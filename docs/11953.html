<html>
<head>
<title>Why Are Phantom Types Useful?</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">为什么幻影类型有用？</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/why-are-phantom-types-useful-cfeceb8a9e81?source=collection_archive---------4-----------------------#2022-04-29">https://betterprogramming.pub/why-are-phantom-types-useful-cfeceb8a9e81?source=collection_archive---------4-----------------------#2022-04-29</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="0d7b" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">使用Elm编程语言</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/a6b7615861f76284fdea08b776e8cfe1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*QCMO7ljujF3UGC2A"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">本·科林斯在<a class="ae kv" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</p></figure><p id="8749" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在这篇文章中，我们将慢慢揭开什么是幻影类型，以及为什么它们可能有用。</p><p id="df41" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们将使用Elm作为编程语言的例子，但是如果你懂一点其他支持类型参数的编程语言，你可能会明白。</p><p id="2cfb" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">首先，让我们从一个定义开始:</p><blockquote class="ls lt lu"><p id="581a" class="kw kx lv ky b kz la jr lb lc ld ju le lw lg lh li lx lk ll lm ly lo lp lq lr ij bi translated">"幻象类型是具有一个或多个未使用的类型参数的自定义类型."</p></blockquote><p id="c077" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这是一个幻影类型的例子。</p><pre class="kg kh ki kj gt lz ma mb mc aw md bi"><span id="6aad" class="me mf iq ma b gy mg mh l mi mj">type Length unit = Length Int</span></pre><p id="2817" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">为了理解这是什么以及为什么它可能有用，我们将从理解他们可以解决的问题开始。</p><p id="d7f3" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">让我们从这段elm代码开始。</p><pre class="kg kh ki kj gt lz ma mb mc aw md bi"><span id="b365" class="me mf iq ma b gy mg mh l mi mj">meter : Int <br/>meter = 1</span><span id="3844" class="me mf iq ma b gy mk mh l mi mj">twoMeters : Int <br/>twoMeters = meter + meter</span><span id="bce2" class="me mf iq ma b gy mk mh l mi mj">kilometer : Int <br/>kilometer = 1</span><span id="23d5" class="me mf iq ma b gy mk mh l mi mj">twoKilometers : Int <br/>twoKilometers = kilometer + kilometer</span></pre><p id="154a" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这完全没问题。然而，在这段代码中有一个错误等待着我们去犯。看看这个:</p><pre class="kg kh ki kj gt lz ma mb mc aw md bi"><span id="4a99" class="me mf iq ma b gy mg mh l mi mj">test : Int <br/>test = meter + kilometer</span><span id="262f" class="me mf iq ma b gy mk mh l mi mj">&gt; test <br/>&gt; 2</span></pre><p id="40d0" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这是不对的。不先换算一下就把一米加到一公里上是没有意义的。发生了什么事？</p><p id="cfca" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">错就错在我们加了两个意思不一样的东西；两个不相容的概念。我们把单位“米”和“公里”混在一起，结果毫无意义。</p><p id="ff19" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">一个可能出现的问题是:“如果不先换算就把一公里加到一米上是没有意义的，怎么可能这样做？”</p><p id="b02f" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这个错误是可能的，因为在编写这个程序时，我们将“米”的概念和“公里”的概念抽象为“整数”的概念。</p><p id="b987" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">抽象是“忘记”或“省略”细节的过程。在这种情况下，我们采用一个概念“长度”，它有一个“单位”和一个“数量”组件，我们将其抽象为一个“整数”，一个只有，因此只能捕获“数量”组件的概念。在这个抽象的过程中，我们“省略”了一个重要的细节，即“单元”组件；决定两个给定长度的加法是否有意义的分量。这就是电脑不阻止你添加“米”和“公里”的原因。它不知道“米”或“公里”，它们是我们抽象出来的“单位”。</p></div><div class="ab cl ml mm hu mn" role="separator"><span class="mo bw bk mp mq mr"/><span class="mo bw bk mp mq mr"/><span class="mo bw bk mp mq"/></div><div class="ij ik il im in"><p id="ecd8" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">好了，我们现在理解了可能出错的原因:在表示概念“长度”时，我们执行了一个抽象步骤，“省略”了“单位”组件。因此，不可能再用不同的单位来区分长度，因此可以添加隐含不同单位的长度。</p><p id="692b" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">让我们试着想出一个防止这种错误发生的方法。</p><p id="72c2" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">记住,“长度”的概念有“单位”和“数量”两部分。整数已经捕获了“数量”部分，所以为了确保我们永远不会将不同单位的长度相加，我们只需要找出一种方法来告诉计算机:</p><ul class=""><li id="e375" class="ms mt iq ky b kz la lc ld lf mu lj mv ln mw lr mx my mz na bi translated">具体“长度”的“单位”是什么。</li><li id="11f3" class="ms mt iq ky b kz nb lc nc lf nd lj ne ln nf lr mx my mz na bi translated">它应该防止两个没有相同“单位”的“长度”相加。</li></ul><p id="76b9" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">如何着手此事？</p><p id="b2c2" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">一种方法是将“单位”和“数量”组件存储在一个<code class="fe ng nh ni ma b">Length</code>数据结构中。然后，在我们组合两个长度之前，我们首先比较它们的“单位”，以确保操作有意义。</p><pre class="kg kh ki kj gt lz ma mb mc aw md bi"><span id="fb8b" class="me mf iq ma b gy mg mh l mi mj">type Unit = Meters | Kilometers</span><span id="c30c" class="me mf iq ma b gy mk mh l mi mj">type Length = Length Unit Int</span><span id="acb1" class="me mf iq ma b gy mk mh l mi mj">add : Length -&gt; Length -&gt; Maybe Length <br/>add (Length unitA a) (Length unitB b) = <br/> if unitA == unitB then <br/>   Just (Length unitA (a + b)) </span><span id="6fc3" class="me mf iq ma b gy mk mh l mi mj"> else <br/>   Nothing</span></pre><p id="12e6" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">如果我们现在犯了一个错误，至少我们不会变得毫无意义。不过，它也有一些缺点。</p><ul class=""><li id="d447" class="ms mt iq ky b kz la lc ld lf mu lj mv ln mw lr mx my mz na bi translated">当我们犯了错误，只有在运行时才变得明显。虽然没有之前那么微妙，但它可能仍然是一个bug。</li><li id="86a5" class="ms mt iq ky b kz nb lc nc lf nd lj ne ln nf lr mx my mz na bi translated">我们必须想出一个特别的方法来处理单元不相同的情况。在这种情况下，我选择返回一个“可能长度”,但我也可以选择返回“结果单位错误长度”或更自定义的内容。</li><li id="e699" class="ms mt iq ky b kz nb lc nc lf nd lj ne ln nf lr mx my mz na bi translated">现在，每个被调用者都必须处理错误情况，即使他们确信自己没有犯任何错误。</li></ul><p id="24e1" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我认为我们可以做得更好。</p><p id="52ca" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">也许我们可以在类型系统中编码“单元”组件。这样我们就可以在运行时完全防止错误发生，所以我们不必处理任何错误情况。</p><p id="c24b" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">让我们通过为每个支持的“单元”定义一个自定义类型来尝试这样做。</p><pre class="kg kh ki kj gt lz ma mb mc aw md bi"><span id="01a5" class="me mf iq ma b gy mg mh l mi mj">type Meters = Meters Int<br/>type Kilometers = Kilometers Int</span><span id="0476" class="me mf iq ma b gy mk mh l mi mj">addMeters : Meters -&gt; Meters -&gt; Meters <br/>addMeters (Meters a) (Meters b) = <br/>   Meters (a + b)<br/> <br/>addKilometers : Kilometers -&gt; Kilometers -&gt; Kilometers <br/>addKilometers (Kilometers a) (Kilometers a) = <br/>   Kilometers (a + b)</span></pre><p id="f87c" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">好的，这是可行的，不太可能意外地把米加到公里上，但仍然是次优的。</p><ul class=""><li id="f37e" class="ms mt iq ky b kz la lc ld lf mu lj mv ln mw lr mx my mz na bi translated">我们希望在“长度”上支持的每个函数都需要为每个支持的“单元”重新实现(例如，如果我们希望支持减法，会发生什么？).所有这些函数都遵循完全相同的结构。不是很干。</li><li id="a542" class="ms mt iq ky b kz nb lc nc lf nd lj ne ln nf lr mx my mz na bi translated">每当我们想要支持一个新的“单元”时，我们需要为那个“单元”重新实现所有支持的“长度”函数。再说一遍，不是很干。</li></ul><p id="1fe2" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们已经得到了我们想要的运行时属性，但是一遍又一遍地重新实现相同功能的成本不是我愿意接受的。也许有一种方法可以概括这一点；只实现所有这些功能一次，并且能够为所有“单元”重用它们。</p><p id="0244" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">让我们再来看看上面定义的类型。</p><pre class="kg kh ki kj gt lz ma mb mc aw md bi"><span id="6fb9" class="me mf iq ma b gy mg mh l mi mj">type Meters = Meters Int <br/>type Kilometers = Kilometers Int</span></pre><p id="d416" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们可以将这些定义理解为预先填充了“单位”成分的“长度”概念的表示。<code class="fe ng nh ni ma b">Meters</code>类型具有“长度”的含义，其中“单位”组件始终为米，“T2”也是如此。有没有办法“拉出”那个预填充的“单元”？我们能不能定义一个有意义的东西“一个‘长度’，其中‘单位’分量是X”。</p><p id="fcbe" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这是幻影类型开始变得有趣的地方。这正是我们要找的。它概括了以前的方法。</p><p id="a81f" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">让我们再来看一下定义:</p><blockquote class="ls lt lu"><p id="9e3f" class="kw kx lv ky b kz la jr lb lc ld ju le lw lg lh li lx lk ll lm ly lo lp lq lr ij bi translated">"幻象类型是具有一个或多个未使用的类型参数的自定义类型."</p></blockquote><p id="6ce3" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">既然我们理解了它们可以解决的问题，我们也可以用一种稍微不同的方式来描述它们。</p><blockquote class="ls lt lu"><p id="3022" class="kw kx lv ky b kz la jr lb lc ld ju le lw lg lh li lx lk ll lm ly lo lp lq lr ij bi translated">"幻影类型可以用来赋予相同的数据结构不同的含义."</p></blockquote><p id="f00d" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">让我们来看看他们的行动:</p><pre class="kg kh ki kj gt lz ma mb mc aw md bi"><span id="7769" class="me mf iq ma b gy mg mh l mi mj">type Length unit = Length Int — (1)</span><span id="f43f" class="me mf iq ma b gy mk mh l mi mj">type Meters = Meters — (2) <br/>type Kilometers = Kilometers — (2)</span><span id="6463" class="me mf iq ma b gy mk mh l mi mj">add : Length unit -&gt; Length unit -&gt; Length unit — (3) <br/>add (Length a) (Length b) = <br/>   Length (a + b)</span></pre><ul class=""><li id="0ee9" class="ms mt iq ky b kz la lc ld lf mu lj mv ln mw lr mx my mz na bi translated">①这是一种幻影式。我们用一个未使用的类型参数<code class="fe ng nh ni ma b">unit</code>定义了一个自定义类型<code class="fe ng nh ni ma b">Length</code>。它的意思就是“一个‘长度’，其中‘单位’分量是X”。类型参数“unit”用作x。</li><li id="79d0" class="ms mt iq ky b kz nb lc nc lf nd lj ne ln nf lr mx my mz na bi translated">(2)我们定义了自定义类型<code class="fe ng nh ni ma b">Meters</code>和<code class="fe ng nh ni ma b">Kilometers</code>，分别代表单位“米”和“公里”。例如，<code class="fe ng nh ni ma b">Length Meters</code>衍生出“长度”的意思，其中“单位”部分是“米”。关键的是，<code class="fe ng nh ni ma b">Length Meters</code>和<code class="fe ng nh ni ma b">Length Kilometers</code>的数据结构完全相同(都是<code class="fe ng nh ni ma b">Length Int</code>)，所以我们可以编写可重用的函数，但类型检查器会将它们视为不同的类型。混合它们会导致类型错误！</li><li id="5bd7" class="ms mt iq ky b kz nb lc nc lf nd lj ne ln nf lr mx my mz na bi translated">(3)<code class="fe ng nh ni ma b">add</code>的类型定义为:“可以添加任意两个长度，只要是同一个单位”。还要注意，因为<code class="fe ng nh ni ma b">Length Meters</code>和<code class="fe ng nh ni ma b">Length Kilometers</code>都与<code class="fe ng nh ni ma b">Length unit</code>兼容，所以我们可以对这两种类型重用这个算法。</li></ul><p id="7133" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">酷，这种方法没有以前方法的缺点:</p><ul class=""><li id="d7b4" class="ms mt iq ky b kz la lc ld lf mu lj mv ln mw lr mx my mz na bi translated">单元在运行时不存在，所以开销更少，没有运行时错误处理！</li><li id="f2cc" class="ms mt iq ky b kz nb lc nc lf nd lj ne ln nf lr mx my mz na bi translated">我们可以编写适用于任何单位的函数。没有重复实现每个单元的每个功能！</li></ul></div><div class="ab cl ml mm hu mn" role="separator"><span class="mo bw bk mp mq mr"/><span class="mo bw bk mp mq mr"/><span class="mo bw bk mp mq"/></div><div class="ij ik il im in"><p id="d606" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">为了更好地了解幻影类型的实际使用情况，我将列出两个常见的真实用例:</p><ol class=""><li id="118d" class="ms mt iq ky b kz la lc ld lf mu lj mv ln mw lr nj my mz na bi translated">措施</li></ol><p id="6bbb" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们在这篇文章中所举的例子是一个参数化长度的“单位”部分的例子，但是这种技术可以用于任何测量。</p><p id="925c" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这里我们看到一个<code class="fe ng nh ni ma b">Quantity</code>类型，它可以用来表示任何数量，同时仍然防止数量的混合。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nk nl l"/></div></figure><p id="183e" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们看到这种技术在<a class="ae kv" href="https://package.elm-lang.org/packages/ianmackenzie/elm-units/latest/" rel="noopener ugc nofollow" target="_blank"> elm-units </a>包中被广泛使用，它是<a class="ae kv" href="https://package.elm-lang.org/packages/ianmackenzie/elm-3d-scene/latest/" rel="noopener ugc nofollow" target="_blank"> elm-3d-scene </a>的支柱。</p><p id="7b51" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">2.本能冲动</p><p id="86bd" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">数据库实体通常有相同类型的id(例如<code class="fe ng nh ni ma b">String</code>或<code class="fe ng nh ni ma b">Int</code>)，但是<code class="fe ng nh ni ma b">userId</code>和<code class="fe ng nh ni ma b">bookId</code>的含义不同。我们可以使用幻象类型来分离这些概念，同时共享适用于任何id的函数。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nk nl l"/></div></figure></div><div class="ab cl ml mm hu mn" role="separator"><span class="mo bw bk mp mq mr"/><span class="mo bw bk mp mq mr"/><span class="mo bw bk mp mq"/></div><div class="ij ik il im in"><p id="f6a7" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">除了这些常见的用例，可能还有更多使用幻影类型的情况。</p><p id="e790" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">如果你感兴趣，你可以看看这种技术的一个更高级的版本，叫做幻影构建模式，作者是<a class="ae kv" href="https://jfmengels.net/" rel="noopener ugc nofollow" target="_blank">耶鲁安·恩格斯</a>:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nm nl l"/></div></figure></div></div>    
</body>
</html>