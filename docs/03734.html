<html>
<head>
<title>Prefer Composition Over Inheritance</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">偏好组合而非继承</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/prefer-composition-over-inheritance-1602d5149ea1?source=collection_archive---------3-----------------------#2020-03-02">https://betterprogramming.pub/prefer-composition-over-inheritance-1602d5149ea1?source=collection_archive---------3-----------------------#2020-03-02</a></blockquote><div><div class="fc ii ij ik il im"/><div class="in io ip iq ir"><div class=""/><div class=""><h2 id="ffeb" class="pw-subtitle-paragraph jr it iu bd b js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki dk translated">遗产会变得很混乱。构图灵活</h2></div><figure class="kk kl km kn gu ko gi gj paragraph-image"><div role="button" tabindex="0" class="kp kq di kr bf ks"><div class="gi gj kj"><img src="../Images/ca0b2e512968bd4e0f98b4a6509a4f5d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*obUc-OHfPGO4ojLGmpO5uQ.jpeg"/></div></div><p class="kv kw gk gi gj kx ky bd b be z dk translated"><a class="ae kz" href="https://unsplash.com/@jasonhk1920?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">黄志刚</a>在<a class="ae kz" href="https://unsplash.com/s/photos/composition?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍照</p></figure><p id="d18d" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">在三个OOP原则中，继承可能是封装后你开始理解的第二个原则。这是一个非常基本的想法——您可以扩充现有的类，同时仍然使用父类的所有功能。很简单，对吧？</p><p id="aa75" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">有趣的是，继承最近已经有点失宠，取而代之的是组合的概念。继承是一个强大的特性，但是它可能会失去控制。让我们看一个例子来说明这一点。</p></div><div class="ab cl lw lx hy ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="in io ip iq ir"><h1 id="5838" class="md me iu bd mf mg mh mi mj mk ml mm mn ka mo kb mp kd mq ke mr kg ms kh mt mu bi translated">失控继承</h1><p id="1107" class="pw-post-body-paragraph la lb iu lc b ld mv jv lf lg mw jy li lj mx ll lm ln my lp lq lr mz lt lu lv in bi translated">假设你拥有一家披萨店。你想写一个系统来管理你所有的比萨饼。所以，你从一个基类开始:</p><figure class="kk kl km kn gu ko gi gj paragraph-image"><div role="button" tabindex="0" class="kp kq di kr bf ks"><div class="gi gj na"><img src="../Images/a9a4e0647ccaf06a1a839620e9cafd30.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*UZ5ESki0w03saEJmNANO3w.png"/></div></div><p class="kv kw gk gi gj kx ky bd b be z dk translated">一堂简单的披萨课</p></figure><p id="0d99" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">当然，这是一个很好的抽象类，所以我们必须从它派生出来。我们假设所有自尊的披萨都有番茄酱，因此我们将创建:</p><figure class="kk kl km kn gu ko gi gj paragraph-image"><div role="button" tabindex="0" class="kp kq di kr bf ks"><div class="gi gj na"><img src="../Images/4d3c3c7db27d9e30d43521ff4d6ce99b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*bsbjBz3MhqahqhP3XvUY4A.png"/></div></div><p class="kv kw gk gi gj kx ky bd b be z dk translated">后代阶级</p></figure><p id="f462" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">当然，我们还需要奶酪:</p><figure class="kk kl km kn gu ko gi gj paragraph-image"><div role="button" tabindex="0" class="kp kq di kr bf ks"><div class="gi gj na"><img src="../Images/a9d1dadb9c3357cdab163feb2725a089.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*MyvHhJscLkuCTDcBH2gbFw.png"/></div></div><p class="kv kw gk gi gj kx ky bd b be z dk translated">又一个后代</p></figure><p id="8aaa" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">太好了。但是你的顾客会想要更多的配料。让我们从意大利香肠和蘑菇开始。我们最后会得到:</p><figure class="kk kl km kn gu ko gi gj paragraph-image"><div role="button" tabindex="0" class="kp kq di kr bf ks"><div class="gi gj na"><img src="../Images/01d87d32bf32d181caed8b18ce751bdf.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*mUlhZTc32TSsNKiaMNzkgw.png"/></div></div><p class="kv kw gk gi gj kx ky bd b be z dk translated">甚至更多的后代。这开始变得复杂了</p></figure><p id="a241" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">当然，有些客户可能两者都想要，所以您需要:</p><figure class="kk kl km kn gu ko gi gj paragraph-image"><div role="button" tabindex="0" class="kp kq di kr bf ks"><div class="gi gj nb"><img src="../Images/3cb6d05fe799a4cd35c49367ccd223d3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ZZmNkDWu6frCbFiH5mCOGg.png"/></div></div><p class="kv kw gk gi gj kx ky bd b be z dk translated">好吧，这有点过了</p></figure><p id="3f0d" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">现在，让我们加入香肠、洋葱、凤尾鱼和黑橄榄。</p><p id="bfa7" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">嗯。事情会变得很复杂，不是吗？</p><p id="adcb" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">使用继承，你会很快得到一个更深更广的继承模型。您的属性不能涵盖添加更多成分时可能出现的所有情况。</p><p id="5834" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">整个设计很快变得笨拙而不灵活。当老板决定把菠萝加到披萨上时，你将有很多代码要写(撇开披萨上的菠萝是一种完全令人厌恶的事实不谈)。</p></div><div class="ab cl lw lx hy ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="in io ip iq ir"><h1 id="bc33" class="md me iu bd mf mg mh mi mj mk ml mm mn ka mo kb mp kd mq ke mr kg ms kh mt mu bi translated">问题</h1><p id="2250" class="pw-post-body-paragraph la lb iu lc b ld mv jv lf lg mw jy li lj mx ll lm ln my lp lq lr mz lt lu lv in bi translated">继承很酷，但也有它的问题。</p><ul class=""><li id="e13e" class="nc nd iu lc b ld le lg lh lj ne ln nf lr ng lv nh ni nj nk bi translated">正如我提到的，它鼓励了一大堆笨拙的子类。你最终可能会得到很多很多可能满足也可能不满足你需求的课程。</li><li id="bdf9" class="nc nd iu lc b ld nl lg nm lj nn ln no lr np lv nh ni nj nk bi translated">谁也不知道超级阶级会做什么。也许它在你控制之外的一个模块中，并且超类有很多依赖项。创造它会导致你不想要或没有准备好的副作用。</li><li id="ec13" class="nc nd iu lc b ld nl lg nm lj nn ln no lr np lv nh ni nj nk bi translated">一旦被部署，类的层次结构就很难改变。你可能会被没人点的披萨困住。在飞行中创造一个新的、特别的比萨饼是不可能的。你不能改变一个超类而不冒破坏用户子类的风险。</li></ul><p id="2c6f" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">但是有更好的方法。不如我们“合成”一个披萨:</p><figure class="kk kl km kn gu ko gi gj paragraph-image"><div role="button" tabindex="0" class="kp kq di kr bf ks"><div class="gi gj na"><img src="../Images/bf25592775b9fd46f76985bd808bf709.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*vXtnMLMau9UmDT2w7LTN0g.png"/></div></div><p class="kv kw gk gi gj kx ky bd b be z dk translated">制作披萨的更好方法</p></figure><p id="2b40" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">这是一个很好的例子，说明为什么你应该更喜欢组合而不是继承。</p><p id="03cd" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">我们披萨的构图版本很简单。它更加灵活，允许多种奶酪类型、酱料类型和几乎无限的配料集合。</p><p id="2fe6" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">上面的例子是一个非常简单的例子，它可以很容易地拥有私有字段、公共属性和一个构造函数，这样就可以一次性创建所有这些属性。它可能看起来像这样:</p><figure class="kk kl km kn gu ko gi gj paragraph-image"><div role="button" tabindex="0" class="kp kq di kr bf ks"><div class="gi gj nq"><img src="../Images/2307003013c149d27a63b222699c0b5e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*df2SvLjMPuQa-f6ijVzs5g.png"/></div></div><p class="kv kw gk gi gj kx ky bd b be z dk translated">这才是披萨！</p></figure><p id="8ccb" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">你很难描述一个这个类不能包含的比萨饼。如果您需要扩展什么是比萨饼的定义，您可以很容易地做到这一点，而不会影响现有的对<code class="fe nr ns nt nu b">Pizza</code>类的使用。</p><p id="2b52" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">这个类完成了我们上面创建的整个继承结构的工作。组合允许你在一个类中，通过继承做2^n类可能做的事情。它还提供了一个更简单、更易测试的代码库。</p></div><div class="ab cl lw lx hy ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="in io ip iq ir"><h1 id="2f5c" class="md me iu bd mf mg mh mi mj mk ml mm mn ka mo kb mp kd mq ke mr kg ms kh mt mu bi translated">界面组成</h1><p id="21f4" class="pw-post-body-paragraph la lb iu lc b ld mv jv lf lg mw jy li lj mx ll lm ln my lp lq lr mz lt lu lv in bi translated">另一种看待继承复合问题的方式是通过接口。(<a class="ae kz" href="https://medium.com/better-programming/code-against-interfaces-not-implementations-37b30e7ab992" rel="noopener">它总是回到界面，不是吗？</a>)</p><p id="db13" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">如果你熟悉实体编码原则，你会知道接口分离原则声明你应该保持你的接口小而简单。</p><p id="6772" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">如果你这样做了，它们可以被用来使用那些接口而不是继承来组成类，这又会带来更多的灵活性。</p><p id="f931" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">注意，据说<em class="nv">更倾向于</em> <strong class="lc iv"> <em class="nv"> </em> </strong>成分多于继承。它并没有说<em class="nv">总是</em> <strong class="lc iv"> <em class="nv"> </em> </strong>用构图超过继承。继承有它的位置——在设计一个类框架时，它通常不是最好的选择。</p><p id="1eeb" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">比如拿<code class="fe nr ns nt nu b">Vehicle</code>这个经典的例子。创建使用继承来定义车辆、添加车轮和转向方法的例子是很常见的。</p><p id="4098" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">这时来了一艘船，你不知道该怎么办。嗯，接口的组合可以考虑这种事情。</p><p id="fea6" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">请考虑以下情况:</p><figure class="kk kl km kn gu ko gi gj paragraph-image"><div role="button" tabindex="0" class="kp kq di kr bf ks"><div class="gi gj na"><img src="../Images/fc5a3afcac86d8a147990499ac334720.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*51rFG-qCluQlsJNzFlVynQ.png"/></div></div><p class="kv kw gk gi gj kx ky bd b be z dk translated">界面组合解决了经典的车辆问题</p></figure><p id="8942" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">这里我们有一个接口集合，可以放在一起——如果你愿意的话，可以组合在一起——来创建任何类型的交通工具，甚至是一艘船。请注意，<code class="fe nr ns nt nu b">Boat</code>和<code class="fe nr ns nt nu b">Car</code>在他们的声明中并没有太大的不同，除了汽车有轮子，可以<code class="fe nr ns nt nu b">brake</code>。</p><p id="e1ea" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">可用的各种接口足以定义几乎任何车辆的功能，如果没有，只需添加另一个接口就很简单了。</p><p id="c624" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">在上面的例子中，您可能会考虑添加<code class="fe nr ns nt nu b">ILight</code>和<code class="fe nr ns nt nu b">ITrailerHitch</code>作为接口，供能够使用它们的车辆使用。两者都可以相对容易地添加和组合，对类框架的现有用户来说没有痛苦。</p></div><div class="ab cl lw lx hy ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="in io ip iq ir"><h1 id="202e" class="md me iu bd mf mg mh mi mj mk ml mm mn ka mo kb mp kd mq ke mr kg ms kh mt mu bi translated">结论</h1><p id="bd4d" class="pw-post-body-paragraph la lb iu lc b ld mv jv lf lg mw jy li lj mx ll lm ln my lp lq lr mz lt lu lv in bi translated">因此，出于多种原因，组合物变得更优选:</p><ul class=""><li id="612d" class="nc nd iu lc b ld le lg lh lj ne ln nf lr ng lv nh ni nj nk bi translated">您的组合类可以很容易地添加到没有反响。也许你想给<code class="fe nr ns nt nu b">Pizza</code>添加一种新的奶酪——没问题。也许你决定要添加特定种类的外壳——这可以很容易地添加，而不用担心会破坏现有的<code class="fe nr ns nt nu b">Pizza</code>用途。</li><li id="3e4d" class="nc nd iu lc b ld nl lg nm lj nn ln no lr np lv nh ni nj nk bi translated">组合允许您将组件的创建推迟到需要的时候，或者如果不需要的话，根本不创建组件。也许你的<code class="fe nr ns nt nu b">Car</code>在白天行驶，灯是不需要的，所以它们甚至不需要被创造。</li><li id="4fb8" class="nc nd iu lc b ld nl lg nm lj nn ln no lr np lv nh ni nj nk bi translated">您还可以设计您的类，以便在需要时可以动态更改组件。你不能用继承来做到这一点。一旦你创造了<code class="fe nr ns nt nu b">TAnchoviePeppersMozarellaCheeseTomatoSauceThinCrustPizza</code>，你就会坚持下去。如果需要的话,<code class="fe nr ns nt nu b">Pizza</code>可以随时改变外壳类型。</li></ul><p id="5dc9" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">比起继承，更喜欢组合，这样你会有更灵活、可扩展和可测试的代码。</p></div></div>    
</body>
</html>