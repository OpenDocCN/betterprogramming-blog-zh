<html>
<head>
<title>Recoil: A New State Management Library Moving Beyond Redux and the Context API</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">反冲:超越Redux和上下文API的新状态管理库</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/recoil-a-new-state-management-library-moving-beyond-redux-and-the-context-api-63794c11b3a5?source=collection_archive---------2-----------------------#2020-06-16">https://betterprogramming.pub/recoil-a-new-state-management-library-moving-beyond-redux-and-the-context-api-63794c11b3a5?source=collection_archive---------2-----------------------#2020-06-16</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="8615" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">反冲的全面介绍，React应用程序的实验性状态管理库</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/e1403f38261687332aef20a55427862d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Xt3Vgl7DJq1P2qAuo_fYfw.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">状态管理的反冲数据流图—作者照片。</p></figure><p id="c23f" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">自2015年5月以来，<a class="ae lu" href="https://github.com/reduxjs/redux" rel="noopener ugc nofollow" target="_blank"> Redux </a>是JavaScript应用程序的可预测状态容器。它是真理的单一来源，它的状态是只读的，并且用纯函数进行更改。Redux有一个很好的浏览器调试扩展，方便调试。缺点是复杂的样板文件。可能与React即将推出的并发模式不兼容。</p><p id="06f6" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated"><a class="ae lu" href="https://reactjs.org/docs/context.html" rel="noopener ugc nofollow" target="_blank">上下文API </a>由React 16.3于2018年5月推出。与React挂钩(<code class="fe lv lw lx ly b">useContext</code>)一起，它提供了一种通过React组件树传递数据的方法，而不必在每一层手动传递道具。它旨在共享全局数据，例如当前已验证的用户、主题或首选语言。上下文API和React挂钩提供了一种新的状态管理方法。调试是困难的，并且在呈现多个动态项目时存在性能问题。</p><p id="0123" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">那么应该用Redux还是上下文API呢？</p><p id="0fbf" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">经过几年的斗争，许多文章宣布Redux已经死了，还没有死，等等。，两者都很活跃，并被许多应用程序采用。还没有明确的赢家。</p><p id="fdcc" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">以下是NPM趋势比较。这两种工具仍在大量使用:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi lz"><img src="../Images/689229a40a1e795730c3f145bd1111e1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*OR5PrkO6ko3NOHUAlCY5ZA.png"/></div></div></figure><p id="ad2d" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">现在我们有了一个新人。</p><p id="5810" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated"><a class="ae lu" href="https://recoiljs.org/" rel="noopener ugc nofollow" target="_blank">反冲</a>是脸书开发的一个全新的实验性JavaScript状态管理库。2020年5月起上市。</p></div><div class="ab cl ma mb hx mc" role="separator"><span class="md bw bk me mf mg"/><span class="md bw bk me mf mg"/><span class="md bw bk me mf"/></div><div class="im in io ip iq"><h1 id="be2e" class="mh mi it bd mj mk ml mm mn mo mp mq mr jz ms ka mt kc mu kd mv kf mw kg mx my bi translated"><strong class="ak">解决的问题</strong></h1><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi mz"><img src="../Images/afb04d04d74937f291254db4b09dda13.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*JTaM9-_QAAvOWUvpio6ogg.png"/></div></div></figure><p id="7cf4" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">反冲解决了大型应用程序在使用现有上下文API时遇到的许多问题:</p><ul class=""><li id="95e9" class="na nb it la b lb lc le lf lh nc ll nd lp ne lt nf ng nh ni bi translated">组件状态只能通过将其推至公共祖先来共享，但这可能包括一个巨大的树，然后需要重新呈现。</li><li id="565b" class="na nb it la b lb nj le nk lh nl ll nm lp nn lt nf ng nh ni bi translated">上下文只能存储单个值，而不是一组不确定的值，每个值都有自己的使用者。</li><li id="947d" class="na nb it la b lb nj le nk lh nl ll nm lp nn lt nf ng nh ni bi translated">这两者都使得将树的顶部(状态必须存在的地方)与树的叶子(使用状态的地方)进行代码分离变得很困难。</li></ul><p id="add2" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">反冲定义了一个正交的有向图，但它也是固有的，并附加到React组件树(参见顶部的反冲数据流图)。在这个数据流图中，状态变化从图的根(原子)通过派生状态的纯函数(选择器)流入组件。</p><p id="3081" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">通过这种架构设计，反冲使用一种反应式的解决方案来解决上下文API问题。这种解决方案易于使用，可以兼容并发模式和其他可用的React新特性。此外，更高级的调试器选项正在开发中，如时间旅行、撤销功能、持久数据等。</p></div><div class="ab cl ma mb hx mc" role="separator"><span class="md bw bk me mf mg"/><span class="md bw bk me mf mg"/><span class="md bw bk me mf"/></div><div class="im in io ip iq"><h1 id="c631" class="mh mi it bd mj mk ml mm mn mo mp mq mr jz ms ka mt kc mu kd mv kf mw kg mx my bi translated"><strong class="ak">反冲设置</strong></h1><p id="279a" class="pw-post-body-paragraph ky kz it la b lb no ju ld le np jx lg lh nq lj lk ll nr ln lo lp ns lr ls lt im bi translated">我们来看看<a class="ae lu" href="https://medium.com/better-programming/10-fun-facts-about-create-react-app-eb7124aa3785" rel="noopener"> Create React App </a> ( <code class="fe lv lw lx ly b">npx create-react-app my-app</code>)中反冲是如何工作的。首先用命令<code class="fe lv lw lx ly b">npm i recoil</code>安装后坐力。然后这个包成为<code class="fe lv lw lx ly b">package.json</code>中<code class="fe lv lw lx ly b"><a class="ae lu" href="https://medium.com/better-programming/package-jsons-dependencies-in-depth-a1f0637a3129" rel="noopener">dependencies</a></code>的一部分:</p><pre class="kj kk kl km gt nt ly nu nv aw nw bi"><span id="2ae9" class="nx mi it ly b gy ny nz l oa ob">"dependencies": {<br/>  "recoil": "0.1.2"<br/>}</span></pre><p id="9b8b" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">将<code class="fe lv lw lx ly b">src/App.css</code>更改为最小化样式:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oc od l"/></div></figure><p id="0499" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">使用反冲钩的部件必须用<code class="fe lv lw lx ly b">&lt;RecoilRoot&gt;</code>包裹。在下面的<code class="fe lv lw lx ly b">src/index.js</code>中，在第10行和第12行添加<code class="fe lv lw lx ly b">RecoilRoot</code>:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oc od l"/></div></figure><p id="3eae" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">现在我们准备看反冲的例子。</p></div><div class="ab cl ma mb hx mc" role="separator"><span class="md bw bk me mf mg"/><span class="md bw bk me mf mg"/><span class="md bw bk me mf"/></div><div class="im in io ip iq"><h1 id="9225" class="mh mi it bd mj mk ml mm mn mo mp mq mr jz ms ka mt kc mu kd mv kf mw kg mx my bi translated">原子</h1><p id="57f8" class="pw-post-body-paragraph ky kz it la b lb no ju ld le np jx lg lh nq lj lk ll nr ln lo lp ns lr ls lt im bi translated">我们想要创建以下用户界面。它显示初始状态<code class="fe lv lw lx ly b">0</code>。每点击一次<code class="fe lv lw lx ly b">Increase</code>按钮，计数将增加1，每点击一次<code class="fe lv lw lx ly b">Decrease</code>按钮，计数将减少1。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi oe"><img src="../Images/8e1cc71656e2deb6d65ea872b18a63e5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*i1-RniYENVqHeA3xme8V5w.png"/></div></div></figure><p id="2066" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">我们可以使用<code class="fe lv lw lx ly b">useState</code>在<code class="fe lv lw lx ly b">src/App.js</code>中实现这一点:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oc od l"/></div></figure><p id="86be" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">现在我们用反冲的原子做同样的用户界面。原子<code class="fe lv lw lx ly b">countState</code>在第5-8行定义。它由11号线使用。就是这样。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oc od l"/></div></figure><p id="2378" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">什么是原子？</p><p id="656b" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">它是一种共享的、可写的反冲状态，包括它所管理的一段数据。组件可以订阅原子，然后在相关原子改变时重新呈现。</p><p id="f2e7" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">一个原子有两个支柱:</p><ul class=""><li id="a3fe" class="na nb it la b lb lc le lf lh nc ll nd lp ne lt nf ng nh ni bi translated"><code class="fe lv lw lx ly b">key</code>:用于内部识别原子的字符串。这个字符串相对于整个应用程序中的其他原子和选择器应该是唯一的。</li><li id="5401" class="na nb it la b lb nj le nk lh nl ll nm lp nn lt nf ng nh ni bi translated"><code class="fe lv lw lx ly b">default</code>:原子的初始值。</li></ul><p id="a83f" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">以下是与原子相互作用的钩子:</p><ul class=""><li id="37ba" class="na nb it la b lb lc le lf lh nc ll nd lp ne lt nf ng nh ni bi translated"><code class="fe lv lw lx ly b"><a class="ae lu" href="https://recoiljs.org/docs/api-reference/core/useRecoilState" rel="noopener ugc nofollow" target="_blank">useRecoilState()</a></code>:这个钩子用来读写一个原子。它向原子订阅调用组件。</li><li id="5a94" class="na nb it la b lb nj le nk lh nl ll nm lp nn lt nf ng nh ni bi translated">这个钩子用来读取一个原子。它向原子订阅调用组件。</li><li id="763b" class="na nb it la b lb nj le nk lh nl ll nm lp nn lt nf ng nh ni bi translated"><code class="fe lv lw lx ly b"><a class="ae lu" href="https://recoiljs.org/docs/api-reference/core/useSetRecoilState" rel="noopener ugc nofollow" target="_blank">useSetRecoilState()</a></code>:这个钩子用来写一个原子。</li><li id="f559" class="na nb it la b lb nj le nk lh nl ll nm lp nn lt nf ng nh ni bi translated"><code class="fe lv lw lx ly b"><a class="ae lu" href="https://recoiljs.org/docs/api-reference/core/useResetRecoilState" rel="noopener ugc nofollow" target="_blank">useResetRecoilState()</a></code>:这个钩子用来重置一个原子到它的默认值。</li><li id="2f00" class="na nb it la b lb nj le nk lh nl ll nm lp nn lt nf ng nh ni bi translated"><code class="fe lv lw lx ly b"><a class="ae lu" href="https://recoiljs.org/docs/api-reference/core/useRecoilCallback" rel="noopener ugc nofollow" target="_blank">useRecoilCallback()</a></code>:这个钩子用来构造一个回调函数，这个回调函数可以读取一个原子并异步更新它。</li></ul></div><div class="ab cl ma mb hx mc" role="separator"><span class="md bw bk me mf mg"/><span class="md bw bk me mf mg"/><span class="md bw bk me mf"/></div><div class="im in io ip iq"><h1 id="b2bf" class="mh mi it bd mj mk ml mm mn mo mp mq mr jz ms ka mt kc mu kd mv kf mw kg mx my bi translated">选择器</h1><p id="3a79" class="pw-post-body-paragraph ky kz it la b lb no ju ld le np jx lg lh nq lj lk ll nr ln lo lp ns lr ls lt im bi translated">原子能很好地储存状态。选择器是用于计算派生状态的纯函数。选择器避免冗余状态，通常不需要归约器来保持状态同步和有效。</p><p id="8bbf" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">正确的设计是使用原子来存储最小的状态集，而其他所有东西都作为原子的函数来有效地计算。组件可以像原子一样订阅选择器，当选择器派生的状态改变时，组件将被重新呈现。</p><p id="1bc5" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">什么是选择器？根据<a class="ae lu" href="https://recoiljs.org/docs/introduction/core-concepts/" rel="noopener ugc nofollow" target="_blank">官方文件</a>:</p><blockquote class="of og oh"><p id="5437" class="ky kz oi la b lb lc ju ld le lf jx lg oj li lj lk ok lm ln lo ol lq lr ls lt im bi translated">“选择器是一个纯粹的函数，它接受原子或其他选择器作为输入。当这些上游原子或选择器被更新时，选择器功能将被重新评估。”</p></blockquote><p id="4cf9" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">选择器具有以下特性:</p><ul class=""><li id="1731" class="na nb it la b lb lc le lf lh nc ll nd lp ne lt nf ng nh ni bi translated"><code class="fe lv lw lx ly b">key</code>:用于内部识别原子的字符串。这个字符串相对于整个应用程序中的其他原子和选择器应该是唯一的。</li><li id="15e8" class="na nb it la b lb nj le nk lh nl ll nm lp nn lt nf ng nh ni bi translated"><code class="fe lv lw lx ly b">get</code>:作为对象传递的函数<code class="fe lv lw lx ly b">{ get }</code>，其中<code class="fe lv lw lx ly b">get</code>是从其他原子或选择器检索值的函数。传递给该函数的所有原子或选择器都将被隐式地添加到选择器的依赖列表中。</li><li id="6abb" class="na nb it la b lb nj le nk lh nl ll nm lp nn lt nf ng nh ni bi translated"><code class="fe lv lw lx ly b">set?</code>:返回新的可写状态的可选函数。它作为一个对象、<code class="fe lv lw lx ly b">{ get, set }</code>和一个新值被传递。<code class="fe lv lw lx ly b">get</code>是从其他原子或选择器中检索值的函数。<code class="fe lv lw lx ly b">set</code>是设置原子值的函数，其中第一个参数是原子名，第二个参数是新值。</li></ul><p id="5223" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">我们添加了一个选择器来生成<code class="fe lv lw lx ly b">src/App.js</code>中的派生状态:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oc od l"/></div></figure><p id="74ea" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">第10-13行上的选择器定义了第17行使用的派生的<code class="fe lv lw lx ly b">doubleCountState</code>。该值在第23行显示为双计数值。</p><p id="f358" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">可选地，选择器可以设置原子值。我们在用户界面中添加了一个输入字段。它反映了<code class="fe lv lw lx ly b">doubleCountState</code>选择器的状态。当它得到用户输入时，这个新值被设置为<code class="fe lv lw lx ly b">countState</code>原子状态。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi om"><img src="../Images/8ab68532af25b8a7a1c0ab13ca57ed5e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*k4xvGYGwmxcx-smwnf18rw.png"/></div></div></figure><p id="198c" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">这里有一个<code class="fe lv lw lx ly b">src/App.js</code>的例子:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oc od l"/></div></figure><p id="560b" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">第15-19行上的选择器定义了第24行使用的派生<code class="fe lv lw lx ly b">inputState</code>。它的值与选择器的值相同:<code class="fe lv lw lx ly b">doubleCountState</code>(在第17行定义)。</p><p id="0484" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">当用户更改输入值时，<code class="fe lv lw lx ly b">onChange</code>(第29行)将调用<code class="fe lv lw lx ly b">setInput</code>(第24行)，然后设置<code class="fe lv lw lx ly b">countState</code>原子(第18行)。原子变化将导致每个相关值的重新呈现。</p></div><div class="ab cl ma mb hx mc" role="separator"><span class="md bw bk me mf mg"/><span class="md bw bk me mf mg"/><span class="md bw bk me mf"/></div><div class="im in io ip iq"><h1 id="c090" class="mh mi it bd mj mk ml mm mn mo mp mq mr jz ms ka mt kc mu kd mv kf mw kg mx my bi translated">异步选择器</h1><p id="1580" class="pw-post-body-paragraph ky kz it la b lb no ju ld le np jx lg lh nq lj lk ll nr ln lo lp ns lr ls lt im bi translated">反冲提供了一种通过数据流图将状态(原子)和派生状态(选择器)映射到反应组件的方法。如果选择器中的<code class="fe lv lw lx ly b">get</code>函数是异步的怎么办？它的工作方式与同步数据流相同。简单地让<code class="fe lv lw lx ly b">get</code>函数返回一个承诺值。</p><p id="9a0b" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">下面是修改后的<code class="fe lv lw lx ly b">src/App.js</code>:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oc od l"/></div></figure><p id="1e5a" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">在第12-18行，我们重写了<code class="fe lv lw lx ly b">get</code>函数来返回一个承诺。其他一切都保持不变。</p><p id="f3be" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">事实上，如果您用下面的代码片段替换第12-18行来等待承诺，它也可以工作:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oc od l"/></div></figure><p id="3188" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">等一下。运行<code class="fe lv lw lx ly b">npm start</code>，我们遇到这个错误:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi on"><img src="../Images/bcb93f549b0ce5642c74d078ba41f523.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*MUEC0JP-bC-UKpSmm8oKRA.png"/></div></div></figure><p id="419d" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated"><code class="fe lv lw lx ly b">RecoilRoot</code>异步选择器需要一个后备用户界面。我们将其添加到第12行和第14行的<code class="fe lv lw lx ly b">src/index.js</code>:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oc od l"/></div></figure><p id="a528" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">现在，它工作了！</p><p id="b021" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">当事情变得动态时，拥有一个<code class="fe lv lw lx ly b">ErrorBoundary</code>(第11行和第15行)总是一个好主意。前一篇文章中详细介绍了如何创建误差边界。</p></div><div class="ab cl ma mb hx mc" role="separator"><span class="md bw bk me mf mg"/><span class="md bw bk me mf mg"/><span class="md bw bk me mf"/></div><div class="im in io ip iq"><h1 id="a418" class="mh mi it bd mj mk ml mm mn mo mp mq mr jz ms ka mt kc mu kd mv kf mw kg mx my bi translated">反冲极限</h1><p id="3475" class="pw-post-body-paragraph ky kz it la b lb no ju ld le np jx lg lh nq lj lk ll nr ln lo lp ns lr ls lt im bi translated">你在你的项目中使用了<a class="ae lu" href="https://www.npmjs.com/package/eslint-plugin-react-hooks" rel="noopener ugc nofollow" target="_blank">eslint-plugin-react-hooks</a>吗？如果是，建议将<code class="fe lv lw lx ly b">useRecoilCallback</code>添加到<code class="fe lv lw lx ly b">additionalHooks</code>列表中(第9行)。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oc od l"/></div></figure></div><div class="ab cl ma mb hx mc" role="separator"><span class="md bw bk me mf mg"/><span class="md bw bk me mf mg"/><span class="md bw bk me mf"/></div><div class="im in io ip iq"><h1 id="c063" class="mh mi it bd mj mk ml mm mn mo mp mq mr jz ms ka mt kc mu kd mv kf mw kg mx my bi translated">结论</h1><p id="09c6" class="pw-post-body-paragraph ky kz it la b lb no ju ld le np jx lg lh nq lj lk ll nr ln lo lp ns lr ls lt im bi translated">反冲是最新的国家管理图书馆提供的脸书。尽管它仍处于试验阶段，但它展示了许多有希望取代状态管理上下文API的特性。</p><p id="41a5" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">我们已经使用反冲有一段时间了。它易于使用，并允许我们使用简单的语法在多个组件/文件之间共享状态。这本故事书包括几个使用反冲的例子。</p><p id="448e" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">原子和选择器的状态可以是已定义的或未定义的、原语值或对象值。选择器的值是从原子或其他选择器自动派生的。</p><p id="3105" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">还有各种构造原子和选择器的方法。根据编程逻辑，它们可以被分组到一个文件中，或者被分类到几个文件中。反冲提供了从现有技术约束中的自由。</p><p id="dcad" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">编码快乐！</p><p id="e82d" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">感谢阅读。我希望这有所帮助。你可以在这里看到我的其他媒体出版物<a class="ae lu" href="https://medium.com/@jenniferfubook/jennifer-fus-web-development-publications-1a887e4454af" rel="noopener">。</a></p><p id="fb1a" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated"><em class="oi">注:Jonathan Ma对本文部分内容有贡献。</em></p></div></div>    
</body>
</html>