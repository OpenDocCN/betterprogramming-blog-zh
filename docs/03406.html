<html>
<head>
<title>How to Avoid Tedious CSS and XPath Queries in End-to-End and Component Tests</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何在端到端和组件测试中避免繁琐的CSS和XPath查询</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/how-to-avoid-tedious-css-and-xpath-queries-in-end-to-end-and-component-tests-732c5b86f2f6?source=collection_archive---------13-----------------------#2020-02-07">https://betterprogramming.pub/how-to-avoid-tedious-css-and-xpath-queries-in-end-to-end-and-component-tests-732c5b86f2f6?source=collection_archive---------13-----------------------#2020-02-07</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="a152" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">改善前端测试的五个技巧</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/734c5d47455c861bd35a8af987ece42b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*jNu6u0bH5uvLmdzr"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">由<a class="ae ky" href="https://unsplash.com/@gcalebjones?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">凯勒·琼斯</a>在<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</p></figure><p id="7b20" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">组件测试和端到端测试有一些共同点。下面是我们所关注的两种测试的简要概述:</p><ol class=""><li id="ed46" class="lv lw it lb b lc ld lf lg li lx lm ly lq lz lu ma mb mc md bi translated">组件测试(有时简称为<em class="me">单元测试</em>)开发成本低廉，易于执行和调试，因为它们隔离了故障。此外，它们通常可以在没有浏览器的情况下运行。示例框架:Jest、Mocha。</li><li id="ade6" class="lv lw it lb b lc mf lf mg li mh lm mi lq mj lu ma mb mc md bi translated"><strong class="lb iu">端到端(e2e)测试</strong>模拟真实的用户场景，这允许您快速发现错误。与单元测试相比，这些测试的执行需要更长的时间，并且可能更加复杂。另一方面，端到端测试为您的应用程序按预期工作提供了更高的有效性。示例框架:量角器，硒。</li></ol><p id="2362" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">最常见的事情之一是在DOM中找到一些元素，并对其进行处理(例如，单击它并期待一些输出)。如果您以前使用过基于JavaScript的<a class="ae ky" href="https://angularjs.org/" rel="noopener ugc nofollow" target="_blank"> Angular </a>和<a class="ae ky" href="https://reactjs.org/" rel="noopener ugc nofollow" target="_blank"> React </a>，那么您可能熟悉使用jQuery或普通JavaScript查询DOM元素。</p><p id="0f07" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">大多数web开发人员应该对CSS有所了解。然而，对于测试或抓取，还有XPath，它提供了一些CSS中没有的有趣特性。虽然JavaScript不直接支持XPath，但是您可以在组件和e2e测试中使用它，也可以在任何现代的web浏览器中使用它，比如Google Chrome。</p><p id="1c80" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">可悲的是，这种力量往往伴随着一个警告:</p><ul class=""><li id="62b9" class="lv lw it lb b lc ld lf lg li lx lm ly lq lz lu mk mb mc md bi translated">XPath可以做CSS能做的任何事情，甚至更多:例如，访问元素的父元素。这一点有时很受欢迎，因为XPath支持许多亲属。</li><li id="93dd" class="lv lw it lb b lc mf lf mg li mh lm mi lq mj lu mk mb mc md bi translated">这个优点可能会变成缺点——因为使用XPath经常会导致冗长而复杂的查询，而这在CSS中是不可能的</li></ul><p id="e028" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在本文中，我想看看XPath和CSS查询的常见问题。之后，我们将探索一些避免这些问题的方法。</p><p id="5d92" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu">提示:</strong>像Google Chrome这样的浏览器允许你在开发者工具中复制和运行CSS和XPath查询。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ml"><img src="../Images/94ddb9b0c8b84145ef0b51f502ad155a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*-VRbEqYkviUEqF1DCwDkKA.png"/></div></div></figure></div><div class="ab cl mm mn hx mo" role="separator"><span class="mp bw bk mq mr ms"/><span class="mp bw bk mq mr ms"/><span class="mp bw bk mq mr"/></div><div class="im in io ip iq"><h1 id="375e" class="mt mu it bd mv mw mx my mz na nb nc nd jz ne ka nf kc ng kd nh kf ni kg nj nk bi translated">使用XPath查找元素时的常见问题</h1><ul class=""><li id="1037" class="lv lw it lb b lc nl lf nm li nn lm no lq np lu mk mb mc md bi translated">XPath查询可以很快变得很大:<code class="fe nq nr ns nt b">//table[@id='table2']//tr/td[contains(@class,'dues')]/a/span</code> vs. <code class="fe nq nr ns nt b">#table2 .dues a span</code>使用CSS</li><li id="5d2b" class="lv lw it lb b lc mf lf mg li mh lm mi lq mj lu mk mb mc md bi translated">XPath查询通常包含太多的层次结构和条件，这使得它们非常脆弱，将来很容易被破坏。例子:<code class="fe nq nr ns nt b">span[contains(@class,'name')]/../../../button[contains(@class,'lock')]</code>。</li></ul></div><div class="ab cl mm mn hx mo" role="separator"><span class="mp bw bk mq mr ms"/><span class="mp bw bk mq mr ms"/><span class="mp bw bk mq mr"/></div><div class="im in io ip iq"><h1 id="2e4d" class="mt mu it bd mv mw mx my mz na nb nc nd jz ne ka nf kc ng kd nh kf ni kg nj nk bi translated">使用CSS查找元素时的常见问题</h1><ul class=""><li id="7581" class="lv lw it lb b lc nl lf nm li nn lm no lq np lu mk mb mc md bi translated">CSS查询通常包括太多的层次结构和条件，这使得它们非常脆弱，将来很容易被破坏。例子:<code class="fe nq nr ns nt b">.main &gt; section:first-child .info-section a.author + img</code>。</li><li id="f752" class="lv lw it lb b lc mf lf mg li mh lm mi lq mj lu mk mb mc md bi translated">CSS有一些众所周知的限制，比如不能选择元素的父元素</li></ul></div><div class="ab cl mm mn hx mo" role="separator"><span class="mp bw bk mq mr ms"/><span class="mp bw bk mq mr ms"/><span class="mp bw bk mq mr"/></div><div class="im in io ip iq"><h1 id="9a12" class="mt mu it bd mv mw mx my mz na nb nc nd jz ne ka nf kc ng kd nh kf ni kg nj nk bi translated">如何避免复杂的XPath和CSS查询</h1><ol class=""><li id="2135" class="lv lw it lb b lc nl lf nm li nn lm no lq np lu ma mb mc md bi translated">对于大多数简单的情况，CSS选择器通常更容易理解。</li><li id="d126" class="lv lw it lb b lc mf lf mg li mh lm mi lq mj lu ma mb mc md bi translated">通过减少查询中的层次结构，当您更改层次结构(例如，通过删除一个层)时，它变得不那么脆弱并且不太可能被破坏。</li><li id="f907" class="lv lw it lb b lc mf lf mg li mh lm mi lq mj lu ma mb mc md bi translated">使用XPath，您可以搜索父元素——这在纯CSS选择器中是做不到的。我可以推荐祖先选择器，以避免不必要地遍历DOM来查找特定的父元素。例如:<code class="fe nq nr ns nt b">//button[@attr='val']/ancestor::div[contains(@class,'post')]</code>。</li><li id="cdbd" class="lv lw it lb b lc mf lf mg li mh lm mi lq mj lu ma mb mc md bi translated">查询特定的字符串可能非常脆弱，因为文本经常会发生变化。尽管如此，仍然存在查找包含特定字符串的元素的用例。像<a class="ae ky" href="https://www.protractortest.org/#/api?view=ProtractorBy.prototype.cssContainingText" rel="noopener ugc nofollow" target="_blank">量角器</a>这样的框架有一种便捷的方法来用CSS和文本查找元素，相比XPath我更喜欢这种方法。</li><li id="7e66" class="lv lw it lb b lc mf lf mg li mh lm mi lq mj lu ma mb mc md bi translated">您可以使用较小的查询，而不是单一的长查询。下面举个量角器的例子:<code class="fe nq nr ns nt b">$('my-app .login-container').$('.login-button')</code>。特别是对于复杂的查询，我宁愿将一些find调用链接起来，也不愿使用难以理解的查询。</li></ol></div><div class="ab cl mm mn hx mo" role="separator"><span class="mp bw bk mq mr ms"/><span class="mp bw bk mq mr ms"/><span class="mp bw bk mq mr"/></div><div class="im in io ip iq"><h1 id="ce2a" class="mt mu it bd mv mw mx my mz na nb nc nd jz ne ka nf kc ng kd nh kf ni kg nj nk bi translated">结论</h1><p id="8f99" class="pw-post-body-paragraph kz la it lb b lc nl ju le lf nm jx lh li nu lk ll lm nv lo lp lq nw ls lt lu im bi translated">感谢您阅读这篇短文。如您所见，使用CSS或XPath查询查找元素时会遇到一些问题。</p><p id="3001" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">然而，有一些易于遵循的规则——帮助我们编写易于阅读且不太可能出错的查询。</p></div></div>    
</body>
</html>