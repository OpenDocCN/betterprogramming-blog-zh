<html>
<head>
<title>Understanding Contravariance — The Java Wildcard</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">理解逆变Java通配符</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/understanding-contravariance-the-java-wildcard-149853da1559?source=collection_archive---------8-----------------------#2022-09-20">https://betterprogramming.pub/understanding-contravariance-the-java-wildcard-149853da1559?source=collection_archive---------8-----------------------#2022-09-20</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="7685" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">探索这个奇妙元素的第二个指南</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/b758a71407a2c0e74d03252214601ad6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*RDG_bSmSWizkNPcexi3IQA.jpeg"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">由<a class="ae kv" href="https://unsplash.com/@nicod5300?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Nicolas Brulois </a>在<a class="ae kv" href="https://unsplash.com/s/photos/bucket?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</p></figure><p id="e513" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">Contravariance比较棘手，所以慢慢通读文章吧！不要着急。如果你赶时间，把它加到阅读清单上，以后再回来看。</p><p id="d9c9" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这是系列文章的续篇。如果你先浏览一下上一篇文章会很有用。你会了解到本文所讨论的事情的历史背景。</p><p id="364d" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">正如我们在本系列的A部分中了解到的:</p><ul class=""><li id="1a03" class="ls lt iq ky b kz la lc ld lf lu lj lv ln lw lr lx ly lz ma bi translated">如果String是Object的子对象(称之为base-relation)，那么如何使用contravariance建立一个关系，其中<code class="fe mb mc md me b">HT&lt;Object&gt;</code>是<code class="fe mb mc md me b">HT&lt;String&gt;</code>的子对象？其中HT是持有者数据类型，如<code class="fe mb mc md me b">List</code>、<code class="fe mb mc md me b">Map</code>等。</li><li id="48a2" class="ls lt iq ky b kz mf lc mg lf mh lj mi ln mj lr lx ly lz ma bi translated">逆变反转基关系，根据逆变，如果String是<code class="fe mb mc md me b">Object</code>的子，那么<code class="fe mb mc md me b">HT&lt;Object&gt; </code>将是<code class="fe mb mc md me b">HT&lt;String&gt;</code>的子。这意味着可以允许父引用存储子引用。</li></ul><p id="f1f4" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这不是开箱即用的。我们需要使用Java通配符。</p><p id="d5aa" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们将使用上一篇文章中类似的例子来了解更多。考虑如下所示的类层次结构:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi mk"><img src="../Images/7b70f25a2924407cba8561be1e9584f5.png" data-original-src="https://miro.medium.com/v2/resize:fit:602/format:webp/1*4qZuS2juBdAdOkEJjIPDjA.png"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">child的类层次结构</p></figure><p id="5dbe" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">有一个方法接受<code class="fe mb mc md me b">List&lt;Child&gt;</code>作为参数，现在我们想接受一个<code class="fe mb mc md me b">List&lt;Father&gt;</code>、<code class="fe mb mc md me b">List&lt;Grandfather&gt;</code>、<code class="fe mb mc md me b">List&lt;GreatGrandFather&gt;</code>..直到<code class="fe mb mc md me b">List&lt;Object&gt;</code>。但这与我们在协方差中所学的相反。情况描述如下:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi ml"><img src="../Images/1fa064d68847c2f8c30805bf18ed1c38.png" data-original-src="https://miro.medium.com/v2/resize:fit:928/format:webp/1*7th_Y5dhmuvvH8_TcpI5qg.png"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">接受类祖先的函数</p></figure><p id="6b70" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这是通过如下声明函数来实现的:</p><pre class="kg kh ki kj gt mm me mn mo aw mp bi"><span id="ea2b" class="mq mr iq me b gy ms mt l mu mv">void accept(List&lt;? super Child&gt; items)</span></pre><p id="78eb" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">一旦完成，该函数将开始接受其自身及其祖先的所有holder类型，使其看起来像是<code class="fe mb mc md me b">HT&lt;Parent&gt;</code>是<code class="fe mb mc md me b">HT&lt;Child&gt;</code>的子代。Java子引用可以分配给父引用，反之亦然。你打出了你的通配符！所以这个名字。请参见下面的代码片段:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi mw"><img src="../Images/3ca6d81c892549e794bd7bd769ae83c3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*f76O0jORNUHAyfAm2DFyLA.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">使用逆变将超类分配给子类引用</p></figure><p id="64b4" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">现在，让我们分析一下<code class="fe mb mc md me b">accept()</code>方法。我们知道这些物品可能包含孩子的任何祖先，包括<code class="fe mb mc md me b">Object</code>。那么，我们能保证从这个逆变列表中读出什么参考吗？不要！我们拥有的唯一保证是我们可以安全地提取对象引用。</p><h1 id="6428" class="mx mr iq bd my mz na nb nc nd ne nf ng jw nh jx ni jz nj ka nk kc nl kd nm nn bi translated">矛盾的限制</h1><p id="58b2" class="pw-post-body-paragraph kw kx iq ky b kz no jr lb lc np ju le lf nq lh li lj nr ll lm ln ns lp lq lr ij bi translated">除了<code class="fe mb mc md me b">Object</code>，从逆变持有人客体，我们不允许阅读任何东西。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nt"><img src="../Images/60009abc655bbf2de0fb505602ab77b5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*72xpmAe-otHj1rO61qgDBg.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">可以有把握地提取仅表示对象引用的样本。</p></figure><p id="3569" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">2.第二种表现与我们在上一篇文章的共变列表中看到的相反。我们将能够在“项目”列表中添加一个对象<code class="fe mb mc md me b">Child</code>或<code class="fe mb mc md me b">Child</code>的任何子类，但不能在它上面添加任何东西。为什么？</p><p id="c832" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">假设传递给方法的列表是一个<code class="fe mb mc md me b">List&lt;Father&gt;</code>。如果我们允许列表中包含<code class="fe mb mc md me b">Child</code>以上的类，那么开发者可能会无意中污染列表——将<code class="fe mb mc md me b">GrandFather</code>添加到<code class="fe mb mc md me b">List&lt;Father&gt;</code>将是错误的，并可能导致<code class="fe mb mc md me b">ClassCastException</code>。但是，<code class="fe mb mc md me b">Child</code>和<code class="fe mb mc md me b">Child</code>的子类将总是确保列表的一致性。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nu"><img src="../Images/87d14d3c41a2667407f63c6da16e5df9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*5OrNXCoAd4Pen6opYgXHlQ.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">显示逆变列表的示例可以接受子的任何子类，但不能接受它上面的任何子类。</p></figure><p id="4543" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">一个问题浮现在脑海中:为什么我们需要这种由方差促成的关系？</p><p id="0a5e" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">假设您编写了一个实用函数，将<code class="fe mb mc md me b">List&lt;Child&gt;</code>的内容复制到另一个函数中。</p><pre class="kg kh ki kj gt mm me mn mo aw mp bi"><span id="f39e" class="mq mr iq me b gy ms mt l mu mv">void copy(List&lt;? super Child&gt; dest, List&lt;? extends Child&gt; source)</span></pre><p id="8ded" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们知道源将接受任何带有<code class="fe mb mc md me b">Child</code>子类的列表。这很容易理解，因为协方差使得代码更通用，可以为<code class="fe mb mc md me b">Child</code>的多个子类工作。但是<code class="fe mb mc md me b">List&lt;? super Child&gt;</code>有什么帮助呢？</p><p id="02c4" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在<code class="fe mb mc md me b">dest</code>中，我们可以通过<code class="fe mb mc md me b">List&lt;Father&gt;</code>、<code class="fe mb mc md me b">List&lt;GrandFather&gt;</code>等。，当您将这些目的地列表传递给<code class="fe mb mc md me b">copy()</code>时，您也会有代码来使用这个列表，对吗？你会意识到列表的使用契约不会因为contravariance而中断，并且代码尽可能保持通用。</p><p id="0d55" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">请参见以下代码:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nv nw l"/></div></figure><blockquote class="nx ny nz"><p id="8cad" class="kw kx oa ky b kz la jr lb lc ld ju le ob lg lh li oc lk ll lm od lo lp lq lr ij bi translated">Contravariance允许你的<code class="fe mb mc md me b"><em class="iq">copy()</em></code>方法被子超类的List &lt; &gt;使用，也不会破坏它们的契约，否则你可能不得不为父类、祖父类等编写单独的方法。</p></blockquote><h2 id="457d" class="mq mr iq bd my oe of dn nc og oh dp ng lf oi oj ni lj ok ol nk ln om on nm oo bi translated">集合之外的逆变</h2><p id="f16e" class="pw-post-body-paragraph kw kx iq ky b kz no jr lb lc np ju le lf nq lh li lj nr ll lm ln ns lp lq lr ij bi translated">让我们考虑同一个<code class="fe mb mc md me b">Box&lt;T&gt;</code>的例子:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nv nw l"/></div></figure><p id="de1f" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">现在，我们知道了<code class="fe mb mc md me b">GrandFather</code>、<code class="fe mb mc md me b">Father</code>和<code class="fe mb mc md me b">Child</code>之间的关系。使用逆变，我们可以反转包含<code class="fe mb mc md me b">GrandFather</code>、<code class="fe mb mc md me b">Father</code>和<code class="fe mb mc md me b">Child</code>的<code class="fe mb mc md me b">Box&lt;&gt;</code>类的关系。</p><p id="4a55" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">请注意，每个实例的<code class="fe mb mc md me b">Box</code>实例之间没有现成的关系。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi op"><img src="../Images/bc1c5d95718f4f7a5f57120c4292974a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Rvud-KjaPtPmzOH1mQUEgg.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">没有关系黑白框实例</p></figure><p id="d0cf" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">但是，在应用逆变之后，我们将能够将<code class="fe mb mc md me b">Box&lt;Parent&gt;</code>分配给<code class="fe mb mc md me b">Box&lt;Child&gt;</code>。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi oq"><img src="../Images/dbdedeae68940a5da86328683baff3c6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*alMKT0BqLTLIEcgZo8FNTQ.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">盒类的逆变行为</p></figure><p id="4e15" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">就像在集合中一样，一旦我们正在访问Box的逆变引用，我们将被允许在<code class="fe mb mc md me b">setItem()</code>方法中添加任何child的实现，但不能在<code class="fe mb mc md me b">Child</code>之上添加。见下文。<code class="fe mb mc md me b">Child</code>和<code class="fe mb mc md me b">Grandchild </code>允许，但<code class="fe mb mc md me b">Father</code>不允许。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi or"><img src="../Images/1a222e9220faa0cd2b22ac84658429e8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*7jid_bnba219UYJ2V-RBTA.png"/></div></div></figure><p id="074a" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们还观察到，从<code class="fe mb mc md me b">Box</code>的逆变参考中，我们无法提取除<code class="fe mb mc md me b">Object</code>以外的任何参考。在集合的情况下也是如此。除了<code class="fe mb mc md me b">Object</code>之外，我们不允许阅读任何东西。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi os"><img src="../Images/965751bff3f1140ae2104caa914683dd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*6XMHpvp4PKabi-nK1x45dQ.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">逆变列表只允许读取对象引用</p></figure><h1 id="42f2" class="mx mr iq bd my mz na nb nc nd ne nf ng jw nh jx ni jz nj ka nk kc nl kd nm nn bi translated">我们学到了什么</h1><ol class=""><li id="1dad" class="ls lt iq ky b kz no lc np lf ot lj ou ln ov lr ow ly lz ma bi translated">逆变可用于反转包含对象之间的父子关系。</li><li id="23f5" class="ls lt iq ky b kz mf lc mg lf mh lj mi ln mj lr ow ly lz ma bi translated">它可用于使夹具类型只写，并阻止读取除<code class="fe mb mc md me b">Object</code>以外的任何参考值。</li><li id="19bf" class="ls lt iq ky b kz mf lc mg lf mh lj mi ln mj lr ow ly lz ma bi translated">逆变列表将允许添加边界类型的任何子元素。例如，<code class="fe mb mc md me b">Box&lt;? super Child&gt;</code>将允许<code class="fe mb mc md me b">Child</code>及其子类型，但不允许层次结构中任何高于<code class="fe mb mc md me b">Child</code>的类型。</li></ol><h1 id="501f" class="mx mr iq bd my mz na nb nc nd ne nf ng jw nh jx ni jz nj ka nk kc nl kd nm nn bi translated">Java中的逆变与Kotlin中的协变</h1><p id="2c72" class="pw-post-body-paragraph kw kx iq ky b kz no jr lb lc np ju le lf nq lh li lj nr ll lm ln ns lp lq lr ij bi translated">在Java中，我们看到使用 super SomeClass&gt;可以获得逆变。但是，这只能在holder类之外完成。在上面的<code class="fe mb mc md me b">Box</code>例子中，我们在<code class="fe mb mc md me b">Box </code>类之外创建的新的<code class="fe mb mc md me b">Box</code>引用被声明为逆变，而不是实际的<code class="fe mb mc md me b">Box</code>类。</p><p id="0af6" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这被称为调用点差异。因为差异是在使用地点定义的。因此，它也被称为使用地点差异。</p><p id="8304" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在Kotlin中，与我们看到的相反，我们可以通过使用<code class="fe mb mc md me b">in</code>操作符在编写holder类本身的时候声明一个类是逆变的。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi ox"><img src="../Images/377cd5825c2b27f23120a5e3e6407db2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*JBmFVEgwTtWrjZqtN07zhA.png"/></div></div></figure><p id="68ac" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们看到，当我们编写一个返回结果<code class="fe mb mc md me b">T</code>的方法时，声明一个类<code class="fe mb mc md me b">in</code>开始显示一个错误。换句话说，将<code class="fe mb mc md me b">T</code>声明为<code class="fe mb mc md me b">in</code>将不允许您编写任何接受返回<code class="fe mb mc md me b">T</code>的方法。<code class="fe mb mc md me b">T</code>只能是一个方法的参数，又名，<code class="fe mb mc md me b">T</code>只能在里面。所以这个<code class="fe mb mc md me b">in</code>。</p><p id="468a" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们在科特林的呼叫站点免费获得以下行为。我们必须在Java中为相同的内容创建逆变引用。</p><ol class=""><li id="1aea" class="ls lt iq ky b kz la lc ld lf lu lj lv ln lw lr ow ly lz ma bi translated">我们不允许将任何对象放在层次结构中的<code class="fe mb mc md me b">Child</code>之上。下面的例子展示了在传递<code class="fe mb mc md me b">Grandfather</code>对象的情况下它是如何失败的，并与<code class="fe mb mc md me b">Child</code>和<code class="fe mb mc md me b">Grandchild</code>对象一起工作。</li></ol><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi oy"><img src="../Images/1c06662797cd99e745b58dd5b4b3fd13.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*gW6pSiU9YDI0el3hfAIZtQ.png"/></div></div></figure><p id="cb55" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">2.<code class="fe mb mc md me b">KtBox&lt;Child&gt;</code>允许存储的引用<code class="fe mb mc md me b">KtBox&lt;Parent&gt;</code></p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi oz"><img src="../Images/bea7e2dc84bb9f6ea156cbd47d01d530.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*k8T0y9EkiY4wUS5lr2CjcA.png"/></div></div></figure><p id="00e0" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">Kotlin协方差可以在创建holder类时定义。因此，它也被称为“申报现场逆变”</p><h2 id="d1a9" class="mq mr iq bd my oe of dn nc og oh dp ng lf oi oj ni lj ok ol nk ln om on nm oo bi translated">何时使用逆变的例子，又名<code class="fe mb mc md me b">&lt;? super XXXX&gt;</code></h2><ol class=""><li id="7484" class="ls lt iq ky b kz no lc np lf ot lj ou ln ov lr ow ly lz ma bi translated">它与协变API相反。如果您想在不想读取任何内容的地方构建拦截器API，请添加一些项目。例如，一旦用户向您的框架提交工作，您希望在不读取任何内容的情况下向列表中添加几个默认的工作项。</li></ol><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi pa"><img src="../Images/3b4c3b9acb67233592e5ff9a3f3a4c8c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*vSeXImGcw-SCKKJ6hs7GSQ.png"/></div></div></figure><p id="3a61" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">2.对于像<code class="fe mb mc md me b">Box&lt;T&gt;</code>这样的其他容器类型，我们可以使用逆变来禁止从其中读取<code class="fe mb mc md me b">T</code>类型的对象。</p><h1 id="6760" class="mx mr iq bd my mz na nb nc nd ne nf ng jw nh jx ni jz nj ka nk kc nl kd nm nn bi translated">离别赠言</h1><p id="a0f9" class="pw-post-body-paragraph kw kx iq ky b kz no jr lb lc np ju le lf nq lh li lj nr ll lm ln ns lp lq lr ij bi translated">现在你已经学习了协变和逆变的基本原理，我们可以开始学习如何使用它们来构建高级API表面，例如当你需要一种关系时，你应该能够将父引用分配给子引用，反之亦然。</p></div></div>    
</body>
</html>