<html>
<head>
<title>4 Swift Protocols Commonly Used in SwiftUI</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">SwiftUI中常用的4种Swift协议</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/4-swift-protocols-commonly-used-in-swiftui-b3859af9debd?source=collection_archive---------11-----------------------#2022-01-03">https://betterprogramming.pub/4-swift-protocols-commonly-used-in-swiftui-b3859af9debd?source=collection_archive---------11-----------------------#2022-01-03</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="8575" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">等价、可比、可识别和可散列的解决方案</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/fdc4eb6d20a7f88e1400bdf5c1e161b0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*ICc6yzTu0b0Mi_e3"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">照片由<a class="ae ky" href="https://unsplash.com/@jannerboy62?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">尼克·费因斯</a>在<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</p></figure><p id="8f48" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">协议对于iOS或它的表亲OS X来说肯定不陌生；事实上，委托协议是一半以上框架的基础，尽管随着新的async/await的出现，它可能会在未来几年发生变化。也就是说，自SwiftUI在2019年问世以来，协议似乎一直在改变颜色。</p><p id="ef9d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我这样说是因为SwiftUI包含了几个与语言本身相关的强制性协议。基本协议，如等价、可比、可识别和可散列，尽管并不总是很清楚发生了什么。</p><h1 id="1fa9" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">可辨认的</h1><p id="1e67" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">这是作为一个新的SwiftUI编码器的第一个协议，当你试图定义一个<code class="fe ms mt mu mv b">ForEach</code>循环时，例如，在一个<code class="fe ms mt mu mv b">List</code>中——假设我们有一个包含自定义结构的骰子数组。</p><pre class="kj kk kl km gt mw mv mx my aw mz bi"><span id="b3ba" class="na lw it mv b gy nb nc l nd ne">struct ContentView: View {<br/>  @State var dice = [Dice]()<br/>  var body: some View {<br/>    ForEach(dice) {<br/>      Text(String($0.value))<br/>    }<br/>  }<br/>}</span></pre><p id="5217" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">编译器需要的是一种唯一标识结构循环中每一行的方法。这里显示的骰子变量需要符合<code class="fe ms mt mu mv b">Identifiable</code>。你用这样的代码获得的一致性。</p><pre class="kj kk kl km gt mw mv mx my aw mz bi"><span id="5394" class="na lw it mv b gy nb nc l nd ne">struct Dice: Identifiable {<br/>  //  var id = UUID()<br/>  var id = Date().timeIntervalSince1970 // epoch [dies Jan 19, 2038]<br/>  var value: Int!<br/>}</span></pre><h1 id="9217" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">易消化的</h1><p id="4d85" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">您可能遇到的第二个协议是<code class="fe ms mt mu mv b">Hashable</code>，SwiftUI将需要这个协议来完成一个循环，就像这里举例说明的那样。</p><pre class="kj kk kl km gt mw mv mx my aw mz bi"><span id="2c41" class="na lw it mv b gy nb nc l nd ne">ForEach(dice, id: \.self) { die in<br/>  Text("Die: \(die.value)")<br/>}</span></pre><p id="3364" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">但是要小心，因为如果你随后添加了第三个协议<code class="fe ms mt mu mv b">Equatable</code>并给出了定义——它会使你的代码崩溃。</p><pre class="kj kk kl km gt mw mv mx my aw mz bi"><span id="1f8f" class="na lw it mv b gy nb nc l nd ne"><strong class="mv iu">struct</strong> Dice: <strong class="mv iu">Equatable, Hashable</strong> {<br/>  <strong class="mv iu">var</strong> id = <strong class="mv iu">UUID</strong>()<br/>  <strong class="mv iu">var</strong> value: <strong class="mv iu">Int</strong>!</span><span id="ebc3" class="na lw it mv b gy nf nc l nd ne"><strong class="mv iu">  static</strong> <strong class="mv iu">func</strong> ==(lhs: Dice, rhs: Dice) -&gt;<strong class="mv iu"> Bool</strong> {<br/>    lhs.value == rhs.value<br/>  }<br/>}</span></pre><p id="f1a7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这里的hashable需求需要一个惟一的标识符，就像可识别的协议(当它需要可识别的时候，为什么它要求Hashable，这超出了我的理解)。</p><p id="0a29" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">为了同时使用<code class="fe ms mt mu mv b">Hashable</code>和<code class="fe ms mt mu mv b">Equatable</code>协议，您需要告诉<code class="fe ms mt mu mv b">Hashable</code>协议关注id，所以是的，那个唯一的<code class="fe ms mt mu mv b">Identifiable</code>值。</p><pre class="kj kk kl km gt mw mv mx my aw mz bi"><span id="7a08" class="na lw it mv b gy nb nc l nd ne">extension Dice: Hashable {<br/>  static func ==(lhs: Dice, rhs: Dice) -&gt; Bool {<br/>    lhs.id == rhs.id<br/>  }</span><span id="d1e3" class="na lw it mv b gy nf nc l nd ne">  func hash(into hasher: inout Hasher) {<br/>    hasher.combine(id)<br/>  }<br/>}</span></pre><p id="b376" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">也就是说，散列函数在这里也可以派上用场，因为它保证在给定相同输入的情况下产生相同的输出。虽然这个例子看起来有点无意义，但是您可以使用这样的代码一次又一次地生成相同的密钥。</p><pre class="kj kk kl km gt mw mv mx my aw mz bi"><span id="4f31" class="na lw it mv b gy nb nc l nd ne">.onAppear {<br/>  var hash = Hasher()<br/>  hash.combine(die.id)<br/>  print("hash \(hash.finalize()) \(die.hashValue)")<br/>}</span></pre><p id="0852" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">Apple的手册页<a class="ae ky" href="https://developer.apple.com/documentation/swift/hashable" rel="noopener ugc nofollow" target="_blank">给出了如何使用该协议的更好的实际应用。</a></p><h1 id="3f76" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">可比较的</h1><p id="3ed1" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">在我的协议列表中，下一个是comparable，它看起来几乎与Equatable相同。</p><pre class="kj kk kl km gt mw mv mx my aw mz bi"><span id="39bf" class="na lw it mv b gy nb nc l nd ne">extension Dice: Comparable {<br/>  static func &lt; (lhs: Dice, rhs: Dice) -&gt; Bool {<br/>    lhs.value &lt; rhs.value<br/>  }<br/>}</span></pre><p id="5b06" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">将此代码添加到我们的SwiftUI接口，以利用新的协议/属性。</p><pre class="kj kk kl km gt mw mv mx my aw mz bi"><span id="2428" class="na lw it mv b gy nb nc l nd ne">if dice.count == 2 {<br/>  if dice.first! &gt; dice.last! {<br/>    Text("Winner 1st")<br/>  } else {<br/>    Text("Winner 2nd")<br/>  }<br/>}</span></pre><p id="0a8e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">但是这里有一个警告。因为我必须指向<code class="fe ms mt mu mv b">id</code>来符合散列协议，所以我不能以同样的方式使用<code class="fe ms mt mu mv b">==</code>。</p><pre class="kj kk kl km gt mw mv mx my aw mz bi"><span id="ae6a" class="na lw it mv b gy nb nc l nd ne">if dice.first! == dice.last! {<br/>  Text("Unequal \(dice.hashValue)")<br/>} else {<br/>  Text("Equal \(dice.hashValue)")<br/>}</span></pre><p id="7c76" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">为了解决这个问题，我需要一个新的运营商。对上述问题的修复需要我创建一个新的中缀运算符，如<code class="fe ms mt mu mv b">====.</code>，显然我需要更新上面显示的代码片段，用<code class="fe ms mt mu mv b">====</code>代替所示的<code class="fe ms mt mu mv b">==</code>。</p><pre class="kj kk kl km gt mw mv mx my aw mz bi"><span id="f949" class="na lw it mv b gy nb nc l nd ne">infix operator ==== : DefaultPrecedence<br/>extension Dice {<br/>  static func ====(lhs: Dice, rhs: Dice) -&gt; Bool {<br/>    lhs.face == rhs.face<br/>  }<br/>}</span></pre><p id="6242" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我相信苹果公司希望你在日常代码中使用协议，让你想做的事情更加明显，这是一种有效的类型扩展，你可以在你的定制对象上使用。</p></div><div class="ab cl ng nh hx ni" role="separator"><span class="nj bw bk nk nl nm"/><span class="nj bw bk nk nl nm"/><span class="nj bw bk nk nl"/></div><div class="im in io ip iq"><h1 id="4537" class="lv lw it bd lx ly nn ma mb mc no me mf jz np ka mh kc nq kd mj kf nr kg ml mm bi translated">等价的</h1><p id="b4b2" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">好吧，我承认中缀运算符并不适合所有人——尤其是敏捷的清教徒。因此，这里有一个替代使用更等值，没有中缀。</p><p id="46c1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在其中，我将视图定义为符合等价协议，将我的骰子的正面作为目标。</p><p id="0e5e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">注意，我最初使用<code class="fe ms mt mu mv b">.onAppear</code>来设置<code class="fe ms mt mu mv b">die1</code>和<code class="fe ms mt mu mv b">die2</code>，然后使用<code class="fe ms mt mu mv b">.onChange</code>来管理每次我掷出新的一对骰子的所有后续重新加载。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ns nt l"/></div></figure><p id="5b73" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">至此，我结束了这篇论文。如果你想下载我用来一次性构建不同案例的整个项目，你可以在这里找到它。</p></div></div>    
</body>
</html>