<html>
<head>
<title>Introduction to TypeScript Data Types (Part 2)</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">TypeScript数据类型介绍(第2部分)</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/introduction-to-typescript-data-types-numbers-strings-and-objects-2b6eaebd5d66?source=collection_archive---------12-----------------------#2019-12-13">https://betterprogramming.pub/introduction-to-typescript-data-types-numbers-strings-and-objects-2b6eaebd5d66?source=collection_archive---------12-----------------------#2019-12-13</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="f175" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">数字、字符串和对象</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/b062cc2a70240c2686a41c4085fa0859.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*lEiAyXVpNw8tTQrN"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">照片由<a class="ae ky" href="https://unsplash.com/@emilep?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">émile Perron</a>在<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</p></figure><p id="146f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">JavaScript和其他编程语言一样，有自己的数据结构和类型。为了用JavaScript构建程序，我们必须了解一些数据类型。不同的数据可以放在一起构建更复杂的数据结构。</p><p id="9d12" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">JavaScript是一种松散类型或动态类型的语言。这意味着用一种类型声明的变量可以转换成另一种类型，而不用显式地将数据转换成另一种类型。变量也可以在任何时候包含任何类型，这取决于赋值的内容。</p><p id="29df" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在动态类型语言中，如果不记录就很难确定变量的类型，我们可能会在变量中分配我们不想要的数据。</p><p id="23a1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">TypeScript纠正了这些问题，让我们为变量设置固定的类型，这样我们就可以确定类型。它拥有JavaScript的所有基本数据类型，以及TypeScript独有的类型，如数字、字符串和对象。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="e4e1" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">数字</h1><p id="c864" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">JavaScript中有两种数字类型，分别是number和BigInt。数字类型是双精度64位数字，其值可以在-2的53次方减1和2的53次方减1之间。整数没有特定的类型。所有数字都是浮点数。还有三个符号值:<code class="fe mz na nb nc b">Infinity</code>、<code class="fe mz na nb nc b">-Infinity</code>、<code class="fe mz na nb nc b">NaN</code>。</p><p id="a4dd" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">一个数字的最大和最小可用值分别是<code class="fe mz na nb nc b">Infinity</code>和<code class="fe mz na nb nc b">-Infinity</code>。我们也可以使用常数<code class="fe mz na nb nc b">Number.MAX_VALUE</code>或<code class="fe mz na nb nc b">Number.MIN_VALUE</code>来表示最大和最小的数字。我们可以使用<code class="fe mz na nb nc b">Number.isSafeInteger()</code>函数来检查一个数字是否在JavaScript允许的可用数字范围内。</p><p id="5e0f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">还有常量<code class="fe mz na nb nc b">Number.MAX_SAFE_INTEGER</code>和<code class="fe mz na nb nc b">Number.MIN_SAFE_NUMBER</code>检查你指定的数字是否在安全范围内。超出该范围的任何内容都是不安全的，将是该值的双精度浮点型。数字0在JavaScript中有两种表示:有+0和-0，0是+0的别名。如果你试图将一个数除以0，它会被注意到:</p><pre class="kj kk kl km gt nd nc ne nf aw ng bi"><span id="fbb7" class="nh md it nc b gy ni nj l nk nl">1/+0 // Infinity<br/>1/-0 // -Infinity</span></pre><p id="16e0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">有时候，数字可以用位操作符表示布尔值，将它们作为布尔值进行操作，但这是一种不好的做法，因为JavaScript已经有了布尔值类型，所以使用数字表示布尔值对于阅读代码的人来说是不清楚的。这是因为数字可以表示数字，或者如果有人选择这样使用它们，它们可以表示布尔值。</p><p id="be10" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们可以用TypeScript声明数字，如下面的代码所示:</p><pre class="kj kk kl km gt nd nc ne nf aw ng bi"><span id="bcc3" class="nh md it nc b gy ni nj l nk nl">const x: number = 1<br/>const y: number = x + 1;</span></pre><p id="5db0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在TypeScript中，BigInt类型存储超出安全整数范围的数字。可以通过在数字末尾添加一个<code class="fe mz na nb nc b">n</code>字符来创建一个BigInt数字。使用BigInt，我们可以计算出超出正常数字安全范围的结果。例如，我们可以写出下面的表达式，并且仍然得到我们期望的数字:</p><pre class="kj kk kl km gt nd nc ne nf aw ng bi"><span id="e62a" class="nh md it nc b gy ni nj l nk nl">const x: bigint = 2n ** 55n;<br/>const y: bigint = x + 1n;</span></pre><p id="5820" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">对于<code class="fe mz na nb nc b">x</code>，我们得到<code class="fe mz na nb nc b">36028797018963968n</code>，对于<code class="fe mz na nb nc b">y</code>，我们得到<code class="fe mz na nb nc b">36028797018963969n</code>，这是我们所期望的。BigInts可以使用和数字一样的算术运算，比如<code class="fe mz na nb nc b">+</code>、<code class="fe mz na nb nc b">*</code>、<code class="fe mz na nb nc b">-</code>、<code class="fe mz na nb nc b">**</code>、<code class="fe mz na nb nc b">%</code>。当转换为布尔值时，BigInt的行为类似于数字，带有函数、关键字或运算符，如<code class="fe mz na nb nc b">Boolean</code>、<code class="fe mz na nb nc b">if</code>、<code class="fe mz na nb nc b">||</code>、<code class="fe mz na nb nc b">&amp;&amp;</code>、<code class="fe mz na nb nc b">!</code>。BigInts不能在与numbers相同的表达式中操作。如果我们这样做，我们将得到一个<code class="fe mz na nb nc b">TypeError</code>。这是在编译完成之前通过TypeScript编译器检查强制实现的。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="4685" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">用线串</h1><p id="3c7c" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">字符串用于表示文本数据。字符串中的每个元素在字符串中都有自己的位置。它是零索引的，所以字符串第一个字符的位置是0。字符串的<code class="fe mz na nb nc b">length</code>属性有字符串的总字符数。</p><p id="c383" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">JavaScript字符串是不可变的。我们不能修改已经创建的字符串，但是我们仍然可以创建一个包含最初定义的字符串的新字符串。我们可以使用<code class="fe mz na nb nc b">substr()</code>函数从字符串中提取子字符串，并使用<code class="fe mz na nb nc b">concat()</code>函数连接两个字符串。</p><p id="23af" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们应该只用字符串表示文本数据。如果你的数据结构需要更复杂的结构，那么它们就不应该用字符串来表示。相反，它们应该是对象。这是因为字符串很容易出错，因为我们可以输入我们想要的字符。</p><p id="c6f1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们可以用下面的代码在TypeScript中声明字符串:</p><pre class="kj kk kl km gt nd nc ne nf aw ng bi"><span id="6a3a" class="nh md it nc b gy ni nj l nk nl">const x: string = 'abc';</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nm"><img src="../Images/1d33a8c285757c898f1296957890c75c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*JsKL0IiXAac0iHKW"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">弗洛里安·克劳尔在<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>拍摄的照片</p></figure></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="c27b" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">目标</h1><p id="d495" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">对象是一种引用数据类型，这意味着它可以被指向对象在内存中的位置的标识符引用。在内存中，对象的值被存储，通过标识符，我们可以访问该值。对象具有属性，属性是键值对，其值能够包含原始类型或其他对象的数据。</p><p id="f7b0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这意味着我们可以使用对象来构建复杂的数据结构。键是属性值的标识符，可以存储为字符串或符号。有两种类型的属性在对象中具有某些特性。对象具有数据属性和访问器属性。</p><p id="8047" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">JavaScript对象具有以下数据属性:</p><ul class=""><li id="2c05" class="nn no it lb b lc ld lf lg li np lm nq lq nr lu ns nt nu nv bi translated"><code class="fe mz na nb nc b">[[Value]]</code> —这可以是任何类型。它具有由属性的getter检索的值。默认为<code class="fe mz na nb nc b">undefined</code>。</li><li id="8e2c" class="nn no it lb b lc nw lf nx li ny lm nz lq oa lu ns nt nu nv bi translated"><code class="fe mz na nb nc b">[[Writable]]</code> —这是一个布尔值。如果是<code class="fe mz na nb nc b">false</code>，那么<code class="fe mz na nb nc b">[[Value]]</code>是不能改变的。默认为<code class="fe mz na nb nc b">false</code>。</li><li id="e463" class="nn no it lb b lc nw lf nx li ny lm nz lq oa lu ns nt nu nv bi translated"><code class="fe mz na nb nc b">[[Enumerable]]</code> —这是一个布尔值。如果是<code class="fe mz na nb nc b">true</code>，那么它可以被<code class="fe mz na nb nc b">for...in</code>循环迭代，该循环用于迭代对象的属性。默认为<code class="fe mz na nb nc b">false</code>。</li><li id="9bf9" class="nn no it lb b lc nw lf nx li ny lm nz lq oa lu ns nt nu nv bi translated"><code class="fe mz na nb nc b">[[Configurable]]</code> —这是一个布尔值。如果是<code class="fe mz na nb nc b">true</code>，则可以删除该属性或将其更改为访问器属性，并且可以更改所有属性。否则，不能删除该属性或将其更改为访问器属性，并且不能更改除<code class="fe mz na nb nc b">[[Value]]</code>和<code class="fe mz na nb nc b">[[Writable]]</code>之外的属性。默认为<code class="fe mz na nb nc b">false</code>。</li></ul><p id="8b2a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">JavaScript对象具有以下访问器属性:</p><ul class=""><li id="e05c" class="nn no it lb b lc ld lf lg li np lm nq lq nr lu ns nt nu nv bi translated"><code class="fe mz na nb nc b">[[Get]]</code> —这要么是一个函数，要么是<code class="fe mz na nb nc b">undefined</code>。这可能包含一个函数，用于在检索属性时检索属性值。默认为<code class="fe mz na nb nc b">undefined</code>。</li><li id="a670" class="nn no it lb b lc nw lf nx li ny lm nz lq oa lu ns nt nu nv bi translated"><code class="fe mz na nb nc b">[[Set]]</code> —这要么是一个函数，要么是<code class="fe mz na nb nc b">undefined</code>。这让我们可以在试图改变对象属性时，为对象的属性设置赋值。默认为<code class="fe mz na nb nc b">undefined</code>。</li><li id="2a28" class="nn no it lb b lc nw lf nx li ny lm nz lq oa lu ns nt nu nv bi translated"><code class="fe mz na nb nc b">[[Enumerable]]</code> —这是一个布尔值，默认为<code class="fe mz na nb nc b">false</code>。如果是<code class="fe mz na nb nc b">true</code>，那么当我们用<code class="fe mz na nb nc b">for...in</code>循环遍历属性时，属性将被包含。</li><li id="c9ed" class="nn no it lb b lc nw lf nx li ny lm nz lq oa lu ns nt nu nv bi translated"><code class="fe mz na nb nc b">[[Configurable]]</code> —这是一个布尔值，默认为<code class="fe mz na nb nc b">false</code>。如果是<code class="fe mz na nb nc b">false</code>，那么我们就不能删除属性，也不能对其进行修改。</li></ul><p id="8461" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">JavaScript有一个内置在标准库中的<code class="fe mz na nb nc b">Date</code>对象，所以我们可以用它来操作日期。</p><p id="0697" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">数组也是对象。<code class="fe mz na nb nc b">Array</code>可以存储一列数据，用整数索引来表示其位置。JavaScript数组的第一个索引是0。还有一个<code class="fe mz na nb nc b">length</code>属性来获取数组的大小。<code class="fe mz na nb nc b">Array</code>对象有许多方便的方法来操作数组，比如<code class="fe mz na nb nc b">push</code>方法将项目添加到数组的末尾，而<code class="fe mz na nb nc b">indexOf</code>方法查找给定值第一次出现的索引。<code class="fe mz na nb nc b">TypedArray</code>对象是让我们看到二进制数据缓冲区的类似数组的视图的对象。</p><p id="beac" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">自ES2015起，以下类型化数组对象可用:</p><ul class=""><li id="f34b" class="nn no it lb b lc ld lf lg li np lm nq lq nr lu ns nt nu nv bi translated"><code class="fe mz na nb nc b">Int8Array</code>，取值范围从-128到127</li><li id="0d97" class="nn no it lb b lc nw lf nx li ny lm nz lq oa lu ns nt nu nv bi translated"><code class="fe mz na nb nc b">Uint8Array</code>，取值范围从0到255</li><li id="81c7" class="nn no it lb b lc nw lf nx li ny lm nz lq oa lu ns nt nu nv bi translated"><code class="fe mz na nb nc b">Uint8ClampedArray</code>，取值范围从0到255</li><li id="96f5" class="nn no it lb b lc nw lf nx li ny lm nz lq oa lu ns nt nu nv bi translated"><code class="fe mz na nb nc b">Int16Array</code>，取值范围从-32768到32767</li><li id="9100" class="nn no it lb b lc nw lf nx li ny lm nz lq oa lu ns nt nu nv bi translated"><code class="fe mz na nb nc b">Uint16Array</code>，取值范围从0到65535</li><li id="882b" class="nn no it lb b lc nw lf nx li ny lm nz lq oa lu ns nt nu nv bi translated"><code class="fe mz na nb nc b">Int32Array</code>，取值范围从-2147483648到2147483647</li><li id="5ad3" class="nn no it lb b lc nw lf nx li ny lm nz lq oa lu ns nt nu nv bi translated"><code class="fe mz na nb nc b">Unit32Array</code>，取值范围从0到4294967295</li><li id="78ae" class="nn no it lb b lc nw lf nx li ny lm nz lq oa lu ns nt nu nv bi translated"><code class="fe mz na nb nc b">Floar32Array</code>，取值范围从-1.2乘以10的38次方到3.4乘以10的38次方</li><li id="174e" class="nn no it lb b lc nw lf nx li ny lm nz lq oa lu ns nt nu nv bi translated"><code class="fe mz na nb nc b">Float64Array</code>，取值范围从5.0乘以10的324到1.8乘以10的308</li><li id="b2db" class="nn no it lb b lc nw lf nx li ny lm nz lq oa lu ns nt nu nv bi translated"><code class="fe mz na nb nc b">BigInt64Array</code>，取值范围从-2到63到2到63减1</li><li id="fc05" class="nn no it lb b lc nw lf nx li ny lm nz lq oa lu ns nt nu nv bi translated"><code class="fe mz na nb nc b">BigUint64Array</code>，取值范围从0到2到64减1</li></ul><p id="9ab3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">从ES2015开始，我们有了新的可迭代对象类型。他们是<code class="fe mz na nb nc b">Map</code>、<code class="fe mz na nb nc b">Set</code>、<code class="fe mz na nb nc b">WeakMap</code>和<code class="fe mz na nb nc b">WeakSet</code>。<code class="fe mz na nb nc b">Set</code>和<code class="fe mz na nb nc b">WeakSet</code>表示对象集，<code class="fe mz na nb nc b">Map</code>和<code class="fe mz na nb nc b">WeakMap</code>表示具有一系列键值对的对象。<code class="fe mz na nb nc b">Map</code>键可以被迭代，但是<code class="fe mz na nb nc b">WeakMap</code>的键不能。</p><p id="9175" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">使用TypeScript，我们将构造函数名称放在变量声明中的冒号之后，以声明它们的类型。例如，如果我们想声明一个<code class="fe mz na nb nc b">Map</code>对象，我们可以写:</p><pre class="kj kk kl km gt nd nc ne nf aw ng bi"><span id="646d" class="nh md it nc b gy ni nj l nk nl">const map: Map&lt;string, number&gt; = new Map([['a', 1], ['b', 2]]);</span></pre><p id="694c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">请注意，声明某些对象(如<code class="fe mz na nb nc b">Maps</code>)的方式与JavaScript不同。这是因为TypeScript支持泛型。TypeScript中的泛型允许我们将一个不确定的类型传递给函数、接口和类(它们只是函数的语法糖)，这样当我们在代码中引用对象时，就可以传递实际的类型，就像我们上面所做的那样。上面的声明是类型安全的，不像JavaScript那样声明<code class="fe mz na nb nc b">Map</code>对象。使用上面的代码，<code class="fe mz na nb nc b">Map</code>的键总是字符串，值总是数字。</p><p id="2dd6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">对于动态类型的语言，如果不记录就很难确定变量的类型，我们可能会像JavaScript一样在变量中分配我们不想要的数据。TypeScript纠正了这些问题，让我们为变量设置固定的类型，这样我们就可以确定类型。它拥有JavaScript的所有基本数据类型，以及TypeScript独有的类型。我们将在其他TypeScript文章中进行更详细的讨论，在这些文章中，我们将探索仅支持TypeScript的数据类型、接口、组合多种类型等等。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="3835" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">相关作品</h1><p id="bdba" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated"><a class="ae ky" href="https://medium.com/better-programming/introduction-to-typescript-data-types-void-null-undefined-never-and-object-types-11eb839e5381" rel="noopener">TypeScript数据类型介绍(第1部分):Null、void、undefined、never和object类型</a></p></div></div>    
</body>
</html>