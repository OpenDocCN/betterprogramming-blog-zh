<html>
<head>
<title>Improving the Performance of NumPy Code</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">提高NumPy码的性能</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/improving-the-performance-of-numpy-code-d8a339a484d9?source=collection_archive---------8-----------------------#2022-11-01">https://betterprogramming.pub/improving-the-performance-of-numpy-code-d8a339a484d9?source=collection_archive---------8-----------------------#2022-11-01</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="9754" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">NumPy代码运行时的实验</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/50fa7082c18e4c72f14204fb1adf1d86.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*8xBKmBIfkZR-7G0WgrzUxw.jpeg"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">作者图片</p></figure><p id="c676" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">在最近的一个项目中，我们决定使用<code class="fe lr ls lt lu b">AUC-Recall@K</code>作为评估我们模型的主要指标。我们将其定义为我们的模型所达到的理想<code class="fe lr ls lt lu b">Recall@k</code>曲线下的面积比例。</p><p id="9102" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">我的第一个实现使用了NumPy的函数，性能一点也不差，但这让我想知道我还能做得多好..以及有多糟糕。</p><pre class="kg kh ki kj gt lv lu lw lx aw ly bi"><span id="fc38" class="lz ma iq lu b gy mb mc l md me">Table of Contents</span><span id="7ead" class="lz ma iq lu b gy mf mc l md me">The AUC-Recall@k Metric</span><span id="d1d2" class="lz ma iq lu b gy mf mc l md me"><a class="ae mg" href="#17ff" rel="noopener ugc nofollow">The BaseLine Implementation</a></span><span id="81b5" class="lz ma iq lu b gy mf mc l md me"><a class="ae mg" href="#eaf9" rel="noopener ugc nofollow">Replacing the for-loop with NumPy’s functions</a></span><span id="2517" class="lz ma iq lu b gy mf mc l md me"><a class="ae mg" href="#0139" rel="noopener ugc nofollow">Removing the Dataframe</a></span><span id="905d" class="lz ma iq lu b gy mf mc l md me"><a class="ae mg" href="#bea9" rel="noopener ugc nofollow">Using Numba</a></span></pre></div><div class="ab cl mh mi hu mj" role="separator"><span class="mk bw bk ml mm mn"/><span class="mk bw bk ml mm mn"/><span class="mk bw bk ml mm"/></div><div class="ij ik il im in"><h2 id="ad67" class="lz ma iq bd mo mp mq dn mr ms mt dp mu le mv mw mx li my mz na lm nb nc nd ne bi translated">更新</h2><blockquote class="nf ng nh"><p id="28a7" class="kv kw ni kx b ky kz jr la lb lc ju ld nj lf lg lh nk lj lk ll nl ln lo lp lq ij bi translated">4.11.22:添加代码表</p></blockquote></div><div class="ab cl mh mi hu mj" role="separator"><span class="mk bw bk ml mm mn"/><span class="mk bw bk ml mm mn"/><span class="mk bw bk ml mm"/></div><div class="ij ik il im in"><h1 id="dde6" class="nm ma iq bd mo nn no np mr nq nr ns mu jw nt jx mx jz nu ka na kc nv kd nd nw bi translated">AUC-Recall@k指标</h1><p id="74fe" class="pw-post-body-paragraph kv kw iq kx b ky nx jr la lb ny ju ld le nz lg lh li oa lk ll lm ob lo lp lq ij bi translated">我们选择的度量标准计算了我们的模型达到的<code class="fe lr ls lt lu b">Recall@k</code>曲线下的理想区域的比例。</p><pre class="kg kh ki kj gt lv lu lw lx aw ly bi"><span id="2057" class="lz ma iq lu b gy mb mc l md me">AUC Recall@k = Area under Recall@k / Area under Ideal Recall@k</span></pre><p id="a967" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">这需要两个计算:理想的<code class="fe lr ls lt lu b">recall@k</code>曲线，当然，还有我们模型的<code class="fe lr ls lt lu b">recall@k</code>曲线。我们先定义一下什么是<code class="fe lr ls lt lu b">Recall@k</code>。</p><h2 id="0dcb" class="lz ma iq bd mo mp mq dn mr ms mt dp mu le mv mw mx li my mz na lm nb nc nd ne bi translated">回忆@k</h2><p id="3542" class="pw-post-body-paragraph kv kw iq kx b ky nx jr la lb ny ju ld le nz lg lh li oa lk ll lm ob lo lp lq ij bi translated">这是评估推荐系统的一个流行指标，通常是排名，通常与<code class="fe lr ls lt lu b">Precision@k</code>一起计算。</p><blockquote class="oc"><p id="4b8b" class="od oe iq bd of og oh oi oj ok ol lq dk translated"><code class="fe lr ls lt lu b">Recall@k</code>回答问题:</p><p id="aed7" class="od oe iq bd of og oh oi oj ok ol lq dk translated">在所有正确的建议中，有多少出现在您的模型的前k名建议中？</p></blockquote><pre class="om on oo op oq lv lu lw lx aw ly bi"><span id="96b7" class="lz ma iq lu b gy mb mc l md me">Recall@k = # correct recommendations in the top k / # total correct</span></pre><p id="5a01" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">很明显，随着k的增加，<code class="fe lr ls lt lu b">Recall@k</code>也增加，当<code class="fe lr ls lt lu b">k</code>等于文档总数时，最终达到值<code class="fe lr ls lt lu b">1</code>。请注意，对于较小的<code class="fe lr ls lt lu b">k</code>，它也可能到达<code class="fe lr ls lt lu b">1</code>。</p><h2 id="1e1f" class="lz ma iq bd mo mp mq dn mr ms mt dp mu le mv mw mx li my mz na lm nb nc nd ne bi translated">计算召回@k曲线</h2><p id="f6bc" class="pw-post-body-paragraph kv kw iq kx b ky nx jr la lb ny ju ld le nz lg lh li oa lk ll lm ob lo lp lq ij bi translated">现在我们有了计算<code class="fe lr ls lt lu b">Recall@k</code>的方法，为了得到曲线，我们为从0到推荐总数的每个<code class="fe lr ls lt lu b">k</code>计算<code class="fe lr ls lt lu b">Recall@k</code>。</p><pre class="kg kh ki kj gt lv lu lw lx aw ly bi"><span id="8fd5" class="lz ma iq lu b gy mb mc l md me">Recall@k Curve = [Recall@0, Recall@1, Recall@2, Recall@3, ..]</span></pre><h2 id="e8af" class="lz ma iq bd mo mp mq dn mr ms mt dp mu le mv mw mx li my mz na lm nb nc nd ne bi translated">计算理想召回@k曲线</h2><p id="7a20" class="pw-post-body-paragraph kv kw iq kx b ky nx jr la lb ny ju ld le nz lg lh li oa lk ll lm ob lo lp lq ij bi translated">理想<code class="fe lr ls lt lu b">Recall@k</code>曲线背后的直觉是，在理想世界中，每个相关文档的排名都会高于不相关的文档。结果会是这样的排名顺序:</p><pre class="kg kh ki kj gt lv lu lw lx aw ly bi"><span id="0893" class="lz ma iq lu b gy mb mc l md me">[1, 1, 1, ... 1, 0, 0 ... 0]</span></pre><p id="bc82" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">每次我们增加<code class="fe lr ls lt lu b">k</code>，我们总是在考虑多一个相关的文档。一旦我们覆盖了所有相关的文档，我们的<code class="fe lr ls lt lu b">recall@k</code>就已经点击了<code class="fe lr ls lt lu b">1</code>。在那之后，它保持不变，因为没有更多的相关文件影响我们的召回。</p><pre class="kg kh ki kj gt lv lu lw lx aw ly bi"><span id="dbc8" class="lz ma iq lu b gy mb mc l md me">Ideal Recall@k = k / total relevant documents<br/>                       (when k &lt;= # relevant docs)<br/>               = 1<br/>                       (when k &gt; # relevant docs)</span></pre><p id="7133" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">更简洁地说，</p><pre class="kg kh ki kj gt lv lu lw lx aw ly bi"><span id="f2fa" class="lz ma iq lu b gy mb mc l md me">Ideal Recall@k = min(1, k / total relevant documents)</span></pre><p id="45f3" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">由于我们对理想的<code class="fe lr ls lt lu b">recall@k</code>曲线感兴趣，我们将对每个<code class="fe lr ls lt lu b">k</code>进行外推。</p><h2 id="a91f" class="lz ma iq bd mo mp mq dn mr ms mt dp mu le mv mw mx li my mz na lm nb nc nd ne bi translated">计算AUC-召回@k</h2><p id="e0f4" class="pw-post-body-paragraph kv kw iq kx b ky nx jr la lb ny ju ld le nz lg lh li oa lk ll lm ob lo lp lq ij bi translated">现在我们有了两条曲线——回忆@k和理想回忆@ k——AUC分数就是它们的面积比。</p><pre class="kg kh ki kj gt lv lu lw lx aw ly bi"><span id="5e8f" class="lz ma iq lu b gy mb mc l md me">AUC-Recall@k = Area under Recall@k / Area under the ideal Recall@k</span></pre><h1 id="17ff" class="nm ma iq bd mo nn or np mr nq os ns mu jw ot jx mx jz ou ka na kc ov kd nd nw bi translated">基线实施</h1><p id="33db" class="pw-post-body-paragraph kv kw iq kx b ky nx jr la lb ny ju ld le nz lg lh li oa lk ll lm ob lo lp lq ij bi translated">让我们从一个基本的实现开始，来欣赏后续版本中的性能改进。请注意，这种实现故意很慢，只是作为糟糕的代码的代表。</p><h2 id="e9fe" class="lz ma iq bd mo mp mq dn mr ms mt dp mu le mv mw mx li my mz na lm nb nc nd ne bi translated">数据框架</h2><p id="6df9" class="pw-post-body-paragraph kv kw iq kx b ky nx jr la lb ny ju ld le nz lg lh li oa lk ll lm ob lo lp lq ij bi translated">我们将首先创建我们的模型的置信度得分和目标的数据框架，其中<code class="fe lr ls lt lu b">1</code>代表相关文档，而<code class="fe lr ls lt lu b">0</code>代表不相关文档。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ow ox l"/></div></figure><h2 id="4c23" class="lz ma iq bd mo mp mq dn mr ms mt dp mu le mv mw mx li my mz na lm nb nc nd ne bi translated">实现召回@k曲线的计算</h2><p id="7aac" class="pw-post-body-paragraph kv kw iq kx b ky nx jr la lb ny ju ld le nz lg lh li oa lk ll lm ob lo lp lq ij bi translated">为了计算你的模型的<code class="fe lr ls lt lu b">recall@k</code>，迭代排名列表并计算每个点的<code class="fe lr ls lt lu b">recall</code>。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ow ox l"/></div></figure><h2 id="7b59" class="lz ma iq bd mo mp mq dn mr ms mt dp mu le mv mw mx li my mz na lm nb nc nd ne bi translated">实现理想召回率@k曲线的计算</h2><p id="c594" class="pw-post-body-paragraph kv kw iq kx b ky nx jr la lb ny ju ld le nz lg lh li oa lk ll lm ob lo lp lq ij bi translated">正如我们在上一节中所定义的，理想的Recall@k曲线是一个分段函数。我们将使用NumPy的<code class="fe lr ls lt lu b">numpy.minimum</code>函数来实现它。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ow ox l"/></div></figure><h2 id="5c3c" class="lz ma iq bd mo mp mq dn mr ms mt dp mu le mv mw mx li my mz na lm nb nc nd ne bi translated">完整的实现</h2><p id="8947" class="pw-post-body-paragraph kv kw iq kx b ky nx jr la lb ny ju ld le nz lg lh li oa lk ll lm ob lo lp lq ij bi translated">现在我们有了两条曲线，我们将计算它们的面积比，以获得最终的AUC-Recall@k指标。我们将使用NumPy的<code class="fe lr ls lt lu b">numpy.trapz</code>来计算这个。</p><pre class="kg kh ki kj gt lv lu lw lx aw ly bi"><span id="6aa2" class="lz ma iq lu b gy mb mc l md me"># Computing the final metric by getting the proportion of areas<br/>return np.trapz(recall_at_k) / np.trapz(ideal_recall_at_k)</span></pre><p id="7be1" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">整个实现如下所示:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ow ox l"/></div></figure><h1 id="eaf9" class="nm ma iq bd mo nn or np mr nq os ns mu jw ot jx mx jz ou ka na kc ov kd nd nw bi translated">用NumPy函数替换for循环</h1><p id="a3f3" class="pw-post-body-paragraph kv kw iq kx b ky nx jr la lb ny ju ld le nz lg lh li oa lk ll lm ob lo lp lq ij bi translated">提高代码速度的最好方法之一是消除循环。当我们使用它的优化函数时，NumPy的性能改进是有效的。</p><h2 id="281c" class="lz ma iq bd mo mp mq dn mr ms mt dp mu le mv mw mx li my mz na lm nb nc nd ne bi translated">计算召回@k曲线</h2><p id="d950" class="pw-post-body-paragraph kv kw iq kx b ky nx jr la lb ny ju ld le nz lg lh li oa lk ll lm ob lo lp lq ij bi translated">例如，为了计算我们模型的<code class="fe lr ls lt lu b">Recall@k</code>曲线，我们可以使用NumPy的<code class="fe lr ls lt lu b">cumsum</code>函数。</p><p id="dd5f" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">让我们首先将我们的排名存储为一个NumPy数组。回想一下<code class="fe lr ls lt lu b">conf_df</code>是我们的数据框架，它包含了预期的预测和我们的模型分配给它们的置信度分数。</p><pre class="kg kh ki kj gt lv lu lw lx aw ly bi"><span id="ccfe" class="lz ma iq lu b gy mb mc l md me">ranking = conf_df["expected"].to_numpy()</span></pre><p id="c97b" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated"><code class="fe lr ls lt lu b">cumsum</code>逻辑可以这样实现。在我们的例子中，由于<code class="fe lr ls lt lu b">1</code>代表一个相关的文档，我们可以通过简单地计算前k个等级中的<code class="fe lr ls lt lu b">1</code>的数量来计算<code class="fe lr ls lt lu b">recall</code>。</p><pre class="kg kh ki kj gt lv lu lw lx aw ly bi"><span id="0815" class="lz ma iq lu b gy mb mc l md me">recall_at_k = (ranking == 1).cumsum() / (ranking == 1).sum()</span></pre><h2 id="ba89" class="lz ma iq bd mo mp mq dn mr ms mt dp mu le mv mw mx li my mz na lm nb nc nd ne bi translated">计算理想召回@k曲线</h2><p id="a2da" class="pw-post-body-paragraph kv kw iq kx b ky nx jr la lb ny ju ld le nz lg lh li oa lk ll lm ob lo lp lq ij bi translated">虽然理想曲线的整体实现在这里不会改变，因为我们已经在使用NumPy的函数，我们不再需要使用<code class="fe lr ls lt lu b">conf_df</code>，因为我们已经在NumPy数组中有了我们的排名(<code class="fe lr ls lt lu b">ranking</code>)。</p><p id="b613" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">我们将把<code class="fe lr ls lt lu b">ranking</code>替换到现有的实现中。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ow ox l"/></div></figure><h2 id="0d9c" class="lz ma iq bd mo mp mq dn mr ms mt dp mu le mv mw mx li my mz na lm nb nc nd ne bi translated">完整的实现</h2><p id="decb" class="pw-post-body-paragraph kv kw iq kx b ky nx jr la lb ny ju ld le nz lg lh li oa lk ll lm ob lo lp lq ij bi translated">我们的函数现在看起来像这样:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ow ox l"/></div></figure><h1 id="0139" class="nm ma iq bd mo nn or np mr nq os ns mu jw ot jx mx jz ou ka na kc ov kd nd nw bi translated">移除数据框</h1><p id="f16f" class="pw-post-body-paragraph kv kw iq kx b ky nx jr la lb ny ju ld le nz lg lh li oa lk ll lm ob lo lp lq ij bi translated">在我们之前的方法中，虽然我们从数据帧开始，但最终我们使用了NumPy数组。移除数据帧应该会给我们一个不错的改进。</p><p id="9556" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">如果我们看看创建数据框架的主要原因，它只是根据我们模型的置信度对预测进行排序。这可以使用NumPy轻松实现。我们需要做的就是使用一个数组的排序索引来重新排序另一个数组。</p><p id="f6f8" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">在我们的例子中，我们将像以前一样对置信度得分数组进行降序排序，然后使用这些索引对我们的文档数组进行重新排序。</p><p id="843a" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">让我们称文档数组为<code class="fe lr ls lt lu b">y_true</code>，置信度数组为<code class="fe lr ls lt lu b">y_conf</code>。排序可以结合NumPy的<code class="fe lr ls lt lu b">argsort</code>和索引来完成。</p><pre class="kg kh ki kj gt lv lu lw lx aw ly bi"><span id="cef5" class="lz ma iq lu b gy mb mc l md me">ranking = y_true[np.argsort(y_conf)[::-1]]</span></pre><h2 id="239f" class="lz ma iq bd mo mp mq dn mr ms mt dp mu le mv mw mx li my mz na lm nb nc nd ne bi translated">完整的实现</h2><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ow ox l"/></div></figure><h1 id="bea9" class="nm ma iq bd mo nn or np mr nq os ns mu jw ot jx mx jz ou ka na kc ov kd nd nw bi translated">使用Numba</h1><p id="d376" class="pw-post-body-paragraph kv kw iq kx b ky nx jr la lb ny ju ld le nz lg lh li oa lk ll lm ob lo lp lq ij bi translated">在运行这些实验时，我很好奇是否有更简单的方法来获得额外的性能提升。我遇到了Numba，根据他们的说法是:</p><blockquote class="oc"><p id="42f5" class="od oe iq bd of og oh oi oj ok ol lq dk translated">Numba是一个开源的JIT编译器，它将Python和NumPy代码的子集翻译成快速的机器代码。</p></blockquote><p id="0772" class="pw-post-body-paragraph kv kw iq kx b ky oy jr la lb oz ju ld le pa lg lh li pb lk ll lm pc lo lp lq ij bi translated">他们的快速入门指南《Numba 5分钟指南》提到Numba最适合循环和NumPy代码，但不适合熊猫。因为我们已经在前面的方法中专门使用了NumPy，所以尝试一下似乎是个好主意。</p><p id="34cd" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">虽然我还没有探索Numba提供的所有功能，但我发现了他们的<code class="fe lr ls lt lu b">jit</code>装饰器，它可以优化任何用。</p><p id="fff6" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">所以，我们最后的Numba方法需要简单地在我们之前的函数上添加Numba的<code class="fe lr ls lt lu b">jit</code>装饰器。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ow ox l"/></div></figure><h1 id="c4f0" class="nm ma iq bd mo nn or np mr nq os ns mu jw ot jx mx jz ou ka na kc ov kd nd nw bi translated">结果呢</h1><p id="9157" class="pw-post-body-paragraph kv kw iq kx b ky nx jr la lb ny ju ld le nz lg lh li oa lk ll lm ob lo lp lq ij bi translated">我们将在四种数据集规模上比较这些方法的性能:</p><ul class=""><li id="4b73" class="pd pe iq kx b ky kz lb lc le pf li pg lm ph lq pi pj pk pl bi translated">5份文件</li><li id="9481" class="pd pe iq kx b ky pm lb pn le po li pp lm pq lq pi pj pk pl bi translated">100份文件</li><li id="a351" class="pd pe iq kx b ky pm lb pn le po li pp lm pq lq pi pj pk pl bi translated">10k文档</li><li id="5329" class="pd pe iq kx b ky pm lb pn le po li pp lm pq lq pi pj pk pl bi translated">100k文档</li></ul><h2 id="399e" class="lz ma iq bd mo mp mq dn mr ms mt dp mu le mv mw mx li my mz na lm nb nc nd ne bi translated">原始值</h2><p id="5ec3" class="pw-post-body-paragraph kv kw iq kx b ky nx jr la lb ny ju ld le nz lg lh li oa lk ll lm ob lo lp lq ij bi translated">为了运行这些实验，我使用了<code class="fe lr ls lt lu b">timeit</code>这个神奇的命令。</p><p id="ebc6" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">例如，在100k数据集上，基线方法的性能是这样计算的:</p><pre class="kg kh ki kj gt lv lu lw lx aw ly bi"><span id="8c92" class="lz ma iq lu b gy mb mc l md me">%timeit -o auc_recall_at_k_np_no_df_numba(np.random.randint(0, 2, 100000), np.random.rand(100000))</span></pre><p id="f4f2" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">最终原始时间(毫秒)为:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi pr"><img src="../Images/fac9a9d040b13f705019aeab6a2ec2c7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*zGhLZd5BGON5AfrLbqLMjg.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">运行时间(毫秒)—越小越好</p></figure><h2 id="2235" class="lz ma iq bd mo mp mq dn mr ms mt dp mu le mv mw mx li my mz na lm nb nc nd ne bi translated">相对性能</h2><p id="0ff5" class="pw-post-body-paragraph kv kw iq kx b ky nx jr la lb ny ju ld le nz lg lh li oa lk ll lm ob lo lp lq ij bi translated">让我们首先来看看我们所有实验的相对性能，并与时间最少的实验进行比较——在五个数据点上的Numba。在下面的图表中，我们可以看到，从使用for循环的基线方法到使用Numba性能提升的方法，我们的实验的相对性能有了显著的提高。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi ps"><img src="../Images/0e34c686a70098db4cff09551bcdd66d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*2wb4ZKqjlN2h1u64Ch7xvA.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">5个数据点上Numba的对数标度相对性能—越小越好</p></figure><p id="f1ad" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated"><strong class="kx ir">重点观察</strong></p><blockquote class="nf ng nh"><p id="9edc" class="kv kw ni kx b ky kz jr la lb lc ju ld nj lf lg lh nk lj lk ll nl ln lo lp lq ij bi translated">一旦我们承诺使用NumPy(从第二个实验开始)，我们就会看到性能的显著提升。随着我们进一步提高，我们得到的回报越来越少。</p></blockquote><h2 id="1e54" class="lz ma iq bd mo mp mq dn mr ms mt dp mu le mv mw mx li my mz na lm nb nc nd ne bi translated">在10k和100k文档上</h2><p id="2f9d" class="pw-post-body-paragraph kv kw iq kx b ky nx jr la lb ny ju ld le nz lg lh li oa lk ll lm ob lo lp lq ij bi translated">如果我们放大到10k和100k的数据集大小，趋势就更容易可视化了。随着数据集大小的增加，基线实现的性能下降最多。另一方面，添加Numba的性能提升使我们的实现速度提高了30–40 %,考虑到我们所要做的只是在函数顶部添加四个字母，这还不算太差。</p><p id="ee58" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">图中的数据标签是下面的原始时间(毫秒):</p><div class="kg kh ki kj gt ab cb"><figure class="pt kk pu pv pw px py paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><img src="../Images/fd489a72f23e3de973f5ea176f6c5d8b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1002/format:webp/1*2dWyYYln0RsDSb4RUF6RNA.png"/></div></figure><figure class="pt kk pz pv pw px py paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><img src="../Images/ca7fa72b2d6f7d47f8266d2d3b2499e7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1000/format:webp/1*qYOC2yRrT1q1zZSwAncL-Q.png"/></div><p class="kr ks gj gh gi kt ku bd b be z dk qa di qb qc translated">10k(左)和100k(右)文档的对数级性能—越小越好</p></figure></div><h1 id="b3af" class="nm ma iq bd mo nn or np mr nq os ns mu jw ot jx mx jz ou ka na kc ov kd nd nw bi translated">参考和示例代码</h1><h2 id="2857" class="lz ma iq bd mo mp mq dn mr ms mt dp mu le mv mw mx li my mz na lm nb nc nd ne bi translated">密码</h2><div class="qd qe gp gr qf qg"><a href="https://github.com/Polaris000/BlogCode/tree/main/NumpyOptimization" rel="noopener  ugc nofollow" target="_blank"><div class="qh ab fo"><div class="qi ab qj cl cj qk"><h2 class="bd ir gy z fp ql fr fs qm fu fw ip bi translated">blog code/num优化主极化000/BlogCode</h2><div class="qn l"><h3 class="bd b gy z fp ql fr fs qm fu fw dk translated">示例代码来自我在Medium和我的个人网站上的博客文章。—主页面上的博客代码/数字优化…</h3></div><div class="qo l"><p class="bd b dl z fp ql fr fs qm fu fw dk translated">github.com</p></div></div><div class="qp l"><div class="qq l qr qs qt qp qu kp qg"/></div></div></a></div><h1 id="c5f0" class="nm ma iq bd mo nn or np mr nq os ns mu jw ot jx mx jz ou ka na kc ov kd nd nw bi translated">参考</h1><ul class=""><li id="75e4" class="pd pe iq kx b ky nx lb ny le qv li qw lm qx lq pi pj pk pl bi translated">https://numpy.org/</li><li id="2bd0" class="pd pe iq kx b ky pm lb pn le po li pp lm pq lq pi pj pk pl bi translated">Numba的五分钟指南:【https://numba.readthedocs.io/en/stable/user/5minguide.html T2】</li><li id="c6cf" class="pd pe iq kx b ky pm lb pn le po li pp lm pq lq pi pj pk pl bi translated">the time it magic:<a class="ae mg" href="https://ipython.readthedocs.io/en/stable/interactive/magics.html#magic-timeit" rel="noopener ugc nofollow" target="_blank">https://ipython . readthedocs . io/en/stable/interactive/magics . html # magic-time it</a></li></ul><h1 id="d06b" class="nm ma iq bd mo nn or np mr nq os ns mu jw ot jx mx jz ou ka na kc ov kd nd nw bi translated">结论</h1><p id="8316" class="pw-post-body-paragraph kv kw iq kx b ky nx jr la lb ny ju ld le nz lg lh li oa lk ll lm ob lo lp lq ij bi translated">本文并不打算成为编写更好代码的全面指南。相反，这是为了展示什么是可能的。虽然我确信这里还有进一步改进的空间——例如，通过进一步探索Numba或将任何重复的函数调用存储在变量中——但很明显用NumPy的内置函数替换循环会产生多大的不同。</p><p id="caba" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">如果没有别的，我希望读者看到如此琐碎的事情是如何为你节省时间的。</p></div></div>    
</body>
</html>