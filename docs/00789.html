<html>
<head>
<title>Building Basic React Authentication</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">构建基本的反应认证</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/building-basic-react-authentication-e20a574d5e71?source=collection_archive---------0-----------------------#2019-07-15">https://betterprogramming.pub/building-basic-react-authentication-e20a574d5e71?source=collection_archive---------0-----------------------#2019-07-15</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="9d94" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">在react路由器中使用钩子和上下文</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/79661286f0184ba72a51fa42652f8e4d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*dJUgnFsCVI5gTdGpgxvhWA.jpeg"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">Artem Sapegin 在<a class="ae ky" href="https://unsplash.com/search/photos/react?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</p></figure><p id="22ac" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我一直在做一些建设应用程序的合同工作，当开始时，我有一个“绿地”的特权。我选择了一些常见的嫌疑人，<a class="ae ky" href="https://reactjs.org/" rel="noopener ugc nofollow" target="_blank">反应</a>(当然是用钩子！)、<a class="ae ky" href="https://www.styled-components.com/" rel="noopener ugc nofollow" target="_blank">风格化-组件</a>、<a class="ae ky" href="https://reacttraining.com/react-router/web/guides/quick-start" rel="noopener ugc nofollow" target="_blank">反应式-路由器</a>等。但是在开发它的过程中，我遇到了一个问题集——一个我每次都会遇到的问题:创建一个基本的身份验证系统。</p><p id="4448" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">老实说，我真的没有一个<em class="lv">标准的</em>方法来在React应用程序中进行身份验证。回顾我以前的工作，关于我如何处理令牌、组件和身份验证路由，这似乎是一个相当混杂的问题。因此，我选择了一种我最喜欢的管理身份验证的方法，对其进行了一点改进，并将使用react-router将其作为基本身份验证系统的基础。</p><p id="89e7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">注意:在我使用它之前，这个认证缺少了许多需要添加的部分，请查看结束注释以获得一些想法。但是这些都是开始的良好开端！</p></div><div class="ab cl lw lx hx ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="im in io ip iq"><h1 id="f533" class="md me it bd mf mg mh mi mj mk ml mm mn jz mo ka mp kc mq kd mr kf ms kg mt mu bi translated">该认证系统的目标</h1><ul class=""><li id="db03" class="mv mw it lb b lc mx lf my li mz lm na lq nb lu nc nd ne nf bi translated"><strong class="lb iu">私人和公共路线</strong>:这个应用程序将有基本的“登陆”页面，任何用户都可以访问。除此之外，注册和登录应该是声明性的公共途径。另一方面，将会有许多需要验证才能查看的页面。</li><li id="80b3" class="mv mw it lb b lc ng lf nh li ni lm nj lq nk lu nc nd ne nf bi translated"><strong class="lb iu">重定向至登录</strong>:如果用户没有令牌，或者令牌刷新不起作用，当用户试图查看私有路由时，将自动重定向至登录页面。</li><li id="5c44" class="mv mw it lb b lc ng lf nh li ni lm nj lq nk lu nc nd ne nf bi translated"><strong class="lb iu">重定向到referrer </strong>:如果用户想要查看特定页面，但没有有效的令牌，他们将被重定向到登录页面。我们希望确保在登录后，他们被发送到他们最初想要的页面。默认为仪表板。</li><li id="4447" class="mv mw it lb b lc ng lf nh li ni lm nj lq nk lu nc nd ne nf bi translated"><strong class="lb iu">认证令牌</strong>:我们将使用令牌来读写认证。这些应该存储在本地存储，以便用户可以保持登录，如果他们离开网站。</li><li id="3e32" class="mv mw it lb b lc ng lf nh li ni lm nj lq nk lu nc nd ne nf bi translated"><strong class="lb iu">用户界面直观明了</strong>:这真的不是什么用户界面方面的“考试”，但我认为我们的登录和注册页面必须简单，并遵循Brad Frost <a class="ae ky" href="http://bradfrost.com/blog/post/dont-get-clever-with-login-forms/" rel="noopener ugc nofollow" target="_blank">在这里</a>列出的注意事项。</li></ul><p id="f88c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们将尝试按顺序解决这些问题，以确保我们不会用太多的代码使流程过载。最好重构代码并理解整个过程，而不是从一开始就期望所有这些都能工作。我们在这里不会使用<a class="ae ky" href="https://redux.js.org/" rel="noopener ugc nofollow" target="_blank">Redux</a>——相反，我们将在react上下文中存储我们需要的数据，以保持简单。在引擎盖下，Redux会做一些类似的事情，但该应用程序的大小还不足以保证目前使用Redux。</p><p id="4fd0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们开始吧！</p></div><div class="ab cl lw lx hx ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="im in io ip iq"><h1 id="45ae" class="md me it bd mf mg mh mi mj mk ml mm mn jz mo ka mp kc mq kd mr kf ms kg mt mu bi translated">项目初始化</h1><p id="0187" class="pw-post-body-paragraph kz la it lb b lc mx ju le lf my jx lh li nl lk ll lm nm lo lp lq nn ls lt lu im bi translated">让我们用我们的基础项目做一些基础工作。这将在你自己的项目中，但是让我们假设我们是从零开始——只是为了更容易理解。如果您想继续，请查看github 上的<a class="ae ky" href="https://github.com/DennyScott/react-router-auth" rel="noopener ugc nofollow" target="_blank">完整代码——我们正在使用</a><a class="ae ky" href="https://github.com/facebook/create-react-app" rel="noopener ugc nofollow" target="_blank"> Create React App </a>设置基础项目，如下所示:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="no np l"/></div></figure><p id="93f0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我不会在这个项目中为我的文件建立任何永久的架构。每个人都有自己的文件夹/文件架构风格，所以我想尽可能保持不可知论，以便人们遵循。</p><p id="9a45" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">或者，也许我正试图避免引发人们不使用我的架构！</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi nq"><img src="../Images/e8eb83299c5a20738ef1de09b51c3e05.png" data-original-src="https://miro.medium.com/v2/resize:fit:1280/format:webp/0*8s2VTz1RPFDmAxl7.jpg"/></div></figure><p id="081c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们的下一步将是安装我们需要的软件包。我们正在安装<a class="ae ky" href="https://reacttraining.com/react-router/web/guides/quick-start" rel="noopener ugc nofollow" target="_blank">反应路由器</a>和<a class="ae ky" href="https://www.styled-components.com/" rel="noopener ugc nofollow" target="_blank">样式组件</a>和<a class="ae ky" href="https://github.com/axios/axios" rel="noopener ugc nofollow" target="_blank">轴</a>。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="no np l"/></div></figure><p id="032d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">很好，现在让我们设置反应路由器。我们将修改我们的<code class="fe nr ns nt nu b">App.js</code>组件，增加一些基本路线。现在，让我们添加一个公共的<code class="fe nr ns nt nu b">Home</code>页面和一个公共的<code class="fe nr ns nt nu b">Admin</code>页面。别担心，我们很快就会把它改成私人的。</p><p id="d043" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">请注意，我们将导入两个尚未创建的文件。我只是想让我们在进入我们正在制作的页面的细节之前看看路由器。</p><h2 id="1d3b" class="nv me it bd mf nw nx dn mj ny nz dp mn li oa ob mp lm oc od mr lq oe of mt og bi translated"><strong class="ak"> src/App.js </strong></h2><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="no np l"/></div></figure><p id="e0ea" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们现在还将为主页和管理页面创建这两个组件。让我们在<code class="fe nr ns nt nu b">src</code>目录中创建一个名为<code class="fe nr ns nt nu b">pages.</code>的新文件夹。我们将在这个目录中创建两个新页面。不出所料，它们将被命名为<code class="fe nr ns nt nu b">Home.js</code>和<code class="fe nr ns nt nu b">Admin.js.</code>，不过你不需要导入它们，因为我们已经在上面做了。</p><h2 id="82a8" class="nv me it bd mf nw nx dn mj ny nz dp mn li oa ob mp lm oc od mr lq oe of mt og bi translated"><strong class="ak"> src/pages/Home.js </strong></h2><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="no np l"/></div></figure><h2 id="2776" class="nv me it bd mf nw nx dn mj ny nz dp mn li oa ob mp lm oc od mr lq oe of mt og bi translated"><strong class="ak"> src/pages/Admin.js </strong></h2><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="no np l"/></div></figure><p id="efae" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这应该可以建立项目的初始结构。从这里，我们可以开始添加我们的认证系统的各个部分。一定要给它一个测试运行与<code class="fe nr ns nt nu b">npm start.</code>你应该能够在页面之间导航，只有主页或管理页面应该显示。</p></div><div class="ab cl lw lx hx ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="im in io ip iq"><h1 id="59d2" class="md me it bd mf mg mh mi mj mk ml mm mn jz mo ka mp kc mq kd mr kf ms kg mt mu bi translated">等等，我们现在做了什么？</h1><p id="8edc" class="pw-post-body-paragraph kz la it lb b lc mx ju le lf my jx lh li nl lk ll lm nm lo lp lq nn ls lt lu im bi translated">在我们继续之前，让我们确保对spa和react-router有一个基本的了解。如果您以前使用过路由器和spa，欢迎您跳过这一部分！</p><p id="df69" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">Create-React-App是一个非常棒的项目，可以处理大量创建新React应用程序的繁重工作。在幕后，有许多不同的部分需要放在一起，特别是模块捆绑。这是一个不同的话题，但对我们来说，它让我们只关注应用程序本身，而不必担心配置。</p><p id="977a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在，我们有几种不同的方式向用户展示网页。传统上，网页是从web服务器提供给用户的。用户将访问一个类似于<code class="fe nr ns nt nu b"><a class="ae ky" href="http://www.dennyssweetwebsite.com/hello,`" rel="noopener ugc nofollow" target="_blank">http://www.dennyssweetwebsite.com/hello</a></code>的URL，托管我的网站的服务器将收到请求，找出他们正在寻找的页面(在本例中为<code class="fe nr ns nt nu b">hello</code>)，并返回用户<code class="fe nr ns nt nu b">hello.html</code>，这是一个驻留在服务器上的HTML文件。</p><p id="79d7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">随着web变得越来越复杂，这些调用将解析到服务器应用程序，运行在类似于<code class="fe nr ns nt nu b">PHP</code>的东西上，为用户生成HTML页面并返回数据。这里需要注意的关键一点是，用户指定的URL与web服务器上的路由直接相关。因此，生成和返回内容是一个实际的网络地址。</p><p id="d678" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">另一方面，Create React App搭建了一个客户端<a class="ae ky" href="https://en.wikipedia.org/wiki/Single-page_application" rel="noopener ugc nofollow" target="_blank">单页面应用(或<strong class="lb iu"> SPA </strong> ) </a>。单页应用程序是完全驻留在用户浏览器上的web应用程序。当用户请求<code class="fe nr ns nt nu b">www.dennyssweetwebsite.com</code>时，他们会收到我的整个应用程序。从那以后，我们实际上甚至不需要URL。用户可以查看的内容可以直接由状态处理，而无需更改URL。</p><p id="ca2b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">问题是浏览器和用户仍然高度依赖URL。浏览器允许你在历史中来回移动，给特定的页面做书签，等等。用户可能会标记特定的页面，并希望直接跳转到那里。他们甚至可以记住网址。同样，公平地说，URL是分离我们内容的一个很好的方式，特别是当涉及到像基于路径的<a class="ae ky" href="https://reactjs.org/docs/code-splitting.html" rel="noopener ugc nofollow" target="_blank">延迟加载</a>这样的事情时。就此而言，许多单页面应用程序仍然使用路由系统来分割它们的内容。这只是读取给定的URL，而不是将更改传递给服务器，而是显示给定URL的组件。基于路线渲染组件正是我们在上面的<code class="fe nr ns nt nu b">App.js</code>中所做的。</p><p id="7b8d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">好了，历史课结束了，让我们开始建造一些私人路线。</p></div><div class="ab cl lw lx hx ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="im in io ip iq"><h1 id="e611" class="md me it bd mf mg mh mi mj mk ml mm mn jz mo ka mp kc mq kd mr kf ms kg mt mu bi translated">私人和公共路线</h1><p id="c101" class="pw-post-body-paragraph kz la it lb b lc mx ju le lf my jx lh li nl lk ll lm nm lo lp lq nn ls lt lu im bi translated">我们要设置的第一件事是一个新的路由组件，我们称之为<code class="fe nr ns nt nu b">PrivateRoute</code>。这个装饰器将被任何需要在认证之后的路由使用。很简单，让我们在“src”目录下创建一个名为<code class="fe nr ns nt nu b">PrivateRoute.js.</code>的新文件</p><h2 id="5cea" class="nv me it bd mf nw nx dn mj ny nz dp mn li oa ob mp lm oc od mr lq oe of mt og bi translated"><strong class="ak"> src/PrivateRoute.js </strong></h2><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="no np l"/></div></figure><p id="4b96" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">您会注意到我们还没有添加任何身份验证逻辑。我们只是呈现传入的路由，就像公共路由一样。不过，我们对API做了一些小改动。我们在这里使用<a class="ae ky" href="https://reactjs.org/docs/render-props.html" rel="noopener ugc nofollow" target="_blank">渲染道具</a>样式来代替路线。稍后当我们添加认证逻辑时，这将更有意义——现在，假设它与使用公共路线的<code class="fe nr ns nt nu b">Component</code>道具做同样的事情。</p><p id="2822" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在，如果你看看渲染道具，很明显我们应该在里面有一些认证。但是我们还没有完全建立起来。我们没有使用Redux，但我们可能希望在整个应用程序中使用认证数据。为了避免道具钻取，我们将使用<a class="ae ky" href="https://reactjs.org/docs/context.html" rel="noopener ugc nofollow" target="_blank">上下文API </a>。我们将有另一个关于上下文API范围的博客条目，但是现在让我们假设我们放入其中的数据可以在react树中的任何地方删除。在幕后，这就是Redux所使用的。</p><p id="6fdd" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">首先，我们要创建一个新的环境。我在src目录中创建了一个名为<code class="fe nr ns nt nu b">context</code>的文件夹。在其中，我将创建一个名为<code class="fe nr ns nt nu b">auth.js.</code>的新文件</p></div><div class="ab cl lw lx hx ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="im in io ip iq"><h2 id="a9c2" class="nv me it bd mf nw nx dn mj ny nz dp mn li oa ob mp lm oc od mr lq oe of mt og bi translated"><strong class="ak"> src/context/auth.js </strong></h2><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="no np l"/></div></figure><p id="8542" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这里我们创建了下一个上下文，以及一个<a class="ae ky" href="https://reactjs.org/docs/hooks-intro.html" rel="noopener ugc nofollow" target="_blank">钩子</a>来使用这个上下文，这个钩子叫做<code class="fe nr ns nt nu b">useAuth.</code>,我们稍后再来讨论。到目前为止，还没有完成任何逻辑—它将提取在AuthContext中找到的任何数据。为了使用我们的新上下文，我们需要添加一个提供者来作出反应。我们将把这个提供者添加到<code class="fe nr ns nt nu b">App.js</code>文件中。当我们这样做的时候，让我们改变我们的管理路径来使用新的<code class="fe nr ns nt nu b">PrivateRoute</code>组件。</p><p id="6f36" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu"> src/App.js </strong></p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="no np l"/></div></figure></div><div class="ab cl lw lx hx ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="im in io ip iq"><h1 id="51de" class="md me it bd mf mg mh mi mj mk ml mm mn jz mo ka mp kc mq kd mr kf ms kg mt mu bi translated">重定向到主页</h1><p id="d7a2" class="pw-post-body-paragraph kz la it lb b lc mx ju le lf my jx lh li nl lk ll lm nm lo lp lq nn ls lt lu im bi translated">我们的PrivateRoute在技术上是可行的，唯一真正让它“工作”的方法是让用户无法访问未经认证的页面。因此，让我们完成我们的第二个目标:如果他们目前还没有通过身份验证，将他们重定向到主页。稍后我们将把它连接到登录页面。</p><p id="11f0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">注意，我们正在为提供者传递值<code class="fe nr ns nt nu b">false</code>。这意味着我们的<code class="fe nr ns nt nu b">useAuth</code>钩子在检查身份验证时将总是返回false因此，所有私有路由都是不可访问的。不理想，但很适合我们现在测试！为了让这个功能正常工作，我们只需要将<code class="fe nr ns nt nu b">useAuth</code>钩子添加到<code class="fe nr ns nt nu b">PrivateRoute</code>组件中。</p><h2 id="c41c" class="nv me it bd mf nw nx dn mj ny nz dp mn li oa ob mp lm oc od mr lq oe of mt og bi translated"><strong class="ak"> src/PrivateRoute.js </strong></h2><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="no np l"/></div></figure><p id="28c4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在这里，我们使用钩子并提取存储在AuthContext中的任何值。稍后我们将使用令牌来更新这个值。目前，它被设置为false。这意味着<code class="fe nr ns nt nu b">isAuthenticated</code>将总是假的，所以当我们点击我们的Route render prop中的逻辑时，它将把我们重定向到主页。稍后，这将是登录页面，但是现在，如果您测试这个，您应该不能到达管理页面—您将停留在主页上。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi oh"><img src="../Images/bba8b2c305e61629f4665bf6eb123e6a.png" data-original-src="https://miro.medium.com/v2/resize:fit:890/0*qjq8ej-rlqPtlL7h.gif"/></div></figure><p id="eec7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">为了确保这是可行的，尝试将<code class="fe nr ns nt nu b">App.js.</code>中的Provider值更改为<code class="fe nr ns nt nu b">true</code>,您现在应该可以自由地去任何您想去的地方。让我们将上下文值改回<code class="fe nr ns nt nu b">false</code>并继续。</p></div><div class="ab cl lw lx hx ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="im in io ip iq"><h1 id="cfc1" class="md me it bd mf mg mh mi mj mk ml mm mn jz mo ka mp kc mq kd mr kf ms kg mt mu bi translated">创建登录和注册页面</h1><p id="bc3e" class="pw-post-body-paragraph kz la it lb b lc mx ju le lf my jx lh li nl lk ll lm nm lo lp lq nn ls lt lu im bi translated">让我们创建一个登录和注册页面。我会试着尽可能做到简约，同时仍然遵循上面强调的布拉德·弗罗斯特的一些指导方针。也就是说，我们将从页面中使用的几个组件开始。首先，我们将在<code class="fe nr ns nt nu b">src</code>、<code class="fe nr ns nt nu b">components</code>和<code class="fe nr ns nt nu b">img</code>中创建两个新文件夹。</p><p id="9355" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们从一个<code class="fe nr ns nt nu b">AuthForm</code>组件开始。为了简单起见，它将只有一些样式组件，我们将在登录和注册之间共享。</p><h2 id="635b" class="nv me it bd mf nw nx dn mj ny nz dp mn li oa ob mp lm oc od mr lq oe of mt og bi translated"><strong class="ak">src/components/auth form . js</strong></h2><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="no np l"/></div></figure><p id="c9b7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">组件非常简单明了。因为我们的重点主要是私有路由逻辑，所以我不打算花时间来描述它，但是我们将能够使用这些组件来构建我们的登录和注册页面。</p><p id="94f9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们需要预先设置的另一个部分是用于注册和登录表单的徽标。我刚刚在<code class="fe nr ns nt nu b">src/img/logo.jpg</code>中放置了一个任意的徽标——一会儿你就会看到它在我们的页面中使用。</p><p id="a837" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在让我们制作登录和注册页面。</p><h2 id="32b3" class="nv me it bd mf nw nx dn mj ny nz dp mn li oa ob mp lm oc od mr lq oe of mt og bi translated"><strong class="ak"> src/pages/Login.js </strong></h2><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="no np l"/></div></figure><h2 id="4619" class="nv me it bd mf nw nx dn mj ny nz dp mn li oa ob mp lm oc od mr lq oe of mt og bi translated"><strong class="ak"> src/pages/Signup.js </strong></h2><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="no np l"/></div></figure><p id="05c1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这两者现在很相似，但将来会有更具体的逻辑。我们不会深入注册，但它是为你准备的！</p><p id="cc93" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">接下来，我们需要添加这些新路线。由于这些用户使用它们登录或创建帐户，因此它们是公共路由。</p><h2 id="5625" class="nv me it bd mf nw nx dn mj ny nz dp mn li oa ob mp lm oc od mr lq oe of mt og bi translated"><strong class="ak"> src/App.js </strong></h2><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="no np l"/></div></figure><p id="d7fa" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">您现在应该能够通过输入URL跳转到登录和注册页面。我们可以稍后添加按钮，但您也应该能够通过点击登录/注册按钮下方的链接在两个页面之间来回导航。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi oi"><img src="../Images/8e9ae37eed1751083b10407223ff1a10.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*PoVTl3XHgUKFk3Id.png"/></div></div></figure><p id="57ba" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">最后一个补充:当用户试图进入Private Route时，我们希望将用户重定向回登录页面。这只需要在<code class="fe nr ns nt nu b">PrivateRoute</code>组件的<code class="fe nr ns nt nu b">redirect</code>中做一个小的更新。</p><h2 id="8ab2" class="nv me it bd mf nw nx dn mj ny nz dp mn li oa ob mp lm oc od mr lq oe of mt og bi translated"><strong class="ak"> src/PrivateRoute.js </strong></h2><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="no np l"/></div></figure></div><div class="ab cl lw lx hx ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="im in io ip iq"><h1 id="8bb6" class="md me it bd mf mg mh mi mj mk ml mm mn jz mo ka mp kc mq kd mr kf ms kg mt mu bi translated">令牌认证</h1><p id="2633" class="pw-post-body-paragraph kz la it lb b lc mx ju le lf my jx lh li nl lk ll lm nm lo lp lq nn ls lt lu im bi translated">我们将在我们的web应用程序中添加基本令牌认证。我们不会深入探讨安全性——也许可以在另一篇博客文章中讨论。现在，我们将构建一个令牌系统，用用户名和密码调用登录端点，并将这些令牌存储在我们的状态和本地存储中。当我们访问私有路由页面时，我们将检查令牌的状态，如果没有令牌，我们将检查本地存储。如果两者都不存在，我们将用户定向到登录页面。你会注意到已经为此设置了很多部分——我们只需要插入一些逻辑。</p><p id="b099" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">第一步:用auth provider上下文的一些新状态更新我们的<code class="fe nr ns nt nu b">App.js</code>。通过在上下文提供者中使用state，我们允许上下文数据是动态的，也就是说，它们不需要在运行前设置。它们可以根据用户的输入而改变。</p><p id="4f55" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们看看实际情况。</p><h2 id="2c10" class="nv me it bd mf nw nx dn mj ny nz dp mn li oa ob mp lm oc od mr lq oe of mt og bi translated"><strong class="ak"> App.js </strong></h2><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="no np l"/></div></figure><p id="bd3a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在，任何使用我们的AuthContext的组件都可以获得令牌<em class="lv">并</em>设置令牌。让我们将这个逻辑插入到我们的登录页面中。此时，我们将使用<a class="ae ky" href="https://reactjs.org/docs/hooks-state.html" rel="noopener ugc nofollow" target="_blank"> useState钩子</a>为我们的登录表单添加状态，并允许用户点击“登录”来触发登录流程。</p><p id="c4fb" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">注意:我已经添加了一个<code class="fe nr ns nt nu b">Axios</code>呼叫。你可以在他们的github上了解更多关于Axios的信息。我们传递的URL显然不是真正的URL——它需要指向分发令牌的某个地方。</p><h2 id="b074" class="nv me it bd mf nw nx dn mj ny nz dp mn li oa ob mp lm oc od mr lq oe of mt og bi translated"><strong class="ak"> Login.js </strong></h2><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="no np l"/></div></figure><p id="dc2d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我不打算进入注册流程——它几乎与登录流程相同。有几个不同之处:第二次需要密码字段，可能是一些其他个人信息，并且使用注册URL而不是登录。</p><p id="4c30" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在，由于我们已经将它移到了令牌流中，并在<code class="fe nr ns nt nu b">App.js</code>上修改了我们的Auth上下文中的对象，所以<code class="fe nr ns nt nu b">PrivateRoute.js</code>中的<code class="fe nr ns nt nu b">isAuthenticated</code>变量实际上指向了一个如下所示的对象:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="no np l"/></div></figure><p id="14ed" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">即使没有赋值，我们的<code class="fe nr ns nt nu b">isAuthenticated</code>也会为真，因为对象总是存在的。为了让这篇博客更加简单，我们假设拥有<code class="fe nr ns nt nu b">authTokens</code>意味着你已经通过了认证。稍后，当调用发生时，我们的授权令牌被指示为过期，我们将清除这个令牌以及本地存储<a class="ae ky" href="https://developer.mozilla.org/en-US/docs/Web/API/Window/localStorage" rel="noopener ugc nofollow" target="_blank"/>。当用户注销时也会发生这种情况。</p><p id="4415" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们现在更新一下。首先，我们使用新的<code class="fe nr ns nt nu b">useAuth</code>钩子从上下文中获取令牌。我们将检查是否已经设置了<code class="fe nr ns nt nu b">authTokens</code>,如果它们确实呈现了组件，如果没有，我们将它们重定向回登录。</p><h2 id="fdb0" class="nv me it bd mf nw nx dn mj ny nz dp mn li oa ob mp lm oc od mr lq oe of mt og bi translated"><strong class="ak"> PrivateRoute.js </strong></h2><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="no np l"/></div></figure></div><div class="ab cl lw lx hx ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="im in io ip iq"><h1 id="f1d7" class="md me it bd mf mg mh mi mj mk ml mm mn jz mo ka mp kc mq kd mr kf ms kg mt mu bi translated">注销和过期令牌</h1><p id="4687" class="pw-post-body-paragraph kz la it lb b lc mx ju le lf my jx lh li nl lk ll lm nm lo lp lq nn ls lt lu im bi translated">令牌身份认证的最后一部分是处理过期的令牌，或者在用户注销时删除令牌。第一部分将是注销流程，因为它会简单一点，并给我们一个强大的工作基础。</p><p id="22ea" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">当注销时，我们可以假设我们的状态和本地存储中的所有令牌都需要删除。让我们在管理页面中制作一个简单的按钮。仅供参考，这将是该网页上的一个巨大的按钮。</p><h2 id="6ea9" class="nv me it bd mf nw nx dn mj ny nz dp mn li oa ob mp lm oc od mr lq oe of mt og bi translated"><strong class="ak"> Admin.js </strong></h2><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="no np l"/></div></figure></div><div class="ab cl lw lx hx ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="im in io ip iq"><h1 id="a534" class="md me it bd mf mg mh mi mj mk ml mm mn jz mo ka mp kc mq kd mr kf ms kg mt mu bi translated">登录后重定向到推荐人(如果有)</h1><p id="87aa" class="pw-post-body-paragraph kz la it lb b lc mx ju le lf my jx lh li nl lk ll lm nm lo lp lq nn ls lt lu im bi translated">让我们想想用户访问我们的web应用程序的方式。到目前为止，我们可以假设用户已经进入我们的主页，然后决定“我要登录”，所以他们导航到我们的<code class="fe nr ns nt nu b">login</code>路线，登录，并被带到仪表板。</p><p id="e955" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我的预期流将试图查看一个页面，需要一个认证令牌将重定向我登录。一旦我成功登录，我将被重定向回我最初试图查看的页面。现在，用户将被重定向到主页。让我们为登录状态添加一个referer值。</p><h2 id="fd07" class="nv me it bd mf nw nx dn mj ny nz dp mn li oa ob mp lm oc od mr lq oe of mt og bi translated"><strong class="ak"> Login.js </strong></h2><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="no np l"/></div></figure><p id="3bcd" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在，当用户登录时，他们将被重定向到推荐网站或主页。让我们将这个新的状态通行证添加到我们的<code class="fe nr ns nt nu b">PrivateRoute.js</code>的重定向中</p><h2 id="5e9d" class="nv me it bd mf nw nx dn mj ny nz dp mn li oa ob mp lm oc od mr lq oe of mt og bi translated"><strong class="ak"> PrivateRoute.js </strong></h2><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="no np l"/></div></figure><p id="bdee" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">用户现在应该被重定向回他们最初试图查看的页面。</p></div><div class="ab cl lw lx hx ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="im in io ip iq"><h1 id="148a" class="md me it bd mf mg mh mi mj mk ml mm mn jz mo ka mp kc mq kd mr kf ms kg mt mu bi translated">结束语</h1><p id="cc44" class="pw-post-body-paragraph kz la it lb b lc mx ju le lf my jx lh li nl lk ll lm nm lo lp lq nn ls lt lu im bi translated">这是基本的走一遍。我们准备好生产了，对吗？嗯，我不会太舒服——还有很多工作要做。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi oj"><img src="../Images/7e7a65161e02df0c823986d058d57785.png" data-original-src="https://miro.medium.com/v2/resize:fit:640/0*q4gB1KknV0yCkGjR.gif"/></div></figure><p id="e29e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">其他一些可能很重要的事情有:</p><ul class=""><li id="d7ba" class="mv mw it lb b lc ld lf lg li ok lm ol lq om lu nc nd ne nf bi translated">具有必要用户数据的用户对象</li><li id="0fb0" class="mv mw it lb b lc ng lf nh li ni lm nj lq nk lu nc nd ne nf bi translated">在初始应用程序装载时检查令牌，以确定它是否过期</li><li id="7b76" class="mv mw it lb b lc ng lf nh li ni lm nj lq nk lu nc nd ne nf bi translated">级联权限，其中经理“限制”的意思是，经理和上面的任何人(例如，管理员)都有访问页面的权限。</li><li id="83a5" class="mv mw it lb b lc ng lf nh li ni lm nj lq nk lu nc nd ne nf bi translated">更好的<a class="ae ky" href="https://developer.mozilla.org/en-US/docs/Web/Security" rel="noopener ugc nofollow" target="_blank">安全性</a>、<a class="ae ky" href="https://reactjs.org/docs/error-boundaries.html" rel="noopener ugc nofollow" target="_blank">错误记录</a>、加载等</li></ul><p id="d5fc" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">也许那是改天的博客。希望这对每个人的基本开始都有帮助。这和我平时写的与表现相关的博客有些不同——有时写起来很有趣。</p><p id="6532" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">正如我所说的，这是一个基本的介绍，但是我发现自己更经常地使用这样的模式。随着我对博客的深入了解，我计划加入更多像这样的基本指南博客或组件设计博客。如果您有任何建议，请在我下面的链接中给我发一条推文。</p></div><div class="ab cl lw lx hx ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="im in io ip iq"><h1 id="6022" class="md me it bd mf mg mh mi mj mk ml mm mn jz mo ka mp kc mq kd mr kf ms kg mt mu bi translated">参考资料和进一步阅读</h1><div class="on oo gp gr op oq"><a href="http://bradfrost.com/blog/post/dont-get-clever-with-login-forms/" rel="noopener  ugc nofollow" target="_blank"><div class="or ab fo"><div class="os ab ot cl cj ou"><h2 class="bd iu gy z fp ov fr fs ow fu fw is bi translated">不要耍登录表单的小聪明</h2><div class="ox l"><h3 class="bd b gy z fp ov fr fs ow fu fw dk translated">随着时间的推移，我发现自己越来越讨厌登录表单。作为密码管理器，如1Password(这是什么…</h3></div><div class="oy l"><p class="bd b dl z fp ov fr fs ow fu fw dk translated">bradfrost.com</p></div></div><div class="oz l"><div class="pa l pb pc pd oz pe ks oq"/></div></div></a></div><div class="on oo gp gr op oq"><a href="https://reactjs.org/" rel="noopener  ugc nofollow" target="_blank"><div class="or ab fo"><div class="os ab ot cl cj ou"><h2 class="bd iu gy z fp ov fr fs ow fu fw is bi translated">react——用于构建用户界面的JavaScript库</h2><div class="ox l"><h3 class="bd b gy z fp ov fr fs ow fu fw dk translated">用于构建用户界面的JavaScript库</h3></div><div class="oy l"><p class="bd b dl z fp ov fr fs ow fu fw dk translated">用于构建用户interfacesreactjs.org的JavaScript库</p></div></div><div class="oz l"><div class="pf l pb pc pd oz pe ks oq"/></div></div></a></div><div class="on oo gp gr op oq"><a href="https://www.styled-components.com" rel="noopener  ugc nofollow" target="_blank"><div class="or ab fo"><div class="os ab ot cl cj ou"><h2 class="bd iu gy z fp ov fr fs ow fu fw is bi translated">样式组件</h2><div class="ox l"><h3 class="bd b gy z fp ov fr fs ow fu fw dk translated">组件时代的视觉原语。使用ES6和CSS的精华来设计你的应用，没有压力💅</h3></div><div class="oy l"><p class="bd b dl z fp ov fr fs ow fu fw dk translated">www.styled-components.com</p></div></div><div class="oz l"><div class="pg l pb pc pd oz pe ks oq"/></div></div></a></div><div class="on oo gp gr op oq"><a href="https://reacttraining.com/react-router/web/guides/quick-start" rel="noopener  ugc nofollow" target="_blank"><div class="or ab fo"><div class="os ab ot cl cj ou"><h2 class="bd iu gy z fp ov fr fs ow fu fw is bi translated">React路由器:React的声明式路由</h2><div class="ox l"><h3 class="bd b gy z fp ov fr fs ow fu fw dk translated">学习一次，路线无处不在</h3></div><div class="oy l"><p class="bd b dl z fp ov fr fs ow fu fw dk translated">reacttraining.com</p></div></div><div class="oz l"><div class="ph l pb pc pd oz pe ks oq"/></div></div></a></div><div class="on oo gp gr op oq"><a href="https://redux.js.org/" rel="noopener  ugc nofollow" target="_blank"><div class="or ab fo"><div class="os ab ot cl cj ou"><h2 class="bd iu gy z fp ov fr fs ow fu fw is bi translated">为JS应用程序还原一个可预测的状态容器</h2><div class="ox l"><h3 class="bd b gy z fp ov fr fs ow fu fw dk translated">JS应用程序的可预测状态容器</h3></div><div class="oy l"><p class="bd b dl z fp ov fr fs ow fu fw dk translated">JS Appsredux.js.org的可预测状态容器</p></div></div><div class="oz l"><div class="pi l pb pc pd oz pe ks oq"/></div></div></a></div><div class="on oo gp gr op oq"><a href="https://github.com/facebook/create-react-app" rel="noopener  ugc nofollow" target="_blank"><div class="or ab fo"><div class="os ab ot cl cj ou"><h2 class="bd iu gy z fp ov fr fs ow fu fw is bi translated">Facebook/创建-反应-应用程序</h2><div class="ox l"><h3 class="bd b gy z fp ov fr fs ow fu fw dk translated">通过运行一个命令设置一个现代化的web应用程序。通过创建……为facebook/create-react-app开发做出贡献</h3></div><div class="oy l"><p class="bd b dl z fp ov fr fs ow fu fw dk translated">github.com</p></div></div><div class="oz l"><div class="pj l pb pc pd oz pe ks oq"/></div></div></a></div><div class="on oo gp gr op oq"><a href="https://github.com/axios/axios" rel="noopener  ugc nofollow" target="_blank"><div class="or ab fo"><div class="os ab ot cl cj ou"><h2 class="bd iu gy z fp ov fr fs ow fu fw is bi translated">axios/axios</h2><div class="ox l"><h3 class="bd b gy z fp ov fr fs ow fu fw dk translated">用于浏览器和node.js - axios/axios的基于Promise的HTTP客户端</h3></div><div class="oy l"><p class="bd b dl z fp ov fr fs ow fu fw dk translated">github.com</p></div></div><div class="oz l"><div class="pk l pb pc pd oz pe ks oq"/></div></div></a></div><div class="on oo gp gr op oq"><a href="https://en.wikipedia.org/wiki/Single-page_application" rel="noopener  ugc nofollow" target="_blank"><div class="or ab fo"><div class="os ab ot cl cj ou"><h2 class="bd iu gy z fp ov fr fs ow fu fw is bi translated">单页应用程序-维基百科</h2><div class="ox l"><h3 class="bd b gy z fp ov fr fs ow fu fw dk translated">单页应用程序(SPA)是一个web应用程序或网站，它通过动态重写…</h3></div><div class="oy l"><p class="bd b dl z fp ov fr fs ow fu fw dk translated">en.wikipedia.org</p></div></div></div></a></div><div class="on oo gp gr op oq"><a href="https://reactjs.org/docs/code-splitting.html" rel="noopener  ugc nofollow" target="_blank"><div class="or ab fo"><div class="os ab ot cl cj ou"><h2 class="bd iu gy z fp ov fr fs ow fu fw is bi translated">代码分解-反应</h2><div class="ox l"><h3 class="bd b gy z fp ov fr fs ow fu fw dk translated">用于构建用户界面的JavaScript库</h3></div><div class="oy l"><p class="bd b dl z fp ov fr fs ow fu fw dk translated">reactjs.org</p></div></div><div class="oz l"><div class="pl l pb pc pd oz pe ks oq"/></div></div></a></div><div class="on oo gp gr op oq"><a href="https://reactjs.org/docs/context.html" rel="noopener  ugc nofollow" target="_blank"><div class="or ab fo"><div class="os ab ot cl cj ou"><h2 class="bd iu gy z fp ov fr fs ow fu fw is bi translated">上下文反应</h2><div class="ox l"><h3 class="bd b gy z fp ov fr fs ow fu fw dk translated">上下文提供了一种通过组件树传递数据的方法，而不必每次都手动传递属性</h3></div><div class="oy l"><p class="bd b dl z fp ov fr fs ow fu fw dk translated">reactjs.org</p></div></div><div class="oz l"><div class="pm l pb pc pd oz pe ks oq"/></div></div></a></div><div class="on oo gp gr op oq"><a href="https://reactjs.org/docs/hooks-intro.html" rel="noopener  ugc nofollow" target="_blank"><div class="or ab fo"><div class="os ab ot cl cj ou"><h2 class="bd iu gy z fp ov fr fs ow fu fw is bi translated">介绍钩子-反应</h2><div class="ox l"><h3 class="bd b gy z fp ov fr fs ow fu fw dk translated">钩子是React 16.8中的新增功能。它们允许您使用状态和其他React特性，而无需编写类。这个…</h3></div><div class="oy l"><p class="bd b dl z fp ov fr fs ow fu fw dk translated">reactjs.org</p></div></div><div class="oz l"><div class="pn l pb pc pd oz pe ks oq"/></div></div></a></div><div class="on oo gp gr op oq"><a href="https://reactjs.org/docs/hooks-state.html" rel="noopener  ugc nofollow" target="_blank"><div class="or ab fo"><div class="os ab ot cl cj ou"><h2 class="bd iu gy z fp ov fr fs ow fu fw is bi translated">使用状态钩子-反应</h2><div class="ox l"><h3 class="bd b gy z fp ov fr fs ow fu fw dk translated">钩子是React 16.8中的新增功能。它们允许您使用状态和其他React特性，而无需编写类。的…</h3></div><div class="oy l"><p class="bd b dl z fp ov fr fs ow fu fw dk translated">reactjs.org</p></div></div><div class="oz l"><div class="po l pb pc pd oz pe ks oq"/></div></div></a></div><div class="on oo gp gr op oq"><a href="https://developer.mozilla.org/en-US/docs/Web/API/Window/localStorage" rel="noopener  ugc nofollow" target="_blank"><div class="or ab fo"><div class="os ab ot cl cj ou"><h2 class="bd iu gy z fp ov fr fs ow fu fw is bi translated">窗口.本地存储</h2><div class="ox l"><h3 class="bd b gy z fp ov fr fs ow fu fw dk translated">只读localStorage属性允许您访问文档来源的存储对象；存储的数据是…</h3></div><div class="oy l"><p class="bd b dl z fp ov fr fs ow fu fw dk translated">developer.mozilla.org</p></div></div><div class="oz l"><div class="pp l pb pc pd oz pe ks oq"/></div></div></a></div><div class="on oo gp gr op oq"><a href="https://developer.mozilla.org/en-US/docs/Web/Security" rel="noopener  ugc nofollow" target="_blank"><div class="or ab fo"><div class="os ab ot cl cj ou"><h2 class="bd iu gy z fp ov fr fs ow fu fw is bi translated">网络安全</h2><div class="ox l"><h3 class="bd b gy z fp ov fr fs ow fu fw dk translated">这里列出的面向web安全的文章提供的信息可以帮助您保护您的站点及其代码免受…</h3></div><div class="oy l"><p class="bd b dl z fp ov fr fs ow fu fw dk translated">developer.mozilla.org</p></div></div><div class="oz l"><div class="pq l pb pc pd oz pe ks oq"/></div></div></a></div><div class="on oo gp gr op oq"><a href="https://github.com/DennyScott/react-router-auth" rel="noopener  ugc nofollow" target="_blank"><div class="or ab fo"><div class="os ab ot cl cj ou"><h2 class="bd iu gy z fp ov fr fs ow fu fw is bi translated">丹尼斯科特/反应路由器授权</h2><div class="ox l"><h3 class="bd b gy z fp ov fr fs ow fu fw dk translated">在GitHub上创建一个帐户，为DennyScott/react-router-auth开发做贡献。</h3></div><div class="oy l"><p class="bd b dl z fp ov fr fs ow fu fw dk translated">github.com</p></div></div><div class="oz l"><div class="pr l pb pc pd oz pe ks oq"/></div></div></a></div><div class="on oo gp gr op oq"><a href="https://jwt.io/" rel="noopener  ugc nofollow" target="_blank"><div class="or ab fo"><div class="os ab ot cl cj ou"><h2 class="bd iu gy z fp ov fr fs ow fu fw is bi translated">JWT。超正析象管(Image Orthicon)</h2><div class="ox l"><h3 class="bd b gy z fp ov fr fs ow fu fw dk translated">JSON Web Token (JWT)是一种简洁的、URL安全的方式，用于表示要在双方之间传输的声明。的…</h3></div><div class="oy l"><p class="bd b dl z fp ov fr fs ow fu fw dk translated">jwt.io</p></div></div><div class="oz l"><div class="ps l pb pc pd oz pe ks oq"/></div></div></a></div><div class="on oo gp gr op oq"><a href="https://reactjs.org/docs/error-boundaries.html" rel="noopener  ugc nofollow" target="_blank"><div class="or ab fo"><div class="os ab ot cl cj ou"><h2 class="bd iu gy z fp ov fr fs ow fu fw is bi translated">错误边界-反应</h2><div class="ox l"><h3 class="bd b gy z fp ov fr fs ow fu fw dk translated">过去，组件内部的JavaScript错误会破坏React的内部状态，导致它发出神秘的…</h3></div><div class="oy l"><p class="bd b dl z fp ov fr fs ow fu fw dk translated">reactjs.org</p></div></div><div class="oz l"><div class="pt l pb pc pd oz pe ks oq"/></div></div></a></div></div></div>    
</body>
</html>