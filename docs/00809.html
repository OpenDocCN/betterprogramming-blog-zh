<html>
<head>
<title>WebAssembly — Is It As Scary As It Sounds?</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">web assembly——有听起来那么可怕吗？</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/webassembly-is-it-as-scary-as-it-sounds-b0c38fb2d9c8?source=collection_archive---------3-----------------------#2019-07-16">https://betterprogramming.pub/webassembly-is-it-as-scary-as-it-sounds-b0c38fb2d9c8?source=collection_archive---------3-----------------------#2019-07-16</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="de62" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">学习WebAssembly，同时为浏览器构建基于Wasm的QR解码器</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/23c71066aa3ec9a85ecd0031f81620bf.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*KoFqaWev5QQ_CjhzAojv4g.png"/></div></div></figure><p id="de6d" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated"><a class="ae lq" href="https://webassembly.org/" rel="noopener ugc nofollow" target="_blank">web assembly</a><strong class="kw iu"/>(Wasm)<strong class="kw iu"/>已经在<strong class="kw iu"> </strong>左右两年了。还是比较新的技术。</p><p id="5ce4" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">出于某种原因，它总让我感到害怕。也许是因为它在<strong class="kw iu"> <em class="lr"> </em> </strong>中有<em class="lr">装配</em> <strong class="kw iu"> <em class="lr"> </em> </strong>而得名？或者可能是必须用一种与JavaScript非常不同的语言来编码？</p><p id="86a7" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">不管是什么，我是一个好奇的人，在看了<a class="ls lt ep" href="https://medium.com/u/2d30b2439b4b?source=post_page-----b0c38fb2d9c8--------------------------------" rel="noopener" target="_blank">苏尔马</a>的<a class="ae lq" href="https://www.youtube.com/watch?v=njt-Qzw0mVY" rel="noopener ugc nofollow" target="_blank">演讲</a>后，我说服自己尝试学习WebAssembly。</p></div><div class="ab cl lu lv hx lw" role="separator"><span class="lx bw bk ly lz ma"/><span class="lx bw bk ly lz ma"/><span class="lx bw bk ly lz"/></div><div class="im in io ip iq"><h1 id="69cf" class="mb mc it bd md me mf mg mh mi mj mk ml jz mm ka mn kc mo kd mp kf mq kg mr ms bi translated"><strong class="ak"> <em class="mt">什么是WebAssembly </em> </strong></h1><blockquote class="mu"><p id="77a8" class="mv mw it bd mx my mz na nb nc nd lp dk translated">“[WebAssembly]提供了一种在网络上以接近本地速度运行用多种语言编写的代码的方式，客户端应用程序在网络上运行，这在以前是不可能的。”— <a class="ae lq" href="https://developer.mozilla.org/en-US/docs/WebAssembly" rel="noopener ugc nofollow" target="_blank"> MDN </a></p></blockquote><p id="26a7" class="pw-post-body-paragraph ku kv it kw b kx ne ju kz la nf jx lc ld ng lf lg lh nh lj lk ll ni ln lo lp im bi translated">基本上，WebAssembly允许我们编译代码，用C、<a class="ae lq" href="https://www.rust-lang.org/" rel="noopener ugc nofollow" target="_blank"> Rust </a>等语言编写。(<a class="ae lq" href="https://github.com/appcypher/awesome-wasm-langs" rel="noopener ugc nofollow" target="_blank">完整的语言列表可以在这里</a>找到)，保存在一个<code class="fe nj nk nl nm b">.wasm</code> <em class="lr"> </em>文件中，然后在浏览器中运行。</p><p id="2f8e" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">就为网络平台开辟各种可能性而言，这是不可思议的。如果你之前尝试过<a class="ae lq" href="https://unity.com/" rel="noopener ugc nofollow" target="_blank"> Unity </a>构建游戏，你可能会对这个画面很熟悉。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nn"><img src="../Images/d02eb91f23f92623038446ed09d1a51f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*3zDCsIwsZU6Tm7VmZT0oDg.png"/></div></div><p class="no np gj gh gi nq nr bd b be z dk translated">团结游戏:坦克！</p></figure><p id="71a6" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">这是一个示例3D游戏，用Unity创建，在WebAssembly的帮助下移植到浏览器。疯狂的是，玩起来一点都不呆滞。你可以自己试试<a class="ae lq" href="https://wasm.bootcss.com/demo/Tanks/" rel="noopener ugc nofollow" target="_blank">这里</a>。</p><p id="6a19" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">另一个是<a class="ae lq" href="https://www.autodesk.com.au/products/autocad/overview" rel="noopener ugc nofollow" target="_blank"> AutoCAD </a>。AutoCAD也被移植到网络上。你可以观看<a class="ae lq" href="https://youtu.be/BnYq7JapeDA?t=1612" rel="noopener ugc nofollow" target="_blank">这个视频</a>来了解更多。</p><p id="c9a4" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">WebAssembly不是魔术。它不会自动获取你现有的用C++编写的程序，编译它，并在浏览器中运行它。WebAssembly允许我们重用其他语言的代码，并以接近本地的速度在浏览器上运行它！</p></div><div class="ab cl lu lv hx lw" role="separator"><span class="lx bw bk ly lz ma"/><span class="lx bw bk ly lz ma"/><span class="lx bw bk ly lz"/></div><div class="im in io ip iq"><h1 id="74ac" class="mb mc it bd md me mf mg mh mi mj mk ml jz mm ka mn kc mo kd mp kf mq kg mr ms bi translated">我应该学习WebAssembly吗</h1><p id="375c" class="pw-post-body-paragraph ku kv it kw b kx ns ju kz la nt jx lc ld nu lf lg lh nv lj lk ll nw ln lo lp im bi translated">如果你的web应用程序不包含繁重的计算，只做一些简单的任务，比如渲染UI，请求API等等。，那么你很可能不需要WebAssembly。</p><p id="5e7b" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">作为web开发人员，WebAssembly允许我们实现以前只用JavaScript无法(或至少不可行)实现的事情。它是JavaScript的补充，而不是替代。</p><p id="55f5" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">话虽如此，学习它并尝试它总是有益的。</p></div><div class="ab cl lu lv hx lw" role="separator"><span class="lx bw bk ly lz ma"/><span class="lx bw bk ly lz ma"/><span class="lx bw bk ly lz"/></div><div class="im in io ip iq"><h1 id="7eeb" class="mb mc it bd md me mf mg mh mi mj mk ml jz mm ka mn kc mo kd mp kf mq kg mr ms bi translated">Wasm解码二维码</h1><p id="1ffa" class="pw-post-body-paragraph ku kv it kw b kx ns ju kz la nt jx lc ld nu lf lg lh nv lj lk ll nw ln lo lp im bi translated">在本文中，我们将使用Wasm从图像输入中解码QR码。</p><p id="4cef" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">我们将使用Rust和<code class="fe nj nk nl nm b"><a class="ae lq" href="https://rustwasm.github.io/docs/wasm-bindgen/" rel="noopener ugc nofollow" target="_blank">wasm-bindgen</a></code>。</p><p id="8187" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">最终的结果可以在这个回购中看到:</p><div class="nx ny gp gr nz oa"><a href="https://github.com/jackyef/rqrr-wasm/tree/master/rust-src" rel="noopener  ugc nofollow" target="_blank"><div class="ob ab fo"><div class="oc ab od cl cj oe"><h2 class="bd iu gy z fp of fr fs og fu fw is bi translated">jackyef/rqrr-wasm</h2><div class="oh l"><h3 class="bd b gy z fp of fr fs og fu fw dk translated">rust QR解码器库“rqrr ”;编译到WebAssembly。演示:https://jackyef.github.io/rqrr-wasm…</h3></div><div class="oi l"><p class="bd b dl z fp of fr fs og fu fw dk translated">github.com</p></div></div><div class="oj l"><div class="ok l ol om on oj oo ks oa"/></div></div></a></div><p id="0d76" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">不过注意，我绝不是WebAssembly或者Rust方面的专家。</p><p id="0da0" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">我在软件工程方面的经验主要包括web开发和编写JavaScript。这基本上意味着我在这篇文章中所做的可能不是好的实践，其中一些可能在技术上不准确。</p><p id="b176" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">然而，这是一个陌生人真正的学习之旅。希望你会发现这在某种程度上是有用的。</p></div><div class="ab cl lu lv hx lw" role="separator"><span class="lx bw bk ly lz ma"/><span class="lx bw bk ly lz ma"/><span class="lx bw bk ly lz"/></div><div class="im in io ip iq"><h1 id="74db" class="mb mc it bd md me mf mg mh mi mj mk ml jz mm ka mn kc mo kd mp kf mq kg mr ms bi translated"><strong class="ak">设置</strong></h1><p id="6e1e" class="pw-post-body-paragraph ku kv it kw b kx ns ju kz la nt jx lc ld nu lf lg lh nv lj lk ll nw ln lo lp im bi translated">首先，我们需要安装Rust。按照本指南来做。</p><p id="abdd" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">一旦安装完毕，我们将把<code class="fe nj nk nl nm b">wasm</code>作为编译目标添加到Rust编译器中。我们通过运行以下命令来实现这一点:</p><pre class="kj kk kl km gt op nm oq or aw os bi"><span id="5d26" class="ot mc it nm b gy ou ov l ow ox">rustup target add wasm32-unknown-unknown</span></pre><p id="5a4a" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">现在，我们应该安装<code class="fe nj nk nl nm b">wasm-bindgen-cli</code>，因为我们以后会用到它。我们将使用<code class="fe nj nk nl nm b">cargo</code>来安装它。应该已经和铁锈一起安装了。</p><p id="5086" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">你就当是npm吧，不过是为了铁锈。</p><p id="0851" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">运行以下命令安装<code class="fe nj nk nl nm b">wasm-bindgen-cli</code>:</p><pre class="kj kk kl km gt op nm oq or aw os bi"><span id="5608" class="ot mc it nm b gy ou ov l ow ox">cargo install wasm-bindgen-cli</span></pre><p id="2956" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">这就是我们目前所需要的。</p><p id="3de0" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">让我给你概述一下我们将要做的事情。</p><ol class=""><li id="6b87" class="oy oz it kw b kx ky la lb ld pa lh pb ll pc lp pd pe pf pg bi translated">用Rust写一个可以解码二维码的函数。</li><li id="e0dd" class="oy oz it kw b kx ph la pi ld pj lh pk ll pl lp pd pe pf pg bi translated">将Rust代码编译成Wasm。</li><li id="4f40" class="oy oz it kw b kx ph la pi ld pj lh pk ll pl lp pd pe pf pg bi translated">尝试在简单的HTML + JS网页中使用Wasm文件。</li></ol></div><div class="ab cl lu lv hx lw" role="separator"><span class="lx bw bk ly lz ma"/><span class="lx bw bk ly lz ma"/><span class="lx bw bk ly lz"/></div><div class="im in io ip iq"><h1 id="6219" class="mb mc it bd md me mf mg mh mi mj mk ml jz mm ka mn kc mo kd mp kf mq kg mr ms bi translated">用Rust写代码</h1><p id="c8c1" class="pw-post-body-paragraph ku kv it kw b kx ns ju kz la nt jx lc ld nu lf lg lh nv lj lk ll nw ln lo lp im bi translated">如果您熟悉<a class="ae lq" href="https://nodejs.org/" rel="noopener ugc nofollow" target="_blank">节点</a>，您通常会通过运行<code class="fe nj nk nl nm b">npm init</code>来启动一个项目。</p><p id="f550" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">在Rust中，我们用<code class="fe nj nk nl nm b">cargo new hello_world</code>代替。</p><p id="e17b" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">这将创建一个名为<code class="fe nj nk nl nm b">hello_world</code>的目录，其中包含一些为我们预先准备好的文件。在Rust中，这个项目被称为包。我们也可以导入第三方<em class="lr">板条箱</em>，就像在Node中，我们可以导入第三方模块一样。</p><p id="dc06" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">现在，我们来看看<code class="fe nj nk nl nm b">Cargo.toml</code>文件。你的可能现在看起来有点空，但没关系。只需修改它以遵循以下代码片段:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="pm pn l"/></div><p class="no np gj gh gi nq nr bd b be z dk translated">填充的Cargo.toml文件</p></figure><p id="9bca" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">您可能会看到这个文件包含了这个包及其依赖项的信息。这个文件很像一个<code class="fe nj nk nl nm b">package.json</code>文件，它是包裹的<em class="lr">清单</em>。</p><p id="83b7" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">这里重要的是，在<code class="fe nj nk nl nm b">[lib]</code>部分，我们将<code class="fe nj nk nl nm b">crate-type</code>定义为<code class="fe nj nk nl nm b">["cdylib"]</code>。当我们以Wasm为目标时，这是必需的。</p><p id="6cee" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">此外，我们不打算自己编写QR解码器，所以我们将使用第三方板条箱。我们将使用<a class="ae lq" href="https://docs.rs/rqrr/0.2.0/rqrr/" rel="noopener ugc nofollow" target="_blank"> rqrr </a>作为QR解码器。</p><p id="d0d4" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">为了创建一个将被提供给解码器的图像，我们将使用<a class="ae lq" href="https://docs.rs/image/0.21.2/image/" rel="noopener ugc nofollow" target="_blank"> image </a> crate，并且我们还将使用<a class="ae lq" href="https://docs.rs/wasm-bindgen/0.2.48/wasm_bindgen/" rel="noopener ugc nofollow" target="_blank"> wasm-bindgen </a>来帮助提供Rust-to-JavaScript <em class="lr"> </em>绑定。</p><p id="5daa" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">现在，将<code class="fe nj nk nl nm b">src/main.rs</code>重命名为<code class="fe nj nk nl nm b">src/lib.rs</code>，并在其中写入以下代码。<code class="fe nj nk nl nm b">lib.rs</code>是我们后来编译到Wasm时，我们的包的入口点。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="pm pn l"/></div></figure><p id="bd64" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">我对铁锈不是很熟悉，但我会尽力解释。</p><p id="83c2" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated"><code class="fe nj nk nl nm b">extern crate</code>和<code class="fe nj nk nl nm b">use</code>语句用于导入我们将使用的板条箱，在本例中，它们是<code class="fe nj nk nl nm b">wasm_bindgen</code>、<code class="fe nj nk nl nm b">rqrr</code>和<code class="fe nj nk nl nm b">image</code>。</p><p id="f93b" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">然后，我们使用关键字<code class="fe nj nk nl nm b">pub fn</code>创建一个名为<code class="fe nj nk nl nm b">decode_qr</code>的公共函数。该函数接受一个名为bytes ( <code class="fe nj nk nl nm b">bytes:&amp;[u8]</code>)的无符号8位整数数组，表示图像数据。</p><p id="ea4f" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">它将解码图像并返回一个<code class="fe nj nk nl nm b">String</code>。<code class="fe nj nk nl nm b">#[wasm_bindgen]</code>属性告诉<code class="fe nj nk nl nm b">wasm_bindgen</code>当我们使用这个函数时，我们希望它被暴露给我们的JavaScript。这个信息被<code class="fe nj nk nl nm b">wasm-bindgen</code>用来为我们创建合适的绑定。</p><pre class="kj kk kl km gt op nm oq or aw os bi"><span id="ff92" class="ot mc it nm b gy ou ov l ow ox">#[wasm_bindgen]<br/>pub fn decode_qr(bytes: &amp;[u8]) -&gt; String {</span></pre><p id="d36d" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">然后我们使用由<code class="fe nj nk nl nm b">image</code> crate提供的<code class="fe nj nk nl nm b">load_from_memory</code>方法从这个数组中创建一个图像。</p><p id="52db" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">因为这个操作可能会失败，所以我们使用<code class="fe nj nk nl nm b">match</code>关键字，并在方法返回<code class="fe nj nk nl nm b">Ok</code>和<code class="fe nj nk nl nm b">Err</code>结果时处理案例。</p><p id="c68a" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">出错时，我们将把字符串<code class="fe nj nk nl nm b">“[Error] Failed when trying to load image”</code>返回给JavaScript端。</p><pre class="kj kk kl km gt op nm oq or aw os bi"><span id="f1ff" class="ot mc it nm b gy ou ov l ow ox">let img = match image::load_from_memory(&amp;bytes) {<br/>        Ok(v) =&gt; v,<br/>        Err(_e) =&gt; return format!("{}", "[Error] Failed when trying to load image"),<br/>    };</span></pre><p id="cbce" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">然后，我们将该图像转换为灰度图像，然后将其提供给rqrr。</p><pre class="kj kk kl km gt op nm oq or aw os bi"><span id="298f" class="ot mc it nm b gy ou ov l ow ox">let img = img.to_luma();</span></pre><p id="057e" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">您可能会想:“所有这些方法名是从哪里来的？”</p><p id="c290" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">这些方法以及其他信息可以在板条箱文档页面中找到。</p><p id="e70c" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">我已经链接到上面的文档页面，但我会再次提供，以防您错过。<a class="ae lq" href="https://docs.rs/rqrr/0.2.0/rqrr/" rel="noopener ugc nofollow" target="_blank"> rqrr文件</a>、<a class="ae lq" href="https://docs.rs/image/0.21.2/image/" rel="noopener ugc nofollow" target="_blank">图像文件</a>、<a class="ae lq" href="https://docs.rs/crate/wasm-bindgen/0.2.8" rel="noopener ugc nofollow" target="_blank"> wasm_bindgen文件</a>。</p><p id="57cb" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">现在，我们准备图像，然后将它和案例处理一起提供给rqrr。</p><p id="21af" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">最后，我们将<code class="fe nj nk nl nm b">String</code>返回到JavaScript端。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="pm pn l"/></div></figure></div><div class="ab cl lu lv hx lw" role="separator"><span class="lx bw bk ly lz ma"/><span class="lx bw bk ly lz ma"/><span class="lx bw bk ly lz"/></div><div class="im in io ip iq"><h1 id="8630" class="mb mc it bd md me mf mg mh mi mj mk ml jz mm ka mn kc mo kd mp kf mq kg mr ms bi translated">编译到Wasm</h1><p id="713e" class="pw-post-body-paragraph ku kv it kw b kx ns ju kz la nt jx lc ld nu lf lg lh nv lj lk ll nw ln lo lp im bi translated">现在我们有了Rust代码，我们可以使用以下命令轻松地将其编译成Wasm:</p><pre class="kj kk kl km gt op nm oq or aw os bi"><span id="225f" class="ot mc it nm b gy ou ov l ow ox">cargo build --target wasm32-unknown-unknown --release</span></pre><p id="7dfa" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">这将在<code class="fe nj nk nl nm b">target/wasm32-unknown-unknown/release</code>中生成一个Wasm文件。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi po"><img src="../Images/4dedb1ea40008a9d86c77b4c8b0a1ca8.png" data-original-src="https://miro.medium.com/v2/resize:fit:970/format:webp/1*9k1yhri_k4azV91GlZKVmA.png"/></div><p class="no np gj gh gi nq nr bd b be z dk translated">我们创造了第一个。wasm文件！🎉</p></figure><p id="b76a" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">注意，文件名是<code class="fe nj nk nl nm b">qr_rust.wasm</code>。这是因为我的包名是<code class="fe nj nk nl nm b">qr-rust</code>，所以输出文件也相应命名。</p><p id="72a3" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">然而，我们还没有完成。由于我们正在使用<code class="fe nj nk nl nm b">wasm-bindgen</code>，我们需要对这个Wasm文件运行<code class="fe nj nk nl nm b">wasm-bindgen</code>来生成另一个Wasm文件。这将包含一个JavaScript文件，其中包含帮助我们轻松使用Wasm文件所需的绑定。</p><p id="efc1" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">为此，请运行以下命令:</p><pre class="kj kk kl km gt op nm oq or aw os bi"><span id="f6aa" class="ot mc it nm b gy ou ov l ow ox">wasm-bindgen target/wasm32-unknown-unknown/release/qr_rust.wasm --out-dir ./dist --no-modules --no-typescript</span></pre><p id="89a0" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">您现在应该在<code class="fe nj nk nl nm b">dist</code>目录中看到两个新文件。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi pp"><img src="../Images/62046e22b750726089ee8bdb13b1f780.png" data-original-src="https://miro.medium.com/v2/resize:fit:448/format:webp/1*iznfL6STxbAPlVb8FE6K_A.png"/></div><p class="no np gj gh gi nq nr bd b be z dk translated">使用wasm-bindgen cli创建绑定后的输出文件</p></figure><p id="1edd" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">如果你试着观察。js文件，您将看到由<code class="fe nj nk nl nm b">wasm-bindgen</code>生成的一堆代码，这样我们就可以轻松地使用Wasm模块。</p><p id="671d" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">它为我们做了两件值得注意的事情:</p><ol class=""><li id="8740" class="oy oz it kw b kx ky la lb ld pa lh pb ll pc lp pd pe pf pg bi translated">它帮助我们在<code class="fe nj nk nl nm b">init()</code>函数中实例化Wasm模块:</li></ol><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="pm pn l"/></div><p class="no np gj gh gi nq nr bd b be z dk translated">初始化wasm模块</p></figure><p id="c3ac" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">2.它提供了在JavaScript和Wasm之间传递数据所必需的东西:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="pm pn l"/></div></figure><p id="730e" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">如果我们不使用<code class="fe nj nk nl nm b">wasm-bindgen</code>，我们将不得不自己编写这些东西。</p></div><div class="ab cl lu lv hx lw" role="separator"><span class="lx bw bk ly lz ma"/><span class="lx bw bk ly lz ma"/><span class="lx bw bk ly lz"/></div><div class="im in io ip iq"><h1 id="ab9e" class="mb mc it bd md me mf mg mh mi mj mk ml jz mm ka mn kc mo kd mp kf mq kg mr ms bi translated">尝试一下</h1><p id="dde2" class="pw-post-body-paragraph ku kv it kw b kx ns ju kz la nt jx lc ld nu lf lg lh nv lj lk ll nw ln lo lp im bi translated">首先，让我们创建一个简单的HTML文件，其中包含由<code class="fe nj nk nl nm b">wasm-bindgen</code>生成的JavaScript绑定。</p><p id="8dfc" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">在我们可以对Wasm模块做任何事情之前，必须执行绑定。</p><p id="5eb9" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">让我们在<code class="fe nj nk nl nm b">./dist</code>目录中创建这个<code class="fe nj nk nl nm b">index.html</code>文件。</p><pre class="kj kk kl km gt op nm oq or aw os bi"><span id="50f8" class="ot mc it nm b gy ou ov l ow ox">&lt;html&gt;<br/>  &lt;!-- the javascript bindings --&gt;<br/>  &lt;script src="qr_rust.js"&gt;&lt;/script&gt;<br/>&lt;/html&gt;</span></pre><p id="3b7c" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">绑定在全局范围内创建了一个<code class="fe nj nk nl nm b">wasm_bindgen</code>变量，我们可以用它来加载Wasm模块。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="pm pn l"/></div></figure><p id="16ab" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">让我们尝试在本地提供这个HTML文件，看看会发生什么。</p><p id="2dc9" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">最简单的方法是使用<code class="fe nj nk nl nm b">http-server</code> npm模块并服务于我们的<code class="fe nj nk nl nm b">./dist</code>目录。</p><pre class="kj kk kl km gt op nm oq or aw os bi"><span id="7feb" class="ot mc it nm b gy ou ov l ow ox">npm install http-server -g<br/>http-server ./dist -g</span></pre><p id="bce8" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">打开网址。如果一切正常，您应该会在浏览器控制台中看到<code class="fe nj nk nl nm b">It is loaded!</code>。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi pq"><img src="../Images/f016989fc1d80465e0ec874da2977f50.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Yz0ietXZ1zROg0mP7DwLpw.png"/></div></div><p class="no np gj gh gi nq nr bd b be z dk translated">我们在浏览器上加载了Wasm模块！</p></figure><p id="6025" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">我们在Rust中编写的函数可以从全局<code class="fe nj nk nl nm b">wasm_bindgen</code>变量中访问。</p><pre class="kj kk kl km gt op nm oq or aw os bi"><span id="547b" class="ot mc it nm b gy ou ov l ow ox">const { decode_qr } = wasm_bindgen;</span></pre><p id="972e" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">此时，我们可以将一个无符号8位整数数组传递给函数，并记录输出。</p><p id="2de7" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">在这里，我将<code class="fe nj nk nl nm b">new Uint8Array([1,2,3,4,5]);</code>传递给函数。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="pm pn l"/></div></figure><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi pr"><img src="../Images/ab5772c769459b82670a871adc2698a0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1038/format:webp/1*TJugIUHLU7Ck35FVX593bg.png"/></div><p class="no np gj gh gi nq nr bd b be z dk translated">失败了！</p></figure><p id="c6f4" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">显然，它无法加载图像。这是意料之中的，因为我们只是传递一个不代表图像数据的随机数组。</p><p id="b33a" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">让我们创建一个<code class="fe nj nk nl nm b">&lt;video /&gt;</code>元素来获取图像数据。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="pm pn l"/></div></figure><p id="6409" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">如果您刷新浏览器，您的浏览器现在应该会请求使用相机的权限。允许的话，你应该可以在浏览器中看到你的摄像头。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ps"><img src="../Images/471ef5828ca282a837cfa5d8a7a77b1a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*FSFAhsvkFwLo1QSNzPUafA.png"/></div></div><p class="no np gj gh gi nq nr bd b be z dk translated">我，在网络摄像头前拿着一个二维码图片</p></figure><p id="2302" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">接下来，我们希望能够获取视频的当前帧，以无符号8位整数数组的形式获取图像数据，并将其发送给<code class="fe nj nk nl nm b">decode_qr()</code>函数。</p><p id="7495" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">我们将在<code class="fe nj nk nl nm b">canvas</code>和<code class="fe nj nk nl nm b">FileReader</code>的帮助下完成这项工作。这里有一个<code class="fe nj nk nl nm b">captureImage</code>函数可以做到这一点。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="pm pn l"/></div></figure><p id="f4f4" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">现在，我们只需要定期调用这个函数。我们可以用<code class="fe nj nk nl nm b">setInterval</code>简单地做到这一点。我们将在视频流创建后开始间隔。</p><pre class="kj kk kl km gt op nm oq or aw os bi"><span id="bceb" class="ot mc it nm b gy ou ov l ow ox">navigator.mediaDevices.getUserMedia({ video: true })<br/>  .then(stream =&gt; {<br/>    video.srcObject = stream;</span><span id="e70d" class="ot mc it nm b gy pt ov l ow ox">    setInterval(captureImage, 300);<br/>});</span></pre><p id="f1f8" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">因此，我们最终的HTML文件应该是这样的:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="pm pn l"/></div></figure><p id="c2b6" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">刷新您的浏览器，是时候尝试一下了！</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi pu"><img src="../Images/fe4b0e50982c88eb00a85f5b4500be9a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*s7bcO3XFUDd35gApqD9Kig.png"/></div></div><p class="no np gj gh gi nq nr bd b be z dk translated">有用！二维码上写着“http://en.m.wikipedia.org”</p></figure><p id="4602" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">有时，您可能会看到一条错误消息:“无法访问的代码”。</p><p id="decf" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">我还没弄明白为什么会这样。如果你知道原因，请告诉我！</p></div><div class="ab cl lu lv hx lw" role="separator"><span class="lx bw bk ly lz ma"/><span class="lx bw bk ly lz ma"/><span class="lx bw bk ly lz"/></div><div class="im in io ip iq"><h1 id="d4bb" class="mb mc it bd md me mf mg mh mi mj mk ml jz mm ka mn kc mo kd mp kf mq kg mr ms bi translated">接下来你可以尝试什么</h1><p id="1c75" class="pw-post-body-paragraph ku kv it kw b kx ns ju kz la nt jx lc ld nu lf lg lh nv lj lk ll nw ln lo lp im bi translated">我们拿了一个功能正常的二维码解码器，用Rust写的，编译成WebAssembly，借助<code class="fe nj nk nl nm b">wasm-bindgen</code>在浏览器中使用。</p><p id="2683" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">然而，如果你在DevTools中查看网络请求，你会发现这个Wasm文件非常大！</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi pv"><img src="../Images/5368831bccd2c0d3103fc860ca30f373.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*_W0QWawQhnEf0526rJRMiw.png"/></div></div><p class="no np gj gh gi nq nr bd b be z dk translated">QR解码器736kb！？</p></figure><p id="4b78" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">请注意，我们没有进行任何压缩或优化。</p><p id="8cf7" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">你可以试试查<code class="fe nj nk nl nm b">wasm-opt</code>优化尺寸。<a class="ae lq" href="https://rustwasm.github.io/docs/wasm-bindgen/examples/add.html" rel="noopener ugc nofollow" target="_blank">这本指南</a>会帮你解决这个问题。</p><p id="64e1" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">然后，你可以用任何你想要的压缩算法把它压缩下来；常见的有<code class="fe nj nk nl nm b">gzip</code>。看看Wasm文件有多小。我目前在264 KB的gzipped。</p><p id="555a" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">接下来，您可以尝试将您的创作发布为npm模块，以便其他人可以轻松使用它。我自己也做过这个。</p><p id="760a" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">如果你想看看我的实现，你可以看看我下面的库。它包含了大部分与本文相同的代码。</p><div class="nx ny gp gr nz oa"><a href="https://github.com/jackyef/rqrr-wasm" rel="noopener  ugc nofollow" target="_blank"><div class="ob ab fo"><div class="oc ab od cl cj oe"><h2 class="bd iu gy z fp of fr fs og fu fw is bi translated">jackyef/rqrr-wasm</h2><div class="oh l"><h3 class="bd b gy z fp of fr fs og fu fw dk translated">rust QR解码器库“rqrr ”;编译到WebAssembly。演示:https://jackyef.github.io/rqrr-wasm…</h3></div><div class="oi l"><p class="bd b dl z fp of fr fs og fu fw dk translated">github.com</p></div></div><div class="oj l"><div class="pw l ol om on oj oo ks oa"/></div></div></a></div></div><div class="ab cl lu lv hx lw" role="separator"><span class="lx bw bk ly lz ma"/><span class="lx bw bk ly lz ma"/><span class="lx bw bk ly lz"/></div><div class="im in io ip iq"><h1 id="aaaa" class="mb mc it bd md me mf mg mh mi mj mk ml jz mm ka mn kc mo kd mp kf mq kg mr ms bi translated">结论</h1><p id="57f4" class="pw-post-body-paragraph ku kv it kw b kx ns ju kz la nt jx lc ld nu lf lg lh nv lj lk ll nw ln lo lp im bi translated">那么，WebAssembly可怕吗？对我来说，答案是否定的。</p><p id="3915" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">一开始看起来如此恐怖的原因是，这是一项我不熟悉的神秘技术。作为一个主要用JavaScript编码的人，用Rust编码很奇怪。</p><p id="e463" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">在阅读和观看了关于WebAssembly的信息后，我再也不能忽视它，并决定我必须克服对WebAssembly的恐惧。克服恐惧的一个好方法是真正投入进去。</p><p id="084d" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">请注意，您甚至不必创建自己的Wasm！越来越多的Wasm模块，由其他人创建，发布到npm。我们可以在项目中使用这些模块。</p><p id="2223" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">这个练习的目的是让我们更好地了解WebAssembly。实际上，我们可能不需要这样做，但是如果有一天你需要使用它，至少你已经对它的工作原理有了一个大概的了解。</p><p id="63f3" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">WebAssembly为web平台开辟了许多可能性，尤其是对于那些仅靠JavaScript无法完成的繁重任务。</p><p id="5665" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">您的用例可能不需要WebAssembly。比如我们的QR解码器(经过一些优化)是264 KB。还有<a class="ae lq" href="https://github.com/jackyef/rqrr-wasm" rel="noopener ugc nofollow" target="_blank">这个</a> QR扫描仪，用JavaScript写的，只有~12.4 KB的gzipped。</p><p id="c05a" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">根据您的用例，您可能会认为，即使有性能优势，WebAssembly解决方案对于这个目的来说也是大材小用，您可能是对的。</p><p id="a68e" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">关键是工具只是工具，而WebAssembly是我们工具箱的一个很好的补充。</p></div><div class="ab cl lu lv hx lw" role="separator"><span class="lx bw bk ly lz ma"/><span class="lx bw bk ly lz ma"/><span class="lx bw bk ly lz"/></div><div class="im in io ip iq"><h1 id="91ef" class="mb mc it bd md me mf mg mh mi mj mk ml jz mm ka mn kc mo kd mp kf mq kg mr ms bi translated">资源</h1><ul class=""><li id="dc6a" class="oy oz it kw b kx ns la nt ld px lh py ll pz lp qa pe pf pg bi translated">你可以通过观看2019 Google I/O 上的<a class="ae lq" href="https://www.youtube.com/watch?v=njt-Qzw0mVY" rel="noopener ugc nofollow" target="_blank">这个演讲来了解更多关于WebAssembly的知识。</a></li><li id="f0d7" class="oy oz it kw b kx ph la pi ld pj lh pk ll pl lp qa pe pf pg bi translated">你也可以在在线IDE中使用它:<a class="ae lq" href="https://webassembly.studio/" rel="noopener ugc nofollow" target="_blank"> webassembly.studio </a>。</li></ul></div></div>    
</body>
</html>