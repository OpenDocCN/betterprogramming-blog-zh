<html>
<head>
<title>The Definitive Guide to Docker Swarm</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Docker Swarm的权威指南</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/the-definitive-guide-to-docker-swarm-a37f78d39fb3?source=collection_archive---------3-----------------------#2020-02-08">https://betterprogramming.pub/the-definitive-guide-to-docker-swarm-a37f78d39fb3?source=collection_archive---------3-----------------------#2020-02-08</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="4935" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">关于Docker Swarm以及如何使用它来扩展和安全维护您的Docker项目，您需要了解的一切</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/bd99f831f03c4fd456bc710ff9523742.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*96Tc1pMsSDv3Mrf8ttIzvg.jpeg"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">图片由<a class="ae ky" href="https://www.flickr.com/photos/atbaker/3190753344" rel="noopener ugc nofollow" target="_blank"> Flickr上的<a class="ae ky" href="https://www.flickr.com/photos/atbaker/" rel="noopener ugc nofollow" target="_blank">亚当·贝克</a>r</a></p></figure><p id="4c54" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">随着应用程序需要越来越多的计算资源和接近100%的正常运行时间，如果没有某种管理系统，就很难维护和扩展您的软件。这就是Docker Swarm发挥作用的地方。Docker Swarm提供了一种简单的方法来扩展和维护你的容器和服务。</p><p id="4bca" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">本指南将向您展示所有重要的概念和命令以及配置文件的结构。在本文的最后，它还将给出一个真实的例子，说明如何部署一个真实的应用程序。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="f53f" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">为什么要关心Docker Swarm？</h1><p id="134e" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">在我们进入蜂群的技术细节之前，让我们先讨论一下为什么有人会使用它。</p><h2 id="9838" class="mz md it bd me na nb dn mi nc nd dp mm li ne nf mo lm ng nh mq lq ni nj ms nk bi translated">负载平衡</h2><p id="a2cf" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">Swarm有一个内置的负载平衡器，可以让你指定如何在不同的节点之间分配服务和容器。您还可以为外部负载平衡服务公开端口。</p><h2 id="0388" class="mz md it bd me na nb dn mi nc nd dp mm li ne nf mo lm ng nh mq lq ni nj ms nk bi translated">集成到Docker引擎中</h2><p id="61bb" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">Swarm直接集成到Docker CLI中，不需要任何额外的编排软件或其他工具来创建或管理swarm。</p><h2 id="dcbe" class="mz md it bd me na nb dn mi nc nd dp mm li ne nf mo lm ng nh mq lq ni nj ms nk bi translated">缩放比例</h2><p id="d597" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">Swarm允许你定义每个服务要运行的任务数量。这个数字可以用一个命令来改变，这个命令由群管理器处理。</p><p id="1f87" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">Swarm允许您增量应用服务更新，这意味着它一次更新特定数量的副本，并且您的服务将始终保持运行——甚至在更新时。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="aba2" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">什么是蜂群？</h1><p id="5bf5" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">Docker Swarm是一个集群管理和协调工具，可以轻松扩展和管理您现有的Docker服务。</p><p id="742b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">一个<em class="nl">群</em>由多个Docker主机组成，这些主机以所谓的群模式运行，并充当<em class="nl">管理者</em>(管理成员关系)或<em class="nl">工作者</em>(运行服务)。给定的Docker主机可以是管理者、工作者，或者可以执行这两种角色。</p><p id="9285" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在集群中创建服务时，您需要定义服务的最佳状态(副本数量、服务端口、网络和存储资源等)。Docker将通过重新启动/重新调度不可用的任务以及平衡不同节点之间的负载来试图保持这种期望的状态。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="c88d" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">节点</h1><p id="1265" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">节点是参与群的Docker引擎的实例。您可以在单个设备上运行一个或多个节点，但是生产部署通常包括分布在多个物理设备上的Docker节点。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nm"><img src="../Images/d3e8c89fdc00ac67da5d4b740d97ef44.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*N6zIu2BIQQpRgPnO.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated"><a class="ae ky" href="https://docs.docker.com/engine/swarm/how-swarm-mode-works/nodes/" rel="noopener ugc nofollow" target="_blank">码头工人群体节点</a></p></figure><h2 id="22ad" class="mz md it bd me na nb dn mi nc nd dp mm li ne nf mo lm ng nh mq lq ni nj ms nk bi translated">管理器节点</h2><p id="0039" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">管理节点将传入的任务分配和调度到工作节点上，维护集群状态，并执行协调和集群管理功能。管理节点也可以选择为工作节点运行服务。</p><p id="7574" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">集群管理任务包括:</p><ul class=""><li id="3f75" class="nn no it lb b lc ld lf lg li np lm nq lq nr lu ns nt nu nv bi translated">维护集群状态</li><li id="f8b8" class="nn no it lb b lc nw lf nx li ny lm nz lq oa lu ns nt nu nv bi translated">调度服务</li><li id="b0a8" class="nn no it lb b lc nw lf nx li ny lm nz lq oa lu ns nt nu nv bi translated">为HTTP API端点提供群体模式服务</li></ul><p id="32c8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">由于以下原因，您的集群中应该始终有多个管理器节点:</p><ul class=""><li id="441f" class="nn no it lb b lc ld lf lg li np lm nq lq nr lu ns nt nu nv bi translated">保持高可用性</li><li id="324f" class="nn no it lb b lc nw lf nx li ny lm nz lq oa lu ns nt nu nv bi translated">无需停机即可轻松从管理节点故障中恢复</li></ul><p id="293e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这就是为什么Docker建议您根据项目的可用性需求实现奇数个节点。</p><p id="151f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu">注意:</strong> Docker建议一个群最多有七个管理节点。</p><h2 id="cb89" class="mz md it bd me na nb dn mi nc nd dp mm li ne nf mo lm ng nh mq lq ni nj ms nk bi translated">工作节点</h2><p id="7f3a" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">工作者节点也是Docker引擎的实例，其唯一目的是按照管理者节点的指示执行容器和服务。</p><p id="fbc9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">要将您的应用程序部署到swarm，您至少需要一个管理器节点。默认情况下，所有管理器节点也是工作节点。为了防止调度器将任务放在多节点群中的manager节点上，您需要将availability设置为<code class="fe ob oc od oe b">Drain</code>。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="5954" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">服务</h1><p id="2c1c" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">一个<em class="nl">服务</em>是在节点上执行的任务的定义。这是用户与群体互动的主要根源。</p><p id="a18d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">当您创建服务时，您可以指定要使用的容器映像以及要在运行的容器中执行的命令。您还可以为服务定义其他选项，包括:</p><ul class=""><li id="fb79" class="nn no it lb b lc ld lf lg li np lm nq lq nr lu ns nt nu nv bi translated">要公开的端口</li><li id="b31a" class="nn no it lb b lc nw lf nx li ny lm nz lq oa lu ns nt nu nv bi translated">CPU和内存限制</li><li id="30ca" class="nn no it lb b lc nw lf nx li ny lm nz lq oa lu ns nt nu nv bi translated">要在群集中运行的映像副本的数量</li><li id="7db2" class="nn no it lb b lc nw lf nx li ny lm nz lq oa lu ns nt nu nv bi translated">滚动更新策略</li></ul><p id="37a0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">下面是一个HTTP服务器在三个副本上平衡负载的示例:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi of"><img src="../Images/c068a432f3de8f1e96c1596a7408fbe3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*ymlVpJpQi6HpEg1G.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated"><a class="ae ky" href="https://docs.docker.com/engine/swarm/how-swarm-mode-works/services/" rel="noopener ugc nofollow" target="_blank">具有三个副本的Docker群服务</a></p></figure><p id="bab6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如您所见，该服务有三个不同的任务，每个任务只调用一个容器。任务表示调度程序可以放置容器的位置。一旦容器是活动的，调度器就识别出任务处于<code class="fe ob oc od oe b">Running</code>状态。</p><h2 id="cc38" class="mz md it bd me na nb dn mi nc nd dp mm li ne nf mo lm ng nh mq lq ni nj ms nk bi translated">任务调度</h2><p id="77bc" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">一个<em class="nl">任务</em>携带一个Docker容器和在容器内部执行的命令。这是蜂群的原子调度单元。管理节点根据服务中副本集的数量将任务分配给工作节点。</p><p id="a89c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">当创建或更新服务时，orchestrator通过调度任务来实现所需的状态。每个任务都是一个插槽，调度程序通过生成一个容器来填充它——这是任务的实例化。现在，当其中一个容器运行状况检查失败或崩溃时，orchestrator会创建一个新的复制任务，生成一个新容器来替换失败的容器。</p><p id="7be7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">下图显示了swarm模式如何接受服务并为工作节点调度任务。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi og"><img src="../Images/c8650083496286529c8f9033563822c3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*IhewhZm33IRtpBze.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated"><a class="ae ky" href="https://docs.docker.com/engine/swarm/how-swarm-mode-works/services/" rel="noopener ugc nofollow" target="_blank"> Docker任务调度</a></p></figure><h2 id="576c" class="mz md it bd me na nb dn mi nc nd dp mm li ne nf mo lm ng nh mq lq ni nj ms nk bi translated">复制和全球服务</h2><p id="e65b" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">有两种不同的方法可以部署服务，复制和全局。</p><p id="04f2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><em class="nl">复制服务</em>指定您想要运行的相同任务(副本)的数量。然后，这些副本将被拆分到不同的工作节点上，每个副本提供相同的内容。</p><p id="7aa8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><em class="nl">全局服务</em>是一种在集群中的每个节点上运行一个任务的服务，不需要预先指定数量的任务。全局服务通常用于监视代理或您希望在每个节点上运行的任何其他类型的容器。</p><p id="6cd3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这是一个三服务副本和一个全局服务的可视化表示。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi oh"><img src="../Images/072579a89f3e44fe93fc15a185ab384d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*xkak78Lqe8noKlon.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated"><a class="ae ky" href="https://docs.docker.com/engine/swarm/how-swarm-mode-works/services/" rel="noopener ugc nofollow" target="_blank"> Docker副本可视化</a></p></figure></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="2c45" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">入门指南</h1><p id="7d5f" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">既然您已经了解了Docker Swarm的关键概念，我们可以继续学习创建和管理集群的基础知识。</p><h2 id="6240" class="mz md it bd me na nb dn mi nc nd dp mm li ne nf mo lm ng nh mq lq ni nj ms nk bi translated">装置</h2><p id="e0bf" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">Swarm几乎可以在任何操作系统上运行，并且非常容易安装，所以让我们开始吧。</p><p id="38c0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu"> Windows和Mac: </strong></p><p id="aba6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">Compose包含在Windows和Mac桌面安装中，不必单独安装。安装说明可在此处找到:</p><p id="74d3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu"> Linux: </strong></p><p id="f479" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果你使用物理Linux机器或云托管服务作为主机，只需遵循Docker提供的<a class="ae ky" href="https://docs.docker.com/install/" rel="noopener ugc nofollow" target="_blank">安装说明</a>。</p><h2 id="75fa" class="mz md it bd me na nb dn mi nc nd dp mm li ne nf mo lm ng nh mq lq ni nj ms nk bi translated">创造一个蜂群</h2><p id="0f49" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">在你的机器上安装Docker的第一步是创建一个蜂群。为此，我们需要运行以下命令。</p><pre class="kj kk kl km gt oi oe oj ok aw ol bi"><span id="219f" class="mz md it oe b gy om on l oo op">docker swarm init --advertise-addr &lt;MANAGER-IP&gt;</span></pre><p id="ee0a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe ob oc od oe b">MANAGER-IP</code>是群节点管理器将用来广告群集群服务的IP。(如果您使用Docker Desktop for Mac或Docker Desktop for Windows来测试单节点群，只需不带参数地运行<code class="fe ob oc od oe b">docker swarm init</code> <strong class="lb iu"> </strong>。)</p><h2 id="71e9" class="mz md it bd me na nb dn mi nc nd dp mm li ne nf mo lm ng nh mq lq ni nj ms nk bi translated">向群集添加节点</h2><p id="d52e" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">创建完swarm集群后，我们现在可以使用上述命令输出提供的Docker命令添加一个新的节点worker。</p><pre class="kj kk kl km gt oi oe oj ok aw ol bi"><span id="93cd" class="mz md it oe b gy om on l oo op">docker swarm join --token SWMTKN-1-41r5smr3kgfx780781xxgbenin2dp7qikfh9eketc0wrhrkzsn-8lbew6gpgxwd5fkn52l7s6fof 192.168.65.3:2377</span></pre><p id="fe5a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">该节点将作为工作者节点加入群。如果您想授予它管理员权限，您需要提升它或使用另一个invite令牌。</p><p id="b3bd" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">可以使用以下命令显示invite令牌:</p><pre class="kj kk kl km gt oi oe oj ok aw ol bi"><span id="fecf" class="mz md it oe b gy om on l oo op">docker swarm join-token manager</span></pre><h2 id="10df" class="mz md it bd me na nb dn mi nc nd dp mm li ne nf mo lm ng nh mq lq ni nj ms nk bi translated">查看当前节点</h2><p id="08e0" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">您的群中当前节点的状态可以使用<code class="fe ob oc od oe b">node ls</code>命令来验证。</p><pre class="kj kk kl km gt oi oe oj ok aw ol bi"><span id="8b9f" class="mz md it oe b gy om on l oo op">docker node ls</span></pre><p id="6370" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">从该命令的输出中，您将看到您的节点是活动的，可以使用了。</p><p id="912c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">您可以将节点升级或降级为管理者或工作者角色。如果某个特殊节点不可用，并且您需要替换它，这将非常有用。</p><pre class="kj kk kl km gt oi oe oj ok aw ol bi"><span id="5e8b" class="mz md it oe b gy om on l oo op"># Promote node to manager <br/>docker node promote docker-node<br/> <br/># Demote node to worker <br/>docker node demote docker-node</span></pre><p id="e581" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">您也可以使用update命令来更改角色。</p><pre class="kj kk kl km gt oi oe oj ok aw ol bi"><span id="041e" class="mz md it oe b gy om on l oo op">docker node update --role manager docker-node</span></pre><h2 id="7ecf" class="mz md it bd me na nb dn mi nc nd dp mm li ne nf mo lm ng nh mq lq ni nj ms nk bi translated">离开蜂群</h2><p id="09ee" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">一个节点可以自己离开群体或者被管理节点移除。</p><pre class="kj kk kl km gt oi oe oj ok aw ol bi"><span id="a4ac" class="mz md it oe b gy om on l oo op"># Leaving the swarm <br/>docker swarm leave </span><span id="f53c" class="mz md it oe b gy oq on l oo op">#Removing a node from the swarm <br/>docker node rm worker1</span></pre><h2 id="f489" class="mz md it bd me na nb dn mi nc nd dp mm li ne nf mo lm ng nh mq lq ni nj ms nk bi translated">部署服务</h2><p id="1da0" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">在创建了一个群并将您的节点添加到其中之后，您可以继续在其上运行服务。</p><pre class="kj kk kl km gt oi oe oj ok aw ol bi"><span id="1aee" class="mz md it oe b gy om on l oo op">docker service create --replicas 4 --name hellogoogle alpine ping google.com</span></pre><p id="2968" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这里，我们使用<code class="fe ob oc od oe b">service create</code>命令和以下选项创建一个服务:</p><ul class=""><li id="6faf" class="nn no it lb b lc ld lf lg li np lm nq lq nr lu ns nt nu nv bi translated"><code class="fe ob oc od oe b">replicas</code> —该标志指定运行实例的期望状态(在本例中为<code class="fe ob oc od oe b">4</code></li><li id="54ae" class="nn no it lb b lc nw lf nx li ny lm nz lq oa lu ns nt nu nv bi translated"><code class="fe ob oc od oe b">name</code> —定义服务的名称</li></ul><p id="7b8c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">之后，您可以使用<code class="fe ob oc od oe b">service ls</code>命令列出所有正在运行的服务:</p><pre class="kj kk kl km gt oi oe oj ok aw ol bi"><span id="f46c" class="mz md it oe b gy om on l oo op">docker service ls </span><span id="d5ad" class="mz md it oe b gy oq on l oo op">Output: ID NAME MODE REPLICAS IMAGE PORTS uebs1viyktap hellogoogle replicated 4/4 alpine:latest</span></pre><h2 id="a7ec" class="mz md it bd me na nb dn mi nc nd dp mm li ne nf mo lm ng nh mq lq ni nj ms nk bi translated">扩展服务</h2><p id="4a28" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">现在您已经有了一个运行在swarm上的服务，您可以扩展容器和服务的数量。</p><pre class="kj kk kl km gt oi oe oj ok aw ol bi"><span id="3991" class="mz md it oe b gy om on l oo op">docker service scale &lt;SERVICE-ID&gt;=&lt;NUMBER-OF-TASKS&gt; </span><span id="b0ec" class="mz md it oe b gy oq on l oo op"># For our example <br/>docker service scale hellogoogle=10</span></pre><p id="2ef2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">该命令会将副本数量缩放至<code class="fe ob oc od oe b">10</code>。</p><h2 id="9669" class="mz md it bd me na nb dn mi nc nd dp mm li ne nf mo lm ng nh mq lq ni nj ms nk bi translated">检查服务</h2><p id="b68b" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">您可以使用<code class="fe ob oc od oe b">inspect</code>命令获得服务的详细信息。</p><pre class="kj kk kl km gt oi oe oj ok aw ol bi"><span id="2c81" class="mz md it oe b gy om on l oo op">docker service inspect SERVICE_NAME</span></pre><p id="8170" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">还可以通过使用额外的标签(如<code class="fe ob oc od oe b">— pretty</code>标签)来定制输出，以使输出更具可读性。</p><h2 id="bbb2" class="mz md it bd me na nb dn mi nc nd dp mm li ne nf mo lm ng nh mq lq ni nj ms nk bi translated">删除服务</h2><p id="4ef5" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">可以使用<code class="fe ob oc od oe b">rm</code>命令删除服务。</p><pre class="kj kk kl km gt oi oe oj ok aw ol bi"><span id="0ff7" class="mz md it oe b gy om on l oo op">docker service rm hellogoogle</span></pre><h2 id="cf90" class="mz md it bd me na nb dn mi nc nd dp mm li ne nf mo lm ng nh mq lq ni nj ms nk bi translated">更新服务</h2><p id="f6f1" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">Docker Swarm还允许您对正在运行的服务进行滚动更新。滚动更新有以下优点:</p><ul class=""><li id="9f68" class="nn no it lb b lc ld lf lg li np lm nq lq nr lu ns nt nu nv bi translated">没有停机时间(因为它一次只更新特定数量的副本)</li><li id="cfa0" class="nn no it lb b lc nw lf nx li ny lm nz lq oa lu ns nt nu nv bi translated">发生错误时，可以暂停更新</li></ul><p id="333c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu">基本更新:</strong></p><p id="18b8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">使用<code class="fe ob oc od oe b">docker service update</code>命令执行更新:</p><pre class="kj kk kl km gt oi oe oj ok aw ol bi"><span id="00a4" class="mz md it oe b gy om on l oo op"># Create a service <br/>docker service create --name nginx --replicas 3 --update-delay 10s nginx:mainline </span><span id="4554" class="mz md it oe b gy oq on l oo op"># Updating the image <br/>docker service update --image nginx:stable nginx</span></pre><p id="fb33" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe ob oc od oe b"><strong class="lb iu">Update-order</strong></code> <strong class="lb iu"> : </strong></p><p id="9486" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">定义新容器是否在旧容器被终止之前启动。</p><pre class="kj kk kl km gt oi oe oj ok aw ol bi"><span id="a28a" class="mz md it oe b gy om on l oo op">docker service update -d --update-order start-first nginx</span></pre><p id="45c6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe ob oc od oe b"><strong class="lb iu">Parallelism</strong></code> <strong class="lb iu"> : </strong></p><p id="89ca" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这个标志将告诉Swarm它将并行更新多少任务。</p><pre class="kj kk kl km gt oi oe oj ok aw ol bi"><span id="675c" class="mz md it oe b gy om on l oo op">docker service update --update-parallelism 3 nginx</span></pre><h2 id="c49f" class="mz md it bd me na nb dn mi nc nd dp mm li ne nf mo lm ng nh mq lq ni nj ms nk bi translated">定义回滚</h2><p id="e153" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">Docker Swarm允许您自动回滚到以前的服务版本。</p><pre class="kj kk kl km gt oi oe oj ok aw ol bi"><span id="ac19" class="mz md it oe b gy om on l oo op">docker service rollback nginx</span></pre><p id="75ee" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">当更新过程中出现错误时，它们也可以自动执行。</p><pre class="kj kk kl km gt oi oe oj ok aw ol bi"><span id="dfbe" class="mz md it oe b gy om on l oo op">docker service update --detach=false --update-failure-action rollback nginx</span></pre><p id="3636" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">欲了解更多信息，请访问<a class="ae ky" href="https://docs.docker.com/engine/reference/commandline/service_update/" rel="noopener ugc nofollow" target="_blank">官方文档</a>。</p><h2 id="f940" class="mz md it bd me na nb dn mi nc nd dp mm li ne nf mo lm ng nh mq lq ni nj ms nk bi translated">耗尽一个节点</h2><p id="5643" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated"><em class="nl">耗尽可用性</em>阻止一个节点从集群接收新任务。它还会停止该节点上运行的所有任务，并在另一个具有活动<code class="fe ob oc od oe b">availability</code>的可用节点上启动副本任务。</p><pre class="kj kk kl km gt oi oe oj ok aw ol bi"><span id="f1ed" class="mz md it oe b gy om on l oo op">docker node update --availability drain worker1</span></pre><p id="fcc0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu">检查节点:</strong></p><p id="2027" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">您可以检查该节点以查看它的<code class="fe ob oc od oe b">availability</code>:</p><pre class="kj kk kl km gt oi oe oj ok aw ol bi"><span id="023f" class="mz md it oe b gy om on l oo op">docker node inspect --pretty worker1</span></pre><p id="0d5d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu">将其更新回活动状态:</strong></p><p id="7e81" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在您的节点上完成所需的更改并准备好再次启用它之后，将其更新回<code class="fe ob oc od oe b">active</code>。</p><pre class="kj kk kl km gt oi oe oj ok aw ol bi"><span id="8376" class="mz md it oe b gy om on l oo op">docker node update --availability active worker1</span></pre><h2 id="edcf" class="mz md it bd me na nb dn mi nc nd dp mm li ne nf mo lm ng nh mq lq ni nj ms nk bi translated">路由网格</h2><p id="d01f" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated"><em class="nl">路由网格</em>是一个集群范围的传输层(L4)负载均衡器，它将集群中的所有传入请求路由到节点上可用容器的已发布端口。它允许所有群节点接受服务发布端口上的连接。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi or"><img src="../Images/9255580797c0f255e2b327cacb82b7c2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1200/format:webp/0*h917r6xLi8YT47Sl.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated"><a class="ae ky" href="https://success.docker.com/article/ucp-service-discovery-swarm" rel="noopener ugc nofollow" target="_blank"> Docker蜂群路由网</a></p></figure><p id="2e51" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">您可以使用<code class="fe ob oc od oe b">— publish</code>标志(或者简称为<code class="fe ob oc od oe b">-p</code>)发布一个端口:</p><pre class="kj kk kl km gt oi oe oj ok aw ol bi"><span id="4dd8" class="mz md it oe b gy om on l oo op">docker service create -p 80:80 --name nginx --replicas 3 nginx:mainline</span></pre><p id="92be" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">有关如何绕过路由网格并配置外部负载平衡器的更多信息，可在<a class="ae ky" href="https://docs.docker.com/engine/swarm/ingress/" rel="noopener ugc nofollow" target="_blank">官方文档</a>中找到。</p><h2 id="8666" class="mz md it bd me na nb dn mi nc nd dp mm li ne nf mo lm ng nh mq lq ni nj ms nk bi translated">服务日志</h2><p id="a77e" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">日志对于容器化的应用程序来说是一个非常重要的话题，Docker swarm也处理这个话题。</p><p id="0316" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu">获取服务的日志:</strong></p><p id="5d86" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">获取服务的日志与获取单个容器的日志非常相似。</p><pre class="kj kk kl km gt oi oe oj ok aw ol bi"><span id="d4a2" class="mz md it oe b gy om on l oo op">docker service logs hellogoogle</span></pre><p id="c7d4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu">如下日志:</strong></p><p id="9c9f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">您还可以使用<code class="fe ob oc od oe b"> — follow</code>标志获得日志的实时视图。</p><pre class="kj kk kl km gt oi oe oj ok aw ol bi"><span id="8eba" class="mz md it oe b gy om on l oo op">docker service logs --follow hellogoogle</span></pre><p id="7fa1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">您还可以使用一个<a class="ae ky" href="https://docs.docker.com/v17.09/engine/admin/logging/overview/#configure-the-default-logging-driver" rel="noopener ugc nofollow" target="_blank">定制日志驱动程序</a>或者使用更多的标志定制通过<code class="fe ob oc od oe b"><a class="ae ky" href="https://docs.docker.com/engine/reference/commandline/service_logs/" rel="noopener ugc nofollow" target="_blank">docker service logs</a></code>命令得到的输出。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="5926" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">使用机密管理敏感数据</h1><p id="9677" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">秘密是一段不应该在网络上传输或不加密存储的数据。Docker提供了一种服务来集中管理此类数据，并将其安全地传输给那些需要访问它的容器。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nm"><img src="../Images/979ce8bb177180272307cd72a02a7332.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*ly7lgXT2laQO_w7Q.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">工人节点上的Docker群集敏感数据</p></figure><p id="cc9c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">可以通过命令行使用以下命令来创建、检查和删除机密。</p><h2 id="ced0" class="mz md it bd me na nb dn mi nc nd dp mm li ne nf mo lm ng nh mq lq ni nj ms nk bi translated">管理秘密</h2><p id="01d2" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">我们可以使用<code class="fe ob oc od oe b"><strong class="lb iu">secret create</strong></code> <strong class="lb iu"> </strong>命令创建一个秘密，该命令有两个参数:秘密的名称和秘密本身。</p><pre class="kj kk kl km gt oi oe oj ok aw ol bi"><span id="99ff" class="mz md it oe b gy om on l oo op">echo "Secret" | docker secret create my_secret -</span></pre><p id="bade" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">创建密码后，您可以检查它或显示您机器上可用的所有密码。</p><pre class="kj kk kl km gt oi oe oj ok aw ol bi"><span id="1604" class="mz md it oe b gy om on l oo op"># List all secrets <br/>docker secret ls <br/># Inspect a specific secret <br/>docker inspect SECRET_NAME</span></pre><p id="334f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">最后，您可以使用<code class="fe ob oc od oe b">secret rm</code>命令删除一个秘密。</p><pre class="kj kk kl km gt oi oe oj ok aw ol bi"><span id="6e24" class="mz md it oe b gy om on l oo op">docker secret rm my_secret</span></pre><h2 id="7916" class="mz md it bd me na nb dn mi nc nd dp mm li ne nf mo lm ng nh mq lq ni nj ms nk bi translated">将秘密传递给服务</h2><p id="29eb" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">可以在创建服务时或在容器运行时使用以下命令将机密添加到服务中。</p><p id="eb9d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在创建服务时，<code class="fe ob oc od oe b">— secret</code>标签可用于添加秘密。</p><pre class="kj kk kl km gt oi oe oj ok aw ol bi"><span id="6573" class="mz md it oe b gy om on l oo op">docker service create --name="nginx" --secret="my_secret" nginx:latest</span></pre><p id="3ab5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">使用service-update命令上的<code class="fe ob oc od oe b">— secret-add</code>和<code class="fe ob oc od oe b"><strong class="lb iu"> </strong>— secret-rm</code>标签可以添加和删除正在运行的服务的秘密。</p><pre class="kj kk kl km gt oi oe oj ok aw ol bi"><span id="8257" class="mz md it oe b gy om on l oo op">docker service update --secret-rm="my_secret" nginx</span></pre><p id="4d31" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">查看<a class="ae ky" href="https://docs.docker.com/engine/swarm/secrets/" rel="noopener ugc nofollow" target="_blank"> Docker secrets </a>文档了解更多信息。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="bbfa" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">资源有限</h1><p id="fbea" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">限制服务可以访问的资源是容器编排工具的一个重要部分。Swarm通过提供可以添加到您的服务命令中的标签使这变得容易。</p><ul class=""><li id="d8b9" class="nn no it lb b lc ld lf lg li np lm nq lq nr lu ns nt nu nv bi translated"><code class="fe ob oc od oe b">— limit-cpu</code> —以十进制数为参数，限制服务的CPU资源</li><li id="ed24" class="nn no it lb b lc nw lf nx li ny lm nz lq oa lu ns nt nu nv bi translated"><code class="fe ob oc od oe b">— limit-memory</code> —将字节数作为参数—例如2G —并将内存使用限制在该值</li><li id="dc01" class="nn no it lb b lc nw lf nx li ny lm nz lq oa lu ns nt nu nv bi translated"><code class="fe ob oc od oe b">— reserve-cpu</code> —为服务保留特定数量的CPU资源</li><li id="99ba" class="nn no it lb b lc nw lf nx li ny lm nz lq oa lu ns nt nu nv bi translated"><code class="fe ob oc od oe b">— reserve-memory</code> —为服务保留特定数量的内存资源</li></ul><p id="90fe" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">以下是如何使用这些标签的示例:</p><pre class="kj kk kl km gt oi oe oj ok aw ol bi"><span id="5f44" class="mz md it oe b gy om on l oo op">docker service create --name=nginx --limit-cpu 0.1 --limit-memory 1G nginx:latest</span></pre><p id="77e6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">您可以使用<code class="fe ob oc od oe b">inspect</code>命令检查服务的局限性。</p><pre class="kj kk kl km gt oi oe oj ok aw ol bi"><span id="a9d9" class="mz md it oe b gy om on l oo op">docker service inspect --pretty nginx</span></pre><p id="68e6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">关于限制服务资源的更多信息可以在<a class="ae ky" href="https://docs.docker.com/config/containers/resource_constraints/" rel="noopener ugc nofollow" target="_blank">文档</a>中找到。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="490f" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">标签</h1><p id="ed2b" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">在拥有大型集群的情况下，向节点和服务添加标签会非常有帮助，并使过滤之类的任务变得更加容易。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi os"><img src="../Images/d66716757d2914e14f3118b4ed9add86.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*TQcq7gcLEfIC96ti.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated"><a class="ae ky" href="https://docs.docker.com/v17.12/datacenter/ucp/2.2/guides/admin/configure/add-labels-to-cluster-nodes/" rel="noopener ugc nofollow" target="_blank">码头工人群体标签</a></p></figure><p id="cb35" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">标签可以用来给一个已经存在的节点添加一个新标签。</p><pre class="kj kk kl km gt oi oe oj ok aw ol bi"><span id="c091" class="mz md it oe b gy om on l oo op">docker node update --label-add &lt;key&gt;=&lt;value&gt; &lt;node-id&gt;</span></pre><p id="45d5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">标签也可以被添加到服务和容器中，我不会在这篇文章中深入讨论，但是你可以在<a class="ae ky" href="https://docs.docker.com/v17.12/datacenter/ucp/2.2/guides/admin/configure/add-labels-to-cluster-nodes/" rel="noopener ugc nofollow" target="_blank">官方文档</a>或<a class="ae ky" href="https://docs.docker.com/engine/reference/commandline/service_create/#set-metadata-on-a-service-l-label" rel="noopener ugc nofollow" target="_blank"> docker服务命令</a>文档中找到更多信息。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="7262" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">Docker堆栈文件</h1><p id="db97" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">Docker Stack是现有Docker-Compose文件的扩展，它允许您为您的群配置定义部署选项——比如副本的数量或服务的资源限制。</p><p id="3dfe" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果你还没有使用Docker Compose的经验，我建议你先看看这篇文章。</p><h2 id="7ebf" class="mz md it bd me na nb dn mi nc nd dp mm li ne nf mo lm ng nh mq lq ni nj ms nk bi translated">创建堆栈</h2><p id="d3f7" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">如前所述，Docker Stack是Docker-Compose文件的扩展，它只是让你为你的Swarm部署定义一些额外的属性。这些属性可以使用组合文件中的<code class="fe ob oc od oe b">deploy</code>键来定义。</p><p id="b43d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">重要属性包括:</p><ul class=""><li id="efce" class="nn no it lb b lc ld lf lg li np lm nq lq nr lu ns nt nu nv bi translated"><code class="fe ob oc od oe b">replicas</code> —定义服务的副本数量</li><li id="bc3d" class="nn no it lb b lc nw lf nx li ny lm nz lq oa lu ns nt nu nv bi translated"><code class="fe ob oc od oe b">update_config</code> —定义服务的更新方式，例如并行度和延迟</li><li id="dd76" class="nn no it lb b lc nw lf nx li ny lm nz lq oa lu ns nt nu nv bi translated"><code class="fe ob oc od oe b">labels</code></li><li id="a509" class="nn no it lb b lc nw lf nx li ny lm nz lq oa lu ns nt nu nv bi translated"><code class="fe ob oc od oe b">restart_policy</code></li><li id="ecf1" class="nn no it lb b lc nw lf nx li ny lm nz lq oa lu ns nt nu nv bi translated"><code class="fe ob oc od oe b">resources</code></li></ul><p id="5a09" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这是一个堆栈部署的示例:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ot ou l"/></div></figure><p id="0daa" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">关于<code class="fe ob oc od oe b">deploy</code>关键字可用选项的更多信息可以在<a class="ae ky" href="https://docs.docker.com/compose/compose-file/#deploy" rel="noopener ugc nofollow" target="_blank">这里</a>找到。</p><h2 id="791c" class="mz md it bd me na nb dn mi nc nd dp mm li ne nf mo lm ng nh mq lq ni nj ms nk bi translated">管理堆栈</h2><p id="98d0" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">可以通过运行<code class="fe ob oc od oe b"><a class="ae ky" href="https://docs.docker.com/engine/reference/commandline/stack/" rel="noopener ugc nofollow" target="_blank">docker stack deploy</a></code>命令并提供您的堆栈文件来执行堆栈。</p><pre class="kj kk kl km gt oi oe oj ok aw ol bi"><span id="f3f8" class="mz md it oe b gy om on l oo op">docker stack deploy -c docker-compose.yml nginxtest</span></pre><p id="0aed" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">您还可以使用<code class="fe ob oc od oe b">ls</code>和<code class="fe ob oc od oe b">ps</code>命令列出您的所有堆栈或特定堆栈的服务。</p><pre class="kj kk kl km gt oi oe oj ok aw ol bi"><span id="668e" class="mz md it oe b gy om on l oo op"># List all stacks <br/>docker stack ls <br/># List the services of a specific stack <br/>docker stack ps STACK_NAME</span></pre><p id="5e8a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">移除堆栈类似于移除服务，可以使用<code class="fe ob oc od oe b">rm</code>命令来完成。</p><pre class="kj kk kl km gt oi oe oj ok aw ol bi"><span id="71dd" class="mz md it oe b gy om on l oo op">docker stack rm STACK_NAME</span></pre></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="b4bd" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">例子</h1><p id="beb6" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">现在我们已经学习了蜂群理论，让我们来看看我们刚刚谈到的一些魔法的实际运用。为此，我们将部署一个已经包含Docker-Compose文件的NestJS GraphQL应用程序，这样我们就可以专注于群配置。</p><p id="c7c5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">该项目包含一个本地图像，该图像必须存储在注册表中，然后文件才能作为群集运行。如果你不知道什么是注册中心或者为什么我们需要注册中心，我推荐你阅读Docker文档中的这篇文章。</p><p id="3bcc" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们从用GitHub中完成的样板文件克隆存储库开始。</p><pre class="kj kk kl km gt oi oe oj ok aw ol bi"><span id="d555" class="mz md it oe b gy om on l oo op">git clone <a class="ae ky" href="https://github.com/TannerGabriel/nestjs-graphql-boilerplate.git" rel="noopener ugc nofollow" target="_blank">https://github.com/TannerGabriel/nestjs-graphql-boilerplate.git</a></span></pre><p id="eb55" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这将为您提供以下文件夹结构:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi ov"><img src="../Images/ba1f792e1b99c5492288c0a6dd77b3ec.png" data-original-src="https://miro.medium.com/v2/resize:fit:578/format:webp/0*QUK4xDNb93SFlY5r.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">Nestjs GraphQL样板文件夹结构</p></figure><p id="9d8e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如上所述，项目已经包含了一个<code class="fe ob oc od oe b">docker-compose.yml</code>文件，应该是这样的。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ot ou l"/></div></figure><p id="4dc1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在，我们需要对该文件进行一些更改，以便将自定义Node.js图像上传到注册表。(我们将设置一个本地注册表用于测试目的。)</p><h2 id="b916" class="mz md it bd me na nb dn mi nc nd dp mm li ne nf mo lm ng nh mq lq ni nj ms nk bi translated">将图像推送到注册表</h2><p id="bc70" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">首先，我们需要向Node.js服务添加一个image标记，并提供应该保存它的注册表(在我们的例子中是<code class="fe ob oc od oe b">localhost:5000</code>)。</p><pre class="kj kk kl km gt oi oe oj ok aw ol bi"><span id="407c" class="mz md it oe b gy om on l oo op">services: nodejs: image: 127.0.0.1:5000/nodejs</span></pre><p id="28ea" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在，我们将使用以下命令创建本地注册表:</p><pre class="kj kk kl km gt oi oe oj ok aw ol bi"><span id="daaf" class="mz md it oe b gy om on l oo op">docker service create --name registry -p 5000:5000 registry:2</span></pre><p id="ba86" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">注册表运行后，我们可以继续使用<code class="fe ob oc od oe b">push</code>命令将本地映像推送到注册表中。</p><pre class="kj kk kl km gt oi oe oj ok aw ol bi"><span id="8131" class="mz md it oe b gy om on l oo op">docker-compose push</span></pre><h2 id="d265" class="mz md it bd me na nb dn mi nc nd dp mm li ne nf mo lm ng nh mq lq ni nj ms nk bi translated">添加群组配置:</h2><p id="dbed" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">有了映像，我们可以继续将群配置添加到Docker-Compose文件中。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ot ou l"/></div></figure><p id="14ef" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">好了，让我们通过遍历代码来理解这里发生了什么:</p><ul class=""><li id="bd73" class="nn no it lb b lc ld lf lg li np lm nq lq nr lu ns nt nu nv bi translated"><code class="fe ob oc od oe b">deploy</code>关键字用于提供群体将使用的配置</li><li id="2d5f" class="nn no it lb b lc nw lf nx li ny lm nz lq oa lu ns nt nu nv bi translated">之后，我们添加一些我们上面讨论过的选项——例如，<code class="fe ob oc od oe b">replicas</code>、<code class="fe ob oc od oe b">resources</code>或<code class="fe ob oc od oe b">restart_policy</code>。</li></ul><h2 id="ec7d" class="mz md it bd me na nb dn mi nc nd dp mm li ne nf mo lm ng nh mq lq ni nj ms nk bi translated">部署服务</h2><p id="27ce" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">就是这样。我们已经完成了Docker文件，现在可以继续运行应用程序了。这是使用以下命令完成的:</p><pre class="kj kk kl km gt oi oe oj ok aw ol bi"><span id="4983" class="mz md it oe b gy om on l oo op">docker stack deploy --compose-file docker-compose.yml stackdemo</span></pre><p id="9ccc" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如终端输出所示，您的服务现在正在运行，您可以通过在命令行中写入<code class="fe ob oc od oe b">docker stack ls</code>或访问<code class="fe ob oc od oe b">localhost:3000/graphql</code>来检查它。您应该会看到类似这样的内容:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nm"><img src="../Images/00b09d5c59689ea30d265ecb13149366.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*qcmpoCxgbB8G-tTc.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">Nestjs GraphQl游乐场</p></figure></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="7b10" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">结论</h1><p id="6931" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">你一路走到了最后。我希望这篇文章能够帮助您理解Docker Swarm，以及作为一名开发人员，您如何使用它来改进您的开发和部署工作流。</p><h2 id="0a81" class="mz md it bd me na nb dn mi nc nd dp mm li ne nf mo lm ng nh mq lq ni nj ms nk bi translated">来源</h2><ul class=""><li id="4bcf" class="nn no it lb b lc mu lf mv li ow lm ox lq oy lu ns nt nu nv bi translated"><a class="ae ky" href="https://docs.docker.com/" rel="noopener ugc nofollow" target="_blank"> Docker文档</a></li><li id="7270" class="nn no it lb b lc nw lf nx li ny lm nz lq oa lu ns nt nu nv bi translated"><a class="ae ky" href="https://www.docker.com/blog/" rel="noopener ugc nofollow" target="_blank"> Docker博客</a></li><li id="7bd4" class="nn no it lb b lc nw lf nx li ny lm nz lq oa lu ns nt nu nv bi translated"><a class="ae ky" href="https://success.docker.com/" rel="noopener ugc nofollow" target="_blank">码头工人成功中心</a></li></ul></div></div>    
</body>
</html>