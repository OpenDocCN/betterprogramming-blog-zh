<html>
<head>
<title>Selfdestruct: How To Destroy a Smart Contract</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">自毁:如何摧毁一个聪明的契约</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/selfdestruct-how-to-destroy-a-smart-contract-388a9ba51a94?source=collection_archive---------0-----------------------#2022-10-19">https://betterprogramming.pub/selfdestruct-how-to-destroy-a-smart-contract-388a9ba51a94?source=collection_archive---------0-----------------------#2022-10-19</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="1097" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">理解为什么以及如何创建一个“致命的”智能契约，同时考虑相对的安全影响</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/5dc36e132beadb4f0cf7cd320f1d0a1f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*xmm35URpirS2pJDt"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">由<a class="ae ky" href="https://unsplash.com/@emc?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Eric Crawford </a>在<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</p></figure><h1 id="90b1" class="kz la it bd lb lc ld le lf lg lh li lj jz lk ka ll kc lm kd ln kf lo kg lp lq bi translated">什么是智能合同</h1><p id="f839" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">“智能合约”账户只是一个运行在以太坊区块链上的程序，由代码(功能)和数据(状态)定义。</p><p id="80fb" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">智能合约不受用户控制；相反，它们被部署到网络上，并根据它们的程序运行。然后，用户可以通过提交执行智能合约上定义的功能的交易来与智能合约进行交互。与智能合约的交互是不可逆的。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi ms"><img src="../Images/474becd776e7105f2a163114d1c602fc.png" data-original-src="https://miro.medium.com/v2/resize:fit:926/0*95Gs5LNCidvZj7ye"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">来自<a class="ae ky" href="https://takenobu-hs.github.io/downloads/ethereum_evm_illustrated.pdf" rel="noopener ugc nofollow" target="_blank">以太坊EVM画报</a>的智能合同表述</p></figure><p id="6e92" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">一旦部署到网络上，默认情况下，智能合同就不能更改或删除。但是，可以包含一个<code class="fe mt mu mv mw b">selfdestruct</code>功能，允许智能合约被“删除”，擦除代码及其内部状态(存储)并留下一个空白帐户。</p><h1 id="efa1" class="kz la it bd lb lc ld le lf lg lh li lj jz lk ka ll kc lm kd ln kf lo kg lp lq bi translated">为什么要销毁合同</h1><p id="ba4a" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">因此，使用<code class="fe mt mu mv mw b">selfdestruct</code>功能使开发者能够从区块链中移除智能合约。但是这种过激的对策背后的原因是什么呢？</p><p id="dd14" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">要回答这个问题，阅读<a class="ae ky" href="https://arxiv.org/pdf/2005.07908.pdf" rel="noopener ugc nofollow" target="_blank">为什么智能合约会自毁是有帮助的？</a></p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi mx"><img src="../Images/c8f89ee0fc647b14ba5189e17e8915a7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*pe5-RROvPSW-xVl8"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated"><a class="ae ky" href="https://arxiv.org/pdf/2005.07908.pdf" rel="noopener ugc nofollow" target="_blank">自毁原因及其在340个自毁智能合约中的分布</a></p></figure><p id="dc16" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">本研究发现并分析了340份自毁契约。通过将自毁合同定义为“前任”合同，将其升级版本定义为“继任”合同，作者通过比较“前任”合同和“继任”合同之间的差异，确定了合同被销毁的五个主要原因。</p><p id="5d83" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">他们发现，功能变更的需求排在列表的最前面，其次是合同包含错误或表现出不良行为的情况。</p><p id="56a9" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">此外，以太坊提供了从区块链中移除智能合约的激励。这种交易具有负的气体成本，因为该操作通过清除所有合同数据来释放区块链上的空间。这种负气体从交易的总气体成本中扣除。</p><h1 id="05df" class="kz la it bd lb lc ld le lf lg lh li lj jz lk ka ll kc lm kd ln kf lo kg lp lq bi translated">自毁是如何工作的？</h1><p id="35d3" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">智能合约生命始于来自EOA或合约账户的创建交易。创建智能契约的事务的数据负载本身就是运行契约构造函数(如果存在)来初始化契约状态的字节码。</p><p id="b0ba" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">另一方面，合同的最后一口气是它的毁灭。以太坊中的<code class="fe mt mu mv mw b">selfdestruct</code>是EVM级别的<a class="ae ky" href="https://github.com/wolflo/evm-opcodes/blob/main/gas.md#ab-selfdestruct" rel="noopener ugc nofollow" target="_blank">操作码</a>，与使用的语言或客户端无关。</p><p id="9101" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">这个操作码是一个名为<code class="fe mt mu mv mw b">selfdestruct</code>的高级内置函数，它只接受一个参数:契约帐户中任何剩余以太网必须发送到的地址。</p><pre class="kj kk kl km gt my mw mz na aw nb bi"><span id="e294" class="nc la it mw b gy nd ne l nf ng">selfdestruct(address recipient);</span></pre><p id="b991" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">一个重要的注意事项是，开发人员必须明确地将该命令添加到合同中。否则，智能合约将永远无法删除。</p><p id="85bd" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">在契约销毁后，发送到该帐户地址的任何事务都不会导致任何代码执行，因为那里不再有任何代码可执行。</p><p id="377a" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">删除合同不会删除合同的交易历史(过去),因为区块链本身是不可变的。</p><blockquote class="nh ni nj"><p id="7498" class="lr ls nk lt b lu mn ju lw lx mo jx lz nl mp mc md nm mq mg mh nn mr mk ml mm im bi translated">"所以使用自毁不同于从硬盘上删除数据."</p></blockquote><h1 id="2689" class="kz la it bd lb lc ld le lf lg lh li lj jz lk ka ll kc lm kd ln kf lo kg lp lq bi translated">让智能合同变得“凡人”</h1><p id="2057" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">现在，我们将使用构造函数和<code class="fe mt mu mv mw b">selfdestruct</code>命令创建一个简单的智能契约:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="no np l"/></div></figure><p id="9fe3" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">通常，希望<code class="fe mt mu mv mw b">selfdestruct</code>命令只能由最初创建契约的帐户调用。因此，使用了名为<code class="fe mt mu mv mw b">owner</code>的地址类型变量。事实上，在契约创建时，构造函数将这个变量赋给了<code class="fe mt mu mv mw b">msg.sender</code>。</p><p id="693a" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">契约有一个最小的<code class="fe mt mu mv mw b">destroy()</code>功能。require语句确保只有所有者才能运行该函数。它检查所有者是否是调用者，否则失败。如果支票没问题，合同将自毁，并将任何剩余余额发送到所有者的地址。</p><p id="fb02" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">以下测试显示了可析构契约的预期行为。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="no np l"/></div></figure><ul class=""><li id="8fa4" class="nq nr it lt b lu mn lx mo ma ns me nt mi nu mm nv nw nx ny bi translated">部署:部署合同</li><li id="24a7" class="nq nr it lt b lu nz lx oa ma ob me oc mi od mm nv nw nx ny bi translated">获取所有者:检查已部署契约的所有者是否正确</li><li id="3878" class="nq nr it lt b lu nz lx oa ma ob me oc mi od mm nv nw nx ny bi translated">调用destroy失败:检查destroy函数是否只能从协定的所有者调用</li><li id="ac92" class="nq nr it lt b lu nz lx oa ma ob me oc mi od mm nv nw nx ny bi translated">调用销毁成功:从所有者帐户调用销毁函数</li><li id="7f70" class="nq nr it lt b lu nz lx oa ma ob me oc mi od mm nv nw nx ny bi translated">获取合同失败:检查合同代码是否不再可用</li></ul><h1 id="447a" class="kz la it bd lb lc ld le lf lg lh li lj jz lk ka ll kc lm kd ln kf lo kg lp lq bi translated">安全影响</h1><p id="70e4" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">对智能合约有一个普遍的误解。事实上，很多没有经验的Solidity开发者错误地认为，一个契约只能通过可支付的函数来获得醚。</p><blockquote class="oe"><p id="a519" class="of og it bd oh oi oj ok ol om on mm dk translated">那不是真的！</p></blockquote><p id="4c78" class="pw-post-body-paragraph lr ls it lt b lu oo ju lw lx op jx lz ma oq mc md me or mg mh mi os mk ml mm im bi translated">如前所述，任何实现了<code class="fe mt mu mv mw b">selfdestruct</code>函数的契约都可以将其所有的以太网发送到一个特定的地址。如果该地址是约定地址，则在不调用任何函数(包括回退)的情况下发生醚的转移。</p><p id="4a20" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">因此，<code class="fe mt mu mv mw b">selfdestruct</code>函数是一种将ethers强制发送到任何契约的方法，而不管它内部实现了什么代码(即使契约缺少payable函数)。</p><p id="73c8" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">这种行为意味着攻击者可以通过三个简单的步骤轻松地将以太网发送到目标合同:</p><ol class=""><li id="3611" class="nq nr it lt b lu mn lx mo ma ns me nt mi nu mm ot nw nx ny bi translated">可以用<code class="fe mt mu mv mw b">selfdestruct</code>功能创建合同</li><li id="1d68" class="nq nr it lt b lu nz lx oa ma ob me oc mi od mm ot nw nx ny bi translated">给它送乙醚</li><li id="44d6" class="nq nr it lt b lu nz lx oa ma ob me oc mi od mm ot nw nx ny bi translated">呼叫<code class="fe mt mu mv mw b">selfdestruct(targetContract)</code></li></ol><p id="1732" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">这一弱点导致对合同实际余额的错误假设。</p><p id="d5de" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">没有什么比一个示例游戏合同更好的来阐明这种情况如何会导致不想要的影响。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="no np l"/></div></figure><p id="004d" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">这个合同代表一个简单的游戏，并不打算在实践中使用。一个想玩的用户给契约发0.5以太(调用<code class="fe mt mu mv mw b">play()</code>函数)。他们希望成为达到三个里程碑之一的人。里程碑是由合同确定的一段时间内拥有的醚量。当游戏结束时，第一个到达里程碑的用户可以在以太中要求奖励。当到达最后一个里程碑时，游戏结束。</p><p id="242e" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">攻击者可以通过自己部署的契约的<code class="fe mt mu mv mw b">selfdestruct</code>功能发送少量的以太网(0.000001也足够了)。这个简单的操作阻止任何未来的玩家达到一个里程碑。这是因为第17行计算的<code class="fe mt mu mv mw b">currentBalance</code>将永远不会是0.5以太的倍数，这是由于这个小以太对合同余额的贡献(注意，玩家被迫只发送0.5以太增量)。</p><p id="c63f" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">这里的问题是第17行的<code class="fe mt mu mv mw b">this.balance</code>使用不当。契约逻辑应该避免依赖于契约的平衡，因为它可能被恶意操纵。</p><p id="640b" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">一个可能的解决方案是使用自定义变量(例如<code class="fe mt mu mv mw b">depositedEth</code>)并增加它来安全地跟踪沉积的乙醚。该变量不会受到<code class="fe mt mu mv mw b">selfdestruct</code>调用的影响，因为它不再引用<code class="fe mt mu mv mw b">this.balance</code>。</p><pre class="kj kk kl km gt my mw mz na aw nb bi"><span id="6404" class="nc la it mw b gy nd ne l nf ng">uint currentBalance = depositedEth + msg.value;</span></pre><p id="ae01" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">感谢您的阅读。我希望你喜欢这篇文章。</p><p id="974e" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">让我知道你对它的想法。</p></div></div>    
</body>
</html>