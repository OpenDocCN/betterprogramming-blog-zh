<html>
<head>
<title>Why Do We Need Strict Mode in JavaScript?</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">JavaScript中为什么需要严格模式？</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/why-do-we-need-strict-mode-in-javascript-df34771eb950?source=collection_archive---------3-----------------------#2019-11-10">https://betterprogramming.pub/why-do-we-need-strict-mode-in-javascript-df34771eb950?source=collection_archive---------3-----------------------#2019-11-10</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="7b36" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">这是什么？这是为了什么？我们为什么要使用它？</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/8e3767e880b873ebb460847a6f61de8d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*koVK62DU2I-AVeVg"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">照片由<a class="ae ky" href="https://unsplash.com/@pankajpatel?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Pankaj Patel </a>在<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</p></figure><p id="5aac" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">严格模式是现代JavaScript的重要组成部分。这是一种允许我们选择更受限制的JavaScript语法的模式。</p><p id="6c0a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">严格模式的语义不同于旧的JavaScript的“草率模式”,后者具有更宽松的语法，并且在代码中出现错误时会被隐藏。这意味着错误被忽略，代码运行时可能会出现意外结果。</p><p id="68c1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">严格模式对JavaScript语义做了几处修改。它消除了静默错误，而是抛出它们，这样代码就不会在运行时出现错误。</p><p id="6a14" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">它还会指出妨碍JavaScript引擎进行优化的错误。此外，它还禁止可能在JavaScript的未来版本中定义的特性。</p><p id="76fb" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">严格模式可以应用于单个函数或整个脚本。它不能只应用于花括号中的语句或其他块。为了让脚本使用严格模式，我们在脚本的顶部添加了语句<code class="fe lv lw lx ly b">"use strict"</code>或<code class="fe lv lw lx ly b">'use strict'</code>在任何其他语句之前。</p><p id="1fb2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果我们有一些使用严格模式的脚本和一些不使用严格模式的脚本，那么我们可能有一些使用严格模式的脚本与其他不使用严格模式的脚本连接在一起。</p><p id="0a17" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这意味着不使用严格模式的代码在连接在一起时可能会使用严格模式。反之亦然。所以，最好不要混在一起。</p><p id="580d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们也可以将此应用于函数。为此，我们将语句<code class="fe lv lw lx ly b">"use strict"</code>或<code class="fe lv lw lx ly b">'use strict'</code>添加到主体顶部的函数中，放在任何其他语句之前。它适用于内部的一切，包括嵌套在使用严格模式的函数中的函数。</p><p id="b35e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">例如:</p><pre class="kj kk kl km gt lz ly ma mb aw mc bi"><span id="dac2" class="md me it ly b gy mf mg l mh mi">const strictFunction = ()=&gt;{<br/>  'use strict';<br/>  const nestedFunction = ()=&gt;{<br/>    // this function also uses strict mode<br/>  }<br/>}</span></pre><p id="d938" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">ES2015中引入的JavaScript模块自动启用了严格模式，因此无需任何语句即可启用。</p></div><div class="ab cl mj mk hx ml" role="separator"><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo"/></div><div class="im in io ip iq"><h1 id="0b80" class="mq me it bd mr ms mt mu mv mw mx my mz jz na ka nb kc nc kd nd kf ne kg nf ng bi translated">严格模式下的变化</h1><p id="a272" class="pw-post-body-paragraph kz la it lb b lc nh ju le lf ni jx lh li nj lk ll lm nk lo lp lq nl ls lt lu im bi translated">严格模式改变使用它的代码的语法和运行时行为。代码中的错误被转换为运行时抛出的语法错误，简化特定变量的计算方式，简化<code class="fe lv lw lx ly b">eval</code>函数和<code class="fe lv lw lx ly b">arguments</code>对象的更改，以及可能在未来es规范中实现的更改。</p></div><div class="ab cl mj mk hx ml" role="separator"><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo"/></div><div class="im in io ip iq"><h1 id="1639" class="mq me it bd mr ms mt mu mv mw mx my mz jz na ka nb kc nc kd nd kf ne kg nf ng bi translated">将错误转化为错误</h1><p id="6e4b" class="pw-post-body-paragraph kz la it lb b lc nh ju le lf ni jx lh li nj lk ll lm nk lo lp lq nl ls lt lu im bi translated">错误转化为错误。它们以前是以非严格模式接受的。严格模式限制错误语法的使用，不会让代码在有错误的情况下运行。</p><p id="d632" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">它不允许我们用<code class="fe lv lw lx ly b">var</code>、<code class="fe lv lw lx ly b">let</code>或<code class="fe lv lw lx ly b">const</code>来声明变量，这使得创建全局变量变得困难，所以创建变量而不用这些关键字来声明它们是行不通的。例如，下面的代码将抛出一个<code class="fe lv lw lx ly b">ReferenceError</code>:</p><pre class="kj kk kl km gt lz ly ma mb aw mc bi"><span id="fb80" class="md me it ly b gy mf mg l mh mi">'use strict';<br/>badVariable = 1;</span></pre><p id="1b87" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们不能在严格模式下运行上面的代码，因为如果严格模式关闭，这段代码将创建一个全局变量<code class="fe lv lw lx ly b">badVariable</code>。严格模式可以防止意外创建全局变量。</p><p id="51ff" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">任何静默失败的代码现在都会抛出异常。这包括之前被忽略的任何无效语法。</p><p id="b43e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">例如，在严格模式下，我们不能不给只读变量赋值，比如<code class="fe lv lw lx ly b">arguments</code>、<code class="fe lv lw lx ly b">NaN</code>或<code class="fe lv lw lx ly b">eval</code>。</p><p id="f99a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">任何对只读属性的赋值，比如不可写的全局属性、getter-only属性的赋值，以及对不可扩展对象的属性赋值，都会在严格模式下抛出异常。</p><p id="05c4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">下面是一些在严格模式下会失败的语法示例:</p><pre class="kj kk kl km gt lz ly ma mb aw mc bi"><span id="b437" class="md me it ly b gy mf mg l mh mi">'use strict';<br/><br/>let undefined = 5; <br/>let Infinity = 5;<br/><br/>let obj = {};<br/>Object.defineProperty(obj, 'foo', { value: 1, writable: false });<br/>obj.foo = 1<br/><br/>let obj2 = { get foo() { return 17; } };<br/>obj2.foo = 2<br/><br/>let fixedObj = {};<br/>Object.preventExtensions(fixedObj);<br/>fixed.bar= 1;</span></pre><p id="fbff" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">上面所有的例子都会抛出一个<code class="fe lv lw lx ly b">TypeError</code>。<code class="fe lv lw lx ly b">undefined</code>和<code class="fe lv lw lx ly b">Infinity</code>是不可写的全局对象。<code class="fe lv lw lx ly b">obj</code>是不可写的属性。</p><p id="90ef" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe lv lw lx ly b">obj2</code>的<code class="fe lv lw lx ly b">foo</code>属性是仅getter属性，因此无法设置。<code class="fe lv lw lx ly b">fixedObj</code>被阻止使用<code class="fe lv lw lx ly b">Object.preventExtensions</code>方法向其添加更多属性。</p><p id="5ae2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">此外，当有代码试图删除不可删除的属性时，会抛出一个<code class="fe lv lw lx ly b">TypeError</code>。例如:</p><pre class="kj kk kl km gt lz ly ma mb aw mc bi"><span id="c4f6" class="md me it ly b gy mf mg l mh mi">'use strict';<br/>delete <!-- -->Array<!-- -->.prototype</span></pre><p id="9548" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这样会抛出一个<code class="fe lv lw lx ly b">TypeError</code>。</p><p id="0cb1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在引入ES6之前，严格模式也不允许对象中有重复的属性名，因此以下示例将引发语法错误:</p><pre class="kj kk kl km gt lz ly ma mb aw mc bi"><span id="26ba" class="md me it ly b gy mf mg l mh mi">'use strict';<br/>var o = { a: 1, a: 2 };</span></pre><p id="f9ce" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">严格模式要求函数参数名是唯一的。在没有严格模式的情况下，如果两个参数的名称都是<em class="nm">一个是</em>，那么当传入参数时，后面定义的那个将被接受为参数的值。</p><p id="d859" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在严格模式下，不再允许多个函数参数具有相同的名称，因此以下示例将无法运行，并出现语法错误:</p><pre class="kj kk kl km gt lz ly ma mb aw mc bi"><span id="cb05" class="md me it ly b gy mf mg l mh mi">const multiply = (x, x, y) =&gt; x*x*y;</span></pre><p id="4317" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在严格模式下也不允许八进制语法。这不是规范的一部分，但是浏览器通过在八进制数前加一个0来支持它。</p><p id="b7e9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这让开发人员感到困惑，因为有些人可能认为数字前面的0没有意义。因此，严格模式不允许此语法，并将引发语法错误。</p><p id="83dc" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">严格模式还防止使用使优化变得困难的语法。在进行优化之前，它需要知道一个变量实际上是存储在它认为的存储位置，所以我们必须防止这种阻止优化发生的语法。</p><p id="1d18" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这方面的一个例子是<code class="fe lv lw lx ly b">with</code>语句。如果我们使用它，它会阻止JavaScript解释器知道你指的是哪个变量或属性，因为在<code class="fe lv lw lx ly b">with</code>语句内部或外部可能有同名的变量。</p><p id="57af" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果我们有类似下面的代码:</p><pre class="kj kk kl km gt lz ly ma mb aw mc bi"><span id="4719" class="md me it ly b gy mf mg l mh mi">let x = 1;<br/>with (obj) {<br/>  x;<br/>}</span></pre><p id="14a6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">然后，JavaScript不会知道<code class="fe lv lw lx ly b">with</code>语句中的<code class="fe lv lw lx ly b">x</code>是指<code class="fe lv lw lx ly b">x</code>变量还是<code class="fe lv lw lx ly b">obj</code>、<code class="fe lv lw lx ly b">obj.x</code>的属性。</p><p id="e42a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">所以<code class="fe lv lw lx ly b">x</code>的存储位置是不明确的。因此，严格模式阻止使用<code class="fe lv lw lx ly b">with</code>语句。如果我们有如下的严格模式:</p><pre class="kj kk kl km gt lz ly ma mb aw mc bi"><span id="a0f6" class="md me it ly b gy mf mg l mh mi">'use strict';<br/>let x = 1;<br/>with (obj) {<br/>  x;<br/>}</span></pre><p id="c696" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">那么上面的代码就会有语法错误。</p><p id="692f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">严格模式阻止的另一件事是在<code class="fe lv lw lx ly b">eval</code>语句中声明变量。</p><p id="da47" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">例如，如果没有严格模式，<code class="fe lv lw lx ly b">eval('let x')</code>会在代码中声明变量<code class="fe lv lw lx ly b">x</code>。这让人们可以隐藏字符串中的变量声明，这些声明可能会覆盖<code class="fe lv lw lx ly b">eval</code>语句之外的相同变量声明。</p><p id="3dea" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">为了防止这种情况，严格模式不允许在我们传递给<code class="fe lv lw lx ly b">eval</code>语句的字符串参数中声明变量。</p><p id="5ee1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">严格模式还禁止删除普通变量名，因此下面将引发语法错误:</p><pre class="kj kk kl km gt lz ly ma mb aw mc bi"><span id="a468" class="md me it ly b gy mf mg l mh mi">'use strict';<br/><br/>let x;<br/>delete x;</span></pre></div><div class="ab cl mj mk hx ml" role="separator"><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo"/></div><div class="im in io ip iq"><h1 id="7266" class="mq me it bd mr ms mt mu mv mw mx my mz jz na ka nb kc nc kd nd kf ne kg nf ng bi translated">禁止无效语法</h1><p id="40dd" class="pw-post-body-paragraph kz la it lb b lc nh ju le lf ni jx lh li nj lk ll lm nk lo lp lq nl ls lt lu im bi translated">严格模式下不允许<code class="fe lv lw lx ly b">eval</code>和<code class="fe lv lw lx ly b">argument</code>的无效语法。</p><p id="7358" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这意味着对它们的任何操作都是不允许的，比如给它们赋值或者用它们作为变量、函数或者函数中参数的名字。</p><p id="6368" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">以下是不允许的<code class="fe lv lw lx ly b">eval</code>和<code class="fe lv lw lx ly b">argument</code>对象的无效使用示例:</p><pre class="kj kk kl km gt lz ly ma mb aw mc bi"><span id="a043" class="md me it ly b gy mf mg l mh mi">'use strict';<br/>eval = 1;<br/>arguments++;<br/>arguments--;<br/>++eval;<br/>eval--;<br/>let obj = { set p(arguments) { } };<br/>let eval;<br/>try { } catch (arguments) { }<br/>try { } catch (eval) { }<br/>function x(eval) { }<br/>function arguments() { }<br/>let y = function eval() { };<br/>let eval = ()=&gt;{ };<br/>let f = new Function('arguments', "'use strict'; return 1;");</span></pre><p id="5ad1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">严格模式不允许为<code class="fe lv lw lx ly b">arguments</code>对象创建别名并通过别名设置新值。</p><p id="5162" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在没有严格模式的情况下，如果函数的第一个参数是<code class="fe lv lw lx ly b">a</code>，那么设置<code class="fe lv lw lx ly b">a</code>也会设置<code class="fe lv lw lx ly b">arguments[0]</code>。在严格模式下，<code class="fe lv lw lx ly b">arguments</code>对象总是拥有调用函数的参数列表。</p><p id="4628" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">例如，如果我们有:</p><pre class="kj kk kl km gt lz ly ma mb aw mc bi"><span id="9ba9" class="md me it ly b gy mf mg l mh mi">const fn = function(a) {<br/>  'use strict';<br/>  a = 2;<br/>  return [a, arguments[0]];<br/>}</span><span id="9887" class="md me it ly b gy nn mg l mh mi">console.log(fn(1))</span></pre><p id="ad38" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">然后我们应该看到<code class="fe lv lw lx ly b">[2,1]</code>被记录。这是因为将<code class="fe lv lw lx ly b">a</code>设置为2并不会将<code class="fe lv lw lx ly b">arguments[0]</code>也设置为2。</p></div><div class="ab cl mj mk hx ml" role="separator"><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo"/></div><div class="im in io ip iq"><h1 id="61e7" class="mq me it bd mr ms mt mu mv mw mx my mz jz na ka nb kc nc kd nd kf ne kg nf ng bi translated">性能优化</h1><p id="2084" class="pw-post-body-paragraph kz la it lb b lc nh ju le lf ni jx lh li nj lk ll lm nk lo lp lq nl ls lt lu im bi translated">另外，不再支持<code class="fe lv lw lx ly b">arguments.callee</code>。如果没有严格模式，它所做的就是返回被调用的函数的名字，这个函数就是<code class="fe lv lw lx ly b">arguments.callee</code>所在的函数。</p><p id="f671" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">它阻止了像内联函数这样的优化，因为<code class="fe lv lw lx ly b">arguments.callee</code>要求如果访问<code class="fe lv lw lx ly b">arguments.callee</code>的话，对非内联函数的引用是可用的。所以在严格模式下，<code class="fe lv lw lx ly b">arguments.callee</code>现在抛出一个<code class="fe lv lw lx ly b">TypeError</code>。</p><p id="9dd5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">使用严格模式，<code class="fe lv lw lx ly b">this</code>将不会被强制始终作为一个对象。如果函数的<code class="fe lv lw lx ly b">this</code>与<code class="fe lv lw lx ly b">call</code>、<code class="fe lv lw lx ly b">apply</code>或<code class="fe lv lw lx ly b">bind</code>绑定到任何非对象类型，如<code class="fe lv lw lx ly b">undefined</code>、<code class="fe lv lw lx ly b">null</code>、<code class="fe lv lw lx ly b">number</code>、<code class="fe lv lw lx ly b">boolean</code>等原始类型，那么它们必须被强制成为对象。</p><p id="c977" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果<code class="fe lv lw lx ly b">this</code>的上下文切换到非对象类型，那么全局<code class="fe lv lw lx ly b">window</code>对象将取代它的位置。这意味着全局对象被暴露给被调用的函数，而<code class="fe lv lw lx ly b">this</code>被绑定到非对象类型。</p><p id="ab0f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">例如，如果我们运行以下代码:</p><pre class="kj kk kl km gt lz ly ma mb aw mc bi"><span id="0031" class="md me it ly b gy mf mg l mh mi">'use strict';</span><span id="536f" class="md me it ly b gy nn mg l mh mi">function fn() {<br/>  return this;<br/>}<br/>console.log(fn() === undefined);<br/>console.log(fn.call(2) === 2);<br/>console.log(fn.apply(null) === null);<br/>console.log(fn.call(undefined) === undefined);<br/>console.log(fn.bind(true)() === true);</span></pre><p id="f545" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">所有的控制台日志都将是<code class="fe lv lw lx ly b">true</code>，因为当<code class="fe lv lw lx ly b">this</code>被更改为非对象类型时，函数中的<code class="fe lv lw lx ly b">this</code>不会自动转换为<code class="fe lv lw lx ly b">window</code>全局对象。</p></div><div class="ab cl mj mk hx ml" role="separator"><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo"/></div><div class="im in io ip iq"><h1 id="586c" class="mq me it bd mr ms mt mu mv mw mx my mz jz na ka nb kc nc kd nd kf ne kg nf ng bi translated">安全修复</h1><p id="3a4b" class="pw-post-body-paragraph kz la it lb b lc nh ju le lf ni jx lh li nj lk ll lm nk lo lp lq nl ls lt lu im bi translated">在严格模式下，我们也不允许将函数的<code class="fe lv lw lx ly b">caller</code>和<code class="fe lv lw lx ly b">arguments</code>公开，因为<code class="fe lv lw lx ly b">caller</code>可能会公开调用该函数的<code class="fe lv lw lx ly b">caller</code>属性所访问的函数的函数。</p><p id="c28d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">调用函数时，<code class="fe lv lw lx ly b">arguments</code>有传入的参数。例如，如果我们有一个名为<code class="fe lv lw lx ly b">fn</code>的函数，那么通过<code class="fe lv lw lx ly b">fn.caller</code>，我们可以看到调用了<code class="fe lv lw lx ly b">fn</code>的函数，通过<code class="fe lv lw lx ly b">fn.arguments</code>，我们可以看到在调用<code class="fe lv lw lx ly b">fn</code>时传递给<code class="fe lv lw lx ly b">fn</code>的参数。</p><p id="5bf4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这是一个潜在的安全漏洞，可以通过禁止访问函数的这两个属性来消除。</p><pre class="kj kk kl km gt lz ly ma mb aw mc bi"><span id="6336" class="md me it ly b gy mf mg l mh mi">function secretFunction() {<br/>  'use strict';<br/>  secretFunction.caller;    <br/>  secretFunction.arguments;<br/>}<br/>function restrictedRunner() {<br/>  return secretFunction();<br/>}<br/>restrictedRunner();</span></pre><p id="3db1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在上面的例子中，我们不能用严格模式访问<code class="fe lv lw lx ly b">secretFunction.caller</code>和<code class="fe lv lw lx ly b">secretFunction.arguments</code>，因为人们可能会用它来获取函数的调用栈。如果我们运行该代码，将会抛出一个<code class="fe lv lw lx ly b">TypeError</code>。</p><p id="45da" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在JavaScript的未来版本中，将成为受限关键字的标识符将不允许用于变量或属性名等标识符。</p><p id="e40d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">以下关键字不允许用于在代码中定义我们的标识符。<code class="fe lv lw lx ly b">implements</code>、<code class="fe lv lw lx ly b">interface</code>、<code class="fe lv lw lx ly b">let</code>、<code class="fe lv lw lx ly b">package</code>、<code class="fe lv lw lx ly b">private</code>、<code class="fe lv lw lx ly b">protected</code>、<code class="fe lv lw lx ly b">public</code>、<code class="fe lv lw lx ly b">static</code>和<code class="fe lv lw lx ly b">yield</code>。</p><p id="1c51" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">对于ES2015或更高版本，这些已成为保留字，因此在没有严格模式的情况下，它们肯定不能用于命名变量和对象属性。</p><p id="6c09" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">几年来，严格模式一直是一个标准。浏览器对它的支持是常见的，只有像Internet Explorer这样的旧浏览器可能会有问题。</p><p id="1b2c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">其他浏览器在使用严格模式时应该不会有问题。因此，它应该用于防止错误和避免安全风险，如暴露调用堆栈或在<code class="fe lv lw lx ly b">eval</code>中声明新变量。</p><p id="70f4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">此外，它消除了静默错误，而是抛出它们，这样代码就不会在运行时出现错误。它还会指出妨碍JavaScript引擎进行优化的错误。</p><p id="ec7f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">此外，它还禁止可能在JavaScript的未来版本中定义的特性。</p></div></div>    
</body>
</html>