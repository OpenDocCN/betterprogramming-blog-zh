<html>
<head>
<title>How You Should Structure Your React Applications</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">应该如何构建React应用程序</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/how-you-should-structure-your-react-applications-e7dd32375a98?source=collection_archive---------1-----------------------#2020-09-08">https://betterprogramming.pub/how-you-should-structure-your-react-applications-e7dd32375a98?source=collection_archive---------1-----------------------#2020-09-08</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="a3c8" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">当然，这是个人喜好的问题，但这里有一种方法可以扩展</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/ffea3a00537dd7fc513e73274a8b30cb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*aGZNgDfcPEZo-TZN"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">由<a class="ae ky" href="https://unsplash.com/@netherlandz108?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">瑞安·巴伦</a>在<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片。</p></figure><p id="1127" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">有没有构建React项目的完美方法？官方文档帮不了你多少。React是一个库，而不是一个框架，这就是为什么它对你应该如何构建你的应用程序没有意见。</p><p id="9c2a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这很好，因为它给了我们自由来构建我们想要的应用程序。有经验的开发人员不会发现这样做的缺点，但是初级开发人员可能会发现很难找到构建整洁结构的方法。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="0c43" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">我的哲学</h1><p id="173d" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">每个项目都满足特定的需求，因此需要特定的结构和规则。构建应用程序的好方法有多少，坏方法就有多少。我将在本文中描述的方法可能不是您项目特定需求的完美答案。</p><p id="f2f5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">也就是说，我已经在不同规模的项目上与React合作了一段时间。我今天用的结构和几年前用的真的不一样。事实上，我一直在为自己创建的每个项目改进构建应用程序的方式。因为我对我最近使用的结构非常满意，所以我决定分享它。</p><p id="682a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">当然，你会发现下面的结构可能看起来太多了，这取决于你的需求(应用程序的大小，目标等等)。)，但是要明白，这是一种允许您的项目扩展的方法，从长远来看是值得的。</p><p id="9f56" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">除非你完全确定你要去哪里，否则我不会说你需要从第一天起就对你的应用应用一个严格的结构。代码总是可以在以后进行重构。那是选择的问题。</p><p id="f081" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我总是觉得重构非常令人满意，但同时，我也不喜欢一开始就在混乱的代码库中工作。</p><p id="3d6e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">因此，我试图尽快应用我的结构需求，因为我认为这对我的生产率有好处(显然，这不会阻止未来潜在的重构)。</p><p id="9e3a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们开始吧！</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi mz"><img src="../Images/08b77ed19c00b4d88d7a62c11a59376a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*JgbEkulngzKEwZII"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">照片由<a class="ae ky" href="https://unsplash.com/@dragos126?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Dragos Gontariu </a>在<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄。</p></figure></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="1faf" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">全球结构</h1><p id="fdc5" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">好吧！每个项目的根目录都是一样的，这一点没有太多争议，因为它只是关于配置的东西。所以我就直接去<code class="fe na nb nc nd b">./src</code>文件夹了，那里有乡亲们的意见和品味！</p><p id="9595" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">下面是我如何构建我的<code class="fe na nb nc nd b">./src</code>文件夹:</p><pre class="kj kk kl km gt ne nd nf ng aw nh bi"><span id="2ff1" class="ni md it nd b gy nj nk l nl nm">/src<br/>  │<br/>  ├── <strong class="nd iu">assets</strong><br/>  │   └── ...<br/>  │<br/>  ├── <strong class="nd iu">components</strong><br/>  │   └── ...<br/>  │<br/>  ├── <strong class="nd iu">containers</strong><br/>  │   └── ...<br/>  │<br/>  ├── <strong class="nd iu">core</strong><br/>  │   └── ...<br/>  │<br/>  ├── app.tsx<br/>  ├── index.tsx<br/>  └── router.tsx</span></pre><p id="f43c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这里发生了什么？</p><h2 id="dcf2" class="ni md it bd me nn no dn mi np nq dp mm li nr ns mo lm nt nu mq lq nv nw ms nx bi translated">为数不多的TSX档案</h2><p id="87a5" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">是的，我喜欢打字稿，你将在这篇文章中处理它。TSX是包含JSX代码的类型脚本文件的文件扩展名。</p><ul class=""><li id="f025" class="ny nz it lb b lc ld lf lg li oa lm ob lq oc lu od oe of og bi translated"><code class="fe na nb nc nd b">./index.tsx</code>:项目的切入点。这是我初始化我使用的库的地方，比如主题提供者(来自<a class="ae ky" href="https://styled-components.com/" rel="noopener ugc nofollow" target="_blank"> styled-components </a>)、商店(<a class="ae ky" href="https://redux.js.org/" rel="noopener ugc nofollow" target="_blank"> Redux </a>、<a class="ae ky" href="https://www.apollographql.com/docs/react/" rel="noopener ugc nofollow" target="_blank"> Apollo </a>，或者你选择的库)、路由器(<a class="ae ky" href="https://reactrouter.com/web/guides/quick-start" rel="noopener ugc nofollow" target="_blank"> React Router </a>)并且我显然还包括了我的<code class="fe na nb nc nd b">&lt;App /&gt;</code>组件。</li><li id="7583" class="ny nz it lb b lc oh lf oi li oj lm ok lq ol lu od oe of og bi translated"><code class="fe na nb nc nd b">./app.tsx</code>:包含<code class="fe na nb nc nd b">&lt;Router /&gt;</code>组件。这也是我实现我的特性(主要是容器，但我们将在后面了解)的地方，这些特性在整个应用程序中使用，比如模态系统、通知容器、服务人员等。</li><li id="f35a" class="ny nz it lb b lc oh lf oi li oj lm ok lq ol lu od oe of og bi translated"><code class="fe na nb nc nd b">./router.tsx</code>:由我项目的主要部件<code class="fe na nb nc nd b">&lt;Switch /&gt;</code>和<code class="fe na nb nc nd b">&lt;Route /&gt; </code>组成。如果我需要子路由，它们由使用它们的容器来处理。</li></ul></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h2 id="f2d2" class="ni md it bd me nn no dn mi np nq dp mm li nr ns mo lm nt nu mq lq nv nw ms nx bi translated">资产文件夹</h2><p id="7803" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">没什么大不了的。这个文件夹显然包含图像、图标、字体等等。</p><p id="42b5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">但是因为我不希望它变成一个巨大的垃圾桶，团队只是随着应用程序的增长随意扔东西，所以资产是按上下文排序的。</p><pre class="kj kk kl km gt ne nd nf ng aw nh bi"><span id="3474" class="ni md it nd b gy nj nk l nl nm">/<strong class="nd iu">assets</strong><br/>  │<br/>  ├── auth // ◀️ Assets specific to the auth container<br/>  │   ├── connected.mp3<br/>  │   └── background.png<br/>  │<br/>  ├── fonts<br/>  │   └── ...<br/>  │<br/>  ├── ionicon // ◀️ An icon Library<br/>  │   └── ...<br/>  │<br/>  ├── profile // ◀️ Assets specific to the profile container<br/>  │   └── background.png<br/>  │<br/>  ├── logo.svg<br/>  └── ...</span></pre><p id="dae9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">规则如下:如果资产仅在特定容器中使用，则它属于与该容器同名的文件夹。</p><p id="7897" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">例如，如果我的应用程序使用了一个徽标，它可能会在我的项目中的任何地方使用。由于这个原因，这个属于<code class="fe na nb nc nd b">./assets</code>文件夹的根目录。但是只在<code class="fe na nb nc nd b">Auth</code>容器中使用的背景图像属于<code class="fe na nb nc nd b">./auth</code>子文件夹。</p><p id="3dc7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我发现用这种方式浏览我的资产非常简单。</p><p id="c3eb" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这种方法还可以更容易地找到不再使用的资产。首先这应该不是问题，但是说实话:我们经常忘记清理这个文件夹。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h2 id="8672" class="ni md it bd me nn no dn mi np nq dp mm li nr ns mo lm nt nu mq lq nv nw ms nx bi translated">组件和容器文件夹</h2><p id="2467" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">您应该如何对组件进行分组？这里有很多不同的口味。<a class="ae ky" href="https://reactjs.org/docs/faq-structure.html" rel="noopener ugc nofollow" target="_blank"> React的文档</a>提出了两种解决方案:</p><ul class=""><li id="6b13" class="ny nz it lb b lc ld lf lg li oa lm ob lq oc lu od oe of og bi translated">按特征或路线对文件进行分组。</li><li id="71d7" class="ny nz it lb b lc oh lf oi li oj lm ok lq ol lu od oe of og bi translated">或者按类型(CSS、组件、测试等)对文件进行分组。).</li></ul><p id="f460" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果我正在做一个有大约100个组件的项目，第二个解决方案会让我发疯。</p><p id="a789" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我更喜欢使用第一种选择——或者至少是它的改进版本。</p><pre class="kj kk kl km gt ne nd nf ng aw nh bi"><span id="965f" class="ni md it nd b gy nj nk l nl nm">/src<br/>  │<br/>  ├── <strong class="nd iu">components</strong><br/>  │   └── ...<br/>  │<br/>  ├── <strong class="nd iu">containers</strong><br/>  │   └── ...<br/>  │<br/>  └── ... // ◀️ other folders we saw above</span></pre><p id="8bc2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们先处理组件文件夹。</p><p id="71dc" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">为了让React组件在<code class="fe na nb nc nd b">./components</code>文件夹中赢得一席之地，它必须遵守两条规则:</p><ul class=""><li id="8413" class="ny nz it lb b lc ld lf lg li oa lm ob lq oc lu od oe of og bi translated">它必须是一个<em class="om">表示组件</em>，这意味着它没有连接到应用程序的状态，当然也不会获取或发布数据。<br/>它可以与父容器交互(例如，通过触发Props中传递的函数)。我没意见，但仅此而已。</li><li id="a8b2" class="ny nz it lb b lc oh lf oi li oj lm ok lq ol lu od oe of og bi translated">它必须跨多个组件或容器使用。</li></ul><p id="7fe5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">组件使事情看起来很好，而容器使事情工作。</p><p id="ece5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">根据你的应用程序实现的功能，它可以是一个页面，也可以是页面的一个模块。我喜欢称它们为<em class="om">功能</em>。标题是一个特征。授权页面也是一个特性。他们完成特定的事情。</p><p id="a370" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">容器是有状态的，这意味着它们可以:</p><ul class=""><li id="6a62" class="ny nz it lb b lc ld lf lg li oa lm ob lq oc lu od oe of og bi translated">订阅商店。</li><li id="b5bb" class="ny nz it lb b lc oh lf oi li oj lm ok lq ol lu od oe of og bi translated">触发副作用，(与存储交互，获取或发布数据等。).</li><li id="e16e" class="ny nz it lb b lc oh lf oi li oj lm ok lq ol lu od oe of og bi translated">处理分析事件的分派。</li><li id="0cb1" class="ny nz it lb b lc oh lf oi li oj lm ok lq ol lu od oe of og bi translated">通过props向子组件提供状态、数据和动作。</li></ul><p id="6ae1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这在我的文件结构中清楚地表明了逻辑在哪里，表示部分在哪里。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h2 id="27b2" class="ni md it bd me nn no dn mi np nq dp mm li nr ns mo lm nt nu mq lq nv nw ms nx bi translated">核心文件夹——应用程序的核心</h2><p id="6263" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">我的核心文件夹也可以命名为<em class="om"> Commons </em>或<em class="om"> Shared </em>。它包含应用程序中使用的所有内容。</p><pre class="kj kk kl km gt ne nd nf ng aw nh bi"><span id="2c4f" class="ni md it nd b gy nj nk l nl nm">/<strong class="nd iu">core</strong><br/>  │<br/>  ├── <strong class="nd iu">models</strong><br/>  │   ├── notification.model.ts<br/>  │   ├── user.model.ts<br/>  │   └── ...<br/>  │<br/>  ├── <strong class="nd iu">services</strong><br/>  │   ├── notification.ts<br/>  │   ├── notification.test.ts<br/>  │   ├── user.ts<br/>  │   ├── user.test.ts<br/>  │   └── ...<br/>  │<br/>  ├── <strong class="nd iu">store</strong><br/>  │   ├── middlewares<br/>  │   │   └── ...<br/>  │   │<br/>  │   ├── auth<br/>  │   │   ├── actions.ts<br/>  │   │   ├── epics<br/>  │   │   │   ├── some-side-effect.ts<br/>  │   │   │   ├── fetch-stuff.ts<br/>  │   │   │   └── ...<br/>  │   │   │<br/>  │   │   ├── reducer.ts<br/>  │   │   └── selectors.ts<br/>  │   │<br/>  │   ├── index.ts<br/>  │   └── state.ts<br/>  │<br/>  └── <strong class="nd iu">theme</strong><br/>      ├── animations.ts<br/>      ├── global-state.ts<br/>      └── index.ts</span></pre><p id="57d8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">由于我在项目中使用TypeScript，这意味着我需要一个地方来存储我所有的类型和接口。</p><p id="5f5f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">每种数据类型都有一个文件(<code class="fe na nb nc nd b">User</code>、<code class="fe na nb nc nd b">Product</code>、<code class="fe na nb nc nd b">Notification</code>等)。).</p><p id="21e7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">容器的工作就是启用这个特性。为了让我的容器尽可能精简，服务处理会在组件中产生大量不必要噪音的业务逻辑。服务通常负责验证输入、记录错误、执行HTTP请求、操作数据等。</p><p id="9d12" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">应用程序中有多少服务就有多少服务，所以很容易找到我需要的东西。</p><p id="5a87" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">store文件夹包含商店配置及其中间件——没什么特别的。它还包含所有的缩减器、它们的动作、它们的史诗和它们的选择器。</p><p id="b279" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们应该把减速器放在哪里经常是一个争论。我们应该把它们放在主要使用它们的容器旁边，还是放在一个单独的目录中，和所有其他的reducers放在一起？</p><p id="3362" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">两种选择都可行。我更喜欢把它们放在<code class="fe na nb nc nd b">./core/store</code>文件夹中，因为状态经常被多个组件使用，动作也是如此。</p><p id="c699" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我正在使用Redux-Observable来处理我的应用程序的副作用。这相当于NgRx处理Angular副作用的方式，我发现它非常方便。这就是为什么你会看到一个史诗文件夹。因为它们可以被多个容器触发，所以我将它们放在存储中各自的文件夹中。</p><p id="9163" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">最后是<code class="fe na nb nc nd b">./theme</code>文件夹。像我们许多人一样，我使用流行的样式组件库来设计我的组件。主题文件夹是我放置项目的全局样式和CSS动画的地方。</p><p id="e16c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我还将我的项目的主题变量存储在<code class="fe na nb nc nd b">index.ts</code>文件中，如<a class="ae ky" href="https://styled-components.com/docs/advanced#function-themes" rel="noopener ugc nofollow" target="_blank">文档</a>中所述。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="b546" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated"><strong class="ak">组件文件夹的结构</strong></h1><p id="9da4" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">容器比表示组件负责更多的东西，但是我用同样的方式构造它们。因此，以下内容适用于容器和组件。以下是构建组件文件夹的方法:</p><pre class="kj kk kl km gt ne nd nf ng aw nh bi"><span id="d33f" class="ni md it nd b gy nj nk l nl nm">/my-component<br/>  │<br/>  ├── <strong class="nd iu">components</strong> // ◀️ Only for a Container!<br/>  │   ├── sub-componentA<br/>  │   │   ├── index.test.tsx<br/>  │   │   ├── index.tsx<br/>  │   │   └── styled.ts<br/>  │   │<br/>  │   └── sub-componentB<br/>  │       └── ...<br/>  │<br/>  ├── <strong class="nd iu">service</strong> // ◀️ Optional, mostly for Containers<br/>  │   ├── index.test.tsx<br/>  │   └── index.ts<br/>  │<br/>  ├── <strong class="nd iu">index.test.tsx</strong><br/>  ├── <strong class="nd iu">index.tsx</strong><br/>  └── <strong class="nd iu">styled.ts</strong></span></pre><h2 id="523a" class="ni md it bd me nn no dn mi np nq dp mm li nr ns mo lm nt nu mq lq nv nw ms nx bi translated"><strong class="ak">组件的根</strong></h2><ul class=""><li id="21dc" class="ny nz it lb b lc mu lf mv li on lm oo lq op lu od oe of og bi translated"><code class="fe na nb nc nd b">./index.tsx</code>:我的组件定义的地方。有些人喜欢用它导出的组件的名字来命名它。那是口味问题。这两种方法各有利弊。我不介意在我的项目中使用哪一个。</li><li id="4ed1" class="ny nz it lb b lc oh lf oi li oj lm ok lq ol lu od oe of og bi translated"><code class="fe na nb nc nd b">./styled.ts</code>:我的组件的设计所在的地方。<br/>在该文件中创建的所有组件遵循相同的惯例。它们被命名为<em class="om"> StyledXxx </em>，用法如下:<code class="fe na nb nc nd b">&lt;StyledXxx /&gt;</code>。由于一个组件可以使用许多子组件，这是一个简单的方法来确定一个组件是否只负责设计。</li><li id="2106" class="ny nz it lb b lc oh lf oi li oj lm ok lq ol lu od oe of og bi translated"><code class="fe na nb nc nd b">./index.test.tsx</code>:测试现场。</li></ul><h2 id="1fe3" class="ni md it bd me nn no dn mi np nq dp mm li nr ns mo lm nt nu mq lq nv nw ms nx bi translated"><strong class="ak">组件文件夹(仅用于容器)</strong></h2><p id="9e37" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">容器通常使用自己的表示组件。所谓“拥有”，我的意思是那些表示组件只在这个容器中使用。</p><p id="7665" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">因为我想把代码放在靠近使用它的地方，所以让这些组件存在于容器中是有意义的。</p><p id="6b1c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe na nb nc nd b">./components</code>子文件夹的深度为2，这使得容器易于浏览。更深的深度会不必要地增加复杂性。</p><p id="fae0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在上面的例子中，<code class="fe na nb nc nd b">&lt;SubComponentB /&gt;</code>可能是<code class="fe na nb nc nd b">&lt;SubComponentA /&gt;</code>的子节点，但这无关紧要。他们生活在同一水平。</p><h2 id="ad9d" class="ni md it bd me nn no dn mi np nq dp mm li nr ns mo lm nt nu mq lq nv nw ms nx bi translated"><strong class="ak">服务文件夹</strong></h2><p id="23d1" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">该服务帮助我从我的容器中外包特定的繁重业务逻辑。并非每个容器都需要自己的服务，因为“公共”逻辑可能已经存在于核心文件夹中，但有时可能需要它。</p><p id="43f3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们举一个例子:我有一个分析事件要分派，它以特定的方式需要十个字段(我发誓我遇到过这种情况)。这意味着它将在我的容器中增加十多行噪声。对于一个分析事件来说，这是一个很大的噪音，但是我希望商业智能团队高兴，所以我提供他们想要的东西！</p><p id="ffe4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">因为我想让我的容器尽可能精简，这样一看就能明白，所以我把这个逻辑放在组件旁边的服务文件中。这种方法也使得测试更加干净。</p><p id="9936" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">有些人可能会说，这实际上使理解正在发生的事情变得更加困难，因为他们需要打开服务来检查逻辑。我看不出这有什么问题。此外，由于我使用TypeScript，悬停该方法会告诉我我得到了什么。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="d84c" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">反应组分的结构</h1><p id="c98b" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">拥有一个好的文件结构是至关重要的，但是让我们也关注一下React组件本身，因为这是我们花费时间最多的地方。</p><p id="b3bc" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">以下是一些规则以及我如何构建我的React组件:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi oq"><img src="../Images/366e239f883c5079a5d3609812ed7c67.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*eW890WmLwVsJHzBeOf3PMA.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">一个<Profile/>容器示例</p></figure><h2 id="95e9" class="ni md it bd me nn no dn mi np nq dp mm li nr ns mo lm nt nu mq lq nv nw ms nx bi translated">命名您的组件</h2><p id="0b1b" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">该名称应该是唯一的，并且清楚地表明该组件实现了什么。</p><p id="b41c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">为什么给组件命名很重要？我喜欢直呼同事的名字——我的组件也是如此。</p><p id="9556" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">更严重的是，它有助于调试。下面是匿名组件的情况:</p><pre class="kj kk kl km gt ne nd nf ng aw nh bi"><span id="8ba8" class="ni md it nd b gy nj nk l nl nm">export <strong class="nd iu">default</strong> (props) =&gt; {<br/>  return &lt;p&gt;<strong class="nd iu">Don't do this</strong>&lt;/p&gt;;<br/>}</span></pre><p id="f994" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果你用React dev工具检查你的应用，一切都显示为<code class="fe na nb nc nd b">Anonymous</code>，这真的很令人沮丧。运行时错误也是如此…</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi or"><img src="../Images/e90131a1f792751b4d860d1a85f8ce82.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*dhe7kCdnfmdvd82KNqdt6g.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">用React开发工具调试匿名组件</p></figure><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi os"><img src="../Images/a26952398e45d225eb63b3d2de7e6b94.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*QCJKVciPIcG4ItsjpBAk2w.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">真的吗？谢谢，反应先生！</p></figure><p id="7b80" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">命名您的组件使您的生活更加轻松！</p><pre class="kj kk kl km gt ne nd nf ng aw nh bi"><span id="a9d3" class="ni md it nd b gy nj nk l nl nm">const <strong class="nd iu">Better</strong> = (props) =&gt; {<br/>  return &lt;p&gt;Do This instead&lt;/p&gt;<br/>}</span><span id="79c1" class="ni md it nd b gy ot nk l nl nm">export default <strong class="nd iu">Better</strong>;</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ou"><img src="../Images/4442bc7bb8ae27524dd979305e5cdaa4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*iiqqztQPOtzXKgaRjhCwfg.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">使用React开发工具调试命名组件</p></figure><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ov"><img src="../Images/1912ed9d4a03e8763d4dc7779e146b4e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*KdOnhozzHAJ5KxUgRHIBMw.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">知道去哪里更快！</p></figure><p id="5cbd" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在一个大项目中，你<em class="om">希望</em>你的组件有一个名字。</p><h2 id="87f5" class="ni md it bd me nn no dn mi np nq dp mm li nr ns mo lm nt nu mq lq nv nw ms nx bi translated">打字道具</h2><p id="c845" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">当我打开一个React组件时，我想看一看它收到了什么。这就是为什么我把Props接口放在文件的顶部，就在imports的下面。</p><p id="ba40" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">然后，我在函数的参数中析构props。由于VSCode只突出显示使用过的道具，这使得查看一个道具是否还在使用变得更加简单。这一切都是为了让我的组件尽可能的干净。</p><h2 id="33af" class="ni md it bd me nn no dn mi np nq dp mm li nr ns mo lm nt nu mq lq nv nw ms nx bi translated">钩子初始化</h2><p id="15b9" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">它们很吵，但是我们需要它们。它们位于组件的顶部，所以当我读取文件的其余部分时，它们不会打扰我。</p><p id="61cb" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这些规则很简单，容易遵循，不需要太多的工作，但是它们仍然让你的生活变得更轻松。</p><p id="6fe6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">请记住，上面的例子非常简单。组件通常比这个大，不容易阅读。</p><h2 id="d0cd" class="ni md it bd me nn no dn mi np nq dp mm li nr ns mo lm nt nu mq lq nv nw ms nx bi translated">应用状态和本地状态</h2><p id="ee01" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">这就是我的目光停留的地方——就在道具界面之后。它们位于钩子的正下方，因为它们代表了最有价值的信息:我的容器从存储中接收了什么数据，以及它在本地管理什么状态。</p><h2 id="8bef" class="ni md it bd me nn no dn mi np nq dp mm li nr ns mo lm nt nu mq lq nv nw ms nx bi translated">效果</h2><p id="e363" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">我知道我的组件是由什么组成的。效果告诉我它的行为。按照重要性的顺序，这就是我希望在组件状态下面看到的内容。</p><h2 id="f4ac" class="ni md it bd me nn no dn mi np nq dp mm li nr ns mo lm nt nu mq lq nv nw ms nx bi translated">功能</h2><p id="6505" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">最后，业务逻辑。我有理解逻辑所需的所有信息。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="f7b8" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">结论</h1><p id="3b53" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">下面是我在这篇文章中经历的完整结构。</p><p id="01da" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">正如我前面提到的，您可能不需要在应用程序中实现完整的结构，因为每个应用程序都有自己的需求。如果你的app特别小，五个组件一个容器，显然太多了。</p><p id="c8b5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这是我构建React应用的方法。这是一种可扩展的方法，效果很好，允许我快速工作，而不会随着应用程序的增长而影响代码库的质量。</p><p id="f78f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">有许多其他的方法来构建你的应用程序，我想说的是，除了你做出的结构选择，最重要的考虑是在整个项目中保持一致。</p><pre class="kj kk kl km gt ne nd nf ng aw nh bi"><span id="f018" class="ni md it nd b gy nj nk l nl nm">/src<br/>  │<br/>  ├── <strong class="nd iu">assets<br/>  </strong>│   ├── auth<br/>  │   │   │<br/>  │   │   ├── connected.mp3<br/>  │   │   └── background.png<br/>  │   │<br/>  │   ├── fonts<br/>  │   │   └── ...<br/>  │   │<br/>  │   ├── ionicon<br/>  │   │   └── ...<br/>  │   │<br/>  │   ├── profile<br/>  │   │   └── background.png<br/>  │   │<br/>  │   ├── logo.svg<br/>  │   └── ...<br/>  │<br/>  ├── <strong class="nd iu">components</strong><br/>  │   ├── <strong class="nd iu">componentA</strong><br/>  │   │   ├── service<br/>  │   │   │   ├── index.test.tsx<br/>  │   │   │   └── index.ts<br/>  │   │   │   <br/>  │   │   ├── index.test.tsx<br/>  │   │   ├── index.tsx<br/>  │   │   └── styled.ts<br/>  │   └── ...<br/>  │   <br/>  ├── <strong class="nd iu">containers</strong><br/>  │   ├── <strong class="nd iu">containerA</strong><br/>  │   │   ├── <strong class="nd iu">components</strong><br/>  │   │   │   ├── sub-componentA<br/>  │   │   │   │   ├── index.test.tsx<br/>  │   │   │   │   ├── index.tsx<br/>  │   │   │   │   └── styled.ts<br/>  │   │   │   │<br/>  │   │   │   └── sub-componentB<br/>  │   │   │       └── ...<br/>  │   │   │<br/>  │   │   ├── <strong class="nd iu">service</strong><br/>  │   │   │   ├── index.test.tsx<br/>  │   │   │   └── index.ts<br/>  │   │   │   <br/>  │   │   ├── index.test.tsx<br/>  │   │   ├── index.tsx<br/>  │   │   └── styled.ts<br/>  │   │<br/>  │   └── ...<br/>  │<br/>  ├── <strong class="nd iu">core</strong><br/>  │   ├── <strong class="nd iu">models</strong><br/>  │   │   ├── notification.model.ts<br/>  │   │   ├── user.model.ts<br/>  │   │   └── ...<br/>  │   │<br/>  │   ├── <strong class="nd iu">services</strong><br/>  │   │   ├── notification.ts<br/>  │   │   ├── notification.test.ts<br/>  │   │   ├── user.ts<br/>  │   │   ├── user.test.ts<br/>  │   │   └── ...<br/>  │   │   <br/>  │   ├── <strong class="nd iu">store</strong><br/>  │   │   ├── middlewares<br/>  │   │   │   └── ...<br/>  │   │   │   <br/>  │   │   ├── auth<br/>  │   │   │   ├── actions.ts<br/>  │   │   │   ├── epics<br/>  │   │   │   │   ├── some-side-effect.ts<br/>  │   │   │   │   ├── fetch-stuff.ts<br/>  │   │   │   │   └── ...<br/>  │   │   │   │<br/>  │   │   │   ├── reducer.ts<br/>  │   │   │   └── selectors.ts<br/>  │   │   │   <br/>  │   │   ├── index.ts<br/>  │   │   └── state.ts<br/>  │   │<br/>  │   └── <strong class="nd iu">theme</strong><br/>  │       ├── animations.ts<br/>  │       ├── global-state.ts<br/>  │       └── index.ts<br/>  │<br/>  ├── <strong class="nd iu">app</strong>.tsx<br/>  ├── <strong class="nd iu">index</strong>.tsx<br/>  └── <strong class="nd iu">router</strong>.tsx</span></pre><p id="ce03" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">感谢阅读！</p></div></div>    
</body>
</html>