# 应用这 4 种技术来编写简洁的 Python 代码

> 原文：<https://betterprogramming.pub/apply-these-4-techniques-to-write-concise-python-code-9298458fbb2e>

## 用 Python 的方式编写 Python 代码

![](img/721f1b5df4eddf8f5a144fea2992a79f.png)

照片由[在](https://unsplash.com/@jannerboy62?utm_source=medium&utm_medium=referral)[的缺口处](https://unsplash.com?utm_source=medium&utm_medium=referral)拍摄。

任何编程项目的一个重要目标都与可维护性有关。无论项目的规模有多大，您总是希望有一个可维护的代码库，以便在项目的长期维护阶段不会浪费您或您的团队成员的时间。因此，当我们在项目中工作时，我们必须牢记可维护性。

提高项目可维护性的一个重要方法是编写简洁的代码——有几个原因。第一，一般来说，简洁的代码可读性更强，更容易让你的队友理解。第二，简洁的代码意味着代码更少，更不容易出现 bug。

在本文中，我想分享一些 Python 特性，这些特性允许您编写更简洁的 Python 代码。

# 1.在 for 循环中使用枚举

我们使用`for`循环来避免为相同的工作编写重复的代码。在许多情况下，我们希望记录 iterable 中项的位置。下面向您展示了 wordy 版本的两种可能的实现:

无需列举

*   第一个`for`循环涉及到使用`index()`方法来定位项目的位置，这可以通过访问列表来直接检索。
*   第二个`for`循环涉及到使用`range()`函数来创建一个 iterable，该 iterable 产生项目的索引。我们用这个来找回物品。

在这两个版本中，我们必须分别获取条目和索引。然而，这两条信息可以一起生成。以下代码向您展示了一个更简洁的实现:

带枚举

*   `enumerate()`将 list 作为它的第一个参数，这将产生一个迭代器，每个条目作为一个 tuple 对象。
*   元组对象由两项组成:计数器(或“索引”)和项。在示例中，我们使用解包来直接访问这两个项目。
*   计数器从哪个数字开始由`enumerate()`函数的第二个参数决定。在示例中，我们将值设置为`1`，这意味着我们希望从`1`开始计数。

# 2.检查容器是否空

在 Python 中，我们经常将元组、列表、字典和集合称为数据容器，因为所有这些数据类型都可以将其他对象作为它们的项目。值得注意的是，所有这些容器都允许有零个项目。因此，当我们处理这些数据容器时，我们经常需要在进行任何操作之前检查它们是否有任何条目。

让我们以列表对象为例，但同样的原则也适用于其他数据类型。

以下代码向您展示了 wordy 版本的可能实现:

检查空性(罗嗦)

*   第一个例子使用了`len()`函数，它检查列表中的项目数量。当它的长度大于`0`时，这意味着列表不是空的。
*   第二个示例将获取的列表对象与一个空列表进行比较。因为如果获取的列表不等于空列表，列表对象就按值进行比较，所以它不是空的。

以下代码片段向您展示了一个更简洁的版本:

止空(简洁)

上面的代码利用了 Python 将空列表评估为`False`，将非空列表评估为`True`的事实。更广泛地说，这种评估也适用于其他容器，包括元组、字典和集合。作为一个旁注，这也适用于字符串的求值，当它们不是空字符串时是真的。

# 3.使用命名元组作为数据容器

如果您的项目涉及读取数据，并且这些数据具有相同的结构，您可以考虑使用数据容器来帮助您访问数据的单个元素。假设一个数据单元包含客户的三条信息:姓名、年龄和性别。下面向您展示了一个冗长版本的一些可能的实现:

数据容器(冗长)

*   我们可以用字典来代表每个客户。然而，我们可能会拼错一些键，导致`KeyError`异常。
*   我们还可以创建一个自定义类来管理客户端信息。但是，正确维护一个类对象和单个对象的内存消耗需要额外的开销。

如果我们只需要一个数据容器来保存数据，并且大部分操作都是读取数据，那么我们可以考虑使用命名元组作为轻量级的数据容器。下面的代码向您展示了这样一个实现:

命名元组(简明)

*   `namedtuple`是在`collections`模块中可用的工厂功能。之所以称之为工厂函数，是因为该函数创建了一种新的数据类型，它是元组的子类型，如下所示:

```
>>> type(Client)
<class 'type'>
>>> issubclass(Client, tuple)
True
```

*   在`namedtuple`函数中，我们将类名作为第一个参数传递，将属性(由空格分隔的字符串或字符串列表)作为第二个参数传递。
*   当我们创建`Client`类的实例时，我们可以使用与常规定制类相同的实例化方法。
*   更重要的是，我们可以使用相同的点符号来访问元组对象的“属性”，就像自定义类对象一样，如下所示:

```
>>> client0 = Client("John", 37, "M")
>>> client0.name
'John'
>>> client0.age
37
>>> client0.gender
'M'
```

# 4.使用部分功能

为了避免代码重复，我们重构了函数。考虑在更大的范围内，我们有以下效用函数及其用法:

效用函数(可能很罗嗦)

*   我们在各种模块中使用`save_image_to_directory`实用函数。
*   当我们处理`Event 0`时，我们向函数传递三个参数。值得注意的是，第三个参数在模块范围内总是相同的。
*   当我们处理另一个事件时，同样的场景通过为每个调用重复第三个参数而发生。

在这种使用场景下，我们应该考虑使用部分函数。具体来说，如果在合理的范围内(例如一个模块)使用一个特定的函数，并且在每个函数调用中都应用了相同的参数，那么部分函数可能会有所帮助。实质上，部分函数是通过将部分参数应用于现有函数而创建的。以下代码向您展示了这种用法:

部分功能(简明)

*   `partial`功能在`functools`模块中可用。该函数采用现有函数，并为每个模块应用共享参数。在这种情况下，它是`desired_directory`参数。
*   `partial`函数创建另一个函数。调用它消除了传递共享参数的需要。如您所见，从现在开始，我们只需要为分部函数设置两个参数。

顺便提一下，我们可以利用 lambda 函数创建一个分部函数，如下所示。但是我不推荐这种方法，因为它没有使用部分函数来表示我们正在创建部分函数那么明确。

```
save_image_for_event2 = lambda x, y: save_image_to_directory(x, y, desired_directory='folder_for_event2')
save_image_for_event2("image_data2_101", "event2_101.png")
```

lambda 函数的检查也有问题，因为它没有给出有用的信息，不像使用`partial`创建的分部函数。考虑以下差异:

```
>>> save_image_for_event1
functools.partial(<function save_image_to_directory at 0x111bf68b0>, desired_directory='folder_for_event1')
>>> save_image_for_event2
<function <lambda> at 0x111bf6940>
```

# 结论

在本文中，我们回顾了可以帮助您编写更简洁的 Python 代码的四个特性。通过应用这些技术和许多其他 Pythonic 方法，您可以提高项目的整体可维护性。

下面是这篇文章的摘要:

*   使用`enumerate()`函数为`for`循环中的可重复项创建计数器。
*   理解 Python 将空容器评估为 Falsy，这样我们就不需要将它们与另一个值进行比较。
*   命名元组是一种易于实现且灵活的只读数据容器。
*   使用部分函数可以消除在特定范围内重复共享参数的需要。