<html>
<head>
<title>How To Build a Website Using Rust, gRPC-Web, React</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何用Rust，gRPC-Web，React建立网站</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/building-a-website-using-rust-grpc-web-react-7412f1596a17?source=collection_archive---------0-----------------------#2022-10-22">https://betterprogramming.pub/building-a-website-using-rust-grpc-web-react-7412f1596a17?source=collection_archive---------0-----------------------#2022-10-22</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="10f4" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">创建自己的互联网家园指南</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/199d40aa6d1e8d62ffa6cce3dfea0cfc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*ThSirzaZa8PXa3md"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">在<a class="ae kv" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上由<a class="ae kv" href="https://unsplash.com/@kmuza?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Carlos Muza </a>拍摄的照片</p></figure><p id="dc4c" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这就是我如何使用一个<a class="ae kv" href="https://github.com/grpc/grpc-web" rel="noopener ugc nofollow" target="_blank"> grpc-web </a>接口实现一个服务于我个人网站的小型客户端-服务器应用程序，以及我在做这件事时学到的东西。客户端提供一个静态页面，并通过gRPC接收内容。内容的结构类似于<a class="ae kv" href="https://editorjs.io/" rel="noopener ugc nofollow" target="_blank"> Editor.js </a>。</p><p id="6ca0" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">对于服务器，我使用Rust和<a class="ae kv" href="https://github.com/hyperium/tonic" rel="noopener ugc nofollow" target="_blank"> Tonic </a>框架。由于gRPC是基于<a class="ae kv" href="https://en.wikipedia.org/wiki/HTTP/2" rel="noopener ugc nofollow" target="_blank"> http/2 </a>的，因此<a class="ae kv" href="https://www.envoyproxy.io/" rel="noopener ugc nofollow" target="_blank"> Envoy代理</a>通常用于将<a class="ae kv" href="https://en.wikipedia.org/wiki/Hypertext_Transfer_Protocol" rel="noopener ugc nofollow" target="_blank"> http/1.1 </a>转换为<a class="ae kv" href="https://en.wikipedia.org/wiki/HTTP/2" rel="noopener ugc nofollow" target="_blank"> http/2。</a>对于这个应用程序，我走了一条不同的路，使用了<a class="ae kv" href="https://github.com/hyperium/tonic/tree/master/tonic-web" rel="noopener ugc nofollow" target="_blank"> Tonic-web </a>机箱。</p><p id="ede7" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">对于客户，我使用<a class="ae kv" href="https://reactjs.org/" rel="noopener ugc nofollow" target="_blank">反应</a>并通过<a class="ae kv" href="https://expressjs.com/" rel="noopener ugc nofollow" target="_blank">快递</a>服务。</p><h1 id="c403" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">计算机网络服务器</h1><h2 id="6e89" class="mk lt iq bd lu ml mm dn ly mn mo dp mc lf mp mq me lj mr ms mg ln mt mu mi mv bi translated">设置环境</h2><p id="2f87" class="pw-post-body-paragraph kw kx iq ky b kz mw jr lb lc mx ju le lf my lh li lj mz ll lm ln na lp lq lr ij bi translated">要构建这个应用，我们需要安装<a class="ae kv" href="https://www.rust-lang.org/" rel="noopener ugc nofollow" target="_blank"> Rust </a>和<a class="ae kv" href="https://grpc.io/" rel="noopener ugc nofollow" target="_blank">协议缓冲编译器</a>(protoco)。</p><ul class=""><li id="d028" class="nb nc iq ky b kz la lc ld lf nd lj ne ln nf lr ng nh ni nj bi translated">安装铁锈:<a class="ae kv" href="https://www.rust-lang.org/tools/install" rel="noopener ugc nofollow" target="_blank">https://www.rust-lang.org/tools/install</a></li><li id="d7d6" class="nb nc iq ky b kz nk lc nl lf nm lj nn ln no lr ng nh ni nj bi translated">在Linux和macOS上安装协议缓冲编译器:<a class="ae kv" href="https://grpc.io/docs/protoc-installation/" rel="noopener ugc nofollow" target="_blank">https://grpc.io/docs/protoc-installation/</a>要在Windows上安装，需要从<a class="ae kv" href="https://github.com/protocolbuffers/protobuf/releases" rel="noopener ugc nofollow" target="_blank">https://github.com/protocolbuffers/protobuf/releases</a>下载二进制。将它提取到类似于<code class="fe np nq nr ns b">C:\\Program Files\\protoc</code>的地方，并将<code class="fe np nq nr ns b">C:\\Program Files\\protoc\\bin</code>添加到您的<a class="ae kv" href="https://www.architectryan.com/2018/03/17/add-to-the-path-on-windows-10/" rel="noopener ugc nofollow" target="_blank">路径</a>中。</li></ul><h2 id="24e4" class="mk lt iq bd lu ml mm dn ly mn mo dp mc lf mp mq me lj mr ms mg ln mt mu mi mv bi translated">安装包</h2><p id="8da3" class="pw-post-body-paragraph kw kx iq ky b kz mw jr lb lc mx ju le lf my lh li lj mz ll lm ln na lp lq lr ij bi translated">设置好我们的开发环境后，我们可以开始我们的项目了。让我们首先使用以下命令启动一个新的项目目录:</p><pre class="kg kh ki kj gt nt ns nu nv aw nw bi"><span id="352a" class="mk lt iq ns b gy nx ny l nz oa">mkdir grpc_app<br/>cd grpc_app</span></pre><p id="ec3d" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">使用Rust包管理器，我们现在可以创建一个包。</p><pre class="kg kh ki kj gt nt ns nu nv aw nw bi"><span id="40a7" class="mk lt iq ns b gy nx ny l nz oa">cargo new server<br/>cd server</span></pre><p id="20f1" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">对于应用程序界面，我们需要以下内容:</p><ul class=""><li id="519b" class="nb nc iq ky b kz la lc ld lf nd lj ne ln nf lr ng nh ni nj bi translated"><a class="ae kv" href="https://github.com/hyperium/tonic/tree/master/tonic-build" rel="noopener ugc nofollow" target="_blank"> Tonic-build </a>(作为构建依赖)，<a class="ae kv" href="https://github.com/tokio-rs/prost" rel="noopener ugc nofollow" target="_blank"> Prost </a>，<a class="ae kv" href="https://github.com/tokio-rs/prost/tree/master/prost-types" rel="noopener ugc nofollow" target="_blank"> Prost-types </a>装箱以从<a class="ae kv" href="https://developers.google.com/protocol-buffers/docs/proto3" rel="noopener ugc nofollow" target="_blank"> proto3 </a>文件生成Rust代码</li><li id="a57d" class="nb nc iq ky b kz nk lc nl lf nm lj nn ln no lr ng nh ni nj bi translated">托基奥机箱异步运行服务器</li></ul><p id="c00f" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><a class="ae kv" href="https://github.com/uuid-rs/uuid" rel="noopener ugc nofollow" target="_blank"> UUID </a>机箱用于创建<a class="ae kv" href="https://en.wikipedia.org/wiki/Universally_unique_identifier#Version_4_(random)" rel="noopener ugc nofollow" target="_blank">uuid v4</a>。这只是应用程序内容所需要的，而不是接口的一般实现。</p><p id="a72a" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">让我们将它们添加到我们的服务器应用程序中，如下所示:</p><pre class="kg kh ki kj gt nt ns nu nv aw nw bi"><span id="629a" class="mk lt iq ns b gy nx ny l nz oa">cargo add tonic@0.8 tonic-web@0.4<br/>cargo add prost@0.11 prost-types@0.11<br/>cargo add --features tokio@1.0/macros,tokio@1.0/rt-multi-thread tokio@1.0<br/>cargo add --features uuid@1.2/v4 uuid@1.2<br/>cargo add --build tonic-build@0.8</span></pre><p id="c866" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这应该会导致一个<code class="fe np nq nr ns b">Cargo.toml</code>，就像这样:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ob oc l"/></div></figure><h2 id="36ed" class="mk lt iq bd lu ml mm dn ly mn mo dp mc lf mp mq me lj mr ms mg ln mt mu mi mv bi translated">创建协议缓冲区定义</h2><p id="0d3e" class="pw-post-body-paragraph kw kx iq ky b kz mw jr lb lc mx ju le lf my lh li lj mz ll lm ln na lp lq lr ij bi translated">如上所述，我们想要基于<a class="ae kv" href="https://editorjs.io/" rel="noopener ugc nofollow" target="_blank"> Editor.js </a>规范创建我们的界面。我们将实现块类型<code class="fe np nq nr ns b">Paragraph</code>、<code class="fe np nq nr ns b">Header</code>和<code class="fe np nq nr ns b">List</code>。</p><p id="21e0" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">让我们首先在proto目录中创建新文件:</p><pre class="kg kh ki kj gt nt ns nu nv aw nw bi"><span id="b729" class="mk lt iq ns b gy nx ny l nz oa">mkdir proto<br/>cd proto<br/>touch page.proto</span></pre><p id="ee15" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">首先，我们需要定义语法并给语法命名:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ob oc l"/></div></figure><p id="9b81" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">接下来，我们定义我们的服务。该服务只包含一个调用，接收并返回一条消息。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ob oc l"/></div></figure><p id="c176" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们需要落实这两条信息。<code class="fe np nq nr ns b">PageRequest</code>只是一个字符串，但是<code class="fe np nq nr ns b">PageReply</code>将是我们结构化的<a class="ae kv" href="https://editorjs.io/" rel="noopener ugc nofollow" target="_blank"> Editor.js </a>式的响应。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ob oc l"/></div></figure><p id="3360" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">由于<code class="fe np nq nr ns b">PageReply</code>有时间戳，我们需要导入或创建一个额外的类型。我们将从Google的<a class="ae kv" href="https://developers.google.com/protocol-buffers/docs/reference/csharp/namespace/google/protobuf/well-known-types" rel="noopener ugc nofollow" target="_blank">知名类型</a>中导入一个。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ob oc l"/></div></figure><p id="2d2f" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">然后我们定义我们的<code class="fe np nq nr ns b">PageReply</code>。为了创建一个列表，我们使用了特性<code class="fe np nq nr ns b">repeated</code>。该块可以是段落、标题和列表中的一个。为此，我们使用功能<code class="fe np nq nr ns b">oneof</code>。一个<code class="fe np nq nr ns b">oneof</code>不能是<code class="fe np nq nr ns b">repeated</code>。所以我们需要创建一个名为<code class="fe np nq nr ns b">Block</code>的中间消息。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ob oc l"/></div></figure><p id="a5c1" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">现在我们可以实现不同的块类型。对于<code class="fe np nq nr ns b">ListBlock</code>,我们需要一个样式字段的约束。这可以通过<code class="fe np nq nr ns b">enum</code>来实现。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ob oc l"/></div></figure><p id="5fc4" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">完整的代码可以在<a class="ae kv" href="https://github.com/christopherscholz/rust_grpc_website/blob/main/server/proto/page.proto" rel="noopener ugc nofollow" target="_blank">这里</a>找到。</p><h2 id="7c76" class="mk lt iq bd lu ml mm dn ly mn mo dp mc lf mp mq me lj mr ms mg ln mt mu mi mv bi translated">生成原型存根</h2><p id="ff7e" class="pw-post-body-paragraph kw kx iq ky b kz mw jr lb lc mx ju le lf my lh li lj mz ll lm ln na lp lq lr ij bi translated">为了生成proto存根，我们需要在应用程序的主目录中添加一个<a class="ae kv" href="https://doc.rust-lang.org/cargo/reference/build-scripts.html" rel="noopener ugc nofollow" target="_blank">构建脚本</a> ( <code class="fe np nq nr ns b">build.rs</code>)。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ob oc l"/></div></figure><h2 id="6bb2" class="mk lt iq bd lu ml mm dn ly mn mo dp mc lf mp mq me lj mr ms mg ln mt mu mi mv bi translated">实施服务</h2><p id="603b" class="pw-post-body-paragraph kw kx iq ky b kz mw jr lb lc mx ju le lf my lh li lj mz ll lm ln na lp lq lr ij bi translated">为了编写我们的应用程序，我们编辑了由<code class="fe np nq nr ns b">cargo new server</code>创建的<code class="fe np nq nr ns b">src/main.rs</code>文件。</p><p id="7dfa" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">首先，我们将声明一些模块的使用，并发布生成的原型页面存根。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ob oc l"/></div></figure><p id="bbec" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">接下来，我们声明结构并定义页面实现。我们稍后会谈到逻辑。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ob oc l"/></div></figure><p id="67d6" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">要运行我们的应用程序，我们必须添加我们的主函数。我们使用<code class="fe np nq nr ns b">tokio::main</code>宏来帮助我们。在这里，我们还使用<code class="fe np nq nr ns b">tonic_web</code> crate来提供我们在http/1.1上的服务，并定义了<a class="ae kv" href="https://developer.mozilla.org/en-US/docs/Web/HTTP/CORS" rel="noopener ugc nofollow" target="_blank"> CORS </a>头。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ob oc l"/></div></figure><p id="89c5" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们应用的逻辑是基于输入的。我们需要在我们的<code class="fe np nq nr ns b">get_page</code>函数中定义三种情况，如下所示:</p><ul class=""><li id="b244" class="nb nc iq ky b kz la lc ld lf nd lj ne ln nf lr ng nh ni nj bi translated">家</li><li id="16a9" class="nb nc iq ky b kz nk lc nl lf nm lj nn ln no lr ng nh ni nj bi translated">出版说明</li><li id="4188" class="nb nc iq ky b kz nk lc nl lf nm lj nn ln no lr ng nh ni nj bi translated">默认情况</li></ul><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ob oc l"/></div></figure><p id="c321" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">然后，通过创建我们的模块来构建每个匹配臂，例如，如下所示:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ob oc l"/></div></figure><p id="e0de" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">完整的代码可以在<a class="ae kv" href="https://github.com/christopherscholz/rust_grpc_website/blob/main/server/src/main.rs" rel="noopener ugc nofollow" target="_blank">这里</a>找到。</p><h2 id="f60b" class="mk lt iq bd lu ml mm dn ly mn mo dp mc lf mp mq me lj mr ms mg ln mt mu mi mv bi translated">运行服务</h2><p id="8ddb" class="pw-post-body-paragraph kw kx iq ky b kz mw jr lb lc mx ju le lf my lh li lj mz ll lm ln na lp lq lr ij bi translated">我们现在可以使用以下命令运行应用程序:</p><pre class="kg kh ki kj gt nt ns nu nv aw nw bi"><span id="69cd" class="mk lt iq ns b gy nx ny l nz oa">cargo run</span></pre><p id="1fd8" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">因为我们还没有实现客户端，所以我们通过<a class="ae kv" href="https://github.com/bloomrpc/bloomrpc" rel="noopener ugc nofollow" target="_blank"> BloomRPC </a>测试我们的服务器。为此，我们可以导入我们的page.proto，然后将我们的服务器设置为<code class="fe np nq nr ns b">127.0.01:8000</code>并从gRPC切换到web。点击绿色播放按钮将得到我们的回应。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi od"><img src="../Images/c288206eb5f0a3e668debcdb76abb9bb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*trvnjiRoEr7bPNzw81I8sw.png"/></div></div></figure><h2 id="628d" class="mk lt iq bd lu ml mm dn ly mn mo dp mc lf mp mq me lj mr ms mg ln mt mu mi mv bi translated">归档</h2><p id="ab68" class="pw-post-body-paragraph kw kx iq ky b kz mw jr lb lc mx ju le lf my lh li lj mz ll lm ln na lp lq lr ij bi translated">每一个好的app都需要dockerized。我们首先构建它，然后将二进制文件复制到一个发行版映像。</p><p id="5874" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">让我们创建我们的<code class="fe np nq nr ns b">Dockerfile</code></p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ob oc l"/></div></figure><p id="04af" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">因为我们稍后还将为我们的客户创建一个docker映像，所以让我们在项目主目录中设置一个<code class="fe np nq nr ns b">docker-compose.json</code>。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ob oc l"/></div></figure><p id="8296" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">然后，我们可以通过BloomRPC运行Docker映像并再次测试。</p><pre class="kg kh ki kj gt nt ns nu nv aw nw bi"><span id="c5d7" class="mk lt iq ns b gy nx ny l nz oa">docker-compose up --build</span></pre><h1 id="5ba8" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">客户</h1><h2 id="2832" class="mk lt iq bd lu ml mm dn ly mn mo dp mc lf mp mq me lj mr ms mg ln mt mu mi mv bi translated">设置环境</h2><p id="6126" class="pw-post-body-paragraph kw kx iq ky b kz mw jr lb lc mx ju le lf my lh li lj mz ll lm ln na lp lq lr ij bi translated">安装<a class="ae kv" href="https://nodejs.org/en/" rel="noopener ugc nofollow" target="_blank">节点</a>。</p><p id="ec93" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">除了我们为服务器安装的协议缓冲编译器，我们还需要两个插件来生成JavaScript proto存根。可惜protobuf-javascript的JavaScript实现维护的不是很好。在写这篇文章的时候，发布的二进制文件还没有工作，所以我们需要从源代码编译它。</p><p id="3080" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">首先，我们从<a class="ae kv" href="https://github.com/grpc/grpc-web/releases/tag/1.4.1" rel="noopener ugc nofollow" target="_blank">https://github.com/grpc/grpc-web/releases/tag/1.4.1</a>下载protocol-gen-grpc-web二进制文件，并把它放在我们的protocol二进制文件旁边。确保将二进制文件重命名为<code class="fe np nq nr ns b"><a class="ae kv" href="https://github.com/grpc/grpc-web/releases/download/1.4.1/protoc-gen-grpc-web-1.4.1-darwin-aarch64" rel="noopener ugc nofollow" target="_blank">protoc-gen-grpc-web</a></code>。</p><p id="2c7e" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">其次，克隆protobuf-javascript存储库，并将其重置为指定的提交。</p><pre class="kg kh ki kj gt nt ns nu nv aw nw bi"><span id="f6c0" class="mk lt iq ns b gy nx ny l nz oa">git clone &lt;https://github.com/protocolbuffers/protobuf-javascript&gt; /home/protobuf-javascript<br/>git reset --hard 3ff6090f139d71453062fb96c66e9aff801709c2</span></pre><p id="921e" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们需要安装巴泽尔:<a class="ae kv" href="https://docs.bazel.build/versions/main/install.html" rel="noopener ugc nofollow" target="_blank">https://docs.bazel.build/versions/main/install.html</a></p><p id="8a9b" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">然后我们可以加载依赖项并构建二进制文件</p><pre class="kg kh ki kj gt nt ns nu nv aw nw bi"><span id="4f66" class="mk lt iq ns b gy nx ny l nz oa">cd protobuf-javascript<br/>npm install<br/>npm run build</span></pre><p id="0a13" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">最后一件事是将<code class="fe np nq nr ns b">bazel-bin/generator/protoc-gen-js</code>复制到与protoc二进制文件相同的路径。</p><h2 id="76dd" class="mk lt iq bd lu ml mm dn ly mn mo dp mc lf mp mq me lj mr ms mg ln mt mu mi mv bi translated">安装包</h2><p id="a6fe" class="pw-post-body-paragraph kw kx iq ky b kz mw jr lb lc mx ju le lf my lh li lj mz ll lm ln na lp lq lr ij bi translated">现在，我们可以通过运行以下命令来创建React应用程序:</p><pre class="kg kh ki kj gt nt ns nu nv aw nw bi"><span id="b6b9" class="mk lt iq ns b gy nx ny l nz oa">npx create-react-app client<br/>cd client</span></pre><p id="a3a0" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">除了React依赖项，我们还需要添加react-router、grpc-web和google-protobuf模块。</p><pre class="kg kh ki kj gt nt ns nu nv aw nw bi"><span id="eade" class="mk lt iq ns b gy nx ny l nz oa">npm install --save google-protobuf@~3.21.2 grpc-web@~1.4.1 react-router-dom@~6.4.2</span></pre><h2 id="11b5" class="mk lt iq bd lu ml mm dn ly mn mo dp mc lf mp mq me lj mr ms mg ln mt mu mi mv bi translated">生成原型存根</h2><p id="0c80" class="pw-post-body-paragraph kw kx iq ky b kz mw jr lb lc mx ju le lf my lh li lj mz ll lm ln na lp lq lr ij bi translated">我们必须创建我们的proto-javascript存根来编码/解码序列化/反序列化grpc数据。为此，我们可以使用二进制协议。将<code class="fe np nq nr ns b">page.proto</code>复制到客户端应用程序中名为<code class="fe np nq nr ns b">proto</code>的新目录中，然后运行以下命令:</p><pre class="kg kh ki kj gt nt ns nu nv aw nw bi"><span id="1c67" class="mk lt iq ns b gy nx ny l nz oa">protoc --proto_path=proto page.proto \\<br/>  --grpc-web_out=import_style=commonjs,mode=grpcweb:src \\<br/>  --js_out=import_style=commonjs,binary:src</span></pre><p id="b185" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这将在src目录中生成两个名为<code class="fe np nq nr ns b">page_grpc_web_pb.js</code>和<code class="fe np nq nr ns b">page_pb.js</code>的JavaScript文件。对于大的原型文件，这会生成大量代码。您可以使用类似于<a class="ae kv" href="https://github.com/protobufjs/protobuf.js" rel="noopener ugc nofollow" target="_blank"> protobuf.js </a>的节点模块，而不是生成这个静态代码。</p><p id="a0fc" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">模式设置为<code class="fe np nq nr ns b">grpcweb</code>。相反，我们也可以将其设置为<code class="fe np nq nr ns b">grpcwebtext</code>。更多关于模式<a class="ae kv" href="https://github.com/grpc/grpc-web#wire-format-mode" rel="noopener ugc nofollow" target="_blank">的信息，请点击</a>。</p><p id="13ad" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">为了支持二进制原型格式，我们将二进制文件<code class="fe np nq nr ns b">import_style</code>添加到<code class="fe np nq nr ns b">js_out</code>中。更多关于选项<a class="ae kv" href="https://github.com/protocolbuffers/protobuf-javascript#the---js_out-flag" rel="noopener ugc nofollow" target="_blank">在这里</a>。</p><p id="eff6" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">为了确保每次都生成这个存根，我们运行<code class="fe np nq nr ns b">npm install</code>并向我们的<code class="fe np nq nr ns b">package.json</code>添加另一个脚本。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ob oc l"/></div></figure><h2 id="b6d6" class="mk lt iq bd lu ml mm dn ly mn mo dp mc lf mp mq me lj mr ms mg ln mt mu mi mv bi translated">实现客户端</h2><p id="814e" class="pw-post-body-paragraph kw kx iq ky b kz mw jr lb lc mx ju le lf my lh li lj mz ll lm ln na lp lq lr ij bi translated">我们的委托人会很直接。</p><p id="b4d0" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">首先，我们需要一个<code class="fe np nq nr ns b">public/index.html</code></p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ob oc l"/></div></figure><p id="fc9e" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">然后我们将在<code class="fe np nq nr ns b">src/index.js</code>中实现我们的React应用。</p><p id="4d1b" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">首先，导入所有需要的模块并定义React根。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ob oc l"/></div></figure><p id="8e55" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在我们的<code class="fe np nq nr ns b">React.StrictMode</code>中，我们将添加带有三条路由的React路由器</p><ul class=""><li id="cf85" class="nb nc iq ky b kz la lc ld lf nd lj ne ln nf lr ng nh ni nj bi translated">/ →带有属性页的页面组件=主页</li><li id="bddc" class="nb nc iq ky b kz nk lc nl lf nm lj nn ln no lr ng nh ni nj bi translated">/impressum →带有属性page=impressum的页面组件</li><li id="0fac" class="nb nc iq ky b kz nk lc nl lf nm lj nn ln no lr ng nh ni nj bi translated">其他→无页面组件</li></ul><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ob oc l"/></div></figure><p id="7ecc" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">组件只是一些没有任何逻辑的HTML</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ob oc l"/></div></figure><p id="2fbc" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">对于<code class="fe np nq nr ns b">Page</code>组件，我们需要首先导入我们生成的JavaScript存根并创建一个<code class="fe np nq nr ns b">PageClient</code>对象。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ob oc l"/></div></figure><p id="1e2c" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">然后我们就可以像这样不用逻辑来定义我们的组件。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ob oc l"/></div></figure><p id="7251" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">对于逻辑，我们将从<code class="fe np nq nr ns b">page</code>属性创建一个<code class="fe np nq nr ns b">PageRequest</code>，调用<code class="fe np nq nr ns b">getPage</code>并用从<code class="fe np nq nr ns b">PageReply</code>生成的HTML设置组件的状态。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ob oc l"/></div></figure><p id="5ee5" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们使用响应来生成HTML。由于响应包括一个块列表，我们可以遍历它们并返回相应的HTML。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ob oc l"/></div></figure><p id="954c" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">对于我的实现，我添加了一些样式和一些其他静态HTML片段。</p><h2 id="f6cd" class="mk lt iq bd lu ml mm dn ly mn mo dp mc lf mp mq me lj mr ms mg ln mt mu mi mv bi translated">运行客户端</h2><p id="1d44" class="pw-post-body-paragraph kw kx iq ky b kz mw jr lb lc mx ju le lf my lh li lj mz ll lm ln na lp lq lr ij bi translated">为了通过开发服务器运行我们的客户机，我们需要运行React启动脚本。这也将打开一个新的浏览器窗口并显示网站。</p><pre class="kg kh ki kj gt nt ns nu nv aw nw bi"><span id="976d" class="mk lt iq ns b gy nx ny l nz oa">npm start</span></pre><h2 id="d5e6" class="mk lt iq bd lu ml mm dn ly mn mo dp mc lf mp mq me lj mr ms mg ln mt mu mi mv bi translated">通过快递服务</h2><p id="55c7" class="pw-post-body-paragraph kw kx iq ky b kz mw jr lb lc mx ju le lf my lh li lj mz ll lm ln na lp lq lr ij bi translated">开发服务器不是部署React应用程序的唯一方式。我们可以在这里读到一些可能性:<a class="ae kv" href="https://create-react-app.dev/docs/deployment/" rel="noopener ugc nofollow" target="_blank">https://create-react-app.dev/docs/deployment/</a></p><p id="b486" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们选择通过express部署应用程序。为此，我们在客户端应用程序中创建了一个新的nodejs应用程序，并添加了express依赖项。</p><pre class="kg kh ki kj gt nt ns nu nv aw nw bi"><span id="5702" class="mk lt iq ns b gy nx ny l nz oa">npm init express<br/>cd express<br/>npm install --save express@~4.18.2</span></pre><p id="26cd" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">然后我们需要一个<code class="fe np nq nr ns b">index.js </code>文件来服务React应用程序。看起来是这样的:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ob oc l"/></div></figure><p id="49f4" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这是行不通的，因为我们还没有创建产品版本。我们可以通过在客户端目录中运行以下命令来实现这一点:</p><pre class="kg kh ki kj gt nt ns nu nv aw nw bi"><span id="0645" class="mk lt iq ns b gy nx ny l nz oa">npm run build</span></pre><p id="eed2" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">然后，我们可以使用以下代码运行express服务器:</p><pre class="kg kh ki kj gt nt ns nu nv aw nw bi"><span id="34fe" class="mk lt iq ns b gy nx ny l nz oa">cd express<br/>node index.js</span></pre><h2 id="c556" class="mk lt iq bd lu ml mm dn ly mn mo dp mc lf mp mq me lj mr ms mg ln mt mu mi mv bi translated">归档</h2><p id="e8a8" class="pw-post-body-paragraph kw kx iq ky b kz mw jr lb lc mx ju le lf my lh li lj mz ll lm ln na lp lq lr ij bi translated">像服务器应用程序一样，我们对客户端进行dockerize。</p><p id="16e4" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这将稍微复杂一点，因为我们需要创建以下内容:</p><p id="980c" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><strong class="ky ir">构建器</strong></p><ul class=""><li id="8521" class="nb nc iq ky b kz la lc ld lf nd lj ne ln nf lr ng nh ni nj bi translated">安装protobuf编译器和两个生成器插件</li><li id="3c45" class="nb nc iq ky b kz nk lc nl lf nm lj nn ln no lr ng nh ni nj bi translated">构建我们的React应用</li><li id="61a6" class="nb nc iq ky b kz nk lc nl lf nm lj nn ln no lr ng nh ni nj bi translated">安装快速</li></ul><p id="f03d" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><strong class="ky ir">转轮</strong></p><ul class=""><li id="6cf4" class="nb nc iq ky b kz la lc ld lf nd lj ne ln nf lr ng nh ni nj bi translated">添加节点用户和组</li><li id="90e6" class="nb nc iq ky b kz nk lc nl lf nm lj nn ln no lr ng nh ni nj bi translated">安装nodejs和dum-init</li><li id="dfb3" class="nb nc iq ky b kz nk lc nl lf nm lj nn ln no lr ng nh ni nj bi translated">从生成器复制相关文件</li></ul><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ob oc l"/></div></figure><p id="d407" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">现在，将我们的客户端添加到项目主目录中的<code class="fe np nq nr ns b">docker-compose.json</code>。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ob oc l"/></div></figure><p id="edfc" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">当我们把所有的东西放在一起后，我们运行两个图像并浏览到<code class="fe np nq nr ns b"><a class="ae kv" href="http://127.0.0.1:8000" rel="noopener ugc nofollow" target="_blank">http://127.0.0.1:8000</a></code>。</p><pre class="kg kh ki kj gt nt ns nu nv aw nw bi"><span id="79d4" class="mk lt iq ns b gy nx ny l nz oa">docker-compose up --build</span></pre><h1 id="c0d3" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">结论</h1><p id="69c0" class="pw-post-body-paragraph kw kx iq ky b kz mw jr lb lc mx ju le lf my lh li lj mz ll lm ln na lp lq lr ij bi translated">我费了很大劲才让协议缓冲编译器JavaScript插件工作起来。但后来，一切都很容易设置。gRPC-web与服务器的通信工作正常，并且只使用了相应JSON大小的大约2/3。</p><p id="b0ed" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">但是消息的编码/解码和序列化/反序列化需要相当多的代码，这对于webapp来说似乎过于复杂。protobuf.js 可能是解决这个问题的一种方法，但是它也需要一些代码来动态生成存根。</p><p id="8232" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我喜欢使用proto文件理解数据结构是如此容易。这些原型文件充当客户机和服务器之间的契约。</p><p id="b275" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我怀念使用GraphQL时编写查询的可能性，因为它很像一个类似REST的二进制接口。创建一个类似GraphQL的协议缓冲区肯定是可能的，但这将是相当多的工作。目前，我仍将继续使用GraphQL进行Web客户端到服务器的通信。</p><p id="b96e" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">应用程序的完整代码可以在<a class="ae kv" href="https://github.com/christopherscholz/rust_grpc_website" rel="noopener ugc nofollow" target="_blank">这里</a>找到。</p></div></div>    
</body>
</html>