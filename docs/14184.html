<html>
<head>
<title>What’s New in TypeScript 4.9?</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">TypeScript 4.9有什么新功能？</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/whats-new-in-typescript-4-9-6bce2387aa31?source=collection_archive---------1-----------------------#2022-11-15">https://betterprogramming.pub/whats-new-in-typescript-4-9-6bce2387aa31?source=collection_archive---------1-----------------------#2022-11-15</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="e16f" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">满足运算符、自动访问器字段等</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/e7692ade753e4f1ed14c5992a54e9455.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*JxqHB7UyEswO6_nbHpSR6Q.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">作者捕获</p></figure><p id="c257" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">打字稿<code class="fe lu lv lw lx b">4.9</code>版本计划于11月15日发布🎉。这将是2022年的最后一次。对于TypeScript来说，这是很棒的一年。</p><p id="e95d" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">在本文中，我将重点介绍最相关的新特性。以下是摘要:</p><ul class=""><li id="aae3" class="ly lz it la b lb lc le lf lh ma ll mb lp mc lt md me mf mg bi translated">满足运算符</li><li id="2d4e" class="ly lz it la b lb mh le mi lh mj ll mk lp ml lt md me mf mg bi translated">支持自动访问器字段</li><li id="2765" class="ly lz it la b lb mh le mi lh mj ll mk lp ml lt md me mf mg bi translated">改进对<code class="fe lu lv lw lx b">in</code>操作器的检查</li><li id="6d62" class="ly lz it la b lb mh le mi lh mj ll mk lp ml lt md me mf mg bi translated">不允许与<code class="fe lu lv lw lx b">NaN</code>进行比较</li></ul><p id="b36b" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">像往常一样，您可以通过使用这里的TypeScript playground】来遵循任何示例。最好的学习方法总是互动地进行。</p></div><div class="ab cl mn mo hx mp" role="separator"><span class="mq bw bk mr ms mt"/><span class="mq bw bk mr ms mt"/><span class="mq bw bk mr ms"/></div><div class="im in io ip iq"><h2 id="472c" class="mu mv it bd mw mx my dn mz na nb dp nc lh nd ne nf ll ng nh ni lp nj nk nl nm bi translated">满足运算符</h2><p id="2954" class="pw-post-body-paragraph ky kz it la b lb nn ju ld le no jx lg lh np lj lk ll nq ln lo lp nr lr ls lt im bi translated">当输入一个变量时，我们必须决定是手动定义它的类型还是依靠推理。不可能两者兼而有之。</p><p id="722a" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">假设我们想声明一个变量，它的键可以是任何值，但我们希望值是一个数字。</p><p id="e189" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">如果我们仅仅依靠推理，除了交换之外，我们什么也不能实施，我们知道密钥是<code class="fe lu lv lw lx b">a | b | c</code></p><pre class="kj kk kl km gt ns lx nt bn nu nv bi"><span id="34fc" class="nw mv it lx b be nx ny l nz oa">// relying on inference to do the typing for us<br/>const foo = {<br/>    a: 255,<br/>    b: 255,<br/>    c: 255<br/>};<br/><br/>// typeof foo is <br/>// const foo: {<br/>//    a: number;<br/>//    b: number;<br/>//    c: number;<br/>// }</span></pre><p id="b010" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">让我们尝试将键值强制为一个数字:</p><pre class="kj kk kl km gt ns lx nt bn nu nv bi"><span id="f5af" class="nw mv it lx b be nx ny l nz oa">const foo: Record&lt;string, number&gt; = {<br/>    a: 255,<br/>    b: 255,<br/>    c: 255<br/>};<br/><br/>// typeof foo is <br/>// const foo: Record&lt;string, number&gt;</span></pre><p id="0d49" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">它的工作，但是，我们失去了键的类型信息被<code class="fe lu lv lw lx b">a | b | c</code>。我们可以通过提供映射键来轻松解决这个问题:</p><pre class="kj kk kl km gt ns lx nt bn nu nv bi"><span id="792b" class="nw mv it lx b be nx ny l nz oa">type Keys = 'a' | 'b' | 'c';<br/>const foo: Record&lt;Keys, number&gt; = {<br/>    a: 255,<br/>    b: 255,<br/>    c: 255<br/>};<br/><br/>// typeof foo is <br/>// const foo: Record&lt;Keys, number&gt;</span></pre><p id="76d7" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">以上是好的，但是有一个权衡。如果我们需要另一个键，我们必须将它添加到<code class="fe lu lv lw lx b">Keys</code>类型和<code class="fe lu lv lw lx b">foo</code>变量中。</p><p id="15e9" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">所以没有好的方法来表达对类型的限制而不改变它。直到现在。使用新的<code class="fe lu lv lw lx b">satisfies</code>操作符，我们可以在不改变变量推断类型的情况下实施类型限制。</p><pre class="kj kk kl km gt ns lx nt bn nu nv bi"><span id="9a0c" class="nw mv it lx b be nx ny l nz oa">const foo = {<br/>    a: 255,<br/>    b: 255,<br/>    c: 255,<br/>    // ❌ We get the error Type 'string' is not assignable to type 'number'<br/>    d: 'bar'<br/>} satisfies Record&lt;string, number&gt;;<br/><br/>// ✅ We are not losing any type inferance information<br/>// typeof foo is <br/>// const foo: {<br/>//    a: number;<br/>//    b: number;<br/>//    c: number;<br/>//    d: string;<br/>// }</span></pre><p id="f621" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">在上面的代码中，我们可以看到它的好处。我们能够强制对象<code class="fe lu lv lw lx b">foo</code>键总是属于<code class="fe lu lv lw lx b">number</code>类型。我们仍然可以保留关于对象的推理信息。</p><p id="a80e" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">过剩的房产怎么办？会失败还是会通过？关于这一点一直有争论。这有点棘手，因为你可以提出支持或反对的有力论据。</p><p id="23a6" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">最后的决定似乎是，多余的属性将被禁止，导致编译时出错。</p><pre class="kj kk kl km gt ns lx nt bn nu nv bi"><span id="09e3" class="nw mv it lx b be nx ny l nz oa">type Point = {<br/>    x: number,<br/>    y: number<br/>};<br/><br/>const origin = {<br/>    x: 0,<br/>    y: 0,<br/>    // ❌ Type '{ x: number; y: number; z: number; }' does not satisfy<br/>    // the expected type 'Point'<br/>    z: 0<br/>} satisfies Point;</span></pre><p id="457d" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">这个特性可能会在未来发展，也许会让<code class="fe lu lv lw lx b">satisfies</code>操作符用于函数声明成为可能。</p><p id="0b80" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">如果你想了解更多的细节或背景，你可以在这里看看最初的提议<a class="ae mm" href="https://github.com/microsoft/TypeScript/issues/47920" rel="noopener ugc nofollow" target="_blank">。</a></p></div><div class="ab cl mn mo hx mp" role="separator"><span class="mq bw bk mr ms mt"/><span class="mq bw bk mr ms mt"/><span class="mq bw bk mr ms"/></div><div class="im in io ip iq"><h1 id="5939" class="ob mv it bd mw oc od oe mz of og oh nc jz oi ka nf kc oj kd ni kf ok kg nl ol bi translated">支持自动访问器字段</h1><p id="50b4" class="pw-post-body-paragraph ky kz it la b lb nn ju ld le no jx lg lh np lj lk ll nq ln lo lp nr lr ls lt im bi translated">ECMAScript decorators提案已经在<code class="fe lu lv lw lx b">Stage 3</code>(这里的<a class="ae mm" href="https://github.com/tc39/proposal-decorators" rel="noopener ugc nofollow" target="_blank">链接</a>)中。这个特性将启用属性自动访问器构造。</p><pre class="kj kk kl km gt ns lx nt bn nu nv bi"><span id="4c0b" class="nw mv it lx b be nx ny l nz oa">class C {<br/>  accessor x = 1;<br/>}</span></pre><p id="11d7" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">作为这个版本的一部分，<code class="fe lu lv lw lx b">accessor</code>字段声明已经可以在TypeScript中使用。它在幕后使用装饰者的功能。</p><p id="caf2" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">让我们看看如何使用它</p><pre class="kj kk kl km gt ns lx nt bn nu nv bi"><span id="8991" class="nw mv it lx b be nx ny l nz oa">class Foo {<br/>    accessor a: string = 'a';<br/>}<br/><br/>const instance = new Foo();<br/><br/>// ✅ it works and prints 'a' <br/>console.log(instance.a);</span></pre><p id="c441" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">请注意我们如何访问<code class="fe lu lv lw lx b">a</code>属性，而不需要任何额外的样板文件。根据选择的<code class="fe lu lv lw lx b">target</code>输出，<code class="fe lu lv lw lx b">JavaScript</code>输出可能会有所不同。如果我们使用最新的<code class="fe lu lv lw lx b">Es2022</code>，输出将依赖于去年发布的JavaScript私有变量。</p><p id="fcb5" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">让我们看看<code class="fe lu lv lw lx b">tsconfig</code>目标设置为<code class="fe lu lv lw lx b">Es2022</code>时的<code class="fe lu lv lw lx b">js</code>输出代码:</p><pre class="kj kk kl km gt ns lx nt bn nu nv bi"><span id="1699" class="nw mv it lx b be nx ny l nz oa">"use strict";<br/>class Foo {<br/>    constructor() {<br/>        this.#a_accessor_storage = 'a';<br/>    }<br/>    #a_accessor_storage;<br/>    get a() { return this.#a_accessor_storage; }<br/>    set a(value) { this.#a_accessor_storage = value; }<br/>}<br/><br/>const instance = new Foo();<br/>// ✅ it works and prints 'a' <br/>console.log(instance.a);</span></pre><p id="e169" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">这个特征并没有就此结束。我们仍然可以使<code class="fe lu lv lw lx b">accessors</code>私有，以限制对类实例内部的访问，或者使<code class="fe lu lv lw lx b">static</code>可用，而不需要有一个实例。</p><p id="1fd6" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">让我们看一个这两种用法的例子:</p><pre class="kj kk kl km gt ns lx nt bn nu nv bi"><span id="16c7" class="nw mv it lx b be nx ny l nz oa">class Foo {<br/>    accessor a: string = 'a';<br/>    accessor #b: string = 'b';<br/>    static accessor c: string = 'c';<br/>    <br/>    log() {<br/>        // ✅ it works and prints 'b'<br/>        console.log(this.#b)<br/>    }<br/>}<br/><br/>const instance = new Foo();<br/><br/>// ❌ does not work since property is private<br/>console.log(instance.#b);<br/><br/>// ✅ it works and prints 'c' <br/>console.log(Foo.c);</span></pre></div><div class="ab cl mn mo hx mp" role="separator"><span class="mq bw bk mr ms mt"/><span class="mq bw bk mr ms mt"/><span class="mq bw bk mr ms"/></div><div class="im in io ip iq"><h1 id="82b6" class="ob mv it bd mw oc od oe mz of og oh nc jz oi ka nf kc oj kd ni kf ok kg nl ol bi translated">改进对<code class="fe lu lv lw lx b">in</code>操作器的检查</h1><p id="c30d" class="pw-post-body-paragraph ky kz it la b lb nn ju ld le no jx lg lh np lj lk ll nq ln lo lp nr lr ls lt im bi translated">TypeScript <code class="fe lu lv lw lx b">in</code>是一个很好的方法，可以正确检查可能只存在于联合中的一个对象中的内容。</p><p id="dc39" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">让我们看一个例子:</p><pre class="kj kk kl km gt ns lx nt bn nu nv bi"><span id="8749" class="nw mv it lx b be nx ny l nz oa">type Car = {<br/>  wheels: number;<br/>  topSpeed: number;<br/>}<br/><br/>type Plane = {<br/>  topSpeed: number;<br/>}<br/><br/>function log(vehicle: Car | Plane) {<br/>  if ('wheels' in vehicle) {<br/>    // ✅ vehicle.wheels is of type string<br/>    console.log(`vehicle has ${vehicle.wheels} wheels`)<br/>  }<br/>  console.log(`vehicle top topSpeed is ${vehicle.topSpeed} km/h`)<br/>}</span></pre><p id="fcda" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">当类型未知时会发生什么？在键入脚本<code class="fe lu lv lw lx b">4.9</code>之前，不可能对其进行类型检查。我们会得到一个打字错误。</p><p id="fc23" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">现在，我们可以结合使用<code class="fe lu lv lw lx b">in</code>操作符和<code class="fe lu lv lw lx b">typeof</code>来缩小类型。如果<code class="fe lu lv lw lx b">typeof</code>不存在，它将被输入为<code class="fe lu lv lw lx b">unknown</code>。</p><p id="8ae9" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">带有<code class="fe lu lv lw lx b">typeof</code>的示例:</p><pre class="kj kk kl km gt ns lx nt bn nu nv bi"><span id="eac9" class="nw mv it lx b be nx ny l nz oa">function log(vehicle: {}) {<br/>  // ✅ Works, item.wheels is now of type number<br/>  if ('wheels' in vehicle &amp;&amp; typeof vehicle.wheels === "number") {<br/>    console.log(`the entity has ${vehicle.wheels} wheels`)<br/>  }<br/>}<br/><br/>log({ wheels : 4, topSpeed: 20, })</span></pre><p id="4647" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">不带<code class="fe lu lv lw lx b">typeof</code>的示例:</p><pre class="kj kk kl km gt ns lx nt bn nu nv bi"><span id="31c2" class="nw mv it lx b be nx ny l nz oa">function log(vehicle: {}) {<br/>  // ✅ Works, item.wheels is now of type unknown<br/>  if ('wheels' in vehicle) {<br/>    console.log(`the entity has ${vehicle.wheels} wheels`)<br/>  }<br/>}<br/><br/>log({ wheels : 4, topSpeed: 20, })</span></pre><p id="190e" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">对<code class="fe lu lv lw lx b">in</code>操作符的另一个改变是<code class="fe lu lv lw lx b">key in obj</code>的键现在被约束到了<code class="fe lu lv lw lx b">string | number | symbol</code>。以前，允许<code class="fe lu lv lw lx b">key</code>为无约束类型的参数类型。</p></div><div class="ab cl mn mo hx mp" role="separator"><span class="mq bw bk mr ms mt"/><span class="mq bw bk mr ms mt"/><span class="mq bw bk mr ms"/></div><div class="im in io ip iq"><h1 id="86a9" class="ob mv it bd mw oc od oe mz of og oh nc jz oi ka nf kc oj kd ni kf ok kg nl ol bi translated">不允许与<code class="fe lu lv lw lx b">NaN</code>进行比较</h1><p id="defc" class="pw-post-body-paragraph ky kz it la b lb nn ju ld le no jx lg lh np lj lk ll nq ln lo lp nr lr ls lt im bi translated">浮点运算标准是浮点运算的技术标准。它对于所有使用浮点的语言都是同等实现的。</p><p id="8735" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated"><code class="fe lu lv lw lx b">IEEE 754</code>规范声明<code class="fe lu lv lw lx b">NaN</code>值永远不相等。</p><pre class="kj kk kl km gt ns lx nt bn nu nv bi"><span id="e6d7" class="nw mv it lx b be nx ny l nz oa">NaN === NaN // false<br/>NaN !== NaN // false</span></pre><p id="60e4" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">那我们怎么能恰当地比较这些呢？在JavaScript中，我们可以使用<code class="fe lu lv lw lx b">Number.isNaN</code>实用函数。</p><pre class="kj kk kl km gt ns lx nt bn nu nv bi"><span id="6449" class="nw mv it lx b be nx ny l nz oa">Number.isNaN(NaN) // true<br/>Number.isNaN(0) // false</span></pre><p id="c455" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">作为TypeScript <code class="fe lu lv lw lx b">4.9</code>版本的一部分，编译器在比较<code class="fe lu lv lw lx b">NaN</code>值时会给出一个错误。</p><pre class="kj kk kl km gt ns lx nt bn nu nv bi"><span id="af3f" class="nw mv it lx b be nx ny l nz oa">function logValue(value: Number | NaN) {<br/>  // ❌ Error: This condition will always return 'true'<br/>  // Did you mean '!Number.isNaN(value)'<br/>  if (value !== NaN) { <br/>    console.log('It is NaN');<br/>  }<br/>  console.log(value);<br/>}</span></pre><p id="f99b" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">这个方便的错误将节省大量的调试时间，尤其是对初学者来说。</p></div><div class="ab cl mn mo hx mp" role="separator"><span class="mq bw bk mr ms mt"/><span class="mq bw bk mr ms mt"/><span class="mq bw bk mr ms"/></div><div class="im in io ip iq"><h1 id="c863" class="ob mv it bd mw oc od oe mz of og oh nc jz oi ka nf kc oj kd ni kf ok kg nl ol bi translated">包裹</h1><p id="ed30" class="pw-post-body-paragraph ky kz it la b lb nn ju ld le no jx lg lh np lj lk ll nq ln lo lp nr lr ls lt im bi translated">总的来说，这是一次伟大的发布。我看到自己在相当多的场景中使用<code class="fe lu lv lw lx b">satisfies</code>操作符。我相信它会很快流行起来。只有这个功能值得升级。</p><p id="1576" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">像现在变得常见的那样，还有一些性能改进。</p><p id="df6d" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">我没有讲太多细节，但你可以在这里找到更多信息:</p><ul class=""><li id="a56f" class="ly lz it la b lb lc le lf lh ma ll mb lp mc lt md me mf mg bi translated"><em class="om">优化#1: </em>交换<code class="fe lu lv lw lx b">forEachChild</code>使用一个函数表，而不是这里的<code class="fe lu lv lw lx b">switch</code>语句<a class="ae mm" href="https://github.com/microsoft/TypeScript/pull/50225" rel="noopener ugc nofollow" target="_blank"/>。</li><li id="bb48" class="ly lz it la b lb mh le mi lh mj ll mk lp ml lt md me mf mg bi translated"><em class="om">优化#2: </em>在此添加一个<code class="fe lu lv lw lx b">visitEachChild</code> <a class="ae mm" href="https://github.com/microsoft/TypeScript/pull/50266" rel="noopener ugc nofollow" target="_blank">的跳转表。</a></li><li id="85c4" class="ly lz it la b lb mh le mi lh mj ll mk lp ml lt md me mf mg bi translated"><em class="om">优化#3: </em>优化替换类型<a class="ae mm" href="https://github.com/microsoft/TypeScript/pull/50397" rel="noopener ugc nofollow" target="_blank">此处</a>。</li></ul></div></div>    
</body>
</html>