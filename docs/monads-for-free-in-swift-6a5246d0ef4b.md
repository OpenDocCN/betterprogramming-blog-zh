# Swift 中的免费单子

> 原文：<https://betterprogramming.pub/monads-for-free-in-swift-6a5246d0ef4b>

## 使用预定义的符号编写工作流，并在以后对其进行解释

![](img/007a365de9ce3de50f94cc5ca71d73b6.png)

布鲁诺·马丁斯在 [Unsplash](https://unsplash.com?utm_source=medium&utm_medium=referral) 上拍摄的照片

我刚刚发现了一些惊人的事情:实际上有一种方法可以以一种相对通用的方式将免费的单子和单子解释器带到 Swift！

等等……什么？

也许让我们从头开始。什么是单子？

monad 只是一个泛型类型(想想:`Optional`或`Array`)，有一个非常特殊的接口。具体来说，有三个要求:

1.  需要有一种方法将“普通”值提升到一元上下文中。
2.  需要一种用“纯”函数转换一元值的方法。
3.  需要一种用“一元”函数转换一元值的方法。

但是，与其指出上述术语的确切含义，不如让我给你一个有效单子的例子:

这是怎么回事？

`MyMonad`所做的是:它使它的一般值 T 依赖于 Env(在这个例子中，它只是一个占位符类型，但也可能包含有意义的信息)。

如您所见，函数`pure`表达了一个事实上不依赖于 Env 的值。方法`map`接受您计算的任何值(取决于 Env)并对其应用纯函数`transform`。最后，方法`flatMap`使得在“一元工作流”中的任意点多次依赖 Env 成为可能。

实际上，`Optional`和`Array`暴露的正是这个接口。不幸的是，Swift 的类型系统不够强大，不足以写下一个“单子协议”，但它是你有时会看到的模式。如果你熟悉单子，你可能已经认识到上面的`MyMonad`例子是读者单子。如果你关注 Haskell，你可以在这里阅读更多关于这个[的内容](https://hackage.haskell.org/package/mtl-2.2.2/docs/Control-Monad-Reader.html)。

单子需要满足一些定律。基本上，它必须使用简单函数形成一个类别(通常的身份作为`map`下的身份)，它必须使用一元箭头(通过`flatMap`形成一个类别，其中`pure`必须扮演身份箭头的角色。你不必真的理解这一点就能理解文章的其余部分。这里有一个[来源](https://mokacoding.com/blog/functor-applicative-monads-in-pictures/)。对于高级读者，查看[单子分类](https://bartoszmilewski.com/2016/12/27/monads-categorically/)指南。

但是，单子有什么用呢？

首先，他们隐藏了一些样板文件，这通常是可取的。但更重要的是，它们编码了副作用！

如果你坚持不做任何副作用的约定，除非你以某种方式将它编码在单子中，你可以从函数的签名中准确地推断出它会有什么副作用，例如，读取一些`Env`值或者可能失败或者做一些异步工作。事实上，抛出函数或异步函数可以被看作是形成一个单子。

# 自由单子

现在让我们转到自由单子。单子的一个严重问题是它们很难组合。给定两个单子，得到一个超级单子的通常方法是使用一个模糊的概念，叫做“单子变换器”。

这种方法的一个大问题是，通过单子转换器获得的“超级单子”取决于组合的顺序:`Array[T]?`与`Array[T?]`完全不同，单子转换器(它实际上只是提供了一点语法糖，使处理那些“单子堆栈”更容易)不会改变这一点。

但是实际上有一种更“平等”的方式来组合单子。好吧，至少如果你把自己限制在某种(非常有用的)单子类型上。

事实证明，有一种非常通用的方法可以“按需”构造单子。实际上，你可以使用任何“足够通用”的类型作为单子的基础:自由单子。

废话少说，举例子时间到了！

我们看到的是类型级的单子:虽然我们没有一个单一的泛型类型充当单子，但是`Symbol`协议本身有。

因此，我们可以将只涉及有效`Symbol`的任意计算序列链接起来，只要它们的含义与链中下一个函数的预期含义相匹配。

以下是符号及其含义的具体示例:

好吧，这很好，但是我们能拿这些做什么呢？

# 我们可以解读！

例如:

请注意，我们没有使`Nothing`符合`PureInterpretable`。这种一致性在一般情况下是不可能的。不过，有人可能会去 T2。

`tryInterpret`对于`Map`和`FlatMap`的实现其实和`interpret`非常相似。其实就是一种模式。我们可以仅根据目标单子的`flatMap`和映射方法来表达任意单子中`Map`和`FlatMap`的实现(或者仅使用`flatMap`和 pure，其中我们不映射纯函数，而是人为地将返回值包装到目标单子上下文中)。

唯一改变的是解释方法和目标单子的名称。我没有试过，但是应该可以通过 codegen 管理这个样板文件。

最后，让我们看看如何将符号的工作流编译成更有趣的东西。

`Map`和`FlatMap`的一致性开始变得熟悉:

下面是对我们基本符号类型的一种可能的解释:

# 结论

使用上面的模式，可以用预定义的符号编写工作流，并在以后给它们一个解释。

重要的是，解释实际上决定了你的工作流能做什么和不能做什么。我们得到了关注点的分离，这使得我们可以简单地把我们的代码看作一个链式函数的工作流。您甚至不必关心是否需要一台复杂的机器来实际运行您的计算并处理诸如错误或异步之类的异常，或者您是否只是返回一些默认值。

假设`Map`和`FlatMap`与“可解释”协议的一致性实际上可以通过代码生成来完成，那么在 Swift 中只有一个问题——类型很快变得难以理解。在这里，未来的发展，如完全存在的，改进的不透明返回类型或占位符类型可以有所帮助。