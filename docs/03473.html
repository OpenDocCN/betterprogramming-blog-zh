<html>
<head>
<title>Different Ways to Create Observables in RxJava</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">在RxJava中创建观察值的不同方法</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/rxjava-different-ways-of-creating-observables-7ec3204f1e23?source=collection_archive---------1-----------------------#2020-02-12">https://betterprogramming.pub/rxjava-different-ways-of-creating-observables-7ec3204f1e23?source=collection_archive---------1-----------------------#2020-02-12</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="95d1" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">有多少种方法可以创造一个可观察的？</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/db8456ab95e7e2d813e442b8b517b170.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*2kMMQMDi4RAufaUvq99nsg.jpeg"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">照片由<a class="ae ky" href="https://unsplash.com/@mikakor?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Mika Korhonen </a>在<a class="ae ky" href="https://unsplash.com/s/photos/observation?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</p></figure><p id="0821" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">Rx代表无功扩展。是一个非常棒的反应库，我们可以很容易地将它集成到我们的应用程序中。</p><p id="4c1d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们可以将<code class="fe lv lw lx ly b">RxJava</code>理解为由一个称为<code class="fe lv lw lx ly b">Observable</code>的组件发出的数据，由Rx库提供的底层结构将把更改传播到另一个组件<code class="fe lv lw lx ly b">Observer</code>。简单地说，它是一个使用可观察流进行异步编程的API。</p><p id="eb57" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><a class="ae ky" href="https://medium.com/@pavan.careers5208/rxjava-multi-threading-in-android-302a7419edbf" rel="noopener">Rx Java—Android中的多线程</a>有助于了解Rx的基础知识，关于<code class="fe lv lw lx ly b"><a class="ae ky" href="https://medium.com/better-programming/rxjava-multi-threading-in-android-302a7419edbf" rel="noopener">Observable</a></code><a class="ae ky" href="https://medium.com/better-programming/rxjava-multi-threading-in-android-302a7419edbf" rel="noopener">s</a><code class="fe lv lw lx ly b"><a class="ae ky" href="https://medium.com/better-programming/rxjava-multi-threading-in-android-302a7419edbf" rel="noopener">Observer</a></code><a class="ae ky" href="https://medium.com/better-programming/rxjava-multi-threading-in-android-302a7419edbf" rel="noopener">s</a><code class="fe lv lw lx ly b"><a class="ae ky" href="https://medium.com/better-programming/rxjava-multi-threading-in-android-302a7419edbf" rel="noopener">Scheduler</a></code><a class="ae ky" href="https://medium.com/better-programming/rxjava-multi-threading-in-android-302a7419edbf" rel="noopener">s</a>等的一切。所以，希望你已经了解了<code class="fe lv lw lx ly b">RxJava</code>的基础知识，让我们从讨论<code class="fe lv lw lx ly b">Observable</code>开始。</p><h2 id="fa75" class="lz ma it bd mb mc md dn me mf mg dp mh li mi mj mk lm ml mm mn lq mo mp mq mr bi translated">什么是可观测的？</h2><p id="f0be" class="pw-post-body-paragraph kz la it lb b lc ms ju le lf mt jx lh li mu lk ll lm mv lo lp lq mw ls lt lu im bi translated">在<code class="fe lv lw lx ly b">RxJava</code>中，<code class="fe lv lw lx ly b">Observable</code>是向<code class="fe lv lw lx ly b">Observers</code>发送数据的源。我们可以将<code class="fe lv lw lx ly b">observable</code> s理解为供应商——他们处理数据并向其他组件提供数据。它做一些工作，并发出一些值。</p><p id="6709" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">以下是RxJava中不同类型的<code class="fe lv lw lx ly b">Observable</code></p><ul class=""><li id="2bc2" class="mx my it lb b lc ld lf lg li mz lm na lq nb lu nc nd ne nf bi translated"><code class="fe lv lw lx ly b">Observable</code></li><li id="06da" class="mx my it lb b lc ng lf nh li ni lm nj lq nk lu nc nd ne nf bi translated"><code class="fe lv lw lx ly b">Flowable</code></li><li id="5028" class="mx my it lb b lc ng lf nh li ni lm nj lq nk lu nc nd ne nf bi translated"><code class="fe lv lw lx ly b">Single</code></li><li id="c836" class="mx my it lb b lc ng lf nh li ni lm nj lq nk lu nc nd ne nf bi translated"><code class="fe lv lw lx ly b">Maybe</code></li><li id="8616" class="mx my it lb b lc ng lf nh li ni lm nj lq nk lu nc nd ne nf bi translated"><code class="fe lv lw lx ly b">Completable</code></li></ul><p id="13ab" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们将在下一篇文章中详细讨论每种类型，但请记住，不同类型的<code class="fe lv lw lx ly b">Observable</code>有不同的用途。</p><p id="8404" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe lv lw lx ly b">RxJava</code>库为<code class="fe lv lw lx ly b">Observabl</code> e创作提供了很多方法。让我们看看这些方法，并了解何时使用每种方法:</p><ul class=""><li id="698d" class="mx my it lb b lc ld lf lg li mz lm na lq nb lu nc nd ne nf bi translated"><code class="fe lv lw lx ly b">create()</code></li><li id="6a91" class="mx my it lb b lc ng lf nh li ni lm nj lq nk lu nc nd ne nf bi translated"><code class="fe lv lw lx ly b">just()</code></li><li id="a766" class="mx my it lb b lc ng lf nh li ni lm nj lq nk lu nc nd ne nf bi translated"><code class="fe lv lw lx ly b">defer()</code></li><li id="7fa4" class="mx my it lb b lc ng lf nh li ni lm nj lq nk lu nc nd ne nf bi translated"><code class="fe lv lw lx ly b">empty()</code></li><li id="5dcb" class="mx my it lb b lc ng lf nh li ni lm nj lq nk lu nc nd ne nf bi translated"><code class="fe lv lw lx ly b">never()</code></li><li id="9e19" class="mx my it lb b lc ng lf nh li ni lm nj lq nk lu nc nd ne nf bi translated"><code class="fe lv lw lx ly b">error()</code></li><li id="956b" class="mx my it lb b lc ng lf nh li ni lm nj lq nk lu nc nd ne nf bi translated"><code class="fe lv lw lx ly b">range()</code></li><li id="980f" class="mx my it lb b lc ng lf nh li ni lm nj lq nk lu nc nd ne nf bi translated"><code class="fe lv lw lx ly b">interval()</code></li><li id="2efb" class="mx my it lb b lc ng lf nh li ni lm nj lq nk lu nc nd ne nf bi translated"><code class="fe lv lw lx ly b">timer()</code></li><li id="b9ed" class="mx my it lb b lc ng lf nh li ni lm nj lq nk lu nc nd ne nf bi translated"><code class="fe lv lw lx ly b">from()</code></li></ul></div><div class="ab cl nl nm hx nn" role="separator"><span class="no bw bk np nq nr"/><span class="no bw bk np nq nr"/><span class="no bw bk np nq"/></div><div class="im in io ip iq"><h1 id="19d1" class="ns ma it bd mb nt nu nv me nw nx ny mh jz nz ka mk kc oa kd mn kf ob kg mq oc bi translated"><strong class="ak">创建()</strong></h1><p id="411d" class="pw-post-body-paragraph kz la it lb b lc ms ju le lf mt jx lh li mu lk ll lm mv lo lp lq mw ls lt lu im bi translated">通过函数从头开始创建一个<code class="fe lv lw lx ly b">Observable</code>:</p><pre class="kj kk kl km gt od ly oe of aw og bi"><span id="d1fd" class="lz ma it ly b gy oh oi l oj ok">val createObserver = Observable.<strong class="ly iu">create</strong>(<em class="ol">ObservableOnSubscribe</em>&lt;String&gt; <strong class="ly iu">{ </strong>emitter <strong class="ly iu">-&gt;<br/>    </strong>emitter.onNext("Hello World")<br/>    emitter.onComplete()<br/><strong class="ly iu">}</strong>)</span></pre><p id="66f5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">create factory方法是<em class="ol">首选的</em>实现自定义可观察序列的方式。本质上，此方法允许您指定一个委托，该委托将在每次进行订阅时执行。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi om"><img src="../Images/86ac42207d532f3207612aae723b0d36.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*QnrhRZtPRvdYVO_FVJwgPA.png"/></div></div></figure><p id="c92e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><em class="ol">注意:</em><code class="fe lv lw lx ly b"><em class="ol">Flowable.create()</em></code><strong class="lb iu"><em class="ol"/></strong><em class="ol">还必须指定</em> <strong class="lb iu"> <em class="ol">背压</em> </strong> <em class="ol">当用户提供的函数生成的项目多于下游消费者请求的项目时，将应用的行为。</em></p><p id="2db9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe lv lw lx ly b">ObservableOnSubscribe</code>是一个函数接口，它有一个<code class="fe lv lw lx ly b">subscribe()</code>方法，该方法接收一个<code class="fe lv lw lx ly b">ObservableEmitter</code>实例的实例，该实例允许以取消安全的方式推送事件。看一下界面:</p><pre class="kj kk kl km gt od ly oe of aw og bi"><span id="21ad" class="lz ma it ly b gy oh oi l oj ok"><em class="ol">/* </em><strong class="ly iu"><em class="ol">@param </em></strong>&lt;<em class="ol">T</em>&gt; <em class="ol">the value type pushed<br/> */<br/></em>public interface <strong class="ly iu">ObservableOnSubscribe</strong>&lt;T&gt; {<br/><br/>    <em class="ol">/**<br/>     * Called for each Observer that subscribes.<br/>     * </em><strong class="ly iu"><em class="ol">@param </em></strong><em class="ol">emitter the safe emitter instance, never null<br/>     * </em><strong class="ly iu"><em class="ol">@throws </em></strong><em class="ol">Exception on error<br/>     */<br/>    </em>void <strong class="ly iu">subscribe</strong>(@NonNull ObservableEmitter&lt;T&gt; emitter) throws Exception;<br/>}</span></pre></div><div class="ab cl nl nm hx nn" role="separator"><span class="no bw bk np nq nr"/><span class="no bw bk np nq nr"/><span class="no bw bk np nq"/></div><div class="im in io ip iq"><h1 id="014b" class="ns ma it bd mb nt nu nv me nw nx ny mh jz nz ka mk kc oa kd mn kf ob kg mq oc bi translated">就()</h1><p id="cee9" class="pw-post-body-paragraph kz la it lb b lc ms ju le lf mt jx lh li mu lk ll lm mv lo lp lq mw ls lt lu im bi translated">这是创建可观察的最简单方便的方法之一。<code class="fe lv lw lx ly b">just()</code>通过获取一个预先存在的对象并在<em class="ol">订阅</em>时将该特定对象发送给<em class="ol">下游</em>消费者来构建一个反应类型。just操作符将一个项目转换成一个发出该项目的<code class="fe lv lw lx ly b">Observable</code>。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi on"><img src="../Images/7f53e1141e87776c4a7a68564700ba67.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*mJ9qvLJh5Xd6HQUelU0DCQ.png"/></div></div></figure><pre class="kj kk kl km gt od ly oe of aw og bi"><span id="0020" class="lz ma it ly b gy oh oi l oj ok">val justObservable = Observable.<strong class="ly iu">just</strong>(4, 5, 6, null)</span></pre><p id="3553" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">记住，如果你将<code class="fe lv lw lx ly b">null</code>传递给<code class="fe lv lw lx ly b">Just</code>，它将返回一个<code class="fe lv lw lx ly b">Observable</code>，这个<code class="fe lv lw lx ly b">Observable</code>将发出<code class="fe lv lw lx ly b">null</code>作为一个项。不要错误地认为这将返回一个空的<code class="fe lv lw lx ly b">Observable</code>到<code class="fe lv lw lx ly b">Just </code>——它将返回一个发出<code class="fe lv lw lx ly b">null</code>的<code class="fe lv lw lx ly b">Observable</code>作为一个条目。</p><p id="1412" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe lv lw lx ly b"><em class="ol">Observable.just()</em></code> <em class="ol">放出just函数里面存在的东西。它可以接受2到9个参数。如果你在</em> <code class="fe lv lw lx ly b"><em class="ol">just()</em></code> <em class="ol">中传递一个列表或数组，它将只发出这个列表或数组。</em></p></div><div class="ab cl nl nm hx nn" role="separator"><span class="no bw bk np nq nr"/><span class="no bw bk np nq nr"/><span class="no bw bk np nq"/></div><div class="im in io ip iq"><h1 id="e9ee" class="ns ma it bd mb nt nu nv me nw nx ny mh jz nz ka mk kc oa kd mn kf ob kg mq oc bi translated"><strong class="ak">延期</strong>()</h1><p id="3678" class="pw-post-body-paragraph kz la it lb b lc ms ju le lf mt jx lh li mu lk ll lm mv lo lp lq mw ls lt lu im bi translated">在观察者订阅并为每个<code class="fe lv lw lx ly b">observer</code>创建一个新的<code class="fe lv lw lx ly b">Observable</code>之前，<code class="fe lv lw lx ly b">defer()</code>不会创建<code class="fe lv lw lx ly b">Observable</code>。<code class="fe lv lw lx ly b">Defer</code>操作符一直等到观察者订阅它，然后它生成一个<code class="fe lv lw lx ly b">Observable</code>，通常带有一个<code class="fe lv lw lx ly b">Observable</code>工厂函数。它为每个<code class="fe lv lw lx ly b">subscriber</code>进行这种创建——尽管每个<code class="fe lv lw lx ly b">subscriber</code>可能认为它订阅了同一个<code class="fe lv lw lx ly b">Observable</code>，但事实上，每个订阅者都获得了自己单独的序列。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi om"><img src="../Images/86ac42207d532f3207612aae723b0d36.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*QnrhRZtPRvdYVO_FVJwgPA.png"/></div></div></figure><pre class="kj kk kl km gt od ly oe of aw og bi"><span id="f0ff" class="lz ma it ly b gy oh oi l oj ok">val observable = Observable.<strong class="ly iu">defer</strong> <strong class="ly iu">{<br/>    </strong>val time = System.currentTimeMillis()<br/>    Observable.just(time)<br/><strong class="ly iu">}</strong></span></pre><p id="66e6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在某些情况下，等到最后一分钟(即订阅时间)生成<code class="fe lv lw lx ly b">Observable</code>可以确保它包含最新的数据。</p></div><div class="ab cl nl nm hx nn" role="separator"><span class="no bw bk np nq nr"/><span class="no bw bk np nq nr"/><span class="no bw bk np nq"/></div><div class="im in io ip iq"><h1 id="cbda" class="ns ma it bd mb nt nu nv me nw nx ny mh jz nz ka mk kc oa kd mn kf ob kg mq oc bi translated">空()</h1><p id="31a3" class="pw-post-body-paragraph kz la it lb b lc ms ju le lf mt jx lh li mu lk ll lm mv lo lp lq mw ls lt lu im bi translated"><code class="fe lv lw lx ly b">empty()</code>创建一个<code class="fe lv lw lx ly b">Observable</code>使<em class="ol">不发射任何物品，但正常终止</em>。这种类型的源在订阅时立即发出完成信号。它返回一个没有向<code class="fe lv lw lx ly b">Observer</code>发出任何条目的<code class="fe lv lw lx ly b">Observable</code>，并立即调用它的<code class="fe lv lw lx ly b">onComplete()</code>方法。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi oo"><img src="../Images/8beb1d4812bc32179d096bfab08772d3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*sUUNcD32k7PQdQvl-NkAgQ.png"/></div></div></figure><pre class="kj kk kl km gt od ly oe of aw og bi"><span id="8fa3" class="lz ma it ly b gy oh oi l oj ok">val empty = Observable.<strong class="ly iu">empty</strong>()<br/><br/>empty.subscribe(<br/>        <strong class="ly iu">{ </strong>v <strong class="ly iu">-&gt; </strong><em class="ol">println</em>("This should never be printed!") <strong class="ly iu">}</strong>,<br/>        <strong class="ly iu">{ </strong>error <strong class="ly iu">-&gt; </strong><em class="ol">println</em>("Or this!") <strong class="ly iu">}</strong>,<br/>        <strong class="ly iu">{ </strong><em class="ol">println</em>("Done will be printed.") <strong class="ly iu">}</strong>)</span></pre></div><div class="ab cl nl nm hx nn" role="separator"><span class="no bw bk np nq nr"/><span class="no bw bk np nq nr"/><span class="no bw bk np nq"/></div><div class="im in io ip iq"><h1 id="09b3" class="ns ma it bd mb nt nu nv me nw nx ny mh jz nz ka mk kc oa kd mn kf ob kg mq oc bi translated">从不()</h1><p id="49f0" class="pw-post-body-paragraph kz la it lb b lc ms ju le lf mt jx lh li mu lk ll lm mv lo lp lq mw ls lt lu im bi translated"><code class="fe lv lw lx ly b">never()</code>创建一个<strong class="lb iu"> </strong> <em class="ol">不发射任何项目且不终止的<code class="fe lv lw lx ly b">Observable</code>。</em>这种类型的信号源不发出任何<code class="fe lv lw lx ly b">onNext</code>、<code class="fe lv lw lx ly b">onSuccess</code>、<code class="fe lv lw lx ly b">onError</code>或<code class="fe lv lw lx ly b">onComplete</code>信号。这种类型的无功源对于测试或禁用组合运算符中的某些源非常有用。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi op"><img src="../Images/1ef2bf3c83ab62db56e32a1b69531d03.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*V6vwGWv8x_I-qQayT-4F2Q.png"/></div></div></figure><pre class="kj kk kl km gt od ly oe of aw og bi"><span id="d909" class="lz ma it ly b gy oh oi l oj ok">val never = Observable.<strong class="ly iu">never</strong>()<br/><br/>never.subscribe(<br/>        <strong class="ly iu">{ </strong>v <strong class="ly iu">-&gt; </strong><em class="ol">println</em>("This should never be printed!") <strong class="ly iu">}</strong>,<br/>        <strong class="ly iu">{ </strong>error <strong class="ly iu">-&gt; </strong><em class="ol">println</em>("Or this!") <strong class="ly iu">}</strong>,<br/>        <strong class="ly iu">{ </strong><em class="ol">println</em>("This neither!") <strong class="ly iu">}</strong>)</span></pre></div><div class="ab cl nl nm hx nn" role="separator"><span class="no bw bk np nq nr"/><span class="no bw bk np nq nr"/><span class="no bw bk np nq"/></div><div class="im in io ip iq"><h1 id="74f7" class="ns ma it bd mb nt nu nv me nw nx ny mh jz nz ka mk kc oa kd mn kf ob kg mq oc bi translated"><strong class="ak">错误()</strong></h1><p id="2797" class="pw-post-body-paragraph kz la it lb b lc ms ju le lf mt jx lh li mu lk ll lm mv lo lp lq mw ls lt lu im bi translated"><code class="fe lv lw lx ly b">error()</code>向用户发出一个错误信号，该信号可以是预先存在的，也可以是通过<code class="fe lv lw lx ly b">java.util.concurrent.Callable</code>产生的。</p><pre class="kj kk kl km gt od ly oe of aw og bi"><span id="e674" class="lz ma it ly b gy oh oi l oj ok">val error = Observable.<strong class="ly iu">error</strong>(IOException())<br/>error.subscribe(<br/>        <strong class="ly iu">{ </strong>v <strong class="ly iu">-&gt; </strong><em class="ol">println</em>("This should never be printed!") <strong class="ly iu">}</strong>,<br/>        <strong class="ly iu">{ </strong>e <strong class="ly iu">-&gt; </strong>e.<em class="ol">printStackTrace</em>() <strong class="ly iu">}</strong>,<br/>        <strong class="ly iu">{ </strong><em class="ol">println</em>("This neither!") <strong class="ly iu">}</strong>)</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi om"><img src="../Images/86ac42207d532f3207612aae723b0d36.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*QnrhRZtPRvdYVO_FVJwgPA.png"/></div></div></figure><p id="3475" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe lv lw lx ly b">onErrorResumeNext()</code> <strong class="lb iu"> </strong>指示一个<code class="fe lv lw lx ly b">ObservableSource</code>将控制传递给另一个<code class="fe lv lw lx ly b">ObservableSource</code>，而不是调用<code class="fe lv lw lx ly b">Observer.onError()</code>，如果它在序列链中遇到错误。</p><p id="6ec8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果您将另一个<code class="fe lv lw lx ly b">ObservableSource</code>恢复序列传递给一个<code class="fe lv lw lx ly b">ObservableSource</code>的<code class="fe lv lw lx ly b">onErrorResumeNext()</code>方法，如果原来的<code class="fe lv lw lx ly b">ObservableSource</code>遇到错误，它不会调用其<code class="fe lv lw lx ly b">Observer</code>的<code class="fe lv lw lx ly b">onError()</code>方法，而是将控制权让给<strong class="lb iu">恢复序列</strong>，后者将调用<code class="fe lv lw lx ly b">Observer</code>的<code class="fe lv lw lx ly b">onNext()</code>方法，如果它能够这样做的话。在这种情况下，<code class="fe lv lw lx ly b">Observer</code>可能永远不会知道发生了错误。您可以使用它来防止错误传播，或者在遇到错误时提供回退数据。</p><pre class="kj kk kl km gt od ly oe of aw og bi"><span id="d39d" class="lz ma it ly b gy oh oi l oj ok">val observable = Observable.<strong class="ly iu">fromCallable</strong> <strong class="ly iu">{<br/>    </strong>if (Math.random() &lt; 0.5) {<br/>        throw IOException()<br/>    }<br/>    throw IllegalArgumentException()<br/><strong class="ly iu">}<br/><br/></strong>val result = observable.<strong class="ly iu">onErrorResumeNext</strong> <strong class="ly iu">{ </strong>error <strong class="ly iu">-&gt;<br/>    </strong>if (error is IllegalArgumentException) {<br/>        return@onErrorResumeNext Observable.empty()<br/>    }<br/>    Observable.error(error)<br/><strong class="ly iu">}</strong></span><span id="1716" class="lz ma it ly b gy oq oi l oj ok">for (i in 0..9) {<br/>    result.subscribe(<br/>            <strong class="ly iu">{ </strong>v <strong class="ly iu">-&gt; </strong><em class="ol">println</em>("This should never be printed!") <strong class="ly iu">}</strong>,<br/>            <strong class="ly iu">{ </strong>error <strong class="ly iu">-&gt; </strong>error.<em class="ol">printStackTrace</em>() <strong class="ly iu">}</strong>,<br/>            <strong class="ly iu">{ </strong><em class="ol">println</em>("Done") <strong class="ly iu">}</strong>)<br/>}</span></pre></div><div class="ab cl nl nm hx nn" role="separator"><span class="no bw bk np nq nr"/><span class="no bw bk np nq nr"/><span class="no bw bk np nq"/></div><div class="im in io ip iq"><h1 id="cb32" class="ns ma it bd mb nt nu nv me nw nx ny mh jz nz ka mk kc oa kd mn kf ob kg mq oc bi translated">范围()</h1><p id="d862" class="pw-post-body-paragraph kz la it lb b lc ms ju le lf mt jx lh li mu lk ll lm mv lo lp lq mw ls lt lu im bi translated"><code class="fe lv lw lx ly b">range()</code>创建一个发出特定范围的连续整数的<code class="fe lv lw lx ly b">Observable</code>。<code class="fe lv lw lx ly b">Range</code>操作符按顺序发出一系列连续的整数，您可以从中选择范围的开始及其长度。它为每个消费者生成一个价值序列。<code class="fe lv lw lx ly b">range()</code>方法生成<code class="fe lv lw lx ly b">Integer</code> s，<code class="fe lv lw lx ly b">rangeLong()</code>生成<code class="fe lv lw lx ly b">Long</code> s。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi or"><img src="../Images/b04987745983a2d74e06972e09f526b0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Kb-Ib1Jg4HENvm7nF6iV6Q.png"/></div></div></figure><pre class="kj kk kl km gt od ly oe of aw og bi"><span id="89a1" class="lz ma it ly b gy oh oi l oj ok">val greeting = "Hello World!"<br/><br/>val indexes = Observable.<strong class="ly iu">range</strong>(0, greeting.length)<br/><br/>val characters = indexes<br/>        .map <strong class="ly iu">{ </strong>index <strong class="ly iu">-&gt; </strong>greeting[index] <strong class="ly iu">}<br/><br/></strong>characters.subscribe(<strong class="ly iu">{ </strong>character <strong class="ly iu">-&gt; </strong><em class="ol">print</em>(character) <strong class="ly iu">}</strong>, <strong class="ly iu">{ </strong>error <strong class="ly iu">-&gt; </strong>error.printStackTrace() <strong class="ly iu">}</strong>,<br/>        <strong class="ly iu">{ </strong><em class="ol">println</em>() <strong class="ly iu">}</strong>)</span></pre></div><div class="ab cl nl nm hx nn" role="separator"><span class="no bw bk np nq nr"/><span class="no bw bk np nq nr"/><span class="no bw bk np nq"/></div><div class="im in io ip iq"><h1 id="a7b2" class="ns ma it bd mb nt nu nv me nw nx ny mh jz nz ka mk kc oa kd mn kf ob kg mq oc bi translated">间隔()</h1><p id="f742" class="pw-post-body-paragraph kz la it lb b lc ms ju le lf mt jx lh li mu lk ll lm mv lo lp lq mw ls lt lu im bi translated"><code class="fe lv lw lx ly b">interval()</code>创建一个<code class="fe lv lw lx ly b">Observable</code>，它发出一个由给定时间间隔分隔的整数序列。<code class="fe lv lw lx ly b">Interval</code>操作符返回一个<code class="fe lv lw lx ly b">Observable</code>，它发出一个无限的升序整数序列，在两次发射之间有一个您选择的固定时间间隔。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi or"><img src="../Images/b04987745983a2d74e06972e09f526b0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Kb-Ib1Jg4HENvm7nF6iV6Q.png"/></div></div></figure><pre class="kj kk kl km gt od ly oe of aw og bi"><span id="1d02" class="lz ma it ly b gy oh oi l oj ok">val clock = Observable.<strong class="ly iu">interval</strong>(1, TimeUnit.SECONDS)<br/><br/>clock.subscribe <strong class="ly iu">{ </strong>time <strong class="ly iu">-&gt;<br/>    </strong>if (time!! % 2 == 0L) {<br/>        <em class="ol">println</em>("Tick")<br/>    } else {<br/>        <em class="ol">println</em>("Tock")<br/>    }<br/><strong class="ly iu">}</strong></span></pre></div><div class="ab cl nl nm hx nn" role="separator"><span class="no bw bk np nq nr"/><span class="no bw bk np nq nr"/><span class="no bw bk np nq"/></div><div class="im in io ip iq"><h1 id="f457" class="ns ma it bd mb nt nu nv me nw nx ny mh jz nz ka mk kc oa kd mn kf ob kg mq oc bi translated">计时器()</h1><p id="5d02" class="pw-post-body-paragraph kz la it lb b lc ms ju le lf mt jx lh li mu lk ll lm mv lo lp lq mw ls lt lu im bi translated"><code class="fe lv lw lx ly b">timer()</code>创建一个<code class="fe lv lw lx ly b">Observable</code>，它在我们指定的给定延迟后发出一个特定的项目。</p><pre class="kj kk kl km gt od ly oe of aw og bi"><span id="f62d" class="lz ma it ly b gy oh oi l oj ok">val eggTimer = Observable.<strong class="ly iu">timer</strong>(5, TimeUnit.MINUTES)<br/><br/>eggTimer.blockingSubscribe <strong class="ly iu">{ </strong>v <strong class="ly iu">-&gt; </strong><em class="ol">println</em>("Egg is ready!") <strong class="ly iu">}</strong></span></pre></div><div class="ab cl nl nm hx nn" role="separator"><span class="no bw bk np nq nr"/><span class="no bw bk np nq nr"/><span class="no bw bk np nq"/></div><div class="im in io ip iq"><h1 id="5a4b" class="ns ma it bd mb nt nu nv me nw nx ny mh jz nz ka mk kc oa kd mn kf ob kg mq oc bi translated">从</h1><p id="fc8f" class="pw-post-body-paragraph kz la it lb b lc ms ju le lf mt jx lh li mu lk ll lm mv lo lp lq mw ls lt lu im bi translated"><code class="fe lv lw lx ly b">from</code>用于将各种其他对象和数据类型转换为<code class="fe lv lw lx ly b">Observable</code>。<strong class="lb iu"/>当我们处理<code class="fe lv lw lx ly b">Observable</code>时，如果您想要处理的所有数据都可以表示为<code class="fe lv lw lx ly b">Observable</code> s，而不是表示为<code class="fe lv lw lx ly b">Observable</code> s和其他类型的混合，会更加方便。这允许您使用一组操作符来管理数据流的整个生命周期。</p></div><div class="ab cl nl nm hx nn" role="separator"><span class="no bw bk np nq nr"/><span class="no bw bk np nq nr"/><span class="no bw bk np nq"/></div><div class="im in io ip iq"><h1 id="7361" class="ns ma it bd mb nt nu nv me nw nx ny mh jz nz ka mk kc oa kd mn kf ob kg mq oc bi translated">fromIterable()</h1><p id="447f" class="pw-post-body-paragraph kz la it lb b lc ms ju le lf mt jx lh li mu lk ll lm mv lo lp lq mw ls lt lu im bi translated"><code class="fe lv lw lx ly b">fromIterable()</code>向来自<code class="fe lv lw lx ly b">java.lang.Iterable</code>源(如<code class="fe lv lw lx ly b">List</code> s、<code class="fe lv lw lx ly b">Set</code> s或<code class="fe lv lw lx ly b">Collection</code> s或<code class="fe lv lw lx ly b">custom Iterable</code> s)的项目发送信号，然后完成序列。将<code class="fe lv lw lx ly b">Iterable</code>序列转换为发出序列中项目的<code class="fe lv lw lx ly b">ObservableSource</code>。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi or"><img src="../Images/b04987745983a2d74e06972e09f526b0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Kb-Ib1Jg4HENvm7nF6iV6Q.png"/></div></div></figure><pre class="kj kk kl km gt od ly oe of aw og bi"><span id="41bb" class="lz ma it ly b gy oh oi l oj ok">val numbers = ArrayList&lt;Int&gt;()<br/>numbers.add(1)<br/>numbers.add(2)<br/>numbers.add(3)<br/>numbers.add(4)<br/>val fromObservable = Observable.<strong class="ly iu">fromIterable</strong>(numbers)</span></pre></div><div class="ab cl nl nm hx nn" role="separator"><span class="no bw bk np nq nr"/><span class="no bw bk np nq nr"/><span class="no bw bk np nq"/></div><div class="im in io ip iq"><h2 id="3cf9" class="lz ma it bd mb mc md dn me mf mg dp mh li mi mj mk lm ml mm mn lq mo mp mq mr bi translated">fromArray()</h2><p id="4676" class="pw-post-body-paragraph kz la it lb b lc ms ju le lf mt jx lh li mu lk ll lm mv lo lp lq mw ls lt lu im bi translated"><code class="fe lv lw lx ly b">fromArray()</code>将<code class="fe lv lw lx ly b">Array</code>转换为<code class="fe lv lw lx ly b">ObservableSource</code>，发出<code class="fe lv lw lx ly b">Array</code>中的项目。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi or"><img src="../Images/b04987745983a2d74e06972e09f526b0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Kb-Ib1Jg4HENvm7nF6iV6Q.png"/></div></div></figure><pre class="kj kk kl km gt od ly oe of aw og bi"><span id="17ed" class="lz ma it ly b gy oh oi l oj ok">val observable = Observable.<strong class="ly iu">fromArray</strong>(array)<br/><br/>observable.subscribe(<br/>        <strong class="ly iu">{ </strong>item <strong class="ly iu">-&gt; </strong><em class="ol">println</em>(item) <strong class="ly iu">}</strong>, <br/>        <strong class="ly iu">{ </strong>error <strong class="ly iu">-&gt; </strong>error.printStackTrace() <strong class="ly iu">}</strong>,<br/>        <strong class="ly iu">{ </strong><em class="ol">println</em>("Done") <strong class="ly iu">}</strong>)</span></pre><p id="1e75" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu"> <em class="ol">注意</em> </strong> <em class="ol"> : RxJava不支持原语数组，只支持(泛型)引用数组。</em></p></div><div class="ab cl nl nm hx nn" role="separator"><span class="no bw bk np nq nr"/><span class="no bw bk np nq nr"/><span class="no bw bk np nq"/></div><div class="im in io ip iq"><h1 id="f708" class="ns ma it bd mb nt nu nv me nw nx ny mh jz nz ka mk kc oa kd mn kf ob kg mq oc bi translated">fromCallable()</h1><p id="0e69" class="pw-post-body-paragraph kz la it lb b lc ms ju le lf mt jx lh li mu lk ll lm mv lo lp lq mw ls lt lu im bi translated">当消费者订阅时，调用给定的<code class="fe lv lw lx ly b">java.util.concurrent.Callable</code>,其返回值(或抛出的异常)被传递给该消费者。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi op"><img src="../Images/1ef2bf3c83ab62db56e32a1b69531d03.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*V6vwGWv8x_I-qQayT-4F2Q.png"/></div></div></figure><p id="87c0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">换句话说，它返回一个<code class="fe lv lw lx ly b">Observable</code>,当观察者订阅它时，它调用您指定的函数，然后发出从该函数返回的值。这允许您推迟执行您指定的函数，直到观察者订阅了<code class="fe lv lw lx ly b">ObservableSource</code>。也就是说，它让函数变得“懒惰”</p><pre class="kj kk kl km gt od ly oe of aw og bi"><span id="ef3d" class="lz ma it ly b gy oh oi l oj ok">val callable = <em class="ol">Callable </em><strong class="ly iu">{<br/>    </strong><em class="ol">println</em>("Hello World!")<br/>    return@Callable ("Hello World!")<br/><strong class="ly iu">}<br/></strong>val observable = Observable.<strong class="ly iu">fromCallable</strong>(callable)<br/><br/>observable.subscribe(<br/>        <strong class="ly iu">{ </strong>item <strong class="ly iu">-&gt; </strong><em class="ol">println</em>(item) <strong class="ly iu">}</strong>, <br/>        <strong class="ly iu">{ </strong>error <strong class="ly iu">-&gt; </strong>error.printStackTrace() <strong class="ly iu">}</strong>,<br/>        <strong class="ly iu">{ </strong><em class="ol">println</em>("Done") <strong class="ly iu">}</strong>)</span></pre></div><div class="ab cl nl nm hx nn" role="separator"><span class="no bw bk np nq nr"/><span class="no bw bk np nq nr"/><span class="no bw bk np nq"/></div><div class="im in io ip iq"><h2 id="49ae" class="lz ma it bd mb mc md dn me mf mg dp mh li mi mj mk lm ml mm mn lq mo mp mq mr bi translated">fromAction()</h2><p id="3d2e" class="pw-post-body-paragraph kz la it lb b lc ms ju le lf mt jx lh li mu lk ll lm mv lo lp lq mw ls lt lu im bi translated"><code class="fe lv lw lx ly b">fromAction()</code>返回一个<code class="fe lv lw lx ly b">Completable</code>实例，该实例为每个订阅者运行给定的<code class="fe lv lw lx ly b">Action</code>，并发出一个未检查的异常或简单地完成。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi os"><img src="../Images/d796c5d1f9e3d0fdab6bc347ffe45c6b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ZOssoKUpipolYBYe6flyqQ.png"/></div></div></figure><pre class="kj kk kl km gt od ly oe of aw og bi"><span id="f14d" class="lz ma it ly b gy oh oi l oj ok">val action = <em class="ol">Action</em><strong class="ly iu">{ </strong><em class="ol">println</em>("Hello World!") <strong class="ly iu">}<br/><br/></strong>val completable = Completable.<strong class="ly iu">fromAction</strong>(action)<br/><br/>completable.subscribe(<br/>        <strong class="ly iu">{ </strong><em class="ol">println</em>("Done") <strong class="ly iu">}</strong>, <br/>        <strong class="ly iu">{ </strong>error <strong class="ly iu">-&gt; </strong>error.printStackTrace() <strong class="ly iu">}<br/></strong>)</span></pre></div><div class="ab cl nl nm hx nn" role="separator"><span class="no bw bk np nq nr"/><span class="no bw bk np nq nr"/><span class="no bw bk np nq"/></div><div class="im in io ip iq"><h1 id="a0b8" class="ns ma it bd mb nt nu nv me nw nx ny mh jz nz ka mk kc oa kd mn kf ob kg mq oc bi translated">fromRunnable()</h1><p id="d2b6" class="pw-post-body-paragraph kz la it lb b lc ms ju le lf mt jx lh li mu lk ll lm mv lo lp lq mw ls lt lu im bi translated"><code class="fe lv lw lx ly b">fromRunnable()</code>返回一个<code class="fe lv lw lx ly b">Completable</code>实例，该实例订阅给定的可观察对象，忽略所有值，只发出终端事件。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi os"><img src="../Images/d796c5d1f9e3d0fdab6bc347ffe45c6b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ZOssoKUpipolYBYe6flyqQ.png"/></div></div></figure><pre class="kj kk kl km gt od ly oe of aw og bi"><span id="8934" class="lz ma it ly b gy oh oi l oj ok">val runnable = <strong class="ly iu">{ </strong><em class="ol">println</em>("Hello World!") <strong class="ly iu">}<br/><br/></strong>val completable1 = Completable.<strong class="ly iu">fromRunnable</strong>(runnable)<br/><br/>completable.subscribe(<br/>        <strong class="ly iu">{ </strong><em class="ol">println</em>("Done") <strong class="ly iu">}</strong>,<br/>        <strong class="ly iu">{ </strong>error <strong class="ly iu">-&gt; </strong>error.printStackTrace() <strong class="ly iu">}<br/></strong>)</span></pre><p id="18e0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu"> <em class="ol">注意</em></strong><em class="ol">:</em><code class="fe lv lw lx ly b">fromAction</code><em class="ol">和</em> <code class="fe lv lw lx ly b">fromRunnable</code> <em class="ol">的区别在于</em> <code class="fe lv lw lx ly b">Action</code> <em class="ol">接口允许抛出被检查的异常，而</em> <code class="fe lv lw lx ly b">java.lang.Runnable</code> <em class="ol">不允许。</em></p></div><div class="ab cl nl nm hx nn" role="separator"><span class="no bw bk np nq nr"/><span class="no bw bk np nq nr"/><span class="no bw bk np nq"/></div><div class="im in io ip iq"><h2 id="56e2" class="lz ma it bd mb mc md dn me mf mg dp mh li mi mj mk lm ml mm mn lq mo mp mq mr bi translated">来自未来()</h2><p id="a52d" class="pw-post-body-paragraph kz la it lb b lc ms ju le lf mt jx lh li mu lk ll lm mv lo lp lq mw ls lt lu im bi translated"><code class="fe lv lw lx ly b">fromFuture()</code>将一个<code class="fe lv lw lx ly b">java.util.concurrent.Future</code> <strong class="lb iu"> </strong>转换成一个<code class="fe lv lw lx ly b">ObservableSource</code>。通过将对象传递到<code class="fe lv lw lx ly b">from()</code>方法，我们可以将任何支持<code class="fe lv lw lx ly b">Future</code>接口的对象转换成发出该对象的<code class="fe lv lw lx ly b">Future.get()</code>方法的返回值的<code class="fe lv lw lx ly b">ObservableSource</code>。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi op"><img src="../Images/1ef2bf3c83ab62db56e32a1b69531d03.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*V6vwGWv8x_I-qQayT-4F2Q.png"/></div></div></figure><pre class="kj kk kl km gt od ly oe of aw og bi"><span id="e207" class="lz ma it ly b gy oh oi l oj ok">val executor = Executors.newSingleThreadScheduledExecutor()<br/><br/>val future = executor.schedule(<strong class="ly iu">{ </strong>"Hello world!" <strong class="ly iu">}</strong>, 1, TimeUnit.SECONDS)<br/><br/>val observable = Observable.<strong class="ly iu">fromFuture</strong>&lt;String&gt;(future)<br/><br/>observable.subscribe(<br/>        <strong class="ly iu">{ </strong>item <strong class="ly iu">-&gt; </strong><em class="ol">println</em>(item) <strong class="ly iu">}</strong>,<br/>        <strong class="ly iu">{ </strong>error <strong class="ly iu">-&gt; </strong>error.printStackTrace() <strong class="ly iu">}</strong>,<br/>        <strong class="ly iu">{ </strong><em class="ol">println</em>("Done") <strong class="ly iu">}</strong>)</span></pre><p id="a117" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这还不是关于可观测量的所有知识——还有更多。</p></div><div class="ab cl nl nm hx nn" role="separator"><span class="no bw bk np nq nr"/><span class="no bw bk np nq nr"/><span class="no bw bk np nq"/></div><div class="im in io ip iq"><h1 id="a629" class="ns ma it bd mb nt nu nv me nw nx ny mh jz nz ka mk kc oa kd mn kf ob kg mq oc bi translated">奖金</h1><p id="f93a" class="pw-post-body-paragraph kz la it lb b lc ms ju le lf mt jx lh li mu lk ll lm mv lo lp lq mw ls lt lu im bi translated">渴望了解更多关于Rx的信息，请继续阅读RxJava 上的系列<a class="ae ky" href="https://medium.com/@pavan.careers5208/complete-guide-on-rxjava-d997235e4eec" rel="noopener">完整指南。</a></p></div><div class="ab cl nl nm hx nn" role="separator"><span class="no bw bk np nq nr"/><span class="no bw bk np nq nr"/><span class="no bw bk np nq"/></div><div class="im in io ip iq"><h1 id="6548" class="ns ma it bd mb nt nu nv me nw nx ny mh jz nz ka mk kc oa kd mn kf ob kg mq oc bi translated"><strong class="ak">参考文献</strong></h1><p id="bc8f" class="pw-post-body-paragraph kz la it lb b lc ms ju le lf mt jx lh li mu lk ll lm mv lo lp lq mw ls lt lu im bi translated"><a class="ae ky" href="http://reactivex.io/documentation/operators.html" rel="noopener ugc nofollow" target="_blank">创建可观测量</a></p></div><div class="ab cl nl nm hx nn" role="separator"><span class="no bw bk np nq nr"/><span class="no bw bk np nq nr"/><span class="no bw bk np nq"/></div><div class="im in io ip iq"><p id="be4f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">请让我知道你的建议和意见。感谢您的阅读。</p></div></div>    
</body>
</html>