<html>
<head>
<title>Using React 17 With Phoenix 1.5</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">将React 17与Phoenix 1.5一起使用</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/using-react-17-with-phoenix-1-5-1b445526c739?source=collection_archive---------6-----------------------#2021-01-05">https://betterprogramming.pub/using-react-17-with-phoenix-1-5-1b445526c739?source=collection_archive---------6-----------------------#2021-01-05</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="17cb" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">向Phoenix应用程序添加React组件的增量方法</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/53e1bcc8963dc6523b7b68f74c85dd10.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Q3L0ebox4K8wfG1IWzR0Yg.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">图片来源:作者</p></figure><p id="afe9" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">我最近开始使用Elixir和React实现一个高度交互式的、基于web的生产力工具。下面是我如何在需要的地方向Phoenix视图添加React组件。你可以在这里找到<a class="ae lu" href="https://github.com/donrestarone/integrate-react-with-phoenix" rel="noopener ugc nofollow" target="_blank">的源代码</a>。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi lv"><img src="../Images/d03da2634a60d85cc93e1adcd52363ce.png" data-original-src="https://miro.medium.com/v2/resize:fit:1200/1*XhBBU2X_9svFyWkr7gwvxw.gif"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">这是我整理出来的概念证明。它并不复杂——只是一个很酷的小React项目的所有成分。</p></figure></div><div class="ab cl lw lx hx ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="im in io ip iq"><h2 id="2384" class="md me it bd mf mg mh dn mi mj mk dp ml lh mm mn mo ll mp mq mr lp ms mt mu mv bi translated">目标</h2><p id="310b" class="pw-post-body-paragraph ky kz it la b lb mw ju ld le mx jx lg lh my lj lk ll mz ln lo lp na lr ls lt im bi translated">我不想完全致力于客户端呈现的视图，因为当你独自工作时会变得单调乏味，而且这不是搜索引擎优化的最佳选择。我想在应用程序的大部分地方使用服务器端渲染，除了需要高用户交互性的区域。</p><p id="da5a" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">对我来说，理想的方法是简单地将React组件与服务器呈现的HTML打包在一起。</p><p id="515e" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">如果您想以视频形式跟进:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nb nc l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">在这个视频中，我遵循了本文中概述的相同步骤</p></figure></div><div class="ab cl lw lx hx ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="im in io ip iq"><h1 id="0430" class="nd me it bd mf ne nf ng mi nh ni nj ml jz nk ka mo kc nl kd mr kf nm kg mu nn bi translated">Phoenix后端配置</h1><p id="4b18" class="pw-post-body-paragraph ky kz it la b lb mw ju ld le mx jx lg lh my lj lk ll mz ln lo lp na lr ls lt im bi translated">我首先导航到<code class="fe no np nq nr b">/assets</code>目录，安装必要的前端依赖项和<code class="fe no np nq nr b">yarn</code>。</p><pre class="kj kk kl km gt ns nr nt nu aw nv bi"><span id="810f" class="md me it nr b gy nw nx l ny nz">cd assets<br/>yarn add @babel/preset-react react react-dom remount</span></pre><p id="e8d3" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">如果您想继续做下去，构建和我一样的东西，您也可以添加这些额外的JavaScript依赖项:</p><pre class="kj kk kl km gt ns nr nt nu aw nv bi"><span id="bf6c" class="md me it nr b gy nw nx l ny nz">yarn add @babel/preset-react react react-dom remount react-zoom-pan-pinch react-grid-layout faker</span></pre><p id="ca22" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">在<code class="fe no np nq nr b">router.ex</code>中，我添加了一个路径和控制器动作，它将为带有React组件的页面提供服务。在第19行，Phoenix将把到达根路径的请求路由到<code class="fe no np nq nr b">HomeController</code>的索引方法。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oa nc l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">lib/workshop_web/router.ex</p></figure><p id="2856" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">接下来，我为控制器安装了最简单的管道。你可以在第8行看到传递道具的策略，Phoenix可以传递任意地图，并使用<code class="fe no np nq nr b">Jason</code>将其编码为JSON字符串。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oa nc l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">lib/workshop _ web/controllers/home _ controller . ex</p></figure><p id="0240" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">接下来是必不可少的视图功能。我总是忘记为新的控制器实现这些，直到Phoenix抛出一个错误来提醒我。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oa nc l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">lib/workshop _ web/views/home _ view . ex</p></figure><p id="47a8" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">在<code class="fe no np nq nr b">lib/workshop_web/templates/layout/app.html.eex</code>创建了一个空白的Elixir HTML文档后，我已经做好了向JavaScript领域前进的准备。</p></div><div class="ab cl lw lx hx ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="im in io ip iq"><h1 id="4303" class="nd me it bd mf ne nf ng mi nh ni nj ml jz nk ka mo kc nl kd mr kf nm kg mu nn bi translated">凤凰前端配置</h1><p id="5f0a" class="pw-post-body-paragraph ky kz it la b lb mw ju ld le mx jx lg lh my lj lk ll mz ln lo lp na lr ls lt im bi translated">我删除了Phoenix附带的默认<code class="fe no np nq nr b">assets/.babelrc</code>文件，创建了一个名为<code class="fe no np nq nr b">assets/babel.config.js</code>的新的Babel配置，并添加了以下代码:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oa nc l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">assets/babel.config.js</p></figure><p id="62fd" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">这将允许凤凰处理JSX标记。接下来我配置了webpack，这样我就可以使用CSS导入并享受类似于<code class="fe no np nq nr b">create-react-app</code>的工作流程。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oa nc l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">assets/webpack.config.js</p></figure><p id="7946" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">现在，Phoenix将能够处理JSX、CSS导入和其他相关的一切。是时候创建一些文件夹来存放React应用程序了。</p><p id="5c4f" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">我在<code class="fe no np nq nr b">assets/js</code>下创建了一个子文件夹，命名为<code class="fe no np nq nr b">react</code>，并创建了以下子文件夹以保持有序。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ob"><img src="../Images/dc88c830f0b59d8dfa4c456581057ee1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ZKdwSllYn2aIAvzHps6VcA.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">图片来源:作者</p></figure><p id="4f6e" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">JavaScript执行的入口点将发生在<code class="fe no np nq nr b">index.js</code>:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oa nc l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">assets/js/react/src/Index.js</p></figure><p id="ffee" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">在这里，我只是简单地导入<code class="fe no np nq nr b">remount</code>和我需要的任何组件，然后将每个组件映射到定制的HTML元素名称。可以在视图中引用这些元素名称，以便在需要的地方呈现React组件。</p><p id="170e" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">为了让Phoenix知道HTML-to-React组件映射，我通过简单地在<code class="fe no np nq nr b">assets/js/app.js</code>中添加下面一行来将入口点导入主应用程序:</p><pre class="kj kk kl km gt ns nr nt nu aw nv bi"><span id="71c4" class="md me it nr b gy nw nx l ny nz">import "./react/src/Index.js"</span></pre><p id="a7ac" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">随着终点线在望，我继续复制我之前在<code class="fe no np nq nr b">create-react-app</code>中的原型。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oa nc l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">assets/js/react/src/App.js</p></figure><p id="6b06" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">动态生成虚拟数据的功能:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oa nc l"/></div></figure><p id="c65d" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">有了这些，我所要做的就是在我之前创建的Elixir HTML模板中安装React组件。在<code class="fe no np nq nr b">lib/workshop_web/templates/home/index.html.eex</code>中，我为此插入了一个小程序:</p><pre class="kj kk kl km gt ns nr nt nu aw nv bi"><span id="e0e8" class="md me it nr b gy nw nx l ny nz">&lt;x-application props-json='&lt;%= @props %&gt;' &gt;&lt;/x-application&gt;</span></pre><p id="9d83" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated"><code class="fe no np nq nr b">x-application</code>映射到组件<code class="fe no np nq nr b">&lt;App/&gt;</code>并且<code class="fe no np nq nr b">props-json</code>属性将用于将JSON数据从Phoenix控制器传递到<code class="fe no np nq nr b">&lt;App/&gt;</code>。</p><p id="594c" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">就位后，我转动钥匙，强大的凤凰反应引擎轰鸣着启动了。</p></div><div class="ab cl lw lx hx ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="im in io ip iq"><h1 id="de19" class="nd me it bd mf ne nf ng mi nh ni nj ml jz nk ka mo kc nl kd mr kf nm kg mu nn bi translated">但是等等，有一个问题！</h1><p id="eceb" class="pw-post-body-paragraph ky kz it la b lb mw ju ld le mx jx lg lh my lj lk ll mz ln lo lp na lr ls lt im bi translated">在测试期间，我注意到在除了Firefox之外的任何其他浏览器上，<code class="fe no np nq nr b">react-zoom-pan-pinch</code>都在呈现一个不可见的DOM。问题出在CSS中，解决方法很简单——但是它证明了CSS导入也适用于这种设置:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oa nc l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">assets/js/react/src/index.css</p></figure><p id="5c3f" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">就是这样！如果你像我一样，你现在可以享受在Phoenix中构建和使用React组件，直到你学会LiveView。</p></div><div class="ab cl lw lx hx ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="im in io ip iq"><p id="adf0" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated"><a class="ae lu" href="https://www.linkedin.com/in/shashike-jayatunge/" rel="noopener ugc nofollow" target="_blank">沙西克</a>是一名来自多伦多的软件工程师，也是<a class="ae lu" href="https://www.restarone.com" rel="noopener ugc nofollow" target="_blank"> Restarone Inc </a>的创始人。当他不开发软件时，他就在Medium和YouTube上创作内容，帮助人们过渡到技术领域。</p></div></div>    
</body>
</html>