<html>
<head>
<title>10 Useful Kotlin String Extensions</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">10个有用的Kotlin字符串扩展</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/10-useful-kotlin-string-extensions-46772b653f71?source=collection_archive---------6-----------------------#2020-03-15">https://betterprogramming.pub/10-useful-kotlin-string-extensions-46772b653f71?source=collection_archive---------6-----------------------#2020-03-15</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="47f5" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">用于电子邮件验证、JSON解析等的语法糖</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/d9db8562cf2a10beb09eb1a2bf5f894b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*kd62ng52rNTY9KIgFJ8CHA.png"/></div></div></figure><p id="0243" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">Kotlin是一种相对较新的编程语言。它基于Java，Kotlin代码在JVM中工作。也可以编译成原生应用(Kotlin Native)和JavaScript应用(Kotlin JS)。</p><p id="cf18" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">作为一名Android开发者，我很高兴获得比Java更现代的语言。2017年谷歌宣布Kotlin为Android开发的官方语言；2019年，他们宣布Android将“Kotlin-first”。为什么Kotlin比Java好？</p><ol class=""><li id="0820" class="lq lr it kw b kx ky la lb ld ls lh lt ll lu lp lv lw lx ly bi translated">Kotlin支持选项。选装件有助于避免许多事故。</li><li id="ec4f" class="lq lr it kw b kx lz la ma ld mb lh mc ll md lp lv lw lx ly bi translated">科特林更简洁。更少的核心，更容易阅读，更容易维护。</li><li id="a01a" class="lq lr it kw b kx lz la ma ld mb lh mc ll md lp lv lw lx ly bi translated"><strong class="kw iu">科特林支持扩展。</strong></li></ol><p id="6530" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">今天我们将谈论<code class="fe me mf mg mh b">string</code>扩展，它将使你的代码更短，更安全，总体上更好。</p><p id="3de0" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">这些扩展适用于Kotlin 1.3.70，但它们也必须兼容其他版本。我在Java环境中工作，所以我不能保证它们在Kotlin/Native和Kotlin/JS中也能工作。</p><p id="ee4d" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated"><em class="mi">如果你也是iOS或Mac开发者，你可能会对我的文章</em> <a class="ae mj" href="https://medium.com/better-programming/10-useful-swift-string-extensions-e4280e55a554" rel="noopener"> <em class="mi"> 10个有用的Swift字符串扩展</em> </a> <em class="mi">感兴趣。</em></p></div><div class="ab cl mk ml hx mm" role="separator"><span class="mn bw bk mo mp mq"/><span class="mn bw bk mo mp mq"/><span class="mn bw bk mo mp"/></div><div class="im in io ip iq"><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi mr"><img src="../Images/0e83a8d3235306ae00062fe1cfb3d7c1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*-7Y1aJA778v9xN_1"/></div></div><p class="ms mt gj gh gi mu mv bd b be z dk translated">Jonathan Chng 在<a class="ae mj" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</p></figure><h1 id="f468" class="mw mx it bd my mz na nb nc nd ne nf ng jz nh ka ni kc nj kd nk kf nl kg nm nn bi translated">1.MD5/SHA哈希计算器</h1><p id="c0f5" class="pw-post-body-paragraph ku kv it kw b kx no ju kz la np jx lc ld nq lf lg lh nr lj lk ll ns ln lo lp im bi translated">为什么我们要计算一个<code class="fe me mf mg mh b">string</code>的MD5？原因可能有很多。在数据库中保存密码，通过不安全的通道进行一些验证，检查文件是否计算正确。SHA哈希也是如此。</p><p id="8fe5" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">让我们从MD5开始:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nt nu l"/></div></figure><p id="e9c1" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated"><code class="fe me mf mg mh b">md5</code>这里是一个计算的属性(也可以作为一个函数)。首先，我们使用java.security.MessageDigest计算MD5 hash作为字节数组。然后，我们将字节数组转换为十六进制字符串。</p><p id="723f" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">SHA-1是“安全哈希算法— 1”。一般SHA是一组算法。从编程的角度来看，这两者没有太大的区别；我们只需要在<code class="fe me mf mg mh b">MessageDigest.getInstance()</code>调用中改变算法名称。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nt nu l"/></div></figure><h2 id="d345" class="nv mx it bd my nw nx dn nc ny nz dp ng ld oa ob ni lh oc od nk ll oe of nm og bi translated">如何使用它</h2><pre class="kj kk kl km gt oh mh oi oj aw ok bi"><span id="a958" class="nv mx it mh b gy ol om l on oo"><strong class="mh iu">val</strong> md5Hash = "test".md5 // 098f6bcd4621d373cade4e832627b4f6<br/><strong class="mh iu">val</strong> sha1Hash = "test".sha1 // a94a8fe5ccb19ba61c4c0873d391e987982fbbd3</span></pre></div><div class="ab cl mk ml hx mm" role="separator"><span class="mn bw bk mo mp mq"/><span class="mn bw bk mo mp mq"/><span class="mn bw bk mo mp"/></div><div class="im in io ip iq"><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi op"><img src="../Images/d524670e95e5882d1a3940b936ab1e2b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*WIZ4ZT-nMbNUMwFd"/></div></div><p class="ms mt gj gh gi mu mv bd b be z dk translated">照片由<a class="ae mj" href="https://unsplash.com/@davideibiza?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">大卫·巴拉迪</a>在<a class="ae mj" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>拍摄</p></figure><h1 id="6300" class="mw mx it bd my mz na nb nc nd ne nf ng jz nh ka ni kc nj kd nk kf nl kg nm nn bi translated">2.检查字符串是否是有效的电子邮件地址</h1><p id="de84" class="pw-post-body-paragraph ku kv it kw b kx no ju kz la np jx lc ld nq lf lg lh nr lj lk ll ns ln lo lp im bi translated">检查电子邮件地址的有效性是一个非常常见的功能。从我的个人经验来看，10个Android应用中有9个允许或要求用户认证。10个有认证的应用程序中有9个允许电子邮件/密码作为方法之一。这是一个很好的做法，检查输入的电子邮件地址，然后再发送到服务器，而不是浪费互联网流量，使不成功的注册/登录电话。如果您开发后端，在将电子邮件地址保存到数据库之前对其进行验证是至关重要的。</p><p id="5e9d" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">验证电子邮件地址最简单的方法是使用正则表达式。你可以根据需要调整表达方式。我将展示我为自己选择的内容:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nt nu l"/></div></figure><p id="b661" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">这个扩展提供了一个功能，但是计算属性也是一个选项。</p><h2 id="27c5" class="nv mx it bd my nw nx dn nc ny nz dp ng ld oa ob ni lh oc od nk ll oe of nm og bi translated">如何使用它</h2><pre class="kj kk kl km gt oh mh oi oj aw ok bi"><span id="6b29" class="nv mx it mh b gy ol om l on oo"><strong class="mh iu">val</strong> email = "test@email.com"<br/>if (email.isEmailValid()) {<br/>    <em class="mi">print</em>("Email is valid. Continue registration")<br/>} else {<br/>    <em class="mi">print</em>("Email is not validate. Show error")<br/>}</span></pre></div><div class="ab cl mk ml hx mm" role="separator"><span class="mn bw bk mo mp mq"/><span class="mn bw bk mo mp mq"/><span class="mn bw bk mo mp"/></div><div class="im in io ip iq"><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi oq"><img src="../Images/61c2c6e0adfc82e3d3a6aa0ddfcc2a17.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*zcw9VBEAyZXwSh8o"/></div></div><p class="ms mt gj gh gi mu mv bd b be z dk translated">照片由<a class="ae mj" href="https://unsplash.com/@quinoal?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">奎诺·阿尔</a>在<a class="ae mj" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</p></figure><h1 id="0c35" class="mw mx it bd my mz na nb nc nd ne nf ng jz nh ka ni kc nj kd nk kf nl kg nm nn bi translated">3.验证和格式化电话号码</h1><p id="9844" class="pw-post-body-paragraph ku kv it kw b kx no ju kz la np jx lc ld nq lf lg lh nr lj lk ll ns ln lo lp im bi translated">与电子邮件类似，电话号码可能需要验证，更重要的是，需要格式化。电话号码只有国家代码是唯一的，但用户通常不输入它(他们通常改变国旗的国家名称)。这是与电子邮件的显著区别。</p><p id="e6d1" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">此外，不同国家的电话号码有不同的格式。这就是为什么它只能用外部库来完成。</p><p id="bc44" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">对于JVM代码，有Google库<a class="ae mj" href="https://github.com/google/libphonenumber" rel="noopener ugc nofollow" target="_blank"> libphonenumber </a>。有一个针对<a class="ae mj" href="https://github.com/MichaelRocks/libphonenumber-android" rel="noopener ugc nofollow" target="_blank"> libphonenumber-android </a>的特别改编。他们几乎一模一样。</p><h2 id="7d17" class="nv mx it bd my nw nx dn nc ny nz dp ng ld oa ob ni lh oc od nk ll oe of nm og bi translated">JVM版本</h2><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nt nu l"/></div></figure><p id="dfd2" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">如果有效，这个函数返回一个格式化的电话号码(以“+”和国家代码开头),否则返回<code class="fe me mf mg mh b">null</code>。区域是从列表中选择的国家。如果应用程序是针对一个国家，它可以是硬编码的价值。</p><h2 id="9b6f" class="nv mx it bd my nw nx dn nc ny nz dp ng ld oa ob ni lh oc od nk ll oe of nm og bi translated">如何使用它</h2><pre class="kj kk kl km gt oh mh oi oj aw ok bi"><span id="fdf3" class="nv mx it mh b gy ol om l on oo"><strong class="mh iu">val</strong> phone = "(202)555-0156" // Phone number is fake, but has valid format<br/><strong class="mh iu">val</strong> formattedPhone = phone.<em class="mi">formatPhoneNumber</em>("US")<br/>if (formattedPhone == <strong class="mh iu">null</strong>) {<br/>    <em class="mi">println</em>("Phone number is not valid")<br/>} else {<br/>    <em class="mi">println</em>("Sending $formattedPhone to API")<br/>}</span></pre><h2 id="65dd" class="nv mx it bd my nw nx dn nc ny nz dp ng ld oa ob ni lh oc od nk ll oe of nm og bi translated">安卓版本</h2><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nt nu l"/></div></figure><p id="1d94" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">如果有效，该函数返回格式化的电话号码(以“+”和国家代码开头),否则返回<code class="fe me mf mg mh b">null</code>。首先论证的是安卓<code class="fe me mf mg mh b">Context</code>，例如<code class="fe me mf mg mh b">Activity</code>。</p><h2 id="f84c" class="nv mx it bd my nw nx dn nc ny nz dp ng ld oa ob ni lh oc od nk ll oe of nm og bi translated">如何使用它</h2><pre class="kj kk kl km gt oh mh oi oj aw ok bi"><span id="9dcd" class="nv mx it mh b gy ol om l on oo"><strong class="mh iu">val</strong> phone = "(202)555-0156" // Phone number is fake, but has valid format<br/><strong class="mh iu">val</strong> formattedPhone = phone.<em class="mi">formatPhoneNumber</em>(this, "US")<br/>if (formattedPhone == null) {<br/>    <em class="mi">println</em>("Phone number is not valid")<br/>} else {<br/>    <em class="mi">println</em>("Sending $formattedPhone to API")<br/>}</span></pre></div><div class="ab cl mk ml hx mm" role="separator"><span class="mn bw bk mo mp mq"/><span class="mn bw bk mo mp mq"/><span class="mn bw bk mo mp"/></div><div class="im in io ip iq"><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi or"><img src="../Images/ddf25b6320512e0bcb86e0cf8048a40d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*RJJWCNI74ui6FPtp"/></div></div><p class="ms mt gj gh gi mu mv bd b be z dk translated">欧文·比尔德在<a class="ae mj" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的照片</p></figure><h1 id="e0e8" class="mw mx it bd my mz na nb nc nd ne nf ng jz nh ka ni kc nj kd nk kf nl kg nm nn bi translated">4.检查里面有什么</h1><p id="4185" class="pw-post-body-paragraph ku kv it kw b kx no ju kz la np jx lc ld nq lf lg lh nr lj lk ll ns ln lo lp im bi translated"><code class="fe me mf mg mh b">string</code>里面是什么？它可以是数字，可以是单词，也可以是包含特殊字符的密码。有时我们需要找出字符串内部的内容，以便知道下一步该做什么。让我们写一些扩展来实现它。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nt nu l"/></div></figure><h2 id="6b1b" class="nv mx it bd my nw nx dn nc ny nz dp ng ld oa ob ni lh oc od nk ll oe of nm og bi translated">如何使用它</h2><pre class="kj kk kl km gt oh mh oi oj aw ok bi"><span id="1007" class="nv mx it mh b gy ol om l on oo"><strong class="mh iu">val</strong> cl = "Contains letters".<em class="mi">containsLatinLetter // true<br/></em><strong class="mh iu">val</strong> cnl = "12345".<em class="mi">containsLatinLetter // false<br/></em><strong class="mh iu">val</strong> cd = "Contains digits 123".<em class="mi">containsDigit // true<br/></em><strong class="mh iu">val</strong> istr = "123".<em class="mi">isIntegerNumber // true<br/></em><strong class="mh iu">val</strong> dstr = "12.9".<em class="mi">toDecimalNumber // true</em></span></pre><p id="dc6d" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">假设我们需要检查密码是否有效。这是新密码，不是验证现有密码。新密码需要一个数字、一个拉丁字母和一个非字母数字字符。此外，我们不希望密码中有空格，除了第一个和最后一个字符，我们只是修剪它们。最后一次验证—长度。我们希望我们的密码包含6到20个字符。</p><pre class="kj kk kl km gt oh mh oi oj aw ok bi"><span id="7182" class="nv mx it mh b gy ol om l on oo"><strong class="mh iu">val</strong> password = "yt6Hbb2.s(ma**213"<br/><strong class="mh iu">val</strong> password2 = "yt6Hbb2sma213"</span><span id="dd52" class="nv mx it mh b gy os om l on oo"><strong class="mh iu">val</strong> isPasswordValid = !password.<em class="mi">isAlphanumeric </em>&amp;&amp; password.<em class="mi">containsDigit </em>&amp;&amp; password.<em class="mi">containsLatinLetter </em>&amp;&amp; password.length &gt; 6 &amp;&amp; password.length &lt; 20 // true</span><span id="1d2e" class="nv mx it mh b gy os om l on oo"><strong class="mh iu">val</strong> isPassword2Valid = !password2.<em class="mi">isAlphanumeric </em>&amp;&amp; password2.<em class="mi">containsDigit </em>&amp;&amp; password2.<em class="mi">containsLatinLetter </em>&amp;&amp; password2.length &gt; 6 &amp;&amp; password2.length &lt; 20 // false, doesn't contain non-alphanumeric characters</span></pre></div><div class="ab cl mk ml hx mm" role="separator"><span class="mn bw bk mo mp mq"/><span class="mn bw bk mo mp mq"/><span class="mn bw bk mo mp"/></div><div class="im in io ip iq"><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ot"><img src="../Images/f8a96488355262acbd54284bac096a43.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*nAVlSDFcW3WpInPM"/></div></div><p class="ms mt gj gh gi mu mv bd b be z dk translated"><a class="ae mj" href="https://unsplash.com/@erdaest?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Erda Estremera </a>在<a class="ae mj" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>拍摄的照片</p></figure><h1 id="6bca" class="mw mx it bd my mz na nb nc nd ne nf ng jz nh ka ni kc nj kd nk kf nl kg nm nn bi translated">6.存储和检索本地设置</h1><p id="6c7f" class="pw-post-body-paragraph ku kv it kw b kx no ju kz la np jx lc ld nq lf lg lh nr lj lk ll ns ln lo lp im bi translated">这个扩展是Android特有的。Kotlin是Android开发的官方语言。越来越多的Play Store应用使用Kotlin。开发时间更短，质量更好，同时与Java有充分的兼容性和互操作性。</p><p id="3a6e" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">Android应用程序有几种方法来存储本地设置，但最简单和本机的方法是<code class="fe me mf mg mh b">SharedPreferences</code>。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nt nu l"/></div></figure><p id="e33c" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">第一个论点是<code class="fe me mf mg mh b">applicationContext: Context</code>。如果从<code class="fe me mf mg mh b">Activity</code>运行函数，它可以传递自身(因为<code class="fe me mf mg mh b">Activity</code>是<code class="fe me mf mg mh b">Context</code>的子类)或者更好的是<code class="fe me mf mg mh b">applicationContext</code>。</p><p id="05b3" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">第二个参数是<code class="fe me mf mg mh b">value: Map&lt;String, Any&gt;</code>。Kotlin中的地图易于创建和使用。在这个扩展中<code class="fe me mf mg mh b">Any</code>可以是任意非空值，但是只保存五种类型:<code class="fe me mf mg mh b">Int</code>、<code class="fe me mf mg mh b">Float</code>、<code class="fe me mf mg mh b">Long</code>、<code class="fe me mf mg mh b">Boolean</code>和<code class="fe me mf mg mh b">String</code>。</p><p id="1cf5" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">如果不在<code class="fe me mf mg mh b">value</code>中的<code class="fe me mf mg mh b">SharedPreferences</code>中的所有字段都应该从<code class="fe me mf mg mh b">SharedPreferences</code>中移除，则参数<code class="fe me mf mg mh b">clear</code>应该为真。</p><p id="d020" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">关于<code class="fe me mf mg mh b">SharedPreferences</code>的另一个细节是背景保存。保存<code class="fe me mf mg mh b">SharedPreferences</code>有两种方法:<code class="fe me mf mg mh b">commit</code>和<code class="fe me mf mg mh b">apply</code>。不同之处在于<code class="fe me mf mg mh b">commit</code>会立即应用更改。<code class="fe me mf mg mh b">apply</code>在后台执行，这可以使你的应用程序更快，但不能保证立即保存。在大多数情况下，<code class="fe me mf mg mh b">apply</code>是首选，这就是为什么<code class="fe me mf mg mh b">now</code>参数几乎总是应该是<code class="fe me mf mg mh b">false</code>。</p><h2 id="c0b1" class="nv mx it bd my nw nx dn nc ny nz dp ng ld oa ob ni lh oc od nk ll oe of nm og bi translated">如何使用它</h2><p id="7d21" class="pw-post-body-paragraph ku kv it kw b kx no ju kz la np jx lc ld nq lf lg lh nr lj lk ll ns ln lo lp im bi translated">这个例子展示了一个应用程序如何存储游戏设置:</p><pre class="kj kk kl km gt oh mh oi oj aw ok bi"><span id="5d9c" class="nv mx it mh b gy ol om l on oo">"com.app.options".<em class="mi">save</em>(<em class="mi">applicationContext</em>,<br/>    <strong class="mh iu"><em class="mi">mapOf</em></strong>(<br/>        "volume" <em class="mi">to </em>0.8f,<br/>        "fullscreen" <em class="mi">to </em>true<br/>    )<br/>)<br/><br/><strong class="mh iu">val</strong> volume = "options".<em class="mi">load</em>(<em class="mi">applicationContext</em>)["volume"] as? Float // 0.8</span></pre><p id="a8b6" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">请注意，这里的<code class="fe me mf mg mh b">SharedPreferences</code>是用<code class="fe me mf mg mh b">apply</code>保存的。同时，可以立即使用。这是因为<code class="fe me mf mg mh b">SharedPreferences</code>存储在手机内存中。如果应用程序随后崩溃，有很小的机会价值不会被保存，尤其是如果它很大。</p></div><div class="ab cl mk ml hx mm" role="separator"><span class="mn bw bk mo mp mq"/><span class="mn bw bk mo mp mq"/><span class="mn bw bk mo mp"/></div><div class="im in io ip iq"><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ou"><img src="../Images/9c6a110eb7db003f440a4174d28e8e62.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*6dp_oSG23VB2fmyF"/></div></div><p class="ms mt gj gh gi mu mv bd b be z dk translated">由<a class="ae mj" href="https://unsplash.com/@casparrubin?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">卡斯帕·卡米尔·鲁宾</a>在<a class="ae mj" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</p></figure><h1 id="3e15" class="mw mx it bd my mz na nb nc nd ne nf ng jz nh ka ni kc nj kd nk kf nl kg nm nn bi translated">7.从字符串解析JSON</h1><p id="5c29" class="pw-post-body-paragraph ku kv it kw b kx no ju kz la np jx lc ld nq lf lg lh nr lj lk ll ns ln lo lp im bi translated">Java和Kotlin允许将JSON解析成<code class="fe me mf mg mh b">JSONObject</code>或<code class="fe me mf mg mh b">JSONArray</code>类(取决于内容)。让我们添加一些语法糖，使它更快，没有例外。如果<code class="fe me mf mg mh b">String</code>包含有效的JSON，函数将返回<code class="fe me mf mg mh b">JSONObject</code>或<code class="fe me mf mg mh b">JSONArray</code>，否则返回<code class="fe me mf mg mh b">null</code>。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nt nu l"/></div></figure><h2 id="60c5" class="nv mx it bd my nw nx dn nc ny nz dp ng ld oa ob ni lh oc od nk ll oe of nm og bi translated">如何使用它</h2><p id="2637" class="pw-post-body-paragraph ku kv it kw b kx no ju kz la np jx lc ld nq lf lg lh nr lj lk ll ns ln lo lp im bi translated">让我们解析JSON字符串并再次将其转换为<code class="fe me mf mg mh b">String</code>:</p><pre class="kj kk kl km gt oh mh oi oj aw ok bi"><span id="d4b1" class="nv mx it mh b gy ol om l on oo"><strong class="mh iu">val</strong> json = "{\"key\": \"value\"}".<em class="mi">jsonObject </em> // {"key": "value"}<em class="mi"><br/></em><strong class="mh iu">val</strong> jsonAgain = json?.toString() // "{"key": "value"}"<br/><strong class="mh iu">val</strong> stringFromJson = json?.getString("key") // "value"</span></pre></div><div class="ab cl mk ml hx mm" role="separator"><span class="mn bw bk mo mp mq"/><span class="mn bw bk mo mp mq"/><span class="mn bw bk mo mp"/></div><div class="im in io ip iq"><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ov"><img src="../Images/385511b399a0e87a585b15bcb4d5206f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*Ycic-GA5gBGejkOu"/></div></div><p class="ms mt gj gh gi mu mv bd b be z dk translated">Jonatan Lewczuk 在<a class="ae mj" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</p></figure><h1 id="0a91" class="mw mx it bd my mz na nb nc nd ne nf ng jz nh ka ni kc nj kd nk kf nl kg nm nn bi translated">8.最后路径组件</h1><p id="e26b" class="pw-post-body-paragraph ku kv it kw b kx no ju kz la np jx lc ld nq lf lg lh nr lj lk ll ns ln lo lp im bi translated">苹果基金会有一个很有用的属性<code class="fe me mf mg mh b">lastPathComponent</code>。如果<code class="fe me mf mg mh b">String</code>包含路径或URL，则返回最后一个组件(在最后一个“/”之后)。让我们将其复制为Kotlin扩展。</p><p id="2ba8" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">但首先，我想做两点说明:</p><ol class=""><li id="948d" class="lq lr it kw b kx ky la lb ld ls lh lt ll lu lp lv lw lx ly bi translated">路径可以结尾斜杠结束。扩展函数应该在其前面返回路径组件；否则，它不会处理URL。</li><li id="6409" class="lq lr it kw b kx lz la ma ld mb lh mc ll md lp lv lw lx ly bi translated">一些系统(例如微软视窗系统)使用反斜杠代替斜杠。我们也应该处理它。</li></ol><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nt nu l"/></div></figure><h2 id="9d36" class="nv mx it bd my nw nx dn nc ny nz dp ng ld oa ob ni lh oc od nk ll oe of nm og bi translated">如何使用它</h2><pre class="kj kk kl km gt oh mh oi oj aw ok bi"><span id="9443" class="nv mx it mh b gy ol om l on oo"><strong class="mh iu">val</strong> lpc1 = "https://google.com/chrome/".<em class="mi">lastPathComponent </em>// chrome<br/><strong class="mh iu">val</strong> lpc2 = "C:\\Windows\\Fonts\\font.ttf".<em class="mi">lastPathComponent </em>// font.ttf<br/><strong class="mh iu">val</strong> lpc3 = "/dev/null".<em class="mi">lastPathComponent </em>// null</span></pre></div><div class="ab cl mk ml hx mm" role="separator"><span class="mn bw bk mo mp mq"/><span class="mn bw bk mo mp mq"/><span class="mn bw bk mo mp"/></div><div class="im in io ip iq"><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ow"><img src="../Images/9d552d44d3e87142a871c5a77e16b31f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*SE6QVZeA_KFsiJlj"/></div></div><p class="ms mt gj gh gi mu mv bd b be z dk translated"><a class="ae mj" href="https://unsplash.com/@plushdesignstudio?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">毛绒设计工作室</a>在<a class="ae mj" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</p></figure><h1 id="06d5" class="mw mx it bd my mz na nb nc nd ne nf ng jz nh ka ni kc nj kd nk kf nl kg nm nn bi translated">9.字符串中的颜色</h1><p id="f6ae" class="pw-post-body-paragraph ku kv it kw b kx no ju kz la np jx lc ld nq lf lg lh nr lj lk ll ns ln lo lp im bi translated">颜色在不同的环境中有不同的表现。Android使用简单的整数。它有<code class="fe me mf mg mh b">Color</code>类，但它只包含帮助函数。另一个表示是AWT <code class="fe me mf mg mh b">Color</code>类，它为红色、绿色、蓝色和alpha分量封装了四个整数值。</p><h2 id="d53e" class="nv mx it bd my nw nx dn nc ny nz dp ng ld oa ob ni lh oc od nk ll oe of nm og bi translated">将十六进制<code class="fe me mf mg mh b">String</code>解析为AWT <code class="fe me mf mg mh b">Color</code></h2><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nt nu l"/></div></figure><h2 id="ac17" class="nv mx it bd my nw nx dn nc ny nz dp ng ld oa ob ni lh oc od nk ll oe of nm og bi translated">如何使用它</h2><pre class="kj kk kl km gt oh mh oi oj aw ok bi"><span id="2b53" class="nv mx it mh b gy ol om l on oo"><strong class="mh iu">val</strong> c = "#010203".<em class="mi">awtColor<br/>print</em>(c.<em class="mi">toString</em>()) // java.awt.Color[r=1,g=2,b=3]</span></pre><h2 id="4d4b" class="nv mx it bd my nw nx dn nc ny nz dp ng ld oa ob ni lh oc od nk ll oe of nm og bi translated">将十六进制字符串解析为Android颜色</h2><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nt nu l"/></div></figure><p id="315b" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">这个类返回<code class="fe me mf mg mh b">Int</code>，因为Android在其视图中使用了<code class="fe me mf mg mh b">Int</code>。</p><h2 id="e106" class="nv mx it bd my nw nx dn nc ny nz dp ng ld oa ob ni lh oc od nk ll oe of nm og bi translated">如何使用它</h2><pre class="kj kk kl km gt oh mh oi oj aw ok bi"><span id="f1a1" class="nv mx it mh b gy ol om l on oo"><strong class="mh iu">val</strong> colorHex = "#010203"<br/><strong class="mh iu">val</strong> color = colorHex.<em class="mi">asColor // </em>-16711165<em class="mi"><br/></em><strong class="mh iu">val</strong> nonColorHex = "abcdef"<br/><strong class="mh iu">val</strong> nonColor = nonColorHex.<em class="mi">asColor // null</em></span></pre><p id="8e8c" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">你可能会问:如果用一行代码替换另一行代码，为什么要使用扩展？</p><pre class="kj kk kl km gt oh mh oi oj aw ok bi"><span id="05a2" class="nv mx it mh b gy ol om l on oo"><strong class="mh iu">val</strong> color1 = Color.parseColor(hexString)<br/><strong class="mh iu">val</strong> color2 = hexString.<em class="mi">asColor</em></span></pre><p id="e698" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">有两个不同之处:</p><ol class=""><li id="a7b1" class="lq lr it kw b kx ky la lb ld ls lh lt ll lu lp lv lw lx ly bi translated"><code class="fe me mf mg mh b">asColor</code>分机可以连锁。比如:<code class="fe me mf mg mh b">hexString.asColor?.toString()</code></li><li id="9a0d" class="lq lr it kw b kx lz la ma ld mb lh mc ll md lp lv lw lx ly bi translated"><code class="fe me mf mg mh b">null</code>代替例外。不需要用<code class="fe me mf mg mh b">try-catch</code>块包起来。如果不是有效的颜色，您将得到<code class="fe me mf mg mh b">null</code>。</li></ol></div><div class="ab cl mk ml hx mm" role="separator"><span class="mn bw bk mo mp mq"/><span class="mn bw bk mo mp mq"/><span class="mn bw bk mo mp"/></div><div class="im in io ip iq"><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ox"><img src="../Images/5e1ffb8bcbad03879eaf4984c34566de.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*slbWp73-EtqVvqjs"/></div></div><p class="ms mt gj gh gi mu mv bd b be z dk translated"><a class="ae mj" href="https://unsplash.com/@claybanks?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">粘土堤</a>在<a class="ae mj" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">防溅板</a>上拍照</p></figure><h1 id="778e" class="mw mx it bd my mz na nb nc nd ne nf ng jz nh ka ni kc nj kd nk kf nl kg nm nn bi translated">10.将字符串格式化为信用卡号</h1><p id="dd51" class="pw-post-body-paragraph ku kv it kw b kx no ju kz la np jx lc ld nq lf lg lh nr lj lk ll ns ln lo lp im bi translated">一些Android应用程序出售物品或服务，不能通过应用内购买支付。对于Java server app store，它使用并向用户显示信用卡号。通常应用程序会将其保存为不带空格的<code class="fe me mf mg mh b">string</code>。但是没有任何分隔的16位(有时更多)数字对用户来说是不舒服的。</p><p id="095b" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">这个简单的扩展在字符串的每四个字符后添加空格:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nt nu l"/></div></figure><h2 id="6583" class="nv mx it bd my nw nx dn nc ny nz dp ng ld oa ob ni lh oc od nk ll oe of nm og bi translated"><strong class="ak">如何使用</strong></h2><pre class="kj kk kl km gt oh mh oi oj aw ok bi"><span id="b764" class="nv mx it mh b gy ol om l on oo"><strong class="mh iu">val</strong> ccFormatted = "1234567890123456".<em class="mi">creditCardFormatted // "</em>1234 5678 9012 3456<em class="mi">"</em></span></pre></div><div class="ab cl mk ml hx mm" role="separator"><span class="mn bw bk mo mp mq"/><span class="mn bw bk mo mp mq"/><span class="mn bw bk mo mp"/></div><div class="im in io ip iq"><h1 id="7135" class="mw mx it bd my mz oy nb nc nd oz nf ng jz pa ka ni kc pb kd nk kf pc kg nm nn bi translated">额外收获:使用JSON安全工作</h1><p id="ffc1" class="pw-post-body-paragraph ku kv it kw b kx no ju kz la np jx lc ld nq lf lg lh nr lj lk ll ns ln lo lp im bi translated">JSON和XML是数据加载、保存、交换等的两种流行格式。很难想象没有这些格式的API调用。</p><p id="8ef1" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">Java提供了相当舒适的类:<code class="fe me mf mg mh b">JSONObject</code>和<code class="fe me mf mg mh b">JSONArray</code>。Kotlin可以使用任何Java类，所以这也是Kotlin解析和编写JSON的一种方式。<code class="fe me mf mg mh b">JSONObject</code>和<code class="fe me mf mg mh b">JSONArray</code>安卓都有。</p><p id="4057" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">为什么要扩展这些类？问题是，如果出现问题，它们会抛出异常。如果出了什么差错。例如，如果您试图获取错误的数据类型，或者如果您引用了不存在的字段。</p><pre class="kj kk kl km gt oh mh oi oj aw ok bi"><span id="93a6" class="nv mx it mh b gy ol om l on oo"><strong class="mh iu">try</strong> {<br/>    <strong class="mh iu">val</strong> obj = JSONObject()<br/>    obj.put("str", "abc")<br/>    <strong class="mh iu">val strAsInt = obj.getInt("str") // </strong>org.json.JSONException: Value abc at str of type java.lang.String cannot be converted to int</span><span id="34d8" class="nv mx it mh b gy os om l on oo"><strong class="mh iu">val noKey = obj.getString("iamnothere")</strong> // org.json.JSONException: No value for iamnothere<br/>} catch (e: JSONException) {<br/>    e.printStackTrace()<br/>}</span></pre><p id="9b59" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">例外没什么不好；这是处理这种情况的好方法。但有时我们需要只拉现有字段，忽略(保留为<code class="fe me mf mg mh b">null</code>)字段，这些字段不在API响应中。</p><p id="28fd" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">如果没有扩展，可以这样做:</p><pre class="kj kk kl km gt oh mh oi oj aw ok bi"><span id="6e54" class="nv mx it mh b gy ol om l on oo"><strong class="mh iu">val</strong> firstName: String?<br/><strong class="mh iu">try</strong> {<br/>    firstName = json.getString("first_name")<br/>} <strong class="mh iu">catch</strong> (e: JSONException) {<br/>    firstName = <strong class="mh iu">null</strong><br/>}</span><span id="baaa" class="nv mx it mh b gy os om l on oo"><strong class="mh iu">val</strong> lastName: String?<br/><strong class="mh iu">try</strong> {<br/>    lastName = json.getString("last_name")<br/>} <strong class="mh iu">catch</strong> (e: JSONException) {<br/>    lastName = <strong class="mh iu">null</strong><br/>}</span></pre><p id="c781" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">看起来很长，对吧？现在想象一下，服务器返回的是<code class="fe me mf mg mh b">"null"</code>而不是<code class="fe me mf mg mh b">null</code>。每个字段的代码都将增长。这可以通过扩展来解决:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nt nu l"/></div></figure><p id="16e0" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">这个扩展有一些额外的功能，如字符串修剪。如果你仔细看看会更好，而不是复制到你的项目中。像将<code class="fe me mf mg mh b">"null"</code>替换为<code class="fe me mf mg mh b">null</code>这样的功能可以这样添加:</p><pre class="kj kk kl km gt oh mh oi oj aw ok bi"><span id="baac" class="nv mx it mh b gy ol om l on oo"><strong class="mh iu">fun</strong> JSONObject.getStringOrNull(name: String): String? =<br/>      <strong class="mh iu">try</strong> {<br/>         <strong class="mh iu">val</strong> str = getString(name).<em class="mi">trim</em>()<br/>         if (str == "null") return <strong class="mh iu">null</strong><br/>         <strong class="mh iu">return</strong> str<br/>      }<br/>      <strong class="mh iu">catch</strong> (e: JSONException) {<br/>         <strong class="mh iu">null</strong><br/>      }</span></pre><h2 id="ea13" class="nv mx it bd my nw nx dn nc ny nz dp ng ld oa ob ni lh oc od nk ll oe of nm og bi translated">如何使用它</h2><pre class="kj kk kl km gt oh mh oi oj aw ok bi"><span id="96b9" class="nv mx it mh b gy ol om l on oo"><strong class="mh iu">val</strong> firstName = json.getStringOrNull("first_name")<br/><strong class="mh iu">val</strong> lastName = json.getStringOrNull("last_name")</span></pre><h2 id="0b2a" class="nv mx it bd my nw nx dn nc ny nz dp ng ld oa ob ni lh oc od nk ll oe of nm og bi translated">注意</h2><p id="1f31" class="pw-post-body-paragraph ku kv it kw b kx no ju kz la np jx lc ld nq lf lg lh nr lj lk ll ns ln lo lp im bi translated">解析JSON的另一种方法是使用外部库:<a class="ae mj" href="https://github.com/google/gson" rel="noopener ugc nofollow" target="_blank"> GSON </a>或<a class="ae mj" href="https://github.com/square/moshi" rel="noopener ugc nofollow" target="_blank"> Moshi </a>。</p></div><div class="ab cl mk ml hx mm" role="separator"><span class="mn bw bk mo mp mq"/><span class="mn bw bk mo mp mq"/><span class="mn bw bk mo mp"/></div><div class="im in io ip iq"><h1 id="72f2" class="mw mx it bd my mz oy nb nc nd oz nf ng jz pa ka ni kc pb kd nk kf pc kg nm nn bi translated">结论</h1><p id="cf1c" class="pw-post-body-paragraph ku kv it kw b kx no ju kz la np jx lc ld nq lf lg lh nr lj lk ll ns ln lo lp im bi translated">你可以是JVM开发人员、Android开发人员，或者更奇特的Kotlin原生开发人员——我希望这些扩展对你有用。</p><p id="26d6" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">下次见。编码快乐！</p></div></div>    
</body>
</html>