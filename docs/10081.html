<html>
<head>
<title>Automated Docker Deployments Using Watchtower</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用瞭望塔自动部署Docker</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/automated-docker-deployments-using-watchtower-1b7414a755e5?source=collection_archive---------5-----------------------#2021-11-24">https://betterprogramming.pub/automated-docker-deployments-using-watchtower-1b7414a755e5?source=collection_archive---------5-----------------------#2021-11-24</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><h2 id="194e" class="ir is it bd b dl iu iv iw ix iy iz dk ja translated" aria-label="kicker paragraph">全栈开发| DevOps</h2><div class=""/><div class=""><h2 id="aa9a" class="pw-subtitle-paragraph jz jc it bd b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq dk translated">了望塔|码头工人|码头工人撰写</h2></div><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi kr"><img src="../Images/93c98b7eeec99ab7259f4af13b35cb8b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*xhqKern92F_CigBNG3zWzw.jpeg"/></div></div><p class="ld le gj gh gi lf lg bd b be z dk translated">照片由<a class="ae lh" href="https://www.pexels.com/photo/man-jumping-on-intermodal-container-379964/?utm_content=attributionCopyText&amp;utm_medium=referral&amp;utm_source=pexels" rel="noopener ugc nofollow" target="_blank"> Pexels </a>的<a class="ae lh" href="https://www.pexels.com/@kaiquestr?utm_content=attributionCopyText&amp;utm_medium=referral&amp;utm_source=pexels" rel="noopener ugc nofollow" target="_blank">凯奎·罗查</a>拍摄</p></figure><p id="0d49" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">在过去的几周里，我有一个小小的需求，关于我们如何部署已经在docker容器注册表上发布的docker映像。有多种方法，包括手动拉动和部署，而<a class="ae lh" href="https://containrrr.dev/watchtower/" rel="noopener ugc nofollow" target="_blank">瞭望塔</a>给了我迄今为止最好的解决方案。</p><p id="f080" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">在本文中，我将解释我如何使用watchtower为发布在GitLab docker registry上的<a class="ae lh" href="https://medium.com/geekculture/setup-gitlab-ci-pipeline-for-angular-9cce853ef281" rel="noopener"> angular应用程序配置自动化docker部署。</a></p><p id="d1b8" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">目前，我已经解释了如何为angular应用程序设置Gitlab CI管道，您可以从<a class="ae lh" href="https://gitlab.com/chikaslocalhost/angular-ci-cd" rel="noopener ugc nofollow" target="_blank"> Gitlab </a>下载所有源代码。现在，随着CI的实施，我们已经将应用程序源代码发布到Gitlab docker注册表中。让我们从那里开始。</p><h1 id="d671" class="me mf it bd mg mh mi mj mk ml mm mn mo ki mp kj mq kl mr km ms ko mt kp mu mv bi translated">启动了望塔</h1><p id="a0bf" class="pw-post-body-paragraph li lj it lk b ll mw kd ln lo mx kg lq lr my lt lu lv mz lx ly lz na mb mc md im bi translated">Watchtower只是另一个docker容器，它能够监听部署的docker映像上发生的变化。所以首先我们需要在docker上面设置docker和瞭望塔。</p><p id="42cb" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">对于本教程，我使用的是基于ubuntu 20.04的服务器环境，你可以在开始设置瞭望塔之前，按照这个<a class="ae lh" href="https://www.digitalocean.com/community/tutorials/how-to-install-and-use-docker-on-ubuntu-20-04" rel="noopener ugc nofollow" target="_blank">文档</a>继续安装ubuntu。</p><p id="4822" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">如果你已经完成了docker的安装，你可以继续安装瞭望塔，如下所示。</p><pre class="ks kt ku kv gt nb nc nd ne aw nf bi"><span id="c56b" class="ng mf it nc b gy nh ni l nj nk">$ docker run -d --name watchtower   --restart always   -v /var/run/docker.sock:/var/run/docker.sock   v2tec/watchtower   -i 30</span></pre><ul class=""><li id="5e92" class="nl nm it lk b ll lm lo lp lr nn lv no lz np md nq nr ns nt bi translated">在这里，瞭望塔依赖于它能够<strong class="lk jd">访问docker API的方式，因为瞭望塔需要能够访问docker实例</strong>，以便从原始docker注册表中捕获变更，并在已发布的变更上进行部署。这就是为什么我们<strong class="lk jd">将/var/run/docker.sock </strong>挂载为一个卷。</li><li id="9104" class="nl nm it lk b ll nu lo nv lr nw lv nx lz ny md nq nr ns nt bi translated">除了瞭望塔默认以5分钟的间隔检查变化，但是在这个设置中，我设置在启动瞭望塔时使用-i 30 每30秒检查一次变化<strong class="lk jd">。</strong></li></ul><h1 id="3170" class="me mf it bd mg mh mi mj mk ml mm mn mo ki mp kj mq kl mr km ms ko mt kp mu mv bi translated">启动带有角度应用图像的docker容器</h1><p id="537e" class="pw-post-body-paragraph li lj it lk b ll mw kd ln lo mx kg lq lr my lt lu lv mz lx ly lz na mb mc md im bi translated">在这里，我在docker hub 上创建了一个<a class="ae lh" href="https://hub.docker.com/repository/docker/javatodev/angular-ci-cd-app" rel="noopener ugc nofollow" target="_blank">公共docker存储库，并推送了angular应用程序源代码的最新版本。您可以克隆源代码并将其发布到您帐户下的docker hub。或者直接使用您设置中的任何docker映像。</a></p><p id="d24e" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">首先，使用带有最新应用程序docker映像的docker启动应用程序，</p><pre class="ks kt ku kv gt nb nc nd ne aw nf bi"><span id="607e" class="ng mf it nc b gy nh ni l nj nk">$ docker pull javatodev/angular-ci-cd-app<br/>$ docker run -p 80:80 -d javatodev/angular-ci-cd-app:latest</span></pre><p id="6181" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">现在，我们已经运行了带有了望塔监听器的docker实例，该监听器监听Docker注册表，</p><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi nz"><img src="../Images/b1a52017b8b208f9a6e2e3bf5ade22cc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Hk54S34Jj4IelzDx69ZHUQ.png"/></div></div><p class="ld le gj gh gi lf lg bd b be z dk translated">服务器上运行的Docker容器</p></figure><p id="5be0" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">您应该能够使用公共IP通过端口80访问服务器上的应用程序。</p><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi oa"><img src="../Images/8757bbdb22638e280779ca0c48bc829f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*1cR3Acg_doIsx-9wYSNmuA.png"/></div></div><p class="ld le gj gh gi lf lg bd b be z dk translated">部署在Amazon EC2上的Angular应用程序</p></figure><p id="e9a8" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">现在我们可以发布对源代码的更改，并将其发布到docker hub注册中心，</p><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi ob"><img src="../Images/32b33b10a74f9bf793c8d295572ed6dd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*q9ls88CFqVVXbQ84PDps_g.png"/></div></div><p class="ld le gj gh gi lf lg bd b be z dk translated">用于角度应用的Gitlab管道</p></figure><p id="ab27" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">全部完成，这是我们在了望塔日志中看到的，</p><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi oc"><img src="../Images/1dbf40252b9a9901cb55aa13f7cbe5f7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*eaYqYZ6K40ZQEDLgQVrlWA.png"/></div></div></figure><p id="9624" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">docker镜像具有带有新镜像的最新版本，</p><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div class="gh gi od"><img src="../Images/2f985f9d1d0e2d58da319bd133e35c8d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1308/format:webp/1*SMLvO3seErEHcLjE3VkD0g.png"/></div></figure><p id="4b53" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">因此，在这里，watchtower捕获docker注册表上的更改，<strong class="lk jd">关闭当前正在运行的实例，在相同的配置(如端口绑定，80:80)上使用相同的docker容器名称拉取和部署更改</strong>。</p><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi oe"><img src="../Images/09fd644347f243787e692365e30eb332.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*6a6049zA7MuzRe-yx8hNeQ.png"/></div></div></figure><p id="664a" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">完成所有工作后，当我们更新源文件并将新的docker映像发布到各自的Docker注册中心时，部署在该服务器上的所有应用程序都将被更新。</p><h1 id="da02" class="me mf it bd mg mh mi mj mk ml mm mn mo ki mp kj mq kl mr km ms ko mt kp mu mv bi translated">为私有Docker注册表配置身份验证</h1><p id="bf21" class="pw-post-body-paragraph li lj it lk b ll mw kd ln lo mx kg lq lr my lt lu lv mz lx ly lz na mb mc md im bi translated">如果我们使用像Gitlab、Github这样的私有docker注册中心，或者您自己的docker注册中心设置，我们应该做一个额外的配置。</p><p id="b607" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">通常，如果我们需要访问任何私有docker注册表，我们要做的是插入docker登录命令，如下所示，</p><pre class="ks kt ku kv gt nb nc nd ne aw nf bi"><span id="1923" class="ng mf it nc b gy nh ni l nj nk">$ docker login registry.gitlab.com<br/>Username: xxxxxxxxxxxxxx</span><span id="c216" class="ng mf it nc b gy of ni l nj nk">Password:</span><span id="4b26" class="ng mf it nc b gy of ni l nj nk">WARNING! Your password will be stored unencrypted in <strong class="nc jd">/home/ubuntu/.docker/config.json</strong>.</span><span id="3c31" class="ng mf it nc b gy of ni l nj nk">Configure a credential helper to remove this warning. See</span><span id="f261" class="ng mf it nc b gy of ni l nj nk">https://docs.docker.com/engine/reference/commandline/login/#credentials-store</span><span id="f2f0" class="ng mf it nc b gy of ni l nj nk">Login Succeeded</span></pre><p id="f5ce" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">这里已经创建了凭证配置，并将其存储在服务器环境中，(<strong class="lk jd"> /home/ubuntu/)。docker/config.json </strong>)，下面是一个示例文件，</p><figure class="ks kt ku kv gt kw"><div class="bz fp l di"><div class="og oh l"/></div></figure><p id="9c82" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">因此，我们可以通过使用新卷添加该文件作为配置来重新启动我们的了望塔，</p><pre class="ks kt ku kv gt nb nc nd ne aw nf bi"><span id="0329" class="ng mf it nc b gy nh ni l nj nk">$ docker run -d --name watchtower --restart always -v /var/run/docker.sock:/var/run/docker.sock -v <strong class="nc jd">/home/ubuntu/.docker/config.json:/config.json</strong> v2tec/watchtower -i 30</span></pre><p id="8bdc" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">现在，瞭望塔可以使用存储的凭证文件，并从私有注册表中提取新的docker映像。</p><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi oi"><img src="../Images/515acb1c6c832a81ca6e02d9bd6de086.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*1zflSdKsjeaMn_yV6SScYA.png"/></div></div><p class="ld le gj gh gi lf lg bd b be z dk translated">带有私人码头登记处的瞭望塔</p></figure><p id="1cfc" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">正如我所展示的，当有新版本发布在各自的docker注册中心时，所有的组件都会得到更新。最好为docker镜像设置稳定的版本，如数据库(MongoDB、PostgreSQL等)、应用服务器(Tomcat、PHP实例等)，因为我们不会更新docker容器，因为这可能会导致应用程序开发中版本不兼容的问题。</p><p id="581f" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">感谢阅读。</p></div></div>    
</body>
</html>