<html>
<head>
<title>My Introduction to the Blockchain and Merkle Tree</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">我对区块链和Merkle树的介绍</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/my-introduction-to-the-blockchain-and-merkle-tree-6fba6ee853c?source=collection_archive---------8-----------------------#2022-04-22">https://betterprogramming.pub/my-introduction-to-the-blockchain-and-merkle-tree-6fba6ee853c?source=collection_archive---------8-----------------------#2022-04-22</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="90d3" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">通过这个Go实现了解区块链</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/cf301858add660961052e6abb2dc781a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*d4GXuM7nKznJ-sCJ"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">由<a class="ae kv" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的<a class="ae kv" href="https://unsplash.com/@theshubhamdhage?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Shubham Dhage </a>拍摄的照片</p></figure><p id="9656" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">几个月前，我开始围绕区块链进行游戏和开发，因为最近加密货币和智能合约的实施导致的所有令人难以置信的可能应用程序(如NFT收藏、游戏和DAO)在加密领域引起了轩然大波。我一直对分布式系统非常感兴趣，区块链是最纯粹形式的分布式系统。</p><p id="e3b6" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这一切都始于最受欢迎的游戏之一，它应用了Play2Earn的新概念，其中游戏的资产是代币(ERC-721)，玩家拥有代币并在玩代币时产生利润。他们也可以通过该平台提供的市场与其他玩家进行交易。当我发现市场上有玩家以低于平均水平的价格购买这些资产，然后转售获利时，我的兴趣被激发了。</p><p id="5fcf" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">注意到这一点后，我联系了一位很棒的同事和朋友，因为这代表了两个令人兴奋的好处:首先，了解这项已经谈论多年的技术(尽管如此，我们两人迄今都没有机会或兴趣进入这项技术)；第二，它展示了一个实际的用例，也可以带来经济效益。多么大的激励啊！</p><p id="07e1" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们从简单的迭代开始。我们创建了一个机器人，它可以监听我们感兴趣的特定区块链的事件和交易。每次发现有可以盈利的交易，我们就决定参与。显然，我们不是唯一参与的人，所以我们失败了大多数交易，因为其他人比我们快得多。随着时间的推移，我们调查的越多，我们了解的越多，我们正在进行更有效的实施。我们停止使用公共节点，并使用修改后的协议版本部署多个节点。</p><p id="7fb8" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">区块链是一个以太坊分支，所以我们修改了协议的实现(用Go编写，也是我最喜欢的语言),作为我们内部实现的一部分来运行我们的机器人，以加快速度。通过这种方式，我们最终完成了交易的前期运作，并获得了更多的机会。</p><blockquote class="ls lt lu"><p id="9cda" class="kw kx lv ky b kz la jr lb lc ld ju le lw lg lh li lx lk ll lm ly lo lp lq lr ij bi translated"><em class="iq">抢先交易是在知道未来交易的情况下将交易放入队列的行为。<br/></em><a class="ae kv" href="https://coinmarketcap.com/alexandria/glossary/front-running" rel="noopener ugc nofollow" target="_blank"><em class="iq"/></a></p></blockquote><p id="f7e6" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">简而言之，这一切导致我在最近几周更多地参与了区块链开发的整个话题，这也是为什么我决定学习更深入一点，并在做这件事的同时与您分享。因此，我的想法是，我会发布一些关于区块链相关技术的小文章，任何我觉得有趣并且你可能也会感兴趣的东西。</p><p id="9cbe" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">为了不再让你厌烦这个介绍，在第一篇文章中，我想谈谈区块链的基本部分，比如Merkle树，以及Go中的一个简单实现。本文假设您对加密哈希函数和基本二叉树算法有基本的了解。</p><h1 id="1ecd" class="lz ma iq bd mb mc md me mf mg mh mi mj jw mk jx ml jz mm ka mn kc mo kd mp mq bi translated">什么是Merkle树？</h1><p id="b114" class="pw-post-body-paragraph kw kx iq ky b kz mr jr lb lc ms ju le lf mt lh li lj mu ll lm ln mv lp lq lr ij bi translated">Merkle树或hash树是一种二叉树，其中一个节点只能有零个、一个或两个子节点。每个叶节点都标有数据块的加密哈希(例如，块链事务)，每个不是叶的节点(称为分支或内部节点)都标有其子节点标签的加密哈希。当有一个称为Merkle根的节点时，树就是完整的。</p><p id="6cb9" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">由于这种设计，这种结构实现了以下特性:</p><ul class=""><li id="635c" class="mw mx iq ky b kz la lc ld lf my lj mz ln na lr nb nc nd ne bi translated">易于验证数据完整性，因为如果任何数据发生变化，根哈希(Merkle root)也会发生变化。</li><li id="c578" class="mw mx iq ky b kz nf lc ng lf nh lj ni ln nj lr nb nc nd ne bi translated">单个散列值Merkle根代表所有数据块。</li><li id="97bc" class="mw mx iq ky b kz nf lc ng lf nh lj ni ln nj lr nb nc nd ne bi translated">使用Merkle proof很容易验证数据是否包含在树中。</li></ul><p id="d997" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">关于Merkle树的构造，值得注意的一点是，由于它是二叉树，其分支是子节点的组合，那么，如果我们有奇数个叶节点，会发生什么呢？如果我们有奇数个分支节点会发生什么？</p><p id="84d3" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在构建Merkle树时，简单的答案是，如果我们在某个特定级别有奇数个节点，我们必须复制最后一个节点，以便与其自身连接。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nk"><img src="../Images/7977c082cf9e923d9de61e4132468b2d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*wGbm7mPEFzq4BfaqA3-i6A.png"/></div></div></figure><p id="9b18" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">假设用户知道Merkle树的根hash，并想检查该树是否确实包含特定的数据，比如事务。在这种情况下，他可以通过使用穿过Merkle树的一条路径来完成，这与叶节点的数量成比例，而不是与叶节点的总数成比例。</p><p id="86e7" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">例如，根据上图，我们可以看到用户如何检查<code class="fe nl nm nn no b">L3</code>块的完整性，或者它是否出现在树中。如果他们知道<code class="fe nl nm nn no b">root hash</code>，并且有<code class="fe nl nm nn no b">Hash 1-1</code>和<code class="fe nl nm nn no b">Hash 0</code>，他们可以按照以下步骤操作:</p><ul class=""><li id="9860" class="mw mx iq ky b kz la lc ld lf my lj mz ln na lr nb nc nd ne bi translated">用户首先获得他们想要检查的数据块的散列，在本例中是<code class="fe nl nm nn no b">L3</code>块:<code class="fe nl nm nn no b">Hash(L3)</code>，以获得<code class="fe nl nm nn no b">Hash 1-0</code>。</li><li id="8988" class="mw mx iq ky b kz nf lc ng lf nh lj ni ln nj lr nb nc nd ne bi translated">然后，它们必须将结果与下一个提供的散列结合起来，该散列必须是作为其对等节点的节点的散列。在这种情况下，它将是<code class="fe nl nm nn no b">Hash(Hash 1-0, Hash 1-1)</code>等等，直到我们得到Merkle根。</li><li id="56ac" class="mw mx iq ky b kz nf lc ng lf nh lj ni ln nj lr nb nc nd ne bi translated">最后，他们只需要检查获得的根哈希是否等于先前已知的根哈希。如果散列是相同的，那么<code class="fe nl nm nn no b">L3</code>块属于树，并且它的数据没有被改变。否则，<code class="fe nl nm nn no b">L3</code>不在树中或者它的数据被改变了。</li></ul><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi np"><img src="../Images/143a1ca441eaadea9e21496f25359838.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*Fqi0izR_SyS1WKuB.png"/></div></div></figure><p id="2b1c" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">可以看出，Merkle树允许快速验证并提供了一个健壮的安全系统，因为如果任何块被修改，其散列的结果是不同的。因此，将其哈希与后续哈希相结合将产生一个与已知哈希不同的根哈希。</p><p id="13ab" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">Merkle树在许多计算机应用中使用。在比特币和其他加密货币中，Merkle树特别用于高效安全地维护区块链的状态。</p><p id="16f5" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">一个比特币区块平均有500笔交易。如果没有这种数据结构，想要检查一个事务是否在特定块内或其完整性的每个用户/客户端将不得不请求并下载500个事务来证明这一点。当使用Merkle树实现时，他们只需要下载特定事务的九个节点<code class="fe nl nm nn no b">ceil(log2(500)) = 9</code>的路径，并执行前面讨论的流程。有了这个，你就可以检查交易的完整性。</p><p id="36fe" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">即使该块包含100万个事务，它也只需要一个包含20个节点的路径就能执行验证。</p><p id="2f60" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">如您所见，这种数据结构非常引人注目，并被用于各种系统，例如:</p><ul class=""><li id="ab49" class="mw mx iq ky b kz la lc ld lf my lj mz ln na lr nb nc nd ne bi translated">版本控制系统，例如Git。</li><li id="8268" class="mw mx iq ky b kz nf lc ng lf nh lj ni ln nj lr nb nc nd ne bi translated">P2P中的文件系统。</li><li id="464d" class="mw mx iq ky b kz nf lc ng lf nh lj ni ln nj lr nb nc nd ne bi translated">数据库。</li><li id="eef3" class="mw mx iq ky b kz nf lc ng lf nh lj ni ln nj lr nb nc nd ne bi translated">区块链。</li></ul><h1 id="ec83" class="lz ma iq bd mb mc md me mf mg mh mi mj jw mk jx ml jz mm ka mn kc mo kd mp mq bi translated">围棋中的Merkle树</h1><p id="0ca4" class="pw-post-body-paragraph kw kx iq ky b kz mr jr lb lc ms ju le lf mt lh li lj mu ll lm ln mv lp lq lr ij bi translated">构建该树的一个简单方法是使用基于指针的策略。有了指针，我们可以很容易地看到节点与其子节点和父节点的关系，并使用这些知识来正确地计算它们的哈希值。同样，这些关系将帮助我们建立证明一个数据的路径。</p><p id="9341" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">正如我们已经知道的，在这种类型的树中，叶节点是我们想要构建树的数据的散列，因此我们必须使用自下而上的分层构造算法从叶到根构建树。</p><p id="dfe8" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们将从两个相对简单的结构开始，其中我们将存储树和树的节点以及它们各自的值。</p><pre class="kg kh ki kj gt nq no nr ns aw nt bi"><span id="b3df" class="nu ma iq no b gy nv nw l nx ny">type Tree struct {<br/>    Root   *Node<br/>    Leaves []*Node<br/>    h      Hasher<br/>}</span><span id="6a33" class="nu ma iq no b gy nz nw l nx ny">type Node struct {<br/>    Parent *Node<br/>    Left   *Node<br/>    Right  *Node<br/>    Hash   []byte<br/>}</span></pre><p id="a612" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><code class="fe nl nm nn no b">NewFromHashes</code>函数将帮助我们从散列数组中创建一棵树，因为我们已经知道这个结构的叶节点是所需信息的散列。</p><pre class="kg kh ki kj gt nq no nr ns aw nt bi"><span id="846e" class="nu ma iq no b gy nv nw l nx ny">func NewFromHashes(hashes [][]byte, h Hasher) *Tree {<br/>    t := &amp;Tree{<br/>        Leaves: make([]*Node, 0, len(hashes)),<br/>        h:      h,<br/>    }</span><span id="7f6f" class="nu ma iq no b gy nz nw l nx ny">    // Add leaf nodes.<br/>    for _, h := range hashes {<br/>        t.Leaves = append(t.Leaves, &amp;Node{Hash: h})<br/>    }</span><span id="4572" class="nu ma iq no b gy nz nw l nx ny">    t.Root = t.buildRoot()<br/>    return t<br/>}</span></pre><p id="20c4" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">下一个将遍历每一层节点以形成它们的关系，直到到达根节点。</p><pre class="kg kh ki kj gt nq no nr ns aw nt bi"><span id="944b" class="nu ma iq no b gy nv nw l nx ny">func (t *Tree) buildRoot() *Node {<br/>    nodes := t.Leaves<br/>    // We are iterating until we reach a single node, which will be our root.<br/>    for len(nodes) &gt; 1 {<br/>        var parents []*Node</span><span id="7fa6" class="nu ma iq no b gy nz nw l nx ny">        // Having an odd number of nodes at this level, we will duplicate the last node to concatenate it with itself.<br/>        if len(nodes)%2 != 0 {<br/>            nodes = append(nodes, nodes[len(nodes)-1])<br/>        }</span><span id="20ac" class="nu ma iq no b gy nz nw l nx ny">        // Pairing nodes to build a parent from the pair<br/>        for i := 0; i &lt; len(nodes); i += 2 {<br/>            n := &amp;Node{<br/>                Left:  nodes[i],<br/>                Right: nodes[i+1],</span><span id="65cc" class="nu ma iq no b gy nz nw l nx ny">                // Compute the hash of the new node, which will be the combination of its children's hashes.<br/>                Hash: t.h.Hash(nodes[i].Hash, nodes[i+1].Hash),<br/>            }</span><span id="c753" class="nu ma iq no b gy nz nw l nx ny">            parents = append(parents, n)<br/>            nodes[i].Parent, nodes[i+1].Parent = n, n<br/>        }<br/>        // Once all possible pairs are processed, the parents become the children, and we start all over again.<br/>        nodes = parents<br/>    }</span><span id="1e21" class="nu ma iq no b gy nz nw l nx ny">    return nodes[0]<br/>}</span></pre><p id="e6f0" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><code class="fe nl nm nn no b">GetProof</code>函数接收我们想要验证的数据/事务的散列作为参数，并将返回验证其完整性所需的节点散列。利用节点之间的关系，我们可以很容易地检索这些节点。</p><p id="f402" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我添加了一些解释性的注释，我认为这些注释可以阐明我们用指针得到证明的方法。</p><pre class="kg kh ki kj gt nq no nr ns aw nt bi"><span id="2832" class="nu ma iq no b gy nv nw l nx ny">func (t *Tree) GetProof(hash []byte) ([][]byte, []int, error) {<br/>    var (<br/>        path [][]byte<br/>        idxs []int<br/>    )</span><span id="a5cf" class="nu ma iq no b gy nz nw l nx ny">    // Find the leaf node for the specific hash.<br/>    for _, currentNode := range t.Leaves {<br/>        if bytes.Equal(currentNode.Hash, hash) {<br/>            // After finding the node, we will scale the tree using the relationship of the nodes to their parent nodes.<br/>            parent := currentNode.Parent<br/>            for parent != nil {<br/>                // If the current node is the left child, we need the right child to calculate the parent hash<br/>                // for the proof and vice versa.<br/>                // i.e:<br/>                // If CurrentNode == Left ; ParentHash = (CurrentNode.Hash, RightChild.Hash)<br/>                // If CurrentNode == Right ; ParentHash = (LeftChild.Hash, CurrentNode.Hash)<br/>                // So we have to add the corresponding hash to the path, and in idxs, we save the hash's position 0<br/>                // for left and 1 for right. In this way, when we want to verify the proof, we can know if<br/>                // the given hash is the left o right child.<br/>                if bytes.Equal(currentNode.Hash, parent.Left.Hash) {<br/>                    path = append(path, parent.Right.Hash)<br/>                    idxs = append(idxs, 1)<br/>                } else {<br/>                    path = append(path, parent.Left.Hash)<br/>                    idxs = append(idxs, 0)<br/>                }<br/>                currentNode = parent<br/>                parent = currentNode.Parent<br/>            }<br/>            return path, idxs, nil<br/>        }<br/>    }<br/>    return path, idxs, errors.New("hash does not belong to the tree")<br/>}</span></pre><p id="1486" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">如果你去仓库，你可以找到函数来验证证明，你也会找到这个简单实现的完整例子。Github回购。</p><pre class="kg kh ki kj gt nq no nr ns aw nt bi"><span id="9384" class="nu ma iq no b gy nv nw l nx ny">package main</span><span id="a481" class="nu ma iq no b gy nz nw l nx ny">import (<br/>    "crypto/sha256"<br/>    "fmt"</span><span id="e18f" class="nu ma iq no b gy nz nw l nx ny">    "github.com/douglasmakey/mktree"<br/>)</span><span id="7466" class="nu ma iq no b gy nz nw l nx ny">type transaction struct {<br/>    from  string<br/>    to    string<br/>    value string<br/>}</span><span id="f45f" class="nu ma iq no b gy nz nw l nx ny">func hashTrx(t transaction) []byte {<br/>    h := sha256.New()<br/>    h.Write([]byte(fmt.Sprintf("%v", t)))<br/>    return h.Sum(nil)<br/>}</span><span id="707d" class="nu ma iq no b gy nz nw l nx ny">func main() {<br/>    trx1 := transaction{from: "mike", to: "bob", value: "100"}<br/>    trx2 := transaction{from: "bob", to: "douglas", value: "250"}<br/>    trx3 := transaction{from: "alice", to: "john", value: "100"}<br/>    trx4 := transaction{from: "vitalik", to: "elon", value: "10000"}</span><span id="a008" class="nu ma iq no b gy nz nw l nx ny">    data := [][]byte{<br/>        hashTrx(trx1),<br/>        hashTrx(trx2),<br/>        hashTrx(trx3),<br/>        hashTrx(trx4),<br/>    }</span><span id="7a0b" class="nu ma iq no b gy nz nw l nx ny">    // Create and verify the tree.<br/>    t := mktree.NewFromHashes(data, mktree.DefaultShaHasher)<br/>    fmt.Println("Hex: ", t.Root.Hex())</span><span id="de59" class="nu ma iq no b gy nz nw l nx ny">    // Getting the proof of the first transaction and verify it.<br/>    proof, idxs, err := t.GetProof(hashTrx(trx1))<br/>    if err != nil {<br/>        panic(err)<br/>    }<br/>    fmt.Printf("Verify proof of trx1: %+v \n", trx1)<br/>    p := mktree.VerifyProof(t.Root.Hash, hashTrx(trx1), proof, idxs, mktree.DefaultShaHasher)<br/>    fmt.Println("Proof integrity: ", p)</span><span id="daf3" class="nu ma iq no b gy nz nw l nx ny">    // Change trx1 and try to verify it with the original proof.<br/>    trx1.value = "1000"<br/>    fmt.Printf("Verify proof of trx1: %+v \n", trx1)<br/>    p = mktree.VerifyProof(t.Root.Hash, hashTrx(trx1), proof, idxs, mktree.DefaultShaHasher)<br/>    fmt.Println("Proof integrity with a change trx: ", p)</span><span id="14dd" class="nu ma iq no b gy nz nw l nx ny">    // Modifying the second transaction to send money to me.<br/>    trx5 := transaction{from: "vitalik", to: "douglas", value: "10000"}<br/>    t.Leaves[1].Hash = hashTrx(trx5)<br/>    // We are going to verify the integrity of the tree after the modification<br/>    fmt.Println("Tree integrity: ", t.Verify())<br/>}</span></pre><p id="b3bb" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我希望你喜欢这篇文章。感谢您的时间，任何反馈都是受欢迎的。</p><h1 id="7efe" class="lz ma iq bd mb mc md me mf mg mh mi mj jw mk jx ml jz mm ka mn kc mo kd mp mq bi translated">资源</h1><ul class=""><li id="6bda" class="mw mx iq ky b kz mr lc ms lf oa lj ob ln oc lr nb nc nd ne bi translated"><a class="ae kv" href="https://www.geeksforgeeks.org/binary-tree-data-structure/" rel="noopener ugc nofollow" target="_blank">https://www.geeksforgeeks.org/binary-tree-data-structure/</a></li><li id="9274" class="mw mx iq ky b kz nf lc ng lf nh lj ni ln nj lr nb nc nd ne bi translated"><a class="ae kv" href="https://en.wikipedia.org/wiki/Cryptographic_hash_function" rel="noopener ugc nofollow" target="_blank">https://en.wikipedia.org/wiki/Cryptographic_hash_function</a></li><li id="541e" class="mw mx iq ky b kz nf lc ng lf nh lj ni ln nj lr nb nc nd ne bi translated"><a class="ae kv" href="https://en.wikipedia.org/wiki/Merkle_tree" rel="noopener ugc nofollow" target="_blank">https://en.wikipedia.org/wiki/Merkle_tree</a></li><li id="eee0" class="mw mx iq ky b kz nf lc ng lf nh lj ni ln nj lr nb nc nd ne bi translated"><a class="ae kv" href="https://en.bitcoinwiki.org/wiki/Merkle_tree" rel="noopener ugc nofollow" target="_blank">https://en.bitcoinwiki.org/wiki/Merkle_tree</a></li><li id="8c86" class="mw mx iq ky b kz nf lc ng lf nh lj ni ln nj lr nb nc nd ne bi translated"><a class="ae kv" href="https://en.bitcoin.it/wiki/Protocol_documentation#Merkle_Trees" rel="noopener ugc nofollow" target="_blank">https://en . bit coin . it/wiki/Protocol _ documentation # Merkle _ Trees</a></li><li id="01f2" class="mw mx iq ky b kz nf lc ng lf nh lj ni ln nj lr nb nc nd ne bi translated"><a class="ae kv" href="https://cointelegraph.com/explained/what-is-front-running-in-crypto-and-nft-trading" rel="noopener ugc nofollow" target="_blank">https://coin telegraph . com/explained/what-front-running-in-crypto-and-NFT-trading</a></li></ul></div></div>    
</body>
</html>