<html>
<head>
<title>Recreate Apple Watch Ultra Water Level Animation Using Jetpack Compose</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用Jetpack Compose重新创建Apple Watch超高水位动画</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/made-in-compose-apple-watch-ultra-water-level-animation-9dc7cab099ac?source=collection_archive---------7-----------------------#2022-10-06">https://betterprogramming.pub/made-in-compose-apple-watch-ultra-water-level-animation-9dc7cab099ac?source=collection_archive---------7-----------------------#2022-10-06</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="c003" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">在组合#1中制造</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/df58d67dff941318a7d7b5b8ca31efbf.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*Sc_HBFHmr43yQ6b9.png"/></div></div></figure><p id="0ad8" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">欢迎来到我的Made in Compose系列的第一篇文章，我尝试在Jetpack Compose中重新创建UI和动画，并分享我的过程。在这第一篇文章中，我将在新的Apple Watch Ultra diving应用程序中重现水位动画。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi ln"><img src="../Images/f573855c78ed0dbd1f53c3124350d577.png" data-original-src="https://miro.medium.com/v2/resize:fit:1200/1*pfvkl05KthKjTsdGsDjeww.gif"/></div></div><p class="lo lp gj gh gi lq lr bd b be z dk translated">来源:苹果keynote</p></figure><p id="76bd" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">这是苹果主题演讲中对我来说最突出的动画之一(除了动态岛)。这是一个简单的动画，通过外观来传递信息，看起来令人惊叹。</p><h1 id="493d" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">选择我的画布</h1><p id="6102" class="pw-post-body-paragraph kr ks iq kt b ku mk jr kw kx ml ju kz la mm lc ld le mn lg lh li mo lk ll lm ij bi translated">首先，我必须决定用什么在屏幕上展示我的元素。不幸的是，就混合模式而言，普通组件在屏幕上绘制时没有提供很多定制。我选择使用<code class="fe mp mq mr ms b">Canvas</code> composable并在那里绘制元素，并且可以绘制复杂的路径以及调整它们的混合模式。</p><h1 id="cf16" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">绘图文本</h1><p id="3555" class="pw-post-body-paragraph kr ks iq kt b ku mk jr kw kx ml ju kz la mm lc ld le mn lg lh li mo lk ll lm ij bi translated">遗憾的是，在<code class="fe mp mq mr ms b">Canvas</code> composable中，没有直接的方法在屏幕上绘制文本。为了解决这个问题，我使用了<code class="fe mp mq mr ms b">Canvas</code>视图互操作来使用它的<code class="fe mp mq mr ms b">drawText</code>函数。</p><pre class="kg kh ki kj gt mt ms mu mv aw mw bi"><span id="c331" class="mx lt iq ms b gy my mz l na nb">Canvas( <br/>    onDraw = {<br/>  val paint = Paint().asFrameworkPaint()  <br/>  paint.apply {  <br/>      isAntiAlias = true<br/>      color = android.graphics.Color.parseColor("#41E0E0")  <br/>      textAlign = android.graphics.Paint.Align.CENTER<br/>  }  <br/>    <br/>  drawIntoCanvas {  <br/>      it.nativeCanvas.apply {  <br/>          drawText(text, x, y, paint)  <br/>      }  <br/>  }<br/> }<br/>)</span></pre><h1 id="4d19" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">动画波浪</h1><p id="2dc0" class="pw-post-body-paragraph kr ks iq kt b ku mk jr kw kx ml ju kz la mm lc ld le mn lg lh li mo lk ll lm ij bi translated"><code class="fe mp mq mr ms b">Canvas</code>允许我们在屏幕上绘制各种路径。在测试了几个变体之后，结果最好的是使用<code class="fe mp mq mr ms b">cubicTo</code>函数的立方路径。<br/>立方路径由四个点定义。一个起点和终点，以及两个控制点。我的立方路径是由一个函数定义的，它接受任意大小的y位置列表，并将它们均匀地分布在画布的宽度上。然后，我根据之前计算的点来计算控制点。</p><pre class="kg kh ki kj gt mt ms mu mv aw mw bi"><span id="730c" class="mx lt iq ms b gy my mz l na nb">Path().apply {  <br/>    moveTo(0f, 0f)  <br/>    lineTo(0f, animatedY)  <br/>    val interval = size.width * (1 / (aYs.size + 1).toFloat())  <br/>    aYs.forEachIndexed { index, y -&gt;  <br/>        val segmentIndex = (index + 1) / (aYs.size + 1).toFloat()  <br/>        val x = size.width * segmentIndex  <br/>        cubicTo(  <br/>            x1 = if (index == 0) 0f else x - interval / 2f,  <br/>            y1 = aYs.getOrNull(index - 1)?.toFloat() ?: currentY,  <br/>            x2 = x - interval / 2f,  <br/>            y2 = y.toFloat(),  <br/>            x3 = x,  <br/>            y3 = y.toFloat(),  <br/>        )  <br/>    }  <br/>  <br/>    cubicTo(  <br/>        x1 = size.width - interval / 2f,  <br/>        y1 = aYs.last().toFloat(),  <br/>        x2 = size.width,  <br/>        y2 = animatedY,  <br/>        x3 = size.width,  <br/>        y3 = animatedY,  <br/>    )  <br/>    lineTo(size.width, 0f)  <br/>    close()  <br/>}</span></pre><h1 id="d3e2" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">混合模式</h1><p id="e68d" class="pw-post-body-paragraph kr ks iq kt b ku mk jr kw kx ml ju kz la mm lc ld le mn lg lh li mo lk ll lm ij bi translated">在苹果的动画中，你会注意到，只有被波浪覆盖的文本部分才会切换颜色。为了实现这一点，我们将在画布中使用混合模式。混合模式允许我们操作。<br/>有关所有可用混合模式的概述，请查看<a class="ae nc" href="https://developer.android.com/reference/android/graphics/BlendMode" rel="noopener ugc nofollow" target="_blank">此处</a>。在这个动画中，<code class="fe mp mq mr ms b">BlendMode.Xor</code>给了我们想要的效果。<br/>所以对于侧面的渐变线，我应用了这样的混合模式:</p><pre class="kg kh ki kj gt mt ms mu mv aw mw bi"><span id="4553" class="mx lt iq ms b gy my mz l na nb">drawLine(  <br/>    start = Offset(0f, y),  <br/>    end = Offset(lineWidth, y),  <br/>    brush = Brush.verticalGradient(  <br/>        colors = listOf(  <br/>            Color(0xFF41E0E0),  <br/>            Color(0xFF279ED5),  <br/>        )  <br/>    ),  <br/>    blendMode = BlendMode.Xor,  &lt;----<br/>    strokeWidth = strokeWidth,  <br/>)</span></pre><p id="4030" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">对于文本，我不得不使用与旧画布兼容的混合模式。</p><pre class="kg kh ki kj gt mt ms mu mv aw mw bi"><span id="70ed" class="mx lt iq ms b gy my mz l na nb">val paint = Paint().asFrameworkPaint()  <br/>paint.apply {  <br/>    isAntiAlias = true  <br/>    textSize = 100.sp.toPx()  <br/>    typeface = Typeface.create(Typeface.DEFAULT, Typeface.BOLD)  <br/>    color = android.graphics.Color.parseColor("#41E0E0")  <br/>    textAlign = android.graphics.Paint.Align.CENTER  <br/>    blendMode = android.graphics.BlendMode.XOR  &lt;----<br/>}</span></pre><p id="db58" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">这两者最终都会给我们同样的结果。</p><p id="101a" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">在Compose中使用混合模式的一个小警告:我必须在获得效果之前添加这一行。</p><pre class="kg kh ki kj gt mt ms mu mv aw mw bi"><span id="acf5" class="mx lt iq ms b gy my mz l na nb">Canvas(  <br/>    modifier = Modifier  <br/>        .graphicsLayer(alpha = 0.99f)  &lt;----<br/>        .fillMaxSize(),  <br/>    onDraw = {<br/>     ...</span></pre><p id="d1f0" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">有了这些，我就可以创建一个水动画的基本版本了。以下是我的最终结果:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi ln"><img src="../Images/badec0d8b656f97d337725b577ba142c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1200/1*5RCs1XExsaUJGifbhICbqw.gif"/></div></figure><p id="c96d" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">composable的完整代码可从<a class="ae nc" href="https://gist.github.com/sinasamaki/ce6160e7a8c0b8be4e060030bea2f194" rel="noopener ugc nofollow" target="_blank">这里</a>获得。</p><p id="48e7" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">这是我在compose中计划的一系列娱乐活动的第一篇文章。如果你有任何UI或动画的想法，在构图上做起来会很酷，让我在<a class="ae nc" href="https://twitter.com/sinasamaki" rel="noopener ugc nofollow" target="_blank">推特</a>上知道。</p><p id="2c2b" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">感谢阅读，祝你好运！</p></div><div class="ab cl nd ne hu nf" role="separator"><span class="ng bw bk nh ni nj"/><span class="ng bw bk nh ni nj"/><span class="ng bw bk nh ni"/></div><div class="ij ik il im in"><p id="052e" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">【https://www.sinasamaki.com】原载于<a class="ae nc" href="https://www.sinasamaki.com/made-in-compose-apple-watch-ultra-water-level-animation/" rel="noopener ugc nofollow" target="_blank"><em class="nk"/></a></p></div></div>    
</body>
</html>