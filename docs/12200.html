<html>
<head>
<title>5 JavaScript Utility Types — And How To Create Your Own</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">5种JavaScript实用程序类型——以及如何创建自己的实用程序</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/5-javascript-utility-types-and-how-to-create-your-own-39e6bcd5a3bd?source=collection_archive---------15-----------------------#2022-05-18">https://betterprogramming.pub/5-javascript-utility-types-and-how-to-create-your-own-39e6bcd5a3bd?source=collection_archive---------15-----------------------#2022-05-18</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="0709" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">高级打字稿:从零到英雄</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/a7911fb546a13925fd2a26a9b42b1e0a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*ppTKZSD3cC5NDBsW"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">由<a class="ae kv" href="https://unsplash.com/@lautaroandreani?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">劳塔罗·安德烈亚尼</a>在<a class="ae kv" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</p></figure><p id="ad5e" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">TypeScript有一堆有用的<a class="ae kv" href="https://www.typescriptlang.org/docs/handbook/utility-types.html" rel="noopener ugc nofollow" target="_blank">实用程序类型</a>。但是你知道如何自己创造它们吗？我相信如果您重新创建了它们中的每一个，您将会非常了解高级TypeScript特性。如果这仍然是一个问题，你有空间来提高你的技能。</p><p id="f198" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><em class="ls">我鼓励你遵循内置的实用程序类型列表，并尝试自己重新创建它们。它有助于揭示您的TypeScript知识中的一些空白，并且涵盖了所有高级TypeScript功能。</em></p><p id="d213" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">让我们讨论一下我将如何推荐阅读这篇文章以获得更多的好处。首先，我将提供一些关于特定TypeScript特性的基础知识，然后，提供一些我们需要自己实现的实用程序类型的相关示例。在你看答案之前，花些时间去实现它。</p><p id="e004" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这里的主要目的是提供允许我们从头开始重新实现每个实用程序类型所需的所有必要信息。</p><p id="e718" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在我们走得太远之前，本文假设您已经了解了泛型。如果你对它感到不舒服，不要担心，你可以看看<a class="ae kv" href="https://javascript.plainenglish.io/typescript-generics-explained-with-practical-examples-ff9865bc8f4a" rel="noopener ugc nofollow" target="_blank">这篇文章</a>。</p><h1 id="3c86" class="lt lu iq bd lv lw lx ly lz ma mb mc md jw me jx mf jz mg ka mh kc mi kd mj mk bi translated">1.映射类型</h1><p id="6bcb" class="pw-post-body-paragraph kw kx iq ky b kz ml jr lb lc mm ju le lf mn lh li lj mo ll lm ln mp lp lq lr ij bi translated">映射类型建立在用于声明属性类型的索引签名的语法之上。假设我们需要为一个只包含布尔属性的对象创建一个类型，您可以在下面的示例中看到这一点:</p><pre class="kg kh ki kj gt mq mr ms mt aw mu bi"><span id="aa5d" class="mv lu iq mr b gy mw mx l my mz">type OnlyBooleanProperties = {<br/>   [Key: string]: boolean<br/>}</span></pre><p id="5b79" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">索引签名类型经常与关键字<code class="fe na nb nc mr b">keyof</code>和<code class="fe na nb nc mr b">in </code>一起使用。假设我们有一个对象，我们想创建一个具有相同属性的新对象，但是每个属性都包含布尔类型的值，如下所示:</p><pre class="kg kh ki kj gt mq mr ms mt aw mu bi"><span id="23be" class="mv lu iq mr b gy mw mx l my mz">type OptionsFlags&lt;Type&gt; = {<br/>   [Key in keyof Type]: boolean<br/>}</span></pre><p id="b2c9" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在这个例子中，<code class="fe na nb nc mr b">OptionsFlags</code>将从类型<code class="fe na nb nc mr b">Type</code>中获取所有属性，并将它们的值改为布尔值。</p><h2 id="f8ba" class="mv lu iq bd lv nd ne dn lz nf ng dp md lf nh ni mf lj nj nk mh ln nl nm mj nn bi translated">示例1</h2><p id="f4c1" class="pw-post-body-paragraph kw kx iq ky b kz ml jr lb lc mm ju le lf mn lh li lj mo ll lm ln mp lp lq lr ij bi translated">我们来看看实用类型<code class="fe na nb nc mr b">Record&lt;Keys, Type&gt;</code>(链接<a class="ae kv" href="https://www.typescriptlang.org/docs/handbook/utility-types.html#recordkeys-type" rel="noopener ugc nofollow" target="_blank">此处</a>)。它构建了一个对象类型，其属性键为<code class="fe na nb nc mr b">Keys</code>，属性值为<code class="fe na nb nc mr b">Type</code>。如果没有这样的效用，我们怎么自己创造呢？你已经获得了如何完成它的必要知识，因此，花些时间自己完成它。之后，查看下面的答案:</p><pre class="kg kh ki kj gt mq mr ms mt aw mu bi"><span id="eeaa" class="mv lu iq mr b gy mw mx l my mz">type Record&lt;Keys extends keyof any, Type&gt; = {<br/>   [Key in Keys]: Type<br/>}</span></pre><h2 id="16d4" class="mv lu iq bd lv nd ne dn lz nf ng dp md lf nh ni mf lj nj nk mh ln nl nm mj nn bi translated">示例2</h2><p id="8d49" class="pw-post-body-paragraph kw kx iq ky b kz ml jr lb lc mm ju le lf mn lh li lj mo ll lm ln mp lp lq lr ij bi translated">我们来看看实用类型<code class="fe na nb nc mr b">Pick&lt;Type, Keys&gt;</code>(链接<a class="ae kv" href="https://www.typescriptlang.org/docs/handbook/utility-types.html#picktype-keys" rel="noopener ugc nofollow" target="_blank">此处</a>)。它通过从<code class="fe na nb nc mr b">Type</code>中选取一组属性<code class="fe na nb nc mr b">Keys</code>来构建一个类型。代码如下:</p><pre class="kg kh ki kj gt mq mr ms mt aw mu bi"><span id="f805" class="mv lu iq mr b gy mw mx l my mz">type Pick&lt;Type, Keys extends keyof Type&gt; = {<br/>   [Key in Keys]: Type[Key]<br/>}</span></pre><h1 id="fbd3" class="lt lu iq bd lv lw lx ly lz ma mb mc md jw me jx mf jz mg ka mh kc mi kd mj mk bi translated">2.映射类型的映射修饰符</h1><p id="7961" class="pw-post-body-paragraph kw kx iq ky b kz ml jr lb lc mm ju le lf mn lh li lj mo ll lm ln mp lp lq lr ij bi translated">在映射期间可以应用两个额外的修饰符:<code class="fe na nb nc mr b">readonly</code>和<code class="fe na nb nc mr b">?</code>，它们分别影响可变性和可选性。</p><p id="24e0" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">为了看到这一点，让我们看看<code class="fe na nb nc mr b">Partial&lt;Type&gt;</code>(链接<a class="ae kv" href="https://www.typescriptlang.org/docs/handbook/utility-types.html#partialtype" rel="noopener ugc nofollow" target="_blank">此处</a>)。它构建了一个类型，将<code class="fe na nb nc mr b">Type</code>的所有属性设置为可选，如下所示:</p><pre class="kg kh ki kj gt mq mr ms mt aw mu bi"><span id="26bf" class="mv lu iq mr b gy mw mx l my mz">type Partial&lt;Type&gt; = {<br/>   [Key in keyof Type]?: Type[Key];<br/>};</span></pre><p id="fbd2" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">您可以通过添加前缀<code class="fe na nb nc mr b">-</code>来删除修饰符<code class="fe na nb nc mr b">readonly</code>和<code class="fe na nb nc mr b">?</code>。</p><p id="8260" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这是另一个例子。它使用<code class="fe na nb nc mr b">Required&lt;Type&gt;</code>(链接<a class="ae kv" href="https://www.typescriptlang.org/docs/handbook/utility-types.html#requiredtype" rel="noopener ugc nofollow" target="_blank">这里是</a>)并构建一个由设置为required的<code class="fe na nb nc mr b">Type</code>的所有属性组成的类型。代码如下:</p><pre class="kg kh ki kj gt mq mr ms mt aw mu bi"><span id="56d2" class="mv lu iq mr b gy mw mx l my mz">type Required&lt;Type&gt; = {<br/>   [Key in keyof Type]-?:Type[Key]<br/>}</span></pre><h2 id="157b" class="mv lu iq bd lv nd ne dn lz nf ng dp md lf nh ni mf lj nj nk mh ln nl nm mj nn bi translated">示例3</h2><p id="30ba" class="pw-post-body-paragraph kw kx iq ky b kz ml jr lb lc mm ju le lf mn lh li lj mo ll lm ln mp lp lq lr ij bi translated">在前面的例子中，我们用一个<code class="fe na nb nc mr b">?</code>修饰符涵盖了所有的实用程序类型。为了得到更多的练习，你需要实现<code class="fe na nb nc mr b">Readonly&lt;Type&gt;</code>来使用一个<code class="fe na nb nc mr b">readonly</code>修饰符(链接<a class="ae kv" href="https://www.typescriptlang.org/docs/handbook/utility-types.html#readonlytype" rel="noopener ugc nofollow" target="_blank">在这里</a>)。它构造一个类型，将<code class="fe na nb nc mr b">Type</code>的所有属性设置为<code class="fe na nb nc mr b">readonly</code>。</p><pre class="kg kh ki kj gt mq mr ms mt aw mu bi"><span id="7e90" class="mv lu iq mr b gy mw mx l my mz">type Readonly&lt;Type&gt; = {<br/>   readonly [K in keyof Type]: Type[K]<br/>}</span></pre><h1 id="464a" class="lt lu iq bd lv lw lx ly lz ma mb mc md jw me jx mf jz mg ka mh kc mi kd mj mk bi translated">3.条件类型和从不类型</h1><p id="d8ed" class="pw-post-body-paragraph kw kx iq ky b kz ml jr lb lc mm ju le lf mn lh li lj mo ll lm ln mp lp lq lr ij bi translated">我们都知道JS代码中的三元条件，事实证明我们可以使用相同的语法来定义类型。这里的主要区别是，我们将使用带有关键字<code class="fe na nb nc mr b">extends</code>的表达式来表示条件部分的TS三元组。这个条件看起来像<code class="fe na nb nc mr b">T extend K</code>。代码如下:</p><pre class="kg kh ki kj gt mq mr ms mt aw mu bi"><span id="2daf" class="mv lu iq mr b gy mw mx l my mz">SomeType extends OtherType ? TrueType : FalseType;</span></pre><p id="829d" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">当<code class="fe na nb nc mr b">extends</code>左边的类型被赋值给右边的类型时，你将得到第一个分支中的类型(“真”分支)；否则，您将获得后一个分支中的类型(“假”分支)。举个例子，</p><pre class="kg kh ki kj gt mq mr ms mt aw mu bi"><span id="8add" class="mv lu iq mr b gy mw mx l my mz">10 extends number ? 'YES' : 'NO'<br/>    =&gt; 'YES'  // since 10 extends number === true</span><span id="2a40" class="mv lu iq mr b gy no mx l my mz">10 extends string ? 'YES' : 'NO'<br/>    =&gt; 'NO'   // since 10 extends string === false</span></pre><p id="27e2" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">让我们来看另一个例子:</p><pre class="kg kh ki kj gt mq mr ms mt aw mu bi"><span id="7dc1" class="mv lu iq mr b gy mw mx l my mz">type StringFromType&lt;T&gt; = T extends string ? 'string' : never;</span><span id="6916" class="mv lu iq mr b gy no mx l my mz">type Type1 = StringFromType&lt;"text"&gt;;  // string<br/>type Type2 = StringFromType&lt;10&gt;;      // never</span></pre><p id="8812" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这里需要给一些关于<code class="fe na nb nc mr b">never</code>型的话。它的字面意思是“没有价值”，它被视为空集<code class="fe na nb nc mr b">∅</code>。通常，<code class="fe na nb nc mr b">never</code>用于逻辑上不应该发生的情况和控制流。你会经常看到它被用作一个死胡同类型，就像上面的例子。</p><p id="160f" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">另外，我想强调一下<code class="fe na nb nc mr b">never</code>在一个像<code class="fe na nb nc mr b">string | never</code>这样的联合类型中的行为，因为<code class="fe na nb nc mr b">never</code>意味着一个空集(<code class="fe na nb nc mr b">∅</code>)。因此任何集合与空集的<a class="ae kv" href="https://www.thoughtco.com/what-is-the-union-3126595" rel="noopener ugc nofollow" target="_blank">并集</a>就是我们开始的集合— <code class="fe na nb nc mr b"> <em class="ls">X</em> U ∅ = <em class="ls">X</em></code> <em class="ls">。</em>它的意思如下:</p><pre class="kg kh ki kj gt mq mr ms mt aw mu bi"><span id="670b" class="mv lu iq mr b gy mw mx l my mz">string | never     =&gt; string;<br/>number | never     =&gt; number;<br/>&lt;AnyType&gt; | never  =&gt; AnyType;</span></pre><p id="4c4d" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们还可以像在JavaScript中嵌套三元运算符一样链接更多的条件，如下所示:</p><pre class="kg kh ki kj gt mq mr ms mt aw mu bi"><span id="698c" class="mv lu iq mr b gy mw mx l my mz">type StringFromType&lt;T&gt; = <br/>    T extends string<br/>       ? 'string'<br/>       : T extends number<br/>          ? 'number'<br/>          : never;</span><span id="43e6" class="mv lu iq mr b gy no mx l my mz">type Type1 = StringFromType&lt;"text"&gt;;  // string<br/>type Type2 = StringFromType&lt;10&gt;;      // number<br/>type Type3 = StringFromType&lt;{}&gt;;      // never</span></pre><p id="e8fb" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在大多数情况下，你不会喜欢到达一个死胡同类型<code class="fe na nb nc mr b">never</code>。实际上，最好使用<code class="fe na nb nc mr b">extend</code>关键字对泛型<code class="fe na nb nc mr b">T</code>进行约束，并仅列出允许的类型，如下所示:</p><pre class="kg kh ki kj gt mq mr ms mt aw mu bi"><span id="33bd" class="mv lu iq mr b gy mw mx l my mz">type StringFromType&lt;T extends string | number&gt; = <br/>    T extends string<br/>       ? 'string'<br/>       : T extends number<br/>          ? 'number'<br/>          : never;</span></pre><p id="fa15" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在这种情况下，TypeScript甚至不允许您将该类型与除<code class="fe na nb nc mr b">number</code>或<code class="fe na nb nc mr b">string</code>之外的类型一起使用，因此，没有办法到达<code class="fe na nb nc mr b">never</code>。它看起来像下面这样:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi np"><img src="../Images/e0c684c1b223adffb766bafd33fe8574.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*AhTeh3nguah4MUkef0s_Jg.png"/></div></div></figure><h1 id="bd7f" class="lt lu iq bd lv lw lx ly lz ma mb mc md jw me jx mf jz mg ka mh kc mi kd mj mk bi translated">4.分配条件类型</h1><p id="fc92" class="pw-post-body-paragraph kw kx iq ky b kz ml jr lb lc mm ju le lf mn lh li lj mo ll lm ln mp lp lq lr ij bi translated">在将联合作为约束进行扩展的情况下，TypeScript将对联合的每个成员进行循环，并返回自己的联合。这是什么意思？假设我们有以下条件类型:</p><pre class="kg kh ki kj gt mq mr ms mt aw mu bi"><span id="1554" class="mv lu iq mr b gy mw mx l my mz">type NonNullable&lt;Type&gt; <br/>     =  Type extends null | undefined ? never : Type;</span></pre><p id="f5cd" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">如果我们传递一个泛型类型而不是具有以下形状的联合类型，TypeScript如何计算它<code class="fe na nb nc mr b">string | null | undefined</code>。如上所述，它在每个成员上循环，可以这样重写:</p><pre class="kg kh ki kj gt mq mr ms mt aw mu bi"><span id="518a" class="mv lu iq mr b gy mw mx l my mz">type ReturnedType = NonNullable&lt;string | null | undefined&gt;<br/>     =   (string extends null | undefined ? never : string)<br/>       | (null extends null | undefined ? never : null)<br/>       | (undefined extends null | undefined ? never : undefine)<br/>     = string | never | never<br/>     = string</span></pre><p id="b63e" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">顺便说一下，我们已经实现了另一个内置的<code class="fe na nb nc mr b">NonNullable&lt;Type&gt;</code>(链接<a class="ae kv" href="https://www.typescriptlang.org/docs/handbook/utility-types.html#nonnullabletype" rel="noopener ugc nofollow" target="_blank">这里</a>)并且我们已经知道它是如何工作的。恭喜你。</p><h2 id="e744" class="mv lu iq bd lv nd ne dn lz nf ng dp md lf nh ni mf lj nj nk mh ln nl nm mj nn bi translated">实例4</h2><p id="b1f5" class="pw-post-body-paragraph kw kx iq ky b kz ml jr lb lc mm ju le lf mn lh li lj mo ll lm ln mp lp lq lr ij bi translated">我们来看看实用类型<code class="fe na nb nc mr b">Exclude&lt;UnionType, ExcludedMembers&gt;</code>(链接<a class="ae kv" href="https://www.typescriptlang.org/docs/handbook/utility-types.html#excludeuniontype-excludedmembers" rel="noopener ugc nofollow" target="_blank">此处</a>)。它通过从所有可分配给<code class="fe na nb nc mr b">ExcludedMembers</code>的工会成员中排除<code class="fe na nb nc mr b">UnionType</code>来创建一个新类型。</p><pre class="kg kh ki kj gt mq mr ms mt aw mu bi"><span id="8136" class="mv lu iq mr b gy mw mx l my mz">type Exclude&lt;UnionType, ExcludedMembers&gt; <br/>     = UnionType extends ExcludedMembers ? never : UnionType</span></pre><p id="0821" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">老实说，对我来说，这并不容易理解。因此，让我们像TypeScript transpiler那样遍历每个联合类型成员，并为每个成员计算一个条件。</p><pre class="kg kh ki kj gt mq mr ms mt aw mu bi"><span id="36eb" class="mv lu iq mr b gy mw mx l my mz">type NewType = Exclude&lt;'a' | 'b' | 'c', 'a'&gt;<br/>    =    ('a' extends 'a' ? never : 'a')<br/>       | ('b' extends 'a' ? never : 'b')<br/>       | ('c' extends 'a' ? never : 'c')<br/>    = never | 'b' | 'c' <br/>    = 'b' | 'c'</span></pre><h2 id="8054" class="mv lu iq bd lv nd ne dn lz nf ng dp md lf nh ni mf lj nj nk mh ln nl nm mj nn bi translated">实例5</h2><p id="4893" class="pw-post-body-paragraph kw kx iq ky b kz ml jr lb lc mm ju le lf mn lh li lj mo ll lm ln mp lp lq lr ij bi translated">哇，如果例子4对你来说很清楚，我相信你会整理出下一个实用程序类型:<code class="fe na nb nc mr b">Extract&lt;UnionType, ExtractedMembers&gt;</code>(链接<a class="ae kv" href="https://www.typescriptlang.org/docs/handbook/utility-types.html#extracttype-union" rel="noopener ugc nofollow" target="_blank">此处</a>)。它通过从<code class="fe na nb nc mr b">UnionType</code>中提取所有可分配给<code class="fe na nb nc mr b">ExtractedMembers</code>的联合成员来创建一个类型。</p><pre class="kg kh ki kj gt mq mr ms mt aw mu bi"><span id="6359" class="mv lu iq mr b gy mw mx l my mz">type Extract&lt;UnionType, ExtractedMembers&gt;<br/>     = UnionType extends ExcludedMembers ? UnionType: never</span></pre><p id="4f32" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们只是在三元运算中交换了左右操作数。让我们根据这个例子来考虑一下TypeScript transpiler在钩子下是如何工作的:</p><pre class="kg kh ki kj gt mq mr ms mt aw mu bi"><span id="9f6f" class="mv lu iq mr b gy mw mx l my mz">type NewType = Extract&lt;'a' | 'b' | 'c', 'a' | 'c'&gt;<br/>    =    ('a' extends 'a' | 'c' ? 'a' : never)<br/>       | ('b' extends 'a' | 'c' ? 'b' : never)<br/>       | ('c' extends 'a' | 'c' ? 'c' : never)<br/>    = 'a' | never | 'c'<br/>    = 'a' | 'c'</span></pre><h2 id="6eb9" class="mv lu iq bd lv nd ne dn lz nf ng dp md lf nh ni mf lj nj nk mh ln nl nm mj nn bi translated">实例6</h2><p id="5bc6" class="pw-post-body-paragraph kw kx iq ky b kz ml jr lb lc mm ju le lf mn lh li lj mo ll lm ln mp lp lq lr ij bi translated">这个例子与分布式条件类型主题无关，但是它建立在我们已经实现的<code class="fe na nb nc mr b">Exclude&lt;UnionType, ExcludedMember&gt;</code>类型之上(例子4)。这是一个回忆的绝佳机会。嗯，它是<code class="fe na nb nc mr b">Omit&lt;Type, OmittedKeys&gt;</code>(链接<a class="ae kv" href="https://www.typescriptlang.org/docs/handbook/utility-types.html#omittype-keys" rel="noopener ugc nofollow" target="_blank">这里是</a>)，它通过从<code class="fe na nb nc mr b">Type</code>中选取所有属性，然后移除<code class="fe na nb nc mr b">OmittedKeys</code>来创建一个类型。</p><pre class="kg kh ki kj gt mq mr ms mt aw mu bi"><span id="7acd" class="mv lu iq mr b gy mw mx l my mz">type Omit&lt;Type, OmmitedKeys extends keyof Type&gt; = {<br/>   [Key in Exclude&lt;keyof Type, OmmitedKeys&gt;]: Type[Key]<br/>}</span></pre><p id="a6a1" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我希望它做得很好，并且我们没有忘记我们在第一部分中讨论的映射类型主题。</p><h1 id="e5fc" class="lt lu iq bd lv lw lx ly lz ma mb mc md jw me jx mf jz mg ka mh kc mi kd mj mk bi translated">5.条件类型推理</h1><p id="97f9" class="pw-post-body-paragraph kw kx iq ky b kz ml jr lb lc mm ju le lf mn lh li lj mo ll lm ln mp lp lq lr ij bi translated">条件类型最有趣的部分可能是，我们可以从条件语句的一部分中推断出新的类型，该语句可能会在“真”或“假”分支中的条件类型中使用。不要害怕；这听起来很吓人，直到我们没有看到一个特定的例子。所以让我们来看一个:</p><pre class="kg kh ki kj gt mq mr ms mt aw mu bi"><span id="69cb" class="mv lu iq mr b gy mw mx l my mz">type IdType&lt;T&gt; = T extends { id: infer ID} ? ID: never;</span></pre><p id="f5dc" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在这个例子中，我们从类型<code class="fe na nb nc mr b">T</code>的<code class="fe na nb nc mr b">id</code>字段中推断出类型<code class="fe na nb nc mr b">ID</code>。如果<code class="fe na nb nc mr b">T</code>有<code class="fe na nb nc mr b">id</code>属性，TypeScript推断该属性的类型为<code class="fe na nb nc mr b">ID</code>，我们可以在“真”或“假”分支中使用它。</p><h2 id="7a67" class="mv lu iq bd lv nd ne dn lz nf ng dp md lf nh ni mf lj nj nk mh ln nl nm mj nn bi translated">例7</h2><p id="5ec1" class="pw-post-body-paragraph kw kx iq ky b kz ml jr lb lc mm ju le lf mn lh li lj mo ll lm ln mp lp lq lr ij bi translated">我们来看一下<code class="fe na nb nc mr b">ReturnType&lt;Type&gt;</code>(链接<a class="ae kv" href="https://www.typescriptlang.org/docs/handbook/utility-types.html#returntypetype" rel="noopener ugc nofollow" target="_blank">这里是</a>)构造一个由函数的返回类型组成的类型。</p><pre class="kg kh ki kj gt mq mr ms mt aw mu bi"><span id="fdb3" class="mv lu iq mr b gy mw mx l my mz">type ReturnType&lt;T extends (...args: any) =&gt; any&gt; <br/>     = T extends (...args: any) =&gt; infer R ? R : any;</span></pre><h2 id="7d01" class="mv lu iq bd lv nd ne dn lz nf ng dp md lf nh ni mf lj nj nk mh ln nl nm mj nn bi translated">实施例8</h2><p id="ffa2" class="pw-post-body-paragraph kw kx iq ky b kz ml jr lb lc mm ju le lf mn lh li lj mo ll lm ln mp lp lq lr ij bi translated">它不包含在TypeScript实用程序类型中，但有时它可能非常方便，特别是当您试图从3d party库中扩展任何不扩展属性类型的React组件时。</p><p id="40cb" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在大多数情况下，我们坚持使用函数式方法，React组件被表示为一个函数，其中第一个参数是组件props。我们需要推断出一种类型的<code class="fe na nb nc mr b">Component </code>道具。</p><pre class="kg kh ki kj gt mq mr ms mt aw mu bi"><span id="35c5" class="mv lu iq mr b gy mw mx l my mz">const Component = (props: { prop1: string }) =&gt; null;</span><span id="68d1" class="mv lu iq mr b gy no mx l my mz">// should extract type of props: {prop1: string}<br/>type T0 = ComponentProps&lt;typeof Component&gt;</span></pre><p id="0f4f" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">花一些时间自己实现它，但是方法类似于示例7中的方法。</p><pre class="kg kh ki kj gt mq mr ms mt aw mu bi"><span id="407c" class="mv lu iq mr b gy mw mx l my mz">type ComponentProps&lt;T extends (arg: any) =&gt; any&gt; <br/>    = T extends (arg: infer Props) =&gt; any ? Props : never;</span></pre><p id="101f" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">与示例7的不同之处在于我们在函数声明中推断类型的地方。顺便说一句，这个类型已经在<code class="fe na nb nc mr b">react</code>中实现了，名称相同，但是他们的类型考虑到了函数和类<code class="fe na nb nc mr b">Components</code>。代码如下:</p><pre class="kg kh ki kj gt mq mr ms mt aw mu bi"><span id="3493" class="mv lu iq mr b gy mw mx l my mz">import { ComponentType } from 'react'</span></pre><p id="04d4" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">感谢阅读！</p><p id="345e" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我希望你喜欢阅读这篇文章。</p></div></div>    
</body>
</html>