<html>
<head>
<title>Build a CSV Parser Using AsyncSequence in Swift</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">在Swift中使用AsyncSequence构建CSV解析器</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/simple-csv-parser-using-asyncsequence-7356fd7d800?source=collection_archive---------4-----------------------#2022-07-31">https://betterprogramming.pub/simple-csv-parser-using-asyncsequence-7356fd7d800?source=collection_archive---------4-----------------------#2022-07-31</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="0466" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">在您的iOS应用程序中轻松解析数据</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/b11007479aa6f7b7c6a5e7ddc70f54f0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*71TTPkOJaZrLAD9z4EEoDw.jpeg"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">照片由<a class="ae kv" href="https://unsplash.com/@mbaumi?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">米卡·鲍梅斯特</a>在<a class="ae kv" href="https://unsplash.com/photos/Wpnoqo2plFA?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</p></figure><p id="5258" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我想解析一些来自Zillow的CSV文件中的住房数据。我认为这将是一个学习如何使用编写自定义序列的好方法。这个简短的教程将介绍如何编写一个简单的CSV解析器，它使用<code class="fe ls lt lu lv b">AsyncSequence</code>将数据解析为一个值数组。</p><p id="5991" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">本文中的源代码可以在<a class="ae kv" href="https://github.com/scottandrew/CSVParser.git" rel="noopener ugc nofollow" target="_blank"> Github </a>中。</p><h1 id="62d3" class="lw lx iq bd ly lz ma mb mc md me mf mg jw mh jx mi jz mj ka mk kc ml kd mm mn bi translated"><strong class="ak">什么是CSV </strong></h1><p id="1f31" class="pw-post-body-paragraph kw kx iq ky b kz mo jr lb lc mp ju le lf mq lh li lj mr ll lm ln ms lp lq lr ij bi translated">CSV(逗号分隔值)文件是以列/行格式保存数据的文本文件。每行是一组数据，每列有一个值。第一行有一个可选的标题。这些列通常由逗号(，)分隔。</p><p id="e390" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">一篇完整的维基百科文章可以在这里找到。</p><h1 id="87db" class="lw lx iq bd ly lz ma mb mc md me mf mg jw mh jx mi jz mj ka mk kc ml kd mm mn bi translated"><strong class="ak">异步序列</strong></h1><p id="8d93" class="pw-post-body-paragraph kw kx iq ky b kz mo jr lb lc mp ju le lf mq lh li lj mr ll lm ln ms lp lq lr ij bi translated">AsyncSequence是通过Swift async/await引入的。它允许您异步枚举一组对象——就像在列表中一样。但是，当您循环一个项时，数据的这个数据序列不一定在内存中——从而允许您在每次迭代中等待取值。完整的文档见<a class="ae kv" href="https://developer.apple.com/documentation/swift/asyncsequence" rel="noopener ugc nofollow" target="_blank">苹果文档</a>。</p><h1 id="eafc" class="lw lx iq bd ly lz ma mb mc md me mf mg jw mh jx mi jz mj ka mk kc ml kd mm mn bi translated">我们想要解析的数据</h1><p id="79bc" class="pw-post-body-paragraph kw kx iq ky b kz mo jr lb lc mp ju le lf mq lh li lj mr ll lm ln ms lp lq lr ij bi translated">我们将从Zillow解析一些住房数据。该数据是美国各地区的月平均房价。对于本教程，我们将使用家庭价值价格，下载链接可以在<a class="ae kv" href="https://www.zillow.com/research/data/" rel="noopener ugc nofollow" target="_blank">这里</a>找到。我们将使用的地铁&amp;美国数据可以在这个<a class="ae kv" href="https://files.zillowstatic.com/research/public_csvs/zhvi/Metro_zhvi_uc_sfrcondo_tier_0.33_0.67_sm_sa_month.csv?t=1659150579" rel="noopener ugc nofollow" target="_blank">链接</a>中找到。</p><p id="dc94" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">让我们看看前三行的前6列。<code class="fe ls lt lu lv b">column 5</code>之后的列都是日期。</p><p id="47c1" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">数据如下所示:</p><pre class="kg kh ki kj gt mt lv mu mv aw mw bi"><span id="393c" class="mx lx iq lv b gy my mz l na nb">RegionID,SizeRank,RegionName,RegionType,StateName,2000–01–31,<br/>102001,0,United States,Country,,128454.0<br/>394913,1,”New York, NY”,Msa,NY,225516.0</span></pre><p id="4ca4" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">从这些数据中我们可以看出:</p><ul class=""><li id="5736" class="nc nd iq ky b kz la lc ld lf ne lj nf ln ng lr nh ni nj nk bi translated">各列用逗号分隔</li><li id="b8cc" class="nc nd iq ky b kz nl lc nm lf nn lj no ln np lr nh ni nj nk bi translated">逗号和数据之间没有空格</li><li id="7dbb" class="nc nd iq ky b kz nl lc nm lf nn lj no ln np lr nh ni nj nk bi translated">假设一切都是字符串。</li><li id="985e" class="nc nd iq ky b kz nl lc nm lf nn lj no ln np lr nh ni nj nk bi translated">缺失数据可以有空白栏。</li><li id="b279" class="nc nd iq ky b kz nl lc nm lf nn lj no ln np lr nh ni nj nk bi translated">我们需要引号之间的字符串。</li></ul><h1 id="4c4f" class="lw lx iq bd ly lz ma mb mc md me mf mg jw mh jx mi jz mj ka mk kc ml kd mm mn bi translated"><strong class="ak">跟踪线路</strong></h1><p id="f6cc" class="pw-post-body-paragraph kw kx iq ky b kz mo jr lb lc mp ju le lf mq lh li lj mr ll lm ln ms lp lq lr ij bi translated">对数据的每次迭代都将返回一个行结构，该行结构包含行号和数据在行中的顺序。</p><p id="3db8" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">数据以可选字符串数组的形式返回。任何丢失的数据或两个逗号之间没有文本都被认为是数组中的<code class="fe ls lt lu lv b">nil</code>。</p><pre class="kg kh ki kj gt mt lv nq bn nr ns bi"><span id="f84f" class="nt lx iq lv b be nu nv l nw nb">struct Line {<br/>  let lineNumber: Int<br/>  let data: [String?]<br/>}</span></pre><p id="9ce6" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">CSV在文档中可以有一个标题——通常在第一行，所以跟踪行号很重要。</p><h1 id="cd02" class="lw lx iq bd ly lz ma mb mc md me mf mg jw mh jx mi jz mj ka mk kc ml kd mm mn bi translated">清除解析器</h1><p id="f1bc" class="pw-post-body-paragraph kw kx iq ky b kz mo jr lb lc mp ju le lf mq lh li lj mr ll lm ln ms lp lq lr ij bi translated"><code class="fe ls lt lu lv b">URL</code>类有一些新的属性——<code class="fe ls lt lu lv b">url.lines</code>来异步迭代文本行。CSV解析器将使用这个<code class="fe ls lt lu lv b"><strong class="ky ir">AsyncSequence</strong></code>来解析URL中的行。</p><pre class="kg kh ki kj gt mt lv nq bn nr ns bi"><span id="9515" class="nt lx iq lv b be nu nv l nw nb">typealias LineIterator = AsyncLineSequence&lt;URL.AsyncBytes&gt;.AsyncIterator<br/><br/>struct CSVParser: AsyncSequence, AsyncIteratorProtocol {   <br/>  private let url: URL<br/>  private var lineIterator: LineIterator<br/>  private let seperator: Character<br/>  private let quoteCharacter: Character = "\""<br/>  private var lineNumber = 0<br/>    <br/>  init(url: URL, seperator: Character = ",") {<br/>    self.url = url<br/>    self.seperator = seperator<br/>    self.lineIterator = url.lines.makeAsyncIterator()<br/>  }<br/>}</span></pre><p id="3cbc" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们的解析器的基础相当简单。</p><ul class=""><li id="54ff" class="nc nd iq ky b kz la lc ld lf ne lj nf ln ng lr nh ni nj nk bi translated">我们有一个接受URL和数据分隔符的构造函数。它默认为逗号(，)。</li><li id="254f" class="nc nd iq ky b kz nl lc nm lf nn lj no ln np lr nh ni nj nk bi translated"><code class="fe ls lt lu lv b">iineIterator</code>是异步迭代器的实例，我们将使用它从URL中获取文本行。我使用了一个<code class="fe ls lt lu lv b">typealias</code>来简化类型的语法。</li><li id="3db4" class="nc nd iq ky b kz nl lc nm lf nn lj no ln np lr nh ni nj nk bi translated"><code class="fe ls lt lu lv b">lineNumber</code>我们当前以0为基数的行号。</li><li id="fde6" class="nc nd iq ky b kz nl lc nm lf nn lj no ln np lr nh ni nj nk bi translated">属性来抓住我们的<code class="fe ls lt lu lv b">url</code>和<code class="fe ls lt lu lv b">delimeter.</code></li></ul><h1 id="88f9" class="lw lx iq bd ly lz ma mb mc md me mf mg jw mh jx mi jz mj ka mk kc ml kd mm mn bi translated">实现异步序列和异步解释器</h1><p id="d5ca" class="pw-post-body-paragraph kw kx iq ky b kz mo jr lb lc mp ju le lf mq lh li lj mr ll lm ln ms lp lq lr ij bi translated">我们需要实现我们的序列和迭代器。</p><h2 id="79f9" class="mx lx iq bd ly nx ny dn mc nz oa dp mg lf ob oc mi lj od oe mk ln of og mm oh bi translated">异步序列</h2><ul class=""><li id="7b9b" class="nc nd iq ky b kz mo lc mp lf oi lj oj ln ok lr nh ni nj nk bi translated"><code class="fe ls lt lu lv b">Element</code>要返回的元素的类型，在我们的例子中是<code class="fe ls lt lu lv b">Line</code>。</li></ul><pre class="kg kh ki kj gt mt lv nq bn nr ns bi"><span id="d400" class="nt lx iq lv b be nu nv l nw nb">typealias Element = Line</span></pre><ul class=""><li id="5af0" class="nc nd iq ky b kz la lc ld lf ne lj nf ln ng lr nh ni nj nk bi translated"><code class="fe ls lt lu lv b">makeAysncIterator</code>函数创建一个新的迭代器用于生成行。在我们的例子中，那只是<code class="fe ls lt lu lv b">self</code>。</li></ul><pre class="kg kh ki kj gt mt lv nq bn nr ns bi"><span id="24a8" class="nt lx iq lv b be nu nv l nw nb">func makeAsyncIterator() -&gt; CSVParser {<br/>  return self<br/>}</span></pre><h2 id="2453" class="mx lx iq bd ly nx ny dn mc nz oa dp mg lf ob oc mi lj od oe mk ln of og mm oh bi translated">AsyncIterator</h2><ul class=""><li id="1e7e" class="nc nd iq ky b kz mo lc mp lf oi lj oj ln ok lr nh ni nj nk bi translated"><code class="fe ls lt lu lv b">next</code>检索序列中的下一个<code class="fe ls lt lu lv b">Line</code>，并在返回行后增加行号。如果没有更多的行，则返回<code class="fe ls lt lu lv b">nil</code>，停止枚举。</li></ul><pre class="kg kh ki kj gt mt lv nq bn nr ns bi"><span id="a800" class="nt lx iq lv b be nu nv l nw nb">mutating func next() async throws -&gt; Line? {<br/>  if let string = try await lineIterator.next() {<br/>    defer { lineNumber += 1 }<br/>    return Line(<br/>      lineNumber: lineNumber,<br/>      data: split(line: string)<br/>    )<br/>  }<br/>      <br/>  return nil<br/>}</span></pre><h1 id="3bb2" class="lw lx iq bd ly lz ma mb mc md me mf mg jw mh jx mi jz mj ka mk kc ml kd mm mn bi translated">分裂函数</h1><p id="02e8" class="pw-post-body-paragraph kw kx iq ky b kz mo jr lb lc mp ju le lf mq lh li lj mr ll lm ln ms lp lq lr ij bi translated">在<code class="fe ls lt lu lv b">split</code>函数中，我们逐个字符地遍历该行，并将该行拆分成一个可选字符串数组。</p><pre class="kg kh ki kj gt mt lv nq bn nr ns bi"><span id="dbda" class="nt lx iq lv b be nu nv l nw nb">private func split(line: String) -&gt; [String?] {<br/>  var data = [String?]()<br/>  var inQuote = false<br/>  var currentString = ""<br/>      <br/>  for character in line {<br/>    switch character {<br/>    case quoteCharacter:<br/>      inQuote = !inQuote<br/>      continue<br/>              <br/>    case seperator:<br/>      if !inQuote {<br/>        data.append(currentString.isEmpty ? nil : currentString)<br/>        currentString = ""<br/>        continue<br/>      }<br/>              <br/>    default:<br/>      break<br/>    }<br/>          <br/>    currentString.append(character)<br/>  }<br/>      <br/>  data.append(currentString.isEmpty ? nil : currentString)<br/>      <br/>  return data<br/>}</span></pre><p id="fcdb" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">将每个角色排成一行。遵循以下规则:</p><ul class=""><li id="17e0" class="nc nd iq ky b kz la lc ld lf ne lj nf ln ng lr nh ni nj nk bi translated">如果我们打了一个引号，那么我们将<code class="fe ls lt lu lv b">inQuote</code> flat设置为true或false。只要这是真的所有字符，直到我们设置<code class="fe ls lt lu lv b">inQuote</code>为假将被添加到<code class="fe ls lt lu lv b">currentString</code>。</li><li id="dc89" class="nc nd iq ky b kz nl lc nm lf nn lj no ln np lr nh ni nj nk bi translated">当遇到一个分隔符，并且我们不在引号中时，将<code class="fe ls lt lu lv b">currentString</code>放在<code class="fe ls lt lu lv b">data</code>数组的末尾。如果<code class="fe ls lt lu lv b">currentString</code>是空的，把<code class="fe ls lt lu lv b">nil</code>放在<code class="fe ls lt lu lv b">data</code>数组的末尾。我们加到数组后复位<code class="fe ls lt lu lv b">currentString</code>。最后移到下一个字符。</li><li id="994e" class="nc nd iq ky b kz nl lc nm lf nn lj no ln np lr nh ni nj nk bi translated">默认情况下，行为是将当前字符添加到<code class="fe ls lt lu lv b">currentString</code></li><li id="febe" class="nc nd iq ky b kz nl lc nm lf nn lj no ln np lr nh ni nj nk bi translated">返回数组之前的最后一件事是将一直解析到行尾的数据添加到<code class="fe ls lt lu lv b">data</code>数组中。</li></ul><p id="7487" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><code class="fe ls lt lu lv b">1, 2, 3,,5, 6</code>会返回<code class="fe ls lt lu lv b">["1", "2", "3", nil, "5", "6"]</code>。</p><h1 id="792e" class="lw lx iq bd ly lz ma mb mc md me mf mg jw mh jx mi jz mj ka mk kc ml kd mm mn bi translated">把所有的放在一起</h1><p id="9962" class="pw-post-body-paragraph kw kx iq ky b kz mo jr lb lc mp ju le lf mq lh li lj mr ll lm ln ms lp lq lr ij bi translated">最终的解析器看起来像这样:</p><pre class="kg kh ki kj gt mt lv nq bn nr ns bi"><span id="810e" class="nt lx iq lv b be nu nv l nw nb">typealias LineIterator = AsyncLineSequence&lt;URL.AsyncBytes&gt;.AsyncIterator<br/><br/>struct CSVParser: AsyncSequence, AsyncIteratorProtocol {<br/>  // this is our type we are going to return on next()<br/>  typealias Element = Line<br/>    <br/>  private let url: URL<br/>  private var lineIterator: LineIterator<br/>  private let seperator: Character<br/>  private let quoteCharacter: Character = "\""<br/>  private var lineNumber = 0<br/>    <br/>  init(url: URL, seperator: Character = ",") {<br/>    self.url = url<br/>    self.seperator = seperator<br/>    self.lineIterator = url.lines.makeAsyncIterator()<br/>  }<br/>    <br/>    mutating func next() async throws -&gt; Line? {<br/>      if let string = try await lineIterator.next() {<br/>        defer { lineNumber += 1 }<br/>        return Line(<br/>          lineNumber: lineNumber,<br/>          data: split(line: string)<br/>        )<br/>      }<br/>          <br/>      return nil<br/>    }<br/>    <br/>  func makeAsyncIterator() -&gt; CSVParser {<br/>    return self<br/>  }<br/>    <br/>  private func split(line: String) -&gt; [String?] {<br/>    var data = [String?]()<br/>    var inQuote = false<br/>    var currentString = ""<br/>        <br/>    for character in line {<br/>      switch character {<br/>      case quoteCharacter:<br/>        inQuote = !inQuote<br/>        continue<br/>                <br/>      case seperator:<br/>        if !inQuote {<br/>          data.append(currentString.isEmpty ? nil : currentString)<br/>          currentString = ""<br/>          continue<br/>        }<br/>                <br/>      default:<br/>        break<br/>      }<br/>            <br/>      currentString.append(character)<br/>    }<br/>        <br/>    data.append(currentString.isEmpty ? nil : currentString)<br/>        <br/>    return data<br/>  }<br/>}</span></pre><h1 id="2824" class="lw lx iq bd ly lz ma mb mc md me mf mg jw mh jx mi jz mj ka mk kc ml kd mm mn bi translated">运行代码</h1><p id="9167" class="pw-post-body-paragraph kw kx iq ky b kz mo jr lb lc mp ju le lf mq lh li lj mr ll lm ln ms lp lq lr ij bi translated">移除<code class="fe ls lt lu lv b">main.swift</code>类并创建一个<code class="fe ls lt lu lv b">App</code>对象来运行代码。这将允许我们的应用程序有一个异步主入口点。<code class="fe ls lt lu lv b">App.swift</code>文件应该如下所示:</p><pre class="kg kh ki kj gt mt lv nq bn nr ns bi"><span id="1992" class="nt lx iq lv b be nu nv l nw nb">import Foundation<br/><br/>@main<br/>enum App {<br/>  static func main() async throws {<br/>    do {<br/>      let parser = CSVParser(url: URL(string: "https://files.zillowstatic.com/research/public_csvs/zhvi/Metro_zhvi_uc_sfrcondo_tier_0.33_0.67_sm_sa_month.csv?t=1659150579")!)<br/><br/>      for try await line in parser {<br/>        print("line: \(line.lineNumber)\ndata: \(line.data)")<br/>      }<br/>    } catch {<br/>      print("Error: \(error)")<br/>    }<br/>  }<br/>}</span></pre><p id="58cd" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">运行该程序将打印每一行对象。</p><p id="806e" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">感谢阅读。</p></div></div>    
</body>
</html>