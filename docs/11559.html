<html>
<head>
<title>Reacting to Windows Settings Change in a Flutter Desktop App</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">对Flutter桌面应用程序中的Windows设置更改做出反应</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/dynamic-theme-settings-change-in-a-flutter-desktop-app-63f137630417?source=collection_archive---------8-----------------------#2022-03-30">https://betterprogramming.pub/dynamic-theme-settings-change-in-a-flutter-desktop-app-63f137630417?source=collection_archive---------8-----------------------#2022-03-30</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="6f47" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">使用事件通道接收事件，动态主题化您的Flutter Windows应用程序</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/c9054f350df0da940ddf60d408039e90.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*Zemv0mOSm1ey6a8w"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">照片由<a class="ae ky" href="https://unsplash.com/@vidarnm?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">维达尔·诺德里-马西森</a>在<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>拍摄</p></figure><p id="8e0a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><em class="lv">简介:</em>学习如何在插件中使用<em class="lv">平台通道</em>从Flutter设置一个<code class="fe lw lx ly lz b">WNDPROC </code>回调函数。该示例展示了如何在应用程序中动态更改主题。</p><h1 id="0caa" class="ma mb it bd mc md me mf mg mh mi mj mk jz ml ka mm kc mn kd mo kf mp kg mq mr bi translated">介绍</h1><p id="3d1d" class="pw-post-body-paragraph kz la it lb b lc ms ju le lf mt jx lh li mu lk ll lm mv lo lp lq mw ls lt lu im bi translated">两个月前<a class="ae ky" href="https://medium.com/flutter/whats-new-in-flutter-2-10-5aafb0314b12" rel="noopener"> Flutter 2.10 </a>带来了稳定的Windows支持。好吧，这不是新闻，Flutter以前为Windows编译应用，为什么现在这么重要？答案是一个简单的词:“稳定”，因为现在谷歌宣布它是，我们可以决定投入更多的时间和资源，使用这个神奇的工具开发Windows应用程序。</p><p id="42d8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">多亏了几个热心人的工作，<a class="ae ky" href="https://pub.dev/" rel="noopener ugc nofollow" target="_blank"> pub.dev </a>上的很多包都支持Windows开发，而且这个列表还在增长。然而，正如在之前告诉<a class="ae ky" rel="noopener ugc nofollow" target="_blank" href="/flutter-platform-plugin-windows-1-8b7c0a96fac4">的那样，在Flutter中设计我们闪亮的新Windows应用程序有时可能会有我们遗漏的东西。</a></p><p id="a727" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">例如，我们可能需要我们的应用程序对Windows系统范围的事件做出反应，并相应地改变它的行为。Flutter没有现成的接口来做这件事。为了了解如何实现这一点，我们将实现一个<em class="lv">事件通道</em>，它可以在我们的Dart代码中提供这些事件。</p><blockquote class="mx my mz"><p id="2170" class="kz la lv lb b lc ld ju le lf lg jx lh na lj lk ll nb ln lo lp nc lr ls lt lu im bi translated">如果你已经有利用平台渠道编写插件的经验，跳到下一段，如果没有，可以看前面的故事:</p></blockquote><div class="nd ne gp gr nf ng"><a rel="noopener  ugc nofollow" target="_blank" href="/flutter-platform-plugin-windows-1-8b7c0a96fac4"><div class="nh ab fo"><div class="ni ab nj cl cj nk"><h2 class="bd iu gy z fp nl fr fs nm fu fw is bi translated">创建一个Flutter插件，为Windows编写特定于平台的代码</h2><div class="nn l"><h3 class="bd b gy z fp nl fr fs nm fu fw dk translated">通过编写您的Flutter桌面应用程序来利用Windows特有的功能</h3></div><div class="no l"><p class="bd b dl z fp nl fr fs nm fu fw dk translated">better编程. pub</p></div></div><div class="np l"><div class="nq l nr ns nt np nu ks ng"/></div></div></a></div><h1 id="f0f9" class="ma mb it bd mc md me mf mg mh mi mj mk jz ml ka mm kc mn kd mo kf mp kg mq mr bi translated">例子:我们想要什么</h1><p id="8fcc" class="pw-post-body-paragraph kz la it lb b lc ms ju le lf mt jx lh li mu lk ll lm mv lo lp lq mw ls lt lu im bi translated">假设我们希望每次用户在Windows中打开或关闭黑暗模式时，我们的应用程序都接收一个事件。</p><p id="8179" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">使用C++或其他“本地”语言在Win32应用程序中实现这一点似乎很简单:我们必须注册一个处理程序来监听我们的应用程序接收到的Windows <code class="fe lw lx ly lz b">WM_</code>事件:</p><pre class="kj kk kl km gt nv lz nw nx aw ny bi"><span id="9dc4" class="nz mb it lz b gy oa ob l oc od">HWND handle = GetActiveWindow()<strong class="lz iu">;<br/></strong>oldProc = reinterpret_cast&lt;WNDPROC&gt;(GetWindowLongPtr(handle<strong class="lz iu">, </strong>GWLP_WNDPROC))<strong class="lz iu">;<br/></strong>SetWindowLongPtr(handle<strong class="lz iu">, </strong>GWLP_WNDPROC<strong class="lz iu">, </strong>(LONG_PTR)MyWndProc)<strong class="lz iu">;</strong></span></pre><p id="0d12" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这是我们的新处理程序，每次Windows WM_ message“到达”时都会调用它:</p><pre class="kj kk kl km gt nv lz nw nx aw ny bi"><span id="ddae" class="nz mb it lz b gy oa ob l oc od">LRESULT CALLBACK MyWndProc(HWND hWnd<strong class="lz iu">, </strong>UINT iMessage<strong class="lz iu">, </strong>WPARAM wParam<strong class="lz iu">, </strong>LPARAM lParam)<br/>      {<br/>        if (iMessage == WM_SETTINGCHANGE)<br/>        {<br/>       <strong class="lz iu">   </strong>if (!lstrcmp(LPCTSTR(lParam)<strong class="lz iu">, </strong>L"ImmersiveColorSet"))<br/>                 {<br/>                   ChangeOurAppTheme();<br/>                 }<br/>        }<br/>        return oldProc(hWnd<strong class="lz iu">, </strong>iMessage<strong class="lz iu">, </strong>wParam<strong class="lz iu">, </strong>lParam)<strong class="lz iu">;<br/>      </strong>}</span></pre><p id="ae27" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">当一个<code class="fe lw lx ly lz b">WM_SETTINGCHANGE</code>消息被拦截时，如果<code class="fe lw lx ly lz b"><em class="lv">lParam</em></code>指向“ImmersiveColorSet”` Unicode字符串，操作系统就发出信号，表明当前UI主题发生了变化。</p><h1 id="99a3" class="ma mb it bd mc md me mf mg mh mi mj mk jz ml ka mm kc mn kd mo kf mp kg mq mr bi translated">颤振侧实施</h1><p id="e6d5" class="pw-post-body-paragraph kz la it lb b lc ms ju le lf mt jx lh li mu lk ll lm mv lo lp lq mw ls lt lu im bi translated">在Flutter应用程序中，情况有点不同。让我们从克隆这个<a class="ae ky" href="https://github.com/pgiacomo69/windows_dark_mode" rel="noopener ugc nofollow" target="_blank">库</a>开始，并在我们的IDE中打开项目。</p><p id="4f17" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们知道，在Flutter中使用方法通道就像调用远程API一样，但是现在我们需要订阅一个流。为此，我们将使用<em class="lv">事件通道</em>，让我们在首选IDE中打开<code class="fe lw lx ly lz b">lib/windows_dark_mode.dart</code>:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi oe"><img src="../Images/76efe9067d823f1dfbb78f6e7f0cffb5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*DsOJzcxD2j5APCQP_5D7WA.png"/></div></div></figure><p id="9dd5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在，我们将在WindowsDarkMode类中添加以下代码:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="of og l"/></div></figure><p id="8d39" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">为此，我们:</p><ol class=""><li id="d0d8" class="oh oi it lb b lc ld lf lg li oj lm ok lq ol lu om on oo op bi translated">将<code class="fe lw lx ly lz b">_eventChannel</code>声明为一个<code class="fe lw lx ly lz b">EventChannel</code>实例。这将是我们从Dart到平台代码的“传输连接”。在构造函数中，我们传递通道名。事实上，我们已经将这个名称构造为一个“路径”,对应于我们的插件名称和一个专有名称，它标识了正确的流。我使用这个约定来更好地识别通道并避免与其他包冲突的风险，事实上你可以随意命名通道。</li><li id="4808" class="oh oi it lb b lc oq lf or li os lm ot lq ou lu om on oo op bi translated">实现了从平台“翻译”事件的静态方法<code class="fe lw lx ly lz b">DarkModeStream()</code>。在内部，我们调用提供<code class="fe lw lx ly lz b">Stream&lt;dynamic&gt;</code>的方法<code class="fe lw lx ly lz b">receiveBroadcastStream()</code>，将动态值映射到<code class="fe lw lx ly lz b">ThemeMode</code>的级联方法<code class="fe lw lx ly lz b">map()</code>，以及在两个或更多连续相同值到达时去抖事件的<code class="fe lw lx ly lz b">distinct(),</code>。</li></ol><h1 id="3a88" class="ma mb it bd mc md me mf mg mh mi mj mk jz ml ka mm kc mn kd mo kf mp kg mq mr bi translated">实现，平台端</h1><p id="0d7c" class="pw-post-body-paragraph kz la it lb b lc ms ju le lf mt jx lh li mu lk ll lm mv lo lp lq mw ls lt lu im bi translated">让我们看看“后端”，打开<code class="fe lw lx ly lz b">/windows/windows_dark_mode_plugin.cpp </code>:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ov"><img src="../Images/052f7bbd420140192b5f34aac285e805.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*nP4HpB_CmZSywqSWH97BxA.png"/></div></div></figure><p id="83f3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe lw lx ly lz b">WindowsDarkModePlugin</code>已经包含了我之前教程中实现的代码。当被询问时，它提供黑暗模式的当前状态。</p><p id="e2d9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在<code class="fe lw lx ly lz b">RegisterWithRegistrar</code>当前我们只有<em class="lv">方法通道</em>声明，以接收来自Dart的查询:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ow"><img src="../Images/cbc261ead5d2b4fe71c10c831e4b103e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1214/format:webp/1*ragDxHaK0TFBrriWm1I-iw.png"/></div></div></figure><p id="6238" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">用同样的方法，我们必须实现平台<em class="lv">事件通道</em>:</p><pre class="kj kk kl km gt nv lz nw nx aw ny bi"><span id="5bc1" class="nz mb it lz b gy oa ob l oc od">plugin-&gt;m_event_channel = std::make_unique&lt;flutter::EventChannel&lt;flutter::EncodableValue&gt;&gt; (<br/>          registrar-&gt;messenger ()<strong class="lz iu">, </strong>"windows_dark_mode/dark_mode_callback"<strong class="lz iu">,<br/>          </strong>&amp;flutter::StandardMethodCodec::GetInstance ()<br/>       )<strong class="lz iu">;</strong></span></pre><p id="df89" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe lw lx ly lz b">m_event_channel</code>需要在类接口中声明，私有:</p><pre class="kj kk kl km gt nv lz nw nx aw ny bi"><span id="826f" class="nz mb it lz b gy oa ob l oc od">std::unique_ptr&lt;flutter::EventChannel&lt;flutter::EncodableValue&gt;&gt; m_event_channel<strong class="lz iu">;</strong></span></pre><p id="bc12" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这些包括需要补充的:</p><pre class="kj kk kl km gt nv lz nw nx aw ny bi"><span id="ef40" class="nz mb it lz b gy oa ob l oc od">#include &lt;flutter/event_channel.h&gt;<br/>#include &lt;mutex&gt;</span></pre><p id="c9ec" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><em class="lv">事件通道</em>已经准备好了，但是要发送事件，它需要一个<em class="lv"> StreamHandler </em>将事件从平台排队到引擎，所以我们在同一个名称空间中包含了我们的新类:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="of og l"/></div></figure><p id="3dbc" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在WindowsDarkModePlugin接口中声明一个变量:</p><pre class="kj kk kl km gt nv lz nw nx aw ny bi"><span id="1a99" class="nz mb it lz b gy oa ob l oc od">MyStreamHandler&lt;&gt; *m_handler<strong class="lz iu">;</strong></span></pre><p id="4f88" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">将其实例化，并分配给<code class="fe lw lx ly lz b">RegisterWithRegistrar</code>中的事件通道，</p><pre class="kj kk kl km gt nv lz nw nx aw ny bi"><span id="dac0" class="nz mb it lz b gy oa ob l oc od">MyStreamHandler&lt;&gt; *_handler=new MyStreamHandler&lt;&gt; ()<strong class="lz iu">;<br/>     </strong>plugin-&gt;m_handler = _handler<strong class="lz iu">;<br/>     </strong>auto _obj_stm_handle = static_cast&lt;flutter::StreamHandler&lt;flutter::EncodableValue&gt;*&gt; (plugin-&gt;m_handler)<strong class="lz iu">;<br/>     </strong>std::unique_ptr&lt;flutter::StreamHandler&lt;flutter::EncodableValue&gt;&gt; _ptr {_obj_stm_handle}<strong class="lz iu">;<br/>     </strong>plugin-&gt;m_event_channel-&gt;SetStreamHandler (std::move (_ptr))<strong class="lz iu">;</strong></span></pre><p id="a6de" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在我们必须拦截WM_ messages。我们可以调用SetWindowLongPtr来设置我们的WNDPROC处理程序，对吗？</p><p id="a7e0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">但是我们不会，因为Flutter Engine也注册了他的handler，它可以给我们机会来接入消息流，所以我们将使用<code class="fe lw lx ly lz b"><a class="ae ky" href="https://engine.chinmaygarde.com/classflutter_1_1_window_proc_delegate_manager_win32.html" rel="noopener ugc nofollow" target="_blank">RegisterTopLevelWindowProcDelegate</a></code>，一个由Flutter Engine提供的平台端的方法。所以我们将替换<code class="fe lw lx ly lz b">WindowsDarkModePlugin</code>构造函数和析构函数:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="of og l"/></div></figure><p id="4a50" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在，我们已经设置了一个回调来挂钩WM_ messages，并在WindowsDarkMode的实例被释放时取消设置。</p><p id="3b48" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">然后我们必须修改<code class="fe lw lx ly lz b">WindowsDarkModePlugin</code>类的接口:</p><ul class=""><li id="3f51" class="oh oi it lb b lc ld lf lg li oj lm ok lq ol lu ox on oo op bi translated">更改构造函数签名以接受<code class="fe lw lx ly lz b">registrar</code>参数；</li><li id="880d" class="oh oi it lb b lc oq lf or li os lm ot lq ou lu ox on oo op bi translated">在私有部分声明<code class="fe lw lx ly lz b">int window_proc_id = -1;</code>,这标识了我们正在注册的处理程序，这对于撤销注册很有用；</li><li id="a531" class="oh oi it lb b lc oq lf or li os lm ot lq ou lu ox on oo op bi translated">在私有部分声明<code class="fe lw lx ly lz b">flutter::PluginRegistrarWindows* registrar;</code>，我们需要<code class="fe lw lx ly lz b">registrar</code>在处理时注销我们的钩子；</li><li id="0da6" class="oh oi it lb b lc oq lf or li os lm ot lq ou lu ox on oo op bi translated">在私有部分声明<code class="fe lw lx ly lz b">std::optional&lt;LRESULT&gt; HandleWindowProc(HWND hWnd,UINT message,WPARAM wParam,LPARAM lParam);</code>头；</li></ul><p id="c83a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">然后我们将替换<code class="fe lw lx ly lz b">RegisterWithRegistrar</code>静态方法中的插件实例化，简单地添加<code class="fe lw lx ly lz b">registrar</code>参数:<br/> <code class="fe lw lx ly lz b">auto plugin = std::make_unique&lt;WindowsDarkModePlugin&gt;(registrar)<strong class="lb iu">;</strong></code></p><p id="65ce" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们将在类体中实现<code class="fe lw lx ly lz b">HandleWindowProc</code>:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="of og l"/></div></figure><blockquote class="mx my mz"><p id="8954" class="kz la lv lb b lc ld ju le lf lg jx lh na lj lk ll nb ln lo lp nc lr ls lt lu im bi translated">我们在我们的流处理器上调用<code class="fe lw lx ly lz b">on_callback</code>方法，发送<code class="fe lw lx ly lz b">isDarkModeAppEnabled()</code>的结果，后一个方法给我们一个布尔值，但我们使用<code class="fe lw lx ly lz b"><a class="ae ky" href="https://engine.chinmaygarde.com/encodable__value_8h_source.html" rel="noopener ugc nofollow" target="_blank">flutter::EncodableValue()</a></code>对它进行装箱，这是我们用来从平台向我们的应用程序的Dart端发送数据的方法，<a class="ae ky" href="https://docs.flutter.dev/development/platform-integration/platform-channels" rel="noopener ugc nofollow" target="_blank">在这里我们的布尔值将被取消装箱</a>。</p></blockquote><p id="9fd7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在我们将尝试编译这个项目，只是为了检查语法到目前为止是否良好，如果是的话…</p><h1 id="bba3" class="ma mb it bd mc md me mf mg mh mi mj mk jz ml ka mm kc mn kd mo kf mp kg mq mr bi translated">让我们试试</h1><p id="5d35" class="pw-post-body-paragraph kz la it lb b lc ms ju le lf mt jx lh li mu lk ll lm mv lo lp lq mw ls lt lu im bi translated">现在，我们将修改“example/lib/main.dart”中的主体，将我们的<code class="fe lw lx ly lz b">MaterialApp</code>包装在StreamBuilder中，因此当我们在Windows中切换主题时，我们的应用程序主题将会改变:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="of og l"/></div></figure><p id="45d0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们点击运行:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oy og l"/></div></figure><p id="8b20" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">希望这篇教程对你有用。很快我将继续这个话题，用其他教程展示如何在Windows中调试插件的c++代码，以及如何获得Windows主题颜色。</p></div><div class="ab cl oz pa hx pb" role="separator"><span class="pc bw bk pd pe pf"/><span class="pc bw bk pd pe pf"/><span class="pc bw bk pd pe"/></div><div class="im in io ip iq"><p id="4f56" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">上述教程的完整代码可以在这个GitHub <a class="ae ky" href="https://github.com/pgiacomo69/windows_dark_mode/tree/events" rel="noopener ugc nofollow" target="_blank">库</a>的“events”分支中找到。感谢阅读。</p><p id="04c0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">相关文章:</p><div class="nd ne gp gr nf ng"><a rel="noopener  ugc nofollow" target="_blank" href="/flutter-platform-plugin-windows-1-8b7c0a96fac4"><div class="nh ab fo"><div class="ni ab nj cl cj nk"><h2 class="bd iu gy z fp nl fr fs nm fu fw is bi translated">创建一个Flutter插件，为Windows编写特定于平台的代码</h2><div class="nn l"><h3 class="bd b gy z fp nl fr fs nm fu fw dk translated">通过编写您的Flutter桌面应用程序来利用Windows特有的功能</h3></div><div class="no l"><p class="bd b dl z fp nl fr fs nm fu fw dk translated">better编程. pub</p></div></div><div class="np l"><div class="nq l nr ns nt np nu ks ng"/></div></div></a></div></div></div>    
</body>
</html>