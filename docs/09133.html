<html>
<head>
<title>How To Use Yield in Python To Make Your Functions More Efficient</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何在Python中使用Yield让你的函数更高效</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/yield-in-python-76413d5e2a27?source=collection_archive---------4-----------------------#2021-07-19">https://betterprogramming.pub/yield-in-python-76413d5e2a27?source=collection_archive---------4-----------------------#2021-07-19</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="5dfe" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">使用yield将您的函数转换成内存高效的生成器</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/e69317a0bbee9d2a5d83631c57353853.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*qZWe6CH-0y2x6zcI"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">Chris Ried 在<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片。</p></figure><p id="c458" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在Python中，<code class="fe lv lw lx ly b">yield</code>用于从函数<em class="lz">返回，而</em>不会破坏其变量。从某种意义上说，<code class="fe lv lw lx ly b">yield</code>暂停了函数的执行。当再次调用该函数时，从最后一条<code class="fe lv lw lx ly b">yield</code>语句继续执行。</p><p id="e487" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">使用<code class="fe lv lw lx ly b">yield</code>将函数转换为<em class="lz">生成器</em>。下面是函数与生成器的对比图:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ma"><img src="../Images/40d883836d2a40f4b6698be0451ecd2a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*iBgdO1ukASeyaLtSv3Jpnw.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">图片由作者提供。</p></figure><p id="6d2f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">生成器返回一个生成器对象，也称为<a class="ae ky" rel="noopener ugc nofollow" target="_blank" href="/what-are-python-iterators-and-iterables-c1dd67559d2f"> <em class="lz">迭代器</em> </a>，一次生成一个值。它不存储任何值。这使得生成器的内存效率更高。</p><p id="fab1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">例如，您可以使用生成器循环遍历一组数字，而无需将它们存储在内存中。</p></div><div class="ab cl mb mc hx md" role="separator"><span class="me bw bk mf mg mh"/><span class="me bw bk mf mg mh"/><span class="me bw bk mf mg"/></div><div class="im in io ip iq"><h1 id="c2d5" class="mi mj it bd mk ml mm mn mo mp mq mr ms jz mt ka mu kc mv kd mw kf mx kg my mz bi translated">如何将一个函数变成一个生成器</h1><p id="fdc2" class="pw-post-body-paragraph kz la it lb b lc na ju le lf nb jx lh li nc lk ll lm nd lo lp lq ne ls lt lu im bi translated"><code class="fe lv lw lx ly b">yield</code>把一个函数变成一个生成器，产生一个值而不是返回它。这使得函数返回一个生成器对象。这是一个迭代器，你可以像遍历列表一样遍历它。</p><h2 id="80d9" class="nf mj it bd mk ng nh dn mo ni nj dp ms li nk nl mu lm nm nn mw lq no np my nq bi translated">例子</h2><p id="92c0" class="pw-post-body-paragraph kz la it lb b lc na ju le lf nb jx lh li nc lk ll lm nd lo lp lq ne ls lt lu im bi translated">让我们创建一个<code class="fe lv lw lx ly b">square()</code>函数，它对输入的数字列表求平方:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nr ns l"/></div></figure><p id="a279" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">输出:</p><pre class="kj kk kl km gt nt ly nu nv aw nw bi"><span id="d9be" class="nf mj it ly b gy nx ny l nz oa">[1, 4, 9, 16, 25]</span></pre><p id="a56d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们把这个函数变成一个生成器。您可以一次存储一个值而不存储它们，而不是将平方数存储到一个列表中:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nr ns l"/></div></figure><p id="8900" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">输出:</p><pre class="kj kk kl km gt nt ly nu nv aw nw bi"><span id="e891" class="nf mj it ly b gy nx ny l nz oa"><strong class="ly iu">&lt;generator object square at 0x7f685175b510&gt;</strong></span></pre><p id="c2e8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在你不再得到平方数的列表。这是因为结果<code class="fe lv lw lx ly b">squared_numbers</code>是一个<em class="lz">生成器对象</em>。</p><h2 id="179b" class="nf mj it bd mk ng nh dn mo ni nj dp ms li nk nl mu lm nm nn mw lq no np my nq bi translated">使用next()函数获取值</h2><p id="5663" class="pw-post-body-paragraph kz la it lb b lc na ju le lf nb jx lh li nc lk ll lm nd lo lp lq ne ls lt lu im bi translated">生成器对象不在内存中保存数字。相反，它一次计算一个结果。只有当您使用<code class="fe lv lw lx ly b">next()</code>函数请求下一个值时，它才会这样做。</p><p id="c5ef" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让生成器计算第一个平方数:</p><pre class="kj kk kl km gt nt ly nu nv aw nw bi"><span id="4f6e" class="nf mj it ly b gy nx ny l nz oa">print(next(squared_numbers))</span></pre><p id="aa6b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">输出:</p><pre class="kj kk kl km gt nt ly nu nv aw nw bi"><span id="373a" class="nf mj it ly b gy nx ny l nz oa">1</span></pre><p id="cabe" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们再调用<code class="fe lv lw lx ly b">next()</code>四次，让它计算其余的数字:</p><pre class="kj kk kl km gt nt ly nu nv aw nw bi"><span id="a868" class="nf mj it ly b gy nx ny l nz oa">print(next(squared_numbers))<br/>print(next(squared_numbers))<br/>print(next(squared_numbers))<br/>print(next(squared_numbers))</span></pre><p id="ea2f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">输出:</p><pre class="kj kk kl km gt nt ly nu nv aw nw bi"><span id="5f68" class="nf mj it ly b gy nx ny l nz oa">4<br/>9<br/>16<br/>25</span></pre><p id="3070" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在生成器已经将所有的数字平方。如果你再叫一次<code class="fe lv lw lx ly b">next()</code>:</p><pre class="kj kk kl km gt nt ly nu nv aw nw bi"><span id="4182" class="nf mj it ly b gy nx ny l nz oa">print(next(squared_numbers))</span></pre><p id="ce73" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">出现错误:</p><pre class="kj kk kl km gt nt ly nu nv aw nw bi"><span id="36d0" class="nf mj it ly b gy nx ny l nz oa"><strong class="ly iu">Traceback (most recent call last):<br/>  File "&lt;string&gt;", line 13, in &lt;module&gt;<br/>StopIteration</strong></span></pre><p id="1b20" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这个错误让你知道没有更多的数字要平方。换句话说，发电机是<em class="lz">耗尽了</em>。</p><p id="1d5d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在您了解了生成器是如何工作的，以及如何让它计算值。</p><h2 id="f04a" class="nf mj it bd mk ng nh dn mo ni nj dp ms li nk nl mu lm nm nn mw lq no np my nq bi translated">不要使用next()函数</h2><p id="daf8" class="pw-post-body-paragraph kz la it lb b lc na ju le lf nb jx lh li nc lk ll lm nd lo lp lq ne ls lt lu im bi translated">使用<code class="fe lv lw lx ly b">next()</code>函数很好地演示了发电机是如何工作的。</p><p id="bc37" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在现实中，你不需要调用<code class="fe lv lw lx ly b">next()</code>函数。相反，您可以使用一个<code class="fe lv lw lx ly b">for</code>循环，其语法与您遍历列表时使用的语法相同(<code class="fe lv lw lx ly b">for</code>循环为您调用了底层的<code class="fe lv lw lx ly b">next()</code>函数)。</p><p id="df3d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">例如，让我们使用一个<code class="fe lv lw lx ly b">for</code>循环来重复生成器的例子:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nr ns l"/></div></figure><p id="42aa" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">输出:</p><pre class="kj kk kl km gt nt ly nu nv aw nw bi"><span id="e557" class="nf mj it ly b gy nx ny l nz oa">1<br/>4<br/>9<br/>16<br/>25</span></pre></div><div class="ab cl mb mc hx md" role="separator"><span class="me bw bk mf mg mh"/><span class="me bw bk mf mg mh"/><span class="me bw bk mf mg"/></div><div class="im in io ip iq"><h1 id="1b3a" class="mi mj it bd mk ml mm mn mo mp mq mr ms jz mt ka mu kc mv kd mw kf mx kg my mz bi translated">带生成器的无限数字流</h1><p id="de73" class="pw-post-body-paragraph kz la it lb b lc na ju le lf nb jx lh li nc lk ll lm nd lo lp lq ne ls lt lu im bi translated">生成器对象(迭代器)只关心当前值，不存储任何值。因此，创造无限的价值流是可能的。</p><h2 id="2fdc" class="nf mj it bd mk ng nh dn mo ni nj dp ms li nk nl mu lm nm nn mw lq no np my nq bi translated">例子</h2><p id="8378" class="pw-post-body-paragraph kz la it lb b lc na ju le lf nb jx lh li nc lk ll lm nd lo lp lq ne ls lt lu im bi translated">让我们创建一个无限生成器，它产生一个起点之后的所有数字:</p><pre class="kj kk kl km gt nt ly nu nv aw nw bi"><span id="b161" class="nf mj it ly b gy nx ny l nz oa"><strong class="ly iu">def</strong> infinite_values(start):<br/>    current = start<br/>    <strong class="ly iu">while</strong> True:<br/>        <strong class="ly iu">yield</strong> current<br/>        current += 1</span></pre><p id="ed53" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">该发生器产生从<code class="fe lv lw lx ly b">start</code>到无穷大的值。让我们运行它:</p><pre class="kj kk kl km gt nt ly nu nv aw nw bi"><span id="5261" class="nf mj it ly b gy nx ny l nz oa">infinite_nums = infinite_values(0)</span><span id="fe9a" class="nf mj it ly b gy ob ny l nz oa"><strong class="ly iu">for</strong> num <strong class="ly iu">in</strong> infinite_nums:<br/>    print(num)</span></pre><p id="7b0a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">输出:</p><pre class="kj kk kl km gt nt ly nu nv aw nw bi"><span id="afc8" class="nf mj it ly b gy nx ny l nz oa">0<br/>1<br/>2<br/>3<br/>4<br/>5<br/>.<br/>.<br/>.</span></pre><p id="42b7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">从语法上看，<code class="fe lv lw lx ly b">infinite_nums</code>似乎是一个我们正在循环的无限数字列表。实际上，它是一个逐个计算值的生成器。</p></div><div class="ab cl mb mc hx md" role="separator"><span class="me bw bk mf mg mh"/><span class="me bw bk mf mg mh"/><span class="me bw bk mf mg"/></div><div class="im in io ip iq"><h1 id="2a7d" class="mi mj it bd mk ml mm mn mo mp mq mr ms jz mt ka mu kc mv kd mw kf mx kg my mz bi translated">生成器与列表—运行时比较</h1><p id="e64f" class="pw-post-body-paragraph kz la it lb b lc na ju le lf nb jx lh li nc lk ll lm nd lo lp lq ne ls lt lu im bi translated">让我们对生成器和函数进行运行时比较。</p><p id="be3e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在这个例子中，有一个十个数字和两个函数的列表:</p><ul class=""><li id="01b7" class="oc od it lb b lc ld lf lg li oe lm of lq og lu oh oi oj ok bi translated">一个<code class="fe lv lw lx ly b">data_list()</code>函数从列表中随机选择一个数字<code class="fe lv lw lx ly b">n</code>次。</li><li id="3254" class="oc od it lb b lc ol lf om li on lm oo lq op lu oh oi oj ok bi translated">一个<code class="fe lv lw lx ly b">data_generator()</code>发生器函数也从列表中随机选择一个数字<code class="fe lv lw lx ly b">n</code>次。</li></ul><p id="1efe" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这段代码比较了使用这些函数构建一百万个随机选择数字的列表的运行时间:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nr ns l"/></div></figure><p id="cf7e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">结果:</p><pre class="kj kk kl km gt nt ly nu nv aw nw bi"><span id="b583" class="nf mj it ly b gy nx ny l nz oa">List creation took 0.6045370370011369 Seconds<br/>Generator creation took  3.48799949279055e-06 Seconds<br/>The generator is <strong class="ly iu">173319</strong> times faster</span></pre><p id="ea80" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这显示了如何更快地创建生成器。这是因为当你创建一个列表时，所有的数字都必须存储在内存中。但是当你使用发电机时，这些数字不会存储在任何地方，所以速度非常快。</p></div><div class="ab cl mb mc hx md" role="separator"><span class="me bw bk mf mg mh"/><span class="me bw bk mf mg mh"/><span class="me bw bk mf mg"/></div><div class="im in io ip iq"><h1 id="8be1" class="mi mj it bd mk ml mm mn mo mp mq mr ms jz mt ka mu kc mv kd mw kf mx kg my mz bi translated">在Python中使用生成器时</h1><p id="d835" class="pw-post-body-paragraph kz la it lb b lc na ju le lf nb jx lh li nc lk ll lm nd lo lp lq ne ls lt lu im bi translated">要知道什么时候你可以使用发电机，问问你自己，“我需要同时有多个项目吗？”如果答案是否定的，你可以使用发电机。</p><p id="5a62" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们回到平方数字的例子。如果你想打印平方数，你可以使用生成器。这是因为平方数并不相互依赖。因此，你可以一个一个地计算它们。</p><p id="5974" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果列表很小，那么你用不用发电机都没什么区别。但是随着列表变得越来越大，生成器的功能开始发挥作用。</p><p id="61b6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">想象一下遍历一个包含十亿个字符串(比如密码)的文件。你不可能在一个列表中存储那么多的字符串。在这种情况下，您可以使用一个生成器来逐个遍历它们，而不是一次性存储它们。</p></div><div class="ab cl mb mc hx md" role="separator"><span class="me bw bk mf mg mh"/><span class="me bw bk mf mg mh"/><span class="me bw bk mf mg"/></div><div class="im in io ip iq"><h1 id="9d69" class="mi mj it bd mk ml mm mn mo mp mq mr ms jz mt ka mu kc mv kd mw kf mx kg my mz bi translated">创建生成器的简写</h1><p id="1b8d" class="pw-post-body-paragraph kz la it lb b lc na ju le lf nb jx lh li nc lk ll lm nd lo lp lq ne ls lt lu im bi translated">最后，让我们来看看在处理生成器时如何缩短代码。</p><p id="6e8e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">您之前看到的<code class="fe lv lw lx ly b">square()</code>函数引入了多余的代码行。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nr ns l"/></div></figure><p id="a4fb" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">你可以使用list <a class="ae ky" href="https://medium.com/codex/python-make-your-code-fly-with-comprehensions-147873eea0ef#:~:text=for%20instance%2C%20you%20can%20use%20a%20comprehension%20to%20replace%20this%3A" rel="noopener"> comprehension </a>来保存6行代码，而不是创建一个函数:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nr ns l"/></div></figure><p id="be00" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">输出:</p><pre class="kj kk kl km gt nt ly nu nv aw nw bi"><span id="b924" class="nf mj it ly b gy nx ny l nz oa">[1, 4, 9, 16, 25]</span></pre><p id="cb0b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">类似的简写也可以用于发电机。</p><p id="3ae4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">生成器理解，更好地称为<em class="lz">生成器表达式</em>，是创建生成器的简写。语法类似于列表理解。</p><p id="30f6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">以前，您是这样定义<code class="fe lv lw lx ly b">square()</code>生成器的:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nr ns l"/></div></figure><p id="8a78" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">但是您可以使用生成器表达式来做完全相同的事情:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nr ns l"/></div></figure><p id="be6b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">结果:</p><pre class="kj kk kl km gt nt ly nu nv aw nw bi"><span id="5c34" class="nf mj it ly b gy nx ny l nz oa"><strong class="ly iu">&lt;generator object &lt;genexpr&gt; at 0x7f37a094a580&gt;</strong></span></pre><p id="bace" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">要打印<code class="fe lv lw lx ly b">squared_numbers</code>，你可以通过生成器循环:</p><pre class="kj kk kl km gt nt ly nu nv aw nw bi"><span id="0c0e" class="nf mj it ly b gy nx ny l nz oa"><strong class="ly iu">for</strong> n <strong class="ly iu">in</strong> squared_numbers:<br/>    print(n)</span></pre><p id="b332" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">输出:</p><pre class="kj kk kl km gt nt ly nu nv aw nw bi"><span id="4417" class="nf mj it ly b gy nx ny l nz oa">1<br/>4<br/>9<br/>16<br/>25</span></pre></div><div class="ab cl mb mc hx md" role="separator"><span class="me bw bk mf mg mh"/><span class="me bw bk mf mg mh"/><span class="me bw bk mf mg"/></div><div class="im in io ip iq"><h1 id="ebf0" class="mi mj it bd mk ml mm mn mo mp mq mr ms jz mt ka mu kc mv kd mw kf mx kg my mz bi translated">结论</h1><p id="98b4" class="pw-post-body-paragraph kz la it lb b lc na ju le lf nb jx lh li nc lk ll lm nd lo lp lq ne ls lt lu im bi translated">在Python中，<code class="fe lv lw lx ly b">yield</code>是一个把函数变成生成器的关键字。</p><p id="3d05" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">与列表不同，生成器不存储值。相反，它知道当前值以及如何获得下一个值。这使得生成器的内存效率更高。</p><p id="9bfc" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">遍历生成器的语法与遍历列表的语法相同。</p><p id="ff54" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">每当您循环访问一大组项目，并且不需要一次存储所有项目时，使用生成器非常有用。</p><p id="63cc" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">感谢阅读。编码快乐！</p></div><div class="ab cl mb mc hx md" role="separator"><span class="me bw bk mf mg mh"/><span class="me bw bk mf mg mh"/><span class="me bw bk mf mg"/></div><div class="im in io ip iq"><h1 id="9697" class="mi mj it bd mk ml mm mn mo mp mq mr ms jz mt ka mu kc mv kd mw kf mx kg my mz bi translated">你可能会发现这些文章很有见地</h1><div class="oq or gp gr os ot"><a rel="noopener  ugc nofollow" target="_blank" href="/50-python-interview-questions-and-answers-5230fe2a0db6"><div class="ou ab fo"><div class="ov ab ow cl cj ox"><h2 class="bd iu gy z fp oy fr fs oz fu fw is bi translated">50 Python面试问答</h2><div class="pa l"><h3 class="bd b gy z fp oy fr fs oz fu fw dk translated">Ace您的下一次编码面试</h3></div><div class="pb l"><p class="bd b dl z fp oy fr fs oz fu fw dk translated">better编程. pub</p></div></div><div class="pc l"><div class="pd l pe pf pg pc ph ks ot"/></div></div></a></div><div class="oq or gp gr os ot"><a rel="noopener  ugc nofollow" target="_blank" href="/10-useful-python-snippets-to-code-like-a-pro-e3d9a34e6145"><div class="ou ab fo"><div class="ov ab ow cl cj ox"><h2 class="bd iu gy z fp oy fr fs oz fu fw is bi translated">10个有用的Python片段，让你像专业人士一样编写代码</h2><div class="pa l"><h3 class="bd b gy z fp oy fr fs oz fu fw dk translated">我每天使用的有用的提示和技巧</h3></div><div class="pb l"><p class="bd b dl z fp oy fr fs oz fu fw dk translated">better编程. pub</p></div></div><div class="pc l"><div class="pi l pe pf pg pc ph ks ot"/></div></div></a></div></div><div class="ab cl mb mc hx md" role="separator"><span class="me bw bk mf mg mh"/><span class="me bw bk mf mg mh"/><span class="me bw bk mf mg"/></div><div class="im in io ip iq"><h1 id="c5b1" class="mi mj it bd mk ml mm mn mo mp mq mr ms jz mt ka mu kc mv kd mw kf mx kg my mz bi translated">参考</h1><div class="oq or gp gr os ot"><a href="https://docs.python.org/3/" rel="noopener  ugc nofollow" target="_blank"><div class="ou ab fo"><div class="ov ab ow cl cj ox"><h2 class="bd iu gy z fp oy fr fs oz fu fw is bi translated">文件</h2><div class="pa l"><h3 class="bd b gy z fp oy fr fs oz fu fw dk translated">欢迎光临！这是Python 3.9.6的文档。</h3></div><div class="pb l"><p class="bd b dl z fp oy fr fs oz fu fw dk translated">docs.python.org</p></div></div></div></a></div></div></div>    
</body>
</html>