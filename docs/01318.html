<html>
<head>
<title>Creating multi-container Docker Applications using Docker Compose</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用Docker编写创建多容器Docker应用程序</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/dockerizing-multiple-services-inside-a-single-container-96cdff286cef?source=collection_archive---------1-----------------------#2019-09-01">https://betterprogramming.pub/dockerizing-multiple-services-inside-a-single-container-96cdff286cef?source=collection_archive---------1-----------------------#2019-09-01</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="10ee" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">关于定义和创建多个Docker容器的教程，包括数据库设置</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/00bdea9eb9e73ecaf808fcaf0a106078.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*WJXpV75HFx6og-U8NBR7lw.png"/></div></div></figure><p id="48ef" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">最近，我有机会为一个项目做码头集装箱。这是一次很好的学习经历，因为我之前对Docker的用法一无所知。</p><p id="161b" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">这个博客的目标是使用Docker Compose创建多容器Docker应用程序(应用服务器、客户机-服务器和PostgreSQL数据库)。</p></div><div class="ab cl ln lo hu lp" role="separator"><span class="lq bw bk lr ls lt"/><span class="lq bw bk lr ls lt"/><span class="lq bw bk lr ls"/></div><div class="ij ik il im in"><h1 id="060c" class="lu lv iq bd lw lx ly lz ma mb mc md me jw mf jx mg jz mh ka mi kc mj kd mk ml bi translated"><strong class="ak">什么是Docker？</strong>(基本定义)</h1><blockquote class="mm mn mo"><p id="a967" class="kr ks mp kt b ku kv jr kw kx ky ju kz mq lb lc ld mr lf lg lh ms lj lk ll lm ij bi translated">Docker 是一个工具，旨在通过使用容器来简化应用程序的创建、部署和运行。容器允许开发人员将应用程序与它需要的所有部分打包在一起，比如库和其他依赖项，然后作为一个包发送出去。</p><p id="da97" class="kr ks mp kt b ku kv jr kw kx ky ju kz mq lb lc ld mr lf lg lh ms lj lk ll lm ij bi translated">通过这样做，由于有了容器，开发人员可以放心，应用程序将在任何其他Linux机器上运行，而不管该机器的任何定制设置可能与用于编写和测试代码的机器不同。”—来源<a class="ae mt" href="https://opensource.com/resources/what-docker" rel="noopener ugc nofollow" target="_blank">https://opensource.com/resources/what-docker</a></p></blockquote><p id="c394" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">我喜欢把Docker看作是开发工具的乐高积木，它们可以组合在一起简化开发过程，并消除设置开销。</p></div><div class="ab cl ln lo hu lp" role="separator"><span class="lq bw bk lr ls lt"/><span class="lq bw bk lr ls lt"/><span class="lq bw bk lr ls"/></div><div class="ij ik il im in"><h1 id="206c" class="lu lv iq bd lw lx ly lz ma mb mc md me jw mf jx mg jz mh ka mi kc mj kd mk ml bi translated"><strong class="ak">当前项目结构及其解决方案</strong></h1><p id="0562" class="pw-post-body-paragraph kr ks iq kt b ku mu jr kw kx mv ju kz la mw lc ld le mx lg lh li my lk ll lm ij bi translated">这个项目的代码可以在<a class="ae mt" href="https://github.com/mukul13/docker-example" rel="noopener ugc nofollow" target="_blank"> GitHub </a>上找到。对于这个项目，我们将为两个Node.js服务器和一个<a class="ae mt" href="https://www.postgresql.org/" rel="noopener ugc nofollow" target="_blank"> Postgres </a>数据库设置容器。</p><p id="69c3" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">我们可以用不同的语言或框架编写两个服务器，只要我们为它正确初始化Docker文件。</p><p id="2961" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">为了简单起见，我们将托管两个Node.js服务器和两个基本端点来测试这个项目。</p><pre class="kg kh ki kj gt mz na nb nc aw nd bi"><span id="da05" class="ne lv iq na b gy nf ng l nh ni">### Sample requests<br/>curl <a class="ae mt" href="http://localhost:4000/" rel="noopener ugc nofollow" target="_blank">http://localhost:4000/</a></span><span id="9c7f" class="ne lv iq na b gy nj ng l nh ni"># Expected response<br/>#<br/>#  {"message":"Hello from Server 1"}<br/>#</span><span id="da2c" class="ne lv iq na b gy nj ng l nh ni">curl <a class="ae mt" href="http://localhost:4000/" rel="noopener ugc nofollow" target="_blank">http://localhost:3001/</a></span><span id="76f7" class="ne lv iq na b gy nj ng l nh ni"># Expected response<br/>#<br/>#  {"message":"Hello from Server 2"}<br/>#</span></pre><p id="bbee" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">目前的项目结构如下:</p><pre class="kg kh ki kj gt mz na nb nc aw nd bi"><span id="9802" class="ne lv iq na b gy nf ng l nh ni">docker-example<br/>- server1 (will run on port 4000)<br/>- server2 (will run on port 3001)<br/>- docker-compose.yml (will initialize all Docker containers: postgres, server1, and server2)</span></pre><p id="fba1" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">首先，我们必须将<code class="fe nk nl nm na b">Dockerfile</code>添加到每个Node.js服务器项目中。</p><p id="2804" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">根据我们使用的语言和框架，这些docker文件可能会有所不同。<code class="fe nk nl nm na b">Dockerfile</code>是一个文本文档，包含用户可以在命令行上调用的所有命令，以组合一个图像。</p><p id="f42c" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">对于<code class="fe nk nl nm na b">server1</code>，我们的<code class="fe nk nl nm na b">Dockerfile</code>看起来是这样的:</p><pre class="kg kh ki kj gt mz na nb nc aw nd bi"><span id="2ab4" class="ne lv iq na b gy nf ng l nh ni">FROM node:12.4.0<br/>EXPOSE 4000</span><span id="45f7" class="ne lv iq na b gy nj ng l nh ni">WORKDIR /home/server1</span><span id="ff0e" class="ne lv iq na b gy nj ng l nh ni">COPY package.json /home/server1/<br/>COPY package-lock.json /home/server1/</span><span id="c1c3" class="ne lv iq na b gy nj ng l nh ni">RUN npm ci</span><span id="06b5" class="ne lv iq na b gy nj ng l nh ni">COPY . /home/server1</span><span id="7748" class="ne lv iq na b gy nj ng l nh ni">RUN npm install</span><span id="2ca9" class="ne lv iq na b gy nj ng l nh ni">ADD <a class="ae mt" href="https://github.com/ufoscout/docker-compose-wait/releases/download/2.2.1/wait" rel="noopener ugc nofollow" target="_blank">https://github.com/ufoscout/docker-compose-wait/releases/download/2.2.1/wait</a> /wait<br/>RUN chmod +x /wait</span><span id="a5a6" class="ne lv iq na b gy nj ng l nh ni">## Launch the wait tool and then your application<br/>CMD /wait &amp;&amp; PORT=4000 yarn start</span></pre><p id="635a" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">基本上，我们要做的是:</p><ul class=""><li id="d87a" class="nn no iq kt b ku kv kx ky la np le nq li nr lm ns nt nu nv bi translated">暴露端口4000，下载节点版本12.4.0 Docker镜像来构建这个项目。</li><li id="6978" class="nn no iq kt b ku nw kx nx la ny le nz li oa lm ns nt nu nv bi translated">创建一个工作目录，并在其中复制所需的文件夹。</li><li id="6cfd" class="nn no iq kt b ku nw kx nx la ny le nz li oa lm ns nt nu nv bi translated">当我们开始项目的构建过程时，<code class="fe nk nl nm na b">docker-compose.yml</code>中提到的所有Docker服务都被初始化并同时运行。<code class="fe nk nl nm na b">/wait</code>命令是在运行下一个命令之前等待图像加载。例如，我们希望首先初始化PostgreSQL数据库，然后初始化所有服务器，以便在服务器启动时数据库连接不会出现问题。另一种方法是在Node.js服务器代码中添加重试，以等待数据库连接，但我发现这种方法很容易解决上述问题。</li><li id="a104" class="nn no iq kt b ku nw kx nx la ny le nz li oa lm ns nt nu nv bi translated">最后，我们创建了一个Docker容器，可以通过<code class="fe nk nl nm na b">docker-compose.yml</code>初始化。基本上，我们已经以某种方式将多个乐高块连接起来，使事情能够工作(Node是一个乐高块，Node.js代码库是另一个乐高块)。</li></ul><p id="1bd2" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">现在，<code class="fe nk nl nm na b">server2</code>也将有一个类似的<code class="fe nk nl nm na b">Dockerfile</code>。<code class="fe nk nl nm na b">docker-compose.yml</code>如下:</p><pre class="kg kh ki kj gt mz na nb nc aw nd bi"><span id="2997" class="ne lv iq na b gy nf ng l nh ni"># docker-compose.yml<br/>version: "3.3"<br/>services:<br/>  postgres:<br/>    image: postgres<br/>    hostname: postgres<br/>    environment:<br/>      POSTGRES_DB: postgres<br/>      POSTGRES_USER: postgres<br/>      POSTGRES_PASSWORD: postgres<br/>    ports:<br/>      - 5432:5432</span><span id="11d7" class="ne lv iq na b gy nj ng l nh ni">app:<br/>    build: ./server1<br/>    hostname: app<br/>    env_file: ./server1/.env<br/>    depends_on:<br/>      - postgres<br/>    links:<br/>      - postgres<br/>    ports:<br/>      - 4000:4000<br/>    environment:<br/>      WAIT_HOSTS: postgres:5432</span><span id="a95a" class="ne lv iq na b gy nj ng l nh ni">client:<br/>    build: ./server2<br/>    hostname: client<br/>    env_file: ./server2/.env<br/>    ports:<br/>      - 3001:3001<br/>    depends_on:<br/>      - postgres<br/>    links:<br/>      - postgres<br/>    environment:<br/>      WAIT_HOSTS: postgres:5432</span></pre><p id="ab7e" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated"><code class="fe nk nl nm na b">docker-compose.yml</code>是我们应用程序的起点。</p><p id="8a24" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">它用于初始化所有Docker容器(<code class="fe nk nl nm na b">server1</code>、<code class="fe nk nl nm na b">server2</code>和Postgres)，暴露端口并映射各自的环境变量。</p><p id="2dec" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">我们正在努力做的是:</p><ul class=""><li id="03dd" class="nn no iq kt b ku kv kx ky la np le nq li nr lm ns nt nu nv bi translated">为我们拥有的不同服务创建单独的配置。</li><li id="9c90" class="nn no iq kt b ku nw kx nx la ny le nz li oa lm ns nt nu nv bi translated"><code class="fe nk nl nm na b">WAIT_HOSTS</code>用于等待<code class="fe nk nl nm na b">postgres</code>服务完成执行。</li><li id="64cc" class="nn no iq kt b ku nw kx nx la ny le nz li oa lm ns nt nu nv bi translated">暴露所需的<code class="fe nk nl nm na b">ports</code>并添加<code class="fe nk nl nm na b">build</code>路径。</li></ul><p id="2b52" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">要运行当前项目:</p><pre class="kg kh ki kj gt mz na nb nc aw nd bi"><span id="1442" class="ne lv iq na b gy nf ng l nh ni">cd to-the-parent-directory<br/>docker-compose up</span></pre><p id="a295" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">要停止和移除当前项目的容器，请执行以下操作:</p><pre class="kg kh ki kj gt mz na nb nc aw nd bi"><span id="8d60" class="ne lv iq na b gy nf ng l nh ni">cd to-the-parent-directory<br/>docker-compose down</span></pre><p id="0493" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">要获得有关运行容器的更多信息:</p><pre class="kg kh ki kj gt mz na nb nc aw nd bi"><span id="54e0" class="ne lv iq na b gy nf ng l nh ni">docker ps</span></pre><p id="187b" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">我们可以尝试<code class="fe nk nl nm na b">curl</code>请求来验证服务器是否正常运行。</p><p id="851f" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">如果你试图从<code class="fe nk nl nm na b">server2</code>点击<code class="fe nk nl nm na b">server1</code>，你将不得不在<code class="fe nk nl nm na b">server2</code>的<code class="fe nk nl nm na b">.env</code>文件中设置主机URL为<code class="fe nk nl nm na b">app</code>(而不是<code class="fe nk nl nm na b">localhost</code>)，因为那是<code class="fe nk nl nm na b">server1</code>的<code class="fe nk nl nm na b">hostname</code>。</p><p id="67ab" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">类似地，当连接到数据库时，您必须使用<code class="fe nk nl nm na b">postgres</code>(这是我们的<code class="fe nk nl nm na b">docker-compose.yml</code>中的服务名)而不是<code class="fe nk nl nm na b">localhost</code>。</p><p id="a95d" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">感谢阅读。我希望这有所帮助。不要犹豫，纠正评论中的任何错误或为未来的帖子提供建议！</p></div></div>    
</body>
</html>