<html>
<head>
<title>Building iOS apps faster using Bazel</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用Bazel更快地构建iOS应用</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/building-ios-apps-faster-using-bazel-b960f6788fab?source=collection_archive---------10-----------------------#2022-04-19">https://betterprogramming.pub/building-ios-apps-faster-using-bazel-b960f6788fab?source=collection_archive---------10-----------------------#2022-04-19</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><h2 id="5f1a" class="ir is it bd b dl iu iv iw ix iy iz dk ja translated" aria-label="kicker paragraph">iOS开发工具</h2><div class=""/><div class=""><h2 id="f1d9" class="pw-subtitle-paragraph jz jc it bd b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq dk translated">了解如何在没有Xcode的情况下更快地构建iOS应用程序</h2></div><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi kr"><img src="../Images/2c5d950e708918b93510138f699df372.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*2R9hoqTbwaYv3NyV"/></div></div><p class="ld le gj gh gi lf lg bd b be z dk translated">Loubna Aggoun 在<a class="ae lh" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</p></figure><p id="c4b2" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">你是否想过在每次创建一个干净的iOS应用程序时喝杯咖啡？也许你和我一样，在等待的时候开始浏览instagram。更糟糕的是，当构建完成时，你已经忘记了你下一步应该做什么，或者你为什么要进行这个干净的构建。</p><p id="b317" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">随着iOS代码库的增长，它们的构建变得越来越慢。较慢的构建时间会导致开发人员效率较低，更加沮丧。</p><p id="ce00" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">那么，我们如何加快构建时间呢？一种方法是<a class="ae lh" href="https://medium.com/@anuragajwani/modular-ios-guide-60810f5a7f97" rel="noopener">将你的应用</a>模块化成独立的块，然后使用你不会处理的块的<a class="ae lh" href="https://medium.com/@anuragajwani/how-to-build-universal-ios-frameworks-using-xcframeworks-4c2790cfa623" rel="noopener">已编译模块</a>。然而，这可能很难管理。开发人员需要知道他们将在哪些模块上工作。其余的模块需要从缓存中获取。此外，他们可能需要为将要工作的每个分支配置不同的Xcode。</p><p id="d69d" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">那么，有没有更好的方法来加快应用程序的构建时间呢？有，有！Bazel 是许多语言和应用程序的开源构建工具。Bazel 还增加了缓存构建并无缝使用它们的选项。</p><p id="531c" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">在本教程中，我将向您展示如何迁移现有应用程序以使用<a class="ae lh" href="https://bazel.build" rel="noopener ugc nofollow" target="_blank"> Bazel </a>。<a class="ae lh" href="https://bazel.build" rel="noopener ugc nofollow" target="_blank"> Bazel </a>不使用Xcode构建系统、工具和IDE。因此，我将继续指导如何在模拟器上调试Bazel管理的iOS应用程序。然后，我将指导您如何缓存构建以加快构建时间。最后，我将介绍何时不使用<a class="ae lh" href="https://bazel.build" rel="noopener ugc nofollow" target="_blank"> Bazel </a>。</p><p id="e31f" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">以下是这篇文章将如何划分的概述:</p><ol class=""><li id="4d00" class="me mf it lk b ll lm lo lp lr mg lv mh lz mi md mj mk ml mm bi translated">如何将现有的<a class="ae lh" href="https://github.com/anuragajwani/bazel-ios-tut/releases/tag/starter" rel="noopener ugc nofollow" target="_blank"> iOS项目</a>转换为使用<a class="ae lh" href="https://bazel.build" rel="noopener ugc nofollow" target="_blank"> Bazel </a></li><li id="7c7a" class="me mf it lk b ll mn lo mo lr mp lv mq lz mr md mj mk ml mm bi translated">使用<a class="ae lh" href="https://bazel.build" rel="noopener ugc nofollow" target="_blank">巴泽尔</a>时调试iOS应用</li><li id="c7ca" class="me mf it lk b ll mn lo mo lr mp lv mq lz mr md mj mk ml mm bi translated">远程缓存在<a class="ae lh" href="https://bazel.build" rel="noopener ugc nofollow" target="_blank">巴泽尔</a>构建输出</li><li id="a827" class="me mf it lk b ll mn lo mo lr mp lv mq lz mr md mj mk ml mm bi translated">何时不使用<a class="ae lh" href="https://bazel.build" rel="noopener ugc nofollow" target="_blank"> Bazel </a></li></ol><p id="d811" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated"><em class="ms">我在这篇文章中使用了Swift 5.6和Xcode 13.3。</em></p></div><div class="ab cl mt mu hx mv" role="separator"><span class="mw bw bk mx my mz"/><span class="mw bw bk mx my mz"/><span class="mw bw bk mx my"/></div><div class="im in io ip iq"><h1 id="5931" class="na nb it bd nc nd ne nf ng nh ni nj nk ki nl kj nm kl nn km no ko np kp nq nr bi translated">如何将一个iOS应用程序项目转换为使用Bazel</h1><p id="92cb" class="pw-post-body-paragraph li lj it lk b ll ns kd ln lo nt kg lq lr nu lt lu lv nv lx ly lz nw mb mc md im bi translated">在这一部分，我们将从安装<a class="ae lh" href="https://bazel.build" rel="noopener ugc nofollow" target="_blank"> Bazel </a>开始。然后我们将下载一个已经存在的iOS应用程序项目。最后，我们将迁移项目以使用<a class="ae lh" href="https://bazel.build" rel="noopener ugc nofollow" target="_blank"> Bazel </a>。</p><p id="9544" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">以下是我们将要采取的步骤:</p><ol class=""><li id="7f83" class="me mf it lk b ll lm lo lp lr mg lv mh lz mi md mj mk ml mm bi translated">安装<a class="ae lh" href="https://bazel.build" rel="noopener ugc nofollow" target="_blank">挡板</a></li><li id="31c3" class="me mf it lk b ll mn lo mo lr mp lv mq lz mr md mj mk ml mm bi translated">下载入门包</li><li id="1ef3" class="me mf it lk b ll mn lo mo lr mp lv mq lz mr md mj mk ml mm bi translated">将项目转换为使用<a class="ae lh" href="https://bazel.build" rel="noopener ugc nofollow" target="_blank"> Bazel </a></li></ol><p id="1768" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">我们开始吧！</p><h2 id="7724" class="nx nb it bd nc ny nz dn ng oa ob dp nk lr oc od nm lv oe of no lz og oh nq iz bi translated">1.安装Bazel</h2><p id="56c2" class="pw-post-body-paragraph li lj it lk b ll ns kd ln lo nt kg lq lr nu lt lu lv nv lx ly lz nw mb mc md im bi translated">有多种方法安装<a class="ae lh" href="https://bazel.build" rel="noopener ugc nofollow" target="_blank"> Bazel </a>。然而，在本教程中，我们将使用<a class="ae lh" href="https://brew.sh" rel="noopener ugc nofollow" target="_blank">自制软件</a>来安装Bazel。</p><p id="ec20" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated"><a class="ae lh" href="https://brew.sh" rel="noopener ugc nofollow" target="_blank">家酿</a>是一个软件包管理系统。对于macOS来说，它是一个非常受欢迎的工具。如果您还没有安装它，那么继续这样做。遵循<a class="ae lh" href="https://brew.sh/" rel="noopener ugc nofollow" target="_blank">家酿</a>在其网站<a class="ae lh" href="https://brew.sh/" rel="noopener ugc nofollow" target="_blank"> brew.sh </a>上的安装说明。</p><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi oi"><img src="../Images/f58e3e49a8ea2bcbb5f19fa59e5d1475.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*4O6nw7eHOGxB213A.png"/></div></div></figure><p id="2556" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">一旦安装好自制软件，让我们安装Bazel。在终端中运行以下命令:</p><pre class="ks kt ku kv gt oj ok ol om aw on bi"><span id="2f95" class="nx nb it ok b gy oo op l oq or">brew install bazel</span></pre><p id="4fe6" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">一旦成功完成，我们将准备开始使用<a class="ae lh" href="https://bazel.build" rel="noopener ugc nofollow" target="_blank">巴泽尔</a>。</p><h2 id="15f6" class="nx nb it bd nc ny nz dn ng oa ob dp nk lr oc od nm lv oe of no lz og oh nq iz bi translated">2.下载入门包</h2><p id="7637" class="pw-post-body-paragraph li lj it lk b ll ns kd ln lo nt kg lq lr nu lt lu lv nv lx ly lz nw mb mc md im bi translated">在本教程中，我们将使用一个现有的iOS应用程序项目来举例说明如何迁移到使用<a class="ae lh" href="https://bazel.build" rel="noopener ugc nofollow" target="_blank"> Bazel </a>。让我们下载一个已经存在的iOS应用程序项目。打开终端并运行以下命令:</p><pre class="ks kt ku kv gt oj ok ol om aw on bi"><span id="86cd" class="nx nb it ok b gy oo op l oq or">cd $HOME<br/>curl <a class="ae lh" href="https://github.com/anuragajwani/bazel-ios-tut/archive/starter.zip" rel="noopener ugc nofollow" target="_blank">https://github.com/anuragajwani/bazel-ios-tut/archive/starter.zip</a> -L -o starter.zip -s<br/>unzip -q starter.zip<br/>cd bazel-ios-tut-starter</span></pre><h2 id="34d7" class="nx nb it bd nc ny nz dn ng oa ob dp nk lr oc od nm lv oe of no lz og oh nq iz bi translated">3.将项目转换为使用<a class="ae lh" href="https://bazel.build" rel="noopener ugc nofollow" target="_blank"> Bazel </a></h2><p id="ee43" class="pw-post-body-paragraph li lj it lk b ll ns kd ln lo nt kg lq lr nu lt lu lv nv lx ly lz nw mb mc md im bi translated">在这一步中，我们将迁移starter项目中的app项目以使用Bazel。</p><p id="f7a6" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">首先，我们来分析一下Xcode管理的项目的项目结构。</p><pre class="ks kt ku kv gt oj ok ol om aw on bi"><span id="7256" class="nx nb it ok b gy oo op l oq or">.<br/>├── README.md<br/>├── SaladMaker<br/>├── SaladMaker.xcodeproj<br/>└── SayHelloKit</span></pre><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div class="gh gi os"><img src="../Images/0bc7e58deed0b5dabeb136792c1d8cbb.png" data-original-src="https://miro.medium.com/v2/resize:fit:326/format:webp/1*tH67_r1X4cMqlRNgWI3jWQ.png"/></div><p class="ld le gj gh gi lf lg bd b be z dk translated">SaladMaker.xcodeproj中的目标</p></figure><p id="a89a" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated"><code class="fe ot ou ov ok b">SaladMaker</code>项目由两个目标组成:</p><ol class=""><li id="78d3" class="me mf it lk b ll lm lo lp lr mg lv mh lz mi md mj mk ml mm bi translated"><code class="fe ot ou ov ok b">SaladMaker</code> iOS应用程序</li><li id="5f48" class="me mf it lk b ll mn lo mo lr mp lv mq lz mr md mj mk ml mm bi translated"><code class="fe ot ou ov ok b">SayHelloKit</code>框架</li></ol><p id="44f7" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated"><code class="fe ot ou ov ok b">SaladMaker</code>的源代码位于一个名为<code class="fe ot ou ov ok b">SaladMaker</code>的目录中。</p><p id="2092" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated"><code class="fe ot ou ov ok b">SayHelloKit</code>的源代码位于一个名为<code class="fe ot ou ov ok b">SayHelloKit</code>的目录中。</p><p id="0cc4" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">这两个目标都支持iOS 14及以上版本。<code class="fe ot ou ov ok b">SayHelloKit</code>框架被<code class="fe ot ou ov ok b">SaladMaker</code>应用消费。</p><p id="ebf9" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">接下来，让我们在Bazel中重新创建项目结构。在项目的根目录下，我们需要创建一个名为<code class="fe ot ou ov ok b">WORKSPACE.bazel</code>的文件。Bazel工作空间是:</p><blockquote class="ow ox oy"><p id="be4e" class="li lj ms lk b ll lm kd ln lo lp kg lq oz ls lt lu pa lw lx ly pb ma mb mc md im bi translated">您的文件系统上的一个目录树，包含您想要构建的软件的源文件<br/> - <a class="ae lh" href="https://bazel.build/concepts/build-ref" rel="noopener ugc nofollow" target="_blank"> Bazel docs </a></p></blockquote><p id="24bb" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">简单来说，它标记了项目的根。目标必须位于包含<code class="fe ot ou ov ok b">WORKSPACE</code>的目录下。</p><p id="a51a" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">让我们创建<code class="fe ot ou ov ok b">WORKSPACE</code>。在终端中运行以下命令:</p><pre class="ks kt ku kv gt oj ok ol om aw on bi"><span id="391e" class="nx nb it ok b gy oo op l oq or">cat &gt; WORKSPACE.bazel &lt;&lt;-EOF<br/>load("<a class="ae lh" href="http://twitter.com/bazel_tools" rel="noopener ugc nofollow" target="_blank">@bazel_tools</a>//tools/build_defs/repo:http.bzl", "http_archive")</span><span id="fb17" class="nx nb it ok b gy pc op l oq or">http_archive(<br/>    name = "build_bazel_rules_apple",<br/>    sha256 = "4161b2283f80f33b93579627c3bd846169b2d58848b0ffb29b5d4db35263156a",<br/>    url = "<a class="ae lh" href="https://github.com/bazelbuild/rules_apple/releases/download/0.34.0/rules_apple.0.34.0.tar.gz" rel="noopener ugc nofollow" target="_blank">https://github.com/bazelbuild/rules_apple/releases/download/0.34.0/rules_apple.0.34.0.tar.gz</a>",<br/>)</span><span id="3e89" class="nx nb it ok b gy pc op l oq or">load(<br/>    "<a class="ae lh" href="http://twitter.com/build_bazel_rules_ap" rel="noopener ugc nofollow" target="_blank">@build_bazel_rules_ap</a>ple//apple:repositories.bzl",<br/>    "apple_rules_dependencies",<br/>)</span><span id="dbad" class="nx nb it ok b gy pc op l oq or">apple_rules_dependencies()</span><span id="e39b" class="nx nb it ok b gy pc op l oq or">load(<br/>    "<a class="ae lh" href="http://twitter.com/build_bazel_rules_sw" rel="noopener ugc nofollow" target="_blank">@build_bazel_rules_sw</a>ift//swift:repositories.bzl",<br/>    "swift_rules_dependencies",<br/>)</span><span id="eff9" class="nx nb it ok b gy pc op l oq or">swift_rules_dependencies()</span><span id="51a2" class="nx nb it ok b gy pc op l oq or">load(<br/>    "<a class="ae lh" href="http://twitter.com/build_bazel_rules_sw" rel="noopener ugc nofollow" target="_blank">@build_bazel_rules_sw</a>ift//swift:extras.bzl",<br/>    "swift_rules_extra_dependencies",<br/>)</span><span id="c07e" class="nx nb it ok b gy pc op l oq or">swift_rules_extra_dependencies()</span><span id="2d52" class="nx nb it ok b gy pc op l oq or">load(<br/>    "<a class="ae lh" href="http://twitter.com/build_bazel_apple_su" rel="noopener ugc nofollow" target="_blank">@build_bazel_apple_su</a>pport//lib:repositories.bzl",<br/>    "apple_support_dependencies",<br/>)</span><span id="e745" class="nx nb it ok b gy pc op l oq or">apple_support_dependencies()<br/>EOF</span></pre><p id="9dc2" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">上面我们正在获取和加载知道如何构建iOS应用(<code class="fe ot ou ov ok b">bazelbuild/rules_apple</code>)和swift库(<code class="fe ot ou ov ok b">bazelbuild/rules_swift</code>)的代码。在Bazel中，完成构建的函数被称为<a class="ae lh" href="https://bazel.build/rules/rules" rel="noopener ugc nofollow" target="_blank"> <em class="ms">规则</em> </a>。</p><p id="fc77" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">您可能已经注意到，我们的<em class="ms">工作区</em>不包含关于要构建的目标的信息。Bazel 将在我们项目的根目录下搜索要构建的东西。<a class="ae lh" href="https://bazel.build" rel="noopener ugc nofollow" target="_blank"> Bazel </a>将寻找一个名为<code class="fe ot ou ov ok b">BUILD.bazel</code>的文件，我们在其中指定要构建的内容。我们通常在Xcode中将这些称为目标。有两件事要做:</p><ol class=""><li id="2cb3" class="me mf it lk b ll lm lo lp lr mg lv mh lz mi md mj mk ml mm bi translated"><code class="fe ot ou ov ok b">SaladMaker</code> iOS应用程序</li><li id="304e" class="me mf it lk b ll mn lo mo lr mp lv mq lz mr md mj mk ml mm bi translated"><code class="fe ot ou ov ok b">SayHelloKit</code>图书馆</li></ol><p id="c007" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">因此，我们将为其中的每一个创建一个<code class="fe ot ou ov ok b">BUILD.bazel</code>。</p><p id="54b7" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">注意:最初的<code class="fe ot ou ov ok b">SayHelloKit</code>目标是一个动态框架。为了简单起见，在这篇文章中我们将把它转换成一个静态库。这个职位不需要模块类型的知识。你可以在我的<a class="ae lh" href="https://medium.com/p/60810f5a7f97" rel="noopener">模块化iOS指南</a>中了解更多关于动态与静态的内容。</p><p id="5278" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">让我们先为<code class="fe ot ou ov ok b">SayHelloKit</code>创建<code class="fe ot ou ov ok b">BUILD.bazel</code>。在终端中运行以下命令:</p><pre class="ks kt ku kv gt oj ok ol om aw on bi"><span id="4a99" class="nx nb it ok b gy oo op l oq or">cat &gt; SayHelloKit/BUILD.bazel &lt;&lt;-EOF<br/>load("<a class="ae lh" href="http://twitter.com/build_bazel_rules_sw" rel="noopener ugc nofollow" target="_blank">@build_bazel_rules_sw</a>ift//swift:swift.bzl", "swift_library")</span><span id="f6d0" class="nx nb it ok b gy pc op l oq or">swift_library(<br/>    name = "SayHelloKit",<br/>    module_name = "SayHelloKit",<br/>    srcs = ["SayHello.swift"],<br/>    visibility = ["//visibility:public"],<br/>)<br/>EOF</span></pre><p id="aa82" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">上面我们已经用Swift静态库创建了一个<code class="fe ot ou ov ok b">BUILD.bazel</code>文件作为产品。为了生成库，我们使用了<code class="fe ot ou ov ok b">swift_library</code>函数或<em class="ms">规则</em>。记得我们在<code class="fe ot ou ov ok b">WORKSAPCE.bazel</code>文件中加载了swift构建规则。在这个<code class="fe ot ou ov ok b">BUILD.bazel</code>文件中，我们已经加载了<code class="fe ot ou ov ok b">swift_library</code>规则。</p><p id="60cf" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">接下来，让我们为<code class="fe ot ou ov ok b">SaladMaker</code>目标创建一个<code class="fe ot ou ov ok b">BUILD.bazel</code>文件。然而，在我们这样做之前，让我们重组一下<code class="fe ot ou ov ok b">SaladMaker</code>目录。为什么？您可能已经注意到，我们将文件<code class="fe ot ou ov ok b">SayHello.swift</code>列为<code class="fe ot ou ov ok b">SayHelloKit</code>的sources ( <code class="fe ot ou ov ok b">srcs</code>)下的唯一文件。在大型应用程序中列出每个文件不太容易。我们可以使用double <code class="fe ot ou ov ok b">glob</code>函数和目录路径中的星号(<code class="fe ot ou ov ok b">**</code>)来告诉<a class="ae lh" href="https://bazel.build" rel="noopener ugc nofollow" target="_blank"> Bazel </a>将一个目录下的所有文件作为其来源。但是，该规则只接受Swift文件。因此，and <code class="fe ot ou ov ok b">Info.plist</code> or图像将不被接受，构建将失败。</p><p id="d69b" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">让我们重组<code class="fe ot ou ov ok b">SaladMaker</code>。在终端中运行以下命令:</p><pre class="ks kt ku kv gt oj ok ol om aw on bi"><span id="7359" class="nx nb it ok b gy oo op l oq or">mkdir SaladMaker/Sources<br/>mkdir SaladMaker/Resources<br/>mv SaladMaker/*.swift SaladMaker/Sources<br/>mv SaladMaker/Assets.xcassets SaladMaker/Resources &amp;&amp; mv SaladMaker/Preview\ Content SaladMaker/Resources</span></pre><p id="ba3d" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">现在所有<code class="fe ot ou ov ok b">SaladMaker</code>的Swift文件都在<code class="fe ot ou ov ok b">SaladMaker/Sources</code>下，所有其他资源都在<code class="fe ot ou ov ok b">SaladMaker/Resources</code>下。接下来让我们为<code class="fe ot ou ov ok b">SaladMaker</code>创建<code class="fe ot ou ov ok b">BUILD.bazel</code>文件。</p><p id="46fb" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">在终端中运行以下命令:</p><pre class="ks kt ku kv gt oj ok ol om aw on bi"><span id="e12d" class="nx nb it ok b gy oo op l oq or">cat &gt; SaladMaker/BUILD.bazel &lt;&lt;-EOF<br/>load("<a class="ae lh" href="http://twitter.com/build_bazel_rules_ap" rel="noopener ugc nofollow" target="_blank">@build_bazel_rules_ap</a>ple//apple:ios.bzl", "ios_application")<br/>load("<a class="ae lh" href="http://twitter.com/build_bazel_rules_sw" rel="noopener ugc nofollow" target="_blank">@build_bazel_rules_sw</a>ift//swift:swift.bzl", "swift_library")<br/>load("<a class="ae lh" href="http://twitter.com/build_bazel_rules_ap" rel="noopener ugc nofollow" target="_blank">@build_bazel_rules_ap</a>ple//apple:resources.bzl", "apple_resource_bundle")</span><span id="42ed" class="nx nb it ok b gy pc op l oq or">apple_resource_bundle(<br/>    name = "SaladMaker_Resoures",<br/>    bundle_id = "com.anuragajwani.SaladMaker_Resources",<br/>    resources = [<br/>        "Resources/Assets.xcassets",<br/>        "Resources/Preview Content"<br/>    ],<br/>    visibility = ["//visibility:public"],<br/>)</span><span id="8eac" class="nx nb it ok b gy pc op l oq or">swift_library(<br/>    name = "Sources",<br/>    srcs = glob(["Sources/**"]),<br/>    deps = [<br/>        "//SayHelloKit:SayHelloKit"<br/>    ],<br/>    visibility = ["//visibility:public"],<br/>)</span><span id="cc67" class="nx nb it ok b gy pc op l oq or">ios_application(<br/>    name = "SaladMaker",<br/>    bundle_id = "com.anuragajwani.SaladMaker",<br/>    deps = [<br/>        ":Sources",<br/>        ":SaladMaker_Resoures"<br/>    ],<br/>    families = [<br/>        "iphone"<br/>    ],<br/>    infoplists = ["Info.plist"],<br/>    minimum_os_version = "14.0",<br/>    visibility = ["//visibility:public"],<br/>    resources = [":SaladMaker_Resoures"]<br/>)<br/>EOF</span></pre><p id="12b0" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">上面我们有三个规则可以调用:</p><ol class=""><li id="80a9" class="me mf it lk b ll lm lo lp lr mg lv mh lz mi md mj mk ml mm bi translated"><code class="fe ot ou ov ok b">SaladMaker</code> app</li><li id="9312" class="me mf it lk b ll mn lo mo lr mp lv mq lz mr md mj mk ml mm bi translated"><code class="fe ot ou ov ok b">SaladMaker</code> app源代码文件包装在一个库中</li><li id="6454" class="me mf it lk b ll mn lo mo lr mp lv mq lz mr md mj mk ml mm bi translated"><code class="fe ot ou ov ok b">SaladMaker</code>打包在资源包中的资源</li></ol><p id="4007" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated"><code class="fe ot ou ov ok b">ios_application</code>规则不接受源代码文件或资源文件的参数。该规则期望代码和资源作为单独构建的工件，然后链接到应用程序。因此，源代码被构建为静态库，资源被包装在资源包中。</p><p id="4289" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">两件值得注意的事情是源代码库中的<code class="fe ot ou ov ok b">srcs</code>参数和到<code class="fe ot ou ov ok b">SayHelloKit</code>依赖项的链接。</p><p id="8273" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">首先，<code class="fe ot ou ov ok b">srcs</code>注意，我们还没有声明所有的Swift文件。这很容易变成一个大列表，因此我们从<code class="fe ot ou ov ok b">SaladMaker/Sources</code>目录中选择所有文件。所有这些文件都必须很快，否则构建会失败。</p><p id="8047" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">第二，我们声明<code class="fe ot ou ov ok b">SayHelloKit</code>是一个附属国；<code class="fe ot ou ov ok b">//SayHelloKit:SayHelloKit</code>。基本上，我们是说依赖项位于项目根目录下的<code class="fe ot ou ov ok b">SayHelloKit</code>目录下(T5所在的位置)，带有一个模块名<code class="fe ot ou ov ok b">SayHelloKit</code>(在冒号<code class="fe ot ou ov ok b">:</code>之后)。</p><p id="c00c" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">迁移就是这样。您现在可以开始构建了。在终端中运行以下命令:</p><pre class="ks kt ku kv gt oj ok ol om aw on bi"><span id="c46f" class="nx nb it ok b gy oo op l oq or">bazel build //SaladMaker:SaladMaker</span></pre><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi pd"><img src="../Images/6ab48e1de3df762a6a4fdf1678648f20.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*923vjRIDDPE26V6CZF6FBA.png"/></div></div><p class="ld le gj gh gi lf lg bd b be z dk translated">使用Bazel构建SaladMaker应用程序</p></figure><h1 id="210a" class="na nb it bd nc nd pe nf ng nh pf nj nk ki pg kj nm kl ph km no ko pi kp nq nr bi translated">调试用Bazel构建的iOS应用程序</h1><p id="f5b2" class="pw-post-body-paragraph li lj it lk b ll ns kd ln lo nt kg lq lr nu lt lu lv nv lx ly lz nw mb mc md im bi translated">在上一节中，我们将一个现有的app项目从Xcode构建系统迁移到了<a class="ae lh" href="https://bazel.build" rel="noopener ugc nofollow" target="_blank"> Bazel </a>构建系统。在这个过程中，我们重组了目录。最后，我们通过命令行用<a class="ae lh" href="https://bazel.build" rel="noopener ugc nofollow" target="_blank"> Bazel </a>搭建了app。</p><p id="0a41" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">但是，如何才能调试好自己的app呢？通常我们会在模拟器或设备上通过Xcode运行应用程序。在撰写本文时，没有其他方法可以将iOS应用程序调试到Xcode。</p><p id="c0f8" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">如果您试图打开项目中的<code class="fe ot ou ov ok b">xcodeproj</code>,它将无法工作，因为文件已被移动，对文件位置的引用已被破坏。</p><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div class="gh gi pj"><img src="../Images/5ac115a9f7640eac52731052438c91fd.png" data-original-src="https://miro.medium.com/v2/resize:fit:534/format:webp/1*jGUZmmNpHyUMX6UlnLwXLA.png"/></div><p class="ld le gj gh gi lf lg bd b be z dk translated">Xcode中损坏的文件引用</p></figure><p id="58f4" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">此外，我们希望使用<a class="ae lh" href="https://bazel.build" rel="noopener ugc nofollow" target="_blank"> Bazel的</a>构建系统从更快的构建时间中获益。那么我们如何在使用<a class="ae lh" href="https://bazel.build" rel="noopener ugc nofollow" target="_blank"> Bazel </a>构建系统的同时使用Xcode来调试iOS应用呢？为<a class="ae lh" href="https://bazel.build" rel="noopener ugc nofollow" target="_blank"> Bazel </a>管理的iOS项目生成<code class="fe ot ou ov ok b">xcodeproj</code>有两种流行的方法:</p><ol class=""><li id="a208" class="me mf it lk b ll lm lo lp lr mg lv mh lz mi md mj mk ml mm bi translated"><a class="ae lh" href="https://tulsi.bazel.build" rel="noopener ugc nofollow" target="_blank">图尔斯</a></li><li id="b94e" class="me mf it lk b ll mn lo mo lr mp lv mq lz mr md mj mk ml mm bi translated"><a class="ae lh" href="https://github.com/pinterest/xchammer" rel="noopener ugc nofollow" target="_blank"> XCHammer </a></li></ol><p id="e44f" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">这些工具将生成<code class="fe ot ou ov ok b">xcodeproj</code>并调用<a class="ae lh" href="https://bazel.build" rel="noopener ugc nofollow" target="_blank"> Bazel </a>构建系统，而不是Xcode的默认系统。然后Xcode将使用来自<a class="ae lh" href="https://bazel.build" rel="noopener ugc nofollow" target="_blank"> Bazel </a>的构建，并在您选择的物理或模拟器设备上运行应用程序。我们应该使用哪种工具，为什么？让我们来看看每一个。</p><p id="37d8" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">Tulsi是基于UI的工具，它利用<a class="ae lh" href="https://bazel.build" rel="noopener ugc nofollow" target="_blank"> Bazel </a>文件来构建中间文件。然后使用这些中间文件生成<code class="fe ot ou ov ok b">xcodeproj</code>。<a class="ae lh" href="https://github.com/bazelbuild/tulsi/tree/ea2d59e0f82390edbedd709e1816a80ed84f50ad#building-and-installing" rel="noopener ugc nofollow" target="_blank"> Tulsi需要与Bazel </a>分开安装和管理。</p><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi pk"><img src="../Images/a33376a78657c9ac961739a5bffe1511.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ivQzjfM8Xx3EZTFxY0I2FQ.png"/></div></div><p class="ld le gj gh gi lf lg bd b be z dk translated">用Tulsi生成的xcodeproj</p></figure><p id="b7c0" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated"><a class="ae lh" href="https://github.com/pinterest/xchammer" rel="noopener ugc nofollow" target="_blank"> XCHammer </a>是可以通过<a class="ae lh" href="https://bazel.build" rel="noopener ugc nofollow" target="_blank"> Bazel </a>本身安装的工具。这是一个可以通过<a class="ae lh" href="https://bazel.build" rel="noopener ugc nofollow" target="_blank"> Bazel </a>调用的规则。</p><p id="1625" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">我不会讨论如何实现这些。我将留下两个工具操作方法的链接:</p><ul class=""><li id="7a31" class="me mf it lk b ll lm lo lp lr mg lv mh lz mi md pl mk ml mm bi translated"><a class="ae lh" href="https://tulsi.bazel.build/docs/gettingstarted.html" rel="noopener ugc nofollow" target="_blank">如何使用Tulsi生成Xcodeproj】</a></li><li id="7497" class="me mf it lk b ll mn lo mo lr mp lv mq lz mr md pl mk ml mm bi translated"><a class="ae lh" href="https://github.com/pinterest/xchammer" rel="noopener ugc nofollow" target="_blank">如何使用XCHammer生成Xcodeproj】</a></li></ul><h1 id="36e0" class="na nb it bd nc nd pe nf ng nh pf nj nk ki pg kj nm kl ph km no ko pi kp nq nr bi translated">Bazel中的远程缓存构建输出</h1><p id="17b7" class="pw-post-body-paragraph li lj it lk b ll ns kd ln lo nt kg lq lr nu lt lu lv nv lx ly lz nw mb mc md im bi translated">巴泽尔在增量构建方面速度很快——也就是说只重建已经改变的东西。然而，从一个干净的状态开始构建仍然需要大量的时间。应用程序的某些部分不会在不同的要素分支之间发生变化。Bazel允许我们在远程服务器中缓存构建输出，并在从头构建时重用它们。</p><p id="7912" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">简单地说，你所需要的就是一个托管对象服务器。您可以创建、部署和管理自己的服务器。或者，你可以使用谷歌云存储或AWS S3。</p><p id="aaba" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">一旦远程服务器启动并运行，我们只需远程缓存bazel构建的参数:</p><pre class="ks kt ku kv gt oj ok ol om aw on bi"><span id="f2b5" class="nx nb it ok b gy oo op l oq or">bazel build <!-- -->--remote_cache=http://replace-with-your.host:port //SaladMaker:SaladMaker</span></pre><p id="f853" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">你可以在<a class="ae lh" href="https://bazel.build" rel="noopener ugc nofollow" target="_blank"> Bazel </a>文档中找到更多关于如何使用<a class="ae lh" href="https://bazel.build" rel="noopener ugc nofollow" target="_blank"> Bazel </a>远程缓存的信息:</p><div class="pm pn gp gr po pp"><a href="https://docs.bazel.build/versions/main/remote-caching.html" rel="noopener  ugc nofollow" target="_blank"><div class="pq ab fo"><div class="pr ab ps cl cj pt"><h2 class="bd jd gy z fp pu fr fs pv fu fw jc bi translated">远程缓存</h2><div class="pw l"><h3 class="bd b gy z fp pu fr fs pv fu fw dk translated">本页涵盖远程缓存、设置服务器来承载缓存以及使用远程缓存运行构建。一个…</h3></div><div class="px l"><p class="bd b dl z fp pu fr fs pv fu fw dk translated">docs.bazel.build</p></div></div><div class="py l"><div class="pz l qa qb qc py qd lb pp"/></div></div></a></div><h1 id="d990" class="na nb it bd nc nd pe nf ng nh pf nj nk ki pg kj nm kl ph km no ko pi kp nq nr bi translated">何时不使用Bazel</h1><p id="a876" class="pw-post-body-paragraph li lj it lk b ll ns kd ln lo nt kg lq lr nu lt lu lv nv lx ly lz nw mb mc md im bi translated">Bazel经常被用在大型项目中，有一个大型团队参与其中。这些项目的构建时间通常需要几十分钟，甚至接近一个小时。Bazel是一个强大的工具，可以将构建时间减少到原来的一小部分。然而，向项目中添加任何新工具都会增加项目的复杂性。因此，在决定使用某个工具时，利大于弊是很重要的。</p><p id="3c66" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated"><a class="ae lh" href="https://bazel.build" rel="noopener ugc nofollow" target="_blank">巴泽尔</a>使用一种叫做<a class="ae lh" href="https://github.com/bazelbuild/starlark" rel="noopener ugc nofollow" target="_blank"> Starlank </a>的语言，这是Python的一种方言。您团队中的iOS工程师需要学习一门新语言来维护项目和构建配置。</p><p id="28d2" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">此外，值得注意的是，Bazel 不是由苹果维护的第三方工具。因此，当苹果在Xcode构建系统中推出新的特性或功能时，那么<a class="ae lh" href="https://bazel.build" rel="noopener ugc nofollow" target="_blank"> Bazel </a>将需要由开源社区进行更新。例如，M1 Mac于2020年11月推出，但Bazel only <a class="ae lh" href="https://github.com/bazelbuild/bazel/releases/tag/5.0.0" rel="noopener ugc nofollow" target="_blank">于2022年1月</a>全面支持它。</p><p id="9a7b" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">此外，你还依赖于Bazel社区来保持教程和其他资源的更新。在撰写bazel.build的iOS教程<a class="ae lh" href="https://docs.bazel.build/versions/main/tutorial/ios-app.html" rel="noopener ugc nofollow" target="_blank">时</a>指向了近3年前的苹果规则模块。<a class="ae lh" href="https://docs.bazel.build/versions/main/tutorial/ios-app.html" rel="noopener ugc nofollow" target="_blank">这个教程</a>坏了，不管用。</p><p id="27c8" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">以下是避免使用<a class="ae lh" href="https://bazel.build" rel="noopener ugc nofollow" target="_blank"> Bazel </a>的原因总结:</p><ul class=""><li id="0774" class="me mf it lk b ll lm lo lp lr mg lv mh lz mi md pl mk ml mm bi translated">需要学习和维护的新工具和语言</li><li id="d6f2" class="me mf it lk b ll mn lo mo lr mp lv mq lz mr md pl mk ml mm bi translated">对最新Apple特性和功能的支持缓慢</li><li id="8cf3" class="me mf it lk b ll mn lo mo lr mp lv mq lz mr md pl mk ml mm bi translated">糟糕的文档</li></ul></div><div class="ab cl mt mu hx mv" role="separator"><span class="mw bw bk mx my mz"/><span class="mw bw bk mx my mz"/><span class="mw bw bk mx my"/></div><div class="im in io ip iq"><h1 id="bb07" class="na nb it bd nc nd ne nf ng nh ni nj nk ki nl kj nm kl nn km no ko np kp nq nr bi translated">摘要</h1><p id="3647" class="pw-post-body-paragraph li lj it lk b ll ns kd ln lo nt kg lq lr nu lt lu lv nv lx ly lz nw mb mc md im bi translated">在这篇文章中，我们了解到:</p><ul class=""><li id="b47e" class="me mf it lk b ll lm lo lp lr mg lv mh lz mi md pl mk ml mm bi translated">什么是<a class="ae lh" href="https://bazel.build" rel="noopener ugc nofollow" target="_blank">巴泽尔</a></li><li id="9a1b" class="me mf it lk b ll mn lo mo lr mp lv mq lz mr md pl mk ml mm bi translated">如何迁移现有应用程序以使用<a class="ae lh" href="https://bazel.build" rel="noopener ugc nofollow" target="_blank"> Bazel </a></li><li id="a979" class="me mf it lk b ll mn lo mo lr mp lv mq lz mr md pl mk ml mm bi translated">如何在<a class="ae lh" href="https://bazel.build" rel="noopener ugc nofollow" target="_blank"> Bazel </a>中远程缓存构建</li><li id="0726" class="me mf it lk b ll mn lo mo lr mp lv mq lz mr md pl mk ml mm bi translated">什么时候不用<a class="ae lh" href="https://bazel.build" rel="noopener ugc nofollow" target="_blank">巴泽尔</a></li></ul><h1 id="f318" class="na nb it bd nc nd pe nf ng nh pf nj nk ki pg kj nm kl ph km no ko pi kp nq nr bi translated">最后的想法</h1><p id="4109" class="pw-post-body-paragraph li lj it lk b ll ns kd ln lo nt kg lq lr nu lt lu lv nv lx ly lz nw mb mc md im bi translated">我在这篇文章中提到了使用<a class="ae lh" href="https://bazel.build" rel="noopener ugc nofollow" target="_blank">巴泽尔</a>的缺点。使用<a class="ae lh" href="https://bazel.build" rel="noopener ugc nofollow" target="_blank"> Bazel </a>的公司是那些拥有大型iOS应用项目的公司，这些项目的模块数量在10个甚至100个模块上。在这些项目中，使用Bazel的影响更有可能超过实现和维护它的努力。</p><p id="891d" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">需要注意的是，Bazel 可能需要一些努力。你会发现开发者<a class="ae lh" href="https://twitter.com/kocienda/status/1425909869345869825?s=20&amp;t=pqxryzo13lbVwrgIcV3Lyw" rel="noopener ugc nofollow" target="_blank">经常在推特上谈论这个</a>。</p><p id="f83c" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">为了加快构建时间，Bazel 还有其他选择。一个这样的选择是<a class="ae lh" href="https://medium.com/better-programming/generating-xcodeprojs-with-tuist-4f11134e9f5a" rel="noopener"> Tuist </a>。使用Tuist，开发者需要决定在哪些模块上工作，并使用缓存来处理其余的模块。<a class="ae lh" href="https://medium.com/better-programming/generating-xcodeprojs-with-tuist-4f11134e9f5a" rel="noopener"> Tuist </a>用Swift配置和编写，围绕Xcode工作。因此，iOS开发者很容易管理和维护它。如果你有兴趣了解更多关于Tuist的知识，请查看我的教程。</p><pre class="ks kt ku kv gt oj ok ol om aw on bi"><span id="a1ab" class="nx nb it ok b gy oo op l oq or"><strong class="ok jd">Want to Connect?</strong></span><span id="0608" class="nx nb it ok b gy pc op l oq or">For more on iOS development follow me on <a class="ae lh" href="https://twitter.com/anuragajwani?source=post_page---------------------------" rel="noopener ugc nofollow" target="_blank">Twitter</a>!</span></pre></div></div>    
</body>
</html>