<html>
<head>
<title>Improving Item Collection in a JavaScript Game</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">改进JavaScript游戏中的物品收集</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/improving-item-collection-in-a-javascript-game-2be45bafe01d?source=collection_archive---------18-----------------------#2022-08-22">https://betterprogramming.pub/improving-item-collection-in-a-javascript-game-2be45bafe01d?source=collection_archive---------18-----------------------#2022-08-22</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="0dc3" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">让我们的碰撞检测精确到像素。</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/8fcd5e02631957648ee3304519d3eb2e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*prgc4ZWjyMdDiy_y6vbH-A.jpeg"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">图片由<a class="ae ky" href="https://www.freepik.com/author/pch-vector" rel="noopener ugc nofollow" target="_blank"> pch.vector </a>在<a class="ae ky" href="https://freepik.com" rel="noopener ugc nofollow" target="_blank"> freepik </a>上</p></figure><p id="88e3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在过去的几个月里，我一直在逐步构建一个JavaScript地牢爬虫，它的特点是玩家在自动生成的洞穴迷宫中移动。当与敌人战斗时，玩家可以收集健康药水和武器——当危险发生时，玩家必须快速抓住它们。</p><p id="56ee" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">帮助玩家尽可能快地抓取物品依赖于有效的碰撞检测。在早期版本中，玩家必须站在物品的正上方才能收集物品。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="lv lw l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">基于图块的碰撞检测</p></figure><p id="3c64" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在改进代码后，我终于让游戏达到了玩家只需触摸一小部分就可以收集物品的地步。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="lv lw l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">像素级碰撞检测</p></figure><p id="8738" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">本文主要讨论如何使用普通JavaScript提高基于图块的游戏中碰撞检测的准确性。</p></div><div class="ab cl lx ly hx lz" role="separator"><span class="ma bw bk mb mc md"/><span class="ma bw bk mb mc md"/><span class="ma bw bk mb mc"/></div><div class="im in io ip iq"><h1 id="9998" class="me mf it bd mg mh mi mj mk ml mm mn mo jz mp ka mq kc mr kd ms kf mt kg mu mv bi translated">瓷砖的作用</h1><p id="f6e9" class="pw-post-body-paragraph kz la it lb b lc mw ju le lf mx jx lh li my lk ll lm mz lo lp lq na ls lt lu im bi translated">游戏总是由瓷砖组成，虽然玩家可以在瓷砖之间顺利移动，但每个项目都与其所在的瓷砖完美对齐。在这里，我们利用这一点，检测玩家在什么牌上，以及这些牌上是否有物品。</p><p id="0b0f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">游戏地图是数字代码的2D阵列。根据下面的按键，每个代码对应一个特定的瓷砖。</p><pre class="kj kk kl km gt nb nc nd ne aw nf bi"><span id="1576" class="ng mf it nc b gy nh ni l nj nk">const WALL_CODE = 0;<br/>const FLOOR_CODE = 1;<br/>const POTION_CODE = 4;<br/>const WEAPON_CODE = 5;</span></pre><p id="6980" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">2D数组中的每一项都有一个特定的索引，可以认为是它在平铺地图中的(x，y)坐标。在下面的示例中，用0表示的第一个墙砖位于坐标(0，0)处。第二个墙砖位于坐标(2，2)处。</p><pre class="kj kk kl km gt nb nc nd ne aw nf bi"><span id="1eff" class="ng mf it nc b gy nh ni l nj nk">(0,0)<br/>  |<br/>[[0,1,1]<br/> [1,1,1]<br/> [1,1,0] &lt;-- (2,2)</span></pre><p id="2a96" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在我最近的游戏中，每个方块的长度和宽度都是32像素。我将这个数字存储在一个名为<code class="fe nl nm nn nc b">TILE_DIM</code>的常量中，我用这个常量在地图的图块索引和像素坐标之间进行转换。我们将在下一个例子中看到这是如何工作的。</p></div><div class="ab cl lx ly hx lz" role="separator"><span class="ma bw bk mb mc md"/><span class="ma bw bk mb mc md"/><span class="ma bw bk mb mc"/></div><div class="im in io ip iq"><h1 id="3ba5" class="me mf it bd mg mh mi mj mk ml mm mn mo jz mp ka mq kc mr kd ms kf mt kg mu mv bi translated">找到玩家所在的牌</h1><p id="29d4" class="pw-post-body-paragraph kz la it lb b lc mw ju le lf mx jx lh li my lk ll lm mz lo lp lq na ls lt lu im bi translated"><code class="fe nl nm nn nc b">player</code>对象是一个<code class="fe nl nm nn nc b">coords</code>属性，它以像素为单位存储它的(x，y)坐标。我们可以使用下面的一个简单方法找到玩家最匹配的牌的数组索引。这被称为玩家的<em class="no">当前牌。</em></p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="np lw l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">当前磁贴。</p></figure><p id="8e84" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在，一个玩家不能被均匀地放置在四张牌上吗？当然可以。在这种情况下，由于玩家的坐标向上舍入的方式，右下角的图块成为当前图块。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi nq"><img src="../Images/5f406244ccfe12c7768c59467efac1e8.png" data-original-src="https://miro.medium.com/v2/resize:fit:322/format:webp/1*dtRycTWfYXbHYmqheXUR5g.png"/></div></figure><p id="5374" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在我们可以识别玩家所在的瓷砖，让我们看看如何让它检查与周围瓷砖的碰撞。</p></div><div class="ab cl lx ly hx lz" role="separator"><span class="ma bw bk mb mc md"/><span class="ma bw bk mb mc md"/><span class="ma bw bk mb mc"/></div><div class="im in io ip iq"><h1 id="db71" class="me mf it bd mg mh mi mj mk ml mm mn mo jz mp ka mq kc mr kd ms kf mt kg mu mv bi translated">识别周围的瓷砖</h1><p id="07b0" class="pw-post-body-paragraph kz la it lb b lc mw ju le lf mx jx lh li my lk ll lm mz lo lp lq na ls lt lu im bi translated">在任何给定时间，玩家通常被八个其他牌包围。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi nr"><img src="../Images/e9eb8dbbcdec2487ce0e49529193e401.png" data-original-src="https://miro.medium.com/v2/resize:fit:482/format:webp/1*9IwA1vegrmMSzI2jgGYs5A.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">玩家和周围的牌。</p></figure><p id="1c8b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">下面，玩家开始离开他一直停留的黄色方块。因为它仍然与这张牌重叠最多，所以游戏认为它是玩家的当前牌。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi nr"><img src="../Images/05c609c56a3d5ad0e7b58d49badfbcdf.png" data-original-src="https://miro.medium.com/v2/resize:fit:482/format:webp/1*h4Pcb_rn_Y2nxZF2eYVEyg.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">玩家开始离开当前的牌。</p></figure><p id="55c5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">假设在玩家上方的右边有一个物品。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi nr"><img src="../Images/1ed8cc1f6e27f58ed3e42c531ff0329d.png" data-original-src="https://miro.medium.com/v2/resize:fit:482/format:webp/1*E2XKoZqJVfYnrFOqoH4OLA.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">玩家用一个物品触摸一个方块。</p></figure><p id="a768" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这里的目标是检查玩家和物品之间的重叠。我们可以通过检查玩家周围的瓷砖来做到这一点。让我们给它们标上坐标</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi nr"><img src="../Images/08448c4c036d5949345f62ee82fdd022.png" data-original-src="https://miro.medium.com/v2/resize:fit:482/format:webp/1*4yjKaTWxwxZTO5wiCG3uDA.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">每个周围单幅图块的相对坐标。</p></figure><p id="d456" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">因为这些坐标都是相对于玩家位置的，我们姑且称之为<em class="no">相对坐标。</em>要获得相邻图块的数组索引，我们可以使用下面的方法<code class="fe nl nm nn nc b">adjacentTileIndices</code>，该方法将一组相对坐标作为参数。</p><pre class="kj kk kl km gt nb nc nd ne aw nf bi"><span id="6f56" class="ng mf it nc b gy nh ni l nj nk">Player.prototype.adjacentTileIndices = function({x,y}) {<br/>    let tile = this.curTileCoords();</span><span id="eecd" class="ng mf it nc b gy ns ni l nj nk">    tile.x += x;<br/>    tile.y += y;</span><span id="91a4" class="ng mf it nc b gy ns ni l nj nk">    return tile;<br/>}</span></pre><p id="8ba7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">因此，为了获得右上角的图块的数组索引，我们调用以下方法:</p><pre class="kj kk kl km gt nb nc nd ne aw nf bi"><span id="ca82" class="ng mf it nc b gy nh ni l nj nk">player.adjacentTileIndices({x:1,y:-1})</span></pre><p id="dd73" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">因为游戏不存储物品的位置，所以最好在玩家移动时检查周围的物品。给定下面的相对坐标…</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi nr"><img src="../Images/6406478660beb4985f4dc8b8ae88b44e.png" data-original-src="https://miro.medium.com/v2/resize:fit:482/format:webp/1*6K-KrF7Adn1EcblQyNjGQQ.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">相对坐标</p></figure><p id="3aa0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">…我们可以想出一系列数字来在<code class="fe nl nm nn nc b">x</code>和<code class="fe nl nm nn nc b">y</code>轴上测试。</p><pre class="kj kk kl km gt nb nc nd ne aw nf bi"><span id="cbc0" class="ng mf it nc b gy nh ni l nj nk">const range = [-1,0,1];</span></pre><p id="91bb" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">理论上，我们可以使用嵌套循环遍历所有九组图块坐标。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nt"><img src="../Images/575fa1edc7a9ee7c591ccef50144e710.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*LJsCH3NrUIeAcQ-7nacn9g.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">我们可以假设这样做。</p></figure><p id="afed" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">但是等等！我们不应该检查所有的九张牌，因为玩家最多只能有四张牌。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi nr"><img src="../Images/94ab6ba6a393c6aacae985ba1c3c8080.png" data-original-src="https://miro.medium.com/v2/resize:fit:482/format:webp/1*M8wKKpCrORN1Qluh3LDpFg.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">玩家不在五张牌上。</p></figure><p id="5725" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">因此，更有效的方法是识别玩家所在的图块，仅遍历这些图块，并查看每个图块上是否有项目。</p><p id="acc5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">为了实现这一点，让我们编写一些帮助器方法来检查一个玩家是否与它当前的图块完全对齐。如果它<em class="no">没有</em>完全对齐，我们识别出它正在侵占哪些瓷砖。(如果这些牌有物品，则玩家收集该物品。)</p></div><div class="ab cl lx ly hx lz" role="separator"><span class="ma bw bk mb mc md"/><span class="ma bw bk mb mc md"/><span class="ma bw bk mb mc"/></div><div class="im in io ip iq"><h1 id="e382" class="me mf it bd mg mh mi mj mk ml mm mn mo jz mp ka mq kc mr kd ms kf mt kg mu mv bi translated">查找与当前图块的距离</h1><p id="d3a2" class="pw-post-body-paragraph kz la it lb b lc mw ju le lf mx jx lh li my lk ll lm mz lo lp lq na ls lt lu im bi translated">现在让我们使用我们所拥有的助手来找出这个层已经偏离它当前的图块有多远。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="np lw l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">查找当前图块距离。</p></figure><p id="a6cf" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在上面的方法中，我们首先根据<code class="fe nl nm nn nc b">axis</code>参数获得玩家的<code class="fe nl nm nn nc b">x</code>或<code class="fe nl nm nn nc b">y</code>坐标。</p><pre class="kj kk kl km gt nb nc nd ne aw nf bi"><span id="2f6e" class="ng mf it nc b gy nh ni l nj nk">let coord = this.coords[axis];</span></pre><p id="de94" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">然后我们除以<code class="fe nl nm nn nc b">TILE_DIM</code>并取整得到它在游戏地图数组中的<code class="fe nl nm nn nc b">x</code>或<code class="fe nl nm nn nc b">y</code>索引。</p><pre class="kj kk kl km gt nb nc nd ne aw nf bi"><span id="e64b" class="ng mf it nc b gy nh ni l nj nk">let tileCoords = Math.round(coord / TILE_DIM);</span></pre><p id="423f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在，让我们将它乘以<code class="fe nl nm nn nc b">TILE_DIM</code>以获得图块的<code class="fe nl nm nn nc b">x</code>或<code class="fe nl nm nn nc b">y</code>坐标，单位为像素。</p><pre class="kj kk kl km gt nb nc nd ne aw nf bi"><span id="96a8" class="ng mf it nc b gy nh ni l nj nk">let pixelTileCoord = tileCoord*TILE_DIM;</span></pre><p id="9cd4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">完成后，我们找到玩家位置和瓷砖位置之间的像素差异。</p><pre class="kj kk kl km gt nb nc nd ne aw nf bi"><span id="3723" class="ng mf it nc b gy nh ni l nj nk">const diff = coord - pixelTileCoords;</span><span id="6f06" class="ng mf it nc b gy ns ni l nj nk">return diff;</span></pre><h2 id="7f29" class="ng mf it bd mg nu nv dn mk nw nx dp mo li ny nz mq lm oa ob ms lq oc od mu oe bi translated">你站在哪一边？</h2><p id="1c80" class="pw-post-body-paragraph kz la it lb b lc mw ju le lf mx jx lh li my lk ll lm mz lo lp lq na ls lt lu im bi translated">对于每个轴，我们可以调用下面的这个助手来查看玩家在瓷砖的哪一侧。如果像素数不为零，这意味着玩家正漫游到相邻的图块上。</p><pre class="kj kk kl km gt nb nc nd ne aw nf bi"><span id="7e85" class="ng mf it nc b gy nh ni l nj nk">Player.prototype.tileSide = function(axis) {<br/>    let dist = this.curTileDist(axis);</span><span id="1166" class="ng mf it nc b gy ns ni l nj nk">    return (dist == 0) ? dist : Math.round(dist/Math.abs(dist));<br/>}</span></pre><p id="2267" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们仔细看看上面的方法。首先，我们得到玩家与其当前图块的距离。</p><pre class="kj kk kl km gt nb nc nd ne aw nf bi"><span id="0b4f" class="ng mf it nc b gy nh ni l nj nk">let dist = this.curTileDist(axis);</span></pre><p id="ab2c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">因为除以零将是灾难性的，如果它是零，我们简单地返回<code class="fe nl nm nn nc b">dist</code>。如果它不是零，我们根据它的符号使它成为<code class="fe nl nm nn nc b">1</code>或<code class="fe nl nm nn nc b">-1</code>。</p><pre class="kj kk kl km gt nb nc nd ne aw nf bi"><span id="2b76" class="ng mf it nc b gy nh ni l nj nk">return (dist == 0) ? dist : Math.round(dist/Math.abs(dist));</span></pre><p id="c0ea" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">所以对于<code class="fe nl nm nn nc b">x</code>轴，<code class="fe nl nm nn nc b">tileSide</code>方法将返回三个值之一:</p><ul class=""><li id="ceb8" class="of og it lb b lc ld lf lg li oh lm oi lq oj lu ok ol om on bi translated"><code class="fe nl nm nn nc b">-1</code>如果玩家重叠了左边的牌</li><li id="017c" class="of og it lb b lc oo lf op li oq lm or lq os lu ok ol om on bi translated"><code class="fe nl nm nn nc b">0</code>如果玩家与其当前牌水平对齐</li><li id="2ab0" class="of og it lb b lc oo lf op li oq lm or lq os lu ok ol om on bi translated"><code class="fe nl nm nn nc b">1</code>如果方块与右边的方块重叠</li></ul><p id="435d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">对于<code class="fe nl nm nn nc b">y</code>轴，<code class="fe nl nm nn nc b">tileSide</code>将返回以下内容之一:</p><ul class=""><li id="7c18" class="of og it lb b lc ld lf lg li oh lm oi lq oj lu ok ol om on bi translated"><code class="fe nl nm nn nc b">-1</code>如果玩家重叠了上面的牌</li><li id="48f9" class="of og it lb b lc oo lf op li oq lm or lq os lu ok ol om on bi translated"><code class="fe nl nm nn nc b">0</code>如果玩家与其当前牌垂直对齐</li><li id="436a" class="of og it lb b lc oo lf op li oq lm or lq os lu ok ol om on bi translated"><code class="fe nl nm nn nc b">1</code>如果图块与下面的图块重叠</li></ul><p id="358c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">然后在下面的方法中使用这个<code class="fe nl nm nn nc b">tileSide</code>方法，该方法获取玩家相对于一个图块的位置，并添加我们应该检查的图块的相对坐标。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="np lw l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">如果玩家没有在给定的轴上对齐其牌，此方法会添加一个坐标1或-1。</p></figure><p id="3e24" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">对于<code class="fe nl nm nn nc b">x</code>和<code class="fe nl nm nn nc b">y</code>，变量<code class="fe nl nm nn nc b">arr</code>从包含<code class="fe nl nm nn nc b">0</code>开始，因为我们应该总是检查相对坐标<code class="fe nl nm nn nc b">(0,0)</code>，它是玩家所在的区块。</p><pre class="kj kk kl km gt nb nc nd ne aw nf bi"><span id="a94d" class="ng mf it nc b gy nh ni l nj nk">let arr = [0];</span></pre><p id="5af9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">注意<code class="fe nl nm nn nc b">tileSide</code>的返回值是<code class="fe nl nm nn nc b">sideVal</code>。</p><pre class="kj kk kl km gt nb nc nd ne aw nf bi"><span id="92e3" class="ng mf it nc b gy nh ni l nj nk">let sideVal = this.tileSide(axis);</span></pre><ul class=""><li id="9e46" class="of og it lb b lc ld lf lg li oh lm oi lq oj lu ok ol om on bi translated">在<code class="fe nl nm nn nc b">x</code>轴上，<code class="fe nl nm nn nc b">sideVal</code>为左，<code class="fe nl nm nn nc b">-1</code>为右。</li><li id="f2a0" class="of og it lb b lc oo lf op li oq lm or lq os lu ok ol om on bi translated">在<code class="fe nl nm nn nc b">y</code>轴上，<code class="fe nl nm nn nc b">sideVal</code>在上方，<code class="fe nl nm nn nc b">-1</code>在下方。</li></ul><p id="5410" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在让我们看看<code class="fe nl nm nn nc b">tilePositions</code>是如何被用来检查玩家的相邻牌的。</p></div><div class="ab cl lx ly hx lz" role="separator"><span class="ma bw bk mb mc md"/><span class="ma bw bk mb mc md"/><span class="ma bw bk mb mc"/></div><div class="im in io ip iq"><h1 id="6583" class="me mf it bd mg mh mi mj mk ml mm mn mo jz mp ka mq kc mr kd ms kf mt kg mu mv bi translated">检查周围的瓷砖</h1><p id="c283" class="pw-post-body-paragraph kz la it lb b lc mw ju le lf mx jx lh li my lk ll lm mz lo lp lq na ls lt lu im bi translated">然后在下面的“大图”函数中使用<code class="fe nl nm nn nc b">tilePositions</code>方法，找到玩家所在的方块并检查上面的物品。注意，它被调用了两次——每个轴一次。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="np lw l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">checkSurround方法</p></figure><p id="b925" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们把这个分解一下。首先，我们得到玩家的瓷砖坐标。</p><pre class="kj kk kl km gt nb nc nd ne aw nf bi"><span id="e025" class="ng mf it nc b gy nh ni l nj nk">const cur = this.curTileCoords();</span></pre><p id="b806" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">然后我们定义一个<code class="fe nl nm nn nc b">range</code>对象，它存储每个轴要检查的位置。</p><pre class="kj kk kl km gt nb nc nd ne aw nf bi"><span id="3182" class="ng mf it nc b gy nh ni l nj nk">let range = {<br/>        x:this.tilePositions('x'),<br/>        y:this.tilePositions('y')<br/>};</span></pre><p id="d41b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果玩家完全对齐，那么<code class="fe nl nm nn nc b">range</code>就是<code class="fe nl nm nn nc b">{x:[0] ,y:[0]}</code>，因为只有一张牌需要检查。</p><p id="bc3d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">但是如果玩家在下面的位置…</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi nr"><img src="../Images/c5d2f918ed930054931ccfc0cac32d10.png" data-original-src="https://miro.medium.com/v2/resize:fit:482/format:webp/1*YO0z-9uHi8CRYy-7N-jUXg.png"/></div></figure><p id="1387" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">…对<code class="fe nl nm nn nc b">tilePositions</code>的两次调用产生的<code class="fe nl nm nn nc b">range</code>对象如下所示:</p><pre class="kj kk kl km gt nb nc nd ne aw nf bi"><span id="ec04" class="ng mf it nc b gy nh ni l nj nk">{<br/>   x:[0, 1],<br/>   y:[0,-1]<br/>}</span></pre><p id="6af6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">结果，只有玩家所在的四个牌被检查:<code class="fe nl nm nn nc b">(0, 0)</code>、<code class="fe nl nm nn nc b">(1, 0)</code>、<code class="fe nl nm nn nc b">(1, -1)</code>和<code class="fe nl nm nn nc b">(0, -1)</code>。</p><p id="7f82" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在进入循环之前，我们先建立应该在2D地图数组中检查的物品代码的类型。</p><pre class="kj kk kl km gt nb nc nd ne aw nf bi"><span id="626d" class="ng mf it nc b gy nh ni l nj nk">const itemCodes = [POTION_CODE, WEAPON_CODE];</span></pre><p id="947f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">然后，我们可以设置嵌套循环:</p><pre class="kj kk kl km gt nb nc nd ne aw nf bi"><span id="b870" class="ng mf it nc b gy nh ni l nj nk">for (let y of range.y) {</span><span id="7a04" class="ng mf it nc b gy ns ni l nj nk">   for (let x of range.x) {<br/>       <br/>       // check the tile at (x,y)<br/>       // if it's an item, collect it</span><span id="09d3" class="ng mf it nc b gy ns ni l nj nk">   }<br/>}</span></pre><p id="791c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在循环中，我们得到被检查的瓷砖的数组索引。</p><pre class="kj kk kl km gt nb nc nd ne aw nf bi"><span id="c6c9" class="ng mf it nc b gy nh ni l nj nk">const coords = this.adjacentTileIndices({x,y});</span></pre><p id="cff0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">然后，我们在<code class="fe nl nm nn nc b">game</code>地图中识别图块。</p><pre class="kj kk kl km gt nb nc nd ne aw nf bi"><span id="4481" class="ng mf it nc b gy nh ni l nj nk">let tileCode = game.map[coords.y][coords.x];</span></pre><p id="ec09" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">还记得<code class="fe nl nm nn nc b">itemCodes</code>阵吗？</p><pre class="kj kk kl km gt nb nc nd ne aw nf bi"><span id="864b" class="ng mf it nc b gy nh ni l nj nk">[POTION_CODE, WEAPON_CODE];</span></pre><p id="3a13" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果<code class="fe nl nm nn nc b">tileCode</code>包含在<code class="fe nl nm nn nc b">itemCodes</code>数组中，我们调用一个<code class="fe nl nm nn nc b">grabItem</code>函数并收集它。这会增加玩家的生命值</p><pre class="kj kk kl km gt nb nc nd ne aw nf bi"><span id="5355" class="ng mf it nc b gy nh ni l nj nk">if (itemCodes.includes(tileCode)) {<br/>       grabItem(tileCode, coords);<br/>}</span></pre><p id="31ec" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">关于<code class="fe nl nm nn nc b">grabItem</code>你只需要知道它会改变玩家的属性，并从游戏地图中移除物品。如果是健康药剂，玩家的生命值会一直上升，直到达到最大值。如果是武器，玩家获得它。</p><p id="bbc2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">你可以在这个<a class="ae ky" href="https://roguelike-smooth.netlify.app/demo-10-items/index.html" rel="noopener ugc nofollow" target="_blank">演示</a>中看到这个逻辑在起作用。</p></div><div class="ab cl lx ly hx lz" role="separator"><span class="ma bw bk mb mc md"/><span class="ma bw bk mb mc md"/><span class="ma bw bk mb mc"/></div><div class="im in io ip iq"><h1 id="9e1c" class="me mf it bd mg mh mi mj mk ml mm mn mo jz mp ka mq kc mr kd ms kf mt kg mu mv bi translated">概述</h1><p id="68fd" class="pw-post-body-paragraph kz la it lb b lc mw ju le lf mx jx lh li my lk ll lm mz lo lp lq na ls lt lu im bi translated">以下是你需要记住的一些要点:</p><ul class=""><li id="cdbb" class="of og it lb b lc ld lf lg li oh lm oi lq oj lu ok ol om on bi translated"><code class="fe nl nm nn nc b">TILE_DIM</code>常量允许我在2D数组索引和像素坐标之间切换。</li><li id="8e7f" class="of og it lb b lc oo lf op li oq lm or lq os lu ok ol om on bi translated">玩家通常被八个牌包围。</li><li id="d866" class="of og it lb b lc oo lf op li oq lm or lq os lu ok ol om on bi translated">我们构建了一些小的辅助函数来计算玩家在哪个方块上。</li><li id="0733" class="of og it lb b lc oo lf op li oq lm or lq os lu ok ol om on bi translated">使用一个<code class="fe nl nm nn nc b">range</code>对象，我们收集要检查的图块的坐标。</li><li id="502a" class="of og it lb b lc oo lf op li oq lm or lq os lu ok ol om on bi translated">如果这些瓦片中的任何一个变成了一个项目，该项目将被收集。</li></ul><p id="424e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">对于与瓷砖完美对齐的物品，我们可以利用玩家的瓷砖对齐程度来确定应该检查的瓷砖。这有助于保持高效的冲突检测。</p><div class="ot ou gp gr ov ow"><a rel="noopener  ugc nofollow" target="_blank" href="/creating-a-game-loop-in-javascript-4b4d51c18f67"><div class="ox ab fo"><div class="oy ab oz cl cj pa"><h2 class="bd iu gy z fp pb fr fs pc fu fw is bi translated">用JavaScript创建游戏循环</h2><div class="pd l"><h3 class="bd b gy z fp pb fr fs pc fu fw dk translated">让我们用一个循环的过程来平滑玩家的移动。</h3></div><div class="pe l"><p class="bd b dl z fp pb fr fs pc fu fw dk translated">better编程. pub</p></div></div><div class="pf l"><div class="pg l ph pi pj pf pk ks ow"/></div></div></a></div></div></div>    
</body>
</html>