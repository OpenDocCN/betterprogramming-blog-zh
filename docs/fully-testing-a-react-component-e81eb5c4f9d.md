# 如何全面测试 React 组件

> 原文：<https://betterprogramming.pub/fully-testing-a-react-component-e81eb5c4f9d>

## 可测试的代码是好代码

![](img/1da35ad08c08d4ad4f3e60d2fbdffc2a.png)

照片由 [Omer Rana](https://unsplash.com/@omerrana?utm_source=medium&utm_medium=referral) 在 [Unsplash](https://unsplash.com?utm_source=medium&utm_medium=referral) 上拍摄

我在 React.js 的很多测试教程中看到的东西是正在测试的组件，但有些东西被忽略了。或者更糟，完全依赖快照测试，它不能测试所有的东西。开发人员经常在更改后更新快照，甚至不看快照表示中发生了什么变化(我在专业上也见过这种情况！).所以，如果你有很多 React 和测试 React 代码的质量经验，你最好跳过这一步去读别的。但是如果你有任何空白，请继续阅读！

我们将在本教程中使用`create-react-app`，因为这是一种简单的入门方式，并且已经提供了对通用测试库的支持:`jest`。运行完`npx create-react-app my-project`后，我编辑了`src/App.js`文件，如下所示:

该组件呈现一个输入，用户可以输入一个神奇宝贝的名字，然后在点击搜索按钮后看到神奇宝贝的图像。以下是三种主要的用户流:

1.  用户输入一个神奇宝贝的正确名称并点击搜索按钮，然后在屏幕上查看神奇宝贝的图像。
2.  用户输入了不正确的名称，但在屏幕上看到一个错误。
3.  用户没有在输入中输入任何内容，而是单击了 search 按钮，然后看到一个错误，要求用户首先键入姓名。

`getPokemon`功能基本上只是使用原生的`fetch`功能，通过使用[免费神奇宝贝 API](https://pokeapi.co/) 按名称检索一个神奇宝贝。该文件如下所示:

```
// API.jsexport const getPokemon = name =>
  fetch(`https://pokeapi.co/api/v2/pokemon/${name}`)
    .then(res => res.json());
```

现在让我们为组件编写一个测试。为此，我们可以通过以下方式将`enzyme`添加到我们的项目中:

```
npm i --save-dev enzyme enzyme-adapter-react-16
```

让我们使用`create-react-app`已经为我们建立的测试文件。为了使事情更简单，我简单地在同一个文件中配置了`enzyme`,然后编写了一个简单的测试来覆盖第一个用例

# 用户流#1

## 用户输入一个神奇宝贝的正确名称并点击搜索按钮，然后在屏幕上查看神奇宝贝的图像

这里的测试模拟了 API，所以我们在测试过程中实际上不必触及 API。当你在开发时，依赖 API 是不切实际的，这也是“关注点分离”的一个很好的实践。

我们刚刚编写的测试确保用户输入的内容用于获取相关的神奇宝贝。这是可以的，但我们不是在测试整个流程。我们还必须确保用户不会收到错误，而是看到一个图像，并且该图像与他们在响应中收到的图像相同。在我们的例子中，我们伪造了这个响应，并在我们的`describe`块中保持图像路径在`randomImagePath` const 中。然而，为了等待 API 的结果，我们必须将测试转换成异步测试— `Promise`对象是异步操作的表示。然后，我们还必须创建一个助手函数，帮助我们等待承诺的解决。显然，在我们的例子中，我们立即解析了承诺，但是我们仍然必须等待一个滴答过去，以便 JavaScript 可以执行下一个操作。这是测试之后的样子:

现在，我们不仅断言使用用户输入调用了`getPokemon`函数，而且我们还可以测试在被模仿的`getPokemon` API 调用解析后，没有错误，页面上的一个图像标签使用了来自 API 响应的正确 URL。

因此，在这个测试用例之后，我们可以确保之前描述的第一个用例得到了充分的测试。让我们进入下一个测试。

# 用户流#2

## 用户输入了不正确的名称，但在屏幕上看到一个错误

为了测试这一点，我们必须模拟我们的 spy 函数到`reject`的实现，而不是解析。完成之后，我们可以简单地断言页面上有一个错误，并且该错误的文本是正确的。在第一个测试下面添加了另一个测试后，我们的`App.test.js`文件如下所示:

这个测试非常简单明了。请注意，我们已经通过移动测试本身中 API 调用的`mockImplementation`部分进行了调整，并在每次测试后恢复模拟，因此测试之间没有干扰。

# 用户流#3

## 用户没有在输入中输入任何内容，而是单击了 search 按钮，然后看到一个错误，要求用户首先键入姓名

这个测试用例比其他的稍微短一点。添加最后一个测试后，我们的文件现在看起来像这样:

除了断言错误以正确的文本显示之外，我们还断言`API`函数`getPokemon`从未被调用，因此节省了一个不必要的 API 调用。如果将来某个开发人员决定改变这种行为，这个测试将会中断并给他们提供一个提示。

# 继续前进

如果您想测试自己，还有一个小功能没有测试。对于第一个用例，我们当前的 React 组件在收到来自 Pokemon API 的成功响应后也会清除输入。然而，这不是我们目前的第一个测试，所以您可以修改它，以包括这个`expect`断言。

# 结论

所有这些测试都足够了吗？不，我们仍然应该进行快照测试，以确保组件结构不会被开发人员有意更改。此外，我们测试流程中的一个主要缺口是我们没有测试过`getPokemon`函数。但这是有意的，本文只是关于测试 React 组件和分离所有其他代码。正确的单元测试是小型的，只测试一段代码。这不是不测试其他代码的借口，而是鼓励为它们建立单独的单元测试文件。API 调用测试非常简单，使用`axios`和`axios-mock-adapter`可以进一步简化。也许我们会在另一篇文章中讨论这个问题。下次见！