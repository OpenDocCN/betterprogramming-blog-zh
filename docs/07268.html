<html>
<head>
<title>The 4 Creational Design Patterns in Node.js That You Should Know</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">你应该知道的Node.js中的4个创新设计模式</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/the-4-creational-design-patterns-in-node-js-that-you-should-know-cfb7ed77a84e?source=collection_archive---------1-----------------------#2020-12-28">https://betterprogramming.pub/the-4-creational-design-patterns-in-node-js-that-you-should-know-cfb7ed77a84e?source=collection_archive---------1-----------------------#2020-12-28</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="3c73" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">了解单例、工厂、构建器和原型模式</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/336ae6ab4dfe987152a80f53d3a2bb77.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*I7VpuiD7G_BsTPXG"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk">Photo by <a class="ae kv" href="https://unsplash.com/@danist07?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">贝莉儿 DANIST</a> on <a class="ae kv" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a>.</p></figure><p id="8cde" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">首先，我们先来解释一下什么是设计模式。简而言之，它们允许我们重用代码来解决重复出现的问题。我们可以重用已经有效的代码，而不是一次又一次地解决同样的问题。</p><p id="1919" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">为什么要使用设计模式？以下是一些很好的理由:</p><ul class=""><li id="b64e" class="ls lt iq ky b kz la lc ld lf lu lj lv ln lw lr lx ly lz ma bi translated">它们被很好地记录和测试。</li><li id="f5ef" class="ls lt iq ky b kz mb lc mc lf md lj me ln mf lr lx ly lz ma bi translated">它们在许多不同的情况下都是可重用的。</li><li id="c270" class="ls lt iq ky b kz mb lc mc lf md lj me ln mf lr lx ly lz ma bi translated">他们很有效率。</li><li id="4a6f" class="ls lt iq ky b kz mb lc mc lf md lj me ln mf lr lx ly lz ma bi translated">他们会节省你的时间。</li></ul><p id="e84a" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">值得注意的是，这些模式是通用的，这意味着它们适用于其他编程语言/框架/库。然而，在本文中，我们将使用Node.js来实现和理解它们。</p><p id="1764" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">有三种类型的设计模式:</p><ol class=""><li id="da2f" class="ls lt iq ky b kz la lc ld lf lu lj lv ln lw lr mg ly lz ma bi translated">创建—对象实例的创建</li><li id="f9e2" class="ls lt iq ky b kz mb lc mc lf md lj me ln mf lr mg ly lz ma bi translated">结构—对象的设计方式</li><li id="1114" class="ls lt iq ky b kz mb lc mc lf md lj me ln mf lr mg ly lz ma bi translated">行为——物体如何相互作用</li></ol></div><div class="ab cl mh mi hu mj" role="separator"><span class="mk bw bk ml mm mn"/><span class="mk bw bk ml mm mn"/><span class="mk bw bk ml mm"/></div><div class="ij ik il im in"><h1 id="9174" class="mo mp iq bd mq mr ms mt mu mv mw mx my jw mz jx na jz nb ka nc kc nd kd ne nf bi translated">创造性的设计模式</h1><p id="773d" class="pw-post-body-paragraph kw kx iq ky b kz ng jr lb lc nh ju le lf ni lh li lj nj ll lm ln nk lp lq lr ij bi translated">在本文中，您将了解创造性的设计模式。他们关心对象实例的创建。在我接下来的文章中，你也会学到结构和行为模式。</p><p id="e677" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">本文中涉及的创造性设计模式有:</p><ol class=""><li id="83df" class="ls lt iq ky b kz la lc ld lf lu lj lv ln lw lr mg ly lz ma bi translated">一个</li><li id="42b5" class="ls lt iq ky b kz mb lc mc lf md lj me ln mf lr mg ly lz ma bi translated">工厂</li><li id="ea1e" class="ls lt iq ky b kz mb lc mc lf md lj me ln mf lr mg ly lz ma bi translated">建设者</li><li id="1b96" class="ls lt iq ky b kz mb lc mc lf md lj me ln mf lr mg ly lz ma bi translated">原型</li></ol><p id="e78d" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">事不宜迟，让我们从单例设计模式开始。</p></div><div class="ab cl mh mi hu mj" role="separator"><span class="mk bw bk ml mm mn"/><span class="mk bw bk ml mm mn"/><span class="mk bw bk ml mm"/></div><div class="ij ik il im in"><h1 id="9897" class="mo mp iq bd mq mr ms mt mu mv mw mx my jw mz jx na jz nb ka nc kc nd kd ne nf bi translated">一个</h1><p id="acc3" class="pw-post-body-paragraph kw kx iq ky b kz ng jr lb lc nh ju le lf ni lh li lj nj ll lm ln nk lp lq lr ij bi translated">从它的名字:<em class="nl">单</em>吨就可以一窥这种设计模式的用途。当我们只需要一个类的单个实例时，我们使用这种设计模式。这意味着我们不能创建多个实例，只能创建一个。如果没有实例，则会创建一个新实例。如果存在现有实例，它将使用该实例。</p><p id="c874" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">让我们看一个实现了单例模式的例子:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nm nn l"/></div></figure><p id="592a" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">正如您所看到的，有许多样板文件来实现Singleton。因此，让我们看看实现这种设计模式的一种更短的方法。解决方案是完全删除<code class="fe no np nq nr b">Singleton</code>类，并导出类<code class="fe no np nq nr b">DatabaseConnection</code>的一个新实例。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nm nn l"/></div></figure><p id="a759" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">为什么会这样？在Node中，它的工作是因为模块缓存系统。根据<a class="ae kv" href="https://nodejs.org/api/modules.html#modules_caching" rel="noopener ugc nofollow" target="_blank">的文档</a>，“模块在第一次加载后被缓存。”在上面的第二个例子中，导出的新实例被缓存，并在每次需要时重用。</p><p id="1ae0" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">因此，这是在Node中实现单例模式的两种方式。</p><p id="b165" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">概括一下:</p><ul class=""><li id="597a" class="ls lt iq ky b kz la lc ld lf lu lj lv ln lw lr lx ly lz ma bi translated">当你只需要一个类的实例时，Singleton是很有用的。</li><li id="8456" class="ls lt iq ky b kz mb lc mc lf md lj me ln mf lr lx ly lz ma bi translated">在Node中，我们可以利用模块缓存系统直接导出实例。</li></ul></div><div class="ab cl mh mi hu mj" role="separator"><span class="mk bw bk ml mm mn"/><span class="mk bw bk ml mm mn"/><span class="mk bw bk ml mm"/></div><div class="ij ik il im in"><h1 id="abbf" class="mo mp iq bd mq mr ms mt mu mv mw mx my jw mz jx na jz nb ka nc kc nd kd ne nf bi translated">工厂</h1><p id="b6f9" class="pw-post-body-paragraph kw kx iq ky b kz ng jr lb lc nh ju le lf ni lh li lj nj ll lm ln nk lp lq lr ij bi translated">再一次，我们可以通过查看它的名字来了解这种设计模式的作用。工厂设计模式允许我们定义用于创建对象的接口或抽象类。然后我们使用接口/抽象类来实例化不同的对象。</p><p id="73a1" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">考虑一个应用程序，其中我们必须创建和使用所有类型的车辆。有机动车(汽车、公共汽车、卡车、摩托车)、轨道交通工具(火车、电车)、飞机(飞机、直升机)和水上交通工具(轮船、小船)。因此，我们可以如下实现工厂模式，而不是通过单独调用每个类的构造函数来创建实例:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nm nn l"/></div></figure><p id="c4dd" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">您可以使用<code class="fe no np nq nr b">VehicleFactory</code>并指定类型，而不是单独创建每个类的实例。您将创建一个新的<code class="fe no np nq nr b">Car</code>实例，如下所示:</p><pre class="kg kh ki kj gt ns nr nt nu aw nv bi"><span id="cbd8" class="nw mp iq nr b gy nx ny l nz oa"><strong class="nr ir">const</strong> audiAllRoad = VehicleFactory('car', 'Audi', 'A6 Allroad', '2020');</span></pre><p id="648a" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">使用工厂设计模式的好处是它将对象的构造从对象本身中分离出来。您还可以在不破坏现有代码的情况下向应用程序中引入新对象。最后，它帮助您更好地组织代码，因为所有与创建实例相关的代码都在一个地方。</p><p id="fa21" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">概括一下:</p><ul class=""><li id="6811" class="ls lt iq ky b kz la lc ld lf lu lj lv ln lw lr lx ly lz ma bi translated">工厂模式为创建对象提供了一个接口/抽象类。</li><li id="5cfb" class="ls lt iq ky b kz mb lc mc lf md lj me ln mf lr lx ly lz ma bi translated">您可以通过使用相同的接口/抽象类来创建不同的对象。</li><li id="7e3a" class="ls lt iq ky b kz mb lc mc lf md lj me ln mf lr lx ly lz ma bi translated">它改进了代码的结构，使其更易于维护。</li></ul></div><div class="ab cl mh mi hu mj" role="separator"><span class="mk bw bk ml mm mn"/><span class="mk bw bk ml mm mn"/><span class="mk bw bk ml mm"/></div><div class="ij ik il im in"><h1 id="f83b" class="mo mp iq bd mq mr ms mt mu mv mw mx my jw mz jx na jz nb ka nc kc nd kd ne nf bi translated">建设者</h1><p id="4dbc" class="pw-post-body-paragraph kw kx iq ky b kz ng jr lb lc nh ju le lf ni lh li lj nj ll lm ln nk lp lq lr ij bi translated">构建器设计模式允许我们将对象的构造与它们的表示分离开来。因此，它简化了创建复杂对象的代码。对于简单的对象来说，这可能有点过了，但是对于复杂的对象来说，这简化了它们的创建。</p><p id="efff" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">为了帮助您理解这种设计模式，我们来看一个例子。假设我们想制造汽车。在这个例子中，我们有<code class="fe no np nq nr b">Car</code>和<code class="fe no np nq nr b">CarBuilder</code>类。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nm nn l"/></div></figure><p id="52d8" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">现在我们用<code class="fe no np nq nr b">CarBuilder</code>代替<code class="fe no np nq nr b">Car</code>来制造汽车。我们的做法如下:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nm nn l"/></div></figure><p id="a745" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">使用构建器设计模式使得复杂对象的创建不容易出错，因为您可以很容易地理解每个参数的作用。相比之下，下面是我们如何创建没有<code class="fe no np nq nr b">CarBuilder</code>类的汽车:</p><pre class="kg kh ki kj gt ns nr nt nu aw nv bi"><span id="2b11" class="nw mp iq nr b gy nx ny l nz oa"><strong class="nr ir">const</strong> bmw = <strong class="nr ir">new</strong> CarBuilder('bmw', 'x6', 2020, true, true);</span></pre><p id="8900" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">你可以看到它是如何变得令人困惑的。那两个布尔值(<code class="fe no np nq nr b">true</code>)是什么意思？现在想象这个物体更复杂。创建对象会令人困惑，并且引入错误的几率会更高。</p><p id="7df1" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">因此，构建器设计模式对于分离复杂对象的创建和表示非常有用。</p></div><div class="ab cl mh mi hu mj" role="separator"><span class="mk bw bk ml mm mn"/><span class="mk bw bk ml mm mn"/><span class="mk bw bk ml mm"/></div><div class="ij ik il im in"><h1 id="34fc" class="mo mp iq bd mq mr ms mt mu mv mw mx my jw mz jx na jz nb ka nc kc nd kd ne nf bi translated">原型</h1><p id="539f" class="pw-post-body-paragraph kw kx iq ky b kz ng jr lb lc nh ju le lf ni lh li lj nj ll lm ln nk lp lq lr ij bi translated">JavaScript是一种基于原型的语言，这意味着它使用原型继承。这意味着每个对象都继承自其他对象。</p><p id="ea63" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">因此，我们通过克隆原型的值来创建新的对象，这也可以称为样本对象。这意味着原型充当新对象的蓝图。使用这种设计模式的一个重要好处是对象中定义的函数是通过引用创建的。这意味着所有对象都指向同一个函数，而不是拥有该函数的副本。更简单地说，原型的功能可用于从原型继承的所有对象。</p><p id="b1d9" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">好了，说够了。让我们看一个例子，这样你可以更好地理解这个设计模式是关于什么的。我们将继续汽车场景。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nm nn l"/></div></figure><p id="15c4" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">为了从原型创建一个新的对象，我们可以使用<code class="fe no np nq nr b">Object.create()</code>方法。第二个对象(<code class="fe no np nq nr b">secondATV</code>)的值与第一个对象(<code class="fe no np nq nr b">atv</code>)的值相同。为了确保它正常工作，请尝试调用<code class="fe no np nq nr b">mud</code>函数或打印任何对象属性。</p><p id="b6ab" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">使用原型设计模式的另一种方式是在“类”中指定原型你可以看到下面的例子:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nm nn l"/></div></figure><p id="52e9" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">同样，两个实例都可以访问在<code class="fe no np nq nr b">atvPrototype</code>对象中定义的任何内容。而且，它们指向同一个函数，而不是拥有它们的<code class="fe no np nq nr b">mud</code>函数。</p><p id="3e86" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">总之，原型设计模式非常有用——尤其是当您希望对象共享相同的功能或属性时。它还充当所有新对象的蓝图。</p><p id="8f8b" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">概括一下:</p><ul class=""><li id="80cf" class="ls lt iq ky b kz la lc ld lf lu lj lv ln lw lr lx ly lz ma bi translated">JavaScript是一种基于原型的语言。</li><li id="efb1" class="ls lt iq ky b kz mb lc mc lf md lj me ln mf lr lx ly lz ma bi translated">它使用原型继承。</li><li id="9520" class="ls lt iq ky b kz mb lc mc lf md lj me ln mf lr lx ly lz ma bi translated">每个对象都继承自其他对象。</li><li id="6cde" class="ls lt iq ky b kz mb lc mc lf md lj me ln mf lr lx ly lz ma bi translated">新对象是按照一个叫做原型的蓝图创建的。</li><li id="317c" class="ls lt iq ky b kz mb lc mc lf md lj me ln mf lr lx ly lz ma bi translated">原型上定义的函数被所有新类继承。</li><li id="559d" class="ls lt iq ky b kz mb lc mc lf md lj me ln mf lr lx ly lz ma bi translated">新的类指向同一个函数，而不是有单独的副本。</li></ul></div><div class="ab cl mh mi hu mj" role="separator"><span class="mk bw bk ml mm mn"/><span class="mk bw bk ml mm mn"/><span class="mk bw bk ml mm"/></div><div class="ij ik il im in"><h1 id="4af5" class="mo mp iq bd mq mr ms mt mu mv mw mx my jw mz jx na jz nb ka nc kc nd kd ne nf bi translated">结论</h1><p id="e9a8" class="pw-post-body-paragraph kw kx iq ky b kz ng jr lb lc nh ju le lf ni lh li lj nj ll lm ln nk lp lq lr ij bi translated">这篇文章是我的#learninpublic过程的一部分。因此，重要的是要注意，这篇文章是一个起点，你当然可以挖掘得更深。如果你想深入了解，我推荐《设计模式:可重用面向对象软件的元素》这本书。</p><p id="0e23" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">感谢阅读！</p><blockquote class="ob oc od"><p id="1fad" class="kw kx nl ky b kz la jr lb lc ld ju le oe lg lh li of lk ll lm og lo lp lq lr ij bi translated"><a class="ae kv" href="https://rli.to/PhkSl" rel="noopener ugc nofollow" target="_blank">学习Node.js </a>，从零开始构建高级大型应用&amp;被聘为后端开发人员</p></blockquote></div></div>    
</body>
</html>