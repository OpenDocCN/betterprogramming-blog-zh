<html>
<head>
<title>How To Manage Sessions in Node.js Using Passport, Redis, and MySQL</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何使用Passport、Redis和MySQL管理Node.js中的会话</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/how-to-manage-sessions-in-node-js-using-passport-redis-and-mysql-a9ac9ecb0708?source=collection_archive---------4-----------------------#2022-03-25">https://betterprogramming.pub/how-to-manage-sessions-in-node-js-using-passport-redis-and-mysql-a9ac9ecb0708?source=collection_archive---------4-----------------------#2022-03-25</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="98b7" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">深入会话管理的世界</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/3fcddf842c879990686f3f39ddb82bad.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*GBc0laMQqXQhGjn2.png"/></div></div></figure><p id="205c" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">HTTP和HTTPS是互联网协议，允许通过网络浏览器发送请求，从而在互联网上发送数据。因为它们是无状态的，所以发送到浏览器的每个请求都被独立处理。这意味着浏览器无法记住请求的来源，即使是同一用户发出的请求。HTTP会话解决了这个问题。</p><p id="d0fa" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">本文将探讨会话管理，以及Passport、Redis和MySQL等工具如何帮助我们管理Node.js会话。让我们开始吧。</p><h1 id="c307" class="lq lr it bd ls lt lu lv lw lx ly lz ma jz mb ka mc kc md kd me kf mf kg mg mh bi translated">HTTP会话是如何工作的？</h1><p id="d878" class="pw-post-body-paragraph ku kv it kw b kx mi ju kz la mj jx lc ld mk lf lg lh ml lj lk ll mm ln lo lp im bi translated">HTTP会话允许web服务器在客户端应用程序和web应用程序之间的多个请求/响应交互中维护用户身份并存储用户特定的数据。当客户端登录到应用程序时，服务器会生成一个SessionID。使用单服务器、非复制的持久存储机制将会话保存在内存中。这种机制的例子包括JDBC持久性、文件系统持久性、基于cookie的会话持久性和内存复制。</p><p id="614c" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">当用户发送后续请求时，<code class="fe mn mo mp mq b">sessionID</code>在请求头中传递，浏览器检查ID是否与内存存储中的任何ID匹配，并授予用户访问权限，直到会话到期。</p><p id="1765" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">HTTP会话将以下数据存储在内存中:</p><ul class=""><li id="b187" class="mr ms it kw b kx ky la lb ld mt lh mu ll mv lp mw mx my mz bi translated">关于会话的细节(会话标识符、创建时间、上次访问时间等。)</li><li id="aaaa" class="mr ms it kw b kx na la nb ld nc lh nd ll ne lp mw mx my mz bi translated">关于用户的上下文信息(例如，客户端登录状态)</li></ul><h1 id="0817" class="lq lr it bd ls lt lu lv lw lx ly lz ma jz mb ka mc kc md kd me kf mf kg mg mh bi translated">Redis是什么？</h1><p id="93d5" class="pw-post-body-paragraph ku kv it kw b kx mi ju kz la mj jx lc ld mk lf lg lh ml lj lk ll mm ln lo lp im bi translated">Redis(远程字典服务器)是一个快速、开源、内存中的键值数据存储，用作数据库、缓存、消息代理和队列。</p><p id="6e81" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">Redis具有亚毫秒级响应时间，每秒钟可处理数百万个实时应用请求，如游戏、广告技术、金融、医疗保健和物联网等行业。因此，Redis现在是最受欢迎的开源引擎之一，连续五年被Stack Overflow评为“最受欢迎”的数据库。</p><p id="ec33" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">由于其快速的性能，Redis是缓存、会话管理、游戏、排行榜、实时分析、地理空间、乘车、聊天/消息、媒体流和发布/订阅应用程序的热门选择。</p><h1 id="97d2" class="lq lr it bd ls lt lu lv lw lx ly lz ma jz mb ka mc kc md kd me kf mf kg mg mh bi translated">我们在建造什么？</h1><p id="9a1b" class="pw-post-body-paragraph ku kv it kw b kx mi ju kz la mj jx lc ld mk lf lg lh ml lj lk ll mm ln lo lp im bi translated">为了演示Node.js中的会话管理，我们将创建一个简单的注册和登录应用程序。用户将注册并通过提供他们的电子邮件地址和密码登录到该应用程序。当用户登录时，会创建一个会话并保存在Redis存储中以备将来请求。当用户注销时，我们将删除他们的会话。说够了。我们开始吧！</p><h1 id="b537" class="lq lr it bd ls lt lu lv lw lx ly lz ma jz mb ka mc kc md kd me kf mf kg mg mh bi translated">先决条件</h1><p id="d45c" class="pw-post-body-paragraph ku kv it kw b kx mi ju kz la mj jx lc ld mk lf lg lh ml lj lk ll mm ln lo lp im bi translated">本教程是一个实践演示。开始之前，请确保您已经安装了以下软件:</p><ul class=""><li id="085d" class="mr ms it kw b kx ky la lb ld mt lh mu ll mv lp mw mx my mz bi translated"><a class="ae nf" href="https://nodejs.org/en/" rel="noopener ugc nofollow" target="_blank"> Node.js </a></li><li id="ca57" class="mr ms it kw b kx na la nb ld nc lh nd ll ne lp mw mx my mz bi translated"><a class="ae nf" href="https://redis.io/topics/quickstart" rel="noopener ugc nofollow" target="_blank"> Redis CLI </a></li><li id="7d3d" class="mr ms it kw b kx na la nb ld nc lh nd ll ne lp mw mx my mz bi translated"><a class="ae nf" href="https://www.mysql.com/downloads/" rel="noopener ugc nofollow" target="_blank"> MySQL数据库</a></li><li id="de5a" class="mr ms it kw b kx na la nb ld nc lh nd ll ne lp mw mx my mz bi translated"><a class="ae nf" href="http://arctype.com" rel="noopener ugc nofollow" target="_blank">弧型</a></li></ul><p id="a92b" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">本教程的代码可以在我的GitHub <a class="ae nf" href="https://github.com/Claradev32/Session_management" rel="noopener ugc nofollow" target="_blank">资源库</a>中找到。感觉克隆和跟随。</p><h2 id="e911" class="ng lr it bd ls nh ni dn lw nj nk dp ma ld nl nm mc lh nn no me ll np nq mg nr bi translated">项目设置</h2><p id="6729" class="pw-post-body-paragraph ku kv it kw b kx mi ju kz la mj jx lc ld mk lf lg lh ml lj lk ll mm ln lo lp im bi translated">让我们首先使用下面的命令为应用程序创建一个项目文件夹:</p><pre class="kj kk kl km gt ns mq nt nu aw nv bi"><span id="0d5c" class="ng lr it mq b gy nw nx l ny nz">mkdir Session_management &amp;&amp; cd Session_management</span></pre><p id="d634" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">然后，使用以下命令初始化Node.js应用程序以创建package.json文件:</p><pre class="kj kk kl km gt ns mq nt nu aw nv bi"><span id="c98f" class="ng lr it mq b gy nw nx l ny nz">npm init -y</span></pre><p id="c146" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">上面命令中的<code class="fe mn mo mp mq b">-y</code>标志告诉npm使用默认配置。现在，在您的项目根目录中创建以下文件夹结构。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi oa"><img src="../Images/3782105088784c7a1a81f15ff745ec23.png" data-original-src="https://miro.medium.com/v2/resize:fit:928/format:webp/1*CK0qtEtJJ36SG3dJanxWXg.png"/></div></figure><p id="fa46" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">创建了package.json之后，让我们在下一节安装这个项目所需的包。</p><h1 id="b40c" class="lq lr it bd ls lt lu lv lw lx ly lz ma jz mb ka mc kc md kd me kf mf kg mg mh bi translated">安装依赖项</h1><p id="eef4" class="pw-post-body-paragraph ku kv it kw b kx mi ju kz la mj jx lc ld mk lf lg lh ml lj lk ll mm ln lo lp im bi translated">我们将为我们的应用程序安装以下依赖项:</p><ul class=""><li id="9677" class="mr ms it kw b kx ky la lb ld mt lh mu ll mv lp mw mx my mz bi translated"><code class="fe mn mo mp mq b">Bcryptjs</code> —该模块将用于散列用户的密码。</li><li id="1b97" class="mr ms it kw b kx na la nb ld nc lh nd ll ne lp mw mx my mz bi translated"><code class="fe mn mo mp mq b">Connect-redis </code> —此模块将为Express提供Redis会话存储。</li><li id="8f42" class="mr ms it kw b kx na la nb ld nc lh nd ll ne lp mw mx my mz bi translated"><code class="fe mn mo mp mq b">Express-session</code> —此模块将用于创建会话。</li><li id="801d" class="mr ms it kw b kx na la nb ld nc lh nd ll ne lp mw mx my mz bi translated"><code class="fe mn mo mp mq b">Ejs</code> —这个模块是我们的模板引擎</li><li id="6642" class="mr ms it kw b kx na la nb ld nc lh nd ll ne lp mw mx my mz bi translated"><code class="fe mn mo mp mq b">Passport</code> —该模块将用于用户认证</li><li id="7ed4" class="mr ms it kw b kx na la nb ld nc lh nd ll ne lp mw mx my mz bi translated"><code class="fe mn mo mp mq b">Passport-local</code> —该模块将用于本地用户名和密码验证</li><li id="eb70" class="mr ms it kw b kx na la nb ld nc lh nd ll ne lp mw mx my mz bi translated">这个模块是我们的MySQL ORM，用于将我们的应用程序连接到MySQL数据库。</li><li id="ed33" class="mr ms it kw b kx na la nb ld nc lh nd ll ne lp mw mx my mz bi translated"><code class="fe mn mo mp mq b">Dotenv</code> —该模块将用于加载我们的环境变量。</li></ul><p id="2705" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">使用下面的命令安装所有必需的依赖项。</p><pre class="kj kk kl km gt ns mq nt nu aw nv bi"><span id="f9a1" class="ng lr it mq b gy nw nx l ny nz">npm install bcryptjs connect-redis redis express-session ejs passport passport-local sequelize dotenv</span></pre><p id="844d" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">等待安装完成。安装完成后，在下一节中继续设置MySQL数据库。</p><h1 id="5684" class="lq lr it bd ls lt lu lv lw lx ly lz ma jz mb ka mc kc md kd me kf mf kg mg mh bi translated">设置MySQL数据库</h1><p id="eb45" class="pw-post-body-paragraph ku kv it kw b kx mi ju kz la mj jx lc ld mk lf lg lh ml lj lk ll mm ln lo lp im bi translated">我们将为我们的应用程序创建一个MySQL数据库。但在此之前，运行下面的命令来创建一个MySQL用户帐户:</p><pre class="kj kk kl km gt ns mq nt nu aw nv bi"><span id="d23c" class="ng lr it mq b gy nw nx l ny nz">CREATE USER 'newuser'@'localhost' IDENTIFIED BY '1234';</span></pre><p id="4d9d" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">现在创建一个数据库<code class="fe mn mo mp mq b">session_db</code>，并使用下面的命令授予<code class="fe mn mo mp mq b">newuser</code>访问数据库的权限:</p><pre class="kj kk kl km gt ns mq nt nu aw nv bi"><span id="ba69" class="ng lr it mq b gy nw nx l ny nz">#Create database<br/>CREATE DATABASE session_db; <br/><br/> #grant access<br/>GRANT ALL PRIVILEGES ON session_db TO 'newuser'@'localhost';<br/><br/>ALTER USER 'newuser'@'localhost' IDENTIFIED WITH mysql_native_password BY '1234';</span></pre><p id="f262" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">现在，使用下面的命令重新加载所有权限:</p><pre class="kj kk kl km gt ns mq nt nu aw nv bi"><span id="845b" class="ng lr it mq b gy nw nx l ny nz">FLUSH PRIVILEGES;</span></pre><p id="b68f" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">有了MySQL数据库设置，让我们在下一节创建我们的<code class="fe mn mo mp mq b">users</code>数据库模型。</p><h1 id="800d" class="lq lr it bd ls lt lu lv lw lx ly lz ma jz mb ka mc kc md kd me kf mf kg mg mh bi translated">创建Express服务器</h1><p id="a543" class="pw-post-body-paragraph ku kv it kw b kx mi ju kz la mj jx lc ld mk lf lg lh ml lj lk ll mm ln lo lp im bi translated">使用我们的MySQL数据库设置，让我们为应用程序创建一个express服务器。打开<code class="fe mn mo mp mq b">src/server.js</code>文件并添加以下代码片段:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ob oc l"/></div></figure><p id="7160" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">在上面的代码片段中，我们创建了一个express服务器，它将侦听端口4300上的请求。然后，我们使用<code class="fe mn mo mp mq b">express.json()</code>中间件解析带有JSON有效负载的传入请求，使用<code class="fe mn mo mp mq b">Express.urlencoded()</code>中间件解析带有<code class="fe mn mo mp mq b">urlencoded</code>的传入请求。</p><h1 id="91f3" class="lq lr it bd ls lt lu lv lw lx ly lz ma jz mb ka mc kc md kd me kf mf kg mg mh bi translated">创建数据库模型</h1><p id="8b4a" class="pw-post-body-paragraph ku kv it kw b kx mi ju kz la mj jx lc ld mk lf lg lh ml lj lk ll mm ln lo lp im bi translated">至此，我们的Express服务器已经设置完毕。现在我们将创建一个<code class="fe mn mo mp mq b">Users</code>模型来表示用户数据，我们将看到使用<code class="fe mn mo mp mq b">Sequelize</code>的数据库。打开<code class="fe mn mo mp mq b">src/models/index.js</code>文件，添加下面的代码片段:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ob oc l"/></div></figure><p id="9d99" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">在上面的代码片段中，我们从<code class="fe mn mo mp mq b">sequelize</code>导入<code class="fe mn mo mp mq b">Sequelize</code>和<code class="fe mn mo mp mq b">DateTypes</code>来连接我们的MySQL数据库，并为我们的模型属性分配一个数据类型。然后，我们通过从<code class="fe mn mo mp mq b">Sequelize</code>类创建一个<code class="fe mn mo mp mq b">sequelize</code>实例并传递我们的数据库凭证来连接MySQL。例如，对于<code class="fe mn mo mp mq b">sequelize</code>实例，我们定义了我们的模型及其属性。我们只需要本教程的id，电子邮件和密码字段。但是sequelize创建了两个额外的字段，即<code class="fe mn mo mp mq b">createdAt</code>和<code class="fe mn mo mp mq b">updatedAt</code>字段。</p><h1 id="1f6d" class="lq lr it bd ls lt lu lv lw lx ly lz ma jz mb ka mc kc md kd me kf mf kg mg mh bi translated">设置Passport和Redis</h1><p id="7a87" class="pw-post-body-paragraph ku kv it kw b kx mi ju kz la mj jx lc ld mk lf lg lh ml lj lk ll mm ln lo lp im bi translated">为了处理和存储我们的用户凭证，我们将使用和配置<code class="fe mn mo mp mq b">Redis</code>。为此，打开<code class="fe mn mo mp mq b">src/index.js</code>文件并导入以下依赖关系:</p><pre class="kj kk kl km gt ns mq nt nu aw nv bi"><span id="ce29" class="ng lr it mq b gy nw nx l ny nz">const session = require("express-session");<br/>const connectRedis = require("connect-redis");<br/>const dotenv = require("dotenv").config()<br/>const { createClient } = require("redis");<br/>const passport = require("passport");</span></pre><p id="ecec" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">然后，定位注释区域<code class="fe mn mo mp mq b">//Redis configurations</code>并添加下面的代码片段:</p><pre class="kj kk kl km gt ns mq nt nu aw nv bi"><span id="bf9f" class="ng lr it mq b gy nw nx l ny nz">const redisClient = createClient({ legacyMode: true });<br/>redisClient.connect().catch(console.error);<br/>const RedisStore = connectRedis(session);</span></pre><p id="69ab" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">在上面的代码片段中，我们建立了到数据库的连接，该数据库将管理用户的用户名数据。</p><p id="f9e6" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">接下来，定位注释区域<code class="fe mn mo mp mq b">//Commented session middleware</code>并添加下面的代码片段:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ob oc l"/></div></figure><p id="2fb5" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">在上面的代码片段中，我们在一个<code class="fe mn mo mp mq b">.env</code>文件中创建了一个<code class="fe mn mo mp mq b">SESSION_SECRET</code>变量来保存我们的会话秘密，然后创建了一个会话中间件并使用Redis作为我们的存储。为了让会话工作，我们添加了两个中间件<code class="fe mn mo mp mq b">passport.initialize()</code>和<code class="fe mn mo mp mq b">passport.session()</code>。</p><h1 id="8d42" class="lq lr it bd ls lt lu lv lw lx ly lz ma jz mb ka mc kc md kd me kf mf kg mg mh bi translated">创建应用程序控制器</h1><p id="d272" class="pw-post-body-paragraph ku kv it kw b kx mi ju kz la mj jx lc ld mk lf lg lh ml lj lk ll mm ln lo lp im bi translated">通过我们的Redis和express会话设置，我们将创建一个路由来处理用户信息。为此，打开<code class="fe mn mo mp mq b">src/controllers/index.js</code>文件并添加下面的代码片段:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ob oc l"/></div></figure><p id="364c" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">在上面的代码片段中，我们导入了<code class="fe mn mo mp mq b">bcrypt</code>和<code class="fe mn mo mp mq b">User</code>模型，我们从<code class="fe mn mo mp mq b">req.body</code>对象中析构了用户的<code class="fe mn mo mp mq b">email</code>和<code class="fe mn mo mp mq b">password</code>。然后我们使用<code class="fe mn mo mp mq b">bcrypt </code>散列密码，并使用<code class="fe mn mo mp mq b">sequelize create</code>方法创建一个新用户。</p><p id="0cb5" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">接下来，用下面的代码片段创建一个<code class="fe mn mo mp mq b">home page</code>、<code class="fe mn mo mp mq b">registration page</code>、<code class="fe mn mo mp mq b">login page</code>:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ob oc l"/></div></figure><p id="c0e9" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">在<code class="fe mn mo mp mq b">HomePage</code>中，我们将在<code class="fe mn mo mp mq b">home</code>视图旁边呈现一些经过验证的用户的详细信息。</p><p id="b989" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">最后，创建<code class="fe mn mo mp mq b">logout</code>路由，用下面的代码片段删除用户的用户名数据:</p><pre class="kj kk kl km gt ns mq nt nu aw nv bi"><span id="073b" class="ng lr it mq b gy nw nx l ny nz">exports.Logout = (req, res) =&gt; {<br/> req.session.destroy((err) =&gt; {<br/>   if (err) {<br/>     return console.log(err);<br/>   }<br/>   res.redirect("/");<br/> });<br/>};</span></pre><h1 id="eafe" class="lq lr it bd ls lt lu lv lw lx ly lz ma jz mb ka mc kc md kd me kf mf kg mg mh bi translated">创建护照策略</h1><p id="a138" class="pw-post-body-paragraph ku kv it kw b kx mi ju kz la mj jx lc ld mk lf lg lh ml lj lk ll mm ln lo lp im bi translated">此时，用户可以注册、登录和注销我们的应用程序。现在，让我们创建passport策略来验证用户并创建一个会话。为此，打开<code class="fe mn mo mp mq b">src/utils/passport.js</code> <strong class="kw iu"> </strong>文件，并添加下面的代码片段:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ob oc l"/></div></figure><p id="4dee" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">在上面的代码片段中，我们导入了<code class="fe mn mo mp mq b">passport</code>、<code class="fe mn mo mp mq b">bcrypt</code>和我们的用户模型，并且我们创建了一个passport中间件来使用<code class="fe mn mo mp mq b">local-strategy</code>、<strong class="kw iu">。</strong>然后，我们将默认文件名重命名为我们用来验证用户的字段名(<code class="fe mn mo mp mq b">email</code>、<code class="fe mn mo mp mq b">password</code>)。现在，在为用户创建会话之前，我们检查数据库中是否存在用户详细信息。</p><p id="d86e" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated"><code class="fe mn mo mp mq b">Passport.serialize</code>和<code class="fe mn mo mp mq b">passport.deserialize</code>命令用于将用户的id作为cookie保存在用户的浏览器中，并在必要时从cookie中检索id，然后使用该id在回调中检索用户信息。</p><p id="7fd3" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated"><code class="fe mn mo mp mq b">done()</code>函数是一个内部<code class="fe mn mo mp mq b">passport.js</code>函数，它将用户id作为第二个参数。</p><h1 id="0b2b" class="lq lr it bd ls lt lu lv lw lx ly lz ma jz mb ka mc kc md kd me kf mf kg mg mh bi translated">创建应用程序路由</h1><p id="60ab" class="pw-post-body-paragraph ku kv it kw b kx mi ju kz la mj jx lc ld mk lf lg lh ml lj lk ll mm ln lo lp im bi translated">创建了passport策略后，让我们继续为控制器创建路线。为此，打开<code class="fe mn mo mp mq b">src/routes/index.js</code>文件并添加以下代码片段:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ob oc l"/></div></figure><p id="6635" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">在上面的代码片段中，我们导入了控制器函数，并为它们创建了一个路由。对于<code class="fe mn mo mp mq b">signin route</code>、<strong class="kw iu">、</strong>，我们使用了<code class="fe mn mo mp mq b">passport.authenticate</code>方法，通过前面章节设置中的<code class="fe mn mo mp mq b">local</code>策略对用户进行身份验证。</p><p id="3c31" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">现在回到我们的<code class="fe mn mo mp mq b">server.js</code> <strong class="kw iu"> </strong>文件，我们将为我们的路由创建一个中间件。在此之前，我们需要导入我们的<code class="fe mn mo mp mq b">router</code>和<code class="fe mn mo mp mq b">passportConfig</code> <strong class="kw iu"> </strong>函数。</p><pre class="kj kk kl km gt ns mq nt nu aw nv bi"><span id="23be" class="ng lr it mq b gy nw nx l ny nz">const router = require("./routes");<br/>const { passportConfig } = require("./utils/passport");</span></pre><p id="e3a0" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">然后，我们将在注释了<code class="fe mn mo mp mq b">//Configure session middleware</code>的区域调用代码正下方的<code class="fe mn mo mp mq b">passportConfig</code>函数。</p><pre class="kj kk kl km gt ns mq nt nu aw nv bi"><span id="476d" class="ng lr it mq b gy nw nx l ny nz">passportConfig();</span></pre><p id="c0f4" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">然后，我们将在区域注释<strong class="kw iu"> </strong> <code class="fe mn mo mp mq b">//Router middleware</code>之后创建我们的路由中间件。</p><pre class="kj kk kl km gt ns mq nt nu aw nv bi"><span id="7d2b" class="ng lr it mq b gy nw nx l ny nz">app.use(router);</span></pre><h1 id="36ce" class="lq lr it bd ls lt lu lv lw lx ly lz ma jz mb ka mc kc md kd me kf mf kg mg mh bi translated">创建我们的应用视图</h1><p id="bce7" class="pw-post-body-paragraph ku kv it kw b kx mi ju kz la mj jx lc ld mk lf lg lh ml lj lk ll mm ln lo lp im bi translated">创建好路线后，我们将创建在<code class="fe mn mo mp mq b">HomePage</code>、<code class="fe mn mo mp mq b">LoginPage</code>和<code class="fe mn mo mp mq b">RegisterPage</code>控制器中呈现的视图。在此之前，我们将在<code class="fe mn mo mp mq b">server.js</code>文件中设置我们的ejs视图引擎，在注释区域<code class="fe mn mo mp mq b">//app middleware</code>的正下方有一段代码。</p><pre class="kj kk kl km gt ns mq nt nu aw nv bi"><span id="ea37" class="ng lr it mq b gy nw nx l ny nz">app.set("view engine", "ejs");</span></pre><p id="5cfe" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">然后，我们将从主页开始，打开<code class="fe mn mo mp mq b">views/home.ejs</code> <strong class="kw iu"> </strong>文件并添加以下标记:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ob oc l"/></div></figure><p id="ae83" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">在我们的主页上，我们使用bootstrap为我们的标记添加了一些样式。然后，我们检查用户是否经过身份验证，以显示注销按钮。同样，我们从后端显示用户的<code class="fe mn mo mp mq b">Email</code>、<code class="fe mn mo mp mq b">sessionID</code>和<code class="fe mn mo mp mq b">ExpirationTime</code>。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="ab gu cl od"><img src="../Images/49f232729b0ffd14ab7b5d13d9081bbc.png" data-original-src="https://miro.medium.com/v2/0*0-OmTnU42lzr2Fn-"/></div></figure><p id="5f4e" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">接下来，打开<code class="fe mn mo mp mq b">src/views/auth/resgister</code>并为注册页面添加以下标记:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ob oc l"/></div></figure><p id="72c4" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">在注册页面上，我们创建了一个HTML表单来接受用户的详细信息。在表单中，我们还添加了active属性并指定注册端点。这意味着当用户点击提交按钮时，一个请求将被发送到<code class="fe mn mo mp mq b">/api/v1/signup</code> <strong class="kw iu"> </strong>端点。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="ab gu cl od"><img src="../Images/48a14c115f72a9c5bab152f2225c1612.png" data-original-src="https://miro.medium.com/v2/0*2Fl-nRYVX4HFeupq"/></div></figure><p id="a89b" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">最后，打开<code class="fe mn mo mp mq b">src/views/auth/signin.js</code>文件，并在下面添加以下标记片段:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ob oc l"/></div></figure><p id="b605" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">在上面的标记中，我们添加了一个HTML表单，用户可以通过向<code class="fe mn mo mp mq b">/api/v1/signin</code> <strong class="kw iu"> </strong>端点发送请求来登录。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="ab gu cl od"><img src="../Images/7924017a8b6d3591f116f3873c03a8ed.png" data-original-src="https://miro.medium.com/v2/0*FjVvqLk-OsjtVE5S"/></div></figure><h1 id="b7de" class="lq lr it bd ls lt lu lv lw lx ly lz ma jz mb ka mc kc md kd me kf mf kg mg mh bi translated">使用Arctype查看用户数据</h1><p id="7780" class="pw-post-body-paragraph ku kv it kw b kx mi ju kz la mj jx lc ld mk lf lg lh ml lj lk ll mm ln lo lp im bi translated">我们现在已经成功创建了Node.js会话管理应用程序。让我们看看Arctype的用户数据。首先，启动Arctype，单击MySQL选项卡，并输入以下MySQL凭据，如下面的屏幕截图所示:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="ab gu cl od"><img src="../Images/138eaa435c6d938881519015d4735fd9.png" data-original-src="https://miro.medium.com/v2/0*QCtUz461KbqAjtz1"/></div></figure><p id="8e64" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">然后，点击<code class="fe mn mo mp mq b">users</code> <strong class="kw iu"> </strong>表格显示注册用户，如下图所示:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="ab gu cl od"><img src="../Images/93a1cdcd011484f36f716a916d495cc1.png" data-original-src="https://miro.medium.com/v2/0*-xH4HkkpUlHdnGRQ"/></div></figure><h1 id="db76" class="lq lr it bd ls lt lu lv lw lx ly lz ma jz mb ka mc kc md kd me kf mf kg mg mh bi translated">结论</h1><p id="4ddd" class="pw-post-body-paragraph ku kv it kw b kx mi ju kz la mj jx lc ld mk lf lg lh ml lj lk ll mm ln lo lp im bi translated">通过构建一个演示登录应用程序，我们已经了解了如何使用Passport和Redis在Node.js中实现会话管理。我们从介绍HTTP会话及其工作方式开始，然后我们研究了Redis是什么，并创建了一个项目来将所有这些付诸实践。</p><p id="dff3" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">现在您已经获得了您所寻求的知识，那么您将如何认证用户的项目呢？</p></div></div>    
</body>
</html>