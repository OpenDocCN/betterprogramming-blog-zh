# Python 编程入门—第 13 部分

> 原文：<https://betterprogramming.pub/beginning-python-programming-part-13-6147ce4cd88d>

## 深入研究异步代码

![](img/91326bd49045caa121fdcffa52a381f2.png)

在 [Unsplash](https://unsplash.com?utm_source=medium&utm_medium=referral) 上由[阿米拉里·米尔哈西米安](https://unsplash.com/@amir_v_ali?utm_source=medium&utm_medium=referral)拍摄的照片

在前一篇文章中，我们讨论了迭代器和生成器。

[](https://medium.com/better-programming/beginning-python-programming-part-12-5450ae804936) [## Python 编程入门—第 12 部分

### 迭代器和生成器介绍

medium.com](https://medium.com/better-programming/beginning-python-programming-part-12-5450ae804936) 

在本文中，我们将深入研究异步代码，或者可以同时做多件事情的代码。提醒一句，这一课会很难。这将要求你很好地掌握我们到目前为止所涉及的一切。好消息是，在这之后，剩下的就比较容易了。

虽然大多数文章在给出异步编程如何工作的例子时使用了`sleep()`,但我向一个朋友保证，我会避免使用这种语法来解释异步代码。你所需要知道的是，当你调用`sleep(3)`时，程序的执行将等待`3`秒后再继续。

在开始之前，我们需要了解一些贯穿本文的术语。

*   *协程*——异步编程的最底层，这是一个异步处理的函数。这些可以直接运行或在*任务*中使用。
*   *任务* —用于调度协同程序，以供系统异步执行。
*   *Future* —用于挂起协程，直到另一个协程完成。(请将此视为需要在完成之前获取数据的后台代码)
*   *事件循环* —在一个或多个任务上迭代直到完成的循环。在 web 服务器中，这可能是一个等待客户端连接的无限循环。这是 Python 中 async 的核心；它协调所有在后台完成的工作。
*   *CPU* —中央处理器；计算机中执行计算(即工作)的硬件。
*   *CPU 物理内核* —如今的 CPU 包含多个内核。这些内核可能包括逻辑处理器(例如英特尔 i3、i5、i7)。每个物理内核负责处理数据或将工作移交给逻辑处理器。拆一个 CPU 就能摸到物理核心。
*   *逻辑处理器* —如果一个物理内核包含逻辑处理器，这些逻辑处理器执行工作。逻辑处理器仅仅因为软件而存在，但是这允许你的计算机同时做多件事情。(下载文件时一边写代码一边流音乐等。) .逻辑处理器是您在四核计算机上看到八核的原因。
*   *线程* —执行工作的物理或逻辑处理器内的队列。处理器可以包含多个队列；它们只是基于优先级进行调度。由于计算机有多个内核，您的代码可能在一个内核的主线程上运行，而您的用户界面可能在另一个内核的主线程上运行。任何不在主线程上运行的代码都被视为在后台运行。

## 获奖名单

`asyncio`是一个我们可以导入来执行异步代码的模块。它是为那些有很多慢速 I/O(输入/输出)连接的情况而设计的，并提供了两个重要的实用程序— `async`和`await`。使用`asyncio`的一个很好的例子是 web 服务器。

一个`awaitable`是一个可以在`await`表达式中使用的对象。`async`用于任何包含`await`的函数的`def`之前。

## 协程和未来

虽然我在上面给了你一个定义，但我希望你在进入细节之前对大局有一个基本的了解。

我知道这看起来像很多代码，但是我们将一次一个部分地完成它。这是我在这里找到的的一个剧本的返工。

在顶部，我们有两个导入:`asyncio`和`json`。`asyncio`是在将数据返回给客户端时要做的重要工作，而`json`只是用来将我们的字典编码成一个 JSON 结构，我们可以将它返回给每个客户端。

下一个方法`async def connection(reader, writer)`用于在客户端请求数据时响应客户端。因为我们使用了`async`，所以这是一个协程对象，它将在一个单独的线程上运行，这样服务器就可以在返回响应的同时处理其他请求。`reader`用于将请求传递给我们的函数，`writer`形成响应返回给客户端。

首先，我们使用`await reader.read(1024)`读取请求。当我们请求某样东西时，通常会有一些数据伴随着请求。这些数据告诉我们客户想做什么，以及希望如何做。只要这个响应有效，就由我们的服务器来完成。这里我们读取的是前 1024 个字节，对于任何 GET 请求来说应该足够了。我们使用`await`来暂停这个方法，直到所有的数据都可以被读取。这意味着`reader.read(1024)`是一个未来。

接下来，我们开始构建我们的响应。因为我们需要告诉客户端如何理解我们发送回来的数据，所以我们需要包含一个头。

在这个标题中，我们告诉客户一些事情:

*   HTTP/1.1 —我们正在响应的 HTTP 版本
*   200 OK —请求的状态代码，200 表示成功
*   Content-Type: application/json —我们返回的内容类型将是 json。

您可能会注意到我们在请求中包含了`\r\n`，并且在末尾出现了两次。

`\r`是创建回车(CR)的转义序列。这是老式打字机的典型代表，当你敲击书页边缘时。需要一个回车符来将回车符(固定纸张的横条)带回到页面的左边。`\r`用于 x 之前的 Mac OS 版本的新行。

`\n`是创建换行符(LF)的转义序列。回到打字机前；换行是指你向下翻页开始新的一行。`\n`至今仍在 Linux 和 macOS 系统中使用，用来表示新行。

是既做回车又做换行符的想法(CRLF)。虽然它更准确地描述了人们使用打字机时发生的事情，但它也被用来在窗口中创建新行。这也是当你在 Windows 和 Linux(或者 Windows 和 macOS)之间切换时，你的代码有时不能工作的一个很大的原因。

好了，回到正题。接下来，我们有了`data`，它只是我使用[这个脚本](https://next.json-generator.com/NkDNBEp08)创建的 JSON 的一个随机位，为了简洁起见稍微修改了一下，并将其作为字典存储在代码片段中。

接下来，我们使用`json.dumps(data)`将字典转换成 JSON 字符串。`dumps`代表“转储字符串”因为我们的 web 服务器只喜欢处理字节，所以我们将它转换成一个`bytes`对象，给它一个 UTF-8 编码，这样我们的客户端就可以正确地解析它。

然后我们使用`writer.write(header + body)`。首先，它将`header`与`body`连接起来，然后在关闭我们的编写器之前，我们将这些数据写回 web 服务器以返回给客户端，这有效地刷新了编写器的缓冲区并从内存中删除了对象。

`async def main(host, port)`是一个协程，用于处理进入 web 服务器的请求。它接受一个`host`和一个`port`作为参数，这些参数将在主体中用来创建一个基本的 web 服务器。

`server = await asyncio.start_server(connection, host, port)`很长，但很容易理解。我们使用`asyncio.start_server`创建一个`server`对象。这是一个未来，它将使用我们上面的`connection()`协程、一个`host`、这个将被托管的服务器的 IP 地址以及我们将接受连接的服务器上的`port`来创建一个 web 服务器。

`async with server`是我们还没有涉及的新语法。`with`本质上是在我们完成任何我们想要做的事情后，进行创建和任何必要的清理。`async with server`使用`async`启动`server`，如果我们遇到任何问题，它会干净利落地关闭服务器。这里我们用它来运行一个未来`await server.serve_forever()`。没错，上面为我们创建的服务器也自带了一个`async` 功能。

最后，我们需要设置服务器。

创建一个允许我们运行协程的事件循环。`main("0.0.0.0", 8000)`是我们传入的协程，因为它最终会调用我们的`connection`协程。

如果你不熟悉 IP 地址，这里有一个快速的纲要:

*   127.0.0.1 —没有比家更好的地方了，这是您的本地环回地址。
*   0.0.0.0 —告知服务器在所有接口(网卡)的所有 IP 地址上运行主机。如果您有一个以太网端口和一个无线网卡，服务器将对两个接口都可用。这个要小心；您可能只想为一个网络接口指定 IP 地址，以太网始终是首选。

每台计算机都有许多可用的端口，确切地说是 65536 个，尽管我们从 0 开始，所以最大端口号是 65535。一定要回顾一下[知名港口](https://en.wikipedia.org/wiki/List_of_TCP_and_UDP_port_numbers)(共有 1024 个)。在测试期间，您应该尽可能地远离它们，因为它们是为特定的功能保留的。端口 80 用于 HTTP，端口 443 用于 HTTPS。虽然我不能说我都记住了，但我记得我用得最多的。

您还应该注意其他端口，例如 PostgreSQL-5432、MSSQL-1433、1434、MySQL-3306 和 RDP-3389。

这些都是基本的东西，你用得越多，就会越熟悉。

回去吧！您可能会注意到，我将它包装在一个 try/except 块中。我这样做是因为当我按下键盘上的`ctrl+c`时，程序崩溃了。我不喜欢它，所以我处理了用户中断执行时发生的异常`KeyboardInterrupt`。我本可以让它安静地结束，但是为了对网站管理员友好，我决定在退出之前打印“停止 web 服务器”。

![](img/0374db98a6052d456a35d661876948ff.png)

照片由[格伦·卡斯滕斯-彼得斯](https://unsplash.com/@glenncarstenspeters?utm_source=medium&utm_medium=referral)在 [Unsplash](https://unsplash.com?utm_source=medium&utm_medium=referral) 拍摄

## 任务

说到任务，首先要记住的是任务不是线程安全的。这意味着，如果一个协程更改了另一个协程使用的数据，可能会出现一些意想不到的结果，或者更糟，您的程序可能会崩溃。

在线程安全方面，可以这样想:我们俩开同一辆车。我们必须计划好谁在什么时间开车。如果我在 8-5 点之间开车去上班，而你试图在上午 10 点开车，你将无法开车，因为车不在那里。

让我们假设我们有一个缓冲区，可以包含任何我们想要存储的数据。然后我们有两个任务使用同一个缓冲区来执行工作。一个任务使用整数数据类型，另一个使用字符串。

第一个任务在缓冲区中存储 42，第二个任务用“Hello”替换缓冲区的内容，然后第一个任务试图使用缓冲区将 1 加到缓冲区中…您看到这会给我们带来什么问题吗？

警告结束后，让我们深入研究任务。

任务用于调度协程。任务也可以用来同时运行多个协同程序。

有几种方法可用于任务，允许您取消任务、返回任务结果、检查任务状态以及添加或删除任务的*回调*。

回调本质上是任务完成时将调用的方法或函数。如果我有一个将“Bob”打印到屏幕上的任务，它可能会有一个回调函数，该函数在完成时会打印“程序完成”。

是时候举一个我从[这页](http://skipperkongen.dk/2016/09/09/easy-parallel-http-requests-with-python-and-asyncio/)借来的例子了。

照例，我们`import asyncio`。然后我们有一个`count`函数，它将当前的运行次数作为参数。然后我们为每次运行打印 100 次迭代。我们以前做过这些。

`create_tasks`是一个异步函数，它使用`asyncio.get_event_loop()`创建一个内部事件循环。它提供了一个事件循环，我们可以使用它来执行任务。

然后，我创建了一个清单理解，生成 300 个任务来运行。在这个列表的理解里面，我们使用`inner_loop.run_in_executor`。该函数的第一个参数需要一个*concurrent . futures . executor*实例。如果我们像这里一样传入`None`，我们使用默认的执行器。这很好地满足了我们的需求。第二个参数`count`，指的是我们希望并发调用的函数，也就是同时调用。最后，`i`是我们传入的参数，它将在被调用时交给`count`函数。

最后，我们使用`for _ in await asyncio.gather(*tasks)`将我们所有的任务添加到一个未来中，这个未来将我们所有的任务聚合成一个结果。

我们的程序将开始创建一个用于调度内循环的外循环，告诉它`run_until_complete`并传入函数`create_tasks()`作为它需要执行的唯一任务。

一旦任务完成，外部循环关闭。虽然我们似乎忘记了关闭内部循环，但当`create_tasks`结束时，它会自动关闭。如果我们试图在函数结束时关闭它，我们会得到一个运行时错误，即我们不能关闭一个正在运行的事件循环。

我希望您运行这段代码，并在输出中寻找任何看起来奇怪的东西。如果你使用小范围，你会看到更少的异常，也许没有。但是如果您这样做了，请不要担心，因为我们并没有以线程安全的方式创建所有这些任务。如果我们想这样做，我们可以一次处理一个任务的结果，如果它们都存储在同一个地方的话。

# 摘要

今天我们学习了协程、任务、未来和事件循环。我认为目前这已经足够好了，但是就异步编程而言，我们还有更多的内容要介绍。没错，兔子洞更深！我们不仅有`asyncio,`,而且还有线程和多处理供我们使用。我们还没有讨论后两者，但是它们即将出现。

如果你有不明白的地方，不要担心。使用异步代码需要时间和经验。探索，自己尝试，不要害怕改变；它总是可以被修复的。

## 推荐阅读

 [## asyncio -异步 I/O - Python 3.7.3 文档

### asyncio 被用作多个 Python 异步框架的基础，这些框架提供了高性能的网络和…

docs.python.org](https://docs.python.org/3/library/asyncio.html) [](https://realpython.com/async-io-python/) [## Python 中的异步 IO:完整的演练-真实的 Python

### Async IO 是一种并发编程设计，在 Python 中获得了专门的支持，它是从 Python 快速发展而来的…

realpython.com](https://realpython.com/async-io-python/) 

# 下一步是什么

更多异步代码，呜呜！只是这次我们不会报道`asyncio`。相反，在`asyncio`可能不理想的地方，我们将寻找其他方法来进行异步编程。当我们讨论完异步的时候，我会添加一篇文章，我发现这篇文章很好地解释了当你选择一个而不是另一个的时候。在那之前，继续练习！

[](https://medium.com/better-programming/beginning-python-programming-part-14-208b9fa2f0a1) [## Python 编程入门—第 14 部分

### 多线程简介

medium.com](https://medium.com/better-programming/beginning-python-programming-part-14-208b9fa2f0a1)