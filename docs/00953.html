<html>
<head>
<title>Reflecting PostgreSQL Databases with Python and SQLAlchemy</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">用Python和SQLAlchemy反映PostgreSQL数据库</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/reflecting-postgresql-databases-using-python-and-sqlalchemy-48b50870d40f?source=collection_archive---------6-----------------------#2019-07-31">https://betterprogramming.pub/reflecting-postgresql-databases-using-python-and-sqlalchemy-48b50870d40f?source=collection_archive---------6-----------------------#2019-07-31</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="b5fc" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">解释ORM中的反向迁移</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/937de2660eb299933005d92ac0c0b767.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*NYNX5r-YQsdz08eo.gif"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">图片来源:<a class="ae kv" href="https://www.andreafiori.net/" rel="noopener ugc nofollow" target="_blank">https://www.andreafiori.net/</a></p></figure><p id="1db3" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们所说的“反映数据库”是什么意思？听起来很奇怪，不是吗？别担心，一切都会解释清楚的。</p><p id="965f" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">你可能听说过ORM世界里的“迁移”。这是将对象转换成真正的数据库表和关系的操作。太好了，那如果你想反过来呢？那叫“反射”。</p><p id="513d" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">当你已经有了一个装满数据的数据库，并且需要使用ORM来处理它时，反射是很有用的。</p></div><div class="ab cl ls lt hu lu" role="separator"><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx"/></div><div class="ij ik il im in"><h1 id="42db" class="lz ma iq bd mb mc md me mf mg mh mi mj jw mk jx ml jz mm ka mn kc mo kd mp mq bi translated">反映单个表格</h1><p id="e922" class="pw-post-body-paragraph kw kx iq ky b kz mr jr lb lc ms ju le lf mt lh li lj mu ll lm ln mv lp lq lr ij bi translated">首先，我们将只把一个表反射到一个Python对象，让我们从创建那个表并插入一些数据开始。我们假设您已经安装了PostgreSQL。</p><p id="5b4b" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">运行以下查询来创建包含三列(id、用户名和电子邮件)的帐户表:</p><pre class="kg kh ki kj gt mw mx my mz aw na bi"><span id="d5dc" class="nb ma iq mx b gy nc nd l ne nf">CREATE TABLE accounts(                                   <br/>id serial PRIMARY KEY, <br/>username VARCHAR(50) UNIQUE NOT NULL, <br/>email VARCHAR(256) UNIQUE NOT NULL);</span></pre></div><div class="ab cl ls lt hu lu" role="separator"><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx"/></div><div class="ij ik il im in"><p id="e816" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们的桌子准备好了，现在让我们输入一些数据</p><pre class="kg kh ki kj gt mw mx my mz aw na bi"><span id="a137" class="nb ma iq mx b gy nc nd l ne nf">INSERT INTO accounts (username, email) VALUES ('user1', 'user1@gmail.com'), ('user2', 'user2@gmail.com');</span></pre><p id="5f4c" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们有一个充满数据的表，现在让我们反映它并查询它。<br/>首先我们需要安装<em class="ng"> SQLAlchemy、</em>这是使用的ORM，以及<em class="ng"> psycopg2 </em>这是Python的原生PostgreSQL驱动程序:</p><pre class="kg kh ki kj gt mw mx my mz aw na bi"><span id="3858" class="nb ma iq mx b gy nc nd l ne nf">pip3 install sqlalchemy psycopg2</span></pre><blockquote class="nh ni nj"><p id="b387" class="kw kx ng ky b kz la jr lb lc ld ju le nk lg lh li nl lk ll lm nm lo lp lq lr ij bi translated">linux上的psycopg2依赖于python3-devel和postgresql-devel包，所以一定要安装它们</p></blockquote><p id="84d5" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">下面的代码将表反映给一个类，然后查询数据:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nn no l"/></div></figure><p id="4b43" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">现在我们的表被成功地反映出来，查询也正常工作了，是时候反映整个数据库了！是的，在生产系统中，您可以找到数十或数百个表，而不仅仅是一个单独的表。</p></div><div class="ab cl ls lt hu lu" role="separator"><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx"/></div><div class="ij ik il im in"><h1 id="04dd" class="lz ma iq bd mb mc md me mf mg mh mi mj jw mk jx ml jz mm ka mn kc mo kd mp mq bi translated"><strong class="ak">反映数据库</strong></h1><p id="a49d" class="pw-post-body-paragraph kw kx iq ky b kz mr jr lb lc ms ju le lf mt lh li lj mu ll lm ln mv lp lq lr ij bi translated">我们将模拟一个生产数据库，其中包含许多表以及它们之间的关系。一种快速的方法是导入一个数据库示例。我在网上找到的一个很好的例子是dvd租赁数据库——你可以在这里下载。</p><p id="a6fe" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这是一个zip存档文件——解压它，您将得到一个tar存档文件。要将tar存档导入PostgreSQL，首先创建一个新的数据库:</p><pre class="kg kh ki kj gt mw mx my mz aw na bi"><span id="24d5" class="nb ma iq mx b gy nc nd l ne nf">CREATE DATABASE dvdrental;</span></pre><p id="b5c8" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">现在让我们使用pg_restore导入它:</p><pre class="kg kh ki kj gt mw mx my mz aw na bi"><span id="c727" class="nb ma iq mx b gy nc nd l ne nf">pg_restore -U postgres -d dvdrental dvdrental.tar</span></pre><p id="012b" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们的数据库准备好了。如果您尝试使用您最喜欢的PostgreSQL客户端连接到它，您会发现15个充满数据的表——很棒吧？但是如何使用SQLAlchemy来反映这一点呢？</p><p id="b86c" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">SQLAlchemy有一个名为<em class="ng"> automap的扩展。它从数据库中自动生成类和关系。让我们试一试:</em></p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nn no l"/></div></figure><p id="9562" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">如果运行上面的代码，将会打印出一个包含15个表名的列表。这些名称是从数据库表中反映出来的类！现在的问题是如何查询它们。</p><p id="71ca" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">首先，我们需要将代码扫描的数据库表映射到Python对象。此外，我们需要一个会话来进行查询。添加以下代码:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nn no l"/></div></figure><p id="84dc" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这很好——我们可以从反射数据库中查询单个表。但是关系呢？</p><p id="1f7d" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">别担心，SQLAlchemy会帮你处理的。automap扩展自动反映关系，并支持一对多、多对多和多对一。automap反映的关系将被命名为<related_table> _collection。</related_table></p><p id="02ad" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们的示例数据库中的示例关系是表电影和表语言之间的关系——多对一关系。所以我们来拿一个英文片列表(要知道英文是语言表的第一排):</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nn no l"/></div></figure><p id="9ea6" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">完成了吗？真快！</p><p id="2746" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我知道——这不是一个深入的指南，但这里的目标是用简单的例子阐明数据库反射。</p><p id="b749" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">如果你想进一步阅读，请关注<a class="ae kv" href="https://docs.sqlalchemy.org/en/13/" rel="noopener ugc nofollow" target="_blank"> SQLAlchemy官方文件</a>。</p></div></div>    
</body>
</html>