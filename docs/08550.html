<html>
<head>
<title>3 Data Processing Pipelines You Can Build With Python Generators</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">您可以使用Python生成器构建3个数据处理管道</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/3-data-processing-pipelines-you-can-build-with-python-generators-dc0d2019b177?source=collection_archive---------3-----------------------#2021-05-13">https://betterprogramming.pub/3-data-processing-pipelines-you-can-build-with-python-generators-dc0d2019b177?source=collection_archive---------3-----------------------#2021-05-13</a></blockquote><div><div class="fc ii ij ik il im"/><div class="in io ip iq ir"><div class=""/><div class=""><h2 id="1c68" class="pw-subtitle-paragraph jr it iu bd b js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki dk translated">使用生成器在Python中创建数据处理管道</h2></div><figure class="kk kl km kn gu ko gi gj paragraph-image"><div role="button" tabindex="0" class="kp kq di kr bf ks"><div class="gi gj kj"><img src="../Images/886a5793325ce3dcff7a05771f6c26ec.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*M1PCtJmjDD3EIgQKWFeV7A.jpeg"/></div></div><p class="kv kw gk gi gj kx ky bd b be z dk translated">照片由<a class="ae kz" href="https://elements.envato.com/user/maxxyustas" rel="noopener ugc nofollow" target="_blank"> maxxyustas </a>拍摄，版权通过<a class="ae kz" href="https://elements.envato.com/license-terms" rel="noopener ugc nofollow" target="_blank"> Envato元素</a>获得。</p></figure><p id="f6f9" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">自从我看了David Beazley关于Python中的生成器的演示，我就被它们迷住了。如果没看，推荐看<a class="ae kz" href="https://www.youtube.com/watch?v=RZ4Sn-Y7AP8&amp;t=2477s&amp;ab_channel=PyCon2014" rel="noopener ugc nofollow" target="_blank"> Python探索</a>。</p><p id="0d9c" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">Python生成器是一个强大的概念。您可以使用它们来创建非常高效的数据处理管道。在本文中，我将向您展示三个实际的例子。</p><p id="3edd" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">我们将看到如何将几个过滤器串在一起创建一个数据处理管道。该管道能够处理大型数据集或数据流。使用生成器的最大好处是你不会耗尽机器的内存。</p><p id="9238" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">下图显示了我们想要创建的内容。我们希望通过组合一组过滤器来处理数据流。最终的解决方案应该使添加、移除或改变过滤器变得容易。</p><figure class="kk kl km kn gu ko gi gj paragraph-image"><div role="button" tabindex="0" class="kp kq di kr bf ks"><div class="gi gj lw"><img src="../Images/39366cfe173bdf30db3d326949d7311f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*NBaHvGiUw3DJvWYwk76rDg.jpeg"/></div></div><p class="kv kw gk gi gj kx ky bd b be z dk translated">链接多个过滤器以创建处理管道。图片由作者提供。</p></figure><p id="bca0" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">这种管道和过滤器模式并不新鲜。它经常在类Unix操作系统中使用，通过组合命令来构造强大的命令行。例如，此命令行使用管道符号<code class="fe lx ly lz ma b">|</code>将几个命令连接在一起:</p><pre class="kk kl km kn gu mb ma mc md aw me bi"><span id="0bf6" class="mf mg iu ma b gz mh mi l mj mk">$ ps aux | grep [processtokill_name] | grep -v grep | awk '{print $2}' | xargs kill</span></pre><p id="0924" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">该模式也被描述为架构模式。例如，在<em class="ml">面向模式的软件架构</em>中，Buschmann等人将其描述为:</p><blockquote class="mm mn mo"><p id="2fe3" class="la lb ml lc b ld le jv lf lg lh jy li mp lk ll lm mq lo lp lq mr ls lt lu lv in bi translated">“管道和过滤器架构模式为处理数据流的系统提供了一种结构。每个处理步骤都封装在一个过滤器组件中。数据通过相邻过滤器之间的管道传递。重新组合过滤器允许您构建相关系统的系列。”</p></blockquote><p id="3825" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">在<em class="ml">企业集成模式</em>中，Gregory Hope写道:</p><blockquote class="mm mn mo"><p id="d241" class="la lb ml lc b ld le jv lf lg lh jy li mp lk ll lm mq lo lp lq mr ls lt lu lv in bi translated">使用<em class="iu">管道和过滤器</em>架构风格将较大的处理任务划分为一系列较小的独立处理步骤(过滤器)，这些步骤通过通道(管道)连接</p></blockquote><p id="231d" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">有趣的是，Hope和Buschmann在系统的上下文中讨论了这种模式。相反，我将使用Python中的三个实际例子来演示该模式。这些示例将:</p><ul class=""><li id="7d35" class="ms mt iu lc b ld le lg lh lj mu ln mv lr mw lv mx my mz na bi translated">从CSV文件中计算所有A轮融资的总和。</li><li id="d332" class="ms mt iu lc b ld nb lg nc lj nd ln ne lr nf lv mx my mz na bi translated">计算网络服务器传输的字节数。</li><li id="d868" class="ms mt iu lc b ld nb lg nc lj nd ln ne lr nf lv mx my mz na bi translated">计算文件系统中目录的大小。</li></ul><p id="30c1" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">我将仔细检查源代码的每一部分。如果你等不及，可以在<a class="ae kz" href="https://github.com/PatrickKalkman/python-processing-pipeline" rel="noopener ugc nofollow" target="_blank">这个GitHub库</a>里找到。</p></div><div class="ab cl ng nh hy ni" role="separator"><span class="nj bw bk nk nl nm"/><span class="nj bw bk nk nl nm"/><span class="nj bw bk nk nl"/></div><div class="in io ip iq ir"><h1 id="9e38" class="nn mg iu bd no np nq nr ns nt nu nv nw ka nx kb ny kd nz ke oa kg ob kh oc od bi translated">1.计算所有首轮融资的总额</h1><p id="fe27" class="pw-post-body-paragraph la lb iu lc b ld oe jv lf lg of jy li lj og ll lm ln oh lp lq lr oi lt lu lv in bi translated">在第一个示例中，我们创建了一个处理管道来计算一家公司通过首轮融资获得的资金总额。我们通过解析来自CrunchBase的CSV文件来计算总数。</p><p id="1cd6" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">下图显示了解析CSV文件的处理管道:</p><figure class="kk kl km kn gu ko gi gj paragraph-image"><div role="button" tabindex="0" class="kp kq di kr bf ks"><div class="gi gj oj"><img src="../Images/5aa9f3fd76fdc7875b1abbff62a68348.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*1mHxe1S1Z7AgTRohZKy_6Q.jpeg"/></div></div><p class="kv kw gk gi gj kx ky bd b be z dk translated">使用过滤器将CSV转换为总数。图片由作者提供。</p></figure><p id="3d45" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">Crunchbase是一个提供投资和融资信息的平台。除了API，他们还通过CSV提供数据。你必须为完整版本付费。我用的是这个<a class="ae kz" href="https://data.crunchbase.com/docs/daily-csv-export" rel="noopener ugc nofollow" target="_blank">免费样品</a>。</p><figure class="kk kl km kn gu ko"><div class="bz fq l di"><div class="ok ol l"/></div><p class="kv kw gk gi gj kx ky bd b be z dk translated">通过组合多个过滤器创建数据处理管道。</p></figure><p id="e39d" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">上面的Python脚本读取CSV文件，并返回所有A轮融资的总和。“首轮”融资是初创企业获得的第一笔风险资本。</p><p id="eadc" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">在第7行，我们使用Python列表定义了管道。我把列表中的每一项都称为过滤器。我们用一个<code class="fe lx ly lz ma b">file_filter</code>来打开一个文件。第二个过滤器使用Python <code class="fe lx ly lz ma b">DictReader</code>来读取CSV。<code class="fe lx ly lz ma b">series_a_filter</code>只选择A类型的记录。最后一个<code class="fe lx ly lz ma b">sum_filter</code>对每个A系列记录的资金进行求和。</p><p id="971a" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated"><code class="fe lx ly lz ma b">log_filter</code>是一个过滤器，你可以把它放在管道的任何地方。它记录每个通过通道的项目。</p><p id="bbad" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">如果我们使用<code class="fe lx ly lz ma b">print(next(pipeline))</code>运行管道，我们会得到以下输出:</p><figure class="kk kl km kn gu ko gi gj paragraph-image"><div role="button" tabindex="0" class="kp kq di kr bf ks"><div class="gi gj om"><img src="../Images/0fac2c4ea4bb60308adfc83a72177800.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*JyKmxJcYd6GRsjHM6bfwEA.png"/></div></div><p class="kv kw gk gi gj kx ky bd b be z dk translated">执行处理流水线。图片由作者提供。</p></figure><h2 id="dc8e" class="mf mg iu bd no on oo dn ns op oq dp nw lj or os ny ln ot ou oa lr ov ow oc ox bi translated">单个过滤器</h2><p id="4a81" class="pw-post-body-paragraph la lb iu lc b ld oe jv lf lg of jy li lj og ll lm ln oh lp lq lr oi lt lu lv in bi translated">在本例中，我们看到使用了几个滤波器。每个过滤器都是使用Python函数实现的。过滤器的一般规则是它接受一个生成器并返回一个生成器。生成器是使用<code class="fe lx ly lz ma b">yield</code>语句创建的。</p><p id="fba3" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">让我们看看每个过滤器，并检查其实施。</p><h2 id="659f" class="mf mg iu bd no on oo dn ns op oq dp nw lj or os ny ln ot ou oa lr ov ow oc ox bi translated">文件过滤器</h2><p id="c6c2" class="pw-post-body-paragraph la lb iu lc b ld oe jv lf lg of jy li lj og ll lm ln oh lp lq lr oi lt lu lv in bi translated">文件过滤器接受文件名列表，打开文件，并使用<code class="fe lx ly lz ma b">yield</code>语句返回打开的文件。</p><figure class="kk kl km kn gu ko"><div class="bz fq l di"><div class="ok ol l"/></div><p class="kv kw gk gi gj kx ky bd b be z dk translated">文件过滤器</p></figure><h2 id="e945" class="mf mg iu bd no on oo dn ns op oq dp nw lj or os ny ln ot ou oa lr ov ow oc ox bi translated">字典过滤器</h2><p id="3e1a" class="pw-post-body-paragraph la lb iu lc b ld oe jv lf lg of jy li lj og ll lm ln oh lp lq lr oi lt lu lv in bi translated">dict过滤器使用来自CSV模块的Python <code class="fe lx ly lz ma b">DictReader</code>。它创建一个读取器，将每行中的列映射到一个字典。字典的键是从文件的第一行检索的。CSV中的第一行通常表示列名。</p><p id="9d50" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated"><code class="fe lx ly lz ma b">dict_filter</code>检索一个打开的文件，并使用打开的文件创建<code class="fe lx ly lz ma b">DictReader</code>。然后，它遍历所有行，并使用<code class="fe lx ly lz ma b">yield</code>语句返回每一行。</p><figure class="kk kl km kn gu ko"><div class="bz fq l di"><div class="ok ol l"/></div><p class="kv kw gk gi gj kx ky bd b be z dk translated">字典过滤器</p></figure><h2 id="f85b" class="mf mg iu bd no on oo dn ns op oq dp nw lj or os ny ln ot ou oa lr ov ow oc ox bi translated">A系列过滤器</h2><p id="2446" class="pw-post-body-paragraph la lb iu lc b ld oe jv lf lg of jy li lj og ll lm ln oh lp lq lr oi lt lu lv in bi translated">CSV包含几种融资类型的记录，例如A、B和c系列。我们只需要A系列的记录。A系列滤波器正是这样做的。它只过滤A系列记录。</p><figure class="kk kl km kn gu ko"><div class="bz fq l di"><div class="ok ol l"/></div><p class="kv kw gk gi gj kx ky bd b be z dk translated">该系列A过滤器</p></figure><p id="c2a6" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">该实现对所有行进行迭代。我们通过检查列“round”是否包含“A”来确定该行是否包含A轮融资。</p><p id="ade3" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">我想你已经开始看到一种模式了。每个过滤器都有一个可枚举的输入和<code class="fe lx ly lz ma b">yield</code>作为输出。</p><h2 id="fbb7" class="mf mg iu bd no on oo dn ns op oq dp nw lj or os ny ln ot ou oa lr ov ow oc ox bi translated">总和过滤器</h2><p id="061e" class="pw-post-body-paragraph la lb iu lc b ld oe jv lf lg of jy li lj og ll lm ln oh lp lq lr oi lt lu lv in bi translated">最后一个功能滤波器是求和滤波器。它负责计算首轮融资的总额。</p><figure class="kk kl km kn gu ko"><div class="bz fq l di"><div class="ok ol l"/></div></figure><p id="f9e4" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">与每个过滤器一样，它接收一个迭代器，并使用<code class="fe lx ly lz ma b">yield</code>语句返回总和。</p><h2 id="d214" class="mf mg iu bd no on oo dn ns op oq dp nw lj or os ny ln ot ou oa lr ov ow oc ox bi translated"><strong class="ak">日志过滤器</strong></h2><p id="c978" class="pw-post-body-paragraph la lb iu lc b ld oe jv lf lg of jy li lj og ll lm ln oh lp lq lr oi lt lu lv in bi translated">日志过滤器可以在每个过滤器之前或之后使用。它只做一件事:遍历传入的输入，记录条目，并使用<code class="fe lx ly lz ma b">yield</code>返回条目。</p><figure class="kk kl km kn gu ko"><div class="bz fq l di"><div class="ok ol l"/></div><p class="kv kw gk gi gj kx ky bd b be z dk translated">用于记录项目的日志过滤器。</p></figure><h2 id="a6fc" class="mf mg iu bd no on oo dn ns op oq dp nw lj or os ny ln ot ou oa lr ov ow oc ox bi translated">组合过滤器</h2><p id="1650" class="pw-post-body-paragraph la lb iu lc b ld oe jv lf lg of jy li lj og ll lm ln oh lp lq lr oi lt lu lv in bi translated">最后，我们需要组合每个过滤器来创建管道。好好看看<code class="fe lx ly lz ma b">create_processing_pipeline</code>函数。该函数将单个过滤器串在一起。</p><figure class="kk kl km kn gu ko"><div class="bz fq l di"><div class="ok ol l"/></div><p class="kv kw gk gi gj kx ky bd b be z dk translated">将单个过滤器串在一起以创建处理流水线。</p></figure></div><div class="ab cl ng nh hy ni" role="separator"><span class="nj bw bk nk nl nm"/><span class="nj bw bk nk nl nm"/><span class="nj bw bk nk nl"/></div><div class="in io ip iq ir"><h1 id="b994" class="nn mg iu bd no np nq nr ns nt nu nv nw ka nx kb ny kd nz ke oa kg ob kh oc od bi translated">2.计算web服务器传输的字节数</h1><p id="4dc0" class="pw-post-body-paragraph la lb iu lc b ld oe jv lf lg of jy li lj og ll lm ln oh lp lq lr oi lt lu lv in bi translated">在第二个例子中，我们创建了一个处理管道来计算Apache服务器提供的总字节数。总数是通过解析访问日志计算出来的。</p><p id="aa6e" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">下图显示了解析Apache服务器日志的处理管道:</p><figure class="kk kl km kn gu ko gi gj paragraph-image"><div role="button" tabindex="0" class="kp kq di kr bf ks"><div class="gi gj oy"><img src="../Images/8e86b7077523640346cb12d5011665bb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*b7_aSEgoiUxYPkYjQl2K1g.jpeg"/></div></div><p class="kv kw gk gi gj kx ky bd b be z dk translated">计算Apache服务器提供的总字节数。图片由作者提供。</p></figure><p id="2d4a" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">管道的创建与前面的示例非常相似。第一个过滤器遍历访问日志的给定文件名，打开每个文件，并逐行读取。</p><p id="4cc4" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">访问日志的一行如下所示:</p><pre class="kk kl km kn gu mb ma mc md aw me bi"><span id="2ad4" class="mf mg iu ma b gz mh mi l mj mk">127.0.0.1 — — [10/May/2013:10:35:35 +0200] “GET /favicon.ico HTTP/1.1” 404 295</span></pre><p id="37e0" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">末尾的最后一个数字<code class="fe lx ly lz ma b">295</code>表示网络服务器传输的字节数。无字节传输时，为<code class="fe lx ly lz ma b">“-”</code>。</p><p id="a897" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">字节过滤器解析这一行并返回最后一部分。“转换字节”过滤器将字符串转换为整数。当指示<code class="fe lx ly lz ma b">“-”</code>时，转换字节过滤器返回零。</p><p id="ecdf" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">最后一个过滤器，sum过滤器，计算总字节数。</p><h2 id="c50c" class="mf mg iu bd no on oo dn ns op oq dp nw lj or os ny ln ot ou oa lr ov ow oc ox bi translated">单个过滤器</h2><p id="c911" class="pw-post-body-paragraph la lb iu lc b ld oe jv lf lg of jy li lj og ll lm ln oh lp lq lr oi lt lu lv in bi translated">在本例中，每个过滤器都是使用Python函数实现的。过滤器的一般规则是它接受一个生成器并返回一个生成器。生成器是使用<code class="fe lx ly lz ma b">yield</code>语句创建的。</p><p id="1859" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">让我们看看过滤器并检查它们的实现。</p><h2 id="9d9a" class="mf mg iu bd no on oo dn ns op oq dp nw lj or os ny ln ot ou oa lr ov ow oc ox bi translated">文件过滤器</h2><p id="bd57" class="pw-post-body-paragraph la lb iu lc b ld oe jv lf lg of jy li lj og ll lm ln oh lp lq lr oi lt lu lv in bi translated">文件过滤器与前面的示例相同。它接收文件名列表，并使用<code class="fe lx ly lz ma b">yield</code>返回打开的文件。</p><h2 id="0fc4" class="mf mg iu bd no on oo dn ns op oq dp nw lj or os ny ln ot ou oa lr ov ow oc ox bi translated">线路滤波器</h2><p id="0af2" class="pw-post-body-paragraph la lb iu lc b ld oe jv lf lg of jy li lj og ll lm ln oh lp lq lr oi lt lu lv in bi translated">行过滤器负责逐行读取打开的文件。它使用<code class="fe lx ly lz ma b">yield</code>语句返回每一行。</p><figure class="kk kl km kn gu ko"><div class="bz fq l di"><div class="ok ol l"/></div><p class="kv kw gk gi gj kx ky bd b be z dk translated">行过滤器读取打开的文件中的所有行。</p></figure><h2 id="f2b9" class="mf mg iu bd no on oo dn ns op oq dp nw lj or os ny ln ot ou oa lr ov ow oc ox bi translated">字节过滤器</h2><p id="405a" class="pw-post-body-paragraph la lb iu lc b ld oe jv lf lg of jy li lj og ll lm ln oh lp lq lr oi lt lu lv in bi translated">字节过滤器拆分该行，并在行尾返回令牌。这个令牌可以是一个破折号。</p><pre class="kk kl km kn gu mb ma mc md aw me bi"><span id="5c2c" class="mf mg iu ma b gz mh mi l mj mk">127.0.0.1 — — [10/May/2013:10:35:35 +0200] “GET /favicon.ico HTTP/1.1” 404 295</span></pre><figure class="kk kl km kn gu ko"><div class="bz fq l di"><div class="ok ol l"/></div><p class="kv kw gk gi gj kx ky bd b be z dk translated">字节过滤器返回传输的字节数。</p></figure><p id="ed3e" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">它使用<code class="fe lx ly lz ma b">rsplit</code>以最大<code class="fe lx ly lz ma b">1</code>分割从右侧分割该行。然后我们得到两个项目。我们从索引<code class="fe lx ly lz ma b">1</code>处的项目中获取字节数。</p><h2 id="7473" class="mf mg iu bd no on oo dn ns op oq dp nw lj or os ny ln ot ou oa lr ov ow oc ox bi translated">转换字节过滤器</h2><p id="c635" class="pw-post-body-paragraph la lb iu lc b ld oe jv lf lg of jy li lj og ll lm ln oh lp lq lr oi lt lu lv in bi translated">转换字节过滤器负责将字节字符串转换成数字。字节字符串可以包含数字或破折号。</p><p id="d8dd" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">我使用生成器表达式而不是使用<code class="fe lx ly lz ma b">yield</code>语句实现了这个过滤器。生成器表达式看起来像列表理解，但返回的是生成器而不是列表。通过在语句周围添加大括号，可以将列表理解转换为生成器表达式。</p><figure class="kk kl km kn gu ko"><div class="bz fq l di"><div class="ok ol l"/></div><p class="kv kw gk gi gj kx ky bd b be z dk translated">如果可用，转换字节过滤器将字符串转换成int。</p></figure><h2 id="a5d4" class="mf mg iu bd no on oo dn ns op oq dp nw lj or os ny ln ot ou oa lr ov ow oc ox bi translated">总和过滤器</h2><p id="a8f1" class="pw-post-body-paragraph la lb iu lc b ld oe jv lf lg of jy li lj og ll lm ln oh lp lq lr oi lt lu lv in bi translated">最后一个滤波器是求和滤波器。它只是使用<code class="fe lx ly lz ma b">yield</code>语句返回总和。</p><figure class="kk kl km kn gu ko"><div class="bz fq l di"><div class="ok ol l"/></div><p class="kv kw gk gi gj kx ky bd b be z dk translated">总和过滤器返回所有传输字节的总和。</p></figure><h2 id="894e" class="mf mg iu bd no on oo dn ns op oq dp nw lj or os ny ln ot ou oa lr ov ow oc ox bi translated">组合过滤器</h2><p id="8b0d" class="pw-post-body-paragraph la lb iu lc b ld oe jv lf lg of jy li lj og ll lm ln oh lp lq lr oi lt lu lv in bi translated">过滤器的组合方式与上例相同。如果我们运行该脚本，我们会得到以下输出:</p><figure class="kk kl km kn gu ko gi gj paragraph-image"><div role="button" tabindex="0" class="kp kq di kr bf ks"><div class="gi gj oz"><img src="../Images/e0451211578c6a991494c6f3a44455c5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*xzAg-lgBGphslkm8xVxJtg.png"/></div></div><p class="kv kw gk gi gj kx ky bd b be z dk translated">执行处理流水线。图片由作者提供。</p></figure></div><div class="ab cl ng nh hy ni" role="separator"><span class="nj bw bk nk nl nm"/><span class="nj bw bk nk nl nm"/><span class="nj bw bk nk nl"/></div><div class="in io ip iq ir"><h1 id="93fd" class="nn mg iu bd no np nq nr ns nt nu nv nw ka nx kb ny kd nz ke oa kg ob kh oc od bi translated">3.计算目录中所有文件的总和</h1><p id="0774" class="pw-post-body-paragraph la lb iu lc b ld oe jv lf lg of jy li lj og ll lm ln oh lp lq lr oi lt lu lv in bi translated">在第三个也是最后一个示例中，我们创建了一个处理管道来计算目录中所有文件的总大小。</p><p id="d5d0" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">下图显示了计算目录中所有文件总和的处理管道:</p><figure class="kk kl km kn gu ko gi gj paragraph-image"><div role="button" tabindex="0" class="kp kq di kr bf ks"><div class="gi gj pa"><img src="../Images/4432dbf6cf91ef6d5200513ceed661e5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*d2sVJu54acoPxGqG43iCbA.jpeg"/></div></div><p class="kv kw gk gi gj kx ky bd b be z dk translated">计算目录中所有文件的总文件数。图片由作者提供。</p></figure><p id="e602" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">同样，实现看起来很像前面的例子，但是使用了不同的过滤器。第一个过滤器<code class="fe lx ly lz ma b">collect_filter</code>，递归地收集一个目录中的所有文件。</p><p id="4e2c" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated"><code class="fe lx ly lz ma b">size_filter</code>接收文件名并确定文件的大小。最后一个过滤器<code class="fe lx ly lz ma b">sum_filter</code>计算总大小。</p><h2 id="64fc" class="mf mg iu bd no on oo dn ns op oq dp nw lj or os ny ln ot ou oa lr ov ow oc ox bi translated">单个过滤器</h2><p id="0a84" class="pw-post-body-paragraph la lb iu lc b ld oe jv lf lg of jy li lj og ll lm ln oh lp lq lr oi lt lu lv in bi translated">与其他两个示例一样，每个过滤器都是使用Python函数实现的，该函数接受并返回一个生成器。让我们看看过滤器并检查它们的实现。</p><h2 id="6fa4" class="mf mg iu bd no on oo dn ns op oq dp nw lj or os ny ln ot ou oa lr ov ow oc ox bi translated">收集过滤器</h2><p id="6686" class="pw-post-body-paragraph la lb iu lc b ld oe jv lf lg of jy li lj og ll lm ln oh lp lq lr oi lt lu lv in bi translated">收集过滤器负责收集目录中的所有文件。为了收集文件，我们使用<code class="fe lx ly lz ma b">iglob</code>。这是一个可以递归搜索目录的函数。它返回一个生成器。</p><p id="198a" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">因为我想包含隐藏文件，所以我将两个<code class="fe lx ly lz ma b">glob</code>函数链接在一起。第二个是搜索隐藏文件。结果是一个传递文件的迭代器。</p><figure class="kk kl km kn gu ko"><div class="bz fq l di"><div class="ok ol l"/></div></figure><h2 id="ab88" class="mf mg iu bd no on oo dn ns op oq dp nw lj or os ny ln ot ou oa lr ov ow oc ox bi translated">尺寸过滤器</h2><p id="13c6" class="pw-post-body-paragraph la lb iu lc b ld oe jv lf lg of jy li lj og ll lm ln oh lp lq lr oi lt lu lv in bi translated">大小过滤器负责获取文件的大小。它使用<code class="fe lx ly lz ma b">os.path.getsize()</code>来获取文件的字节大小。</p><figure class="kk kl km kn gu ko"><div class="bz fq l di"><div class="ok ol l"/></div><p class="kv kw gk gi gj kx ky bd b be z dk translated">大小过滤器以字节为单位返回文件的大小。</p></figure><h2 id="c8d1" class="mf mg iu bd no on oo dn ns op oq dp nw lj or os ny ln ot ou oa lr ov ow oc ox bi translated">总和过滤器</h2><p id="3e1e" class="pw-post-body-paragraph la lb iu lc b ld oe jv lf lg of jy li lj og ll lm ln oh lp lq lr oi lt lu lv in bi translated">最后一个滤波器是求和滤波器。它只是使用<code class="fe lx ly lz ma b">yield</code>语句返回所有大小的总和。</p><figure class="kk kl km kn gu ko"><div class="bz fq l di"><div class="ok ol l"/></div><p class="kv kw gk gi gj kx ky bd b be z dk translated">sum筛选器以字节为单位计算总大小。</p></figure><h2 id="b2ac" class="mf mg iu bd no on oo dn ns op oq dp nw lj or os ny ln ot ou oa lr ov ow oc ox bi translated">组合过滤器</h2><p id="1acd" class="pw-post-body-paragraph la lb iu lc b ld oe jv lf lg of jy li lj og ll lm ln oh lp lq lr oi lt lu lv in bi translated">我们以与前面的管道相同的方式组合各个过滤器。如果我们运行该脚本，我们会得到以下输出:</p><figure class="kk kl km kn gu ko gi gj paragraph-image"><div role="button" tabindex="0" class="kp kq di kr bf ks"><div class="gi gj pb"><img src="../Images/e87a500cd97b5554773a739d563d538e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*f_WZTdszGMkAnD2w39FZcA.png"/></div></div><p class="kv kw gk gi gj kx ky bd b be z dk translated">执行处理流水线。图片由作者提供。</p></figure></div><div class="ab cl ng nh hy ni" role="separator"><span class="nj bw bk nk nl nm"/><span class="nj bw bk nk nl nm"/><span class="nj bw bk nk nl"/></div><div class="in io ip iq ir"><h1 id="7021" class="nn mg iu bd no np nq nr ns nt nu nv nw ka nx kb ny kd nz ke oa kg ob kh oc od bi translated">结论</h1><p id="b583" class="pw-post-body-paragraph la lb iu lc b ld oe jv lf lg of jy li lj og ll lm ln oh lp lq lr oi lt lu lv in bi translated">看完这三个例子后，我希望您同意Python生成器是一个强大的概念。</p><p id="2578" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">生成器允许您从使用迭代结果的代码中分离迭代。通过一次处理一个项目，不需要将整个数据集加载到内存中。这意味着您可以处理的数据大小没有限制。</p><p id="495f" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">这三个例子都使用了一种通用的方法，通过Python函数和<code class="fe lx ly lz ma b">yield</code>语句来定义和连接过滤器。利用这种结构，很容易通过修改或重新排列过滤器来构建不同的管线。</p><p id="f4f0" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">你可以在<a class="ae kz" href="https://github.com/PatrickKalkman/python-processing-pipeline" rel="noopener ugc nofollow" target="_blank">这个GitHub库</a>中找到例子的源代码。</p><p id="0b3e" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">感谢阅读。我希望这篇文章能给你创建自己的处理管道的灵感。请在下面留下您的回复，让我知道您创建了什么类型的管道。</p></div></div>    
</body>
</html>