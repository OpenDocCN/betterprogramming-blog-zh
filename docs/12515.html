<html>
<head>
<title>Build Super Fast gRPC APIs With Go and Java</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">用Go和Java构建超快速gRPC APIs</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/grpc-fieldmask-only-request-for-needed-data-build-super-fast-apis-example-with-golang-and-8953089e88a3?source=collection_archive---------3-----------------------#2022-06-10">https://betterprogramming.pub/grpc-fieldmask-only-request-for-needed-data-build-super-fast-apis-example-with-golang-and-8953089e88a3?source=collection_archive---------3-----------------------#2022-06-10</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="dd4f" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">[gRPC]字段掩码—仅请求所需的数据</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/095840499b73a0232ddd5c27b8ad517f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*5SAVISwbDOIeda9NvG4zuw.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">带Java服务器的gRPC(客户端)和带字段掩码的Go客户端示例</p></figure><h1 id="5d05" class="ky kz it bd la lb lc ld le lf lg lh li jz lj ka lk kc ll kd lm kf ln kg lo lp bi translated">gRPC是什么？</h1><p id="2eb5" class="pw-post-body-paragraph lq lr it ls b lt lu ju lv lw lx jx ly lz ma mb mc md me mf mg mh mi mj mk ml im bi translated">gRPC不是Google远程过程调用:-D</p><p id="6c2f" class="pw-post-body-paragraph lq lr it ls b lt mm ju lv lw mn jx ly lz mo mb mc md mp mf mg mh mq mj mk ml im bi translated">gRPC代表gRPC远程过程调用，最初由Google开发。</p><p id="a160" class="pw-post-body-paragraph lq lr it ls b lt mm ju lv lw mn jx ly lz mo mb mc md mp mf mg mh mq mj mk ml im bi translated">它是一个开源、高性能的远程过程调用(RPC)框架，可以在任何地方运行。</p><p id="1d07" class="pw-post-body-paragraph lq lr it ls b lt mm ju lv lw mn jx ly lz mo mb mc md mp mf mg mh mq mj mk ml im bi translated">它有效地允许客户端应用程序直接调用位于不同数据中心的不同机器上的服务器应用程序上的方法，该方法以不同的编程语言编写，就像是本地方法一样，这使得我们更容易创建分布式应用程序和服务。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi mr"><img src="../Images/1915b34aac94318203f6ae49da51c982.png" data-original-src="https://miro.medium.com/v2/resize:fit:1042/format:webp/1*SCgKxbtVdaUWX5thgYhJ1g.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">gRPC通信示例</p></figure><p id="3f3b" class="pw-post-body-paragraph lq lr it ls b lt mm ju lv lw mn jx ly lz mo mb mc md mp mf mg mh mq mj mk ml im bi translated">gRPC使用HTTP/2协议进行传输，协议缓冲区作为接口定义语言(IDL)。</p><p id="f2b1" class="pw-post-body-paragraph lq lr it ls b lt mm ju lv lw mn jx ly lz mo mb mc md mp mf mg mh mq mj mk ml im bi translated">它还提供诸如身份验证、双向流和流量控制、阻塞或非阻塞绑定以及取消和超时等功能。</p><h2 id="cf1d" class="ms kz it bd la mt mu dn le mv mw dp li lz mx my lk md mz na lm mh nb nc lo nd bi translated">什么是FieldMask？</h2><p id="66b6" class="pw-post-body-paragraph lq lr it ls b lt lu ju lv lw lx jx ly lz ma mb mc md me mf mg mh mi mj mk ml im bi translated">字段掩码是ProtoBuf的一个简单但非常强大的概念。它有助于使API更加健壮，服务实现更加高效。</p><p id="216d" class="pw-post-body-paragraph lq lr it ls b lt mm ju lv lw mn jx ly lz mo mb mc md mp mf mg mh mq mj mk ml im bi translated">它类似于我们可以在REST APIs中使用的JSON API规范的<em class="ne">稀疏字段集</em>。</p><p id="6f15" class="pw-post-body-paragraph lq lr it ls b lt mm ju lv lw mn jx ly lz mo mb mc md mp mf mg mh mq mj mk ml im bi translated">客户端可以使用FieldMask来指定它们需要从服务器获取的资源数据成员的列表，而不是获取整个资源对象，这可能很大并且会增加网络成本/延迟，此外，服务器可能需要时间来构建整个资源对象(它可能从不同的位置获取数据)。</p><h1 id="ac67" class="ky kz it bd la lb lc ld le lf lg lh li jz lj ka lk kc ll kd lm kf ln kg lo lp bi translated">这个故事的用例</h1><p id="17b7" class="pw-post-body-paragraph lq lr it ls b lt lu ju lv lw lx jx ly lz ma mb mc md me mf mg mh mi mj mk ml im bi translated">我们将创建一个用户消息/资源，其中将有用户的基本信息和地址。我们将为问候用户和获取随机用户创建gRPC APIs。</p><p id="2d9b" class="pw-post-body-paragraph lq lr it ls b lt mm ju lv lw mn jx ly lz mo mb mc md mp mf mg mh mq mj mk ml im bi translated">在获取随机用户API时，我们将使用<code class="fe nf ng nh ni b">FieldMask</code>来不获取用户的<code class="fe nf ng nh ni b">Address</code>(在实时用例中，地址可能存储在不同的表/数据库/位置中)。</p><p id="1056" class="pw-post-body-paragraph lq lr it ls b lt mm ju lv lw mn jx ly lz mo mb mc md mp mf mg mh mq mj mk ml im bi translated">我们将创建<code class="fe nf ng nh ni b">proto</code>文件，用Java实现服务器，用Go实现客户端。</p><h2 id="070d" class="ms kz it bd la mt mu dn le mv mw dp li lz mx my lk md mz na lm mh nb nc lo nd bi translated">先决条件</h2><ul class=""><li id="9fa3" class="nj nk it ls b lt lu lw lx lz nl md nm mh nn ml no np nq nr bi translated">Java 8+</li><li id="4195" class="nj nk it ls b lt ns lw nt lz nu md nv mh nw ml no np nq nr bi translated">Go 1.16+(可选，仅当您想要在Go中创建客户端时)</li><li id="a056" class="nj nk it ls b lt ns lw nt lz nu md nv mh nw ml no np nq nr bi translated">格雷尔还是梅文</li></ul><h2 id="634b" class="ms kz it bd la mt mu dn le mv mw dp li lz mx my lk md mz na lm mh nb nc lo nd bi translated">原型文件</h2><p id="03ba" class="pw-post-body-paragraph lq lr it ls b lt lu ju lv lw lx jx ly lz ma mb mc md me mf mg mh mi mj mk ml im bi translated">gRPC服务是使用协议缓冲区定义的。</p><p id="7cc3" class="pw-post-body-paragraph lq lr it ls b lt mm ju lv lw mn jx ly lz mo mb mc md mp mf mg mh mq mj mk ml im bi translated">协议缓冲区是Google的语言中立、平台中立、可扩展的机制，用于以向前兼容和向后兼容的方式序列化结构化数据。它很像JSON，只不过它更小更快，并且生成本机语言绑定。</p><p id="d455" class="pw-post-body-paragraph lq lr it ls b lt mm ju lv lw mn jx ly lz mo mb mc md mp mf mg mh mq mj mk ml im bi translated">我们将为用例定义协议缓冲区。我们将定义<em class="ne">用户消息协议</em>和<em class="ne">问候用户服务协议</em>。现在让我们创建一个名为<em class="ne"> user_proto </em>的目录，并在这里创建我们的proto文件。它看起来会像这样:</p><ul class=""><li id="76f6" class="nj nk it ls b lt mm lw mn lz nx md ny mh nz ml no np nq nr bi translated"><code class="fe nf ng nh ni b">user_message.proto</code></li></ul><pre class="kj kk kl km gt oa ni ob oc aw od bi"><span id="9f2d" class="ms kz it ni b gy oe of l og oh">syntax = "proto3";<br/><br/>package com.grpc.example;<br/><br/>option java_multiple_files = true;<br/>option java_package = "com.grpc.example.greet.model";<br/>option go_package = "./pb";</span><span id="b23a" class="ms kz it ni b gy oi of l og oh">import "google/protobuf/timestamp.proto";<br/><br/>message User {<br/>  string firstName = 1;<br/>  optional string middleName = 2;<br/>  optional string lastName = 3;<br/>  optional uint32 age = 4;<br/>  repeated UserAddress address = 5;<br/>  google.protobuf.Timestamp currentTime = 6;<br/>}<br/><br/>message UserAddress {<br/>  string addressLine1 = 1;<br/>  optional string addressLine2 = 2;<br/>  string city = 3;<br/>  string country = 4;<br/>  uint32 pincode = 5;<br/>  enum ADDRESS_TYPE {<br/>    <em class="ne">BOTH </em>= 0;<br/>    <em class="ne">PERMANENT </em>= 1;<br/>    <em class="ne">CURRENT </em>= 2;<br/>  }<br/>}</span></pre><ul class=""><li id="bee0" class="nj nk it ls b lt mm lw mn lz nx md ny mh nz ml no np nq nr bi translated"><code class="fe nf ng nh ni b">greet_user_service.proto</code></li></ul><pre class="kj kk kl km gt oa ni ob oc aw od bi"><span id="43f0" class="ms kz it ni b gy oe of l og oh">syntax = "proto3";<br/><br/>package com.grpc.example;<br/><br/>option java_multiple_files = true;<br/>option java_package = "com.grpc.example.greet.service";<br/>option go_package = "./pb";</span><span id="421f" class="ms kz it ni b gy oi of l og oh">import "user_message.proto";<br/>import "google/protobuf/field_mask.proto";<br/><br/>message GreetUserRequest {<br/>    User user = 1;<br/>}<br/><br/>message GreetUserResponse {<br/>  string greetMessage = 1;<br/>}<br/><br/>message GetRandomUserRequest {<br/>  google.protobuf.FieldMask field_mask = 1;<br/>}<br/><br/>message GetRandomUserResponse {<br/>  User user = 1;<br/>}<br/><br/>service GreetUserService {<br/>  rpc GreetUser(GreetUserRequest) returns (GreetUserResponse) {};<br/>  rpc GetRandomUser(GetRandomUserRequest) returns (GetRandomUserResponse) {};<br/>}</span></pre><p id="7db2" class="pw-post-body-paragraph lq lr it ls b lt mm ju lv lw mn jx ly lz mo mb mc md mp mf mg mh mq mj mk ml im bi translated">我们可以看到在<code class="fe nf ng nh ni b">GetRandomUserRequest</code>中，我们增加了<code class="fe nf ng nh ni b">field_mask</code>作为参数。</p></div><div class="ab cl oj ok hx ol" role="separator"><span class="om bw bk on oo op"/><span class="om bw bk on oo op"/><span class="om bw bk on oo"/></div><div class="im in io ip iq"><h2 id="a779" class="ms kz it bd la mt mu dn le mv mw dp li lz mx my lk md mz na lm mh nb nc lo nd bi translated">服务器端实现(带Gradle的Java)</h2><p id="030f" class="pw-post-body-paragraph lq lr it ls b lt lu ju lv lw lx jx ly lz ma mb mc md me mf mg mh mi mj mk ml im bi translated">让我们创建一个简单的Gradle应用程序，并将其导入我们的IDE。为此我将使用IntelliJ IDEA。</p><p id="9778" class="pw-post-body-paragraph lq lr it ls b lt mm ju lv lw mn jx ly lz mo mb mc md mp mf mg mh mq mj mk ml im bi translated">让我们在<code class="fe nf ng nh ni b">build.gradle</code>文件中做些改变，添加gRPC和protobuf支持。我们将添加一些依赖项、protobuf插件和生成proto文件的类实现的指令。</p><p id="b70c" class="pw-post-body-paragraph lq lr it ls b lt mm ju lv lw mn jx ly lz mo mb mc md mp mf mg mh mq mj mk ml im bi translated">我们将添加以下依赖项:</p><pre class="kj kk kl km gt oa ni ob oc aw od bi"><span id="3542" class="ms kz it ni b gy oe of l og oh">implementation group: 'io.grpc', name: 'grpc-all', version: '1.45.0'</span><span id="f115" class="ms kz it ni b gy oi of l og oh">implementation group: 'com.google.protobuf', name: 'protobuf-java', version: '3.15.0'</span><span id="6a06" class="ms kz it ni b gy oi of l og oh">implementation group: 'javax.annotation', name: 'javax.annotation-api', version: '1.3.2'</span></pre><p id="033c" class="pw-post-body-paragraph lq lr it ls b lt mm ju lv lw mn jx ly lz mo mb mc md mp mf mg mh mq mj mk ml im bi translated">我们将添加以下插件:</p><pre class="kj kk kl km gt oa ni ob oc aw od bi"><span id="2831" class="ms kz it ni b gy oe of l og oh">id "com.google.protobuf" version "0.8.18"</span></pre><p id="6b05" class="pw-post-body-paragraph lq lr it ls b lt mm ju lv lw mn jx ly lz mo mb mc md mp mf mg mh mq mj mk ml im bi translated">我们将为原型文件和类生成添加以下指令:</p><pre class="kj kk kl km gt oa ni ob oc aw od bi"><span id="c46d" class="ms kz it ni b gy oe of l og oh">protobuf <strong class="ni iu">{<br/>    </strong>protoc <strong class="ni iu">{<br/>        </strong>artifact = 'com.google.protobuf:protoc:3.15.0'<br/>    <strong class="ni iu">}<br/>    </strong>plugins <strong class="ni iu">{<br/>        </strong>grpc <strong class="ni iu">{<br/>            </strong>artifact = 'io.grpc:protoc-gen-grpc-java:1.45.0'<br/>        <strong class="ni iu">}<br/>    }<br/>    </strong>generateProtoTasks <strong class="ni iu">{<br/>        </strong>all()*.plugins <strong class="ni iu">{<br/>            </strong>grpc <strong class="ni iu">{}<br/>        }<br/>    }<br/>}<br/><br/></strong>sourceSets <strong class="ni iu">{<br/>    </strong>main <strong class="ni iu">{<br/>        </strong>java <strong class="ni iu">{<br/>            </strong>srcDirs 'build/generated/source/proto/main/grpc'<br/>            srcDirs 'build/generated/source/proto/main/java'<br/>        <strong class="ni iu">}<br/>    }<br/>}</strong></span></pre><p id="ed1a" class="pw-post-body-paragraph lq lr it ls b lt mm ju lv lw mn jx ly lz mo mb mc md mp mf mg mh mq mj mk ml im bi translated">我们现在将在<code class="fe nf ng nh ni b">src/main</code> <em class="ne"> </em>中创建一个名为<code class="fe nf ng nh ni b">proto</code>的目录，并将我们的协议缓冲文件复制到这个目录中。这是因为我们的<code class="fe nf ng nh ni b">sourceSet</code>默认配置是从这个位置读取proto文件，我们可以根据需要更改它。</p><p id="2432" class="pw-post-body-paragraph lq lr it ls b lt mm ju lv lw mn jx ly lz mo mb mc md mp mf mg mh mq mj mk ml im bi translated">现在让我们尝试构建我们的项目。它应该在<code class="fe nf ng nh ni b">build.gradle</code>的<code class="fe nf ng nh ni b">sourceSets</code>中提到的包中创建原型文件的存根。</p><p id="d566" class="pw-post-body-paragraph lq lr it ls b lt mm ju lv lw mn jx ly lz mo mb mc md mp mf mg mh mq mj mk ml im bi translated">我们应该创建我们的<code class="fe nf ng nh ni b">GreetingService.java</code>类实现，它将扩展自动生成的<code class="fe nf ng nh ni b">GreetUserServiceGrpc.GreetUserServiceImplBase.java</code>类，并用我们自己的实现覆盖<code class="fe nf ng nh ni b">greetUser</code>和<code class="fe nf ng nh ni b">getRandomUser</code>方法。</p><p id="190f" class="pw-post-body-paragraph lq lr it ls b lt mm ju lv lw mn jx ly lz mo mb mc md mp mf mg mh mq mj mk ml im bi translated">它应该看起来像这样:</p><pre class="kj kk kl km gt oa ni ob oc aw od bi"><span id="ccd9" class="ms kz it ni b gy oe of l og oh">public class GreetingService extends GreetUserServiceGrpc.GreetUserServiceImplBase {<br/><br/>    @Override<br/>    public void greetUser(GreetUserRequest request, StreamObserver&lt;GreetUserResponse&gt; responseObserver) {<br/>        User user = request.getUser();<br/>        String greetMessage = createGreetMessage(user);<br/>        GreetUserResponse response = GreetUserResponse.<em class="ne">newBuilder</em>().setGreetMessage(greetMessage).build();<br/>        responseObserver.onNext(response);<br/>        responseObserver.onCompleted();<br/>    }<br/><br/>    private String createGreetMessage(User user) {<br/>        StringBuilder stringBuilder = new StringBuilder();<br/>        stringBuilder.append("Hello, ")<br/>                .append(user.getFirstName())<br/>                .append(user.hasMiddleName() ? " "+user.getMiddleName() : "")<br/>                .append(user.hasLastName() ? " "+user.getLastName() : "")<br/>                .append("!");<br/>        if(user.getAddressCount() &gt; 0) {<br/>            stringBuilder.append("\nI hope things are good in ")<br/>                    .append(user.getAddress(0).getCity())<br/>                    .append(", ")<br/>                    .append(user.getAddress(0).getCountry());<br/>        }<br/>        return stringBuilder.toString();<br/>    }<br/><br/><br/>    @Override<br/>    public void getRandomUser(GetRandomUserRequest request, StreamObserver&lt;GetRandomUserResponse&gt; responseObserver) {<br/><br/>        User user = User.<em class="ne">newBuilder</em>().setFirstName("John").setLastName("Doe").setAge(26).build();<br/><br/>        for (String s : request.getFieldMask().getPathsList()) {<br/>            if(s.equalsIgnoreCase("address")) {<br/>                UserAddress userAddress = UserAddress.<em class="ne">newBuilder</em>()<br/>                        .setAddressLine1("BR 15")<br/>                        .setCity("PN")<br/>                        .setCountry("IN")<br/>                        .build();<br/>                user = user.toBuilder().addAddress(userAddress).build();<br/>            }<br/>        }<br/><br/>        User.Builder resUserBuilder = User.<em class="ne">newBuilder</em>();<br/><br/>        FieldMaskUtil.<em class="ne">merge</em>(request.getFieldMask(), user, resUserBuilder);<br/><br/>        GetRandomUserResponse response = GetRandomUserResponse.<em class="ne">newBuilder</em>().setUser(resUserBuilder).build();<br/>        responseObserver.onNext(response);<br/>        responseObserver.onCompleted();<br/>    }<br/>}</span></pre><p id="4780" class="pw-post-body-paragraph lq lr it ls b lt mm ju lv lw mn jx ly lz mo mb mc md mp mf mg mh mq mj mk ml im bi translated">我们可以在<code class="fe nf ng nh ni b">getRandomUser</code>方法实现中看到，我们使用字段掩码首先检查是否需要地址字段，然后使用<code class="fe nf ng nh ni b">FieldMaskUtil.merge</code>创建一个只包含被请求数据的对象。</p><p id="6a99" class="pw-post-body-paragraph lq lr it ls b lt mm ju lv lw mn jx ly lz mo mb mc md mp mf mg mh mq mj mk ml im bi translated">我们现在应该创建我们的<code class="fe nf ng nh ni b">GreetingServer.java</code>类，并编写启动gRPC服务器的代码。它应该看起来像这样:</p><pre class="kj kk kl km gt oa ni ob oc aw od bi"><span id="aa16" class="ms kz it ni b gy oe of l og oh">public class GreetingServer {<br/><br/>    private final int port;<br/>    private final Server server;<br/><br/>    public GreetingServer(int port) {<br/>        this(ServerBuilder.<em class="ne">forPort</em>(port), port);<br/>    }<br/><br/>    public GreetingServer(ServerBuilder serverBuilder, int port) {<br/>        this.port = port;<br/>        GreetingService greetingService = new GreetingService();<br/><br/>        server = serverBuilder.addService(greetingService).build();<br/>    }<br/><br/>    public void start() throws IOException {<br/>        server.start();<br/>        System.<em class="ne">out</em>.println("Server Started!!!");<br/>        Runtime.<em class="ne">getRuntime</em>().addShutdownHook(new Thread() {<br/>            @Override<br/>            public void run() {<br/>                try {<br/>                    GreetingServer.this.stop();<br/>                } catch (InterruptedException e) {<br/>                    e.printStackTrace();<br/>                }<br/>            }<br/>        });<br/>    }<br/><br/>    public void stop() throws InterruptedException {<br/>        if(server != null) {<br/>            server.shutdown().awaitTermination(30, TimeUnit.<em class="ne">SECONDS</em>);<br/>        }<br/>    }<br/><br/>    public void blockTillShutdown() throws InterruptedException {<br/>        if(server!=null) {<br/>            server.awaitTermination();<br/>        }<br/>    }<br/><br/>    public static void main(String[] args) throws InterruptedException, IOException {<br/>        GreetingServer greetingServer = new GreetingServer(9090);<br/>        greetingServer.start();<br/>        greetingServer.blockTillShutdown();<br/>    }<br/><br/>}</span></pre><p id="7b23" class="pw-post-body-paragraph lq lr it ls b lt mm ju lv lw mn jx ly lz mo mb mc md mp mf mg mh mq mj mk ml im bi translated">它将在<em class="ne"> 9090 </em>端口启动我们的服务器。请点击<a class="ae oq" href="https://grpc.io/docs/languages/java/quickstart/" rel="noopener ugc nofollow" target="_blank">这里的官方文档链接</a>了解更多关于用Java开发gRPC的细节。</p><p id="21b1" class="pw-post-body-paragraph lq lr it ls b lt mm ju lv lw mn jx ly lz mo mb mc md mp mf mg mh mq mj mk ml im bi translated">我们现在可以编写客户端代码来使用这个API。</p></div><div class="ab cl oj ok hx ol" role="separator"><span class="om bw bk on oo op"/><span class="om bw bk on oo op"/><span class="om bw bk on oo"/></div><div class="im in io ip iq"><h2 id="5c19" class="ms kz it bd la mt mu dn le mv mw dp li lz mx my lk md mz na lm mh nb nc lo nd bi translated">客户端实现(GoLang)</h2><p id="a72e" class="pw-post-body-paragraph lq lr it ls b lt lu ju lv lw lx jx ly lz ma mb mc md me mf mg mh mi mj mk ml im bi translated">让我们创建一个名为<code class="fe nf ng nh ni b">grpc-fieldmask-example-go</code>的简单Go应用程序，并在我们的IDE中打开它。为此，我将使用Visual Studio代码。</p><p id="886d" class="pw-post-body-paragraph lq lr it ls b lt mm ju lv lw mn jx ly lz mo mb mc md mp mf mg mh mq mj mk ml im bi translated">我们先安装协议缓冲编译器，<a class="ae oq" href="https://grpc.io/docs/protoc-installation/" rel="noopener ugc nofollow" target="_blank">点击这里了解更多详情</a>。</p><pre class="kj kk kl km gt oa ni ob oc aw od bi"><span id="82fe" class="ms kz it ni b gy oe of l og oh">brew install protobuf</span><span id="dbcc" class="ms kz it ni b gy oi of l og oh">protoc --version #please ensure if compiler version is 3+</span></pre><p id="ca0b" class="pw-post-body-paragraph lq lr it ls b lt mm ju lv lw mn jx ly lz mo mb mc md mp mf mg mh mq mj mk ml im bi translated">现在，我们应该使用以下命令为Go安装协议编译器插件:</p><pre class="kj kk kl km gt oa ni ob oc aw od bi"><span id="1a80" class="ms kz it ni b gy oe of l og oh">go install google.golang.org/protobuf/cmd/protoc-gen-go@v1.28</span><span id="0714" class="ms kz it ni b gy oi of l og oh">go install google.golang.org/grpc/cmd/protoc-gen-go-grpc@v1.2</span><span id="e483" class="ms kz it ni b gy oi of l og oh">export PATH="$PATH:<strong class="ni iu">$(</strong>go env GOPATH<strong class="ni iu">)</strong>/bin"</span></pre><p id="a031" class="pw-post-body-paragraph lq lr it ls b lt mm ju lv lw mn jx ly lz mo mb mc md mp mf mg mh mq mj mk ml im bi translated">首先，我们将创建一个<code class="fe nf ng nh ni b">proto</code>目录，并将原型文件复制到这里(类似于我们在Java中所做的)</p><p id="75b1" class="pw-post-body-paragraph lq lr it ls b lt mm ju lv lw mn jx ly lz mo mb mc md mp mf mg mh mq mj mk ml im bi translated">下一步是从原型文件创建存根，为此我们将使用以下命令:</p><pre class="kj kk kl km gt oa ni ob oc aw od bi"><span id="e9d5" class="ms kz it ni b gy oe of l og oh">protoc --proto_path=proto proto/*.proto --go_out=. --go-grpc_out=.</span></pre><p id="d405" class="pw-post-body-paragraph lq lr it ls b lt mm ju lv lw mn jx ly lz mo mb mc md mp mf mg mh mq mj mk ml im bi translated">它将创建一个包/目录调用<code class="fe nf ng nh ni b">pb</code>并在这个包中生成存根。我们已经在原型文件中定义了这个包名。</p><p id="9cbd" class="pw-post-body-paragraph lq lr it ls b lt mm ju lv lw mn jx ly lz mo mb mc md mp mf mg mh mq mj mk ml im bi translated">我们现在将创建我们的主go文件，在这里我们将编写gRPC客户机代码，并向运行在Java中的服务器发出请求。它看起来会像这样:</p><pre class="kj kk kl km gt oa ni ob oc aw od bi"><span id="4951" class="ms kz it ni b gy oe of l og oh">package main</span><span id="2eb0" class="ms kz it ni b gy oi of l og oh">import (<br/>        "context"<br/>        "flag"<br/>        "fmt"<br/>        "log"<br/>        "time"</span><span id="3553" class="ms kz it ni b gy oi of l og oh">"grpc-fieldmask-example-go/pb"</span><span id="7440" class="ms kz it ni b gy oi of l og oh">"google.golang.org/grpc"<br/>        "google.golang.org/protobuf/types/known/fieldmaskpb"<br/>)</span><span id="0c77" class="ms kz it ni b gy oi of l og oh">var (<br/>        addr = flag.String("addr", "localhost:9090", "the address to connect to")<br/>)</span><span id="34b1" class="ms kz it ni b gy oi of l og oh">func main() {<br/>        fmt.Println("main method")<br/>        serverAddress := flag.String("address", "localhost:9090", "the server address")<br/>        flag.Parse()<br/>        log.Printf("Connecting to %s", *serverAddress)</span><span id="c921" class="ms kz it ni b gy oi of l og oh">conn, err := grpc.Dial(*serverAddress, grpc.WithInsecure())<br/>        if err != nil {<br/>                log.Fatalf("error while connecting: %v", err)<br/>        }<br/>        defer conn.Close()</span><span id="317b" class="ms kz it ni b gy oi of l og oh">client := pb.NewGreetUserServiceClient(conn)</span><span id="1b2d" class="ms kz it ni b gy oi of l og oh">ctx, cancel := context.WithTimeout(context.Background(), time.Second)<br/>        defer cancel()</span><span id="bd0a" class="ms kz it ni b gy oi of l og oh">callGreetUser(client, ctx)</span><span id="44b5" class="ms kz it ni b gy oi of l og oh">callRandomUser(client, ctx)</span><span id="ec9f" class="ms kz it ni b gy oi of l og oh">}</span><span id="f99d" class="ms kz it ni b gy oi of l og oh">func callGreetUser(client pb.GreetUserServiceClient, ctx context.Context) {<br/>        lastName := flag.String("lastName", "Doe", "last name of user")<br/>        var age uint32 = 26</span><span id="c957" class="ms kz it ni b gy oi of l og oh">user := pb.User{FirstName: "John", LastName: lastName, Age: &amp;age}</span><span id="0585" class="ms kz it ni b gy oi of l og oh">req := pb.GreetUserRequest{User: &amp;user}</span><span id="f4a6" class="ms kz it ni b gy oi of l og oh">r, err := client.GreetUser(ctx, &amp;req)</span><span id="7868" class="ms kz it ni b gy oi of l og oh">if err != nil {<br/>                log.Fatalf("could not greet: %v", err)<br/>        }</span><span id="45b1" class="ms kz it ni b gy oi of l og oh">log.Printf("Response From Server - Greeting : %s", r.GetGreetMessage())<br/>}</span><span id="9990" class="ms kz it ni b gy oi of l og oh">func callRandomUser(client pb.GreetUserServiceClient, ctx context.Context) {</span><span id="3e9a" class="ms kz it ni b gy oi of l og oh">var paths []string = []string{"firstName", "lastName", "age"}</span><span id="7183" class="ms kz it ni b gy oi of l og oh">field_mask := fieldmaskpb.FieldMask{Paths: paths}</span><span id="7d70" class="ms kz it ni b gy oi of l og oh">req := pb.GetRandomUserRequest{FieldMask: &amp;field_mask}</span><span id="4a99" class="ms kz it ni b gy oi of l og oh">r, err := client.GetRandomUser(ctx, &amp;req)</span><span id="7e8e" class="ms kz it ni b gy oi of l og oh">if err != nil {<br/>                log.Fatalf("could not get random user : %v", err)<br/>        }</span><span id="25cb" class="ms kz it ni b gy oi of l og oh">log.Printf("Response From Server - Random User : %s", r.GetUser())</span><span id="2c45" class="ms kz it ni b gy oi of l og oh">}</span></pre><p id="b1be" class="pw-post-body-paragraph lq lr it ls b lt mm ju lv lw mn jx ly lz mo mb mc md mp mf mg mh mq mj mk ml im bi translated">现在让我们执行下面的命令来创建一个<code class="fe nf ng nh ni b">module</code>,并添加我们的应用程序的所有缺失的依赖项:</p><pre class="kj kk kl km gt oa ni ob oc aw od bi"><span id="5b07" class="ms kz it ni b gy oe of l og oh">go mod init grpc-fieldmask-example-go</span><span id="3c2c" class="ms kz it ni b gy oi of l og oh">go mod tidy</span></pre><p id="2ef4" class="pw-post-body-paragraph lq lr it ls b lt mm ju lv lw mn jx ly lz mo mb mc md mp mf mg mh mq mj mk ml im bi translated">现在一切都完成了。当您使用以下命令执行这个go代码时，它应该向我们的Java服务器发出一个API请求，该服务器应该正在运行，并在我们的控制台中打印一个响应:</p><pre class="kj kk kl km gt oa ni ob oc aw od bi"><span id="c683" class="ms kz it ni b gy oe of l og oh">go run main.go</span></pre><p id="b8fa" class="pw-post-body-paragraph lq lr it ls b lt mm ju lv lw mn jx ly lz mo mb mc md mp mf mg mh mq mj mk ml im bi translated">尝试使用[]字符串数组中的不同字段，它应该会反映在输出中。</p></div><div class="ab cl oj ok hx ol" role="separator"><span class="om bw bk on oo op"/><span class="om bw bk on oo op"/><span class="om bw bk on oo"/></div><div class="im in io ip iq"><p id="fc4c" class="pw-post-body-paragraph lq lr it ls b lt mm ju lv lw mn jx ly lz mo mb mc md mp mf mg mh mq mj mk ml im bi translated">作为奖励，我将在下面分享用Java编写的相同的客户端代码</p><pre class="kj kk kl km gt oa ni ob oc aw od bi"><span id="cde3" class="ms kz it ni b gy oe of l og oh">public class GreetClient {<br/><br/>    private final ManagedChannel managedChannel;<br/>    private final GreetUserServiceGrpc.GreetUserServiceBlockingStub blockingStub;<br/><br/>    public GreetClient(String host, int port) {<br/>        managedChannel = ManagedChannelBuilder.<em class="ne">forAddress</em>(host, port).usePlaintext().build();<br/>        blockingStub = GreetUserServiceGrpc.<em class="ne">newBlockingStub</em>(managedChannel);<br/>    }<br/><br/>    public void shutdown() throws InterruptedException {<br/>        managedChannel.shutdown().awaitTermination(30, TimeUnit.<em class="ne">SECONDS</em>);<br/>    }<br/><br/>    public String getGreetingMessage(User user) {<br/>        GreetUserRequest greetUserRequest = GreetUserRequest.<em class="ne">newBuilder</em>().setUser(user).build();<br/>        GreetUserResponse greetUserResponse = GreetUserResponse.<em class="ne">getDefaultInstance</em>();<br/><br/>        greetUserResponse = blockingStub.greetUser(greetUserRequest);<br/><br/>        return greetUserResponse.getGreetMessage();<br/>    }<br/><br/>    public User getRandomUser() {<br/>        FieldMask fieldMask = FieldMask.<em class="ne">newBuilder</em>()<br/>                .addPaths("firstName")<br/>                .addPaths("lastName")<br/>                .addPaths("age")<br/>                .build();<br/><br/>        GetRandomUserRequest getRandomUserRequest = GetRandomUserRequest.<em class="ne">newBuilder</em>().setFieldMask(fieldMask).build();<br/><br/>        GetRandomUserResponse getRandomUserResponse = blockingStub.getRandomUser(getRandomUserRequest);<br/>        return getRandomUserResponse.getUser();<br/>    }<br/><br/>    public static void main(String[] args) {<br/>        GreetClient greetClient = new GreetClient("localhost",9090);<br/><br/>        User user = User.<em class="ne">newBuilder</em>()<br/>                .setFirstName("John")<br/>                .setLastName("Doe")                .addAddress(UserAddress.<em class="ne">newBuilder</em>().setCity("PN").setCountry("IN").build())<br/>                .build();<br/>        System.<em class="ne">out</em>.println("Response Greeting Message : "+greetClient.getGreetingMessage(user));<br/><br/>        User randomUser = greetClient.getRandomUser();<br/><br/>        System.<em class="ne">out</em>.println("Response User : "+randomUser);<br/><br/>        try {<br/>            greetClient.shutdown();<br/>        } catch (InterruptedException e) {<br/>            e.printStackTrace();<br/>        }<br/><br/>    }<br/><br/>}</span></pre><h1 id="0dd4" class="ky kz it bd la lb lc ld le lf lg lh li jz lj ka lk kc ll kd lm kf ln kg lo lp bi translated">结论</h1><p id="8e6a" class="pw-post-body-paragraph lq lr it ls b lt lu ju lv lw lx jx ly lz ma mb mc md me mf mg mh mi mj mk ml im bi translated">我们刚刚使用Java和Go生成并使用了一个gRPC API。此外，我们还学习了如何编写proto文件、生成存根以及在Java和Go中使用它们。</p><p id="b948" class="pw-post-body-paragraph lq lr it ls b lt mm ju lv lw mn jx ly lz mo mb mc md mp mf mg mh mq mj mk ml im bi translated">我们还使用了重要特性之一的<code class="fe nf ng nh ni b">FieldMask</code>，如果使用正确，它可以显著提高系统性能并节省一些成本。</p><p id="04e5" class="pw-post-body-paragraph lq lr it ls b lt mm ju lv lw mn jx ly lz mo mb mc md mp mf mg mh mq mj mk ml im bi translated">你可以在<a class="ae oq" href="https://github.com/kumarprabhashanand/grpc-fieldmask-sample" rel="noopener ugc nofollow" target="_blank">这个GitHub库这里</a>找到这个例子的代码。</p></div></div>    
</body>
</html>