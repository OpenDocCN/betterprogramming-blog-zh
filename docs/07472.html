<html>
<head>
<title>Styling In SwiftUI</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">SwiftUI中的样式</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/styling-swiftui-6d4ebd77af2b?source=collection_archive---------1-----------------------#2021-01-19">https://betterprogramming.pub/styling-swiftui-6d4ebd77af2b?source=collection_archive---------1-----------------------#2021-01-19</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="5fef" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">在三个简单的课程中编写有风格的应用程序</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/fc2501284a0fe81f8e48c7b2f7a3df01.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*eV7SYvdVdwTQtgeH9FNlkw.jpeg"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">由<a class="ae ky" href="https://unsplash.com/@updoug?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">道格拉斯·桑切斯</a>在<a class="ae ky" href="https://unsplash.com/s/photos/futuristic?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</p></figure><p id="f037" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">SwiftUI为我们编程用户界面提供了一种非常简洁的声明式方法。考虑以下代码:</p><pre class="kj kk kl km gt lv lw lx ly aw lz bi"><span id="36f9" class="ma mb it lw b gy mc md l me mf">struct SomeHeaderView: View {<br/>  var text: String<br/>  var body: some View {<br/>    HStack {<br/>      Image(systemName: "star")<br/>        .font(Font.title.smallCaps().bold())<br/>        .foregroundColor(Color(red: 88, green: 86, blue: 214))<br/>      Text(text)<br/>        .font(Font.title.smallCaps().bold())<br/>        .foregroundColor(Color(red: 89, green: 86, blue: 214))<br/>    }<br/>}</span></pre><p id="fe59" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这里，我们使用视图分解为我们的应用程序构建一个customer header视图，任何人都可以在自己的视图中包含和使用它。标题中的图像和文本使用带有自定义修饰符的标题字体，并且使用应用程序的品牌颜色。</p><p id="3a46" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">但是我们有几个问题。第一个也是最明显的是，我们复制了视图修饰符代码。让我们现在解决这个问题。</p></div><div class="ab cl mg mh hx mi" role="separator"><span class="mj bw bk mk ml mm"/><span class="mj bw bk mk ml mm"/><span class="mj bw bk mk ml"/></div><div class="im in io ip iq"><h1 id="0d6b" class="mn mb it bd mo mp mq mr ms mt mu mv mw jz mx ka my kc mz kd na kf nb kg nc nd bi translated">清理环境</h1><p id="85ce" class="pw-post-body-paragraph kz la it lb b lc ne ju le lf nf jx lh li ng lk ll lm nh lo lp lq ni ls lt lu im bi translated">实际上，正如我在SwiftUI 的<a class="ae ky" href="https://medium.com/swlh/deep-inside-views-state-and-performance-in-swiftui-d23a3a44b79" rel="noopener">深入内部视图、状态和性能中指出的，将视图修改器称为“视图”修改器有点用词不当，因为我们的许多视图修改器修改的是环境，而不是视图。</a></p><p id="a5f1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">您可能知道这样一个事实，即您可以使用SwiftUI的<code class="fe nj nk nl lw b">Group</code>收集一组视图，并对它们应用一组修改器，如下所示:</p><pre class="kj kk kl km gt lv lw lx ly aw lz bi"><span id="23f9" class="ma mb it lw b gy mc md l me mf">struct SomeHeaderView: View {<br/>  var text: String<br/>  var body: some View {<br/>    HStack {<br/>      Group {<br/>        Image(systemName: "star")<br/>        Text(text)<br/>      }<br/>      .font(Font.title.smallCaps().bold())<br/>      .foregroundColor(Color(red: 88, green: 86, blue: 214))<br/>    }<br/>  }<br/>}</span></pre><p id="a916" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">但是实际上，您可以在任何视图上做同样的事情，并且让嵌套的子视图继承这些属性。</p><pre class="kj kk kl km gt lv lw lx ly aw lz bi"><span id="cdd6" class="ma mb it lw b gy mc md l me mf">struct SomeHeaderView: View {<br/>  var text: String<br/>  var body: some View {<br/>    HStack {<br/>      Image(systemName: "star")<br/>      Text(text)<br/>    }<br/>    .font(Font.title.smallCaps().bold())<br/>    .foregroundColor(Color(red: 88, green: 86, blue: 214))<br/>  }<br/>}</span></pre><p id="a501" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这里我没有使用<code class="fe nj nk nl lw b">Group</code>，只是简单地将我的字体和颜色直接应用到了<code class="fe nj nk nl lw b">HStack</code>。嵌套图像和文本视图都将采用这些设置。</p><p id="260e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这样干净多了！</p></div><div class="ab cl mg mh hx mi" role="separator"><span class="mj bw bk mk ml mm"/><span class="mj bw bk mk ml mm"/><span class="mj bw bk mk ml"/></div><div class="im in io ip iq"><h1 id="31d3" class="mn mb it bd mo mp mq mr ms mt mu mv mw jz mx ka my kc mz kd na kf nb kg nc nd bi translated">颜色资产</h1><p id="5bbe" class="pw-post-body-paragraph kz la it lb b lc ne ju le lf nf jx lh li ng lk ll lm nh lo lp lq ni ls lt lu im bi translated">接下来，另一个问题是我们对品牌颜色进行了硬编码。</p><p id="866d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">颜色变了怎么办？我们需要在整个应用程序中进行搜索和替换吗？如果我打错字了，颜色错了怎么办？(正如我在上面的第一个例子中所做的那样。)</p><p id="3d8f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">此外，一个不太明显的事实是，通过硬编码单一颜色值，当我将应用程序置于黑暗模式时，我可能会遇到一些缺乏对比度的可访问性问题。</p><p id="63f7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">Xcode允许我们创建适用于iOS 11及更高版本的颜色资源。这也很方便，因为我们定义的任何颜色都可以是自适应的。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nm"><img src="../Images/3f02f1c55c2cff5ea80be66490af107e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*149TacsGA8qX2HS06y-A0A.png"/></div></div></figure><p id="2981" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这里我已经添加了一个<code class="fe nj nk nl lw b">Colors.xcassets</code>组到我的项目中，并添加了我的品牌颜色。请注意，我的品牌颜色有一个额外的“深色外观”，比您在浅色模式下看到的正常外观颜色要浅。这样，当我的应用程序处于黑暗模式时，我可以获得更多的对比度。</p><p id="d07d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在，我可以在任何需要的地方指定我的颜色，当我的应用程序在亮模式和暗模式下运行时，我会自动获得正确的自适应颜色。</p><pre class="kj kk kl km gt lv lw lx ly aw lz bi"><span id="8f2e" class="ma mb it lw b gy mc md l me mf">.foregroundColor(Color("brand"))</span></pre><p id="7b8c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">很好。但在某种程度上，我只是把一个问题换成了另一个问题。我的颜色名称是一个字符串，如果我碰巧打错了我的名字，我的颜色就会是错误的。</p><p id="e997" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">事实上，如果我能用颜色自动完成就好了，就像我在Xcode中输入<code class="fe nj nk nl lw b">.secondary</code>一样。</p><p id="b1aa" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">幸运的是，这也很容易。</p></div><div class="ab cl mg mh hx mi" role="separator"><span class="mj bw bk mk ml mm"/><span class="mj bw bk mk ml mm"/><span class="mj bw bk mk ml"/></div><div class="im in io ip iq"><h1 id="f11d" class="mn mb it bd mo mp mq mr ms mt mu mv mw jz mx ka my kc mz kd na kf nb kg nc nd bi translated">颜色扩展</h1><p id="fe28" class="pw-post-body-paragraph kz la it lb b lc ne ju le lf nf jx lh li ng lk ll lm nh lo lp lq ni ls lt lu im bi translated">让我们将一个<code class="fe nj nk nl lw b">colors.swift</code>文件添加到我们的项目中，并将以下内容添加到其中:</p><pre class="kj kk kl km gt lv lw lx ly aw lz bi"><span id="71f9" class="ma mb it lw b gy mc md l me mf">import SwiftUI</span><span id="119b" class="ma mb it lw b gy nn md l me mf">@available(iOS 13.0, macOS 10.15, tvOS 13.0, watchOS 6.0, *)<br/>extension Color {<br/>    static let action = Color("error")<br/>    static let brand = Color("brand")<br/>    static let error = Color("error")<br/>    static let secondaryBrand = Color("secondaryBrand")<br/>}</span></pre><p id="4b93" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这将我们的自定义颜色添加到<code class="fe nj nk nl lw b">Color</code>中，就像添加标准SwiftUI颜色一样。这给了我们:</p><pre class="kj kk kl km gt lv lw lx ly aw lz bi"><span id="e6af" class="ma mb it lw b gy mc md l me mf">struct SomeHeaderView: View {<br/>  var text: String<br/>  var body: some View {<br/>    HStack {<br/>      Image(systemName: "star")<br/>      Text(text)<br/>    }<br/>    .font(Font.title.smallCaps().bold())<br/>    .foregroundColor(.brand)<br/>  }<br/>}</span></pre><p id="2386" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在，我可以在应用程序的任何地方使用我新的自动完成自适应品牌颜色名称。</p></div><div class="ab cl mg mh hx mi" role="separator"><span class="mj bw bk mk ml mm"/><span class="mj bw bk mk ml mm"/><span class="mj bw bk mk ml"/></div><div class="im in io ip iq"><h1 id="323a" class="mn mb it bd mo mp mq mr ms mt mu mv mw jz mx ka my kc mz kd na kf nb kg nc nd bi translated">字体扩展</h1><p id="fc86" class="pw-post-body-paragraph kz la it lb b lc ne ju le lf nf jx lh li ng lk ll lm nh lo lp lq ni ls lt lu im bi translated">这可能是一个给定的，我想在应用程序的其他地方相同的标题视图字体样式。</p><p id="9555" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">此外，如果我们的UI/UX团队决定不再对所有的标题使用小型大写字母，我只需做一个改动，就可以在应用程序范围内修复它，这样就更好了。</p><p id="009f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这也很容易做到。我们用几乎完全相同的方式添加自定义颜色。通过以下方式将<code class="fe nj nk nl lw b">fonts.swift</code>添加到您的项目中:</p><pre class="kj kk kl km gt lv lw lx ly aw lz bi"><span id="f8c9" class="ma mb it lw b gy mc md l me mf">import SwiftUI</span><span id="eb9c" class="ma mb it lw b gy nn md l me mf">@available(iOS 13.0, macOS 10.15, tvOS 13.0, watchOS 6.0, *)<br/>extension Font {<br/>    static let sectionHeader: Font = Font.title.smallCaps().bold() <br/>    static let sectionFooter: Font = Font.footer.italic()<br/>}</span></pre><p id="54b2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这使我们的字体和颜色修饰符下降到:</p><pre class="kj kk kl km gt lv lw lx ly aw lz bi"><span id="7583" class="ma mb it lw b gy mc md l me mf">.font(.sectionHeader)<br/>.foregroundColor(.brand)</span></pre><p id="b39c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">太棒了。</p></div><div class="ab cl mg mh hx mi" role="separator"><span class="mj bw bk mk ml mm"/><span class="mj bw bk mk ml mm"/><span class="mj bw bk mk ml"/></div><div class="im in io ip iq"><h1 id="5973" class="mn mb it bd mo mp mq mr ms mt mu mv mw jz mx ka my kc mz kd na kf nb kg nc nd bi translated">样式修饰符</h1><p id="b9c3" class="pw-post-body-paragraph kz la it lb b lc ne ju le lf nf jx lh li ng lk ll lm nh lo lp lq ni ls lt lu im bi translated">这对于字体和颜色等单独的样式来说很好，但是如果我需要在整个应用程序中对文本应用相同的<em class="no">组</em>样式，就像SwiftUI让我们应用按钮或列表样式一样，该怎么办呢？</p><p id="c00e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这些样式有它们自己的格式，我们稍后会讨论，但是我们可以用自定义视图修饰符很容易地滚动我们自己的文本样式。让我们为我们的章节标题做一个。</p><pre class="kj kk kl km gt lv lw lx ly aw lz bi"><span id="7e5f" class="ma mb it lw b gy mc md l me mf">struct BrandedSectionHeader: ViewModifier {<br/>    func body(content: Content) -&gt; some View {<br/>        content<br/>            .font(.sectionHeader)<br/>            .foregroundColor(.brand)<br/>    }<br/>}</span></pre><p id="0456" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这里我们做了一个<code class="fe nj nk nl lw b">BrandedSectionHeader</code>修改器，我们可以在应用程序中的任何地方使用，并且我们可以应用于几乎任何东西。</p><pre class="kj kk kl km gt lv lw lx ly aw lz bi"><span id="bc43" class="ma mb it lw b gy mc md l me mf">    HStack {<br/>        Image(systemName: "star")<br/>        Text(text)<br/>    }<br/>    .modifier(BrandedSectionHeader())</span></pre><p id="efd9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">那很好，但是我仍然有一些问题。一个是<code class="fe nj nk nl lw b">.modifier</code>语法有点难看，但实际上我最大的问题是，我所有的样式修饰符将开始污染我的全局名称空间。</p><p id="7726" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我可以将样式修饰符嵌套在一个枚举中来解决命名空间问题:</p><pre class="kj kk kl km gt lv lw lx ly aw lz bi"><span id="544e" class="ma mb it lw b gy mc md l me mf">.modifier(Styles.BrandedSectionHeader())</span></pre><p id="9764" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">那好多了。另外，我将在<code class="fe nj nk nl lw b">Styles-dot-whatever</code>再次自动完成。但让我们探索另一种选择。</p></div><div class="ab cl mg mh hx mi" role="separator"><span class="mj bw bk mk ml mm"/><span class="mj bw bk mk ml mm"/><span class="mj bw bk mk ml"/></div><div class="im in io ip iq"><h1 id="b582" class="mn mb it bd mo mp mq mr ms mt mu mv mw jz mx ka my kc mz kd na kf nb kg nc nd bi translated">查看扩展</h1><p id="e877" class="pw-post-body-paragraph kz la it lb b lc ne ju le lf nf jx lh li ng lk ll lm nh lo lp lq ni ls lt lu im bi translated">使用视图扩展的一种方法是简单地将特定的样式直接附加到我们的视图上。</p><pre class="kj kk kl km gt lv lw lx ly aw lz bi"><span id="cfad" class="ma mb it lw b gy mc md l me mf">extension View {<br/>    func styleAsSectionHeader() -&gt; some View {<br/>        self.font(.sectionHeader).foregroundColor(.action)<br/>    }<br/>}</span></pre><p id="6cff" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果您有一种风格或一组属性，并且您总是想将它添加到您的视图中，那么这将非常有用。当然，这里的缺点是现在您污染了您的<code class="fe nj nk nl lw b">View</code>名称空间，并且弄乱了所有的<code class="fe nj nk nl lw b">View</code>自动完成选项。</p><p id="e141" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们尝试另一种解决方案。考虑以下代码:</p><pre class="kj kk kl km gt lv lw lx ly aw lz bi"><span id="9744" class="ma mb it lw b gy mc md l me mf">enum CustomViewStyle {<br/>    case actionSectionHeader<br/>    case brandedSectionHeader<br/>    case brandedSectionFooter<br/>}</span><span id="5551" class="ma mb it lw b gy nn md l me mf">extension View {<br/>    @ViewBuilder func style(_ style: CustomViewStyle) -&gt; some View {<br/>        switch style {<br/>        case .actionSectionHeader:<br/>            self.font(.sectionHeader).foregroundColor(.action)<br/>        case .brandedSectionHeader:<br/>            self.font(.sectionHeader).foregroundColor(.brand)<br/>        case .brandedSectionFooter:<br/>            self.font(.sectionFooter).foregroundColor(.brand)      <br/>        }<br/>    }<br/>}</span></pre><p id="a311" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这里我们给<code class="fe nj nk nl lw b">View</code>添加了一个<code class="fe nj nk nl lw b">style</code>扩展，它将枚举的样式应用到当前视图，您可以在下面的操作中看到。</p><pre class="kj kk kl km gt lv lw lx ly aw lz bi"><span id="de85" class="ma mb it lw b gy mc md l me mf">    HStack {<br/>        Image(systemName: "star")<br/>        Text(text)<br/>    }<br/>    .style(.brandedSectionHeader)</span></pre><p id="1a74" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这非常简洁，使用起来肯定更像SwiftUI。当然，缺点是你的<code class="fe nj nk nl lw b">style</code>函数会很快变得相当大。</p><p id="f5d7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果您想知道，函数定义前面的<code class="fe nj nk nl lw b">ViewBuilder</code>属性告诉SwiftUI将视图构建器语义应用于函数结果，这又让我们的<code class="fe nj nk nl lw b">style</code>函数的switch语句返回多个视图类型。</p><p id="2a39" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">事实上，有了<code class="fe nj nk nl lw b">.style</code>或者甚至有了样式修改器，我们已经把事情简化到了根本不需要专用的<code class="fe nj nk nl lw b">SomeHeaderView</code>组件的地步。</p><p id="fb9c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果我们使用SwiftUI 2.0的一个新功能，我们现在可以将图像嵌入文本本身，那就更是如此。</p><pre class="kj kk kl km gt lv lw lx ly aw lz bi"><span id="5dd6" class="ma mb it lw b gy mc md l me mf">Text("\(Image(systemName: "star") \(text)")<br/>  .style(.brandedSectionHeader)</span></pre><p id="2e54" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">或者使用<code class="fe nj nk nl lw b">Label</code>进一步清理。</p><pre class="kj kk kl km gt lv lw lx ly aw lz bi"><span id="2c6b" class="ma mb it lw b gy mc md l me mf">Label(text, systemImage: "star")<br/>  .style(.brandedSectionHeader)</span></pre><p id="e651" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">但是，请记住，<code class="fe nj nk nl lw b">Label</code>的表示语义因其表示位置而异:表单、列表或动作表。</p></div><div class="ab cl mg mh hx mi" role="separator"><span class="mj bw bk mk ml mm"/><span class="mj bw bk mk ml mm"/><span class="mj bw bk mk ml"/></div><div class="im in io ip iq"><h1 id="0784" class="mn mb it bd mo mp mq mr ms mt mu mv mw jz mx ka my kc mz kd na kf nb kg nc nd bi translated">全局强调色</h1><p id="f175" class="pw-post-body-paragraph kz la it lb b lc ne ju le lf nf jx lh li ng lk ll lm nh lo lp lq ni ls lt lu im bi translated">您可能知道可以使用<code class="fe nj nk nl lw b">accentColor</code>修饰符来调整SwiftUI应用程序中按钮、切换和其他控件的强调色。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi np"><img src="../Images/98c9c8512dfbea82eee2b6cecc89a067.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*vZYSGNmHFQMU2e07cpLSkg.png"/></div></div></figure><p id="30bb" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">然而，你可能不知道的是，从iOS 14开始，你现在可以在你的应用程序的<code class="fe nj nk nl lw b">xcassets</code>文件夹中添加一个<code class="fe nj nk nl lw b">AccentColor</code>颜色集。当你这样做的时候，应用程序会选择那个颜色，并在整个应用程序中自动使用。</p><p id="0700" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">当然，您可以使用<code class="fe nj nk nl lw b">accentColor</code>修改器局部覆盖颜色。</p></div><div class="ab cl mg mh hx mi" role="separator"><span class="mj bw bk mk ml mm"/><span class="mj bw bk mk ml mm"/><span class="mj bw bk mk ml"/></div><div class="im in io ip iq"><h1 id="d605" class="mn mb it bd mo mp mq mr ms mt mu mv mw jz mx ka my kc mz kd na kf nb kg nc nd bi translated">完成块</h1><p id="5524" class="pw-post-body-paragraph kz la it lb b lc ne ju le lf nf jx lh li ng lk ll lm nh lo lp lq ni ls lt lu im bi translated">目前就是这样，尽管我们甚至还没有开始触及SwiftUI中样式的皮毛。</p><p id="2cae" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果您有任何问题或意见，请在下面留下。</p><p id="5088" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">尽情享受吧！</p></div></div>    
</body>
</html>