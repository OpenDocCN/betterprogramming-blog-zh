<html>
<head>
<title>Rust for IoT: Is It Time?</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">物联网生锈:是时候了吗？</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/rust-for-iot-is-it-time-67b14ab34b8?source=collection_archive---------1-----------------------#2022-10-10">https://betterprogramming.pub/rust-for-iot-is-it-time-67b14ab34b8?source=collection_archive---------1-----------------------#2022-10-10</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="a5a9" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">探索esp32-c3上的锈迹</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/f134d553d54dc05af6fd86fc83d5e55d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*kYYC0TU825BMCCWL"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">托马斯·博尔曼斯在<a class="ae kv" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</p></figure><p id="eaab" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">Rust已经存在一段时间了，我们都听说过这种语言的好处，特别是在内存安全方面。在过去的几年里，我写了相当多的C代码，但一直想使用一种更现代的语言。所以，当我第一次听说Rust的时候，我希望它能改变游戏规则。现在这种语言似乎正在加速发展，微软Azure的CTO甚至说<a class="ae kv" href="https://www.zdnet.com/article/programming-languages-its-time-to-stop-using-c-and-c-for-new-projects-says-microsoft-azure-cto/" rel="noopener ugc nofollow" target="_blank">我们不应该再用C或C++开始新的项目</a>。</p><p id="9c18" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我有一些问题:</p><ul class=""><li id="65ce" class="ls lt iq ky b kz la lc ld lf lu lj lv ln lw lr lx ly lz ma bi translated">那么，在物联网领域，特别是在裸机上进行嵌入式开发时，在实践中启动一个基于Rust的新项目会是什么样子呢？</li><li id="f39e" class="ls lt iq ky b kz mb lc mc lf md lj me ln mf lr lx ly lz ma bi translated">现在是时候了吗？我们可以在生产环境中的新项目中开始使用这种有前途的语言吗，或者我们仍然缺乏对关键特性的支持吗？更重要的是，2022年的开发体验相比C语言编程如何？</li><li id="9e6d" class="ls lt iq ky b kz mb lc mc lf md lj me ln mf lr lx ly lz ma bi translated">Rust是否让我们在保持代码安全的同时，更快地开发更易维护的应用程序？</li></ul><p id="19fa" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在本文中，我将探讨这些问题，并通过放大当今最受欢迎的硬件平台之一，并(尝试)为其创建一个简单的物联网应用程序，收集我对2022年物联网Rust状态的想法。</p><p id="bd1a" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">如果你想跟随代码，完整的代码清单可以在这里找到:<a class="ae kv" href="https://github.com/mfiumara/rust-iot-2022" rel="noopener ugc nofollow" target="_blank"> rust-iot-2022 </a>。</p><h1 id="31c2" class="mg mh iq bd mi mj mk ml mm mn mo mp mq jw mr jx ms jz mt ka mu kc mv kd mw mx bi translated">硬件和设置</h1><p id="7ec4" class="pw-post-body-paragraph kw kx iq ky b kz my jr lb lc mz ju le lf na lh li lj nb ll lm ln nc lp lq lr ij bi translated">首先，我们需要一些硬件。在当今所有物联网硬件平台中，Espressif的ESP32系列肯定是最受欢迎的平台之一。随着业余爱好者社区的大型聚会，它也在工业物联网环境中赢得了坚实的基础。我决定试用一下<a class="ae kv" href="https://docs.espressif.com/projects/esp-idf/en/latest/esp32c3/hw-reference/esp32c3/user-guide-devkitm-1.html" rel="noopener ugc nofollow" target="_blank"> ESP32 C3开发套件</a>，这是一个基于RISC-V的架构，具有Wi-Fi和蓝牙功能。</p><p id="747b" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">当开始四处寻找支持时，您很快就会以ESP IDF(物联网开发框架)作为主要开发框架，它拥有一些由开源ESP社区为其编写的可靠的<a class="ae kv" href="https://github.com/esp-rs/esp-idf-svc" rel="noopener ugc nofollow" target="_blank"> Rust绑定</a>。为了进行设置，我简单地遵循了来自<a class="ae kv" href="https://github.com/esp-rs/esp-idf-template" rel="noopener ugc nofollow" target="_blank">的这个模板项目</a>的指南(确保您的系统中安装了那里列出的依赖项)并执行了以下命令:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nd ne l"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">Rust设置和项目生成</p></figure><p id="9315" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这个命令包安装了Rust的夜间工具链以及编译和运行我们的应用程序所需的所有依赖项。毕竟，安装了依赖项之后，我们生成演示项目，编译，刷新，最后运行应用程序，所有这些都在六分钟的时间内完成。与我在C或C++中进行的一些项目设置相比，这种设置非常容易——在C或c++中，我必须手动搜索并安装正确的工具链——这是Rust的第一次胜利，并显示了Rust的构建系统是如何工作的。</p><h1 id="6bc5" class="mg mh iq bd mi mj mk ml mm mn mo mp mq jw mr jx ms jz mt ka mu kc mv kd mw mx bi translated">开发工作流程</h1><p id="6ff7" class="pw-post-body-paragraph kw kx iq ky b kz my jr lb lc mz ju le lf na lh li lj nb ll lm ln nc lp lq lr ij bi translated">为了简单起见，我决定从VScode开始，并安装了<a class="ae kv" href="https://marketplace.visualstudio.com/items?itemName=rust-lang.rust-analyzer" rel="noopener ugc nofollow" target="_blank"> Rust analyzer扩展</a>，这就产生了一个开箱即用的自动完成器。不用再使用<a class="ae kv" href="https://clangd.llvm.org/design/compile-commands" rel="noopener ugc nofollow" target="_blank">编译命令</a>生成编译数据库，也不会总是缺少一个系统库:Rust语言服务器简单地完成这项工作，并在您习惯Rust语法的同时帮助您。</p><p id="fcf8" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">现在，让我们看看导航ESP-IDF的生锈绑定是什么样子的。我通读了文档，并让Rust语言服务器完成它的工作，为每个函数参数建议应该填写什么。为了连接到您的本地WiFi网络，我使用了以下代码:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nd ne l"/></div></figure><p id="1387" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">相当简单。让我们看看我们的二进制文件有多大，编译-&gt;闪存-&gt;运行循环有多快:</p><pre class="kg kh ki kj gt nf ng nh ni aw nj bi"><span id="fd68" class="nk mh iq ng b gy nl nm l nn no">$ time cargo build</span><span id="0c9b" class="nk mh iq ng b gy np nm l nn no">Compiling wireprobe-rs v0.1.0 (/Users/mfiumara/repos/esp-rust)Finished dev [optimized + debuginfo] target(s) in 1.27s<br/>        1.31 real         1.15 user         0.15 sys</span><span id="c844" class="nk mh iq ng b gy np nm l nn no">$ time espflash --speed 406800 target/riscv32imc-esp-espidf/debug/wireprobe-rs<br/>Serial port: /dev/tty.usbserial-10<br/>Connecting...</span><span id="5203" class="nk mh iq ng b gy np nm l nn no">WARN setting baud rate higher than 115200 can cause issues.<br/>Chip type:         ESP32-C3 (revision 3)<br/>Crystal frequency: 40MHz<br/>Flash size:        4MB<br/>Features:          WiFi<br/>MAC address:       10:91:a8:36:53:04<br/>App/part. size:    1037024/4128768 bytes, 25.12%<br/>[00:00:00] ########################################      12/12      segment 0x0<br/>[00:00:00] ########################################       1/1       segment 0x8000<br/>[00:00:25] ########################################     584/584     segment 0x10000<br/>Flashing has completed!<br/>       33.33 real         0.14 user         0.16 sys</span></pre><p id="0fb3" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们的二进制文件变成大约1MB，编译和刷新大约需要40秒。这是一个相当大的二进制图像，这可以解释，因为我们在WiFi堆栈中链接。关于闪烁的速度，这受到UART接口的最大速度406800位/秒的限制。这并不令人惊讶，但这是我们必须面对的问题:这似乎不是Rust的限制，而是硬件的限制。</p><h1 id="d469" class="mg mh iq bd mi mj mk ml mm mn mo mp mq jw mr jx ms jz mt ka mu kc mv kd mw mx bi translated">做一些有用的事情</h1><p id="1e9a" class="pw-post-body-paragraph kw kx iq ky b kz my jr lb lc mz ju le lf na lh li lj nb ll lm ln nc lp lq lr ij bi translated">既然我们已经成功地在目标上运行了代码，那么让我们尝试做一些实际有用的事情，例如，连接到MQTT代理并尝试发送和接收一些消息。为此，我在初始化WiFi堆栈后添加了这几行代码来初始化和启动MQTT客户端:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nd ne l"/></div></figure><p id="f1bc" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我使用的是emqx.io的public broker，它有一个很好的在线客户端，我们可以在那里看到我们的消息，并且可以使用一个简单的GUI向我们的设备发送消息，以测试我们的功能。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nq"><img src="../Images/4b6cad7f2b37e734cc2470d7f1610fef.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*yDHrZgNxmW3e5Pw2hro3Cw.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">在emqx.io上接收和发送MQTT消息</p></figure><p id="fa72" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">现在，为了实际发送和接收消息，我不得不做一些调查，因为我真的不知道如何仅从文档中实现这一点。幸运的是，围绕<code class="fe nr ns nt ng b">esp-rs</code>绑定有一个相当活跃的<a class="ae kv" href="https://matrix.to/#/#esp-rs:matrix.org" rel="noopener ugc nofollow" target="_blank">社区聊天</a>，这个话题在聊天历史中经过。在我的第一个实现中，我试图在不处理任何来自MQTT堆栈的事件的情况下发布消息，这完全冻结了我的应用程序。根据一些参考资料，我想出了下面这段代码:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nd ne l"/></div></figure><p id="0aad" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">乍一看这段代码有点令人生畏，但是一旦你通读了它的语法，就会发现与更传统的C编程工作流相比，Rust是多么强大:</p><ol class=""><li id="d023" class="ls lt iq ky b kz la lc ld lf lu lj lv ln lw lr nu ly lz ma bi translated">首先，我们使用<code class="fe nr ns nt ng b">std::thread</code>生成一个线程，在其中监听传入的MQTT事件。没有代码花费在定义堆栈大小、配置线程优先级、定义调度行为、定义入口函数和传递变量上。我们只需<code class="fe nr ns nt ng b">thread::spawn</code>，传递一个闭包，<code class="fe nr ns nt ng b">move</code>我们的连接变量进入线程，我们就设置好了。</li><li id="5ec8" class="ls lt iq ky b kz mb lc mc lf md lj me ln mf lr nu ly lz ma bi translated">在新生成的线程中，我们处理MQTT事件，并使用<code class="fe nr ns nt ng b">match</code>专门寻找一个<code class="fe nr ns nt ng b">Received</code>事件。我们在控制台中将内容打印为一个字符串，这次利用了<code class="fe nr ns nt ng b">std::str</code>。在C语言中，我们必须手动操作<code class="fe nr ns nt ng b">memcpy</code>，不要忘记字符串结束字符，否则会有打印出目标内存索引的风险，这说明了Rust的一些安全特性。</li><li id="6b4b" class="ls lt iq ky b kz mb lc mc lf md lj me ln mf lr nu ly lz ma bi translated">最后，回到我们的<code class="fe nr ns nt ng b">main</code>线程，我们订阅了一个主题并创建了一个无限循环，在这个循环中，我们连续发布到一个MQTT主题，中间有一秒钟的停顿。</li></ol><p id="1fcf" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这里还有改进的空间:我们没有处理任何不可预见的错误(只是简单地<code class="fe nr ns nt ng b">unwrap()</code> -ing它们),我们的嵌套match语句可以进行重构，但是作为概念的证明，这已经足够了，并且显示了我们可以在很少的几行代码中做多少事情。意识到我们仍然在微控制器上编程，感觉几乎是超现实的，更像是在编写云服务。这是好事。</p><h1 id="5e54" class="mg mh iq bd mi mj mk ml mm mn mo mp mq jw mr jx ms jz mt ka mu kc mv kd mw mx bi translated">是时候了吗？</h1><p id="3877" class="pw-post-body-paragraph kw kx iq ky b kz my jr lb lc mz ju le lf na lh li lj nb ll lm ln nc lp lq lr ij bi translated">所以…我们在esp32-c3上设置了一个简单的Rust应用程序，它可以在很短的时间内成功地向云应用程序发送和接收消息。我们使用Rust的标准库来更快地开发代码，同时保持安全性。我们没有做的事情:讨论无线更新、安全和加密、调试功能或内存优化，所有这些主题都需要在全力投入Rust之前进行评估(更不用说测试了，但这本身就是一篇文章)。然而，回顾到目前为止的经验，并从这个不起眼的项目中推断，我确实认为上述主题无需过多的努力就可以解决。所以我称之为:</p><p id="ba08" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">是时候了。</p><p id="da1c" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">现在，这并不意味着明天你需要开始把你的整个代码库从C / C++重写到Rust。这在很大程度上取决于您的芯片组所能获得的支持类型:是否有一个活跃的社区/源代码是否被积极地维护，是否有制造商对开源努力的官方支持，以及是否有良好的绑定？那就想尽一切办法去争取吧。</p><p id="b0f5" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">有些情况下，你可能需要自己解决问题，并为开源社区做出贡献，但是，如果你不介意，那么从长远来看，现在采用Rust将会是一个不错的投资回报。</p></div><div class="ab cl nv nw hu nx" role="separator"><span class="ny bw bk nz oa ob"/><span class="ny bw bk nz oa ob"/><span class="ny bw bk nz oa"/></div><div class="ij ik il im in"><p id="4f1d" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">感谢阅读到最后！</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi oc"><img src="../Images/75ecb9b0b2ae55903066ff4427b8ceea.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Ba7o1_mR9dCa_Vjk46H0xA.png"/></div></figure><h1 id="1faf" class="mg mh iq bd mi mj mk ml mm mn mo mp mq jw mr jx ms jz mt ka mu kc mv kd mw mx bi translated">资源</h1><ul class=""><li id="c07d" class="ls lt iq ky b kz my lc mz lf od lj oe ln of lr lx ly lz ma bi translated">参考代号:<a class="ae kv" href="https://github.com/mfiumara/rust-iot-2022" rel="noopener ugc nofollow" target="_blank">https://github.com/mfiumara/rust-iot-2022</a></li><li id="126e" class="ls lt iq ky b kz mb lc mc lf md lj me ln mf lr lx ly lz ma bi translated">ESP Rust Github资源:<a class="ae kv" href="https://github.com/esp-rs" rel="noopener ugc nofollow" target="_blank">https://github.com/esp-rs</a></li><li id="b0c1" class="ls lt iq ky b kz mb lc mc lf md lj me ln mf lr lx ly lz ma bi translated">ESP Rust社区聊天:<a class="ae kv" href="https://matrix.to/#/#esp-rs:matrix.org" rel="noopener ugc nofollow" target="_blank">https://matrix.to/#/#esp-rs:matrix.org</a></li></ul></div></div>    
</body>
</html>