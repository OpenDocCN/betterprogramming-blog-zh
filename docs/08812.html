<html>
<head>
<title>Create a Galaga Clone Using Pygame</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用Pygame创建一个Galaga克隆体</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/create-a-galaga-clone-using-pygame-57d32567699e?source=collection_archive---------3-----------------------#2021-06-15">https://betterprogramming.pub/create-a-galaga-clone-using-pygame-57d32567699e?source=collection_archive---------3-----------------------#2021-06-15</a></blockquote><div><div class="fc ii ij ik il im"/><div class="in io ip iq ir"><div class=""/><div class=""><h2 id="7e03" class="pw-subtitle-paragraph jr it iu bd b js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki dk translated">我的游戏编程梦想是如何让我重现街机经典的</h2></div><figure class="kk kl km kn gu ko gi gj paragraph-image"><div role="button" tabindex="0" class="kp kq di kr bf ks"><div class="gi gj kj"><img src="../Images/d0fb90870a5941b236f69a8668fad6b4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ZQzyTv-oZ3-jD7OwKTtQFw.jpeg"/></div></div><p class="kv kw gk gi gj kx ky bd b be z dk translated">卡尔·劳在<a class="ae kz" href="https://unsplash.com/s/photos/arcade-game?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片。</p></figure><p id="3a75" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">我有一个坦白:自从我能够在Commodore 64的屏幕上反弹精灵，我就想成为一名游戏程序员。</p><p id="ccb2" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">不要误解我。我热爱我的工作，并为我完成的项目感到自豪。但是创造一个视频游戏并让东西在屏幕上移动是有魔力的。</p><p id="16ae" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">有时候会心痒痒，尝试开发一个小游戏。这次尝试以<a class="ae kz" href="https://en.wikipedia.org/wiki/Galaga" rel="noopener ugc nofollow" target="_blank"> <em class="lw"> Galaga </em> </a>为原型打造一款太空射击游戏。Galaga是一款经典的街机游戏，由Namco开发，我十几岁的时候经常在当地的自助餐厅玩。</p><p id="4e5b" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">最初游戏中最令人愉快的部分是具有挑战性的阶段。你必须射击垂直向你飞来的各种敌人。我以此为灵感创作了一款游戏。</p><p id="02b5" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">下面，你可以看到结果。它的特点是一波一波的敌人沿着贝塞尔曲线向你移动，动画精灵，碰撞检测，得分和不同的游戏状态。我甚至加入了一些原版游戏的声音。</p><figure class="kk kl km kn gu ko gi gj paragraph-image"><div role="button" tabindex="0" class="kp kq di kr bf ks"><div class="gi gj lx"><img src="../Images/9e7ca354c0a5b99195e8bb0dc3108680.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*dmE-0b_2Rtnl6u_qok96-w.gif"/></div></div><p class="kv kw gk gi gj kx ky bd b be z dk translated">一个用Pygame用Python写的Galaga克隆体。</p></figure><p id="890f" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">在这篇文章中，我将通过解释游戏的各个部分向你展示我是如何创建它的。你可以在GitHub库中找到游戏的源代码。</p></div><div class="ab cl ly lz hy ma" role="separator"><span class="mb bw bk mc md me"/><span class="mb bw bk mc md me"/><span class="mb bw bk mc md"/></div><div class="in io ip iq ir"><figure class="kk kl km kn gu ko gi gj paragraph-image"><div role="button" tabindex="0" class="kp kq di kr bf ks"><div class="gi gj mf"><img src="../Images/056197b95a86d88140bc0205dbe68f7d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*c86qwoALxCFbTiLRfJKRiQ.png"/></div></div><p class="kv kw gk gi gj kx ky bd b be z dk translated">来源:<a class="ae kz" href="https://www.pygame.org/news" rel="noopener ugc nofollow" target="_blank"> Pygame </a></p></figure><p id="bb20" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">如果你开始开发一个游戏，你应该看看各种游戏引擎和框架。使用现有的游戏引擎可以节省你大量的工作。</p><p id="6aa3" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">有很多游戏引擎和框架可用。根据您使用的编程语言，您可能有更多或更少的选择。Unity和Unreal Engine是众所周知的跨平台框架。以前有一款手游我用过<a class="ae kz" href="https://www.monogame.net/" rel="noopener ugc nofollow" target="_blank">一夫一妻制</a>。</p><p id="9875" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">对于这个项目，我决定使用Pygame，因为我计划使用Python。Pygame是一个构建在SDL库之上的开源框架。简单的DirectMedia层(SDL)是一个跨平台的库。这意味着你用Pygame开发的游戏可以在Windows、Linux和macOS上运行。</p></div><div class="ab cl ly lz hy ma" role="separator"><span class="mb bw bk mc md me"/><span class="mb bw bk mc md me"/><span class="mb bw bk mc md"/></div><div class="in io ip iq ir"><h1 id="0769" class="mg mh iu bd mi mj mk ml mm mn mo mp mq ka mr kb ms kd mt ke mu kg mv kh mw mx bi translated">游戏状态</h1><p id="3552" class="pw-post-body-paragraph la lb iu lc b ld my jv lf lg mz jy li lj na ll lm ln nb lp lq lr nc lt lu lv in bi translated">我在开发视频游戏时学到的一件事是，你的游戏需要一个状态机。一个游戏可以有几种状态。例如，它有<em class="lw">玩</em>状态，也有<em class="lw">开始</em>和<em class="lw">游戏超过</em>状态。</p><p id="d924" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">您可以使用<code class="fe nd ne nf ng b">if-else</code>构造来创建这个逻辑。但是请相信我，如果您使用状态机，您的代码将更容易构建和维护。</p><p id="553c" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">我使用Python类对状态机建模。每个州都是一个类。所以我创建了类型<code class="fe nd ne nf ng b">Splash</code>、<code class="fe nd ne nf ng b">Menu</code>、<code class="fe nd ne nf ng b">Gameplay</code>和<code class="fe nd ne nf ng b">GameOver</code>。我从一个名为<code class="fe nd ne nf ng b">BaseState</code>的基类中派生出这些类。</p><figure class="kk kl km kn gu ko"><div class="bz fq l di"><div class="nh ni l"/></div><p class="kv kw gk gi gj kx ky bd b be z dk translated">状态机的每个状态的BaseState基类。</p></figure><p id="dde1" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">在我们深入游戏状态之前，我们必须先谈谈游戏的主要循环。有一个名为<code class="fe nd ne nf ng b">Game</code>的类负责实际的游戏循环。在这个类中，有一个方法调用<code class="fe nd ne nf ng b">run</code>，您可以在下面看到。</p><figure class="kk kl km kn gu ko"><div class="bz fq l di"><div class="nh ni l"/></div><p class="kv kw gk gi gj kx ky bd b be z dk translated">游戏类中的主游戏循环。</p></figure><p id="b88c" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated"><code class="fe nd ne nf ng b">event_loop</code>、<code class="fe nd ne nf ng b">update</code>和<code class="fe nd ne nf ng b">draw</code>是在当前状态下调用相同方法的函数。<code class="fe nd ne nf ng b">event_loop</code>负责处理定时器和按键等事件。<code class="fe nd ne nf ng b">update</code>方法用于控制游戏逻辑，如敌人移动。最后一个函数，<code class="fe nd ne nf ng b">draw</code>，负责在屏幕上绘制游戏的各个部分。</p><p id="cacd" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">现在我们来看第一种状态，也就是<em class="lw">飞溅</em>状态。这个状态显示游戏的闪屏。它等待几秒钟，并通过将<code class="fe nd ne nf ng b">done</code>标志设置为<code class="fe nd ne nf ng b">True</code>进入下一个状态。</p><figure class="kk kl km kn gu ko"><div class="bz fq l di"><div class="nh ni l"/></div><p class="kv kw gk gi gj kx ky bd b be z dk translated">显示闪屏的闪屏状态。</p></figure><p id="667a" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">Splash状态使用font类在屏幕上呈现文本。如果闪屏处于活动状态超过三秒钟，它将切换到下一个状态。下一个状态是<em class="lw">菜单</em>状态，显示一个菜单。每个状态通过设置<code class="fe nd ne nf ng b">next_state</code>成员来指示下一个状态，如您在第6行所见。</p><p id="b63f" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">将<code class="fe nd ne nf ng b">done</code>字段设置为<code class="fe nd ne nf ng b">True</code>向游戏循环指示它应该翻转到下一个状态。</p><p id="e822" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">最广泛的状态是<em class="lw">游戏性</em>状态。所有的游戏逻辑都在这种状态下处理。</p></div><div class="ab cl ly lz hy ma" role="separator"><span class="mb bw bk mc md me"/><span class="mb bw bk mc md me"/><span class="mb bw bk mc md"/></div><div class="in io ip iq ir"><h1 id="45d7" class="mg mh iu bd mi mj mk ml mm mn mo mp mq ka mr kb ms kd mt ke mu kg mv kh mw mx bi translated">精灵</h1><p id="b039" class="pw-post-body-paragraph la lb iu lc b ld my jv lf lg mz jy li lj na ll lm ln nb lp lq lr nc lt lu lv in bi translated">精灵是在屏幕上移动的东西。Pygame有一个专门为精灵设计的内置类。这个名为<code class="fe nd ne nf ng b">Sprite</code>的类有几个方法使得移动东西变得更容易。</p><p id="8f8b" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">通常，精灵和它们的动画是在精灵表中定义的。精灵表是包含游戏图形资源的图像，包括动画精灵的变化。</p><p id="800b" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">下面，你可以看到我在这个游戏中使用的精灵表。现在我不是图形艺术家，所以我从OpenGameArt.org下载了这张纸。</p><figure class="kk kl km kn gu ko gi gj paragraph-image"><div class="gi gj nj"><img src="../Images/8434243fdbc4c048c191c52276d507c9.png" data-original-src="https://miro.medium.com/v2/resize:fit:672/format:webp/1*-AeGjF2MM0PLMBJgj9Oi1Q.jpeg"/></div><p class="kv kw gk gi gj kx ky bd b be z dk translated"><a class="ae kz" href="www.scriptefun.com/transcript-2-using" rel="noopener ugc nofollow" target="_blank"> Sprite sheet </a>由<a class="ae kz" href="https://opengameart.org/users/cuzco" rel="noopener ugc nofollow" target="_blank"> Cuzco </a>创建并捐赠给公共领域CC0。</p></figure><p id="1b52" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">要使用sprite工作表，您必须知道每个sprite的确切大小和帧数。我们先来看看玩家的飞船。当我们组合第三行的六个图像时，我们得到了一个很好的玩家船的动画。</p><figure class="kk kl km kn gu ko gi gj paragraph-image"><div class="gi gj nk"><img src="../Images/0e7e26775d05a0e6e1b4ef7417e784fa.png" data-original-src="https://miro.medium.com/v2/resize:fit:436/1*itER5qW4cNZ0lyo-Yht2bA.gif"/></div><p class="kv kw gk gi gj kx ky bd b be z dk translated">制作玩家飞船的动画。</p></figure><p id="a7fb" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">为了加载sprite工作表，我们使用了<code class="fe nd ne nf ng b">SpriteSheet</code>辅助类。这个类包含一个方法来加载sprite表并返回组成动画的各个图像的数组。</p><p id="bb32" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">我们通过创建一个<code class="fe nd ne nf ng b">SpriteSheet</code>类的实例来加载sprite工作表，并给它sprite工作表图像的位置。下面的代码显示了<code class="fe nd ne nf ng b">Player</code>类。我们将六艘不同的飞船放入第7行的<code class="fe nd ne nf ng b">images</code>阵列中。</p><p id="8567" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">动画发生在<code class="fe nd ne nf ng b">get_surf</code>方法中。根据计时器，它返回动画的一个图像。我使用<code class="fe nd ne nf ng b">self.interval</code>字段来延迟动画。</p><figure class="kk kl km kn gu ko"><div class="bz fq l di"><div class="nh ni l"/></div><p class="kv kw gk gi gj kx ky bd b be z dk translated">从Pygame Sprite类派生的Player类。</p></figure><p id="d11f" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">其他精灵是使用不同的类实现的。有一个<code class="fe nd ne nf ng b">Enemy</code>类、一个<code class="fe nd ne nf ng b">Rocket</code>类和一个<code class="fe nd ne nf ng b">Explosion</code>类。</p></div><div class="ab cl ly lz hy ma" role="separator"><span class="mb bw bk mc md me"/><span class="mb bw bk mc md me"/><span class="mb bw bk mc md"/></div><div class="in io ip iq ir"><h1 id="c677" class="mg mh iu bd mi mj mk ml mm mn mo mp mq ka mr kb ms kd mt ke mu kg mv kh mw mx bi translated">射击</h1><p id="0416" class="pw-post-body-paragraph la lb iu lc b ld my jv lf lg mz jy li lj na ll lm ln nb lp lq lr nc lt lu lv in bi translated">玩家可以使用空格键发射火箭。我们在玩家的位置创建了一个火箭精灵。我们将同时发射的火箭数量限制在两枚。</p><p id="fafd" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">下面是创建<code class="fe nd ne nf ng b">Rocket</code>的<code class="fe nd ne nf ng b">shoot_rocket</code>函数。第2行的第一个参数是sprite表。第二个和第三个参数表示水平和垂直速度。我们将垂直速度设为<code class="fe nd ne nf ng b">-15</code>，这意味着火箭直线上升。火箭也是一个动画精灵。</p><figure class="kk kl km kn gu ko"><div class="bz fq l di"><div class="nh ni l"/></div><p class="kv kw gk gi gj kx ky bd b be z dk translated">向敌人发射火箭的功能。</p></figure><p id="a799" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">敌人的宇宙飞船也向玩家发射火箭。这些火箭向玩家移动。我们用一个Pygame定时器让敌人的飞船每秒射击一次。当定时器被触发时，它调用<code class="fe nd ne nf ng b">enemy_shoots</code>函数。</p><p id="0044" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">在函数中，我们首先随机选择一艘敌方飞船。然后我们计算出正确的速度，让火箭从敌人手中直线射向玩家。</p><p id="7491" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">我们检查火箭是不是低于400像素才释放。否则，火箭几乎总是会击中球员。你可以用这个值和火箭的速度来玩(例如，当改变到下一个难度级别时)。</p><figure class="kk kl km kn gu ko"><div class="bz fq l di"><div class="nh ni l"/></div><p class="kv kw gk gi gj kx ky bd b be z dk translated">从随机选择的敌人那里发射火箭的功能。</p></figure></div><div class="ab cl ly lz hy ma" role="separator"><span class="mb bw bk mc md me"/><span class="mb bw bk mc md me"/><span class="mb bw bk mc md"/></div><div class="in io ip iq ir"><h1 id="065f" class="mg mh iu bd mi mj mk ml mm mn mo mp mq ka mr kb ms kd mt ke mu kg mv kh mw mx bi translated">冲突检出</h1><p id="8712" class="pw-post-body-paragraph la lb iu lc b ld my jv lf lg mz jy li lj na ll lm ln nb lp lq lr nc lt lu lv in bi translated">Pygame让碰撞检测变得轻而易举。它有一个<code class="fe nd ne nf ng b">SpriteGroup</code>类，作为sprite对象的容器。Pygame中的辅助方法可以检测一个精灵组中的精灵是否与另一个精灵组中的精灵冲突。</p><p id="42ca" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">当我们发射火箭时，我们将<code class="fe nd ne nf ng b">Rocket</code>添加到<code class="fe nd ne nf ng b">all_rockets</code>精灵组中。我们在进入屏幕时将每个敌人添加到<code class="fe nd ne nf ng b">all_enemies</code>精灵组中。然后我们可以通过<code class="fe nd ne nf ng b">groupcollide</code>功能确定火箭和敌人是否相撞。</p><figure class="kk kl km kn gu ko"><div class="bz fq l di"><div class="nh ni l"/></div><p class="kv kw gk gi gj kx ky bd b be z dk translated">使用groupcollide函数检测碰撞。</p></figure><p id="53e8" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">第1行的<code class="fe nd ne nf ng b">groupcollide</code>函数获取两个sprite组作为参数和两个附加的布尔值。这些布尔参数表示当精灵发生碰撞时，是否应该自动从精灵组中移除。</p><p id="f143" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">我们还使用精灵组在屏幕上绘制精灵。当它们发生冲突时，它们会自动从组中移除，从而从屏幕上移除。</p><p id="9ac8" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated"><code class="fe nd ne nf ng b">groupcollide</code>方法返回一个包含所有碰撞的精灵的字典。我们迭代所有的键，并在碰撞的位置添加一个爆炸精灵。</p></div><div class="ab cl ly lz hy ma" role="separator"><span class="mb bw bk mc md me"/><span class="mb bw bk mc md me"/><span class="mb bw bk mc md"/></div><div class="in io ip iq ir"><h1 id="d6fa" class="mg mh iu bd mi mj mk ml mm mn mo mp mq ka mr kb ms kd mt ke mu kg mv kh mw mx bi translated">敌人精灵运动</h1><p id="6750" class="pw-post-body-paragraph la lb iu lc b ld my jv lf lg mz jy li lj na ll lm ln nb lp lq lr nc lt lu lv in bi translated">敌人的宇宙飞船沿着一条使用多条贝塞尔曲线构建的路径飞行。有一个游戏模式显示贝塞尔曲线和控制点。通过移动控制点，您可以实时更改路径。当你退出游戏时，每个控制点的位置被写入一个文件，这样你就可以在游戏中使用它。</p><p id="ea2c" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">您可以通过按S键来切换显示曲线和控制点的模式。</p><figure class="kk kl km kn gu ko gi gj paragraph-image"><div role="button" tabindex="0" class="kp kq di kr bf ks"><div class="gi gj lx"><img src="../Images/3961726e6f6a1baee71fef81d452b575.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*k-Y25g1AAzuP7NcYOaLrPA.gif"/></div></div><p class="kv kw gk gi gj kx ky bd b be z dk translated">实时改变敌人的移动方式。</p></figure><h2 id="d202" class="nl mh iu bd mi nm nn dn mm no np dp mq lj nq nr ms ln ns nt mu lr nu nv mw nw bi translated">贝塞尔曲线</h2><p id="4021" class="pw-post-body-paragraph la lb iu lc b ld my jv lf lg mz jy li lj na ll lm ln nb lp lq lr nc lt lu lv in bi translated">我们使用一种特殊类型的曲线，称为<a class="ae kz" href="https://en.wikipedia.org/wiki/B%C3%A9zier_curve" rel="noopener ugc nofollow" target="_blank">三次贝塞尔</a>曲线。每条曲线都是使用四个点创建的。使用以下公式计算曲线:</p><pre class="kk kl km kn gu nx ng ny nz aw oa bi"><span id="2614" class="nl mh iu ng b gz ob oc l od oe">P(t) = (1-t)³P0 + 3(1-t)²tP1 + 3(1-t)t²P2 + t³P3</span></pre><p id="ff4e" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">时间(<em class="lw"> t </em>)从零到一。在<em class="lw"> t=0 </em>时，路径在<em class="lw"> P0 </em>处。在<em class="lw"> t=1 </em>时，路径在<em class="lw"> P3 </em>。我们通过使后续段的<em class="lw"> p0 </em>等于前一段的<em class="lw"> p3 </em>来连接多条曲线。</p><p id="3972" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">在控制模式的演示中可以看到，游戏使用了三条相连的贝塞尔曲线。这些曲线的点是由<code class="fe nd ne nf ng b">ControlPointCollectionFactory</code>类创建的。</p><p id="9797" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">第一个点被移到了屏幕之外，这样看起来好像敌人是从顶部潜入的。</p><p id="205c" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">这些控制点的有趣之处在于，第11行上的最后一个点的位置与第14行上的下一个线段的第一个点的位置相同。此外，第23行最后一段的最后一点与第8行的第一点相同。这确保了每条曲线都连接到下一条曲线。</p><figure class="kk kl km kn gu ko"><div class="bz fq l di"><div class="nh ni l"/></div><p class="kv kw gk gi gj kx ky bd b be z dk translated">负责创建贝塞尔曲线点的类。</p></figure><h2 id="ce68" class="nl mh iu bd mi nm nn dn mm no np dp mq lj nq nr ms ln ns nt mu lr nu nv mw nw bi translated">计算贝塞尔曲线</h2><p id="6cd6" class="pw-post-body-paragraph la lb iu lc b ld my jv lf lg mz jy li lj na ll lm ln nb lp lq lr nc lt lu lv in bi translated">我们创建了一个名为<code class="fe nd ne nf ng b">PathPointCalculator</code>的类，负责计算曲线。该类型有一个名为<code class="fe nd ne nf ng b">calculate_path_point</code>的函数，它接受两个参数。第一个参数<code class="fe nd ne nf ng b">control_point_quartet</code>是一个包含贝塞尔曲线的四个点的结构。第二个，<code class="fe nd ne nf ng b">time_to_calculate</code>，是公式中的时间(<em class="lw"> t </em>)。</p><figure class="kk kl km kn gu ko"><div class="bz fq l di"><div class="nh ni l"/></div><p class="kv kw gk gi gj kx ky bd b be z dk translated">负责计算贝塞尔曲线的类。</p></figure><p id="2948" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">如果我们想要组合多条曲线，我们使用第一组点，并让时间从零到一。然后我们使用第二组数据，再次让时间从0到1运行——第三组数据也是如此。</p><h2 id="149e" class="nl mh iu bd mi nm nn dn mm no np dp mq lj nq nr ms ln ns nt mu lr nu nv mw nw bi translated">旋转</h2><p id="8509" class="pw-post-body-paragraph la lb iu lc b ld my jv lf lg mz jy li lj na ll lm ln nb lp lq lr nc lt lu lv in bi translated">如果你注意的话，你可能会看到精灵在沿着曲线移动的时候向他们的方向旋转。我们实时计算旋转，并让Pygame在给定旋转情况下转换精灵。</p><p id="a57f" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">旋转通过<code class="fe nd ne nf ng b">calculate_rotation</code>计算，T5是<code class="fe nd ne nf ng b">Enemy</code>类的一部分。它使用先前和当前的<em class="lw"> x </em>和<em class="lw"> y </em>坐标来计算它们之间的角度。</p><figure class="kk kl km kn gu ko"><div class="bz fq l di"><div class="nh ni l"/></div><p class="kv kw gk gi gj kx ky bd b be z dk translated">计算敌人飞船的旋转。</p></figure><h2 id="18de" class="nl mh iu bd mi nm nn dn mm no np dp mq lj nq nr ms ln ns nt mu lr nu nv mw nw bi translated">实时改变控制点</h2><p id="48e0" class="pw-post-body-paragraph la lb iu lc b ld my jv lf lg mz jy li lj na ll lm ln nb lp lq lr nc lt lu lv in bi translated">在演示中，你看到了我实时改变贝塞尔曲线的点。为了移动这些点，同时保持平滑的曲线，我们必须应用一些简单的规则。</p><p id="829e" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">但首先，我们必须区分构成单个线段的三个点。我们将中间的点称为<em class="lw">路径点</em>，将两个外部点称为<em class="lw">控制点</em>。</p><figure class="kk kl km kn gu ko gi gj paragraph-image"><div role="button" tabindex="0" class="kp kq di kr bf ks"><div class="gi gj of"><img src="../Images/6f02c55e86943b208cfb08dd3bc2a108.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Z21uNfxZ9N5KU46LfTZ4gA.jpeg"/></div></div><p class="kv kw gk gi gj kx ky bd b be z dk translated">每条曲线由一个路径点和两个控制点组成。</p></figure><p id="c534" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">以下是如何在拖移路径点或控制点时保持曲线平滑:</p><ul class=""><li id="b0cf" class="og oh iu lc b ld le lg lh lj oi ln oj lr ok lv ol om on oo bi translated">如果我们移动路径点，我们必须以相同的增量移动左右控制点。</li><li id="e654" class="og oh iu lc b ld op lg oq lj or ln os lr ot lv ol om on oo bi translated">如果我们移动左控制点，我们必须向相反的方向移动右控制点。</li><li id="b722" class="og oh iu lc b ld op lg oq lj or ln os lr ot lv ol om on oo bi translated">如果我们移动右边的控制点，我们必须向相反的方向移动左边的控制点。</li></ul><p id="f5f9" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">我们还必须记住，一些控制点是粘在一起的两个点(例如，前一段的最后一个点和下一段的第一个点)。我们必须同时移动它们。</p><p id="2af7" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">这个行为是在<code class="fe nd ne nf ng b">ControlHandlerMover</code>类中实现的，您可以在下面看到。</p><p id="56d4" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">该类的<code class="fe nd ne nf ng b">__init__</code>构造函数有两个参数。第一个是所有线段所有点的集合。第二个是辅助对象，确定一个点是路径点还是控制点。</p><p id="c167" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated"><code class="fe nd ne nf ng b">move_control_handler</code>功能移动路径或控制点。它接收该点的标识和新的<em class="lw"> x </em>和<em class="lw"> y </em>坐标。然后它改变相关的点。</p><figure class="kk kl km kn gu ko"><div class="bz fq l di"><div class="nh ni l"/></div><p class="kv kw gk gi gj kx ky bd b be z dk translated">负责移动贝塞尔曲线相关点的类。</p></figure></div><div class="ab cl ly lz hy ma" role="separator"><span class="mb bw bk mc md me"/><span class="mb bw bk mc md me"/><span class="mb bw bk mc md"/></div><div class="in io ip iq ir"><h1 id="1adb" class="mg mh iu bd mi mj mk ml mm mn mo mp mq ka mr kb ms kd mt ke mu kg mv kh mw mx bi translated">背景星空</h1><p id="ce6f" class="pw-post-body-paragraph la lb iu lc b ld my jv lf lg mz jy li lj na ll lm ln nb lp lq lr nc lt lu lv in bi translated">没有星域，太空射手就无法存在。所以，我添加了三层星星:小，中，大。每一层都以不同的速度移动，并有不同大小的恒星。这就造成了前进的错觉。</p><figure class="kk kl km kn gu ko gi gj paragraph-image"><div role="button" tabindex="0" class="kp kq di kr bf ks"><div class="gi gj ou"><img src="../Images/8e41ab4fe36aeedf4cbcbfe15a4098ec.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*E-bmA2z6GU-ZuZ08QBLe5g.gif"/></div></div><p class="kv kw gk gi gj kx ky bd b be z dk translated">背景星域</p></figure><p id="5562" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">我在一个名为<code class="fe nd ne nf ng b">StarField</code>的类中实现了starfield，你可以在下面看到。我们有三个数组，每个数组都有一组我们在构造函数中随机生成的星星。</p><p id="4597" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated"><code class="fe nd ne nf ng b">render_stars</code>功能渲染一层的星星。你用星星集合来喂养它——星星的速度、大小和颜色。</p><p id="53d9" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">您可以更改参数来添加更多的星星或添加额外的层，以使视差效果更加显著。</p><figure class="kk kl km kn gu ko"><div class="bz fq l di"><div class="nh ni l"/></div><p class="kv kw gk gi gj kx ky bd b be z dk translated">starfield类负责创建和动画StarField。</p></figure></div><div class="ab cl ly lz hy ma" role="separator"><span class="mb bw bk mc md me"/><span class="mb bw bk mc md me"/><span class="mb bw bk mc md"/></div><div class="in io ip iq ir"><h1 id="bae3" class="mg mh iu bd mi mj mk ml mm mn mo mp mq ka mr kb ms kd mt ke mu kg mv kh mw mx bi translated">结论</h1><p id="40e7" class="pw-post-body-paragraph la lb iu lc b ld my jv lf lg mz jy li lj na ll lm ln nb lp lq lr nc lt lu lv in bi translated">我在开发这个游戏的时候玩得很开心。这让我回想起在当地自助餐厅玩最初的Galaga游戏的童年时光。游戏还远未完成，但还可以玩。它会给一个初学游戏的程序员一个好的开始。</p><p id="ec8a" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">我喜欢Pygame图书馆。它使得碰撞检测和渲染变得简单。如果你想用Python开发游戏，我邀请你去看看。</p><p id="2719" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">我没有谈论分辨率、每秒帧数、游戏循环、音乐、播放声音或得分。对于这些主题，我使用了Pygame提供的标准工具。</p><p id="026f" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">但是你可以在这个GitHub库的源代码中找到它。</p><p id="c1b4" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">感谢您的阅读。</p></div></div>    
</body>
</html>