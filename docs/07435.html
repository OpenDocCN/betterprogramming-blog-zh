<html>
<head>
<title>Make Your UI Updates Instant Without Waiting for a Backend With React</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用React让您的UI即时更新，无需等待后端</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/make-your-ui-updates-instant-without-waiting-for-a-backend-with-react-bc81147c3c32?source=collection_archive---------4-----------------------#2021-01-14">https://betterprogramming.pub/make-your-ui-updates-instant-without-waiting-for-a-backend-with-react-bc81147c3c32?source=collection_archive---------4-----------------------#2021-01-14</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="c917" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">React中请求批处理的乐观UI更新</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/94b26e114c73de17823d9b8c442f5289.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*4iZynBU4gWo9ocjM"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">即时照片会留下美好的回忆。即时用户界面是很好的体验。(照片由<a class="ae ky" href="https://unsplash.com/@jakobowens1?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">雅各布·欧文斯</a>在<a class="ae ky" href="https://unsplash.com/?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄)</p></figure><p id="2a3f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在本教程中，我想分享我的解决方案，来创建非常具有交互性的用户界面，在这样的界面中，用户感觉所有的事情都是立即完成的。用户等待界面响应的时间越短越好。我们避免沮丧，因此吸引了更多的用户。</p><p id="55d9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">目标是让用户感觉后端正在立即响应，并使更新达到最佳，而不是用太多的请求淹没API。</p><p id="4095" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">为了实现这两个目标，我将介绍在API请求批处理之后进行乐观UI更新。所有这些都将作为React组件来实现。出于本文的目的，我们将有一个照片列表作为示例。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="f79c" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">词汇表</h1><p id="536b" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">首先，我想澄清一些我们将在整篇文章中使用的概念。</p><p id="5eeb" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">所谓的<em class="mz">乐观UI更新，</em>我指的是在与用户交互后立即在UI中完成的更新，而不需要等待后端响应。在任何错误的情况下，我们可以有一个回退逻辑，通常重置回它们的原始状态。</p><p id="2a69" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">通过<em class="mz">请求批处理</em>，我的意思是发送一个带有更新列表的请求，而不是对每个更新进行一个API调用。这要求后端处理这样的请求。</p><p id="0aaf" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们还将使用<em class="mz">去抖</em>功能。简而言之，这是一个</p><blockquote class="na nb nc"><p id="d90a" class="kz la mz lb b lc ld ju le lf lg jx lh nd lj lk ll ne ln lo lp nf lr ls lt lu im bi translated">函数，只要它继续被调用，就不会被触发。该函数将在停止调用N毫秒后被调用。—来自https://davidwalsh.name/javascript-debounce-function<a class="ae ky" href="https://davidwalsh.name/javascript-debounce-function" rel="noopener ugc nofollow" target="_blank">的定义</a></p></blockquote><p id="55af" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们将使用它，但有一点小小的不同，那就是我们将在一段时间后调用这个函数，不管它是否还在被调用。这种方式也非常类似于节流(但我认为节流时间是可变的)。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="54d3" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">目标</h1><p id="51b1" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">在本教程中，我们将实现一个你喜欢的图片的照片网格。负责喜欢照片的按钮会在点击后立即切换状态。在后台，应用程序将等待其他类似的按钮点击，然后在一个批处理中将多个更新发送到后端。</p><p id="288b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">因为一幅图像胜过千言万语，所以看一下下面这个我们将要实现的例子:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nk"><img src="../Images/b309762aa0def2c5b8d69ab8138c7c35.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*d8Clumx9XYEYwPjnyLsJaA.gif"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">交互式照片网格。所有图片均来自pexels.com</p></figure><p id="d1dd" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">你可以看到一个用户在第一行喜欢了两张照片，超时后，一个更新请求被发送。照片被标记为正在更新。与此同时，一个用户喜欢第二行的另外两张照片，另一个请求被发送。</p><p id="c098" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">注意:“正在更新…”状态只是为了本教程而显示的，但在实际情况下，它可能会被隐藏，使UI感觉即时响应。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="2406" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">问题</h1><p id="c084" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated"><em class="mz">如果你想了解教程的核心，可以跳过这一部分。在这里，我将进一步强调促使我创建解决方案的问题，以及本文后面的内容。</em></p><p id="af9f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">一段时间以前，当我在我的软件产品(员工日程安排产品)中实现一个组件时，我偶然发现了一个需要解决的重要问题。我创建了一个交互性很强的表格，每个单元格代表一个员工在给定班次的可用性。起初，我采取了一种天真的方法，只是为了让事情正常运行:细胞是相互独立的，在点击每个细胞后，有一个请求被发送到后端。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nl"><img src="../Images/9f824486d5023c4d549bfbba5c54458d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*pQATiowO26QZOOWMv1tARg.gif"/></div></div></figure><p id="529d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在图中，您可以看到DevTools的Network选项卡中发生了什么。这肯定是可行的，但是随着负载的增加，这可能会很快造成一些麻烦，并使后端充满不必要的请求。</p><p id="1957" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">由于任何超时或滞后都会使这个表很难使用，所以UI需要尽快更新。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nm"><img src="../Images/265b55ef37f4223132903c775b19f5c2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*T4pGEkYwxmhtSPugMzXpog.gif"/></div></div></figure><p id="d271" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">基本上，我们想要实现这张图片中的内容。您可以单击多个项目，它们的状态会立即更新，并且只有一个请求会发送到后端。</p><p id="71ce" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果出现任何错误，给定批次中的项目将被重置为其原始状态。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="21f6" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">解决办法</h1><h2 id="9e9b" class="nn md it bd me no np dn mi nq nr dp mm li ns nt mo lm nu nv mq lq nw nx ms ny bi translated">要求</h2><p id="3e53" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">这些是我希望我的解决方案满足的要求:</p><ol class=""><li id="d1ee" class="nz oa it lb b lc ld lf lg li ob lm oc lq od lu oe of og oh bi translated">UI更新瞬间完成，很乐观。</li><li id="bf01" class="nz oa it lb b lc oi lf oj li ok lm ol lq om lu oe of og oh bi translated">为一批更新发送一个API请求(给定的API本身已经为此做好了准备)。</li><li id="181d" class="nz oa it lb b lc oi lf oj li ok lm ol lq om lu oe of og oh bi translated">应该同时处理多个批处理请求(例如，如果进行了一个API调用，但是响应还没有到来，则可以处理另一批项目)。</li><li id="0c53" class="nz oa it lb b lc oi lf oj li ok lm ol lq om lu oe of og oh bi translated">如果出现任何API错误，项目将恢复到其原始状态。</li><li id="b142" class="nz oa it lb b lc oi lf oj li ok lm ol lq om lu oe of og oh bi translated">跳过不必要的请求(例如，当您第一次喜欢照片，然后很快不喜欢照片时，不需要将任何请求发送到后端)。</li></ol><h2 id="ef0e" class="nn md it bd me no np dn mi nq nr dp mm li ns nt mo lm nu nv mq lq nw nx ms ny bi translated">解决方法解释</h2><p id="a338" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">我们将在组件(<code class="fe ng nh ni nj b">photos</code>变量)中保存照片列表，但是每当我们想要修改照片时，我们将修改添加到待更新列表中。该列表可以增长，直到一段时间过去(去抖动)，然后执行更新。然后刷新列表，准备接受另一批更新。</p><p id="42b0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">当执行更新时，我们调用API。在处理API调用时，我们将向照片添加一个<code class="fe ng nh ni nj b">locked: true</code>属性(例如，如果我们想在UI中禁用一些与之相关的控件)。</p><p id="2427" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">负责向未决更新列表添加修改的函数将被称为<code class="fe ng nh ni nj b">updatePhotos</code>，而用于执行更新的函数将被简单地命名为<code class="fe ng nh ni nj b">performUpdates</code>。后者是一个实现细节，将只在内部调用。这是为了让我们的解决方案的界面尽可能简单。外部组件只需要调用<code class="fe ng nh ni nj b">updatePhotos</code>，而不需要知道内部发生了什么。</p><p id="897c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">将修改添加到待定更新列表不会立即修改照片列表。为了模拟这种情况，更新按以下方式进行。我们将创建一个临时变量<code class="fe ng nh ni nj b">currentPhotos</code>，它将保存照片的“当前”版本，并应用更新。换句话说，它将把<code class="fe ng nh ni nj b">photos</code>列表和<code class="fe ng nh ni nj b">pendingUpdates</code>列表合并，创建一个实际的项目列表。我们将使用<code class="fe ng nh ni nj b">useMemo</code>来确保它更高的性能。</p><p id="dcc9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">API调用完成后，挂起的更新将永久应用于<code class="fe ng nh ni nj b">photos</code>列表。</p><p id="7699" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这样，使用<code class="fe ng nh ni nj b">currentPhotos</code>，我们将创建一个“乐观更新”机制——立即应用更新，但调用API时会有一些超时，假设API调用成功后手动更新的状态是相同的。</p><p id="6c87" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">为了进一步阐明这种机制，我创建了下面的表格/调用图混合来显示在调用<code class="fe ng nh ni nj b">updatePhotos</code>和<code class="fe ng nh ni nj b">performUpdates</code>之后，所提到的状态是如何变化的(<code class="fe ng nh ni nj b">pendingUpdates, photos, currentPhotos</code>)。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi on"><img src="../Images/a99f75f7b718bba3faafeaafbb026fc8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*U_U7ENtrRkS91TTAe-EOow.png"/></div></div></figure><p id="8411" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在图像中，我们可以看到两个<code class="fe ng nh ni nj b">performUpdate</code>呼叫:蓝色和红色。它们由<code class="fe ng nh ni nj b">updatePhotos</code>调用触发(在去抖超时后)。蓝色的正在更新id为<code class="fe ng nh ni nj b">1</code>和<code class="fe ng nh ni nj b">2</code>的照片。当蓝色API调用仍在处理时，<code class="fe ng nh ni nj b">pendingUpdates</code>“队列”是清晰的，所以我们调用另一个<code class="fe ng nh ni nj b">updatePhotos</code>，现在就像id为<code class="fe ng nh ni nj b">3</code>的照片。</p><p id="ddba" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">当我们还在等待蓝色的回应时，红色的<code class="fe ng nh ni nj b">performUpdate</code>被调用。最后，两个请求都完成，并且从照片中移除了<code class="fe ng nh ni nj b">locked</code>标志。</p><p id="d9d5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在每一步中，<code class="fe ng nh ni nj b">currentPhotos</code>代表来自<code class="fe ng nh ni nj b">photos</code>和<code class="fe ng nh ni nj b">pendingUpdates</code>的合并状态，以模仿在<code class="fe ng nh ni nj b">photos</code>列表上即时完成的更新。</p><h2 id="1b02" class="nn md it bd me no np dn mi nq nr dp mm li ns nt mo lm nu nv mq lq nw nx ms ny bi translated">解决方案的核心逻辑</h2><p id="7780" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">让我们展示一下该解决方案的核心功能。下面的要点显示了第一个，<code class="fe ng nh ni nj b">performUpdates</code>:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oo op l"/></div></figure><p id="7fe4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">为了尽可能清楚地显示意图和流程，它被简化了一点，没有了辅助变量。我们稍后将讨论更多细节。</p><p id="23cf" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">负责更新<code class="fe ng nh ni nj b">pendingUpdates</code>列表的第二个函数是这里的<code class="fe ng nh ni nj b">updatePhotos</code>:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oo op l"/></div></figure><p id="6393" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe ng nh ni nj b">getItemsToResetAndUpdate</code>将传入的<code class="fe ng nh ni nj b">itemsUpdates</code>与当前状态进行比较，以决定该项是否需要实际更新。这满足了需求5(不做不必要的更新)。在函数中，我们更新待更新的列表，然后调用<code class="fe ng nh ni nj b">performUpdates</code>(去抖)。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="84c0" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">一些技术细节和使用的方法</h1><h2 id="e303" class="nn md it bd me no np dn mi nq nr dp mm li ns nt mo lm nu nv mq lq nw nx ms ny bi translated">关闭</h2><p id="f1ad" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">我们将使用<a class="ae ky" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Closures" rel="noopener ugc nofollow" target="_blank"> JavaScript闭包</a>来将一些信息保存在内存中，而不是手动将其添加到一些状态变量中。这样，我们可以只有一个<code class="fe ng nh ni nj b">pendingUpdates</code>变量，但可以用于多个批处理。</p><p id="41fa" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在调用<code class="fe ng nh ni nj b">performUpdates</code>时，它会记住<code class="fe ng nh ni nj b">pendingUpdates</code>的副本，即使它是异步的。这样我们将知道一旦API调用完成，哪些照片需要移除<code class="fe ng nh ni nj b">locked</code>标志，或者如果我们得到一个API错误，将它们重置为原始状态。</p><h2 id="7980" class="nn md it bd me no np dn mi nq nr dp mm li ns nt mo lm nu nv mq lq nw nx ms ny bi translated">钩住</h2><p id="9cf7" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">通过我们的解决方案设计，我们允许多个异步调用同时运行。为了在进行状态更新时(从<code class="fe ng nh ni nj b">useState</code>开始的<code class="fe ng nh ni nj b">setState</code>)总是拥有最新的状态，我们将主要使用<a class="ae ky" href="https://reactjs.org/docs/hooks-reference.html#functional-updates" rel="noopener ugc nofollow" target="_blank">功能状态更新</a>:</p><pre class="kj kk kl km gt oq nj or os aw ot bi"><span id="a7ff" class="nn md it nj b gy ou ov l ow ox">const [state, setState] = useState({});<br/>setState(photos =&gt; /* ... */)</span></pre><p id="d27a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这样，这里的<code class="fe ng nh ni nj b">photos</code>变量将总是引用最新的照片，而不是过时的引用。</p><p id="dcd8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果你想了解更多关于功能更新如何工作以及何时需要更新的信息，<a class="ae ky" href="https://medium.com/better-programming/you-dont-know-usestate-until-you-ve-used-functional-updates-5da52117620f" rel="noopener">请查看我的另一篇文章</a>，在那里我会在更广泛的背景下解释这一点。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="90cd" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">履行</h1><p id="3e41" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">我不会从头开始创建一个完整的应用程序，因为这篇文章本身的主题已经足够大了。相反，我将关注解决方案的实现。</p><p id="0e35" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果您想用一个示例照片网格运行整个工作项目，请克隆这个<a class="ae ky" href="https://github.com/tfiechowski/optimisic-react-batching-tutorial" rel="noopener ugc nofollow" target="_blank"> GitHub repo </a>。一切都在里面，包括实现的解决方案、样式、应用程序设置和测试！</p><p id="232a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">按照存储库中的项目结构，实现将在<code class="fe ng nh ni nj b">src/batching/usePhotos.js</code>中完成。让我们看一下<code class="fe ng nh ni nj b">usePhotos</code>的一个精简的“初始”版本，以帮助我们理解我们将要实现的组件的框架和结构:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oo op l"/></div></figure><p id="6a91" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们使用<code class="fe ng nh ni nj b">useState</code>来保存<code class="fe ng nh ni nj b">photos</code>列表和<code class="fe ng nh ni nj b">pendingUpdates</code>对象。</p><p id="03e1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">为什么反对？我们将使用照片id作为密钥，以便更快、更方便地访问待定更新项目。该对象将具有以下形状:</p><pre class="kj kk kl km gt oq nj or os aw ot bi"><span id="12f9" class="nn md it nj b gy ou ov l ow ox">{ [id: string]: { [id: string}, /* photo modifications */ }}</span></pre><p id="5761" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们将实现上述功能，并逐个添加必要的实用程序，以满足所有需求。</p><h2 id="23d8" class="nn md it bd me no np dn mi nq nr dp mm li ns nt mo lm nu nv mq lq nw nx ms ny bi translated">添加待定更新列表-更新照片</h2><p id="9375" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">先实现<code class="fe ng nh ni nj b">updatePhotos</code>吧:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oo op l"/></div></figure><p id="0515" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">作为一个参数，<code class="fe ng nh ni nj b">itemsToUpdate</code>，我们正在传递一个具有以下形状的对象数组:<code class="fe ng nh ni nj b">{ id: string, /* photo modifications */ }</code>，例如:<code class="fe ng nh ni nj b">{id: 1, liked: true}</code>如果我们想将id为:<code class="fe ng nh ni nj b">1</code>的照片标记为喜欢。</p><p id="b3d2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">通过<code class="fe ng nh ni nj b">getItemsToResetAndUpdate</code>,我们满足了跳过不必要更新的要求5。如果一张照片在短时间内被喜欢和不喜欢，该函数将检测到这一点，并从<code class="fe ng nh ni nj b">pendingUpdates</code>对象中删除该更新。</p><p id="28a0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们在这里使用<code class="fe ng nh ni nj b">immutability-helper</code>中的<code class="fe ng nh ni nj b">update</code>函数。简而言之，它将从<code class="fe ng nh ni nj b">pendingUpdates</code>中删除<code class="fe ng nh ni nj b">$unset</code>中指定的所有键，并将它与<code class="fe ng nh ni nj b">toUpdate</code>对象合并。这样，我们删除了所有不必要的更新，并添加了有效的更新。</p><p id="1ed0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">最后，我们调用<code class="fe ng nh ni nj b">performUpdates.callback</code>——这是来自<code class="fe ng nh ni nj b">useDebouncedCallback</code>的值应该如何使用。</p><p id="97af" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们转移到<code class="fe ng nh ni nj b">performUpdate</code>。我们稍后将回到<code class="fe ng nh ni nj b">getItemsToResetAndUpdate</code>和其他实用函数。</p><h2 id="d5d2" class="nn md it bd me no np dn mi nq nr dp mm li ns nt mo lm nu nv mq lq nw nx ms ny bi translated">执行更新—执行更新</h2><p id="63b6" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">这是大多数必要逻辑发生的函数。它是通过以下方式实现的:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oo op l"/></div></figure><p id="0621" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在检查了是否没有未完成的更新需要提前返回后，我们清除<code class="fe ng nh ni nj b">pendingUpdates</code>，这样我们就可以接受下一批更新，而不会干扰当前的更新。</p><p id="3de6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">接下来，更新被应用到<code class="fe ng nh ni nj b">photos</code>以反映<code class="fe ng nh ni nj b">pendingUpdates</code>的修改。然后，我们调用API ( <code class="fe ng nh ni nj b">onUpdate</code>)并在成功时从照片中移除<code class="fe ng nh ni nj b">locked</code>标志，或者在出现任何异常的情况下将照片恢复到原始状态。</p><h2 id="4125" class="nn md it bd me no np dn mi nq nr dp mm li ns nt mo lm nu nv mq lq nw nx ms ny bi translated">公用事业</h2><p id="7d3c" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">我们现在将讨论实用函数。先从提到的<code class="fe ng nh ni nj b">getItemsToResetAndUpdate</code>说起。我们还将在这里介绍<code class="fe ng nh ni nj b">isUpdateNeeded</code>。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oo op l"/></div></figure><p id="f7c7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们使用该实用程序来检查哪些<code class="fe ng nh ni nj b">pendingUpdates</code>需要执行，哪些可以丢弃。我们使用<code class="fe ng nh ni nj b">partition</code>根据是否需要执行将<code class="fe ng nh ni nj b">pendingUpdates</code>分成两组。</p><p id="6676" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">然后我们把它们转换成合适的格式:<code class="fe ng nh ni nj b">toReset</code>会和<code class="fe ng nh ni nj b">$unset</code>一起使用，所以它需要是一个photo IDs的数组，<code class="fe ng nh ni nj b">toUpdate</code>只是一个和<code class="fe ng nh ni nj b">pendingUpdates</code>形状相同的对象来与之合并。</p><p id="14e8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe ng nh ni nj b">isUpdateNeeded</code>功能检查在应用<code class="fe ng nh ni nj b">itemUpdate</code>后照片是否需要更新。基本上，它检查<code class="fe ng nh ni nj b">itemUpdate</code>中的字段是否与原始照片中的相应字段不同。如果它们相同，则不需要更新。</p><p id="6bd8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在让我们实现在<code class="fe ng nh ni nj b">performUpdate</code>中使用的所有剩余的实用程序。它们是相当简单的状态操作函数:</p><ul class=""><li id="4590" class="nz oa it lb b lc ld lf lg li ob lm oc lq od lu oy of og oh bi translated"><code class="fe ng nh ni nj b"><strong class="lb iu">removePhotosLockedFlag </strong></code>以<code class="fe ng nh ni nj b">pendingUpdates</code>为参数，如果照片中有对应的<code class="fe ng nh ni nj b">pendingUpdate</code>，则从照片中移除<code class="fe ng nh ni nj b">locked</code>标志。</li><li id="df5b" class="nz oa it lb b lc oi lf oj li ok lm ol lq om lu oy of og oh bi translated"><code class="fe ng nh ni nj b"><strong class="lb iu">revertPhotosToOriginalState</strong></code>将原始照片列表作为参数，并将当前照片与其原始版本交换。它还删除了<code class="fe ng nh ni nj b">locked</code>标志，以防万一。</li><li id="11b1" class="nz oa it lb b lc oi lf oj li ok lm ol lq om lu oy of og oh bi translated"><code class="fe ng nh ni nj b"><strong class="lb iu">applyUpdatesToPhotos</strong></code>将<code class="fe ng nh ni nj b">pendingUpdates</code>的修改应用到<code class="fe ng nh ni nj b">photos</code>列表。</li><li id="0b5f" class="nz oa it lb b lc oi lf oj li ok lm ol lq om lu oy of og oh bi translated"><code class="fe ng nh ni nj b"><strong class="lb iu">clearPendingUpdates</strong></code>清除待定更新列表。它也可以被称为<code class="fe ng nh ni nj b">setPendingUpdates({})</code>，但是我想将其提取到一个具有更有意义的名称的函数中。</li></ul><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oo op l"/></div></figure></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="033e" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">解决方案使用</h1><p id="6300" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">现在，随着我们的解决方案的实现，我们可以创建一个简单的组件来利用<code class="fe ng nh ni nj b">usePhotos</code>。</p><p id="afdc" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">同样，我将重点展示如何使用<code class="fe ng nh ni nj b">usePhotos</code>,而不是挖掘关于样式和运行整个应用程序的细节。您可以检查GitHub repo，所有这些东西都已实现，应用程序已准备好运行。</p><p id="7414" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们可以创建一个简单的<code class="fe ng nh ni nj b">PhotoList</code>组件，如下所示:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oo op l"/></div></figure><p id="ac28" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">从<code class="fe ng nh ni nj b">usePhotos</code>挂钩上仅使用<code class="fe ng nh ni nj b">photos</code>和<code class="fe ng nh ni nj b">updatePhotos</code>。我们呈现列表<code class="fe ng nh ni nj b">photos</code>并调用适当的处理程序进行相似/不相似操作。他们在后面叫<code class="fe ng nh ni nj b">updatePhotos</code>。</p><p id="75ef" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">Dummy <code class="fe ng nh ni nj b">onUpdate</code>只是一个函数，它会在随机超时后成功解析，以模拟需要一些时间才能完成的实际异步API调用。</p><p id="5acc" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在我们应该能够创建一个网格，如下图所示:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nk"><img src="../Images/b309762aa0def2c5b8d69ab8138c7c35.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*d8Clumx9XYEYwPjnyLsJaA.gif"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">交互式照片网格。所有图片均来自pexels.com</p></figure></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="154b" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">摘要</h1><p id="5320" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">在请求批处理的同时进行乐观UI更新可能会很快变得复杂。希望我分享的解决方案能帮到你。</p><p id="3517" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">解决这个问题肯定还有其他方法，但我发现这个方法对我来说效果最好。在这种情况下，API调用是对常规端点(如REST)进行的。如果您正在使用<a class="ae ky" href="https://graphql.org/" rel="noopener ugc nofollow" target="_blank"> GraphQL </a>，由于该解决方案的“单端点”性质，您有一些开箱即用的更广泛的可能性，特别是当您将其与类似<a class="ae ky" href="https://www.apollographql.com/docs/react/" rel="noopener ugc nofollow" target="_blank"> Apollo Client </a> with cache的东西挂钩时。如果你想看关于GraphQL批量请求的乐观更新的类似教程，请告诉我。</p><h2 id="f5de" class="nn md it bd me no np dn mi nq nr dp mm li ns nt mo lm nu nv mq lq nw nx ms ny bi translated">谢谢！</h2><p id="006f" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">最后——感谢你坚持到最后！欢迎在评论中发表你的观点。我非常开放，渴望听到你的反馈，无论是积极的还是消极的(或者说，建设性的)！</p></div></div>    
</body>
</html>