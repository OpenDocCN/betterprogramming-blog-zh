<html>
<head>
<title>Use Codable to Parse JSON in Swift</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用Codable解析Swift中的JSON</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/use-codable-to-parse-json-in-swift-b937f59b63a4?source=collection_archive---------23-----------------------#2020-01-21">https://betterprogramming.pub/use-codable-to-parse-json-in-swift-b937f59b63a4?source=collection_archive---------23-----------------------#2020-01-21</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="2e10" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">带有代码示例</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/9f547cf4505d4b8d80abf99883962484.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*oCIMUul5AFR-jPm-0q0Qtg.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">由<a class="ae ky" href="https://pixabay.com/users/bohemienne-123410/" rel="noopener ugc nofollow" target="_blank"> bohemienne </a>在<a class="ae ky" href="https://pixabay.com/illustrations/minimalism-simplify-downsizing-241876/" rel="noopener ugc nofollow" target="_blank"> Pixabay </a>上的插图</p></figure><p id="edad" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">Swift中的JSON解析是一件很常见的事情。几乎每个app都解码JSON，以可视化的方式展现数据。解析JSON绝对是作为iOS开发人员应该学习的基础知识之一。</p><p id="ca80" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在Swift中解码JSON非常容易，不需要任何外部依赖。Swift附带的基本API足以完成这项工作，所以让我们开始吧！</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="efe3" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">JSON解码的基础</h1><p id="05cd" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">最好从基础开始，让您了解Swift中的JSON解析是如何工作的。让我们以SwiftLee的博客帖子为例:</p><pre class="kj kk kl km gt mz na nb nc aw nd bi"><span id="d0aa" class="ne md it na b gy nf ng l nh ni">{<br/>	"title": "Optionals in Swift explained: 5 things you should know",<br/>	"url": "https://www.avanderlee.com/swift/optionals-in-swift-explained-5-things-you-should-know/",<br/>	"category": "Swift",<br/>	"views": 47093<br/>}</span></pre><p id="2f82" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">通过使用<code class="fe nj nk nl na b">Decodable</code>协议，我们可以很容易地对此进行解码:</p><pre class="kj kk kl km gt mz na nb nc aw nd bi"><span id="c0cf" class="ne md it na b gy nf ng l nh ni">struct BlogPost: Decodable {<br/>    enum Category: String, Decodable {<br/>        case swift, combine, debugging, xcode<br/>    }<br/><br/>    let title: String<br/>    let url: URL<br/>    let category: Category<br/>    let views: Int<br/>}</span></pre><p id="05c0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们定义了一个符合<code class="fe nj nk nl na b">Decodable</code>协议的<code class="fe nj nk nl na b">Category</code>枚举。所有属性都与我们定义的JSON示例中的名称相匹配。每个符合<code class="fe nj nk nl na b">Decodable</code>协议的类型都会自动转换。这意味着你也可以使用你自己定制的<code class="fe nj nk nl na b">Decodable</code>类型作为属性。</p><p id="9c27" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">通过使用<code class="fe nj nk nl na b">JSONDecoder</code>，我们可以让JSON解析变得非常简单:</p><pre class="kj kk kl km gt mz na nb nc aw nd bi"><span id="fa1c" class="ne md it na b gy nf ng l nh ni">let JSON = """<br/>{<br/>    "title": "Optionals in Swift explained: 5 things you should know",<br/>    "url": "https://www.avanderlee.com/swift/optionals-in-swift-explained-5-things-you-should-know/",<br/>    "category": "swift",<br/>    "views": 47093<br/>}<br/>"""<br/><br/>let jsonData = JSON.data(using: .utf8)!<br/>let blogPost: BlogPost = try! JSONDecoder().decode(BlogPost.self, from: jsonData)<br/><br/>print(blogPost.title) // Prints: "Optionals in Swift explained: 5 things you should know"</span></pre><p id="2e88" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">尽管这可能给人一种JSON解析非常简单的印象，但这都是边缘情况。幸运的是，Swift也有足够的能力处理这些问题。</p><h2 id="e0da" class="ne md it bd me nm nn dn mi no np dp mm li nq nr mo lm ns nt mq lq nu nv ms nw bi translated">不需要定义每个属性</h2><p id="dedd" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">很高兴知道您不需要定义JSON附带的每个属性。这意味着下面的结构也可以工作:</p><pre class="kj kk kl km gt mz na nb nc aw nd bi"><span id="066e" class="ne md it na b gy nf ng l nh ni">struct BlogPost: Decodable {<br/>    let title: String<br/>}</span></pre><p id="d2ba" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这很好，因为这可能是在你已经发布了一个版本的应用程序之后，你正在添加新的密钥。如果它不这样工作，你可以很容易地打破旧版本。</p><h2 id="01d3" class="ne md it bd me nm nn dn mi no np dp mm li nq nr mo lm ns nt mq lq nu nv ms nw bi translated">选项和JSON解码</h2><p id="1a84" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">这可能是因为您不确定是否返回了一个JSON键或者是否设置了一个值。在这种情况下，您可以将一个Swift属性定义为可选的，然后<code class="fe nj nk nl na b">JSONDecoder</code>会处理剩下的事情。</p><pre class="kj kk kl km gt mz na nb nc aw nd bi"><span id="30b8" class="ne md it na b gy nf ng l nh ni">struct BlogPost: Decodable {<br/>    let title: String<br/>    /// Define a key as optional if it can be returned as `nil` or if it does not always exist in the JSON.<br/>    let subtitle: String?<br/>}</span></pre></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="1391" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">在Swift中解码JSON数组</h1><p id="297c" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">在Swift中解码一个JSON数组几乎和解码一个JSON对象一样简单。以下面的JSON为例:</p><pre class="kj kk kl km gt mz na nb nc aw nd bi"><span id="2a19" class="ne md it na b gy nf ng l nh ni">[{<br/>    "title": "Optionals in Swift explained: 5 things you should know",<br/>    "url": "https://www.avanderlee.com/swift/optionals-in-swift-explained-5-things-you-should-know/"<br/>},<br/>{<br/>    "title": "EXC_BAD_ACCESS crash error: Understanding and solving it",<br/>    "url": "https://www.avanderlee.com/swift/exc-bad-access-crash/"<br/>},<br/>{<br/>    "title": "Thread Sanitizer explained: Data Races in Swift",<br/>    "url": "https://www.avanderlee.com/swift/thread-sanitizer-data-races/"<br/>}]</span></pre><p id="df84" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们可以通过将<code class="fe nj nk nl na b">Decodable</code>类型定义为<code class="fe nj nk nl na b">[BlogPost].self</code>来解析这个博客文章列表:</p><pre class="kj kk kl km gt mz na nb nc aw nd bi"><span id="e5af" class="ne md it na b gy nf ng l nh ni">struct BlogPost: Decodable {<br/>    let title: String<br/>    let url: URL<br/>}<br/><br/>let blogPosts: [BlogPost] = try! JSONDecoder().decode([BlogPost].self, from: jsonData)<br/>print(blogPosts.count) // Prints: 3</span></pre></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="95cc" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">将JSON键映射到自定义属性名</h1><p id="90d5" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">JSON解析并不总是像将相同的键复制到一个结构中那样简单。在映射JSON时，希望定义不同的属性名是很常见的。</p><p id="3db3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">以之前的JSON为例，我们可能想在JSON模型中将<code class="fe nj nk nl na b">url</code>命名为<code class="fe nj nk nl na b">htmlLink</code>。我们可以通过定义一个定制的<code class="fe nj nk nl na b">CodingKeys</code>枚举来创建这个映射:</p><pre class="kj kk kl km gt mz na nb nc aw nd bi"><span id="b13b" class="ne md it na b gy nf ng l nh ni">struct BlogPost: Decodable {<br/>    enum Category: String, Decodable {<br/>        case swift, combine, debugging, xcode<br/>    }<br/><br/>    enum CodingKeys: String, CodingKey {<br/>        case title, category, views<br/>        // Map the JSON key "url" to the Swift property name "htmlLink"<br/>        case htmlLink = "url"<br/>    }<br/><br/>    let title: String<br/>    let htmlLink: URL<br/>    let category: Category<br/>    let views: Int<br/>}<br/><br/><br/>let blogPost: BlogPost = try! JSONDecoder().decode(BlogPost.self, from: jsonData)<br/>print(blogPost.htmlLink) // Prints: "https://www.avanderlee.com/swift/optionals-in-swift-explained-5-things-you-should-know/"</span></pre><p id="7a6c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如您所见，我们定义了一个自定义映射，将JSON键<code class="fe nj nk nl na b">url</code>转换成Swift属性名<code class="fe nj nk nl na b">htmlLink</code>。</p><p id="9de7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">因为我们没有改变标题、类别或视图的名称，所以我们可以保持这种情况不变。我们必须包含这些键，因为<code class="fe nj nk nl na b">JSONDecoder</code>将切换到我们为所有定义的属性定义的映射。如果我们不这样做，我们会遇到以下错误:</p><blockquote class="nx ny nz"><p id="d06e" class="kz la oa lb b lc ld ju le lf lg jx lh ob lj lk ll oc ln lo lp od lr ls lt lu im bi translated">类型“BlogPost”不符合协议“Decodable”</p></blockquote></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="8e56" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">骆驼案和蛇案之间的转换</h1><p id="178b" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">为键定义自定义映射的一个常见原因是，如果您使用的后端使用snake case来命名属性。在Swift中，我们大多使用camel case，这意味着我们以小写字母开始，然后大写后续单词的第一个字母:<code class="fe nj nk nl na b">htmlLink</code>或<code class="fe nj nk nl na b">numberOfBlogPosts</code>。蛇案中的同字看起来是这样的:<code class="fe nj nk nl na b">html_link</code>和<code class="fe nj nk nl na b">number_of_blog_posts</code>。</p><p id="7348" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">幸运的是，我们不必为每个已定义的键定义自定义映射。以博客的JSON为例:</p><pre class="kj kk kl km gt mz na nb nc aw nd bi"><span id="410d" class="ne md it na b gy nf ng l nh ni">{<br/>    "title": "A weekly Swift Blog on Xcode and iOS Development - SwiftLee",<br/>    "url": "https://www.avanderlee.com",<br/>    "total_visitors": 378483,<br/>    "number_of_posts": 47093<br/>}</span></pre><p id="eba7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们可以通过将解码器的<code class="fe nj nk nl na b">keyEncodingStrategy</code>设置为<code class="fe nj nk nl na b">.convertToSnakeCase</code>来轻松解码JSON:</p><pre class="kj kk kl km gt mz na nb nc aw nd bi"><span id="6ac4" class="ne md it na b gy nf ng l nh ni">struct Blog: Decodable {<br/>    let title: String<br/>    let url: URL<br/>    let totalVisitors: Int<br/>    let numberOfPosts: Int<br/>}<br/><br/>let decoder = JSONDecoder()<br/>decoder.keyDecodingStrategy = .convertFromSnakeCase<br/><br/>let blog: Blog = try! decoder.decode(Blog.self, from: jsonData)<br/>print(blog.numberOfPosts) // Prints: 47093</span></pre><p id="49e9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这太简单了。这也适用于自定义键。因此，如果您想像我们之前做的那样将<code class="fe nj nk nl na b">url</code>映射到<code class="fe nj nk nl na b">htmlLink</code>，您可以按如下方式轻松完成:</p><pre class="kj kk kl km gt mz na nb nc aw nd bi"><span id="f414" class="ne md it na b gy nf ng l nh ni">struct Blog: Decodable {<br/><br/>    enum CodingKeys: String, CodingKey {<br/>        case title, totalVisitors, numberOfPosts<br/><br/>        case htmlLink = "url"<br/>    }<br/><br/>    let title: String<br/>    let htmlLink: URL<br/>    let totalVisitors: Int<br/>    let numberOfPosts: Int<br/>}</span></pre></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="ca66" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">用定制格式解码JSON日期</h1><p id="e65d" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">JSON中的日期被定义为字符串或时间间隔，并且需要一种转换策略。我们可以在我们的<code class="fe nj nk nl na b">JSONDecoder</code>上设置这样的策略，就像我们将骆驼案例转换为蛇案例一样。</p><p id="5659" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">以下面的JSON博客文章为例:</p><pre class="kj kk kl km gt mz na nb nc aw nd bi"><span id="075a" class="ne md it na b gy nf ng l nh ni">{<br/>    "title": "Optionals in Swift explained: 5 things you should know",<br/>    "date": "2019-10-21T09:15:00Z"<br/>}</span></pre><p id="4ccf" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">本例中的日期定义如下:<code class="fe nj nk nl na b">yyyy-MM-dd'T'HH:mm:ss</code>。我们需要用这种格式创建一个自定义的<code class="fe nj nk nl na b">DateFormatter</code>，并通过将<code class="fe nj nk nl na b">dateDecodingStrategy</code>设置为<code class="fe nj nk nl na b">formatted</code>将其应用于我们的解码器:</p><pre class="kj kk kl km gt mz na nb nc aw nd bi"><span id="e93b" class="ne md it na b gy nf ng l nh ni">struct BlogPost: Decodable {<br/>    let title: String<br/>    let date: Date<br/>}<br/><br/>let decoder = JSONDecoder()<br/>let dateFormatter = DateFormatter()<br/>dateFormatter.dateFormat = "yyyy-MM-dd'T'HH:mm:ssZ"<br/>dateFormatter.locale = Locale(identifier: "en_US")<br/>dateFormatter.timeZone = TimeZone(secondsFromGMT: 0)<br/>decoder.dateDecodingStrategy = .formatted(dateFormatter)<br/><br/>let blogPost: BlogPost = try! decoder.decode(BlogPost.self, from: jsonData)<br/>print(blogPost.date) // Prints: 2019-10-21 09:15:00 +0000</span></pre><p id="b852" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">还有一些其他策略可供设置:</p><ul class=""><li id="28d8" class="oe of it lb b lc ld lf lg li og lm oh lq oi lu oj ok ol om bi translated"><code class="fe nj nk nl na b">deferredToDate</code>:使用苹果自己的数据格式，跟踪自2001年1月1日以来的秒数和毫秒数。这主要是有用的直接使用苹果的平台。</li><li id="361a" class="oe of it lb b lc on lf oo li op lm oq lq or lu oj ok ol om bi translated">这种格式记录自1970年1月1日以来的秒数和毫秒数，使用起来更加普遍</li><li id="ec05" class="oe of it lb b lc on lf oo li op lm oq lq or lu oj ok ol om bi translated"><code class="fe nj nk nl na b">secondsSince1970</code>:跟踪自1970年1月1日以来的秒数</li><li id="1256" class="oe of it lb b lc on lf oo li op lm oq lq or lu oj ok ol om bi translated"><code class="fe nj nk nl na b">iso8601</code>:将日期解码为ISO-8601格式的字符串(RFC 3339格式)</li></ul><p id="504b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">根据您使用的API返回日期的方式，您可以在这些策略之间进行选择。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="3cd3" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">结论</h1><p id="015e" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">Swift使得解码JSON变得非常容易。没有必要为JSON解析使用定制库，因为默认API提供了我们需要的一切，从定制键映射到格式化日期。</p><p id="73fa" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">感谢阅读！</p></div></div>    
</body>
</html>