<html>
<head>
<title>How to Write an Express-like API Using Bun.js</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何使用Bun.js编写类似Express的API</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/write-a-express-like-api-using-bunjs-79e77a6a7a31?source=collection_archive---------0-----------------------#2022-08-10">https://betterprogramming.pub/write-a-express-like-api-using-bunjs-79e77a6a7a31?source=collection_archive---------0-----------------------#2022-08-10</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="5f7b" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">使用新的运行时</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi kf"><img src="../Images/22a05c0d199617be3171c9360979a2be.png" data-original-src="https://miro.medium.com/v2/resize:fit:512/format:webp/1*VoHwnK9wwjiRXi4KabN4Og.png"/></div></figure><p id="8927" class="pw-post-body-paragraph kn ko iq kp b kq kr jr ks kt ku ju kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">我偶然在Youtube上发现了一些有趣的技术视频，然后我发现了一个关于<a class="ae lj" href="https://github.com/oven-sh/bun" rel="noopener ugc nofollow" target="_blank"> Bun </a>的视频，这是一个用Zig编写的JavaScript运行时。它自称是一个非常快的运行时，比Nodejs快得多。</p><p id="ff5b" class="pw-post-body-paragraph kn ko iq kp b kq kr jr ks kt ku ju kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">所以我决定试一试。</p><p id="cc48" class="pw-post-body-paragraph kn ko iq kp b kq kr jr ks kt ku ju kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">下面是如何使用命令行下载<a class="ae lj" href="https://bun.sh/" rel="noopener ugc nofollow" target="_blank"> bun </a>:</p><pre class="kg kh ki kj gt lk ll lm ln aw lo bi"><span id="04f4" class="lp lq iq ll b gy lr ls l lt lu">curl -fsSL https://bun.sh/install | bash</span></pre><p id="3a36" class="pw-post-body-paragraph kn ko iq kp b kq kr jr ks kt ku ju kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">根据bun的文档，这就是如何从您的<code class="fe lv lw lx ll b">index.js</code>文件启动HTTP服务器:</p><pre class="kg kh ki kj gt lk ll lm ln aw lo bi"><span id="7b28" class="lp lq iq ll b gy lr ls l lt lu">export default {<br/>  fetch(req) {<br/>    return new Response("HI!");<br/>  },<br/>};</span></pre><p id="76a8" class="pw-post-body-paragraph kn ko iq kp b kq kr jr ks kt ku ju kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">在上面的代码中，如果JavaScript文件导出了一个默认对象，其中包含了<code class="fe lv lw lx ll b">fetch</code>函数，那么它将启动服务器。</p><p id="81cf" class="pw-post-body-paragraph kn ko iq kp b kq kr jr ks kt ku ju kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">或者你可以使用<code class="fe lv lw lx ll b">Bun.serve</code>:</p><pre class="kg kh ki kj gt lk ll lm ln aw lo bi"><span id="3137" class="lp lq iq ll b gy lr ls l lt lu">Bun.serve({<br/>  fetch(req) {<br/>    return new Response("HI!");<br/>  },<br/>});</span></pre><p id="29b5" class="pw-post-body-paragraph kn ko iq kp b kq kr jr ks kt ku ju kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">要运行JavaScript文件，只需执行<code class="fe lv lw lx ll b">bun run index.js</code>。</p><p id="bb54" class="pw-post-body-paragraph kn ko iq kp b kq kr jr ks kt ku ju kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">就是这样！一切正常…</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="lz ma di mb bf mc"><div class="gh gi ly"><img src="../Images/221540fff0238dc66d1fa81a03d8d736.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*Bk7RmmJ6RfxEWYOZ"/></div></div><p class="md me gj gh gi mf mg bd b be z dk translated">詹姆斯·哈里森在<a class="ae lj" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</p></figure><p id="d574" class="pw-post-body-paragraph kn ko iq kp b kq kr jr ks kt ku ju kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">然而，这个API可能有点复杂。当项目变得更大时，我们需要一个好的方法来完成它。所以，我决定从头开始用bun做一个类似express的API。通过这样做，任何熟悉ExpressJS的人都能够快速进入bun。</p></div><div class="ab cl mh mi hu mj" role="separator"><span class="mk bw bk ml mm mn"/><span class="mk bw bk ml mm mn"/><span class="mk bw bk ml mm"/></div><div class="ij ik il im in"><p id="17fd" class="pw-post-body-paragraph kn ko iq kp b kq kr jr ks kt ku ju kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">首先，我们需要处理请求。</p><p id="e398" class="pw-post-body-paragraph kn ko iq kp b kq kr jr ks kt ku ju kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">我们将创建一个包含HTTP方法的<code class="fe lv lw lx ll b">BunServer</code>类:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mo mp l"/></div></figure><p id="c7be" class="pw-post-body-paragraph kn ko iq kp b kq kr jr ks kt ku ju kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">在HTTP请求方法函数中，第一个参数<code class="fe lv lw lx ll b">path</code>是请求的路径，第二个参数是用于处理请求的回调数组。</p><p id="e26b" class="pw-post-body-paragraph kn ko iq kp b kq kr jr ks kt ku ju kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">一切经过HTTP的方法都会用<code class="fe lv lw lx ll b">delegate</code>函数来处理。</p><ul class=""><li id="325d" class="mq mr iq kp b kq kr kt ku kw ms la mt le mu li mv mw mx my bi translated"><code class="fe lv lw lx ll b">requestMap</code>存储路径的映射，它的处理程序是用户处理请求的业务逻辑。</li><li id="cf49" class="mq mr iq kp b kq mz kt na kw nb la nc le nd li mv mw mx my bi translated"><code class="fe lv lw lx ll b">middlewares</code>存储用户声明的所有中间件。</li></ul><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mo mp l"/></div></figure><p id="8ab5" class="pw-post-body-paragraph kn ko iq kp b kq kr jr ks kt ku ju kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">上面是<code class="fe lv lw lx ll b">delegate</code>函数，我们根据它们的请求方法和路径以及用户的handler函数来存储它们。所以每次用户调用路径时，我们都能够找到他们对应的处理程序。</p><p id="8530" class="pw-post-body-paragraph kn ko iq kp b kq kr jr ks kt ku ju kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">例如，我们称这个API为:</p><pre class="kg kh ki kj gt lk ll lm ln aw lo bi"><span id="e432" class="lp lq iq ll b gy lr ls l lt lu">curl -X POST 'http://localhost:3000/test</span></pre><p id="e065" class="pw-post-body-paragraph kn ko iq kp b kq kr jr ks kt ku ju kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">在我们的<code class="fe lv lw lx ll b">requestMap</code>中，键会变成<code class="fe lv lw lx ll b">POST:/test</code>，值是类似<code class="fe lv lw lx ll b">(req, res) =&gt; { console.log('Donate me pls'); }</code>的处理函数</p><p id="dbb5" class="pw-post-body-paragraph kn ko iq kp b kq kr jr ks kt ku ju kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">需要注意的是，<code class="fe lv lw lx ll b">handlers</code>中最后一个函数之前的函数是<code class="fe lv lw lx ll b">middlewares</code>，最后一个函数是实际的请求处理函数。</p><blockquote class="ne nf ng"><p id="8d9a" class="kn ko nh kp b kq kr jr ks kt ku ju kv ni kx ky kz nj lb lc ld nk lf lg lh li ij bi translated">这就是我们处理请求的方式，非常简单。</p></blockquote><p id="47e0" class="pw-post-body-paragraph kn ko iq kp b kq kr jr ks kt ku ju kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">接下来是<strong class="kp ir">中间件</strong>。</p><p id="c603" class="pw-post-body-paragraph kn ko iq kp b kq kr jr ks kt ku ju kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">在express上，我们有一个带有签名<code class="fe lv lw lx ll b">(req, res, next)</code>的中间件功能，这是一个<a class="ae lj" href="https://en.wikipedia.org/wiki/Chain-of-responsibility_pattern" rel="noopener ugc nofollow" target="_blank">责任链设计模式</a>。</p><p id="175a" class="pw-post-body-paragraph kn ko iq kp b kq kr jr ks kt ku ju kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">我的实现在这里也很简单。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mo mp l"/></div><p class="md me gj gh gi mf mg bd b be z dk translated">链家网</p></figure><p id="532e" class="pw-post-body-paragraph kn ko iq kp b kq kr jr ks kt ku ju kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">我创建了一个<code class="fe lv lw lx ll b">Chain</code>函数来处理中间件传递。我们的函数中有三个参数。</p><p id="70e9" class="pw-post-body-paragraph kn ko iq kp b kq kr jr ks kt ku ju kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated"><code class="fe lv lw lx ll b">request</code>是bun请求的对象，我们从<code class="fe lv lw lx ll b">fetch(req)</code>函数中得到它。</p><p id="3cbf" class="pw-post-body-paragraph kn ko iq kp b kq kr jr ks kt ku ju kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated"><code class="fe lv lw lx ll b">res</code>是<code class="fe lv lw lx ll b">BunResponse</code>对象。在bun上，我们有<code class="fe lv lw lx ll b">response</code>对象，为了向客户端返回响应，我们需要调用</p><pre class="kg kh ki kj gt lk ll lm ln aw lo bi"><span id="5655" class="lp lq iq ll b gy lr ls l lt lu">return new Response('hello world', { status: 200 });</span></pre><p id="1953" class="pw-post-body-paragraph kn ko iq kp b kq kr jr ks kt ku ju kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">但是在Express上，我们通过调用以下命令来返回响应:</p><pre class="kg kh ki kj gt lk ll lm ln aw lo bi"><span id="2c6d" class="lp lq iq ll b gy lr ls l lt lu">res.status(200).send('hello world');</span></pre><p id="69d1" class="pw-post-body-paragraph kn ko iq kp b kq kr jr ks kt ku ju kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">为了实现这种语法，我创建了一个名为<code class="fe lv lw lx ll b">BunResponse</code>的新类:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mo mp l"/></div><p class="md me gj gh gi mf mg bd b be z dk translated">bun-response.js</p></figure><p id="9167" class="pw-post-body-paragraph kn ko iq kp b kq kr jr ks kt ku ju kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">然后，我们通过调用响应对象的默认构造函数来创建响应对象:</p><pre class="kg kh ki kj gt lk ll lm ln aw lo bi"><span id="a5c9" class="lp lq iq ll b gy lr ls l lt lu">const res = new BunResponse();</span></pre><p id="bd68" class="pw-post-body-paragraph kn ko iq kp b kq kr jr ks kt ku ju kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">但是问题来了，当一个用户不小心调用了response两次:</p><pre class="kg kh ki kj gt lk ll lm ln aw lo bi"><span id="49bb" class="lp lq iq ll b gy lr ls l lt lu">res.status(200).send();<br/>res.status(500).send();</span></pre><p id="5617" class="pw-post-body-paragraph kn ko iq kp b kq kr jr ks kt ku ju kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">在我们的实现中，第一个响应将被忽略。这不是<code class="fe lv lw lx ll b">ExpressJs</code>处理这个的方式。在Express上，当我们调用两次请求响应时，它会抛出一个错误来禁止这种行为。</p><p id="fbc2" class="pw-post-body-paragraph kn ko iq kp b kq kr jr ks kt ku ju kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">所以在这里，我们将做同样的事情。</p><p id="a371" class="pw-post-body-paragraph kn ko iq kp b kq kr jr ks kt ku ju kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">我用<code class="fe lv lw lx ll b">BunResponse</code>对象创建了一个代理对象包装器</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mo mp l"/></div></figure><p id="c438" class="pw-post-body-paragraph kn ko iq kp b kq kr jr ks kt ku ju kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">在这个术语中，当用户调用终止关键字<code class="fe lv lw lx ll b">json</code>或<code class="fe lv lw lx ll b">send</code>时，它会检查之前的<code class="fe lv lw lx ll b">Bun Response</code>是否存在，如果存在，则意味着之前已经被调用过，我们抛出一个新的错误。</p><p id="15dd" class="pw-post-body-paragraph kn ko iq kp b kq kr jr ks kt ku ju kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">我们通过呼叫得到响应</p><pre class="kg kh ki kj gt lk ll lm ln aw lo bi"><span id="c19e" class="lp lq iq ll b gy lr ls l lt lu">const res = responseProxy();</span></pre><p id="1d09" class="pw-post-body-paragraph kn ko iq kp b kq kr jr ks kt ku ju kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated"><code class="fe lv lw lx ll b">Chain </code>中的第三个参数是<code class="fe lv lw lx ll b">middlewares</code>，它是中间件的处理函数。</p><p id="4b52" class="pw-post-body-paragraph kn ko iq kp b kq kr jr ks kt ku ju kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated"><code class="fe lv lw lx ll b">Chain</code>函数中的第一行是将所有处理函数遍历成一个普通的回调函数，返回值为<code class="fe lv lw lx ll b">res.isReady()</code>。</p><pre class="kg kh ki kj gt lk ll lm ln aw lo bi"><span id="fbf1" class="lp lq iq ll b gy lr ls l lt lu">this.middlewares = middlewares.map((mid) =&gt; {        <br/>   return () =&gt; {            <br/>     mid.middlewareFunc(req, res, this.next);            <br/>     return res.isReady();        <br/>   }    <br/>});</span></pre><p id="08f6" class="pw-post-body-paragraph kn ko iq kp b kq kr jr ks kt ku ju kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated"><code class="fe lv lw lx ll b">res.isReady()</code>是检查用户是否发送了<code class="fe lv lw lx ll b">stop signal</code>。例如，用户在中间件内部调用<code class="fe lv lw lx ll b">res.send('return')</code>。在这种情况下，我们不会继续将东西传递给下一个中间件，而是返回响应。</p><pre class="kg kh ki kj gt lk ll lm ln aw lo bi"><span id="c0a1" class="lp lq iq ll b gy lr ls l lt lu">this.next = () =&gt; {        <br/>  if (this.isFinish()) {            <br/>    return;        <br/>  }         <br/>  const cur = this.middlewares[this.index++];   </span><span id="a2de" class="lp lq iq ll b gy nl ls l lt lu">  this.isReady = cur();</span><span id="fc4f" class="lp lq iq ll b gy nl ls l lt lu">  if (this.isReady) {   <br/>    return;<br/>  }    <br/>}</span></pre><p id="bd33" class="pw-post-body-paragraph kn ko iq kp b kq kr jr ks kt ku ju kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated"><code class="fe lv lw lx ll b">next</code>功能类似于Express。在我们调用<code class="fe lv lw lx ll b">next</code>之后，我们将进入下一个中间件。</p><p id="4396" class="pw-post-body-paragraph kn ko iq kp b kq kr jr ks kt ku ju kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">这里有几件事你需要知道。</p><ol class=""><li id="10ef" class="mq mr iq kp b kq kr kt ku kw ms la mt le mu li nm mw mx my bi translated">每一个<code class="fe lv lw lx ll b">next</code>函数被调用，都会做<code class="fe lv lw lx ll b">index++</code>，我们用那个索引从中间件得到特定的回调函数。</li><li id="8fa7" class="mq mr iq kp b kq mz kt na kw nb la nc le nd li nm mw mx my bi translated">停止信号。为了阻止中间件通过，我们检查是否<code class="fe lv lw lx ll b">this.isFinish()</code>，这意味着索引是否等于中间件的大小。然后是<code class="fe lv lw lx ll b">this.isReady()</code>，如果用户呼叫<code class="fe lv lw lx ll b">res.send('')</code>。</li></ol><p id="a878" class="pw-post-body-paragraph kn ko iq kp b kq kr jr ks kt ku ju kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">现在，我们可以使用<code class="fe lv lw lx ll b">fetch</code>函数中的中间件</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mo mp l"/></div></figure><p id="44f9" class="pw-post-body-paragraph kn ko iq kp b kq kr jr ks kt ku ju kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">在上面的代码中，我们用默认路径<code class="fe lv lw lx ll b">/</code>检查所有的<code class="fe lv lw lx ll b">middlewares</code>。</p><p id="a059" class="pw-post-body-paragraph kn ko iq kp b kq kr jr ks kt ku ju kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">我们使用<code class="fe lv lw lx ll b">Chain</code>作为构造函数来创建一个<code class="fe lv lw lx ll b">chain</code>对象，并使用<code class="fe lv lw lx ll b">next</code>来迭代中间件。</p><p id="e24a" class="pw-post-body-paragraph kn ko iq kp b kq kr jr ks kt ku ju kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">递归之后，我们检查响应是否准备好了，如果准备好了，这意味着用户已经触发了<code class="fe lv lw lx ll b">stop signal</code>，我们立即返回响应。如果没有，我们检查用户是否已经完成通过中间件。</p><p id="f639" class="pw-post-body-paragraph kn ko iq kp b kq kr jr ks kt ku ju kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">之后，我们可以像在Express上一样使用中间件</p><pre class="kg kh ki kj gt lk ll lm ln aw lo bi"><span id="9e4a" class="lp lq iq ll b gy lr ls l lt lu">server.use((req, res, next) =&gt; {</span><span id="d277" class="lp lq iq ll b gy nl ls l lt lu">  console.log('hello');</span><span id="ad2c" class="lp lq iq ll b gy nl ls l lt lu">  next();<br/>});</span></pre><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mo mp l"/></div></figure><p id="e71e" class="pw-post-body-paragraph kn ko iq kp b kq kr jr ks kt ku ju kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">接下来，我们需要找到具有特定路径的中间件。例如，如果我们在路径<code class="fe lv lw lx ll b">/test</code>上添加一个中间件，我们需要在处理请求之前调用这个中间件。</p><p id="76e6" class="pw-post-body-paragraph kn ko iq kp b kq kr jr ks kt ku ju kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">我们从中间件数组的末尾开始检查<code class="fe lv lw lx ll b">req.path</code>是否满足。如果<code class="fe lv lw lx ll b">req.path</code>等于中间件中的<code class="fe lv lw lx ll b">path</code>存储，我们将推送到一个新的数组。迭代之后，我们做和上面一样的事情来调用中间件函数。</p><p id="ea91" class="pw-post-body-paragraph kn ko iq kp b kq kr jr ks kt ku ju kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">最后一件事是处理用户逻辑，我们将它们存储在<code class="fe lv lw lx ll b">requestMap</code>中。</p><pre class="kg kh ki kj gt lk ll lm ln aw lo bi"><span id="8af7" class="lp lq iq ll b gy lr ls l lt lu">if (handler) {                    <br/>   handler.apply(null, [req, res]);                <br/>}</span></pre><p id="e795" class="pw-post-body-paragraph kn ko iq kp b kq kr jr ks kt ku ju kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">就这么简单。</p><p id="8861" class="pw-post-body-paragraph kn ko iq kp b kq kr jr ks kt ku ju kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">最后，我们总结一下。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mo mp l"/></div></figure></div><div class="ab cl mh mi hu mj" role="separator"><span class="mk bw bk ml mm mn"/><span class="mk bw bk ml mm mn"/><span class="mk bw bk ml mm"/></div><div class="ij ik il im in"><p id="ad0d" class="pw-post-body-paragraph kn ko iq kp b kq kr jr ks kt ku ju kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">让我们看看如何使用API。这个包叫做<code class="fe lv lw lx ll b"><a class="ae lj" href="https://www.npmjs.com/package/bunrest" rel="noopener ugc nofollow" target="_blank">bunrest</a></code>，我已经在npm上发表了:</p><pre class="kg kh ki kj gt lk ll lm ln aw lo bi"><span id="fb42" class="lp lq iq ll b gy lr ls l lt lu">npm i bunrest</span></pre><p id="bc91" class="pw-post-body-paragraph kn ko iq kp b kq kr jr ks kt ku ju kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">首先，创建一个服务器对象:</p><pre class="kg kh ki kj gt lk ll lm ln aw lo bi"><span id="30b5" class="lp lq iq ll b gy lr ls l lt lu">import App from 'bunrest'</span><span id="4df1" class="lp lq iq ll b gy nl ls l lt lu">const server = App();</span></pre><p id="4a7f" class="pw-post-body-paragraph kn ko iq kp b kq kr jr ks kt ku ju kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">然后你可以像在快递上一样使用它:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mo mp l"/></div></figure><p id="7639" class="pw-post-body-paragraph kn ko iq kp b kq kr jr ks kt ku ju kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">让我们添加中间件:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mo mp l"/></div></figure><p id="ed12" class="pw-post-body-paragraph kn ko iq kp b kq kr jr ks kt ku ju kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">让我们添加一个路由器:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mo mp l"/></div></figure><p id="7321" class="pw-post-body-paragraph kn ko iq kp b kq kr jr ks kt ku ju kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">最后，要启动服务器:</p><pre class="kg kh ki kj gt lk ll lm ln aw lo bi"><span id="1fb9" class="lp lq iq ll b gy lr ls l lt lu">server.listen(3000, () =&gt; {<br/>  console.log('App is listening on port 3000');<br/>});</span></pre><p id="e4b6" class="pw-post-body-paragraph kn ko iq kp b kq kr jr ks kt ku ju kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">你可以在我的<a class="ae lj" href="https://github.com/lau1944/bunrest" rel="noopener ugc nofollow" target="_blank"> GitHub库</a>中查看源代码。</p><p id="fa77" class="pw-post-body-paragraph kn ko iq kp b kq kr jr ks kt ku ju kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">感谢阅读。</p></div></div>    
</body>
</html>