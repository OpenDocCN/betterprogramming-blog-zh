<html>
<head>
<title>Understanding the Closure Trap of React Hooks</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">理解React钩子的闭包陷阱</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/understanding-the-closure-trap-of-react-hooks-6c560c408cde?source=collection_archive---------0-----------------------#2022-06-25">https://betterprogramming.pub/understanding-the-closure-trap-of-react-hooks-6c560c408cde?source=collection_archive---------0-----------------------#2022-06-25</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="9382" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">挖掘经典问题</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/f2cd978144178b00d266631fc95911d9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*QIRyn9NniP8LJQNpt8tuMA.png"/></div></div></figure><p id="3910" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">现在当我们开发React项目时，我们一般使用钩子。</p><p id="d313" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">但是在开发过程中，我们经常会遇到一些问题。最经典的问题是React钩子的闭包陷阱。</p><p id="ddf5" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">有些朋友可能遇到过类似的问题，但可能并没有从React的底层原理去理解这个问题。在这里我们一起来讨论这个话题。</p></div><div class="ab cl lq lr hx ls" role="separator"><span class="lt bw bk lu lv lw"/><span class="lt bw bk lu lv lw"/><span class="lt bw bk lu lv"/></div><div class="im in io ip iq"><h1 id="fdeb" class="lx ly it bd lz ma mb mc md me mf mg mh jz mi ka mj kc mk kd ml kf mm kg mn mo bi translated">问题是</h1><p id="e694" class="pw-post-body-paragraph ku kv it kw b kx mp ju kz la mq jx lc ld mr lf lg lh ms lj lk ll mt ln lo lp im bi translated">这是一个简单的React应用程序:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mu mv l"/></div></figure><p id="20d1" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">我们使用<code class="fe mw mx my mz b">useState</code>创建一个<code class="fe mw mx my mz b">count</code>状态，并在第一个<code class="fe mw mx my mz b">useEffect</code>中不断增加<code class="fe mw mx my mz b">count</code>的值，然后同时在另一个<code class="fe mw mx my mz b">useEffect</code>中打印出<code class="fe mw mx my mz b">count</code>的最新值。</p><p id="7b2e" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">你认为控制台输出会是怎样的？</p><p id="f597" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">结果如下:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi na"><img src="../Images/d77cc3e8fbb82a985546f8ce2e42d97f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Pc5Ur3y_MCR0Q9nIDWjbnQ.png"/></div></div></figure><p id="9688" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">这是一个嵌入式演示:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nb mv l"/></div></figure><p id="83b4" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">控制台一直输入<code class="fe mw mx my mz b">0, 0, 0 …</code>而不是我们期望的<code class="fe mw mx my mz b">0, 1, 2, 3, …</code>。</p><p id="885e" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">这是封闭陷阱。</p></div><div class="ab cl lq lr hx ls" role="separator"><span class="lt bw bk lu lv lw"/><span class="lt bw bk lu lv lw"/><span class="lt bw bk lu lv"/></div><div class="im in io ip iq"><h1 id="f38c" class="lx ly it bd lz ma mb mc md me mf mg mh jz mi ka mj kc mk kd ml kf mm kg mn mo bi translated">分析</h1><h2 id="fc0c" class="nc ly it bd lz nd ne dn md nf ng dp mh ld nh ni mj lh nj nk ml ll nl nm mn nn bi translated">React运行时中的组件是什么？</h2><ul class=""><li id="aeef" class="no np it kw b kx mp la mq ld nq lh nr ll ns lp nt nu nv nw bi translated"><strong class="kw iu">一个组件实际上是一个纤维节点。</strong></li><li id="413b" class="no np it kw b kx nx la ny ld nz lh oa ll ob lp nt nu nv nw bi translated">而且每个纤程节点都有一个属性叫做<code class="fe mw mx my mz b">memorizedState</code>，它是一个链表。</li><li id="b9c9" class="no np it kw b kx nx la ny ld nz lh oa ll ob lp nt nu nv nw bi translated">组件的每个钩子对应于<code class="fe mw mx my mz b">memorizedState</code>链表的一个节点，它们从相应的节点访问自己的值。</li></ul><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi oc"><img src="../Images/8448914850ca7d530974413b88fa29f9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*T1TiRZM4ilPXV4B2m2GWwA.png"/></div></div></figure><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi od"><img src="../Images/6174d7d7388a4ed306e5a69023fa6c02.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*L6FuRtdcazVlRX7sE3Em8w.png"/></div></div></figure><p id="915a" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">例如，上面的例子中有三个钩子，每个钩子对应于<code class="fe mw mx my mz b">memorizedState</code>链表中的一个节点:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi oe"><img src="../Images/c16c28ba6c1cd7c22bce5cf49b6ba51a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*S05-fhn1iHKe8W2ssFL77g.png"/></div></div></figure><p id="879a" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">然后每个钩子访问它自己的<code class="fe mw mx my mz b">memorizedState</code>来完成它自己的逻辑。</p><h2 id="f75b" class="nc ly it bd lz nd ne dn md nf ng dp mh ld nh ni mj lh nj nk ml ll nl nm mn nn bi translated">钩子的实现</h2><p id="b3d5" class="pw-post-body-paragraph ku kv it kw b kx mp ju kz la mq jx lc ld mr lf lg lh ms lj lk ll mt ln lo lp im bi translated">钩子有两个阶段:挂载和更新。</p><p id="a68f" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">挂载函数在第一次创建钩子时执行，而更新函数在此后每次钩子更新时执行。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi of"><img src="../Images/40efb994c83359287da2b55cd5720ba9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*DlKaqqlV3FhD2OT4Cxs2Xg.png"/></div></div></figure><p id="ee19" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">下面是<code class="fe mw mx my mz b">useEffect</code>的实现:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi og"><img src="../Images/165525bf93716caf6ae5ea3bda63e220.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*PZj9f6-8pQV7-0_2XDUHBg.png"/></div></div></figure><h2 id="6828" class="nc ly it bd lz nd ne dn md nf ng dp mh ld nh ni mj lh nj nk ml ll nl nm mn nn bi translated"><strong class="ak">钩子如何处理dep？</strong></h2><p id="4548" class="pw-post-body-paragraph ku kv it kw b kx mp ju kz la mq jx lc ld mr lf lg lh ms lj lk ll mt ln lo lp im bi translated">这里我们要注意对<code class="fe mw mx my mz b">deps</code>参数的处理:如果<code class="fe mw mx my mz b">deps</code>未定义，那么<code class="fe mw mx my mz b">deps</code>被视为空。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi oh"><img src="../Images/c70d7eaa549d0575039af78bf0e35547.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*r_t2ee9zRBUgsTjZmaxMvQ.png"/></div></div></figure><p id="8734" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">然后它将新传递的<code class="fe mw mx my mz b">deps</code>与之前存在于<code class="fe mw mx my mz b">memorizedState</code>中的<code class="fe mw mx my mz b">deps</code>进行比较:如果两者相等，则直接使用之前给定的函数，否则创建一个新的函数。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi oi"><img src="../Images/7287e20b54b7c0ceb5f5cafb3d8e033d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*iwWN4brVdHQuBQpoDJrVxw.png"/></div></div></figure><p id="158f" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">比较两个<code class="fe mw mx my mz b">deps</code>是否相等的逻辑很简单:如果前面的<code class="fe mw mx my mz b">deps</code>是<code class="fe mw mx my mz b">null</code>，那么直接返回<code class="fe mw mx my mz b">false</code>，即不相等；否则，将依次遍历和比较数组。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi oj"><img src="../Images/f4e6256c94fe3e7d82ce074d4590b32a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*pPFTVayluBpp6UQADIqPzw.png"/></div></div></figure><p id="3d7c" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">所以我们可以得到三个结论:</p><ul class=""><li id="52c5" class="no np it kw b kx ky la lb ld ok lh ol ll om lp nt nu nv nw bi translated">如果<code class="fe mw mx my mz b">useEffect</code>的<code class="fe mw mx my mz b">deps</code>参数未定义或为空，回调函数将在每次重新渲染时重新创建并执行。</li><li id="d187" class="no np it kw b kx nx la ny ld nz lh oa ll ob lp nt nu nv nw bi translated">如果是空数组，效果只会执行一次。</li><li id="5811" class="no np it kw b kx nx la ny ld nz lh oa ll ob lp nt nu nv nw bi translated">否则，它会比较<code class="fe mw mx my mz b">deps</code>数组中的每个元素是否都发生了变化来决定是否执行该效果。</li></ul><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi on"><img src="../Images/b13f707decdbe47854959e9693e7fad8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*sUwY0Je3-b_wDNwyTGhPbg.png"/></div></div></figure><p id="7c4a" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">在阅读本文之前，你可能已经知道了这些结论，但这里我们是从源代码的角度来理解的。</p><p id="8292" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">像<code class="fe mw mx my mz b">useMemo</code>和<code class="fe mw mx my mz b">useCallback</code>这样的挂钩也以同样的方式操作<code class="fe mw mx my mz b">deps</code>:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi oo"><img src="../Images/698a1fe450b2b465b3a9d43e68fff8dc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*4DgunW6LDX9mIAw9dJ8C3A.png"/></div></div></figure><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi op"><img src="../Images/d4e1dabec61eaa6385f328920ebff387.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Z0Nb2aiP28LT3YyvYh-QuA.png"/></div></div></figure></div><div class="ab cl lq lr hx ls" role="separator"><span class="lt bw bk lu lv lw"/><span class="lt bw bk lu lv lw"/><span class="lt bw bk lu lv"/></div><div class="im in io ip iq"><p id="0d08" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">从前面的讨论中，我们知道两件事:</p><ul class=""><li id="0aa4" class="no np it kw b kx ky la lb ld ok lh ol ll om lp nt nu nv nw bi translated">像<code class="fe mw mx my mz b">useEffect</code>这样的钩子访问<code class="fe mw mx my mz b">memriorizedState</code>中的数据。</li><li id="b70e" class="no np it kw b kx nx la ny ld nz lh oa ll ob lp nt nu nv nw bi translated">钩子通过比较<code class="fe mw mx my mz b">deps</code>是否相等来决定是否执行回调函数。</li></ul><h2 id="c1fc" class="nc ly it bd lz nd ne dn md nf ng dp mh ld nh ni mj lh nj nk ml ll nl nm mn nn bi translated">封闭陷阱</h2><p id="0efd" class="pw-post-body-paragraph ku kv it kw b kx mp ju kz la mq jx lc ld mr lf lg lh ms lj lk ll mt ln lo lp im bi translated">现在回到我们的结束问题。我们这样写代码:</p><pre class="kj kk kl km gt oq mz or os aw ot bi"><span id="8acf" class="nc ly it mz b gy ou ov l ow ox">useEffect(() =&gt; {<br/>    const timer = setInterval(() =&gt; {<br/>        setCount(count + 1);<br/>    }, 500);<br/>}, []);</span><span id="ea97" class="nc ly it mz b gy oy ov l ow ox">useEffect(() =&gt; {<br/>    const timer = setInterval(() =&gt; {<br/>        console.log(count);<br/>    }, 500);<br/>}, []);</span></pre><p id="a853" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated"><code class="fe mw mx my mz b">deps</code>是空数组，所以这个效果只会执行一次。</p><p id="7801" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">相应的源代码实现如下:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi oz"><img src="../Images/766e32e53ad7ee2d37cda80499c7b5b5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*MbGcb96hJmFPpHgOB5dO6w.png"/></div></div></figure><p id="4b12" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">需要执行的效果会用<code class="fe mw mx my mz b">HasEffect</code>标记，稍后再执行:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi oo"><img src="../Images/2715c72b1197e58e6a5fc9e0dbccd107.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*cLJig3k-pHM7fV2TTJdDrQ.png"/></div></div></figure><p id="3922" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">由于这里的<code class="fe mw mx my mz b">deps</code>是空数组，所以没有<code class="fe mw mx my mz b">HasEffect</code>标志。该效果将不再执行。</p><p id="10b7" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated"><strong class="kw iu">所以我们的定时器</strong> <code class="fe mw mx my mz b"><strong class="kw iu">setInterval</strong></code> <strong class="kw iu">只会设置一次。</strong>因此，其回调函数引用的状态始终是初始状态，无法获得最新状态。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi pa"><img src="../Images/7f81383ae2da2161db92cf1de0c33117.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*llkKIRkQsB3c-55UiiaBGw.png"/></div></div></figure><p id="d819" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">如果我们想获得最新的状态，那么我们需要让<code class="fe mw mx my mz b">fn</code>在每次刷新时执行一次。也就是说，我们要把<code class="fe mw mx my mz b">count</code>放在依赖数组里。</p><pre class="kj kk kl km gt oq mz or os aw ot bi"><span id="4f8e" class="nc ly it mz b gy ou ov l ow ox">useEffect(() =&gt; {<br/>        setInterval(() =&gt; {<br/>            setCount(count + 1);<br/>        }, 1500);<br/>    }, [count]);</span><span id="6a04" class="nc ly it mz b gy oy ov l ow ox">useEffect(() =&gt; {<br/>        setInterval(() =&gt; {<br/>            console.log(count);<br/>        }, 1500);<br/>    }, [count]);</span></pre><p id="c832" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">结果如下:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi pb"><img src="../Images/113c86bfef0800bc8d5759284fa051a2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*UHuMM8zfwlurofxQ3Av9fA.png"/></div></div></figure><p id="3fcb" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">看起来<code class="fe mw mx my mz b">fn</code>得到的是最新状态，但是为什么控制台结果这么乱？</p><p id="23a4" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">这是因为每个效果都会产生一个时间间隔。所以我们需要在效果中清除之前的时间间隔。</p><p id="e61a" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">代码:</p><pre class="kj kk kl km gt oq mz or os aw ot bi"><span id="2dd6" class="nc ly it mz b gy ou ov l ow ox">useEffect(() =&gt; {<br/>    let timer = setInterval(() =&gt; {<br/>      setCount(count + 1);<br/>    }, 1500);<br/>    return () =&gt; clearInterval(timer);<br/>  }, [count]);</span><span id="db79" class="nc ly it mz b gy oy ov l ow ox">useEffect(() =&gt; {<br/>    let timer = setInterval(() =&gt; {<br/>      console.log(count);<br/>    }, 1500);<br/>    return () =&gt; clearInterval(timer);<br/>  }, [count]);</span></pre><p id="e45a" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">在线演示:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nb mv l"/></div></figure><p id="af38" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">就这样，我们终于解决了这个封闭陷阱。</p></div><div class="ab cl lq lr hx ls" role="separator"><span class="lt bw bk lu lv lw"/><span class="lt bw bk lu lv lw"/><span class="lt bw bk lu lv"/></div><div class="im in io ip iq"><h1 id="175b" class="lx ly it bd lz ma mb mc md me mf mg mh jz mi ka mj kc mk kd ml kf mm kg mn mo bi translated">结论</h1><p id="0843" class="pw-post-body-paragraph ku kv it kw b kx mp ju kz la mq jx lc ld mr lf lg lh ms lj lk ll mt ln lo lp im bi translated">名为<code class="fe mw mx my mz b">memorizedState</code>的链表存储在纤程节点中。链表的节点与钩子一一对应，每个钩子访问其对应节点上的数据。</p><p id="1780" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">像<code class="fe mw mx my mz b">useEffect</code>、<code class="fe mw mx my mz b">useMomo</code>、<code class="fe mw mx my mz b">useCallback</code>这样的钩子都有一个<code class="fe mw mx my mz b">deps</code>参数。每次重新渲染时都会比较新旧<code class="fe mw mx my mz b">deps</code>，如果<code class="fe mw mx my mz b">deps</code>发生变化，将重新执行回调函数。</p><p id="9977" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">所以每个渲染器都会执行参数为<code class="fe mw mx my mz b">undefined</code>和<code class="fe mw mx my mz b">null</code>的钩子，参数为<code class="fe mw mx my mz b">[]</code>的钩子只会执行一次，参数为<code class="fe mw mx my mz b">[state]</code>的钩子只有在状态改变时才会再次执行。</p><p id="fd69" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">闭包陷阱的原因是在<code class="fe mw mx my mz b">useEffect</code>等钩子中使用了某个状态，但没有添加到<code class="fe mw mx my mz b">deps</code>数组中，这样即使状态发生变化，回调函数也不会重新执行，仍然引用旧的状态。</p><p id="36dd" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">闭包陷阱也很容易修复，我们只需要正确设置<code class="fe mw mx my mz b">deps</code>数组。这样，每次状态改变时，回调函数都会被重新执行，引用新的状态。但是，我们也需要注意清理之前的计时器、事件侦听器等。</p></div><div class="ab cl lq lr hx ls" role="separator"><span class="lt bw bk lu lv lw"/><span class="lt bw bk lu lv lw"/><span class="lt bw bk lu lv"/></div><div class="im in io ip iq"><ul class=""><li id="e2ba" class="no np it kw b kx ky la lb ld ok lh ol ll om lp nt nu nv nw bi translated"><a class="ae pc" rel="noopener ugc nofollow" target="_blank" href="/10-javascript-closure-challenges-explained-with-diagrams-c964110805e7">用图表解释10个JavaScript闭包挑战</a></li><li id="f758" class="no np it kw b kx nx la ny ld nz lh oa ll ob lp nt nu nv nw bi translated"><a class="ae pc" rel="noopener ugc nofollow" target="_blank" href="/a-react-hooks-challenge-for-senior-react-developers-f1190e1939ec">面向高级React开发人员的React挂钩挑战</a></li></ul><div class="pd pe gp gr pf"><div role="button" tabindex="0" class="ab bv gv cb fp pg ph bn pi ks ex"><div class="pj l"><div class="ab q"><div class="l di"><img alt="bytefish" class="l de bw pk pl fe" src="../Images/743f175620c9b16012604fb316b07c94.png" width="20" height="20" loading="lazy" data-original-src="https://miro.medium.com/v2/resize:fill:40:40/1*XYGoKrb1w5zdWZLOIEevZg.png"/><div class="fb bw l pk pl fc n aw fd"/></div><div class="hh l fo"><p class="bd b dl z fp fq fr fs ft fu fv fw dk translated"><a class="ae af ag ah ai aj ak al am an ao ap aq ar as" href="https://bytefish.medium.com/?source=post_page-----6c560c408cde--------------------------------" rel="noopener follow" target="_top">字节鱼</a></p></div></div><div class="po pp gw l"><h2 class="bd iu uu no fp uv fr fs uw fu fw is bi translated">反应文章</h2></div><div class="ab q"><div class="l fo"><a class="bd b be z bi ux au uy uz va ri vb an eh ei vc vd ve el em eo de bk ep" href="https://bytefish.medium.com/list/react-articles-f03ed95b6f26?source=post_page-----6c560c408cde--------------------------------" rel="noopener follow" target="_top">View list</a></div><div class="vf l fo"><span class="bd b dl z dk">11 stories</span></div></div></div><div class="qb dh qc fp ab qd fo di"><div class="di pt bv pu pv"><div class="dh l"><img alt="" class="dh" src="../Images/e555ae2e737e52a96b752353afc59b7e.png" width="194" height="194" loading="lazy" role="presentation" data-original-src="https://miro.medium.com/v2/resize:fill:388:388/1*jIPrIhabXe8a8oMahKB-dg.png"/></div></div><div class="di pt bv pw px py"><div class="dh l"><img alt="" class="dh" src="../Images/115df7a3b8878c59dc62f7a1734823f6.png" width="194" height="194" loading="lazy" role="presentation" data-original-src="https://miro.medium.com/v2/resize:fill:388:388/1*hvdWN3AJPPDNlOOMnLNKtQ.png"/></div></div><div class="di bv pz qa py"><div class="dh l"><img alt="" class="dh" src="../Images/9e6c69b1759e4d02beabe7671d8aae7f.png" width="194" height="194" loading="lazy" role="presentation" data-original-src="https://miro.medium.com/v2/resize:fill:388:388/1*QIRyn9NniP8LJQNpt8tuMA.png"/></div></div></div></div></div></div></div>    
</body>
</html>