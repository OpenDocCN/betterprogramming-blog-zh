<html>
<head>
<title>Write-Ahead Logging (WAL) Disabled to Force Commits in Core Data</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">禁用预写日志记录(WAL)以强制提交核心数据</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/write-ahead-logging-wal-disabled-to-force-commits-in-core-data-d1a6bb359c0a?source=collection_archive---------10-----------------------#2020-08-25">https://betterprogramming.pub/write-ahead-logging-wal-disabled-to-force-commits-in-core-data-d1a6bb359c0a?source=collection_archive---------10-----------------------#2020-08-25</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="62d1" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">解释核心数据的底层结构</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/c1f9eab05500911e24cb0e292c374b3b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*BuFb-BDsRmdvSt7MTgE9xg.jpeg"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">Pawel Czerwinski 在<a class="ae ky" href="http://unsplash.com" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</p></figure><p id="eb67" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">自iOS 7和OS X Mavericks以来，预写日志记录一直是核心数据SQLite存储的默认日志记录模式。核心数据中的日志记录最好解释为将数据事务保存到底层SQLite存储中的方式。与以前的默认“回滚”日志模式相比，WAL模式在大多数情况下都要快得多，这也是核心数据能够并发的根本原因。</p><p id="93d3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在WAL模式下，Core Data保持主SQLite存储文件不变，并在SQLite存储的同一位置的<code class="fe lv lw lx ly b">-wal</code>文件中跟踪数据事务。这意味着在某些情况下，SQLite存储本身中的更改还不可见。因此，您可能希望将这些更改强制提交到SQLite存储中。在这篇博文中，我将给出一个例子，并解释如何做到这一点。</p></div><div class="ab cl lz ma hx mb" role="separator"><span class="mc bw bk md me mf"/><span class="mc bw bk md me mf"/><span class="mc bw bk md me"/></div><div class="im in io ip iq"><h1 id="fad4" class="mg mh it bd mi mj mk ml mm mn mo mp mq jz mr ka ms kc mt kd mu kf mv kg mw mx bi translated">预写日志记录是如何工作的？</h1><p id="e6fc" class="pw-post-body-paragraph kz la it lb b lc my ju le lf mz jx lh li na lk ll lm nb lo lp lq nc ls lt lu im bi translated">当你打开应用程序的目录找到你的核心数据文件<code class="fe lv lw lx ly b">.sqlite</code>时，你可能一直想知道这些<code class="fe lv lw lx ly b">.sqlite-wal</code>和<code class="fe lv lw lx ly b">.sqlite-shm</code>文件意味着什么。自iOS 7和OS X Mavericks以来，这两个文件就存在于您的<code class="fe lv lw lx ly b">.sqlite</code>文件旁边，它们是当前默认的核心数据预写日志记录模式的一部分。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi nd"><img src="../Images/6825fc279e1039f8fd51e88f1fc3f4d2.png" data-original-src="https://miro.medium.com/v2/resize:fit:788/format:webp/0*IEIl1BVrbAqWf2M9.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">预写日志记录(WAL)会产生多个数据库文件。</p></figure><p id="5088" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">核心数据和SQLite中的日志模式通过在中间日志文件中写入新事务来防止数据丢失。在引入WAL之前，SQLite使用传统的回滚日志，它通过在日志文件中保存原始未更改数据库内容的副本来工作。新的更改直接写入数据库文件，日志文件用于在崩溃时回滚更改。删除回滚日志时，会进行保存更改的最终提交。</p><p id="b68b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">沃尔的工作方式正好相反。原始内容保留在数据库文件中，新的更改添加到WAL文件中。提交最终数据更改实际上可以发生在这个WAL文件中，这意味着可以保存数据，而原始数据库保持不变。所谓的“检查点”最终会将所有事务从WAL文件转移到数据库中。</p><p id="8b33" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe lv lw lx ly b">.sqlite-shm</code>文件是作为多个SQLite数据库连接之间的共享内存而存在的，它被用作WAL文件的索引。</p><p id="9684" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果你想了解更多，可以阅读关于WAL模式的<a class="ae ky" href="http://www.sqlite.org/draft/wal.html" rel="noopener ugc nofollow" target="_blank">深度解释</a>。</p></div><div class="ab cl lz ma hx mb" role="separator"><span class="mc bw bk md me mf"/><span class="mc bw bk md me mf"/><span class="mc bw bk md me"/></div><div class="im in io ip iq"><h1 id="8e27" class="mg mh it bd mi mj mk ml mm mn mo mp mq jz mr ka ms kc mt kd mu kf mv kg mw mx bi translated">打开SQLite数据库文件时，核心数据更改不可见</h1><p id="dced" class="pw-post-body-paragraph kz la it lb b lc my ju le lf mz jx lh li na lk ll lm nb lo lp lq nc ls lt lu im bi translated">在某些情况下，您可能会发现自己打开一个SQLite数据库文件，并意识到某些更改丢失了。这可能是因为您移动了一个SQLite文件，而没有匹配的<code class="fe lv lw lx ly b">-wal</code>和<code class="fe lv lw lx ly b">-shm</code>文件。大多数数据库阅读器应用程序支持WAL模式，并自动显示尚未提交到SQLite商店的更改。</p><h2 id="473c" class="ne mh it bd mi nf ng dn mm nh ni dp mq li nj nk ms lm nl nm mu lq nn no mw np bi translated">将更改强制提交到SQLite存储区的原因</h2><p id="1bf1" class="pw-post-body-paragraph kz la it lb b lc my ju le lf mz jx lh li na lk ll lm nb lo lp lq nc ls lt lu im bi translated">我敢打赌，您一定想知道为什么要将更改强制提交到SQLite存储中。也可能是因为你已经有了一个理由，所以你才写了这篇文章，在这种情况下，我希望<a class="ae ky" href="https://twitter.com/twannl" rel="noopener ugc nofollow" target="_blank">听到更多的</a>。</p><p id="8750" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">WeTransfer 收集的<a class="ae ky" href="https://collect.bywetransfer.com/" rel="noopener ugc nofollow" target="_blank">包含大量数据，使用核心数据作为其存储。随着时间的推移，我们不得不编写多个核心数据迁移，这在极少数情况下会失败，并出现如下错误:</a></p><blockquote class="nq nr ns"><p id="e0f5" class="kz la nt lb b lc ld ju le lf lg jx lh nu lj lk ll nv ln lo lp nw lr ls lt lu im bi translated">“添加日期”是必需的值。\ " UserInfo = { NSValidationErrorObject =<nsmanagedobject:>(entity:image content；id:</nsmanagedobject:></p></blockquote><p id="63fb" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在大多数情况下，您可以通过编写一个正确的迁移策略来解决这个问题，该策略在迁移过程中设置正确的值。然而，我们发现，在某些情况下，我们喜欢在迁移之前对本地存储进行预处理，以删除那些已知的无效案例，这些案例是过去的错误导致的。</p><p id="9f1f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">编写预处理器就像使用源数据库创建一个持久容器来执行所需的事务一样简单。然而，根据我们的经验，我们发现这些更改对于核心数据迁移并不总是可见的，需要我们执行强制提交，以确保这些更改应用到SQLite数据库文件。</p></div><div class="ab cl lz ma hx mb" role="separator"><span class="mc bw bk md me mf"/><span class="mc bw bk md me mf"/><span class="mc bw bk md me"/></div><div class="im in io ip iq"><h1 id="c562" class="mg mh it bd mi mj mk ml mm mn mo mp mq jz mr ka ms kc mt kd mu kf mv kg mw mx bi translated">如何将更改强制提交到SQLite数据库中</h1><p id="1a74" class="pw-post-body-paragraph kz la it lb b lc my ju le lf mz jx lh li na lk ll lm nb lo lp lq nc ls lt lu im bi translated">强制提交，也称为检查点，意味着将存在于<code class="fe lv lw lx ly b">-wal</code>文件中的事务合并到存储文件中。通过使用传统的回滚日志模式，我们可以强制核心数据对预写日志数据库执行检查点操作。</p><p id="65e4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">为此，我们可以通过将日志模式设置为<code class="fe lv lw lx ly b">DELETE</code>来添加持久性存储:</p><pre class="kj kk kl km gt nx ly ny nz aw oa bi"><span id="1164" class="ne mh it ly b gy ob oc l od oe">private func forceWALCheckpointingForStore(at storeURL: URL, model: NSManagedObjectModel) throws {<br/>    do {<br/>        let persistentStoreCoordinator = NSPersistentStoreCoordinator(managedObjectModel: model)<br/><br/>        let options = [NSSQLitePragmasOption: ["journal_mode": "DELETE"]]<br/>        let store = try persistentStoreCoordinator.addPersistentStore(ofType: NSSQLiteStoreType, configurationName: nil, at: storeURL, options: options)<br/>        try persistentStoreCoordinator.remove(store)<br/>    } catch let error {<br/>        throw Error.forcedWALCheckFailed(error: error)<br/>    }<br/>}</span></pre><p id="5318" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">该方法将源存储URL和数据库模型作为输入，足以强制将更改提交到本地数据库文件中。</p></div><div class="ab cl lz ma hx mb" role="separator"><span class="mc bw bk md me mf"/><span class="mc bw bk md me mf"/><span class="mc bw bk md me"/></div><div class="im in io ip iq"><h1 id="720c" class="mg mh it bd mi mj mk ml mm mn mo mp mq jz mr ka ms kc mt kd mu kf mv kg mw mx bi translated"><strong class="ak">在NSPersistentContainer中完全禁用WAL模式</strong></h1><p id="5e2e" class="pw-post-body-paragraph kz la it lb b lc my ju le lf mz jx lh li na lk ll lm nb lo lp lq nc ls lt lu im bi translated">如果您喜欢将更改直接写入SQLite文件，您可以通过设置具有回滚日志记录模式的持久性容器，决定将更改直接提交到本地SQLite文件:</p><pre class="kj kk kl km gt nx ly ny nz aw oa bi"><span id="5c7e" class="ne mh it ly b gy ob oc l od oe">let persistentContainer = NSPersistentContainer(name: "Database_Name", managedObjectModel: model)<br/>let storeDescription = NSPersistentStoreDescription(url: storeURL)<br/>storeDescription.setValue("DELETE" as NSObject, forPragmaNamed: "journal_mode")<br/>persistentContainer.persistentStoreDescriptions = [storeDescription]</span></pre></div><div class="ab cl lz ma hx mb" role="separator"><span class="mc bw bk md me mf"/><span class="mc bw bk md me mf"/><span class="mc bw bk md me"/></div><div class="im in io ip iq"><h1 id="c7ca" class="mg mh it bd mi mj mk ml mm mn mo mp mq jz mr ka ms kc mt kd mu kf mv kg mw mx bi translated">使用SQLite调试验证配置的日志模式</h1><p id="4c9b" class="pw-post-body-paragraph kz la it lb b lc my ju le lf mz jx lh li na lk ll lm nb lo lp lq nc ls lt lu im bi translated">虽然这一部分在我的详细的<a class="ae ky" href="https://www.avanderlee.com/debugging/core-data-debugging-xcode/" rel="noopener ugc nofollow" target="_blank">核心数据调试帖子</a>中有最好的解释，但我想强调一个启动论点。通过使用<code class="fe lv lw lx ly b">-com.apple.CoreData.SQLDebug 4</code>作为启动时传递的参数，您将获得核心数据中发生的事务的详细信息。</p><p id="b245" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在这些日志中，您会发现有关日志模式的以下信息:</p><pre class="kj kk kl km gt nx ly ny nz aw oa bi"><span id="a212" class="ne mh it ly b gy ob oc l od oe">CoreData: sql: pragma journal_mode=DELETE</span></pre></div><div class="ab cl lz ma hx mb" role="separator"><span class="mc bw bk md me mf"/><span class="mc bw bk md me mf"/><span class="mc bw bk md me"/></div><div class="im in io ip iq"><h1 id="cf02" class="mg mh it bd mi mj mk ml mm mn mo mp mq jz mr ka ms kc mt kd mu kf mv kg mw mx bi translated">当删除日志模式导致死锁时该怎么办</h1><p id="5d12" class="pw-post-body-paragraph kz la it lb b lc my ju le lf mz jx lh li na lk ll lm nb lo lp lq nc ls lt lu im bi translated">如果具有不同日志记录模式的持久性容器当前处于活动状态并且正在使用数据库文件，则会发生死锁。对于为什么会发生这种情况，我没有确切的解释，但这可能是由数据库文件上的一个活动锁引起的。因此，请确保仅在没有到数据库的活动连接时才强制提交。</p></div><div class="ab cl lz ma hx mb" role="separator"><span class="mc bw bk md me mf"/><span class="mc bw bk md me mf"/><span class="mc bw bk md me"/></div><div class="im in io ip iq"><h1 id="6a42" class="mg mh it bd mi mj mk ml mm mn mo mp mq jz mr ka ms kc mt kd mu kf mv kg mw mx bi translated">结论</h1><p id="d60a" class="pw-post-body-paragraph kz la it lb b lc my ju le lf mz jx lh li na lk ll lm nb lo lp lq nc ls lt lu im bi translated">核心数据允许我们使用高级API将数据保存在SQLite存储中。读完这篇博文后，您有望了解更多关于底层结构的知识，它使用的是预写日志记录模式。强制提交允许您将更改写入SQLite文件，以确保本地数据库文件中确实存在更改。如果您想进一步提高您的Swift知识，请查看<a class="ae ky" href="https://www.avanderlee.com/category/swift/" rel="noopener ugc nofollow" target="_blank"> Swift类别页面</a>。</p><p id="4371" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">谢谢！</p></div></div>    
</body>
</html>