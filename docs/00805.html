<html>
<head>
<title>Recursion-Phobia: Fear of Falling Into an Infinite Loop With Recursion</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">递归恐惧症:害怕陷入递归的无限循环</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/recursion-phobia-4251f625d7b6?source=collection_archive---------16-----------------------#2019-07-15">https://betterprogramming.pub/recursion-phobia-4251f625d7b6?source=collection_archive---------16-----------------------#2019-07-15</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div class="gh gi jn"><img src="../Images/6ab189fb2ab2f3acb28bf4eed3a9b13d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1392/format:webp/1*Q4jrQ97OIR49d_bYvqOndg.png"/></div><p class="ju jv gj gh gi jw jx bd b be z dk translated">图片来自谷歌&lt;<a class="ae jy" href="https://www.quora.com/What-are-some-of-the-best-recursion-jokes" rel="noopener ugc nofollow" target="_blank">https://www . quora . com/What-s-some-of-the-best-recursion-skills</a>&gt;</p></figure><p id="c124" class="pw-post-body-paragraph jz ka iq kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ij bi translated">在我的代码学习之旅中，我为一个叫做<em class="kx">递归</em>的话题纠结了很久。</p><p id="3fe0" class="pw-post-body-paragraph jz ka iq kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ij bi translated">如上图所示，在程序崩溃之前，我总是发现自己处于一个无限循环中。</p><p id="5bbb" class="pw-post-body-paragraph jz ka iq kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ij bi translated">不知何故，我通过调用递归的兄弟<strong class="kb ir">迭代</strong>，设法解决了大多数涉及递归的代码挑战问题。</p><p id="52fb" class="pw-post-body-paragraph jz ka iq kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ij bi translated">我不建议在一个明显需要递归的问题中进行迭代(使用循环),因为它们只是不必要的代码行，需要花更长的时间来编写。</p><p id="6288" class="pw-post-body-paragraph jz ka iq kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ij bi translated">在代码挑战中，时间是一个重要因素。但最重要的是，数组可以像这样深度嵌套:<code class="fe ky kz la lb b">[13,[5,[3[“hello”,[9,[“can”,[“you find me”]]]</code>。</p><p id="db13" class="pw-post-body-paragraph jz ka iq kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ij bi translated">如果你像我一样是个初学者，你在理解递归上有困难，那么你知道你可以用迭代来解决它，因为递归是迭代的一种替代。</p><figure class="ld le lf lg gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="lh li di lj bf lk"><div class="gh gi lc"><img src="../Images/6ab33affc566b4b45e9ccb20b33ff0c0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*fbUtUcBKe9VjsIm9lIj2bA.png"/></div></div><p class="ju jv gj gh gi jw jx bd b be z dk translated"><a class="ae jy" href="https://www.freecodecamp.org/news/how-recursion-works-explained-with-flowcharts-and-a-video-de61f40cb7f9/" rel="noopener ugc nofollow" target="_blank">https://www . freecodecamp . org/news/how-recursion-works-explained-with-flow-and-a-video-de 61 f 40 CB 7 f 9/</a></p></figure><p id="e811" class="pw-post-body-paragraph jz ka iq kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ij bi translated">然而，一旦你理解了基本情况和递归情况为什么以及如何工作——在任何情况下你都会选择递归而不是迭代。</p></div><div class="ab cl ll lm hu ln" role="separator"><span class="lo bw bk lp lq lr"/><span class="lo bw bk lp lq lr"/><span class="lo bw bk lp lq"/></div><div class="ij ik il im in"><h1 id="f21a" class="ls lt iq bd lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp bi translated">什么是递归</h1><p id="b139" class="pw-post-body-paragraph jz ka iq kb b kc mq ke kf kg mr ki kj kk ms km kn ko mt kq kr ks mu ku kv kw ij bi translated">让我们深入了解什么是递归，如何识别递归问题，以及我用来解决递归问题的常用方法。</p><p id="158c" class="pw-post-body-paragraph jz ka iq kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ij bi translated">当函数调用自身时，就会发生递归。递归有助于将更大的问题分解成更小的块，直到没有更多问题需要分解——我们可以将最后一个块称为<em class="kx">基础用例</em>。</p><p id="ff07" class="pw-post-body-paragraph jz ka iq kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ij bi translated">如果你没有一个基本用例，一旦函数/方法调用它自己，它将陷入一个无限循环，直到程序崩溃。</p><p id="445f" class="pw-post-body-paragraph jz ka iq kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ij bi translated">让我们来看看JavaScript和Ruby中的两个不同问题。</p><figure class="ld le lf lg gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="lh li di lj bf lk"><div class="gh gi mv"><img src="../Images/417196dc8e7af7741c70baeebc06b24c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*JI9SlgOt7I59YHcNkKkYxA.png"/></div></div><p class="ju jv gj gh gi jw jx bd b be z dk translated">来自repl.it/jahan2019</p></figure><p id="4e69" class="pw-post-body-paragraph jz ka iq kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ij bi translated">上面的图片是我在<a class="ae jy" href="https://repl.it/" rel="noopener ugc nofollow" target="_blank"> Repl.it </a>(练习你的代码的网站)上解决并复制的一个问题的快照。</p><p id="dd0a" class="pw-post-body-paragraph jz ka iq kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ij bi translated">如你所见，嵌套鸟是一个深度嵌套的数组。</p><p id="9451" class="pw-post-body-paragraph jz ka iq kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ij bi translated">当我着手解决这个问题时，我问自己:“我要把所有的迭代都写出来吗？如果嵌套更深，比如9个或12个深度数组呢？”</p><p id="c9a9" class="pw-post-body-paragraph jz ka iq kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ij bi translated">我创建了一个名为<em class="kx">nestibird</em>的函数，它在括号中接受一个参数。然后，我已经在一个空字符串中设置了我的最终答案(我要返回的值)。</p><p id="02ae" class="pw-post-body-paragraph jz ka iq kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ij bi translated">第7行“for循环”是查看第一个数组并检查。</p><p id="6e0b" class="pw-post-body-paragraph jz ka iq kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ij bi translated">我有一个<code class="fe ky kz la lb b">if</code>子句(第9-15行),它基本上说明了如果它是一个数组，那么调用函数，否则转到最基本的状态。</p><p id="28ff" class="pw-post-body-paragraph jz ka iq kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ij bi translated">在我的基本案例中，每个元素都被添加到<code class="fe ky kz la lb b">finalString</code>中。</p><figure class="ld le lf lg gt jr gh gi paragraph-image"><div class="gh gi mw"><img src="../Images/0287d592ef4f365a233eb5e58b3b2694.png" data-original-src="https://miro.medium.com/v2/resize:fit:778/format:webp/1*6rDomwLH3oIztixTp51JCg.png"/></div><p class="ju jv gj gh gi jw jx bd b be z dk translated">回复它</p></figure><p id="3095" class="pw-post-body-paragraph jz ka iq kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ij bi translated">类似地，我们可以通过设置一个基础案例和一个递归案例，用Ruby以同样的方式解决阶乘问题。</p></div></div>    
</body>
</html>