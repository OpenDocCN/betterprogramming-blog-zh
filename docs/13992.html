<html>
<head>
<title>Does Async-Await and Promises Guarantee Asynchronous Code? No (and Here’s Why)</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Async-Await和Promises保证异步代码吗？没有(原因如下)</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/why-just-using-async-await-and-promises-doesnt-make-your-code-asynchronous-e8ee9014d92e?source=collection_archive---------2-----------------------#2022-10-24">https://betterprogramming.pub/why-just-using-async-await-and-promises-doesnt-make-your-code-asynchronous-e8ee9014d92e?source=collection_archive---------2-----------------------#2022-10-24</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="7252" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">一个异步方法只有在调用其他异步方法时才是真正的异步</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/12619904bc406ddb242c27903240348c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*W89ERTNtf0VqTyzJ"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">同步与异步|作者图片</p></figure><p id="3643" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">许多开发人员有一种误解，认为如果他们在函数定义前添加<code class="fe lr ls lt lu b">async</code>，返回一个承诺，并在该承诺上使用<code class="fe lr ls lt lu b">.then</code>或<code class="fe lr ls lt lu b">await</code>，他们的代码将是非阻塞的(异步的)。在等待该承诺的解决方案时，其他代码(如处理UI交互事件)可以自由运行。</p><p id="6f90" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">本文通过几个例子打破了这个神话，告诉你什么时候你的代码是真正异步和非阻塞的。</p></div><div class="ab cl lv lw hu lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="ij ik il im in"><p id="8c13" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">JavaScript是单线程的。它只用一个线程来运行你所有的代码。让我们看一个异步代码的例子:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mc md l"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">带<code class="fe lr ls lt lu b">setTimeout()</code>的异步示例</p></figure><p id="ddc3" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">花点时间试着弄清楚这段代码在做什么。我们正在调用异步函数<code class="fe lr ls lt lu b">OrderIceCream()</code>，它将创建一个7秒钟的计时器，然后执行一个回调，记录“您的冰淇淋已经到达”，并通过消息“冰淇淋已送达”解析承诺，这将由<code class="fe lr ls lt lu b">.then</code>回调记录。</p><p id="cee6" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">我们还调用了<code class="fe lr ls lt lu b">EatPizza()</code>函数。我们想点些冰淇淋，在披萨还在路上的时候吃披萨，之后我们会接受送货。</p><p id="aad4" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">你认为<code class="fe lr ls lt lu b">console.logs</code>的顺序会是什么？复制上述代码，将其粘贴到浏览器控制台(f12)中，或者使用Node运行它。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mc md l"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">带有setTimeout()输出的异步示例</p></figure><p id="1ba8" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">正如我们所看到的，“订购冰淇淋”首先被记录，然后是“吃披萨”7秒钟后，“你的冰淇淋已经到了”被记录下来，紧接着是“冰淇淋送到了”这正是我们想要的！</p><p id="1f69" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">当计时器运行时，JavaScript主线程没有被阻塞。它可以自由地执行其他代码(T8函数)。这是异步代码的一个例子。</p></div><div class="ab cl lv lw hu lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="ij ik il im in"><p id="d185" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">现在我们来看另一个例子。这一次，我们将稍微改变一下<code class="fe lr ls lt lu b">OrderIceCream()</code>:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mc md l"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">同步CPU限制阻塞示例</p></figure><p id="abc5" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">现在我们已经移除了<code class="fe lr ls lt lu b">setTimeout()</code>并添加了一个for循环，它将运行10，00，00，00，000次迭代(一个非常长的循环，需要很多秒才能完成)。</p><p id="d05a" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">你认为这次控制台日志的顺序会是什么？如果使用<code class="fe lr ls lt lu b"><em class="me">.then()</em></code>(或使用async-await)返回一个承诺并在该承诺的解析之后调度一个回调足以使我们的代码异步，并且不会阻塞主线程，那么我们应该会看到与之前相同的结果。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mc md l"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">同步CPU绑定阻塞示例输出</p></figure><p id="33a9" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">实际的记录顺序与我们预期的相反。在日志“订购冰淇淋”和“您的冰淇淋已经到了”之间有几秒钟的间隔，我们不想等着冰淇淋来吃我们的比萨饼。为什么会这样呢？</p><p id="318c" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">再次提醒你，JavaScript是单线程的。它使用一个线程来运行你所有的代码。这意味着for循环也将在主线程上运行，并且只有当这个for循环完成后，其余的代码才会运行。</p><p id="b8c8" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">因此，如果您有同步代码，它将在主线程上运行，即使您的函数是异步的。</p><p id="cee0" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">注意<code class="fe lr ls lt lu b">console.logs</code>也是同步代码，但是它们不需要太多的执行时间，所以它们只会阻塞我们的主线程几毫秒。在此期间，如果您的UI上有一个按钮单击事件，那么该事件的处理程序将不会被执行，直到线程正在执行的任何内容完成为止。</p><p id="a959" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">对于像<code class="fe lr ls lt lu b">console.log</code>这样的简单语句，这种延迟只有几毫秒，用户几乎察觉不到，但是对于像运行1e10次迭代的大For循环这样的东西，用户界面会被冻结很多秒，用户会注意到这一点。在线程释放之前，不会运行其他代码。</p><p id="0713" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">我使用了big for循环的例子来模拟长时间运行的同步代码，比如处理一个大型数据集或者将一个长视频从一种格式转换成另一种格式。</p><p id="2e47" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">那么，如何才能让这个长时间运行的同步代码不阻塞主线程呢？您可以使用“工作线程”来运行它。虽然JavaScript是单线程的，但是我们用来运行JavaScript代码的浏览器有“web worker”线程。类似地，NodeJs也有“节点工作者”线程。您可以在工作线程上运行大for循环(或任何其他长期运行的代码)。这将阻塞工作线程，但让您的主线程自由地做其他事情，如处理UI事件。</p></div><div class="ab cl lv lw hu lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="ij ik il im in"><p id="abff" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">好的，所以即使你的方法使用了promises和“<code class="fe lr ls lt lu b">.then</code>或“<code class="fe lr ls lt lu b">async-await</code>”，方法内部的代码本身是同步的，将在单个JavaScript线程上执行，如果代码是长时间运行的，主线程将不能长时间运行其他任何东西。</p><p id="4424" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">但是第一个例子中的<code class="fe lr ls lt lu b">setTimeout()</code>呢？计时器在哪里计时？它不是也会在主线程执行的时候阻塞它吗？或者我们使用工作线程，这样我们的主线程是自由的吗？那么等待网络响应呢:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mc md l"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">异步非阻塞I/O示例</p></figure><p id="4cca" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">在本例中，我创建了一个节点服务器，它监听localhost:5000，每当接收到一个请求时，在等待5秒钟后返回一个响应(正文为文本“Ice cream delivered”)。那么，你认为控制台日志的顺序会是怎样的呢？</p><p id="477c" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">既然我们知道所有代码都在同一个线程上执行，我们可能会认为等待网络响应也会发生在那个线程上。这意味着我们应该首先看到“订购冰淇淋”被记录，然后等待响应的过程就完成了，五秒钟后，我们将看到响应(“冰淇淋已送达”)被记录，然后是“吃比萨饼”</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mc md l"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">异步非阻塞I/O示例输出</p></figure><p id="51e8" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">但是，就像第一个<code class="fe lr ls lt lu b">setTimeout()</code>的例子一样，我们看到在这种情况下，<code class="fe lr ls lt lu b">EatPizza()</code>函数也可以在等待响应时执行。首先记录“订购冰淇淋”，然后是“吃比萨饼”，五秒钟后，记录来自服务器的响应(“冰淇淋已送达”)。</p><p id="393f" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">为什么计时器和等待网络响应不会阻塞主线程？他们会阻塞一个工作线程吗？</p><p id="0f21" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">要理解这一点，首先要知道定时器和网络操作都是输入输出操作。一般来说，CPU上没有发生的任何事情都称为I/O。</p><p id="b3f7" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">发送网络请求(将请求写入套接字)或读取响应(从套接字)都是I/O操作(就像鼠标点击、按键或硬盘读/写一样)。执行这些I/O操作的设备是网络接口卡。计算时间使用系统时钟。</p><p id="189b" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated"><code class="fe lr ls lt lu b">setTimeout()</code>、<code class="fe lr ls lt lu b">fetch()</code>等库函数在主线程上同步运行(阻塞一段时间)，但是实际的计算时间、写入网卡、读取网卡响应的工作都是I/O操作。</p><h1 id="9998" class="mf mg iq bd mh mi mj mk ml mm mn mo mp jw mq jx mr jz ms ka mt kc mu kd mv mw bi translated">线程阻塞的类型</h1><p id="3906" class="pw-post-body-paragraph kv kw iq kx b ky mx jr la lb my ju ld le mz lg lh li na lk ll lm nb lo lp lq ij bi translated">有两种类型的线程阻塞:</p><p id="d863" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">CPU限制阻塞:线程被阻塞是因为它在CPU上主动执行。上面的第二个例子(1e10迭代for-loop)是CPU限制的阻塞。</p><p id="a88e" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">I/O绑定阻塞:这里，一个线程被阻塞，等待I/O事件发生。在这种情况下，线程没有在CPU上主动执行，而是处于休眠状态(在RAM的等待队列中)。</p><p id="33b9" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">JavaScript不做I/O绑定阻塞；它不会在等待I/O事件时阻塞线程。它实现了一种叫做“异步非阻塞I/O”的东西，让线程可以自由地做其他事情，而不是等待I/O事件。这就是等待网络响应或计时器完成不会阻塞线程的原因。是的，甚至没有工作线程！</p><h1 id="4695" class="mf mg iq bd mh mi mj mk ml mm mn mo mp jw mq jx mr jz ms ka mt kc mu kd mv mw bi translated">结论</h1><p id="366e" class="pw-post-body-paragraph kv kw iq kx b ky mx jr la lb my ju ld le mz lg lh li na lk ll lm nb lo lp lq ij bi translated">仅仅使用承诺和<code class="fe lr ls lt lu b"><em class="me">.then</em></code>或<code class="fe lr ls lt lu b"><em class="me">async-await</em></code>不会让你的代码异步(非阻塞)。您的所有代码都在一个线程上运行。</p><p id="3d69" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">有两种类型的线程阻塞:</p><p id="fee2" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">CPU限制的阻塞:如果在异步方法中有长时间运行的同步代码，它将阻塞主线程。为了克服这个问题，您可以使用工作线程来运行长同步代码，让您的主线程自由地处理其他事件。</p><p id="2f52" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">I/O绑定阻塞:线程在等待I/O事件(如鼠标点击或网络请求/响应)时被阻塞。为了克服这一点，JavaScript使用异步编程(async-await、Promises和事件循环)来实现“异步非阻塞I/O”。要理解这是如何工作的，请查看我的文章。</p><p id="a48a" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">最终，一个异步方法只有在调用其他异步方法时才是真正的异步(非阻塞的)(而其他异步方法又应该调用另一个异步方法，以此类推)。最底层应该是一个I/O操作(I/O操作完全是异步的)或者一个运行在另一个线程上的同步方法(它会阻塞另一个线程)。</p><p id="34ef" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">感谢您的阅读。</p></div></div>    
</body>
</html>