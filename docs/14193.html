<html>
<head>
<title>Salesforce Functions for Caching Expensive Queries</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">用于缓存昂贵查询的Salesforce函数</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/salesforce-functions-for-caching-expensive-queries-6b5ee2ce5380?source=collection_archive---------10-----------------------#2022-11-15">https://betterprogramming.pub/salesforce-functions-for-caching-expensive-queries-6b5ee2ce5380?source=collection_archive---------10-----------------------#2022-11-15</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="058b" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">让我们将我们的Salesforce组织连接到Heroku数据存储并构建缓存机制</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/946b3ea6f24e86073d68f5fa4d359b17.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*-aQoM-UVAcQ8HVPq"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">在<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上<a class="ae ky" href="https://unsplash.com/@enginakyurt?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> engin akyurt </a>拍摄的照片</p></figure><p id="921c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">缓存是一种可以帮助您节省资源和提高性能的策略。当您有一个经常运行的昂贵的查询并且结果很少改变时，缓存是一个理想的解决方案。必要时，可以通过缓存该查询的结果来返回缓存的结果。结果是一样的，但是您不需要运行昂贵的查询。每个人都赢了。</p><p id="e213" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在本文中，我们将介绍如何使用Salesforce函数来缓存昂贵的查询。例如，我们想在许多记录中查询某个值，需要这个查询的页面经常被加载。但是，从一次查询执行到下一次查询执行，结果不会改变。</p><h1 id="54dd" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">问题简介</h1><p id="08bc" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">在我们的演示中，示例查询将是“拥有超过10，000名员工的公司的数量”我们设想一个用例，其中有一个我们的销售团队经常加载的页面，该页面的一部分显示了我们的Salesforce组织中符合该条件的公司总数。理想情况下，并不是每次页面加载时都运行昂贵的查询；相反，我们将实现一个缓存机制。</p><p id="cceb" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">为了解决这个问题，我们将:</p><ol class=""><li id="c256" class="ms mt it lb b lc ld lf lg li mu lm mv lq mw lu mx my mz na bi translated">利用<a class="ae ky" href="https://www.heroku.com/connect" rel="noopener ugc nofollow" target="_blank"> Heroku Connect </a>将我们的公司列表从Salesforce同步到<a class="ae ky" href="https://www.heroku.com/postgres" rel="noopener ugc nofollow" target="_blank"> Heroku Postgres </a>(或使用Postgres中已有的表格)。</li><li id="4cbf" class="ms mt it lb b lc nb lf nc li nd lm ne lq nf lu mx my mz na bi translated">创建一个<a class="ae ky" href="https://developer.salesforce.com/docs/platform/functions/overview" rel="noopener ugc nofollow" target="_blank"> Salesforce函数</a>来查询Postgres并返回计数。</li><li id="ab89" class="ms mt it lb b lc nb lf nc li nd lm ne lq nf lu mx my mz na bi translated">在指定时间内将结果值存储在<a class="ae ky" href="https://www.heroku.com/redis" rel="noopener ugc nofollow" target="_blank"> Heroku Redis </a>中。</li><li id="e05e" class="ms mt it lb b lc nb lf nc li nd lm ne lq nf lu mx my mz na bi translated">使用Salesforce函数检查Redis中的值。如果Redis中存在该值，则返回它。如果没有，那么运行查询并将结果存储在Redis中。</li></ol><p id="38d4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">数据流如下所示:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ng"><img src="../Images/468fc3429b6e58f7a75d04caf67dea5c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*DWrHP8BsPgonJefb.png"/></div></div></figure><p id="b039" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">当然，Apex确实有一个<a class="ae ky" href="https://developer.salesforce.com/docs/atlas.en-us.apexcode.meta/apexcode/apex_cache_namespace_overview.htm" rel="noopener ugc nofollow" target="_blank">平台缓存API </a>来促进特定用例的缓存。出于我们的使用案例和演示目的，我们将探索这个使用Salesforce函数的缓存解决方案。</p><p id="9618" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在我们继续之前，让我们简要介绍一下我们系统中的每一个部分。</p><ul class=""><li id="af76" class="ms mt it lb b lc ld lf lg li mu lm mv lq mw lu nh my mz na bi translated"><a class="ae ky" href="https://developer.salesforce.com/docs/platform/functions/overview" rel="noopener ugc nofollow" target="_blank"> Salesforce功能</a>:Salesforce的一项功能，允许您运行仍在您的sales force组织的安全区域中但未在您的组织上运行的一些代码(JavaScript或Java是当前支持的语言)。这使您可以卸载可能导致您超出限制的繁重工作负载。</li><li id="7ebf" class="ms mt it lb b lc nb lf nc li nd lm ne lq nf lu nh my mz na bi translated"><a class="ae ky" href="https://www.heroku.com/connect" rel="noopener ugc nofollow" target="_blank">Heroku Connect</a>:Salesforce家族中的一个工具，用于您的sales force组织和<a class="ae ky" href="https://www.heroku.com/postgres" rel="noopener ugc nofollow" target="_blank"> Heroku Postgres </a>之间的双向数据同步。与Salesforce功能类似，您可以利用此工具，而不会影响您的Salesforce限制。</li><li id="9d52" class="ms mt it lb b lc nb lf nc li nd lm ne lq nf lu nh my mz na bi translated">Heroku Postgres:Heroku上的一个完全托管的PostgreSQL (一个关系数据库)实例。</li><li id="811d" class="ms mt it lb b lc nb lf nc li nd lm ne lq nf lu nh my mz na bi translated"><a class="ae ky" href="https://www.heroku.com/redis" rel="noopener ugc nofollow" target="_blank">Heroku Redis</a>:Heroku上的一个完全托管的<a class="ae ky" href="https://redis.io/" rel="noopener ugc nofollow" target="_blank"> Redis </a>(内存中的键值存储)实例。</li></ul><h1 id="ebab" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">先决条件</h1><p id="be84" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">要使用上述所有组件，您必须准备好以下组件:</p><ul class=""><li id="be5d" class="ms mt it lb b lc ld lf lg li mu lm mv lq mw lu nh my mz na bi translated">一个<a class="ae ky" href="https://signup.heroku.com/" rel="noopener ugc nofollow" target="_blank"> Heroku账号</a></li><li id="2856" class="ms mt it lb b lc nb lf nc li nd lm ne lq nf lu nh my mz na bi translated">一个<a class="ae ky" href="https://devcenter.heroku.com/articles/creating-apps" rel="noopener ugc nofollow" target="_blank"> Heroku app </a>创建，附带<a class="ae ky" href="https://devcenter.heroku.com/articles/heroku-postgresql#provisioning-heroku-postgres" rel="noopener ugc nofollow" target="_blank"> Postgres </a>和<a class="ae ky" href="https://devcenter.heroku.com/articles/heroku-redis#create-an-instance" rel="noopener ugc nofollow" target="_blank"> Redis </a>附加组件</li><li id="5257" class="ms mt it lb b lc nb lf nc li nd lm ne lq nf lu nh my mz na bi translated">启用了<a class="ae ky" href="https://developer.salesforce.com/docs/platform/functions/guide/index.html" rel="noopener ugc nofollow" target="_blank">功能的Salesforce组织</a></li><li id="6686" class="ms mt it lb b lc nb lf nc li nd lm ne lq nf lu nh my mz na bi translated">本地Salesforce功能<a class="ae ky" href="https://developer.salesforce.com/docs/platform/functions/guide/set-up.html" rel="noopener ugc nofollow" target="_blank">开发环境</a></li><li id="5470" class="ms mt it lb b lc nb lf nc li nd lm ne lq nf lu nh my mz na bi translated">[可选] <a class="ae ky" href="https://devcenter.heroku.com/articles/quick-start-heroku-connect-cli" rel="noopener ugc nofollow" target="_blank"> Heroku Connect </a>同步到Postgres(提供样本数据集)</li></ul><p id="8fc1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">有了先决条件，我们就可以开始连接它们了。首先，我们将浏览连接环境。然后，我们将看看实现这一奇迹所需的代码。</p><h1 id="9257" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">从Salesforce功能访问Heroku数据服务</h1><p id="b89a" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">有了您的帐户和访问权限，我们就可以继续使用该功能了。假设您正在开始一个新项目，并且有一个空的Postgres数据库。</p><p id="af52" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果您是函数新手，我们建议您在涉及其他部分之前，先完成这个基本过程，以便对事物有所了解。如果您已经有一个Salesforce项目或正在通过Heroku Connect同步数据，您可以修改以下命令以满足您的需求。</p><p id="b7d3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">首先，创建一个Salesforce DX项目，为您的功能提供一个家。</p><pre class="kj kk kl km gt ni nj nk bn nl nm bi"><span id="f865" class="nn lw it nj b be no np l nq nr">sfdx force:project:create -n MyDataProj</span></pre><p id="1657" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">接下来，导航到项目目录并运行以下命令来创建一个新的JavaScript函数。</p><pre class="kj kk kl km gt ni nj nk bn nl nm bi"><span id="6bdc" class="nn lw it nj b be no np l nq nr">sf generate function -n yourfunction -l javascript</span></pre><p id="bc92" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这将创建一个带有Node.js应用程序模板的<code class="fe ns nt nu nj b">/functions</code>文件夹。</p><p id="422b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">接下来，通过将Heroku用户作为协作者添加到您的职能部门的计算环境，将您的Salesforce职能部门与您的Heroku环境相关联:</p><pre class="kj kk kl km gt ni nj nk bn nl nm bi"><span id="1cf5" class="nn lw it nj b be no np l nq nr">sf env compute collaborator add --heroku-user &lt;yourherokuaccount@email.com&gt;</span></pre><p id="134a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这些环境现在可以共享Heroku数据服务。</p><p id="bd2b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">接下来，您需要获得计算环境的名称，以便可以将数据存储区连接到它。</p><pre class="kj kk kl km gt ni nj nk bn nl nm bi"><span id="003e" class="nn lw it nj b be no np l nq nr">sf env list</span></pre><p id="0774" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">要附加Heroku数据存储库，您还需要附加组件的名称。您可以使用以下命令获得附加组件的名称:</p><pre class="kj kk kl km gt ni nj nk bn nl nm bi"><span id="2629" class="nn lw it nj b be no np l nq nr">heroku addons -a &lt;yourherokuapp&gt;</span></pre><p id="774c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">输出将类似于以下内容。每个附加组件的“名称”显示为紫色(例如，<code class="fe ns nt nu nj b">postgresql-closed-46065</code>)。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nv"><img src="../Images/d417bd4ca3686592321f2a10e8809de4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*s0q26jwrLsstevp_.png"/></div></div></figure><p id="1216" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">使用计算环境和附加组件的名称，运行以下命令将Postgres和Redis附加到您的计算环境:</p><pre class="kj kk kl km gt ni nj nk bn nl nm bi"><span id="3ed5" class="nn lw it nj b be no np l nq nr">heroku addons:attach &lt;your-heroku-postgres-name&gt; --app &lt;your-compute-environment-name&gt;</span></pre><pre class="nw ni nj nk bn nl nm bi"><span id="d4ef" class="nn lw it nj b be no np l nq nr">heroku addons:attach &lt;your-heroku-redis-name&gt; --app &lt;your-compute-environment-name&gt;</span></pre><p id="f8ea" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在，我们已经将Salesforce功能环境与Heroku数据存储连接起来，我们可以编写我们的Salesforce功能代码了。</p><h1 id="ac5e" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">实施Salesforce功能</h1><p id="f793" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">在我们开始为这个Salesforce函数编写JavaScript之前，让我们用必要的库设置我们的本地开发环境。我们的函数将从部署环境中的环境变量获取数据连接信息。对于我们的本地环境，我们将使用<a class="ae ky" href="https://www.npmjs.com/package/dotenv" rel="noopener ugc nofollow" target="_blank"> dotenv </a>节点包来读取一个名为<code class="fe ns nt nu nj b">.env</code>的文件中的信息。我们可以使用以下命令创建该文件:</p><pre class="kj kk kl km gt ni nj nk bn nl nm bi"><span id="1f49" class="nn lw it nj b be no np l nq nr">heroku config -a &lt;yourherokuapp&gt; --shell &gt; .env</span></pre><p id="7c33" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">接下来，让我们安装与Postgres和Redis以及dotenv交互所需的包:</p><pre class="kj kk kl km gt ni nj nk bn nl nm bi"><span id="e957" class="nn lw it nj b be no np l nq nr">npm install dotenv pg redis</span></pre><p id="9c45" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们的项目设置已经完成。让我们写函数代码。</p><h1 id="6849" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">连接到Heroku Postgres和Redis</h1><p id="d594" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">让我们从添加允许我们在Heroku Postgres和Heroku Redis中读取和存储数据的代码开始。(注意:<a class="ae ky" href="https://devcenter.heroku.com/" rel="noopener ugc nofollow" target="_blank"> Heroku Devcenter </a>有关于从Node.js连接到<a class="ae ky" href="https://devcenter.heroku.com/articles/connecting-heroku-postgres#connecting-in-node-js" rel="noopener ugc nofollow" target="_blank"> Postgres </a>和<a class="ae ky" href="https://devcenter.heroku.com/articles/connecting-heroku-redis#connecting-in-node-js" rel="noopener ugc nofollow" target="_blank"> Redis </a>的有用文档。)</p><p id="bebc" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们的函数代码将保存在项目中<code class="fe ns nt nu nj b">functions</code>文件夹的<code class="fe ns nt nu nj b">index.js</code>文件中(例如，<code class="fe ns nt nu nj b">MyDataProj/functions/index.js</code>)。我们打开该文件，并在顶部添加以下行。这些行将导入我们刚刚安装的模块。</p><pre class="kj kk kl km gt ni nj nk bn nl nm bi"><span id="05e3" class="nn lw it nj b be no np l nq nr">import "dotenv/config";<br/>import pg from "pg";<br/>const { Client } = pg;<br/>import { createClient } from 'redis';</span></pre><p id="4fcc" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">该函数的主要部分是正在导出的部分。从这个块返回的值将被返回给函数的调用者。</p><pre class="kj kk kl km gt ni nj nk bn nl nm bi"><span id="60fe" class="nn lw it nj b be no np l nq nr">export default async function (event, context, logger) {</span></pre><pre class="nw ni nj nk bn nl nm bi"><span id="7c54" class="nn lw it nj b be no np l nq nr">}</span></pre><p id="27d9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">为了保持代码的整洁和模块化，让我们首先在文件的底部写几个助手函数。我们需要可以调用的函数来管理我们到Postgres和Redis的连接。在导出函数之下(之外)，我们添加了以下两个辅助函数:</p><pre class="kj kk kl km gt ni nj nk bn nl nm bi"><span id="e301" class="nn lw it nj b be no np l nq nr">/* Helper functions */</span></pre><pre class="nw ni nj nk bn nl nm bi"><span id="f1d3" class="nn lw it nj b be no np l nq nr">// Connect to PostgreSQL<br/>async function pgConnect() {<br/>   const DATABASE_URL = process.env.DATABASE_URL;<br/>   if (!DATABASE_URL) {<br/>     throw new Error("DATABASE_URL is not set");<br/>   }<br/>    const client = new Client({<br/>     connectionString: DATABASE_URL,<br/>     ssl: {<br/>       rejectUnauthorized: false<br/>     }<br/>   });<br/>    await client.connect();<br/>   return client;<br/> }</span></pre><pre class="nw ni nj nk bn nl nm bi"><span id="7207" class="nn lw it nj b be no np l nq nr">// Connect to Redis<br/>async function redisConnect() {<br/>   const REDIS_URL = process.env.REDIS_URL;<br/>   if (!REDIS_URL) {<br/>     throw new Error("REDIS_URL is not set");<br/>   }<br/>    const redis = createClient({<br/>       url: process.env.REDIS_URL,<br/>       socket: {<br/>           tls: true,<br/>           rejectUnauthorized: false<br/>       }<br/>       });<br/>    await redis.connect();<br/>   redis.on('error', err =&gt; {<br/>       console.log('Error ' + err);<br/>   });<br/>   return redis;<br/> }</span></pre><h1 id="00ea" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">在样本数据集中加载</h1><p id="c385" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">让我们将一个小数据集加载到Postgres中，以保持示例的简单性。我们可以通过运行以下<a class="ae ky" href="https://gist.github.com/alvinslee/3a7233eab951ec269f3d3fdf9d1e2283" rel="noopener ugc nofollow" target="_blank">要点</a>中的数据库命令来创建一个名为“company”的表。将要点内容下载到一个名为<code class="fe ns nt nu nj b">company.sql</code>的文件中。要从Heroku CLI运行数据库命令，请执行以下操作:</p><pre class="kj kk kl km gt ni nj nk bn nl nm bi"><span id="0f41" class="nn lw it nj b be no np l nq nr">heroku pg:psql -a &lt;yourherokuapp&gt;</span></pre><pre class="nw ni nj nk bn nl nm bi"><span id="49b7" class="nn lw it nj b be no np l nq nr">DATABASE=&gt; \i /path/to/company.sql</span></pre><p id="538a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">您可以通过运行以下查询来验证您的示例数据集是否已加载:</p><pre class="kj kk kl km gt ni nj nk bn nl nm bi"><span id="9a88" class="nn lw it nj b be no np l nq nr">DATABASE=&gt; select * from company;</span></pre><h1 id="9846" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">编写主函数</h1><p id="cd39" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">我们都准备好了！现在，我们要为我们的实际函数写一点代码。我们函数的代码可作为<a class="ae ky" href="https://gist.github.com/alvinslee/62cb4ad3390740ed8a15e2da11d0d020" rel="noopener ugc nofollow" target="_blank">要点</a>获得，如下所示。你可以把这个拷贝到你的<code class="fe ns nt nu nj b">index.js</code>文件中。我们将逐步解释代码的每一部分。</p><pre class="kj kk kl km gt ni nj nk bn nl nm bi"><span id="bc37" class="nn lw it nj b be no np l nq nr">export default async function (event, context, logger) {<br/>   logger.info(`Invoking Datafunction with payload ${JSON.stringify(event.data || {})}`);</span></pre><pre class="nw ni nj nk bn nl nm bi"><span id="c1c9" class="nn lw it nj b be no np l nq nr">const redis = await redisConnect();<br/>   let cached = {};</span></pre><pre class="nw ni nj nk bn nl nm bi"><span id="137b" class="nn lw it nj b be no np l nq nr">// Check Redis for cached entry first<br/>   let big_biz_count = await redis.get(`big_biz`);</span></pre><pre class="nw ni nj nk bn nl nm bi"><span id="28ed" class="nn lw it nj b be no np l nq nr">if (big_biz_count) {<br/>       // If cached entry found, return it and be done.<br/>       logger.info(`Found cache entry = ${big_biz_count}`);<br/>       cached = "true"<br/>       redis.quit();</span></pre><pre class="nw ni nj nk bn nl nm bi"><span id="b231" class="nn lw it nj b be no np l nq nr">return { big_biz_count, cached }<br/>   }  else {<br/>      // If cached entry not found, then:<br/>      // 1. Run the Postgres query<br/>      // 2. Store the result in Redis<br/>      // 3. Return the result and be done<br/>       logger.info(`did not find in cache, returned ${big_biz_count}`);<br/>       cached = "false"<br/>       const pg = await pgConnect();<br/>       const { rows } = await pg.query('SELECT COUNT(*) FROM company WHERE employees&gt;10000;');<br/>       big_biz_count = rows[0].count.toString();</span></pre><pre class="nw ni nj nk bn nl nm bi"><span id="f2d3" class="nn lw it nj b be no np l nq nr">redis.set(`big_biz`, big_biz_count, {<br/>         EX: 30, // seconds to keep before expiring<br/>         NX: true<br/>       });</span></pre><pre class="nw ni nj nk bn nl nm bi"><span id="6ae1" class="nn lw it nj b be no np l nq nr">// Close the connections   <br/>       redis.quit();<br/>       pg.end();</span></pre><pre class="nw ni nj nk bn nl nm bi"><span id="4b91" class="nn lw it nj b be no np l nq nr">// Return the value from Postgres, now stored in Redis<br/>       return { big_biz_count, cached }<br/>   }<br/>}</span></pre><h1 id="956c" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">代码的解释</h1><p id="06af" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">正如本文开头提到的，我们希望找出有多少公司拥有超过10，000名员工，并返回该数字。我们希望缓存这个数字，因为这是一个“昂贵的查询”在我们的例子中，桌子很小，所以不贵。然而，它代表了我们在现实生活中可能想要运行的“昂贵查询”。你明白了。</p><p id="5fa8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们浏览一下函数代码的主要部分。</p><p id="4748" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">1)连接到Redis，查看值是否存在。</p><pre class="kj kk kl km gt ni nj nk bn nl nm bi"><span id="edf0" class="nn lw it nj b be no np l nq nr">const redis = await redisConnect();<br/>  let cached = {};<br/>  let big_biz_count = await redis.get(`big_biz`);</span></pre><p id="d776" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">2)如果值在那里，意味着它已经被缓存，那么我们可以返回缓存的值，这样就完成了。</p><pre class="kj kk kl km gt ni nj nk bn nl nm bi"><span id="6fbf" class="nn lw it nj b be no np l nq nr">if (big_biz_count) {<br/>    cached = "true"<br/>    redis.quit();<br/>    return { big_biz_count, cached }</span></pre><p id="9f9f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">3)如果没有找到缓存值，那么我们别无选择，只能在Postgres数据库上运行查询。</p><pre class="kj kk kl km gt ni nj nk bn nl nm bi"><span id="f6fe" class="nn lw it nj b be no np l nq nr">}  else {<br/>    cached = "false"<br/>    const pg = await pgConnect();<br/>    const { rows } = await pg.query('SELECT COUNT(*) FROM company WHERE employees&gt;10000;');<br/>    big_biz_count = rows[0].count.toString();</span></pre><p id="a557" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">4)然后，我们将查询返回的值存储在Redis中。</p><pre class="kj kk kl km gt ni nj nk bn nl nm bi"><span id="2238" class="nn lw it nj b be no np l nq nr">redis.set(`big_biz`, big_biz_count, {<br/>      EX: 30, // seconds to keep before expiring<br/>      NX: true<br/>    });</span></pre><p id="9044" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">5)最后，我们关闭数据存储连接，并返回查询结果。</p><pre class="kj kk kl km gt ni nj nk bn nl nm bi"><span id="b0b4" class="nn lw it nj b be no np l nq nr">redis.quit();<br/>    pg.end();<br/>    return { big_biz_count, cached }</span></pre><p id="02cd" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">您可能更喜欢重构代码或添加一些错误处理。然而，在这个最基本的水平上，这就是它的全部。</p><h1 id="ab9f" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">测试功能</h1><p id="61ed" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">现在我们有了一个Salesforce函数，我们可以在本地测试它。首先，我们启动函数服务器。</p><pre class="kj kk kl km gt ni nj nk bn nl nm bi"><span id="2d7f" class="nn lw it nj b be no np l nq nr">sf run function start</span></pre><p id="99e1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">然后，我们使用来自另一个终端的有效载荷调用该函数。</p><pre class="kj kk kl km gt ni nj nk bn nl nm bi"><span id="7b1c" class="nn lw it nj b be no np l nq nr">sf run function -l http://localhost:8080 -p '{"payloadID": "info"}'</span></pre><p id="ba06" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">当您第一次对测试数据库调用该函数时，您应该会看到以下输出，因为缓存中没有值:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi nx"><img src="../Images/d93c9da8f24a45bcd4ff8a95be740377.png" data-original-src="https://miro.medium.com/v2/resize:fit:498/format:webp/0*jCCB93pira8jPkXO.png"/></div></figure><p id="0c7c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">然而，在第一次运行之后，该值被存储在我们的Heroku Redis实例中。Salesforce函数的后续运行返回相同的值，但这一次，<code class="fe ns nt nu nj b">cached</code>为真。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi ny"><img src="../Images/f15198e612a855de2b7103535788fdc6.png" data-original-src="https://miro.medium.com/v2/resize:fit:484/format:webp/0*zUr84UQB2z93iQWN.png"/></div></figure><p id="1b3f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">当我们将该值添加到Redis时，我们将缓存过期时间设置为10秒。这使得测试更加容易。然而，在现实环境中，缓存值的生命周期应该对您的业务用例有意义。例如，如果报告在夜间运行后结果发生变化，那么您可以将缓存值设置为每24小时过期一次。更好的是，您可以创建另一个Salesforce函数，在报表完成后立即用新值更新缓存。</p><p id="d770" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">index.js的全部内容可以在这里<a class="ae ky" href="https://gist.github.com/alvinslee/62cb4ad3390740ed8a15e2da11d0d020" rel="noopener ugc nofollow" target="_blank">下载。</a></p><h1 id="7166" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">结论</h1><p id="ec97" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">我们做到了。缓存是减少资源负载同时提供更快响应的优秀策略。借助Salesforce功能，我们可以将Salesforce组织连接到Heroku数据存储(如Postgres和Redis)并构建缓存机制。</p><p id="fe47" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">Salesforce功能允许我们执行通常可能负载繁重、导致超时或超出Salesforce施加的其他限制的任务。缓存只是一个用例，但是它可以产生巨大的好处，并且易于实现。现在，去享受吧！</p></div></div>    
</body>
</html>