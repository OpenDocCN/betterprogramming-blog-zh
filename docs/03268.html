<html>
<head>
<title>Share the UI Event State in React With RxJS</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">与RxJS共享React中的UI事件状态</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/sharing-ui-event-state-in-react-with-rxjs-f7edf5648027?source=collection_archive---------13-----------------------#2020-01-30">https://betterprogramming.pub/sharing-ui-event-state-in-react-with-rxjs-f7edf5648027?source=collection_archive---------13-----------------------#2020-01-30</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="11fb" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">跨组件共享状态</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/8f2e73ff03e5d5c059653a601e6b36a5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*53oW1RCEGI5bcSYkkHFDrg.png"/></div></div></figure><p id="59e2" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">这篇文章是一个在React组件之间共享UI事件数据的漂亮解决方案的分解，这个问题对我来说是一个长期的挑战。这是我最近在React/ TypeScript项目中使用的策略，但它适用于任何前端JavaScript框架。</p><p id="a164" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">这篇文章主要是关于通过<a class="ae lq" href="https://rxjs-dev.firebaseapp.com/" rel="noopener ugc nofollow" target="_blank"> RxJS </a> JavaScript库使用<a class="ae lq" href="http://reactivex.io/" rel="noopener ugc nofollow" target="_blank">react vex</a>流的反应式编程。</p></div><div class="ab cl lr ls hx lt" role="separator"><span class="lu bw bk lv lw lx"/><span class="lu bw bk lv lw lx"/><span class="lu bw bk lv lw"/></div><div class="im in io ip iq"><h1 id="afa8" class="ly lz it bd ma mb mc md me mf mg mh mi jz mj ka mk kc ml kd mm kf mn kg mo mp bi translated"><strong class="ak">问题</strong></h1><p id="90f0" class="pw-post-body-paragraph ku kv it kw b kx mq ju kz la mr jx lc ld ms lf lg lh mt lj lk ll mu ln lo lp im bi translated">通常，React中的click处理程序(或任何UI事件处理程序)都以某种方式绑定到状态，要么在组件内部，要么在父/子组件中。</p><p id="dd0f" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">我们从文档中学习编写的第一个组件是一个有状态类，它有一个处理程序，可以增加状态值或其他值。这是可行的——毫无疑问——但是既要遵循自顶向下的数据流，又要保留在虚拟DOM范围内而不查询文档，这两者之间需要权衡。要记住的事情:</p><ul class=""><li id="83c6" class="mv mw it kw b kx ky la lb ld mx lh my ll mz lp na nb nc nd bi translated">调和:对于UI事件来说，所有的不同真的值得吗？这对低CPU设备有很大的影响。如果你的应用程序需要一个平滑、复杂的用户界面，你就有因此而阻塞用户界面的风险。</li><li id="35fe" class="mv mw it kw b kx ne la nf ld ng lh nh ll ni lp na nb nc nd bi translated"><strong class="kw iu">有状态UI组件:</strong>如果你需要基于应用程序另一部分的DOM事件发出请求(后面的例子)，保持关注点的分离将是一个挑战。请记住，我们希望UI组件保持“愚蠢”并且没有业务逻辑。</li><li id="032c" class="mv mw it kw b kx ne la nf ld ng lh nh ll ni lp na nb nc nd bi translated"><strong class="kw iu">道具穿线:</strong>不是世界末日，但是当有很多道具穿线的时候，我们会讨厌它。</li></ul><p id="f525" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">基于上述原因，不建议在基于电视的应用程序中使用React这样的框架。</p><p id="f3ef" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">我最近需要从一个组件中访问innerHTML数据，该组件是组件层次结构中的多个子组件。单击该项时，我需要使用它的值在最外层的父节点中发出请求。像这样:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nj"><img src="../Images/54680f406ce0a1c02b1401b16fce2dc1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*M2HmDF8kGkrdYySmCBDRBg.jpeg"/></div></div></figure><p id="0bbe" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">UI由网络响应的形状决定，网络响应包含对组件类型和数据的引用，因此列表内容和请求本身尽可能与内容无关是很重要的。</p></div><div class="ab cl lr ls hx lt" role="separator"><span class="lu bw bk lv lw lx"/><span class="lu bw bk lv lw lx"/><span class="lu bw bk lv lw"/></div><div class="im in io ip iq"><h1 id="5555" class="ly lz it bd ma mb mc md me mf mg mh mi jz mj ka mk kc ml kd mm kf mn kg mo mp bi translated"><strong class="ak">解决方案:Rx，行为主体</strong></h1><p id="e078" class="pw-post-body-paragraph ku kv it kw b kx mq ju kz la mr jx lc ld ms lf lg lh mt lj lk ll mu ln lo lp im bi translated">在过去一年左右的时间里，我一直在开发基于网络的应用程序，这些程序可以在客厅的电视和游戏机上运行。用户对Netfilx、Hulu和其他服务集的高期望，加上为电视浏览器构建的困难，使其成为一个有趣的挑战，我们已经知道一个对我们的需求极其有效的工具是RxJS。</p><p id="1c80" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">Rx是一种被称为<em class="nk">反应式编程</em>的编程范式的实现，这种编程范式在多种语言中使用——在JavaScript中是RxJS。不管您的前端语言偏好如何，事件驱动的UI可能会变得复杂，并且达到这样一种程度，即在事件发生时响应事件的流思维比事件发生时的状态变化更容易处理。</p><p id="be0e" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">这里的想法是存储对所选DOM元素值的引用，并在应用程序的其他部分访问它(但不限于UI)。我们希望订阅由这个存储机制发出的值，并在用户选择新值时更新它们。实施很简单，由以下步骤组成:</p><ul class=""><li id="68fc" class="mv mw it kw b kx ky la lb ld mx lh my ll mz lp na nb nc nd bi translated">用默认值创建一个新的<code class="fe nl nm nn no b">BehaviorSubject</code>(我们将在其他组件中订阅的存储)</li><li id="cd57" class="mv mw it kw b kx ne la nf ld ng lh nh ll ni lp na nb nc nd bi translated">创建更新订阅的方法</li><li id="2407" class="mv mw it kw b kx ne la nf ld ng lh nh ll ni lp na nb nc nd bi translated">实现点击处理程序</li><li id="e7bf" class="mv mw it kw b kx ne la nf ld ng lh nh ll ni lp na nb nc nd bi translated">订阅<code class="fe nl nm nn no b">BehaviorSubject</code>以获取最新发出的值</li></ul><p id="c808" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">代码按顺序如下所示:</p><pre class="kj kk kl km gt np no nq nr aw ns bi"><span id="997b" class="nt lz it no b gy nu nv l nw nx">// 1: create the BehaviorSubject</span><span id="c409" class="nt lz it no b gy ny nv l nw nx"><em class="nk">export </em>const<em class="nk"> featuredCategory$ </em>=<em class="nk"> </em>new<em class="nk"> BehaviorSubject</em>("")<em class="nk">.pipe</em>(<br/>  <em class="nk">distinctUntilChanged</em>(),<br/>  <em class="nk">skip</em>(1)<br/>);</span><span id="1ceb" class="nt lz it no b gy ny nv l nw nx">// 2: create a method to update the BehaviorSubject</span><span id="545a" class="nt lz it no b gy ny nv l nw nx">const<em class="nk"> setfeaturedCategory </em>=<em class="nk"> </em>(category:<em class="nk"> string</em>):<em class="nk"> void </em>=&gt; <em class="nk">featuredCategory$.next</em>(<em class="nk">index</em>);</span></pre><p id="4ed7" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">我们现在可以使用<code class="fe nl nm nn no b">BehaviorSubject</code>来订阅和更新:</p><pre class="kj kk kl km gt np no nq nr aw ns bi"><span id="03fa" class="nt lz it no b gy nu nv l nw nx">// 3: Implement the click handler</span><span id="7574" class="nt lz it no b gy ny nv l nw nx">&lt;li <em class="nk">onClick</em>={(category): void =&gt; <em class="nk">setfeaturedCategory</em>(category)}&gt;{category}&lt;/li&gt;</span><span id="397c" class="nt lz it no b gy ny nv l nw nx">// 4: Subscribe to the behaviorSubject to get the latest emitted value</span><span id="b69f" class="nt lz it no b gy ny nv l nw nx">&lt;=== Anywhere in our app ===&gt;</span><span id="60ee" class="nt lz it no b gy ny nv l nw nx"><em class="nk">import</em> { featuredCategory$ } <em class="nk">from </em>"component";</span><span id="42b8" class="nt lz it no b gy ny nv l nw nx">featuredCategory$.subscribe((category: string): void =&gt; this.setState({ selectedCategory: category }))</span></pre><p id="544f" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">如您所见，我们现在更简单地读取我们的状态。下面是使用这种方法的一些优点。</p><ul class=""><li id="81ed" class="mv mw it kw b kx ky la lb ld mx lh my ll mz lp na nb nc nd bi translated"><strong class="kw iu"> Composition: </strong>因为Rx都是关于流的，所以如果我需要的话，很容易将它们与其他流结合使用。</li><li id="1a9e" class="mv mw it kw b kx ne la nf ld ng lh nh ll ni lp na nb nc nd bi translated"><strong class="kw iu">灵活性:</strong> RxJS附带了许多方法，我可以根据需要使用这些方法来操作我的流——例如，如果我需要在第一次页面加载时延迟发出值的发出。</li><li id="c1d5" class="mv mw it kw b kx ne la nf ld ng lh nh ll ni lp na nb nc nd bi translated"><strong class="kw iu">控制:</strong>如果我想在满足某个条件后停止监听值的变化，我所要做的就是取消订阅。</li></ul><pre class="kj kk kl km gt np no nq nr aw ns bi"><span id="2fa8" class="nt lz it no b gy nu nv l nw nx">featuredCategory$.unsubscribe();</span></pre><p id="d537" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">很酷，是吧？我们只是刚刚开始接触这个强大工具的皮毛。我想过分享这个妙招，以防你发现自己处于类似的情况。希望有帮助！</p></div></div>    
</body>
</html>