<html>
<head>
<title>Implement an Email Masking Proof-of-concept Using AWS Simple Email Service (SES) and AWS Rust SDK</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用AWS简单电子邮件服务(SES)和AWS Rust SDK实施电子邮件屏蔽概念验证</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/implementing-an-email-masking-proof-of-concept-using-aws-simple-email-service-ses-and-aws-rust-c6aa34f1e1df?source=collection_archive---------8-----------------------#2022-06-23">https://betterprogramming.pub/implementing-an-email-masking-proof-of-concept-using-aws-simple-email-service-ses-and-aws-rust-c6aa34f1e1df?source=collection_archive---------8-----------------------#2022-06-23</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="b621" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">使用屏蔽阻止电子邮件营销浪潮</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/3874494026d1e7805e1bf5f01d893f27.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*t6eLhQhwXrYIothLxcsozA.jpeg"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">图片来自<a class="ae kv" href="https://pixabay.com/?utm_source=link-attribution&amp;amp;utm_medium=referral&amp;amp;utm_campaign=image&amp;amp;utm_content=1048452" rel="noopener ugc nofollow" target="_blank"> Pixabay </a>的<a class="ae kv" href="https://pixabay.com/users/anne-onyme-1513318/?utm_source=link-attribution&amp;amp;utm_medium=referral&amp;amp;utm_campaign=image&amp;amp;utm_content=1048452" rel="noopener ugc nofollow" target="_blank"> Anne-Onyme </a></p></figure><p id="849c" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这个故事展示了一个概念验证，允许我在订阅邮件列表和注册不重要的帐户时给出一个唯一的电子邮件地址<code class="fe ls lt lu lv b"><em class="lw">anything</em>@mydomain.com</code>。<code class="fe ls lt lu lv b">anything</code>可以是我给出地址时当场决定的任何词。这些电子邮件会被转发到我的正常电子邮件地址，如果我发现我收到太多邮件，我可以取消订阅并将该地址列入黑名单…</p><p id="541f" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">作为一个额外的好处，我现在在网站注册时使用不同的密码<strong class="ky ir">和</strong>电子邮件地址……这应该会让我更安全。</p><p id="e921" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这个故事中表达的观点/意见是我自己的。这个故事与我的个人经历和选择有关，提供它是希望它有用，但没有任何担保。</p></div><div class="ab cl lx ly hu lz" role="separator"><span class="ma bw bk mb mc md"/><span class="ma bw bk mb mc md"/><span class="ma bw bk mb mc"/></div><div class="ij ik il im in"><p id="37a0" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我喜欢订阅新闻、论坛等。但是，我已经被pwn了…我不读大多数电子邮件——只是随便浏览一下主题，看看是否有任何东西引起我的兴趣……我可以退订，但我有这样的印象，这些电子邮件只是不断到来。我最近开始使用一个全新的电子邮件地址——我想保持干净，因此一直在寻找一种方法来控制我给谁这个电子邮件地址。</p><p id="b23d" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">一个黑客新闻帖子[1]让我进入了电子邮件屏蔽。Google让我看到了AWS的博客文章(将收到的电子邮件转发到外部目的地[2])和这个实现。</p><h2 id="5dd8" class="me mf iq bd mg mh mi dn mj mk ml dp mm lf mn mo mp lj mq mr ms ln mt mu mv mw bi translated">AWS基础设施图</h2><p id="16b1" class="pw-post-body-paragraph kw kx iq ky b kz mx jr lb lc my ju le lf mz lh li lj na ll lm ln nb lp lq lr ij bi translated">下图显示了在实施电子邮件屏蔽服务时使用的AWS基础设施，即接收和存储电子邮件，检查地址并在适当时转发。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nc"><img src="../Images/12336b4d82e3b6429b0819447c281391.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*XL2lOrezpKuUDbaZ3V9DGg.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">AWS基础设施图</p></figure><p id="143b" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">AWS基础设施包括:</p><ul class=""><li id="1ca5" class="nd ne iq ky b kz la lc ld lf nf lj ng ln nh lr ni nj nk nl bi translated">route53记录，用于将传入邮件定向到SES服务；</li><li id="1a99" class="nd ne iq ky b kz nm lc nn lf no lj np ln nq lr ni nj nk nl bi translated">SES规则处理发往<code class="fe ls lt lu lv b">anything@mydomain.com</code>的电子邮件，将它们保存到S3并调用lambda函数；</li><li id="90a6" class="nd ne iq ky b kz nm lc nn lf no lj np ln nq lr ni nj nk nl bi translated">一个lambda函数，处理收到的电子邮件，如果收到的电子邮件地址<code class="fe ls lt lu lv b">anything@mydomain.com</code>不在黑名单上，它会转发到我的正常电子邮件<code class="fe ls lt lu lv b">myemail@anotherdomain.com</code>。</li></ul><p id="c36d" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我个人使用terraform来管理AWS基础设施，但人们可以通过控制台轻松地创建它——它与[2]中描述的基础设施相同——或者使用任何其他基础设施即代码工具。</p><p id="dd44" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">terraform脚本的主要元素如下:</p><ul class=""><li id="b08a" class="nd ne iq ky b kz la lc ld lf nf lj ng ln nh lr ni nj nk nl bi translated">SES规则:下面的脚本设置了一个SES规则，用于处理地址为<code class="fe ls lt lu lv b">@mydomain.com</code>的任何传入电子邮件。该规则有两个操作。第一个操作将电子邮件保存到S3存储桶<code class="fe ls lt lu lv b">aws_s3_bucket.x.id</code> —这个存储桶是使用<code class="fe ls lt lu lv b">aws_s3_bucket</code>资源创建的，重要的是，对该存储桶应用了一个策略，允许来自SES的写操作，也称为<code class="fe ls lt lu lv b">PutObject</code>操作。第二个动作触发λ函数<code class="fe ls lt lu lv b">aws_lambda_function.x.arn</code>。该规则被分配给使用<code class="fe ls lt lu lv b">aws_ses_receipt_rule_set</code>资源定义的规则集<code class="fe ls lt lu lv b">aws_ses_receipt_rule_set.mail.id</code>。</li></ul><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nr ns l"/></div></figure><ul class=""><li id="1436" class="nd ne iq ky b kz la lc ld lf nf lj ng ln nh lr ni nj nk nl bi translated">Lambda函数:lambda函数是用一个提供的运行时来定义的——即函数是一个自包含的可执行文件，没有依赖关系，如[3]中所述。最大内存使用量设置为128MB，运行时间为5s，这对于我的使用来说已经足够了。当我使用AWS命令行界面部署可执行文件时，这个函数用一个空的zip文件初始化。</li></ul><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nr ns l"/></div></figure><p id="4cdb" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">要让SES规则和lambda发挥作用，需要设置权限:</p><ul class=""><li id="bc91" class="nd ne iq ky b kz la lc ld lf nf lj ng ln nh lr ni nj nk nl bi translated">定义了允许SES服务调用lambda函数的资源——我试图使用源arn条目来指定SES调用者，但是这种方法导致了循环引用。</li></ul><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nr ns l"/></div></figure><ul class=""><li id="a281" class="nd ne iq ky b kz la lc ld lf nf lj ng ln nh lr ni nj nk nl bi translated">使用策略定义lambda函数使用的角色，该策略允许lambda函数读取S3存储桶并使用AWS SES服务发送电子邮件。该角色还允许lambda函数为CloudWatch写日志。</li></ul><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nr ns l"/></div></figure><h2 id="310c" class="me mf iq bd mg mh mi dn mj mk ml dp mm lf mn mo mp lj mq mr ms ln mt mu mv mw bi translated">λ函数</h2><p id="7fbc" class="pw-post-body-paragraph kw kx iq ky b kz mx jr lb lc my ju le lf mz lh li lj na ll lm ln nb lp lq lr ij bi translated">我选择使用Rust Runtime for AWS [3]和AWS SDK for Rust [4]在Rust中编写lambda函数——目前在开发者预览版中。该实现与[2]中的python实现非常相似，只是我想(a)对照黑名单检查电子邮件地址，以及(b)转发电子邮件内容，而不是从S3桶访问电子邮件的链接。</p><p id="0a92" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">安装<code class="fe ls lt lu lv b">rust</code>后，使用<code class="fe ls lt lu lv b">cargo new ses_handler</code>创建一个新的二进制应用程序。以下依赖关系被添加到<code class="fe ls lt lu lv b">Cargo.toml</code>:</p><ul class=""><li id="d0f5" class="nd ne iq ky b kz la lc ld lf nf lj ng ln nh lr ni nj nk nl bi translated"><code class="fe ls lt lu lv b">lambda_runtime</code> —在Rust中编写AWS lambda函数所需的胶水；</li><li id="fb96" class="nd ne iq ky b kz nm lc nn lf no lj np ln nq lr ni nj nk nl bi translated"><code class="fe ls lt lu lv b">aws-types</code>、<code class="fe ls lt lu lv b">aws-config</code>、<code class="fe ls lt lu lv b">aws-sdk-ses</code>和<code class="fe ls lt lu lv b">aws-sdk-s3</code>—Rust SDK的组件，用于访问SES和S3服务；</li><li id="5fe5" class="nd ne iq ky b kz nm lc nn lf no lj np ln nq lr ni nj nk nl bi translated">解析SES收到并保存到S3的电子邮件。有许多可用的库——我开始使用这个库，因为它运行得令人满意，所以我没有研究任何其他的库。</li></ul><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nr ns l"/></div></figure><p id="5ff8" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">实施是围绕以下3个Rust结构构建的:</p><ul class=""><li id="2b94" class="nd ne iq ky b kz la lc ld lf nf lj ng ln nh lr ni nj nk nl bi translated"><code class="fe ls lt lu lv b">SesEvent</code>结构将SES事件映射到一个对象，该对象标识电子邮件ID、发件人、主题和目的地列表。该结构及其构造方法如下所示。该构造方法与SES传入电子邮件事件格式[5]紧密耦合，后者作为<code class="fe ls lt lu lv b">from_json</code>方法参数<code class="fe ls lt lu lv b">payload</code>提供。</li></ul><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nr ns l"/></div></figure><ul class=""><li id="4321" class="nd ne iq ky b kz la lc ld lf nf lj ng ln nh lr ni nj nk nl bi translated"><code class="fe ls lt lu lv b">Address</code>结构存储转发邮件时lambda函数使用的字段——<code class="fe ls lt lu lv b">from</code>字段用于存储邮件最初发送到的电子邮件地址，即<code class="fe ls lt lu lv b">anything@mydomain.com</code>。这被用作转发的电子邮件的发起者。<code class="fe ls lt lu lv b">key</code>字段存储电子邮件地址密钥，即<code class="fe ls lt lu lv b">anything</code>。</li></ul><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nr ns l"/></div></figure><ul class=""><li id="1f20" class="nd ne iq ky b kz la lc ld lf nf lj ng ln nh lr ni nj nk nl bi translated">从电子邮件地址<code class="fe ls lt lu lv b">anything@mydomain.com</code>构建<code class="fe ls lt lu lv b">Address</code>结构的实例。<code class="fe ls lt lu lv b">key</code>用于决定邮件是否转发，如下图所示。对于没有被转发的<code class="fe ls lt lu lv b">key</code>，该方法返回一个<code class="fe ls lt lu lv b">None</code>选项。</li></ul><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nr ns l"/></div></figure><ul class=""><li id="013f" class="nd ne iq ky b kz la lc ld lf nf lj ng ln nh lr ni nj nk nl bi translated">上述方法用于以下方法，该方法将SES事件目的地转换为地址列表:</li></ul><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nr ns l"/></div></figure><ul class=""><li id="ce43" class="nd ne iq ky b kz la lc ld lf nf lj ng ln nh lr ni nj nk nl bi translated">最后一个结构<code class="fe ls lt lu lv b">Mail</code>负责从S3桶中读取电子邮件、解析它、创建要转发的电子邮件(只转发邮件的文本和html部分，没有附件)并发送它。<code class="fe ls lt lu lv b">Mail</code>结构由<code class="fe ls lt lu lv b">message_id</code>定义，即SES事件给出的电子邮件标识符。其他字段<code class="fe ls lt lu lv b">config</code>、<code class="fe ls lt lu lv b">client</code>和<code class="fe ls lt lu lv b">message</code>允许在一条消息要发送多次的情况下缓存信息——如果该电子邮件是具有不同<code class="fe ls lt lu lv b">@mydomain.com</code>地址的邮件列表的一部分，这是一种边缘情况。</li></ul><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nr ns l"/></div></figure><ul class=""><li id="4693" class="nd ne iq ky b kz la lc ld lf nf lj ng ln nh lr ni nj nk nl bi translated">电子邮件解析由以下函数处理，该函数提取电子邮件的主题、纯文本和HTML组件:</li></ul><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nr ns l"/></div></figure><ul class=""><li id="1b9f" class="nd ne iq ky b kz la lc ld lf nf lj ng ln nh lr ni nj nk nl bi translated"><code class="fe ls lt lu lv b">Mail</code>结构的<code class="fe ls lt lu lv b">send</code>功能的实现是实现中最重要的部分，如下所示。实现相当清晰和直接:(a)初始化AWS配置，(b)从S3桶中读取传入消息，(c)从传入消息的纯文本和HTML内容中创建SES消息，(d)初始化SES客户端，以及(e)在…上发送消息</li></ul><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nr ns l"/></div></figure><p id="e8bb" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">使用上述结构，main函数采用以下形式，其中传入事件被处理成一个<code class="fe ls lt lu lv b">SesEvent</code>对象。</p><p id="35f9" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><code class="fe ls lt lu lv b">SesEvent</code>消息id用于创建<code class="fe ls lt lu lv b">Mail</code>对象，而<code class="fe ls lt lu lv b">SesEvent</code>目的地列表被转换为<code class="fe ls lt lu lv b">Address</code>，用于调用<code class="fe ls lt lu lv b">Mail</code>对象的<code class="fe ls lt lu lv b">send</code>方法。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nr ns l"/></div></figure><h1 id="d149" class="nt mf iq bd mg nu nv nw mj nx ny nz mm jw oa jx mp jz ob ka ms kc oc kd mv od bi translated">结论</h1><p id="67d5" class="pw-post-body-paragraph kw kx iq ky b kz mx jr lb lc my ju le lf mz lh li lj na ll lm ln nb lp lq lr ij bi translated">我已经使用我的<code class="fe ls lt lu lv b">anything@mydomain.com</code>概念验证几个星期了，取得了相当大的成功。但是由于黑名单是硬编码的，我不会经常更新它。虽然还有改进的空间，但尽管我对SES服务不太熟悉，概念验证的实施还是相当顺利。</p><p id="def3" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">AWS Rust SDK可以有效地与AWS SES和S3服务配合使用——尽管还处于开发者预览版。我目前使用它与亚马逊DynamoDB，这是目前证明有点不太稳定。</p><p id="5f5b" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">[1]<a class="ae kv" href="https://news.ycombinator.com/item?id=31116861" rel="noopener ugc nofollow" target="_blank">https://news.ycombinator.com/item?id=31116861</a><br/>【2】<a class="ae kv" href="https://aws.amazon.com/blogs/messaging-and-targeting/forward-incoming-email-to-an-external-destination/" rel="noopener ugc nofollow" target="_blank">https://AWS . Amazon . com/blogs/messaging-and-targeting/forward-incoming-email-to-an-external-destination/</a><br/><a class="ae kv" href="https://aws.amazon.com/blogs/opensource/rust-runtime-for-aws-lambda/" rel="noopener ugc nofollow" target="_blank">https://AWS . Amazon . com/blogs/open source/rust-runtime-for-AWS-lambda/</a><br/>【4】<a class="ae kv" href="https://aws.amazon.com/sdk-for-rust/" rel="noopener ugc nofollow" target="_blank">https://aws.amazon.com/sdk-for-rust/</a><br/>【5】<a class="ae kv" href="https://docs.aws.amazon.com/ses/latest/dg/receiving-email-action-lambda-event.html" rel="noopener ugc nofollow" target="_blank">https</a></p></div></div>    
</body>
</html>