<html>
<head>
<title>PostgreSQL: Lessons Learned While Optimising Query Performance</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">PostgreSQL:优化查询性能的经验教训</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/postgresql-lessons-learned-while-optimising-query-performance-56e1652ecd86?source=collection_archive---------5-----------------------#2022-03-14">https://betterprogramming.pub/postgresql-lessons-learned-while-optimising-query-performance-56e1652ecd86?source=collection_archive---------5-----------------------#2022-03-14</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="3aab" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">让您的结果快很多倍</h2></div><p id="67c3" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在过去的一年中，我学到了很多关于如何优化PostgreSQL性能的知识，在这篇文章中，我想分享一些关于如何充分利用我们的数据库的重要知识。</p><p id="f36d" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">您的团队或客户是否向您询问过为什么产品的应用程序运行缓慢？很可能你有😅。</p><p id="a358" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">以我的经验来看，</p><pre class="lb lc ld le gt lf lg lh li aw lj bi"><span id="7af0" class="lk ll iq lg b gy lm ln l lo lp">Database Performance == Application Performance</span></pre><h1 id="1ded" class="lq ll iq bd lr ls lt lu lv lw lx ly lz jw ma jx mb jz mc ka md kc me kd mf mg bi translated">头号问题是缺少索引</h1><p id="1531" class="pw-post-body-paragraph kf kg iq kh b ki mh jr kk kl mi ju kn ko mj kq kr ks mk ku kv kw ml ky kz la ij bi translated">导致数据库性能问题的最常见错误是:( 1)查询缺少索引，或者(2)为查询创建的索引没有被利用。</p><p id="5fa4" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">让我们考虑一个存储关于艺术家、他们的曲目和他们各自专辑的数据的数据库。</p><figure class="lb lc ld le gt mn gh gi paragraph-image"><div role="button" tabindex="0" class="mo mp di mq bf mr"><div class="gh gi mm"><img src="../Images/83a3f332362cd260214f8a69feb1eaf6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*8bv0mTd-XD06zZVO3yFHnQ.jpeg"/></div></div></figure><p id="d80d" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如果我想用<code class="fe mu mv mw lg b">Name = Levitating</code>查询一个音轨，我将使用下面的查询:</p><pre class="lb lc ld le gt lf lg lh li aw lj bi"><span id="f147" class="lk ll iq lg b gy lm ln l lo lp">SELECT * FROM Track WHERE Name='Levitating';</span></pre><p id="89ee" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">数据库中的数据以数据页的形式存储在磁盘上。这些页面的结构类似于链表，因为它们包含一个数据部分和另一个指向下一个块的指针部分。这些块不需要以连续的顺序存储。</p><figure class="lb lc ld le gt mn gh gi paragraph-image"><div class="gh gi mx"><img src="../Images/474ea28f6bb81a6c3bf41fdd2fd4d40a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1324/format:webp/1*GmJFJjhThj4nGFHOYA8iaA.jpeg"/></div><p class="my mz gj gh gi na nb bd b be z dk translated">表格是一系列页面</p></figure><figure class="lb lc ld le gt mn gh gi paragraph-image"><div role="button" tabindex="0" class="mo mp di mq bf mr"><div class="gh gi nc"><img src="../Images/d285a9c071ec00e0fc677e474e3a53ec.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*3PHTnLpJUo3S1P4F6AnvQg.jpeg"/></div></div><p class="my mz gj gh gi na nb bd b be z dk translated">页面构成</p></figure><p id="b181" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><em class="nd">当记录变得太大而无法存储在一个块中时，PostgreSQL会将它存储在一个</em> <code class="fe mu mv mw lg b"><em class="nd">TOAST</em></code> <em class="nd">表中。记录将被分割成块，因此主表(也称为堆)将包含一个指针，指向</em> <code class="fe mu mv mw lg b"><em class="nd">TOAST</em></code> <em class="nd">表中的右块。</em></p><p id="d1d8" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">根据<code class="fe mu mv mw lg b">Track</code>表的模式，<code class="fe mu mv mw lg b">Track</code>的一个块在其数据段中将包含多个字段。事实上，记录只能在一个字段中排序，搜索像<code class="fe mu mv mw lg b">Name</code>这样不是主键的字段，因为<code class="fe mu mv mw lg b">Name</code>是一个非唯一字段，因此默认情况下不排序，搜索<code class="fe mu mv mw lg b">Name</code>将需要全表扫描。</p><p id="0a6e" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这意味着使用上面的查询找到带有<code class="fe mu mv mw lg b">Name=’Levitating’</code>的轨道，所有大约1亿行将必须被扫描。这太疯狂了。将花费几秒钟来得到结果，并且这是对计算资源的不良使用，并且对环境🥲是不利的</p><h2 id="0ee8" class="lk ll iq bd lr ne nf dn lv ng nh dp lz ko ni nj mb ks nk nl md kw nm nn mf no bi translated"><strong class="ak">如何提高上述查询的性能？输入索引。</strong></h2><p id="fa52" class="pw-post-body-paragraph kf kg iq kh b ki mh jr kk kl mi ju kn ko mj kq kr ks mk ku kv kw ml ky kz la ij bi translated">索引是一种数据结构，它通过提供指向所请求记录的数据库客户机指针来实现更快的数据查询。一旦知道了记录的位置，就可以通过查找准确的内存地址来快速获取数据。</p><p id="2338" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><em class="nd">底层查询协议允许数据库客户端批量获取结果，而不是一次获取全部结果。</em></p><p id="f5c1" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">让我们通过执行以下查询在<code class="fe mu mv mw lg b">Track</code>表的<code class="fe mu mv mw lg b">Name</code>字段上创建一个索引:</p><pre class="lb lc ld le gt lf lg lh li aw lj bi"><span id="be73" class="lk ll iq lg b gy lm ln l lo lp">CREATE INDEX CONCURRENTLY ON Track Using btree (Name);</span></pre><p id="a66c" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">索引被实现为B树。在剖析上面的查询之前，我将让您对B树有一个深入的了解。</p><p id="c23d" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">b树是为在磁盘上存储数据而创建的结构，其中访问一个存储位置需要大约5毫秒，因此，数据局部性是其设计的一个重要方面，允许在每个树节点中存储多个值。</p><p id="27a4" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">由于B树的分支因子很高，只需很少的磁盘读取操作就可以到达存储数据的目标位置。</p><p id="7ae3" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">具有<code class="fe mu mv mw lg b">m</code>值的B树节点将有多达<code class="fe mu mv mw lg b">m+1</code>个指向子节点的指针。每个指针指向包含其两个父节点之间的值的子树。</p><figure class="lb lc ld le gt mn gh gi paragraph-image"><div role="button" tabindex="0" class="mo mp di mq bf mr"><div class="gh gi nc"><img src="../Images/8232e85a4260d9a3e2cf3da674ca1148.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*-Vpxzvn12XQNWOWsSeZd5A.jpeg"/></div></div><p class="my mz gj gh gi na nb bd b be z dk translated">分支因子为3的b树</p></figure><p id="7def" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在上面的B树中:</p><ol class=""><li id="3769" class="np nq iq kh b ki kj kl km ko nr ks ns kw nt la nu nv nw nx bi translated">第一个指针指向值小于10的子节点</li><li id="9a6b" class="np nq iq kh b ki ny kl nz ko oa ks ob kw oc la nu nv nw nx bi translated">第二个指针指向一个值在(10，20)之间的子节点</li><li id="01a3" class="np nq iq kh b ki ny kl nz ko oa ks ob kw oc la nu nv nw nx bi translated">第三个指针指向值大于20的子节点</li></ol><p id="ad3b" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如果我想将值<code class="fe mu mv mw lg b">5</code>添加到B树中，将会对根节点的第一个子节点进行拆分，生成的树将转换为下面的树:</p><figure class="lb lc ld le gt mn gh gi paragraph-image"><div role="button" tabindex="0" class="mo mp di mq bf mr"><div class="gh gi od"><img src="../Images/d0e25e34ffd06c93863885377f21b67e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*wHLP7Q1ihC9lbBkOp_jrPg.jpeg"/></div></div><p class="my mz gj gh gi na nb bd b be z dk translated">分支因子为4的b树</p></figure><p id="62f1" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">拆分会将子对象的中间值插入到父对象中。这意味着分割也会重新平衡树。</p><p id="c5d1" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在上面的B树中，插入<code class="fe mu mv mw lg b">5</code>会导致拆分，将子节点的中间值移动到父节点中，重新平衡会引入一个新的子节点。</p><p id="112e" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这确保了二叉树的最大深度将是<code class="fe mu mv mw lg b">log(m/2)n</code>，其中<code class="fe mu mv mw lg b">m</code>是分支因子，<code class="fe mu mv mw lg b">n</code>是树中值的数量。</p><p id="e698" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">关于B树需要注意的要点是:</p><ol class=""><li id="72e4" class="np nq iq kh b ki kj kl km ko nr ks ns kw nt la nu nv nw nx bi translated">搜索、插入和删除等操作具有对数时间复杂度。</li><li id="2859" class="np nq iq kh b ki ny kl nz ko oa ks ob kw oc la nu nv nw nx bi translated">b树是非常浅的数据结构。具有数千分支因子的B树意味着它们可以在仅仅两到三层中存储数百万个元素。</li></ol><p id="b38f" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><em class="nd">一旦创建了列的索引，如果索引的</em> <code class="fe mu mv mw lg b"><em class="nd">operator class</em></code> <em class="nd">包含查询中与列一起使用的运算符，则</em> <a class="ae oe" href="https://www.postgresql.org/docs/9.5/planner-optimizer.html" rel="noopener ugc nofollow" target="_blank"> <em class="nd">查询计划器</em> </a> <em class="nd">将使用使用索引列的表上的任何查询，以创建最佳的查询执行计划。</em></p><p id="a312" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">执行相同的查询，以获得一个跟踪，其中<code class="fe mu mv mw lg b">Name=’Levitating’</code>将再次在毫秒内产生结果，因为查询规划器将使用索引，并且只需两到三次磁盘读取就能够找到所需数据的位置。这种情况下使用的扫描将是索引扫描。</p><p id="2258" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">像生活中所有美好的事物一样，指数也是有代价的。虽然它们提高了速度，但需要空间来存储索引。这个空间可能从兆字节到千兆字节不等，有时取决于被索引的数据量。</p><p id="36ab" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">您可以在多个字段上创建索引，也称为复合索引，并且可以在同一个表上创建多个索引，这取决于该表上所需的各种类型的查询。</p><p id="0136" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">因此，需要特别注意了解如何在数据库上执行查询，以及我们创建的索引是否被利用。</p><p id="d492" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">创建索引时需要考虑几个非常重要的问题:</p><ol class=""><li id="c40a" class="np nq iq kh b ki kj kl km ko nr ks ns kw nt la nu nv nw nx bi translated">当且仅当查询的<code class="fe mu mv mw lg b">WHERE</code>子句至少包含索引最左边的列时，查询才会使用复合索引。</li><li id="bedd" class="np nq iq kh b ki ny kl nz ko oa ks ob kw oc la nu nv nw nx bi translated">不必为表中的所有行创建索引，可以为行的子集创建索引。这在空间和时间复杂性方面有真正的好处。</li><li id="0e4e" class="np nq iq kh b ki ny kl nz ko oa ks ob kw oc la nu nv nw nx bi translated"><code class="fe mu mv mw lg b">CREATE INDEX CONCURRENTLY ON Track Using btree (Name) WHERE ArtistId In (ArtistId1, ArtistId2, ...);<br/></code>使用上面的命令，我们告诉PostgreSQL只为<code class="fe mu mv mw lg b">ArtistId</code>是<code class="fe mu mv mw lg b">(ArtistId1, ArtistId2, ...)</code>之一的行创建一个索引</li></ol><p id="d71e" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><em class="nd">关于</em> <code class="fe mu mv mw lg b"><em class="nd">CONCURRENTLY</em></code> <em class="nd">的说明用于</em> <code class="fe mu mv mw lg b"><em class="nd">CREATE INDEX</em></code> <em class="nd">命令</em></p><p id="d878" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><em class="nd">当一个表被索引时，PostgreSQL锁定该表以防写入。读取操作仍然可以执行，但是写入、更新或删除操作会被阻止。在生产环境中，可能不希望出现这种情况，因为在生产环境中，为大型表编制索引可能需要几个小时。</em></p><p id="8e38" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><em class="nd">当使用</em> <code class="fe mu mv mw lg b"><em class="nd">CONCURRENTLY</em></code> <em class="nd">时，写操作不会被阻塞，PostgreSQL将等待此类事务完成。由于允许继续正常操作，构建索引的时间也会随着数据库服务器的CPU和内存利用率的增加而增加。</em></p><h1 id="b693" class="lq ll iq bd lr ls lt lu lv lw lx ly lz jw ma jx mb jz mc ka md kc me kd mf mg bi translated">第二个问题是不知道数据库中发生了什么</h1><p id="ee23" class="pw-post-body-paragraph kf kg iq kh b ki mh jr kk kl mi ju kn ko mj kq kr ks mk ku kv kw ml ky kz la ij bi translated">假设我们想找出数据库中运行速度最慢的三个查询。我们该怎么做呢？</p><h2 id="c9b5" class="lk ll iq bd lr ne nf dn lv ng nh dp lz ko ni nj mb ks nk nl md kw nm nn mf no bi translated">1.查找昂贵的查询</h2><pre class="lb lc ld le gt lf lg lh li aw lj bi"><span id="f0af" class="lk ll iq lg b gy lm ln l lo lp">SELECT queryid, calls, mean_time, substring(query for 100)<br/>FROM pg_stat_statements <br/>ORDER BY total_time DESC LIMIT 3;</span></pre><p id="ab33" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这将为我们提供三个最昂贵的查询列表:</p><pre class="lb lc ld le gt lf lg lh li aw lj bi"><span id="0a00" class="lk ll iq lg b gy lm ln l lo lp">| query_id   | calls | mean_time | substring |<br/>|------------|-------|-----------|-----------|<br/>| 1819595255 | 18000 | 500.12    | Query 1   |<br/>| 10013512   | 100   | 273.25    | Query 2   |<br/>| 50123753   | 3000  | 252.37    | Query 3   |</span></pre><h2 id="0cdf" class="lk ll iq bd lr ne nf dn lv ng nh dp lz ko ni nj mb ks nk nl md kw nm nn mf no bi translated">2.分析昂贵的查询</h2><p id="ea12" class="pw-post-body-paragraph kf kg iq kh b ki mh jr kk kl mi ju kn ko mj kq kr ks mk ku kv kw ml ky kz la ij bi translated">下一步是分析昂贵的查询，并理解查询规划器是如何执行它们的。</p><pre class="lb lc ld le gt lf lg lh li aw lj bi"><span id="313e" class="lk ll iq lg b gy lm ln l lo lp">EXPLAIN SELECT * FROM Album WHERE Name = 'Favourite Worst Nightmare';<br/>                         QUERY PLAN                                          <br/>------------------------------------------------------------<br/>Seq Scan on Album (cost=0.00..169375.85 rows=10000000 width=32) Filter: (Name = 'Favourite Worst Nightmare'::text)</span></pre><p id="4551" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><code class="fe mu mv mw lg b">EXPLAIN</code>提供查询规划器为给定查询生成的执行计划。执行计划显示了如何扫描查询所引用的表。</p><blockquote class="of og oh"><p id="1505" class="kf kg nd kh b ki kj jr kk kl km ju kn oi kp kq kr oj kt ku kv ok kx ky kz la ij bi translated"><em class="iq">PostgreSQL使用多种扫描策略:</em></p><p id="73c8" class="kf kg nd kh b ki kj jr kk kl km ju kn oi kp kq kr oj kt ku kv ok kx ky kz la ij bi translated"><em class="iq">顺序扫描—顺序扫描表格的所有页面。它基本上是一个线性搜索。顺序扫描在两种情况下发生:</em></p><p id="6ea6" class="kf kg nd kh b ki kj jr kk kl km ju kn oi kp kq kr oj kt ku kv ok kx ky kz la ij bi translated">1.<code class="fe mu mv mw lg b">WHERE</code>子句中的键没有可用的索引</p><p id="98f2" class="kf kg nd kh b ki kj jr kk kl km ju kn oi kp kq kr oj kt ku kv ok kx ky kz la ij bi translated">2.大多数行将作为查询结果的一部分返回</p><p id="6d0b" class="kf kg nd kh b ki kj jr kk kl km ju kn oi kp kq kr oj kt ku kv ok kx ky kz la ij bi translated"><em class="iq">索引扫描—这是一个两步扫描。第一步是从索引中查询数据。该索引返回</em><a class="ae oe" href="https://www.postgresql.org/docs/9.3/datatype-oid.html" rel="noopener ugc nofollow" target="_blank"><em class="iq"/></a><em class="iq">主表或堆中的数据。第2步是直接访问堆页以获得全部数据。</em></p><p id="4640" class="kf kg nd kh b ki kj jr kk kl km ju kn oi kp kq kr oj kt ku kv ok kx ky kz la ij bi translated"><em class="iq">步骤2是必需的，因为查询可能请求获取比索引中可用的更多的列。</em></p><p id="a1ab" class="kf kg nd kh b ki kj jr kk kl km ju kn oi kp kq kr oj kt ku kv ok kx ky kz la ij bi translated"><em class="iq">仅索引扫描——这与索引扫描相似，只是不需要步骤2，所有数据都从索引中提取。这是最快的扫描了。必须满足几个条件，查询规划器才能选择仅索引扫描。你可以在</em> <a class="ae oe" href="https://www.postgresql.org/docs/10/indexes-index-only-scans.html" rel="noopener ugc nofollow" target="_blank"> <em class="iq">维基</em> </a> <em class="iq">中读到关于它的一切。</em></p><p id="a6de" class="kf kg nd kh b ki kj jr kk kl km ju kn oi kp kq kr oj kt ku kv ok kx ky kz la ij bi translated">还有另外两种类型的扫描策略，它们需要额外的上下文来解释，也许我以后会写一篇关于它们的文章。一种是位图扫描，另一种是TID扫描。</p></blockquote><p id="165f" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">使用没有任何选项的<code class="fe mu mv mw lg b">EXPLAIN</code>没有多大帮助；它不执行查询，只显示如何执行查询的计划。</p><p id="d977" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><code class="fe mu mv mw lg b">EXPLAIN</code>与<code class="fe mu mv mw lg b">ANALYZE</code>一起使用时，将实际运行查询并显示计划和执行查询所花费的时间。在确定查询性能和瓶颈时，这些信息是非常宝贵的。</p><p id="33a8" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">让我们看看在创建了<code class="fe mu mv mw lg b">Name</code>上的索引后，第一次执行查询时<code class="fe mu mv mw lg b">EXPLAIN ANALYZE</code>的输出:</p><pre class="lb lc ld le gt lf lg lh li aw lj bi"><span id="58a2" class="lk ll iq lg b gy lm ln l lo lp">EXPLAIN ANALYZE SELECT * FROM Track WHERE Name='Levitating';</span><span id="1e44" class="lk ll iq lg b gy ol ln l lo lp">                         QUERY PLAN                                          <br/>---------------------------------------------------------------</span><span id="1c66" class="lk ll iq lg b gy ol ln l lo lp">Index Scan using idx_name on Track  (cost=0.00..32.97 rows=1 width=64) (actual time=0.352..0.357 rows=1 loops=1)<br/>        Index Cond: (Name='Levitating')<br/>Planning Time: 3.011 ms<br/>Execution Time: 0.379 ms</span></pre><p id="afab" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">查询计划表明所使用的扫描策略是索引扫描，这是有意义的，因为我们要求的是该行中可能不在索引中的所有列。</p><p id="ed94" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><code class="fe mu mv mw lg b">actual time=0.352..0.357</code>表示访问第一行花费的时间和读取所有行花费的时间。</p><p id="4027" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在我看来，读取<code class="fe mu mv mw lg b">EXPLAIN ANALYZE</code>的输出对于简单的查询来说是可以的，但是对于复杂的查询来说就变得困难了。我遇到了一个叫做<a class="ae oe" href="http://explain.depesz.com/" rel="noopener ugc nofollow" target="_blank">explain.depesz.com</a>的工具，它通过将输出分解成组件来简化输出，并为查询执行的每个阶段提供统计数据。</p><p id="4444" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">当您试图在缓慢的查询中找到瓶颈时，我强烈推荐使用该工具。</p><p id="f78b" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">好吧，我就说到这里。我真的很喜欢写这篇文章，也许我会写更多关于数据库的话题，比如:</p><ol class=""><li id="b7ef" class="np nq iq kh b ki kj kl km ko nr ks ns kw nt la nu nv nw nx bi translated">优化涉及连接的PostgreSQL查询</li><li id="4b7d" class="np nq iq kh b ki ny kl nz ko oa ks ob kw oc la nu nv nw nx bi translated">查询优化器如何工作以及查询执行的不同阶段</li><li id="2e0f" class="np nq iq kh b ki ny kl nz ko oa ks ob kw oc la nu nv nw nx bi translated">为什么缓存并不总是解决问题的答案，通常，人们会低估数据库，直接跳到缓存解决方案</li><li id="657c" class="np nq iq kh b ki ny kl nz ko oa ks ob kw oc la nu nv nw nx bi translated">数据库设计的注意事项</li><li id="b527" class="np nq iq kh b ki ny kl nz ko oa ks ob kw oc la nu nv nw nx bi translated">更加</li></ol><p id="5989" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">直到下次👋🏼</p><p id="e84d" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如果你喜欢我的内容，考虑分享它，如果我的帖子增加了你的订阅价值，请考虑订阅我的<a class="ae oe" href="https://ashutoshnarang.substack.com/p/postgresql-improve-query-performance?r=1b65mw&amp;s=w&amp;utm_campaign=post&amp;utm_medium=web" rel="noopener ugc nofollow" target="_blank">时事通讯</a>:)。</p></div></div>    
</body>
</html>