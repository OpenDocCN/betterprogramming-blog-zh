<html>
<head>
<title>Streamline Your GitHub Actions With Composite Actions</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">用复合动作简化GitHub动作</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/streamline-your-github-actions-with-composite-actions-a8ebc6d28f6b?source=collection_archive---------3-----------------------#2021-09-16">https://betterprogramming.pub/streamline-your-github-actions-with-composite-actions-a8ebc6d28f6b?source=collection_archive---------3-----------------------#2021-09-16</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="d98a" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">利用缓存操作和复合操作支持的相关作业，充分利用GitHub操作</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/0873f0f8dbdb295e01a511a5c1dac9b4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*gNzY16SsGJFVOotH"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">准备好让你的GitHub行动更上一层楼了吗？由<a class="ae ky" href="https://unsplash.com/@spacex?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> SpaceX </a>在<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</p></figure><p id="f6bb" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">GitHub博客<a class="ae ky" href="https://github.blog/changelog/2021-08-25-github-actions-reduce-duplication-with-action-composition/" rel="noopener ugc nofollow" target="_blank">发表了一篇文章</a>揭示了减少重复的复合动作。谁不喜欢有个<em class="lv">干</em>码？我在一个类似真实世界的情况下尝试了一下，看看复合动作带来了多少附加值以及它们的潜在局限性。</p><p id="0e7f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这也是展示我现在喜欢的另外两个GitHub actions概念的机会:</p><ul class=""><li id="9adb" class="lw lx it lb b lc ld lf lg li ly lm lz lq ma lu mb mc md me bi translated"><strong class="lb iu">缓存动作</strong>:仅在必要时安装依赖项。</li><li id="991e" class="lw lx it lb b lc mf lf mg li mh lm mi lq mj lu mb mc md me bi translated"><strong class="lb iu">相关作业</strong>:并行化任务和/或以更精细的粒度分解作业。</li></ul><p id="5d55" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">本文中的示例可以在这个存储库中找到:</p><div class="mk ml gp gr mm mn"><a href="https://github.com/Al-un/ci-github-actions" rel="noopener  ugc nofollow" target="_blank"><div class="mo ab fo"><div class="mp ab mq cl cj mr"><h2 class="bd iu gy z fp ms fr fs mt fu fw is bi translated">GitHub - Al-un/ci-github-actions:了解GitHub操作</h2><div class="mu l"><h3 class="bd b gy z fp ms fr fs mt fu fw dk translated">了解GitHub操作。</h3></div><div class="mv l"><p class="bd b dl z fp ms fr fs mt fu fw dk translated">github.com</p></div></div><div class="mw l"><div class="mx l my mz na mw nb ks mn"/></div></div></a></div><h1 id="d0e9" class="nc nd it bd ne nf ng nh ni nj nk nl nm jz nn ka no kc np kd nq kf nr kg ns nt bi translated">为什么我们需要依赖型工作？</h1><p id="1820" class="pw-post-body-paragraph kz la it lb b lc nu ju le lf nv jx lh li nw lk ll lm nx lo lp lq ny ls lt lu im bi translated">NodeJs项目有周期性的检查，例如林挺、构建和单元测试。使用GitHub actions，设置这一点非常容易:创建一个工作流，其中所有内容都包含在一个作业中。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nz oa l"/></div></figure><p id="0a78" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">以下是一些有用的链接:</p><ul class=""><li id="d136" class="lw lx it lb b lc ld lf lg li ly lm lz lq ma lu mb mc md me bi translated"><code class="fe ob oc od oe b">actions/checkout</code>储存库:<a class="ae ky" href="https://github.com/actions/checkout" rel="noopener ugc nofollow" target="_blank">https://github.com/actions/checkout</a></li><li id="2faf" class="lw lx it lb b lc mf lf mg li mh lm mi lq mj lu mb mc md me bi translated"><code class="fe ob oc od oe b">actions/setup-node</code>储存库:<a class="ae ky" href="https://github.com/actions/setup-node" rel="noopener ugc nofollow" target="_blank">https://github.com/actions/setup-node</a></li></ul><p id="f994" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这个示例可以工作，但是很快会遇到一些限制，如下所示:</p><ul class=""><li id="9428" class="lw lx it lb b lc ld lf lg li ly lm lz lq ma lu mb mc md me bi translated"><strong class="lb iu">无检查并行化</strong>:所有步骤都是连续的，不可能并行化任务。</li><li id="ecb1" class="lw lx it lb b lc mf lf mg li mh lm mi lq mj lu mb mc md me bi translated"><strong class="lb iu">粒度不够</strong>:如果某些检查被标记为需要通过，在GitHub分支保护规则中，需要更细的粒度。</li><li id="d083" class="lw lx it lb b lc mf lf mg li mh lm mi lq mj lu mb mc md me bi translated"><strong class="lb iu">矩阵测试</strong>:如果某些步骤需要设置:<br/>#…初始化步骤…矩阵配置，当只有少数步骤实际需要矩阵配置时，会影响所有步骤。</li></ul><p id="4850" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">为了解决上述问题，需要将这些步骤分解为专门的工作。使用以下代码会有所帮助:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nz oa l"/></div></figure><p id="f2ee" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">所有三个作业将并行执行。这造成了一些冗余，因为林挺、构建和单元测试都需要安装依赖项。</p><p id="21b4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu">注意:</strong>每项工作都需要时间来运转，因此将一些任务组合在一起是有意义的。此外，同步作业有限制，因此将工作流分解为大量并行作业没有实际价值。</p><p id="73c7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">附加作业可以专用于安装和依赖项安装，但必须在其他三个步骤之前运行。这就是依赖型工作的作用。</p><h1 id="cea2" class="nc nd it bd ne nf ng nh ni nj nk nl nm jz nn ka no kc np kd nq kf nr kg ns nt bi translated">如何使用依赖型作业？</h1><p id="1781" class="pw-post-body-paragraph kz la it lb b lc nu ju le lf nv jx lh li nw lk ll lm nx lo lp lq ny ls lt lu im bi translated">从属任务依赖于<code class="fe ob oc od oe b">jobs.&lt;job id&gt;.need</code>参数(<a class="ae ky" href="https://docs.github.com/en/actions/reference/workflow-syntax-for-github-actions#jobsjob_idneeds" rel="noopener ugc nofollow" target="_blank">文档链接</a>)。前面的框架使用了以下代码:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nz oa l"/></div></figure><p id="ca0b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">虽然这个例子相当简单，但是可以设置更多的依赖项配置，包括用<code class="fe ob oc od oe b">if: always()</code>参数(<a class="ae ky" href="https://docs.github.com/en/actions/reference/workflow-syntax-for-github-actions#example-not-requiring-dependent-jobs-to-be-successful" rel="noopener ugc nofollow" target="_blank">文档链接</a>)接受所需作业中的失败状态。</p><p id="496f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">请查看Edward Thomson 的这篇文章，了解工作流分解的另一个例子。</p><p id="440a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe ob oc od oe b">setup</code>工作的要点是一劳永逸地安装依赖项。但是，由于每个作业都是从头开始的，并且数据没有跨作业持久化，因此依赖关系将会丢失。幸运的是，<code class="fe ob oc od oe b">actions/cache</code>前来救援。</p><h1 id="20a4" class="nc nd it bd ne nf ng nh ni nj nk nl nm jz nn ka no kc np kd nq kf nr kg ns nt bi translated">缓存依赖项</h1><p id="54cf" class="pw-post-body-paragraph kz la it lb b lc nu ju le lf nv jx lh li nw lk ll lm nx lo lp lq ny ls lt lu im bi translated"><code class="fe ob oc od oe b">actions/cache</code> ( <a class="ae ky" href="https://github.com/actions/cache" rel="noopener ugc nofollow" target="_blank">存储库链接</a>)以标准方式工作:</p><ul class=""><li id="21df" class="lw lx it lb b lc ld lf lg li ly lm lz lq ma lu mb mc md me bi translated">提供一个或多个要缓存的文件夹路径。要缓存的内容在作业结束时解析。</li><li id="8be9" class="lw lx it lb b lc mf lf mg li mh lm mi lq mj lu mb mc md me bi translated">提供一个标识缓存的键。给定一个键，如果找到缓存，则在调用该操作的步骤中恢复内容。</li></ul><p id="b530" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">使用缓存操作，GitHub操作会像这样增长:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nz oa l"/></div></figure><p id="66c9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">由于<code class="fe ob oc od oe b">lint</code>、<code class="fe ob oc od oe b">build</code>和<code class="fe ob oc od oe b">test</code>作业必须等待<code class="fe ob oc od oe b">setup</code>完成，因此保证有缓存可用。然后，每个作业只需恢复缓存的依赖关系即可继续。</p><p id="9f89" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><em class="lv">确保缓存键设置正确……没错，这张纸条来自一些相当痛苦的经历。</em></p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi of"><img src="../Images/d8d58eed685ecaf2c41c157de6832dae.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*fRVo9XGlldl8GQGP1tj81g.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">现在可以选择哪些检查是强制性的。</p></figure><p id="d6a8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">多亏了Jonathan Wilkinson 的这篇文章，这种配置可以更进一步:只有在没有缓存的依赖项可用时才安装依赖项！</p><p id="d838" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe ob oc od oe b">actions/cache</code>返回一个<code class="fe ob oc od oe b">cache-hit</code>布尔值，该值指示是否找到了缓存，这使得它成为有条件地触发依赖项安装的完美标志。在<code class="fe ob oc od oe b">setup</code>工作中只需要两个变化:</p><ul class=""><li id="8af0" class="lw lx it lb b lc ld lf lg li ly lm lz lq ma lu mb mc md me bi translated">向缓存步骤添加ID。</li><li id="5a31" class="lw lx it lb b lc mf lf mg li mh lm mi lq mj lu mb mc md me bi translated">只有当缓存步骤<code class="fe ob oc od oe b">cache-hit</code>返回真时，才执行<code class="fe ob oc od oe b">npm install</code>。</li></ul><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nz oa l"/></div></figure><p id="943e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">您可以在“Actions”选项卡中检查是否正确跳过了依赖项安装步骤。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi og"><img src="../Images/0a30b7b621dabaf837e2bc631fc35be8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*wic8IqDbcwsCRq_Z1laciw.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">看到“0s”执行时间总是好的！</p></figure><h1 id="47ff" class="nc nd it bd ne nf ng nh ni nj nk nl nm jz nn ka no kc np kd nq kf nr kg ns nt bi translated">保持代码干燥:复合动作</h1><p id="7a57" class="pw-post-body-paragraph kz la it lb b lc nu ju le lf nv jx lh li nw lk ll lm nx lo lp lq ny ls lt lu im bi translated">前面的例子包含了很多冗余，所以现在来看看复合动作是否交付了承诺的干代码。</p><h2 id="3b85" class="oh nd it bd ne oi oj dn ni ok ol dp nm li om on no lm oo op nq lq oq or ns os bi translated">设置复合动作</h2><p id="4f34" class="pw-post-body-paragraph kz la it lb b lc nu ju le lf nv jx lh li nw lk ll lm nx lo lp lq ny ls lt lu im bi translated">我们要分解的两个步骤是节点设置和缓存操作。基于<a class="ae ky" href="https://docs.github.com/en/actions/creating-actions/metadata-syntax-for-github-actions#about-yaml-syntax-for-github-actions" rel="noopener ugc nofollow" target="_blank">元数据语法文档</a>，复合动作定义为:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nz oa l"/></div></figure><p id="2055" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我没有包括<code class="fe ob oc od oe b">actions/checkout@v2</code>有两个原因:</p><ul class=""><li id="e6b0" class="lw lx it lb b lc ld lf lg li ly lm lz lq ma lu mb mc md me bi translated">大多数公司的存储库是私有的，所以复合动作的导入必须通过本地文件导入来完成(这里的<a class="ae ky" href="https://docs.github.com/en/actions/reference/workflow-syntax-for-github-actions#example-using-a-public-action-in-a-subdirectory" rel="noopener ugc nofollow" target="_blank">语法文档</a>)。该作业必须在加载本地文件之前签出存储库。</li><li id="139e" class="lw lx it lb b lc mf lf mg li mh lm mi lq mj lu mb mc md me bi translated">我想设置另一个工作流，该工作流在结帐步骤中需要一些附加参数。</li></ul><p id="925e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们的示例如下所示:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nz oa l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">轻多了，不是吗？</p></figure><h1 id="6750" class="nc nd it bd ne nf ng nh ni nj nk nl nm jz nn ka no kc np kd nq kf nr kg ns nt bi translated">矩阵测试</h1><p id="2e72" class="pw-post-body-paragraph kz la it lb b lc nu ju le lf nv jx lh li nw lk ll lm nx lo lp lq ny ls lt lu im bi translated">现在设置矩阵配置容易多了。让我们假设这个古怪的例子:</p><ul class=""><li id="501c" class="lw lx it lb b lc ld lf lg li ly lm lz lq ma lu mb mc md me bi translated">使用节点12和节点14检查构建步骤</li><li id="9a52" class="lw lx it lb b lc mf lf mg li mh lm mi lq mj lu mb mc md me bi translated">使用节点15检查林挺</li><li id="717a" class="lw lx it lb b lc mf lf mg li mh lm mi lq mj lu mb mc md me bi translated">使用节点14运行单元测试</li></ul><p id="529b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在这种情况下，设置必须涵盖所有可能性和三个节点版本，以确保正确生成依赖关系缓存。由于缓存键涉及节点版本和<code class="fe ob oc od oe b">package-lock.json</code>散列，缓存的依赖项可以在后续作业中安全地检索。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nz oa l"/></div></figure><p id="c2d7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">当所有测试都通过时，可以看到一个漂亮的全绿色图形，如下所示:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ot"><img src="../Images/b62f6a55fe27bc731c7bd6441649c5cf.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*5zHUYkaguCh9DEB5LtL0uQ.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">这里表示的工作流与代码示例略有不同。</p></figure><h1 id="bc58" class="nc nd it bd ne nf ng nh ni nj nk nl nm jz nn ka no kc np kd nq kf nr kg ns nt bi translated">真实世界的结论</h1><p id="cd99" class="pw-post-body-paragraph kz la it lb b lc nu ju le lf nv jx lh li nw lk ll lm nx lo lp lq ny ls lt lu im bi translated">当我看到基于文档的复合动作可以提供什么时，我的小实验还远远没有深入。但是目前为止我还是喜欢的。这里有一个简短的总结:</p><ul class=""><li id="d1be" class="lw lx it lb b lc ld lf lg li ly lm lz lq ma lu mb mc md me bi translated">为了保持代码干燥，组合模式总是受欢迎的！</li><li id="3796" class="lw lx it lb b lc mf lf mg li mh lm mi lq mj lu mb mc md me bi translated">您可以在私有存储库中使用复合动作。</li><li id="555c" class="lw lx it lb b lc mf lf mg li mh lm mi lq mj lu mb mc md me bi translated">使用特定的shell执行一些步骤的可能性对于一些设置任务非常有用。</li><li id="583c" class="lw lx it lb b lc mf lf mg li mh lm mi lq mj lu mb mc md me bi translated">很好的文档！</li></ul><p id="2c76" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果我要提到消极点，我只能想到不支持有条件的步骤。有了多工作流存储库，我不再需要冗余的<code class="fe ob oc od oe b">cache-restore</code>动作序列，后面紧跟着一个可选的<code class="fe ob oc od oe b">npm install</code>。也就是说，这是非常具体的，我相信没有条件的步骤肯定是可以忍受的。</p></div><div class="ab cl ou ov hx ow" role="separator"><span class="ox bw bk oy oz pa"/><span class="ox bw bk oy oz pa"/><span class="ox bw bk oy oz"/></div><div class="im in io ip iq"><p id="9d6b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">请不要忘记:正确集成的代码是友好的代码，所以不要忽视你的CI！</p><p id="49fd" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">感谢您阅读至此，用GitHub行动快乐CI建设！</p></div></div>    
</body>
</html>