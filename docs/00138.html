<html>
<head>
<title>SOLID Principles-simple and easy explanation</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">坚实的原则-简单易懂的解释</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/solid-principles-simple-and-easy-explanation-f57d86c47a7f?source=collection_archive---------0-----------------------#2018-05-29">https://betterprogramming.pub/solid-principles-simple-and-easy-explanation-f57d86c47a7f?source=collection_archive---------0-----------------------#2018-05-29</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><figure class="gl gn jr js jt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi jq"><img src="../Images/738dca35296d0c368002b57a3da1def0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*qatotphqCyOKDuGbDl4Qwg.jpeg"/></div></div></figure><p id="7318" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">SOLID Principles是一种编码标准，所有开发人员都应该对正确开发软件有一个清晰的概念，以避免糟糕的设计。它是由Robert C Martin提出的，并在面向对象设计领域广泛使用。如果应用得当，它会使你的代码更具可扩展性、逻辑性和可读性。</p><p id="bdfe" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">当开发人员按照糟糕的设计构建软件时，代码可能会变得不灵活和更脆弱。软件中的小改动会导致错误。基于这些原因，我们应该遵循坚实的原则。</p><p id="472f" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">这需要一些时间来理解，但是如果你遵循这些原则来编写代码，它将提高代码质量，并帮助你理解设计最好的软件。</p><p id="7c5a" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">为了理解坚实的原理，你必须清楚地知道接口的使用。如果你对界面的概念不清楚，那么你可以阅读这个<a class="ae kz" href="https://medium.com/@NahidulHasan/understanding-use-of-interface-and-abstract-class-9a82f5f15837" rel="noopener">文档</a>。</p><p id="fe9e" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我将试图用最简单的方式解释坚实的原理，以便初学者容易理解。让我们一个接一个地检查每个原则:</p></div><div class="ab cl la lb hx lc" role="separator"><span class="ld bw bk le lf lg"/><span class="ld bw bk le lf lg"/><span class="ld bw bk le lf"/></div><div class="im in io ip iq"><h1 id="a78d" class="lh li it bd lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me bi translated">单一责任原则:</h1><blockquote class="mf mg mh"><p id="8a9a" class="kb kc mi kd b ke kf kg kh ki kj kk kl mj kn ko kp mk kr ks kt ml kv kw kx ky im bi translated">一个类应该有且只有一个改变的理由。</p></blockquote><p id="0cb8" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">一个类应该只服务于一个目的。这并不意味着每个类应该只有一个方法，但是它们都应该与类的职责直接相关。所有的方法和属性都应该朝着同一个目标努力。当一个类服务于多种目的或职责时，它应该成为一个新的类。</p><p id="f447" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">请看下面的代码:</p><figure class="mm mn mo mp gt ju"><div class="bz fp l di"><div class="mq mr l"/></div></figure><p id="fd5b" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">上述类违反了单一责任原则。这个类为什么要从数据库中检索数据？它与持久层有关。持久层处理持久化(存储和检索)来自数据存储(例如数据库)的数据。所以不是这门课的责任。</p><p id="99b5" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">方法格式也不是这个类的责任，因为我们可能需要不同的数据格式，比如XML、JSON、HTML等等。</p><p id="3879" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">最后，重构后的代码将描述如下:</p><figure class="mm mn mo mp gt ju"><div class="bz fp l di"><div class="mq mr l"/></div></figure></div><div class="ab cl la lb hx lc" role="separator"><span class="ld bw bk le lf lg"/><span class="ld bw bk le lf lg"/><span class="ld bw bk le lf"/></div><div class="im in io ip iq"><h1 id="ab77" class="lh li it bd lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me bi translated">开闭原则:</h1><blockquote class="mf mg mh"><p id="332e" class="kb kc mi kd b ke kf kg kh ki kj kk kl mj kn ko kp mk kr ks kt ml kv kw kx ky im bi translated">实体应该对扩展开放，但对修改关闭。</p></blockquote><p id="7386" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">软件实体(类、模块、函数等。)应该是可扩展的，而不需要实际改变正在扩展的类的内容。如果我们能够足够严格地遵循这个原则，那么就有可能在不接触原始代码的情况下修改我们代码的行为。</p><p id="4ab0" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">请看下面的代码:</p><figure class="mm mn mo mp gt ju"><div class="bz fp l di"><div class="mq mr l"/></div></figure><p id="bc5f" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">如果我们想计算一个正方形的面积，我们必须修改CostManager类中的calculate方法。它打破了开闭原则。根据这个原理，我们不能修改，但可以扩展。</p><p id="dcde" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">那么我们该如何解决这个问题呢？请参见以下代码:</p><figure class="mm mn mo mp gt ju"><div class="bz fp l di"><div class="mq mr l"/></div></figure><p id="67be" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">现在我们可以在不修改CostManager类的情况下找到一个正方形的面积。</p></div><div class="ab cl la lb hx lc" role="separator"><span class="ld bw bk le lf lg"/><span class="ld bw bk le lf lg"/><span class="ld bw bk le lf"/></div><div class="im in io ip iq"><h1 id="5091" class="lh li it bd lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me bi translated">利斯科夫替代原理:</h1><p id="ab1d" class="pw-post-body-paragraph kb kc it kd b ke ms kg kh ki mt kk kl km mu ko kp kq mv ks kt ku mw kw kx ky im bi translated">1987年，Barbara Liskov在她的会议主题“数据抽象”中介绍了Liskov替代原则。芭芭拉·利斯科夫和<a class="ae kz" href="https://en.wikipedia.org/wiki/Jeannette_Wing" rel="noopener ugc nofollow" target="_blank">珍妮特·温</a>在1994年的一篇论文中简洁地阐述了这一原理，如下所示:</p><blockquote class="mf mg mh"><p id="d923" class="kb kc mi kd b ke kf kg kh ki kj kk kl mj kn ko kp mk kr ks kt ml kv kw kx ky im bi translated">设φ(x)是关于t类型的对象x的一个可证明的性质，那么φ(y)对于S类型的对象y应该是真的，其中S是t的子类型。</p></blockquote><p id="d1a5" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated"><a class="ae kz" href="https://en.wikipedia.org/wiki/Liskov_substitution_principle#Principle" rel="noopener ugc nofollow" target="_blank">的人类可读版本</a>几乎重复了Bertrand Meyer已经说过的所有内容，但是它完全依赖于一个类型系统:</p><blockquote class="mf mg mh"><p id="a35f" class="kb kc mi kd b ke kf kg kh ki kj kk kl mj kn ko kp mk kr ks kt ml kv kw kx ky im bi translated">1.不能在子类型中加强前提条件。<br/> 2。子类型中的后置条件不能被削弱。<br/> 3。超类型的不变量必须保留在子类型中。</p></blockquote><p id="0e0b" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">罗伯特·马丁在1996年使这个定义更流畅、更简洁:</p><blockquote class="mf mg mh"><p id="2566" class="kb kc mi kd b ke kf kg kh ki kj kk kl mj kn ko kp mk kr ks kt ml kv kw kx ky im bi translated">使用基类引用的指针的函数必须能够在不知道的情况下使用派生类的对象。</p></blockquote><p id="1f08" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">或者简单地说:子类/派生类应该可以替换它们的基类/父类。</p><p id="2e09" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">它指出，抽象(接口)的任何实现在接受抽象的任何地方都应该是可替换的。基本上，在我们的代码中使用接口编码时，我们不仅有接口接收的输入契约，还有实现该接口的不同类返回的输出；他们应该是同一类型的。</p><p id="1ce3" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">这段代码显示了什么违反了LSP，以及我们如何修复它:</p><figure class="mm mn mo mp gt ju"><div class="bz fp l di"><div class="mq mr l"/></div></figure></div><div class="ab cl la lb hx lc" role="separator"><span class="ld bw bk le lf lg"/><span class="ld bw bk le lf lg"/><span class="ld bw bk le lf"/></div><div class="im in io ip iq"><h1 id="63b9" class="lh li it bd lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me bi translated">界面分离原则:</h1><blockquote class="mf mg mh"><p id="7273" class="kb kc mi kd b ke kf kg kh ki kj kk kl mj kn ko kp mk kr ks kt ml kv kw kx ky im bi translated">不应该强迫客户端实现它不使用的接口。</p></blockquote><p id="0f0a" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">这条规则意味着我们应该把我们的界面分成许多更小的界面，这样它们才能更好地满足客户的确切需求。</p><p id="e0fc" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">与单一责任原则相似，接口分离原则的目标是通过将软件划分为多个独立的部分来最小化副作用和重复。</p><p id="525e" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">让我们看一个例子:</p><figure class="mm mn mo mp gt ju"><div class="bz fp l di"><div class="mq mr l"/></div></figure><p id="3125" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">在上面的代码中，RobotWorker不需要sleep，但是类必须实现sleep方法，因为我们知道所有的方法在接口中都是抽象的。它打破了界面分离定律。请查看以下代码，了解我们如何修复它:</p><figure class="mm mn mo mp gt ju"><div class="bz fp l di"><div class="mq mr l"/></div></figure></div><div class="ab cl la lb hx lc" role="separator"><span class="ld bw bk le lf lg"/><span class="ld bw bk le lf lg"/><span class="ld bw bk le lf"/></div><div class="im in io ip iq"><h1 id="83a6" class="lh li it bd lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me bi translated">依赖性倒置原则:</h1><blockquote class="mf mg mh"><p id="6d68" class="kb kc mi kd b ke kf kg kh ki kj kk kl mj kn ko kp mk kr ks kt ml kv kw kx ky im bi translated">高层模块不应该依赖低层模块。两者都应该依赖于抽象。</p><p id="1ed6" class="kb kc mi kd b ke kf kg kh ki kj kk kl mj kn ko kp mk kr ks kt ml kv kw kx ky im bi translated">抽象不应该依赖于细节。细节应该依赖于抽象。</p></blockquote><p id="7915" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">或者简单地说:依赖抽象，而不是具体。</p><p id="a3d9" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">通过应用依赖倒置原则，模块可以很容易地被其他模块改变，只要改变依赖模块。对低级模块的任何更改都不会影响高级模块。</p><p id="b510" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">请看下面的代码:</p><figure class="mm mn mo mp gt ju"><div class="bz fp l di"><div class="mq mr l"/></div></figure><p id="13d4" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">有一个常见的误解，即依赖倒置只是依赖注入的另一种说法。然而，这两者并不相同。</p><p id="3fe8" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">在上面的代码中，尽管在<code class="fe mx my mz na b">PasswordReminder</code>类中注入了<code class="fe mx my mz na b">MySQLConnection</code>类，但它依赖于<code class="fe mx my mz na b">MySQLConnection</code>。高级模块<code class="fe mx my mz na b">PasswordReminder</code>不应该依赖低级模块<code class="fe mx my mz na b">MySQLConnection</code>。</p><p id="d454" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">如果我们想将连接从<code class="fe mx my mz na b">MySQLConnection</code>更改为<code class="fe mx my mz na b">MongoDBConnection</code>，我们必须更改<code class="fe mx my mz na b">PasswordReminder</code>类中硬编码的构造函数注入。</p><p id="0cd8" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">类应该依赖于抽象，而不是具体化。但是怎么才能做到呢？请看下面的例子:</p><figure class="mm mn mo mp gt ju"><div class="bz fp l di"><div class="mq mr l"/></div></figure><p id="b883" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">在上面的代码中，我们希望将连接从<code class="fe mx my mz na b">MySQLConnection</code>更改为<code class="fe mx my mz na b">MongoDBConnection</code>。我们不需要改变<code class="fe mx my mz na b">PasswordReminder</code>类中的构造函数注入。因为这里的<code class="fe mx my mz na b">PasswordReminder</code>类依赖于抽象，而不是具体化。</p><p id="952d" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated"><em class="mi">如果你想练习并得到关于坚实的例子的代码，请查看我的</em><a class="ae kz" href="https://github.com/nahidulhasan/solid-principles" rel="noopener ugc nofollow" target="_blank"><em class="mi">GitHub</em></a><em class="mi">(星星总是受赞赏的)资源库。</em></p><p id="c692" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">感谢阅读。</p></div><div class="ab cl la lb hx lc" role="separator"><span class="ld bw bk le lf lg"/><span class="ld bw bk le lf lg"/><span class="ld bw bk le lf"/></div><div class="im in io ip iq"><p id="66e0" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">特别感谢<a class="nb nc ep" href="https://medium.com/u/42d2a133e29f?source=post_page-----f57d86c47a7f--------------------------------" rel="noopener" target="_blank">艾哈迈德·沙米姆·哈桑</a>和<a class="nb nc ep" href="https://medium.com/u/2194060a4e1f?source=post_page-----f57d86c47a7f--------------------------------" rel="noopener" target="_blank">拉夫桑·哈辛·汗</a></p></div></div>    
</body>
</html>