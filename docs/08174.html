<html>
<head>
<title>How To Master HTTP Requests With Axios</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何用Axios掌握HTTP请求</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/how-to-master-http-requests-with-axios-639b2286dc31?source=collection_archive---------10-----------------------#2021-04-02">https://betterprogramming.pub/how-to-master-http-requests-with-axios-639b2286dc31?source=collection_archive---------10-----------------------#2021-04-02</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="8dc3" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">了解如何在HTTP请求中使用基于JavaScript的库</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi ki"><img src="../Images/b41745bf53fdb85e4ed8a956d14c92ed.png" data-original-src="https://miro.medium.com/v2/resize:fit:1360/format:webp/0*i9dZDqeMsvHYqC6C.jpg"/></div><p class="kq kr gj gh gi ks kt bd b be z dk translated">作者照片。</p></figure><p id="e93f" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">Axios 是JavaScript开发者最喜欢的HTTP客户端之一。它用于从客户端和服务器端发送HTTP请求，尤其是AJAX请求。</p><p id="bdad" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">在开发动态web应用程序时，从JavaScript端发送HTTP请求几乎是必不可少的。Axios通过在JavaScript的<code class="fe lr ls lt lu b">XMLHttpRequest</code>接口上提供一个易于使用的抽象来简化这项任务，提供了许多用户友好的功能和配置选项。</p><p id="deb3" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">在本教程中，我们将带着代码示例和简化的解释，向您介绍使用Axios发送HTTP请求所需要了解的一切。</p><p id="4035" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">让我们以一个问题开始我们的介绍。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="fdb0" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">为什么要选择Axios？</h1><p id="c7a2" class="pw-post-body-paragraph ku kv it kw b kx mu ju kz la mv jx lc ld mw lf lg lh mx lj lk ll my ln lo lp im bi translated">要回答这个问题，让我们来看看可供开发人员使用的Axios替代方案。</p><p id="ad28" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">JavaScript提供了一个内置接口<code class="fe lr ls lt lu b">XMLHttpRequest</code>来处理HTTP请求。然而，用这个接口发送请求并不简单，需要编写太多行代码。</p><p id="d32a" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">如果你用过jQuery，你一定很熟悉<code class="fe lr ls lt lu b">$_ajax</code>函数。它在<code class="fe lr ls lt lu b">XMLHttpRequest</code>接口上提供了一个更简单易用的抽象，我们可以用更少的代码行来发送HTTP请求。但是随着像jQuery这样的库在过去几年中变得过时，开发人员需要一个本地JavaScript解决方案来创建HTTP请求。</p><p id="775d" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">现在，Fetch API和Axios是用于发送这些请求的本地JavaScript中最流行的两种解决方案。然而，与Fetch API相比，Axios有一个优势，因为它为开发人员提供了一些独特的功能。以下是其中的几个例子:</p><ul class=""><li id="bc27" class="mz na it kw b kx ky la lb ld nb lh nc ll nd lp ne nf ng nh bi translated">支持请求和响应拦截</li><li id="30e0" class="mz na it kw b kx ni la nj ld nk lh nl ll nm lp ne nf ng nh bi translated">取消请求的能力</li><li id="9d39" class="mz na it kw b kx ni la nj ld nk lh nl ll nm lp ne nf ng nh bi translated">支持旧浏览器(Internet Explorer 11)</li><li id="cf11" class="mz na it kw b kx ni la nj ld nk lh nl ll nm lp ne nf ng nh bi translated">JSON数据的自动转换</li><li id="d121" class="mz na it kw b kx ni la nj ld nk lh nl ll nm lp ne nf ng nh bi translated">XSRF保护的客户端支持</li></ul><p id="f500" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">由于其强大的功能集，开发人员现在开始倾向于使用Axios而不是Fetch API来发送HTTP请求。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="b9dd" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">安装Axios</h1><p id="1460" class="pw-post-body-paragraph ku kv it kw b kx mu ju kz la mv jx lc ld mw lf lg lh mx lj lk ll my ln lo lp im bi translated">您可以在前端和后端安装和使用Axios。如果您使用的是像npm这样的软件包管理器，安装会很简单:</p><pre class="kj kk kl km gt nn lu no np aw nq bi"><span id="8c0b" class="nr md it lu b gy ns nt l nu nv">npm install axios</span></pre><p id="105d" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">如果您使用内容交付网络(CDN ),请在HTML中嵌入Axios脚本:</p><pre class="kj kk kl km gt nn lu no np aw nq bi"><span id="53aa" class="nr md it lu b gy ns nt l nu nv">&lt;script src="https://cdn.jsdelivr.net/npm/axios/dist/axios.min.js"&gt;&lt;/script&gt;</span></pre><p id="7dc1" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">或者:</p><pre class="kj kk kl km gt nn lu no np aw nq bi"><span id="661c" class="nr md it lu b gy ns nt l nu nv">&lt;script src="https://unpkg.com/axios/dist/axios.min.js"&gt;&lt;/script&gt;</span></pre></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="b4b6" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">使用Axios发送HTTP请求</h1><p id="15e9" class="pw-post-body-paragraph ku kv it kw b kx mu ju kz la mv jx lc ld mw lf lg lh mx lj lk ll my ln lo lp im bi translated">使用Axios发送HTTP请求就像将包含所有配置选项和数据的对象传递给<code class="fe lr ls lt lu b">axios()</code>函数一样简单:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nw nx l"/></div></figure><p id="48db" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">让我们仔细看看这里使用的配置选项:</p><ul class=""><li id="0514" class="mz na it kw b kx ky la lb ld nb lh nc ll nd lp ne nf ng nh bi translated"><code class="fe lr ls lt lu b">method</code>:必须发送请求的HTTP方法。</li><li id="61b6" class="mz na it kw b kx ni la nj ld nk lh nl ll nm lp ne nf ng nh bi translated"><code class="fe lr ls lt lu b">url</code>:请求必须发送到的服务器的URL。</li><li id="0cc2" class="mz na it kw b kx ni la nj ld nk lh nl ll nm lp ne nf ng nh bi translated"><code class="fe lr ls lt lu b">data</code>:在POST、PUT和PATCH请求的情况下，使用该选项提供的数据在HTTP请求的主体中发送。</li></ul><p id="ab0e" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">要查看Axios请求功能可用的所有配置选项，请参考其<a class="ae lq" href="https://www.npmjs.com/package/axios#creating-an-instance" rel="noopener ugc nofollow" target="_blank">官方文档</a>。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="ec88" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">专用请求功能</h1><p id="50cc" class="pw-post-body-paragraph ku kv it kw b kx mu ju kz la mv jx lc ld mw lf lg lh mx lj lk ll my ln lo lp im bi translated">除了通用的<code class="fe lr ls lt lu b">axios()</code>功能，Axios还提供了专用功能来简化发送不同类型的请求。以下是这些功能的列表:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nw nx l"/></div></figure><p id="f961" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">例如，我们可以通过将方法设置为“post”来使用<code class="fe lr ls lt lu b">axios.post()</code>函数发送POST请求，而不是使用<code class="fe lr ls lt lu b">axios()</code>函数</p><pre class="kj kk kl km gt nn lu no np aw nq bi"><span id="7736" class="nr md it lu b gy ns nt l nu nv">axios.post("/users", {<br/>    username: "sam123",<br/>    firstname: "sam",<br/>    lastname: "smith"<br/>});</span></pre><p id="e7a7" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">我们可以使用<code class="fe lr ls lt lu b">axios.get()</code>函数以类似的方式发送GET请求:</p><pre class="kj kk kl km gt nn lu no np aw nq bi"><span id="f4ef" class="nr md it lu b gy ns nt l nu nv">axios.get("/users", {<br/>    params: {<br/>        firstname: "sam"<br/>    }<br/>});</span></pre><p id="c2f0" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated"><code class="fe lr ls lt lu b">params</code>配置选项用于设置URL中的查询参数。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="14c4" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">发送多个并发请求</h1><p id="1369" class="pw-post-body-paragraph ku kv it kw b kx mu ju kz la mv jx lc ld mw lf lg lh mx lj lk ll my ln lo lp im bi translated">我们可以使用Axios并发发送多个请求。为此，我们必须将一组请求调用传递给<code class="fe lr ls lt lu b">Promise.all()</code>函数:</p><pre class="kj kk kl km gt nn lu no np aw nq bi"><span id="78aa" class="nr md it lu b gy ns nt l nu nv">Promise.all([<br/>    axios.get("/users/sam123"),<br/>    axios.get("/users/sam123/comments")<br/>]);</span></pre></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="5338" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">用Axios处理响应</h1><p id="98af" class="pw-post-body-paragraph ku kv it kw b kx mu ju kz la mv jx lc ld mw lf lg lh mx lj lk ll my ln lo lp im bi translated">当我们向远程服务器发送HTTP请求时，我们会收到来自该服务器的包含特定信息的响应。我们可以使用Axios检索这个响应。</p><p id="278a" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">根据Axios的文档，返回的响应包含以下信息:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nw nx l"/></div></figure><p id="f83a" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">因为Axios是基于承诺的，所以响应作为承诺返回。所以我们需要使用<code class="fe lr ls lt lu b">then()</code>和<code class="fe lr ls lt lu b">catch()</code>函数来检索响应并捕捉错误(如果有的话)。</p><p id="0fc9" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">让我们看看如何处理POST请求返回的响应:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nw nx l"/></div></figure></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="1977" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">使用异步/等待</h1><p id="3d89" class="pw-post-body-paragraph ku kv it kw b kx mu ju kz la mv jx lc ld mw lf lg lh mx lj lk ll my ln lo lp im bi translated">我们还可以使用<code class="fe lr ls lt lu b">async/await</code>发送HTTP请求并处理响应，而不是承诺:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nw nx l"/></div></figure></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="457a" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">处理来自并发请求的响应</h1><p id="596d" class="pw-post-body-paragraph ku kv it kw b kx mu ju kz la mv jx lc ld mw lf lg lh mx lj lk ll my ln lo lp im bi translated">在上一节中，我们使用了<code class="fe lr ls lt lu b">Promise.all()</code>方法来发送多个并发请求。当传递给该方法的所有请求都完成时，它返回一个带有每个请求的响应对象的承诺。我们可以使用传递给方法的数组中每个请求的索引来分隔响应:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nw nx l"/></div></figure></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="6900" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">处理错误</h1><p id="fc8f" class="pw-post-body-paragraph ku kv it kw b kx mu ju kz la mv jx lc ld mw lf lg lh mx lj lk ll my ln lo lp im bi translated">如果在使用Axios发送HTTP请求时发生错误，返回的error对象包含特定的信息来帮助我们找出错误发生的确切位置。正如您将在下面的示例中看到的，有三个地方可能会出现错误:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nw nx l"/></div></figure><p id="668e" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">有了Axios提供的这些信息，您可以根据错误发生的位置适当地处理错误。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="3669" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">用POST请求发送数据</h1><p id="2d17" class="pw-post-body-paragraph ku kv it kw b kx mu ju kz la mv jx lc ld mw lf lg lh mx lj lk ll my ln lo lp im bi translated">当使用Axios发送POST请求(还有PUT和PATCH请求)时，请注意我们是如何将普通的JavaScript对象作为数据传递的。默认情况下，Axios会将这些JavaScript数据转换成JSON。它还将<code class="fe lr ls lt lu b">content-type</code>报头设置为<code class="fe lr ls lt lu b">application/json</code>。</p><p id="a592" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">但是，如果将序列化的JSON对象作为数据传递，Axios会将内容类型视为“application/x-www-form-urlencoded”(表单编码的请求体)。如果想要的内容类型是JSON，您必须使用<code class="fe lr ls lt lu b">headers</code>配置选项手动设置头。</p><pre class="kj kk kl km gt nn lu no np aw nq bi"><span id="9fe2" class="nr md it lu b gy ns nt l nu nv">const data = JSON.stringify({name: "sam"});<br/>const options = {<br/>    headers: {"content-type": "application/json"}<br/>}</span><span id="15f6" class="nr md it lu b gy ny nt l nu nv">axios.post("/users", data, options);</span></pre><p id="062b" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">如果您想发送除JSON之外的任何其他类型的数据，您必须显式地转换数据并适当地设置<code class="fe lr ls lt lu b">content-type</code>头。Axios提供了两个配置选项(<code class="fe lr ls lt lu b">transformRequest</code>和<code class="fe lr ls lt lu b">transformResponse</code>)，分别用于在发送请求和接收响应之前进行转换。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="1a63" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">转换数据</h1><p id="98de" class="pw-post-body-paragraph ku kv it kw b kx mu ju kz la mv jx lc ld mw lf lg lh mx lj lk ll my ln lo lp im bi translated">让我们看看如何在发送请求时使用这两个配置选项:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nw nx l"/></div></figure></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="ff3f" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">为请求设置自定义标题</h1><p id="41c5" class="pw-post-body-paragraph ku kv it kw b kx mu ju kz la mv jx lc ld mw lf lg lh mx lj lk ll my ln lo lp im bi translated">您可以轻松地为使用Axios发送的请求设置自定义标题。您只需将包含自定义标头的对象传递给正在使用的请求方法:</p><pre class="kj kk kl km gt nn lu no np aw nq bi"><span id="04c7" class="nr md it lu b gy ns nt l nu nv">const options = {<br/>    headers: {"X-Custom-Header": "value"}<br/>}</span><span id="4ec1" class="nr md it lu b gy ny nt l nu nv">axios.get("users/sam123", options);</span></pre></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="2edf" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">设置配置默认值</h1><p id="3b19" class="pw-post-body-paragraph ku kv it kw b kx mu ju kz la mv jx lc ld mw lf lg lh mx lj lk ll my ln lo lp im bi translated">您可以设置默认配置选项，以便将它们应用于您使用Axios发送的每个请求。这样，您就不必重复设置所有请求都通用的选项。</p><p id="1e41" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">例如，如果您想设置用于每个请求的基本URL或授权头，可以很容易地实现:</p><pre class="kj kk kl km gt nn lu no np aw nq bi"><span id="6fee" class="nr md it lu b gy ns nt l nu nv">axios.defaults.baseURL = "https://example.com";<br/>axios.defaults.headers.common["Authorization"] = AUTH_TOKEN</span></pre><h2 id="f3c5" class="nr md it bd me nz oa dn mi ob oc dp mm ld od oe mo lh of og mq ll oh oi ms oj bi translated">设置实例的配置默认值</h2><p id="ec7b" class="pw-post-body-paragraph ku kv it kw b kx mu ju kz la mv jx lc ld mw lf lg lh mx lj lk ll my ln lo lp im bi translated">有时，由于我们发送的请求的差异，为每个HTTP请求设置默认配置变得不现实。根据用户权限，我们可以向两个不同的API或不同的授权令牌发送请求。</p><p id="7e37" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">在这种情况下，虽然我们不能找到每个请求共有的配置选项，但是我们也许能够找到不同请求组共有的选项。Axios为我们提供了一种分别为这些不同的组设置默认配置的方法:通过创建实例。</p><p id="d372" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">我们可以创建单独的实例，并为每个实例设置默认配置。然后，我们可以使用这个实例对象代替Axios对象来发送请求:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nw nx l"/></div></figure></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="fa40" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">拦截请求</h1><p id="7d2a" class="pw-post-body-paragraph ku kv it kw b kx mu ju kz la mv jx lc ld mw lf lg lh mx lj lk ll my ln lo lp im bi translated">HTTP请求拦截是Axios中最有趣的特性之一。它允许你拦截程序发送和接收的请求，并在操作完成之前执行一些常见的任务。这个特性简化了与HTTP请求相关的后台任务的处理，比如日志记录、身份验证和授权。</p><p id="818f" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">为请求或响应定义拦截器是一项简单的任务:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nw nx l"/></div></figure><p id="6c7c" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">这里，<code class="fe lr ls lt lu b">config</code>对象就是我们传递给Axios函数的确切的<code class="fe lr ls lt lu b">config</code>对象或者它的一个别名。因此拦截器可以完全访问请求配置及其数据。</p><p id="471a" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">设置请求拦截器后，每次程序发送新请求时，消息“请求已发送”都会记录到控制台。</p><p id="75e8" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">我们可以用类似的方式设置响应拦截器:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nw nx l"/></div></figure><p id="8918" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">现在，每次收到响应时，消息“Response received”都会记录到控制台。</p><p id="4c48" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">我们也可以为实例而不是Axios对象定义拦截器:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nw nx l"/></div></figure></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="bec8" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">取消请求</h1><p id="6fd6" class="pw-post-body-paragraph ku kv it kw b kx mu ju kz la mv jx lc ld mw lf lg lh mx lj lk ll my ln lo lp im bi translated">Axios提供的另一个有趣的特性是我们可以随时取消请求。</p><p id="1173" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">在web开发的某些情况下，我们可能会发现远程服务器对我们请求的响应不再重要。在这种情况下，我们可以通过简单地取消请求来节省系统资源。Axios为我们提供了实现这一目标的方法。</p><p id="e837" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">如果您想取消某个请求，它应该有一个在创建请求时创建的<code class="fe lr ls lt lu b">cancel</code>令牌。我们可以使用这个令牌随时取消请求。</p><p id="fa63" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">取消过程是这样实现的:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nw nx l"/></div></figure><p id="7dfe" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">值得注意的是，我们可以使用一个<code class="fe lr ls lt lu b">source</code>对象同时取消几个请求。当调用<code class="fe lr ls lt lu b">source.cancel</code>时，其<code class="fe lr ls lt lu b">cancel</code>令牌是使用给定源创建的所有请求都被取消。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="4f3a" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">防范XSRF攻击</h1><p id="e776" class="pw-post-body-paragraph ku kv it kw b kx mu ju kz la mv jx lc ld mw lf lg lh mx lj lk ll my ln lo lp im bi translated">跨站点请求伪造(XSRF)是攻击者用来渗透web应用程序并执行恶意任务的一种技术。在这些攻击中，攻击者伪装成受信任的用户，欺骗应用程序执行对他们有利的操作。</p><p id="040b" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">这可能会危及用户的隐私和安全，如果用户拥有高级权限，甚至会导致攻击者获得整个系统的访问权限。</p><p id="b1ab" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">Axios通过在创建请求时嵌入额外的身份验证信息，提供了一种防止此类攻击的方法。它是这样实现的:</p><pre class="kj kk kl km gt nn lu no np aw nq bi"><span id="7d3e" class="nr md it lu b gy ns nt l nu nv">const options = {<br/>  xsrfCookieName: 'XSRF-TOKEN',<br/>  xsrfHeaderName: 'X-XSRF-TOKEN',<br/>};</span><span id="286f" class="nr md it lu b gy ny nt l nu nv">axios.post("/users", options);</span></pre></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="4a41" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">摘要</h1><p id="09b7" class="pw-post-body-paragraph ku kv it kw b kx mu ju kz la mv jx lc ld mw lf lg lh mx lj lk ll my ln lo lp im bi translated">在本教程中，我们讨论了作为web开发人员使用Axios发送HTTP请求时需要了解的一切。正如您已经看到的，Axios使处理HTTP请求和响应的任务变得非常简单。</p><p id="9c77" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">它提供了许多配置选项来根据我们的需要改变默认行为。它还提供了许多方法来简化发送HTTP请求的任务。在Axios的帮助下，您可以以超乎想象的速度在应用程序的后端和前端实现HTTP请求发送特性。</p><p id="3005" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">因此，如果您还没有，请将Axios添加到您的JavaScript库组中，并使用它轻松实现您的HTTP请求发送任务。</p></div></div>    
</body>
</html>