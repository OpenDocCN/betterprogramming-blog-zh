<html>
<head>
<title>Inverting Dependencies: A Step Towards Hexagonal Architecture</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">反转依赖关系:迈向六边形架构的一步</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/inverting-dependencies-a-step-towards-hexagonal-architecture-ee74e11877dd?source=collection_archive---------5-----------------------#2020-05-13">https://betterprogramming.pub/inverting-dependencies-a-step-towards-hexagonal-architecture-ee74e11877dd?source=collection_archive---------5-----------------------#2020-05-13</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="e4ad" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">如何从传统的分层架构向六边形架构迈出第一步</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/6e95fb51aad1438f74c46ca90a6a2b31.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*bVq4BL2ZocG_ECXu"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">照片由<a class="ae kv" href="https://unsplash.com/@glzk?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">格劳科·祖卡西亚</a>在<a class="ae kv" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</p></figure><blockquote class="kw kx ky"><p id="e173" class="kz la lb lc b ld le jr lf lg lh ju li lj lk ll lm ln lo lp lq lr ls lt lu lv ij bi translated">“您必须明白，当您将一个框架与您的应用程序结合时，您将在该应用程序的剩余生命周期中被该框架所束缚。不管是好是坏，生病还是健康，富裕还是贫穷，抛开所有其他，你都将使用这个框架。这不是一个轻易做出的承诺。”</p><p id="f658" class="kz la lb lc b ld le jr lf lg lh ju li lj lk ll lm ln lo lp lq lr ls lt lu lv ij bi translated">――罗伯特·c·马丁，“清洁建筑”</p></blockquote><p id="032b" class="pw-post-body-paragraph kz la iq lc b ld le jr lf lg lh ju li lw lk ll lm lx lo lp lq ly ls lt lu lv ij bi translated">年轻时的我会对这个警告感到惊讶。因为年轻的我考虑过知道一个框架相当于拥有更高的学位。那时候，我只有一个目标，那就是找到一个完美的框架，只要我想继续从事这个行业，就坚持下去。</p><p id="4c24" class="pw-post-body-paragraph kz la iq lc b ld le jr lf lg lh ju li lw lk ll lm lx lo lp lq ly ls lt lu lv ij bi translated">切换到不同的框架来做同样的事情对我来说是陌生的。但是我的这种态度并没有持续很久。因为很快我就意识到这个行业中的事情是多么的短暂——每天我们都被引入一门新的语言或一个新的框架，这可能会进一步减少我们的工作。</p><p id="c99a" class="pw-post-body-paragraph kz la iq lc b ld le jr lf lg lh ju li lw lk ll lm lx lo lp lq ly ls lt lu lv ij bi translated">当我意识到这一点时，我经常想把我的代码移植到新的闪亮的框架中。但是我不能。因为框架代码在业务逻辑中根深蒂固，所以需要付出巨大的努力。</p><blockquote class="kw kx ky"><p id="e720" class="kz la lb lc b ld le jr lf lg lh ju li lj lk ll lm ln lo lp lq lr ls lt lu lv ij bi translated">"业务规则应该是系统中最独立和可重用的代码."</p><p id="c00b" class="kz la lb lc b ld le jr lf lg lh ju li lj lk ll lm ln lo lp lq lr ls lt lu lv ij bi translated">――罗伯特·c·马丁，“清洁建筑”</p></blockquote><p id="26c3" class="pw-post-body-paragraph kz la iq lc b ld le jr lf lg lh ju li lw lk ll lm lx lo lp lq ly ls lt lu lv ij bi translated">这个问题的答案一直摆在我面前——也就是说，保持领域逻辑的解耦——但是有一种方法没有。但是最近，我遇到了一个架构，它提供了一个有趣的方法来解决这个问题。它被称为<em class="lb">六角形建筑。</em></p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi lz"><img src="../Images/91cf23480a93ec9cf63810b939fe5103.png" data-original-src="https://miro.medium.com/v2/resize:fit:1000/format:webp/1*9R3V9gbS3I_4-kBl9DHntA.png"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">由<a class="ae kv" href="https://commons.wikimedia.org/w/index.php?title=User:Cth027&amp;action=edit&amp;redlink=1" rel="noopener ugc nofollow" target="_blank"> Cth027 </a>在<a class="ae kv" href="https://commons.wikimedia.org/wiki/File:Hexagonal_Architecture.svg" rel="noopener ugc nofollow" target="_blank">维基共享资源</a>上的插图</p></figure><p id="f04a" class="pw-post-body-paragraph kz la iq lc b ld le jr lf lg lh ju li lw lk ll lm lx lo lp lq ly ls lt lu lv ij bi translated">六角形架构背后的想法是将领域或业务逻辑保持在设计的中心。该域不应该有任何外部依赖性。在它的中心，我们有实体，围绕它的是用例。所有东西都包含在六边形内。只能通过输入/输出端口<strong class="lc ir"> </strong>和<strong class="lc ir">对其进行访问。</strong>那么，我们如何实现这一目标呢？</p><p id="d453" class="pw-post-body-paragraph kz la iq lc b ld le jr lf lg lh ju li lw lk ll lm lx lo lp lq ly ls lt lu lv ij bi translated">在我回答这个问题之前，我想稍微谈一下<em class="lb">分层架构</em>和它的一些缺点。然后，我将向您展示如何从分层架构过渡到六边形架构，这将帮助我们克服这些缺点，并回答上面提出的问题。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi ma"><img src="../Images/2d32455293d364e6231dfc4eafefea4b.png" data-original-src="https://miro.medium.com/v2/resize:fit:242/format:webp/1*7IYK_FPk042P3RX16r0egg.png"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">分层架构</p></figure><p id="4733" class="pw-post-body-paragraph kz la iq lc b ld le jr lf lg lh ju li lw lk ll lm lx lo lp lq ly ls lt lu lv ij bi translated">正如您在上图中看到的，服务层位于存储库层之上。很明显，我们的域代码——驻留在服务层——对存储库层有一个向外的依赖性。因此，在实现存储库层之前，我们不能开始服务层的工作。</p><p id="ec12" class="pw-post-body-paragraph kz la iq lc b ld le jr lf lg lh ju li lw lk ll lm lx lo lp lq ly ls lt lu lv ij bi translated">同样因为这种层次结构，我们通常从建模数据库模式开始— <em class="lb">数据库驱动设计— </em>，自信地认为我们已经完全理解了我们的领域，事实上，除非我们已经实现了我们所有的业务逻辑，否则我们永远也不会理解。然后我们发现自己又花了几个小时在DB模式和ORM代码上。</p><p id="3a70" class="pw-post-body-paragraph kz la iq lc b ld le jr lf lg lh ju li lw lk ll lm lx lo lp lq ly ls lt lu lv ij bi translated">不是这个。还记得第一段中关于混合框架代码和业务逻辑的咆哮吗？这发生在服务层，因为ORM实体进入了服务层。“那有什么不好？”你可能会问。这些实体与我们数据库中的表完全相似——此外，它们包含元数据和映射信息，这意味着我们的域代码完全了解持久性API并与之耦合。</p><p id="6072" class="pw-post-body-paragraph kz la iq lc b ld le jr lf lg lh ju li lw lk ll lm lx lo lp lq ly ls lt lu lv ij bi translated">现在让我们看看迁移到六边形架构如何帮助我们解决这些问题。为此，我们需要我们的存储库层或持久层依赖于服务层或领域层。所以，基本上，我们需要颠倒依赖关系。</p><p id="240a" class="pw-post-body-paragraph kz la iq lc b ld le jr lf lg lh ju li lw lk ll lm lx lo lp lq ly ls lt lu lv ij bi translated">首先要反转依赖关系，我们需要一个没有任何ORM代码的实体。接下来，我们的域层需要公开一组名为<em class="lb">端口、</em>的接口，我们的持久层需要提供具体的实现。</p><p id="e581" class="pw-post-body-paragraph kz la iq lc b ld le jr lf lg lh ju li lw lk ll lm lx lo lp lq ly ls lt lu lv ij bi translated">将这些域实体转换成ORM管理的实体并执行所需的操作将是持久层的工作。这样，我们的域逻辑就没有任何持久性代码了。检查下面的UML类图以获得更多的清晰度。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi mb"><img src="../Images/f5071588c3ed33f69eb7198ae00ecbca.png" data-original-src="https://miro.medium.com/v2/resize:fit:1202/format:webp/1*n-7MOXATnEo73fkRL8c_JA.png"/></div></figure><p id="d03d" class="pw-post-body-paragraph kz la iq lc b ld le jr lf lg lh ju li lw lk ll lm lx lo lp lq ly ls lt lu lv ij bi translated">不过，这种脱钩是有代价的。正如你所看到的，现在除了ORM实体之外，我们还需要管理域实体。</p><p id="9955" class="pw-post-body-paragraph kz la iq lc b ld le jr lf lg lh ju li lw lk ll lm lx lo lp lq ly ls lt lu lv ij bi translated">但是看看好的一面:会有很多收获。首先，我们的领域层是完全解耦的。此外，现在您可以自由地使用助手方法和大量构造函数来丰富您的域实体，否则您无法使用ORM实体来完成这些。这也允许我们以最纯粹的形式应用领域驱动设计(DDD)。</p><p id="9221" class="pw-post-body-paragraph kz la iq lc b ld le jr lf lg lh ju li lw lk ll lm lx lo lp lq ly ls lt lu lv ij bi translated">尽管如此，我们的领域层不会完全摆脱所有的框架代码，因为领域层中使用的接口需要提供具体的实现。</p><p id="a2f3" class="pw-post-body-paragraph kz la iq lc b ld le jr lf lg lh ju li lw lk ll lm lx lo lp lq ly ls lt lu lv ij bi translated">为此，我们仍然依赖我们的依赖注入(DI)框架，它将在运行时满足依赖性。所以所有的层仍然依赖于DI框架。但是通常情况下，DI框架在代码上的足迹非常低，我们可以通过使用诸如构造注入之类的方法来进一步减少这些足迹。</p><p id="c739" class="pw-post-body-paragraph kz la iq lc b ld le jr lf lg lh ju li lw lk ll lm lx lo lp lq ly ls lt lu lv ij bi translated">就是这样！有了这个，我们向六边形建筑迈出了第一步。还有很长的路要走。但目前就这样了。</p></div><div class="ab cl mc md hu me" role="separator"><span class="mf bw bk mg mh mi"/><span class="mf bw bk mg mh mi"/><span class="mf bw bk mg mh"/></div><div class="ij ik il im in"><h1 id="5cc8" class="mj mk iq bd ml mm mn mo mp mq mr ms mt jw mu jx mv jz mw ka mx kc my kd mz na bi translated">结论</h1><p id="2121" class="pw-post-body-paragraph kz la iq lc b ld nb jr lf lg nc ju li lw nd ll lm lx ne lp lq ly nf lt lu lv ij bi translated">六边形架构允许我们将域逻辑放在设计的中心。这是有代价的，但与我们的收获相比，这算不了什么。</p><p id="bdef" class="pw-post-body-paragraph kz la iq lc b ld le jr lf lg lh ju li lw lk ll lm lx lo lp lq ly ls lt lu lv ij bi translated">此外，这篇文章可能会给你一种印象，那就是所有关于领域逻辑的解耦。但是还有更多。它允许我们克服分层架构的许多其他缺点，如胖服务、无包边界等。</p><p id="dd93" class="pw-post-body-paragraph kz la iq lc b ld le jr lf lg lh ju li lw lk ll lm lx lo lp lq ly ls lt lu lv ij bi translated">这种设计真正允许开发人员在多个用例上并行工作。</p><p id="328a" class="pw-post-body-paragraph kz la iq lc b ld le jr lf lg lh ju li lw lk ll lm lx lo lp lq ly ls lt lu lv ij bi translated">感谢阅读！</p></div></div>    
</body>
</html>