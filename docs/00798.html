<html>
<head>
<title>A Beginner’s Guide to Docker</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">码头工人入门指南</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/a-beginners-guide-to-docker-4915d691b972?source=collection_archive---------9-----------------------#2019-07-15">https://betterprogramming.pub/a-beginners-guide-to-docker-4915d691b972?source=collection_archive---------9-----------------------#2019-07-15</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="bf1b" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">构建和配置第一个基于Docker的应用程序的完整教程</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/60abaedd3d07eb570ca68b4ad6f66c92.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*126sHZF_Xo8TVuk6ybWnlA.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">图片Via[<a class="ae ky" href="https://docker.com" rel="noopener ugc nofollow" target="_blank">https://docker.com</a></p></figure><p id="72c5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">你是最酷的孩子之一。你听说过Docker，知道你可以把你的代码打包在一个容器里，在一个隔离的环境下运行。您听说过许多公司正在使用它来构建、测试和部署他们从开发到生产的应用程序。但是你还没有机会和Docker一起工作。</p><p id="9f15" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我在想，如果这件事传出去，你还会是一个酷孩子吗？</p><p id="22ca" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">别担心。我自己也在那里。我不是专家，但我帮你搞定了。让我们准备好进入Docker。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="978b" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">后续步骤:</h1><ol class=""><li id="19fc" class="mu mv it lb b lc mw lf mx li my lm mz lq na lu nb nc nd ne bi translated">为什么要用Docker？</li><li id="bd5f" class="mu mv it lb b lc nf lf ng li nh lm ni lq nj lu nb nc nd ne bi translated">安装Docker</li><li id="9680" class="mu mv it lb b lc nf lf ng li nh lm ni lq nj lu nb nc nd ne bi translated">我将如何打包我所有的依赖项？</li><li id="8e92" class="mu mv it lb b lc nf lf ng li nh lm ni lq nj lu nb nc nd ne bi translated">我如何运行这个打包的映像？</li><li id="dd5d" class="mu mv it lb b lc nf lf ng li nh lm ni lq nj lu nb nc nd ne bi translated">我们如何配置docker基于图像的应用程序？</li></ol></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="1da9" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">1.为什么要用Docker？</h1><p id="b342" class="pw-post-body-paragraph kz la it lb b lc mw ju le lf mx jx lh li nk lk ll lm nl lo lp lq nm ls lt lu im bi translated">每个应用程序都有自己的依赖项集。假设我希望我的应用程序有一个完整的工作实例，传统的做法是使用脚本列出所有的依赖项，或者在Python应用程序的情况下使用<code class="fe nn no np nq b">requirements.txt</code>。</p><p id="6c05" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们来看看可能出现的一些问题:</p><ul class=""><li id="a274" class="mu mv it lb b lc ld lf lg li nr lm ns lq nt lu nu nc nd ne bi translated">我的需求成功地安装在我的机器上，但不是我同事的。啊，是的，臭名昭著的<code class="fe nn no np nq b">”Works on my machine!”</code>难题，因为操作系统/内核/系统级别的差异。</li><li id="fc11" class="mu mv it lb b lc nf lf ng li nh lm ni lq nj lu nu nc nd ne bi translated">我对我的应用程序所做的更改在我的机器上运行得非常完美，但是由于上面提到的差异，在生产环境中失败了。你能想象这有多恐怖吗？！</li><li id="fab3" class="mu mv it lb b lc nf lf ng li nh lm ni lq nj lu nu nc nd ne bi translated">我错误地配置了一些依赖项。我能以多快的速度推倒重来？</li></ul><p id="0fb3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">从上述问题来看，主题似乎是在<a class="ae ky" href="https://12factor.net/" rel="noopener ugc nofollow" target="_blank">https://12factor.net/</a>看到的<code class="fe nn no np nq b">The Twelve-Factor App</code>提到的环境平价有问题。这里的想法是，如果所有的环境都是对等的，难道我们不能用最少的默认配置构建应用程序一次，然后在环境/配置中需要时，用较小的覆盖更改在任何地方运行吗？</p><p id="0637" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">以下是一些问题:</p><ul class=""><li id="7b77" class="mu mv it lb b lc ld lf lg li nr lm ns lq nt lu nu nc nd ne bi translated">我们能不能<em class="nv">打包</em>我们的应用程序，让它可以带着它的依赖项在任何地方运行？</li><li id="096d" class="mu mv it lb b lc nf lf ng li nh lm ni lq nj lu nu nc nd ne bi translated">我们能否通过确保配置/打包在所有环境中尽可能保持一致来解决这个问题？</li><li id="d151" class="mu mv it lb b lc nf lf ng li nh lm ni lq nj lu nu nc nd ne bi translated">我们能否确保应用程序运行时在所有环境中保持几乎相同？</li><li id="b701" class="mu mv it lb b lc nf lf ng li nh lm ni lq nj lu nu nc nd ne bi translated">我们能否构建一次应用程序，然后在任何地方运行<em class="nv"/>？</li></ul><h1 id="76c5" class="mc md it bd me mf nw mh mi mj nx ml mm jz ny ka mo kc nz kd mq kf oa kg ms mt bi translated">码头工人来救援了！</h1><p id="667d" class="pw-post-body-paragraph kz la it lb b lc mw ju le lf mx jx lh li nk lk ll lm nl lo lp lq nm ls lt lu im bi translated"><a class="ae ky" href="https://www.docker.com/" rel="noopener ugc nofollow" target="_blank"> Docker </a>是一个<a class="ae ky" href="https://github.com/docker/docker" rel="noopener ugc nofollow" target="_blank">开源项目</a>，用于将任何应用程序打包成自给自足、可独立部署的单一单元，<em class="nv">又名</em>容器，可以在云、桌面或任何其他平台上运行。其思想是应用程序运行在完全隔离的环境中，该环境运行在Docker引擎之上，Docker引擎运行在主机操作系统之上。与传统的虚拟化软件相比，隔离的应用程序看起来有点像下图:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ob"><img src="../Images/5bbce6f072e5db8238dec76d6f07ffe5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*mS5c8IKskvmz5fDeDacGdA.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">图片来自[<a class="ae ky" href="https://docker.com" rel="noopener ugc nofollow" target="_blank">https://docker.com</a></p></figure></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="682a" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">2.安装Docker</h1><h2 id="41b6" class="oc md it bd me od oe dn mi of og dp mm li oh oi mo lm oj ok mq lq ol om ms on bi translated">我们从哪里开始？</h2><p id="b18f" class="pw-post-body-paragraph kz la it lb b lc mw ju le lf mx jx lh li nk lk ll lm nl lo lp lq nm ls lt lu im bi translated">首先，让我们从<a class="ae ky" href="https://docs.docker.com/install/#supported-platforms" rel="noopener ugc nofollow" target="_blank">https://docs.docker.com/install/#supported-platforms</a>下载并安装适合你操作系统的Docker CE(社区版)</p><h2 id="d835" class="oc md it bd me od oe dn mi of og dp mm li oh oi mo lm oj ok mq lq ol om ms on bi translated">验证Docker正在工作</h2><p id="fbc5" class="pw-post-body-paragraph kz la it lb b lc mw ju le lf mx jx lh li nk lk ll lm nl lo lp lq nm ls lt lu im bi translated">只需运行<code class="fe nn no np nq b">docker run hello-world</code>。如果您看到以下输出，则它正在工作:</p><pre class="kj kk kl km gt oo nq op oq aw or bi"><span id="0762" class="oc md it nq b gy os ot l ou ov">Unable to find image 'hello-world:latest' locally</span><span id="7ab2" class="oc md it nq b gy ow ot l ou ov">latest: Pulling from library/hello-world</span><span id="7101" class="oc md it nq b gy ow ot l ou ov">1b930d010525: Pull complete</span><span id="601f" class="oc md it nq b gy ow ot l ou ov">Digest: sha256:2557e3c07ed1e38f26e389462d03ed943586f744621577a99efb77324b0fe535</span><span id="51bc" class="oc md it nq b gy ow ot l ou ov">Status: Downloaded newer image for hello-world:latest</span><span id="7dfd" class="oc md it nq b gy ow ot l ou ov">Hello from Docker!</span><span id="1b57" class="oc md it nq b gy ow ot l ou ov">This message shows that your installation appears to be working correctly.</span><span id="a590" class="oc md it nq b gy ow ot l ou ov">To generate this message, Docker took the following steps:</span><span id="6a4d" class="oc md it nq b gy ow ot l ou ov">1. The Docker client contacted the Docker daemon.</span><span id="4250" class="oc md it nq b gy ow ot l ou ov">2. The Docker daemon pulled the "hello-world" image from the Docker Hub.</span><span id="c8ad" class="oc md it nq b gy ow ot l ou ov">(amd64)</span><span id="f614" class="oc md it nq b gy ow ot l ou ov">3. The Docker daemon created a new container from that image which runs the</span><span id="a04c" class="oc md it nq b gy ow ot l ou ov">executable that produces the output you are currently reading.</span><span id="455c" class="oc md it nq b gy ow ot l ou ov">4. The Docker daemon streamed that output to the Docker client, which sent it</span><span id="2d2a" class="oc md it nq b gy ow ot l ou ov">to your terminal.</span><span id="1625" class="oc md it nq b gy ow ot l ou ov">To try something more ambitious, you can run an Ubuntu container with:</span><span id="49e9" class="oc md it nq b gy ow ot l ou ov">$ docker run -it ubuntu bash</span><span id="da2b" class="oc md it nq b gy ow ot l ou ov">Share images, automate workflows, and more with a free Docker ID:</span><span id="39e6" class="oc md it nq b gy ow ot l ou ov"><a class="ae ky" href="https://hub.docker.com/" rel="noopener ugc nofollow" target="_blank">https://hub.docker.com/</a></span><span id="2303" class="oc md it nq b gy ow ot l ou ov">For more examples and ideas, visit:</span><span id="2472" class="oc md it nq b gy ow ot l ou ov"><a class="ae ky" href="https://docs.docker.com/get-started/" rel="noopener ugc nofollow" target="_blank">https://docs.docker.com/get-started/</a></span></pre><h2 id="55cc" class="oc md it bd me od oe dn mi of og dp mm li oh oi mo lm oj ok mq lq ol om ms on bi translated">恭喜你！</h2><p id="1aef" class="pw-post-body-paragraph kz la it lb b lc mw ju le lf mx jx lh li nk lk ll lm nl lo lp lq nm ls lt lu im bi translated">现在，您的机器上已经安装了一个可以工作的docker。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="f6ed" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">3.打包应用程序</h1><p id="ea57" class="pw-post-body-paragraph kz la it lb b lc mw ju le lf mx jx lh li nk lk ll lm nl lo lp lq nm ls lt lu im bi translated">现在我们已经在系统上安装了docker，让我们来探索如何使用Docker打包应用程序。</p><p id="2072" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">为了简单起见，让我们以一个非常简单的flask应用程序为例，它只打印出被调用的请求方法。</p><p id="3de7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在您的工作区中创建一个名为<code class="fe nn no np nq b">docker-demo</code>的文件夹。</p><p id="c22e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在创建一个名为<code class="fe nn no np nq b">app.py</code>的文件，内容如下:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ox oy l"/></div></figure><p id="4713" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们在同一个<code class="fe nn no np nq b">docker-demo</code>文件夹中为包依赖项创建一个<code class="fe nn no np nq b">requirements.txt</code>文件。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ox oy l"/></div></figure><p id="b508" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在我们已经准备好python应用程序和依赖项列表，让我们开始打包应用程序。</p><p id="a4a1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">一个<code class="fe nn no np nq b">Dockerfile</code>拥有将应用程序构建为Docker映像所需的所有步骤。在同一个<code class="fe nn no np nq b">docker-demo</code>文件夹中，我们创建一个名为<code class="fe nn no np nq b">Dockerfile</code>的文件，内容如下:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ox oy l"/></div></figure><p id="e550" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们仔细看看<code class="fe nn no np nq b">Dockerfile</code>中的每一行:</p><h2 id="69fd" class="oc md it bd me od oe dn mi of og dp mm li oh oi mo lm oj ok mq lq ol om ms on bi translated">第一行:</h2><p id="d181" class="pw-post-body-paragraph kz la it lb b lc mw ju le lf mx jx lh li nk lk ll lm nl lo lp lq nm ls lt lu im bi translated"><code class="fe nn no np nq b">FROM python:latest</code></p><p id="48c9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这一行告诉docker引擎，它必须将最新的可用<code class="fe nn no np nq b">python</code>图像作为应用程序图像的基础。</p><h2 id="cb4e" class="oc md it bd me od oe dn mi of og dp mm li oh oi mo lm oj ok mq lq ol om ms on bi translated">第二行:</h2><p id="98e3" class="pw-post-body-paragraph kz la it lb b lc mw ju le lf mx jx lh li nk lk ll lm nl lo lp lq nm ls lt lu im bi translated"><code class="fe nn no np nq b">COPY requirements.txt /usr/src/code/</code></p><p id="9ce9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这一行告诉docker引擎应该将文件<code class="fe nn no np nq b">requirements.txt</code>从我们当前的项目文件夹复制到最终图像上的路径<code class="fe nn no np nq b">/usr/src/code/</code></p><h2 id="e6a0" class="oc md it bd me od oe dn mi of og dp mm li oh oi mo lm oj ok mq lq ol om ms on bi translated">第3行:</h2><p id="ccd2" class="pw-post-body-paragraph kz la it lb b lc mw ju le lf mx jx lh li nk lk ll lm nl lo lp lq nm ls lt lu im bi translated"><code class="fe nn no np nq b">WORKDIR /usr/src/code/</code></p><p id="34ce" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这一行告诉我们当前的工作目录在图像中应该是<code class="fe nn no np nq b">/usr/src/code/</code></p><h2 id="76dd" class="oc md it bd me od oe dn mi of og dp mm li oh oi mo lm oj ok mq lq ol om ms on bi translated">第4行:</h2><p id="e2ad" class="pw-post-body-paragraph kz la it lb b lc mw ju le lf mx jx lh li nk lk ll lm nl lo lp lq nm ls lt lu im bi translated"><code class="fe nn no np nq b">RUN pip install -r requirements.txt</code></p><p id="b2b5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这一行确保我们的应用程序依赖项已经安装。</p><h2 id="fd50" class="oc md it bd me od oe dn mi of og dp mm li oh oi mo lm oj ok mq lq ol om ms on bi translated">第5行:</h2><p id="d57f" class="pw-post-body-paragraph kz la it lb b lc mw ju le lf mx jx lh li nk lk ll lm nl lo lp lq nm ls lt lu im bi translated"><code class="fe nn no np nq b">COPY . /usr/src/code/</code></p><p id="03ec" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这一行告诉我们将当前项目文件夹的内容复制到docker图像上的文件夹<code class="fe nn no np nq b">/usr/src/code/</code>中。</p><h2 id="39cc" class="oc md it bd me od oe dn mi of og dp mm li oh oi mo lm oj ok mq lq ol om ms on bi translated">第6行:</h2><p id="d9d4" class="pw-post-body-paragraph kz la it lb b lc mw ju le lf mx jx lh li nk lk ll lm nl lo lp lq nm ls lt lu im bi translated"><code class="fe nn no np nq b">CMD gunicorn --bind 0.0.0.0:8000 app:app</code></p><p id="c429" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这一行定义了运行最终docker映像时要运行的默认命令。</p><p id="629f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">既然我们已经对docker文件中的内容有了一些了解，让我们试着构建应用程序。</p><p id="593c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在shell上运行以下命令:</p><p id="a70f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe nn no np nq b">docker build . -f Dockerfile -t docker-demo</code></p><p id="8621" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这个命令基本上是说用当前文件夹<code class="fe nn no np nq b">.</code>的上下文运行<code class="fe nn no np nq b">Dockerfile </code>，并用名称<code class="fe nn no np nq b">docker-demo</code>标记结果图像。</p><p id="ea6c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果映像构建成功，您应该会看到以下输出:</p><pre class="kj kk kl km gt oo nq op oq aw or bi"><span id="2a37" class="oc md it nq b gy os ot l ou ov">docker-demo$ docker build . -f Dockerfile -t docker-demo<br/>Sending build context to Docker daemon  1.47MB<br/>Step 1/6 : FROM python:latest<br/> ---&gt; 4c0fd7901be8<br/>Step 2/6 : COPY requirements.txt /usr/src/code/<br/> ---&gt; Using cache<br/> ---&gt; 0ae7f5e0b8f1<br/>Step 3/6 : WORKDIR /usr/src/code<br/> ---&gt; Using cache<br/> ---&gt; 758680b1755e<br/>Step 4/6 : RUN pip install -r requirements.txt<br/> ---&gt; Using cache<br/> ---&gt; a4d56393776b<br/>Step 5/6 : COPY . /usr/src/code/<br/> ---&gt; e37d0a98dcd1<br/>Step 6/6 : CMD gunicorn --bind 0.0.0.0:8000 app:app<br/> ---&gt; Running in 4e30f7d4bb82<br/>Removing intermediate container 4e30f7d4bb82<br/> ---&gt; 041dbd6f6add<br/>Successfully built 041dbd6f6add<br/>Successfully tagged docker-demo:latest</span></pre></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="0d1c" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">4.运行Docker映像</h1><p id="8226" class="pw-post-body-paragraph kz la it lb b lc mw ju le lf mx jx lh li nk lk ll lm nl lo lp lq nm ls lt lu im bi translated">运行以下命令来运行现在打包为docker映像的应用程序:</p><p id="5955" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe nn no np nq b">docker run -p 8000:8000 docker-demo</code></p><p id="0891" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们已经使用<code class="fe nn no np nq b">-p</code> (publish)指令将容器中的应用程序运行端口<code class="fe nn no np nq b">8000</code>暴露给外部端口<code class="fe nn no np nq b">8000</code>。</p><p id="c90e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">一旦成功运行，您将看到以下输出:</p><pre class="kj kk kl km gt oo nq op oq aw or bi"><span id="1530" class="oc md it nq b gy os ot l ou ov">[2019-07-09 20:43:15 +0000] [6] [INFO] Starting gunicorn 19.9.0<br/>[2019-07-09 20:43:15 +0000] [6] [INFO] Listening at: <a class="ae ky" href="http://0.0.0.0:8000" rel="noopener ugc nofollow" target="_blank">http://0.0.0.0:8000</a> (6)<br/>[2019-07-09 20:43:15 +0000] [6] [INFO] Using worker: sync<br/>[2019-07-09 20:43:15 +0000] [9] [INFO] Booting worker with pid: 9</span></pre><p id="1e9b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">您可以从主机使用<code class="fe nn no np nq b">curl</code>测试应用程序URL。</p><pre class="kj kk kl km gt oo nq op oq aw or bi"><span id="605a" class="oc md it nq b gy os ot l ou ov">docker-demo$ curl 'http://localhost:8000/hello?name=Kishan'<br/>Hello Kishan<br/>docker-demo$ curl 'http://localhost:8000/hello'<br/>Hello John Doe</span></pre><p id="12fe" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">您现在已经使用Docker运行了一个应用程序！</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="4139" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">5.配置基于Docker的应用程序</h1><p id="2cd8" class="pw-post-body-paragraph kz la it lb b lc mw ju le lf mx jx lh li nk lk ll lm nl lo lp lq nm ls lt lu im bi translated">现在我们已经构建好了，让我们考虑一下配置应用程序的真实场景。通常，任何应用程序都有一个合理的默认值，然后您可以根据需要在每个环境中覆盖它。</p><p id="f625" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">应用程序使用两种类型的配置:</p><ul class=""><li id="938a" class="mu mv it lb b lc ld lf lg li nr lm ns lq nt lu nu nc nd ne bi translated">环境变量</li><li id="64c6" class="mu mv it lb b lc nf lf ng li nh lm ni lq nj lu nu nc nd ne bi translated">基于文件的流程配置</li></ul><p id="ab06" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们对应用程序进行更改，以便它根据配置做一些不同的事情。</p><h2 id="de9c" class="oc md it bd me od oe dn mi of og dp mm li oh oi mo lm oj ok mq lq ol om ms on bi translated">A.基于环境变量的配置</h2><p id="10a8" class="pw-post-body-paragraph kz la it lb b lc mw ju le lf mx jx lh li nk lk ll lm nl lo lp lq nm ls lt lu im bi translated">让我们假设您的应用程序必须根据当前环境做一些不同的事情。为了简单起见，我刚刚编辑了之前的Flask应用程序，我们必须打印出关于当前环境的额外信息:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ox oy l"/></div></figure><p id="0d94" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这里，应用程序被配置为在发送响应时使用环境变量<code class="fe nn no np nq b">env</code>。如果在<code class="fe nn no np nq b">env</code>中没有得到任何值，则默认为<code class="fe nn no np nq b">prod</code>。</p><p id="0ff2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在让我们也在docker文件中做一些更改:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ox oy l"/></div></figure><p id="93ec" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">您可能会注意到这一行:<code class="fe nn no np nq b">ENV env prod</code></p><p id="44e5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">一旦构建了这个映像，这实际上就向应用程序运行时注入了一个值为<code class="fe nn no np nq b">prod</code>的环境变量<code class="fe nn no np nq b">env</code>。</p><p id="b550" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在让我们来试试这个:</p><pre class="kj kk kl km gt oo nq op oq aw or bi"><span id="b9a0" class="oc md it nq b gy os ot l ou ov">docker build . -t docker-demo:env</span></pre><p id="788b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们将这张新图片标记为<code class="fe nn no np nq b">docker-image:env</code>。</p><p id="fbc3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在运行这个容器之前，您可能想使用CTRL^C退出现有的旧容器，如果您还没有这样做的话。</p><p id="b287" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们运行这个新图像:</p><pre class="kj kk kl km gt oo nq op oq aw or bi"><span id="6d85" class="oc md it nq b gy os ot l ou ov">docker-demo$ docker run --rm --name docker-demo -p 8000:8000 docker-demo:env<br/>[2019-07-13 12:29:24 +0000] [6] [INFO] Starting gunicorn 19.9.0<br/>[2019-07-13 12:29:24 +0000] [6] [INFO] Listening at: <a class="ae ky" href="http://0.0.0.0:8000" rel="noopener ugc nofollow" target="_blank">http://0.0.0.0:8000</a> (6)<br/>[2019-07-13 12:29:24 +0000] [6] [INFO] Using worker: sync<br/>[2019-07-13 12:29:24 +0000] [9] [INFO] Booting worker with pid: 9</span></pre><p id="0eaa" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">您可能会注意到两个新选项:<code class="fe nn no np nq b">--rm</code>和<code class="fe nn no np nq b">--name</code></p><p id="aba5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe nn no np nq b">--rm</code>告诉docker引擎一旦退出就删除这个容器。</p><p id="0993" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe nn no np nq b">—-name</code>告诉将容器命名为<code class="fe nn no np nq b">docker-demo</code></p><p id="4fe7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们进行一个API调用。</p><pre class="kj kk kl km gt oo nq op oq aw or bi"><span id="30b1" class="oc md it nq b gy os ot l ou ov">docker-demo$ curl '<a class="ae ky" href="http://localhost:8000/hello?name=Kishan'" rel="noopener ugc nofollow" target="_blank">http://localhost:8000/hello?name=Kishan'</a><br/>Hello Kishan from 'prod'</span></pre><p id="6f71" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在，我们看到应用程序正在使用Dockerfile文件中的已配置环境。我们来验证一下怎么样？</p><p id="bcf4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们使用<code class="fe nn no np nq b">bash</code>登录到正在运行的容器</p><pre class="kj kk kl km gt oo nq op oq aw or bi"><span id="f13d" class="oc md it nq b gy os ot l ou ov">docker-demo$ docker exec -it docker-demo bash<br/>root@6160a487196c:/usr/src/code# echo $env<br/>prod<br/>root@6160a487196c:/usr/src/code#</span></pre><p id="0f77" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">瞧啊。</p><p id="d13b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在，让我们假设我在一个名为<code class="fe nn no np nq b">dev</code>的不同环境中，因为我遇到了一个错误，并且想要重现它。我应该如何为不同的环境覆盖<code class="fe nn no np nq b">env</code>配置？让我们尝试在docker容器启动期间更改环境变量<code class="fe nn no np nq b">env</code>:</p><pre class="kj kk kl km gt oo nq op oq aw or bi"><span id="509d" class="oc md it nq b gy os ot l ou ov">docker-demo$ docker run --rm --name docker-demo -e env=dev -p 8000:8000 docker-demo:env<br/>[2019-07-13 12:29:24 +0000] [6] [INFO] Starting gunicorn 19.9.0<br/>[2019-07-13 12:29:24 +0000] [6] [INFO] Listening at: <a class="ae ky" href="http://0.0.0.0:8000" rel="noopener ugc nofollow" target="_blank">http://0.0.0.0:8000</a> (6)<br/>[2019-07-13 12:29:24 +0000] [6] [INFO] Using worker: sync<br/>[2019-07-13 12:29:24 +0000] [9] [INFO] Booting worker with pid: 9</span></pre><p id="453a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">真的那么容易吗？我们打个API电话怎么样？</p><pre class="kj kk kl km gt oo nq op oq aw or bi"><span id="6100" class="oc md it nq b gy os ot l ou ov">docker-demo$ curl '<a class="ae ky" href="http://localhost:8000/hello?name=Kishan'" rel="noopener ugc nofollow" target="_blank">http://localhost:8000/hello?name=Kishan'</a><br/>Hello Kishan from 'dev'</span></pre><p id="36d4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu">引人深思:</strong>如果你注意到了，我们只构建了一次应用程序<em class="nv"/>。但是，我们已经覆盖了配置变量，从而使它在不同的<em class="nv">环境</em>下运行。</p><h2 id="ec2e" class="oc md it bd me od oe dn mi of og dp mm li oh oi mo lm oj ok mq lq ol om ms on bi translated">b.基于文件的配置</h2><p id="c980" class="pw-post-body-paragraph kz la it lb b lc mw ju le lf mx jx lh li nk lk ll lm nl lo lp lq nm ls lt lu im bi translated">一如既往，事情从来没有你想象的那么简单。使用环境变量并不能解决所有问题。您可能最终会为uwsgi、supervisor、gunicorn、nginx等编写配置文件。其配置不能放在环境变量中。</p><p id="0cd7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">为了简单起见，让我们配置gunicorn的主机和端口绑定配置。</p><p id="940a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">gunicorn接受任何有效的python文件作为配置。</p><p id="9221" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们创建一个名为<code class="fe nn no np nq b">configuration.py</code>的新文件，内容如下:</p><p id="675f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe nn no np nq b">bind = "0.0.0.0:8000"</code></p><p id="b359" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们更改docker文件的最后一行，以支持我们的新配置。</p><p id="9b99" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">出发地:</p><pre class="kj kk kl km gt oo nq op oq aw or bi"><span id="37ac" class="oc md it nq b gy os ot l ou ov">CMD gunicorn --bind 0.0.0.0:8000 app:app</span></pre><p id="967a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">收件人:</p><pre class="kj kk kl km gt oo nq op oq aw or bi"><span id="8b45" class="oc md it nq b gy os ot l ou ov">CMD gunicorn -c configuration.py app:app</span></pre><p id="0c81" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们构建图像，并给它一个新的标签。</p><pre class="kj kk kl km gt oo nq op oq aw or bi"><span id="fbd6" class="oc md it nq b gy os ot l ou ov">docker build . -t docker-demo:config</span></pre><p id="bbe6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在让我们运行应用程序:</p><pre class="kj kk kl km gt oo nq op oq aw or bi"><span id="34c5" class="oc md it nq b gy os ot l ou ov">docker-demo$ docker run --rm --name docker-demo -p 8000:8000 docker-demo:config<br/>[2019-07-13 13:33:09 +0000] [6] [INFO] Starting gunicorn 19.9.0<br/>[2019-07-13 13:33:09 +0000] [6] [INFO] Listening at: <a class="ae ky" href="http://0.0.0.0:8000" rel="noopener ugc nofollow" target="_blank">http://0.0.0.0:8000</a> (6)<br/>[2019-07-13 13:33:09 +0000] [6] [INFO] Using worker: sync<br/>[2019-07-13 13:33:09 +0000] [9] [INFO] Booting worker with pid: 9</span></pre><p id="ab27" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们可以看到应用程序已经成功地从configuration.py文件中获取了配置，并在<code class="fe nn no np nq b">0.0.0.0:8000</code>上绑定了它。</p><p id="90df" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们来谈谈如何超越这一点。</p><p id="7c90" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在环境变量的情况下，我们可以使用<code class="fe nn no np nq b">-e</code>开关来覆盖应用程序容器中的现有环境。我们如何为一个文件这样做呢？</p><p id="0c4d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">Docker <a class="ae ky" href="https://docs.docker.com/storage/volumes/" rel="noopener ugc nofollow" target="_blank"> volumes </a>通过将主机目录/文件暴露到容器中，是将持久性放入应用程序容器的一种方式。默认情况下，容器没有任何内置的持久性，因为它们应该是轻量级的、隔离的、易于拆卸和重建的。Docker卷是展示配置、日志等的绝佳方式。到/从集装箱。</p><p id="cd8a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在我们的场景中，我们需要的是更改<code class="fe nn no np nq b">configuration.py</code>的内容，然后在运行映像时使用这个新配置，而不必再次构建docker映像。</p><p id="9210" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们创建一个名为<code class="fe nn no np nq b">configuration2.py</code>的文件，内容如下:</p><pre class="kj kk kl km gt oo nq op oq aw or bi"><span id="3c1e" class="oc md it nq b gy os ot l ou ov">bind = "0.0.0.0:9000"</span></pre><p id="a321" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在这里，我们实际上是将gunicorn的绑定配置从端口8000更改为9000。</p><p id="3c68" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们用下面的命令终止以前的容器并启动一个新的容器:</p><pre class="kj kk kl km gt oo nq op oq aw or bi"><span id="d0fe" class="oc md it nq b gy os ot l ou ov">docker-demo$ docker run --rm --name docker-demo -v `pwd`/configuration2.py:/usr/src/code/configuration.py -p 8000:9000 docker-demo:config<br/>[2019-07-13 13:52:30 +0000] [7] [INFO] Starting gunicorn 19.9.0<br/>[2019-07-13 13:52:30 +0000] [7] [INFO] Listening at: <a class="ae ky" href="http://0.0.0.0:9000" rel="noopener ugc nofollow" target="_blank">http://0.0.0.0:9000</a> (7)<br/>[2019-07-13 13:52:30 +0000] [7] [INFO] Using worker: sync<br/>[2019-07-13 13:52:30 +0000] [10] [INFO] Booting worker with pid: 10</span></pre><p id="409f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们使用<code class="fe nn no np nq b">-v</code>开关在主机上创建文件<code class="fe nn no np nq b">configuration2.py</code>的一个卷，然后将它挂载到映像中的文件<code class="fe nn no np nq b">configuration.py</code>上，从而用<code class="fe nn no np nq b">configuration2.py</code>的内容替换它的内容。如您所见，应用程序现在运行在端口<code class="fe nn no np nq b">9000</code>上，正如新配置中所写的那样。</p><p id="ddb9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果您再次注意到，我们已经覆盖了配置，而不必重新构建应用程序。</p><p id="c26f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们进行API调用:</p><pre class="kj kk kl km gt oo nq op oq aw or bi"><span id="8123" class="oc md it nq b gy os ot l ou ov">docker-demo$ curl '<a class="ae ky" href="http://localhost:8000/hello?name=Kishan'" rel="noopener ugc nofollow" target="_blank">http://localhost:8000/hello?name=Kishan'</a><br/>Hello Kishan from 'prod'</span></pre><p id="8eb7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们的教程到此结束！</p><p id="170f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们在本教程中完成的内容:</p><ul class=""><li id="1a18" class="mu mv it lb b lc ld lf lg li nr lm ns lq nt lu nu nc nd ne bi translated">写了一个REST应用。</li><li id="5063" class="mu mv it lb b lc nf lf ng li nh lm ni lq nj lu nu nc nd ne bi translated">编写了应用程序的依赖项。</li><li id="210b" class="mu mv it lb b lc nf lf ng li nh lm ni lq nj lu nu nc nd ne bi translated">为应用程序编写Dockerfile规范。</li><li id="7898" class="mu mv it lb b lc nf lf ng li nh lm ni lq nj lu nu nc nd ne bi translated">使用Dockerfile文件构建应用程序，并用名称标记图像。</li><li id="ef06" class="mu mv it lb b lc nf lf ng li nh lm ni lq nj lu nu nc nd ne bi translated">运行docker映像并测试URL端点。</li><li id="c233" class="mu mv it lb b lc nf lf ng li nh lm ni lq nj lu nu nc nd ne bi translated">使用环境变量和配置文件配置应用程序</li><li id="6ec7" class="mu mv it lb b lc nf lf ng li nh lm ni lq nj lu nu nc nd ne bi translated">在运行时覆盖环境变量和配置文件的配置，而不重建映像。(又名<em class="nv">构建一次，随处运行</em>)</li></ul><p id="08fd" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如需进一步阅读，请查看以下链接:</p><ul class=""><li id="4bae" class="mu mv it lb b lc ld lf lg li nr lm ns lq nt lu nu nc nd ne bi translated"><a class="ae ky" href="https://docs.docker.com/develop/develop-images/dockerfile_best-practices/" rel="noopener ugc nofollow" target="_blank"> Dockerfile最佳实践</a></li><li id="07df" class="mu mv it lb b lc nf lf ng li nh lm ni lq nj lu nu nc nd ne bi translated"><a class="ae ky" href="https://docs.docker.com/network/" rel="noopener ugc nofollow" target="_blank"> Docker联网</a></li><li id="53d1" class="mu mv it lb b lc nf lf ng li nh lm ni lq nj lu nu nc nd ne bi translated"><a class="ae ky" href="https://docs.docker.com/get-started/part3/" rel="noopener ugc nofollow" target="_blank"> Docker撰写</a></li></ul><h1 id="5020" class="mc md it bd me mf nw mh mi mj nx ml mm jz ny ka mo kc nz kd mq kf oa kg ms mt bi translated">结论</h1><p id="583d" class="pw-post-body-paragraph kz la it lb b lc mw ju le lf mx jx lh li nk lk ll lm nl lo lp lq nm ls lt lu im bi translated">祝贺您完成本教程！</p><p id="2c15" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这篇博文中使用的代码可以在<a class="ae ky" href="https://github.com/kishanreddykethu/docker-demo" rel="noopener ugc nofollow" target="_blank">这里</a>找到。提交历史与我们已经讨论过的例子一致。我要特别感谢<a class="ae ky" href="https://www.linkedin.com/in/lalitanand-dandge-456076a/" rel="noopener ugc nofollow" target="_blank">拉利特</a>和<a class="ae ky" href="https://www.linkedin.com/in/nihar-rathod/" rel="noopener ugc nofollow" target="_blank">尼哈尔</a>校对了我的漫谈，并就本教程应该涵盖的内容给出了很好的建议。</p></div></div>    
</body>
</html>