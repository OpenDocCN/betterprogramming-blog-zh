<html>
<head>
<title>Building Restful APIs With Flask and SQLAlchemy (Part 1)</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">用Flask和SQLAlchemy构建Restful APIs(第1部分)</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/building-restful-apis-with-flask-and-sqlalchemy-part-1-b192c5846ddd?source=collection_archive---------1-----------------------#2020-12-14">https://betterprogramming.pub/building-restful-apis-with-flask-and-sqlalchemy-part-1-b192c5846ddd?source=collection_archive---------1-----------------------#2020-12-14</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="30dd" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">立即创建您的第一个Python API</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/85c0024fdabc9063ffb3705620230154.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*8W_ToO7cCGQrXP16"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">阿里·洛克汉瓦拉在<a class="ae kv" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的照片</p></figure><p id="d038" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我决定写一篇关于用Flask构建RESTful APIs的文章。因此，我们将为待办事项应用程序构建一个API。该API将允许用户登录、创建、读取、更新和删除待办事项，但不能看到其他用户创建的待办事项。</p><p id="7946" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">也将有一个管理部分。作为管理员，您可以看到所有用户和待办事项的详细信息。管理员也可以过滤他们的搜索结果。</p><p id="0a0a" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这将是一段漫长的旅程——因此，我决定将这篇文章分成三部分。这一部分将只关注构建用户和待办事项功能。第二部分将介绍身份验证和授权。最后一节将关注代码重构和错误处理。我还将向您介绍Flask-Restful，这是一个Flask扩展，用于使用Flask轻松构建RESTful APIs。</p><p id="e796" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我很兴奋能和你一起开始，我希望你也是。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi ls"><img src="../Images/8018178b3cb3244b6cd8c2728086f1d5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*VgrPsoent39WOhUI"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">照片由<a class="ae kv" href="https://unsplash.com/@steve3p_0?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">史蒂夫·哈拉马</a>在<a class="ae kv" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</p></figure></div><div class="ab cl lt lu hu lv" role="separator"><span class="lw bw bk lx ly lz"/><span class="lw bw bk lx ly lz"/><span class="lw bw bk lx ly"/></div><div class="ij ik il im in"><h1 id="f0bb" class="ma mb iq bd mc md me mf mg mh mi mj mk jw ml jx mm jz mn ka mo kc mp kd mq mr bi translated">入门指南</h1><h2 id="c163" class="ms mb iq bd mc mt mu dn mg mv mw dp mk lf mx my mm lj mz na mo ln nb nc mq nd bi translated">微观框架</h2><p id="976f" class="pw-post-body-paragraph kw kx iq ky b kz ne jr lb lc nf ju le lf ng lh li lj nh ll lm ln ni lp lq lr ij bi translated">Flask是Python中web开发(后端)的微框架。尽管它是一个微框架，但我们可以构建一个复杂的应用程序，它可以很好地与Flask一起伸缩。</p><p id="4d61" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">那么<em class="nj">微框架</em> <strong class="ky ir"> </strong>是什么意思呢？这意味着它不会把任何东西强加给我们——我们可以决定使用一种工具而不是另一种。本文将带您了解如何用Flask构建restful APIs。如果你是Flask的新手，并且想了解如何设置Flask应用程序，你可以阅读我的文章<a class="ae kv" href="https://medium.com/swlh/building-your-first-flask-app-753638ef9d7" rel="noopener">中关于这方面的内容。</a></p><h2 id="85ba" class="ms mb iq bd mc mt mu dn mg mv mw dp mk lf mx my mm lj mz na mo ln nb nc mq nd bi translated">应用程序接口</h2><p id="716f" class="pw-post-body-paragraph kw kx iq ky b kz ne jr lb lc nf ju le lf ng lh li lj nh ll lm ln ni lp lq lr ij bi translated">在我们开始在Flask中构建我们的API之前，让我们先来定义什么是API，并确定我们的API将会如何。API <em class="nj"> </em>代表应用程序编程接口，它就像一个连接/中介，允许两个应用程序相互通信——比如服务器和客户端。</p><p id="d61f" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">服务器是后端(在这种情况下，是Flask)，但客户端不一定是web浏览器，它可以是移动应用程序或单页应用程序(SPA)。这是API重要的一个原因。<a class="ae kv" href="https://www.freecodecamp.org/news/what-is-an-api-in-english-please-b880a3214a82/" rel="noopener ugc nofollow" target="_blank">这篇文章</a>深入探讨了什么是API<em class="nj">。</em></p><p id="0c94" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">现在我们已经了解了什么是API，让我们更深入地讨论Restful APIs。RESTful APIs允许我们使用HTTP请求(<code class="fe nk nl nm nn b">GET</code>、<code class="fe nk nl nm nn b">POST</code>、<code class="fe nk nl nm nn b">PUT</code>、<code class="fe nk nl nm nn b">DELETE</code>、<code class="fe nk nl nm nn b">PATCH</code>等)。).构建Restful APIs时需要遵循一些规则——我将在下面列出。</p><ol class=""><li id="877d" class="no np iq ky b kz la lc ld lf nq lj nr ln ns lr nt nu nv nw bi translated"><strong class="ky ir">客户端—服务器:</strong>客户端和服务器相互独立。</li><li id="046a" class="no np iq ky b kz nx lc ny lf nz lj oa ln ob lr nt nu nv nw bi translated"><strong class="ky ir">无状态:</strong>客户端发送的请求必须包含所有必要的信息；服务器不得存储有关客户端的任何状态。</li><li id="d937" class="no np iq ky b kz nx lc ny lf nz lj oa ln ob lr nt nu nv nw bi translated"><strong class="ky ir">缓存:</strong>服务器可以将响应标记为可缓存或不可缓存。</li><li id="0e78" class="no np iq ky b kz nx lc ny lf nz lj oa ln ob lr nt nu nv nw bi translated">统一资源:客户端必须使用统一的、定义良好的、标准化的协议来访问服务器。大多数RESTful APIs中常用的协议是HTTP和HTTPS协议。</li><li id="cdee" class="no np iq ky b kz nx lc ny lf nz lj oa ln ob lr nt nu nv nw bi translated"><strong class="ky ir">分层系统:</strong>可以在客户端和服务器之间插入代理服务器来提高性能。</li><li id="759e" class="no np iq ky b kz nx lc ny lf nz lj oa ln ob lr nt nu nv nw bi translated">客户端可以选择从服务器下载代码。</li><li id="a889" class="no np iq ky b kz nx lc ny lf nz lj oa ln ob lr nt nu nv nw bi translated">大多数API用<strong class="ky ir"> JSON </strong>响应，但有些使用XML(不常见)。</li><li id="b781" class="no np iq ky b kz nx lc ny lf nz lj oa ln ob lr nt nu nv nw bi translated">允许<strong class="ky ir">过滤数据</strong>。</li></ol><h2 id="4275" class="ms mb iq bd mc mt mu dn mg mv mw dp mk lf mx my mm lj mz na mo ln nb nc mq nd bi translated">HTTP动词</h2><p id="a83a" class="pw-post-body-paragraph kw kx iq ky b kz ne jr lb lc nf ju le lf ng lh li lj nh ll lm ln ni lp lq lr ij bi translated">我上面提到了HTTP动词，但是它们是什么呢？</p><p id="7d44" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">HTTP动词只是我们用来告诉端点我们想要做什么的方法。虽然有些HTTP动词可以用来代替其他的，但这不是一个好的做法。使用最恰当的动词提出或处理请求。HTTP动词有很多——有些是<code class="fe nk nl nm nn b">GET</code>、<code class="fe nk nl nm nn b">POST</code>、<code class="fe nk nl nm nn b">PUT</code>、<code class="fe nk nl nm nn b">PATCH</code>、<code class="fe nk nl nm nn b">DELETE</code>、<code class="fe nk nl nm nn b">HEAD</code>等。我将解释四种最常见的。</p><ol class=""><li id="5514" class="no np iq ky b kz la lc ld lf nq lj nr ln ns lr nt nu nv nw bi translated"><code class="fe nk nl nm nn b">GET</code>:<code class="fe nk nl nm nn b">GET</code>方法用于从服务器获取资源。它根据资源路径从服务器获取数据，资源路径可能包括用于过滤我们想要返回的内容的查询参数。从使用此方法的资源路径返回的状态代码应该是200，表示正常。</li><li id="a972" class="no np iq ky b kz nx lc ny lf nz lj oa ln ob lr nt nu nv nw bi translated"><code class="fe nk nl nm nn b">POST</code>:<code class="fe nk nl nm nn b">POST</code>方法用于为服务器创建一个新的资源。从使用此方法的资源路径返回的状态代码应该是201，表示已创建。该资源不应返回任何值。</li><li id="9eb2" class="no np iq ky b kz nx lc ny lf nz lj oa ln ob lr nt nu nv nw bi translated"><code class="fe nk nl nm nn b">PUT</code>:<code class="fe nk nl nm nn b">PUT</code>方法用于更新服务器中的资源。从使用此方法的资源路径返回的状态代码应该是200，表示正常，或者204，表示没有内容。</li><li id="b241" class="no np iq ky b kz nx lc ny lf nz lj oa ln ob lr nt nu nv nw bi translated"><code class="fe nk nl nm nn b">DELETE</code>:<code class="fe nk nl nm nn b">DELETE</code>方法用于删除服务器上的资源。从使用此方法的资源路径返回的状态代码应该是200，表示正常，或者204，表示没有内容。</li></ol><h2 id="913c" class="ms mb iq bd mc mt mu dn mg mv mw dp mk lf mx my mm lj mz na mo ln nb nc mq nd bi translated">构建我们的API</h2><p id="cfe9" class="pw-post-body-paragraph kw kx iq ky b kz ne jr lb lc nf ju le lf ng lh li lj nh ll lm ln ni lp lq lr ij bi translated">既然我们已经花了一些时间来理解什么是API，那么让我们来考虑我们的API将是什么以及如何构造的。我可以决定从服务器或单个用户获取所有用户的数组。我还可以创建用户或更新用户详细信息。所有这些都有各自的HTTP请求。</p><ul class=""><li id="fe7e" class="no np iq ky b kz la lc ld lf nq lj nr ln ns lr oc nu nv nw bi translated"><code class="fe nk nl nm nn b">GET users/</code>:检索所有用户</li><li id="db69" class="no np iq ky b kz nx lc ny lf nz lj oa ln ob lr oc nu nv nw bi translated"><code class="fe nk nl nm nn b">GET users/id/</code>:检索单个用户</li><li id="94ba" class="no np iq ky b kz nx lc ny lf nz lj oa ln ob lr oc nu nv nw bi translated"><code class="fe nk nl nm nn b">POST users/</code>:创建新用户</li><li id="4f59" class="no np iq ky b kz nx lc ny lf nz lj oa ln ob lr oc nu nv nw bi translated"><code class="fe nk nl nm nn b">PUT users/id/</code>:更新现有用户</li><li id="2841" class="no np iq ky b kz nx lc ny lf nz lj oa ln ob lr oc nu nv nw bi translated"><code class="fe nk nl nm nn b">DELETE users/id/</code>:删除已有用户</li><li id="cfee" class="no np iq ky b kz nx lc ny lf nz lj oa ln ob lr oc nu nv nw bi translated"><code class="fe nk nl nm nn b">GET todos/</code>:检索所有待办事项</li><li id="83c7" class="no np iq ky b kz nx lc ny lf nz lj oa ln ob lr oc nu nv nw bi translated"><code class="fe nk nl nm nn b">Get todos/id/</code>:检索单个待办事项</li><li id="005f" class="no np iq ky b kz nx lc ny lf nz lj oa ln ob lr oc nu nv nw bi translated"><code class="fe nk nl nm nn b">POST todos/</code>:创建新的待办事项</li><li id="5922" class="no np iq ky b kz nx lc ny lf nz lj oa ln ob lr oc nu nv nw bi translated"><code class="fe nk nl nm nn b">PUT todos/id/</code>:更新现有的待办事项</li><li id="7871" class="no np iq ky b kz nx lc ny lf nz lj oa ln ob lr oc nu nv nw bi translated"><code class="fe nk nl nm nn b">DELETE todos/id/</code>:删除现有的待办事项</li></ul><h2 id="1199" class="ms mb iq bd mc mt mu dn mg mv mw dp mk lf mx my mm lj mz na mo ln nb nc mq nd bi translated">SQLAlchemy</h2><p id="0813" class="pw-post-body-paragraph kw kx iq ky b kz ne jr lb lc nf ju le lf ng lh li lj nh ll lm ln ni lp lq lr ij bi translated">现在我们来谈谈SQLAlchemy。</p><p id="f2e2" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">SQLAlchemy到底是什么？SQLAlchemy是一个对象关系映射器(ORM)。这意味着使用SQLAlchemy，我们不必编写原始的SQL命令。我们所需要做的就是以类(对象)的形式创建模型，SQLAlchemy将完成将它们转换成SQL(关系数据库)的工作——因此得名<em class="nj">对象关系映射器。</em></p><p id="0bb4" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们可以用ORM做很多事情——从做普通的查询到插入、更新和删除，再到做高级的事情，比如连接、合并等等。SQLAlchemy官网有更多信息<a class="ae kv" href="https://www.sqlalchemy.org/" rel="noopener ugc nofollow" target="_blank">这里</a> <em class="nj">。</em>但是在本文中，我们将使用SQLAlchemy的Flask包装器，即<a class="ae kv" href="https://flask-sqlalchemy.palletsprojects.com/en/2.x/" rel="noopener ugc nofollow" target="_blank"> Flask-SQLAlchemy </a>。</p><h2 id="e711" class="ms mb iq bd mc mt mu dn mg mv mw dp mk lf mx my mm lj mz na mo ln nb nc mq nd bi translated">创建我们的API</h2><p id="c447" class="pw-post-body-paragraph kw kx iq ky b kz ne jr lb lc nf ju le lf ng lh li lj nh ll lm ln ni lp lq lr ij bi translated">让我们开始创建我们的API。我们将从安装依赖项开始。我们只需要两个:烧瓶和烧瓶-SQLAlchemy。</p><p id="3eb7" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">让我们设置我们的Flask应用程序，我将使用Postman来测试我的API——如果你不知道那是什么，你可以在这里查看<em class="nj">。</em></p><p id="7668" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我简单说几个关于Postman的事情，以及它有多好用。Postman是一个用于验证项目API的交互式自动工具。Postman是一款谷歌Chrome桌面应用(曾经是Chrome的扩展)，用于与HTTP APIs交互。它还支持GraphQL。它为您提供了一个友好的GUI来构造请求和读取响应。</p><p id="2c30" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">如果您愿意，您可以随时使用任何HTTP库来测试API。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi od"><img src="../Images/cd6005e5525e478c478e54633aa2580f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1380/format:webp/1*vKKweff06Iu0IwjDe9KN6w.png"/></div></figure><p id="55ea" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">让我们测试应用程序。用<code class="fe nk nl nm nn b">flask run</code>、<strong class="ky ir">、</strong>运行服务器，向<code class="fe nk nl nm nn b">localhost:5000/</code>发送请求。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi oe"><img src="../Images/3cb1df571d7c92c90ffe8380ce9c7593.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*bwVHelLKSMe_TL2O9nmsFQ.png"/></div></div></figure><p id="53de" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们可以看到，当我们向端点<code class="fe nk nl nm nn b">/</code>、<strong class="ky ir">、</strong>发送请求时，我们得到了我们想要的，这意味着一切都运行良好。</p><p id="2c74" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">是时候构建我们的用户和待办事项模型了，这样我们就可以为用户模型定义端点。这两个模型将具有一对多的关系，即一个用户可以有多个待办事项，而一个待办事项需要有一个用户。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi of"><img src="../Images/119222c8eb3120ecb9b9e0a05181f4b8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1294/format:webp/1*6F6elp1eJxEQTLnMvdbMeQ.png"/></div></figure><p id="caab" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这里发生了很多事！我们来详细的过一遍。</p><p id="a28f" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">首先，我们从Flask-SQLAlchemy导入SQLAlchemy，并将其连接到我们的应用程序。</p><p id="5434" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">接下来，我们在应用程序中添加了两个<code class="fe nk nl nm nn b">config</code>变量。第一个是密钥，这是一个用于保护我们的应用程序的秘密变量。它被一些与安全性有关的中间件(扩展)使用(目前我们还没有——当我们到达认证部分时，我们将使用它)。第二个是<code class="fe nk nl nm nn b">SQLALCHEMY_DATABASE_URI</code>，它是我们应用程序的数据库curl。这里我使用的是SQLite，但是您也可以使用您选择的任何SQL数据库(例如MySQL)。那么该值将是<code class="fe nk nl nm nn b">mysql://username:password@server/db</code>。你可以查看他们的官方文档<a class="ae kv" href="https://flask-sqlalchemy.palletsprojects.com/en/2.x/config/" rel="noopener ugc nofollow" target="_blank">以获得更多细节和其他配置变量的列表。</a></p><p id="8b85" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">然后我们定义了我们的用户模型，它从<code class="fe nk nl nm nn b">db.Model</code> <strong class="ky ir"> </strong>类扩展而来。</p><p id="09f4" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">最后，我们定义了列。<code class="fe nk nl nm nn b">db.Column</code>用于创建一个列。我们定义的第一列是由SQL自动创建的<code class="fe nk nl nm nn b">id</code>、<strong class="ky ir">、</strong>。第二列是姓名和电子邮件字段，必须是字符串。此外，电子邮件字段是唯一的。</p><p id="8c29" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我还添加了一个<code class="fe nk nl nm nn b">public_id</code>字段，这是我希望用作路由参数的字段，因为SQL将<code class="fe nk nl nm nn b">id</code>作为一个整数给出，我希望有一个类似于UUID值的值，类似于我们从Mongo ID中得到的值。</p><p id="94ab" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我还添加了一个<code class="fe nk nl nm nn b">is_admin</code> <strong class="ky ir"> </strong>字段/列，我们将使用它进行授权。</p><p id="b625" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">最后，我们添加了一个<code class="fe nk nl nm nn b">todos</code>字段，顾名思义(关系)，它是我们用来连接到待办事项模型的。这部分取三个值:第一个和其他类似，是它所在的字段类型。第二个是<code class="fe nk nl nm nn b">backref</code>，是我们用来引用待办模型中用户模型的字段(变量)。最后一个参数是<code class="fe nk nl nm nn b">lazy</code>，这就是数据是如何加载的。</p><p id="7b2a" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">待办事项模型类似于用户模型。它有<code class="fe nk nl nm nn b">id</code>、<code class="fe nk nl nm nn b">name</code>、<code class="fe nk nl nm nn b">is_completed</code>和<code class="fe nk nl nm nn b">user_id</code>字段，最后一个字段是外键，即用于引用另一个模型的键。通过这个<code class="fe nk nl nm nn b">user_id</code>字段，我可以获得一个待办事项应用程序的用户ID，通过owner字段(来自<code class="fe nk nl nm nn b">backref</code>，我可以获得创建该待办事项的用户。</p><p id="e60e" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">现在，即使数据库存在，模型本身还没有被创建。要创建这些，您可以打开数据库驱动程序。但是如果你正在使用SQLite并且没有数据库驱动，你可以在导入<code class="fe nk nl nm nn b">db</code> <strong class="ky ir"> </strong>变量后打开你的终端并运行<code class="fe nk nl nm nn b">db.create_all()</code> <strong class="ky ir"> </strong>。这将创建数据库以及用它定义的所有模型。另一个有用的方法是<code class="fe nk nl nm nn b">db.drop_all()</code>，<strong class="ky ir"> </strong>，它做的正好相反。</p><p id="1f0d" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">打开一个烧瓶外壳，让我们测试我们的模型。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi og"><img src="../Images/3dd51d7022143ef16df71b8ff3d4c700.png" data-original-src="https://miro.medium.com/v2/resize:fit:1004/format:webp/1*HoXKa-6N-3Sq_L1JHANLbQ.png"/></div></figure><p id="4c05" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">如您所见，尝试从用户模型进行查询时出现了错误，因为我还没有创建数据库。</p><p id="d2e3" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">有一个Flask扩展充当我们和SQLAlchemy(以及Flask SQLAlchemy)之间的中间人。它给了我们一个命令，帮助我们创建和管理我们的模型。它使用<a class="ae kv" href="https://alembic.sqlalchemy.org/en/latest/" rel="noopener ugc nofollow" target="_blank"> Alembic </a>来实现这一点。这样做的好处是，如果我们将来要更新我们的模型，我们需要做的只是运行一些命令，数据库就会被更新。如果我们不使用这个扩展，我们将不得不自己处理它。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi oh"><img src="../Images/343bf16a90f6ebcb50a1f75b64db98c1.png" data-original-src="https://miro.medium.com/v2/resize:fit:492/format:webp/1*sVZ56asC5RTSYZ7-LTEOjg.png"/></div></figure><p id="e5a6" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">运行<code class="fe nk nl nm nn b">db.create_all()</code>后，这些模型已经创建好了，我们可以查询了。</p><p id="1aea" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><code class="fe nk nl nm nn b">db.Model</code>对象将我们的模型暴露给我们用来查询它们的查询方法。我们可以做很多查询—我们已经看到了<code class="fe nk nl nm nn b">all</code>，它返回所有行的数组；<code class="fe nk nl nm nn b">first</code>，返回查询中的第一行；<code class="fe nk nl nm nn b">filter</code> <strong class="ky ir"> </strong>和<code class="fe nk nl nm nn b">filter_by</code>用于过滤我们的查询；<code class="fe nk nl nm nn b">get</code> <strong class="ky ir"> </strong>接受一个ID并返回具有该ID的行；如果查询本身(<code class="fe nk nl nm nn b">get</code>或<code class="fe nk nl nm nn b">first</code>)返回<code class="fe nk nl nm nn b">None</code>，则<code class="fe nk nl nm nn b">first_or_404</code>和<code class="fe nk nl nm nn b">get_or_404</code>返回404。</p><p id="7054" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">让我们在数据库中插入一些行。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi oi"><img src="../Images/2020097b59c3cfaa500f8df6e547e7e7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1096/format:webp/1*H0lUd1XCIuDQOSker7NhTw.png"/></div></figure><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi oj"><img src="../Images/aa805e661bc6a7c23c411646879c4573.png" data-original-src="https://miro.medium.com/v2/resize:fit:594/format:webp/1*BULEvOjgfrKrotWSJBcO5g.png"/></div></figure><p id="66cb" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">从图像中，我使用了公共ID的<code class="fe nk nl nm nn b">uuid</code>模块，以使其唯一。我创建了该对象的一个实例，并将其存储在一个变量中，但实际上还没有创建行。我通过获取<code class="fe nk nl nm nn b">babs.id</code>、<strong class="ky ir">、</strong>的值确认了这一点，但没有给出任何值。</p><p id="7dff" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">函数<code class="fe nk nl nm nn b">db.session.add</code>向数据库临时添加一个变量。第二个功能<code class="fe nk nl nm nn b">db.session.commit</code>，永久保存。其他函数包括<code class="fe nk nl nm nn b">db.session.add_all</code>，它获取要添加到数据库中的对象数组，以及<code class="fe nk nl nm nn b">db.session.delete</code>，它删除一个对象。</p><p id="0f8a" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">数据库对象在终端中的表示方式是使用类定义中的<code class="fe nk nl nm nn b">__repr__</code> <strong class="ky ir"> </strong>方法完成的。<code class="fe nk nl nm nn b">todo</code>方法也类似。但是当我们向数据库添加一个新的<code class="fe nk nl nm nn b">todo</code>时，对象将有一个新的属性所有者，我们将它用作用户模型的<code class="fe nk nl nm nn b">backref</code>。<code class="fe nk nl nm nn b">todo</code>对象也存储在<code class="fe nk nl nm nn b">user.todos</code>对象中。</p><h2 id="513b" class="ms mb iq bd mc mt mu dn mg mv mw dp mk lf mx my mm lj mz na mo ln nb nc mq nd bi translated">端点</h2><p id="746c" class="pw-post-body-paragraph kw kx iq ky b kz ne jr lb lc nf ju le lf ng lh li lj nh ll lm ln ni lp lq lr ij bi translated">现在让我们开始创建端点。</p><p id="c7a9" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">让我们创建获取所有用户和获取单个用户的端点。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi ok"><img src="../Images/fd9b2b3dbdad6979a3df254f44df6714.png" data-original-src="https://miro.medium.com/v2/resize:fit:1300/format:webp/1*EZ99f_hWSMalVw_3pKRtUw.png"/></div></figure><p id="c79b" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这两个函数的端点在<code class="fe nk nl nm nn b">app.route</code>装饰器中给出。如果我们返回一个字典，Flask会自动将它转换成JSON，这就是为什么我们没有在第二个函数中使用<code class="fe nk nl nm nn b">jsonify</code>函数。</p><p id="080d" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在<code class="fe nk nl nm nn b">get_users</code>函数中，我们返回一个用户数组。我们没有返回<code class="fe nk nl nm nn b">id</code>，而是返回了<code class="fe nk nl nm nn b">public_id</code>，它被用作路由参数。默认的状态码是200，所以我们不需要在这里传递它。现在让我们测试这些端点。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi ol"><img src="../Images/67b7ba386c2b5cdd0fe41ea503497835.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*tfMTQY4fkF55Q7aAevcurA.png"/></div></div></figure><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi om"><img src="../Images/4424bdad595a7d1ad090aa744107d4d4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ad_Q7m7lmAgZ6NavP87aZQ.png"/></div></div></figure><p id="3bbd" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">下一步是为创建、更新和删除用户创建端点。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi on"><img src="../Images/ae7769ddd4f6654cdc8dd5a7a1f383d0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1320/format:webp/1*VMysy4dLqlUvjKGaaVIFTg.png"/></div></figure><p id="f86a" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这个函数的装饰器接受另一个参数<code class="fe nk nl nm nn b">method</code>、<strong class="ky ir">、</strong>，默认情况下是<code class="fe nk nl nm nn b">[‘GET’]</code>。<strong class="ky ir"> </strong>我们在这里把它指定为一个<strong class="ky ir"> </strong> <code class="fe nk nl nm nn b">POST</code>的方法。</p><p id="0e38" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><code class="fe nk nl nm nn b">create_user</code>函数<code class="fe nk nl nm nn b">POST</code>接收一位JSON数据。它首先验证给定的姓名和电子邮件，并且长度至少为四个字符(在前端也会有一些验证)。我们还可以使用正则表达式进行一些更高级的验证，但这不在本文的讨论范围之内。</p><p id="e071" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们最终创建了行，并将其保存到数据库中。我们返回用户的JSON数据和状态代码201。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi oo"><img src="../Images/e0d967eae2bd0e18a804fbe1771725c3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1050/format:webp/1*cciqUH5pVPrDxEeL-5i_Hw.png"/></div></figure><p id="63ce" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><code class="fe nk nl nm nn b">update_user</code>函数注册了一个<code class="fe nk nl nm nn b">PUT HTTP</code>动词。它还有我们想要更新的JSON数据——在这种情况下，它必须是<code class="fe nk nl nm nn b">name</code>。</p><p id="8dce" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们在更新数据库之前做了一些验证。我们首先在route参数中获得了具有公共ID的用户。然后，我们更新了字段并调用了<code class="fe nk nl nm nn b">db.session.commit()</code>。我们最终返回了更新后的用户数据，状态代码为200(默认值)。类似地，<code class="fe nk nl nm nn b">delete_user</code>函数使用route参数中的ID来获取用户，并最终删除它。</p><p id="aa41" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这两个函数使用<code class="fe nk nl nm nn b">first_or_404</code> <strong class="ky ir"> </strong>函数来过滤数据——这样，如果URL中没有用户拥有该公共ID，就会返回404错误。让我们前往Postman测试这些端点。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi op"><img src="../Images/235b3f663eb187cf9638d9e65810aef7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*kjYx_4wkIJ9xWx0jsUKnSA.png"/></div></div></figure><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi oq"><img src="../Images/b17c5366152a260807524a5af3b51582.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*44C-88SJZWEcCBEd6gtYbQ.png"/></div></div></figure><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi om"><img src="../Images/b218a2f9132c2777c8cf4690cbc120a2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*3yHfj-6jb5U8WcmMQn7sXA.png"/></div></div></figure><p id="3a89" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">耶！我们已经完成了用户端点。现在让我们从<code class="fe nk nl nm nn b">todo</code>端点开始。首先，一个<code class="fe nk nl nm nn b">todo</code>需要有一个用户连接到它。我们可以使用<code class="fe nk nl nm nn b">public_id</code>或email来获取用户对象，因为这两个字段是唯一的。我想我会选择电子邮件，因为它容易记忆。所以当创建一个新的<code class="fe nk nl nm nn b">todo</code>时，我们也需要传递创建者的电子邮件。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi oo"><img src="../Images/74d261eaa0a8416ed930c52a33fc230f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1050/format:webp/1*REopmtFdq2LWesPobueWWg.png"/></div></figure><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi or"><img src="../Images/3c69c9763aaf054d31596dc778a65d5f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1376/format:webp/1*3xchgr2kOdL3NPU8nwi7-w.png"/></div></figure><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi os"><img src="../Images/d9c61d5e7e069345f2eee8bfd49a0699.png" data-original-src="https://miro.medium.com/v2/resize:fit:1184/format:webp/1*oRwgJmHmizVGnyCvs5OmxA.png"/></div></figure><p id="ba76" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">终点与我们之前看到的相似。让我们前往Postman测试这些端点。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi ot"><img src="../Images/c476c88247b71b945729c18daffc908d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*JCIvC-Z5hDSbr6OKATJeJA.png"/></div></div></figure><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi ou"><img src="../Images/635c13f7871b7c27e1df10a1840456f9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*G9EHeZH5ZO5464okSHSyyA.png"/></div></div></figure><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi ov"><img src="../Images/237685564a9f1c426ab0b7f2b5f76c07.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*axQmbLu17Z5084PR72Nh9g.png"/></div></div></figure><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi ow"><img src="../Images/10f8cf6430a5f845440e6891027719f4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*4oe4VYw2NAHcsmwnPnHDsQ.png"/></div></div></figure><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi ox"><img src="../Images/de5d4774a8321dc626f59239f8503ac3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*mQ7JKP6cA0jmaylfh4LonQ.png"/></div></div></figure></div><div class="ab cl lt lu hu lv" role="separator"><span class="lw bw bk lx ly lz"/><span class="lw bw bk lx ly lz"/><span class="lw bw bk lx ly"/></div><div class="ij ik il im in"><h1 id="7c02" class="ma mb iq bd mc md me mf mg mh mi mj mk jw ml jx mm jz mn ka mo kc mp kd mq mr bi translated">结论</h1><p id="359f" class="pw-post-body-paragraph kw kx iq ky b kz ne jr lb lc nf ju le lf ng lh li lj nh ll lm ln ni lp lq lr ij bi translated">耶！我们已经完成了这个系列的第一部分。本文向您展示了如何用Flask和SQLAlchemy构建一个简单的待办事项API。你可以在GitHub <a class="ae kv" href="https://gist.github.com/Babatunde13/81866103136d20090a6f5c17f5de336b" rel="noopener ugc nofollow" target="_blank">这里</a>获得完整的代码。下一部分将重点讨论身份验证和授权。</p></div></div>    
</body>
</html>