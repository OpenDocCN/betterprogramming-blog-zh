<html>
<head>
<title>Stream Output When Parsing Big Xml With Elixir</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">用Elixir解析大Xml时的流输出</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/stream-output-when-parsing-big-xml-with-elixir-92baff37e607?source=collection_archive---------7-----------------------#2022-05-08">https://betterprogramming.pub/stream-output-when-parsing-big-xml-with-elixir-92baff37e607?source=collection_archive---------7-----------------------#2022-05-08</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="1e4f" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">嗯，这对我来说很难发现，因此，我想分享一下。</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/8c482e732dd22970b8453890c9136092.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*oBbelCZJd42Pll5XC9TvyQ.jpeg"/></div></div></figure></div><div class="ab cl kr ks hu kt" role="separator"><span class="ku bw bk kv kw kx"/><span class="ku bw bk kv kw kx"/><span class="ku bw bk kv kw"/></div><div class="ij ik il im in"><h1 id="7609" class="ky kz iq bd la lb lc ld le lf lg lh li jw lj jx lk jz ll ka lm kc ln kd lo lp bi translated">工具</h1><p id="aca1" class="pw-post-body-paragraph lq lr iq ls b lt lu jr lv lw lx ju ly lz ma mb mc md me mf mg mh mi mj mk ml ij bi translated">在elixir的XML解析生态系统中有两个大玩家:</p><ul class=""><li id="ae1e" class="mm mn iq ls b lt mo lw mp lz mq md mr mh ms ml mt mu mv mw bi translated"><code class="fe mx my mz na b">SweetXml</code>，它是传统的“解析器”,当你向它提供一些带有XML内容的字符串或流时，它会产生一些元素结构，其中每个元素都是<code class="fe mx my mz na b">SweetXml</code>认为XML元素应该表示的。</li><li id="6e36" class="mm mn iq ls b lt nb lw nc lz nd md ne mh nf ml mt mu mv mw bi translated"><code class="fe mx my mz na b">Saxy</code>，基于SAX解析。您为它提供一个模块和一些状态。该模块要知道在读取一些包含xml内容的字符串或流时，当发生sax xml相关事件(例如“start-document”、“start-element”等)时该做什么。该模块将根据这些事件按照提供给他的状态做事。</li></ul><h1 id="ad87" class="ky kz iq bd la lb ng ld le lf nh lh li jw ni jx lk jz nj ka lm kc nk kd lo lp bi translated">我想达到的目标</h1><p id="237c" class="pw-post-body-paragraph lq lr iq ls b lt lu jr lv lw lx ju ly lz ma mb mc md me mf mg mh mi mj mk ml ij bi translated">我想读取一个巨大的XML文件，其中有一些重复的元素，并想从中产生某种“迭代器”。大概是这样的:</p><p id="eaa7" class="pw-post-body-paragraph lq lr iq ls b lt mo jr lv lw mp ju ly lz nl mb mc md nm mf mg mh nn mj mk ml ij bi translated">给定XML文件:</p><pre class="kg kh ki kj gt no na np nq aw nr bi"><span id="992a" class="ns kz iq na b gy nt nu l nv nw">&lt;rss&gt;<br/>  &lt;item&gt;<br/>    &lt;title&gt;I'm a title&lt;/title&gt;<br/>    &lt;id&gt;xx1&lt;/id&gt;<br/>  &lt;/item&gt;<br/>  &lt;item&gt;<br/>    &lt;title&gt;second title&lt;/title&gt;<br/>    &lt;id&gt;xx2&lt;/id&gt;<br/>    &lt;extra&gt;extra content&lt;/extra&gt;<br/>    &lt;whatever&gt;<br/>      &lt;some&gt;thing&lt;/some&gt;<br/>      &lt;some&gt;thing2&lt;/some&gt;<br/>    &lt;/whatever&gt;<br/>  &lt;/item&gt;<br/>  &lt;item&gt;<br/>    &lt;extra&gt;thing&lt;/extra&gt;<br/>  &lt;/item&gt;<br/>&lt;/rss&gt;</span></pre><p id="a18c" class="pw-post-body-paragraph lq lr iq ls b lt mo jr lv lw mp ju ly lz nl mb mc md nm mf mg mh nn mj mk ml ij bi translated">我想产生一些迭代器，当迭代时，产生这样的结果:</p><pre class="kg kh ki kj gt no na np nq aw nr bi"><span id="a6cb" class="ns kz iq na b gy nt nu l nv nw">[<br/>  {"title": "I'm a title", "id": "xx1"}, <br/>  {<br/>    "title": "second title", <br/>    "id": "xx2", <br/>    "extra": "extra content", <br/>    "whatever": {<br/>      "some": ["thing", "thing2"]<br/>    }<br/>  }, <br/>  {"extra": "thing"}<br/>]<!-- --> </span></pre><h1 id="3b7a" class="ky kz iq bd la lb ng ld le lf nh lh li jw ni jx lk jz nj ka lm kc nk kd lo lp bi translated">我不需要的是</h1><ul class=""><li id="ea39" class="mm mn iq ls b lt lu lw lx lz nx md ny mh nz ml mt mu mv mw bi translated">我不需要在内存中保存代表整个xml文件的结构。</li><li id="2596" class="mm mn iq ls b lt nb lw nc lz nd md ne mh nf ml mt mu mv mw bi translated">我甚至不需要将整个条目列表保存在内存中，因为我可以使用某种“迭代器”,这意味着我每次只需要在内存中保存一个<code class="fe mx my mz na b">item</code></li></ul><h1 id="1ac5" class="ky kz iq bd la lb ng ld le lf nh lh li jw ni jx lk jz nj ka lm kc nk kd lo lp bi translated">这些工具为我提供了什么“开箱即用”</h1><p id="b5a7" class="pw-post-body-paragraph lq lr iq ls b lt lu jr lv lw lx ju ly lz ma mb mc md me mf mg mh mi mj mk ml ij bi translated"><code class="fe mx my mz na b">Saxy</code>是<strong class="ls ir">难以置信的快和高性能</strong>，但是它基于这样的概念，当你读取XML文件时，你“填充”一些状态对象(用你想要的任何东西，和你想要的数量，但是，不管怎样，你填充它)。</p><p id="46a7" class="pw-post-body-paragraph lq lr iq ls b lt mo jr lv lw mp ju ly lz nl mb mc md nm mf mg mh nn mj mk ml ij bi translated">在这个场景中，我可以用项目列表“填充”状态。当然，这比在内存中保存整个XML结构要少得多。但它仍然在XML文件的大小和存储在内存中的列表的大小之间建立了一种关系，我不喜欢这种关系，因为这意味着如果我使用一个足够大的文件，我可能会消耗比我允许的更多的内存。</p><p id="7223" class="pw-post-body-paragraph lq lr iq ls b lt mo jr lv lw mp ju ly lz nl mb mc md nm mf mg mh nn mj mk ml ij bi translated"><code class="fe mx my mz na b">SweetXml</code>提供了一个叫做<code class="fe mx my mz na b">stream_tags</code>的功能，当你看到它做什么的时候，你会发现它很棒！！！因为它说这正是我所需要的:解析一个xml，当它找到某些标签时，流传输它们的<code class="fe mx my mz na b">SweetXml</code>表示，并且它没有在内存中构建任何表示xml的结构。所以这应该是我所需要的:</p><pre class="kg kh ki kj gt no na np nq aw nr bi"><span id="69b7" class="ns kz iq na b gy nt nu l nv nw">iex &gt; list_iterator = File.stream("some_feed.xml") |&gt; SweetXml.stream_tags!(:item, discard: [:item])</span></pre><p id="1f52" class="pw-post-body-paragraph lq lr iq ls b lt mo jr lv lw mp ju ly lz nl mb mc md nm mf mg mh nn mj mk ml ij bi translated">就这样了。<code class="fe mx my mz na b">list_iterator</code>不是<em class="oa">整个列表</em>而是它的一个迭代器，这意味着<em class="oa">我不需要在内存中保存整个列表</em>。所以从理论上讲，<code class="fe mx my mz na b">"some_feed.xml"</code>可以是我想要的大小，并且没有内存损失。但是…</p><p id="c10e" class="pw-post-body-paragraph lq lr iq ls b lt mo jr lv lw mp ju ly lz nl mb mc md nm mf mg mh nn mj mk ml ij bi translated">不是这样的。我不知道确切的原因，但是有一些积累，这意味着有一些内存囤积，这意味着对于足够大的xml文件，我将超过我的内存限额。</p><h1 id="bb37" class="ky kz iq bd la lb ng ld le lf nh lh li jw ni jx lk jz nj ka lm kc nk kd lo lp bi translated">我最终做的是:“欺骗”saxy</h1><p id="3326" class="pw-post-body-paragraph lq lr iq ls b lt lu jr lv lw lx ju ly lz ma mb mc md me mf mg mh mi mj mk ml ij bi translated">这个想法是，即使saxy在一些<code class="fe mx my mz na b">state</code>中“积累”了一些东西，在解析期间，只要我需要，我就会“清理”这些<code class="fe mx my mz na b">state</code>，这样<code class="fe mx my mz na b">state</code>就不会消耗很多内存。</p><p id="eea9" class="pw-post-body-paragraph lq lr iq ls b lt mo jr lv lw mp ju ly lz nl mb mc md nm mf mg mh nn mj mk ml ij bi translated"><code class="fe mx my mz na b">Saxy</code>可以通过几次“部分”尝试来解析XML文件(尽管它累积到的<code class="fe mx my mz na b">state</code>保持不变)，如下所示:</p><pre class="kg kh ki kj gt no na np nq aw nr bi"><span id="2372" class="ns kz iq na b gy nt nu l nv nw">{:ok, partial} = Partial.new(MyEventHandler, initial_state)<br/>{:cont, partial} = Partial.parse(partial, "&lt;foo&gt;")<br/>{:cont, partial} = Partial.parse(partial, "&lt;bar&gt;&lt;/bar&gt;")<br/>{:cont, partial} = Partial.parse(partial, "&lt;/foo&gt;")<br/>{:ok, state} = Partial.terminate(partial)</span></pre><p id="d083" class="pw-post-body-paragraph lq lr iq ls b lt mo jr lv lw mp ju ly lz nl mb mc md nm mf mg mh nn mj mk ml ij bi translated">同样，诀窍是确保<code class="fe mx my mz na b">initial_state</code>不时地被“清空”。</p></div><div class="ab cl kr ks hu kt" role="separator"><span class="ku bw bk kv kw kx"/><span class="ku bw bk kv kw kx"/><span class="ku bw bk kv kw"/></div><div class="ij ik il im in"><h1 id="33c9" class="ky kz iq bd la lb lc ld le lf lg lh li jw lj jx lk jz ll ka lm kc ln kd lo lp bi translated">戈尔细节</h1><h2 id="a354" class="ns kz iq bd la ob oc dn le od oe dp li lz of og lk md oh oi lm mh oj ok lo ol bi translated">处理程序:当发现sax事件时做什么</h2><p id="5095" class="pw-post-body-paragraph lq lr iq ls b lt lu jr lv lw lx ju ly lz ma mb mc md me mf mg mh mi mj mk ml ij bi translated">首先，我们必须构建一个模块，当在XML解析期间发现XML事件时，该模块知道如何处理<code class="fe mx my mz na b">state</code>:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="om on l"/></div></figure><p id="efd7" class="pw-post-body-paragraph lq lr iq ls b lt mo jr lv lw mp ju ly lz nl mb mc md nm mf mg mh nn mj mk ml ij bi translated">如你所见:</p><ul class=""><li id="8339" class="mm mn iq ls b lt mo lw mp lz mq md mr mh ms ml mt mu mv mw bi translated">提供给解析器的初始状态是<code class="fe mx my mz na b">%{current_element: nil, stack: nil, items: []}</code>，也就是说，初始状态包含一个空的项目列表</li><li id="9059" class="mm mn iq ls b lt nb lw nc lz nd md ne mh nf ml mt mu mv mw bi translated">当模块解析器完成解析一个<code class="fe mx my mz na b">&lt;item&gt;</code>元素时，一个新的<code class="fe mx my mz na b">item</code>被添加到状态中</li><li id="4b8c" class="mm mn iq ls b lt nb lw nc lz nd md ne mh nf ml mt mu mv mw bi translated">因此，在解析过程中的任何时候，state(在键<code class="fe mx my mz na b">items</code>下)包含一个到目前为止已解析项目的列表。如果我们什么都不做，那么在解析了整个xml文件之后，我们可以获取从该文件中获得的整个解析项列表，这对于不太大的XML文件来说是可以的，但是，<em class="oa">如果XML文件足够大，那么累积的项列表也会很大，这就意味着要吃掉很多内存！。</em></li></ul><h1 id="6282" class="ky kz iq bd la lb ng ld le lf nh lh li jw ni jx lk jz nj ka lm kc nk kd lo lp bi translated">在解析xml文件时清理状态，这样它就不会变得太大</h1><p id="72d9" class="pw-post-body-paragraph lq lr iq ls b lt lu jr lv lw lx ju ly lz ma mb mc md me mf mg mh mi mj mk ml ij bi translated">我们想要的输出是一个<code class="fe mx my mz na b">Stream</code>，所以唯一的内存消耗是保存一个项目的内存。为了做到这一点，我们必须<em class="oa">流化</em> <strong class="ls ir"> </strong> XML解析，这要感谢<code class="fe mx my mz na b">Saxy.Partial</code>模块。在我们这样做的同时，我们还负责<em class="oa">产生已经处理的项目，并将它们从状态中移除。通过这种方式，我们可以确定<code class="fe mx my mz na b">state</code>永远不会增长太多。</em></p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="om on l"/></div></figure><p id="02bd" class="pw-post-body-paragraph lq lr iq ls b lt mo jr lv lw mp ju ly lz nl mb mc md nm mf mg mh nn mj mk ml ij bi translated">正如你所看到的，只要它解析XML，它就生成一个流，其中每个元素都是一些条目的列表，当检索这些条目时(通过<code class="fe mx my mz na b">fetch_items</code>函数)，我们也从<code class="fe mx my mz na b">state</code>中删除这些条目，因此<code class="fe mx my mz na b">state</code>永远不会保存太多条目，因此<code class="fe mx my mz na b">state</code>永远不会占用太多内存！！！</p></div><div class="ab cl kr ks hu kt" role="separator"><span class="ku bw bk kv kw kx"/><span class="ku bw bk kv kw kx"/><span class="ku bw bk kv kw"/></div><div class="ij ik il im in"><p id="774d" class="pw-post-body-paragraph lq lr iq ls b lt mo jr lv lw mp ju ly lz nl mb mc md nm mf mg mh nn mj mk ml ij bi translated">哇！这很难解释清楚(我不得不说，我不确定我是否成功做到了)。无论如何，代码是真实的，我真的希望它能帮助别人。</p></div></div>    
</body>
</html>