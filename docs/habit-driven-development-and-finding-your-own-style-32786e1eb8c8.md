# 习惯驱动的发展和找到你自己的风格

> 原文：<https://betterprogramming.pub/habit-driven-development-and-finding-your-own-style-32786e1eb8c8>

## 关于编码习惯和如何成为一名更好的工程师的思考

![](img/3609d54d849ae09c5f9497c1f3b05dbe.png)

由[丹尼尔·里卡洛斯](https://unsplash.com/@ricaros?utm_source=medium&utm_medium=referral)在 [Unsplash](https://unsplash.com?utm_source=medium&utm_medium=referral) 拍摄的照片。

通过设计和编写代码，我们自然开始发展自己的个人风格和习惯。我们带着改进的目的写的代码越多，我们最终会变得越好。但是在我们掌握这门手艺的过程中，我们可能会染上一些坏习惯。

# 新瓶装旧酒

作为软件开发人员，我们所做的大部分工作只是在稍微不同的包装中解决相同的问题。在基本上一遍又一遍地做同样的事情之后，我们开始养成以某种方式做这件事的习惯。问题是，我们可能还没有找到做这件事的最佳方法。

如果有人问我们，“你们为什么要这样做？”或者“你为什么选择那个特定的堆栈？”我们的答案会是什么？

我想到了几个答案:

*   “我一直都是这么做的。”
*   “这是我们这里做事的方式。”
*   “这比其他解决方案更方便。”
*   “这是我知道的唯一的办法。”

这些都是有效的回应，我们以前都听过或说过。缺少的是我们应该问自己的问题，以理解我们为什么给出这个特定的答案:

*   **“为什么我开始这样做？”我们关于软件开发的每一个习惯和信念都是从合理的推理开始的。也许我们碰到了一个错误，我们必须解决它。编译器错误地优化了我们的代码。一个框架让我们适应了自己的风格。或者我们当时不知道更多。**
*   (现在)没有更好的方法吗我们的语言和工具随着新的特性和范例、性能改进和错误修复而稳步发展。就算我们过去可以信任编译器，现在还有效吗？迫使我们做不同事情的错误最终被修复了吗？我们上一次检查和验证我们之前的假设，甚至将我们的解决方案与其他解决方案进行比较是什么时候？

如果不考虑我们为什么以这种方式做事，我们最终会迷信自己编码，而不是依赖我们的框架提供的标准库或社区提供的成熟解决方案。为了不动摇我们的信念，我们甚至不会验证我们的解决方案。

当然，我们一直是这样做的。这是我们的*正常。但是，我们最近有没有问过自己，它(仍然)好吗？*

# *按我的方式做*

*`C`中的内存管理并不容易。正确地做它是困难的。这就是为什么许多开发者创造他们自己的风格，相信他们找到了完美的方式:*

```
**// Habit-Driven-Development*
char x[2048];
for(int i = 0; i < 2048; i++) {
    [i] = 0;
}*
```

*我们可以通过迭代来初始化数组的内存，并把所有东西都设置为零。也许曾经有一段时间，这是应该的做法。但是还有一种标准库*的*方式可以做到:*

```
**// Standard Library*
char x[2048];
memset(x, 0, sizeof(x));*
```

*当这种更短、更常见的方式存在时，我们为什么要自己进行初始化呢？也许我们相信我们的解决方案比打电话`memset()`更安全甚至更快。在适当的条件下，这可能是真的，特别是因为微基准测试是另一个真正棘手的问题。*

*但是我们真的想要一个更复杂、更难理解的解决方案吗？为什么不使用其他程序员都理解的、有良好文档记录的、经过无数行代码考验的标准解决方案呢？*

# *要聪明，不要自作聪明*

*编译器能够实现非常复杂的优化技巧和巧妙的处理器和平台相关的实现。你知道吗，一个智能编译器甚至可以用一个`memset()`来代替我们的`for`-循环。*

*如果我们对我们的代码进行了微基准测试(我们没有)，我们可能会想，“我的代码和`memset()`一样快！”即使编译器用更灵活、更简洁的代码取代了我们的习惯。*

*我们的习惯和有时古怪的代码风格不一定会导致糟糕或错误的代码。但最终，我们可能完成的只是增加了一层额外的复杂性。特别是如果我们不是唯一需要处理代码的人，我们应该尽量避免添加这些代码。*

*有些情况下，我们需要自己做事情，而不依赖于提供的标准库。但这些情况比我们通常认为的要罕见。在做之前，我们应该绝对确定我们在做什么，为什么要做。*

*我们需要在代码上变得*聪明*，而不是试图变得*聪明*。*

# *重复的真理*

*习惯因重复而强化。我们越是通过重复一个行为来建立我们的习惯，我们就越能无意识地依赖它们。它们将成为我们的*自动真理*。*

*好习惯如此，坏习惯也是如此。*

## *几乎正确*

*重复出真理的一个例子是电影语录。我们都知道一些著名的电影台词，并能背诵下来:*

> *卢克，我是你的父亲
> ——达斯·维德，《帝国反击战》*
> 
> *“再放一遍，山姆。”
> ——里克·布莱恩，卡萨布兰卡*
> 
> *“你觉得幸运吗，小子？”
> ——哈里·卡拉汉，肮脏的哈利*

*![](img/cceabd46990c8e835080975988fdf6d5.png)*

*[帝国反击战](https://www.lucasfilm.com/productions/episode-v/) |图片由[卢卡斯影业](https://www.lucasfilm.com/)提供。*

*你猜怎么着？没有一个是逐字引用的，尽管我们大多数人都确信它们都是。*

*随着时间的推移，原来的行被变成了更短，更令人难忘的信息块。通过在流行文化中的重复，它最终成为了真理。*

*仅仅因为我们一直以一种特定的方式做某件事，并不意味着下次它就是最好的解决方案。我们不必每次做的时候都把每一个习惯都称为有问题，但我们需要不时地重新评估。*

# *其他人的习惯*

*有时候，习惯甚至不是我们自己的！*

*任何现代的 IDE 都为日常任务提供了大量的代码生成。这很方便，但是对于这个问题来说，这是最好的代码吗？强制编码指南，或自动林挺和修正，是我们代码的另一个外部因素。*

*我们利用许多不同的工具来改进我们的代码，比如 linters、formatters、代码生成器、构建管道等等。它们极大地提高了我们的生产力和代码质量。但是我们最后一次敢于质疑我们的工具是什么时候？*

*我不是说我们不应该使用编码指南、linters 或代码生成。它们都是我们编码工具带的重要补充。但是我们需要明白，任何没有真正理解原因就应用的固定规则或思维模式都会削弱我们更好地理解代码并加以改进的能力。*

# *不要从零开始*

*一些语言，如 [Golang](https://golang.org/cmd/gofmt/) ，提供了硬编码指南，包括执行它们的工具。其他语言对于什么使得编码风格“好”的解释更加开放*

*我们不需要重新发明轮子，但我们也不应该未经事实检验就接受别人的真理。*

*我们可以利用他人的工作作为起点，而不是从零开始。许多不同的人，许多比我们聪明得多——或者至少比我聪明——就适当的代码样式进行了漫长而复杂的讨论。这并不意味着他们对每个小决定都是正确的。每个团队和代码库都是不同的。但是我们可以免费从他们的成果中获利。*

*有针对语言的风格指南，有时甚至针对单个项目或框架:*

*   *[谷歌风格指南](http://google.github.io/styleguide/) (12 种不同语言)*
*   *[JavaScript 标准样式](https://standardjs.com/)*
*   *[AirBnb JavaScript 风格指南](https://github.com/airbnb/javascript)*
*   *[PEP 8—Python 代码风格指南](https://www.python.org/dev/peps/pep-0008/)*
*   *[Mozilla Firefox 编码风格](https://firefox-source-docs.mozilla.org/tools/lint/index.html#coding-style)*
*   *[Epic 虚幻引擎编码标准](https://docs.unrealengine.com/en-US/Programming/Development/CodingStandard/index.html)*

*指导方针应该改进我们的代码，而不是强迫我们的代码去适应仅仅是为了让 linter 高兴。用风格指南改进你的代码，但是要知道什么时候打破或改变规则。*

# *找到自己的风格*

*在我的公司，所有的开发人员坐在一起讨论适合我们项目的不同风格指南。我们通过讨论和投票使它们适应我们的团队和代码库。*

*![](img/aa276a1d533d8ed122e59889e9fb01a8.png)*

*阿曼达·达尔比约恩在 [Unsplash](https://unsplash.com/s/photos/binoculars?utm_source=unsplash&utm_medium=referral&utm_content=creditCopyText) 上的照片。*

*以一个既定的指导方针作为起点总是一个好主意。但是无论你想出了什么样的自定义准则，都不要把它们当作固定的规则集。它们需要定期重新评估、发展和适应新的需求。指导方针不应该太严格，否则在需要的时候很难偏离。*

*例如，我们总是适应我们以前做事方式的一种规则:罗嗦。作为一个 Java 爱好者，我们习惯了冗长的代码——我们坚信冗长是一件好事。许多错误可以通过不时地添加一些冗长来避免。代码被读取的次数比被编写的次数多:*

*这是一个夸张的例子，但它是一个有效的风格选择:*

*   *[每个变量都应该有一个合适的名字](https://medium.com/@benweidig/naming-stuff-is-hard-bee6b3a25849)。*
*   *显式的`== false`可能不常见，但我们不会在第一个括号后意外忘记`!`。*
*   *方法也应该有合适的名称。*
*   *提供花括号可以防止多种类型的错误。*

*但是请注意，与原始的“信号”相比，过度使用可能会增加更多的“噪音”*

# *结论*

*我们通常不需要使用最新软件栈的最新和最好的夜间版本。但是我们不应该把自己困在过去，不去努力改善。*

*仅仅因为我们总是以一种特定的方式做一些事情，并不意味着我们不能改变和改进。有时候，我们需要跳出框框思考，但我们也需要知道什么时候该呆在我们舒适的盒子里。*

*我们的职业要求不断改进和终身学习。否则，我们将无法达到最佳效果。我们应该通过不断地重新评估我们的信念来努力成为更好的软件开发人员。*

*技术在进步，我们也应该进步。*

# *书籍推荐*

*   *[干净代码:敏捷软件技术手册](https://www.goodreads.com/book/show/3735293-clean-code)*
*   *[务实的程序员:从熟练工到大师](https://www.goodreads.com/book/show/4099.The_Pragmatic_Programmer)*
*   *[代码完成](https://www.goodreads.com/book/show/4845.Code_Complete?from_search=true&qid=aaAOPe2DIY&rank=1)*

# *我的相关文章*

*[](https://codeburst.io/signal-to-noise-ratio-a45ae45c3545) [## 信噪比

### 与期望的和实际的相关信号相比，在我们的代码中应该传输尽可能少的噪声…

codeburst.io](https://codeburst.io/signal-to-noise-ratio-a45ae45c3545) [](https://medium.com/@benweidig/naming-stuff-is-hard-bee6b3a25849) [## 给东西命名很难

### 好的干净的代码从所有事物的正确名称开始。

medium.com](https://medium.com/@benweidig/naming-stuff-is-hard-bee6b3a25849) [](https://medium.com/@benweidig/your-comments-are-bad-and-you-should-feel-bad-8a17bddc8463) [## 你的评论很糟糕

### 评论会出很多问题。

medium.com](https://medium.com/@benweidig/your-comments-are-bad-and-you-should-feel-bad-8a17bddc8463)*