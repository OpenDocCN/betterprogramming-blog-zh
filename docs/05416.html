<html>
<head>
<title>Introducing iOS 14 WidgetKit With SwiftUI</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">引入带SwiftUI的iOS 14 WidgetKit</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/introducing-ios-14-widgetkit-with-swiftui-a9cc473caa24?source=collection_archive---------2-----------------------#2020-07-07">https://betterprogramming.pub/introducing-ios-14-widgetkit-with-swiftui-a9cc473caa24?source=collection_archive---------2-----------------------#2020-07-07</a></blockquote><div><div class="fc ii ij ik il im"/><div class="in io ip iq ir"><div class=""/><div class=""><h2 id="1ad8" class="pw-subtitle-paragraph jr it iu bd b js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki dk translated">让我们在几分钟内学习如何为我们的主屏幕构建一些小部件</h2></div><figure class="kk kl km kn gu ko gi gj paragraph-image"><div role="button" tabindex="0" class="kp kq di kr bf ks"><div class="gi gj kj"><img src="../Images/d29e86d7ae77c36547e168acf8fc1424.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*eDuMsmCpp5oZhu-j"/></div></div><p class="kv kw gk gi gj kx ky bd b be z dk translated"><a class="ae kz" href="https://unsplash.com/@bhaguz?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">巴格斯·赫纳万</a>在<a class="ae kz" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>拍摄的照片。</p></figure><p id="8d55" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">WWDC 2020给了我们很多增强和更新，但毫无疑问，引入了<a class="ae kz" href="https://developer.apple.com/widgets/" rel="noopener ugc nofollow" target="_blank"> WidgetKit </a>框架。</p><p id="e0e8" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">iOS 14引入了重新设计的主屏幕，其中包含的小工具是一个巨大的补充。对于我们的应用程序来说，小部件不仅仅是一个赏心悦目的UI快捷方式。它们还有助于不时地向用户提供有用的信息。</p><p id="8fc5" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">在某种程度上，它们是一种更平静的通知形式，为你提供来自应用程序的最新信息(如果开发者选择这样做的话)，而不会打扰你。此外，iOS 14中还有一个新的智能堆栈功能，它将一组可以滑动的小部件分组。智能堆栈倾向于通过使用设备上的智能在顶部提供相关的小部件，该智能考虑了一天中的时间、位置和一些其他属性。</p><p id="6ce8" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">WidgetKit完全是使用SwiftUI构建的，这为构建漂亮的小部件提供了无限的机会。需要注意的是，WidgetKit并不是用来构建迷你应用的。</p><p id="c415" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">除了提供一个<code class="fe lw lx ly lz b">Link</code>按钮让你设置一个深层链接URL来导航到应用程序的特定部分，你不能在小部件中添加任何动画或其他交互。</p></div><div class="ab cl ma mb hy mc" role="separator"><span class="md bw bk me mf mg"/><span class="md bw bk me mf mg"/><span class="md bw bk me mf"/></div><div class="in io ip iq ir"><h1 id="cb43" class="mh mi iu bd mj mk ml mm mn mo mp mq mr ka ms kb mt kd mu ke mv kg mw kh mx my bi translated">我们的目标</h1><ul class=""><li id="0e5b" class="mz na iu lc b ld nb lg nc lj nd ln ne lr nf lv ng nh ni nj bi translated">了解WidgetKit的结构。我们将探索这个框架，看看小部件是如何创建和更新的。</li><li id="e9c0" class="mz na iu lc b ld nk lg nl lj nm ln nn lr no lv ng nh ni nj bi translated">在SwiftUI中构建一个小时笑话小部件。</li><li id="0cf7" class="mz na iu lc b ld nk lg nl lj nm ln nn lr no lv ng nh ni nj bi translated">使用<code class="fe lw lx ly lz b">WidgetBuilder</code>将我们的SwiftUI应用程序与两个小部件捆绑在一起。</li></ul><p id="9b77" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">事不宜迟，我们开始吧。</p></div><div class="ab cl ma mb hy mc" role="separator"><span class="md bw bk me mf mg"/><span class="md bw bk me mf mg"/><span class="md bw bk me mf"/></div><div class="in io ip iq ir"><h1 id="247c" class="mh mi iu bd mj mk ml mm mn mo mp mq mr ka ms kb mt kd mu ke mv kg mw kh mx my bi translated">WidgetKit框架:引擎盖下</h1><p id="48e6" class="pw-post-body-paragraph la lb iu lc b ld nb jv lf lg nc jy li lj np ll lm ln nq lp lq lr nr lt lu lv in bi translated">为了理解WidgetKit的结构，让我们创建一个新的Xcode 12 SwiftUI项目，并确保选择SwiftUI应用程序生命周期。</p><p id="37e0" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">要创建我们的第一个小部件，转到文件→新建→目标并选择小部件扩展模板。确保您没有选中“包含配置意图”，因为在本文中我们将只讨论静态配置。</p><figure class="kk kl km kn gu ko gi gj paragraph-image"><div role="button" tabindex="0" class="kp kq di kr bf ks"><div class="gi gj ns"><img src="../Images/ab2dcfdfce6c5ae593d80288a5b315db.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*0lhzqag3CeZNcsxys4V4JQ.png"/></div></div></figure><p id="3405" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">在添加小部件扩展目标时，您会看到一个文件，其中包含一些您可能觉得陌生的SwiftUI代码。别担心，我们会从头到尾走一遍。</p><p id="f5f7" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">以下代码片段是您的小部件的起点:</p><figure class="kk kl km kn gu ko gi gj paragraph-image"><div role="button" tabindex="0" class="kp kq di kr bf ks"><div class="gi gj nt"><img src="../Images/004c8b65165d67a8c68b2d8bc14b5148.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*L5hCMkZcTGvKXa37hjr_sQ.png"/></div></div></figure><p id="aa1e" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">这些是从上面的代码中得出的推论:</p><ul class=""><li id="34dd" class="mz na iu lc b ld le lg lh lj nu ln nv lr nw lv ng nh ni nj bi translated"><code class="fe lw lx ly lz b">kind</code>是一个标识符，用于在WidgetCenter中将小部件与其他小部件区分开来。</li><li id="c0eb" class="mz na iu lc b ld nk lg nl lj nm ln nn lr no lv ng nh ni nj bi translated">在<code class="fe lw lx ly lz b">WidgetConfiguration</code>中，我们设置了一个占位符视图，在小部件加载时显示。小部件的内容设置在<code class="fe lw lx ly lz b">FirstWidgetEntryView</code>中，我们很快就会看到。</li><li id="c5f4" class="mz na iu lc b ld nk lg nl lj nm ln nn lr no lv ng nh ni nj bi translated"><code class="fe lw lx ly lz b">Provider</code>是一个<code class="fe lw lx ly lz b">TimelineProvider</code>类型的结构，这是小部件的核心引擎。它负责向小部件提供数据，并设置更新数据的时间间隔。同样，我们很快就会谈到这一点。</li><li id="cd59" class="mz na iu lc b ld nk lg nl lj nm ln nn lr no lv ng nh ni nj bi translated">视图修改器<code class="fe lw lx ly lz b">configurationDisplayName</code>和<code class="fe lw lx ly lz b">description</code>在微件图库中显示各自的信息——微件图库是存放设备上所有微件的地方。</li></ul><p id="ea14" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">WidgetKit框架还有另一个新的修饰符(<code class="fe lw lx ly lz b">supportedFamilies</code>)，在这个修饰符中，我们可以为我们的应用程序传递不同大小的小部件。例如，<code class="fe lw lx ly lz b">.supportedFamilies([.systemLarge])</code>只允许大尺寸的小部件。</p></div><div class="ab cl ma mb hy mc" role="separator"><span class="md bw bk me mf mg"/><span class="md bw bk me mf mg"/><span class="md bw bk me mf"/></div><div class="in io ip iq ir"><h1 id="a223" class="mh mi iu bd mj mk ml mm mn mo mp mq mr ka ms kb mt kd mu ke mv kg mw kh mx my bi translated">WidgetKit时间轴提供程序</h1><p id="6e79" class="pw-post-body-paragraph la lb iu lc b ld nb jv lf lg nc jy li lj np ll lm ln nq lp lq lr nr lt lu lv in bi translated">顾名思义，<code class="fe lw lx ly lz b">Provider</code>结构旨在为小部件的内容提供数据。它符合<code class="fe lw lx ly lz b">TimelineProvider</code>协议，该协议要求实现两种方法(<code class="fe lw lx ly lz b">snapshot</code>和<code class="fe lw lx ly lz b">timeline</code>)，如下面给出的默认示例所示:</p><figure class="kk kl km kn gu ko gi gj paragraph-image"><div role="button" tabindex="0" class="kp kq di kr bf ks"><div class="gi gj nt"><img src="../Images/400fc74beece0069fd0e9055a841b951.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*GOS2ZncFAVZ_43Puju9Y_A.png"/></div></div></figure><ul class=""><li id="a63b" class="mz na iu lc b ld le lg lh lj nu ln nv lr nw lv ng nh ni nj bi translated"><code class="fe lw lx ly lz b">snapshot</code>函数用于立即呈现一个小部件视图，而时间轴提供者则希望加载数据。只使用虚拟数据设置快照方法很重要，因为这个视图也会显示在小部件图库中。</li><li id="c1d6" class="mz na iu lc b ld nk lg nl lj nm ln nn lr no lv ng nh ni nj bi translated"><code class="fe lw lx ly lz b">SimpleEntry</code>结构实际上保存了单个<code class="fe lw lx ly lz b">TimelineEntry</code>的数据，并最终显示在小部件的内容中。</li><li id="e752" class="mz na iu lc b ld nk lg nl lj nm ln nn lr no lv ng nh ni nj bi translated">另一方面，<code class="fe lw lx ly lz b">timeline</code>函数用于创建一个或多个条目。我们可以设置<code class="fe lw lx ly lz b">TimelineEntry</code>需要更新的时间间隔。</li><li id="ef22" class="mz na iu lc b ld nk lg nl lj nm ln nn lr no lv ng nh ni nj bi translated">上面的代码基本上添加了五个时间轴条目，用于每小时更新小部件的内容。默认示例中的数据集是日期文本。</li><li id="0a83" class="mz na iu lc b ld nk lg nl lj nm ln nn lr no lv ng nh ni nj bi translated"><code class="fe lw lx ly lz b">Timeline</code>实例还包含一个<code class="fe lw lx ly lz b">TimelineReloadPolicy</code>。系统将使用该策略来确定何时再次调用<code class="fe lw lx ly lz b">timeline</code>函数，以加载下一组时间线条目。在上面的代码中，策略被设置为<code class="fe lw lx ly lz b">atEnd</code>，这意味着在第五个<code class="fe lw lx ly lz b">SimpleEntry</code>显示在widget上之后，系统将触发下一批的<code class="fe lw lx ly lz b">timeline</code>函数。</li><li id="6276" class="mz na iu lc b ld nk lg nl lj nm ln nn lr no lv ng nh ni nj bi translated">除了<code class="fe lw lx ly lz b">atEnd</code>，我们还有一个<code class="fe lw lx ly lz b">after(Date:)</code>属性。它用于设置我们希望获取下一个时间轴的具体日期。请注意，系统可能不会在<em class="nx">确切的</em>日期触发<code class="fe lw lx ly lz b">timeline</code>功能。此外，我们可以设置一个<code class="fe lw lx ly lz b">never</code>作为重载策略，以确保时间轴不会再次触发。</li></ul><p id="5cb7" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">此外，如果您想要触发小部件条目的重新加载，您可以使用<code class="fe lw lx ly lz b">WidgetCenter</code> API。它让我们重新加载特定的时间线或所有的时间线。</p><p id="bba5" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated"><code class="fe lw lx ly lz b">TimelineProvider</code>结构非常重要，因为您的动态内容将被提取到其中，以便按照您选择的特定时间间隔更新小部件的内容。</p></div><div class="ab cl ma mb hy mc" role="separator"><span class="md bw bk me mf mg"/><span class="md bw bk me mf mg"/><span class="md bw bk me mf"/></div><div class="in io ip iq ir"><h1 id="bd1b" class="mh mi iu bd mj mk ml mm mn mo mp mq mr ka ms kb mt kd mu ke mv kg mw kh mx my bi translated">SwiftUI小部件视图</h1><p id="6a83" class="pw-post-body-paragraph la lb iu lc b ld nb jv lf lg nc jy li lj np ll lm ln nq lp lq lr nr lt lu lv in bi translated">现在我们已经清楚widget是如何工作的了，让我们来看看将在屏幕上显示widget的SwiftUI视图。</p><figure class="kk kl km kn gu ko gi gj paragraph-image"><div role="button" tabindex="0" class="kp kq di kr bf ks"><div class="gi gj nt"><img src="../Images/c3de50b448bceb867ac6b3f109cc571f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Dftsjsjoe-TYbXtMrljs7Q.png"/></div></div></figure><p id="d549" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">上面的结构用<code class="fe lw lx ly lz b">Provider.Entry</code>中的数据集填充小部件的视图。<code class="fe lw lx ly lz b">Provider.Entry</code>是我们小部件视图的数据源，如果您回头看一下<code class="fe lw lx ly lz b">TimelineProvider</code>，您会看到<code class="fe lw lx ly lz b">SimpleEntry</code> struct被设置为<code class="fe lw lx ly lz b">Entry</code>的类型别名。</p><p id="10a7" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">现在我们已经看到了WidgetKit是如何操作的——从显示占位符到用<code class="fe lw lx ly lz b">TimelineProvider</code>中指定的时间线条目填充小部件视图——我们准备构建自己的定制小部件:一个每小时更新一次的笑话跟踪器(您可以定制时间间隔)。</p></div><div class="ab cl ma mb hy mc" role="separator"><span class="md bw bk me mf mg"/><span class="md bw bk me mf mg"/><span class="md bw bk me mf"/></div><div class="in io ip iq ir"><h1 id="012d" class="mh mi iu bd mj mk ml mm mn mo mp mq mr ka ms kb mt kd mu ke mv kg mw kh mx my bi translated">在iOS 14中建立一个笑话小部件跟踪器</h1><p id="5a02" class="pw-post-body-paragraph la lb iu lc b ld nb jv lf lg nc jy li lj np ll lm ln nq lp lq lr nr lt lu lv in bi translated">当显示<code class="fe lw lx ly lz b">PlaceholderView</code>时，<code class="fe lw lx ly lz b">TimelineProvider</code>允许我们从网络请求或数据库中获取数据。从API中为小部件获取数据的方法与为应用程序获取数据的方法相同。</p><p id="5887" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">下面的代码使用Combine-powered <code class="fe lw lx ly lz b">URLSession</code>来解码API响应，并将其传递给完成块:</p><figure class="kk kl km kn gu ko"><div class="bz fq l di"><div class="ny nz l"/></div></figure><p id="57a2" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">请注意，SwiftUI小部件视图不能也不应该使用像<code class="fe lw lx ly lz b">Published</code>或<code class="fe lw lx ly lz b">State</code>这样的属性包装器来更新。</p><p id="865e" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">使用以下可编码结构对响应进行解码:</p><figure class="kk kl km kn gu ko"><div class="bz fq l di"><div class="ny nz l"/></div></figure></div><div class="ab cl ma mb hy mc" role="separator"><span class="md bw bk me mf mg"/><span class="md bw bk me mf mg"/><span class="md bw bk me mf"/></div><div class="in io ip iq ir"><h1 id="4f12" class="mh mi iu bd mj mk ml mm mn mo mp mq mr ka ms kb mt kd mu ke mv kg mw kh mx my bi translated">创建我们的数据源</h1><p id="4d26" class="pw-post-body-paragraph la lb iu lc b ld nb jv lf lg nc jy li lj np ll lm ln nq lp lq lr nr lt lu lv in bi translated">我们的小部件将笑话显示为一个字符串。因此，让我们在我们的<code class="fe lw lx ly lz b">SimpleEntry</code>结构中添加字段，如下所示:</p><pre class="kk kl km kn gu oa lz ob oc aw od bi"><span id="6833" class="oe mi iu lz b gz of og l oh oi">struct JokesEntry: TimelineEntry {</span><span id="cf77" class="oe mi iu lz b gz oj og l oh oi">public let date: Date<br/>public let joke : String</span><span id="f9eb" class="oe mi iu lz b gz oj og l oh oi">}</span></pre></div><div class="ab cl ma mb hy mc" role="separator"><span class="md bw bk me mf mg"/><span class="md bw bk me mf mg"/><span class="md bw bk me mf"/></div><div class="in io ip iq ir"><h1 id="eda4" class="mh mi iu bd mj mk ml mm mn mo mp mq mr ka ms kb mt kd mu ke mv kg mw kh mx my bi translated">创建时间轴提供程序</h1><p id="3614" class="pw-post-body-paragraph la lb iu lc b ld nb jv lf lg nc jy li lj np ll lm ln nq lp lq lr nr lt lu lv in bi translated">下面的时间线提供者结构从<code class="fe lw lx ly lz b">DataFetcher</code>获取数据，并将它们设置在以给定时间间隔配置的<code class="fe lw lx ly lz b">TimelineEntries</code>数组上:</p><figure class="kk kl km kn gu ko"><div class="bz fq l di"><div class="ny nz l"/></div></figure><p id="c7ff" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated"><em class="nx">注意:在生产应用程序中，不建议设置秒的时间间隔。上面的代码片段只是为了演示的目的。</em></p></div><div class="ab cl ma mb hy mc" role="separator"><span class="md bw bk me mf mg"/><span class="md bw bk me mf mg"/><span class="md bw bk me mf"/></div><div class="in io ip iq ir"><h1 id="8e1a" class="mh mi iu bd mj mk ml mm mn mo mp mq mr ka ms kb mt kd mu ke mv kg mw kh mx my bi translated">创建小部件SwiftUI视图</h1><p id="cc59" class="pw-post-body-paragraph la lb iu lc b ld nb jv lf lg nc jy li lj np ll lm ln nq lp lq lr nr lt lu lv in bi translated">下面这段代码代表了我们的SwiftUI视图，将<code class="fe lw lx ly lz b">SimpleEntry</code> struct设置为其数据源:</p><figure class="kk kl km kn gu ko"><div class="bz fq l di"><div class="ny nz l"/></div></figure><p id="7a90" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">在上面的代码中，通过使用SwiftUI <code class="fe lw lx ly lz b">@ViewBuilder</code>和使用<code class="fe lw lx ly lz b">widgetFamily</code> enum类型作为EnvironmentObject，我们为各种小部件形状设置了不同的SwiftUI视图。</p><p id="edce" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">最后，让我们设置我们的<code class="fe lw lx ly lz b">WidgetConfiguration</code>并在iOS 14设备上启动应用程序:</p><figure class="kk kl km kn gu ko"><div class="bz fq l di"><div class="ny nz l"/></div></figure><p id="ed1a" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">下面是小部件的实际输出:</p><figure class="kk kl km kn gu ko gi gj paragraph-image"><div class="gi gj ok"><img src="../Images/50220fa1324721461d7feb134cbc43bf.png" data-original-src="https://miro.medium.com/v2/resize:fit:1280/1*ZMhZMq8MZ0IATKwObqDX_Q.gif"/></div></figure><p id="1333" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">如您所见，我们有两个不同大小和不同布局的小部件。您可以使用自己漂亮的SwiftUI视图进一步定制它们。</p><p id="e13c" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">出于演示的目的，我将<code class="fe lw lx ly lz b">TimelineProvider</code>间隔设置为一秒钟(尽管这在小部件中并不理想，并且会消耗大量电池)。</p></div><div class="ab cl ma mb hy mc" role="separator"><span class="md bw bk me mf mg"/><span class="md bw bk me mf mg"/><span class="md bw bk me mf"/></div><div class="in io ip iq ir"><h1 id="da41" class="mh mi iu bd mj mk ml mm mn mo mp mq mr ka ms kb mt kd mu ke mv kg mw kh mx my bi translated">使用小部件构建器创建多个小部件</h1><p id="0274" class="pw-post-body-paragraph la lb iu lc b ld nb jv lf lg nc jy li lj np ll lm ln nq lp lq lr nr lt lu lv in bi translated">我们可以创建不同的小部件，并使用<code class="fe lw lx ly lz b">WidgetBundleBuilder</code>将它们捆绑在一起:</p><figure class="kk kl km kn gu ko"><div class="bz fq l di"><div class="ny nz l"/></div></figure></div><div class="ab cl ma mb hy mc" role="separator"><span class="md bw bk me mf mg"/><span class="md bw bk me mf mg"/><span class="md bw bk me mf"/></div><div class="in io ip iq ir"><h1 id="071c" class="mh mi iu bd mj mk ml mm mn mo mp mq mr ka ms kb mt kd mu ke mv kg mw kh mx my bi translated">结论</h1><p id="6849" class="pw-post-body-paragraph la lb iu lc b ld nb jv lf lg nc jy li lj np ll lm ln nq lp lq lr nr lt lu lv in bi translated">小工具既方便又赏心悦目。由于苹果在iOS的主屏幕上引入了新的WidgetKit框架和小部件，许多应用程序将会利用它。然而，看看它对用户隐私的影响有多大会很有趣。完整的源代码可以在<a class="ae kz" href="https://github.com/anupamchugh/iOS14WidgetKitStaticConfig" rel="noopener ugc nofollow" target="_blank"> GitHub资源库</a>中找到。</p><p id="ffd8" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">在下一部分中，我们将使用意向配置和链接来构建一些方便的小部件。</p><p id="749f" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">这一次到此为止。感谢阅读。</p></div></div>    
</body>
</html>