<html>
<head>
<title>6 Ways to Do Component Communications in Svelte</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">6种简单的组件通信方式</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/6-ways-to-do-component-communications-in-svelte-b3f2a483913c?source=collection_archive---------1-----------------------#2020-09-29">https://betterprogramming.pub/6-ways-to-do-component-communications-in-svelte-b3f2a483913c?source=collection_archive---------1-----------------------#2020-09-29</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="8cbd" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">在组件之间共享反应数据和事件</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/1ea144d3ed5d5298b9c3e25f39e7053d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*gs1Fty2ybaXnnSWBFHMq_A.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">图片由作者提供。</p></figure><p id="3e38" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">现代web应用程序是建立在反应式组件之上的。苗条的应用程序由一个或多个组件组成。组件是一个可重用的自包含代码块，它封装了HTML、CSS和JavaScript，将它们一起写入一个<code class="fe lr ls lt lu b">.svelte</code>文件。</p><p id="0f7d" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">用组件设计用户界面的主要挑战是管理不同组件上的应用程序状态。在苗条，我们有强大的技术来有效地沟通的组成部分。</p><blockquote class="lv"><p id="007d" class="lw lx iq bd ly lz ma mb mc md me lq dk translated">“伟大的沟通始于联系。”</p><p id="800b" class="lw lx iq bd ly lz ma mb mc md me lq dk translated">——奥普拉·温弗瑞</p></blockquote><p id="a3c6" class="pw-post-body-paragraph kv kw iq kx b ky mf jr la lb mg ju ld le mh lg lh li mi lk ll lm mj lo lp lq ij bi translated">让我们通过使用组件通信技术，结合对需求及其解决方案的理解，将这些点连接起来。</p><ol class=""><li id="8368" class="mk ml iq kx b ky kz lb lc le mm li mn lm mo lq mp mq mr ms bi translated">将数据从父节点发送到子节点:<strong class="kx ir">道具</strong></li><li id="d02b" class="mk ml iq kx b ky mt lb mu le mv li mw lm mx lq mp mq mr ms bi translated">在你的组件中渲染HTML:<strong class="kx ir">插槽</strong></li><li id="fbaf" class="mk ml iq kx b ky mt lb mu le mv li mw lm mx lq mp mq mr ms bi translated">子通知事件给其父，带有可选数据:<strong class="kx ir">事件</strong></li><li id="5c20" class="mk ml iq kx b ky mt lb mu le mv li mw lm mx lq mp mq mr ms bi translated">祖先将数据共享给他们的所有后代:<strong class="kx ir">上下文API </strong></li><li id="6d13" class="mk ml iq kx b ky mt lb mu le mv li mw lm mx lq mp mq mr ms bi translated">在组件的所有实例之间共享数据:<strong class="kx ir">模块上下文</strong></li><li id="bb99" class="mk ml iq kx b ky mt lb mu le mv li mw lm mx lq mp mq mr ms bi translated">与任何组件共享数据:<strong class="kx ir">存储</strong></li></ol><p id="d789" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">在本文中，我们可以制作样本子组件，并应用所有不同的瘦组件通信技术。它不会涵盖每一个细节，但它给出了一个本质的更好的想法。如果您从基础到高级循序渐进地遵循每个示例。</p></div><div class="ab cl my mz hu na" role="separator"><span class="nb bw bk nc nd ne"/><span class="nb bw bk nc nd ne"/><span class="nb bw bk nc nd"/></div><div class="ij ik il im in"><h1 id="de93" class="nf ng iq bd nh ni nj nk nl nm nn no np jw nq jx nr jz ns ka nt kc nu kd nv nw bi translated">1.小道具</h1><p id="339b" class="pw-post-body-paragraph kv kw iq kx b ky nx jr la lb ny ju ld le nz lg lh li oa lk ll lm ob lo lp lq ij bi translated">在任何实际的应用程序中，您都需要将数据从一个组件向下传递到其子组件。为此，我们需要声明属性，通常简称为“道具”在Svelte中，我们用关键字<code class="fe lr ls lt lu b">export</code>来做这件事。</p><p id="1b53" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">用<code class="fe lr ls lt lu b">Card.svelte</code>组件中的<code class="fe lr ls lt lu b">export</code>关键字检查下面突出显示的代码。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi oc"><img src="../Images/3e8b3a6f16cf42a36b4df5b01bf47abe.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*zDYpYB6ydVpIf09ZiENidg.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">带道具的卡片</p></figure><p id="47d2" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">只需导入卡片组件，将用户数据作为道具发送即可。</p><pre class="kg kh ki kj gt od lu oe of aw og bi"><span id="c702" class="oh ng iq lu b gy oi oj l ok ol">&lt;script&gt;<br/>  import Card from './Card.svelte';<br/>&lt;/script&gt;</span><span id="d050" class="oh ng iq lu b gy om oj l ok ol">&lt;Card userid="#2312312" name="Jhon Doe"/&gt;</span></pre><p id="61c7" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">提示:在Svelte中使用Typescript将解决组件内部属性的类型检查。</p></div><div class="ab cl my mz hu na" role="separator"><span class="nb bw bk nc nd ne"/><span class="nb bw bk nc nd ne"/><span class="nb bw bk nc nd"/></div><div class="ij ik il im in"><h1 id="f391" class="nf ng iq bd nh ni nj nk nl nm nn no np jw nq jx nr jz ns ka nt kc nu kd nv nw bi translated">2.时间</h1><p id="f16e" class="pw-post-body-paragraph kv kw iq kx b ky nx jr la lb ny ju ld le nz lg lh li oa lk ll lm ob lo lp lq ij bi translated">组件可能有多个子组件，通过使用插槽，我们可以定义子组件的位置。它基于web组件插槽提议。</p><pre class="kg kh ki kj gt od lu oe of aw og bi"><span id="4b0d" class="oh ng iq lu b gy oi oj l ok ol">&lt;div class="card"&gt;<br/>  &lt;slot/&gt;<br/>&lt;/div&gt;</span></pre><p id="e8c8" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">默认槽可以被定义为子组件中的<code class="fe lr ls lt lu b">&lt;slot&gt;</code> HTML标签。</p><p id="5e6b" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">插槽帮助我们将组件设计为模板，我们基于命名的插槽注入HTML。以下示例将显示带回退的命名插槽组件。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi on"><img src="../Images/8f303cf13f529bfe87eebfba0c2a42e4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*cZWEgp13KDdn07UpuRWE9A.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">具有插槽的卡组件</p></figure></div><div class="ab cl my mz hu na" role="separator"><span class="nb bw bk nc nd ne"/><span class="nb bw bk nc nd ne"/><span class="nb bw bk nc nd"/></div><div class="ij ik il im in"><h1 id="f242" class="nf ng iq bd nh ni nj nk nl nm nn no np jw nq jx nr jz ns ka nt kc nu kd nv nw bi translated">3.事件</h1><p id="17dd" class="pw-post-body-paragraph kv kw iq kx b ky nx jr la lb ny ju ld le nz lg lh li oa lk ll lm ob lo lp lq ij bi translated">当我们设计组件时，从子组件捕获事件是一件有趣的事情。让我们用最喜欢的toggle heart按钮更新我们的card组件，并根据用户事件显示它已被填充。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi oo"><img src="../Images/6accefc6b149eefefff1e51cf19b32ee.png" data-original-src="https://miro.medium.com/v2/resize:fit:800/1*XIFYmhahMI0RJtxfPp0xXw.gif"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">心形标签示例。</p></figure><p id="1f41" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">为了调度事件，我们必须从Svelte导入<code class="fe lr ls lt lu b">{createEventDispatcher}</code>。在子事件函数上，我们发送想要触发的数据和事件名称。</p><p id="ae61" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated"><code class="fe lr ls lt lu b">dispatch(&lt;eventName&gt;, &lt;data-object&gt;)</code>源自<code class="fe lr ls lt lu b">createEventDispatcher</code></p><p id="fa3f" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">让我们看看下面的代码是如何做到的。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="op oq l"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">带有调度收藏夹按钮事件的CardEvent.svelte文件</p></figure><p id="d396" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">我们从父节点获得三个属性id、name、favor，并在单击<code class="fe lr ls lt lu b">heartIcon</code>时用数据调度事件。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="op oq l"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">使用CardEvent.svelte的App.svelte</p></figure><p id="7683" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">我们使用扩展操作符<code class="fe lr ls lt lu b">{...}</code>将<code class="fe lr ls lt lu b">user</code>对象设置为子组件的道具，并监听<code class="fe lr ls lt lu b">favorite</code>点击事件，当它发生时我们调用<code class="fe lr ls lt lu b">whenFavored()</code>函数并将值设置为父对象。</p><h2 id="7190" class="oh ng iq bd nh or os dn nl ot ou dp np le ov ow nr li ox oy nt lm oz pa nv pb bi translated">奖金方法</h2><ol class=""><li id="72fc" class="mk ml iq kx b ky nx lb ny le pc li pd lm pe lq mp mq mr ms bi translated">在多层嵌套组件上，可以使用事件转发方法来转发事件，如<code class="fe lr ls lt lu b">&lt;card on:favorite /&gt;</code>将事件传递给其父组件。它也适用于DOM事件。</li><li id="1644" class="mk ml iq kx b ky mt lb mu le mv li mw lm mx lq mp mq mr ms bi translated">我们还可以将子组件绑定为对父对象的引用，并访问所有导出的子方法。例如，我们将<code class="fe lr ls lt lu b">userCard</code>对象中的<code class="fe lr ls lt lu b">Card</code>组件称为<code class="fe lr ls lt lu b">&lt;Card bind:this={userCard} /&gt;</code>。</li></ol></div><div class="ab cl my mz hu na" role="separator"><span class="nb bw bk nc nd ne"/><span class="nb bw bk nc nd ne"/><span class="nb bw bk nc nd"/></div><div class="ij ik il im in"><h1 id="a159" class="nf ng iq bd nh ni nj nk nl nm nn no np jw nq jx nr jz ns ka nt kc nu kd nv nw bi translated">4.上下文API</h1><p id="8f2b" class="pw-post-body-paragraph kv kw iq kx b ky nx jr la lb ny ju ld le nz lg lh li oa lk ll lm ob lo lp lq ij bi translated">我们现在正进入通信技术的高级但有用的特征。上下文API为我们提供了强大的机制来与子组件“对话”,而无需传递数据和函数作为道具或分派大量事件。</p><blockquote class="lv"><p id="6f7a" class="lw lx iq bd ly lz ma mb mc md me lq dk translated">“只有当我们以对接受者有意义的方式交流，而不是对我们自己有意义的方式交流，交流才是有效的。”</p><p id="ebb8" class="lw lx iq bd ly lz ma mb mc md me lq dk translated">—里奇·西蒙兹</p></blockquote><p id="2d29" class="pw-post-body-paragraph kv kw iq kx b ky mf jr la lb mg ju ld le mh lg lh li mi lk ll lm mj lo lp lq ij bi translated">使用<code class="fe lr ls lt lu b">setContext()</code>所需的祖先(顶层组件)及其所有后代(子组件)将使用<code class="fe lr ls lt lu b">getContext()</code>获得数据看起来很简单，对吗？是的，就这么简单。</p><pre class="kg kh ki kj gt od lu oe of aw og bi"><span id="027f" class="oh ng iq lu b gy oi oj l ok ol">//App.svelte</span><span id="4a11" class="oh ng iq lu b gy om oj l ok ol">&lt;script&gt;<br/> import Card from './CardContext.svelte' <br/> import {setContext} from 'svelte';</span><span id="707c" class="oh ng iq lu b gy om oj l ok ol"> let user ={<br/>  id:123456,<br/>  name:'Jhon Doe',<br/>  favor : true<br/> } <br/> setContext('user', user);</span><span id="f9ee" class="oh ng iq lu b gy om oj l ok ol">&lt;/script&gt;</span><span id="6663" class="oh ng iq lu b gy om oj l ok ol">&lt;Card/&gt;</span></pre><p id="a424" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">我们通过使用键<code class="fe lr ls lt lu b">'User'</code>来设置用户对象，以使用它的所有后代。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="op oq l"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">CardContext.svelte</p></figure><p id="c942" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">上下文的状态仅对其子代可用。如果您希望使用一个组件的多个实例，并且其中一个实例的状态不会干扰其他实例的状态，这可能会很有帮助。</p></div><div class="ab cl my mz hu na" role="separator"><span class="nb bw bk nc nd ne"/><span class="nb bw bk nc nd ne"/><span class="nb bw bk nc nd"/></div><div class="ij ik il im in"><h1 id="0c96" class="nf ng iq bd nh ni nj nk nl nm nn no np jw nq jx nr jz ns ka nt kc nu kd nv nw bi translated">5.<strong class="ak">模块上下文</strong></h1><p id="8b66" class="pw-post-body-paragraph kv kw iq kx b ky nx jr la lb ny ju ld le nz lg lh li oa lk ll lm ob lo lp lq ij bi translated">在同一个组件的所有实例之间共享数据就像在模块脚本中添加变量一样简单。</p><p id="594f" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">让我们看一个例子，单击一个组件中的标签，并以有趣的方式突出显示同一组件的其他实例上的标签名称。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi pf"><img src="../Images/3b06a1bf25df13dbd966ced54356ba6b.png" data-original-src="https://miro.medium.com/v2/resize:fit:708/1*Kb-H_r7LmG87M0n6BCI0JA.gif"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">标签点击清除所有按钮</p></figure><p id="1e06" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">使用<code class="fe lr ls lt lu b">users</code>对象在App.svelte父组件中创建所有卡片实例，并将用户数据作为道具发送。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="op oq l"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">App.svelte</p></figure><p id="b449" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">我们还添加了一个模块方法<code class="fe lr ls lt lu b">{clearAll}</code>来清除点击“Clear All”按钮时的高亮显示。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="op oq l"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">CardWithModuleContext.svelte</p></figure><p id="2070" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">变量<code class="fe lr ls lt lu b">tagSelected</code>在所有实例之间共享。以一种有趣的理解方式，我们添加了一个100毫秒的固定间隔来更新突出显示的标签。正如您所看到的，所有的逻辑都被添加到子组件中，并与其他实例“对话”。</p></div><div class="ab cl my mz hu na" role="separator"><span class="nb bw bk nc nd ne"/><span class="nb bw bk nc nd ne"/><span class="nb bw bk nc nd"/></div><div class="ij ik il im in"><h1 id="4c22" class="nf ng iq bd nh ni nj nk nl nm nn no np jw nq jx nr jz ns ka nt kc nu kd nv nw bi translated">6.商店</h1><p id="7150" class="pw-post-body-paragraph kv kw iq kx b ky nx jr la lb ny ju ld le nz lg lh li oa lk ll lm ob lo lp lq ij bi translated">随着应用程序的发展，添加更多的功能意味着添加更多的组件。这往往会增加复杂性。此时，我们需要将应用程序状态置于组件的层次结构之外。内置的苗条商店可以方便地做到这一点。</p><p id="6714" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">在苗条商店中，我们可以保存单个对象或一个数组。斯韦特有许多不同种类的商店。存储可以是可写的、可读的、派生的或自定义的。</p><p id="d581" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">让我们用表单和列表组件创建一个简单的可写书店。</p><p id="0419" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated"><em class="pg"> BookStore.js </em></p><pre class="kg kh ki kj gt od lu oe of aw og bi"><span id="53a5" class="oh ng iq lu b gy oi oj l ok ol">import { writable } from 'svelte/store'</span><span id="8b02" class="oh ng iq lu b gy om oj l ok ol">export let bookStore = writable([<br/> {name:"Hamlet",author:"William Shakespeare"},<br/> {name:"The Great Gatsby",author:"F. Scott Fitzgerald"}<br/>]);</span></pre><p id="61dd" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated"><em class="pg"> BookList.svelte </em></p><pre class="kg kh ki kj gt od lu oe of aw og bi"><span id="2493" class="oh ng iq lu b gy oi oj l ok ol">&lt;script&gt;<br/> import { bookStore } from './BookStore.js' <br/>&lt;/script&gt;<br/>&lt;ul&gt;<br/> {#each $bookStore as book}<br/>  &lt;li&gt;{book.name} - {book.author}&lt;/li&gt;<br/> {/each} <br/>&lt;/ul&gt;</span></pre><p id="d223" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated"><em class="pg"> BookForm.svelte </em></p><pre class="kg kh ki kj gt od lu oe of aw og bi"><span id="847b" class="oh ng iq lu b gy oi oj l ok ol">&lt;script&gt;<br/> import { bookStore } from './BookStore.js' <br/> let bookName;<br/> let author;<br/> const addNew = ()=&gt;{<br/>  $bookStore = [{name:bookName, author:author},...$bookStore,];<br/> }<br/>&lt;/script&gt;<br/>&lt;input type="text" bind:value={bookName} placeholder="Book Name"/&gt;<br/>&lt;input type="text" bind:value={author} placeholder="Author Name"/&gt;<br/>&lt;button on:click={addNew}&gt;+ Add Book&lt;/button&gt;</span></pre><p id="67ff" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated"><em class="pg"> App.svelte </em></p><pre class="kg kh ki kj gt od lu oe of aw og bi"><span id="d4f9" class="oh ng iq lu b gy oi oj l ok ol">&lt;script&gt;<br/> import BookList from './BookList.svelte'<br/> import BookForm from './BookForm.svelte' <br/>&lt;/script&gt;<br/>&lt;BookForm/&gt;<br/>&lt;BookList/&gt;</span></pre><p id="f899" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">我们将<code class="fe lr ls lt lu b">bookStore</code>创建为一个可写数组。通过使用sugar语法<code class="fe lr ls lt lu b">$</code>访问数据，它被导入到表单和列表组件中。是啊！<code class="fe lr ls lt lu b">$bookStore</code>是反应式的，可以用在我们应用的任何地方。</p></div><div class="ab cl my mz hu na" role="separator"><span class="nb bw bk nc nd ne"/><span class="nb bw bk nc nd ne"/><span class="nb bw bk nc nd"/></div><div class="ij ik il im in"><h1 id="e51a" class="nf ng iq bd nh ni nj nk nl nm nn no np jw nq jx nr jz ns ka nt kc nu kd nv nw bi translated">上下文与存储</h1><p id="3706" class="pw-post-body-paragraph kv kw iq kx b ky nx jr la lb ny ju ld le nz lg lh li oa lk ll lm ob lo lp lq ij bi translated">上下文和存储二者是相似的。不同之处仅在于应用程序的任何部分都可以访问存储，而上下文只对其后代可用。</p></div><div class="ab cl my mz hu na" role="separator"><span class="nb bw bk nc nd ne"/><span class="nb bw bk nc nd ne"/><span class="nb bw bk nc nd"/></div><div class="ij ik il im in"><h1 id="22d0" class="nf ng iq bd nh ni nj nk nl nm nn no np jw nq jx nr jz ns ka nt kc nu kd nv nw bi translated">资源</h1><p id="f63c" class="pw-post-body-paragraph kv kw iq kx b ky nx jr la lb ny ju ld le nz lg lh li oa lk ll lm ob lo lp lq ij bi translated">在这篇文章中解释的所有例子都可以在苗条的REPL找到。通过导入不同的卡组件来检查结果，以测试更新App.svelte文件。(<a class="ae ph" href="https://svelte.dev/repl/4ba0194c810b487b88c266c115c2d4dc?version=3.25.1" rel="noopener ugc nofollow" target="_blank">演示</a>)</p></div><div class="ab cl my mz hu na" role="separator"><span class="nb bw bk nc nd ne"/><span class="nb bw bk nc nd ne"/><span class="nb bw bk nc nd"/></div><div class="ij ik il im in"><h1 id="c32a" class="nf ng iq bd nh ni nj nk nl nm nn no np jw nq jx nr jz ns ka nt kc nu kd nv nw bi translated">结论</h1><p id="38c9" class="pw-post-body-paragraph kv kw iq kx b ky nx jr la lb ny ju ld le nz lg lh li oa lk ll lm ob lo lp lq ij bi translated">组件之间的通信是应用程序设计中最重要的部分。在Svelte中，我们有内置的状态管理功能，可以为我们设计更好的应用程序提供良好的灵活性。</p></div></div>    
</body>
</html>