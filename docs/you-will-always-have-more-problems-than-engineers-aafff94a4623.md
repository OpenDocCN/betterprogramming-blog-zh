# 你永远比工程师有更多的问题。

> 原文：<https://betterprogramming.pub/you-will-always-have-more-problems-than-engineers-aafff94a4623>

## 如何面对悲伤的现实？

![](img/13a71a73f7273b7b8f9b8dbe8159cd9a.png)

阿德里安·斯旺卡在 [Unsplash](https://unsplash.com/s/photos/broken?utm_source=unsplash&utm_medium=referral&utm_content=creditCopyText) 上拍摄的照片

> 每个人都知道调试比一开始写程序要难两倍。所以，如果你在编写它的时候尽可能的聪明，你将如何调试它呢？
> 
> 布莱恩·柯尼根

打破东西总是比制造东西容易。软件也不例外。如果说有什么不同的话，那就是软件让它变得清晰了。我们可以*证明*有[无限数量的有效软件程序](https://math.stackexchange.com/questions/204519/is-the-set-of-all-valid-c-programs-countably-infinite)。其中有多少真正做到了我们想要的，没有错误？

**少得多的**(然而有趣的是，仍然[无限的](https://en.wikipedia.org/wiki/Minification_(programming)))。

即使你忽略软件工程师自己制造的所有错误，软件工程师也只占世界人口的 0.3%。大自然母亲和其他 77 亿人没有闲着。是的，许多其他人不用软件也能解决问题，当然也不是所有人制造的问题都能用软件解决。然而，当世界各地的公司试图利用技术解决世界上的问题时，他们不得不面对一个不可侵犯的事实:问题总是比工程师多。

这是有后果的。Kernighan 专注于软件设计。简单的设计导致更易维护的软件。当软件更容易维护时，它会导致更少(和更小)的问题。但在严格的技术领域之外，还有更大、更广泛的后果:

# 优先级变得无法解决。

公司对积压的工作感到困扰。他们看到了所有这些问题，并通过雇用整个项目经理团队来建立和优先考虑一些巨大的吉拉董事会。但是当你意识到你总是比工程师有更多的问题时，优化一个待办事项是没有意义的。当你被问题淹没时，*整理它们*不是最重要的技能，*过滤它们*才是。最有价值的优先排序技巧就是简单地说“不，我不会马上解决那个问题”。

很多时候，团队采取相反的方法。他们列出了所有的功能、缺陷、客户要求、技术债务和值得拥有的东西。他们试图构建所有工作的完整画面，以便可以对事物进行比较、评估和排序——即使软件任务很少具有可量化的价值。你的团队*可以*做的工作比他们有生之年*将要*做的工作要多得多。列举这个清单是愚蠢的。

更大的挑战是*即使*你设法做到了所有这些，你的大部分问题仍然不会出现在待办事项中。这让我们想到了第二个结果:

# 工程师也需要优先化技能。

大多数问题都不是大问题。他们不是在构建一些 API 或者优化一些算法。他们没有修复一些 bug，也没有测试 9000 款安卓系统。大多数问题都是 ***微小的*** 。比如“我应该给这个变量取什么名字？”或者“这应该是列表还是地图？”或者“鲍勃需要知道这件事吗？”—问题如此之小，以至于每次出现问题都要开会是不切实际的。

工程师如何对那些微小的问题进行优先排序？如果我们很慷慨的话。软件工程师没有得到优先化技能的培训。他们很少得到工作量管理方面的指导。没有一个很好的反馈回路让工程师知道他们的选择是否在改进。单独来看，这些小问题并不重要，但是综合起来，它们代表了软件成败的很大一部分。

有意重视和投资工程师的工作管理技能是提高工程师效率的良好开端。这将使他们不会被问题淹没，并且理想地帮助他们专注于有价值的事情。但这还不够。知道什么问题有价值，对什么问题说“不”需要*语境*。当所有的工程师都有一个带有评估的用户故事时，他们就不知道上下文了。他们所知道的只是一个接受标准和一个估计——做什么和什么时候做。他们不明白*为什么*要做这件事，或者在做这件事的时候他们应该支持什么样的权衡，或者他们可以做什么来代替。

是的，软件工程师不擅长区分优先级。协调每个人做出自己的权衡是一件困难的工作。但是解决方案并不是将优先级从工程师手中拿走！他们通常是最接近问题的人！解决办法是把他们放在一个更有可能成功的环境中。给他们一些背景。构建良好的抽象，这样团队就可以安全地[忽略大多数问题](https://matt-schellhas.medium.com/zooming-out-the-first-challenge-of-a-growing-team-8109a329f5be)。帮助他们提高处理自己不可避免的堆积如山的问题所需的技能。

# 异想天开的计划变成了幻想。

每个人都喜欢一个计划的出台。我们喜欢一场精心设计的抢劫以好人带着赃物走出赌场而告终。我们喜欢看到一些菜鸟从激光炮塔的峡谷中飞下来拯救了宇宙，这样他们终于可以利用他们在[虐待动物的历史](https://getyarn.io/yarn-clip/b0c74d07-c55c-4c39-8686-7a229e26d47d)做好事了。我们喜欢看到那些 1 到 14，000，605 长镜头(以及 22 部电影的投资)得到回报。

一些幸运的傻瓜做着不可能的事情是伟大的幻想，但这些都是 ***可怕的*** 计划。

它们都是错综复杂的，有许多(不太可能)的事情必须发生*恰好*让英雄们成功。这使它们变得脆弱。如果计划的一部分遇到了问题，那么整个计划就开始分崩离析。人们争先恐后地保持一致，通常做出轻率的决定，而不是成为破坏大计划的人。你会比工程师有更多的问题。你的计划需要考虑到这一点。

让我们考虑一部有好计划的电影。在 [*浪人*](https://en.wikipedia.org/wiki/Ronin_(film)) 的开始，山姆要去一家咖啡馆会见一些危险的陌生人。很多事情都可能出错。他提前观察了咖啡馆，并制定了一个计划。他在咖啡馆后面藏了一把枪。当他进入咖啡馆时，他要了厕所，并以此为借口打开了后门。如果任何数量的事情出错，现在他有一个更快的退出和枪准备好，如果需要的话。

问题是萨姆不需要执行计划。会议进行得很顺利。每个人都平静地走出门外，他取回了枪。大多数公司认为这是浪费 T21。花在没有价值的事情上的工作？那是需要清理的东西！要优化掉的东西！

但这是公司需要接受的那种计划。好的计划会增加你的选择，即使你并不总是需要它们。当事情变糟时(他们会的)，那扇没锁的门或藏起来的枪意味着你有更多的胜利之路。你不应该为每一个可能的问题做计划。反正他们人太多了。关注大的和可能的。给自己一些选择，这样当你最终发现这次会出现哪个问题时，你就可以选择最好的选择。

# 进步是跑步机。

想象一下，你有一张要做的家务清单。打扫房子，割草，付账单。你不是真的想做，但是你是一个有责任心的成年人，所以你必须做。一天的辛苦工作之后，你完成了所有的杂务，却发现清单变大了！现在你需要修车、遛狗、做晚饭、预约医生，还有……唉。

简而言之，这就是软件工程。

当你的团队解决问题时，公司就成功了，也成长了。现在你的团队需要解决更多、更困难的问题(除了维护你已经构建的东西)。对于关注问题的人来说，事情似乎永远不会变好。所有这些工作，仍然有所有这些问题。他们跑了几个小时，但没有到达任何地方。

因为总会有更多的问题，工程师的成就感需要来自其他地方。有些人过得很轻松。他们喜欢解决问题。对他们来说，永无止境的问题就像是世界上最大的游戏。只要保持乐趣(通常是通过在难度和多样性之间找到适当的平衡)，如果他们不能到达任何地方，那也没关系——旅程对他们来说已经足够了。

其他人更难。他们需要看到变化。当总是有更多的问题需要解决时，这是行不通的。你可以用一生的时间让你所在的地方变得更好，同时还有一辈子的工作要做。这并不意味着你没有完成任何事情。完全相反！但是唯一的方法就是回顾过去。

衡量进展的更好方法是忽略问题，想想我们已经建立了什么。我们今天能做哪些昨天不能做的事情？现在有哪些事情比较容易？如果我们不在那里，什么会变成废墟？这些事情确实会改变。我们可以回顾过去，看看现在的情况如何比过去好。是的，新软件带来了新问题。

总会有更多的问题。

大多数公司都不明白。大多数人不明白。对他们来说，问题是失败的标志。他们认为默认状态是完美。他们相信，如果我们足够努力地工作——*计划*足够努力，那么就不会有任何问题。我们从完美状态跌落的唯一原因是有人在某处搞砸了。

但那不是现实。我们现实的默认状态是混乱。这是毁灭。它是熵、侵蚀和人性。我们建造东西来创造一个更美好的世界，是的，其中一部分是人们的失败。人们总是会失败。这很糟糕，但你不会改变它。所以你还是好好生活吧。