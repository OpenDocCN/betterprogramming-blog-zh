<html>
<head>
<title>Python Functions: Lambdas, Closures, Decorators, and Currying</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Python函数:Lambdas、闭包、装饰器和Currying</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/python-functions-lambdas-closures-decorators-and-currying-83165d099abe?source=collection_archive---------6-----------------------#2020-04-22">https://betterprogramming.pub/python-functions-lambdas-closures-decorators-and-currying-83165d099abe?source=collection_archive---------6-----------------------#2020-04-22</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="456d" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">理解Python中的四个高级函数概念</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/1260c8c88b93aae790f591c71ac1e987.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*plDsiXwfhPWvAHAm"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">照片由<a class="ae ky" href="https://unsplash.com/@timswaanphotography?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">蒂姆·斯万</a>在<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄。</p></figure><p id="1cce" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">Python函数是一个代码块，当它们被请求运行时执行特定的操作，我们称之为调用函数。大多数情况下，我们使用以下语法来声明和调用函数:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="lv lw l"/></div></figure><p id="2127" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在上面的代码中，我们使用关键字<code class="fe lx ly lz ma b">def</code>声明了一个名为<code class="fe lx ly lz ma b">add_up</code>的函数。这个函数将两个数字(<code class="fe lx ly lz ma b">num1</code>和<code class="fe lx ly lz ma b">num2</code>)作为输入参数，按照定义的操作计算它们的和，并将这个值作为函数的输出返回。很简单，对吧？</p><p id="2d13" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">除了这些常规函数，Python中还有其他种类的函数可以让我们的开发受益。让我们在本文中回顾一下它们。</p></div><div class="ab cl mb mc hx md" role="separator"><span class="me bw bk mf mg mh"/><span class="me bw bk mf mg mh"/><span class="me bw bk mf mg"/></div><div class="im in io ip iq"><h1 id="736a" class="mi mj it bd mk ml mm mn mo mp mq mr ms jz mt ka mu kc mv kd mw kf mx kg my mz bi translated">λ函数</h1><p id="4f22" class="pw-post-body-paragraph kz la it lb b lc na ju le lf nb jx lh li nc lk ll lm nd lo lp lq ne ls lt lu im bi translated">Lambda函数是小型匿名单行函数。有时，我们可以简单地称它们为兰姆达斯。Lambdas具有以下语法:</p><pre class="kj kk kl km gt nf ma ng nh aw ni bi"><span id="30d8" class="nj mj it ma b gy nk nl l nm nn">lambda arguments: expression</span></pre><p id="c961" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们使用<code class="fe lx ly lz ma b">lambda</code>关键字声明一个lambda函数。在这个关键字之后，我们指定参数列表，参数的数量可以从零到多个不等。然后，我们指定想要执行的操作，这就是lambda函数的表达式。</p><p id="23c9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">正如您所看到的，lambdas具有非常简洁的语法，因此它们最适合于需要简单的一次性函数的场景。让我们考虑下面的例子。<code class="fe lx ly lz ma b">sorted()</code>函数根据<code class="fe lx ly lz ma b">key</code>参数指定的键函数对iterable进行排序:</p><pre class="kj kk kl km gt nf ma ng nh aw ni bi"><span id="bf91" class="nj mj it ma b gy nk nl l nm nn">&gt;&gt;&gt; # define a list of tuples<br/>&gt;&gt;&gt; records = [(1, 'John'), (2, 'Aaron'), (5, 'Ian')]<br/>&gt;&gt;&gt; # sort with a lambda<br/>&gt;&gt;&gt; sorted(records, key=lambda x: len(x[1]))<br/>[(5, 'Ian'), (1, 'John'), (2, 'Aaron')]</span></pre><p id="16c1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在上面的代码中，我们首先定义了一个列表来存储一些学生的记录以及他们的学号和姓名。然后我们用lambda函数对它们进行排序，该函数根据学生姓名的长度对列表进行排序。</p><p id="408b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">关于使用lambda函数排序的信息，可以参考我以前的文章。知道兰姆达斯可能被误用也很重要。为了您的方便，提供以下文章:</p><div class="no np gp gr nq nr"><a href="https://medium.com/better-programming/advanced-sorting-in-python-using-lambdas-and-custom-functions-410b5780fb07" rel="noopener follow" target="_blank"><div class="ns ab fo"><div class="nt ab nu cl cj nv"><h2 class="bd iu gy z fp nw fr fs nx fu fw is bi translated">Python中使用Lambdas和自定义函数的高级排序</h2><div class="ny l"><h3 class="bd b gy z fp nw fr fs nx fu fw dk translated">对非基本数据类型(如int、str)的元素列表进行排序</h3></div><div class="nz l"><p class="bd b dl z fp nw fr fs nx fu fw dk translated">medium.com</p></div></div><div class="oa l"><div class="ob l oc od oe oa of ks nr"/></div></div></a></div><div class="no np gp gr nq nr"><a href="https://medium.com/better-programming/the-top-4-misuses-of-lambdas-in-python-e419f426b74f" rel="noopener follow" target="_blank"><div class="ns ab fo"><div class="nt ab nu cl cj nv"><h2 class="bd iu gy z fp nw fr fs nx fu fw is bi translated">Python中Lambdas的4大误用</h2><div class="ny l"><h3 class="bd b gy z fp nw fr fs nx fu fw dk translated">使用Python lambdas的最佳实践</h3></div><div class="nz l"><p class="bd b dl z fp nw fr fs nx fu fw dk translated">medium.com</p></div></div><div class="oa l"><div class="og l oc od oe oa of ks nr"/></div></div></a></div></div><div class="ab cl mb mc hx md" role="separator"><span class="me bw bk mf mg mh"/><span class="me bw bk mf mg mh"/><span class="me bw bk mf mg"/></div><div class="im in io ip iq"><h1 id="132d" class="mi mj it bd mk ml mm mn mo mp mq mr ms jz mt ka mu kc mv kd mw kf mx kg my mz bi translated">关闭</h1><p id="62b3" class="pw-post-body-paragraph kz la it lb b lc na ju le lf nb jx lh li nc lk ll lm nd lo lp lq ne ls lt lu im bi translated">闭包是捕获外部函数的非局部变量的嵌套函数。我认为从概念上理解闭包并不容易。<a class="ae ky" href="https://medium.com/swlh/anatomize-pythons-closures-dbf0fa217d38" rel="noopener">彻底理解</a>需要深入了解Python中作为一级对象的<a class="ae ky" href="https://medium.com/better-programming/6-things-to-know-to-demystify-namespaces-and-scopes-in-python-f5353c7ff56f" rel="noopener">作用域</a>和<a class="ae ky" href="https://medium.com/swlh/everything-is-an-object-in-python-learn-to-use-functions-as-objects-ace7f30e283e" rel="noopener">函数。出于本文的目的，让我们通过一个具体的例子对闭包有一个总体的了解:</a></p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="lv lw l"/></div></figure><p id="c60b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在上面的代码中，我们定义了一个名为<code class="fe lx ly lz ma b">make_multiplier</code>的函数。因为它包含了另一个函数<code class="fe lx ly lz ma b">multiplier</code>，我们可以称<code class="fe lx ly lz ma b">make_multiplier</code>为外部函数，称<code class="fe lx ly lz ma b">multiplier</code>为嵌套函数。外部函数返回嵌套函数作为其返回值。重要的是，嵌套函数使用并修改了外部函数范围内定义的非局部变量(即<code class="fe lx ly lz ma b">product</code>)。总而言之，在Python中创建闭包有三个关键要素:</p><ol class=""><li id="23da" class="oh oi it lb b lc ld lf lg li oj lm ok lq ol lu om on oo op bi translated">在外部函数的范围内声明一个嵌套函数。</li><li id="7b1e" class="oh oi it lb b lc oq lf or li os lm ot lq ou lu om on oo op bi translated">嵌套函数范围外的非局部变量的绑定。</li><li id="771c" class="oh oi it lb b lc oq lf or li os lm ot lq ou lu om on oo op bi translated">返回嵌套函数以输出闭包函数。</li></ol><p id="57d6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们如何使用闭包？让我们看看下面这个简单的例子:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="lv lw l"/></div></figure><p id="f159" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">然后我们声明一个名为<code class="fe lx ly lz ma b">multiplier3</code>的闭包。每次我们调用这个闭包，乘积就乘以3。换句话说，封盖“记住”了产品最后一次使用后的状态。相关概念包括变量绑定和值捕获。我们可以通过调用<code class="fe lx ly lz ma b">__code__.co_freevars</code>和<code class="fe lx ly lz ma b">__closure__[1].cell_contents</code>来查看相关信息。</p><p id="3f32" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">关于闭包的更多细节，可以参考我以前的文章:</p><div class="no np gp gr nq nr"><a href="https://medium.com/swlh/anatomize-pythons-closures-dbf0fa217d38" rel="noopener follow" target="_blank"><div class="ns ab fo"><div class="nt ab nu cl cj nv"><h2 class="bd iu gy z fp nw fr fs nx fu fw is bi translated">剖析Python的闭包</h2><div class="ny l"><h3 class="bd b gy z fp nw fr fs nx fu fw dk translated">Python中闭包的介绍性剖析，帮助您更好地理解闭包。</h3></div><div class="nz l"><p class="bd b dl z fp nw fr fs nx fu fw dk translated">medium.com</p></div></div><div class="oa l"><div class="ov l oc od oe oa of ks nr"/></div></div></a></div></div><div class="ab cl mb mc hx md" role="separator"><span class="me bw bk mf mg mh"/><span class="me bw bk mf mg mh"/><span class="me bw bk mf mg"/></div><div class="im in io ip iq"><h1 id="1321" class="mi mj it bd mk ml mm mn mo mp mq mr ms jz mt ka mu kc mv kd mw kf mx kg my mz bi translated">装修工</h1><p id="969b" class="pw-post-body-paragraph kz la it lb b lc na ju le lf nb jx lh li nc lk ll lm nd lo lp lq ne ls lt lu im bi translated">装饰器是扩展其他函数的行为而不显式修改它们的函数。装饰器本质上是一种高阶函数，定义为要么以其他函数为输入，要么返回其他函数为输出的函数。让我们通过下面的例子对装饰者有一个真实的感受:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="lv lw l"/></div></figure><p id="3ad4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在上面的代码中，我们定义了两个函数(<code class="fe lx ly lz ma b">clap</code>和<code class="fe lx ly lz ma b">triple_repeat_wrapper</code>)，后者是一个高阶函数，它在嵌套的<code class="fe lx ly lz ma b">wrapper</code>函数中调用传递的<code class="fe lx ly lz ma b">func</code>三次，并返回<code class="fe lx ly lz ma b">wrapper</code>函数作为高阶函数的输出。</p><p id="4381" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们如何使用这些功能？如下面的代码所示，我们创建了一个名为<code class="fe lx ly lz ma b">wrapped_clap</code>的函数，它将<code class="fe lx ly lz ma b">clap</code>函数传递给高阶函数<code class="fe lx ly lz ma b">triple_repeat_wrapper</code>。如您所见，调用<code class="fe lx ly lz ma b">wrapped_clap</code>函数将导致嵌套的<code class="fe lx ly lz ma b">wrapper</code>函数内的代码被调用。与打印输出一致，我们知道<code class="fe lx ly lz ma b">wrapped_clap</code>函数引用了嵌套函数<code class="fe lx ly lz ma b">wrapper</code>。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="lv lw l"/></div></figure><p id="f81e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">但是如果你回想一下，当你看过一些关于装饰者的示例代码时，你一定见过@符号的用法。这个符号是如何与我们上面定义的功能一起发挥作用的？让我们参考下面的代码来解决这个问题:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="lv lw l"/></div></figure><p id="81c1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在上面的代码中，我们声明了一个名为<code class="fe lx ly lz ma b">hooray</code>的函数。当我们调用这个函数时，输出与前面的<code class="fe lx ly lz ma b">wrapped_clap</code>函数的输出具有相同的格式。类似地，<code class="fe lx ly lz ma b">hooray</code>函数引用嵌套的<code class="fe lx ly lz ma b">wrapper</code>函数。</p><p id="b88a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">为什么会这样？您可能已经注意到，在这个<code class="fe lx ly lz ma b">hooray</code>函数声明的正上方，我们使用@符号作为<code class="fe lx ly lz ma b">triple_repeat_wrapper</code>函数名的前缀。这只是装饰者的语法糖。本质上，我们告诉Python解释器，我们将要定义的函数将被装饰函数包装。</p></div><div class="ab cl mb mc hx md" role="separator"><span class="me bw bk mf mg mh"/><span class="me bw bk mf mg mh"/><span class="me bw bk mf mg"/></div><div class="im in io ip iq"><h1 id="e3e6" class="mi mj it bd mk ml mm mn mo mp mq mr ms jz mt ka mu kc mv kd mw kf mx kg my mz bi translated">Currying</h1><p id="85d3" class="pw-post-body-paragraph kz la it lb b lc na ju le lf nb jx lh li nc lk ll lm nd lo lp lq ne ls lt lu im bi translated">currying以数学家Haskell Curry 的名字命名，指的是通过应用部分参数从现有函数创建新函数。因此，这个概念有时也被称为部分功能。</p><p id="23c7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">与上面的概念相比，这个概念更容易理解。让我们考虑下面的简化示例，使用我们在上面定义的相同函数<code class="fe lx ly lz ma b">add_up</code>:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="lv lw l"/></div></figure><p id="beb5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在上面的代码中，我们使用lambda函数将数字<code class="fe lx ly lz ma b">7</code>设置为<code class="fe lx ly lz ma b">add_up</code>函数的第一个参数。换句话说，创建的<code class="fe lx ly lz ma b">add_seven</code>函数是原始<code class="fe lx ly lz ma b">add_up</code>的部分函数，第一个参数一直被设置为<code class="fe lx ly lz ma b">7</code>。除了使用lambda函数之外，使用常规方式定义带有<code class="fe lx ly lz ma b">def</code>关键字的函数也是可以接受的。</p><p id="192b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在<code class="fe lx ly lz ma b">functools</code>模块中有另一个创建部分功能的便捷工具。考虑下面的例子。我们使用<code class="fe lx ly lz ma b">partial</code>函数来创建<code class="fe lx ly lz ma b">add_ten</code>函数，它有一个默认参数<code class="fe lx ly lz ma b">10</code>来调用<code class="fe lx ly lz ma b">add_up</code>函数:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="lv lw l"/></div></figure></div><div class="ab cl mb mc hx md" role="separator"><span class="me bw bk mf mg mh"/><span class="me bw bk mf mg mh"/><span class="me bw bk mf mg"/></div><div class="im in io ip iq"><h1 id="c2cc" class="mi mj it bd mk ml mm mn mo mp mq mr ms jz mt ka mu kc mv kd mw kf mx kg my mz bi translated">外卖食品</h1><p id="70b8" class="pw-post-body-paragraph kz la it lb b lc na ju le lf nb jx lh li nc lk ll lm nd lo lp lq ne ls lt lu im bi translated">在本文中，我们回顾了Python函数基础之外的四个高级概念。以下是这些概念的简要回顾:</p><ul class=""><li id="6db9" class="oh oi it lb b lc ld lf lg li oj lm ok lq ol lu ow on oo op bi translated">Lambdas是匿名函数，在需要简单的一次性内联函数的情况下非常方便。</li><li id="dfb1" class="oh oi it lb b lc oq lf or li os lm ot lq ou lu ow on oo op bi translated">闭包是嵌套函数，它绑定了周围范围的非局部变量。</li><li id="5ab4" class="oh oi it lb b lc oq lf or li os lm ot lq ou lu ow on oo op bi translated">装饰器是修改其他函数行为的高阶函数。</li><li id="ef52" class="oh oi it lb b lc oq lf or li os lm ot lq ou lu ow on oo op bi translated">Currying是我们如何通过设置一些默认参数从现有函数创建部分函数。</li></ul></div></div>    
</body>
</html>