<html>
<head>
<title>Will Automatic Bug Fixing Work on Your Codebases?</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">自动修复Bug能在你的代码库上工作吗？</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/will-automatic-bug-fixing-work-on-your-codebases-d56cdad4fa78?source=collection_archive---------11-----------------------#2021-08-16">https://betterprogramming.pub/will-automatic-bug-fixing-work-on-your-codebases-d56cdad4fa78?source=collection_archive---------11-----------------------#2021-08-16</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="d5ee" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">如果DeepDebug正在修复您的工作，那么您的项目会有更大的问题</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/13787e97a3c8af98ca44acb4a0d570cd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*jz_xsDmifVAI_tP8"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">凯利·西克玛在<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的照片</p></figure><h2 id="0566" class="kz la it bd lb lc ld dn le lf lg dp lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated">每个程序员都会写bug</h2><p id="e88b" class="pw-post-body-paragraph lv lw it lx b ly lz ju ma mb mc jx md li me mf mg lm mh mi mj lq mk ml mm mn im bi translated">当我十年前开始学习编码时，我对错误非常敏感——当我的程序不工作时，它们让我发疯，尤其是当我和同事展示我的项目时。不知何故，展示我的作品是臭虫决定宣布它们存在的最频繁的场合。在过去的日子里，我在心理上很容易受到虫子的攻击。</p><p id="b6b3" class="pw-post-body-paragraph lv lw it lx b ly mo ju ma mb mp jx md li mq mf mg lm mr mi mj lq ms ml mm mn im bi translated">然而，在编写了更多的代码之后，我意识到我们的编码工作基本上是修复程序中的各种错误。因此，当程序员的代码有错误时，他们不应该感到羞耻。我现在敢说，如果你不写bug，你就不是一个真正的程序员。因为我们作为程序员的部分日常职责就是把bug引入到我们的项目中，这是我们工作保障的根本基础。</p><blockquote class="mt"><p id="241b" class="mu mv it bd mw mx my mz na nb nc mn dk translated">“如果调试是去除软件bug的过程，那么编程一定是把bug放进去的过程。”― <strong class="ak">埃德格·沃克·迪杰斯特拉</strong></p></blockquote><p id="8e98" class="pw-post-body-paragraph lv lw it lx b ly nd ju ma mb ne jx md li nf mf mg lm ng mi mj lq nh ml mm mn im bi translated">玩笑归玩笑，我们可能应该同意我们的目标不是写bug。然而，bug是我们正在开发的代码库不可避免的副产品。网上的一些讨论(比如<a class="ae ky" href="https://www.quora.com/What-is-the-average-ratio-of-bugs-to-a-line-of-code" rel="noopener ugc nofollow" target="_blank"> Quora:一行代码中bug的平均比例是多少？</a>)揭示了每1000行代码中有15到50个错误，这取决于您何时/如何检查代码(例如，代码第一次键入时的打字错误)。</p><h1 id="bf60" class="ni la it bd lb nj nk nl le nm nn no lh jz np ka ll kc nq kd lp kf nr kg lt ns bi translated">修复bug既繁琐又昂贵</h1><p id="7d4b" class="pw-post-body-paragraph lv lw it lx b ly lz ju ma mb mc jx md li me mf mg lm mh mi mj lq mk ml mm mn im bi translated">鉴于错误在任何软件开发过程中的普遍存在，定位和修复错误是程序员工作的关键部分。不幸的是，这需要大量的时间和成本。以下是我在网上找到的一些事实(<a class="ae ky" href="https://www.openrefactory.com/intelligent-code-repair-icr/" rel="noopener ugc nofollow" target="_blank">来源</a>)。</p><blockquote class="nt nu nv"><p id="a84a" class="lv lw nw lx b ly mo ju ma mb mp jx md nx mq mf mg ny mr mi mj nz ms ml mm mn im bi translated"><em class="it">修复一个bug比写一行代码要多花30倍的时间。</em></p><p id="aea3" class="lv lw nw lx b ly mo ju ma mb mp jx md nx mq mf mg ny mr mi mj nz ms ml mm mn im bi translated"><em class="it">一个开发者75%的时间花在调试上(一年1500小时！).</em></p><p id="257c" class="lv lw nw lx b ly mo ju ma mb mp jx md nx mq mf mg ny mr mi mj nz ms ml mm mn im bi translated"><em class="it">仅在美国，每年就有1130亿美元花费在识别和修复产品缺陷上。</em></p></blockquote><p id="5fed" class="pw-post-body-paragraph lv lw it lx b ly mo ju ma mb mp jx md li mq mf mg lm mr mi mj lq ms ml mm mn im bi translated">为了检测和修复bug，传统的方法主要是手动过程。我们编写测试代码来检查我们能想到的所有可能的用例。然后我们祈祷所有的bug都自己弹出来，这样我们就可以相应地修复它们。虽然我们尽了最大的努力去去除bug，但是在生产过程中，当出现了超出我们最初想法和计划的罕见用例时，总会有一些bug冒出来。</p><p id="0a8a" class="pw-post-body-paragraph lv lw it lx b ly mo ju ma mb mp jx md li mq mf mg lm mr mi mj lq ms ml mm mn im bi translated">我必须说调试不是编码中最有趣的事情——通常，它是许多程序员不喜欢做的最乏味的过程之一。编写代码是有趣的，因为你正在向一个现有的项目添加新的东西，看着它从一无所有变成一个工作系统。</p><p id="9c6d" class="pw-post-body-paragraph lv lw it lx b ly mo ju ma mb mp jx md li mq mf mg lm mr mi mj lq ms ml mm mn im bi translated">相比之下，修复bug是“无聊”的，因为你在处理一堆有病的代码。在许多情况下，您必须删除您之前编写的大量代码，并重写更多代码来修复bug。对现有代码库的这种破坏有时真的令人沮丧。我知道——没有人喜欢自我否定——修复一个bug基本上就是证明你做的是错的。</p><h1 id="83e2" class="ni la it bd lb nj nk nl le nm nn no lh jz np ka ll kc nq kd lp kf nr kg lt ns bi translated">什么是DeepDebug？</h1><p id="9d28" class="pw-post-body-paragraph lv lw it lx b ly lz ju ma mb mc jx md li me mf mg lm mh mi mj lq mk ml mm mn im bi translated">在最近的一篇论文中，来自微软的研究人员开发并报告了DeepDebug，这是一个使用大型预训练转换器自动检测并修复Python错误的框架。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi oa"><img src="../Images/7cfa5056bb77065ffec31f1271b648db.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*-9mY5YN_ntRAeAsFicdVag.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">DeepDebug的训练模型(来源:【https://arxiv.org/abs/2105.09352】T2，许可:抄送)</p></figure><p id="8337" class="pw-post-body-paragraph lv lw it lx b ly mo ju ma mb mp jx md li mq mf mg lm mr mi mj lq ms ml mm mn im bi translated">这些研究人员从200，000个公共Python库中获取Python代码作为他们的训练数据。使用这些数据，他们开发了他们的初始基线bugpatcher模型(图中的Bugpatcher-commit)和bug creator(图中的Bug creator)，后者使用反向提交数据。bug creator用于创建合成bug，这极大地丰富了训练数据量。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ob"><img src="../Images/37e503efb7d87cbbb73eeb82e73ece40.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*CkBZHo2mY5RnPASfACP9vw.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">使用Bug Creator创建的合成Bug(来源:【https://arxiv.org/abs/2105.09352】T4，授权:CC BY)</p></figure><p id="ce71" class="pw-post-body-paragraph lv lw it lx b ly mo ju ma mb mp jx md li mq mf mg lm mr mi mj lq ms ml mm mn im bi translated">研究人员建立了一个相当复杂的调试框架，它集成了反向翻译(即从目标数据到源数据的翻译)、堆栈跟踪(使用Pytest来跟踪bug)和代码骨架(bug的上下文，如函数、类和导入的模块)。他们的框架优于几个现有的工具，具有更高比例的错误修复(53%)和更少的误报(DeepDebug为1，而现有的同类工具为7和9)。</p><h1 id="61a3" class="ni la it bd lb nj nk nl le nm nn no lh jz np ka ll kc nq kd lp kf nr kg lt ns bi translated">Deepdebug能在现实项目中工作吗？</h1><p id="c762" class="pw-post-body-paragraph lv lw it lx b ly lz ju ma mb mc jx md li me mf mg lm mh mi mj lq mk ml mm mn im bi translated">当许多人第一次听说这个工具时，它听起来很新奇，因为它将消除大量的人工工作，否则这些工作将需要修复我们代码中的错误。然而，当我更多地考虑它的实际应用时，我的怀疑程度增加了。</p><p id="fe9b" class="pw-post-body-paragraph lv lw it lx b ly mo ju ma mb mp jx md li mq mf mg lm mr mi mj lq ms ml mm mn im bi translated">由他们的框架创建和修复的错误本来就不应该存在于我们的项目中。下面是一些例子:</p><ul class=""><li id="088f" class="oc od it lx b ly mo mb mp li oe lm of lq og mn oh oi oj ok bi translated">使用所需方法的错误名称:get_key -&gt; get_value。</li><li id="f8b8" class="oc od it lx b ly ol mb om li on lm oo lq op mn oh oi oj ok bi translated">不相关方法的随机互换:get_key  reverse_list。</li><li id="4b89" class="oc od it lx b ly ol mb om li on lm oo lq op mn oh oi oj ok bi translated">反向比较评价:“≥”—&gt;“</li><li id="a560" class="oc od it lx b ly ol mb om li on lm oo lq op mn oh oi oj ok bi translated">Truncate chained function calls</li><li id="ae2c" class="oc od it lx b ly ol mb om li on lm oo lq op mn oh oi oj ok bi translated">Delete return values</li><li id="1392" class="oc od it lx b ly ol mb om li on lm oo lq op mn oh oi oj ok bi translated">Misname variables: self.result -&gt;自我。_结果</li><li id="54b8" class="oc od it lx b ly ol mb om li on lm oo lq op mn oh oi oj ok bi translated">还有更多</li></ul><p id="a137" class="pw-post-body-paragraph lv lw it lx b ly mo ju ma mb mp jx md li mq mf mg lm mr mi mj lq ms ml mm mn im bi translated">为了让DeepDebug正常工作，您的项目应该包含大量的bug，如示例中所示。具体来说，我的意思是DeepDebug可以极大地帮助检测和修复代码库中的错误。然而，正如你所看到的，几乎没有一个错误会发生在任何有经验的程序员身上。我明白程序员确实会犯错误，但是这些错误，对不起？</p><p id="2dbc" class="pw-post-body-paragraph lv lw it lx b ly mo ju ma mb mp jx md li mq mf mg lm mr mi mj lq ms ml mm mn im bi translated">不管你的项目是你自己的还是团队的，对项目有贡献的每个人都应该负责。如果你不想让别人污染项目，请你自己也不要这么做。因此，我们需要尽最大努力防止DeepDebug“工作”——通过将尽可能少的错误引入到我们自己或共享的项目中。</p><h1 id="3ced" class="ni la it bd lb nj nk nl le nm nn no lh jz np ka ll kc nq kd lp kf nr kg lt ns bi translated">在开发过程中最大限度地减少错误</h1><p id="02b1" class="pw-post-body-paragraph lv lw it lx b ly lz ju ma mb mc jx md li me mf mg lm mh mi mj lq mk ml mm mn im bi translated">有些人写代码比别人快。然而，这并不意味着他们的代码质量更好。当人们不小心时，可能会有更多的错误被嵌入到代码中。以下是我发现的一些有助于保持bug数量最少的方法:</p><ol class=""><li id="3b89" class="oc od it lx b ly mo mb mp li oe lm of lq og mn oq oi oj ok bi translated"><strong class="lx iu">迈小步。</strong>你不会想渐渐地写一堆没有测试的代码。更大的步骤意味着代码复杂性的显著增加，这掩盖了可能的错误，使调试更加困难。</li><li id="739c" class="oc od it lx b ly ol mb om li on lm oo lq op mn oq oi oj ok bi translated"><strong class="lx iu">经常休息。没有人能全天保持100%的注意力。如果你能连续几个小时全神贯注地工作，你就是一个比我更好的程序员。对我来说，我经常每隔一个小时左右休息一下，这可以让我保持精力充沛。如果你不休息，很可能你会因为精神疲劳而在没有意识到的情况下犯错。</strong></li><li id="74a1" class="oc od it lx b ly ol mb om li on lm oo lq op mn oq oi oj ok bi translated">经常检查你的代码。写代码本质上就是写一篇短文。如果你曾经编辑过文章，你可能会同意，审查过程帮助你纠正了一些语法错误，提高了文章的逻辑流。审查你的代码是非常相似的。你可能会发现一些最初没有注意到的错误。</li><li id="f145" class="oc od it lx b ly ol mb om li on lm oo lq op mn oq oi oj ok bi translated"><strong class="lx iu">看大局。当你试图修复一个bug时，你应该在头脑中有一个大的蓝图。我们不想要局部的和临时的修正——你必须彻底地思考:这种改变会给项目的其他部分带来问题吗？</strong></li></ol><h1 id="9add" class="ni la it bd lb nj nk nl le nm nn no lh jz np ka ll kc nq kd lp kf nr kg lt ns bi translated">最后的想法</h1><p id="1507" class="pw-post-body-paragraph lv lw it lx b ly lz ju ma mb mc jx md li me mf mg lm mh mi mj lq mk ml mm mn im bi translated">我们应该感谢这些计算机科学研究人员所做的工作。最终，我们可能会有一个更好的框架来检测基本错误之外的复杂错误。</p><p id="a155" class="pw-post-body-paragraph lv lw it lx b ly mo ju ma mb mp jx md li mq mf mg lm mr mi mj lq ms ml mm mn im bi translated">然而，不管这些自动缺陷检测框架会变得多好，我们程序员应该尽量减少代码库中的缺陷数量。</p><p id="39f8" class="pw-post-body-paragraph lv lw it lx b ly mo ju ma mb mp jx md li mq mf mg lm mr mi mj lq ms ml mm mn im bi translated">就好像这些框架是治疗疾病的有效药物。它们是很好的尝试——除非你的健康受到损害，并且这些药物总是有一些副作用。为什么我们不定期锻炼，并及时完成年度检查，以保持健康呢？</p><p id="06f2" class="pw-post-body-paragraph lv lw it lx b ly mo ju ma mb mp jx md li mq mf mg lm mr mi mj lq ms ml mm mn im bi translated">更聪明地编码，而不是更难。</p></div></div>    
</body>
</html>