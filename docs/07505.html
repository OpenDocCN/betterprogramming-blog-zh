<html>
<head>
<title>Create Stack-Safe Recursion Using Trampolines in Scala</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">在Scala中使用蹦床创建栈安全递归</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/create-stack-safe-recursion-using-trampolines-in-scala-7c0ecd003fb9?source=collection_archive---------5-----------------------#2021-01-21">https://betterprogramming.pub/create-stack-safe-recursion-using-trampolines-in-scala-7c0ecd003fb9?source=collection_archive---------5-----------------------#2021-01-21</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="1256" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">避免函数调用中的堆栈溢出</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/857254e4690497e03a563f9949f06a78.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*zTMIhptyHpH9BV1f"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">照片由<a class="ae ky" href="https://unsplash.com/@jsclick?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">拍摄杰米在<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上看到</a></p></figure><p id="3d6e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">当我们想要计算组合值和其他迭代值时，经常使用递归。在函数中使用递归可以减少函数中编写的代码量。然而，很多时候，当您有大量输入时，递归调用可能很难处理。</p><p id="3c92" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们来看下面这个调用斐波那契的例子:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="lv lw l"/></div></figure><p id="6f57" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在一个常规的递归调用中，我们可以通过尾递归来优化这个值。通常，在Scala中，注释<code class="fe lx ly lz ma b">@tailRec</code>告诉编译器静态检查你写的当前函数是否是尾递归的。</p><p id="3cc2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这样做的问题是，尾递归有时很难构造，一些只有常规代码的函数无法完成尾递归。考虑以尾递归的方式创建斐波那契数列。</p><p id="0444" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这篇文章的灵感来自于Runar比雅纳松的《Scala中的函数式编程》一书。他试图解释<code class="fe lx ly lz ma b">IO</code>,并给出了一些为我们构造的函数创建一般尾递归值的例子。这种尾递归调用叫做蹦床。</p><p id="d368" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在这篇文章中，我想通过Fibonacci的例子来说明为什么它被称为蹦床，以及我们如何构造这个蹦床函数，使所有的函数都是尾递归的。</p><p id="506c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">创建堆栈安全递归的技巧是将递归从堆栈移到堆空间。基本上，我们不是让JVM运行一个递归函数，并在每次执行递归时将新的帧推入堆栈，而是希望编写递归，这样我们就可以控制执行——而不是JVM。</p><p id="946f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在上面的Fibonacci案例中，调用<code class="fe lx ly lz ma b">fib</code>本身将执行控制权交给了JVM。它将<code class="fe lx ly lz ma b">fib(n-1)</code>推到调用框架，因为我们需要计算<code class="fe lx ly lz ma b">fib(n-2)</code>并评估该值。如果我们简化我们的实现而不是调用一个函数，它构造一个数据类型。</p><p id="2b25" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">例如，代替调用<code class="fe lx ly lz ma b">fib(n-1)</code>，我们可以尝试将函数包装成一个数据类型<code class="fe lx ly lz ma b">Suspense(() =&gt; Function[Int, Int])</code>数据类型来保存这个值。本质上，我们是在构造一个数据结构，而不是调用一个函数。</p><p id="0b1f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果我们想用<code class="fe lx ly lz ma b">Suspense</code>包装我们的函数调用，我们的返回值也需要数据类型。</p><p id="56e3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">本质上，函数调用应该是这样的:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="lv lw l"/></div></figure><p id="bde2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们将有一个<code class="fe lx ly lz ma b">Trampolining</code>类型的构造函数来包装我们的结果值。</p><p id="0a1f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果我们在每次函数调用时返回<code class="fe lx ly lz ma b">Trampolining</code>，我们如何将这些结果链接在一起呢？</p><p id="ec31" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe lx ly lz ma b">fib</code>函数的原始值的递归值只返回一个<code class="fe lx ly lz ma b">Int</code>。为了说明我的意思:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="lv lw l"/></div></figure><p id="27ce" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">当我们做<code class="fe lx ly lz ma b">fib(n-1) + fib(n-2)</code>时，它是有效的，因为两者都返回一个<code class="fe lx ly lz ma b">Int</code>，我们可以在上面做加法。但是，如果我们返回一个<code class="fe lx ly lz ma b">Trampolining</code>，那么如何将<code class="fe lx ly lz ma b">Trampolining[Int]</code>和<code class="fe lx ly lz ma b">Trampolining[Int]</code>的结果连锁起来呢？</p><p id="bced" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果我们想对我们的计算进行排序，这听起来像是一个<code class="fe lx ly lz ma b">map</code>或<code class="fe lx ly lz ma b">flatMap</code>。</p><p id="53f3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们的函数看起来像这样:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="lv lw l"/></div></figure><p id="4f1f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">但是，我们也具体化了<code class="fe lx ly lz ma b">flatMap</code>和<code class="fe lx ly lz ma b">map</code>来构造数据类型，而不是调用函数<code class="fe lx ly lz ma b">f</code>。我们只是想将它包装到数据中，以便可以在堆中构建它。</p><p id="c15e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">因此，我们的数据类型<code class="fe lx ly lz ma b">Trampolining</code>必须具有<code class="fe lx ly lz ma b">flatMap</code>和<code class="fe lx ly lz ma b">map</code>功能。</p><p id="c725" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在我解释如何用<code class="fe lx ly lz ma b">Trampolining</code>使这个尾部递归之前，让我们看看下面的例子，它展示了如何构建<code class="fe lx ly lz ma b">Trampolining</code>应该是什么样子:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="lv lw l"/></div></figure><p id="3903" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们可以按以下方式重写现有的递归函数:</p><ul class=""><li id="fea5" class="mc md it lb b lc ld lf lg li me lm mf lq mg lu mh mi mj mk bi translated">如果原始函数返回一个<code class="fe lx ly lz ma b">A</code>，新函数应该返回一个<code class="fe lx ly lz ma b">Trampolining[A]</code></li><li id="fba2" class="mc md it lb b lc ml lf mm li mn lm mo lq mp lu mh mi mj mk bi translated">原始函数中的每个<code class="fe lx ly lz ma b">return</code>值都应该被包装在<code class="fe lx ly lz ma b">Return</code>中</li><li id="c30a" class="mc md it lb b lc ml lf mm li mn lm mo lq mp lu mh mi mj mk bi translated">我们想要<code class="fe lx ly lz ma b">Suspense</code>递归调用，这样程序就不会推到我们的堆栈框架</li><li id="2397" class="mc md it lb b lc ml lf mm li mn lm mo lq mp lu mh mi mj mk bi translated">我们在递归调用之后做的事情，比如<code class="fe lx ly lz ma b">fib(n-1)</code>和<code class="fe lx ly lz ma b">fib(n-2)</code>的加法，都会被包装在<code class="fe lx ly lz ma b">FlatMap</code>里面。</li></ul></div><div class="ab cl mq mr hx ms" role="separator"><span class="mt bw bk mu mv mw"/><span class="mt bw bk mu mv mw"/><span class="mt bw bk mu mv"/></div><div class="im in io ip iq"><h1 id="ef4d" class="mx my it bd mz na nb nc nd ne nf ng nh jz ni ka nj kc nk kd nl kf nm kg nn no bi translated">新斐波那契递归调用</h1><p id="9461" class="pw-post-body-paragraph kz la it lb b lc np ju le lf nq jx lh li nr lk ll lm ns lo lp lq nt ls lt lu im bi translated">我们现在的斐波那契递归调用如下所示:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="lv lw l"/></div></figure></div><div class="ab cl mq mr hx ms" role="separator"><span class="mt bw bk mu mv mw"/><span class="mt bw bk mu mv mw"/><span class="mt bw bk mu mv"/></div><div class="im in io ip iq"><h1 id="b820" class="mx my it bd mz na nb nc nd ne nf ng nh jz ni ka nj kc nk kd nl kf nm kg nn no bi translated">尾部递归的调用</h1><p id="de5f" class="pw-post-body-paragraph kz la it lb b lc np ju le lf nq jx lh li nr lk ll lm ns lo lp lq nt ls lt lu im bi translated">现在把这个做成数据构造器的目的是把程序的控制权委托给程序员。然后我们可以创建一个解释器来解释这个控制流。</p><p id="a9e3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">解释器是我们在程序中使用尾递归调用的地方。</p><p id="80e4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们如下创建我们的解释器:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="lv lw l"/></div></figure><p id="b250" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">注意，在<code class="fe lx ly lz ma b">FlatMap</code>下的<code class="fe lx ly lz ma b">Suspense</code>中，我们需要用<code class="fe lx ly lz ma b">FlatMap</code>将它包装起来，以调用<code class="fe lx ly lz ma b">f</code>函数，一旦函数调用完成，就执行那个<code class="fe lx ly lz ma b">flatMap</code>。如果你只是创建了<code class="fe lx ly lz ma b">run(x())</code>，像上面一样，它在得到<code class="fe lx ly lz ma b">a</code>的值后就不会执行函数了。</p></div><div class="ab cl mq mr hx ms" role="separator"><span class="mt bw bk mu mv mw"/><span class="mt bw bk mu mv mw"/><span class="mt bw bk mu mv"/></div><div class="im in io ip iq"><h1 id="b43d" class="mx my it bd mz na nb nc nd ne nf ng nh jz ni ka nj kc nk kd nl kf nm kg nn no bi translated">运行代码</h1><p id="ab8d" class="pw-post-body-paragraph kz la it lb b lc np ju le lf nq jx lh li nr lk ll lm ns lo lp lq nt ls lt lu im bi translated">让我们用<code class="fe lx ly lz ma b">fibTailRef(5)</code>来执行我们的代码，看看内部发生了什么。</p><p id="f97b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">调用<code class="fe lx ly lz ma b">fibTailRef(5)</code>时，转到<code class="fe lx ly lz ma b">else</code>语句。通过用它的定义替换我们的代码，我们可以得到这样的结果:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="lv lw l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">图表1</p></figure><p id="a599" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">当我们用解释器<code class="fe lx ly lz ma b">run</code>执行这个构造函数时，它将进入<code class="fe lx ly lz ma b">FlatMap</code> - <code class="fe lx ly lz ma b">Suspense</code>情况，如下所示:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="lv lw l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">图表2</p></figure><p id="1279" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">它将执行一个<code class="fe lx ly lz ma b">FlatMap(a(), f)</code>。因此它将如下执行<code class="fe lx ly lz ma b">a()</code>:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="lv lw l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">图表3</p></figure><p id="a5ff" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">此时，我们将评估我们的函数<code class="fe lx ly lz ma b">fibTailRef(4)</code>，它给出了我们:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="lv lw l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">图表4</p></figure><p id="d9ab" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们将上述<code class="fe lx ly lz ma b">fibTailRef(4)</code>的定义代入图4中的<code class="fe lx ly lz ma b">run</code>方法:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="lv lw l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">图表5</p></figure><p id="59b4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">此时，<code class="fe lx ly lz ma b">FlatMap</code>案例在<code class="fe lx ly lz ma b">FlatMap</code>下执行。在这种情况下，我们将函数从<code class="fe lx ly lz ma b">a.flatMap f flatMap f1</code>重新关联到<code class="fe lx ly lz ma b">a.flatMap(x =&gt; f(x).flatMap(f))</code>，所以它是尾递归的。这样做的原因是因为<code class="fe lx ly lz ma b">a</code>将保持递归遍历——直到它遇到来自前两个模式匹配案例的基础案例<code class="fe lx ly lz ma b">Return</code>或<code class="fe lx ly lz ma b">Suspense</code>。之后，它会调用<code class="fe lx ly lz ma b">f</code>函数。</p><p id="8482" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这不会改变结果，因为我们利用了单子定律的结合律。</p><p id="bcea" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">上面显示的图表5在被调用后如下所示:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="lv lw l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">图表6</p></figure><p id="fabf" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这个结构与我们的调用堆栈具有相同的形式，只是它是在堆中创建的。</p></div><div class="ab cl mq mr hx ms" role="separator"><span class="mt bw bk mu mv mw"/><span class="mt bw bk mu mv mw"/><span class="mt bw bk mu mv"/></div><div class="im in io ip iq"><h1 id="73fe" class="mx my it bd mz na nb nc nd ne nf ng nh jz ni ka nj kc nk kd nl kf nm kg nn no bi translated">为什么是蹦床？</h1><p id="9fd1" class="pw-post-body-paragraph kz la it lb b lc np ju le lf nq jx lh li nr lk ll lm ns lo lp lq nt ls lt lu im bi translated">如您所见，我们的筹码不会越来越多。我们首先调用<code class="fe lx ly lz ma b">run</code>函数，该函数将其推送到堆栈中。然后，它将通过创建另一个<code class="fe lx ly lz ma b">FlatMap</code>构造首次上升到<code class="fe lx ly lz ma b">FlatMap</code>。当所有的<code class="fe lx ly lz ma b">Suspense</code>值弹出堆栈并进入<code class="fe lx ly lz ma b">fibWithRef(4)</code>时，它进入<code class="fe lx ly lz ma b">run</code>函数。然后，它再次转到<code class="fe lx ly lz ma b">fibWithRef(3)</code>，然后转到<code class="fe lx ly lz ma b">run</code>。最后，它构建价值观。</p><p id="786b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们不停地从<code class="fe lx ly lz ma b">run</code>和<code class="fe lx ly lz ma b">fibWithRef</code>来回跳跃——就像蹦床一样。</p></div><div class="ab cl mq mr hx ms" role="separator"><span class="mt bw bk mu mv mw"/><span class="mt bw bk mu mv mw"/><span class="mt bw bk mu mv"/></div><div class="im in io ip iq"><h1 id="0a43" class="mx my it bd mz na nb nc nd ne nf ng nh jz ni ka nj kc nk kd nl kf nm kg nn no bi translated">结论</h1><p id="69be" class="pw-post-body-paragraph kz la it lb b lc np ju le lf nq jx lh li nr lk ll lm ns lo lp lq nt ls lt lu im bi translated">我们创建的<code class="fe lx ly lz ma b">Trampolining</code>数据构造器适用于很多递归场景。我们将return语句的值包装到<code class="fe lx ly lz ma b">Trampolining</code>。我们将<code class="fe lx ly lz ma b">Return</code>数据构造函数包装在常规递归调用返回的基本情况值上。最后，我们对想要对值执行的操作执行<code class="fe lx ly lz ma b">flatMap</code>。</p><p id="3a55" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在这个已经被广泛使用了，因为<code class="fe lx ly lz ma b">Cats </code>有一个<code class="fe lx ly lz ma b">Eval </code>单子来以堆栈安全的方式构造值。</p><p id="2cf1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">最后，如果你有兴趣了解更多关于蹦床的知识，这里有一些参考资料供你参考:</p><ul class=""><li id="c928" class="mc md it lb b lc ld lf lg li me lm mf lq mg lu mh mi mj mk bi translated"><a class="ae ky" href="http://blog.higher-order.com/assets/trampolines.pdf" rel="noopener ugc nofollow" target="_blank">带有自由单子的无栈Scala】</a></li><li id="f958" class="mc md it lb b lc ml lf mm li mn lm mo lq mp lu mh mi mj mk bi translated"><a class="ae ky" href="https://gist.github.com/eamelink/4466932a11d8d92a6b76e80364062250" rel="noopener ugc nofollow" target="_blank">Scala GitHub中的递归和蹦床</a></li><li id="b724" class="mc md it lb b lc ml lf mm li mn lm mo lq mp lu mh mi mj mk bi translated"><a class="ae ky" href="https://free.cofree.io/2017/08/24/trampoline/" rel="noopener ugc nofollow" target="_blank">Scala中蹦床是如何工作的</a></li><li id="7889" class="mc md it lb b lc ml lf mm li mn lm mo lq mp lu mh mi mj mk bi translated"><a class="ae ky" href="https://medium.com/@olxc/trampolining-and-stack-safety-in-scala-d8e86474ddfa" rel="noopener">olek sii Avramenko著《Scala中的蹦床和堆栈安全》</a></li></ul></div><div class="ab cl mq mr hx ms" role="separator"><span class="mt bw bk mu mv mw"/><span class="mt bw bk mu mv mw"/><span class="mt bw bk mu mv"/></div><div class="im in io ip iq"><p id="982c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><em class="mb">最初发表于</em><a class="ae ky" href="https://edward-huang.com/functional-programming/programming/scala/optimization/2021/01/17/common-pattern-of-creating-stack-safe-recursion/" rel="noopener ugc nofollow" target="_blank"><em class="mb">https://edward-huang.com</em></a><em class="mb">。</em></p></div></div>    
</body>
</html>