<html>
<head>
<title>Architecting a GraphQL API Codebase in Node.js</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">在Node.js中构建GraphQL API代码库</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/architecting-a-graphql-api-codebase-in-node-js-3a951cd7f0f4?source=collection_archive---------2-----------------------#2021-09-28">https://betterprogramming.pub/architecting-a-graphql-api-codebase-in-node-js-3a951cd7f0f4?source=collection_archive---------2-----------------------#2021-09-28</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="3639" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">建立一个具有模块化和认证的GraphQL服务器</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/54d8ae36d44b70f602acecf8eb550197.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*OuvQgOzBhkYdU3s5K0tHtw.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">图片来源:作者</p></figure><p id="1170" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">大多数GraphQL教程都没有教你如何拆分模式和解析器，就像在典型的REST API中模块化路由和控制器一样，也没有教你如何从<code class="fe lu lv lw lx b">.grapqhl</code>文件而不是模板文本中定义和加载类型定义。我将在本教程中尝试教你这些重要的概念。</p><p id="4acd" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">我假设您对<a class="ae ly" href="https://graphql.org/" rel="noopener ugc nofollow" target="_blank"> GraphQL </a>及其工作原理有基本的了解。不然这个教程就没多大意义了。你可以自己随意探索<a class="ae ly" href="https://github.com/haseebanwar/graphql-server" rel="noopener ugc nofollow" target="_blank">代码库</a>，如果你想和我一起编码，那也很好。</p><h1 id="d4e9" class="lz ma it bd mb mc md me mf mg mh mi mj jz mk ka ml kc mm kd mn kf mo kg mp mq bi translated">初始设置</h1><p id="0c7a" class="pw-post-body-paragraph ky kz it la b lb mr ju ld le ms jx lg lh mt lj lk ll mu ln lo lp mv lr ls lt im bi translated">让我们从一个基本服务器开始，安装以下依赖项。</p><pre class="kj kk kl km gt mw lx mx my aw mz bi"><span id="213f" class="na ma it lx b gy nb nc l nd ne">npm i express express-graphql graphql @graphql-tools/schema</span></pre><ul class=""><li id="c372" class="nf ng it la b lb lc le lf lh nh ll ni lp nj lt nk nl nm nn bi translated"><code class="fe lu lv lw lx b">express</code>是NodeJS的框架</li><li id="0d9d" class="nf ng it la b lb no le np lh nq ll nr lp ns lt nk nl nm nn bi translated"><code class="fe lu lv lw lx b">express-graphql</code>是一个让你用Express构建GraphQL API的模块</li><li id="cc3f" class="nf ng it la b lb no le np lh nq ll nr lp ns lt nk nl nm nn bi translated"><code class="fe lu lv lw lx b">graphql</code>是GraphQL的JavaScript参考实现</li><li id="39ab" class="nf ng it la b lb no le np lh nq ll nr lp ns lt nk nl nm nn bi translated"><code class="fe lu lv lw lx b">@graphql-tools/*</code>是一组使GraphQL工作更容易的包</li></ul><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nt nu l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">基本graphql服务器</p></figure><p id="3b80" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">请注意，我使用的是来自<code class="fe lu lv lw lx b">@graphql-tools</code>的<code class="fe lu lv lw lx b">makeExecutableSchema</code>，而不是来自<code class="fe lu lv lw lx b">graphql</code>的<code class="fe lu lv lw lx b">buildSchema</code>，因为它限制了你的模式的功能。更多关于这个StackOverflow的回答。</p><h1 id="9e63" class="lz ma it bd mb mc md me mf mg mh mi mj jz mk ka ml kc mm kd mn kf mo kg mp mq bi translated">要处理的数据</h1><p id="bdcc" class="pw-post-body-paragraph ky kz it la b lb mr ju ld le ms jx lg lh mt lj lk ll mu ln lo lp mv lr ls lt im bi translated">我们需要数据来使用API，我将使用虚拟数据进行演示(存储在JS文件中)。但是无论您使用虚拟数据还是数据库，概念都是一样的。</p><p id="094f" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">在代码库的根目录下创建一个名为<code class="fe lu lv lw lx b">data</code>的目录，并放入以下内容:</p><pre class="kj kk kl km gt mw lx mx my aw mz bi"><span id="60ea" class="na ma it lx b gy nb nc l nd ne">const authors = [<br/>  { id: 1, name: 'J. K. Rowling' },<br/>  // ... more authors<br/>];</span><span id="1d94" class="na ma it lx b gy nv nc l nd ne">const books = [<br/>  { id: 6, name: 'Forrest Gump', authorId: 2 },<br/>  { id: 7, name: 'The Way of Shadows', authorId: 3 },<br/>  { id: 8, name: 'Beyond the Shadows', authorId: 3 },<br/>  // ... more books<br/>];</span><span id="3500" class="na ma it lx b gy nv nc l nd ne">exports.authors = authors;<br/>exports.books = books;</span></pre><p id="e04d" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">如果您正在编写代码，只需将<a class="ae ly" href="https://raw.githubusercontent.com/haseebanwar/graphql-server/master/data/index.js" rel="noopener ugc nofollow" target="_blank">中的数据复制并粘贴到这里</a>。有两个实体，作者和书。作者有一套书，一本书有作者。</p><h1 id="61ce" class="lz ma it bd mb mc md me mf mg mh mi mj jz mk ka ml kc mm kd mn kf mo kg mp mq bi translated">定义模块化模式</h1><p id="1c2f" class="pw-post-body-paragraph ky kz it la b lb mr ju ld le ms jx lg lh mt lj lk ll mu ln lo lp mv lr ls lt im bi translated">让我们在应用程序的根目录下创建两个新目录:</p><ul class=""><li id="3f07" class="nf ng it la b lb lc le lf lh nh ll ni lp nj lt nk nl nm nn bi translated">模式(用于保存作者和书籍的类型定义)</li><li id="1592" class="nf ng it la b lb no le np lh nq ll nr lp ns lt nk nl nm nn bi translated">解析器(用于保存作者和书籍的解析器函数)</li></ul><pre class="kj kk kl km gt mw lx mx my aw mz bi"><span id="7f72" class="na ma it lx b gy nb nc l nd ne">root<br/> └─ resolvers<br/>     ├─ authors.js<br/>     ├─ authors.js<br/>     └─ index.js<br/> └─ schemas<br/>     ├─ authors.graphql<br/>     └─ books.graphql<br/>     └─ index.graphql<br/> ├─ package.json<br/> └─ server.js</span></pre><p id="f5a7" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">解析器中的<code class="fe lu lv lw lx b">index.js</code>文件和模式目录中的<code class="fe lu lv lw lx b">index.graphql</code>文件分别是所有解析器和模式的交汇点。</p><pre class="kj kk kl km gt mw lx mx my aw mz bi"><span id="611e" class="na ma it lx b gy nb nc l nd ne">// index.graphql</span><span id="ebc6" class="na ma it lx b gy nv nc l nd ne">type Query {<br/>  _empty: String<br/>  <em class="nw"># define any root queries here</em><br/>}</span><span id="bca7" class="na ma it lx b gy nv nc l nd ne">type Mutation {<br/>  _empty: String<br/>  <em class="nw"># define any root queries here</em><br/>}</span></pre><p id="1fa3" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">目前，我们只在类型<code class="fe lu lv lw lx b">Query</code>中定义了一个空查询，因为稍后我们将在书籍和作者各自的模式文件中为他们定义查询。</p><p id="3fc6" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">请注意，GraphQL的当前版本不允许您拥有空类型，即使您打算以后扩展它。所以我加了一个空字段。</p><pre class="kj kk kl km gt mw lx mx my aw mz bi"><span id="f462" class="na ma it lx b gy nb nc l nd ne">// authors.graphql</span><span id="2079" class="na ma it lx b gy nv nc l nd ne">type Author {<br/>  id: Int!<br/>  name: String!<br/>  books: [Book]<br/>}</span><span id="f78b" class="na ma it lx b gy nv nc l nd ne"><em class="nw"># extending root query type we defined in index.grapqhl</em><br/>extend type Query {<br/>  authors: [Author]<br/>  author(id: Int!): Author!<br/>}</span></pre><p id="6025" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">类似地，书籍的模式如下所示:</p><pre class="kj kk kl km gt mw lx mx my aw mz bi"><span id="7cd8" class="na ma it lx b gy nb nc l nd ne">// books.graphql</span><span id="22ab" class="na ma it lx b gy nv nc l nd ne">type Book {<br/>  id: Int!<br/>  title: String!<br/>  authorId: Int!<br/>  author: Author!<br/>}</span><span id="6610" class="na ma it lx b gy nv nc l nd ne">extend type Query {<br/>  books: [Book]!<br/>  book(id: Int!): Book!<br/>}</span><span id="635b" class="na ma it lx b gy nv nc l nd ne">input NewBook {<br/>  title: String!<br/>  authorId: Int!<br/>}</span><span id="9db3" class="na ma it lx b gy nv nc l nd ne">extend type Mutation {<br/>  createBook(newBook: NewBook): Book!<br/>}</span></pre><p id="76d7" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">为了定义模式和类型，我使用了GraphQL的SDL。您还可以通过编程方式生成架构。由于GraphQL可以用于任何后端编程语言，所以我认为最好使用SDL。</p><p id="04f7" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated"><em class="nw">如果您正在使用VSCode，并且在您的</em> <code class="fe lu lv lw lx b"><em class="nw">.graphql</em></code> <em class="nw">文件中没有看到语法高亮/自动完成，请安装</em> <a class="ae ly" href="https://marketplace.visualstudio.com/items?itemName=GraphQL.vscode-graphql" rel="noopener ugc nofollow" target="_blank"> <em class="nw">正式GraphQL扩展</em> </a> <em class="nw">。</em></p><h1 id="1609" class="lz ma it bd mb mc md me mf mg mh mi mj jz mk ka ml kc mm kd mn kf mo kg mp mq bi translated">定义解析器</h1><p id="8084" class="pw-post-body-paragraph ky kz it la b lb mr ju ld le ms jx lg lh mt lj lk ll mu ln lo lp mv lr ls lt im bi translated">现在我们已经为书籍和作者定义了模式。是时候为作者和书籍制定解决方案了。</p><pre class="kj kk kl km gt mw lx mx my aw mz bi"><span id="ec69" class="na ma it lx b gy nb nc l nd ne">// resolvers/authors.js</span><span id="d85e" class="na ma it lx b gy nv nc l nd ne">const { authors, books } = require('../data');</span><span id="c399" class="na ma it lx b gy nv nc l nd ne">const authorsResolvers = {<br/>  Query: {<br/>    authors: () =&gt; authors,<br/>    author: (parent, { id }) =&gt; {<br/>      return authors.find((author) =&gt; author.id === id);<br/>    }<br/>  },<br/>  Author: {<br/>    books: (author) =&gt; {<br/>      return books.filter((book) =&gt; book.authorId === author.id);<br/>    }<br/>  }<br/>};</span><span id="29d9" class="na ma it lx b gy nv nc l nd ne">module.exports = authorsResolvers;</span></pre><p id="c29b" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">类似地，书籍解析器</p><pre class="kj kk kl km gt mw lx mx my aw mz bi"><span id="74d6" class="na ma it lx b gy nb nc l nd ne">// resolvers/books.js</span><span id="a340" class="na ma it lx b gy nv nc l nd ne">const { authors, books } = require('../data');</span><span id="abaa" class="na ma it lx b gy nv nc l nd ne">const booksResolvers = {<br/>  Query: {<br/>    books: () =&gt; books,<br/>    book: (parent, { id }) =&gt; {<br/>      return books.find((book) =&gt; book.id === id);<br/>    }<br/>  },<br/>  Book: {<br/>    author: (book) =&gt; {<br/>      return authors.find((author) =&gt; author.id === book.authorId);<br/>    }<br/>  },<br/>  Mutation: {<br/>    createBook: (parent, { newBook }) =&gt; {<br/>      const createdBook = { id: books.length + 1, ...newBook };<br/>      books.push(createdBook);<br/>      return createdBook;<br/>    }<br/>  }<br/>};</span><span id="bd47" class="na ma it lx b gy nv nc l nd ne">module.exports = booksResolvers;</span></pre><p id="8d4d" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">在解析器目录的<code class="fe lu lv lw lx b">index.js</code>中，我们可以将书籍和作者解析器合并成一个对象。</p><pre class="kj kk kl km gt mw lx mx my aw mz bi"><span id="e207" class="na ma it lx b gy nb nc l nd ne">// resolvers/index.js</span><span id="aacc" class="na ma it lx b gy nv nc l nd ne">const authorsResolvers = require('./authors');<br/>const booksResolvers = require('./books');</span><span id="abdf" class="na ma it lx b gy nv nc l nd ne">const rootResolver = {};</span><span id="12a8" class="na ma it lx b gy nv nc l nd ne">const resolvers = [<br/>  rootResolver,<br/>  authorsResolvers,<br/>  booksResolvers,<br/>];</span><span id="f58e" class="na ma it lx b gy nv nc l nd ne">module.exports = resolvers;</span></pre><p id="8e57" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">这是我们正在做的事情</p><ul class=""><li id="9d8c" class="nf ng it la b lb lc le lf lh nh ll ni lp nj lt nk nl nm nn bi translated">导入所有解析器(本例中为书籍和作者)</li><li id="5566" class="nf ng it la b lb no le np lh nq ll nr lp ns lt nk nl nm nn bi translated">定义根解析程序</li><li id="3b0c" class="nf ng it la b lb no le np lh nq ll nr lp ns lt nk nl nm nn bi translated">导出一组解析器(graphql-tools会自动组合它们)</li></ul><h1 id="5d71" class="lz ma it bd mb mc md me mf mg mh mi mj jz mk ka ml kc mm kd mn kf mo kg mp mq bi translated">在服务器中注入我们的模式和解析器</h1><p id="635c" class="pw-post-body-paragraph ky kz it la b lb mr ju ld le ms jx lg lh mt lj lk ll mu ln lo lp mv lr ls lt im bi translated">最后，我们可以在<code class="fe lu lv lw lx b">server.js</code>中导入模式和解析器。由于我使用<code class="fe lu lv lw lx b">.graphql</code>文件进行类型定义，我将使用两个小的graphql工具来帮助我读取<code class="fe lu lv lw lx b">.graphql</code>文件</p><pre class="kj kk kl km gt mw lx mx my aw mz bi"><span id="a1d0" class="na ma it lx b gy nb nc l nd ne">npm i @graphql-tools/load @graphql-tools/graphql-file-loader</span></pre><p id="a5e4" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">而在server.js中</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nt nu l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">带有模块化模式和解析器的server.js</p></figure><p id="b60b" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">我使用glob模式来加载类型定义，所以<code class="fe lu lv lw lx b">loadSchemaSync</code>将从<code class="fe lu lv lw lx b">schemas</code>目录中加载所有的<code class="fe lu lv lw lx b">.graphql</code>文件，并将它们组合成一个模式。</p><p id="a45b" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">现在我们有了一个运行在<a class="ae ly" href="http://localhost:5000/graphql" rel="noopener ugc nofollow" target="_blank"> localhost:5000/graphql </a>的功能性GraphQL服务器，我们可以执行以下查询:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nx"><img src="../Images/82b7683b7a3b5c0c1b29f44f767e96a3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*yzutxqAj3na5Uj7ZkSmipQ.gif"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">演示</p></figure><h1 id="ce25" class="lz ma it bd mb mc md me mf mg mh mi mj jz mk ka ml kc mm kd mn kf mo kg mp mq bi translated">证明</h1><p id="2b25" class="pw-post-body-paragraph ky kz it la b lb mr ju ld le ms jx lg lh mt lj lk ll mu ln lo lp mv lr ls lt im bi translated">向GraphQL API添加身份验证很简单。在<code class="fe lu lv lw lx b">server.js</code>中定义<code class="fe lu lv lw lx b">/graphql</code>路径之前，添加一个express中间件即可</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nt nu l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">带身份验证的server.js</p></figure><p id="747a" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">然后在解析器函数中，你可以</p><pre class="kj kk kl km gt mw lx mx my aw mz bi"><span id="b0d1" class="na ma it lx b gy nb nc l nd ne">// resolvers/authors.js</span><span id="3e34" class="na ma it lx b gy nv nc l nd ne">const authorsResolvers = {<br/>  Query: {<br/>    authors: (parent, args, context) =&gt; {<br/><strong class="lx iu">      if (!context.isAuthenticated) {<br/>        throw new Error('You are not authenticated');<br/>      }</strong></span><span id="e81a" class="na ma it lx b gy nv nc l nd ne">      return authors;<br/>    },<br/>    author: (parent, { id }) =&gt; {<br/>      return authors.find((author) =&gt; author.id === id);<br/>    }<br/>  },<br/>};</span></pre><h1 id="a63b" class="lz ma it bd mb mc md me mf mg mh mi mj jz mk ka ml kc mm kd mn kf mo kg mp mq bi translated">分解剂成分</h1><p id="40d6" class="pw-post-body-paragraph ky kz it la b lb mr ju ld le ms jx lg lh mt lj lk ll mu ln lo lp mv lr ls lt im bi translated">因为我们需要在每个解析器上执行认证，所以我们可以使用来自<code class="fe lu lv lw lx b">@graphql-tools</code>的工具，让我们为一组查询或变化定义一个认证中间件，而不是检查用户是否在每个解析器上都被认证</p><pre class="kj kk kl km gt mw lx mx my aw mz bi"><span id="7402" class="na ma it lx b gy nb nc l nd ne">npm i @graphql-tools/resolvers-composition</span></pre><p id="f05e" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">和</p><pre class="kj kk kl km gt mw lx mx my aw mz bi"><span id="aa60" class="na ma it lx b gy nb nc l nd ne">// resolvers/authors.js</span><span id="d572" class="na ma it lx b gy nv nc l nd ne"><strong class="lx iu">const { composeResolvers } =<br/>  require('@graphql-tools/resolvers-composition');</strong><br/>const { authors, books } = require('../data');</span><span id="ef5e" class="na ma it lx b gy nv nc l nd ne">const authorsResolvers = {<br/>  Query: {<br/>    authors: (parent, args, context) =&gt; {<br/>      return authors;<br/>    },<br/>    author: (parent, { id }) =&gt; {<br/>      return authors.find((author) =&gt; author.id === id);<br/>    }<br/>  },<br/>};</span><span id="bd7e" class="na ma it lx b gy nv nc l nd ne">const authenticateReq = (next) =&gt; {<br/>  return (root, args, context, info) =&gt; {<br/>    if (!context.isAuthenticated) {<br/>      throw new Error('You are not authorized');<br/>    }<br/>    return next(root, args, context, info);<br/>  };<br/>};</span><span id="a126" class="na ma it lx b gy nv nc l nd ne">// run auth middleware for all types and all fields<br/>// on authors resolver<br/><strong class="lx iu">module.exports = composeResolvers(authorsResolvers, {<br/>  '*.*': [authenticateReq],<br/>});</strong></span></pre><p id="8ba5" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">现在，每当您查询<code class="fe lu lv lw lx b">auhtors</code>或<code class="fe lu lv lw lx b">author(id: id_here)</code>时，中间件<code class="fe lu lv lw lx b">authenticateReq</code>会在解析器功能之前运行，它会确保只有经过身份验证的请求才会发送到实际的解析器功能。</p><p id="891c" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">对于我们API的books资源，您可以遵循相同的方法。请在此查看解析器组合<a class="ae ly" href="https://www.graphql-tools.com/docs/resolvers-composition#supported-path-matcher-format" rel="noopener ugc nofollow" target="_blank">支持的glob模式。</a></p></div><div class="ab cl ny nz hx oa" role="separator"><span class="ob bw bk oc od oe"/><span class="ob bw bk oc od oe"/><span class="ob bw bk oc od"/></div><div class="im in io ip iq"><p id="2d82" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">这是任何复杂的GraphQL项目的起点，但它的结构方式将帮助您轻松地维护代码，因为资源是模块化的。</p><p id="c88c" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">感谢阅读。这里是代码库。</p></div></div>    
</body>
</html>