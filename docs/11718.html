<html>
<head>
<title>I Moved Away From Webpack — and When I Loaded Vue Directly in the Browser I Faced Some Problems.</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">我离开了web pack——当我直接在浏览器中加载Vue时，我遇到了一些问题。</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/i-moved-away-from-webpack-and-when-i-loaded-vue-directly-in-the-browser-i-faced-some-problems-4ab875c5b8c9?source=collection_archive---------11-----------------------#2022-04-11">https://betterprogramming.pub/i-moved-away-from-webpack-and-when-i-loaded-vue-directly-in-the-browser-i-faced-some-problems-4ab875c5b8c9?source=collection_archive---------11-----------------------#2022-04-11</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="35de" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">我为什么需要捆扎机？跟我一起踏上如何在浏览器中直接加载Vue单个文件组件的旅程。</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi kf"><img src="../Images/cb076a280c6de4c5a851b0ad8e9053ee.png" data-original-src="https://miro.medium.com/v2/resize:fit:864/format:webp/1*SK8w77U37JvR12AMqYB9bQ.png"/></div></figure><p id="a792" class="pw-post-body-paragraph kn ko iq kp b kq kr jr ks kt ku ju kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">几个月后，我对Webpack越来越失望，每次更新后都必须修复一些东西，这让我开始疲惫不堪，所以我问自己:为什么我需要一个bundler？app可以直接在浏览器中运行吗？浏览器API都长大了，就试试吧！</p><p id="d829" class="pw-post-body-paragraph kn ko iq kp b kq kr jr ks kt ku ju kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">所以我的第一个目标是创建我能想到的最简单的Vue应用。只需从Vue导入<code class="fe lj lk ll lm b">createApp</code>函数，在屏幕上显示一个简单的模板。如何在浏览器中加载Vue？<a class="ae ln" href="https://vuejs.org/guide/quick-start.html#without-build-tools" rel="noopener ugc nofollow" target="_blank"> Vue文档</a>知道答案:Vue源代码可以通过内容交付网络加载:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="lo lp l"/></div></figure><p id="ecb0" class="pw-post-body-paragraph kn ko iq kp b kq kr jr ks kt ku ju kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">当我在浏览器中打开应用程序时，我意识到:我的方向是正确的！我可以不用捆绑器在浏览器中运行Vue。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="lr ls di lt bf lu"><div class="gh gi lq"><img src="../Images/f877b5c1ba0546afd33c7d1ec88ef4c4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*UNWAC2UumxpTbgvDsJUV1w.png"/></div></div></figure><p id="a77b" class="pw-post-body-paragraph kn ko iq kp b kq kr jr ks kt ku ju kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">但是把整个app写在<code class="fe lj lk ll lm b">main.ts</code>文件单里还是挺不方便的。当我使用bundler时，我可以使用Vue的<a class="ae ln" href="https://vuejs.org/guide/scaling-up/sfc.html#introduction" rel="noopener ugc nofollow" target="_blank">单个文件组件</a>将应用程序拆分成组件。</p><p id="89bd" class="pw-post-body-paragraph kn ko iq kp b kq kr jr ks kt ku ju kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">如果捆绑器能做到这一点，为什么浏览器就不能做到这一点呢？跟我一起踏上在浏览器中直接加载单个文件组件的旅程。</p><h1 id="b649" class="lv lw iq bd lx ly lz ma mb mc md me mf jw mg jx mh jz mi ka mj kc mk kd ml mm bi translated">直接在浏览器中加载单个文件组件</h1><p id="8565" class="pw-post-body-paragraph kn ko iq kp b kq mn jr ks kt mo ju kv kw mp ky kz la mq lc ld le mr lg lh li ij bi translated">上面的应用程序非常简单，它只是一个没有逻辑的模板。如果我在一个页面组件中做同样的事情，它看起来像</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="lo lp l"/></div></figure><p id="7644" class="pw-post-body-paragraph kn ko iq kp b kq kr jr ks kt ku ju kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">嗯，我如何在浏览器中直接加载这样的文件？</p><ol class=""><li id="7ebc" class="ms mt iq kp b kq kr kt ku kw mu la mv le mw li mx my mz na bi translated">使用fetch API，我可以从服务器加载组件文件。</li><li id="974a" class="ms mt iq kp b kq nb kt nc kw nd la ne le nf li mx my mz na bi translated">然后可以使用<code class="fe lj lk ll lm b">innerHTML</code>属性将文件转换成组件的DOM表示。</li><li id="cc0b" class="ms mt iq kp b kq nb kt nc kw nd la ne le nf li mx my mz na bi translated"><code class="fe lj lk ll lm b">querySelector</code>允许提取模板元素。</li></ol><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="lo lp l"/></div></figure><p id="ccc4" class="pw-post-body-paragraph kn ko iq kp b kq kr jr ks kt ku ju kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">这都是魔术！通过这个函数，我可以导入非常简单的ChildComponent.vue</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="lo lp l"/></div></figure><p id="d08e" class="pw-post-body-paragraph kn ko iq kp b kq kr jr ks kt ku ju kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">如果我打开浏览器，我知道，应该显示什么:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="lr ls di lt bf lu"><div class="gh gi lq"><img src="../Images/c9ec8062fd015f70167eefbfc18a1c3f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*NIMTnMsw62BLaXtPrdK3eA.png"/></div></div></figure><p id="15fd" class="pw-post-body-paragraph kn ko iq kp b kq kr jr ks kt ku ju kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">是啊！我成功地从一个Vue单文件组件中加载了一个模板！太棒了。但是没有逻辑的Vue组件的用途非常有限。逻辑呢？</p><h1 id="8202" class="lv lw iq bd lx ly lz ma mb mc md me mf jw mg jx mh jz mi ka mj kc mk kd ml mm bi translated">向组件添加逻辑</h1><p id="597a" class="pw-post-body-paragraph kn ko iq kp b kq mn jr ks kt mo ju kv kw mp ky kz la mq lc ld le mr lg lh li ij bi translated"><code class="fe lj lk ll lm b">ChildComponent</code>正在成为一个具有模板和逻辑的完全真实的组件。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="lo lp l"/></div></figure><p id="8c03" class="pw-post-body-paragraph kn ko iq kp b kq kr jr ks kt ku ju kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">但是这并不像看起来那么简单，首先我们不能只使用<code class="fe lj lk ll lm b">innerHTML</code>来评估脚本。为什么？innerHTML 上的<a class="ae ln" href="https://www.w3.org/TR/2008/WD-html5-20080610/dom.html#innerhtml0" rel="noopener ugc nofollow" target="_blank"> HTML5规范告诉我为什么:</a></p><blockquote class="ng nh ni"><p id="55e7" class="kn ko nj kp b kq kr jr ks kt ku ju kv nk kx ky kz nl lb lc ld nm lf lg lh li ij bi translated">注意:使用<code class="fe lj lk ll lm b">innerHTML</code>插入的<code class="fe lj lk ll lm b">script</code>元素在插入时不执行。</p></blockquote><p id="00f4" class="pw-post-body-paragraph kn ko iq kp b kq kr jr ks kt ku ju kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">这意味着浏览器不会有所帮助。所以我只能靠自己了。</p><p id="f100" class="pw-post-body-paragraph kn ko iq kp b kq kr jr ks kt ku ju kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">我首先想到的是创建一个<code class="fe lj lk ll lm b">&lt;script&gt;</code>标签或者使用丑陋的<code class="fe lj lk ll lm b">eval</code>函数，但是<code class="fe lj lk ll lm b">&lt;script&gt;</code>标签或者<code class="fe lj lk ll lm b">eval</code>函数是前模块时代的恐龙。但是Vue单组件文件在其逻辑部分有一个默认导出的模块。这意味着以上两个选项都是无效选项。</p><p id="c8c7" class="pw-post-body-paragraph kn ko iq kp b kq kr jr ks kt ku ju kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">还有第三种不太为人所知的评估模块的方法:如果我将逻辑表示为一个<a class="ae ln" href="https://en.wikipedia.org/wiki/Data_URI_scheme" rel="noopener ugc nofollow" target="_blank">数据URI </a>，那么<code class="fe lj lk ll lm b">import()</code>操作符让我动态加载JavaScript模块:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="lo lp l"/></div></figure><p id="c1ef" class="pw-post-body-paragraph kn ko iq kp b kq kr jr ks kt ku ju kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">上面的代码将显示警告窗口</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="lr ls di lt bf lu"><div class="gh gi lq"><img src="../Images/872ac8c3bf2f895a7642b7c26d1b6b0a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*K0dnJpWEAAy9379r73pe0Q.png"/></div></div></figure><p id="b9a4" class="pw-post-body-paragraph kn ko iq kp b kq kr jr ks kt ku ju kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">这是我一直在寻找的诀窍。使用这个技巧，单个组件文件导入功能就变成了。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="lo lp l"/></div></figure><p id="7b55" class="pw-post-body-paragraph kn ko iq kp b kq kr jr ks kt ku ju kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">现在我的单组件文件加载器已经支持模板和逻辑。现在，我可以不用捆绑器在浏览器中使用Vue。但是过了一段时间后，样式表变得相当混乱。如何在单组件文件中使用样式？</p><h1 id="7549" class="lv lw iq bd lx ly lz ma mb mc md me mf jw mg jx mh jz mi ka mj kc mk kd ml mm bi translated">设计组件的样式</h1><p id="5fc5" class="pw-post-body-paragraph kn ko iq kp b kq mn jr ks kt mo ju kv kw mp ky kz la mq lc ld le mr lg lh li ij bi translated">这比预期的要容易。我唯一要做的事情就是将样式元素从单个文件组件移动到实际的DOM中。这可以通过一行代码来完成:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="lo lp l"/></div></figure><p id="e6e4" class="pw-post-body-paragraph kn ko iq kp b kq kr jr ks kt ku ju kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">就是这样！我们可以使用带有模板、逻辑和样式的单个组件文件。</p><p id="5abc" class="pw-post-body-paragraph kn ko iq kp b kq kr jr ks kt ku ju kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">但是当我介绍我的第一个子模块时，什么都不能用了。我们所有进口的单组分文件都坏了。</p><h1 id="e601" class="lv lw iq bd lx ly lz ma mb mc md me mf jw mg jx mh jz mi ka mj kc mk kd ml mm bi translated">修复动态导入</h1><p id="d4eb" class="pw-post-body-paragraph kn ko iq kp b kq mn jr ks kt mo ju kv kw mp ky kz la mq lc ld le mr lg lh li ij bi translated">首先:它们为什么会坏掉？公平地说，浏览器应该如何解析相对路径？我使用导入技巧来评估逻辑，通过这样做，浏览器失去了上下文。浏览器没有机会知道模块的相对路径。</p><p id="6d3d" class="pw-post-body-paragraph kn ko iq kp b kq kr jr ks kt ku ju kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">这是最后一个问题。如果我设法解决了这个问题，我就可以使用单个组件文件在浏览器中运行一个完整的Vue应用程序。</p><p id="dc7d" class="pw-post-body-paragraph kn ko iq kp b kq kr jr ks kt ku ju kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">为了修复导入，我需要用绝对路径替换所有相对导入路径。这段代码有点复杂，但本质上，我需要完成以下三个步骤:</p><ol class=""><li id="a195" class="ms mt iq kp b kq kr kt ku kw mu la mv le mw li mx my mz na bi translated">我需要确定导入的单个组件文件的基本url。这可以通过使用<code class="fe lj lk ll lm b">&lt;base&gt;</code>将模块的相对路径转换成绝对路径来完成。</li><li id="1b63" class="ms mt iq kp b kq nb kt nc kw nd la ne le nf li mx my mz na bi translated">使用正则表达式查找所有导入语句</li><li id="41a4" class="ms mt iq kp b kq nb kt nc kw nd la ne le nf li mx my mz na bi translated">并用绝对路径替换每个相对导入路径。</li></ol><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="lo lp l"/></div></figure><p id="4f04" class="pw-post-body-paragraph kn ko iq kp b kq kr jr ks kt ku ju kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">最终的单个组件导入器变得有点复杂，但是只需50行代码，我就可以导入Vue单个组件文件！这真是难以置信！我们可以只运行Vue单文件组件，不需要捆绑器。但是现在来了:这是一个很好的技术演示，但是不要在生产中使用。</p><p id="e4e4" class="pw-post-body-paragraph kn ko iq kp b kq kr jr ks kt ku ju kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">所以我回到了Webpack，在浪费了很多时间搜索后，我解决了我的Webpack冲突，并从此使用Webpack。</p><h1 id="e252" class="lv lw iq bd lx ly lz ma mb mc md me mf jw mg jx mh jz mi ka mj kc mk kd ml mm bi translated">结论</h1><p id="7534" class="pw-post-body-paragraph kn ko iq kp b kq mn jr ks kt mo ju kv kw mp ky kz la mq lc ld le mr lg lh li ij bi translated">这个例子展示了网络在过去十年中是如何发展的。原生浏览器API已经达到这一点，我们可以运行一个完整的Vue应用程序，而不需要捆绑器。浏览器API每年都变得更加强大，如果以这样的速度发展下去，今天使用的许多工具可能在几年内就会过时。</p><p id="df95" class="pw-post-body-paragraph kn ko iq kp b kq kr jr ks kt ku ju kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">这太不可思议了！只需50行代码就可以导入Vue单个文件组件。但这不能和<a class="ae ln" href="https://github.com/vuejs/core/tree/main/packages/compiler-sfc" rel="noopener ugc nofollow" target="_blank"> @vue/compiler-sfc </a>相比。上面的解决方案缺少许多功能，如作用域样式、脚本标记中的其他语言(如TypeScript)或热模块替换。在浏览器能够为捆绑者提供类似的开发者体验之前，还有很长的路要走。</p></div></div>    
</body>
</html>