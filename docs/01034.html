<html>
<head>
<title>Zero-Sum and Odd-Even Subarrays in Swift</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Swift中的零和与奇偶子阵列</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/zero-sum-and-odd-even-subarrays-in-swift-8178d1ed677f?source=collection_archive---------11-----------------------#2019-08-08">https://betterprogramming.pub/zero-sum-and-odd-even-subarrays-in-swift-8178d1ed677f?source=collection_archive---------11-----------------------#2019-08-08</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="b0b3" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">一个问题的解决方案，有例子</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/a5237cceda60b96de5048bfab9142bf4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*1wqoQlumr4DaRqi_lJO_pA.jpeg"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">马库斯·斯皮斯克在<a class="ae ky" href="https://unsplash.com/search/photos/numbers?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的照片</p></figure><p id="3173" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">黑客地球上的<a class="ae ky" href="https://www.hackerearth.com/practice/algorithms/dynamic-programming/introduction-to-dynamic-programming-1/practice-problems/algorithm/odd-even-subarrays-72ad69db/" rel="noopener ugc nofollow" target="_blank">原问题</a>是</p><blockquote class="lv"><p id="240d" class="lw lx it bd ly lz ma mb mc md me lu dk translated">给定一个正数和负数的数组，找出是否有一个和为零的子数组(大小至少为一)。在这种情况下，子阵列必须是连续的。</p></blockquote></div><div class="ab cl mf mg hx mh" role="separator"><span class="mi bw bk mj mk ml"/><span class="mi bw bk mj mk ml"/><span class="mi bw bk mj mk"/></div><div class="im in io ip iq"><h1 id="617f" class="mm mn it bd mo mp mq mr ms mt mu mv mw jz mx ka my kc mz kd na kf nb kg nc nd bi translated">零和阵列</h1><p id="64f4" class="pw-post-body-paragraph kz la it lb b lc ne ju le lf nf jx lh li ng lk ll lm nh lo lp lq ni ls lt lu im bi translated">我们将以一个数组中的三个整数为例。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi nj"><img src="../Images/357a1082ee83a6ae444c7f76d3a69c23.png" data-original-src="https://miro.medium.com/v2/resize:fit:466/format:webp/1*C8ajdyf6itIcDroZbYYqpQ.png"/></div></figure><p id="56e5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们取数组的累积和(写在数组下面)。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi nk"><img src="../Images/46aae4fd0b9668f7ea7f715a091bf37b.png" data-original-src="https://miro.medium.com/v2/resize:fit:434/format:webp/1*DlgYNS1vxHCJgRgCcaRnYw.png"/></div></figure><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nl"><img src="../Images/20b18de2092aff7289d214a3c0a1d664.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*DoL40ySZt-92M36CVfC1Tg.png"/></div></div></figure><p id="6cc0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们正在寻找一个使我们回到之前总和的元素(这里是第二个元素)或者一个使我们回到0的元素。</p><p id="3d06" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">所以让我们来看看另一个例子(下面还是累积和)。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi nm"><img src="../Images/5417ceac38a832f133db7ff07f3580bd.png" data-original-src="https://miro.medium.com/v2/resize:fit:528/format:webp/1*P5k2Mgdx_cAkJCvQ9Olbqw.png"/></div></figure><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nn"><img src="../Images/3e65063137e0c54ec14ada02f07db46a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*eP48iKHgcEPnPNt5XtNzOg.png"/></div></div></figure><p id="f22d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果在从0…i(其中I是数组的末尾)开始的任何一点，我们返回到我们已经在的点或者下降到零，我们就找到了一个零和数组。</p><p id="d6ae" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们来看一个反例:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi no"><img src="../Images/bb5077f32d63c6b53128d4f29ddbc141.png" data-original-src="https://miro.medium.com/v2/resize:fit:418/format:webp/1*aEfBUr8VT4FfKEK1nfrn9g.png"/></div></figure><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi np"><img src="../Images/3a527e95de45a4762035676adf7a7019.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*d5ZzjefdkePbY-5fAJhqbg.png"/></div></div></figure><p id="f0ef" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在Swift中实施时，如下所示:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nq nr l"/></div></figure></div><div class="ab cl mf mg hx mh" role="separator"><span class="mi bw bk mj mk ml"/><span class="mi bw bk mj mk ml"/><span class="mi bw bk mj mk"/></div><div class="im in io ip iq"><h1 id="fea3" class="mm mn it bd mo mp mq mr ms mt mu mv mw jz mx ka my kc mz kd na kf nb kg nc nd bi translated">奇偶子阵列问题</h1><p id="a4d4" class="pw-post-body-paragraph kz la it lb b lc ne ju le lf nf jx lh li ng lk ll lm nh lo lp lq ni ls lt lu im bi translated">类似的相关问题是，当且仅当子阵列中奇数元素的数量等于子阵列中偶数元素的数量时，阵列的子阵列(连续的)才是奇偶子阵列。我们将称这些奇偶子阵列<em class="ns">为平衡的</em>，因为它们在子阵列中具有相同数量的奇数和偶数。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi nt"><img src="../Images/dffd0f5bb788afcf263ddc91b0d6b784.png" data-original-src="https://miro.medium.com/v2/resize:fit:530/format:webp/1*K3lXf-oyir5KLCz-fp3jmg.png"/></div></figure><p id="18c2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">有三个奇偶子阵列:{2，5} {7，8} {2，5，7，8}</p><h2 id="6806" class="nu mn it bd mo nv nw dn ms nx ny dp mw li nz oa my lm ob oc na lq od oe nc of bi translated">一个微不足道的奇偶例子</h2><p id="84a4" class="pw-post-body-paragraph kz la it lb b lc ne ju le lf nf jx lh li ng lk ll lm nh lo lp lq ni ls lt lu im bi translated">一个平凡的[1，2]数组:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi og"><img src="../Images/10733e9ff478022fcf880637a5dfc29d.png" data-original-src="https://miro.medium.com/v2/resize:fit:272/format:webp/1*0UMoM0FZ0-5L7L4pnAlvYA.png"/></div></figure><p id="33ad" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">像以前一样，我们将累积差异放在数组下面。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi oh"><img src="../Images/00f6603fb9ab9f983af180f0fc01a834.png" data-original-src="https://miro.medium.com/v2/resize:fit:276/format:webp/1*EEtjAjZYAiuL4aimfU0uWg.png"/></div></figure><p id="0f69" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这里我们可以看到，我们创建了一个子数组{1，2}，因为1是奇数，2是偶数，这是最大的子数组(因为它包含了原始数组的所有元素)。</p><p id="ddbc" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们可以将数组表示为下面的图1。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi oi"><img src="../Images/461ca55fb46ebd8cdd747da54bee7465.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*H2KTEHxXFsha6NBlPyAuRw.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">图表1。数组[1，2]的位置和差的图</p></figure><p id="70a6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们看一个使用图1的算法:</p><p id="4100" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">a) 1是奇数(在位置0)，所以差= 0 - 1。因此我们在0，1处绘图。</p><p id="234a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">b) 2是偶数(在位置1)，所以差= -1 + 1。因此，我们在1，0处绘图。</p><p id="edbb" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果我们回到任何位置，我们有一个匹配，提供了一种方法来创建一个平衡的子阵列。</p><p id="422d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">然而，这里有一个问题——我们实际上从未回到图上的任何一点。这样做的原因是，当我们初始化程序时，我们没有任何偶数或奇数(意味着我们最初处于平衡位置，即使子数组中没有数字，差值也为0)。</p><p id="4ecf" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们可以在图2中解决这个问题:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi oi"><img src="../Images/d3a7170333464dd29c86b52668db85d9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*0QKMKwY8uXqqeMfteAF0eA.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">图2:数组[1，2]的位置和差的固定图</p></figure><p id="067f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">对于最初的图，我们有一个匹配。</p><h2 id="a94b" class="nu mn it bd mo nv nw dn ms nx ny dp mw li nz oa my lm ob oc na lq od oe nc of bi translated">一个更复杂的例子</h2><p id="d63d" class="pw-post-body-paragraph kz la it lb b lc ne ju le lf nf jx lh li ng lk ll lm nh lo lp lq ni ls lt lu im bi translated">使用上面的算法，我们会发现它比仅仅查找单个匹配稍微复杂一些。</p><p id="6367" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们考虑阵列{2，5，7，8}，它有三个平衡的子阵列:{2，5} {7，8} {2，5，7，8} <em class="ns">。</em></p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi oj"><img src="../Images/f972c5a7ab3ebe60955e2392d184c74d.png" data-original-src="https://miro.medium.com/v2/resize:fit:526/format:webp/1*3zVON6yLNdyUBS5C-B1LYg.png"/></div></figure><p id="b5ef" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们再次重复我们的把戏，当我们没有偶数或奇数时，我们说我们访问了0。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ok"><img src="../Images/719af0ca99b3d5f6b78e23e1cc55791f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*s5T4vHQxNaB-uFY3Rah6xQ.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">图3:一个更复杂的例子</p></figure><p id="e87b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们再一次看算法。</p><p id="ba1e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">a) 2是偶数(在位置0)，所以我们在0处绘图，(0 + 1)。</p><p id="8c92" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">b) 5是奇数(在位置1)，所以我们在1处绘图，(1-1)。我们已经去过那里了。</p><p id="6f44" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">c) 7是奇数(在位置2)，所以我们在2处绘图，(0 -1)。</p><p id="df51" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">d) 8是奇数(在位置3)，所以我们在3处绘图，(-1 + 1)。我们已经去过那里了。</p><p id="df15" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">从表面上看，只有b)和d)位于我们之前访问过的位置。</p><p id="1130" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们可以认为第一个匹配b)是子阵列{2，5}，第二个匹配是{7，8}。我们应该知道第二个匹配{7，8}为我们提供了另一个关于{2，5}的匹配，因为我们的第三个子数组是{2，5，7，8}，它是{2，5}和{7，8}的连接。</p></div><div class="ab cl mf mg hx mh" role="separator"><span class="mi bw bk mj mk ml"/><span class="mi bw bk mj mk ml"/><span class="mi bw bk mj mk"/></div><div class="im in io ip iq"><h1 id="7682" class="mm mn it bd mo mp mq mr ms mt mu mv mw jz mx ka my kc mz kd na kf nb kg nc nd bi translated">奇偶子阵列的实现</h1><p id="dcfd" class="pw-post-body-paragraph kz la it lb b lc ne ju le lf nf jx lh li ng lk ll lm nh lo lp lq ni ls lt lu im bi translated">在代码中，我们跟踪:</p><ul class=""><li id="05cd" class="ol om it lb b lc ld lf lg li on lm oo lq op lu oq or os ot bi translated">累积差异(var差异= 0)</li><li id="6fbb" class="ol om it lb b lc ou lf ov li ow lm ox lq oy lu oq or os ot bi translated">我们可以制造的子阵列数量(var ans = 0)</li><li id="d27b" class="ol om it lb b lc ou lf ov li ow lm ox lq oy lu oq or os ot bi translated">我们在字典(hashmap)中访问过的所有差异(var hm : [Int:Int] = [:])</li></ul><p id="160e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">为了产生上图所示的紫色修正，我们说我们访问了初始平衡状态一次:hm[0] = 1</p><p id="6e58" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们遍历输入数组。如果当前元素是偶数，则累积差值递增；如果不是，则递减。</p><p id="7846" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果我们之前已经看到了这个和，我们就有了一个匹配，我们可以通过我们之前看到的匹配的次数来增加子数组的数量。(如果没有，我们记录我们看过这场比赛。)</p><p id="0c24" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">然后我们返回子数组的数量。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nq nr l"/></div></figure><p id="1aaa" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">祝你好运！</p></div></div>    
</body>
</html>