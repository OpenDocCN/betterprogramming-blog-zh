<html>
<head>
<title>Tuples vs. Lists vs. Sets in Python</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Python中的元组、列表和集合</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/tuples-vs-lists-vs-sets-in-python-3dff8a7b1f02?source=collection_archive---------10-----------------------#2021-07-13">https://betterprogramming.pub/tuples-vs-lists-vs-sets-in-python-3dff8a7b1f02?source=collection_archive---------10-----------------------#2021-07-13</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="b1b9" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">你可能一直都用错了</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/e255855d5955dc68bea443eff2e7ea7b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*3xMasHsr8OgaPKAl"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated"><a class="ae ky" href="https://unsplash.com/@bradyn?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Bradyn Trollip </a>在<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片。</p></figure><p id="70b6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在Python中，有四种内置的数据类型可以用来存储数据集合。这些内置的数据类型具有不同的性质和特点，分别被称为<a class="ae ky" href="https://www.w3schools.com/python/python_lists.asp" rel="noopener ugc nofollow" target="_blank">列表</a> ( <code class="fe lv lw lx ly b">list</code>)、<a class="ae ky" href="https://www.w3schools.com/python/python_tuples.asp" rel="noopener ugc nofollow" target="_blank">元组</a> ( <code class="fe lv lw lx ly b">tuple</code>)、<a class="ae ky" href="https://www.w3schools.com/python/python_sets.asp" rel="noopener ugc nofollow" target="_blank">集合</a> ( <code class="fe lv lw lx ly b">set</code>)、<a class="ae ky" href="https://www.w3schools.com/python/python_dictionaries.asp" rel="noopener ugc nofollow" target="_blank">字典</a> ( <code class="fe lv lw lx ly b">dict</code>)。</p><p id="be06" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在本文中，我们将略微深入Python中的List、Tuple和Set，讨论它们的区别以及何时使用这些数据类型。</p><p id="8f02" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">由于Dictionary将键与它们各自的值相关联，这与List、Tuple和Set(它们只包含值)相比是一个非常不同的用例，因此它不属于本次讨论的范围。</p><p id="7f6f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">为了简单起见，我可能会互换使用Set和Dictionary，因为它们是基于<a class="ae ky" href="https://en.wikipedia.org/wiki/Hash_table" rel="noopener ugc nofollow" target="_blank">哈希表</a>(或哈希映射)。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi lz"><img src="../Images/de9c3009db4f91bc6cb2f6774828f10e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*MRMpZ6ldubfuwDWUnLodGg.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">Python内置数据类型来存储数据集合</p></figure><h2 id="39b1" class="ma mb it bd mc md me dn mf mg mh dp mi li mj mk ml lm mm mn mo lq mp mq mr ms bi translated">TL；速度三角形定位法(dead reckoning)</h2><ul class=""><li id="a269" class="mt mu it lb b lc mv lf mw li mx lm my lq mz lu na nb nc nd bi translated">如果您需要存储副本，请使用列表或元组。</li><li id="617b" class="mt mu it lb b lc ne lf nf li ng lm nh lq ni lu na nb nc nd bi translated">对于List vs. Tuple，如果您不打算进行变异，请选择Tuple。</li><li id="4c19" class="mt mu it lb b lc ne lf nf li ng lm nh lq ni lu na nb nc nd bi translated">如果您不需要存储副本，请始终使用集合或字典，因为在确定一个对象是否在集合中时，它们会快得多(例如<code class="fe lv lw lx ly b">x in set_or_dict</code>)。</li></ul></div><div class="ab cl nj nk hx nl" role="separator"><span class="nm bw bk nn no np"/><span class="nm bw bk nn no np"/><span class="nm bw bk nn no"/></div><div class="im in io ip iq"><h1 id="9e77" class="nq mb it bd mc nr ns nt mf nu nv nw mi jz nx ka ml kc ny kd mo kf nz kg mr oa bi translated">我们为什么关心？</h1><p id="56b8" class="pw-post-body-paragraph kz la it lb b lc mv ju le lf mw jx lh li ob lk ll lm oc lo lp lq od ls lt lu im bi translated">在大多数情况下，这些数据类型可以在一个应用程序中互换使用，不会有太大的麻烦。然而，想象一下，如果给我们一个任务，检查在一个相当大的干草堆中是否存在一根针。就速度和内存而言，这样做最有效的方式是什么？</p><p id="2591" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">草堆应该是列表吗？元组呢？或者为什么不总是用一套(或者一本字典)？我们应该注意哪些警告？</p><p id="18d1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们开始吃吧。</p></div><div class="ab cl nj nk hx nl" role="separator"><span class="nm bw bk nn no np"/><span class="nm bw bk nn no np"/><span class="nm bw bk nn no"/></div><div class="im in io ip iq"><h1 id="1c15" class="nq mb it bd mc nr ns nt mf nu nv nw mi jz nx ka ml kc ny kd mo kf nz kg mr oa bi translated">列表、元组和集之间的区别</h1><h2 id="6644" class="ma mb it bd mc md me dn mf mg mh dp mi li mj mk ml lm mm mn mo lq mp mq mr ms bi translated">复制</h2><p id="e4ce" class="pw-post-body-paragraph kz la it lb b lc mv ju le lf mw jx lh li ob lk ll lm oc lo lp lq od ls lt lu im bi translated">如果我要解释这一点，列表和元组就像Python中的兄弟姐妹。另一方面，Set(或Dictionary)就像是这两者的表亲。</p><p id="8b3d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">与列表或元组不同，集合不能包含重复项。换句话说，集合中的元素是唯一的。</p><pre class="kj kk kl km gt oe ly of og aw oh bi"><span id="d4e9" class="ma mb it ly b gy oi oj l ok ol">set_example = {1, 1, 2, 3, 3, 3}<br/># {1, 2, 3}</span><span id="e6e3" class="ma mb it ly b gy om oj l ok ol">fruit_set = {'🍎', '🍓', '🍐', '🍎', '🍎', '🍓'}<br/># {'🍎', '🍐', '🍓'}</span></pre><p id="77a6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">有了这些知识，我们现在知道Set也可以用来从列表中删除重复项！</p><h2 id="7249" class="ma mb it bd mc md me dn mf mg mh dp mi li mj mk ml lm mm mn mo lq mp mq mr ms bi translated">命令</h2><p id="faed" class="pw-post-body-paragraph kz la it lb b lc mv ju le lf mw jx lh li ob lk ll lm oc lo lp lq od ls lt lu im bi translated">您可能听说过“Python中的集合和字典是无序的”这句话现在，这只是事实的一半，这取决于你使用的Python版本。</p><p id="35e4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在Python 3.6之前，字典和集合不会保留它们的插入顺序。如果您在Python 3.5中尝试，这里有一个示例:</p><pre class="kj kk kl km gt oe ly of og aw oh bi"><span id="1fd4" class="ma mb it ly b gy oi oj l ok ol"># Example in Python 3.5</span><span id="88e3" class="ma mb it ly b gy om oj l ok ol">fruit_size = {} <br/>&gt;&gt;&gt; fruit_size['🍎'] = 12 <br/>&gt;&gt;&gt; fruit_size['🍐'] = 16 <br/>&gt;&gt;&gt; fruit_size['🍇'] = 20 <br/>&gt;&gt;&gt; fruit_size<br/>{'🍎': 12, '🍇': 20, '🍐': 16}</span></pre><p id="d80e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><em class="on">使用</em> <a class="ae ky" href="https://github.com/pyenv/pyenv" rel="noopener ugc nofollow" target="_blank"> <em class="on"> pyenv </em> </a> <em class="on">可以轻松切换到不同版本的Python。试试吧！</em></p><p id="e9e1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">今天，这句话已经过时几年了。<a class="ae ky" href="https://mail.python.org/pipermail/python-dev/2017-December/151283.html" rel="noopener ugc nofollow" target="_blank">从Python 3.7 </a>开始，字典和集合<a class="ae ky" href="https://docs.python.org/3/whatsnew/3.7.html#summary-release-highlights" rel="noopener ugc nofollow" target="_blank">正式</a>按插入时间排序。</p><p id="77ef" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">无论如何，如果你想知道，列表和元组是对象的有序序列。</p><h2 id="9dc1" class="ma mb it bd mc md me dn mf mg mh dp mi li mj mk ml lm mm mn mo lq mp mq mr ms bi translated">易变性</h2><p id="e404" class="pw-post-body-paragraph kz la it lb b lc mv ju le lf mw jx lh li ob lk ll lm oc lo lp lq od ls lt lu im bi translated">当你把一个对象描述为可变的时候，这仅仅是说对象的内部状态可以被改变的一种奇特的方式。</p><p id="20bd" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这里的关键区别是Tuple是不可变的，而List和Set是可变的。</p><p id="31ab" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">尽管集合是可变的，但我们不能通过索引或切片来访问或更改集合中的任何元素。因此，我们只能向集合中添加新元素，而不能改变它们。</p><p id="d7cc" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">请注意集合中的<code class="fe lv lw lx ly b"><a class="ae ky" href="https://www.geeksforgeeks.org/python-set-update/" rel="noopener ugc nofollow" target="_blank">update</a></code>方法仅仅意味着一次添加多个元素的能力。</p><h2 id="f68a" class="ma mb it bd mc md me dn mf mg mh dp mi li mj mk ml lm mm mn mo lq mp mq mr ms bi translated">索引</h2><p id="d812" class="pw-post-body-paragraph kz la it lb b lc mv ju le lf mw jx lh li ob lk ll lm oc lo lp lq od ls lt lu im bi translated">Tuple和List都支持索引和<a class="ae ky" href="https://www.w3schools.com/python/python_strings_slicing.asp" rel="noopener ugc nofollow" target="_blank">切片</a>，而Set不支持。</p><pre class="kj kk kl km gt oe ly of og aw oh bi"><span id="72a1" class="ma mb it ly b gy oi oj l ok ol">fruit_list = ['🍎', '🍓', '🍐']<br/>fruit_list[1]<br/># '🍓'</span><span id="a542" class="ma mb it ly b gy om oj l ok ol">animal_tuple = ('🐶', '🐱', '🐮')<br/>animal_tuple[2]<br/># '🐮'</span><span id="5913" class="ma mb it ly b gy om oj l ok ol">vehicle_set = {'🚐', '🏍', '🚗'}<br/>vehicle_set[0]<br/># TypeError: 'set' object is not subscriptable</span></pre></div><div class="ab cl nj nk hx nl" role="separator"><span class="nm bw bk nn no np"/><span class="nm bw bk nn no np"/><span class="nm bw bk nn no"/></div><div class="im in io ip iq"><h1 id="cf2f" class="nq mb it bd mc nr ns nt mf nu nv nw mi jz nx ka ml kc ny kd mo kf nz kg mr oa bi translated">何时使用列表还是元组</h1><p id="f908" class="pw-post-body-paragraph kz la it lb b lc mv ju le lf mw jx lh li ob lk ll lm oc lo lp lq od ls lt lu im bi translated">正如我们前面提到的，元组是不可变的，而列表是可变的。同理，<a class="ae ky" href="https://docs.python.org/3/tutorial/datastructures.html#tuples-and-sequences" rel="noopener ugc nofollow" target="_blank">元组</a>本质上是固定大小的，而<a class="ae ky" href="https://docs.python.org/3/tutorial/introduction.html#lists" rel="noopener ugc nofollow" target="_blank">列表</a>是动态的。</p><pre class="kj kk kl km gt oe ly of og aw oh bi"><span id="8c44" class="ma mb it ly b gy oi oj l ok ol">a_tuple = tuple(range(1000))<br/>a_list = list(range(1000))</span><span id="0a53" class="ma mb it ly b gy om oj l ok ol">a_tuple.__sizeof__()  # 8024 bytes<br/>a_list.__sizeof__()   # 9088 bytes</span></pre><h2 id="11a3" class="ma mb it bd mc md me dn mf mg mh dp mi li mj mk ml lm mm mn mo lq mp mq mr ms bi translated">使用列表</h2><ol class=""><li id="998d" class="mt mu it lb b lc mv lf mw li mx lm my lq mz lu oo nb nc nd bi translated">当你需要改变你的收藏时。</li><li id="8121" class="mt mu it lb b lc ne lf nf li ng lm nh lq ni lu oo nb nc nd bi translated">当您需要在项目集合中移除或添加新项目时。</li></ol><h2 id="44a0" class="ma mb it bd mc md me dn mf mg mh dp mi li mj mk ml lm mm mn mo lq mp mq mr ms bi translated">使用元组</h2><ol class=""><li id="7dcd" class="mt mu it lb b lc mv lf mw li mx lm my lq mz lu oo nb nc nd bi translated">您的数据是否需要更改。</li><li id="41c7" class="mt mu it lb b lc ne lf nf li ng lm nh lq ni lu oo nb nc nd bi translated">元组比列表快<a class="ae ky" href="https://stackoverflow.com/a/3340881/10067850" rel="noopener ugc nofollow" target="_blank"/>。如果我们定义一组常量值，并且我们要做的只是遍历它，那么我们应该使用Tuple而不是List。</li><li id="e162" class="mt mu it lb b lc ne lf nf li ng lm nh lq ni lu oo nb nc nd bi translated">如果我们需要一个元素数组作为字典键，我们可以<a class="ae ky" href="https://diveintopython3.net/native-datatypes.html#tuples" rel="noopener ugc nofollow" target="_blank">使用元组</a>。由于列表是可变的，所以它们永远不能用作字典键。</li></ol></div><div class="ab cl nj nk hx nl" role="separator"><span class="nm bw bk nn no np"/><span class="nm bw bk nn no np"/><span class="nm bw bk nn no"/></div><div class="im in io ip iq"><h1 id="18dc" class="nq mb it bd mc nr ns nt mf nu nv nw mi jz nx ka ml kc ny kd mo kf nz kg mr oa bi translated">何时使用集合与列表/元组</h1><p id="86cd" class="pw-post-body-paragraph kz la it lb b lc mv ju le lf mw jx lh li ob lk ll lm oc lo lp lq od ls lt lu im bi translated">由于Set使用哈希表作为其底层数据结构，当检查一个元素是否在其中时(例如<code class="fe lv lw lx ly b">x in a_set</code>)，Set<em class="on">非常快</em>。</p><p id="f4fd" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">其背后的思想是，在哈希表中查找一个条目是一个<em class="on"> O(1)(常数时间)</em>操作。</p><h2 id="5957" class="ma mb it bd mc md me dn mf mg mh dp mi li mj mk ml lm mm mn mo lq mp mq mr ms bi translated">那么，我应该总是使用Set还是字典呢？</h2><p id="4f4c" class="pw-post-body-paragraph kz la it lb b lc mv ju le lf mw jx lh li ob lk ll lm oc lo lp lq od ls lt lu im bi translated">本质上，如果您不需要存储副本，Set将比List更好。句号。</p></div><div class="ab cl nj nk hx nl" role="separator"><span class="nm bw bk nn no np"/><span class="nm bw bk nn no np"/><span class="nm bw bk nn no"/></div><div class="im in io ip iq"><h1 id="ab8e" class="nq mb it bd mc nr ns nt mf nu nv nw mi jz nx ka ml kc ny kd mo kf nz kg mr oa bi translated">摘要</h1><p id="9b48" class="pw-post-body-paragraph kz la it lb b lc mv ju le lf mw jx lh li ob lk ll lm oc lo lp lq od ls lt lu im bi translated">那么，主要的外卖有哪些呢？</p><ul class=""><li id="96eb" class="mt mu it lb b lc ld lf lg li op lm oq lq or lu na nb nc nd bi translated">如果您需要存储副本，请使用列表或元组。</li><li id="e4dd" class="mt mu it lb b lc ne lf nf li ng lm nh lq ni lu na nb nc nd bi translated">对于List vs. Tuple，如果您不打算进行变异，请选择Tuple。</li><li id="686a" class="mt mu it lb b lc ne lf nf li ng lm nh lq ni lu na nb nc nd bi translated">如果您不需要存储副本，请始终使用集合或字典，因为在确定集合中是否存在某个对象时，它们要快得多(例如<code class="fe lv lw lx ly b">x in set_or_dict</code>)。</li></ul><p id="157a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果你像我一样是一个数字迷，当你迭代或检查一个对象是否存在于一个集合中时，看看这个Tuple、List和Set之间的速度比较。</p><p id="5a59" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">最终，在很大程度上，我真的认为我们不应该过多考虑使用哪种数据结构。</p><blockquote class="os"><p id="e524" class="ot ou it bd ov ow ox oy oz pa pb lu dk translated"><em class="pc">“过早优化是万恶之源。”</em></p></blockquote><h2 id="d1c4" class="ma mb it bd mc md pd dn mf mg pe dp mi li pf mk ml lm pg mn mo lq ph mq mr ms bi translated">其他参考文献</h2><ul class=""><li id="e252" class="mt mu it lb b lc mv lf mw li mx lm my lq mz lu na nb nc nd bi translated"><a class="ae ky" href="https://wiki.python.org/moin/TimeComplexity" rel="noopener ugc nofollow" target="_blank">https://wiki.python.org/moin/TimeComplexity</a></li></ul></div><div class="ab cl nj nk hx nl" role="separator"><span class="nm bw bk nn no np"/><span class="nm bw bk nn no np"/><span class="nm bw bk nn no"/></div><div class="im in io ip iq"><h2 id="4567" class="ma mb it bd mc md me dn mf mg mh dp mi li mj mk ml lm mm mn mo lq mp mq mr ms bi translated"><a class="ae ky" href="https://jerrynsh.com/tuples-vs-lists-vs-sets-in-python/" rel="noopener ugc nofollow" target="_blank">最初发表于jerrynsh.com</a></h2><div class="pi pj gp gr pk pl"><a rel="noopener  ugc nofollow" target="_blank" href="/how-to-write-clean-code-in-python-5d67746133f2"><div class="pm ab fo"><div class="pn ab po cl cj pp"><h2 class="bd iu gy z fp pq fr fs pr fu fw is bi translated">如何用Python写干净的代码</h2><div class="ps l"><h3 class="bd b gy z fp pq fr fs pr fu fw dk translated">使用Python示例编写干净代码的3个技巧</h3></div><div class="pt l"><p class="bd b dl z fp pq fr fs pr fu fw dk translated">better编程. pub</p></div></div><div class="pu l"><div class="pv l pw px py pu pz ks pl"/></div></div></a></div><div class="pi pj gp gr pk pl"><a rel="noopener  ugc nofollow" target="_blank" href="/3-useful-python-f-string-tricks-you-probably-dont-know-f908f7ed6cf5"><div class="pm ab fo"><div class="pn ab po cl cj pp"><h2 class="bd iu gy z fp pq fr fs pr fu fw is bi translated">你可能不知道的3个有用的Python f-string技巧</h2><div class="ps l"><h3 class="bd b gy z fp pq fr fs pr fu fw dk translated">关于Python的格式化字符串(f-string)你需要知道的事情</h3></div><div class="pt l"><p class="bd b dl z fp pq fr fs pr fu fw dk translated">better编程. pub</p></div></div><div class="pu l"><div class="qa l pw px py pu pz ks pl"/></div></div></a></div></div></div>    
</body>
</html>