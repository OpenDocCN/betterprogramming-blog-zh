<html>
<head>
<title>How to Deal With Modal Views in SwiftUI</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何在SwiftUI中处理模态视图</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/how-to-deal-with-modal-views-a-k-a-sheets-with-swiftui-5c4cca7862d6?source=collection_archive---------9-----------------------#2020-12-02">https://betterprogramming.pub/how-to-deal-with-modal-views-a-k-a-sheets-with-swiftui-5c4cca7862d6?source=collection_archive---------9-----------------------#2020-12-02</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="e28b" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">关于床单你需要知道的一切</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/f7c23d5c0593f917de0a2f338bdc3c61.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Elbd4_-nWZ8Gwql9ThjH1Q.jpeg"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">照片由<a class="ae ky" href="https://unsplash.com/@driesdeschepper" rel="noopener ugc nofollow" target="_blank"> Dries De Schepper </a>在<a class="ae ky" href="https://unsplash.com/?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄。</p></figure><p id="1287" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">当在屏幕上显示一小段额外信息时，显示模态视图是必不可少的。有了UIKit，我们可以用<code class="fe lv lw lx ly b">presentViewController:animated:completion:</code> <a class="ae ky" href="https://developer.apple.com/documentation/uikit/uiviewcontroller/1621380-presentviewcontroller" rel="noopener ugc nofollow" target="_blank">函数</a>来做这件事。</p><p id="fc10" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">然而，当使用SwiftUI时，我们需要将我们的思维转向使用视图或环境状态，因为模态视图现在被称为工作表。</p><p id="b6c6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们详细检查一下。</p></div><div class="ab cl lz ma hx mb" role="separator"><span class="mc bw bk md me mf"/><span class="mc bw bk md me mf"/><span class="mc bw bk md me"/></div><div class="im in io ip iq"><h1 id="65ec" class="mg mh it bd mi mj mk ml mm mn mo mp mq jz mr ka ms kc mt kd mu kf mv kg mw mx bi translated">打开模式视图(又名图纸)</h1><p id="785e" class="pw-post-body-paragraph kz la it lb b lc my ju le lf mz jx lh li na lk ll lm nb lo lp lq nc ls lt lu im bi translated">SwiftUI表帮助我们向用户展示一个模态视图。<code class="fe lv lw lx ly b">sheet</code>是<a class="ae ky" href="https://developer.apple.com/documentation/swiftui/view-presentation" rel="noopener ugc nofollow" target="_blank">视图展示</a>的实例方法。它描述了我们如何展示SwiftUI视图，涵盖具体的用户旅程场景。</p><p id="93a2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">假设我们想要向用户显示关于我们的应用程序的信息。</p><p id="8770" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">首先，我们需要定义应用程序是否应该显示模态视图，用<code class="fe lv lw lx ly b">Bool</code>值绑定它。</p><p id="2467" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这里的关键字是“应该”，因为一旦我们忽略它，呈现的视图值将被设置回<code class="fe lv lw lx ly b">false</code>。这个值用一个<code class="fe lv lw lx ly b">@State</code>属性包装器修饰，或者可以来自<code class="fe lv lw lx ly b">ObservableObject</code>视图模型。为了简单起见，我们不打算在这篇文章中讨论视图模型。</p><p id="ddb2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">其次，我们需要改变视图，或者在某些情况下，改变环境状态。一旦我们使用了<code class="fe lv lw lx ly b">@State</code>属性包装器，我们只需将其设置为<code class="fe lv lw lx ly b">true</code>，SwiftUI将完成剩下的工作来呈现模态视图。</p><p id="4b72" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们看看如何在代码中做到这一点:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nd ne l"/></div></figure><p id="c9af" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">当我们运行应用程序时，我们现在可以打开模式视图并查看详细信息:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi nf"><img src="../Images/bb221a7e3cfc876f10596c8e3a6f50b4.png" data-original-src="https://miro.medium.com/v2/resize:fit:500/0*K3ccCcoOQOK4iwFX.gif"/></div></figure></div><div class="ab cl lz ma hx mb" role="separator"><span class="mc bw bk md me mf"/><span class="mc bw bk md me mf"/><span class="mc bw bk md me"/></div><div class="im in io ip iq"><h1 id="468d" class="mg mh it bd mi mj mk ml mm mn mo mp mq jz mr ka ms kc mt kd mu kf mv kg mw mx bi translated">以编程方式关闭模式视图</h1><p id="e8c3" class="pw-post-body-paragraph kz la it lb b lc my ju le lf mz jx lh li na lk ll lm nb lo lp lq nc ls lt lu im bi translated">我们的应用程序用户可以简单地向下滑动模态视图，它将隐藏一个漂亮的动画。将状态设置为<code class="fe lv lw lx ly b">false</code>以隐藏负责显示模态视图的视图。</p><p id="c558" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在，我们如何从模态视图本身做到这一点呢？我们有两种选择:</p><ul class=""><li id="8519" class="ng nh it lb b lc ld lf lg li ni lm nj lq nk lu nl nm nn no bi translated">使用<code class="fe lv lw lx ly b">@Environment</code>属性<code class="fe lv lw lx ly b">presentationMode</code>。</li><li id="6beb" class="ng nh it lb b lc np lf nq li nr lm ns lq nt lu nl nm nn no bi translated">将状态作为绑定传递给模式视图。</li></ul><h2 id="2abf" class="nu mh it bd mi nv nw dn mm nx ny dp mq li nz oa ms lm ob oc mu lq od oe mw of bi translated">使用环境</h2><p id="16ef" class="pw-post-body-paragraph kz la it lb b lc my ju le lf mz jx lh li na lk ll lm nb lo lp lq nc ls lt lu im bi translated">属性包装器<code class="fe lv lw lx ly b">@Environment</code>允许我们读取和更改视图环境状态的值。为了隐藏模态视图，我们需要更改<code class="fe lv lw lx ly b">presentationMode</code>属性。首先，我们需要定义我们的视图。为此，我们将它添加到模式视图属性中。要消除模态视图，我们需要改变呈现模式包装值:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nd ne l"/></div></figure><p id="14f8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这种方法相当麻烦，而且处理环境属性可能会导致难以跟踪和调试的意外问题。</p><h2 id="2d63" class="nu mh it bd mi nv nw dn mm nx ny dp mq li nz oa ms lm ob oc mu lq od oe mw of bi translated">使用绑定</h2><p id="d106" class="pw-post-body-paragraph kz la it lb b lc my ju le lf mz jx lh li na lk ll lm nb lo lp lq nc ls lt lu im bi translated">在呈现模式视图的视图和模式视图本身之间使用绑定是另一种从代码中隐藏它的方法。</p><p id="23d8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">首先，我们需要使用<code class="fe lv lw lx ly b">@Binding</code>属性包装器向模态视图结构添加一个新属性。这说明这个值来自视图范围之外的其他地方。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nd ne l"/></div></figure><p id="136c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在当我们初始化<code class="fe lv lw lx ly b">ModalView</code>时，我们需要通过<code class="fe lv lw lx ly b">isPresented</code>:</p><pre class="kj kk kl km gt og ly oh oi aw oj bi"><span id="e272" class="nu mh it ly b gy ok ol l om on">.sheet(isPresented: $showInfoModalView) {<br/>    InfoView(isPresented: $showInfoModalView)<br/>  }</span></pre><p id="4f37" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">使用这种方法，我们可以确定这个变量只属于这两个视图。测试和调试更加简单。</p></div><div class="ab cl lz ma hx mb" role="separator"><span class="mc bw bk md me mf"/><span class="mc bw bk md me mf"/><span class="mc bw bk md me"/></div><div class="im in io ip iq"><h1 id="0a79" class="mg mh it bd mi mj mk ml mm mn mo mp mq jz mr ka ms kc mt kd mu kf mv kg mw mx bi translated">一个SwiftUI视图上的多个工作表</h1><p id="9685" class="pw-post-body-paragraph kz la it lb b lc my ju le lf mz jx lh li na lk ll lm nb lo lp lq nc ls lt lu im bi translated">现在我们知道了如何呈现一个模态视图，但是如何显示多个模态视图呢？</p><p id="c2d8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">假设我们希望从主应用程序视图中呈现应用程序和设置视图的相关信息。</p><p id="df90" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们可以通过以下两种方法实现这一点:</p><ul class=""><li id="6f2f" class="ng nh it lb b lc ld lf lg li ni lm nj lq nk lu nl nm nn no bi translated">使用多张纸展示功能。</li><li id="b72d" class="ng nh it lb b lc np lf nq li nr lm ns lq nt lu nl nm nn no bi translated">使用<code class="fe lv lw lx ly b">Identifiable</code>枚举保持当前显示的工作表的状态。</li></ul><h2 id="461a" class="nu mh it bd mi nv nw dn mm nx ny dp mq li nz oa ms lm ob oc mu lq od oe mw of bi translated">一个SwiftUI视图中的多个工作表功能</h2><p id="4a41" class="pw-post-body-paragraph kz la it lb b lc my ju le lf mz jx lh li na lk ll lm nb lo lp lq nc ls lt lu im bi translated">我们可以将<code class="fe lv lw lx ly b">sheet</code>功能附加到任何SwiftUI视图或控件上(例如，附加到<code class="fe lv lw lx ly b">Button</code>):</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nd ne l"/></div></figure><p id="e8c0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">有两个按钮可以很好，但假设我们有更多的按钮。这会变得相当混乱，所以我们应该处理许多<code class="fe lv lw lx ly b">@State</code>变量。</p><h2 id="c876" class="nu mh it bd mi nv nw dn mm nx ny dp mq li nz oa ms lm ob oc mu lq od oe mw of bi translated">使用所有模态视图的枚举</h2><p id="827c" class="pw-post-body-paragraph kz la it lb b lc my ju le lf mz jx lh li na lk ll lm nb lo lp lq nc ls lt lu im bi translated">如果我们看苹果的官方文档，还有另外一个<a class="ae ky" href="https://developer.apple.com/documentation/swiftui/view/actionsheet(item:content:)" rel="noopener ugc nofollow" target="_blank">函数</a>显示一张表。让我们试着使用它。</p><p id="a289" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">首先，我们将定义一个包含所有模态视图选项的<code class="fe lv lw lx ly b">enum</code>:</p><pre class="kj kk kl km gt og ly oh oi aw oj bi"><span id="7d94" class="nu mh it ly b gy ok ol l om on">enum Sheet: Identifiable {<br/>    case info<br/>    case settings<br/>  }</span></pre><p id="6609" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在我们可以在SwiftUI视图中使用它。我们需要一个可选类型为<code class="fe lv lw lx ly b">Sheet</code>的新<code class="fe lv lw lx ly b">@State</code>变量，并使用它来确定我们想要呈现哪个模态视图:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nd ne l"/></div></figure><p id="d098" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们不需要在这里停下来。我们可以通过向<code class="fe lv lw lx ly b">Sheet</code>枚举添加一个计算属性来整理这段代码:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nd ne l"/></div></figure><p id="b61c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">然后我们可以在打开工作表时使用它:</p><pre class="kj kk kl km gt og ly oh oi aw oj bi"><span id="7cb0" class="nu mh it ly b gy ok ol l om on">.sheet(item: $activeSheet) { $0.modalView }</span></pre><p id="5c64" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">使用闭包中新奇的keypaths功能，我们可以进一步简化:</p><pre class="kj kk kl km gt og ly oh oi aw oj bi"><span id="f344" class="nu mh it ly b gy ok ol l om on">.sheet(item: $activeSheet, content: \.modalView)</span></pre><p id="120c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">对这种方法的一个警告是，我们需要改变我们过程的一部分来隐藏代码中的视图。为此，我们将其设置为<code class="fe lv lw lx ly b">nil</code>而不是<code class="fe lv lw lx ly b">false</code>。</p><p id="d309" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这种方法要安全得多，因为我们使用枚举类型来保持一切井井有条。</p><p id="d5ef" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们看看它的实际效果。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi nf"><img src="../Images/f9ed4992daaa438e72a02ba82f168b06.png" data-original-src="https://miro.medium.com/v2/resize:fit:500/0*yef0y7y_1XDpQUdz.gif"/></div></figure></div><div class="ab cl lz ma hx mb" role="separator"><span class="mc bw bk md me mf"/><span class="mc bw bk md me mf"/><span class="mc bw bk md me"/></div><div class="im in io ip iq"><h1 id="1010" class="mg mh it bd mi mj mk ml mm mn mo mp mq jz mr ka ms kc mt kd mu kf mv kg mw mx bi translated">TL；速度三角形定位法(dead reckoning)</h1><p id="fcec" class="pw-post-body-paragraph kz la it lb b lc my ju le lf mz jx lh li na lk ll lm nb lo lp lq nc ls lt lu im bi translated">SwiftUI中的模态视图是使用视图或控件上的<code class="fe lv lw lx ly b">sheet</code>修饰符来呈现的。最简单的方法是用一个<code class="fe lv lw lx ly b">@State</code>属性来指示它何时应该可见。</p><p id="6681" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">为了隐藏模态视图，我们可以使用环境参数或者向模态视图对象传递一个绑定。显示多个表可以通过使用多个表修饰符或者使用一个具有所有可能的模式视图枚举的对象来实现。</p></div><div class="ab cl lz ma hx mb" role="separator"><span class="mc bw bk md me mf"/><span class="mc bw bk md me mf"/><span class="mc bw bk md me"/></div><div class="im in io ip iq"><h1 id="6508" class="mg mh it bd mi mj mk ml mm mn mo mp mq jz mr ka ms kc mt kd mu kf mv kg mw mx bi translated">资源</h1><ul class=""><li id="7b99" class="ng nh it lb b lc my lf mz li oo lm op lq oq lu nl nm nn no bi translated"><a class="ae ky" href="https://github.com/fassko/ModalViewApp" rel="noopener ugc nofollow" target="_blank">演示应用——我们讨论的所有内容都有多个分支</a></li><li id="033e" class="ng nh it lb b lc np lf nq li nr lm ns lq nt lu nl nm nn no bi translated"><a class="ae ky" href="https://developer.apple.com/documentation/swiftui/view/sheet(ispresented:ondismiss:content:)" rel="noopener ugc nofollow" target="_blank">苹果官方文件</a></li><li id="8b37" class="ng nh it lb b lc np lf nq li nr lm ns lq nt lu nl nm nn no bi translated"><a class="ae ky" href="https://www.simpleswiftguide.com/how-to-present-sheet-modally-in-swiftui/" rel="noopener ugc nofollow" target="_blank">如何在SwiftUI中有模式地展示一个表</a></li><li id="e4d6" class="ng nh it lb b lc np lf nq li nr lm ns lq nt lu nl nm nn no bi translated"><a class="ae ky" href="https://swiftwithmajid.com/2019/07/24/alerts-actionsheets-modals-and-popovers-in-swiftui/" rel="noopener ugc nofollow" target="_blank">swift ui中的警报、动作表、模态和弹出框</a></li><li id="51c4" class="ng nh it lb b lc np lf nq li nr lm ns lq nt lu nl nm nn no bi translated"><a class="ae ky" href="https://www.hackingwithswift.com/quick-start/swiftui/how-to-present-a-new-view-using-sheets" rel="noopener ugc nofollow" target="_blank">如何使用工作表呈现新视图</a></li><li id="4916" class="ng nh it lb b lc np lf nq li nr lm ns lq nt lu nl nm nn no bi translated"><a class="ae ky" href="https://masilotti.com/multiple-sheets-swiftui/" rel="noopener ugc nofollow" target="_blank">如何在SwiftUI中管理多张表</a></li><li id="62c2" class="ng nh it lb b lc np lf nq li nr lm ns lq nt lu nl nm nn no bi translated"><a class="ae ky" href="https://stackoverflow.com/questions/58837007/multiple-sheetispresented-doesnt-work-in-swiftui" rel="noopener ugc nofollow" target="_blank">线程进入堆栈溢出</a></li><li id="0db6" class="ng nh it lb b lc np lf nq li nr lm ns lq nt lu nl nm nn no bi translated"><a class="ae ky" href="https://www.youtube.com/watch?feature=player_embedded&amp;v=7dZfpAn_P2g" rel="noopener ugc nofollow" target="_blank">多张纸的枚举</a></li><li id="eb8e" class="ng nh it lb b lc np lf nq li nr lm ns lq nt lu nl nm nn no bi translated"><a class="ae ky" href="https://github.com/davdroman/MultiSheet" rel="noopener ugc nofollow" target="_blank">多张纸</a></li></ul></div></div>    
</body>
</html>