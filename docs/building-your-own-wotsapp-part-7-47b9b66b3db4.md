# 构建您自己的 WotsApp —第 7 部分

> 原文：<https://betterprogramming.pub/building-your-own-wotsapp-part-7-47b9b66b3db4>

## 使用 SwiftUI、Combine、通知、CloudKit 和加密技术

![](img/074bca4aa0b581394c07cc568c3b1feb.png)

杰瑞米·毕肖普在 [Unsplash](https://unsplash.com/s/photos/skyscrappers-night-time?utm_source=unsplash&utm_medium=referral&utm_content=creditCopyText) 上的照片。

我应该以免责声明开始这篇文章:它是基于 iOS 13、Swift 5 和 Xcode 11.x 的。如果你正在阅读这篇文章，而那些数字看起来过时了，请预先警告。

我还应该提醒你，通知——主要是远程通知——涉及苹果的基础设施，这意味着你需要一个苹果开发者账户才能使用它们。当然，你也需要一个来使用 CloudKit。

结束我们的审查…在审查中，我认为我们可以通过一些设计更改来解决最后几个问题，这些更改将一次性解决几乎所有问题。

在上一章中，我们做了 3/4 的工作来阻止和隐藏条目。我想出了一个扭转局面的计划。不过，我现在不会这么做。让我们首先解决多用户问题，这是更重要的。

# 第十三章

现在，我确信我们将有两个用户想要相同的登录名。这一点我们都同意。在当前的设计中，他们也有可能选择同样的秘密。几率比你想象的要大得多——只是谷歌常用密码。这种组合将奠定我们目前的设计。

我们可以通过创建应用内的秘密来解决这个问题，只是我们称之为 PIN 码。人们已经习惯了被发给密码，而不是秘密。

然后，我们可以通过对我们的协议进行细微的修改来解决同名问题。当你点击一个用户时，它不会发送与对方通话的请求。它会要求您确认他们的 PIN。我们可以将这个 PIN 码存储在我们用 MD5 散列加密的公共目录中。是的，我知道 MD5 散列不太安全，但我们已经在安装的加密包中获得了代码…毕竟，我们不是在建立一个银行。

当他们点击一个名字时，我们将建立一个拥有该名字的所有用户的子集，并要求他们输入 PIN。然后，我们可以使用他们的名字和他们刚刚输入的 PIN 的 MD5 散列，在我们刚刚下载的子集中找到他们想要通话的用户。

鉴于您已经知道了代码，我们将假设可以连接，这大大简化了整个过程。

这样，我们可以在数据库中拥有无限数量的重复名称，当您列出目录时，只有一个名称出现。这是我们要解决的第一个问题。

现在，如果我不需要一个盒子来键入一个秘密，我就可以把那个空格收回来。所以让我们用它作为一个组名。

这是双赢。我们不要求用户输入更多的内容，我们保持界面几乎不变。事实上，组名可以是可选的。它甚至可能是一个应用程序购买。现在有一个想法。这是我们的第二点。

让我们有一个规则，如果你键入一个组，它假设你想创建一个私人目录，不希望你的名字出现在全局目录中。很明显，你需要和你的朋友分享群名。否则，他们永远找不到你。这是我们的第三点。

## 问题和解决方案

编辑`Crypto.swift`文件并添加这个简短的方法来生成 PIN 码:

是的，有极小的可能性，你会得到两个用户相同的名字和相同的代码。但这没关系，因为我们将比较这段代码的 MD5 散列，它应该是唯一的。说到散列，这里是您需要添加到`Crypto.swift`文件中的`md5hash`方法的代码:

注意，您需要在文件的顶部导入 Cryptor 库。现在移到`Storage.swift`，编辑`saveToPublic`方法。给它添加一个对新的`md5hash`方法的调用:

因此，当您添加一个用户时，他们的代码将自动生成并保存在他们的私有文件中，并作为哈希保存在他们的公共文件中。诚然，公共文件并不是真正的公共文件——只有这个应用程序可以访问它——但原则是存在的。你不能在公共数据库中存储私人数据。最后，编辑`ContentView.swift`文件并更新按钮以包含新方法。这将使我们继续前进:

好了，你应该准备好测试了。进行更改，使用 CloudKit dashboard 清空您的数据库，并测试代码。创建一个新用户，确保你有一个 PIN 码和 MD5 散列文件。

我们现在需要对协议进行修改——相当剧烈的修改，真的。我们将不再请求连接许可。我们假设如果他们知道密码，他们可以连接。先说`Storage.swift`。

我想要一个记录的简单表示，所以我在`Storage.swift`中定义了一个新的结构，并定义了一个新的`PassThroughPublisher`来使用它:

完成后，我创建了一些新方法来使用这个新结构。我们还需要一个方法来返回所有的名字，第二个方法来匹配您用选择器选择的名字，第三个方法来更新您确认的名字的授权消息，假设给出了正确的 PIN 码:

确认代码时，有两种方法保存记录:

还有这个。注意，我们将`auth`字段保存到私有数据库，但是随着协议的改变，我们现在需要将其保存到公共数据库:

为了充分利用我们的新协议，还需要对`contentView.swift`做一点修改。在`pickerView`下，你需要更改/添加这个标签。注意，我们在这里使用了一个更快的弹出窗口:

最后，我们需要再次对目录列表器做一个小小的更改:

以及我们称之为:

你已经准备好接受下一次测试了。将第二个用户添加到您的同名设备中，然后开始使用。

这看起来像是一个更干净的解决方案，但是等等:它有两个主要缺点。

*   一旦您在设备上授权了一个用户，该设备上的所有用户都获得了授权。
*   更糟糕的是，一旦你授权了一个人，你就授权了所有人，因为我们在公共目录中保存了`auth`。

我们要么需要改变公共数据库，使`authorised users`成为`auth`字段下的个人账户列表，要么我们将它保存在设备上。前者听起来不错，这将意味着如果我们改变我们的设备，我们不会失去授权用户，但如果我们改变我们的设备，我们会改变我们的通知签名。让我们重新调整一下，以便在本地保存它。

这两个例程将保存和/或确认我们共享内存的令牌:

我们只需要更改`ContentView.swift`检查并使用保存例程。我注释掉了保存到公共数据库的调用，并在这里添加了新的调用:

再次测试的时间到了，虽然这次您将需要三个真实的设备，因此您创建三个用户，验证一个用户与第二个用户的对话，并检查第三个用户是否仍然需要验证。

还剩下什么？

*   解除账户冻结(您还记得第 4/4 部分)。
*   实现分组。
*   实现更高的安全性(这样您就不会有无数次尝试在各方之间设置通知)。
*   整理图标上出现的徽章，让它们更有意义。
*   清理代码，去掉封存的方法。

# 第十四章

我想用一个摇动的手势来调用一个`restore`方法用于被封锁的账户。在我开始之前，我应该提到这是一个实现的挑战，因为被阻止的设备在三个地方被阻止:在内存中的本地设备上，在内存中的远程设备上，以及在其他用户的私有数据库中的远程设备上。

这个例程拾取摇动动作。你需要把它添加到你的`ContentView.swift`文件的末尾。这是最简单的部分:

仍然在`ContentView.swift`中工作，当被`togglePublisher`触发时，这段代码会引出一个新的分支。这将列出被阻止的帐户:

`togglePublisher`本身就是在这里触发的。我注释掉了一些我们还没有实现的方法。

```
Text("WotsApp")
.onReceive(togglePublisher) { (_) in
self.display4 = !self.display4
self.display5 = !self.display5
}
```

将这些方法添加到项目中，编译并运行。根据您的设置，它可能工作，也可能不工作。这里有一个微妙的错误。被封锁的帐户数据保存在被封锁者的私人数据库中。如果你已经在所有登录到同一个苹果 ID 的设备上运行了这个，它会工作。但是，如果你一直在登录到单独帐户的设备上运行这一功能——这是应该的——它将不起作用，因为`blocked`标签保存在被阻止的个人的私人数据库中。

当然，你不记得了，但我们需要这样做，因为我们需要阻止消息从源头发出。

还有另一个问题。如果甲方屏蔽了乙方，我们就没事了…但只是在乙方重新安装应用程序并获得新的令牌值之前。

不过，一步一步来。我们正在寻找解除封锁的解决方案。要做到这一点，两个用户需要同时在线并运行应用程序。我们继续。

编辑`RemoteNotifications.swift`并添加一个`unblockMessage`方法。这将是我们在前面章节中讨论过的背景通知之一:

现在编辑你的`appDelegate`并进行修改。这里，我们正在清除本地内存和私有数据库:

```
if request == "unblock" {
cloud.searchNReturn(device!, action: "unblock")
cloud.saveUnblockedTokenToSharedmemory(token2U: device!)
}
```

现在您需要编辑`Storage.swift`中的方法并添加一个新动作:

并将此方法(由新操作触发的方法)添加到同一个文件中:

当然，您将需要将未阻止的令牌保存回内存的方法:

你应该准备好再做一次测试。使用 CloudKit dashboard 清理您的数据库，并向两个不同的设备添加一些新帐户。现在从一个向另一个发送通知。如果你确信一切都还正常，试着屏蔽彼此之间的信息。检查它们是否被阻止。重新启动一切，摇一摇其中一个设备。取消阻止该帐户，然后尝试再次发送邮件。您可能需要搜索该名称，因为当您重新启动时它不会显示。

还有一个与多个用户相关的错误:如果你屏蔽了一个用户，它就会屏蔽该设备上的所有人。

# 结论

我们需要再休息一下，透透气。看似简单的应用程序已经变成了一个巨大的工程，出现的障碍几乎和我们修复它们一样快。我必须承认，我担心我在旅途中错过了什么，让你孤立无援。如果是这样的话，请告诉我，我会尽力救你的。

在第 10 章，我说我们已经到达了终点，但我随后认为我掉了太多球。我们已经解决了几乎所有的问题，我想现在我真的需要结束这个系列了。谢谢你陪我一起探索。我希望你喜欢阅读这个系列，就像我喜欢写它一样，并且确实在这个过程中学到了一些新东西。