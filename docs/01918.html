<html>
<head>
<title>Part 1 — Getting Started with RxJava</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">第1部分RxJava入门</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/part-1-getting-started-with-rxjava-ed9fa4e3d2ad?source=collection_archive---------6-----------------------#2019-10-22">https://betterprogramming.pub/part-1-getting-started-with-rxjava-ed9fa4e3d2ad?source=collection_archive---------6-----------------------#2019-10-22</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><h2 id="1529" class="ir is it bd b dl iu iv iw ix iy iz dk ja translated" aria-label="kicker paragraph"># 100日代码的第34天</h2><div class=""/><div class=""><h2 id="250a" class="pw-subtitle-paragraph jz jc it bd b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq dk translated">学习RxJava应该不难</h2></div><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi kr"><img src="../Images/e1c153582291aa4244782d13f7485148.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*xD5fgGHUhvHlUTasvnJdnw.jpeg"/></div></div></figure><figure class="ks kt ku kv gt kw"><div class="bz fp l di"><div class="ld le l"/></div></figure><p id="f73a" class="pw-post-body-paragraph lf lg it lh b li lj kd lk ll lm kg ln lo lp lq lr ls lt lu lv lw lx ly lz ma im bi translated">2019年，我终于在搭建AR apps的时候碰到了一些场景。我从各种渠道获得的大多数支持都使用这种编写代码的模式，因此我必须学习RxJava。</p><p id="53e7" class="pw-post-body-paragraph lf lg it lh b li lj kd lk ll lm kg ln lo lp lq lr ls lt lu lv lw lx ly lz ma im bi translated">浏览网上无穷无尽的资源让我很难学习。我讲这个故事是为了让你更容易理解。</p><p id="7dd6" class="pw-post-body-paragraph lf lg it lh b li lj kd lk ll lm kg ln lo lp lq lr ls lt lu lv lw lx ly lz ma im bi translated">RxJava不是一种不同的编程语言。这只是一种编写代码的方式，使你的程序以函数的方式运行。它不是功能代码，但它以那种方式运行。RxJava还有许多其他很酷的方式来帮助你编写干净、易读的代码——因为它来自函数式编程的世界。</p></div><div class="ab cl mb mc hx md" role="separator"><span class="me bw bk mf mg mh"/><span class="me bw bk mf mg mh"/><span class="me bw bk mf mg"/></div><div class="im in io ip iq"><h1 id="aec5" class="mi mj it bd mk ml mm mn mo mp mq mr ms ki mt kj mu kl mv km mw ko mx kp my mz bi translated">入门指南</h1><h2 id="8f74" class="na mj it bd mk nb nc dn mo nd ne dp ms lo nf ng mu ls nh ni mw lw nj nk my iz bi translated">导入依赖关系</h2><ul class=""><li id="4498" class="nl nm it lh b li nn ll no lo np ls nq lw nr ma ns nt nu nv bi translated">将RxJava相关的依赖项导入到项目中。会有<a class="ae nw" href="https://github.com/ReactiveX/RxAndroid" rel="noopener ugc nofollow" target="_blank"> RxAndroid </a>和<a class="ae nw" href="https://github.com/ReactiveX/RxJava" rel="noopener ugc nofollow" target="_blank"> RxJava </a>。您需要将两者都导入到您的项目中。</li></ul><h2 id="554d" class="na mj it bd mk nb nc dn mo nd ne dp ms lo nf ng mu ls nh ni mw lw nj nk my iz bi translated">RxJava的重要概念</h2><p id="1330" class="pw-post-body-paragraph lf lg it lh b li nn kd lk ll no kg ln lo nx lq lr ls ny lu lv lw nz ly lz ma im bi translated">让我们详细了解其中的每一项，以帮助您轻松应对未来的挑战。</p><p id="e858" class="pw-post-body-paragraph lf lg it lh b li lj kd lk ll lm kg ln lo lp lq lr ls lt lu lv lw lx ly lz ma im bi translated"><strong class="lh jd"> 1。可观察的</strong></p><p id="b2a3" class="pw-post-body-paragraph lf lg it lh b li lj kd lk ll lm kg ln lo lp lq lr ls lt lu lv lw lx ly lz ma im bi translated">现在你正在阅读这个媒介故事。你知道你会从中获得一些重要的东西——因此我可以说你正在<em class="oa">观察</em>它。在这个糟糕的例子中，我的故事变成了一个<em class="oa">可观察。在你的程序中，可能会有一些你想观察的物体。这些物体被称为可观测量。</em></p><p id="75e6" class="pw-post-body-paragraph lf lg it lh b li lj kd lk ll lm kg ln lo lp lq lr ls lt lu lv lw lx ly lz ma im bi translated"><strong class="lh jd"> 2。观察员</strong></p><p id="5608" class="pw-post-body-paragraph lf lg it lh b li lj kd lk ll lm kg ln lo lp lq lr ls lt lu lv lw lx ly lz ma im bi translated">如果你还在读，你们这些可爱的人就是观察者，即使在所有这些坏例子之后，他们仍然在观察我的故事。因此，如果没有人阅读这个故事，我写这个故事就毫无意义。因此，如果没有观察者，拥有可观察的物体就没有任何意义。</p><p id="2144" class="pw-post-body-paragraph lf lg it lh b li lj kd lk ll lm kg ln lo lp lq lr ls lt lu lv lw lx ly lz ma im bi translated"><strong class="lh jd"> 3。调度程序</strong></p><p id="c2c8" class="pw-post-body-paragraph lf lg it lh b li lj kd lk ll lm kg ln lo lp lq lr ls lt lu lv lw lx ly lz ma im bi translated">我们都知道管理线程和并发对我们所有人来说都是一件痛苦的事情。RxJava通过在<em class="oa">调度器的帮助下抽象出许多痛苦来帮助我们。</em>所以你不必使用线程池和执行器，RxJava会帮你处理的。</p><p id="5568" class="pw-post-body-paragraph lf lg it lh b li lj kd lk ll lm kg ln lo lp lq lr ls lt lu lv lw lx ly lz ma im bi translated"><strong class="lh jd"> 4。订阅</strong></p><p id="6ec1" class="pw-post-body-paragraph lf lg it lh b li lj kd lk ll lm kg ln lo lp lq lr ls lt lu lv lw lx ly lz ma im bi translated">最终，结果将被称为<em class="oa">订阅。</em>为什么我们要分开订阅？这样，当我们不再需要来自观察者的结果时，我们可以取消订阅。这是避免内存泄漏的一个非常简洁的方法。</p><h2 id="8951" class="na mj it bd mk nb nc dn mo nd ne dp ms lo nf ng mu ls nh ni mw lw nj nk my iz bi translated"><strong class="ak"> <em class="ob">我们在RxJava编程中遵循的一个常见模式是:</em> </strong></h2><ul class=""><li id="d09e" class="nl nm it lh b li nn ll no lo np ls nq lw nr ma ns nt nu nv bi translated">创造一个可观察的</li><li id="34cb" class="nl nm it lh b li oc ll od lo oe ls of lw og ma ns nt nu nv bi translated">对可观察对象应用算子</li><li id="8b8b" class="nl nm it lh b li oc ll od lo oe ls of lw og ma ns nt nu nv bi translated">指定您想要处理的线程</li><li id="fac0" class="nl nm it lh b li oc ll od lo oe ls of lw og ma ns nt nu nv bi translated">指定要将结果发布到哪个线程</li><li id="43c0" class="nl nm it lh b li oc ll od lo oe ls of lw og ma ns nt nu nv bi translated">考虑如何为观察者订阅可观察的</li></ul></div><div class="ab cl mb mc hx md" role="separator"><span class="me bw bk mf mg mh"/><span class="me bw bk mf mg mh"/><span class="me bw bk mf mg"/></div><div class="im in io ip iq"><h1 id="8bb3" class="mi mj it bd mk ml mm mn mo mp mq mr ms ki mt kj mu kl mv km mw ko mx kp my mz bi translated">说够了——让我们编码吧！</h1><ol class=""><li id="909d" class="nl nm it lh b li nn ll no lo np ls nq lw nr ma oh nt nu nv bi translated">让我们创建一个<code class="fe oi oj ok ol b">Task</code>数据类。</li></ol><figure class="ks kt ku kv gt kw"><div class="bz fp l di"><div class="om le l"/></div></figure><p id="2d8e" class="pw-post-body-paragraph lf lg it lh b li lj kd lk ll lm kg ln lo lp lq lr ls lt lu lv lw lx ly lz ma im bi translated">2.创建一个<code class="fe oi oj ok ol b">DataRepository</code>类。这个类将为我们提供任务对象列表。</p><figure class="ks kt ku kv gt kw"><div class="bz fp l di"><div class="om le l"/></div></figure><p id="7a7e" class="pw-post-body-paragraph lf lg it lh b li lj kd lk ll lm kg ln lo lp lq lr ls lt lu lv lw lx ly lz ma im bi translated">3.创建一个带有无限进度条的UI。我们将使用它来查看我们的用户界面是否在任何时间点冻结。</p><figure class="ks kt ku kv gt kw"><div class="bz fp l di"><div class="om le l"/></div></figure><p id="7a7c" class="pw-post-body-paragraph lf lg it lh b li lj kd lk ll lm kg ln lo lp lq lr ls lt lu lv lw lx ly lz ma im bi translated">4.在<code class="fe oi oj ok ol b">MainActivity</code>中，让我们获取任务列表，并使用RxJava将它们记录到控制台。</p><figure class="ks kt ku kv gt kw"><div class="bz fp l di"><div class="om le l"/></div></figure><p id="0bba" class="pw-post-body-paragraph lf lg it lh b li lj kd lk ll lm kg ln lo lp lq lr ls lt lu lv lw lx ly lz ma im bi translated">这里是<code class="fe oi oj ok ol b">logcat</code>输出。观察RxJava代码的生命周期。</p><pre class="ks kt ku kv gt on ol oo op aw oq bi"><span id="3740" class="na mj it ol b gy or os l ot ou">Subscribed<br/>Task 1 processed, moving on to the next one<br/>Task 2 processed, moving on to the next one<br/>Task 3 processed, moving on to the next one<br/>Task 4 processed, moving on to the next one<br/>Task 5 processed, moving on to the next one<br/>Task 6 processed, moving on to the next one<br/>Task 7 processed, moving on to the next one<br/>Task 8 processed, moving on to the next one<br/>Task 9 processed, moving on to the next one<br/>Task 10 processed, moving on to the next one<br/>Got the whole data from the data source</span></pre><p id="4502" class="pw-post-body-paragraph lf lg it lh b li lj kd lk ll lm kg ln lo lp lq lr ls lt lu lv lw lx ly lz ma im bi translated">5.让我们稍微修改一下我们的任务observable。请注意，我们添加了一个过滤操作符。</p><figure class="ks kt ku kv gt kw"><div class="bz fp l di"><div class="om le l"/></div></figure><p id="cfba" class="pw-post-body-paragraph lf lg it lh b li lj kd lk ll lm kg ln lo lp lq lr ls lt lu lv lw lx ly lz ma im bi translated">我们的UI不会在这里冻结。这项工作在后台线程中完成，我们在主线程上观察，<code class="fe oi oj ok ol b">.subscribe()</code>在主线程上工作并发布更新。</p><p id="ddcf" class="pw-post-body-paragraph lf lg it lh b li lj kd lk ll lm kg ln lo lp lq lr ls lt lu lv lw lx ly lz ma im bi translated">如果你做到了这些，你就太棒了。</p></div><div class="ab cl mb mc hx md" role="separator"><span class="me bw bk mf mg mh"/><span class="me bw bk mf mg mh"/><span class="me bw bk mf mg"/></div><div class="im in io ip iq"><p id="4d13" class="pw-post-body-paragraph lf lg it lh b li lj kd lk ll lm kg ln lo lp lq lr ls lt lu lv lw lx ly lz ma im bi translated">感谢阅读。请继续关注RxJava上的未来系列。</p></div></div>    
</body>
</html>