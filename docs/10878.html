<html>
<head>
<title>Beating Wordle: Constraint Programming</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">击败Wordle:约束编程</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/beating-wordle-constraint-programming-ef0b0b6897fe?source=collection_archive---------16-----------------------#2022-02-01">https://betterprogramming.pub/beating-wordle-constraint-programming-ef0b0b6897fe?source=collection_archive---------16-----------------------#2022-02-01</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="92cb" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">获取数据集，预处理，定义约束变量，让Wordle求解器完成它的工作</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/02bd7813be9e4bd256730ce916911110.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*pEPimtkcOdvjPuaI"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">斯文·布兰德斯马在<a class="ae kv" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的照片</p></figure><blockquote class="kw"><p id="7630" class="kx ky iq bd kz la lb lc ld le lf lg dk translated">TL；博士，开始你的世界最好的两个词是“孤独”和“衬衫”。</p></blockquote><p id="3869" class="pw-post-body-paragraph lh li iq lj b lk ll jr lm ln lo ju lp lq lr ls lt lu lv lw lx ly lz ma mb lg ij bi translated">当我看到Wordle(1月31日星期一)时，我想哎呀，约束编程在解决这个问题上不是很棒吗？在做餐巾纸背面的数学时，如果我们有500个单词可供选择，我们想找出最好的两个单词，我们需要在最坏的情况下进行62亿次比较。我们将把它提高几个档次，设定2000字的目标:)</p><p id="d74c" class="pw-post-body-paragraph lh li iq lj b lk mc jr lm ln md ju lp lq me ls lt lu mf lw lx ly mg ma mb lg ij bi translated">数学，如果有人感兴趣的话。我可能是错的，但我在假设最坏的情况:</p><pre class="kg kh ki kj gt mh mi mj mk aw ml bi"><span id="d7e0" class="mm mn iq mi b gy mo mp l mq mr">1st word: 500 possibilities</span><span id="5f85" class="mm mn iq mi b gy ms mp l mq mr">2nd word: 499 possibilities</span><span id="96d8" class="mm mn iq mi b gy ms mp l mq mr">Then we will need to check how each of these words compares to all the other words 498 and each word contains 5 letters so we would need to compare all 2words each with 5 letters to those 5 letters.</span><span id="e938" class="mm mn iq mi b gy ms mp l mq mr">Thus: 500*499*498*2*5*5=~6.2 billion Operations</span></pre><p id="7879" class="pw-post-body-paragraph lh li iq lj b lk mc jr lm ln md ju lp lq me ls lt lu mf lw lx ly mg ma mb lg ij bi translated">约束编程来拯救！对于那些不熟悉约束编程的人，我将使用Google的话:</p><blockquote class="mt mu mv"><p id="7d91" class="lh li mw lj b lk mc jr lm ln md ju lp mx me ls lt my mf lw lx mz mg ma mb lg ij bi translated">约束优化，或约束规划(CP)，是从一个非常大的候选集合中识别可行解的名称，其中问题可以根据任意约束来建模。CP问题出现在许多科学和工程学科中。(“编程”这个词有点用词不当，类似于“计算机”曾经的意思是“计算的人”。这里的“编程”指的是一个计划的安排，而不是用计算机语言编程。)<br/> — <a class="ae kv" href="https://developers.google.com/optimization/cp" rel="noopener ugc nofollow" target="_blank">来源</a></p></blockquote><p id="dc70" class="pw-post-body-paragraph lh li iq lj b lk mc jr lm ln md ju lp lq me ls lt lu mf lw lx ly mg ma mb lg ij bi translated">为了简化约束编程，需要定义问题的参数，并定义这些参数的约束。</p></div><div class="ab cl na nb hu nc" role="separator"><span class="nd bw bk ne nf ng"/><span class="nd bw bk ne nf ng"/><span class="nd bw bk ne nf"/></div><div class="ij ik il im in"><p id="37c1" class="pw-post-body-paragraph lh li iq lj b lk mc jr lm ln md ju lp lq me ls lt lu mf lw lx ly mg ma mb lg ij bi translated">在Wordle中，我们希望挑选出能给我们最大暗示的词，告诉我们目标词是什么。如何找到那些神奇的文字？我们需要遵循以下步骤:</p><ol class=""><li id="40e1" class="nh ni iq lj b lk mc ln md lq nj lu nk ly nl lg nm nn no np bi translated">获取英语单词数据集。</li><li id="f2ea" class="nh ni iq lj b lk nq ln nr lq ns lu nt ly nu lg nm nn no np bi translated">将这些单词预处理成我们想要的大小(5个字母的单词)。</li><li id="ea64" class="nh ni iq lj b lk nq ln nr lq ns lu nt ly nu lg nm nn no np bi translated">将这些单词转换成求解者可以理解的东西。</li><li id="f869" class="nh ni iq lj b lk nq ln nr lq ns lu nt ly nu lg nm nn no np bi translated">定义约束变量。</li><li id="d484" class="nh ni iq lj b lk nq ln nr lq ns lu nt ly nu lg nm nn no np bi translated">选择一种启发式方法来选择最佳单词并创建约束条件。</li><li id="7742" class="nh ni iq lj b lk nq ln nr lq ns lu nt ly nu lg nm nn no np bi translated">运行规划求解并将结果重新转换成文字。</li></ol></div><div class="ab cl na nb hu nc" role="separator"><span class="nd bw bk ne nf ng"/><span class="nd bw bk ne nf ng"/><span class="nd bw bk ne nf"/></div><div class="ij ik il im in"><h1 id="a8f1" class="nv mn iq bd nw nx ny nz oa ob oc od oe jw of jx og jz oh ka oi kc oj kd ok ol bi translated">1.获取英语单词数据集。</h1><p id="d00b" class="pw-post-body-paragraph lh li iq lj b lk om jr lm ln on ju lp lq oo ls lt lu op lw lx ly oq ma mb lg ij bi translated">要打败wordle，我们必须找到一个英语单词列表，幸运的是在搜索了GitHub之后，我找到了这个美丽的单词。</p><p id="6e2b" class="pw-post-body-paragraph lh li iq lj b lk mc jr lm ln md ju lp lq me ls lt lu mf lw lx ly mg ma mb lg ij bi translated">正如回购推荐的那样，我选择了<code class="fe or os ot mi b"><a class="ae kv" href="https://github.com/dwyl/english-words/blob/master/words_alpha.txt" rel="noopener ugc nofollow" target="_blank">words_alpha.txt</a></code>，你可以随意选择自己的。现在我们有了一个英语单词列表，可以进入下一步了。</p><h1 id="4cab" class="nv mn iq bd nw nx ou nz oa ob ov od oe jw ow jx og jz ox ka oi kc oy kd ok ol bi translated">2.将这些单词预处理成我们想要的大小(5个字母的单词)。</h1><p id="0211" class="pw-post-body-paragraph lh li iq lj b lk om jr lm ln on ju lp lq oo ls lt lu op lw lx ly oq ma mb lg ij bi translated">那么现在我们有了一些单词，我们把它们导入到Python中来看看吧。为此，我们可以使用熊猫来读取数据。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="oz pa l"/></div></figure><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi pb"><img src="../Images/905998905e88cb72b0279efaf80b0b58.png" data-original-src="https://miro.medium.com/v2/resize:fit:768/format:webp/1*YYhSlsGa6kFPhCLu0QXuNg.png"/></div></figure><p id="8d7f" class="pw-post-body-paragraph lh li iq lj b lk mc jr lm ln md ju lp lq me ls lt lu mf lw lx ly mg ma mb lg ij bi translated">这很酷，我们可以看到我们有370，103个单词。现在让我们只得到5个字母的单词。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="oz pa l"/></div></figure><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi pb"><img src="../Images/0daccb58175c446a4c3a0b94c55582ea.png" data-original-src="https://miro.medium.com/v2/resize:fit:768/format:webp/1*1L0xFYjOI7aLtYtG2sfl9A.png"/></div></figure><p id="b573" class="pw-post-body-paragraph lh li iq lj b lk mc jr lm ln md ju lp lq me ls lt lu mf lw lx ly mg ma mb lg ij bi translated">耶！我们现在有15918个单词可以玩，其中一些单词我从未听说过，比如<code class="fe or os ot mi b">aalii</code> <strong class="lj ir"> </strong>，意思是“一种浓密的无患子灌木”<strong class="lj ir">。</strong></p><h1 id="1e0f" class="nv mn iq bd nw nx ou nz oa ob ov od oe jw ow jx og jz ox ka oi kc oy kd ok ol bi translated">3.将这些单词转换成求解者可以理解的东西。</h1><p id="01c8" class="pw-post-body-paragraph lh li iq lj b lk om jr lm ln on ju lp lq oo ls lt lu op lw lx ly oq ma mb lg ij bi translated">现在我们有了很多单词，我们需要一种方法让求解者理解。CSP求解器可以理解一些数据类型，如整数和布尔。但是我将使用的求解器不理解字符，所以我们需要将字符转换成他们可以理解的东西。</p><p id="e017" class="pw-post-body-paragraph lh li iq lj b lk mc jr lm ln md ju lp lq me ls lt lu mf lw lx ly mg ma mb lg ij bi translated">我们可以使用<a class="ae kv" href="https://en.wikipedia.org/wiki/One-hot" rel="noopener ugc nofollow" target="_blank">一键编码</a>。或者我们可以保持简单，给每个字母分配一个数字(例如字母a → 0，b → 1 … z → 25)，这就简单多了。让我们开始吧。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="oz pa l"/></div></figure><p id="300a" class="pw-post-body-paragraph lh li iq lj b lk mc jr lm ln md ju lp lq me ls lt lu mf lw lx ly mg ma mb lg ij bi translated">当我们运行这段代码时，我们得到一个名为<code class="fe or os ot mi b">words</code>的变量，它是一个由整数表示的单词列表。例如，<code class="fe or os ot mi b">[0,0,7,4,3]</code>代表“aahed”。</p><h1 id="f56e" class="nv mn iq bd nw nx ou nz oa ob ov od oe jw ow jx og jz ox ka oi kc oy kd ok ol bi translated">4.定义约束变量。</h1><p id="b62b" class="pw-post-body-paragraph lh li iq lj b lk om jr lm ln on ju lp lq oo ls lt lu op lw lx ly oq ma mb lg ij bi translated">现在我们需要进入杂草中一点。我们想为约束求解器定义一些变量来理解。我们将要使用的约束求解器叫做<a class="ae kv" href="http://fmv.jku.at/cadical/" rel="noopener ugc nofollow" target="_blank">Cadical</a>——它是最先进的求解器之一。</p><p id="b185" class="pw-post-body-paragraph lh li iq lj b lk mc jr lm ln md ju lp lq me ls lt lu mf lw lx ly mg ma mb lg ij bi translated">为Cadical编写代码实际上需要很长时间，因此我们将使用一个名为<a class="ae kv" href="https://savilerow.cs.st-andrews.ac.uk/" rel="noopener ugc nofollow" target="_blank"> SavileRow </a>的抽象，它运行在Essence Prime语言上，然后可以将我们的代码翻译成Cadical，Cadical随后可以求解。</p><p id="c31f" class="pw-post-body-paragraph lh li iq lj b lk mc jr lm ln md ju lp lq me ls lt lu mf lw lx ly mg ma mb lg ij bi translated">首先，我们需要告诉萨维罗我们的参数是什么。为了提高效率，我们可以编写一个Python函数，它将接受<code class="fe or os ot mi b">words</code>变量，并输出一个【SavileRow可以理解的文件。</p><p id="64a9" class="pw-post-body-paragraph lh li iq lj b lk mc jr lm ln md ju lp lq me ls lt lu mf lw lx ly mg ma mb lg ij bi translated">在这个函数中，我们将单词数、单词的字母数以及我们希望求解器为我们选择的单词数传递给SavileRow。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="oz pa l"/></div></figure><p id="9fed" class="pw-post-body-paragraph lh li iq lj b lk mc jr lm ln md ju lp lq me ls lt lu mf lw lx ly mg ma mb lg ij bi translated">正如我们在本文开头所承诺的，我们将比较2000个单词。所以让我们将<code class="fe or os ot mi b">words</code>随机化，这样当我们将它传递给函数时，它有一个以不同字符开头的单词混合。</p><pre class="kg kh ki kj gt mh mi mj mk aw ml bi"><span id="593e" class="mm mn iq mi b gy mo mp l mq mr">random.shuffle(words)</span></pre><p id="aabb" class="pw-post-body-paragraph lh li iq lj b lk mc jr lm ln md ju lp lq me ls lt lu mf lw lx ly mg ma mb lg ij bi translated">我们现在可以将<code class="fe or os ot mi b">words</code>传递到函数中。我们得到这个参数文件:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="oz pa l"/></div></figure><h1 id="054a" class="nv mn iq bd nw nx ou nz oa ob ov od oe jw ow jx og jz ox ka oi kc oy kd ok ol bi translated">5.选择一种启发式方法来选择最佳单词并创建约束条件。</h1><p id="71f2" class="pw-post-body-paragraph lh li iq lj b lk om jr lm ln on ju lp lq oo ls lt lu op lw lx ly oq ma mb lg ij bi translated">为了让求解者选择最好的单词，我们需要告诉求解者要找什么。我们可以通过<code class="fe or os ot mi b">find</code>命令告诉求解器要找什么。在这种情况下，我们希望找到最佳单词的索引，这些索引具有查找单词的最佳特征。我们可以称这个数组为<code class="fe or os ot mi b">best_words</code></p><p id="2773" class="pw-post-body-paragraph lh li iq lj b lk mc jr lm ln md ju lp lq me ls lt lu mf lw lx ly mg ma mb lg ij bi translated"><code class="fe or os ot mi b">heuristic</code>是约束编程中最重要的，这是我们试图优化的。这里我们试图优化两个词覆盖目标词的可能性。实际上，我们想要计算每隔一个字母中这两个单词字母出现的次数。我们可以称之为变量<code class="fe or os ot mi b">cost</code>，我们可以告诉求解器<code class="fe or os ot mi b">maximise</code>这一点。</p><p id="02c1" class="pw-post-body-paragraph lh li iq lj b lk mc jr lm ln md ju lp lq me ls lt lu mf lw lx ly mg ma mb lg ij bi translated">至于约束，我们希望确保求解器选择的所有单词都是不同的，我们可以使用<code class="fe or os ot mi b">AllDiff</code>约束来实现这一点。我们还希望确保求解器不会两次得出相同的解，例如，如果选择的索引是:[1，3]，则[3，1]是相同的解，只是顺序不同。我们可以通过约束较大的索引总是在最前面来强制排序。</p><p id="a878" class="pw-post-body-paragraph lh li iq lj b lk mc jr lm ln md ju lp lq me ls lt lu mf lw lx ly mg ma mb lg ij bi translated">有了所有这些，我们可以创建一个SalvileRow模型:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="oz pa l"/></div></figure><h1 id="9a9b" class="nv mn iq bd nw nx ou nz oa ob ov od oe jw ow jx og jz ox ka oi kc oy kd ok ol bi translated">7.运行规划求解并将结果重新转换成文字。</h1><p id="dd27" class="pw-post-body-paragraph lh li iq lj b lk om jr lm ln on ju lp lq oo ls lt lu op lw lx ly oq ma mb lg ij bi translated">使用以下命令运行求解程序后:</p><pre class="kg kh ki kj gt mh mi mj mk aw ml bi"><span id="46c2" class="mm mn iq mi b gy mo mp l mq mr">savilerow words.eprime words.param -run-solver -sat</span></pre><p id="60a7" class="pw-post-body-paragraph lh li iq lj b lk mc jr lm ln md ju lp lq me ls lt lu mf lw lx ly mg ma mb lg ij bi translated">我们得到一个输出<code class="fe or os ot mi b">[414, 129]</code>，这些是在启发式搜索中得分最高的单词的索引。如果我们接着查找这些单词，我们得到<code class="fe or os ot mi b">[11, 0, 20, 13, 3]</code>和<code class="fe or os ot mi b">[14, 18, 8, 4, 17]</code>，当翻译回字符时，我们得到‘laund’和‘osier’</p><h1 id="9304" class="nv mn iq bd nw nx ou nz oa ob ov od oe jw ow jx og jz ox ka oi kc oy kd ok ol bi translated">L̶i̶m̶i̶t̶a̶t̶i̶o̶n̶s̶</h1><p id="6414" class="pw-post-body-paragraph lh li iq lj b lk om jr lm ln on ju lp lq oo ls lt lu op lw lx ly oq ma mb lg ij bi translated">̶s̶o̶m̶e̶̶o̶f̶̶t̶h̶e̶̶w̶o̶r̶d̶s̶̶i̶n̶̶t̶h̶e̶̶w̶o̶r̶d̶s̶_̶a̶l̶p̶h̶a̶.̶t̶x̶t̶̶d̶o̶̶n̶o̶t̶̶a̶p̶p̶e̶a̶r̶̶t̶o̶̶b̶e̶̶c̶o̶m̶p̶a̶t̶i̶b̶l̶e̶̶w̶i̶t̶h̶̶w̶o̶r̶d̶l̶e̶,̶̶s̶o̶̶i̶t̶̶m̶a̶y̶̶n̶o̶t̶̶b̶e̶̶a̶c̶c̶u̶r̶a̶t̶e̶̶f̶o̶r̶̶w̶o̶r̶d̶l̶e̶.̶̶i̶f̶̶a̶̶d̶a̶t̶a̶s̶e̶t̶̶o̶f̶̶w̶o̶r̶d̶l̶e̶̶w̶o̶r̶d̶s̶̶t̶h̶a̶t̶̶a̶r̶e̶̶u̶s̶e̶d̶̶i̶s̶̶e̶v̶e̶r̶̶r̶e̶l̶e̶a̶s̶e̶d̶̶t̶h̶e̶n̶̶a̶n̶̶a̶c̶c̶u̶r̶a̶t̶e̶̶a̶n̶s̶w̶e̶r̶̶c̶a̶n̶̶b̶e̶̶r̶e̶a̶c̶h̶e̶d̶̶o̶n̶̶w̶h̶i̶c̶h̶̶w̶o̶r̶d̶s̶̶a̶r̶e̶̶b̶e̶s̶t̶̶f̶o̶r̶̶w̶o̶r̶d̶l̶e̶.̶</p></div><div class="ab cl na nb hu nc" role="separator"><span class="nd bw bk ne nf ng"/><span class="nd bw bk ne nf ng"/><span class="nd bw bk ne nf"/></div><div class="ij ik il im in"><h1 id="7938" class="nv mn iq bd nw nx ny nz oa ob oc od oe jw of jx og jz oh ka oi kc oj kd ok ol bi translated">更新</h1><p id="08d9" class="pw-post-body-paragraph lh li iq lj b lk om jr lm ln on ju lp lq oo ls lt lu op lw lx ly oq ma mb lg ij bi translated">我发现了一个更好的单词表，你可以从牛津词典中提取。</p><p id="39bd" class="pw-post-body-paragraph lh li iq lj b lk mc jr lm ln md ju lp lq me ls lt lu mf lw lx ly mg ma mb lg ij bi translated">我执行了与上面相同的步骤，并想出了两个更有可能出现在Wordle中的单词，分别是“孤独”和“衬衫”。</p></div></div>    
</body>
</html>