<html>
<head>
<title>How To Build a Reverse Proxy With Express</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何用Express构建反向代理</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/how-to-build-a-reverse-proxy-with-express-87a31ec2ec80?source=collection_archive---------0-----------------------#2019-08-06">https://betterprogramming.pub/how-to-build-a-reverse-proxy-with-express-87a31ec2ec80?source=collection_archive---------0-----------------------#2019-08-06</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="217c" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">一种快速简单的构建API网关的方法</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/2649506b389b7738201d2eca1ca54efb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*-Nq1fQSPq9aeoWxn4WFbhg.png"/></div></div></figure><p id="932d" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">如果您的分布式系统使用微服务架构，那么就需要一个API网关。构建API网关的一个好方法是使用反向代理。Node.js 是一个很好的反向代理，因为它很快，并且有很多库可以用来做反向代理。</p><p id="2013" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">Express是构建web应用程序最流行的框架。这对于构建反向代理来说也是非常好的，因为有附加组件来表示可以为反向代理进行路由。</p><p id="bb7c" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">设计将非常简单。它只会根据请求的URL将流量重定向到我们不同的后端应用程序。此外，除了请求有效负载之外，它还必须能够将头数据、文件和cookies传递到我们的服务中。</p><p id="87ee" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">为了做到这一切，我们首先按照<a class="ae lq" href="https://expressjs.com/en/starter/generator.html" rel="noopener ugc nofollow" target="_blank">https://expressjs.com/en/starter/generator.html</a>的说明运行快速应用生成器来搭建我们的应用</p><p id="f116" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">我们必须运行<code class="fe lr ls lt lu b">npx express-generator</code>来生成我们需要的代码。</p><p id="23d2" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">我建议使用<code class="fe lr ls lt lu b">nodemon</code>在开发环境中运行我们的应用程序，这样每当我们的代码改变时，它就会重新启动。</p><p id="64c7" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">接下来，我们必须安装一些软件包来完成反向代理功能，并启用CORS，以便前端应用程序可以使用反向代理。为此，运行<code class="fe lr ls lt lu b">npm i express-http-proxy glob node-env-file cookie-parser babel-register body-parser</code>。</p><p id="1fb6" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated"><code class="fe lr ls lt lu b">express-http-proxy</code>是HTTP反向代理库。<code class="fe lr ls lt lu b">cors</code>是支持CORS的Express的附加组件。<code class="fe lr ls lt lu b">cookie-parser</code>是一个允许Express解析cookies的插件。<code class="fe lr ls lt lu b">babel-register</code>允许我们使用最新的JavaScript特性。<code class="fe lr ls lt lu b">node-env-file</code>允许我们使用<code class="fe lr ls lt lu b">.env</code>文件存储环境变量。<code class="fe lr ls lt lu b">body-parser</code>将用于检查多部分请求。多部分请求是包含文件的请求。带有文件的请求在重定向前不会通过<code class="fe lr ls lt lu b">body-parser</code>。</p><p id="f165" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">现在我们准备写代码了。我们在自己创建的<code class="fe lr ls lt lu b">helpers</code>文件夹中创建一个名为<code class="fe lr ls lt lu b">helper.js</code>的新文件。</p><p id="139c" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">在那里，我们添加:</p><pre class="kj kk kl km gt lv lu lw lx aw ly bi"><span id="0a4f" class="lz ma it lu b gy mb mc l md me">module.exports = {<br/>    isMultipartRequest: (req) =&gt; {<br/>        let contentTypeHeader = req.headers['content-type'];<br/>        return contentTypeHeader &amp;&amp; contentTypeHeader.indexOf('multipart') &gt; -1;<br/>    }<br/>}</span></pre><p id="235a" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">该函数检查多部分请求，即作为表单数据发送的请求。它可以包括文本或文件。</p><p id="3ac1" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">在<code class="fe lr ls lt lu b">app.js</code>中，我们写道:</p><pre class="kj kk kl km gt lv lu lw lx aw ly bi"><span id="a2e8" class="lz ma it lu b gy mb mc l md me">require("babel-register");<br/>let express = require('express');<br/>let cors = require('cors')<br/>let config = require('./config/config');<br/>let env = require('node-env-file');<br/>let helpers = require('./app/helpers/helpers');<br/>let bodyParser = require('body-parser');<br/>env(__dirname + '/.env');</span><span id="1c1f" class="lz ma it lu b gy mf mc l md me">let app = express();</span><span id="13cd" class="lz ma it lu b gy mf mc l md me">app.use(cors({<br/>  credentials: true,<br/>  origin: true<br/>}));</span><span id="ac4f" class="lz ma it lu b gy mf mc l md me">const bodyParserJsonMiddleware = function () {<br/>  return function (req, res, next) {<br/>    if (helpers.isMultipartRequest(req)) {<br/>      return next();<br/>    }<br/>    return bodyParser.json()(req, res, next);<br/>  };<br/>};</span><span id="d3fc" class="lz ma it lu b gy mf mc l md me">app.use(bodyParserJsonMiddleware());</span><span id="61ae" class="lz ma it lu b gy mf mc l md me">app.all('*', (req, res, next) =&gt; {<br/>  let origin = req.get('origin');<br/>  res.header('Access-Control-Allow-Origin', origin);<br/>  res.header("Access-Control-Allow-Headers", "X-Requested-With");<br/>  res.header('Access-Control-Allow-Headers', 'Content-Type');<br/>  next();<br/>});</span><span id="9598" class="lz ma it lu b gy mf mc l md me">module.exports = require('./config/express')(app, config);</span><span id="9e44" class="lz ma it lu b gy mf mc l md me">app.listen(config.port, () =&gt; {<br/>  console.log('Express server listening on port ' + config.port);<br/>});</span></pre><p id="15f7" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">该代码通过传递服务器端cookies来工作，并允许多方请求不通过<code class="fe lr ls lt lu b">body-parser</code>，因为它不是JSON。</p><p id="7605" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">此外，我们允许CORS在下面的块中:</p><pre class="kj kk kl km gt lv lu lw lx aw ly bi"><span id="7e37" class="lz ma it lu b gy mb mc l md me">app.all('*', (req, res, next) =&gt; {<br/>  let origin = req.get('origin');<br/>  res.header('Access-Control-Allow-Origin', origin);<br/>  res.header("Access-Control-Allow-Headers", "X-Requested-With");<br/>  res.header('Access-Control-Allow-Headers', 'Content-Type');<br/>  next();<br/>});</span></pre><p id="0bef" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">它允许接受来自所有来源的请求。默认情况下，只接受来自与后端相同的主机的请求，因为允许来自其他主机的请求是不安全的。然而，如果我们允许移动和独立的前端web应用程序通过我们的反向代理发出请求，我们必须允许所有来源。它从标头中获取来源，并允许来自该来源的请求继续进行。</p><p id="15b8" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">然后我们在<code class="fe lr ls lt lu b">controllers/home.js</code>中添加代理请求的代码:</p><pre class="kj kk kl km gt lv lu lw lx aw ly bi"><span id="1078" class="lz ma it lu b gy mb mc l md me">const express = require('express');<br/>let proxy = require("express-http-proxy");<br/>let helpers = require('../helpers/helpers');</span><span id="6f4a" class="lz ma it lu b gy mf mc l md me">let loginAppRoutes = [<br/>  '/login*',<br/>  '/loginms',<br/>  '/register',<br/>  '/resetPassword',<br/>  '/getActivationKey*',<br/>  '/activateAccount',<br/>  '/logout',<br/>  '/reports',<br/>  '/'<br/>]</span><span id="61fe" class="lz ma it lu b gy mf mc l md me">let uploadRoutes = [<br/>  '/uploadlogo*',<br/>]</span><span id="bc61" class="lz ma it lu b gy mf mc l md me">module.exports = (app) =&gt; {<br/>  const proxyMiddleware = () =&gt; {<br/>    return (req, res, next) =&gt; {<br/>      let reqAsBuffer = false;<br/>      let reqBodyEncoding = true;<br/>      let contentTypeHeader = req.headers['content-type'];<br/>      if (helpers.isMultipartRequest(req)) {<br/>        reqAsBuffer = true;<br/>        reqBodyEncoding = null;<br/>      }<br/>      return proxy(process.env.UPLOAD_URL, {<br/>        reqAsBuffer: reqAsBuffer,<br/>        reqBodyEncoding: reqBodyEncoding,<br/>        parseReqBody: false,<br/>        proxyReqOptDecorator: (proxyReq) =&gt; {<br/>          return proxyReq;<br/>        },</span><span id="b565" class="lz ma it lu b gy mf mc l md me">  proxyReqPathResolver: (req) =&gt; {<br/>          return `${process.env.UPLOAD_APP_URL}/${req.baseUrl}${req.url.slice(1)}`;<br/>        },</span><span id="9b48" class="lz ma it lu b gy mf mc l md me">  userResDecorator: (rsp, data, req, res) =&gt; {<br/>          res.set('Access-Control-Allow-Origin', req.headers.origin);<br/>          return data.toString('utf-8');<br/>        }<br/>      })(req, res, next);<br/>    };<br/>  }</span><span id="4349" class="lz ma it lu b gy mf mc l md me">  uploadRoutes.forEach(r =&gt; {<br/>    app.use(r, proxyMiddleware());<br/>  })</span><span id="cf39" class="lz ma it lu b gy mf mc l md me">  loginAppRoutes.forEach(r =&gt; {<br/>    app.use(r, proxy(process.env.LOGIN_URL, {<br/>      proxyReqOptDecorator: (proxyReq) =&gt; {<br/>        return proxyReq;<br/>      },</span><span id="d88b" class="lz ma it lu b gy mf mc l md me">proxyReqPathResolver: (req) =&gt; {<br/>        return `${process.env.LOGIN_URL}/${req.baseUrl}${req.url.slice(1)}`;<br/>      },</span><span id="2a79" class="lz ma it lu b gy mf mc l md me">  userResDecorator: (rsp, data, req, res) =&gt; {<br/>        res.set('Access-Control-Allow-Origin', req.headers.origin);<br/>        return data.toString('utf-8');<br/>      }<br/>    }));<br/>  })<br/>};</span></pre><p id="1487" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">我们通过以下方式检查多部分表单请求:</p><pre class="kj kk kl km gt lv lu lw lx aw ly bi"><span id="aeed" class="lz ma it lu b gy mb mc l md me">if (helpers.isMultipartRequest(req)) {<br/>  reqAsBuffer = true;<br/>  reqBodyEncoding = null;<br/>}</span></pre><p id="aad3" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">会将带有文件的请求直接传递给我们的内部API。</p><p id="f1bf" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">以下内容:</p><pre class="kj kk kl km gt lv lu lw lx aw ly bi"><span id="40a5" class="lz ma it lu b gy mb mc l md me">proxyReqPathResolver: (req) =&gt; {<br/>  return `${process.env.LOGIN_URL}/${req.baseUrl}${req.url.slice(1)}`;<br/>},</span></pre><p id="09e3" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">是设置从代理到内部API的实际重定向URL的地方。注意，<code class="fe lr ls lt lu b">parseReqBody</code>是<code class="fe lr ls lt lu b">false</code>，所以多部分表单请求不会被解析为JSON。</p><p id="1704" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated"><code class="fe lr ls lt lu b">process.env</code>变量设置在<code class="fe lr ls lt lu b">.env</code>文件中。</p><p id="18a6" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">在<code class="fe lr ls lt lu b">.env</code>文件中，我们有:</p><pre class="kj kk kl km gt lv lu lw lx aw ly bi"><span id="67b9" class="lz ma it lu b gy mb mc l md me">LOGIN_URL='http://urlForYourLoginApp'<br/>UPLOAD_URL='http://anotherUrlForYourUploadApp'</span></pre><p id="9ffe" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">借助反向代理插件，Express是在Node中构建反向代理的最佳选择之一。</p><p id="c484" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated"><strong class="kw iu">在推特上关注我:</strong><a class="ae lq" href="https://twitter.com/AuMayeung" rel="noopener ugc nofollow" target="_blank"><strong class="kw iu">https://twitter.com/AuMayeung</strong></a></p></div></div>    
</body>
</html>