<html>
<head>
<title>Implement a GraphQL Server With Ent and Gqlgen in Go</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">在Go中用ent和Gqlgen实现一个GraphQL服务器</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/implement-a-graphql-server-with-ent-and-gqlgen-in-go-8840f086b8a8?source=collection_archive---------1-----------------------#2021-11-08">https://betterprogramming.pub/implement-a-graphql-server-with-ent-and-gqlgen-in-go-8840f086b8a8?source=collection_archive---------1-----------------------#2021-11-08</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="acd7" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">将静态类型的API与GraphQL集成</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/213b130c4c5d3280a3e914911a2fabfb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*kX4r1LA9iUB7MJ74FbrWlw.jpeg"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated"><a class="ae ky" href="https://unsplash.com/@elliotm" rel="noopener ugc nofollow" target="_blank">ильямельниченко</a>在<a class="ae ky" href="https://unsplash.com/?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍照。</p></figure><p id="a512" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这篇文章将带你了解如何使用<code class="fe lv lw lx ly b">ent</code>和<code class="fe lv lw lx ly b">gqlgen</code>实现GraphQL服务器。</p></div><div class="ab cl lz ma hx mb" role="separator"><span class="mc bw bk md me mf"/><span class="mc bw bk md me mf"/><span class="mc bw bk md me"/></div><div class="im in io ip iq"><h1 id="223e" class="mg mh it bd mi mj mk ml mm mn mo mp mq jz mr ka ms kc mt kd mu kf mv kg mw mx bi translated">回购示例</h1><p id="2947" class="pw-post-body-paragraph kz la it lb b lc my ju le lf mz jx lh li na lk ll lm nb lo lp lq nc ls lt lu im bi translated">以下是最终代码库的参考:</p><div class="nd ne gp gr nf ng"><a href="https://github.com/manakuro/golang-ent-gqlgen-example" rel="noopener  ugc nofollow" target="_blank"><div class="nh ab fo"><div class="ni ab nj cl cj nk"><h2 class="bd iu gy z fp nl fr fs nm fu fw is bi translated">GitHub-manakuro/golang-ent-gqlgen-示例:Go中带有ent和gqlgen的GraphQL服务器</h2><div class="nn l"><p class="bd b dl z fp nl fr fs nm fu fw dk translated">github.com</p></div></div><div class="no l"><div class="np l nq nr ns no nt ks ng"/></div></div></a></div><h1 id="1592" class="mg mh it bd mi mj nu ml mm mn nv mp mq jz nw ka ms kc nx kd mu kf ny kg mw mx bi translated">属国</h1><p id="d2ae" class="pw-post-body-paragraph kz la it lb b lc my ju le lf mz jx lh li na lk ll lm nb lo lp lq nc ls lt lu im bi translated">所需的依赖关系如下:</p><ul class=""><li id="5680" class="nz oa it lb b lc ld lf lg li ob lm oc lq od lu oe of og oh bi translated">Go版本1.17.2</li><li id="bc92" class="nz oa it lb b lc oi lf oj li ok lm ol lq om lu oe of og oh bi translated"><a class="ae ky" href="https://github.com/labstack/echo" rel="noopener ugc nofollow" target="_blank">回音</a></li><li id="7c58" class="nz oa it lb b lc oi lf oj li ok lm ol lq om lu oe of og oh bi translated"><a class="ae ky" href="https://github.com/ent/ent" rel="noopener ugc nofollow" target="_blank"> ent/ent </a></li><li id="8ed0" class="nz oa it lb b lc oi lf oj li ok lm ol lq om lu oe of og oh bi translated"><a class="ae ky" href="https://github.com/99designs/gqlgen" rel="noopener ugc nofollow" target="_blank">99设计/gqlgen </a></li></ul><h1 id="f1d7" class="mg mh it bd mi mj nu ml mm mn nv mp mq jz nw ka ms kc nx kd mu kf ny kg mw mx bi translated">什么是耳鼻喉？</h1><p id="f22e" class="pw-post-body-paragraph kz la it lb b lc my ju le lf mz jx lh li na lk ll lm nb lo lp lq nc ls lt lu im bi translated"><a class="ae ky" href="https://entgo.io/" rel="noopener ugc nofollow" target="_blank"> ent </a>是一个面向Go的ORM框架，它使得用数据库维护应用程序变得容易，并允许我们:</p><ul class=""><li id="5f30" class="nz oa it lb b lc ld lf lg li ob lm oc lq od lu oe of og oh bi translated">轻松运行查询和遍历任何图形结构</li><li id="f05d" class="nz oa it lb b lc oi lf oj li ok lm ol lq om lu oe of og oh bi translated">通过代码生成使用100%静态类型的API</li><li id="aaf1" class="nz oa it lb b lc oi lf oj li ok lm ol lq om lu oe of og oh bi translated">使用多种存储驱动程序— MySQL、PostgreSQL、SQLite和Gremlin</li><li id="0ff5" class="nz oa it lb b lc oi lf oj li ok lm ol lq om lu oe of og oh bi translated">使用GraphQL和<code class="fe lv lw lx ly b">gqlgen</code></li></ul><p id="0245" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">就静态类型API而言，<code class="fe lv lw lx ly b"><a class="ae ky" href="https://github.com/volatiletech/sqlboiler" rel="noopener ugc nofollow" target="_blank">sqlboiler</a></code>具有类似的功能，但不同之处在于<code class="fe lv lw lx ly b">ent</code>是一个模式优先的工具，它从模式文件创建数据库和类型API。<code class="fe lv lw lx ly b">sqlboilder</code>是一个数据库优先的ORM，它从数据库创建一个类型化的API。</p><h1 id="5b25" class="mg mh it bd mi mj nu ml mm mn nv mp mq jz nw ka ms kc nx kd mu kf ny kg mw mx bi translated">实施概述</h1><p id="80de" class="pw-post-body-paragraph kz la it lb b lc my ju le lf mz jx lh li na lk ll lm nb lo lp lq nc ls lt lu im bi translated">实施的步骤如下:</p><ul class=""><li id="4f85" class="nz oa it lb b lc ld lf lg li ob lm oc lq od lu oe of og oh bi translated">安装依赖项</li><li id="5514" class="nz oa it lb b lc oi lf oj li ok lm ol lq om lu oe of og oh bi translated">设置回显服务器</li><li id="5275" class="nz oa it lb b lc oi lf oj li ok lm ol lq om lu oe of og oh bi translated">设置ent</li><li id="9189" class="nz oa it lb b lc oi lf oj li ok lm ol lq om lu oe of og oh bi translated">设置<code class="fe lv lw lx ly b">gqlgen</code></li></ul><h1 id="c1f8" class="mg mh it bd mi mj nu ml mm mn nv mp mq jz nw ka ms kc nx kd mu kf ny kg mw mx bi translated">安装依赖项</h1><p id="e001" class="pw-post-body-paragraph kz la it lb b lc my ju le lf mz jx lh li na lk ll lm nb lo lp lq nc ls lt lu im bi translated">这篇文章中需要一些依赖项，所以先安装它们:</p><pre class="kj kk kl km gt on ly oo op aw oq bi"><span id="dd92" class="or mh it ly b gy os ot l ou ov">go get github.com/labstack/echo/v4<br/>go get github.com/labstack/echo/v4/middleware@v4.6.1<br/>go get github.com/go-sql-driver/mysql<br/>go install entgo.io/ent/cmd/ent</span></pre></div><div class="ab cl lz ma hx mb" role="separator"><span class="mc bw bk md me mf"/><span class="mc bw bk md me mf"/><span class="mc bw bk md me"/></div><div class="im in io ip iq"><h1 id="dbeb" class="mg mh it bd mi mj mk ml mm mn mo mp mq jz mr ka ms kc mt kd mu kf mv kg mw mx bi translated">设置回显服务器</h1><p id="34bd" class="pw-post-body-paragraph kz la it lb b lc my ju le lf mz jx lh li na lk ll lm nb lo lp lq nc ls lt lu im bi translated">为了快速开始，我们将使用echo包设置一个服务器。</p><p id="0cd8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">创建<code class="fe lv lw lx ly b">main.go</code>并编写代码:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ow ox l"/></div></figure><p id="afc7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">你可以在<a class="ae ky" href="http://localhost:8080/" rel="noopener ugc nofollow" target="_blank"> http://localhost:8080: </a>看到这个页面</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi oy"><img src="../Images/5f1566a154e6ecdca18e04b436191d6a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*BvybVMNByUOoAH58.jpeg"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">欢迎页面</p></figure></div><div class="ab cl lz ma hx mb" role="separator"><span class="mc bw bk md me mf"/><span class="mc bw bk md me mf"/><span class="mc bw bk md me"/></div><div class="im in io ip iq"><h1 id="901e" class="mg mh it bd mi mj mk ml mm mn mo mp mq jz mr ka ms kc mt kd mu kf mv kg mw mx bi translated">设置ent</h1><p id="4cb3" class="pw-post-body-paragraph kz la it lb b lc my ju le lf mz jx lh li na lk ll lm nb lo lp lq nc ls lt lu im bi translated">接下来，我们将设置<code class="fe lv lw lx ly b">ent</code>。</p><h2 id="4575" class="or mh it bd mi oz pa dn mm pb pc dp mq li pd pe ms lm pf pg mu lq ph pi mw pj bi translated">创建用户模式</h2><p id="7e45" class="pw-post-body-paragraph kz la it lb b lc my ju le lf mz jx lh li na lk ll lm nb lo lp lq nc ls lt lu im bi translated">在本文中，我们将在数据库中创建一个<code class="fe lv lw lx ly b">users</code>表。</p><p id="d5f4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在此之前，我们需要创建一个名为<code class="fe lv lw lx ly b">User</code>的模式文件:</p><pre class="kj kk kl km gt on ly oo op aw oq bi"><span id="dfbe" class="or mh it ly b gy os ot l ou ov">ent init User</span></pre><p id="55c4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">生成的文件应该如下所示:</p><pre class="kj kk kl km gt on ly oo op aw oq bi"><span id="6741" class="or mh it ly b gy os ot l ou ov">ent<br/>├── generate.go<br/>└── schema<br/>    └── user.go</span></pre><p id="8f90" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe lv lw lx ly b">user.go</code>有一个包括<code class="fe lv lw lx ly b">Fields</code>和<code class="fe lv lw lx ly b">Edges</code>的模式:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ow ox l"/></div></figure><ul class=""><li id="e53c" class="nz oa it lb b lc ld lf lg li ob lm oc lq od lu oe of og oh bi translated"><code class="fe lv lw lx ly b">Fields</code> —节点的属性。这相当于数据库中的一列，像<code class="fe lv lw lx ly b">name</code>、<code class="fe lv lw lx ly b">age</code>和<code class="fe lv lw lx ly b">created_at</code>。</li><li id="55df" class="nz oa it lb b lc oi lf oj li ok lm ol lq om lu oe of og oh bi translated"><code class="fe lv lw lx ly b">Edges</code>—实体的关系。它允许您定义每个表的关系，如<code class="fe lv lw lx ly b">O2O</code>(一对一)、<code class="fe lv lw lx ly b">O2M</code>(一对多)和<code class="fe lv lw lx ly b">M2M</code>(多对多)</li></ul><p id="bd69" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">因此，我们将按如下方式设置<code class="fe lv lw lx ly b">name</code>、<code class="fe lv lw lx ly b">age</code>和<code class="fe lv lw lx ly b">created_at</code>至<code class="fe lv lw lx ly b">Fields</code>:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ow ox l"/></div></figure><p id="a687" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在添加字段之后，基于上面的模式生成资产，以便它们可以在您的项目中工作。</p><p id="819e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在根项目中运行<code class="fe lv lw lx ly b">go generate</code>:</p><pre class="kj kk kl km gt on ly oo op aw oq bi"><span id="7eb8" class="or mh it ly b gy os ot l ou ov"><em class="pk">go</em> generate ./ent</span></pre><p id="cc85" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这将生成如下文件:</p><pre class="kj kk kl km gt on ly oo op aw oq bi"><span id="b1a9" class="or mh it ly b gy os ot l ou ov">ent<br/>├── client.go<br/>├── config.go<br/>├── context.go<br/>├── ent.go<br/>├── enttest<br/>│   └── enttest.go<br/>├── generate.go<br/>├── hook<br/>│   └── hook.go<br/>├── migrate<br/>│   ├── migrate.go<br/>│   └── schema.go<br/>├── mutation.go<br/>├── predicate<br/>│   └── predicate.go<br/>├── runtime<br/>│   └── runtime.go<br/>├── runtime.go<br/>├── schema<br/>│   └── user.go<br/>├── tx.go<br/>├── user<br/>│   ├── user.go<br/>│   └── where.go<br/>├── user.go<br/>├── user_create.go<br/>├── user_delete.go<br/>├── user_query.go<br/>└── user_update.go</span></pre><p id="58b1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这项资产包括:</p><ul class=""><li id="7c36" class="nz oa it lb b lc ld lf lg li ob lm oc lq od lu oe of og oh bi translated">操作表中CRUD的代码(<code class="fe lv lw lx ly b">user_create.go</code>、<code class="fe lv lw lx ly b">user_delete.go</code>、<code class="fe lv lw lx ly b">user_query.go</code>和<code class="fe lv lw lx ly b">user_update.go</code>)</li><li id="f69f" class="nz oa it lb b lc oi lf oj li ok lm ol lq om lu oe of og oh bi translated">SQL的迁移包</li><li id="93b9" class="nz oa it lb b lc oi lf oj li ok lm ol lq om lu oe of og oh bi translated">实体对象</li><li id="59e6" class="nz oa it lb b lc oi lf oj li ok lm ol lq om lu oe of og oh bi translated">添加变异中间件的钩子包。</li><li id="3294" class="nz oa it lb b lc oi lf oj li ok lm ol lq om lu oe of og oh bi translated">等等</li></ul><p id="70b2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">所以基本上，有了这个资产，您就可以安全地操作带有静态类型实体的表。</p><h2 id="d834" class="or mh it bd mi oz pa dn mm pb pc dp mq li pd pe ms lm pf pg mu lq ph pi mw pj bi translated">数据库迁移</h2><p id="6abf" class="pw-post-body-paragraph kz la it lb b lc my ju le lf mz jx lh li na lk ll lm nb lo lp lq nc ls lt lu im bi translated"><code class="fe lv lw lx ly b">ent</code>还提供数据库迁移支持，以保持项目中模式的一致性。</p><p id="7407" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">要运行迁移，请在应用程序的初始化中编写代码。</p><p id="3ad6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在<code class="fe lv lw lx ly b">main.go</code>中编写迁移逻辑:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ow ox l"/></div></figure><p id="880e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">完成初始化后，可以看到<code class="fe lv lw lx ly b">users</code>表已经成功创建。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi pl"><img src="../Images/c7402a2e24a5a05a0bf1f452329cc18e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*UC6jl16VPISZLPyQ79sIFw.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">用户表</p></figure><p id="c9d4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">默认情况下，<code class="fe lv lw lx ly b">field.Time</code>使用MySQL中的<code class="fe lv lw lx ly b">TIMESTAMP</code>类型，其范围为<code class="fe lv lw lx ly b">1970–01–01 00:00:01 UTC</code>到<code class="fe lv lw lx ly b">2038–01–19 03:14:07 UTC</code>。</p><p id="32a1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果<code class="fe lv lw lx ly b">TIMESTAMP</code>不适合您的应用，您可以更改为<code class="fe lv lw lx ly b">DATETIME</code>类型，如下所示:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ow ox l"/></div></figure><h2 id="ea6b" class="or mh it bd mi oz pa dn mm pb pc dp mq li pd pe ms lm pf pg mu lq ph pi mw pj bi translated">创建用户</h2><p id="97e6" class="pw-post-body-paragraph kz la it lb b lc my ju le lf mz jx lh li na lk ll lm nb lo lp lq nc ls lt lu im bi translated">现在我们已经准备好在表中创建一个用户。</p><p id="f5d8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如上所述，我们已经有了为表提供CRUD API的方法。</p><p id="51d0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们在<code class="fe lv lw lx ly b">ent/user_create.go</code>中调用<code class="fe lv lw lx ly b">Create</code>:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ow ox l"/></div></figure><p id="ea5d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">当您向<code class="fe lv lw lx ly b">http://localhost:8080/users</code>发送POST请求时，这将在<code class="fe lv lw lx ly b">users</code>表中创建一个用户，并随后响应一个用户数据:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi pm"><img src="../Images/49967c469a32838b484f6540bdd43a24.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*yfoBUaX8ZX55AR1JxC_efg.png"/></div></div></figure><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi pn"><img src="../Images/673d53c1d11fc192726f0d1af96b2129.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*sEixhX3r3-Wpn1-2IBPVlA.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">发送发布请求</p></figure><h2 id="865d" class="or mh it bd mi oz pa dn mm pb pc dp mq li pd pe ms lm pf pg mu lq ph pi mw pj bi translated">询问用户</h2><p id="fe93" class="pw-post-body-paragraph kz la it lb b lc my ju le lf mz jx lh li na lk ll lm nb lo lp lq nc ls lt lu im bi translated">为了从<code class="fe lv lw lx ly b">ent</code>包中获取用户数据，您可以像这样使用<code class="fe lv lw lx ly b">Query()</code>:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ow ox l"/></div></figure><p id="bfce" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这将响应表中的所有用户:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi po"><img src="../Images/0faf0a4abeab7eb8628824cca882c992.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*HHNIw4qrX3pFj1GJ8IK_1A.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">所有用户</p></figure><p id="56d8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">您可以使用<code class="fe lv lw lx ly b">Select</code>功能选择部分对象，如下所示:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ow ox l"/></div></figure><p id="3d31" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe lv lw lx ly b">age</code>字段被排除在响应之外，如下所示:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi pp"><img src="../Images/76a0942d6ab2e8393929308f526e3f6c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*RTuQ7ujv2BWmDk8WmyrqMA.png"/></div></div></figure><p id="4c83" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">也可以这样使用<code class="fe lv lw lx ly b">Where</code>:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ow ox l"/></div></figure><p id="4074" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe lv lw lx ly b">Only</code>函数返回一个用户实体，当没有找到用户实体时，返回一个<code class="fe lv lw lx ly b">NotFoundError</code>。</p><p id="dbd9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">当SQL返回多个用户时:</p><pre class="kj kk kl km gt on ly oo op aw oq bi"><span id="9f8b" class="or mh it ly b gy os ot l ou ov">us, err := client.User.<br/>   Query().<br/>   Where(user.AgeEQ(21)).<br/>   Only(c.Request().Context())</span></pre><p id="2f76" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe lv lw lx ly b">ent</code>会警告记录不是单个的。</p><pre class="kj kk kl km gt on ly oo op aw oq bi"><span id="3718" class="or mh it ly b gy os ot l ou ov">user not singular</span></pre><h2 id="398b" class="or mh it bd mi oz pa dn mm pb pc dp mq li pd pe ms lm pf pg mu lq ph pi mw pj bi translated">创建边</h2><p id="a02d" class="pw-post-body-paragraph kz la it lb b lc my ju le lf mz jx lh li na lk ll lm nb lo lp lq nc ls lt lu im bi translated">接下来，我们将创建另一个实体，并在模式中声明该实体的边缘。</p><p id="5b0c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">首先，让我们创建一个名为<code class="fe lv lw lx ly b">Article</code>的实体。</p><pre class="kj kk kl km gt on ly oo op aw oq bi"><span id="4e3e" class="or mh it ly b gy os ot l ou ov">ent init Artcile</span></pre><p id="3828" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">并且会在schema文件夹下生成<code class="fe lv lw lx ly b">article.go</code>。</p><pre class="kj kk kl km gt on ly oo op aw oq bi"><span id="7812" class="or mh it ly b gy os ot l ou ov">ent<br/>├── schema<br/>│   ├── article.go<br/>│   └── user.go</span></pre><p id="109a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">然后，我们将添加一些字段，如下所示:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ow ox l"/></div></figure><p id="d263" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们假设<code class="fe lv lw lx ly b">User</code>可以有多篇文章，而一篇文章只有一个用户，所以关系是一个<code class="fe lv lw lx ly b">one-to-many</code>。</p><p id="2968" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">因此，让我们创建一条从<code class="fe lv lw lx ly b">User</code>到<code class="fe lv lw lx ly b">Artcie</code>的边。</p><p id="69d8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">首先，将<code class="fe lv lw lx ly b">articles</code>边添加到<code class="fe lv lw lx ly b">ent/schema/user.go</code>中的<code class="fe lv lw lx ly b">User</code>模式:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ow ox l"/></div></figure><p id="6428" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">并运行它:</p><pre class="kj kk kl km gt on ly oo op aw oq bi"><span id="979c" class="or mh it ly b gy os ot l ou ov">go generate ./ent</span></pre><p id="f3e3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">当您运行服务器时，您可以看到已经创建了<code class="fe lv lw lx ly b">articles</code>表:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi pq"><img src="../Images/b8a534f61cdf8bbf990b7c1aa7bd0a2f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*79bYzxQKBlUYS0ri3dj7rA.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">文章表</p></figure><p id="e728" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">因此，让我们创建一篇文章并将其添加到<code class="fe lv lw lx ly b">User</code>中。</p><p id="9f62" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们继续使用<code class="fe lv lw lx ly b">main.go</code>中的<code class="fe lv lw lx ly b">/users</code>端点，并把一些代码写成这样:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ow ox l"/></div></figure><p id="e3a2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe lv lw lx ly b">AddArticles</code>函数已经通过在模式中添加一条边而生成，所以我们可以用它来给用户添加文章。</p><p id="2ec3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">向<code class="fe lv lw lx ly b"><a class="ae ky" href="http://localhost:8080/users," rel="noopener ugc nofollow" target="_blank">http://localhost:8080/users</a></code><a class="ae ky" href="http://localhost:8080/users," rel="noopener ugc nofollow" target="_blank"/>发送请求后，可以看到记录已经创建:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi pr"><img src="../Images/558ecb105aead4271686c79d9f1f1a83.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*kijzJ3FaAZ_hbB3Wtszh3g.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">文章</p></figure><h2 id="1423" class="or mh it bd mi oz pa dn mm pb pc dp mq li pd pe ms lm pf pg mu lq ph pi mw pj bi translated">反向边缘</h2><p id="1a64" class="pw-post-body-paragraph kz la it lb b lc my ju le lf mz jx lh li na lk ll lm nb lo lp lq nc ls lt lu im bi translated">现在我们可以通过<code class="fe lv lw lx ly b">User</code>实体访问<code class="fe lv lw lx ly b">Article</code>，但是在某些情况下你想从<code class="fe lv lw lx ly b">Article</code>获取用户。为了实现这一点，<code class="fe lv lw lx ly b">ent</code>提供了<code class="fe lv lw lx ly b">edge.From</code>功能。</p><p id="8782" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">因此，让我们在<code class="fe lv lw lx ly b">ent/schema/artcile.go</code>的<code class="fe lv lw lx ly b">Article</code>模式中添加一个名为<code class="fe lv lw lx ly b">users</code>的反向边:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ow ox l"/></div></figure><p id="77b6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">因为除了<code class="fe lv lw lx ly b">Article</code>之外，<code class="fe lv lw lx ly b">User</code>模式可能有不止一个引用，所以<code class="fe lv lw lx ly b">Ref</code>方法描述了用户模式的哪个边缘被引用。</p><p id="5404" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">并运行生成:</p><pre class="kj kk kl km gt on ly oo op aw oq bi"><span id="61be" class="or mh it ly b gy os ot l ou ov">go generate ./ent</span></pre><p id="b2b3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">因此，让我们从一个文章实体中查询一个用户:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ow ox l"/></div></figure><p id="e1e3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在控制台日志中，您可以看到实际执行的SQL:</p><pre class="kj kk kl km gt on ly oo op aw oq bi"><span id="b4c4" class="or mh it ly b gy os ot l ou ov">SELECT DISTINCT <br/> `users`.`id`, <br/> `users`.`name`, <br/> `users`.`age`, <br/> `users`.`created_at` <br/>FROM <br/> `users` <br/>JOIN <br/> (SELECT `articles`.`user_articles` FROM `articles` WHERE `articles`.`id` = ?) AS `t1` <br/>ON <br/> `users`.`id` = `t1`.`user_articles` <br/>LIMIT 2 args=[1]</span></pre><p id="c03a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">并且这样响应一个用户数据:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ps"><img src="../Images/b0972dc7be3e0953ad234184f3968685.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*MAsrkbFN_IUg9EBkDVqFrw.png"/></div></div></figure><h2 id="a464" class="or mh it bd mi oz pa dn mm pb pc dp mq li pd pe ms lm pf pg mu lq ph pi mw pj bi translated">急切装载</h2><p id="5cc1" class="pw-post-body-paragraph kz la it lb b lc my ju le lf mz jx lh li na lk ll lm nb lo lp lq nc ls lt lu im bi translated"><code class="fe lv lw lx ly b">ent</code>提供通过<code class="fe lv lw lx ly b">Eager loading</code>查询实体及其关联的能力。</p><p id="10d3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">急切加载允许我们查询多个关联。例如，我们可以将用户数据包含在这样的文章中:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ow ox l"/></div></figure><p id="7b10" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">响应包括<code class="fe lv lw lx ly b">edges</code>中的文章数据:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi pt"><img src="../Images/58b34275ede3167b2b9d6a28e00ce3f5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*2_lMxACTMjYYBWMx0FBIsw.png"/></div></div></figure><p id="4a26" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">执行的日志如下:</p><pre class="kj kk kl km gt on ly oo op aw oq bi"><span id="247a" class="or mh it ly b gy os ot l ou ov">SELECT DISTINCT <br/> `users`.`id`, <br/> `users`.`name`, <br/> `users`.`age`, <br/> `users`.`created_at` <br/>FROM <br/> `users` <br/>WHERE <br/> `users`.`id` = ? <br/>LIMIT <br/> 2<br/>args=[7]</span><span id="3efe" class="or mh it ly b gy pu ot l ou ov">SELECT DISTINCT <br/> `articles`.`id`, <br/> `articles`.`title`, <br/> `articles`.`description`, <br/> `articles`.`user_articles` <br/>FROM <br/> `articles` <br/>WHERE <br/> `user_articles` <br/>IN (?) <br/>args=[7]</span></pre><h2 id="1e86" class="or mh it bd mi oz pa dn mm pb pc dp mq li pd pe ms lm pf pg mu lq ph pi mw pj bi translated">自定义外键列</h2><p id="491e" class="pw-post-body-paragraph kz la it lb b lc my ju le lf mz jx lh li na lk ll lm nb lo lp lq nc ls lt lu im bi translated">创建边时，<code class="fe lv lw lx ly b">ent</code>默认会自动生成一个外键列。</p><p id="d23b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">例如，在创建<code class="fe lv lw lx ly b">Article</code>时，<code class="fe lv lw lx ly b">ent</code>已经创建了<code class="fe lv lw lx ly b">user_articles</code>列作为外键。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi pv"><img src="../Images/55508a8a1d8cacbaa13a1d47d0c66785.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*RJq-YBOfQJdGYbA527Byjg.png"/></div></div></figure><p id="e1d1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">为了自定义名称，您可以像这样在<code class="fe lv lw lx ly b">ent/schema/user.go</code>中使用<code class="fe lv lw lx ly b"><a class="ae ky" href="https://entgo.io/docs/schema-edges/#storagekey" rel="noopener ugc nofollow" target="_blank">StorageKey</a></code>:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ow ox l"/></div></figure><p id="2ade" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">并运行<code class="fe lv lw lx ly b">go generate ./ent</code>，会将<code class="fe lv lw lx ly b">user_id</code>列添加到<code class="fe lv lw lx ly b">articles</code>表中:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi pl"><img src="../Images/79fd8573e74ec7937f24bbc8ebc43be0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*XMXWujh6Pg1FIOwpzVj6VQ.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">文章表</p></figure><p id="eb30" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><em class="pk">注意:ent默认使外键</em><a class="ae ky" href="https://github.com/ent/ent/blob/master/entc/gen/graph.go#L459" rel="noopener ugc nofollow" target="_blank"><em class="pk"/></a><em class="pk">为空。</em> <a class="ae ky" href="https://github.com/ent/ent/pull/1703" rel="noopener ugc nofollow" target="_blank"> <em class="pk"> PR </em> </a> <em class="pk">合并后，可以根据需要边设置</em> <code class="fe lv lw lx ly b"><em class="pk">NOT NULL</em></code> <em class="pk">为外键。</em></p><h1 id="d5d7" class="mg mh it bd mi mj nu ml mm mn nv mp mq jz nw ka ms kc nx kd mu kf ny kg mw mx bi translated">设置GraphQL</h1><p id="f762" class="pw-post-body-paragraph kz la it lb b lc my ju le lf mz jx lh li na lk ll lm nb lo lp lq nc ls lt lu im bi translated">接下来，我们将使用<code class="fe lv lw lx ly b">gqlgen</code>将<code class="fe lv lw lx ly b">ent</code>连接到GraphQL。</p><h2 id="d61c" class="or mh it bd mi oz pa dn mm pb pc dp mq li pd pe ms lm pf pg mu lq ph pi mw pj bi translated">设置gqlgen</h2><p id="85d0" class="pw-post-body-paragraph kz la it lb b lc my ju le lf mz jx lh li na lk ll lm nb lo lp lq nc ls lt lu im bi translated">首先，让我们安装gqlgen:</p><pre class="kj kk kl km gt on ly oo op aw oq bi"><span id="7204" class="or mh it ly b gy os ot l ou ov">go get github.com/99designs/gqlgen</span></pre><p id="7d0b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">要安装程序包，请运行以下命令:</p><pre class="kj kk kl km gt on ly oo op aw oq bi"><span id="f550" class="or mh it ly b gy os ot l ou ov">go run github.com/99designs/gqlgen init</span></pre><p id="55a8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这将在根项目下生成以下布局:</p><pre class="kj kk kl km gt on ly oo op aw oq bi"><span id="4615" class="or mh it ly b gy os ot l ou ov">├── gqlgen.yml<br/>├── graph<br/>│   ├── generated<br/>│   │   └── generated.go<br/>│   ├── model<br/>│   │   └── models_gen.go<br/>│   ├── resolver.go<br/>│   ├── schema.graphqls<br/>│   └── schema.resolvers.go</span></pre><ul class=""><li id="04e2" class="nz oa it lb b lc ld lf lg li ob lm oc lq od lu oe of og oh bi translated"><code class="fe lv lw lx ly b">gqlgen.yml</code> —控制生成文件的配置文件</li><li id="47e5" class="nz oa it lb b lc oi lf oj li ok lm ol lq om lu oe of og oh bi translated"><code class="fe lv lw lx ly b">graph/generated</code> —运行时包(自动生成)</li><li id="b4e3" class="nz oa it lb b lc oi lf oj li ok lm ol lq om lu oe of og oh bi translated"><code class="fe lv lw lx ly b">model/models_gen.go</code> —所有图形模型的包(自动生成)</li><li id="00ec" class="nz oa it lb b lc oi lf oj li ok lm ol lq om lu oe of og oh bi translated"><code class="fe lv lw lx ly b">resolver.go</code> —图形解析器的根</li><li id="1236" class="nz oa it lb b lc oi lf oj li ok lm ol lq om lu oe of og oh bi translated"><code class="fe lv lw lx ly b">schema.graphqls</code> —您可以随意定制的模式文件</li><li id="308f" class="nz oa it lb b lc oi lf oj li ok lm ol lq om lu oe of og oh bi translated"><code class="fe lv lw lx ly b">schema.resolvers.go</code> —解析器实现(自动生成)</li></ul><p id="6de2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe lv lw lx ly b">gqlgen.yml</code>需要修改为ent，所以粘贴代码:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ow ox l"/></div></figure><p id="7db9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe lv lw lx ly b">autobind</code>在<code class="fe lv lw lx ly b">ent</code>文件夹中寻找任何匹配的类型名。在这种情况下，<code class="fe lv lw lx ly b">ent.User</code>将在解析器中使用。</p><p id="80db" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">接下来，我们将把<code class="fe lv lw lx ly b">schema.graphqls</code>改为<code class="fe lv lw lx ly b">user.graphqls</code>，并放入一些代码，如下所示:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ow ox l"/></div></figure><p id="48da" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">并移除现有的解析器，<code class="fe lv lw lx ly b">schema.resolvers.go</code>:</p><pre class="kj kk kl km gt on ly oo op aw oq bi"><span id="b1f3" class="or mh it ly b gy os ot l ou ov">rm -r ./graph/<!-- -->schema.resolvers.go</span></pre><p id="5c30" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">运行<code class="fe lv lw lx ly b">gqlgen</code>代码生成:</p><pre class="kj kk kl km gt on ly oo op aw oq bi"><span id="e5af" class="or mh it ly b gy os ot l ou ov">go run github.com/99designs/gqlgen</span></pre><p id="f6d2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">因此，项目目录应该如下所示:</p><pre class="kj kk kl km gt on ly oo op aw oq bi"><span id="8b32" class="or mh it ly b gy os ot l ou ov">graph<br/>├── generated<br/>│   └── generated.go<br/>├── model<br/>│   └── models_gen.go<br/>├── resolver.go<br/>├── user.graphqls<br/>└── user.resolvers.go</span></pre><h2 id="a362" class="or mh it bd mi oz pa dn mm pb pc dp mq li pd pe ms lm pf pg mu lq ph pi mw pj bi translated">将ent连接到gqlgen</h2><p id="54a4" class="pw-post-body-paragraph kz la it lb b lc my ju le lf mz jx lh li na lk ll lm nb lo lp lq nc ls lt lu im bi translated">和GraphQL扩展用于<code class="fe lv lw lx ly b">ent</code>:</p><pre class="kj kk kl km gt on ly oo op aw oq bi"><span id="1993" class="or mh it ly b gy os ot l ou ov">go get entgo.io/contrib/entgql</span></pre><p id="d699" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">为了在ent项目中使用<code class="fe lv lw lx ly b">gqlgen</code>,需要对我们的项目启用ent扩展。</p><p id="377f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">为此，创建一个名为<code class="fe lv lw lx ly b">ent/entc.go</code>的新文件，并添加以下代码:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ow ox l"/></div></figure><p id="d9ed" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">然后，打开<code class="fe lv lw lx ly b">ent/generate.go</code>文件，将代码改为:</p><pre class="kj kk kl km gt on ly oo op aw oq bi"><span id="7e66" class="or mh it ly b gy os ot l ou ov">package ent<br/><br/>//<strong class="ly iu"><em class="pk">go:generate </em></strong>go run -mod=mod entc.go</span></pre><p id="5d08" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">运行codegen:</p><pre class="kj kk kl km gt on ly oo op aw oq bi"><span id="c76f" class="or mh it ly b gy os ot l ou ov">go generate ./ent</span></pre><p id="4cee" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">因此，通过运行这个命令，<a class="ae ky" href="https://entgo.io/docs/graphql/#node-api" rel="noopener ugc nofollow" target="_blank">一些附加组件</a>将被添加到我们的项目中。</p><p id="2f8f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">最后，为了在<code class="fe lv lw lx ly b">gelgen</code>解析器中使用<code class="fe lv lw lx ly b">ent.Client</code>，打开<code class="fe lv lw lx ly b">graph/resolver.go</code>并将其作为附加依赖项传递给模式:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ow ox l"/></div></figure><h1 id="f7fe" class="mg mh it bd mi mj nu ml mm mn nv mp mq jz nw ka ms kc nx kd mu kf ny kg mw mx bi translated">运行GraphQL服务器</h1><p id="94e9" class="pw-post-body-paragraph kz la it lb b lc my ju le lf mz jx lh li na lk ll lm nb lo lp lq nc ls lt lu im bi translated">现在我们已经准备好运行GraphQL服务器了。</p><p id="da1c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们修改<code class="fe lv lw lx ly b">main.go</code>来配置GraphQL服务器。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ow ox l"/></div></figure><p id="87c5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">并打开<code class="fe lv lw lx ly b">http://localhost:8080/playground</code>:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi pw"><img src="../Images/15450e682ea877f7f72f2b75a2ee2e08.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*fwzKJ7vw8jCcU7rsfkYWQA.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">操场</p></figure><h2 id="5c6f" class="or mh it bd mi oz pa dn mm pb pc dp mq li pd pe ms lm pf pg mu lq ph pi mw pj bi translated">查询用户</h2><p id="2bb8" class="pw-post-body-paragraph kz la it lb b lc my ju le lf mz jx lh li na lk ll lm nb lo lp lq nc ls lt lu im bi translated">由于用户的解析器尚未实现，因此我们在<code class="fe lv lw lx ly b">graph/user.resolvers.go</code>中添加解析器:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ow ox l"/></div></figure><p id="8968" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在操场上运行查询，它应该会返回用户数据:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi px"><img src="../Images/88d4803852106432825416a02f34a972.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*7-uJq-v_btXQXl9Ej8aczQ.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">操场</p></figure></div><div class="ab cl lz ma hx mb" role="separator"><span class="mc bw bk md me mf"/><span class="mc bw bk md me mf"/><span class="mc bw bk md me"/></div><div class="im in io ip iq"><h1 id="93de" class="mg mh it bd mi mj mk ml mm mn mo mp mq jz mr ka ms kc mt kd mu kf mv kg mw mx bi translated">结论</h1><p id="c90c" class="pw-post-body-paragraph kz la it lb b lc my ju le lf mz jx lh li na lk ll lm nb lo lp lq nc ls lt lu im bi translated">就是这样！我们已经使用<code class="fe lv lw lx ly b">ent</code>和<code class="fe lv lw lx ly b">gqlgen</code>包实现了一个GraphQL服务器。如你所见，<code class="fe lv lw lx ly b">ent</code>为我们的数据库提供了一个真正有用的强类型API。</p><p id="b6d3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><a class="ae ky" href="https://github.com/go-gorm/gorm" rel="noopener ugc nofollow" target="_blank"> Gorm </a>已经成为Go的标准orm工具，并提供了一个全功能的包。在静态类型方面，gorm采用接口，内部使用反射，所以有时会丢失类型，出现运行时错误。</p><p id="ce5e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">另一方面，<code class="fe lv lw lx ly b">ent</code>使用codegen来生成类型和API，以便在编译时通知我们可能的错误。</p><p id="d128" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果您需要使用静态类型的API和GraphQL集成，ent将是您的选择之一。</p></div></div>    
</body>
</html>