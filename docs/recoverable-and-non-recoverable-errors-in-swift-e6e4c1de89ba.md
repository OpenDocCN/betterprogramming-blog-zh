# Swift 中可恢复和不可恢复的错误

> 原文：<https://betterprogramming.pub/recoverable-and-non-recoverable-errors-in-swift-e6e4c1de89ba>

## 确保您的 iOS 代码库正确失败

![](img/75e33df6d6ec1223874c6bf5107e0568.png)

照片由[放大](https://unsplash.com/@theblowup?utm_source=unsplash&utm_medium=referral&utm_content=creditCopyText)上的[去飞溅](https://unsplash.com/s/photos/failure?utm_source=unsplash&utm_medium=referral&utm_content=creditCopyText)

Swift 为开发人员提供了一些处理意外程序流的工具。然而*意料之外的*在这里不一定意味着*未定义的*。

在你能选择一个合适的工具之前，你首先得仔细检查这个问题。区分谁或什么做了意想不到的事情很重要:

1.  用户
2.  一项服务
3.  程序本身

# 意外的用户操作

如果你要求用户输入他们的名字，但是他们只是简单地按下“OK”按钮，那么这不是通常所期望的行为，而是(希望)已经预先定义好的行为。

理想情况下，用户甚至不可能执行这个动作(例如，因为按钮被去激活)。如果这个动作仍然可行，那么你应该拒绝这个结果，并且告诉用户他们做错了什么。

因此，该操作会导致一个定义好的错误，在运行时很容易恢复。通过拒绝进入，app 始终处于定义好的状态。

适用于此类错误的工具有:

*   `if`或`switch`分支
*   `guard`语句

# 意外服务行为

如果您使用某个服务，比如向服务器发送请求，那么该服务总是会出现意外行为。

服务器有时可能不可用，这当然不是服务器的预期行为，但它肯定是一个定义好的行为。或者它可能被错误地编程，并产生无效的、不可处理的结果。

在后一种情况下，不正确的结果没有被定义。一切最终都可能回来，但是预期的行为(某个返回值)和过程(请求的响应)本身是非常好定义的。这使您能够捕获错误，因为您确切地知道错误可能发生在哪里以及错误是什么。

因此，您应该始终预期服务不会像您预期的那样工作，并捕捉相应的错误。通过在运行时捕获错误，您可以恢复应用程序以前定义的状态。

合适的工具有:

*   `Result.error`或`nil`为可选返回值
*   使用`if`、`switch`或`guard`语句检查返回值。
*   `do try catch`块或`try?`如果错误可以忽略

# 意外的程序行为

我们已经到达有趣的和“有问题的”问题。我们如何处理程序本身的错误？

当程序没有做它应该做的事情时，它被称为“bug”错误是由程序员造成的，因为他们通常没有彻底考虑一些事情，或者因为功能没有被清楚地描述，因此没有被正确地使用。

与前面的错误不同，这些错误总是未定义的。没有人会告诉开发者友好地在这里添加一个 bug。否则，它就不是一个 bug，而是一个已定义的行为。从定义上来说，有缺陷的接受标准是矛盾的。

程序(mer)错误通常会导致应用程序出现未定义的状态。有些可能不是很严重，但有些是。未定义的状态也会影响应用程序中其他未定义的状态。

未定义的应用程序状态是我们肯定要防止的，因为*未定义的*意味着应用程序可以一次做所有的事情。这种行为最终不再被定义。该应用程序可能会立即崩溃或继续运行，没有任何明显的问题，只会在很久以后导致一些神秘的副作用，我们永远不会得到重建和修复。

错误发现得越晚，就越难定位和修复。这就是为什么我们要编写单元和集成测试(或者至少我们应该这样做)。然而，这些总是只检查封装的代码块，并且只能测试定义的行为，因为单元测试未定义的行为应该是什么样子的呢？如果一个人能做到这一点，那么行为就会被定义。

然而，有一种更好的方法，通过健全性检查直接在代码中进行测试。健全性检查类似于`assert`和`precondition`。它们有助于检查代码本身的假设和内部状态，从而识别未定义的应用程序状态。

如果健全性检查不成功，那是因为应用程序已经处于未定义的状态——一种应该/不能实际发生的状态。如果这种情况真的发生了，实际上只有一个有效的解决方案:崩溃！

崩溃在这里是一件好事，因为使用崩溃报告:

1.  你就会知道这个应用程序有错误。
2.  你就能确切知道它发生在哪里。

这为您提供了尽快修复错误的可能性。任何恢复尝试都不可避免地导致错误延续，并导致可能永远无法修复的后续错误。

因此，未定义的状态是不可恢复的错误，会导致崩溃。

合适的工具有:

*   `assert()`或`assertionFailure()`
*   `precondition()`或`preconditionFailure()`
*   `fatalError()`

让我们仔细看看这些工具及其用途。

# 代码中的完整性检查

根据函数和编译器标志，健全性检查方法的行为会有所不同。这些列表示是否执行了函数和测试，如果没有执行，应用程序就会崩溃。

健全性检查功能

**优化器可能认为这个函数永远不会被调用。如果是这样呢？这是未定义的。但是，无论如何都不应该使用 unchecked 标志。*

那么什么时候用哪个函数呢？

## 致命错误

因为这个函数本身不检查任何东西，所以它实际上非常容易使用。每当您在代码中到达一个逻辑上不可到达的状态时，您就使用`fatalError()`来强制崩溃。

何时使用 fatalError()的示例

## 前提

使用`precondition()`，您可以检查输入参数的有效性。

例如，如果您编写一个仅对大于零的正值有意义的方法，您可以将这样的值设置为调用该方法的条件。因为没有办法通过编译器来定义它，我们通过方法文档来定义它。为了确保开发人员不会用不正确的值调用该方法，使用`precondition()`在方法中检查该值。

何时使用前提条件()的示例

重要的是要知道，无论是在调试还是在发布版本中，这种检查总是要执行的。所以你可以确定，在这一点上，应用程序永远不会在未定义的状态下运行。

## 预处理失败

`preconditionFailure()`的语义其实和`precondition()`的语义是一样的。如果触发，则方法参数不正确。然而，不同之处在于`preconditionFailure()`本身并不执行检查(也就是说，您必须自己在代码中执行这样的检查，并且在否定的情况下，手动调用`preconditionFailure()`)。

何时使用 preconditionFailure()的示例

也可以使用`fatalError()`来代替`preconditionFailure()`。但`preconditionFailure()`明确表示是因为参数，而`fatalError()`则更笼统。所以唯一的区别是使用的上下文。

## 维护

像`precondition()`一样，`assert()`函数检查一个值，并在否定的情况下使应用崩溃。然而，这只会发生在调试版本中，而不会发生在发布版本中。所以如果你传递了一个类似`assert(isStateSet())`的函数，那么这个函数只在开发过程中执行——而不是在生产应用中。

如果`isStateSet()`执行一个耗时的计算，那么它不在生产应用程序中运行可能是有意义的。然而，如果`isStateSet()`确实有副作用，那么这只会发生在开发过程中——而不会发生在生产应用中——然后人们会想为什么完成的应用与开发过程中的行为不同。所以你必须确保`assert()`没有副作用。

如果函数参数用`precondition()`，什么时候用`assert()`？实际上，仅用于在您自己的代码块中进行检查(例如，如果您当前正在自己计算一些东西，并且想要确保您已经正确地计算了一些东西，并且它仍然在值的范围内)。如果以后有人更改了代码，`assert()`会确保这种更改仍然受原始条件的约束(即防止未来的自己忘记原来的假设)。

何时使用 assert()的示例

但是如果在一个发布版本中`aPositiveNumber`变成负数会发生什么呢？如果计算使用该类的属性，则可能会发生这种情况。正常情况下，这些值应该总是包含正值，但是如果出现了错误，它们就会突然变成负值。因为`assert()`不会在发布版本中触发，所以工作会以一个不正确的值继续。结果是不确定的，错误是长期的。

这就是为什么我建议不要使用`assert()`而总是使用`guard`和`fatalError()`:

如何用 fatalError()替换 assert()的示例

但是如果绝对要用`assert`，要注意以下几点:

1.  切勿在`assert`的闭合参数中产生副作用。否则，对于调试版本和发布版本，应用程序的行为可能会有所不同。
2.  仅在`assert`的闭合参数中使用常量。否则，不会捕捉到只发生在发布版本中的错误。

例如，`assert`的一个有意义的用例是，如果你想确保所有的资源都捆绑在应用中。资源是在编译时进入应用程序的常量，在运行时不会改变。加载和检查这些文件可能非常耗时。如果您在调试版本的应用程序启动时这样做一次，您可以确定您没有忘记添加资源。然而，在发布版本中，您可以节省时间并跳过这个检查。

## 断言失败

正如`preconditionFailure()`与`precondition()`相关一样，`assertionFailure()`与`assert()`相关。`assertionFailure()`不检查任何东西，只在调试版本中崩溃应用程序。与`assert()`一样，可能会出现未定义状态的问题，这在发布版本中会延长。

由于`assertionFailure()`甚至不检查任何东西(也就是说，无论如何你必须事先执行检查)，你失去了在发布版本中不执行代码的罕见优势。这就引出了`assertionFailure()`有用性的问题。

然而，实际上有一个用例:您有一个服务器，并希望从它那里得到错误结果的通知。

起初，这听起来更像是一种意外的服务行为。毕竟，我们在这里讨论的是一个服务，一个服务总是能提供意想不到的价值。

然而，这项服务是你的责任，如果它不能正常工作，你会想知道。单元测试实际上应该在服务器上使用，以确保其 API 的正确性，并防止此类错误。然而，单元测试可能是不完整的(编程错误)，当然，如果您在应用程序中有第二个安全网，这是很好的。

因此，使用`assertionFailure()`调用是合理的，例如，在`guard`之后，因为它会立即通知您服务器及其单元测试有故障。如果不是你自己的服务器，你可能不会用一个`assertionFailure()`，但在这里是有道理的。

何时使用 assertionFailure()的示例

# 结论

如果可能的话，应用程序应该恢复状态。然而，在编程错误的情况下，这通常是不可能的。那么应用程序应该尽早崩溃，这样错误就不会被延迟，开发者就有更好的机会找到并纠正错误。

我已经在上面展示了哪些工具可以在何时以及如何使用。有时候你想稍微弯曲一下。例如，如果您想在崩溃前将错误和应用程序状态发送到跟踪服务，那么崩溃应该延迟一点。但是延期不是取消！