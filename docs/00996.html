<html>
<head>
<title>Swift: Why You Should Avoid Using Default Implementations in Protocols</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Swift:为什么您应该避免在协议中使用默认实现</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/swift-why-you-should-avoid-using-default-implementations-in-protocols-eeffddbed46d?source=collection_archive---------4-----------------------#2019-08-05">https://betterprogramming.pub/swift-why-you-should-avoid-using-default-implementations-in-protocols-eeffddbed46d?source=collection_archive---------4-----------------------#2019-08-05</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="cbe2" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">继承之上的组合、接口分离原则、方法调度和单元测试</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/d5b84701041f595339bb1741776b3778.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*HH3hOXVl7pMK_LBjG36PRQ.jpeg"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated"><a class="ae ky" href="https://unsplash.com/@agkdesign?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">亚历山大·奈特</a>在<a class="ae ky" href="https://unsplash.com/search/photos/laptop?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍照</p></figure><p id="026a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">因为不使用它们的理由超过了这样做的好处。让我们来看看其中的一些:</p><ul class=""><li id="2f52" class="lv lw it lb b lc ld lf lg li lx lm ly lq lz lu ma mb mc md bi translated">继承之上的组合和界面分离原则。</li><li id="2c4e" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated">协议的方法分派。</li><li id="a1f7" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated">单元测试。</li></ul></div><div class="ab cl mj mk hx ml" role="separator"><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo"/></div><div class="im in io ip iq"><h1 id="5951" class="mq mr it bd ms mt mu mv mw mx my mz na jz nb ka nc kc nd kd ne kf nf kg ng nh bi translated">协议默认实现</h1><p id="9277" class="pw-post-body-paragraph kz la it lb b lc ni ju le lf nj jx lh li nk lk ll lm nl lo lp lq nm ls lt lu im bi translated">如<a class="ae ky" href="https://docs.swift.org/swift-book/LanguageGuide/Protocols.html" rel="noopener ugc nofollow" target="_blank"> Swift文档</a>所述:</p><blockquote class="nn"><p id="333c" class="no np it bd nq nr ns nt nu nv nw lu dk translated">"您可以使用协议扩展为该协议的任何方法或计算属性要求提供默认实现。"</p></blockquote><p id="fd11" class="pw-post-body-paragraph kz la it lb b lc nx ju le lf ny jx lh li nz lk ll lm oa lo lp lq ob ls lt lu im bi translated">事实上，您不仅可以为协议中定义的方法或计算属性提供默认实现，还可以添加新的实现。</p><p id="c91c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们看一个例子:</p><pre class="kj kk kl km gt oc od oe of aw og bi"><span id="d4e3" class="oh mr it od b gy oi oj l ok ol">protocol SampleProtocol {<br/>  func foo()<br/>}</span><span id="6c97" class="oh mr it od b gy om oj l ok ol">extension SampleProtocol {<br/>  func foo() {<br/>    print("foo")<br/>  }<br/>  func bar() {<br/>    print("bar")<br/>  }<br/>}</span><span id="5dea" class="oh mr it od b gy om oj l ok ol">class SampleClass: SampleProtocol {}</span><span id="3f3a" class="oh mr it od b gy om oj l ok ol">let sample: SampleProtocol = SampleClass()<br/>sample.foo() <strong class="od iu">// prints "foo"</strong><br/>sample.bar() <strong class="od iu">// prints "bar"</strong></span></pre></div><div class="ab cl mj mk hx ml" role="separator"><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo"/></div><div class="im in io ip iq"><h1 id="5142" class="mq mr it bd ms mt mu mv mw mx my mz na jz nb ka nc kc nd kd ne kf nf kg ng nh bi translated">偏爱合成而非遗传</h1><p id="6412" class="pw-post-body-paragraph kz la it lb b lc ni ju le lf nj jx lh li nk lk ll lm nl lo lp lq nm ls lt lu im bi translated">在我看来，你需要一个方法或计算属性的默认实现的事实是一个<a class="ae ky" href="https://martinfowler.com/bliki/CodeSmell.html" rel="noopener ugc nofollow" target="_blank"> <em class="on">代码闻</em> </a>。</p><p id="a2fe" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果你不熟悉这个术语，代码味道是指代码中的某种东西，可能表明更深层次的问题。</p><p id="7d47" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">您认为需要使用这种方法可能还有其他原因，但最有可能的原因是为了避免代码重复。如果是这样的话，你将会做一些类似于子类化一个<em class="on">抽象</em> <em class="on"> BaseX </em>类的事情，这并不是最好的方法。</p><p id="2d58" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">根据OOP原则，为了这个目的，你应该<em class="on">更喜欢组合而不是继承</em>。</p><p id="fceb" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">继承更加严格，避免了在运行时注入或更改具体的实现，破坏了封装，降低了代码的可读性，使测试更加困难，等等。</p><p id="61f9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我在<a class="ae ky" href="https://medium.com/better-programming/swift-favor-composition-over-inheritance-the-baseviewcontroller-case-f598064bda6" rel="noopener">的另一篇文章</a>中谈到这个话题。</p></div><div class="ab cl mj mk hx ml" role="separator"><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo"/></div><div class="im in io ip iq"><h1 id="51da" class="mq mr it bd ms mt mu mv mw mx my mz na jz nb ka nc kc nd kd ne kf nf kg ng nh bi translated">界面分离原理</h1><p id="cc17" class="pw-post-body-paragraph kz la it lb b lc ni ju le lf nj jx lh li nk lk ll lm nl lo lp lq nm ls lt lu im bi translated">您需要使用默认实现的另一个原因是您错过了Objective-C协议中的可选方法。您可能希望提供一个默认的实现作为替代。</p><p id="f3df" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">同样，这可能不是最好的方法。接口分离原则是五个坚实的原则之一，并且声明<em class="on">任何客户端都不应该被迫依赖于它不使用的方法</em>。</p><p id="3679" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">简而言之:如果是这样的话，把你的协议分成几个小的部分。</p></div><div class="ab cl mj mk hx ml" role="separator"><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo"/></div><div class="im in io ip iq"><h1 id="4b31" class="mq mr it bd ms mt mu mv mw mx my mz na jz nb ka nc kc nd kd ne kf nf kg ng nh bi translated">方法分派</h1><p id="70bb" class="pw-post-body-paragraph kz la it lb b lc ni ju le lf nj jx lh li nk lk ll lm nl lo lp lq nm ls lt lu im bi translated">如果我们回到本文的第一个例子，并试图覆盖协议的默认实现，让我们看看会发生什么:</p><pre class="kj kk kl km gt oc od oe of aw og bi"><span id="5bbe" class="oh mr it od b gy oi oj l ok ol">protocol SampleProtocol {<br/>    func foo()<br/>}<br/>extension SampleProtocol {<br/>    func foo() {<br/>        print("protocol foo")<br/>    }<br/>    func bar() {<br/>        print("protocol bar")<br/>    }<br/>}</span><span id="c862" class="oh mr it od b gy om oj l ok ol">class SampleClass: SampleProtocol {<br/>    func foo() {<br/>        print("class foo")<br/>    }<br/>    func bar() {<br/>        print("class bar")<br/>    }<br/>}</span><span id="9670" class="oh mr it od b gy om oj l ok ol">let sample: SampleProtocol = SampleClass()<br/>sample.foo() <strong class="od iu">// prints "class foo"</strong><br/>sample.bar() <strong class="od iu">// prints "protocol bar"</strong></span></pre><p id="ce6c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我重复一遍:<code class="fe oo op oq od b">Sample.bar()</code>打印<code class="fe oo op oq od b">“protocol bar”</code>。</p><p id="327f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果您或任何阅读您代码的人不熟悉Swift中方法分派的工作方式，这是非常违反直觉的。</p><p id="1e0a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">并且，它也是难以发现的bug的来源。</p><p id="ac9b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这就是为什么会这样:</p><p id="0258" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe oo op oq od b">SampleProtocol</code>定义了两种方法:<code class="fe oo op oq od b">foo()</code> <em class="on">，</em>在协议中定义为需求，<code class="fe oo op oq od b">bar()</code>在扩展中定义。</p><p id="8afd" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">协议要求的方法使用动态分派，它选择在运行时执行的方法实现。</p><p id="9a7e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">扩展定义的方法使用静态分派，静态分派选择在构建时执行的方法实现。这意味着使用的唯一实现将是扩展的实现。而且，你不能覆盖它。</p></div><div class="ab cl mj mk hx ml" role="separator"><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo"/></div><div class="im in io ip iq"><h1 id="d344" class="mq mr it bd ms mt mu mv mw mx my mz na jz nb ka nc kc nd kd ne kf nf kg ng nh bi translated">调度优先级和约束</h1><p id="8a3b" class="pw-post-body-paragraph kz la it lb b lc ni ju le lf nj jx lh li nk lk ll lm nl lo lp lq nm ls lt lu im bi translated">在方法分派问题之后，如果使用约束，还有另一件事需要考虑:</p><pre class="kj kk kl km gt oc od oe of aw og bi"><span id="aaa2" class="oh mr it od b gy oi oj l ok ol">protocol SampleProtocol {<br/>    func foo()<br/>}<br/>extension SampleProtocol {<br/>    func foo() {<br/>        print("SampleProtocol")<br/>    }<br/>}</span><span id="687b" class="oh mr it od b gy om oj l ok ol">protocol BarProtocol {}<br/>extension SampleProtocol <strong class="od iu">where Self: BarProtocol</strong> {<br/>    func foo() {<br/>        print("BarProtocol")<br/>    }<br/>}</span><span id="e45d" class="oh mr it od b gy om oj l ok ol">class SampleClass: SampleProtocol, <strong class="od iu">BarProtocol</strong> {}</span><span id="7837" class="oh mr it od b gy om oj l ok ol">let sample: SampleProtocol = SampleClass()<br/>sample.foo() <strong class="od iu">// prints "BarProtocol"</strong></span></pre><p id="b931" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">您可以使用约束来覆盖默认实现(只要它们是协议所要求的)。并且受约束的默认实现优先于不受约束的实现。</p><p id="f2c1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">所以优先级应该是:<em class="on">符合协议的类/结构/枚举- &gt;约束协议扩展- &gt;简单协议扩展</em>。</p><p id="6def" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">同样，您可能已经知道这一点，但是对于阅读、修改或调试您的代码的任何人来说，这肯定是令人困惑的。</p></div><div class="ab cl mj mk hx ml" role="separator"><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo"/></div><div class="im in io ip iq"><h1 id="3d57" class="mq mr it bd ms mt mu mv mw mx my mz na jz nb ka nc kc nd kd ne kf nf kg ng nh bi translated">单元测试</h1><p id="7228" class="pw-post-body-paragraph kz la it lb b lc ni ju le lf nj jx lh li nk lk ll lm nl lo lp lq nm ls lt lu im bi translated">假设您正在为您的代码编写测试，注入依赖项，并使用模拟，您会发现尝试两者都有困难:用默认实现模拟协议并测试那些默认实现。</p><p id="a3df" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">当您试图用默认实现模仿协议时，您将遇到方法分派问题，因此，您将无法模仿扩展定义的方法:</p><pre class="kj kk kl km gt oc od oe of aw og bi"><span id="f6ae" class="oh mr it od b gy oi oj l ok ol">protocol DependencyProtocol {}<br/>extension DependencyProtocol {<br/>    func foo() -&gt; Int {<br/>        return 0<br/>    }<br/>}</span><span id="663f" class="oh mr it od b gy om oj l ok ol">class SampleClass {<br/>    let dependency: DependencyProtocol<br/>    init(dependency: DependencyProtocol) {<br/>        self.dependency = dependency<br/>    }<br/>    <br/><strong class="od iu">    // You will never be able to mock dependency.foo()</strong><br/>    func sampleMethod() {<br/>        let dependencyValue = dependency.foo()<br/>        print(dependencyValue)<br/>    }<br/>}</span></pre><p id="f4da" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">此外，您可能会发现很难检测何时何地用默认实现模拟新添加的方法，因为编译器不会抱怨这一点。</p><p id="80fc" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">您可能最终会在其他类的测试中包含默认的实现，而不是模拟的方法。</p><p id="9e39" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">测试默认实现不是一个小问题，因为您必须编码并实例化一个符合协议的虚拟类，这样您就可以调用这些方法。</p><p id="3adc" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这个伪类必须实现所有那些没有默认实现的协议要求的方法。</p><pre class="kj kk kl km gt oc od oe of aw og bi"><span id="ee7f" class="oh mr it od b gy oi oj l ok ol">protocol SampleProtocol {<br/>    func same(input: Int) -&gt; Int<br/>}<br/>extension SampleProtocol {<br/>    func double(input: Int) -&gt; Int {<br/>        return input * input<br/>    }<br/>}</span><span id="5a5e" class="oh mr it od b gy om oj l ok ol"><strong class="od iu">// You need a dummy class so you can call protocol default implementations</strong><br/>class SampleProtocolDummy: SampleProtocol {</span><span id="76c0" class="oh mr it od b gy om oj l ok ol"><strong class="od iu">    // You need to implement notimplemented-required-methods with dummy code</strong><br/>    func same(input: Int) -&gt; Int {<br/>        return 0<br/>    }</span><span id="1f10" class="oh mr it od b gy om oj l ok ol">}</span><span id="40df" class="oh mr it od b gy om oj l ok ol">let sut: SampleProtocol = SampleProtocolDummy()</span><span id="1358" class="oh mr it od b gy om oj l ok ol">let result = sut.double(input: 2)</span><span id="8c63" class="oh mr it od b gy om oj l ok ol">XCTAssertEqual(expectedResult, result)</span></pre></div><div class="ab cl mj mk hx ml" role="separator"><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo"/></div><div class="im in io ip iq"><p id="140d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">感谢阅读！如果你喜欢这篇文章，请鼓掌:)</p></div></div>    
</body>
</html>