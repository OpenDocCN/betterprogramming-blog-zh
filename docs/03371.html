<html>
<head>
<title>Identify Similarities Between Sentences in Python</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">识别Python中句子之间的相似之处</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/identify-similarities-between-sentences-in-python-e9f71d454d1d?source=collection_archive---------13-----------------------#2020-02-05">https://betterprogramming.pub/identify-similarities-between-sentences-in-python-e9f71d454d1d?source=collection_archive---------13-----------------------#2020-02-05</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="0218" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">基于Jaccard相似性和最小散列值实现您自己的相似性匹配函数</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/e9ee9d0f01bac5a4333bd8292942ed21.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*WUnL_eywqnewZB3uTRyu4A.jpeg"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">照片由<a class="ae ky" href="https://unsplash.com/@fiteka?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">拉奎尔·马丁内斯</a>在<a class="ae ky" href="https://unsplash.com/s/photos/compare?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>拍摄</p></figure><p id="e8b0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">通过阅读这篇文章，您将学会编写一个简单的相似性匹配函数来计算两个输入字符串之间的相似性。</p><p id="c0e2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe lv lw lx ly b">MinHash</code>是数据挖掘和计算机科学中经常使用的一种技术，用于快速估计两个集合之间的相似性。它经常被用于数据聚类和最近邻搜索。大多数情况下，Jaccard相似系数用于此技术。Jaccard指数可以被定义为它们的交集的元素的数量与它们的并集的元素的数量的比率。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi lz"><img src="../Images/8f7840cb5f3020d4fd589712e4f9edad.png" data-original-src="https://miro.medium.com/v2/resize:fit:346/format:webp/1*YZB0bZAGl0VmbS-YrJSVoQ.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">图片来源:<a class="ae ky" href="https://en.wikipedia.org/wiki/MinHash" rel="noopener ugc nofollow" target="_blank">维基百科</a></p></figure><p id="307c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">当两个集合是不相交的集合时，该值将为0-表示它们之间没有相似之处。如果两个集合之间没有交集，则称它们为不相交的集合。换句话说，两个集合的交集是一个空集。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi ma"><img src="../Images/9e2dd13bf204ac4f37c30b5a1a10d569.png" data-original-src="https://miro.medium.com/v2/resize:fit:440/format:webp/0*oxJC7q17mg2k2Syk.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">图片来源:<a class="ae ky" href="https://en.wikipedia.org/wiki/Disjoint_sets" rel="noopener ugc nofollow" target="_blank">维基百科</a></p></figure><p id="da11" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在上面给出的例子中，集合A和集合B是不相交的集合。同样，如果两个集合完全相等，则值将为1。最终值将始终介于0和1之间。我们将使用这种技术来实现两个输入句子之间的相似性匹配功能。一个主要优点是它适用于所有语言，因为比较是基于标记化的字符串。</p></div><div class="ab cl mb mc hx md" role="separator"><span class="me bw bk mf mg mh"/><span class="me bw bk mf mg mh"/><span class="me bw bk mf mg"/></div><div class="im in io ip iq"><h1 id="7e16" class="mi mj it bd mk ml mm mn mo mp mq mr ms jz mt ka mu kc mv kd mw kf mx kg my mz bi translated">履行</h1><h2 id="bc74" class="na mj it bd mk nb nc dn mo nd ne dp ms li nf ng mu lm nh ni mw lq nj nk my nl bi translated">Minhash函数</h2><p id="4ee2" class="pw-post-body-paragraph kz la it lb b lc nm ju le lf nn jx lh li no lk ll lm np lo lp lq nq ls lt lu im bi translated">在Python文件中创建一个名为<code class="fe lv lw lx ly b">minhash</code>的新函数。这个函数接受两个输入字符串参数。我就把它们命名为<code class="fe lv lw lx ly b">input_question</code>和<code class="fe lv lw lx ly b">compare_question</code>。你可以随意给它们起任何你喜欢的名字。</p><pre class="kj kk kl km gt nr ly ns nt aw nu bi"><span id="0163" class="na mj it ly b gy nv nw l nx ny">def minhash(input_question, compare_question):</span></pre><p id="22c8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">初始化一个分数变量，并将其设置为0。</p><pre class="kj kk kl km gt nr ly ns nt aw nu bi"><span id="d876" class="na mj it ly b gy nv nw l nx ny">score = 0.0</span></pre><h2 id="6a74" class="na mj it bd mk nb nc dn mo nd ne dp ms li nf ng mu lm nh ni mw lq nj nk my nl bi translated">将文本拆分成元素</h2><p id="5753" class="pw-post-body-paragraph kz la it lb b lc nm ju le lf nn jx lh li no lk ll lm np lo lp lq nq ls lt lu im bi translated">然后，我们编写下面的匿名函数，将输入文本转换成三个字符的元素。</p><pre class="kj kk kl km gt nr ly ns nt aw nu bi"><span id="f811" class="na mj it ly b gy nv nw l nx ny">shingles = lambda s: set(s[i:i+3] for i in range(len(s)-2))</span></pre><p id="d916" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">请注意，这个匿名函数是基于jProcessing模块下的原始实现的。当涉及到像汉语和日语这样的语言时，这是一个大问题，因为一个单词可能只由一个字符组成。</p><p id="e180" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果长度小于3，您可以通过实现自己的方法来解决这个问题，将文本拆分成元素，或者在输入文本中填充额外的空格。</p><p id="a725" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">您可以通过运行以下代码来测试结果:</p><pre class="kj kk kl km gt nr ly ns nt aw nu bi"><span id="41cc" class="na mj it ly b gy nv nw l nx ny">shingles = lambda s: set(s[i:i+3] for i in range(len(s)-2))</span><span id="20eb" class="na mj it ly b gy nz nw l nx ny">print(shingles('Hello, there ! How are you ?'), shingles('早 上 好 ， 在 干 嘛 呢 ？'))</span></pre><p id="dcd4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">您应该会得到以下结果。顺序可能不同，但是如果使用相同的输入，元素应该是相同的。</p><pre class="kj kk kl km gt nr ly ns nt aw nu bi"><span id="0d12" class="na mj it ly b gy nv nw l nx ny">{'lo,', 'you', 'u ?', 'o, ', ' th', 'are', 'the', 'ere', 're ', 'w a', 'ou ', 'How', ' Ho', ', t', 'ow ', 'e !', 'llo', '! H', ' ar', 'e y', ' yo', 'Hel', 'ell', ' ! ', 'her'} {' 呢 ', '早 上', '， 在', '干 嘛', '上 好', ' 干 ', ' 好 ', '呢 ？', '在 干', ' 在 ', '好 ，', '嘛 呢', ' 上 ', ' 嘛 ', ' ， '}</span></pre><h2 id="ab40" class="na mj it bd mk nb nc dn mo nd ne dp ms li nf ng mu lm nh ni mw lq nj nk my nl bi translated">计算雅克卡距离</h2><p id="76a4" class="pw-post-body-paragraph kz la it lb b lc nm ju le lf nn jx lh li no lk ll lm np lo lp lq nq ls lt lu im bi translated">下一步是根据上面给出的公式计算Jaccard距离。创建一个接受两个输入的匿名函数。</p><pre class="kj kk kl km gt nr ly ns nt aw nu bi"><span id="feb3" class="na mj it ly b gy nv nw l nx ny">jaccard_distance = lambda seta, setb: len(seta &amp; setb)/float(len(seta | setb))</span></pre><p id="ac9b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">一旦你完成了，我们将开始实现主要代码。建议将其包装在一个<code class="fe lv lw lx ly b">try except</code>调用中。</p><pre class="kj kk kl km gt nr ly ns nt aw nu bi"><span id="118a" class="na mj it ly b gy nv nw l nx ny">try:<br/>    score = jaccard_distance(shingles(input_question), shingles(compare_question))<br/>except ZeroDivisionError:<br/>    print('ZeroDivisionError')</span></pre><p id="9bab" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">最后一步是返回分数。</p><pre class="kj kk kl km gt nr ly ns nt aw nu bi"><span id="e3b2" class="na mj it ly b gy nv nw l nx ny">return score</span></pre><p id="ef32" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">您的最终功能应该如下所示:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oa ob l"/></div></figure><h2 id="9495" class="na mj it bd mk nb nc dn mo nd ne dp ms li nf ng mu lm nh ni mw lq nj nk my nl bi translated">结果</h2><p id="89a5" class="pw-post-body-paragraph kz la it lb b lc nm ju le lf nn jx lh li no lk ll lm np lo lp lq nq ls lt lu im bi translated">让我们测试一下这个函数，看看两个输入句子之间的相似性。</p><pre class="kj kk kl km gt nr ly ns nt aw nu bi"><span id="1012" class="na mj it ly b gy nv nw l nx ny">print(minhash('welcome to medium', 'medium is a publishing platform'))</span><span id="0193" class="na mj it ly b gy nz nw l nx ny">print(minhash('i have a cat', 'i have a dog'))</span></pre><p id="dcaa" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我得到了以下结果:</p><pre class="kj kk kl km gt nr ly ns nt aw nu bi"><span id="96df" class="na mj it ly b gy nv nw l nx ny">0.1<br/>0.5384615384615384</span></pre><h2 id="21cf" class="na mj it bd mk nb nc dn mo nd ne dp ms li nf ng mu lm nh ni mw lq nj nk my nl bi translated">区分大小写</h2><p id="0bd5" class="pw-post-body-paragraph kz la it lb b lc nm ju le lf nn jx lh li no lk ll lm np lo lp lq nq ls lt lu im bi translated">我们刚刚实现的函数是区分大小写的。这意味着大小写会影响相似性匹配的结果。最好的方法是在调用<code class="fe lv lw lx ly b">minhash</code>函数之前将大小写降低为小写。</p><pre class="kj kk kl km gt nr ly ns nt aw nu bi"><span id="6736" class="na mj it ly b gy nv nw l nx ny">input = 'Welcome to Medium'<br/>compare = 'Medium is a publishing platform'</span><span id="c11e" class="na mj it ly b gy nz nw l nx ny">print(minhash(input.lower(), compare.lower()))</span></pre><h2 id="4ae5" class="na mj it bd mk nb nc dn mo nd ne dp ms li nf ng mu lm nh ni mw lq nj nk my nl bi translated">支持其他语言</h2><p id="97dd" class="pw-post-body-paragraph kz la it lb b lc nm ju le lf nn jx lh li no lk ll lm np lo lp lq nq ls lt lu im bi translated">理论上，我们的函数支持所有类型的语言，因为它是基于字符串比较的。但是，如果您处理的是不能用空格标记的语言，您需要自己标记它。最简单的方法是实现一个简单的字符标记化。</p><pre class="kj kk kl km gt nr ly ns nt aw nu bi"><span id="40cd" class="na mj it ly b gy nv nw l nx ny">def tokenize(text):<br/>    result = [elem for elem in text]<br/>    return ' '.join(result)</span></pre><p id="4ddd" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在以下中文输入上调用<code class="fe lv lw lx ly b">tokenize</code>功能…</p><pre class="kj kk kl km gt nr ly ns nt aw nu bi"><span id="1ab5" class="na mj it ly b gy nv nw l nx ny">print(tokenize('新年快乐！祝福您和家人身体健康'))</span></pre><p id="391f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">…将产生以下结果:</p><pre class="kj kk kl km gt nr ly ns nt aw nu bi"><span id="69ec" class="na mj it ly b gy nv nw l nx ny">新 年 快 乐 ！ 祝 福 您 和 家 人 身 体 健 康</span></pre><p id="1c15" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们来测试一下:</p><pre class="kj kk kl km gt nr ly ns nt aw nu bi"><span id="0c30" class="na mj it ly b gy nv nw l nx ny">print(minhash(tokenize('新年快乐！祝福您和家人身体健康'), tokenize('新年快乐！红包拿来！')))</span></pre><p id="8f6a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">控制台的输出应该如下所示:</p><pre class="kj kk kl km gt nr ly ns nt aw nu bi"><span id="fdd6" class="na mj it ly b gy nv nw l nx ny">0.2222222222222222</span></pre></div><div class="ab cl mb mc hx md" role="separator"><span class="me bw bk mf mg mh"/><span class="me bw bk mf mg mh"/><span class="me bw bk mf mg"/></div><div class="im in io ip iq"><h1 id="7a12" class="mi mj it bd mk ml mm mn mo mp mq mr ms jz mt ka mu kc mv kd mw kf mx kg my mz bi translated">结论</h1><p id="9c9c" class="pw-post-body-paragraph kz la it lb b lc nm ju le lf nn jx lh li no lk ll lm np lo lp lq nq ls lt lu im bi translated">让我们回顾一下今天所学的内容。</p><p id="775b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们从简单解释<code class="fe lv lw lx ly b">minhash</code>和Jaccard距离开始。我们学习了它背后的基本概念和计算Jaccard相似系数的公式。</p><p id="45ff" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">之后，我们开始实现自己的自定义功能。我们通过匿名函数将输入文本分成三个字符的元素。随后，我们创建了另一个匿名函数来计算Jaccard距离。</p><p id="8f56" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">此外，我们详细探讨了区分大小写的问题，以及通过在调用<code class="fe lv lw lx ly b">minhash</code>函数之前将文本转换为小写来解决这个问题的方法。为了支持不能被空格标记的语言，我们实现了一个简单的字符标记。</p><p id="86e8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">感谢阅读，我希望你喜欢它。下一篇再见！</p></div><div class="ab cl mb mc hx md" role="separator"><span class="me bw bk mf mg mh"/><span class="me bw bk mf mg mh"/><span class="me bw bk mf mg"/></div><div class="im in io ip iq"><h1 id="7a50" class="mi mj it bd mk ml mm mn mo mp mq mr ms jz mt ka mu kc mv kd mw kf mx kg my mz bi translated">参考</h1><ol class=""><li id="639e" class="oc od it lb b lc nm lf nn li oe lm of lq og lu oh oi oj ok bi translated"><a class="ae ky" href="https://github.com/kevincobain2000/jProcessing/blob/master/src/jNlp/jProcessing.py" rel="noopener ugc nofollow" target="_blank"> jProcessing的GitHub页面</a></li><li id="97c7" class="oc od it lb b lc ol lf om li on lm oo lq op lu oh oi oj ok bi translated"><a class="ae ky" href="https://en.wikipedia.org/wiki/MinHash" rel="noopener ugc nofollow" target="_blank">米纳什的维基百科页面</a></li></ol></div></div>    
</body>
</html>