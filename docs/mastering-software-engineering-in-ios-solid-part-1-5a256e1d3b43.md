# 掌握 iOS 中的软件工程:单一责任原则

> 原文：<https://betterprogramming.pub/mastering-software-engineering-in-ios-solid-part-1-5a256e1d3b43>

## SRP:软件开发基础易于解释

![](img/c2726b27b25a93aad62883e910b86072.png)

[博伊图梅洛·菲特拉](https://unsplash.com/@writecodenow?utm_source=medium&utm_medium=referral)在 [Unsplash](https://unsplash.com?utm_source=medium&utm_medium=referral) 上的照片

# 介绍

在这一系列文章中，我将尝试在 iOS 开发的背景下布局好的软件工程基础。

那么就从每次求职面试都会提到的话题开始:*扎实*原则。

# 固体

*SOLID* 是 Bob 叔叔[提出的 5 个原则的首字母缩写，这些原则是编写好的面向对象代码的基础:](https://en.wikipedia.org/wiki/Robert_C._Martin)

*   单一责任原则
*   开闭原理
*   利斯科夫替代原理
*   界面分离原理
*   从属倒置原则

也许你已经听说过那些原则，甚至还记得它们。但是如果我向你要一个例子，你能为每个原则写一个代码，然后解释它吗？

这就是大多数人的问题所在:在日常的实际使用中。为了写出好的代码，你需要理解为什么坏代码是坏的。为了让你们了解全貌，我将:

*   给出每个*固体*原理的简单定义
*   举一个糟糕的代码的例子，它在某种程度上破坏了所讨论的原则
*   解释为什么这个原则在给定的例子中被打破
*   重构代码，因此该示例符合所讨论的原则
*   解释为什么现在它符合它

我将向大家展示的每个例子都将在 *Swift Playground* 中发挥作用

为了使这篇文章的篇幅合理，我将按每部分的每个*固体*原理来拆分。所以还是从第一个开始吧！

# 单一责任原则

> *“一个类应该只有一个改变的理由”*

这条规则说的是一个给定的类应该只有一个存在的理由，因此也应该只有一个改变它的理由。

当创建一个类时，你应该严格定义它是什么*存在的理由*并坚持下去。开设有一个特定目的的课程，这样你就清楚了。

## 示例 1

让我们看一个非常简单的例子，这个类应该发送带有附件的电子邮件:

类`EmailSender`打破了*单一责任原则*，因为有 2 个原因要改变它:

1.  发送电子邮件逻辑的任何改变都需要改变`EmailSender`类。
2.  我们从操作系统加载文件的逻辑的改变也需要改变`EmailSender`类。

只有第一个改变的原因是有意义的。发送电子邮件本身不应该与从我们的操作系统获取文件有任何关系。应该拥有发送电子邮件所需的所有数据，并且不应该关心这些数据是如何获得的。

编译成*单一责任原则*的示例如下所示:

现在有两个班，每个班只有一个责任。`FileReader`处理文件，`EmailSender`发送电子邮件(不管附件是如何创建的)。

## 示例 2

前面的例子以一种非常简单的方式打破了 SRP，但是在现实生活中，人们倾向于以一种更加微妙的方式打破它。下面的例子乍一看似乎是正确的，但是当你仔细观察时，你会发现它实际上违反了 SRP。

设想一个酒店应用程序，它保存房间预订、客人的个人信息、房间细节(床位数、浴室数等)。).

一个典型的违反单一责任原则的真实例子应该是这样的:

如果酒店老板为其中一个房间购买了空调，存储这些信息将会改变`Room`类的实现，这是完全可以理解的。

假设有一项新的法律，禁止酒店收集顾客的年龄数据。为了实现这个改变，我们需要改变`Room`和`Guest`两个类。为什么从我们的应用程序中删除客人的年龄会影响到`Room`类的实现？！类`Room`打破了*单一责任原则*，因为有 2 个原因要改变它:

1.  酒店房间逻辑的任何改变都需要改变`Room`类。比如:加空调。
2.  创建 guest 的逻辑的变化也需要在`addGuestThatWillOccupyTheRoom(guestFirstName:guestLastName:age:)`方法中的`Room`类的变化。

正如你所看到的，所需要做的只是在一个错误的地方调用一个构造函数，创建一个有不止一个理由要改变的类。

符合*单一责任原则*的示例如下:

现在我们已经通过移除`Guest`的构造函数调用，使`addGuestToTheRoom(guest:)`的实现独立于`Guest`的实现。

这种方式的`addGuestToTheRoom(guest:)`方法并不真正关心`Guest`对象是如何创建的。只要将`Guest`对象(不管它是如何初始化的)传递给它，它就会工作。

所以现在我们在法律上的改变完全可以在不影响`Room`类的情况下实现，因为现在它只有一个改变的理由(房间逻辑本身)。

## 如何定义改变的理由？

并不是每个例子都像我们的电子邮件和酒店应用程序那样黑白分明。如果一个类存在的理由足够广泛，我们总是可以假装我们只有一个理由去改变它。

你可以创建一个类`DataManager`，而不是两个独立的类:`InputReader`和`OutputWriter`。输入和输出都将由`DataManager`管理。这个类显然有两个改变的理由(处理输入和处理输出)，但是用我们巧妙的措辞看起来只有一个理由:数据管理。这可以说仍然是一个糟糕的设计选择！

但是这是双向的:太具体了，你会得到数百个可笑的相互关联的类，这很容易成为一个。

看一下`String`结构。它做了很多，但所有这些在一个给定的上下文中都是有意义的。我们不希望有像`StringCapitalizer`、`StringUppercaser`、`StringLowercasser`这样过于专门化的结构/类。那太荒谬了！

因此，类及其存在(和变化)的原因应该足够专门化。精细平衡是这里的关键。

考虑到这一点，原来的原则也可以([和被！](https://8thlight.com/blog/uncle-bob/2014/05/08/SingleReponsibilityPrinciple.html))这样措辞:

> *“把因为相同原因而改变的东西聚集在一起。把那些因为不同原因而改变的东西分开。”*

# 原来如此！

现在你已经知道了*单一责任原则*的全部内容，并且应该能够自己想出例子来！

值得注意的是，有时术语“软件模块”被用来代替“类”，以使这个原则更加通用。