<html>
<head>
<title>A Gentle Explanation of Logarithmic Time Complexity</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">对数时间复杂性的温和解释</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/a-gentle-explanation-of-logarithmic-time-complexity-79842728a702?source=collection_archive---------1-----------------------#2019-05-16">https://betterprogramming.pub/a-gentle-explanation-of-logarithmic-time-complexity-79842728a702?source=collection_archive---------1-----------------------#2019-05-16</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="f74e" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">别担心，这比听起来简单</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/2e148a3c6e2b03de5b7ef9e185f9d597.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*UUOHpVsIpWapYfKeXJME5A.jpeg"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">照片由<a class="ae ky" href="https://unsplash.com/@harryxsandhu?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">哈里桑德胡</a>在<a class="ae ky" href="https://unsplash.com/s/photos/time?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>拍摄</p></figure><p id="19ec" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果你是计算机科学的新手，你可能见过类似于<code class="fe lv lw lx ly b">O(n)</code>或<code class="fe lv lw lx ly b">O(log n)</code>的符号。这就是时间复杂度分析或big-O符号！</p><p id="e576" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">为了快速编写代码，理解这个概念非常重要，至少在直觉层面上是如此。还有空间的复杂性。它定义了一个程序可能使用多少内存，但是我们将把它留到下一篇文章中。</p><p id="5d41" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这个概念是高等教育认为需要让计算机科学本科生上几年数学课的原因之一。现在，我并不反对数学课，但是你绝对不需要它们来写好的代码。</p><p id="d859" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">事实是，普通程序员需要了解的所有计算机科学概念本身并不难理解。就像代码本身一样，各个部分都很简单，但是这些部分加起来就复杂得难以理解了。</p></div><div class="ab cl lz ma hx mb" role="separator"><span class="mc bw bk md me mf"/><span class="mc bw bk md me mf"/><span class="mc bw bk md me"/></div><div class="im in io ip iq"><h1 id="c3a2" class="mg mh it bd mi mj mk ml mm mn mo mp mq jz mr ka ms kc mt kd mu kf mv kg mw mx bi translated">n是什么？</h1><blockquote class="my"><p id="26dd" class="mz na it bd nb nc nd ne nf ng nh lu dk translated">"时间复杂度是计算复杂度，描述了运行一个算法所需的时间."— <a class="ae ky" href="https://en.wikipedia.org/wiki/Time_complexity" rel="noopener ugc nofollow" target="_blank">维基百科</a></p></blockquote><p id="1980" class="pw-post-body-paragraph kz la it lb b lc ni ju le lf nj jx lh li nk lk ll lm nl lo lp lq nm ls lt lu im bi translated">这是一个相当罗嗦的定义，让我们来分解一下。</p><p id="f301" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我将讨论四种重要的大O符号。还有其他像<em class="nn"> n log n </em>和<em class="nn"> n factorial </em>这样的方法，但是我们现在不考虑这些。</p><p id="d870" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">假设我们有一个包含五个字母的列表:</p><pre class="kj kk kl km gt no ly np nq aw nr bi"><span id="c0d9" class="ns mh it ly b gy nt nu l nv nw">[a,b,c,d,e]</span></pre><p id="9823" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">因为有五个，所以这里的<em class="nn"> n </em>等于5: <code class="fe lv lw lx ly b">n=5</code>。</p><h2 id="a43d" class="ns mh it bd mi nx ny dn mm nz oa dp mq li ob oc ms lm od oe mu lq of og mw oh bi translated">常数时间或O(1)</h2><p id="ddf6" class="pw-post-body-paragraph kz la it lb b lc oi ju le lf oj jx lh li ok lk ll lm ol lo lp lq om ls lt lu im bi translated">如果你的程序想像这样从你的列表中删除一个字母:</p><pre class="kj kk kl km gt no ly np nq aw nr bi"><span id="9304" class="ns mh it ly b gy nt nu l nv nw">[a,b,c,d,e] =&gt; [a,b,c,d]</span></pre><p id="e9ad" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">它的时间复杂度仅仅是1，因为不管列表中有多少个字母，它总是只需要一次操作。</p><p id="7dc6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">O(1)是最好的时间复杂度！像哈希表这样的数据结构巧妙地利用算法来完成常数时间操作，并大大加快速度。</p><h2 id="f507" class="ns mh it bd mi nx ny dn mm nz oa dp mq li ob oc ms lm od oe mu lq of og mw oh bi translated">线性时间或O(n)</h2><p id="b7a1" class="pw-post-body-paragraph kz la it lb b lc oi ju le lf oj jx lh li ok lk ll lm ol lo lp lq om ls lt lu im bi translated">如果你的程序像这样复制所有的字母:</p><pre class="kj kk kl km gt no ly np nq aw nr bi"><span id="e5ff" class="ns mh it ly b gy nt nu l nv nw">[a,b,c,d,e] =&gt; [aa,bb,cc,dd,ee]</span></pre><p id="bb2d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">对于每个字母，该字母是重复的。程序一次通过一个。</p><p id="1dc1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">你可以说它的运行时间是n阶的，因为它要做的操作数量与你的列表中有多少个字母成正比。这能说明它在实践中会跑多快吗？不完全是。</p><p id="5a79" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">你的输入可以是两个字母，也可以是120亿。它可以在旧的笔记本电脑或超级电脑上运行，运行时间会有很大不同。</p><p id="5f88" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果程序把每个数字加到自己身上三次，而不是两次，它仍然是O(n ),因为即使你的程序每次输入做更多的运算，每次输入多多少是不变的。</p><p id="24fb" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">O(n)是一个合适的时间复杂度，你经常无法避免它。</p><h2 id="0e2e" class="ns mh it bd mi nx ny dn mm nz oa dp mq li ob oc ms lm od oe mu lq of og mw oh bi translated">n阶平方或O(n)</h2><p id="2a69" class="pw-post-body-paragraph kz la it lb b lc oi ju le lf oj jx lh li ok lk ll lm ol lo lp lq om ls lt lu im bi translated">现在，假设您希望您的程序将列表中的每个成员互相添加。</p><pre class="kj kk kl km gt no ly np nq aw nr bi"><span id="21ff" class="ns mh it ly b gy nt nu l nv nw">[a,b,c,d,e] =&gt; [abcde, bacde, cabde, dabce, eabcd]</span></pre><p id="33b3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">因为对于列表中的每一个项<em class="nn">，你也必须遍历列表中剩余的<em class="nn">项</em>，所以你的程序必须执行的操作数是输入数(或n)乘以自身数(n的平方)。</em></p><p id="7f9a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果你的列表中有两个字母，你的程序将运行四次运算。如果你的列表有四万亿个字母，它可能永远也跑不完！</p><p id="6575" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">O(n)几乎从来都不是一个可接受的时间复杂度，你通常可以用某种聪明的算法来避免它。</p><h2 id="1052" class="ns mh it bd mi nx ny dn mm nz oa dp mq li ob oc ms lm od oe mu lq of og mw oh bi translated">对数时间或O(log n)</h2><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi on"><img src="../Images/78321583a24735d6b2ebd25b0ec8492b.png" data-original-src="https://miro.medium.com/v2/resize:fit:896/format:webp/1*z2Alwgh26yPEmDaL2RwXsg.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">matplotlib xkcd样式的图形！</p></figure><p id="c5e1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">查看该图，您可以看到四个运行时是如何伸缩的。</p><p id="b2b5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">橙色二次曲线上升速度极快，而绿色常数保持不变，与输入无关。但是那条蓝色的对数线呢？那看起来几乎和恒定时间一样好！</p></div><div class="ab cl lz ma hx mb" role="separator"><span class="mc bw bk md me mf"/><span class="mc bw bk md me mf"/><span class="mc bw bk md me"/></div><div class="im in io ip iq"><h1 id="615c" class="mg mh it bd mi mj mk ml mm mn mo mp mq jz mr ka ms kc mt kd mu kf mv kg mw mx bi translated">对数</h1><blockquote class="my"><p id="fbe3" class="mz na it bd nb nc nd ne nf ng nh lu dk translated">"一个代表一个固定数(基数)的幂的量，它必须被提高到一定的幂才能产生一个给定的数."— <a class="ae ky" href="https://www.lexico.com/definition/logarithm" rel="noopener ugc nofollow" target="_blank">词典</a></p></blockquote><p id="71e7" class="pw-post-body-paragraph kz la it lb b lc ni ju le lf nj jx lh li nk lk ll lm nl lo lp lq nm ls lt lu im bi translated">如果你从高中起就没想过代数，你会想重温一下对数到底是什么。</p><h2 id="d023" class="ns mh it bd mi nx ny dn mm nz oa dp mq li ob oc ms lm od oe mu lq of og mw oh bi translated">数学来了</h2><p id="46dc" class="pw-post-body-paragraph kz la it lb b lc oi ju le lf oj jx lh li ok lk ll lm ol lo lp lq om ls lt lu im bi translated">当x是指数时，对数用于求解x。看看这个等式:</p><pre class="kj kk kl km gt no ly np nq aw nr bi"><span id="5081" class="ns mh it ly b gy nt nu l nv nw">3^x == 9</span></pre><p id="4163" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">对数问题的答案是:“我们用3的什么次方得到9？”答案当然是2！</p><pre class="kj kk kl km gt no ly np nq aw nr bi"><span id="975b" class="ns mh it ly b gy nt nu l nv nw">log3(9) == 2</span></pre><p id="1f00" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">对数函数与指数函数相反。当你说某样东西呈指数增长时，它正在被<em class="nn">乘以</em>。当某物以对数方式增长时，它被除以。</p><p id="1a5c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">被它除的数是基数。在计算机科学中，这个数字在大多数实际应用中是2。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi oo"><img src="../Images/a02d3c4980bc3932529db32555e06f8d.png" data-original-src="https://miro.medium.com/v2/resize:fit:718/format:webp/1*BpSXof1S3wL7VK4JPDkA9g.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">看啊！它们是镜像的。</p></figure><p id="bae0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这意味着，如果您有两个列表项要处理，并且您的程序在n次的<em class="nn"> log base 2中运行，那么将需要执行一次操作。那真的很厉害！运行的操作将比您拥有的数据少。</em></p><p id="e01e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">输入越大，你的程序需要经历的实际输入的比例就越小！</p></div><div class="ab cl lz ma hx mb" role="separator"><span class="mc bw bk md me mf"/><span class="mc bw bk md me mf"/><span class="mc bw bk md me"/></div><div class="im in io ip iq"><h1 id="aad0" class="mg mh it bd mi mj mk ml mm mn mo mp mq jz mr ka ms kc mt kd mu kf mv kg mw mx bi translated">实际对数</h1><p id="20b3" class="pw-post-body-paragraph kz la it lb b lc oi ju le lf oj jx lh li ok lk ll lm ol lo lp lq om ls lt lu im bi translated">再次查看我的列表:</p><pre class="kj kk kl km gt no ly np nq aw nr bi"><span id="7c5e" class="ns mh it ly b gy nt nu l nv nw">[a,b,c,d,e]</span></pre><p id="aff6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">例如，如果我想搜索它并找到<code class="fe lv lw lx ly b">d</code>，也许你可以写一个程序，按顺序查看每个字母，并在找到它要找的东西(d)时返回索引(3)。</p><p id="b886" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">该搜索将需要四次操作。不算太坏，对吧？如果我们要找的是<code class="fe lv lw lx ly b">e</code>呢？只有五次手术。因为这是最坏的情况，而五是输入的长度，所以搜索算法将是O(n)。</p><p id="ae25" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这对于一个小的列表来说很好，但是如果我们在一个有十亿个元素的列表中搜索最末尾的元素，这个算法会花费很长时间。</p><h2 id="b678" class="ns mh it bd mi nx ny dn mm nz oa dp mq li ob oc ms lm od oe mu lq of og mw oh bi translated">弗拉门戈搜索</h2><p id="fba2" class="pw-post-body-paragraph kz la it lb b lc oi ju le lf oj jx lh li ok lk ll lm ol lo lp lq om ls lt lu im bi translated">如果我们能加速到O(log n)呢？嗯，如果列表排序了，我们可以！我会让这些弗拉门戈舞者来解释:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="op oq l"/></div></figure><p id="1bc1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">注意舞者是如何排成一行，背上有数字的。背上有数字7的男人在找匹配的女人。他不知道她在哪里，但他知道所有的女士都在排序。</p><p id="5818" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">他的流程是走到中间的舞者面前，问她数字七在哪边。当她说:“她在我左边”时，他可以排除她右边的所有人。</p><p id="b434" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">接下来，他问左边中间的女人同样的问题。这让他可以排除另外一半的候选人，以此类推，直到他找到第七个。</p><p id="6233" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这个程序的运行时间为O(log n ),因为在最坏的情况下，它运行的操作数将是输入大小的<em class="nn"> log base 2。在这种情况下，由于我们的“列表”中有七个舞者，运行时间是log2(7)或~3次操作。</em></p><p id="ac43" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这种算法被称为二分搜索法，因为我们在每次运算中用两个T4来除可能的候选数。这就是log2(以2为底的对数)的意思。它是O(log n)的典型代表。</p><p id="83c6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">作为软件工程师，我们不必太担心对数的底数。它几乎总是为2，如果不是，性能考虑也没有太大的不同。所以我们才说log n，不指定基数。</p></div><div class="ab cl lz ma hx mb" role="separator"><span class="mc bw bk md me mf"/><span class="mc bw bk md me mf"/><span class="mc bw bk md me"/></div><div class="im in io ip iq"><h1 id="cdbf" class="mg mh it bd mi mj mk ml mm mn mo mp mq jz mr ka ms kc mt kd mu kf mv kg mw mx bi translated">感谢阅读！</h1><p id="8cc3" class="pw-post-body-paragraph kz la it lb b lc oi ju le lf oj jx lh li ok lk ll lm ol lo lp lq om ls lt lu im bi translated">希望有意义！如果有不清楚的地方，请留言评论。</p></div></div>    
</body>
</html>