<html>
<head>
<title>Implementing Reactive Circuit Breaker Using Resilience4j</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">用Resilience4j实现无功断路器</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/implementing-reactive-circuit-breaker-using-resilience4j-4fe81d28e100?source=collection_archive---------2-----------------------#2022-02-08">https://betterprogramming.pub/implementing-reactive-circuit-breaker-using-resilience4j-4fe81d28e100?source=collection_archive---------2-----------------------#2022-02-08</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="a16b" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">实施反应式弹性的分步指南4j</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/bfb0f8a6eb08b2948548e581e59e7493.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*kMn2lR4Ja3EEP7XVhymkNw.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">Craig Glantz的图像背景</p></figure><pre class="kj kk kl km gt ky kz la lb aw lc bi"><span id="4174" class="ld le it kz b gy lf lg l lh li"><strong class="kz iu">Table of Contents</strong></span><span id="3274" class="ld le it kz b gy lj lg l lh li">· <a class="ae lk" href="#e53c" rel="noopener ugc nofollow">Why Reactive?</a><br/>· <a class="ae lk" href="#a26b" rel="noopener ugc nofollow">Blocking vs Non Blocking</a><br/>· <a class="ae lk" href="#4c88" rel="noopener ugc nofollow">Why Resilience4j?</a><br/>· <a class="ae lk" href="#329e" rel="noopener ugc nofollow">Step 1. Add POM Dependency</a><br/>· <a class="ae lk" href="#aed0" rel="noopener ugc nofollow">Step 2. Add Circuit Breaker Configuration Bean</a><br/>· <a class="ae lk" href="#56ae" rel="noopener ugc nofollow">Step 3. Add Configuration for Circuit Breaker Properties</a><br/>· <a class="ae lk" href="#054d" rel="noopener ugc nofollow">Step 4. Implementing Circuit Breaker</a><br/>· <a class="ae lk" href="#5023" rel="noopener ugc nofollow">Troubleshooting</a><br/>· <a class="ae lk" href="#18e2" rel="noopener ugc nofollow">Swagger UI not Working for Webflux</a><br/>· <a class="ae lk" href="#f19a" rel="noopener ugc nofollow">How to Implement Circuit Breaker for Endpoints Which Don’t Have Return Type</a></span></pre><p id="e12b" class="pw-post-body-paragraph ll lm it ln b lo lp ju lq lr ls jx lt lu lv lw lx ly lz ma mb mc md me mf mg im bi translated">本文将重点介绍使用Resilience4j(一个Spring Cloud断路器库)实现无功断路器。</p><h1 id="e53c" class="mh le it bd mi mj mk ml mm mn mo mp mq jz mr ka ms kc mt kd mu kf mv kg mw mx bi translated">为什么反应？</h1><p id="39bf" class="pw-post-body-paragraph ll lm it ln b lo my ju lq lr mz jx lt lu na lw lx ly nb ma mb mc nc me mf mg im bi translated">让我们后退一步，仔细看看REST API消费的一些可用选项。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nd"><img src="../Images/719448abfbe3028661931efb6c0d996b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*H_pnA93UrjD9dZFHFeUumA.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">作者图表</p></figure><h1 id="a26b" class="mh le it bd mi mj mk ml mm mn mo mp mq jz mr ka ms kc mt kd mu kf mv kg mw mx bi translated">阻塞与非阻塞</h1><p id="762c" class="pw-post-body-paragraph ll lm it ln b lo my ju lq lr mz jx lt lu na lw lx ly nb ma mb mc nc me mf mg im bi translated">上图中选项的“阻塞”端基本上都基于每请求线程模型。这意味着线程将一直阻塞，直到REST API客户机收到响应。如果我们有许多传入的请求，应用程序将创建许多线程，这将耗尽线程池或占用所有可用的内存。用户可能会体验到性能下降。</p><p id="f059" class="pw-post-body-paragraph ll lm it ln b lo lp ju lq lr ls jx lt lu lv lw lx ly lz ma mb mc md me mf mg im bi translated">Spring 5 Reactive framework引入了<code class="fe ne nf ng kz b">WebClient</code>，一种异步、非阻塞的解决方案。反应式框架使用事件驱动的架构。它提供了通过反应流API组合异步逻辑的方法。与同步/阻塞方法相比，反应式方法可以处理更多逻辑，同时使用更少的线程和系统资源。此外，使用<code class="fe ne nf ng kz b">WebClient</code>,我们可以使用功能性的fluent API发出同步或异步HTTP请求，该API可以直接集成到我们现有的Spring配置和WebFlux反应式框架中。</p><p id="136c" class="pw-post-body-paragraph ll lm it ln b lo lp ju lq lr ls jx lt lu lv lw lx ly lz ma mb mc md me mf mg im bi translated">对于REST API消耗，赢家很明显！这就是无堵无功<code class="fe ne nf ng kz b">WebClient</code>！</p><h1 id="4c88" class="mh le it bd mi mj mk ml mm mn mo mp mq jz mr ka ms kc mt kd mu kf mv kg mw mx bi translated">为什么选择Resilience4j？</h1><p id="2972" class="pw-post-body-paragraph ll lm it ln b lo my ju lq lr mz jx lt lu na lw lx ly nb ma mb mc nc me mf mg im bi translated">我们可以使用两个主要的库来实现断路器。网飞Hystrix，它采用了面向对象的设计，对外部系统的调用必须封装在一个提供多种功能的<code class="fe ne nf ng kz b">HystrixCommand</code>中。然而，在SpringOne 2019中，Spring宣布Hystrix Dashboard将从Spring Cloud 3.1版本中删除，这使得它正式被弃用。使用废弃的库不是一个好主意。所以选择很明确，就是Resilience4j！</p><p id="2165" class="pw-post-body-paragraph ll lm it ln b lo lp ju lq lr ls jx lt lu lv lw lx ly lz ma mb mc md me mf mg im bi translated">Resilience4j是一个受Hystrix启发的独立库，但它建立在函数式编程的原则之上。Resilience4J提供高阶函数(decorators)来增强任何函数接口、lambda表达式或带有断路器、速率限制器或隔板的方法引用。</p><p id="9e20" class="pw-post-body-paragraph ll lm it ln b lo lp ju lq lr ls jx lt lu lv lw lx ly lz ma mb mc md me mf mg im bi translated">Resilience4J的其他优势包括更精细的配置选项(例如，闭合断路器模式所需的成功执行次数)和更轻的依赖性。</p><p id="f1d9" class="pw-post-body-paragraph ll lm it ln b lo lp ju lq lr ls jx lt lu lv lw lx ly lz ma mb mc md me mf mg im bi translated">我们将使用两个Spring Boot微服务来演示如何实现反应式断路器:</p><ul class=""><li id="92d5" class="nh ni it ln b lo lp lr ls lu nj ly nk mc nl mg nm nn no np bi translated">客户服务，充当REST API提供者，为客户提供CRUD端点。</li><li id="79ca" class="nh ni it ln b lo nq lr nr lu ns ly nt mc nu mg nm nn no np bi translated">客户服务客户端，通过Spring Boot Starter Webflux库利用<code class="fe ne nf ng kz b">WebClient</code>调用REST APIs。</li></ul><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nv"><img src="../Images/bdf01cb37f5abd2a032bc88c96790297.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*sVOfYH-pqs-_hcinjyX6sg.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">作者图，改编自<a class="ae lk" href="https://resilience4j.readme.io/docs/circuitbreaker" rel="noopener ugc nofollow" target="_blank">https://resilience4j.readme.io/docs/circuitbreaker</a></p></figure><p id="94aa" class="pw-post-body-paragraph ll lm it ln b lo lp ju lq lr ls jx lt lu lv lw lx ly lz ma mb mc md me mf mg im bi translated">现在，让我们深入了解为反应式断路器实施Resilience4j的详细步骤。</p><h1 id="329e" class="mh le it bd mi mj mk ml mm mn mo mp mq jz mr ka ms kc mt kd mu kf mv kg mw mx bi translated">第一步。添加POM相关性</h1><p id="1700" class="pw-post-body-paragraph ll lm it ln b lo my ju lq lr mz jx lt lu na lw lx ly nb ma mb mc nc me mf mg im bi translated">既然我们已经选择了<code class="fe ne nf ng kz b">WebClient</code>来消费REST API，我们需要将Spring Cloud断路器反应器Resilience4J依赖项添加到我们的REST客户端应用程序中。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nw nx l"/></div></figure><h1 id="aed0" class="mh le it bd mi mj mk ml mm mn mo mp mq jz mr ka ms kc mt kd mu kf mv kg mw mx bi translated">第二步。添加断路器配置Bean</h1><p id="c6be" class="pw-post-body-paragraph ll lm it ln b lo my ju lq lr mz jx lt lu na lw lx ly nb ma mb mc nc me mf mg im bi translated"><code class="fe ne nf ng kz b">CircuitBreakerConfig</code>类附带了一组断路器配置的默认值，如果我们选择对所有断路器使用默认配置值，我们可以创建一个通过<code class="fe ne nf ng kz b">ReactiveResilience4JCircuitBreakerFactory</code>传递的<code class="fe ne nf ng kz b">Customize</code> bean。工厂的<code class="fe ne nf ng kz b">configureDefault</code>方法可用于提供默认配置。样本片段如下:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nw nx l"/></div></figure><p id="8611" class="pw-post-body-paragraph ll lm it ln b lo lp ju lq lr ls jx lt lu lv lw lx ly lz ma mb mc md me mf mg im bi translated">如果我们选择使用定制的配置值，我们将需要如下定义我们的bean(“customer-service”仅仅是一个示例REST客户端实例，您可以使用您赋予REST客户端应用程序的任何实例名称):</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nw nx l"/></div></figure><h1 id="56ae" class="mh le it bd mi mj mk ml mm mn mo mp mq jz mr ka ms kc mt kd mu kf mv kg mw mx bi translated">第三步。添加断路器属性的配置</h1><p id="567b" class="pw-post-body-paragraph ll lm it ln b lo my ju lq lr mz jx lt lu na lw lx ly nb ma mb mc nc me mf mg im bi translated">如果我们定义我们的定制配置bean，我们还需要在<code class="fe ne nf ng kz b">application.yml</code>中添加断路器配置，例如(仅示例值，数字应根据应用使用场景进行调整):</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nw nx l"/></div></figure><ul class=""><li id="03d0" class="nh ni it ln b lo lp lr ls lu nj ly nk mc nl mg nm nn no np bi translated"><code class="fe ne nf ng kz b">failureRateThreshold</code>:当故障率等于或大于阈值时，断路器转换为打开并开始短路呼叫。在我们的例子中，这个值是50%，这意味着如果2个请求中有1个失败，将达到阈值，这将使断路器进入断开状态。</li><li id="eb7c" class="nh ni it ln b lo nq lr nr lu ns ly nt mc nu mg nm nn no np bi translated"><code class="fe ne nf ng kz b">minimumNumberOfCalls</code>:该属性确保一旦执行了最小数量的调用，就会计算失败率。在我们的例子中，在失败率计算开始之前，必须执行10个请求。</li><li id="bbcf" class="nh ni it ln b lo nq lr nr lu ns ly nt mc nu mg nm nn no np bi translated"><code class="fe ne nf ng kz b">slidingWindowType</code>:配置用于记录断路器闭合时通话结果的滑动窗口类型。<br/>滑动窗口可以基于计数，也可以基于时间。</li><li id="ae1e" class="nh ni it ln b lo nq lr nr lu ns ly nt mc nu mg nm nn no np bi translated"><code class="fe ne nf ng kz b">slidingWindowSize</code>:配置滑动窗口的大小，用于记录断路器闭合时的通话结果。</li><li id="dc85" class="nh ni it ln b lo nq lr nr lu ns ly nt mc nu mg nm nn no np bi translated"><code class="fe ne nf ng kz b">waitDurationInOpenState</code>:断路器从打开状态转换到半开状态前应等待的时间。在我们的例子中，是50秒。</li><li id="77e7" class="nh ni it ln b lo nq lr nr lu ns ly nt mc nu mg nm nn no np bi translated"><code class="fe ne nf ng kz b">permittedNumberOfCallsInHalfOpenState</code> <strong class="ln iu"> : </strong>配置断路器半开时允许呼叫的次数。在我们的例子中，限制是3，这意味着在10秒的窗口中只能处理3个请求。</li></ul><h1 id="054d" class="mh le it bd mi mj mk ml mm mn mo mp mq jz mr ka ms kc mt kd mu kf mv kg mw mx bi translated">第四步。实施断路器</h1><p id="804d" class="pw-post-body-paragraph ll lm it ln b lo my ju lq lr mz jx lt lu na lw lx ly nb ma mb mc nc me mf mg im bi translated">现在所有的配置都已就绪，我们可以开始使用断路器从客户端修饰REST API调用了。在下面的例子中，我们通过构造函数注入将<code class="fe ne nf ng kz b">WebClient </code>和<code class="fe ne nf ng kz b">ReactiveCircuitBreakerFactory </code>注入到<code class="fe ne nf ng kz b">CustomerCientController </code>中。然后，我们使用<code class="fe ne nf ng kz b">webClient </code>来触发传入的CustomerVO和/或customerId上的CRUD调用。请注意“<code class="fe ne nf ng kz b">transform</code>”部分，我们在<code class="fe ne nf ng kz b">ReactiveCircuitBreakerFactory</code>的帮助下为“客户服务”(<code class="fe ne nf ng kz b">rcb </code>类型<code class="fe ne nf ng kz b">ReactiveCircuitBreaker</code>)创建了<code class="fe ne nf ng kz b">ReactiveCircuitBreaker </code>实例。执行断路器的线路是<code class="fe ne nf ng kz b">rcb.run(...)</code>。在下面的示例控制器中，当抛出异常时，我们为POST/GET/PUT调用返回一个空白的<code class="fe ne nf ng kz b">CustomerVO </code>对象作为回退响应。对于删除调用，我们返回传入的<code class="fe ne nf ng kz b">customerId </code>作为后备。因此，在REST API provider关闭的情况下，不会出现500内部服务器错误，随着断路器的正确实现，我们会收到回退响应。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nw nx l"/></div></figure><h1 id="5023" class="mh le it bd mi mj mk ml mm mn mo mp mq jz mr ka ms kc mt kd mu kf mv kg mw mx bi translated">解决纷争</h1><h1 id="18e2" class="mh le it bd mi mj mk ml mm mn mo mp mq jz mr ka ms kc mt kd mu kf mv kg mw mx bi translated">Swagger UI不适用于Webflux</h1><p id="ed67" class="pw-post-body-paragraph ll lm it ln b lo my ju lq lr mz jx lt lu na lw lx ly nb ma mb mc nc me mf mg im bi translated">由于我们引入了Webflux库来使用<code class="fe ne nf ng kz b">WebClient</code>，您可能会注意到您的swagger UI最初并不工作。为了使其发挥作用，请确保实施以下步骤:</p><ul class=""><li id="1065" class="nh ni it ln b lo lp lr ls lu nj ly nk mc nl mg nm nn no np bi translated">在pom中添加以下依赖关系:</li></ul><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nw nx l"/></div></figure><ul class=""><li id="17db" class="nh ni it ln b lo lp lr ls lu nj ly nk mc nl mg nm nn no np bi translated">如果已经实现了注释<code class="fe ne nf ng kz b">@EnableSwagger2WebFlux</code>,则将其移除。</li><li id="1d32" class="nh ni it ln b lo nq lr nr lu ns ly nt mc nu mg nm nn no np bi translated">访问swagger的URL现在应该是:<a class="ae lk" href="http://localhost:8600/swagger-ui/" rel="noopener ugc nofollow" target="_blank">http://&lt;YOUR _ APP _ SERVER&gt;:&lt;YOUR _ APP _ PORT&gt;/swagger-ui/</a>，一定要加上结尾“/”。比如<a class="ae lk" href="http://localhost:8100/swagger-ui/." rel="noopener ugc nofollow" target="_blank">http://localhost:8100/swagger-ui/。</a></li></ul><h1 id="f19a" class="mh le it bd mi mj mk ml mm mn mo mp mq jz mr ka ms kc mt kd mu kf mv kg mw mx bi translated">如何为没有返回类型的端点实现断路器</h1><p id="2f96" class="pw-post-body-paragraph ll lm it ln b lo my ju lq lr mz jx lt lu na lw lx ly nb ma mb mc nc me mf mg im bi translated">对于在响应体中不返回任何内容的端点，比如REST API provider中的以下端点，在REST客户端，如果我们标记了调用该端点返回<code class="fe ne nf ng kz b">Mono&lt;Void&gt;</code>，<code class="fe ne nf ng kz b">ReactiveCircuitBreaker</code>将不起作用。如果REST API提供程序关闭，您将看到500 server错误，这完全违背了断路器的目的。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nw nx l"/></div></figure><p id="4e94" class="pw-post-body-paragraph ll lm it ln b lo lp ju lq lr ls jx lt lu lv lw lx ly lz ma mb mc md me mf mg im bi translated">在<strong class="ln iu">无功</strong>断路器实现中，对于没有返回类型的方法，我们可以使用<strong class="ln iu"> CheckedRunnable </strong>，做如下(举例):</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nw nx l"/></div></figure><p id="ae08" class="pw-post-body-paragraph ll lm it ln b lo lp ju lq lr ls jx lt lu lv lw lx ly lz ma mb mc md me mf mg im bi translated">但是，在无功断路器中，<code class="fe ne nf ng kz b">ReactiveCircuitBreaker</code>没有这样的接口布置<code class="fe ne nf ng kz b">CheckedRunnable</code>，那我们怎么办？经过一些调查和实验后，我注意到我们可以操纵这类端点的返回类型来返回一个通用类型，比如<code class="fe ne nf ng kz b">String</code>。简而言之，如果一个端点(如删除调用)在服务器端返回<code class="fe ne nf ng kz b">Void</code>，我们仍然可以从客户端操作该删除调用的返回类型以返回一个简单类型作为<code class="fe ne nf ng kz b">String</code>，只需传回传递给该端点的输入字符串。例如，在客户端，我们可以像这样实现删除调用:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nw nx l"/></div></figure><p id="ab4c" class="pw-post-body-paragraph ll lm it ln b lo lp ju lq lr ls jx lt lu lv lw lx ly lz ma mb mc md me mf mg im bi translated">注意我们正在返回<code class="fe ne nf ng kz b">Mono&lt;String&gt;</code>而不是<code class="fe ne nf ng kz b">Mono&lt;Void&gt;</code>，并且我们在<code class="fe ne nf ng kz b">.bodyToMono(String.class)</code>行指定了返回类型<code class="fe ne nf ng kz b">String</code>，这就是为什么我们可以简单地调用<code class="fe ne nf ng kz b">ReactiveCircuitBreaker</code>的<code class="fe ne nf ng kz b">run </code>方法来调用修饰的无功断路器函数。这是我能想到的唯一解决办法，不用<code class="fe ne nf ng kz b">ReactiveCircuitBreaker</code>的<code class="fe ne nf ng kz b">decorateCheckedRunnable</code>方法来处理没有返回类型的方法。</p><p id="4e69" class="pw-post-body-paragraph ll lm it ln b lo lp ju lq lr ls jx lt lu lv lw lx ly lz ma mb mc md me mf mg im bi translated">本文中提到的演示应用的源代码可以在<a class="ae lk" href="https://github.com/wenqiglantz/spring-boot-webclient-resilience4j" rel="noopener ugc nofollow" target="_blank">我的GitHub库</a>中找到。</p><p id="c8a9" class="pw-post-body-paragraph ll lm it ln b lo lp ju lq lr ls jx lt lu lv lw lx ly lz ma mb mc md me mf mg im bi translated">编码快乐！手工制作快乐！</p></div><div class="ab cl ny nz hx oa" role="separator"><span class="ob bw bk oc od oe"/><span class="ob bw bk oc od oe"/><span class="ob bw bk oc od"/></div><div class="im in io ip iq"><h1 id="33d5" class="mh le it bd mi mj of ml mm mn og mp mq jz oh ka ms kc oi kd mu kf oj kg mw mx bi translated"><strong class="ak">参考文献</strong></h1><p id="6dbc" class="pw-post-body-paragraph ll lm it ln b lo my ju lq lr mz jx lt lu na lw lx ly nb ma mb mc nc me mf mg im bi translated"><a class="ae lk" href="https://resilience4j.readme.io/docs/circuitbreaker" rel="noopener ugc nofollow" target="_blank">https://resilience4j.readme.io/docs/circuitbreaker</a></p><p id="2108" class="pw-post-body-paragraph ll lm it ln b lo lp ju lq lr ls jx lt lu lv lw lx ly lz ma mb mc md me mf mg im bi translated"><a class="ae lk" href="https://resilience4j.readme.io/docs/comparison-to-netflix-hystrix" rel="noopener ugc nofollow" target="_blank">https://resilience 4j . readme . io/docs/comparison-to-网飞-海斯特里克斯</a></p><p id="17c1" class="pw-post-body-paragraph ll lm it ln b lo lp ju lq lr ls jx lt lu lv lw lx ly lz ma mb mc md me mf mg im bi translated"><a class="ae lk" href="https://www.exoscale.com/syslog/migrate-from-hystrix-to-resilience4j/" rel="noopener ugc nofollow" target="_blank">从Hystrix迁移到Resilience4J </a></p><p id="496f" class="pw-post-body-paragraph ll lm it ln b lo lp ju lq lr ls jx lt lu lv lw lx ly lz ma mb mc md me mf mg im bi translated"><a class="ae lk" href="https://github.com/springfox/springfox#migrating-from-earlier-snapshot" rel="noopener ugc nofollow" target="_blank">https://github . com/spring fox/spring fox #从早期快照迁移</a></p><p id="c091" class="pw-post-body-paragraph ll lm it ln b lo lp ju lq lr ls jx lt lu lv lw lx ly lz ma mb mc md me mf mg im bi translated"><a class="ae lk" href="https://reflectoring.io/spring-webclient/" rel="noopener ugc nofollow" target="_blank">用Spring WebClient发送HTTP请求</a></p><p id="2ea5" class="pw-post-body-paragraph ll lm it ln b lo lp ju lq lr ls jx lt lu lv lw lx ly lz ma mb mc md me mf mg im bi translated">请随意查看我关于Spring Boot的其他文章:</p><div class="ok ol gp gr om on"><a href="https://medium.com/codex/spring-boot-microservices-coding-style-guidelines-and-best-practices-1dec229161c8" rel="noopener follow" target="_blank"><div class="oo ab fo"><div class="op ab oq cl cj or"><h2 class="bd iu gy z fp os fr fs ot fu fw is bi translated">Spring Boot微服务编码风格指南和最佳实践</h2><div class="ou l"><h3 class="bd b gy z fp os fr fs ot fu fw dk translated">通过多年来与Spring Boot微服务公司的合作，我已经编制了一份编码风格指南和…</h3></div><div class="ov l"><p class="bd b dl z fp os fr fs ot fu fw dk translated">medium.com</p></div></div><div class="ow l"><div class="ox l oy oz pa ow pb ks on"/></div></div></a></div></div></div>    
</body>
</html>