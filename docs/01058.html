<html>
<head>
<title>Pattern Matching vs. Polymorphism</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">模式匹配与多态性</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/pattern-matching-vs-polymorphism-ce0441fbfcda?source=collection_archive---------8-----------------------#2019-08-11">https://betterprogramming.pub/pattern-matching-vs-polymorphism-ce0441fbfcda?source=collection_archive---------8-----------------------#2019-08-11</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="016e" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">构建可扩展的架构</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/503ce62163238dadd9ce53be94c6c6bf.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*Ojfp5SNPPkgM1oym"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk">Photo by <a class="ae ky" href="https://unsplash.com/@danist07?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">贝莉儿 NG</a> on <a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></p></figure><h1 id="0e00" class="kz la it bd lb lc ld le lf lg lh li lj jz lk ka ll kc lm kd ln kf lo kg lp lq bi translated">TL；速度三角形定位法(dead reckoning)</h1><p id="90b9" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">子类型多态性对于添加更多的实体类型非常有用。模式匹配是添加更多功能的更好选择。在许多用例中，请求更多的功能比请求更多的实体类型更有可能。</p><p id="42f6" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">在本文中，我们基于一组简单的需求实现了一个程序。首先，我们使用子类型多态性实现它，然后使用模式匹配。给定这些实现，我们添加另外两个需求，并比较实现新需求所需的更改。</p><h2 id="5183" class="ms la it bd lb mt mu dn lf mv mw dp lj ma mx my ll me mz na ln mi nb nc lp nd bi translated">放弃</h2><p id="436a" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">当使用术语<em class="ne">模式匹配</em>时，我指的是有限的子集。您可以在<code class="fe nf ng nh ni b">Resources</code>部分找到更详细的模式匹配解释的链接。</p></div><div class="ab cl nj nk hx nl" role="separator"><span class="nm bw bk nn no np"/><span class="nm bw bk nn no np"/><span class="nm bw bk nn no"/></div><div class="im in io ip iq"><h1 id="97fe" class="kz la it bd lb lc nq le lf lg nr li lj jz ns ka ll kc nt kd ln kf nu kg lp lq bi translated">初始要求</h1><p id="6291" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">让我们考虑二维形状的例子。我们希望允许两种不同的类型:矩形和圆形。所有形状都有周长和面积。矩形是由两条长度各不相同的边定义的。它的周长是<code class="fe nf ng nh ni b">(x + y) * 2</code>，面积是<code class="fe nf ng nh ni b">x * y</code>。圆是由半径定义的。它的周长是<code class="fe nf ng nh ni b">2 * PI * r</code>，面积是<code class="fe nf ng nh ni b">PI * r * r</code>。</p></div><div class="ab cl nj nk hx nl" role="separator"><span class="nm bw bk nn no np"/><span class="nm bw bk nn no np"/><span class="nm bw bk nn no"/></div><div class="im in io ip iq"><h1 id="ccc7" class="kz la it bd lb lc nq le lf lg nr li lj jz ns ka ll kc nt kd ln kf nu kg lp lq bi translated">使用子类型多态性</h1><p id="a781" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">让我们用Java中的子类型多态性来建模这个例子。</p><p id="0a0a" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">我们将形状建模为界面。它有一个检索周长的方法和一个检索面积的方法。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nv nw l"/></div></figure><p id="36fb" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">矩形是<code class="fe nf ng nh ni b">Shape</code>接口的一个实现。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nv nw l"/></div></figure><p id="6544" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">圆形是<code class="fe nf ng nh ni b">Shape</code>接口的第二个实现。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nv nw l"/></div></figure><p id="8b5f" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">这个类层次结构成功地实现了需求。我们的利益相关者现在可以计算矩形和圆形的周长和面积。太好了。</p></div><div class="ab cl nj nk hx nl" role="separator"><span class="nm bw bk nn no np"/><span class="nm bw bk nn no np"/><span class="nm bw bk nn no"/></div><div class="im in io ip iq"><h1 id="ee9e" class="kz la it bd lb lc nq le lf lg nr li lj jz ns ka ll kc nt kd ln kf nu kg lp lq bi translated">额外要求</h1><p id="7e3f" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">现在，我们的涉众提出了两个额外的要求。</p><ol class=""><li id="856c" class="nx ny it lt b lu mn lx mo ma nz me oa mi ob mm oc od oe of bi translated">他们也想计算平行四边形的这些性质。</li><li id="721e" class="nx ny it lt b lu og lx oh ma oi me oj mi ok mm oc od oe of bi translated">他们想计算一个形状的直径。这是一个形状中最长的距离。</li></ol></div><div class="ab cl nj nk hx nl" role="separator"><span class="nm bw bk nn no np"/><span class="nm bw bk nn no np"/><span class="nm bw bk nn no"/></div><div class="im in io ip iq"><h1 id="ffb5" class="kz la it bd lb lc nq le lf lg nr li lj jz ns ka ll kc nt kd ln kf nu kg lp lq bi translated">向子类型架构中添加新类</h1><p id="0860" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">有了我们给定的子类型架构，满足第一个要求是很容易的。</p><p id="7c01" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">我们从创建一个类<code class="fe nf ng nh ni b">Parallelogram</code>开始，并在类签名中添加一个<code class="fe nf ng nh ni b">implements</code>子句。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nv nw l"/></div></figure><p id="4204" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">此时，Java编译器已经通知我们该类缺少方法<code class="fe nf ng nh ni b">perimeter</code>和<code class="fe nf ng nh ni b">area</code>的实现。IDE为我们提供了生成方法存根的选项。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nv nw l"/></div></figure><p id="a8dd" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">现在我们可以向类中添加属性并实现这两种方法。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nv nw l"/></div></figure><p id="084c" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">子类型多态性允许我们用一个新文件来满足这个需求。我们不需要接触现有的代码库。</p><p id="06bf" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">子类型多态性简化了新实体类型的添加。</p></div><div class="ab cl nj nk hx nl" role="separator"><span class="nm bw bk nn no np"/><span class="nm bw bk nn no np"/><span class="nm bw bk nn no"/></div><div class="im in io ip iq"><h1 id="1e82" class="kz la it bd lb lc nq le lf lg nr li lj jz ns ka ll kc nt kd ln kf nu kg lp lq bi translated">向子类型架构中添加新方法</h1><p id="caae" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">我们来看第二个要求。</p><ul class=""><li id="4170" class="nx ny it lt b lu mn lx mo ma nz me oa mi ob mm ol od oe of bi translated">利益相关者想要计算形状的直径。这是一个形状中最长的距离。</li></ul><p id="0d55" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">我们向接口<code class="fe nf ng nh ni b">Shape</code>添加了一个新方法。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nv nw l"/></div></figure><p id="59bf" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">此时，Java编译器在类<code class="fe nf ng nh ni b">Rectangle</code>、<code class="fe nf ng nh ni b">Shape</code>和<code class="fe nf ng nh ni b">Parallelogram</code>中通知我们。每个类都缺少一个新方法<code class="fe nf ng nh ni b">diameter</code>的实现。</p><p id="8be9" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">我们将方法<code class="fe nf ng nh ni b">diameter</code>的实现添加到类<code class="fe nf ng nh ni b">Rectangle</code>中。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nv nw l"/></div></figure><p id="d336" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">又到了<code class="fe nf ng nh ni b">Circle</code>类。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nv nw l"/></div></figure><p id="5356" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">AAA和到类<code class="fe nf ng nh ni b">Parallelogram</code>。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nv nw l"/></div></figure><p id="8994" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">为了增加直径，我们需要触及层次结构中的每个类。这些更改分散在整个应用程序中。</p><p id="8850" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">子类型多态性使添加新方法变得复杂。</p></div><div class="ab cl nj nk hx nl" role="separator"><span class="nm bw bk nn no np"/><span class="nm bw bk nn no np"/><span class="nm bw bk nn no"/></div><div class="im in io ip iq"><h1 id="ff0a" class="kz la it bd lb lc nq le lf lg nr li lj jz ns ka ll kc nt kd ln kf nu kg lp lq bi translated">使用模式匹配</h1><p id="f5f7" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">让我们看一种不同的方法:模式匹配。Java目前还不支持模式匹配。(这很可能在即将到来的版本中发生变化:<a class="ae ky" href="http://openjdk.java.net/jeps/305" rel="noopener ugc nofollow" target="_blank"> JEP 305 </a>，<a class="ae ky" href="https://openjdk.java.net/jeps/354" rel="noopener ugc nofollow" target="_blank"> JEP 354 </a>。)目前，我们将使用Kotlin进行模式匹配。Kotlin为模式匹配提供了足够的支持来展示这个例子。</p><p id="e48c" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">形状被建模为没有任何属性的<code class="fe nf ng nh ni b">sealed</code>类。关键字<code class="fe nf ng nh ni b">sealed</code>强制要求<code class="fe nf ng nh ni b">Shape</code>的所有子类都在同一个文件中声明。我们将<code class="fe nf ng nh ni b">Rectangle</code>和<code class="fe nf ng nh ni b">Circle</code>定义为<code class="fe nf ng nh ni b">Shape</code>类的唯一子类。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nv nw l"/></div></figure><p id="7053" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">新的层次结构看起来类似于使用子类型多态性的层次结构。关键的区别在于，我们没有在类层次结构中指定方法。相反，我们将方法定义为层次结构之外的函数。</p><p id="8848" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">让我们实现函数<code class="fe nf ng nh ni b">area</code>。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nv nw l"/></div></figure><p id="b784" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">因为函数是在层次结构之外定义的，所以我们不知道传递的形状是矩形还是圆形。我们使用模式匹配来区分这两种情况。如果形状是<code class="fe nf ng nh ni b">Rectangle</code>的子类型，编译器会将参数<code class="fe nf ng nh ni b">shape</code>转换为矩形并对<code class="fe nf ng nh ni b">shape.x * shape.y</code>求值。如果形状是<code class="fe nf ng nh ni b">Circle</code>的子类型，编译器将参数<code class="fe nf ng nh ni b">shape</code>转换成一个圆，并对<code class="fe nf ng nh ni b">PI * shape.radius * shape.radius</code>求值。</p><p id="670e" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">注意，没有必要定义默认子句，因为类<code class="fe nf ng nh ni b">Shape</code>是<code class="fe nf ng nh ni b">sealed</code>。如果有一个类没有被覆盖，编译器会通知我们。</p><p id="9292" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">我们可以类似地实现函数<code class="fe nf ng nh ni b">perimeter</code>。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nv nw l"/></div></figure><p id="7f51" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">我们为这两个实现添加了两个子句:矩形和圆形。</p></div><div class="ab cl nj nk hx nl" role="separator"><span class="nm bw bk nn no np"/><span class="nm bw bk nn no np"/><span class="nm bw bk nn no"/></div><div class="im in io ip iq"><h1 id="e03d" class="kz la it bd lb lc nq le lf lg nr li lj jz ns ka ll kc nt kd ln kf nu kg lp lq bi translated">将新方法添加到模式匹配架构中</h1><p id="0e0d" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">我们成功地满足了最初的要求。现在，让我们考虑一个额外的要求。</p><ul class=""><li id="5e5e" class="nx ny it lt b lu mn lx mo ma nz me oa mi ob mm ol od oe of bi translated">利益相关者想要计算形状的直径。这是一个形状中最长的距离。</li></ul><p id="67c5" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">有了新的架构，满足这一要求就像添加新功能一样简单。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nv nw l"/></div></figure><p id="d453" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">不需要修改任何现有文件。同样，如前所述，如果我们错过了<code class="fe nf ng nh ni b">Shape</code>的一个子类，编译器会自动通知我们。</p><p id="2a5f" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">模式匹配简化了新功能的添加。</p></div><div class="ab cl nj nk hx nl" role="separator"><span class="nm bw bk nn no np"/><span class="nm bw bk nn no np"/><span class="nm bw bk nn no"/></div><div class="im in io ip iq"><h1 id="3645" class="kz la it bd lb lc nq le lf lg nr li lj jz ns ka ll kc nt kd ln kf nu kg lp lq bi translated">将新类添加到模式匹配体系结构中</h1><p id="97f7" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">让我们考虑另一个要求。</p><ul class=""><li id="1589" class="nx ny it lt b lu mn lx mo ma nz me oa mi ob mm ol od oe of bi translated">利益相关者也想计算平行四边形的这些属性。</li></ul><p id="e122" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">使用子类型架构很容易满足这个要求。模式匹配更难。</p><p id="95f2" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">首先，我们添加一个新的子类<code class="fe nf ng nh ni b">Shape</code>。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nv nw l"/></div></figure><p id="c983" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">此时，编译器通知我们函数<code class="fe nf ng nh ni b">perimeter</code>、<code class="fe nf ng nh ni b">area</code>和<code class="fe nf ng nh ni b">diameter</code>中的<code class="fe nf ng nh ni b">when</code>表达式缺少一个用于<code class="fe nf ng nh ni b">Parallelogram</code>的子句。</p><p id="0721" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">我们将缺失的案例添加到函数<code class="fe nf ng nh ni b">perimeter</code>中。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nv nw l"/></div></figure><p id="9518" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">以及功能<code class="fe nf ng nh ni b">area</code>。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nv nw l"/></div></figure><p id="13a8" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">AAA和功能<code class="fe nf ng nh ni b">diameter</code>。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nv nw l"/></div></figure><p id="b968" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">为了添加新的类<code class="fe nf ng nh ni b">Parallelogram</code>，我们需要触及每一个现有的函数。这些更改分散在整个应用程序中。</p><p id="b6a8" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">模式匹配使添加新的实体类型变得复杂。</p></div><div class="ab cl nj nk hx nl" role="separator"><span class="nm bw bk nn no np"/><span class="nm bw bk nn no np"/><span class="nm bw bk nn no"/></div><div class="im in io ip iq"><h1 id="4365" class="kz la it bd lb lc nq le lf lg nr li lj jz ns ka ll kc nt kd ln kf nu kg lp lq bi translated">摘要</h1><p id="e389" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">模式匹配和子类型多态性是设计架构的两种不同工具。前者非常适合添加新功能，而后者非常适合添加新的实体类型。在决定一个架构之前，问问你自己你是否更可能需要更多的功能或者更多的实体类型。根据我的经验，随着时间的推移，大多数用例不成比例地需要更多的功能，而不是更多的实体类型。</p><p id="fddd" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">你怎么想呢?</p></div><div class="ab cl nj nk hx nl" role="separator"><span class="nm bw bk nn no np"/><span class="nm bw bk nn no np"/><span class="nm bw bk nn no"/></div><div class="im in io ip iq"><h1 id="3cef" class="kz la it bd lb lc nq le lf lg nr li lj jz ns ka ll kc nt kd ln kf nu kg lp lq bi translated">资源</h1><ul class=""><li id="e0ee" class="nx ny it lt b lu lv lx ly ma om me on mi oo mm ol od oe of bi translated">Java中模式匹配的例子:<a class="ae ky" href="https://gist.github.com/fboeller/f1465df917baf854f7d6bc07dce7b96d" rel="noopener ugc nofollow" target="_blank">https://gist . github . com/fbo eller/f 1465 df 917 BAF 854 f 7 D6 BC 07 DCE 7b 96d</a></li><li id="de74" class="nx ny it lt b lu og lx oh ma oi me oj mi ok mm ol od oe of bi translated">Kotlin中具有子类型多态性的示例:<a class="ae ky" href="https://gist.github.com/fboeller/57295c2bd2089c229cf09f9297b5e8a1" rel="noopener ugc nofollow" target="_blank">https://gist . github . com/fbo eller/57295 C2 BD 2089 c 229 cf 09 f 9297 b5 E8 a 1</a></li><li id="57ac" class="nx ny it lt b lu og lx oh ma oi me oj mi ok mm ol od oe of bi translated">模式匹配说明:【http://learnyouahaskell.com/syntax-in-functions T2】</li><li id="6137" class="nx ny it lt b lu og lx oh ma oi me oj mi ok mm ol od oe of bi translated">http://openjdk.java.net/jeps/305 JEP 305:<a class="ae ky" href="http://openjdk.java.net/jeps/305" rel="noopener ugc nofollow" target="_blank"/></li><li id="f2ff" class="nx ny it lt b lu og lx oh ma oi me oj mi ok mm ol od oe of bi translated">http://openjdk.java.net/jeps/325 JEP 325:<a class="ae ky" href="http://openjdk.java.net/jeps/325" rel="noopener ugc nofollow" target="_blank"/></li></ul></div></div>    
</body>
</html>