<html>
<head>
<title>Building a Realtime Chat in NestJS</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">在NestJS中构建实时聊天</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/building-a-realtime-chat-in-nestjs-9c0b680be33f?source=collection_archive---------2-----------------------#2019-08-06">https://betterprogramming.pub/building-a-realtime-chat-in-nestjs-9c0b680be33f?source=collection_archive---------2-----------------------#2019-08-06</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="dcba" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">循序渐进的指南</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/3ef56ec8118925c1a5b681637efe6a21.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*N_ZuX50s1SxBAvsR"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">由<a class="ae ky" href="https://unsplash.com/@fossy?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Fab Lentz </a>在<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</p></figure><p id="d075" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><a class="ae ky" href="https://en.wikipedia.org/wiki/WebSocket" rel="noopener ugc nofollow" target="_blank"> Websockets </a>是一种通信协议，它在web浏览器和web服务器之间建立的单一TCP连接上提供全双工通信通道。这允许服务器发送到浏览器，而不被客户端调用。</p><p id="1eb5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">今天，我们将通过在<a class="ae ky" href="https://nestjs.com/" rel="noopener ugc nofollow" target="_blank"> NestJS </a>中构建一个聊天应用程序，来看看如何使用Websockets实现不同浏览器之间的实时通信。</p><p id="3bd3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">所以事不宜迟，让我们开始吧。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="79cc" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">Websockets简介</h1><p id="8ae5" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">Websockets是web应用程序中HTTP通信的替代方案。它们在客户机和服务器之间提供了一个持久的连接，双方可以随时使用这个连接开始发送数据。</p><p id="b731" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这可以带来以下好处:</p><ul class=""><li id="4d82" class="mz na it lb b lc ld lf lg li nb lm nc lq nd lu ne nf ng nh bi translated">服务器可以向客户端发送消息，而无需客户端明确请求某些内容</li><li id="dbd2" class="mz na it lb b lc ni lf nj li nk lm nl lq nm lu ne nf ng nh bi translated">低延迟通信</li><li id="36b1" class="mz na it lb b lc ni lf nj li nk lm nl lq nm lu ne nf ng nh bi translated">客户端和服务器可以同时相互通信</li></ul><p id="2274" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这就是Websockets在实时和长期通信方面优于HTTP的原因。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="7b74" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">项目设置</h1><p id="9db8" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">在我们开始编码之前，让我们首先设置我们的项目并安装必要的依赖项。为此，您需要打开终端并运行以下命令。</p><p id="2e78" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">首先，创建项目并移动到它的目录中。</p><pre class="kj kk kl km gt nn no np nq aw nr bi"><span id="2c8d" class="ns md it no b gy nt nu l nv nw">nest new nestchat<br/>cd nestchat</span></pre><p id="689b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">之后，我们只需要使用节点包管理器(npm)安装依赖项。</p><pre class="kj kk kl km gt nn no np nq aw nr bi"><span id="b1ee" class="ns md it no b gy nt nu l nv nw">npm i --save @nestjs/websockets @nestjs/platform-socket.io</span></pre><p id="7fad" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在我们已经安装好了所有的东西，基本的项目设置也已经就绪，让我们创建将要使用的文件。</p><p id="ce23" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们从使用NestJS CLI创建模块、服务和控制器开始。</p><pre class="kj kk kl km gt nn no np nq aw nr bi"><span id="747e" class="ns md it no b gy nt nu l nv nw">nest g gateway app</span></pre><p id="9f86" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">之后，您只需要在src目录中创建一个名为static的文件夹，其中包含三个文件:</p><ul class=""><li id="a75c" class="mz na it lb b lc ld lf lg li nb lm nc lq nd lu ne nf ng nh bi translated">index.html——为我们的聊天而设计</li><li id="53ec" class="mz na it lb b lc ni lf nj li nk lm nl lq nm lu ne nf ng nh bi translated">main.js —客户端websockets逻辑</li><li id="8eaf" class="mz na it lb b lc ni lf nj li nk lm nl lq nm lu ne nf ng nh bi translated">styles.css —我们的HTML文件的样式</li></ul><p id="4f90" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在你的项目结构应该看起来像这样。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi nx"><img src="../Images/44337eb1b496c3f83722c70098e95118.png" data-original-src="https://miro.medium.com/v2/resize:fit:376/format:webp/1*LNulH7limFJ2pDoRfUNA2g.png"/></div></figure><p id="ac5a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在我们已经完成了初始设置，我们可以通过运行下一个命令来启动我们的服务器。</p><pre class="kj kk kl km gt nn no np nq aw nr bi"><span id="2e8e" class="ns md it no b gy nt nu l nv nw">npm run start:dev</span></pre><p id="afd3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">瞧，初始设置已经完成，现在让我们开始实现Websockets配置。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="9080" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">Websockets服务器</h1><p id="51c4" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">首先，让我们通过实现我们之前安装的Websockets工具来创建我们的web sockets服务器。这是一个非常简单的过程，只需要我们上面创建的AppGateway。</p><pre class="kj kk kl km gt nn no np nq aw nr bi"><span id="5cd2" class="ns md it no b gy nt nu l nv nw"><em class="ny">import</em> {<br/> SubscribeMessage,<br/> WebSocketGateway,<br/> OnGatewayInit,<br/> WebSocketServer,<br/> OnGatewayConnection,<br/> OnGatewayDisconnect,<br/>} <em class="ny">from</em> '@nestjs/websockets';<br/><em class="ny">import</em> { Logger } <em class="ny">from</em> '@nestjs/common';<br/><em class="ny">import</em> { Socket, Server } <em class="ny">from</em> 'socket.io';</span><span id="8696" class="ns md it no b gy nz nu l nv nw">@WebSocketGateway()<br/><em class="ny">export</em> class AppGateway implements OnGatewayInit, OnGatewayConnection, OnGatewayDisconnect {</span><span id="c9fa" class="ns md it no b gy nz nu l nv nw"> @WebSocketServer() server: Server;<br/> private logger: Logger = new Logger('AppGateway');</span><span id="66be" class="ns md it no b gy nz nu l nv nw"> @SubscribeMessage('msgToServer')<br/> handleMessage(client: Socket, payload: string): void {<br/>  <em class="ny">this</em>.server.emit('msgToClient', payload);<br/> }</span><span id="80b0" class="ns md it no b gy nz nu l nv nw"> afterInit(server: Server) {<br/>  <em class="ny">this</em>.logger.log('Init');<br/> }</span><span id="e56e" class="ns md it no b gy nz nu l nv nw"> handleDisconnect(client: Socket) {<br/>  <em class="ny">this</em>.logger.log(`Client disconnected: ${client.id}`);<br/> }</span><span id="761a" class="ns md it no b gy nz nu l nv nw"> handleConnection(client: Socket, ...args: any[]) {<br/>  <em class="ny">this</em>.logger.log(`Client connected: ${client.id}`);<br/> }<br/>}</span></pre><p id="b28b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这基本上是我们处理应用程序通信所需的全部内容，所以让我们来分解一下。</p><p id="981e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">首先，您会注意到我们用<code class="fe oa ob oc no b">@WebsocketGateway()</code>声明符来修饰我们的类，它让我们可以访问socket.io功能。</p><p id="e665" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们还实现了三个接口<code class="fe oa ob oc no b">OnGatewayInit</code>、<code class="fe oa ob oc no b">OnGatewayConnection</code>和<code class="fe oa ob oc no b">OnGatewayDisconnect</code>、<em class="ny">、</em>，用于记录应用程序的一些关键状态。例如，当一个新的客户端连接到服务器或者当一个当前的客户端断开连接时，我们记录日志。</p><p id="1252" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">接下来，我们创建了一个名为server的成员变量，用<code class="fe oa ob oc no b">@WebsocketServer()</code>修饰，让我们可以访问Websockets服务器实例。</p><p id="1ccb" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们利用了<code class="fe oa ob oc no b">handleMessage() </code>函数中的实例，其中我们使用<code class="fe oa ob oc no b">emit()</code>函数向连接到服务器的所有客户端发送数据。<code class="fe oa ob oc no b">handleMessage()</code>函数也用<code class="fe oa ob oc no b">@SubscribeMessage()</code>修饰，这使得它可以监听名为<code class="fe oa ob oc no b">msgToServer</code>的事件。</p><p id="7529" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在我们进入项目的客户端之前，我们只需要将网关添加到模块的提供者中。</p><pre class="kj kk kl km gt nn no np nq aw nr bi"><span id="6a0f" class="ns md it no b gy nt nu l nv nw"><em class="ny">import</em> { Module } <em class="ny">from</em> '@nestjs/common';<br/><em class="ny">import</em> { AppGateway } <em class="ny">from</em> './app.gateway';</span><span id="4f3d" class="ns md it no b gy nz nu l nv nw">@Module({<br/> imports: [],<br/> controllers: [],<br/> providers: [AppGateway],<br/>})<br/><em class="ny">export</em> class AppModule {}</span></pre></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="984d" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">Websockets客户端</h1><p id="bb8f" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">服务器完成后，现在让我们继续这个项目的客户端。为此，我们将在我们的NestJS项目中直接使用静态资产。为了使布局和状态保存更容易处理，我们还将使用<a class="ae ky" href="https://vuejs.org/" rel="noopener ugc nofollow" target="_blank"> Vue.js </a>。</p><p id="a3e9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">首先，我们需要通过向我们的<code class="fe oa ob oc no b">main.js</code>文件添加几行代码来告诉我们的NestJS应用程序我们想要使用静态资产。</p><pre class="kj kk kl km gt nn no np nq aw nr bi"><span id="6f0c" class="ns md it no b gy nt nu l nv nw"><em class="ny">import</em> { NestFactory } <em class="ny">from</em> '@nestjs/core';<br/><em class="ny">import</em> { AppModule } <em class="ny">from</em> './app.module';<br/><em class="ny">import</em> { NestExpressApplication } <em class="ny">from</em> '@nestjs/platform-express';<br/><em class="ny">import</em> { join } <em class="ny">from</em> 'path';</span><span id="8454" class="ns md it no b gy nz nu l nv nw">async function bootstrap() {<br/> const app = <em class="ny">await</em> NestFactory.create&lt;NestExpressApplication&gt;(AppModule);<br/> app.useStaticAssets(join(__dirname, '..', 'static'));<br/> <em class="ny">await</em> app.listen(3000);<br/>}<br/>bootstrap();</span></pre><p id="3161" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在这里，我们告诉express静态目录将用于存储我们的静态资产，我们只能通过导入和使用NestExpressApplication来实现。</p><p id="fcb8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">接下来，我们将在我们的<code class="fe oa ob oc no b">main.js</code>文件中创建客户端javascript代码，稍后我们将在布局中使用它。</p><pre class="kj kk kl km gt nn no np nq aw nr bi"><span id="e6d9" class="ns md it no b gy nt nu l nv nw">const app = new Vue({<br/> el: '#app',<br/> data: {<br/>  title: 'Nestjs Websockets Chat',<br/>  name: '',<br/>  text: '',<br/>  messages: [],<br/>  socket: null<br/> },<br/> methods: {<br/>  sendMessage() {<br/>   <em class="ny">if</em>(<em class="ny">this</em>.validateInput()) {<br/>    const message = {<br/>    name: <em class="ny">this</em>.name,<br/>    text: <em class="ny">this</em>.text<br/>   }<br/>   <em class="ny">this</em>.socket.emit('msgToServer', message)<br/>   <em class="ny">this</em>.text = ''<br/>  }<br/> },<br/> receivedMessage(message) {<br/>  <em class="ny">this</em>.messages.push(message)<br/> },<br/> validateInput() {<br/>  <em class="ny">return</em> <em class="ny">this</em>.name.length &gt; 0 &amp;&amp; <em class="ny">this</em>.text.length &gt; 0<br/> }<br/>},<br/> created() {<br/>  <em class="ny">this</em>.socket = io('http://localhost:3000')<br/>  <em class="ny">this</em>.socket.on('msgToClient', (message) =&gt; {<br/>   <em class="ny">this</em>.receivedMessage(message)<br/>  })<br/> }<br/>})</span></pre><p id="86f0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在这里，我们创建一个新的Vue.js实例，并创建一些基本变量，我们稍后将在我们的布局中使用。</p><p id="3f7d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">接下来，您可以看到<code class="fe oa ob oc no b">created() </code>函数，每当创建前端时都会执行该函数。在这个方法中，我们使用<a class="ae ky" href="https://socket.io/" rel="noopener ugc nofollow" target="_blank"> socket.io </a>库实例化我们的socket变量，稍后我们将把这个库导入到我们的前端。我们还在我们的套接字上添加了一个事件监听器，它监听我们之前在服务器中创建的<code class="fe oa ob oc no b">msgToClient</code>事件。</p><p id="2dc8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">接下来，我们有了<code class="fe oa ob oc no b">sendMessage()</code>函数，它从我们的布局中获取输入，如果输入是正确的，就使用相同的事件将它发送到我们的服务器。</p><p id="1f13" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这就是我们的客户端——现在我们只需要为我们的应用程序创建布局。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="146d" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">应用程序布局</h1><p id="04bd" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">为了创建布局，我们只需要在应用程序中添加一些简单的HTML和CSS。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="od oe l"/></div></figure><p id="8745" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这里，我们使用脚本标签导入socket.io和vue.js依赖项，然后创建一个简单的布局，包含两个输入字段、一个消息区域和一个发送消息的按钮。</p><p id="a662" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">您还可以注意到，我们导入了上面使用的main.js文件和一个我们现在将创建的自定义样式表。</p><pre class="kj kk kl km gt nn no np nq aw nr bi"><span id="99da" class="ns md it no b gy nt nu l nv nw"><em class="ny">#messages</em>{<br/> height:300px;<br/> overflow-y: scroll;<br/>}</span><span id="f33b" class="ns md it no b gy nz nu l nv nw"><em class="ny">#app</em> {<br/> margin-top: 2rem;<br/>}</span></pre></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="b9e9" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">测试应用程序</h1><p id="ec14" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">现在我们已经完成了我们的聊天应用程序，是时候通过在两个或更多的浏览器标签中打开它并相互聊天来测试它了。为此，让我们启动应用程序并在浏览器中打开它。</p><pre class="kj kk kl km gt nn no np nq aw nr bi"><span id="4c66" class="ns md it no b gy nt nu l nv nw">npm run start</span></pre><p id="eacd" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">启动之后，我们应该可以在http://localhost:3000上看到我们的布局。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi of"><img src="../Images/789116249eebf228225b926b1a2ecd2b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*0iK8UPn15qJhErrhqkqe0A.png"/></div></div></figure><p id="a054" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">然后你只需要输入名字和信息，然后点击发送。发送后，消息应该出现在第二个窗口中，看起来应该像这样。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi og"><img src="../Images/a44e7bbbb24e5072a01afce4e8817c64.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*9wrnmE_wzMw117-lwC-l9Q.png"/></div></div></figure><p id="05d6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">就是这样！我们已经使用Websockets完成了我们的NestJS聊天应用程序。该项目的完整代码也可以在我的Github上找到。</p><div class="oh oi gp gr oj ok"><a href="https://github.com/TannerGabriel/Blog/tree/master/NestVueChat" rel="noopener  ugc nofollow" target="_blank"><div class="ol ab fo"><div class="om ab on cl cj oo"><h2 class="bd iu gy z fp op fr fs oq fu fw is bi translated">TannerGabriel/博客</h2><div class="or l"><h3 class="bd b gy z fp op fr fs oq fu fw dk translated">一个渐进式Node.js框架，用于构建高效且可伸缩的服务器端应用程序，其灵感主要来自…</h3></div><div class="os l"><p class="bd b dl z fp op fr fs oq fu fw dk translated">github.com</p></div></div><div class="ot l"><div class="ou l ov ow ox ot oy ks ok"/></div></div></a></div></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h2 id="cf26" class="ns md it bd me oz pa dn mi pb pc dp mm li pd pe mo lm pf pg mq lq ph pi ms pj bi translated">推荐阅读</h2><div class="oh oi gp gr oj ok"><a href="https://medium.com/better-programming/building-a-graphql-server-in-nestjs-f9ba34e773a3" rel="noopener follow" target="_blank"><div class="ol ab fo"><div class="om ab on cl cj oo"><h2 class="bd iu gy z fp op fr fs oq fu fw is bi translated">在NestJS中构建GraphQL服务器</h2><div class="or l"><h3 class="bd b gy z fp op fr fs oq fu fw dk translated">GraphQL基础和NestJS开发的最佳实践</h3></div><div class="os l"><p class="bd b dl z fp op fr fs oq fu fw dk translated">medium.com</p></div></div><div class="ot l"><div class="pk l ov ow ox ot oy ks ok"/></div></div></a></div></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="b0b4" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">结论</h1><p id="03d8" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">你一直坚持到最后！我希望这篇文章能帮助你理解Websockets的基础知识以及如何在NestJS中使用它们。</p><p id="8ef3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果您发现这很有用，请考虑推荐并与其他开发人员分享。如果您有任何问题或反馈，请在下面的评论中告诉我！</p></div></div>    
</body>
</html>