<html>
<head>
<title>Will Nuxt 3 Make Vue.js Great Again?</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Nuxt 3会让Vue.js再次伟大吗？</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/will-nuxt-3-make-vue-js-great-again-122672de31ed?source=collection_archive---------4-----------------------#2022-05-09">https://betterprogramming.pub/will-nuxt-3-make-vue-js-great-again-122672de31ed?source=collection_archive---------4-----------------------#2022-05-09</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="88c5" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">更轻、更快、自动导入、出色的开发人员体验</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/76b2ad482a57535b4f3dee35e873528a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*qJppTMduXXhjgU2tZt9SfQ.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">作者图片</p></figure><p id="b263" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">最近，我们发布了令人兴奋的React生态系统。先是<code class="fe lu lv lw lx b">Next.js</code>，然后是<code class="fe lu lv lw lx b">Remix</code>，后来是<code class="fe lu lv lw lx b">React 18</code>。这些都抢了任何<code class="fe lu lv lw lx b">JavaScript</code>框架的风头。他们推动了所有的前端讨论，增加了React的发展势头。</p><p id="f952" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">幸运的是，<code class="fe lu lv lw lx b">Nuxt</code>团队凭借其最新的<code class="fe lu lv lw lx b">Nuxt 3</code>版本卷土重来。它目前在<code class="fe lu lv lw lx b">RC</code>中，稳定版将于六月发布。尽管一个<code class="fe lu lv lw lx b">Vue.js</code>很伟大，但是如果它在框架特性上落后，它将无法获得牵引力。这个版本可能会在增加其受欢迎程度方面发挥很大作用🚀。</p><p id="159c" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated"><code class="fe lu lv lw lx b">Nuxt</code>到底是什么？你可以把它看成是<code class="fe lu lv lw lx b">Vue.js</code>里写的<code class="fe lu lv lw lx b">Remix/Next.js</code>的等价物。这是一个同构的<code class="fe lu lv lw lx b">JavaScript</code>框架，它使我们能够编写在客户端和服务器上都可以执行的代码。它抽象了所有的复杂性和配置。</p><p id="ffd8" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">新的<code class="fe lu lv lw lx b">Nuxt 3</code>版本包含许多功能。不仅要创建高性能的web应用程序，还要将开发人员的体验提升到一个全新的水平。它有内置的TypeScript支持，这是真棒。唯一明显的警告是，它非常固执己见。这是一个高我们需要支付。但是，看到这种进化有多神奇，我会很乐意为此买单。</p><p id="ba76" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">在这篇文章中，我将总结一些最伟大的特性，这些特性有望引导许多开发者从<code class="fe lu lv lw lx b">React</code>转向。</p></div><div class="ab cl ly lz hx ma" role="separator"><span class="mb bw bk mc md me"/><span class="mb bw bk mc md me"/><span class="mb bw bk mc md"/></div><div class="im in io ip iq"><h1 id="22de" class="mf mg it bd mh mi mj mk ml mm mn mo mp jz mq ka mr kc ms kd mt kf mu kg mv mw bi translated">1.Nitro —服务器引擎</h1><p id="27f4" class="pw-post-body-paragraph ky kz it la b lb mx ju ld le my jx lg lh mz lj lk ll na ln lo lp nb lr ls lt im bi translated">这个新版本的<code class="fe lu lv lw lx b">Nuxt</code>由一个新的服务器引擎驱动，这个引擎的昵称是<code class="fe lu lv lw lx b">Nitro</code>。它是从头开始构建的，这意味着没有遗留代码。</p><p id="3832" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">它有什么特点？</p><ul class=""><li id="731b" class="nc nd it la b lb lc le lf lh ne ll nf lp ng lt nh ni nj nk bi translated"><strong class="la iu">对Node.js、浏览器、服务工作者等的跨平台支持</strong>:它使得引擎与平台无关</li><li id="2951" class="nc nd it la b lb nl le nm lh nn ll no lp np lt nh ni nj nk bi translated"><strong class="la iu">无服务器支持</strong></li><li id="9206" class="nc nd it la b lb nl le nm lh nn ll no lp np lt nh ni nj nk bi translated"><strong class="la iu"> API路由</strong>:内部由<a class="ae nq" href="https://github.com/unjs/h3" rel="noopener ugc nofollow" target="_blank"> unjs/h3 </a>项目供电。</li><li id="9701" class="nc nd it la b lb nl le nm lh nn ll no lp np lt nh ni nj nk bi translated"><strong class="la iu">自动代码分割</strong></li><li id="8a97" class="nc nd it la b lb nl le nm lh nn ll no lp np lt nh ni nj nk bi translated"><strong class="la iu">热模块重装</strong></li><li id="f3a7" class="nc nd it la b lb nl le nm lh nn ll no lp np lt nh ni nj nk bi translated"><strong class="la iu">混合模式:</strong>精细地控制页面的呈现方式。下一节将详细介绍这一点。</li></ul><p id="44dd" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">总之，我们得到了一个伟大的引擎，它不仅能够驱动<code class="fe lu lv lw lx b">SSR</code>。我们可以创建<code class="fe lu lv lw lx b">static</code>、<code class="fe lu lv lw lx b">spa</code>或事件<code class="fe lu lv lw lx b">api</code>应用程序。它的平台无关性和轻量级使得它非常强大。这不仅意味着更快的响应时间，还意味着在我们喜欢的地方托管应用程序的自由。我们现在可以直接在边缘部署我们的代码。这意味着<code class="fe lu lv lw lx b">SSR</code>代码在尽可能靠近最终用户的地方执行。</p></div><div class="ab cl ly lz hx ma" role="separator"><span class="mb bw bk mc md me"/><span class="mb bw bk mc md me"/><span class="mb bw bk mc md"/></div><div class="im in io ip iq"><h1 id="5c28" class="mf mg it bd mh mi mj mk ml mm mn mo mp jz mq ka mr kc ms kd mt kf mu kg mv mw bi translated">2.灵活渲染</h1><p id="28bf" class="pw-post-body-paragraph ky kz it la b lb mx ju ld le my jx lg lh mz lj lk ll na ln lo lp nb lr ls lt im bi translated">目前<code class="fe lu lv lw lx b">Nuxt</code>框架支持两种渲染模式:</p><ul class=""><li id="1659" class="nc nd it la b lb lc le lf lh ne ll nf lp ng lt nh ni nj nk bi translated">客户端:浏览器下载所有的<code class="fe lu lv lw lx b">JavaScript</code>文件，然后生成HTML元素</li><li id="f435" class="nc nd it la b lb nl le nm lh nn ll no lp np lt nh ni nj nk bi translated"><strong class="la iu">服务器端:</strong>服务器生成HTML页面并返回给客户端。然后给客户补充水分以增加互动性。</li></ul><p id="17c4" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">这些方法各有利弊。例如，<code class="fe lu lv lw lx b">server-side</code>渲染更昂贵，因为我们在主机中计算视图。然而<code class="fe lu lv lw lx b">client-side</code>和<code class="fe lu lv lw lx b">SEO</code>玩的并不好。</p><p id="edfe" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">在以前的版本中，我们必须为整个应用程序选择一种或另一种方法。在这个新版本中，我们有一个<code class="fe lu lv lw lx b">Hybrid Rendering</code>。我们可以在每条路由的基础上定制行为。</p><p id="dd98" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">总之，我们可以更精确地控制哪些路线需要使用<code class="fe lu lv lw lx b">SSR</code>而哪些不需要。它让我们享受每种方法的优点，并相应地设计我们的web应用程序。</p><p id="8ec8" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">⚠️这可能不是第一个稳定版本的一部分，但不久之后就会出现。</p></div><div class="ab cl ly lz hx ma" role="separator"><span class="mb bw bk mc md me"/><span class="mb bw bk mc md me"/><span class="mb bw bk mc md"/></div><div class="im in io ip iq"><h1 id="f10b" class="mf mg it bd mh mi mj mk ml mm mn mo mp jz mq ka mr kc ms kd mt kf mu kg mv mw bi translated">3.汽车进口</h1><p id="9459" class="pw-post-body-paragraph ky kz it la b lb mx ju ld le my jx lg lh mz lj lk ll na ln lo lp nb lr ls lt im bi translated">导入是一项微不足道的任务。这是如此枯燥的工作，以至于我们通常依赖工具来处理这些(VSCode扩展)和订购这些(ESLint)。如果不需要它们呢？</p><p id="f47b" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">这正是发生在<code class="fe lu lv lw lx b">Nuxt 3</code>的事情。我们不再需要添加任何导入语句。它将由引擎自动计算出来。<code class="fe lu lv lw lx b">Nuxt</code>如何知道如何解决这些问题？它们基于目录和命名结构。</p><ul class=""><li id="423e" class="nc nd it la b lb lc le lf lh ne ll nf lp ng lt nh ni nj nk bi translated"><code class="fe lu lv lw lx b">components/</code> —这是应该放置<code class="fe lu lv lw lx b">Vue</code>组件的地方。</li><li id="8afe" class="nc nd it la b lb nl le nm lh nn ll no lp np lt nh ni nj nk bi translated"><code class="fe lu lv lw lx b">composables/</code> —这是应该放置堆肥的地方。</li></ul><h2 id="b517" class="ns mg it bd mh nt nu dn ml nv nw dp mp lh nx ny mr ll nz oa mt lp ob oc mv od bi translated">成分</h2><p id="7d2f" class="pw-post-body-paragraph ky kz it la b lb mx ju ld le my jx lg lh mz lj lk ll na ln lo lp nb lr ls lt im bi translated">假设我们创建了一个<code class="fe lu lv lw lx b">components/Foo.vue</code>:</p><pre class="kj kk kl km gt oe lx of og aw oh bi"><span id="b7ce" class="ns mg it lx b gy oi oj l ok ol">&lt;template&gt;<br/>  Foo<br/>&lt;/template&gt;</span></pre><p id="85de" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">要使用这个组件，我们所要做的就是在我们的<code class="fe lu lv lw lx b">.vue</code>模板文件中使用它，匹配组件文件名。</p><pre class="kj kk kl km gt oe lx of og aw oh bi"><span id="77c7" class="ns mg it lx b gy oi oj l ok ol">&lt;template&gt;<br/>  &lt;div&gt;<br/>    <strong class="lx iu">&lt;Foo /&gt;</strong><br/>  &lt;/div&gt;<br/>&lt;/template&gt;</span></pre><p id="070d" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">这是怎么发生的？在内部，引擎在<code class="fe lu lv lw lx b">.nuxt</code>文件夹中创建所有内容。我们可以检查<code class="fe lu lv lw lx b">.nuxt/components.d.ts</code>并在那里找到我们的组件定义。</p><h2 id="7e11" class="ns mg it bd mh nt nu dn ml nv nw dp mp lh nx ny mr ll nz oa mt lp ob oc mv od bi translated">动态导入</h2><p id="875f" class="pw-post-body-paragraph ky kz it la b lb mx ju ld le my jx lg lh mz lj lk ll na ln lo lp nb lr ls lt im bi translated">如果我们想以一种懒惰的方式导入那个组件呢？这可以通过在组件名前加上前缀<code class="fe lu lv lw lx b">Lazy</code>来轻松实现。</p><pre class="kj kk kl km gt oe lx of og aw oh bi"><span id="2c04" class="ns mg it lx b gy oi oj l ok ol">&lt;template&gt;<br/>  &lt;div&gt;<br/>    <strong class="lx iu">&lt;LazyFoo /&gt; </strong>// component will be lazy loaded<br/>  &lt;/div&gt;<br/>&lt;/template&gt;</span></pre><h2 id="b799" class="ns mg it bd mh nt nu dn ml nv nw dp mp lh nx ny mr ll nz oa mt lp ob oc mv od bi translated">嵌套组件</h2><p id="f276" class="pw-post-body-paragraph ky kz it la b lb mx ju ld le my jx lg lh mz lj lk ll na ln lo lp nb lr ls lt im bi translated">如果组件在嵌套目录中会怎样？我们只需将路径目录修改为组件的名称。比如<code class="fe lu lv lw lx b">components/<strong class="la iu">bar</strong>/<strong class="la iu">foo</strong>.vue</code>。</p><pre class="kj kk kl km gt oe lx of og aw oh bi"><span id="4fb3" class="ns mg it lx b gy oi oj l ok ol">&lt;template&gt;<br/>  &lt;div&gt;<br/>    <strong class="lx iu">&lt;BarFoo /&gt;</strong><br/>  &lt;/div&gt;<br/>&lt;/template&gt;</span></pre><p id="cf8f" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated"><em class="nr">💁‍♂️但是为了一致，建议将组件命名为</em> <code class="fe lu lv lw lx b"><em class="nr">components/bar/</em><strong class="la iu"><em class="nr">BarFoo</em></strong><em class="nr">.vue</em></code> <em class="nr">。</em></p><h2 id="0554" class="ns mg it bd mh nt nu dn ml nv nw dp mp lh nx ny mr ll nz oa mt lp ob oc mv od bi translated">客户端特定组件</h2><p id="d677" class="pw-post-body-paragraph ky kz it la b lb mx ju ld le my jx lg lh mz lj lk ll na ln lo lp nb lr ls lt im bi translated">如果我们只想让组件成为客户端，该怎么办？我们可以使用<code class="fe lu lv lw lx b">ClientOnly</code>包装。</p><pre class="kj kk kl km gt oe lx of og aw oh bi"><span id="4669" class="ns mg it lx b gy oi oj l ok ol">&lt;template&gt;<br/>  &lt;div&gt;<br/>    <strong class="lx iu">&lt;</strong><strong class="lx iu">ClientOnly&gt;</strong><br/>  <!-- -->    <strong class="lx iu">&lt;LazyFoo /&gt;<br/>    &lt;/ClientOnly&gt;<br/></strong>  &lt;/div&gt;<br/>&lt;/template&gt;</span></pre><h2 id="d664" class="ns mg it bd mh nt nu dn ml nv nw dp mp lh nx ny mr ll nz oa mt lp ob oc mv od bi translated">显式导入</h2><p id="4db2" class="pw-post-body-paragraph ky kz it la b lb mx ju ld le my jx lg lh mz lj lk ll na ln lo lp nb lr ls lt im bi translated">在这个场景中，如果需要，我们可以通过使用<code class="fe lu lv lw lx b">#components</code>来使用显式导入。</p><pre class="kj kk kl km gt oe lx of og aw oh bi"><span id="7f78" class="ns mg it lx b gy oi oj l ok ol">import { Foo } from <strong class="lx iu">'#components'</strong>;</span></pre></div><div class="ab cl ly lz hx ma" role="separator"><span class="mb bw bk mc md me"/><span class="mb bw bk mc md me"/><span class="mb bw bk mc md"/></div><div class="im in io ip iq"><h1 id="e696" class="mf mg it bd mh mi mj mk ml mm mn mo mp jz mq ka mr kc ms kd mt kf mu kg mv mw bi translated">4.证明文件</h1><p id="b204" class="pw-post-body-paragraph ky kz it la b lb mx ju ld le my jx lg lh mz lj lk ll na ln lo lp nb lr ls lt im bi translated">文档很棒。有传统的<code class="fe lu lv lw lx b">API</code>这里可以找到<a class="ae nq" href="https://v3.nuxtjs.org/api/composables/use-async-data" rel="noopener ugc nofollow" target="_blank"/>。</p><p id="e2f5" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">然而，这里有一个有趣而直观的入门指南<a class="ae nq" href="https://v3.nuxtjs.org/guide/concepts/introduction" rel="noopener ugc nofollow" target="_blank"/>。它仍然是一个过程中的工作，但帮助我们以一种简单的方式理解<code class="fe lu lv lw lx b">Nuxt</code>项目。由于<code class="fe lu lv lw lx b">Nuxt</code>有很多文件夹范围的特性，一开始可能很难理解。一些目录参与一些基于文件的路由。</p><p id="e2d7" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">以下是我们可能找到的一些文件夹示例:</p><ul class=""><li id="2381" class="nc nd it la b lb lc le lf lh ne ll nf lp ng lt nh ni nj nk bi translated"><strong class="la iu">页面:</strong>基于文件的路由通过<code class="fe lu lv lw lx b">Vue Router</code>在你的web应用内创建路由。</li><li id="3e7f" class="nc nd it la b lb nl le nm lh nn ll no lp np lt nh ni nj nk bi translated"><strong class="la iu">服务器:</strong>扫描文件夹以向HMR支持注册API和服务器处理程序。</li><li id="d972" class="nc nd it la b lb nl le nm lh nn ll no lp np lt nh ni nj nk bi translated">公共部门:我们需要把我们的资产放在哪里</li><li id="7603" class="nc nd it la b lb nl le nm lh nn ll no lp np lt nh ni nj nk bi translated"><strong class="la iu">组件:</strong>可从任何页面导出的所有组件。</li><li id="ba78" class="nc nd it la b lb nl le nm lh nn ll no lp np lt nh ni nj nk bi translated"><strong class="la iu">插件:</strong>我们需要放置导入插件的目录。</li></ul><p id="8fc0" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">为了快速掌握这一点，您可以在本指南中找到任何<code class="fe lu lv lw lx b">Nuxt</code>项目的完整树。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi om"><img src="../Images/6b49752e3328bfe82886f4179ae2ce9c.png" data-original-src="https://miro.medium.com/v2/resize:fit:468/format:webp/1*Q4LlQa-dFGcQ9zZbcnMUMg.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">https://v3.nuxtjs.org/guide/directory-structure/components的字幕</p></figure><p id="3df5" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">还有一些互动的例子可以在<a class="ae nq" href="https://v3.nuxtjs.org/examples/essentials/hello-world" rel="noopener ugc nofollow" target="_blank">这里</a>找到。这些链接指向<code class="fe lu lv lw lx b">CodeSandBox</code>或<code class="fe lu lv lw lx b">StackBlitz</code>。</p></div><div class="ab cl ly lz hx ma" role="separator"><span class="mb bw bk mc md me"/><span class="mb bw bk mc md me"/><span class="mb bw bk mc md"/></div><div class="im in io ip iq"><h1 id="c3fa" class="mf mg it bd mh mi mj mk ml mm mn mo mp jz mq ka mr kc ms kd mt kf mu kg mv mw bi translated">5.开发者体验</h1><p id="049e" class="pw-post-body-paragraph ky kz it la b lb mx ju ld le my jx lg lh mz lj lk ll na ln lo lp nb lr ls lt im bi translated">目前，JavaScript框架确实考虑到了开发人员的体验。对打字稿有很大支持的是<code class="fe lu lv lw lx b">Nuxt 3</code>。我们可以将<code class="fe lu lv lw lx b">API</code>类型与我们的<code class="fe lu lv lw lx b">components</code>结合起来，后者将整个事情很好地包装在一起。</p><p id="1a3c" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">此外，我们现在可以使用最新的花哨的构建工具来构建我们的项目。这让整个体验更加爽快。</p><p id="6501" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">开箱即用<code class="fe lu lv lw lx b">Nuxt 3</code>支持:</p><ul class=""><li id="277d" class="nc nd it la b lb lc le lf lh ne ll nf lp ng lt nh ni nj nk bi translated"><code class="fe lu lv lw lx b">Vite</code></li><li id="53a6" class="nc nd it la b lb nl le nm lh nn ll no lp np lt nh ni nj nk bi translated"><code class="fe lu lv lw lx b">webpack 5</code> + <code class="fe lu lv lw lx b">esbuild</code></li><li id="7eab" class="nc nd it la b lb nl le nm lh nn ll no lp np lt nh ni nj nk bi translated">PostCSS</li></ul><p id="501a" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">默认的构建器是<code class="fe lu lv lw lx b">Vite</code>，但是切换到<code class="fe lu lv lw lx b">Webpack5</code>很容易，但是可以简化对<code class="fe lu lv lw lx b">nuxt.config.ts</code>文件的调整:</p><pre class="kj kk kl km gt oe lx of og aw oh bi"><span id="54ed" class="ns mg it lx b gy oi oj l ok ol">export default defineNuxtConfig({<br/>  <strong class="lx iu">vite: false</strong><br/>})</span></pre><p id="9a19" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">您可以使用以下命令来扩展任何配置</p><ul class=""><li id="d37f" class="nc nd it la b lb lc le lf lh ne ll nf lp ng lt nh ni nj nk bi translated"><code class="fe lu lv lw lx b">extendWebpackConfig(callback, options?)</code></li><li id="151b" class="nc nd it la b lb nl le nm lh nn ll no lp np lt nh ni nj nk bi translated"><code class="fe lu lv lw lx b">extendViteConfig(callback, options?)</code></li><li id="3cf2" class="nc nd it la b lb nl le nm lh nn ll no lp np lt nh ni nj nk bi translated"><code class="fe lu lv lw lx b">addWebpackPlugin(webpackPlugin, options?)</code></li><li id="af87" class="nc nd it la b lb nl le nm lh nn ll no lp np lt nh ni nj nk bi translated"><code class="fe lu lv lw lx b">addVitePlugin(vitePlugin, options?)</code></li></ul><p id="695a" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">多亏了现代JavaScript编译器，我们可以期待更快的构建时间和更好的开发者体验。</p></div><div class="ab cl ly lz hx ma" role="separator"><span class="mb bw bk mc md me"/><span class="mb bw bk mc md me"/><span class="mb bw bk mc md"/></div><div class="im in io ip iq"><h1 id="efd1" class="mf mg it bd mh mi mj mk ml mm mn mo mp jz mq ka mr kc ms kd mt kf mu kg mv mw bi translated">包裹</h1><p id="f529" class="pw-post-body-paragraph ky kz it la b lb mx ju ld le my jx lg lh mz lj lk ll na ln lo lp nb lr ls lt im bi translated">我们已经看到这个版本是多么的伟大和重要。希望这将有助于增加<code class="fe lu lv lw lx b">Vue.js</code>的兴趣。多样化是很棒的，因为竞争会带来很多好主意。这就是推动创新的方式。</p><p id="c433" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">我们可以看到React是如何统治JavaScript的视图生态系统的。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi on"><img src="../Images/d18c0f811e00bbcc986c8ac17a9cda7e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*0PwouH-2lWixgkx4l2R0ZA.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">图片来自www.npmtrends.com。</p></figure><p id="b63a" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">React的社区更大，也更容易找到工作。然而，像<code class="fe lu lv lw lx b">Nuxt 3</code>这样的工具也许能够平衡这两者。</p><p id="e707" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">然而，这是一个网站开发者的大好时机。我们有很多很好的选择。我们是去<code class="fe lu lv lw lx b">Remix</code>、<code class="fe lu lv lw lx b">Next.js</code>还是<code class="fe lu lv lw lx b">Nuxt.js</code>？这些我们都不可能出错。这将归结为我们的个人喜好。</p><div class="oo op gp gr oq or"><a rel="noopener  ugc nofollow" target="_blank" href="/next-js-vs-remix-analyzing-key-aspects-and-differences-8674beaba695"><div class="os ab fo"><div class="ot ab ou cl cj ov"><h2 class="bd iu gy z fp ow fr fs ox fu fw is bi translated">Next.js vs. Remix:分析关键方面和差异</h2><div class="oy l"><h3 class="bd b gy z fp ow fr fs ox fu fw dk translated">通过比较Remix和Next.js的最新版本，知道哪一个适合你</h3></div><div class="oz l"><p class="bd b dl z fp ow fr fs ox fu fw dk translated">better编程. pub</p></div></div><div class="pa l"><div class="pb l pc pd pe pa pf ks or"/></div></div></a></div></div></div>    
</body>
</html>