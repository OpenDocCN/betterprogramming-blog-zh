<html>
<head>
<title>What Can We Expect in TypeScript 4.1?</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">在TypeScript 4.1中我们可以期待什么？</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/what-can-we-expect-in-typescript-4-1-822a59d89dc2?source=collection_archive---------9-----------------------#2020-09-29">https://betterprogramming.pub/what-can-we-expect-in-typescript-4-1-822a59d89dc2?source=collection_archive---------9-----------------------#2020-09-29</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="baef" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">了解下一版本的TypeScript将会带来什么</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/9d66d47a4c29a1a8ec3d4d6356d40be5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*IgS1lgcCjWWKIFKi"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">由<a class="ae ky" href="https://unsplash.com/@amosg?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">阿莫斯G </a>在<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>拍摄的照片。</p></figure><p id="df4f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">8月20日，TypeScript团队发布了Typescript 4.0。大约三个月后，他们将在11月发布另一个版本，名为TypeScript 4.1。这将是今年TypeScript的最后一次发布。根据<a class="ae ky" href="https://github.com/microsoft/TypeScript/issues/40124" rel="noopener ugc nofollow" target="_blank">的迭代计划</a>，似乎他们正在各方面努力，包括语言特性、性能和基础设施，为你提供最好的特性。</p><p id="dd4d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在本文中，我将简要讨论TypeScript 4.1测试版中发布的一些特性。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="7029" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">映射类型中的键重新映射</h1><p id="5b6c" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">映射类型最初是在TypeScript 2.1中引入的，它们已用于基于您提供的任意键或基于其他对象类型创建新的对象类型，如下所示:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mz na l"/></div></figure><p id="8a27" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在4.1版本中，TypeScript通过引入一个名为<code class="fe nb nc nd ne b">as</code>的新子句，启用了映射类型中的重映射。<strong class="lb iu"> <em class="nf"> </em> </strong>使用此选项，您可以根据输入创建新的键和过滤键:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mz na l"/></div></figure></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="139b" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">模板文字类型</h1><p id="39d7" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">自早期以来，字符串文字类型就存在于TypeScript中，并且它们主要用作映射类型中的属性名。此外，我们可以使用字符串来建模函数和API，拼写检查字符串值，等等。除了这些用途，我们可以使用字符串文字的最重要的情况之一是构建其他字符串文字类型。</p><blockquote class="ng nh ni"><p id="2be2" class="kz la nf lb b lc ld ju le lf lg jx lh nj lj lk ll nk ln lo lp nl lr ls lt lu im bi translated">“这就是TypeScript 4.1引入模板文字字符串类型的原因。它与JavaScript 中的<a class="ae ky" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Template_literals" rel="noopener ugc nofollow" target="_blank">模板文字字符串具有相同的语法，但是用于类型位置。当您将它与具体的文本类型一起使用时，它会通过连接内容来生成一个新的字符串文本类型。— </a><a class="ae ky" href="https://devblogs.microsoft.com/typescript/announcing-typescript-4-1-beta/" rel="noopener ugc nofollow" target="_blank">微软开发者博客</a></p></blockquote><pre class="kj kk kl km gt nm ne nn no aw np bi"><span id="b88c" class="nq md it ne b gy nr ns l nt nu">type Student = "student";<br/><br/>type Greeting = `hello ${Student}`;<br/>// same as<br/>//   type Greeting = "hello student";</span></pre><p id="cd6b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这一新特性的另一个有趣的用途是，我们可以使用联合生成两个不同文字的所有可能的字符串文字:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mz na l"/></div></figure><p id="7785" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">你可以在TypeScript 4.1的<a class="ae ky" href="https://devblogs.microsoft.com/typescript/announcing-typescript-4-1-beta/" rel="noopener ugc nofollow" target="_blank">文档</a>中找到更多关于文字类型的细节。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="b050" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">递归条件类型</h1><p id="725a" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">虽然有一些黑客或非正统的方法，但在以前版本的TypeScript中，不可能轻松地解开嵌套数组或承诺，使它们扁平化。但是在最新的版本中，TypeScript允许一些条件类型来解决这个问题。</p><p id="1876" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">根据<a class="ae ky" href="https://devblogs.microsoft.com/typescript/announcing-typescript-4-1-beta/" rel="noopener ugc nofollow" target="_blank">文档</a>:</p><blockquote class="nv"><p id="02a3" class="nw nx it bd ny nz oa ob oc od oe lu dk translated">在TypeScript 4.1中，条件类型现在可以立即在其分支内引用自身，从而更容易编写递归类型别名</p></blockquote><p id="a865" class="pw-post-body-paragraph kz la it lb b lc of ju le lf og jx lh li oh lk ll lm oi lo lp lq oj ls lt lu im bi translated">如果我们举一个解开深度嵌套承诺的例子，我们可以使用<code class="fe nb nc nd ne b">Awaited</code>类型来这样做，如下所示:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mz na l"/></div></figure><p id="6109" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">但是关于这些递归类型，我们需要记住一些事情:</p><ul class=""><li id="2184" class="ok ol it lb b lc ld lf lg li om lm on lq oo lu op oq or os bi translated">我们应该只在必要的场合使用它们。</li><li id="aa89" class="ok ol it lb b lc ot lf ou li ov lm ow lq ox lu op oq or os bi translated">他们非常强大。</li><li id="8ce1" class="ok ol it lb b lc ot lf ou li ov lm ow lq ox lu op oq or os bi translated">计算成本可能很高。</li><li id="089e" class="ok ol it lb b lc ot lf ou li ov lm ow lq ox lu op oq or os bi translated">您可以达到最大递归深度限制。</li></ul><p id="ec7f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">TypeScript已经在GitHub 上提供了递归条件类型<a class="ae ky" href="https://github.com/microsoft/TypeScript/pull/40002" rel="noopener ugc nofollow" target="_blank">的实现。</a></p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="c5a0" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">React 17家JSX工厂</h1><p id="ec4d" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">React的最新版本将是17，我们将能够在今年内看到React 17的稳定发布。因此，TypeScript做了一些修改，以支持React 17最新版本4.1的最新功能。</p><p id="d1a8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">TypeScript 4.1引入了两个新的jsx编译器选项(react-jsx和react-jsxdev)来支持React 17中的<code class="fe nb nc nd ne b">jsx</code>和<code class="fe nb nc nd ne b">jsxs</code>工厂函数:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mz na l"/></div></figure><p id="4306" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在这个代码片段中，您可以看到生产和开发配置文件以及这些<code class="fe nb nc nd ne b">jsx</code>选项是如何在其中使用的。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="40e8" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">其他的</h1><p id="487e" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">除此之外，TypeScript 4.1中还有一些其他重要的功能更新和突破性变化。</p><h2 id="c63d" class="nq md it bd me oy oz dn mi pa pb dp mm li pc pd mo lm pe pf mq lq pg ph ms pi bi translated"><strong class="ak">突破性的变化</strong></h2><ul class=""><li id="b0f3" class="ok ol it lb b lc mu lf mv li pj lm pk lq pl lu op oq or os bi translated">您不能再将抽象成员标记为异步。</li><li id="5cd5" class="ok ol it lb b lc ot lf ou li ov lm ow lq ox lu op oq or os bi translated"><code class="fe nb nc nd ne b">any</code> / <code class="fe nb nc nd ne b">unknown</code>在虚假位置繁殖。</li><li id="5035" class="ok ol it lb b lc ot lf ou li ov lm ow lq ox lu op oq or os bi translated"><code class="fe nb nc nd ne b">--declaration</code>和<code class="fe nb nc nd ne b">--outFile</code>需要一个包名root。</li><li id="6f65" class="ok ol it lb b lc ot lf ou li ov lm ow lq ox lu op oq or os bi translated"><code class="fe nb nc nd ne b">resolve</code>的参数在<code class="fe nb nc nd ne b">Promises</code>中不再可选。</li></ul><h2 id="912f" class="nq md it bd me oy oz dn mi pa pb dp mm li pc pd mo lm pe pf mq lq pg ph ms pi bi translated"><strong class="ak">其他变更</strong></h2><ul class=""><li id="0772" class="ok ol it lb b lc mu lf mv li pj lm pk lq pl lu op oq or os bi translated">迂腐的索引签名检查(<code class="fe nb nc nd ne b">--noUncheckedIndexedAccess</code>)。</li><li id="4744" class="ok ol it lb b lc ot lf ou li ov lm ow lq ox lu op oq or os bi translated"><code class="fe nb nc nd ne b">paths</code>不带<code class="fe nb nc nd ne b">baseUrl</code>。</li><li id="074f" class="ok ol it lb b lc ot lf ou li ov lm ow lq ox lu op oq or os bi translated"><code class="fe nb nc nd ne b">checkJs</code>寓意<code class="fe nb nc nd ne b">allowJs</code>。</li><li id="e1d2" class="ok ol it lb b lc ot lf ou li ov lm ow lq ox lu op oq or os bi translated">JSDoc <code class="fe nb nc nd ne b">@see</code>标签的编辑器支持。</li></ul><p id="d8f6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">虽然4.1测试版已经发布，但我们还看不到很多性能或编辑器支持方面的改进。但是在TypeScript 4.1的稳定发布之前还有足够的时间。让我们期待在接下来的日子里会有更多现有的功能被添加进来。</p><p id="a87e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">你可以在<a class="ae ky" href="https://devblogs.microsoft.com/typescript/announcing-typescript-4-1-beta/#no-unchecked-indexed-access" rel="noopener ugc nofollow" target="_blank"> GitHub </a>上找到TypeSCript 4.1的迭代计划，也可以在<a class="ae ky" href="https://github.com/microsoft/TypeScript/issues/40124" rel="noopener ugc nofollow" target="_blank">文档</a>中找到关于上述特性的更多细节。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="289f" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">参考</h1><ul class=""><li id="28f0" class="ok ol it lb b lc mu lf mv li pj lm pk lq pl lu op oq or os bi translated"><a class="ae ky" href="https://devblogs.microsoft.com/typescript/announcing-typescript-4-1-beta/#no-unchecked-indexed-access" rel="noopener ugc nofollow" target="_blank">打字稿的文档</a></li></ul></div></div>    
</body>
</html>