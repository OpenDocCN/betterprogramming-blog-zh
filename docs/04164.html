<html>
<head>
<title>Why and How to Use Kotlin’s Native Serialization Library</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">为什么以及如何使用Kotlin的原生序列化库</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/why-and-how-to-use-kotlins-native-serialization-library-c88c0f14f93d?source=collection_archive---------0-----------------------#2020-03-27">https://betterprogramming.pub/why-and-how-to-use-kotlins-native-serialization-library-c88c0f14f93d?source=collection_archive---------0-----------------------#2020-03-27</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="5b58" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">在Android中序列化JSON响应的最简单方法</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi ki"><img src="../Images/49feaa131b88068a1a3104fe7661de1a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1108/format:webp/1*v4LXaVKgUORTM_BP565Q8g.jpeg"/></div><p class="kq kr gj gh gi ks kt bd b be z dk translated">图片来源:科特林</p></figure></div><div class="ab cl ku kv hx kw" role="separator"><span class="kx bw bk ky kz la"/><span class="kx bw bk ky kz la"/><span class="kx bw bk ky kz"/></div><div class="im in io ip iq"><h1 id="a12e" class="lb lc it bd ld le lf lg lh li lj lk ll jz lm ka ln kc lo kd lp kf lq kg lr ls bi translated">从文章中摘录</h1><p id="eab5" class="pw-post-body-paragraph lt lu it lv b lw lx ju ly lz ma jx mb mc md me mf mg mh mi mj mk ml mm mn mo im bi translated">到本文结束时，您将了解为什么Kotlin的团队创建了一个新的序列化库，尽管有许多高级库，如<a class="ae mp" href="https://github.com/square/moshi" rel="noopener ugc nofollow" target="_blank"> Moshi </a>和<a class="ae mp" href="https://github.com/google/gson/blob/master/UserGuide.md" rel="noopener ugc nofollow" target="_blank"> Gson </a>。除此之外，您还将学习如何使用本机序列化库，如果您有足够的耐心一直读到最后，您可能还会知道本机序列化的隐藏特性。请继续阅读，了解它们。</p></div><div class="ab cl ku kv hx kw" role="separator"><span class="kx bw bk ky kz la"/><span class="kx bw bk ky kz la"/><span class="kx bw bk ky kz"/></div><div class="im in io ip iq"><h1 id="ee4a" class="lb lc it bd ld le lf lg lh li lj lk ll jz lm ka ln kc lo kd lp kf lq kg lr ls bi translated">为什么Kotlin团队创建了一个新的序列化库</h1><p id="f071" class="pw-post-body-paragraph lt lu it lv b lw lx ju ly lz ma jx mb mc md me mf mg mh mi mj mk ml mm mn mo im bi translated">我们有许多著名且有效的序列化库，比如Square的Moshi和Google的Gson。但是Kotlin团队决定为Kotlin创建一个全新的本地序列化库。问题是，为什么？</p><p id="d07c" class="pw-post-body-paragraph lt lu it lv b lw mq ju ly lz mr jx mb mc ms me mf mg mt mi mj mk mu mm mn mo im bi translated">像Moshi和Gson这样的序列化库都是使用反射的Java库，对于Android开发来说很好。Kotlin不限于Android(JVM)；它支持JavaScript(JS)和IOS(原生)开发。反射肯定不会与<a class="ae mp" href="https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.js/" rel="noopener ugc nofollow" target="_blank"> Kotlin.js </a>和本机模块一起工作。此外，在Android中使用反射也是一个缺点。</p><p id="a9a7" class="pw-post-body-paragraph lt lu it lv b lw mq ju ly lz mr jx mb mc ms me mf mg mt mi mj mk mu mm mn mo im bi translated">除了多平台支持和在序列化中使用反射，Java序列化库还有一个缺点:它们不支持Kotlin中的默认值变量。为了清楚地理解它，让我们从一个简单的数据类开始，如下所示:</p><pre class="kj kk kl km gt mv mw mx my aw mz bi"><span id="b548" class="na lc it mw b gy nb nc l nd ne"><strong class="mw iu">data class SimpleExample</strong>(<strong class="mw iu">val </strong>data : <strong class="mw iu">String</strong>,<br/>                         <strong class="mw iu">var </strong>optionalData : <strong class="mw iu">String </strong>= "empty")</span></pre><p id="2b41" class="pw-post-body-paragraph lt lu it lv b lw mq ju ly lz mr jx mb mc ms me mf mg mt mi mj mk mu mm mn mo im bi translated">当我们试图解析只有<code class="fe nf ng nh mw b">data </code>节点的JSON时，那么<code class="fe nf ng nh mw b">optionalData </code>值被更改为<code class="fe nf ng nh mw b">null </code>，而不是像在数据类中声明的那样分配一个默认值<code class="fe nf ng nh mw b">empty </code>。这是一个大问题，因为当一个变量不带问号声明时，Kotlin编译器将保证该变量永远不会成为<code class="fe nf ng nh mw b">null</code>，但是普通的Java序列化库并不知道这一点。这种类型的功能冲突会导致应用程序出现意外行为。</p><p id="b70d" class="pw-post-body-paragraph lt lu it lv b lw mq ju ly lz mr jx mb mc ms me mf mg mt mi mj mk mu mm mn mo im bi translated">因此，Kotlin团队决定创建一个序列化库，它可以与它支持的所有平台一起工作，并且没有反射。</p></div><div class="ab cl ku kv hx kw" role="separator"><span class="kx bw bk ky kz la"/><span class="kx bw bk ky kz la"/><span class="kx bw bk ky kz"/></div><div class="im in io ip iq"><h1 id="d42c" class="lb lc it bd ld le lf lg lh li lj lk ll jz lm ka ln kc lo kd lp kf lq kg lr ls bi translated">综合</h1><p id="63ab" class="pw-post-body-paragraph lt lu it lv b lw lx ju ly lz ma jx mb mc md me mf mg mh mi mj mk ml mm mn mo im bi translated">要使用Kotlin序列化库，我们必须集成序列化插件和运行时序列化库。序列化插件生成代码来解析JSON，而不使用任何反射。另一方面，运行时库使用这些代码来序列化数据类。</p><p id="62e6" class="pw-post-body-paragraph lt lu it lv b lw mq ju ly lz mr jx mb mc ms me mf mg mt mi mj mk mu mm mn mo im bi translated">要集成序列化插件，请在应用程序级<code class="fe nf ng nh mw b">build.gradle</code> <strong class="lv iu"> </strong>文件顶部的所有插件下添加以下代码行。</p><pre class="kj kk kl km gt mv mw mx my aw mz bi"><span id="725a" class="na lc it mw b gy nb nc l nd ne">apply plugin: 'kotlinx-serialization'</span></pre><p id="69d1" class="pw-post-body-paragraph lt lu it lv b lw mq ju ly lz mr jx mb mc ms me mf mg mt mi mj mk mu mm mn mo im bi translated">您还需要在项目级<code class="fe nf ng nh mw b">build.gradle</code>文件中的dependencies节点下添加下面一行:</p><pre class="kj kk kl km gt mv mw mx my aw mz bi"><span id="7a27" class="na lc it mw b gy nb nc l nd ne">classpath <strong class="mw iu">"org.jetbrains.kotlin:kotlin-serialization:$kotlin_version"</strong></span></pre><p id="4f01" class="pw-post-body-paragraph lt lu it lv b lw mq ju ly lz mr jx mb mc ms me mf mg mt mi mj mk mu mm mn mo im bi translated">然后在应用程序级的<code class="fe nf ng nh mw b">build.gradle</code>文件中的dependencies标签下添加下面的库实现行:</p><pre class="kj kk kl km gt mv mw mx my aw mz bi"><span id="e82c" class="na lc it mw b gy nb nc l nd ne">implementation "<strong class="mw iu">org.jetbrains.kotlinx:kotlinx-serialization-runtime:0.20.0</strong>"</span></pre></div><div class="ab cl ku kv hx kw" role="separator"><span class="kx bw bk ky kz la"/><span class="kx bw bk ky kz la"/><span class="kx bw bk ky kz"/></div><div class="im in io ip iq"><h1 id="7562" class="lb lc it bd ld le lf lg lh li lj lk ll jz lm ka ln kc lo kd lp kf lq kg lr ls bi translated">如何对数据类使用Kotlin序列化</h1><p id="fcaf" class="pw-post-body-paragraph lt lu it lv b lw lx ju ly lz ma jx mb mc md me mf mg mh mi mj mk ml mm mn mo im bi translated">Kotlin团队的这个原生库可以很快完成序列化。我们需要在预期的类上面添加<code class="fe nf ng nh mw b">@Serializable </code>注释。看一看:</p><pre class="kj kk kl km gt mv mw mx my aw mz bi"><span id="20ac" class="na lc it mw b gy nb nc l nd ne"><strong class="mw iu">@Serializable<br/>data class SimpleExample</strong>(<strong class="mw iu">val </strong>data : <strong class="mw iu">String</strong>,<br/>                         <strong class="mw iu">var </strong>optionalData : <strong class="mw iu">String </strong>= "empty")</span></pre><p id="d41a" class="pw-post-body-paragraph lt lu it lv b lw mq ju ly lz mr jx mb mc ms me mf mg mt mi mj mk mu mm mn mo im bi translated">仅此而已；您不需要像处理常规库那样用可序列化标签来注释每个变量。这很简单。现在让我们看一个更真实的例子，关于<a class="ae mp" href="https://square.github.io/retrofit/" rel="noopener ugc nofollow" target="_blank">改型2 </a>。</p></div><div class="ab cl ku kv hx kw" role="separator"><span class="kx bw bk ky kz la"/><span class="kx bw bk ky kz la"/><span class="kx bw bk ky kz"/></div><div class="im in io ip iq"><h1 id="7976" class="lb lc it bd ld le lf lg lh li lj lk ll jz lm ka ln kc lo kd lp kf lq kg lr ls bi translated">用kotlinx-serialization改进2</h1><p id="3b38" class="pw-post-body-paragraph lt lu it lv b lw lx ju ly lz ma jx mb mc md me mf mg mh mi mj mk ml mm mn mo im bi translated">我们都熟悉用于<a class="ae mp" href="https://github.com/ReactiveX/RxJava/wiki" rel="noopener ugc nofollow" target="_blank"> RxJava </a>、<a class="ae mp" href="https://kotlinlang.org/docs/reference/coroutines-overview.html" rel="noopener ugc nofollow" target="_blank">协程</a>、Moshi和其他库的改型适配器，对吗？同样，Kotlin序列化也有一个来自<a class="ae mp" href="https://github.com/JakeWharton/retrofit2-kotlinx-serialization-converter/commits?author=JakeWharton" rel="noopener ugc nofollow" target="_blank"> JakeWharton </a>的适配器，通过它我们可以将改型响应与Kotlin序列化代码链接起来。</p><p id="f1be" class="pw-post-body-paragraph lt lu it lv b lw mq ju ly lz mr jx mb mc ms me mf mg mt mi mj mk mu mm mn mo im bi translated">要将这个库集成到您的项目中，请在应用程序级<code class="fe nf ng nh mw b">build.gradle</code>文件中的<code class="fe nf ng nh mw b">dependencies </code>节点下添加以下代码行:</p><pre class="kj kk kl km gt mv mw mx my aw mz bi"><span id="7643" class="na lc it mw b gy nb nc l nd ne">implementation("<strong class="mw iu">com.jakewharton.retrofit:retrofit2-kotlinx-serialization-converter:0.5.0</strong>")</span></pre><p id="9b56" class="pw-post-body-paragraph lt lu it lv b lw mq ju ly lz mr jx mb mc ms me mf mg mt mi mj mk mu mm mn mo im bi translated">现在是时候将适配器与改造实例联系起来了。看看下面的代码:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ni nj l"/></div></figure><p id="82c5" class="pw-post-body-paragraph lt lu it lv b lw mq ju ly lz mr jx mb mc ms me mf mg mt mi mj mk mu mm mn mo im bi translated">假设结果数据类被标注了<code class="fe nf ng nh mw b">@Serializable</code>标签，这就是我们需要做的。其余的将由Kotlin序列化转换器处理。</p></div><div class="ab cl ku kv hx kw" role="separator"><span class="kx bw bk ky kz la"/><span class="kx bw bk ky kz la"/><span class="kx bw bk ky kz"/></div><div class="im in io ip iq"><h1 id="4d85" class="lb lc it bd ld le lf lg lh li lj lk ll jz lm ka ln kc lo kd lp kf lq kg lr ls bi translated">隐藏功能</h1><h2 id="b5dd" class="na lc it bd ld nk nl dn lh nm nn dp ll mc no np ln mg nq nr lp mk ns nt lr nu bi translated">编译时安全</h2><p id="7f9f" class="pw-post-body-paragraph lt lu it lv b lw lx ju ly lz ma jx mb mc md me mf mg mh mi mj mk ml mm mn mo im bi translated">这是在你做一些复杂的序列化时使用的，比如你在响应数据类中嵌套了类。看一看:</p><pre class="kj kk kl km gt mv mw mx my aw mz bi"><span id="973f" class="na lc it mw b gy nb nc l nd ne"><strong class="mw iu">@Serializable<br/>data class SimpleExample</strong>(<strong class="mw iu">val </strong>data : <strong class="mw iu">String</strong>,<br/>                         <strong class="mw iu">var </strong>optionalData : <strong class="mw iu">String </strong>= "empty",<br/>                         <strong class="mw iu">var complexClass</strong>: <strong class="mw iu">ComplexClass </strong>)</span></pre><p id="509a" class="pw-post-body-paragraph lt lu it lv b lw mq ju ly lz mr jx mb mc ms me mf mg mt mi mj mk mu mm mn mo im bi translated">你已经用<code class="fe nf ng nh mw b">@Serializable</code>注释了<code class="fe nf ng nh mw b">SimpleExample</code>数据类，这很好，但是如果你忘记注释<code class="fe nf ng nh mw b">ComplexClass</code>该怎么办呢？这会导致运行时崩溃吗？或者你已经自己明确地检查了每个嵌套类是否被注释了？</p><p id="015f" class="pw-post-body-paragraph lt lu it lv b lw mq ju ly lz mr jx mb mc ms me mf mg mt mi mj mk mu mm mn mo im bi translated">放松；上述灾难都不会发生，因为Kotlin序列化库是编译时安全的，这意味着如果您没有用<code class="fe nf ng nh mw b"><strong class="lv iu">@</strong>Serializable</code> <strong class="lv iu">、</strong>注释任何嵌套类，无论树结构有多深<strong class="lv iu">，它都会显示一个错误。</strong></p><h2 id="d61b" class="na lc it bd ld nk nl dn lh nm nn dp ll mc no np ln mg nq nr lp mk ns nt lr nu bi translated">瞬态和可选注释</h2><p id="aa1b" class="pw-post-body-paragraph lt lu it lv b lw lx ju ly lz ma jx mb mc md me mf mg mh mi mj mk ml mm mn mo im bi translated"><strong class="lv iu"> Transient: </strong>通过将数据类中的一个变量注释为<code class="fe nf ng nh mw b">@Transient</code>，我们指示序列化程序完全忽略这个字段。</p><p id="0889" class="pw-post-body-paragraph lt lu it lv b lw mq ju ly lz mr jx mb mc ms me mf mg mt mi mj mk mu mm mn mo im bi translated"><strong class="lv iu">可选:</strong>通过将数据类中的一个变量注释为<code class="fe nf ng nh mw b">@Optional</code>，我们向序列化程序表明这个变量是可选的，所以如果在响应中没有找到它，不要中断流程。此外，我们可以分配一个默认值，如下所示。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ni nj l"/></div></figure><p id="b974" class="pw-post-body-paragraph lt lu it lv b lw mq ju ly lz mr jx mb mc ms me mf mg mt mi mj mk mu mm mn mo im bi translated">这两个注释很有意义，我不知道Java库是怎么漏掉的。</p></div><div class="ab cl ku kv hx kw" role="separator"><span class="kx bw bk ky kz la"/><span class="kx bw bk ky kz la"/><span class="kx bw bk ky kz"/></div><div class="im in io ip iq"><h1 id="6b2f" class="lb lc it bd ld le lf lg lh li lj lk ll jz lm ka ln kc lo kd lp kf lq kg lr ls bi translated">奖金</h1><p id="d59c" class="pw-post-body-paragraph lt lu it lv b lw lx ju ly lz ma jx mb mc md me mf mg mh mi mj mk ml mm mn mo im bi translated">要了解更多关于Kotlin的信息，请阅读Kotlin高级编程系列的前几部分:</p><ul class=""><li id="a623" class="nv nw it lv b lw mq lz mr mc nx mg ny mk nz mo oa ob oc od bi translated"><a class="ae mp" href="https://medium.com/better-programming/advanced-android-programming-with-kotlin-5e40b1be22bb" rel="noopener">“使用Kotlin进行高级编程</a>”</li><li id="3500" class="nv nw it lv b lw oe lz of mc og mg oh mk oi mo oa ob oc od bi translated"><a class="ae mp" href="https://medium.com/android-dev-hacks/advanced-android-programming-with-kotlin-part-2-aae2a15258b0" rel="noopener">“用Kotlin进行高级编程(第二部分</a>)”</li><li id="cd40" class="nv nw it lv b lw oe lz of mc og mg oh mk oi mo oa ob oc od bi translated"><a class="ae mp" href="https://medium.com/better-programming/advanced-programming-in-kotlin-2e01fbc39134" rel="noopener">“用Kotlin进行高级编程(第三部分</a>)”</li><li id="125b" class="nv nw it lv b lw oe lz of mc og mg oh mk oi mo oa ob oc od bi translated"><a class="ae mp" href="https://medium.com/better-programming/advanced-android-programing-in-kotlin-part-4-187b88fea048" rel="noopener">“kot Lin中的高级Android编程(第四部分)”</a></li></ul><p id="46d5" class="pw-post-body-paragraph lt lu it lv b lw mq ju ly lz mr jx mb mc ms me mf mg mt mi mj mk mu mm mn mo im bi translated">要了解更多关于Kotlin协同例程和Kotlin的其他高级特性，请阅读以下文章:</p><ul class=""><li id="19c5" class="nv nw it lv b lw mq lz mr mc nx mg ny mk nz mo oa ob oc od bi translated"><a class="ae mp" href="https://medium.com/better-programming/kotlin-coroutines-from-basics-to-advanced-ad3eb1421006" rel="noopener">“科特林协程，从基础到高级</a>”</li><li id="f6e6" class="nv nw it lv b lw oe lz of mc og mg oh mk oi mo oa ob oc od bi translated"><a class="ae mp" href="https://medium.com/better-programming/asynchronous-data-loading-with-new-kotlin-flow-233f85ae1d8b" rel="noopener">“使用新Kotlin流程进行异步数据加载</a></li><li id="a662" class="nv nw it lv b lw oe lz of mc og mg oh mk oi mo oa ob oc od bi translated"><a class="ae mp" href="https://medium.com/better-programming/exploring-collections-and-sequences-in-kotlin-3a324ea08fb9" rel="noopener">“探索Kotlin中的集合和序列”</a></li></ul></div><div class="ab cl ku kv hx kw" role="separator"><span class="kx bw bk ky kz la"/><span class="kx bw bk ky kz la"/><span class="kx bw bk ky kz"/></div><div class="im in io ip iq"><p id="309f" class="pw-post-body-paragraph lt lu it lv b lw mq ju ly lz mr jx mb mc ms me mf mg mt mi mj mk mu mm mn mo im bi translated">在我们结束之前，我要感谢列昂尼德·斯塔策夫。我从他在KotlinConfig 2019的演讲中学到了很多我在这里提到的概念。</p><p id="4b72" class="pw-post-body-paragraph lt lu it lv b lw mq ju ly lz mr jx mb mc ms me mf mg mt mi mj mk mu mm mn mo im bi translated">感谢您的阅读。</p></div></div>    
</body>
</html>