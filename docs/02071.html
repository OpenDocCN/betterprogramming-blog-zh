<html>
<head>
<title>Common JavaScript Mistakes — Part 1</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">常见的JavaScript错误—第1部分</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/common-javascript-mistakes-part-1-73e1654a26c?source=collection_archive---------11-----------------------#2019-11-04">https://betterprogramming.pub/common-javascript-mistakes-part-1-73e1654a26c?source=collection_archive---------11-----------------------#2019-11-04</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="a4b6" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">要记住的好事情</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/2738d2a841ff98e52e9b56b36fe46be5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*M_BVJJC0vAApyOnG"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated"><a class="ae ky" href="https://unsplash.com/@hhh13?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">傅勇华</a>在<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的照片</p></figure><p id="3e66" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">JavaScript是一种比世界上许多其他编程语言更友好的语言。然而，在编写JavaScript代码时，由于误解或忽略我们已经知道的东西，仍然很容易犯错误。通过避免下面的一些错误，我们可以通过防止代码中的错误和错别字来使我们的生活变得更容易，这些错误和错别字会使我们陷入意想不到的结果。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="2c8d" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">括号不匹配</h1><p id="2878" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">语句和函数相互嵌套意味着每个文件中有多层括号。通常情况下，应用程序非常复杂，所以级别可能会增加。这意味着，如果您使用的文本编辑器不支持语法高亮显示或者不检查不匹配的括号，那么不匹配的括号很容易出现。使用Visual Studio Code、Atom和Sublime等现代文本编辑器可以很容易地避免这种情况。如果我们想使用更简单的文本编辑器，那么就使用linters和代码格式化工具，比如ESLint和Prettier，来检测这些问题。它们还让我们能够自动格式化代码，并检测可能出现的常见样式问题，如引用样式不一致、一行中的字符数、可以缩短的函数等。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="06fc" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">引号和括号不匹配</h1><p id="0d99" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">JavaScript允许我们对字符串使用单引号、双引号和反引号。它们是等价的。但是，我们应该以同样的性格来打开和关闭。所以如果我们用单引号开始一个字符串，然后用单引号结束一个字符串。如果我们以双引号或反勾号开始，那么分别用它们来结束字符串。此外，在某些情况下，像引号这样的特殊字符必须转义才能包含在字符串中。如果你用单引号打开一个字符串，并且你也在字符串中使用单引号，那么你必须对它进行转义以将它们包含在字符串中。这也适用于双引号和反斜线。如果你在双引号字符串中使用双引号，那么你必须对它进行转义。如果你在模板字符串中使用反勾号，那么你必须对反勾号进行转义。</p><p id="0cef" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在<code class="fe mz na nb nc b">if</code>语句中，圆括号总是必须包围整个条件。例如，类似于</p><pre class="kj kk kl km gt nd nc ne nf aw ng bi"><span id="9538" class="nh md it nc b gy ni nj l nk nl">if (x &gt; y) &amp;&amp; (y &lt; 10) {...}</span></pre><p id="0d44" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">行不通。写这句话的正确方法是</p><pre class="kj kk kl km gt nd nc ne nf aw ng bi"><span id="5074" class="nh md it nc b gy ni nj l nk nl">if ((x &gt; y) &amp;&amp; (y &lt; 10)) {...}</span></pre><p id="7e34" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果我们想检查两个条件是否都为真。</p><p id="d673" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们可以通过使用JavaScript代码感知文本编辑器(如Visual Studio代码)轻松避免这种情况，它会为我们突出显示这些语法错误，以便我们可以修复这些错误并使代码运行。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="908a" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">混淆=、==和===运算符</h1><p id="25c1" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">单个等号(=)运算符用于将右侧的数据赋给左侧的变量。不要将它与双等于(==)和三等于运算符(===)混淆，这两种运算符用于比较运算符左侧和右侧的值。在JavaScript中，我们可以在一个<code class="fe mz na nb nc b">if</code>语句中使用所有三个操作符。然而，在大多数情况下，我们并不打算在<code class="fe mz na nb nc b">if</code>语句的条件中使用单个等号运算符。我们实际上想要的是使用double或triple equals运算符来比较它左边和右边的操作数。</p><p id="3608" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">例如，我们不应该写</p><pre class="kj kk kl km gt nd nc ne nf aw ng bi"><span id="df0d" class="nh md it nc b gy ni nj l nk nl">if (x = 1){ ... }</span></pre><p id="98bb" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">因为我们不想在<code class="fe mz na nb nc b">if</code>语句中给<code class="fe mz na nb nc b">x</code>赋值1。相反，我们应该使用双倍或三倍等于运算符，如下面的代码所示</p><pre class="kj kk kl km gt nd nc ne nf aw ng bi"><span id="3c48" class="nh md it nc b gy ni nj l nk nl">if (x == 1){ ... }</span></pre><p id="557f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">或者</p><pre class="kj kk kl km gt nd nc ne nf aw ng bi"><span id="e286" class="nh md it nc b gy ni nj l nk nl">if (x === 1){ ... }</span></pre><p id="bca0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">第一个例子，<code class="fe mz na nb nc b">if (x = 1){ … }</code>，总是<code class="fe mz na nb nc b">true</code>，因为<code class="fe mz na nb nc b">x</code>是真的，因为它被赋值为1，这是真的。我们实际上想要的是利用条件语句<code class="fe mz na nb nc b">if</code>进行比较。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="f756" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">在块级别之外使用变量</h1><p id="6fb3" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">如果我们使用<code class="fe mz na nb nc b">var</code>关键字声明一个变量，它可以在<code class="fe mz na nb nc b">var</code>表达式下面的任何地方被引用。例如，假设我们有:</p><pre class="kj kk kl km gt nd nc ne nf aw ng bi"><span id="ee1f" class="nh md it nc b gy ni nj l nk nl">for (var j = 0; j &lt; 10; j++) {<br/>  j = j + 1;<br/>}<br/>console.log(j);</span></pre><p id="6f6c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">然后我们可以看到当我们在代码的最后一行运行<code class="fe mz na nb nc b">console.log</code>语句时<code class="fe mz na nb nc b">j</code>是10。这就是我们用<code class="fe mz na nb nc b">let</code>和<code class="fe mz na nb nc b">const</code>关键字来声明变量和常量的原因。它们被限制了作用域，因此不能在块外引用。这意味着我们避免了使用<code class="fe mz na nb nc b">var</code>时可能出现的错误，因为变量不能在声明它的块之外被访问。因此，我们不能意外地将它赋给其他任何东西，从而导致我们的代码出现问题。我们可以像下面的例子那样使用<code class="fe mz na nb nc b">let</code>，而不是像上面的例子那样使用<code class="fe mz na nb nc b">var</code>:</p><pre class="kj kk kl km gt nd nc ne nf aw ng bi"><span id="4841" class="nh md it nc b gy ni nj l nk nl">for (let j = 0; j &lt; 10; j++) {<br/>  j = j + 1;<br/>}<br/>console.log(j);</span></pre><p id="7942" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">当我们运行上面的代码时，我们应该得到<code class="fe mz na nb nc b">ReferenceError: j is not defined</code>，这是一个好迹象，因为我们不希望<code class="fe mz na nb nc b">j</code>在<code class="fe mz na nb nc b">for</code>循环之外被引用。如果我们删除<code class="fe mz na nb nc b">console.log</code>语句，那么它将运行。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nm"><img src="../Images/f4603635a5de4f81f91e8bf71ede5af5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*6IR511ZETkXZ5AYk"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">席琳·艺伎回忆录·塔加米在<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的照片</p></figure></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="dc44" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">将类似数组的可迭代对象视为数组</h1><p id="306a" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">在JavaScript中，我们可以拥有带有数字关键字的属性。它们在被访问之前被自动转换成字符串，因为它们实际上是包含所有数字内容的字符串。像<code class="fe mz na nb nc b">arguments</code>和<code class="fe mz na nb nc b">NodeList</code>这样的对象不是数组，但是它们的属性像数组一样用整数键存储。很容易把它们误认为数组。数组和类数组对象的区别在于类数组对象不是数组，但它们都有一个以符号<code class="fe mz na nb nc b">Symbol.Iterator</code>作为标识符的函数。在这些情况下，我们可以将它们转换成数组。例如，如果我们想用<code class="fe mz na nb nc b">arguments</code>对象将参数传递给一个常规函数，我们用spread操作符编写如下内容:</p><pre class="kj kk kl km gt nd nc ne nf aw ng bi"><span id="9464" class="nh md it nc b gy ni nj l nk nl">function f() {<br/>  const args = [...arguments];<br/>  console.log(args);<br/>}<br/>f(1, 2, 3);</span></pre><p id="723c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果我们运行上面的代码，我们得到<code class="fe mz na nb nc b">[1,2,3]</code>。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="3133" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">混淆非数组对象和数组</h1><p id="d896" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">因为我们可以用括号符号访问对象属性和数组条目，这在用于数组和常规对象时看起来是一样的，所以很容易混淆对象和数组。</p><p id="5ece" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">例如，假设我们有以下代码:</p><pre class="kj kk kl km gt nd nc ne nf aw ng bi"><span id="aa72" class="nh md it nc b gy ni nj l nk nl">const obj = {<br/>  0: 1,<br/>  1: 2,<br/>  2: 3<br/>};<br/>console.log(obj[0]);</span></pre><p id="798d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们看到<code class="fe mz na nb nc b">console.log</code>语句将返回1。上面的代码有一个常规对象，但是在<code class="fe mz na nb nc b">console.log</code>语句中，我们将0作为带括号符号的键传入，以获得值<code class="fe mz na nb nc b">obj[0]</code>，即1。</p><p id="49f0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果我们有一个数组，我们试图通过它的索引来访问一个条目，如下面的代码所示:</p><pre class="kj kk kl km gt nd nc ne nf aw ng bi"><span id="27ac" class="nh md it nc b gy ni nj l nk nl">const arr = [1, 2, 3];<br/>console.log(arr[0]);</span></pre><p id="8f46" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">对于<code class="fe mz na nb nc b">console.log</code>语句，我们也得到了1。它们都使用括号符号来访问它们的值，但它们并不相同。数组是对象，但与常规对象不同，您可以遍历它们。如果您试图用<code class="fe mz na nb nc b">for...of</code>循环或<code class="fe mz na nb nc b">forEach</code>函数循环遍历一个数组，或者尝试对其使用spread操作符，那么带有<code class="fe mz na nb nc b">obj</code>对象的示例将会导致错误，因为它不是一个可迭代的对象。我们可以通过添加一个带有符号<code class="fe mz na nb nc b">Symbol.iterator</code>的生成器函数来使它可迭代，如下面的代码所示:</p><pre class="kj kk kl km gt nd nc ne nf aw ng bi"><span id="7e4a" class="nh md it nc b gy ni nj l nk nl">const obj = {<br/>  0: 1,<br/>  1: 2,<br/>  2: 3,<br/>  [Symbol.iterator]: function*() {<br/>    for (let prop in this) {<br/>      yield this[prop];<br/>    }<br/>  }<br/>};</span></pre><p id="591e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">然后，当我们像下面这样用<code class="fe mz na nb nc b">for...of</code>循环迭代<code class="fe mz na nb nc b">obj</code>对象时:</p><pre class="kj kk kl km gt nd nc ne nf aw ng bi"><span id="30cb" class="nh md it nc b gy ni nj l nk nl">for (let num of obj) {<br/>  console.log(num);<br/>}</span></pre><p id="d603" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们取回了我们使之可迭代的新的<code class="fe mz na nb nc b">obj</code>对象的条目。</p><p id="91e1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">扩展操作符也可以工作。如果我们有以下代码:</p><pre class="kj kk kl km gt nd nc ne nf aw ng bi"><span id="a33a" class="nh md it nc b gy ni nj l nk nl">console.log([...obj]);</span></pre><p id="8c6c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们从<code class="fe mz na nb nc b">console.log</code>输出中得到<code class="fe mz na nb nc b">[1, 2, 3]</code>。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><p id="89b6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">大多数避免错误的技巧都包含了ES6的特性。这是ES6发布的一个主要原因。生成器和<code class="fe mz na nb nc b">let</code>和<code class="fe mz na nb nc b">const</code>关键字都是规范的一部分。ES6的使用，以及更好的文本编辑器，如Visual Studio代码，帮助我们避免了使用旧技术时会犯的错误。这是保持JavaScript代码和工具更新的一个很好的理由。ES6是2015年发布的，所以没有理由留在后面。对于像Internet Explorer这样的老浏览器，我们可以使用类似Babel的东西动态地将其转换为ES5。或者我们可以使用像Webpack这样的模块捆绑器，在构建工件中将ES6或更高版本的代码转换成ES5，这样我们就可以用较新版本的JavaScript编写代码。</p></div></div>    
</body>
</html>