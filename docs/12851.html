<html>
<head>
<title>How to Write Unit Tests for Combine’s Debounce Method in iOS</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何在iOS中为Combine的去抖方法编写单元测试</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/how-to-write-unit-tests-for-combines-debounce-method-in-ios-2257f1523002?source=collection_archive---------14-----------------------#2022-07-06">https://betterprogramming.pub/how-to-write-unit-tests-for-combines-debounce-method-in-ios-2257f1523002?source=collection_archive---------14-----------------------#2022-07-06</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="0e90" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">测试很容易。编写可测试的代码不是。</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/f9247ebe562321b539474e3b2139ae1e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*wBeRnCrmM28xVes_SBpicA.jpeg"/></div></div></figure><h1 id="cabe" class="kr ks iq bd kt ku kv kw kx ky kz la lb jw lc jx ld jz le ka lf kc lg kd lh li bi translated">关于组合测试的几句话</h1><p id="e24b" class="pw-post-body-paragraph lj lk iq ll b lm ln jr lo lp lq ju lr ls lt lu lv lw lx ly lz ma mb mc md me ij bi translated">编写可测试的代码可能很难。编写需要异步工作的可测试代码更加困难。</p><p id="cfa8" class="pw-post-body-paragraph lj lk iq ll b lm mf jr lo lp mg ju lr ls mh lu lv lw mi ly lz ma mj mc md me ij bi translated">大部分实现combine的应用程序主要使用它来支持并发代码，而不是同步代码。显然，采用合并操作来支持异步和同步操作是可能的，但是在我看来，使用合并来执行与以下任何一项都不相关的工作:</p><ul class=""><li id="c2a1" class="mk ml iq ll b lm mf lp mg ls mm lw mn ma mo me mp mq mr ms bi translated">执行后台工作</li><li id="525d" class="mk ml iq ll b lm mt lp mu ls mv lw mw ma mx me mp mq mr ms bi translated">组合多个来源</li><li id="5f1c" class="mk ml iq ll b lm mt lp mu ls mv lw mw ma mx me mp mq mr ms bi translated">异步初始化</li></ul><p id="731d" class="pw-post-body-paragraph lj lk iq ll b lm mf jr lo lp mg ju lr ls mh lu lv lw mi ly lz ma mj mc md me ij bi translated">这是对可读性的浪费。</p><p id="c232" class="pw-post-body-paragraph lj lk iq ll b lm mf jr lo lp mg ju lr ls mh lu lv lw mi ly lz ma mj mc md me ij bi translated">在这篇文章中，我想告诉你如何正确地测试<code class="fe my mz na nb b">debounce</code>方法，以避免长时间的代码执行和不稳定的测试。</p><h1 id="11ff" class="kr ks iq bd kt ku kv kw kx ky kz la lb jw lc jx ld jz le ka lf kc lg kd lh li bi translated">去抖</h1><p id="1373" class="pw-post-body-paragraph lj lk iq ll b lm ln jr lo lp lq ju lr ls lt lu lv lw lx ly lz ma mb mc md me ij bi translated">先从<code class="fe my mz na nb b">debounce</code>开始，我简单提醒一下这个方法是什么，定义是什么:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nc nd l"/></div></figure><p id="9ca9" class="pw-post-body-paragraph lj lk iq ll b lm mf jr lo lp mg ju lr ls mh lu lv lw mi ly lz ma mj mc md me ij bi translated">根据Apple文档:</p><blockquote class="ne nf ng"><p id="3414" class="lj lk nh ll b lm mf jr lo lp mg ju lr ni mh lu lv nj mi ly lz nk mj mc md me ij bi translated">仅在事件之间经过指定的时间间隔后发布元素。</p></blockquote><p id="2237" class="pw-post-body-paragraph lj lk iq ll b lm mf jr lo lp mg ju lr ls mh lu lv lw mi ly lz ma mj mc md me ij bi translated">基本上，<code class="fe my mz na nb b">debounce</code>会在收到每个值后暂停一段时间，然后在暂停结束时发送最后一个值。</p><p id="12c8" class="pw-post-body-paragraph lj lk iq ll b lm mf jr lo lp mg ju lr ls mh lu lv lw mi ly lz ma mj mc md me ij bi translated">什么时候可以用？基本上，每当您试图限制发送事件的数量时，并不是每个事件都是重要的，相反，知道特定事件序列的最后结果是至关重要的。最常见的情况是在用户输入查询时限制对API的请求数量。</p><p id="aa2b" class="pw-post-body-paragraph lj lk iq ll b lm mf jr lo lp mg ju lr ls mh lu lv lw mi ly lz ma mj mc md me ij bi translated">在一个假设的情况下，假设一个用户正在寻找一个特定的产品(iPhone ),并且在每次击键之后请求被发送到一个API。下图显示了每个请求是如何发送到服务器的。如您所见，在简单的实现中，每个字母都会触发一个新的API请求。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi nl"><img src="../Images/6d5716efbf5c7e27b4cf5235d7ee280a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1102/format:webp/1*H3cpTlpy8ZO5kHlIDUhg_Q.png"/></div></figure><p id="0664" class="pw-post-body-paragraph lj lk iq ll b lm mf jr lo lp mg ju lr ls mh lu lv lw mi ly lz ma mj mc md me ij bi translated">发送一个无关紧要的请求是低效的，还会导致不一致。例如，在前面的一个请求在最后一个请求之前执行的情况下。显然，您可以在执行下一个请求之前取消每个请求。但是它给代码库带来了一部分新的代码，必须对其进行测试和维护。这就是<code class="fe my mz na nb b">debounce</code>帮助我们的地方。</p><p id="1f2e" class="pw-post-body-paragraph lj lk iq ll b lm mf jr lo lp mg ju lr ls mh lu lv lw mi ly lz ma mj mc md me ij bi translated">通过提供有效的参数，您可以确保创建新的请求会延迟到预定的时间过去之后。在上面的例子中，大约0.5秒的延迟时间足够大多数用户输入下一个字符，只创建一个请求:<code class="fe my mz na nb b">Request — (IPHONE)</code>。显然，如果用户打字速度很慢，请求将被多次创建，在运行下一个之前取消它是开发人员的责任。</p><p id="e724" class="pw-post-body-paragraph lj lk iq ll b lm mf jr lo lp mg ju lr ls mh lu lv lw mi ly lz ma mj mc md me ij bi translated">现在让我们把它做好，确保可测试性和良好的抽象水平，使代码可测试、可读和可维护。</p><h1 id="9722" class="kr ks iq bd kt ku kv kw kx ky kz la lb jw lc jx ld jz le ka lf kc lg kd lh li bi translated">现实生活中的例子</h1><p id="51fc" class="pw-post-body-paragraph lj lk iq ll b lm ln jr lo lp lq ju lr ls lt lu lv lw lx ly lz ma mb mc md me ij bi translated">从一个图表开始，它描述了我想要创建的东西:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi nm"><img src="../Images/c648c86c9f64ef4570179a7c9210d4d3.png" data-original-src="https://miro.medium.com/v2/resize:fit:782/format:webp/1*_SG5ttqNpNXV-QeFE0vV6g.png"/></div></figure><p id="8f99" class="pw-post-body-paragraph lj lk iq ll b lm mf jr lo lp mg ju lr ls mh lu lv lw mi ly lz ma mj mc md me ij bi translated">每个访问SearchStream的客户端都能够<code class="fe my mz na nb b">subscribe</code>搜索结果并从中接收最新数据。用户还可以使用<code class="fe my mz na nb b">search</code>方法搜索特定的查询。每当客户机(用户)运行一个搜索函数时，搜索到的字符串被传递给<code class="fe my mz na nb b">SearchStream</code>，后者产生一个发布者，将搜索到的值传递回客户机。</p><p id="866e" class="pw-post-body-paragraph lj lk iq ll b lm mf jr lo lp mg ju lr ls mh lu lv lw mi ly lz ma mj mc md me ij bi translated">让我们做两个对编写本模块至关重要的假设:</p><ol class=""><li id="e46d" class="mk ml iq ll b lm mf lp mg ls mm lw mn ma mo me nn mq mr ms bi translated"><code class="fe my mz na nb b">SearchStream</code>必须在同步测试中可测试，不需要使用<code class="fe my mz na nb b">XCTest.waitForExpectations</code>。</li><li id="55aa" class="mk ml iq ll b lm mt lp mu ls mv lw mw ma mx me nn mq mr ms bi translated">客户端能够忽略去抖方法，并期望立即得到结果。</li></ol><p id="ea6f" class="pw-post-body-paragraph lj lk iq ll b lm mf jr lo lp mg ju lr ls mh lu lv lw mi ly lz ma mj mc md me ij bi translated">首先让我们从协议开始，它描述了一个<code class="fe my mz na nb b">SearchStream</code>:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nc nd l"/></div></figure><ul class=""><li id="2b12" class="mk ml iq ll b lm mf lp mg ls mm lw mn ma mo me mp mq mr ms bi translated"><code class="fe my mz na nb b">associatedtype ResponseType</code> —返回的类型</li><li id="3883" class="mk ml iq ll b lm mt lp mu ls mv lw mw ma mx me mp mq mr ms bi translated"><code class="fe my mz na nb b">var searchResult: AnyPublisher&lt;ResponseType, Never&gt;</code> —发布下一个搜索结果的流</li><li id="7a32" class="mk ml iq ll b lm mt lp mu ls mv lw mw ma mx me mp mq mr ms bi translated"><code class="fe my mz na nb b">func search(_ query: String)</code> —每次文本更改后运行的方法</li></ul><p id="e426" class="pw-post-body-paragraph lj lk iq ll b lm mf jr lo lp mg ju lr ls mh lu lv lw mi ly lz ma mj mc md me ij bi translated">使SearchStream协议不是一个类会导致代码有另一个抽象层，并且可以适应不同的需求。例如，一个流可以从后端返回值，第二个流可以在数据库中搜索以前保存的结果。</p><p id="9c55" class="pw-post-body-paragraph lj lk iq ll b lm mf jr lo lp mg ju lr ls mh lu lv lw mi ly lz ma mj mc md me ij bi translated">同样，让我们来看看去抖方法的定义:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nc nd l"/></div></figure><p id="1497" class="pw-post-body-paragraph lj lk iq ll b lm mf jr lo lp mg ju lr ls mh lu lv lw mi ly lz ma mj mc md me ij bi translated">测试期间有两件重要的事情:</p><p id="4382" class="pw-post-body-paragraph lj lk iq ll b lm mf jr lo lp mg ju lr ls mh lu lv lw mi ly lz ma mj mc md me ij bi translated"><code class="fe my mz na nb b">scheduler</code> : <strong class="ll ir"> </strong>这是一个定义何时以及如何执行闭包的协议。我们需要其中的两个:</p><ul class=""><li id="2a68" class="mk ml iq ll b lm mf lp mg ls mm lw mn ma mo me mp mq mr ms bi translated"><code class="fe my mz na nb b">RunLoop.main</code> —这是主线程上的运行循环，它将用于生产代码以接收主线程上的值。</li><li id="e544" class="mk ml iq ll b lm mt lp mu ls mv lw mw ma mx me mp mq mr ms bi translated"><code class="fe my mz na nb b">ImmediateScheduler</code> —特殊调度程序，执行同步动作。</li></ul><p id="2de5" class="pw-post-body-paragraph lj lk iq ll b lm mf jr lo lp mg ju lr ls mh lu lv lw mi ly lz ma mj mc md me ij bi translated">正确设置调度程序可以满足第一个假设:</p><blockquote class="ne nf ng"><p id="17da" class="lj lk nh ll b lm mf jr lo lp mg ju lr ni mh lu lv nj mi ly lz nk mj mc md me ij bi translated">SearchStream在同步测试中必须是可测试的，不需要使用<code class="fe my mz na nb b">XCTest.waitForExpectations</code>。</p></blockquote><p id="677b" class="pw-post-body-paragraph lj lk iq ll b lm mf jr lo lp mg ju lr ls mh lu lv lw mi ly lz ma mj mc md me ij bi translated"><code class="fe my mz na nb b">dueTime</code> : <strong class="ll ir"> </strong>指定发布元素前等待多长时间<strong class="ll ir"> </strong>。</p><p id="8768" class="pw-post-body-paragraph lj lk iq ll b lm mf jr lo lp mg ju lr ls mh lu lv lw mi ly lz ma mj mc md me ij bi translated">将该值设置为0.0以满足第二个假设:</p><blockquote class="ne nf ng"><p id="094f" class="lj lk nh ll b lm mf jr lo lp mg ju lr ni mh lu lv nj mi ly lz nk mj mc md me ij bi translated">客户端能够忽略去抖方法，并期望立即得到结果</p></blockquote><p id="e95a" class="pw-post-body-paragraph lj lk iq ll b lm mf jr lo lp mg ju lr ls mh lu lv lw mi ly lz ma mj mc md me ij bi translated">为了处理这些参数，让我们把它包装成一个方便的结构:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nc nd l"/></div></figure><p id="4d79" class="pw-post-body-paragraph lj lk iq ll b lm mf jr lo lp mg ju lr ls mh lu lv lw mi ly lz ma mj mc md me ij bi translated">添加一个扩展是一个好主意，它支持对上述每个调度程序的访问。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nc nd l"/></div></figure><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nc nd l"/></div></figure><p id="a786" class="pw-post-body-paragraph lj lk iq ll b lm mf jr lo lp mg ju lr ls mh lu lv lw mi ly lz ma mj mc md me ij bi translated">这是一个关于样品<code class="fe my mz na nb b">SearchStream</code>外观的示例。我想让你注意构造函数是如何设计的，以及测试它有多容易。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nc nd l"/></div></figure><h1 id="b38c" class="kr ks iq bd kt ku kv kw kx ky kz la lb jw lc jx ld jz le ka lf kc lg kd lh li bi translated">怎么考？</h1><p id="15cb" class="pw-post-body-paragraph lj lk iq ll b lm ln jr lo lp lq ju lr ls lt lu lv lw lx ly lz ma mb mc md me ij bi translated">最容易测试的类是没有外部依赖的类。很少，大多数类支持基本的逻辑操作，如字符串修改、数学方程、数据转换或类似的操作。</p><p id="7b78" class="pw-post-body-paragraph lj lk iq ll b lm mf jr lo lp mg ju lr ls mh lu lv lw mi ly lz ma mj mc md me ij bi translated">事实上，大多数类都有外部依赖性，比如网络、文件系统或其他内部逻辑。这也适用于<code class="fe my mz na nb b">SearchStream</code>类。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi no"><img src="../Images/2bfbcc635fc272ec839989e8746853e4.png" data-original-src="https://miro.medium.com/v2/resize:fit:642/format:webp/1*uEs0TyDugR8Mp7AXaB4jHQ.png"/></div><p class="np nq gj gh gi nr ns bd b be z dk translated">搜索流依赖关系图</p></figure><p id="b99e" class="pw-post-body-paragraph lj lk iq ll b lm mf jr lo lp mg ju lr ls mh lu lv lw mi ly lz ma mj mc md me ij bi translated">这是生产和测试目标的实现情况。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi nt"><img src="../Images/9c6801d35fa3c912af79f31281cf8df0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1022/format:webp/1*PK5JT5R6jL7lSfbJ2di_iQ.png"/></div></figure><p id="c4e4" class="pw-post-body-paragraph lj lk iq ll b lm mf jr lo lp mg ju lr ls mh lu lv lw mi ly lz ma mj mc md me ij bi translated">虽然<code class="fe my mz na nb b">SearchStream</code>是同一个类，但是依赖关系是不同的，这允许您控制<code class="fe my mz na nb b">SearchStream</code>应该如何表现并设置预期的结果。</p><p id="4e77" class="pw-post-body-paragraph lj lk iq ll b lm mf jr lo lp mg ju lr ls mh lu lv lw mi ly lz ma mj mc md me ij bi translated">测试代码可能如下所示:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nc nd l"/></div></figure><ul class=""><li id="62d3" class="mk ml iq ll b lm mf lp mg ls mm lw mn ma mo me mp mq mr ms bi translated">由于<code class="fe my mz na nb b">ImmediateScheduler</code>每个测试用例都是独立的，所以没有期望或<code class="fe my mz na nb b">waitForExpectations</code>代码，它们经常被添加来支持并发性。</li><li id="e295" class="mk ml iq ll b lm mt lp mu ls mv lw mw ma mx me mp mq mr ms bi translated">因为<code class="fe my mz na nb b">APISearchStream</code>已经注入了依赖关系，测试用例也能够验证搜索流是否执行了注入代码中的方法。</li></ul><h1 id="e5a4" class="kr ks iq bd kt ku kv kw kx ky kz la lb jw lc jx ld jz le ka lf kc lg kd lh li bi translated">结论</h1><p id="7b6d" class="pw-post-body-paragraph lj lk iq ll b lm ln jr lo lp lq ju lr ls lt lu lv lw lx ly lz ma mb mc md me ij bi translated">让我们从这篇文章中总结出最重要的内容:</p><ul class=""><li id="56be" class="mk ml iq ll b lm mf lp mg ls mm lw mn ma mo me mp mq mr ms bi translated">尽量避免使用<code class="fe my mz na nb b">waitForExpectations</code>方法，它会减慢你的测试速度。测试代码中等待的时间越长，等待所有测试用例的时间就越长，并且会给CI带来不必要的压力。</li><li id="1611" class="mk ml iq ll b lm mt lp mu ls mv lw mw ma mx me mp mq mr ms bi translated">总是试图将你的代码分割成独立的、弱依赖的部分，这使得你的代码更小、更简单、更易测试。</li></ul></div></div>    
</body>
</html>