# 将 SwiftUI 视图链接到 SpriteKit 场景的 7 种方法

> 原文：<https://betterprogramming.pub/7-ways-to-link-swiftui-views-to-spritekit-scene-58180a57ab58>

## 看看用 SwiftUI 接口链接一个类的不同方法

![](img/adf9080022373fe08563de2d61f6b370.png)

[Tamanna Rumee](https://unsplash.com/@tamanna_rumee?utm_source=medium&utm_medium=referral) 在 [Unsplash](https://unsplash.com?utm_source=medium&utm_medium=referral) 上拍摄的照片

我在玩 SpriteKit，突然想到这可能是一个很好的练习，提醒自己有多少种不同的方法可以将我的 SwiftUI 代码与我的 SpriteKit 场景/类链接起来。我不会以任何顺序、偏好或推荐来呈现这些；我按照它们或多或少出现在我脑海中的顺序展示它们。

# 案情摘要

我正在 SwiftUI 应用程序中运行 SpriteKit 场景，我希望能够使用 SwiftUI 元素(在本例中是一个按钮)直接控制 sprite。和我一起看看我能做出多少种烹饪方法——来做到这一点。

让我们从基本代码开始。现在我把两个结构/类放在同一个文件中，尽管你可能希望把它们放在不同的文件中定义。

最终目标是想出尽可能多的不同方法来做到这一点，蓝色文本`jump`是一个 SwiftUI 按钮。兔子是我的 SwiftUI 界面所承载的场景中的一个`SKSpriteNode`。

![](img/0170050cec7283a26718abc1baf1c51e.png)

显然，列出的代码不会完全实现您在这里看到的内容，因为我们需要实现链接。

# 1.使用单件

所以我的第一个想法是访问我的场景中的单例，然后在其中直接调用。我觉得是最短最快的实现。

我已经在`GameScene`类中将 shared 定义为单例。缺点当然是我的`GameScene`中的跳转方法需要每个人都可以访问，这可以说是糟糕的编码。

# 2.使用传递主题

这是我的第二个想法，老实说和第一个想法几乎一样，只是我通过 Combine 框架重定向了按钮。

我能想到的主要优势是组织优势。如果我使用这种技术访问我所有的外部方法，那么我也许可以用一些预定义的规则来构造我的代码。遗憾的是`jump()`当然仍然不是私有的。

# 3.可观察到的物体

这是一个经典的 Combine + SwiftUI 解决方案。它确实需要使用单例，而且可以说是迄今为止最干净的一种。

最干净，因为在`GameScene`和`ContentView`之间没有直接连接。在其中，我定义了一个共享变量作为中间人类，用于触发`jump()`方法的启动。

不利的一面是，我不认为这最终是非常可伸缩的，因为更新方法很快就会被启动变量淹没。

# 4.使用订阅

这也是一个经典的 Combine+SwiftUI 解决方案——虽然我在 Stack Overflow 之类的地方没怎么看到。

我之所以怀疑，是因为这有点神秘，说实话，有点像“goto”语句。

我在这里做的是在我的`ContentView.swift`中订阅`jointp`类中的 runner。一个订阅，它在看到任何操作时运行 jump 方法。`Jointp`这里又是一个中间人，有好有坏。

我觉得这有点过时的原因是，没有规定说你在哪里设置订阅。

它在这里工作得很好，因为我需要在`didMove`方法中这样做，但是理论上，我们可以在任何地方订阅，并创建一行从任何地方触发跳转方法——有点像 goto。

这种解决方案有一个隐藏的优势；理论上，你可以取消订阅，并有效地禁用按钮。阅读这篇[文章](https://medium.com/geekculture/cancelling-subscriptions-in-combine-illustrated-using-swiftui-60c786f8496c)来找出方法。

# 5.可变触发器

这个解决方案类似于第一个。在其中，我创建了一个变量，当它被访问时将执行我的`jump()`方法。尝试建立一些团队规则来在代码中构建这类东西可能是个好主意。它比直接版本好一点，因为你没有直接访问一个方法；你在访问一个变量。

# 6.全球主题

该解决方案与第二个解决方案**非常相似，除了** `PassthroughSubject`是全局可见的。显然，这不是最好的选择，因为全局变量会在访问过程中造成混乱。

`jump`也不是私有的。越想越觉得这其实是最差的方案:)。

# 7.安全订阅

正如我在开始时说的，这里没有真正的顺序，尽管通读 Sundell 的这篇文章，我发现我可以拆分出这个出版社。

这有一个很大的优势:不像以前的解决方案，我现在不能直接访问它。仅在`jointp`类中通过 fire 方法授予访问权限。

我仍在订阅，但我的代码比以前更安全了。说到防御性编码，您可以通过在 fire 方法本身中要求某种认证来进一步确保团队中的那些 Tom、Dick 和 Harrys 需要遵守规则。

当然，不利的一面是，即使没有认证，这也是迄今为止我展示的最多的代码。

所有这些都让我想到了这篇文章的结尾。

在开始的时候，我说过它没有任何顺序。但是事后看来，最后一种方法可能是最佳解决方案，尽管它也有最多的代码。当然，您必须想出一些规则来组织这些讨厌的订阅，但这可能是最具可伸缩性的，也可能是最安全的。

我希望你能像我研究和写这篇文章一样喜欢读这篇文章。

保持冷静；继续编码。