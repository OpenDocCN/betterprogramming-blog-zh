<html>
<head>
<title>My Favorite Coding Interview Task for Frontend Developers</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">我最喜欢的前端开发人员的编码面试任务</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/my-favorite-coding-interview-task-for-frontened-developers-f3e984fa49e2?source=collection_archive---------1-----------------------#2021-11-19">https://betterprogramming.pub/my-favorite-coding-interview-task-for-frontened-developers-f3e984fa49e2?source=collection_archive---------1-----------------------#2021-11-19</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="0c5f" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">显示窗口垂直滚动的实际值</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/8e1cc299846d24c7905d41b0f22c86d0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*UHG3_V_EYGcPz2h6v5PieQ.jpeg"/></div></div></figure><p id="e6ca" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">一年前，我的公司首先要求我做一个前端面试。然后我为了自己的话题性想出了这个任务。</p><p id="0347" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">任务很简单，检查基础知识。但是，事实证明，其中可能会出现许多有趣的错误。它还包含一些不明显的细节，有经验的开发人员可能也会感兴趣。</p><p id="811d" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">出于教学目的，我决定在本文中详细分析这个任务。这篇文章主要针对react的新开发者。</p><h1 id="2c3e" class="ln lo iq bd lp lq lr ls lt lu lv lw lx jw ly jx lz jz ma ka mb kc mc kd md me bi translated">问题陈述</h1><p id="a793" class="pw-post-body-paragraph kr ks iq kt b ku mf jr kw kx mg ju kz la mh lc ld le mi lg lh li mj lk ll lm ij bi translated">有一个组件实现需要两件事:</p><ol class=""><li id="7074" class="mk ml iq kt b ku kv kx ky la mm le mn li mo lm mp mq mr ms bi translated">显示窗口垂直滚动的实际值(<code class="fe mt mu mv mw b">window.scrollY</code>)</li><li id="8857" class="mk ml iq kt b ku mx kx my la mz le na li nb lm mp mq mr ms bi translated">挂载后，异步接收一个数字并显示它</li></ol><p id="a5dc" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">找到、解释并解决尽可能多的实施问题。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nc nd l"/></div></figure><p id="64e8" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">我强烈建议在继续阅读之前，先解决你发现的所有问题。</p></div><div class="ab cl ne nf hu ng" role="separator"><span class="nh bw bk ni nj nk"/><span class="nh bw bk ni nj nk"/><span class="nh bw bk ni nj"/></div><div class="ij ik il im in"><h1 id="77b9" class="ln lo iq bd lp lq nl ls lt lu nm lw lx jw nn jx lz jz no ka mb kc np kd md me bi translated">重要的事情先来</h1><p id="e341" class="pw-post-body-paragraph kr ks iq kt b ku mf jr kw kx mg ju kz la mh lc ld le mi lg lh li mj lk ll lm ij bi translated">大家正确注意的第一点是<code class="fe mt mu mv mw b">useEffect</code>没有第二个参数。</p><p id="4ed5" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">应该有一个空的依赖数组，因为我们只需要在挂载时从“服务器”获取一次<em class="nq">号</em>。并且重复重新订阅滚动事件是没有意义的。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nc nd l"/></div></figure><p id="ffaa" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">一个常见的错误是像这样传递依赖关系数组:<code class="fe mt mu mv mw b">[scroll]</code>。如果你也犯了这样的错误，那么回到代码中，确保你不需要当前的滚动值来更新它。</p></div><div class="ab cl ne nf hu ng" role="separator"><span class="nh bw bk ni nj nk"/><span class="nh bw bk ni nj nk"/><span class="nh bw bk ni nj"/></div><div class="ij ik il im in"><p id="d07e" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">第二个通常被注意到的是回调中的<code class="fe mt mu mv mw b">async</code>关键字。通常，候选人都有过用这种方式写作的亲身经历。所以，他们知道不能这样做。但是为什么呢？这个问题难倒了某人。</p><p id="2bd4" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">根据react文档，回调应该不返回任何东西(<code class="fe mt mu mv mw b">undefined</code>)或者返回一个清理函数。即只返回2个有效值:<code class="fe mt mu mv mw b">undefined</code> <em class="nq"> </em>和<code class="fe mt mu mv mw b">function</code>。但是，你当然知道<code class="fe mt mu mv mw b">async</code> <em class="nq"> </em>函数总是返回一个<code class="fe mt mu mv mw b">promise</code> <em class="nq">。</em>即在当前的实现中，回调并不返回一个清理函数，而是返回那个函数的<em class="nq">承诺</em>。</p><p id="42be" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">我们需要删除<code class="fe mt mu mv mw b">async</code> <em class="nq"> </em>关键字并重做回调工作。一些初学者遇到了问题。最简单的就是用<code class="fe mt mu mv mw b">promise</code>写:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nc nd l"/></div></figure><p id="782f" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">如果你写过<code class="fe mt mu mv mw b">fetchRandomNumber().then(num =&gt; setNumber(num))</code>，花一分钟去体会<code class="fe mt mu mv mw b">fetchRandomNumber().then(setNumber)</code> <em class="nq"> </em>做的是同样的事情，但是更短更优。</p></div><div class="ab cl ne nf hu ng" role="separator"><span class="nh bw bk ni nj nk"/><span class="nh bw bk ni nj nk"/><span class="nh bw bk ni nj"/></div><div class="ij ik il im in"><p id="01cb" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">最后一个错误是滚动监听器无论如何都没有被清除。我将尝试给出我自己的类比来解释这个错误。假设你买了一部新手机。你在它上面设置了一个闹钟，让它在早上5点起床去海边跑步。然后你改变了主意。</p><p id="9d31" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">但是你没有关闭新手机的闹钟，而是回到商店，买了另一部相同型号的手机，打开手机中的闹钟设置，在早上5点关闭一切(然而，那里没有什么可以关闭的)。</p><p id="cdae" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">两款手机完全相同，几乎没有明显的区别，但它们仍然是不同的手机。在实现的代码中也写了同样的废话。每当我们编写表达式<code class="fe mt mu mv mw b">() =&gt; setScroll(window.scrollY)</code>，我们就创建了一个新的函数。这个问题通常以一种奇怪的方式解决:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nc nd l"/></div></figure><p id="e4d6" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">这是可行的，但问题是<code class="fe mt mu mv mw b">handleScroll</code> <em class="nq"> </em>将被<em class="nq"> </em>为组件的每个渲染创建，但将仅在<code class="fe mt mu mv mw b">useEffect</code>回调中使用。因此，它将只在第一次渲染时使用。所以，做了额外的工作，代码更加分散。</p><p id="b4db" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">更正确的方式可能是这样的:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nc nd l"/></div></figure><h1 id="a484" class="ln lo iq bd lp lq lr ls lt lu lv lw lx jw ly jx lz jz ma ka mb kc mc kd md me bi translated">不太重要的问题</h1><p id="c7d5" class="pw-post-body-paragraph kr ks iq kt b ku mf jr kw kx mg ju kz la mh lc ld le mi lg lh li mj lk ll lm ij bi translated">我要求候选人注意的另一点是状态的初始值。大三学生经常这样写:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nc nd l"/></div></figure><p id="0741" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">有人认为初始值是强制性的。如果这是一个数字，那么<code class="fe mt mu mv mw b">0</code> <strong class="kt ir"> <em class="nq"> </em> </strong>肯定是最好的选择。但是在这种情况下，我们不能给数字<code class="fe mt mu mv mw b">var</code> <em class="nq"> </em>一个合适的初始值，最好不要定义它。</p><p id="5c68" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">对于scroll变量，<code class="fe mt mu mv mw b">0</code>的初始值是不正确的，因为我们的组件可以在浏览器页面已经向下滚动的时候出现。预期的代码是:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nc nd l"/></div></figure><p id="c5f5" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">这是相当不错的代码。在这一点上，我通常会转移到面试中的下一个任务。但是如果候选人做得很好，我建议他们多考虑一下代码片段。</p></div><div class="ab cl ne nf hu ng" role="separator"><span class="nh bw bk ni nj nk"/><span class="nh bw bk ni nj nk"/><span class="nh bw bk ni nj"/></div><div class="ij ik il im in"><p id="678a" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">如果候选人知道什么是节流并正确运用，这将是一个加分项。比如像这样:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nc nd l"/></div></figure><p id="2084" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">这里的一个好问题是为什么37毫秒。变量的值可能更有意义。比如我们可以设置<code class="fe mt mu mv mw b">throttleWait = 1000/60</code> <strong class="kt ir"> <em class="nq"> </em> </strong>因为我们想要60 <a class="ae nr" href="https://en.wikipedia.org/wiki/Frame_rate" rel="noopener ugc nofollow" target="_blank"> FPS </a>。但就FPS而言，真正先进的解决方案是使用<em class="nq"> requestAnimationFrame </em>而不是<em class="nq"> throttle。</em></p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nc nd l"/></div></figure></div><div class="ab cl ne nf hu ng" role="separator"><span class="nh bw bk ni nj nk"/><span class="nh bw bk ni nj nk"/><span class="nh bw bk ni nj"/></div><div class="ij ik il im in"><p id="9d89" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">另外我想看到的是<a class="ae nr" href="https://en.wikipedia.org/wiki/Single-responsibility_principle" rel="noopener ugc nofollow" target="_blank">单一责任原则</a>在<em class="nq">使用效果</em>中的应用。现在同样的<em class="nq"> useEffect </em>负责异步号码检索逻辑和滚动逻辑。结果可能如下所示:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nc nd l"/></div></figure><p id="778e" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">这段代码运行起来会稍微慢一些，但是随着时间的推移，它会更容易阅读和修改。此外，在这一步之后，更容易看到出于相同目的而提取的自定义挂钩:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nc nd l"/></div></figure></div><div class="ab cl ne nf hu ng" role="separator"><span class="nh bw bk ni nj nk"/><span class="nh bw bk ni nj nk"/><span class="nh bw bk ni nj"/></div><div class="ij ik il im in"><p id="3c9f" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">你在你的主机里见过这样的警告吗？</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi ns"><img src="../Images/f24471f969f9358815ebb095433e1fae.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*11JX9SVS96aPwbrWPueMwQ.png"/></div></div></figure><p id="10bd" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">在大多数情况下，这种警告是完全无害的，但令人讨厌。要移除它，你应该确保你的组件在调用<code class="fe mt mu mv mw b">setState</code>之前没有被卸载。示例:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nc nd l"/></div></figure><h2 id="e96a" class="nt lo iq bd lp nu nv dn lt nw nx dp lx la ny nz lz le oa ob mb li oc od md oe bi translated">SSR问题</h2><p id="69c2" class="pw-post-body-paragraph kr ks iq kt b ku mf jr kw kx mg ju kz la mh lc ld le mi lg lh li mj lk ll lm ij bi translated">在这段代码中，我们使用的是<code class="fe mt mu mv mw b">window</code> <em class="nq"> </em>对象。但是node . js<em class="nq"/>environment没有<code class="fe mt mu mv mw b">window</code> <em class="nq"> </em>对象。我们的代码要用SSR的话应该是<a class="ae nr" href="https://www.lullabot.com/articles/what-is-an-isomorphic-application" rel="noopener ugc nofollow" target="_blank"> <em class="nq">同构</em> </a>。</p><h1 id="255b" class="ln lo iq bd lp lq lr ls lt lu lv lw lx jw ly jx lz jz ma ka mb kc mc kd md me bi translated">不明显的</h1><p id="c6b0" class="pw-post-body-paragraph kr ks iq kt b ku mf jr kw kx mg ju kz la mh lc ld le mi lg lh li mj lk ll lm ij bi translated">JS里有个日常工作中很少用到的东西——<a class="ae nr" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/defineProperty" rel="noopener ugc nofollow" target="_blank">描述符</a>。你可以这样做，当你从一个对象获得一个属性时，一个getter函数将被调用，这个调用的结果将被返回。</p><p id="1b1c" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated"><code class="fe mt mu mv mw b">Object.getOwnPropertyDescriptor</code>函数可以告诉你一个对象属性是规则的还是用描述符定义的复杂的。所以如果你在控制台中运行<code class="fe mt mu mv mw b">Object.getOwnPropertyDescriptor (window, ‘scrollY’);</code> <strong class="kt ir"> <em class="nq"> </em> </strong>，你会发现scrollY属性有一个setter和一个getter</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi of"><img src="../Images/7342b98048a7d7b5c0c30603032d8f34.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*vfOx_vhLXgD5cLWaN1JfWA.png"/></div></div></figure><p id="3c4f" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">所以，当我们写<code class="fe mt mu mv mw b">window.scrollY</code>时，我们将这个getter函数添加到<a class="ae nr" href="http://latentflip.com/loupe/" rel="noopener ugc nofollow" target="_blank">调用栈</a>。因此，如果我们写<code class="fe mt mu mv mw b">useState(() =&gt; window.scrollY)</code> <em class="nq"> </em>而不是<code class="fe mt mu mv mw b">useState(window.scrollY)</code>，那么对于每次渲染，调用堆栈上将会少一个函数(如果你将一个函数传递给<code class="fe mt mu mv mw b">useState</code>，它将只在第一次渲染时被调用，初始值将是这次调用的结果)。</p><p id="96fc" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">优化！事实上，这样的优化并没有提供任何实际的好处。但在我看来，重要的是对这些过程的意识，有意识地编写每一行代码。将功能传入<code class="fe mt mu mv mw b">useState</code>的另一个原因是，每一个<code class="fe mt mu mv mw b"><a class="ae nr" href="https://gist.github.com/paulirish/5d52fb081b3570c81e3a/565c05680b27c9cfd9f5e971d295cd558c3e1843" rel="noopener ugc nofollow" target="_blank">window.scrollY</a></code> <a class="ae nr" href="https://gist.github.com/paulirish/5d52fb081b3570c81e3a/565c05680b27c9cfd9f5e971d295cd558c3e1843" rel="noopener ugc nofollow" target="_blank"> <strong class="kt ir"> <em class="nq"> </em> </strong>都会触发回流</a>。最终的代码看起来会像这样:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nc nd l"/></div></figure><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="og nd l"/></div></figure></div><div class="ab cl ne nf hu ng" role="separator"><span class="nh bw bk ni nj nk"/><span class="nh bw bk ni nj nk"/><span class="nh bw bk ni nj"/></div><div class="ij ik il im in"><h1 id="9678" class="ln lo iq bd lp lq nl ls lt lu nm lw lx jw nn jx lz jz no ka mb kc np kd md me bi translated">奖励练习</h1><p id="4379" class="pw-post-body-paragraph kr ks iq kt b ku mf jr kw kx mg ju kz la mh lc ld le mi lg lh li mj lk ll lm ij bi translated">对于那些喜欢再次开动脑筋的人，我建议找出如何对上一节中的“优化”进行基准测试。我以前从未写过这样的综合测试，但对于一篇综合文章，我给自己设定了这个目标，结果如下:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="og nd l"/></div></figure><p id="3a50" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">我的笔记本电脑在大约3500毫秒内完成20，000个组件渲染(对于<code class="fe mt mu mv mw b">useState (window.scrollY))</code>和大约3300毫秒<code class="fe mt mu mv mw b">(for useState (() =&gt; window.scrollY)</code>)</p></div><div class="ab cl ne nf hu ng" role="separator"><span class="nh bw bk ni nj nk"/><span class="nh bw bk ni nj nk"/><span class="nh bw bk ni nj"/></div><div class="ij ik il im in"><p id="9262" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">我发现我们可以深入这样一个简单的任务是很有趣的。感谢阅读。</p></div></div>    
</body>
</html>