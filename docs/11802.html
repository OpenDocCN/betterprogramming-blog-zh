<html>
<head>
<title>Convert MySQL Files to Postgres Format on the Fly</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">动态转换MySQL文件为Postgres格式</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/convert-mysql-files-to-postgres-format-on-the-fly-1a9bde5a186b?source=collection_archive---------12-----------------------#2022-04-18">https://betterprogramming.pub/convert-mysql-files-to-postgres-format-on-the-fly-1a9bde5a186b?source=collection_archive---------12-----------------------#2022-04-18</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="2a06" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">编写一个自定义脚本，允许将MySQL文件加载到Postgres中</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/fee80d89e923bf869f7bae948624b08b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*lV7No1Y0hQD-ADbT"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">扬·安东宁·科拉尔在<a class="ae kv" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</p></figure><p id="3ea9" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">有时候，生活会给你一个SQL文件来加载到你的数据库中，但它的格式不正确。这发生在我身上。</p><p id="0135" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我为MySQL生成了一个文件，需要将它加载到我的Postgres数据库中。标准解决方案需要联系供应商，要求他们提供正确的文件，或者使用转换器软件。不幸的是，这两种方法都不合适。</p><p id="dc39" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">因此，我将演示第三种方法——一个自定义脚本，它允许您将MySQL文件加载到Postgres中，同时动态转换它，而无需创建任何额外的文件和在驱动器上分配额外的空间。</p><p id="714e" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">该文件由两部分组成。首先是表创建部分，这基本上是一个大型语句，它在数据库中创建一个空表来装载数据。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ls lt l"/></div></figure><p id="ca0b" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">第二部分，向表中插入行:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ls lt l"/></div></figure><p id="c672" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">最难重写的部分是第一个，因为在声明表时，MySQL和Postgres有很多不同，而INSERT语句非常相似。</p><h1 id="5525" class="lu lv iq bd lw lx ly lz ma mb mc md me jw mf jx mg jz mh ka mi kc mj kd mk ml bi translated">表格部分的修改</h1><p id="697b" class="pw-post-body-paragraph kw kx iq ky b kz mm jr lb lc mn ju le lf mo lh li lj mp ll lm ln mq lp lq lr ij bi translated">计划是编写一个Python脚本，逐行读取SQL文件，并将MySQL语法更改为Postgres。然后一旦检测到一个<code class="fe mr ms mt mu b">;</code>符号，就向服务器提交查询。</p><p id="780f" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我将使用一个标准的<code class="fe mr ms mt mu b">psycorg</code>库来提交查询。首先，让我们编写一个处理查询的函数。我们可以调用它将数据写入数据库。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ls lt l"/></div></figure><p id="7105" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">现在，计划如下:</p><ul class=""><li id="88f0" class="mv mw iq ky b kz la lc ld lf mx lj my ln mz lr na nb nc nd bi translated">将该行从原始文件读入变量<code class="fe mr ms mt mu b">sql_line</code>。</li><li id="052c" class="mv mw iq ky b kz ne lc nf lf ng lj nh ln ni lr na nb nc nd bi translated">检查是否包含方言矛盾。如果是这样，请修复它们。</li><li id="e749" class="mv mw iq ky b kz ne lc nf lf ng lj nh ln ni lr na nb nc nd bi translated">将该行添加到包含整个语句的变量中。</li><li id="37c2" class="mv mw iq ky b kz ne lc nf lf ng lj nh ln ni lr na nb nc nd bi translated">如果该行包含<code class="fe mr ms mt mu b">;</code>符号，则向数据库提交该语句。</li></ul><p id="8316" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">首先，MySQL在表和列名中使用反勾符号，而Postgres使用双引号。这个很容易操作，如下图所示:</p><pre class="kg kh ki kj gt nj mu nk nl aw nm bi"><span id="5b17" class="nn lv iq mu b gy no np l nq nr">sql_line = sql_lone.replace('`', '"')</span></pre><p id="b8ad" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">另一个容易处理的方面是时间戳格式:</p><pre class="kg kh ki kj gt nj mu nk nl aw nm bi"><span id="2138" class="nn lv iq mu b gy no np l nq nr">sql_lime = sql_line.replace("datetime", "timestamp(0)")</span></pre><p id="6901" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">现在，Postgres在为列指定<code class="fe mr ms mt mu b">INT</code>类型时，括号中不需要任何数字，所以需要删除。</p><p id="eeaa" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">要实现自动递增的列，我们需要用<code class="fe mr ms mt mu b">SERIAL</code>替换<code class="fe mr ms mt mu b">AUTO_INCREMENT</code>关键字。该行还可能包含列名和自动递增关键字之间的内容，所以我们将忽略这一点，并在列名之后写入serial关键字。</p><p id="9a3e" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我也把评论全删了。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ls lt l"/></div></figure><p id="e92a" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">现在，MySQL有了关键字<code class="fe mr ms mt mu b">collate</code>，我们也不需要了，可以把它和它后面的字删掉。</p><p id="7977" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">有些列具有<code class="fe mr ms mt mu b">unsigned</code>属性。Postgres中没有这样的属性，但是我们可以简单地检查列中的所有值是否都大于0。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ls lt l"/></div></figure><p id="1eb7" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">声明枚举最棘手的部分是MySQL枚举类型需要在table语句之前声明一个自定义类型。</p><pre class="kg kh ki kj gt nj mu nk nl aw nm bi"><span id="f9f1" class="nn lv iq mu b gy no np l nq nr">CREATE TYPE enum_1 as ENUM ('value 1', 'value 2');</span></pre><p id="6691" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">然后在table语句中，创建该类型的列:</p><pre class="kg kh ki kj gt nj mu nk nl aw nm bi"><span id="1b97" class="nn lv iq mu b gy no np l nq nr">”ENUM_column” enum_1 NOT NULL</span></pre><p id="27f0" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">所以，如果我们遇到这个关键字，我们需要解析行中可能的条目，在整个table语句的开头声明类型，然后，创建一个新声明类型的列。结果是下面的代码:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ls lt l"/></div></figure><p id="69b3" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">专栏部分到此为止。现在，我们需要处理表约束。</p><p id="fd6f" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">该文件包含三个基本约束:</p><ul class=""><li id="998e" class="mv mw iq ky b kz la lc ld lf mx lj my ln mz lr na nb nc nd bi translated"><code class="fe mr ms mt mu b">primary key</code>。在Postgres中，主键是通过向列添加相应的关键字来声明的，因此我们需要解析主键语句，找出主键的名称，并更改创建该列的行。</li><li id="3ebc" class="mv mw iq ky b kz ne lc nf lf ng lj nh ln ni lr na nb nc nd bi translated"><code class="fe mr ms mt mu b">Unique key</code>。这里使用了相同的方法。我们需要解析原始行中的唯一键约束，并将<code class="fe mr ms mt mu b">unique</code>关键字添加到相应的列中。</li><li id="2260" class="mv mw iq ky b kz ne lc nf lf ng lj nh ln ni lr na nb nc nd bi translated"><code class="fe mr ms mt mu b">Foreign key</code>。创建外键的语法有很大的不同。在我的键中，外键语句中提到的两个表都不存在于我的数据库中，所以我忽略了它们。但在下面的例子中，有一段代码将代码改写成Postgres格式，只是为了通用性。</li></ul><p id="9eb2" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">因此，结合所有三种方法，我们得到以下结果:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ls lt l"/></div></figure><p id="54d3" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在所有这些转换之后，我们有了创建预期表的Postgres工作代码。剩下要做的就是向服务器提交查询，我们可以使用下面的代码来完成:</p><p id="57b8" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><code class="fe mr ms mt mu b">execute_sql(table_statement)</code></p><p id="729f" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">之后，我们只需要遍历所有剩余的行，并将数据插入新生成的表中。</p><h1 id="1c08" class="lu lv iq bd lw lx ly lz ma mb mc md me jw mf jx mg jz mh ka mi kc mj kd mk ml bi translated">调整INSERT语句</h1><p id="5aeb" class="pw-post-body-paragraph kw kx iq ky b kz mm jr lb lc mn ju le lf mo lh li lj mp ll lm ln mq lp lq lr ij bi translated">上面已经提到过，<code class="fe mr ms mt mu b">INSERT</code>语法在MySQL和Postgres中非常相似，除了一点不同。</p><p id="5746" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">不同之处在于对转义字符的处理。在MySQL中，如果一个人需要在字符串中包含一个撇号，他所要做的就是在它前面加一个反斜杠。在Postgres中，除此之外，还需要一个大写字母<code class="fe mr ms mt mu b">E</code>来表示该行可能包含转义字符。</p><pre class="kg kh ki kj gt nj mu nk nl aw nm bi"><span id="ab31" class="nn lv iq mu b gy no np l nq nr">'McDonald\'s' -&gt; E'McDonald\'s'</span></pre><p id="29e3" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">因此，让我们编写一个函数来检测字符串中的反斜杠，并在撇号打开该字符串之前添加一个大写字母<code class="fe mr ms mt mu b">E</code>。这里引人注意的是，这一行可能有多个撇号，因此，在放置字母<code class="fe mr ms mt mu b">E</code>之前，我们需要检查这个撇号是否实际上是字符串的开头。</p><p id="48c9" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">和以前一样，我们需要用引号替换任何反勾号。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ls lt l"/></div></figure><p id="c8ed" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">原来如此。现在我们可以安全地执行该行了，它将像这样出现在您的表中:</p><pre class="kg kh ki kj gt nj mu nk nl aw nm bi"><span id="4581" class="nn lv iq mu b gy no np l nq nr">execute_sql(sql_line)</span></pre><p id="67a5" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这个差异列表并不详尽；我只介绍了我自己在加载文件时遇到的问题，如果您使用该脚本，您可能会遇到其他问题。</p><p id="4645" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">感谢阅读。</p><p id="1c52" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">完整的代码可以在<a class="ae kv" href="https://github.com/Megachell/mysql-to-postgres" rel="noopener ugc nofollow" target="_blank"> GitHub库</a>中找到。</p></div></div>    
</body>
</html>