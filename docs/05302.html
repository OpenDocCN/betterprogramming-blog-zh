<html>
<head>
<title>Practicing Recursion With 7 Algorithm Challenges</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">用7个算法挑战练习递归</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/practicing-recursion-with-7-algorithm-challenges-7ffdd634557?source=collection_archive---------1-----------------------#2020-06-27">https://betterprogramming.pub/practicing-recursion-with-7-algorithm-challenges-7ffdd634557?source=collection_archive---------1-----------------------#2020-06-27</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="a7e9" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">用这些有用的练习题搞定你的下一次面试</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/4bf25e3c875b65b3a8f31bed53c4a197.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*qmeSaOhOpgH0tkwg7W5QeQ.jpeg"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">图片来自<a class="ae ky" href="https://indepth.dev/dijkstra-was-right-recursion-should-not-be-difficult/" rel="noopener ugc nofollow" target="_blank">深度开发</a>。</p></figure><p id="f942" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">还记得你第一次不用查答案就自己解决了一个算法难题，却被告知要用递归函数再解决一次吗？</p><p id="ada3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">由于这似乎是一个常见的场景，尤其是在技术面试环境中，我整理了一个经典算法挑战的列表，以帮助弯曲我们的递归大脑肌肉，因为这似乎是一个常见的场景，尤其是在技术面试环境中…</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="a91a" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">1.反转字符串</h1><pre class="kj kk kl km gt mu mv mw mx aw my bi"><span id="1159" class="mz md it mv b gy na nb l nc nd">/* Instruction:<br/>Given a string, write a recursive function to return the reversed string. */</span><span id="c3d1" class="mz md it mv b gy ne nb l nc nd">// Example:<br/>reverseString('covid')<br/>// =&gt; 'divoc'</span></pre><p id="7a66" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这似乎是每个代码新手遇到的第一个挑战。如果你还没有用递归解决这个问题，我鼓励你在进一步阅读之前尝试一下。</p><p id="a41f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这是我的解决方案，可以通过三元运算符进行重构:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nf ng l"/></div></figure></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="6e17" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">2.将数字相加</h1><pre class="kj kk kl km gt mu mv mw mx aw my bi"><span id="93b9" class="mz md it mv b gy na nb l nc nd">/* Instruction:<br/>Given an array and an index, write a recursive function to add up the elements of an array. */</span><span id="1e08" class="mz md it mv b gy ne nb l nc nd">// Examples:<br/>addingUpTo([1, 4, 5, 3], 2)<br/>// =&gt; 10<br/>// =&gt; adding the number all the way up to index 2 (1 + 4 + 5)<br/>addingUpTo([4, 3, 1, 5], 1)<br/>// =&gt; 7<br/>// =&gt; adding the number all the way up to index 1 (4 + 3)</span></pre><p id="f49f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">因为我们要返回多个数字的和，所以我马上想到声明一个变量<code class="fe nh ni nj mv b">sum</code>。</p><p id="3c6b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">此外，由于我们给定了一个索引，我决定将<code class="fe nh ni nj mv b">sum</code>作为该索引处的元素，并将数字向后添加。</p><p id="d9ef" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">基本情况是当我们到达操作的末尾时，在这种情况下是索引<code class="fe nh ni nj mv b">0</code>，因为我们向后添加:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nf ng l"/></div></figure></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="f446" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">3.寻找最大整数</h1><pre class="kj kk kl km gt mu mv mw mx aw my bi"><span id="ae46" class="mz md it mv b gy na nb l nc nd">/* Instruction:<br/>Given an array, write a recursive function to find the largest integer in an array. */</span><span id="0e5c" class="mz md it mv b gy ne nb l nc nd">// Examples:<br/>maxOf([1, 4, 5, 3])<br/>// =&gt; 5<br/>maxOf([3, 1, 6, 8, 2, 4, 5])<br/>// =&gt; 8</span></pre><p id="6020" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这是一个比较问题。所以自然地，基本情况是我们不能进行比较的时候(也就是说，当数组中只剩下一个元素的时候)。</p><p id="445f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在，我们如何继续比较和减少数组中的元素，以达到基本情况？</p><p id="1228" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">JavaScript中的<code class="fe nh ni nj mv b">splice</code>方法拯救了我。</p><p id="88fe" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">感谢<code class="fe nh ni nj mv b">splice</code>方法的可变性，我可以比较数组中的前两个元素，删除较小的一个，并用更新后的数组递归调用函数:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nf ng l"/></div></figure></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="5695" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">4.寻找特定元素</h1><pre class="kj kk kl km gt mu mv mw mx aw my bi"><span id="bcff" class="mz md it mv b gy na nb l nc nd">/* Instruction:<br/>Given an array and a number, write a recursive function to see if the array includes the given element. */</span><span id="f55c" class="mz md it mv b gy ne nb l nc nd">// Examples:<br/>includesNumber([1, 4, 5, 3], 5)<br/>// =&gt; true<br/>includesNumber([3, 1, 6, 8, 2, 4, 5], 9)<br/>// =&gt; false</span></pre><p id="b46a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">类似于<code class="fe nh ni nj mv b">maxOf()</code>函数，我们需要将数组中的元素与给定的数字进行比较。</p><p id="7a1b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">一旦找到匹配，我们可以立即返回<code class="fe nh ni nj mv b">true</code>。如果没有，我们可以递归调用函数，并传入减去刚才比较的元素的数组，直到到达基本情况。</p><p id="5e53" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我在这里建立的基本情况是当数组中没有元素时，在这种情况下，我们返回<code class="fe nh ni nj mv b">false</code>，因为数组中没有元素匹配给定的数字:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nf ng l"/></div></figure><p id="66cf" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">事后看来，我应该使用<code class="fe nh ni nj mv b">splice</code>而不是<code class="fe nh ni nj mv b">slice</code>方法来移除当前元素。使用<code class="fe nh ni nj mv b">slice</code>将在每次递归函数调用中触发数组的一个新副本，如果给定一个大数据集，这可能会降低操作速度。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="8412" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">5.回文</h1><pre class="kj kk kl km gt mu mv mw mx aw my bi"><span id="dd5d" class="mz md it mv b gy na nb l nc nd">/* Instruction:<br/>Given a string, write a recursive function to see if a word is a palindrome. */</span><span id="d317" class="mz md it mv b gy ne nb l nc nd">// Examples:<br/>isPalindrome('madam')<br/>// =&gt; true<br/>isPalindrome('covid')<br/>// =&gt; false</span></pre><p id="bd0c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">回文是一个单词或短语，如果你颠倒每个对立字符的顺序，它的意思是一样的。</p><p id="0ddd" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我以镜像的方式处理这个问题:比较每个递归函数中字符串的第一个和最后一个字符，直到我们到达中间点，这成为我们的基本情况。</p><p id="0426" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在递归的情况下，如果当前字符不等于相反的字符，我们应该立即返回<code class="fe nh ni nj mv b">false</code>，因为这不满足回文的组成:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nf ng l"/></div></figure></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="ae3b" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">6.排列</h1><pre class="kj kk kl km gt mu mv mw mx aw my bi"><span id="d339" class="mz md it mv b gy na nb l nc nd">/* Instruction:<br/>Given a string, write a recursive function to print out an array of all possible permutations of the string. */</span><span id="155e" class="mz md it mv b gy ne nb l nc nd">// Examples:<br/>permutations('abc')<br/>// =&gt; ['abc', 'acb', 'bac', 'bca', 'cab', 'cba']<br/>permutations('aabc')<br/>// =&gt; ["aabc", "aacb", "abac", "abca", "acab", "acba", "baac", "baca", "bcaa", "caab", "caba", "cbaa"]</span></pre><p id="a1bf" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">排列是一组项目的重新排列。现在，我们至少需要两个元素来完成排列。如果字符串只有一个或更少的字符，没有什么需要重新排列的，所以这是我们的基本情况。</p><p id="c4f9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">递归的情况对我来说是一个棘手的问题。与之前的挑战不同，这次我们需要几层操作才能达到预期效果:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nf ng l"/></div></figure><p id="1a48" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如代码片段中所述，在递归情况下，我们不仅需要考虑给定字符串中有重复字符的情况，还必须将当前字符与递归函数结果的每个排列连接起来。</p><p id="52a3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果你仍然感到困惑，我强烈推荐<a class="ae ky" href="https://levelup.gitconnected.com/find-all-permutations-of-a-string-in-javascript-af41bfe072d2" rel="noopener ugc nofollow" target="_blank">这个详细的演练</a>，它帮助我理解了这个挑战的递归解决方案。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="5882" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">7.斐波纳契</h1><pre class="kj kk kl km gt mu mv mw mx aw my bi"><span id="6f1e" class="mz md it mv b gy na nb l nc nd">/* Instruction:<br/>Given a number, write a recursive function to <br/>print out the n-th entry in the fibonacci series. </span><span id="688c" class="mz md it mv b gy ne nb l nc nd">Fibonacci series is a sequence, <br/>where each number is the sum of the preceding two: <br/>[0, 1, 1, 2, 3, 5, 8, 13, 21, 34] */</span><span id="3f04" class="mz md it mv b gy ne nb l nc nd">// Example:<br/>fib(3)<br/>// =&gt; 2<br/>fib(6)<br/>// =&gt; 8</span></pre><p id="4719" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">听说不查就想出递归解的情况并不常见，所以下面是“教科书”版。根据一些有经验的开发人员的说法，这是一个值得记住的公式:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nf ng l"/></div></figure><p id="4b3d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这种递归方法的运行时复杂性是指数级的(<code class="fe nh ni nj mv b">O(2^n)</code>)，因此它不如普通的旧迭代方法(<code class="fe nh ni nj mv b">O(n)</code>)高效。</p><p id="b452" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">您可以利用<code class="fe nh ni nj mv b">memoization</code>技术来优化递归，但是这超出了本文的范围。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="c216" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">最后的想法</h1><p id="310c" class="pw-post-body-paragraph kz la it lb b lc nk ju le lf nl jx lh li nm lk ll lm nn lo lp lq no ls lt lu im bi translated">我们都有使用递归解决问题的不同方法。我花了相当多的时间来发展自己的策略。</p><p id="f00d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">到目前为止，我倾向于从找出基本案例开始，正如多种资源所建议的那样。然后我将冒险进入递归情况，这通常涉及创建子任务和组合子任务的结果。</p><p id="603a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">你呢？你是如何训练大脑递归思考的？请在评论中告诉我！</p></div></div>    
</body>
</html>