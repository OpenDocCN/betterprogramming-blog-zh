<html>
<head>
<title>Retain Cycles and Memory Management in Swift</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Swift中的保留周期和内存管理</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/retain-cycles-and-memory-management-in-swift-fb6226165b17?source=collection_archive---------2-----------------------#2021-11-10">https://betterprogramming.pub/retain-cycles-and-memory-management-in-swift-fb6226165b17?source=collection_archive---------2-----------------------#2021-11-10</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="f561" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">构建高性能的iOS应用</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/0e981a4bf17557f24f918f5baafbe39a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*aalD7rY8wzab8eoE"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">照片由<a class="ae kv" href="https://unsplash.com/@sharkovski?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Kirill Sharkovski </a>在<a class="ae kv" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</p></figure><p id="2651" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在这篇文章中，我想解释一下保留周期和内存管理的概念是什么，以及如何通过简单地了解这些概念来改进您的iOS应用程序。</p><p id="48fe" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在Swift或任何其他OOP语言中，每个实例要么是值类型，要么是引用类型。</p><p id="aef7" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">值类型实例意味着无论何时你想从该实例创建一个变量并将该变量赋给另一个变量，它都遵循一个称为“按值传递”的概念，这意味着它将该变量的值复制给另一个变量。</p><p id="f94a" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">其中一个实例的更改不会影响另一个实例，因为原始值被复制到了另一个实例，而复制的值仍然是相同的。</p><p id="a9d3" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">另一方面，引用类型实例遵循按引用传递的概念，这意味着值不会被复制，但两个变量将指向同一个内存空间。如果一个改变，另一个也会改变，因为内存空间中的值会改变。</p><p id="8895" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">让我举一个简单的例子来说明这一点。下面是一个值类型示例:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ls lt l"/></div></figure><p id="e8e2" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">由于struct是值类型，当我们使用struct创建一个变量并将其赋给另一个变量时，Swift只将第一个变量的值复制到第二个变量。如果我们想改变第一个变量中的一个属性，并像上面一样打印它们，我们可以看到第一个打印语句打印出<code class="fe lu lv lw lx b">Audi</code>，第二个打印语句仍然打印出<code class="fe lu lv lw lx b">Mercedes</code>。</p><p id="4d06" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这里是一个为了可视化引用类型的<code class="fe lu lv lw lx b">Class</code>例子:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ls lt l"/></div></figure><p id="5b3c" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">首先，我们从<code class="fe lu lv lw lx b">Car</code>类中创建一个变量，并将它赋给另一个变量。因为类是引用类型，所以两个变量(<code class="fe lu lv lw lx b">car1</code>和<code class="fe lu lv lw lx b">car2</code>)指向同一个内存地址。当我们将<code class="fe lu lv lw lx b">car1</code>变量的品牌属性更改为<code class="fe lu lv lw lx b">Audi</code>并打印两个变量的品牌属性时，两个<strong class="ky ir"> </strong>打印语句都会打印出<code class="fe lu lv lw lx b">Audi</code>。</p></div><div class="ab cl ly lz hu ma" role="separator"><span class="mb bw bk mc md me"/><span class="mb bw bk mc md me"/><span class="mb bw bk mc md"/></div><div class="ij ik il im in"><p id="603e" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">一旦我们弄清楚了值和引用类型这两个理解内存管理的基本概念，我们就可以开始真正的工作了。</p><p id="0b5c" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">Swift编译器处理值类型(结构和枚举)的内存管理。</p><p id="e0e5" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在大多数情况下，编译器还处理引用类型类的内存管理。但是，您应该意识到，在某些情况下，类会导致编译器自身无法处理的内存问题。</p><p id="2189" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">通常，当引用类型(例如“一个类”)被使用完后，编译器会释放该实例，因此它的空间会从内存中释放出来。</p><blockquote class="mf mg mh"><p id="a71a" class="kw kx mi ky b kz la jr lb lc ld ju le mj lg lh li mk lk ll lm ml lo lp lq lr ij bi translated">提醒:在OOP中，我们可以将类变量赋给其他类变量。这种赋值叫做引用传递。这意味着实例的引用将被复制到另一个变量，而不是它的值。</p></blockquote><p id="5f01" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这个概念可能会导致一些内存问题，因为不止一个实例指向同一个内存空间，因此编译器本身无法决定何时从内存中释放实例。在这种情况下，Swift使用了一种称为自动引用计数(ARC)的概念来简化编译器的任务。</p><h2 id="3125" class="mm mn iq bd mo mp mq dn mr ms mt dp mu lf mv mw mx lj my mz na ln nb nc nd ne bi translated">自动参考计数</h2><p id="2342" class="pw-post-body-paragraph kw kx iq ky b kz nf jr lb lc ng ju le lf nh lh li lj ni ll lm ln nj lp lq lr ij bi translated">自动引用计数背后的想法很简单。Swift通过计算每个类实例拥有的引用来跟踪代码中创建的引用，以便知道何时从内存中释放类实例是安全的。</p><p id="4bc7" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">ARC确保只要一个属性或变量有对它的强引用，类实例就不会被释放。我将用一个例子来解释它。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ls lt l"/></div></figure><p id="1e59" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">首先让我们假设约翰想买一辆新车。他使用上面的类为汽车创建了这个对象。每当创建一个新的汽车对象时，<code class="fe lu lv lw lx b">init</code> <strong class="ky ir"> </strong>函数分配品牌名称并打印。</p><p id="d65e" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">当John想卖掉他的汽车时，对象将从内存中被释放，因此<code class="fe lu lv lw lx b">deinit</code> <strong class="ky ir"> </strong>函数将被触发。</p><p id="4e4a" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">现在，为了在实际例子中演示弧线，我们将从上面的<code class="fe lu lv lw lx b">MyNewCar</code> <em class="mi"> </em>对象创建一些实例。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ls lt l"/></div></figure><p id="acc3" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们创建了三个类型为<code class="fe lu lv lw lx b">MyNewCar</code>的变量，并且没有初始化它们。首先，我们用我们的<code class="fe lu lv lw lx b">MyNewCar</code>类构造函数初始化一个变量。</p><p id="e95c" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">该操作打印<code class="fe lu lv lw lx b">Porsche is being initialized</code>语句，因为内存空间被分配给类对象的引用，因此当我们第一次初始化对象时，init方法将被调用。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ls lt l"/></div></figure><p id="6bdf" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">之后，我们将<code class="fe lu lv lw lx b">porsche</code> <em class="mi"> </em>变量<em class="mi"> </em>赋给另外两个变量，如上。我将在下面的段落中解释在这个作业的背景中发生的事情。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ls lt l"/></div></figure><p id="0906" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">然后，我们将<code class="fe lu lv lw lx b">porsche</code>和<code class="fe lu lv lw lx b">mercedes</code>变量赋给<code class="fe lu lv lw lx b">nil</code>。同样，我将在下面的段落中解释在这个作业的背景中发生的事情。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ls lt l"/></div></figure><p id="a652" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">最后，我们将该类的最后一个实例(即<code class="fe lu lv lw lx b">ford</code>)设置为零。</p><p id="ad86" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">只有当同一个对象的所有实例都被删除后，该对象才真正被解除初始化<em class="mi"> </em>并从内存中释放。因此，它打印出了deinit函数中的语句。</p></div><div class="ab cl ly lz hu ma" role="separator"><span class="mb bw bk mc md me"/><span class="mb bw bk mc md me"/><span class="mb bw bk mc md"/></div><div class="ij ik il im in"><p id="27f6" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这个例子中到底发生了什么？我们是否创建了一个对象并将其复制到另外两个对象中？这个问题其实在本文第二段就有回答。</p><p id="5801" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">类是引用类型，它们存储在内存的堆部分。当你给同一个类对象分配两个或多个实例时，对象的内容不会被复制，它们只会指向内存中的同一个地址。所以，不复制值，只包含来自内存对象的地址。</p><p id="bcb3" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">该示例的主要目的是解释自动引用计数(ARC)的概念。对象的强引用的数量。当从一个类创建并初始化一个实例时，该对象的ARC为1。当该实例被分配给另外两个实例时，ARC将为3(在将porsche分配给另外两个对象后的<em class="mi">)。</em></p><p id="3927" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">当我们将这两个实例设置为nil时，我们移除了它们与包含该对象的内存地址的连接。他们不再指向那个地址了。弧会再次成为那个物体的<code class="fe lu lv lw lx b">3–2 = 1</code>。因为ARC仍然大于零，所以这个类对象不会被释放，它仍然存在于内存中。</p><p id="f1bb" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">只有当我们设置了指向该对象的最后一个对象(也就是<code class="fe lu lv lw lx b">ford</code> <em class="mi"> </em>对象)时，ARC才会为零，类的<code class="fe lu lv lw lx b">deinit</code>函数才会被调用，类的引用才会从内存中释放。</p></div><div class="ab cl ly lz hu ma" role="separator"><span class="mb bw bk mc md me"/><span class="mb bw bk mc md me"/><span class="mb bw bk mc md"/></div><div class="ij ik il im in"><h2 id="f0d8" class="mm mn iq bd mo mp mq dn mr ms mt dp mu lf mv mw mx lj my mz na ln nb nc nd ne bi translated">强对弱对无主</h2><p id="e84a" class="pw-post-body-paragraph kw kx iq ky b kz nf jr lb lc ng ju le lf nh lh li lj ni ll lm ln nj lp lq lr ij bi translated">什么是强引用？我们将简要地看一下是什么使一个引用变强或变弱。</p><p id="6dfa" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><em class="mi">在本文中，我将只简要提及强引用、弱引用和无主引用的概念。为了进一步解释，我将只写另一篇关于这个概念的文章。</em></p><blockquote class="mf mg mh"><p id="a328" class="kw kx mi ky b kz la jr lb lc ld ju le mj lg lh li mk lk ll lm ml lo lp lq lr ij bi translated">在Swift中，变量可以被声明为<em class="iq">强</em>、<em class="iq">弱</em>或<em class="iq">无主</em>。</p></blockquote><p id="8aca" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">为了让一个变量变强，不需要在声明前面写什么。强引用保护所指向的对象不被ARC释放。只要一个对象有一个强引用，它就不能从内存中被释放，即使包含该对象的屏幕已经从导航堆栈中弹出。</p><p id="c96d" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">例如，上面例子中的每个变量都是强引用，因为没有像weak或unowned这样的关键字。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi nk"><img src="../Images/5f09b1c91e6aafbb9f45f984b8e3204a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1328/format:webp/1*6ckwxMS823wjVZFpMfk6jg.png"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">作者图片</p></figure><p id="2c98" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">与强引用相反，当没有指向被引用对象的强引用时，弱引用不会保护被引用对象不被从内存中释放。</p><p id="65eb" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">指向对象时，弱引用也不会增加弧数。当没有强引用指向一个对象时，即使有弱引用指向，ARC将为零，它将从内存中释放，使弱引用变量为零，因此所有弱引用变量都必须是可选的。为了进行弱引用，我们需要将变量声明为一个<code class="fe lu lv lw lx b">var</code> <strong class="ky ir"> </strong>，并在其前面加上一个<code class="fe lu lv lw lx b">weak</code> <strong class="ky ir"> </strong>关键字。</p><p id="5cfa" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">如上所述，当没有其他强引用指向对象时，弱引用变量将为零，因此它必须是一个可变变量。这意味着它不能是一个常量(不能声明为“let”)。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi nl"><img src="../Images/3fd7ff8d8d0bcf36341c44b6453f1e31.png" data-original-src="https://miro.medium.com/v2/resize:fit:1332/format:webp/1*A6yTWls7nfluyhS1R_ypBA.png"/></div></figure><p id="8f5b" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">一个<strong class="ky ir"> </strong>无主引用和一个弱引用非常相似，除了一些细微的差别。指向对象时，无主参照和弱参照都不会增加圆弧。</p><p id="86a1" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">然而，一个无主被引用对象不必像Swift中的弱被引用对象那样是可选的，它们只应在你确定引用一旦在初始化过程中被设置就不会为零时使用<em class="mi">。</em></p><p id="01a6" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这意味着，当被引用对象没有强引用时，从内存中释放该对象时，该对象不会清零。这产生了一个名为<em class="mi">悬空指针</em>的概念，每个Swift开发人员都应该知道。</p><p id="fcf2" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">因此，无主引用对象应该像<em class="mi">隐式展开选项</em>一样使用。我不会解释悬空指针和隐式展开选项的概念，因为它们的细节不是这篇内存管理文章必须知道的。我将在另一篇文章中详细解释它们。</p></div><div class="ab cl ly lz hu ma" role="separator"><span class="mb bw bk mc md me"/><span class="mb bw bk mc md me"/><span class="mb bw bk mc md"/></div><div class="ij ik il im in"><p id="7328" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我假设自动引用计数术语已经很清楚了。下一件大事是，如果我们不注意这个ARC概念会发生什么，以及它如何损害我们的应用程序的性能。</p><h2 id="a520" class="mm mn iq bd mo mp mq dn mr ms mt dp mu lf mv mw mx lj my mz na ln nb nc nd ne bi translated">保留周期和内存泄漏</h2><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nm"><img src="../Images/07be518b5101b51784ac987fdea1b440.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ZCKr4aOSXmNuToIby3ILAg.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">作者图片</p></figure><p id="754f" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们都知道——至少现在是:)—为了从内存中释放一个对象，它的ARC值必须为零。但是，当两个对象通过强引用相互引用时，它们会阻止编译器释放其中一个对象，因为它们的ARC值总是1。这就是所谓的保留周期。</p><p id="9f9a" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在iOS应用程序中，当由于某种原因无法释放一定量的已分配内存空间时，就会发生内存泄漏。在应用程序运行时，该应用程序的内存使用量总是会增长。内存泄漏可能非常严重，因为它们会很快耗尽为应用程序保留的所有内存，并使iOS操作系统强制关闭应用程序。</p><p id="c0ae" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">保留周期通常会导致内存泄漏，因为无法从内存中释放所有导致保留周期的对象。我将给出一个小例子来演示我们如何导致一个保留周期和一个具有潜在内存泄漏的应用程序。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ls lt l"/></div></figure><p id="0c36" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">首先，我们假设约翰又想买一辆新车。为了帮助他，我们写了一个类似上面的<code class="fe lu lv lw lx b">Car</code> <em class="mi"> </em>类。该类有两个属性；一个是类型为<code class="fe lu lv lw lx b">String</code>的<code class="fe lu lv lw lx b">brand</code><strong class="ky ir">T22，另一个是类型为<code class="fe lu lv lw lx b">Person</code>的<code class="fe lu lv lw lx b">driver</code> <strong class="ky ir"> </strong>。</strong></p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ls lt l"/></div></figure><p id="3f41" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">并行地，我们编写一个<code class="fe lu lv lw lx b">Person</code> <em class="mi"> </em>类，它有两个属性；<code class="fe lu lv lw lx b">name</code> <strong class="ky ir"> </strong>和<code class="fe lu lv lw lx b">car</code>。这两个类都有初始化器和反初始化器函数，用于创建和销毁从这些类派生的对象。当任何一个对象被破坏(或设置为零)时，应调用<code class="fe lu lv lw lx b">deinit</code> <em class="mi"> </em>函数并打印一条响应语句。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ls lt l"/></div></figure><p id="a12b" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">写完类后，我们用它们的初始化器初始化它们。现在，我们需要给<code class="fe lu lv lw lx b">Car</code>实例(<code class="fe lu lv lw lx b">mercedes</code>)设置一个<code class="fe lu lv lw lx b">driver</code> <strong class="ky ir"> </strong>，给<code class="fe lu lv lw lx b">Person</code>实例(<code class="fe lu lv lw lx b">john</code>)设置一个<code class="fe lu lv lw lx b">car</code> <strong class="ky ir"> </strong>。我们在第5行和第6行中就是这样做的。这使得<code class="fe lu lv lw lx b">Car</code>和<code class="fe lu lv lw lx b">Person</code>对象实例(即<code class="fe lu lv lw lx b">mercedes</code> <em class="mi"> </em>和<code class="fe lu lv lw lx b">john</code>)的ARC值都为1。</p><p id="756a" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">当我们的工作完成后，我们希望从内存中释放它们的资源，我们希望销毁这两个对象，如第8行和第9行。我们希望它们的ARC值应该减少到0，编译器从内存中释放它们的资源。然而，我们没有从两个类的deinit函数中看到任何print语句。出问题的是，我们造成了一个保留周期。</p><p id="59c2" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">由于有两个相互引用的强引用，Swift编译器不能从内存中释放它们的资源，因此当我们将它们设置为nil时，不能减少它们的ARC值。比如说；当我们将<code class="fe lu lv lw lx b">mercedes</code> <em class="mi"> </em>实例设置为<code class="fe lu lv lw lx b">nil</code>时，编译器不能将其ARC减少到1，因为汽车对象仍然引用奔驰，反之亦然。</p><p id="40d6" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">为了防止这种保留循环，我们需要声明至少一个变量为弱变量或无主变量。我们可以通过在<code class="fe lu lv lw lx b">Car</code>类的<code class="fe lu lv lw lx b">driver</code> <em class="mi"> </em>属性或<code class="fe lu lv lw lx b">Person</code>类的<code class="fe lu lv lw lx b">car</code> <em class="mi"> </em>属性之前添加一个<code class="fe lu lv lw lx b">weak</code> <strong class="ky ir"> </strong>关键字来打破保留循环。</p></div><div class="ab cl ly lz hu ma" role="separator"><span class="mb bw bk mc md me"/><span class="mb bw bk mc md me"/><span class="mb bw bk mc md"/></div><div class="ij ik il im in"><p id="9ee6" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这是对保留周期和内存泄漏的简短介绍，以便理解Swift中内存管理概念的重要性。我会添加更多关于内存管理和类似主题的博客，因为在我看来这是一个需要学习的重要概念。</p><p id="063f" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我希望这篇文章能够帮助理解内存管理概念的基本部分，并帮助您实现高性能的iOS应用程序。保持健康。</p></div></div>    
</body>
</html>