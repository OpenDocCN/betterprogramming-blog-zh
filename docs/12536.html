<html>
<head>
<title>Deploy Your Stack to a Docker Swarm Through AWS Free-tier Services</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">通过AWS自由层服务将您的堆栈部署到Docker群</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/docker-deploy-a-stack-to-a-swarm-af508e11cfa0?source=collection_archive---------4-----------------------#2022-06-12">https://betterprogramming.pub/docker-deploy-a-stack-to-a-swarm-af508e11cfa0?source=collection_archive---------4-----------------------#2022-06-12</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="27dd" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">快速、简单、廉价的部署</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi ki"><img src="../Images/dcc66c06267d5208619bd25519fa2d8c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1000/format:webp/1*UDluiaOSstYaL5mHP3QQdQ.png"/></div></figure></div><div class="ab cl kq kr hx ks" role="separator"><span class="kt bw bk ku kv kw"/><span class="kt bw bk ku kv kw"/><span class="kt bw bk ku kv"/></div><div class="im in io ip iq"><p id="4db8" class="pw-post-body-paragraph kx ky it kz b la lb ju lc ld le jx lf lg lh li lj lk ll lm ln lo lp lq lr ls im bi translated">在本教程中，我将使用AWS Cloud9 IDE创建一个Docker swarm。Docker Swarm是一个容器编排平台，由Docker构建。</p><p id="8eac" class="pw-post-body-paragraph kx ky it kz b la lb ju lc ld le jx lf lg lh li lj lk ll lm ln lo lp lq lr ls im bi translated">在使用AWS免费层服务的同时，这是一种快速简单的Docker Swarm实验方法。</p><p id="de1a" class="pw-post-body-paragraph kx ky it kz b la lb ju lc ld le jx lf lg lh li lj lk ll lm ln lo lp lq lr ls im bi translated">我们将创建一群Docker引擎，在实践中，您可以通过跨多台主机的多个容器部署应用程序服务。我将使用Docker Compose在本地开发一个映像，并将该映像部署到任何节点都可以访问的集群中。</p></div><div class="ab cl kq kr hx ks" role="separator"><span class="kt bw bk ku kv kw"/><span class="kt bw bk ku kv kw"/><span class="kt bw bk ku kv"/></div><div class="im in io ip iq"><h1 id="299e" class="lt lu it bd lv lw lx ly lz ma mb mc md jz me ka mf kc mg kd mh kf mi kg mj mk bi translated"><strong class="ak">先决条件</strong></h1><ul class=""><li id="4a57" class="ml mm it kz b la mn ld mo lg mp lk mq lo mr ls ms mt mu mv bi translated">具有IAM权限的AWS帐户</li><li id="d6eb" class="ml mm it kz b la mw ld mx lg my lk mz lo na ls ms mt mu mv bi translated">AWS Cloud9 IDE。您需要创建三个环境。一个将用于群管理器，另外两个将作为工作节点。使用Ubuntu平台和t2微实例类型:</li></ul><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="nc nd di ne bf nf"><div class="gh gi nb"><img src="../Images/62506e8804ded125752076441866fb10.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*oGl0F2pgi4WDNdi2LvaW9g.png"/></div></div></figure><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="nc nd di ne bf nf"><div class="gh gi ng"><img src="../Images/c70419a5d077ec54f7a82a1cdb038120.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Fmfx9Hid9W2hm_GOrPoyJQ.png"/></div></div></figure><ul class=""><li id="234a" class="ml mm it kz b la lb ld le lg nh lk ni lo nj ls ms mt mu mv bi translated">GitHub帐户(如果您想将代码推送到GitHub，这是可选的)</li></ul></div><div class="ab cl kq kr hx ks" role="separator"><span class="kt bw bk ku kv kw"/><span class="kt bw bk ku kv kw"/><span class="kt bw bk ku kv"/></div><div class="im in io ip iq"><p id="ca0e" class="pw-post-body-paragraph kx ky it kz b la lb ju lc ld le jx lf lg lh li lj lk ll lm ln lo lp lq lr ls im bi translated">在我们进入Cloud9之前，我们需要添加一些入站安全规则。首先，在网上搜索你的IP地址并复制下来。</p><p id="d8a7" class="pw-post-body-paragraph kx ky it kz b la lb ju lc ld le jx lf lg lh li lj lk ll lm ln lo lp lq lr ls im bi translated">返回AWS控制台，找到EC2服务。选择每个正在运行的Cloud9实例，然后点击您的安全组。接下来，我们将编辑入站规则。添加所有流量并粘贴您的IP地址。选择具有32位地址的cidr模块。保存规则。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="nc nd di ne bf nf"><div class="gh gi nk"><img src="../Images/41f56ca8df02ff6395e19d54c746d407.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*3suLspdn1n2vo42y_10s4g.png"/></div></div></figure><p id="554e" class="pw-post-body-paragraph kx ky it kz b la lb ju lc ld le jx lf lg lh li lj lk ll lm ln lo lp lq lr ls im bi translated">之后，我们将把Swarm manager安全组添加到每个worker节点入站规则中。我们需要蜂群能够互相交流。我们将把每个工作者节点的安全组添加到群组管理器的入站规则中。下面是经理的入站规则的一个示例:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="nc nd di ne bf nf"><div class="gh gi nl"><img src="../Images/5a861aac4e18c088f215627d44db020b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*pOp3HsJUwiVRBiSJHV54RA.png"/></div></div></figure><p id="f483" class="pw-post-body-paragraph kx ky it kz b la lb ju lc ld le jx lf lg lh li lj lk ll lm ln lo lp lq lr ls im bi translated">如果您想将我们创建的代码推送到GitHub，请确保在开始之前克隆您的GitHub库并创建一个新的分支。</p><p id="0926" class="pw-post-body-paragraph kx ky it kz b la lb ju lc ld le jx lf lg lh li lj lk ll lm ln lo lp lq lr ls im bi translated">要开始使用Cloud9，我们先来看看Docker的版本。</p><pre class="kj kk kl km gt nm nn no np aw nq bi"><span id="ebaf" class="nr lu it nn b gy ns nt l nu nv">docker version</span></pre><p id="5059" class="pw-post-body-paragraph kx ky it kz b la lb ju lc ld le jx lf lg lh li lj lk ll lm ln lo lp lq lr ls im bi translated">Docker预装在Cloud9环境中，所以Docker Swarm模式也在那里。确保您在swarm manager IDE上，并键入以下命令来配置manager节点。</p><pre class="kj kk kl km gt nm nn no np aw nq bi"><span id="a5f7" class="nr lu it nn b gy ns nt l nu nv">docker swarm init</span></pre><p id="0589" class="pw-post-body-paragraph kx ky it kz b la lb ju lc ld le jx lf lg lh li lj lk ll lm ln lo lp lq lr ls im bi translated">您将看到下面的消息，我们将使用我们的worker节点上给出的命令将它们添加到群中。复制命令</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="nc nd di ne bf nf"><div class="gh gi nw"><img src="../Images/5063d64ec7e81118ab36b2cf076b82f2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*8Ve5t8Hjr4C01kNDm6keog.png"/></div></div></figure><p id="d081" class="pw-post-body-paragraph kx ky it kz b la lb ju lc ld le jx lf lg lh li lj lk ll lm ln lo lp lq lr ls im bi translated">转到worker 1 IDE，粘贴经理的命令:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="nc nd di ne bf nf"><div class="gh gi nx"><img src="../Images/98a697a92256473df6b4127247b72927.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*6366ap1IYwrUf1lEhUafOg.png"/></div></div><p class="ny nz gj gh gi oa ob bd b be z dk translated">工人1已经加入了蜂群</p></figure><p id="bfc2" class="pw-post-body-paragraph kx ky it kz b la lb ju lc ld le jx lf lg lh li lj lk ll lm ln lo lp lq lr ls im bi translated">对工人2重复该步骤，然后回到经理那里。键入以下命令以确保您的swarm已准备就绪并处于活动状态。</p><pre class="kj kk kl km gt nm nn no np aw nq bi"><span id="28ee" class="nr lu it nn b gy ns nt l nu nv">docker node ls</span></pre><p id="301f" class="pw-post-body-paragraph kx ky it kz b la lb ju lc ld le jx lf lg lh li lj lk ll lm ln lo lp lq lr ls im bi translated">您应该会看到类似这样的内容:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="nc nd di ne bf nf"><div class="gh gi oc"><img src="../Images/525e4c6ddc256ee237a67278776e418c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*81MgwheVmdrtCCMblTetoQ.png"/></div></div></figure><p id="067e" class="pw-post-body-paragraph kx ky it kz b la lb ju lc ld le jx lf lg lh li lj lk ll lm ln lo lp lq lr ls im bi translated">你可以看到我有一个经理和两个工人。</p></div><div class="ab cl kq kr hx ks" role="separator"><span class="kt bw bk ku kv kw"/><span class="kt bw bk ku kv kw"/><span class="kt bw bk ku kv"/></div><div class="im in io ip iq"><p id="5779" class="pw-post-body-paragraph kx ky it kz b la lb ju lc ld le jx lf lg lh li lj lk ll lm ln lo lp lq lr ls im bi translated">如果你写了这个命令，<code class="fe od oe of nn b">docker images</code>你会看到我们可以去掉一些图像来释放空间。运行a</p><p id="edac" class="pw-post-body-paragraph kx ky it kz b la lb ju lc ld le jx lf lg lh li lj lk ll lm ln lo lp lq lr ls im bi translated"><code class="fe od oe of nn b">docker rmi -f $(docker images -q)</code>如果您愿意，可以去掉所有图像。</p></div><div class="ab cl kq kr hx ks" role="separator"><span class="kt bw bk ku kv kw"/><span class="kt bw bk ku kv kw"/><span class="kt bw bk ku kv"/></div><div class="im in io ip iq"><p id="d28a" class="pw-post-body-paragraph kx ky it kz b la lb ju lc ld le jx lf lg lh li lj lk ll lm ln lo lp lq lr ls im bi translated">接下来，我们将安装docker-compose。为此，请键入:</p><pre class="kj kk kl km gt nm nn no np aw nq bi"><span id="5f57" class="nr lu it nn b gy ns nt l nu nv">sudo apt install docker-compose</span></pre><p id="7252" class="pw-post-body-paragraph kx ky it kz b la lb ju lc ld le jx lf lg lh li lj lk ll lm ln lo lp lq lr ls im bi translated">让我们创建一些将要使用的目录和文件。</p><p id="bcf4" class="pw-post-body-paragraph kx ky it kz b la lb ju lc ld le jx lf lg lh li lj lk ll lm ln lo lp lq lr ls im bi translated">我有一个目录，我把它命名为<strong class="kz iu"> <em class="og"> Docker_Swarm </em> </strong>。我会把目录换成这个，并添加一个<strong class="kz iu"><em class="og">docker-compose . yml</em></strong>文件。我将使用以下命令:</p><pre class="kj kk kl km gt nm nn no np aw nq bi"><span id="b0d9" class="nr lu it nn b gy ns nt l nu nv">touch docker-compose.yml</span></pre></div><div class="ab cl kq kr hx ks" role="separator"><span class="kt bw bk ku kv kw"/><span class="kt bw bk ku kv kw"/><span class="kt bw bk ku kv"/></div><div class="im in io ip iq"><p id="cc9f" class="pw-post-body-paragraph kx ky it kz b la lb ju lc ld le jx lf lg lh li lj lk ll lm ln lo lp lq lr ls im bi translated">接下来，我们将创建另一个目录来存放一个<code class="fe od oe of nn b">websales</code>文件，我们最终将把它分配给一个网络，并在我们的每个容器中为其创建卷。让我们把这个新文件夹叫做<code class="fe od oe of nn b">webexport</code>，里面有一个文件叫做<code class="fe od oe of nn b">websales.txt</code>。我们将在容器上创建一个名为stored in <code class="fe od oe of nn b">webvolume</code>的Docker卷，我们的docker-compose文件将指向<code class="fe od oe of nn b">webexport</code>目录。我们创建的所有容器都将附加Docker卷。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi oh"><img src="../Images/666cb382294d15b70d95564331f06194.png" data-original-src="https://miro.medium.com/v2/resize:fit:438/format:webp/1*6ybgmVovjMzbQPGgGdGWRw.png"/></div></figure><p id="bcd1" class="pw-post-body-paragraph kx ky it kz b la lb ju lc ld le jx lf lg lh li lj lk ll lm ln lo lp lq lr ls im bi translated">对于这个项目，我不会使用绑定挂载。根据Docker的说法，绑定挂载可能是有用的，但是最佳实践建议您在使用Docker swarm模式时不要使用它们来设计应用程序。以下是风险:</p><blockquote class="oi oj ok"><p id="9ea9" class="kx ky og kz b la lb ju lc ld le jx lf ol lh li lj om ll lm ln on lp lq lr ls im bi translated">如果将主机路径绑定到服务的容器中，该路径必须存在于每个群节点上。Docker swarm模式调度程序可以在任何满足资源可用性要求和所有约束条件以及您指定的布局偏好的机器上调度容器。</p><p id="11aa" class="kx ky og kz b la lb ju lc ld le jx lf ol lh li lj om ll lm ln on lp lq lr ls im bi translated">如果服务容器变得不健康或不可达，Docker swarm模式调度程序可以随时重新调度正在运行的服务容器。</p><p id="b861" class="kx ky og kz b la lb ju lc ld le jx lf ol lh li lj om ll lm ln on lp lq lr ls im bi translated">主机绑定装载是不可移植的。当您使用绑定挂载时，不能保证您的应用程序在开发中的运行方式与在生产中的运行方式相同。</p></blockquote></div><div class="ab cl kq kr hx ks" role="separator"><span class="kt bw bk ku kv kw"/><span class="kt bw bk ku kv kw"/><span class="kt bw bk ku kv"/></div><div class="im in io ip iq"><p id="1df4" class="pw-post-body-paragraph kx ky it kz b la lb ju lc ld le jx lf lg lh li lj lk ll lm ln lo lp lq lr ls im bi translated">现在让我们来看看docker-compose文件。您可以使用一个文本编辑工具，比如vim，其中您可以使用来自<code class="fe od oe of nn b">Docker_Swarm</code>目录的命令<code class="fe od oe of nn b">vim docker-compose.yml</code>。我只需双击左栏中的文件。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oo op l"/></div></figure><ul class=""><li id="a0d1" class="ml mm it kz b la lb ld le lg nh lk ni lo nj ls ms mt mu mv bi translated">我想指出的一点是，我第一次进行故障排除时，为了使用将Docker映像的副本分布到整个集群的放置首选项，我必须为我的每个worker节点创建一个节点标签。标签是<code class="fe od oe of nn b">availability_zone</code>。我首先使用一个<code class="fe od oe of nn b">docker node ls</code>来显示每个工作节点的主机名，然后使用命令</li></ul><pre class="kj kk kl km gt nm nn no np aw nq bi"><span id="762a" class="nr lu it nn b gy ns nt l nu nv">docker node update --label-add <strong class="nn iu"><em class="og">availability_zone</em></strong> &lt;HOSTNAME&gt;</span></pre><ul class=""><li id="b8d5" class="ml mm it kz b la lb ld le lg nh lk ni lo nj ls ms mt mu mv bi translated">一旦添加了该标签，就可以检查该节点</li></ul><pre class="kj kk kl km gt nm nn no np aw nq bi"><span id="e825" class="nr lu it nn b gy ns nt l nu nv">docker node inspect --pretty &lt;HOSTNAME&gt;</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi oq"><img src="../Images/93a1392bd8a294fc2573f0fb40ca474b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1352/format:webp/1*DN6WGMxcTcbzQC0IvAjzjQ.png"/></div></figure><ul class=""><li id="53ca" class="ml mm it kz b la lb ld le lg nh lk ni lo nj ls ms mt mu mv bi translated">另一个注意事项是，我们不需要在docker-compose文件中打开任何端口。您可能希望容器的服务保持私有，或者只对同一个Docker网络中的其他成员开放。</li></ul></div><div class="ab cl kq kr hx ks" role="separator"><span class="kt bw bk ku kv kw"/><span class="kt bw bk ku kv kw"/><span class="kt bw bk ku kv"/></div><div class="im in io ip iq"><p id="d58c" class="pw-post-body-paragraph kx ky it kz b la lb ju lc ld le jx lf lg lh li lj lk ll lm ln lo lp lq lr ls im bi translated">让我们看看这一切是否行得通。在命令行中，键入:</p><pre class="kj kk kl km gt nm nn no np aw nq bi"><span id="10e1" class="nr lu it nn b gy ns nt l nu nv">docker stack deploy -c docker-compose.yml &lt;NAME_YOUR_STACK&gt;</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="nc nd di ne bf nf"><div class="gh gi or"><img src="../Images/4460b0fa3670fda2ead513d481886a19.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*suZrauBZEEyvLSDY2ZP7ug.png"/></div></div></figure><p id="688f" class="pw-post-body-paragraph kx ky it kz b la lb ju lc ld le jx lf lg lh li lj lk ll lm ln lo lp lq lr ls im bi translated">看起来那个堆栈正在被创建。要查看堆栈中运行的容器:</p><pre class="kj kk kl km gt nm nn no np aw nq bi"><span id="3c50" class="nr lu it nn b gy ns nt l nu nv">docker stack ps &lt;STACK_NAME&gt;</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="nc nd di ne bf nf"><div class="gh gi os"><img src="../Images/37edbe69527914987ced606e073e13ff.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*dD5BgXLSWWoH15MDaLakGQ.png"/></div></div></figure><p id="67e5" class="pw-post-body-paragraph kx ky it kz b la lb ju lc ld le jx lf lg lh li lj lk ll lm ln lo lp lq lr ls im bi translated">如您所见，我们在每个群节点上运行centos映像。</p><p id="85b0" class="pw-post-body-paragraph kx ky it kz b la lb ju lc ld le jx lf lg lh li lj lk ll lm ln lo lp lq lr ls im bi translated">让我们来看看服务:</p><pre class="kj kk kl km gt nm nn no np aw nq bi"><span id="8cee" class="nr lu it nn b gy ns nt l nu nv">docker stack services &lt;STACK_NAME&gt;</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="nc nd di ne bf nf"><div class="gh gi ot"><img src="../Images/64e541d12ed9e46e044f59cb6b289cfe.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*nzR0Jwnj411f8LVqjdZmAw.png"/></div></div></figure><p id="e87c" class="pw-post-body-paragraph kx ky it kz b la lb ju lc ld le jx lf lg lh li lj lk ll lm ln lo lp lq lr ls im bi translated">要查看卷是否已连接，我们可以输入以下命令:</p><pre class="kj kk kl km gt nm nn no np aw nq bi"><span id="99a0" class="nr lu it nn b gy ns nt l nu nv">docker volume ls<br/>docker volume inspect &lt;VOLUME_NAME&gt;</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="nc nd di ne bf nf"><div class="gh gi ou"><img src="../Images/3458a6b1135946fd25f42ec84e3b0e34.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ztDe5-jBsiN9ZBxrFWtkIg.png"/></div></div></figure><p id="a7b8" class="pw-post-body-paragraph kx ky it kz b la lb ju lc ld le jx lf lg lh li lj lk ll lm ln lo lp lq lr ls im bi translated">我们也可以在每个worker节点上运行<code class="fe od oe of nn b">docker volume ls</code>:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi ov"><img src="../Images/9fdbb5afdff7a82c90744ec659a8fe03.png" data-original-src="https://miro.medium.com/v2/resize:fit:1324/format:webp/1*dlbUUHCN1yoPjKcYhxQdcQ.png"/></div><p class="ny nz gj gh gi oa ob bd b be z dk translated">工人1</p></figure><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi ow"><img src="../Images/6dbcdc24e7495265af057f86ce90e0fb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1058/format:webp/1*vy4xtPjRNgQNv6C1R986Dg.png"/></div><p class="ny nz gj gh gi oa ob bd b be z dk translated">工人2</p></figure><p id="d614" class="pw-post-body-paragraph kx ky it kz b la lb ju lc ld le jx lf lg lh li lj lk ll lm ln lo lp lq lr ls im bi translated">我们还可以看到，我们在docker-compose文件中指定的网络存在于整个集群中:</p><pre class="kj kk kl km gt nm nn no np aw nq bi"><span id="fd77" class="nr lu it nn b gy ns nt l nu nv">docker network ls<br/>docker network inspect &lt;NETWORK_NAME&gt;</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi ox"><img src="../Images/61e9d1d86e7ced9a5b08d43448ad571e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1242/format:webp/1*-evWazFDTHhZlfeEIHePlw.png"/></div></figure><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi oy"><img src="../Images/d149cdae4693fab5bdfe49984bf36cc3.png" data-original-src="https://miro.medium.com/v2/resize:fit:848/format:webp/1*hyst77DagICuwBCgRpZ1-Q.png"/></div><p class="ny nz gj gh gi oa ob bd b be z dk translated">网络是附在蜂群上的</p></figure></div><div class="ab cl kq kr hx ks" role="separator"><span class="kt bw bk ku kv kw"/><span class="kt bw bk ku kv kw"/><span class="kt bw bk ku kv"/></div><div class="im in io ip iq"><p id="d25d" class="pw-post-body-paragraph kx ky it kz b la lb ju lc ld le jx lf lg lh li lj lk ll lm ln lo lp lq lr ls im bi translated">恭喜你。您已经成功地创建了一个Docker群组，并利用群组中的工作节点部署了一个带有副本的Docker堆栈。</p><p id="929d" class="pw-post-body-paragraph kx ky it kz b la lb ju lc ld le jx lf lg lh li lj lk ll lm ln lo lp lq lr ls im bi translated">如果你想把你的代码推送到GitHub，现在是时候了。</p><p id="f43c" class="pw-post-body-paragraph kx ky it kz b la lb ju lc ld le jx lf lg lh li lj lk ll lm ln lo lp lq lr ls im bi translated">确保移除您的堆栈:</p><pre class="kj kk kl km gt nm nn no np aw nq bi"><span id="c336" class="nr lu it nn b gy ns nt l nu nv">docker stack rm &lt;STACK_NAME&gt; </span></pre><p id="915c" class="pw-post-body-paragraph kx ky it kz b la lb ju lc ld le jx lf lg lh li lj lk ll lm ln lo lp lq lr ls im bi translated">当我完成我的项目时，我喜欢移除所有的容器和图像。</p><pre class="kj kk kl km gt nm nn no np aw nq bi"><span id="fa45" class="nr lu it nn b gy ns nt l nu nv">docker rm -f $(docker ps -a -q) <br/># removes all containers</span><span id="007c" class="nr lu it nn b gy oz nt l nu nv">docker rmi -f $(docker images -q)<br/># removes all docker images</span></pre><p id="e43a" class="pw-post-body-paragraph kx ky it kz b la lb ju lc ld le jx lf lg lh li lj lk ll lm ln lo lp lq lr ls im bi translated">感谢您的阅读！</p></div></div>    
</body>
</html>