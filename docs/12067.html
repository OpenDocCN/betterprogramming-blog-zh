<html>
<head>
<title>Generate NFT Collections With Node.js Using the Canvas API</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用Canvas API通过Node.js生成NFT集合</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/using-the-canvas-api-to-generate-an-nft-collection-with-nodejs-add56035c40f?source=collection_archive---------14-----------------------#2022-05-09">https://betterprogramming.pub/using-the-canvas-api-to-generate-an-nft-collection-with-nodejs-add56035c40f?source=collection_archive---------14-----------------------#2022-05-09</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="dfb6" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">先睹为快NFTooze项目</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/926d82d4a3a07236d7d6b50b00e288d8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*fdZ9mfbQdfzUdo6VgUhGsQ.png"/></div></div></figure><p id="d13b" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">NFT集合通常指的是从同一组单独的可组合特征生成的一组NFT，如眼睛、鼻子和做脸的嘴。</p><p id="4f1f" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">生成这些图像的简单逻辑是使用Canvas API将每个图像从后向前绘制为一个层，将Canvas导出为一个图像，清除，并使用不同的特征集重复相同的过程。</p><p id="aa41" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">这个实现来自于我构建的一个小平台，它使用相应的元数据生成NFT集合，没有代码，名为<a class="ae ln" href="https://nftooze.com" rel="noopener ugc nofollow" target="_blank"> <strong class="kt ir"> NFTooze </strong> </a></p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi lo"><img src="../Images/e21adf024f1aad209eb72135fdfa8c87.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*XiDhWGfGMkTnUTA8wsQ6eA.png"/></div></div></figure><p id="d49f" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">安装和导入软件包</p><pre class="kg kh ki kj gt lp lq lr ls aw lt bi"><span id="85b2" class="lu lv iq lq b gy lw lx l ly lz">npm i canvas file-saver jszip</span></pre><p id="81a2" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">为了能够保存生成的图像，我们需要再安装两个包，<code class="fe ma mb mc lq b">file-saver</code>保存单个文件，<code class="fe ma mb mc lq b">jszip</code>为整个集合创建一个zip文件夹。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="md me l"/></div></figure><p id="1d4a" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">在安装和导入包之后，我们将创建一个<strong class="kt ir">引擎类</strong>，它将保存集合生成所需的不同方法。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="md me l"/></div></figure><p id="25ff" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated"><code class="fe ma mb mc lq b">size</code>变量代表我们画布的<code class="fe ma mb mc lq b">width</code>和<code class="fe ma mb mc lq b">height</code>，它们对于每张用于合成的图像应该是相同的。</p><p id="9b73" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">我们的类变量包含我们需要声明的类型。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="md me l"/></div></figure><p id="843c" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">每个图层都代表一个由多幅图像组成的NFT，正如你在上面的定义中看到的那样。</p><p id="a7ea" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">我们需要一个构造函数和其他一些方法来实例化或设置我们的类变量。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="md me l"/></div></figure><p id="7830" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">画完NFT后，我们需要使用上下文的方法<code class="fe ma mb mc lq b">clearRect</code>清空画布:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="md me l"/></div></figure><p id="11c1" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">绘制图像是最重要的步骤之一，这是通过从图像路径加载图像，并使用<code class="fe ma mb mc lq b">ctx.drawImage</code>将其绘制到画布上来实现的:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="md me l"/></div></figure><p id="e3ae" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">一旦图像被绘制到画布上，它就可以导出为png。对于这一步，我们需要两个方法，<code class="fe ma mb mc lq b">generateNFT</code>从images数组中逐个绘制所有图像，而<code class="fe ma mb mc lq b">saveFileToZip</code>将每个生成的NFT添加到集合中。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="md me l"/></div></figure><p id="6e76" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">为了保存在画布上绘制的图像，我们将使用<code class="fe ma mb mc lq b">canvas.toBlob</code>方法获取要传递给<code class="fe ma mb mc lq b">jszip</code>的blob，然后调用<code class="fe ma mb mc lq b">this.clearCanvas</code>来释放画布以进行新的绘制。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="md me l"/></div></figure><p id="e863" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">最后，为了导出和下载我们的zip文件，我们已经向其中添加了图像，我们必须从<code class="fe ma mb mc lq b">jszip</code>调用<code class="fe ma mb mc lq b">generateAsync</code>方法</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="md me l"/></div></figure><h2 id="04cf" class="lu lv iq bd mf mg mh dn mi mj mk dp ml la mm mn mo le mp mq mr li ms mt mu mv bi translated">生成图层</h2><p id="8c91" class="pw-post-body-paragraph kr ks iq kt b ku mw jr kw kx mx ju kz la my lc ld le mz lg lh li na lk ll lm ij bi translated">上述过程没有显示如何从一组特征生成层，因为这可以通过特定的算法来完成。一种基本的方法可以是所有特征的笛卡儿积，这将产生一个数组的数组，每个数组是构成单个NFT的一组独特的特征。</p><p id="f2eb" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">让我们向类中添加一个方法，该方法接受一组层，并返回具有不同唯一组合的层的数组。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="md me l"/></div></figure><h1 id="096f" class="nb lv iq bd mf nc nd ne mi nf ng nh ml jw ni jx mo jz nj ka mr kc nk kd mu nl bi translated">下一步是什么？</h1><p id="dceb" class="pw-post-body-paragraph kr ks iq kt b ku mw jr kw kx mx ju kz la my lc ld le mz lg lh li na lk ll lm ij bi translated">查看<a class="ae ln" href="https://nftooze.com" rel="noopener ugc nofollow" target="_blank"> NFTooze </a>项目的<a class="ae ln" href="https://github.com/gracelungu/nft-generator" rel="noopener ugc nofollow" target="_blank"> GitHub库</a>，看看用前端应用程序生成NFT集合所需的其他代码部分。</p></div></div>    
</body>
</html>