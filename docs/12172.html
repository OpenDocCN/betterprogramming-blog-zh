<html>
<head>
<title>Do We Need gRPC?</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">我们需要gRPC吗？</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/we-need-grpc-7ce6f13312d8?source=collection_archive---------3-----------------------#2022-05-17">https://betterprogramming.pub/we-need-grpc-7ce6f13312d8?source=collection_archive---------3-----------------------#2022-05-17</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="6610" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">…从技术上讲，我们不需要它，但它有自己的使用案例</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/e52b0bca01a4dd473974556261347025.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*D0dyCIcwZPt8sgMScqOntw.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated"><a class="ae kv" href="https://grpc.io/" rel="noopener ugc nofollow" target="_blank">https://grpc.io/</a></p></figure><p id="890f" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我准备写一篇关于中间件的长篇大论的帖子，以回应有人在一次聚会上问我的一个问题，但我意识到我错了——尽管<a class="ae kv" href="https://github.com/grpc-ecosystem/go-grpc-middleware" rel="noopener ugc nofollow" target="_blank"> gRPC可以用于中间件</a>，最好的描述方式是将<a class="ae kv" href="https://towardsdatascience.com/reasons-to-choose-grpc-over-rest-and-how-to-adopt-it-into-your-python-apis-197ac28e22b4" rel="noopener" target="_blank">描述为一个RPC系统，可以作为其余</a>架构风格的替代。这种说法本身就有问题(有人说它是合理的，有人说它是风马牛不相及的)，但这可能是开始讨论的最简单的地方:</p><ul class=""><li id="037b" class="ls lt iq ky b kz la lc ld lf lu lj lv ln lw lr lx ly lz ma bi translated">它使用比JSON 更小更快的协议缓冲区<a class="ae kv" href="https://developers.google.com/protocol-buffers/docs/overview" rel="noopener ugc nofollow" target="_blank">。有人在博客上写了一个基准测试</a><a class="ae kv" href="https://medium.com/sahibinden-technology/benchmarking-rest-vs-grpc-5d4b34360911" rel="noopener">，这里</a>比较了gRPC/协议缓冲区和REST/json</li><li id="af5d" class="ls lt iq ky b kz mb lc mc lf md lj me ln mf lr lx ly lz ma bi translated"><a class="ae kv" href="https://grpc.io/" rel="noopener ugc nofollow" target="_blank"> gRPC跨语言和平台工作</a>。例如，你可以用Java写一个服务器，用Python写一个客户端。这个过程相对简单</li><li id="1f94" class="ls lt iq ky b kz mb lc mc lf md lj me ln mf lr lx ly lz ma bi translated">gRPC是开源的</li></ul><p id="6ba9" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我不愿意建议每个开发人员抛弃他们当前的技术而选择gRPC，尽管已经有相当多的文章做出了这样的声明。对于为什么我们可能需要gRPC，我简单的回答是，它已经被广泛采用了。根据维基百科的页面:<em class="mg">许多不同的组织都采用了gRPC，如</em> <a class="ae kv" href="https://en.wikipedia.org/wiki/Uber" rel="noopener ugc nofollow" target="_blank"> <em class="mg">【优步】</em></a><em class="mg"/><a class="ae kv" href="https://en.wikipedia.org/wiki/GRPC#cite_note-8" rel="noopener ugc nofollow" target="_blank"><em class="mg">【8】</em></a><em class="mg"/><a class="ae kv" href="https://en.wikipedia.org/wiki/Square,_Inc." rel="noopener ugc nofollow" target="_blank"><em class="mg">Square</em></a><em class="mg"/><a class="ae kv" href="https://en.wikipedia.org/wiki/Netflix" rel="noopener ugc nofollow" target="_blank"><em class="mg">【网飞</em></a><em class="mg"/><a class="ae kv" href="https://en.wikipedia.org/wiki/IBM" rel="noopener ugc nofollow" target="_blank"><em class="mg">IBM</em></a><em class="mg"> </em> <a class="ae kv" href="https://en.wikipedia.org/wiki/Cisco_Systems" rel="noopener ugc nofollow" target="_blank"> <em class="mg">【思科】</em></a><em class="mg"/><a class="ae kv" href="https://en.wikipedia.org/wiki/Juniper_Networks" rel="noopener ugc nofollow" target="_blank"><em class="mg">瞻博网络</em></a><em class="mg"/><a class="ae kv" href="https://en.wikipedia.org/wiki/GRPC#cite_note-9" rel="noopener ugc nofollow" target="_blank"><em class="mg">【9】</em></a><em class="mg"/><a class="ae kv" href="https://en.wikipedia.org/wiki/Spotify" rel="noopener ugc nofollow" target="_blank"><em class="mg">Spotify</em></a><em class="mg"/><a class="ae kv" href="https://en.wikipedia.org/wiki/GRPC#cite_note-10" rel="noopener ugc nofollow" target="_blank"><em class="mg">【10】<em class="mg"> </em><a class="ae kv" href="https://en.wikipedia.org/wiki/GRPC#cite_note-12" rel="noopener ugc nofollow" target="_blank"><em class="mg"/></a></em></a></p><p id="f915" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">一篇非常简洁的文章可以在<a class="ae kv" href="https://www.altexsoft.com/blog/what-is-grpc/" rel="noopener ugc nofollow" target="_blank">这里</a>找到，它简要概述了gRPC如何使用轻量级消息，执行速度比REST/JSON快5-8倍，并具有内置通信功能。在把这篇文章汇总成我能找到的所有其他文章之前，让我先描述一下它是如何工作的:</p><p id="9d86" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">你在一个协议缓冲文件中定义了一个服务…出于某种原因，Google在它的文档中使用的例子是矩形属性。根据编程语言的不同，您可以使用proto编译器生成一些特定于语言的文件。现在您有了可以使用的文件，包括一个存根(一个RPC概念)。在这里，您可以创建客户端和服务器。</p><h1 id="a3b4" class="mh mi iq bd mj mk ml mm mn mo mp mq mr jw ms jx mt jz mu ka mv kc mw kd mx my bi translated">给我看看</h1><p id="0bd0" class="pw-post-body-paragraph kw kx iq ky b kz mz jr lb lc na ju le lf nb lh li lj nc ll lm ln nd lp lq lr ij bi translated">好吧，就是这样。这只是他们固定的Python例子。你可以直接从他们的<a class="ae kv" href="https://github.com/grpc/grpc" rel="noopener ugc nofollow" target="_blank"> GitHub </a>下载，可以在一个名为examples的文件夹中找到。它开箱即用吗？埃文的数据点，但绝对不是。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi ne"><img src="../Images/be7d54d9a67849d182b1e1836142657f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*DTrHQhV2PO9cjzTC5Dap7Q.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated"><a class="ae kv" href="https://github.com/grpc/grpc/blob/master/examples/python/helloworld/async_greeter_client.py" rel="noopener ugc nofollow" target="_blank">https://github . com/grpc/grpc/blob/master/examples/python/hello world/async _ greeter _ client . py</a>。这个想法是你自己写你自己的greet_client和greeter_server等价物。另外两个文件是自动生成的，包含RPC代码特有的存根。</p></figure><p id="640a" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">当您自己编写实现时，您可以混合使用。你可以用多种语言编写一个服务器，然后用多种语言编写一个客户端。重点是？如果你做了一个服务器，人们可以编写定制的客户端，用他们选择的语言与它对话。</p><p id="af48" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我脑子里有一个完整的例子。我打算用corgi.proto编写一个服务，它将具有corgi权重和corgi长度……它将使用C++和双向流。我没有做到这一点，所以我决定只使用开箱即用的示例，但这也不起作用，所以在我等待C++依赖项的时候，我浏览了一堆论坛，直到我可以使用他们的现成Python示例。所以是的，就是这样。服务器在上面，客户端在下面。</p><p id="af0c" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们可以给你看一些非常非常棒的代码。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nf"><img src="../Images/9232a9e18ec6726d4418426e5a665434.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*jusYcXh_pyY5xczucjxXqg.png"/></div></div></figure><p id="3ac9" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这是Python，我不是超级熟悉，但还是继续吧。<code class="fe ng nh ni nj b">helloworld_pb2</code>和<code class="fe ng nh ni nj b">helloworld_pb2_grpc</code>是上述从协议缓冲区创建的两个文件。</p><p id="5145" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><code class="fe ng nh ni nj b">insecure_channel</code>表示没有SSL/TLS，这是一个异步调用(没错，有整整一节是关于认证的。这一部分相当简单，至少在客户端是如此)。它附带了免费的开源gRPC/Python文档，这是一个很好的起点。您将看到有几个选项…您可以让客户端和服务器进行单个请求/回复，或者您可以使用双向流，或者您可以做类似这样的事情。</p><p id="1de4" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">是的。这就是了。客户端和服务器。</p><h1 id="d155" class="mh mi iq bd mj mk ml mm mn mo mp mq mr jw ms jx mt jz mu ka mv kc mw kd mx my bi translated">后退一步</h1><p id="dcb3" class="pw-post-body-paragraph kw kx iq ky b kz mz jr lb lc na ju le lf nb lh li lj nc ll lm ln nd lp lq lr ij bi translated">咻。好吧。现在事情变得有趣了。</p><p id="70fb" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><a class="ae kv" rel="noopener ugc nofollow" target="_blank" href="/understanding-grpc-60737b23e79e">这篇</a>是一篇病毒式的文章(嗯，“病毒”是我使用的一个不太严谨的术语)，为gRPC辩护——你可以在评论中看到一些不同的观点。这里有一个有趣的。</p><pre class="kg kh ki kj gt nk nj nl nm aw nn bi"><span id="9723" class="no mi iq nj b gy np nq l nr ns">Sorry, Arun, RPCs are an archaic technology that I used back in the 70s when it was all we had. Software engineering has come a long way since then.</span><span id="85a9" class="no mi iq nj b gy nt nq l nr ns">We've learned to avoid tight coupling of components for many compelling reasons. It is a fundamental principle of microservice architecture. It is painful watching developers making the same mistakes again for the same old reasons.</span><span id="14ca" class="no mi iq nj b gy nt nq l nr ns">JSON didn't exist when Roy Fielding wrote his dissertation on REST, but it is a useful "self-defining" message syntax. Protocol buffers are anything but self-defining and require a complex system for distributed schema management to work at all. That may be justifiable when data compression is the overriding concern, but it makes loosely-coupled microservices impossible to implement.</span><span id="85a5" class="no mi iq nj b gy nt nq l nr ns">A properly designed RESTful solution is a far better match for the implementation of a microservice architecture.</span><span id="982d" class="no mi iq nj b gy nt nq l nr ns"><a class="ae kv" href="https://medium.com/nerd-for-tech/microservice-architecture-622e4148f1" rel="noopener">https://medium.com/nerd-for-tech/microservice-architecture-622e4148f1</a></span><span id="c68f" class="no mi iq nj b gy nt nq l nr ns">--Dick Dowdell <a class="ae kv" href="https://dick-dowdell.medium.com/?source=responses-----60737b23e79e----4----------------------------" rel="noopener">https://dick-dowdell.medium.com/?source=responses-----60737b23e79e----4----------------------------</a></span></pre><p id="aafd" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我的看法？我真的不知道，但这是一个令人着迷的讨论。</p><p id="853f" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">gRPC现在在业界很有用，google协议缓冲区更受欢迎。它很快。让同一套协议缓冲文件在几秒钟内产生不同的语言绑定是有好处的。这可能是未来。但是同时我们还需要使用REST APIs吗？</p><p id="7309" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">当然，对于各种各样的事情。这是典型的惯性权衡，在技术领域如此普遍，尽管至少上面的评论表明，可能有其他原因让我们想对此三思。</p><p id="3977" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">一个好的项目应该是用gRPC构建一个完整的端到端系统。由于其性质，这也可以作为一个整洁的语言学习练习。Python？当然可以。C++客户端？为什么不呢？</p><h1 id="ea87" class="mh mi iq bd mj mk ml mm mn mo mp mq mr jw ms jx mt jz mu ka mv kc mw kd mx my bi translated">结束语</h1><p id="5add" class="pw-post-body-paragraph kw kx iq ky b kz mz jr lb lc na ju le lf nb lh li lj nc ll lm ln nd lp lq lr ij bi translated">我希望继续讨论第二个post addressing中间件，也许是ZeroMQ的现成例子。</p><p id="6441" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这里有一篇关于老虎的文章，许多人无情地将它倾倒在点击诱饵标题上，“休息正在死去，摆脱它。”我觉得有趣的是，有人认为GRPC是老虎的更好版本。</p><p id="220b" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">它代表什么？不知道。</p><p id="fa8a" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">总有一天<a class="ae kv" href="https://medium.com/@kurt.shibainu/every-tech-article-ever-part-1-of-3-40df957d3e0c" rel="noopener">我会发明自己的项目，叫做柯基</a>。</p></div></div>    
</body>
</html>