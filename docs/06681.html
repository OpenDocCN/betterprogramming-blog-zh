<html>
<head>
<title>5 Sorting Algorithms Every Programmer Should Know</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">每个程序员都应该知道的5种排序算法</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/5-basic-sorting-algorithms-you-must-know-9ef5b1f3949c?source=collection_archive---------0-----------------------#2020-10-24">https://betterprogramming.pub/5-basic-sorting-algorithms-you-must-know-9ef5b1f3949c?source=collection_archive---------0-----------------------#2020-10-24</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="626d" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">插入、选择、冒泡、合并和快速排序</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/aab64c318f3b49f7e177baaacd50db9c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*0QAHmg7iZgG4lVk0"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">罗伯特·尼克森在<a class="ae kv" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的照片</p></figure><p id="1d89" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">有没有想过，当你应用从低到高、从高到低或按字母顺序的过滤器时，亚马逊或任何其他电子商务网站上的产品是如何排序的？排序算法在这类网站中起着至关重要的作用，在这些网站中，你有大量的产品上市，你必须使客户互动变得容易。</p><p id="66cd" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">排序算法用于根据元素上的比较运算符重新排列给定的元素数组或列表。比较运算符用于决定各个数据结构中元素的新顺序。主要有五种基本算法，你可以用这些基本算法推导出多种算法。这些算法各有利弊，可以根据要处理的数据大小进行有效选择。</p><ol class=""><li id="aad3" class="ls lt iq ky b kz la lc ld lf lu lj lv ln lw lr lx ly lz ma bi translated">插入排序</li><li id="39d3" class="ls lt iq ky b kz mb lc mc lf md lj me ln mf lr lx ly lz ma bi translated">选择排序</li><li id="6ec3" class="ls lt iq ky b kz mb lc mc lf md lj me ln mf lr lx ly lz ma bi translated">冒泡排序</li><li id="6d22" class="ls lt iq ky b kz mb lc mc lf md lj me ln mf lr lx ly lz ma bi translated">合并排序</li><li id="bc3b" class="ls lt iq ky b kz mb lc mc lf md lj me ln mf lr lx ly lz ma bi translated">快速排序</li></ol><p id="3791" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><em class="mg">获取完整的数据结构和算法cheatsheet，叉本</em><a class="ae kv" href="https://github.com/adwiteeya3/dsa-cheatsheet" rel="noopener ugc nofollow" target="_blank"><em class="mg">GitHub</em></a><em class="mg">repo。</em></p></div><div class="ab cl mh mi hu mj" role="separator"><span class="mk bw bk ml mm mn"/><span class="mk bw bk ml mm mn"/><span class="mk bw bk ml mm"/></div><div class="ij ik il im in"><h1 id="4426" class="mo mp iq bd mq mr ms mt mu mv mw mx my jw mz jx na jz nb ka nc kc nd kd ne nf bi translated">1.插入排序</h1><p id="4dc7" class="pw-post-body-paragraph kw kx iq ky b kz ng jr lb lc nh ju le lf ni lh li lj nj ll lm ln nk lp lq lr ij bi translated">插入排序是一种简单的排序算法，其工作方式类似于您对手中扑克牌的排序。该阵列实际上被分成排序的和未排序的部分。未排序部分的值被拾取并放置在排序部分的正确位置。当问题规模很小时(因为它的开销很低)，或者当数据接近排序时(因为它是自适应的)，插入排序是快速且最适合的。</p><pre class="kg kh ki kj gt nl nm nn no aw np bi"><span id="caab" class="nq mp iq nm b gy nr ns l nt nu"><strong class="nm ir">Example:</strong> <br/>elements: 9, 6, 5, 0, 8, 2, 7, 1, 3, 4<br/>i       : 0, 1, 2, 3, 4, 5, 6, 7, 8, 9<br/>Let us loop for i = 1 (second element of the array) to 9 (last element of the array)</span><span id="1e74" class="nq mp iq nm b gy nv ns l nt nu"><em class="mg">i=1</em>. Since 6 is smaller than 9, move 9 and insert 6 before 9<br/><strong class="nm ir">6<em class="mg">,</em> 9,</strong> 5, 0, 8, 2, 7, 1, 3, 4</span><span id="ca43" class="nq mp iq nm b gy nv ns l nt nu"><em class="mg">i=2</em>. Since 5 is smaller than 6 and 9, move 5 before 6 and 9<br/><strong class="nm ir">5, 6, 9,</strong> 0, 8, 2, 7, 1, 3, 4</span><span id="6585" class="nq mp iq nm b gy nv ns l nt nu"><em class="mg">i=3</em>. Since 0 is smaller than 5,6 and 9, move 0 before 5,6,9<br/><strong class="nm ir">0, 5, 6, 9,</strong> 8, 2, 7, 1, 3, 4</span><span id="15f7" class="nq mp iq nm b gy nv ns l nt nu"><em class="mg">i=4</em>. Since 8 is smaller than 9, move 8 before 9<br/><strong class="nm ir">0, 5, 6, 8, 9,</strong> 2, 7, 1, 3, 4</span><span id="7250" class="nq mp iq nm b gy nv ns l nt nu"><em class="mg">i=5</em>. Since 2 is smaller than 5,6,8 and 9, move 2 before 5,6,8,9<br/><strong class="nm ir">0, 2, 5, 6, 8, 9,</strong> 7, 1, 3, 4</span><span id="b0f5" class="nq mp iq nm b gy nv ns l nt nu"><em class="mg">i=6</em>. <strong class="nm ir">0, 2, 5, 6, 7, 8, 9, </strong>1, 3, 4<br/><em class="mg">i=7</em>. <strong class="nm ir">0, 1, 2, 5, 6, 7, 8, 9, 3, 4<br/></strong><em class="mg">i=8</em>. <strong class="nm ir">0, 1, 2, 3, 5, 6, 7, 8, 9, 4<br/></strong><em class="mg">i=9</em>. <strong class="nm ir">0, 1, 2, 3, 4, 5, 6, 7, 8, 9</strong></span></pre><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nw"><img src="../Images/de5c30127eb1619c934a282d0a667e5b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*8-1rrFXeIqUpI1hzZ1V0uA.jpeg"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">插入排序</p></figure><pre class="kg kh ki kj gt nl nm nn no aw np bi"><span id="de19" class="nq mp iq nm b gy nr ns l nt nu"><strong class="nm ir">Algorithm:</strong></span><span id="169c" class="nq mp iq nm b gy nv ns l nt nu">Insertion-Sort(A)<br/>{<br/> for j=i to A.length<br/>     key = A[i];<br/>     // insert A[i] into sorted sequence A[1,2,3,..,i-1]<br/>     j= i-1;<br/>     while (j&gt;0 and A[j]&gt;key)<br/>         A[j+1] = A[j]<br/>         j= j-1<br/>     A[j+1] = key<br/>}</span></pre><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nx ny l"/></div></figure></div><div class="ab cl mh mi hu mj" role="separator"><span class="mk bw bk ml mm mn"/><span class="mk bw bk ml mm mn"/><span class="mk bw bk ml mm"/></div><div class="ij ik il im in"><h1 id="3557" class="mo mp iq bd mq mr ms mt mu mv mw mx my jw mz jx na jz nb ka nc kc nd kd ne nf bi translated">2.选择排序</h1><p id="4e5f" class="pw-post-body-paragraph kw kx iq ky b kz ng jr lb lc nh ju le lf ni lh li lj nj ll lm ln nk lp lq lr ij bi translated">选择排序算法通过从未排序的部分中重复查找最小元素(考虑升序)并将其放在开头来对数组进行排序。该算法在给定的阵列中保持两个子阵列:</p><ul class=""><li id="a364" class="ls lt iq ky b kz la lc ld lf lu lj lv ln lw lr nz ly lz ma bi translated">已经排序的子数组</li><li id="410a" class="ls lt iq ky b kz mb lc mc lf md lj me ln mf lr nz ly lz ma bi translated">未排序的剩余子数组</li></ul><p id="5b70" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在选择排序的每次迭代/传递中，从未排序的子数组中选取最小元素(考虑升序)并将其移动到排序的子数组中。选择排序具有最小化交换次数的特性。所以在对换成本较高的情况下是最佳选择。</p><pre class="kg kh ki kj gt nl nm nn no aw np bi"><span id="90a2" class="nq mp iq nm b gy nr ns l nt nu"><strong class="nm ir">Example:<br/></strong>arr[]= 23 78 45 8 32 46</span><span id="db60" class="nq mp iq nm b gy nv ns l nt nu"><strong class="nm ir"><em class="mg">Pass 1</em></strong><br/>// Find the minimum element in arr[0...5] and place it at beginning<br/>8 78 45 23 32 46</span><span id="e738" class="nq mp iq nm b gy nv ns l nt nu"><strong class="nm ir"><em class="mg">Pass 2</em></strong><br/>// Find the minimum element in arr[1...5] and place it at beginning of arr[1...5]<br/>8 23 45 78 32 46</span><span id="eedf" class="nq mp iq nm b gy nv ns l nt nu"><strong class="nm ir"><em class="mg">Pass 3</em></strong><br/>// Find the minimum element in arr[2...5] and place it at beginning of arr[2...5]<br/>8 23 32 78 45 46</span><span id="c824" class="nq mp iq nm b gy nv ns l nt nu"><strong class="nm ir"><em class="mg">Pass 4</em></strong><br/>// Find the minimum element in arr[3...5] and place it at beginning of arr[3...5]<br/>8 23 32 45 78 46</span><span id="3427" class="nq mp iq nm b gy nv ns l nt nu"><strong class="nm ir"><em class="mg">Pass 5</em></strong><br/>// Find the minimum element in arr[4...5] and place it at beginning of arr[4...5]<br/>8 23 32 45 46 78</span></pre><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi oa"><img src="../Images/acf54c6f5cc8715d49fc891b52295bde.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*j5i4kTA7yaRHcoD77kvmnw.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">选择排序</p></figure><pre class="kg kh ki kj gt nl nm nn no aw np bi"><span id="5262" class="nq mp iq nm b gy nr ns l nt nu"><strong class="nm ir">Algorithm:</strong></span><span id="bcb1" class="nq mp iq nm b gy nv ns l nt nu">void SelectionSort (int a[], int n)<br/>{<br/> int i,j, temp, min;<br/> for (i=0; i&lt;n-1; i++)<br/> {<br/>    min = i;<br/>    for (j=i+1; j&lt;n; j++)<br/>      if (a[j] &lt; a[min])<br/>      {<br/>        min = j;<br/>      }<br/>    temp = a[i];<br/>    a[i] = a[min];<br/>    a[min] = temp;<br/> }<br/>}</span></pre><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nx ny l"/></div></figure></div><div class="ab cl mh mi hu mj" role="separator"><span class="mk bw bk ml mm mn"/><span class="mk bw bk ml mm mn"/><span class="mk bw bk ml mm"/></div><div class="ij ik il im in"><h1 id="fc54" class="mo mp iq bd mq mr ms mt mu mv mw mx my jw mz jx na jz nb ka nc kc nd kd ne nf bi translated">3.冒泡排序</h1><p id="15cc" class="pw-post-body-paragraph kw kx iq ky b kz ng jr lb lc nh ju le lf ni lh li lj nj ll lm ln nk lp lq lr ij bi translated">冒泡排序是一种排序算法，如果相邻元素的顺序不对，它会重复交换相邻元素。在每次迭代或传递之后，最大的元素到达末尾(在升序的情况下)，或者最小的元素到达末尾(在降序的情况下)。重复遍历列表，直到列表被排序。该算法不适合大数据集，因为它的平均和最坏情况复杂度是ο(n^2，其中<em class="mg"> n </em>是项目的数量</p><pre class="kg kh ki kj gt nl nm nn no aw np bi"><span id="1c70" class="nq mp iq nm b gy nr ns l nt nu"><strong class="nm ir">Example:</strong><br/>64 34 25 12 22 11 90</span><span id="8189" class="nq mp iq nm b gy nv ns l nt nu"><strong class="nm ir"><em class="mg">Iteration 1:</em></strong><br/>(<strong class="nm ir">64 34</strong> 25 12 22 11 90) -&gt; (<strong class="nm ir">34 64</strong> 25 12 22 11 90), Here, algorithm compares the first two elements, and swaps since 64 &gt; 34.<br/>(34 <strong class="nm ir">64 25</strong> 12 22 11 90) -&gt; (34 <strong class="nm ir">25 64</strong> 12 22 11 90), Swap since 64 &gt; 25<br/>(34 25 <strong class="nm ir">64 12</strong> 22 11 90) -&gt; (34 25 <strong class="nm ir">12 64</strong> 22 11 90), Swap since 64 &gt; 12<br/>(34 25 12 <strong class="nm ir">64 22</strong> 11 90) -&gt; (34 25 12 <strong class="nm ir">22 64</strong> 11 90), Swap since 64 &gt; 22<br/>(34 25 12 22 <strong class="nm ir">64 11</strong> 90) -&gt; (34 25 12 22 <strong class="nm ir">11 64</strong> 90), Swap since 64 &gt; 11<br/>(34 25 12 22 11 <strong class="nm ir">64 90</strong>) -&gt; (34 25 12 22 11 <strong class="nm ir">64 90</strong>), Now, since these elements are already in order (90 &gt; 64), algorithm does not swap them.</span><span id="a64d" class="nq mp iq nm b gy nv ns l nt nu"><strong class="nm ir"><em class="mg">Iteration 2:</em></strong><br/>(<strong class="nm ir">34 25</strong> 12 22 11 64 90) -&gt; (<strong class="nm ir">25 34</strong> 12 22 11 64 90), Swap since 34 &gt; 25<br/>(25 <strong class="nm ir">34 12</strong> 22 11 64 90) -&gt; (25 <strong class="nm ir">12 34</strong> 22 11 64 90), Swap since 34 &gt; 12<br/>(25 12 <strong class="nm ir">34 22</strong> 11 64 90) -&gt; (25 12 <strong class="nm ir">22 34</strong> 11 64 90), Swap since 34 &gt; 22<br/>(25 12 22 <strong class="nm ir">34 11</strong> 64 90) -&gt; (25 12 22 <strong class="nm ir">11 34 </strong>64 90), Swap since 34 &gt; 11<br/>(25 12 22 11 <strong class="nm ir">34 64</strong> 90) -&gt; (25 12 22 11 <strong class="nm ir">34 64</strong> 90), Now, since these elements are already in order (64 &gt; 34), algorithm does not swap them.</span><span id="ddc7" class="nq mp iq nm b gy nv ns l nt nu"><strong class="nm ir"><em class="mg">Iteration 3:<br/></em></strong>(<strong class="nm ir">25 12</strong> 22 11 34 64 90) -&gt; (<strong class="nm ir">12 25</strong> 22 11 34 64 90), Swap since 25 &gt; 12<br/>(12 <strong class="nm ir">25 22</strong> 11 34 64 90) -&gt; (12 <strong class="nm ir">22 25</strong> 11 34 64 90), Swap since 25 &gt; 22<br/>(12 22 <strong class="nm ir">25 11</strong> 34 64 90) -&gt; (12 22 <strong class="nm ir">11 25</strong> 34 64 90), Swap since 25 &gt; 11<br/>(12 22 11 <strong class="nm ir">25 34 </strong>64 90) -&gt; (12 22 11 <strong class="nm ir">25 34</strong> 64 90), Now, since these elements are already in order (34 &gt; 25), algorithm does not swap them.</span><span id="6db8" class="nq mp iq nm b gy nv ns l nt nu"><strong class="nm ir"><em class="mg">Iteration 4:<br/></em></strong>(<strong class="nm ir">12 22</strong> 11 25 34 64 90) -&gt; (<strong class="nm ir">12 22</strong> 11 25 34 64 90)<br/>(12 <strong class="nm ir">22 11 </strong>25 34 64 90) -&gt; (12 <strong class="nm ir">11 22</strong> 25 34 64 90), Swap since 22 &gt; 11<br/>(12 11 <strong class="nm ir">22 25</strong> 34 64 90) -&gt; (12 11 <strong class="nm ir">22 25</strong> 34 64 90)</span><span id="2d82" class="nq mp iq nm b gy nv ns l nt nu"><strong class="nm ir"><em class="mg">Iteration 5:<br/></em></strong>(<strong class="nm ir">12 11</strong> 22 25 34 64 90) -&gt; (<strong class="nm ir">11 12</strong> 22 25 34 64 90), Swap since 12 &gt; 11<br/>(11 <strong class="nm ir">12 22</strong> 25 34 64 90) -&gt; (11 <strong class="nm ir">12 22</strong> 25 34 64 90)</span><span id="5a97" class="nq mp iq nm b gy nv ns l nt nu"><strong class="nm ir"><em class="mg">Iteration 6:<br/></em></strong>(<strong class="nm ir">11 12</strong> 22 25 34 64 90) -&gt; (<strong class="nm ir">11 12</strong> 22 25 34 64 90)</span><span id="5b64" class="nq mp iq nm b gy nv ns l nt nu">Now, the array is already sorted, but our algorithm does not know if it is completed. The algorithm needs one <strong class="nm ir">whole</strong> pass without <strong class="nm ir">any</strong> swap to know it is sorted.<br/><strong class="nm ir"><em class="mg">Iteration 7:</em></strong><br/>(<strong class="nm ir">11 12</strong> 22 25 34 64 90) -&gt; (<strong class="nm ir">11 12</strong> 22 25 34 64 90)<br/>(11 <strong class="nm ir">12 22</strong> 25 34 64 90) -&gt; (11 <strong class="nm ir">12 22</strong> 25 34 64 90)<br/>(11 12 <strong class="nm ir">22 25</strong> 34 64 90) -&gt; (11 12 <strong class="nm ir">22 25 </strong>34 64 90)<br/>(11 12 22 <strong class="nm ir">25 34</strong> 64 90) -&gt; (11 12 22 <strong class="nm ir">25 34</strong> 64 90)<br/>(11 12 22 25 <strong class="nm ir">34 64</strong> 90) -&gt; (11 12 22 25 <strong class="nm ir">34 64</strong> 90)<br/>(11 12 22 25 34 <strong class="nm ir">64 90</strong>) -&gt; (11 12 22 25 34 <strong class="nm ir">64 90</strong>)</span></pre><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi ob"><img src="../Images/fb8573cb1d5b4eb8de6fade5ce89ffe4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*2TK2jLCnEIaxwhPbDT0TNw.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">冒泡排序</p></figure><pre class="kg kh ki kj gt nl nm nn no aw np bi"><span id="baca" class="nq mp iq nm b gy nr ns l nt nu"><strong class="nm ir">Algorithm:</strong></span><span id="0e3b" class="nq mp iq nm b gy nv ns l nt nu">Bubble_Sort(int a[], n) <br/>{<br/> int swapped, i, j;<br/> for (i=0; i&lt;n; i++)<br/> {<br/>   swapped = 0;<br/>   for (j=0; j&lt;n-i-1; j++)<br/>   {<br/>     if (a[j] &gt; a[j+1])<br/>     {<br/>       swap (a[j], a[j+1]);<br/>       swapped = 1;<br/>     }<br/>   }<br/>   if (swapped == 0)<br/>     break;<br/> }<br/>}</span></pre><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nx ny l"/></div></figure></div><div class="ab cl mh mi hu mj" role="separator"><span class="mk bw bk ml mm mn"/><span class="mk bw bk ml mm mn"/><span class="mk bw bk ml mm"/></div><div class="ij ik il im in"><h1 id="5d2a" class="mo mp iq bd mq mr ms mt mu mv mw mx my jw mz jx na jz nb ka nc kc nd kd ne nf bi translated">4.合并排序</h1><p id="26af" class="pw-post-body-paragraph kw kx iq ky b kz ng jr lb lc nh ju le lf ni lh li lj nj ll lm ln nk lp lq lr ij bi translated">与上述三种排序算法不同，该算法基于分治技术。它将输入数组分成两半，为这两半调用自身，然后合并排序后的两半。合并排序的核心是<code class="fe oc od oe nm b">merge()</code> <strong class="ky ir"> </strong>函数，用于合并两半。merge(A，p，q，r)是一个关键过程，它假设A[p..q]和A[q+1..r]被排序并将两个排序的子数组合并成一个。</p><p id="edc8" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">当你需要一个稳定的O(N log N)排序时，合并排序是唯一的选择。</p><h2 id="44a3" class="nq mp iq bd mq of og dn mu oh oi dp my lf oj ok na lj ol om nc ln on oo ne op bi translated">merge()函数</h2><p id="8116" class="pw-post-body-paragraph kw kx iq ky b kz ng jr lb lc nh ju le lf ni lh li lj nj ll lm ln nk lp lq lr ij bi translated">合并过程也称为错位过程</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi oq"><img src="../Images/79d2415e396908dabfa69b6b2f7a8957.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*w6I_G9c6RFr0nvTfqA5pfw.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">merge()函数</p></figure><pre class="kg kh ki kj gt nl nm nn no aw np bi"><span id="719d" class="nq mp iq nm b gy nr ns l nt nu"><strong class="nm ir">Algorithm:</strong></span><span id="118c" class="nq mp iq nm b gy nv ns l nt nu">merge(A, p, q, r)<br/>{<br/>  n1= q-p+1<br/>  n2= r-q<br/>  Let L[1:n+1] and R[1:n2+1] be new arrays<br/>  for (i=1:n1)<br/>    L[i]= A[p+i-1]<br/>  for (j=1:n2)<br/>    R[j]= A[q+j]<br/>  L[n1 + 1]= infinity<br/>  R[n2 + 1]= infinity<br/>  i=1, j=1<br/>  for (k=p:r)<br/>  {<br/>    if (L[i] &lt;= R[j])<br/>      A[k] = L[i]<br/>      i= i+1<br/>    else<br/>      A[k] = R[j]<br/>      j= j+1<br/>  }<br/>}<br/></span></pre><h2 id="27b0" class="nq mp iq bd mq of og dn mu oh oi dp my lf oj ok na lj ol om nc ln on oo ne op bi translated">合并排序:</h2><p id="8910" class="pw-post-body-paragraph kw kx iq ky b kz ng jr lb lc nh ju le lf ni lh li lj nj ll lm ln nk lp lq lr ij bi translated">整个合并排序的工作方式如下:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi or"><img src="../Images/2eb1cf1f2b7e37b0c78614bbb7911202.png" data-original-src="https://miro.medium.com/v2/resize:fit:1232/format:webp/1*4i98eW-hKzYbCT2AZGpw-w.png"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">合并排序</p></figure><pre class="kg kh ki kj gt nl nm nn no aw np bi"><span id="5509" class="nq mp iq nm b gy nr ns l nt nu"><strong class="nm ir">Algorithm:</strong></span><span id="d3ac" class="nq mp iq nm b gy nv ns l nt nu">Merge_Sort(A, p ,r)<br/>{<br/>  if p&lt;r<br/>    q= [(p+r)/2]<br/>    Merge_Sort(A, p ,q)<br/>    Merge_Sort(A, q+1, r)<br/>    merge(A, p, q, r)<br/>}</span></pre><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nx ny l"/></div></figure></div><div class="ab cl mh mi hu mj" role="separator"><span class="mk bw bk ml mm mn"/><span class="mk bw bk ml mm mn"/><span class="mk bw bk ml mm"/></div><div class="ij ik il im in"><h1 id="b323" class="mo mp iq bd mq mr ms mt mu mv mw mx my jw mz jx na jz nb ka nc kc nd kd ne nf bi translated">5.快速排序</h1><p id="714a" class="pw-post-body-paragraph kw kx iq ky b kz ng jr lb lc nh ju le lf ni lh li lj nj ll lm ln nk lp lq lr ij bi translated">快速排序也是一种分治算法。它选取一个元素作为轴心，并围绕所选取的轴心对给定的数组进行分区，使得所有较小的元素都位于轴心的左侧，而所有较大的元素都位于轴心的右侧。有许多不同版本的quickSort以不同的方式选择pivot:</p><ul class=""><li id="a9ad" class="ls lt iq ky b kz la lc ld lf lu lj lv ln lw lr nz ly lz ma bi translated">总是选择第一个元素作为轴心。</li><li id="07df" class="ls lt iq ky b kz mb lc mc lf md lj me ln mf lr nz ly lz ma bi translated">总是选择最后一个元素作为轴心(在下面实现)。</li><li id="5640" class="ls lt iq ky b kz mb lc mc lf md lj me ln mf lr nz ly lz ma bi translated">选择一个随机元素作为轴心。</li><li id="d2d1" class="ls lt iq ky b kz mb lc mc lf md lj me ln mf lr nz ly lz ma bi translated">选择中间值作为支点。</li></ul><p id="c441" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">快速排序的关键过程是<code class="fe oc od oe nm b">partition()</code>方法。分区的目标是，给定一个数组和数组中的一个元素r作为支点，将<em class="mg"> r </em>放在一个排序数组中的正确位置，并将所有较小的元素(小于<em class="mg"> r </em>)放在<em class="mg"> r </em>之前，将所有较大的元素(大于<em class="mg"> r </em>)放在<em class="mg"> r </em>之后。所有这些都应该在线性时间内完成。</p><p id="c120" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">对于小输入，与合并排序相比，快速排序是最好的算法。当你不需要一个稳定的排序，并且一般情况下的性能比最差情况下的性能更重要时，就选择快速排序。先来看划分算法及其实现。</p><h2 id="8c2e" class="nq mp iq bd mq of og dn mu oh oi dp my lf oj ok na lj ol om nc ln on oo ne op bi translated">partition()算法</h2><p id="5011" class="pw-post-body-paragraph kw kx iq ky b kz ng jr lb lc nh ju le lf ni lh li lj nj ll lm ln nk lp lq lr ij bi translated">我们从最右边的元素开始，跟踪更小(或等于)元素的索引，记为<em class="mg"> r </em>。</p><ul class=""><li id="0497" class="ls lt iq ky b kz la lc ld lf lu lj lv ln lw lr nz ly lz ma bi translated">如果我们发现一个元素<em class="mg"> j </em>小于<em class="mg"> r </em>，那么我们增加<em class="mg"> i </em>指针并交换I和j的元素</li><li id="dcdd" class="ls lt iq ky b kz mb lc mc lf md lj me ln mf lr nz ly lz ma bi translated">如果我们发现一个元素<em class="mg"> j </em>大于<em class="mg"> r </em>，那么我们简单地增加<em class="mg"> j </em>指针。</li></ul><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi os"><img src="../Images/5756a75536585432aaeed59d9b9892a0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*GF0dkCa5EiymDbrEHeKUPg.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">快速排序</p></figure><pre class="kg kh ki kj gt nl nm nn no aw np bi"><span id="223b" class="nq mp iq nm b gy nr ns l nt nu"><strong class="nm ir">Algorithm:</strong></span><span id="4f3d" class="nq mp iq nm b gy nv ns l nt nu">partition(A, p, r)<br/>{<br/> x= A[r]<br/>  i= p-1<br/>  for (j= p:r-1)<br/>  {<br/>   if (A[j] &lt;= x)<br/>    {<br/>     i= i+1<br/>     exchange A[i] with A[j]<br/>    }<br/>  } <br/>  exchange A[i+1] with A[r]<br/>  return i+1  <br/>}</span></pre><h2 id="4c67" class="nq mp iq bd mq of og dn mu oh oi dp my lf oj ok na lj ol om nc ln on oo ne op bi translated">快速分类</h2><p id="b2b8" class="pw-post-body-paragraph kw kx iq ky b kz ng jr lb lc nh ju le lf ni lh li lj nj ll lm ln nk lp lq lr ij bi translated">整个快速排序的工作方式如下:</p><ul class=""><li id="bbc6" class="ls lt iq ky b kz la lc ld lf lu lj lv ln lw lr nz ly lz ma bi translated">它检查条件<em class="mg">p</em>T14】T8】r。如果为真，则进入If循环，否则退出循环</li><li id="99b6" class="ls lt iq ky b kz mb lc mc lf md lj me ln mf lr nz ly lz ma bi translated">然后，应用划分算法，以便选择枢轴元素并将其放在正确的位置。</li><li id="ecf1" class="ls lt iq ky b kz mb lc mc lf md lj me ln mf lr nz ly lz ma bi translated">在分区算法之后，整个数组被分成两半，这样，所有比pivot元素小的元素都在它的左边，所有比pivot元素大的元素都在它的右边。</li><li id="f303" class="ls lt iq ky b kz mb lc mc lf md lj me ln mf lr nz ly lz ma bi translated">快速排序应用于两半。</li><li id="97d3" class="ls lt iq ky b kz mb lc mc lf md lj me ln mf lr nz ly lz ma bi translated">整个循环继续将数组分成两部分，直到我们找到一个元素，使得<em class="mg"> p </em> &gt; <em class="mg"> r </em>。</li></ul><pre class="kg kh ki kj gt nl nm nn no aw np bi"><span id="6c56" class="nq mp iq nm b gy nr ns l nt nu"><strong class="nm ir">Algorithm:</strong></span><span id="a277" class="nq mp iq nm b gy nv ns l nt nu">Quick_Sort(A, p ,r)<br/>{<br/>  if (p&lt;r)<br/>  {<br/>    q= partition(A, p, r)<br/>    Quick_Sort(A, p, q-1)<br/>    Quick_Sort(A, q+1, r)<br/>  }<br/>}</span></pre><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi ot"><img src="../Images/e433f996d7952564d5ec77880a492f19.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*iAYdxq5ZEtEJbQhXSFAUmg.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">快速排序</p></figure><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nx ny l"/></div></figure></div></div>    
</body>
</html>