<html>
<head>
<title>How to Create Reusable SwiftUI Previews That Can Be Saved As JSON Files</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何创建可以保存为JSON文件的可重用SwiftUI预览</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/how-to-create-reusable-swiftui-previews-that-can-be-saved-as-json-files-2ca7b42c9ac6?source=collection_archive---------11-----------------------#2020-05-19">https://betterprogramming.pub/how-to-create-reusable-swiftui-previews-that-can-be-saved-as-json-files-2ca7b42c9ac6?source=collection_archive---------11-----------------------#2020-05-19</a></blockquote><div><div class="fc ii ij ik il im"/><div class="in io ip iq ir"><div class=""/><div class=""><h2 id="180e" class="pw-subtitle-paragraph jr it iu bd b js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki dk translated">为每个预览或所有预览设置亮或暗模式。选择任何设备或自定义尺寸。用一个修改器加载它们</h2></div><figure class="kk kl km kn gu ko gi gj paragraph-image"><div role="button" tabindex="0" class="kp kq di kr bf ks"><div class="gi gj kj"><img src="../Images/23b4e0cad72f201f6c3f846d40cee449.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*Z5WLTcWDIbUyKAVF"/></div></div><p class="kv kw gk gi gj kx ky bd b be z dk translated">查尔斯·德鲁维奥在<a class="ae kz" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片。</p></figure><p id="5271" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">SwiftUI预览提供了查看您的UI的唯一方式，而无需在模拟器或设备上构建和运行它。的确，故事板允许你看到你的约束如何布置子视图，但是你不能同时运行Swift代码。使用SwiftUI预览，您看到的是应用程序屏幕的完全初始化版本，该屏幕甚至不需要使用SwiftUI制作。</p><p id="7dec" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">NSHipster为UIKit 提供了一个使用SwiftUI预览的指南<a class="ae kz" href="https://nshipster.com/swiftui-previews/" rel="noopener ugc nofollow" target="_blank">,这使得查看基于故事板或以编程方式创建的<code class="fe lw lx ly lz b">UIViewControllers</code>和<code class="fe lw lx ly lz b">UIViews</code>的实时版本变得很容易。</a></p><p id="e3d7" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">SwiftUI预览很容易创建。文件中符合PreviewProvider协议的任何结构都将显示在画布中。可以通过按下option、command和enter键来显示或隐藏画布(⌥⌘↩).他们可以预览任何内容，包括甚至不在同一个文件中的视图。这意味着您可以在更广泛的上下文中查看视图，比如在它所属的<code class="fe lw lx ly lz b">List</code>中看到一个<code class="fe lw lx ly lz b">List</code>行，其中包含从本地JSON文件加载的虚拟数据。</p><p id="5075" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">我对使SwiftUI预览更容易创建和使用的方法很感兴趣。虽然我目前不能修改预览的外观，但有足够多的选项，添加你想要的东西可能会花费更多的时间。如果你一次创建多个预览，它们必须在一个<code class="fe lw lx ly lz b">Group</code>中，因为像任何返回<code class="fe lw lx ly lz b">some View</code>的东西一样，<code class="fe lw lx ly lz b">previews</code>静态属性必须返回单一类型的单个值。</p><p id="49fa" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">最近，我一直在创建四个预览。一个是iPhone 8，这是最后一款没有摄像头凹槽的iPhone——至少在最近(几乎相同)的iPhone SE 宣布之前是如此。一种是针对有凹口的iPhone，通常是iPhone 11的型号之一。最后两个是iPad，可能是12.9英寸的型号，也是在你考虑iPad Mini之前存在的三个较小尺寸之一。</p></div><div class="ab cl ma mb hy mc" role="separator"><span class="md bw bk me mf mg"/><span class="md bw bk me mf mg"/><span class="md bw bk me mf"/></div><div class="in io ip iq ir"><h1 id="8365" class="mh mi iu bd mj mk ml mm mn mo mp mq mr ka ms kb mt kd mu ke mv kg mw kh mx my bi translated">目前需要做多少工作</h1><figure class="kk kl km kn gu ko"><div class="bz fq l di"><div class="mz na l"/></div><p class="kv kw gk gi gj kx ky bd b be z dk translated">默认情况下，创建四个预览需要更多的工作。</p></figure><p id="483f" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">虽然我可能不需要为每个预览设置配色方案和显示名称，但是很容易看出这已经很复杂了，而且只有四个预览。如果我想在其他地方重用这个配置，我基本上需要将所有这些修饰符复制并粘贴到其他文件中。另一个问题是创建<code class="fe lw lx ly lz b">PreviewDevice</code>实例需要字符串作为原始值。我首先通过创建一个将所有iOS 13设备列为常量的扩展<code class="fe lw lx ly lz b">PreviewDevice</code>来解决这个问题。</p></div><div class="ab cl ma mb hy mc" role="separator"><span class="md bw bk me mf mg"/><span class="md bw bk me mf mg"/><span class="md bw bk me mf"/></div><div class="in io ip iq ir"><h1 id="615f" class="mh mi iu bd mj mk ml mm mn mo mp mq mr ka ms kb mt kd mu ke mv kg mw kh mx my bi translated">将设备作为常量添加到预览设备</h1><figure class="kk kl km kn gu ko"><div class="bz fq l di"><div class="mz na l"/></div><p class="kv kw gk gi gj kx ky bd b be z dk translated">现在，当编写previewDevice的参数时，只需键入一个点，自动完成功能就会提示所有这些设备。</p></figure><p id="c8c5" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">在添加了所有设备的常量后，我认为用一个修改器创建多个设备的预览会很有用。如上所示，我用一个名为<code class="fe lw lx ly lz b">previewDevices(_:)</code>的函数扩展了<code class="fe lw lx ly lz b">View</code>，该函数接受一个<code class="fe lw lx ly lz b">PreviewDevices</code>数组。该函数将<code class="fe lw lx ly lz b">Views</code>放在一个<code class="fe lw lx ly lz b">Group</code>中，所以我不需要担心在预览的静态属性中意外创建多个<code class="fe lw lx ly lz b">Views</code>。你可能会注意到，我添加了一个名为<code class="fe lw lx ly lz b">previewColorScheme(_:)</code>的函数，将配色方案设置为亮或暗。使用<code class="fe lw lx ly lz b">.environment(\.colorScheme, .light)</code>修饰符可以做到这一点，但是我发现这很难记住，而且写起来有些麻烦。</p><p id="053c" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">此时，用最少的代码创建多个预览已经容易多了，但是你可能会注意到我的<code class="fe lw lx ly lz b">previewColorScheme(_:)</code>修改器现在被应用于所有四个预览。这让我想到了一种方法来保存我想要的每个预览的所有内容，或者将配置设置为常量，或者将其保存到一个文件中。在我的例子中，我两者都做了，但是可能没有必要两者都做。在<code class="fe lw lx ly lz b">View</code>扩展中，我现在有了一个名为<code class="fe lw lx ly lz b">preview(_:, _:)</code>的函数，它既可以接受我的<code class="fe lw lx ly lz b">Preview</code>结构的一个实例，也可以接受我的<code class="fe lw lx ly lz b">PreviewData</code>结构的一个实例，该实例包含一个<code class="fe lw lx ly lz b">Previews</code>数组。</p><p id="01dd" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">这两种结构都符合Codable协议，这意味着它们可以很容易地与JSON相互转换。</p></div><div class="ab cl ma mb hy mc" role="separator"><span class="md bw bk me mf mg"/><span class="md bw bk me mf mg"/><span class="md bw bk me mf"/></div><div class="in io ip iq ir"><h1 id="797a" class="mh mi iu bd mj mk ml mm mn mo mp mq mr ka ms kb mt kd mu ke mv kg mw kh mx my bi translated">保存和加载预览配置所需的一切</h1><figure class="kk kl km kn gu ko"><div class="bz fq l di"><div class="mz na l"/></div><p class="kv kw gk gi gj kx ky bd b be z dk translated">尽管这是您需要的所有代码，但是将结构和扩展移到单独的文件中会使它更简洁。</p></figure><p id="e31f" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">当您的项目中有代码时，您可能希望看到该代码可以创建的JSON。通过右键单击或按住control键单击右下角的播放按钮来调试其中一个预览。</p><figure class="kk kl km kn gu ko gi gj paragraph-image"><div role="button" tabindex="0" class="kp kq di kr bf ks"><div class="gi gj nb"><img src="../Images/5cc4055168ba85b53bd4537491dfaa09.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*dMZz0r7EvDwCfHLPCeRu9A.png"/></div></div><p class="kv kw gk gi gj kx ky bd b be z dk translated">右键或按control键单击实时预览按钮可以打印到控制台，甚至可以使用断点！</p></figure><p id="fd94" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">当我设置代码在每次加载预览时打印JSON时，您应该看到打印到控制台的<code class="fe lw lx ly lz b">PreviewData</code>实例的JSON。如果你想从一个文件加载这个JSON，从控制台复制这个JSON，在你的Xcode项目中创建一个名为<code class="fe lw lx ly lz b">previews.json</code>的<code class="fe lw lx ly lz b">empty file</code>类型的新文件，并粘贴到那里。这应该是您需要做的全部工作，因为我已经创建了一个名为<code class="fe lw lx ly lz b">previewDataFromFile</code>的静态常量，它查找具有此名称的文件。如果你给你的文件起了不同的名字，你需要相应地更新<code class="fe lw lx ly lz b">previewDataFromFile</code>。</p><p id="7cd2" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">如果一切正常，你应该能够将<code class="fe lw lx ly lz b">ContentView_Previews</code>中的修改器从<code class="fe lw lx ly lz b">.preview(previewData) </code>改为<code class="fe lw lx ly lz b">.preview(previewDataFromFile)</code>。如果预览可以重新加载而不会失败，那么您已经成功加载了该文件。您看到的内容不会有任何变化，因为文件包含的数据与您之前预览的数据相同。然而，基于文件的方法的一个缺点是缺少实时更新。您可以修改JSON文件，但是您的更改不会反映在预览中，直到您对SwiftUI代码进行其他更改。</p><p id="f826" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">可以把JSON文件看作是存储配置的一种更持久的方式。</p></div><div class="ab cl ma mb hy mc" role="separator"><span class="md bw bk me mf mg"/><span class="md bw bk me mf mg"/><span class="md bw bk me mf"/></div><div class="in io ip iq ir"><h1 id="8820" class="mh mi iu bd mj mk ml mm mn mo mp mq mr ka ms kb mt kd mu ke mv kg mw kh mx my bi translated">后续步骤</h1><p id="d059" class="pw-post-body-paragraph la lb iu lc b ld nc jv lf lg nd jy li lj ne ll lm ln nf lp lq lr ng lt lu lv in bi translated">虽然我没有在这里介绍它，但是如果您想与他人共享配置，可以从URL响应中检索这些JSON文件。</p><p id="57ea" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">有可能将文件解析为<code class="fe lw lx ly lz b">[PreviewData].self</code>，这意味着在一个文件中可以有一组配置。这需要你将这个数组保存为一个对象，甚至可能保存为一个<code class="fe lw lx ly lz b">PreviewDevice</code>类的静态常量。这将允许您使用类似于<code class="fe lw lx ly lz b">.preview(PreviewDevice.arrayFromFile[0])</code>的修饰符来传递数组中的第一个<code class="fe lw lx ly lz b">PreviewData</code>。</p></div></div>    
</body>
</html>