# 使用工作流处理分布式事务

> 原文：<https://betterprogramming.pub/use-workflow-to-handle-distributed-transactions-6152605796e7>

![](img/97c7b797b9d4027e5f50e116e110beff.png)

照片由[马库斯·斯皮斯克](https://unsplash.com/@markusspiske?utm_source=medium&utm_medium=referral)在 [Unsplash](https://unsplash.com?utm_source=medium&utm_medium=referral) 拍摄

在微服务领域，一个事务现在被分配给多个服务，这些服务被依次调用以完成整个事务。

随着微服务架构的出现，我们正在失去数据库的酸性。事务现在可以跨越多个微服务，因此也可以跨越多个数据库。

为了解决分布式事务的问题，已经描述了以下方法列表:

*   两阶段提交/ XA
*   最终一致性和补偿/传奇
*   尝试、确认、取消/ TCC

在经典解决方案中，开发人员应该选择三种模式中的一种来处理分布式事务。

但是在这篇文章中，我们介绍了 github.com/dtm-labs/dtm[中的工作流模式。在这种模式下，XA、SAGA 和 TCC 的混合可以应用于单个分布式事务中的不同分支，也可以使用 HTTP、gRPC 和本地操作的混合，允许用户自定义分布式事务的大部分内容，提供了很大的灵活性。](https://github.com/dtm-labs/dtm)

# 工作流示例

在 DTM 的工作流模式中，HTTP 和 gRPC 协议都可以使用。以下是 gRPC 协议的示例，该协议分为以下步骤:

*   初始化 SDK
*   注册工作流
*   执行工作流

完整示例可在此处找到[工作流-grpc](https://github.com/dtm-labs/quick-start-sample/blob/main/workflow-grpc/README.md)

# 初始化 SDK

首先，在使用 SDK 之前，您需要初始化它的工作流。

# 注册工作流

然后你需要注册工作流的处理函数。以下是进行跨行转账的 saga 工作流程:

*   这个注册操作需要在业务服务启动后执行，因为当流程崩溃时，dtm 将回调业务服务器以继续未完成的任务
*   上面的代码`NewBranch`将创建一个事务分支，它将包括一个转发动作和一个全局事务提交/回滚的回调
*   `OnRollback/OnCommit`将为当前事务分支注册全局事务回滚/提交回调。在上面的代码中，只指定了`OnRollback`，所以它处于传奇模式
*   上面代码中的`busi.BusiCli`需要添加一个工作流拦截器，它将自动记录对 dtm 的 rpc 请求的结果，如下所示

当然，您可以将`workflow.Interceptor`添加到所有 gRPC 客户端，这个中间件将只处理`wf.Context`和`wf.NewBranchContext()`下的请求

*   当工作流函数返回 nil/ErrFailure 时，全局事务进入 Commit/Rollbasck 阶段，以相反的顺序调用函数内部注册在 OnCommit/OnRollback 中的操作

# 执行工作流

最后，执行工作流。

*   当执行结果为`nil/ErrFailure`时，全局事务成功/回滚。
*   当执行的结果为其他值时，dtm 服务器将随后回调此工作流任务以重试

# 工作流原理

工作流如何保证分布式事务中的数据一致性？当一个业务流程出现崩溃或其他问题时，dtm 服务器会发现这个工作流全局事务已经超时并且没有完成。然后，dtm 服务器将使用指数撤退算法，并重试工作流事务。当工作流重试请求到达业务服务时，SDK 将从 dtm 服务器查询全局事务的进度。

对于已完成的分支，它将获取先前保存的结果，并通过一个拦截器(如 gRPC/HTTP)直接返回分支结果。最终，工作流将成功完成。

工作流函数需要是等幂的，即第一次调用或后续重试应该得到相同的结果。

# 工作流程中的传奇

Saga 模式的核心思想源自本文 [SAGAS](https://www.cs.cornell.edu/andru/cs711/2002fa/reading/sagas.pdf) ，即长事务被分割成由 Saga 事务协调器协调的短事务。如果每个短事务操作成功完成，则全局事务正常完成，如果一个步骤失败，则以相反的顺序一次调用一个补偿操作。

在工作流模式下，您可以在函数中直接调用函数进行操作，然后将补偿操作写入分支机构的`OnRollback`，补偿操作将被自动调用，达到 Saga 模式的效果

# 工作流下的 Tcc

Tcc 模式源自本文[分布式事务之外的生活:一个叛教者的观点](https://www.ics.uci.edu/~cs223/papers/cidr07p15.%20pdf)。他将一个大的交易分成多个较小的交易，每个交易有三个操作。

*   尝试阶段:尝试执行，完成所有业务检查，留出足够的业务资源
*   确认阶段:如果所有分支上的 Try 操作都成功，那么它将进入确认阶段，在没有任何业务检查的情况下执行事务，只使用 Try 阶段中留出的业务资源
*   取消阶段:如果所有分支中的一个尝试操作失败，我们将进入取消阶段，释放在尝试阶段保留的业务资源。

对于我们从 A 到 B 的银行间转账场景，如果使用 SAGA，并且在正向操作中调整余额，在补偿操作中反向调整余额，那么将出现以下场景。

*   a 成功扣款
*   a 看到余额减少，告诉 B
*   将金额转移到 B 失败，整个事务回滚
*   b 从未收到资金

这对 As 和 Bs 都造成了极大的困扰。这种情况在 SAGA 中是无法避免的，但 TCC 可以通过以下设计技巧来解决:

*   除了账户中的余额字段之外，引入一个`trading_balance`字段
*   试相检查账户是否冻结，检查账户`balance-trading_balance`是否充足，然后调整`trading_balance`(即因业务目的冻结的资金)
*   确认阶段，调整余额，调整`trading_balance`(即业务解冻资金)
*   取消阶段，调整`trading_balance`(即解冻业务上的资金)

在这种情况下，一旦最终用户 A 看到他们的余额被扣除，那么 B 必须能够收到资金

在工作流模式下，可以直接在函数中调用`Try`操作，然后将`Confirm`操作注册到分支中的`OnCommit`，将`Cancel`操作注册到分支中的`OnRollback`，达到`Tcc`模式的效果

# 工作流下的 XA

XA 是由 X/Open 组织提出的分布式事务规范。XA 规范本质上定义了(全局)事务管理器(TM)和(本地)资源管理器(RM)之间的接口。MySQL 等本地数据库在 XA 中扮演 tse RM 角色。

XA 分为两个阶段。

*   阶段 1(准备):所有参与者 RM 准备执行事务并锁定所需的资源。当参与者准备好时，他们向 TM 报告他们准备好了。
*   阶段 2(提交/回滚):当事务管理器(TM)确认所有参与者(rms)准备就绪时，它向所有参与者发送一个提交命令。

目前，所有主流数据库都支持 XA 事务，包括 MySQL、Oracle、sqlserver 和 postgres

在工作流模式下，您可以调用工作流函数中的`NewBranch().DoXa`来打开您的 XA 事务分支。

# 混合多种模式

在工作流模式中，如上所述，Saga、Tcc 和 XA 都是分支事务的模式。因此，您可以对一些分支使用一种模式，对其他分支使用另一种模式。这种混合模式所提供的灵活性允许根据分支事务的特征来选择子模式，因此建议如下。

*   XA:如果业务没有行锁争用，全局事务不会持续很久，可以使用 XA。这种模式需要较少的额外开发，并且`Commit/Rollback`是由数据库自动完成的。例如，这种模式适用于订单创建业务，其中不同的订单锁定不同的订单行，并且对彼此之间的并发性没有影响。不适合用于扣除库存，因为涉及同一个项目的订单都将竞争该项目的行锁，这将导致低并发。
*   Saga:不适合 XA 的普通业务可以使用这种模式。这种模式比 Tcc 有更少的额外开发；它只需要开发正向操作和补偿操作
*   Tcc:适用于高一致性需求，比如前面描述的转移，这种模式有最多的附加开发，需要开发的操作包括`Try/Confirm/Cancel`

# 等幂要求

在工作流模式中，当崩溃发生时，会执行重试，因此需要各个操作来支持幂等性，即第一次调用的结果与下一次尝试的结果相同，返回相同的结果。

在商业中，数据库的`unique key`通常用于实现幂等，具体来说就是`insert ignore "unique-key"`。如果插入失败，则意味着该操作已经完成。这次直接无视返回。如果插入成功，说明这是第一次操作，继续后续的业务操作。

如果你的业务本身是幂等的，那么你可以直接经营你的业务。如果您的业务不提供幂等功能，那么 dtm 提供了一个`BranchBarrier` helper 类，基于上面的唯一键原则，可以很容易地帮助开发人员实现`Mysql/Mongo/Redis`的幂等操作。

请注意，下面两个是典型的非幂等运算:

*   超时回滚:如果您的业务中有一个可能需要很长时间的操作，并且您希望在等待超时返回失败后回滚您的全局事务。那么这就不是一个幂等操作，因为在两个进程同时调用该操作的极端情况下，一个返回超时失败，另一个返回成功，从而导致不同的结果。
*   达到重试限制后回滚:分析过程同上。

工作流模式目前不支持上述超时回滚和重试限制回滚。如果您有相关的场景，请将具体的场景发送给我们。我们将积极考虑是否增加这种支持。

# 分支操作结果

分支操作将返回以下结果。

*   成功:分支操作返回`HTTP-200/gRPC-nil`
*   业务失败:分支操作返回`HTTP-409/gRPC-Aborted`，不再重试，全局事务需要回滚
*   进行中:分支操作返回`HTTP-425/gRPC-FailPrecondition`。这个结果表明事务正在正常进行，并且要求 dtm 不是用指数后退算法而是用固定间隔重试来重试
*   未知错误:分支操作返回其他结果，表明存在未知错误，dtm 将使用指数后退算法重试此工作流

如果您现有的服务与上面的结果不同，那么您可以使用`workflow.Options.HTTPResp2DtmError/GRPCError2DtmError`定制这部分结果。

根据 Saga 和 Tcc 协议，Saga 的补偿操作和 Tcc 的确认/取消操作不允许返回业务失败，因为当处于工作流的第二阶段 Commit/Rollback 时，既不成功也不允许重试，那么全局事务就无法完成，所以在设计时请注意避免这种情况。

# 交易完成通知

在一些业务场景中，您希望在事务完成时得到通知，这可以通过在第一个事务分支上设置一个`OnFinish`回调来实现。当回调被调用时，所有的业务操作都已经执行，全局事务基本上已经完成。回调函数可以根据传入的`isCommit`来确定全局事务是最终提交还是回滚。

需要注意的一点是，当调用`OnFinish`回调时，事务的状态还没有被修改为 dtm 服务器上的最终状态。因此，如果您混合使用事务完成通知和查询全局事务结果，两者的结果可能不一致。建议用户仅使用这些方法中的一种，而不是混合使用。

# 结论

我们引入了一个工作流模式来支持 Saga、XA 和 Tcc 的混合使用。该模式还支持 HTTP、gRPC 和本地事务。

我们还用可运行的例子说明了工作流在 Golang 中的用法。

```
**Want to Connect?**You are welcome to visit [https://github.com/dtm-labs/dtm](https://github.com/dtm-labs/dtm)
```