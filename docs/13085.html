<html>
<head>
<title>Use Workflow to Handle Distributed Transactions</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用工作流处理分布式事务</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/use-workflow-to-handle-distributed-transactions-6152605796e7?source=collection_archive---------2-----------------------#2022-07-27">https://betterprogramming.pub/use-workflow-to-handle-distributed-transactions-6152605796e7?source=collection_archive---------2-----------------------#2022-07-27</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/97c7b797b9d4027e5f50e116e110beff.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*xICjr13SC84xPy2k"/></div></div><p class="jy jz gj gh gi ka kb bd b be z dk translated">照片由<a class="ae kc" href="https://unsplash.com/@markusspiske?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">马库斯·斯皮斯克</a>在<a class="ae kc" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>拍摄</p></figure><p id="90cd" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在微服务领域，一个事务现在被分配给多个服务，这些服务被依次调用以完成整个事务。</p><p id="47ed" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">随着微服务架构的出现，我们正在失去数据库的酸性。事务现在可以跨越多个微服务，因此也可以跨越多个数据库。</p><p id="612a" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">为了解决分布式事务的问题，已经描述了以下方法列表:</p><ul class=""><li id="757b" class="lb lc iq kf b kg kh kk kl ko ld ks le kw lf la lg lh li lj bi translated">两阶段提交/ XA</li><li id="ac06" class="lb lc iq kf b kg lk kk ll ko lm ks ln kw lo la lg lh li lj bi translated">最终一致性和补偿/传奇</li><li id="6e86" class="lb lc iq kf b kg lk kk ll ko lm ks ln kw lo la lg lh li lj bi translated">尝试、确认、取消/ TCC</li></ul><p id="b3d7" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在经典解决方案中，开发人员应该选择三种模式中的一种来处理分布式事务。</p><p id="ff63" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">但是在这篇文章中，我们介绍了github.com/dtm-labs/dtm<a class="ae kc" href="https://github.com/dtm-labs/dtm" rel="noopener ugc nofollow" target="_blank">中的工作流模式。在这种模式下，XA、SAGA和TCC的混合可以应用于单个分布式事务中的不同分支，也可以使用HTTP、gRPC和本地操作的混合，允许用户自定义分布式事务的大部分内容，提供了很大的灵活性。</a></p><h1 id="3e8e" class="lp lq iq bd lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm bi translated">工作流示例</h1><p id="fdca" class="pw-post-body-paragraph kd ke iq kf b kg mn ki kj kk mo km kn ko mp kq kr ks mq ku kv kw mr ky kz la ij bi translated">在DTM的工作流模式中，HTTP和gRPC协议都可以使用。以下是gRPC协议的示例，该协议分为以下步骤:</p><ul class=""><li id="7bfb" class="lb lc iq kf b kg kh kk kl ko ld ks le kw lf la lg lh li lj bi translated">初始化SDK</li><li id="098b" class="lb lc iq kf b kg lk kk ll ko lm ks ln kw lo la lg lh li lj bi translated">注册工作流</li><li id="41db" class="lb lc iq kf b kg lk kk ll ko lm ks ln kw lo la lg lh li lj bi translated">执行工作流</li></ul><p id="c0d9" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">完整示例可在此处找到<a class="ae kc" href="https://github.com/dtm-labs/quick-start-sample/blob/main/workflow-grpc/README.md" rel="noopener ugc nofollow" target="_blank">工作流-grpc </a></p><h1 id="a8aa" class="lp lq iq bd lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm bi translated">初始化SDK</h1><p id="f6fa" class="pw-post-body-paragraph kd ke iq kf b kg mn ki kj kk mo km kn ko mp kq kr ks mq ku kv kw mr ky kz la ij bi translated">首先，在使用SDK之前，您需要初始化它的工作流。</p><figure class="ms mt mu mv gt jr"><div class="bz fp l di"><div class="mw mx l"/></div></figure><h1 id="8eb9" class="lp lq iq bd lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm bi translated">注册工作流</h1><p id="c35d" class="pw-post-body-paragraph kd ke iq kf b kg mn ki kj kk mo km kn ko mp kq kr ks mq ku kv kw mr ky kz la ij bi translated">然后你需要注册工作流的处理函数。以下是进行跨行转账的saga工作流程:</p><figure class="ms mt mu mv gt jr"><div class="bz fp l di"><div class="mw mx l"/></div></figure><ul class=""><li id="842c" class="lb lc iq kf b kg kh kk kl ko ld ks le kw lf la lg lh li lj bi translated">这个注册操作需要在业务服务启动后执行，因为当流程崩溃时，dtm将回调业务服务器以继续未完成的任务</li><li id="aa3b" class="lb lc iq kf b kg lk kk ll ko lm ks ln kw lo la lg lh li lj bi translated">上面的代码<code class="fe my mz na nb b">NewBranch</code>将创建一个事务分支，它将包括一个转发动作和一个全局事务提交/回滚的回调</li><li id="d96b" class="lb lc iq kf b kg lk kk ll ko lm ks ln kw lo la lg lh li lj bi translated"><code class="fe my mz na nb b">OnRollback/OnCommit</code>将为当前事务分支注册全局事务回滚/提交回调。在上面的代码中，只指定了<code class="fe my mz na nb b">OnRollback</code>，所以它处于传奇模式</li><li id="08c5" class="lb lc iq kf b kg lk kk ll ko lm ks ln kw lo la lg lh li lj bi translated">上面代码中的<code class="fe my mz na nb b">busi.BusiCli</code>需要添加一个工作流拦截器，它将自动记录对dtm的rpc请求的结果，如下所示</li></ul><figure class="ms mt mu mv gt jr"><div class="bz fp l di"><div class="mw mx l"/></div></figure><p id="74f5" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">当然，您可以将<code class="fe my mz na nb b">workflow.Interceptor</code>添加到所有gRPC客户端，这个中间件将只处理<code class="fe my mz na nb b">wf.Context</code>和<code class="fe my mz na nb b">wf.NewBranchContext()</code>下的请求</p><ul class=""><li id="e506" class="lb lc iq kf b kg kh kk kl ko ld ks le kw lf la lg lh li lj bi translated">当工作流函数返回nil/ErrFailure时，全局事务进入Commit/Rollbasck阶段，以相反的顺序调用函数内部注册在OnCommit/OnRollback中的操作</li></ul><h1 id="66dd" class="lp lq iq bd lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm bi translated">执行工作流</h1><p id="8a62" class="pw-post-body-paragraph kd ke iq kf b kg mn ki kj kk mo km kn ko mp kq kr ks mq ku kv kw mr ky kz la ij bi translated">最后，执行工作流。</p><figure class="ms mt mu mv gt jr"><div class="bz fp l di"><div class="mw mx l"/></div></figure><ul class=""><li id="daa6" class="lb lc iq kf b kg kh kk kl ko ld ks le kw lf la lg lh li lj bi translated">当执行结果为<code class="fe my mz na nb b">nil/ErrFailure</code>时，全局事务成功/回滚。</li><li id="ac12" class="lb lc iq kf b kg lk kk ll ko lm ks ln kw lo la lg lh li lj bi translated">当执行的结果为其他值时，dtm服务器将随后回调此工作流任务以重试</li></ul><h1 id="bfe1" class="lp lq iq bd lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm bi translated">工作流原理</h1><p id="9e71" class="pw-post-body-paragraph kd ke iq kf b kg mn ki kj kk mo km kn ko mp kq kr ks mq ku kv kw mr ky kz la ij bi translated">工作流如何保证分布式事务中的数据一致性？当一个业务流程出现崩溃或其他问题时，dtm服务器会发现这个工作流全局事务已经超时并且没有完成。然后，dtm服务器将使用指数撤退算法，并重试工作流事务。当工作流重试请求到达业务服务时，SDK将从dtm服务器查询全局事务的进度。</p><p id="aa2e" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">对于已完成的分支，它将获取先前保存的结果，并通过一个拦截器(如gRPC/HTTP)直接返回分支结果。最终，工作流将成功完成。</p><p id="4c0c" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">工作流函数需要是等幂的，即第一次调用或后续重试应该得到相同的结果。</p><h1 id="ed0d" class="lp lq iq bd lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm bi translated">工作流程中的传奇</h1><p id="44ce" class="pw-post-body-paragraph kd ke iq kf b kg mn ki kj kk mo km kn ko mp kq kr ks mq ku kv kw mr ky kz la ij bi translated">Saga模式的核心思想源自本文<a class="ae kc" href="https://www.cs.cornell.edu/andru/cs711/2002fa/reading/sagas.pdf" rel="noopener ugc nofollow" target="_blank"> SAGAS </a>，即长事务被分割成由Saga事务协调器协调的短事务。如果每个短事务操作成功完成，则全局事务正常完成，如果一个步骤失败，则以相反的顺序一次调用一个补偿操作。</p><p id="be80" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在工作流模式下，您可以在函数中直接调用函数进行操作，然后将补偿操作写入分支机构的<code class="fe my mz na nb b">OnRollback</code>，补偿操作将被自动调用，达到Saga模式的效果</p><h1 id="5064" class="lp lq iq bd lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm bi translated">工作流下的Tcc</h1><p id="982c" class="pw-post-body-paragraph kd ke iq kf b kg mn ki kj kk mo km kn ko mp kq kr ks mq ku kv kw mr ky kz la ij bi translated">Tcc模式源自本文<a class="ae kc" href="https://www.ics.uci.edu/~cs223/papers/cidr07p15.%20pdf" rel="noopener ugc nofollow" target="_blank">分布式事务之外的生活:一个叛教者的观点</a>。他将一个大的交易分成多个较小的交易，每个交易有三个操作。</p><ul class=""><li id="6bad" class="lb lc iq kf b kg kh kk kl ko ld ks le kw lf la lg lh li lj bi translated">尝试阶段:尝试执行，完成所有业务检查，留出足够的业务资源</li><li id="a436" class="lb lc iq kf b kg lk kk ll ko lm ks ln kw lo la lg lh li lj bi translated">确认阶段:如果所有分支上的Try操作都成功，那么它将进入确认阶段，在没有任何业务检查的情况下执行事务，只使用Try阶段中留出的业务资源</li><li id="45f9" class="lb lc iq kf b kg lk kk ll ko lm ks ln kw lo la lg lh li lj bi translated">取消阶段:如果所有分支中的一个尝试操作失败，我们将进入取消阶段，释放在尝试阶段保留的业务资源。</li></ul><p id="1672" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">对于我们从A到B的银行间转账场景，如果使用SAGA，并且在正向操作中调整余额，在补偿操作中反向调整余额，那么将出现以下场景。</p><ul class=""><li id="bfc4" class="lb lc iq kf b kg kh kk kl ko ld ks le kw lf la lg lh li lj bi translated">a成功扣款</li><li id="c24d" class="lb lc iq kf b kg lk kk ll ko lm ks ln kw lo la lg lh li lj bi translated">a看到余额减少，告诉B</li><li id="ac5e" class="lb lc iq kf b kg lk kk ll ko lm ks ln kw lo la lg lh li lj bi translated">将金额转移到B失败，整个事务回滚</li><li id="c989" class="lb lc iq kf b kg lk kk ll ko lm ks ln kw lo la lg lh li lj bi translated">b从未收到资金</li></ul><p id="904b" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这对As和Bs都造成了极大的困扰。这种情况在SAGA中是无法避免的，但TCC可以通过以下设计技巧来解决:</p><ul class=""><li id="0c29" class="lb lc iq kf b kg kh kk kl ko ld ks le kw lf la lg lh li lj bi translated">除了账户中的余额字段之外，引入一个<code class="fe my mz na nb b">trading_balance</code>字段</li><li id="4044" class="lb lc iq kf b kg lk kk ll ko lm ks ln kw lo la lg lh li lj bi translated">试相检查账户是否冻结，检查账户<code class="fe my mz na nb b">balance-trading_balance</code>是否充足，然后调整<code class="fe my mz na nb b">trading_balance</code>(即因业务目的冻结的资金)</li><li id="14bc" class="lb lc iq kf b kg lk kk ll ko lm ks ln kw lo la lg lh li lj bi translated">确认阶段，调整余额，调整<code class="fe my mz na nb b">trading_balance</code>(即业务解冻资金)</li><li id="5699" class="lb lc iq kf b kg lk kk ll ko lm ks ln kw lo la lg lh li lj bi translated">取消阶段，调整<code class="fe my mz na nb b">trading_balance</code>(即解冻业务上的资金)</li></ul><p id="ed78" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在这种情况下，一旦最终用户A看到他们的余额被扣除，那么B必须能够收到资金</p><p id="f710" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在工作流模式下，可以直接在函数中调用<code class="fe my mz na nb b">Try</code>操作，然后将<code class="fe my mz na nb b">Confirm</code>操作注册到分支中的<code class="fe my mz na nb b">OnCommit</code>，将<code class="fe my mz na nb b">Cancel</code>操作注册到分支中的<code class="fe my mz na nb b">OnRollback</code>，达到<code class="fe my mz na nb b">Tcc</code>模式的效果</p><h1 id="b227" class="lp lq iq bd lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm bi translated">工作流下的XA</h1><p id="b783" class="pw-post-body-paragraph kd ke iq kf b kg mn ki kj kk mo km kn ko mp kq kr ks mq ku kv kw mr ky kz la ij bi translated">XA是由X/Open组织提出的分布式事务规范。XA规范本质上定义了(全局)事务管理器(TM)和(本地)资源管理器(RM)之间的接口。MySQL等本地数据库在XA中扮演tse RM角色。</p><p id="5269" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">XA分为两个阶段。</p><ul class=""><li id="e0e4" class="lb lc iq kf b kg kh kk kl ko ld ks le kw lf la lg lh li lj bi translated">阶段1(准备):所有参与者RM准备执行事务并锁定所需的资源。当参与者准备好时，他们向TM报告他们准备好了。</li><li id="e54b" class="lb lc iq kf b kg lk kk ll ko lm ks ln kw lo la lg lh li lj bi translated">阶段2(提交/回滚):当事务管理器(TM)确认所有参与者(rms)准备就绪时，它向所有参与者发送一个提交命令。</li></ul><p id="0b77" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">目前，所有主流数据库都支持XA事务，包括MySQL、Oracle、sqlserver和postgres</p><p id="60c9" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在工作流模式下，您可以调用工作流函数中的<code class="fe my mz na nb b">NewBranch().DoXa</code>来打开您的XA事务分支。</p><h1 id="78e8" class="lp lq iq bd lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm bi translated">混合多种模式</h1><p id="e286" class="pw-post-body-paragraph kd ke iq kf b kg mn ki kj kk mo km kn ko mp kq kr ks mq ku kv kw mr ky kz la ij bi translated">在工作流模式中，如上所述，Saga、Tcc和XA都是分支事务的模式。因此，您可以对一些分支使用一种模式，对其他分支使用另一种模式。这种混合模式所提供的灵活性允许根据分支事务的特征来选择子模式，因此建议如下。</p><ul class=""><li id="960c" class="lb lc iq kf b kg kh kk kl ko ld ks le kw lf la lg lh li lj bi translated">XA:如果业务没有行锁争用，全局事务不会持续很久，可以使用XA。这种模式需要较少的额外开发，并且<code class="fe my mz na nb b">Commit/Rollback</code>是由数据库自动完成的。例如，这种模式适用于订单创建业务，其中不同的订单锁定不同的订单行，并且对彼此之间的并发性没有影响。不适合用于扣除库存，因为涉及同一个项目的订单都将竞争该项目的行锁，这将导致低并发。</li><li id="f50e" class="lb lc iq kf b kg lk kk ll ko lm ks ln kw lo la lg lh li lj bi translated">Saga:不适合XA的普通业务可以使用这种模式。这种模式比Tcc有更少的额外开发；它只需要开发正向操作和补偿操作</li><li id="eaa8" class="lb lc iq kf b kg lk kk ll ko lm ks ln kw lo la lg lh li lj bi translated">Tcc:适用于高一致性需求，比如前面描述的转移，这种模式有最多的附加开发，需要开发的操作包括<code class="fe my mz na nb b">Try/Confirm/Cancel</code></li></ul><h1 id="8bfd" class="lp lq iq bd lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm bi translated">等幂要求</h1><p id="ca97" class="pw-post-body-paragraph kd ke iq kf b kg mn ki kj kk mo km kn ko mp kq kr ks mq ku kv kw mr ky kz la ij bi translated">在工作流模式中，当崩溃发生时，会执行重试，因此需要各个操作来支持幂等性，即第一次调用的结果与下一次尝试的结果相同，返回相同的结果。</p><p id="9649" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在商业中，数据库的<code class="fe my mz na nb b">unique key</code>通常用于实现幂等，具体来说就是<code class="fe my mz na nb b">insert ignore "unique-key"</code>。如果插入失败，则意味着该操作已经完成。这次直接无视返回。如果插入成功，说明这是第一次操作，继续后续的业务操作。</p><p id="8d09" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如果你的业务本身是幂等的，那么你可以直接经营你的业务。如果您的业务不提供幂等功能，那么dtm提供了一个<code class="fe my mz na nb b">BranchBarrier</code> helper类，基于上面的唯一键原则，可以很容易地帮助开发人员实现<code class="fe my mz na nb b">Mysql/Mongo/Redis</code>的幂等操作。</p><p id="0946" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">请注意，下面两个是典型的非幂等运算:</p><ul class=""><li id="1eda" class="lb lc iq kf b kg kh kk kl ko ld ks le kw lf la lg lh li lj bi translated">超时回滚:如果您的业务中有一个可能需要很长时间的操作，并且您希望在等待超时返回失败后回滚您的全局事务。那么这就不是一个幂等操作，因为在两个进程同时调用该操作的极端情况下，一个返回超时失败，另一个返回成功，从而导致不同的结果。</li><li id="066e" class="lb lc iq kf b kg lk kk ll ko lm ks ln kw lo la lg lh li lj bi translated">达到重试限制后回滚:分析过程同上。</li></ul><p id="85a5" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">工作流模式目前不支持上述超时回滚和重试限制回滚。如果您有相关的场景，请将具体的场景发送给我们。我们将积极考虑是否增加这种支持。</p><h1 id="c8d1" class="lp lq iq bd lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm bi translated">分支操作结果</h1><p id="d73a" class="pw-post-body-paragraph kd ke iq kf b kg mn ki kj kk mo km kn ko mp kq kr ks mq ku kv kw mr ky kz la ij bi translated">分支操作将返回以下结果。</p><ul class=""><li id="59b6" class="lb lc iq kf b kg kh kk kl ko ld ks le kw lf la lg lh li lj bi translated">成功:分支操作返回<code class="fe my mz na nb b">HTTP-200/gRPC-nil</code></li><li id="78e0" class="lb lc iq kf b kg lk kk ll ko lm ks ln kw lo la lg lh li lj bi translated">业务失败:分支操作返回<code class="fe my mz na nb b">HTTP-409/gRPC-Aborted</code>，不再重试，全局事务需要回滚</li><li id="bfcc" class="lb lc iq kf b kg lk kk ll ko lm ks ln kw lo la lg lh li lj bi translated">进行中:分支操作返回<code class="fe my mz na nb b">HTTP-425/gRPC-FailPrecondition</code>。这个结果表明事务正在正常进行，并且要求dtm不是用指数后退算法而是用固定间隔重试来重试</li><li id="6ba8" class="lb lc iq kf b kg lk kk ll ko lm ks ln kw lo la lg lh li lj bi translated">未知错误:分支操作返回其他结果，表明存在未知错误，dtm将使用指数后退算法重试此工作流</li></ul><p id="803c" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如果您现有的服务与上面的结果不同，那么您可以使用<code class="fe my mz na nb b">workflow.Options.HTTPResp2DtmError/GRPCError2DtmError</code>定制这部分结果。</p><p id="d760" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">根据Saga和Tcc协议，Saga的补偿操作和Tcc的确认/取消操作不允许返回业务失败，因为当处于工作流的第二阶段Commit/Rollback时，既不成功也不允许重试，那么全局事务就无法完成，所以在设计时请注意避免这种情况。</p><h1 id="6d85" class="lp lq iq bd lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm bi translated">交易完成通知</h1><p id="37d9" class="pw-post-body-paragraph kd ke iq kf b kg mn ki kj kk mo km kn ko mp kq kr ks mq ku kv kw mr ky kz la ij bi translated">在一些业务场景中，您希望在事务完成时得到通知，这可以通过在第一个事务分支上设置一个<code class="fe my mz na nb b">OnFinish</code>回调来实现。当回调被调用时，所有的业务操作都已经执行，全局事务基本上已经完成。回调函数可以根据传入的<code class="fe my mz na nb b">isCommit</code>来确定全局事务是最终提交还是回滚。</p><p id="e35a" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">需要注意的一点是，当调用<code class="fe my mz na nb b">OnFinish</code>回调时，事务的状态还没有被修改为dtm服务器上的最终状态。因此，如果您混合使用事务完成通知和查询全局事务结果，两者的结果可能不一致。建议用户仅使用这些方法中的一种，而不是混合使用。</p><h1 id="a165" class="lp lq iq bd lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm bi translated">结论</h1><p id="908b" class="pw-post-body-paragraph kd ke iq kf b kg mn ki kj kk mo km kn ko mp kq kr ks mq ku kv kw mr ky kz la ij bi translated">我们引入了一个工作流模式来支持Saga、XA和Tcc的混合使用。该模式还支持HTTP、gRPC和本地事务。</p><p id="c235" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们还用可运行的例子说明了工作流在Golang中的用法。</p></div><div class="ab cl nc nd hu ne" role="separator"><span class="nf bw bk ng nh ni"/><span class="nf bw bk ng nh ni"/><span class="nf bw bk ng nh"/></div><div class="ij ik il im in"><pre class="ms mt mu mv gt nj nb nk nl aw nm bi"><span id="23be" class="nn lq iq nb b gy no np l nq nr"><strong class="nb ir">Want to Connect?</strong></span><span id="ac28" class="nn lq iq nb b gy ns np l nq nr">You are welcome to visit <a class="ae kc" href="https://github.com/dtm-labs/dtm" rel="noopener ugc nofollow" target="_blank">https://github.com/dtm-labs/dtm</a></span></pre></div></div>    
</body>
</html>