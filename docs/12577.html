<html>
<head>
<title>How We Benefited From Webhooks in a Specific Use Case Scenario</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">在特定的用例场景中，我们如何从Webhooks中获益</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/how-we-benefited-from-webhooks-in-a-specific-use-case-scenario-cf9ff2f5afd3?source=collection_archive---------16-----------------------#2022-06-14">https://betterprogramming.pub/how-we-benefited-from-webhooks-in-a-specific-use-case-scenario-cf9ff2f5afd3?source=collection_archive---------16-----------------------#2022-06-14</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="a727" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">解决架构问题的快速webhook用例</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/5d682f983b4a449ced26fe823e0a9340.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*gfLoHlhErmb3lkMy"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">由<a class="ae kv" href="https://unsplash.com/@milandegraeve?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">米兰·德格雷夫</a>在<a class="ae kv" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</p></figure><p id="1b17" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">上周，我一直面临着一个具有挑战性的场景，它对我们当前的架构有着某些复杂的影响，因此使我在许多限制下工作。我试图以一种清晰的方式来描述它，并展示webhooks是如何被证明适合于实现一个工作解决方案的。</p><h1 id="8dfc" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">问题是</h1><p id="22a1" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">有一个单一的web应用程序，它使用某些实体(业务领域实体)来执行业务操作。这个web应用程序目前正在被分解为微服务，从单一架构转变为面向微服务的架构。为了实现这一点，有许多不同的微服务可以满足特定的业务领域。</p><p id="ed30" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">有一个特定的用例需要处理一批实体。处理每个实体可能只需要几毫秒或15分钟。实体的状态在处理后可能会改变，但是并不立即需要每个特定实体的处理结果，因此可以异步处理一批实体。</p><p id="9c9e" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">顺便说一下，某个实体的处理发生在特定的微服务中。为了处理实体“A”，应该向微服务发送使用“A”作为参数的请求。因此，为了处理一批N个实体，微服务应该被请求N次。</p><p id="2230" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">为了更好地描述这个场景，可以将一批实体看作是查询数据库的结果，将微服务看作是特定的业务域操作。一些有用的例子是:</p><ul class=""><li id="a800" class="mp mq iq ky b kz la lc ld lf mr lj ms ln mt lr mu mv mw mx bi translated">通过在当前工资的基础上增加5%的奖金来提高在公司工作超过10年的前100名员工的工资。</li><li id="c983" class="mp mq iq ky b kz my lc mz lf na lj nb ln nc lr mu mv mw mx bi translated">对于给定客户的每个产品，通过比较它们的名称，找到最有可能相关的产品。然后用匹配项更新<code class="fe nd ne nf ng b">related_products</code>表。</li><li id="8a92" class="mp mq iq ky b kz my lc mz lf na lj nb ln nc lr mu mv mw mx bi translated">对于社交媒体平台中的每个用户，使用某种兴趣匹配算法找到可能分享相同兴趣的其他用户。然后用匹配更新<code class="fe nd ne nf ng b">users_suggested_friends</code>表。一旦用户再次在线，就可以向用户显示这些建议。</li></ul><h1 id="b08b" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">第一种方法:发射和遗忘机制</h1><p id="da12" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">由于处理每个实体的微服务(MS)可以是异步的，所以一劳永逸的方法起初似乎不错。给定一批实体，web应用程序应该遍历所有实体，并为每个实体向MS发送请求，而不需要等待MS的任何响应。这样，MS将负责异步管理每个实体的处理。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nh"><img src="../Images/1d6dbd8e95361dbcc98be1dac9f5891e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*pG_OIXlNMRM2JX26Y3253w.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">火灾和遗忘进近的概貌</p></figure><p id="a7cb" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">MS没有任何类型的缓存机制或临时存储来存储所有进入的实体，延迟了它们的处理。话虽如此，每个到达的实体在MS中触发一个新的执行线程，完全是为了处理那个特定的实体。</p><p id="b356" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">可以想象，这种方法非常简单，但是它带来了可怕的性能问题，经历了非常高的CPU和内存使用率以及资源使用中的瓶颈。</p><h1 id="a3f5" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">第二种方法:同步阻塞机制</h1><p id="99ca" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">当我们看到问题时，我们认为web应用程序无法知道特定实体的处理何时完成，从而请求MS处理下一个实体。下面的方法试图通过采用完全同步的方法提出一个解决方案:一旦处理线程完成，对MS的每个请求都将返回一个HTTP响应。</p><p id="b64f" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这种模式包括让web应用程序等待一个实体的处理完成，然后再请求处理下一个实体。它将架构变成了单线程架构。它将CPU、内存和资源利用率降至最低，并且web应用程序现在知道MS何时完成了对实体的处理。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi ni"><img src="../Images/75b68086db2eb2084de84acc0ae60fc4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*AF_0y88mDrLyP3W_e7v9Lg.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">同步机构的概貌</p></figure><p id="6060" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">但是，我前面提到过，实体的处理可能需要15分钟或更长时间。让一个HTTP连接打开那么长时间绝对不是一个好主意。</p><h1 id="0314" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">第三种也是工作方法是使用webhook</h1><p id="b981" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">所有以前的方法都失败了，我们开始详细考虑新的解决方法。以下是我们认为应该涵盖的预期非功能性需求的列表:</p><ul class=""><li id="8389" class="mp mq iq ky b kz la lc ld lf mr lj ms ln mt lr mu mv mw mx bi translated">web应用程序应该向MS发送处理请求，而不必等待它完成。web应用程序应该完全控制请求率。</li><li id="0b03" class="mp mq iq ky b kz my lc mz lf na lj nb ln nc lr mu mv mw mx bi translated">当MS处理完一个实体时，它应该能够与web应用程序通信。</li><li id="996e" class="mp mq iq ky b kz my lc mz lf na lj nb ln nc lr mu mv mw mx bi translated">MS应该保持无状态。它不应该保存任何实体集合。</li></ul><p id="f2e1" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">一位同事建议使用webhook通过将控制权从web应用程序临时转移到MS本身来异步循环<code class="fe nd ne nf ng b">entities</code>批处理。我们立刻意识到这是一个多么棒的主意。</p><p id="03c0" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">webhook、hook或回调是一个特定的端点，充当事件侦听器的入口点。它只不过是一个端点，每次满足一组特定的条件或触发一个特定的事件时都应该调用它。在这种情况下，事件将是“实体X处理完成”，挂钩将由MS调用。</p><p id="6244" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">web应用程序将存储<code class="fe nd ne nf ng b">entities</code>批处理(例如，使用缓存机制)，并且它将只触发第一个实体的处理请求。此后，每次MS调用webhook时，web应用程序都会知道某个实体的处理已经完成。假设实体的ID是在hook请求中发送的，那么web应用程序将从批处理中删除传入的实体，并发送下一个实体的处理请求。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nj"><img src="../Images/c6002241b6eed36e2ba5b4bf5af1ccaa.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*NZV9CegUn8fuvGk-XndVyQ.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">webhook方法的概貌</p></figure><p id="165f" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">以下是使用这种有趣模式时需要考虑的一些事项:</p><ul class=""><li id="8e4b" class="mp mq iq ky b kz la lc ld lf mr lj ms ln mt lr mu mv mw mx bi translated">这种模式保证了在任何时候都只有一个实体被处理，尽管如果我们愿意的话，可以很容易地将它修改为有N个同时工作的线程。</li><li id="7dd7" class="mp mq iq ky b kz my lc mz lf na lj nb ln nc lr mu mv mw mx bi translated">我们开始只在应用程序端循环实体(只有应用程序对循环有完全的控制权)。它没有像我们预期的那样工作，我们最终使用了混合控制方法:现在有一个应用程序完全控制的第一个时刻，第二个时刻是MS负责决定何时应该继续循环。这是一个更复杂的模式，循环决策涉及两个分布式组件。</li><li id="166a" class="mp mq iq ky b kz my lc mz lf na lj nb ln nc lr mu mv mw mx bi translated">这个循环必须有一个入口点:在web应用程序中填充和存储<code class="fe nd ne nf ng b">entities</code>批处理的时刻和位置，以及发送第一个处理请求的时间。这可以在一个异步过程中完成(比如一个作业或一个脚本)，也可以在主应用程序的线程中触发。</li><li id="0219" class="mp mq iq ky b kz my lc mz lf na lj nb ln nc lr mu mv mw mx bi translated">如果MS失败或没有正确调用钩子，那么<code class="fe nd ne nf ng b">entities</code>批处理将完全保留在web应用程序端，循环将永远不会结束。因此，这种架构必须考虑容错或恢复机制。</li><li id="72de" class="mp mq iq ky b kz my lc mz lf na lj nb ln nc lr mu mv mw mx bi translated">如果一个新的<code class="fe nd ne nf ng b"> entitie</code> s批处理被设置为在已经有一个正在被处理时被处理，会发生什么？新批次是否应该覆盖现有批次？新的一批<code class="fe nd ne nf ng b">entities</code>是否应该添加到现有的一批中，以便将它们全部混合在一批中？它应该退出记录已经有一个实体批处理的消息吗？</li></ul><p id="f390" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我个人认为，这种模式非常灵活，很容易适应具有两个以上相互依赖的分布式组件的更复杂的类似场景。我喜欢我们根据自己的需要对它进行调整的方式，我希望您的开发人员工具箱中现在有了另一个有用的资源，可以用于这样的场景。</p><p id="6039" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">感谢您的阅读，并保持联系以获取更多信息！</p></div></div>    
</body>
</html>