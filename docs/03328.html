<html>
<head>
<title>Android: Understand LiveData</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Android:了解LiveData</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/everything-to-should-understand-about-livedata-507dd83adea7?source=collection_archive---------1-----------------------#2020-02-04">https://betterprogramming.pub/everything-to-should-understand-about-livedata-507dd83adea7?source=collection_archive---------1-----------------------#2020-02-04</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="3b73" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">为什么应该使用LiveData，它是什么，它是如何工作的</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/5d4aa13fbf6fcd9dee095c3a6e926fc0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*m93Glsqw5DEorYH_zeKV2A.jpeg"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">照片由<a class="ae ky" href="https://unsplash.com/@arifrw?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">阿里夫·瓦希德</a>在<a class="ae ky" href="https://unsplash.com/s/photos/data?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</p></figure><p id="97c2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如今，架构组件对于Android开发人员来说很常见。长期以来，每个人都在使用这样或那样的架构组件来满足他们的需求。LiveData是这些组件中最重要的一个。在本文中，我们将讨论LiveData、它的使用方式及其重要性。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi lv"><img src="../Images/78f574098b6569e5e909a6ba41664770.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*P1h69PXJFiuctiWDlPH4Jg.png"/></div></div></figure><h2 id="040e" class="lw lx it bd ly lz ma dn mb mc md dp me li mf mg mh lm mi mj mk lq ml mm mn mo bi translated">问题</h2><p id="966c" class="pw-post-body-paragraph kz la it lb b lc mp ju le lf mq jx lh li mr lk ll lm ms lo lp lq mt ls lt lu im bi translated">《架构组件和Rx Java》前情提要你还记得我们是如何将结果或回调传递给<code class="fe mu mv mw mx b">UI thread</code>的吗？主要是通过接口。</p><p id="2a70" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们举一个用<code class="fe mu mv mw mx b">MVP</code>开发的应用程序的简单例子。以前，如果要执行API调用，我们会从<code class="fe mu mv mw mx b">Presenter</code>中的<code class="fe mu mv mw mx b">View</code>层调用一个方法来执行网络请求。然后，在那个特定的方法中，我们用写<code class="fe mu mv mw mx b">Async task</code>来执行操作。一旦我们收到响应，我们使用一个<code class="fe mu mv mw mx b">View</code>接口将这个响应传递给<code class="fe mu mv mw mx b">Main</code>线程，这样它就可以更新UI。</p><p id="978c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这里的一切都是紧密耦合的视图和表示器，大量的接口用于层间交互。</p><h2 id="55bc" class="lw lx it bd ly lz ma dn mb mc md dp me li mf mg mh lm mi mj mk lq ml mm mn mo bi translated">解决办法</h2><p id="624e" class="pw-post-body-paragraph kz la it lb b lc mp ju le lf mq jx lh li mr lk ll lm ms lo lp lq mt ls lt lu im bi translated">这个问题的解决方案来自于<code class="fe mu mv mw mx b">MVVM</code>，但是我们不打算在这里讨论这个问题。可以说使用T8的主要问题已经被T9的概念解决了。</p></div><div class="ab cl my mz hx na" role="separator"><span class="nb bw bk nc nd ne"/><span class="nb bw bk nc nd ne"/><span class="nb bw bk nc nd"/></div><div class="im in io ip iq"><h1 id="3c9b" class="nf lx it bd ly ng nh ni mb nj nk nl me jz nm ka mh kc nn kd mk kf no kg mn np bi translated">什么是LiveData？</h1><p id="be21" class="pw-post-body-paragraph kz la it lb b lc mp ju le lf mq jx lh li mr lk ll lm ms lo lp lq mt ls lt lu im bi translated">从文档中:</p><blockquote class="nq nr ns"><p id="631b" class="kz la nt lb b lc ld ju le lf lg jx lh nu lj lk ll nv ln lo lp nw lr ls lt lu im bi translated"><strong class="lb iu"> LiveData </strong>是一个<strong class="lb iu">可观察的</strong>数据持有者类。与常规的可观察对象不同，LiveData具有生命周期意识，这意味着它尊重其他应用程序组件的生命周期，如活动、片段或服务。这种意识确保LiveData仅更新处于活动生命周期状态的应用程序组件观察者。</p></blockquote><h2 id="2264" class="lw lx it bd ly lz ma dn mb mc md dp me li mf mg mh lm mi mj mk lq ml mm mn mo bi translated">它是如何工作的？</h2><p id="f11c" class="pw-post-body-paragraph kz la it lb b lc mp ju le lf mq jx lh li mr lk ll lm ms lo lp lq mt ls lt lu im bi translated">为了理解LiveData，我们首先需要理解观察者模式。<code class="fe mu mv mw mx b">observer pattern</code>是一种软件设计模式，其中一个名为subject的对象维护一个名为observers的依赖者列表，并自动通知它们任何状态变化，通常是通过调用它们的一个方法。</p><p id="8df3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">简单来说，会有一个<code class="fe mu mv mw mx b">Observer</code>订阅<code class="fe mu mv mw mx b">Observable</code> <strong class="lb iu"> </strong>来获得最新数据的通知或者说状态改变。之前我们使用了<code class="fe mu mv mw mx b">Rx Java</code>，但是这里我们需要维护一个<code class="fe mu mv mw mx b">subscriptions</code>和<code class="fe mu mv mw mx b">onDestroy()</code>中的<code class="fe mu mv mw mx b">remove</code>的列表。</p><p id="cf6f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe mu mv mw mx b">LiveData</code>的<strong class="lb iu"> </strong>主概念是一个<code class="fe mu mv mw mx b">Observer</code>图案。<code class="fe mu mv mw mx b">LiveData</code>是一个<code class="fe mu mv mw mx b">observable</code>数据容器类——没有必要每次都请求最新的数据。使用<code class="fe mu mv mw mx b">MVVM</code>时，从<code class="fe mu mv mw mx b"><a class="ae ky" href="https://medium.com/@pavan.careers5208/everything-to-understand-about-viewmodel-400e8e637a58" rel="noopener">ViewModel</a></code>到<code class="fe mu mv mw mx b">View</code>的通信仅通过<code class="fe mu mv mw mx b">LiveData</code>完成。</p><p id="ecb5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">从<code class="fe mu mv mw mx b">View</code>活动或片段我们<code class="fe mu mv mw mx b">subscribe</code>到<code class="fe mu mv mw mx b">LiveData</code>、<strong class="lb iu">、</strong>经过<code class="fe mu mv mw mx b">lifecycle owner</code>、<strong class="lb iu">、<code class="fe mu mv mw mx b">Observer</code>。但是没有必要维护列表或销毁订阅。正如<code class="fe mu mv mw mx b">LiveData</code>是<code class="fe mu mv mw mx b">lifecycle-aware</code> <strong class="lb iu"> </strong>它负责这些事情。</strong></p><p id="32eb" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">LiveData只有在处于<code class="fe mu mv mw mx b">foreground</code>状态时才会将值提交给<code class="fe mu mv mw mx b">Observers</code>(活动或片段)，这样就不会发生内存泄漏。我们不需要检查<code class="fe mu mv mw mx b">View</code>是不是<code class="fe mu mv mw mx b">alive</code>来更新<code class="fe mu mv mw mx b">Observer</code>里面的UI。</p><p id="8503" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们不再需要担心取消订阅它<code class="fe mu mv mw mx b">onPause</code>或<code class="fe mu mv mw mx b">onDestroy</code>。此外，一旦<code class="fe mu mv mw mx b">Observer</code>恢复，它将立即被通知来自<code class="fe mu mv mw mx b">LiveData</code>的最新数据。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nx"><img src="../Images/ef06f5e4f1b987c02a2245df32be8ef6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*0-Gq8UlglxwyTh38x4O4AQ.png"/></div></div></figure><p id="3d99" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">关于<code class="fe mu mv mw mx b">LiveData</code>，我们需要了解的两件重要事情是</p><ul class=""><li id="c418" class="ny nz it lb b lc ld lf lg li oa lm ob lq oc lu od oe of og bi translated">UI控制器或视图(an <code class="fe mu mv mw mx b">Activity</code>或<code class="fe mu mv mw mx b">Fragment</code>)将在每次数据改变时得到通知，而不是每次都向<code class="fe mu mv mw mx b"><a class="ae ky" href="https://medium.com/@pavan.careers5208/everything-to-understand-about-viewmodel-400e8e637a58" rel="noopener">ViewModel</a></code>请求数据(<strong class="lb iu">总是最新数据</strong>！)</li><li id="d2c6" class="ny nz it lb b lc oh lf oi li oj lm ok lq ol lu od oe of og bi translated">LiveData是<code class="fe mu mv mw mx b">lifecycle-aware</code>，所以只有当<code class="fe mu mv mw mx b">View</code> (an <code class="fe mu mv mw mx b">Activity</code>或<code class="fe mu mv mw mx b">Fragment</code>)处于<code class="fe mu mv mw mx b">STARTED</code>或<code class="fe mu mv mw mx b">RESUMED</code>状态时，视图才会被注册以观察那些变化，只有这样LiveData才会<strong class="lb iu">发出</strong>任何项目(这样就不会再有崩溃、生命周期处理、内存泄漏和由于视图不存在而导致的<code class="fe mu mv mw mx b">NullPointerExceptions</code>！)</li></ul></div><div class="ab cl my mz hx na" role="separator"><span class="nb bw bk nc nd ne"/><span class="nb bw bk nc nd ne"/><span class="nb bw bk nc nd"/></div><div class="im in io ip iq"><h1 id="6a07" class="nf lx it bd ly ng nh ni mb nj nk nl me jz nm ka mh kc nn kd mk kf no kg mn np bi translated">让我们开始编码吧</h1><p id="419b" class="pw-post-body-paragraph kz la it lb b lc mp ju le lf mq jx lh li mr lk ll lm ms lo lp lq mt ls lt lu im bi translated">要使用<code class="fe mu mv mw mx b">LiveData</code>，我们需要采取以下步骤:</p><ul class=""><li id="5185" class="ny nz it lb b lc ld lf lg li oa lm ob lq oc lu od oe of og bi translated">在应用程序级别声明依赖关系<code class="fe mu mv mw mx b">build.gradle</code>。</li><li id="3d66" class="ny nz it lb b lc oh lf oi li oj lm ok lq ol lu od oe of og bi translated">创建一个LiveData的<code class="fe mu mv mw mx b">instance</code>来保存某种类型的数据。这通常在<a class="ae ky" href="https://medium.com/@pavan.careers5208/everything-to-understand-about-viewmodel-400e8e637a58" rel="noopener"> ViewModel </a>类中完成。</li><li id="3095" class="ny nz it lb b lc oh lf oi li oj lm ok lq ol lu od oe of og bi translated">创建一个定义了<code class="fe mu mv mw mx b"><strong class="lb iu">onChanged()</strong></code>方法的<code class="fe mu mv mw mx b">Observer</code>对象，该方法控制当LiveData对象保存的数据改变时会发生什么。您通常在UI控制器中创建一个<code class="fe mu mv mw mx b">Observer</code>对象，比如一个活动或片段。</li><li id="36b5" class="ny nz it lb b lc oh lf oi li oj lm ok lq ol lu od oe of og bi translated">使用<code class="fe mu mv mw mx b">observe()</code>方法将<code class="fe mu mv mw mx b">Observer</code>物体连接到<code class="fe mu mv mw mx b">LiveData</code>物体上。这个方法接受一个<code class="fe mu mv mw mx b">LifecycleOwner</code>对象，并将<code class="fe mu mv mw mx b">Observer</code>对象订阅给<code class="fe mu mv mw mx b">LiveData</code>对象，这样它就能得到变更通知。您通常在UI控制器中附加<code class="fe mu mv mw mx b">Observer</code>对象，比如<code class="fe mu mv mw mx b">activity</code>或<code class="fe mu mv mw mx b">fragment</code>。</li></ul><h2 id="a11a" class="lw lx it bd ly lz ma dn mb mc md dp me li mf mg mh lm mi mj mk lq ml mm mn mo bi translated">声明依赖关系</h2><pre class="kj kk kl km gt om mx on oo aw op bi"><span id="5e8a" class="lw lx it mx b gy oq or l os ot">//Java<br/>implementation "android.arch.lifecycle:extensions:1.0.0"<br/>annotationProcessor "android.arch.lifecycle:compiler:1.0.0"</span><span id="4d49" class="lw lx it mx b gy ou or l os ot">//Kotlin with AndroidX<br/>implementation 'androidx.lifecycle:lifecycle-viewmodel-ktx:2.2.0'</span></pre><h2 id="4551" class="lw lx it bd ly lz ma dn mb mc md dp me li mf mg mh lm mi mj mk lq ml mm mn mo bi translated">正在创建LiveData实例</h2><p id="3774" class="pw-post-body-paragraph kz la it lb b lc mp ju le lf mq jx lh li mr lk ll lm ms lo lp lq mt ls lt lu im bi translated">LiveData是一个包装器，可以用来保存任何类型的数据，包括实现了<code class="fe mu mv mw mx b">Collection</code>的对象，比如<code class="fe mu mv mw mx b">List</code>。一个<code class="fe mu mv mw mx b">LiveData</code>对象通常存储在一个<code class="fe mu mv mw mx b"><a class="ae ky" href="https://medium.com/@pavan.careers5208/everything-to-understand-about-viewmodel-400e8e637a58" rel="noopener">ViewModel</a></code>对象中，并使用getter方法访问。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ov ow l"/></div></figure><p id="b3d7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">最初，LiveData对象中的数据没有被设置，后来当我们调用<code class="fe mu mv mw mx b">setFirstName()</code>时，LiveData的值被更新。</p><h2 id="ba6a" class="lw lx it bd ly lz ma dn mb mc md dp me li mf mg mh lm mi mj mk lq ml mm mn mo bi translated">在UI控制器中创建LiveData的观察者</h2><p id="1b84" class="pw-post-body-paragraph kz la it lb b lc mp ju le lf mq jx lh li mr lk ll lm ms lo lp lq mt ls lt lu im bi translated">创建一个<code class="fe mu mv mw mx b">Activity</code>并观察LiveData的任何变化，如下所示</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ov ow l"/></div></figure><h2 id="7f33" class="lw lx it bd ly lz ma dn mb mc md dp me li mf mg mh lm mi mj mk lq ml mm mn mo bi translated"><strong class="ak">更新LiveData值</strong></h2><p id="04e0" class="pw-post-body-paragraph kz la it lb b lc mp ju le lf mq jx lh li mr lk ll lm ms lo lp lq mt ls lt lu im bi translated">有两种方法可以更新LiveData中的值。</p><ul class=""><li id="c49b" class="ny nz it lb b lc ld lf lg li oa lm ob lq oc lu od oe of og bi translated"><code class="fe mu mv mw mx b">setValue</code></li><li id="f467" class="ny nz it lb b lc oh lf oi li oj lm ok lq ol lu od oe of og bi translated"><code class="fe mu mv mw mx b">postValue</code></li></ul><h2 id="4de9" class="lw lx it bd ly lz ma dn mb mc md dp me li mf mg mh lm mi mj mk lq ml mm mn mo bi translated">设置值</h2><p id="c9fb" class="pw-post-body-paragraph kz la it lb b lc mp ju le lf mq jx lh li mr lk ll lm ms lo lp lq mt ls lt lu im bi translated">我们必须使用<code class="fe mu mv mw mx b">setValue(T)</code>方法从<code class="fe mu mv mw mx b">main thread</code>更新<code class="fe mu mv mw mx b">LiveData</code>对象。如果我们从后台线程使用<code class="fe mu mv mw mx b">setValue</code> <strong class="lb iu"> </strong>，那么应用程序崩溃，从<code class="fe mu mv mw mx b">WongThread</code>异常调用日志记录。</p><pre class="kj kk kl km gt om mx on oo aw op bi"><span id="2a85" class="lw lx it mx b gy oq or l os ot">_nameLiveData.<em class="nt">value </em>= "something"</span></pre><h2 id="6f06" class="lw lx it bd ly lz ma dn mb mc md dp me li mf mg mh lm mi mj mk lq ml mm mn mo bi translated"><strong class="ak">后置值</strong></h2><p id="dd28" class="pw-post-body-paragraph kz la it lb b lc mp ju le lf mq jx lh li mr lk ll lm ms lo lp lq mt ls lt lu im bi translated">如果代码在主线程之外的<code class="fe mu mv mw mx b">worker</code>线程中执行，您可以使用<code class="fe mu mv mw mx b">postValue(T)</code>方法更新<code class="fe mu mv mw mx b">LiveData</code>对象。它可以在任何线程中使用，但最好不要在主线程中使用，因为它比<code class="fe mu mv mw mx b">setValue</code>稍慢。</p><pre class="kj kk kl km gt om mx on oo aw op bi"><span id="689f" class="lw lx it mx b gy oq or l os ot">_nameLiveData.postValue("something")</span></pre><p id="3391" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><em class="nt">要更新LiveData值，请使用来自</em> <code class="fe mu mv mw mx b"><em class="nt">Main Thread</em></code> <em class="nt">的</em> <code class="fe mu mv mw mx b"><em class="nt">setValue</em></code> <em class="nt">和来自主线程之外的任何其他</em> <code class="fe mu mv mw mx b"><em class="nt">thread</em></code> <em class="nt">的</em><strong class="lb iu"><em class="nt">postValue</em></strong><em class="nt">以获得更好的性能。</em></p><h2 id="a33a" class="lw lx it bd ly lz ma dn mb mc md dp me li mf mg mh lm mi mj mk lq ml mm mn mo bi translated"><strong class="ak">用例</strong></h2><p id="7918" class="pw-post-body-paragraph kz la it lb b lc mp ju le lf mq jx lh li mr lk ll lm ms lo lp lq mt ls lt lu im bi translated">假设有一个应用程序，当用户打开一个活动并点击一个按钮时，它必须进行API调用。在用<code class="fe mu mv mw mx b">LiveData</code>得到响应后，我们将值发送到UI控制器来更新视图。在这种情况下，当API调用处于<code class="fe mu mv mw mx b">progress</code>状态时，不知何故应用程序进入了<code class="fe mu mv mw mx b">background</code>状态。你能猜到接下来会发生什么吗？UI会更新还是应用会崩溃？</p><p id="bab8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">API调用完成，<code class="fe mu mv mw mx b">LiveData</code>接收值。然而，无论是崩溃还是UI都没有更新，因为正如我们上面讨论的，LiveData是<code class="fe mu mv mw mx b">lifecycle-aware</code> <strong class="lb iu"> </strong>所以当API调用完成时，LiveData接收该值，但它不会将该值发送到UI控制器。它将等待UI控制器进入<code class="fe mu mv mw mx b">foreground</code>状态，然后LiveData立即将最新的可用值发送到UI控制器。</p></div><div class="ab cl my mz hx na" role="separator"><span class="nb bw bk nc nd ne"/><span class="nb bw bk nc nd ne"/><span class="nb bw bk nc nd"/></div><div class="im in io ip iq"><h1 id="34c2" class="nf lx it bd ly ng nh ni mb nj nk nl me jz nm ka mh kc nn kd mk kf no kg mn np bi translated">LiveData的类型</h1><p id="5e1b" class="pw-post-body-paragraph kz la it lb b lc mp ju le lf mq jx lh li mr lk ll lm ms lo lp lq mt ls lt lu im bi translated">我们可以扩展<code class="fe mu mv mw mx b">LiveData&lt;T&gt;</code> <strong class="lb iu"> </strong>并创建自己的自定义类。</p><h2 id="9f15" class="lw lx it bd ly lz ma dn mb mc md dp me li mf mg mh lm mi mj mk lq ml mm mn mo bi translated"><strong class="ak">可变数据</strong></h2><p id="350c" class="pw-post-body-paragraph kz la it lb b lc mp ju le lf mq jx lh li mr lk ll lm ms lo lp lq mt ls lt lu im bi translated">根据文件，<code class="fe mu mv mw mx b">MutableLiveData</code>的代码:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ov ow l"/></div></figure><h2 id="b6b3" class="lw lx it bd ly lz ma dn mb mc md dp me li mf mg mh lm mi mj mk lq ml mm mn mo bi translated">MediatorLiveData</h2><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ox"><img src="../Images/87a5c8fc4acbc9c1da745cdd0e613d90.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*nWh2WUDHV1MQ_bIUxsheeQ.png"/></div></div></figure><p id="c394" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们可以使用<code class="fe mu mv mw mx b">MediatorLiveData</code>将不同<code class="fe mu mv mw mx b">LiveData</code>对象的结果合并成一个。它也可以被定义为LiveData子类，可以观察其他LiveData对象并对来自它们的<code class="fe mu mv mw mx b">OnChanged</code>事件做出反应。</p><p id="efdf" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">假设我们有两个发出number类型值的LiveData对象。一个LiveData对象从特定的源发出值，另一个从不同的源发出值。我们想听听他们两个的结果，如果结果小于10，我们也想忽略第二个LiveData的结果。我们的做法如下:</p><pre class="kj kk kl km gt om mx on oo aw op bi"><span id="c44e" class="lw lx it mx b gy oq or l os ot">val mediatorLiveData: MediatorLiveData&lt;Int&gt; = MediatorLiveData()<br/>mediatorLiveData.addSource(stockLiveData1, <em class="nt">Observer</em>&lt;Int&gt; <strong class="mx iu">{ </strong>it -&gt;<br/>    mediatorLiveData.setValue(it)<br/><strong class="mx iu">}</strong>)<br/><br/>mediatorLiveData.addSource(stockLiveData1, <em class="nt">Observer</em>&lt;Int&gt; <strong class="mx iu">{ </strong>value <strong class="mx iu">-&gt;<br/>    </strong>if (value &gt; 10) {<br/>        mediatorLiveData.setValue(value)<br/>    }<br/><strong class="mx iu">}</strong>)</span></pre><h2 id="43be" class="lw lx it bd ly lz ma dn mb mc md dp me li mf mg mh lm mi mj mk lq ml mm mn mo bi translated">用例</h2><p id="0d95" class="pw-post-body-paragraph kz la it lb b lc mp ju le lf mq jx lh li mr lk ll lm ms lo lp lq mt ls lt lu im bi translated">假设我们只想将<code class="fe mu mv mw mx b">liveData</code>发出的五个值合并到<code class="fe mu mv mw mx b">MediatorLiveData</code>中。然后，在这五个值之后，我们可以停止监听<code class="fe mu mv mw mx b">liveData</code>并将其作为源移除:</p><pre class="kj kk kl km gt om mx on oo aw op bi"><span id="8891" class="lw lx it mx b gy oq or l os ot">val liveDataMerger: MediatorLiveData&lt;Int&gt; = MediatorLiveData()<br/>val liveData = MutableLiveData&lt;Int&gt;()<br/>val liveData2 = MutableLiveData&lt;Int&gt;()<br/><br/>liveDataMerger.addSource(liveData) <strong class="mx iu">{ </strong>value <strong class="mx iu">-&gt;<br/>    </strong>liveDataMerger.setValue(value)<br/><strong class="mx iu">}<br/><br/></strong>liveDataMerger.addSource(liveData2) <strong class="mx iu">{ </strong>value2<strong class="mx iu">-&gt;<br/>    </strong>var count = 1<br/>    count++<br/>    liveDataMerger.setValue(value2)<br/>    if (count &gt; 5) {<br/>        liveDataMerger.removeSource(liveData2)<br/>    }<br/><br/><strong class="mx iu">}</strong></span></pre><p id="1352" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><em class="nt">如果给定的</em> <code class="fe mu mv mw mx b"><em class="nt">LiveData</em></code> <em class="nt">已经作为源添加，但带有不同的</em> <code class="fe mu mv mw mx b"><em class="nt">Observer</em></code> <em class="nt">，那么</em> <code class="fe mu mv mw mx b"><em class="nt">IllegalArgumentException</em></code> <em class="nt">将被抛出。</em></p></div><div class="ab cl my mz hx na" role="separator"><span class="nb bw bk nc nd ne"/><span class="nb bw bk nc nd ne"/><span class="nb bw bk nc nd"/></div><div class="im in io ip iq"><h1 id="fe6d" class="nf lx it bd ly ng nh ni mb nj nk nl me jz nm ka mh kc nn kd mk kf no kg mn np bi translated">转换</h1><p id="0f1c" class="pw-post-body-paragraph kz la it lb b lc mp ju le lf mq jx lh li mr lk ll lm ms lo lp lq mt ls lt lu im bi translated"><code class="fe mu mv mw mx b">Transformations</code>类为我们提供了可以改变LiveData对象中的值的函数。目前，我们在这个类中有两个可用的函数:<code class="fe mu mv mw mx b">map</code>和<code class="fe mu mv mw mx b">switchMap</code>。</p><p id="c709" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe mu mv mw mx b">map()</code>允许您在<code class="fe mu mv mw mx b">LiveData</code>发出更改时将更改应用到每个值。<em class="nt">该方法类似于</em> <code class="fe mu mv mw mx b"><em class="nt">Rx(io.reactivex.Observable)</em></code> <em class="nt">地图操作符。该转换将在</em> <code class="fe mu mv mw mx b"><em class="nt">main</em></code> <em class="nt">线程上执行。</em>下面是文档中的一个例子，其中一个<code class="fe mu mv mw mx b">User</code>对象被映射以获得完整的名称:</p><pre class="kj kk kl km gt om mx on oo aw op bi"><span id="ab6b" class="lw lx it mx b gy oq or l os ot">LiveData&lt;User&gt; userLiveData = ...;</span><span id="271e" class="lw lx it mx b gy ou or l os ot"><em class="nt">LiveData&lt;String&gt; userFullNameLiveData =<br/> Transformations.map(userLiveData,user -&gt;<br/> user.firstName + user.lastName);<br/>});</em></span></pre><p id="cf46" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">根据文件，<code class="fe mu mv mw mx b">map</code> <strong class="lb iu"> </strong>方法代码如下:</p><pre class="kj kk kl km gt om mx on oo aw op bi"><span id="c031" class="lw lx it mx b gy oq or l os ot">@MainThread<br/>public static &lt;X, Y&gt; LiveData&lt;Y&gt; map(<br/>        @NonNull LiveData&lt;X&gt; source,<br/>        @NonNull final Function&lt;X, Y&gt; mapFunction) {<br/>    final MediatorLiveData&lt;Y&gt; result = new MediatorLiveData&lt;&gt;();<br/>    result.addSource(source, new Observer&lt;X&gt;() {<br/>        @Override<br/>        public void onChanged(@Nullable X x) {<br/>            result.setValue(mapFunction.apply(x));<br/>        }<br/>    });<br/>    return result;<br/>}</span></pre><p id="4854" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe mu mv mw mx b">switchMap</code>返回一个新的<code class="fe mu mv mw mx b">LiveData</code>对象而不是一个值，即它将实际的<code class="fe mu mv mw mx b">LiveData</code>切换为一个新的。<em class="nt">该方法类似于</em> <code class="fe mu mv mw mx b"><em class="nt">Rx(io.reactivex.Observable)</em></code> <em class="nt">开关映射操作符。</em> <code class="fe mu mv mw mx b"><em class="nt">switchMapFunction</em></code> <em class="nt">将在</em> <code class="fe mu mv mw mx b"><em class="nt">main</em></code> <em class="nt">线程上执行。</em></p><p id="c988" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">下面是一个示例类，它保存了键入的用户名，该用户名是来自<code class="fe mu mv mw mx b">MutableLiveData</code>中的<code class="fe mu mv mw mx b">EditTex</code>的字符串，并返回一个包含同名用户的用户对象列表的<code class="fe mu mv mw mx b">LiveData</code>。每次输入的名称改变时，它通过重新查询一个存储库模式对象来填充这个<code class="fe mu mv mw mx b">LiveData</code>。</p><pre class="kj kk kl km gt om mx on oo aw op bi"><span id="9c26" class="lw lx it mx b gy oq or l os ot"><em class="nt"> class UserViewModel extends AndroidViewModel {<br/>     MutableLiveData&lt;String&gt; nameQueryLiveData = ...<br/><br/>     LiveData&lt;List&lt;String&gt;&gt; getUsersWithNameLiveData() {<br/>         return Transformations.switchMap(<br/>             nameQueryLiveData,<br/>                 name -&gt; myDataSource.getUsersWithNameLiveData(name));<br/>     }<br/><br/>     void setNameQuery(String name) {<br/>         this.nameQueryLiveData.setValue(name);<br/>     }<br/> }</em></span></pre><p id="d59e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">根据文档，<code class="fe mu mv mw mx b">switchMap</code> <strong class="lb iu"> </strong>方法代码如下:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ov ow l"/></div></figure></div><div class="ab cl my mz hx na" role="separator"><span class="nb bw bk nc nd ne"/><span class="nb bw bk nc nd ne"/><span class="nb bw bk nc nd"/></div><div class="im in io ip iq"><p id="9abf" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">请给我你的建议和意见。</p><p id="0489" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">感谢阅读！</p></div></div>    
</body>
</html>