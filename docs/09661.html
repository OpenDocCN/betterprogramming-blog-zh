<html>
<head>
<title>Handling Actor Reentrancy Problem in Swift</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">在Swift中处理参与者重入问题</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/handling-actor-reentrancy-problem-in-swift-cee60557dadf?source=collection_archive---------11-----------------------#2021-09-22">https://betterprogramming.pub/handling-actor-reentrancy-problem-in-swift-cee60557dadf?source=collection_archive---------11-----------------------#2021-09-22</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="3730" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">了解如何安全运行并发Swift代码</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/d87b4a2e1ac94f197cf06b8faa399f4c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*yvYCFV2QqnvwVf5a"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">mate usz waca wek在<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</p></figure><p id="bd0d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">当我第一次看到WWDC关于演员的演示时，我对它的能力以及它将如何在不久的将来改变我们编写异步代码的方式感到兴奋。通过使用actors，编写没有数据竞争和死锁的异步代码变得前所未有的简单。</p><p id="7b26" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">除此之外，这并不意味着演员没有线程问题。如果我们不够小心，我们可能会在使用actors时意外地引入可重入性问题。</p><p id="4a58" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在本文中，我将带您了解什么是可重入性问题，为什么它会有问题，以及如何防止它发生。如果这是您第一次听说可重入性问题，一定要继续读下去，这样下次使用actors时就不会措手不及了。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="3594" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">现实生活中的银行交易示例</h1><p id="0022" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">展示可重入性问题的最佳方式是使用现实生活中的例子。考虑下面的<code class="fe mz na nb nc b">BankAccount</code> actor，它有一个<code class="fe mz na nb nc b">balance</code>变量。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nd ne l"/></div></figure><p id="f736" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">稍后，我们将为这个<code class="fe mz na nb nc b">BankAccount</code>角色提供一个取款功能，但在此之前，让我们为它提供一个私有功能，检查该帐户是否有足够的余额用于取款:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nd ne l"/></div></figure><p id="f30b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">除此之外，我们将定义另一个模拟授权过程的私有函数:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nd ne l"/></div></figure><p id="39d8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">实际上，授权过程应该是一个相当慢的过程，因此我们将使它成为一个异步函数。我们不打算实现实际的授权工作流，而是等待1秒钟，然后返回<code class="fe mz na nb nc b">true</code>来模拟交易已被授权的情况。</p><p id="0c83" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这样，我们现在可以像这样实现撤销功能:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nd ne l"/></div></figure><p id="5563" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">实现非常简单。我们将首先检查帐户余额。如果余额足够，我们将继续授权交易。</p><p id="fcbd" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">一旦我们成功授权交易，我们将从余额中扣除取款金额，表明钱已从帐户中取出。</p><p id="ff2f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">之后，让我们添加一些<code class="fe mz na nb nc b">print</code>语句来帮助我们监控整个取款过程的流程:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nd ne l"/></div></figure><p id="94e5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">下面是<code class="fe mz na nb nc b">BankAccount</code> actor的完整实现:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nd ne l"/></div></figure><h2 id="1be9" class="nf md it bd me ng nh dn mi ni nj dp mm li nk nl mo lm nm nn mq lq no np ms nq bi translated">模拟可重入问题</h2><p id="099b" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">现在，让我们考虑两次提款同时发生的情况。我们可以通过在两个独立的异步任务中触发<code class="fe mz na nb nc b">withdraw(_:)</code>函数来模拟。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nd ne l"/></div></figure><p id="68ea" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">你认为结果会是什么？</p><p id="01f9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">乍一看，你可能会认为第一次提款(800)应该通过，而第二次(500)会因为余额不足而被拒绝。不幸的是，情况并非如此。下面是我们从Xcode控制台得到的结果:</p><pre class="kj kk kl km gt nr nc ns nt aw nu bi"><span id="9ba7" class="nf md it nc b gy nv nw l nx ny">🤓 Check balance for withdrawal: 800<br/>🤓 Check balance for withdrawal: 500<br/>✅ Transaction authorized: 800<br/>💰 Account balance: 200<br/>✅ Transaction authorized: 500<br/>💰 Account balance: -300</span></pre><p id="fe93" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如您所见，两笔交易都已完成，用户能够提取的金额超过了账户余额。如果你是银行老板，你不会希望这种事情发生的！</p><p id="26fe" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在让我们仔细看看<code class="fe mz na nb nc b">withdraw(_:)</code>函数的实现，你会注意到我们目前面临的问题实际上是由以下三个原因造成的:</p><ol class=""><li id="04ff" class="nz oa it lb b lc ld lf lg li ob lm oc lq od lu oe of og oh bi translated"><code class="fe mz na nb nc b">withdraw(_:)</code>功能中存在一个暂停点，即<code class="fe mz na nb nc b">await authorizeTransaction()</code>。</li><li id="cacf" class="nz oa it lb b lc oi lf oj li ok lm ol lq om lu oe of og oh bi translated">暂停点前后第二笔交易的<code class="fe mz na nb nc b">BankAccount</code>状态(<code class="fe mz na nb nc b">balance</code>值)不同。</li><li id="ae60" class="nz oa it lb b lc oi lf oj li ok lm ol lq om lu oe of og oh bi translated"><code class="fe mz na nb nc b">withdraw(_:)</code>函数在其先前的执行完成之前被调用。</li></ol><p id="174a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">由于<code class="fe mz na nb nc b">withdraw(_:)</code>功能中的暂停点，第二笔交易的余额检查发生在第一笔交易完成之前。在此期间，账户仍然有足够的余额进行第二次交易，这就是为什么第二次交易的余额检查通过了。</p><p id="1f79" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这是一个非常典型的可重入性问题，看起来当它发生时，Swift actors不会给我们任何编译器错误。如果是这样，我们该怎么做才能防止这种情况发生？</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="0bd9" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">为可重入性设计参与者</h1><p id="2645" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">根据Apple的说法，actor reentrancy可以防止死锁并保证向前的进度。但是，它不能保证参与者的可变状态在每个await中都保持不变。</p><p id="db50" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">因此，作为开发人员，我们必须时刻注意，每次等待都是一个潜在的暂停点，而且在每次等待之后，参与者的可变状态可能会发生变化。换句话说，防止重入问题的发生是我们的责任。</p><p id="e7cd" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果是，我们有什么预防方法？</p><h2 id="0e10" class="nf md it bd me ng nh dn mi ni nj dp mm li nk nl mo lm nm nn mq lq no np ms nq bi translated">在同步代码中执行状态突变</h2><p id="d414" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">苹果工程师建议的第一种方法是总是在同步代码中改变角色状态。正如您在我们的示例中看到的，我们改变参与者状态的时间点是余额扣除发生的时间点，我们读取参与者状态的时间点是我们检查帐户余额的时间点。这两个点由一个悬挂点隔开。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi on"><img src="../Images/1dbc93bc2352e9a3a02a165b7dc09b58.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*-25PoghGUK0G-6AS9gPO5w.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">悬挂点位置</p></figure><p id="596d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">因此，为了确保余额检查和余额扣除同步运行，我们需要做的就是在执行余额检查之前授权交易。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nd ne l"/></div></figure><p id="03af" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果我们再次运行代码，我们将得到以下输出:</p><pre class="kj kk kl km gt nr nc ns nt aw nu bi"><span id="d9fc" class="nf md it nc b gy nv nw l nx ny">✅ Transaction authorized: 800<br/>🤓 Check balance for withdrawal: 800<br/>💰 Account balance: 200<br/>✅ Transaction authorized: 500<br/>🤓 Check balance for withdrawal: 500<br/>🚫 Not enough balance to withdraw: 500</span></pre><p id="c9ef" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">太好了！我们的代码现在成功地拒绝了第二个事务。但是，取款工作流程并不真正有意义。如果账户余额不足，授权交易还有什么意义？</p><p id="67dd" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果是这样的话，我们还有什么其他的选择，以便在解决可重入性问题的同时，我们可以保持原来的撤销工作流？</p><h2 id="b17b" class="nf md it bd me ng nh dn mi ni nj dp mm li nk nl mo lm nm nn mq lq no np ms nq bi translated">检查暂停点后的执行元状态</h2><p id="ff08" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">苹果工程师建议的另一种预防方法是在暂停点之后对演员状态进行检查。这可以确保我们对参与者可变状态所做的任何假设在各个暂停点上保持不变。</p><p id="c93a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">对于我们的例子，我们假设在授权过程之后账户余额是足够的。因此，为了防止重入问题，我们必须在交易被授权后再次检查账户余额。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nd ne l"/></div></figure><p id="6459" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">下面是我们从上面的<code class="fe mz na nb nc b">withdraw(_:)</code>函数中得到的结果:</p><pre class="kj kk kl km gt nr nc ns nt aw nu bi"><span id="52ca" class="nf md it nc b gy nv nw l nx ny">🤓 Check balance for withdrawal: 800<br/>🤓 Check balance for withdrawal: 500<br/>✅ Transaction authorized: 800<br/>💰 Account balance: 200<br/>✅ Transaction authorized: 500<br/>⛔️ Not enough balance to withdraw: 500 (authorized)</span></pre><p id="95df" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这样，我们成功地防止了重入问题的发生，同时保持了原来的撤销工作流。</p><p id="22c2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如您所见，没有能够防止各种可重入问题的灵丹妙药。我们需要根据我们真正需要的东西来调整我们采取的方法。</p><p id="fd24" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果你想看一个更复杂的现实生活中的重入问题，我强烈推荐<a class="ae ky" href="https://www.donnywals.com/using-swifts-async-await-to-build-an-image-loader/" rel="noopener ugc nofollow" target="_blank">这篇由<a class="ae ky" href="https://twitter.com/DonnyWals" rel="noopener ugc nofollow" target="_blank">唐尼·瓦尔斯</a>撰写的</a>文章。在文章中，您将看到他如何使用字典来防止他的图像下载器演员由于重入问题而两次下载图像。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="7d55" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">线程安全与可重入性</h1><p id="e06e" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">既然您已经了解了导致可重入性问题的原因以及我们如何防止它，那么让我们把注意力转移到线程安全和可重入性之间的区别上来。</p><p id="9379" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">众所周知，一个actor会在它自己的上下文中保证线程安全，那么为什么我们仍然会遇到可重入性问题呢？</p><p id="eee6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">根据苹果公司的说法，一个参与者将保证对其可变状态的互斥访问。这就是为什么在刚才的例子中，与<code class="fe mz na nb nc b">amount = 800</code>的交易总是先发生。如果一个actor不是线程安全的，我们就不能得到这样一致的结果。我们有时可能会得到与<code class="fe mz na nb nc b">amount = 500</code>的交易首先被触发的结果。</p><p id="df93" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">尽管可重入性问题发生在多线程环境中，但这并不意味着它是一个线程安全问题。发生可重入性问题是因为我们假设参与者的状态不会在一个暂停点上改变，而不是因为我们试图同时改变参与者的可变状态。因此，可重入性问题并不等同于线程安全问题。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="5389" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">包扎</h1><p id="7aff" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">在本文中，您已经了解到参与者可以保证线程安全，但是它不能防止可重入问题。因此，我们必须时刻注意，参与者状态可能会在一个暂停点上发生变化，我们有责任确保即使在参与者状态发生变化后，我们的代码仍然可以正确运行。</p><p id="628e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果您想试用本文中的示例代码，您可以在这里获得它<a class="ae ky" href="https://github.com/LeeKahSeng/SwiftSenpai-Swift-Concurrency" rel="noopener ugc nofollow" target="_blank">。</a></p><p id="2da9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">感谢阅读。更多关于iOS开发和Swift的文章，请务必在<a class="ae ky" href="https://twitter.com/Lee_Kah_Seng" rel="noopener ugc nofollow" target="_blank"> Twitter </a>上关注我。</p></div></div>    
</body>
</html>