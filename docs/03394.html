<html>
<head>
<title>Dev/Staging/Prod Configs in Xcode</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Xcode中的开发/暂存/生产配置</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/how-to-create-development-staging-and-production-configs-in-xcode-ec58b2cc1df4?source=collection_archive---------1-----------------------#2020-02-07">https://betterprogramming.pub/how-to-create-development-staging-and-production-configs-in-xcode-ec58b2cc1df4?source=collection_archive---------1-----------------------#2020-02-07</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><h2 id="b8e7" class="ir is it bd b dl iu iv iw ix iy iz dk ja translated" aria-label="kicker paragraph">可扩展IOS应用架构的组成部分</h2><div class=""/><div class=""><h2 id="447e" class="pw-subtitle-paragraph jz jc it bd b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq dk translated">使用。不同环境的xcconfig和config.plist文件</h2></div><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi kr"><img src="../Images/75c918e23f1dfcdef40471255c80cfd9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*g6PEXNY0zApHueATU8Ou2Q.jpeg"/></div></div><p class="ld le gj gh gi lf lg bd b be z dk translated"><a class="ae lh" href="https://unsplash.com/@hansonluu?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">汉森卢</a>在<a class="ae lh" href="https://unsplash.com/s/photos/device-environment-different?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍照</p></figure><p id="5923" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">在一个项目中，人们经常在不同的环境中开发。例如，在开发期间，所有的服务器请求都将针对<code class="fe me mf mg mh b">Dev</code>服务器，之后针对<code class="fe me mf mg mh b">Staging</code>服务器进行测试，最后针对<code class="fe me mf mg mh b">Prod</code>服务器。</p><p id="daf3" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">或者可以使用不同的测试场景，例如，在开发期间只模拟请求，并且应该在每个应用程序开始时使用准备好的测试数据填充数据库。为此，您不希望一直更改代码。😫</p><blockquote class="mi"><p id="4a7d" class="mj mk it bd ml mm mn mo mp mq mr md dk translated">使用配置文件轻松交换依赖于环境的数据。</p></blockquote><p id="c9d2" class="pw-post-body-paragraph li lj it lk b ll ms kd ln lo mt kg lq lr mu lt lu lv mv lx ly lz mw mb mc md im bi translated">这可以用不同的方法来完成。</p><p id="eb70" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">顺便说一句，谢谢你<a class="mx my ep" href="https://medium.com/u/b8653b12a7c4?source=post_page-----ec58b2cc1df4--------------------------------" rel="noopener" target="_blank">昆汀·法斯奎尔</a>用你的<a class="ae lh" href="https://medium.com/@quentinfasquel/hi-sven-korset-bb5d2960a616#--responses" rel="noopener">回复</a>推动我找到更好的解决方案！😊👍</p><p id="015d" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">顺便说一下，这是“可扩展的iOS应用架构系列的<a class="ae lh" href="https://medium.com/@sven.korset/pieces-of-a-scalable-ios-app-architecture-7c182f9dcd2c" rel="noopener">部分”中的一篇文章。</a></p></div><div class="ab cl mz na hx nb" role="separator"><span class="nc bw bk nd ne nf"/><span class="nc bw bk nd ne nf"/><span class="nc bw bk nd ne"/></div><div class="im in io ip iq"><h1 id="ed56" class="ng nh it bd ni nj nk nl nm nn no np nq ki nr kj ns kl nt km nu ko nv kp nw nx bi translated">过时的老方法</h1><p id="52ec" class="pw-post-body-paragraph li lj it lk b ll ny kd ln lo nz kg lq lr oa lt lu lv ob lx ly lz oc mb mc md im bi translated">这种方法使用不同的项目目标将适当的配置文件复制到包中。它可以工作，但是有一些缺点，稍后会谈到。因此，如果您对如何<strong class="lk jd">而不是</strong>进行配置不感兴趣，请继续阅读“新推荐方法”一节。😉</p><p id="7498" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">对于这种方法，您需要创建几个目标:一个用于正常开发、调试和测试的<strong class="lk jd">开发目标</strong>(开发)和一个<strong class="lk jd">生产目标</strong>(生产)，它只需要在上线时构建最终的应用程序。</p><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div class="gh gi od"><img src="../Images/22259e954895227b5f30b6598bdb19cb.png" data-original-src="https://miro.medium.com/v2/resize:fit:608/format:webp/1*PZ48jfV-ASAKGDdlQRCjQw.png"/></div></figure><p id="b6c0" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">使用多个目标的好处是允许您为开发构建使用不同于生产构建的包标识符，因为有两个<em class="oe"> info.plist </em>文件。</p><p id="4d4f" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">然后，您还可以创建两个配置文件。一个只包含在开发目标中，另一个包含在生产目标中。不需要代码转换！😁</p><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi of"><img src="../Images/86a01b0cfa5cb729ede07b7d9bf41052.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*EscPCfoL1ExnHL0uUtasTA.png"/></div></div><p class="ld le gj gh gi lf lg bd b be z dk translated">开发目标中的Config.plist</p></figure><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi of"><img src="../Images/5a1484a915935be0f35f43df78c0a8a3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*guHRvVfG7E5h5DGx_2qmwQ.png"/></div></div><p class="ld le gj gh gi lf lg bd b be z dk translated">生产目标中的Config.plist</p></figure><p id="6a97" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">使用一点粘合代码来解释命令行参数，然后您可以简单地在同一个目标内切换不同的配置文件，例如加载一个<em class="oe"> dev </em>或<em class="oe"> staging </em>配置文件进行调试。</p><p id="3f9e" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">但是，只为不同的配置创建新目标有一些缺点:</p><ol class=""><li id="e4bb" class="og oh it lk b ll lm lo lp lr oi lv oj lz ok md ol om on oo bi translated">项目的<code class="fe me mf mg mh b">.pbxproj</code>文件长度增加了一倍，更大的项目文件可能会降低Xcode的速度。</li><li id="3f97" class="og oh it lk b ll op lo oq lr or lv os lz ot md ol om on oo bi translated">项目文件中的合并冲突现在需要在更多位置解决。</li><li id="9c3e" class="og oh it lk b ll op lo oq lr or lv os lz ot md ol om on oo bi translated">人们可能会忘记将新文件添加到两个目的地。</li></ol><p id="8270" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">在我看来，最后一点是一个特别的问题，因为没有CI，问题出现得晚。然后翻遍所有文件寻找被遗忘的复选标记就很繁琐了。😔</p></div><div class="ab cl mz na hx nb" role="separator"><span class="nc bw bk nd ne nf"/><span class="nc bw bk nd ne nf"/><span class="nc bw bk nd ne"/></div><div class="im in io ip iq"><h1 id="0f51" class="ng nh it bd ni nj nk nl nm nn no np nq ki nr kj ns kl nt km nu ko nv kp nw nx bi translated">更好的方法</h1><p id="d42d" class="pw-post-body-paragraph li lj it lk b ll ny kd ln lo nz kg lq lr oa lt lu lv ob lx ly lz oc mb mc md im bi translated">正如<a class="mx my ep" href="https://medium.com/u/7114b3d7b439?source=post_page-----ec58b2cc1df4--------------------------------" rel="noopener" target="_blank"> Piotr Gorzelany </a>在他的文章<a class="ae lh" href="https://medium.com/@piotr.gorzelany/ios-project-best-practices-and-tools-c46135b8116d" rel="noopener"> iOS项目最佳实践和工具</a>中解释的那样，您可以使用<em class="oe">项目级配置</em>。然后，您必须编辑<em class="oe">方案</em>，在<em class="oe">构建配置</em>的<em class="oe">运行信息</em>选项卡中选择<em class="oe">调试</em>、<em class="oe">发布</em>或<em class="oe">准备</em>。</p><p id="ccae" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">根据选择的配置，加载<em class="oe"> Configuration.plist </em>文件的另一部分。问题是所有配置的所有数据都必须在一个文件中。这意味着整个文件被交付到生产版本中，并且可能包含敏感的开发数据。😨</p><p id="e4b2" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">如果只发送需要的数据会更好。而且最好有一个解决方案，不需要一直修改方案。😩</p></div><div class="ab cl mz na hx nb" role="separator"><span class="nc bw bk nd ne nf"/><span class="nc bw bk nd ne nf"/><span class="nc bw bk nd ne"/></div><div class="im in io ip iq"><h1 id="5701" class="ng nh it bd ni nj nk nl nm nn no np nq ki nr kj ns kl nt km nu ko nv kp nw nx bi translated">推荐的新方法</h1><p id="dcde" class="pw-post-body-paragraph li lj it lk b ll ny kd ln lo nz kg lq lr oa lt lu lv ob lx ly lz oc mb mc md im bi translated">这种方法依赖于<em class="oe">。每个配置的xcconfig </em>文件、<em class="oe">方案</em>和<em class="oe"> Config.plist </em>文件。</p><h2 id="3019" class="ou nh it bd ni ov ow dn nm ox oy dp nq lr oz pa ns lv pb pc nu lz pd pe nw iz bi translated">设置配置</h2><p id="9a97" class="pw-post-body-paragraph li lj it lk b ll ny kd ln lo nz kg lq lr oa lt lu lv ob lx ly lz oc mb mc md im bi translated">在<em class="oe">项目设置</em>的<em class="oe">信息</em> — <em class="oe">配置下，</em>使用加号按钮添加一个新的配置。您应该选择“Debug”作为复制的基础，并选择“Staging”作为名称。</p><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi pf"><img src="../Images/70dc50f7a0aab15a7675d83cca995a34.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*TklPMvYkVa7FON6rFAmcbQ.jpeg"/></div></div><p class="ld le gj gh gi lf lg bd b be z dk translated">创建新的配置条目</p></figure><p id="b598" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">通过<em class="oe">文件—新建—文件… —配置设置文件</em>添加三个<em class="oe">。xcconfig </em>文件。它们被命名为“Development.xcconfig”、“Staging.xcconfig”和“Production.xcconfig”。</p><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi pg"><img src="../Images/898f7dd12959adc3d6d7469b9e9f5cf1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*KmP2iAaOSX4ClPaDMmzjpg.png"/></div></div><p class="ld le gj gh gi lf lg bd b be z dk translated">创建新的“配置设置文件”</p></figure><p id="5dc4" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">同时，您还可以为这三种配置创建三个“Config.plist”文件。如果您将它们保存在各自的目录中，这些文件甚至可以具有相同的名称。</p><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div class="gh gi ph"><img src="../Images/5c83ef588c463595f8f1dedfe4e9ab0b.png" data-original-src="https://miro.medium.com/v2/resize:fit:792/format:webp/1*j9PKpBb9CkkU3NrmzGyhgA.jpeg"/></div><p class="ld le gj gh gi lf lg bd b be z dk translated">三种配置的三个xcconfig文件</p></figure><p id="1667" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">但是，这些文件不应该添加到目标中——否则，就不清楚哪些文件现在在包中，哪些文件将被覆盖。稍后会详细介绍。</p><p id="895e" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">所以<em class="oe">。xcconfig </em>文件也被<em class="oe">配置</em>使用，你必须将它们指定为基础。为此，您可以在<em class="oe">项目设置</em>中展开相应的配置，并为相应的配置选择适当的基础。</p><p id="504e" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">在“调试”配置中，例如，“开发”。还应该为“登台”和“发布”执行此操作，以映射到“登台”和“生产”。</p><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi pi"><img src="../Images/c3e61796445cd593eeea001da54cca6f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*dtxOE2OOupEaS3Z7ZPylag.jpeg"/></div></div><p class="ld le gj gh gi lf lg bd b be z dk translated">设置“基于配置文件”</p></figure><p id="827c" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">如果您对<em class="oe"> CocoaPods </em>有问题，您可能需要删除“Pods”目录和“Podfile.lock”文件，并通过<code class="fe me mf mg mh b">pod install</code>重新安装。现在，项目应该重新构建。😅</p><h2 id="403f" class="ou nh it bd ni ov ow dn nm ox oy dp nq lr oz pa ns lv pb pc nu lz pd pe nw iz bi translated">使用。xcconfig文件</h2><p id="0ef0" class="pw-post-body-paragraph li lj it lk b ll ny kd ln lo nz kg lq lr oa lt lu lv ob lx ly lz oc mb mc md im bi translated"><em class="oe">。xcconfig </em>文件现在已经集成并使用了，但是仍然是空的。😙</p><p id="2e3e" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">可用于输入<em class="oe"> Info.plist </em>条目、<em class="oe">构建设置</em>和<em class="oe">自定义设置</em>。例如，您可以在<em class="oe"> Development.xcconfig </em>中输入以下内容:</p><p id="e52e" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated"><code class="fe me mf mg mh b">XCC_BUNDLE_NAME = Demo D</code></p><p id="9113" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated"><code class="fe me mf mg mh b">XCC_CONFIG_PATH = Development/Config.plist</code></p><p id="a549" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">这创建了两个变量，您可以在<em class="oe">构建阶段</em>和<em class="oe"> Info.plist </em>中使用。变量名是任意的，但是您应该注意可能的冲突。这就是为什么我用<em class="oe"> XCC </em>作为<em class="oe"> XCodeConfig </em>的前缀。</p><p id="6e65" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">在<em class="oe"> Info.plist </em>中，在“Bundle name”下输入值<code class="fe me mf mg mh b">${XCC_BUNDLE_NAME}</code>。此后，设备上的应用程序图标名为“演示D”。如果您在其他配置文件中添加适当的条目，例如，<em class="oe">试运行</em>的“Demo S”和<em class="oe">生产</em>版本的“Demo ”,您可以立即看到设备上当前的版本。😌</p><p id="2ae7" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">第二个变量应在<em class="oe">构建阶段</em>的单独脚本中使用。为此，使用加号按钮和条目“新运行脚本阶段”，在<em class="oe">构建阶段</em>下的<em class="oe">项目设置</em>中创建一个新的脚本条目。例如，新条目可以命名为“复制配置”并包含一个简单的<code class="fe me mf mg mh b">cp</code>命令，该命令只将适当的<em class="oe"> Config.plist </em>复制到<em class="oe">生成的</em>目录中。</p><p id="f53e" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">确保新的“复制配置”脚本条目在“依赖项”/[CP]Check Pods manifest . lock”之后和“编译源代码”之前。</p><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi pj"><img src="../Images/d2100ea7d62a052fa731b0a228cde276.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*QyoUdZpMOyTmf25ljWv0Ow.jpeg"/></div></div><p class="ld le gj gh gi lf lg bd b be z dk translated">复制配置脚本</p></figure><p id="1191" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">注意，这里配置中定义的变量与<code class="fe me mf mg mh b">${XCC_CONFIG_PATH}</code>一起使用。通过<em class="oe">配置</em>，可以确定应该复制哪个<em class="oe">列表</em>。</p><p id="816a" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">在<em class="oe">输出文件</em>下，您可能还需要输入目标文件，以确保下一阶段仅在文件被实际复制时才开始。</p><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div class="gh gi pk"><img src="../Images/a4c1518a92480f40f3dff020ade15776.png" data-original-src="https://miro.medium.com/v2/resize:fit:1256/format:webp/1*TbBd5nOYPdVnjJk1BhT-dQ.jpeg"/></div><p class="ld le gj gh gi lf lg bd b be z dk translated">复制配置脚本输出文件</p></figure><p id="4de7" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">现在，只有<em class="oe">生成的</em>目录中的<em class="oe"> Config.plist </em>必须集成到目标中，因为它应该被复制到<em class="oe">包</em>中。</p><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div class="gh gi pl"><img src="../Images/f6d71a26d8a26bd166ea9d78cb87f790.png" data-original-src="https://miro.medium.com/v2/resize:fit:1028/format:webp/1*ykkRY786IHaJXDnaOqOXYw.jpeg"/></div><p class="ld le gj gh gi lf lg bd b be z dk translated">Config.plist目标成员</p></figure><p id="b702" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">根据所选择的<em class="oe">配置</em>，相应的<em class="oe"> Config.plist </em>将在<em class="oe">构建阶段</em>被复制到<em class="oe">生成的</em>目录中，然后被复制到app的<em class="oe">包</em>中。</p><h2 id="6763" class="ou nh it bd ni ov ow dn nm ox oy dp nq lr oz pa ns lv pb pc nu lz pd pe nw iz bi translated">配置切换方案</h2><p id="ea1e" class="pw-post-body-paragraph li lj it lk b ll ny kd ln lo nz kg lq lr oa lt lu lv ob lx ly lz oc mb mc md im bi translated">为了选择各自的<em class="oe">配置</em>，人们不希望不断地调整<em class="oe">方案</em>。最好为每个<em class="oe">配置</em>创建一个<em class="oe">方案</em>，然后简单地在<em class="oe">方案</em>之间切换。</p><p id="ac57" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">通过<em class="oe">产品</em> — <em class="oe">方案</em> — <em class="oe">管理方案… </em>，可以新建<em class="oe">方案</em>。这里你总是选择相同的目标，但是根据<em class="oe">配置</em>将<em class="oe">方案命名为</em>。</p><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi pm"><img src="../Images/8f57eb27ad0f5918a3a752f46e3f1311.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*t3n3hZJT8fnZOKJhqb1-VA.jpeg"/></div></div><p class="ld le gj gh gi lf lg bd b be z dk translated">为每个配置创建方案</p></figure><p id="badc" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">对于每个<em class="oe">方案</em>，您必须在“构建配置”下选择各自的<em class="oe">配置</em>。因此，对于<em class="oe">分段方案</em>，选择<em class="oe">分段构建配置</em>。</p><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi pn"><img src="../Images/b996ed70b7501c9e9ab1b5504c33d477.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*6MjL7iLuNb3tmWLgpOrn2w.jpeg"/></div></div><p class="ld le gj gh gi lf lg bd b be z dk translated">选择构建配置</p></figure><p id="58aa" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">如果您已经为所有<em class="oe">配置</em>配置了<em class="oe">方案</em>，您现在可以轻松地在它们之间切换，并始终使用相应的<em class="oe">配置</em>。😀</p><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div class="gh gi po"><img src="../Images/cd38a820bb1e9f6707f898a0123f59c2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1276/format:webp/1*C_K4254c8636zxZ-_NLyxw.png"/></div><p class="ld le gj gh gi lf lg bd b be z dk translated">切换方案</p></figure><h2 id="abff" class="ou nh it bd ni ov ow dn nm ox oy dp nq lr oz pa ns lv pb pc nu lz pd pe nw iz bi translated">解码配置文件</h2><p id="1b81" class="pw-post-body-paragraph li lj it lk b ll ny kd ln lo nz kg lq lr oa lt lu lv ob lx ly lz oc mb mc md im bi translated">现在你已经有了通过<em class="oe">方案</em>启动的合适的<em class="oe">配置</em>和app的<em class="oe">包</em>中正确的<em class="oe"> Config.plist </em>，你也应该利用它了。😋</p><p id="9db8" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated"><em class="oe"> Config.plist </em>文件的内容可以通过<em class="oe">可解码</em>结构中的<em class="oe"> PropertyListDecoder </em>轻松解码。在<em class="oe"> DemoApp </em>项目中，你可以在<em class="oe">共享</em>框架中找到<em class="oe"> ConfigLoader </em>，将<em class="oe"> Config.plist </em>映射到<em class="oe"> Configuration </em> struct。</p><figure class="ks kt ku kv gt kw"><div class="bz fp l di"><div class="pp pq l"/></div></figure><p id="95f5" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">如你所见，<em class="oe">配置</em>结构将<em class="oe">测试标志</em>声明为可选，因此它们不必包含在<em class="oe">生产</em>版本中。只有必要的数据在<em class="oe">生产</em>版本中。😘</p><p id="22fe" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">然而，<em class="oe">开发</em>和<em class="oe">登台</em>环境不仅可以使用不同的<em class="oe"> BaseURL </em> s，还可以使用不同的<em class="oe"> TestFlags — </em>例如，在开发期间使用模拟的服务器请求。</p><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi pr"><img src="../Images/412c3b97e581f0761d05a54c6a78edc3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*P5y5M9ZIPxJ4cFSf7Crx7A.jpeg"/></div></div><p class="ld le gj gh gi lf lg bd b be z dk translated">开发配置列表</p></figure><p id="804b" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">由于结构的原因，<em class="oe">配置</em>是类型安全的，并且当由<em class="oe">依赖</em>提供时，可以很容易地在代码中使用。</p><figure class="ks kt ku kv gt kw"><div class="bz fp l di"><div class="pp pq l"/></div></figure></div><div class="ab cl mz na hx nb" role="separator"><span class="nc bw bk nd ne nf"/><span class="nc bw bk nd ne nf"/><span class="nc bw bk nd ne"/></div><div class="im in io ip iq"><h1 id="965d" class="ng nh it bd ni nj nk nl nm nn no np nq ki nr kj ns kl nt km nu ko nv kp nw nx bi translated">编译时的想法</h1><p id="50b2" class="pw-post-body-paragraph li lj it lk b ll ny kd ln lo nz kg lq lr oa lt lu lv ob lx ly lz oc mb mc md im bi translated">运行时当前正在加载<em class="oe"> Config.plist </em>。对于损坏的配置文件，这可能会导致应用程序由于抛出异常而崩溃。😅</p><p id="2c8e" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">如果你在应用程序启动后很早就开始加载配置文件，那么当你启动应用程序进行测试时，它就会崩溃。在我看来，这已经足够好了，因为配置不应该有问题。即使是这样，你也应该在每次发布后相对较快地收到通知，并被迫解决它。</p><p id="bc44" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">难道不可能在编译时捕捉错误吗？例如，使用像<a class="ae lh" href="https://github.com/SwiftGen/SwiftGen" rel="noopener ugc nofollow" target="_blank"> SwiftGen </a>这样的代码生成器，您可以在<em class="oe">构建阶段</em>将<em class="oe"> plist </em>文件转换为Swift代码，然后进行类型安全调用，并且不会出现运行时崩溃。🧐</p><p id="55c2" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">然而，这种方法存在一些问题:</p><ol class=""><li id="5dda" class="og oh it lk b ll lm lo lp lr oi lv oj lz ok md ol om on oo bi translated">当前的SwiftGen模板使用字符串字典解析嵌套级别——即，<em class="oe"> testFlags </em>将通过字符串键解析，并且不再是类型安全的:<code class="fe me mf mg mh b">configuration.testFlags[“noSplash"]</code></li><li id="a8f2" class="og oh it lk b ll op lo oq lr or lv os lz ot md ol om on oo bi translated">您可以修改模板，但这并不容易，需要维护工作，甚至可能更改SwiftGen生成器代码。在这里你要问问自己是否真的值得。</li><li id="194c" class="og oh it lk b ll op lo oq lr or lv os lz ot md ol om on oo bi translated">根据<em class="oe">配置</em>，是否将<em class="oe">测试标志</em>转换为代码——即在<em class="oe">开发</em>中，常量<code class="fe me mf mg mh b">static let testFlags: [String: Any]</code>被创建，但在<em class="oe">部署中</em>未被创建，甚至<em class="oe">未作为可选</em>。这将在<em class="oe">版本</em>中产生相应的编译器错误。修复这些问题很可能会导致不干净的解决方法。😓</li></ol><p id="7e53" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">这就是为什么我认为在运行时加载<em class="oe">配置</em>的方法更好，只要加载发生在应用程序启动之后。CI服务器上的一个小的<em class="oe"> UITest </em>应该能够快速自动地检测可能的配置文件损坏用例。所以没必要维护SwiftGen。😁</p></div></div>    
</body>
</html>