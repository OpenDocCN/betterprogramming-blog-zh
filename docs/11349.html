<html>
<head>
<title>This Pattern Will Make Your React Hooks Cleaner</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">这种模式将使你的反应钩更干净</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/this-pattern-will-make-your-react-hooks-cleaner-ca9deba5d58d?source=collection_archive---------1-----------------------#2022-03-11">https://betterprogramming.pub/this-pattern-will-make-your-react-hooks-cleaner-ca9deba5d58d?source=collection_archive---------1-----------------------#2022-03-11</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="5429" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">所以你不必重做工作</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/b38b4a5721d12903030a9016c0ba7dba.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*sPptsTjGtwqtiHPSzVhirA.jpeg"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">照片由<a class="ae kv" href="https://unsplash.com/@polarmermaid?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">安妮·尼加德</a>在<a class="ae kv" href="https://unsplash.com/s/photos/hook?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>拍摄</p></figure><h1 id="6788" class="kw kx iq bd ky kz la lb lc ld le lf lg jw lh jx li jz lj ka lk kc ll kd lm ln bi translated">目录</h1><ul class=""><li id="101a" class="lo lp iq lq b lr ls lt lu lv lw lx ly lz ma mb mc md me mf bi translated">钩子是如何制造的</li><li id="319d" class="lo lp iq lq b lr mg lt mh lv mi lx mj lz mk mb mc md me mf bi translated">我们能把选项结合起来吗</li><li id="d2e0" class="lo lp iq lq b lr mg lt mh lv mi lx mj lz mk mb mc md me mf bi translated">为什么会这样</li><li id="0862" class="lo lp iq lq b lr mg lt mh lv mi lx mj lz mk mb mc md me mf bi translated">结论</li></ul><h1 id="2da4" class="kw kx iq bd ky kz la lb lc ld le lf lg jw lh jx li jz lj ka lk kc ll kd lm ln bi translated">钩子是如何制造的</h1><p id="6702" class="pw-post-body-paragraph ml mm iq lq b lr ls jr mn lt lu ju mo lv mp mq mr lx ms mt mu lz mv mw mx mb ij bi translated">当我们在React中构建一个带有复杂逻辑的定制钩子时，我们要么返回一个数组，要么返回一个具有状态和逻辑的对象。下面显示了该过程:</p><h2 id="c8a7" class="my kx iq bd ky mz na dn lc nb nc dp lg lv nd ne li lx nf ng lk lz nh ni lm nj bi translated">1.返回一个对象</h2><p id="5fae" class="pw-post-body-paragraph ml mm iq lq b lr ls jr mn lt lu ju mo lv mp mq mr lx ms mt mu lz mv mw mx mb ij bi translated">第一个选项是从自定义挂钩返回一个对象，如下所示:</p><pre class="kg kh ki kj gt nk nl nm nn aw no bi"><span id="afbb" class="my kx iq nl b gy np nq l nr ns">const customHook = (configs) =&gt; {<br/>  const isLoading = true //logic<br/>  const reload    = () =&gt; {/*logic*/}</span><span id="2614" class="my kx iq nl b gy nt nq l nr ns">  return<strong class="nl ir"> { isLoading, reload }</strong><br/>}</span></pre><p id="31fa" class="pw-post-body-paragraph ml mm iq lq b lr nu jr mn lt nv ju mo lv nw mq mr lx nx mt mu lz ny mw mx mb ij bi translated">用法如下所示:</p><pre class="kg kh ki kj gt nk nl nm nn aw no bi"><span id="e826" class="my kx iq nl b gy np nq l nr ns">const <strong class="nl ir">{ isLoading, reload } </strong>= customHook(configs)</span></pre><p id="8fa3" class="pw-post-body-paragraph ml mm iq lq b lr nu jr mn lt nv ju mo lv nw mq mr lx nx mt mu lz ny mw mx mb ij bi translated">其中:</p><ul class=""><li id="4c72" class="lo lp iq lq b lr nu lt nv lv nz lx oa lz ob mb mc md me mf bi translated">它对开发者友好，你不需要记住道具的顺序</li><li id="5743" class="lo lp iq lq b lr mg lt mh lv mi lx mj lz mk mb mc md me mf bi translated">智能感知将帮助您了解参数</li></ul><p id="d9b4" class="pw-post-body-paragraph ml mm iq lq b lr nu jr mn lt nv ju mo lv nw mq mr lx nx mt mu lz ny mw mx mb ij bi translated">但是当我们使用多个钩子时，就不好看了。它看起来会像这样:</p><pre class="kg kh ki kj gt nk nl nm nn aw no bi"><span id="6d4f" class="my kx iq nl b gy np nq l nr ns">const { <br/>  <strong class="nl ir">isLoading: isLoadingWidget1, <br/>  reload: reloadWidget1 </strong><br/>} = customHook(widget1Config)</span><span id="917e" class="my kx iq nl b gy nt nq l nr ns">const { <br/> <strong class="nl ir"> isLoading: isLoadingWidget2, <br/>  reload: reloadWidget2 </strong><br/>} = customHook(widget2Config)</span><span id="7425" class="my kx iq nl b gy nt nq l nr ns">const { <br/>  <strong class="nl ir">isLoading: isLoadingWidget3, <br/>  reload: reloadWidget3 </strong><br/>} = customHook(widget3Config)</span></pre><p id="52f1" class="pw-post-body-paragraph ml mm iq lq b lr nu jr mn lt nv ju mo lv nw mq mr lx nx mt mu lz ny mw mx mb ij bi translated">这可不太好。我们必须将每个键重命名为另一个键，这样它们就不会冲突。</p><h2 id="a114" class="my kx iq bd ky mz na dn lc nb nc dp lg lv nd ne li lx nf ng lk lz nh ni lm nj bi translated">2.返回数组</h2><p id="3e7d" class="pw-post-body-paragraph ml mm iq lq b lr ls jr mn lt lu ju mo lv mp mq mr lx ms mt mu lz mv mw mx mb ij bi translated">另一个选项是从自定义挂钩返回一个数组，如下所示:</p><pre class="kg kh ki kj gt nk nl nm nn aw no bi"><span id="90fb" class="my kx iq nl b gy np nq l nr ns">const customHook = (configs) =&gt; {<br/>  const isLoading = true //logic<br/>  const reload    = () =&gt; {/*logic*/}</span><span id="d3ee" class="my kx iq nl b gy nt nq l nr ns">  return <strong class="nl ir">[isLoading, reload]</strong><br/>}</span></pre><p id="6f49" class="pw-post-body-paragraph ml mm iq lq b lr nu jr mn lt nv ju mo lv nw mq mr lx nx mt mu lz ny mw mx mb ij bi translated">用法如下所示:</p><pre class="kg kh ki kj gt nk nl nm nn aw no bi"><span id="f187" class="my kx iq nl b gy np nq l nr ns">const [<strong class="nl ir">isLoadingWidget1, reloadWidget1] </strong>= customHook(widget1Config)<br/>const [<strong class="nl ir">isLoadingWidget2, reloadWidget2] </strong>= customHook(widget2Config)<br/>const [<strong class="nl ir">isLoadingWidget3, reloadWidget3] </strong>= customHook(widget3Config)</span></pre><p id="fdc9" class="pw-post-body-paragraph ml mm iq lq b lr nu jr mn lt nv ju mo lv nw mq mr lx nx mt mu lz ny mw mx mb ij bi translated">其中:</p><ul class=""><li id="f8fb" class="lo lp iq lq b lr nu lt nv lv nz lx oa lz ob mb mc md me mf bi translated">它解决了多用途的问题。您不必重命名每个键。</li></ul><p id="c325" class="pw-post-body-paragraph ml mm iq lq b lr nu jr mn lt nv ju mo lv nw mq mr lx nx mt mu lz ny mw mx mb ij bi translated">但是:</p><ul class=""><li id="da8b" class="lo lp iq lq b lr nu lt nv lv nz lx oa lz ob mb mc md me mf bi translated">你要维持道具的顺序</li><li id="b280" class="lo lp iq lq b lr mg lt mh lv mi lx mj lz mk mb mc md me mf bi translated">不具备与对象相同的智能感知</li></ul><h1 id="d4ee" class="kw kx iq bd ky kz la lb lc ld le lf lg jw lh jx li jz lj ka lk kc ll kd lm ln bi translated">我们能把选项结合起来吗</h1><p id="da2c" class="pw-post-body-paragraph ml mm iq lq b lr ls jr mn lt lu ju mo lv mp mq mr lx ms mt mu lz mv mw mx mb ij bi translated">我们能把这些模式结合起来吗？从某种意义上说，如果你想把它作为一个数组或者作为同一个钩子的对象。</p><p id="a727" class="pw-post-body-paragraph ml mm iq lq b lr nu jr mn lt nv ju mo lv nw mq mr lx nx mt mu lz ny mw mx mb ij bi translated">是的，这是可能的。看看这个实现:</p><pre class="kg kh ki kj gt nk nl nm nn aw no bi"><span id="0f67" class="my kx iq nl b gy np nq l nr ns">const customHook = () =&gt; {  <br/>  const isLoading = true //logic<br/>  const reload    = () =&gt; {/*logic*/}</span><span id="657c" class="my kx iq nl b gy nt nq l nr ns">  <strong class="nl ir">const result = [isLoading, reload]</strong></span><span id="3f68" class="my kx iq nl b gy nt nq l nr ns"><strong class="nl ir">  result.isLoading = isLoading<br/>  result.reload    = reload</strong></span><span id="559b" class="my kx iq nl b gy nt nq l nr ns">  return result<br/>}</span></pre><p id="956f" class="pw-post-body-paragraph ml mm iq lq b lr nu jr mn lt nv ju mo lv nw mq mr lx nx mt mu lz ny mw mx mb ij bi translated"><code class="fe oc od oe nl b">result</code>是一个数组，但是我们给它添加了<code class="fe oc od oe nl b">isLoading</code>和<code class="fe oc od oe nl b">reload</code>键。</p><p id="bddc" class="pw-post-body-paragraph ml mm iq lq b lr nu jr mn lt nv ju mo lv nw mq mr lx nx mt mu lz ny mw mx mb ij bi translated">该实现将使我们能够使用钩子的返回值:</p><ol class=""><li id="bc35" class="lo lp iq lq b lr nu lt nv lv nz lx oa lz ob mb of md me mf bi translated"><strong class="lq ir">一个物体</strong></li></ol><pre class="kg kh ki kj gt nk nl nm nn aw no bi"><span id="4c18" class="my kx iq nl b gy np nq l nr ns">const <strong class="nl ir">{ isLoading, reload }</strong> = customHook(configs)</span></pre><p id="160a" class="pw-post-body-paragraph ml mm iq lq b lr nu jr mn lt nv ju mo lv nw mq mr lx nx mt mu lz ny mw mx mb ij bi translated">2.<strong class="lq ir">一个数组</strong></p><pre class="kg kh ki kj gt nk nl nm nn aw no bi"><span id="326a" class="my kx iq nl b gy np nq l nr ns">const <strong class="nl ir">[isLoading, reload]</strong> = customHook(configs)</span></pre><p id="347a" class="pw-post-body-paragraph ml mm iq lq b lr nu jr mn lt nv ju mo lv nw mq mr lx nx mt mu lz ny mw mx mb ij bi translated">这两种选择都行得通。但是为什么…</p><h1 id="d5ea" class="kw kx iq bd ky kz la lb lc ld le lf lg jw lh jx li jz lj ka lk kc ll kd lm ln bi translated">为什么会这样</h1><p id="1f8b" class="pw-post-body-paragraph ml mm iq lq b lr ls jr mn lt lu ju mo lv mp mq mr lx ms mt mu lz mv mw mx mb ij bi translated">为什么可以同时使用数组和对象返回类型？为什么可以将键附加到数组上？</p><blockquote class="og oh oi"><p id="0ba0" class="ml mm oj lq b lr nu jr mn lt nv ju mo ok nw mq mr ol nx mt mu om ny mw mx mb ij bi translated">与其他编程语言中的数组一样，<code class="fe oc od oe nl b">Array</code>对象使<a class="ae kv" href="https://developer.mozilla.org/en-US/docs/Learn/JavaScript/First_steps/Arrays" rel="noopener ugc nofollow" target="_blank">能够在单个变量名</a>下存储多个项目的集合，并且具有用于执行公共数组操作的<a class="ae kv" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array#examples" rel="noopener ugc nofollow" target="_blank">的成员— </a><a class="ae kv" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array" rel="noopener ugc nofollow" target="_blank"> MDN </a></p></blockquote><p id="4894" class="pw-post-body-paragraph ml mm iq lq b lr nu jr mn lt nv ju mo lv nw mq mr lx nx mt mu lz ny mw mx mb ij bi translated">如前所述，“数组对象”这揭示了一个事实，数组实际上只是一个对象，有一个特殊的构造函数和一组执行常见数组操作的方法。</p><h2 id="6aab" class="my kx iq bd ky mz na dn lc nb nc dp lg lv nd ne li lx nf ng lk lz nh ni lm nj bi translated">证明数组实际上是一个对象</h2><ol class=""><li id="feed" class="lo lp iq lq b lr ls lt lu lv lw lx ly lz ma mb of md me mf bi translated"><strong class="lq ir">证据1 </strong></li></ol><pre class="kg kh ki kj gt nk nl nm nn aw no bi"><span id="1d1a" class="my kx iq nl b gy np nq l nr ns"><strong class="nl ir">typeof []</strong> // 'object'</span></pre><p id="3735" class="pw-post-body-paragraph ml mm iq lq b lr nu jr mn lt nv ju mo lv nw mq mr lx nx mt mu lz ny mw mx mb ij bi translated">是的，<code class="fe oc od oe nl b">typeof</code>将导致<code class="fe oc od oe nl b">'object'</code></p><p id="2b2b" class="pw-post-body-paragraph ml mm iq lq b lr nu jr mn lt nv ju mo lv nw mq mr lx nx mt mu lz ny mw mx mb ij bi translated">2.<strong class="lq ir">证明2 </strong></p><pre class="kg kh ki kj gt nk nl nm nn aw no bi"><span id="4ec3" class="my kx iq nl b gy np nq l nr ns">const <strong class="nl ir">{0: first, 1: second}</strong> = [1, 2, 3, 4] // first: 1, second: 2</span></pre><p id="ea52" class="pw-post-body-paragraph ml mm iq lq b lr nu jr mn lt nv ju mo lv nw mq mr lx nx mt mu lz ny mw mx mb ij bi translated">我们可以使用索引来破坏数组对象，因为任何数组中的键都是对象的索引和值，它们是你在方括号<code class="fe oc od oe nl b">[]</code>之间传递的东西。这就是为什么我们能够破坏它，并以这种方式重命名密钥。</p><p id="ab74" class="pw-post-body-paragraph ml mm iq lq b lr nu jr mn lt nv ju mo lv nw mq mr lx nx mt mu lz ny mw mx mb ij bi translated">3.<strong class="lq ir">证据3 </strong></p><pre class="kg kh ki kj gt nk nl nm nn aw no bi"><span id="c753" class="my kx iq nl b gy np nq l nr ns"><strong class="nl ir">const { length } </strong>=<strong class="nl ir"> </strong>[1, 2, 3, 4]</span></pre><p id="56a7" class="pw-post-body-paragraph ml mm iq lq b lr nu jr mn lt nv ju mo lv nw mq mr lx nx mt mu lz ny mw mx mb ij bi translated">数组是一个对象，其中也有<code class="fe oc od oe nl b">length</code>键。</p><p id="f636" class="pw-post-body-paragraph ml mm iq lq b lr nu jr mn lt nv ju mo lv nw mq mr lx nx mt mu lz ny mw mx mb ij bi translated">4.<strong class="lq ir">证据4 </strong></p><pre class="kg kh ki kj gt nk nl nm nn aw no bi"><span id="424b" class="my kx iq nl b gy np nq l nr ns"><strong class="nl ir">Object.keys([1, 2, 3, 4]) </strong>  // ['0', '1', '2', '3']<br/><strong class="nl ir">Object.values([1, 2, 3, 4])</strong> // [1, 2, 3, 4]</span></pre><p id="7c90" class="pw-post-body-paragraph ml mm iq lq b lr nu jr mn lt nv ju mo lv nw mq mr lx nx mt mu lz ny mw mx mb ij bi translated"><code class="fe oc od oe nl b">Object.keys</code>和<code class="fe oc od oe nl b">Object.values</code>只作用于对象，数组是对象(特殊对象)。</p><h1 id="479c" class="kw kx iq bd ky kz la lb lc ld le lf lg jw lh jx li jz lj ka lk kc ll kd lm ln bi translated">结论</h1><p id="7f84" class="pw-post-body-paragraph ml mm iq lq b lr ls jr mn lt lu ju mo lv mp mq mr lx ms mt mu lz mv mw mx mb ij bi translated">我们刚刚看到了一个模式，它允许我们将钩子的返回值作为数组或对象进行析构。我们已经看到这是多么有帮助。我们已经看到了为什么这是可能的，因为这一切都是关于这样一个事实，数组只是有一个上限的对象。</p><h1 id="a5c4" class="kw kx iq bd ky kz la lb lc ld le lf lg jw lh jx li jz lj ka lk kc ll kd lm ln bi translated">资源</h1><ol class=""><li id="f62c" class="lo lp iq lq b lr ls lt lu lv lw lx ly lz ma mb of md me mf bi translated"><a class="ae kv" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array" rel="noopener ugc nofollow" target="_blank">https://developer . Mozilla . org/en-US/docs/Web/JavaScript/Reference/Global _ Objects/Array</a></li></ol></div></div>    
</body>
</html>