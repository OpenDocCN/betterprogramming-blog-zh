<html>
<head>
<title>The Complete Guide To Understanding Time and Space Complexity of Algorithms</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">理解算法的时间和空间复杂性的完全指南</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/the-complete-guide-to-understanding-time-and-space-complexity-of-algorithms-88de31d89949?source=collection_archive---------9-----------------------#2021-04-29">https://betterprogramming.pub/the-complete-guide-to-understanding-time-and-space-complexity-of-algorithms-88de31d89949?source=collection_archive---------9-----------------------#2021-04-29</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="b0c8" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">这个话题在面试中超级潮，找工作的话应该知道</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/a1d9eb7cd8fcb2b244d91746d16e2c1a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Ra_tuJLXkl9xY2iKbSuUbg.jpeg"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">作者图片</p></figure><p id="ab5a" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">解决问题的方法不止一种，但并不是所有的方法都是最好的。不是每个解决方案都能够有效地利用我们的资源。因此，在采取行动之前，我们需要找到解决问题的最佳、最有效的方案。</p><p id="76e9" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">在编程中，我们不能把寻找最佳解决方案、最佳算法的机制留给猜测。我们需要一个明确的标准来评估解决方案的效率。这就是时间和空间复杂性概念介入的地方。它们帮助我们根据所需的资源来确定算法的效率。</p><p id="b85b" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">在本文中，我们将讨论时间和空间复杂性的概念，以及如何使用它们为给定的任务选择最有效的算法。当然，这也是像O( <em class="lu"> n </em>)和O(log <em class="lu"> n </em>)这样的符号的来源，这些符号在学习算法时可能会让你感到困惑。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="e4b6" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">算法的效率</h1><p id="3fd1" class="pw-post-body-paragraph ky kz it la b lb mu ju ld le mv jx lg lh mw lj lk ll mx ln lo lp my lr ls lt im bi translated">我们使用算法执行所需的时间和空间(内存)来衡量算法的效率。时间很重要，因为我们需要我们的程序尽可能快地运行，以快速交付结果。空间很重要，因为机器留给程序的空间是有限的。</p><p id="98e3" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">最好的算法是使用最少的空间在最少的时间内完成执行的算法。但通常，在现实中，算法必须在节省空间和时间之间进行权衡。</p><p id="b101" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">这就是为什么给定任务的最佳算法不是一成不变的。最佳算法取决于我们的需求。如果我们需要我们的算法尽可能快地运行，不管内存使用情况如何，我们可以选择最省时的算法作为最佳算法，反之亦然。</p><p id="c240" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">如果我们需要节省时间和空间，我们可以满足于使用平均时间和空间量的算法。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="bc2b" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">空间复杂性</h1><p id="e543" class="pw-post-body-paragraph ky kz it la b lb mu ju ld le mv jx lg lh mw lj lk ll mx ln lo lp my lr ls lt im bi translated">算法的空间复杂度是指算法执行时所使用的空间量与输入的大小之间的关系。</p><pre class="kj kk kl km gt mz na nb nc aw nd bi"><span id="83dd" class="ne md it na b gy nf ng l nh ni">n = int(input())</span><span id="5fbc" class="ne md it na b gy nj ng l nh ni">nums = []<br/>for i in range(1, n+1):<br/>    nums.append(i*i)</span></pre><p id="80d6" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">在这个例子中，我们创建的列表的长度取决于我们为<em class="lu"> n </em>提供的输入值。</p><p id="46ac" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">假设向列表中添加一个整数占用了<em class="lu"> c </em>空间，而其他初始操作，包括创建一个新列表，占用了<em class="lu"> d </em>空间。然后我们可以像这样为上面的算法所占用的空间创建一个方程。</p><pre class="kj kk kl km gt mz na nb nc aw nd bi"><span id="e4f1" class="ne md it na b gy nf ng l nh ni">when n       -&gt; c*n + d<br/>when n = 10  -&gt; c*10 + d<br/>when n = 100 -&gt; c*100 + d</span></pre><p id="0c43" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">由该等式计算的值是算法完成执行所需的空间。常量<em class="lu"> c </em>和<em class="lu"> d </em>的值不受算法的控制，并且取决于诸如编程语言、硬件规格等因素。</p><p id="47d6" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">然而，我们不需要这个方程计算的精确值来讨论算法的空间复杂度。相反，我们使用变量<em class="lu"> n </em>的最高阶作为空间复杂度的代表。</p><p id="a4e6" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">例如，上述算法的空间复杂度约为<em class="lu"> n </em>。如果另一个算法对于它需要的空间有等式<em class="lu">c</em>*<em class="lu">n</em>2+<em class="lu">d</em>*<em class="lu">n</em>+<em class="lu">e</em>，我们说它有一个<em class="lu"> n </em> 2的空间复杂度的阶。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="ccaf" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">时间复杂度</h1><p id="f65b" class="pw-post-body-paragraph ky kz it la b lb mu ju ld le mv jx lg lh mw lj lk ll mx ln lo lp my lr ls lt im bi translated">时间复杂度是算法执行的与输入大小相关的基本操作的数量。这里我们计算的是操作的数量，而不是时间本身，这是基于这样一个假设，即每个操作需要固定的时间来完成。</p><p id="0d6f" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">如果我们再看一下前面的算法，它执行<em class="lu"> n </em>次操作(<em class="lu"> n </em>次循环迭代)来完成它的执行。</p><p id="6897" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">如果我们像以前一样构造一个类似的时间复杂度方程，它也采用<em class="lu">c</em>*<em class="lu">n</em>+<em class="lu">d</em>的形式，其中<em class="lu"> c </em>为每次循环迭代所用的固定时间，<code class="fe nk nl nm na b">d</code>为其他初始操作所用的固定时间。</p><p id="2146" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">因此该算法的时间复杂度也在<em class="lu"> n </em>的数量级。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="e46e" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">渐近分析</h1><p id="137b" class="pw-post-body-paragraph ky kz it la b lb mu ju ld le mv jx lg lh mw lj lk ll mx ln lo lp my lr ls lt im bi translated">正如你在这些例子中看到的，我们不能用精确的值来比较一个算法和另一个算法，因为它们取决于我们使用的工具和底层硬件。事实上，如果我们计算在同一系统上运行同一算法的两个实例的时间和空间值，由于系统环境的细微变化，我们得到的值会有差异。</p><p id="3c2b" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">因此，我们使用<a class="ae nn" href="https://en.wikipedia.org/wiki/Asymptotic_analysis" rel="noopener ugc nofollow" target="_blank">渐近分析</a>来比较两种算法的空间和时间复杂度。它根据输入大小分析算法的性能。它评估性能如何随着输入大小的增加而变化。这种类型的分析不需要算法所采用的空间或时间的实际值来进行比较。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="cfc4" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">最佳、最差和一般情况</h1><p id="2685" class="pw-post-body-paragraph ky kz it la b lb mu ju ld le mv jx lg lh mw lj lk ll mx ln lo lp my lr ls lt im bi translated">通常，在渐近分析中，我们在分析算法时会考虑三种情况:最佳、最差和平均。</p><p id="8979" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">为了理解每种情况，让我们以线性搜索算法为例。我们使用一个简单的<code class="fe nk nl nm na b">for</code>循环来搜索一个给定的整数<em class="lu"> k </em>是否出现在一个名为<code class="fe nk nl nm na b">nums</code>的大小为<em class="lu"> n </em>的列表中。</p><pre class="kj kk kl km gt mz na nb nc aw nd bi"><span id="b5ea" class="ne md it na b gy nf ng l nh ni">def linear_search(nums, n, k):<br/>    for i in range(n):<br/>        if k == nums[i]:<br/>            return i<br/>    return -1</span></pre><p id="2557" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">让我们从时间复杂度的角度来考虑这个算法的最好、最坏和平均情况。(我们也可以从空间复杂度的角度来讨论这三个场景。)</p><h2 id="38f3" class="ne md it bd me no np dn mi nq nr dp mm lh ns nt mo ll nu nv mq lp nw nx ms ny bi translated">最好的情况</h2><p id="60a6" class="pw-post-body-paragraph ky kz it la b lb mu ju ld le mv jx lg lh mw lj lk ll mx ln lo lp my lr ls lt im bi translated">我们将允许算法在最短时间内完成执行的输入组合视为时间复杂度方面的最佳情况。在这种情况下，执行时间充当算法时间复杂度的下限。</p><p id="85e4" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">在线性搜索中，最好的情况发生在当<em class="lu"> k </em>存储在列表的第0个索引时。在这种情况下，算法可以在<code class="fe nk nl nm na b">for</code>循环的仅一次迭代之后完成执行。</p><pre class="kj kk kl km gt mz na nb nc aw nd bi"><span id="9fd2" class="ne md it na b gy nf ng l nh ni">nums = [1, 2, 3, 4, 5, 6]<br/>n = 6<br/>k = 1</span></pre><h2 id="ba72" class="ne md it bd me no np dn mi nq nr dp mm lh ns nt mo ll nu nv mq lp nw nx ms ny bi translated">最坏情况</h2><p id="69c3" class="pw-post-body-paragraph ky kz it la b lb mu ju ld le mv jx lg lh mw lj lk ll mx ln lo lp my lr ls lt im bi translated">最糟糕的情况发生在将花费最长时间完成的输入组合传递给算法时。最坏情况的执行时间充当算法时间复杂度的上限。</p><p id="822f" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">在线性搜索中，最坏的情况发生在<code class="fe nk nl nm na b">k</code>不在列表中的时候。这需要算法<em class="lu"> n </em> +1次迭代才能算出这个数字不在列表中。</p><pre class="kj kk kl km gt mz na nb nc aw nd bi"><span id="636f" class="ne md it na b gy nf ng l nh ni">nums = [1, 2, 3, 4, 5, 6]<br/>n = 6<br/>k = 7</span></pre><h2 id="82d0" class="ne md it bd me no np dn mi nq nr dp mm lh ns nt mo ll nu nv mq lp nw nx ms ny bi translated">一般情况</h2><p id="1d5c" class="pw-post-body-paragraph ky kz it la b lb mu ju ld le mv jx lg lh mw lj lk ll mx ln lo lp my lr ls lt im bi translated">为了找到平均情况，我们得到算法对于每个可能的输入组合的运行时间的总和，并取它们的平均值。</p><p id="4051" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">在线性搜索中，算法完成执行所需的迭代次数遵循以下模式。</p><pre class="kj kk kl km gt mz na nb nc aw nd bi"><span id="f9a3" class="ne md it na b gy nf ng l nh ni">When k is stored at the 0th index  -&gt; 1 iteration<br/>When k is stored at the 1st index  -&gt; 2 iterations<br/>When k is stored at the 2nd index  -&gt; 3 iterations<br/>When k is stored at the 3rd index  -&gt; 4 iterations<br/>:                                  :<br/>When k is stored at the nth index  -&gt; n iterations<br/>When k is not in the list          -&gt; n+1 iterations</span></pre><p id="5eaa" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">所以我们可以这样计算算法的平均运行时间。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi nz"><img src="../Images/bb976a6d2cb5e4222f7f2df394c2b91a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1076/format:webp/0*lod6M3q2BLKVweq-.png"/></div></figure></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="9de9" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">渐近符号</h1><p id="f046" class="pw-post-body-paragraph ky kz it la b lb mu ju ld le mv jx lg lh mw lj lk ll mx ln lo lp my lr ls lt im bi translated">渐近符号是一种数学符号，用于表示渐近分析中算法的时间和空间复杂度。我们主要使用三种渐近符号来表示算法的最佳、最差和平均情况。</p><h2 id="d68b" class="ne md it bd me no np dn mi nq nr dp mm lh ns nt mo ll nu nv mq lp nw nx ms ny bi translated">ω(大ω)符号</h2><p id="be61" class="pw-post-body-paragraph ky kz it la b lb mu ju ld le mv jx lg lh mw lj lk ll mx ln lo lp my lr ls lt im bi translated">ω符号表示函数的渐近下界。换句话说，它说函数应该至少输出给定输入的相应的big-omega值。</p><p id="9751" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">对于一个函数<em class="lu"> g </em> ( <em class="lu"> n </em>)，我们可以将ω(<em class="lu">g</em>(<em class="lu">n</em>))表示的函数集合定义如下。</p><pre class="kj kk kl km gt mz na nb nc aw nd bi"><span id="e97e" class="ne md it na b gy nf ng l nh ni">Ω(g(n)) = {<br/>  f(n): there exist positive constants c and n0 such that<br/>    0 &lt;= c*g(n) &lt;= f(n) for all n &gt;= n0<br/>}</span></pre><p id="106d" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">很拗口。但是让我们用一个例子来分解这个定义，试着去理解它的意思。</p><p id="b27e" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">先拿函数<em class="lu">g</em>(<em class="lu">n</em>)=<em class="lu">n</em>2来说。</p><p id="7402" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">现在，<em class="lu"> g </em> ( <em class="lu"> n </em>)的大ω代表所有<em class="lu"> n </em> &gt; = <em class="lu"> n </em> 0时满足条件0&lt;=<em class="lu">c</em>*<em class="lu">g</em>(<em class="lu">n</em>)&lt;=<em class="lu">f</em>(<em class="lu">n</em>)的函数集合</p><p id="c16c" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">我们来考虑函数<em class="lu">f</em>(<em class="lu">n</em>)= 2<em class="lu">n</em>2+4。</p><pre class="kj kk kl km gt mz na nb nc aw nd bi"><span id="bbd8" class="ne md it na b gy nf ng l nh ni">For c = 1 and n0 = 1, 0 &lt;= c*g(n) &lt;= f(n) for all n &gt;= n0<br/>Therefore, f(n) = Ω(g(n))</span></pre><p id="9961" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">现在，如果我们考虑<em class="lu">f</em>(<em class="lu">n</em>)= 3<em class="lu">n</em>+5，就找不到满足上述条件的常数<em class="lu"> c </em>和<em class="lu"> n </em> 0的值。所以<em class="lu">f</em>(<em class="lu">n</em>)= 3<em class="lu">n</em>+5不属于<em class="lu"> g </em> ( <em class="lu"> n </em>)的大ω。</p><p id="442b" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">在时间和空间复杂性中，ω符号用于表示算法的最佳情况。它可以提供时间和空间复杂度的下限。</p><h2 id="1279" class="ne md it bd me no np dn mi nq nr dp mm lh ns nt mo ll nu nv mq lp nw nx ms ny bi translated">O(大O)符号</h2><p id="a4c3" class="pw-post-body-paragraph ky kz it la b lb mu ju ld le mv jx lg lh mw lj lk ll mx ln lo lp my lr ls lt im bi translated">o符号表示函数的渐近上界。换句话说，对于给定的输入，该函数应该最多输出相应的big-O值。</p><p id="8ffe" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">对于一个函数<em class="lu"> g </em> ( <em class="lu"> n </em>)，集合O( <em class="lu"> g </em> ( <em class="lu"> n </em>))的定义如下。</p><pre class="kj kk kl km gt mz na nb nc aw nd bi"><span id="38ab" class="ne md it na b gy nf ng l nh ni">O(g(n)) = { <br/>  f(n): there exist positive constants c and n0 such that<br/>    0 &lt;= f(n) &lt;= c*g(n) for all n &gt;= n0<br/>}</span></pre><p id="bce5" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">还是那句话，我们用一个例子来理解这个定义。</p><pre class="kj kk kl km gt mz na nb nc aw nd bi"><span id="7ca9" class="ne md it na b gy nf ng l nh ni">g(n) = n2<br/>f(n) = 2n2 + 4<br/>For c = 5 and n0 = 1, 0 &lt;= f(n) &lt;= c*g(n) for all n &gt;= n0<br/>Therefore, f(n) = O(g(n)</span></pre><p id="bf1b" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">而如果我们考虑<em class="lu">f</em>(<em class="lu">n</em>)=<em class="lu">n</em>3+2，则不属于O( <em class="lu"> g </em> ( <em class="lu"> n </em>))，因为<em class="lu"> c </em>和<em class="lu"> n </em> 0的值组合都不满足要求的条件。</p><p id="1c73" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">我们用O符号来表示算法最坏情况下的时间和空间复杂度。</p><h2 id="3310" class="ne md it bd me no np dn mi nq nr dp mm lh ns nt mo ll nu nv mq lp nw nx ms ny bi translated">θ(大θ)符号</h2><p id="c0c5" class="pw-post-body-paragraph ky kz it la b lb mu ju ld le mv jx lg lh mw lj lk ll mx ln lo lp my lr ls lt im bi translated">θ符号表示函数的上界和下界。因此，对于给定的输入，它定义了函数可以取值的最大和最小边界。</p><p id="182e" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">θ符号的标准定义如下。</p><pre class="kj kk kl km gt mz na nb nc aw nd bi"><span id="a8f6" class="ne md it na b gy nf ng l nh ni">Θ(g(n)) = {<br/>    f(n): there exist positive constants c1, c2 and n0 such<br/>        that 0 &lt;= c1*g(n) &lt;= f(n) &lt;= c2*g(n) for all n &gt;= n0<br/>}</span></pre><p id="5ec4" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">我们用一个例子，用我们到目前为止使用的<em class="lu"> g </em> ( <em class="lu"> n </em>)和<em class="lu"> f </em> ( <em class="lu"> n </em>)函数来理解这个定义。</p><pre class="kj kk kl km gt mz na nb nc aw nd bi"><span id="17cc" class="ne md it na b gy nf ng l nh ni">g(n) = n2<br/>f(n) = 2n2 + 4<br/>For n0 = 1, c0 = 1, and c1 = 5, 0 &lt;= c0*g(n) &lt;= f(n) &lt;= c1*g(n) for all n &gt;= n0<br/>Therefore, f(n) = Θ(g(n))</span></pre><p id="693b" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">Big-theta符号用于定义算法的平均时间和空间复杂度。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="3f32" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">流行算法的时间和空间复杂度</h1><h2 id="1207" class="ne md it bd me no np dn mi nq nr dp mm lh ns nt mo ll nu nv mq lp nw nx ms ny bi translated">选择排序</h2><p id="69a4" class="pw-post-body-paragraph ky kz it la b lb mu ju ld le mv jx lg lh mw lj lk ll mx ln lo lp my lr ls lt im bi translated">选择排序算法用于对项目列表进行排序。</p><ol class=""><li id="2b69" class="oa ob it la b lb lc le lf lh oc ll od lp oe lt of og oh oi bi translated">它遍历列表一次，找到最小项，并将其放在列表的起始索引处。</li><li id="ecf1" class="oa ob it la b lb oj le ok lh ol ll om lp on lt of og oh oi bi translated">然后，在下一次迭代中，它会找到第二个最小项，并将其放在第二个位置。</li><li id="1e06" class="oa ob it la b lb oj le ok lh ol ll om lp on lt of og oh oi bi translated">这种模式一直持续到列表中的所有项目都排序完毕。</li></ol><pre class="kj kk kl km gt mz na nb nc aw nd bi"><span id="4bee" class="ne md it na b gy nf ng l nh ni">def selection_sort(nums, n):<br/>    """<br/>    nums: the list of numbers to sort<br/>    n: the length of the list<br/>    """<br/>    for i in range(n-1):</span><span id="a81f" class="ne md it na b gy nj ng l nh ni">        min_index = i<br/>        #search the unsorted indexes for the next minimum number<br/>        for j in range(i+1, n):<br/>            if (nums[j] &lt; nums[min_index] ):<br/>                min_index = j<br/>        #Swap the next minimum number with the earliest unsorted number<br/>        nums[i], nums[min_index] = nums[min_index], nums[i]</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi oo"><img src="../Images/4d4223fcb9ad79fdeb18a0cdd9f4fc10.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*k4NRGwG101e2EzUp.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">选择排序示例</p></figure><p id="5e71" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated"><strong class="la iu">时间复杂度</strong></p><p id="2478" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">让我们考虑这个算法的最好、最坏和一般情况下的时间复杂度。</p><p id="e56d" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">最好的情况发生在传递的数字列表已经排序的时候。然而，选择排序算法仍然必须完成所有的迭代步骤，因为它没有一种机制来知道列表是否已经排序。</p><p id="8056" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">如果算法在<em class="lu"> p </em>步数内完成，则以下公式适用。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi op"><img src="../Images/ba8c6ec129357b4b4e15cb5601557f6e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*lWEBYxGrLgAPrRLI.png"/></div></div></figure><p id="75c5" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">我们可以看到<em class="lu"> p </em>的顺序是<em class="lu"> n </em> 2。因此，选择排序的最佳时间复杂度是<em class="lu">ω</em>(<em class="lu">n</em>2)。</p><p id="5d52" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">选择排序对于其他所有输入都是一样的，包括最坏的情况。所以它的最坏情况和平均情况的时间复杂度是O( <em class="lu"> n </em> 2)和θ(<em class="lu">n</em>2)。</p><p id="8095" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated"><strong class="la iu">空间复杂度</strong></p><p id="4b4f" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">选择排序不在内存中存储额外的数据。它只修改原始列表。因此，它的空间复杂度为O(1)。</p><h2 id="868d" class="ne md it bd me no np dn mi nq nr dp mm lh ns nt mo ll nu nv mq lp nw nx ms ny bi translated">冒泡排序</h2><p id="42e2" class="pw-post-body-paragraph ky kz it la b lb mu ju ld le mv jx lg lh mw lj lk ll mx ln lo lp my lr ls lt im bi translated">冒泡排序算法比较列表中的相邻项，如果第一项小于第二项，则交换它们。它继续这个操作，直到在遍历列表时没有执行交换(即，列表被排序)。</p><p id="268e" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">例如，如果[22，12]是列表中两个相邻的项目，冒泡排序会交换它们，并将顺序更改为[12，22]。</p><pre class="kj kk kl km gt mz na nb nc aw nd bi"><span id="be6a" class="ne md it na b gy nf ng l nh ni">def bubble_sort(nums, n):<br/>    for i in range(n-1):<br/>        swapped = False<br/>        for j in range(n-i-1):<br/>            if (nums[j] &gt; nums[j+1]):<br/>                #Swap the adjacent numbers to keep them in ascending order<br/>                nums[j], nums[j+1] = nums[j+1], nums[j]<br/>                swapped = True</span><span id="6632" class="ne md it na b gy nj ng l nh ni">        if not swapped:<br/>            break</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi oo"><img src="../Images/51373abe1be9373d0274e0fc0b716edc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*rm5Ylux499nktyWK.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">冒泡排序示例</p></figure><p id="d731" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated"><strong class="la iu">时间复杂度</strong></p><p id="cbf2" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">在最好的情况下，当传递的列表已经排序时，算法执行<em class="lu"> n </em> -1次操作，其顺序为<em class="lu"> n </em>。因此，它的最佳情况时间复杂度为ω(<em class="lu">n</em>)。</p><p id="6d61" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">在最坏的情况下，当列表中的项目按降序排列时，该算法按照<em class="lu"> n </em> 2的顺序执行多个操作。因此，冒泡排序的最坏情况时间复杂度为O( <em class="lu"> n </em> 2)。</p><p id="8308" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">算法的平均时间复杂度也是θ(<em class="lu">n</em>2)。</p><p id="83a3" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated"><strong class="la iu">空间复杂度</strong></p><p id="b15b" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">与选择排序类似，冒泡排序具有O(1)的常数空间复杂度。</p><h2 id="3b9f" class="ne md it bd me no np dn mi nq nr dp mm lh ns nt mo ll nu nv mq lp nw nx ms ny bi translated">插入排序</h2><p id="30e9" class="pw-post-body-paragraph ky kz it la b lb mu ju ld le mv jx lg lh mw lj lk ll mx ln lo lp my lr ls lt im bi translated">插入排序算法按照以下步骤对项目列表进行排序。</p><ol class=""><li id="51bd" class="oa ob it la b lb lc le lf lh oc ll od lp oe lt of og oh oi bi translated">从第0个索引开始循环访问数组。</li><li id="3d36" class="oa ob it la b lb oj le ok lh ol ll om lp on lt of og oh oi bi translated">检查当前项目是否小于其前一个项目。</li><li id="e7c3" class="oa ob it la b lb oj le ok lh ol ll om lp on lt of og oh oi bi translated">如果是，将当前项目与前一个项目进行比较。</li><li id="ee53" class="oa ob it la b lb oj le ok lh ol ll om lp on lt of og oh oi bi translated">继续此操作，直到找到小于或等于当前项目的项目。</li><li id="7cd0" class="oa ob it la b lb oj le ok lh ol ll om lp on lt of og oh oi bi translated">通过将较大的项目上移一个位置，将当前项目放在较小的项目旁边。</li></ol><pre class="kj kk kl km gt mz na nb nc aw nd bi"><span id="67c9" class="ne md it na b gy nf ng l nh ni">def insertion_sort(nums, n):<br/>    for i in range(1, n):<br/>        current = nums[i]<br/>        <br/>        #Check the previous items to find where current item fits in the sorting order<br/>        j = i-1<br/>        while j &gt;= 0 and nums[j] &gt; current:<br/>            nums[j+1] = nums[j]<br/>            j -= 1<br/>        nums[j+1] = current</span></pre><p id="2089" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated"><strong class="la iu">时间复杂度</strong></p><p id="0c6d" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">在最好的情况下，插入排序算法只需要<em class="lu"> n次</em>操作，因为列表已经被排序了。因此，它具有ω(<em class="lu">n</em>)的最佳情况时间复杂度。</p><p id="282b" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">在最坏的情况下，该算法需要完成以下数量的运算，其顺序为<em class="lu"> n </em> 2。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi oq"><img src="../Images/2fe43a0813ca1fa8bceebb8048e15986.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*1W1im8XLTFYR2Af7.png"/></div></div></figure><p id="119f" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">所以最坏情况的时间复杂度是O( <em class="lu"> n </em> 2)。</p><p id="edd3" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated"><strong class="la iu">空间复杂度</strong></p><p id="f6de" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">同样，由于该算法在不使用额外内存的情况下就地修改列表，所以它的空间复杂度为O(1)。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi oo"><img src="../Images/5f3dafa82ff286f3bccf789a7a14063e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*O2h50ZQtXirU6RUG.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">插入排序示例</p></figure><h2 id="762f" class="ne md it bd me no np dn mi nq nr dp mm lh ns nt mo ll nu nv mq lp nw nx ms ny bi translated">合并排序</h2><p id="759b" class="pw-post-body-paragraph ky kz it la b lb mu ju ld le mv jx lg lh mw lj lk ll mx ln lo lp my lr ls lt im bi translated">Merge sort将给定的列表分成更短的列表，并在将它们组合在一起之前对它们进行排序，以创建一个完全排序的列表。算法中涉及的步骤如下。</p><ol class=""><li id="a890" class="oa ob it la b lb lc le lf lh oc ll od lp oe lt of og oh oi bi translated">通过中间点将列表分成两半。</li><li id="190d" class="oa ob it la b lb oj le ok lh ol ll om lp on lt of og oh oi bi translated">分别对列表的前半部分和后半部分进行合并排序。</li><li id="5172" class="oa ob it la b lb oj le ok lh ol ll om lp on lt of og oh oi bi translated">合并排序后的两半，创建最终的排序列表。</li></ol><p id="e1de" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">正如您可能已经猜到的，merge sort是一种递归算法，它在对半列表上反复调用<code class="fe nk nl nm na b">mergeSort</code>函数，直到初始列表被分成单个项目。然后，它将这些项目按排序后的顺序重新合并。</p><pre class="kj kk kl km gt mz na nb nc aw nd bi"><span id="aa2c" class="ne md it na b gy nf ng l nh ni">def merge(arr, left, right):</span><span id="e92b" class="ne md it na b gy nj ng l nh ni">    i = j = k = 0</span><span id="b5ed" class="ne md it na b gy nj ng l nh ni">    #Compare the elements in the two lists starting from the first items<br/>    #Add the smallest item to the merged list <br/>    #Continue this until all items of one list are added<br/>    while i &lt; len(left) and j &lt; len(right):<br/>        if (left[i] &lt; right[j]):<br/>            arr[k] = left[i]<br/>            i += 1<br/>        else:<br/>            arr[k] = right[j]<br/>            j += 1<br/>        k += 1</span><span id="f0ce" class="ne md it na b gy nj ng l nh ni">    #Check if there are more items in left list and merge them in order<br/>    while i &lt; len(left):<br/>        arr[k] = left[i]<br/>        i += 1<br/>        k += 1</span><span id="93ca" class="ne md it na b gy nj ng l nh ni">    #Check if there are more items in right list and merge them in order<br/>    while j &lt; len(right):<br/>        arr[k] = right[j]<br/>        j += 1<br/>        k += 1<br/></span><span id="120c" class="ne md it na b gy nj ng l nh ni">def merge_sort(arr, n):<br/>    if (n &gt; 1):<br/>        mid = n//2<br/>        left = arr[:mid]<br/>        right = arr[mid:]</span><span id="06e1" class="ne md it na b gy nj ng l nh ni">        merge_sort(left, len(left))<br/>        merge_sort(right, len(right))</span><span id="f72f" class="ne md it na b gy nj ng l nh ni">        #Merge left and right lists in sorted order<br/>        merge(arr, left, right)</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi oo"><img src="../Images/098fe39258a41da792d10b7f990086c8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*ENrgf4J0bMmGmPD7.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">合并排序示例</p></figure><p id="e3e8" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated"><strong class="la iu">时间复杂度</strong></p><p id="eb4f" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">在最佳、最差和一般情况下，合并排序具有相同顺序的时间复杂性。让我们看看如何找到算法的这个顺序。</p><ul class=""><li id="39bf" class="oa ob it la b lb lc le lf lh oc ll od lp oe lt or og oh oi bi translated">归并排序算法将一个有<em class="lu"> n </em>个条目的列表一分为二，一直持续到有<em class="lu"> n </em>个有单个条目的列表。</li><li id="36ce" class="oa ob it la b lb oj le ok lh ol ll om lp on lt or og oh oi bi translated">如果<em class="lu"> n </em> =2 <em class="lu"> x </em>，这需要<em class="lu"> x </em>的除法数除以2才能得到基本级别。因此它创建了<em class="lu"> x </em>个级别，每个级别包含大小为<em class="lu"> n </em> /2、<em class="lu"> n </em> /4、…、<em class="lu"> n </em> /2 <em class="lu"> x </em> -1、<em class="lu"> n </em> /2 <em class="lu"> x </em>的数组。我们可以使用对数来计算<em class="lu"> x </em>的值。是log2 <em class="lu"> n </em>。</li><li id="f6e6" class="oa ob it la b lb oj le ok lh ol ll om lp on lt or og oh oi bi translated">如果2<em class="lu">x</em>+1&gt;T30】n&gt;2<em class="lu">x</em>，则需要<em class="lu"> x </em> +1的除法数除以2才能得到基级。这导致创建了<em class="lu"> x </em> +1个级别。我们可以将log2 <em class="lu"> n </em> +1的值向上取整，得到<em class="lu"> x </em> +1的值。</li><li id="5b32" class="oa ob it la b lb oj le ok lh ol ll om lp on lt or og oh oi bi translated">在每一级中，合并排序算法在将左列表和右列表合并在一起时，对单独列表中的每个项目迭代一次。因为总共有<em class="lu"> n </em>项，所以每一级都需要<em class="lu"> n </em>次运算才能完成合并。</li><li id="7ec1" class="oa ob it la b lb oj le ok lh ol ll om lp on lt or og oh oi bi translated">因为最多有log <em class="lu"> n </em> +1个级别，所以算法执行的操作总数是<em class="lu"> n </em> *( log <em class="lu"> n </em> +1)。按照<em class="lu"> n </em> *log <em class="lu"> n </em>的顺序。</li></ul><p id="37bb" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">因此，归并排序的最佳、最差、平均时间复杂度分别为ω(<em class="lu">n</em>* log<em class="lu">n</em>)、O( <em class="lu"> n </em> *log <em class="lu"> n </em>)、θ(<em class="lu">n</em>* log<em class="lu">n</em>)。</p><p id="f578" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated"><strong class="la iu">空间复杂度</strong></p><p id="786c" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">合并排序使用额外的<em class="lu"> n </em>空间来存储分割数组中的项目。因此，它在最好、最差、一般情况下的空间复杂度分别为ω(<em class="lu">n</em>)、O( <em class="lu"> n </em>)、θ(<em class="lu">n</em>)。</p><h2 id="09d8" class="ne md it bd me no np dn mi nq nr dp mm lh ns nt mo ll nu nv mq lp nw nx ms ny bi translated">线性搜索</h2><p id="3198" class="pw-post-body-paragraph ky kz it la b lb mu ju ld le mv jx lg lh mw lj lk ll mx ln lo lp my lr ls lt im bi translated">线性搜索算法遍历列表中的每一项，找出某一项是否存储在其中。</p><pre class="kj kk kl km gt mz na nb nc aw nd bi"><span id="d1a2" class="ne md it na b gy nf ng l nh ni">def linear_search(nums, n, k):<br/>    for i in range(n):<br/>        if k == nums[i]:<br/>            return i<br/>    return -1</span></pre><p id="aaf2" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated"><strong class="la iu">时间复杂度</strong></p><p id="ade0" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">在最坏的情况下，该算法遍历列表中的每个项目一次。因此，它的最坏情况时间复杂度为O( <em class="lu"> n </em>)。在最好的情况下，搜索完成一次搜索迭代，时间复杂度为O(1)。</p><p id="7f78" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated"><strong class="la iu">空间复杂度</strong></p><p id="fd24" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">线性搜索不使用额外的空间来存储项目。因此它的空间复杂度为O(1)。</p><h2 id="4d58" class="ne md it bd me no np dn mi nq nr dp mm lh ns nt mo ll nu nv mq lp nw nx ms ny bi translated">二进位检索</h2><p id="0d30" class="pw-post-body-paragraph ky kz it la b lb mu ju ld le mv jx lg lh mw lj lk ll mx ln lo lp my lr ls lt im bi translated">二进制搜索算法用于在排序的项目列表中查找给定的项目。它使用不同于线性搜索的机制来更快地完成搜索。</p><ol class=""><li id="4782" class="oa ob it la b lb lc le lf lh oc ll od lp oe lt of og oh oi bi translated">找到列表的中间项目，并将其与给定项目<em class="lu"> k </em>进行比较。</li><li id="31bd" class="oa ob it la b lb oj le ok lh ol ll om lp on lt of og oh oi bi translated">如果中间项等于<em class="lu"> k </em>，则算法完成。</li><li id="e2b1" class="oa ob it la b lb oj le ok lh ol ll om lp on lt of og oh oi bi translated">如果<em class="lu"> k </em>小于中间项，则对中间项左边的数组执行二分搜索法。</li><li id="fd61" class="oa ob it la b lb oj le ok lh ol ll om lp on lt of og oh oi bi translated">如果<em class="lu"> k </em>大于中间项，则对中间项右边的数组执行二分搜索法。</li><li id="5b4d" class="oa ob it la b lb oj le ok lh ol ll om lp on lt of og oh oi bi translated">递归地继续这个操作，直到找到<em class="lu"> k </em>或者确定<em class="lu"> k </em>不在列表中。</li></ol><pre class="kj kk kl km gt mz na nb nc aw nd bi"><span id="4ab7" class="ne md it na b gy nf ng l nh ni">def binary_search(nums, left, right, k):<br/>    if (left &lt;= right):<br/>        mid = left + (right - left)//2</span><span id="5736" class="ne md it na b gy nj ng l nh ni">        #Check if the mid item is equal to k<br/>        if (nums[mid] == k):<br/>            return mid</span><span id="422d" class="ne md it na b gy nj ng l nh ni">        #If k is smaller than the middle item, check the left half of the list<br/>        elif nums[mid] &gt; k:<br/>            return binary_search(nums, left, mid-1, k)<br/>        <br/>        #If k is lerger than the middle item, check the right half of the list<br/>        else:<br/>            return binary_search(nums, mid+1, right, k)<br/>    <br/>    return -1</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi oo"><img src="../Images/2ceb4b27e04877afb88a42e0cd0a21bb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*sdg0r40QNGKKlhV1.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">二分搜索法的例子</p></figure><p id="9c87" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated"><strong class="la iu">时间复杂度</strong></p><p id="3666" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">二分搜索法，类似于你在合并排序算法中看到的，使用分治法来解决这个问题。它将数组一分为二，并在数组的相关一侧搜索给定的项。最坏的情况下，算法最多将数组log <em class="lu"> n </em> +1次。因此，它的最坏情况时间复杂度为O(log <em class="lu"> n </em>)。</p><p id="298f" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">在最好的情况下，传递的列表的中间项必须是被搜索的项。因此，由于它在恒定时间内完成，最佳情况下的时间复杂度为ω(1)。</p><p id="df7b" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated"><strong class="la iu">空间复杂度</strong></p><p id="81bf" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">二分搜索法最好的空间复杂度是ω(1)。</p><p id="8cbc" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">最坏情况下的空间复杂度取决于实现。使用我们已经完成的递归实现，由于为每个递归调用在中间、左侧和右侧值存储额外的数据，二分搜索法具有O(log <em class="lu"> n </em>)的空间复杂度。迭代实现可以将复杂度降低到O(1)。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="765a" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">算法复杂性概述</h1><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi os"><img src="../Images/bab6f8fdab021a1f678478863017d4eb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*oux51DbxwEJE1zmH7Pnt8w.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">算法及其复杂性概述</p></figure><p id="73e8" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">如果你以前对算法的时间和空间复杂性感到困惑，我希望这篇文章至少在某种程度上帮助你解决了这种困惑。</p><p id="551e" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">感谢您的阅读。</p></div></div>    
</body>
</html>