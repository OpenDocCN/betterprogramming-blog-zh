<html>
<head>
<title>How To Make a Task List Using SwiftUI and Core Data</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何使用SwiftUI和核心数据制作任务列表</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/how-to-make-a-task-list-using-swiftui-and-core-data-a8ab6eaf0f58?source=collection_archive---------5-----------------------#2019-12-18">https://betterprogramming.pub/how-to-make-a-task-list-using-swiftui-and-core-data-a8ab6eaf0f58?source=collection_archive---------5-----------------------#2019-12-18</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="fce3" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">构建一个在核心数据中存储任务的任务列表应用程序</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/9e1cde194fc929959c01288f14b106a3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*kA5bZWiM_qmNJjGx0o1aYw.jpeg"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">照片由<a class="ae ky" href="https://unsplash.com/@emmamatthews?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">艾玛·马修斯数字内容制作</a>在<a class="ae ky" href="https://unsplash.com/s/photos/to-do-list?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>拍摄</p></figure><p id="b87b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">该应用程序将具有以下功能:</p><ul class=""><li id="5ff9" class="lv lw it lb b lc ld lf lg li lx lm ly lq lz lu ma mb mc md bi translated">添加任务</li><li id="13e3" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated">完成任务</li><li id="772a" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated">删除任务</li><li id="7cb5" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated">如果应用程序关闭，则保留数据</li></ul><p id="3530" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这是完成后的应用程序的外观:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi mj"><img src="../Images/8575c4a31c1e8334b32c9829b465bf44.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*vQ7M9s0jE7Rkh145"/></div></div></figure><p id="faa4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">完成的app可以在这个<a class="ae ky" href="https://github.com/maeganjwilson/taskList" rel="noopener ugc nofollow" target="_blank"> GitHub repo </a>上找到。</p></div><div class="ab cl mk ml hx mm" role="separator"><span class="mn bw bk mo mp mq"/><span class="mn bw bk mo mp mq"/><span class="mn bw bk mo mp"/></div><div class="im in io ip iq"><h1 id="5ee9" class="mr ms it bd mt mu mv mw mx my mz na nb jz nc ka nd kc ne kd nf kf ng kg nh ni bi translated">1.创建新的单页iOS应用程序</h1><p id="b6ed" class="pw-post-body-paragraph kz la it lb b lc nj ju le lf nk jx lh li nl lk ll lm nm lo lp lq nn ls lt lu im bi translated">为单视图iOS应用程序创建新的Xcode项目。</p><p id="f6d4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">选中SwiftUI框和使用核心数据框。</p></div><div class="ab cl mk ml hx mm" role="separator"><span class="mn bw bk mo mp mq"/><span class="mn bw bk mo mp mq"/><span class="mn bw bk mo mp"/></div><div class="im in io ip iq"><h1 id="e1b6" class="mr ms it bd mt mu mv mw mx my mz na nb jz nc ka nd kc ne kd nf kf ng kg nh ni bi translated">2.核心数据实体和属性</h1><p id="5501" class="pw-post-body-paragraph kz la it lb b lc nj ju le lf nk jx lh li nl lk ll lm nm lo lp lq nn ls lt lu im bi translated">我们需要做的第一件事是向核心数据模型添加一个实体。为此，打开<code class="fe no np nq nr b">ProjectName.xcdatamodeld</code>，其中<code class="fe no np nq nr b">ProjectName</code>是您在步骤1中调用的项目，并单击窗口底部的Add Entity。将新实体命名为<code class="fe no np nq nr b">Task</code>。</p><p id="1eb6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">下图高亮显示了检查器中要更改名称的位置。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi mj"><img src="../Images/9f17bac78ee604504bbf718e3e0a59c4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*tYIU9-MLuxcqoBQb"/></div></div></figure><h2 id="c929" class="ns ms it bd mt nt nu dn mx nv nw dp nb li nx ny nd lm nz oa nf lq ob oc nh od bi translated">2.1向任务实体添加属性</h2><p id="508c" class="pw-post-body-paragraph kz la it lb b lc nj ju le lf nk jx lh li nl lk ll lm nm lo lp lq nn ls lt lu im bi translated">接下来，我们需要<code class="fe no np nq nr b">Task</code>实体拥有存储以下信息的属性:</p><ul class=""><li id="cbf7" class="lv lw it lb b lc ld lf lg li lx lm ly lq lz lu ma mb mc md bi translated"><code class="fe no np nq nr b">id</code>:用作每个任务的唯一标识符</li><li id="8812" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated"><code class="fe no np nq nr b">name</code>:用户将调用的任务</li><li id="46b8" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated"><code class="fe no np nq nr b">isComplete</code>:定义任务是否完成</li><li id="59ae" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated"><code class="fe no np nq nr b">dateAdded</code>:知道任务是什么时候添加的</li></ul><p id="0dc6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">要给<code class="fe no np nq nr b">Task</code>添加属性，点击属性部分的+号，并给属性一个名称和类型。下面的GIF展示了如何做到这一点。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi oe"><img src="../Images/e059deedf87d0c8b1cca81dd756a25a3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*X2qkqBc0UaINVDMj"/></div></div></figure><p id="ed93" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">下表描述了每个属性以及与该属性关联的类型。</p><ul class=""><li id="cb80" class="lv lw it lb b lc ld lf lg li lx lm ly lq lz lu ma mb mc md bi translated"><code class="fe no np nq nr b">id</code> : UUID</li><li id="85cb" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated"><code class="fe no np nq nr b">name</code>:字符串</li><li id="3817" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated"><code class="fe no np nq nr b">isComplete</code>:布尔</li><li id="0493" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated"><code class="fe no np nq nr b">dateAdded</code>:日期</li></ul><p id="b31c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe no np nq nr b">ProjectName.xcdatamodeld</code>现在看起来应该如下图所示。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi of"><img src="../Images/97107ab7cb4900dece8a61ff80f9f681.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*yVboMOhQSiGH9_zq.png"/></div></div></figure><h2 id="1dcd" class="ns ms it bd mt nt nu dn mx nv nw dp nb li nx ny nd lm nz oa nf lq ob oc nh od bi translated">2.2添加新的Swift文件</h2><p id="00a8" class="pw-post-body-paragraph kz la it lb b lc nj ju le lf nk jx lh li nl lk ll lm nm lo lp lq nn ls lt lu im bi translated">现在，我们正在添加一个新的Swift文件，它将使<code class="fe no np nq nr b">Task</code>可识别，使任务列表更容易调用。</p><p id="7535" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">添加一个新的Swift文件，命名为<code class="fe no np nq nr b">Task+Extensions</code>。</p><p id="5690" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在文件中，添加以下内容:</p><pre class="kj kk kl km gt og nr oh oi aw oj bi"><span id="d9ab" class="ns ms it nr b gy ok ol l om on">extension Task: Identifiable {<br/>}</span></pre><p id="f0d6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">通过添加上面的代码，<code class="fe no np nq nr b">Task</code>类现在符合<code class="fe no np nq nr b">Identifiable</code>类。</p><h2 id="1b80" class="ns ms it bd mt nt nu dn mx nv nw dp nb li nx ny nd lm nz oa nf lq ob oc nh od bi translated">2.3将核心数据添加到<code class="fe no np nq nr b">ContentView.swift</code></h2><p id="63da" class="pw-post-body-paragraph kz la it lb b lc nj ju le lf nk jx lh li nl lk ll lm nm lo lp lq nn ls lt lu im bi translated">我们需要添加一个变量来访问我们的<code class="fe no np nq nr b">ContentView.swift</code>文件中的<code class="fe no np nq nr b">managedObjectContext</code>。</p><p id="2987" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">为此，打开<code class="fe no np nq nr b">ContentView.swift</code>文件，并在<code class="fe no np nq nr b">body</code>变量前添加<code class="fe no np nq nr b">@Environment(.\managedObjectContext) var context</code>。<code class="fe no np nq nr b">ContentView</code>现在应该是这样的:</p><pre class="kj kk kl km gt og nr oh oi aw oj bi"><span id="9f98" class="ns ms it nr b gy ok ol l om on">struct ContentView: View {<br/>    @Environment(\.managedObjectContext) var context</span><span id="d6bd" class="ns ms it nr b gy oo ol l om on">    var body: some View {<br/>        Text("Hello world!")<br/>    }<br/>}</span><span id="7336" class="ns ms it nr b gy oo ol l om on">struct ContentView_Previews: PreviewProvider {<br/>    static var previews: some View {<br/>        ContentView()<br/>    }<br/>}</span></pre><p id="e0bb" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们做了什么？</p><p id="ba57" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们将context声明为一个环境变量，这意味着该值将来自视图的环境。在这种情况下，它将来自第23到27行的<code class="fe no np nq nr b">SceneDelegate.swift</code>，在这里<code class="fe no np nq nr b">context</code>被声明，然后被赋予<code class="fe no np nq nr b">ContentView()</code>。</p></div><div class="ab cl mk ml hx mm" role="separator"><span class="mn bw bk mo mp mq"/><span class="mn bw bk mo mp mq"/><span class="mn bw bk mo mp"/></div><div class="im in io ip iq"><h1 id="9a18" class="mr ms it bd mt mu mv mw mx my mz na nb jz nc ka nd kc ne kd nf kf ng kg nh ni bi translated">3.是时候让UI工作了</h1><p id="6cee" class="pw-post-body-paragraph kz la it lb b lc nj ju le lf nk jx lh li nl lk ll lm nm lo lp lq nn ls lt lu im bi translated">我们现在将致力于<code class="fe no np nq nr b">ContentView.swift</code>中的用户界面。</p><h2 id="b68d" class="ns ms it bd mt nt nu dn mx nv nw dp nb li nx ny nd lm nz oa nf lq ob oc nh od bi translated">3.1添加一个<code class="fe no np nq nr b">TextField</code></h2><p id="8c4d" class="pw-post-body-paragraph kz la it lb b lc nj ju le lf nk jx lh li nl lk ll lm nm lo lp lq nn ls lt lu im bi translated">让我们从给应用程序添加一个<code class="fe no np nq nr b">TextField</code>开始。</p><p id="684e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">将<code class="fe no np nq nr b">Text(HelloWorld)</code>改为<code class="fe no np nq nr b">TextField(title: StringProtocol, text:Binding&lt;String&gt;)</code>。</p><p id="e91e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe no np nq nr b">TextField</code>需要两个属性:一个<code class="fe no np nq nr b">StringProtocol</code>和一个<code class="fe no np nq nr b">Binding&lt;String&gt;</code>。对于<code class="fe no np nq nr b">StringProtocol</code>，赋予其属性<code class="fe no np nq nr b">"Task Name"</code>。当<code class="fe no np nq nr b">TextField</code>为空时，任务名称将以浅灰色显示。</p><p id="8681" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在，我们仍然需要一个<code class="fe no np nq nr b">Binding&lt;String&gt;</code>。这可不像<code class="fe no np nq nr b">TextField</code>那么简单。我们需要为它声明一个变量。</p><p id="15ef" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在<code class="fe no np nq nr b">body</code>变量声明前添加<code class="fe no np nq nr b">@State private var taskName: String = ""</code>，然后做<code class="fe no np nq nr b">TextField</code>的第二个属性<code class="fe no np nq nr b">$taskName</code>。</p><p id="c57e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe no np nq nr b">ContentView.swift</code>现在应该是这样的:</p><pre class="kj kk kl km gt og nr oh oi aw oj bi"><span id="5199" class="ns ms it nr b gy ok ol l om on">struct ContentView: View {<br/>    @Environment(\.managedObjectContext) var context</span><span id="f998" class="ns ms it nr b gy oo ol l om on">    // this is the variable we added<br/>    @State private var taskName: String = ""</span><span id="41ec" class="ns ms it nr b gy oo ol l om on">    var body: some View {<br/>        // this is the TextField that we added<br/>        TextField("Task Name", text: $taskName)<br/>    }<br/>}</span><span id="1ed9" class="ns ms it nr b gy oo ol l om on">struct ContentView_Previews: PreviewProvider {<br/>    static var previews: some View {<br/>        ContentView()<br/>    }<br/>}</span></pre><p id="857a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">由于我们使用的是SwiftUI，如果你使用画布，你可以看到UI是什么样子，而不必在模拟器中运行应用程序。</p><p id="537c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们做了什么？</p><p id="8c29" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我将解释一下<code class="fe no np nq nr b">@State private var taskName: String = "" </code>的各个部分，以及为什么我们需要这样做。</p><p id="832c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">首先，这是通过使用<code class="fe no np nq nr b">@State</code>属性包装器声明一个<a class="ae ky" href="https://developer.apple.com/documentation/swiftui/state" rel="noopener ugc nofollow" target="_blank">状态</a>属性，因此<code class="fe no np nq nr b">taskName</code>是一个绑定值。一个状态属性将把值存储在<code class="fe no np nq nr b">taskName</code>中，并允许视图在值改变时进行观察和更新。</p><h2 id="7c4f" class="ns ms it bd mt nt nu dn mx nv nw dp nb li nx ny nd lm nz oa nf lq ob oc nh od bi translated">3.2将任务添加到核心数据</h2><p id="1b6e" class="pw-post-body-paragraph kz la it lb b lc nj ju le lf nk jx lh li nl lk ll lm nm lo lp lq nn ls lt lu im bi translated">首先，我们需要添加一个按钮，这样当用户完成输入后，他们就可以将任务添加到他们的列表中。</p><p id="1951" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">为此，我们将把<code class="fe no np nq nr b">TextField</code>包装在<code class="fe no np nq nr b">HStack</code>中，然后添加一个<code class="fe no np nq nr b">Button()</code>。添加按钮时，动作应该是<code class="fe no np nq nr b">self.addTask()</code>，按钮中的标签应该是<code class="fe no np nq nr b">Text("Add Task)</code>。</p><p id="c647" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">下面是<code class="fe no np nq nr b">body</code>中的代码现在应该是什么样子。</p><pre class="kj kk kl km gt og nr oh oi aw oj bi"><span id="241b" class="ns ms it nr b gy ok ol l om on">var body: some View {<br/>    HStack{<br/>        TextField("Task Name", text: $taskName)<br/>        Button(action: {<br/>            self.addTask()<br/>        }){<br/>            Text("Add Task")<br/>        }<br/>    }<br/>}</span></pre><p id="aec7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在，这导致Xcode给出错误“类型' ContentView '的值没有成员' addTask '”，所以这意味着我们必须添加函数<code class="fe no np nq nr b">addTask()</code>。</p><p id="1793" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在<code class="fe no np nq nr b">body</code>变量后，添加以下内容:</p><pre class="kj kk kl km gt og nr oh oi aw oj bi"><span id="a960" class="ns ms it nr b gy ok ol l om on">func addTask() {<br/>    let newTask = Task(context: context)<br/>    newTask.id = UUID()<br/>    newTask.isComplete = false<br/>    newTask.name = taskName<br/>    newTask.dateAdded = Date()</span><span id="2d3d" class="ns ms it nr b gy oo ol l om on">    do {<br/>        try context.save()<br/>    } catch {<br/>        print(error)<br/>    }<br/>}</span></pre><p id="dd6d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们做了什么？</p><p id="f313" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在<code class="fe no np nq nr b">addTask()</code>中，我们创建了一个新的<code class="fe no np nq nr b">Task</code>对象，然后赋予<code class="fe no np nq nr b">newTask</code>值各自的属性。然后，我们使用上下文中的<code class="fe no np nq nr b">save()</code>将其添加到核心数据中。</p><p id="caf0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这是目前为止用户界面的样子。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi op"><img src="../Images/0e65185e5c1554f66e262297a552d685.png" data-original-src="https://miro.medium.com/v2/resize:fit:1232/0*uFrsQN7Buf9D1uWh"/></div></figure><h2 id="b53c" class="ns ms it bd mt nt nu dn mx nv nw dp nb li nx ny nd lm nz oa nf lq ob oc nh od bi translated">3.3创建任务列表</h2><p id="6819" class="pw-post-body-paragraph kz la it lb b lc nj ju le lf nk jx lh li nl lk ll lm nm lo lp lq nn ls lt lu im bi translated">终于到了创建任务列表的时候了。</p><p id="2481" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">首先，我们需要发出一个获取请求来添加任务。下面是我们需要添加到<code class="fe no np nq nr b">ContentView</code>中的内容。</p><pre class="kj kk kl km gt og nr oh oi aw oj bi"><span id="b6e1" class="ns ms it nr b gy ok ol l om on">@FetchRequest(<br/>    entity: Task.entity(),<br/>    sortDescriptors: [NSSortDescriptor(keyPath: \Task.dateAdded, ascending: false)],<br/>    predicate: NSPredicate(format: "isComplete == %@", NSNumber(value: false))<br/>) var notCompletedTasks: FetchedResults&lt;Task&gt;</span></pre><p id="5ff3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在，我要把它分解一下。</p><ul class=""><li id="45e9" class="lv lw it lb b lc ld lf lg li lx lm ly lq lz lu ma mb mc md bi translated"><code class="fe no np nq nr b">entity</code>声明我们正在检索的核心数据实体</li><li id="5b80" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated"><code class="fe no np nq nr b">sortDescriptors</code>描述我们希望如何对实体进行排序</li><li id="8ee2" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated"><code class="fe no np nq nr b">predicate</code>充当过滤器</li></ul><p id="5d94" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">所以在上面的代码中，我们要求所有未完成的任务都按照日期排序——从最新到最早。</p><p id="b44c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">接下来，我们需要列出任务清单。让我们将<code class="fe no np nq nr b">HStack </code>嵌入到<code class="fe no np nq nr b">VStack</code>中。它应该是这样的:</p><pre class="kj kk kl km gt og nr oh oi aw oj bi"><span id="5491" class="ns ms it nr b gy ok ol l om on">VStack {<br/>    HStack {<br/>        // TEXTFIELD CODE HERE<br/>    }<br/>}</span></pre><p id="93f8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在，我们可以添加一个列表。在<code class="fe no np nq nr b">HStack</code>之后，添加以下内容:</p><pre class="kj kk kl km gt og nr oh oi aw oj bi"><span id="7e3c" class="ns ms it nr b gy ok ol l om on">List {<br/>    Text("Hi")<br/>}</span></pre><p id="3d0c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这在<code class="fe no np nq nr b">TextField</code>下面添加了一个列表，使UI看起来像这样。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi oq"><img src="../Images/63dd8cb9d28c91d9384bbd2d6232e466.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*TLDtVF_0SEmSD9Ti"/></div></div></figure><p id="cd04" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">接下来，无论我们有多少任务，我们都要重复“嗨”。像这样将<code class="fe no np nq nr b">Text("Hi")</code>嵌入<code class="fe no np nq nr b">ForEach</code>中:</p><pre class="kj kk kl km gt og nr oh oi aw oj bi"><span id="d29b" class="ns ms it nr b gy ok ol l om on">ForEach(notCompletedTasks){ task in<br/>    Text("Hi")<br/>}</span></pre><p id="8068" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们不必在<code class="fe no np nq nr b">ForEach </code>中为<code class="fe no np nq nr b">notCompletedTasks</code>指定<code class="fe no np nq nr b">id</code>，因为<code class="fe no np nq nr b">Task</code>符合<code class="fe no np nq nr b">Identifiable</code>，这要感谢我们在步骤2.3中的工作。</p><p id="19a9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果你运行应用程序，然后输入一个任务名称。点击添加任务将会产生另一行“嗨”</p><p id="47f1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们为<code class="fe no np nq nr b">TaskRow</code>视图创建一个新的<code class="fe no np nq nr b">struct</code>，它将接受<code class="fe no np nq nr b">ContentView.swift</code>中的任务。在<code class="fe no np nq nr b">ContentView()</code>上方，添加以下内容:</p><pre class="kj kk kl km gt og nr oh oi aw oj bi"><span id="9e5d" class="ns ms it nr b gy ok ol l om on">struct TaskRow: View {<br/>    var task: Task</span><span id="e928" class="ns ms it nr b gy oo ol l om on">    var body: some View {<br/>        Text(task.name ?? "No name given")<br/>    }<br/>}</span></pre><p id="0860" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在<code class="fe no np nq nr b">Text</code>中，你会看到我们必须使用零合并操作符<code class="fe no np nq nr b">??</code>来给出一个默认值。我们这样做的原因是因为<code class="fe no np nq nr b">Task </code>属性的值是可选的，可能没有值。</p><p id="91e5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在，在<code class="fe no np nq nr b">ForEach</code>内部，用<code class="fe no np nq nr b">TaskRow(task)</code>替换<code class="fe no np nq nr b">Text</code>。<code class="fe no np nq nr b">ContentView.swift</code>应该有以下代码。</p><pre class="kj kk kl km gt og nr oh oi aw oj bi"><span id="60fe" class="ns ms it nr b gy ok ol l om on">import SwiftUI</span><span id="2e46" class="ns ms it nr b gy oo ol l om on">struct TaskRow: View {<br/>    var task: Task</span><span id="1f7b" class="ns ms it nr b gy oo ol l om on">    var body: some View {<br/>        Text(task.name ?? "No name given")<br/>    }<br/>}</span><span id="8a43" class="ns ms it nr b gy oo ol l om on">struct ContentView: View {<br/>    @Environment(\.managedObjectContext) var context</span><span id="5052" class="ns ms it nr b gy oo ol l om on">    @FetchRequest(<br/>        entity: Task.entity(),<br/>        sortDescriptors: [NSSortDescriptor(keyPath: \Task.dateAdded, ascending: false)],<br/>        predicate: NSPredicate(format: "isComplete == %@", NSNumber(value: false))<br/>    ) var notCompletedTasks: FetchedResults&lt;Task&gt;</span><span id="7a9f" class="ns ms it nr b gy oo ol l om on">    @State private var taskName: String = ""</span><span id="3c8e" class="ns ms it nr b gy oo ol l om on">    var body: some View {<br/>        VStack {<br/>            HStack{<br/>                TextField("Task Name", text: $taskName)<br/>                Button(action: {<br/>                    self.addTask()<br/>                }){<br/>                    Text("Add Task")<br/>                }<br/>            }<br/>            List {<br/>                ForEach(notCompletedTasks){ task in<br/>                    TaskRow(task: task)<br/>                }<br/>            }<br/>        }<br/>    }</span><span id="4447" class="ns ms it nr b gy oo ol l om on">    func addTask() {<br/>        let newTask = Task(context: context)<br/>        newTask.id = UUID()<br/>        newTask.isComplete = false<br/>        newTask.name = taskName<br/>        newTask.dateAdded = Date()</span><span id="6fc5" class="ns ms it nr b gy oo ol l om on">        do {<br/>            try context.save()<br/>        } catch {<br/>            print(error)<br/>        }<br/>    }<br/>}</span><span id="263b" class="ns ms it nr b gy oo ol l om on">struct ContentView_Previews: PreviewProvider {<br/>    static var previews: some View {<br/>        ContentView()<br/>    }<br/>}</span></pre><p id="de1a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这是应用程序现在应该如何工作。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi or"><img src="../Images/07f63decabc6f18fd55ba99967fcfd05.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*U1yQRK9kNDkLYEnr"/></div></div></figure></div><div class="ab cl mk ml hx mm" role="separator"><span class="mn bw bk mo mp mq"/><span class="mn bw bk mo mp mq"/><span class="mn bw bk mo mp"/></div><div class="im in io ip iq"><h1 id="baa5" class="mr ms it bd mt mu mv mw mx my mz na nb jz nc ka nd kc ne kd nf kf ng kg nh ni bi translated">4.将任务标记为完成</h1><p id="45d8" class="pw-post-body-paragraph kz la it lb b lc nj ju le lf nk jx lh li nl lk ll lm nm lo lp lq nn ls lt lu im bi translated">现在，我们将任务标记为完成，这将使任务从列表中消失。</p><p id="4ac0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">首先，我们将把<code class="fe no np nq nr b">TaskRow</code>嵌入到一个<code class="fe no np nq nr b">Button</code>中，按钮的动作将是<code class="fe no np nq nr b">self.updateTask(task)</code>。现在看起来像这样。</p><pre class="kj kk kl km gt og nr oh oi aw oj bi"><span id="d8f6" class="ns ms it nr b gy ok ol l om on">Button(action: {<br/>    self.updateTask(task)<br/>}){<br/>    TaskRow(task: task)<br/>}</span></pre><p id="ab5b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">接下来，我们需要创建一个名为<code class="fe no np nq nr b">updateTask</code>的函数，这样我们就可以更新任务并将其标记为完成。</p><p id="9a31" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在<code class="fe no np nq nr b">addTask</code>之后，让我们加上<code class="fe no np nq nr b">func updateTask(_ task: task){}</code>。使用<code class="fe no np nq nr b">_</code>表示我们可以在调用函数时忽略参数标签。如果你想了解更多关于参数标签的内容，点击这里阅读我的帖子。接下来，让我们添加函数的内部。</p><pre class="kj kk kl km gt og nr oh oi aw oj bi"><span id="bf9b" class="ns ms it nr b gy ok ol l om on">let isComplete = true<br/>let taskID = task.id! as NSUUID<br/>let fetchRequest: NSFetchRequest&lt;NSFetchRequestResult&gt; = NSFetchRequest(entityName: "Task")<br/>fetchRequest.predicate = NSPredicate(format: "id == %@", taskID as CVarArg)<br/>fetchRequest.fetchLimit = 1<br/>do {<br/>    let test = try context.fetch(fetchRequest)<br/>    let taskUpdate = test[0] as! NSManagedObject<br/>    taskUpdate.setValue(isComplete, forKey: "isComplete")<br/>} catch {<br/>    print(error)<br/>}</span></pre><p id="5075" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们深入研究一下。我们做的第一件事是为任务的新值<code class="fe no np nq nr b">isComplete</code>设置一个常数。然后，我们将任务的<code class="fe no np nq nr b">id</code>设置为一个常量，以便在谓词中使用。接下来，我们需要创建一个获取我们正在更新的特定任务的fetch请求。然后，我们执行更新。</p><p id="35bb" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在，如果你运行应用程序，应用程序将允许你添加一个任务，然后点击它以将其标记为完成。因为我们只使用列表中未完成的任务，所以已完成的任务会从列表中消失。</p><p id="0e12" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">下面的GIF展示了最终的app。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi or"><img src="../Images/3916a9fe38657b724178bc9908a16022.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*xpexLFmT4ff5a1LX"/></div></div></figure></div></div>    
</body>
</html>