<html>
<head>
<title>The Key to Creating Docker Images: Dockerfile Keywords</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">创建Docker图像的关键:Docker文件关键字</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/the-key-to-creating-docker-images-dockerfile-keywords-57f25d7e5fa6?source=collection_archive---------5-----------------------#2020-07-20">https://betterprogramming.pub/the-key-to-creating-docker-images-dockerfile-keywords-57f25d7e5fa6?source=collection_archive---------5-----------------------#2020-07-20</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="3bf4" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">用Angular中的一个例子理解Dockerfile关键字</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/927cf8b9af9405fa949bb54f74c2b120.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*MHR-gpbF9rT4yN41BFYorw.jpeg"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">照片由<a class="ae ky" href="https://unsplash.com/@thefallofmath?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">乌帕德克·马特米</a>在<a class="ae ky" href="https://unsplash.com/s/photos/container?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄。</p></figure><p id="47ce" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">码头工人席卷了我们的行业。它革新并简化了我们运送、部署和设置软件开发环境的方式。</p><p id="364c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在本文中，我将解释大多数Docker图片中使用的主要Docker关键字。为了实用起见，我们将创建一个角度应用程序的Docker图像。在本文结束时，您应该已经掌握了相关知识，能够:</p><ul class=""><li id="eb25" class="lv lw it lb b lc ld lf lg li lx lm ly lq lz lu ma mb mc md bi translated">创建您自己的自定义Docker图像。</li><li id="031e" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated">运行您的Docker图像。</li><li id="b85f" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated">将您的Docker图像推送到注册表。</li></ul></div><div class="ab cl mj mk hx ml" role="separator"><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo"/></div><div class="im in io ip iq"><h1 id="ce57" class="mq mr it bd ms mt mu mv mw mx my mz na jz nb ka nc kc nd kd ne kf nf kg ng nh bi translated">创建角度项目</h1><p id="379c" class="pw-post-body-paragraph kz la it lb b lc ni ju le lf nj jx lh li nk lk ll lm nl lo lp lq nm ls lt lu im bi translated">要通过名为angular-docker的CLI创建Angular项目，只需在命令提示符下键入以下内容:</p><pre class="kj kk kl km gt nn no np nq aw nr bi"><span id="1171" class="ns mr it no b gy nt nu l nv nw">$ ng new angular-docker</span></pre><p id="6feb" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">只需在随后出现的提示中按回车键，就可以使用默认设置。</p></div><div class="ab cl mj mk hx ml" role="separator"><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo"/></div><div class="im in io ip iq"><h1 id="a30b" class="mq mr it bd ms mt mu mv mw mx my mz na jz nb ka nc kc nd kd ne kf nf kg ng nh bi translated">添加Dockerfile</h1><p id="d05a" class="pw-post-body-paragraph kz la it lb b lc ni ju le lf nj jx lh li nk lk ll lm nl lo lp lq nm ls lt lu im bi translated">将名为<code class="fe nx ny nz no b">Dockerfile</code>的文件添加到新创建的Angular项目的根目录中。注意:文件名没有扩展名。</p><p id="a8af" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu"><em class="oa"/></strong>Docker文件包含构建Docker映像的指令，还定义了执行容器的入口点(即映像的运行实例)。</p><p id="041b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">将Docker文件中的每一行代码想象成一个层，在这个层中，您给出了构建或运行Docker映像的相关指令。</p><p id="68ae" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在，复制下面的代码行，并将它们粘贴到新创建的docker文件中:</p><pre class="kj kk kl km gt nn no np nq aw nr bi"><span id="74eb" class="ns mr it no b gy nt nu l nv nw"># Comment can be placed here.<br/>FROM node:10.21.0-alpine as builder<br/>WORKDIR /app<br/>COPY package.json package-lock.json ./<br/>RUN npm install<br/>COPY . .<br/>RUN npm run build --prod</span><span id="e534" class="ns mr it no b gy ob nu l nv nw">FROM nginx:1.16.0-alpine as server<br/>COPY --from=builder /app/dist/angular-docker /usr/share/nginx/html<br/>EXPOSE 80<br/>CMD ["nginx", "-g", "daemon off;"]</span></pre></div><div class="ab cl mj mk hx ml" role="separator"><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo"/></div><div class="im in io ip iq"><h1 id="2e9e" class="mq mr it bd ms mt mu mv mw mx my mz na jz nb ka nc kc nd kd ne kf nf kg ng nh bi translated">解释的关键字</h1><p id="a18a" class="pw-post-body-paragraph kz la it lb b lc ni ju le lf nj jx lh li nk lk ll lm nl lo lp lq nm ls lt lu im bi translated">按照惯例，Docker使用所有大写字母作为Docker关键字，正如您在上面的文件中看到的那样。我强烈建议你坚持这样做。</p><h2 id="e514" class="ns mr it bd ms oc od dn mw oe of dp na li og oh nc lm oi oj ne lq ok ol ng om bi translated">评论</h2><p id="655b" class="pw-post-body-paragraph kz la it lb b lc ni ju le lf nj jx lh li nk lk ll lm nl lo lp lq nm ls lt lu im bi translated">在Dockerfile中，<code class="fe nx ny nz no b"><strong class="lb iu"><em class="oa">#</em></strong></code> <strong class="lb iu"> <em class="oa"> </em> </strong>(散列)字符代表一行注释。请参见上面Dockerfile文件第一行中的示例注释。</p><h2 id="518d" class="ns mr it bd ms oc od dn mw oe of dp na li og oh nc lm oi oj ne lq ok ol ng om bi translated">1.从</h2><p id="05d1" class="pw-post-body-paragraph kz la it lb b lc ni ju le lf nj jx lh li nk lk ll lm nl lo lp lq nm ls lt lu im bi translated"><code class="fe nx ny nz no b">FROM</code>关键字指定了我们希望在其上构建图像的基础图像。您会发现，大多数Docker图像都以关键字<code class="fe nx ny nz no b">FROM</code>开头。这里的核心概念是不要重新发明轮子。有很多官方支持的基础映像，所以在它们的基础上构建。</p><pre class="kj kk kl km gt nn no np nq aw nr bi"><span id="44b8" class="ns mr it no b gy nt nu l nv nw">FROM node:10.21.0-alpine as builder</span></pre><p id="f64d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在docker文件中，我们指定了两个基本映像。上面的关键字<code class="fe nx ny nz no b">FROM</code>只是说我们将使用Node-alpine作为我们的图像所基于的基础图像。我们用名称<code class="fe nx ny nz no b">builder</code>标记它，因为我们将主要使用它来构建我们的应用程序。</p><p id="60ae" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在docker文件的后面，我们还指定了另一个基础图像，我们将使用它来服务我们的应用程序(标记为<code class="fe nx ny nz no b">server</code>)。它基于流行的NGINX服务器。</p><pre class="kj kk kl km gt nn no np nq aw nr bi"><span id="ec6b" class="ns mr it no b gy nt nu l nv nw">FROM nginx:1.16.0-alpine as server</span></pre><h2 id="482b" class="ns mr it bd ms oc od dn mw oe of dp na li og oh nc lm oi oj ne lq ok ol ng om bi translated">2.工作方向</h2><p id="c446" class="pw-post-body-paragraph kz la it lb b lc ni ju le lf nj jx lh li nk lk ll lm nl lo lp lq nm ls lt lu im bi translated"><code class="fe nx ny nz no b">WORKDIR</code>在我们构建的图像中设置工作目录或上下文。</p><p id="d8b0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在本例中，我们用下面的语句将工作目录设置为映像中的<code class="fe nx ny nz no b">app</code>文件夹:</p><pre class="kj kk kl km gt nn no np nq aw nr bi"><span id="2d82" class="ns mr it no b gy nt nu l nv nw">WORKDIR /app</span></pre><p id="7953" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">一旦我们设置了上下文，所有后续的命令都在指定上下文的根目录下运行，除非另有说明。在本例中，它是<code class="fe nx ny nz no b">app</code> <strong class="lb iu"> <em class="oa"> </em> </strong>目录。</p><h2 id="b02b" class="ns mr it bd ms oc od dn mw oe of dp na li og oh nc lm oi oj ne lq ok ol ng om bi translated">3.复制</h2><p id="6c58" class="pw-post-body-paragraph kz la it lb b lc ni ju le lf nj jx lh li nk lk ll lm nl lo lp lq nm ls lt lu im bi translated">关键字<code class="fe nx ny nz no b">COPY</code>几乎是不言自明的。它只是将内容从一个文件夹复制到另一个文件夹中。为此，您可以指定源和目标，或者指定要复制的文件和映像中的目标文件夹。</p><p id="cdd7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">从上面的Dockerfile文件中，我们注意到<code class="fe nx ny nz no b">COPY</code>关键字出现了几次。</p><p id="b3a5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们第一次使用<code class="fe nx ny nz no b">COPY</code>关键字如下:</p><pre class="kj kk kl km gt nn no np nq aw nr bi"><span id="9d79" class="ns mr it no b gy nt nu l nv nw">COPY package.json package-lock.json ./</span></pre><p id="3003" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这里，我们显式地指定了要复制到映像中的文件。我们将应用程序中的<code class="fe nx ny nz no b">package.json</code>和<code class="fe nx ny nz no b">package-lock.json</code>文件复制到映像的工作目录中，即<code class="fe nx ny nz no b">app</code>。</p><p id="7844" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">第二次，我们使用<code class="fe nx ny nz no b">COPY</code>关键字将所有源代码从我们的应用程序根文件夹复制到Docker images的工作目录(<code class="fe nx ny nz no b">app</code>):</p><pre class="kj kk kl km gt nn no np nq aw nr bi"><span id="b58e" class="ns mr it no b gy nt nu l nv nw">COPY . .</span></pre><p id="7dcd" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在Dockerfile文件的末尾，我们还有一个<code class="fe nx ny nz no b">COPY</code>关键字。在这里，我们使用它从构建阶段创建的<code class="fe nx ny nz no b">dist</code>文件夹中复制所有内容，并将其转储到NGINX服务器HTML目录中:</p><pre class="kj kk kl km gt nn no np nq aw nr bi"><span id="b673" class="ns mr it no b gy nt nu l nv nw">COPY --from=builder /app/dist/angular-docker /usr/share/nginx/html</span></pre><p id="50ed" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">除了COPY关键字，docker还提供了ADD关键字。它可以用于从HTTP URL复制zip文件或内容。</p><h2 id="c7c5" class="ns mr it bd ms oc od dn mw oe of dp na li og oh nc lm oi oj ne lq ok ol ng om bi translated">4.奔跑</h2><p id="a91e" class="pw-post-body-paragraph kz la it lb b lc ni ju le lf nj jx lh li nk lk ll lm nl lo lp lq nm ls lt lu im bi translated">如果您想运行一个特定的Linux命令，那么<code class="fe nx ny nz no b">RUN</code>关键字就是您要找的。在上面的Dockerfile文件中，<code class="fe nx ny nz no b">RUN</code>关键字被使用了两次。</p><p id="d66e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">首先，通过运行<code class="fe nx ny nz no b">npm install</code>命令，在Docker映像的工作上下文中恢复npm依赖关系:</p><pre class="kj kk kl km gt nn no np nq aw nr bi"><span id="283e" class="ns mr it no b gy nt nu l nv nw">RUN npm install</span></pre><p id="42fd" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">稍后，<code class="fe nx ny nz no b">RUN</code>关键字用于在应用程序映像中进行生产构建:</p><pre class="kj kk kl km gt nn no np nq aw nr bi"><span id="ca37" class="ns mr it no b gy nt nu l nv nw">RUN npm run build --prod</span></pre><h2 id="a7f6" class="ns mr it bd ms oc od dn mw oe of dp na li og oh nc lm oi oj ne lq ok ol ng om bi translated">5.揭露</h2><p id="5507" class="pw-post-body-paragraph kz la it lb b lc ni ju le lf nj jx lh li nk lk ll lm nl lo lp lq nm ls lt lu im bi translated"><code class="fe nx ny nz no b">EXPOSE</code>关键字用于向外界公开Docker映像内部的端口:</p><pre class="kj kk kl km gt nn no np nq aw nr bi"><span id="f6b7" class="ns mr it no b gy nt nu l nv nw">EXPOSE 80</span></pre><p id="2832" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在本例中，我们公开了端口80上的Docker映像，我们可以在运行容器时使用它。</p><h2 id="932e" class="ns mr it bd ms oc od dn mw oe of dp na li og oh nc lm oi oj ne lq ok ol ng om bi translated">6.煤矿管理局</h2><p id="32b7" class="pw-post-body-paragraph kz la it lb b lc ni ju le lf nj jx lh li nk lk ll lm nl lo lp lq nm ls lt lu im bi translated"><code class="fe nx ny nz no b">CMD</code>关键字有点类似于上面讨论的<code class="fe nx ny nz no b">RUN</code>关键字。它还用于运行Linux命令。但是与运行构建映像命令的<code class="fe nx ny nz no b">RUN</code>关键字不同的是，<code class="fe nx ny nz no b">CMD</code>关键字用于在容器启动时运行Linux命令(即在一个活动映像中)。</p><p id="e162" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">此外，Docker还提供了<code class="fe nx ny nz no b">ENTRYPOINT</code>关键字，可以用来代替<code class="fe nx ny nz no b">CMD</code>关键字，也可以和它一起使用。</p><p id="e002" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">关于<code class="fe nx ny nz no b">CMD</code>和<code class="fe nx ny nz no b">ENTRYPOINT</code>关键词的更详细讨论，请查看<a class="ae ky" href="https://medium.com/bb-tutorials-and-thoughts/docker-entrypoint-vs-cmd-8934cfdf78f3" rel="noopener">Bhargav Bachina</a>撰写的这篇文章。</p><pre class="kj kk kl km gt nn no np nq aw nr bi"><span id="d34f" class="ns mr it no b gy nt nu l nv nw">CMD ["nginx", "-g", "daemon off;"]</span></pre><p id="0005" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">当Docker映像运行时，上面的命令将启动NGINX服务器，并提供生产版本中的静态文件。</p></div><div class="ab cl mj mk hx ml" role="separator"><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo"/></div><div class="im in io ip iq"><h1 id="d9e8" class="mq mr it bd ms mt mu mv mw mx my mz na jz nb ka nc kc nd kd ne kf nf kg ng nh bi translated">构建图像</h1><p id="d4a9" class="pw-post-body-paragraph kz la it lb b lc ni ju le lf nj jx lh li nk lk ll lm nl lo lp lq nm ls lt lu im bi translated">最后，我们可以基于上面的Docker文件构建我们的Docker映像。我们将简单地运行以下命令:</p><pre class="kj kk kl km gt nn no np nq aw nr bi"><span id="f415" class="ns mr it no b gy nt nu l nv nw">$ docker build -t mwizak/angular-docker -f Dockerfile .</span></pre><p id="2e47" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在本例中，我们用名称<code class="fe nx ny nz no b">mwizak/angular-docker</code>标记了Docker图像。此外，我们指定Dockerfile文件指令的位置。</p><p id="9eb1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">注意:<code class="fe nx ny nz no b">mwizak</code>是我的docker注册表的名称。你可以使用它或者用你喜欢的任何名字来代替它。</p><p id="0f69" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">映像构建完成后，您可以使用以下命令检查它是否在本地Docker映像中列出:</p><pre class="kj kk kl km gt nn no np nq aw nr bi"><span id="41c7" class="ns mr it no b gy nt nu l nv nw">$ docker images</span></pre><p id="4a40" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">您应该得到类似下面的输出。新创建的图像以红色突出显示:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi op"><img src="../Images/cfcb05d65a83216e3e114f858a52be9c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*iRb-S3fTHWTCiKF92X9p1Q.png"/></div></div></figure></div><div class="ab cl mj mk hx ml" role="separator"><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo"/></div><div class="im in io ip iq"><h1 id="eabb" class="mq mr it bd ms mt mu mv mw mx my mz na jz nb ka nc kc nd kd ne kf nf kg ng nh bi translated">运行图像</h1><p id="425f" class="pw-post-body-paragraph kz la it lb b lc ni ju le lf nj jx lh li nk lk ll lm nl lo lp lq nm ls lt lu im bi translated">为了运行新的映像，我们将使用它的映像名称。只需运行下面的命令:</p><pre class="kj kk kl km gt nn no np nq aw nr bi"><span id="381f" class="ns mr it no b gy nt nu l nv nw">$ docker run -ti --rm -p 8080:80 mwizak/angular-docker </span></pre><p id="845b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们已经指定Docker图像应用程序应该在HTTP端口8080上运行，该端口映射到图像内部的端口80。</p><p id="83cd" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在你的浏览器中进入<a class="ae ky" rel="noopener ugc nofollow" target="_blank" href="/localhost:8080/"> http:localhost:8080/ </a>，你会发现你的Angular应用程序作为Docker容器运行。</p></div><div class="ab cl mj mk hx ml" role="separator"><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo"/></div><div class="im in io ip iq"><h1 id="efb7" class="mq mr it bd ms mt mu mv mw mx my mz na jz nb ka nc kc nd kd ne kf nf kg ng nh bi translated">将图像推送到注册表</h1><p id="0766" class="pw-post-body-paragraph kz la it lb b lc ni ju le lf nj jx lh li nk lk ll lm nl lo lp lq nm ls lt lu im bi translated">这个过程对于创建Docker映像来说并不是必需的，但是如果您想要轻松地共享您新创建的Docker映像，您可以将它推送到Docker注册表，以便人们在本地PC上获取和运行。</p><p id="5b3c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在我的例子中，我在Docker Hub上有一个注册中心，但它可能在任何地方(Azure、AWS等)。).</p><p id="b173" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">要将图像推送到Docker Hub，您首先必须登录您的帐户。运行命令:</p><pre class="kj kk kl km gt nn no np nq aw nr bi"><span id="d723" class="ns mr it no b gy nt nu l nv nw"> $ docker login</span></pre><p id="0707" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">通过身份验证后，您可以使用以下命令将映像推送到注册表中:</p><pre class="kj kk kl km gt nn no np nq aw nr bi"><span id="cb55" class="ns mr it no b gy nt nu l nv nw">$ docker push mwizak/angular-docker</span></pre><p id="7606" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">其中<code class="fe nx ny nz no b">mwizak</code>是您的Docker Hub注册帐户的名称。</p><p id="5334" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">登录您的Docker hub，图像应如下所示:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi oq"><img src="../Images/31b9fd3a18817909d795d936f94d3972.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*HMNdVZWAnBE8WrK2oMN2GQ.png"/></div></div></figure></div><div class="ab cl mj mk hx ml" role="separator"><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo"/></div><div class="im in io ip iq"><h1 id="c9e3" class="mq mr it bd ms mt mu mv mw mx my mz na jz nb ka nc kc nd kd ne kf nf kg ng nh bi translated">结论</h1><p id="d7fb" class="pw-post-body-paragraph kz la it lb b lc ni ju le lf nj jx lh li nk lk ll lm nl lo lp lq nm ls lt lu im bi translated">在本文中，我们创建了一个Angular应用程序，并将其打包在一个Docker映像中。我们使用Node-alpine构建图像应用程序，然后使用NGINX服务静态文件。</p><p id="1c53" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">之后，我们在一个容器中运行新创建的映像，然后将它推送到Docker Hub注册中心。</p><p id="90f1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">关于Docker的进一步阅读，请查看诺兰·格雷斯的这个<a class="ae ky" href="https://medium.com/pintail-labs/docker-series-what-is-docker-9eddca88f434" rel="noopener"> Docker系列</a>。</p></div></div>    
</body>
</html>