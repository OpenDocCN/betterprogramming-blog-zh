<html>
<head>
<title>The TypeScript 4.0 Beta Is Here</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">TypeScript 4.0测试版在这里</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/the-typescript-4-0-beta-is-here-c243358fe361?source=collection_archive---------5-----------------------#2020-07-10">https://betterprogramming.pub/the-typescript-4-0-beta-is-here-c243358fe361?source=collection_archive---------5-----------------------#2020-07-10</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="66f4" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">让我们探索一下TypeScript 4.0中令人兴奋的特性</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/e888dd422e64217d760d0499b6791de3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*IPrvRwYpLo0CRZCm"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">照片由<a class="ae ky" href="https://unsplash.com/@gcalebjones?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">凯勒·琼斯</a>在<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</p></figure><p id="193b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在我之前的<a class="ae ky" href="https://medium.com/better-programming/whats-new-in-typescript-3-9-70e3d2eabe26" rel="noopener">文章</a>中，我谈到了TypeScript版本3.9中的新特性。今天，我将窥视2020年6月25日发布的TypeScript 4.0测试版。在这个测试版中，我们第一次使用了TypeScript4.0。虽然这带来了一个新的主要版本，但并没有比平常大得多的突破性变化。所以让我们来看看这个版本有什么新功能。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="de13" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">标记元组元素</h1><p id="6f4c" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">这种语言特性改变了元组的定义方式。以前，元组定义如下:</p><pre class="kj kk kl km gt mz na nb nc aw nd bi"><span id="3312" class="ne md it na b gy nf ng l nh ni">function tuple(...args: [string, number]): void {<br/>    // ...<br/>}</span></pre><p id="c166" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在上面的例子中，第一个和第二个元素没有参数名。虽然这些对类型检查没有影响，但是元组位置上缺少标签会使它们更难使用——更难传达我们的意图。</p><p id="e846" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">作为对此的解决方案，TypeScrip 4.0引入了带标签的元组。</p><pre class="kj kk kl km gt mz na nb nc aw nd bi"><span id="ec41" class="ne md it na b gy nf ng l nh ni">type Segment = [length: number, count: number];</span></pre><p id="13e8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">但是如果你要标记一个元素，你必须标记元组中的所有元素。如果没有，您将收到一个错误。</p><pre class="kj kk kl km gt mz na nb nc aw nd bi"><span id="2743" class="ne md it na b gy nf ng l nh ni">type Segment = [first: string, number];<br/>//                         ~~~~~~<br/>// error! Tuple members must all have names or all not have names.</span></pre></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="7bc0" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">从构造函数推断类属性</h1><p id="2101" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">如果我们在<code class="fe nj nk nl na b">noImplicitAny</code>模式下配置TypeScript，<strong class="lb iu"><em class="nm"/></strong>TypeScript 4.0可以使用控制流分析来确定类中属性的类型。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nn no l"/></div></figure><p id="6021" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在以前版本的TypeScript中，上述代码将导致错误。但是4.0版本会编译，TypeScript会推断出<code class="fe nj nk nl na b">x</code>的类型是<code class="fe nj nk nl na b">string</code> <strong class="lb iu"> <em class="nm"> </em> </strong>还是<code class="fe nj nk nl na b">number</code>。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="4b53" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">短路赋值运算符</h1><p id="99e4" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">我相信您一定见过许多语言中的复合赋值运算符。复合赋值运算符将一个运算符应用于两个参数，然后将结果赋给左侧。以下是一些例子:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nn no l"/></div></figure><p id="c37a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">但是有三个明显的例外:逻辑<em class="nm">和</em> ( <code class="fe nj nk nl na b">&amp;&amp;</code>)、逻辑<em class="nm">或</em> ( <code class="fe nj nk nl na b">||</code>)以及无效合并(<code class="fe nj nk nl na b">??</code>)。TypeScript准备在4.0版本中填补这些空白，他们有一个很有希望的提议，添加三个新的赋值操作符:<code class="fe nj nk nl na b">&amp;&amp;=</code>、<code class="fe nj nk nl na b">||=</code>和<code class="fe nj nk nl na b">??=</code>。</p><pre class="kj kk kl km gt mz na nb nc aw nd bi"><span id="bfaf" class="ne md it na b gy nf ng l nh ni">a ||= b;<br/><br/>// This will be equal to<br/><br/>a || (a = b);</span></pre></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="afdf" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">catch子句绑定未知</h1><p id="5a52" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">从TypeScript开始，<code class="fe nj nk nl na b">catch</code>子句变量总是被类型化为<code class="fe nj nk nl na b">any</code>，这意味着TypeScript允许您对它们做任何您想做的事情。</p><pre class="kj kk kl km gt mz na nb nc aw nd bi"><span id="86ee" class="ne md it na b gy nf ng l nh ni">try {<br/>  throw 20;<br/>} catch (err) {<br/>  console.error(err.specialFunction()); <br/>}</span></pre><p id="ac8e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在上面的例子中，错误的类型是<code class="fe nj nk nl na b">any</code>，因此它不是类型安全的。这就是为什么TypeScript 4.0现在让您将<code class="fe nj nk nl na b">catch</code>子句变量的类型指定为<code class="fe nj nk nl na b">unknown</code>。<code class="fe nj nk nl na b">unknown</code>比<code class="fe nj nk nl na b">any</code>更安全，因为它提醒我们在对值进行操作之前需要执行一些类型检查。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nn no l"/></div></figure></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="c537" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">定制JSX工厂</h1><p id="32ea" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">在TypeScript 4.0中，用户可以通过新的<code class="fe nj nk nl na b">jsxFragmentFactory</code>选项自定义片段工厂。例如，下面的<code class="fe nj nk nl na b">tsconfig.json</code>文件告诉TypeScript以与React兼容的方式转换JSX，但是将每个调用切换到<code class="fe nj nk nl na b">h</code>而不是<code class="fe nj nk nl na b">React.createElement</code>，并使用<code class="fe nj nk nl na b">Fragment</code>而不是<code class="fe nj nk nl na b">React.Fragment</code>。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nn no l"/></div></figure></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="d39c" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">使用<code class="fe nj nk nl na b">--noEmitOnError</code>提高B <code class="fe nj nk nl na b">uild</code>模式下的速度</h1><p id="4dca" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">在以前的版本中，当使用<code class="fe nj nk nl na b">--noEmitOnError</code>标志时，在<code class="fe nj nk nl na b">--incremental</code>下有错误的前一次编译后编译程序会非常慢，因为上次编译的任何信息都不会基于<code class="fe nj nk nl na b">--noEmitOnError</code>标志缓存在<code class="fe nj nk nl na b">.tsbuildinfo</code>文件中。</p><p id="e252" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在TypeScript 4.0中，这一点已经改变，现在您将在这些场景中获得巨大的速度提升。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="25d3" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">编辑器改进</h1><p id="0515" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">TypeScript编译器不仅增强了大多数主流编辑器中TypeScript本身的编辑体验，还增强了Visual Studio系列编辑器及其他编辑器中的JavaScript体验。你可以查看部分支持TypeScript 的编辑器列表，了解你最喜欢的编辑器是否支持使用新版本。</p><p id="6d1e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">此外，TypeScript的编辑支持现在可以识别声明何时用<code class="fe nj nk nl na b">/** @deprecated *</code> JSDoc注释标记。</p><p id="95cf" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">启动时的部分编辑模式<strong class="lb iu"> </strong>是TypeScript 4.0中包含的另一个实验性特性。他们说，这将是许多项目中加载时间缓慢的一个解决方案。这种新的编辑模式将提供部分体验，直到加载完整的语言服务体验。</p><p id="c513" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">目前唯一支持这种模式的编辑器是<a class="ae ky" href="http://code.visualstudio.com/insiders" rel="noopener ugc nofollow" target="_blank"> Visual Studio Code Insiders </a>。您可以按照以下步骤进行尝试。</p><ol class=""><li id="20fd" class="np nq it lb b lc ld lf lg li nr lm ns lq nt lu nu nv nw nx bi translated">安装<a class="ae ky" href="http://code.visualstudio.com/insiders" rel="noopener ugc nofollow" target="_blank"> Visual Studio代码内部人员</a>。</li><li id="a72c" class="np nq it lb b lc ny lf nz li oa lm ob lq oc lu nu nv nw nx bi translated"><a class="ae ky" href="https://code.visualstudio.com/docs/typescript/typescript-compiling#_using-newer-typescript-versions" rel="noopener ugc nofollow" target="_blank">配置Visual Studio Code Insiders </a>使用测试版或者为Visual Studio Code Insiders安装<a class="ae ky" href="https://marketplace.visualstudio.com/items?itemName=ms-vscode.vscode-typescript-next" rel="noopener ugc nofollow" target="_blank"> JavaScript和TypeScript Nightly Extension </a>。</li><li id="2bdd" class="np nq it lb b lc ny lf nz li oa lm ob lq oc lu nu nv nw nx bi translated">打开你的JSON设置视图:<code class="fe nj nk nl na b">&gt; Preferences: Open Settings (JSON)</code>。</li><li id="0c5d" class="np nq it lb b lc ny lf nz li oa lm ob lq oc lu nu nv nw nx bi translated">添加以下几行:</li></ol><p id="6b3c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe nj nk nl na b">// The editor will say 'dynamic' is an unknown option, // but don't worry about it for now. It's still experimental. "typescript.tsserver.useSeparateSyntaxServer": "dynamic",</code></p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><p id="725e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">上述功能只是我们在TypeScript 4.0中可以看到的大量更改中的一个子集。因为这是测试版，如果你愿意，TypeScript邀请你用你的项目测试这个版本。如果这是你的计划，</p><ul class=""><li id="c3df" class="np nq it lb b lc ld lf lg li nr lm ns lq nt lu od nv nw nx bi translated">你可以使用npm <code class="fe nj nk nl na b"> install typescript@beta</code>。</li><li id="ed0b" class="np nq it lb b lc ny lf nz li oa lm ob lq oc lu od nv nw nx bi translated">可以通过NuGet 获得<a class="ae ky" href="https://www.nuget.org/packages/Microsoft.TypeScript.MSBuild" rel="noopener ugc nofollow" target="_blank">。</a></li></ul><p id="ffe9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">所以试试吧，让他们知道你的反馈。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><p id="2247" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">感谢阅读！</p></div></div>    
</body>
</html>