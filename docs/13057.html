<html>
<head>
<title>First Impressions When Switching From Spring Boot to Ktor</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">从Spring Boot转到Ktor的第一印象</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/switching-from-springboot-to-ktor-a-first-impression-1c4776970f39?source=collection_archive---------0-----------------------#2022-07-24">https://betterprogramming.pub/switching-from-springboot-to-ktor-a-first-impression-1c4776970f39?source=collection_archive---------0-----------------------#2022-07-24</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="5bf1" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">使用Ktor、Koin和Exposed编写API端点的分步指南</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/b335e56674b3c561e14ddb8538faf56d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*dX5WByhliJbHx-hl9pgnHQ.png"/></div></div></figure><p id="4392" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">当我从Java切换到Kotlin时，我继续使用我熟悉的技术栈，它由SpringBoot生态系统的几个部分组成。除了一些小的不同，主要由<a class="ae ln" href="https://kotlinlang.org/docs/all-open-plugin.html" rel="noopener ugc nofollow" target="_blank"> Kotlin Spring插件</a>处理，我可以像在Java世界中一样使用它。</p><p id="dc4d" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">随着我对Kotlin相关内容的兴趣增加，我搜索了一个Kotlin原生替代方案，它提供了与SpringBoot相似的功能范围。科特林社区的很多人都向我推荐了Ktor。</p><p id="6671" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">在这篇文章中，我将分享我在使用Ktor时与Spring Boot相比的第一印象。</p><p id="c11d" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">有了IntelliJ，使用“新项目”菜单很容易创建一个新的Ktor项目，该菜单提供了一个类似于使用<a class="ae ln" href="https://start.spring.io" rel="noopener ugc nofollow" target="_blank"> SpringBoot starter </a>创建Spring Boot项目的向导</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi lo"><img src="../Images/1353be5c1e24bbbf074776437b2e9323.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*w-T-4JPfLpBHriLqjnWl0Q.png"/></div></div></figure><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi lp"><img src="../Images/2306dccdbd90d77bf737f7ea2ffb2b0d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*cAuLmg7FUVaMcQWkKF8K-A.png"/></div></div></figure><p id="0901" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">为了能够比较Spring Boot和Ktor实现功能的方式，我将使用我之前用Kotlin + Spring Boot(包括JPA)创建的Rest API应用程序。当然，我的解决方案并不是使用Ktor + Koin + Exposed的惯用方式，而是尝试看看在同样的需求下事情是如何完成的。</p><p id="a47b" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">所以我的第一步将是编写验收测试来指导我的实现。这是测试的第一个版本(随着应用程序功能的增加，测试的设置将逐步更新)。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="lq lr l"/></div></figure><p id="3cf7" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">实现非常简单。使用了一个<code class="fe ls lt lu lv b">testApplication</code>块来代替<code class="fe ls lt lu lv b">@MockMvc</code>。该函数提供了一个测试应用程序的配置实例，该实例在本地运行。如果没有配置任何不同，则使用生产应用程序的设置(见下文)。</p><pre class="kg kh ki kj gt lw lv lx ly aw lz bi"><span id="8277" class="ma mb iq lv b gy mc md l me mf">fun Application.module() {<br/>  ...<br/>  <em class="mg">configureRouting</em>()<br/>  ...<br/>}</span></pre><p id="8676" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">更多细节可以在Ktor 的<a class="ae ln" href="https://ktor.io/docs/testing.html" rel="noopener ugc nofollow" target="_blank">官方文档中找到。</a></p><p id="d662" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">下一步将是<code class="fe ls lt lu lv b">datasource</code>的配置。因为没有可用的自动配置，所以我需要手动实现它，并在应用程序启动时注册它。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="lq lr l"/></div></figure><p id="57eb" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">我设置了一个光<code class="fe ls lt lu lv b">datasource</code>并创建了必要的表(如果还不存在的话)。</p><p id="04d6" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">对于<code class="fe ls lt lu lv b">datasource</code>的设置，SpringBoot提供了一个更简单的实现，因为它只需要在<code class="fe ls lt lu lv b">application.properties</code>中指定配置，这也可以很容易地在测试中被覆盖，剩下的工作由自动配置完成。</p><p id="1b73" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">实现中的下一个区别是表和存储库的配置。与JPA相比，没有可用的注释。相反，Exposed为不同的表类型提供基类。在我的例子中，我可以使用<code class="fe ls lt lu lv b">IdLongTable</code>类。</p><p id="c029" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">地址的创建非常简单，因为不需要任何关系。</p><p id="24a4" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">customer表和account表有点复杂，因为它们与寻址是一对一的关系(没有级联更新/删除),与记账是一对多的关系(有级联更新/删除)。</p><p id="bf50" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">我使用GitHub资源库中的官方文档来获得必要的帮助。</p><p id="b88c" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">暴露的DAO API应该提供一种类似于像Hibernate这样的ORM框架的持久化数据的方法(根据文档)。但是我的实体的配置工作方式与我以前使用Spring Data JPA的方式不同。</p><p id="bb22" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">我将所有的DAO调用包装在事务块中，因此消费者不会被迫这样做。Exposed期望数据库上的所有调用(读和写)都有一个事务。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="lq lr l"/></div></figure><p id="c478" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">公开的DAO提供了基类，用于将对表的访问包装在一个实体中。实体基类提供了对数据库的基本访问方法(与Spring Data JPA的<code class="fe ls lt lu lv b">CrudRepositories</code>相比非常基本)。</p><p id="fd19" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">暴露的DAO在建模关系上也是有限的。客户和账户之间的一对多关系不能由客户来处理(就像JPA支持的那样),而是需要从账户来处理。</p><p id="8600" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">有了这个限制，我必须按照需要将实体添加到数据库的相同顺序来创建和持久化实体，以符合约束。添加一个新客户将类似于下面的示例。这和Spring Data JPA版本比起来不是很舒服。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="lq lr l"/></div></figure><p id="20cb" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">为了将<code class="fe ls lt lu lv b">Exposed</code>的数据持久层封装成可交换的，我将添加一个额外的抽象层。但现在问题来了:如何在不改变实现的情况下使Exposed可交换？</p><p id="8f4e" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">在SpringBoot中，已经包括了依赖注入容器，并且很容易通过例如不同的配置文件来切换一个组件的多个版本。</p><p id="e860" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">所以我的下一步将是向Ktor应用程序添加一个依赖注入框架。为此，我使用了Koin<a class="ae ln" href="https://insert-koin.io" rel="noopener ugc nofollow" target="_blank"/><strong class="kt ir"/>，这是Kotlin的一个轻量级注入库。</p><p id="4a8c" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">在Koin的文档中，有一个<a class="ae ln" href="https://insert-koin.io/docs/reference/koin-ktor/ktor" rel="noopener ugc nofollow" target="_blank">单独的章节</a>关于Koin在Ktor应用程序中的集成。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="lq lr l"/></div></figure><p id="255c" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">所需的配置非常小。只需将依赖关系添加到<code class="fe ls lt lu lv b">build.gradle.kts</code>，设置您的依赖关系图并安装Koin模块。应该由Koin管理的组件的定义需要手动配置。没有任何注释能帮我完成这项工作。</p><p id="b73f" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">存储库类只是包装公开的功能，并将实体对象映射到域对象。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="lq lr l"/></div></figure><p id="579c" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">测试组件也非常简单。Koin提供了一个接口，可以用来在测试类中注入依赖项。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="lq lr l"/></div></figure><p id="1839" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">我将在本文中省略应用程序服务层的实现，因为它的工作方式与SpringBoot相同，因此对于比较这两个应用程序来说并不有趣。</p><p id="104f" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">满足需求所缺少的部分是添加一个处理程序，它提供处理post请求的功能。在<code class="fe ls lt lu lv b">SpringBoot</code>中，这部分由RestController完成。</p><p id="bd1d" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">Ktor有不同的概念。由应用程序处理的端点的定义在路由配置中定义。为了将路由的定义与HTTP请求的处理分开，我创建了一个控制器组件来完成这项工作。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="lq lr l"/></div></figure><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="lq lr l"/></div></figure><p id="287f" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">当运行测试时，我得到一个异常，因为应用程序不能反序列化JSON有效负载。所以我需要添加一个额外的插件和对<code class="fe ls lt lu lv b">build.gradle.kts</code>的依赖，它支持JSON的序列化/反序列化。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="lq lr l"/></div></figure><p id="d32a" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">通过这一步，我已经达到了我的目标，验收测试也顺利通过。</p><p id="5b0b" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">在添加功能的过程中，我需要更新我的验收测试设置，以便正确地设置测试应用程序。</p><p id="9e8e" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">最终版本如下所示:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="lq lr l"/></div></figure><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi mh"><img src="../Images/4153962c5433b5b26718e0423cbaa4cc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*jrcNZd71y-eLPydbVdZ0jw.png"/></div></div></figure><p id="c53e" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">我用Ktor的第一印象结束了。与跳羚相比，我需要花费更多的时间来达到同样的目标，但这主要与我的跳羚经验有关。</p><p id="69a4" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">我仍然需要评估一些未解决的问题:</p><ul class=""><li id="b726" class="mi mj iq kt b ku kv kx ky la mk le ml li mm lm mn mo mp mq bi translated">事务处理</li><li id="3b8a" class="mi mj iq kt b ku mr kx ms la mt le mu li mv lm mn mo mp mq bi translated">使用注释来简化组件的处理(<a class="ae ln" href="https://insert-koin.io/docs/reference/koin-annotations/annotations/" rel="noopener ugc nofollow" target="_blank">https://insert-koin . io/docs/reference/koin-annotations/annotations/</a>)</li><li id="c20b" class="mi mj iq kt b ku mr kx ms la mt le mu li mv lm mn mo mp mq bi translated">添加请求过滤器功能(例如用于请求/响应日志记录)</li><li id="00dc" class="mi mj iq kt b ku mr kx ms la mt le mu li mv lm mn mo mp mq bi translated">SpringBoot提供的更多高级功能(例如安全性)</li><li id="c2db" class="mi mj iq kt b ku mr kx ms la mt le mu li mv lm mn mo mp mq bi translated">SpringBoot提供的集成(例如JMS、Keycloak、Kafka)</li></ul><h1 id="2abc" class="mw mb iq bd mx my mz na nb nc nd ne nf jw ng jx nh jz ni ka nj kc nk kd nl nm bi translated">结论</h1><ul class=""><li id="275d" class="mi mj iq kt b ku nn kx no la np le nq li nr lm mn mo mp mq bi translated">对于Ktor来说，SpringBoot通过自动配置或组件扫描在引擎盖下执行的许多步骤都需要手动完成。</li><li id="de9d" class="mi mj iq kt b ku mr kx ms la mt le mu li mv lm mn mo mp mq bi translated">Ktor和我在应用程序中使用的框架比Spring Boot使用的“魔法”更少，所以发生了什么更清楚。</li><li id="a327" class="mi mj iq kt b ku mr kx ms la mt le mu li mv lm mn mo mp mq bi translated">与SpringBoot应用程序相比，该应用程序更加轻量级。</li><li id="e8e9" class="mi mj iq kt b ku mr kx ms la mt le mu li mv lm mn mo mp mq bi translated">对于编写REST应用程序，Ktor是一个选项。</li></ul><p id="cafe" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">对于本文使用的示例应用程序，请查看GitHub资源库:</p><div class="ns nt gp gr nu nv"><a href="https://github.com/PoisonedYouth/kotlin-acceptance-test-ktor.git" rel="noopener  ugc nofollow" target="_blank"><div class="nw ab fo"><div class="nx ab ny cl cj nz"><h2 class="bd ir gy z fp oa fr fs ob fu fw ip bi translated">GitHub-PoisonedYouth/kot Lin-验收-测试-ktor</h2><div class="oc l"><h3 class="bd b gy z fp oa fr fs ob fu fw dk translated">此时您不能执行该操作。您已使用另一个标签页或窗口登录。您已在另一个选项卡中注销，或者…</h3></div><div class="od l"><p class="bd b dl z fp oa fr fs ob fu fw dk translated">github.com</p></div></div><div class="oe l"><div class="of l og oh oi oe oj kp nv"/></div></div></a></div></div></div>    
</body>
</html>