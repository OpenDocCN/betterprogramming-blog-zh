<html>
<head>
<title>How To Implement Google Rewarded Ads in a SpriteKit Game</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何在SpriteKit游戏中实现Google奖励广告</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/how-to-implement-rewarded-ads-in-your-game-made-in-spritekit-1d104534d843?source=collection_archive---------4-----------------------#2022-12-15">https://betterprogramming.pub/how-to-implement-rewarded-ads-in-your-game-made-in-spritekit-1d104534d843?source=collection_archive---------4-----------------------#2022-12-15</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="5b79" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">将您的应用货币化</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/0b97302e911aee06721d704879e68304.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*z-17pnFvay6U9_GDuShn5A.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">作者图片</p></figure><p id="f341" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">事情是这样的:你已经成功开发并发布了你的iOS手机游戏，现在你想赚点钱。从你的游戏中赚钱的最简单的方法是什么(除非你是一个超级著名的开发者，有一群忠诚的客户，他们愿意为你游戏中的额外功能付费)？广告。哪些广告对你来说更有利可图，对一个用户来说不那么讨厌？奖励广告在用户观看后提供额外的功能，比如额外的硬币，或者在我们的情况下，在被杀死后继续玩而不丢失你的进度的机会。</p><p id="507b" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">在本文中，我将一步一步地解释如何在一个用SpriteKit制作的游戏中实现奖励广告(和一些边界)。我想你已经有了一个开发好的游戏，但是我将向你展示如何在一个真实的项目中这样做，<em class="lr">中轴</em>。</p><h1 id="16e2" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">关于游戏</h1><p id="fea0" class="pw-post-body-paragraph kv kw iq kx b ky mk jr la lb ml ju ld le mm lg lh li mn lk ll lm mo lo lp lq ij bi translated"><em class="lr">中轴</em>是我和我的同事路易吉·卢卡·科莱塔在苹果开发者学院开发的一款无尽的跑步者街机游戏。</p><p id="877c" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">在这个游戏中，你沿着高速公路跑，收集煤气罐，躲避汽车和卡车。跑的时间越长，收集的油箱越多，分数越高。</p><p id="ca4f" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">如果你被汽车或卡车撞了，你就输了，新游戏的分数让你从零开始。考虑到我们游戏中实现的排行榜，你几乎不希望这种情况发生！</p><div class="mp mq gp gr mr ms"><a href="https://youtube.com/shorts/pLCATT6T7MA?feature=share" rel="noopener  ugc nofollow" target="_blank"><div class="mt ab fo"><div class="mu ab mv cl cj mw"><h2 class="bd ir gy z fp mx fr fs my fu fw ip bi translated">中轴</h2><div class="mz l"><h3 class="bd b gy z fp mx fr fs my fu fw dk translated">编辑描述</h3></div><div class="na l"><p class="bd b dl z fp mx fr fs my fu fw dk translated">youtube.com</p></div></div><div class="nb l"><div class="nc l nd ne nf nb ng kp ms"/></div></div></a></div><p id="23da" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">这里有一个<a class="ae nh" href="https://apps.apple.com/it/app/median-axis/id1617251103?l=en" rel="noopener ugc nofollow" target="_blank">到App Store </a>的链接，你可以在那里下载游戏并享受它…在这里<a class="ae nh" href="https://www.notion.so/Median-Axis-664c8be4409f47249111f6c04f483b9b" rel="noopener ugc nofollow" target="_blank">你可以找到产品页面、团队信息和隐私政策。</a></p><h1 id="8d8c" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">AdMob:第一步</h1><p id="9333" class="pw-post-body-paragraph kv kw iq kx b ky mk jr la lb ml ju ld le mm lg lh li mn lk ll lm mo lo lp lq ij bi translated">在官方<a class="ae nh" href="https://developers.google.com/admob/ios/quick-start" rel="noopener ugc nofollow" target="_blank"> Google AdMob指南</a>中非常清楚地描述了在iOS应用中实现AdMob。这篇文章解释了在SKScene内部用SpriteKit创建的iOS游戏中实现广告的特性，以及为显示广告创建定制的边界。</p><h2 id="cbc3" class="ni lt iq bd lu nj nk dn ly nl nm dp mc le nn no me li np nq mg lm nr ns mi nt bi translated"><strong class="ak">先决条件</strong></h2><ol class=""><li id="51f7" class="nu nv iq kx b ky mk lb ml le nw li nx lm ny lq nz oa ob oc bi translated">按照<a class="ae nh" href="https://support.google.com/admob/answer/7356219?utm_source=developers.google.com&amp;utm_medium=referral&amp;visit_id=638063717918329050-1143239393&amp;rd=1" rel="noopener ugc nofollow" target="_blank">官方指南</a>创建一个AdMob账户</li><li id="ceb0" class="nu nv iq kx b ky od lb oe le of li og lm oh lq nz oa ob oc bi translated">按照<a class="ae nh" href="https://support.google.com/admob/answer/9989980?utm_source=developers.google.com&amp;utm_medium=referral&amp;visit_id=638063717918329050-1143239393&amp;rd=1" rel="noopener ugc nofollow" target="_blank">官方指南</a>注册你的游戏</li><li id="f56c" class="nu nv iq kx b ky od lb oe le of li og lm oh lq nz oa ob oc bi translated">导入并初始化移动广告SDK，并按照上述<a class="ae nh" href="https://developers.google.com/admob/ios/quick-start" rel="noopener ugc nofollow" target="_blank">指南</a>更新您的应用程序的<code class="fe oi oj ok ol b">Info.plist</code></li></ol><blockquote class="om on oo"><p id="0787" class="kv kw lr kx b ky kz jr la lb lc ju ld op lf lg lh oq lj lk ll or ln lo lp lq ij bi translated">关于进口，我同意指南并强烈推荐你使用可可豆。</p></blockquote><p id="d97d" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">完成这些步骤后，就可以开始实施打赏广告了。</p><h1 id="2c62" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">奖励广告实施</h1><p id="bb36" class="pw-post-body-paragraph kv kw iq kx b ky mk jr la lb ml ju ld le mm lg lh li mn lk ll lm mo lo lp lq ij bi translated">创建一个单独的Swift文件包含奖励广告的所有信息和功能会更方便，所以在项目内部，创建一个名为<code class="fe oi oj ok ol b">RewardedAdHelper</code>的新Swift文件。</p><p id="3d9c" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">首先，你需要<code class="fe oi oj ok ol b">import GoogleMobileAds</code>。</p><pre class="kg kh ki kj gt os ol ot bn ou ov bi"><span id="733d" class="ow lt iq ol b be ox oy l oz pa">//RewardedAdHelper.swift<br/><br/>import GoogleMobileAds</span></pre><p id="7187" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">然后创建一个类<code class="fe oi oj ok ol b">RewardedAdHelper</code>。它应该从<code class="fe oi oj ok ol b">NSobject </code>类继承并符合<code class="fe oi oj ok ol b">GADFullScreenContentDelegate</code>协议(能够全屏显示广告)。</p><pre class="kg kh ki kj gt os ol ot bn ou ov bi"><span id="67a1" class="ow lt iq ol b be ox oy l oz pa">//RewardedAdHelper.swift<br/><br/>import GoogleMobileAds<br/><br/>class RewardedAdHelper : NSObject, GADFullScreenContentDelegate {<br/><br/>}</span></pre><p id="41a0" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">在这个新创建的类的花括号内，提供<code class="fe oi oj ok ol b">GADRewardedAd </code>对象作为参数。看起来是这样的:</p><pre class="kg kh ki kj gt os ol ot bn ou ov bi"><span id="e60e" class="ow lt iq ol b be ox oy l oz pa">//RewardedAdHelper.swift<br/><br/>import GoogleMobileAds<br/><br/>class RewardedAdHelper : NSObject, GADFullScreenContentDelegate {<br/>   private var rewardedAd : GADRewardedAd?<br/>}</span></pre><p id="5d91" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">然后，仍然在类内部，添加函数<code class="fe oi oj ok ol b">loadRewardedAd()</code>。它从源加载广告。</p><pre class="kg kh ki kj gt os ol ot bn ou ov bi"><span id="6978" class="ow lt iq ol b be ox oy l oz pa">//RewardedAdHelper.swift<br/><br/>import GoogleMobileAds<br/><br/>class RewardedAdHelper : NSObject, GADFullScreenContentDelegate {<br/> <br/>  //...<br/><br/>  func loadRewardedAd() {<br/>       let request = GADRequest()<br/>   <br/>       //1<br/>       GADRewardedAd.load(withAdUnitID: "ca-app-pub-3940256099942544/1712485313", request: request) { [self] ad, error in<br/>           if let error = error {<br/>               print("Failed to load reward ad with error: \(error.localizedDescription)")<br/>               return<br/>           }<br/>           <br/>           rewardedAd = ad<br/>           rewardedAd?.fullScreenContentDelegate = self<br/>       }<br/>   }<br/>}</span></pre><blockquote class="om on oo"><p id="963b" class="kv kw lr kx b ky kz jr la lb lc ju ld op lf lg lh oq lj lk ll or ln lo lp lq ij bi translated"><em class="iq"> 1。注意用</em> <code class="fe oi oj ok ol b"><em class="iq">GADRewardedAd.load(withAdUnitID: ...)</em></code> <em class="iq">的线。在本文中，我使用Google AdMob提供的iOS奖励广告的测试广告单元ID(你也可以在这里找到它</em><a class="ae nh" href="https://developers.google.com/admob/ios/rewarded" rel="noopener ugc nofollow" target="_blank"><em class="iq"/></a><em class="iq">)。在发布你的游戏之前，别忘了改成你自己的广告单元ID(你可以在这里</em>  <em class="iq">阅读如何找到</em> <a class="ae nh" href="https://support.google.com/admob/answer/7356431" rel="noopener ugc nofollow" target="_blank"> <em class="iq">)。</em></a></p></blockquote><p id="9f41" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">在<code class="fe oi oj ok ol b">loadRewardedAd()</code>之后添加这三个功能:</p><pre class="kg kh ki kj gt os ol ot bn ou ov bi"><span id="bccd" class="ow lt iq ol b be ox oy l oz pa">//RewardedAdHelper.swift<br/><br/>import GoogleMobileAds<br/><br/>class RewardedAdHelper : NSObject, GADFullScreenContentDelegate {<br/> <br/>  //...<br/> <br/> func loadRewardedAd() {<br/>   //...<br/>  }<br/><br/><br/>  //1<br/>   /// Tells the delegate that the ad failed to present full screen content.<br/>   func ad(_ ad: GADFullScreenPresentingAd, didFailToPresentFullScreenContentWithError error: Error) {<br/>     print("Ad did fail to present full screen content.")<br/>   }<br/><br/>   //2<br/>  /// Tells the delegate that the ad will present full screen content.<br/>   func adWillPresentFullScreenContent(_ ad: GADFullScreenPresentingAd) {<br/>     print("Ad will present full screen content.")<br/>   }<br/><br/>  //3<br/>   /// Tells the delegate that the ad dismissed full screen content.<br/>   func adDidDismissFullScreenContent(_ ad: GADFullScreenPresentingAd) {<br/>       loadRewardedAd()<br/>   }<br/>}</span></pre><ol class=""><li id="0358" class="nu nv iq kx b ky kz lb lc le pb li pc lm pd lq nz oa ob oc bi translated">这个函数告诉代理广告不能全屏显示。</li><li id="d98e" class="nu nv iq kx b ky od lb oe le of li og lm oh lq nz oa ob oc bi translated">这个函数告诉代理，广告将呈现全屏内容。</li><li id="aeae" class="nu nv iq kx b ky od lb oe le of li og lm oh lq nz oa ob oc bi translated">这个函数告诉代理广告放弃了全屏内容。</li></ol><p id="e701" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">最后，在第三个函数之后，添加<code class="fe oi oj ok ol b">showRewardedAd()</code>函数。稍后，它应该在您想要显示广告的条件之后被调用。</p><pre class="kg kh ki kj gt os ol ot bn ou ov bi"><span id="dbb0" class="ow lt iq ol b be ox oy l oz pa">//RewardedAdHelper.swift<br/><br/>import GoogleMobileAds<br/><br/>class RewardedAdHelper : NSObject, GADFullScreenContentDelegate {<br/> <br/>  //...<br/><br/>  func showRewardedAd(viewController: UIViewController) {<br/>       if rewardedAd != nil {<br/>           rewardedAd!.present(fromRootViewController: viewController, userDidEarnRewardHandler: {<br/>               let reward = self.rewardedAd!.adReward<br/>               print("\(reward.amount) \(reward.type)")<br/>           })<br/>       } else {<br/>           print("RewardedAd wasn't ready")<br/>      }<br/>   }<br/>}</span></pre><p id="ba08" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">这个文件的代码应该是这样的:</p><pre class="kg kh ki kj gt os ol ot bn ou ov bi"><span id="7c7f" class="ow lt iq ol b be ox oy l oz pa">//RewardedAdHelper.swift<br/><br/>import GoogleMobileAds<br/><br/>class RewardedAdHelper : NSObject, GADFullScreenContentDelegate  {<br/>   private var rewardedAd : GADRewardedAd?<br/><br/>   <br/>   func loadRewardedAd() {<br/>       let request = GADRequest()<br/>       GADRewardedAd.load(withAdUnitID: "ca-app-pub-3940256099942544/1712485313", request: request) { [self] ad, error in<br/>           if let error = error {<br/>               print("Failed to load reward ad with error: \(error.localizedDescription)")<br/>               return<br/>           }<br/>           <br/>           rewardedAd = ad<br/>           rewardedAd?.fullScreenContentDelegate = self<br/>       }<br/>   }<br/>   <br/>   /// Tells the delegate that the ad failed to present full screen content.<br/>   func ad(_ ad: GADFullScreenPresentingAd, didFailToPresentFullScreenContentWithError error: Error) {<br/>     print("Ad did fail to present full screen content.")<br/>   }<br/><br/>   /// Tells the delegate that the ad will present full screen content.<br/>   func adWillPresentFullScreenContent(_ ad: GADFullScreenPresentingAd) {<br/>     print("Ad will present full screen content.")<br/>   }<br/><br/>   /// Tells the delegate that the ad dismissed full screen content.<br/>   func adDidDismissFullScreenContent(_ ad: GADFullScreenPresentingAd) {<br/>       loadRewardedAd()<br/>   }<br/>   <br/>   func showRewardedAd(viewController: UIViewController) {<br/>       if rewardedAd != nil {<br/>           rewardedAd!.present(fromRootViewController: viewController, userDidEarnRewardHandler: {<br/>               let reward = self.rewardedAd!.adReward<br/>               print("\(reward.amount) \(reward.type)")<br/>           })<br/>       } else {<br/>           print("RewardedAd wasn't ready")<br/>       }<br/>   }<br/>}</span></pre><h1 id="27bb" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">问题屏幕(仅限用户界面)</h1><p id="d504" class="pw-post-body-paragraph kv kw iq kx b ky mk jr la lb ml ju ld le mm lg lh li mn lk ll lm mo lo lp lq ij bi translated">现在，只要我们已经完成了广告的基础，让我们切换到一些UI(这是不可避免的，你知道)。</p><p id="b291" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">首先，礼貌的做法是询问用户是否愿意在被击中后继续观看广告而不失去分数。所以我们需要创建一个有一个问题和两个按钮的问题窗口。</p><p id="52da" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">如果你有自己的方法在SpriteKit中创建屏幕和窗口，你可以跳过这一部分，直接进入<strong class="kx ir">奖励广告实现(续)</strong>。但是请记住，这个问题屏幕上的按钮名称将在项目中使用。</p><p id="a93e" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">在项目中创建一个新的Swift文件，并将其命名为<code class="fe oi oj ok ol b">QuestionScreen</code>。</p><p id="d759" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">首先你需要<code class="fe oi oj ok ol b">import SpriteKit</code>。该命令可以帮助您做到这一点:</p><pre class="kg kh ki kj gt os ol ot bn ou ov bi"><span id="27a6" class="ow lt iq ol b be ox oy l oz pa">//QuestionScreen.swift<br/><br/>import SpriteKit</span></pre><p id="dda9" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">然后创建一个类<code class="fe oi oj ok ol b">QuestionScreen</code>，它应该继承自类<code class="fe oi oj ok ol b">SKSpriteNode</code>。</p><pre class="kg kh ki kj gt os ol ot bn ou ov bi"><span id="b7aa" class="ow lt iq ol b be ox oy l oz pa">//QuestionScreen.swift<br/><br/>import SpriteKit<br/><br/>class QuestionScreen: SKSpriteNode {<br/><br/>}</span></pre><blockquote class="om on oo"><p id="e8ca" class="kv kw lr kx b ky kz jr la lb lc ju ld op lf lg lh oq lj lk ll or ln lo lp lq ij bi translated"><code class="fe oi oj ok ol b">SKSpriteNode </code> <em class="iq">是屏幕上的图形元素，可以从图像或纯色初始化。SpriteKit增加了使用函数显示图像的功能。</em></p></blockquote><p id="545d" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">在这个类中，添加初始化器和必需的初始化器:</p><pre class="kg kh ki kj gt os ol ot bn ou ov bi"><span id="b1b1" class="ow lt iq ol b be ox oy l oz pa">//QuestionScreen.swift<br/><br/>import SpriteKit<br/><br/>class QuestionScreen: SKSpriteNode {<br/><br/>  init() {<br/>  <br/> }<br/><br/>  required init?(coder aDecoder: NSCoder) {<br/>          fatalError("init(coder:) has not been implemented")<br/>      }<br/>}</span></pre><p id="6ab0" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">在初始值设定项中，添加以下代码:</p><pre class="kg kh ki kj gt os ol ot bn ou ov bi"><span id="59ae" class="ow lt iq ol b be ox oy l oz pa">//QuestionScreen.swift<br/><br/>import SpriteKit<br/><br/>class QuestionScreen: SKSpriteNode {<br/><br/> init() {<br/>    <br/>    //1<br/>        let texture = SKTexture(imageNamed: "PauseScr")<br/>        <br/>        super.init(texture: texture, color: .clear, size: texture.size())<br/>        self.position = CGPoint(x: 212, y: 530)<br/>        self.zPosition = 200<br/>        self.name = "questionScreen"<br/>        <br/>    //2<br/>        let yesButton = SKSpriteNode(imageNamed: "YES")<br/>       yesButton.name = "YesBtn"<br/>        self.addChild(yesButton)<br/>       yesButton.zPosition = 240<br/>       yesButton.position = CGPoint(x: 0, y: (((-size.height)/3.5)/1.7) + 75)<br/>        <br/>        let littleButtonsSize = CGSize(width: yesButton.size.height, height: yesButton.size.height)<br/>        <br/>    //3<br/>        let noButton = SKSpriteNode(imageNamed: "NO")<br/>       noButton.size = littleButtonsSize<br/>        // Name the start node for touch detection:<br/>       noButton.name = "NoBtn"<br/>       noButton.position = CGPoint(x: yesButton.position.x, y: (((-size.height)/3.5)/1.7) - 125)<br/>       noButton.zPosition = 240<br/>        <br/>        self.addChild(noButton)<br/><br/>    //4<br/>       let gotHitText = NSLocalizedString("GotHit", comment: "Got Hit 1")<br/>       let gotHit = SKLabelNode(fontNamed: "Menlo")<br/>       gotHit.text = gotHitText<br/>       gotHit.horizontalAlignmentMode = .center<br/>       gotHit.fontSize = 16<br/>       gotHit.position = CGPoint(x: 0, y: 190)<br/>       gotHit.zPosition = 220<br/>       <br/>       addChild(gotHit)<br/>       <br/>       let reward1Text = NSLocalizedString("WatchVideo", comment: "Watch Video")<br/>       let reward1 = SKLabelNode(fontNamed: "Menlo")<br/>       reward1.text = reward1Text<br/>       reward1.horizontalAlignmentMode = .center<br/>       reward1.fontSize = 16<br/>       reward1.position = CGPoint(x: 0, y: 160)<br/>       reward1.zPosition = 220<br/><br/>       addChild(reward1)<br/>       <br/>       let reward2Text = NSLocalizedString("ToContinue", comment: "To Continue2")<br/>       let reward2 = SKLabelNode(fontNamed: "Menlo")<br/>       reward2.text = reward2Text<br/>       reward2.horizontalAlignmentMode = .center<br/>       reward2.fontSize = 16<br/>       reward2.position = CGPoint(x: 0, y: 130)<br/>       reward2.zPosition = 220<br/><br/>       addChild(reward2)<br/>       <br/>       let reward3Text = NSLocalizedString("YourProgress", comment: "Your Progress")<br/>       let reward3 = SKLabelNode(fontNamed: "Menlo")<br/>       reward3.text = reward3Text<br/>       reward3.horizontalAlignmentMode = .center<br/>       reward3.fontSize = 16<br/>       reward3.position = CGPoint(x: 0, y: 100)<br/>       reward3.zPosition = 220<br/><br/>       addChild(reward3)<br/>    }<br/>    <br/>   //...<br/>}</span></pre><ol class=""><li id="633d" class="nu nv iq kx b ky kz lb lc le pb li pc lm pd lq nz oa ob oc bi translated">屏幕的背景、大小和位置。</li><li id="fb0d" class="nu nv iq kx b ky od lb oe le of li og lm oh lq nz oa ob oc bi translated">按钮是的，它的大小和位置。</li><li id="c8b7" class="nu nv iq kx b ky od lb oe le of li og lm oh lq nz oa ob oc bi translated">按钮编号、大小和位置。</li><li id="6025" class="nu nv iq kx b ky od lb oe le of li og lm oh lq nz oa ob oc bi translated">四行信息和问题，它们的大小和位置。</li></ol><blockquote class="om on oo"><p id="9f71" class="kv kw lr kx b ky kz jr la lb lc ju ld op lf lg lh oq lj lk ll or ln lo lp lq ij bi translated">如果你在游戏中实现了本地化，请注意下面的步骤，因为文本和按钮图像都应该本地化。</p></blockquote><p id="fad9" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">只要我们的游戏本地化为两种语言，英语和意大利语，我们就不会直接将问题的文本写成简单的<code class="fe oi oj ok ol b">String</code>，而是从<code class="fe oi oj ok ol b">Localizable.strings </code>文件中取出。</p><p id="9da9" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">这些字符串应该这样保存在该文件中；请注意，我们将它们分成了几行，以便在英语和意大利语版本中组织它们在屏幕上的位置:</p><pre class="kg kh ki kj gt os ol ot bn ou ov bi"><span id="e31e" class="ow lt iq ol b be ox oy l oz pa">//Localizable.strings(en)<br/><br/>"GotHit" = "You got hit!";<br/>"WatchVideo" = "Wanna watch a video";<br/>"ToContinue" = "to continue without";<br/>"YourProgress" = "losing your progress?";</span></pre><pre class="pe os ol ot bn ou ov bi"><span id="e3b9" class="ow lt iq ol b be ox oy l oz pa">//Localizable.strings(it)<br/><br/>"GotHit" = "Incidente!";<br/>"WatchVideo" = "Vuoi guardare un video";<br/>"ToContinue" = "per continuare senza";<br/>"YourProgress" = "perdere il tuo progresso?";</span></pre><p id="33ea" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">至于“是”和“否”按钮，它们是图像，请确保在资产中启用本地化，以便它们看起来像这样:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi pf"><img src="../Images/6f69f803de34f04b01e5be00ec530211.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*JrQPAYvR5RpNDJ7EEVLxOA.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">本地化的“是”按钮</p></figure><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi pf"><img src="../Images/b247333ea9d019c4abbbb2b927100048.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Wg3A3SuXk5B0_j1AMB8A3A.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated"><em class="pg">其实对于无按钮来说，没有太大的区别</em></p></figure><h1 id="259a" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">有奖广告实施(续)</h1><p id="d415" class="pw-post-body-paragraph kv kw iq kx b ky mk jr la lb ml ju ld le mm lg lh li mn lk ll lm mo lo lp lq ij bi translated">我们已经完成了准备工作。现在我们可以移动到<code class="fe oi oj ok ol b">GameScene</code>，在那里发生的行动！</p><p id="2d49" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">你可以为你的项目取一个不同的名字，但是这是游戏的发展方向。</p><p id="0cf0" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">在<code class="fe oi oj ok ol b">GameScene</code>中，首先，你需要将<code class="fe oi oj ok ol b">import GoogleMobileAds</code>放在文件的顶部。</p><pre class="kg kh ki kj gt os ol ot bn ou ov bi"><span id="1ead" class="ow lt iq ol b be ox oy l oz pa">//GameScene.swift<br/><br/>import GoogleMobileAds<br/>//...</span></pre><p id="98c4" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">然后，在<code class="fe oi oj ok ol b">GameScene </code>类中，创建<code class="fe oi oj ok ol b">private var rewardAdHelper = RewardedAdHelper()</code>。这将是<code class="fe oi oj ok ol b">RewardedAdHelper</code>的一个实例，所以我们将能够很容易地调用它的函数。</p><pre class="kg kh ki kj gt os ol ot bn ou ov bi"><span id="c6bb" class="ow lt iq ol b be ox oy l oz pa">//GameScene.swift<br/><br/>//...<br/><br/>class GameScene: SKScene {<br/> private var rewardAdHelper = RewardedAdHelper()<br/>//...<br/>}</span></pre><p id="9370" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">找到<code class="fe oi oj ok ol b">override func didMove() </code>，在它的花括号内，添加<code class="fe oi oj ok ol b">rewardAdHelper.loadRewardedAd()</code>。这将在你从<code class="fe oi oj ok ol b">StartScene</code>移动到<code class="fe oi oj ok ol b">GameScene</code>时加载广告，因为在显示之前，它必须先被加载。</p><pre class="kg kh ki kj gt os ol ot bn ou ov bi"><span id="530e" class="ow lt iq ol b be ox oy l oz pa">//GameScene.swift<br/><br/>//...<br/><br/>class GameScene: SKScene {<br/> //...<br/><br/> override func didMove(to view: SKView) {<br/>  rewardAdHelper.loadRewardedAd()<br/><br/>  //all the rest code of your game<br/> }<br/>}</span></pre><p id="7e4f" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">现在，还记得我们之前创造的<code class="fe oi oj ok ol b">QuestionScreen</code>吗？我们需要一个函数在<code class="fe oi oj ok ol b">GameScene</code>中显示它。</p><p id="1e3d" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">在<code class="fe oi oj ok ol b">GameScene</code>中声明的其他变量中，添加这个变量:<code class="fe oi oj ok ol b">private var questionScreen = QuestionScreen()</code>。这是之前创建的<code class="fe oi oj ok ol b">QuestionScreen</code>的一个实例。</p><pre class="kg kh ki kj gt os ol ot bn ou ov bi"><span id="c7ae" class="ow lt iq ol b be ox oy l oz pa">//GameScene.swift<br/><br/>//...<br/><br/>class GameScene: SKScene {<br/> //...<br/> private var questionScreen = QuestionScreen()<br/>}</span></pre><p id="4dea" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">然后，仍然在<code class="fe oi oj ok ol b">GameScene</code>类内部，创建一个函数<code class="fe oi oj ok ol b">showQuestion() </code>来显示这个问题屏幕:</p><pre class="kg kh ki kj gt os ol ot bn ou ov bi"><span id="eb88" class="ow lt iq ol b be ox oy l oz pa">//GameScene.swift<br/><br/>//...<br/><br/>class GameScene: SKScene {<br/><br/>//...<br/><br/>override func didMove(to view: SKView) {<br/> //...<br/>}<br/><br/>func showQuestion() {<br/>      self.run(SKAction.wait(forDuration: 0.0001)){<br/>         self.pauseChilds(isPaused: true)<br/>      }<br/>      paws = true<br/>      questionScreen.zPosition = 120<br/>      if self.childNode(withName: "questionScreen") == nil {<br/>         self.addChild(questionScreen)<br/>      }<br/>   }<br/>}</span></pre><p id="4af6" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated"><code class="fe oi oj ok ol b">pauseChilds</code>和<code class="fe oi oj ok ol b">paws</code>此处停止<code class="fe oi oj ok ol b">GameScene</code>中物体的移动，并控制是否暂停。</p><p id="dc5e" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">我的意思是，当你在“是”和“否”之间做出选择时，你不希望玩家被移动的汽车撞到，对吗？</p><p id="a707" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">这也有助于我们将分数保持在当前点，这样如果用户决定观看奖励广告，尽管玩家被击中，分数也不会变为零。</p><p id="169d" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">我们终于完成了准备工作。让我们开始行动吧！</p><p id="c1e8" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">让我们定义广告应该在哪个事件之后显示。从逻辑上来说，用户选择了“是”之后(“T20”是，我希望观看一个广告继续播放，而不会在被击中后失去我的分数“)。但是为了让用户选择“是”或“否”，我们需要在用户被汽车或卡车撞了之后立即显示问题屏幕。</p><ol class=""><li id="7556" class="nu nv iq kx b ky kz lb lc le pb li pc lm pd lq nz oa ob oc bi translated">找到杀死你的玩家(或者让他们输)并触发游戏场景的功能。在我们的例子中，这个函数叫做<code class="fe oi oj ok ol b">func playerHit(car: SKSpriteNode)</code>。在里面，评论揭示游戏结束场景的函数(在我们的例子中是<code class="fe oi oj ok ol b">showGameOver()</code>)，我们以后会用到它。</li><li id="a43e" class="nu nv iq kx b ky od lb oe le of li og lm oh lq nz oa ob oc bi translated">仍在该函数内时，调用<code class="fe oi oj ok ol b">showQuestion()</code>函数。</li></ol><pre class="kg kh ki kj gt os ol ot bn ou ov bi"><span id="76b2" class="ow lt iq ol b be ox oy l oz pa">//GameScene.swift<br/><br/>//...<br/><br/>class GameScene: SKScene {<br/><br/>//...<br/><br/>override func didMove(to view: SKView) {<br/> //...<br/>}<br/><br/> //...<br/><br/> func playerHit(car: SKSpriteNode){<br/>  //showGameOver()<br/>  showQuestion()<br/> }<br/>}</span></pre><p id="2a0d" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">因此，一旦玩家被车撞了，窗口就会显示关于广告的问题。</p><p id="742f" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">如果你有几个事件或功能，使玩家输了，并揭示了游戏超过现场，不要忘记重复步骤1和2。在我们的例子中，我们在函数<code class="fe oi oj ok ol b">func playerHit(truck: SKSpriteNode)</code>中重复它们，因为汽车和卡车都能杀死玩家。</p><pre class="kg kh ki kj gt os ol ot bn ou ov bi"><span id="1639" class="ow lt iq ol b be ox oy l oz pa">//GameScene.swift<br/><br/>//...<br/><br/>class GameScene: SKScene {<br/><br/>//...<br/><br/>override func didMove(to view: SKView) {<br/> //...<br/>}<br/><br/> //...<br/><br/> func playerHit(truck: SKSpriteNode){<br/>  //showGameOver()<br/>  showQuestion()<br/> }<br/>}</span></pre><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi ph"><img src="../Images/46216f34fb937a08c4132675d1247865.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*tX3D139qCbPRz4_IO3ER-w.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated"><em class="pg">行动上的问题画面</em></p></figure><p id="9bc5" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">当您还在游戏场景中时，找到函数<code class="fe oi oj ok ol b">touchesBegan</code>，它定义了每个被触摸的按钮的动作，并在其中添加以下条件:</p><pre class="kg kh ki kj gt os ol ot bn ou ov bi"><span id="7c37" class="ow lt iq ol b be ox oy l oz pa">//GameScene.swift<br/><br/>//...<br/><br/>class GameScene: SKScene {<br/><br/>   //...<br/>   <br/>   override func didMove(to view: SKView) {<br/>    //...<br/>   }<br/>   <br/>   override func touchesBegan(_ touches: Set&lt;UITouch&gt;, with event: UIEvent?) {<br/>   <br/>   if nodeTouched.name == "YesBtn" {<br/>            // show reward ad, then reveal game with saved score<br/>            rewardAdHelper.showRewardedAd(viewController: self.view!.window!.rootViewController!)<br/>            questionScreen.removeFromParent()<br/>            backgroundMusicPlayer.volume = 0.0<br/>            self.run(SKAction.wait(forDuration: 2.0)){<br/>               self.addRewardButton()<br/>            }   <br/>       }<br/>    }<br/>}</span></pre><p id="c43d" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">这里我们调用显示来自<code class="fe oi oj ok ol b">RewardAdHelper</code>的广告的函数。记得把问题屏幕去掉(我们得到了我们的答案，我们不再需要它了)，把背景音乐的音量调为零(<em class="lr">我的意思是，你不希望它和广告里的音乐搞混吧？</em>)。</p><blockquote class="om on oo"><p id="71da" class="kv kw lr kx b ky kz jr la lb lc ju ld op lf lg lh oq lj lk ll or ln lo lp lq ij bi translated"><em class="iq">注意我们到底如何调用</em> <code class="fe oi oj ok ol b"><em class="iq">showRewardedAd() </em></code> <em class="iq">函数。如你所知，在</em> <code class="fe oi oj ok ol b"><em class="iq">RewardedAdHelper</em></code> <em class="iq">中它被定义为</em> <code class="fe oi oj ok ol b"><em class="iq">func showRewardedAd(viewController: UIViewController)</em></code></p></blockquote><p id="f37e" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">我们这里有个小问题。我们的<code class="fe oi oj ok ol b">GameScene</code>不是<code class="fe oi oj ok ol b">UIViewController</code>，只是<code class="fe oi oj ok ol b">SKScene</code>。这就是为什么，为了能够调用<code class="fe oi oj ok ol b">showRewardedAd </code>函数，作为它的参数，我们必须使用这个超长的<code class="fe oi oj ok ol b">(viewController: self.view!.window!.rootViewController!)</code></p><ul class=""><li id="4b5a" class="nu nv iq kx b ky kz lb lc le pb li pc lm pd lq pi oa ob oc bi translated"><code class="fe oi oj ok ol b">view</code>是当前呈现场景的视图。它继承自<code class="fe oi oj ok ol b">SKView</code>，一个呈现<code class="fe oi oj ok ol b">SpriteKit</code>场景的视图子类。如果场景当前不存在，该属性保持<code class="fe oi oj ok ol b">nil</code>。就我们所呈现的场景而言，我们强制展开<code class="fe oi oj ok ol b">view</code>。</li><li id="c443" class="nu nv iq kx b ky od lb oe le of li og lm oh lq pi oa ob oc bi translated"><code class="fe oi oj ok ol b">window</code>是接收方的窗口对象。</li><li id="aaae" class="nu nv iq kx b ky od lb oe le of li og lm oh lq pi oa ob oc bi translated"><code class="fe oi oj ok ol b">rootViewController</code>继承自<code class="fe oi oj ok ol b">UIViewController</code>类。</li></ul><p id="55cd" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">现在，这个<code class="fe oi oj ok ol b">addRewardButton()</code>功能是什么？让用户在看完广告后决定何时继续播放就好了(如果他们刚从公交车上走出来怎么办？)所以，我们再加一个按钮，让我们继续游戏。</p><p id="453f" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">回到声明所有函数的地方，在其中一些函数之间，添加<code class="fe oi oj ok ol b">addRewardButton()</code>:</p><pre class="kg kh ki kj gt os ol ot bn ou ov bi"><span id="1cfc" class="ow lt iq ol b be ox oy l oz pa">//GameScene.swift<br/><br/>//...<br/><br/>class GameScene: SKScene {<br/><br/>   //...<br/>   <br/>   override func didMove(to view: SKView) {<br/>    //...<br/>   }<br/>   //...<br/>  func addRewardButton(){<br/>     let rewardButton = SKSpriteNode(imageNamed: "RewardEng")<br/>        // Name the start node for touch detection:<br/>        rewardButton.name = "RewardBtn"<br/>        rewardButton.zPosition = 200<br/>        rewardButton.position = CGPoint(x: frame.midX, y: frame.midY)<br/>        rewardButton.setScale(1.5)<br/>        <br/>        addChild(rewardButton)<br/>     }<br/>}</span></pre><p id="259c" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">这个函数创建一个按钮，让用户继续播放，并设置它的位置、大小等。现在，只要用户关闭广告窗口，他们就会看到这个按钮(希望他们也会按下它)。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi pj"><img src="../Images/26bdf44de8494b7d543ab6079b0ee7d6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*xpU_bO80MiishmU-b7BFWA.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">确保此按钮已针对您使用的所有语言进行了本地化！</p></figure><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi ph"><img src="../Images/57bc83e768c89dfbd2e576b1ffe2fabf.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*CfkFV5ZmuSqgYpMdE4YvFw.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated"><em class="pg">这是奖励按钮的显示方式</em></p></figure><p id="e3ec" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">用户不想看广告怎么办？</p><p id="06bc" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">在函数<code class="fe oi oj ok ol b">touchesBegan</code>中，在前面带有“YesBtn”的if语句的右花括号后，添加新的if语句:</p><pre class="kg kh ki kj gt os ol ot bn ou ov bi"><span id="da7c" class="ow lt iq ol b be ox oy l oz pa">//GameScene.swift<br/><br/>//...<br/><br/>class GameScene: SKScene {<br/><br/>   //...<br/>   <br/>   override func didMove(to view: SKView) {<br/>    //...<br/>   }<br/>   <br/>   override func touchesBegan(_ touches: Set&lt;UITouch&gt;, with event: UIEvent?) {<br/>   <br/>    if nodeTouched.name == "YesBtn" {<br/>       //...<br/>     } else if nodeTouched.name == "NoBtn" {<br/>              //show game over scene<br/>              showGameOver()  <br/>           }<br/>     }<br/>}</span></pre><p id="cd9d" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">在这里，我们打开游戏场景。</p><p id="2561" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">现在，如果用户观看了广告，我们需要让他们继续玩下去。在前一个if语句的右花括号后，添加以下if语句:</p><pre class="kg kh ki kj gt os ol ot bn ou ov bi"><span id="c2b2" class="ow lt iq ol b be ox oy l oz pa">//GameScene.swift<br/><br/>//...<br/><br/>class GameScene: SKScene {<br/><br/>   //...<br/>   <br/>   override func didMove(to view: SKView) {<br/>    //...<br/>   }<br/>   <br/>   override func touchesBegan(_ touches: Set&lt;UITouch&gt;, with event: UIEvent?) {<br/>     if nodeTouched.name == "YesBtn" {<br/>       //...<br/>     } else if nodeTouched.name == "NoBtn" {<br/>              //...  <br/>           } else if nodeTouched.name == "RewardBtn" {<br/>              run(buttonSound)<br/>              nodeTouched.removeFromParent()<br/>              backgroundMusicPlayer.play()<br/>             <br/>              backgroundMusicPlayer.volume = 1.0<br/>     <br/>              self.pauseChilds(isPaused: false)<br/>              self.paws = false<br/>      }<br/>   }<br/>}</span></pre><p id="d51a" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">在这里，我们解除所有游戏对象的暂停，将背景音乐恢复到正常音量，并移除按下的按钮，这样就不会影响游戏内容。</p><p id="9f78" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">满意的用户继续玩，他们的分数没有变为零。太好了！</p><h1 id="c295" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">Ads数量限制:实施</h1><p id="6f7c" class="pw-post-body-paragraph kv kw iq kx b ky mk jr la lb ml ju ld le mm lg lh li mn lk ll lm mo lo lp lq ij bi translated">理论上，我们可以就此打住，在App Store上发布更新。但是如果用户注意到，不管他们是否死亡，他们仍然可以继续玩，而不会有任何后果，这将部分扼杀游戏的精神——毕竟，它的目的之一是躲避汽车！</p><p id="163e" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">让我们把可能的广告观看量限制在三个(<em class="lr"> santa trinità </em>)。</p><p id="eaf8" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">为此，仍然在<code class="fe oi oj ok ol b">GameScene</code>中，在其他变量中，声明这一个:<code class="fe oi oj ok ol b">var rewardsWatched = 0</code></p><pre class="kg kh ki kj gt os ol ot bn ou ov bi"><span id="643d" class="ow lt iq ol b be ox oy l oz pa">//  GameScene.swift<br/><br/>class GameScene: SKScene {<br/> //...<br/> <strong class="ol ir">var rewardsWatched = 0</strong><br/> //...<br/>}</span></pre><p id="3a84" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">然后，在if语句<code class="fe oi oj ok ol b">else if nodeTouched.name == "RewardBtn" </code>中添加这一行:<code class="fe oi oj ok ol b">rewardsWatched += 1</code></p><pre class="kg kh ki kj gt os ol ot bn ou ov bi"><span id="33c6" class="ow lt iq ol b be ox oy l oz pa">//GameScene.swift<br/><br/>//...<br/><br/>class GameScene: SKScene {<br/><br/>   //...<br/>   <br/>   override func didMove(to view: SKView) {<br/>    //...<br/>   }<br/>   <br/>   override func touchesBegan(_ touches: Set&lt;UITouch&gt;, with event: UIEvent?) {<br/>    //...<br/>   else if nodeTouched.name == "RewardBtn" {<br/>         //...<br/>       rewardsWatched += 1<br/>      }<br/>   }<br/>}</span></pre><p id="9b54" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">所以，每次用户看完广告后按下奖励按钮，我们就知道又看了一个广告。</p><p id="f5e9" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">返回到<code class="fe oi oj ok ol b">func playerHit(car: SKSpriteNode)</code>(或者你游戏中触发玩家失败的任何功能)，取消之前注释的<code class="fe oi oj ok ol b">showGameOver()</code>，并将其嵌入if语句<code class="fe oi oj ok ol b">if rewardsWatched &gt; 2</code>。然后将<code class="fe oi oj ok ol b">showQuestion()</code>功能嵌入<code class="fe oi oj ok ol b">else if rewardsWatched &lt;= 2</code>:</p><pre class="kg kh ki kj gt os ol ot bn ou ov bi"><span id="c189" class="ow lt iq ol b be ox oy l oz pa">//GameScene.swift<br/><br/>//...<br/><br/>class GameScene: SKScene {<br/><br/>//...<br/><br/>override func didMove(to view: SKView) {<br/> //...<br/>}<br/><br/> //...<br/><br/>  func playerHit(car: SKSpriteNode){<br/>   if rewardsWatched &gt; 2 {<br/>   showGameOver()<br/>  } else if rewardsWatched &lt;= 2 {<br/>   showQuestion()<br/>  } <br/> }<br/>}</span></pre><p id="020a" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">如果你有更多触发玩家失败的功能，不要忘记在它们里面重复这些动作。在我们这里是<code class="fe oi oj ok ol b">func playerHit(truck: SKSpriteNode)</code>。</p><pre class="kg kh ki kj gt os ol ot bn ou ov bi"><span id="fec2" class="ow lt iq ol b be ox oy l oz pa">//GameScene.swift<br/><br/>//...<br/><br/>class GameScene: SKScene {<br/><br/>  //...<br/>  <br/>  override func didMove(to view: SKView) {<br/>   //...<br/>  }<br/>  <br/>   //...<br/>  <br/>    func playerHit(truck: SKSpriteNode){<br/>       if rewardsWatched &gt; 2 {<br/>       showGameOver()<br/>      } else if rewardsWatched &lt;= 2 {<br/>       showQuestion()<br/>     }<br/>    <br/>   }<br/>}</span></pre><p id="713e" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">现在，在玩家选择观看广告三次后，他们将只能在第四次被击中后看到游戏结束的场景。</p><h1 id="8efe" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">广告时间限制:实施</h1><p id="665f" class="pw-post-body-paragraph kv kw iq kx b ky mk jr la lb ml ju ld le mm lg lh li mn lk ll lm mo lo lp lq ij bi translated">看起来我们可以在这里冷静下来，但如果你测试这个游戏，你会注意到，在你按下游戏场景上的“重启”或“退出”然后点击屏幕玩游戏后，你再次有机会在被击中后观看广告。这仍然有点损害游戏的精神。毕竟，我们想让这个有回报的广告成为给用户的一份难得的礼物。</p><p id="bdf2" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">为了解决这个问题，我们可以每六个小时显示一次奖励广告。</p><p id="eda0" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">为此，我们需要保存用户在<code class="fe oi oj ok ol b">UserDefaults</code>中第三次观看广告的时间，然后在这一时刻之后计算六个小时。</p><p id="6706" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">转到功能<code class="fe oi oj ok ol b">touchesBegan</code>。在<code class="fe oi oj ok ol b">RewardBtn</code>的if语句中，添加以下条件:</p><pre class="kg kh ki kj gt os ol ot bn ou ov bi"><span id="9eb4" class="ow lt iq ol b be ox oy l oz pa">//GameScene.swift<br/><br/>//...<br/><br/>class GameScene: SKScene {<br/><br/>   //...<br/>   <br/>   override func didMove(to view: SKView) {<br/>    //...<br/>   }<br/>   <br/>   override func touchesBegan(_ touches: Set&lt;UITouch&gt;, with event: UIEvent?) {<br/>    //...<br/>   else if nodeTouched.name == "RewardBtn" {<br/>           //...<br/>     if rewardsWatched == 2 {<br/>                 UserDefaults.standard.set(Date.now, forKey: "lastRevive")<br/>        }<br/>      }<br/>   }<br/>}</span></pre><p id="5e15" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated"><code class="fe oi oj ok ol b">Date.now</code>定义当前时刻，我们把它连接到用户第二次看完广告后按下奖励按钮继续播放的时刻。之后，我们将这个特殊的时刻保存在<code class="fe oi oj ok ol b">UserDefaults</code>中，这样即使你退出游戏、关掉手机等，游戏也会记住它。</p><p id="e9aa" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">现在我们需要计算从这个保存的时刻开始的时间间隔，并检查是否已经过了六个小时。为此，请转到类的顶部，在那里声明了所有属性，并添加此属性:</p><p id="9478" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated"><code class="fe oi oj ok ol b">let lastRevive = UserDefaults.standard.object(forKey: "lastRevive") as? Date</code></p><pre class="kg kh ki kj gt os ol ot bn ou ov bi"><span id="c499" class="ow lt iq ol b be ox oy l oz pa">//GameScene.swift<br/><br/>//...<br/><br/>class GameScene: SKScene {<br/> //...<br/><strong class="ol ir"> let lastRevive = UserDefaults.standard.object(forKey: "lastRevive") as? Date<br/></strong> //...<br/>}</span></pre><p id="7728" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">正如你所看到的，这个属性有相同的键，<code class="fe oi oj ok ol b">lastRevive</code>和当用户点击奖励按钮时我们保存在<code class="fe oi oj ok ol b">UserDefaults</code>中的键。我们还需要将其定义为<code class="fe oi oj ok ol b">Date</code>，以便能够从这一点开始计算时间间隔。</p><p id="388f" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">如您所见，我们在这里使<code class="fe oi oj ok ol b">lastRevive</code>成为可选的，因为这个对象属于类型<code class="fe oi oj ok ol b">Any</code>，它可以表示任何类型的实例。如果你试图简单地定义它<code class="fe oi oj ok ol b">as Date</code>，XCode会给你以下错误”</p><p id="e984" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">“<em class="lr">‘有吗？’不能转换为“日期””</em></p><p id="0df4" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">要解决这个问题，您可以强制解开<code class="fe oi oj ok ol b">as! Date</code>，但是在这种情况下，当您从主菜单场景进入游戏场景时，游戏将会崩溃，因为在游戏开始时，键<code class="fe oi oj ok ol b">lastRevive</code>的对象还不存在。只有在用户第二次按下奖励按钮后才会出现，所以当你试图强行解包时会有<code class="fe oi oj ok ol b">nil</code>。为了避免崩溃，最好将其定义为可选类型。</p><p id="1512" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">然而，要进一步使用这个属性，我们必须打开它。如果我们在玩家撞上汽车时打开它(这是我们检查用户是否可以观看奖励广告的地方)，我们会因为同样的原因再次崩溃:键<code class="fe oi oj ok ol b">lastRevive</code>的对象还没有被创建和保存。</p><p id="e291" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">为了避免这种情况，让我们在<code class="fe oi oj ok ol b">lastRevive</code>之后创建一个布尔值<code class="fe oi oj ok ol b">var checkingTime = false</code>:</p><pre class="kg kh ki kj gt os ol ot bn ou ov bi"><span id="3dbc" class="ow lt iq ol b be ox oy l oz pa">//GameScene.swift<br/><br/>//...<br/><br/>class GameScene: SKScene {<br/> //...<br/> let lastRevive = UserDefaults.standard.object(forKey: "lastRevive") as? Date<br/> <strong class="ol ir">var checkingTime = false</strong><br/> //...<br/>}</span></pre><p id="ef0b" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">如果该布尔值为假，则还没有六小时倒计时，所以没有什么可检查的，用户可以观看广告。</p><p id="5ceb" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">现在转到<code class="fe oi oj ok ol b">didMove</code>函数，在里面添加这个条件:</p><pre class="kg kh ki kj gt os ol ot bn ou ov bi"><span id="2ecd" class="ow lt iq ol b be ox oy l oz pa">//GameScene.swift<br/><br/>//...<br/><br/>class GameScene: SKScene {<br/><br/>   //...<br/>   <br/>   override func didMove(to view: SKView) {<br/>       if lastRevive == nil {<br/>              checkingTime = false<br/>           } else if lastRevive != nil {<br/>              if Date.now.timeIntervalSince(lastRevive!) &lt; 21600 {<br/>                 checkingTime = true<br/>              } else if Date.now.timeIntervalSince(lastRevive!) &gt; 21600 {<br/>                 checkingTime = false<br/>              }<br/>          }<br/>     //...<br/>   }<br/>   <br/>    //...<br/>}</span></pre><p id="f596" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">这里，我们检查<code class="fe oi oj ok ol b">lastRevive</code>是否已经定义并保存。如果没有，我们不检查时间间隔，游戏继续进行，并有机会观看广告。</p><p id="14ad" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">如果它已经被定义并保存(在用户第二次按下奖励按钮之后)，我们可以强制打开它，并检查从它被保存在<code class="fe oi oj ok ol b">UserDefaults</code>中的时刻到当前时间是否已经过了<code class="fe oi oj ok ol b">21600</code>秒(正好6小时)。如果经过的秒数小于<code class="fe oi oj ok ol b">21600</code>(六小时)，布尔<code class="fe oi oj ok ol b">checkingTime</code>变为真。否则，它又变成假的。</p><p id="893c" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">现在转到使玩家失败的函数(在我们的例子中是<code class="fe oi oj ok ol b">func playerHit(car: SKSpriteNode)</code>)并修改第一个if语句，使其看起来像这样:<code class="fe oi oj ok ol b">if checkingTime == true || rewardsWatched &gt; 2</code>。</p><pre class="kg kh ki kj gt os ol ot bn ou ov bi"><span id="2816" class="ow lt iq ol b be ox oy l oz pa">//GameScene.swift<br/><br/>//...<br/><br/>class GameScene: SKScene {<br/><br/>//...<br/><br/>override func didMove(to view: SKView) {<br/> //...<br/>}<br/><br/> //...<br/><br/>  func playerHit(car: SKSpriteNode){<br/>   <strong class="ol ir">if checkingTime == true || rewardsWatched &gt; 2</strong> {<br/>   showGameOver()<br/>  } else if rewardsWatched &lt;= 2 {<br/>   showQuestion()<br/>  }<br/>  <br/> }<br/>}</span></pre><p id="0406" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">每次玩家被车撞了，我们都会检查自上次观看广告以来的六个小时的时间间隔是否还在过去，或者用户是否已经观看了两个以上的奖励广告。如果这些条件中至少有一个为真，游戏结束场景将立即出现。</p><p id="7bf7" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">对任何其他使玩家失败的功能重复此步骤(在我们的例子中为<code class="fe oi oj ok ol b">func playerHit(truck: SKSpriteNode)</code>)。</p><pre class="kg kh ki kj gt os ol ot bn ou ov bi"><span id="64f1" class="ow lt iq ol b be ox oy l oz pa">//GameScene.swift<br/><br/>//...<br/><br/>class GameScene: SKScene {<br/><br/>  //...<br/>  <br/>  override func didMove(to view: SKView) {<br/>   //...<br/>  }<br/>  <br/>   //...<br/>    <br/>      func playerHit(truck: SKSpriteNode){<br/>       <strong class="ol ir">if checkingTime == true || rewardsWatched &gt; 2</strong> {<br/>       showGameOver()<br/>      } else if rewardsWatched &lt;= 2 {<br/>       showQuestion()<br/>     }<br/>   }<br/>}</span></pre><p id="70ef" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">这就是了！现在，用户将能够连续观看广告并获得奖励(即，在被击中后继续玩而不失去他们的分数)仅三次，并且将仅在自第三次起的六个小时后再次获得该礼物。</p><p id="c953" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">如果你想100%确定一切都按你计划的那样运行，你可以减少秒数，比如120(两分钟)，然后检查广告是否会在这个时间间隔后再次出现。</p></div><div class="ab cl pk pl hu pm" role="separator"><span class="pn bw bk po pp pq"/><span class="pn bw bk po pp pq"/><span class="pn bw bk po pp"/></div><div class="ij ik il im in"><p id="62ee" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">现在你可以在App Store上发布你的更新，然后到处都是垃圾邮件，垃圾邮件，垃圾邮件，所以观看奖励广告会给你带来一些钱</p><p id="13a3" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">…但那是另一个故事了。</p><p id="1c06" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">如果您对更好地实现所描述的方法有任何建议，请随时告诉我。</p><h1 id="9013" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">资源</h1><ol class=""><li id="bf59" class="nu nv iq kx b ky mk lb ml le nw li nx lm ny lq nz oa ob oc bi translated"><em class="lr">谷歌AdMob指南:</em><a class="ae nh" href="https://developers.google.com/admob/ios/quick-start" rel="noopener ugc nofollow" target="_blank">https://developers.google.com/admob/ios/quick-start</a></li><li id="dbed" class="nu nv iq kx b ky od lb oe le of li og lm oh lq nz oa ob oc bi translated"><em class="lr">在AdMob指南中设置app:</em><a class="ae nh" href="https://support.google.com/admob/answer/9989980?utm_source=developers.google.com&amp;utm_medium=referral&amp;visit_id=638063717918329050-1143239393&amp;rd=1" rel="noopener ugc nofollow" target="_blank">https://support.google.com/admob/answer/9989980?UTM _ source = developers . Google . com&amp;UTM _ medium = referral&amp;visit _ id = 638063717918329050-1143239393&amp;rd = 1</a></li><li id="9398" class="nu nv iq kx b ky od lb oe le of li og lm oh lq nz oa ob oc bi translated"><em class="lr">有奖广告指南:</em>【https://developers.google.com/admob/ios/rewarded T2】</li><li id="67f4" class="nu nv iq kx b ky od lb oe le of li og lm oh lq nz oa ob oc bi translated">找到你的应用id和广告单元id指南:<a class="ae nh" href="https://support.google.com/admob/answer/7356431" rel="noopener ugc nofollow" target="_blank">https://support.google.com/admob/answer/7356431</a></li><li id="efcd" class="nu nv iq kx b ky od lb oe le of li og lm oh lq nz oa ob oc bi translated"><em class="lr">中轴:产品页面和团队信息:</em><a class="ae nh" href="https://oasis-record-e98.notion.site/Median-Axis-664c8be4409f47249111f6c04f483b9b" rel="noopener ugc nofollow" target="_blank">https://oasis-record-e98 . orgion . site/Median-Axis-664 c8 be 4409 f 47249111 f 6 c 04 f 483 b 9 b</a></li></ol></div></div>    
</body>
</html>