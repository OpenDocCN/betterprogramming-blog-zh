<html>
<head>
<title>Circuit Breakers and Auto-Scaling</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">断路器和自动缩放</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/circuit-breakers-and-auto-scaling-1d68a2761164?source=collection_archive---------10-----------------------#2020-05-07">https://betterprogramming.pub/circuit-breakers-and-auto-scaling-1d68a2761164?source=collection_archive---------10-----------------------#2020-05-07</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="b16b" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">导致灾难的因素</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/06277cc05885015c5a086dc0da4eabea.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*BHZrOHWg8F0UzCR7"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">照片由<a class="ae ky" href="https://unsplash.com/@magnusengo?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">马格努斯·恩格</a>在<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>拍摄。</p></figure><p id="cea4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">本文讨论了混合断路器与自动缩放引起的理论延长服务中断。我们调查了停机的原因以及一些潜在的缓解方案。</p><p id="e094" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果你正在考虑在你的服务中一起使用这些，请确保你了解你正在进入什么。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="fe28" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">自动缩放</h1><p id="7fb4" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">部署到云的好处之一是充分利用按需定价。这使我们能够在需要时提供更多资源，在不需要时削减成本。大多数交通状况会随着一天中的时间、季节甚至一年中的特定日子而变化。自动扩展使我们能够控制成本，同时仍能有效处理流量。</p><p id="d7a8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">要成功做到这一点，我们的服务必须知道何时需要更多资源来处理当前负载。这通常是通过查看一个服务在每个实例中接收到多少请求，并确保它不会超过已知的限制来实现的。如果您对如何找到这个限制感兴趣，请查看这篇文章，它解释了如何使用性能测试来达到这个目的。</p><p id="93b3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在Kubernetes中，用于计算服务需要多少吊舱的方程被定义为<code class="fe mz na nb nc b">desiredReplicas = ceil[currentReplicas * ( currentMetricValue / desiredMetricValue )]</code>，其中<code class="fe mz na nb nc b">desiredMetricValue</code>是服务的已知极限。<code class="fe mz na nb nc b">ceil</code>函数对结果进行舍入，确保有足够的pod来满足请求的数量。由于定期评估指标和必须启动新实例，自动伸缩会有一些延迟，因此在期望的指标值中应该有一些“喘息空间”。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="b326" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">断路器</h1><p id="e1e3" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">断路器是在故障情况下保护您的应用程序的好方法。你应该预料到事情会失败。这在微服务/Kubernetes世界中更为重要，因为事物总是在不断变化。在马丁·福勒的博客上可以找到关于断路器的背景知识。</p><p id="5740" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">断路器包装了一个您认为可能会失败的功能，这可能会对您的服务造成额外的压力。当它确实失败时(并且失败次数超过配置的阈值)，断路器会断开并停止评估该功能。通过停止函数的执行，它停止了级联故障，并给下游服务一个自我修复的机会。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="44e0" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">灾难来袭</h1><p id="2828" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">断路器和自动缩放听起来很棒。它们都使您的服务对负载和故障更有弹性。他们怎么会引起问题呢？</p><p id="4d4b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">假设服务A与服务b对话。服务A在对服务b的调用周围有一个断路器。这两个服务都配置了自动扩展功能，并且每个服务都可以轻松运行10个pod。服务B现在断电，但幸运的是，服务A中的断路器打开，它继续为其客户服务，但处于降级状态。一切都很好——至少在失败的情况下是这样。</p><p id="b0d2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">服务B现在恢复运行。断路器闭合，因为对服务B的请求再次成功解析。问题是，由于服务B没有接收到请求，它已经被自动缩放器缩减到了它的最小pod数量。现在，来自服务A的10个pod的满负荷进入服务B，但是服务B不能处理该负荷，请求开始超时，并且断路器再次打开。如此循环往复。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="a66b" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">我们如何防范这种情况？</h1><p id="4085" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">有几种方法可以修复或防止这种导致服务永远无法恢复的循环。其中一些解决方案比其他解决方案更好，这取决于它们是需要人工干预，还是可以自行解决问题的永久性解决方案。</p><p id="9b82" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">大多数自动缩放逻辑只有在冷却一段时间后才会缩小。对于K8s来说，这是五分钟。如果断路器打开的时间少于五分钟，那么服务将不会缩减，并且一旦断路器打开，服务将能够处理负载。如果服务已经缩减，则在服务恢复后手动扩展将会阻止其被淹没，并继续正常运行。由于手动干预，这不是一个很好的解决方案，但如果您没有准备好，这是一个很好的快速修复方法。</p><p id="e451" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果自动缩放是基于即使断路器断开时请求仍被计数的度量，则自动缩放器不会按比例缩小。这可能很难实现，因为度量是在被缩放的服务的外部服务中。它还必须汇总来自多个应用程序的指标，并且所有应用程序都必须公开这些指标。这看起来需要做很多工作来防止这个问题，客户端很容易违反这个标准，由于没有足够的实例可用而导致停机。</p><p id="00df" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><a class="ae ky" href="https://github.com/nodeshift/opossum" rel="noopener ugc nofollow" target="_blank">负鼠</a>、<a class="ae ky" href="https://github.com/Netflix/Hystrix" rel="noopener ugc nofollow" target="_blank">海斯特里克斯</a>和<a class="ae ky" href="https://github.com/resilience4j/resilience4j" rel="noopener ugc nofollow" target="_blank">瑞西琳4J </a>在请求开始工作后全部打开。这会导致对下游服务的大量请求。如果断路器可以选择将负载缓慢增加回服务状态，这将为下游自动定标器提供反应时间。这可以进行配置，以匹配自动定标器的响应速度。对我来说，这似乎是最好的解决方案。然而，这将需要对断路器实施进行核心变更。</p><p id="8366" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果您的自动缩放器可以响应流量峰值，并且您的服务启动时间不长，这可能不是问题。当断路器在断电后断开时，只要自动定标器在断路器再次闭合之前启动更多实例，下次断路器断开时，更多请求可能会成功。断路器跳闸可能需要几轮，但只要断路器的重试时间足够短，并且自动定标器的响应速度足够快，能够按比例放大，问题最终应该会得到解决。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="e34a" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">结论</h1><p id="c99c" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">希望您现在已经了解断路器和自动缩放会如何使问题变得更糟。如果您对这种情况或该问题的其他解决方案有任何经验，请在评论部分告诉我。</p></div></div>    
</body>
</html>