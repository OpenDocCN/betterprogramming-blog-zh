<html>
<head>
<title>3 Steps to Creating Dynamic Views in Angular</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">在Angular中创建动态视图的3个步骤</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/3-steps-to-creating-dynamic-views-in-angular-9df80e3e3d6b?source=collection_archive---------0-----------------------#2019-11-30">https://betterprogramming.pub/3-steps-to-creating-dynamic-views-in-angular-9df80e3e3d6b?source=collection_archive---------0-----------------------#2019-11-30</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="055c" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">无指令动态加载组件</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/0ced5422e8e77e5af50ed39e80ba2ad3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*65xWwW2q17RhUjYY"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">照片由<a class="ae ky" href="https://unsplash.com/@emilep?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">émile Perron</a>在<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</p></figure><h1 id="660f" class="kz la it bd lb lc ld le lf lg lh li lj jz lk ka ll kc lm kd ln kf lo kg lp lq bi translated">语境</h1><p id="4c15" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">很多时候，我们需要动态地呈现子视图。例如，我们可能有一个带有选项卡菜单的父视图，我们希望根据选择的选项卡来呈现视图。</p><p id="58e3" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">作为Angular的新手，这是我经历过的事情，尽管遵循了官方的<a class="ae ky" href="http://angular.io" rel="noopener ugc nofollow" target="_blank"> Angular </a>指南，我还是花了相当多的时间来实现工作。阅读Maxim Koretskyi关于<a class="ae ky" href="https://hackernoon.com/exploring-angular-dom-abstractions-80b3ebcfc02" rel="noopener ugc nofollow" target="_blank"> DOM操纵</a>的文章无疑有助于我的理解，所以如果你想要更深入的解释，我也推荐你读一读。</p><p id="9bdf" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">在这篇文章中，我将强调并总结三个关键概念，让你快速运行。</p></div><div class="ab cl ms mt hx mu" role="separator"><span class="mv bw bk mw mx my"/><span class="mv bw bk mw mx my"/><span class="mv bw bk mw mx"/></div><div class="im in io ip iq"><h1 id="4a7d" class="kz la it bd lb lc mz le lf lg na li lj jz nb ka ll kc nc kd ln kf nd kg lp lq bi translated">1.创建视图</h1><p id="d25f" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">在插入视图之前，我们首先要知道如何创建一个视图。Angular支持两种<strong class="lt iu"> </strong>类型的视图，即<em class="ne">宿主视图</em>和<em class="ne">嵌入视图。</em></p><h2 id="6cd0" class="nf la it bd lb ng nh dn lf ni nj dp lj ma nk nl ll me nm nn ln mi no np lp nq bi translated">主机视图</h2><p id="b242" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">这是我们最常用的视图，也可能是我们最熟悉的视图。当Angular创建一个组件时，我们得到一个视图，其中也包含组件的数据。当我们谈论主机视图时，它们本质上是实例化的组件视图。</p><p id="a703" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">要创建一个组件，我们只需将它的选择器包含在另一个组件的模板中，Angular会自动完成剩下的工作。然而，当我们动态地创建视图时，有两个必要的中间步骤。</p><p id="94e1" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">我们需要一个<code class="fe nr ns nt nu b">ComponentFactory</code>，它将用于手动(即动态)创建一个组件。为了得到一个<code class="fe nr ns nt nu b">ComponentFactory</code>，我们需要通过将组件作为参数传入来使用<code class="fe nr ns nt nu b">ComponentFactoryResolver</code>。</p><p id="e9bc" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">假设我们希望在初始化时创建一个动态组件:</p><pre class="kj kk kl km gt nv nu nw nx aw ny bi"><span id="6e96" class="nf la it nu b gy nz oa l ob oc">&lt;-- parentComponent.component.ts --&gt;</span><span id="e185" class="nf la it nu b gy od oa l ob oc">import { ..., ComponentFactoryResolver } from '@angular/core';<br/>import { FirstComponent } from '&lt;path&gt;/firstcomponent.component.ts'</span><span id="1a38" class="nf la it nu b gy od oa l ob oc">...</span><span id="1720" class="nf la it nu b gy od oa l ob oc">export class ParentComponent implements OnInit {</span><span id="4ee5" class="nf la it nu b gy od oa l ob oc">constructor(private resolver: ComponentFactoryResolver) {}<br/>}</span><span id="b77f" class="nf la it nu b gy od oa l ob oc">ngOnInit() {<br/>    const componentFactory = this.resolver.resolveComponentFactory(<br/>       FirstComponent);<br/>    const dynamicallyCreatedComponent = componentFactory.create();<br/>}</span></pre><p id="af58" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated"><strong class="lt iu">重要:</strong>你需要在<code class="fe nr ns nt nu b">app.module.ts</code>文件内<code class="fe nr ns nt nu b">NgModules</code>的<code class="fe nr ns nt nu b">entryComponents</code> <strong class="lt iu"> </strong>中定义组件。在Angular doc的<a class="ae ky" href="https://angular.io/guide/dynamic-component-loader" rel="noopener ugc nofollow" target="_blank">动态组件加载</a>部分，这部分不包括在内，我花了一段时间才弄明白。</p><pre class="kj kk kl km gt nv nu nw nx aw ny bi"><span id="cd2f" class="nf la it nu b gy nz oa l ob oc">&lt;-- app.module.ts --&gt;<br/>...</span><span id="ddf3" class="nf la it nu b gy od oa l ob oc">providers: [],<br/>  bootstrap: [AppComponent],<br/>  entryComponents: [FirstComponent]<br/>});</span></pre><blockquote class="oe of og"><p id="f360" class="lr ls ne lt b lu mn ju lw lx mo jx lz oh mp mc md oi mq mg mh oj mr mk ml mm im bi translated">“入口构件是任何按类型强制进行角度加载的构件(这意味着您没有在模板中引用它)。”— <a class="ae ky" href="https://angular.io/guide/entry-components" rel="noopener ugc nofollow" target="_blank"> Angular.io </a></p></blockquote><h2 id="a99b" class="nf la it bd lb ng nh dn lf ni nj dp lj ma nk nl ll me nm nn ln mi no np lp nq bi translated">嵌入式视图</h2><pre class="kj kk kl km gt nv nu nw nx aw ny bi"><span id="1139" class="nf la it nu b gy nz oa l ob oc">&lt;-- parentComponent.component.html --&gt;<br/>&lt;div&gt;This is rendered&lt;/div&gt;</span><span id="4dad" class="nf la it nu b gy od oa l ob oc">&lt;ng-template #templateName&gt;<br/>    &lt;div&gt; This is not rendered&lt;/div&gt;<br/>&lt;ng-template&gt;</span></pre><p id="f04a" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">一个<code class="fe nr ns nt nu b">TemplateRef</code>是创建DOM元素的蓝图，就像一个类对于它自己的一个实例一样。当你引用一个<code class="fe nr ns nt nu b">ng-template</code>时，你得到一个<code class="fe nr ns nt nu b">TemplateRef</code>。如果你在你的<code class="fe nr ns nt nu b">component.html</code>文件中包含了一个<code class="fe nr ns nt nu b">ng-template</code>，它将不会被渲染，因为你需要初始化视图并在之后嵌入它。在下一节中，我们将讨论如何引用DOM元素。</p><p id="8d6d" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">现在，我们只需要知道我们能够通过选择器名称<code class="fe nr ns nt nu b">#templateName</code>选择<code class="fe nr ns nt nu b">ng-template</code>，并且我们能够创建它的一个实例——这就是我们所说的<em class="ne">嵌入式视图。</em></p><p id="2df7" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">如果你有兴趣，你可以阅读更多关于<a class="ae ky" href="https://stackoverflow.com/questions/40423772/what-is-the-difference-between-a-view-a-host-view-and-an-embedded-view" rel="noopener ugc nofollow" target="_blank">主机和嵌入式视图的区别</a>。</p></div><div class="ab cl ms mt hx mu" role="separator"><span class="mv bw bk mw mx my"/><span class="mv bw bk mw mx my"/><span class="mv bw bk mw mx"/></div><div class="im in io ip iq"><h1 id="7ef0" class="kz la it bd lb lc mz le lf lg na li lj jz nb ka ll kc nc kd ln kf nd kg lp lq bi translated">2.选择DOM元素</h1><p id="acaf" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">如果您想要动态地呈现一个视图，您可以想象有一个元素作为锚点来告诉Angular视图应该插入的位置。如果您有使用jQuery的经验，它应该类似于:</p><pre class="kj kk kl km gt nv nu nw nx aw ny bi"><span id="c22a" class="nf la it nu b gy nz oa l ob oc">&lt;div id="selector&gt;&lt;/div&gt; // HTML</span><span id="0615" class="nf la it nu b gy od oa l ob oc">$('.selector').html('Dynamic Content Here') // jQuery selector</span></pre><p id="2469" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">在Angular中，我们使用装饰器<code class="fe nr ns nt nu b">@ViewChild</code>和<code class="fe nr ns nt nu b">@ViewChildren</code>来搜索元素。它们都提供相似的功能，但是前者只返回一个引用。后者返回一个对元素有多个引用的<code class="fe nr ns nt nu b">QueryList</code>对象。</p><h2 id="91c2" class="nf la it bd lb ng nh dn lf ni nj dp lj ma nk nl ll me nm nn ln mi no np lp nq bi translated">句法</h2><p id="010a" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated"><code class="fe nr ns nt nu b">@ViewChild(selector, [{read: any}], [{static: boolean}])</code></p><p id="75fc" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">这里再解释一下元数据属性:<code class="fe nr ns nt nu b">read</code>和<code class="fe nr ns nt nu b">static</code>都是可选参数，但是我会快速地讨论它们。</p><p id="d802" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">在Angular的文档中，它说<code class="fe nr ns nt nu b">read</code>应该被设置为“true以从被查询的元素中读取不同的标记”然而，更实际的用法是包含您感兴趣的元素的类。</p><p id="ec2a" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">在这篇<a class="ae ky" href="https://stackoverflow.com/questions/37450805/what-is-the-read-parameter-in-viewchild-for" rel="noopener ugc nofollow" target="_blank">堆栈溢出</a>文章中，它说可以有几个实例绑定到元素选择器。例如，对于每个元素，至少有一个<code class="fe nr ns nt nu b">ElementRef</code>和一个<code class="fe nr ns nt nu b">ViewContainerRef</code>。如果这两个类现在听起来很陌生，请不要担心，我稍后会谈到后者。</p><p id="902c" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated"><code class="fe nr ns nt nu b">Static</code>属性更简单。如果您希望查询结果在变更检测发生之前运行，请将其设置为<code class="fe nr ns nt nu b">true</code>。</p><p id="99ed" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">让我们看一个例子，看看我们如何访问元素的<code class="fe nr ns nt nu b">ViewContainerRef</code>。</p><h2 id="11d7" class="nf la it bd lb ng nh dn lf ni nj dp lj ma nk nl ll me nm nn ln mi no np lp nq bi translated">例子</h2><pre class="kj kk kl km gt nv nu nw nx aw ny bi"><span id="3e5a" class="nf la it nu b gy nz oa l ob oc">&lt;-- parentComponent.component.html --&gt;</span><span id="05f0" class="nf la it nu b gy od oa l ob oc">&lt;div&gt;<br/>    &lt;ng-container #viewContainer&gt;&lt;/ng-container&gt;<br/>&lt;/div&gt;<br/></span><span id="a552" class="nf la it nu b gy od oa l ob oc">&lt;-- parentComponent.component.ts --&gt;</span><span id="fffa" class="nf la it nu b gy od oa l ob oc">export class ParentComponent implements OnInit {<br/>  @ViewChild('viewContainer', read: ViewContainerRef) viewContainer: ViewContainerRef;</span><span id="45f7" class="nf la it nu b gy od oa l ob oc">   ...<br/>}</span></pre></div><div class="ab cl ms mt hx mu" role="separator"><span class="mv bw bk mw mx my"/><span class="mv bw bk mw mx my"/><span class="mv bw bk mw mx"/></div><div class="im in io ip iq"><h1 id="50a4" class="kz la it bd lb lc mz le lf lg na li lj jz nb ka ll kc nc kd ln kf nd kg lp lq bi translated">3.附着视图</h1><p id="4965" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">既然我们能够选择一个锚元素，我们需要将视图附加到它上面。<code class="fe nr ns nt nu b">ViewContainerRef</code>表示元素的容器，我们可以在它之后附加视图。</p><h2 id="152b" class="nf la it bd lb ng nh dn lf ni nj dp lj ma nk nl ll me nm nn ln mi no np lp nq bi translated">锚元素</h2><p id="2e62" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">在上面的例子中，我们使用<code class="fe nr ns nt nu b">ng-container</code>作为锚元素。或者，我们也可以使用<code class="fe nr ns nt nu b">ng-template</code>。我怀疑有些人会好奇我们是否可以使用其他元素，例如<code class="fe nr ns nt nu b">div</code>。理论上，我们可以使用任何我们想要的元素。</p><p id="f297" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">然而，需要注意的是Angular并没有在元素的中插入视图<em class="ne">，而是在绑定到<code class="fe nr ns nt nu b">ViewContainer</code>的元素的</em>之后插入<em class="ne">。</em></p><p id="d088" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated"><code class="fe nr ns nt nu b">ng-container</code>和<code class="fe nr ns nt nu b">ng-template</code>实际上并不在DOM中呈现，而是作为Angular知道要查找的注释。因此，使用这些元素允许我们避免在DOM中插入过多的元素，比如不需要的<code class="fe nr ns nt nu b">div</code>。</p><h2 id="1cc5" class="nf la it bd lb ng nh dn lf ni nj dp lj ma nk nl ll me nm nn ln mi no np lp nq bi translated">插入视图</h2><p id="3a50" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">在上面的代码块中，我们已经有了一个名为<code class="fe nr ns nt nu b">viewContainer</code>的实例属性，我们只需注入视图。</p><pre class="kj kk kl km gt nv nu nw nx aw ny bi"><span id="7cf9" class="nf la it nu b gy nz oa l ob oc">&lt;-- parentComponent.component.ts --&gt;</span><span id="efab" class="nf la it nu b gy od oa l ob oc">import { ..., ComponentFactoryResolver } from '@angular/core';<br/>import { FirstComponent } from '.../firstcomponent.component.ts';<br/>import { SecondComponent } from '.../secondcomponent.component.ts';</span><span id="0294" class="nf la it nu b gy od oa l ob oc">...</span><span id="8ad5" class="nf la it nu b gy od oa l ob oc">export class ParentComponent implements OnInit {<br/>  @ViewChild('viewContainer', read: ViewContainerRef) viewContainer: ViewContainerRef;</span><span id="394d" class="nf la it nu b gy od oa l ob oc">constructor(private resolver: ComponentFactoryResolver) {}<br/>}</span><span id="acf1" class="nf la it nu b gy od oa l ob oc">...</span><span id="31a3" class="nf la it nu b gy od oa l ob oc">onTabChange(selectedTab) {<br/>  this.viewContainer.clear(); // clear all views<br/>  if (selectedTab === 'firstComponent') {<br/>    const componentFactory = this.resolver.resolveComponentFactory(<br/>      FirstComponent<br/>    );<br/>    this.viewContainer.createComponent(componentFactory);<br/>  } else if (selectedTab === 'secondComponent') {<br/>      // similar idea here<br/>  }<br/>};</span></pre><p id="ba20" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">之前，我们使用了来自<code class="fe nr ns nt nu b">ComponentFactory</code>对象的<code class="fe nr ns nt nu b">.create()</code>方法，但是<code class="fe nr ns nt nu b">ViewContainerRef</code>有一个方法接受一个<code class="fe nr ns nt nu b">ComponentFactory</code>，通过内部调用它的<code class="fe nr ns nt nu b">create </code>函数创建主机视图，并自动插入视图。</p><h2 id="e99a" class="nf la it bd lb ng nh dn lf ni nj dp lj ma nk nl ll me nm nn ln mi no np lp nq bi translated"><strong class="ak">向动态组件传递数据</strong></h2><p id="b23b" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">现在，我们能够动态创建主机视图。能够做的一件有用的事情是将数据传递给我们的组件。这样，我们就能够用动态数据动态地创建主机视图。</p><p id="9e0b" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">让我们以上面的例子为基础。</p><pre class="kj kk kl km gt nv nu nw nx aw ny bi"><span id="7a70" class="nf la it nu b gy nz oa l ob oc">&lt;-- parentComponent.component.ts --&gt;</span><span id="dd63" class="nf la it nu b gy od oa l ob oc">const componentRef =<br/>    this.viewContainer.createComponent(componentFactory);<br/>(componentRef.instance).dynamicData = { a: 5, b: 3}; // passing data</span><span id="d3a0" class="nf la it nu b gy od oa l ob oc">&lt;-- firstComponent.component.html --&gt;<br/>&lt;div&gt; Dynamic Content: {{ dynamicData.a }} &lt;/div&gt;</span></pre><p id="5145" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated"><code class="fe nr ns nt nu b">createComponent</code>方法返回一个<code class="fe nr ns nt nu b">ComponentRef</code>对象，我们可以用它来访问实例属性并添加一个<code class="fe nr ns nt nu b">dynamicData</code>键。这样，在我们的子组件中，我们可以通过插值简单地引用数据变量名。</p><h2 id="276c" class="nf la it bd lb ng nh dn lf ni nj dp lj ma nk nl ll me nm nn ln mi no np lp nq bi translated"><strong class="ak">创建嵌入式视图</strong></h2><p id="74e8" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">现在我们知道了如何创建主体视图，嵌入视图在概念上几乎是相似的。还记得我们之前谈过的<code class="fe nr ns nt nu b">TemplateRef</code>吗？我们可以用它创建一个嵌入式视图。</p><pre class="kj kk kl km gt nv nu nw nx aw ny bi"><span id="47ba" class="nf la it nu b gy nz oa l ob oc">&lt;-- parentComponent.component.html --&gt;</span><span id="bbf0" class="nf la it nu b gy od oa l ob oc">&lt;div&gt;<br/>    &lt;ng-container #viewContainer&gt;&lt;/ng-container&gt;<br/>&lt;/div&gt;</span><span id="c27f" class="nf la it nu b gy od oa l ob oc">&lt;ng-template #isLoggedInTemplate&gt;<br/>    &lt;div&gt; You are logged in! &lt;/div&gt;<br/>&lt;ng-template&gt;</span><span id="f87f" class="nf la it nu b gy od oa l ob oc">&lt;-- parentComponent.component.ts --&gt;</span><span id="9d6e" class="nf la it nu b gy od oa l ob oc">export class ParentComponent implements OnInit {<br/>  @ViewChild('viewContainer', read: ViewContainerRef) viewContainer: ViewContainerRef;<br/>  @ViewChild('isLoggedInTemplate', read: TemplateRef) template:<br/>TemplateRef&lt;any&gt;;</span><span id="3d2a" class="nf la it nu b gy od oa l ob oc">...</span><span id="998b" class="nf la it nu b gy od oa l ob oc">displayLoginMessage() {<br/>  this.viewContainer.createEmbeddedView(this.template);<br/>};</span></pre><p id="4163" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">我们简单地添加另一个<code class="fe nr ns nt nu b">TemplateRef</code>实例属性，并使用<code class="fe nr ns nt nu b">ViewContainer</code>的方法实例化视图并插入它。</p></div><div class="ab cl ms mt hx mu" role="separator"><span class="mv bw bk mw mx my"/><span class="mv bw bk mw mx my"/><span class="mv bw bk mw mx"/></div><div class="im in io ip iq"><h1 id="634f" class="kz la it bd lb lc mz le lf lg na li lj jz nb ka ll kc nc kd ln kf nd kg lp lq bi translated">最后的话</h1><p id="b915" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">通过理解这三个概念，你应该能够很容易地在Angular中创建动态视图。</p><p id="9fb5" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">在官方指南中，在指令的帮助下，<a class="ae ky" href="https://angular.io/guide/dynamic-component-loader" rel="noopener ugc nofollow" target="_blank">动态组件加载</a>的实现略有不同。我决定多谈一谈如何不使用它，因为它似乎可以省去创建指令的麻烦。尽管如此，最好也看一下官方文件，以了解潜在的机制。</p></div></div>    
</body>
</html>