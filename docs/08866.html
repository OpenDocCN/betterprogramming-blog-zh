<html>
<head>
<title>React 18 Is Here! What Is New?</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">React 18来了！什么是新的？</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/react-18-is-here-what-is-new-e72e1efd57d6?source=collection_archive---------5-----------------------#2021-06-21">https://betterprogramming.pub/react-18-is-here-what-is-new-e72e1efd57d6?source=collection_archive---------5-----------------------#2021-06-21</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="19fc" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">自动批处理、startTransition、SSR改造等等</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/1c889ad61de9c45d3d08c54d72037f23.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*lO2QMyyxHA_puGTn0l9RLg.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">作者截图。</p></figure><p id="f17c" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">React 18将会是一个激动人心的版本。首先，React团队正在尝试一种新的方法。他们邀请了一组专家、开发人员、库作者和教育工作者加入工作组。它最初将是一个小团体。</p><p id="d547" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">我们其余的人能做什么？即使我们不能在这个版本中扮演积极的角色，但我们可以关注他们GitHub讨论组中的所有内容。看到想法和功能是如何形成的是非常令人兴奋的。</p><p id="4fdb" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">该版本将主要关注:</p><ul class=""><li id="5b8e" class="lu lv it la b lb lc le lf lh lw ll lx lp ly lt lz ma mb mc bi translated">一些现成的性能改进</li><li id="bb07" class="lu lv it la b lb md le me lh mf ll mg lp mh lt lz ma mb mc bi translated">新的并发功能</li><li id="794c" class="lu lv it la b lb md le me lh mf ll mg lp mh lt lz ma mb mc bi translated">服务器端呈现区域的改进</li></ul></div><div class="ab cl mi mj hx mk" role="separator"><span class="ml bw bk mm mn mo"/><span class="ml bw bk mm mn mo"/><span class="ml bw bk mm mn"/></div><div class="im in io ip iq"><h1 id="8312" class="mp mq it bd mr ms mt mu mv mw mx my mz jz na ka nb kc nc kd nd kf ne kg nf ng bi translated">发布状态</h1><p id="bfe6" class="pw-post-body-paragraph ky kz it la b lb nh ju ld le ni jx lg lh nj lj lk ll nk ln lo lp nl lr ls lt im bi translated">该版本仍处于早期阶段。React的团队旨在从图书馆作者那里收集尽可能多的反馈。这就是他们发布早期alpha版本的原因。</p><p id="b49e" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">我们可以通过以下方式立即安装:</p><pre class="kj kk kl km gt nm nn no np aw nq bi"><span id="5ffa" class="nr mq it nn b gy ns nt l nu nv">npm install react@alpha</span><span id="72bc" class="nr mq it nn b gy nw nt l nu nv">npm install react-dom@alpha</span></pre><p id="5f23" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">这些alpha版本是使用主回购中最近的提交构建的。当任何特性/bug被合并时，它将在下一个工作日出现在alpha中。这绝不适合生产环境。</p><p id="e019" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">现在让我们来看看新特性。</p></div><div class="ab cl mi mj hx mk" role="separator"><span class="ml bw bk mm mn mo"/><span class="ml bw bk mm mn mo"/><span class="ml bw bk mm mn"/></div><div class="im in io ip iq"><h1 id="3992" class="mp mq it bd mr ms mt mu mv mw mx my mz jz na ka nb kc nc kd nd kf ne kg nf ng bi translated">1.创建根</h1><p id="5675" class="pw-post-body-paragraph ky kz it la b lb nh ju ld le ni jx lg lh nj lj lk ll nk ln lo lp nl lr ls lt im bi translated">React 18将附带两个根API:</p><ul class=""><li id="370e" class="lu lv it la b lb lc le lf lh lw ll lx lp ly lt lz ma mb mc bi translated"><code class="fe nx ny nz nn b">ReactDOM.render</code>:创建一个在“遗留”模式下运行的根目录。根节点将像在React 17中一样工作。</li><li id="d188" class="lu lv it la b lb md le me lh mf ll mg lp mh lt lz ma mb mc bi translated"><code class="fe nx ny nz nn b">ReactDOM.createRoot</code>:它创建了一个运行在React 18中的root，带有一些新的开箱即用的好东西。</li></ul><p id="b689" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">与之前的全有或全无方法不同，这给了你逐步选择React 18的机会。自从上一个版本发布以来，他们一直在努力使升级到新版本变得更加容易。</p><h2 id="a3ec" class="nr mq it bd mr oa ob dn mv oc od dp mz lh oe of nb ll og oh nd lp oi oj nf ok bi translated"><strong class="ak">两者之间有什么变化？</strong></h2><ul class=""><li id="ee4f" class="lu lv it la b lb nh le ni lh ol ll om lp on lt lz ma mb mc bi translated">如果你没有使用新的<code class="fe nx ny nz nn b">createRoot</code> API，你将会错过开箱即用的改进。我们将在以后看到那些是什么。</li><li id="b441" class="lu lv it la b lb md le me lh mf ll mg lp mh lt lz ma mb mc bi translated">移除<code class="fe nx ny nz nn b">hydrate</code>功能以支持配置参数。</li></ul><p id="d5ad" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">之前怎么做补水:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oo op l"/></div></figure><p id="4c0c" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">下一个版本如何补水:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oo op l"/></div></figure><ul class=""><li id="7637" class="lu lv it la b lb lc le lf lh lw ll lx lp ly lt lz ma mb mc bi translated">根的渲染<code class="fe nx ny nz nn b">callback</code>已经被移除。</li></ul><p id="40ff" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">之前:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oo op l"/></div></figure><p id="a98f" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">现在:推荐的方式是在根节点上使用<code class="fe nx ny nz nn b">requestIdleCallback</code>、<code class="fe nx ny nz nn b">setTimeout</code>或者一个<code class="fe nx ny nz nn b">ref callback</code>。</p><p id="8bdc" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">使用<code class="fe nx ny nz nn b">ref callback</code>方法的示例:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oo op l"/></div></figure></div><div class="ab cl mi mj hx mk" role="separator"><span class="ml bw bk mm mn mo"/><span class="ml bw bk mm mn mo"/><span class="ml bw bk mm mn"/></div><div class="im in io ip iq"><h1 id="5815" class="mp mq it bd mr ms mt mu mv mw mx my mz jz na ka nb kc nc kd nd kf ne kg nf ng bi translated">2.自动更新批处理</h1><p id="7cb9" class="pw-post-body-paragraph ky kz it la b lb nh ju ld le ni jx lg lh nj lj lk ll nk ln lo lp nl lr ls lt im bi translated">在这个版本之前，React只对事件处理程序内部发生的更新进行批处理。批处理更新是什么意思？这意味着它将对一个处理函数上发生的所有状态更新进行分组。那么它将只重新呈现组件一次，而不是每次状态改变都呈现一次。</p><p id="4739" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">让我们看一个例子:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oo op l"/></div></figure><p id="ea69" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">注意，<code class="fe nx ny nz nn b">handleClick</code>正在更新<code class="fe nx ny nz nn b">count</code>和<code class="fe nx ny nz nn b">odd</code>状态。React足够聪明，可以将两者组合在一起，只需重新渲染组件一次。您可以在<a class="ae oq" href="https://codesandbox.io/s/spring-water-929i6" rel="noopener ugc nofollow" target="_blank"> CodeSandbox </a>上尝试React团队的原始示例。</p><p id="d855" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">那么这个新版本有什么变化呢？配料机制远非完美。它仅限于批处理事件回调中运行的状态更新。如果事件处理程序在异步函数中包含一些状态更新，这些更新就不会被批处理。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oo op l"/></div></figure><p id="444b" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">现在，通过使用React 18的<code class="fe nx ny nz nn b">createRoot</code> API，这些将被自动批量处理。引擎将足够智能地对这些进行分组，即使它们是异步发生的。</p><p id="92a8" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">如果你想退出那种行为呢？他们为此增加了一个新的API:<code class="fe nx ny nz nn b">flushSync</code>。</p><p id="2b79" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">让我们来看看它的一个使用示例:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oo op l"/></div></figure><p id="33ae" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">上面的代码现在将触发两次重新渲染。预计这不会是一个常见的场景，但是工具就在那里，以防你需要它们。</p><p id="f1c6" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">在这个版本之前，这个问题有一个解决方案。他们加了一个<code class="fe nx ny nz nn b">unstable_batchedUpdated</code>功能。您可以包装状态更改来对它们进行批处理。虽然它变得多余，但在这个版本中还没有被删除。会在不久的将来。</p></div><div class="ab cl mi mj hx mk" role="separator"><span class="ml bw bk mm mn mo"/><span class="ml bw bk mm mn mo"/><span class="ml bw bk mm mn"/></div><div class="im in io ip iq"><h1 id="236f" class="mp mq it bd mr ms mt mu mv mw mx my mz jz na ka nb kc nc kd nd kf ne kg nf ng bi translated">3.开始过渡</h1><p id="478d" class="pw-post-body-paragraph ky kz it la b lb nh ju ld le ni jx lg lh nj lj lk ll nk ln lo lp nl lr ls lt im bi translated">对于React团队来说，应用程序响应一直是一个至关重要的主题。这就是他们一直在开发并发模式特性的原因。在并发模式下，渲染不会阻塞。它是可中断的。这意味着您可以确定哪些更新对您的应用程序至关重要。</p><p id="4ac5" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">用户与之交互的任何东西都应该是有响应的。不然app感觉很迟钝。例如，如果用户在输入搜索中键入一些内容，显示用户键入的内容比显示结果更重要。</p><p id="081b" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated"><code class="fe nx ny nz nn b">startTransition</code> API将允许您将状态更新标记为不太紧急。这将让渲染引擎优先处理更重要的问题。</p><p id="b6ed" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">我们来看一个小例子:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oo op l"/></div></figure><p id="5327" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">如果您想通知某人更新正在进行，该怎么办？这里有一个钩子:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oo op l"/></div></figure><p id="66bb" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">这个新的API是另一个工具，可以让您根据自己的特定需求调整应用程序的性能。</p></div><div class="ab cl mi mj hx mk" role="separator"><span class="ml bw bk mm mn mo"/><span class="ml bw bk mm mn mo"/><span class="ml bw bk mm mn"/></div><div class="im in io ip iq"><h1 id="a1bc" class="mp mq it bd mr ms mt mu mv mw mx my mz jz na ka nb kc nc kd nd kf ne kg nf ng bi translated">4.SSR改进</h1><p id="77b2" class="pw-post-body-paragraph ky kz it la b lb nh ju ld le ni jx lg lh nj lj lk ll nk ln lo lp nl lr ls lt im bi translated">安全部门改革经历了重大改革。为了提供更好的用户体验，内部的很多东西都被改变了。这些改进大部分是自动的，尽管也有一些是选择加入的。</p><h2 id="dcd9" class="nr mq it bd mr oa ob dn mv oc od dp mz lh oe of nb ll og oh nd lp oi oj nf ok bi translated"><strong class="ak">流HTML </strong></h2><p id="9982" class="pw-post-body-paragraph ky kz it la b lb nh ju ld le ni jx lg lh nj lj lk ll nk ln lo lp nl lr ls lt im bi translated">以前，SSR的一个警告是，在流传输HTML之前，您必须等待整个树被加载。现在，您可以流式传输HTML页面的各个部分。</p><p id="2083" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">它是如何工作的？通过将任何组件封装到<code class="fe nx ny nz nn b">&lt;Suspense&gt;</code>中，React不会等待这些组件开始传输HTML。它将显示<code class="fe nx ny nz nn b">fallback</code>,稍后用该成分替换它并水合它。它将如何做到这一点？通过一个<code class="fe nx ny nz nn b">&lt;script&gt;</code>标签发送剩余的HTML代码。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oo op l"/></div></figure><p id="2c3e" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">通过将<code class="fe nx ny nz nn b">&lt;Comments/&gt;</code>组件包装到<code class="fe nx ny nz nn b">&lt;Suspense/&gt;</code>中，我们告诉React它不需要等待注释就可以开始为页面的其余部分传输HTML。</p><p id="621e" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">让我们看一个React团队的例子:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi or"><img src="../Images/52dee1fc1bd3305d9054607aca2a59d6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1200/1*eADl9oOqQ3SOAtdeTlSbzw.gif"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">由这个<a class="ae oq" href="https://codesandbox.io/s/festive-star-9hfqt?file=/src/App.js" rel="noopener ugc nofollow" target="_blank"> CodeSandbox app </a>的作者捕获。</p></figure><p id="e06e" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">请注意，即使<code class="fe nx ny nz nn b">Comments</code>尚未在服务器中获取，内容也是如何流动和水合的。在<code class="fe nx ny nz nn b">&lt;Comments/&gt;</code>组件被传输到客户端之前，会呈现<code class="fe nx ny nz nn b">&lt;Suspense&gt;</code>回退。当它被流化时，它将替换<code class="fe nx ny nz nn b">&lt;Suspense&gt;</code>占位符。</p><p id="0308" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">要选择这种行为，您需要使用<code class="fe nx ny nz nn b">pipeToNodeWritable</code> API:</p><pre class="kj kk kl km gt nm nn no np aw nq bi"><span id="7f80" class="nr mq it nn b gy ns nt l nu nv">// will be moved to react-dom/server<br/>import { pipeToNodeWritable } from 'react-dom/unstable-fizz';</span></pre><p id="2558" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">您必须将SSR呈现代码包装在<code class="fe nx ny nz nn b">pipeToNodeWritable</code>函数中。</p><h2 id="d8a1" class="nr mq it bd mr oa ob dn mv oc od dp mz lh oe of nb ll og oh nd lp oi oj nf ok bi translated"><strong class="ak">选择性水合</strong></h2><p id="a65d" class="pw-post-body-paragraph ky kz it la b lb nh ju ld le ni jx lg lh nj lj lk ll nk ln lo lp nl lr ls lt im bi translated">在以前的版本中，<code class="fe nx ny nz nn b">hydration</code>进程可能会损害用户的页面交互性。在与页面交互之前，您必须等待它完成。</p><p id="cf95" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">通过在<code class="fe nx ny nz nn b">Suspense</code>中包装组件，不再是这种情况。水合作用发生在浏览器可以处理事件的小间隙中。</p><p id="f86c" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">另一种情况是用户可以影响水合作用。假设一个组件已经加载，但是还没有水合，用户点击它。React现在可以优先考虑该组件的水合作用。它将记录这种相互作用，并在组件完成水合作用后重放。当不需要紧急任务时，它将继续与组分的其余部分水合。</p><p id="35c1" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">水合过程大大改善了。它将帮助我们提供更加无缝和互动的体验，同时提高我们应用程序的性能。</p></div><div class="ab cl mi mj hx mk" role="separator"><span class="ml bw bk mm mn mo"/><span class="ml bw bk mm mn mo"/><span class="ml bw bk mm mn"/></div><div class="im in io ip iq"><h1 id="3384" class="mp mq it bd mr ms mt mu mv mw mx my mz jz na ka nb kc nc kd nd kf ne kg nf ng bi translated">最后的想法</h1><p id="0a2b" class="pw-post-body-paragraph ky kz it la b lb nh ju ld le ni jx lg lh nj lj lk ll nk ln lo lp nl lr ls lt im bi translated">React 17是一个“无聊”的版本。它主要致力于使React本身的升级变得更加容易。这个版本将是相反的。它包含了许多功能。请记住，因为是测试版，所以最终版本会有变化。</p><p id="4401" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">在这个版本中，大多数特性似乎都围绕并发运行。这是个好消息，因为这将帮助我们提高应用程序的速度和效率。有了这些新工具，我们将能够更好地调整它们的性能。</p><p id="ad44" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">升级策略很简单:您可以逐步选择加入新功能。React中全有或全无升级的日子已经一去不复返了。这对大型代码库尤其有用。</p></div><div class="ab cl mi mj hx mk" role="separator"><span class="ml bw bk mm mn mo"/><span class="ml bw bk mm mn mo"/><span class="ml bw bk mm mn"/></div><div class="im in io ip iq"><h1 id="fb8b" class="mp mq it bd mr ms mt mu mv mw mx my mz jz na ka nb kc nc kd nd kf ne kg nf ng bi translated">相关文章</h1><div class="os ot gp gr ou ov"><a rel="noopener  ugc nofollow" target="_blank" href="/javascript-es2021-a-look-at-the-new-features-7d5770288648"><div class="ow ab fo"><div class="ox ab oy cl cj oz"><h2 class="bd iu gy z fp pa fr fs pb fu fw is bi translated">JavaScript ES2021:看看新特性</h2><div class="pc l"><h3 class="bd b gy z fp pa fr fs pb fu fw dk translated">新ES12规格概述</h3></div><div class="pd l"><p class="bd b dl z fp pa fr fs pb fu fw dk translated">better编程. pub</p></div></div><div class="pe l"><div class="pf l pg ph pi pe pj ks ov"/></div></div></a></div><div class="os ot gp gr ou ov"><a rel="noopener  ugc nofollow" target="_blank" href="/7-tips-to-write-efficient-and-performant-javascript-code-bccbdb9662ae"><div class="ow ab fo"><div class="ox ab oy cl cj oz"><h2 class="bd iu gy z fp pa fr fs pb fu fw is bi translated">编写高效高性能JavaScript代码的7个技巧</h2><div class="pc l"><h3 class="bd b gy z fp pa fr fs pb fu fw dk translated">提升您的JavaScript应用程序的性能</h3></div><div class="pd l"><p class="bd b dl z fp pa fr fs pb fu fw dk translated">better编程. pub</p></div></div><div class="pe l"><div class="pk l pg ph pi pe pj ks ov"/></div></div></a></div></div></div>    
</body>
</html>