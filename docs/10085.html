<html>
<head>
<title>Python, SQLAlchemy, and Concurrency</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Python、SQLAlchemy和并发性</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/python-sqlalchemy-and-concurrency-c89ec9b5a628?source=collection_archive---------0-----------------------#2021-11-25">https://betterprogramming.pub/python-sqlalchemy-and-concurrency-c89ec9b5a628?source=collection_archive---------0-----------------------#2021-11-25</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="4488" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">Python和SQLAlchemy ORM中现代异步特性的实用概述</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/4a6225b2157312a61170bb001e01e6b3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*J3SVD5rvDH0XV0T_"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">克里斯里德在<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的照片</p></figure><blockquote class="kz la lb"><p id="59d2" class="lc ld le lf b lg lh ju li lj lk jx ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated">考虑到对提高性能的需求以及与其他语言/运行时的竞争，并发编程在Python中越来越受欢迎</p></blockquote><p id="d170" class="pw-post-body-paragraph lc ld it lf b lg lh ju li lj lk jx ll lz ln lo lp ma lr ls lt mb lv lw lx ly im bi translated">Python已经被誉为最通用、最广泛使用的现代编程语言之一。</p><p id="6e48" class="pw-post-body-paragraph lc ld it lf b lg lh ju li lj lk jx ll lz ln lo lp ma lr ls lt mb lv lw lx ly im bi translated">从开发人员到数据科学家，每个人都使用它是有原因的。它易于阅读，用户友好，如果你知道你在用它做什么，你可以在短时间内写很多代码。</p><p id="b135" class="pw-post-body-paragraph lc ld it lf b lg lh ju li lj lk jx ll lz ln lo lp ma lr ls lt mb lv lw lx ly im bi translated">但是Python确实有一些明显的缺点。</p><p id="8ceb" class="pw-post-body-paragraph lc ld it lf b lg lh ju li lj lk jx ll lz ln lo lp ma lr ls lt mb lv lw lx ly im bi translated"><strong class="lf iu"> <em class="le">拿一个来说，就是慢。</em> </strong></p><p id="5734" class="pw-post-body-paragraph lc ld it lf b lg lh ju li lj lk jx ll lz ln lo lp ma lr ls lt mb lv lw lx ly im bi translated">有时候这并不重要。对于大多数应用程序来说，几毫秒的处理时间差异并不重要。</p><p id="967b" class="pw-post-body-paragraph lc ld it lf b lg lh ju li lj lk jx ll lz ln lo lp ma lr ls lt mb lv lw lx ly im bi translated">然而，重要的是能够异步地<a class="ae ky" href="https://developer.mozilla.org/en-US/docs/Learn/JavaScript/Asynchronous/Concepts" rel="noopener ugc nofollow" target="_blank"><strong class="lf iu"><em class="le"/></strong></a><strong class="lf iu"><em class="le"/></strong>处理事件。在现代web编程中，应用程序大部分时间都在等待其他东西的响应。这可能是来自第三方API的HTTP响应、用户输入或数据库查询的结果。</p><p id="b9ac" class="pw-post-body-paragraph lc ld it lf b lg lh ju li lj lk jx ll lz ln lo lp ma lr ls lt mb lv lw lx ly im bi translated">总的来说，人们期望应用程序可以发出许多请求，并保持对用户的响应。</p><p id="b90e" class="pw-post-body-paragraph lc ld it lf b lg lh ju li lj lk jx ll lz ln lo lp ma lr ls lt mb lv lw lx ly im bi translated">由于这个需求，现代web编程中使用的许多语言/运行时在其核心都包含了这种异步范例。</p><p id="99b0" class="pw-post-body-paragraph lc ld it lf b lg lh ju li lj lk jx ll lz ln lo lp ma lr ls lt mb lv lw lx ly im bi translated"><a class="ae ky" href="https://golang.org/doc/" rel="noopener ugc nofollow" target="_blank">比如Golang </a>，默认是异步的。通过对<a class="ae ky" href="https://tour.golang.org/concurrency/1" rel="noopener ugc nofollow" target="_blank"> goroutine </a>和其他语言特性的抽象，Golang可以利用多线程并并行执行操作。</p><p id="94c8" class="pw-post-body-paragraph lc ld it lf b lg lh ju li lj lk jx ll lz ln lo lp ma lr ls lt mb lv lw lx ly im bi translated">不幸的是，Python最初并没有考虑到这种执行模型。</p><p id="5fe5" class="pw-post-body-paragraph lc ld it lf b lg lh ju li lj lk jx ll lz ln lo lp ma lr ls lt mb lv lw lx ly im bi translated">这是完全可以理解的，因为Python是在操作系统有线程概念之前创建的。部分由于这个原因，Python实现了带<strong class="lf iu"> <em class="le">全局解释器锁</em> </strong>(也称为<strong class="lf iu"><em class="le"/></strong>)。</p><p id="142a" class="pw-post-body-paragraph lc ld it lf b lg lh ju li lj lk jx ll lz ln lo lp ma lr ls lt mb lv lw lx ly im bi translated">GIL的最终效果是一个Python进程中一次只能执行一个线程。</p><p id="dcd3" class="pw-post-body-paragraph lc ld it lf b lg lh ju li lj lk jx ll lz ln lo lp ma lr ls lt mb lv lw lx ly im bi translated">虽然这看起来像是一个基本的语言设计缺陷，但它确实有存在的理由。</p><p id="3eb0" class="pw-post-body-paragraph lc ld it lf b lg lh ju li lj lk jx ll lz ln lo lp ma lr ls lt mb lv lw lx ly im bi translated">用Python核心开发人员<a class="ae ky" href="https://www.youtube.com/watch?v=KVKufdTphKs&amp;t=731s" rel="noopener ugc nofollow" target="_blank">拉里·黑斯廷斯</a>的话说:</p><blockquote class="kz la lb"><p id="f074" class="lc ld le lf b lg lh ju li lj lk jx ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated">“我想说，GIL的设计决定是让Python像今天一样流行的原因之一。”— Larry Hastings，PyCon 2015</p></blockquote><p id="6ed9" class="pw-post-body-paragraph lc ld it lf b lg lh ju li lj lk jx ll lz ln lo lp ma lr ls lt mb lv lw lx ly im bi translated">如果您有兴趣了解更多关于GIL以及它为什么对Python的成功至关重要的信息，请查看这篇<a class="ae ky" href="https://realpython.com/python-gil/" rel="noopener ugc nofollow" target="_blank">文章</a>。</p><p id="c54c" class="pw-post-body-paragraph lc ld it lf b lg lh ju li lj lk jx ll lz ln lo lp ma lr ls lt mb lv lw lx ly im bi translated">尽管Python是单线程的，不能并行运行任务(至少在同一个进程中)，它仍然可以利用<a class="ae ky" href="https://en.wikipedia.org/wiki/Concurrency_(computer_science)" rel="noopener ugc nofollow" target="_blank"> <strong class="lf iu"> <em class="le">并发</em> </strong> </a> <strong class="lf iu"> <em class="le">。</em> </strong></p><p id="2d07" class="pw-post-body-paragraph lc ld it lf b lg lh ju li lj lk jx ll lz ln lo lp ma lr ls lt mb lv lw lx ly im bi translated">并发性与并行性非常相似，但有一个重要的区别。</p><p id="75b9" class="pw-post-body-paragraph lc ld it lf b lg lh ju li lj lk jx ll lz ln lo lp ma lr ls lt mb lv lw lx ly im bi translated">它表明任务可以同时运行，但不一定必须同时运行。</p><p id="18dc" class="pw-post-body-paragraph lc ld it lf b lg lh ju li lj lk jx ll lz ln lo lp ma lr ls lt mb lv lw lx ly im bi translated">并行性是并发性，但不是相反。</p><p id="f95c" class="pw-post-body-paragraph lc ld it lf b lg lh ju li lj lk jx ll lz ln lo lp ma lr ls lt mb lv lw lx ly im bi translated">下面可以看到这个并发、非并行执行模型的一个有用的例子。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi mc"><img src="../Images/539dd130ace052623920f30acd3e3dc2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1020/format:webp/1*NMM_GRqa0PiWOCEG_2gtXA.jpeg"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">参考:<a class="ae ky" href="https://books.google.ie/books/about/Introduction_to_Concurrency_in_Programmi.html?id=J5-ckoCgc3IC&amp;redir_esc=y" rel="noopener ugc nofollow" target="_blank">编程语言中的并发介绍</a></p></figure><p id="a48e" class="pw-post-body-paragraph lc ld it lf b lg lh ju li lj lk jx ll lz ln lo lp ma lr ls lt mb lv lw lx ly im bi translated">运行在客户端和服务器端的JavaScript(node . js运行时)都是实现这一点的典型例子。尽管JavaScript是单线程的，但是<a class="ae ky" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/EventLoop" rel="noopener ugc nofollow" target="_blank">事件循环</a>、消息队列/任务队列和web APIs的组合允许它执行非阻塞的异步代码。</p><p id="5c19" class="pw-post-body-paragraph lc ld it lf b lg lh ju li lj lk jx ll lz ln lo lp ma lr ls lt mb lv lw lx ly im bi translated">正如您所期望的，现代版本的Python(3.4+版)可以通过标准库做类似的事情。让我们在下一节中更深入地了解这一点。</p></div><div class="ab cl md me hx mf" role="separator"><span class="mg bw bk mh mi mj"/><span class="mg bw bk mh mi mj"/><span class="mg bw bk mh mi"/></div><div class="im in io ip iq"><h1 id="4192" class="mk ml it bd mm mn mo mp mq mr ms mt mu jz mv ka mw kc mx kd my kf mz kg na nb bi translated">应用Python并发</h1><p id="2f77" class="pw-post-body-paragraph lc ld it lf b lg nc ju li lj nd jx ll lz ne lo lp ma nf ls lt mb ng lw lx ly im bi translated">现代Python中支持并发代码的标准库部分是<a class="ae ky" href="https://docs.python.org/3/library/asyncio.html" rel="noopener ugc nofollow" target="_blank"> asyncio </a>。</p><p id="6cd3" class="pw-post-body-paragraph lc ld it lf b lg lh ju li lj lk jx ll lz ln lo lp ma lr ls lt mb lv lw lx ly im bi translated">当然，这个库不是Python中并发的第一次迭代。<a class="ae ky" href="https://docs.python.org/2.7/library/threading.html" rel="noopener ugc nofollow" target="_blank">线程模块</a>已经存在了一段时间，并且在Python的遗留版本(2.7等)中有提供。).</p><p id="f939" class="pw-post-body-paragraph lc ld it lf b lg lh ju li lj lk jx ll lz ln lo lp ma lr ls lt mb lv lw lx ly im bi translated">为了节省时间，我们将跳过这些旧的概念，只关注asyncio(如果您感兴趣，请观看大卫·比兹利在PyCon 2015 现场编码练习的<a class="ae ky" href="https://www.youtube.com/watch?v=MCs5OvhV9S4" rel="noopener ugc nofollow" target="_blank">视频)。</a></p><p id="15c8" class="pw-post-body-paragraph lc ld it lf b lg lh ju li lj lk jx ll lz ln lo lp ma lr ls lt mb lv lw lx ly im bi translated">我们现在将探讨如何用Python编写并发代码。以下所有代码示例均可在<a class="ae ky" href="https://github.com/nmchenry01/medium-code-examples/tree/main/PythonSQLAlchemyAndConcurrency" rel="noopener ugc nofollow" target="_blank">Github repo</a>获得。</p><p id="1ab1" class="pw-post-body-paragraph lc ld it lf b lg lh ju li lj lk jx ll lz ln lo lp ma lr ls lt mb lv lw lx ly im bi translated">我们要介绍的第一个对象是<a class="ae ky" href="https://docs.python.org/3/library/asyncio-task.html#coroutines-and-tasks" rel="noopener ugc nofollow" target="_blank">协程</a>。</p><p id="776a" class="pw-post-body-paragraph lc ld it lf b lg lh ju li lj lk jx ll lz ln lo lp ma lr ls lt mb lv lw lx ly im bi translated">如果你熟悉现代JavaScript，那么<em class="le">协程</em>很像<em class="le">承诺</em>(或者Scala中的<em class="le">未来</em>，C#中的<em class="le">任务</em>，等等)。就本文的目的而言，我们将它视为一个将在未来某个时候产生结果的对象。</p><p id="5a00" class="pw-post-body-paragraph lc ld it lf b lg lh ju li lj lk jx ll lz ln lo lp ma lr ls lt mb lv lw lx ly im bi translated">顺便提一下，协程实际上是Python中的一个<a class="ae ky" href="https://www.geeksforgeeks.org/coroutine-in-python/" rel="noopener ugc nofollow" target="_blank">专用生成器函数</a>。</p><p id="19fa" class="pw-post-body-paragraph lc ld it lf b lg lh ju li lj lk jx ll lz ln lo lp ma lr ls lt mb lv lw lx ly im bi translated">我们将从简单地创建和打印协程开始:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nh ni l"/></div></figure></div><div class="ab cl md me hx mf" role="separator"><span class="mg bw bk mh mi mj"/><span class="mg bw bk mh mi mj"/><span class="mg bw bk mh mi"/></div><div class="im in io ip iq"><p id="2753" class="pw-post-body-paragraph lc ld it lf b lg lh ju li lj lk jx ll lz ln lo lp ma lr ls lt mb lv lw lx ly im bi translated">如果您运行上面的代码，您会看到您得到了一个协程对象以及它的一些内部属性的打印输出。</p><p id="9959" class="pw-post-body-paragraph lc ld it lf b lg lh ju li lj lk jx ll lz ln lo lp ma lr ls lt mb lv lw lx ly im bi translated">这里的要点是，我们用<strong class="lf iu"> <em class="le"> async </em> </strong>关键字表示的任何函数都将返回一个协程，即使实际上没有发生任何异步。</p><p id="e41d" class="pw-post-body-paragraph lc ld it lf b lg lh ju li lj lk jx ll lz ln lo lp ma lr ls lt mb lv lw lx ly im bi translated">现在让我们尝试模拟一些异步操作:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nh ni l"/></div></figure></div><div class="ab cl md me hx mf" role="separator"><span class="mg bw bk mh mi mj"/><span class="mg bw bk mh mi mj"/><span class="mg bw bk mh mi"/></div><div class="im in io ip iq"><p id="5690" class="pw-post-body-paragraph lc ld it lf b lg lh ju li lj lk jx ll lz ln lo lp ma lr ls lt mb lv lw lx ly im bi translated">同样，我们得到了与之前相同的协程对象。程序还会在3秒钟之前退出，这不是我们所期望的。</p><p id="87b5" class="pw-post-body-paragraph lc ld it lf b lg lh ju li lj lk jx ll lz ln lo lp ma lr ls lt mb lv lw lx ly im bi translated">我们解决这个问题的方法是添加<strong class="lf iu"> <em class="le"> await </em> </strong>关键字:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nh ni l"/></div></figure></div><div class="ab cl md me hx mf" role="separator"><span class="mg bw bk mh mi mj"/><span class="mg bw bk mh mi mj"/><span class="mg bw bk mh mi"/></div><div class="im in io ip iq"><p id="9cde" class="pw-post-body-paragraph lc ld it lf b lg lh ju li lj lk jx ll lz ln lo lp ma lr ls lt mb lv lw lx ly im bi translated">这里正在发生一些新的事情:</p><ul class=""><li id="0840" class="nj nk it lf b lg lh lj lk lz nl ma nm mb nn ly no np nq nr bi translated">我们现在使用asyncio库</li><li id="ec8e" class="nj nk it lf b lg ns lj nt lz nu ma nv mb nw ly no np nq nr bi translated">我们使用<strong class="lf iu"> <em class="le"> await </em> </strong>来等待几个协程的结果(<code class="fe nx ny nz oa b">asyncio.sleep()</code>也返回一个协程)</li><li id="978f" class="nj nk it lf b lg ns lj nt lz nu ma nv mb nw ly no np nq nr bi translated">我们使用<code class="fe nx ny nz oa b">asyncio.run()</code>来运行我们的顶级异步函数。这与运行事件循环接口，以确保我们的程序在所有异步工作完成之前不会退出</li></ul><p id="e53a" class="pw-post-body-paragraph lc ld it lf b lg lh ju li lj lk jx ll lz ln lo lp ma lr ls lt mb lv lw lx ly im bi translated">所以现在我们对Python的异步结构以及如何运行一些基本代码有了一个大致的了解。</p><p id="df21" class="pw-post-body-paragraph lc ld it lf b lg lh ju li lj lk jx ll lz ln lo lp ma lr ls lt mb lv lw lx ly im bi translated">让我们更进一步，尝试进行多个异步操作:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nh ni l"/></div></figure></div><div class="ab cl md me hx mf" role="separator"><span class="mg bw bk mh mi mj"/><span class="mg bw bk mh mi mj"/><span class="mg bw bk mh mi"/></div><div class="im in io ip iq"><p id="4cb1" class="pw-post-body-paragraph lc ld it lf b lg lh ju li lj lk jx ll lz ln lo lp ma lr ls lt mb lv lw lx ly im bi translated">我们最终得到了我们想要的输出。所有三个操作的结果都打印到控制台。</p><p id="257a" class="pw-post-body-paragraph lc ld it lf b lg lh ju li lj lk jx ll lz ln lo lp ma lr ls lt mb lv lw lx ly im bi translated">然而，缺点是整个程序需要大约3秒的时间来运行(就像我们用传统的同步方式编写程序一样)。</p><p id="c6c0" class="pw-post-body-paragraph lc ld it lf b lg lh ju li lj lk jx ll lz ln lo lp ma lr ls lt mb lv lw lx ly im bi translated">我们需要能够<em class="le">调度</em>操作并发运行，然后等待它们返回:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nh ni l"/></div></figure></div><div class="ab cl md me hx mf" role="separator"><span class="mg bw bk mh mi mj"/><span class="mg bw bk mh mi mj"/><span class="mg bw bk mh mi"/></div><div class="im in io ip iq"><p id="1f5b" class="pw-post-body-paragraph lc ld it lf b lg lh ju li lj lk jx ll lz ln lo lp ma lr ls lt mb lv lw lx ly im bi translated">我们得到相同的预期输出，但是整个过程只需要1秒钟。</p><p id="5744" class="pw-post-body-paragraph lc ld it lf b lg lh ju li lj lk jx ll lz ln lo lp ma lr ls lt mb lv lw lx ly im bi translated">这里的要点是Python可以<em class="le">调度</em>操作并发运行(尽管它仍然不能并行处理它们)。</p><p id="724c" class="pw-post-body-paragraph lc ld it lf b lg lh ju li lj lk jx ll lz ln lo lp ma lr ls lt mb lv lw lx ly im bi translated">你会注意到程序运行的时间比一秒多了几千分之一秒。这来自于程序其他部分的开销和事件循环运行的时间等。不管怎样，它仍然比同步版本的性能好得多。</p><p id="56fc" class="pw-post-body-paragraph lc ld it lf b lg lh ju li lj lk jx ll lz ln lo lp ma lr ls lt mb lv lw lx ly im bi translated">正如您所料，asyncio库包含的内容远不止这个简短演示所涵盖的内容。如果感兴趣的话，可以查看一下<a class="ae ky" href="https://docs.python.org/3/library/asyncio.html" rel="noopener ugc nofollow" target="_blank">文档</a>,看看在Python中可以用并发性做的其他很酷的事情。</p></div><div class="ab cl md me hx mf" role="separator"><span class="mg bw bk mh mi mj"/><span class="mg bw bk mh mi mj"/><span class="mg bw bk mh mi"/></div><div class="im in io ip iq"><h1 id="b37b" class="mk ml it bd mm mn mo mp mq mr ms mt mu jz mv ka mw kc mx kd my kf mz kg na nb bi translated">SQLAlchemy的并发性</h1><p id="464f" class="pw-post-body-paragraph lc ld it lf b lg nc ju li lj nd jx ll lz ne lo lp ma nf ls lt mb ng lw lx ly im bi translated">既然我们已经理解了并发性，那么让我们来讨论它与Python最流行的ORM之一<a class="ae ky" href="https://www.sqlalchemy.org/" rel="noopener ugc nofollow" target="_blank"> SQLAlchemy </a>的关系。</p><p id="4c00" class="pw-post-body-paragraph lc ld it lf b lg lh ju li lj lk jx ll lz ln lo lp ma lr ls lt mb lv lw lx ly im bi translated">顺便说一下，原生协程和async/await语法在Python中仍然没有像在其他语言中那样被广泛采用。因此，并非所有第三方库都是asyncio兼容的。</p><p id="25b0" class="pw-post-body-paragraph lc ld it lf b lg lh ju li lj lk jx ll lz ln lo lp ma lr ls lt mb lv lw lx ly im bi translated">SQLAlchemy也不例外，直到2021年初的<a class="ae ky" href="https://pypi.org/project/SQLAlchemy/1.4.0/" rel="noopener ugc nofollow" target="_blank"> 1.4.x版本</a>才成为asyncio兼容的。即将到来的主要<a class="ae ky" href="https://docs.sqlalchemy.org/en/14/changelog/migration_20.html" rel="noopener ugc nofollow" target="_blank"> 2.0版本</a>无疑也将继续扩展asyncio支持。</p><p id="beb7" class="pw-post-body-paragraph lc ld it lf b lg lh ju li lj lk jx ll lz ln lo lp ma lr ls lt mb lv lw lx ly im bi translated">现在，我们将看看这个新功能，并回顾一下这个库的基本示例用法。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nh ni l"/></div></figure></div><div class="ab cl md me hx mf" role="separator"><span class="mg bw bk mh mi mj"/><span class="mg bw bk mh mi mj"/><span class="mg bw bk mh mi"/></div><div class="im in io ip iq"><p id="24ac" class="pw-post-body-paragraph lc ld it lf b lg lh ju li lj lk jx ll lz ln lo lp ma lr ls lt mb lv lw lx ly im bi translated">在上面，我们做了几件事:</p><ul class=""><li id="a307" class="nj nk it lf b lg lh lj lk lz nl ma nm mb nn ly no np nq nr bi translated">通过SQLAlchemy ORM创建一个基本的数据库模式，并创建一个SQLite内存数据库</li><li id="b853" class="nj nk it lf b lg ns lj nt lz nu ma nv mb nw ly no np nq nr bi translated">创建一个我们用来与数据库交互的数据库引擎</li><li id="496e" class="nj nk it lf b lg ns lj nt lz nu ma nv mb nw ly no np nq nr bi translated">添加一些测试数据</li><li id="5b50" class="nj nk it lf b lg ns lj nt lz nu ma nv mb nw ly no np nq nr bi translated">使用<a class="ae ky" href="https://docs.sqlalchemy.org/en/14/orm/session_api.html" rel="noopener ugc nofollow" target="_blank"> SQLAlchemy会话API </a>执行SQL select语句</li></ul><p id="633e" class="pw-post-body-paragraph lc ld it lf b lg lh ju li lj lk jx ll lz ln lo lp ma lr ls lt mb lv lw lx ly im bi translated">如果您以前使用过SQLAlchemy，这应该非常简单。如果没有，查看他们的<a class="ae ky" href="https://docs.sqlalchemy.org/en/14/intro.html" rel="noopener ugc nofollow" target="_blank">文档</a>，因为SQLAlchemy是Python生态系统中一个必不可少的数据库工具。</p><p id="8f1c" class="pw-post-body-paragraph lc ld it lf b lg lh ju li lj lk jx ll lz ln lo lp ma lr ls lt mb lv lw lx ly im bi translated">上面执行的所有操作都是同步的。现在让我们看看我们需要做些什么来使它们异步。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nh ni l"/></div></figure></div><div class="ab cl md me hx mf" role="separator"><span class="mg bw bk mh mi mj"/><span class="mg bw bk mh mi mj"/><span class="mg bw bk mh mi"/></div><div class="im in io ip iq"><p id="baa0" class="pw-post-body-paragraph lc ld it lf b lg lh ju li lj lk jx ll lz ln lo lp ma lr ls lt mb lv lw lx ly im bi translated">上面首先要注意的是<a class="ae ky" href="https://docs.sqlalchemy.org/en/14/orm/extensions/asyncio.html#sqlalchemy.ext.asyncio.create_async_engine" rel="noopener ugc nofollow" target="_blank"> create_async_engine() </a>函数的使用。这允许我们创建一个支持asyncio的数据库引擎。</p><p id="e9c8" class="pw-post-body-paragraph lc ld it lf b lg lh ju li lj lk jx ll lz ln lo lp ma lr ls lt mb lv lw lx ly im bi translated">我们还使用了<a class="ae ky" href="https://github.com/omnilib/aiosqlite" rel="noopener ugc nofollow" target="_blank"> aiosqlite </a>库，并将其包含在传递给create_async_engine()的第一个参数中。这是因为我们需要一个asyncio兼容的数据库驱动程序来创建/使用SQLAlchemy中的异步引擎。</p><p id="7600" class="pw-post-body-paragraph lc ld it lf b lg lh ju li lj lk jx ll lz ln lo lp ma lr ls lt mb lv lw lx ly im bi translated">从这里开始，语法相对类似于我们之前看到的同步版本。</p><p id="929c" class="pw-post-body-paragraph lc ld it lf b lg lh ju li lj lk jx ll lz ln lo lp ma lr ls lt mb lv lw lx ly im bi translated">主要的例外是，我们需要<strong class="lf iu"> <em class="le">等待</em> </strong>通过会话API对数据库的任何异步调用(包括数据库提交),我们用前面讨论的<code class="fe nx ny nz oa b">asyncio.run()</code>方法调用我们的主函数。</p><p id="e76b" class="pw-post-body-paragraph lc ld it lf b lg lh ju li lj lk jx ll lz ln lo lp ma lr ls lt mb lv lw lx ly im bi translated">尽管这个例子相对简单，但它非常强大，因为它打开了一个围绕Python中数据库交互的并行优化的世界。</p></div><div class="ab cl md me hx mf" role="separator"><span class="mg bw bk mh mi mj"/><span class="mg bw bk mh mi mj"/><span class="mg bw bk mh mi"/></div><div class="im in io ip iq"><h1 id="ca38" class="mk ml it bd mm mn mo mp mq mr ms mt mu jz mv ka mw kc mx kd my kf mz kg na nb bi translated">结束语和后续步骤</h1><p id="c9e5" class="pw-post-body-paragraph lc ld it lf b lg nc ju li lj nd jx ll lz ne lo lp ma nf ls lt mb ng lw lx ly im bi translated">虽然并发是Python开发人员工具箱中的一个有价值的工具，但需要谨慎使用。</p><p id="8756" class="pw-post-body-paragraph lc ld it lf b lg lh ju li lj lk jx ll lz ln lo lp ma lr ls lt mb lv lw lx ly im bi translated">也就是说，异步代码并不总是比同步代码快。在某些情况下，它实际上可以相同或更慢。</p><p id="a503" class="pw-post-body-paragraph lc ld it lf b lg lh ju li lj lk jx ll lz ln lo lp ma lr ls lt mb lv lw lx ly im bi translated">通常，您编写的代码会受到应用程序无法控制的外部因素的限制。这可能包括数据库操作、第三方服务的处理时间或任何外部瓶颈。这就是为什么在尝试实施优化时，必须对系统性能进行基准测试并收集数据。</p><p id="856f" class="pw-post-body-paragraph lc ld it lf b lg lh ju li lj lk jx ll lz ln lo lp ma lr ls lt mb lv lw lx ly im bi translated">此外，并发性通常会导致应用程序复杂性的增加。</p><p id="8a19" class="pw-post-body-paragraph lc ld it lf b lg lh ju li lj lk jx ll lz ln lo lp ma lr ls lt mb lv lw lx ly im bi translated">任何有经验的开发人员都知道，管理复杂性是编写好的、可维护的代码的重要部分。有时，并发带来的复杂性增加是不值得的。</p><p id="2393" class="pw-post-body-paragraph lc ld it lf b lg lh ju li lj lk jx ll lz ln lo lp ma lr ls lt mb lv lw lx ly im bi translated">记住所有这些，开始写代码做你需要它做的事情。如果需要，并发可以是一个很好的优化工具。你能做的最好的事情是进行实验，然后迭代结果。</p><p id="3dbd" class="pw-post-body-paragraph lc ld it lf b lg lh ju li lj lk jx ll lz ln lo lp ma lr ls lt mb lv lw lx ly im bi translated">希望这篇文章提供了丰富的信息，并简化了Python和SQLAlchemy中相对复杂的并发性主题。如果您想尝试上面提供的任何代码示例，请查看这个repo 。</p><p id="1a6f" class="pw-post-body-paragraph lc ld it lf b lg lh ju li lj lk jx ll lz ln lo lp ma lr ls lt mb lv lw lx ly im bi translated">一如既往，我很乐意听到任何关于Python/SQLAlchemy/异步编程的想法和反馈。</p><p id="3dea" class="pw-post-body-paragraph lc ld it lf b lg lh ju li lj lk jx ll lz ln lo lp ma lr ls lt mb lv lw lx ly im bi translated">下次见，感谢阅读。</p></div></div>    
</body>
</html>