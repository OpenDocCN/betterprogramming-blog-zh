<html>
<head>
<title>Config Driven Reactive Programming in Ruby</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Ruby中配置驱动的反应式编程</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/config-driven-reactive-programming-in-ruby-676863f50881?source=collection_archive---------5-----------------------#2022-06-30">https://betterprogramming.pub/config-driven-reactive-programming-in-ruby-676863f50881?source=collection_archive---------5-----------------------#2022-06-30</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="d232" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">初学者指南</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/4097a7d24800ff8ec5a59f36a02f0631.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*WN1x_TzUhZs-KZF7"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">梅勒妮·德泽尔在<a class="ae kv" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的照片</p></figure><p id="8294" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">最近，我正在检查一个基于Ruby on Rails的遗留应用程序，我想知道是否有什么方法可以修改某些工作流来提高性能和可配置性。尽管我所遵循的方法在现有的Ruby gems中已经可用，但我发现以可配置的方式编写它是令人兴奋的。</p><blockquote class="ls lt lu"><p id="000b" class="kw kx lv ky b kz la jr lb lc ld ju le lw lg lh li lx lk ll lm ly lo lp lq lr ij bi translated">问题陈述:订单管理系统有一个订单模型，一个订单实例可以附加一个状态。我们不使用任何状态机来调节订单状态的变化，因此我想开发我自己的可定制的状态机。</p></blockquote></div><div class="ab cl lz ma hu mb" role="separator"><span class="mc bw bk md me mf"/><span class="mc bw bk md me mf"/><span class="mc bw bk md me"/></div><div class="ij ik il im in"><p id="1892" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">方法<strong class="ky ir"> : </strong>我将利用Ruby中的observer模式来构建我的类。当对象之间存在一对多关系时，使用观察者模式，例如，如果一个对象被修改，它的依赖对象将被自动通知。观察者模式属于行为模式类别。</p></div><div class="ab cl lz ma hu mb" role="separator"><span class="mc bw bk md me mf"/><span class="mc bw bk md me mf"/><span class="mc bw bk md me"/></div><div class="ij ik il im in"><p id="8aba" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">最初，我设置了一个散列常数，将发布者映射到订阅者。为了简单起见，我把它放在一个ruby文件中。在生产中，这可以存储在集中的配置管理器或数据库中，这样就可以配置这些值，并且可以实时看到变化。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mg mh l"/></div></figure><p id="8d2a" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">接下来，我展示了一个<code class="fe mi mj mk ml b">DeliveryService</code>，这是调用我们的发布者服务的服务。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mg mh l"/></div></figure><p id="3463" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><code class="fe mi mj mk ml b">OrderStateService</code>是最重要的类，它充当我们的发布者。我们需要Ruby的observer模块，在第8行，我们通过类名- &gt;过滤了<code class="fe mi mj mk ml b">OBSERVER_CONFIG</code>，这将返回为<code class="fe mi mj mk ml b">OrderStateService</code>发布者注册的所有订阅者。</p><p id="4924" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在第9行中，我们遍历每个订阅者，并将他们注册为<code class="fe mi mj mk ml b">OrderStateService</code>发布者的观察者。只有当观察者实现了更新方法时，才会执行此操作。<a class="ae kv" href="https://ruby-doc.org/stdlib-2.5.3/libdoc/observer/rdoc/Observable.html" rel="noopener ugc nofollow" target="_blank">这是因为文档中指定通过update方法监听。</a></p><p id="5829" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在第17行中，我们表示已经进行了更改，在第18行中，事件被传递给我们所有的订阅者。我们还通过使用Ruby的多线程功能来异步运行它。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mg mh l"/></div></figure><p id="df7a" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">作为订阅者的<code class="fe mi mj mk ml b">NotificationService</code>实现了一个更新方法，当在<code class="fe mi mj mk ml b">OrderStateService</code>中注册了一个变更事件时，它将执行任何操作。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mg mh l"/></div></figure><p id="cee8" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">如果需要创建一个新的订户，我们只需要用一个更新方法创建这个类，并在我们的<code class="fe mi mj mk ml b">OBSERVER_MAPPING</code>配置中注册这个订户。</p></div><div class="ab cl lz ma hu mb" role="separator"><span class="mc bw bk md me mf"/><span class="mc bw bk md me mf"/><span class="mc bw bk md me"/></div><div class="ij ik il im in"><p id="9d09" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这只是一个原型，问题陈述的解决方案可以进一步改进，例如订单状态转换这样的事件可以让几个订阅者异步执行多个操作。由于这完全是配置驱动的，管理员可以在运行时轻松地添加/删除订户，这有助于隔离错误、性能监控等。</p><h2 id="0108" class="mm mn iq bd mo mp mq dn mr ms mt dp mu lf mv mw mx lj my mz na ln nb nc nd ne bi translated">这种方法的优点</h2><ol class=""><li id="c49d" class="nf ng iq ky b kz nh lc ni lf nj lj nk ln nl lr nm nn no np bi translated">开/关原则。您可以引入新的订阅者类，而不必更改发布者的代码(如果有发布者接口，反之亦然)。</li><li id="987e" class="nf ng iq ky b kz nq lc nr lf ns lj nt ln nu lr nm nn no np bi translated">您可以在运行时建立对象之间的关系。</li><li id="4e0d" class="nf ng iq ky b kz nq lc nr lf ns lj nt ln nu lr nm nn no np bi translated">您可以轻松地添加或删除订阅者，而无需进行任何代码更改或重新部署。</li></ol><h2 id="41e6" class="mm mn iq bd mo mp mq dn mr ms mt dp mu lf mv mw mx lj my mz na ln nb nc nd ne bi translated">这种方法的缺点</h2><ol class=""><li id="9312" class="nf ng iq ky b kz nh lc ni lf nj lj nk ln nl lr nm nn no np bi translated">以随机顺序通知订户。</li><li id="882d" class="nf ng iq ky b kz nq lc nr lf ns lj nt ln nu lr nm nn no np bi translated">如果没有设置适当的日志记录机制，可能很难调试。</li><li id="ba43" class="nf ng iq ky b kz nq lc nr lf ns lj nt ln nu lr nm nn no np bi translated">代码完全依赖于配置。应该建立单独的验证和安全机制，以确保配置不会被滥用。</li></ol><h2 id="91d0" class="mm mn iq bd mo mp mq dn mr ms mt dp mu lf mv mw mx lj my mz na ln nb nc nd ne bi translated">参考</h2><ol class=""><li id="8c72" class="nf ng iq ky b kz nh lc ni lf nj lj nk ln nl lr nm nn no np bi translated">Ruby的observable模块—<a class="ae kv" href="https://ruby-doc.org/stdlib-2.5.3/libdoc/observer/rdoc/Observable.html" rel="noopener ugc nofollow" target="_blank">https://ruby-doc . org/stdlib-2 . 5 . 3/lib doc/observer/rdoc/observable . html</a></li><li id="141b" class="nf ng iq ky b kz nq lc nr lf ns lj nt ln nu lr nm nn no np bi translated">观察者设计模式—<a class="ae kv" href="https://refactoring.guru/design-patterns/observer" rel="noopener ugc nofollow" target="_blank">https://refactoring.guru/design-patterns/observer</a></li><li id="a5f2" class="nf ng iq ky b kz nq lc nr lf ns lj nt ln nu lr nm nn no np bi translated">Ruby中的多线程技术—<a class="ae kv" href="https://www.rubyguides.com/2015/07/ruby-threads/" rel="noopener ugc nofollow" target="_blank">https://www.rubyguides.com/2015/07/ruby-threads/</a></li></ol></div></div>    
</body>
</html>