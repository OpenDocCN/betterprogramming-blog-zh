<html>
<head>
<title>SwiftUI and Combine: Better Together</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">SwiftUI和Combine:一起更好</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/swiftui-plus-combine-equals-love-791ad444a082?source=collection_archive---------3-----------------------#2019-09-19">https://betterprogramming.pub/swiftui-plus-combine-equals-love-791ad444a082?source=collection_archive---------3-----------------------#2019-09-19</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><h2 id="7af0" class="ir is it bd b dl iu iv iw ix iy iz dk ja translated" aria-label="kicker paragraph">功能反应式编程</h2><div class=""/><div class=""><h2 id="d858" class="pw-subtitle-paragraph jz jc it bd b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq dk translated">为什么SwiftUI和Combine将帮助您构建更好的应用</h2></div><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi kr"><img src="../Images/895eba1495c5a5aba3030bd8f9345949.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*3Km9YqzjpLzrgesK"/></div></div><p class="ld le gj gh gi lf lg bd b be z dk translated">由<a class="ae lh" href="https://unsplash.com/@hannahbusing?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">汉娜·布斯</a>在<a class="ae lh" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>拍摄的照片</p></figure><p id="b8cf" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">WWDC 2019上最大的宣布之一是swift UI——它的声明式方法使构建ui变得轻而易举，很容易看出人们为什么对此如此兴奋。然而，隐藏的瑰宝是Combine框架，它并没有得到我认为它应该得到的那样多的宣传。</p><blockquote class="me"><p id="e53c" class="mf mg it bd mh mi mj mk ml mm mn md dk translated">苹果公司已经认可了函数式反应式编程，很快它将不再是只有少数开发团队使用的技术。</p></blockquote><p id="b88c" class="pw-post-body-paragraph li lj it lk b ll mo kd ln lo mp kg lq lr mq lt lu lv mr lx ly lz ms mb mc md im bi translated">在本文中，我们将进一步了解如何使用SwiftUI并结合在一起，构建更好的应用程序，并在此过程中获得更多乐趣。</p><p id="c78a" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">准备好了吗？我们走吧！</p><h1 id="26e9" class="mt mu it bd mv mw mx my mz na nb nc nd ki ne kj nf kl ng km nh ko ni kp nj nk bi translated">你将会学到什么</h1><ul class=""><li id="f19c" class="nl nm it lk b ll nn lo no lr np lv nq lz nr md ns nt nu nv bi translated">什么是Combine框架，以及如何将其与SwiftUI集成</li><li id="21ab" class="nl nm it lk b ll nw lo nx lr ny lv nz lz oa md ns nt nu nv bi translated">什么是发布者、订阅者和操作者，以及如何使用它们</li><li id="19ac" class="nl nm it lk b ll nw lo nx lr ny lv nz lz oa md ns nt nu nv bi translated">如何组织你的代码</li></ul><p id="6f95" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">为了帮助我们推理SwiftUI和Combine，我们将使用一个简单的注册屏幕，让用户输入用户名和密码在应用程序中创建一个新帐户。在后面的文章中，我们将添加一个登录屏幕来演示使用Combine的一些额外好处。</p><p id="ec38" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">注册屏幕的数据模型非常简单:</p><ul class=""><li id="5931" class="nl nm it lk b ll lm lo lp lr ob lv oc lz od md ns nt nu nv bi translated">用户需要输入他们想要的用户名</li><li id="83a2" class="nl nm it lk b ll nw lo nx lr ny lv nz lz oa md ns nt nu nv bi translated">他们还需要选择一个密码</li></ul><p id="809b" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">用户名和密码的要求非常简单:</p><ul class=""><li id="b63c" class="nl nm it lk b ll lm lo lp lr ob lv oc lz od md ns nt nu nv bi translated">用户名必须包含至少3个字符</li><li id="b13b" class="nl nm it lk b ll nw lo nx lr ny lv nz lz oa md ns nt nu nv bi translated">密码必须非空且足够强</li><li id="38ca" class="nl nm it lk b ll nw lo nx lr ny lv nz lz oa md ns nt nu nv bi translated">此外，为了确保用户没有意外输入错误，他们需要再次输入他们的密码，并且这两个密码需要匹配</li></ul><p id="a81c" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">让我们用代码写下来！</p><p id="542f" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">我已经决定使用MVVM架构——这将产生一个干净的代码库，并使向应用程序添加新功能变得更加容易。首先，让我们定义<em class="oe"> ViewModel </em>，它有几个接受用户输入(比如用户名和密码)的属性，并且暂时有一个属性公开我们不久将实现的任何业务逻辑的结果。</p><figure class="ks kt ku kv gt kw"><div class="bz fp l di"><div class="of og l"/></div></figure><p id="84ff" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">对于注册屏幕，我们使用一个带有几个<code class="fe oh oi oj ok b">Section</code>的<code class="fe oh oi oj ok b">Form</code>作为各种输入字段，这给了我们一个干净的外观和感觉。它完成了工作，但看起来并不令人兴奋。在下一集，我们将回顾一下SwiftUI和Combine是如何在不修改底层业务逻辑的情况下改变用户界面的。</p><figure class="ks kt ku kv gt kw"><div class="bz fp l di"><div class="of og l"/></div></figure><p id="378a" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">注意我们如何使用SwiftUI绑定来访问视图模型的属性。<em class="oe">注册</em>按钮被绑定到视图模型的<code class="fe oh oi oj ok b">isValid</code>输出属性。由于这个默认为<code class="fe oh oi oj ok b">false</code>，这个按钮最初是禁用的，这正是我们想要的——毕竟，用户不应该能够创建一个用户名和密码为空的帐户！</p><p id="a968" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">这是目前为止用户界面的外观:</p><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi ol"><img src="../Images/0a5ff535165648324b08641ff484893c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*YKpUgF8IYcDBk_ywR8MGsQ.png"/></div></div></figure><h1 id="8151" class="mt mu it bd mv mw mx my mz na nb nc nd ki ne kj nf kl ng km nh ko ni kp nj nk bi translated">联合收割机简介</h1><p id="f887" class="pw-post-body-paragraph li lj it lk b ll nn kd ln lo no kg lq lr om lt lu lv on lx ly lz oo mb mc md im bi translated">在为我们的注册表单实现验证逻辑之前，让我们花一些时间来理解Combine框架是如何工作的。</p><p id="e4cd" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">根据苹果<a class="ae lh" href="https://developer.apple.com/documentation/combine" rel="noopener ugc nofollow" target="_blank">文档</a>:</p><blockquote class="op oq or"><p id="0fe4" class="li lj oe lk b ll lm kd ln lo lp kg lq os ls lt lu ot lw lx ly ou ma mb mc md im bi translated"><em class="it">Combine框架提供了一个声明性的Swift API，用于随时处理值。这些值可以表示多种异步事件。Combine声明发布者公开可以随时间变化的值，并声明订阅者从发布者接收这些值。(</em> <a class="ae lh" href="https://developer.apple.com/documentation/combine" rel="noopener ugc nofollow" target="_blank"> <em class="it">来源</em> </a> <em class="it"> ) </em></p></blockquote><p id="bf9b" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">让我们仔细看看这里的几个关键概念，以理解这意味着什么以及它如何帮助我们。</p><h2 id="d131" class="ov mu it bd mv ow ox dn mz oy oz dp nd lr pa pb nf lv pc pd nh lz pe pf nj iz bi translated">出版商</h2><p id="2ab8" class="pw-post-body-paragraph li lj it lk b ll nn kd ln lo no kg lq lr om lt lu lv on lx ly lz oo mb mc md im bi translated">发布者将值发送给一个或多个订阅者。它们符合<code class="fe oh oi oj ok b">Publisher</code>协议，并声明输出类型和它们产生的任何错误:</p><figure class="ks kt ku kv gt kw"><div class="bz fp l di"><div class="of og l"/></div></figure><p id="adbe" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">发布者可以随时发送任意数量的值，也可以因出错而失败。关联类型<code class="fe oh oi oj ok b">Output</code>定义了发布者可以发送哪种类型的值，而关联类型<code class="fe oh oi oj ok b">Failure</code>定义了它可能失败的错误类型。发布者可以通过指定<code class="fe oh oi oj ok b">Never</code>关联类型来声明它永远不会失败。</p><h2 id="9250" class="ov mu it bd mv ow ox dn mz oy oz dp nd lr pa pb nf lv pc pd nh lz pe pf nj iz bi translated">订阅者</h2><p id="2971" class="pw-post-body-paragraph li lj it lk b ll nn kd ln lo no kg lq lr om lt lu lv on lx ly lz oo mb mc md im bi translated">另一方面，订阅者订阅一个特定的发布者实例，并接收一个值流，直到订阅被取消。</p><p id="1d59" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">它们符合<code class="fe oh oi oj ok b">Subscriber</code>协议。为了订阅发布者，订阅者关联的<code class="fe oh oi oj ok b">Input</code>和<code class="fe oh oi oj ok b">Failure</code>类型必须符合发布者关联的<code class="fe oh oi oj ok b">Output</code>和<code class="fe oh oi oj ok b">Failure</code>类型。</p><figure class="ks kt ku kv gt kw"><div class="bz fp l di"><div class="of og l"/></div></figure><h2 id="549a" class="ov mu it bd mv ow ox dn mz oy oz dp nd lr pa pb nf lv pc pd nh lz pe pf nj iz bi translated">经营者</h2><p id="8956" class="pw-post-body-paragraph li lj it lk b ll nn kd ln lo no kg lq lr om lt lu lv on lx ly lz oo mb mc md im bi translated">发布者和订阅者是SwiftUI在UI和底层模型之间双向同步的支柱。我想你会同意，保持你的UI和模型同步从来没有比SwiftUI更容易，这都要归功于Combine框架的这一部分。</p><p id="53c4" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">然而，运营商是联合公司的超级力量。它们是对一个<code class="fe oh oi oj ok b">Publisher</code>进行操作、执行一些计算并产生另一个<code class="fe oh oi oj ok b">Publisher</code>作为回报的方法。</p><ul class=""><li id="9487" class="nl nm it lk b ll lm lo lp lr ob lv oc lz od md ns nt nu nv bi translated">例如，您可以使用<code class="fe oh oi oj ok b">filter</code>操作符来忽略基于特定条件的值</li><li id="634a" class="nl nm it lk b ll nw lo nx lr ny lv nz lz oa md ns nt nu nv bi translated">或者，如果您需要执行一个昂贵的任务(比如通过网络获取信息)，您可以使用<code class="fe oh oi oj ok b">debounce</code>操作符等待，直到用户停止输入</li><li id="f08a" class="nl nm it lk b ll nw lo nx lr ny lv nz lz oa md ns nt nu nv bi translated"><code class="fe oh oi oj ok b">map</code>操作符允许您将某种类型的输入值转换成不同类型的输出值</li></ul><h1 id="46c9" class="mt mu it bd mv mw mx my mz na nb nc nd ki ne kj nf kl ng km nh ko ni kp nj nk bi translated">验证用户名</h1><p id="d485" class="pw-post-body-paragraph li lj it lk b ll nn kd ln lo no kg lq lr om lt lu lv on lx ly lz oo mb mc md im bi translated">记住这一点，让我们实现一个简单的验证来确保用户输入的名称至少有三个字符。</p><p id="8520" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">我们的视图模型上的所有属性都用<code class="fe oh oi oj ok b">@Published</code>属性包装器包装。这意味着每个属性都有自己的发布者，我们可以订阅。</p><p id="1716" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">为了表明用户名是否有效，我们使用<code class="fe oh oi oj ok b">map</code>操作符将用户的输入从<code class="fe oh oi oj ok b">String</code>转换为<code class="fe oh oi oj ok b">Bool</code>:</p><figure class="ks kt ku kv gt kw"><div class="bz fp l di"><div class="of og l"/></div></figure><p id="bab7" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">然后这个转换的结果被<code class="fe oh oi oj ok b">assign</code>订阅者使用，顾名思义，它将接收到的值分配给视图模型的<code class="fe oh oi oj ok b">valid</code>输出属性。</p><p id="3a25" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">由于我们之前在<code class="fe oh oi oj ok b">ContentView.swift</code>中配置的绑定，每当这个属性改变时，SwiftUI将自动更新UI。我们稍后会看到为什么这种方法有点问题，但是现在，它工作得很好。</p><p id="febb" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">你可能想知道<code class="fe oh oi oj ok b">debounce</code>和<code class="fe oh oi oj ok b">removeDuplicate</code>操作符有什么奇特的功能？嗯，这些是Combine成为将ui连接到底层业务逻辑的有用工具的部分原因。在所有的用户界面中，我们必须处理这样一个事实:用户输入的速度可能比我们获取他们所请求的信息的速度还要快。例如，当键入他们的用户名时，没有必要检查用户名对于用户键入的每个字母是否有效或可用。只有当他们停止输入(或停顿片刻)时，才需要执行这项检查。</p><p id="dd46" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated"><code class="fe oh oi oj ok b">debounce</code>操作符让我们指定希望等待事件交付的暂停，例如当用户停止输入时。</p><p id="eca0" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">类似地，<code class="fe oh oi oj ok b">removeDuplicates</code>操作符只在事件不同于任何先前的事件时才会发布事件。举个例子，如果用户先输入<code class="fe oh oi oj ok b">john</code>，然后输入<code class="fe oh oi oj ok b">joe</code>，再输入<code class="fe oh oi oj ok b">john</code>，我们只会收到一次<code class="fe oh oi oj ok b">john</code>。这有助于我们的UI更有效地工作。</p><p id="b685" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">这个调用链的结果是一个<code class="fe oh oi oj ok b">Cancellable</code>，如果需要的话，我们可以用它来取消处理(对于长时间运行的链很有用)。我们将把这个(以及我们稍后将创建的所有其他内容)存储到一个<code class="fe oh oi oj ok b">Set&lt;AnyCancellable&gt;</code>中，这样我们就可以在<code class="fe oh oi oj ok b">deinit</code>时进行清理。</p><h1 id="02bf" class="mt mu it bd mv mw mx my mz na nb nc nd ki ne kj nf kl ng km nh ko ni kp nj nk bi translated">验证密码</h1><p id="98b7" class="pw-post-body-paragraph li lj it lk b ll nn kd ln lo no kg lq lr om lt lu lv on lx ly lz oo mb mc md im bi translated">现在让我们换个话题，看看如何执行多阶段验证逻辑。这是必需的，因为我们的表单上的密码字段需要满足多个要求:它们不能为空，它们必须匹配，并且(最重要的)选择的密码必须足够强。除了将输入值转换成一个<code class="fe oh oi oj ok b">Bool</code>来指示密码是否满足我们的要求，我们还希望通过返回一个适当的警告消息来为用户提供一些指导。</p><p id="c04d" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">让我们一步一步来，从实现验证用户输入的密码的管道开始。</p><figure class="ks kt ku kv gt kw"><div class="bz fp l di"><div class="of og l"/></div></figure><p id="b8b1" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">检查密码是否为空非常简单，您会注意到这种方法非常类似于我们的用户名验证实现。然而，我们没有将转换的结果直接分配给<code class="fe oh oi oj ok b">isValid</code>输出属性，而是返回了一个<code class="fe oh oi oj ok b">AnyPublisher&lt;Bool, Never&gt;</code>。这是为了以后在订阅最终结果(有效或无效)之前，我们可以将多个发布者组合成一个多阶段链。</p><p id="cd3d" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">为了验证两个独立的属性是否包含相同的字符串，我们使用了<code class="fe oh oi oj ok b">CombineLatest</code>操作符。请记住，每当用户输入一个字符时，绑定到相应的<code class="fe oh oi oj ok b">SecureField</code>的属性就会触发，我们希望比较每个字段的<em class="oe">最新的</em>值。让我们去做吧。</p><figure class="ks kt ku kv gt kw"><div class="bz fp l di"><div class="of og l"/></div></figure><p id="360f" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">为了计算密码强度，我们使用了<a class="ae lh" href="https://github.com/jasonnam/Navajo-Swift" rel="noopener ugc nofollow" target="_blank">纳瓦霍语Swift </a>，这是<a class="ae lh" href="https://www.twitter.com/mattt" rel="noopener ugc nofollow" target="_blank"> @mattt </a>优秀的<a class="ae lh" href="https://github.com/mattt/Navajo" rel="noopener ugc nofollow" target="_blank">纳瓦霍语</a>库(2)的Swift端口。，并通过链接另一个发布者(<code class="fe oh oi oj ok b">isPasswordStrongEnoughPublisher</code>)将结果枚举转换为<code class="fe oh oi oj ok b">Bool</code>。这是我们第一次订阅我们自己的出版商，并且很好地展示了我们如何结合多个出版商来产生所需的输出。</p><figure class="ks kt ku kv gt kw"><div class="bz fp l di"><div class="of og l"/></div></figure><p id="054d" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">如果你想知道为什么我们需要在每个链的末尾调用<code class="fe oh oi oj ok b">eraseToAnyPublisher()</code>:这执行了一些类型擦除，确保我们不会以一些疯狂的嵌套返回类型结束。</p><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div class="gh gi pg"><img src="../Images/29690f452ff98c1ec136cb0b1b7e7bbe.png" data-original-src="https://miro.medium.com/v2/resize:fit:1200/format:webp/1*UJCHOEyluVtwSqJsnagb4A.png"/></div></figure><p id="d6ca" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">太好了——我们现在知道了很多关于用户输入的密码，让我们把它归结为我们真正想知道的一件事:<em class="oe">这是一个有效的密码吗</em>？</p><p id="4da1" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">您可能已经猜到，我们将需要使用<code class="fe oh oi oj ok b">CombineLatest</code>操作符，但是这次我们有三个参数，我们将使用<code class="fe oh oi oj ok b">CombineLatest3</code>，它有三个输入参数。</p><figure class="ks kt ku kv gt kw"><div class="bz fp l di"><div class="of og l"/></div></figure><p id="7894" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">我们将三个布尔值映射到一个枚举的主要原因是，我们希望能够根据验证的结果产生一个合适的警告消息。告诉用户他们的密码不好并没有多大帮助，是吗？如果我们告诉他们为什么无效会好得多。</p><h1 id="c90b" class="mt mu it bd mv mw mx my mz na nb nc nd ki ne kj nf kl ng km nh ko ni kp nj nk bi translated">把所有的放在一起</h1><p id="cd37" class="pw-post-body-paragraph li lj it lk b ll nn kd ln lo no kg lq lr om lt lu lv on lx ly lz oo mb mc md im bi translated">为了计算验证的最终结果，我们需要将用户名验证的结果与密码验证的结果结合起来。然而，在我们这样做之前，我们需要重构用户名验证，以便它也返回一个我们包含在验证链中的发布者。</p><figure class="ks kt ku kv gt kw"><div class="bz fp l di"><div class="of og l"/></div></figure><p id="9e33" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">这样，我们就可以实现表单验证的最后一个阶段了:</p><figure class="ks kt ku kv gt kw"><div class="bz fp l di"><div class="of og l"/></div></figure><p id="4412" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">到目前为止，您应该对此相当熟悉了。</p><h1 id="f81a" class="mt mu it bd mv mw mx my mz na nb nc nd ki ne kj nf kl ng km nh ko ni kp nj nk bi translated">更新用户界面</h1><p id="bf93" class="pw-post-body-paragraph li lj it lk b ll nn kd ln lo no kg lq lr om lt lu lv on lx ly lz oo mb mc md im bi translated">如果不将它连接到UI，这些都不会非常有用。为了驱动<em class="oe">注册</em>按钮的状态，我们需要更新视图模型上的<code class="fe oh oi oj ok b">isValid</code>输出属性。</p><p id="3563" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">为此，我们只需订阅<code class="fe oh oi oj ok b">isFormValidPublisher</code>并将它发布的值赋给<code class="fe oh oi oj ok b">isValid</code>属性:</p><figure class="ks kt ku kv gt kw"><div class="bz fp l di"><div class="of og l"/></div></figure><p id="35aa" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">由于这段代码与UI交互，所以它需要在UI线程上运行。我们可以通过调用<code class="fe oh oi oj ok b">receive(on: RunLoop.main)</code>告诉SwiftUI在UI线程上执行这段代码。</p><p id="5942" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">最后，让我们将警告消息输出属性绑定到UI，以帮助指导用户填写注册表单。</p><p id="64a3" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">首先，我们订阅各自的发布者来了解什么时候<code class="fe oh oi oj ok b">username</code> vs. <code class="fe oh oi oj ok b">password</code>属性无效。同样，我们需要确保这发生在UI线程上，所以我们将调用<code class="fe oh oi oj ok b">receive(on:)</code>并传递主运行循环。</p><figure class="ks kt ku kv gt kw"><div class="bz fp l di"><div class="of og l"/></div></figure><p id="c450" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">最后，我们需要将输出属性<code class="fe oh oi oj ok b">usernameMessage</code>和<code class="fe oh oi oj ok b">passwordMessage</code>绑定到UI。页脚是显示错误信息的一个方便的地方，我们可以通过将它们涂成红色来突出它们:</p><figure class="ks kt ku kv gt kw"><div class="bz fp l di"><div class="of og l"/></div></figure><p id="0ba9" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">这是我们努力工作的成果:</p><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi ph"><img src="../Images/8c0042d4b481ee9323e423d1cbb1aa6b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*k_uN7xKIm9t_2butrxvdiQ.gif"/></div></div><p class="ld le gj gh gi lf lg bd b be z dk translated">运行中的演示应用</p></figure><h1 id="d9c6" class="mt mu it bd mv mw mx my mz na nb nc nd ki ne kj nf kl ng km nh ko ni kp nj nk bi translated">结论</h1><p id="557a" class="pw-post-body-paragraph li lj it lk b ll nn kd ln lo no kg lq lr om lt lu lv on lx ly lz oo mb mc md im bi translated">用SwiftUI构建UI轻而易举。苹果在细节上煞费苦心，为我们提供了比以往任何时候都更加高效的ui构建工具。最重要的是，SwiftUI遵循苹果的<a class="ae lh" href="https://developer.apple.com/design/human-interface-guidelines/" rel="noopener ugc nofollow" target="_blank">人机界面指南</a>，自动适应黑暗模式，并具有内置的可访问性。所有这些都有助于在更短的时间内构建更好、更具包容性的应用——有什么不喜欢的呢？</p><p id="cc51" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">使用Combine会产生一个更干净、更模块化的代码，它(我们将在下一集看到)更易维护、更易扩展。</p><p id="60cd" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">当然，像每个新的范例一样，有一个学习曲线，需要一些时间来掌握函数式反应式编程。但我确信这是值得努力的。通过发布SwiftUI和Combine，苹果已经认可了函数式反应式编程，很快它将不再是只有少数开发团队使用的技术。</p><p id="8de3" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">我们会看到越来越多的学习资源帮助人们入门。此外(在Xcode的最新测试版中，这是一个有点棘手的问题)，随着时间的推移，工具会变得更好，帮助开发人员提高工作效率。</p><p id="17f8" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">现在是开始使用SwiftUI和Combine的绝佳时机——尝试在您的下一个项目中使用它们，以取得领先！</p><h1 id="2e8a" class="mt mu it bd mv mw mx my mz na nb nc nd ki ne kj nf kl ng km nh ko ni kp nj nk bi translated">资源</h1><div class="pi pj gp gr pk pl"><a href="https://github.com/peterfriese/SwiftUI-Combine" rel="noopener  ugc nofollow" target="_blank"><div class="pm ab fo"><div class="pn ab po cl cj pp"><h2 class="bd jd gy z fp pq fr fs pr fu fw jc bi translated">peterfriese/SwiftUI-Combine</h2><div class="ps l"><h3 class="bd b gy z fp pq fr fs pr fu fw dk translated">SwiftUI &amp; Combine入门探索文档“查看演示报告Bug请求”功能以获取本地副本…</h3></div><div class="pt l"><p class="bd b dl z fp pq fr fs pr fu fw dk translated">github.com</p></div></div><div class="pu l"><div class="pv l pw px py pu pz lb pl"/></div></div></a></div><div class="pi pj gp gr pk pl"><a href="https://developer.apple.com/videos/play/wwdc2019/722/" rel="noopener  ugc nofollow" target="_blank"><div class="pm ab fo"><div class="pn ab po cl cj pp"><h2 class="bd jd gy z fp pq fr fs pr fu fw jc bi translated">介绍联合收割机-WWDC 2019-视频-苹果开发者</h2><div class="ps l"><h3 class="bd b gy z fp pq fr fs pr fu fw dk translated">Combine是一个统一的声明性框架，用于随时间处理值。了解它如何简化异步代码…</h3></div><div class="pt l"><p class="bd b dl z fp pq fr fs pr fu fw dk translated">developer.apple.com</p></div></div><div class="pu l"><div class="qa l pw px py pu pz lb pl"/></div></div></a></div><div class="pi pj gp gr pk pl"><a href="https://developer.apple.com/videos/play/wwdc2019/721/" rel="noopener  ugc nofollow" target="_blank"><div class="pm ab fo"><div class="pn ab po cl cj pp"><h2 class="bd jd gy z fp pq fr fs pr fu fw jc bi translated">结合实践— WWDC 2019 —视频—苹果开发者</h2><div class="ps l"><h3 class="bd b gy z fp pq fr fs pr fu fw dk translated">扩展您对Combine的了解，Combine是Apple新的统一声明式框架，用于处理随时间变化的值。学习…</h3></div><div class="pt l"><p class="bd b dl z fp pq fr fs pr fu fw dk translated">developer.apple.com</p></div></div><div class="pu l"><div class="qb l pw px py pu pz lb pl"/></div></div></a></div><div class="pi pj gp gr pk pl"><a href="https://rotato.xyz/" rel="noopener  ugc nofollow" target="_blank"><div class="pm ab fo"><div class="pn ab po cl cj pp"><h2 class="bd jd gy z fp pq fr fs pr fu fw jc bi translated">旋转-3D模型，拖放-应用程序设计的动画3D模型</h2><div class="ps l"><h3 class="bd b gy z fp pq fr fs pr fu fw dk translated">Rotato是一款适用于Mac的应用程序，可以让您在一个…</h3></div><div class="pt l"><p class="bd b dl z fp pq fr fs pr fu fw dk translated">旋转xyz</p></div></div><div class="pu l"><div class="qc l pw px py pu pz lb pl"/></div></div></a></div></div></div>    
</body>
</html>