<html>
<head>
<title>Try Mithril.js: A Modern JavaScript Frontend Framework</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">试试Mithril.js:一个现代的JavaScript前端框架</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/mithril-js-try-it-in-2022-you-can-start-right-here-5e87a601e700?source=collection_archive---------5-----------------------#2021-12-30">https://betterprogramming.pub/mithril-js-try-it-in-2022-you-can-start-right-here-5e87a601e700?source=collection_archive---------5-----------------------#2021-12-30</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="a40e" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">通过构建CRUD应用程序，在2022年开始使用Mithril.js</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/8d70e88560323edf8eecab2fda8a00a4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Sm_wau8Ff1eq05Y51bYI7g.jpeg"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">新年伊始</p></figure><p id="a820" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">这个世界上有很多前端的JavaScript框架，任何一个都不能掉以轻心。但是有一个您可能还没有尝试过，但是您应该尝试一下:Mithril.js。</p><p id="bcfa" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">我在这里不打算谈论Mithril.js为什么如此伟大。相反，我将向您展示如何开始。</p><p id="4df9" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">在本文中，我们将构建一个简单的应用程序，显示来自<a class="ae lr" href="https://jsonplaceholder.typicode.com/posts" rel="noopener ugc nofollow" target="_blank">https://jsonplaceholder.typicode.com/posts</a>的帖子列表，并通过6个简单的步骤提供CRUD操作:</p><ol class=""><li id="77df" class="ls lt iq kx b ky kz lb lc le lu li lv lm lw lq lx ly lz ma bi translated">初始化项目。</li><li id="bd88" class="ls lt iq kx b ky mb lb mc le md li me lm mf lq lx ly lz ma bi translated">设置应用程序组件。</li><li id="1d9c" class="ls lt iq kx b ky mb lb mc le md li me lm mf lq lx ly lz ma bi translated">设置页面之间的传送方式。</li><li id="b4ed" class="ls lt iq kx b ky mb lb mc le md li me lm mf lq lx ly lz ma bi translated">实现列表。</li><li id="fd2a" class="ls lt iq kx b ky mb lb mc le md li me lm mf lq lx ly lz ma bi translated">实施创建/更新表单。</li><li id="84cf" class="ls lt iq kx b ky mb lb mc le md li me lm mf lq lx ly lz ma bi translated">添加删除按钮。</li></ol><p id="31fb" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">如果你想看最终结果，你可以在<a class="ae lr" href="https://github.com/tmj-code/mithril-simple-demo-with-posts" rel="noopener ugc nofollow" target="_blank"> GitHub </a>或<a class="ae lr" href="https://codepen.io/tmj-code/pen/XWeZdmw" rel="noopener ugc nofollow" target="_blank"> CodePen </a>上找到。在这里，我还添加了一些本文中没有提到的样式(只是为了证明我不是设计师)。</p><h1 id="c7b6" class="mg mh iq bd mi mj mk ml mm mn mo mp mq jw mr jx ms jz mt ka mu kc mv kd mw mx bi translated">1.初始化项目</h1><p id="3099" class="pw-post-body-paragraph kv kw iq kx b ky my jr la lb mz ju ld le na lg lh li nb lk ll lm nc lo lp lq ij bi translated">虽然你可以在公共CDN 上通过引用<a class="ae lr" href="https://unpkg.com/mithril@latest/mithril.min.js" rel="noopener ugc nofollow" target="_blank">核心Mithril.js文件轻松构建，但是我们将使用一个bundler，特别是</a><a class="ae lr" href="https://vitejs.dev" rel="noopener ugc nofollow" target="_blank"> Vite.js </a>。我们还将使用<a class="ae lr" href="https://www.typescriptlang.org/" rel="noopener ugc nofollow" target="_blank"> TypeScript </a>，尽管用JavaScript也同样容易。</p><p id="b26b" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">首先，我们创建基本的应用程序并安装依赖项。我们将这个项目命名为<code class="fe nd ne nf ng b">mithril-simple-demo-with-posts</code>，并使用Vite模板<code class="fe nd ne nf ng b">vanilla-ts</code> <em class="nh"> </em>(或者<code class="fe nd ne nf ng b">vanilla-js</code>，如果你是用普通的JavaScript做的话):</p><pre class="kg kh ki kj gt ni ng nj nk aw nl bi"><span id="430a" class="nm mh iq ng b gy nn no l np nq">npm init vite@latest mithril-simple-demo-with-posts — — template vanilla-ts<br/>cd m-demo<br/>npm install<br/>npm install mithril — save<br/>npm install <a class="ae lr" href="http://twitter.com/types/mithril" rel="noopener ugc nofollow" target="_blank">@types/mithril</a> — save-dev</span></pre><p id="fbdf" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">如果你愿意，你也可以用<code class="fe nd ne nf ng b">yarn</code> <em class="nh"> </em>或<code class="fe nd ne nf ng b">pnpm</code> <em class="nh"> </em>来做这件事。</p><h1 id="9f8e" class="mg mh iq bd mi mj mk ml mm mn mo mp mq jw mr jx ms jz mt ka mu kc mv kd mw mx bi translated">2.设置应用程序组件</h1><p id="86ef" class="pw-post-body-paragraph kv kw iq kx b ky my jr la lb mz ju ld le na lg lh li nb lk ll lm nc lo lp lq ij bi translated">现在我们创建应用程序组件。它将呈现我们应用程序的根元素(<code class="fe nd ne nf ng b">&lt;div class="app"&gt;...&lt;/div&gt;</code>)，并将是我们应用程序中所有其他组件的容器。将<code class="fe nd ne nf ng b">src &gt; main.ts</code>的内容替换为:</p><pre class="kg kh ki kj gt ni ng nj nk aw nl bi"><span id="c18c" class="nm mh iq ng b gy nn no l np nq">import './style.css';<br/>import m from 'mithril';</span><span id="2589" class="nm mh iq ng b gy nr no l np nq">function App(): m.Component {<br/>  return {<br/>    view: () =&gt; m('div.app',<br/>      m('header', 'Mithril Demo'),<br/>      m('main', '[some content]'),<br/>      m('footer', 'Mithril is simple yet powerful')<br/>    )<br/>  };<br/>}</span><span id="f5e8" class="nm mh iq ng b gy nr no l np nq">m.mount(document.body, App);</span></pre><p id="c3dc" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">这里发生了什么？</p><ul class=""><li id="cf34" class="ls lt iq kx b ky kz lb lc le lu li lv lm lw lq ns ly lz ma bi translated">我们从<code class="fe nd ne nf ng b">node_modules</code>导入Mithril.js，我们称导入为<code class="fe nd ne nf ng b">m</code>。这是一个附加了几个属性的函数。</li><li id="913a" class="ls lt iq kx b ky mb lb mc le md li me lm mf lq ns ly lz ma bi translated">我们定义了一个函数<code class="fe nd ne nf ng b">App</code>，它返回一个Mithril组件。一个Mithril组件是任何具有返回某些东西的<em class="nh">视图</em>方法的对象。由app函数返回的组件我们此后将称为App组件。</li><li id="4e30" class="ls lt iq kx b ky mb lb mc le md li me lm mf lq ns ly lz ma bi translated">view方法调用<code class="fe nd ne nf ng b">m</code>作为一个函数，看起来像CSS选择器(<code class="fe nd ne nf ng b"><em class="nh">div.app</em></code>)作为第一个参数。这将被渲染为<code class="fe nd ne nf ng b">&lt;div class="app"&gt;&lt;/div&gt;</code>。对<code class="fe nd ne nf ng b">m</code>的多次调用被作为参数添加到第一次调用中，这些调用将被呈现为嵌套元素。</li><li id="5828" class="ls lt iq kx b ky mb lb mc le md li me lm mf lq ns ly lz ma bi translated">最后，我们告诉Mithril呈现App函数返回的任何内容，并将其放入<code class="fe nd ne nf ng b">document.body</code>元素中。</li></ul><p id="97e6" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">现在，通过在控制台中编写<code class="fe nd ne nf ng b">npm run dev</code>来运行Vite，然后导航到该站点。你会在一个带有类app的<code class="fe nd ne nf ng b">div</code>中看到文本<code class="fe nd ne nf ng b">‘[some content]’</code>。</p><p id="e4b2" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">只是为了清理，打开文件<code class="fe nd ne nf ng b">index.html</code>，删除id为<code class="fe nd ne nf ng b">app</code> <em class="nh">的div我们不需要它。</em></p><h1 id="70f6" class="mg mh iq bd mi mj mk ml mm mn mo mp mq jw mr jx ms jz mt ka mu kc mv kd mw mx bi translated">3.设置页面之间的传送方式</h1><p id="56d9" class="pw-post-body-paragraph kv kw iq kx b ky my jr la lb mz ju ld le na lg lh li nb lk ll lm nc lo lp lq ij bi translated">我们首先将这三个函数添加到<code class="fe nd ne nf ng b">src &gt; main.ts</code>来开始路由:</p><pre class="kg kh ki kj gt ni ng nj nk aw nl bi"><span id="b324" class="nm mh iq ng b gy nn no l np nq">function PostList(): m.Component {<br/> return {<br/>  view: () =&gt; 'Post list'<br/> };<br/>}</span><span id="696b" class="nm mh iq ng b gy nr no l np nq">function PostForm(): m.Component {<br/> return {<br/>  view: () =&gt; 'Post form'<br/> };<br/>}</span><span id="7261" class="nm mh iq ng b gy nr no l np nq">function setupRouting(root: Element): void {<br/> m.route.prefix = '';<br/> <br/> m.route(root, '/', {<br/>  '/': PostList, // list of posts<br/>  '/posts': PostForm, // form to create a post<br/>  '/posts/:id': PostForm // form to update a post<br/> });<br/>}</span></pre><p id="e5e0" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">前两个是组件的函数，就像App函数一样。现在他们渲染一些虚拟文本。</p><p id="66e7" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated"><code class="fe nd ne nf ng b">setupRouting</code>功能更有趣。下面是它的作用:</p><ul class=""><li id="4a9e" class="ls lt iq kx b ky kz lb lc le lu li lv lm lw lq ns ly lz ma bi translated">首先，它从DOM中获取一个HTML元素作为输入。一会儿会用到这个。</li><li id="9198" class="ls lt iq kx b ky mb lb mc le md li me lm mf lq ns ly lz ma bi translated">通过将<code class="fe nd ne nf ng b">m.route.prefix</code>设置为空字符串，我们定义了如何从浏览器URL解析路由。省略它，Mithril将——像其他前端框架一样——使用hashbang ( <code class="fe nd ne nf ng b">#!</code>)。这将为我们提供类似<a class="ae lr" href="http://localhost:3000/#!/posts/1" rel="noopener ugc nofollow" target="_blank"> <em class="nh">的URL http://localhost:3000/#！/posts/1</em>T23】。通过将它设置为空字符串，我们得到了</a><a class="ae lr" href="http://localhost:3000/posts/1" rel="noopener ugc nofollow" target="_blank"><em class="nh">http://localhost:3000/posts/1</em></a>。这两种方法都有合理的理由，但是这里我们将使用空字符串。</li><li id="1b95" class="ls lt iq kx b ky mb lb mc le md li me lm mf lq ns ly lz ma bi translated">我们用三个参数调用<code class="fe nd ne nf ng b">m.route(...)</code>。第一个是HTML元素，它将充当<em class="nh">路由容器</em>——所有路由的内容都将显示在这个元素中。第二个参数是在浏览器导航到没有定义路由的URL时使用的备用路由。第三个参数是一个将路由(URL路径)映射到组件函数的对象。</li><li id="8d85" class="ls lt iq kx b ky mb lb mc le md li me lm mf lq ns ly lz ma bi translated">最后看路线<code class="fe nd ne nf ng b">/posts/:id</code>。这个路由将URL的一部分映射到变量<em class="nh"> id </em>。我们可以在组件中检查路由变量，并根据我们发现采取行动。</li></ul><p id="1e4e" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">我们需要从某个地方调用<code class="fe nd ne nf ng b">setupRouting</code>，为它提供一个HTML元素。在<code class="fe nd ne nf ng b">App</code>功能中，将<code class="fe nd ne nf ng b">m('main', …)</code>行更改如下:</p><pre class="kg kh ki kj gt ni ng nj nk aw nl bi"><span id="8d0d" class="nm mh iq ng b gy nn no l np nq">m('main', { <br/>    oncreate: (vnode: m.VnodeDOM) =&gt; setupRouting(vnode.dom) <br/>})</span></pre><p id="b3c3" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">当<code class="fe nd ne nf ng b">m</code>的第二个参数是非组件对象时，它用于配置由第一个参数创建的元素。在这种情况下，我们正在挂接一个Mithril的生命周期挂钩:<code class="fe nd ne nf ng b">oncreate</code>。当Mithril在DOM中创建了元素并公开了一个附加了DOM元素的虚拟节点(元素的内部表示)时，这个钩子被调用。我们将DOM元素交给<code class="fe nd ne nf ng b">setupRouting</code>。</p><p id="9415" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">现在转到浏览器，输入<a class="ae lr" href="http://localhost:3000" rel="noopener ugc nofollow" target="_blank"> http://localhost:3000 </a>以查看<code class="fe nd ne nf ng b">main</code>元素中的“帖子列表”文本，输入<a class="ae lr" href="http://localhost:3000/posts" rel="noopener ugc nofollow" target="_blank">http://localhost:3000/posts</a>(或<a class="ae lr" href="http://localhost:3000/posts/abc" rel="noopener ugc nofollow" target="_blank">http://localhost:3000/posts/ABC</a>)以查看文本“帖子表单”。</p><h1 id="5e4b" class="mg mh iq bd mi mj mk ml mm mn mo mp mq jw mr jx ms jz mt ka mu kc mv kd mw mx bi translated">4.实现一个列表</h1><p id="8d60" class="pw-post-body-paragraph kv kw iq kx b ky my jr la lb mz ju ld le na lg lh li nb lk ll lm nc lo lp lq ij bi translated">我们现在要实现<code class="fe nd ne nf ng b">PostList</code>组件。添加以下接口(为了TypeScript的方便)，并更新<code class="fe nd ne nf ng b">PostList</code>函数:</p><pre class="kg kh ki kj gt ni ng nj nk aw nl bi"><span id="62d2" class="nm mh iq ng b gy nn no l np nq">interface IPost {<br/>  serId: number;<br/>  id: number;<br/>  title: string;<br/>  body: string;<br/>}</span><span id="7751" class="nm mh iq ng b gy nr no l np nq">function PostList(): m.Component {<br/>  let posts: IPost[] = [<br/>  { userId: 1, id: 1, title: 'Dummy post 1', body: 'dummy post 1' },<br/>  { userId: 1, id: 2, title: 'Dummy post 2', body: 'dummy post 2' }<br/> ];</span><span id="5c7a" class="nm mh iq ng b gy nr no l np nq">  return {<br/>    view: () =&gt; m('section.post-list',<br/>      m('ul',<br/>        posts.map(post =&gt; <br/>          m('li',<br/>            m(m.route.Link, { <br/>              href: `/posts/${post.id}`<br/>            }, post.title)<br/>          )<br/>        )<br/>      ),<br/>      m(m.route.Link, { <br/>        href: '/posts', className: 'button' <br/>      }, 'Add new post')<br/>    )<br/>  };<br/>}</span></pre><p id="11ca" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">这里发生了什么？</p><ul class=""><li id="b0a8" class="ls lt iq kx b ky kz lb lc le lu li lv lm lw lq ns ly lz ma bi translated">在视图方法中，我们创建一个带有项目符号列表的部分(<em class="nh"> ul </em>)。请注意，我们还在该部分设置了一个CSS类。</li><li id="d705" class="ls lt iq kx b ky mb lb mc le md li me lm mf lq ns ly lz ma bi translated">我们使用JavaScript <code class="fe nd ne nf ng b">Array.map(...)</code>函数迭代文章来生成列表项；对于每个帖子，我们返回一个列表项(<code class="fe nd ne nf ng b">m('li')</code>)。</li><li id="df2d" class="ls lt iq kx b ky mb lb mc le md li me lm mf lq ns ly lz ma bi translated">在列表项中，我们正在创建一个特殊的元素— <code class="fe nd ne nf ng b">m.route.Link</code>。这实际上只是一个link ( <em class="nh"> a/anchor </em>)元素，具有特殊的点击处理，确保页面在被点击时不会重新加载，而是改变路径。除了“防止重新加载”处理，这创建了一个正常的锚元素。</li><li id="2109" class="ls lt iq kx b ky mb lb mc le md li me lm mf lq ns ly lz ma bi translated">作为第二个参数，我们提供了一个对象。这一次，它既不附加到生命周期挂钩(如<code class="fe nd ne nf ng b">oncreate</code>)也不附加到DOM事件(如<code class="fe nd ne nf ng b">onclick</code>)。相反，它包含一个属性值(<code class="fe nd ne nf ng b">href</code>)，由Mithril分配给元素。</li><li id="7d3b" class="ls lt iq kx b ky mb lb mc le md li me lm mf lq ns ly lz ma bi translated">我们还添加了一个创建新帖子的链接。这个链接我们给了类<code class="fe nd ne nf ng b">button</code>——但是因为我们使用了<code class="fe nd ne nf ng b">m(m.route.Link)</code>，我们不能简单地使用<code class="fe nd ne nf ng b">m('a.button')</code>符号；相反，我们将其设置为第二个参数对象中的一个属性。设置类的两种方法产生相同的结果。</li></ul><p id="cb13" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">现在在浏览器中查看，你会看到一个帖子列表，带有有效的链接。</p><p id="7689" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">接下来，返回到<code class="fe nd ne nf ng b">PostList</code>函数来加载一些真实数据:</p><pre class="kg kh ki kj gt ni ng nj nk aw nl bi"><span id="e571" class="nm mh iq ng b gy nn no l np nq">function PostList(): m.Component {<br/>  let posts: IPost[] = [];<br/> <br/>  m.request&lt;IPost[]&gt;({<br/>    method: 'GET',<br/>    url: '<a class="ae lr" href="https://jsonplaceholder.typicode.com/posts'" rel="noopener ugc nofollow" target="_blank">https://jsonplaceholder.typicode.com/posts'</a><br/>  }).then(data =&gt; posts = data);<br/> <br/>  return ...<br/>}</span></pre><p id="29d3" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">所以:</p><ul class=""><li id="63f4" class="ls lt iq kx b ky kz lb lc le lu li lv lm lw lq ns ly lz ma bi translated">我们从posts数组中删除了虚拟数据，因为我们现在将获得真实数据。</li><li id="fa94" class="ls lt iq kx b ky mb lb mc le md li me lm mf lq ns ly lz ma bi translated">我们用一个定义了HTTP方法和URL的options对象调用<em class="nh"> m.request </em>。m.request返回一个带有数据的承诺。</li><li id="b2e7" class="ls lt iq kx b ky mb lb mc le md li me lm mf lq ns ly lz ma bi translated">当使用TypeScript时，我们给<code class="fe nd ne nf ng b">m.request&lt;IPost[]&gt;</code>添加了一个类型参数，这样我们就可以推断出承诺中的数据类型。</li></ul><p id="caed" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">再次在浏览器中查找。您现在有一个帖子列表。神奇！</p><h1 id="1fee" class="mg mh iq bd mi mj mk ml mm mn mo mp mq jw mr jx ms jz mt ka mu kc mv kd mw mx bi translated">5.实施创建/更新表单</h1><p id="bbd0" class="pw-post-body-paragraph kv kw iq kx b ky my jr la lb mz ju ld le na lg lh li nb lk ll lm nc lo lp lq ij bi translated">我们将更新<code class="fe nd ne nf ng b">PostForm</code> <em class="nh"> </em>函数，并添加一个函数来保存帖子:</p><pre class="kg kh ki kj gt ni ng nj nk aw nl bi"><span id="e0f8" class="nm mh iq ng b gy nn no l np nq">function savePost(post: IPost): void {<br/>  const isCreate = post.id === -1;<br/>  m.request({<br/>    method: isCreate ? 'POST' : 'PUT',<br/>    url: '<a class="ae lr" href="https://jsonplaceholder.typicode.com/posts'" rel="noopener ugc nofollow" target="_blank">https://jsonplaceholder.typicode.com/posts'</a> + <br/>      isCreate ? '' : `/${post.id}`,<br/>    body: post<br/>  });<br/>}</span><span id="15a2" class="nm mh iq ng b gy nr no l np nq">function PostForm(): m.Component {<br/>  let post: IPost = {<br/>    userId: -1,<br/>    id: -1,<br/>    title: '',<br/>    body: ''<br/>  };</span><span id="23ab" class="nm mh iq ng b gy nr no l np nq">  const id = m.route.param('id');<br/>  if (id) {<br/>    m.request&lt;IPost&gt;({<br/>      method: 'GET',<br/>      url: `<a class="ae lr" href="https://jsonplaceholder.typicode.com/posts/${id}`" rel="noopener ugc nofollow" target="_blank">https://jsonplaceholder.typicode.com/posts/${id}`</a><br/>    }).then(data =&gt; post = data);<br/>  }</span><span id="e4ff" class="nm mh iq ng b gy nr no l np nq">  return {<br/>    view: () =&gt; m('form',<br/>      m('label', <br/>        m('span', 'Title'), <br/>        m('input[type="text"]', { <br/>          value: post.title,<br/>          onchange: (e: Event) =&gt; <br/>            post.title = (e.target as HTMLInputElement).value<br/>        })<br/>      ),<br/>      m('label', <br/>        m('span', 'Body'), <br/>        m('textarea[rows="5"]', { <br/>          value: post.body,<br/>          onchange: (e: Event) =&gt; <br/>            post.body = (e.target as HTMLTextAreaElement).value<br/>        })<br/>      ),<br/>      m('button.button[type="button"]', { <br/>        onclick: () =&gt; savePost(post) <br/>      }, 'Save')<br/>    )<br/>  };<br/>}</span></pre><p id="b891" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">浏览代码:</p><ul class=""><li id="543a" class="ls lt iq kx b ky kz lb lc le lu li lv lm lw lq ns ly lz ma bi translated">在<code class="fe nd ne nf ng b">savePost</code>中唯一的新东西是我们给<code class="fe nd ne nf ng b">m.request</code>增加了一个身体。</li><li id="6cbc" class="ls lt iq kx b ky mb lb mc le md li me lm mf lq ns ly lz ma bi translated">在<code class="fe nd ne nf ng b">PostForm</code>中，我们创建一个表单。它有两个输入字段(其中一个实际上是一个<code class="fe nd ne nf ng b">textarea</code>)和一个按钮。</li><li id="62bf" class="ls lt iq kx b ky mb lb mc le md li me lm mf lq ns ly lz ma bi translated">我们通过添加一个对象作为<code class="fe nd ne nf ng b">m</code>函数的第二个参数来设置输入的属性。我们还设置了<code class="fe nd ne nf ng b">onchange</code>事件处理程序来从输入字段更新帖子的值。</li><li id="9cc5" class="ls lt iq kx b ky mb lb mc le md li me lm mf lq ns ly lz ma bi translated">注意我们如何直接在<code class="fe nd ne nf ng b">m</code>函数的第一个参数中设置简单的属性，使用与CSS选择器中相同的语法。我们可以把它们放在第二个参数的对象中，就像我们对<code class="fe nd ne nf ng b">m.route.Link</code>的<code class="fe nd ne nf ng b">href</code>所做的那样——但是我想演示这样做的方法。最终，这主要是一个品味和可读性的问题。</li><li id="2068" class="ls lt iq kx b ky mb lb mc le md li me lm mf lq ns ly lz ma bi translated">作为最后一步，我们包括一个按钮来保存文章。</li></ul><h1 id="5c9c" class="mg mh iq bd mi mj mk ml mm mn mo mp mq jw mr jx ms jz mt ka mu kc mv kd mw mx bi translated">6.添加删除按钮</h1><p id="19a4" class="pw-post-body-paragraph kv kw iq kx b ky my jr la lb mz ju ld le na lg lh li nb lk ll lm nc lo lp lq ij bi translated">作为最后一个CRUD操作，我们要实现delete。我们将返回到PostList函数，并在每个列表项中添加一个按钮。该按钮将有一个click事件处理程序，向api发送删除请求。</p><p id="6c88" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">实际上，这一部分没有什么新的东西，所以我将它作为一个练习留给你。但是如果你需要帮助，你可以在GitHub 上看一下完成的代码。</p><h1 id="3981" class="mg mh iq bd mi mj mk ml mm mn mo mp mq jw mr jx ms jz mt ka mu kc mv kd mw mx bi translated">摘要</h1><p id="3e31" class="pw-post-body-paragraph kv kw iq kx b ky my jr la lb mz ju ld le na lg lh li nb lk ll lm nc lo lp lq ij bi translated">仅仅通过六个简单的步骤，我们就构建了一个CRUD应用程序。Mithril负责渲染、路由和HTTP请求，其余的由普通JavaScript完成。</p><p id="7a7d" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">到现在为止，你已经看到了秘银是多么容易使用。<code class="fe nd ne nf ng b">m</code>函数允许你使用CSS选择器之类的语法创建元素。组件模型易于使用，并使大型应用程序易于管理。Mithril自带路由器和HTTP请求处理器。</p><p id="a38c" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">无论你是需要一个快速添加到你的网站还是一个大型的商业应用程序，那么你现在已经知道你需要什么了。</p><p id="7607" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">现在，您基本上可以将Mithril.js添加到您的工具箱中。如果你想了解更多，去https://mithril.js.org吧。</p></div></div>    
</body>
</html>