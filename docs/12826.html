<html>
<head>
<title>The Easiest Way to Use Caching in Go</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">在Go中使用缓存的最简单方法</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/easiest-way-to-use-caching-in-golang-d3c639f9483a?source=collection_archive---------5-----------------------#2022-07-05">https://betterprogramming.pub/easiest-way-to-use-caching-in-golang-d3c639f9483a?source=collection_archive---------5-----------------------#2022-07-05</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="f2ef" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">使用Kubernetes的client-go软件包</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/afcc67663e82bd9a47aa857c64d5a6e1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*ooU7GjR28o2-n0hL"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">照片由<a class="ae kv" href="https://unsplash.com/@perfectshot4u?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Arvind meena mina </a>在<a class="ae kv" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</p></figure><p id="ce5b" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">缓存是任何程序中用来快速访问常用数据的重要概念之一。</p><p id="b449" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在本文中，让我们了解如何轻松地使用Kubernetes <a class="ae kv" href="https://github.com/kubernetes/client-go" rel="noopener ugc nofollow" target="_blank"> client-go </a>包中可用的缓存方法。</p><p id="2689" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">首先，让我们考虑一个简单的场景，我们希望在缓存中存储键和值。完整的程序可以在我的<a class="ae kv" href="https://github.com/Karthik-K-N/goCache" rel="noopener ugc nofollow" target="_blank"> Github </a>库中找到。</p><pre class="kg kh ki kj gt ls lt lu lv aw lw bi"><span id="9610" class="lx ly iq lt b gy lz ma l mb mc">// cacheTTL is the duration of time to hold the key in cache<br/>const <em class="md">cacheTTL </em>= 20 * time.<em class="md">Second<br/><br/></em>// keyValue contains the fields to store the key and value<br/>type keyValue struct {<br/>   key   string<br/>   value string<br/>}<br/><br/>func main() {<br/>   cacheStore := cache.NewTTLStore(cacheKeyFunc, <em class="md">cacheTTL</em>)<br/>}</span><span id="49c2" class="lx ly iq lt b gy me ma l mb mc">// cacheKeyFunc defines the key function required in TTLStore.<br/>func cacheKeyFunc(obj interface{}) (string, error) {<br/>   return obj.(keyValue).key, nil<br/>}</span></pre><p id="6ba1" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在上面的代码片段中，在main函数中，我们使用以下代码初始化缓存存储:</p><p id="319e" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><code class="fe mf mg mh lt b"><strong class="ky ir">cacheKeyFunc</strong></code>:告诉使用什么作为键来存储用户提供的对象到缓存中。</p><p id="41f4" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><code class="fe mf mg mh lt b"><strong class="ky ir">cacheTTL</strong></code>:缓存中保存密钥的持续时间。</p><p id="ed81" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">完成基本初始化后，我们现在可以借助以下函数将值存储在缓存中:</p><pre class="kg kh ki kj gt ls lt lu lv aw lw bi"><span id="e2d8" class="lx ly iq lt b gy lz ma l mb mc">func addToCache(cacheStore cache.Store, object keyValue) error {<br/>   err := cacheStore.Add(object)<br/>   if err != nil {<br/>      klog.Errorf("failed to add key value to cache error", err)<br/>      return err<br/>   }<br/>   return nil<br/>}<br/><br/>func fetchFromCache(cacheStore cache.Store, key string) (string, error) {<br/>   obj, exists, err := cacheStore.GetByKey(key)<br/>   if err != nil {<br/>      klog.Errorf("failed to add key value to cache error", err)<br/>      return "", err<br/>   }<br/>   if !exists {<br/>      klog.Errorf("object does not exist in the cache")<br/>      return "", nil<br/>   }<br/>   return obj.(keyValue).value, nil<br/>}<br/><br/>func deleteFromCache(cacheStore cache.Store, object keyValue) error {<br/>   return cacheStore.Delete(object)<br/>}</span></pre><p id="84e7" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在上面的代码片段中，我们使用了cachestore方法</p><p id="4115" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">添加<strong class="ky ir"> </strong>将值存储在缓存<strong class="ky ir">中，添加</strong> <code class="fe mf mg mh lt b"><strong class="ky ir">GetByKey</strong></code> <strong class="ky ir"> </strong>从提供的键中获取值，添加“删除”将值从缓存中删除。</p><p id="03f2" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在获取时，我们需要确保检查所需键的值是否存在于缓存中，如果它过期或从未被添加，它可能不存在于缓存中。</p><p id="7211" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">此外，为了添加、<code class="fe mf mg mh lt b">GetByKey</code>和<code class="fe mf mg mh lt b">Delete</code>方法，缓存存储还有许多其他方法，如Get、Update、List等——所有方法都可以在这里看到<a class="ae kv" href="https://github.com/kubernetes/client-go/blob/master/tools/cache/store.go#L39-L71" rel="noopener ugc nofollow" target="_blank">。</a></p><p id="53b5" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">最后，主函数看起来像这样</p><pre class="kg kh ki kj gt ls lt lu lv aw lw bi"><span id="ae0b" class="lx ly iq lt b gy lz ma l mb mc">func main() {<br/>   cacheStore := cache.NewTTLStore(cacheKeyFunc, <em class="md">cacheTTL</em>)<br/><br/>   testKey := "myKey"<br/>   key := keyValue{<br/>      key:   testKey,<br/>      value: "myValue",<br/>   }<br/><br/>   klog.Infof("adding the key %v to cache", key)<br/><br/>   err := addToCache(cacheStore, key)<br/>   if err != nil {<br/>      klog.Fatalf("failed to add the key %v to cache error %v", key, err)<br/>   }<br/><br/>   klog.Infof("fetching the value for key: %s from cache", testKey)<br/><br/>   value, err := fetchFromCache(cacheStore, "myKey")<br/>   if err != nil {<br/>      klog.Fatalf("failed to fetch value for key %S from cache error %v", testKey, err)<br/>   }<br/>   if value == "" {<br/>      klog.Fatalf("the value for key %s is empty", testKey)<br/>   }<br/><br/>   klog.Infof("successfully fetched the value for key %s from cache value: %s", testKey, value)<br/><br/>   klog.Infof("deleting the key %s from cache", testKey)<br/>   err = deleteFromCache(cacheStore, key)<br/>   if err != nil {<br/>      klog.Fatalf("failed to delete key %s from cache error %v", testKey, err)<br/>   }<br/>}</span></pre><p id="d050" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在我们为上面的代码添加单元测试之前，我们的工作还没有完全完成。让我们为<code class="fe mf mg mh lt b">addToCache</code>和<code class="fe mf mg mh lt b">fetchFromCache</code>函数添加单元测试。</p><pre class="kg kh ki kj gt ls lt lu lv aw lw bi"><span id="630a" class="lx ly iq lt b gy lz ma l mb mc">func TestAddToCache(t *testing.T) {<br/><br/>   cacheStore := cache.NewTTLStore(cacheKeyFunc, <em class="md">cacheTTL</em>)<br/>   testKey := keyValue{<br/>      key:   "testKey",<br/>      value: "testValue",<br/>   }<br/>   err := addToCache(cacheStore, testKey)<br/>   if err != nil {<br/>      t.Fatalf("expecting error to be nil but got err %v", err)<br/>   }<br/>}<br/><br/>func TestFetchFromCache(t *testing.T) {<br/><br/>   defaultCacheStoreFunc := func() cache.Store {<br/>      return cache.NewTTLStore(cacheKeyFunc, <em class="md">cacheTTL</em>)<br/>   }<br/>   testKey := keyValue{<br/>      key:   "testKey",<br/>      value: "testValue",<br/>   }<br/><br/>   testCases := []struct {<br/>      name          string<br/>      expectedError error<br/>      expectedValue string<br/>      keyName       string<br/>      sleep         bool<br/>      cacheStore    func() cache.Store<br/>   }{<br/>      {<br/>         name:          "exists in cache",<br/>         expectedValue: "testValue",<br/>         keyName:       "testKey",<br/>         cacheStore:    defaultCacheStoreFunc,<br/>      },<br/>      {<br/>         name:          "not exists in cache",<br/>         expectedValue: "",<br/>         keyName:       "notTestKey",<br/>         cacheStore:    defaultCacheStoreFunc,<br/>      },<br/>      {<br/>         name:          "key in cache expired",<br/>         expectedValue: "",<br/>         keyName:       "testKey",<br/>         cacheStore: func() cache.Store {<br/>            return cache.NewTTLStore(cacheKeyFunc, time.<em class="md">Millisecond</em>)<br/>         },<br/>      },<br/>   }<br/>   for _, tc := range testCases {<br/>      t.Run(tc.name, func(t *testing.T) {<br/>         gs := NewWithT(t)<br/>         cacheStore := tc.cacheStore()<br/>         err := addToCache(cacheStore, testKey)<br/>         if err != nil {<br/>            t.Fatalf("failed to add key to cache error %v", err)<br/>         }<br/>         if tc.sleep {<br/>            time.Sleep(time.<em class="md">Second</em>)<br/>         }<br/>         value, err := fetchFromCache(cacheStore, keyValue{key: tc.keyName})<br/>         if err != nil {<br/>            if tc.expectedError != nil {<br/>               gs.Expect(err).To(HaveOccurred())<br/>               gs.Expect(err.Error()).To(Equal(tc.expectedError.Error()))<br/>            } else {<br/>               gs.Expect(err).ToNot(HaveOccurred())<br/>            }<br/>         }<br/>         gs.Expect(value).To(Equal(tc.expectedValue))<br/>      })<br/>   }<br/>}</span></pre><p id="270e" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">完整的程序和测试可以在我的<a class="ae kv" href="https://github.com/Karthik-K-N/goCache" rel="noopener ugc nofollow" target="_blank"> GitHub </a>库中找到。</p><h1 id="9e1c" class="mi ly iq bd mj mk ml mm mn mo mp mq mr jw ms jx mt jz mu ka mv kc mw kd mx my bi translated">参考</h1><ol class=""><li id="afe3" class="mz na iq ky b kz nb lc nc lf nd lj ne ln nf lr ng nh ni nj bi translated"><a class="ae kv" rel="noopener ugc nofollow" target="_blank" href="/unit-testing-in-go-language-using-mocks-3b873ce1348d">用go语言进行单元测试</a></li><li id="b502" class="mz na iq ky b kz nk lc nl lf nm lj nn ln no lr ng nh ni nj bi translated"><a class="ae kv" rel="noopener ugc nofollow" target="_blank" href="/writing-custom-kubernetes-controller-and-webhooks-141230820e9">编写定制的Kubernetes控制器和webhooks </a></li></ol></div></div>    
</body>
</html>