<html>
<head>
<title>Build an iOS Screen Recorder With React Native</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">用React Native构建一个iOS屏幕记录器</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/building-an-ios-screen-recorder-with-react-native-9e8c764c477e?source=collection_archive---------0-----------------------#2020-02-22">https://betterprogramming.pub/building-an-ios-screen-recorder-with-react-native-9e8c764c477e?source=collection_archive---------0-----------------------#2020-02-22</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="62a7" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">这比你想象的要容易得多</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/131d4f28341dfa84ece755964b8680c2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*GKJGZ_A0qbV05pNjiutL1Q@2x.jpeg"/></div></div></figure><p id="8c26" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">用React Native这样的跨平台工具构建一个屏幕录制器意味着必须编写大量的原生平台特定代码，所以跳过React Native是有意义的。然而，我将这个解决方案实现为React Native内置的一个更大的应用程序中的一个小功能。</p><p id="a74f" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">我可能会做另一个教程，展示如何在Android中实现同样的事情。</p><p id="a7ff" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">如果你遵循这个教程，你也可以不用React Native就能使用大部分代码为iOS构建一个屏幕录制应用。</p><p id="2698" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">你需要一个安装了iOS v12.0+的iOS设备，因为屏幕录制无法在模拟器上运行。</p><p id="06e8" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">以下是我们将在本教程中涉及的主题:</p><ul class=""><li id="7bd8" class="lq lr it kw b kx ky la lb ld ls lh lt ll lu lp lv lw lx ly bi translated">如何用React Native编写原生模块？</li><li id="d7c5" class="lq lr it kw b kx lz la ma ld mb lh mc ll md lp lv lw lx ly bi translated">iOS广播上传扩展。</li><li id="f26f" class="lq lr it kw b kx lz la ma ld mb lh mc ll md lp lv lw lx ly bi translated">ReplayKit。</li><li id="b192" class="lq lr it kw b kx lz la ma ld mb lh mc ll md lp lv lw lx ly bi translated">应用程序组—共享数据b/w目标</li></ul><p id="2ea2" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">本教程将涵盖很多内容。到最后，它将不仅仅是一个你能制作的屏幕记录器。</p><h1 id="c687" class="me mf it bd mg mh mi mj mk ml mm mn mo jz mp ka mq kc mr kd ms kf mt kg mu mv bi translated">完全码</h1><p id="cf6b" class="pw-post-body-paragraph ku kv it kw b kx mw ju kz la mx jx lc ld my lf lg lh mz lj lk ll na ln lo lp im bi translated">一旦您按照本指南进行操作，如果您遇到任何问题，请使用此存储库作为参考。</p><div class="nb nc gp gr nd ne"><a href="https://github.com/linuxpi/ScreenRecordingRNDemo" rel="noopener  ugc nofollow" target="_blank"><div class="nf ab fo"><div class="ng ab nh cl cj ni"><h2 class="bd iu gy z fp nj fr fs nk fu fw is bi translated">linuxpi/ScreenRecordingRNDemo</h2><div class="nl l"><h3 class="bd b gy z fp nj fr fs nk fu fw dk translated">React原生iOS屏幕记录器。在…上创建一个帐户，为linuxpi/ScreenRecordingRNDemo开发做贡献</h3></div><div class="nm l"><p class="bd b dl z fp nj fr fs nk fu fw dk translated">github.com</p></div></div><div class="nn l"><div class="no l np nq nr nn ns ks ne"/></div></div></a></div><p id="8b48" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">让我们直接跳进来吧！</p></div><div class="ab cl nt nu hx nv" role="separator"><span class="nw bw bk nx ny nz"/><span class="nw bw bk nx ny nz"/><span class="nw bw bk nx ny"/></div><div class="im in io ip iq"><h1 id="f44e" class="me mf it bd mg mh oa mj mk ml ob mn mo jz oc ka mq kc od kd ms kf oe kg mu mv bi translated">安装React本机JS组件</h1><p id="6f33" class="pw-post-body-paragraph ku kv it kw b kx mw ju kz la mx jx lc ld my lf lg lh mz lj lk ll na ln lo lp im bi translated">让我们假设您有一个使用<code class="fe of og oh oi b">create-react-app</code> <em class="oj">设置的React原生项目。</em></p><p id="5598" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">首先，我们创建一个组件，在您的应用程序中为屏幕录制相关操作提供一个UI。我们将这个组件命名为<code class="fe of og oh oi b">ScreenRecorder</code> <strong class="kw iu"> <em class="oj">。</em> </strong></p><p id="2021" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">现在让我们添加一个状态变量，<code class="fe of og oh oi b">recordings </code> —它将用于列出所有屏幕记录的文件路径。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ok ol l"/></div></figure></div><div class="ab cl nt nu hx nv" role="separator"><span class="nw bw bk nx ny nz"/><span class="nw bw bk nx ny nz"/><span class="nw bw bk nx ny"/></div><div class="im in io ip iq"><h1 id="4906" class="me mf it bd mg mh oa mj mk ml ob mn mo jz oc ka mq kc od kd ms kf oe kg mu mv bi translated">我们的第一个本地模块</h1><p id="48b2" class="pw-post-body-paragraph ku kv it kw b kx mw ju kz la mx jx lc ld my lf lg lh mz lj lk ll na ln lo lp im bi translated">现在让我们在Swift中设置一个本地视图管理器。这用于显示记录按钮。</p><p id="6f2d" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">为此，我们使用React Native提供的<code class="fe of og oh oi b">RCTViewManager</code>。它使我们的本机模块能够在JavaScript组件中使用。</p><p id="058f" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">使用文件<code class="fe of og oh oi b">ScreenRecordingDemo.xcworkspace</code> <em class="oj">在Xcode中打开您的项目。</em> <strong class="kw iu"> <em class="oj"> </em> </strong>这里的<code class="fe of og oh oi b">ScreenRecordingDemo</code> <strong class="kw iu"> <em class="oj"> </em> </strong>是我反应过来的原生项目名称。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi om"><img src="../Images/1514c33d7af4ef9e9c3d219dcc7b885d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1068/format:webp/1*F-HgcIu29ttvKPWa4VOlkQ.png"/></div><p class="on oo gj gh gi op oq bd b be z dk translated">Xcode中的项目浏览器视图</p></figure><p id="83b6" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">按下<strong class="kw iu"> Cmd + N <em class="oj"> </em> </strong>键，在选中的组中创建新的swift文件。命名为<code class="fe of og oh oi b">RecordComponent</code>。你将被要求创建一个Obj-C桥接头——点击“创建桥接头”</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi or"><img src="../Images/15344c82fd9a173028571971f59a9ac2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*bq7ysswuXBevp-H5ui2OOg.png"/></div></div></figure><p id="d5b1" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">应该在项目浏览器中为您创建两个新文件— <code class="fe of og oh oi b">RecordComponent.swift</code>和<code class="fe of og oh oi b">ScreenRecordingDemo-Bridging-Header.h</code>。</p><p id="05fa" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated"><em class="oj">注意:桥接头文件只在你创建第一个本地文件时创建一次。</em></p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi os"><img src="../Images/b3eb30c01c25654295f84ef145ed1384.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*7upb_qwhsKhypM6zis3Rew.png"/></div></div></figure><p id="63b8" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">现在让我们为我们的<code class="fe of og oh oi b">RecordComponent</code>写一些本机代码吧！</p><p id="fae5" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">要使用RCTViewManager，我们需要将下面的头导入到<code class="fe of og oh oi b">ScreenRecordDemo-Bridging-Header.h</code> <em class="oj"> </em>文件中。</p><pre class="kj kk kl km gt ot oi ou ov aw ow bi"><span id="75ad" class="ox mf it oi b gy oy oz l pa pb">#import &lt;React/RCTViewManager.h&gt;</span></pre><p id="ecf4" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">现在打开<code class="fe of og oh oi b">RecordComponent.swift</code><strong class="kw iu"><em class="oj"/></strong>并创建一个新的类<code class="fe of og oh oi b">RecordComponent</code>，它继承了<code class="fe of og oh oi b">RCTViewManager</code>。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi pc"><img src="../Images/c4690d0f28cdb64d306c7faf2bd14954.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*8BAHdw012QbqimvBiCPiTw.png"/></div></div></figure><p id="5aeb" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">我们添加了<code class="fe of og oh oi b">@objc(RecordComponent)</code> <strong class="kw iu"> </strong>来使该模块在objective-C文件中可用。</p><p id="3b65" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">我们在这里实现的record按钮并不是普通的按钮——我们使用的是ReplayKit提供的<code class="fe of og oh oi b">RPSystemBroadcastPickerView</code> <strong class="kw iu"> <em class="oj"> </em> </strong>。</p><p id="c358" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">下面是它的代码:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ok ol l"/></div></figure><p id="454b" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">我们已经覆盖了<code class="fe of og oh oi b">RCTViewManager</code>的<code class="fe of og oh oi b">view</code>方法来返回我们的记录按钮UI。<code class="fe of og oh oi b">RCTViewManager</code>的视图<strong class="kw iu"> <em class="oj"> </em> </strong>方法应该返回UIView的一个实例或者任何继承UIView的类。无论<code class="fe of og oh oi b">view</code>方法返回什么，都以<code class="fe of og oh oi b">RecordComponent</code>的名称显示在屏幕上。</p><p id="bdb2" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">我们创建一个<code class="fe of og oh oi b">RPSystemBroadcastPickerView</code> <strong class="kw iu"> <em class="oj"> </em> </strong>的实例，并对其进行一些修改后返回。</p><p id="de0d" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">这里还有一点需要注意的是<code class="fe of og oh oi b">#available(iOS 12.0, *)</code>检查。这是必要的，因为我们在这里编写的代码仅在iOS12.0+上受支持。</p><p id="2ca0" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">现在让我们将<code class="fe of og oh oi b">RecordComponent</code>添加到React原生JS组件中。</p></div><div class="ab cl nt nu hx nv" role="separator"><span class="nw bw bk nx ny nz"/><span class="nw bw bk nx ny nz"/><span class="nw bw bk nx ny"/></div><div class="im in io ip iq"><h1 id="b70d" class="me mf it bd mg mh oa mj mk ml ob mn mo jz oc ka mq kc od kd ms kf oe kg mu mv bi translated">在JS组件中导入本机模块</h1><p id="fb85" class="pw-post-body-paragraph ku kv it kw b kx mw ju kz la mx jx lc ld my lf lg lh mz lj lk ll na ln lo lp im bi translated">为了让React Native发现<code class="fe of og oh oi b">RecordComponent</code>(本机模块)，我们需要在objective-C中调用React Native提供的一些函数，这样它就知道<code class="fe of og oh oi b">RecordComponent</code>可供使用。</p><p id="e805" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">让我们为<code class="fe of og oh oi b">RecordComponent.swift</code>创建一个相应的objective-C文件来调用这些函数——<code class="fe of og oh oi b"><strong class="kw iu"><em class="oj"> </em></strong>RecordComponent.m </code>——并添加以下代码:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ok ol l"/></div></figure><p id="af46" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated"><code class="fe of og oh oi b">RCT_EXTERN_MODULE</code> <strong class="kw iu"> </strong>使<code class="fe of og oh oi b">RecordComponent</code>在React原生代码中可用。</p><p id="fb98" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">就这样，<code class="fe of og oh oi b">RecordComponent</code>现在可以用在您的反应性JS代码中了。</p><p id="65b6" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">让我们修改ScreenRecorder.js文件，向其中添加原生的<code class="fe of og oh oi b">RecordComponent</code>。完成后，ScreenRecorder.js的代码应该是这样的:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ok ol l"/></div></figure><p id="45a3" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">除了<code class="fe of og oh oi b">requireNativeComponens</code>，这里没有任何意外。顾名思义，我们正在使用<code class="fe of og oh oi b">RCT_EXTERN_MODULE</code> <strong class="kw iu">获取我们导出的原生组件。</strong></p><p id="aec6" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">现在让我们在设备上运行应用程序。如果你从未在iOS设备上运行过React原生应用程序，你可能想要遵循这个<a class="ae pd" href="https://facebook.github.io/react-native/docs/running-on-device" rel="noopener ugc nofollow" target="_blank">指南</a></p><p id="f642" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">应用程序应该是这样的:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi pe"><img src="../Images/183dbd5961a5275668135c91d3413adc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Cd1Ecd3XA0_aI07AKQYeEQ.png"/></div></div><p class="on oo gj gh gi op oq bd b be z dk translated"><em class="pf">我们应用的第一稿</em></p></figure></div><div class="ab cl nt nu hx nv" role="separator"><span class="nw bw bk nx ny nz"/><span class="nw bw bk nx ny nz"/><span class="nw bw bk nx ny"/></div><div class="im in io ip iq"><h1 id="1437" class="me mf it bd mg mh oa mj mk ml ob mn mo jz oc ka mq kc od kd ms kf oe kg mu mv bi translated">设置iOS广播上传扩展</h1><p id="be85" class="pw-post-body-paragraph ku kv it kw b kx mw ju kz la mx jx lc ld my lf lg lh mz lj lk ll na ln lo lp im bi translated">我们已经有了record按钮，现在我们需要将我们的应用程序添加到<strong class="kw iu"><em class="oj">Start Recording</em></strong>picker视图(右边的截图)，这样当我们开始记录时，我们的应用程序可以接收记录样本缓冲区。</p><p id="c9b9" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">为此，我们在应用程序中添加了一个<em class="oj">广播上传扩展</em>。</p><ul class=""><li id="96ed" class="lq lr it kw b kx ky la lb ld ls lh lt ll lu lp lv lw lx ly bi translated">进入Xcode，文件-&gt;新建-&gt;目标。</li><li id="58c7" class="lq lr it kw b kx lz la ma ld mb lh mc ll md lp lv lw lx ly bi translated">从列表中选择【广播上传扩展名】<em class="oj"/><strong class="kw iu"><em class="oj"/></strong>。</li><li id="c340" class="lq lr it kw b kx lz la ma ld mb lh mc ll md lp lv lw lx ly bi translated">添加<strong class="kw iu"> </strong> <code class="fe of og oh oi b">ScreenRecordingExt</code>作为产品名称。</li></ul><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi pg"><img src="../Images/7c0ecb38a992f77b6ba18e2032fa0886.png" data-original-src="https://miro.medium.com/v2/resize:fit:1192/format:webp/1*7YKuOj6bZhtFgDT2pGQ67A.png"/></div></figure><p id="c1b7" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated"><code class="fe of og oh oi b">ScreenRecordingExt</code>和<code class="fe of og oh oi b">ScreenRecordingExtSetupUI</code>现在应该可以在项目浏览器中找到了。让我们用应用程序运行新的扩展，看看有什么变化。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi ph"><img src="../Images/8e0ea55c5f75c48a4fd4191d56a5c698.png" data-original-src="https://miro.medium.com/v2/resize:fit:1268/format:webp/1*Dbc2uysRTgcsi6ez6Vsy1Q.png"/></div><p class="on oo gj gh gi op oq bd b be z dk translated">从下拉列表中选择扩展名，然后单击播放</p></figure><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi pi"><img src="../Images/a3bbbe642b28e14ab5c9e82417e554d2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ZJ1ATmrfOhjcWWxYkqjFWA.png"/></div></div><p class="on oo gj gh gi op oq bd b be z dk translated">选择UI扩展并单击播放</p></figure><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi pj"><img src="../Images/bbe3a8bb258a97f5c873c3319847d4cd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Zvh8cwyPYdqGE7ei3Fnqng.png"/></div></div><p class="on oo gj gh gi op oq bd b be z dk translated">选择我们正在使用的应用程序</p></figure><p id="9eca" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated"><em class="oj">注意:我不得不分别运行两个扩展的构建来使它工作。如果你知道更好的方法，请在评论中告诉我！</em></p><p id="d28c" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">现在，您应该能够在picker视图中看到我们的广播上传扩展:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi pe"><img src="../Images/5d3e858551c96424c2c984039c114754.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*w9TLNojg6qEoK3Q75GQihQ.png"/></div></div></figure><p id="e132" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">开始录音吧！</p></div><div class="ab cl nt nu hx nv" role="separator"><span class="nw bw bk nx ny nz"/><span class="nw bw bk nx ny nz"/><span class="nw bw bk nx ny"/></div><div class="im in io ip iq"><h1 id="bd64" class="me mf it bd mg mh oa mj mk ml ob mn mo jz oc ka mq kc od kd ms kf oe kg mu mv bi translated">使用AVAssetWriter保存录像</h1><p id="5bf8" class="pw-post-body-paragraph ku kv it kw b kx mw ju kz la mx jx lc ld my lf lg lh mz lj lk ll na ln lo lp im bi translated">我们将使用<code class="fe of og oh oi b">AVAssetWriter</code>将视频缓冲区保存到iOS应用程序的documents目录下的一个文件中。</p><p id="6893" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">让我们打开<code class="fe of og oh oi b">ScreenRecordingExt</code>中的<code class="fe of og oh oi b">SampleHandler.swift</code>。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi pk"><img src="../Images/cb65bccac76ba1411efee99785347356.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*qCr6i-do-tiOWLhOc4CZHQ.png"/></div></div></figure><p id="e502" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">在开始之前，我们将创建一个<code class="fe of og oh oi b">FileSystemUtil</code>来帮助生成文件系统路径，我们将在那里写入我们的记录。针对我们的应用和扩展创建新的Swift文件:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi or"><img src="../Images/ef996ea2f64ed5d9aa66661202676f24.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*vyBBNZxJWVv7mHg5PS4XhA.png"/></div></div></figure><p id="de94" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">我们在这里将应用程序和扩展都作为目标，这样我们就可以在两个目标的代码中使用这个实用程序</p><p id="dfec" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">下面是<code class="fe of og oh oi b">FileSystemUtil.swift</code>的代码:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ok ol l"/></div></figure><p id="1bc6" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">现在我们将修改<code class="fe of og oh oi b">ScreenRecordingExt</code> <strong class="kw iu"> </strong>目标中<code class="fe of og oh oi b">broadcastStarted</code><strong class="kw iu"><em class="oj"/></strong><strong class="kw iu"><em class="oj"/></strong><code class="fe of og oh oi b">SampleHandler.swift</code>，<strong class="kw iu"> </strong>来初始化我们的<code class="fe of og oh oi b">AVAssetWriter</code>，并为视频输入做好准备。</p><p id="e98c" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">代码如下:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ok ol l"/></div></figure><p id="707c" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">我们在这里生成一个带有随机名称的文件URL，并将其传送给<code class="fe of og oh oi b">AVAssetWritter</code>。这是我们的最终输出将在录制完成后保存的URL。添加一个writer输入后我们调用<code class="fe of og oh oi b">.startWriting()</code> <strong class="kw iu"> <em class="oj"> </em> </strong>使<code class="fe of og oh oi b">AVAssetWriter</code>能够接受录音缓冲。</p><p id="272d" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">接下来，我们修改<code class="fe of og oh oi b"><em class="oj">processSampleBuffer</em></code> <strong class="kw iu"> <em class="oj">，</em> </strong>这个函数接收所有下面的样本缓冲用于记录。我们需要将这些缓冲区添加到我们在<code class="fe of og oh oi b">broadcastStarted</code>中创建的<code class="fe of og oh oi b">AVAssetWriterInput</code>中。</p><p id="a499" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">代码如下:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ok ol l"/></div></figure><p id="9718" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">对于上面的代码，我得到了以下人员的帮助:<a class="ae pd" href="https://github.com/giridharvc7/ScreenRecord" rel="noopener ugc nofollow" target="_blank">https://github.com/giridharvc7/ScreenRecord</a>。这展示了iOS应用内屏幕记录器的实现。</p><p id="f96a" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">现在我们来处理录音的最后一部分——收尾。</p><p id="51ff" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">现在您应该已经知道我们将使用<code class="fe of og oh oi b">broadcastFinished</code>函数。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ok ol l"/></div></figure></div><div class="ab cl nt nu hx nv" role="separator"><span class="nw bw bk nx ny nz"/><span class="nw bw bk nx ny nz"/><span class="nw bw bk nx ny"/></div><div class="im in io ip iq"><h1 id="a6ba" class="me mf it bd mg mh oa mj mk ml ob mn mo jz oc ka mq kc od kd ms kf oe kg mu mv bi translated">设置应用程序组</h1><p id="d95e" class="pw-post-body-paragraph ku kv it kw b kx mw ju kz la mx jx lc ld my lf lg lh mz lj lk ll na ln lo lp im bi translated">我们有一个保存录像的文件URL。但在我们能看到录音之前，这是没有用的。</p><p id="d3fd" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">为此，我们必须使用应用组在我们的应用和扩展之间共享数据。我们保存的录音在我们的extension的documents目录中——extension和应用程序在iOS上各自独立的沙箱中运行，因此我们无法直接从我们的应用程序访问extension创建的文件。</p><p id="6f4f" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">如果你想在应用和扩展之间共享数据，你必须将文件保存在应用组中。关于应用程序组的简单介绍，我推荐这个视频:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="pl ol l"/></div><p class="on oo gj gh gi op oq bd b be z dk translated"><a class="ae pd" href="https://www.youtube.com/watch?v=Jlr9cF9nDnU" rel="noopener ugc nofollow" target="_blank">https://www.youtube.com/watch?v=Jlr9cF9nDnU</a></p></figure><p id="7511" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">让我们创建我们的应用程序组。</p><p id="e7d8" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">在Xcode中，转到“签名和功能”并添加一个新功能:“应用程序组”</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi pm"><img src="../Images/1c2962d68427d924992c200a4284f967.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*mN9h98mibLN_u-WPPQ647g.png"/></div></div></figure><p id="4b10" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">通过在<code class="fe of og oh oi b">group.</code> <strong class="kw iu"> </strong>前缀后添加您的捆绑包ID来添加新的应用程序组。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi pn"><img src="../Images/6144d4e94a7572fa86fa73efafb5266a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*dSDSHnbvlslR9vNSn_lK6A.png"/></div></div><p class="on oo gj gh gi op oq bd b be z dk translated">创建应用程序组后的最终视图</p></figure><p id="c521" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">现在转到目标列表中的<code class="fe of og oh oi b">ScreenRecordingExtension</code>，添加“应用程序组功能”</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi po"><img src="../Images/92887cf2b41fbef56b25f9cb44638698.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Ysns8jynEkXVyyJYHJi1PA.png"/></div></div><p class="on oo gj gh gi op oq bd b be z dk translated">在扩展中选择相同的应用程序组</p></figure><p id="870b" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">您之前添加的同一个应用程序组应该在这里可见。如果没有，请刷新列表并再次选中该框。</p><p id="93fa" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">现在，您已经在应用和扩展之间创建了一个共享空间。对于我们完成的每个录制，我们会将文件复制到共享应用程序组，以便我们的应用程序可以访问该文件。</p><p id="444e" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">让我们修改一下<code class="fe of og oh oi b">broadcastFinished</code>方法。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ok ol l"/></div></figure><p id="35c4" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">首先你会注意到我们创建了一个<code class="fe of og oh oi b">DispatchGroup</code>。如果你曾经在任何其他编程语言中使用过线程，它们在这里实现相同的功能。因为我们的扩展在后台运行，而<code class="fe of og oh oi b">finishWriting</code>下的代码将异步运行，所以后台线程将在<code class="fe of og oh oi b">finishWriting</code>中的异步代码完成之前结束。所以我们创建了一个<code class="fe of og oh oi b">DispatchGroup</code>来让后台线程等待，直到<code class="fe of og oh oi b">finishWriting</code>执行完毕。</p><p id="c4f4" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">现在来看一下<code class="fe of og oh oi b">finishWriting</code>正在做的事情——它只是将记录文件从我们的扩展的沙盒文档目录复制到共享应用程序组。</p></div><div class="ab cl nt nu hx nv" role="separator"><span class="nw bw bk nx ny nz"/><span class="nw bw bk nx ny nz"/><span class="nw bw bk nx ny"/></div><div class="im in io ip iq"><h1 id="32d6" class="me mf it bd mg mh oa mj mk ml ob mn mo jz oc ka mq kc od kd ms kf oe kg mu mv bi translated">列出所有录像</h1><p id="ce87" class="pw-post-body-paragraph ku kv it kw b kx mw ju kz la mx jx lc ld my lf lg lh mz lj lk ll na ln lo lp im bi translated">既然我们已经将记录文件复制到应用程序组共享容器，我们需要在我们的应用程序中列出它们。</p><p id="1ab5" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">让我们再创建一个本机模块，从React本机代码中获取应用程序组中的记录列表。我们将这个模块称为<code class="fe of og oh oi b">SharedFileSystemRCT</code> <strong class="kw iu"> <em class="oj">。</em> </strong>只为你的app创建这个模块，不为扩展创建。</p><p id="bdd1" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">下面是<code class="fe of og oh oi b">SharedFileSystemRCT.swift</code>的代码:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ok ol l"/></div></figure><p id="3be6" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">如果您熟悉Swift编码范式，代码非常简单。我们获取共享应用程序组中的文件列表，按修改日期排序，并用最终数据解析承诺。</p><p id="f98d" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">为了暴露这个模块和它的函数来反应原生JS代码，我们需要使用<code class="fe of og oh oi b">RCT_EXTERN_METHOD</code>，如本文开头所解释的。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ok ol l"/></div></figure><p id="dded" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">现在，让我们设置一个<code class="fe of og oh oi b">FlatList</code>来查看<code class="fe of og oh oi b">ScreenRecorder.js</code>中的所有记录。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ok ol l"/></div></figure><p id="9745" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">接下来，让我们实现<code class="fe of og oh oi b">viewRecordings</code>，它将用于打开一个原生UI来将记录保存到<code class="fe of og oh oi b">Files</code>应用程序，这样您就可以轻松地访问它。</p><p id="130f" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">为此，我们将在<code class="fe of og oh oi b">RecordComponent.swift</code> <strong class="kw iu"> <em class="oj"> </em> </strong>中创建一个方法，并将其公开给JS组件。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ok ol l"/></div></figure><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ok ol l"/></div></figure><p id="8d56" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">现在，让我们调用<code class="fe of og oh oi b">showSaveFile</code> <strong class="kw iu"> <em class="oj">，</em> </strong>点击列表中的一项。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ok ol l"/></div></figure><p id="7b10" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">让我们运行应用程序，看看这是否可行！</p><p id="874d" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">当您单击列表中的某个项目时，系统会提示您保存记录。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi pe"><img src="../Images/6297f87d445fef9e896b0c51a69de296.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Nah37JLt5NyeTQT9UtBSYg.png"/></div></div></figure><p id="37d4" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">这就是你要的——一个iOS屏幕记录器。我同意UI可以更好。如果您愿意，您可以花一些时间根据自己的喜好来设计UI。</p><p id="7611" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">这是一篇很长的文章，但是我希望你不仅仅是在学习构建一个屏幕记录器。希望你学到了很多概念，对你将来的各种任务有帮助。</p></div></div>    
</body>
</html>