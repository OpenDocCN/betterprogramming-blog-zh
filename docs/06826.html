<html>
<head>
<title>5 Answers to Kubernetes CKAD Practice Questions</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Kubernetes CKAD练习题的5个答案</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/5-answers-to-kubernetes-ckad-practice-questions-3fa1c72a6b5d?source=collection_archive---------5-----------------------#2020-11-09">https://betterprogramming.pub/5-answers-to-kubernetes-ckad-practice-questions-3fa1c72a6b5d?source=collection_archive---------5-----------------------#2020-11-09</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="3016" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">当我们回顾几个假设的CKAD问题以及可能的解决方案时，了解名称空间、pod、部署等等</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/1ecb307a7baab13c59f5c215d22b0727.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*z-RBaocREvUkjbAu4P4lhw.jpeg"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated"><a class="ae kv" href="https://unsplash.com/@andasta?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">安迪李</a>在<a class="ae kv" href="https://unsplash.com/s/photos/containers?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍照</p></figure><p id="c37c" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在使用<a class="ae kv" href="https://kubernetes.io/" rel="noopener ugc nofollow" target="_blank"> Kubernetes </a> (K8s)进行一些工作以及准备认证Kubernetes应用程序开发人员(CKAD)考试时，我在Matthew Palmer的网站上看到了一个名为“<a class="ae kv" href="https://matthewpalmer.net/kubernetes-app-developer/articles/ckad-practice-exam.html" rel="noopener ugc nofollow" target="_blank">认证Kubernetes应用程序开发人员(CKAD)认证</a>的练习考试”的页面，其中包含五个练习题，我将在这里进行介绍。如果你对我下面做的任何事情有问题，包括低效的解决方案，请在评论中告诉我。</p><p id="9909" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们不仅要展示每个问题的可能解决方案，还要验证我们的工作。</p><p id="d293" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">由于我们在进行该测试时仅限于使用<a class="ae kv" href="https://kubernetes.io/" rel="noopener ugc nofollow" target="_blank"> Kubernetes </a>网站，因此在适当的地方会引用该网站。特别是，<a class="ae kv" href="https://kubernetes.io/docs/reference/kubectl/cheatsheet/" rel="noopener ugc nofollow" target="_blank"> kubectl备忘单页面</a>是一个不错的起点，我们也可以在那里搜索我们需要的内容。</p><p id="3872" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">最后，对于每一个问题，我们都需要特别注意名称空间需求。</p><p id="5afa" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">本文依赖于运行在Ubuntu上的minikube和Oh My Zsh shell。</p><p id="94a7" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><em class="ls"> k指令</em>定义如下:</p><pre class="kg kh ki kj gt lt lu lv lw aw lx bi"><span id="835b" class="ly lz iq lu b gy ma mb l mc md">alias k='kubectl'</span></pre><p id="861d" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们来看看第一个问题。</p></div><div class="ab cl me mf hu mg" role="separator"><span class="mh bw bk mi mj mk"/><span class="mh bw bk mi mj mk"/><span class="mh bw bk mi mj"/></div><div class="ij ik il im in"><h1 id="164e" class="ml lz iq bd mm mn mo mp mq mr ms mt mu jw mv jx mw jz mx ka my kc mz kd na nb bi translated">问题1。</h1><p id="7d9a" class="pw-post-body-paragraph kw kx iq ky b kz nc jr lb lc nd ju le lf ne lh li lj nf ll lm ln ng lp lq lr ij bi translated">帕尔默练习考试[1]的第一个问题如下:</p><blockquote class="nh ni nj"><p id="0019" class="kw kx ls ky b kz la jr lb lc ld ju le nk lg lh li nl lk ll lm nm lo lp lq lr ij bi translated">"在集群中创建一个名为ggckad-s0的命名空间。<br/>在此名称空间中运行以下pod。</p><p id="599e" class="kw kx ls ky b kz la jr lb lc ld ju le nk lg lh li nl lk ll lm nm lo lp lq lr ij bi translated">1.一个名为pod-a的pod有一个运行<code class="fe nn no np lu b">kubegoldenguide/simple-http-server</code>映像的容器</p><p id="2918" class="kw kx ls ky b kz la jr lb lc ld ju le nk lg lh li nl lk ll lm nm lo lp lq lr ij bi translated">2.一个名为pod-b的容器，其中一个容器运行<code class="fe nn no np lu b">kubegoldenguide/alpine-spin:1.0.0</code>映像，另一个容器运行<code class="fe nn no np lu b">nginx:1.7.9</code></p><p id="c257" class="kw kx ls ky b kz la jr lb lc ld ju le nk lg lh li nl lk ll lm nm lo lp lq lr ij bi translated">记下ggckad-s0名称空间的<code class="fe nn no np lu b">kubectl get pods</code>的输出。"</p></blockquote><p id="20ea" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们可以手工拼凑一个pod，也可以自动生成，这应该是首选，因为如果可以避免的话，我们不想浪费时间。以下命令可用于自动生成每个YAML文件:一个用于<code class="fe nn no np lu b">kubegoldenguide/simple-http-server</code>容器，一个用于<code class="fe nn no np lu b">kubegoldenguide/alpine-spin:1.0.0</code>容器，一个用于<code class="fe nn no np lu b">nginx:1.7.9</code>容器。</p><pre class="kg kh ki kj gt lt lu lv lw aw lx bi"><span id="8228" class="ly lz iq lu b gy ma mb l mc md">kubectl run nginx --image=kubegoldenguide/simple-http-server --dry-run=client -o yaml &gt; simple-http-server.yaml</span><span id="5f14" class="ly lz iq lu b gy nq mb l mc md">kubectl run nginx --image=kubegoldenguide/alpine-spin:1.0.0 --dry-run=client -o yaml &gt; alpine-spin.yaml</span><span id="872d" class="ly lz iq lu b gy nq mb l mc md">kubectl run nginx --image=nginx:1.7.9 --dry-run=client -o yaml &gt; nginx.yaml</span></pre><p id="ec89" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们可以使用这些文件来创建这个问题所需的pod-a和pod-b YAML文件。</p><p id="50f3" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">pod-a的配置文件如下所示:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nr ns l"/></div></figure><p id="f3b9" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">pod-b的配置文件如下所示:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nr ns l"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">认证Kubernetes应用程序开发人员(CKAD)认证问题1.2配置Yaml的模拟考试</p></figure><p id="445f" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们需要首先按照说明创建名称空间:</p><pre class="kg kh ki kj gt lt lu lv lw aw lx bi"><span id="f50b" class="ly lz iq lu b gy ma mb l mc md">k create namespace ggckad-s0</span></pre><p id="73d2" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">接下来，我们可以应用此配置:</p><pre class="kg kh ki kj gt lt lu lv lw aw lx bi"><span id="3807" class="ly lz iq lu b gy ma mb l mc md">kubectl apply -f pod-[a or b].yaml --namespace ggckad-s0</span></pre><p id="0bce" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这个问题的最后一条指令指出，我们需要“写下ggckad-s0名称空间的<code class="fe nn no np lu b">kubectl get pods</code>的输出”这通过以下方式实现:</p><pre class="kg kh ki kj gt lt lu lv lw aw lx bi"><span id="238a" class="ly lz iq lu b gy ma mb l mc md">k get pods --namespace ggckad-s0</span></pre><p id="f02d" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这会产生以下结果:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nt"><img src="../Images/f10bbfcd2300b6f5dff9c8a24f4745dc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*mbK3-9Vf4UAlB8I1"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">运行“k get pods–命名空间ggckad-s0”的结果。</p></figure><h2 id="2ee9" class="ly lz iq bd mm nu nv dn mq nw nx dp mu lf ny nz mw lj oa ob my ln oc od na oe bi translated">验证我们的解决方案</h2><p id="7b6a" class="pw-post-body-paragraph kw kx iq ky b kz nc jr lb lc nd ju le lf ne lh li lj nf ll lm ln ng lp lq lr ij bi translated">下面是我们在这个例子中使用的整个脚本。我们检查所有容器的日志，以查看它们是否正确运行。</p><pre class="kg kh ki kj gt lt lu lv lw aw lx bi"><span id="2cd4" class="ly lz iq lu b gy ma mb l mc md">k create namespace ggckad-s0<br/>k apply -f pod-a.yaml --namespace ggckad-s0<br/>k logs pod-a --namespace ggckad-s0<br/>k apply -f pod-b.yaml --namespace ggckad-s0<br/>k logs pod-b alpine-spin-container --namespace ggckad-s0<br/>k logs pod-b nginx-container --namespace ggckad-s0</span></pre><p id="2fdd" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">运行该脚本应该会产生以下输出:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi of"><img src="../Images/f4eb3ca74b2eab2a12d8c303503764d5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*2e64RpctV6PgpcjQ"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">在这个例子中，k被定义为“别名k='kubectl '”。</p></figure><p id="f228" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们可以使用<code class="fe nn no np lu b">get events</code>命令来查看收集到的事件。</p><pre class="kg kh ki kj gt lt lu lv lw aw lx bi"><span id="6f46" class="ly lz iq lu b gy ma mb l mc md">k get events --namespace ggckad-s0</span></pre><p id="4ac2" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">运行该命令应该会产生以下输出:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi of"><img src="../Images/bb6b3aad51fcb2653dd74750495e37b8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*DzS-k_cIIcEBCHMR"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">设置pod-a和pod-b时在名称空间ggckad-s0中收集的事件的输出</p></figure><p id="119b" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">注意<code class="fe nn no np lu b">nginx-container</code>已经启动；然而，日志中没有消息表明它实际上正在运行，所以我们将通过将本地机器上的端口19999映射到pod-b pod中的端口80来检查这一点，pod-b pod应该指向在端口80上运行nginx web服务器的<code class="fe nn no np lu b">nginx-container</code>。</p><pre class="kg kh ki kj gt lt lu lv lw aw lx bi"><span id="c07c" class="ly lz iq lu b gy ma mb l mc md">kubectl port-forward pods/pod-b 19999:80 --namespace ggckad-s0</span></pre><p id="cb4a" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">当我们执行上面的行时，输出应该如下所示:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi of"><img src="../Images/894478d085f6c9f03478f833c0ae0ce6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*VV4t-2liuEAunuVw"/></div></div></figure><p id="6bbb" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">最后，我们现在可以通过浏览localhost:19999来测试nginx是否正在运行。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi of"><img src="../Images/521b9acb06fdba03360aa8425056dd4b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*q540NEitnTOwVpqY"/></div></div></figure><p id="7f89" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这个问题到此为止。</p></div><div class="ab cl me mf hu mg" role="separator"><span class="mh bw bk mi mj mk"/><span class="mh bw bk mi mj mk"/><span class="mh bw bk mi mj"/></div><div class="ij ik il im in"><h1 id="d235" class="ml lz iq bd mm mn mo mp mq mr ms mt mu jw mv jx mw jz mx ka my kc mz kd na nb bi translated">问题2。</h1><p id="d475" class="pw-post-body-paragraph kw kx iq ky b kz nc jr lb lc nd ju le lf ne lh li lj nf ll lm ln ng lp lq lr ij bi translated">帕尔默练习考试的第二个问题[1]如下:</p><blockquote class="nh ni nj"><p id="ead8" class="kw kx ls ky b kz la jr lb lc ld ju le nk lg lh li nl lk ll lm nm lo lp lq lr ij bi translated">"此问题中的所有操作都应在ggckad-s2命名空间中执行。</p><p id="b735" class="kw kx ls ky b kz la jr lb lc ld ju le nk lg lh li nl lk ll lm nm lo lp lq lr ij bi translated">创建一个名为app-config的配置映射，其中包含以下两个条目:</p><p id="03b9" class="kw kx ls ky b kz la jr lb lc ld ju le nk lg lh li nl lk ll lm nm lo lp lq lr ij bi translated">“connection_string”设置为“localhost:4096”</p><p id="07a7" class="kw kx ls ky b kz la jr lb lc ld ju le nk lg lh li nl lk ll lm nm lo lp lq lr ij bi translated">“外部url”设置为“google.com”</p><p id="c365" class="kw kx ls ky b kz la jr lb lc ld ju le nk lg lh li nl lk ll lm nm lo lp lq lr ij bi translated">使用运行<code class="fe nn no np lu b">kubegoldenguide/alpine-spin:1.0.0</code>映像的单个容器运行一个名为question-two-pod的pod，并将这些配置设置作为环境变量暴露在容器中。"</p></blockquote><p id="e770" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们需要首先按照说明创建名称空间:</p><pre class="kg kh ki kj gt lt lu lv lw aw lx bi"><span id="cb2b" class="ly lz iq lu b gy ma mb l mc md">k create namespace ggckad-s2</span></pre><p id="fdc7" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们需要一个<a class="ae kv" href="https://kubernetes.io/docs/concepts/configuration/configmap/" rel="noopener ugc nofollow" target="_blank">配置映射</a>，可以通过CLI创建，如下所示:</p><pre class="kg kh ki kj gt lt lu lv lw aw lx bi"><span id="1791" class="ly lz iq lu b gy ma mb l mc md">kubectl create configmap app-config --from-literal connection_string=localhost:4096 --from-literal external_url=<a class="ae kv" href="http://google.com/" rel="noopener ugc nofollow" target="_blank">google.com</a> --dry-run -oyaml --namespace ggckad-s2</span></pre><p id="3be8" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这在以下要点中定义:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nr ns l"/></div></figure><p id="ae34" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">接下来，我们可以应用此配置，确保包含指定的名称空间:</p><pre class="kg kh ki kj gt lt lu lv lw aw lx bi"><span id="2725" class="ly lz iq lu b gy ma mb l mc md">k apply -f ./app-config.yaml --namespace ggckad-s2</span></pre><p id="2030" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">问题2-pod的配置文件如下所示:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nr ns l"/></div></figure><p id="5864" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们需要应用pod配置文件，我们通过以下命令来实现:</p><pre class="kg kh ki kj gt lt lu lv lw aw lx bi"><span id="8adf" class="ly lz iq lu b gy ma mb l mc md">k apply -f ./question-two-pod.yaml --namespace ggckad-s2</span></pre><p id="b6bf" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">最后，我们需要验证我们的工作。</p><h2 id="c7e6" class="ly lz iq bd mm nu nv dn mq nw nx dp mu lf ny nz mw lj oa ob my ln oc od na oe bi translated">验证我们的解决方案</h2><p id="b50b" class="pw-post-body-paragraph kw kx iq ky b kz nc jr lb lc nd ju le lf ne lh li lj nf ll lm ln ng lp lq lr ij bi translated">验证这个解决方案很简单:在第一步中，我们将获得对容器的CLI访问，在第二步中，我们将检查环境。如果已经设置了环境变量，那么我们就完成了。</p><p id="a4e7" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">第一步如下所示:</p><pre class="kg kh ki kj gt lt lu lv lw aw lx bi"><span id="2a0c" class="ly lz iq lu b gy ma mb l mc md">k exec -it question-two-pod -c web --namespace ggckad-s2 -- /bin/sh</span></pre><p id="6e2c" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">第二步可以通过使用<code class="fe nn no np lu b">env</code>命令并目视检查结果来完成。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi of"><img src="../Images/3b144d31069454daf90da3c12f017130.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*QD-7xUBSbXgTX0bB"/></div></div></figure><p id="562e" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这个问题到此为止。</p></div><div class="ab cl me mf hu mg" role="separator"><span class="mh bw bk mi mj mk"/><span class="mh bw bk mi mj mk"/><span class="mh bw bk mi mj"/></div><div class="ij ik il im in"><h1 id="a3e4" class="ml lz iq bd mm mn mo mp mq mr ms mt mu jw mv jx mw jz mx ka my kc mz kd na nb bi translated">问题3。</h1><p id="dada" class="pw-post-body-paragraph kw kx iq ky b kz nc jr lb lc nd ju le lf ne lh li lj nf ll lm ln ng lp lq lr ij bi translated">帕尔默练习考试的第三个问题[1]如下:</p><blockquote class="nh ni nj"><p id="afac" class="kw kx ls ky b kz la jr lb lc ld ju le nk lg lh li nl lk ll lm nm lo lp lq lr ij bi translated">"此问题中的所有操作都应在ggckad-s2命名空间中执行。创建一个有两个容器的pod。两个容器都应该运行<code class="fe nn no np lu b">kubegoldenguide/alpine-spin:1.0.0</code>图像。第一个容器应该以用户ID 1000运行，第二个容器应该以用户ID 2000运行。两个容器都应该使用文件系统组ID 3000。</p></blockquote><p id="c652" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们需要首先按照说明创建名称空间:</p><pre class="kg kh ki kj gt lt lu lv lw aw lx bi"><span id="7371" class="ly lz iq lu b gy ma mb l mc md">k create namespace ggckad-s2</span></pre><p id="41fe" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">下面显示了三个问题的配置文件——查看名称空间声明。这允许我们通过命令行(CLI)应用配置文件，而不包括名称空间；此外，更重要的是，要特别注意<code class="fe nn no np lu b">fsGroup</code>和<code class="fe nn no np lu b">runAsUser</code>键/值对:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nr ns l"/></div></figure><p id="7e10" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们可以如下应用此配置:</p><pre class="kg kh ki kj gt lt lu lv lw aw lx bi"><span id="ffd3" class="ly lz iq lu b gy ma mb l mc md">k apply -f ./question-three-pod.yaml</span></pre><p id="d6c5" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">最后，我们需要验证我们的工作。</p><h2 id="8143" class="ly lz iq bd mm nu nv dn mq nw nx dp mu lf ny nz mw lj oa ob my ln oc od na oe bi translated">验证我们的解决方案</h2><p id="2132" class="pw-post-body-paragraph kw kx iq ky b kz nc jr lb lc nd ju le lf ne lh li lj nf ll lm ln ng lp lq lr ij bi translated">我们需要让CLI访问我们的容器，然后验证设置是否正确。可以使用以下命令来做到这一点:</p><pre class="kg kh ki kj gt lt lu lv lw aw lx bi"><span id="da69" class="ly lz iq lu b gy ma mb l mc md">k exec -it question-three-pod -c alpine-spin-[a or b] --namespace ggckad-s2 -- /bin/sh</span></pre><p id="7c67" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">一旦我们有了访问权限，我们就可以检查<code class="fe nn no np lu b">fsGroup</code>和<code class="fe nn no np lu b">runAsUser</code>键/值对是否设置正确。我们将通过使用<code class="fe nn no np lu b"><a class="ae kv" href="https://man7.org/linux/man-pages/man1/id.1.html" rel="noopener ugc nofollow" target="_blank">id</a></code> <a class="ae kv" href="https://man7.org/linux/man-pages/man1/id.1.html" rel="noopener ugc nofollow" target="_blank">命令</a>来获取这些信息。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi of"><img src="../Images/c56908e76184008b9a4b913b90181840.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*hCebSpE8si-gK9RW"/></div></div></figure><p id="5457" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这个问题到此为止。</p></div><div class="ab cl me mf hu mg" role="separator"><span class="mh bw bk mi mj mk"/><span class="mh bw bk mi mj mk"/><span class="mh bw bk mi mj"/></div><div class="ij ik il im in"><h1 id="0082" class="ml lz iq bd mm mn mo mp mq mr ms mt mu jw mv jx mw jz mx ka my kc mz kd na nb bi translated">问题4。</h1><p id="addd" class="pw-post-body-paragraph kw kx iq ky b kz nc jr lb lc nd ju le lf ne lh li lj nf ll lm ln ng lp lq lr ij bi translated">帕尔默练习考试的第四个问题[1]如下:</p><blockquote class="nh ni nj"><p id="5e37" class="kw kx ls ky b kz la jr lb lc ld ju le nk lg lh li nl lk ll lm nm lo lp lq lr ij bi translated">"此问题中的所有操作都应在ggckad-s4命名空间中执行。这个问题将要求您创建一个运行图像<code class="fe nn no np lu b">kubegoldenguide/question-thirteen</code>的pod。这幅图像是在hub.docker.com的主码头仓库。</p><p id="1642" class="kw kx ls ky b kz la jr lb lc ld ju le nk lg lh li nl lk ll lm nm lo lp lq lr ij bi translated">此映像是一个web服务器，其健康终结点位于“/health”。web服务器监听端口8000。(它运行Python的SimpleHTTPServer。)当应用程序运行正常时，它会返回200状态代码响应。应用程序通常需要60秒才能启动。</p><p id="5afd" class="kw kx ls ky b kz la jr lb lc ld ju le nk lg lh li nl lk ll lm nm lo lp lq lr ij bi translated">创建一个名为question-13-pod的pod来运行这个应用程序，确保定义使用这个健康端点的活动和就绪探测器。"</p></blockquote><p id="6324" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">与之前的问题不同，这个问题明确告诉我们<code class="fe nn no np lu b">kubegoldenguide/question-thirteen image</code>在位于<a class="ae kv" href="https://hub.docker.com/" rel="noopener ugc nofollow" target="_blank">hub.docker.com</a>的主Docker存储库中。根据Kubernetes<a class="ae kv" href="https://kubernetes.io/docs/concepts/containers/images/" rel="noopener ugc nofollow" target="_blank">Images:Image Names</a>文档，“如果您不指定注册表主机名，Kubernetes会认为您指的是Docker公共注册表”，因此对于这个细节不需要采取进一步的措施。</p><p id="feb0" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这个问题特别需要<em class="ls">活跃度</em>和<em class="ls">就绪度</em>探测器，为了方便起见，我们在下面包括了每个探测器的定义。</p><p id="9aec" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">活跃度—“应用程序不再为请求提供服务，K8s将重启有问题的pod”[4]。</p><p id="e421" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">就绪—“应用程序已准备好接收流量”[4]。根据[6]:“如果准备就绪探测失败，端点控制器将从所有匹配Pod的服务的端点中删除Pod的IP地址。”</p><p id="5014" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">根据标题为<a class="ae kv" href="https://kubernetes.io/docs/tasks/configure-pod-container/configure-liveness-readiness-startup-probes/#define-a-liveness-http-request" rel="noopener ugc nofollow" target="_blank">定义活跃度HTTP请求</a>的部分，“任何大于或等于200且小于400的代码都表示成功。”因此，在我们的解决方案中不需要任何操作，因为当应用程序运行正常时，运行在question-thirty容器中的服务器将返回一个HTTP状态响应代码200。</p><p id="e3dc" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在我们提出的解决方案中，我们将添加一个缓冲区，并在75秒时启动<code class="fe nn no np lu b">livenessProbe</code>，这比典型的预期启动时间晚15秒，如问题4中的详细信息所示。15秒的缓冲时间是一个任意选择的数字，假设实际上服务器应该已经启动了；类似的例子出现在[5]中，也可参考[7]和[8]。</p><p id="d245" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">请注意，从Kubernetes 1.16开始，可以定义一个<code class="fe nn no np lu b">startupProbe</code>，以便在返回初始OK之前<code class="fe nn no np lu b">livenessProbe</code>不会启动。</p><p id="4608" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们的吊舱配置可以在这里看到。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nr ns l"/></div></figure><p id="f0d2" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">最后，我们需要验证我们的工作。</p><h2 id="421e" class="ly lz iq bd mm nu nv dn mq nw nx dp mu lf ny nz mw lj oa ob my ln oc od na oe bi translated">验证我们的解决方案</h2><p id="6706" class="pw-post-body-paragraph kw kx iq ky b kz nc jr lb lc nd ju le lf ne lh li lj nf ll lm ln ng lp lq lr ij bi translated">在本例中，我们应该可以看到在pod启动后大约75秒内<code class="fe nn no np lu b">readinessProbe</code>的日志消息，此时我们应该可以看到<em class="ls"/><code class="fe nn no np lu b">readinessProbe</code><em class="ls"/>和<code class="fe nn no np lu b">livenessProbe</code>的日志消息。</p><pre class="kg kh ki kj gt lt lu lv lw aw lx bi"><span id="bd06" class="ly lz iq lu b gy ma mb l mc md">kubectl logs question-13-pod -c question-thirteen --v 4 --namespace ggckad-s4</span></pre><p id="a864" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">不幸的是，这个命令的输出没有告诉我们哪个探测器正在调用端点。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi of"><img src="../Images/d8b99d2e7662c9decd64f54fa71c7258.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*DCD_FutjNkdCq75s"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">问题四验证</p></figure><p id="29dd" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">作为读者的一个练习，我们能准确地确定哪个探测器正在调用健康端点吗？Kubernetes文档似乎表明这是可能的。然而，目前我还没有一个例子来证明这一点。</p><p id="0dec" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这个问题到此为止。</p></div><div class="ab cl me mf hu mg" role="separator"><span class="mh bw bk mi mj mk"/><span class="mh bw bk mi mj mk"/><span class="mh bw bk mi mj"/></div><div class="ij ik il im in"><h1 id="fa34" class="ml lz iq bd mm mn mo mp mq mr ms mt mu jw mv jx mw jz mx ka my kc mz kd na nb bi translated">问题5。</h1><p id="3f30" class="pw-post-body-paragraph kw kx iq ky b kz nc jr lb lc nd ju le lf ne lh li lj nf ll lm ln ng lp lq lr ij bi translated">帕尔默练习考试的第五个问题[1]如下:</p><blockquote class="nh ni nj"><p id="48ae" class="kw kx ls ky b kz la jr lb lc ld ju le nk lg lh li nl lk ll lm nm lo lp lq lr ij bi translated">"此问题中的所有操作都应在ggckad-s5命名空间中执行。创建一个名为question-5.yaml的文件，在ggckad-s5名称空间中声明一个部署，其中有六个副本运行<code class="fe nn no np lu b">nginx:1.7.9</code>映像。</p><p id="592d" class="kw kx ls ky b kz la jr lb lc ld ju le nk lg lh li nl lk ll lm nm lo lp lq lr ij bi translated">每个pod都应该有标签<code class="fe nn no np lu b">app=revproxy</code>。部署应该有标签<code class="fe nn no np lu b">client=user</code>。配置部署，以便在更新部署时，在创建新的pod来替换它们之前，现有的pod会被终止。"</p></blockquote><p id="9bc1" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们需要检查部署和pod的标签，然后我们需要按照[1]“配置部署，以便当部署更新时，在创建新的pod来替换它们之前，现有的pod会被删除。”</p><p id="db60" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们有两种可用的部署策略:<code class="fe nn no np lu b">RollingUpdate</code>(默认)，和<code class="fe nn no np lu b">Recreate</code> [14]。给定<code class="fe nn no np lu b">RollingUpdate</code>和<code class="fe nn no np lu b">Recreate</code>的定义，在这种情况下，我们不想使用默认值，而是需要将<code class="fe nn no np lu b">Recreate</code>分配给<code class="fe nn no np lu b">.spec.strategy.type</code>。</p><p id="985b" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们的部署配置可以在这里看到:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nr ns l"/></div></figure><p id="6e91" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们可以像在上一个问题中一样应用文件:</p><pre class="kg kh ki kj gt lt lu lv lw aw lx bi"><span id="1939" class="ly lz iq lu b gy ma mb l mc md">k apply -f ./question-5.yaml</span></pre><p id="b7a9" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">最后，我们需要验证我们的工作。</p><h2 id="a9e1" class="ly lz iq bd mm nu nv dn mq nw nx dp mu lf ny nz mw lj oa ob my ln oc od na oe bi translated">验证我们的解决方案</h2><p id="52f3" class="pw-post-body-paragraph kw kx iq ky b kz nc jr lb lc nd ju le lf ne lh li lj nf ll lm ln ng lp lq lr ij bi translated">我们需要检查部署和pod的标签，并且我们还需要确保在更新部署时，在创建新的pod来替换它们之前，现有的pod会被删除。</p><p id="91e7" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们可以使用以下命令来查看部署标签:</p><pre class="kg kh ki kj gt lt lu lv lw aw lx bi"><span id="8fcf" class="ly lz iq lu b gy ma mb l mc md">k get deployments --show-labels --namespace ggckad-s5</span></pre><p id="aab8" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们可以使用以下命令来查看各种pod标签:</p><pre class="kg kh ki kj gt lt lu lv lw aw lx bi"><span id="0e23" class="ly lz iq lu b gy ma mb l mc md">k get pods --show-labels --namespace ggckad-s5</span></pre><p id="6f21" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">下面我们可以看到应用<code class="fe nn no np lu b">question-5.yaml</code>文件然后执行这两个命令的输出。黄色箭头表示标签已经按照规格进行了设置:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi og"><img src="../Images/16e16fba3eb33c8d466e8bc017638ea0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*aBmI1SiLvnBhANEb"/></div></div></figure><p id="51f7" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">注意，我们的部署依赖于<code class="fe nn no np lu b">nginx:1.7.9</code>映像。这个映像是旧的，所以如果我们将它更新到<code class="fe nn no np lu b">nginx:latest</code>并再次应用<code class="fe nn no np lu b">question-5.yaml</code>文件，那么我们会看到新的容器被部署，而旧的容器被逐渐终止。下图演示了这种行为:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi of"><img src="../Images/f6b8e0d10591e068f45a07edd3d8a140.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*wAFP3whP9PRKBfv0"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">使用重新创建策略应用部署</p></figure><p id="3ea3" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">接下来，我们重复同样的练习，只是这里我们使用下面的命令[11]检查<code class="fe nn no np lu b">rollout status</code>:</p><pre class="kg kh ki kj gt lt lu lv lw aw lx bi"><span id="da3a" class="ly lz iq lu b gy ma mb l mc md">kubectl rollout status deployment.v1.apps/question-5 --namespace ggckad-s5</span></pre><p id="47cf" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们可以从不同的角度看到，旧的副本正在终止，而新的副本正在开始。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi of"><img src="../Images/40f8c9ab2483cd22e78ee62e167268fe.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*L-gdv9A2cQhdgJSa"/></div></div></figure><p id="f69b" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">最后，我们可以通过执行以下命令来重现相同的行为:</p><pre class="kg kh ki kj gt lt lu lv lw aw lx bi"><span id="5513" class="ly lz iq lu b gy ma mb l mc md">kubectl rollout restart deployment question-5 --namespace ggckad-s5</span></pre><p id="3def" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在这种情况下，我们甚至不需要在<code class="fe nn no np lu b">question-5.yaml file</code>中更新nginx版本。</p><p id="0018" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">让我们看看部署策略类型设置为<code class="fe nn no np lu b">RollingUpdate</code>时的更新。这是默认设置，也是给定规范的错误选择。</p><h2 id="a870" class="ly lz iq bd mm nu nv dn mq nw nx dp mu lf ny nz mw lj oa ob my ln oc od na oe bi translated">不正确的解决方法</h2><p id="bd4b" class="pw-post-body-paragraph kw kx iq ky b kz nc jr lb lc nd ju le lf ne lh li lj nf ll lm ln ng lp lq lr ij bi translated">同样的例子，但是使用<code class="fe nn no np lu b">RollingUpdate</code>部署策略是不正确的。为了便于比较，我们在下面包含了这个例子的输出。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi of"><img src="../Images/ba53df921b46887b4de3beb069361819.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*plxoDxlMX0wtlM8L"/></div></div></figure><p id="8e1a" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">接下来，我们重复同样的练习，只是这里我们使用下面的命令[11]检查<code class="fe nn no np lu b">rollout status</code>:</p><pre class="kg kh ki kj gt lt lu lv lw aw lx bi"><span id="4104" class="ly lz iq lu b gy ma mb l mc md">kubectl rollout status deployment.v1.apps/question-5 --namespace ggckad-s5</span></pre><p id="31e2" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们可以从不同的角度看到，旧的副本正在终止，而新的副本正在开始。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi of"><img src="../Images/a5adb13b794fd62b1434298a35f00ae6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*yxFWA6v2RB4SgpMa"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">Nginx从1.7.9更新到最新版本时的首次展示状态</p></figure><p id="c16d" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这个问题就到此为止，这篇文章也是如此——直到结论！</p></div><div class="ab cl me mf hu mg" role="separator"><span class="mh bw bk mi mj mk"/><span class="mh bw bk mi mj mk"/><span class="mh bw bk mi mj"/></div><div class="ij ik il im in"><h1 id="8372" class="ml lz iq bd mm mn mo mp mq mr ms mt mu jw mv jx mw jz mx ka my kc mz kd na nb bi translated">结论</h1><p id="ce64" class="pw-post-body-paragraph kw kx iq ky b kz nc jr lb lc nd ju le lf ne lh li lj nf ll lm ln ng lp lq lr ij bi translated">这篇文章花了几个小时来写，部分是作为对如何解决这些问题的调查，作为对我学习CKAD考试的介绍。</p><p id="ab34" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">如果你开始准备这个认证的过程，你会发现有几篇好文章提供了关于考试结构和如何为考试学习的指导。我在下面加入了几个链接。</p><p id="57c6" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">如果你有其他有助于准备考试的资源或参考资料，请在评论中注明。</p></div><div class="ab cl me mf hu mg" role="separator"><span class="mh bw bk mi mj mk"/><span class="mh bw bk mi mj mk"/><span class="mh bw bk mi mj"/></div><div class="ij ik il im in"><h1 id="773b" class="ml lz iq bd mm mn mo mp mq mr ms mt mu jw mv jx mw jz mx ka my kc mz kd na nb bi translated">测验和笔记</h1><ol class=""><li id="5839" class="oh oi iq ky b kz nc lc nd lf oj lj ok ln ol lr om on oo op bi translated">参考问题1:当<code class="fe nn no np lu b">alpine-spin-container</code>和<code class="fe nn no np lu b">nginx-container</code> <em class="ls"> </em>都依赖于<code class="fe nn no np lu b">containerPort 80</code>时，为什么我们不需要在<code class="fe nn no np lu b">port-forward</code>命令中包含特定的容器，为了方便起见复制如下？</li><li id="48e4" class="oh oi iq ky b kz oq lc or lf os lj ot ln ou lr om on oo op bi translated">kubectl端口转发pod/pod-b 19999:80-名称空间ggckad-s0</li><li id="6830" class="oh oi iq ky b kz oq lc or lf os lj ot ln ou lr om on oo op bi translated">注意:<code class="fe nn no np lu b">port-forward</code>只允许我们指定pod，不允许我们指定pod +容器。</li><li id="51a7" class="oh oi iq ky b kz oq lc or lf os lj ot ln ou lr om on oo op bi translated">参考问题1:如果我们试图启动pod-b，但我们有两个<code class="fe nn no np lu b">nginx-container</code>而不是<code class="fe nn no np lu b">alpine-spin-container</code>，会发生什么？</li><li id="16a2" class="oh oi iq ky b kz oq lc or lf os lj ot ln ou lr om on oo op bi translated">一个<code class="fe nn no np lu b">Recreate</code>与<code class="fe nn no np lu b">RollingUpdate</code>并列的部署策略有什么区别？</li></ol></div><div class="ab cl me mf hu mg" role="separator"><span class="mh bw bk mi mj mk"/><span class="mh bw bk mi mj mk"/><span class="mh bw bk mi mj"/></div><div class="ij ik il im in"><h1 id="af94" class="ml lz iq bd mm mn mo mp mq mr ms mt mu jw mv jx mw jz mx ka my kc mz kd na nb bi translated">帽尖</h1><p id="e2cc" class="pw-post-body-paragraph kw kx iq ky b kz nc jr lb lc nd ju le lf ne lh li lj nf ll lm ln ng lp lq lr ij bi translated"><a class="ae kv" href="https://www.linkedin.com/in/rishilmalik/" rel="noopener ugc nofollow" target="_blank"> Rishi Malik </a>，<a class="ae kv" href="https://www.linkedin.com/in/ed-macdonald-7037006/" rel="noopener ugc nofollow" target="_blank"> Ed McDonald </a>，<a class="ae kv" href="https://www.linkedin.com/in/aaronfriel/" rel="noopener ugc nofollow" target="_blank"> Aaron弗列尔</a>，<a class="ae kv" href="https://www.linkedin.com/in/scottslowe/" rel="noopener ugc nofollow" target="_blank"> Scott Lowe </a>和<a class="ae kv" href="https://www.linkedin.com/in/sudermanjr/" rel="noopener ugc nofollow" target="_blank"> Andy Suderman </a></p></div><div class="ab cl me mf hu mg" role="separator"><span class="mh bw bk mi mj mk"/><span class="mh bw bk mi mj mk"/><span class="mh bw bk mi mj"/></div><div class="ij ik il im in"><h1 id="b672" class="ml lz iq bd mm mn mo mp mq mr ms mt mu jw mv jx mw jz mx ka my kc mz kd na nb bi translated">参考</h1><ol class=""><li id="bcd2" class="oh oi iq ky b kz nc lc nd lf oj lj ok ln ol lr om on oo op bi translated">【Kubernetes应用程序开发员(CKAD)认证模拟考试</li><li id="52ca" class="oh oi iq ky b kz oq lc or lf os lj ot ln ou lr om on oo op bi translated"><a class="ae kv" href="https://github.com/kelseyhightower/kubernetes-the-hard-way" rel="noopener ugc nofollow" target="_blank">凯尔西高塔/库伯内特斯-艰难的方式</a></li><li id="2fee" class="oh oi iq ky b kz oq lc or lf os lj ot ln ou lr om on oo op bi translated"><a class="ae kv" href="https://kubernetes.io/docs/concepts/services-networking/connect-applications-service/" rel="noopener ugc nofollow" target="_blank">连接应用程序和服务</a></li><li id="67a5" class="oh oi iq ky b kz oq lc or lf os lj ot ln ou lr om on oo op bi translated"><a class="ae kv" href="https://kubernetes.io/docs/tasks/configure-pod-container/configure-liveness-readiness-startup-probes/" rel="noopener ugc nofollow" target="_blank">配置活性、就绪和启动探针</a></li><li id="b789" class="oh oi iq ky b kz oq lc or lf os lj ot ln ou lr om on oo op bi translated"><a class="ae kv" href="https://blog.colinbreck.com/kubernetes-liveness-and-readiness-probes-how-to-avoid-shooting-yourself-in-the-foot/" rel="noopener ugc nofollow" target="_blank"> Kubernetes活跃度和准备度调查:如何避免搬起石头砸自己的脚</a></li><li id="6ebc" class="oh oi iq ky b kz oq lc or lf os lj ot ln ou lr om on oo op bi translated"><a class="ae kv" href="https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle/" rel="noopener ugc nofollow" target="_blank"> Pod生命周期</a></li><li id="077d" class="oh oi iq ky b kz oq lc or lf os lj ot ln ou lr om on oo op bi translated"><a class="ae kv" href="https://cloud.google.com/blog/products/gcp/kubernetes-best-practices-setting-up-health-checks-with-readiness-and-liveness-probes" rel="noopener ugc nofollow" target="_blank"> Kubernetes最佳实践:使用就绪性和活性探测器设置健康检查</a></li><li id="8fd3" class="oh oi iq ky b kz oq lc or lf os lj ot ln ou lr om on oo op bi translated"><a class="ae kv" href="https://kubernetes.io/docs/tasks/configure-pod-container/configure-liveness-readiness-startup-probes/#define-startup-probes" rel="noopener ugc nofollow" target="_blank">用启动探针保护慢启动容器</a></li><li id="03f3" class="oh oi iq ky b kz oq lc or lf os lj ot ln ou lr om on oo op bi translated"><a class="ae kv" href="https://kubernetes.io/docs/tasks/configure-pod-container/configure-liveness-readiness-startup-probes/#define-a-liveness-http-request" rel="noopener ugc nofollow" target="_blank">定义一个活跃度HTTP请求</a></li><li id="9f26" class="oh oi iq ky b kz oq lc or lf os lj ot ln ou lr om on oo op bi translated"><a class="ae kv" href="https://kubernetes.io/docs/tasks/configure-pod-container/configure-pod-configmap/" rel="noopener ugc nofollow" target="_blank">配置Pod以使用配置图</a></li><li id="a0f0" class="oh oi iq ky b kz oq lc or lf os lj ot ln ou lr om on oo op bi translated"><a class="ae kv" href="https://kubernetes.io/docs/concepts/workloads/controllers/deployment/#rollover-aka-multiple-updates-in-flight" rel="noopener ugc nofollow" target="_blank">翻车(也就是飞行中的多次更新)</a></li><li id="5995" class="oh oi iq ky b kz oq lc or lf os lj ot ln ou lr om on oo op bi translated"><a class="ae kv" href="https://blog.container-solutions.com/kubernetes-deployment-strategies" rel="noopener ugc nofollow" target="_blank"> Kubernetes部署策略</a></li><li id="652c" class="oh oi iq ky b kz oq lc or lf os lj ot ln ou lr om on oo op bi translated"><a class="ae kv" href="https://kubernetes.io/docs/concepts/workloads/controllers/deployment/" rel="noopener ugc nofollow" target="_blank">比例缩放</a></li><li id="9da0" class="oh oi iq ky b kz oq lc or lf os lj ot ln ou lr om on oo op bi translated"><a class="ae kv" href="https://kubernetes.io/docs/concepts/workloads/controllers/deployment/#strategy" rel="noopener ugc nofollow" target="_blank">部署:战略</a></li><li id="b69a" class="oh oi iq ky b kz oq lc or lf os lj ot ln ou lr om on oo op bi translated"><a class="ae kv" href="https://github.com/kelseyhightower/kubernetes-the-hard-way" rel="noopener ugc nofollow" target="_blank">苦尽甘来</a></li><li id="dc14" class="oh oi iq ky b kz oq lc or lf os lj ot ln ou lr om on oo op bi translated"><a class="ae kv" href="https://phoenixnap.com/kb/how-to-restart-kubernetes-pods" rel="noopener ugc nofollow" target="_blank">如何重启Kubernetes Pods </a></li></ol></div></div>    
</body>
</html>