<html>
<head>
<title>Cleaner Code With RxJava, Coroutines Kotlin Extensions, and Helper Functions</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">带有RxJava、协同程序Kotlin扩展和帮助函数的更简洁的代码</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/cleaner-code-with-rxjava-coroutines-kotlin-extensions-and-helper-functions-d7b7871cdbc?source=collection_archive---------7-----------------------#2020-12-18">https://betterprogramming.pub/cleaner-code-with-rxjava-coroutines-kotlin-extensions-and-helper-functions-d7b7871cdbc?source=collection_archive---------7-----------------------#2020-12-18</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="7eb3" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">用于Android开发的Kotlinizing RxJava和协程</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/87ff567d3cc2545e3ebba0c7feb1ab66.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*64UE9Y67UZ2RhUfx"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">莎拉·多维勒在<a class="ae kv" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的照片</p></figure><p id="6dda" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在本文中，我将解释我为<a class="ae kv" href="https://github.com/ReactiveX/RxJava" rel="noopener ugc nofollow" target="_blank"> RxJava </a>和<a class="ae kv" href="https://kotlinlang.org/docs/reference/coroutines-overview.html" rel="noopener ugc nofollow" target="_blank">协程</a>编写的一些Kotlin扩展和助手函数，同时将反应模式引入我的Android应用程序。我将假设您对这些库有些熟悉。</p><p id="0ca1" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">对于每个扩展，我将描述用例，如何在没有扩展的情况下实现它，如何使用它，以及将实现首选使用方式的扩展。所以事不宜迟，让我们开始吧。</p></div><div class="ab cl ls lt hu lu" role="separator"><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx"/></div><div class="ij ik il im in"><h1 id="dfba" class="lz ma iq bd mb mc md me mf mg mh mi mj jw mk jx ml jz mm ka mn kc mo kd mp mq bi translated">场景1。带RxJava的房间</h1><p id="a0a0" class="pw-post-body-paragraph kw kx iq ky b kz mr jr lb lc ms ju le lf mt lh li lj mu ll lm ln mv lp lq lr ij bi translated">假设您有一个返回<code class="fe mw mx my mz b">Flowable</code>的房间查询；这是一个典型的用例，使我们能够观察数据库，并在发生更新时采取相应的行动。如果我们只想调用一次房间查询而不观察它，会发生什么呢？当然，我们总是可以用不同的返回类型创建另一个查询，这在某些情况下肯定是可行的，但是如果我们仍然想在这种情况下利用RxJava，我们可以为此编写一个简单的扩展。</p><p id="6008" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">理想情况下，扩展将在成功时返回单个调用结果，并允许失败处理。该扩展的签名如下所示:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="na nb l"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">数据库单次调用签名</p></figure><p id="d6fd" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">如果我们看一下<code class="fe mw mx my mz b">Flowable</code>类，您会注意到有一个名为<code class="fe mw mx my mz b">blockingFirst()</code>的函数，它返回发出的第一个项目。如果它没有发出任何项目，它将抛出一个<code class="fe mw mx my mz b">NoSuchElementException</code> <strong class="ky ir"> </strong>，如果源发出错误信号，它将抛出一个<code class="fe mw mx my mz b">RuntimeException</code> <strong class="ky ir"> </strong>。</p><p id="f7cb" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们可以利用这些信息来编写下面的扩展函数:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="na nb l"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">数据库单次调用扩展功能</p></figure><p id="e2cc" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我将这两种类型的异常分开只是为了强调一个事实，即您可以明确地捕捉到<code class="fe mw mx my mz b">NoSuchElementException</code> <strong class="ky ir"> </strong>。要使用该扩展，我们假设您有一个如下所示的数据库查询:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="na nb l"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">从房间数据库查询中获取所有任务</p></figure><p id="8854" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">要调用这个查询一次而不必观察它，可以像这样使用扩展函数:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="na nb l"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">从房间数据库查询使用情况获取所有任务</p></figure><p id="246f" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">值得一提的是，RxJava在嵌套的本质上有一种固有的丑陋；可以想象，如果逻辑更加复杂，嵌套可能会失控。这个问题可以用协程解决；但是现在，这个扩展将使它比它的直接实现更加简洁。</p></div><div class="ab cl ls lt hu lu" role="separator"><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx"/></div><div class="ij ik il im in"><h1 id="22ba" class="lz ma iq bd mb mc md me mf mg mh mi mj jw mk jx ml jz mm ka mn kc mo kd mp mq bi translated">场景2。使用RxJava进行改造</h1><p id="39bf" class="pw-post-body-paragraph kw kx iq ky b kz mr jr lb lc ms ju le lf mt lh li lj mu ll lm ln mv lp lq lr ij bi translated">如果您曾经将RxJava用于改造网络调用，那么您应该知道RxJava处理HTTP错误(比如404)的方式与处理其他网络错误(比如没有互联网连接)的方式不同，这给您进行的每个网络调用添加了许多样板代码。</p><p id="9012" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">理想情况下，我们应该能够拥有一个接受成功处理程序、失败处理程序和完成处理程序的扩展，这就是我们所关心的。扩展的签名如下所示:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="na nb l"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">RxJava改型扩展签名</p></figure><p id="2ae4" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">请注意，可观察对象拥有一个改进的<code class="fe mw mx my mz b">Response</code>对象，这将是我们包装网络响应对象的对象；这样我们可以识别HTTP错误。我们希望在任何失败(HTTP或网络)发生时调用<code class="fe mw mx my mz b">onFailure</code>，在网络调用后调用<code class="fe mw mx my mz b">onComplete</code>，无论成功与否，如果网络调用成功，则调用<code class="fe mw mx my mz b">onSuccess</code>。</p><p id="f6f5" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">有了这些信息，下面是扩展的样子:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="na nb l"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">RxJava改型扩展实现</p></figure><p id="36f7" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">注意，我们必须在两个地方调用<code class="fe mw mx my mz b">onComplete</code>;那是因为如果发生网络错误的话<code class="fe mw mx my mz b">doOnComplete</code>不会被调用。如果我们得到一个HTTP错误，那么我们可以将响应封装在一个<code class="fe mw mx my mz b">HttpException</code>中，并在<code class="fe mw mx my mz b">onFailure</code>处理程序中使用它。</p><p id="71dc" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在我们作为参数传递的<code class="fe mw mx my mz b">onFailure</code>处理程序之上，我们也可以有一个通用的错误处理程序，看起来像这样:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="na nb l"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">具有通用错误处理器的RxJava改进扩展实现</p></figure><p id="f285" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">要使用这个扩展，让我们假设您有一个<code class="fe mw mx my mz b">getTasks</code> <strong class="ky ir"> </strong> GET请求，比如这个:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="na nb l"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">用RxJava改进GET请求</p></figure><p id="e795" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">现在，要调用这个GET请求，您只需编写以下代码:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="na nb l"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">RxJava改型扩展用法</p></figure><p id="f5b9" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">请注意，如果您选择不关心特定用例的<strong class="ky ir"> </strong> <code class="fe mw mx my mz b">onFailure</code>和<code class="fe mw mx my mz b">onComplete</code>，您可以选择不传递它们。</p></div><div class="ab cl ls lt hu lu" role="separator"><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx"/></div><div class="ij ik il im in"><h1 id="3054" class="lz ma iq bd mb mc md me mf mg mh mi mj jw mk jx ml jz mm ka mn kc mo kd mp mq bi translated">场景3。用协程程序翻新</h1><p id="f59b" class="pw-post-body-paragraph kw kx iq ky b kz mr jr lb lc ms ju le lf mt lh li lj mu ll lm ln mv lp lq lr ij bi translated">如果你想做我们在场景2中做的同样的事情，但是使用协程，我们可以写一个快速助手函数来代替扩展。该函数的签名如下所示:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="na nb l"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">协程改进助手函数签名</p></figure><p id="baa4" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">随着<code class="fe mw mx my mz b">suspend</code> <strong class="ky ir"> </strong>函数的使用，使用协程会干净很多。如您所见，我们不需要传递一个<code class="fe mw mx my mz b">onSuccess</code>处理程序，因为我们可以通过返回值来识别成功；否则我们可以返回<code class="fe mw mx my mz b">null</code>。我们也不需要<code class="fe mw mx my mz b">onComplete</code>处理程序，因为我们在调用之后做的任何事情都是在完成之后。</p><p id="38f8" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这个帮助器函数的实现可能如下所示:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="na nb l"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">协程改进助手函数实现</p></figure><p id="d237" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">使用这种类型的实现，您可以很容易地在此方法中传递的可选错误处理程序之上添加一个通用错误处理程序；也许您想添加一些通用分析，或者您想显示整个应用程序中所有网络错误的Snackbar。添加后，它看起来更像这样:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="na nb l"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">具有通用错误处理器的协程改进助手函数实现</p></figure><p id="3f4b" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">为了使用这个帮助器函数，让我们假设您有一个<code class="fe mw mx my mz b">getTasks</code>改进函数，如下所示:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="na nb l"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">用协程改进GET请求</p></figure><p id="bd9a" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">然后你可以在<code class="fe mw mx my mz b">CoroutineScope</code>中使用它，比如说在<code class="fe mw mx my mz b">ViewModel</code>中，就像这样:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="na nb l"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">在视图模型中使用协程改进GET请求</p></figure><p id="c456" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">作为最后一个想法，我确实意识到RxJava仍然有用，但是我发现在这里使用协程要干净得多，而且也不会受到RxJava的嵌套效应的影响。</p></div><div class="ab cl ls lt hu lu" role="separator"><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx"/></div><div class="ij ik il im in"><p id="467f" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">本文到此为止。我希望你能从中得到一些用处，并帮助你写出更干净的代码。直到下一次，开发咬签出！</p></div></div>    
</body>
</html>