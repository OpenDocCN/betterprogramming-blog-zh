<html>
<head>
<title>13 Tips for Writing Useful Unit Tests</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">编写有用的单元测试的13个技巧</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/13-tips-for-writing-useful-unit-tests-ca20706b5368?source=collection_archive---------0-----------------------#2019-10-07">https://betterprogramming.pub/13-tips-for-writing-useful-unit-tests-ca20706b5368?source=collection_archive---------0-----------------------#2019-10-07</a></blockquote><div><div class="fc ii ij ik il im"/><div class="in io ip iq ir"><div class=""/><div class=""><h2 id="9098" class="pw-subtitle-paragraph jr it iu bd b js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki dk translated">如何编写测试和编写测试一样重要</h2></div><figure class="kk kl km kn gu ko gi gj paragraph-image"><div role="button" tabindex="0" class="kp kq di kr bf ks"><div class="gi gj kj"><img src="../Images/ccdd04d717eb9d35dbc92d3731eb332e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*dCH9EIxT6lh3M_MiZuD3Rg.jpeg"/></div></div><p class="kv kw gk gi gj kx ky bd b be z dk translated">本·穆林斯在<a class="ae kz" href="https://unsplash.com/s/photos/test?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的照片</p></figure><p id="f8f8" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">在<a class="ae kz" href="https://medium.com/better-programming/unit-testing-and-why-you-should-be-doing-it-ab61407c53ce" rel="noopener">我之前的文章</a>中，我提出了你应该对你的代码进行单元测试的案例。我觉得我的理由很充分。</p><p id="e30d" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">在本文中，我将介绍一些关于如何对代码进行单元测试的技巧和提示。开始了。</p></div><div class="ab cl lw lx hy ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="in io ip iq ir"><h1 id="244b" class="md me iu bd mf mg mh mi mj mk ml mm mn ka mo kb mp kd mq ke mr kg ms kh mt mu bi translated">1.孤立地一次测试一件事</h1><p id="0aaf" class="pw-post-body-paragraph la lb iu lc b ld mv jv lf lg mw jy li lj mx ll lm ln my lp lq lr mz lt lu lv in bi translated">这可能是单元测试要遵循的基本规则。所有的类都应该单独测试。他们不应该依赖于除了模仿和存根以外的任何东西。</p><p id="1045" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">他们不应该依赖其他测试的结果。它们应该可以在任何机器上运行。你应该能够在你母亲的计算机上运行你的单元测试可执行文件，即使它还没有连接到互联网。</p></div><div class="ab cl lw lx hy ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="in io ip iq ir"><h1 id="afe6" class="md me iu bd mf mg mh mi mj mk ml mm mn ka mo kb mp kd mq ke mr kg ms kh mt mu bi translated">2.遵循AAA规则:安排、行动、断言</h1><p id="72c8" class="pw-post-body-paragraph la lb iu lc b ld mv jv lf lg mw jy li lj mx ll lm ln my lp lq lr mz lt lu lv in bi translated">说到单元测试，AAA代表<em class="na">安排、行动、断言</em>。这是编写单个测试的通用模式，以使它们更具可读性和有用性。</p><p id="b9aa" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">首先，你安排。在这一步中，您设置要测试的东西。您可以设置变量、字段和属性来运行测试，并定义预期的结果。</p><p id="bbc4" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">然后您采取行动——也就是说，您调用您正在测试的方法。</p><p id="09e2" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">最后，您断言——调用测试框架来验证您的“行为”的结果是预期的。遵循AAA原则，你的测试就会清晰易读。</p></div><div class="ab cl lw lx hy ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="in io ip iq ir"><h1 id="7954" class="md me iu bd mf mg mh mi mj mk ml mm mn ka mo kb mp kd mq ke mr kg ms kh mt mu bi translated">3.首先编写简单的“中间快速投球”测试</h1><p id="5f0c" class="pw-post-body-paragraph la lb iu lc b ld mv jv lf lg mw jy li lj mx ll lm ln my lp lq lr mz lt lu lv in bi translated">你写的第一个测试应该是最简单的——快乐之路。它们应该是那些能够简单快速地说明你要写的功能的东西。</p><p id="6a22" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">如果您正在编写加法算法，您编写的早期测试应该确保您的代码可以执行2 + 2 = 4。然后，一旦这些测试通过，您应该开始编写更复杂的测试(如下所述),测试代码的边缘和边界。</p></div><div class="ab cl lw lx hy ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="in io ip iq ir"><h1 id="2b3d" class="md me iu bd mf mg mh mi mj mk ml mm mn ka mo kb mp kd mq ke mr kg ms kh mt mu bi translated">4.跨边界测试</h1><p id="719c" class="pw-post-body-paragraph la lb iu lc b ld mv jv lf lg mw jy li lj mx ll lm ln my lp lq lr mz lt lu lv in bi translated">单元测试应该测试给定边界的两边。如果您正在为日期和时间实用程序构建一些测试，请尝试在午夜前一秒和午夜后一秒进行测试。检查日期值是否为0.0。</p><p id="4ec5" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">如果您正在处理一个包含矩形的结构，那么测试矩形内外的点会发生什么。上面或者下面呢？向左还是向右？右上方？在左下方？</p><p id="6198" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">跨越边界是代码可能失败或以不可预知的方式执行的地方。</p></div><div class="ab cl lw lx hy ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="in io ip iq ir"><h1 id="c8ce" class="md me iu bd mf mg mh mi mj mk ml mm mn ka mo kb mp kd mq ke mr kg ms kh mt mu bi translated">5.如果可以的话，测试整个光谱</h1><p id="cf6d" class="pw-post-body-paragraph la lb iu lc b ld mv jv lf lg mw jy li lj mx ll lm ln my lp lq lr mz lt lu lv in bi translated">如果可行，测试你的功能的所有可能性。如果它涉及枚举类型，请用枚举中的每一项测试功能。</p><p id="be5c" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">检查每一个可能的字符串或每一个整数可能不切实际，但是如果你能测试每一种可能性，那就去做吧。</p></div><div class="ab cl lw lx hy ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="in io ip iq ir"><h1 id="5a13" class="md me iu bd mf mg mh mi mj mk ml mm mn ka mo kb mp kd mq ke mr kg ms kh mt mu bi translated">6.如果可能的话，覆盖每一条代码路径</h1><p id="3d23" class="pw-post-body-paragraph la lb iu lc b ld mv jv lf lg mw jy li lj mx ll lm ln my lp lq lr mz lt lu lv in bi translated">这也是一个挑战，但是如果你的代码是为测试而设计的，并且你使用了代码覆盖工具，你可以确保你的每一行代码至少被单元测试覆盖一次。</p><p id="eb19" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">如果你选择的语言有一个代码覆盖工具，在你的单元测试中使用它。覆盖每一条代码路径并不能保证没有任何错误，但是它肯定会给你关于每一行代码状态的有价值的信息。</p></div><div class="ab cl lw lx hy ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="in io ip iq ir"><h1 id="c7cc" class="md me iu bd mf mg mh mi mj mk ml mm mn ka mo kb mp kd mq ke mr kg ms kh mt mu bi translated">7.编写测试来揭示错误，然后修复它</h1><p id="4c3b" class="pw-post-body-paragraph la lb iu lc b ld mv jv lf lg mw jy li lj mx ll lm ln my lp lq lr mz lt lu lv in bi translated">这是一种强大而有用的技术。如果你发现了一个bug，写一个测试来揭示它。然后，您可以通过调试测试来快速修复bug。</p><p id="4b4f" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">然后，您有一个优秀的回归测试来确保如果该bug因为任何原因再次出现，您将立即知道。当您在调试器中运行一个简单、直接的测试时，修复一个bug是很容易的。</p><p id="efbc" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">这里的一个附带好处是你已经“测试了你的测试”。因为您已经看到测试失败，然后又看到它通过，所以您知道测试是有效的，因为它已经被证明正确地工作。这使得它成为一个更好的回归测试。</p></div><div class="ab cl lw lx hy ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="in io ip iq ir"><h1 id="3f7c" class="md me iu bd mf mg mh mi mj mk ml mm mn ka mo kb mp kd mq ke mr kg ms kh mt mu bi translated">8.使每个测试独立</h1><p id="ca54" class="pw-post-body-paragraph la lb iu lc b ld mv jv lf lg mw jy li lj mx ll lm ln my lp lq lr mz lt lu lv in bi translated">测试不应该互相依赖。如果您的测试必须以特定的顺序运行，那么您需要改变您的测试。</p><p id="3d6c" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">相反，您应该正确使用单元测试框架的<code class="fe nb nc nd ne b">Setup</code> <strong class="lc iv"> </strong>和<code class="fe nb nc nd ne b">TearDown</code> <strong class="lc iv"> </strong>特性，以确保每个测试都准备好单独运行。</p><p id="4f2b" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">单元测试框架不保证测试会以任何特定的顺序运行。如果您的测试依赖于以特定顺序运行的测试，那么您可能会发现自己在测试中有一些微妙的、难以追踪的错误。</p><p id="76aa" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">确保每个测试都是独立的，你就不会有这个问题。</p></div><div class="ab cl lw lx hy ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="in io ip iq ir"><h1 id="4f9d" class="md me iu bd mf mg mh mi mj mk ml mm mn ka mo kb mp kd mq ke mr kg ms kh mt mu bi translated">9.清楚地命名你的测试，不要害怕长名字</h1><p id="a756" class="pw-post-body-paragraph la lb iu lc b ld mv jv lf lg mw jy li lj mx ll lm ln my lp lq lr mz lt lu lv in bi translated">因为您在每个测试中做一个断言，所以每个测试可能会非常具体。因此，不要犹豫使用一个长的、完整的测试名。有<code class="fe nb nc nd ne b">TestDivisionWhenNumPositiveDenomNegative</code>比有<code class="fe nb nc nd ne b">DivisionTest3</code>好。</p><p id="1abc" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">一个长的、完整的名字可以让你立即知道哪个测试失败了，以及这个测试到底想做什么。名称清晰的长测试也可以记录你的测试。</p><p id="2330" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">例如，一个名为<code class="fe nb nc nd ne b">DivisionByZeroShouldThrowException</code>的测试精确记录了当你试图除以零时代码做了什么。</p></div><div class="ab cl lw lx hy ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="in io ip iq ir"><h1 id="5ff8" class="md me iu bd mf mg mh mi mj mk ml mm mn ka mo kb mp kd mq ke mr kg ms kh mt mu bi translated">10.测试是否引发了每个引发的异常</h1><p id="711c" class="pw-post-body-paragraph la lb iu lc b ld mv jv lf lg mw jy li lj mx ll lm ln my lp lq lr mz lt lu lv in bi translated">如果您的代码引发异常，那么编写测试来确保您引发的每个异常都在应该引发的时候被引发。</p><p id="d808" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">大多数xUnit测试框架可以测试正在引发的异常，所以您应该使用该特性来确保您的代码引发的每个异常确实是在适当的情况下引发的。</p></div><div class="ab cl lw lx hy ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="in io ip iq ir"><h1 id="2809" class="md me iu bd mf mg mh mi mj mk ml mm mn ka mo kb mp kd mq ke mr kg ms kh mt mu bi translated">11.避免使用Assert。伊斯特鲁</h1><p id="6d7b" class="pw-post-body-paragraph la lb iu lc b ld mv jv lf lg mw jy li lj mx ll lm ln my lp lq lr mz lt lu lv in bi translated">避免检查布尔条件。</p><p id="7e83" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">例如，不要用<code class="fe nb nc nd ne b">Assert.IsTrue</code>来检查两个东西是否相等，而是用<code class="fe nb nc nd ne b">Assert.AreEqual</code>来代替。为什么？因为这个:</p><pre class="kk kl km kn gu nf ne ng nh aw ni bi"><span id="6854" class="nj me iu ne b gz nk nl l nm nn">Assert.IsTrue(Expected = Actual);</span></pre><p id="f6ed" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">会举报类似<code class="fe nb nc nd ne b">Some test failed: Expected True, but the actual result was False</code>的事情。这说明不了什么。相反，使用<code class="fe nb nc nd ne b">Assert.AreEqual</code>:</p><pre class="kk kl km kn gu nf ne ng nh aw ni bi"><span id="9f01" class="nj me iu ne b gz nk nl l nm nn">Assert.AreEqual(Expected, Actual)</span></pre><p id="a64f" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">它会告诉你所涉及的实际值，比如<em class="na"> </em> <code class="fe nb nc nd ne b">Some test failed: Expected 7, but the actual result was 3</code> <em class="na">，</em>哪个作为错误信息更有价值。</p></div><div class="ab cl lw lx hy ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="in io ip iq ir"><h1 id="e2a3" class="md me iu bd mf mg mh mi mj mk ml mm mn ka mo kb mp kd mq ke mr kg ms kh mt mu bi translated">12.不断运行您的测试</h1><p id="0f74" class="pw-post-body-paragraph la lb iu lc b ld mv jv lf lg mw jy li lj mx ll lm ln my lp lq lr mz lt lu lv in bi translated">在编写代码的同时运行测试。您的测试应该运行得很快，使您能够在即使很小的更改后运行它们。</p><p id="1b2f" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">如果您不能将测试作为正常开发过程的一部分来运行，那么一定是出了问题——单元测试应该几乎立即运行。如果不是，那可能是因为你没有孤立地运行它们。</p></div><div class="ab cl lw lx hy ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="in io ip iq ir"><h1 id="b526" class="md me iu bd mf mg mh mi mj mk ml mm mn ka mo kb mp kd mq ke mr kg ms kh mt mu bi translated">13.作为每个自动化构建的一部分运行您的测试</h1><p id="0d64" class="pw-post-body-paragraph la lb iu lc b ld mv jv lf lg mw jy li lj mx ll lm ln my lp lq lr mz lt lu lv in bi translated">正如您应该在开发时运行测试一样，它们也应该是您持续集成过程中不可或缺的一部分。失败的测试应该意味着你的构建被破坏了。</p><p id="89f3" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">不要让失败的测试徘徊不前——将它视为构建失败，并立即修复它。</p></div><div class="ab cl lw lx hy ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="in io ip iq ir"><h1 id="d4e5" class="md me iu bd mf mg mh mi mj mk ml mm mn ka mo kb mp kd mq ke mr kg ms kh mt mu bi translated">结论</h1><p id="2283" class="pw-post-body-paragraph la lb iu lc b ld mv jv lf lg mw jy li lj mx ll lm ln my lp lq lr mz lt lu lv in bi translated">有13种方法可以写出有用的单元测试。请记住，除非您正在编写单元测试，否则您的代码将难以维护和修复。写得好的、全面的单元测试是一个巨大的胜利。</p></div></div>    
</body>
</html>