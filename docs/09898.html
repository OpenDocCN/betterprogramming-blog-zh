<html>
<head>
<title>Understanding Swift 5.5 Task Groups</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">了解Swift 5.5任务组</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/understanding-swift-5-5-task-groups-f49fe7c5f873?source=collection_archive---------5-----------------------#2021-10-27">https://betterprogramming.pub/understanding-swift-5-5-task-groups-f49fe7c5f873?source=collection_archive---------5-----------------------#2021-10-27</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="0b01" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">在您的iOS模块中创建子任务并有效收集结果</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/a8ee0a6f1737f119ddda3b6eed4b5ce2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*MUoU2T3vkxoSROCc"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">由<a class="ae ky" href="https://unsplash.com/@element5digital?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Element5数码</a>在<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</p></figure><p id="d809" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">苹果在Swift 5.5中引入了任务组，作为Swift并发框架的重要组成部分之一。顾名思义，任务组是并发运行的子任务的集合，只有当它的所有子任务完成执行时，它才会返回。</p><p id="e96f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在本文中，我将向您展示如何创建一个任务组，向任务组添加子任务，并从所有子任务中收集结果。涉及的话题太多了，让我们开始吧。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="d8da" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">做好准备</h1><p id="055e" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">像往常一样，我将使用一些样本代码来解释并帮助您理解任务组在Swift中是如何工作的。在深入研究任务组之前，让我们首先定义一个贯穿本文的操作结构。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mz na l"/></div></figure><p id="0063" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe nb nc nd ne b">SlowDivideOperation</code>是一个简单的结构，它包含一个基于给定数字执行除法运算的<code class="fe nb nc nd ne b">execute()</code>函数。请注意，我故意让它在除数之前休眠一段时间来降低执行速度。</p><p id="5362" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这使我们能够很好地控制除法运算应该执行多长时间。因此，允许我们容易地观察当多个<code class="fe nb nc nd ne b">SlowDivideOperation</code>在一个任务组中同时运行时会发生什么。</p><p id="ee1d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">说完这些，让我们直接进入任务组。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="f7ec" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">任务组行为</h1><p id="3fbb" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">为了让我们能够正确使用任务组，我们需要了解一些任务组行为:</p><ol class=""><li id="f324" class="nf ng it lb b lc ld lf lg li nh lm ni lq nj lu nk nl nm nn bi translated">任务组由一组相互独立的异步任务(子任务)组成。</li><li id="3fd9" class="nf ng it lb b lc no lf np li nq lm nr lq ns lu nk nl nm nn bi translated">添加到任务组的所有子任务开始自动并发运行。</li><li id="3d8d" class="nf ng it lb b lc no lf np li nq lm nr lq ns lu nk nl nm nn bi translated">我们无法控制子任务何时完成执行。因此，<strong class="lb iu">如果我们希望子任务以特定的顺序完成</strong>，我们就不应该使用任务组。</li><li id="99e7" class="nf ng it lb b lc no lf np li nq lm nr lq ns lu nk nl nm nn bi translated">任务组仅在其所有子任务完成执行时返回。换句话说，一个任务组的所有子任务只能存在于其任务组的范围内。</li><li id="16ff" class="nf ng it lb b lc no lf np li nq lm nr lq ns lu nk nl nm nn bi translated">任务组可以通过返回值、返回void(非返回值)或抛出错误来退出。</li></ol><p id="5453" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">既然您已经了解了任务组的行为，是时候编写一些Swift代码了。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="6da9" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">创建任务组</h1><p id="6e1a" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">要创建任务组，我们可以使用Swift 5.5中引入的<code class="fe nb nc nd ne b">withTaskGroup(of:returning:body:)</code>或<code class="fe nb nc nd ne b">withThrowingTaskGroup(of:returning:body:)</code>功能。因为我们想要创建的任务组不会抛出任何错误，所以我们将在示例代码中使用<code class="fe nb nc nd ne b">withTaskGroup(of:returning:body:)</code>变体。当被调用时，它采用以下形式:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nt"><img src="../Images/ba574bda705667b3bd2ce0d0d3b0d773.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*SGhSbChfCJo4RaI3"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">使用TaskGroup调用(的:返回:正文:)</p></figure><p id="46fe" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在我们的例子中，我们将创建一个任务组，它产生多个子任务，这些子任务执行一个<code class="fe nb nc nd ne b">SlowDivideOperation</code>并返回它的名称和结果。当所有的<code class="fe nb nc nd ne b">SlowDivideOperation</code>完成后，任务组将收集其所有的子任务结果，并返回一个包含所有<code class="fe nb nc nd ne b">SlowDivideOperation</code>名称和结果的字典。</p><p id="c8ab" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">考虑到这一点，我们可以使用如下函数创建一个任务组:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mz na l"/></div></figure><p id="c427" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">注意，任务组的一个实例作为<code class="fe nb nc nd ne b">body</code>闭包的一个参数给了我们。在下一节中，我们将看看如何利用这个任务组实例来生成多个并发运行的子任务。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="8f10" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">行动中的任务组</h1><p id="ed7e" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">假设我们有一个如下所示的<code class="fe nb nc nd ne b">SlowDivideOperation</code>数组:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mz na l"/></div></figure><p id="c4e9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">然后，我们可以通过遍历<code class="fe nb nc nd ne b">operations</code>数组向任务组添加子任务:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mz na l"/></div></figure><p id="af0b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">值得一提的是，我们在子任务操作闭包中返回了一个由<code class="fe nb nc nd ne b">String</code>和<code class="fe nb nc nd ne b">Double</code>组成的元组，它与我们之前设置的子任务结果数据类型相匹配。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nt"><img src="../Images/1bce7212046ce263baf3c8df1bef1d73.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*Zh8MoK5f7pklLGz_"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">匹配子任务返回类型</p></figure><p id="017a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如前所述，所有子任务将并发运行，我们无法控制它们何时结束运行。为了收集每个子任务的结果，我们必须像这样遍历任务组:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mz na l"/></div></figure><p id="d987" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">注意，我们在循环时使用了关键字<code class="fe nb nc nd ne b">await</code>来表示<code class="fe nb nc nd ne b">for</code>循环可能会在等待子任务完成时挂起。每次子任务返回时，<code class="fe nb nc nd ne b">for</code>循环都会迭代更新<code class="fe nb nc nd ne b">childTaskResults</code>字典。</p><p id="d55e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">一旦所有子任务执行完毕，<code class="fe nb nc nd ne b">for</code>循环将退出并返回任务组结果。您可能已经注意到，<code class="fe nb nc nd ne b">childTaskResults</code>的数据类型必须与我们之前设置的任务组结果类型相匹配。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nt"><img src="../Images/1e3626d444b7dee13197f15e194ab680.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*8bpnOpClZM3gzwlR"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">匹配任务组结果类型</p></figure><blockquote class="nu nv nw"><p id="510a" class="kz la nx lb b lc ld ju le lf lg jx lh ny lj lk ll nz ln lo lp oa lr ls lt lu im bi translated"><strong class="lb iu">亲提示:</strong></p><p id="1b08" class="kz la nx lb b lc ld ju le lf lg jx lh ny lj lk ll nz ln lo lp oa lr ls lt lu im bi translated">如果有不返回值的任务组或子任务，使用<code class="fe nb nc nd ne b">Void.self</code>作为结果类型。</p></blockquote><p id="b159" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在使用我们的示例代码之前，让我们在触发任务组之前和之后添加一些打印语句，以检查最终结果和执行所有子任务所需的时间。下面是完整的示例代码:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mz na l"/></div></figure><p id="c287" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果我们尝试执行上面的代码，我们得到的输出将是这样的:</p><pre class="kj kk kl km gt ob ne oc od aw oe bi"><span id="05f5" class="of md it ne b gy og oh l oi oj">Task start   : 2021-10-23 05:53:15 +0000<br/>Task end     : 2021-10-23 05:53:20 +0000<br/>allResults   : ["operation-1": 2.0, "operation-2": 4.0, "operation-0": 5.0]</span></pre><p id="5541" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如您所见，整个任务组花了5s才完成。事实上，5s也等于所有<code class="fe nb nc nd ne b">SlowDivideOperation</code>中最长的睡眠持续时间，这表明所有子任务实际上是并发运行的。</p><p id="54c2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果您看一下<code class="fe nb nc nd ne b">allResults</code>，您会注意到它包含了所有子任务的结果。这进一步证明了一个任务组只有在它的所有子任务完成运行时才返回。这也表明子任务只能存在于任务组的上下文中。</p><p id="e95a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果您想试用本文中的示例代码，您可以在这里获得它<a class="ae ky" href="https://github.com/LeeKahSeng/SwiftSenpai-Swift-Concurrency" rel="noopener ugc nofollow" target="_blank">。</a></p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="a539" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">包扎</h1><p id="b2f6" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">在本文中，我向您展示了如何创建任务组，如何向任务组添加子任务，以及如何从任务组的子任务中收集结果。在我的下一篇文章中，我将讨论任务组中的错误处理。敬请期待！</p><p id="d5e1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">欢迎在<a class="ae ky" href="https://twitter.com/Lee_Kah_Seng" rel="noopener ugc nofollow" target="_blank"> Twitter </a>上关注我，这样你就不会错过我即将发布的任何与iOS开发相关的文章。</p><p id="d150" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">感谢阅读。</p></div></div>    
</body>
</html>