<html>
<head>
<title>Dependency Injection in Android With Dagger2</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Android中的依赖注入与Dagger2</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/dependency-injection-in-android-with-dagger2-d260b8a72bb0?source=collection_archive---------1-----------------------#2019-11-15">https://betterprogramming.pub/dependency-injection-in-android-with-dagger2-d260b8a72bb0?source=collection_archive---------1-----------------------#2019-11-15</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="a121" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">了解你需要知道的关于Dagger2的一切</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/6a45ea3e425a96de5c3f55eed2b3beaa.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*fyncpC8sDmSyGQo0"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">图片由<a class="ae ky" href="https://unsplash.com/@nesabymakers?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> NESA制作</a>在<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</p></figure><ol class=""><li id="3643" class="kz la it lb b lc ld le lf lg lh li lj lk ll lm ln lo lp lq bi translated"><a class="ae ky" href="#f0d1" rel="noopener ugc nofollow">什么是依赖注入？</a></li><li id="37c4" class="kz la it lb b lc lr le ls lg lt li lu lk lv lm ln lo lp lq bi translated"><a class="ae ky" href="#3d94" rel="noopener ugc nofollow">依赖注入的类型</a></li><li id="2c69" class="kz la it lb b lc lr le ls lg lt li lu lk lv lm ln lo lp lq bi translated"><a class="ae ky" href="http://62c4" rel="noopener ugc nofollow" target="_blank">为您的应用选择正确的技术</a></li><li id="2b40" class="kz la it lb b lc lr le ls lg lt li lu lk lv lm ln lo lp lq bi translated"><a class="ae ky" href="#85dc" rel="noopener ugc nofollow">Android中的依赖注入</a></li><li id="2dbd" class="kz la it lb b lc lr le ls lg lt li lu lk lv lm ln lo lp lq bi translated"><a class="ae ky" href="#3ca9" rel="noopener ugc nofollow">匕首的历史及其优点</a></li><li id="7d6d" class="kz la it lb b lc lr le ls lg lt li lu lk lv lm ln lo lp lq bi translated"><a class="ae ky" href="#b853" rel="noopener ugc nofollow">术语</a></li><li id="cd0c" class="kz la it lb b lc lr le ls lg lt li lu lk lv lm ln lo lp lq bi translated"><a class="ae ky" href="#4221" rel="noopener ugc nofollow">整合</a></li><li id="4fa3" class="kz la it lb b lc lr le ls lg lt li lu lk lv lm ln lo lp lq bi translated"><a class="ae ky" href="#9fca" rel="noopener ugc nofollow"> Dagger2设置</a></li><li id="0525" class="kz la it lb b lc lr le ls lg lt li lu lk lv lm ln lo lp lq bi translated"><a class="ae ky" href="#ef07" rel="noopener ugc nofollow">用法</a></li><li id="b92c" class="kz la it lb b lc lr le ls lg lt li lu lk lv lm ln lo lp lq bi translated"><a class="ae ky" href="#ea82" rel="noopener ugc nofollow">多模块应用程序中的dagger 2</a></li><li id="8676" class="kz la it lb b lc lr le ls lg lt li lu lk lv lm ln lo lp lq bi translated"><a class="ae ky" href="#e9c2" rel="noopener ugc nofollow">有用链接</a></li></ol></div><div class="ab cl lw lx hx ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="im in io ip iq"><h1 id="f0d1" class="md me it bd mf mg mh mi mj mk ml mm mn jz mo ka mp kc mq kd mr kf ms kg mt mu bi translated">什么是依赖注入？</h1><p id="e52a" class="pw-post-body-paragraph mv mw it lb b lc mx ju my le mz jx na lg nb nc nd li ne nf ng lk nh ni nj lm im bi translated">依赖注入是类获取其他类的引用的另一种方式。例如，有一个类<code class="fe nk nl nm nn b">BananaMilkshake</code>，它可能需要<code class="fe nk nl nm nn b">Milk</code>类。在这里，<code class="fe nk nl nm nn b">BananaMilkShake</code>依赖于<code class="fe nk nl nm nn b">Milk</code>类。通常这些必需的类，像<code class="fe nk nl nm nn b">Milk</code>，被称为依赖。</p><p id="0faf" class="pw-post-body-paragraph mv mw it lb b lc ld ju my le lf jx na lg no nc nd li np nf ng lk nq ni nj lm im bi translated">实现依赖注入为您提供了以下优势:</p><ul class=""><li id="0f2a" class="kz la it lb b lc ld le lf lg lh li lj lk ll lm nr lo lp lq bi translated">代码的可重用性</li><li id="52aa" class="kz la it lb b lc lr le ls lg lt li lu lk lv lm nr lo lp lq bi translated">易于重构</li><li id="cfc7" class="kz la it lb b lc lr le ls lg lt li lu lk lv lm nr lo lp lq bi translated">易于测试</li></ul><p id="b39b" class="pw-post-body-paragraph mv mw it lb b lc ld ju my le lf jx na lg no nc nd li np nf ng lk nq ni nj lm im bi translated">依赖注入有三种类型</p><ol class=""><li id="164e" class="kz la it lb b lc ld le lf lg lh li lj lk ll lm ln lo lp lq bi translated">在类本身中创建所需的对象(类似于在<code class="fe nk nl nm nn b">BananaMilkshake</code>类中创建的<code class="fe nk nl nm nn b">Milk</code>类对象)。</li><li id="3b0d" class="kz la it lb b lc lr le ls lg lt li lu lk lv lm ln lo lp lq bi translated">从其他地方获取所需的对象(比如Android-activity组件中的上下文)。</li><li id="61fb" class="kz la it lb b lc lr le ls lg lt li lu lk lv lm ln lo lp lq bi translated">提供所需的类对象作为参数(可以通过构造函数来创建)。</li></ol></div><div class="ab cl lw lx hx ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="im in io ip iq"><h1 id="3d94" class="md me it bd mf mg mh mi mj mk ml mm mn jz mo ka mp kc mq kd mr kf ms kg mt mu bi translated">依赖注入的类型</h1><h2 id="d548" class="ns me it bd mf nt nu dn mj nv nw dp mn lg nx ny mp li nz oa mr lk ob oc mt od bi translated">手动依赖注入</h2><p id="ef48" class="pw-post-body-paragraph mv mw it lb b lc mx ju my le mz jx na lg nb nc nd li ne nf ng lk nh ni nj lm im bi translated">让我们以上面的例子为例，看看在没有依赖注入的情况下它是如何工作的。看一看:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oe of l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">手动依赖注入</p></figure><p id="78ef" class="pw-post-body-paragraph mv mw it lb b lc ld ju my le lf jx na lg no nc nd li np nf ng lk nq ni nj lm im bi translated">这似乎很容易做到，因为这是一个简单的例子。</p><p id="f536" class="pw-post-body-paragraph mv mw it lb b lc ld ju my le lf jx na lg no nc nd li np nf ng lk nq ni nj lm im bi translated">这里的<code class="fe nk nl nm nn b">BananaMilkshake</code>和<code class="fe nk nl nm nn b">Milk</code>类是紧密耦合的，这在编程世界中不是一件好事。<code class="fe nk nl nm nn b">BananaMilkshake</code>在测试的时候对<code class="fe nk nl nm nn b">Milk</code> <strong class="lb iu"> </strong>也有依赖，这就很难了。</p><p id="f406" class="pw-post-body-paragraph mv mw it lb b lc ld ju my le lf jx na lg no nc nd li np nf ng lk nq ni nj lm im bi translated">当它变得复杂时怎么办——比如当<code class="fe nk nl nm nn b">BananaMilkshake</code>需要多个类时，如下所示:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oe of l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">复杂情况下的手动依赖注入</p></figure><p id="21f0" class="pw-post-body-paragraph mv mw it lb b lc ld ju my le lf jx na lg no nc nd li np nf ng lk nq ni nj lm im bi translated">是不是显得势不可挡？在实时情况下会更复杂。</p><h2 id="6d66" class="ns me it bd mf nt nu dn mj nv nw dp mn lg nx ny mp li nz oa mr lk ob oc mt od bi translated">手动依赖注入的替代方法</h2><p id="b8ab" class="pw-post-body-paragraph mv mw it lb b lc mx ju my le mz jx na lg nb nc nd li ne nf ng lk nh ni nj lm im bi translated">基本上，我们在这里做的是创建所有类都可用的更高级别的类，创建我们在其中需要的所有对象，并在需要时从不同的类访问它们。看一看:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oe of l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">手动依赖注入</p></figure><p id="bc88" class="pw-post-body-paragraph mv mw it lb b lc ld ju my le lf jx na lg no nc nd li np nf ng lk nq ni nj lm im bi translated">下面是我们所做的:我们有一个a对象类，<code class="fe nk nl nm nn b">ServiceGenerater</code>，在其中我们创建了我们需要的所有对象，当<code class="fe nk nl nm nn b">BananaMilkshake</code>需要<code class="fe nk nl nm nn b">Milk</code>类时，它只是从<code class="fe nk nl nm nn b">ServiceGenerater</code>中获取对象。</p><p id="7973" class="pw-post-body-paragraph mv mw it lb b lc ld ju my le lf jx na lg no nc nd li np nf ng lk nq ni nj lm im bi translated">服务生成器的问题:</p><ol class=""><li id="d911" class="kz la it lb b lc ld le lf lg lh li lj lk ll lm ln lo lp lq bi translated">维护生存期对象很困难，这可能会导致在某个时候崩溃。</li><li id="fe83" class="kz la it lb b lc lr le ls lg lt li lu lk lv lm ln lo lp lq bi translated">这也使得测试变得复杂，因为所有的依赖都应该来自一个类。</li><li id="495d" class="kz la it lb b lc lr le ls lg lt li lu lk lv lm ln lo lp lq bi translated">我们无法维持对象的范围。</li></ol><h2 id="6cd2" class="ns me it bd mf nt nu dn mj nv nw dp mn lg nx ny mp li nz oa mr lk ob oc mt od bi translated">依赖注入</h2><p id="bc34" class="pw-post-body-paragraph mv mw it lb b lc mx ju my le mz jx na lg nb nc nd li ne nf ng lk nh ni nj lm im bi translated">有两种方法可以通过DI。</p><ul class=""><li id="7a86" class="kz la it lb b lc ld le lf lg lh li lj lk ll lm nr lo lp lq bi translated"><strong class="lb iu">构造函数注入:</strong>通过这种方式，我们可以在构造函数中传递所有需要类的对象，并使用它们。看一看:</li></ul><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oe of l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">构造函数注入</p></figure><ul class=""><li id="efe7" class="kz la it lb b lc ld le lf lg lh li lj lk ll lm nr lo lp lq bi translated"><strong class="lb iu">字段注入(或者setter注入):</strong>某些Android框架类，比如activities和fragments，是由系统实例化的，所以构造函数注入是不可能的。</li><li id="520b" class="kz la it lb b lc lr le ls lg lt li lu lk lv lm nr lo lp lq bi translated">使用字段注入，依赖关系在类创建后被实例化。代码应该是这样的:</li></ul><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oe of l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">现场注射</p></figure></div><div class="ab cl lw lx hx ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="im in io ip iq"><h1 id="62c4" class="md me it bd mf mg mh mi mj mk ml mm mn jz mo ka mp kc mq kd mr kf ms kg mt mu bi translated">为您的应用选择正确的技术</h1><p id="3473" class="pw-post-body-paragraph mv mw it lb b lc mx ju my le mz jx na lg nb nc nd li ne nf ng lk nh ni nj lm im bi translated">如上所述，我们有不同类型的方法来实现依赖注入。</p><p id="b07b" class="pw-post-body-paragraph mv mw it lb b lc ld ju my le lf jx na lg no nc nd li np nf ng lk nq ni nj lm im bi translated">正如Android团队建议的那样，如果你的应用程序包含三个或更少的屏幕，你可以不进行依赖注入。但是超过三个屏幕时，总是推荐使用依赖注入。</p><p id="0252" class="pw-post-body-paragraph mv mw it lb b lc ld ju my le lf jx na lg no nc nd li np nf ng lk nq ni nj lm im bi translated">如果您对DI提供的功能有深入的了解，那么选择它会更容易</p><ul class=""><li id="e9a4" class="kz la it lb b lc ld le lf lg lh li lj lk ll lm nr lo lp lq bi translated"><strong class="lb iu">可重用性:</strong>随着项目的扩展，创建依赖关系的多个实现将变得更加容易，但是有了DI反转控制，依赖类不再控制依赖关系的创建方式</li><li id="5007" class="kz la it lb b lc lr le ls lg lt li lu lk lv lm nr lo lp lq bi translated"><strong class="lb iu">易于重构:</strong>依赖对象的创建可以在编译时检查，而不是在运行时隐藏。</li><li id="25a0" class="kz la it lb b lc lr le ls lg lt li lu lk lv lm nr lo lp lq bi translated"><strong class="lb iu">易于测试:</strong>有了DI，它将不再是一个产生依赖的类，所以测试将会更容易。</li></ul></div><div class="ab cl lw lx hx ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="im in io ip iq"><h1 id="554a" class="md me it bd mf mg mh mi mj mk ml mm mn jz mo ka mp kc mq kd mr kf ms kg mt mu bi translated">Android中的依赖注入</h1><p id="4d14" class="pw-post-body-paragraph mv mw it lb b lc mx ju my le mz jx na lg nb nc nd li ne nf ng lk nh ni nj lm im bi translated">安卓里的DI和别人没什么区别。在这里，Android组件，如activities、fragments等，依赖于reform、Glide等实例。在Android中，我们用<a class="ae ky" href="https://dagger.dev/" rel="noopener ugc nofollow" target="_blank">匕首</a>来维护DI。</p><p id="4714" class="pw-post-body-paragraph mv mw it lb b lc ld ju my le lf jx na lg no nc nd li np nf ng lk nq ni nj lm im bi translated">使用Dagger的主要优点是它会在编译时生成创建所需对象的代码。这有两个主要优点。一个是不再有运行时错误，因为Dagger是一个编译时静态库。另一个是你不再需要写所有的代码来维护依赖关系。</p><p id="8b48" class="pw-post-body-paragraph mv mw it lb b lc ld ju my le lf jx na lg no nc nd li np nf ng lk nq ni nj lm im bi translated">简而言之，Dagger提供了编译时依赖管理，无需编写样板代码。</p></div><div class="ab cl lw lx hx ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="im in io ip iq"><h1 id="3ca9" class="md me it bd mf mg mh mi mj mk ml mm mn jz mo ka mp kc mq kd mr kf ms kg mt mu bi translated">匕首的历史及其优势</h1><h2 id="a26f" class="ns me it bd mf nt nu dn mj nv nw dp mn lg nx ny mp li nz oa mr lk ob oc mt od bi translated">匕首的历史</h2><p id="670d" class="pw-post-body-paragraph mv mw it lb b lc mx ju my le mz jx na lg nb nc nd li ne nf ng lk nh ni nj lm im bi translated">Dagger是由Square的开发人员在2012年创建的一个依赖注入库。Dagger1使用反射的概念来创建类和依赖关系的实例。</p><p id="5265" class="pw-post-body-paragraph mv mw it lb b lc ld ju my le lf jx na lg no nc nd li np nf ng lk nq ni nj lm im bi translated">之后，他们与谷歌的开发人员合作，通过去除反射来构建Dagger2，这非常强大。Dagger2基于注释处理器。</p><h2 id="c30a" class="ns me it bd mf nt nu dn mj nv nw dp mn lg nx ny mp li nz oa mr lk ob oc mt od bi translated">优势</h2><p id="7df2" class="pw-post-body-paragraph mv mw it lb b lc mx ju my le mz jx na lg nb nc nd li ne nf ng lk nh ni nj lm im bi translated">Dagger通过以下方式将您从编写乏味且容易出错的样板代码中解放出来:</p><ul class=""><li id="4d04" class="kz la it lb b lc ld le lf lg lh li lj lk ll lm nr lo lp lq bi translated">创建您在手动DI部分手动实现的<code class="fe nk nl nm nn b">AppContainer</code>代码(应用程序图)。</li><li id="ae18" class="kz la it lb b lc lr le ls lg lt li lu lk lv lm nr lo lp lq bi translated">为应用程序图中可用的类创建工厂。这就是依赖性在内部得到满足的方式，也是我们不需要编写所有样板代码的原因。</li><li id="0902" class="kz la it lb b lc lr le ls lg lt li lu lk lv lm nr lo lp lq bi translated">重用依赖项或创建类型的新实例取决于您如何使用范围配置类型。</li><li id="4660" class="kz la it lb b lc lr le ls lg lt li lu lk lv lm nr lo lp lq bi translated">Daggers还通过释放不再使用的对象来关心内存管理。</li></ul></div><div class="ab cl lw lx hx ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="im in io ip iq"><h1 id="b853" class="md me it bd mf mg mh mi mj mk ml mm mn jz mo ka mp kc mq kd mr kf ms kg mt mu bi translated">术语</h1><h2 id="edde" class="ns me it bd mf nt nu dn mj nv nw dp mn lg nx ny mp li nz oa mr lk ob oc mt od bi translated">@模块</h2><p id="172d" class="pw-post-body-paragraph mv mw it lb b lc mx ju my le mz jx na lg nb nc nd li ne nf ng lk nh ni nj lm im bi translated">这用于创建依赖类对象的类。</p><h2 id="051c" class="ns me it bd mf nt nu dn mj nv nw dp mn lg nx ny mp li nz oa mr lk ob oc mt od bi translated">@提供</h2><p id="5365" class="pw-post-body-paragraph mv mw it lb b lc mx ju my le mz jx na lg nb nc nd li ne nf ng lk nh ni nj lm im bi translated">这用于模块类内部的方法，并提供依赖关系。</p><h2 id="9536" class="ns me it bd mf nt nu dn mj nv nw dp mn lg nx ny mp li nz oa mr lk ob oc mt od bi translated">@注入</h2><p id="957b" class="pw-post-body-paragraph mv mw it lb b lc mx ju my le mz jx na lg nb nc nd li ne nf ng lk nh ni nj lm im bi translated">这用于请求依赖项的构造函数、字段或方法中。</p><h2 id="b9f5" class="ns me it bd mf nt nu dn mj nv nw dp mn lg nx ny mp li nz oa mr lk ob oc mt od bi translated">@组件</h2><p id="2c03" class="pw-post-body-paragraph mv mw it lb b lc mx ju my le mz jx na lg nb nc nd li ne nf ng lk nh ni nj lm im bi translated">模块类不会直接提供依赖关系——相反，它会创建一个接口作为<code class="fe nk nl nm nn b">@Module</code>和<code class="fe nk nl nm nn b">@Inject</code>之间的桥梁。</p><h2 id="3d3a" class="ns me it bd mf nt nu dn mj nv nw dp mn lg nx ny mp li nz oa mr lk ob oc mt od bi translated">@单身</h2><p id="2170" class="pw-post-body-paragraph mv mw it lb b lc mx ju my le mz jx na lg nb nc nd li ne nf ng lk nh ni nj lm im bi translated">这也用于模块中的方法，但是，具体来说，依赖对象应该只创建一次。</p></div><div class="ab cl lw lx hx ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="im in io ip iq"><h1 id="4221" class="md me it bd mf mg mh mi mj mk ml mm mn jz mo ka mp kc mq kd mr kf ms kg mt mu bi translated">综合</h1><p id="7bfb" class="pw-post-body-paragraph mv mw it lb b lc mx ju my le mz jx na lg nb nc nd li ne nf ng lk nh ni nj lm im bi translated">Dagger2集成和其他库一样简单——您只需要将下面这段代码包含到<code class="fe nk nl nm nn b">build.gradle</code>文件中。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oe of l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">Dagger2集成</p></figure><p id="b15c" class="pw-post-body-paragraph mv mw it lb b lc ld ju my le lf jx na lg no nc nd li np nf ng lk nq ni nj lm im bi translated">确保您使用的是<a class="ae ky" href="https://github.com/google/dagger/releases" rel="noopener ugc nofollow" target="_blank">这里</a>的最新版本。</p></div><div class="ab cl lw lx hx ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="im in io ip iq"><h1 id="9fca" class="md me it bd mf mg mh mi mj mk ml mm mn jz mo ka mp kc mq kd mr kf ms kg mt mu bi translated">Dagger2设置</h1><p id="4d05" class="pw-post-body-paragraph mv mw it lb b lc mx ju my le mz jx na lg nb nc nd li ne nf ng lk nh ni nj lm im bi translated">正如我所说的，模块类中会有返回依赖关系的<code class="fe nk nl nm nn b">@Provides</code>方法，所以我们的第一项工作是创建模块类。我们来看看怎么做。</p><p id="9f89" class="pw-post-body-paragraph mv mw it lb b lc ld ju my le lf jx na lg no nc nd li np nf ng lk nq ni nj lm im bi translated">这里我将创建一个改进实例，我需要OkHttp和Moshi实例。与此同时，我将创建<code class="fe nk nl nm nn b">ApiService</code>类实例来调用服务调用。看一看:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oe of l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">Dagger2模块设置</p></figure><p id="ed6d" class="pw-post-body-paragraph mv mw it lb b lc ld ju my le lf jx na lg no nc nd li np nf ng lk nq ni nj lm im bi translated">我们可以创建任意多的模块，关键是要提到<code class="fe nk nl nm nn b">appcomponent</code>类中的所有模块——这是我们的下一步。在此之前，我们为什么需要不同的模块类？我们不能在一个模块类中包含所有的依赖吗？</p><p id="f963" class="pw-post-body-paragraph mv mw it lb b lc ld ju my le lf jx na lg no nc nd li np nf ng lk nq ni nj lm im bi translated">当然，但是在一个模块中声明所有的网络、数据和其他依赖项会在项目增长时造成混乱，所以如果我们为不同类型的依赖项创建不同的模块类，会更清楚、更容易理解。</p><p id="de88" class="pw-post-body-paragraph mv mw it lb b lc ld ju my le lf jx na lg no nc nd li np nf ng lk nq ni nj lm im bi translated">既然我们已经创建了所需网络依赖关系的实例，下一步将是创建<code class="fe nk nl nm nn b">AppComponent</code>，它充当<code class="fe nk nl nm nn b">module</code>和<code class="fe nk nl nm nn b">inject</code>之间的桥梁。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oe of l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">Dagger2组件设置</p></figure><p id="0b7f" class="pw-post-body-paragraph mv mw it lb b lc ld ju my le lf jx na lg no nc nd li np nf ng lk nq ni nj lm im bi translated">如果您清楚地观察了上面的代码，我使用了六个模块类来提供所有需要的依赖项，并在我的<code class="fe nk nl nm nn b">AppcCmponent</code>接口中声明了它们。</p><p id="3ffb" class="pw-post-body-paragraph mv mw it lb b lc ld ju my le lf jx na lg no nc nd li np nf ng lk nq ni nj lm im bi translated">现在，我们已经完成了所有的工作——唯一剩下的就是将<code class="fe nk nl nm nn b">AppComponent</code>与应用程序生命周期联系起来。在此之前，我们需要重新构建项目，这样Dagger将在后台创建所有的样板代码。成功重建后，就该在应用程序类中声明<code class="fe nk nl nm nn b">AppComponent</code>了。看一看:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oe of l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">将组件与应用程序生命周期联系起来</p></figure><p id="e963" class="pw-post-body-paragraph mv mw it lb b lc ld ju my le lf jx na lg no nc nd li np nf ng lk nq ni nj lm im bi translated">这就是我们要通过Dagger2建立对onjection的依赖所要做的一切。</p></div><div class="ab cl lw lx hx ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="im in io ip iq"><h1 id="ef07" class="md me it bd mf mg mh mi mj mk ml mm mn jz mo ka mp kc mq kd mr kf ms kg mt mu bi translated">使用</h1><p id="a3a1" class="pw-post-body-paragraph mv mw it lb b lc mx ju my le mz jx na lg nb nc nd li ne nf ng lk nh ni nj lm im bi translated">既然我们已经完成了基本的设置和所有的事情，剩下的唯一事情就是将依赖项注入到所需的类中并使用它们。让我们看看如何注入一个改造实例。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oe of l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">dagger2的用法</p></figure><p id="761a" class="pw-post-body-paragraph mv mw it lb b lc ld ju my le lf jx na lg no nc nd li np nf ng lk nq ni nj lm im bi translated">这被称为<em class="og">字段注入</em>，因为我们通过一个称为变量的字段注入所需的依赖关系。</p><p id="c942" class="pw-post-body-paragraph mv mw it lb b lc ld ju my le lf jx na lg no nc nd li np nf ng lk nq ni nj lm im bi translated">我们还可以通过构造函数注入来实现这一点，我们将通过类的构造函数传递所需的依赖关系。看一看:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oe of l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">通过构造函数使用Dagger2</p></figure></div><div class="ab cl lw lx hx ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="im in io ip iq"><h1 id="ea82" class="md me it bd mf mg mh mi mj mk ml mm mn jz mo ka mp kc mq kd mr kf ms kg mt mu bi translated">多模块应用中的匕首</h1><p id="4535" class="pw-post-body-paragraph mv mw it lb b lc mx ju my le mz jx na lg nb nc nd li ne nf ng lk nh ni nj lm im bi translated">要理解这个模块，首先你应该理解什么是多模块应用。</p><p id="92da" class="pw-post-body-paragraph mv mw it lb b lc ld ju my le lf jx na lg no nc nd li np nf ng lk nq ni nj lm im bi translated">当我们开始一个新的应用程序时，我们不知道随着时间的推移我们需要做的一切是正常的。这意味着久而久之，你的产品经理将提出不同的想法，以实施在应用程序中。在软件世界里很正常。一般来说，在这种情况下，我们所做的是在同一个模块中创建那些特性，随着时间的推移，这些特性会在维护代码时引起严重的问题。</p><p id="8609" class="pw-post-body-paragraph mv mw it lb b lc ld ju my le lf jx na lg no nc nd li np nf ng lk nq ni nj lm im bi translated">这就是多模块概念发挥作用的时候了。</p><p id="9aa9" class="pw-post-body-paragraph mv mw it lb b lc ld ju my le lf jx na lg no nc nd li np nf ng lk nq ni nj lm im bi translated">无论需要什么样的新特性，都将作为项目中的新模块来实现，因此代码的维护将变得简单，也更容易处理——即使有多个开发人员在这个项目中工作</p><p id="b1be" class="pw-post-body-paragraph mv mw it lb b lc ld ju my le lf jx na lg no nc nd li np nf ng lk nq ni nj lm im bi translated">现在我们知道了什么是多模块项目，是时候处理模块间的依赖注入了。</p><p id="80c5" class="pw-post-body-paragraph mv mw it lb b lc ld ju my le lf jx na lg no nc nd li np nf ng lk nq ni nj lm im bi translated">应用程序的每个模块都需要某些资源，这是很常见的，比如用于服务调用的翻新实例或<code class="fe nk nl nm nn b">SharedPreference</code>实例。所以我们需要跨模块共享资源，而不是创建新的实例——这就是多模块项目中依赖注入的样子。</p><p id="384b" class="pw-post-body-paragraph mv mw it lb b lc ld ju my le lf jx na lg no nc nd li np nf ng lk nq ni nj lm im bi translated">看看我们是怎么实现的吧。</p><p id="f08d" class="pw-post-body-paragraph mv mw it lb b lc ld ju my le lf jx na lg no nc nd li np nf ng lk nq ni nj lm im bi translated">我们主要做的是为每个功能模块创建一个单独的组件。假设我们有一个登录模块。正如我所说的，我们需要一个登录组件，如下所示创建:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oe of l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">Dagger2模块组件创建</p></figure><p id="6148" class="pw-post-body-paragraph mv mw it lb b lc ld ju my le lf jx na lg no nc nd li np nf ng lk nq ni nj lm im bi translated">这就是我们如何在模块级实现组件。</p><p id="902d" class="pw-post-body-paragraph mv mw it lb b lc ld ju my le lf jx na lg no nc nd li np nf ng lk nq ni nj lm im bi translated">现在，让我们看看如何使用它们。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oe of l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">模块组件使用</p></figure></div><div class="ab cl lw lx hx ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="im in io ip iq"><h1 id="e9c2" class="md me it bd mf mg mh mi mj mk ml mm mn jz mo ka mp kc mq kd mr kf ms kg mt mu bi translated">有用的链接</h1><div class="oh oi gp gr oj ok"><a href="https://developer.android.com/training/dependency-injection/dagger-android" rel="noopener  ugc nofollow" target="_blank"><div class="ol ab fo"><div class="om ab on cl cj oo"><h2 class="bd iu gy z fp op fr fs oq fu fw is bi translated">在Android应用中使用Dagger | Android开发者</h2><div class="or l"><h3 class="bd b gy z fp op fr fs oq fu fw dk translated">Dagger基础页面解释了Dagger如何帮助您在应用程序中自动化依赖注入。用匕首，你…</h3></div><div class="os l"><p class="bd b dl z fp op fr fs oq fu fw dk translated">developer.android.com</p></div></div><div class="ot l"><div class="ou l ov ow ox ot oy ks ok"/></div></div></a></div><div class="oh oi gp gr oj ok"><a href="https://developer.android.com/training/dependency-injection/dagger-multi-module" rel="noopener  ugc nofollow" target="_blank"><div class="ol ab fo"><div class="om ab on cl cj oo"><h2 class="bd iu gy z fp op fr fs oq fu fw is bi translated">在多模块应用中使用Dagger | Android开发者</h2><div class="or l"><h3 class="bd b gy z fp op fr fs oq fu fw dk translated">注意:在这一页中，提到的模块是指Gradle模块，而不是Dagger模块。在一个有多个…</h3></div><div class="os l"><p class="bd b dl z fp op fr fs oq fu fw dk translated">developer.android.com</p></div></div><div class="ot l"><div class="oz l ov ow ox ot oy ks ok"/></div></div></a></div><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="pa of l"/></div></figure></div></div>    
</body>
</html>