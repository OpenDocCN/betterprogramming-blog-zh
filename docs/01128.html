<html>
<head>
<title>Structure Constants in iOS With Enums</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">带枚举的iOS中的结构常数</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/structure-constants-in-ios-with-enums-5ca2135dcab0?source=collection_archive---------11-----------------------#2019-08-16">https://betterprogramming.pub/structure-constants-in-ios-with-enums-5ca2135dcab0?source=collection_archive---------11-----------------------#2019-08-16</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><figure class="is it gp gr iu iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi ir"><img src="../Images/1902a097eec7788419b1c219aaa8724d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*bSa7R-nEdCiLlCpcelV2rg.jpeg"/></div></div></figure><h2 id="be42" class="jc jd je bd b dl jf jg jh ji jj jk dk jl translated" aria-label="kicker paragraph">可扩展iOS应用架构的组成部分</h2><div class=""/><div class=""><h2 id="954c" class="pw-subtitle-paragraph kk jn je bd b kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb dk translated">Swift中作为名称空间的枚举</h2></div><p id="54f6" class="pw-post-body-paragraph lc ld je le b lf lg ko lh li lj kr lk ll lm ln lo lp lq lr ls lt lu lv lw lx im bi translated">最后，所有的视图都完成了，看起来完全符合挑剔的设计师的要求。按钮只在第一次点击时触发，不再发送100个服务器请求，因为QA部门总是疯狂地按下按钮。其他一切看起来也很好。</p><p id="9628" class="pw-post-body-paragraph lc ld je le b lf lg ko lh li lj kr lk ll lm ln lo lp lq lr ls lt lu lv lw lx im bi translated">当然，在工作日结束前五分钟有一个小小的变化——所有的间隙现在应该是10像素宽，而不是8像素宽，去抖动应该从500毫秒减少到300毫秒。在该项目中，现在必须找到100个位置并进行调整。当然，还有今天！😱</p><p id="3ec6" class="pw-post-body-paragraph lc ld je le b lf lg ko lh li lj kr lk ll lm ln lo lp lq lr ls lt lu lv lw lx im bi translated">当然，明智的程序员不会在源代码中存储硬编码的值，而只会使用全局常量。交换两个值，完成，晚上保存。🤓</p><p id="f73c" class="pw-post-body-paragraph lc ld je le b lf lg ko lh li lj kr lk ll lm ln lo lp lq lr ls lt lu lv lw lx im bi translated">没有必要搜索100个位置来查看值“500”是否真的是一个去抖动值，或者是否可能不是一个视图高度。不会因为有人写了0.5秒而不是500毫秒而忘记或忽略某处的值。只有一个重要的，不需要动脑筋的改变。</p></div><div class="ab cl ly lz hx ma" role="separator"><span class="mb bw bk mc md me"/><span class="mb bw bk mc md me"/><span class="mb bw bk mc md"/></div><div class="im in io ip iq"><h1 id="f81e" class="mf mg je bd mh mi mj mk ml mm mn mo mp kt mq ku mr kw ms kx mt kz mu la mv mw bi translated">你如何构造这些常数？</h1><p id="9cf1" class="pw-post-body-paragraph lc ld je le b lf mx ko lh li my kr lk ll mz ln lo lp na lr ls lt nb lv lw lx im bi translated">最天真的方法是简单地将1000条<code class="fe nc nd ne nf b">let</code>语句写入一个<em class="ng"> const.swift </em>文件。🚨更好的做法是在名字中加上自己的前缀缩写，以防止命名冲突。🚨🚨然后你只需要找到正确的常数…</p><p id="b773" class="pw-post-body-paragraph lc ld je le b lf lg ko lh li lj kr lk ll lm ln lo lp lq lr ls lt lu lv lw lx im bi translated">难道没有更好的东西，比如<em class="ng">命名空间</em>？🤔</p><blockquote class="nh"><p id="cdf3" class="ni nj je bd nk nl nm nn no np nq lx dk translated">命名空间是用于分隔代码和防止名称冲突的概念。</p></blockquote><p id="35ca" class="pw-post-body-paragraph lc ld je le b lf nr ko lh li ns kr lk ll nt ln lo lp nu lr ls lt nv lv lw lx im bi translated">不幸的是，除了模块，Swift本身没有名称空间。然而，正如Bart Jacobs在他的文章“<a class="ae nw" href="https://medium.com/@chungbkhn87/namespace-in-swift-e92e96376c17" rel="noopener">Swift</a>中的名称空间”中的“<a class="ae nw" href="https://cocoacasts.com/namespaces-in-swift" rel="noopener ugc nofollow" target="_blank">Swift</a>中的名称空间”或<a class="nx ny ep" href="https://medium.com/u/dedec971c104?source=post_page-----5ca2135dcab0--------------------------------" rel="noopener" target="_blank"> Chung Duong </a>中很好地解释的那样，您可以只使用枚举而不使用cases。这最接近Swift中的名称空间。</p><figure class="nz oa ob oc gt iv"><div class="bz fp l di"><div class="od oe l"/></div></figure></div><div class="ab cl ly lz hx ma" role="separator"><span class="mb bw bk mc md me"/><span class="mb bw bk mc md me"/><span class="mb bw bk mc md"/></div><div class="im in io ip iq"><h1 id="2df0" class="mf mg je bd mh mi mj mk ml mm mn mo mp kt mq ku mr kw ms kx mt kz mu la mv mw bi translated">枚举是解决方案</h1><p id="bff1" class="pw-post-body-paragraph lc ld je le b lf mx ko lh li my kr lk ll mz ln lo lp na lr ls lt nb lv lw lx im bi translated">枚举可以嵌套和扩展，但没有实例化的case定义。这使得艾努斯·斯威夫特的命名空间。</p><p id="1136" class="pw-post-body-paragraph lc ld je le b lf lg ko lh li lj kr lk ll lm ln lo lp lq lr ls lt lu lv lw lx im bi translated">通过将每个类别移动到自己的文件中，声明甚至可以进一步结构化。然后，所有常数的根节点形成<code class="fe nc nd ne nf b">Const</code>，例如，在名为<em class="ng"> Const.swift </em>的文件中:</p><figure class="nz oa ob oc gt iv"><div class="bz fp l di"><div class="od oe l"/></div><p class="of og gj gh gi oh oi bd b be z dk translated">Const.swift</p></figure><p id="dcb7" class="pw-post-body-paragraph lc ld je le b lf lg ko lh li lj kr lk ll lm ln lo lp lq lr ls lt lu lv lw lx im bi translated">然后，每个额外的类别将作为一个扩展名出现在它自己的文件中，例如<em class="ng">size . swift</em>:</p><figure class="nz oa ob oc gt iv"><div class="bz fp l di"><div class="od oe l"/></div><p class="of og gj gh gi oh oi bd b be z dk translated">尺码. swift</p></figure><p id="fa86" class="pw-post-body-paragraph lc ld je le b lf lg ko lh li lj kr lk ll lm ln lo lp lq lr ls lt lu lv lw lx im bi translated">通过这种方式，您可以将相似的常数与每个枚举结构捆绑在一起。这减少了潜在的合并冲突。通过将它们分成不同的文件，您可以将文件大小保持在较低水平，而将概览保持在较高水平。</p><p id="499b" class="pw-post-body-paragraph lc ld je le b lf lg ko lh li lj kr lk ll lm ln lo lp lq lr ls lt lu lv lw lx im bi translated">由于Xcode的自动补全功能只显示这一逻辑类别的常量，因此访问常量非常容易。</p><figure class="nz oa ob oc gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi oj"><img src="../Images/1ede15546d4bdc71b814fb31ee2f7c46.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*O6bUPSPMpqIudCOTukRlgQ.png"/></div></div></figure></div><div class="ab cl ly lz hx ma" role="separator"><span class="mb bw bk mc md me"/><span class="mb bw bk mc md me"/><span class="mb bw bk mc md"/></div><div class="im in io ip iq"><h1 id="0c33" class="mf mg je bd mh mi mj mk ml mm mn mo mp kt mq ku mr kw ms kx mt kz mu la mv mw bi translated">次优选择</h1><p id="1636" class="pw-post-body-paragraph lc ld je le b lf mx ko lh li my kr lk ll mz ln lo lp na lr ls lt nb lv lw lx im bi translated">当然，您也可以在相关返回类型的扩展中编写常量，并通过类型而不是<code class="fe nc nd ne nf b">Const</code>来访问常量。</p><figure class="nz oa ob oc gt iv"><div class="bz fp l di"><div class="od oe l"/></div></figure><p id="5c84" class="pw-post-body-paragraph lc ld je le b lf lg ko lh li lj kr lk ll lm ln lo lp lq lr ls lt lu lv lw lx im bi translated">这使得它更短，因为你不再需要写<code class="fe nc nd ne nf b">Const.Size.</code>，但它可能会回到名称冲突，例如，如果苹果在<em class="ng"> CGFloat </em>中引入自己的<code class="fe nc nd ne nf b">gapSize</code>常数。</p><p id="f2c4" class="pw-post-body-paragraph lc ld je le b lf lg ko lh li lj kr lk ll lm ln lo lp lq lr ls lt lu lv lw lx im bi translated">此外，由于不再区分自定义常量和标准常量，概述也受到了影响。然后，自动完成功能会显示关于该类型的所有信息。</p><figure class="nz oa ob oc gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi ok"><img src="../Images/0fcde942b04b7ceb3ecf90a4c7ebeb69.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*IrrduEPkKZdqtBefw9Gc-Q.png"/></div></div></figure><p id="53f6" class="pw-post-body-paragraph lc ld je le b lf lg ko lh li lj kr lk ll lm ln lo lp lq lr ls lt lu lv lw lx im bi translated">此外，你必须事先知道你在寻找什么样的常数。</p><p id="e684" class="pw-post-body-paragraph lc ld je le b lf lg ko lh li lj kr lk ll lm ln lo lp lq lr ls lt lu lv lw lx im bi translated">常量然后根据它们的类型被分离，例如，一个<code class="fe nc nd ne nf b">static let defaultViewSize = CGSize(width: 100, height: 30)</code>将是类型<em class="ng"> CGSize </em>并且不再适合<em class="ng"> CGFloat </em>扩展。然而，它仍然非常适合<code class="fe nc nd ne nf b">Const.Size</code>扩展。所以，在这种情况下，你必须知道<code class="fe nc nd ne nf b">defaultViewSize</code>的类型是<em class="ng"> CGSize </em>但是<code class="fe nc nd ne nf b">gapSize</code>的类型是<em class="ng"> CGFloat </em>。</p><p id="f9be" class="pw-post-body-paragraph lc ld je le b lf lg ko lh li lj kr lk ll lm ln lo lp lq lr ls lt lu lv lw lx im bi translated">这就是为什么我最喜欢enum方法，并使用它在可伸缩的iOS应用程序中构造常数。</p></div><div class="ab cl ly lz hx ma" role="separator"><span class="mb bw bk mc md me"/><span class="mb bw bk mc md me"/><span class="mb bw bk mc md"/></div><div class="im in io ip iq"><h1 id="1bb6" class="mf mg je bd mh mi mj mk ml mm mn mo mp kt mq ku mr kw ms kx mt kz mu la mv mw bi translated">非常数的命名空间</h1><p id="3446" class="pw-post-body-paragraph lc ld je le b lf mx ko lh li my kr lk ll mz ln lo lp na lr ls lt nb lv lw lx im bi translated">如果枚举充当名称空间，是否可以将所有类和其他类型都放入其中？🤔</p><figure class="nz oa ob oc gt iv"><div class="bz fp l di"><div class="od oe l"/></div></figure><p id="c283" class="pw-post-body-paragraph lc ld je le b lf lg ko lh li lj kr lk ll lm ln lo lp lq lr ls lt lu lv lw lx im bi translated">当然这是可行的，但是有一个更好的方法:模块。简单地外包框架中的所有类和其他类型。😉</p><p id="ab5b" class="pw-post-body-paragraph lc ld je le b lf lg ko lh li lj kr lk ll lm ln lo lp lq lr ls lt lu lv lw lx im bi translated">但是，如果您只想捆绑特殊类型，那么再次使用枚举可能是有意义的。例如，在我的<a class="ae nw" href="https://github.com/indieSoftware/DemoArchitecture" rel="noopener ugc nofollow" target="_blank"> DemoApp项目</a> (DAP)中，我使用一个<code class="fe nc nd ne nf b">Request</code> enum来捆绑所有请求，并将端点分组到其他enum中。</p><figure class="nz oa ob oc gt iv"><div class="bz fp l di"><div class="od oe l"/></div></figure><p id="d15b" class="pw-post-body-paragraph lc ld je le b lf lg ko lh li lj kr lk ll lm ln lo lp lq lr ls lt lu lv lw lx im bi translated">这具有自动完成建议匹配端点(例如，<code class="fe nc nd ne nf b">Request.SearchAutocompletion</code>)及其请求(<code class="fe nc nd ne nf b">Query</code>)的优点。</p><p id="a485" class="pw-post-body-paragraph lc ld je le b lf lg ko lh li lj kr lk ll lm ln lo lp lq lr ls lt lu lv lw lx im bi translated">在它们各自的文件中被分成几个扩展名，代码被进一步分离，所有的请求和它们的<em class="ng"> ServerWorker </em>一起位于它们自己的框架中。</p></div><div class="ab cl ly lz hx ma" role="separator"><span class="mb bw bk mc md me"/><span class="mb bw bk mc md me"/><span class="mb bw bk mc md"/></div><div class="im in io ip iq"><h1 id="783b" class="mf mg je bd mh mi mj mk ml mm mn mo mp kt mq ku mr kw ms kx mt kz mu la mv mw bi translated">结论</h1><p id="326a" class="pw-post-body-paragraph lc ld je le b lf mx ko lh li my kr lk ll mz ln lo lp na lr ls lt nb lv lw lx im bi translated">如图所示，人们可以简单地引用枚举来更好地构造常数或类型。它捆绑了从属关系，并支持Xcode的自动补全功能。不再需要大量的常量文件。</p><p id="763a" class="pw-post-body-paragraph lc ld je le b lf lg ko lh li lj kr lk ll lm ln lo lp lq lr ls lt lu lv lw lx im bi translated">这是一篇来自可扩展的iOS应用架构系列的文章。</p></div></div>    
</body>
</html>