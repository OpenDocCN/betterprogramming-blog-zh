<html>
<head>
<title>How to Manage Vue’s State With Vue.observable</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何用Vue.observable管理Vue的状态</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/how-to-manage-vues-state-with-vue-observable-25988a88938b?source=collection_archive---------6-----------------------#2020-04-28">https://betterprogramming.pub/how-to-manage-vues-state-with-vue-observable-25988a88938b?source=collection_archive---------6-----------------------#2020-04-28</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="a842" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">让不必要的样板文件消失吧</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/c3b8d47f37eec89bc45b3560ad01a7ce.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*1CQKTs7fzWC2Bm0D"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">保罗·斯科鲁普斯卡斯在<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>拍摄的照片。</p></figure><p id="2e62" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我已经使用Vue至少三年了，从一开始，我就使用Vuex来控制我的应用程序中的常见状态，因为这是一个官方和核心支持的功能。对于大型应用程序，使用像Vuex这样的解决方案来保持代码的集中化、组织化和整个团队的可理解性是完全有意义的。但是对于较小的应用程序，在我看来，仅仅为了控制少量的数据，就必须编写太多的代码(状态、动作、突变、getters)。</p><p id="2b64" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">总而言之，状态只是你的组件之间共享的一个对象，对吗？因此，也许我们可以用导出状态对象的JavaScript文件开始编写我们的解决方案:</p><pre class="kj kk kl km gt lv lw lx ly aw lz bi"><span id="ace7" class="ma mb it lw b gy mc md l me mf">// store.js<br/>const state = { counter: 1 };<br/>export default state;</span></pre><p id="3078" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在我们只需导入它并将其作为计算属性，这样我们的组件就可以访问它的值:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mg mh l"/></div></figure><p id="d4c6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">到目前为止，我们还好。但是如果我们想用这样的方法来更新存储值呢？</p><pre class="kj kk kl km gt lv lw lx ly aw lz bi"><span id="f710" class="ma mb it lw b gy mc md l me mf">  ,methods: {<br/>    increment() {<br/>      store.counter ++<br/>    }<br/>  }</span></pre><p id="9c64" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">正如您所想象的，存储将得到更新，但由于它没有意义告诉我们的组件值已经改变，我们的组件仍将显示值0。</p><p id="9a29" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">为了解决这个问题，我们可以实现类似于<code class="fe mi mj mk lw b">pubsub</code>模式的东西，我在我的文章<a class="ae ky" href="https://medium.com/swlh/write-your-own-javascript-state-management-library-3687d3c09aae" rel="noopener">写你自己的JavaScript状态管理库</a>中描述过，或者尝试在一些库的帮助下使用observables，比如<a class="ae ky" href="https://rxjs-dev.firebaseapp.com/" rel="noopener ugc nofollow" target="_blank"> RxJS </a>。Observables似乎是一种更现代、更简洁的解决问题的方式，但在这两种情况下，我们都必须编写更多的代码或使用一些外部库，这可能不是更适合小型应用程序的解决方案。</p><p id="3fbd" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">因为我们已经在使用Vue来处理我们的UI，所以我们可以利用它的<code class="fe mi mj mk lw b">Vue.observable</code> API函数来让我们的小商店具有反应性。如<a class="ae ky" href="https://vuejs.org/v2/api/#Vue-observable" rel="noopener ugc nofollow" target="_blank"> Vue文档</a>所述:</p><blockquote class="ml mm mn"><p id="5316" class="kz la mo lb b lc ld ju le lf lg jx lh mp lj lk ll mq ln lo lp mr lr ls lt lu im bi translated">“Vue.observable使一个对象具有反应性。在内部，Vue在由<code class="fe mi mj mk lw b">data</code>函数返回的对象上使用它。</p><p id="3733" class="kz la mo lb b lc ld ju le lf lg jx lh mp lj lk ll mq ln lo lp mr lr ls lt lu im bi translated">返回的对象可以直接在<a class="ae ky" href="https://vuejs.org/v2/guide/render-function.html" rel="noopener ugc nofollow" target="_blank">渲染函数</a>和<a class="ae ky" href="https://vuejs.org/v2/guide/computed.html" rel="noopener ugc nofollow" target="_blank">计算属性</a>中使用，变异时会触发相应的更新。对于简单的场景，它还可以用作最小的、跨组件的状态存储。"</p></blockquote><p id="7ee2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这看起来很适合我们的案子。所以现在我们的商店看起来像这样:</p><pre class="kj kk kl km gt lv lw lx ly aw lz bi"><span id="de8a" class="ma mb it lw b gy mc md l me mf">// store.js<br/>import Vue from 'vue';<br/>const state = Vue.observable({ counter : 1})<br/>export default state;</span></pre><p id="d60e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在，当进行任何更改时，导入该存储的所有组件都将得到新值的通知。我发现使用这种方法的一个问题是，业务登录必须直接写在组件本身中，这使得更新和共享变得困难。为了解决这个问题，我们可以创建另一个文件，该文件利用存储并包含所有规则——或者因为我们的存储非常小，我们可以将它们写在那里作为命名导出:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mg mh l"/></div></figure><p id="5844" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">通过这样做，我们可以更新我们的组件来导入它们，并添加按钮来实现我们的UI和商店状态之间的交互:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mg mh l"/></div></figure><p id="dc65" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在，我们有了一个反应性的、简单的商店，并且我们的组件从业务逻辑中分离出来。</p><p id="38d7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这里用到的代码在<a class="ae ky" href="https://codesandbox.io/s/vue-state-management-751pq?file=/src/App.vue" rel="noopener ugc nofollow" target="_blank"> CodeSandbox </a>上有，可以自己测试。</p><p id="e755" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">您可能认为这个项目有太多的代码，本地状态就足够了，我同意这一点。这个例子更适合我之前说过的，你必须在非父子关系之间共享状态，并且不想使用高阶组件或者在多个级别之间传递道具和事件的情况。这可以在瞬间将应用程序从简单变得过于复杂。</p><p id="071b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">最后一点注意:这个例子并不意味着Vuex是一个发电站，或者是Vuex在所有项目上的替代品。对于需要强大功能的大型项目，您应该使用Vuex或任何其他类似的解决方案。</p><p id="9474" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我希望你喜欢这篇文章。下一集见。</p></div></div>    
</body>
</html>