<html>
<head>
<title>Creating a Database for Your Flask Python Web App</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">为Flask Python Web应用程序创建数据库</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/creating-a-postgresql-database-for-your-flask-web-app-ffa21fdf37b0?source=collection_archive---------1-----------------------#2022-07-02">https://betterprogramming.pub/creating-a-postgresql-database-for-your-flask-web-app-ffa21fdf37b0?source=collection_archive---------1-----------------------#2022-07-02</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="2a84" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">使用Python的SQAlchemy、ORM和数据版本控制</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/abde09dcbf88f8a2bc8711d64c78ee57.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*caiaE4nTvbqSyn6R99i00A.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">来自<a class="ae kv" href="https://icons8.com/illustrations" rel="noopener ugc nofollow" target="_blank">的<a class="ae kv" href="https://icons8.com/illustrations/author/zD2oqC8lLBBA" rel="noopener ugc nofollow" target="_blank">图标8 </a>插图哎哟！</a></p></figure><h1 id="d4a0" class="kw kx iq bd ky kz la lb lc ld le lf lg jw lh jx li jz lj ka lk kc ll kd lm ln bi translated">介绍</h1><p id="ecb3" class="pw-post-body-paragraph lo lp iq lq b lr ls jr lt lu lv ju lw lx ly lz ma mb mc md me mf mg mh mi mj ij bi translated">许多应用程序需要某种存储。也许你是一家在网上销售商品的企业，你需要保留一份清单。也许你正在建立一个论坛，需要跟踪每个人的帖子。我个人正在分发小说，需要准备好我的书籍和订阅清单。</p><p id="78e9" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">在本文中，我们将了解如何使用Flask和Heroku为您的应用程序轻松设置PostgreSQL数据库。</p><p id="4b2b" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">如果你想开始用Flask构建你的应用，你可以在<a class="ae kv" rel="noopener ugc nofollow" target="_blank" href="/building-a-web-app-a-starting-boost-9f037976f45f">我的起步助推文章</a>中了解第一步。我还在这里提供了一个全栈web应用<a class="ae kv" href="https://github.com/chlolgr/flask-structure" rel="noopener ugc nofollow" target="_blank">的代码模板(在上面链接的文章中进行了剖析)。</a></p><h2 id="e278" class="mp kx iq bd ky mq mr dn lc ms mt dp lg lx mu mv li mb mw mx lk mf my mz lm na bi translated">概观</h2><p id="2bed" class="pw-post-body-paragraph lo lp iq lq b lr ls jr lt lu lv ju lw lx ly lz ma mb mc md me mf mg mh mi mj ij bi translated">为了让你阅读这篇文章时更有意义，让我们鸟瞰一下这些步骤。</p><p id="2902" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">您首先需要确定一个数据模型——您需要创建什么表来存储您的信息。通过为每个需要的表创建一个类，您可以用Python完成所有的数据建模。</p><p id="a1b1" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">然后，您可以使用我在代码模板中提供的脚本在本地实例化您的数据库。SQLAlchemy库会将您的Python类转换成SQL语句，并在您的存储库中生成一个二进制文件来存储所有数据。对于这一步，两个bash命令就足够了。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nb"><img src="../Images/6926e37fc57476edfbb7762636820b0e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*-MSN4Cme9oWIGZ23A0Uk8A.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">来自<a class="ae kv" href="https://icons8.com/illustrations" rel="noopener ugc nofollow" target="_blank">的<a class="ae kv" href="https://icons8.com/illustrations/author/zD2oqC8lLBBA" rel="noopener ugc nofollow" target="_blank">图标8 </a>的插图哎哟！</a></p></figure><p id="3501" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">一旦有了本地数据库，就可以测试数据移动，在路由函数中查询表，并确保一切都按照您希望的方式运行。您的本地数据库可以作为临时区域。</p><p id="e104" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">当你在你的机器上有了一个与你的应用程序一起工作的数据库，你可以运行在Heroku本地实例化它的相同脚本，并开始使用它将为生产生成的PostgreSQL数据库。</p><h1 id="5170" class="kw kx iq bd ky kz la lb lc ld le lf lg jw lh jx li jz lj ka lk kc ll kd lm ln bi translated">为您的数据建模</h1><p id="e3dd" class="pw-post-body-paragraph lo lp iq lq b lr ls jr lt lu lv ju lw lx ly lz ma mb mc md me mf mg mh mi mj ij bi translated">根据您需要存储的对象的复杂性，这可能需要几分钟到几个小时的思考时间。如果你像我一样，你只需要记录两件事，这是非常简单的。</p><h2 id="4a1e" class="mp kx iq bd ky mq mr dn lc ms mt dp lg lx mu mv li mb mw mx lk mf my mz lm na bi translated">带有SQLAlchemy的ORM</h2><p id="8393" class="pw-post-body-paragraph lo lp iq lq b lr ls jr lt lu lv ju lw lx ly lz ma mb mc md me mf mg mh mi mj ij bi translated">使用Flask和SQLAlchemy，您可以只使用Python来构建整个数据库。一旦您知道需要创建什么模型，您就可以将它们构建为Python类，而不需要一行SQL。</p><p id="949e" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">对我来说，我有一个书单，然后有人报名阅读。我选择了最简单的方法来进行建模，尽可能使用最少的表:一个表用于图书，一个表用于订阅。这是我的<code class="fe nc nd ne nf b">app/models.py</code>文件(为了简洁，去掉了几行):</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ng nh l"/></div></figure><p id="0e93" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">每个表由一个继承自<code class="fe nc nd ne nf b">sqlachemy.Model</code>的类表示。这构成了我们所说的对象关系映射(ORM ),它处理SQL表和Python类之间的转换，并允许您将表中的行作为类的实例进行操作。</p><p id="1f21" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">按照惯例，您的类将带有一个带标题的单数名称，并在数据库中使用<code class="fe nc nd ne nf b">__tablename__</code>属性被赋予一个小写的单数表名。</p><p id="f0b0" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">在您的类中，您可以将表列定义为类属性(相对于实例属性)。换句话说:不需要构造函数。所有的列都是<code class="fe nc nd ne nf b">sqlalchemy.Column</code>实例，每个都有特定的类型——这也是来自<code class="fe nc nd ne nf b">sqlalchemy</code>库中的一个类的实例。您可以在这里找到通用SQLAlchemy类型的列表<a class="ae kv" href="https://docs.sqlalchemy.org/en/14/core/type_basics.html#generic-types" rel="noopener ugc nofollow" target="_blank">。</a></p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi ni"><img src="../Images/1afcaa51d7967fc39e68e20062e59c6b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*-nRwxcuTigGK39LJUBiYcQ.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">Python模型生成的数据库图表(图片由作者提供)</p></figure><p id="74e0" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">我还添加了unicity约束，这种约束运行起来非常流行，并提供了一种有用的保护措施来防止重复的行和用户应该只执行一次的操作。您可以通过将它们作为参数添加到您的<code class="fe nc nd ne nf b">Column()</code>启动程序中来创建约束——就像我对第9行和第23行的<code class="fe nc nd ne nf b">primary_key</code>参数所做的那样——或者，如果它们跨越了几个将要成为的列，就用一个<code class="fe nc nd ne nf b">__table_args__</code>属性来创建约束——就像我对第30–32行所做的那样，对<code class="fe nc nd ne nf b">email, book_id</code>索引使用一个unicity约束。</p><h2 id="c842" class="mp kx iq bd ky mq mr dn lc ms mt dp lg lx mu mv li mb mw mx lk mf my mz lm na bi translated">翻译外键:Flask关系</h2><p id="5939" class="pw-post-body-paragraph lo lp iq lq b lr ls jr lt lu lv ju lw lx ly lz ma mb mc md me mf mg mh mi mj ij bi translated">很容易看出Python类如何用SQLAlchemy对应SQL表。类的语法非常类似于<code class="fe nc nd ne nf b">CREATE TABLE</code>语句的语法。然而，ORM还会为您做一件事。</p><p id="f7a2" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">让我们放大上面代码示例中的第27–28行:</p><pre class="kg kh ki kj gt nj nf nk nl aw nm bi"><span id="0262" class="mp kx iq nf b gy nn no l np nq">class Subscription(db.Model):<br/>    [...]<br/>    book_id = db.Column(db.Integer, db.ForeignKey('book.id'))<br/>    book = db.relationship('Book', backref='book')</span></pre><p id="404c" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated"><code class="fe nc nd ne nf b">book_id</code>属性是<code class="fe nc nd ne nf b">book</code>表的外键，就像我们用SQL创建一个表一样。那么<code class="fe nc nd ne nf b">book</code>属性是关于什么的呢？</p><p id="9170" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated"><a class="ae kv" href="https://docs.sqlalchemy.org/en/14/orm/basic_relationships.html#many-to-one" rel="noopener ugc nofollow" target="_blank">关系函数</a>(这里是多对一的形式)将具有匹配<code class="fe nc nd ne nf b">id</code>属性的<code class="fe nc nd ne nf b">Book</code>类的实例链接到您的<code class="fe nc nd ne nf b">Subscription</code>对象，这意味着您的<code class="fe nc nd ne nf b">Book</code>实例将可以从所有将<code class="fe nc nd ne nf b">id</code>存储在其<code class="fe nc nd ne nf b">book_id</code>属性中的<code class="fe nc nd ne nf b">Subscription</code>实例中访问。例如，你可以运行这样的代码:</p><pre class="kg kh ki kj gt nj nf nk nl aw nm bi"><span id="9814" class="mp kx iq nf b gy nn no l np nq">&gt;&gt;&gt; from app.models import Subscription<br/>&gt;&gt;&gt; s = Subscription.query.get(5)<br/>&gt;&gt;&gt; s<br/>&lt;Subscription 5&gt;<br/>&gt;&gt;&gt; s.book<br/>&lt;Book 3&gt;<br/>&gt;&gt;&gt; s.book.title<br/>'The Picture of Dorian Gray'</span></pre><h1 id="839e" class="kw kx iq bd ky kz la lb lc ld le lf lg jw lh jx li jz lj ka lk kc ll kd lm ln bi translated">部署您的模型</h1><p id="96e4" class="pw-post-body-paragraph lo lp iq lq b lr ls jr lt lu lv ju lw lx ly lz ma mb mc md me mf mg mh mi mj ij bi translated">一旦定义了模型中的所有表，就需要实际创建数据库。为了拥有一个独立于生产环境的临时实例，您可以在您的计算机上创建一个本地数据库。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nr"><img src="../Images/4ab83e34509db596df0c83f8204f6d4b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*GRdW7x7Gnn_kJxLZd6u8hQ.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">插图由<a class="ae kv" href="https://icons8.com/illustrations/author/zD2oqC8lLBBA" rel="noopener ugc nofollow" target="_blank">图标8 </a>从<a class="ae kv" href="https://icons8.com/illustrations" rel="noopener ugc nofollow" target="_blank">哎哟！</a></p></figure><p id="911a" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">在<code class="fe nc nd ne nf b">app/config.py</code>文件中，第<code class="fe nc nd ne nf b">SQLALCHEMY_DATABASE_URI = os.environ.get('DATABASE_URL') or 'sqlite:///' + os.path.join(basedir, 'app.db')</code>行将根据当前环境为您的数据库定义正确的地址。如果<code class="fe nc nd ne nf b">DATABASE_URL</code>是一个现有的环境变量(生产环境)，那就是你的应用程序将寻找你的数据的地方。否则，它将加载一个<code class="fe nc nd ne nf b">app/app.db</code>文件(本地)。</p><p id="96a5" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">我提供的代码将在您运行接下来的步骤时，在您的生产服务器上自动生成<code class="fe nc nd ne nf b">DATABASE_URL</code>环境变量，并在您的机器上自动生成<code class="fe nc nd ne nf b">app/app.db</code>文件。</p><h2 id="5307" class="mp kx iq bd ky mq mr dn lc ms mt dp lg lx mu mv li mb mw mx lk mf my mz lm na bi translated">生成本地数据库文件</h2><p id="c7b8" class="pw-post-body-paragraph lo lp iq lq b lr ls jr lt lu lv ju lw lx ly lz ma mb mc md me mf mg mh mi mj ij bi translated">您只需要运行带有正确参数的<code class="fe nc nd ne nf b">manage.py</code>文件来启动并修改您的数据库。对于初始化(显然您必须首先运行它)，您可以运行(在bash中)<code class="fe nc nd ne nf b">python manage.py db init</code>或<code class="fe nc nd ne nf b">flask db init</code>。</p><p id="7778" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">然后，您应该会看到类似以下内容的内容:</p><pre class="kg kh ki kj gt nj nf nk nl aw nm bi"><span id="e9b5" class="mp kx iq nf b gy nn no l np nq">Creating directory /absolute/path/to_your_repo/migrations ...  done<br/>Creating directory /absolute/path/to_your_repo/migrations/versions ...  done<br/>Generating /absolute/path/to_your_repo/migrations/script.py.mako ...  done<br/>Generating /absolute/path/to_your_repo/migrations/env.py ...  done<br/>Generating /absolute/path/to_your_repo/migrations/README ...  done<br/>Generating /absolute/path/to_your_repo/migrations/alembic.ini ...  done<br/>Please edit configuration/connection/logging settings in '/absolute/path/to_your_repo/migrations/alembic.ini' before proceeding.</span></pre><p id="1c9b" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">您的数据库现在已经初始化。您现在在项目根目录下找到的migrations文件夹包含版本控制所需的文件。但是您的数据模型还不存在(即您的表不存在)。要部署它们，您可以运行(仍然是bash) <code class="fe nc nd ne nf b">python manage.py db migrate</code>或<code class="fe nc nd ne nf b">flask db migrate</code>。然后你会看到(适应你自己的表):</p><pre class="kg kh ki kj gt nj nf nk nl aw nm bi"><span id="185c" class="mp kx iq nf b gy nn no l np nq">INFO  [alembic.runtime.migration] Context impl SQLiteImpl.<br/>INFO  [alembic.runtime.migration] Will assume non-transactional DDL.<br/>INFO  [alembic.autogenerate.compare] Detected added table 'book'<br/>INFO  [alembic.autogenerate.compare] Detected added table 'subscription'<br/>Generating /absolute/path/to_your_repo/migrations/versions/8be207c95451_.py ...  done</span></pre><p id="a9dc" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">当您运行迁移时，Alembic(处理数据模型版本控制的Flask扩展)将您更新的模型与您现有的模型进行比较，并概括变更，然后为部署进行设置。</p><p id="0166" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">你的桌子还没准备好使用！但是我们会成功的。最后一步是实际部署，使用<code class="fe nc nd ne nf b">python manage.py db upgrade</code>或<code class="fe nc nd ne nf b">flask db upgrade</code>运行。这将运行实际的<code class="fe nc nd ne nf b">CREATE TABLE</code>语句，并显示:</p><pre class="kg kh ki kj gt nj nf nk nl aw nm bi"><span id="4fe7" class="mp kx iq nf b gy nn no l np nq">INFO [alembic.runtime.migration] Context impl SQLiteImpl.<br/>INFO [alembic.runtime.migration] Will assume non-transactional DDL.<br/>INFO [alembic.runtime.migration] Running upgrade -&gt; 8be207c95451, empty message</span></pre><p id="d6ba" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">如果一切顺利，现在就可以填充和查询表了！✨</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi ns"><img src="../Images/e46f318f87946558947165ed9f3bc932.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*2fT5RSWiGXraRm5jpJjFOg.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">插图由<a class="ae kv" href="https://icons8.com/illustrations/author/TQQ1qAnr9rn5" rel="noopener ugc nofollow" target="_blank"> Oleg Shcherba </a>从<a class="ae kv" href="https://icons8.com/illustrations" rel="noopener ugc nofollow" target="_blank">哎哟！</a></p></figure><p id="3da5" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">每次您对您的模型进行更改时，您都需要再次迁移和升级。⚠️小心，<a class="ae kv" href="https://alembic.sqlalchemy.org/en/latest/autogenerate.html#what-does-autogenerate-detect-and-what-does-it-not-detect" rel="noopener ugc nofollow" target="_blank"> Alembic不会跟踪你模型的所有变化</a>；因此，即使有了版本控制，你也应该认真考虑如何组织你的数据。</p><h2 id="254f" class="mp kx iq bd ky mq mr dn lc ms mt dp lg lx mu mv li mb mw mx lk mf my mz lm na bi translated">在Heroku上创建PostgreSQL数据库</h2><p id="8778" class="pw-post-body-paragraph lo lp iq lq b lr ls jr lt lu lv ju lw lx ly lz ma mb mc md me mf mg mh mi mj ij bi translated">一些好消息:在Heroku上部署模型的步骤与生成本地二进制文件的步骤相同——您只需要直接从服务器上运行bash命令。</p><p id="2bf5" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">您不需要为PostgreSQL显式添加该插件，因为Heroku会自动为具有某些库的应用程序提供该插件(如SQLAlchemy)。Heroku还将为您生成您的<code class="fe nc nd ne nf b">DATABASE_URL</code>环境变量，如果您计划从您的机器上读写数据库(即您不需要一个登台环境)，您可能希望将该变量复制到您的本地环境文件中。</p><p id="e1e1" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">您只需要提交您的更改并将其推送到您的<code class="fe nc nd ne nf b">app/models.py</code>文件，同时确保git不会跟踪您的<code class="fe nc nd ne nf b">migrations</code>文件夹和<code class="fe nc nd ne nf b">app/app.db</code>文件(将它们添加到您的<code class="fe nc nd ne nf b">.gitignore</code>)。</p><p id="115a" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">然后，您可以运行:</p><pre class="kg kh ki kj gt nj nf nk nl aw nm bi"><span id="d1b9" class="mp kx iq nf b gy nn no l np nq">heroku run bash<br/>&gt;&gt;&gt; python manage.py db init<br/>&gt;&gt;&gt; python manage.py db migrate<br/>&gt;&gt;&gt; python manage.py db upgrade</span></pre><p id="1a53" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">你完了。</p><p id="d408" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">正如我提到的，您的<code class="fe nc nd ne nf b">app/config.py</code>文件将根据您的环境处理正确数据库的选择(本地二进制文件与PostgreSQL实例)。确保不要将<code class="fe nc nd ne nf b">migrations</code>文件夹混在一起，以避免冲突！</p><h1 id="61ea" class="kw kx iq bd ky kz la lb lc ld le lf lg jw lh jx li jz lj ka lk kc ll kd lm ln bi translated">填充和查询您的数据</h1><p id="c822" class="pw-post-body-paragraph lo lp iq lq b lr ls jr lt lu lv ju lw lx ly lz ma mb mc md me mf mg mh mi mj ij bi translated">基本上有两种方法可以运行DML语句。您可以创建一个到数据库的连接并使用SQL，也可以使用ORM SQLAlchemy提供的。我推荐使用ORM，因为它免去了您的连接设置。</p><p id="4347" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">要在SQL上运行，您可以使用一个简洁的小函数，如下所示:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ng nh l"/></div></figure><p id="a146" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">然后您可以运行插入和更新，或者使用常规SQL查询您的数据库(记住使用PostgreSQL语法)。</p><p id="a990" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">您也可以像这样查询您的数据库(如果您需要一个数据框架来进行进一步的操作，那就太好了):</p><pre class="kg kh ki kj gt nj nf nk nl aw nm bi"><span id="38ee" class="mp kx iq nf b gy nn no l np nq">import pandas as pd<br/>from app import db<br/>df = pd.read_sql(&lt;YOUR-SQL-QUERY&gt;, db.session.bind)</span></pre><p id="ca80" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">或者像这样运行插入或更新(特别有助于快速修复):</p><pre class="kg kh ki kj gt nj nf nk nl aw nm bi"><span id="73ba" class="mp kx iq nf b gy nn no l np nq">from app import db<br/>db.session.bind.execute(&lt;YOUR-SQL-STATEMENT&gt;)</span></pre><p id="f0fb" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">我们现在将介绍ORM方法。首先，你可以在官方文档的<a class="ae kv" href="https://flask-sqlalchemy.palletsprojects.com/en/2.x/queries/" rel="noopener ugc nofollow" target="_blank">中找到我在这篇文章中收集到的很多东西。</a></p><h2 id="caf1" class="mp kx iq bd ky mq mr dn lc ms mt dp lg lx mu mv li mb mw mx lk mf my mz lm na bi translated">选择</h2><p id="717c" class="pw-post-body-paragraph lo lp iq lq b lr ls jr lt lu lv ju lw lx ly lz ma mb mc md me mf mg mh mi mj ij bi translated">有了ORM，您的模型类(从Flask模型类继承而来)有了供选择的内置函数。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi nt"><img src="../Images/db118ccb85eb7d44dd20045cc03e01d9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1164/format:webp/1*LEXv2bKARZ8wIdvLEvenEg.png"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">Igor Kapustin 插图来自<a class="ae kv" href="https://icons8.com/illustrations" rel="noopener ugc nofollow" target="_blank">哎哟！</a></p></figure><p id="ce21" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">让我们看看我会如何从书架上拿书。</p><p id="7974" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">如果我知道书的ID(假设它在AJAX发送给我正在运行的函数的路径的参数中)，我可以简单地运行<code class="fe nc nd ne nf b">Book.query.get(&lt;book-id&gt;)</code>来检索对象。我也可以把所有的书作为列表检索，用<code class="fe nc nd ne nf b">Book.query.all()</code>；或者我可以用一种我只能称之为“python化SQL”的语法来过滤结果。</p><p id="48cf" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">我的网络应用程序的一个最新功能是书架搜索栏。例如，如果你搜索“夏洛克·福尔摩斯”，你应该会找到《夏洛克·福尔摩斯历险记》。我现在保持简单(不允许拼写错误)，对书名进行简单过滤。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ng nh l"/></div></figure><p id="0e07" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">☝️:当用户发送一个带有搜索栏输入的表单时，我可以使用我的orm通过将输入转换成小写并使用<code class="fe nc nd ne nf b">like</code>函数在我的数据库中模糊搜索来检索列表——这可以从典型的SQL语法中识别出来。</p><p id="1944" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">您可以在这里找到更多SQL功能的SQLAlchemy仿真<a class="ae kv" href="https://docs.sqlalchemy.org/en/14/core/functions.html" rel="noopener ugc nofollow" target="_blank">。当我需要的查询变得复杂时，我倾向于直接使用SQL，因为我已经习惯了it⁴.</a></p><h2 id="bec6" class="mp kx iq bd ky mq mr dn lc ms mt dp lg lx mu mv li mb mw mx lk mf my mz lm na bi translated">插入</h2><p id="d4b5" class="pw-post-body-paragraph lo lp iq lq b lr ls jr lt lu lv ju lw lx ly lz ma mb mc md me mf mg mh mi mj ij bi translated">使用ORM编写数据就像用Python创建对象一样简单。比方说我想把列夫·托尔斯泰的<em class="nu">安娜·卡列尼娜</em>加到我的<code class="fe nc nd ne nf b">book</code>桌。我只需要创建一个<code class="fe nc nd ne nf b">book</code>对象，就像这样:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ng nh l"/></div></figure><p id="4d29" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">在第8行，SQLAlchemy将这本书添加到我的数据库中，但是只针对当前会话。如果我打开一个新的连接，这本书将不会在那里。第9行提交新行，并“永久地”插入它。我添加<code class="fe nc nd ne nf b">try</code> / <code class="fe nc nd ne nf b">except</code>子句的原因是，如果违反了任何约束，您的提交将不起作用。</p><p id="d30d" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">当您试图提交一个违反您已经制定的规则的更改时，SQLAlchemy在您收回您的错误之前不会容忍任何进一步的DML这就是我在第10行执行回滚的原因。</p><h2 id="9d6e" class="mp kx iq bd ky mq mr dn lc ms mt dp lg lx mu mv li mb mw mx lk mf my mz lm na bi translated">更新</h2><p id="7268" class="pw-post-body-paragraph lo lp iq lq b lr ls jr lt lu lv ju lw lx ly lz ma mb mc md me mf mg mh mi mj ij bi translated">运行更新包括简单地检索您想要更新的对象，用Python更新新值，并为您的数据库运行一次提交。</p><p id="6baa" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">例如，如果我意识到我把《简·爱》归功于简·奥斯汀，我想澄清事实，我可以这样做:</p><pre class="kg kh ki kj gt nj nf nk nl aw nm bi"><span id="72c8" class="mp kx iq nf b gy nn no l np nq">from app import db<br/>from app.models import Book</span><span id="cc9b" class="mp kx iq nf b gy nv no l np nq">book = Book.query.filter_by(title = 'Jane Eyre')<br/>book.author_name = 'Charlotte Brontë'<br/>db.session.commit()</span></pre><p id="5ffe" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated"><strong class="lq ir">值得一提的是:</strong>对于批量插入和更新，我也求助于SQL。你可以<a class="ae kv" href="https://stackoverflow.com/questions/3659142/bulk-insert-with-sqlalchemy-orm" rel="noopener ugc nofollow" target="_blank">创建你所有的对象并将它们提交到一起</a>，但是我发现SQL连接更干净。</p><h1 id="216f" class="kw kx iq bd ky kz la lb lc ld le lf lg jw lh jx li jz lj ka lk kc ll kd lm ln bi translated">结论</h1><p id="3a60" class="pw-post-body-paragraph lo lp iq lq b lr ls jr lt lu lv ju lw lx ly lz ma mb mc md me mf mg mh mi mj ij bi translated">Heroku和Flask极大地简化了web应用程序中PostgreSQL数据库的使用。第一次部署时会遇到许多障碍，但是本文有望帮助您避开其中的大部分。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nw"><img src="../Images/8bcccd2921be8aa89a4a5e52c7f7f5ce.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*LHU8iHibbv_Tw7wWlLXQEQ.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">插图由<a class="ae kv" href="https://icons8.com/illustrations/author/u7l2K4BCiAa9" rel="noopener ugc nofollow" target="_blank">娜塔莎雷马克</a>从<a class="ae kv" href="https://icons8.com/illustrations" rel="noopener ugc nofollow" target="_blank">哎哟！</a></p></figure><p id="9eae" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">在您的机器上有一个用于暂存的数据库，您可以开发您的模型，并在本地运行您的应用程序时测试它们。一旦您满意了，您可以使用完全相同的命令将它们部署到您的服务器上，从Heroku CLI运行。</p><p id="e27c" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">始终注意不要混淆本地数据库和服务器数据库之间的迁移，否则您将不得不牺牲版本控制来让事情再次运行(我已经这样做了几次)。</p><p id="8060" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">如果你遇到任何问题，有任何疑问，或者找到了更聪明的方法，请告诉我！在以后的文章中，我将会介绍更多的全栈web应用细节。</p></div><div class="ab cl nx ny hu nz" role="separator"><span class="oa bw bk ob oc od"/><span class="oa bw bk ob oc od"/><span class="oa bw bk ob oc"/></div><div class="ij ik il im in"><h1 id="2cac" class="kw kx iq bd ky kz oe lb lc ld of lf lg jw og jx li jz oh ka lk kc oi kd lm ln bi translated">笔记</h1><ol class=""><li id="2058" class="oj ok iq lq b lr ls lu lv lx ol mb om mf on mj oo op oq or bi translated">关系数据库<a class="ae kv" href="https://stackoverflow.com/questions/338156/table-naming-dilemma-singular-vs-plural-names" rel="noopener ugc nofollow" target="_blank">中表名的单数和复数之争在</a>上激烈展开，但与本次讨论无关。随你的便。</li><li id="6863" class="oj ok iq lq b lr os lu ot lx ou mb ov mf ow mj oo op oq or bi translated">如果您不熟悉Python类，并且您只是来进行web应用程序开发的，那么不要担心什么是构造函数或者为什么您不需要构造函数。你可以照着代码做。</li><li id="dea7" class="oj ok iq lq b lr os lu ot lx ou mb ov mf ow mj oo op oq or bi translated">DML代表数据操作语言，与数据定义语言(DDL)相对。DDL包括诸如<code class="fe nc nd ne nf b">CREATE</code>、<code class="fe nc nd ne nf b">ALTER</code>和<code class="fe nc nd ne nf b">DROP</code>之类的语句，这些语句有助于构建您的模型。DML包括<code class="fe nc nd ne nf b">INSERT</code>、<code class="fe nc nd ne nf b">UPDATE</code>和<code class="fe nc nd ne nf b">SELECT</code>语句，它们在您的模型中操作数据。</li><li id="f4a7" class="oj ok iq lq b lr os lu ot lx ou mb ov mf ow mj oo op oq or bi translated">我只在个人项目中使用Flask。如果我是出于专业目的使用它，我可能更愿意付出努力，使用ORM，如果这看起来是一个更好的解决方案。</li></ol></div></div>    
</body>
</html>