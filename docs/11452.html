<html>
<head>
<title>Async All The Way Down!</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">异步一直向下！</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/async-all-the-way-down-2c0cec62480f?source=collection_archive---------1-----------------------#2022-03-22">https://betterprogramming.pub/async-all-the-way-down-2c0cec62480f?source=collection_archive---------1-----------------------#2022-03-22</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="546f" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated"><a class="ae ki" href="https://docs.sqlalchemy.org/en/14/" rel="noopener ugc nofollow" target="_blank"> SqlAlchemy 1.4 </a>现在支持<code class="fe kj kk kl km b">asyncio</code></h2></div><figure class="ko kp kq kr gt ks gh gi paragraph-image"><div role="button" tabindex="0" class="kt ku di kv bf kw"><div class="gh gi kn"><img src="../Images/176790d7494290dfb6eea6ac93b22c5b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*4-7DgQGLyhbbDIp6ADJx3A.png"/></div></div></figure><p id="26d5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">卡洛奥。Callay！<a class="ae ki" href="https://docs.sqlalchemy.org/en/14/" rel="noopener ugc nofollow" target="_blank"> SqlAlchemy 1.4 </a>现在支持<code class="fe kj kk kl km b">asyncio</code>。他们所做的工作令人惊叹。</p><p id="d221" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">多年来，我一直在用<code class="fe kj kk kl km b">SqlAlchemy</code>处理Tornado，并且不得不求助于<code class="fe kj kk kl km b">ThreadPoolExecutor</code>来使我的查询并行运行。不会了。现在，它将一直异步到最后一只海龟。当然，除非您决定使用ORM。然后<a class="ae ki" href="https://pypi.org/project/greenlet/" rel="noopener ugc nofollow" target="_blank"> greenlets </a>会解决你所有的问题。但是让我们后退一步，讨论一下您在设计API时所做的编辑决策。</p><h2 id="5c09" class="lv lw it bd lx ly lz dn ma mb mc dp md li me mf mg lm mh mi mj lq mk ml mm mn bi translated">函数还是类？</h2><p id="48ba" class="pw-post-body-paragraph kz la it lb b lc mo ju le lf mp jx lh li mq lk ll lm mr lo lp lq ms ls lt lu im bi translated">第一个编辑决定通常是习惯问题。我知道有些不允许类的开销——那都是继承和不必要的复杂性。他们有时是错误的。一个优雅的类层次结构通常可以减轻如何在你面前的代码图中导航的痛苦。在其他时候，一堆函数就足够了。</p><p id="3738" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">以学习Java的容易程度为例。一切都是一个类，一切都需要一个接口的实现。然后你看一个python包——这个wally用的是什么风格？功能类或者——哦，天哪。文档是有帮助的，但是有时候我不读源代码就不知道他们想要什么。</p><p id="88d1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">咆哮结束，让我们看看我们的选择。我们试图实现一个简单的时间表应用程序。我选择将其建模如下:</p><figure class="ko kp kq kr gt ks gh gi paragraph-image"><div class="gh gi mt"><img src="../Images/b39b5e65983511069d889dec79e7ddac.png" data-original-src="https://miro.medium.com/v2/resize:fit:750/format:webp/1*puRXsKSVbGfWGE8_xcYdPg.png"/></div></figure><p id="fc43" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">为什么？因为用户会记录他们一整天的时间使用情况。只有用户可以记录时间，只有用户可以编辑他们的时间。我们已经将活动隔离到用户的名称空间；活动不共享。所以日志只是一个时间戳和一个活动的组合。用户还将保存一天的笔记。</p><p id="f63d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">那么我们如何在这个模型上生成视图呢？我们是要公开一个类似CRUD的接口还是假设一个上下文？让我们先来看看日志视图:</p><figure class="ko kp kq kr gt ks"><div class="bz fp l di"><div class="mu mv l"/></div></figure><p id="7e6d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">首先，当前登录的用户是谁？然后，让我们整理一些日期，可能没有日期，也可能格式不正确。我让<code class="fe kj kk kl km b">python-dateutil</code>帮我解决这个问题。然后我们开始我们的查询。我们正在使用新的1.4 <code class="fe kj kk kl km b">Session</code>和<code class="fe kj kk kl km b">select</code>语句。首先，它是上下文感知的。它在离开上下文时关闭，而不是传入一个selectables数组，我们使用*args来传入它们。很干净直观。我们加入，添加一个where和order_by。这个游标有一个all()方法，因为每一行都有一个items接口，所以我们可以将它们解构为dto构造函数的参数。好悲伤的人，它看起来像SQL。嗯，这不就是重点吗——用python写sql。</p><p id="b614" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在让我们看看ORM世界中的等价查询。</p><figure class="ko kp kq kr gt ks"><div class="bz fp l di"><div class="mu mv l"/></div></figure><p id="3bcd" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">您可以看到查询稍微紧凑一些，并且我们的模型类知道它支持的不同视图。使用<code class="fe kj kk kl km b">options</code>选择要使用的加载策略有些复杂。但是等待——没有等待。这是因为我们使用了内置在SQLAlchemy 1.4中的名为<code class="fe kj kk kl km b">session.run_sync</code>的greenlet抽象。它允许我们像对待旧的同步风格一样对待我们的异步模型。这是图书馆的另一个有趣的扩展:</p><figure class="ko kp kq kr gt ks"><div class="bz fp l di"><div class="mu mv l"/></div></figure><p id="5933" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们的Log类声明了一个元数据<code class="fe kj kk kl km b">__table__</code>，它允许使用表达式语言中的表和ORM中的模型！所以如果你不需要ORM的开销，就忽略它。如果您想要ORM及其会话缓存，那么就使用它。将这些世界整合成一个无缝隐喻的纯粹努力令人震惊——但是文档仍然支离破碎，难以理解。</p><p id="8f04" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">所以答案是两者都有。用表定义模式，用模型扩充模式，并编写利用两者优势的函数。为什么是函数？因为我们正在构建一个api。</p><h2 id="60d4" class="lv lw it bd lx ly lz dn ma mb mc dp md li me mf mg lm mh mi mj lq mk ml mm mn bi translated">背景和联系</h2><p id="37b1" class="pw-post-body-paragraph kz la it lb b lc mo ju le lf mp jx lh li mq lk ll lm mr lo lp lq ms ls lt lu im bi translated">从3.7开始，上下文是python中一个丰富的空间。我们的<code class="fe kj kk kl km b">contextvars</code>现在同时使用thread.local和task.local。所以我们可以将当前用户放入一个<code class="fe kj kk kl km b">ContextVar</code>中，无论我们是在运行任务还是在ThreadPoolExecutor中工作，每次我们调用该变量时，它都是正确的。会话也会发生这种情况。</p><figure class="ko kp kq kr gt ks"><div class="bz fp l di"><div class="mu mv l"/></div></figure><p id="8041" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们可以从环境变量中配置这个<code class="fe kj kk kl km b">async_session_factory</code>:</p><figure class="ko kp kq kr gt ks"><div class="bz fp l di"><div class="mu mv l"/></div></figure><p id="86c6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">或者，当我们测试时，从我们的<code class="fe kj kk kl km b">setup.cfg</code>中选择它们:</p><figure class="ko kp kq kr gt ks"><div class="bz fp l di"><div class="mu mv l"/></div></figure><p id="7520" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">你可能会问，<code class="fe kj kk kl km b">Config</code>和<code class="fe kj kk kl km b">command</code>是什么？这是Alembic，我们正在pytest夹具中准备数据库，有点像T2。通过使用<code class="fe kj kk kl km b">alembic</code>进行数据库迁移，我们获得了可测试性和模式迁移，这是由tables.metadata驱动的。我滥用系统，将脚本目录放入我的python包中，并将<code class="fe kj kk kl km b">alembic.ini</code>重命名为<code class="fe kj kk kl km b">setup.cfg</code>。在今天这个由<code class="fe kj kk kl km b">.cfg</code>和<code class="fe kj kk kl km b">.toml</code>组成的世界里，很难知道所有的配置应该放在哪里。我一直没能摆脱<code class="fe kj kk kl km b">setup.cfg</code>，虽然<code class="fe kj kk kl km b">setup.py</code>没了。很好，但是没有人能够弄清楚谁在哪里做什么。我确信它最终会澄清，但目前我仍然需要一个<code class="fe kj kk kl km b">setup.cfg</code>，一个<code class="fe kj kk kl km b">alembic</code>可以理解的格式，以及一个<code class="fe kj kk kl km b">pyproject.toml</code>，因为<code class="fe kj kk kl km b">black</code>不会在<code class="fe kj kk kl km b">.cfg</code>中查找。请注意，这只是为了测试。在生产中，大多数配置是从环境变量或命令行参数中加载的。</p><p id="3cda" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">因此，现在我们可以测试我们的表和模型，我们可以初始化我们的数据库。所以我们来测试一下。</p><h2 id="99ef" class="lv lw it bd lx ly lz dn ma mb mc dp md li me mf mg lm mh mi mj lq mk ml mm mn bi translated">测试</h2><p id="e03e" class="pw-post-body-paragraph kz la it lb b lc mo ju le lf mp jx lh li mq lk ll lm mr lo lp lq ms ls lt lu im bi translated">为了测试异步代码，你需要一个对<code class="fe kj kk kl km b">pytest</code>的扩展。我用过<code class="fe kj kk kl km b">pytest.torn-async</code>和<code class="fe kj kk kl km b">pytest.asyncio</code>。因为我们还没有使用<code class="fe kj kk kl km b">tornado</code>，所以我将使用<code class="fe kj kk kl km b">pytest.asyncio</code>。它需要一个配置，并且会检查你的<code class="fe kj kk kl km b">setup.cfg</code> -添加这个:</p><pre class="ko kp kq kr gt mw km mx my aw mz bi"><span id="9db0" class="lv lw it km b gy na nb l nc nd">[tool:pytest]<br/>asyncio_mode = strict</span></pre><p id="afda" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">否则它会抱怨并警告贬值。现在我们要出发了。让我们写一个<code class="fe kj kk kl km b">register</code>函数来注册一个用户:</p><figure class="ko kp kq kr gt ks"><div class="bz fp l di"><div class="mu mv l"/></div></figure><p id="f84f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们执行插入和选择操作，以便从数据库中选择默认值。现在有一种使用<code class="fe kj kk kl km b">returning</code>的趋势，这会使这变得不必要，但是我的后端(mysql &amp; sqlite)不支持它。我已经抽象出了<code class="fe kj kk kl km b">select</code>,因为它被用在了很多地方。我提出了integrity error——它可能是抽象的。我们还加密了密码——应该可以加盐。但是我们可以测试一下:</p><figure class="ko kp kq kr gt ks"><div class="bz fp l di"><div class="mu mv l"/></div></figure><p id="35d0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们的<code class="fe kj kk kl km b">init_db</code>设备只是突袭<code class="fe kj kk kl km b">setup.cfg</code>并降级和升级数据库。<code class="fe kj kk kl km b">asyncio</code>装饰器让<code class="fe kj kk kl km b">pytest.asyncio</code>知道我们将异步运行。我们可以测试返回的类是否包含我们没有指定的默认值。我们也不能注册两次。</p><p id="2603" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">所以，如果<code class="fe kj kk kl km b">register</code>是模型上的一个类方法。用户，我们的测试会是什么样的？</p><figure class="ko kp kq kr gt ks"><div class="bz fp l di"><div class="mu mv l"/></div></figure><p id="8295" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们在测试中编写了一个同步函数，名为<code class="fe kj kk kl km b">session.run_sync</code>。那么我们回答了这个问题吗？是模特还是表？函数还是类？还是两者都有。</p><p id="0da1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">希望你能明白这是怎么回事。我们正在构建一个应用程序，其中一个用户将成为我们系统中的UML参与者。该用户将记录活动—我们不需要知道活动id、数据库主键，只需要知道他们使用的文本。</p><p id="c92a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">REST制造端点，CRUD向参与者公开数据库的实现。它们一起对我们的模型进行了懒惰的抽象。在这种情况下，需要先创建一个活动，然后才能创建日志。日志应该是:</p><p id="213e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe kj kk kl km b">{id, activity_id, created}</code></p><p id="4f07" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">或者更糟:</p><p id="ae1b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe kj kk kl km b">{id, activity:{id, name, user:{id, name}}, created}</code></p><p id="4597" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">api的上下文简化了我们的结果，并使我们能够公开一个<em class="ne">功能</em>接口。每个函数返回一个图，但它不仅仅是一个数据库模型的rip。所以我们的日志是<code class="fe kj kk kl km b">{id,activity, created}</code>。</p><p id="85e5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">那么这个神秘的<code class="fe kj kk kl km b">log</code>函数看起来像什么呢:</p><figure class="ko kp kq kr gt ks"><div class="bz fp l di"><div class="mu mv l"/></div></figure><p id="63af" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这是<code class="fe kj kk kl km b">log</code>的模型版本。比功能版更紧凑。我们创建一个<code class="fe kj kk kl km b">now</code>，将它与当前用户和提供的<code class="fe kj kk kl km b">activity_name</code>一起传递到我们添加到会话和<code class="fe kj kk kl km b">commit</code>的类中！然后我们告诉我妻子的所有设备，她已经添加了一个日志，甚至是她用来添加日志的那个。如果有任何错误，只有一个设备-调用者-会处理它，否则他们都是平等和连接的！</p><p id="7b7e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果你已经读到这里，你会想看看代码。它在Replit上，还有一个工作版本。这使用了我在<a class="ae ki" href="https://pspddo.medium.com/remote-procedures-please-c18f147e3db" rel="noopener">中描述的<code class="fe kj kk kl km b">rpc</code>远程程序，请。</a></p><h2 id="719c" class="lv lw it bd lx ly lz dn ma mb mc dp md li me mf mg lm mh mi mj lq mk ml mm mn bi translated">最后</h2><p id="5a53" class="pw-post-body-paragraph kz la it lb b lc mo ju le lf mp jx lh li mq lk ll lm mr lo lp lq ms ls lt lu im bi translated">模型是关于状态和功能的——封装。它们使得管理图中的关系不容易出错。这可以通过向表模型中添加关系(当然还有一些视图)来看出。但是我们生活在一个功能世界——一个远程程序的世界。并且通常不需要ORM的可理解的成本。如果你知道sql，用表达式语言和<code class="fe kj kk kl km b">await</code>你的喜悦来映射它。</p><p id="c3c0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">SQLAlchemy的作者应该为他们所做的工作受到高度赞扬。使用他们的包来绘制我的路线，我非常高兴。我已经使用1.4一年了，除了开心地笑，什么也没做。结合龙卷风和vue，人们可以做任何事情。一把真正的<em class="ne">沃帕尔</em>刀锋。</p></div><div class="ab cl nf ng hx nh" role="separator"><span class="ni bw bk nj nk nl"/><span class="ni bw bk nj nk nl"/><span class="ni bw bk nj nk"/></div><div class="im in io ip iq"><p id="416f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在下一篇文章中，我们将把所有这些整合在一起，并展示最终产品。前一篇文章:</p><div class="nm nn gp gr no np"><a href="https://pspddo.medium.com/remote-procedures-please-c18f147e3db" rel="noopener follow" target="_blank"><div class="nq ab fo"><div class="nr ab ns cl cj nt"><h2 class="bd iu gy z fp nu fr fs nv fu fw is bi translated">请远程操作。</h2><div class="nw l"><h3 class="bd b gy z fp nu fr fs nv fu fw dk translated">我儿子用电子和Vue写了一个简单的时间表应用程序。我为我妻子写了一个后端。她有三个…</h3></div><div class="nx l"><p class="bd b dl z fp nu fr fs nv fu fw dk translated">pspddo.medium.com</p></div></div><div class="ny l"><div class="nz l oa ob oc ny od kx np"/></div></div></a></div><p id="12fc" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">[1]<a class="ae ki" href="https://www.poetryfoundation.org/poems/42916/jabberwocky" rel="noopener ugc nofollow" target="_blank">https://www.poetryfoundation.org/poems/42916/jabberwocky</a></p><p id="1532" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">[2]<a class="ae ki" href="https://docs.sqlalchemy.org/en/14/orm/persistence_techniques.html?highlight=returning#fetching-server-generated-defaults" rel="noopener ugc nofollow" target="_blank">https://docs . sqlalchemy . org/en/14/ORM/persistence _ techniques . html</a></p><p id="7c3b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">[3]即将推出。</p></div></div>    
</body>
</html>