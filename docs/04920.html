<html>
<head>
<title>Getting Your App Ready for iOS 14</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">为iOS 14准备好您的应用</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/getting-ready-for-ios-14-7cffcf198239?source=collection_archive---------3-----------------------#2020-05-22">https://betterprogramming.pub/getting-ready-for-ios-14-7cffcf198239?source=collection_archive---------3-----------------------#2020-05-22</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="3784" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">让你的用户界面和你的用户为今年WWDC的到来做好准备</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/7a016176f613b47f12239325ff5fa290.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*FlgVMlPHSmZ7l31oKZwRaA.jpeg"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">图片由苹果公司提供</p></figure><p id="ae95" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">随着WWDC20于6月22日发布，以及下一代操作系统的测试版，现在是做好准备的时候了。我们只能猜测苹果可能会在iOS 14中添加的各种东西，但这并不意味着我们不能为它找到一个好位置。<br/> <br/>这里有几件事是你应该做的，以便获得最佳职位，以及你该如何去做。</p></div><div class="ab cl lu lv hx lw" role="separator"><span class="lx bw bk ly lz ma"/><span class="lx bw bk ly lz ma"/><span class="lx bw bk ly lz"/></div><div class="im in io ip iq"><h1 id="dfd1" class="mb mc it bd md me mf mg mh mi mj mk ml jz mm ka mn kc mo kd mp kf mq kg mr ms bi translated"><strong class="ak">黑暗模式</strong></h1><p id="5c2c" class="pw-post-body-paragraph ky kz it la b lb mt ju ld le mu jx lg lh mv lj lk ll mw ln lo lp mx lr ls lt im bi translated">黑暗模式是我们看到的最大的面向用户的变化，带来了一个全系统的外观，满足了我们中间的夜猫子。实现它可以非常容易，它给你一个机会来完善你的资产，删除重复的颜色，因为你可以做出新的系统界面模式。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi my"><img src="../Images/908e792877da2beb43cafa44ea231fc7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*WoIjhAYaVs_Axl2F1t8vsw.png"/></div></div></figure><p id="66e6" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">实现黑暗模式的最简单方法是在资产目录中显示您的颜色。</p><p id="c422" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">为此，只需转到您通常添加新图像的位置(资产列表底部的加号)，然后选择新颜色。将颜色设置为你想要的光模式颜色，打开右边的属性检查器。将外观选项设置为“任何，暗”，你会看到第二种颜色出现。将它设置为你希望你的颜色在黑暗模式下看起来的样子，通常是比正常外观稍微浅一点的颜色。</p><p id="1d18" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">要在代码中使用这些颜色，您只需:</p><pre class="kj kk kl km gt mz na nb nc aw nd bi"><span id="670d" class="ne mc it na b gy nf ng l nh ni">let color = UIColor(named: “’CBPurple”)</span></pre><p id="23e0" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">并且这些将自动响应接口状态的变化。确保浏览你的应用程序，将各种文本颜色设置为与黑暗模式相对应的新颜色，因为用户将无法阅读你的文本。你确实有很多系统颜色可供选择(假设你把你的部署目标设置为iOS 13)，所有这些颜色都能很好地适应黑暗模式。要看到这一点，设置一些东西到<code class="fe nj nk nl na b">.systemRed</code>，并在明暗模式下看它。你会看到红色几乎变成了粉红色，变得更加易读。</p><p id="2ca4" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated"><strong class="la iu">快速提示:</strong>不用在模拟器中跳转到开发者设置或者使用你的手机并更改你自己的设置，你可以在Xcode中使用界面覆盖来轻松模拟黑暗模式。运行应用程序时选择环境覆盖切换，并在两种模式之间快速调整。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nm"><img src="../Images/fcd4e5b0b5856eeedab1b69d0499026d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*0oP3HHyF4fB1wabqJUMr2w.png"/></div></div></figure><p id="ad3c" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">更多信息，请查看去年的<a class="ae nn" href="https://developer.apple.com/videos/play/wwdc2019/214/" rel="noopener ugc nofollow" target="_blank"> WWDC会议</a>。</p></div><div class="ab cl lu lv hx lw" role="separator"><span class="lx bw bk ly lz ma"/><span class="lx bw bk ly lz ma"/><span class="lx bw bk ly lz"/></div><div class="im in io ip iq"><h1 id="c70f" class="mb mc it bd md me mf mg mh mi mj mk ml jz mm ka mn kc mo kd mp kf mq kg mr ms bi translated"><strong class="ak">模态展示风格</strong></h1><p id="94fd" class="pw-post-body-paragraph ky kz it la b lb mt ju ld le mu jx lg lh mv lj lk ll mw ln lo lp mx lr ls lt im bi translated">一旦你使用iOS 13中的系统应用程序，或者任何经过优化的应用程序，你就会注意到模态现在呈现出一点点不同。</p><p id="1af2" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">这是因为默认的表示风格已经从<code class="fe nj nk nl na b">UIModalPresentationFullScreen</code>变成了<code class="fe nj nk nl na b">UIModalPresentationAutomatic</code>，它会根据上下文发生变化。自动的默认演示风格是<code class="fe nj nk nl na b">UIModalPresentationPageSheet</code>。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi no"><img src="../Images/0ba134e079d23bcb2bc012bc521c2002.png" data-original-src="https://miro.medium.com/v2/resize:fit:552/format:webp/1*rsvVAtE2I0UReoT5BLeatw.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">iPhone上的页面演示文稿</p></figure><p id="383f" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">iPhone上的页面演示为你提供了一个免费的交互式拖放功能，以及一个让底层屏幕变小的华丽动画。</p><p id="461f" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">在iPad上，你可以在屏幕中央看到一个模态，你可以再次拖动它来关闭。当在一个紧凑的环境中，例如最小的多任务窗口，它会恢复到iPhone风格的演示。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi np"><img src="../Images/e6b6224a53f8f8d3e3d983ef29d25a6b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*rV7cgP-Ns1kaRVOUwgHVew.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">iPad上的页面演示</p></figure><p id="eef9" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">你应该在整个应用程序中注意这些，确保如果你有用户不能忽略的东西，比如一个登录表单，你要么改变显示风格，要么禁用忽略。</p><p id="e129" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">为了阻止用户关闭，覆盖视图控制器上的属性<code class="fe nj nk nl na b">isModalInPresentation</code>，并将其设置为<code class="fe nj nk nl na b">true</code>。这将禁用交互式消除，直到您以编程方式更改属性或消除视图控制器。</p><p id="c22c" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">你可以用这些做很多事情，我建议查看关于这个话题的<a class="ae nn" href="https://developer.apple.com/videos/play/wwdc2019/224/" rel="noopener ugc nofollow" target="_blank"> WWDC视频</a>来了解更多。大约15分钟后，你会看到关于模态展示的详细信息，包括一些新的委托方法，可以帮助你发现解散。</p></div><div class="ab cl lu lv hx lw" role="separator"><span class="lx bw bk ly lz ma"/><span class="lx bw bk ly lz ma"/><span class="lx bw bk ly lz"/></div><div class="im in io ip iq"><h1 id="fcfa" class="mb mc it bd md me mf mg mh mi mj mk ml jz mm ka mn kc mo kd mp kf mq kg mr ms bi translated"><strong class="ak">场景委托</strong></h1><p id="6bf4" class="pw-post-body-paragraph ky kz it la b lb mt ju ld le mu jx lg lh mv lj lk ll mw ln lo lp mx lr ls lt im bi translated">iOS 13带来了全新的<code class="fe nj nk nl na b">SceneDelegate</code>和对多窗口的支持。你应该考虑你的应用程序是否会从中受益——通过允许用户在Mac和iPad上打开多个实例，大多数生产力应用程序都会有很大的改进。看看笔记在你的iPad上的表现，允许你并排打开两个。</p><p id="b7b3" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">如果您创建了一个新的应用程序，场景代理现在是默认的。现在我们有了场景委托，应用程序委托的角色略有不同。它应该只用于一次性设置，例如初始化您的数据库或注册推送通知。</p><p id="15a1" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">场景代理具有您习惯于从应用程序代理获得的所有生命周期挂钩，包括:</p><ul class=""><li id="79bd" class="nq nr it la b lb lc le lf lh ns ll nt lp nu lt nv nw nx ny bi translated">连接(启动)</li><li id="2c09" class="nq nr it la b lb nz le oa lh ob ll oc lp od lt nv nw nx ny bi translated">断开连接(停止)</li><li id="5581" class="nq nr it la b lb nz le oa lh ob ll oc lp od lt nv nw nx ny bi translated">变得活跃</li><li id="8c3f" class="nq nr it la b lb nz le oa lh ob ll oc lp od lt nv nw nx ny bi translated">主动辞职</li><li id="6251" class="nq nr it la b lb nz le oa lh ob ll oc lp od lt nv nw nx ny bi translated">进入前景</li><li id="50ef" class="nq nr it la b lb nz le oa lh ob ll oc lp od lt nv nw nx ny bi translated">输入背景</li></ul><p id="891d" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">您可以使用所有这些来重新创建您过去在应用程序代理中拥有的功能，只是现在您已经为多窗口做好了准备。如果你确保一个场景处于活动状态时，它的所有数据源都是最新的，你应该没有什么工作要做。</p><p id="5bcb" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">为了在你的应用程序中打开一个新窗口，你必须利用一个现有的API来响应试图打开一个窗口的用户。一个很好的例子是集合视图有一个新的…</p><pre class="kj kk kl km gt mz na nb nc aw nd bi"><span id="c47f" class="ne mc it na b gy nf ng l nh ni">collectionView(_collectionView: UICollectionView, itemsForBeginning session: UIDragSession, at indexPath: IndexPath)</span></pre><p id="83ad" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">…暴露给<code class="fe nj nk nl na b">UICollectionViewDragDelegate</code>的方法。如果您过去支持拖放操作，您可能已经符合这一点了——在这种情况下，您只需使用新方法来添加整个新窗口。</p><p id="66dd" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">在提供的示例中，您可以看到整个生命周期:设置一个<code class="fe nj nk nl na b">NSUserActivity</code>，将其注册到一个项目提供者，然后从该提供者创建一个拖动项目。</p><p id="5e3d" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">如果你这样做，用户可以从你的收藏视图中拖动项目，为你的应用程序创建一个新窗口，而你所做的只是遵从这个委托，并在你的新场景中响应用户活动——几乎毫不费力！</p><pre class="kj kk kl km gt mz na nb nc aw nd bi"><span id="b7ed" class="ne mc it na b gy nf ng l nh ni">func collectionView(_ collectionView: UICollectionView, itemsForBeginning session: UIDragSession, at indexPath: IndexPath) -&gt; [UIDragItem] { <br/>    var dragItems = [UIDragItem]()<br/>    let selectedPhoto = photo(at: indexPath)</span><span id="8ca9" class="ne mc it na b gy oe ng l nh ni">    if let imageToDrag = UIImage(named: selectedPhoto.name) {</span><span id="a245" class="ne mc it na b gy oe ng l nh ni">        let userActivity = selectedPhoto.openDetailUserActivity</span><span id="cd37" class="ne mc it na b gy oe ng l nh ni">        let itemProvider = NSItemProvider(object: imageToDrag)</span><span id="a034" class="ne mc it na b gy oe ng l nh ni">        itemProvider.registerObject(userActivity, visibility: .all)</span><span id="2172" class="ne mc it na b gy oe ng l nh ni">        let dragItem = UIDragItem(itemProvider: itemProvider)</span><span id="c366" class="ne mc it na b gy oe ng l nh ni">        dragItem.localObject = selectedPhoto</span><span id="9298" class="ne mc it na b gy oe ng l nh ni">        dragItems.append(dragItem)</span><span id="62ca" class="ne mc it na b gy oe ng l nh ni">    }</span><span id="2bbe" class="ne mc it na b gy oe ng l nh ni">    return dragItems</span><span id="aaf5" class="ne mc it na b gy oe ng l nh ni">}</span></pre><p id="e340" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">仅在这个话题上，苹果就有一个<a class="ae nn" href="https://developer.apple.com/documentation/uikit/app_and_environment/scenes/supporting_multiple_windows_on_ipad" rel="noopener ugc nofollow" target="_blank">伟大的指南</a>。</p></div><div class="ab cl lu lv hx lw" role="separator"><span class="lx bw bk ly lz ma"/><span class="lx bw bk ly lz ma"/><span class="lx bw bk ly lz"/></div><div class="im in io ip iq"><h1 id="df65" class="mb mc it bd md me mf mg mh mi mj mk ml jz mm ka mn kc mo kd mp kf mq kg mr ms bi translated"><strong class="ak">折旧</strong></h1><p id="2391" class="pw-post-body-paragraph ky kz it la b lb mt ju ld le mu jx lg lh mv lj lk ll mw ln lo lp mx lr ls lt im bi translated">做好准备时要记住的最重要的事情可能是你在应用程序中使用的被否决的SDK特性。</p><p id="30d5" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">当我们访问新的SDK时，这些警告中的任何一个都可能突然变成错误——所以去掉它们吧</p><p id="a781" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">这里有几个需要注意的。</p><h2 id="6fa5" class="ne mc it bd md of og dn mh oh oi dp ml lh oj ok mn ll ol om mp lp on oo mr op bi translated"><strong class="ak">' uinavigationbar . appearance()'</strong></h2><p id="8799" class="pw-post-body-paragraph ky kz it la b lb mt ju ld le mu jx lg lh mv lj lk ll mw ln lo lp mx lr ls lt im bi translated">旧的<code class="fe nj nk nl na b">UINavigationBar.appearance</code>API在iOS 13上已经不起作用了。您应该考虑实现<code class="fe nj nk nl na b">UINavigationBarAppearance</code>。这是以类似的方式使用，但更具定制性。</p><pre class="kj kk kl km gt mz na nb nc aw nd bi"><span id="7beb" class="ne mc it na b gy nf ng l nh ni"><strong class="na iu">let</strong> navigationBarAppearance = UINavigationBarAppearance()</span><span id="8b58" class="ne mc it na b gy oe ng l nh ni">navigationBarAppearance.backgroundColor = UIColor(named: “purple”)</span><span id="cfe0" class="ne mc it na b gy oe ng l nh ni">navigationController?.navigationBar.scrollEdgeAppearance = navigationBarAppearance</span><span id="e323" class="ne mc it na b gy oe ng l nh ni">navigationController?.navigationBar.compactAppearance = navigationBarAppearance</span><span id="bc48" class="ne mc it na b gy oe ng l nh ni">navigationController?.navigationBar.standardAppearance = navigationBarAppearance</span></pre><p id="1f90" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">一定要在所有不同的外观下测试你的导航条——例如，iPhone上的横向呈现为<code class="fe nj nk nl na b">compactAppearance</code>。你可能想要定制每一个外观来更好地适应它的使用，可能改变一些东西，比如字体颜色或者工具条背景。</p><h2 id="ace0" class="ne mc it bd md of og dn mh oh oi dp ml lh oj ok mn ll ol om mp lp on oo mr op bi translated"><strong class="ak">“状态条样式”</strong></h2><p id="4a3c" class="pw-post-body-paragraph ky kz it la b lb mt ju ld le mu jx lg lh mv lj lk ll mw ln lo lp mx lr ls lt im bi translated">状态栏定制已经过调整，可以更好地与新的<code class="fe nj nk nl na b">UIWindowScene</code>API配合使用。</p><p id="6c41" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated"><code class="fe nj nk nl na b">UIApplication.shared.statusBarStyle = .lightContent</code></p><p id="f98d" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">你不能再简单地在整个应用程序上设置<code class="fe nj nk nl na b">statusBarStyle</code>。你必须在每个V <code class="fe nj nk nl na b">iewController</code>的水平上做这件事，使用像下面这样的东西。如果您在导航控制器上这样做，它将为导航堆栈中的每个视图显示您想要的方式——消除了覆盖每个视图控制器的需要。</p><pre class="kj kk kl km gt mz na nb nc aw nd bi"><span id="7c99" class="ne mc it na b gy nf ng l nh ni"><strong class="na iu">override</strong> <strong class="na iu">var</strong> preferredStatusBarStyle: UIStatusBarStyle {</span><span id="500a" class="ne mc it na b gy oe ng l nh ni"><strong class="na iu">    return</strong> .lightContent</span><span id="17f2" class="ne mc it na b gy oe ng l nh ni">}</span></pre><h2 id="ba72" class="ne mc it bd md of og dn mh oh oi dp ml lh oj ok mn ll ol om mp lp on oo mr op bi translated"><strong class="ak">“ui webview”</strong></h2><p id="1d6a" class="pw-post-body-paragraph ky kz it la b lb mt ju ld le mu jx lg lh mv lj lk ll mw ln lo lp mx lr ls lt im bi translated">嗯，这是一个大问题。</p><p id="c232" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">商店中将不再允许引用<code class="fe nj nk nl na b">UIWebView</code>的应用。对于新的应用程序来说，这已经是事实了——所以你真的没有选择。<br/>记住，如果你用<code class="fe nj nk nl na b">UIWebView</code>替换<code class="fe nj nk nl na b">WKWebView</code>，苹果也有<a class="ae nn" href="https://developer.apple.com/app-store/review/guidelines/#design" rel="noopener ugc nofollow" target="_blank">新规定</a>你的应用程序的主要功能是网络视图，所以要小心。<br/> <br/>要警惕你的豆荚可能还会引用<code class="fe nj nk nl na b">UIWebView</code>，即使你没有。这在任何内置了某种形式网络的老式pod中都很常见，比如<a class="ae nn" href="https://github.com/AFNetworking" rel="noopener ugc nofollow" target="_blank"> AFNetworking </a>。<br/> <br/>如果你的应用不完全基于<code class="fe nj nk nl na b">UIWebView</code>，你应该很容易就能通过非常相似的API进行移植。在这里，您可以完全免费地获得很多性能改进。</p><div class="oq or gp gr os ot"><a href="https://developer.apple.com/documentation/webkit/wkwebview" rel="noopener  ugc nofollow" target="_blank"><div class="ou ab fo"><div class="ov ab ow cl cj ox"><h2 class="bd iu gy z fp oy fr fs oz fu fw is bi translated">WKWebView</h2><div class="pa l"><h3 class="bd b gy z fp oy fr fs oz fu fw dk translated">声明重要从iOS 8.0和OS X 10.10开始，使用WKWebView向你的应用添加网页内容。不要使用…</h3></div><div class="pb l"><p class="bd b dl z fp oy fr fs oz fu fw dk translated">developer.apple.com</p></div></div></div></a></div><h2 id="912b" class="ne mc it bd md of og dn mh oh oi dp ml lh oj ok mn ll ol om mp lp on oo mr op bi translated"><strong class="ak">“关键窗口”</strong></h2><p id="e631" class="pw-post-body-paragraph ky kz it la b lb mt ju ld le mu jx lg lh mv lj lk ll mw ln lo lp mx lr ls lt im bi translated">由于添加了场景委托，我们可能已经习惯的应用程序的某些属性已经被移除。您仍然可以访问它们，但是它们可能不会像您预期的那样运行。</p><p id="e524" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated"><code class="fe nj nk nl na b">UIApplication.shared.keyWindow</code>将向您显示错误:</p><blockquote class="pc pd pe"><p id="c402" class="ky kz pf la b lb lc ju ld le lf jx lg pg li lj lk ph lm ln lo pi lq lr ls lt im bi translated">"<code class="fe nj nk nl na b">keyWindow</code>在iOS 13.0中已被弃用:不应用于支持多个场景的应用程序，因为它会在所有连接的场景中返回一个关键窗口。"</p></blockquote><p id="ca2a" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">苹果在WWDC19上推荐的解决方案是简单地手动跟踪你的窗口。这样你就可以跟踪应用程序中的初始窗口，然后在运行过程中添加其他窗口。</p><p id="6e6f" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">这使得在整个窗口上呈现东西变得再一次微不足道，因为你可以确保你在正确的窗口上呈现，而不是随便一个窗口。想象一下，如果你在第二个窗口中做的事情在第一个窗口中出现了错误，这不是一个好的用户体验。<br/> <br/>如果你真的要抓取关键窗口，你可以迭代<code class="fe nj nk nl na b">UIApplication.shared.windows</code>，寻找第一个<code class="fe nj nk nl na b">.isKeyWindow</code>返回<code class="fe nj nk nl na b">true</code>的窗口。</p><p id="cfd5" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">这里有一个方便的向后兼容的扩展来做到这一点:</p><pre class="kj kk kl km gt mz na nb nc aw nd bi"><span id="8486" class="ne mc it na b gy nf ng l nh ni"> <br/>extension UIWindow {<br/>    static var key: UIWindow? {<br/>        if #available(iOS 13, *) {<br/>        return UIApplication.shared.windows.first { $0.isKeyWindow }<br/>        } else {<br/>        return UIApplication.shared.keyWindow<br/>        }<br/>    }<br/>}</span></pre></div><div class="ab cl lu lv hx lw" role="separator"><span class="lx bw bk ly lz ma"/><span class="lx bw bk ly lz ma"/><span class="lx bw bk ly lz"/></div><div class="im in io ip iq"><h1 id="b07e" class="mb mc it bd md me mf mg mh mi mj mk ml jz mm ka mn kc mo kd mp kf mq kg mr ms bi translated">结论</h1><p id="9064" class="pw-post-body-paragraph ky kz it la b lb mt ju ld le mu jx lg lh mv lj lk ll mw ln lo lp mx lr ls lt im bi translated">虽然这看起来像是相当多的工作——但当你完成一个为下一个最好的事情做好准备的项目时，这是值得的！</p></div></div>    
</body>
</html>