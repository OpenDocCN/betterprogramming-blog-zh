# 可扩展的 Ruby——并发性和并行性解释

> 原文：<https://betterprogramming.pub/scalable-ruby-concurrency-and-parallelism-explained-68b09a7aeb53>

## 以及为什么差异如此重要

![](img/4e88113aacdfeab0a2001eafbb8fa377.png)

谭爱红摄

几年前，Ruby 统治了网络。构建新的应用程序非常容易，有许多解决常见问题的方法，因此，构建新功能也很容易。

但是后来事情发生了变化。Twitter 努力让 Ruby 扩展，并切换到不同的平台来满足他们的性能需求。越来越多的声音指出 Ruby 太慢，无法满足网络的需求。

这产生了更容易扩展、更好扩展的新技术。[节点](https://en.wikipedia.org/wiki/Node.js)特别满足了这种需求，并围绕它创造了新的炒作。其他出现的技术还有 [Golang](https://golang.org/) 、[elixin](https://elixir-lang.org/)和 [Scala/Akka](https://akka.io/) 等等。

注意:当我谈论 Ruby 中的并发性时，我不会谈论多进程架构或如何使用负载平衡器。这篇文章的目标是展示如何在一个进程中利用 Ruby 中的并发性，并展示并行性和并发性之间的区别。

Node 是如何实现这种可伸缩性的？Node 运行在 V8 JavaScript 引擎上，采用了非常复杂和快速的事件循环。借助这一点和非阻塞 IO 操作，Node 可以处理大量并行传入请求。

这是否意味着节点也在*并行*中运行所有这些请求？事实上，没有。事件循环和非阻塞 IO 操作使 V8 可以并发运行请求，但不是并行的。

“等等，什么？”我听到你说。“有什么区别，我为什么要关心？”

# 什么是并发和并行？

## 并发

我发现并发性的一个非常准确的定义是这样的:

> “独立执行部门的协调和管理。这些执行可以真正并行，也可以简单地通过交错来管理。他们可以通过共享内存或消息传递进行交流。”

当谈到并发性时，我将只谈*通过交错*类型的并发性管理的*。*

让我们以 Node 为例来解释并发性，因为许多人都知道 Node，而且(几乎)每个人都知道 JavaScript。因此，让我们看一个例子，看看并发在实践中意味着什么。

假设我们有两个客户请求。其中一个想要更新员工的一些数据，另一个想要访问公司所有部门的列表。V8 发动机如何处理这种情况？

将首先处理第一个请求。例如，服务器检查是否允许用户保存客户。为此，应用程序向数据库发出请求。现在，它发生了！这个对数据库的请求是非阻塞的，这意味着应用程序不会等待响应而继续。因为在数据库响应之前，当前请求没有任何事情可做，所以它通知节点调度器它处于空闲状态。现在，节点可以处理第二个请求。

顺便说一下，这就是 JS 开发人员必须使用 async/await、promises 或 callbacks 的原因。所有这些技术都允许 JS 引擎继续其流程*和*在数据库发送数据后处理响应，而开发人员将代码放在一个地方。

## 这对 Ruby 意味着什么？

由于(几乎)所有的 web 应用程序都有大量的网络请求要处理，在 Ruby 中抑制性能的主要因素是请求和等待响应，因为它默认使用了一个**阻塞 IO** 。

稍后我们将看到我们 Ruby 开发人员可以做些什么来使并发工作。

## 平行

定义如下:

*真正同时执行或评价事物*

并行更容易理解，因为它就像你想象的那样工作。两个请求到达服务器，两个请求同时从服务器并行处理。对于计算机来说，这意味着两个内核同时工作。

# 如何在 Ruby 中实现(非并行)并发

现在我们来看看这篇文章的目标:*如何在 Ruby 中实现并发性？*

如上所述，这是可能的，但现在还不那么容易。Ruby 没有 async/await，它没有承诺，要使用非阻塞 IO，你必须编写自己的 ORM 适配器。

“但是我们有线！”我听到你尖叫。是的，你是对的。对于线程，我们可以使用并发。你会怎么做？下面是一个关于[Rails](https://guides.rubyonrails.org/active_record_basics.html)active record 的简单例子:

## 与节点并发相比的缺点

每个线程映射到一个操作系统线程。因此，不可能创建数百甚至数千个线程。开发商要做更多的仪式。换句话说，他必须更明确地做很多事情。

因为我们使用线程，而 Ruby 线程转换成 OS 线程…

# 我们也能在 Ruby 中利用并行性吗？

不幸的是，不是在一个过程中。Ruby 有一种叫做 GVL(Global Virtual Machine Lock——有时称为 GIL——全局解释器锁)的东西。通过这种机制，Ruby 可以确保当前只有一个操作系统线程在运行。本质上，这是一个全局标志，用于显示在当前线程中运行代码是否合适。

对于 IO 操作，比如上面例子中的数据库请求，这完全没问题，因为线程正在等待数据库，而您的操作系统无论如何都会让它进入睡眠状态。因此，可以处理第二个线程——至少直到它因为数据库请求或者因为操作系统切换线程而被置于睡眠状态。

但是对于 Ruby 代码来说，就有点不同了。您可以在没有 IO 绑定操作的情况下使用 Ruby 线程，但是您不会看到任何性能提升。MRI Ruby 会检查 GVL，只有当这个标志为真时，它才会运行您的代码。

## 你为什么要创造像 GVL 这样的东西？

Ruby 使用 GVL 的原因是基于它的理念:让程序员快乐！

编写多线程程序是非常困难的。GVL 使这变得更容易，因为你不能(如此容易地)有一个[死锁](https://en.wikipedia.org/wiki/Deadlock)，或者其他在多线程程序中很容易发生的讨厌的事情。

顺便提一下， [Python 也在使用 GIL](https://wiki.python.org/moin/GlobalInterpreterLock) 。所以，这是语言设计者经常做的事情。

# **那么不同的 Ruby 实现呢？**

## JRuby

[JRuby](https://www.jruby.org/) 可以使用真正的并行。没有任何 GVL 会阻止你的代码。当然，缺点是，现在你要负责确保你的代码是线程安全的，并且你要避免死锁和其他不好的事情。

## 松露红宝石

[松露红宝石](https://github.com/oracle/truffleruby)也不使用 GVL。甚至有一些讨论更进一步，试图把所有东西都放在一个[互斥体](https://en.wikipedia.org/wiki/Mutual_exclusion)下，如果——且仅如果——你的代码使用线程。这样，您将拥有 GVL 的优势，以及多线程应用程序带来的性能提升。但是，现在，这仍然是一个实验性的功能。只有时间才能证明它是否会成为有用的东西。

## 回到未来— Ruby 3

[Matz](https://twitter.com/yukihiro_matz) 已经认识到并行性和并发性的问题。为此他已经公布了[《并发之年》](https://rubykaigi.org/2019/presentations/yukihiro_matz.html)(此视频只有日文)。Ruby 如何实现与 Node 类似甚至更好的可伸缩性呢？这里有三个项目想让这成为可能

- [公会](https://www.youtube.com/watch?v=XiujvihOLq8)
- [并发纤维](https://www.codeotaku.com/journal/2018-11/fibers-are-the-right-solution/index)-
-[自动::线程](https://bugs.ruby-lang.org/issues/13618)(这个项目可能死了)

# 可扩展性—真的重要吗？

大多数时候答案是否定的。当你开始一个新项目或应用程序时，你的应用程序只有非常非常少的用户。Ruby(也叫 Rails)可以很好地处理一般数量的用户，没有任何问题。很多公司都表现出了这一点。Ruby 甚至可以处理许多用户，正如 Basecamp、Shopify、GitHub 和 AirBnB 所显示的那样。而且，如果你来到像 Twitter 这样需要更高性能的地方，你会有更多的资源。更多的钱来打破一个庞然大物，更多的领域知识，以及更多的技术知识，因为到那时你可能会有雇员。

(MRI) Ruby 的未来似乎把这个障碍推得更远了，所以你可以愉快地用你喜欢的语言编写代码，并且非常高效！

*不是中等会员？* [*在这里报名*](https://grnt-grdwhl.medium.com/membership) *并支持我的写作过程！*