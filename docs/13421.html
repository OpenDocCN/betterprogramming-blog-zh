<html>
<head>
<title>Exploring Jetpack Composes’ Dependencies Injection Using Hilt</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用Hilt探索Jetpack组件的依赖注入</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/dependencies-injection-jetpack-compose-using-hilt-bd4f76ac6c22?source=collection_archive---------1-----------------------#2022-08-25">https://betterprogramming.pub/dependencies-injection-jetpack-compose-using-hilt-bd4f76ac6c22?source=collection_archive---------1-----------------------#2022-08-25</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="fc8e" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">创建松散耦合的干净代码的技巧</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/d797663a1b7a8eb0bd29d95e4b45e0af.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*LEzFz1ScviXgn985"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">恩伯·纳瓦罗在<a class="ae kv" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>拍摄的照片</p></figure><p id="501e" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">您可以在下面找到以前关于Jetpack Compose的教程:</p><ul class=""><li id="c6d7" class="ls lt iq ky b kz la lc ld lf lu lj lv ln lw lr lx ly lz ma bi translated"><a class="ae kv" rel="noopener ugc nofollow" target="_blank" href="/a-glimse-into-jetpack-compose-by-building-an-app-a7869723d4e8">通过构建应用程序一瞥Jetpack Compose</a></li><li id="04f0" class="ls lt iq ky b kz mb lc mc lf md lj me ln mf lr lx ly lz ma bi translated"><a class="ae kv" rel="noopener ugc nofollow" target="_blank" href="/layouting-in-jetpack-compose-8c16e687bfe5">在Jetpack组合中布局</a></li><li id="c8d3" class="ls lt iq ky b kz mb lc mc lf md lj me ln mf lr lx ly lz ma bi translated"><a class="ae kv" rel="noopener ugc nofollow" target="_blank" href="/navigation-routes-in-jetpack-compose-ce2e0337ed28">Jetpack撰写中的导航</a></li><li id="852d" class="ls lt iq ky b kz mb lc mc lf md lj me ln mf lr lx ly lz ma bi translated"><a class="ae kv" rel="noopener ugc nofollow" target="_blank" href="/mvvm-in-jetpack-compose-part-4-fe757a1a1b84">在Jetpack Compose中开始使用MVVM</a></li><li id="826d" class="ls lt iq ky b kz mb lc mc lf md lj me ln mf lr lx ly lz ma bi translated"><a class="ae kv" rel="noopener ugc nofollow" target="_blank" href="/viewmodel-to-view-in-jetpack-compose-7c7183b54fb5">在Jetpack撰写中查看的视图模型</a></li></ul><p id="b7de" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在本文中，我们将学习如何在Jetpack Compose中使用<code class="fe mg mh mi mj b">Dagger-Hilt</code>为我们的应用程序注入依赖注入。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi mk"><img src="../Images/c7cbd2d77e191074e693b6a18f8b1df6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*UJxZUSibWKNQ8GLg"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">由<a class="ae kv" href="https://unsplash.com/@markusspiske?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Markus Spiske </a>在<a class="ae kv" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</p></figure><h1 id="5e98" class="ml mm iq bd mn mo mp mq mr ms mt mu mv jw mw jx mx jz my ka mz kc na kd nb nc bi translated">什么是依赖注入？</h1><p id="537a" class="pw-post-body-paragraph kw kx iq ky b kz nd jr lb lc ne ju le lf nf lh li lj ng ll lm ln nh lp lq lr ij bi translated">依赖注入是一种设计模式，旨在通过形成控制反转来分离对构造对象和使用对象的关注，从而产生松散耦合的程序。</p><p id="22b2" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在Android中，有两种著名的依赖注入方法。<code class="fe mg mh mi mj b">Koin</code>和<code class="fe mg mh mi mj b">Dagger-Hilt</code>。关于选择什么的更多信息，你可以参考这里。</p><div class="ni nj gp gr nk nl"><a rel="noopener  ugc nofollow" target="_blank" href="/dagger-hilt-vs-koin-dependency-injection-for-jetpack-compose-apps-2e598f00aff"><div class="nm ab fo"><div class="nn ab no cl cj np"><h2 class="bd ir gy z fp nq fr fs nr fu fw ip bi translated">匕首/剑柄与锦鲤的Jetpack组成应用程序</h2><div class="ns l"><h3 class="bd b gy z fp nq fr fs nr fu fw dk translated">匕首和锦鲤的优缺点</h3></div><div class="nt l"><p class="bd b dl z fp nq fr fs nr fu fw dk translated">better编程. pub</p></div></div><div class="nu l"><div class="nv l nw nx ny nu nz kp nl"/></div></div></a></div><div class="ni nj gp gr nk nl"><a href="https://medium.com/gradeup/dependency-injection-dagger-hilt-vs-koin-ab2f7f85e6c6" rel="noopener follow" target="_blank"><div class="nm ab fo"><div class="nn ab no cl cj np"><h2 class="bd ir gy z fp nq fr fs nr fu fw ip bi translated">依赖注入:匕首之柄vs Koin</h2><div class="ns l"><h3 class="bd b gy z fp nq fr fs nr fu fw dk translated">从零到英雄的依赖注入</h3></div><div class="nt l"><p class="bd b dl z fp nq fr fs nr fu fw dk translated">medium.com</p></div></div><div class="nu l"><div class="oa l nw nx ny nu nz kp nl"/></div></div></a></div><p id="045c" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">使用<code class="fe mg mh mi mj b">Dagger-Hilt</code>还是<code class="fe mg mh mi mj b">Koin</code>并不重要，因为它们服务于相同的目的，但是在本文中，我将使用<code class="fe mg mh mi mj b">Dagger-Hilt</code>。</p><h1 id="53ef" class="ml mm iq bd mn mo mp mq mr ms mt mu mv jw mw jx mx jz my ka mz kc na kd nb nc bi translated">我们开始吧</h1><p id="da9a" class="pw-post-body-paragraph kw kx iq ky b kz nd jr lb lc ne ju le lf nf lh li lj ng ll lm ln nh lp lq lr ij bi translated">我们必须在应用程序中设置<code class="fe mg mh mi mj b">Dagger-Hilt</code>。在项目级别打开<code class="fe mg mh mi mj b">build.gradle</code>并复制以下代码:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ob oc l"/></div></figure><p id="73c0" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">打开<code class="fe mg mh mi mj b">build.gradle</code> app level，复制这段代码:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ob oc l"/></div></figure><p id="6f5c" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">创建<code class="fe mg mh mi mj b">JetpackComposeApp.kt</code>并添加以下代码:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ob oc l"/></div></figure><p id="61ba" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">转到<code class="fe mg mh mi mj b">AndroidManifest.xml</code>并将该属性添加到<code class="fe mg mh mi mj b">application tag</code>中:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ob oc l"/></div></figure><p id="65a2" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这就是我们在应用程序中设置<code class="fe mg mh mi mj b">Dagger-Hilt</code>的方式，因为这是一个强制步骤。特别是你需要让<code class="fe mg mh mi mj b">JetpackComposeApp.kt</code>有<code class="fe mg mh mi mj b">@HiltComposeApp</code>注释来注释<code class="fe mg mh mi mj b">Application</code>类，并通过在<code class="fe mg mh mi mj b">AndroidManifest.xml</code>中定义<code class="fe mg mh mi mj b">android:name=”.JetpackComposeApp”</code>来让那个<code class="fe mg mh mi mj b">Dagger-Hilt</code>在我们的应用中被识别。</p><p id="acfd" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">现在我们可以打开<code class="fe mg mh mi mj b">MainActivity.kt</code>并添加以下代码:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ob oc l"/></div></figure><p id="05c4" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这个注释使得<code class="fe mg mh mi mj b">Dagger-Hilt</code>可以向<code class="fe mg mh mi mj b">MainActivity.kt</code>注入依赖关系。注意，我们可以将<code class="fe mg mh mi mj b">@AndroidEntryPoint</code>放置到<code class="fe mg mh mi mj b">MainActivity.kt</code>中，因为<code class="fe mg mh mi mj b">MainActivity.kt</code>是具有<code class="fe mg mh mi mj b">HomeFragment.kt</code>和<code class="fe mg mh mi mj b">DetailFragment.kt</code>等片段的地方。每个片段都与MVVM的<code class="fe mg mh mi mj b">ViewModel</code>和<code class="fe mg mh mi mj b">Model</code>有关。</p><p id="aa8d" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在MVVM <code class="fe mg mh mi mj b">Model</code>板块，我们将在<code class="fe mg mh mi mj b">Dagger-Hilt</code>制作模块，增加一些服务功能。创建<code class="fe mg mh mi mj b">AppModules.kt</code>并添加以下代码:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ob oc l"/></div></figure><p id="d451" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">由此，<code class="fe mg mh mi mj b">AppModules.kt</code>在匕首-刀柄上标记为<code class="fe mg mh mi mj b">@Module</code>级。此外，该类将使用<code class="fe mg mh mi mj b">SingletonComponent</code>安装在应用程序级别。所以这个类将首先被执行，并且只要应用程序还在运行，它就将继续存在。</p><p id="6656" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这样，我们可以实现对<code class="fe mg mh mi mj b">AppModules.kt</code>的服务，该服务将分离紧耦合的代码，稍后将对此进行解释。</p><p id="66f6" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">打开<code class="fe mg mh mi mj b">GamesService.kt</code>和<code class="fe mg mh mi mj b">GamesRepositoryImpl.kt</code>。看看下面的代码:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ob oc l"/></div></figure><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ob oc l"/></div></figure><p id="e88f" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">每次调用<code class="fe mg mh mi mj b">GamesRepositoryImpl.kt</code>时，都会初始化<code class="fe mg mh mi mj b">GamesServices.getInstance()</code>。这使得<code class="fe mg mh mi mj b">GamesRepositoryImpl.kt</code>与<code class="fe mg mh mi mj b">GamesServices.kt</code>紧密耦合。为避免这种情况，将服务代码移动到<code class="fe mg mh mi mj b">AppModules.kt</code>，如下所示:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ob oc l"/></div></figure><p id="5b8c" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">现在<code class="fe mg mh mi mj b">AppModules.kt</code>将使用<code class="fe mg mh mi mj b">retrofit</code>提供服务，并将服务注入到存储库中，如上面的代码所述。</p><p id="432e" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">因为服务和实现已经由<code class="fe mg mh mi mj b">AppModule.kt</code>负责，我们将把<code class="fe mg mh mi mj b">GamesService.kt</code>和<code class="fe mg mh mi mj b">GamesRepositoryImpl.kt</code>改为:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ob oc l"/></div></figure><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ob oc l"/></div></figure><p id="6a4e" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">现在<code class="fe mg mh mi mj b">GamesRepositoryImpl.kt</code>将不会与<code class="fe mg mh mi mj b">GamesServices.kt</code>紧密耦合。最重要的是，<code class="fe mg mh mi mj b">GamesRepositoryImpl.kt</code>为<code class="fe mg mh mi mj b">Dagger-Hilt</code>添加了<code class="fe mg mh mi mj b">@Singleton</code>注释，以便知道这个类是<code class="fe mg mh mi mj b">Singleton</code>类。</p><p id="7fa3" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">有关<code class="fe mg mh mi mj b">Singleton</code>的更多信息，请参考此处:</p><div class="ni nj gp gr nk nl"><a href="https://www.patterns.dev/posts/singleton-pattern/" rel="noopener  ugc nofollow" target="_blank"><div class="nm ab fo"><div class="nn ab no cl cj np"><h2 class="bd ir gy z fp nq fr fs nr fu fw ip bi translated">单一模式</h2><div class="ns l"><h3 class="bd b gy z fp nq fr fs nr fu fw dk translated">单例是可以被实例化一次的类，并且可以被全局访问。这个单一实例可以共享…</h3></div><div class="nt l"><p class="bd b dl z fp nq fr fs nr fu fw dk translated">www.patterns.dev</p></div></div><div class="nu l"><div class="od l nw nx ny nu nz kp nl"/></div></div></a></div><p id="0ce4" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">您甚至可以在<code class="fe mg mh mi mj b">AppModule.kt</code>中注入<code class="fe mg mh mi mj b">String</code>以及下面的代码:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ob oc l"/></div></figure><p id="382b" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">注意，如果我们提供多个相同的数据类型，我们将使用注释<code class="fe mg mh mi mj b">@Named</code>在<code class="fe mg mh mi mj b">Dagger-Hilt</code>中进行区分。</p><p id="68f1" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">所以我们只做了一些会影响<code class="fe mg mh mi mj b">GamesRepositoryImpl.kt</code>和<code class="fe mg mh mi mj b">GamesService.kt</code>的改动。到目前为止，它们的代码都是这样的:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ob oc l"/></div></figure><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ob oc l"/></div></figure><p id="09e3" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在<code class="fe mg mh mi mj b">ViewModel</code>部分，我们只需要声明<code class="fe mg mh mi mj b">ViewModel</code>可以像这样被认定为匕首柄类。打开<code class="fe mg mh mi mj b">HomeViewModel.kt</code>和<code class="fe mg mh mi mj b">DetailViewModel.kt</code>，添加以下内容:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ob oc l"/></div></figure><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ob oc l"/></div></figure><p id="df4c" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">现在，<code class="fe mg mh mi mj b">ViewModel</code>被宣布为匕首柄<code class="fe mg mh mi mj b">ViewModel</code>级。</p><p id="59f6" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">现在剩下的都在<code class="fe mg mh mi mj b">View</code>部分了。只需打开<code class="fe mg mh mi mj b">HomeFragment.kt</code>和<code class="fe mg mh mi mj b">DetailFragment.kt</code>并改变这条线:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ob oc l"/></div></figure><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ob oc l"/></div></figure><p id="83f8" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">现在，重建应用程序，并开始运行它。您的应用程序将像以前一样运行。但是代码本身将是松散耦合的，也更加简洁。</p><blockquote class="oe of og"><p id="4a95" class="kw kx oh ky b kz la jr lb lc ld ju le oi lg lh li oj lk ll lm ok lo lp lq lr ij bi translated">这是不利的一面:任何时候你想改变与匕首之柄相关的职业，你都必须重建它。否则，它不会按预期运行。</p></blockquote><h1 id="2573" class="ml mm iq bd mn mo mp mq mr ms mt mu mv jw mw jx mx jz my ka mz kc na kd nb nc bi translated">结论</h1><p id="593d" class="pw-post-body-paragraph kw kx iq ky b kz nd jr lb lc ne ju le lf nf lh li lj ng ll lm ln nh lp lq lr ij bi translated">我们已经了解了如何使用Jetpack Compose中的<code class="fe mg mh mi mj b">Dagger-Hilt</code>为我们的应用程序注入依赖注入。</p><p id="3fb7" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这篇文章的所有代码可以在这里查看。</p><p id="bd1a" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在下一篇文章中，我将讲述如何在我们的应用程序中使用模块化来划分我们的功能。</p></div></div>    
</body>
</html>