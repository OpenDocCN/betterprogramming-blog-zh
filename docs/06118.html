<html>
<head>
<title>22 Kotlin Extensions for Cleaner Code</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">22个Kotlin扩展，用于清理代码</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/22-kotlin-extensions-for-cleaner-code-acadcbd49357?source=collection_archive---------1-----------------------#2020-09-03">https://betterprogramming.pub/22-kotlin-extensions-for-cleaner-code-acadcbd49357?source=collection_archive---------1-----------------------#2020-09-03</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="7a4b" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">构建移动应用程序时更有效率</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/bab172d3b0ba786da53dd5db551b1e06.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*PyR14LD8dR91kq6Z"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">乔纳森·肯珀在<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</p></figure><p id="5785" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我是一名移动开发人员，在Kotlin出现后我立即改用它的原因之一是因为它支持扩展。扩展允许您将方法添加到任何现有的类中，甚至添加到<code class="fe lv lw lx ly b">Any</code>或可选的类型中(例如，<code class="fe lv lw lx ly b">Int?</code>)。</p><p id="d572" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果扩展基类，所有派生类都会自动获得该扩展。您还可以从扩展中覆盖方法，这使得这种机制更加灵活和强大。</p><p id="f301" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我用的是Android Studio 4.0.1中的Android版Kotlin 1.4.0。我假设所有的方法都将从Kotlin调用，而不是Java。即便如此，大部分扩展也可以在Kotlin的其他版本中工作，其中一些可以在其他环境中工作。</p></div><div class="ab cl lz ma hx mb" role="separator"><span class="mc bw bk md me mf"/><span class="mc bw bk md me mf"/><span class="mc bw bk md me"/></div><div class="im in io ip iq"><h1 id="40df" class="mg mh it bd mi mj mk ml mm mn mo mp mq jz mr ka ms kc mt kd mu kf mv kg mw mx bi translated">“Int.toDate()”和“Int.asDate”</h1><p id="b61c" class="pw-post-body-paragraph kz la it lb b lc my ju le lf mz jx lh li na lk ll lm nb lo lp lq nc ls lt lu im bi translated">我们经常获得时间戳形式的日期和时间。一个<em class="nd">时间戳</em>是自1970年1月1日以来的秒数(有时是毫秒)。这个时刻被称为<em class="nd">纪元</em>。</p><p id="4849" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这个简单的扩展将秒转换成一个<code class="fe lv lw lx ly b">Date</code>对象:</p><p id="c24d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">有两个选择:一个<code class="fe lv lw lx ly b">function</code>或一个<code class="fe lv lw lx ly b">read-only</code>的财产。它们在功能上是平等的。用哪个是口味问题。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ne nf l"/></div></figure><h2 id="d241" class="ng mh it bd mi nh ni dn mm nj nk dp mq li nl nm ms lm nn no mu lq np nq mw nr bi translated">使用</h2><pre class="kj kk kl km gt ns ly nt nu aw nv bi"><span id="56f3" class="ng mh it ly b gy nw nx l ny nz"><em class="nd">val </em>json = JSONObject();<br/>json.put("date", 1598435781)<br/><br/><em class="nd">val </em>date = json.getIntOrNull("date")?.asDate</span></pre><p id="1829" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu">注意:</strong>在这个例子中，我使用了另一个扩展— <code class="fe lv lw lx ly b">getIntOrNull</code>。如果它存在于JSON中，它返回一个int值，否则返回<code class="fe lv lw lx ly b">null</code>。您可以在这里找到完整的源代码:</p><div class="oa ob gp gr oc od"><a href="https://medium.com/better-programming/10-useful-kotlin-string-extensions-46772b653f71" rel="noopener follow" target="_blank"><div class="oe ab fo"><div class="of ab og cl cj oh"><h2 class="bd iu gy z fp oi fr fs oj fu fw is bi translated">10个有用的Kotlin字符串扩展</h2><div class="ok l"><h3 class="bd b gy z fp oi fr fs oj fu fw dk translated">用于电子邮件验证、JSON解析等的语法糖</h3></div><div class="ol l"><p class="bd b dl z fp oi fr fs oj fu fw dk translated">medium.com</p></div></div><div class="om l"><div class="on l oo op oq om or ks od"/></div></div></a></div></div><div class="ab cl lz ma hx mb" role="separator"><span class="mc bw bk md me mf"/><span class="mc bw bk md me mf"/><span class="mc bw bk md me"/></div><div class="im in io ip iq"><h1 id="4a1f" class="mg mh it bd mi mj mk ml mm mn mo mp mq jz mr ka ms kc mt kd mu kf mv kg mw mx bi translated">“String.toDate(…)”和“Date.toString(…)”</h1><p id="bf45" class="pw-post-body-paragraph kz la it lb b lc my ju le lf mz jx lh li na lk ll lm nb lo lp lq nc ls lt lu im bi translated">另一种常见的对<code class="fe lv lw lx ly b">Date</code>对象的转换是将其转换成字符串，然后再返回。我说的不是标准的Java/Kotlin <code class="fe lv lw lx ly b">toString()</code>方法。在我们的例子中，我们需要指定一种格式。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ne nf l"/></div></figure><p id="a1d0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu">性能警告:</strong>在这个例子中，我们每次都创建一个<code class="fe lv lw lx ly b">SimpleDateFormat</code>对象。如果您在列表中使用这个扩展，或者从API中解析一个大的响应，请考虑从扩展代码中移除<code class="fe lv lw lx ly b">val dateFormatter = SimpleDateFormat(format, Locale.US)</code>,并将其作为全局变量或静态类成员放入。</p><h2 id="93c2" class="ng mh it bd mi nh ni dn mm nj nk dp mq li nl nm ms lm nn no mu lq np nq mw nr bi translated">使用</h2><pre class="kj kk kl km gt ns ly nt nu aw nv bi"><span id="0c83" class="ng mh it ly b gy nw nx l ny nz"><em class="nd">val </em>format = "yyyy-MM-dd HH:mm:ss"<br/><em class="nd">val </em>date = Date()<br/><em class="nd">val </em>str = date.<em class="nd">toString</em>(format)<br/><em class="nd">val </em>date2 = str.<em class="nd">toDate</em>(format)</span></pre></div><div class="ab cl lz ma hx mb" role="separator"><span class="mc bw bk md me mf"/><span class="mc bw bk md me mf"/><span class="mc bw bk md me"/></div><div class="im in io ip iq"><h1 id="7f52" class="mg mh it bd mi mj mk ml mm mn mo mp mq jz mr ka ms kc mt kd mu kf mv kg mw mx bi translated">'和' Int.centsToDollarsFormat()'</h1><p id="e8f5" class="pw-post-body-paragraph kz la it lb b lc my ju le lf mz jx lh li na lk ll lm nb lo lp lq nc ls lt lu im bi translated">如果处理价格，那么<code class="fe lv lw lx ly b">Floats</code>和<code class="fe lv lw lx ly b">Doubles</code>可能会有精度问题。代表价格的一种流行方式是<code class="fe lv lw lx ly b">Ints</code>。但是，您不是用主要货币(例如，美元或欧元)来存储值，而是用货币单位(例如，美分)来表示它们。</p><p id="a19b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">您需要在<code class="fe lv lw lx ly b">Int</code>内进行所有的计算，并且只向用户显示最终值(转换为<code class="fe lv lw lx ly b">Double</code>或直接转换为<code class="fe lv lw lx ly b">String</code>)。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ne nf l"/></div></figure><h2 id="293e" class="ng mh it bd mi nh ni dn mm nj nk dp mq li nl nm ms lm nn no mu lq np nq mw nr bi translated">使用</h2><pre class="kj kk kl km gt ns ly nt nu aw nv bi"><span id="ac7c" class="ng mh it ly b gy nw nx l ny nz"><em class="nd">val </em>amount = 4999<br/><em class="nd">val </em>doubleAmount = amount.<em class="nd">centsToDollars</em>()<br/><em class="nd">val </em>priceTag = amount.<em class="nd">centsToDollarsFormat</em>("\$")</span></pre></div><div class="ab cl lz ma hx mb" role="separator"><span class="mc bw bk md me mf"/><span class="mc bw bk md me mf"/><span class="mc bw bk md me"/></div><div class="im in io ip iq"><h1 id="5b08" class="mg mh it bd mi mj mk ml mm mn mo mp mq jz mr ka ms kc mt kd mu kf mv kg mw mx bi translated">Double.toPrice()'</h1><p id="e0e8" class="pw-post-body-paragraph kz la it lb b lc my ju le lf mz jx lh li na lk ll lm nb lo lp lq nc ls lt lu im bi translated">处理价格时另一个有用的扩展是分组格式。在大多数情况下，在一个应用程序中，我们只有一套价格格式规则。一个扩展可以在整个应用程序中使用，以显示价格。</p><p id="d976" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在这个扩展中，我们使用两个小数(货币)数字，中间显示一个逗号，并用一个点分隔三个数字中的每一个，以使价格更容易阅读。这次我们用<code class="fe lv lw lx ly b">Double</code>。将<code class="fe lv lw lx ly b">Int</code>转换为<code class="fe lv lw lx ly b">Double</code>可以通过前面章节中的<code class="fe lv lw lx ly b">centsToDollars()</code>扩展来完成。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ne nf l"/></div></figure><h2 id="75d6" class="ng mh it bd mi nh ni dn mm nj nk dp mq li nl nm ms lm nn no mu lq np nq mw nr bi translated">使用</h2><pre class="kj kk kl km gt ns ly nt nu aw nv bi"><span id="9a38" class="ng mh it ly b gy nw nx l ny nz"><em class="nd">val </em>price = 123456789.5.<em class="nd">toPrice</em>()</span></pre></div><div class="ab cl lz ma hx mb" role="separator"><span class="mc bw bk md me mf"/><span class="mc bw bk md me mf"/><span class="mc bw bk md me"/></div><div class="im in io ip iq"><h1 id="9cbd" class="mg mh it bd mi mj mk ml mm mn mo mp mq jz mr ka ms kc mt kd mu kf mv kg mw mx bi translated">' String.toLocation(…)'</h1><p id="269e" class="pw-post-body-paragraph kz la it lb b lc my ju le lf mz jx lh li na lk ll lm nb lo lp lq nc ls lt lu im bi translated">当你使用一个API并得到一个对象的坐标时，你可能会得到两个不同的字段。但有时它是一个字段，用逗号分隔纬度和经度。</p><p id="2061" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">有了这个扩展，我们可以用一行代码将它们转换到Android位置:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ne nf l"/></div></figure><h2 id="3e4d" class="ng mh it bd mi nh ni dn mm nj nk dp mq li nl nm ms lm nn no mu lq np nq mw nr bi translated">使用</h2><pre class="kj kk kl km gt ns ly nt nu aw nv bi"><span id="83db" class="ng mh it ly b gy nw nx l ny nz"><em class="nd">val </em>apiLoc = "41.6168, 41.6367".<em class="nd">toLocation</em>("API")</span></pre><p id="fdc1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">类似地，您可以从Google Maps包中创建一个将<code class="fe lv lw lx ly b">String</code>转换为<code class="fe lv lw lx ly b">LatLng</code>的扩展。在这种情况下，您甚至不需要指定位置提供者。</p></div><div class="ab cl lz ma hx mb" role="separator"><span class="mc bw bk md me mf"/><span class="mc bw bk md me mf"/><span class="mc bw bk md me"/></div><div class="im in io ip iq"><h1 id="bc8b" class="mg mh it bd mi mj mk ml mm mn mo mp mq jz mr ka ms kc mt kd mu kf mv kg mw mx bi translated">String.containsOnlyDigits '和' String.isAlphanumeric '</h1><p id="5fef" class="pw-post-body-paragraph kz la it lb b lc my ju le lf mz jx lh li na lk ll lm nb lo lp lq nc ls lt lu im bi translated">先说一个<code class="fe lv lw lx ly b">String</code>的属性。它们可以为空，也可以不为空，例如，它们可以只包含数字或字母数字字符。这些扩展允许您在一行中验证一个字符串:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ne nf l"/></div></figure><h2 id="6cbb" class="ng mh it bd mi nh ni dn mm nj nk dp mq li nl nm ms lm nn no mu lq np nq mw nr bi translated">使用</h2><pre class="kj kk kl km gt ns ly nt nu aw nv bi"><span id="64e8" class="ng mh it ly b gy nw nx l ny nz"><em class="nd">val </em>digitsOnly = "12345".<em class="nd">containsDigitOnly<br/>val </em>notDigitsOnly = "abc12345".<em class="nd">containsDigitOnly<br/>val </em>alphaNumeric = "abc123".<em class="nd">isAlphanumeric<br/>val </em>notAlphanumeric = "ab.2a#1".<em class="nd">isAlphanumeric</em></span></pre></div><div class="ab cl lz ma hx mb" role="separator"><span class="mc bw bk md me mf"/><span class="mc bw bk md me mf"/><span class="mc bw bk md me"/></div><div class="im in io ip iq"><h1 id="fed3" class="mg mh it bd mi mj mk ml mm mn mo mp mq jz mr ka ms kc mt kd mu kf mv kg mw mx bi translated">“Context.versionNumber”和“Context.versionCode”</h1><p id="e531" class="pw-post-body-paragraph kz la it lb b lc my ju le lf mz jx lh li na lk ll lm nb lo lp lq nc ls lt lu im bi translated">在Android应用程序中，在“关于”或“支持”屏幕上显示版本号是一个好习惯。它将帮助用户了解他们是否需要更新，并在报告错误时提供有价值的信息。标准的Android功能需要几行代码和异常处理。这个扩展将允许您在一行中获得版本号或代码:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ne nf l"/></div></figure><p id="e00f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">用法:</p><pre class="kj kk kl km gt ns ly nt nu aw nv bi"><span id="6cb3" class="ng mh it ly b gy nw nx l ny nz"><em class="nd">val </em>vn = <em class="nd">versionName </em>?: "Unknown"<br/><em class="nd">val </em>vc = <em class="nd">versionCode</em>?.toString() ?: "Unknown"<br/><em class="nd">val </em>appVersion = "App Version: $vn ($vc)"</span></pre></div><div class="ab cl lz ma hx mb" role="separator"><span class="mc bw bk md me mf"/><span class="mc bw bk md me mf"/><span class="mc bw bk md me"/></div><div class="im in io ip iq"><h1 id="9921" class="mg mh it bd mi mj mk ml mm mn mo mp mq jz mr ka ms kc mt kd mu kf mv kg mw mx bi translated">' Context.screenSize '</h1><p id="bad0" class="pw-post-body-paragraph kz la it lb b lc my ju le lf mz jx lh li na lk ll lm nb lo lp lq nc ls lt lu im bi translated">Android的另一个有用的扩展是<code class="fe lv lw lx ly b">Context</code>扩展，它允许你获得设备的屏幕尺寸。这个扩展返回以像素为单位的屏幕尺寸:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ne nf l"/></div></figure><h2 id="d77b" class="ng mh it bd mi nh ni dn mm nj nk dp mq li nl nm ms lm nn no mu lq np nq mw nr bi translated">使用</h2><pre class="kj kk kl km gt ns ly nt nu aw nv bi"><span id="0c29" class="ng mh it ly b gy nw nx l ny nz">Log.d(TAG, "User's screen size: ${<em class="nd">screenSize</em>.x}x${<em class="nd">screenSize</em>.y}")</span></pre></div><div class="ab cl lz ma hx mb" role="separator"><span class="mc bw bk md me mf"/><span class="mc bw bk md me mf"/><span class="mc bw bk md me"/></div><div class="im in io ip iq"><h1 id="9fe7" class="mg mh it bd mi mj mk ml mm mn mo mp mq jz mr ka ms kc mt kd mu kf mv kg mw mx bi translated">任何.设备名称</h1><p id="561e" class="pw-post-body-paragraph kz la it lb b lc my ju le lf mz jx lh li na lk ll lm nb lo lp lq nc ls lt lu im bi translated">是否应该延长<code class="fe lv lw lx ly b">Any</code>值得商榷。如果你这样做了，函数会全局出现，所以基本上，这和声明一个全局函数是一样的。</p><p id="06cf" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在我们的下一个扩展中，我们将获得一个Android设备的名称。由于它不需要任何上下文，我们将把它作为一个<code class="fe lv lw lx ly b">Any</code>扩展:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ne nf l"/></div></figure><h2 id="fa6e" class="ng mh it bd mi nh ni dn mm nj nk dp mq li nl nm ms lm nn no mu lq np nq mw nr bi translated">使用</h2><pre class="kj kk kl km gt ns ly nt nu aw nv bi"><span id="0812" class="ng mh it ly b gy nw nx l ny nz">Log.d(TAG, "User's device: $<em class="nd">deviceName</em>")</span></pre></div><div class="ab cl lz ma hx mb" role="separator"><span class="mc bw bk md me mf"/><span class="mc bw bk md me mf"/><span class="mc bw bk md me"/></div><div class="im in io ip iq"><h1 id="ff3e" class="mg mh it bd mi mj mk ml mm mn mo mp mq jz mr ka ms kc mt kd mu kf mv kg mw mx bi translated">T.weak</h1><p id="4022" class="pw-post-body-paragraph kz la it lb b lc my ju le lf mz jx lh li na lk ll lm nb lo lp lq nc ls lt lu im bi translated">接下来的情况就有点复杂了。假设我们有一个<code class="fe lv lw lx ly b">Activity</code>和一个<code class="fe lv lw lx ly b">ListView</code>，其中有许多单元格。每个细胞都能给出一些反馈。假设它有一个委托接口，我们将活动本身传递给一个单元，因为它实现了单元的接口:</p><pre class="kj kk kl km gt ns ly nt nu aw nv bi"><span id="7662" class="ng mh it ly b gy nw nx l ny nz"><em class="nd">interface CellDelegate </em>{<br/>  <em class="nd">fun </em>buttonAClicked()<br/>  <em class="nd">fun </em>buttonBClicked()<br/>}<br/><br/><em class="nd">class </em>Cell(context: Context?) : View(context) {<br/>  <em class="nd">// ...<br/><br/>  var </em>delegate: <em class="nd">CellDelegate</em>? = <em class="nd">null<br/><br/>  fun </em>prepare(arg1: String, arg2: Int, delegate: <em class="nd">CellDelegate</em>) {<br/>    <em class="nd">this</em>.delegate = delegate<br/>  }<br/>}<br/><br/><em class="nd">class </em>Act: Activity(), <em class="nd">CellDelegate </em>{<br/>  <em class="nd">// ...<br/>  fun </em>createCell(): Cell {<br/>    <em class="nd">val </em>cell = Cell(<em class="nd">this</em>)<br/>    cell.prepare("Milk", 10, <em class="nd">this</em>)<br/>    <em class="nd">return </em>cell<br/>  }<br/><br/>  <em class="nd">override fun </em>buttonAClicked() {<br/>    <em class="nd">TODO</em>("Not yet implemented")<br/>  }<br/><br/>  <em class="nd">override fun </em>buttonBClicked() {<br/>    <em class="nd">TODO</em>("Not yet implemented")<br/>  }<br/>  <em class="nd">// ...<br/></em>}</span></pre><p id="6656" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我只是展示一下这里的结构。在一个真实的app中，我们可以使用<code class="fe lv lw lx ly b">ViewHolder</code>，重用单元格(这是正确的做法)。</p><p id="e6d8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这里的一个问题是<code class="fe lv lw lx ly b">Act</code>和<code class="fe lv lw lx ly b">Cell</code>相互引用，这会导致内存泄漏。这里一个好的解决方案是使用一个<code class="fe lv lw lx ly b">WeakReference</code>。封装在<code class="fe lv lw lx ly b">WeakReference</code>中的委托变量不会影响我们<code class="fe lv lw lx ly b">Act</code>的引用计数器，所以一旦我们关闭屏幕，它就会和所有分配的单元格一起被销毁(或者添加到队列中稍后销毁——我们让Android OS来决定)。</p><p id="dcf7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这个简单的扩展允许您通过向任何对象添加<code class="fe lv lw lx ly b">.weak</code>来获得弱引用:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ne nf l"/></div></figure><h2 id="ae4c" class="ng mh it bd mi nh ni dn mm nj nk dp mq li nl nm ms lm nn no mu lq np nq mw nr bi translated">使用</h2><pre class="kj kk kl km gt ns ly nt nu aw nv bi"><span id="cd19" class="ng mh it ly b gy nw nx l ny nz"><em class="nd">class </em>Cell(context: Context?) : View(context) {<br/>  <em class="nd">// ...<br/><br/>  private var </em>delegate: WeakReference&lt;<em class="nd">CellDelegate</em>&gt;? = <em class="nd">null<br/><br/>  fun </em>prepare(arg1: String, arg2: Int, delegate: <em class="nd">CellDelegate</em>) {<br/>    <em class="nd">this</em>.delegate = delegate.<em class="nd">weak<br/>  </em>}<br/>  <br/>  <em class="nd">fun </em>callA() {<br/>    delegate?.get()?.buttonAClicked()<br/>  }<br/>  <br/>  <em class="nd">fun </em>callB() {<br/>    delegate?.get()?.buttonBClicked()<br/>  }<br/>}</span></pre><p id="3b56" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我想强调这个扩展是通用的，它适用于任何类型。</p></div><div class="ab cl lz ma hx mb" role="separator"><span class="mc bw bk md me mf"/><span class="mc bw bk md me mf"/><span class="mc bw bk md me"/></div><div class="im in io ip iq"><h1 id="6241" class="mg mh it bd mi mj mk ml mm mn mo mp mq jz mr ka ms kc mt kd mu kf mv kg mw mx bi translated">Context.directionsTo(…)'</h1><p id="d84f" class="pw-post-body-paragraph kz la it lb b lc my ju le lf mz jx lh li na lk ll lm nb lo lp lq nc ls lt lu im bi translated">从Android应用程序打开导航是一个受欢迎的功能。安卓是谷歌的产品，和谷歌地图一样。谷歌地图应用程序预装在大多数安卓手机和平板电脑上。最简单的解决方法是在安卓地图应用中打开导航。如果没有安装，只需在网络浏览器中打开它。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ne nf l"/></div></figure><p id="cccd" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这是<code class="fe lv lw lx ly b">Context</code>的扩展，从编码的角度来说，还可以。但从逻辑上讲，我会说得更具体些。它可以延长<code class="fe lv lw lx ly b">Activity</code>或<code class="fe lv lw lx ly b">AppCompatActivity</code>以避免从<code class="fe lv lw lx ly b">Service</code>开始使用的副作用。您可以将可扩展的类更改为您在应用程序中使用的任何类型。</p></div><div class="ab cl lz ma hx mb" role="separator"><span class="mc bw bk md me mf"/><span class="mc bw bk md me mf"/><span class="mc bw bk md me"/></div><div class="im in io ip iq"><h1 id="7a64" class="mg mh it bd mi mj mk ml mm mn mo mp mq jz mr ka ms kc mt kd mu kf mv kg mw mx bi translated">“appcompActivity.callTo(…)”或“activity . call to(…)”</h1><p id="f70a" class="pw-post-body-paragraph kz la it lb b lc my ju le lf mz jx lh li na lk ll lm nb lo lp lq nc ls lt lu im bi translated">我们使用的逻辑与之前的扩展相同。但是我们不是导航到一个对象，而是试图调用它。这两个扩展可以在同一个应用程序中并排使用。</p><p id="2e5d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这种情况的复杂性在于许可(或缺乏许可)。安卓需要权限才能打电话。但与iPhone不同的是，它确实可以拨打电话，而不只是打开呼叫者。</p><p id="043a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">该扩展将有两个参数，并直接扩展<code class="fe lv lw lx ly b">Activity</code>或类似的类。第一个参数是电话号码，第二个是请求代码。如果我们需要许可，但我们没有:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ne nf l"/></div></figure><h2 id="6a04" class="ng mh it bd mi nh ni dn mm nj nk dp mq li nl nm ms lm nn no mu lq np nq mw nr bi translated">用法(下面的代码是“AppCompatActivity”的一部分)</h2><pre class="kj kk kl km gt ns ly nt nu aw nv bi"><span id="9542" class="ng mh it ly b gy nw nx l ny nz"><em class="nd">private val </em>phone: String = "+1234567890"<br/><br/><em class="nd">private fun </em>call() {<br/>  <em class="nd">callTo</em>(phone, callPermissionRequestCode)<br/>}<br/><br/><em class="nd">override fun </em>onRequestPermissionsResult(requestCode: Int, permissions: Array&lt;<em class="nd">out </em>String&gt;, grantResults: IntArray) {<br/>  <em class="nd">if </em>(requestCode == callPermissionRequestCode) {<br/>    <em class="nd">if </em>(permissions.<em class="nd">isNotEmpty</em>() &amp;&amp; grantResults.<em class="nd">isNotEmpty</em>() &amp;&amp; grantResults[0] == PackageManager.<em class="nd">PERMISSION_GRANTED</em>) {<br/>      call()<br/>    }<br/>  } <em class="nd">else </em>{<br/>    <em class="nd">super</em>.onRequestPermissionsResult(requestCode, permissions, grantResults)<br/>  }<br/>}<br/><br/><em class="nd">companion object </em>{<br/>  <em class="nd">const val </em>callPermissionRequestCode = 2001<br/>}</span></pre></div><div class="ab cl lz ma hx mb" role="separator"><span class="mc bw bk md me mf"/><span class="mc bw bk md me mf"/><span class="mc bw bk md me"/></div><div class="im in io ip iq"><h1 id="a0c5" class="mg mh it bd mi mj mk ml mm mn mo mp mq jz mr ka ms kc mt kd mu kf mv kg mw mx bi translated">' String.asUri '</h1><p id="5d7e" class="pw-post-body-paragraph kz la it lb b lc my ju le lf mz jx lh li na lk ll lm nb lo lp lq nc ls lt lu im bi translated">我们通常认为互联网地址是一个字符串。我们可以把它打出来并加上引号。比如“https://medium.com。”</p><p id="1fe0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">但是内部使用，安卓有一个特殊的类型:<code class="fe lv lw lx ly b">Uri</code>。很容易将一个转换成另一个。下面的扩展允许我们通过验证将一个<code class="fe lv lw lx ly b">String</code>转换成一个<code class="fe lv lw lx ly b">Uri</code>。如果它不是一个有效的<code class="fe lv lw lx ly b">Uri</code>，它返回<code class="fe lv lw lx ly b">null</code>:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ne nf l"/></div></figure><h2 id="b2d2" class="ng mh it bd mi nh ni dn mm nj nk dp mq li nl nm ms lm nn no mu lq np nq mw nr bi translated">使用</h2><pre class="kj kk kl km gt ns ly nt nu aw nv bi"><span id="5c6c" class="ng mh it ly b gy nw nx l ny nz"><em class="nd">val </em>uri = "invalid_uri".<em class="nd">asUri<br/>val </em>uri2 = "https://medium.com/@alex_nekrasov".<em class="nd">asUri</em></span></pre></div><div class="ab cl lz ma hx mb" role="separator"><span class="mc bw bk md me mf"/><span class="mc bw bk md me mf"/><span class="mc bw bk md me"/></div><div class="im in io ip iq"><h1 id="3669" class="mg mh it bd mi mj mk ml mm mn mo mp mq jz mr ka ms kc mt kd mu kf mv kg mw mx bi translated">“Uri.open(…)”、“Uri.openInside(…)”和“Uri.openOutside(…)”</h1><p id="484f" class="pw-post-body-paragraph kz la it lb b lc my ju le lf mz jx lh li na lk ll lm nb lo lp lq nc ls lt lu im bi translated">现在，当我们有一个<code class="fe lv lw lx ly b">Uri</code>时，我们可能想在浏览器中打开它。有两种方法可以做到这一点:</p><ul class=""><li id="59b0" class="os ot it lb b lc ld lf lg li ou lm ov lq ow lu ox oy oz pa bi translated">在应用程序中打开它</li><li id="0e29" class="os ot it lb b lc pb lf pc li pd lm pe lq pf lu ox oy oz pa bi translated">在外部浏览器中打开它</li></ul><p id="b6d7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们通常希望将用户留在我们的应用程序中，但有些模式无法在内部打开。比如我们不想在应用内浏览器中打开<code class="fe lv lw lx ly b">instagram://</code>。更有甚者，我们想开的只有<code class="fe lv lw lx ly b">http://</code>和<code class="fe lv lw lx ly b"><a class="ae ky" href="https://." rel="noopener ugc nofollow" target="_blank">https://</a></code>T10。</p><p id="21f4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们将添加三个不同的扩展。一个将在应用程序内部打开<code class="fe lv lw lx ly b">Uri</code>，另一个将打开外部浏览器，最后一个将根据模式动态决定。</p><p id="2abd" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">要在应用程序中打开网页，我们需要创建一个单独的活动，或者使用一个库来完成这项工作。为了简单起见，我选择了第二种方式，并包含了<a class="ae ky" href="https://github.com/TheFinestArtist/FinestWebView-Android" rel="noopener ugc nofollow" target="_blank"> FinestWebView </a>库。</p><p id="4bd3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在你的应用程序gradle filem包括这一行:</p><pre class="kj kk kl km gt ns ly nt nu aw nv bi"><span id="9ac1" class="ng mh it ly b gy nw nx l ny nz">dependencies {<br/>    implementation 'com.thefinestartist:finestwebview:1.2.7'<br/>}</span></pre><p id="1783" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">清单上写着:</p><pre class="kj kk kl km gt ns ly nt nu aw nv bi"><span id="c56b" class="ng mh it ly b gy nw nx l ny nz">&lt;uses-permission android:name="android.permission.INTERNET" /&gt;<br/><br/>&lt;activity<br/>    android:name="com.thefinestartist.finestwebview.FinestWebViewActivity"<br/>    android:configChanges="keyboardHidden|orientation|screenSize"<br/>    android:screenOrientation="sensor"<br/>    android:theme="@style/FinestWebViewTheme.Light" /&gt;</span></pre><p id="7363" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">以下是我们的扩展:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ne nf l"/></div></figure><h2 id="cfb6" class="ng mh it bd mi nh ni dn mm nj nk dp mq li nl nm ms lm nn no mu lq np nq mw nr bi translated">使用</h2><pre class="kj kk kl km gt ns ly nt nu aw nv bi"><span id="2979" class="ng mh it ly b gy nw nx l ny nz"><em class="nd">val </em>uri2 = "https://medium.com/@alex_nekrasov".<em class="nd">asUri<br/></em>uri2?.<em class="nd">open</em>(<em class="nd">this</em>)</span></pre></div><div class="ab cl lz ma hx mb" role="separator"><span class="mc bw bk md me mf"/><span class="mc bw bk md me mf"/><span class="mc bw bk md me"/></div><div class="im in io ip iq"><h1 id="d167" class="mg mh it bd mi mj mk ml mm mn mo mp mq jz mr ka ms kc mt kd mu kf mv kg mw mx bi translated">Context.vibrate(…)'</h1><p id="c518" class="pw-post-body-paragraph kz la it lb b lc my ju le lf mz jx lh li na lk ll lm nb lo lp lq nc ls lt lu im bi translated">有时，我们希望从手机中获得一些物理反馈。例如，当用户点击某个按钮时，该设备可以振动。我将把关于这是否是一个好的实践或者是否超出了范围的讨论放在一边，最好把注意力集中在功能上。</p><p id="2475" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">首先，将该权限添加到您的清单中:</p><pre class="kj kk kl km gt ns ly nt nu aw nv bi"><span id="86a1" class="ng mh it ly b gy nw nx l ny nz">&lt;uses-permission <em class="nd">android:name</em>="android.permission.VIBRATE" /&gt;</span></pre><h2 id="32e5" class="ng mh it bd mi nh ni dn mm nj nk dp mq li nl nm ms lm nn no mu lq np nq mw nr bi translated">延长</h2><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ne nf l"/></div></figure><h2 id="d053" class="ng mh it bd mi nh ni dn mm nj nk dp mq li nl nm ms lm nn no mu lq np nq mw nr bi translated">使用</h2><pre class="kj kk kl km gt ns ly nt nu aw nv bi"><span id="b9cd" class="ng mh it ly b gy nw nx l ny nz">vibrate(500) // 500 ms<br/>// Should be called from Activity or other Context</span></pre><p id="7baf" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">或者</p><pre class="kj kk kl km gt ns ly nt nu aw nv bi"><span id="7aab" class="ng mh it ly b gy nw nx l ny nz">context.vibrate(500) // 500 ms<br/>// Can be called from any place having <strong class="ly iu">context</strong> variable</span></pre></div><div class="ab cl lz ma hx mb" role="separator"><span class="mc bw bk md me mf"/><span class="mc bw bk md me mf"/><span class="mc bw bk md me"/></div><div class="im in io ip iq"><h1 id="d24f" class="mg mh it bd mi mj mk ml mm mn mo mp mq jz mr ka ms kc mt kd mu kf mv kg mw mx bi translated">结论</h1><p id="4d26" class="pw-post-body-paragraph kz la it lb b lc my ju le lf mz jx lh li na lk ll lm nb lo lp lq nc ls lt lu im bi translated">我希望这些扩展对您有用，并使您的代码更短、更整洁。您可以修改它们以满足您的要求，并将它们包含在您的项目中。不要忘记将所有必要的权限添加到您的清单中。</p><p id="215a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">编码快乐，下次见！</p></div></div>    
</body>
</html>