<html>
<head>
<title>Decoupling Flutter Views for Reusability</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">解耦颤振视图以实现可重用性</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/decoupling-flutter-views-for-reusability-1ec8b58f5521?source=collection_archive---------12-----------------------#2021-02-08">https://betterprogramming.pub/decoupling-flutter-views-for-reusability-1ec8b58f5521?source=collection_archive---------12-----------------------#2021-02-08</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="9895" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">创建更好的结构化视图</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/e89b13d4233c7a6ca066e273965312ef.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*lvBbfcnJACEaeV9iY7MBpQ.jpeg"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">照片由<a class="ae ky" href="https://unsplash.com/@spookymatt?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">马特雷姆斯</a>在<a class="ae ky" href="https://unsplash.com/s/photos/buildings?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄。</p></figure><p id="3ce2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">颤动视图代表了呈现给用户的界面。它们提供交互，让用户感受到应用程序的本质。不幸的是，颤振视图也经常被忽略，导致紧密耦合和不可重用的组件。</p><p id="d99f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在本文中，我将讨论可以帮助您构建更多可重用和松耦合视图的技术。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="10aa" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">显示客户列表</h1><p id="04a6" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">让我们考虑一个场景，其中我们必须在应用程序中显示客户列表。点击客户后，我们会将用户发送到详细信息屏幕。为了创建这个应用程序，我们将从实现一个代表整个屏幕的<code class="fe mz na nb nc b">CustomerListScreen</code>小部件开始。我们可以使用<code class="fe mz na nb nc b">ListView</code>小部件显示客户列表。这在下面实现:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nd ne l"/></div></figure><p id="1949" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">上面的代码工作并在小部件上显示客户列表，但是它不可重用。这意味着如果我们想在其他小部件中显示客户列表，我们将不得不手动复制/粘贴代码。</p><p id="3414" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们可以通过创建一个<code class="fe mz na nb nc b">CustomerList</code>小部件来解决这个问题。这个小部件将负责显示客户列表。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="9957" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">正在创建CustomerList视图</h1><p id="4aae" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">创建<code class="fe mz na nb nc b">CustomerList</code>小部件的基本思想是制作一个可重用的小部件，可以在我们的应用程序中的多个地方使用。我们将传递一个客户列表给<code class="fe mz na nb nc b">CustomerList</code>小部件，它将负责向用户显示他们。</p><p id="0fc1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这使得<code class="fe mz na nb nc b">CustomerListScreen</code>更加精简，因为它可以简单地将工作委托给<code class="fe mz na nb nc b">CustomerList</code>小部件。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nd ne l"/></div></figure><p id="f192" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">尽管这很有效，但现在我们的<code class="fe mz na nb nc b">CustomerList</code>小部件与导航紧密耦合。这意味着每次我们点击<code class="fe mz na nb nc b">CustomerList</code>中的一个项目，我们总是导航到<code class="fe mz na nb nc b">CustomerDetailScreen</code>。如果调用者而不是<code class="fe mz na nb nc b">CustomerList</code>小部件负责目的地，那就好了。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="a35f" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">客户列表视图和导航</h1><p id="b827" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">为了将控制传递回调用者，我们将在Dart语言中使用闭包/函数。我们将允许用户传入闭包，这个闭包稍后可以被<code class="fe mz na nb nc b">CustomerList</code>视图调用。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nd ne l"/></div></figure><p id="2660" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在上面的代码中，我们更新了我们的<code class="fe mz na nb nc b">CustomerList</code>小部件，以包含一个<code class="fe mz na nb nc b">onSelected</code>闭包。我们没有把它作为一个必需的参数，因为有时小部件只是想显示数据而不执行任何导航。稍后，当用户点击客户时，我们调用<code class="fe mz na nb nc b">onSelected</code>，传递选定的客户。</p><p id="fb0c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe mz na nb nc b">CustomerListScreen</code>捕获闭包并执行适当的导航。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nd ne l"/></div></figure><p id="ad7a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这使得我们的Flutter小部件可以重用，并且与应用程序的其他部分分离。现在，如果其他屏幕想要显示客户列表，它可以使用<code class="fe mz na nb nc b">CustomerList</code>小部件导航到一个完全独立的屏幕。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="1d66" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">结论</h1><p id="eb26" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">视图是任何Flutter应用程序的构建块。松散耦合和可重用的架构视图可以为您的项目带来好处。我希望本文展示的技术能够帮助您创建更好的结构化视图。</p></div></div>    
</body>
</html>