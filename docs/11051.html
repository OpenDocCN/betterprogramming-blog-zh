<html>
<head>
<title>Why Do We Need GraphQL?</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">我们为什么需要GraphQL？</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/why-do-we-need-graphql-43ea26d0efc4?source=collection_archive---------9-----------------------#2022-02-14">https://betterprogramming.pub/why-do-we-need-graphql-43ea26d0efc4?source=collection_archive---------9-----------------------#2022-02-14</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="3441" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">它如何加速我们的应用程序</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/4b0cb9bf3339a8e50054b79694462818.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*pqSpf7udKn6vefCr"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">艾萨克·史密斯在<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</p></figure><p id="59a6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">由静态网页组成的互联网时代已经一去不复返了。互联网面临着大量的终端设备，所有这些设备都同样希望尽可能快地加载数据。</p><p id="ab4b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">为了实现这一目标，我们需要高性能的应用程序和良好且不断改进的基础设施。</p><p id="b9b3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">此外，快速应用程序让用户感到高兴，并为提供商带来更多的钱。</p><p id="bbdc" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">互联网的历史和未来一直是并将永远是关于从服务器向客户机快速传送数据。GraphQL可能与此有关。</p><h1 id="163f" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">GraphQL是什么？</h1><blockquote class="mn mo mp"><p id="7fe4" class="kz la mq lb b lc ld ju le lf lg jx lh mr lj lk ll ms ln lo lp mt lr ls lt lu im bi translated">“GraphQL是一种API的查询语言，也是一种用现有数据完成这些查询的运行时”(【https://graphql.org/】T4)。</p></blockquote><p id="5f00" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">GraphQL是独立于传输的，但通常通过HTTP提供。GraphQL的好处在于，可以请求唯一需要的数据。</p><p id="499f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">传统上，数据是通过<a class="ae ky" href="https://www.ibm.com/cloud/learn/rest-apis" rel="noopener ugc nofollow" target="_blank"> REST </a>(代表性状态转移)API来消费的。在REST流程中提供和交付完整的实体是很常见的。这正是GraphQL试图解决的问题。</p><p id="dd4c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">通常，我们只需要实体的一小部分，我们仍然可以完整地交付它们。这导致了所谓的“过度蚀刻”其他时候我们需要几个实体，所以所谓的“下钻”在每个请求中都会发生。</p><p id="ec48" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">GraphQL API为开发人员提供了一个单一入口点，查询可以在其中请求合适的数据。开发人员可以用语法描述所需的数据。</p><p id="7b82" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在这里，查询是嵌套的，可以传递多个相关的对象。对GraphQL端点的每个查询都用类型系统进行验证。各个服务定义了GraphQL模式中的类型。类型系统可以被认为是API数据的蓝图。</p><p id="8e6f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">此外，GraphQL支持许多不同的语言，包括C#、Clojure、Elixir、Erlang和许多其他语言。(<a class="ae ky" href="https://graphql.org/code/)" rel="noopener ugc nofollow" target="_blank">https://graphql.org/code/)</a></p><h1 id="39f0" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">GraphQL的起源</h1><p id="db0e" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">脸书在2012年发明了GraphQL。当时，脸书在App store中发布了它的应用程序，通过这样做，他们意识到该应用程序对他们的API产生了很多请求。在这个时候，脸书的应用程序被评为非常差，这与它速度慢、耗电太多有关。</p><p id="7c91" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在REST APIs的世界里，脸书必须向不同的端点发出大量请求。它们具有来自调用端点的级联效应。脸书的工程师们意识到他们需要改进服务器向客户端发送数据的方式。</p><p id="0dfa" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">JS中GraphQL的初始GraphQL规范和参考实现于2015年7月发布。到2016年，GraphQL离开了预览阶段，这意味着它正式投入生产。今天，许多不同的公司都在他们的生产中使用GraphQL。</p><h1 id="f5a1" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">数据传输的历史</h1><p id="1c34" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">为了理解GraphQL背后的新思想，我们必须首先看看数据传输在历史背景下是如何工作的——思考数据传输并理解数据如何在系统之间交换。</p><h2 id="28a9" class="mz lw it bd lx na nb dn mb nc nd dp mf li ne nf mh lm ng nh mj lq ni nj ml nk bi translated"><strong class="ak">远程程序调用</strong></h2><p id="11f8" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">詹姆斯·e·怀特在1976年开发了RPC 的基本概念<a class="ae ky" href="https://datatracker.ietf.org/doc/html/rfc707" rel="noopener ugc nofollow" target="_blank">。RPC代表远程过程调用。客户端向远程系统发送执行某项操作的请求。客户端和服务器不同，但是请求/响应模型基本上是相同的。</a></p><h2 id="e38a" class="mz lw it bd lx na nb dn mb nc nd dp mf li ne nf mh lm ng nh mj lq ni nj ml nk bi translated"><strong class="ak">香皂</strong></h2><p id="16e4" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">之后，SOAP(简单对象访问协议)于20世纪90年代末在微软出现。SOAP使用HTTP进行传输，使用XML对消息进行编码。它也使用了类型系统，但是SOAP使实现变得复杂了。</p><h2 id="02d8" class="mz lw it bd lx na nb dn mb nc nd dp mf li ne nf mh lm ng nh mj lq ni nj ml nk bi translated"><strong class="ak">休息</strong></h2><p id="5ef2" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">所以，在2000年，罗伊·菲尔丁定义了休息。他的想法是一个面向资源的架构，在这个架构中，通过执行诸如GET、PUT、POST和DELETE之类的操作来使用web资源。</p><p id="367d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">它不是一个协议或标准。你可以把它想象成一组架构约束。开发人员可以用多种方式在他们的API中实现REST。</p><p id="e40b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">一开始，开发者使用REST和<a class="ae ky" href="https://www.w3schools.com/XML/xml_whatis.asp" rel="noopener ugc nofollow" target="_blank"> XML </a>，但不久之后，<a class="ae ky" href="https://www.w3schools.com/js/js_json_intro.asp" rel="noopener ugc nofollow" target="_blank"> JavaScript对象符号</a>被<a class="ae ky" href="https://codedocs.org/what-is/douglas-crockford" rel="noopener ugc nofollow" target="_blank">道格拉斯·克洛克福特</a>推广开来。这是一种更加优雅的数据格式，可以被许多不同的语言解析和使用。</p><p id="eb73" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在REST架构风格中，客户机和服务器之间也有明确的分离。到目前为止，REST是最方便的技术。</p><p id="96a7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">但是任何事物都有缺点，在下文中，我们想看看这些。</p><h1 id="50d5" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">休息缺点</h1><p id="2c78" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">即使我写的是REST的缺点，REST并没有死，而且很可能不会很快死去。它擅长履行它的服务。</p><h2 id="d6e1" class="mz lw it bd lx na nb dn mb nc nd dp mf li ne nf mh lm ng nh mj lq ni nj ml nk bi translated"><strong class="ak">过度蚀刻</strong></h2><p id="35ab" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">如上所述，REST存在过度蚀刻的问题。过度蚀刻描述了您请求数据的情况，例如，为一本书的作者。</p><p id="30fd" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">然后你可能会得到一个Id，一个名字，也许还有他们的地址和生日。但是可能会为作者存储更多的数据，服务器将返回每个字段，即使客户端不需要它。</p><h2 id="84e7" class="mz lw it bd lx na nb dn mb nc nd dp mf li ne nf mh lm ng nh mj lq ni nj ml nk bi translated"><strong class="ak">蚀刻不足</strong></h2><p id="dbf9" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">蚀刻不足与蚀刻过度正好相反。返回的信息太少，因此必须查询多个端点来收集适当的数据。</p><p id="31d6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">例如，你想从作者的书中获得更多的细节。因此，您可能需要首先调用author API，该API返回所有作者数据和一组端点，以获取关于这本书的更多信息。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nl nm l"/></div></figure><h2 id="fc95" class="mz lw it bd lx na nb dn mb nc nd dp mf li ne nf mh lm ng nh mj lq ni nj ml nk bi translated"><strong class="ak">管理端点</strong></h2><p id="134d" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">今天，现代web应用程序是高度数据驱动的，需要获取和组合许多不同的数据和数据源。开发人员必须调用许多其他端点来收集必要的数据。所有这些端点都必须得到管理。</p><p id="eb92" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">因此，REST缺乏灵活性。开发人员需要维护端点，添加新的端点，删除旧的端点。因为GraphQL只提供一个端点，所以不需要管理端点。</p><h2 id="ef5f" class="mz lw it bd lx na nb dn mb nc nd dp mf li ne nf mh lm ng nh mj lq ni nj ml nk bi translated"><strong class="ak">网络请求</strong></h2><p id="eb48" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">另一点是调用许多端点来收集数据所产生的网络负载，即使您并不需要所有的端点。</p><p id="e0a1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu">静止不动</strong></p><p id="b67e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">数据以一种特定的方式存储，开发人员将以这种方式获取数据。调整某事与更重大的努力相关联。例如，如果开发人员添加了以前没有包含在POST端点中的额外字段，他必须修改API版本。</p><p id="b3e1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu">版本控制</strong></p><p id="f104" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">上面这一点已经向我们展示了REST的静态实现的问题。开发人员需要版本控制来处理它，可能没有正确的方法。</p><blockquote class="nn"><p id="5ad7" class="no np it bd nq nr ns nt nu nv nw lu dk translated">“最简单的大概就是弃用了。”</p><p id="3a2f" class="no np it bd nq nr ns nt nu nv nw lu dk translated">(问题5，<a class="ae ky" href="https://leapgraph.com/what-graphql-solves/" rel="noopener ugc nofollow" target="_blank">https://leapgraph.com/what-graphql-solves/</a>)</p></blockquote><h1 id="fd74" class="lv lw it bd lx ly lz ma mb mc md me mf jz nx ka mh kc ny kd mj kf nz kg ml mm bi translated">C#实现的示例</h1><p id="2265" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated"><em class="mq">更多信息，请看这里的</em><a class="ae ky" href="https://graphql-aspnet.github.io/docs/quick/quick-start" rel="noopener ugc nofollow" target="_blank"><em class="mq"/></a><em class="mq">！</em></p><p id="4562" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu">第一步。但是让我们首先创建一个新的ASP.NET核心web应用程序项目。</strong></p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi oa"><img src="../Images/cf581128e8550cf328ff8cdd120bf6fa.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*d0DAriC7AFKG3gTx-obqOw.png"/></div></div></figure><p id="804d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu">第二步。创建项目后，下一步是安装Nuget包“GraphQL”。AspNet ":</strong></p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ob"><img src="../Images/897c675ccc72b8f1847d5f283b2bef84.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*GsJmt3Ckk8K1FwYgpv5w2g.png"/></div></div></figure><p id="0739" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu">步骤三。让我们创建一个名为<code class="fe oc od oe of b">book.cs</code>的模型类:</strong></p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nl nm l"/></div></figure><p id="0d6a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu">步骤四。</strong>创建一个<code class="fe oc od oe of b">Controller</code>，叫做<code class="fe oc od oe of b">BookController.cs</code>:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nl nm l"/></div></figure><p id="5280" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu">第五步。</strong>让我们修改<code class="fe oc od oe of b">Programm.cs</code>，通过添加<code class="fe oc od oe of b">builder.Services.AddGraphQL();</code>和<code class="fe oc od oe of b">app.UseGraphQL();</code>来添加服务:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nl nm l"/></div></figure><p id="a1db" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">然后启动应用程序。你应该能指引到<code class="fe oc od oe of b">http://localhost:[YOUR_PORT]/graphql</code>。</p><p id="3000" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果您看到下面的消息:“GraphQL查询应该作为POST请求执行”，那么它正在运行。</p><p id="6cfd" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在我们需要一个程序来交流。为此我将使用<a class="ae ky" href="https://www.postman.com/graphql/" rel="noopener ugc nofollow" target="_blank"> Postman </a>，但是你可以随意使用你喜欢的任何工具。如果一切正常，您应该能够查询一本书，如下所示:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi og"><img src="../Images/bf8465b96d415b37b0b5599bfa97abc4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*hDFH2pep03p5H9SLAk1B6Q.png"/></div></div></figure><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nl nm l"/></div></figure><p id="29e3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在，您可以将想要接收的不同字段添加到查询中。</p><div class="oh oi gp gr oj ok"><a href="https://github.com/muench-develops/graphql_example_medium" rel="noopener  ugc nofollow" target="_blank"><div class="ol ab fo"><div class="om ab on cl cj oo"><h2 class="bd iu gy z fp op fr fs oq fu fw is bi translated">GitHub-muench-develops/graph QL _ example _ medium</h2><div class="or l"><h3 class="bd b gy z fp op fr fs oq fu fw dk translated">此时您不能执行该操作。您已使用另一个标签页或窗口登录。您已在另一个选项卡中注销，或者…</h3></div><div class="os l"><p class="bd b dl z fp op fr fs oq fu fw dk translated">github.com</p></div></div><div class="ot l"><div class="ou l ov ow ox ot oy ks ok"/></div></div></a></div><h1 id="9f62" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">TL；DR；</h1><ul class=""><li id="c46d" class="oz pa it lb b lc mu lf mv li pb lm pc lq pd lu pe pf pg ph bi translated">REST存在“过度蚀刻”和“蚀刻不足”的问题</li><li id="6a35" class="oz pa it lb b lc pi lf pj li pk lm pl lq pm lu pe pf pg ph bi translated">GraphQL试图通过创建特定的查询来解决这个问题。</li><li id="79ae" class="oz pa it lb b lc pi lf pj li pk lm pl lq pm lu pe pf pg ph bi translated">脸书发明了GraphQL，因为它与REST架构风格有性能问题。</li></ul><h1 id="bcc4" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">来源</h1><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="pn nm l"/></div></figure><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="pn nm l"/></div></figure><div class="oh oi gp gr oj ok"><a href="https://www.amazon.com/-/de/dp/1492030716/ref=sr_1_1?__mk_de_DE=%C3%85M%C3%85%C5%BD%C3%95%C3%91&amp;crid=4D5ZQDLBPLAW&amp;keywords=Learning+graphql&amp;qid=1644574423&amp;sprefix=learning+graphql%2Caps%2C138&amp;sr=8-1" rel="noopener  ugc nofollow" target="_blank"><div class="ol ab fo"><div class="om ab on cl cj oo"><h2 class="bd iu gy z fp op fr fs oq fu fw is bi translated">学习GraphQL:现代Web应用程序的声明性数据提取</h2><div class="or l"><h3 class="bd b gy z fp op fr fs oq fu fw dk translated">学习graph QL:Amazon.com上现代Web应用程序[波尔切洛、伊夫、班克斯、亚历克斯]的声明性数据获取。*免费*…</h3></div><div class="os l"><p class="bd b dl z fp op fr fs oq fu fw dk translated">www.amazon.com</p></div></div><div class="ot l"><div class="po l ov ow ox ot oy ks ok"/></div></div></a></div><p id="e8f2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><a class="ae ky" href="http://www.graphql.org" rel="noopener ugc nofollow" target="_blank">www.graphql.org</a></p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="pn nm l"/></div></figure><div class="oh oi gp gr oj ok"><a href="https://www.redhat.com/en/topics/api/what-is-a-rest-api" rel="noopener  ugc nofollow" target="_blank"><div class="ol ab fo"><div class="om ab on cl cj oo"><h2 class="bd iu gy z fp op fr fs oq fu fw is bi translated">什么是REST API？</h2><div class="or l"><h3 class="bd b gy z fp op fr fs oq fu fw dk translated">REST API(也称为RESTful API)是一个应用程序编程接口(API或web API ),它符合</h3></div><div class="os l"><p class="bd b dl z fp op fr fs oq fu fw dk translated">www.redhat.com</p></div></div><div class="ot l"><div class="pp l ov ow ox ot oy ks ok"/></div></div></a></div><div class="oh oi gp gr oj ok"><a href="https://codedocs.org/what-is/douglas-crockford" rel="noopener  ugc nofollow" target="_blank"><div class="ol ab fo"><div class="om ab on cl cj oo"><h2 class="bd iu gy z fp op fr fs oq fu fw is bi translated">道格拉斯·克洛克福特</h2><div class="or l"><h3 class="bd b gy z fp op fr fs oq fu fw dk translated">道格拉斯·克洛克福特是美国计算机程序员和企业家，他参与了…</h3></div><div class="os l"><p class="bd b dl z fp op fr fs oq fu fw dk translated">codedocs.org</p></div></div><div class="ot l"><div class="pq l ov ow ox ot oy ks ok"/></div></div></a></div><div class="oh oi gp gr oj ok"><a href="https://www.w3schools.com/XML/xml_whatis.asp" rel="noopener  ugc nofollow" target="_blank"><div class="ol ab fo"><div class="om ab on cl cj oo"><h2 class="bd iu gy z fp op fr fs oq fu fw is bi translated">XML简介</h2><div class="or l"><h3 class="bd b gy z fp op fr fs oq fu fw dk translated">XML是一种独立于软件和硬件的存储和传输数据的工具。XML代表可扩展标记…</h3></div><div class="os l"><p class="bd b dl z fp op fr fs oq fu fw dk translated">www.w3schools.com</p></div></div><div class="ot l"><div class="pr l ov ow ox ot oy ks ok"/></div></div></a></div><div class="oh oi gp gr oj ok"><a href="https://leapgraph.com/what-graphql-solves/#under-over-fetching" rel="noopener  ugc nofollow" target="_blank"><div class="ol ab fo"><div class="om ab on cl cj oo"><h2 class="bd iu gy z fp op fr fs oq fu fw is bi translated">图形数据和GraphQL API开发-Leap Graph</h2><div class="or l"><h3 class="bd b gy z fp op fr fs oq fu fw dk translated">尽管REST的接口使用了统一的协议(通常是HTTP ),但事实上它是协议不可知的…</h3></div><div class="os l"><p class="bd b dl z fp op fr fs oq fu fw dk translated">leapgraph.com</p></div></div></div></a></div><div class="oh oi gp gr oj ok"><a href="https://graphql-aspnet.github.io/docs/quick/quick-start" rel="noopener  ugc nofollow" target="_blank"><div class="ol ab fo"><div class="om ab on cl cj oo"><h2 class="bd iu gy z fp op fr fs oq fu fw is bi translated">快速入门指南。网</h2><div class="or l"><h3 class="bd b gy z fp op fr fs oq fu fw dk translated">本指南将帮助您启动并运行GraphQL项目，以便您可以开始试验。我们会报道…</h3></div><div class="os l"><p class="bd b dl z fp op fr fs oq fu fw dk translated">graphql-aspnet.github.io</p></div></div><div class="ot l"><div class="ps l ov ow ox ot oy ks ok"/></div></div></a></div></div></div>    
</body>
</html>