<html>
<head>
<title>A Thorough Introduction to Apache Kafka</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">阿帕奇卡夫卡的全面介绍</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/thorough-introduction-to-apache-kafka-6fbf2989bbc1?source=collection_archive---------0-----------------------#2017-12-15">https://betterprogramming.pub/thorough-introduction-to-apache-kafka-6fbf2989bbc1?source=collection_archive---------0-----------------------#2017-12-15</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="7bcc" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">深入探究作为许多公司架构核心的系统</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/003464f5c46deb1ae81efec1cfc28279.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*d3KMaUnrLbWPI5Pxtgfc_w.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">一些使用阿帕奇卡夫卡的巨石柱</p></figure><h1 id="b693" class="ky kz it bd la lb lc ld le lf lg lh li jz lj ka lk kc ll kd lm kf ln kg lo lp bi translated">介绍</h1><p id="0af4" class="pw-post-body-paragraph lq lr it ls b lt lu ju lv lw lx jx ly lz ma mb mc md me mf mg mh mi mj mk ml im bi translated">卡夫卡是一个如今经常听到的词。很多领先的数字公司似乎都在使用它。但实际上是什么呢？</p><p id="cd82" class="pw-post-body-paragraph lq lr it ls b lt mn ju lv lw mo jx ly lz mp mb mc md mq mf mg mh mr mj mk ml im bi translated">Kafka最初是2011年在LinkedIn开发的，之后改进了很多。如今，它是一个完整的平台，允许您冗余地存储荒谬的数据量，拥有巨大吞吐量(百万/秒)的消息总线，并对一次通过的数据使用实时流处理。</p><p id="ba93" class="pw-post-body-paragraph lq lr it ls b lt mn ju lv lw mo jx ly lz mp mb mc md mq mf mg mh mr mj mk ml im bi translated">这一切都很好，但从核心来看，Kafka是一个分布式的、可水平伸缩的、容错的提交日志。</p><p id="032c" class="pw-post-body-paragraph lq lr it ls b lt mn ju lv lw mo jx ly lz mp mb mc md mq mf mg mh mr mj mk ml im bi translated">那些是一些新奇的词，让我们一个一个地看它们是什么意思。之后，我们将深入研究它是如何工作的。</p><h2 id="0b00" class="ms kz it bd la mt mu dn le mv mw dp li lz mx my lk md mz na lm mh nb nc lo nd bi translated">分布的</h2><p id="66d9" class="pw-post-body-paragraph lq lr it ls b lt lu ju lv lw lx jx ly lz ma mb mc md me mf mg mh mi mj mk ml im bi translated">一个<em class="mm">分布式</em>系统是一个被分割成多个运行机器的系统，所有这些机器在一个集群中一起工作，对最终用户来说就像一个单独的节点。Kafka是分布式的，它在不同的节点上存储、接收和发送消息(称为<em class="mm">代理</em>)。关于这一点，我也写了一篇<a class="ae ne" href="https://hackernoon.com/a-thorough-introduction-to-distributed-systems-3b91562c9b3c" rel="noopener ugc nofollow" target="_blank">全面的介绍</a>。</p><p id="3293" class="pw-post-body-paragraph lq lr it ls b lt mn ju lv lw mo jx ly lz mp mb mc md mq mf mg mh mr mj mk ml im bi translated">这种方法的好处是高可伸缩性和容错性。</p><h2 id="e72c" class="ms kz it bd la mt mu dn le mv mw dp li lz mx my lk md mz na lm mh nb nc lo nd bi translated">水平可伸缩</h2><p id="ed4b" class="pw-post-body-paragraph lq lr it ls b lt lu ju lv lw lx jx ly lz ma mb mc md me mf mg mh mi mj mk ml im bi translated">让我们首先定义术语<em class="mm">垂直可伸缩性</em>。比方说，您有一个传统的数据库服务器，它开始过载。解决这个问题的方法是简单地增加服务器上的资源(CPU、RAM、SSD)。这被称为<em class="mm">垂直扩展</em>——向机器添加更多资源。向上扩展有两大缺点:</p><ul class=""><li id="43b1" class="nf ng it ls b lt mn lw mo lz nh md ni mh nj ml nk nl nm nn bi translated">存在由硬件定义的限制。你不能无限扩大规模</li><li id="a1d9" class="nf ng it ls b lt no lw np lz nq md nr mh ns ml nk nl nm nn bi translated">这通常需要停机，这是大公司无法承受的</li></ul><p id="1e18" class="pw-post-body-paragraph lq lr it ls b lt mn ju lv lw mo jx ly lz mp mb mc md mq mf mg mh mr mj mk ml im bi translated"><em class="mm">水平可伸缩性</em>通过投入更多的机器来解决同样的问题。添加一台新机器不需要停机，对集群中的机器数量也没有任何限制。问题是并不是所有的系统都支持水平可伸缩性，因为它们不是为在集群中工作而设计的，那些支持水平可伸缩性的系统通常更复杂。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi nt"><img src="../Images/1d326973ee8308d2e6a08ad593e57a28.png" data-original-src="https://miro.medium.com/v2/resize:fit:800/format:webp/1*ulnsAJdpvet9EW4bKMK-Rw.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">在某个阈值之后，水平缩放变得便宜得多</p></figure><h2 id="763d" class="ms kz it bd la mt mu dn le mv mw dp li lz mx my lk md mz na lm mh nb nc lo nd bi translated">容错的</h2><p id="77b6" class="pw-post-body-paragraph lq lr it ls b lt lu ju lv lw lx jx ly lz ma mb mc md me mf mg mh mi mj mk ml im bi translated">非分布式系统中出现的一个问题是它们具有单点故障(SPoF)。如果您的单个数据库服务器因为任何原因而失败(就像机器一样)，您就惨了。</p><p id="3aab" class="pw-post-body-paragraph lq lr it ls b lt mn ju lv lw mo jx ly lz mp mb mc md mq mf mg mh mr mj mk ml im bi translated">分布式系统被设计成以一种可配置的方式来适应故障。在5节点Kafka集群中，即使其中两个节点出现故障，您也可以让它继续工作。值得注意的是，容错与性能是直接平衡的，因为系统的容错能力越强，性能就越差。</p><h2 id="27b5" class="ms kz it bd la mt mu dn le mv mw dp li lz mx my lk md mz na lm mh nb nc lo nd bi translated">提交日志</h2><p id="7859" class="pw-post-body-paragraph lq lr it ls b lt lu ju lv lw lx jx ly lz ma mb mc md me mf mg mh mi mj mk ml im bi translated"><em class="mm">提交日志</em>(也称为<em class="mm">预写日志</em>或<em class="mm">事务日志</em>)是一种持久有序的数据结构，只支持追加。您不能修改或删除其中的记录。它从左到右阅读，并保证项目排序。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi nu"><img src="../Images/61f6de8887264269c604cd4956481dfc.png" data-original-src="https://miro.medium.com/v2/resize:fit:792/format:webp/1*A6a1_dtaOTg-xFT3SoviUg.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">提交日志的示例图，取自<a class="ae ne" href="https://engineering.linkedin.com/distributed-systems/log-what-every-software-engineer-should-know-about-real-time-datas-unifying" rel="noopener ugc nofollow" target="_blank">这里的</a></p></figure><blockquote class="nv nw nx"><p id="c368" class="lq lr mm ls b lt mn ju lv lw mo jx ly ny mp mb mc nz mq mf mg oa mr mj mk ml im bi translated">“你是在告诉我，卡夫卡就是这么简单的数据结构？”</p></blockquote><p id="dd69" class="pw-post-body-paragraph lq lr it ls b lt mn ju lv lw mo jx ly lz mp mb mc md mq mf mg mh mr mj mk ml im bi translated">在很多方面，是的。这种结构是卡夫卡的核心，是无价的，因为它提供了有序性，而有序性反过来又提供了确定性的处理。这两者都是分布式系统中的重要问题。</p><p id="54df" class="pw-post-body-paragraph lq lr it ls b lt mn ju lv lw mo jx ly lz mp mb mc md mq mf mg mh mr mj mk ml im bi translated">Kafka实际上将其所有的消息存储到磁盘上(稍后将详细介绍)，在结构中对它们进行排序可以让它利用顺序磁盘读取。</p><ul class=""><li id="3153" class="nf ng it ls b lt mn lw mo lz nh md ni mh nj ml nk nl nm nn bi translated">读取和写入是一个恒定的时间O(1) <em class="mm">(知道记录ID) </em>，这与其他结构在磁盘上的O(log N)操作相比是一个巨大的优势，因为每个磁盘寻道都是昂贵的</li><li id="fbbb" class="nf ng it ls b lt no lw np lz nq md nr mh ns ml nk nl nm nn bi translated">读和写互不影响。写作不会锁定阅读，反之亦然(与平衡树相反)。</li></ul><p id="0047" class="pw-post-body-paragraph lq lr it ls b lt mn ju lv lw mo jx ly lz mp mb mc md mq mf mg mh mr mj mk ml im bi translated">这两点具有巨大的性能优势，因为数据大小与性能完全无关。无论您的服务器上有100 KB还是100 TB的数据，Kafka都具有相同的性能。</p></div><div class="ab cl ob oc hx od" role="separator"><span class="oe bw bk of og oh"/><span class="oe bw bk of og oh"/><span class="oe bw bk of og"/></div><div class="im in io ip iq"><h1 id="215d" class="ky kz it bd la lb oi ld le lf oj lh li jz ok ka lk kc ol kd lm kf om kg lo lp bi translated">它是如何工作的？</h1><p id="a2ee" class="pw-post-body-paragraph lq lr it ls b lt lu ju lv lw lx jx ly lz ma mb mc md me mf mg mh mi mj mk ml im bi translated">应用程序<em class="mm">(生产者)</em>向Kafka节点<em class="mm">(代理)</em>发送消息<em class="mm">(记录)</em>，并且所述消息由称为<em class="mm">消费者的其他应用程序处理。</em>所述消息存储在<em class="mm">主题</em>中，消费者订阅该主题以接收新消息。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi on"><img src="../Images/58b490b8ae1a47266344066633970e46.png" data-original-src="https://miro.medium.com/v2/resize:fit:516/format:webp/1*brLQW_K4WrLhFKCTdmsr-w.png"/></div></figure><p id="ea4f" class="pw-post-body-paragraph lq lr it ls b lt mn ju lv lw mo jx ly lz mp mb mc md mq mf mg mh mr mj mk ml im bi translated">由于主题可能会变得很大，它们会被分割成更小的<strong class="ls iu"> </strong> <em class="mm">分区</em>以获得更好的性能和可伸缩性。(例如，假设您正在存储用户登录请求。您可以通过用户名的第一个字符来分割它们。)</p><p id="95a0" class="pw-post-body-paragraph lq lr it ls b lt mn ju lv lw mo jx ly lz mp mb mc md mq mf mg mh mr mj mk ml im bi translated">Kafka保证一个分区中的所有消息按照它们进来的顺序排序。区分特定消息的方法是通过它的<em class="mm">偏移量</em>，您可以将它看作一个普通的数组索引，一个序列号，它随着分区中每个新消息的增加而增加。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi oo"><img src="../Images/50557389c4ed3ae580bc6781ccd32175.png" data-original-src="https://miro.medium.com/v2/resize:fit:832/format:webp/1*GoRlq7O8qMNui6tvnq30cg.png"/></div></figure><p id="d695" class="pw-post-body-paragraph lq lr it ls b lt mn ju lv lw mo jx ly lz mp mb mc md mq mf mg mh mr mj mk ml im bi translated">卡夫卡遵循愚蠢的经纪人和聪明的消费者的原则。这意味着Kafka不会跟踪消费者阅读了哪些记录，然后删除它们。相反，它将它们存储一段时间(例如，一天)或直到达到某个大小阈值。消费者自己在卡夫卡身上寻找新的信息，并说出他们想要阅读的记录。这允许他们按照自己的意愿增加/减少偏移量，从而能够重放和重新处理事件。</p><p id="4bd2" class="pw-post-body-paragraph lq lr it ls b lt mn ju lv lw mo jx ly lz mp mb mc md mq mf mg mh mr mj mk ml im bi translated">值得注意的是，消费者实际上是内部有一个或多个消费流程的消费群体。为了避免两个进程两次读取相同的消息，每个分区只绑定到每个组的一个消费者进程。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi op"><img src="../Images/b69b35c55e825ba4c7e531630ef66afb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*BgaUBaHhE-8-vE1Omk76zg.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">数据流的表示</p></figure></div><div class="ab cl ob oc hx od" role="separator"><span class="oe bw bk of og oh"/><span class="oe bw bk of og oh"/><span class="oe bw bk of og"/></div><div class="im in io ip iq"><h1 id="0a7f" class="ky kz it bd la lb oi ld le lf oj lh li jz ok ka lk kc ol kd lm kf om kg lo lp bi translated">磁盘持久性</h1><p id="258b" class="pw-post-body-paragraph lq lr it ls b lt lu ju lv lw lx jx ly lz ma mb mc md me mf mg mh mi mj mk ml im bi translated">正如我前面提到的，Kafka实际上将其所有记录存储在磁盘上，而不在RAM中保存任何内容。你可能想知道这怎么会是一个明智的选择。这背后有许多优化，使其可行:</p><ul class=""><li id="f1a1" class="nf ng it ls b lt mn lw mo lz nh md ni mh nj ml nk nl nm nn bi translated">卡夫卡有一个将信息组合在一起的协议。这允许网络请求将消息分组在一起，并减少网络开销；反过来，服务器一次保存大量消息，消费者一次获取大量线性消息。</li><li id="8b2f" class="nf ng it ls b lt no lw np lz nq md nr mh ns ml nk nl nm nn bi translated">磁盘上的线性读/写速度很快。现代磁盘慢的概念是因为大量的磁盘寻道，这在大型线性操作中不是问题。</li><li id="b347" class="nf ng it ls b lt no lw np lz nq md nr mh ns ml nk nl nm nn bi translated">所述线性操作由操作系统通过<em class="mm">预读</em>(预取大块倍数)和<em class="mm">后写</em>(将小逻辑写入分组为大物理写入)技术进行了大量优化。</li><li id="9e0b" class="nf ng it ls b lt no lw np lz nq md nr mh ns ml nk nl nm nn bi translated">现代操作系统将磁盘缓存在空闲RAM中。这被称为<em class="mm">页面缓存。</em></li><li id="97bf" class="nf ng it ls b lt no lw np lz nq md nr mh ns ml nk nl nm nn bi translated">由于Kafka在整个流程中以标准的二进制格式存储消息(生产者➡经纪人➡消费者)，它可以利用<em class="mm">零拷贝</em>优化。这时，操作系统将数据从pagecache直接复制到一个套接字，有效地完全绕过了Kafka broker应用程序。</li></ul><p id="ad1a" class="pw-post-body-paragraph lq lr it ls b lt mn ju lv lw mo jx ly lz mp mb mc md mq mf mg mh mr mj mk ml im bi translated">所有这些优化使Kafka能够以接近网络的速度传递消息。</p></div><div class="ab cl ob oc hx od" role="separator"><span class="oe bw bk of og oh"/><span class="oe bw bk of og oh"/><span class="oe bw bk of og"/></div><div class="im in io ip iq"><h1 id="c3f1" class="ky kz it bd la lb oi ld le lf oj lh li jz ok ka lk kc ol kd lm kf om kg lo lp bi translated">数据分发和复制</h1><p id="14e3" class="pw-post-body-paragraph lq lr it ls b lt lu ju lv lw lx jx ly lz ma mb mc md me mf mg mh mi mj mk ml im bi translated">先说Kafka是如何实现容错的，如何在节点之间分配数据。</p><h2 id="acbb" class="ms kz it bd la mt mu dn le mv mw dp li lz mx my lk md mz na lm mh nb nc lo nd bi translated">数据复制</h2><p id="af38" class="pw-post-body-paragraph lq lr it ls b lt lu ju lv lw lx jx ly lz ma mb mc md me mf mg mh mi mj mk ml im bi translated">分区数据在多个代理之间复制，以便在一个代理死亡时保留数据。</p><p id="898a" class="pw-post-body-paragraph lq lr it ls b lt mn ju lv lw mo jx ly lz mp mb mc md mq mf mg mh mr mj mk ml im bi translated">在任何时候，一个代理<em class="mm">都拥有</em>一个分区，并且是应用程序通过其对该分区进行写/读的节点。这被称为<em class="mm">分区领导者。</em>它将接收到的数据复制给<em class="mm"> n </em>其他经纪人，称为<em class="mm">跟随者。</em>它们也存储数据，并准备好在领导节点死亡的情况下被选举为领导节点。</p><p id="fbee" class="pw-post-body-paragraph lq lr it ls b lt mn ju lv lw mo jx ly lz mp mb mc md mq mf mg mh mr mj mk ml im bi translated">这有助于您配置任何成功发布的邮件都不会丢失的保证。有了更改复制因子的选项，您可以根据数据的关键程度，用性能换取更强的耐用性保证。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi oq"><img src="../Images/bbfcbbe8ad08917448146e31d7aaac3b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*08Cs4AHszdnzceAEhKhPLg.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">四个复制因子为3的Kafka经纪人</p></figure><p id="6a03" class="pw-post-body-paragraph lq lr it ls b lt mn ju lv lw mo jx ly lz mp mb mc md mq mf mg mh mr mj mk ml im bi translated">这样，如果一个领导者失败了，一个追随者可以代替他。</p><p id="6c8e" class="pw-post-body-paragraph lq lr it ls b lt mn ju lv lw mo jx ly lz mp mb mc md mq mf mg mh mr mj mk ml im bi translated">不过，你可能会问:</p><blockquote class="nv nw nx"><p id="66e9" class="lq lr mm ls b lt mn ju lv lw mo jx ly ny mp mb mc nz mq mf mg oa mr mj mk ml im bi translated">"生产者/消费者如何知道分区的领导者是谁？"</p></blockquote><p id="09d7" class="pw-post-body-paragraph lq lr it ls b lt mn ju lv lw mo jx ly lz mp mb mc md mq mf mg mh mr mj mk ml im bi translated">对于生产者/消费者来说，从一个分区写/读，他们需要知道它的领导者，对吗？这些信息需要从某处获得。卡夫卡将这些元数据存储在一个名为Zookeeper的服务中。</p><h2 id="d580" class="ms kz it bd la mt mu dn le mv mw dp li lz mx my lk md mz na lm mh nb nc lo nd bi translated"><strong class="ak">什么是动物园管理员？</strong></h2><p id="5ebc" class="pw-post-body-paragraph lq lr it ls b lt lu ju lv lw lx jx ly lz ma mb mc md me mf mg mh mi mj mk ml im bi translated"><em class="mm">动物园管理员</em>是一个分布式键值存储。它针对读取进行了高度优化，但写入速度较慢。它最常用于存储元数据和处理集群机制(心跳、分发更新/配置等)。</p><p id="2d65" class="pw-post-body-paragraph lq lr it ls b lt mn ju lv lw mo jx ly lz mp mb mc md mq mf mg mh mr mj mk ml im bi translated">它允许服务的客户(Kafka brokers)订阅，并在发生变化时将变化发送给他们。这就是代理如何知道何时切换分区领导者。《动物园管理员》还具有极强的容错能力，这是应该的，因为卡夫卡非常依赖它。</p><p id="605f" class="pw-post-body-paragraph lq lr it ls b lt mn ju lv lw mo jx ly lz mp mb mc md mq mf mg mh mr mj mk ml im bi translated">它用于存储各种元数据，例如:</p><ul class=""><li id="5de8" class="nf ng it ls b lt mn lw mo lz nh md ni mh nj ml nk nl nm nn bi translated">每个分区的用户群偏移量(尽管现代客户端在单独的Kafka主题中存储偏移量)</li><li id="542e" class="nf ng it ls b lt no lw np lz nq md nr mh ns ml nk nl nm nn bi translated">访问控制列表(ACLs用于限制访问/授权</li><li id="c3ba" class="nf ng it ls b lt no lw np lz nq md nr mh ns ml nk nl nm nn bi translated">生产者和消费者配额—最大消息/秒界限</li><li id="5580" class="nf ng it ls b lt no lw np lz nq md nr mh ns ml nk nl nm nn bi translated">分区领导及其健康</li></ul><h2 id="7802" class="ms kz it bd la mt mu dn le mv mw dp li lz mx my lk md mz na lm mh nb nc lo nd bi translated"><em class="or">生产者/消费者如何知道分区的领导者是谁？</em></h2><p id="778a" class="pw-post-body-paragraph lq lr it ls b lt lu ju lv lw lx jx ly lz ma mb mc md me mf mg mh mi mj mk ml im bi translated">生产者和消费者过去常常直接连接并与Zookeeper对话来获得这些(以及其他)信息。Kafka一直在远离这种耦合，分别从0.8和0.9版本开始，客户端直接从Kafka经纪人那里获取元数据信息，Kafka经纪人自己与Zookeeper对话。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi os"><img src="../Images/0e998e99e2220852ab92d146c37fe1ee.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*tlgLYE45Q2wd5woB4uxR3g.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">元数据流</p></figure></div><div class="ab cl ob oc hx od" role="separator"><span class="oe bw bk of og oh"/><span class="oe bw bk of og oh"/><span class="oe bw bk of og"/></div><div class="im in io ip iq"><h1 id="ee55" class="ky kz it bd la lb oi ld le lf oj lh li jz ok ka lk kc ol kd lm kf om kg lo lp bi translated">流动</h1><p id="7472" class="pw-post-body-paragraph lq lr it ls b lt lu ju lv lw lx jx ly lz ma mb mc md me mf mg mh mi mj mk ml im bi translated">在Kafka中，流处理器是从输入主题中获取连续的数据流，对该输入进行一些处理，并产生输出主题的数据流(或者外部服务、数据库、垃圾桶——实际上是任何地方)。</p><p id="2ee1" class="pw-post-body-paragraph lq lr it ls b lt mn ju lv lw mo jx ly lz mp mb mc md mq mf mg mh mr mj mk ml im bi translated">可以直接用生产者/消费者API进行简单的处理；然而，对于更复杂的转换，比如将流连接在一起，Kafka提供了一个集成的<a class="ae ne" href="https://www.google.bg/url?sa=t&amp;rct=j&amp;q=&amp;esrc=s&amp;source=web&amp;cd=1&amp;cad=rja&amp;uact=8&amp;ved=0ahUKEwiG1fu-oYDYAhVCCewKHeZMDfEQFggsMAA&amp;url=https%3A%2F%2Fkafka.apache.org%2Fdocumentation%2Fstreams%2F&amp;usg=AOvVaw30e_Zle1rMLJugJuCTx9tx" rel="noopener ugc nofollow" target="_blank">流API </a>库。</p><p id="42e8" class="pw-post-body-paragraph lq lr it ls b lt mn ju lv lw mo jx ly lz mp mb mc md mq mf mg mh mr mj mk ml im bi translated">该API旨在用于您自己的代码库中——它不是在代理上运行的。它的工作方式类似于消费者API，并帮助您将流处理工作扩展到多个应用程序(类似于消费者组)。</p><h2 id="b873" class="ms kz it bd la mt mu dn le mv mw dp li lz mx my lk md mz na lm mh nb nc lo nd bi translated">无状态处理</h2><p id="aca3" class="pw-post-body-paragraph lq lr it ls b lt lu ju lv lw lx jx ly lz ma mb mc md me mf mg mh mi mj mk ml im bi translated">流的无状态处理是不依赖于任何外部事物的确定性处理。您知道，对于任何给定的数据，您总是会产生相同的输出，而不受任何其他因素的影响。这方面的一个例子是简单的数据转换——向字符串<code class="fe ot ou ov ow b">"Hello"</code> ➡ <code class="fe ot ou ov ow b">"Hello, World!"</code>添加内容。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ox"><img src="../Images/787402c5d1f5f5c074995af35e1b6fb7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*RfJabWrHJT3ti-diKbodnA.png"/></div></div></figure><h2 id="e400" class="ms kz it bd la mt mu dn le mv mw dp li lz mx my lk md mz na lm mh nb nc lo nd bi translated">流表二元性</h2><p id="5b06" class="pw-post-body-paragraph lq lr it ls b lt lu ju lv lw lx jx ly lz ma mb mc md me mf mg mh mi mj mk ml im bi translated">重要的是要认识到流和表本质上是相同的。流可以解释为表，表可以解释为流。</p><h2 id="39c6" class="ms kz it bd la mt mu dn le mv mw dp li lz mx my lk md mz na lm mh nb nc lo nd bi translated">作为表的流</h2><p id="9f07" class="pw-post-body-paragraph lq lr it ls b lt lu ju lv lw lx jx ly lz ma mb mc md me mf mg mh mi mj mk ml im bi translated">流可以被解释为一系列的数据更新，其中聚集是表的最终结果。这种技术叫做<a class="ae ne" href="https://martinfowler.com/eaaDev/EventSourcing.html" rel="noopener ugc nofollow" target="_blank"> <em class="mm">事件源</em> </a> <em class="mm">。</em></p><p id="5b7a" class="pw-post-body-paragraph lq lr it ls b lt mn ju lv lw mo jx ly lz mp mb mc md mq mf mg mh mr mj mk ml im bi translated">如果您看看同步数据库复制是如何实现的，您会发现它是通过所谓的<em class="mm">流复制实现的，</em>表中的每个更改都被发送到副本服务器。事件来源的另一个例子是区块链分类帐——分类帐也是一系列的变更。</p><p id="2a1e" class="pw-post-body-paragraph lq lr it ls b lt mn ju lv lw mo jx ly lz mp mb mc md mq mf mg mh mr mj mk ml im bi translated">卡夫卡的作品也可以用同样的方式来解读——事件积累起来就形成了最终的状态。这种流聚合保存在本地<a class="ae ne" href="https://github.com/facebook/rocksdb/wiki/rocksdb-basics" rel="noopener ugc nofollow" target="_blank"> RocksDB </a>(默认)中，称为<em class="mm"> KTable。</em></p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi oy"><img src="../Images/ce0a306a8a0cea26e9247c101d307c06.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*r6oNBRd6Fo98gQUypQHwZQ.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">每条记录都会增加总计数</p></figure><h2 id="29c5" class="ms kz it bd la mt mu dn le mv mw dp li lz mx my lk md mz na lm mh nb nc lo nd bi translated">作为流的表</h2><p id="0dcf" class="pw-post-body-paragraph lq lr it ls b lt lu ju lv lw lx jx ly lz ma mb mc md me mf mg mh mi mj mk ml im bi translated">一个表可以被看作是一个流中每个键的最新值的快照。与流记录可以生成表一样，表更新也可以生成changelog流。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi oz"><img src="../Images/5473495f501afc1fc5406090c1829c13.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*yfucVQ9TFSQIeGuvaQC6eA.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">每次更新都会在流中产生一个快照记录</p></figure><h2 id="1176" class="ms kz it bd la mt mu dn le mv mw dp li lz mx my lk md mz na lm mh nb nc lo nd bi translated">有状态处理</h2><p id="d31d" class="pw-post-body-paragraph lq lr it ls b lt lu ju lv lw lx jx ly lz ma mb mc md me mf mg mh mi mj mk ml im bi translated">一些简单的操作，像<code class="fe ot ou ov ow b">map()</code>或<code class="fe ot ou ov ow b">filter()</code>，是无状态的，不需要你保存任何关于处理的数据。然而，在现实生活中，你要做的大多数操作都是有状态的(例如，<code class="fe ot ou ov ow b">count()</code>)，因此，需要你存储当前累积的状态。</p><p id="570c" class="pw-post-body-paragraph lq lr it ls b lt mn ju lv lw mo jx ly lz mp mb mc md mq mf mg mh mr mj mk ml im bi translated">在流处理器上维护状态的问题是流处理器可能会失败！为了使这种状态具有容错性，您需要在哪里保持这种状态？</p><p id="c51f" class="pw-post-body-paragraph lq lr it ls b lt mn ju lv lw mo jx ly lz mp mb mc md mq mf mg mh mr mj mk ml im bi translated">一种简单的方法是将所有状态存储在远程数据库中，并通过网络连接到该存储。这样做的问题是没有数据的局部性和大量的网络往返，这两者都会大大降低应用程序的速度。</p><p id="a53f" class="pw-post-body-paragraph lq lr it ls b lt mn ju lv lw mo jx ly lz mp mb mc md mq mf mg mh mr mj mk ml im bi translated">一个更微妙但重要的问题是，您的流处理作业的正常运行时间将与远程数据库紧密耦合，并且作业不会是独立的(另一个团队对数据库的更改可能会中断您的处理)。</p><p id="9c9b" class="pw-post-body-paragraph lq lr it ls b lt mn ju lv lw mo jx ly lz mp mb mc md mq mf mg mh mr mj mk ml im bi translated">那么什么是更好的方法呢？</p><p id="a5c0" class="pw-post-body-paragraph lq lr it ls b lt mn ju lv lw mo jx ly lz mp mb mc md mq mf mg mh mr mj mk ml im bi translated">回想一下表和流的二元性。这允许我们将流转换成与我们的处理放在一起的表。它还为我们提供了一种处理容错的机制——通过将流存储在Kafka代理中。</p><p id="764c" class="pw-post-body-paragraph lq lr it ls b lt mn ju lv lw mo jx ly lz mp mb mc md mq mf mg mh mr mj mk ml im bi translated">流处理器可以将其状态保存在本地表(例如RocksDB)中，该表将从输入流中更新(可能在一些任意转换之后)。当进程失败时，它可以通过重放流来恢复其数据。</p><p id="c4ed" class="pw-post-body-paragraph lq lr it ls b lt mn ju lv lw mo jx ly lz mp mb mc md mq mf mg mh mr mj mk ml im bi translated">您甚至可以让一个远程数据库成为流的生产者，有效地广播一个changelog，用它在本地重建表。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi pa"><img src="../Images/9b25b915da9d014b427826252e31b73d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*u-RmxBwTlxw7ZFeiN72BtA.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">有状态处理——用KTable连接KStream</p></figure><h2 id="94f5" class="ms kz it bd la mt mu dn le mv mw dp li lz mx my lk md mz na lm mh nb nc lo nd bi translated">KSQL</h2><p id="960c" class="pw-post-body-paragraph lq lr it ls b lt lu ju lv lw lx jx ly lz ma mb mc md me mf mg mh mi mj mk ml im bi translated">通常，您会被迫用JVM语言编写您的流处理，因为这是唯一的官方Kafka Streams API客户端。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi pb"><img src="../Images/e6bc6e0f84b5dc0be09bef2431c169d2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*jI6I0FwDBozsc1ovM7C1hg.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">示例KSQL设置</p></figure><p id="7c76" class="pw-post-body-paragraph lq lr it ls b lt mn ju lv lw mo jx ly lz mp mb mc md mq mf mg mh mr mj mk ml im bi translated"><a class="ae ne" href="https://www.confluent.io/blog/confluent-platform-4-1-with-production-ready-ksql-now-available/" rel="noopener ugc nofollow" target="_blank">发布于2018年4月</a>、<a class="ae ne" href="https://www.confluent.io/blog/ksql-open-source-streaming-sql-for-apache-kafka/" rel="noopener ugc nofollow" target="_blank">、<em class="mm"> KSQL </em>、</a>是一项功能，可以让你用熟悉的类似SQL的语言编写简单的流作业。</p><p id="e981" class="pw-post-body-paragraph lq lr it ls b lt mn ju lv lw mo jx ly lz mp mb mc md mq mf mg mh mr mj mk ml im bi translated">您设置了一个KSQL服务器，并通过一个<a class="ae ne" href="https://en.wikipedia.org/wiki/Command-line_interface" rel="noopener ugc nofollow" target="_blank"> CLI </a>交互查询它来管理处理。它使用相同的抽象(KStream和KTable)，保证了Streams API的相同优势(可伸缩性、容错性)，并极大地简化了流的工作。</p><p id="3e0e" class="pw-post-body-paragraph lq lr it ls b lt mn ju lv lw mo jx ly lz mp mb mc md mq mf mg mh mr mj mk ml im bi translated">这听起来可能不多，但是在实践中，它对测试东西更有用，甚至允许开发之外的人(例如，产品所有者)参与流处理。<a class="ae ne" href="https://www.youtube.com/watch?v=A45uRzJiv7I&amp;t=2m13s" rel="noopener ugc nofollow" target="_blank">我鼓励你看一看快速入门视频，看看它有多简单</a>。</p><h2 id="2f8f" class="ms kz it bd la mt mu dn le mv mw dp li lz mx my lk md mz na lm mh nb nc lo nd bi translated">流媒体替代品</h2><p id="03e6" class="pw-post-body-paragraph lq lr it ls b lt lu ju lv lw lx jx ly lz ma mb mc md me mf mg mh mi mj mk ml im bi translated">卡夫卡溪流是力量和简单的完美结合。可以说，它们拥有市场上最好的流工作能力，并且它们比其他流处理替代产品更容易与Kafka集成(<a class="ae ne" href="https://storm.apache.org/" rel="noopener ugc nofollow" target="_blank"> Storm </a>、<a class="ae ne" href="https://samza.apache.org/" rel="noopener ugc nofollow" target="_blank"> Samza </a>、<a class="ae ne" href="https://spark.apache.org/" rel="noopener ugc nofollow" target="_blank"> Spark </a>、<a class="ae ne" href="https://github.com/WallarooLabs/wallaroo" rel="noopener ugc nofollow" target="_blank"> Wallaroo </a>)。</p><p id="da25" class="pw-post-body-paragraph lq lr it ls b lt mn ju lv lw mo jx ly lz mp mb mc md mq mf mg mh mr mj mk ml im bi translated">大多数其他流处理框架的问题是它们使用和部署起来很复杂。像Spark这样的批处理框架需要:</p><ul class=""><li id="bac7" class="nf ng it ls b lt mn lw mo lz nh md ni mh nj ml nk nl nm nn bi translated">在一个机器池中控制大量作业，并在集群中高效地分配它们</li><li id="ba5a" class="nf ng it ls b lt no lw np lz nq md nr mh ns ml nk nl nm nn bi translated">为了实现这一点，它必须动态打包您的代码，并将其物理部署到将执行它的节点(连同配置、库等)。)</li></ul><p id="3883" class="pw-post-body-paragraph lq lr it ls b lt mn ju lv lw mo jx ly lz mp mb mc md mq mf mg mh mr mj mk ml im bi translated">不幸的是，解决这些问题使得框架变得相当具有侵略性。他们希望控制代码如何部署、配置、监控和打包的许多方面。</p><p id="e178" class="pw-post-body-paragraph lq lr it ls b lt mn ju lv lw mo jx ly lz mp mb mc md mq mf mg mh mr mj mk ml im bi translated">Kafka Streams让您在需要时推出自己的部署策略，无论是<a class="ae ne" href="https://kubernetes.io/" rel="noopener ugc nofollow" target="_blank"> Kubernetes </a>、<a class="ae ne" href="https://mesos.apache.org/" rel="noopener ugc nofollow" target="_blank"> Mesos </a>、<a class="ae ne" href="https://www.nomadproject.io/" rel="noopener ugc nofollow" target="_blank"> Nomad </a>、<a class="ae ne" href="https://github.com/docker/swarm" rel="noopener ugc nofollow" target="_blank"> Docker Swarm、</a>还是其他。</p><p id="44bc" class="pw-post-body-paragraph lq lr it ls b lt mn ju lv lw mo jx ly lz mp mb mc md mq mf mg mh mr mj mk ml im bi translated">Kafka Streams的潜在动机是让您的所有应用程序都能够进行流处理，而无需运行和维护另一个集群的复杂操作。唯一潜在的缺点是它与Kafka紧密结合，但在现代世界中，大多数(如果不是所有)实时处理都是由Kafka驱动的，这可能不是一个大缺点。</p></div><div class="ab cl ob oc hx od" role="separator"><span class="oe bw bk of og oh"/><span class="oe bw bk of og oh"/><span class="oe bw bk of og"/></div><div class="im in io ip iq"><h1 id="eb4f" class="ky kz it bd la lb oi ld le lf oj lh li jz ok ka lk kc ol kd lm kf om kg lo lp bi translated">你什么时候会用卡夫卡？</h1><p id="e9a7" class="pw-post-body-paragraph lq lr it ls b lt lu ju lv lw lx jx ly lz ma mb mc md me mf mg mh mi mj mk ml im bi translated">正如我们已经讨论过的，Kafka允许你通过一个集中的媒介传递大量的信息并存储它们，而不用担心性能或数据丢失之类的问题。</p><p id="63bf" class="pw-post-body-paragraph lq lr it ls b lt mn ju lv lw mo jx ly lz mp mb mc md mq mf mg mh mr mj mk ml im bi translated">这意味着它非常适合用作系统架构的核心，充当连接不同应用程序的集中媒介。Kafka可以成为事件驱动架构的核心，并允许您真正实现应用程序之间的解耦。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi pc"><img src="../Images/58553fa3ad06578f5bd356803c9e79e5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*FYM9wR3iNrn6PeK_3fcmkg.png"/></div></div></figure><p id="dbed" class="pw-post-body-paragraph lq lr it ls b lt mn ju lv lw mo jx ly lz mp mb mc md mq mf mg mh mr mj mk ml im bi translated">Kafka允许您轻松地分离不同(微)服务之间的通信。有了Streams API，现在比以往任何时候都更容易编写业务逻辑，为服务消费丰富Kafka主题数据。可能性是巨大的，我敦促你探索公司是如何使用卡夫卡的。</p></div><div class="ab cl ob oc hx od" role="separator"><span class="oe bw bk of og oh"/><span class="oe bw bk of og oh"/><span class="oe bw bk of og"/></div><div class="im in io ip iq"><h1 id="0bab" class="ky kz it bd la lb oi ld le lf oj lh li jz ok ka lk kc ol kd lm kf om kg lo lp bi translated">为什么它有如此多的用途？</h1><p id="bff3" class="pw-post-body-paragraph lq lr it ls b lt lu ju lv lw lx jx ly lz ma mb mc md me mf mg mh mi mj mk ml im bi translated">高性能、可用性和可伸缩性本身并不足以成为公司采用新技术的充分理由。还有其他拥有类似特性的系统，但没有一个得到如此广泛的应用。这是为什么呢？</p><p id="597c" class="pw-post-body-paragraph lq lr it ls b lt mn ju lv lw mo jx ly lz mp mb mc md mq mf mg mh mr mj mk ml im bi translated">Kafka越来越受欢迎(并继续如此)的原因是因为一个关键的事情——现在的企业从事件驱动的架构中受益匪浅。这是因为世界已经发生了变化——许多不同的服务(物联网、机器学习、移动、微服务)正在产生和消费大量(且不断增长)的数据。</p><p id="cb3e" class="pw-post-body-paragraph lq lr it ls b lt mn ju lv lw mo jx ly lz mp mb mc md mq mf mg mh mr mj mk ml im bi translated">具有持久存储的单个实时事件广播平台是实现这种架构的最干净的方式。想象一下，如果流入/流出每个服务的数据流使用专门迎合它的不同技术，那将是一种什么样的混乱。</p><p id="fbc1" class="pw-post-body-paragraph lq lr it ls b lt mn ju lv lw mo jx ly lz mp mb mc md mq mf mg mh mr mj mk ml im bi translated">这一点，加上Kafka为这种通用系统提供了适当的特征(持久存储、事件广播、表和流原语、通过KSQL的抽象、开源、积极开发)，使其成为公司的明显选择。</p></div><div class="ab cl ob oc hx od" role="separator"><span class="oe bw bk of og oh"/><span class="oe bw bk of og oh"/><span class="oe bw bk of og"/></div><div class="im in io ip iq"><h1 id="a1bf" class="ky kz it bd la lb oi ld le lf oj lh li jz ok ka lk kc ol kd lm kf om kg lo lp bi translated">摘要</h1><p id="a103" class="pw-post-body-paragraph lq lr it ls b lt lu ju lv lw lx jx ly lz ma mb mc md me mf mg mh mi mj mk ml im bi translated">Apache Kafka是一个分布式流媒体平台，每天能够处理数万亿个事件。Kafka提供低延迟、高吞吐量、容错的发布和订阅管道，并且能够处理事件流。</p><p id="eee1" class="pw-post-body-paragraph lq lr it ls b lt mn ju lv lw mo jx ly lz mp mb mc md mq mf mg mh mr mj mk ml im bi translated">我们讨论了它的基本语义(生产者、代理、消费者、主题)，了解了它的一些优化(页面缓存)，了解了它如何通过复制数据来容错，并了解了它不断增长的强大流功能。</p><p id="c291" class="pw-post-body-paragraph lq lr it ls b lt mn ju lv lw mo jx ly lz mp mb mc md mq mf mg mh mr mj mk ml im bi translated">卡夫卡已经被全球数千家公司大量采用，包括财富500强中的三分之一。随着Kafka的积极开发和最近发布的第一个<a class="ae ne" href="https://www.confluent.io/blog/apache-kafka-goes-1-0/" rel="noopener ugc nofollow" target="_blank">主要版本1.0</a>(2017年11月1日)<em class="mm">，</em>有预测称，这个流媒体平台将像关系数据库一样成为数据平台的核心。</p><p id="ffb8" class="pw-post-body-paragraph lq lr it ls b lt mn ju lv lw mo jx ly lz mp mb mc md mq mf mg mh mr mj mk ml im bi translated">我希望这篇介绍有助于您熟悉Apache Kafka及其潜力。</p></div><div class="ab cl ob oc hx od" role="separator"><span class="oe bw bk of og oh"/><span class="oe bw bk of og oh"/><span class="oe bw bk of og"/></div><div class="im in io ip iq"><h1 id="64b9" class="ky kz it bd la lb oi ld le lf oj lh li jz ok ka lk kc ol kd lm kf om kg lo lp bi translated">进一步的阅读资源和我没有提到的东西</h1><p id="1741" class="pw-post-body-paragraph lq lr it ls b lt lu ju lv lw lx jx ly lz ma mb mc md me mf mg mh mi mj mk ml im bi translated">兔子洞的深度超出了本文的范围。以下是我没有机会提及的一些特性，但了解这些特性非常重要:</p><ul class=""><li id="9283" class="nf ng it ls b lt mn lw mo lz nh md ni mh nj ml nk nl nm nn bi translated"><a class="ae ne" href="https://medium.com/@stanislavkozlovski/apache-kafkas-distributed-system-firefighter-the-controller-broker-1afca1eae302" rel="noopener">控制器代理，同步副本【Kafka保持集群健康并确保足够的一致性和持久性的方式</a></li><li id="59a7" class="nf ng it ls b lt no lw np lz nq md nr mh ns ml nk nl nm nn bi translated"><a class="ae ne" href="https://www.confluent.io/blog/announcing-kafka-connect-building-large-scale-low-latency-data-pipelines/" rel="noopener ugc nofollow" target="_blank">连接器API </a>:帮助您将各种服务连接到Kafka的API，作为源或汇(PostgreSQL、Redis、Elasticsearch)</li><li id="6198" class="nf ng it ls b lt no lw np lz nq md nr mh ns ml nk nl nm nn bi translated"><a class="ae ne" href="http://cloudurable.com/blog/kafka-architecture-log-compaction/index.html" rel="noopener ugc nofollow" target="_blank">日志压缩</a>:减少日志大小的优化。在变更日志流中非常有用。</li><li id="0d49" class="nf ng it ls b lt no lw np lz nq md nr mh ns ml nk nl nm nn bi translated"><a class="ae ne" href="https://www.confluent.io/blog/exactly-once-semantics-are-possible-heres-how-apache-kafka-does-it/" rel="noopener ugc nofollow" target="_blank">恰好一次消息语义</a>:保证消息恰好被接收一次。这是一件大事，因为很难实现。</li></ul><h2 id="dc8b" class="ms kz it bd la mt mu dn le mv mw dp li lz mx my lk md mz na lm mh nb nc lo nd bi translated">资源</h2><ul class=""><li id="4225" class="nf ng it ls b lt lu lw lx lz pd md pe mh pf ml nk nl nm nn bi translated"><a class="ae ne" href="https://medium.com/@stanislavkozlovski/apache-kafkas-distributed-system-firefighter-the-controller-broker-1afca1eae302" rel="noopener">“Apache Kafka的分布式系统消防员——控制器代理</a>”:这是我的另一篇博客文章，在这篇文章中，我深入探讨了代理之间的协调工作以及更多内容</li><li id="baf0" class="nf ng it ls b lt no lw np lz nq md nr mh ns ml nk nl nm nn bi translated"><a class="ae ne" href="https://medium.com/better-programming/kafka-acks-explained-c0515b3b707e" rel="noopener">“卡夫卡式的解释</a>”:我的一篇短文，解释了普遍混淆的<code class="fe ot ou ov ow b">acks</code>和<code class="fe ot ou ov ow b">min.isr</code>设定</li><li id="c414" class="nf ng it ls b lt no lw np lz nq md nr mh ns ml nk nl nm nn bi translated"><a class="ae ne" href="https://www.infoq.com/presentations/kafka-zookeeper/" rel="noopener ugc nofollow" target="_blank">“Kafka不需要看守人</a>”:Colin McCabe关于Apache Kafka如何基于Raft实现自己的元数据共识算法的精彩演讲</li><li id="0bd8" class="nf ng it ls b lt no lw np lz nq md nr mh ns ml nk nl nm nn bi translated">汇流博客:关于阿帕奇卡夫卡的丰富信息</li><li id="79cb" class="nf ng it ls b lt no lw np lz nq md nr mh ns ml nk nl nm nn bi translated"><a class="ae ne" href="https://kafka.apache.org/documentation/" rel="noopener ugc nofollow" target="_blank">卡夫卡文档</a>:伟大、广泛、高质量的文档</li><li id="1c41" class="nf ng it ls b lt no lw np lz nq md nr mh ns ml nk nl nm nn bi translated"><a class="ae ne" href="https://www.confluent.io/kafka-summit-sf17/resource/" rel="noopener ugc nofollow" target="_blank">卡夫卡峰会2017视频</a></li></ul><p id="5552" class="pw-post-body-paragraph lq lr it ls b lt mn ju lv lw mo jx ly lz mp mb mc md mq mf mg mh mr mj mk ml im bi translated">感谢您花时间阅读本<br/>如果您喜欢，测试一下您能点击多少次👏五秒钟后。这对你的手指来说是很好的有氧运动，并且会帮助其他人看到这个故事。<br/>你可以在Twitter上关注我，地址是<a class="ae ne" href="https://twitter.com/StanKozlovski" rel="noopener ugc nofollow" target="_blank"> @StanKozlovski </a>，谈论编程、技术、初创企业、健康、投资，还可以看看什么时候有新文章发布！</p></div></div>    
</body>
</html>