<html>
<head>
<title>Multi-State Cellular Automata in WebGL</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">WebGL中的多态元胞自动机</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/multi-state-cellular-automata-in-webgl-2bff79bf08fb?source=collection_archive---------11-----------------------#2022-09-17">https://betterprogramming.pub/multi-state-cellular-automata-in-webgl-2bff79bf08fb?source=collection_archive---------11-----------------------#2022-09-17</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="d22d" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">如何在浏览器中高效地建模和模拟任意多态元胞自动机</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/3afb57112672119e1e6d1bfe1a23131c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*Bw6MTw_knyvZir4MY593zw.gif"/></div></div></figure><p id="1482" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">这是我第一篇细胞自动机文章的重写和重要扩展。它涵盖了第一篇文章中的所有内容，外加对多态自动机的大量解释。</p><p id="2b5e" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">现场演示:【https://benpm.github.io/cellarium/ T2】</p><p id="c31d" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">我一直对康威的《生命的游戏》这样的细胞自动机很着迷。复杂而有趣的行为可以从简单的规则中产生，这个想法对我很有吸引力。在本文中，我将解释我对一类多态元胞自动机规则进行编码的方法，以及我如何实现我的模拟器。</p><h1 id="2be7" class="lp lq iq bd lr ls lt lu lv lw lx ly lz jw ma jx mb jz mc ka md kc me kd mf mg bi translated">基础知识</h1><p id="c800" class="pw-post-body-paragraph kr ks iq kt b ku mh jr kw kx mi ju kz la mj lc ld le mk lg lh li ml lk ll lm ij bi translated">细胞自动机本质上是由状态(在我们的例子中是整数)决定的细胞排列，这些状态由<strong class="kt ir">规则</strong>决定。这些规则是将单元及其邻居的状态作为输入，并将单元的新状态作为输出的函数。通过将该规则同时应用于每个单元，我们及时推进了模拟。</p><p id="d45f" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">对于这项工作，我们将只考虑具有<strong class="kt ir">摩尔邻域</strong>的<strong class="kt ir"> totalistic </strong>细胞自动机，它包含八个直接相邻的细胞。由于是总计的，这些规则只考虑邻域中每个州的总单元数，而忽略它们的排列。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi mm"><img src="../Images/7b8aff06582275556eb80fdda309f1e5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1336/format:webp/1*OKw3kCzsqmeMja-_jiF2eg.png"/></div><p class="mn mo gj gh gi mp mq bd b be z dk translated">摩尔街区</p></figure><p id="38ed" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">有了这些定义，我们可以指定一个<strong class="kt ir">规则函数</strong>，F:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi mr"><img src="../Images/ec6281ed39994b68884a9013811e3cd1.png" data-original-src="https://miro.medium.com/v2/resize:fit:268/format:webp/1*pwrqQQRJgnyiAwNzEjk4sw.png"/></div></figure><p id="f956" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">o是输出状态，c是当前状态，N是表示每个可能状态的邻居总数的整数序列:N的第I个元素是状态为I的邻居总数，在上面的例子中，c=0，N=(3，3，2)。</p><p id="cbc0" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">首先，让我们考虑两种可能的状态:“开”(1)和“关”(0)，就像《生命的游戏》一样。首先要注意的是，由于邻居总数始终为8，我们只需考虑(1)个邻居，因为(0)个邻居的数量始终为8 N1。(我们也可以选择只计算(0)个邻居的数量)。</p><p id="f731" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">那么，我们如何表示规则函数，以便在我们的约束下模拟任何双态规则呢？因为我们函数的输入只是整数，所以我们可以用它们来索引一个表，就像这样:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi ms"><img src="../Images/d54ca5fb836fed25a0e482660ae6982f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1088/format:webp/1*xdSA2314BpqGSMpnM1XUWQ.png"/></div></figure><p id="05ba" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">这里，我们有一个包含输出状态的表，这是通过按行(当前状态，c)和列(邻居的数量，N1)查询该表找到的。在上面的例子中，F(1，5)=0，所以如果一个单元的状态是(1)，并且它有五(1)个邻居，它就变成(0)。</p><p id="1bb3" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">让我们试着用这种格式来编码生命的游戏。用英语来说，生活的游戏规则是:</p><ol class=""><li id="6233" class="mt mu iq kt b ku kv kx ky la mv le mw li mx lm my mz na nb bi translated">任何单元上的<em class="ln">与两个或三个<em class="ln">单元上的</em>邻居保持<em class="ln">在</em></em></li><li id="927b" class="mt mu iq kt b ku nc kx nd la ne le nf li ng lm my mz na nb bi translated">任何一个<em class="ln">关闭</em>且三个<em class="ln">打开</em>的相邻单元打开<em class="ln">打开</em></li><li id="879e" class="mt mu iq kt b ku nc kx nd la ne le nf li ng lm my mz na nb bi translated">所有其他单元关闭<em class="ln"/>，包括已经关闭<em class="ln">的单元</em></li></ol><p id="8177" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">因此，在F的表格表示中:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi nh"><img src="../Images/86a923cfd24254e5be709f295fcf76b6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1082/format:webp/1*H1kyTUIjOiSddYU0blgFfg.png"/></div></figure><p id="0cb5" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">简单又好看！现在我们可以开始考虑如何在着色器中使用它。模拟将在整数格式的纹理上进行，我们可以这样访问它:</p><pre class="kg kh ki kj gt ni nj nk nl aw nm bi"><span id="2f7a" class="nn lq iq nj b gy no np l nq nr">// simulate.frag<br/>#version 300 es<br/>uniform highp usampler2D uSim; // Simulation texture<br/>in vec2 vTextureCoord;         // Texture coordinates 0.0 to 1.0</span><span id="ca9e" class="nn lq iq nj b gy ns np l nq nr">void main(void) {<br/>    // Get the current state<br/>    int curstate = int(texture(uSim, vTextureCoord).r);</span><span id="8942" class="nn lq iq nj b gy ns np l nq nr">    // Determine number of (1) neighbors<br/>    int count = -curstate;<br/>    for (int x = -1; x &lt;= 1; x += 1) {<br/>        for (int y = -1; y &lt;= 1; y += 1) {<br/>            if (v == 1) {<br/>                count += 1;<br/>            }<br/>        }<br/>    }<br/>}</span></pre><blockquote class="nt nu nv"><p id="090d" class="kr ks ln kt b ku kv jr kw kx ky ju kz nw lb lc ld nx lf lg lh ny lj lk ll lm ij bi translated"><strong class="kt ir"> <em class="iq">注意:</em> </strong> <em class="iq">我们将</em> <code class="fe nz oa ob nj b"><em class="iq">count</em></code> <em class="iq">初始化为</em> <code class="fe nz oa ob nj b"><em class="iq">-curstate</em></code> <em class="iq">以防止对当前单元格进行计数。也避免了分支，在一个GPU上可以很贵，</em> <a class="ae lo" href="https://developer.nvidia.com/gpugems/gpugems2/part-iv-general-purpose-computation-gpus-primer/chapter-34-gpu-flow-control-idioms" rel="noopener ugc nofollow" target="_blank"> <em class="iq">视情况</em> </a> <em class="iq">。</em></p></blockquote><p id="f04e" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">现在我们有了c作为<code class="fe nz oa ob nj b">curstate</code>和N1作为<code class="fe nz oa ob nj b">count</code>，我们可以从规则中获取我们的下一个状态，它也存储在一个纹理中:</p><pre class="kg kh ki kj gt ni nj nk nl aw nm bi"><span id="cb22" class="nn lq iq nj b gy no np l nq nr">// simulate.frag<br/>#version 300 es<br/>uniform highp usampler2D uRule; // Rule table<br/>uniform highp usampler2D uSim;  // Simulation texture<br/>in vec2 vTextureCoord;          // Texture coordinates 0.0 to 1.0<br/>out uvec3 fragColor;</span><span id="2d36" class="nn lq iq nj b gy ns np l nq nr">void main(void) {<br/>    // Get the current state<br/>    int curstate = int(texture(uSim, vTextureCoord).r);</span><span id="a4ec" class="nn lq iq nj b gy ns np l nq nr">    // Determine number of (1) neighbors<br/>    int count = -curstate;<br/>    for (int x = -1; x &lt;= 1; x += 1) {<br/>        for (int y = -1; y &lt;= 1; y += 1) {<br/>            if (v == 1) {<br/>                count += 1;<br/>            }<br/>        }<br/>    }</span><span id="50ca" class="nn lq iq nj b gy ns np l nq nr">    uint newstate = texelFetch(uRule, ivec2(count, curstate), 0).r;<br/>    fragColor = uvec3(newstate);<br/>}</span></pre><blockquote class="nt nu nv"><p id="06fe" class="kr ks ln kt b ku kv jr kw kx ky ju kz nw lb lc ld nx lf lg lh ny lj lk ll lm ij bi translated"><strong class="kt ir"> <em class="iq">注:</em> </strong> <em class="iq">这里我们用</em> <code class="fe nz oa ob nj b"><a class="ae lo" href="https://www.khronos.org/registry/OpenGL-Refpages/es3.0/html/texelFetch.xhtml" rel="noopener ugc nofollow" target="_blank"><em class="iq">texelFetch()</em></a></code> <em class="iq">代替</em> <code class="fe nz oa ob nj b"><a class="ae lo" href="https://www.khronos.org/registry/OpenGL-Refpages/es3.0/html/texture.xhtml" rel="noopener ugc nofollow" target="_blank"><em class="iq">texture()</em></a></code> <em class="iq">来避免昂贵的浮点转换和片段到纹理的坐标转换。我们不为采样模拟纹理这样做，因为它不支持纹理包裹。</em></p></blockquote><p id="9804" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">为了运行我们的模拟，我们使用两个不同的纹理附加到帧缓冲区，一个作为输出，一个作为输入。通过在每个时间步骤中交替他们的角色，我们期望的结果终于产生了！</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi oc"><img src="../Images/bd1539f63e74b0f2ecc4f058f84768ba.png" data-original-src="https://miro.medium.com/v2/resize:fit:1284/1*cULKSCYYXFtOUTtpyy1XCg.gif"/></div><p class="mn mo gj gh gi mp mq bd b be z dk translated">一个有趣的双态规则</p></figure><p id="1d48" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">那么这给了我们多少可能的规则呢？c有2个可能的值，N1有9个可能的值(从0，1，2到8，包括8)。因为f只能返回2个可能的值，所以可能的规则总数是22⋅9=262144！不错，但我们可以做得更好…</p><h1 id="31bc" class="lp lq iq bd lr ls lt lu lv lw lx ly lz jw ma jx mb jz mc ka md kc me kd mf mg bi translated">编码多种状态</h1><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi od"><img src="../Images/34912377fe4aa10a9f9324d30d5307ae.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*B0_d3xJ5bJj9xDf9KurugA.gif"/></div></div></figure><p id="8995" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">虽然两种状态足以产生有趣的行为，但多状态规则可以有<a class="ae lo" href="https://en.wikipedia.org/wiki/Brian%27s_Brain" rel="noopener ugc nofollow" target="_blank">一些</a> <a class="ae lo" href="https://en.wikipedia.org/wiki/Wireworld" rel="noopener ugc nofollow" target="_blank">非常</a> <a class="ae lo" href="https://en.wikipedia.org/wiki/Codd%27s_cellular_automaton" rel="noopener ugc nofollow" target="_blank">酷</a> <a class="ae lo" href="https://en.wikipedia.org/wiki/Von_Neumann_cellular_automaton" rel="noopener ugc nofollow" target="_blank">属性</a>，所以让我们弄清楚如何高效地编码这些更复杂的规则。</p><p id="f1de" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">首先，让我们想象一下，我们有3个状态，而不是2个。我们不仅需要一个额外的邻居计数N2作为规则函数的输入，而且可能的输入集变得更加细微。例如，如果N2=4，则(1)和(0)的可能邻居计数受到限制，因为所有邻居计数的总和必须等于8。换句话说:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi oe"><img src="../Images/e84bf7c4f36c93514523642c3eee2e06.png" data-original-src="https://miro.medium.com/v2/resize:fit:332/format:webp/1*pItQxD3GV8XXsokPG674LA.png"/></div></figure><p id="aee6" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">在这种情况下，N=(3，4，5)是<em class="ln">无效的</em>，因为N的总和不幸是12，而不是8。当然，这也适用于我们的2态情况，但我们不必担心它，因为n0的值隐式地仅由n1定义。</p><p id="2d5f" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">那么，考虑到这个属性，我们如何索引我们的规则纹理呢？好吧，让我们先来看看我们可能希望如何将可能的Ns映射到索引，通过某种“向上计数”:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi of"><img src="../Images/016afa8eea01759fd22f1cd38f78fbdd.png" data-original-src="https://miro.medium.com/v2/resize:fit:698/format:webp/1*HWbn0C6cr8ExOYzoGJUACw.png"/></div></figure><blockquote class="nt nu nv"><p id="e41f" class="kr ks ln kt b ku kv jr kw kx ky ju kz nw lb lc ld nx lf lg lh ny lj lk ll lm ij bi translated"><strong class="kt ir"/></p></blockquote><p id="0e12" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">首先要注意的是，前9个条目的N0=0，这就像我们只有两个状态。这意味着，如果我们考虑到第四种状态，我们可以把它加到表的末尾。这也意味着我们可以将表的长度(可能的ns总数)表示为状态数n的函数。</p><p id="616b" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">一个状态有1个可能的输入，两个状态有9个，如果我们扩展这个表，我们会发现3个状态有45个可能的输入。<a class="ae lo" href="https://oeis.org/" rel="noopener ugc nofollow" target="_blank"> OEIS </a>告诉我们1，9，45，…的顺序是(n+78)。注意:8是我们的目标总和，7只是8–1。事实上，(n+S1)是任何目标和s的一般形式。</p><p id="217d" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">那么这些数字从何而来呢？如果我们按州排列可能的输入序列，就很清楚了:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi og"><img src="../Images/61674ffa435624e5f4b893bd7fcbfcdb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*K10kOkrsec3Ayk86wF8FVg.png"/></div></div></figure><p id="8c98" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">既然我们可以计算任意给定长度n和目标和s的序列的最大索引，我们最终可以计算一个索引。过程是这样的:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi oh"><img src="../Images/1db9667ed449bcd070193cf522b2e2f1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*5EZRICr48qIzvcphnlZxRQ.png"/></div></div></figure><p id="ab86" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">…其中，初始化为0的v是给定序列s的计算索引，s是序列中I之后元素的剩余和，它作为我们的目标和开始(对于我们的目的，8)。当我们遍历它时，S减少了S的每个元素的值。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi oi"><img src="../Images/30e88753097b26304fb3c6fe6d13e66a.png" data-original-src="https://miro.medium.com/v2/resize:fit:188/format:webp/1*fg6yR_HCvlGsJZFkWO_aqg.png"/></div></figure><p id="92e6" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">是计算最大指数的公式，只是我们计算的是长度为ni的序列的最大指数，其总和等于整个序列s的余数。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi oj"><img src="../Images/9f612beb6150ad9b1c0e7f7f9394319f.png" data-original-src="https://miro.medium.com/v2/resize:fit:234/format:webp/1*-MsXSSp3EpijgTlUCkNoVg.png"/></div></figure><p id="0fbc" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">提供长度为ni的序列的最大索引，其总和为Si，即元素Si之后的剩余总和。</p><p id="60a8" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">取这两个量的差，通过将所有i <n we="" get="" the="" index="" of="" whole="" sequence=""/></p><p id="142a" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">For clarity, I’ve also written the algorithm in Python:</p><pre class="kg kh ki kj gt ni nj nk nl aw nm bi"><span id="2c43" class="nn lq iq nj b gy no np l nq nr"># n: sequence length<br/># S: the sequence<br/># s: the integer value which each sequence sums to</span><span id="7cf4" class="nn lq iq nj b gy ns np l nq nr"># The computed index, starts at 0<br/>v = 0</span><span id="0ca1" class="nn lq iq nj b gy ns np l nq nr"># algorithm: Consider each element of the sequence S as a subsequence,<br/>#  where each element is an increasingly smaller subsequence.<br/>#  By summing together the indices of each subsequence, we get the<br/>#  index of the whole sequence. We start with the longest subsequence.<br/>for i in range(n - 1):<br/>    # l: Max index of subsequence that sums to n minus whatever we've seen so far<br/>    l = comb((s) + (n - i - 1), s) <br/>    # r: Like l, but for sequences that sum to current minus S[i], the element we are considering<br/>    r = comb((s - S[i]) + (n - i - 1), s - S[i])<br/>    # Add l-r, the index of the part of the sequence we've seen so far<br/>    v += ( l - r )<br/>    # Subtract the current sequence element from current sum<br/>    s -= S[i]</span></pre><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi od"><img src="../Images/eec4de8ad4ac7498c158643265da6ea0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*RUhK8ikoBqx55NGF-Z_1zw.gif"/></div></div></figure><h1 id="c91f" class="lp lq iq bd lr ls lt lu lv lw lx ly lz jw ma jx mb jz mc ka md kc me kd mf mg bi translated">Implementation</h1><p id="bc02" class="pw-post-body-paragraph kr ks iq kt b ku mh jr kw kx mi ju kz la mj lc ld le mk lg lh li ml lk ll lm ij bi translated">To implement this algorithm efficiently in a shader, we need to pre-compute binomial coefficients into a texture:</p><pre class="kg kh ki kj gt ni nj nk nl aw nm bi"><span id="4d31" class="nn lq iq nj b gy no np l nq nr">function buildBinomial() {<br/>    const data = new Uint32Array(32 * 32);<br/>    data.fill(0);<br/>    for (let n = 0; n &lt; 32; n++) {<br/>        for (let k = 0; k &lt; 32; k++) {<br/>            data[k * 32 + n] = binomial(n, k);<br/>        }<br/>    }<br/>    const binomialTex = this.gl.createTexture();<br/>    this.gl.bindTexture(this.gl.TEXTURE_2D, binomialTex);<br/>    // We use 32-bit unsigned integers because we need to store large numbers<br/>    this.gl.texImage2D(this.gl.TEXTURE_2D, 0, this.gl.R32UI, 32, 32, 0, this.gl.RED_INTEGER, this.gl.UNSIGNED_INT, data);<br/>}</span></pre><p id="b2bf" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">We access the texture like this, using texelFetch():</p><pre class="kg kh ki kj gt ni nj nk nl aw nm bi"><span id="0d79" class="nn lq iq nj b gy no np l nq nr">#version 300 es</span><span id="859d" class="nn lq iq nj b gy ns np l nq nr">uniform highp usampler2D uBinomial</span><span id="e182" class="nn lq iq nj b gy ns np l nq nr">// Returns binomial coefficient (n choose k) from precompute texture<br/>int binomial(int n, int k) {<br/>    return int(texelFetch(uBinomial, ivec2(n, k), 0).r);<br/>}</span></pre><p id="3d6f" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">Finally, we have everything we need for the final shader!</p><pre class="kg kh ki kj gt ni nj nk nl aw nm bi"><span id="b29d" class="nn lq iq nj b gy no np l nq nr">// simulate.frag<br/>#version 300 es<br/>precision mediump float;</span><span id="9922" class="nn lq iq nj b gy ns np l nq nr">uniform highp usampler2D uSim;   // Input states texture<br/>uniform highp usampler2D uRule;      // The cellular automata rule<br/>uniform highp usampler2D uBinomial;  // Precomputed binomial coefficents<br/>uniform vec2 uSize;                  // Size of simulation canvas in pixels<br/>uniform int uStates;                 // Number of states in this rule (MAX 14)<br/>uniform int uSubIndices;             // Number pf subrule indices</span><span id="5fd5" class="nn lq iq nj b gy ns np l nq nr">in vec2 vTextureCoord;</span><span id="46e4" class="nn lq iq nj b gy ns np l nq nr">out uvec3 fragColor;</span><span id="6993" class="nn lq iq nj b gy ns np l nq nr">// Returns binomial coefficient (n choose k) from precompute texture<br/>int binomial(int n, int k) {<br/>    return int(texelFetch(uBinomial, ivec2(n, k), 0).r);<br/>}</span><span id="4a8d" class="nn lq iq nj b gy ns np l nq nr">void main(void) {<br/>    int curstate = int(texture(uSim, vTextureCoord).r);</span><span id="7a42" class="nn lq iq nj b gy ns np l nq nr">    // Neighbor counts by state index<br/>    int N[14] = int[](0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0);<br/>    N[curstate] = -1;</span><span id="f845" class="nn lq iq nj b gy ns np l nq nr">    // Determine neighbor counts<br/>    for (int x = -1; x &lt;= 1; x += 1) {<br/>        for (int y = -1; y &lt;= 1; y += 1) {<br/>            uint i = texture(uSim, vTextureCoord + (vec2(x, y) / uSize)).r;<br/>            N[i] += 1;<br/>        }<br/>    }</span><span id="2ae3" class="nn lq iq nj b gy ns np l nq nr">    // Determine the index of the integer sequence formed by the neighbor counts<br/>    int seqIndex = 0;<br/>    int s = 8;<br/>    for (int i = 0; i &lt; 13; i++) {<br/>        if (N[i] &gt; 0) {<br/>            int x = uStates - i - 1;<br/>            seqIndex += binomial(s + x, s) - binomial(s - N[i] + x, s - N[i]);<br/>            s -= N[i];<br/>        }<br/>    }<br/>    // Compute final index into rule tex given current state and neighbor states<br/>    int ruleIndex = curstate * uSubIndices + seqIndex;<br/>    // Convert 1D rule index into 2D coordinate into rule texture<br/>    uint newstate = texelFetch(uRule, ivec2(ruleIndex % 1024, ruleIndex / 1024), 0).r;</span><span id="5364" class="nn lq iq nj b gy ns np l nq nr">    fragColor = uvec3(newstate);<br/>}</span></pre><p id="612c" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">Now we have a working shader that simulates arbitrary multi-state cellular automatons! You can see a live demo <a class="ae lo" href="https://benpm.github.io/cellarium/" rel="noopener ugc nofollow" target="_blank">这里</a>，以及所有源代码<a class="ae lo" href="https://github.com/benpm/cellarium" rel="noopener ugc nofollow" target="_blank">这里</a>相加，我们得到序列的索引，直到I。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi ok"><img src="../Images/9beb90e23d3dbbfc852be6f49f4279d8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*-D-4lR1pCDFXH5z3LdaUtA.gif"/></div></div></figure><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi ol"><img src="../Images/ed8db424929ac7e7b8e388f8bd5f4193.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*9R4EMhrbUl7J7byTm5XhOA.png"/></div></div></figure></div></div>    
</body>
</html>