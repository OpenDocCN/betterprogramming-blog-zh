<html>
<head>
<title>Will React Server Components Replace SSR?</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">React服务器组件会取代SSR吗？</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/will-react-server-components-replace-ssr-f2f772347109?source=collection_archive---------3-----------------------#2021-04-06">https://betterprogramming.pub/will-react-server-components-replace-ssr-f2f772347109?source=collection_archive---------3-----------------------#2021-04-06</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="e65f" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">React服务器组件的诞生及其对SSR的影响</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/a469231ee3b8614ef1f68438150e5cc4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ALXwcND3MAaJNI-pByP7vw.jpeg"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">作者照片。</p></figure><p id="a8b1" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated"><a class="ae lr" href="https://reactjs.org/blog/2020/12/21/data-fetching-with-react-server-components.html" rel="noopener ugc nofollow" target="_blank"> React服务器组件</a>是React最近推出的一个全新特性。这是人们最期待的特性之一，它允许你和谐地使用客户机和服务器组件。</p><p id="491b" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">尽管它仍处于实验阶段，但它的功能还有很多值得借鉴的地方。</p><p id="9ecc" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">然而，你们中的一些人可能会想，“我们已经有了服务器端渲染(SSR)，现在又有了另一种选择。”</p></div><div class="ab cl ls lt hu lu" role="separator"><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx"/></div><div class="ij ik il im in"><h1 id="177c" class="lz ma iq bd mb mc md me mf mg mh mi mj jw mk jx ml jz mm ka mn kc mo kd mp mq bi translated">SSR呢？</h1><p id="eba0" class="pw-post-body-paragraph kv kw iq kx b ky mr jr la lb ms ju ld le mt lg lh li mu lk ll lm mv lo lp lq ij bi translated">了解React服务器端渲染和服务器组件有不同的用途是很重要的。</p><p id="ff5c" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">React SSR是为了加速React应用程序的初始加载。为了实现这一点，SSR提供了一种机制来定义当最终用户访问应用程序URL时，您需要向他们显示什么。</p><p id="3786" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">根据应用程序的UX(用户体验)需求，它可以是加载图标，也可以是内容填充页面。但是在引导React应用程序之后，交互就变得活跃了。</p><p id="7b79" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">尽管如此，您可能想知道为什么我们需要服务器组件。在回答这个问题之前，让我们了解一下他们。</p></div><div class="ab cl ls lt hu lu" role="separator"><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx"/></div><div class="ij ik il im in"><h1 id="d21f" class="lz ma iq bd mb mc md me mf mg mh mi mj jw mk jx ml jz mm ka mn kc mo kd mp mq bi translated">React服务器组件</h1><p id="3751" class="pw-post-body-paragraph kv kw iq kx b ky mr jr la lb ms ju ld le mt lg lh li mu lk ll lm mv lo lp lq ij bi translated">React的新服务器组件呈现在服务器端。</p><p id="26f9" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">您甚至可以编写一个服务器组件来从数据库中获取数据，并使用Node.js呈现其内容。这多酷啊！</p><p id="13f3" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">您还可以在一个React应用程序中同时使用服务器组件和客户端组件。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/3cf0d856bea811a2d96ac5ec6e97fd5e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*vJMaop0HWzyr6YDEr9lXlg.jpeg"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">使服务器组件和客户端组件协同工作</p></figure><p id="5cbc" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">让我们看看React服务器组件带来的其他一些优势。</p><h2 id="6f19" class="mw ma iq bd mb mx my dn mf mz na dp mj le nb nc ml li nd ne mn lm nf ng mp nh bi translated">控制JavaScript包的大小</h2><p id="586c" class="pw-post-body-paragraph kv kw iq kx b ky mr jr la lb ms ju ld le mt lg lh li mu lk ll lm mv lo lp lq ij bi translated">有了服务器组件，您可以更好地控制包的大小。我们举个例子。假设您的项目中有十个依赖项。如果你只需要将其中的五个下载到浏览器中，其余的留在服务器中，那该怎么办？</p><p id="0c1d" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">考虑到它们的大小，您可以选择通过将它们移动到服务器组件来减少一些依赖项。</p><h2 id="8391" class="mw ma iq bd mb mx my dn mf mz na dp mj le nb nc ml li nd ne mn lm nf ng mp nh bi translated">零束尺寸组件是可能的</h2><p id="794f" class="pw-post-body-paragraph kv kw iq kx b ky mr jr la lb ms ju ld le mt lg lh li mu lk ll lm mv lo lp lq ij bi translated">最令人兴奋的是，在某些应用程序中，您可能不需要在浏览器中保留任何依赖关系。包的大小将比以往任何时候都小。</p><h2 id="fbea" class="mw ma iq bd mb mx my dn mf mz na dp mj le nb nc ml li nd ne mn lm nf ng mp nh bi translated">增加代码重用</h2><p id="c3d8" class="pw-post-body-paragraph kv kw iq kx b ky mr jr la lb ms ju ld le mt lg lh li mu lk ll lm mv lo lp lq ij bi translated">因为您可以选择客户机和服务器组件，所以您可以为正确的工作选择正确的组件。</p><p id="e905" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">例如，您可以选择一个服务器组件在服务器端呈现发票并显示预览，同时使用相同的输出生成PDF。</p><p id="ec55" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">对于特定的用例，您还可以与SSR和服务器组件共享JavaScript库。</p><h2 id="0af3" class="mw ma iq bd mb mx my dn mf mz na dp mj le nb nc ml li nd ne mn lm nf ng mp nh bi translated">兼容许多JavaScript框架</h2><p id="0982" class="pw-post-body-paragraph kv kw iq kx b ky mr jr la lb ms ju ld le mt lg lh li mu lk ll lm mv lo lp lq ij bi translated">服务器组件从一开始就被开发用于任何JavaScript元框架，比如Next.js和Gatsby。</p><p id="5adf" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">它们允许开发人员使用单一语言和单一框架来编写应用程序。最重要的是，开发人员可以在服务器和客户端共享代码。</p><h2 id="37b4" class="mw ma iq bd mb mx my dn mf mz na dp mj le nb nc ml li nd ne mn lm nf ng mp nh bi translated">跨项目重用客户端和服务器组件</h2><p id="4b7b" class="pw-post-body-paragraph kv kw iq kx b ky mr jr la lb ms ju ld le mt lg lh li mu lk ll lm mv lo lp lq ij bi translated">您还可以使用<a class="ae lr" href="https://bit.dev/" rel="noopener ugc nofollow" target="_blank">位</a>开源平台跨多个项目共享客户端和服务器组件。这将有助于最大化代码重用，并在整个产品组合中保持一致的设计。</p><p id="234b" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">但是，如果已经在使用Bit集合，可以为支持Node.js的服务器组件创建单独的集合。</p><p id="eb94" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">这样，您可以将它们分开，并定义将它们注入到任何项目的服务器组件树中的位置。</p><h2 id="133f" class="mw ma iq bd mb mx my dn mf mz na dp mj le nb nc ml li nd ne mn lm nf ng mp nh bi translated">已知限制</h2><p id="0a36" class="pw-post-body-paragraph kv kw iq kx b ky mr jr la lb ms ju ld le mt lg lh li mu lk ll lm mv lo lp lq ij bi translated">尽管服务器组件是全新的，但React团队在优先考虑这个急需的特性方面做得非常出色。但是，您应该知道一些限制。</p><p id="e9ff" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">在某些情况下，不可能将所有组件都作为服务器专用组件。此外，缺乏对React挂钩(<code class="fe ni nj nk nl b">useState()</code>，<code class="fe ni nj nk nl b">useEffect()</code>)的支持将限制它们在特定用例中的应用。</p><p id="ea6e" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">由于该特性是新的，因此服务器组件需要进行一些优化。</p><p id="fb26" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">例如，当前，相同的代码被重新运行，并且组件将在每个请求时重新呈现。</p><p id="ed08" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">此外，服务器组件需要相当多的关注，包括路由和重新获取。因此，考虑如何将“当前SPA”移植到他们身上还为时过早。它们对建筑有着重要的影响，并不是偶然出现的。</p></div><div class="ab cl ls lt hu lu" role="separator"><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx"/></div><div class="ij ik il im in"><h1 id="8517" class="lz ma iq bd mb mc md me mf mg mh mi mj jw mk jx ml jz mm ka mn kc mo kd mp mq bi translated">服务器组件，SSR，还是两者都有？</h1><p id="811b" class="pw-post-body-paragraph kv kw iq kx b ky mr jr la lb ms ju ld le mt lg lh li mu lk ll lm mv lo lp lq ij bi translated">如您所知，服务器组件和SSR是相辅相成的。</p><p id="500c" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">如果我们仔细观察SSR，我们可以指示web服务器在加载单个页面时呈现一个组件。例如，如果我们使用Node.js，我们可以安装<code class="fe ni nj nk nl b">‘react-dom/server’</code> NPM库，并使用它来呈现<code class="fe ni nj nk nl b">App</code>组件:</p><pre class="kg kh ki kj gt nm nl nn no aw np bi"><span id="ef49" class="mw ma iq nl b gy nq nr l ns nt">ReactDOMServer.renderToString(&lt;App /&gt;);</span></pre><p id="6302" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">如您所见，这是一次性操作。在应用程序的初始加载之后，我们没有多余的时间从服务器端呈现任何其他组件。</p><p id="d55d" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">因此，正如我之前解释的那样，SSR改善了初始页面加载时间，并向用户显示了早期输出——甚至在JavaScript包加载之前。</p><p id="c1ce" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">另一方面，服务器组件与React客户端组件协同工作(识别客户端组件树和服务器组件树)。这发生在JavaScript包被加载之后。</p><p id="d6da" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">此外，它们呈现内容的方式也有所不同。例如，服务器组件不呈现HTML。它们以类似于JSON的特定格式呈现。</p><pre class="kg kh ki kj gt nm nl nn no aw np bi"><span id="2f36" class="mw ma iq nl b gy nq nr l ns nt">J0:{"$","div","null",{"className":"main-class"}}</span></pre><p id="c495" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">所以，让我们来回答这个棘手的问题:服务器组件会取代SSR吗？</p><p id="f7a7" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">简而言之，没有！我希望你已经明白为什么了。</p><p id="1738" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">让我们看看您可以考虑使用React服务器组件的几个地方:</p><ul class=""><li id="4b02" class="nu nv iq kx b ky kz lb lc le nw li nx lm ny lq nz oa ob oc bi translated">如果我们需要的某个特定组件的库很大，但是没有在其他地方使用。</li><li id="77ac" class="nu nv iq kx b ky od lb oe le of li og lm oh lq nz oa ob oc bi translated">在移动设备上渲染复杂的组件需要时间。</li><li id="7246" class="nu nv iq kx b ky od lb oe le of li og lm oh lq nz oa ob oc bi translated">代码可在前端和后端重用的地方(例如PDF预览和下载)。</li></ul><p id="af80" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">另一方面，您仍然需要依靠SSR来完成以下工作:</p><ul class=""><li id="8a1b" class="nu nv iq kx b ky kz lb lc le nw li nx lm ny lq nz oa ob oc bi translated">在React应用程序加载之前，用户可以看到初始加载、布局甚至丰富的内容。</li><li id="7559" class="nu nv iq kx b ky od lb oe le of li og lm oh lq nz oa ob oc bi translated">SEO友好的内容。</li><li id="aeba" class="nu nv iq kx b ky od lb oe le of li og lm oh lq nz oa ob oc bi translated">为React应用程序提供任何种子数据，以便在不调用服务器的情况下即时呈现(例如登录用户的详细信息)。</li></ul><p id="2ff6" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">因此，通过使用SSR和React服务器组件来获得两个世界的最佳效果是很重要的。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi oi"><img src="../Images/50c610d9ff1dcb8fb3b06e393d6217c2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*jSpGN1OATUHQwWjbdfqUnw.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">服务器组件和SSR之间的比较</p></figure><p id="8ca2" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">然而，在实践中，您仍然会在您的项目中主要使用客户端组件和SSR。您将只在重要的地方考虑React服务器组件。</p><p id="7d29" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">感谢阅读！干杯！</p></div></div>    
</body>
</html>