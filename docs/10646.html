<html>
<head>
<title>Unleashing the Power of Bio-inspired Parallelism With Membrane Computing</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">利用膜计算释放生物启发的并行能力</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/unleashing-the-power-of-bio-inspired-parallelism-with-membrane-computing-c450a225a770?source=collection_archive---------23-----------------------#2022-01-19">https://betterprogramming.pub/unleashing-the-power-of-bio-inspired-parallelism-with-membrane-computing-c450a225a770?source=collection_archive---------23-----------------------#2022-01-19</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="3156" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">开放式MPI膜计算的快速实用介绍</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/32539bf27a1f560c1ced30011ab2f081.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*33G4sOVN7eDv27t2"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated"><a class="ae kv" href="https://unsplash.com/@nci?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">国家癌症研究所</a>在<a class="ae kv" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</p></figure><p id="dd1e" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">也许你们大多数人已经听说过量子计算、量子位、纠缠和其他一些看起来很“酷”的东西，只是因为它们的名字中含有“量子”。你不知道的是，目前所有这些“量子”的东西在实践中是不可行的。</p><p id="a8d3" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">是的，我们有一些真正的量子计算机，如<a class="ae kv" href="https://en.wikipedia.org/wiki/IBM_Q_System_One" rel="noopener ugc nofollow" target="_blank"> IBM-Q </a>或<a class="ae kv" href="https://en.wikipedia.org/wiki/Sycamore_processor" rel="noopener ugc nofollow" target="_blank"> Google Sycamore </a>，但它们只能解决一些难题的玩具例子。更糟糕的是，我们无法从量子物理学中获得灵感，为我们的经典计算机创建一个高效的计算模型。这是因为我们无法在经典芯片上实现量子效应。</p><p id="19fa" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在这个故事中，我想向你们展示一种新的计算模型，它是由活细胞的结构和功能启发而来的——膜计算。更确切地说，这个模型是受到细胞膜在细胞结构中的作用的启发。</p><h1 id="4d19" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">模型的快速概述</h1><p id="0a35" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">细胞膜将细胞内的两个部分隔开，允许一些化学物质从一个方向或另一个方向通过。所有的化学物质都按照一定的进化规则进化。一个规则可以是一个重写规则，如果它描述了一个隔间内的化学物质的转化，或者它可以是一个通信规则，如果它描述了化学物质从一个隔间到另一个隔间的移动。所有的化学物质都被称为物体。</p><p id="d83b" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">膜计算中的主要数据结构是多重集。多重集代表一个集合，其中每个元素都有多重性。在多重集中，顺序不算。通俗地说，膜可以被视为三维欧几里得空间中的球。膜结构的组成部分如图1所示。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi mp"><img src="../Images/0ec760cb2e7d63ef8139bacce3088ec1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*U6uTAvVl4a8T2ptDDfH3Ng.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">膜结构</p></figure><p id="ae01" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">生化反应通过多重集重写规则来建模。规则接收一个多重集作为输入，并返回一个多重集和一些标签。标签指示规则如何在膜之间移动对象。例如，规则aabc-&gt;cbd将一份c中的两份a和一份c转化为a d，b具有催化剂的作用。这个规则所涉及的所有对象都不会离开由膜所界定的区域。</p><p id="4c3f" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">规则可以将对象发送到当前区域之外，也可以将对象导入当前区域。例如，规则aabc-&gt;a(here)d(out)c(in)在当前区域中维护对象a，并将对象d和c分别发送到较高和较低的邻居。在当前膜具有多个较低邻居的情况下，对象被非确定性地发送到其中一个。</p><p id="b6b1" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">规则u-&gt;v在特定区域中的应用只有在该区域包含所需多重性的所有对象时才是可能的。规则销毁由u描述的对象，并在规则指定的位置(上邻居或下邻居)创建由v描述的对象。</p><p id="8478" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">有两种类型的通信规则:同向端口和反向端口。符号规则的形式为(u，in)或(v，out)。当应用规则(u，in)时，来自多集u的对象从当前区域中被破坏，并被创建到较低的邻居之一中。类似地，当应用规则(v，out)时，来自多重集v的对象从当前区域中被销毁，并在上部邻居中被创建。反向传输规则的形式为(u，outv，in)。这种类型的规则同时破坏来自当前区域的u和v的对象，并且将它们分别创建到上邻居和下邻居中。非正式地，一个膜结构和一组进化规则被称为P系统(P来自<a class="ae kv" href="https://en.wikipedia.org/wiki/Gheorghe_Păun" rel="noopener ugc nofollow" target="_blank">Gheorghe P un</a>——膜计算之父)。</p><h1 id="4736" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">最大并行度</h1><p id="59d9" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">现在你对什么是膜结构，物体如何通过规则的应用而进化有了一个概念。这种计算模式的能力取决于我们如何应用这些规则。所有的规则都被应用，使得它们被最大程度地并行化。</p><p id="8b77" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这种应用模式的灵感来自于活细胞生物化学反应的平行性质。例如，假设该区域包含对象abbc。考虑规则r1: ab-&gt;v1和r2:bc-&gt;v2。如果我们只应用第一个规则一次，那么我们也必须在同一区域应用第二个规则。如果我们应用第一个规则两次，我们不能应用第二个规则。其思想是，如果该区域有足够多的对象，可以再应用一个规则，则应用该规则。</p><h1 id="6ad9" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">理论到此为止</h1><p id="6aa5" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">好了，我们有了一个受活细胞功能启发的计算模型。我们如何应用这个模型来解决现实生活中的问题？尽管膜计算有许多应用，特别是在生物学中，但该模型在计算机科学中最重要的应用是并行算法的设计。基本上，我们观察细胞如何并行处理信息，并使用这些见解来创建新的并行算法。</p><p id="092f" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">让我们来看一个实际的例子:一个求解<a class="ae kv" href="https://www.geeksforgeeks.org/travelling-salesman-problem-set-1/" rel="noopener ugc nofollow" target="_blank"> TSP(旅行商问题)</a>的薄膜算法。解决问题的一个算法是<a class="ae kv" href="https://en.wikipedia.org/wiki/2-opt" rel="noopener ugc nofollow" target="_blank"> 2-opt </a>。这个想法很简单:给定问题的一个可能的解决方案(一次旅行),计算该旅行的所有邻居，并选择最有效的一个。如果我们可以通过交换两条路线从一个解决方案获得另一个解决方案，那么这两个解决方案就是邻居。下图给出了直观的表示:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi mq"><img src="../Images/2a8b6fe0dd6cd20b449b3d86097ef8b4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*SdGlbchGhQnZeMNngqScJw.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">两个邻居旅游</p></figure><p id="a21c" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">求解TSP的膜算法由三个部分组成:</p><ol class=""><li id="9c88" class="mr ms iq ky b kz la lc ld lf mt lj mu ln mv lr mw mx my mz bi translated">许多区域被膜隔开。</li><li id="6cea" class="mr ms iq ky b kz na lc nb lf nc lj nd ln ne lr mw mx my mz bi translated">来自每个区域的对象是TSP实例的潜在解决方案。</li><li id="2f7d" class="mr ms iq ky b kz na lc nb lf nc lj nd ln ne lr mw mx my mz bi translated">重写规则由优化算法表示，如2-opt，它进化当前对象。通信规则由将解决方案从一个区域移动到另一个区域的机制来表示。</li></ol><p id="f2ef" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">该算法本身具有以下步骤:</p><ol class=""><li id="7549" class="mr ms iq ky b kz la lc ld lf mt lj mu ln mv lr mw mx my mz bi translated">所有区域使用优化算法(例如2-opt)同时更新它们的对象(TSP的潜在解)。</li><li id="1320" class="mr ms iq ky b kz na lc nb lf nc lj nd ln ne lr mw mx my mz bi translated">在每个区域中，改善的解决方案被发送到较低的相邻区域，而效率变低的解决方案被发送到较高的相邻区域。</li><li id="fdd7" class="mr ms iq ky b kz na lc nb lf nc lj nd ln ne lr mw mx my mz bi translated">重复更新和传输步骤，直到满足最终条件。</li><li id="8f96" class="mr ms iq ky b kz na lc nb lf nc lj nd ln ne lr mw mx my mz bi translated">算法从最里面的区域输出问题的解。</li></ol><p id="cd2b" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">上述算法代表了一种新的并行算法，用于解决由活细胞的膜结构所启发的TSP问题。很酷，不是吗？</p></div><div class="ab cl nf ng hu nh" role="separator"><span class="ni bw bk nj nk nl"/><span class="ni bw bk nj nk nl"/><span class="ni bw bk nj nk"/></div><div class="ij ik il im in"><h1 id="ab21" class="ls lt iq bd lu lv nm lx ly lz nn mb mc jw no jx me jz np ka mg kc nq kd mi mj bi translated">让我们编码</h1><p id="92f3" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">我们将使用Open MPI用C实现上述膜算法。如果你想在Mac M1上使用CLion的开放式MPI，请查看我的教程。</p><p id="b2c1" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">区域包含TSP问题的一些潜在解决方案作为对象，因此我们可以通过以下结构对区域建模:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nr ns l"/></div></figure><p id="881f" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">对于这个例子，我们从如下文件中读取初始膜结构:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nr ns l"/></div></figure><p id="714d" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在第一行，我们有地区的数量。在第二行，我们有来自每个地区的潜在解决方案的数量。最后，在第三行，我们有每个区域的初始解。</p><p id="3deb" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">为了读取输入文件并初始化膜结构，我们使用函数<code class="fe nt nu nv nw b">initialize_regions_from_file</code>:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nr ns l"/></div></figure><p id="b3dd" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">为了查看每个区域的当前对象(解决方案)，我们使用函数<code class="fe nt nu nv nw b">display_regions</code>:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nr ns l"/></div></figure><p id="5a58" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">为了在区域之间移动解决方案，我们使用函数<code class="fe nt nu nv nw b">move_solution</code>调用函数<code class="fe nt nu nv nw b">add_solution_to_region</code>将解决方案添加到下一个区域，调用函数<code class="fe nt nu nv nw b">remove_solution_from_region</code>从当前区域移除解决方案:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nr ns l"/></div></figure><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nr ns l"/></div></figure><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nr ns l"/></div></figure><p id="1c1f" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">每个解都由2-opt算法更新，该算法由函数two_opt_local_search实现:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nr ns l"/></div></figure><p id="7d1c" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">来自一个区域的解决方案由功能<code class="fe nt nu nv nw b">evolve_region</code>更新:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nr ns l"/></div></figure><p id="1a59" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">使用<a class="ae kv" href="https://www.open-mpi.org" rel="noopener ugc nofollow" target="_blank"> Open MPI </a>我们为每个区域分配一个进程。根据膜算法的规范，所有过程并行工作。根进程通过调用函数<code class="fe nt nu nv nw b">distribute_work_on_regions</code>为其他进程分配一个区域:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nr ns l"/></div></figure><p id="7bc7" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">由于Open MPI不知道如何发送region类型的变量，我们编写了函数<code class="fe nt nu nv nw b">serialize_region</code>，它将一个区域转换成一个字节数组:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nr ns l"/></div></figure><p id="1750" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">类似地，当根进程从另一个进程接收到一个字节数组形式的区域时，我们需要将该数组转换成类型为<code class="fe nt nu nv nw b">region</code> <em class="nx">的变量。</em>我们通过使用函数<code class="fe nt nu nv nw b">deserialize_region</code>来做到这一点:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nr ns l"/></div></figure><p id="09b7" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">更新解决方案后，每个流程都将该区域发送回根流程。这是通过调用函数<code class="fe nt nu nv nw b">receive_work_from_regions</code>来完成的:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nr ns l"/></div></figure><p id="fb71" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">函数<code class="fe nt nu nv nw b">update_region</code>实现了解决方案在相邻区域之间的传输机制；</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nr ns l"/></div></figure><p id="e8a5" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">分发和接收步骤被打包到一个名为<code class="fe nt nu nv nw b">distribution_step</code>的函数中:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nr ns l"/></div></figure><p id="6120" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">每个进程通过调用函数<code class="fe nt nu nv nw b">evolution_step</code>从相应的区域演化出解:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nr ns l"/></div></figure><p id="c4f7" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在主函数中，根进程多次调用函数<code class="fe nt nu nv nw b">distribution_step</code>，而其余进程调用函数<code class="fe nt nu nv nw b">evolution_step</code>:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nr ns l"/></div></figure><p id="a20d" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">下面是简单的<a class="ae kv" href="https://people.sc.fsu.edu/~jburkardt/datasets/tsp/tsp.html" rel="noopener ugc nofollow" target="_blank">五个</a>输入区域的演变:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nr ns l"/></div></figure><p id="dab7" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">最有效的解决方案的成本是19。</p><h1 id="95f9" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">结束语</h1><p id="2b71" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">在这个故事中，我们只是揭开了薄膜计算领域的冰山一角。这是一种新的强大的计算模型，与量子计算不同，它可以激发许多新的并行算法，这些算法可以使用我们当前的计算机来实现。</p><p id="27a7" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">如果你想了解膜计算如何影响计算机科学的其他领域，如机器学习或优化，请查看这篇新论文。完整的源代码可以在<a class="ae kv" href="https://github.com/miiip/MembraneAlgorithmSimulator" rel="noopener ugc nofollow" target="_blank">这里</a>找到。</p><h1 id="903e" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">资源</h1><p id="6244" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">关于计算机科学中薄膜计算应用的<a class="ae kv" href="https://www.researchgate.net/publication/357765052_A_Comprehensive_Survey_on_the_Recent_Variants_and_Applications_of_Membrane-Inspired_Evolutionary_Algorithms/" rel="noopener ugc nofollow" target="_blank">调查</a>:</p><p id="cbb5" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">一篇<a class="ae kv" href="https://sci-hub.se/10.1142/s012905410700539x" rel="noopener ugc nofollow" target="_blank">论文</a>描述了TSP问题的一个更复杂的薄膜算法</p><p id="ba3e" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><a class="ae kv" href="https://www.amazon.com/Oxford-Handbook-Membrane-Computing-Handbooks/dp/0199556679" rel="noopener ugc nofollow" target="_blank">牛津膜计算手册(Oxford Handbooks) </a></p><p id="de8d" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">P系统的<a class="ae kv" href="http://ppage.psystems.eu" rel="noopener ugc nofollow" target="_blank">网站</a>。</p><p id="5509" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><a class="ae kv" href="https://people.sc.fsu.edu/~jburkardt/datasets/tsp/tsp.html" rel="noopener ugc nofollow" target="_blank">旅行销售员问题的TSP数据</a></p></div></div>    
</body>
</html>