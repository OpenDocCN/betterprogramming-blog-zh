<html>
<head>
<title>How to Use Code-Splitting With React and Parcel</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何在React和Parcel中使用代码分割</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/how-to-use-code-splitting-with-react-and-parcel-e8bb37be4160?source=collection_archive---------10-----------------------#2020-04-29">https://betterprogramming.pub/how-to-use-code-splitting-with-react-and-parcel-e8bb37be4160?source=collection_archive---------10-----------------------#2020-04-29</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="7620" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">什么是代码分割，我们为什么要使用它？</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/38cd678985514e4da786d18adec128b7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*0an5UykguoMiuBc139urtw.jpeg"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">照片由<a class="ae kv" href="https://unsplash.com/@amoonra?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> amoon ra </a>在<a class="ae kv" href="https://unsplash.com/s/photos/half?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</p></figure><p id="e2ab" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">代码分割是将捆绑提升到下一个级别的过程。当您有一个小项目时，捆绑是很好的，但是随着项目的增长，您的捆绑也会增长。最终，您的包会变得非常大，以至于您的包加载速度很慢，这就违背了捆绑的全部目的。通过代码分割，仅当用户需要时才创建和加载多个包，这意味着我们可以通过不加载我们不需要的资源来大大减少加载时间。</p></div><div class="ab cl ls lt hu lu" role="separator"><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx"/></div><div class="ij ik il im in"><h1 id="0a84" class="lz ma iq bd mb mc md me mf mg mh mi mj jw mk jx ml jz mm ka mn kc mo kd mp mq bi translated">在活动</h1><h2 id="2478" class="mr ma iq bd mb ms mt dn mf mu mv dp mj lf mw mx ml lj my mz mn ln na nb mp nc bi translated">没有代码分割</h2><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi nd"><img src="../Images/83cc61eeadc834a348a43eca2483322f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1224/format:webp/1*tjKbdTIkwDejk454RFPTMA.png"/></div></figure><p id="af4c" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在上面的例子中，我们加载了一个2.88MB的资源，在下面的例子中，我们加载了两个资源，一个2.83MB的初始父包。然后当用户访问另一个页面时，他们请求一个63KB的子包。虽然这看起来不多；这些数字来自一个非常小的应用程序，由一些图片组成，我创建它是为了演示本文的捆绑。您可以想象，通过使用代码分割，您实际上可以减少一个更大项目的初始包大小，从而减少初始加载时间。</p><h2 id="6b07" class="mr ma iq bd mb ms mt dn mf mu mv dp mj lf mw mx ml lj my mz mn ln na nb mp nc bi translated">使用代码分割</h2><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi ne"><img src="../Images/644534150a3784de5e8fe886774361af.png" data-original-src="https://miro.medium.com/v2/resize:fit:1238/format:webp/1*HApSJLBm0ohsAc5sJlKUng.png"/></div></figure></div><div class="ab cl ls lt hu lu" role="separator"><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx"/></div><div class="ij ik il im in"><h1 id="78bc" class="lz ma iq bd mb mc md me mf mg mh mi mj jw mk jx ml jz mm ka mn kc mo kd mp mq bi translated">如何对包裹使用代码分割</h1><p id="4bd3" class="pw-post-body-paragraph kw kx iq ky b kz nf jr lb lc ng ju le lf nh lh li lj ni ll lm ln nj lp lq lr ij bi translated"><a class="ae kv" href="https://parceljs.org/" rel="noopener ugc nofollow" target="_blank">包裹</a>一如既往的坚持其炒作背后的大特色，零配置。这意味着我们不必创建一个配置文件来实际使用这个特性。Parcel只知道如何处理它那端的一切，所以我们所要做的就是使用动态的<code class="fe nk nl nm nn b">import()</code>函数语法。</p><p id="d215" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">对于没有呈现组件的代码，简单的方法是使用动态导入，如下所示。</p><p id="376a" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">定义逻辑:</p><pre class="kg kh ki kj gt no nn np nq aw nr bi"><span id="8676" class="mr ma iq nn b gy ns nt l nu nv">//math.js</span><span id="45f2" class="mr ma iq nn b gy nw nt l nu nv">export default function add(a, b) {</span><span id="7777" class="mr ma iq nn b gy nw nt l nu nv">return a + b;</span><span id="b342" class="mr ma iq nn b gy nw nt l nu nv">}</span></pre><p id="489a" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在其他地方使用逻辑:</p><pre class="kg kh ki kj gt no nn np nq aw nr bi"><span id="1b97" class="mr ma iq nn b gy ns nt l nu nv">//frontpage.js</span><span id="daaa" class="mr ma iq nn b gy nw nt l nu nv">import("./math").then(math =&gt; {<br/>  console.log(math.add(1, 2));<br/>});</span></pre><p id="b006" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">但是如果我们有一个组件要呈现，我们需要首先定义我们的子组件:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nx ny l"/></div></figure><p id="a2c0" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">然后，为了在我们应用程序的其他地方使用这个组件，我们需要通过这样做在一个<code class="fe nk nl nm nn b">suspense</code>组件中使用<code class="fe nk nl nm nn b">React.lazy</code>:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nx ny l"/></div></figure><p id="b461" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们需要这样做，因为<code class="fe nk nl nm nn b">React.lazy</code>允许我们将动态导入作为常规组件呈现，而<code class="fe nk nl nm nn b">suspense</code>组件允许在加载组件时呈现回退。</p></div><div class="ab cl ls lt hu lu" role="separator"><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx"/></div><div class="ij ik il im in"><h1 id="1487" class="lz ma iq bd mb mc md me mf mg mh mi mj jw mk jx ml jz mm ka mn kc mo kd mp mq bi translated">使用路由进行代码拆分</h1><p id="67de" class="pw-post-body-paragraph kw kx iq ky b kz nf jr lb lc ng ju le lf nh lh li lj ni ll lm ln nj lp lq lr ij bi translated">在SPA中，你很可能不需要代码分割，但是在一个有多个页面的应用中，我们可能会遇到前面提到的包减速。基于路由的代码分割是有用的，因为加载代码束需要时间，并且用户在切换页面时会期望一些时间来加载。此外，我们不会期望用户在重新呈现整个页面时使用元素，所以他们在与元素交互时不会注意到速度变慢。</p><p id="2cf8" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">为了根据路线进行代码分割，我们将路线包装在一个<code class="fe nk nl nm nn b">suspense</code>组件中，如下所示:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nx ny l"/></div></figure></div><div class="ab cl ls lt hu lu" role="separator"><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx"/></div><div class="ij ik il im in"><h1 id="a64e" class="lz ma iq bd mb mc md me mf mg mh mi mj jw mk jx ml jz mm ka mn kc mo kd mp mq bi translated">React的缺点。懒惰和悬念</h1><p id="0850" class="pw-post-body-paragraph kw kx iq ky b kz nf jr lb lc ng ju le lf nh lh li lj ni ll lm ln nj lp lq lr ij bi translated">使用<code class="fe nk nl nm nn b">React.lazy</code>进行代码分割的一个缺点是它目前只支持默认导出。如果您想要导入命名导出，您需要创建一个中间模块，将它作为缺省值重新导出。另外，<code class="fe nk nl nm nn b">React.lazy</code>和<code class="fe nk nl nm nn b">suspense</code>不支持服务器端渲染。要在服务器端渲染的同时对React应用进行代码拆分，目前推荐使用<code class="fe nk nl nm nn b"><a class="ae kv" href="https://loadable-components.com/docs/getting-started/" rel="noopener ugc nofollow" target="_blank">@loadable/component</a></code>。</p></div><div class="ab cl ls lt hu lu" role="separator"><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx"/></div><div class="ij ik il im in"><h1 id="a745" class="lz ma iq bd mb mc md me mf mg mh mi mj jw mk jx ml jz mm ka mn kc mo kd mp mq bi translated">结论</h1><p id="64e4" class="pw-post-body-paragraph kw kx iq ky b kz nf jr lb lc ng ju le lf nh lh li lj ni ll lm ln nj lp lq lr ij bi translated">在我看来，代码分割是另一个很棒的工具，是简单捆绑的逻辑升级。希望这篇文章对你有所帮助。</p><p id="f0d6" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">如果您有任何问题、建议或其他任何事情，请随时发表评论！</p></div></div>    
</body>
</html>