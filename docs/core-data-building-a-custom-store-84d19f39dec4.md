# 核心数据—构建定制商店

> 原文：<https://betterprogramming.pub/core-data-building-a-custom-store-84d19f39dec4>

## 通过增量和原子存储深入了解核心数据

![](img/7de3f77a9d86f10092c713e0e76da6c2.png)

资料来源:undraw.co

我认为这篇教程可能是我写过的最吸引人的教程之一。

它的主要目标是揭示核心数据如何在幕后工作，而不是解决您的问题。

一个很好的方法是编写自己的自定义存储。

# 定制商店——它到底是什么意思？

好了，让我们快速回顾一下核心数据堆栈的样子。

我们有三个主要组件——**数据模型、数据存储和上下文**。

深入到“存储”组件，我们知道我们有四种类型的存储— **原子** (XML、二进制和内存中)和一种**增量** (SQLite)。

现在，是时候透露我们可以选择**通过子类化 NSIncremenetalStore 或 NSAtomicStore 来创建自定义商店**。

这两个类允许您编写自己的存储类型，并基本上控制核心数据如何保存、获取和优化本地数据。

例如，你可以编写一个可以用 CSV 文件代替 SQLite 的**商店，或者甚至是一个**与 web 服务**独立同步的商店。事实上，一旦你掌握了控制权，几乎一切皆有可能。**

# 我们为什么需要它？

大多数情况下，你不会。核心数据附带的四种商店类型适合您的大部分需求。

但是有几个原因让您需要知道如何创建自己的数据存储。

需要理解的一点是，使用自己的定制数据存储并不意味着对栈的其余部分进行额外的修改。数据模型和上下文不知道它们正在使用自定义数据存储，而代码库的其余部分保持不变。

意味着你的店很容易更换，所以不用担心！

# 依靠你的技术

SQLite 是一种非常有效的数据存储方式，它被选为许多移动应用程序的首选数据库绝非偶然。

但这并不意味着这是在移动设备上管理数据的唯一方式。

例如，在 iOS 上实现 NoSQL 数据存储有很好的解决方案，编写自定义存储是**将您的核心数据连接到不同类型存储的一种方式**。

# 跨平台支持

如果您在同一个团队中与 Android 开发人员一起工作，就会出现要求两个平台使用相同数据文件格式的情况。

在许多情况下，让所有平台都使用相同的格式和技术对于团队的成功至关重要。

幸运的是，通过使用自定义存储类型，我们可以在相同的格式上工作，并且仍然可以使用优秀的核心数据特性。

# 从旧的持久性存储迁移

如果您正在开发一个尚未实现核心数据的现有应用程序，但该应用程序已经有一个数据存储，那么创建一个自定义存储可能是一个很好的起点。

从旧的持久层迁移总是很麻烦，所以这种方法可以减轻迁移的痛苦。

# 将持久性存储直接连接到 Web 服务

因为我们已经完全控制了商店的行为，所以一个很好的想法是**将它直接绑定到你的后端服务**。

这似乎是一个奇怪的想法，尤其是当你想到“关注点分离”原则的时候。

但是有一些方法可以将你的商店直接连接到一个 web 服务，而不会使它过于耦合，比如依赖注入。

这是一个令人兴奋的方法，我们可以稍后再探讨。

# 浏览另一个堆栈组件

学习如何创建自定义存储可以揭示一些核心数据秘密，即它是如何工作的。

这基本上意味着你要对获取、保存和出错负责。

这是一个从不同角度对核心数据进行概述的过程，只会让你成为更好的 iOS 开发人员。

也许，这是尝试和学习它的最好理由。

# NSIncrementalStore vs . NSAtomicStore

如上所述，核心数据存储分为两种类型— **原子**和**增量**。

如何选择创建哪种类型的商店？

这取决于你的需求——每种商店类型都有其缺点和优点。

原子存储更青睐简单性而非性能。在原子存储中，我们将所有数据加载到内存中，每次需要执行更改(插入/更新/删除)时，我们都必须保存所有数据。

因此，这是一个易于管理的存储，但也消耗了最大的内存。

当我们需要将数据基于 JSON、XML 或 CSV 文件时，原子存储是相关的。

另外，请注意，这些文件不能太大——在这种情况下，请考虑使用增量存储。

与原子存储相比，增量存储实现起来更复杂。它们要求我们自己处理所有的错误和优化，是为那些喜欢性能胜过简单的人准备的。

增量存储用于大数据文件或其他特殊的异步数据获取，如 HTTP 请求。

这两种存储类型都允许我们创建基本上任何我们想要的持久性存储。我们只需要了解它们是如何工作的。

# 它们是如何工作的？

在我们继续之前，我想解释一下存储在核心数据中的基本工作方式，它甚至比您想象的还要简单。

首先，我们来谈谈核心数据的责任和你的责任。

核心数据负责:

*   初始化我们的商店。
*   处理获取，包括谓词。
*   为我们管理不同的环境。

另一方面，您需要:

*   基于您的数据创建对象。
*   生成对象 id。
*   定义商店元数据信息。
*   应要求提供额外的数据信息。

换句话说，作为开发人员，我们需要做的是处理核心数据框架和我们的后台存储之间的连接，无论它是什么。

在我们开始设置原子存储之前，让我们看看它的超类— NSPersistentStore。

# NSPersistentStore

`NSPersistentStore`是所有核心数据持久性存储的基类。`NSPersistentStore`也是`NSIncrementalStore`和`NSAtomicStore`的超类，如果我们想创建自己的商店，我们需要子类化其中一个类。

为了创建一个新的原子商店，我们将创建一个名为`MyAtomicStore`的子类:

```
class MyAtomicStore: NSAtomicStore
```

正如我前面说过的，我们自己不初始化存储——那是核心数据框架的工作。

我们的工作是注册它们，并告诉 Core Data 我们希望它加载什么类型的存储。

每个存储都有包含类型和 UUID 的元数据。

元数据信息帮助核心数据初始化新的存储，管理它的迁移，在扩展之间共享它，并且一般来说，随着时间的推移照顾我们的存储。

让我们将以下内容添加到我们的`MyAtomicStore`类中:

我们从基于这些值声明一个类型和一个 UUID 开始，我们还创建了一个 storeType 和一个商店描述。当我们设置核心数据容器时，这两者都将被使用。

请注意，被覆盖的方法和变量对于创建自定义存储来说是必需的——不要担心，我们有很多方法可以被覆盖以使存储工作，这是一个好的开始。

现在我们有了元数据，我们可以将我们的存储注册到核心数据。

# 注册新商店

为了确保核心数据加载我们的存储，我们需要执行两个步骤:注册，然后加载它。

为了注册我们创建的商店，我们将在`applicationDidFinishLaunchingWithOptions`中添加下面一行:

```
NSPersistentStoreCoordinator.registerStoreClass(MyAtomicStore.self, type: MyAtomicStore.storeType)
```

我们的下一步是在加载核心数据容器**之前，将我们之前创建的商店描述添加到其中:**

如果一切顺利，我们的集装箱将毫无问题地装船。

# NSAtomicStore

现在我们的商店已经加载完毕，让我们深入到商店本身。

原子存储不同于增量存储，因为它们将所有数据保存在内存中。

这使得它们简单而快速，但在内存方面效率不高，尤其是在处理大型商店时。

毫无疑问，主要任务是将所有数据加载到内存中。

# 映射数据

因此，我们要做的第一件事是创建一个字典，将所有实例映射到一个唯一的值，例如 UUID:

```
var objectMapping = [UUID : NSManagedObjectID]()
```

注意，我们没有映射对象本身，而是映射它们的对象 id。你记得为什么吗？

原因是受管对象不是存储持有或创建的东西，而是受管对象上下文作业的一部分。

这就是为什么学习如何创建自己的数据存储会如此丰富——你最终会知道事情是如何在幕后工作的，而我们才刚刚开始。

# 加载所有数据

正如我前面说过的(甚至可能说过几次)，原子存储从一开始就保存所有的数据。

因此，加载存储时调用的方法之一是`load()`。

```
override func load() throws {
```

`load()`方法是`NSAtomicStore`类的一部分，当你创建自己的原子存储时**必须覆盖**。

如果我们的存储使用某种 CSV 文件，那就是我们转到该文件并加载其所有记录的时候了。

让我们来看一下将所有东西连接起来需要采取的步骤:

-将 CSV(或任何其他持久性文件或数据)文件加载到内存中。

-循环它的所有行。

-对于每一行:

*   生成一个新的`referenceID`。
*   基于`referenceID`生成新的`ObjectID`。
*   创建一个新的缓存节点(这是我们的“对象”)。
*   用数据填充缓存节点。
*   将`objectID`映射到它的`referenceID`。
*   将缓存节点添加到存储中。

看起来工作量很大，是吧？嗯，考虑到这是你创建自己的商店时要做的大部分工作，这没什么大不了的。

下面是一个基本的功能性`load()`方法:

请一行一行地按照我之前列出的步骤去理解正在发生的事情。

# 更多见解

别担心，我不会把你留在黑暗中，用我刚才给你看的代码。

有几件事你应该知道:

对于 CSV 中的每一行，我们的目标是创建一个名为**的缓存节点**。一个缓存节点代表我们存储中的一个**记录**，一旦我们从本地文件加载数据，它就是我们保存数据的地方。

当我们向存储中插入一条新记录时，我们基本上是在插入一个新的缓存节点。

为了创建一个缓存节点，我们需要提供一个`objectID`。到目前为止，我们只读取了`objectID`值，但从未生成过。

现在，我们将使用一个内置方法生成一个`objectID`:

```
let objectID = self.objectID(for: songDesc, withReferenceObject: uuid)
```

创建缓存节点后，我们可以使用常规的`setValue()` 函数设置它的值。

```
cacheNode.setValue(name, forKey: “name”)
```

这是我们用来自 CSV 的信息填充商店的地方。一个好的技巧是从实体描述中获取关键属性的名称，而不是硬编码。

这可能看起来像一个过度工程化的任务，但从长远来看是值得的。

# 关系呢？

核心数据不仅仅是一个持久存储，还是一个对象图。这意味着我们的新商店需要**管理不同对象之间的关系。**

请记住，我们的“对象”实际上是我们刚刚创建的缓存节点。要实现关系，我们需要做的就是将一个缓存节点连接到另一个:

```
let albumCacheNode = NSAtomicStoreCacheNode(objectID: albumObjectID)// filling the albume node with datasongNode.setValue(albumCacheNode, forKey: “album”)
```

不要忘记相册节点只是一个标准的缓存节点—我们需要生成一个`objectID`(基于实体描述)，映射它，并将其插入到存储中，就像我们对歌曲节点所做的那样。

# 添加新对象

我们的存储可能需要支持添加新对象。

在我们知道如何从 CSV 文件中加载所有数据并将其转换为节点后，添加新信息应该很容易，但这需要我们执行额外的工作。

当核心数据插入和操作对象时，我们的存储不做任何事情—记住，上下文是应用程序沙箱。我们的商店只有在上下文`save()`方法被调用时才进入画面。

在这种情况下，我们需要做三件事:生成新的引用 ID，创建新的缓存节点，并将数据保存到 CSV 文件中。

# 生成新的参考 ID

看来我们已经去过了，不是吗？

我告诉过你从现在开始事情会越来越熟悉。

当核心数据上下文(现在是您的客户机)要求插入一个新对象时，我们需要做的第一件事是**返回一个引用对象**。

引用对象必须是唯一的，并且应该从对象值派生。

如果没有，我们需要继续映射它。

要返回一个新的引用对象，实现`newReferenceObject`方法:

# 添加新的缓存节点

添加新的缓存节点类似于我们之前从文件加载数据时所做的，但是方向相反——从上下文到存储。

为此，我们需要实现以下内容:

现在，尽管实现看起来很明显，但是有一个小问题:关系。

如果我们插入一个具有关系的新对象，我们需要确保当我们创建一个新的缓存节点时，**我们负责所有的连接和链接**。

可以帮助我们的事情之一是我们在引用对象和 objectIDs 之间做的映射。

一旦我们有了一个`objectID`，我们需要做的就是检索它的缓存节点(如果存在于我们的内存中)并执行相关的连接:

```
if let albumNode = self.cacheNode(for: albumObjectID) {cacheNode.setValue(albumNode, forKey: “album”)} else {// create a new album cache node from data.}
```

`NSAtomicStore`有一个叫`cacheNode(for objectID: NSManagedObjectID)`的函数可以帮助我们在`objectID`之前获得一个缓存节点，我们需要用它来连接我们需要的一切。

# 节约

最后一步是用所有新的更改更新我们的本地文件。

核心数据调用 store save 方法，我们应该在我们的子类中实现它:

```
override func save() throws {}
```

但是怎样做才是正确的方法呢？

有几种方法可以实现这一点，这取决于您选择如何跟踪您的数据。

一种方法是采用暴力手段。我们有一个包含所有`objectIDs`的映射，因此我们可以为它们生成缓存节点，并从缓存节点创建可以保存为 CSV 文件的数据。

这可能是将数据保存回文件的最可靠、最简单的方法，但不是最优雅的方法。

另一种方法是保留我们加载 CSV 文件时创建的数据，并在每次更新或插入新的缓存节点时用更改来更新它。

一旦我们需要将数据保存回文件，我们已经用所有的更改更新了它。

请记住，您不需要担心处理多个上下文——这是核心的数据容器工作。只有当应用程序请求在本地保存数据时，才会保存到存储区并插入新的缓存节点。

# 更新和删除

就像添加一个新的缓存节点一样，更新和删除需要实现额外的方法。

为了更新节点，我们需要实现以下内容:

请注意，`NSAtomicStore`让您的生活变得更加轻松——它已经为您提供了节点和托管对象。

现在是重用来自`newCacheNode`函数的代码并将其合并到一个地方的好时机。

移除缓存节点的过程类似——就在缓存节点从存储中移除之前，核心数据调用`willRemoveCacheNodes`方法。

这就是我们需要删除相应数据和关系的地方。

# NSIncrementalStore

与`NSAtomicStore`不同的是，`NSIncrementalStore`旨在解决其他无法将数据保存在内存中，只需要在需要时加载数据的情况。

这种情况主要有两种情况:当数据存储太大而无法保存在内存中时，第二种情况是数据没有保存在设备上，您只能在请求时获取数据，就像 web 服务一样。

但首先，让我们谈谈我们如何建立一个自己的`NSIncrementalStore`。

我认为最重要的是要明白这样一个事实，我们有更多的控制权，因此也有更多的责任。

实现`NSAtomicStore`很简单。我们所要做的就是获取所有记录，将它们连接到一个引用 ID，并填充缓存节点。

在`NSIncrementalStore`中，我们有两项主要工作:

-我们需要自己处理所有的存储操作，例如获取、保存和删除。

-我们需要控制断层。记住，它是增量的，我们只加载我们需要的。

我们开始工作吧。

# 正在加载商店

增量存储通常使用本地文件(在许多情况下，它是一个 SQLite 文件)，并需要确保文件位于正确的位置(如果不在，就创建它)。

这也是做另外两件事的地方:

- **检查**文件是否被**损坏**并抛出错误。

- **从商店加载基础数据**(可选)。

下面我们来详细阐述一下“加载基础数据”是什么意思。

事实上，增量存储不像原子存储——我们不会将所有数据都加载到内存中。

但这并不意味着我们完全不能加载任何数据。

例如，如果我们有大量的歌曲，我们可以将它们的 id 加载到内存中，这样在需要的时候我们就可以更容易地获取额外的数据。

获取像“headers”这样的东西可以简化我们的实现，另外，这也是确保我们的文件没有损坏并且格式正确的好方法。

# 执行存储请求

为了让我们的增量存储正常工作，我们需要处理的第一件事是来自我们上下文的存储请求——记住，既然我们是一个存储，那么上下文就是我们的“客户机”。

在增量商店中，我们需要实现以下方法:

```
override func execute(_ request: NSPersistentStoreRequest, with context: NSManagedObjectContext?) throws -> Any
```

`execute()`函数有两个参数:存储请求本身(我们稍后会谈到)和相关的上下文。

这个函数处理获取请求、保存，甚至批处理操作。

# NSPersistentStoreRequest

`execute()`方法签名中的`NSPersistentStoreRequest`实例封装了执行上下文要求我们做的所有必要信息。

首先，我们需要了解我们有什么类型的请求。因此，我们需要检查实例的`requestType`属性:

## 迷人的

当`requestType`属性等于`fetchRequestType`时，我们知道上下文试图执行**一个获取请求**。

在这种情况下，我们可以将它转换为 fetch 请求，并检查请求的是什么实体:

现在我们有了实体名称，我们可以基于获取请求创建我们的歌曲:

先说上面的代码:

首先，我们有一个特殊的函数叫做`getSongsIds(byRequest:)`。我们需要编写这个函数，它需要根据收到的获取请求从我们的后备存储中检索歌曲 id。

获取请求包含我们需要的所有信息，包括一个谓词和排序描述符。

这是您需要做的最复杂的工作——如何使用谓词和排序描述符来执行对 CSV 或 SQLite 文件的请求？

这里我的建议是，您不需要涵盖谓词和排序的所有可能的用例。

当您构建应用程序并添加越来越多的获取请求时，请根据您的需求分析获取请求，并在过程中添加相关代码。不要试图完全复制基于 SQLite 的增量——这不是构建增量存储的目标。

一旦我们有了所有的歌曲 id，我们就可以执行一个 for 循环，并为每个 id 创建一个托管对象。

注意，我们不只是在每次循环迭代中初始化一个新的托管对象——我们首先从实体描述和`songID`中生成一个`objectID`。只有这样，我们才能从上下文中检索一个托管对象。

如果上下文已经有一个带有这个`ObjectID`的托管对象，它将返回现有的对象。

`songID`是我们对象的参考对象和唯一标识符。将它附加到`objectID`上是我们从后台存储中注册记录的存储方式。

你可能已经注意到的另一件事是，我们根本不用数据填充我们的歌曲——那是因为我们只初始化出错的对象。还记得核心数据特性吗？

故障使我们能够优化我们的请求，并且只在请求时加载额外的数据。我们很快会谈到断层！

## 节约

回到`execute()`函数的开头——正如我提到的，这个函数不仅处理获取，还处理保存。

但是什么是“保存”存储请求呢？

“保存”意味着插入、更新和删除对象。

为了处理保存请求，我们首先需要检查请求类型，并将其与`saveRequestType`进行比较。

下一步是将获取请求转换为`NSSaveChangesRequest`。

是的，`execute()`函数在这里使用了多态性——它有时可以是一个获取请求，有时是一个保存请求。

像 fetch 请求一样，save 请求也**封装了所有需要的信息**来将新数据保存到您的存储中。

`NSSaveChangesRequet`有三个属性:

- `insertedObjects`

- `updatedObjects`

- `deletedObjects`

它们中的每一个都是包含被请求保存的对象列表的数组。

这些是什么东西？嗯，在这种情况下，对象实际上是`NSManagedObject`。如果您将它们转换为`Song`(例如)，您将能够检索所有需要的信息并将其保存在您的后备存储器中。

让我们来看看实际的保存请求:

`**ObjectID**`

现在，花一点时间，阅读上面的代码，并思考是否缺少了什么。

提示—看看我们之前编写的代码，当时我们从后备存储中加载了所有数据，并将其注册到增量存储中。

你到了吗？

我们需要将 objectID 映射到它的引用值(在本例中为`songID`)。记得吗？

在`execute()`函数中没有发生的原因是，正如您可能知道的，添加到核心数据的新对象有一个临时的`objectID`。只有在保存操作完成后，它们才能获得永久的`objectID`。

这也是核心数据要求您使用函数`obtainPermanentIDs()`获得一个永久 objectID 的时候:

`obtainPermanentIDs`函数传递新对象的列表，并要求返回相应对象 id 的列表。

我想您现在应该已经熟悉这个实现了。

`obtainPermanentIDs`是了解 NSIncrementalStore 揭示核心数据如何在幕后工作的另一个极好的例子。突然间，许多事情变得更加明显。

但是——这个谜题还缺少一块，那就是**断层**。

# 故障

还记得我们获取对象但没有获取它们的数据时，我告诉过你我们很快会谈到出错吗？这些物体就像“幽灵”，空无一物。

当“用户”(用户实际上是应用程序本身)调用`song.name`时，如果需要，我们需要去获取名称。

幸运的是，NSIncrementalStore 很好地帮助我们管理了那个区域。

我们只需要再实现一个功能，那就是`newValuesForObject`。

当商店需要用来自商店的信息实现一个对象时，调用这个函数。

就像原子存储一样，我们不自己填充托管对象——我们在这里使用一个节点。`NSIncrementalStoreNode`准确地说:

代码很简单，除了一点——版本(我用粗体标出)。

当我们创建`NSIncrementalStoreNode`时，我们需要提供一个版本，该版本应该在每次创建节点时递增。

“版本”有助于合并冲突，并且应该被持久地保存——一行的特定版本。在上面的例子中，我从磁盘中读取了版本，并将其保存回来——以备将来读取。

`NSIncrementalStore`为我们跟踪有故障的对象——这基本上是需要完成的艰苦工作。

关系呢？

对于关系，我们需要覆盖一个额外的方法:

```
func newValue(forRelationship relationship: NSRelationshipDescription, forObjectWith objectID: NSManagedObjectID, with context: NSManagedObjectContext?) throws -> Any
```

尽管看起来很可怕，但关系断层是肤浅的。我们需要做的就是分析什么是目的实体，并返回它的`NSManagedObjectID`(或者在多对多关系的情况下返回 id)。

看看下面的实现:

在上面的例子中，我处理了两个关系——一个是 Album(一对一),一个是 Composer(一对多)。

如果你问自己对象数据在哪里，你现在应该知道答案了。如果核心数据需要，它会通过调用`newValuesForObject()`函数来询问数据。你的工作只是执行它。

# 网络服务

这是我之前提到过的一个部分，你可能仍然会觉得很奇怪。因为增量存储是增量的，所以实现这种存储的一个可能的用例是将存储直接连接到您的后端 API。

想一想——我们有一个完美的对象图框架，带有谓词、排序和缓存机制。

无论如何，你都在你的应用程序中使用这种机制。为什么您“关心”数据是从本地还是远程存储接收的？

这是核心数据魅力的一部分。正如我不止一次说过的——核心数据**不是 SQLite 包装器**。远不止这些。

这是您管理实体的地方，将它直接绑定到您的服务器可能是一个很好的方法。

将我们的商店连接到服务器的主要问题是，调用 HTTP 请求是一个**耗时的操作**，可能需要几秒钟才能返回。

您的存储中的所有步骤必须同步—核心数据存储不支持异步操作。

考虑到我们已经知道的所有核心数据后台操作约束，从应用程序执行核心数据请求应该得出结论，并在后台线程中执行。

# 摘要

在深入研究核心数据时，实现增量存储和原子存储是需要学习的有趣主题之一。

不是因为你能用它做什么，而是你能从中学到什么。

这是一个转换你在 iOS 开发中的位置，并作为一个框架制作者思考一秒钟的绝佳机会。

我们已经了解了如何创建原子和增量存储，以及它们如何通过将我们的存储直接连接到我们的后端来为我们服务。