<html>
<head>
<title>When to Use Bind(), Call(), and Apply() in JavaScript</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">JavaScript中何时使用Bind()、Call()和Apply()</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/when-to-use-bind-call-and-apply-in-javascript-1ae9d7fa66d5?source=collection_archive---------0-----------------------#2021-07-28">https://betterprogramming.pub/when-to-use-bind-call-and-apply-in-javascript-1ae9d7fa66d5?source=collection_archive---------0-----------------------#2021-07-28</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="5a25" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">了解如何用JavaScript创建对象绑定函数</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/4abaad28777816a0f46a6535bc85870a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*3VBH7PIj-vv_BtT6R3Yq1A.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">马库斯·斯皮斯克的原始照片。作者编辑</p></figure><p id="4dc2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">传统上，在JavaScript中，对象可以有自己的属性和方法。例如，<code class="fe lv lw lx ly b">object1</code>不能使用<code class="fe lv lw lx ly b">object2</code>的方法，反之亦然。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi lz"><img src="../Images/79df7f2d164e04ac6657f055200672fa.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*zzWnYHzsYkKa2h8V_8-mWA.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">作者图片</p></figure><p id="cd3d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">但是有一种方法可以克服这个限制。</p><p id="e067" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">您可以使用<code class="fe lv lw lx ly b">call()</code>、<code class="fe lv lw lx ly b">apply()</code>和<code class="fe lv lw lx ly b">bind()</code>方法将一个函数绑定到一个对象中，并调用该函数，就好像它属于那个对象一样。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ma"><img src="../Images/2510550632f7acf353fe56d7d4da050d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*qFsEAXkDUe0mi1yQ6v-4Dg.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">作者图片</p></figure><p id="e85c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们逐一查看这三种方法，并查看一些用例。</p><h1 id="0aab" class="mb mc it bd md me mf mg mh mi mj mk ml jz mm ka mn kc mo kd mp kf mq kg mr ms bi translated">JavaScript中的Call()方法</h1><p id="b847" class="pw-post-body-paragraph kz la it lb b lc mt ju le lf mu jx lh li mv lk ll lm mw lo lp lq mx ls lt lu im bi translated"><code class="fe lv lw lx ly b">call()</code>方法调用具有指定上下文的函数。换句话说，您可以将一个函数绑定到一个对象中，就好像它属于该对象一样。</p><h2 id="9a6f" class="my mc it bd md mz na dn mh nb nc dp ml li nd ne mn lm nf ng mp lq nh ni mr nj bi translated">例子</h2><p id="10ef" class="pw-post-body-paragraph kz la it lb b lc mt ju le lf mu jx lh li mv lk ll lm mw lo lp lq mx ls lt lu im bi translated">让我们创建一个对象<code class="fe lv lw lx ly b">obj</code>和一个函数<code class="fe lv lw lx ly b">add()</code>，用于将一个数与另一个数相加:</p><pre class="kj kk kl km gt nk ly nl nm aw nn bi"><span id="b849" class="my mc it ly b gy no np l nq nr">var obj = { num: 2 };</span><span id="e788" class="my mc it ly b gy ns np l nq nr">function add(a){<br/>  return this.num + a;<br/>}</span></pre><p id="afd4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在，<code class="fe lv lw lx ly b">add()</code>有问题了。它试图返回<code class="fe lv lw lx ly b">this.num</code> +某个值。但是函数内部没有属性<code class="fe lv lw lx ly b">num</code>。因此调用<code class="fe lv lw lx ly b">this.num</code>失败。</p><p id="7072" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">但是正如你所看到的，对象<code class="fe lv lw lx ly b">obj</code>有一个属性<code class="fe lv lw lx ly b">num</code>。如果您可以调用该对象上的函数<code class="fe lv lw lx ly b">add()</code>,就好像它属于该对象一样，会怎么样？</p><p id="f596" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这确实是可能的。为此，使用<code class="fe lv lw lx ly b">call()</code>方法将函数<code class="fe lv lw lx ly b">add()</code>暂时绑定到对象<code class="fe lv lw lx ly b">obj</code>:</p><pre class="kj kk kl km gt nk ly nl nm aw nn bi"><span id="27b9" class="my mc it ly b gy no np l nq nr">add.call(obj, 3);</span></pre><ul class=""><li id="b97a" class="nt nu it lb b lc ld lf lg li nv lm nw lq nx lu ny nz oa ob bi translated">现在函数<code class="fe lv lw lx ly b">add()</code>从它被绑定到的<code class="fe lv lw lx ly b">obj</code>中获取它的<code class="fe lv lw lx ly b"><strong class="lb iu">this</strong></code>。</li><li id="e92d" class="nt nu it lb b lc oc lf od li oe lm of lq og lu ny nz oa ob bi translated">当<code class="fe lv lw lx ly b">add()</code>功能被调用时<code class="fe lv lw lx ly b">this.num</code>是指<code class="fe lv lw lx ly b">obj</code>的<code class="fe lv lw lx ly b">num</code>。</li><li id="15ff" class="nt nu it lb b lc oc lf od li oe lm of lq og lu ny nz oa ob bi translated">因此调用返回<code class="fe lv lw lx ly b">5</code>，因为<code class="fe lv lw lx ly b">2 + 3 = 5</code>。</li></ul><h2 id="6440" class="my mc it bd md mz na dn mh nb nc dp ml li nd ne mn lm nf ng mp lq nh ni mr nj bi translated">使用带有多个参数的Call()</h2><p id="562d" class="pw-post-body-paragraph kz la it lb b lc mt ju le lf mu jx lh li mv lk ll lm mw lo lp lq mx ls lt lu im bi translated">您也可以将<code class="fe lv lw lx ly b">call()</code>用于接受多个参数的函数。</p><p id="7c7d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">例如:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oh oi l"/></div></figure><p id="bd12" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">输出:</p><pre class="kj kk kl km gt nk ly nl nm aw nn bi"><span id="7576" class="my mc it ly b gy no np l nq nr">10</span></pre></div><div class="ab cl oj ok hx ol" role="separator"><span class="om bw bk on oo op"/><span class="om bw bk on oo op"/><span class="om bw bk on oo"/></div><div class="im in io ip iq"><h1 id="e8e4" class="mb mc it bd md me oq mg mh mi or mk ml jz os ka mn kc ot kd mp kf ou kg mr ms bi translated">JavaScript中的Apply()方法</h1><p id="51d5" class="pw-post-body-paragraph kz la it lb b lc mt ju le lf mu jx lh li mv lk ll lm mw lo lp lq mx ls lt lu im bi translated"><code class="fe lv lw lx ly b">apply()</code>方法的作用与<code class="fe lv lw lx ly b">call()</code>完全相同。不同之处在于，<code class="fe lv lw lx ly b">call()</code>接受一个参数列表，而<code class="fe lv lw lx ly b">apply()</code>接受一个参数的<strong class="lb iu">数组</strong>。</p><p id="223e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">例如:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oh oi l"/></div></figure><p id="c628" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">输出:</p><pre class="kj kk kl km gt nk ly nl nm aw nn bi"><span id="478a" class="my mc it ly b gy no np l nq nr">10</span></pre></div><div class="ab cl oj ok hx ol" role="separator"><span class="om bw bk on oo op"/><span class="om bw bk on oo op"/><span class="om bw bk on oo"/></div><div class="im in io ip iq"><h1 id="d9fa" class="mb mc it bd md me oq mg mh mi or mk ml jz os ka mn kc ot kd mp kf ou kg mr ms bi translated">JavaScript中的Bind()方法</h1><p id="ed2f" class="pw-post-body-paragraph kz la it lb b lc mt ju le lf mu jx lh li mv lk ll lm mw lo lp lq mx ls lt lu im bi translated">你之前已经学习了<code class="fe lv lw lx ly b">call()</code>和<code class="fe lv lw lx ly b">apply()</code>方法的作用。如您所见，它们在被调用时会立即执行该函数(并返回一个值)。</p><p id="4129" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe lv lw lx ly b">bind()</code>方法让人联想到<code class="fe lv lw lx ly b">call()</code>和<code class="fe lv lw lx ly b">apply()</code>。但是，<code class="fe lv lw lx ly b">bind()</code>不是立即执行一个函数，而是返回一个可以稍后执行的函数<strong class="lb iu"> </strong>。</p><p id="4976" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们修改前面的例子来使用<code class="fe lv lw lx ly b">bind()</code>:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oh oi l"/></div></figure><p id="d57c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">所以调用<code class="fe lv lw lx ly b">add.bind(obj, 3, 5)</code>返回一个函数。在这种情况下，您将它赋给一个名为<code class="fe lv lw lx ly b">func</code>的常量，然后运行它。</p><p id="c061" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这里调用<code class="fe lv lw lx ly b">func()</code>就是用<code class="fe lv lw lx ly b">3, 5</code>的参数在对象<code class="fe lv lw lx ly b">obj</code>上调用<code class="fe lv lw lx ly b">add()</code>函数。</p><p id="d8a5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在你明白什么是<code class="fe lv lw lx ly b">call()</code>、<code class="fe lv lw lx ly b">apply()</code>和<code class="fe lv lw lx ly b">bind()</code>以及它们是如何工作的了。这里有一个总结，告诉你如何在前面看到的相同的对象函数设置中使用它们。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oh oi l"/></div></figure><p id="a993" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">输出:</p><pre class="kj kk kl km gt nk ly nl nm aw nn bi"><span id="6c3a" class="my mc it ly b gy no np l nq nr">10 10 10</span></pre></div><div class="ab cl oj ok hx ol" role="separator"><span class="om bw bk on oo op"/><span class="om bw bk on oo op"/><span class="om bw bk on oo"/></div><div class="im in io ip iq"><h1 id="11ce" class="mb mc it bd md me oq mg mh mi or mk ml jz os ka mn kc ot kd mp kf ou kg mr ms bi translated">当在JavaScript中使用Call()时</h1><p id="da25" class="pw-post-body-paragraph kz la it lb b lc mt ju le lf mu jx lh li mv lk ll lm mw lo lp lq mx ls lt lu im bi translated">让我们看看在现实生活中如何使用<code class="fe lv lw lx ly b">call()</code>方法的例子。</p><h2 id="2f85" class="my mc it bd md mz na dn mh nb nc dp ml li nd ne mn lm nf ng mp lq nh ni mr nj bi translated">使用Call()链接对象构造函数</h2><p id="660e" class="pw-post-body-paragraph kz la it lb b lc mt ju le lf mu jx lh li mv lk ll lm mw lo lp lq mx ls lt lu im bi translated">例如，让我们创建一个<code class="fe lv lw lx ly b">Item</code>对象。<code class="fe lv lw lx ly b">Item</code>的构造器由<code class="fe lv lw lx ly b">name</code>和<code class="fe lv lw lx ly b">price</code>定义。</p><p id="f12e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们也创建属于<code class="fe lv lw lx ly b">Items</code>的<code class="fe lv lw lx ly b">Car</code>和<code class="fe lv lw lx ly b">Fruit</code>对象。现在，你可以使用<code class="fe lv lw lx ly b">Item</code>对象来初始化它们，而不是像<code class="fe lv lw lx ly b">Item</code>一样初始化它们。这通过<code class="fe lv lw lx ly b">call()</code>方法实现:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oh oi l"/></div></figure><h2 id="4273" class="my mc it bd md mz na dn mh nb nc dp ml li nd ne mn lm nf ng mp lq nh ni mr nj bi translated">使用Call()调用匿名函数</h2><p id="ea70" class="pw-post-body-paragraph kz la it lb b lc mt ju le lf mu jx lh li mv lk ll lm mw lo lp lq mx ls lt lu im bi translated">让我们创建一个匿名函数，并使用<code class="fe lv lw lx ly b">call()</code>为数组的每个对象调用它。</p><p id="d80e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">匿名函数为每个数组对象添加一个<code class="fe lv lw lx ly b">displayInfo()</code>函数。这是为了让它打印队列中每个人的正确位置:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oh oi l"/></div></figure><p id="548e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">输出:</p><pre class="kj kk kl km gt nk ly nl nm aw nn bi"><span id="76cd" class="my mc it ly b gy no np l nq nr">Position 0: Matt<br/>Position 1: Jack</span></pre><h2 id="f891" class="my mc it bd md mz na dn mh nb nc dp ml li nd ne mn lm nf ng mp lq nh ni mr nj bi translated">使用Call()运行带有对象的函数</h2><p id="8a7a" class="pw-post-body-paragraph kz la it lb b lc mt ju le lf mu jx lh li mv lk ll lm mw lo lp lq mx ls lt lu im bi translated">在定义<code class="fe lv lw lx ly b">call()</code>时，您已经看到了一个这样的例子。</p><p id="44f6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">您可以通过<code class="fe lv lw lx ly b">call()</code>方法将一个函数绑定到一个对象中。这样，您可以像调用属于对象的函数一样调用它:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oh oi l"/></div></figure></div><div class="ab cl oj ok hx ol" role="separator"><span class="om bw bk on oo op"/><span class="om bw bk on oo op"/><span class="om bw bk on oo"/></div><div class="im in io ip iq"><h1 id="7a18" class="mb mc it bd md me oq mg mh mi or mk ml jz os ka mn kc ot kd mp kf ou kg mr ms bi translated">当在JavaScript中使用Apply()时</h1><h2 id="0d34" class="my mc it bd md mz na dn mh nb nc dp ml li nd ne mn lm nf ng mp lq nh ni mr nj bi translated">使用Apply()将数组追加到另一个数组</h2><p id="c4bf" class="pw-post-body-paragraph kz la it lb b lc mt ju le lf mu jx lh li mv lk ll lm mw lo lp lq mx ls lt lu im bi translated">您可以使用<code class="fe lv lw lx ly b">push()</code>方法将元素添加到数组中。</p><p id="48d0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果将一个数组传递给<code class="fe lv lw lx ly b">push()</code>方法，它会将整个数组作为一个元素添加到数组中。这意味着数组中有数组。这里你可以使用<code class="fe lv lw lx ly b">concat()</code>，但是它创建了一个新的数组。</p><p id="5ae4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果你想把一个数组作为一个整体添加到一个现有的数组中，使用<code class="fe lv lw lx ly b">apply()</code>。</p><p id="68ae" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">例如:</p><pre class="kj kk kl km gt nk ly nl nm aw nn bi"><span id="8a55" class="my mc it ly b gy no np l nq nr">const numbers = [1, 2, 3];<br/>const moreNumbers = [4, 5, 6];</span><span id="5b11" class="my mc it ly b gy ns np l nq nr">numbers.push.apply(numbers, moreNumbers);<br/>console.log(numbers);</span></pre><p id="4178" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">输出:</p><pre class="kj kk kl km gt nk ly nl nm aw nn bi"><span id="5dff" class="my mc it ly b gy no np l nq nr">[1,2,3,4,5,6]</span></pre><h2 id="8226" class="my mc it bd md mz na dn mh nb nc dp ml li nd ne mn lm nf ng mp lq nh ni mr nj bi translated">使用Apply()链接对象构造函数</h2><p id="6b0d" class="pw-post-body-paragraph kz la it lb b lc mt ju le lf mu jx lh li mv lk ll lm mw lo lp lq mx ls lt lu im bi translated">类似于用<code class="fe lv lw lx ly b">call()</code>链接构造函数，可以用<code class="fe lv lw lx ly b">apply()</code>链接对象构造函数。这一次，您将一个细节数组传递给对象构造函数来初始化对象。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oh oi l"/></div></figure></div><div class="ab cl oj ok hx ol" role="separator"><span class="om bw bk on oo op"/><span class="om bw bk on oo op"/><span class="om bw bk on oo"/></div><div class="im in io ip iq"><h1 id="0d24" class="mb mc it bd md me oq mg mh mi or mk ml jz os ka mn kc ot kd mp kf ou kg mr ms bi translated">当在JavaScript中使用绑定时</h1><h2 id="aad3" class="my mc it bd md mz na dn mh nb nc dp ml li nd ne mn lm nf ng mp lq nh ni mr nj bi translated">用Bind()创建绑定函数</h2><p id="79f9" class="pw-post-body-paragraph kz la it lb b lc mt ju le lf mu jx lh li mv lk ll lm mw lo lp lq mx ls lt lu im bi translated">您可以使用<code class="fe lv lw lx ly b">bind()</code>创建一个绑定到对象的函数。这样，无论何时以何种方式调用它，它都是用它所绑定的对象来调用的。</p><p id="2405" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">前面的一个例子就是这样做的。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oh oi l"/></div></figure><h2 id="3369" class="my mc it bd md mz na dn mh nb nc dp ml li nd ne mn lm nf ng mp lq nh ni mr nj bi translated">使用Bind()使SetTimeout工作</h2><p id="9986" class="pw-post-body-paragraph kz la it lb b lc mt ju le lf mu jx lh li mv lk ll lm mw lo lp lq mx ls lt lu im bi translated">这段代码有一个问题:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oh oi l"/></div></figure><p id="f89c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">它不打印名称<code class="fe lv lw lx ly b">“John”</code>。而是打印<code class="fe lv lw lx ly b">undefined</code>。</p><p id="77de" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">为了理解为什么会发生这种情况，让我们用另一种等价的方式重写最后一行:</p><pre class="kj kk kl km gt nk ly nl nm aw nn bi"><span id="69ea" class="my mc it ly b gy no np l nq nr">let func = person.getName;<br/>window.setTimeout(func, 1000);</span></pre><p id="aba8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">当<code class="fe lv lw lx ly b">window</code>调用其<code class="fe lv lw lx ly b">setTimeout()</code>方法时，其<code class="fe lv lw lx ly b">this</code>对象就是<code class="fe lv lw lx ly b">window</code>对象。因此，当<code class="fe lv lw lx ly b">setTimeout()</code>调用引用<code class="fe lv lw lx ly b">person.getName()</code>的<code class="fe lv lw lx ly b">func</code>时，它不知道这个人的名字是什么。为了克服这个问题，使用<code class="fe lv lw lx ly b">bind()</code>方法将函数绑定到person对象。这样无论你在哪里调用这个函数，它仍然可以访问<code class="fe lv lw lx ly b">person</code>的<code class="fe lv lw lx ly b">name</code>。</p><pre class="kj kk kl km gt nk ly nl nm aw nn bi"><span id="af8b" class="my mc it ly b gy no np l nq nr">let func = person.getName.bind(person);<br/>setTimeout(func, 1000);</span></pre><p id="cc32" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">输出:</p><pre class="kj kk kl km gt nk ly nl nm aw nn bi"><span id="c744" class="my mc it ly b gy no np l nq nr">John</span></pre><p id="7ae4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这行得通，因为现在</p><ul class=""><li id="207d" class="nt nu it lb b lc ld lf lg li nv lm nw lq nx lu ny nz oa ob bi translated"><code class="fe lv lw lx ly b">person.getName</code>方法被分配给一个绑定到<code class="fe lv lw lx ly b">person</code>对象的函数<code class="fe lv lw lx ly b">func</code>。</li><li id="12a2" class="nt nu it lb b lc oc lf od li oe lm of lq og lu ny nz oa ob bi translated">现在<code class="fe lv lw lx ly b">func</code>已经指向了<code class="fe lv lw lx ly b">this</code>对象<code class="fe lv lw lx ly b">person</code>。当你将绑定的函数传递给<code class="fe lv lw lx ly b">setTimeout()</code>时，<code class="fe lv lw lx ly b">func</code>仍然知道如何获取<code class="fe lv lw lx ly b">person</code>的<code class="fe lv lw lx ly b">name</code>。</li></ul></div><div class="ab cl oj ok hx ol" role="separator"><span class="om bw bk on oo op"/><span class="om bw bk on oo op"/><span class="om bw bk on oo"/></div><div class="im in io ip iq"><h1 id="56fb" class="mb mc it bd md me oq mg mh mi or mk ml jz os ka mn kc ot kd mp kf ou kg mr ms bi translated">结论</h1><p id="0638" class="pw-post-body-paragraph kz la it lb b lc mt ju le lf mu jx lh li mv lk ll lm mw lo lp lq mx ls lt lu im bi translated">在JavaScript中，您可以使用<code class="fe lv lw lx ly b">call()</code>、<code class="fe lv lw lx ly b">apply()</code>和<code class="fe lv lw lx ly b">bind()</code>方法将函数与对象耦合。这样你就可以调用对象上的函数，就好像它属于这个对象一样。</p><ul class=""><li id="c3f2" class="nt nu it lb b lc ld lf lg li nv lm nw lq nx lu ny nz oa ob bi translated"><code class="fe lv lw lx ly b">call()</code>和<code class="fe lv lw lx ly b">apply()</code>是非常相似的方法。它们都立即在对象上执行绑定函数。</li><li id="0633" class="nt nu it lb b lc oc lf od li oe lm of lq og lu ny nz oa ob bi translated"><code class="fe lv lw lx ly b">bind()</code>方法不会立即执行该功能。相反，它创建并返回一个可在以后执行的绑定函数。</li></ul><p id="4940" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">此示例使用这些方法进行总结:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oh oi l"/></div></figure><p id="d2a4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">感谢阅读。我希望你喜欢它。编码快乐！</p></div><div class="ab cl oj ok hx ol" role="separator"><span class="om bw bk on oo op"/><span class="om bw bk on oo op"/><span class="om bw bk on oo"/></div><div class="im in io ip iq"><p id="3d69" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">附注:一定要把我的新帖子收进你的收件箱。 <a class="ae ky" href="https://artturi-jalli.medium.com/subscribe" rel="noopener"> <strong class="lb iu"> <em class="ov">在这里做</em> </strong> </a> <em class="ov">！还有，在Medium上阅读更多世界级的故事，可以考虑</em> <a class="ae ky" href="https://artturi-jalli.medium.com/membership" rel="noopener"> <strong class="lb iu"> <em class="ov">成为会员</em> </strong> </a> <em class="ov">。每月只需5美元。此外，你的写作也能赚钱。当我开始做</em> <strong class="lb iu"> <em class="ov">的时候，我用编程文章在前6个月赚了5000美元</em> </strong> <em class="ov">。通过注册</em> <a class="ae ky" href="https://artturi-jalli.medium.com/membership" rel="noopener"> <strong class="lb iu"> <em class="ov">和这个</em> </strong> </a> <em class="ov">链接，你可以用你的一部分费用来支持我，不需要额外的费用。如果你这样做了，非常感谢！</em></p></div><div class="ab cl oj ok hx ol" role="separator"><span class="om bw bk on oo op"/><span class="om bw bk on oo op"/><span class="om bw bk on oo"/></div><div class="im in io ip iq"><h1 id="eb9e" class="mb mc it bd md me oq mg mh mi or mk ml jz os ka mn kc ot kd mp kf ou kg mr ms bi translated">资源</h1><div class="ow ox gp gr oy oz"><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript" rel="noopener  ugc nofollow" target="_blank"><div class="pa ab fo"><div class="pb ab pc cl cj pd"><h2 class="bd iu gy z fp pe fr fs pf fu fw is bi translated">JavaScript | MDN</h2><div class="pg l"><h3 class="bd b gy z fp pe fr fs pf fu fw dk translated">JavaScript (JS)是一种轻量级、解释型或即时编译的编程语言，具有一流的…</h3></div><div class="ph l"><p class="bd b dl z fp pe fr fs pf fu fw dk translated">developer.mozilla.org</p></div></div><div class="pi l"><div class="pj l pk pl pm pi pn ks oz"/></div></div></a></div></div></div>    
</body>
</html>