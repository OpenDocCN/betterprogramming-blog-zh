# 简单代码是可测试的代码

> 原文：<https://betterprogramming.pub/simple-code-is-testable-code-b845a4d56ede>

## 测试不一定很难

![](img/a45bf1f85a01af4625bca32ecb6c439d.png)

安妮·斯普拉特在 [Unsplash](https://unsplash.com/s/photos/test?utm_source=unsplash&utm_medium=referral&utm_content=creditCopyText) 上的照片

编写代码和其他技能一样是一种技能。你需要练习和练习。你需要阅读好的代码来看看它是什么样子的。你需要尝试一些事情，看看结果如何，以了解什么可行，什么不可行。

有时候，你写的代码感觉不太对劲。你尽力了，但是你仍然认为你可以写得更好。任何有自尊的程序员在某些时候都会有这种感觉。没关系:你不会每次都写出最好的代码。

但是你不能忽视的一件事是测试你的代码。

到处都是呻吟声，对吗？任何软件工程师一提到测试，被压抑的关于古怪测试、无用单元测试或者不测试任何东西的测试的记忆就开始出现。

测试不应该这样。它从简单的代码开始。

# 测试应该不难

测试(至少是白盒测试)的一个常见问题是代码太复杂。没有明确的阶级等级。一切影响一切。

状态在多个对象之间共享，防止您在一个地方断言更改。仅一个测试的设置就比实际测试多 20 倍的代码行。

我去过那里。累死人了。

简单代码则大不相同。这非常容易测试。例如，这个纯粹的函数——虽然微不足道——非常容易测试。

```
int multiply(int a, int b) {
    return a * b;
}
```

对这个函数的测试只需要提出使用边界情况的参数——大数、负数等。没有副作用，测试人员只需断言结果。

当然，我听到你已经在说:“好吧，废话。这是一个简单的功能。”

没错。这就是重点…简单的代码易于测试。

# 一个更完整的例子

更复杂一点的呢？假设我们需要一个函数，它返回一个介于 0 和一个可配置参数之间的随机数，这个参数是从一个名为`props.yml`的文件中读取的。

我们可以这样做的一个方法是:

![](img/d0654b7461dd0b4cd2216271910fd258.png)

一个简单的类，从文件中读取 random.upperLimit 属性，作为生成随机数时的限制

那么，这有什么问题(集中在我们能/不能测试的方面)？

1.  为了做一个简单的单元测试，一个`props.yml` *必须*出现在我们的测试`resources`中。此外，如果我们想改变值，我们必须改变文件！
2.  我们不会有确定性测试！`Random`是一个伪随机数生成器，我们不提供种子，所以我们不能验证在调用`getRandomNumber`时是否得到了预期值。
3.  我们有边缘案例需要测试。如果属性文件存在，但是没有我们提供的密钥，该怎么办？如果值不是整数呢？
4.  虽然不是最重要的，你现在有一个速度问题。每次您需要测试这个类时，您都需要重新加载和重新读取这个文件。

# 我们能做些什么改变？

基于我们上面发现的问题，我们希望能够测试这个类。

1.  为每个测试读取和更改文件可能会有问题。我们还能做什么？
2.  我们想要一个确定性的测试，但是我们在每个实例中创建了一个新的`Random`对象。我们如何控制`Random`返回什么值呢？
3.  测试与我们想要测试的实际功能没有什么关系的边缘案例是令人沮丧的。我们如何减少边缘案例和复杂性，以便我们可以专注于测试`getRandomNumber`？
4.  为了解决速度问题，有没有一种完全不需要文件的方法？

让我们来看三个可以帮助我们实现这些目标的核心概念。

## 1.类应该只知道它们的直接依赖关系

类应该相互作用，尽可能了解它们的依赖关系。

这个原理被称为德米特定律[，有助于保持高内聚和低耦合。所有这些都意味着，如果应用程序的一小部分发生了变化，那么只有一小部分会受到影响。](https://en.wikipedia.org/wiki/Law_of_Demeter)

我们班违反了那条规则。如果我们改变属性文件的位置，或者改变它的名字，我们的类需要知道它。我们的类还必须使用类加载器，了解如何解析文件等。

我们的类只需要两样东西:一个`Random`实例和一个限制值的 int。这就是我们的目标功能所需要的:生成一个介于 0 和可配置限制之间的随机数。

如果我们能够消除文件读取和解析的额外职责，我们的类就会变得*更小* 更集中。表面积的减少意味着我们可以更容易地编写测试，并且用相同的测试用例覆盖比以前更多的代码。

但是，我们如何消除类从文件中读取的需要呢？继续读。

## 2.依赖注入

[依赖注入](https://en.wikipedia.org/wiki/Dependency_injection)听起来就像它是什么:你传递(或*注入*)一个类的依赖，而不是类实例化依赖本身。这听起来很傻，但是如果操作正确的话，它会带来很多便利。

首先，我们的课程现在作业少了。他们不需要知道如何构建他们需要的依赖关系；他们只是要求他们。正如我们在上面看到的，这降低了单个类的复杂性。

第二，这允许应用程序的状态在类之间更简单地传播。像属性这样的东西可以包含在一个对象中，并作为依赖项传递给需要它们的类。每个人都得到相同的状态。

第三，它允许*控制*那些依赖关系。虽然这看起来微不足道而且显而易见，但它的好处是巨大的！

我们可以基于应用程序的其他配置，甚至使用专门的对象进行测试，来注入这些依赖关系的特定实例，正如我们将在下面看到的。如果我们对一个接口而不是一个具体的实现进行编码，这尤其正确。

因此，依赖注入为我们的测试提供了我们需要的控制。举个例子，如果您只是将上限值直接传递给类，而不是从文件中读取它，会怎么样呢？

能够测试那个类会有很大帮助。要测试不同的限制，只需创建传入不同值的实例。

当然，有一个缺点:您仍然必须以某种方式读取配置文件*。然而，有人可能会说，如果你正在阅读这一份财产，将来你还会有其他财产要读。*

因此，也许不需要让多个类读取同一个文件，这很容易出错(并且在 I/O 上更昂贵)，您可以很容易地设想一种“属性读取器”,它发出要使用的属性。

然后，您只需找到您需要的属性，并将它们注入到需要它们的类中。

有完整的框架，通常被称为控制框架的反转，在这方面提供帮助。我们现在不谈具体的一个。只要知道它们提供了您需要的工具来实现简单的依赖注入，就像我们在这里需要的那样。

我们的类现在简单多了，不再需要使用依赖注入直接读取文件。但是`Random`呢？

## 3.嘲弄

输入模拟。Mocks 本质上是专门化的对象，用来告诉一个对象当一个特定的函数调用针对它时如何响应(称为期望)。

模拟的使用帮助我们以一种我们以前不能的方式控制像`Random`这样的事情。

模拟在软件工程中是有争议的。许多工程师认为它们是伟大的工具，但是许多其他人发现它们是一种[代码气味](https://medium.com/javascript-scene/mocking-is-a-code-smell-944a70c90a6a)。

我发现模拟有助于孤立地测试一个组件，但有时使用它们是不必要的，甚至是危险的。

一整套单元测试很容易通过模拟测试，而在真正的系统调用中失败。模仿对于模仿外部库或任何进出应用程序的 I/O 尤其有用。

在我们的简单例子中，我们拥有的核心依赖关系是在`Random`上。随机本身就是随机的。我们想要的是以某种方式控制它返回什么值，以断言我们基于该值返回其他东西的逻辑。

此外，最好能验证我们的上限的正确值被提供给了`nextInt`方法，以确保我们确实用它做了一些事情。

模拟是我们解决这个问题的方法。我们可以告诉 mock 根据方法调用的预期值返回一个特定的值，并验证该方法也被调用。在这里，我们要确保两件事:

1.  我们的方法正确地传递来自`random.nextInt`的值。
2.  我们用正确的极限值调用`random.nextInt`。

我不会在这里详细介绍一个特定的库，但是大多数语言都有一些模仿的构造。Java ( [Mockito](https://site.mockito.org/) 、[EasyMock.org](http://easymock.org/))、Python ( [unittest.mock](https://docs.python.org/3/library/unittest.mock.html) )、[Groovy](https://groovy-lang.org/)([mock for](https://docs.groovy-lang.org/latest/html/gapi/groovy/mock/interceptor/MockFor.html))等。和许多其他人都有工具可以帮助。

## 关于模仿依赖项和默认构造函数的一个注释

通常，在模拟和依赖注入的情况下，在实际应用中并不是所有的东西都需要模拟。我们的例子也很好地说明了这一点。我们不想强迫用户每次都把`Random`作为一个依赖注入到我们的类中——那将是令人讨厌的。

解决方案是为我们的对象创建不同的构造函数——一个进行默认创建，另一个提供注入模拟依赖项的位置。

我们的默认构造函数只需要必要的用户提供的参数就可以在应用程序代码中工作，并且允许专门为测试进行其他定制。这种模式被称为“伸缩构造函数”

一些语言，如 Java，也可以限制构造函数的可见性，这有助于防止我们在应用程序代码中调用仅为测试而创建的构造函数。许多语言也可以将这样的构造函数注释为“仅用于测试”

我们的类可以很容易地遵循这种模式，创建一个只需要上限 int 值的默认构造函数。这个构造函数将创建一个`Random`的实例，然后我们可以将它传递给一个伸缩的“仅用于测试”的构造函数，该构造函数允许我们传递一个用于测试的模拟。

# 把所有的放在一起

如果我们收集所有这些反馈，我们可以编写一个类似下面这样的类。

![](img/e67912fb6db74e878b3113d870614b11.png)

我们已经使我们的类变得更小(代码更少！)，限制了它的依赖关系，并通过依赖注入实现了 mocks 的使用。我们的测试现在可以用它需要的限制创建`RandomNumsBetter`的实例，并做出简单的断言。

我们甚至可以有一个小的测试，可能只有五个，调用默认的构建对象，并断言来自`getNextRandomNumber`的值在范围[0，4]内，以断言默认类得到了合理的创建。

我希望这个小例子已经展示了简单的代码如何导致简单和容易的测试。我没有在这里展示测试——我将把它作为一个练习留给你去做……但是它应该很容易。

编码快乐！