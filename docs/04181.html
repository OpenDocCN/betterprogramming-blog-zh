<html>
<head>
<title>Understand Garbage Collection in Python</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">了解Python中的垃圾收集</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/understand-garbage-collection-in-python-5bb118d1748e?source=collection_archive---------7-----------------------#2020-03-28">https://betterprogramming.pub/understand-garbage-collection-in-python-5bb118d1748e?source=collection_archive---------7-----------------------#2020-03-28</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="b66c" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">理解内存管理是如何工作的，尽管您不必亲自去做</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/fd9c67d0022940ba5e0a5559f387bf65.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*wW78UQQc85T5zlZFvK0tpA.jpeg"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">马库斯·斯皮斯克在<a class="ae ky" href="https://unsplash.com/s/photos/programmer?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</p></figure><p id="39c4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在像C或C++这样的语言中，程序员负责堆上内存的动态分配和释放。但是在Python中，程序员不必预分配或释放内存。</p><p id="ad6d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">Python使用以下垃圾收集算法进行内存管理:</p><ul class=""><li id="0220" class="lv lw it lb b lc ld lf lg li lx lm ly lq lz lu ma mb mc md bi translated">引用计数</li><li id="f9e1" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated">循环检测算法(循环引用)</li></ul></div><div class="ab cl mj mk hx ml" role="separator"><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo"/></div><div class="im in io ip iq"><h1 id="4b05" class="mq mr it bd ms mt mu mv mw mx my mz na jz nb ka nc kc nd kd ne kf nf kg ng nh bi translated">引用计数</h1><p id="45aa" class="pw-post-body-paragraph kz la it lb b lc ni ju le lf nj jx lh li nk lk ll lm nl lo lp lq nm ls lt lu im bi translated">引用计数是一个简单的过程，当程序中没有引用对象时，被引用对象被释放。</p><p id="24c1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">简而言之，当引用计数变为<code class="fe nn no np nq b">0</code>时，对象被释放(释放其分配的内存)。</p><p id="82c8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们看看下面的例子:</p><pre class="kj kk kl km gt nr nq ns nt aw nu bi"><span id="e827" class="nv mr it nq b gy nw nx l ny nz">def calculate_sum(num1, num2):<br/>    total = num1 + num2<br/>    print(total)</span></pre><p id="941a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在上面的例子中，我们有三个本地引用<code class="fe nn no np nq b">num1</code>、<code class="fe nn no np nq b">num2</code>和<code class="fe nn no np nq b">total</code>。这里，<code class="fe nn no np nq b">total</code>与<code class="fe nn no np nq b">num1</code>和<code class="fe nn no np nq b">num2</code>不同，因为它在块内只有一个引用——因此它的引用计数是1。<code class="fe nn no np nq b">num1</code>和<code class="fe nn no np nq b">num2</code>在块外被引用，所以它们的引用计数可能不止一个。</p><p id="7e43" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">因此，当函数执行完毕时，<code class="fe nn no np nq b">total</code>的引用计数会减少到零。这是因为它被垃圾收集器跟踪。</p><p id="2e1f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">垃圾收集器发现<code class="fe nn no np nq b">total</code>不再被引用(引用计数字段达到零)并释放其分配的内存。</p><p id="724e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在函数之外声明的变量不会被销毁——即使在函数完成执行之后。</p><p id="c72e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们也可以使用<code class="fe nn no np nq b">del</code>语句进行手动删除。<code class="fe nn no np nq b">del</code>语句删除一个变量及其引用。当引用计数达到<code class="fe nn no np nq b">0</code>时，它将被垃圾收集器收集。</p><p id="5c1a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">引用计数算法也有一些问题，比如循环引用。</p></div><div class="ab cl mj mk hx ml" role="separator"><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo"/></div><div class="im in io ip iq"><h1 id="853d" class="mq mr it bd ms mt mu mv mw mx my mz na jz nb ka nc kc nd kd ne kf nf kg ng nh bi translated">循环引用</h1><p id="69af" class="pw-post-body-paragraph kz la it lb b lc ni ju le lf nj jx lh li nk lk ll lm nl lo lp lq nm ls lt lu im bi translated">当一个或多个对象相互引用时，就会出现引用循环。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi oa"><img src="../Images/f88b549ef995dc02757a0e3bc81d6c1f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*zHOSBnurdsCisyw3.jpg"/></div></div></figure><p id="43c3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">正如你在上面的图像中看到的，<code class="fe nn no np nq b">list</code>物体指向自己，<code class="fe nn no np nq b">object1</code>和<code class="fe nn no np nq b">object2</code>指向对方。此类对象的引用计数始终至少为一。</p><p id="7546" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们看看实际情况:</p><pre class="kj kk kl km gt nr nq ns nt aw nu bi"><span id="32f5" class="nv mr it nq b gy nw nx l ny nz">import gc</span><span id="48ba" class="nv mr it nq b gy ob nx l ny nz">gc.set_debug(gc.DEBUG_SAVEALL) </span><span id="ab94" class="nv mr it nq b gy ob nx l ny nz">lst = []<br/>lst.append(lst)</span><span id="e7e2" class="nv mr it nq b gy ob nx l ny nz">lst_address = id(lst)</span><span id="6cb2" class="nv mr it nq b gy ob nx l ny nz">del lst</span><span id="5205" class="nv mr it nq b gy ob nx l ny nz">object_1 = {}<br/>object_2 = {}<br/>object_1['obj2'] = object_2<br/>object_2['obj1'] = object_1</span><span id="63de" class="nv mr it nq b gy ob nx l ny nz">obj_address = id(object_1)</span><span id="ae8f" class="nv mr it nq b gy ob nx l ny nz">del object_1, object_2</span></pre><p id="888e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在上面的例子中，<code class="fe nn no np nq b">del</code>语句删除了变量及其对对象的引用。</p><p id="196b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们使用<code class="fe nn no np nq b">gc.collect</code>来检查被删除的变量。<code class="fe nn no np nq b">gc.collect</code>保存到<code class="fe nn no np nq b">gc.garbage</code>而不是删除。</p><pre class="kj kk kl km gt nr nq ns nt aw nu bi"><span id="ed2c" class="nv mr it nq b gy nw nx l ny nz">&gt;&gt;&gt; gc.collect()<br/>3</span></pre><p id="a95a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">当我们删除一个变量时，我们只删除了<code class="fe nn no np nq b">__main__</code>引用。现在我们根本无法访问<code class="fe nn no np nq b">lst</code>、<code class="fe nn no np nq b">object_1</code>、<code class="fe nn no np nq b">object_2</code>，但是这些变量仍然有一个引用。这意味着引用计数是1—引用计数算法不会收集它。</p><p id="8f7b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">检查以下参考计数:</p><pre class="kj kk kl km gt nr nq ns nt aw nu bi"><span id="3cf1" class="nv mr it nq b gy nw nx l ny nz">import sys<br/>print(sys.getrefcount(obj_address))<br/>print(sys.getrefcount(lst_address))</span><span id="0448" class="nv mr it nq b gy ob nx l ny nz">2<br/>2<br/># 1 from the variable and 1 from getrefcount</span></pre><p id="d0ba" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">将这个数字乘以100万个对象，您肯定会遇到严重的内存泄漏问题。</p><p id="7d64" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">对于这种引用循环，Python有另一种算法专门用来发现和破坏循环引用。也是<a class="ae ky" href="https://docs.python.org/3.6/library/gc.html" rel="noopener ugc nofollow" target="_blank"> Python的GC </a>唯一可控的部分。</p></div><div class="ab cl mj mk hx ml" role="separator"><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo"/></div><div class="im in io ip iq"><h1 id="d790" class="mq mr it bd ms mt mu mv mw mx my mz na jz nb ka nc kc nd kd ne kf nf kg ng nh bi translated">摘要</h1><p id="21c9" class="pw-post-body-paragraph kz la it lb b lc ni ju le lf nj jx lh li nk lk ll lm nl lo lp lq nm ls lt lu im bi translated">Python有两种垃圾收集算法:一种用于处理引用计数——当引用计数达到零时，它删除对象并释放分配给它的内存。另一个是循环检测算法，它发现并销毁循环引用。</p><p id="ac95" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我希望您现在对Python中的垃圾收集算法有了相当的理解。</p><h1 id="2a01" class="mq mr it bd ms mt oc mv mw mx od mz na jz oe ka nc kc of kd ne kf og kg ng nh bi translated"><strong class="ak">参考</strong></h1><p id="a002" class="pw-post-body-paragraph kz la it lb b lc ni ju le lf nj jx lh li nk lk ll lm nl lo lp lq nm ls lt lu im bi translated"><a class="ae ky" href="https://rushter.com/blog/python-garbage-collector/" rel="noopener ugc nofollow" target="_blank">https://rushter.com/blog/python-garbage-collector/</a></p></div></div>    
</body>
</html>