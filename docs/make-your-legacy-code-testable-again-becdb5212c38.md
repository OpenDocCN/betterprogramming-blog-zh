# 让您的遗留代码再次可测试

> 原文：<https://betterprogramming.pub/make-your-legacy-code-testable-again-becdb5212c38>

## 在本文中，我们将关注如何重构遗留代码库，以便它可以再次测试(不需要依赖注入框架)

![](img/a44dec1307ca9bd2c49e5d456d66c4ca.png)

[穆利亚迪](https://unsplash.com/@mullyadii?utm_source=medium&utm_medium=referral)在 [Unsplash](https://unsplash.com?utm_source=medium&utm_medium=referral) 上的照片

# 背景

可能大多数软件开发人员都非常了解诸如单元测试和 TDD*T5 这样的术语。参与项目的开发人员努力工作，尽最大努力交付满足业务需求的解决方案。*

然而，有时，由于意想不到的困难(低估的用户故事/变化的需求/即将到来的截止日期/太小的团队/缺乏知识—选择一个)，技术债务可能会出现。这在一开始看起来可能是无辜的，但是我们的债务越大，出现 bug 的可能性就越大。

在本文中，我将关注技术债务的一个特殊味道，那就是不可测试的代码。

# 让我们来看看不可测试的代码

但是首先，简短的定义:我们可以说代码在不可能的时候是不可测试的，或者很难用单元/集成测试来覆盖代码。

我个人最喜欢从实例中学习，那么我们来考虑一个与保险行业相关的假设案例。

为了更好地了解索赔注册过程，粗略地说，我们可以将整个索赔注册过程分成几个较小的部分:

1.  查找保单—通常有一个单独的系统保存客户的保单
2.  从保单中选择适当的保险类型—例如，如果我们撞了别人的车，我们必须在保单中投保汽车第三方责任险；另一方面，如果冰雹损坏了我们的汽车，这种情况有一个单独的保险类型——所以，如果我们的保单没有与路上发生的情况相关的保险，保险公司不会支付我们任何赔偿
3.  收集必要的数据以识别被保险人、索赔人、涉及的车辆等
4.  有时，为了使整个索赔处理过程更加顺利，最好利用外部服务来提供涉及车辆的附加信息

因此，了解了这一点，您现在是一名专家了，企业渴望给您带来新的挑战，其中一个挑战听起来如下:*实施新的索赔登记流程*。

# 案例:实施新的索赔登记流程

*   您一直在为一家保险公司开发一个处理汽车索赔的 Java 应用程序
*   要求是允许索赔人登记 MTPL(机动车第三方责任)索赔
*   索赔人将向我们提供车辆的详细信息，如品牌、型号、VIN(车辆识别号)
*   为了加快索赔处理的整个过程，企业希望您使用一种奇特的第三方服务来解码 VIN，这样索赔处理人员将会收到有关所涉及车辆的附加信息

现在，假设您得到了需求，并且立即开始了实现部分:

初始实施

您刚刚完成了实现，点击了 UI，一切看起来都很好，万岁！你有时间看搞笑狗:)

![](img/f15570fbcf3cd7afc82f6255b409b0ff.png)

由[罗伯特·尼克森](https://unsplash.com/@rpnickson?utm_source=medium&utm_medium=referral)在 [Unsplash](https://unsplash.com?utm_source=medium&utm_medium=referral) 上拍摄

好消息是企业接受了这个解决方案，坏消息是企业不知道(也许你也不知道)由于没有用单元/集成测试覆盖引入的功能，技术债务增加了。

## 上面的代码有什么问题？

1.  代码没有被测试覆盖
2.  如果您想稍后编写单元测试，您会看到在测试中调用`RegisterMotorClaimService#registerClaim()`试图调用策略系统和 VIN 解码服务

第一点是不言自明的。用测试覆盖代码永远不会太晚，所以让我们专注于第二点。

就集成测试而言，您可以说:

> 嘿，但是`new PolicyService()`可能包含了调用适当服务所需的所有信息，比如 URL、用户名、密码和其他数据。也许构造器从数据库或一些属性文件中获得这些信息，所以我们可以区分生产环境和测试环境。

说到集成测试，事实上，可能就是这样，所以我们可以编写它们。然而，在单元测试的情况下，事情变得有点复杂。

我们如何编写与外部环境和服务隔离的单元测试，以便无论何时运行它们，我们都可以确保它们不会因为策略系统安装或 VIN 解码服务关闭而失败？

答案是:允许被测试的功能使用假依赖。换句话说，告诉这个类使用一个不同版本的服务，它可以抵抗失败，而且，它总是可以返回我们想要的。使用这种方法，您可以从策略系统和 VIN 解码服务准备测试响应。反过来，这将允许您编写不关心服务访问中断的测试，因此您的测试不会随机失败。

# 重构步骤

有些人倾向于以“火了就忘”的方式编写代码，但我个人发现重构可以带来很大的满足感，尤其是当我可以用一些测试覆盖它时——测试报告中没有什么比绿色更好的了:)。

因为我们已经了解了之前解决方案的后果，所以让我们从重构中获得一些乐趣。

为了使上面的代码再次可测试，我们需要识别我们想要隔离的外部依赖，在我们的例子中是`SomePolicyService`和`SomeVinDecodingService`。

## 步骤 1:从外部提供依赖关系

在从外部提供依赖关系之前

重构后

使用这种方法，您可以摆脱硬编码的依赖，并通过`RegisterMotorClaimService`中的构造函数注入从外部提供它们

如果您使用像 Mockito 这样的库，您很可能就在这里完成重构过程，因为您的 mock 库应该允许您模仿具体的类。

然而，如果由于某种原因，您不能模仿具体的类，那么继续第 2 步。

## 步骤 2:提取依赖关系的接口

如果您不能模拟具体的类，或者如果您根本不能使用模拟库，那么您就需要执行这个额外的步骤，以便手动模拟对象。

让我们创建将分别由`SomePolicyService`和`SomeVinDecodingService`实现的接口。

服务的提取接口

最后一件事是在我们现有的类中实现这些接口:

实现提取接口的服务

## 步骤 3:更改传递的依赖项的类型

如果您已经执行了步骤#2，您还需要更改通过`RegisterMotorClaimService`中的构造函数传递的对象的参数类型。通过将参数类型从具体的类改为它们的接口等价物来实现。

之后:

将参数类型从具体类更改为接口

通过这样做，您可以用 PROD 环境的真实依赖关系实例化`RegisterMotorClaimService`,或者传递单元测试的假依赖关系。

## 步骤 4:编写一个样本测试

测试提供虚假依赖的业务逻辑

在这个测试中，我通过创建服务的匿名实现来手动模拟服务。

然后我将这些依赖项传递给测试中的服务`RegisterMotorClaimService`。

最后，我验证注册的索赔是否与具有给定保单号的保单相关联。

# 最后的想法

总结一下:

*   在编写实际代码之前，我们应该考虑如何编写可测试的实现
*   依赖关系应该从类的外部提供，所以我们可以很容易地替换它们来进行单元测试
*   重构代码并为现有功能添加测试永远不会太迟