<html>
<head>
<title>Python Decorators — 5 Advanced Features to Know</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">python Decorators——需要了解的5个高级特性</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/python-decorators-5-advanced-features-to-know-17dd9be7517b?source=collection_archive---------4-----------------------#2020-09-09">https://betterprogramming.pub/python-decorators-5-advanced-features-to-know-17dd9be7517b?source=collection_archive---------4-----------------------#2020-09-09</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="6584" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">在您的项目中利用Python decorators</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/ec018d482493f1cfdb226a04be896d0d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*0aUkxvuDOIhBvsgZ"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">图为<a class="ae ky" href="https://unsplash.com/@mantashesthaven?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Mantas Hesthaven </a>在<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上。</p></figure><p id="0124" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">装饰器是修改其他函数的行为而不改变其核心操作的函数。顾名思义，装饰者只装饰其他功能。你可以把其他功能想象成普通的甜甜圈，而装饰者所做的就是给甜甜圈涂上不同的涂层。不管你有什么口味(装饰者)，甜甜圈(装饰功能)仍然是甜甜圈。</p><p id="8911" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">下面的代码向您展示了一个基本的装饰器，它记录了一个函数调用的运行时间。本质上，装饰函数接受另一个函数(即要装饰的函数)作为它的输入参数。它定义了一个实际提供装饰活动的内部函数，并返回该内部函数作为输出。要使用装饰器，只需将带有<code class="fe lv lw lx ly b">@</code>符号前缀的装饰器函数名放在要用装饰器函数装饰的函数的上方。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="lz ma l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">装饰者的基本形式</p></figure><p id="8080" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">既然您已经对装饰者的最基本形式有了很好的理解，那么是时候获得一些关于它们的更深入的知识了。</p></div><div class="ab cl mb mc hx md" role="separator"><span class="me bw bk mf mg mh"/><span class="me bw bk mf mg mh"/><span class="me bw bk mf mg"/></div><div class="im in io ip iq"><h1 id="16d8" class="mi mj it bd mk ml mm mn mo mp mq mr ms jz mt ka mu kc mv kd mw kf mx kg my mz bi translated">1.支持不同的函数签名</h1><p id="bfb7" class="pw-post-body-paragraph kz la it lb b lc na ju le lf nb jx lh li nc lk ll lm nd lo lp lq ne ls lt lu im bi translated">上面的代码片段有一个问题:它假设修饰的函数不需要任何输入参数(第7行)。如果我们将当前形式的装饰器与一个带参数的函数一起使用，它将不会像您预期的那样工作:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="lz ma l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">签名不兼容</p></figure><p id="fc04" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">为了解决这个问题，我们应该考虑在装饰定义中使用<code class="fe lv lw lx ly b">*args</code>和<code class="fe lv lw lx ly b">**kwargs</code>。这两个术语用于表示函数中不确定数量(零到更多)的位置和关键字参数。换句话说，它们可以捕获各种函数签名。让我们看看修改后的版本及其改进的兼容性:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="lz ma l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">支持不同的签名</p></figure><p id="7e52" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">正如您所看到的，最大的变化是不再假设函数不带参数，修改后的版本为函数调用提供了<code class="fe lv lw lx ly b">*args </code>和<code class="fe lv lw lx ly b">**kwargs</code>，这样装饰器现在更加通用了。</p></div><div class="ab cl mb mc hx md" role="separator"><span class="me bw bk mf mg mh"/><span class="me bw bk mf mg mh"/><span class="me bw bk mf mg"/></div><div class="im in io ip iq"><h1 id="a377" class="mi mj it bd mk ml mm mn mo mp mq mr ms jz mt ka mu kc mv kd mw kf mx kg my mz bi translated">2.包装修饰的函数</h1><p id="3484" class="pw-post-body-paragraph kz la it lb b lc na ju le lf nb jx lh li nc lk ll lm nd lo lp lq ne ls lt lu im bi translated">有些人可能不知道，默认情况下，修饰会弄乱被修饰函数的元数据，比如docstrings。让我们看看当前装饰者的行为:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="lz ma l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">文档字符串有问题</p></figure><p id="73ed" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如您所见，文档字符串显示了我们在装饰函数中定义的内部函数，而不是装饰函数<code class="fe lv lw lx ly b">say_hello</code>。在引擎盖下，这都是因为装饰过程是从装饰器函数创建一个闭包。本质上，装修的过程相当于调用<code class="fe lv lw lx ly b">say_hello = logging_time(say_hello)</code>。因此，用修饰函数获得内部函数的文档字符串就不足为奇了。</p><p id="ec63" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">为了解决这个问题，我们可以使用标准Python库中附带的另一个装饰函数(<code class="fe lv lw lx ly b">wraps</code>)，如下所示:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="lz ma l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">包装装饰函数</p></figure><ul class=""><li id="e8c0" class="nf ng it lb b lc ld lf lg li nh lm ni lq nj lu nk nl nm nn bi translated">第2行:我们从<code class="fe lv lw lx ly b">functools</code>模块导入<code class="fe lv lw lx ly b">wraps</code>装饰函数。</li><li id="c869" class="nf ng it lb b lc no lf np li nq lm nr lq ns lu nk nl nm nn bi translated">第6行:我们使用<code class="fe lv lw lx ly b">wraps</code>装饰器通过包装要装饰的函数来装饰内部函数(<code class="fe lv lw lx ly b">func</code>参数)。</li><li id="ac95" class="nf ng it lb b lc no lf np li nq lm nr lq ns lu nk nl nm nn bi translated">第21-23行:修饰函数现在有了正确的文档字符串。</li></ul><p id="1aee" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">除了为被修饰的函数传递期望的文档字符串之外，<code class="fe lv lw lx ly b">wraps</code> decorator对于被修饰的函数显示正确的函数注释(例如参数类型)和支持数据保存的pickling是必要的。</p></div><div class="ab cl mb mc hx md" role="separator"><span class="me bw bk mf mg mh"/><span class="me bw bk mf mg mh"/><span class="me bw bk mf mg"/></div><div class="im in io ip iq"><h1 id="9b57" class="mi mj it bd mk ml mm mn mo mp mq mr ms jz mt ka mu kc mv kd mw kf mx kg my mz bi translated">3.用参数定义装饰器</h1><p id="f64f" class="pw-post-body-paragraph kz la it lb b lc na ju le lf nb jx lh li nc lk ll lm nd lo lp lq ne ls lt lu im bi translated">到目前为止，我们的装饰人员已经修复了他们的装饰功能。如果我们想让我们的装饰者根据用户的偏好表现出不同的行为呢？在这种情况下，我们可以考虑定义接受参数的装饰器。让我们继续记录函数运行时间的装饰示例。假设有一个微不足道的业务需求:我们的装饰者以用户指定的单位(毫秒或秒)显示时间。以下代码向您展示了一种可能的解决方案:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="lz ma l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">接受参数的装饰者</p></figure><p id="3270" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如您所见，为了允许装饰器接受<code class="fe lv lw lx ly b">unit</code>参数，我们需要在我们之前定义的装饰器之外创建另一个层。让我们看看它是否如我们预期的那样工作:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="lz ma l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">带参数的装饰器</p></figure><ul class=""><li id="c461" class="nf ng it lb b lc ld lf lg li nh lm ni lq nj lu nk nl nm nn bi translated">我们为装饰器使用了两种不同的设置，并且都按预期工作。</li><li id="17be" class="nf ng it lb b lc no lf np li nq lm nr lq ns lu nk nl nm nn bi translated">添加另一层来让装饰器接受参数的原因是装饰过程链接了函数调用。调用<code class="fe lv lw lx ly b">logging_time(“ms”)</code>将允许我们获得<code class="fe lv lw lx ly b">logger</code>函数，它与我们之前定义的装饰函数具有完全相同的函数签名。</li></ul><p id="8862" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">请注意，装饰者的当前定义要求我们指定装饰的单元。如果你想让你的论点可选，那就需要额外的工作。你可以在我之前的文章中找到相关的讨论。</p></div><div class="ab cl mb mc hx md" role="separator"><span class="me bw bk mf mg mh"/><span class="me bw bk mf mg mh"/><span class="me bw bk mf mg"/></div><div class="im in io ip iq"><h1 id="3b1f" class="mi mj it bd mk ml mm mn mo mp mq mr ms jz mt ka mu kc mv kd mw kf mx kg my mz bi translated">4.多个装饰者</h1><p id="43a1" class="pw-post-body-paragraph kz la it lb b lc na ju le lf nb jx lh li nc lk ll lm nd lo lp lq ne ls lt lu im bi translated">上面的例子只使用了一个装饰器来装饰其他函数。然而，可以同时使用多个装饰器来装饰函数。要做到这一点，我们可以简单地将装饰器堆叠在要装饰的函数之上。以下代码片段向您展示了一个简单的示例:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="lz ma l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">多个装饰者</p></figure><p id="8982" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">上面的代码向您展示了我们创建的另一个装饰器，它简单地调用了被装饰的函数两次。值得注意的是，我们定义了两个由两个装饰者装饰的函数。然而，我们以不同的顺序应用了装饰器，这将产生不同的效果:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="lz ma l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">装饰顺序的不同影响</p></figure><ul class=""><li id="68e1" class="nf ng it lb b lc ld lf lg li nh lm ni lq nj lu nk nl nm nn bi translated">我们注意到<code class="fe lv lw lx ly b">say_hi</code>函数被调用了两次，而时间只被记录了一次。同时，<code class="fe lv lw lx ly b">say_hello</code>函数被调用两次，时间也被记录两次。</li><li id="8e09" class="nf ng it lb b lc no lf np li nq lm nr lq ns lu nk nl nm nn bi translated">当我们有多个装饰者时，应用装饰者的顺序是基于邻近性的。换句话说，在装饰功能正上方的是先发挥装饰作用，以此类推。这就是为什么<code class="fe lv lw lx ly b">say_hi</code>函数的时间只被记录一次——因为<code class="fe lv lw lx ly b">logging_time</code>装饰器是最后应用的。相比之下，重复装饰器应用于已经被<code class="fe lv lw lx ly b">logging_time</code>装饰过的函数，因此<code class="fe lv lw lx ly b">say_hello</code>函数的时间被记录了两次。</li></ul></div><div class="ab cl mb mc hx md" role="separator"><span class="me bw bk mf mg mh"/><span class="me bw bk mf mg mh"/><span class="me bw bk mf mg"/></div><div class="im in io ip iq"><h1 id="9cb5" class="mi mj it bd mk ml mm mn mo mp mq mr ms jz mt ka mu kc mv kd mw kf mx kg my mz bi translated">5.基于类的装饰者</h1><p id="8fb4" class="pw-post-body-paragraph kz la it lb b lc na ju le lf nb jx lh li nc lk ll lm nd lo lp lq ne ls lt lu im bi translated">我们一直在说装饰者是函数。准确地说，这些是高阶函数，这意味着这些函数使用其他函数作为输入和/或输出参数。但是，你知道decorators可以作为一个类来实现吗？有了decorator作为类的可能性，我们应该说decorator是可调用的。在之前的一篇文章中，我介绍了callables。如果您不了解callables，请随意查看。</p><p id="e6df" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">以下代码向您展示了如何使用类定义装饰器:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="lz ma l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">作为类实现的装饰器</p></figure><ul class=""><li id="fe41" class="nf ng it lb b lc ld lf lg li nh lm ni lq nj lu nk nl nm nn bi translated">这个例子向您展示的不是最基本的decorator形式，而是可以接受参数的decorator。</li><li id="9688" class="nf ng it lb b lc no lf np li nq lm nr lq ns lu nk nl nm nn bi translated">我将把创建一个充当装饰器的类的挑战留给您。<strong class="lb iu"> </strong>使用类实现装饰器的基本原理与常规装饰器函数相同。您可以将类视为函数，因为上面的类通过实现<code class="fe lv lw lx ly b">__call__</code>方法变得可调用。</li><li id="2c34" class="nf ng it lb b lc no lf np li nq lm nr lq ns lu nk nl nm nn bi translated">正如您所看到的，通过指定重复次数，修饰函数可以按预期工作。</li></ul><p id="ca78" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">尽管使用类来实现装饰器是可能的，但是如果你希望你的装饰器是完全通用的，那么它会比这里介绍的更复杂。给出的例子只是为您提供一个概念证明。如果你想在一个类中定义的方法中使用这些装饰器，你必须考虑与类相关的位置参数(比如<code class="fe lv lw lx ly b">cls</code>)或者与实例相关的位置参数(比如<code class="fe lv lw lx ly b">self</code>)。更深入的知识可以参考一些关于<a class="ae ky" href="https://stackoverflow.com/questions/30104047/how-can-i-decorate-an-instance-method-with-a-decorator-class" rel="noopener ugc nofollow" target="_blank">栈溢出</a>的好的讨论。</p></div><div class="ab cl mb mc hx md" role="separator"><span class="me bw bk mf mg mh"/><span class="me bw bk mf mg mh"/><span class="me bw bk mf mg"/></div><div class="im in io ip iq"><h1 id="b350" class="mi mj it bd mk ml mm mn mo mp mq mr ms jz mt ka mu kc mv kd mw kf mx kg my mz bi translated">结论</h1><p id="ab16" class="pw-post-body-paragraph kz la it lb b lc na ju le lf nb jx lh li nc lk ll lm nd lo lp lq ne ls lt lu im bi translated">在本文中，我们首先回顾了decorator的基本形式，然后学习了decorator的五个更高级的特性。当你对decoratorss有了很好的理解，你可以定义一些自定义的decorator(例如，登录时间，类型检查)，这将有助于你的日常工作。</p></div></div>    
</body>
</html>