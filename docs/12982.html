<html>
<head>
<title>Web Scraping Using C# and .NET</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用C#和。网</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/web-scraping-using-c-and-net-d99a085dace2?source=collection_archive---------2-----------------------#2022-07-17">https://betterprogramming.pub/web-scraping-using-c-and-net-d99a085dace2?source=collection_archive---------2-----------------------#2022-07-17</a></blockquote><div><div class="fc ii ij ik il im"/><div class="in io ip iq ir"><div class=""/><div class=""><h2 id="16b3" class="pw-subtitle-paragraph jr it iu bd b js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki dk translated">将网页转换成结构化数据</h2></div><figure class="kk kl km kn gu ko gi gj paragraph-image"><div role="button" tabindex="0" class="kp kq di kr bf ks"><div class="gi gj kj"><img src="../Images/15c8c8bd67f481ce8a036c8ea9ed7e2d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*9jQRwSkWd3DuMZ2i"/></div></div><p class="kv kw gk gi gj kx ky bd b be z dk translated">Maksym Kaharlytskyi 在<a class="ae kz" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</p></figure><p id="5040" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">尽管C#已经成为一种可靠的编程语言，主要是在后端应用领域，但它并不是当你想构建一个web scraper时首先想到的语言。</p><p id="7d5a" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">虽然C#的刚性类型系统在处理大多数网页中似乎任意的结构时可能会感觉不灵活，但它实际上是一个非常好的高性能选择。</p><p id="98f2" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">在本文中，我们将深入探讨如何使用C#通过发送HTTP请求来检索内容，以及如何将响应解析为类型化对象。</p><h1 id="9ab2" class="lw lx iu bd ly lz ma mb mc md me mf mg ka mh kb mi kd mj ke mk kg ml kh mm mn bi translated">入门指南</h1><p id="19d6" class="pw-post-body-paragraph la lb iu lc b ld mo jv lf lg mp jy li lj mq ll lm ln mr lp lq lr ms lt lu lv in bi translated">如果您正在使用Visual Studio，只需创建一个新的控制台应用程序，并将其命名为您喜欢的任何名称。如果您使用的是<code class="fe mt mu mv mw b">dotnet</code>命令行，为您的项目创建一个文件夹并运行:</p><pre class="kk kl km kn gu mx mw my mz aw na bi"><span id="8cf7" class="nb lx iu mw b gz nc nd l ne nf">dotnet new console</span></pre><p id="7a25" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">现在，您将拥有一个空的<em class="ng"> Hello World </em>应用程序作为起点。</p><h1 id="40cb" class="lw lx iu bd ly lz ma mb mc md me mf mg ka mh kb mi kd mj ke mk kg ml kh mm mn bi translated">正在检索内容</h1><p id="2a15" class="pw-post-body-paragraph la lb iu lc b ld mo jv lf lg mp jy li lj mq ll lm ln mr lp lq lr ms lt lu lv in bi translated">您选择的检索内容的方法在很大程度上取决于您要抓取的页面类型。虽然你对静态页面使用标准的<code class="fe mt mu mv mw b">HttpClient</code>完全没问题，但它对SPA的React、Angular之类的构建没有太大帮助。</p><p id="631e" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">为了从SPA获取数据，我们需要模拟一个浏览器，让它为我们呈现页面返回的JavaScript。这方面的内容稍微多一点，所以让我们先深入一个简单的静态页面。</p><p id="8381" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">首先，我们需要一个<code class="fe mt mu mv mw b">HttpClient</code>实例。我们将使用它来发出请求，然后读取响应:</p><pre class="kk kl km kn gu mx mw my mz aw na bi"><span id="2655" class="nb lx iu mw b gz nc nd l ne nf">var httpClient = new HttpClient();<br/>var response = await httpClient.GetAsync("https://www.scrapethissite.com/pages/simple/");<br/>var content = await response.Content.ReadAsStringAsync();</span></pre><p id="c498" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">请注意，我们在这里使用的网站明确允许抓取。确保你总是尊重网站的速率限制，以及它不想要的页面。</p><p id="c598" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">因为这个页面上没有多少JavaScript魔法，所以我们能够在我们的<code class="fe mt mu mv mw b">content</code>变量中检索页面的所有HTML。<code class="fe mt mu mv mw b">HttpClient</code>方法适用于每一个页面，你可以通过<em class="ng">右键&gt;查看页面源代码</em>来查看页面的HTML，你可以直接看到页面的内容。</p><h2 id="e74e" class="nb lx iu bd ly nh ni dn mc nj nk dp mg lj nl nm mi ln nn no mk lr np nq mm nr bi translated">使用无头浏览器</h2><p id="9db9" class="pw-post-body-paragraph la lb iu lc b ld mo jv lf lg mp jy li lj mq ll lm ln mr lp lq lr ms lt lu lv in bi translated">如前所述，如果我们抓取的页面是一个更加动态的应用程序，使用JavaScript在客户端呈现页面的一部分，仅仅使用<code class="fe mt mu mv mw b">HttpClient</code>是不行的。</p><p id="7c8f" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">如果不评估服务器提供的JavaScript，我们只能得到如下的响应:</p><figure class="kk kl km kn gu ko gi gj paragraph-image"><div role="button" tabindex="0" class="kp kq di kr bf ks"><div class="gi gj ns"><img src="../Images/98536033b2420158395fa7406416c151.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*vOxpjnv0fvY9rpYtJXSmnA.png"/></div></div></figure><p id="700a" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">这是相当无用的。要评估JavaScript，我们可以做两件事。要么我们自己托管一个JavaScript运行时，并通过它运行页面返回的JavaScript，要么我们模拟一个浏览器。</p><p id="ccbf" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">这两种选择都相对复杂。托管像v8这样的JavaScript运行时——谷歌Chrome的JavaScript运行时——并不特别困难，但我们不能保证获得与浏览器相同的结果。因此，通过真正的浏览器实际运行JavaScript几乎总是更可取的。</p><p id="e507" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">控制另一个进程和模拟用户输入也是一个很大的挑战。幸运的是，我们不必如此。<a class="ae kz" href="https://webdriver.io/docs/automationProtocols/" rel="noopener ugc nofollow" target="_blank"> WebDriver </a>协议使得编程驱动浏览器实例成为可能，这正是我们想要做的。</p><p id="62e2" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">该协议已经在Chrome和Firefox中实现，并允许这些浏览器的所谓<em class="ng">无头</em>操作。也就是说，它们没有用户界面。</p><p id="f2c5" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">两个最流行的无头浏览器库实现是由谷歌维护的<a class="ae kz" href="https://github.com/puppeteer/puppeteer" rel="noopener ugc nofollow" target="_blank">木偶师</a>和由微软维护的<a class="ae kz" href="https://playwright.dev/" rel="noopener ugc nofollow" target="_blank">剧作家</a>。它们原本是用来自动化web测试的，但是它们也能很好地满足我们的目的。</p><figure class="kk kl km kn gu ko gi gj paragraph-image"><div role="button" tabindex="0" class="kp kq di kr bf ks"><div class="gi gj nt"><img src="../Images/27e11d40a7786f313433661b2f246437.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*U0fDTwIKtunYVYI1.png"/></div></div></figure><p id="e131" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">Puppeteer最初是NodeJS库的一个控制Chromium的端口。幸运的是，有人已经将这个库移植到了. NET。它被称为<em class="ng">puppetersharp</em>，让我们可以从C#代码中控制Chromium浏览器。让我们安装它并使用它来查找一些内容:</p><pre class="kk kl km kn gu mx mw my mz aw na bi"><span id="778a" class="nb lx iu mw b gz nc nd l ne nf">nuget install PuppeteerSharp</span></pre><p id="e5f4" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">之后，让我们使用Puppeteer启动一个headless Chrome实例，并从我们以前使用过的同一个页面中检索内容:</p><figure class="kk kl km kn gu ko"><div class="bz fq l di"><div class="nu nv l"/></div></figure><p id="a14e" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">这一次，我们不是简单地向远程主机发送请求，而是启动了整个Chrome实例，将它指向我们指定的地址，并让它为我们读取页面内容。</p><p id="a4bb" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">网页的HTML现在作为一个字符串放在<code class="fe mt mu mv mw b">content</code>变量中，准备就绪。最大的区别是，任何JavaScript都可以被渲染。这使我们能够观察SPA的内容，这是我们用以前的方法无法做到的。</p><p id="8634" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">有趣的事实:如果你把<code class="fe mt mu mv mw b">Headless = true</code>改成<code class="fe mt mu mv mw b">false</code>，再次运行代码，你可以看到整个浏览器被启动，自己导航。试试吧！</p><h1 id="98fd" class="lw lx iu bd ly lz ma mb mc md me mf mg ka mh kb mi kd mj ke mk kg ml kh mm mn bi translated">解析HTML</h1><p id="ed52" class="pw-post-body-paragraph la lb iu lc b ld mo jv lf lg mp jy li lj mq ll lm ln mr lp lq lr ms lt lu lv in bi translated">现在，我们确实有一些内容，但仍然相当松散。我们当然不希望用原始HTML填充数据库，所以在实际使用数据之前，我们需要做一些处理。</p><p id="2ab6" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">首先想到的可能是“正则表达式！”。这是有意义的，除了HTML是非常不规则的，这篇文章比我更好地解释了为什么不应该使用正则表达式来解析HTML。</p><p id="9a79" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">我们能做的是使用一个库来帮助我们有效地解析HTML。另一个稍微保守一点的选择是<strong class="lc iv"> HtmlAgilityPack </strong>。两者都工作得很好，但由于AngleSharp更现代一些，我们将尝试一下:</p><pre class="kk kl km kn gu mx mw my mz aw na bi"><span id="11da" class="nb lx iu mw b gz nc nd l ne nf">dotnet nuget install AngleSharp</span></pre><p id="884f" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">现在，AngleSharp首先需要的是一个浏览上下文和一个可以填充的文档:</p><pre class="kk kl km kn gu mx mw my mz aw na bi"><span id="e584" class="nb lx iu mw b gz nc nd l ne nf">var context = BrowsingContext.New(Configuration.Default);<br/>var document = await context.OpenAsync(req =&gt; req.Content(content));</span></pre><p id="bb20" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">在这个上下文中，<code class="fe mt mu mv mw b">content</code>是我们前面捕获的<code class="fe mt mu mv mw b">string</code>变量中的原始HTML。</p><h2 id="774a" class="nb lx iu bd ly nh ni dn mc nj nk dp mg lj nl nm mi ln nn no mk lr np nq mm nr bi translated">查找元素</h2><p id="3994" class="pw-post-body-paragraph la lb iu lc b ld mo jv lf lg mp jy li lj mq ll lm ln mr lp lq lr ms lt lu lv in bi translated">现在我们有了一个包含所有原始HTML的<code class="fe mt mu mv mw b">document</code>，由原始页面的节点构成。我们可以通过搜索这些节点来找到我们需要的确切信息。</p><p id="6db6" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">让我们看看我们是否能把这个页面组织成充满国家。</p><p id="605d" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">首先，我们需要知道我们在找什么。如果我们使用Chrome开发工具来检查一个元素(CTRL / CMD + Shift + C):</p><figure class="kk kl km kn gu ko gi gj paragraph-image"><div role="button" tabindex="0" class="kp kq di kr bf ks"><div class="gi gj nw"><img src="../Images/626e020bad8b4139dd4d38b76c1dc342.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*wH02DX5x8xRXb8IehEUn2Q.png"/></div></div></figure><p id="dcb0" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">我们可以看到，我们正在寻找的元素是带有<code class="fe mt mu mv mw b">col-md-4 country</code>类的<code class="fe mt mu mv mw b">div</code>——这应该不难找到！</p><p id="532e" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">使用一些简单的LINQ，我们可以获得匹配这个类的所有元素:</p><pre class="kk kl km kn gu mx mw my mz aw na bi"><span id="c0c5" class="nb lx iu mw b gz nc nd l ne nf">var countries = document.QuerySelectorAll("*")<br/>    .Where(e =&gt; e.LocalName == "div" &amp;&amp; e.ClassName == "col-md-4 country")<br/>    .ToList();</span></pre><p id="ac85" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">我完全知道这也可以通过使用<em class="ng"> QuerySelector </em>来完成，但是我们现在保持它非常简单并且使用C#-y。</p><p id="4912" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">运行这段代码将返回250个元素——这正好是该页面上列出的国家的数量！我们一定有所发现。现在让我们开始提取这些信息。</p><h2 id="83cc" class="nb lx iu bd ly nh ni dn mc nj nk dp mg lj nl nm mi ln nn no mk lr np nq mm nr bi translated">提取信息</h2><p id="2fc2" class="pw-post-body-paragraph la lb iu lc b ld mo jv lf lg mp jy li lj mq ll lm ln mr lp lq lr ms lt lu lv in bi translated">让我们从创建一个保存我们国家信息的<code class="fe mt mu mv mw b">record</code>开始。我们提前了解了这些领域，它们是:</p><pre class="kk kl km kn gu mx mw my mz aw na bi"><span id="c249" class="nb lx iu mw b gz nc nd l ne nf">public record Country(string Name, string Capital, int Population, int Area);</span></pre><p id="dd93" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">好的，都很好。现在是有趣的部分，老实说，这是C#感觉有点粗糙的部分。</p><p id="1557" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">为了提取数据，我们必须应用一些非常基本的字符串拆分技巧:</p><figure class="kk kl km kn gu ko"><div class="bz fq l di"><div class="nu nv l"/></div></figure><p id="cddc" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">它可能不是最漂亮的，但它完成了任务:</p><figure class="kk kl km kn gu ko gi gj paragraph-image"><div role="button" tabindex="0" class="kp kq di kr bf ks"><div class="gi gj nx"><img src="../Images/521259fc79947d4713258885804ddca0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*vrRAR062k8v49qM7_P2vZw.png"/></div></div></figure><h1 id="6a77" class="lw lx iu bd ly lz ma mb mc md me mf mg ka mh kb mi kd mj ke mk kg ml kh mm mn bi translated">结论</h1><p id="11db" class="pw-post-body-paragraph la lb iu lc b ld mo jv lf lg mp jy li lj mq ll lm ln mr lp lq lr ms lt lu lv in bi translated">我们已经构建了一个非常非常基础的scraper，它使用一个无头Chrome实例来访问一个页面，返回原始HTML并将其解析为我们可以使用的格式。下面是最终的代码:</p><figure class="kk kl km kn gu ko"><div class="bz fq l di"><div class="nu nv l"/></div></figure><p id="6957" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">拿着它，看看你是否可以用它来抓取你需要的信息。</p><p id="3a73" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">如果处理无头浏览器、代理和验证码对你来说不太有吸引力，那么有一些服务可以为你处理所有这些东西，比如<a class="ae kz" href="https://scrapeshark.com" rel="noopener ugc nofollow" target="_blank"> ScrapeShark </a>。充分披露:我是ScrapeShark的创造者，它是免费的。</p><p id="4bff" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">起初，建造铲运机可能看起来令人生畏且耗时，但从长远来看，它们将在您运营业务时为您节省大量时间！</p></div></div>    
</body>
</html>