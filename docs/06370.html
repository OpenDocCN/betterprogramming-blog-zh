<html>
<head>
<title>Create Secure Clients and Servers in Golang Using HTTPS</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用HTTPS在Golang中创建安全的客户端和服务器</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/create-secure-clients-and-servers-in-golang-using-https-aa970ba36a13?source=collection_archive---------8-----------------------#2020-09-25">https://betterprogramming.pub/create-secure-clients-and-servers-in-golang-using-https-aa970ba36a13?source=collection_archive---------8-----------------------#2020-09-25</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="2401" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">在Go中编写安全的web应用程序并了解细节</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/d0d712f9c2a4f205494cd912929035b3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*dPgg1rD2lJOxovKOSpwIuQ.jpeg"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">照片由<a class="ae ky" href="https://unsplash.com/@yogesh_7?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的<a class="ae ky" href="https://unsplash.com/@yogesh_7?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Yogesh Pedamkar </a>拍摄</p></figure></div><div class="ab cl kz la hx lb" role="separator"><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le"/></div><div class="im in io ip iq"><h1 id="b046" class="lg lh it bd li lj lk ll lm ln lo lp lq jz lr ka ls kc lt kd lu kf lv kg lw lx bi translated">概观</h1><p id="38e9" class="pw-post-body-paragraph ly lz it ma b mb mc ju md me mf jx mg mh mi mj mk ml mm mn mo mp mq mr ms mt im bi translated">这篇文章的目的是展示如何使用<a class="ae ky" href="https://golang.org/" rel="noopener ugc nofollow" target="_blank"> Go </a>和HTTPS编写安全的web服务和客户端。在研究如何做到这一点时，我看到了大量的文章和要点。然而，它们都没有提供我实现健壮的客户机或服务器所需的完整画面。他们中的大多数只提供了简洁的代码示例，以及同样简洁的关于如何创建代码工作所需的证书的示例。其他面向gRPC或TCP上的普通TLS。我还想了解我在做什么，而不仅仅是语法。这篇文章的重点是不仅提供<em class="mu">如何</em>而且提供<em class="mu">如何</em>背后的<em class="mu">为什么</em> s。</p><p id="acff" class="pw-post-body-paragraph ly lz it ma b mb mv ju md me mw jx mg mh mx mj mk ml my mn mo mp mz mr ms mt im bi translated">如果您已经熟悉HTTPS、TLS和公钥/私钥，您可以跳过下一节<strong class="ma iu">安全概述</strong>，直接进入<strong class="ma iu">创建证书和密钥</strong>。</p></div><div class="ab cl kz la hx lb" role="separator"><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le"/></div><div class="im in io ip iq"><h1 id="544d" class="lg lh it bd li lj lk ll lm ln lo lp lq jz lr ka ls kc lt kd lu kf lv kg lw lx bi translated">安全性概述</h1><p id="ebc8" class="pw-post-body-paragraph ly lz it ma b mb mc ju md me mf jx mg mh mi mj mk ml mm mn mo mp mq mr ms mt im bi translated">安全性对于确保客户的隐私和健康至关重要。他们希望确保他们提供的信息(如密码和信用卡号)会被预期的服务提供商获得。同样，服务提供商有时有必要确保他们正在与预期的客户沟通。</p><p id="b79f" class="pw-post-body-paragraph ly lz it ma b mb mv ju md me mw jx mg mh mx mj mk ml my mn mo mp mz mr ms mt im bi translated">安全通信有两个特征:信任和加密。</p><p id="e249" class="pw-post-body-paragraph ly lz it ma b mb mv ju md me mw jx mg mh mx mj mk ml my mn mo mp mz mr ms mt im bi translated">信任是安全的基础。没有信任，就无法保证对话双方都不是坏人。</p><p id="a9d6" class="pw-post-body-paragraph ly lz it ma b mb mv ju md me mw jx mg mh mx mj mk ml my mn mo mp mz mr ms mt im bi translated">需要加密来确保不良行为者无法偷听对话、获取敏感信息或执行有害操作。</p><p id="264d" class="pw-post-body-paragraph ly lz it ma b mb mv ju md me mw jx mg mh mx mj mk ml my mn mo mp mz mr ms mt im bi translated">为了确保信任和安全，必须满足以下要求:</p><ul class=""><li id="65cb" class="na nb it ma b mb mv me mw mh nc ml nd mp ne mt nf ng nh ni bi translated">必须有可信的权威机构来保证客户端或服务器的身份。</li><li id="da4f" class="na nb it ma b mb nj me nk mh nl ml nm mp nn mt nf ng nh ni bi translated">客户端和服务器可以用来加密其通信的加密技术的可信来源也必须存在。</li><li id="d5af" class="na nb it ma b mb nj me nk mh nl ml nm mp nn mt nf ng nh ni bi translated">代码中必须支持用于实现客户端和服务器应用程序的相关技术。</li></ul><p id="941c" class="pw-post-body-paragraph ly lz it ma b mb mv ju md me mw jx mg mh mx mj mk ml my mn mo mp mz mr ms mt im bi translated">所有这些东西的保护伞被称为<a class="ae ky" href="https://en.wikipedia.org/wiki/Public_key_infrastructure" rel="noopener ugc nofollow" target="_blank">公钥基础设施(PKI) </a>。PKI有四个实现上述要求的组件:</p><h2 id="d2de" class="no lh it bd li np nq dn lm nr ns dp lq mh nt nu ls ml nv nw lu mp nx ny lw nz bi translated">公钥加密</h2><p id="d2a7" class="pw-post-body-paragraph ly lz it ma b mb mc ju md me mf jx mg mh mi mj mk ml mm mn mo mp mq mr ms mt im bi translated">公钥可以由所有者安全地与另一方共享，并为另一方提供加密和解密会话的能力。公钥的所有者有一个不共享的相应私钥。公钥只能解密用相应的私钥加密的信息。同样，需要私钥来解密用公钥加密的信息。加密的这种非对称特征保证了信息可以在已知的对话方之间安全地共享。</p><h2 id="8a91" class="no lh it bd li np nq dn lm nr ns dp lq mh nt nu ls ml nv nw lu mp nx ny lw nz bi translated">证书</h2><p id="c1de" class="pw-post-body-paragraph ly lz it ma b mb mc ju md me mf jx mg mh mi mj mk ml mm mn mo mp mq mr ms mt im bi translated">证书包含持有者的身份以及证书所有者的公钥。证书还包括颁发证书的可信机构的信息。</p><h2 id="8063" class="no lh it bd li np nq dn lm nr ns dp lq mh nt nu ls ml nv nw lu mp nx ny lw nz bi translated">证书颁发机构(CA)</h2><p id="8af8" class="pw-post-body-paragraph ly lz it ma b mb mc ju md me mf jx mg mh mi mj mk ml mm mn mo mp mq mr ms mt im bi translated">证书颁发机构是身份信息的可信来源。他们还可以颁发证书或将该权限委托给注册机构。</p><h2 id="eede" class="no lh it bd li np nq dn lm nr ns dp lq mh nt nu ls ml nv nw lu mp nx ny lw nz bi translated">注册机构</h2><p id="0675" class="pw-post-body-paragraph ly lz it ma b mb mc ju md me mf jx mg mh mi mj mk ml mm mn mo mp mq mr ms mt im bi translated">注册机构是证书的可信来源。由RA颁发的任何证书也将包含授权它们颁发证书的CA的证书。这是确保满足信任要求所必需的。换句话说，ra本身之所以被信任，是因为它们可以证明自己受到CA的信任。</p></div><div class="ab cl kz la hx lb" role="separator"><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le"/></div><div class="im in io ip iq"><h1 id="74c0" class="lg lh it bd li lj lk ll lm ln lo lp lq jz lr ka ls kc lt kd lu kf lv kg lw lx bi translated">创建证书和密钥</h1><p id="4f6b" class="pw-post-body-paragraph ly lz it ma b mb mc ju md me mf jx mg mh mi mj mk ml mm mn mo mp mq mr ms mt im bi translated">证明身份和加密信息的基础是证书和相应的证书颁发机构。出于本文的目的，我们两者都需要。有两种方法可以获得这些，艰难的方法和简单的方法。硬方法适用于真实世界的应用程序。它包括注册一个域(例如，youngkin.com)，获得该域的DNS服务，以及获得该域的证书。虽然不难，但需要做大量的工作，你可能需要花一些钱来注册域名。</p><p id="569e" class="pw-post-body-paragraph ly lz it ma b mb mv ju md me mw jx mg mh mx mj mk ml my mn mo mp mz mr ms mt im bi translated">提供真实体验的一种更简单的方法是创建您自己的CA并从该CA获得证书。本文使用CA签名证书和自签名证书来创建更真实的体验。我发现创建一个CA，请求证书，并让CA签署这些证书有助于理解整个过程。</p><p id="b94d" class="pw-post-body-paragraph ly lz it ma b mb mv ju md me mw jx mg mh mx mj mk ml my mn mo mp mz mr ms mt im bi translated">通常，服务器访问安装在机器上的CA证书。本文将演示如何以编程方式注册CA证书。</p><p id="0f0a" class="pw-post-body-paragraph ly lz it ma b mb mv ju md me mw jx mg mh mx mj mk ml my mn mo mp mz mr ms mt im bi translated">至少有几个工具可以帮助我们实现简单的方法，<a class="ae ky" href="https://github.com/square/certstrap" rel="noopener ugc nofollow" target="_blank"> certstrap </a>和<a class="ae ky" href="https://github.com/OpenVPN/easy-rsa" rel="noopener ugc nofollow" target="_blank"> Easy-RSA </a>。</p><p id="25ee" class="pw-post-body-paragraph ly lz it ma b mb mv ju md me mw jx mg mh mx mj mk ml my mn mo mp mz mr ms mt im bi translated">使用证书的权威命令行工具叫做<code class="fe oa ob oc od b">openssl</code>。它可以用来创建ca、RAs和证书，以及做许多其他有用的事情(更多细节请参见下面的参考资料部分)。它还可以用来创建所谓的<em class="mu">自签名证书</em>。<a class="ae ky" href="https://linuxize.com/post/creating-a-self-signed-ssl-certificate/" rel="noopener ugc nofollow" target="_blank">创建一个自签名SSL证书</a>是一个很好的资源，可以教你如何做这件事。虽然它面向Linux，但在Windows和Mac机器上也有不同版本的<code class="fe oa ob oc od b">openssl</code>。我推荐安装<code class="fe oa ob oc od b">openssl</code>的自由叉。这背后的原因在<a class="ae ky" href="https://security.stackexchange.com/questions/112545/what-are-the-main-advantages-of-using-libressl-in-favor-of-openssl" rel="noopener ugc nofollow" target="_blank">堆栈交换问题/答案</a>中有很好的描述。要验证您是否有Libre <code class="fe oa ob oc od b">openssl</code>，请运行以下命令:</p><p id="1fc1" class="pw-post-body-paragraph ly lz it ma b mb mv ju md me mw jx mg mh mx mj mk ml my mn mo mp mz mr ms mt im bi translated"><code class="fe oa ob oc od b">$ openssl version<br/>LibreSSL 2.8.3</code></p><p id="8d6f" class="pw-post-body-paragraph ly lz it ma b mb mv ju md me mw jx mg mh mx mj mk ml my mn mo mp mz mr ms mt im bi translated">类似上面的输出表明Libre <code class="fe oa ob oc od b">openssl</code>正在被使用。</p><p id="ac83" class="pw-post-body-paragraph ly lz it ma b mb mv ju md me mw jx mg mh mx mj mk ml my mn mo mp mz mr ms mt im bi translated">在证书生成过程中将会创建几个文件，其中一些带有<code class="fe oa ob oc od b">.crt</code>和<code class="fe oa ob oc od b">.key</code>就足够了。在阅读有关证书的内容时，您可能还会看到后缀<code class="fe oa ob oc od b">.pem</code>。值得注意的是，<code class="fe oa ob oc od b">.pem</code>文件相当于<code class="fe oa ob oc od b">.crt</code>和<code class="fe oa ob oc od b">.key</code>文件。PEM是一种文件格式。<code class="fe oa ob oc od b">.crt</code>和<code class="fe oa ob oc od b">.key</code>是关于文件包含什么(证书和密钥)的提示，但是这些文件都使用PEM格式。请参见<a class="ae ky" href="https://stackoverflow.com/questions/62823792/how-to-get-crt-and-key-from-cert-pem-and-key-pem" rel="noopener ugc nofollow" target="_blank">堆栈溢出讨论</a>了解更多详情。</p></div><div class="ab cl kz la hx lb" role="separator"><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le"/></div><div class="im in io ip iq"><h1 id="2c18" class="lg lh it bd li lj lk ll lm ln lo lp lq jz lr ka ls kc lt kd lu kf lv kg lw lx bi translated">安装软件以创建CA和证书</h1><p id="d6a7" class="pw-post-body-paragraph ly lz it ma b mb mc ju md me mf jx mg mh mi mj mk ml mm mn mo mp mq mr ms mt im bi translated">如上所述，至少有两种方法可以轻松创建CA和CA的注册证书。本文使用certstrap的原因仅仅是因为它是用Go编写的。然而，Easy-Rsa是一个很好的选择。</p><p id="795c" class="pw-post-body-paragraph ly lz it ma b mb mv ju md me mw jx mg mh mx mj mk ml my mn mo mp mz mr ms mt im bi translated">开始之前，从GitHub上的<a class="ae ky" href="https://github.com/square/certstrap/releases" rel="noopener ugc nofollow" target="_blank"> certstrap releases </a>页面下载适当的可执行文件。我把我的放在我的路径下的目录中。您还需要使它可执行(<code class="fe oa ob oc od b">chmod +x &lt;downloadedfilename&gt;</code>)。</p><p id="bf4f" class="pw-post-body-paragraph ly lz it ma b mb mv ju md me mw jx mg mh mx mj mk ml my mn mo mp mz mr ms mt im bi translated">我们将遵循项目自述文件中的<a class="ae ky" href="https://github.com/square/certstrap" rel="noopener ugc nofollow" target="_blank">使用说明</a>。在本节结束时，我们将创建一个CA、一个服务器证书和一个客户端证书。我将所有证书保存在一个名为<code class="fe oa ob oc od b">~/certs</code>的目录中。以下所有命令都将从该目录运行。当提示输入密码短语时，只需按enter键(即没有密码短语)。</p></div><div class="ab cl kz la hx lb" role="separator"><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le"/></div><div class="im in io ip iq"><h1 id="f550" class="lg lh it bd li lj lk ll lm ln lo lp lq jz lr ka ls kc lt kd lu kf lv kg lw lx bi translated">创建CA</h1><pre class="kj kk kl km gt oe od of og aw oh bi"><span id="a887" class="no lh it od b gy oi oj l ok ol">~/certs certstrap init --common-name "ExampleCA"         <br/>Enter passphrase (empty for no passphrase):<br/>Enter same passphrase again:<br/>Created out/ExampleCA.key<br/>Created out/ExampleCA.crt<br/>Created out/ExampleCA.crl</span></pre><p id="f01d" class="pw-post-body-paragraph ly lz it ma b mb mv ju md me mw jx mg mh mx mj mk ml my mn mo mp mz mr ms mt im bi translated"><code class="fe oa ob oc od b">init</code>指示certstrap创建新的CA。<code class="fe oa ob oc od b">--common-name</code> (CN)为我们的CA指定名称，命名为<em class="mu"> ExampleCA </em>。创建了三个文件:</p><ul class=""><li id="c04a" class="na nb it ma b mb mv me mw mh nc ml nd mp ne mt nf ng nh ni bi translated"><code class="fe oa ob oc od b">ExampleCA.key</code>是<em class="mu">示例CA </em>的私钥</li><li id="091c" class="na nb it ma b mb nj me nk mh nl ml nm mp nn mt nf ng nh ni bi translated"><code class="fe oa ob oc od b">ExampleCA.crt</code>是<em class="mu">例CA </em>的证明</li><li id="6d80" class="na nb it ma b mb nj me nk mh nl ml nm mp nn mt nf ng nh ni bi translated"><code class="fe oa ob oc od b">ExampleCA.crl</code>是该CA的证书吊销列表(CRL)。它包含由相关CA颁发的已吊销证书的列表。</li></ul><p id="791d" class="pw-post-body-paragraph ly lz it ma b mb mv ju md me mw jx mg mh mx mj mk ml my mn mo mp mz mr ms mt im bi translated">一个<em class="mu">通用名</em>或CN通常是与证书相关联的主机的完全合格的域名(FQDN)。</p><p id="2ec8" class="pw-post-body-paragraph ly lz it ma b mb mv ju md me mw jx mg mh mx mj mk ml my mn mo mp mz mr ms mt im bi translated">有关证书撤销列表的信息，请参见<a class="ae ky" href="https://jamielinux.com/docs/openssl-certificate-authority/certificate-revocation-lists.html" rel="noopener ugc nofollow" target="_blank">该来源</a>。</p></div><div class="ab cl kz la hx lb" role="separator"><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le"/></div><div class="im in io ip iq"><h1 id="3e53" class="lg lh it bd li lj lk ll lm ln lo lp lq jz lr ka ls kc lt kd lu kf lv kg lw lx bi translated">为客户端和服务器创建证书</h1><pre class="kj kk kl km gt oe od of og aw oh bi"><span id="d4fe" class="no lh it od b gy oi oj l ok ol">~/certs certstrap request-cert --domain  "localhost"       <br/>Enter passphrase (empty for no passphrase):<br/>Enter same passphrase again:<br/>Created out/localhost.key<br/>Created out/localhost.csr</span><span id="452b" class="no lh it od b gy om oj l ok ol">~/certs certstrap request-cert --domain  "client"<br/>Enter passphrase (empty for no passphrase):<br/>Enter same passphrase again:<br/>Created out/client.key<br/>Created out/client.csr</span></pre><p id="09fa" class="pw-post-body-paragraph ly lz it ma b mb mv ju md me mw jx mg mh mx mj mk ml my mn mo mp mz mr ms mt im bi translated"><code class="fe oa ob oc od b">localhost</code>用作服务器的域，因为如上所述，服务器需要主机的有效FQDN。<code class="fe oa ob oc od b">localhost</code>足以达到这个目的。除了证书签名请求(CSR)和证书本身中的CN之外，使用<code class="fe oa ob oc od b">--domain</code>标志将创建一个<em class="mu">主题替代名称</em> (SAN)。San是指定许多服务寻址方法的当前标准，包括通过FQDN或域名。</p><p id="0a7d" class="pw-post-body-paragraph ly lz it ma b mb mv ju md me mw jx mg mh mx mj mk ml my mn mo mp mz mr ms mt im bi translated">还有一个<code class="fe oa ob oc od b">--domain</code>的替代品，那就是<code class="fe oa ob oc od b">--common-name</code>。我们使用<code class="fe oa ob oc od b">--common-name</code>来创建上面的CA。<code class="fe oa ob oc od b">--common-name</code>只会生成一个CN。从Go 1.15开始，证书必须包含SAN条目，否则https请求将失败。只有CN的证书将不被接受。如果使用Go 1.15或更高版本，并且使用<code class="fe oa ob oc od b">--common-name</code>来生成CSR，您可能会从客户端看到以下错误:</p><pre class="kj kk kl km gt oe od of og aw oh bi"><span id="e46f" class="no lh it od b gy oi oj l ok ol">Get "https://localhost": x509: certificate relies on legacy Common Name field, use SANs or temporarily enable Common Name matching with GODEBUG=x509ignoreCN=0</span></pre><p id="f3dc" class="pw-post-body-paragraph ly lz it ma b mb mv ju md me mw jx mg mh mx mj mk ml my mn mo mp mz mr ms mt im bi translated">如错误消息中所述，这个问题可以通过在客户端命令前面加上<code class="fe oa ob oc od b">GODEBUG=x509ignoreCN=0</code>来解决。</p></div><div class="ab cl kz la hx lb" role="separator"><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le"/></div><div class="im in io ip iq"><h1 id="433c" class="lg lh it bd li lj lk ll lm ln lo lp lq jz lr ka ls kc lt kd lu kf lv kg lw lx bi translated">签署客户端和服务器的证书</h1><pre class="kj kk kl km gt oe od of og aw oh bi"><span id="2347" class="no lh it od b gy oi oj l ok ol">~/certs certstrap sign localhost --CA ExampleCA  <br/>Created out/localhost.crt from out/localhost.csr signed by out/ExampleCA.key</span><span id="f367" class="no lh it od b gy om oj l ok ol">~/certs certstrap sign client --CA ExampleCA   <br/>Created out/client.crt from out/client.csr signed by out/ExampleCA.key</span></pre><p id="05a5" class="pw-post-body-paragraph ly lz it ma b mb mv ju md me mw jx mg mh mx mj mk ml my mn mo mp mz mr ms mt im bi translated">请注意，所有证书和相关密钥都放在了<code class="fe oa ob oc od b">./out</code>目录中。</p><p id="e683" class="pw-post-body-paragraph ly lz it ma b mb mv ju md me mw jx mg mh mx mj mk ml my mn mo mp mz mr ms mt im bi translated">证书必须由可信机构(在本例中为CA)签名才能生效。签名是CA对证书所有者身份的保证。上面的<code class="fe oa ob oc od b">--CA</code>标志指示certstrap让我们的<code class="fe oa ob oc od b">ExampleCA</code>签署证书。</p><p id="6bf7" class="pw-post-body-paragraph ly lz it ma b mb mv ju md me mw jx mg mh mx mj mk ml my mn mo mp mz mr ms mt im bi translated">此时，我们有了CA、客户机和服务器的证书和密钥。</p></div><div class="ab cl kz la hx lb" role="separator"><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le"/></div><div class="im in io ip iq"><h1 id="5dbd" class="lg lh it bd li lj lk ll lm ln lo lp lq jz lr ka ls kc lt kd lu kf lv kg lw lx bi translated">编写客户端和服务器</h1><p id="8110" class="pw-post-body-paragraph ly lz it ma b mb mc ju md me mf jx mg mh mi mj mk ml mm mn mo mp mq mr ms mt im bi translated">本文中的所有代码都可以在GitHub的我的<a class="ae ky" href="https://github.com/youngkin/gohttps" rel="noopener ugc nofollow" target="_blank"> gohttps </a>资源库中获得。</p><p id="bf52" class="pw-post-body-paragraph ly lz it ma b mb mv ju md me mw jx mg mh mx mj mk ml my mn mo mp mz mr ms mt im bi translated">我们将编写一个简单的服务器和一个更高级的服务器，前者不验证客户机的证书，后者在验证客户机的证书时有多种选择。最后，我们将开发一个可以与两台服务器对话的客户机。</p><p id="4562" class="pw-post-body-paragraph ly lz it ma b mb mv ju md me mw jx mg mh mx mj mk ml my mn mo mp mz mr ms mt im bi translated">在继续之前，我们需要简要讨论一下HTTPS是如何实现的。HTTPS流量由TLS层加密。TLS是SSL的后继者，工作在TCP/IP之上。它做了许多事情，包括:</p><ul class=""><li id="30fd" class="na nb it ma b mb mv me mw mh nc ml nd mp ne mt nf ng nh ni bi translated">协商TLS会话。这包括协商要使用的TLS版本和加密套件。</li><li id="11eb" class="na nb it ma b mb nj me nk mh nl ml nm mp nn mt nf ng nh ni bi translated">验证服务器的身份</li><li id="eff8" class="na nb it ma b mb nj me nk mh nl ml nm mp nn mt nf ng nh ni bi translated">如果需要，验证客户端的身份</li><li id="394b" class="na nb it ma b mb nj me nk mh nl ml nm mp nn mt nf ng nh ni bi translated">处理所有流量加密</li></ul><p id="9e7a" class="pw-post-body-paragraph ly lz it ma b mb mv ju md me mw jx mg mh mx mj mk ml my mn mo mp mz mr ms mt im bi translated">Go的HTTP包包括一个TLS配置结构，用于实现客户机和服务器的HTTPS通信期望。这将是以下小节的重点。</p><p id="4c78" class="pw-post-body-paragraph ly lz it ma b mb mv ju md me mw jx mg mh mx mj mk ml my mn mo mp mz mr ms mt im bi translated">TLS需要可靠的传输机制。TCP和UDP是两个选择，但是UDP不靠谱。参见<a class="ae ky" href="https://security.stackexchange.com/questions/170833/why-does-tls-require-tcp" rel="noopener ugc nofollow" target="_blank">为什么TLS需要TCP </a>了解更多关于这个主题的讨论。</p></div><div class="ab cl kz la hx lb" role="separator"><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le"/></div><div class="im in io ip iq"><h1 id="02fe" class="lg lh it bd li lj lk ll lm ln lo lp lq jz lr ka ls kc lt kd lu kf lv kg lw lx bi translated">简单的服务器</h1><p id="91de" class="pw-post-body-paragraph ly lz it ma b mb mc ju md me mf jx mg mh mi mj mk ml mm mn mo mp mq mr ms mt im bi translated">简单服务器的完整实现见<a class="ae ky" href="https://github.com/youngkin/gohttps/blob/master/simpleserver/server.go" rel="noopener ugc nofollow" target="_blank"> GitHub </a>。</p><p id="70c7" class="pw-post-body-paragraph ly lz it ma b mb mv ju md me mw jx mg mh mx mj mk ml my mn mo mp mz mr ms mt im bi translated">客户端和服务器之间最简单的HTTPS交互是客户端验证服务器的凭证，所有流量都被加密。客户端只需要访问签署服务器证书的CA的证书。服务器既不知道也不关心客户端的身份。这是一个非常常见的用例。</p><p id="597d" class="pw-post-body-paragraph ly lz it ma b mb mv ju md me mw jx mg mh mx mj mk ml my mn mo mp mz mr ms mt im bi translated">下面是一个非常简单的HTTPS服务器的实现的分解。首先要做的是创建和配置<code class="fe oa ob oc od b">http.Server</code>结构:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="on oo l"/></div></figure><p id="d623" class="pw-post-body-paragraph ly lz it ma b mb mv ju md me mw jx mg mh mx mj mk ml my mn mo mp mz mr ms mt im bi translated"><code class="fe oa ob oc od b">Addr</code>简单地指定服务器的监听地址。<code class="fe oa ob oc od b">ReadTimeout</code>和<code class="fe oa ob oc od b">WriteTimeout</code>分别设置读取和写入的超时。如注释所示，<code class="fe oa ob oc od b">ReadTimeout</code>设置为五分钟，以便有时间输入机器的用户密码。当使用<code class="fe oa ob oc od b">curl</code>并且证书有密码保护时，OSx有时会提示这一点。在本文中，没有一个证书受密码保护。</p><p id="40b7" class="pw-post-body-paragraph ly lz it ma b mb mv ju md me mw jx mg mh mx mj mk ml my mn mo mp mz mr ms mt im bi translated">严格地说，像这样的简单服务器不需要超时字段。也就是说，健壮的服务器将包含它们。更多详细信息，请参见<a class="ae ky" href="https://blog.cloudflare.com/the-complete-guide-to-golang-net-http-timeouts/" rel="noopener ugc nofollow" target="_blank">完整的Go net/http超时指南</a>。</p><p id="d288" class="pw-post-body-paragraph ly lz it ma b mb mv ju md me mw jx mg mh mx mj mk ml my mn mo mp mz mr ms mt im bi translated">在本文的上下文中，<code class="fe oa ob oc od b">TLSConfig</code>是<code class="fe oa ob oc od b">Server</code>结构中最有趣的字段。这是配置所有TLS选项的地方。在这种情况下，只需要<code class="fe oa ob oc od b">ServerName</code>。<code class="fe oa ob oc od b">ServerName</code>必须与服务器证书中的主机名匹配。</p><p id="c86f" class="pw-post-body-paragraph ly lz it ma b mb mv ju md me mw jx mg mh mx mj mk ml my mn mo mp mz mr ms mt im bi translated">服务器需要一个处理函数:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="on oo l"/></div></figure><p id="d4bb" class="pw-post-body-paragraph ly lz it ma b mb mv ju md me mw jx mg mh mx mj mk ml my mn mo mp mz mr ms mt im bi translated">这个处理函数没有太多内容；它只提供普通的“你好，世界！”回应。</p><p id="c91c" class="pw-post-body-paragraph ly lz it ma b mb mv ju md me mw jx mg mh mx mj mk ml my mn mo mp mz mr ms mt im bi translated">最后一步是服务器开始监听请求:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="on oo l"/></div></figure><p id="bfc1" class="pw-post-body-paragraph ly lz it ma b mb mv ju md me mw jx mg mh mx mj mk ml my mn mo mp mz mr ms mt im bi translated">HTTPS服务器使用<code class="fe oa ob oc od b">ListenAndServeTLS()</code>，而不是HTTP服务器中的<code class="fe oa ob oc od b">ListenAndServe()</code>调用。<code class="fe oa ob oc od b">*serverCert</code>和<code class="fe oa ob oc od b">*srvKey</code>分别是服务器的证书和私钥文件。包含这些文件的文件名在命令行中传递(下面将详细介绍)。您可能还记得，<code class="fe oa ob oc od b">localhost.crt</code>和<code class="fe oa ob oc od b">localhost.key</code>是我们为服务器创建的证书和密钥文件。</p></div><div class="ab cl kz la hx lb" role="separator"><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le"/></div><div class="im in io ip iq"><h1 id="807d" class="lg lh it bd li lj lk ll lm ln lo lp lq jz lr ka ls kc lt kd lu kf lv kg lw lx bi translated">更先进的服务器</h1><p id="1b02" class="pw-post-body-paragraph ly lz it ma b mb mc ju md me mf jx mg mh mi mj mk ml mm mn mo mp mq mr ms mt im bi translated">参见<a class="ae ky" href="https://github.com/youngkin/gohttps/blob/master/advserver/server.go" rel="noopener ugc nofollow" target="_blank"> GitHub </a>了解这个更先进的服务器的完整实现。</p><p id="2087" class="pw-post-body-paragraph ly lz it ma b mb mv ju md me mw jx mg mh mx mj mk ml my mn mo mp mz mr ms mt im bi translated">上面的简单服务器和更安全的服务器之间的主要区别是增加了要求或要求和验证客户端证书的功能。</p><p id="8356" class="pw-post-body-paragraph ly lz it ma b mb mv ju md me mw jx mg mh mx mj mk ml my mn mo mp mz mr ms mt im bi translated">和以前一样，需要一个<code class="fe oa ob oc od b">http.Server</code>结构:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="on oo l"/></div></figure><p id="0a68" class="pw-post-body-paragraph ly lz it ma b mb mv ju md me mw jx mg mh mx mj mk ml my mn mo mp mz mr ms mt im bi translated">注意，在这个版本中，<code class="fe oa ob oc od b">TLSConfig</code>字段是由函数<code class="fe oa ob oc od b">getTLSConfig()</code>配置的。这个<code class="fe oa ob oc od b">TLSConfig</code>比简单的服务器案例要多一点。下面是该函数的代码:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="on oo l"/></div></figure><p id="4aab" class="pw-post-body-paragraph ly lz it ma b mb mv ju md me mw jx mg mh mx mj mk ml my mn mo mp mz mr ms mt im bi translated">让我们把它分成几部分。首先，我们来看看函数签名。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="on oo l"/></div></figure><p id="22bb" class="pw-post-body-paragraph ly lz it ma b mb mv ju md me mw jx mg mh mx mj mk ml my mn mo mp mz mr ms mt im bi translated">论据如下:</p><ol class=""><li id="425f" class="na nb it ma b mb mv me mw mh nc ml nd mp ne mt op ng nh ni bi translated"><code class="fe oa ob oc od b">host</code> —这是服务器的主机名。它必须与主机证书中提供的名称相匹配。在我们的例子中，这是SAN。</li><li id="6cd2" class="na nb it ma b mb nj me nk mh nl ml nm mp nn mt op ng nh ni bi translated"><code class="fe oa ob oc od b">caCertFile</code> —这是签署客户端证书的CA的证书文件名，在本例中为<code class="fe oa ob oc od b">ExampleCA.crt</code>。此服务器中需要CA的证书，因为我们创建了一个未知的CA，即不是通常在操作系统中配置的CA(例如，OSx中的KeyChain)。所以这里需要补充一下。</li><li id="e9db" class="na nb it ma b mb nj me nk mh nl ml nm mp nn mt op ng nh ni bi translated"><code class="fe oa ob oc od b">certopt</code> —可以看到，这是<code class="fe oa ob oc od b">tls.ClientAuthType</code>类型。有五种授权类型用于授权/验证客户端证书:</li></ol><ul class=""><li id="83b5" class="na nb it ma b mb mv me mw mh nc ml nd mp ne mt nf ng nh ni bi translated"><code class="fe oa ob oc od b">tls.NoClientCert </code> —不要求也不需要客户端证书。这是默认值。</li><li id="dd62" class="na nb it ma b mb nj me nk mh nl ml nm mp nn mt nf ng nh ni bi translated"><code class="fe oa ob oc od b">tls.RequestClientCert</code> —将请求客户端证书，但这不是必需的，也不会被验证。</li><li id="fb0d" class="na nb it ma b mb nj me nk mh nl ml nm mp nn mt nf ng nh ni bi translated"><code class="fe oa ob oc od b">tls.RequireAnyClientCert</code> —需要客户端证书，但任何有效的客户端证书都是可以接受的。它不会根据CA的证书进行验证。</li><li id="6440" class="na nb it ma b mb nj me nk mh nl ml nm mp nn mt nf ng nh ni bi translated"><code class="fe oa ob oc od b">tls.VerifyClientCertIfGiven</code> —不会请求客户端证书，但如果存在，将根据CA的证书进行验证。</li><li id="3c8f" class="na nb it ma b mb nj me nk mh nl ml nm mp nn mt nf ng nh ni bi translated"><code class="fe oa ob oc od b">tls.RequireAndVerifyClientCert</code> —将需要客户端证书，并将根据CA的证书进行验证。</li></ul><p id="c32f" class="pw-post-body-paragraph ly lz it ma b mb mv ju md me mw jx mg mh mx mj mk ml my mn mo mp mz mr ms mt im bi translated">现在我们知道了函数的参数是什么，让我们来看看函数体:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="on oo l"/></div></figure><ul class=""><li id="45ea" class="na nb it ma b mb mv me mw mh nc ml nd mp ne mt nf ng nh ni bi translated">第3行—我们定义了一个<code class="fe oa ob oc od b">x509.CertPool</code>。这是一个将在下面使用的证书池。它将包含签署客户端证书的CA的证书。</li><li id="e50f" class="na nb it ma b mb nj me nk mh nl ml nm mp nn mt nf ng nh ni bi translated">第4行—我们检查<code class="fe oa ob oc od b">certOp</code>的值。任何大于<code class="fe oa ob oc od b">tls.RequestClientCert</code>的值都需要客户提供证书。</li><li id="539b" class="na nb it ma b mb nj me nk mh nl ml nm mp nn mt nf ng nh ni bi translated">第5–8行—为了验证客户端证书，需要将CA证书加载到<code class="fe oa ob oc od b">caCertPool</code>中。这些行读取CA证书文件并处理任何错误。</li><li id="a952" class="na nb it ma b mb nj me nk mh nl ml nm mp nn mt nf ng nh ni bi translated">第9 -10行—我们创建一个新的<code class="fe oa ob oc od b">x509.CertPool</code>并将CA的证书添加到池中。</li><li id="ac46" class="na nb it ma b mb nj me nk mh nl ml nm mp nn mt nf ng nh ni bi translated">第15行—<code class="fe oa ob oc od b">ClientAuth</code>字段用于指定所需的客户端证书授权和验证的级别。数值和定义已在上文关于<code class="fe oa ob oc od b">certOpt</code>的讨论中给出。</li><li id="7060" class="na nb it ma b mb nj me nk mh nl ml nm mp nn mt nf ng nh ni bi translated">第16行—<code class="fe oa ob oc od b">ClientCAs</code>字段用于指定将用于验证客户端证书的ca。它的值是从第9行和第10行创建的<code class="fe oa ob oc od b">caCertPool</code>中设置的。该字段的GoDoc包含以下内容:"<code class="fe oa ob oc od b">ClientCA</code> s定义了根证书授权机构的集合，如果<code class="fe oa ob oc od b">ClientAuth</code>中的策略要求验证客户端证书，服务器将使用该集合。"</li><li id="f2da" class="na nb it ma b mb nj me nk mh nl ml nm mp nn mt nf ng nh ni bi translated">第17行— <code class="fe oa ob oc od b">MinVersion</code>设置与客户协商版本时可接受的最低TLS版本。低于1.2的TLS版本被认为是不安全的。详见<a class="ae ky" href="https://www.rfc-editor.org/rfc/rfc7525.txt" rel="noopener ugc nofollow" target="_blank"> RFC 7525 </a>。</li></ul></div><div class="ab cl kz la hx lb" role="separator"><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le"/></div><div class="im in io ip iq"><h1 id="5b6c" class="lg lh it bd li lj lk ll lm ln lo lp lq jz lr ka ls kc lt kd lu kf lv kg lw lx bi translated">创建客户端</h1><p id="ab8f" class="pw-post-body-paragraph ly lz it ma b mb mc ju md me mf jx mg mh mi mj mk ml mm mn mo mp mq mr ms mt im bi translated">该客户端的完整实现见<a class="ae ky" href="https://github.com/youngkin/gohttps/blob/master/client/client.go" rel="noopener ugc nofollow" target="_blank"> GitHub </a>。</p><p id="4d20" class="pw-post-body-paragraph ly lz it ma b mb mv ju md me mw jx mg mh mx mj mk ml my mn mo mp mz mr ms mt im bi translated">如前所述，该客户端可以成功地与简单服务器或高级服务器进行通信。让我们来看看重要的代码。</p><p id="bef6" class="pw-post-body-paragraph ly lz it ma b mb mv ju md me mw jx mg mh mx mj mk ml my mn mo mp mz mr ms mt im bi translated">首先要做的是配置客户端的证书和密钥，如果有的话。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="on oo l"/></div></figure><p id="e056" class="pw-post-body-paragraph ly lz it ma b mb mv ju md me mw jx mg mh mx mj mk ml my mn mo mp mz mr ms mt im bi translated">如果提供了，代码将从客户端的证书和私钥创建一个<code class="fe oa ob oc od b">x509</code>密钥对。此密钥对将在协商TLS连接时使用，并用于加密和解密客户端和服务器之间的通信。</p><p id="817e" class="pw-post-body-paragraph ly lz it ma b mb mv ju md me mw jx mg mh mx mj mk ml my mn mo mp mz mr ms mt im bi translated">接下来，与高级服务器一样，我们将创建一个证书池，其中包含签名的CA的证书，在本例中是服务器的证书。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="on oo l"/></div></figure><p id="6eaf" class="pw-post-body-paragraph ly lz it ma b mb mv ju md me mw jx mg mh mx mj mk ml my mn mo mp mz mr ms mt im bi translated">然后，我们用客户机的证书/密钥对和包含CA的证书池创建一个<code class="fe oa ob oc od b">http.Transport</code>。这个<code class="fe oa ob oc od b">http.Transport</code>将用于配置<code class="fe oa ob oc od b">http.Client</code>。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="on oo l"/></div></figure><p id="a2c6" class="pw-post-body-paragraph ly lz it ma b mb mv ju md me mw jx mg mh mx mj mk ml my mn mo mp mz mr ms mt im bi translated"><code class="fe oa ob oc od b">http.Transport</code>包含一个<code class="fe oa ob oc od b">tls.Config</code>。与服务器一样，<code class="fe oa ob oc od b">Certificates</code>字段由客户端的证书填充。这里有一个新字段，即<code class="fe oa ob oc od b">RootCAs</code>字段。GoDoc对该字段描述如下:"<code class="fe oa ob oc od b">RootCAs</code>定义了客户端在验证服务器证书时使用的一组根证书颁发机构。如果<code class="fe oa ob oc od b">RootCAs</code>为<code class="fe oa ob oc od b">nil</code>，TLS使用主机的根CA集。”</p><p id="1a9a" class="pw-post-body-paragraph ly lz it ma b mb mv ju md me mw jx mg mh mx mj mk ml my mn mo mp mz mr ms mt im bi translated">这是准备客户机与HTTPS服务器交互所需要做的一切。剩下的代码准备和发送请求，并处理响应。</p></div><div class="ab cl kz la hx lb" role="separator"><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le"/></div><div class="im in io ip iq"><h1 id="ba7c" class="lg lh it bd li lj lk ll lm ln lo lp lq jz lr ka ls kc lt kd lu kf lv kg lw lx bi translated">把所有的放在一起</h1><p id="a960" class="pw-post-body-paragraph ly lz it ma b mb mc ju md me mf jx mg mh mi mj mk ml mm mn mo mp mq mr ms mt im bi translated">如果您已经克隆或派生了<a class="ae ky" href="https://github.com/youngkin/gohttps" rel="noopener ugc nofollow" target="_blank"> gohttps </a>存储库，您会注意到它具有以下目录结构:</p><pre class="kj kk kl km gt oe od of og aw oh bi"><span id="343e" class="no lh it od b gy oi oj l ok ol">gohttps+<br/>       |<br/>       +- advserver<br/>       +- client<br/>       +- simpleserver</span></pre><p id="8346" class="pw-post-body-paragraph ly lz it ma b mb mv ju md me mw jx mg mh mx mj mk ml my mn mo mp mz mr ms mt im bi translated">客户机和每个服务器的源文件都在各自的目录中。程序可以从这些目录中构建和运行。</p><p id="fa0b" class="pw-post-body-paragraph ly lz it ma b mb mv ju md me mw jx mg mh mx mj mk ml my mn mo mp mz mr ms mt im bi translated">下面命令行中引用的证书和密钥与上面的<strong class="ma iu">创建证书和密钥</strong>部分中生成的名称相匹配。</p></div><div class="ab cl kz la hx lb" role="separator"><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le"/></div><div class="im in io ip iq"><h1 id="c527" class="lg lh it bd li lj lk ll lm ln lo lp lq jz lr ka ls kc lt kd lu kf lv kg lw lx bi translated">启动服务器</h1><h2 id="9a55" class="no lh it bd li np nq dn lm nr ns dp lq mh nt nu ls ml nv nw lu mp nx ny lw nz bi translated">简单的服务器命令行(没有客户端验证)</h2><pre class="kj kk kl km gt oe od of og aw oh bi"><span id="45cb" class="no lh it od b gy oi oj l ok ol">./simpleserver -host "localhost" -srvcert "/path/to/localhost.crt" -srvkey "/path/to/localhost.key"</span></pre><h2 id="9512" class="no lh it bd li np nq dn lm nr ns dp lq mh nt nu ls ml nv nw lu mp nx ny lw nz bi translated">具有完全客户端证书验证的高级服务器命令行(<code class="fe oa ob oc od b">-certopt 4</code>)。</h2><pre class="kj kk kl km gt oe od of og aw oh bi"><span id="1651" class="no lh it od b gy oi oj l ok ol">./advserver -host "localhost" -srvcert "/path/to/localhost.crt" -cacert "/path/to/ExampleCA.crt" -srvkey "/path/to/localhost.key" -port 443 -certopt 4</span></pre></div><div class="ab cl kz la hx lb" role="separator"><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le"/></div><div class="im in io ip iq"><h1 id="1e80" class="lg lh it bd li lj lk ll lm ln lo lp lq jz lr ka ls kc lt kd lu kf lv kg lw lx bi translated">运行客户端</h1><h2 id="1da3" class="no lh it bd li np nq dn lm nr ns dp lq mh nt nu ls ml nv nw lu mp nx ny lw nz bi translated">使用<code class="fe oa ob oc od b">curl</code></h2><p id="2171" class="pw-post-body-paragraph ly lz it ma b mb mc ju md me mf jx mg mh mi mj mk ml mm mn mo mp mq mr ms mt im bi translated"><code class="fe oa ob oc od b">curl</code>无客户端证书验证的请求:</p><pre class="kj kk kl km gt oe od of og aw oh bi"><span id="c0a2" class="no lh it od b gy oi oj l ok ol">curl -vi -d "World" --cacert /path/to/ExampleCA.crt <a class="ae ky" href="https://localhost" rel="noopener ugc nofollow" target="_blank">https://localhost</a></span></pre><p id="5223" class="pw-post-body-paragraph ly lz it ma b mb mv ju md me mw jx mg mh mx mj mk ml my mn mo mp mz mr ms mt im bi translated"><code class="fe oa ob oc od b">curl</code>使用完全客户端证书验证的请求:</p><pre class="kj kk kl km gt oe od of og aw oh bi"><span id="9a03" class="no lh it od b gy oi oj l ok ol">curl -d "World" -vi --cert /path/to/client.crt  --key /path/to/client.key --cacert ./out/ExampleCA.crt <a class="ae ky" href="https://localhost" rel="noopener ugc nofollow" target="_blank">https://localhost</a></span></pre><h2 id="432c" class="no lh it bd li np nq dn lm nr ns dp lq mh nt nu ls ml nv nw lu mp nx ny lw nz bi translated">使用客户端程序</h2><p id="fc95" class="pw-post-body-paragraph ly lz it ma b mb mc ju md me mf jx mg mh mi mj mk ml mm mn mo mp mq mr ms mt im bi translated">服务器进行完全客户端证书验证的命令行:</p><pre class="kj kk kl km gt oe od of og aw oh bi"><span id="3cda" class="no lh it od b gy oi oj l ok ol">./client -clientcert "/path/to/client.crt" -clientkey "/path/to/client.key" -cacert "/path/to/ExampleCA.crt"</span></pre><p id="93c0" class="pw-post-body-paragraph ly lz it ma b mb mv ju md me mw jx mg mh mx mj mk ml my mn mo mp mz mr ms mt im bi translated">服务器不验证客户端证书的命令行:</p><pre class="kj kk kl km gt oe od of og aw oh bi"><span id="8009" class="no lh it od b gy oi oj l ok ol">./client -cacert "/path/to/ExampleCA.crt"</span></pre><p id="7534" class="pw-post-body-paragraph ly lz it ma b mb mv ju md me mw jx mg mh mx mj mk ml my mn mo mp mz mr ms mt im bi translated">如上面创建证书一节所述，如果客户端和服务器证书不是用<code class="fe oa ob oc od b">--domain</code>标志创建的，您可能会看到以下错误:</p><pre class="kj kk kl km gt oe od of og aw oh bi"><span id="191d" class="no lh it od b gy oi oj l ok ol">Get "https://localhost": x509: certificate relies on legacy Common Name field, use SANs or temporarily enable Common Name matching with GODEBUG=x509ignoreCN=0</span></pre><p id="c219" class="pw-post-body-paragraph ly lz it ma b mb mv ju md me mw jx mg mh mx mj mk ml my mn mo mp mz mr ms mt im bi translated">在前面的命令前加上<code class="fe oa ob oc od b">GODEBUG=x509ignoreCN=0</code>将会解决这个错误。有关如何避免此问题的更多详细信息，请参见创建证书一节。</p></div><div class="ab cl kz la hx lb" role="separator"><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le"/></div><div class="im in io ip iq"><h1 id="afa8" class="lg lh it bd li lj lk ll lm ln lo lp lq jz lr ka ls kc lt kd lu kf lv kg lw lx bi translated">结论</h1><p id="f1c5" class="pw-post-body-paragraph ly lz it ma b mb mc ju md me mf jx mg mh mi mj mk ml mm mn mo mp mq mr ms mt im bi translated">感谢跟随。我们在本文中讨论了很多内容，包括:</p><ul class=""><li id="718d" class="na nb it ma b mb mv me mw mh nc ml nd mp ne mt nf ng nh ni bi translated">如果您没有PKI和证书方面的背景，希望您已经学到了足够的知识，可以开始一段旅程来学习更多关于这个主题的知识。</li><li id="ca38" class="na nb it ma b mb nj me nk mh nl ml nm mp nn mt nf ng nh ni bi translated">对可用于处理证书和密钥的不同软件工具的简要描述。对于本文，我们使用了certstrap。</li><li id="ad15" class="na nb it ma b mb nj me nk mh nl ml nm mp nn mt nf ng nh ni bi translated">如何使用certstrap创建CA以及客户端和服务器证书签名请求、证书和密钥</li><li id="29bb" class="na nb it ma b mb nj me nk mh nl ml nm mp nn mt nf ng nh ni bi translated">如何在Go中编写一个简单而更高级的HTTPS服务器，详细介绍细节</li><li id="fe0e" class="na nb it ma b mb nj me nk mh nl ml nm mp nn mt nf ng nh ni bi translated">如何在Go中编写HTTPS客户端，再次详细讨论细节</li><li id="d171" class="na nb it ma b mb nj me nk mh nl ml nm mp nn mt nf ng nh ni bi translated">运行服务器程序，并使用<code class="fe oa ob oc od b">curl</code>和客户端程序访问正在运行的进程</li></ul><p id="3335" class="pw-post-body-paragraph ly lz it ma b mb mv ju md me mw jx mg mh mx mj mk ml my mn mo mp mz mr ms mt im bi translated">您可以随意使用<a class="ae ky" href="https://github.com/youngkin/gohttps" rel="noopener ugc nofollow" target="_blank"> gohttps资源库</a>中的代码进行自己的学习、实验，或者作为创建自己的客户机和服务器的基础。</p></div><div class="ab cl kz la hx lb" role="separator"><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le"/></div><div class="im in io ip iq"><h1 id="9266" class="lg lh it bd li lj lk ll lm ln lo lp lq jz lr ka ls kc lt kd lu kf lv kg lw lx bi translated">参考</h1><ul class=""><li id="f642" class="na nb it ma b mb mc me mf mh oq ml or mp os mt nf ng nh ni bi translated"><a class="ae ky" href="https://github.com/jcbsmpsn/golang-https-example" rel="noopener ugc nofollow" target="_blank">TLS连接选项</a> GitHub项目是快速创建工作的HTTPS客户端和服务器的好资源。当我第一次开始创建HTTPS客户机和服务器时，它是我关于这个主题的主要信息来源。它还涵盖了一些常见问题的解决方案。</li><li id="071e" class="na nb it ma b mb nj me nk mh nl ml nm mp nn mt nf ng nh ni bi translated"><a class="ae ky" href="https://bbengfort.github.io/programmer/2017/03/03/secure-grpc.html" rel="noopener ugc nofollow" target="_blank">使用TLS/SSL保护gRPC</a>—虽然面向gRPC，但基本的TLS基础与HTTPS相同。本文填补了关于如何在Go中配置TLS的一些空白。</li><li id="ce2c" class="na nb it ma b mb nj me nk mh nl ml nm mp nn mt nf ng nh ni bi translated">从HTTP转换到HTTPS的完整指南提供了关于HTTPS背后的技术的几乎所有方面的详细、实用的讨论，如何请求证书，以及如何配置各种web服务器来支持HTTPS。至少值得快速浏览一下，看看是否有什么有趣的东西。</li><li id="01b3" class="na nb it ma b mb nj me nk mh nl ml nm mp nn mt nf ng nh ni bi translated"><a class="ae ky" href="https://en.wikipedia.org/wiki/Public_key_infrastructure" rel="noopener ugc nofollow" target="_blank">公钥基础设施(PKI) </a>是提供安全通信基础的技术和可信组织的混合体。</li><li id="fc6e" class="na nb it ma b mb nj me nk mh nl ml nm mp nn mt nf ng nh ni bi translated"><a class="ae ky" href="https://en.wikipedia.org/wiki/Transport_Layer_Security" rel="noopener ugc nofollow" target="_blank"> TLS </a>是一种加密协议，用于保护互联网上的通信安全。</li><li id="4d12" class="na nb it ma b mb nj me nk mh nl ml nm mp nn mt nf ng nh ni bi translated"><a class="ae ky" href="https://en.wikipedia.org/wiki/HTTPS" rel="noopener ugc nofollow" target="_blank"> HTTPS </a>是HTTP协议的安全实现。</li><li id="cb05" class="na nb it ma b mb nj me nk mh nl ml nm mp nn mt nf ng nh ni bi translated"><a class="ae ky" href="https://jamielinux.com/docs/openssl-certificate-authority/index.html" rel="noopener ugc nofollow" target="_blank">OpenSSL Certificate Authority</a>是一个关于使用<code class="fe oa ob oc od b">openssl</code>创建ca和证书的好资源。</li><li id="f43b" class="na nb it ma b mb nj me nk mh nl ml nm mp nn mt nf ng nh ni bi translated"><a class="ae ky" href="https://linuxize.com/post/creating-a-self-signed-ssl-certificate/" rel="noopener ugc nofollow" target="_blank">创建自签名SSL证书</a>是创建自签名证书的好资源。这些在本文中没有用到，但是知道这样做是可能的，这很好。</li><li id="c131" class="na nb it ma b mb nj me nk mh nl ml nm mp nn mt nf ng nh ni bi translated"><a class="ae ky" href="https://github.com/square/certstrap" rel="noopener ugc nofollow" target="_blank"> Certstrap GitHub回购</a></li><li id="37be" class="na nb it ma b mb nj me nk mh nl ml nm mp nn mt nf ng nh ni bi translated"><a class="ae ky" href="https://github.com/OpenVPN/easy-rsa" rel="noopener ugc nofollow" target="_blank"> Easy-RSA GitHub回购</a></li><li id="b48e" class="na nb it ma b mb nj me nk mh nl ml nm mp nn mt nf ng nh ni bi translated"><a class="ae ky" href="https://geekflare.com/openssl-commands-certificates/" rel="noopener ugc nofollow" target="_blank"> 21个OpenSSL示例帮助你在现实世界中</a>是一个很好的参考，包含常用的<code class="fe oa ob oc od b">openssl</code>命令。</li><li id="c51b" class="na nb it ma b mb nj me nk mh nl ml nm mp nn mt nf ng nh ni bi translated"><a class="ae ky" href="https://www.ssllabs.com/ssltest/index.html" rel="noopener ugc nofollow" target="_blank"> QualSys SSL服务器测试</a>是一个网页，您可以使用它来测试HTTPS对HTTPS服务器的访问，并获得对其实施最佳实践的评估。</li><li id="6391" class="na nb it ma b mb nj me nk mh nl ml nm mp nn mt nf ng nh ni bi translated">Idrix 有一个很好的测试SSL证书的服务。例如:</li></ul><p id="c5cb" class="pw-post-body-paragraph ly lz it ma b mb mv ju md me mw jx mg mh mx mj mk ml my mn mo mp mz mr ms mt im bi translated"><code class="fe oa ob oc od b">curl -vi –cert ./ClientCert.crt –key ./ClientCert.key <a class="ae ky" href="https://prod.idrix.eu/secure/" rel="noopener ugc nofollow" target="_blank">https://prod.idrix.eu/secure/</a></code></p></div></div>    
</body>
</html>