<html>
<head>
<title>Implementing a Web Form on AWS With Bare HTML and JavaScript</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">用裸HTML和JavaScript在AWS上实现Web表单</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/implementing-a-web-form-on-aws-with-bare-html-and-js-5b0a319a702e?source=collection_archive---------9-----------------------#2022-09-07">https://betterprogramming.pub/implementing-a-web-form-on-aws-with-bare-html-and-js-5b0a319a702e?source=collection_archive---------9-----------------------#2022-09-07</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="fbc8" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">有效处理web表单数据</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/3f78c6bc6e2b19170ac2fcf241c7a6e3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*wr020eK9dGXNVPHK"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">照片由<a class="ae ky" href="https://unsplash.com/@fredmarriage?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">弗雷迪婚姻</a>在<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a></p></figure><p id="f574" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">框架无处不在。作为后端开发人员，我总是躲在漂亮ui的阴影下。每次我试图写一个前端，我都会被JS和CSS的框架和库的数量所迷惑。即使当我使用NodeJS作为我的主要工具时，我也只能勉强理解React、Angular、Vue和其他框架的复杂性。当我搬家时，情况变得更糟了。现在，写前端所需的不可计数的依赖项、解释器、构建器等等让我更加害怕。</p><p id="0b84" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">前一段时间，我挑战自己，测试在没有框架的情况下，编写一个基本的web应用程序是否可行。我想创建比一堆静态HTML更复杂的东西，但我也不想让事情过于复杂。最后，我决定构建一个简单的web表单，用户可以在其中提交一些信息，比如一个<em class="lv">“联系我”</em>或<em class="lv">“订阅”</em>表单。</p><p id="e4c0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">Web表单似乎是使用框架的一个很好的用例。客户端需要处理用户输入，将数据发送到后端系统，并在收到数据处理结果后更新界面。后端应该处理数据，并提供一个API来处理客户端的请求。</p><p id="639c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我决定轻装上阵，在前端使用基本的HTML、CSS和JS。至于后端，我计划只使用AWS服务——不在EC2或lambdas上运行定制代码。</p><p id="94b7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">分析问题后，我设计了以下解决方案:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi lw"><img src="../Images/22a2445b5329db886ad119486f52d94a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*tg5FYqTlfxtxotWF5DhxGg.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">图一。解决方案设计</p></figure><p id="39d2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如您所见，即使是这样一个基本的应用程序也有多个epics要实现。他们在这里:</p><ul class=""><li id="008d" class="lx ly it lb b lc ld lf lg li lz lm ma lq mb lu mc md me mf bi translated">制作和托管静态内容</li><li id="721b" class="lx ly it lb b lc mg lf mh li mi lm mj lq mk lu mc md me mf bi translated">处理用户数据</li><li id="b80d" class="lx ly it lb b lc mg lf mh li mi lm mj lq mk lu mc md me mf bi translated">提供内容</li><li id="2e1b" class="lx ly it lb b lc mg lf mh li mi lm mj lq mk lu mc md me mf bi translated">保护服务</li></ul><p id="c03c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">以下各节详细阐述了每一部史诗。同时，如果你想看到最终的解决方案源代码，你可以在<a class="ae ky" href="https://github.com/antklim/serverless-form" rel="noopener ugc nofollow" target="_blank">无服务器表单</a>存储库中找到它。它具有以下结构:</p><ul class=""><li id="c564" class="lx ly it lb b lc ld lf lg li lz lm ma lq mb lu mc md me mf bi translated">目录包含所有与AWS相关的资产——云形成模板和自动化脚本</li><li id="b7ab" class="lx ly it lb b lc mg lf mh li mi lm mj lq mk lu mc md me mf bi translated"><code class="fe ml mm mn mo b">form</code>目录包含所有web表单资产——HTML页面、CSS和JS</li></ul><h1 id="7a50" class="mp mq it bd mr ms mt mu mv mw mx my mz jz na ka nb kc nc kd nd kf ne kg nf ng bi translated">制作和托管静态内容</h1><p id="ae3c" class="pw-post-body-paragraph kz la it lb b lc nh ju le lf ni jx lh li nj lk ll lm nk lo lp lq nl ls lt lu im bi translated">本节介绍web表单开发和托管前端资产的基础设施。</p><p id="f32d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我设计了一个基本的web表单，有几个输入框和一个提交按钮。此外，我想用一些CSS使它变得漂亮。对于一个经验丰富的前端开发人员来说，实现这样的表单没什么大不了的，但是对我来说，这是有问题的。因此我使用了<a class="ae ky" href="https://html5boilerplate.com/" rel="noopener ugc nofollow" target="_blank"> HTML5样板文件</a>和<a class="ae ky" href="https://getbootstrap.com/" rel="noopener ugc nofollow" target="_blank">引导程序</a>来节省时间。我将一些来自Bootstrap CSS的基类应用于按钮和输入字段。</p><p id="37d8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">HTML5样板模板可以作为归档文件使用。我把它解压到我的<strong class="lb iu"> <em class="lv">表单</em> </strong>目录下，只安装了一个<strong class="lb iu"> <em class="lv"> npm </em> </strong>依赖项— <a class="ae ky" href="https://parceljs.org/" rel="noopener ugc nofollow" target="_blank"> ParcelJS </a>。ParcelJS是一个简单但功能强大的构建工具，它允许我在本地运行web表单并捆绑资产。我将一个引导CSS CDN链接直接添加到web表单的HTML中，以访问CSS类。希望前端模板和CSS库的使用不算框架的使用。</p><p id="24d9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">有多种方法可以实现与后端系统的web表单交互。最简单的方法是只使用HTML。在这种情况下，浏览器会为您完成所有工作。它将输入字段映射到请求负载，发送请求并重定向到结果页面。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nm nn l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">例1。基本HTML表单</p></figure><p id="db44" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">另一种选择是使用JavaScript与后端系统交互。在这种情况下，开发人员负责请求字段映射，发送请求并通知结果。该选项提供了更多的自由，并创建了更复杂的用户体验。权衡是——有更多的东西需要维护。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nm nn l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">例2。带有JS的HTML表单</p></figure><p id="6bb0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我编写了下面的JS代码来将web表单数据提交给后端系统。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nm nn l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">示例2.1 HTML表单的JS</p></figure><p id="37b6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我在JS中的submit按钮上附加了一个click事件监听器。事件处理程序协调多项工作:请求有效负载合成、发送请求和处理响应。为了将数据发送到后端，我使用了<a class="ae ky" href="https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API" rel="noopener ugc nofollow" target="_blank"> Fetch API </a>，这在大多数现代浏览器中都可以使用。</p><p id="1902" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">HTML5样板中可用的工具允许我在浏览器中预览表单。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi no"><img src="../Images/258316618249ef83b9918f7bd408d068.png" data-original-src="https://miro.medium.com/v2/resize:fit:800/format:webp/1*ZLqIc1_LHR1PQvZ3f0qABw.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">图二。随时向我发布网络表单</p></figure><p id="dce7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在我创建了表单之后，下一步是准备通过公共互联网访问它。</p><h2 id="1295" class="np mq it bd mr nq nr dn mv ns nt dp mz li nu nv nb lm nw nx nd lq ny nz nf oa bi translated">AWS S3上的托管表单</h2><p id="69e1" class="pw-post-body-paragraph kz la it lb b lc nh ju le lf ni jx lh li nj lk ll lm nk lo lp lq nl ls lt lu im bi translated">AWS S3是分发数字资产和托管静态网站的最简单的选择之一。我需要做的只是创建和配置一个存储桶，并将web表单资产复制到存储桶中。</p><p id="9c3e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我选择AWS CloudFormation来自动化AWS资源的供应和这些资源中的版本控制变更。</p><p id="e9cd" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我在下面的模板中为web表单资产声明了一个AWS S3存储桶。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nm nn l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">例3。Web表单S3时段资源模板</p></figure><p id="2645" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我使用aws cli命令<a class="ae ky" href="https://docs.aws.amazon.com/cli/latest/reference/cloudformation/create-stack.html#create-stack" rel="noopener ugc nofollow" target="_blank"><em class="lv">cloud formation create-stack</em></a>来提供模板中描述的资源。</p><p id="c58b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">然后我配置ParcelJS将生成的web表单资产保存到<strong class="lb iu"> <em class="lv"> form/dist </em> </strong>目录中。然后，我把<strong class="lb iu"> <em class="lv"> form/dist </em> </strong>目录的内容复制到bucket中。我还编写了一个脚本来同步bucket中的资产和<strong class="lb iu"> <em class="lv"> form/dist </em> </strong>目录中的工件。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nm nn l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">例4。桶同步脚本</p></figure><blockquote class="ob oc od"><p id="9146" class="kz la lv lb b lc ld ju le lf lg jx lh oe lj lk ll of ln lo lp og lr ls lt lu im bi translated">注意，脚本应该位于<strong class="lb iu">表单的</strong>目录下。</p></blockquote><p id="1b89" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在我将web表单资产复制到bucket之后，我临时启用了对bucket的公共访问，以便通过S3网站端点查看web表单。为此，我在bucket模板中更改了<em class="lv">publiccessblockingconfiguration</em>。</p><p id="83da" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在<em class="lv">例3 </em>中，所有对桶的公共访问都被故意阻止。这是为AWS CloudFront集成做准备。在最终版本中，所有流量都通过AWS CloudFront(参见<em class="lv">图1 </em>)，而bucket只能通过AWS CloudFront分发访问。</p><p id="88d5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">就这样，我完成了第一个史诗——“生产和托管静态内容”。我转到了核心功能的实现——处理用户数据。</p><h1 id="237f" class="mp mq it bd mr ms mt mu mv mw mx my mz jz na ka nb kc nc kd nd kf ne kg nf ng bi translated">处理用户数据</h1><p id="9622" class="pw-post-body-paragraph kz la it lb b lc nh ju le lf ni jx lh li nj lk ll lm nk lo lp lq nl ls lt lu im bi translated">本节介绍处理用户数据的两个主要组件—表单数据请求处理程序和数据存储。</p><p id="e5e7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">为了存储用户数据，我选择了AWS DynamoDB。与DynamoDB集成起来相对容易，开始工作起来也比较快。为了处理表单数据请求，我使用AWS API Gateway来简化和加快开发速度。此时，开发人员通常更喜欢放置一些后端服务来处理用户数据。在看埃里克·约翰逊的《异步思考》之前，我会设计类似的架构。这个演示启发了我，我决定直接从AWS API Gateway集成AWS DynamoDB表。下图显示了顶层架构设计。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi oh"><img src="../Images/a086a6ff28120822611213df510f1897.png" data-original-src="https://miro.medium.com/v2/resize:fit:846/format:webp/1*f5Y4cIU69OD6LmVwDpoKcg.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">图3。表单数据处理架构设计</p></figure><p id="efee" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">AWS API网关资源托管端点，并支持API分阶段部署。POST端点的目标是处理HTTP请求并向下游传递数据。AWS DynomoDB表存储表单数据。出于安全原因，不同的AWS资源不能相互通信，除非授予特定的访问权限。在<em class="lv">图3 </em>、<em class="lv">端点角色</em>和<em class="lv"> DynamoDB访问策略</em>授予POST端点将数据写入AWS DynamoDB表的权限。</p><h2 id="770e" class="np mq it bd mr nq nr dn mv ns nt dp mz li nu nv nb lm nw nx nd lq ny nz nf oa bi translated">DynamoDB表</h2><p id="26e8" class="pw-post-body-paragraph kz la it lb b lc nh ju le lf ni jx lh li nj lk ll lm nk lo lp lq nl ls lt lu im bi translated">我从表单数据表a开始实现，写了下面的模板来描述它。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nm nn l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">例5。表单数据表</p></figure><p id="7b77" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">对于AWS DynamoDB表，只需要声明关键字段。在这种情况下，我决定让<em class="lv"> email </em> <strong class="lb iu"> <em class="lv"> </em> </strong>成为<a class="ae ky" href="https://docs.aws.amazon.com/amazondynamodb/latest/developerguide/HowItWorks.CoreComponents.html#HowItWorks.CoreComponents.PrimaryKey" rel="noopener ugc nofollow" target="_blank">主键</a>。为了降低成本，我还限制了生产能力。</p><h2 id="d3e1" class="np mq it bd mr nq nr dn mv ns nt dp mz li nu nv nb lm nw nx nd lq ny nz nf oa bi translated">IAM资源</h2><p id="d91c" class="pw-post-body-paragraph kz la it lb b lc nh ju le lf ni jx lh li nj lk ll lm nk lo lp lq nl ls lt lu im bi translated">创建表之后，我开始处理AWS IAM资源。我声明了一个角色和策略。角色是访问策略(授予资源权限)和主体(需要访问其他资源的资源)之间的中介。</p><p id="65dc" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">以下模板中的角色仅限于AWS API网关主体；其他服务不能使用此角色。该策略授予将项目放入特定AWS DynamoDB表(在<em class="lv">示例5 </em>中声明)并附加到角色的权限。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nm nn l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">例6。IAM资源</p></figure><h2 id="1658" class="np mq it bd mr nq nr dn mv ns nt dp mz li nu nv nb lm nw nx nd lq ny nz nf oa bi translated">API网关</h2><p id="c853" class="pw-post-body-paragraph kz la it lb b lc nh ju le lf ni jx lh li nj lk ll lm nk lo lp lq nl ls lt lu im bi translated">接下来，我创建了AWS API网关和端点的实例。网关实例是添加端点的主机。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nm nn l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">例7。API网关实例</p></figure><blockquote class="ob oc od"><p id="c8f3" class="kz la lv lb b lc ld ju le lf lg jx lh oe lj lk ll of ln lo lp og lr ls lt lu im bi translated">API网关有两种类型:HTTP和RestApi。HTTP APIs提供的功能最少，成本也更低。我选择RestApi是因为我需要访问请求验证、请求参数和主体转换特性(并非所有这些特性在HTTP API中都可用)。这两种API类型的比较可在<a class="ae ky" href="https://docs.aws.amazon.com/apigateway/latest/developerguide/http-api-vs-rest.html" rel="noopener ugc nofollow" target="_blank">这里</a>找到。</p></blockquote><h2 id="bcb7" class="np mq it bd mr nq nr dn mv ns nt dp mz li nu nv nb lm nw nx nd lq ny nz nf oa bi translated">API端点</h2><p id="7fe5" class="pw-post-body-paragraph kz la it lb b lc nh ju le lf ni jx lh li nj lk ll lm nk lo lp lq nl ls lt lu im bi translated">API端点是我必须实现的最后一个基础设施。但这是事情变得有趣的地方。</p><p id="ddce" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">了解端点如何工作、由什么组成以及组件如何协作至关重要。端点从客户端接收数据，并将其发送到集成点(在本例中，它是一个AWS DynamoDB表)。每个端点的配置由四部分组成:方法请求、集成请求、集成响应和方法响应。</p><p id="bd88" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在方法请求部分，定义了API端点请求参数。它们是:请求正文和标题、URL搜索参数、请求验证规则和授权类型。在这里，客户的请求被准备转换成集成请求。</p><p id="43c8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在集成请求部分，定义了集成类型和请求。集成类型是需要连接的服务。集成请求接受客户机请求参数和有效负载，并将它们转换成服务请求。</p><p id="87da" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在方法响应部分，定义了所有可能的响应HTTP代码。每个响应代码都定义了响应代码头和主体模式(模型)。</p><p id="1712" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">集成响应部分将服务响应映射到客户机响应。为方法响应部分中允许的每个状态代码定义了HTTP响应和状态代码映射。</p><p id="97fa" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">API的另一个重要组件是模型。模型描述了请求或响应的模式。模型不仅用于文档。API请求验证器使用模型来验证请求负载。如果违反了模型的模式规则，AWS API网关将拒绝请求。</p><p id="a900" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我创建了两个模型，并将它们附加到一个AWS API网关实例上。请求模型反映了表单字段—电子邮件、全名和注释。作为回应，我决定返回一条消息和状态代码。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nm nn l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">例8。请求和响应模型</p></figure><p id="0bca" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">接下来，我向AWS API网关添加了请求验证器。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nm nn l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">例9。请求验证器</p></figure><p id="71f0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">然后我创建了一个AWS API网关资源。资源代表服务提供访问的实体。在这个例子中，<em class="lv">意图/订阅</em>是资源。表单数据描述资源的属性，HTTP谓词用于检索或更改资源的状态。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nm nn l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">例10。表单数据资源</p></figure><p id="a8b0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">HTTP方法描述了处理请求，并被附加到AWS API网关资源。每个HTTP谓词只能定义一个方法。如果API端点需要处理多个请求，则声明单独的方法(例如，GET和POST请求有两个不同的方法)。</p><p id="823a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">API方法编排API端点的各个部分的交互。我编写了以下模板来处理表单数据请求，并在AWS DynamoDB表中存储信息。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nm nn l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">例11。过帐方法</p></figure><p id="9236" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">上面的模板取代了后端服务的功能。有很多重要的细节需要注意。</p><ul class=""><li id="a85d" class="lx ly it lb b lc ld lf lg li lz lm ma lq mb lu mc md me mf bi translated"><code class="fe ml mm mn mo b">ResourceId</code>和<code class="fe ml mm mn mo b">RestApiId</code> <strong class="lb iu"> <em class="lv"> </em> </strong> —将方法附加到API资源和AWS API网关实例。</li><li id="b59f" class="lx ly it lb b lc mg lf mh li mi lm mj lq mk lu mc md me mf bi translated"><code class="fe ml mm mn mo b">RequestParameters</code> —本节定义了可接受的参数。布尔标志指定参数是否是必需的。本节中声明的参数在集成部分中变得可访问。在<em class="lv">示例11中，</em>需要<em class="lv">内容类型</em>头，因为模板选择是基于所接收请求的内容类型。</li><li id="f636" class="lx ly it lb b lc mg lf mh li mi lm mj lq mk lu mc md me mf bi translated"><code class="fe ml mm mn mo b">RequestModels</code>和<code class="fe ml mm mn mo b">RequestValidatorId</code>—验证器使用模型中定义的模式来验证请求。<em class="lv">图4 </em>显示了web控制台中的请求配置。</li><li id="2ae1" class="lx ly it lb b lc mg lf mh li mi lm mj lq mk lu mc md me mf bi translated"><code class="fe ml mm mn mo b">Integration </code> —定义与后端系统的集成，该方法在收到请求时调用该后端系统。在这种情况下，AWS DynamoDB是被调用来存储表单数据的服务。因此将<strong class="lb iu">与<em class="lv">整合。类型</em> </strong>声明为AWS。</li><li id="9e26" class="lx ly it lb b lc mg lf mh li mi lm mj lq mk lu mc md me mf bi translated"><code class="fe ml mm mn mo b">Integration.Credentials</code> <strong class="lb iu"> <em class="lv"> </em> </strong> —授予对AWS DynamoDB表的访问权限。</li><li id="172c" class="lx ly it lb b lc mg lf mh li mi lm mj lq mk lu mc md me mf bi translated"><code class="fe ml mm mn mo b">Integration.Uri</code>和<code class="fe ml mm mn mo b">Integration.IntegrationHttpMethod</code> —执行<em class="lv"> PutItem </em>操作的AWS DynamoDB HTTP端点和方法。</li><li id="c6c0" class="lx ly it lb b lc mg lf mh li mi lm mj lq mk lu mc md me mf bi translated"><code class="fe ml mm mn mo b">Integration.RequestParameters </code> —定义对后端系统请求的参数，如头、查询和路径参数。在这一节中，我引用了客户请求的内容类型标题。标题值用于<code class="fe ml mm mn mo b">RequestTemplates</code> <strong class="lb iu"> <em class="lv"> </em> </strong>部分。</li><li id="64de" class="lx ly it lb b lc mg lf mh li mi lm mj lq mk lu mc md me mf bi translated"><code class="fe ml mm mn mo b">Integration.RequestTemplates </code> —构建要发送到后端系统的请求有效负载。客户端的请求负载在这一部分中进行映射。我使用<a class="ae ky" href="https://velocity.apache.org/engine/devel/vtl-reference.html" rel="noopener ugc nofollow" target="_blank"> Velicity模板语言(VTL) </a>将客户端的请求映射到AWS DynamoDB的<em class="lv"> PutItem </em>请求。注意，我创建了web表单的两个版本，它们产生不同内容类型的有效负载。纯HTML表单(<em class="lv">示例1 </em>)输出<em class="lv">应用/x- </em> <code class="fe ml mm mn mo b">www-form-urlencoded</code> <em class="lv"> </em>类型的有效负载，基于JS的web表单(<em class="lv">示例2 </em>)产生<code class="fe ml mm mn mo b">application/json</code> <em class="lv"> </em>类型的有效负载。因此，我在本节中定义了两个模板——每个有效负载类型一个模板。我将<code class="fe ml mm mn mo b">$context.stage</code>添加到模板中，以记录处理请求的AWS API网关阶段。<em class="lv">图5 </em>和<em class="lv"> 5.1 </em>显示了web控制台中的集成配置。</li><li id="0a8c" class="lx ly it lb b lc mg lf mh li mi lm mj lq mk lu mc md me mf bi translated"><code class="fe ml mm mn mo b">Integration.IntegrationResponses</code> <strong class="lb iu"> <em class="lv"> </em> </strong> —定义集成响应代码和参数映射到客户端的响应代码和参数。<em class="lv">图6 </em>和<em class="lv"> 6.1 </em>显示了web控制台中的集成响应配置。</li><li id="0930" class="lx ly it lb b lc mg lf mh li mi lm mj lq mk lu mc md me mf bi translated"><code class="fe ml mm mn mo b">MethodResponses</code> <strong class="lb iu"> <em class="lv"> </em> </strong> —定义如何根据接收到的响应代码构建客户端响应，以及向客户端返回什么响应参数。<em class="lv">图7 </em>显示了web控制台中的响应配置。</li></ul><p id="84bd" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">关于如何映射请求响应数据的更多信息可在<a class="ae ky" href="https://docs.aws.amazon.com/apigateway/latest/developerguide/request-response-data-mappings.html" rel="noopener ugc nofollow" target="_blank">这里</a>获得。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi oi"><img src="../Images/268504f6fbf6df25fcfbea438086e0a8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*lOojclqkjVRKXSy0e4clZQ.jpeg"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">图4。方法请求配置</p></figure><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi oj"><img src="../Images/3647d24644e6bd6ffa24858eacf38591.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*HmYBu-NJfSCUnYs2OPidKw.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">图5。方法集成请求配置</p></figure><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ok"><img src="../Images/53581eb58a0b72f0116d4f910fc3a594.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*VvkcCm1LjybbD96vOrlnyw.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">图5.1方法集成请求头和模板配置</p></figure><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ol"><img src="../Images/7f9283d6dbe132b34fa18ecf1a84a327.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*_fezfKzjgddW5ny97cIfiw.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">图6。方法集成响应代码列表</p></figure><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi om"><img src="../Images/c82c98c57c00649b75e559806b940054.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*_PYg_rWTwNqnfkNyIXyPfw.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">图6.1方法集成响应状态映射规则、标题映射和响应模板</p></figure><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi on"><img src="../Images/e70bfe53698d9e0924eed1640ee036a0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*jpKzK3eg_dP76g9WaEfN0A.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">图7。方法响应配置</p></figure><p id="bebb" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><em class="lv">示例7–11</em>中展示的模板是一个API端点的组件。有相当多的活动部件；有时候，把它们都记住是很有挑战性的。因此，我创建了下面的图表来形象化所有这些部分是如何一起工作的。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi oo"><img src="../Images/71e5c2fa3c5f1618afb5f80445de56b8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1368/format:webp/1*xt5EJeoyKn_znkPiphSoMA.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">图8。API网关端点资源(基于云形成模板)。</p></figure><h2 id="c107" class="np mq it bd mr nq nr dn mv ns nt dp mz li nu nv nb lm nw nx nd lq ny nz nf oa bi translated">CORS设置</h2><p id="5357" class="pw-post-body-paragraph kz la it lb b lc nh ju le lf ni jx lh li nj lk ll lm nk lo lp lq nl ls lt lu im bi translated">您可能会注意到在<em class="lv">示例11 </em>的集成和方法响应部分中定义了一堆<em class="lv">访问控制允许-* </em>头。这些是CORS的标题。CORS既麻烦又有挑战性，尤其是在本地主机上。这个项目也不例外。为了能够从<em class="lv"> localhost发送表单数据，</em>我需要为资源配置CORS。为了解决这个问题，我在<code class="fe ml mm mn mo b">FormDataResource</code>中添加了OPTIONS方法。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nm nn l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">例12。选项方法</p></figure><p id="759d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">当浏览器识别出一个不安全的CORS请求时，它会发送一个选项请求来询问服务器什么是允许的。根据OPTIONS响应中收到的<em class="lv"> Access-Control-Allow-* </em>报头，浏览器决定发送主请求(在本例中为POST)是否安全。</p><h2 id="d0df" class="np mq it bd mr nq nr dn mv ns nt dp mz li nu nv nb lm nw nx nd lq ny nz nf oa bi translated">API网关部署和准备</h2><p id="2552" class="pw-post-body-paragraph kz la it lb b lc nh ju le lf ni jx lh li nj lk ll lm nk lo lp lq nl ls lt lu im bi translated">部署是使API资源对公众开放的最后一步。阶段是部署资源的主机。AWS API网关支持多个阶段。我编写了下面的模板来定义<code class="fe ml mm mn mo b">test</code>阶段和部署。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nm nn l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">例13。API网关部署和准备</p></figure><p id="6454" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">部署配置是基本的——它需要的只是对AWS API网关的引用。舞台配置也很简单——唯一的必填字段是<code class="fe ml mm mn mo b">RestApiId</code>。我用<code class="fe ml mm mn mo b">MethodSettings</code>配置扩展了阶段定义，以增加一层额外的保护。当部署发布到某个阶段时，它会生成一个公共URL。为了限制不必要的API使用，我配置了请求限制。</p><h1 id="67a7" class="mp mq it bd mr ms mt mu mv mw mx my mz jz na ka nb kc nc kd nd kf ne kg nf ng bi translated">将所有内容整合在一起— AWS CloudFront分发版</h1><p id="be8c" class="pw-post-body-paragraph kz la it lb b lc nh ju le lf ni jx lh li nj lk ll lm nk lo lp lq nl ls lt lu im bi translated">AWS CloudFront允许我为静态资产和API创建单一入口点。AWS CloudFront中有许多特性支持各种实验和操作策略。</p><p id="3ade" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">AWS CloudFront有两个主要组件:起源和行为。Origin定义了收到请求时要调用的服务。行为定义了请求分组规则以及使用什么来源来构建响应。自定义缓存策略和边缘功能可以添加到行为中，从而创造独特的体验。</p><p id="be0e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">对于这个项目，我定义了两个起源和两种行为。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi op"><img src="../Images/5f332ac86afa18532deb543c458195c6.png" data-original-src="https://miro.medium.com/v2/resize:fit:972/format:webp/1*zSa-cVT2hRQp12vBgWI0zw.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">图9。云锋起源和行为</p></figure><p id="b1ff" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">此外，我为提供静态资产的行为创建了一个定制的缓存策略。原因是每当bucket中的资产发生变化时，我都需要使缓存失效。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nm nn l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">实施例14。静态资产的自定义缓存策略</p></figure><p id="77bd" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">因为AWS API网关部署有一个公共URL，所以AWS CloudFront发行版可以访问它。AWS S3访问不是公共的，需要额外的IAM资源。我结合使用了AWS S3存储桶访问策略和AWS CloudFront origin访问身份(OAI ),以允许发行版从存储桶中读取数据。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi oq"><img src="../Images/5764d942ef391e96ea9b35a9c933389a.png" data-original-src="https://miro.medium.com/v2/resize:fit:950/format:webp/1*qO0r5O5SFmO98KmjAxfKjg.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">图10。云锋OAI和IAM资源</p></figure><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nm nn l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">实施例15。OAI云锋</p></figure><p id="4d7f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">源访问身份是一个特殊的AWS CloudFront用户，它可以与AWS S3源相关联，提供对bucket内容的安全访问。在下面的bucket策略模板中，我使用AWS CloudFront OAI作为主体，这样只有发行版可以访问bucket内容。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nm nn l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">实施例16。Bucket策略只向CloudFront授予获取对象的权限</p></figure><p id="67ef" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">结合<em class="lv">示例3 </em>中提供的bucket配置，只能通过AWS CloudFront分发从公共互联网访问bucket内容。</p><p id="02cb" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">然后我用两个起源和行为定义了AWS CloudFront发行版(参见<em class="lv">图9 </em>)。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nm nn l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">实施例17。云锋分布</p></figure><p id="c747" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">有一些重要的细节需要注意。</p><ul class=""><li id="609b" class="lx ly it lb b lc ld lf lg li lz lm ma lq mb lu mc md me mf bi translated"><code class="fe ml mm mn mo b"><strong class="lb iu"><em class="lv">DefaultCacheBehavior</em></strong></code> <strong class="lb iu"> <em class="lv"> </em> </strong> —引用AWS S3原点。</li><li id="9298" class="lx ly it lb b lc mg lf mh li mi lm mj lq mk lu mc md me mf bi translated"><code class="fe ml mm mn mo b"><strong class="lb iu"><em class="lv">DefaultCacheBehavior.CachePolicyId</em></strong></code> <strong class="lb iu"> <em class="lv"> </em> </strong> —是对在<em class="lv">示例14 </em>中创建的自定义缓存策略的引用。</li><li id="6b35" class="lx ly it lb b lc mg lf mh li mi lm mj lq mk lu mc md me mf bi translated"><code class="fe ml mm mn mo b"><strong class="lb iu"><em class="lv">TargetOriginId</em></strong></code> <strong class="lb iu"> <em class="lv"> </em> </strong> —用于行为配置，应匹配<strong class="lb iu"><em class="lv"/></strong><code class="fe ml mm mn mo b"><strong class="lb iu"><em class="lv">Origins</em></strong></code>部分定义的<code class="fe ml mm mn mo b"><strong class="lb iu"><em class="lv">Id</em></strong>s</code> <strong class="lb iu"> <em class="lv"> </em> </strong>之一。</li><li id="3555" class="lx ly it lb b lc mg lf mh li mi lm mj lq mk lu mc md me mf bi translated"><code class="fe ml mm mn mo b"><strong class="lb iu"><em class="lv">CacheBehaviors</em></strong></code> <strong class="lb iu"> <em class="lv"> </em> </strong> —除默认行为之外的行为列表。我添加了引用API网关起源的行为。</li><li id="3ce9" class="lx ly it lb b lc mg lf mh li mi lm mj lq mk lu mc md me mf bi translated"><code class="fe ml mm mn mo b">CacheBehaviors[0].CachePolicyId</code> —我对AWS API网关行为使用了AWS管理的缓存优化缓存策略。可通过AWS web控制台<em class="lv">CloudFront&gt;Policies</em>获得托管策略列表。当一个策略被选中时，它的<em class="lv"> Id </em>会显示在信息视图<em class="lv"> CloudFront &gt;策略&gt;缓存&gt;{策略id}的顶部。</em></li><li id="238c" class="lx ly it lb b lc mg lf mh li mi lm mj lq mk lu mc md me mf bi translated"><code class="fe ml mm mn mo b">Origins</code>—来源列表</li><li id="e2b3" class="lx ly it lb b lc mg lf mh li mi lm mj lq mk lu mc md me mf bi translated"><code class="fe ml mm mn mo b">Origins[1].OriginPath</code><strong class="lb iu"><em class="lv"/></strong>—AWS API网关的原始路径应包括阶段名。将AWS API网关资源部署到阶段时，所有路径都以阶段名称为前缀。如果在<em class="lv"> OriginPath中没有设置阶段名，</em>AWS CloudFront分发版在<code class="fe ml mm mn mo b">/</code>解析资源。</li></ul><p id="2677" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在我部署了AWS CloudFormtaion栈之后，我验证了web表单和submit可以通过AWS CloudFront分发URL获得。我发布了表单数据，并在AWS DynamoDB表中找到了它。目的达到了！</p><p id="bfc0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我还需要做最后一项改进——增加更多的保护。在那一刻，AWS DynamoDB表被隐式地暴露在公共互联网上。唯一的安全措施是在AWS API网关阶段限制请求速率。</p><h1 id="ad0e" class="mp mq it bd mr ms mt mu mv mw mx my mz jz na ka nb kc nc kd nd kf ne kg nf ng bi translated">安全性— WAF</h1><p id="1509" class="pw-post-body-paragraph kz la it lb b lc nh ju le lf ni jx lh li nj lk ll lm nk lo lp lq nl ls lt lu im bi translated">有几种服务可用于提高web应用程序保护。AWS Shield和WAF是最受欢迎的，也是最容易集成的。简单来说，AWS Shield保护应用和服务免受DDoS攻击。AWS WAF是一个web应用程序防火墙，保护web应用程序或API免受常见web漏洞和僵尸程序的攻击。为了提高解决方案的安全性，我决定添加WAF。</p><blockquote class="ob oc od"><p id="6039" class="kz la lv lb b lc ld ju le lf lg jx lh oe lj lk ll of ln lo lp og lr ls lt lu im bi translated">警告，AWS WAF挺贵的。只是随便玩玩或者扣球的时候，不需要的时候一定要禁用WAF。有了AWS WAF，用户<strong class="lb iu">为活动规则</strong>付费，而不是被这些规则过滤的流量。</p></blockquote><p id="3c71" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我创建了一个单独的模板来描述WAF所需的资源。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nm nn l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">实施例18。晶片配置</p></figure><p id="ba02" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">有几个重要的细节需要注意。</p><ul class=""><li id="c519" class="lx ly it lb b lc ld lf lg li lz lm ma lq mb lu mc md me mf bi translated"><code class="fe ml mm mn mo b">WebACL.Scope</code> —有两种类型的范围:<code class="fe ml mm mn mo b">CLOUDFRONT</code>(全局)和<em class="lv">区域</em>。Scope定义了WebACL是用于CloudFront发行版还是区域应用程序。区域性应用程序可以是应用程序负载平衡器(ALB)、AWS API Gateway REST API、AWS AppSync GraphQL API或Amazon Cognito用户池。要使用<code class="fe ml mm mn mo b">CLOUDFRONT</code>范围，必须在<em class="lv">美国东部-1 </em>地区创建WAF资源。</li><li id="2cac" class="lx ly it lb b lc mg lf mh li mi lm mj lq mk lu mc md me mf bi translated"><code class="fe ml mm mn mo b">WebACL.Rules</code> <strong class="lb iu"> <em class="lv"> </em> </strong> —我用的是AWS管理的规则。</li><li id="3cd3" class="lx ly it lb b lc mg lf mh li mi lm mj lq mk lu mc md me mf bi translated"><code class="fe ml mm mn mo b">Logs</code> <strong class="lb iu"> <em class="lv"> </em> </strong> —晶圆日志组。对于<em class="lv"> CLOUDFRONT </em>范围，必须在<em class="lv"> us-east-1 </em>区域创建日志组。它必须有前缀<em class="lv"> aws-waf-logs- </em>。</li><li id="e89a" class="lx ly it lb b lc mg lf mh li mi lm mj lq mk lu mc md me mf bi translated"><code class="fe ml mm mn mo b">WafLogsConfiguration.LogDestinationConfigs</code> —日志目的地ARN应该是下面的格式<code class="fe ml mm mn mo b">arn:aws:logs:{AWSRegion}:{AccountId}:log-group:aws-waf-logs-{log group name};</code> <em class="lv"> </em>但是日志组资源的<a class="ae ky" href="https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/intrinsic-function-reference-getatt.html" rel="noopener ugc nofollow" target="_blank"> <em class="lv"> Fn::GetAtt </em> </a>以不同的格式<code class="fe ml mm mn mo b">arn:aws:logs:{AWSRegion}:{AccountId}:log-group:/stack-name-12ABC1AB12A1:*</code> <em class="lv">返回ARN。</em>因此，我使用了<a class="ae ky" href="https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/intrinsic-function-reference-sub.html" rel="noopener ugc nofollow" target="_blank"> <em class="lv"> Fn::Sub </em> </a>来构建日志目的地ARN。</li></ul><p id="4ffa" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">创建WebACL后，我将它与在<em class="lv">示例17 </em>中创建的AWS CloudFront发行版关联起来。为此，我定义了<code class="fe ml mm mn mo b">Distribution</code>资源的<code class="fe ml mm mn mo b">DistributionConfig.WebACLID</code> <em class="lv"> </em>属性。需要注意的是，创建WebACL时使用的是哪个版本的AWS WAF。<code class="fe ml mm mn mo b">WebACLID</code>格式因版本而异。要引用最新AWS WAF版本制作的WebACL(<em class="lv">AWS::</em><strong class="lb iu"><em class="lv">WAF v2</em></strong><em class="lv">:</em>)使用WebACL ARN。要引用经典AWS WAF版本中创建的WebACL(<em class="lv">AWS::</em><strong class="lb iu"><em class="lv">WAF</em></strong><em class="lv">::WebACL</em>)，使用WebACL ID。</p><p id="f062" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">就是这样。我完成了项目的最后一部分。还有改进的空间。例如，通过Route53添加一个自定义域，并配置仅通过该域访问web表单。但是这超出了本文的范围，本文已经很大了。</p><blockquote class="ob oc od"><p id="945b" class="kz la lv lb b lc ld ju le lf lg jx lh oe lj lk ll of ln lo lp og lr ls lt lu im bi translated">请注意，在所有云形成模板的例子中，我省略了标签部分。我这样做是为了节省空间。在最终解决方案<a class="ae ky" href="https://github.com/antklim/serverless-form/blob/master/.aws/main.yml" rel="noopener ugc nofollow" target="_blank">模板</a>中，几乎所有的资源都是用标签声明的。我更喜欢在可能的地方添加标签。它提高了栈的可维护性。</p></blockquote><h1 id="81e4" class="mp mq it bd mr ms mt mu mv mw mx my mz jz na ka nb kc nc kd nd kf ne kg nf ng bi translated">临时演员</h1><p id="85e5" class="pw-post-body-paragraph kz la it lb b lc nh ju le lf ni jx lh li nj lk ll lm nk lo lp lq nl ls lt lu im bi translated">正如您所注意到的，一些AWS CloudFromation模板使用参数。为了简化模板的使用，我将参数值组织到了<code class="fe ml mm mn mo b">.env</code>文件中。下面是<code class="fe ml mm mn mo b">.env</code>的一个例子。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nm nn l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">实施例19。。环境文件结构</p></figure><p id="6989" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">为了自动部署资源，我编写了一个基本脚本。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nm nn l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">例20。创建或更新云形成堆栈</p></figure><p id="32fe" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">首先，该脚本验证是否提供了所有必需的参数。然后用<em class="lv"> describe-stacks </em>命令发现现有的栈。如果没有找到堆栈，调用<em class="lv">创建堆栈</em>命令。否则，用<em class="lv">更新堆栈</em>命令更新当前堆栈。</p></div><div class="ab cl or os hx ot" role="separator"><span class="ou bw bk ov ow ox"/><span class="ou bw bk ov ow ox"/><span class="ou bw bk ov ow"/></div><div class="im in io ip iq"><p id="7e7b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">感谢阅读；我希望你喜欢这篇文章，并学到了一些新东西。</p><p id="d2da" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这个项目的主要目标是学习一种处理web表单数据的新技术。每种方法都有其优点和局限性。当前的表单验证和映射技术非常有限。Apache Velocity模板引擎对于AWS API网关来说并不常见，也是独一无二的。对于这个项目的需要来说，这已经足够了。但是如果需要更复杂的映射，我会考虑使用其他东西，比如lambdas。另一方面，AWS API Gateway和AWS DynamoDB的<em class="lv"> AWS-native </em>集成减少了数据写入延迟，提高了系统的可靠性。</p><p id="ebb9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">要找到正确的解决方案，理解问题的<em class="lv">【什么】</em>部分至关重要。<em class="lv">应用程序应该做什么</em>，以及<em class="lv">它有什么</em>行为？通常有多种方法来解决问题，没有必要用传统的方法来解决问题。实施应该与您当前的技术堆栈、技术开发策略以及团队的经验和知识相一致。</p><p id="a4d7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">该解决方案应该易于替换。垂直和水平缩放有限制。不同规模的问题需要不同的架构。例如，当负载增加到每秒100万个连接时，为每秒处理数百个并发连接而设计的解决方案就不能很好地工作。</p><p id="5c54" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">同样，解决方案设计应该足够好，以满足当前的需求。最好知道如何处理数百万个并发连接，并且在用户很少的情况下仍然选择更简单的方法。明智地使用你的时间和工具。</p><h1 id="342e" class="mp mq it bd mr ms mt mu mv mw mx my mz jz na ka nb kc nc kd nd kf ne kg nf ng bi translated">参考</h1><ul class=""><li id="b931" class="lx ly it lb b lc nh lf ni li oy lm oz lq pa lu mc md me mf bi translated">埃里克·约翰逊的<a class="ae ky" href="https://youtu.be/V_tHVUHKqZQ" rel="noopener ugc nofollow" target="_blank">异步思考</a>——该项目的灵感来源。</li><li id="21d8" class="lx ly it lb b lc mg lf mh li mi lm mj lq mk lu mc md me mf bi translated"><a class="ae ky" href="https://docs.aws.amazon.com/AmazonS3/latest/userguide/WebsiteHosting.html" rel="noopener ugc nofollow" target="_blank">使用亚马逊S3托管静态网站</a>。</li><li id="af0e" class="lx ly it lb b lc mg lf mh li mi lm mj lq mk lu mc md me mf bi translated"><a class="ae ky" href="https://docs.aws.amazon.com/apigateway/latest/developerguide/request-response-data-mappings.html" rel="noopener ugc nofollow" target="_blank">亚马逊API网关API请求和响应数据映射参考</a>。</li><li id="a6ca" class="lx ly it lb b lc mg lf mh li mi lm mj lq mk lu mc md me mf bi translated">阿帕奇速度项目。</li><li id="b321" class="lx ly it lb b lc mg lf mh li mi lm mj lq mk lu mc md me mf bi translated"><a class="ae ky" href="https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/intrinsic-function-reference.html" rel="noopener ugc nofollow" target="_blank"> AWS固有函数参考</a>。</li><li id="88a6" class="lx ly it lb b lc mg lf mh li mi lm mj lq mk lu mc md me mf bi translated">GitHub上的<a class="ae ky" href="https://github.com/antklim/serverless-form" rel="noopener ugc nofollow" target="_blank">无服务器表单</a>存储库。</li></ul></div></div>    
</body>
</html>