<html>
<head>
<title>How to Expose Your Services With Kubernetes Ingress</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何使用Kubernetes Ingress公开您的服务</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/how-to-expose-your-services-with-kubernetes-ingress-7f34eb6c9b5a?source=collection_archive---------1-----------------------#2020-05-01">https://betterprogramming.pub/how-to-expose-your-services-with-kubernetes-ingress-7f34eb6c9b5a?source=collection_archive---------1-----------------------#2020-05-01</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="857c" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">允许你的应用程序与外界交流</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/30d36026b39fcfa4a2a0981603a38ad7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Z6gNyd-aMkwj0cFfMde_tw.jpeg"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">由<a class="ae ky" href="https://unsplash.com/@pechka?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">马頔·佩丘林</a>在<a class="ae ky" href="https://unsplash.com/s/photos/door?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>拍摄的照片</p></figure><p id="16d1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在我之前关于<a class="ae ky" href="https://medium.com/better-programming/kubernetes-from-scratch-part-2-e30b48f7ca6b" rel="noopener"> Kubernetes </a>的帖子中，为了向我的家庭网络公开我的服务，我使用了一个名为<a class="ae ky" href="https://metallb.universe.tf/" rel="noopener ugc nofollow" target="_blank"> MetalLB </a>的负载平衡器服务向VM桥公开服务，并在主主机上公开一个Nginx实例，作为我的家庭网络的反向代理。但是这也有一些限制。Kubernetes不知道Nginx，也不能控制它的配置，所以你必须手动配置。此外，MetalLB从VM桥窃取了一些IP地址，您必须猜测它配置的IP数量。如果您需要的数量超过分配的数量，您必须返回并再次配置MetalLB。</p><p id="2a13" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">将服务定义为直接暴露于您的家庭网络的入口路由是很好的。为此，您需要一个入口控制器和一条从主网络到Kubernetes桥接网络的路由。我们将从入口控制器开始。</p><p id="4d9f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">要阅读本文，您需要一个类似于我在文章<a class="ae ky" href="https://medium.com/better-programming/kubernetes-from-scratch-4691283e3995" rel="noopener"><em class="lv">Kubernetes from Scratch</em></a>中创建的设置。在这篇文章中，我在裸机上运行的虚拟机上创建了一个基本的Kubernetes系统。我写这篇文章的目的是通过不使用预打包系统或云提供商提供的系统来帮助理解幕后发生的事情。我还试图成为云提供商不可知论者，因此无论您使用什么云提供商，从本文中收集的知识都将帮助您更好地理解Kubernetes。您还需要了解Linux系统，尤其是网络。</p><p id="abf2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">首先，我们需要一个入口。我正好有一个简单的服务，它监听HTTP get请求并以“hello world”作为响应。创建一个名为<code class="fe lw lx ly lz b">simple-service.yaml</code>的文件，并添加以下内容:</p><pre class="kj kk kl km gt ma lz mb mc aw md bi"><span id="4bca" class="me mf it lz b gy mg mh l mi mj">apiVersion: apps/v1<br/>kind: Deployment<br/>metadata:<br/>  name: hellok8s-deployment<br/>  labels:<br/>    app: hellok8s<br/>spec:<br/>  selector:<br/>    matchLabels:<br/>      app: hellok8s<br/>  template:<br/>    metadata:<br/>      labels:<br/>        app: hellok8s<br/>    spec:<br/>      containers:<br/>      - name: hellok8s<br/>        image: docker.io/rlkamradt/hellok8s:latest<br/>        ports:<br/>        - containerPort: 8080<br/>---<br/>apiVersion: v1<br/>kind: Service<br/>metadata:<br/>  name: hellok8s-service<br/>spec:<br/>  type: ClusterIP<br/>  selector:<br/>    app: hellok8s<br/>  ports:<br/>  - port: 8080<br/>    targetPort: 8080</span></pre><p id="ec90" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这就像你在Kubernetes得到的一样简单。现在，运行<code class="fe lw lx ly lz b">kubectl apply -f simple-service.yaml</code>来启动服务，并公开端口8080。但是暴露在哪里？如果在主机上运行<code class="fe lw lx ly lz b">curl <a class="ae ky" href="http://localhost:8080/" rel="noopener ugc nofollow" target="_blank">http://localhost:8080/</a></code>，将一无所获。你可以看看服务:</p><pre class="kj kk kl km gt ma lz mb mc aw md bi"><span id="c802" class="me mf it lz b gy mg mh l mi mj">rkamradt@beast:~/scratch$ kubectl get service hellok8s-service<br/>NAME               TYPE        CLUSTER-IP      EXTERNAL-IP   PORT(S)    AGE<br/>hellok8s-service   ClusterIP   10.111.98.155   &lt;none&gt;        8080/TCP   80s</span></pre><p id="2bea" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">请注意，它有一个集群IP，但没有外部IP。你可以用集群IP试试冰壶，但是什么也得不到。</p><p id="86b9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们试试另一个选择。如果你可以访问你的节点(我的节点被称为kube 1–4 ),你可以<code class="fe lw lx ly lz b">ssh</code>它们。现在用您的集群IP运行curl:</p><pre class="kj kk kl km gt ma lz mb mc aw md bi"><span id="1a20" class="me mf it lz b gy mg mh l mi mj">rkamradt@kube1:~$ curl <a class="ae ky" href="http://10.111.98.155:8080/" rel="noopener ugc nofollow" target="_blank">http://10.111.98.155:8080/</a><br/>Hello World</span></pre><p id="557a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">你可以在每个节点上尝试，你会得到相同的答案。因此，入口控制器的功能之一是向主机公开服务。</p><p id="e2e8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在，我们必须选择一个入口控制器，其中有几个。如果您使用云提供商，他们通常会有一个首选提供商(或者只有一个)。但是既然我是自己的云提供商，我必须选择一个。我挑的是半官方的Nginx ingress控制器。您可以直接从Kubernetes GitHub页面安装它:</p><pre class="kj kk kl km gt ma lz mb mc aw md bi"><span id="d5b7" class="me mf it lz b gy mg mh l mi mj">kubectl apply -f <a class="ae ky" href="https://raw.githubusercontent.com/kubernetes/ingress-nginx/master/deploy/static/provider/baremetal/deploy.yaml" rel="noopener ugc nofollow" target="_blank">https://raw.githubusercontent.com/kubernetes/ingress-nginx/master/deploy/static/provider/baremetal/deploy.yaml</a></span></pre><p id="8a5a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这就创建了一个名为<code class="fe lw lx ly lz b">ingress-nginx</code>的名称空间。你可以看到它用<code class="fe lw lx ly lz b">kubectl get all -n ingress-nginx</code>创建的所有对象。</p><pre class="kj kk kl km gt ma lz mb mc aw md bi"><span id="1157" class="me mf it lz b gy mg mh l mi mj">rkamradt@beast:~/scratch$ kubectl get all -n ingress-nginx<br/>NAME                                            READY   STATUS      RESTARTS   AGE<br/>pod/ingress-nginx-admission-create-lfc2b        0/1     Completed   0          89s<br/>pod/ingress-nginx-admission-patch-rmcvq         0/1     Completed   0          89s<br/>pod/ingress-nginx-controller-5f98fb55b8-7pnjt   1/1     Running     0          99s</span><span id="0db0" class="me mf it lz b gy mk mh l mi mj">NAME                                         TYPE        CLUSTER-IP      EXTERNAL-IP   PORT(S)                      AGE<br/>service/ingress-nginx-controller             NodePort    10.96.223.195   &lt;none&gt;        80:32688/TCP,443:32569/TCP   99s<br/>service/ingress-nginx-controller-admission   ClusterIP   10.100.112.59   &lt;none&gt;        443/TCP                      99s</span><span id="3202" class="me mf it lz b gy mk mh l mi mj">NAME                                       READY   UP-TO-DATE   AVAILABLE   AGE<br/>deployment.apps/ingress-nginx-controller   1/1     1            1           99s</span><span id="4513" class="me mf it lz b gy mk mh l mi mj">NAME                                                  DESIRED   CURRENT   READY   AGE<br/>replicaset.apps/ingress-nginx-controller-5f98fb55b8   1         1         1       99s</span><span id="48df" class="me mf it lz b gy mk mh l mi mj">NAME                                       COMPLETIONS   DURATION   AGE<br/>job.batch/ingress-nginx-admission-create   1/1           8s         99s<br/>job.batch/ingress-nginx-admission-patch    1/1           8s         99s</span></pre><p id="6ca7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">有几件事需要注意:首先，它有两个运行一次的作业，然后将它们的pod留在周围，也许是为了诊断的目的。他们可能有一个TTL，或者我们可能只是需要在一段时间后摆脱他们。当我看到他们在附近闲逛而感到十分恼火时，我将不得不对此进行调查。</p><p id="8fdb" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">另一件需要注意的事情是，它创建了一个<code class="fe lw lx ly lz b">NodePort</code>服务，这将需要您使用<code class="fe lw lx ly lz b">kubectl port-forward</code>进行转发。我认为它这样做是因为它不能期望配置负载平衡器，但在我们的情况下，我们有MetalLB。我们需要通过编辑<code class="fe lw lx ly lz b">service/ingress-nginx-controller</code>服务来纠正这一点。运行<code class="fe lw lx ly lz b">kubectl edit service ingress-nginx-controller -n ingress-nginx</code>。找到<code class="fe lw lx ly lz b">spec.type</code>字段，将其从<code class="fe lw lx ly lz b">NodePort</code>更改为<code class="fe lw lx ly lz b">LoadBalancer</code>。现在，当我们运行<code class="fe lw lx ly lz b">kubectl get all -n ingress-nginx</code>时，我们可以看到类型已更改为<code class="fe lw lx ly lz b">LoadBalancer</code>，并且它有一个外部IP地址。</p><pre class="kj kk kl km gt ma lz mb mc aw md bi"><span id="4ea3" class="me mf it lz b gy mg mh l mi mj">service/ingress-nginx-controller             LoadBalancer   10.96.223.195   192.168.122.240   80:32688/TCP,443:32569/TCP   4m36s</span></pre><p id="4b27" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">IP地址是从MetalLB分配的，您的地址可能会有所不同。如果我们把地址卷起来，我们会得到:</p><pre class="kj kk kl km gt ma lz mb mc aw md bi"><span id="0786" class="me mf it lz b gy mg mh l mi mj">rkamradt@beast:~/scratch$ curl <a class="ae ky" href="http://192.168.122.240" rel="noopener ugc nofollow" target="_blank">http://192.168.122.240</a><br/>&lt;html&gt;<br/>&lt;head&gt;&lt;title&gt;404 Not Found&lt;/title&gt;&lt;/head&gt;<br/>&lt;body&gt;<br/>&lt;center&gt;&lt;h1&gt;404 Not Found&lt;/h1&gt;&lt;/center&gt;<br/>&lt;hr&gt;&lt;center&gt;nginx/1.17.8&lt;/center&gt;<br/>&lt;/body&gt;<br/>&lt;/html&gt;</span></pre><p id="1442" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在我们可以配置我们的入口点。有许多不同的选项，包括虚拟主机、路径重定向和https终止。但是我们会从非常简单的开始。创建一个名为<code class="fe lw lx ly lz b">simple-ingress.yaml</code>的文件，并向其中添加以下内容:</p><pre class="kj kk kl km gt ma lz mb mc aw md bi"><span id="d17a" class="me mf it lz b gy mg mh l mi mj">apiVersion: networking.k8s.io/v1beta1<br/>kind: Ingress<br/>metadata:<br/>  name: test-ingress<br/>  annotations:<br/>    nginx.ingress.kubernetes.io/rewrite-target: /<br/>spec:<br/>  rules:<br/>  - http:<br/>      paths:<br/>      - path: /testpath<br/>        pathType: Prefix<br/>        backend:<br/>          serviceName: hellok8s-service<br/>          servicePort: 8080</span></pre><p id="1700" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">用<code class="fe lw lx ly lz b">kubectl apply -f simple-ingress.yaml</code>启动。这将配置摄取服务将所有以<code class="fe lw lx ly lz b">/testpath</code>为路径的请求转发到<code class="fe lw lx ly lz b">hellok8s-service</code>。尝试一下:</p><pre class="kj kk kl km gt ma lz mb mc aw md bi"><span id="cd83" class="me mf it lz b gy mg mh l mi mj">rkamradt@beast:~/scratch$ curl <a class="ae ky" href="http://192.168.122.240/testpath" rel="noopener ugc nofollow" target="_blank">http://192.168.122.240/testpath</a><br/>Hello World</span></pre><p id="f646" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">但是没有路径再次卷曲<code class="fe lw lx ly lz b">/testpath</code>它仍然是404页:</p><pre class="kj kk kl km gt ma lz mb mc aw md bi"><span id="de52" class="me mf it lz b gy mg mh l mi mj">rkamradt@beast:~/scratch$ curl <a class="ae ky" href="http://192.168.122.240" rel="noopener ugc nofollow" target="_blank">http://192.168.122.240</a><br/>&lt;html&gt;<br/>&lt;head&gt;&lt;title&gt;404 Not Found&lt;/title&gt;&lt;/head&gt;<br/>&lt;body&gt;<br/>&lt;center&gt;&lt;h1&gt;404 Not Found&lt;/h1&gt;&lt;/center&gt;<br/>&lt;hr&gt;&lt;center&gt;nginx/1.17.8&lt;/center&gt;<br/>&lt;/body&gt;<br/>&lt;/html&gt;</span></pre><p id="3e43" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们可以更改入口规则，让不同的路径连接到不同的服务，或者使用虚拟主机连接到基于<code class="fe lw lx ly lz b">Host</code>报头的不同服务。如果你不喜欢标准的Nginx 404页面，你也可以定义一个默认入口。</p><p id="4359" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">但是还有一个问题:如果我用笔记本电脑上的浏览器去<code class="fe lw lx ly lz b"><a class="ae ky" href="http://192.168.122.240/testpath," rel="noopener ugc nofollow" target="_blank">http://192.168.122.240/testpath</a></code> <a class="ae ky" href="http://192.168.122.240/testpath," rel="noopener ugc nofollow" target="_blank">，</a>我会得到一个错误。我们需要以某种方式从我们的家庭网络路由到<code class="fe lw lx ly lz b">192.168.122.0/24</code>网络。这需要一点Linux网络方面的技能。</p><p id="840f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe lw lx ly lz b">192.168.122.0/24</code>网络从何而来？这是KVM的默认桥接网络。我们创建的所有虚拟机都获得分配给该范围的IP地址。MetalLB也使用该网络来分配某个池中的地址(我的配置是<code class="fe lw lx ly lz b">192.168.122.240-192.168.122.250</code>)您可以通过运行<code class="fe lw lx ly lz b">sudo virsh net-edit default</code>找到KVM分配的地址。您可以看到输出，并确保它不会干扰MetalLB使用的范围:</p><pre class="kj kk kl km gt ma lz mb mc aw md bi"><span id="6b64" class="me mf it lz b gy mg mh l mi mj">&lt;network&gt;<br/>  &lt;name&gt;default&lt;/name&gt;<br/>  &lt;uuid&gt;dc658641-aded-465d-b472-1cc427c76626&lt;/uuid&gt;<br/>  &lt;forward mode='nat'/&gt;<br/>  &lt;bridge name='virbr0' stp='on' delay='0'/&gt;<br/>  &lt;mac address='52:54:00:1d:5b:25'/&gt;<br/>  &lt;ip address='192.168.122.1' netmask='255.255.255.0'&gt;<br/>    &lt;dhcp&gt;<br/>      &lt;range start='192.168.122.2' end='192.168.122.232'/&gt;<br/>    &lt;/dhcp&gt;<br/>  &lt;/ip&gt;<br/>&lt;/network&gt;</span></pre><p id="4436" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我将我的<code class="fe lw lx ly lz b">dhcp</code>范围设置为在<code class="fe lw lx ly lz b">192.168.122.232</code>处结束，这样它就不会干扰MetalLB的范围。您还会看到转发模式是<code class="fe lw lx ly lz b">nat</code>，因此它的行为类似于您的家庭路由器，流量可以出去，但外部世界无法发起连接。</p><p id="f5ab" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">但是主主机有一个到这个网络的“入口”,它可以不通过NAT访问网桥。如果主主机能看到的话，我应该可以玩玩<code class="fe lw lx ly lz b">iptables</code>和port forward。确保关闭您的主主机上可能正在监听端口80或443的任何服务。下面是我用来完成这一任务的命令:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ml mm l"/></div></figure><p id="b210" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">您必须使用<code class="fe lw lx ly lz b">sudo /bin/bash</code>以root用户身份运行所有这些命令(或者给每个命令加上前缀<code class="fe lw lx ly lz b">sudo</code>)。在浏览器中打开<code class="fe lw lx ly lz b">http://&lt;mainhost&gt;/testpath</code>进行测试。我第一次就成功了！然后，您可以使您的更改永久化。我可以使用<code class="fe lw lx ly lz b">apt-get install iptables-persistent</code>将规则保存到<code class="fe lw lx ly lz b">/etc/iptables/rules.v4</code>中，这些规则会在重启时自动加载。您的特定Linux发行版可能需要不同的保存方式。</p><p id="c384" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">您可能也想开放额外的端口，但是通过只开放两个端口，您可以保持简单的入口安全。我甚至可能会移除端口80的入口，并强制人们使用443。也就是说，只要我把HTTPS安顿好。</p><p id="a8c1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这就把我带到了下一个部分:设置HTTPS。现在，HTTPS、SSL和TLS为互联网提供了极大的安全性。但是他们也让很多程序员拔了头发。即使你写的应用程序不会终止HTTPS，最终你也会被要求用一个奇怪的证书给HTTPS的服务打电话。为什么证书这么难处理？首先，它们需要来自官方认证机构(CA)。其次，证书中的通用名称(CN)值必须与主机名匹配，以确保您在浏览器中键入的主机名与服务器提供的证书匹配。这不仅适用于浏览器访问，也适用于应用程序访问。</p><p id="b70f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">缓解这种情况的一种方法是让一台服务器提供所有的入口和终端HTTPS。当我说“终止HTTPS”时，这意味着入口服务器提供证书，然后以普通HTTP将请求转发给应用程序。这就是我喜欢称之为“外骨骼安全”的东西，因为你的安全是由你只有一个入口这一事实提供的，而且它可以被锁得很紧。</p><p id="e678" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">事实上，我们无法路由到KVM桥接网络，除非在主主机的IP表中制定特定的规则，这为我们提供了安全性。当您有多个主机或云主机，而您不知道它们的确切位置时，这就有点困难了，但是子网隔离仍然存在，应该可以提供您需要的外骨骼。它还减少了在应用程序中进行HTTPS处理的需要，而这本身就是一个安全风险。</p><p id="3920" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果我们在Chrome上使用HTTPS浏览我们的新服务，我们会看到这个屏幕:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi mn"><img src="../Images/1ebccf4df0695b72b6154e023a8e127b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*qk-szW_KpSSFyEw_4fqfvQ.png"/></div></div></figure><p id="a13e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">其他浏览器可能会显示不同的屏幕。这是为了看起来吓人；如果这是互联网上的一个真实网站，我肯定会点击“返回安全”按钮。安装Nginx时，它会创建一个自签名证书。单击“高级”按钮可以获得更多信息:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi mo"><img src="../Images/c8f051b36ec0d438bfe12a563e877b6e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*SfOR4mMpWa9YwD6gPaUqyQ.png"/></div></div></figure><p id="7542" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在你可以设置Chrome来信任你的证书，但是因为没有存储可信证书的标准位置，你可能使用的每个浏览器(以及可能从这个URL读取的每个编程语言)都需要配置为信任这个证书。</p><p id="b2a2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">通过点击“前进到野兽(不安全)”链接，你会得到你的“你好世界”。如果你点击网址旁边的“不安全”，它会告诉你为什么它认为它不安全。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi mp"><img src="../Images/364e633be18c905e4b8ba79bd209a735.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*kc-Y6dT5PMShkeAYoQpZWg.png"/></div></div></figure><p id="ad2c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">点击“证书(无效)”链接，您将看到Nginx为您创建的证书。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi mq"><img src="../Images/422a1baef5171f51f28619e8d2edf067.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*9R61iyq59esmmeUvtRlPQQ.png"/></div></div></figure><p id="ae28" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">因此，不仅这个证书没有经过第三方(CA)的验证，通常的名称(应该是主机名)是“Kubernetes Ingress Controller假证书”。</p><p id="fd3c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如上所述，这不是一个创建生产系统的教程。这是为了学习Kubernetes的基本知识，所以你可以更好地准备创建一个生产系统。我们可以让它保持原样，让你在每次访问时点击警告。(我经历过很多让你这样做的工作场所)。但是让我们更进一步，在Kubernetes中安装一个证书管理器，它将允许我们从CA为每个入口创建证书。</p><p id="1ac6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们将使用最初命名的<a class="ae ky" href="https://cert-manager.io/" rel="noopener ugc nofollow" target="_blank">证书管理器</a>作为我们的证书管理器。要安装基本管理器系统所需的所有工件，请使用以下命令:</p><pre class="kj kk kl km gt ma lz mb mc aw md bi"><span id="9de9" class="me mf it lz b gy mg mh l mi mj">kubectl apply --validate=false -f <a class="ae ky" href="https://github.com/jetstack/cert-manager/releases/download/v0.14.2/cert-manager.yaml" rel="noopener ugc nofollow" target="_blank">https://github.com/jetstack/cert-manager/releases/download/v0.14.2/cert-manager.yaml</a></span></pre><p id="c27a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这将创建名称空间调用<code class="fe lw lx ly lz b">cert-manager</code>。用<code class="fe lw lx ly lz b">kubectl get all -n cert-manager</code>可以看到所有的神器。</p><pre class="kj kk kl km gt ma lz mb mc aw md bi"><span id="5a05" class="me mf it lz b gy mg mh l mi mj">rkamradt@beast:~/scratch$ kubectl get all -n cert-manager<br/>NAME                                          READY   STATUS    RESTARTS   AGE<br/>pod/cert-manager-74d6c4d49b-md4lf             1/1     Running   1          22h<br/>pod/cert-manager-cainjector-77bc84779-7vhgj   1/1     Running   1          22h<br/>pod/cert-manager-webhook-5b5485577f-6csgf     1/1     Running   1          22h</span><span id="39d6" class="me mf it lz b gy mk mh l mi mj">NAME                           TYPE        CLUSTER-IP      EXTERNAL-IP   PORT(S)    AGE<br/>service/cert-manager           ClusterIP   10.100.138.27   &lt;none&gt;        9402/TCP   22h<br/>service/cert-manager-webhook   ClusterIP   10.97.218.179   &lt;none&gt;        443/TCP    22h</span><span id="c49f" class="me mf it lz b gy mk mh l mi mj">NAME                                      READY   UP-TO-DATE   AVAILABLE   AGE<br/>deployment.apps/cert-manager              1/1     1            1           22h<br/>deployment.apps/cert-manager-cainjector   1/1     1            1           22h<br/>deployment.apps/cert-manager-webhook      1/1     1            1           22h</span><span id="0b07" class="me mf it lz b gy mk mh l mi mj">NAME                                                DESIRED   CURRENT   READY   AGE<br/>replicaset.apps/cert-manager-74d6c4d49b             1         1         1       22h<br/>replicaset.apps/cert-manager-cainjector-77bc84779   1         1         1       22h<br/>replicaset.apps/cert-manager-webhook-5b5485577f     1         1         1       22h</span></pre><p id="1a69" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在我们应该有一个来自CA的证书。我们将创建自己的CA并生成一个根证书，证书管理器可以用它来签署单个证书。它们仍然不会被您的浏览器信任，但是您只需在浏览器上安装一个根证书，就可以信任由此创建的任何证书，而且离使用真正的CA只有一步之遥。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ml mm l"/></div></figure><p id="3ad7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这将创建两个文件，ca.key和ca . CRT。<code class="fe lw lx ly lz b">key</code>文件是你的私人密钥，需要保密。<code class="fe lw lx ly lz b">crt</code>文件是您的公共根证书，您可以将其安装在浏览器中。代表您的新CA创建证书需要<code class="fe lw lx ly lz b">key</code>文件，因此需要绝对保密。你必须让任何你想信任的人拥有<code class="fe lw lx ly lz b">crt</code>文件。<code class="fe lw lx ly lz b">crt </code>文件是base-64编码的，所以它只是文本，如果你想的话可以打印出来。</p><p id="45d5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">上面代码片段的最后两行将允许它被用作一个秘密。第三行删除密码短语，第四行在Kubernetes中创建秘密。证书管理器将使用这个秘密来创建一个<code class="fe lw lx ly lz b">Issuer</code>。创建一个名为<code class="fe lw lx ly lz b">issuer.yaml</code>的文件，并插入以下内容:</p><pre class="kj kk kl km gt ma lz mb mc aw md bi"><span id="7510" class="me mf it lz b gy mg mh l mi mj">apiVersion: cert-manager.io/v1alpha2<br/>kind: Issuer<br/>metadata:<br/>  name: ca-issuer<br/>spec:<br/>  ca:<br/>    secretName: ca-key-pair</span></pre><p id="c0ac" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这创建了一个名为<code class="fe lw lx ly lz b">ca-issuer</code>的<code class="fe lw lx ly lz b">Issuer</code>，并关联了我们刚刚创建的CA证书秘密。现在可以根据需要要求发行者发行证书。让我们创建一个将使用虚拟主机名并为其颁发证书的入口。创建一个名为<code class="fe lw lx ly lz b">vhost-ingress.yaml</code>的文件，并添加以下内容:</p><pre class="kj kk kl km gt ma lz mb mc aw md bi"><span id="e0f0" class="me mf it lz b gy mg mh l mi mj">apiVersion: networking.k8s.io/v1beta1<br/>kind: Ingress<br/>metadata:<br/>  name: test-ingress<br/>  annotations:<br/>    cert-manager.io/issuer: ca-issuer <br/>spec:<br/>  rules:<br/>  - host: helloworld.local<br/>    http:<br/>      paths:<br/>      - backend:<br/>          serviceName: hellok8s-service<br/>          servicePort: 8080<br/>        path: /<br/>  tls:<br/>  - hosts:<br/>    - helloworld.local<br/>    secretName: myingress-cert</span></pre><p id="2813" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在这个文件中，<code class="fe lw lx ly lz b">cert-manager.io/issuer</code>注释告诉它使用哪个发行者来发行证书，在本例中，就是我们刚刚创建的那个。在<code class="fe lw lx ly lz b">spec.rules</code>下，我们将主机设置为<code class="fe lw lx ly lz b">helloworld.local</code>。最后，我们添加了<code class="fe lw lx ly lz b">tls</code>部分，说明为<code class="fe lw lx ly lz b">helloworld.local</code>创建一个证书，并将其存储在secret <code class="fe lw lx ly lz b">myingress-cert</code>中，供Nginx ingress使用。</p><p id="59ea" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在，我们可以以正常方式将它们添加到系统中:</p><pre class="kj kk kl km gt ma lz mb mc aw md bi"><span id="c77c" class="me mf it lz b gy mg mh l mi mj">kubectl apply -f issuer.yaml<br/>kubectl apply -f vhost-ingress.yaml</span></pre><p id="dde4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">运行<code class="fe lw lx ly lz b">kubectl get secrets myingress-cert</code>查看生成的证书。</p><p id="3f0c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">回到您的开发机器上，您可以在<code class="fe lw lx ly lz b">/etc/hosts</code>文件中添加<code class="fe lw lx ly lz b">helloworld.local</code>作为主主机的别名。然后浏览到<a class="ae ky" href="https://helloworld.local" rel="noopener ugc nofollow" target="_blank">https://hello world . local</a>。您应该会得到同样的警告，因为我们的系统还不信任新的根证书。但是点击通过警告，并再次看看证书。应该是新证书，而不是伪Nginx证书。</p><p id="9775" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果你在macOS上运行Chrome，你可以将它添加到Mac钥匙串上的可信证书中。打开钥匙串工具并选择系统标签。然后，在“文件”菜单下，选择“导入项目”。选择您从主主机复制的证书(ca.crt)。导入后，它应该出现在您的证书列表中，但应该有一个红色的X，表示它还不可信。双击它，并将信任设置为全部。现在，如果您刷新<a class="ae ky" href="https://helloworld.local," rel="noopener ugc nofollow" target="_blank"> https://helloworld.local，</a>它应该显示为可信。如果您点按URL旁边的锁图标，您将看到证书及其受信任根的详细信息。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi mq"><img src="../Images/d09c9aa8b9cfda92815cc2d82d6a4083.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ElDWUWx_E2-fFQA3NB-txw.png"/></div></div></figure><p id="b412" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">它将在三个月后到期，但如果我理解cert-manager，它将根据需要创建一个新的。相当漂亮！如果您运行的是另一个浏览器或另一个操作系统，我相信您可以找到安装根证书的说明。</p><p id="4982" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">仅仅为一个虚拟主机创建一个CA并安装一个证书管理器可能有点过了。但是现在，我可以通过添加另一个入口和更新我的<code class="fe lw lx ly lz b">/etc/hosts</code>文件，用虚拟主机和https为我的系统添加服务。虽然我们离生产系统还很远，但我们已经走了很长的路，并解决了许多问题。如果你有一个域名，你可以很容易地使用像LetsEncrypt这样的服务。cert-manager组件具有内置的LetsEncrypt配置。</p><p id="560d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这是一篇又长又复杂的文章，我希望你坚持到底。我们解决了很多问题，我知道我学到了很多。我希望你也有，谢谢你与我分享这段旅程。所有用到的脚本都可以在我的<a class="ae ky" href="https://github.com/rkamradt/KubernetesFromScratchScripts/tree/v1.1" rel="noopener ugc nofollow" target="_blank"> GitHub页面</a>上找到。</p></div></div>    
</body>
</html>