<html>
<head>
<title>Self-modifying Malware in Rust</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Rust中的自我修改恶意软件</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/self-modify-malware-in-rust-b8b669dc2e93?source=collection_archive---------3-----------------------#2022-09-02">https://betterprogramming.pub/self-modify-malware-in-rust-b8b669dc2e93?source=collection_archive---------3-----------------------#2022-09-02</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="b711" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">在本教程中，我们将深入研究Rust为我们提供的执行操作的工具，这些操作在C/C++中是乏味且难以测试的，就像恶意软件可以安全地修改自己一样。</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/415da1f86ce6d5f04138b3ddf566dad3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*R6pazy_eq5Be5p7K"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated"><a class="ae kv" href="https://unsplash.com/@cdc?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">疾控中心</a>在<a class="ae kv" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>拍摄的照片</p></figure><p id="b2f1" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">首先，当恶意软件修改自身时，它所做的只是对其可执行文件进行更改，从而导致哈希签名完全改变。</p><p id="9637" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">对可执行文件进行更改很简单。你以书面形式打开文件，选择一个位置并改变字节。复杂的事情在于知道在哪里进行所述的改变，以便它不影响功能。</p><p id="82ac" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">后者以<code class="fe ls lt lu lv b">corewars</code>为例，这是一种饥饿游戏竞赛，其中小块代码修改了所有人共享的一部分内存，并且在其中它们相遇使其余部分变得不可用。</p><h1 id="2e89" class="lw lx iq bd ly lz ma mb mc md me mf mg jw mh jx mi jz mj ka mk kc ml kd mm mn bi translated">程序概要</h1><p id="4b45" class="pw-post-body-paragraph kw kx iq ky b kz mo jr lb lc mp ju le lf mq lh li lj mr ll lm ln ms lp lq lr ij bi translated">为了避免使可执行文件不可用，我们必须找出哪些区域包含程序不使用的数据:</p><ul class=""><li id="0e29" class="mt mu iq ky b kz la lc ld lf mv lj mw ln mx lr my mz na nb bi translated">未使用的文本字符串</li><li id="007b" class="mt mu iq ky b kz nc lc nd lf ne lj nf ln ng lr my mz na nb bi translated">数字变量</li><li id="06cb" class="mt mu iq ky b kz nc lc nd lf ne lj nf ln ng lr my mz na nb bi translated">可执行部分</li><li id="3fb0" class="mt mu iq ky b kz nc lc nd lf ne lj nf ln ng lr my mz na nb bi">…</li></ul><p id="f680" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在这种情况下，为了简单起见，我们将选择修改程序中名为。“rsrc ”,通常包含程序使用的资源:图标、图像和对话框。</p><p id="2334" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">图标是一个只显示的资源，可以在不影响程序本身的情况下轻松编辑。我们只需要确保图标标题保持不变。因此，在这个图标中，我们将存储一个程序已经执行了多少次的计数器。</p><p id="ec4b" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">接下来的步骤是:</p><ol class=""><li id="2cea" class="mt mu iq ky b kz la lc ld lf mv lj mw ln mx lr nh mz na nb bi translated">将可执行文件复制到一个新的临时文件中。</li><li id="05d4" class="mt mu iq ky b kz nc lc nd lf ne lj nf ln ng lr nh mz na nb bi translated">以读写方式打开新文件。</li><li id="6e43" class="mt mu iq ky b kz nc lc nd lf ne lj nf ln ng lr nh mz na nb bi translated">定位到”。rsrc”部分。</li><li id="a909" class="mt mu iq ky b kz nc lc nd lf ne lj nf ln ng lr nh mz na nb bi translated">解析该部分并定位图标资源。</li><li id="7dff" class="mt mu iq ky b kz nc lc nd lf ne lj nf ln ng lr nh mz na nb bi translated">从文件开始处获取256字节的计数器。</li><li id="7463" class="mt mu iq ky b kz nc lc nd lf ne lj nf ln ng lr nh mz na nb bi translated">修改计数器。</li><li id="e2e1" class="mt mu iq ky b kz nc lc nd lf ne lj nf ln ng lr nh mz na nb bi translated">保存文件。</li><li id="c262" class="mt mu iq ky b kz nc lc nd lf ne lj nf ln ng lr nh mz na nb bi translated">用新的可执行文件替换原来的可执行文件。</li></ol><h1 id="669d" class="lw lx iq bd ly lz ma mb mc md me mf mg jw mh jx mi jz mj ka mk kc ml kd mm mn bi translated">该编码了！</h1><p id="76a8" class="pw-post-body-paragraph kw kx iq ky b kz mo jr lb lc mp ju le lf mq lh li lj mr ll lm ln ms lp lq lr ij bi translated">首先导入库:</p><pre class="kg kh ki kj gt ni lv nj nk aw nl bi"><span id="429e" class="nm lx iq lv b gy nn no l np nq">[package]<br/>name = "privacy"<br/>version = "0.1.0"<br/>edition = "2021"</span><span id="6527" class="nm lx iq lv b gy nr no l np nq">[dependencies]<br/>memmap2 = "0.5"<br/>object = "0.28"<br/>anyhow = "1.0"</span><span id="fc5f" class="nm lx iq lv b gy nr no l np nq">[profile.dev]<br/>panic = "abort"</span><span id="8cfe" class="nm lx iq lv b gy nr no l np nq">[profile.release]<br/>panic = "abort"<br/>rpath = false<br/>split-debuginfo = "off"<br/>strip = true</span><span id="2530" class="nm lx iq lv b gy nr no l np nq">[target.'cfg(windows)'.build-dependencies]<br/>winres = "0.1"<br/>static_vcruntime = "2.0"</span></pre><p id="a24d" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在可执行文件中添加图标资源的构建脚本:</p><pre class="kg kh ki kj gt ni lv nj nk aw nl bi"><span id="2ade" class="nm lx iq lv b gy nn no l np nq">use std::io;<br/>#[cfg(windows)] use winres::WindowsResource;<br/>#[cfg(windows)] use static_vcruntime;</span><span id="51e0" class="nm lx iq lv b gy nr no l np nq">fn main() -&gt; io::Result&lt;()&gt; {<br/>    #[cfg(windows)] {<br/>        static_vcruntime::metabuild();<br/>        WindowsResource::new()<br/>            .set_icon("icon.ico")<br/>            .compile()?;<br/>    }<br/>    Ok(())<br/>}</span></pre><p id="e732" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">和代码本身。首先，让我们编写一个函数，通过名称获取一个部分的位置:</p><pre class="kg kh ki kj gt ni lv nj nk aw nl bi"><span id="329e" class="nm lx iq lv b gy nn no l np nq">fn get_section(file: &amp;File, name: &amp;str) -&gt; Option&lt;(u64, u64)&gt; {<br/>    for section in file.sections() {<br/>        match section.name() {<br/>            Ok(n) if n == name =&gt; {<br/>                return section.file_range();<br/>            }<br/>            _ =&gt; {}<br/>        }<br/>    }<br/>    None<br/>}</span></pre><p id="466e" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">一个简单的主要功能:</p><pre class="kg kh ki kj gt ni lv nj nk aw nl bi"><span id="0660" class="nm lx iq lv b gy nn no l np nq">fn main() -&gt; Result&lt;(), Box&lt;dyn Error&gt;&gt; {<br/>    let run_count = run_count()?;<br/>    println!("Previous run count: {}", run_count);<br/>    let exe = env::current_exe()?;<br/>    let tmp = exe.with_extension("tmp");<br/>    fs::copy(&amp;exe, &amp;tmp)?;<br/>    edit_run_count(&amp;tmp, run_count + 1)?;<br/>    let perms = fs::metadata(&amp;exe)?.permissions();<br/>    fs::set_permissions(&amp;tmp, perms)?;<br/>    fs::rename(&amp;tmp, &amp;exe)?;<br/>    Ok(())<br/>}</span></pre><p id="d53c" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">获取计数器的函数:</p><pre class="kg kh ki kj gt ni lv nj nk aw nl bi"><span id="5c59" class="nm lx iq lv b gy nn no l np nq">fn run_count() -&gt; Result&lt;u64&gt; {<br/>    let exe = env::current_exe()?;<br/>    let file = OpenOptions::new().read(true).write(true).open(&amp;exe)?;<br/>    let buf = unsafe { MmapOptions::new().map_mut(&amp;file)? };<br/>    let file = File::parse(&amp;*buf)?;<br/>    <br/>    match get_section(&amp;file, ".rsrc") {<br/>        Some(range) =&gt; {<br/>            let section_size = range.1 as usize;<br/>            let section_base = range.0 as usize;<br/>            let base_buff = &amp;buf[section_base..(section_base +section_size)];<br/>            let counter_position = localize_counter_section(&amp;buf,section_size, section_base )?;<br/>            let counter = &amp;base_buff[counter_position..counter_position + 8];<br/>            let counter = u64::from_le_bytes(counter.try_into()?);<br/>            return Ok(counter)<br/>        },<br/>        None =&gt; Err(anyhow!("Resource section is missing!"))<br/>    }<br/>}</span></pre><p id="aae3" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">编辑它的人:</p><pre class="kg kh ki kj gt ni lv nj nk aw nl bi"><span id="b3d6" class="nm lx iq lv b gy nn no l np nq">fn edit_run_count(exe : &amp;PathBuf, counter : u64) -&gt; Result&lt;()&gt; {<br/>    let file = OpenOptions::new().read(true).write(true).open(&amp;exe)?;<br/>    let mut buf = unsafe { MmapOptions::new().map_mut(&amp;file)? };<br/>    let file = File::parse(&amp;*buf)?;<br/>    <br/>    match get_section(&amp;file, ".rsrc") {<br/>        Some(range) =&gt; {<br/>            let section_size = range.1 as usize;<br/>            let section_base = range.0 as usize;<br/>            let counter_position = localize_counter_section(&amp;buf,section_size, section_base )?;<br/>            buf[(section_base + counter_position)..(section_base + counter_position + 8)].copy_from_slice(&amp;(counter).to_ne_bytes());<br/>            return Ok(())<br/>        },<br/>        None =&gt; Err(anyhow!("Resource section is missing!"))<br/>    }<br/>}</span></pre><p id="8027" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">定位计数器的功能需要澄清。</p><p id="77c6" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">首先，“的格式。rsrc”部分就像一棵有分支和叶子的树，所以我们需要遍历它来找到我们正在寻找的资源。</p><p id="2776" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">一旦我们找到它，图标的偏移量位置是一个虚拟内存偏移量，所以它不同于文件在磁盘上的偏移量，这就是为什么我们将所有的资源信息存储在一个列表中，以找到虚拟内存和磁盘上的偏移量之间的差异。</p><p id="eeb9" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这个差值是这样计算的:</p><pre class="kg kh ki kj gt ni lv nj nk aw nl bi"><span id="9c14" class="nm lx iq lv b gy nn no l np nq">first_resource_offset - offset_of_last_entry -16 (size of last entry data) -8 (size of last entry header)</span></pre><p id="c82b" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这是在这部分代码中完成的:</p><pre class="kg kh ki kj gt ni lv nj nk aw nl bi"><span id="f1fc" class="nm lx iq lv b gy nn no l np nq">section_contents.sort_by(|a,b|  (a.1).cmp(&amp;b.1));<br/>let file_reposition = section_contents.get(0).unwrap().1 - (max_offset + 16 + 8);<br/>for section in &amp;section_contents {<br/>  if section.3 == 3 { //RT_ICON<br/>    return Ok(section.1 - file_reposition + ICON_COUNTER_POSITION)<br/>  }<br/>}<br/>return Err(anyhow!("Icon is missing!"))</span></pre><p id="e134" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">”的分析。rsrc”部分不在讨论范围内，因为在本文中解释起来很复杂。</p><p id="90c3" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">整个项目可在以下位置找到:</p><div class="ns nt gp gr nu nv"><a href="https://github.com/SecSamDev/self-modifying-malware" rel="noopener  ugc nofollow" target="_blank"><div class="nw ab fo"><div class="nx ab ny cl cj nz"><h2 class="bd ir gy z fp oa fr fs ob fu fw ip bi translated">GitHub-SecSamDev/自我修改-恶意软件:Rust中的自我修改恶意软件</h2><div class="oc l"><h3 class="bd b gy z fp oa fr fs ob fu fw dk translated">Rust中的自我修改恶意软件。通过在…上创建帐户来促进SecSamDev/自我修改恶意软件的开发</h3></div><div class="od l"><p class="bd b dl z fp oa fr fs ob fu fw dk translated">github.com</p></div></div><div class="oe l"><div class="of l og oh oi oe oj kp nv"/></div></div></a></div><p id="0231" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">感谢阅读。</p></div></div>    
</body>
</html>