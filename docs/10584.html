<html>
<head>
<title>Simplifying Lazy Loading in Next.js</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">简化Next.js中的延迟加载</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/lazy-loading-in-next-js-simplified-435681afb18a?source=collection_archive---------1-----------------------#2022-01-17">https://betterprogramming.pub/lazy-loading-in-next-js-simplified-435681afb18a?source=collection_archive---------1-----------------------#2022-01-17</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="aa11" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">减少组件的加载时间</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi kf"><img src="../Images/f47b0f2cc24e7d63d1551811bc7b466e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1280/1*btEjjGu76-cHqBA0Re-aDw.gif"/></div></figure><p id="1d2d" class="pw-post-body-paragraph kn ko iq kp b kq kr jr ks kt ku ju kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">延迟加载是一个概念，我们可以用它来减少web应用程序中特定页面的初始加载时间。</p><p id="7885" class="pw-post-body-paragraph kn ko iq kp b kq kr jr ks kt ku ju kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">在正常情况下，当用户最初加载页面时，页面的所有内容都会被加载，然而，有时用户并不关心页面底部的内容，也懒得滚动。所以加载所有内容都将是徒劳的。</p><p id="3c71" class="pw-post-body-paragraph kn ko iq kp b kq kr jr ks kt ku ju kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">通过使用延迟加载，我们根据用户的需求呈现内容，所以当用户向下滚动时，我们逐渐加载内容，而不是在页面的初始呈现期间。</p><p id="6587" class="pw-post-body-paragraph kn ko iq kp b kq kr jr ks kt ku ju kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">在这篇文章中，我将解释我们如何在Next.js中延迟加载组件。但是请记住，这并不适用于在服务器端呈现的组件。</p><p id="9392" class="pw-post-body-paragraph kn ko iq kp b kq kr jr ks kt ku ju kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">设想一个场景，其中您将多个组件加载到一个组件中，比如一个包含许多部分和许多API调用的登录页面。</p><pre class="kg kh ki kj gt lj lk ll lm aw ln bi"><span id="6168" class="lo lp iq lk b gy lq lr l ls lt">import Child1 from "../Child1";<br/>import Child2 from "../Child2";<br/>import Child3 from "../Child3";<br/>import Child4 from "../Child4";<br/>import Child5 from "../Child5";</span><span id="c163" class="lo lp iq lk b gy lu lr l ls lt">const ParentComponent = () =&gt; {<br/>     return &lt;div&gt;<br/>               &lt;Child1/&gt;<br/>               &lt;Child2/&gt;<br/>               &lt;Child3/&gt;<br/>               &lt;Child4/&gt;<br/>               &lt;Child5/&gt;           <br/>         &lt;/div&gt;</span><span id="d3c9" class="lo lp iq lk b gy lu lr l ls lt">}</span></pre><p id="8b9a" class="pw-post-body-paragraph kn ko iq kp b kq kr jr ks kt ku ju kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">假设当用户访问上面的页面时，他们在初始视窗中只能看到<code class="fe lv lw lx lk b">Child1</code>和<code class="fe lv lw lx lk b">Child2</code>内容。</p><p id="0ce4" class="pw-post-body-paragraph kn ko iq kp b kq kr jr ks kt ku ju kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">要查看<code class="fe lv lw lx lk b">Child3</code>组件的内容，用户需要向下滚动。然而，有些用户甚至不需要看到页面底部的内容。</p><p id="fbf1" class="pw-post-body-paragraph kn ko iq kp b kq kr jr ks kt ku ju kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">但是根据我们的代码片段，一旦用户访问页面，所有5个子组件都会呈现，如果这些组件中有任何数据提取逻辑，也会有一些API调用。</p><p id="273a" class="pw-post-body-paragraph kn ko iq kp b kq kr jr ks kt ku ju kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">正如我前面提到的，大多数时候这是不必要的，因为一些用户可能甚至不想看到其余的内容。</p><p id="98c3" class="pw-post-body-paragraph kn ko iq kp b kq kr jr ks kt ku ju kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">这是一个可以使用延迟加载来减少组件加载时间的例子。</p><h1 id="e4ed" class="ly lp iq bd lz ma mb mc md me mf mg mh jw mi jx mj jz mk ka ml kc mm kd mn mo bi translated">让我们把手弄脏吧</h1><ol class=""><li id="2cc4" class="mp mq iq kp b kq mr kt ms kw mt la mu le mv li mw mx my mz bi translated">作为第一步，我们需要一种方法来检测用户滚动时特定组件的可见性。为此，我将使用<code class="fe lv lw lx lk b"><a class="ae na" href="https://developer.mozilla.org/en-US/docs/Web/API/Intersection_Observer_API" rel="noopener ugc nofollow" target="_blank">IntersectionObserver</a></code>。</li></ol><p id="acf7" class="pw-post-body-paragraph kn ko iq kp b kq kr jr ks kt ku ju kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">由于这将被多次使用，我将创建一个<a class="ae na" href="https://reactjs.org/docs/hooks-custom.html" rel="noopener ugc nofollow" target="_blank">自定义钩子</a>。</p><pre class="kg kh ki kj gt lj lk ll lm aw ln bi"><span id="7467" class="lo lp iq lk b gy lq lr l ls lt">import { useState, useEffect } from "react";</span><span id="2a2c" class="lo lp iq lk b gy lu lr l ls lt">const useOnScreen = (ref) =&gt; {<br/>    const [isIntersecting, setIntersecting] = useState(false);</span><span id="b281" class="lo lp iq lk b gy lu lr l ls lt">    useEffect(() =&gt; {<br/>        const observer = new IntersectionObserver(<br/>            ([entry]) =&gt; setIntersecting(entry.isIntersecting)<br/>        );</span><span id="f054" class="lo lp iq lk b gy lu lr l ls lt">       if (ref.current) {<br/>           observer.observe(ref.current);<br/>        }</span><span id="1038" class="lo lp iq lk b gy lu lr l ls lt">    }, [])</span><span id="b2ce" class="lo lp iq lk b gy lu lr l ls lt">    return isIntersecting;<br/>}</span><span id="b8da" class="lo lp iq lk b gy lu lr l ls lt">export default useOnScreen</span></pre><p id="a2d6" class="pw-post-body-paragraph kn ko iq kp b kq kr jr ks kt ku ju kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">这个自定义钩子获取一个ref并观察它。我们使用<code class="fe lv lw lx lk b">isIntersecting</code>状态，并使用条目更新状态。<code class="fe lv lw lx lk b">isIntersecting</code>。从自定义钩子，我们返回<code class="fe lv lw lx lk b">isIntersecting</code>状态。如果<code class="fe lv lw lx lk b">isIntersecting</code>值为真，这意味着用户可以看到ref元素。</p><p id="41b5" class="pw-post-body-paragraph kn ko iq kp b kq kr jr ks kt ku ju kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">2.在下一步中，我们必须为每个子组件创建refs，并使用我们的自定义钩子(<code class="fe lv lw lx lk b">useOnScreen</code>)观察可见性。</p><pre class="kg kh ki kj gt lj lk ll lm aw ln bi"><span id="549d" class="lo lp iq lk b gy lq lr l ls lt">import Child1 from "../Child1";<br/>import Child2 from "../Child2";<br/>import Child3 from "../Child3";<br/>import Child4 from "../Child4";<br/>import Child5 from "../Child5";<br/>import useOnScreen from "../useOnScreen";</span><span id="2279" class="lo lp iq lk b gy lu lr l ls lt">const ParentComponent = () =&gt; {<br/>   const child3Ref = useRef();<br/>   const child3RefValue = useOnScreen(child3Ref);</span><span id="d4ac" class="lo lp iq lk b gy lu lr l ls lt">   return &lt;div&gt;<br/>               &lt;Child1/&gt;       <br/>               &lt;Child2/&gt;<br/>               &lt;div ref={child3Ref}&gt;<br/>                 {child3RefValue &amp;&amp;&lt;Child3/&gt;}<br/>               &lt;/div&gt;<br/>               &lt;Child4/&gt;<br/>               &lt;Child5/&gt;           <br/>         &lt;/div&gt;</span><span id="4e6a" class="lo lp iq lk b gy lu lr l ls lt">}</span></pre><p id="dc4c" class="pw-post-body-paragraph kn ko iq kp b kq kr jr ks kt ku ju kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">现在只有当<code class="fe lv lw lx lk b"><em class="nb">Child3RefValue</em></code> <em class="nb"> </em>为<em class="nb">真时<code class="fe lv lw lx lk b">Child3</code>组件才会渲染。</em>但是还有一个问题。想象一个场景，用户向下滚动，然后再次向后滚动。在这样的情况下，<code class="fe lv lw lx lk b"><em class="nb">child3RefValue</em></code> <em class="nb"> </em>会像假→真→假→真这样更新。</p><p id="e8e5" class="pw-post-body-paragraph kn ko iq kp b kq kr jr ks kt ku ju kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">因此，当值更新为true两次时，整个<code class="fe lv lw lx lk b">Child3</code>组件将呈现两次。我们不需要这种情况发生，因此我们需要防止随后的渲染。</p><p id="e2ec" class="pw-post-body-paragraph kn ko iq kp b kq kr jr ks kt ku ju kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">3.为了防止组件多次渲染，我们必须在<code class="fe lv lw lx lk b">Parent</code>组件中保存一个状态值:</p><pre class="kg kh ki kj gt lj lk ll lm aw ln bi"><span id="f3bc" class="lo lp iq lk b gy lq lr l ls lt">import Child1 from "../Child1";<br/>import Child2 from "../Child2";<br/>import Child3 from "../Child3";<br/>import Child4 from "../Child4";<br/>import Child5 from "../Child5";<br/>import useOnScreen from "../useOnScreen";</span><span id="1dd3" class="lo lp iq lk b gy lu lr l ls lt">const ParentComponent = () =&gt; {<br/>   const child3Ref = useRef();<br/>   const child3RefValue = useOnScreen(child3Ref);<br/>   const [isChild3Ref, setIsChild3Ref] =  useState(false);</span><span id="cb6b" class="lo lp iq lk b gy lu lr l ls lt">useEffect(() =&gt; {<br/>      if (!isChild3Ref)<br/>          setIsChild3Ref(child3RefValue);<br/>   }, [child3RefValue])</span><span id="c9de" class="lo lp iq lk b gy lu lr l ls lt">return &lt;div&gt;<br/>               &lt;Child1/&gt;       <br/>               &lt;Child2/&gt;<br/>               &lt;div ref={child3Ref}&gt;<br/>                 {child3RefValue &amp;&amp; &lt;Child3/&gt;}<br/>               &lt;/div&gt;<br/>               &lt;Child4/&gt;<br/>               &lt;Child5/&gt;          <br/>         &lt;/div&gt;</span><span id="af04" class="lo lp iq lk b gy lu lr l ls lt">}</span></pre><p id="f170" class="pw-post-body-paragraph kn ko iq kp b kq kr jr ks kt ku ju kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">现在，当<code class="fe lv lw lx lk b">child3RefValue</code>改变时，<code class="fe lv lw lx lk b">useEffect</code>将运行，如果只有<code class="fe lv lw lx lk b">isChild3Ref</code>为<code class="fe lv lw lx lk b">false</code>，状态将被更新。根据<code class="fe lv lw lx lk b">isChild3Ref</code>值，<code class="fe lv lw lx lk b">Child3</code>组件将被渲染。因此，即使用户上下滚动几次，组件也只会呈现一次。</p><p id="6a9f" class="pw-post-body-paragraph kn ko iq kp b kq kr jr ks kt ku ju kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">您可以使用<a class="ae na" href="https://nextjs.org/docs/advanced-features/dynamic-import" rel="noopener ugc nofollow" target="_blank"> Next.js动态导入</a> t更进一步，因此只有当<code class="fe lv lw lx lk b">isChild3Ref</code>状态值为真时才会导入<code class="fe lv lw lx lk b">Child3</code>组件。</p><pre class="kg kh ki kj gt lj lk ll lm aw ln bi"><span id="49c1" class="lo lp iq lk b gy lq lr l ls lt">import Child1 from "../Child1";<br/>import Child2 from "../Child2";<br/>import Child4 from "../Child4";<br/>import Child5 from "../Child5";<br/>import useOnScreen from "../useOnScreen";<br/>const Child3 = dynamic(() =&gt; import("../Child3"));</span><span id="d290" class="lo lp iq lk b gy lu lr l ls lt">const ParentComponent = () =&gt; {<br/>   const child3Ref = useRef();<br/>   const child3RefValue = useOnScreen(child3Ref);<br/>   const [isChild3Ref, setIsChild3Ref] =  useState(false);</span><span id="b7b7" class="lo lp iq lk b gy lu lr l ls lt">useEffect(() =&gt; {<br/>      if (!isChild3Ref)<br/>          setIsChild3Ref(child3RefValue);<br/>   }, [child3RefValue])</span><span id="393c" class="lo lp iq lk b gy lu lr l ls lt">return  &lt;div&gt;<br/>               &lt;Child1/&gt;       <br/>               &lt;Child2/&gt;<br/>               &lt;div ref={child3Ref}&gt;<br/>                 {isChild3Ref &amp;&amp; &lt;Child3/&gt;}<br/>               &lt;/div&gt;<br/>               &lt;Child4/&gt;<br/>               &lt;Child5/&gt;         <br/>         &lt;/div&gt;</span><span id="a70a" class="lo lp iq lk b gy lu lr l ls lt">}</span></pre><h1 id="786a" class="ly lp iq bd lz ma mb mc md me mf mg mh jw mi jx mj jz mk ka ml kc mm kd mn mo bi translated">结论</h1><p id="5c10" class="pw-post-body-paragraph kn ko iq kp b kq mr jr ks kt ms ju kv kw nc ky kz la nd lc ld le ne lg lh li ij bi translated">延迟加载是防止页面上出现不必要内容的好方法。通过使用它，您可以最小化页面的初始加载时间，因为子组件将只在用户需要时呈现。当你遇到类似的情况时，不要忘记尝试一下。</p><p id="2f1b" class="pw-post-body-paragraph kn ko iq kp b kq kr jr ks kt ku ju kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">如果你对Next.js更感兴趣，你可以参考<a class="ae na" href="https://medium.com/@kithma/pre-rendering-in-next-js-f042ad18c3c0" rel="noopener">我写的关于Next.js预渲染的文章</a>。</p><p id="def7" class="pw-post-body-paragraph kn ko iq kp b kq kr jr ks kt ku ju kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">编码快乐！</p></div></div>    
</body>
</html>