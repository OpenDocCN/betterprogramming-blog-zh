<html>
<head>
<title>Why Model-Based Testing?</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">为什么是基于模型的测试？</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/why-model-based-testing-fbb14b3621ae?source=collection_archive---------7-----------------------#2020-07-02">https://betterprogramming.pub/why-model-based-testing-fbb14b3621ae?source=collection_archive---------7-----------------------#2020-07-02</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="3a13" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">当我们试图测试系统而不是功能时，事情就变了</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/df1e64b02ec65cee051e4ebb7003b97c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*usjkL3DgIrlwPJ_IlrZhmQ.jpeg"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">照片由<a class="ae ky" href="https://unsplash.com/@helloimnik?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">你好，我是尼克🎞</a>开启<a class="ae ky" href="/s/photos/random?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">防溅</a></p></figure><p id="4989" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在一个使用<a class="ae ky" href="https://jestjs.io/" rel="noopener ugc nofollow" target="_blank"> Jest </a>的普通测试中，您将编写一个测试闭包(<code class="fe lv lw lx ly b">test</code>，<code class="fe lv lw lx ly b">it</code>)，带有一系列固定的命令和断言，这构成了我们的场景。</p><pre class="kj kk kl km gt lz ly ma bn mb mc bi"><span id="a197" class="md me it ly b be mf mg l mh mi">context('No Todos', function () {<br/>  it('starts with nothing', function () =&gt; {<br/>    hasNoItems();<br/>  });<br/><br/>  it('should hide #main and #footer', function () {<br/>    cy.get(selectors.todoItems).should('not.exist');<br/>    // some apps remove elements from the DOM<br/>    // but some just hide them<br/>    cy.get(selectors.main).should('not.be.visible');<br/>    cy.get(selectors.footer).should('not.be.visible');<br/>  })<br/>}</span></pre><p id="d17e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这种方法在我们进行单元测试时非常有意义，因为几乎所有的代码都是琐碎的值转换，所以测试是基于多个输入来确保行为是正确的。</p><p id="1dd2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">当我们试图测试系统而不是纯代码时，事情就变了，这意味着当我们离开单元测试，转而进行端到端(E2E)测试时。</p><p id="5b4c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">用E2E测试来测试一个系统会给人一种单元测试所没有的信心，因为你可以确定整个事情都在工作，如果所有的测试都通过了，所有的行为都到位了。当我们进行单元测试时，这种情况不会发生:在100%的覆盖率之后，如果我们不进行连接，系统甚至可能无法启动。</p><p id="1e52" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">还有另一件事通常在E2E测试中比在单元测试中更常见，那就是场景更难设置和调试。这是因为系统更加复杂。</p></div><div class="ab cl mj mk hx ml" role="separator"><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo"/></div><div class="im in io ip iq"><h1 id="0903" class="mq me it bd mr ms mt mu mv mw mx my mz jz na ka nb kc nc kd nd kf ne kg nf ng bi translated">传统测试的一大缺陷</h1><p id="b203" class="pw-post-body-paragraph kz la it lb b lc nh ju le lf ni jx lh li nj lk ll lm nk lo lp lq nl ls lt lu im bi translated">如果我们把我们的系统看作一个可以接收事件的有限状态机，那么任何事件都可能在任何时刻被触发。但是对于传统的场景，编写每个可能事件的序列是不可行的，所以我们只是先测试快乐的路径，最终，如果发现了bug或者我们喜欢它，就测试其他路径。</p><p id="a030" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我认为这种方法从根本上来说是错误的，并且清楚地显示了我们测试系统的方式中的一个缺陷。如果不是我们制定几个事件组合发送到我们的系统，而是一个过程算法负责执行我们甚至不会想到的命令组合，从而扩大我们测试的场景，会发生什么？嗯，我决定建立这样一个工具。</p></div><div class="ab cl mj mk hx ml" role="separator"><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo"/></div><div class="im in io ip iq"><h1 id="feb5" class="mq me it bd mr ms mt mu mv mw mx my mz jz na ka nb kc nc kd nd kf ne kg nf ng bi translated">构建生成式场景构建器</h1><p id="b28f" class="pw-post-body-paragraph kz la it lb b lc nh ju le lf ni jx lh li nj lk ll lm nk lo lp lq nl ls lt lu im bi translated">我以前和同事讨论过这个想法很多次，看起来像个疯子，所以这次我决定上网查一下。也许其他一些志同道合的人可能会想到同样的事情。</p><p id="90ed" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在搜索了一段时间后，我在一个名为<a class="ae ky" href="https://github.com/dubzzz/fast-check/" rel="noopener ugc nofollow" target="_blank"> fast-check </a>的库中找到了一个非常、非常、非常奇特的类似于这个想法的实现，我以前曾将其用于基于属性的测试。这种方法被称为<em class="nm">基于模型的测试</em>，简而言之，这正是我一直在寻找的。</p></div><div class="ab cl mj mk hx ml" role="separator"><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo"/></div><div class="im in io ip iq"><h1 id="6678" class="mq me it bd mr ms mt mu mv mw mx my mz jz na ka nb kc nc kd nd kf ne kg nf ng bi translated">基于模型的测试</h1><p id="65a7" class="pw-post-body-paragraph kz la it lb b lc nh ju le lf ni jx lh li nj lk ll lm nk lo lp lq nl ls lt lu im bi translated">基于模型的测试太棒了，我都想亲一下！这是我一直在寻找的一切，但我并不知道。</p><p id="f60e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我给你快速检查的官方描述:</p><blockquote class="nn no np"><p id="06e6" class="kz la nm lb b lc ld ju le lf lg jx lh nq lj lk ll nr ln lo lp ns lr ls lt lu im bi translated">基于模型的测试方法已经被引入到快速检查中，以简化UI测试或状态机测试。</p><p id="f34e" class="kz la nm lb b lc ld ju le lf lg jx lh nq lj lk ll nr ln lo lp ns lr ls lt lu im bi translated">该方法的思想是定义可以应用于您的系统的命令。然后，框架挑选零个、一个或多个命令，如果它们可以在当前状态下执行，就按顺序运行它们。”</p></blockquote><p id="80f1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">您编写的命令由两个主要部分组成。一部分是检查:给定模型的当前状态，检查命令是否应该执行。第二部分是执行动作和断言的函数。</p><p id="28ef" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">需要注意的是，命令列表的执行顺序与指定的顺序不同，这正是我们想要的:熵。一旦创建了列表，它们就会按上述顺序运行。这种情况会重复发生，默认情况下会发生100次，所以在每次运行中，我们可以测试100个不同的随机生成的场景。</p></div><div class="ab cl mj mk hx ml" role="separator"><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo"/></div><div class="im in io ip iq"><h1 id="7cea" class="mq me it bd mr ms mt mu mv mw mx my mz jz na ka nb kc nc kd nd kf ne kg nf ng bi translated">真实的例子</h1><p id="d976" class="pw-post-body-paragraph kz la it lb b lc nh ju le lf ni jx lh li nj lk ll lm nk lo lp lq nl ls lt lu im bi translated">在所有这些介绍之后，我们试试基于模型的测试怎么样？</p><p id="f294" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">有什么比测试一个流行的应用程序更好的基于模型的测试方法呢？我决定测试<a class="ae ky" href="http://todomvc.com/" rel="noopener ugc nofollow" target="_blank"> To-Do MVC </a>，前端开发人员最喜欢的项目之一，具体来说，就是To-Do MVC 的<a class="ae ky" href="http://todomvc.com/examples/react" rel="noopener ugc nofollow" target="_blank"> React版本，没有特别的原因，除了我真的很喜欢React。</a></p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nt"><img src="../Images/c394c23ae4ddb0d4e97c8d663c23bacb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*A2RBcWonZrXCu78MeKWGCA.png"/></div></div></figure><h2 id="3409" class="nu me it bd mr nv nw dn mv nx ny dp mz li nz oa nb lm ob oc nd lq od oe nf of bi translated">我注意到的第一件事</h2><p id="8a6d" class="pw-post-body-paragraph kz la it lb b lc nh ju le lf ni jx lh li nj lk ll lm nk lo lp lq nl ls lt lu im bi translated">我注意到的第一件事是这个漂亮的测试列表看起来不像一个普通的Jest报告，因为你将只有一个测试闭包，而不是27个。</p><p id="1f54" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果我们运行原始测试，测试终端报告看起来是这样的:</p><pre class="kj kk kl km gt lz ly og oh aw oi bi"><span id="2853" class="nu me it ly b gy oj ok l ol mi">No Todos<br/>        ✓ should hide #main and #footer (201ms)<br/>      New Todo<br/>        ✓ should allow me to add todo items (548ms)<br/>        ✓ should clear text input field when an item is added (306ms)<br/>        ✓ should trim text input (569ms)<br/>        ✓ should show #main and #footer when items added (405ms)<br/>      Mark all as completed<br/>        ✓ should allow me to mark all items as completed (1040ms)<br/>        ✓ should allow me to clear the completion state of all items (1014ms)<br/>        ✓ complete all checkbox should update state when items are completed (1413ms)<br/>      Item<br/>        ✓ should allow me to mark items as complete (843ms)<br/>        ✓ should allow me to un-mark items as complete (978ms)<br/>        ✓ should allow me to edit an item (1155ms)<br/>        ✓ should show the remove button on hover<br/>      Editing<br/>        ✓ should hide other controls when editing (718ms)<br/>        ✓ should save edits on enter (1093ms)<br/>        ✓ should save edits on blur (1256ms)<br/>        ✓ should trim entered text (1163ms)<br/>        ✓ should remove the item if an empty text string was entered (1033ms)<br/>        ✓ should cancel edits on escape (1115ms)<br/>      Counter<br/>        ✓ should display the current number of todo items (462ms)<br/>      Clear completed button<br/>        ✓ should display the number of completed items (873ms)<br/>        ✓ should remove completed items when clicked (898ms)<br/>        ✓ should be hidden when there are no items that are completed (893ms)<br/>      Persistence<br/>        ✓ should persist its data (3832ms)<br/>      Routing<br/>        ✓ should allow me to display active items (871ms)<br/>        ✓ should allow me to display completed items (960ms)<br/>        ✓ should allow me to display all items (1192ms)<br/>        ✓ should highlight the currently applied filter (1095ms)</span></pre><p id="a736" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">但是如果我们运行基于模型的测试，它看起来会是这样的:</p><pre class="kj kk kl km gt lz ly og oh aw oi bi"><span id="4062" class="nu me it ly b gy oj ok l ol mi">Index<br/>        ✓ Stateless<br/>        ✓ Statefull</span></pre><h2 id="5912" class="nu me it bd mr nv nw dn mv nx ny dp mz li nz oa nb lm ob oc nd lq od oe nf of bi translated">一个很好的特征</h2><p id="b4fb" class="pw-post-body-paragraph kz la it lb b lc nh ju le lf ni jx lh li nj lk ll lm nk lo lp lq nl ls lt lu im bi translated">看完这个，我想，“如果我得到一个错误会怎么样？我不会知道它发生在哪个场景中。”但后来我看到了报道。当然，快速检查有一个漂亮的最小场景，让我们确切地知道播放的命令和失败的结果。所以不需要担心终端报告；它将以可重现的方式准确地显示错误:它将显示一个我们可以复制并设置的<a class="ae ky" href="https://github.com/dubzzz/fast-check/blob/master/documentation/1-Guides/Tips.md#replay-after-failure-for-commands" rel="noopener ugc nofollow" target="_blank">种子</a>，这将准确地生成失败场景。</p><p id="8243" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这要归功于fast-check实现了属性测试框架的一个重要特性，一个非常特殊的调试工具，叫做<em class="nm"> shrinking。</em></p><p id="6fec" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">假设我们生成了一个命令列表，其中一些命令失败了。那么快速检查将尝试创建一个发生相同错误的最小场景。这样，我们可能只调试5个命令，而不是调试30个命令的序列。</p><p id="6ad5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这是我们每次调试时都要做的，但现在是自动化的——谢谢，快速检查！</p><p id="0d4e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我仍然想知道它在其他类型的报告中会是什么样子，但是现在，我只是测试了终端报告，它很好。</p><h2 id="3af9" class="nu me it bd mr nv nw dn mv nx ny dp mz li nz oa nb lm ob oc nd lq od oe nf of bi translated">一个模型来统治他们</h2><p id="f08e" class="pw-post-body-paragraph kz la it lb b lc nh ju le lf ni jx lh li nj lk ll lm nk lo lp lq nl ls lt lu im bi translated">在基于模型的测试中，猜猜会发生什么？您需要一个代表系统当前状态的模型。这是我的todo应用程序:</p><pre class="kj kk kl km gt lz ly ma bn mb mc bi"><span id="758a" class="md me it ly b be mf mg l mh mi">export type ToDoItem = {<br/>  text: string<br/>  completed: boolean<br/>  editing: boolean<br/>}<br/><br/>export type ValidInput = {<br/>  text: string<br/>  type: 'valid'<br/>}<br/><br/>export type TrimInput = {<br/>  text: string<br/>  type: 'trim'<br/>}<br/><br/>export type WhiteSpaceInput = {<br/>  text: string<br/>  type: 'whitespace'<br/>}<br/><br/>export type EmptyInput = {<br/>  text: string<br/>  type: 'empty'<br/>}<br/><br/>export type Model = {<br/>  input: ValidInput | TrimInput | WhiteSpaceInput | EmptyInput,<br/>  toDos: ToDoItem[]<br/>  completeAll: boolean<br/>  filter: 'all' | 'active' | 'completed',<br/>  navigation: Model['filter'][]<br/>};</span></pre><p id="4fc3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">拥有模型的有趣之处在于，我可以做一些我一直想做但在传统测试中做不到的事情:我可以一直对照我的模型检查每一个断言。这就是为什么我的命令的<code class="fe lv lw lx ly b">checkModel</code>中只有一个断言，而这个断言中又包含了所有其他的断言。</p><pre class="kj kk kl km gt lz ly ma bn mb mc bi"><span id="62dd" class="md me it ly b be mf mg l mh mi">export async function checkModel(m: Model) {<br/><br/>  await Promise.all([<br/>    Promise.all([<br/>      checkInput(m),<br/>      checkToDosItems(m),<br/>      checkLocalStorage(m),<br/>      checkCount(m),<br/>      checkToggleAll(m, page),<br/>      checkNewToDo(m),<br/>      checkEditing(m),<br/>      checkClearCompleted(m),<br/>      checkFilterCount(m),<br/>      checkFilterHighlight(m),<br/>    ]),<br/>    Promise.all([<br/>      checkBBBB(m),<br/>    ])<br/>  ])<br/><br/>}</span></pre><p id="9ed3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">每个断言都与模型有关，而与到达模型的步骤无关，因此断言不属于任何测试用例。我认为仅仅测试每个命令中最少的东西是没有意义的。为什么？节省几毫秒一点用都没有。</p><p id="b702" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在传统的测试中，我们只测试与每个场景相关的最少的东西，因为我们不知道整个系统的状态，所以我们一次只关注一件事，但是有了模型，我们总是知道，所以我们总是可以测试一切。</p><p id="207b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果你想看到所有的断言，就去这个<a class="ae ky" href="https://github.com/codingedgar/model-based-test-todoapp/blob/master/expects.ts" rel="noopener ugc nofollow" target="_blank"> GitHub文件</a>。</p></div><div class="ab cl mj mk hx ml" role="separator"><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo"/></div><div class="im in io ip iq"><h1 id="0315" class="mq me it bd mr ms mt mu mv mw mx my mz jz na ka nb kc nc kd nd kf ne kg nf ng bi translated">抽象的大小</h1><p id="e5d3" class="pw-post-body-paragraph kz la it lb b lc nh ju le lf ni jx lh li nj lk ll lm nk lo lp lq nl ls lt lu im bi translated">我开始将每个测试映射到命令。我从“应该允许我添加项目”开始。这个场景选择输入，键入一个条目的文本，并点击Enter，这将输入添加到条目列表中并清除输入。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="om on l"/></div></figure><p id="49da" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我选择将Enter键与另一个命令分开。为什么？因为用户可能会在打字和回车之间做一些事情。</p><p id="4e93" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">但是，有一件很有意思的事情需要注意。并非所有键入的文本都有效。文本在添加到列表之前会被修剪，有些可能什么也不做。这就是为什么我生成了三种不同类型的数据来作为不同的套利交易:<code class="fe lv lw lx ly b">validToDoArbitrary</code>、<code class="fe lv lw lx ly b">whitespaceToDoArbitrary</code>、<code class="fe lv lw lx ly b">trimToDoArbitrary</code>、<code class="fe lv lw lx ly b">emptyToDoArbitrary</code>。这些组合中的每一个都可以后跟一个Enter键，并且每一个都会导致不同的行为。</p><pre class="kj kk kl km gt lz ly ma bn mb mc bi"><span id="51e6" class="md me it ly b be mf mg l mh mi">describe('Index', () =&gt; {<br/><br/>  it(<br/>    'stateful',<br/>    async () =&gt; {<br/><br/>      // try {<br/><br/>      await page.evaluateOnNewDocument(() =&gt; localStorage.clear());<br/><br/>      await fc.assert(<br/>        fc.asyncProperty(<br/>          fc.commands(<br/>            [<br/>              validToDoArbitrary()<br/>                .map(toDo =&gt; new WriteInputCommand(toDo)),<br/>              whitespaceToDoArbitrary()<br/>                .map(toDo =&gt; new WriteInputCommand(toDo)),<br/>              trimToDoArbitrary()<br/>                .map(toDo =&gt; new WriteInputCommand(toDo)),<br/>              emptyToDoArbitrary()<br/>                .map(toDo =&gt; new WriteInputCommand(toDo)),</span></pre><h2 id="9597" class="nu me it bd mr nv nw dn mv nx ny dp mz li nz oa nb lm ob oc nd lq od oe nf of bi translated">一个命令，不同的仲裁</h2><p id="a710" class="pw-post-body-paragraph kz la it lb b lc nh ju le lf ni jx lh li nj lk ll lm nk lo lp lq nl ls lt lu im bi translated">我没有创建多个命令，而是决定创建多个仲裁，因为这些命令具有相同的形式:清除输入(以防之前有任何输入)，键入输入，将其分配给模型，并检查断言。</p><pre class="kj kk kl km gt lz ly ma bn mb mc bi"><span id="e898" class="md me it ly b be mf mg l mh mi">export class WriteInputCommand implements fc.AsyncCommand&lt;ModelMachine, Page, false&gt; {<br/>  constructor(readonly input: Model['input']) { }<br/><br/>  check(_m: Readonly&lt;ModelMachine&gt;) {<br/>    return true;<br/>  };<br/><br/>  async run(m: ModelMachine, page: Page) {<br/><br/>    await clearNewToDo(CLASS_SELECTORS.NEW_TODO)<br/><br/>    await page.type(CLASS_SELECTORS.NEW_TODO, this.input.text)<br/><br/>    m.send(<br/>      {<br/>        type: 'INPUT_ASSIGNED',<br/>        payload: this.input<br/>      }<br/>    )<br/><br/>    await checkModel(m.state.context)<br/>    // .catch(e =&gt; {  throw new Error(e) })<br/><br/>  };<br/><br/>  toString = () =&gt; `${WriteInputCommand.name} ${JSON.stringify(this.input)}`;<br/>}</span></pre><h2 id="3914" class="nu me it bd mr nv nw dn mv nx ny dp mz li nz oa nb lm ob oc nd lq od oe nf of bi translated">粒度</h2><p id="4dc4" class="pw-post-body-paragraph kz la it lb b lc nh ju le lf ni jx lh li nj lk ll lm nk lo lp lq nl ls lt lu im bi translated">在设计命令时，粒度是最难决定的事情。例如，我不确定是否应该让<code class="fe lv lw lx ly b">WriteInputCommand</code>写一个字符串或单个字符。在尝试编写单个字符后，我发现在输入中编写一个长字符串作为<code class="fe lv lw lx ly b">WriteInputCommand</code>序列的可能性非常低，并且字符串arbitrary仍然可以生成单个字符，所以我更改了arbitraries来生成一个字符串。</p><p id="1a2c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">另一个问题是决定是否将Enter命令分开。我认为应该是因为我们确实在打字和写回车之间做动作。从那以后，所有的命令都很容易编写。</p></div><div class="ab cl mj mk hx ml" role="separator"><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo"/></div><div class="im in io ip iq"><h1 id="0703" class="mq me it bd mr ms mt mu mv mw mx my mz jz na ka nb kc nc kd nd kf ne kg nf ng bi translated">没有柏树</h1><p id="b30e" class="pw-post-body-paragraph kz la it lb b lc nh ju le lf ni jx lh li nj lk ll lm nk lo lp lq nl ls lt lu im bi translated">一个非常不幸的不兼容性是我没有预见到的(尽管我应该预见到)，那就是基于模型的测试与最好的UI测试运行程序<a class="ae ky" href="https://www.cypress.io/" rel="noopener ugc nofollow" target="_blank"> Cypress </a>完全不兼容。Cypress有一个非常完整的断言列表，但遗憾的是我们无法使用它。</p><p id="f777" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我没有选择赛普拉斯，而是决定选择<a class="ae ky" href="https://github.com/puppeteer/puppeteer" rel="noopener ugc nofollow" target="_blank">木偶师</a>，据我所知，这是我们能与Jest进行的最好的E2E整合。</p><p id="4f9e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果你想知道为什么，这个<a class="ae ky" href="https://twitter.com/codingedgar/status/1263211794929238023" rel="noopener ugc nofollow" target="_blank"> Twitter帖子可能对</a>有所帮助。总之，柏树的承诺不是承诺；它们是预定的。使用cypress-promise插件可能会有所帮助，但是收缩仍然是一个问题。Cypress充分利用了场景是预定义的、静态的、没有分支的假设，因此过程化的场景超出了他们的哲学范畴。</p><h2 id="fe81" class="nu me it bd mr nv nw dn mv nx ny dp mz li nz oa nb lm ob oc nd lq od oe nf of bi translated">出现了状态管理问题</h2><p id="d324" class="pw-post-body-paragraph kz la it lb b lc nh ju le lf ni jx lh li nj lk ll lm nk lo lp lq nl ls lt lu im bi translated">它花了一段时间才浮出水面，但即使是我们的小模型也会有伴随状态而来的常见状态管理问题。</p><p id="4f65" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">所以仅仅有一个键值映射是不够的。我考虑了两条途径:用一个公共类来用函数处理状态，或者用一个有限状态机来尽可能地保持它的功能性。当然，我选择了后者。</p><p id="7b7a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我的状态机看起来像这样:</p><pre class="kj kk kl km gt lz ly ma bn mb mc bi"><span id="60e6" class="md me it ly b be mf mg l mh mi">export const modelMachine = Machine&lt;Context, Schema, Event&gt;({<br/>  initial: 'DEFAULT',<br/>  strict: true,<br/>  context: {<br/>    toDos: [],<br/>    input: {<br/>      text: '',<br/>      type: STATIC.EMPTY,<br/>    },<br/>    filter: STATIC.ALL,<br/>    completeAll: false,<br/>    navigation: [STATIC.ALL],<br/>  },<br/>  states: {<br/>    DEFAULT: {<br/>      on: {<br/>        TO_DO_ADDED: {<br/>          actions: [<br/>            ACTION.ASSIGN_TO_DO,<br/>          ]<br/>        },<br/>        INPUT_ASSIGNED: {<br/>          actions: [<br/>            ACTION.ASSIGN_INPUT,<br/>          ]<br/>        },<br/>        TOGGLE_ITEM_COMPLETED: {<br/>          actions: [<br/>            ACTION.TOGGLE_ITEM_COMPLETED,<br/>          ]<br/>        },<br/>        EDITED: {<br/>          actions: [<br/>            ACTION.EDIT,<br/>          ]<br/>        },<br/>        TEXT_EDITED: {<br/>          actions: [<br/>            ACTION.EDIT_TEXT,<br/>          ]<br/>        },<br/>        REMOVED_FROM_INDEX: {<br/>          actions: [<br/>            ACTION.REMOVE_FROM_INDEX,<br/>          ]<br/>        },<br/>        COMPLETED_CLEARED: {<br/>          actions: [<br/>            ACTION.CLEAR_COMPLETED,<br/>          ]<br/>        },<br/>        FILTER_SELECTED: {<br/>          actions: [<br/>            ACTION.SELECT_FILTER,<br/>          ]<br/>        },<br/>        WENT_BACK: {<br/>          actions: [<br/>            ACTION.GO_BACK,<br/>          ]<br/>        },<br/>        TOGGLE_ALL_COMPLETED: {<br/>          actions: [<br/>            ACTION.TOGGLE_ALL_COMPLETED,<br/>          ]<br/>        },<br/>      }<br/>    }<br/>  }<br/>})</span></pre><p id="59df" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在所有的状态改变都在机器中执行，而不是每个命令，这使得我们的测试不容易出错。</p></div><div class="ab cl mj mk hx ml" role="separator"><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo"/></div><div class="im in io ip iq"><h1 id="8493" class="mq me it bd mr ms mt mu mv mw mx my mz jz na ka nb kc nc kd nd kf ne kg nf ng bi translated">平衡胜算</h1><p id="8368" class="pw-post-body-paragraph kz la it lb b lc nh ju le lf ni jx lh li nj lk ll lm nk lo lp lq nl ls lt lu im bi translated">有些测试在列表上没有项目的情况下也能工作，但是其他的需要它们。因此，我面临着另一个决定，要么用预加载的项目创建另一个测试用例，要么提高列表中有多个项目的几率。</p><h2 id="549d" class="nu me it bd mr nv nw dn mv nx ny dp mz li nz oa nb lm ob oc nd lq od oe nf of bi translated">另一个测试案例</h2><p id="ff10" class="pw-post-body-paragraph kz la it lb b lc nh ju le lf ni jx lh li nj lk ll lm nk lo lp lq nl ls lt lu im bi translated">如果我决定添加另一个测试用例，它将有预加载的项目。我应该如何添加项目？嗯，我可以从一个常量列表中添加它们，就像在当前的测试中一样，但是我们在这里做的是生成测试。另一个选择是嵌套测试属性。</p><p id="a841" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果我们嵌套快速检查断言，外环将用于在基于属性的测试之后添加项目，内环将包含基于模型的测试之后的命令。</p><pre class="kj kk kl km gt lz ly ma bn mb mc bi"><span id="0592" class="md me it ly b be mf mg l mh mi">await fc.assert(<br/>  fc.asyncProperty(...)<br/>      ...<br/>    async (x) =&gt; {<br/>      await fc.assert(<br/>        fc.asyncProperty(<br/>          fc.commands([...]),<br/>          async (commands) =&gt; {...}),<br/>        {seed: sameAsParent}</span></pre><p id="c03c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">嵌套快速检查断言看起来有点复杂，但是存储库中正在进行一些工作，以允许场景生成，这基本上是嵌套。也许如果早就做好了，我就走这条路了。</p><h2 id="70d6" class="nu me it bd mr nv nw dn mv nx ny dp mz li nz oa nb lm ob oc nd lq od oe nf of bi translated">频率增加</h2><p id="9f4c" class="pw-post-body-paragraph kz la it lb b lc nh ju le lf ni jx lh li nj lk ll lm nk lo lp lq nl ls lt lu im bi translated">众所周知，生成测试玩得很好，有统计工具，因为某些场景都是基于它来玩的。正如所料，快速检查确实有一种方法可以调整命令的频率，所以我们可以更频繁地键入和敲击Enter，增加我们拥有多个项目的几率。</p><p id="bf30" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我认为这是一个非常合理的方法，但不知何故，我觉得这可能是一个脆弱的设置。如果添加新命令最终会影响设置的结果，该怎么办？</p><p id="3e9c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我对频率设置如何影响快速检查缺乏了解，这使我没有走这条路。也许在未来，但现在，我可以尝试另一种更简单的方式来实现选择。</p><h2 id="168c" class="nu me it bd mr nv nw dn mv nx ny dp mz li nz oa nb lm ob oc nd lq od oe nf of bi translated">添加新命令</h2><p id="eedb" class="pw-post-body-paragraph kz la it lb b lc nh ju le lf ni jx lh li nj lk ll lm nk lo lp lq nl ls lt lu im bi translated">最后一个选项是添加一个命令，批量添加随机生成的项目的随机列表。</p><p id="b786" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这个命令有时会运行，有时不会。不管怎样，这两种情况最终都会发生。</p><p id="a460" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这个命令的另一个不同之处可能是条目列表必须有效，这样就不会生成空格或空白。这样，我们可以确保项目将安全地退出列表。</p></div><div class="ab cl mj mk hx ml" role="separator"><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo"/></div><div class="im in io ip iq"><h1 id="4e52" class="mq me it bd mr ms mt mu mv mw mx my mz jz na ka nb kc nc kd nd kf ne kg nf ng bi translated">项目选择</h1><p id="c21f" class="pw-post-body-paragraph kz la it lb b lc nh ju le lf ni jx lh li nj lk ll lm nk lo lp lq nl ls lt lu im bi translated">既然我们已经选择了这条路，我们可以继续为需要不止一个项目的测试编写断言。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi oo"><img src="../Images/53fb57f4188c17f05def9562037f5f2f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1238/format:webp/1*_xmIHZFKVo4hFBmfm-zwPQ.png"/></div></figure><p id="6600" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在官方文档中，这些测试总是选择列表中的第一项来断言事物。但是我们不能这样做；这不是我们的哲学。我们应该从三个项目中随机选择一个，但是我们不确定列表中是否会有三个项目。</p><p id="6d8c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在官方测试中，他们知道他们已经预装了三项，“买些奶酪”、“喂猫”和“预约医生”，但我们不会。我们不知道添加条目的命令是否运行了，或者其他命令是否也运行了，所以基于它是没有用的。</p><p id="c88d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我无法决定该怎么做，所以我问了<a class="ae ky" href="https://github.com/dubzzz" rel="noopener ugc nofollow" target="_blank">尼古拉斯·杜比恩</a>本人，他回答了<a class="ae ky" href="https://github.com/dubzzz/fast-check/issues/603#issuecomment-640420412" rel="noopener ugc nofollow" target="_blank">。简而言之，他告诉我用类似于:<code class="fe lv lw lx ly b">seed % number_of_todos</code>的东西。我发现他的想法既聪明又简单——只需生成一个数字，然后根据我们拥有的商品数量来调整这个数字。我最后写了这个:</a></p><pre class="kj kk kl km gt lz ly ma bn mb mc bi"><span id="48ce" class="md me it ly b be mf mg l mh mi">export function pickToDo(number: number, m: Model) {<br/>  return scale(<br/>    number,<br/>    0,<br/>    m.toDos.length -1,<br/>    0,<br/>    2147483647<br/>  )<br/>}<br/><br/>function scale(n: number, toMin: number, toMax: number, fromMin: number, fromMax: number) {<br/>  return clamp(<br/>    toMin,<br/>    toMax,<br/>    Math.floor(<br/>      (<br/>        (<br/>          (toMax - toMin) * (n - fromMin)<br/>        )<br/>        / (fromMax - fromMin)<br/>      )<br/>      + toMin<br/>    ),<br/>  );<br/>}</span></pre><p id="ec06" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">使用<code class="fe lv lw lx ly b">%</code>看似简洁，但却非常不准确。我想他只是给了我一个缩放指数的想法。这段代码的作用是将<code class="fe lv lw lx ly b">fc.nat()</code>生成的数字的最小值(0)和最大值(2147483647)缩小到模型中的项目数。这样，我们可以简单地<code class="fe lv lw lx ly b">const index = pickTodo(number, model)</code>，我们有一个随机选择的项目。</p><p id="2e26" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这是从官方测试到基于模型的测试的最后一个脑筋急转弯。我面临的其他问题更多的是关于木偶师的断言，但那是另一个故事了。</p></div><div class="ab cl mj mk hx ml" role="separator"><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo"/></div><div class="im in io ip iq"><p id="899d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果你想看到整个回购:<a class="ae ky" href="https://github.com/codingedgar/model-based-test-todoapp" rel="noopener ugc nofollow" target="_blank">https://github.com/codingedgar/model-based-test-todoapp</a>。</p></div><div class="ab cl mj mk hx ml" role="separator"><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo"/></div><div class="im in io ip iq"><p id="7f4d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">非常感谢您的阅读，如果您喜欢这篇文章，请考虑<a class="ae ky" href="http://eepurl.com/hg7AeP" rel="noopener ugc nofollow" target="_blank">订阅我的简讯</a>。</p></div></div>    
</body>
</html>