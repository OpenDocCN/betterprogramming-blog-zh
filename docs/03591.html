<html>
<head>
<title>Manage Your Messy Open-Source Repository With Terminal Tools</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">用终端工具管理混乱的开源库</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/manage-your-messy-open-source-repository-with-terminal-tools-bab9bbec43cc?source=collection_archive---------11-----------------------#2020-02-19">https://betterprogramming.pub/manage-your-messy-open-source-repository-with-terminal-tools-bab9bbec43cc?source=collection_archive---------11-----------------------#2020-02-19</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="c2aa" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">一个方便的终端工具箱，帮助开源维护者让他们的项目闪闪发光</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi ki"><img src="../Images/22589b8de556b1e7444708748a1d1518.png" data-original-src="https://miro.medium.com/v2/resize:fit:1280/format:webp/0*hWPKo1F8FWTs-36y.png"/></div><p class="kq kr gj gh gi ks kt bd b be z dk translated">作者插图</p></figure><p id="ff7b" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">有效的协作，尤其是在开源软件开发中，始于有效的组织。为了确保不遗漏任何东西，一般规则“一个问题，一个拉取请求”是一个很好的经验法则。</p><p id="cebe" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">与其像“修复文档中所有断开的链接”那样打开一个大范围的问题，开源项目更有可能通过几个更小、更易管理的问题吸引贡献者。</p><p id="7535" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">在前面的示例中，您可以按节或按页确定断开链接的范围。这允许更多的贡献者投入他们的时间，而不是等待一个人承担更大更乏味的贡献工作。</p><p id="da48" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">较小范围的问题也有助于项目维护人员看到哪里的工作已经完成，哪里还没有完成。这减少了问题的某些部分被遗漏、被认为已经完成，并在以后导致错误或安全漏洞的机会。</p><p id="be75" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">这一切都很好；但是，如果您已经打开了几个大范围的问题，一些pr已经提交或合并，而您目前不知道工作从哪里开始或停止，该怎么办？</p><p id="ffa2" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">要想让你的项目回到可控状态，需要做一些整理工作。幸运的是，有许多命令行工具可以帮助您扫描、排序和理解混乱的存储库。</p><p id="6024" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">这里是我使用的一个小选择。</p><p id="d139" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">跳转到:</p><ul class=""><li id="dae2" class="lq lr it kw b kx ky la lb ld ls lh lt ll lu lp lv lw lx ly bi translated"><a class="ae lz" href="#interactive-search-and-replace-with-vim" rel="noopener ugc nofollow">与</a>交互搜索并替换<code class="fe ma mb mc md b"><a class="ae lz" href="#interactive-search-and-replace-with-vim" rel="noopener ugc nofollow">vim</a></code></li><li id="5b3e" class="lq lr it kw b kx me la mf ld mg lh mh ll mi lp lv lw lx ly bi translated"><a class="ae lz" href="#find-dead-links-in-markdown-files-with-a-node-module" rel="noopener ugc nofollow">用节点模块找到降价文件中的死链接</a></li><li id="dabb" class="lq lr it kw b kx me la mf ld mg lh mh ll mi lp lv lw lx ly bi translated"><a class="ae lz" href="#list-subdirectories-with-or-without-a-git-repository-with-find" rel="noopener ugc nofollow">用</a> <code class="fe ma mb mc md b"><a class="ae lz" href="#list-subdirectories-with-or-without-a-git-repository-with-find" rel="noopener ugc nofollow">find</a></code>列出有或没有git库的子目录</li><li id="702f" class="lq lr it kw b kx me la mf ld mg lh mh ll mi lp lv lw lx ly bi translated"><a class="ae lz" href="#pull-multiple-git-repositories-from-a-list-with-xargs" rel="noopener ugc nofollow">用</a>T2从一个列表中拉出多个git库</li><li id="905b" class="lq lr it kw b kx me la mf ld mg lh mh ll mi lp lv lw lx ly bi translated"><a class="ae lz" href="#list-issues-by-number-with-jot" rel="noopener ugc nofollow">用</a>和<code class="fe ma mb mc md b"><a class="ae lz" href="#list-issues-by-number-with-jot" rel="noopener ugc nofollow">jot</a></code>按编号列出问题</li></ul></div><div class="ab cl mj mk hx ml" role="separator"><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo"/></div><div class="im in io ip iq"><h1 id="e388" class="mq mr it bd ms mt mu mv mw mx my mz na jz nb ka nc kc nd kd ne kf nf kg ng nh bi translated">交互式搜索-用V替换<code class="fe ma mb mc md b">im</code></h1><p id="f7de" class="pw-post-body-paragraph ku kv it kw b kx ni ju kz la nj jx lc ld nk lf lg lh nl lj lk ll nm ln lo lp im bi translated">您可以在<a class="ae lz" href="https://www.vim.org/" rel="noopener ugc nofollow" target="_blank"> Vim </a>中打开一个文件，然后交互搜索并替换为:</p><pre class="kj kk kl km gt nn md no np aw nq bi"><span id="e82c" class="nr mr it md b gy ns nt l nu nv">:%s/\&lt;word\&gt;/newword/gc</span></pre><p id="66dc" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated"><code class="fe ma mb mc md b">%</code>表示查看当前文件的所有行；<code class="fe ma mb mc md b">s</code>代表替代品；<code class="fe ma mb mc md b">\&lt;word\&gt;</code>匹配整个单词；代表“全局”的<code class="fe ma mb mc md b">g</code>代表每一次事件。</p><p id="8505" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">最后的<code class="fe ma mb mc md b">c</code>可以让你在修改前查看和确认每个修改。你可以自动运行它，而且快得多，不用<code class="fe ma mb mc md b">c</code>；然而，如果您犯了模式匹配错误，您就将自己置于使事情复杂化的风险之中。</p></div><div class="ab cl mj mk hx ml" role="separator"><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo"/></div><div class="im in io ip iq"><h1 id="b9ba" class="mq mr it bd ms mt mu mv mw mx my mz na jz nb ka nc kc nd kd ne kf nf kg ng nh bi translated">用节点模块查找降价文件中的死链接</h1><p id="651c" class="pw-post-body-paragraph ku kv it kw b kx ni ju kz la nj jx lc ld nk lf lg lh nl lj lk ll nm ln lo lp im bi translated"><a class="ae lz" href="https://github.com/tcort/markdown-link-check" rel="noopener ugc nofollow" target="_blank"> markdown-link-check </a>节点模块有一个很棒的<a class="ae lz" href="https://github.com/tcort/markdown-link-check#command-line-tool" rel="noopener ugc nofollow" target="_blank"> CLI伙伴</a>。</p><p id="8a16" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">我经常使用它，我把它变成了一个<a class="ae lz" href="https://victoria.dev/blog/how-to-do-twice-as-much-with-half-the-keystrokes-using-.bashrc/#bash-functions" rel="noopener ugc nofollow" target="_blank"> Bash别名函数</a>。为此，请将此添加到您的<code class="fe ma mb mc md b">.bashrc</code>:</p><pre class="kj kk kl km gt nn md no np aw nq bi"><span id="0a9f" class="nr mr it md b gy ns nt l nu nv"># Markdown link check in a folder, recursive<br/>function mlc () {<br/>find $1 -name \*.md -exec markdown-link-check -p {} \;<br/>}</span></pre><p id="9ff7" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">然后用<code class="fe ma mb mc md b">mlc &lt;filename&gt;</code>跑。</p></div><div class="ab cl mj mk hx ml" role="separator"><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo"/></div><div class="im in io ip iq"><h1 id="c038" class="mq mr it bd ms mt mu mv mw mx my mz na jz nb ka nc kc nd kd ne kf nf kg ng nh bi translated">用<code class="fe ma mb mc md b">find</code>列出有或没有Git存储库的子目录</h1><p id="49be" class="pw-post-body-paragraph ku kv it kw b kx ni ju kz la nj jx lc ld nk lf lg lh nl lj lk ll nm ln lo lp im bi translated">打印作为Git存储库的所有子目录，或者换句话说，其中有一个<code class="fe ma mb mc md b">.git</code>:</p><pre class="kj kk kl km gt nn md no np aw nq bi"><span id="3acf" class="nr mr it md b gy ns nt l nu nv">find . -maxdepth 1 -type d -exec test -e '{}/.git' ';' -printf "is git repo: %p\n"</span></pre><p id="05fb" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">要打印所有不是Git存储库的子目录，用<code class="fe ma mb mc md b">!</code>否定测试:</p><pre class="kj kk kl km gt nn md no np aw nq bi"><span id="3201" class="nr mr it md b gy ns nt l nu nv">find . -maxdepth 1 -type d -exec test '!' -e '{}/.git' ';' -printf "not git repo: %p\n"</span></pre></div><div class="ab cl mj mk hx ml" role="separator"><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo"/></div><div class="im in io ip iq"><h1 id="0ced" class="mq mr it bd ms mt mu mv mw mx my mz na jz nb ka nc kc nd kd ne kf nf kg ng nh bi translated">用<code class="fe ma mb mc md b">xargs</code>从一个列表中拉出多个Git库</h1><p id="fed8" class="pw-post-body-paragraph ku kv it kw b kx ni ju kz la nj jx lc ld nk lf lg lh nl lj lk ll nm ln lo lp im bi translated">我最初用它作为用Bash脚本自动重新创建我的笔记本电脑的一部分，但是当你使用云实例或docker文件时，它非常方便。</p><p id="18f4" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">给定一个文件<code class="fe ma mb mc md b">repos.txt</code>，每行都有一个存储库的SSH链接(并且设置了SSH密钥)，运行:</p><pre class="kj kk kl km gt nn md no np aw nq bi"><span id="6d65" class="nr mr it md b gy ns nt l nu nv">xargs -n1 git clone &lt; repos.txt</span></pre><p id="e6ac" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">如果您想要拉和推许多存储库，我以前写过关于如何使用Bash一行程序来管理您的存储库的文章。</p></div><div class="ab cl mj mk hx ml" role="separator"><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo"/></div><div class="im in io ip iq"><h1 id="ab01" class="mq mr it bd ms mt mu mv mw mx my mz na jz nb ka nc kc nd kd ne kf nf kg ng nh bi translated">用<code class="fe ma mb mc md b">jot</code>按编号列出问题</h1><p id="0ba3" class="pw-post-body-paragraph ku kv it kw b kx ni ju kz la nj jx lc ld nk lf lg lh nl lj lk ll nm ln lo lp im bi translated">我是<a class="ae lz" href="https://github.com/OWASP/wstg" rel="noopener ugc nofollow" target="_blank"> OWASP Web安全测试指南</a>库的合著者和维护者，我最近在那里接受了一个大问题(是的，它是“修复文档中所有损坏的链接”)——你是怎么猜到的？)并把它分成几个更小、更易管理的问题。</p><p id="06d3" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">总共37个更小、更易管理的问题。</p><p id="f7cf" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">我想列举原始问题的所有问题，但是打出37个问题号(#275到#312)的想法似乎非常乏味和耗时。</p><p id="501e" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">因此，按照自然程序员的方式，我花了与输入所有这些数字相同的时间，设计了一种自动化的方法。</p><p id="059b" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated"><code class="fe ma mb mc md b">jot</code>实用程序(<code class="fe ma mb mc md b">apt install athena-jot</code>)是一个很小的工具，当你想打印出一些数字时，它是个很大的帮助。只要告诉它你想要多少，以及从哪里开始和停止。</p><pre class="kj kk kl km gt nn md no np aw nq bi"><span id="8440" class="nr mr it md b gy ns nt l nu nv"># jot [ reps [ begin [ end ] ] ]<br/>jot 37 275 312</span></pre><p id="12e5" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">这将在新的一行中打印从275到312的每个数字。为了使这些成为GitHub和许多其他平台自动识别并转化为链接的问题编号符号，您可以将输出通过管道传输到<code class="fe ma mb mc md b">awk</code>。</p><pre class="kj kk kl km gt nn md no np aw nq bi"><span id="592d" class="nr mr it md b gy ns nt l nu nv">jot 37 275 312 | awk '{printf "#"$0", "}'<br/>#275, #276, #277, #278, #279, #280, #281, #282, #283, #284, #285, #286, #287, #288, #289, #290, #291, #292, #293, #295, #296, #297, #298, #299, #300, #301, #302, #303, #304, #305, #306, #307, #308, #309, #310, #311, #312</span></pre><p id="465c" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">您还可以使用<code class="fe ma mb mc md b">jot</code>来生成随机或冗余数据，主要用于开发或测试目的。</p></div><div class="ab cl mj mk hx ml" role="separator"><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo"/></div><div class="im in io ip iq"><h1 id="7c36" class="mq mr it bd ms mt mu mv mw mx my mz na jz nb ka nc kc nd kd ne kf nf kg ng nh bi translated">CLI支持的开源组织</h1><p id="da46" class="pw-post-body-paragraph ku kv it kw b kx ni ju kz la nj jx lc ld nk lf lg lh nl lj lk ll nm ln lo lp im bi translated">一个组织良好的开源存储库是一个维护良好的开源项目。保存这篇文章作为方便的参考，好好使用你新发现的CLI超能力！</p></div></div>    
</body>
</html>