<html>
<head>
<title>ValueTransformer in Core Data Explained: Storing Absolute URLs</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">核心数据中的ValueTransformer解释:存储绝对URL</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/valuetransformer-in-core-data-explained-storing-absolute-urls-61ee37515690?source=collection_archive---------13-----------------------#2020-07-14">https://betterprogramming.pub/valuetransformer-in-core-data-explained-storing-absolute-urls-61ee37515690?source=collection_archive---------13-----------------------#2020-07-14</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="bd1e" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">一个强大的工具，允许您存储类型，如枚举</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/582fcce26546363460cb9a8ef5ce0e7c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*IOaiGgxK67IM-LVE"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">弗兰克·麦肯纳在<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片。</p></figure><p id="6734" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">核心数据中的ValueTransformers是在将值插入数据库并被读取之前转换值的强大方法。它们设置在一个抽象类中，该类处理从一种表示到另一种表示的值转换。</p><p id="cf8b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">它们通常被用来存储默认情况下不支持的值。核心数据允许您保存字符串和整数之类的类型，但是存储一个<code class="fe lv lw lx ly b">CGRect</code>或<code class="fe lv lw lx ly b">CGPoint</code>需要使用ValueTransformer。一旦你了解了它们是如何工作的，你会发现你也可以在其他情况下使用ValueTransformers(例如，将绝对URL存储为相对URL)。</p></div><div class="ab cl lz ma hx mb" role="separator"><span class="mc bw bk md me mf"/><span class="mc bw bk md me mf"/><span class="mc bw bk md me"/></div><div class="im in io ip iq"><h1 id="d222" class="mg mh it bd mi mj mk ml mm mn mo mp mq jz mr ka ms kc mt kd mu kf mv kg mw mx bi translated">什么是ValueTransformer？</h1><p id="cb16" class="pw-post-body-paragraph kz la it lb b lc my ju le lf mz jx lh li na lk ll lm nb lo lp lq nc ls lt lu im bi translated">一切都在名称中:它转换一个值。更准确地说，它在读取和写入核心数据数据库时转换一个值。</p><p id="cd98" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">ValueTransformer可以接受任何类型作为输入，并返回不同类型的值。一个例子是在插入时将<code class="fe lv lw lx ly b">UIColor</code>转换为<code class="fe lv lw lx ly b">NSData</code>，并且在读取后将其从<code class="fe lv lw lx ly b">NSData</code>转换回<code class="fe lv lw lx ly b">UIColor</code>。</p></div><div class="ab cl lz ma hx mb" role="separator"><span class="mc bw bk md me mf"/><span class="mc bw bk md me mf"/><span class="mc bw bk md me"/></div><div class="im in io ip iq"><h1 id="c67e" class="mg mh it bd mi mj mk ml mm mn mo mp mq jz mr ka ms kc mt kd mu kf mv kg mw mx bi translated">如何在核心数据中使用ValueTransformers？</h1><p id="1101" class="pw-post-body-paragraph kz la it lb b lc my ju le lf mz jx lh li na lk ll lm nb lo lp lq nc ls lt lu im bi translated">ValueTransformer是一个抽象类，它要求您根据要实现的转换来覆盖和实现它的一些方法。一旦定义了ValueTransformer，就应该对它进行注册，以便它可用于您的核心数据模型。最后，您可以将一个属性定义为可转换的，并在模型表示中分配您的定制转换器。</p><h2 id="e0a2" class="nd mh it bd mi ne nf dn mm ng nh dp mq li ni nj ms lm nk nl mu lq nm nn mw no bi translated">创建价值转换器</h2><p id="7808" class="pw-post-body-paragraph kz la it lb b lc my ju le lf mz jx lh li na lk ll lm nb lo lp lq nc ls lt lu im bi translated">在这个例子中，我们将创建一个转换器，将一个<code class="fe lv lw lx ly b">UIColor</code>转换成<code class="fe lv lw lx ly b">NSData</code>，并存储在我们的数据库中。</p><p id="0b63" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们首先创建一个名为<code class="fe lv lw lx ly b">UIColorValueTransformer</code>的新类，它继承自<code class="fe lv lw lx ly b">ValueTransformer</code>:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="np nq l"/></div></figure><p id="7232" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">核心数据基本上可以被视为一种技术，它将C函数调用包装到一个更易于使用的面向对象的框架中，以管理SQL数据库。它还没有内置到Swift中，因此需要我们与Objective-C进行交互。<code class="fe lv lw lx ly b">@objc</code>属性告诉Swift在Objective-C中使用我们的ValueTransformer。</p><p id="ecc1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">下一步是设置我们的转换逻辑，这可以通过覆盖抽象<code class="fe lv lw lx ly b">ValueTransformer</code>类中的一些可用方法来实现。我们首先定义转换后的值类，并将转换器标记为可逆的:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="np nq l"/></div></figure><p id="d4ca" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe lv lw lx ly b">transformedValueClass</code>需要返回“读取”的类型，这是一个正向转换。在我们的例子中，我们希望在从持久容器中读取值时有一个<code class="fe lv lw lx ly b">UIColor</code>类型。</p><p id="0756" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">通过将我们的转换器定义为可逆的，我们基本上告诉核心数据，我们的转换器能够处理插入和读取。在其他情况下，您可能只想在插入时转换一个值，以确保该值符合某些要求(例如，存储一个首字母大写的名称)。然而，在我们的案例中，我们希望向两个方向转变。</p><h2 id="524a" class="nd mh it bd mi ne nf dn mm ng nh dp mq li ni nj ms lm nk nl mu lq nm nn mw no bi translated">转变价值观</h2><p id="75fa" class="pw-post-body-paragraph kz la it lb b lc my ju le lf mz jx lh li na lk ll lm nb lo lp lq nc ls lt lu im bi translated">接下来是实现实际的转换方法:一个用于读取数据库，一个用于写入数据库。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="np nq l"/></div></figure><p id="1b82" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们使用了<code class="fe lv lw lx ly b">NSKeyedArchiver</code>类，它允许我们使用安全编码来读取和存储数据，这是从iOS 11开始就需要的，以提高安全性。在调试过程中，如果转换失败，我们通过抛出断言来帮助自己。断言失败只在调试版本中触发，这在我们的例子中非常好！</p><h2 id="cf01" class="nd mh it bd mi ne nf dn mm ng nh dp mq li ni nj ms lm nk nl mu lq nm nn mw no bi translated">注册变压器</h2><p id="6855" class="pw-post-body-paragraph kz la it lb b lc my ju le lf mz jx lh li na lk ll lm nb lo lp lq nc ls lt lu im bi translated">我们的ValueTransformer的实现大部分已经完成。我们只需要一种方法来注册它，并使它对我们的核心数据模型可用。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="np nq l"/></div></figure><p id="f80a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们使用强类型名称，而不是将名称定义为静态字符串。如果我们决定重命名我们的转换器，这可以防止将来的错误。</p><p id="43bb" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">静态的<code class="fe lv lw lx ly b">register()</code>方法允许我们注册如下的转换器:</p><pre class="kj kk kl km gt nr ly ns nt aw nu bi"><span id="8a46" class="nd mh it ly b gy nv nw l nx ny">UIColorValueTransformer.register()</span></pre><p id="7725" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">请确保在设置持久性容器之前这样做，否则您将会遇到如下错误:</p><pre class="kj kk kl km gt nr ly ns nt aw nu bi"><span id="02ef" class="nd mh it ly b gy nv nw l nx ny">No NSValueTransformer with class name 'UIColorValueTransformer' was found for attribute 'color' on entity 'user'</span></pre><h2 id="fbfc" class="nd mh it bd mi ne nf dn mm ng nh dp mq li ni nj ms lm nk nl mu lq nm nn mw no bi translated">通过连接ValueTransformer将属性设置为可转换的</h2><p id="f234" class="pw-post-body-paragraph kz la it lb b lc my ju le lf mz jx lh li na lk ll lm nb lo lp lq nc ls lt lu im bi translated">最后，您需要将ValueTransformer连接到数据库中的一个属性。通过将属性定义为可转换的，可以做到这一点:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi nz"><img src="../Images/934dd56d31a3c8b72348ba5d9bf7e6ed.png" data-original-src="https://miro.medium.com/v2/resize:fit:1348/format:webp/0*dV9MvMa6kEXe4flE.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">将属性定义为可转换的，以便它可以使用ValueTransformer。</p></figure><p id="e79f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">您可以在数据模型检查器中连接ValueTransformer:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi oa"><img src="../Images/93898c09f1f1a5963c568dcde23eb4cc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1044/format:webp/0*kAqZNOjmC_tyDRfd.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">在核心数据模型中连接ValueTransformer。</p></figure><p id="31f5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这就是你使用你自己的ValueTransformer所需要的一切。在这种情况下，将<code class="fe lv lw lx ly b">UIColor</code>存储到核心数据持久容器中。</p></div><div class="ab cl lz ma hx mb" role="separator"><span class="mc bw bk md me mf"/><span class="mc bw bk md me mf"/><span class="mc bw bk md me"/></div><div class="im in io ip iq"><h1 id="3397" class="mg mh it bd mi mj mk ml mm mn mo mp mq jz mr ka ms kc mt kd mu kf mv kg mw mx bi translated">使用ValueTransformer将绝对URL存储为相对URL</h1><p id="9bce" class="pw-post-body-paragraph kz la it lb b lc my ju le lf mz jx lh li na lk ll lm nb lo lp lq nc ls lt lu im bi translated">现在您已经知道了ValueTransformer是如何工作的，是时候探索实现它们的其他方法了。</p><h2 id="8e2a" class="nd mh it bd mi ne nf dn mm ng nh dp mq li ni nj ms lm nk nl mu lq nm nn mw no bi translated">在核心数据中存储URL</h2><p id="db48" class="pw-post-body-paragraph kz la it lb b lc my ju le lf mz jx lh li na lk ll lm nb lo lp lq nc ls lt lu im bi translated">核心数据中的一个常见场景是存储URL。iOS 11引入了<code class="fe lv lw lx ly b">URIAttributeType</code>，这使得将URL直接存储到核心数据变得很有诱惑力。这在某些情况下是没问题的，但它也使存储绝对URL成为一个简单的错误，这在将来会成为一个非常大的问题。</p><p id="3b2d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">URL通常指向像<code class="fe lv lw lx ly b">App Group</code>文件夹或<code class="fe lv lw lx ly b">Documents</code>目录这样的目录。正如在<a class="ae ky" href="https://developer.apple.com/documentation/foundation/nsfilemanager/1412643-containerurlforsecurityapplicati" rel="noopener ugc nofollow" target="_blank">文档</a>中所描述的，其中一些URL是可能改变的路径:</p><blockquote class="ob oc od"><p id="e028" class="kz la oe lb b lc ld ju le lf lg jx lh of lj lk ll og ln lo lp oh lr ls lt lu im bi translated">"总是使用此方法返回的URL来定位组目录，而不是用显式路径手动构造URL。在macOS的未来版本中，目录在文件系统中的确切位置可能会改变，但此方法将始终返回正确的URL。</p></blockquote><p id="f050" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">您可能不会总是足够仔细地阅读文档来防止所有情况，这就是为什么我总是选择最安全的路线。这意味着我将所有的URL相对地存储在核心数据中。</p><h2 id="7818" class="nd mh it bd mi ne nf dn mm ng nh dp mq li ni nj ms lm nk nl mu lq nm nn mw no bi translated">为什么应该使用ValueTransformer将绝对URL存储为相对URL？</h2><p id="ae4c" class="pw-post-body-paragraph kz la it lb b lc my ju le lf mz jx lh li na lk ll lm nb lo lp lq nc ls lt lu im bi translated">您可能想知道为什么要使用ValueTransformer将URL存储为相对URL。要防止类似这样的代码:</p><pre class="kj kk kl km gt nr ly ns nt aw nu bi"><span id="0b1f" class="nd mh it ly b gy nv nw l nx ny">@NSManaged private var urlPath: String<br/><br/>public var url: URL? {<br/>    NSURL(fileURLWithPath: urlPath, relativeTo: RabbitInfo.shared.appGroupURL).absoluteURL<br/>}</span></pre><p id="ee7b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这样定义我们的属性会好得多:</p><pre class="kj kk kl km gt nr ly ns nt aw nu bi"><span id="a856" class="nd mh it ly b gy nv nw l nx ny">@NSManaged public var url: URL?</span></pre><h2 id="5eb0" class="nd mh it bd mi ne nf dn mm ng nh dp mq li ni nj ms lm nk nl mu lq nm nn mw no bi translated">使用ValueTransformer将绝对URL转换为相对URL</h2><p id="4ebd" class="pw-post-body-paragraph kz la it lb b lc my ju le lf mz jx lh li na lk ll lm nb lo lp lq nc ls lt lu im bi translated">在这个例子中，我们将一个指向文件的URL存储在<code class="fe lv lw lx ly b">App Group</code>容器中。它从我们的配置中获取应用程序组URL，配置使用<code class="fe lv lw lx ly b">FileManager</code>来检索正确的路径:</p><pre class="kj kk kl km gt nr ly ns nt aw nu bi"><span id="ae8f" class="nd mh it ly b gy nv nw l nx ny">FileManager.default.containerURL(forSecurityApplicationGroupIdentifier: "YOUR_APP_GROUP_NAME")</span></pre><p id="b37b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">最终的实现如下所示:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="np nq l"/></div></figure><p id="b238" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如您所见，这个ValueTransformer看起来很像我们之前定义的<code class="fe lv lw lx ly b">UIColor</code>转换器。在插入新的URL时，提取并存储相对路径。一旦读取了值，我们就追加指向我们的<code class="fe lv lw lx ly b">App Group</code>容器的当前URL。这样，我们就能确保总是引用正确的路径，并且永远不会遇到文件丢失的情况。</p><h2 id="3603" class="nd mh it bd mi ne nf dn mm ng nh dp mq li ni nj ms lm nk nl mu lq nm nn mw no bi translated">那么什么时候应该使用URL属性类型呢？</h2><p id="2dde" class="pw-post-body-paragraph kz la it lb b lc my ju le lf mz jx lh li na lk ll lm nb lo lp lq nc ls lt lu im bi translated">只有当您确定某个路径将来不会改变时，才使用URL属性类型。显然，您也可以使用它来存储web URLs，对于这些URL，转换器无法解决任何未来的更改。</p></div><div class="ab cl lz ma hx mb" role="separator"><span class="mc bw bk md me mf"/><span class="mc bw bk md me mf"/><span class="mc bw bk md me"/></div><div class="im in io ip iq"><h1 id="53f5" class="mg mh it bd mi mj mk ml mm mn mo mp mq jz mr ka ms kc mt kd mu kf mv kg mw mx bi translated">结论</h1><p id="e6b7" class="pw-post-body-paragraph kz la it lb b lc my ju le lf mz jx lh li na lk ll lm nb lo lp lq nc ls lt lu im bi translated">核心数据中的ValueTransformers允许您将值从任何类型转换为任何其他类型。通过在插入前将它们转换成<code class="fe lv lw lx ly b">NSData</code>，可以存储<code class="fe lv lw lx ly b">UIColor</code>、<code class="fe lv lw lx ly b">CGRect</code>或其他类型。ValueTransformers还可以用于其他情况，比如将URL从绝对转换为相对。</p><p id="e0d2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">感谢阅读！</p></div></div>    
</body>
</html>