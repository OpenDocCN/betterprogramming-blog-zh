<html>
<head>
<title>How to Cache GraphQL Requests Using Kong and StepZen</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何使用Kong和StepZen缓存GraphQL请求</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/how-to-cache-graphql-requests-using-kong-and-stepzen-24a42219c71d?source=collection_archive---------5-----------------------#2022-09-22">https://betterprogramming.pub/how-to-cache-graphql-requests-using-kong-and-stepzen-24a42219c71d?source=collection_archive---------5-----------------------#2022-09-22</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="1337" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">使用API网关解决缓存GraphQL API的挑战</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/8a74f5638984983376d0d6f045002d61.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*GYzXmAqtx3hovxu9.png"/></div></div></figure><p id="717a" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">GraphQL经常被用作微服务的API网关，但也可以很好地与现有的API网关解决方案配合使用。比如使用<a class="ae ln" href="https://konghq.com/" rel="noopener ugc nofollow" target="_blank">孔</a>，一个API网关和微服务管理平台。作为一个API网关，Kong有许多功能可以用来增强GraphQL APIs。其中一个功能是向您添加到Kong的上游服务添加代理缓存。但是当使用GraphQL进行缓存时，由于GraphQL的性质，您必须考虑几个警告。在这篇文章中，我们将讨论缓存GraphQL API的挑战，以及API网关如何对此有所帮助。</p><h1 id="b2d1" class="lo lp iq bd lq lr ls lt lu lv lw lx ly jw lz jx ma jz mb ka mc kc md kd me mf bi translated">为什么要使用API缓存？</h1><p id="b694" class="pw-post-body-paragraph kr ks iq kt b ku mg jr kw kx mh ju kz la mi lc ld le mj lg lh li mk lk ll lm ij bi translated">缓存是任何API的重要组成部分——您希望确保您的用户尽可能获得对其请求的最佳响应时间。当然，缓存不是万能的解决方案，不同的场景有很多不同的策略。</p><p id="e37f" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">假设您的API是一个高流量的关键应用程序。它将受到许多用户的强烈冲击，你需要确保它能随着需求而扩展。缓存可以帮助您做到这一点，它可以减少服务器上的负载，提高所有用户的性能，同时潜在地降低成本并提供额外的安全功能。Kong的缓存通常应用于代理层，这意味着这个代理将缓存请求，并提供对某个端点的最后一次调用的响应(如果该端点存在于缓存中)。</p><p id="9010" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">GraphQL APIs在缓存方面有其挑战，您需要在实现缓存策略之前了解这些挑战，您将在下一节中了解到。</p><h1 id="541b" class="lo lp iq bd lq lr ls lt lu lv lw lx ly jw lz jx ma jz mb ka mc kc md kd me mf bi translated">使用GraphQL缓存的挑战</h1><p id="5238" class="pw-post-body-paragraph kr ks iq kt b ku mg jr kw kx mh ju kz la mi lc ld le mj lg lh li mk lk ll lm ij bi translated">GraphQL在公司中越来越受欢迎。GraphQL最好被描述为API的查询语言。它是声明性的，这意味着您编写您想要的数据，并将请求的细节留给服务器。这对我们有好处，因为它通过将关注点分离到客户端和服务器端实现中，使我们的代码更具可读性和可维护性。</p><p id="4481" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">GraphQL APIs可以解决诸如过度提取和提取不足的挑战(也称为N+1问题)。但是与任何API一样，设计不佳的GraphQL API会导致一些可怕的N+1问题。用户可以通过修改发送给GraphQL API的查询来控制GraphQL请求的响应，他们甚至可以在多个级别上嵌套数据。虽然肯定有办法通过解析器或缓存策略的设计在后端缓解这个问题，但是如果有一种方法可以让您的GraphQL API运行得非常快，而不需要更改一行代码呢？</p><blockquote class="ml mm mn"><p id="8233" class="kr ks mo kt b ku kv jr kw kx ky ju kz mp lb lc ld mq lf lg lh mr lj lk ll lm ij bi translated">StepZen为依赖于<code class="fe ms mt mu mv b">@rest</code>的查询和突变添加了缓存，更多信息请参见<a class="ae ln" href="https://stepzen.com/docs/custom-graphql-directives/directives#cachepolicy" rel="noopener ugc nofollow" target="_blank">这里的</a>。</p></blockquote><p id="fb81" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">通过使用Kong和GraphQL代理缓存高级插件，你完全可以！让我们来看看。</p><h1 id="85b0" class="lo lp iq bd lq lr ls lt lu lv lw lx ly jw lz jx ma jz mb ka mc kc md kd me mf bi translated">用Kong为GraphQL设置缓存</h1><p id="9569" class="pw-post-body-paragraph kr ks iq kt b ku mg jr kw kx mh ju kz la mi lc ld le mj lg lh li mk lk ll lm ij bi translated">当您使用Kong作为API网关时，它可以用来代理对上游服务的请求，包括GraphQL APIs。使用企业插件<a class="ae ln" href="https://docs.konghq.com/hub/kong-inc/graphql-proxy-cache-advanced/" rel="noopener ugc nofollow" target="_blank"> GraphQL代理缓存高级</a>，您可以向任何GraphQL API添加代理缓存。使用这个插件，您可以在GraphQL服务、路由甚至全局范围内启用代理缓存。让我们通过向用StepZen创建的Kong添加一个GraphQL服务来尝试一下。</p><p id="2855" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">使用StepZen，您可以通过使用CLI或编写GraphQL SDL(模式定义语言)以声明方式创建GraphQL APIs。这是一种与语言无关的创建GraphQL的方式，因为它完全依赖于GraphQL SDL。您唯一需要开始的是一个现有的数据源，例如(没有)SQL数据库或REST API。然后，您可以使用CLI为该数据源生成模式和解析器，或者使用GraphQL SDL编写连接。然后，GraphQL模式可以直接从您的终端部署到云中，并带有内置的身份验证。</p><h1 id="cb5e" class="lo lp iq bd lq lr ls lt lu lv lw lx ly jw lz jx ma jz mb ka mc kc md kd me mf bi translated">使用StepZen创建一个GraphQL API</h1><p id="d351" class="pw-post-body-paragraph kr ks iq kt b ku mg jr kw kx mh ju kz la mi lc ld le mj lg lh li mk lk ll lm ij bi translated">要使用StepZen获得GraphQL，您可以连接您的数据源或使用Github中的一个预建示例。在这篇文章中，我们将从示例中的MySQL数据库中取出一个在<a class="ae ln" href="https://github.com/stepzen-dev/examples/tree/main/with-mysql" rel="noopener ugc nofollow" target="_blank">上创建的GraphQL API。通过将这个存储库克隆到您的本地机器，您将获得一组包含GraphQL模式的配置文件和<code class="fe ms mt mu mv b">.graphql</code>文件。要运行GraphQL API并将其部署到云中，您需要使用StepZen CLI。</a></p><p id="8b2c" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">您可以从npm安装CLI:</p><pre class="kg kh ki kj gt mw mv mx my aw mz bi"><span id="c173" class="na lp iq mv b gy nb nc l nd ne">npm i -g stepzen</span></pre><p id="9038" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">安装完CLI后，您可以<a class="ae ln" href="https://stepzen.com/signup" rel="noopener ugc nofollow" target="_blank">注册一个StepZen帐户</a>在一个私有的、安全的端点上部署GraphQL API。或者，您可以不注册而继续，但是请记住，部署的GraphQL端点将是公共的。要启动和部署GraphQL API，您可以运行:</p><pre class="kg kh ki kj gt mw mv mx my aw mz bi"><span id="86d6" class="na lp iq mv b gy nb nc l nd ne">stepzen start</span></pre><p id="a6cb" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">运行这个命令将返回终端中的一个已部署的端点(如<code class="fe ms mt mu mv b">https://public3b47822a17c9dda6.stepzen.net/api/with-mysql/__graphql</code>)。此外，它还产生了一个<code class="fe ms mt mu mv b">localhost</code>地址，您可以使用GraphQL在本地探索GraphQL API。</p><h1 id="e49c" class="lo lp iq bd lq lr ls lt lu lv lw lx ly jw lz jx ma jz mb ka mc kc md kd me mf bi translated">为Kong添加一个GraphQL服务</h1><p id="f106" class="pw-post-body-paragraph kr ks iq kt b ku mg jr kw kx mh ju kz la mi lc ld le mj lg lh li mk lk ll lm ij bi translated">您在上一节中创建的服务现在可以通过使用Kong Manager或<a class="ae ln" href="https://docs.konghq.com/gateway/latest/configure/graphql-quickstart/#existing-graphql-infrastructure" rel="noopener ugc nofollow" target="_blank"> Admin API </a>添加到您的Kong网关中。让我们使用Admin API将我们新创建的GraphQL API添加到Kong，它只需要我们发送几个cURL请求。首先，我们需要添加服务，然后需要添加该服务的路由。</p><p id="49f2" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">您可以运行以下命令来添加GraphQL服务和路由。根据您的Kong网关的设置，您可能需要在您的请求中添加身份验证头:</p><pre class="kg kh ki kj gt mw mv mx my aw mz bi"><span id="3638" class="na lp iq mv b gy nb nc l nd ne">curl -i -X POST \<br/>  --url http://localhost:8001/services/ \<br/>  --data 'name=graphql-service' \<br/>  --data 'url=https://public3b47822a17c9dda6.stepzen.net/api/with-mysql/__graphql'<br/><br/>curl -i -X POST \<br/>  --url http://localhost:8001/services/graphql-service/routes \<br/>  --data 'hosts[]=stepzen.net' \</span></pre><p id="552d" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">GraphQL API现在已经作为上游服务添加到了Kong网关中，这意味着您已经可以代理它了。但在此之前，我们将添加<a class="ae ln" href="https://docs.konghq.com/hub/kong-inc/graphql-proxy-cache-advanced/" rel="noopener ugc nofollow" target="_blank"> GraphQL代理缓存高级</a>插件，这也可以使用cURL命令来完成:</p><pre class="kg kh ki kj gt mw mv mx my aw mz bi"><span id="12ef" class="na lp iq mv b gy nb nc l nd ne">​​curl -i -X POST \<br/>  --url http://localhost:8001/services/graphql-service/plugins/ \<br/>  --data 'name=graphql-proxy-cache-advanced' \<br/>  --data 'config.strategy=memory'</span></pre><p id="f2cc" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">使用Kong作为GraphQL API的代理，并添加了这个插件，所有请求都在查询级别自动缓存。缓存的默认TTL(生存时间)是300秒，除非您通过添加<code class="fe ms mt mu mv b">--data' config.cache_ttl=600</code>将其覆盖(例如600秒)。在下一节中，我们将通过查询代理的GraphQL端点来探索缓存。</p><h1 id="1cb7" class="lo lp iq bd lq lr ls lt lu lv lw lx ly jw lz jx ma jz mb ka mc kc md kd me mf bi translated">查询GraphQL API</h1><p id="08cd" class="pw-post-body-paragraph kr ks iq kt b ku mg jr kw kx mh ju kz la mi lc ld le mj lg lh li mk lk ll lm ij bi translated">代理的GraphQL API将通过网关端点上的Kong提供。当您向它发送请求时，它会收到一个带有GraphQL主机名的头值。因为这是一个对GraphQL API的请求，请记住所有请求都应该是带有<code class="fe ms mt mu mv b">Content-Type: application/json</code>头的<code class="fe ms mt mu mv b">POST</code>请求，并在正文中附加一个GraphQL查询。</p><p id="bc3e" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">要向GraphQL API发送请求，必须首先构造一个GraphQL查询。当您访问部署了GraphQL API的端点时，您会发现一个GraphQL接口——一个探索GraphQL API的交互式平台。在这个接口中，您可以找到完整的模式，包括查询和GraphQL API可能接受的其他操作。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nf"><img src="../Images/18d7fe11db51d85e9ce03fd13b754ec0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*ElyaLjNFeziwZ1lD.png"/></div></div></figure><p id="9fd4" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">在这个界面中，您可以发送查询，并浏览上面看到的结果和模式。要将相同的查询发送到代理的GraphQL API，可以使用以下cURL:</p><pre class="kg kh ki kj gt mw mv mx my aw mz bi"><span id="a940" class="na lp iq mv b gy nb nc l nd ne">curl -i -X POST 'http://localhost:8000/' \<br/>--header 'Host: stepzen.net' \<br/>--header 'Content-Type: application/json' \<br/>--data-raw '{"query":"query getCustomerList {\n getCustomerList {\n name\n }\n}","variables":{}}'</span></pre><p id="88e9" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">这个cURL将返回响应结果和响应头:</p><pre class="kg kh ki kj gt mw mv mx my aw mz bi"><span id="3223" class="na lp iq mv b gy nb nc l nd ne">HTTP/1.1 200 OK<br/>Content-Type: application/json; charset=utf-8<br/>Content-Length: 445<br/>Connection: keep-alive<br/>X-Cache-Key: 5abfc9adc50491d0a264f1e289f4ab1a<br/>X-Cache-Status: Miss<br/>StepZen-Trace: 410b35b512a622aeffa2c7dd6189cd15<br/>Vary: Origin<br/>Date: Wed, 22 Jun 2022 14:12:23 GMT<br/>Via: kong/2.8.1.0-enterprise-edition<br/>Alt-Svc: h3=":443"; ma=2592000,h3-29=":443"; ma=2592000<br/>X-Kong-Upstream-Latency: 256<br/>X-Kong-Proxy-Latency: 39<br/><br/>{<br/>  "data": {<br/>    "getCustomerList": [<br/>      {<br/>        "name": "Lucas Bill"<br/>      },<br/>      {<br/>        "name": "Mandy Jones"<br/>      },<br/>      …<br/>    ]<br/>  }<br/>}</span></pre><p id="5a7a" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">在上面，可以看到GraphQL API的响应，这是一个假客户的列表，与我们发送给它的查询具有相同的数据结构。同样，输出响应头，这里有两个我们应该关注的头:<code class="fe ms mt mu mv b">X-Cache-Status</code>和<code class="fe ms mt mu mv b">X-Cache-Key</code>。第一个头将显示缓存是否被命中，第二个头显示缓存响应的键。为了缓存响应，Kong将查看向其发送请求的端点和post主体的内容——包括查询和可能的查询参数。如果您在不同的请求中重用部分GraphQL查询，GraphQL代理高级插件不会缓存部分响应。</p><p id="30bd" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">在第一次请求时，<code class="fe ms mt mu mv b">X-Cache-Status</code>的值将总是<code class="fe ms mt mu mv b">Miss</code>，因为没有可用的缓存响应。然而，<code class="fe ms mt mu mv b">X-Cache-Key</code>将始终有一个值，因为将根据请求创建缓存。因此，<code class="fe ms mt mu mv b">X-Cache-Key</code>的值将是新创建的缓存响应或来自先前请求的现有缓存响应的键。</p><p id="8201" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">让我们再次发出这个请求，并关注这两个响应头的值:</p><pre class="kg kh ki kj gt mw mv mx my aw mz bi"><span id="f7eb" class="na lp iq mv b gy nb nc l nd ne">X-Cache-Status: Hit<br/>X-Cache-Key: 5abfc9adc50491d0a264f1e289f4ab1a</span></pre><p id="910e" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">我们第二次命中代理的GraphQL API端点时，缓存被命中，缓存键仍然是与第一次请求相同的值。这意味着前一个请求的响应已经被缓存，现在被返回。相反，缓存的响应被用作所指示的缓存状态。除非您更改缓存的默认TTL，否则缓存的响应将保持可用300秒。如果在TTL过期后向代理的GraphQL API发送相同的请求，缓存状态将是<code class="fe ms mt mu mv b">Miss</code>。</p><p id="702b" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">您还可以通过直接向GraphQL代理高级插件发送请求来直接检查缓存的响应。要从前面的请求中获取缓存的响应，可以在Kong实例的Admin API上使用以下端点。例如:</p><pre class="kg kh ki kj gt mw mv mx my aw mz bi"><span id="15d5" class="na lp iq mv b gy nb nc l nd ne">curl <a class="ae ln" href="http://localhost:8001/graphql-proxy-cache-advanced/5abfc9adc50491d0a264f1e289f4ab1a" rel="noopener ugc nofollow" target="_blank">http://localhost:8001/graphql-proxy-cache-advanced/5abfc9adc50491d0a264f1e289f4ab1a</a></span></pre><p id="70d1" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">如果缓存值存在，该请求返回<code class="fe ms mt mu mv b">HTTP 200 OK</code>，如果不存在，则返回<code class="fe ms mt mu mv b">HTTP 404 Not Found</code>。使用Kong Admin API，您可以通过键删除缓存的响应，甚至清除所有缓存的响应。有关此主题的更多信息，请参见GraphQL代理缓存高级文档中的<a class="ae ln" href="https://docs.konghq.com/hub/kong-inc/graphql-proxy-cache-advanced/#delete-cache-entity" rel="noopener ugc nofollow" target="_blank">删除缓存的实体部分</a>。</p><h1 id="d6c4" class="lo lp iq bd lq lr ls lt lu lv lw lx ly jw lz jx ma jz mb ka mc kc md kd me mf bi translated">结论</h1><p id="74ab" class="pw-post-body-paragraph kr ks iq kt b ku mg jr kw kx mh ju kz la mi lc ld le mj lg lh li mk lk ll lm ij bi translated">这篇文章教你如何添加一个GraphQL API到Kong来创建一个代理的GraphQL端点。通过将它添加到Kong中，您不仅可以获得Kong作为代理服务提供的所有特性，还可以为GraphQL API实现缓存。您可以通过安装GraphQL代理缓存高级版来实现这一点，该版适用于Plus和Enterprise实例。使用这个插件，您可以为GraphQL APIs实现代理缓存，让您缓存任何GraphQL请求的响应。</p><pre class="kg kh ki kj gt mw mv mx my aw mz bi"><span id="a72e" class="na lp iq mv b gy nb nc l nd ne">Follow us on <a class="ae ln" href="https://twitter.com/stepzen_dev" rel="noopener ugc nofollow" target="_blank">Twitter</a> or <a class="ae ln" href="https://discord.gg/9k2VdPn2FR" rel="noopener ugc nofollow" target="_blank">join our Discord community</a> to stay updated about our latest developments.</span></pre></div></div>    
</body>
</html>