<html>
<head>
<title>A Deep Dive Into Java Wildcards — Covariance</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">深入探究Java通配符——协方差</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/a-deep-dive-into-java-wildcards-covariance-4d807a65f02?source=collection_archive---------5-----------------------#2022-09-15">https://betterprogramming.pub/a-deep-dive-into-java-wildcards-covariance-4d807a65f02?source=collection_archive---------5-----------------------#2022-09-15</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="a8bd" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">探索Java中较难的主题之一</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/95866c0c89370da32c8375f90af6c597.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*9y_XptjmUhj1IjkXoTS9oA.jpeg"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">照片由<a class="ae kv" href="https://unsplash.com/@sixteenmilesout?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">拍摄于</a>16英里外的<a class="ae kv" href="https://unsplash.com/s/photos/bucket?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a></p></figure><p id="9803" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">当我遇到通配符时，我感到非常困惑，尤其是当它与<code class="fe ls lt lu lv b">&lt;T&gt;</code> s、<code class="fe ls lt lu lv b">&lt;U&gt;</code> s、<code class="fe ls lt lu lv b">&lt;V&gt;</code> s一起出现时。在我们应该何时使用<code class="fe ls lt lu lv b">&lt;T extends Number&gt;</code> vs <code class="fe ls lt lu lv b">&lt;? extends Number&gt;</code>的问题上存在困惑。我相信你们中的许多人可能也感到困惑。</p><p id="b0ed" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">今天，我们就来试着了解一下<code class="fe ls lt lu lv b">&lt;? extends Bla&gt;</code>。我不会谈论像PECS(生产者延伸，消费者超级)等标准的东西。我读过这方面的书，但这不仅仅是记忆。我认为我们应该永远触及核心。</p><p id="dddb" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在深入挖掘之前，我们先试着了解一下背后的故事。这将使事情变得更容易。所以，上车吧。可能会很长。</p><p id="51e4" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">慢慢读这个。我已经为清晰的可视化提供了大量的代码和细节。</p><h1 id="9a07" class="lw lx iq bd ly lz ma mb mc md me mf mg jw mh jx mi jz mj ka mk kc ml kd mm mn bi translated">协方差和逆变——重要的概念！</h1><p id="a867" class="pw-post-body-paragraph kw kx iq ky b kz mo jr lb lc mp ju le lf mq lh li lj mr ll lm ln ms lp lq lr ij bi translated">协方差—我们知道String是Object的子对象，所以根据Java的规则，我们可以将一个子对象引用赋给一个父对象。类似于以下内容:</p><pre class="kg kh ki kj gt mt lv mu mv aw mw bi"><span id="e58c" class="mx lx iq lv b gy my mz l na nb">String s = "Wildcards";<br/>Object o = s;</span></pre><p id="aee6" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">因此，根据协方差规则，这是可能的:</p><pre class="kg kh ki kj gt mt lv mu mv aw mw bi"><span id="0319" class="mx lx iq lv b gy my mz l na nb">String[] sArray = { "Wildcards" };<br/>Object[] o = sArray; // Valid in Java.</span></pre><p id="ecfe" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们称<code class="fe ls lt lu lv b">String[]</code>和<code class="fe ls lt lu lv b">Object[]</code>为holder类型(HT——持有一些对象),分别适用于String和Object之类的持有对象。那个HT可以是<code class="fe ls lt lu lv b">List&lt;&gt;</code>、<code class="fe ls lt lu lv b">Set&lt;&gt;</code>、<code class="fe ls lt lu lv b">Box&lt;&gt;</code>——任何能装物体的东西。</p><blockquote class="nc nd ne"><p id="0e62" class="kw kx nf ky b kz la jr lb lc ld ju le ng lg lh li nh lk ll lm ni lo lp lq lr ij bi translated">所以，根据协方差，如果Object是String的父，那么HT <object>也将是HT <string>的父。</string></object></p></blockquote><pre class="kg kh ki kj gt mt lv mu mv aw mw bi"><span id="5725" class="mx lx iq lv b gy my mz l na nb">List&lt;String&gt; s = new ArrayList&lt;&gt;();<br/>List&lt;Object&gt; o = new ArrayList&lt;&gt;();</span><span id="fc1a" class="mx lx iq lv b gy nj mz l na nb">// This will not compile! But this is what covariance is.<br/>o = s; // We could have done this if lists were covariant, but List is not covariant in its plain form.</span></pre><blockquote class="nc nd ne"><p id="b984" class="kw kx nf ky b kz la jr lb lc ld ju le ng lg lh li nh lk ll lm ni lo lp lq lr ij bi translated">Java中的数组是协变的，这意味着下面的代码是有效的。</p></blockquote><pre class="kg kh ki kj gt mt lv mu mv aw mw bi"><span id="6782" class="mx lx iq lv b gy my mz l na nb">String[] sArray = { "Wildcards" };<br/>Number[] nArray = { 2, 3 };<br/>Object[] o = sArray; // Object is parent of String<br/>o = nArray; // Object is parent of Number too!</span></pre><p id="865d" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">使数组协变是一个Java设计决策。他们本可以选择不同的道路。但是，使它们协变允许许多多态行为。人们可以通过在<code class="fe ls lt lu lv b">Object[]</code>中存储业务对象来编写通用代码。但是它引入了只能在运行时检测到的错误。考虑以下情况:</p><pre class="kg kh ki kj gt mt lv mu mv aw mw bi"><span id="0a5b" class="mx lx iq lv b gy my mz l na nb">Number[] nArray = { 2, 3 };<br/>Object[] o = nArray;<br/>o[0] = "s"; // This is valid in Java, but will crash with ArrayStoreException.</span></pre><p id="504e" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在大型企业应用程序和库中，这种错误很有可能发生，并可能导致崩溃和大量损失。</p><h2 id="7919" class="mx lx iq bd ly nk nl dn mc nm nn dp mg lf no np mi lj nq nr mk ln ns nt mm nu bi translated">收藏时代</h2><p id="51f3" class="pw-post-body-paragraph kw kx iq ky b kz mo jr lb lc mp ju le lf mq lh li lj mr ll lm ln ms lp lq lr ij bi translated">当集合被介绍的时候，他们不是以他们现在的方式被写。他们没有带着信息。尽管如此，您仍然可以编写没有类型信息的代码。IDE将使您的语句变成黄色，编译器将显示警告。即使在今天，当您提供类型信息时，在验证所有内容后，编译器会在编译时删除类型信息。</p><p id="3b82" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这被称为“类型擦除”考虑下面的例子:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nv"><img src="../Images/4c9ada0e052d567545d8919b636fa5a6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*idtQ4rEqThHWpk8IB5qPBA.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">IDE警告</p></figure><p id="514f" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">你可以看到，我们可以向列表中添加任何元素，IDE正在流血。这种行为被保留下来，这样遗留代码就不会中断，事情也就向后兼容了。在Java字节码中，没有类型信息。</p><p id="36a9" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">因此，Java在Java 5的集合中增加了类型信息。从那以后，编译器试图捕捉非法赋值。它相当成功，是吗？</p><p id="3e49" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">现在，如果我们在添加类型后尝试做同样的事情，瞧！它接住了。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nw"><img src="../Images/dd285a36a789733b44b0586b5b1f7c3b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*cOubgp2qEowQVSZiVETMtQ.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">编译器警告非法赋值</p></figure><p id="8fdd" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">让我们试着弄脏我们的手，尝试一些真实的东西。假设您正在构建一个具有调度程序和任务的框架。为此，您有一个基本任务和它的多个实现。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nx ny l"/></div></figure><p id="6a50" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><code class="fe ls lt lu lv b">startJob(task)</code>能接受多种工种。现在，需求发生了变化，我们需要提交一份工作清单。简单的东西！我们再次做出改变。糟糕的是，这种事情发生了！"不允许列表&lt; RxWork &gt;"</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nz"><img src="../Images/72e96244db46d8ffe77e355411c5b981.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*itJVboQ5rcghJqZS9GuaSA.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">没有通配符，集合不是直接协变的。</p></figure><p id="d0d1" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">发生这种情况的原因如下:</p><blockquote class="oa"><p id="0b9f" class="ob oc iq bd od oe of og oh oi oj lr dk translated">即使RxWork是BaseWork的子级，List <rxwork>也不是List <basework>的子级。"</basework></rxwork></p></blockquote><p id="2e30" class="pw-post-body-paragraph kw kx iq ky b kz ok jr lb lc ol ju le lf om lh li lj on ll lm ln oo lp lq lr ij bi translated">但是嘿！为什么不呢？为什么Java工程师不让我们这么做？</p><p id="6f44" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">试着这样理解:假设他们也让我们通过了<code class="fe ls lt lu lv b">List&lt;RxWork&gt;</code>。然后，在提取工作对象时，有人可能已经使用了<code class="fe ls lt lu lv b">RxWork</code>引用来提取工作项，如下所示。而且，如果该项实际上是一个<code class="fe ls lt lu lv b">BaseWork</code>，那么该引用将被分配给子引用——这将导致运行时崩溃。</p><pre class="kg kh ki kj gt mt lv mu mv aw mw bi"><span id="72ec" class="mx lx iq lv b gy my mz l na nb">void startJob(List&lt;BaseWork&gt; incomingWork) {<br/>    <em class="nf">// validate the work and submit.<br/>    </em>for (RxWork b : incomingWork) { // Will crash as BaseWork cast to RxWork will give ClassCastException in runtime. Same problem as arrays.<br/>        Scheduler.<em class="nf">submit</em>(b);<br/>    }<br/>}</span></pre><p id="4c30" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">为了避免使数组有风险的同样的陷阱，这在集合中是不允许的。</p><p id="d391" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">但是，这是一个有效的技术用例，Java工程师知道这一点。要做你想做的，你必须声明你的<code class="fe ls lt lu lv b">List</code>是协变的。并且只有当编译器保证不允许任何人提取除了<code class="fe ls lt lu lv b">BaseWork</code>之外的任何内容时，才允许安全的协方差行为。那样的话，如果列表实现了<code class="fe ls lt lu lv b">BaseWork</code>，我们总是安全的！</p><p id="eae1" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们可以通过以下方式使<code class="fe ls lt lu lv b">List&lt;BaseWork&gt;</code>协变:</p><pre class="kg kh ki kj gt mt lv mu mv aw mw bi"><span id="4c7a" class="mx lx iq lv b gy my mz l na nb">List&lt;? extends BaseWork&gt;</span></pre><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nx ny l"/></div></figure><p id="3099" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在上面的代码中，看看我们如何传递任何一个<code class="fe ls lt lu lv b">BaseWork</code>实现的列表。看看提取<code class="fe ls lt lu lv b">RxWork</code>如何显示协变列表中的错误。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi op"><img src="../Images/bf0cd18ea5b5ae3a30ecdda6750b0e72.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*uUcxwAIw25fusZRg7jH-sA.png"/></div></div></figure><p id="e0eb" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">但是我们工程师很聪明，如果在<code class="fe ls lt lu lv b">startJob()</code>方法中修改列表会怎么样。为了超越这种聪明，它也被屏蔽了。一旦访问了协变列表的引用，就不能再向其中添加任何内容。这里，<code class="fe ls lt lu lv b">incomingWork</code>是协变的。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi oq"><img src="../Images/918be135bf3a84f22ea8e0a37badd796.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*9abq9mRhpCntxQAzASz3YQ.png"/></div></div></figure><p id="a468" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这确保你永远不会在运行时以<code class="fe ls lt lu lv b">ClassCastException!</code>结束。编译器确保如果我们正在访问<code class="fe ls lt lu lv b">BaseWork</code>的协变列表，那么该项至少是<code class="fe ls lt lu lv b">BaseWork</code>，所以它是允许的。你可以两全其美。您可以通过创建关系<code class="fe ls lt lu lv b">List&lt;RxWork&gt; is subtype of List&lt;BaseWork&gt;</code>来编写通用代码，并且不会以运行时错误而告终。</p><p id="394a" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这就是你如何发挥你的通配符！因此它被恰当地命名。这也称为应用“上限”因为它将保存extends关键字之后的类的任何子类型。</p><h2 id="2006" class="mx lx iq bd ly nk nl dn mc nm nn dp mg lf no np mi lj nq nr mk ln ns nt mm nu bi translated">集合外协方差</h2><p id="a3f6" class="pw-post-body-paragraph kw kx iq ky b kz mo jr lb lc mp ju le lf mq lh li lj mr ll lm ln ms lp lq lr ij bi translated">协方差仅仅与集合相关吗？号码</p><p id="d2be" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">理解我们如何利用通配符来构建好的API。让我们假设有一个类层次结构。“孩子”是“父亲”的子类型，“父亲”是“祖父”的子类型。请参见下面的层次结构。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi or"><img src="../Images/96b0582a176a28aaa2e96b175fb69e74.png" data-original-src="https://miro.medium.com/v2/resize:fit:602/format:webp/1*AyVlJt0UFPJJ3ZJiZ-b1PA.jpeg"/></div></figure><p id="07fa" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">而且有一个叫<code class="fe ls lt lu lv b">Box</code>的类可以容纳对象。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nx ny l"/></div></figure><p id="5a89" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">现在，我们知道了<code class="fe ls lt lu lv b">grandFather</code>、<code class="fe ls lt lu lv b">Father</code>、<code class="fe ls lt lu lv b">Child</code>之间的关系。让我们看看是否可以在持有这些对象的<code class="fe ls lt lu lv b">Box</code>之间建立类似的关系。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi os"><img src="../Images/d12b339fece98e09bcbcc3e00a009088.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*hDmTzqgcLy4WLa_SkMYVmw.png"/></div></div></figure><p id="11fd" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们可以看到<code class="fe ls lt lu lv b">grandFather</code>引用可以容纳<code class="fe ls lt lu lv b">Father</code>。但是<code class="fe ls lt lu lv b">Box&lt;GrandFather&gt;</code>撑不住<code class="fe ls lt lu lv b">Box&lt;Father&gt;</code>。</p><p id="e3c3" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">从我们所学的，我们知道我们必须使<code class="fe ls lt lu lv b">Box</code>参考协变。让我们试着去做，看看会发生什么。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi ot"><img src="../Images/8efb1e70e3e4a7f50b76bc704df6ecb8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*hmjNypR1I2cBtFaG-6pzTA.png"/></div></div></figure><p id="04d8" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">现在，<code class="fe ls lt lu lv b">Box&lt;Father&gt;</code>可以赋给<code class="fe ls lt lu lv b">Box&lt;? extends Grandfather&gt;</code>。</p><p id="f8f9" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">协变列表将显示两种行为:</p><ol class=""><li id="52b5" class="ou ov iq ky b kz la lc ld lf ow lj ox ln oy lr oz pa pb pc bi translated">我们只能提取对上限类的对象的引用(本例中为<code class="fe ls lt lu lv b">grandFather</code>)。我们来实验一下。我们在下面看到，我们可以很容易地提取<code class="fe ls lt lu lv b">grandFather</code>，但提取<code class="fe ls lt lu lv b">Father</code>失败。</li></ol><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi pd"><img src="../Images/e522687a5db6a937696a64726df3c5b1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*WJKBp3ZckpPZEZd6cTO8Vw.png"/></div></div></figure><p id="2d21" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">2.我们不能像在<code class="fe ls lt lu lv b">List&lt;&gt;</code>中那样修改<code class="fe ls lt lu lv b">Box</code>类的内容。编译器会阻止我们使用<code class="fe ls lt lu lv b">setItem(T item)</code>方法。很奇怪，对吧？</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi pe"><img src="../Images/a50a5281447cc99c102dba6a6779cffe.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*qcrb5iVpLiFt3tJHlANWJg.png"/></div></div></figure><p id="b335" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们可以将容器类设为只读。我们又打出了我们的通配符！</p><h1 id="4fbf" class="lw lx iq bd ly lz ma mb mc md me mf mg jw mh jx mi jz mj ka mk kc ml kd mm mn bi translated">我们学到了什么</h1><ol class=""><li id="1ca3" class="ou ov iq ky b kz mo lc mp lf pf lj pg ln ph lr oz pa pb pc bi translated">协方差可用于在容器类型(HT)之间建立与包含对象之间相同的父子关系——其中没有现成的Java提供的关系。</li><li id="23f5" class="ou ov iq ky b kz pi lc pj lf pk lj pl ln pm lr oz pa pb pc bi translated">可用于将持有者类型设置为只读(只读取上限类型)。</li><li id="19bf" class="ou ov iq ky b kz pi lc pj lf pk lj pl ln pm lr oz pa pb pc bi translated">限制HT只返回“上限”类引用。</li></ol><h2 id="0954" class="mx lx iq bd ly nk nl dn mc nm nn dp mg lf no np mi lj nq nr mk ln ns nt mm nu bi translated">Java中的协方差与Kotlin中的协方差</h2><p id="8cd7" class="pw-post-body-paragraph kw kx iq ky b kz mo jr lb lc mp ju le lf mq lh li lj mr ll lm ln ms lp lq lr ij bi translated">在Java中，我们看到协方差可以通过使用<code class="fe ls lt lu lv b">&lt;? extends SomeClass&gt;</code>来获得。但这只能在holder类之外完成。在上面的<code class="fe ls lt lu lv b">Box</code>的例子中，我们在<code class="fe ls lt lu lv b">Box</code>类之外创建的新的<code class="fe ls lt lu lv b">Box</code>引用被声明为协变的，而不是实际的<code class="fe ls lt lu lv b">Box</code>类。这被称为调用点差异。由于差异是在使用地点定义的，因此也称为使用地点差异。</p><p id="43d5" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在Kotlin中，比我们在Java中看到的更进一步，我们可以通过使用<code class="fe ls lt lu lv b">out</code>操作符在编写holder类本身时声明一个类是协变的。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi pn"><img src="../Images/44618ad04aa32f5acd09ea5361934e5c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*yM3aAXmFU2llhDEUSwPshg.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">out运算符的用法。</p></figure><p id="9d2e" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们看到，当我们编写一个接受<code class="fe ls lt lu lv b">T</code>作为参数的方法时，声明一个类开始显示错误。换句话说，将<code class="fe ls lt lu lv b">T</code>声明为out将不允许您编写任何接受<code class="fe ls lt lu lv b">T</code>作为参数的方法。<code class="fe ls lt lu lv b">T</code>只能是返回类型，故名<code class="fe ls lt lu lv b">out</code>。</p><p id="d5be" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们在科特林的呼叫站点免费获得以下行为。我们必须在Java中为相同的内容创建协变引用。</p><ol class=""><li id="8f54" class="ou ov iq ky b kz la lc ld lf ow lj ox ln oy lr oz pa pb pc bi translated">只能从<code class="fe ls lt lu lv b">KtBox</code>对象中提取上限类。</li></ol><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi po"><img src="../Images/baa81edca552dae5a8eb5834b98a2860.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*1KAUBfBs5-pBnQT53uBZxg.png"/></div></div></figure><p id="d401" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">2.<code class="fe ls lt lu lv b">KtBox&lt;Father&gt;</code>可以被赋值给<code class="fe ls lt lu lv b">KtBox&lt;Grandfather&gt;</code>，而不需要我们在Java中通过创建协变引用所做的任何额外工作。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi pp"><img src="../Images/fb2627ee190ad3976c9aad4991b34963.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*agdTEdcXVaLwaRdmyovGOg.png"/></div></div></figure><p id="696c" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">Kotlin协方差可以在创建holder类时定义。因此，它也被称为“声明站点协方差”</p><h1 id="e3d8" class="lw lx iq bd ly lz ma mb mc md me mf mg jw mh jx mi jz mj ka mk kc ml kd mm mn bi translated">何时使用协方差的例子，又名 Extends XXXX&gt;</h1><ol class=""><li id="7222" class="ou ov iq ky b kz mo lc mp lf pf lj pg ln ph lr oz pa pb pc bi translated">同时构建一个API，从用户那里接受一些holder类并对其进行操作。例如，创建一个接受工作列表的<code class="fe ls lt lu lv b">startWork(List&lt;? extends BaseWork works)</code>方法。并且工作对象可以有多种实现，比如<code class="fe ls lt lu lv b">RxWork</code>、<code class="fe ls lt lu lv b">CoroutineWork</code>、<code class="fe ls lt lu lv b">ThreadWork</code>等。</li><li id="5816" class="ou ov iq ky b kz pi lc pj lf pk lj pl ln pm lr oz pa pb pc bi translated">我们也不想修改用户对它的请求，这会使你的框架方法内部的引用成为只读的。</li><li id="4d73" class="ou ov iq ky b kz pi lc pj lf pk lj pl ln pm lr oz pa pb pc bi translated">当你想构建一个像<code class="fe ls lt lu lv b">Box&lt;&gt;</code>一样的holder类，但是你想让它是只读的。</li></ol><h1 id="43f5" class="lw lx iq bd ly lz ma mb mc md me mf mg jw mh jx mi jz mj ka mk kc ml kd mm mn bi translated">离别赠言</h1><p id="acac" class="pw-post-body-paragraph kw kx iq ky b kz mo jr lb lc mp ju le lf mq lh li lj mr ll lm ln ms lp lq lr ij bi translated">这是一篇很长的文章，但我希望你能抓住要点。还有一种方差叫逆方差，和那个正好相反。我们会在<a class="ae kv" href="https://medium.com/better-programming/understanding-contravariance-the-java-wildcard-149853da1559" rel="noopener">下篇</a>中详细讨论。</p></div></div>    
</body>
</html>