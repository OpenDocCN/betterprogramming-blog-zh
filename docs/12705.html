<html>
<head>
<title>Build a Desktop Sharing Application With Nodejs, Electron, and Socket.io</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">用Nodejs、Electron和Socket.io构建一个桌面共享应用程序</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/desktop-sharing-application-with-nodejs-electron-and-socket-io-af389cb21d93?source=collection_archive---------1-----------------------#2022-06-24">https://betterprogramming.pub/desktop-sharing-application-with-nodejs-electron-and-socket-io-af389cb21d93?source=collection_archive---------1-----------------------#2022-06-24</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="7357" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">分3步完成</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/3e64a6bf1c872a3660f6c686aece9482.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*kAhmLgGzvLh92J3MlzlTXA.jpeg"/></div></div></figure><p id="36d9" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">什么是桌面共享应用？</p><p id="a769" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">桌面共享应用程序是一种允许通过您的桌面上提供的界面在另一个人的桌面上进行远程访问和远程协作的产品。这种软件的一个著名例子是anyDesk、TeamViewer等。</p><p id="58b4" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">还有一种屏幕共享方式，我们与其他用户共享整个或特定的窗口，但它不涉及任何操作，您只能查看屏幕，如缩放、google meet等。</p><h1 id="f399" class="ln lo iq bd lp lq lr ls lt lu lv lw lx jw ly jx lz jz ma ka mb kc mc kd md me bi translated"><strong class="ak">使用的技术堆栈:</strong></h1><ul class=""><li id="9f82" class="mf mg iq kt b ku mh kx mi la mj le mk li ml lm mm mn mo mp bi translated">节点. js</li><li id="1198" class="mf mg iq kt b ku mq kx mr la ms le mt li mu lm mm mn mo mp bi translated">电子. js</li><li id="4e9a" class="mf mg iq kt b ku mq kx mr la ms le mt li mu lm mm mn mo mp bi translated">Socket.io</li><li id="f763" class="mf mg iq kt b ku mq kx mr la ms le mt li mu lm mm mn mo mp bi translated">Robot.js</li></ul><h2 id="8ffe" class="mv lo iq bd lp mw mx dn lt my mz dp lx la na nb lz le nc nd mb li ne nf md ng bi translated">我们可以使用webRTC进行屏幕共享，那么为什么要考虑Socket.io呢？</h2><p id="b40d" class="pw-post-body-paragraph kr ks iq kt b ku mh jr kw kx mi ju kz la nh lc ld le ni lg lh li nj lk ll lm ij bi translated">我们可以通过webRTC轻松实现屏幕共享，所有这些都可以通过其客户端API实现，但问题是webRTC在stun服务器上仅提供有限的免费用户通信，为了扩大这一限制，我们必须使用第三方依赖，定制有点困难。因此，如果你有没有第三方依赖性的限制，并有定制的要求，那么使用自己的服务器将是一个很好的选择。</p><p id="2147" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">让我们开始构建它的主要功能。如果你只是来看代码，那么你可以在<a class="ae nk" href="https://github.com/jiaabid/screen-sharing-app.git" rel="noopener ugc nofollow" target="_blank"><strong class="kt ir"><em class="nl">git</em></strong></a><strong class="kt ir"><em class="nl">上找到完整的代码。</em> </strong>下面将是基本的通信结构。</p><p id="c7fe" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated"><strong class="kt ir">步骤1 </strong>:客户端将连接到socket服务器，通过socket服务器它们将相互通信。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nm"><img src="../Images/972fa2bb49b91f2edfedd7c27227046d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*d4JHC6oSMq_pd7Iw23koiQ.png"/></div></div></figure><p id="415d" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated"><strong class="kt ir">步骤2 </strong>:任何客户端都可以请求通过服务器连接到任何其他客户端。假设客户端A想要连接到客户端B，那么客户端A将请求服务器连接到客户端B。服务器将把该请求转发给客户端B。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nn"><img src="../Images/31bdf64f71183589d37eb30b746c460e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*uzI9iy8uME_A4lMKZsyUfQ.png"/></div></div></figure><p id="4fca" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated"><strong class="kt ir">第三步</strong>:如果客户端接受请求，将通过服务器通知源客户端。客户端B将接受客户端A的请求，服务器将通知客户端A。然后客户端B将开始向客户端A发送数据包</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi no"><img src="../Images/5b042edd43731c29f873175172027b51.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*vQgMSYLb6tSKhYMpy4Ywdw.png"/></div></div></figure><p id="0aec" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">这是应用程序的基本结构，为了快速概述，我将应用程序分为如下3个部分:</p><ul class=""><li id="aa73" class="mf mg iq kt b ku kv kx ky la np le nq li nr lm mm mn mo mp bi translated">如何通过socket服务器共享屏幕数据？</li><li id="40fb" class="mf mg iq kt b ku mq kx mr la ms le mt li mu lm mm mn mo mp bi translated">如何在共享屏幕上执行操作？</li><li id="c7d9" class="mf mg iq kt b ku mq kx mr la ms le mt li mu lm mm mn mo mp bi translated">指针精度算法。</li></ul><h1 id="8417" class="ln lo iq bd lp lq lr ls lt lu lv lw lx jw ly jx lz jz ma ka mb kc mc kd md me bi translated">如何通过服务器共享数据？</h1><p id="61ad" class="pw-post-body-paragraph kr ks iq kt b ku mh jr kw kx mi ju kz la nh lc ld le ni lg lh li nj lk ll lm ij bi translated">对于数据共享，我们通过socket.io实现了客户端和服务器的实时通信。</p><p id="d5b9" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">假设我们有两个客户端A和B，A将获取客户端B的远程访问权限，因此一旦客户端B接受连接请求A，客户端A将开始接收客户端B的屏幕截图。</p><p id="f31a" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">因此，服务器将向客户端B发出<code class="fe ns nt nu nv b">ready-for-data</code>事件，它将设置500ms的连续时间间隔，并截取屏幕截图，通过<code class="fe ns nt nu nv b">screen-data</code>事件发送给套接字服务器，如下所示:</p><pre class="kg kh ki kj gt nw nv nx ny aw nz bi"><span id="190a" class="mv lo iq nv b gy oa ob l oc od"><strong class="nv ir"><em class="nl">**client/controller/screen.controller.</em>js</strong></span><span id="d06d" class="mv lo iq nv b gy oe ob l oc od"><strong class="nv ir">//take screen shots and send the data to original screen</strong></span><span id="a2de" class="mv lo iq nv b gy oe ob l oc od">socket.on(“ready-for-data”, data =&gt; {</span><span id="4e3a" class="mv lo iq nv b gy oe ob l oc od">data = JSON.parse(data)<br/>data.status = true<br/>status = true</span><span id="8845" class="mv lo iq nv b gy oe ob l oc od">interval = setInterval(function () {</span><span id="bda6" class="mv lo iq nv b gy oe ob l oc od">screenshot().then((img) =&gt; {<br/>let dimension = sizeOf(img)<br/>var imgStr = new Buffer.from(img).toString(‘base64’);<br/>var obj = {};<br/>obj.room = data.myID;<br/>obj.image = imgStr;<br/>obj.dimension = dimension</span><span id="1d0b" class="mv lo iq nv b gy oe ob l oc od"><strong class="nv ir">//sending data to server</strong><br/>socket.emit(“screen-data”, JSON.stringify(obj));<br/>})<br/>}, 500)<br/>})</span></pre><p id="2b50" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">现在在服务器上，数据被接收并通过<code class="fe ns nt nu nv b">connected-screen-data</code>事件发送到客户端<strong class="kt ir"> A </strong>，如下所示:</p><pre class="kg kh ki kj gt nw nv nx ny aw nz bi"><span id="9265" class="mv lo iq nv b gy oa ob l oc od"><strong class="nv ir"><em class="nl">**server/index.js</em></strong></span><span id="c74d" class="mv lo iq nv b gy oe ob l oc od">socket.on(“screen-data”, function (data) {<br/>data = JSON.parse(data);<br/>var room = data.room;<br/>var imgStr = data.image;</span><span id="6cbc" class="mv lo iq nv b gy oe ob l oc od">//check if the connection exist of a client A<br/>if (roomMap.has(room)) {</span><span id="dfe8" class="mv lo iq nv b gy oe ob l oc od"><strong class="nv ir">//emitting to client A</strong><br/>socket.broadcast.to(room).emit(‘connected-screen-data’, {<br/>imgStr,<br/>dimension: data.dimension</span><span id="d28a" class="mv lo iq nv b gy oe ob l oc od">});</span><span id="a12f" class="mv lo iq nv b gy oe ob l oc od">}})</span></pre><p id="84ec" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">客户端<strong class="kt ir"> A </strong>将通过<code class="fe ns nt nu nv b">connected-screen-data</code>监听器接收该数据，并将其设置为整个屏幕画布。为了向屏幕发送数据，将使用电子的IPC。</p><p id="cf66" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">(<em class="nl">进程间通信(IPC)是呈现器和主进程通过其进行交互的电子特性</em>)</p><pre class="kg kh ki kj gt nw nv nx ny aw nz bi"><span id="af1d" class="mv lo iq nv b gy oa ob l oc od"><strong class="nv ir"><em class="nl">**client/controller/screen.controller.js</em></strong></span><span id="5a4c" class="mv lo iq nv b gy oe ob l oc od">//listening to the screen packets<br/>ipcMain.on(“screen-packets”, (e, arg) =&gt; {</span><span id="0fd8" class="mv lo iq nv b gy oe ob l oc od">socket.on(‘connected-screen-data’, data =&gt; {</span><span id="ca29" class="mv lo iq nv b gy oe ob l oc od">if (data.imgStr) {<br/>e.reply(“screen-packets-reply”, data)<br/>}<br/>})<br/>})</span></pre><p id="487e" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">这就是两个客户端共享屏幕的全部过程。</p><h1 id="4b7a" class="ln lo iq bd lp lq lr ls lt lu lv lw lx jw ly jx lz jz ma ka mb kc mc kd md me bi translated">如何在共享屏幕上执行操作？</h1><p id="10fa" class="pw-post-body-paragraph kr ks iq kt b ku mh jr kw kx mi ju kz la nh lc ld le ni lg lh li nj lk ll lm ij bi translated">正如我们所看到的，我们是在屏幕截图的帮助下共享屏幕的，那么问题来了，我们将如何在共享的屏幕上执行任何操作，如移动光标，点击任何地方，或打字等。所以对于这些操作，我们使用了一个名为<code class="fe ns nt nu nv b"><a class="ae nk" href="http://robotjs.io/" rel="noopener ugc nofollow" target="_blank">Robotjs</a></code>的库。这是一个桌面自动化库，通过它我们可以控制鼠标、键盘和阅读屏幕。</p><p id="e9ce" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">在我们的应用程序中，每当远程客户端(客户端<strong class="kt ir"> A </strong>)移动光标、点击或在屏幕上键入时，服务器上就会发出具有相应坐标的事件，然后服务器将其转发给主机客户端，在主机客户端<code class="fe ns nt nu nv b">robotjs</code>获取这些坐标并执行操作。</p><p id="03d6" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">例如，当客户端A点击共享屏幕时，<code class="fe ns nt nu nv b">ipcRenderer</code>向<code class="fe ns nt nu nv b">ipcMain</code>发送<code class="fe ns nt nu nv b">mouse-click</code>事件，并将其发送给服务器。</p><pre class="kg kh ki kj gt nw nv nx ny aw nz bi"><span id="6fae" class="mv lo iq nv b gy oa ob l oc od"><strong class="nv ir"><em class="nl">**client/js/screen.js</em></strong></span><span id="71e9" class="mv lo iq nv b gy oe ob l oc od">//when user click on the screen<br/>imgElement.addEventListener(“mouseup”, e =&gt; {<br/>ipcRenderer.send(“mouse-click”, {direction:e.which , double:false})<br/>})</span><span id="7102" class="mv lo iq nv b gy oe ob l oc od"><strong class="nv ir"><em class="nl">**client/controller/screen.controller.js</em></strong></span><span id="94d1" class="mv lo iq nv b gy oe ob l oc od">//host screen will send the server event to emit click event to original screen<br/>ipcMain.on(“mouse-click”, (e, arg) =&gt; {</span><span id="4ba6" class="mv lo iq nv b gy oe ob l oc od">socket.emit(“mouse-click”, { remoteID: Creds.remoteID, direction: arg.direction, double: arg.double })</span><span id="0dec" class="mv lo iq nv b gy oe ob l oc od">})</span></pre><p id="825b" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">现在，客户端B将监听套接字<code class="fe ns nt nu nv b">mouse-click</code>事件，并且<code class="fe ns nt nu nv b">robotjs</code>将执行该动作。</p><pre class="kg kh ki kj gt nw nv nx ny aw nz bi"><span id="f927" class="mv lo iq nv b gy oa ob l oc od"><strong class="nv ir"><em class="nl">**client/controller/screen.controller.js</em></strong></span><span id="f890" class="mv lo iq nv b gy oe ob l oc od">//click the original screen<br/>socket.on(“mouse-click”, function (data) {</span><span id="6ddc" class="mv lo iq nv b gy oe ob l oc od">let direction = “left”<br/>switch (data.direction) {<br/>case 1:<br/>direction = “left”<br/>break;<br/>case 2:<br/>direction = “middle”<br/>break;<br/>case 3:<br/>direction = “right”<br/>break;<br/>default:<br/>break;<br/>}</span><span id="55f2" class="mv lo iq nv b gy oe ob l oc od">//<strong class="nv ir">robotjs function to click</strong><br/>robot.mouseClick(direction, data.double);<br/>})</span></pre><p id="0ddc" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">查看<code class="fe ns nt nu nv b">robotjs</code> <a class="ae nk" href="http://robotjs.io/" rel="noopener ugc nofollow" target="_blank">的完整文档，点击</a> <em class="nl"> </em>查看其他操作——这是一个令人惊叹的桌面控制库。</p><h1 id="81fb" class="ln lo iq bd lp lq lr ls lt lu lv lw lx jw ly jx lz jz ma ka mb kc mc kd md me bi translated">指针精度算法:</h1><p id="72e4" class="pw-post-body-paragraph kr ks iq kt b ku mh jr kw kx mi ju kz la nh lc ld le ni lg lh li nj lk ll lm ij bi translated">在所有这些忙乱之后，出现的主要问题是指针的准确性，因为我们没有限制共享屏幕的大小，所以无论你的屏幕大小如何，共享屏幕都是一样的。因此，为了匹配不同的屏幕指针精度，我们使用了以下算法:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi of"><img src="../Images/6c906d531cb9c63b3b019d8051f58137.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*-H9w3artsnf8i47jLIWZaA.png"/></div></div><p class="og oh gj gh gi oi oj bd b be z dk translated">作者图片</p></figure><p id="757d" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">这就是保持指针精度的方法，并在名为<code class="fe ns nt nu nv b">mouse-move</code>的事件下使用。</p><h1 id="40b4" class="ln lo iq bd lp lq lr ls lt lu lv lw lx jw ly jx lz jz ma ka mb kc mc kd md me bi translated">结论</h1><p id="aee0" class="pw-post-body-paragraph kr ks iq kt b ku mh jr kw kx mi ju kz la nh lc ld le ni lg lh li nj lk ll lm ij bi translated">这就是我的屏幕共享应用程序的三个主要步骤。代码中还有很多东西——比如发送连接请求、设置密码和通过密码访问遥控器，以及双向共享文件。</p><p id="b4fc" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">到目前为止，我还没有遇到任何滞后的问题，因为屏幕数据是以base64字符串的形式共享的，仍在改进中，并公开征求建议。还计划增加更多的功能，比如聊天和通话。</p><p id="b784" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">你可以在我的GitHub库<a class="ae nk" href="https://github.com/jiaabid/screen-sharing-app.git" rel="noopener ugc nofollow" target="_blank">这里</a>找到完整的应用代码。</p></div></div>    
</body>
</html>