<html>
<head>
<title>The iOS View Drawing Cycle Demystified</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">iOS视图绘制周期揭秘</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/demystifying-the-view-drawing-cycle-fb1f7ac519f1?source=collection_archive---------6-----------------------#2020-06-04">https://betterprogramming.pub/demystifying-the-view-drawing-cycle-fb1f7ac519f1?source=collection_archive---------6-----------------------#2020-06-04</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="9ae2" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">理解为了表达我们的观点而调用的方法</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/2d28d17358b3b986d3b0ecc8bb8e9591.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*amB3GTBqciX9RsHu"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">照片由<a class="ae ky" href="https://unsplash.com/@nevenkrcmarek?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Neven Krcmarek </a>在<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</p></figure><p id="b6d8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">难度:初学者| <strong class="lb iu">简单</strong> |普通|挑战</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="56dc" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">先决条件</h1><ul class=""><li id="4269" class="mu mv it lb b lc mw lf mx li my lm mz lq na lu nb nc nd ne bi translated">对面向对象的一些理解将是有益的。</li></ul></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="cb36" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">iOS应用程序的主运行循环</h1><p id="246e" class="pw-post-body-paragraph kz la it lb b lc mw ju le lf mx jx lh li nf lk ll lm ng lo lp lq nh ls lt lu im bi translated">苹果已经启用iOS SDK来处理用户事件，并通过使用事件队列来触发应用程序内的响应。</p><p id="7407" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">当用户与应用程序交互时，事件被添加到事件队列中，然后可以由应用程序处理，并可能被分派给应用程序中的其他对象。一旦事件被处理，它们就将控制返回到主运行循环，并开始更新周期，该周期负责布局和绘制视图。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="5317" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">更新周期</h1><p id="3ee2" class="pw-post-body-paragraph kz la it lb b lc mw ju le lf mx jx lh li nf lk ll lm ng lo lp lq nh ls lt lu im bi translated">一旦控制返回到主运行循环，系统根据视图实例上的约束渲染布局。</p><p id="a7b8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">当视图被标记为需要在下一个更新周期中进行更改时，系统会执行所有更改。</p><p id="6eda" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">系统通过运行循环工作，然后在延迟布局通过之前进行约束。</p><h2 id="00a2" class="ni md it bd me nj nk dn mi nl nm dp mm li nn no mo lm np nq mq lq nr ns ms nt bi translated">延迟布局传递</h2><p id="c60f" class="pw-post-body-paragraph kz la it lb b lc mw ju le lf mx jx lh li nf lk ll lm ng lo lp lq nh ls lt lu im bi translated">约束通常会在创建视图控制器的过程中创建(可能在<code class="fe nu nv nw nx b">viewDidLoad()</code>函数中)。</p><p id="5411" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">然而，在运行时，系统不会立即对约束的动态变化采取行动。不幸的是，更改将处于陈旧状态，等待下一次延迟的布局传递——实际上，这可能永远不会发生。用户正在查看过时的视图。糟糕透了。</p><p id="15b1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">同样，对对象的其他更改(如更改控件的属性)也会更改对其他对象的约束，从而可能导致相同的问题。</p><p id="956d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">对此的解决方案是通过在相关视图上调用<code class="fe nu nv nw nx b">setNeedsLayout()</code>(或<code class="fe nu nv nw nx b">setNeedsUpdateConstraints()</code>)来请求一个延迟的布局传递。</p><p id="9477" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">从技术上讲，延迟布局走刀(<a class="ae ky" href="https://developer.apple.com/library/archive/documentation/UserExperience/Conceptual/AutolayoutPG/ModifyingConstraints.html#//apple_ref/doc/uid/TP40010853-CH29-SW2" rel="noopener ugc nofollow" target="_blank">根据文件</a>)包括两次走刀:</p><ol class=""><li id="db22" class="mu mv it lb b lc ld lf lg li ny lm nz lq oa lu ob nc nd ne bi translated">更新过程会根据需要更新约束。这将调用所有视图控制器上的<code class="fe nu nv nw nx b">updateViewConstraints</code>方法和所有视图上的<code class="fe nu nv nw nx b">updateConstraints</code>方法。</li><li id="55da" class="mu mv it lb b lc oc lf od li oe lm of lq og lu ob nc nd ne bi translated">布局过程根据需要重新定位视图的框架。这将调用所有视图控制器上的<code class="fe nu nv nw nx b">viewWillLayoutSubviews</code>和每个视图上的<code class="fe nu nv nw nx b">layoutSubviews</code>。</li></ol><p id="507c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">相关方法？它们就在下面，但在文章的后面会有更深入的探讨。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi oh"><img src="../Images/9c28e66608cc58f0919d7d8e4d08fd5a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1000/format:webp/1*Vq9ZVUzTFeDx_R3ZgYKsWg.png"/></div></figure></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="b25f" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">无限循环的风险</h1><p id="70e9" class="pw-post-body-paragraph kz la it lb b lc mw ju le lf mx jx lh li nf lk ll lm ng lo lp lq nh ls lt lu im bi translated">我们将视图放在一个列表上，以请求对延迟的布局传递进行更新。这样做的风险在于，通过每一次传递，都会产生另一个延迟布局传递的请求。</p><ul class=""><li id="5d9d" class="mu mv it lb b lc ld lf lg li ny lm nz lq oa lu nb nc nd ne bi translated">当重写方法时，总是调用超类。</li><li id="f7fe" class="mu mv it lb b lc oc lf od li oe lm of lq og lu nb nc nd ne bi translated">不要在<code class="fe nu nv nw nx b">layoutSubviews</code>里面叫<code class="fe nu nv nw nx b">setNeedsLayout()</code>。</li><li id="8755" class="mu mv it lb b lc oc lf od li oe lm of lq og lu nb nc nd ne bi translated">不要在<code class="fe nu nv nw nx b">updateConstraints()</code>内呼叫<code class="fe nu nv nw nx b">setNeedsUpdateConstraints()</code>。</li></ul></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="3083" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">使用setNeedsDisplay强制重绘</h1><p id="7989" class="pw-post-body-paragraph kz la it lb b lc mw ju le lf mx jx lh li nf lk ll lm ng lo lp lq nh ls lt lu im bi translated"><code class="fe nu nv nw nx b">setNeedsDisplay()</code>强制重绘特定视图。因为你永远不应该直接调用<code class="fe nu nv nw nx b">draw(_ rect: CGRect)</code>，你可以把<code class="fe nu nv nw nx b">setNeedsDisplay() </code>想象成一个向UIKit请求重绘的方法。另一种思考方式是，调用<code class="fe nu nv nw nx b">setNeedsDisplay()</code>将视图标记为脏视图；也就是说，在下一个更新周期，视图将通过延迟的布局过程重新绘制。</p><p id="f685" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">由于传递被延迟，它将发生在下一个更新周期，在此期间将在所有这样的视图上调用<code class="fe nu nv nw nx b">func draw(<strong class="lb iu">_</strong>:)</code>。</p><p id="8728" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">对于初学者来说，这似乎有点令人困惑，因为大多数UI组件已经为我们解决了这个问题。但是，可能有一个属性不直接绑定到UI组件，我们需要通知Swift我们的调用是什么。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi oi"><img src="../Images/ff5016846e90100236aa5d9df8f27059.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*yTZ8R_d59Y7aFWqyG67RLA.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated"><a class="ae ky" href="https://gist.github.com/stevencurtis/8ec7ca6596d3c9a16a04d900e0d17587" rel="noopener ugc nofollow" target="_blank">点击查看要点</a></p></figure></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="d5ba" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">使用setNeedsLayout触发布局刷新</h1><p id="7413" class="pw-post-body-paragraph kz la it lb b lc mw ju le lf mx jx lh li nf lk ll lm ng lo lp lq nh ls lt lu im bi translated">当视图改变时，布局也会改变，这需要通过自动布局进行重新计算。</p><p id="54fe" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">通常，布局会自动更新。也就是说，当调整视图大小时，它被添加到视图层次结构中，约束被更新，设备被旋转或用户滚动。</p><p id="715f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">有些情况下，我们需要强制重新计算特定视图实例的布局。这些将在接下来的几个方法中讨论。</p><h2 id="2a0d" class="ni md it bd me nj nk dn mi nl nm dp mm li nn no mo lm np nq mq lq nr ns ms nt bi translated">setNeedsLayout()</h2><p id="76c5" class="pw-post-body-paragraph kz la it lb b lc mw ju le lf mx jx lh li nf lk ll lm ng lo lp lq nh ls lt lu im bi translated"><code class="fe nu nv nw nx b">setNeedsLayout()</code>要求更新特定视图的布局。这将发生在下一个更新周期，由于iOS设备屏幕的快速刷新，应该足够快，用户不会遇到任何延迟。</p><h2 id="931c" class="ni md it bd me nj nk dn mi nl nm dp mm li nn no mo lm np nq mq lq nr ns ms nt bi translated">layoutIfNeeded()</h2><p id="498d" class="pw-post-body-paragraph kz la it lb b lc mw ju le lf mx jx lh li nf lk ll lm ng lo lp lq nh ls lt lu im bi translated">这与<code class="fe nu nv nw nx b">layoutIfNeeded()</code>相似，因为它强制立即更新布局。使用它的一个特殊例子是约束的<a class="ae ky" href="https://medium.com/@stevenpcurtis.sc/how-to-animate-auto-layout-constraints-fd114ab483c0" rel="noopener">动画，由于动画的原因，它需要立即更新。</a></p><h2 id="23d3" class="ni md it bd me nj nk dn mi nl nm dp mm li nn no mo lm np nq mq lq nr ns ms nt bi translated">布局子视图</h2><p id="b5b5" class="pw-post-body-paragraph kz la it lb b lc mw ju le lf mx jx lh li nf lk ll lm ng lo lp lq nh ls lt lu im bi translated">当视图调整大小时，包括第一次设置时，调用<code class="fe nu nv nw nx b">layoutSubview</code>方法。这意味着覆盖这将是一个合适的位置来设置一个UIView，或类似的圆角半径。</p><p id="20fd" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这不是直接调用，而是由系统在视图第一次布局(即第一次绘图)和旋转时触发。可通过<code class="fe nu nv nw nx b">setNeedsLayout()</code>请求下一次图纸更新，或通过<code class="fe nu nv nw nx b">layoutIfNeeded()</code>立即强制更新。</p><p id="95d3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果你在一个视图控制器<code class="fe nu nv nw nx b"><a class="ae ky" href="https://developer.apple.com/documentation/uikit/uiviewcontroller/1621398-viewdidlayoutsubviews" rel="noopener ugc nofollow" target="_blank">viewDidLayoutSubviews()</a></code>中工作，这里是你的类似方法。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="eb52" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">更新约束</h1><p id="7080" class="pw-post-body-paragraph kz la it lb b lc mw ju le lf mx jx lh li nf lk ll lm ng lo lp lq nh ls lt lu im bi translated">当视图被更新时，调用<code class="fe nu nv nw nx b">func draw(<strong class="lb iu">_</strong> rect: CGRect)</code>方法(如果有的话)。</p><p id="761e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">不要使用<code class="fe nu nv nw nx b">updateConstraints()</code>进行视图的初始设置。当您需要在单个布局过程中添加、修改或删除大量约束时，使用它可以获得最佳性能。但是在实践中，无论如何，在适当的位置改变它们通常是有意义的。因此，使用这种方法可能有性能方面的原因，但通常情况下，您不应该这样做。</p><p id="72de" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe nu nv nw nx b">UpdateConstraints</code>还有一个<code class="fe nu nv nw nx b">viewController</code>、<code class="fe nu nv nw nx b">updateViewConstraints()</code>的兄弟函数，可能会有用。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="b171" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">理解坐标</h1><p id="7d7c" class="pw-post-body-paragraph kz la it lb b lc mw ju le lf mx jx lh li nf lk ll lm ng lo lp lq nh ls lt lu im bi translated">作为一名专注于Swift的开发人员，了解一个视图如何更新以及它如何与UIView中的方法相关对于您的旅程至关重要。</p><p id="63b0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">任何特定UIView的坐标都从左上角开始，如下图所示:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi oj"><img src="../Images/82c064b7f992225a98620b4f66115fe8.png" data-original-src="https://miro.medium.com/v2/resize:fit:968/format:webp/1*po5X6z_9JuHJXywFPx0WUg.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">0，0坐标</p></figure></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="72ce" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">结论</h1><p id="2359" class="pw-post-body-paragraph kz la it lb b lc mw ju le lf mx jx lh li nf lk ll lm ng lo lp lq nh ls lt lu im bi translated">在UIKit中，使用视图极其重要。有相当多的东西需要理解和习惯，但是掌握这些概念对您作为开发人员的旅程有所帮助是很重要的。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="2419" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">扩展你的知识</h1><ul class=""><li id="fa99" class="mu mv it lb b lc mw lf mx li my lm mz lq na lu nb nc nd ne bi translated">阅读<a class="ae ky" href="https://developer.apple.com/library/archive/documentation/2DDrawing/Conceptual/DrawingPrintingiOS/GraphicsDrawingOverview/GraphicsDrawingOverview.html" rel="noopener ugc nofollow" target="_blank">苹果关于绘图概念的文档</a>。</li><li id="2218" class="mu mv it lb b lc oc lf od li oe lm of lq og lu nb nc nd ne bi translated">苹果有关于延期布局的文档。</li></ul></div></div>    
</body>
</html>