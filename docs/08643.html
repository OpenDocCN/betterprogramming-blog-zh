<html>
<head>
<title>7 Advanced Python Concepts You Might Want To Know</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">你可能想知道的7个高级Python概念</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/advanced-python-concepts-257076fa8e35?source=collection_archive---------5-----------------------#2021-05-25">https://betterprogramming.pub/advanced-python-concepts-257076fa8e35?source=collection_archive---------5-----------------------#2021-05-25</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="ab38" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">多重继承、元类等等</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/4ceffc6ae0e6637a13395fdd2630e07c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*4dvUTLbWnSNfRU-c46xkLw.jpeg"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">Chris Ried 在<a class="ae kv" href="https://unsplash.com/s/photos/code?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍照。</p></figure><p id="4b63" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">Python是世界上最流行的编程语言。大多数应用程序只需要Python多样化武库中的一小部分。但是，如果您想成为真正的Python专家，您也应该学习和掌握这些概念。</p></div><div class="ab cl ls lt hu lu" role="separator"><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx"/></div><div class="ij ik il im in"><h1 id="45af" class="lz ma iq bd mb mc md me mf mg mh mi mj jw mk jx ml jz mm ka mn kc mo kd mp mq bi translated">多重遗传</h1><p id="edbf" class="pw-post-body-paragraph kw kx iq ky b kz mr jr lb lc ms ju le lf mt lh li lj mu ll lm ln mv lp lq lr ij bi translated">类可以从不止一个主类继承。它们可以从多个。这允许您结合多个基类的优势来创建一个非常多样化和强大的类。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mw mx l"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">多重遗传</p></figure><p id="4ae8" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">虽然真正的多重继承(即从两个或更多充实的类继承)是不被认可的，但是从一个基类继承然后继承一些其他非常特殊的类是经常使用的。这些专门的类被称为<em class="my"> mixins </em>，通常只有在与某些基类结合时才起作用。</p><p id="d15c" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">一个很好的使用mixins <em class="my"> </em>的框架是<a class="ae kv" href="https://www.django-rest-framework.org/" rel="noopener ugc nofollow" target="_blank"> Django Rest框架</a>。您可以选择一个基本的<code class="fe mz na nb nc b">View</code>类，然后您可以轻松地添加GET、POST或PUT mixins。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mw mx l"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">Django Rest框架中的多重继承。来源:<a class="ae kv" href="https://www.django-rest-framework.org/tutorial/3-class-based-views/" rel="noopener ugc nofollow" target="_blank"> Django Rest框架</a></p></figure><p id="3696" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><code class="fe mz na nb nc b">ListModelMixin</code> <em class="my"> </em>和<code class="fe mz na nb nc b">CreateModelMixin</code> <em class="my"> </em>将具有基于Django模型获取和更新数据库中正确数据的逻辑——并且只使用这两个单词进行继承。</p><p id="f4a0" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">需要记住的一点是，任何解析都是从左到右进行的。所以如果一个方法同时在<code class="fe mz na nb nc b">BaseClassA</code> <em class="my"> </em>和<code class="fe mz na nb nc b">BaseClassB</code>中定义，那么它将从<code class="fe mz na nb nc b">BaseClassB</code> <em class="my">、</em>中取最先定义的方法。这对于类中的任何<code class="fe mz na nb nc b">super()</code>调用都是一样的。这种方法解析是不鼓励继承多个扩展类的原因，因为它会造成很多混乱。保持一个基类和几个专门的混合。</p></div><div class="ab cl ls lt hu lu" role="separator"><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx"/></div><div class="ij ik il im in"><h1 id="1d10" class="lz ma iq bd mb mc md me mf mg mh mi mj jw mk jx ml jz mm ka mn kc mo kd mp mq bi translated">邓德方法</h1><p id="65c3" class="pw-post-body-paragraph kw kx iq ky b kz mr jr lb lc ms ju le lf mt lh li lj mu ll lm ln mv lp lq lr ij bi translated">Dunder方法是以双下划线开始和结束的Python方法。这些有时也被称为魔术方法。你可以在文档中找到完整的列表<a class="ae kv" href="https://docs.python.org/3/reference/datamodel.html" rel="noopener ugc nofollow" target="_blank">。</a></p><p id="7c98" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">一些dunder方法是众所周知的，比如<code class="fe mz na nb nc b">__init__</code>或<code class="fe mz na nb nc b">__str__</code>。但是还有很多其他的值得一看。</p><h2 id="c8ec" class="nd ma iq bd mb ne nf dn mf ng nh dp mj lf ni nj ml lj nk nl mn ln nm nn mp no bi translated">打电话</h2><p id="33e2" class="pw-post-body-paragraph kw kx iq ky b kz mr jr lb lc ms ju le lf mt lh li lj mu ll lm ln mv lp lq lr ij bi translated"><code class="fe mz na nb nc b">__call__</code>允许你执行一个对象作为一个函数。如果您有一些默认功能要在类中使用，或者当您想要互换使用方法和对象时，这将非常有用。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mw mx l"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">__call__提供舍入金额的函数元素示例</p></figure><p id="5ea2" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">使用call方法，您可以将对对象属性的轻松访问与函数的简单使用结合起来。</p><h2 id="79e8" class="nd ma iq bd mb ne nf dn mf ng nh dp mj lf ni nj ml lj nk nl mn ln nm nn mp no bi translated">经营者</h2><p id="fa9d" class="pw-post-body-paragraph kw kx iq ky b kz mr jr lb lc ms ju le lf mt lh li lj mu ll lm ln mv lp lq lr ij bi translated">您也可以覆盖任何您喜欢的运算符，如加、减、乘、除。还有幂、floored division、矩阵乘法、模(<code class="fe mz na nb nc b"><em class="my">@</em></code>)。也可以实现比较语句，如大于、小于或等于。最后，您有像<code class="fe mz na nb nc b">and</code>、<code class="fe mz na nb nc b">invert</code>和<code class="fe mz na nb nc b">or</code>这样的逻辑操作符。请记住，<code class="fe mz na nb nc b">__and__</code>、<code class="fe mz na nb nc b">__invert__</code>、<em class="my">、</em>、<code class="fe mz na nb nc b">__or__</code>、<em class="my">、</em>方法指的是按位<code class="fe mz na nb nc b">ands</code> ( <code class="fe mz na nb nc b">a &amp; b</code>)、<code class="fe mz na nb nc b">inverts</code> ( <code class="fe mz na nb nc b">~a</code>)、<code class="fe mz na nb nc b">ors</code> ( <code class="fe mz na nb nc b">a | b</code>)。<code class="fe mz na nb nc b">and</code>、<code class="fe mz na nb nc b">not</code>和<code class="fe mz na nb nc b">or</code>语句会将对象转换为布尔值，然后对表达式求值。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mw mx l"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">操作员魔术方法</p></figure><p id="dce5" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">许多这些方法都有相应的<code class="fe mz na nb nc b">__r(method)__</code>实现。这在没有实现从左到右实现时使用。当我们做<code class="fe mz na nb nc b">5 + a</code>的时候，这个会被调用。这就是为什么重要的不是出错而是返回<code class="fe mz na nb nc b">NotImplemented</code>。类似的事情也存在于<code class="fe mz na nb nc b">__i(method)__</code>中，例如<code class="fe mz na nb nc b">a += 5</code>中的计算将在适当的位置完成。</p><p id="9271" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">重写这些神奇的方法在图书馆中非常流行。在NumPy中，矩阵覆盖了标准实现，提供了矩阵运算的强大而简洁的用法。在Django中，or和ands可以用来组合<code class="fe mz na nb nc b">QuerySets</code> or过滤器。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mw mx l"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">NumPy和Django——魔法方法的使用</p></figure></div><div class="ab cl ls lt hu lu" role="separator"><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx"/></div><div class="ij ik il im in"><h1 id="9ffb" class="lz ma iq bd mb mc md me mf mg mh mi mj jw mk jx ml jz mm ka mn kc mo kd mp mq bi translated">发电机</h1><p id="badf" class="pw-post-body-paragraph kw kx iq ky b kz mr jr lb lc ms ju le lf mt lh li lj mu ll lm ln mv lp lq lr ij bi translated">生成器是可以迭代的对象。最常见的例子是range函数。使用生成器的好处是，您不需要将整个数据结构保存在内存中。生成器只是跟踪需要什么来提供下一个值。</p><p id="0c89" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">发电机有两种类型。第一类是包含<code class="fe mz na nb nc b">yield</code> <em class="my"> </em>语句的函数。第二种类型是已经实现了<code class="fe mz na nb nc b">__iter__</code> <em class="my"> </em>和<code class="fe mz na nb nc b">__next__</code>方法的对象。</p><p id="fdcb" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">任何包含<code class="fe mz na nb nc b">yield</code> <em class="my"> </em>语句的函数都将成为生成器。迭代函数将执行函数，直到执行完<code class="fe mz na nb nc b">yield</code> <em class="my"> </em>语句，并返回第一个值。对于第二个值，它将从关键字继续，直到下一个<code class="fe mz na nb nc b">yield</code>。这种情况会一直发生，直到函数结束或出现<code class="fe mz na nb nc b">StopIteration</code>错误。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mw mx l"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">函数生成器</p></figure><p id="842c" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">基于对象的迭代器需要两种方法才能工作:<code class="fe mz na nb nc b">__iter__</code> <em class="my"> </em>和<code class="fe mz na nb nc b">__next__</code>。<code class="fe mz na nb nc b">__iter__</code>会初始化迭代，需要返回生成器(一般是自身)。<code class="fe mz na nb nc b">__next__</code>将被调用以获取下一个值。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mw mx l"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">对象生成器</p></figure><p id="2b5a" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">对于发电机，你必须记住两件事。一旦迭代，它们必须再次初始化。您不能使用它们来迭代两次。其次，您也可以使用内置的<code class="fe mz na nb nc b">next</code> <em class="my"> </em>函数手动迭代它们。</p></div><div class="ab cl ls lt hu lu" role="separator"><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx"/></div><div class="ij ik il im in"><h1 id="ac8c" class="lz ma iq bd mb mc md me mf mg mh mi mj jw mk jx ml jz mm ka mn kc mo kd mp mq bi translated">上下文管理器</h1><p id="573e" class="pw-post-body-paragraph kw kx iq ky b kz mr jr lb lc ms ju le lf mt lh li lj mu ll lm ln mv lp lq lr ij bi translated">每个有自尊心的Python开发者都知道他们需要如何处理文件。要么在打开文件后确保将其关闭，要么使用<code class="fe mz na nb nc b">with</code> <em class="my"> </em>语句。<code class="fe mz na nb nc b">with</code> <em class="my"> </em>语句称为上下文管理器。它可以在任何时候使用，当您需要在启动时进行初始化，或者在停止使用后进行清理——特别是当发生错误时也需要进行清理。</p><p id="6e78" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">创建自己的上下文管理器很容易。您需要实现<code class="fe mz na nb nc b">__enter__</code> <em class="my"> </em>和<code class="fe mz na nb nc b">__exit__</code> dunder方法。然后你可以使用<code class="fe mz na nb nc b">with</code>声明来确保你安全地清理干净。enter方法返回的值被赋予<code class="fe mz na nb nc b">as</code> <em class="my"> </em>语句。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mw mx l"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">上下文管理器</p></figure><p id="8fb8" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这对于I/O操作非常有用，因为您希望确保在之后关闭已使用的资源。这将避免悬空连接和打开文件。</p><p id="c177" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">最后，exit方法还可以处理引发的错误。类型、值和引用都是错误信息。您可以使用这些来处理异常。如果从exit方法返回一个<code class="fe mz na nb nc b">True</code>值，Python将不会再次引发异常，并照常继续。</p><p id="b921" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">如果使用<code class="fe mz na nb nc b">contextlib.contextmanager</code>装饰器，生成器函数也可以用作带有<code class="fe mz na nb nc b">yield</code>关键字的上下文管理器。但我会让你自己去想。</p></div><div class="ab cl ls lt hu lu" role="separator"><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx"/></div><div class="ij ik il im in"><h1 id="84f5" class="lz ma iq bd mb mc md me mf mg mh mi mj jw mk jx ml jz mm ka mn kc mo kd mp mq bi translated">阿辛西奥</h1><p id="e624" class="pw-post-body-paragraph kw kx iq ky b kz mr jr lb lc ms ju le lf mt lh li lj mu ll lm ln mv lp lq lr ij bi translated">Python库允许你的代码异步运行吗？在开始之前，请确保了解线程、异步和多处理器之间的区别。我建议阅读<a class="ae kv" rel="noopener ugc nofollow" target="_blank" href="/which-should-you-use-asynchronous-programming-or-multi-threading-7435ec9adc8e">这篇文章</a>。简而言之，<code class="fe mz na nb nc b">asyncio</code>允许您在等待慢速操作时处理其他东西(通常是IO、数据库或网络)。如果没有这些操作，<code class="fe mz na nb nc b">asyncio</code>不会提高代码性能。</p><p id="8286" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">实现<code class="fe mz na nb nc b">asyncio</code>非常容易。通过将<code class="fe mz na nb nc b">async</code>放在定义前面，您可以使任何函数异步。当您调用该函数时，它将返回一个<code class="fe mz na nb nc b">Future</code>对象。为了得到未来的结果，你需要<code class="fe mz na nb nc b">await</code>它。Python将通过在等待时执行其他代码来调度<code class="fe mz na nb nc b">Future</code>对象的正确执行。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mw mx l"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">阿辛西奥</p></figure><p id="b750" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这里，我们从数据库中得到一些记录。只要我们有一个兼容<code class="fe mz na nb nc b">asyncio</code>的数据库，它就能够并行获取记录。我们先初始化所有的请求，然后再处理它们。当代码等待一行时，它已经请求下一行，依此类推。</p><p id="519a" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">作为对比，我们也有一个用<code class="fe mz na nb nc b">await</code>做列表理解的烂例子。这不会提高性能，因为事件循环会等到获取上一条记录后再请求下一条记录。所以一定要使用<code class="fe mz na nb nc b">gather</code>或者类似的方法来提高性能。</p><p id="c6d2" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">随着<code class="fe mz na nb nc b">asyncio</code>而来的是一些额外的under方法。您可以实现<code class="fe mz na nb nc b">await</code>魔法方法来使一个对象变得可唤醒。对于异步上下文管理器，可以使用<code class="fe mz na nb nc b">__aenter__</code> <em class="my"> </em>和<code class="fe mz na nb nc b">__aexit__</code> <em class="my"> </em>，对于异步迭代器，可以实现<code class="fe mz na nb nc b">__aiter__</code>和<code class="fe mz na nb nc b">__anext__</code>。</p></div><div class="ab cl ls lt hu lu" role="separator"><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx"/></div><div class="ij ik il im in"><h1 id="0e49" class="lz ma iq bd mb mc md me mf mg mh mi mj jw mk jx ml jz mm ka mn kc mo kd mp mq bi translated">__new__和对象初始化</h1><p id="c798" class="pw-post-body-paragraph kw kx iq ky b kz mr jr lb lc ms ju le lf mt lh li lj mu ll lm ln mv lp lq lr ij bi translated">在<code class="fe mz na nb nc b">__init__</code>之前，每当您创建一个类的新实例时，就会调用<code class="fe mz na nb nc b">__new__</code> <em class="my"> </em> dunder类方法。它是一个类方法，应该返回该类的一个实例。您可以控制创建类中的对象时返回的实例。你甚至可以返回另一个类对象！<code class="fe mz na nb nc b">__init__</code> <em class="my"> </em>将在你返回的实例上被调用。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mw mx l"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">新邓德方法</p></figure><p id="73a5" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">虽然经常是非传统的，甚至有争议，这种方法确实有它的用途。最常见的例子是单例实现。使用类作为基类将确保一次只初始化其中一个。单例也可以用其他方式强制执行，但是我觉得<code class="fe mz na nb nc b">__new__</code> <em class="my"> </em>方法提供了一个非常方便的实现。</p><p id="b0cb" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">第二个例子类似于其他语言中的工厂模式。基于输入，新方法可以返回适当的类。和前面的例子一样，工厂对象或静态函数也可以产生相同的结果。但是我发现新方法对于同样的问题是一个非常干净简洁的解决方案。</p></div><div class="ab cl ls lt hu lu" role="separator"><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx"/></div><div class="ij ik il im in"><h1 id="0606" class="lz ma iq bd mb mc md me mf mg mh mi mj jw mk jx ml jz mm ka mn kc mo kd mp mq bi translated">元类</h1><p id="32fd" class="pw-post-body-paragraph kw kx iq ky b kz mr jr lb lc ms ju le lf mt lh li lj mu ll lm ln mv lp lq lr ij bi translated">元类将类向前推进了一步。它们允许你动态地调整你的类的属性或方法。文本不能公平对待元类，所以这里有一个例子:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mw mx l"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">环境的元类</p></figure><p id="9a0a" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><code class="fe mz na nb nc b">Environment</code>类将在一个有用的类中加载环境变量。它可以很好地处理输入提示，并避免使用相同的代码一次又一次地加载环境变量。您甚至可以设置默认值或使用它将值转换为正确的类型！</p><p id="a471" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">要定义一个元类，需要用命名继承来设置它。新函数的输出必须是一个类(它是一个元类实例)。它将定义类是什么以及它的行为方式。</p><p id="4c9f" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">输入参数是:</p><ul class=""><li id="bdc5" class="np nq iq ky b kz la lc ld lf nr lj ns ln nt lr nu nv nw nx bi translated">元类(因为默认情况下<code class="fe mz na nb nc b">__new__</code>是一个类方法)</li><li id="2b63" class="np nq iq ky b kz ny lc nz lf oa lj ob ln oc lr nu nv nw nx bi translated">(非元)类的名称</li><li id="4198" class="np nq iq ky b kz ny lc nz lf oa lj ob ln oc lr nu nv nw nx bi translated">(非元)类的子类/基</li><li id="b63f" class="np nq iq ky b kz ny lc nz lf oa lj ob ln oc lr nu nv nw nx bi translated">非元类的命名空间</li></ul><p id="b977" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">名称空间是这里有趣的部分。它将包含在(非元)类上定义的所有字段，如果它们有值的话。它还提供一些其他信息，如注释。这里，我们使用注释将环境变量设置为类属性。通过一些额外的逻辑，您还可以将它们转换为正确的类型或引发适当的错误。</p><p id="9d8d" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">再举一个例子，Django在它的模型上使用它来将模型属性转换成数据库中的相关值。Pydantic使用类似的方法来检索其模型的注释。</p><p id="442d" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">不过，非常重要的一点是:元类的new方法会在类定义后立即执行，而不是在每次对象初始化时执行。所以要确保你的类是完整的，并且元类不需要额外的信息。</p></div><div class="ab cl ls lt hu lu" role="separator"><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx"/></div><div class="ij ik il im in"><h1 id="1970" class="lz ma iq bd mb mc md me mf mg mh mi mj jw mk jx ml jz mm ka mn kc mo kd mp mq bi translated">结论</h1><p id="a66b" class="pw-post-body-paragraph kw kx iq ky b kz mr jr lb lc ms ju le lf mt lh li lj mu ll lm ln mv lp lq lr ij bi translated">并非所有这些都同样有用。尤其是元类并不常见，这是有充分理由的。你可以成为一个严肃的程序员，而不需要深入了解所有这些概念。</p><p id="9c2d" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">但是我认为这篇文章为你提供了一些选择，有时可以做得更好。更深层次地理解Python可以让你理解正在发生的事情，你也将能够更好地理解一些大量使用这些高级方法的高级库(例如Django、SQLAlchemy和Pydantic)。</p></div></div>    
</body>
</html>