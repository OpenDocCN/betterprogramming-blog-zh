<html>
<head>
<title>Making HTTP Requests in Solidity</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">在Solidity中发出HTTP请求</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/making-http-requests-in-solidity-b472c2b5e5f1?source=collection_archive---------5-----------------------#2020-09-04">https://betterprogramming.pub/making-http-requests-in-solidity-b472c2b5e5f1?source=collection_archive---------5-----------------------#2020-09-04</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="87d9" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">HTTP请求在以太坊上工作，并与所谓的神谕保持一致</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/406471013d17a955fb35c220b8fc1787.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*8BJDSd53gKNSN9IZJG1t_Q.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">通过<a class="ae ky" href="http://canva.com/" rel="noopener ugc nofollow" target="_blank">Canva.com</a>从佩什科夫获得的原始背景图像</p></figure><p id="872c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><a class="ae ky" href="https://blog.chain.link/apis-smart-contracts-and-how-to-connect-them/" rel="noopener ugc nofollow" target="_blank">使用Chainlink在Solidity </a>中发出HTTP请求很简单。如果你想了解更多关于最佳实践的见解，那么在阅读完这篇文章后，请务必阅读区块链上的<a class="ae ky" href="https://towardsdatascience.com/api-calls-on-blockchain-best-practice-for-data-collection-11f1fc86a2be?source=friends_link&amp;sk=687abac3f4ff6dba953046d52a648124" rel="noopener" target="_blank"> API调用</a>。</p><p id="5cd2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们退一步开始。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="7bba" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">如何制作一个链接请求？</h1><p id="6afe" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">记住<a class="ae ky" href="https://ethereum.stackexchange.com/a/85181/57451" rel="noopener ugc nofollow" target="_blank">chain link Oracle</a>是区块链中间件，所以我们需要一些东西以编程方式告诉它们发出HTTP请求。我们需要一些东西来<em class="mz">启动</em>他们开始为我们获取数据。这些告诉链节节点开始获取数据的指令被称为<a class="ae ky" href="https://docs.chain.link/docs/initiators" rel="noopener ugc nofollow" target="_blank">链节启动器</a>。</p><p id="eeeb" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">一个链接节点可以有任意多的启动器。每个都将为节点定义不同的方式来开始获取数据。</p><p id="609c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu">启动器1:当x发生时开始获取数据</strong></p><p id="b320" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu">启动器2:当y发生时开始获取数据</strong></p><p id="0972" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu">启动器3:当z发生时开始获取数据</strong></p><p id="1019" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu">等等……</strong></p><p id="19b7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">以及一组当它们被启动时该做什么的指令。这组关于做什么的指令被称为“任务”或“<a class="ae ky" href="https://docs.chain.link/docs/adapters" rel="noopener ugc nofollow" target="_blank">适配器</a>列表。</p><p id="8f64" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu">适配器1:接收到数据后对数据进行q操作</strong></p><p id="f409" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu">适配器2:一旦接收到数据，立即进行响应</strong></p><p id="20ab" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu">适配器3:接收到数据后执行s操作</strong></p><p id="ebd5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu">等等……</strong></p><p id="efd0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">启动器和适配器的组合在一个chainlink节点上组成一个<a class="ae ky" href="https://docs.chain.link/docs/job-specifications" rel="noopener ugc nofollow" target="_blank">单一作业</a>。Chainlink节点可以定义多个作业，以便它们可以在一个简单的界面中做许多不同的事情。</p><p id="2dc3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">下面是一个示例作业定义的样子，您可以看到它在顶部定义了一个<code class="fe na nb nc nd b">initiators</code>列表，然后在后面定义了一个<code class="fe na nb nc nd b">adapters</code> / <code class="fe na nb nc nd b">tasks</code>列表。您还可以看到，启动器可以接受参数，以允许它们执行更多操作。这个示例作业定义被称为<code class="fe na nb nc nd b">jobspec</code>。</p><pre class="kj kk kl km gt ne nd nf ng aw nh bi"><span id="3c01" class="ni md it nd b gy nj nk l nl nm">{<br/>  "initiators": [<br/>    {<br/>      "type": "runlog",<br/>      "params": {<br/>        "address": "0xd8c819674b79c7372d56db03280a5695a9254894"<br/>      }<br/>    }<br/>  ],<br/>  "tasks": [<br/>    {<br/>      "type": "httpget"<br/>    },<br/>    {<br/>      "type": "jsonparse"<br/>    },<br/>    {<br/>      "type": "multiply"<br/>    },<br/>    {<br/>      "type": "ethuint256"<br/>    },<br/>    {<br/>      "type": "ethtx"<br/>    }<br/>  ]<br/>}</span></pre><p id="d5c5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">大多数节点都有许多类似的作业，上面示例中的作业是最常见的作业之一。该工作规范定义了如何在智能合同中提出简单的<code class="fe na nb nc nd b">httpget</code>请求。如果您想发出POST请求而不是GET请求，还有一个<code class="fe na nb nc nd b">httppost</code>适配器。该职务由以下人员定义:</p><ol class=""><li id="20a0" class="nn no it lb b lc ld lf lg li np lm nq lq nr lu ns nt nu nv bi translated"><a class="ae ky" href="https://docs.chain.link/docs/initiators#runlog" rel="noopener ugc nofollow" target="_blank">运行日志启动器</a></li><li id="b469" class="nn no it lb b lc nw lf nx li ny lm nz lq oa lu ns nt nu nv bi translated">这个特定的适配器/任务列表:httpget、jsonparse、multiply、ethuint256和ethTx适配器。</li></ol><p id="3a2c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">运行日志启动器是最常用的启动器之一。它定义了chainlink节点将监视包含该作业ID的任何日志事件的区块链。一旦发现一个事件，它将执行适配器，并将数据发送到链上。我们将很快讨论这些适配器的功能。</p><p id="1be3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">您的智能合约将不得不等待Chainlink节点返回您的数据，但是一旦它返回，您的智能合约将从该事务中提取数据。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ob"><img src="../Images/b1deee0d45acc58c44883bcecf9aa64b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*j08XohnwppmwIRd8ZyiDaA.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">图片来自<a class="ae ky" href="https://chain.link/" rel="noopener ugc nofollow" target="_blank"> chain.link </a></p></figure></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="df5d" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">这在Solidity里是什么样子的？</h1><p id="5b36" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">为了展示这在代码中是什么样子，让我们看一下获取ETH的数字价格。您可以使用这个<a class="ae ky" href="https://remix.ethereum.org/#version=soljson-v0.6.2+commit.bacdbe57.js&amp;optimize=false&amp;gist=9507bdea4570e56067a0ab0ecb351b67" rel="noopener ugc nofollow" target="_blank"> Remix链接</a>来跟进，但是这里是合同代码的一个子集。</p><pre class="kj kk kl km gt ne nd nf ng aw nh bi"><span id="bc0c" class="ni md it nd b gy nj nk l nl nm">// Creates a Chainlink request with the uint256 multiplier job<br/>  // Ideally, you'd want to pass the oracle payment, address, and jobID as <br/>  function requestEthereumPrice() <br/>    public<br/>    onlyOwner<br/>  {<br/>    // newRequest takes a JobID, a callback address, and callback function as input<br/>    Chainlink.Request memory req = buildChainlinkRequest(JOBID, address(this), this.fulfill.selector);<br/>    req.add("get", "<a class="ae ky" href="https://min-api.cryptocompare.com/data/price?fsym=ETH&amp;tsyms=USD" rel="noopener ugc nofollow" target="_blank">https://min-api.cryptocompare.com/data/price?fsym=ETH&amp;tsyms=USD</a>");<br/>    req.add("path", "USD");<br/>    req.addInt("times", 100);<br/>    sendChainlinkRequestTo(ORACLE_ADDRESS, req, ORACLE_PAYMENT);<br/>  }</span><span id="e085" class="ni md it nd b gy oc nk l nl nm">// fulfill receives a uint256 data type<br/>  function fulfill(bytes32 _requestId, uint256 _price)<br/>    public<br/>    // Use recordChainlinkFulfillment to ensure only the requesting oracle can fulfill<br/>    recordChainlinkFulfillment(_requestId)<br/>  {<br/>    currentPrice = _price;<br/>  }</span></pre><p id="89dd" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">为了开始向chainlink节点发出请求，我们调用从<code class="fe na nb nc nd b">ChainlinkClient.sol</code>导入的<code class="fe na nb nc nd b">buildChainlinkRequest</code>函数，该函数返回一个<code class="fe na nb nc nd b">Chainlink.Request</code>结构。在这个函数中，当我们开始构建它时，我们传递jobID、返回地址和实现函数。</p><p id="bdd9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们可以通过前往一个节点列表服务，如<a class="ae ky" href="https://market.link/" rel="noopener ugc nofollow" target="_blank"> market.link </a>，并搜索我们想要的，来找到一个独立的Chainlink节点的jobID。节点列表服务是独立节点发布关于如何连接到其链接节点的信息的地方。您可以使用它们来构建您的分散式神谕网络。确保你在正确的网络上(ropsten，mainnet，kovan等)。</p><p id="0099" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">为此，我们需要一个可以发出<code class="fe na nb nc nd b">httpget</code>调用并返回<code class="fe na nb nc nd b">uint256</code>的作业，所以让我们尝试在ropsten网络上搜索该作业。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi od"><img src="../Images/fe011e156c6e957fa54bfd736b58148e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*HZqo8ybpn4mwHNM1kfvj0A.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">在<a class="ae ky" href="https://market.link/" rel="noopener ugc nofollow" target="_blank">市场上找工作。链接</a></p></figure><p id="086b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们选择一份工作，并确保<code class="fe na nb nc nd b">jobspec</code>就是我们要找的。我们可以前往<code class="fe na nb nc nd b">jobspec</code>选项卡，看看启动器和适配器是什么。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi oe"><img src="../Images/ed44c6d3980491678dad1b6747c425aa.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*RES5FkN-D15-vydagEiQFA.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">图片来自<a class="ae ky" href="https://market.link/" rel="noopener ugc nofollow" target="_blank"> market.link </a></p></figure><p id="9ae8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">为了确保这个作业有正确的适配器，我们可以查看他们的任务/适配器列表。上图显示，这个作业正好有我们想要的启动器和适配器/任务。</p><p id="b1b7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">一旦我们验证了作业具有我们想要的适配器，我们就可以复制作业ID以在代码中使用。您可以看到有类似工作的其他节点，当您将合同分散时，您将需要此列表，但同样对于测试和开发，我们可以只从单个节点中提取。确保您还获取了oracle地址，因为您稍后会需要它。</p><pre class="kj kk kl km gt ne nd nf ng aw nh bi"><span id="9baa" class="ni md it nd b gy nj nk l nl nm">Chainlink.Request memory req = buildChainlinkRequest(JOBID, address(this), this.fulfill.selector);</span></pre><p id="58f2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">然后，我们将JOBID放在我们的<code class="fe na nb nc nd b">buildChainlinkReqeust</code>的第一个参数中。第二个参数是契约返回数据的地址，也称为<code class="fe na nb nc nd b">callbackaddress</code>。最后一个参数是处理收集到的数据的函数，即<code class="fe na nb nc nd b">callbackFunctionSignature</code>。我们想将数据返回到这个契约，所以我们放入<code class="fe na nb nc nd b">address(this)</code>，我们处理数据的函数将是<code class="fe na nb nc nd b">fulfill</code>。我们在这个函数下面定义了实现函数。</p><pre class="kj kk kl km gt ne nd nf ng aw nh bi"><span id="9183" class="ni md it nd b gy nj nk l nl nm">function fulfill(bytes32 _requestId, uint256 _price)<br/>    public<br/>    // Use recordChainlinkFulfillment to ensure only the requesting oracle can fulfill<br/>    recordChainlinkFulfillment(_requestId)<br/>  {<br/>    currentPrice = _price;<br/>  }</span></pre><p id="7797" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe na nb nc nd b">uint256 _price</code>参数是Chainlink节点输入从http get请求中收集的价格的地方。在上面的例子中，我们只是将节点的返回值设置为我们的<code class="fe na nb nc nd b">currentPrice </code>变量。</p><p id="6728" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">回到<code class="fe na nb nc nd b">requestEthereumPrice</code>函数，我们可以向我们的适配器/任务添加参数。让我们回顾一下每个适配器的功能:</p><h2 id="f5dd" class="ni md it bd me of og dn mi oh oi dp mm li oj ok mo lm ol om mq lq on oo ms op bi translated">httpget</h2><p id="35dc" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">Chainlink节点将发出HTTP GET请求；通常，这是一个简单的API调用。</p><p id="8aa0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们希望在传递给<code class="fe na nb nc nd b">req</code>变量的参数中发出的HTTP GET请求。</p><pre class="kj kk kl km gt ne nd nf ng aw nh bi"><span id="a725" class="ni md it nd b gy nj nk l nl nm">req.add("get", "<a class="ae ky" href="https://min-api.cryptocompare.com/data/price?fsym=ETH&amp;tsyms=USD" rel="noopener ugc nofollow" target="_blank">https://min-api.cryptocompare.com/data/price?fsym=ETH&amp;tsyms=USD</a>");</span></pre><p id="56f8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在撰写本文时，这个HTTP GET请求的返回值是:</p><pre class="kj kk kl km gt ne nd nf ng aw nh bi"><span id="9d78" class="ni md it nd b gy nj nk l nl nm">{"USD":391.41}</span></pre><h2 id="8412" class="ni md it bd me of og dn mi oh oi dp mm li oj ok mo lm ol om mq lq on oo ms op bi translated">jsonparse</h2><p id="8e0b" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">一旦节点发出HTTP GET请求，它将遍历json并只找到我们想要的值。存储HTTP GET请求的全部返回将会非常昂贵，因为你在以太坊链上存储的越多，你需要支付的ETH气就越多。所以，我们想尽量少退货。</p><pre class="kj kk kl km gt ne nd nf ng aw nh bi"><span id="8e16" class="ni md it nd b gy nj nk l nl nm">req.add("path", "USD");</span></pre><p id="5767" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这将把HTTP GET请求的返回压缩为值<br/> <code class="fe na nb nc nd b">391.41</code>。它向下遍历<code class="fe na nb nc nd b">{“USD”:391.41}</code>返回值的json。对于更长的json返回，您也可以添加列表索引。例如，如果你有一个像这样的对象:</p><pre class="kj kk kl km gt ne nd nf ng aw nh bi"><span id="8be3" class="ni md it nd b gy nj nk l nl nm">{"USD": [ "price": {"ETH": 391.41}]}</span></pre><p id="9b97" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们可以通过以下方式实现这一价值:</p><pre class="kj kk kl km gt ne nd nf ng aw nh bi"><span id="0c30" class="ni md it nd b gy nj nk l nl nm">req.add("path", "USD.0.ETH");</span></pre><h2 id="c2b6" class="ni md it bd me of og dn mi oh oi dp mm li oj ok mo lm ol om mq lq on oo ms op bi translated">乘/倍</h2><p id="ea00" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">一旦我们得到了<code class="fe na nb nc nd b">391.41</code>值，我们必须把它变成一个整数。小数在solidity中不起作用，我们需要<a class="ae ky" href="https://ethereum.stackexchange.com/questions/2987/how-can-i-represent-decimal-values-in-solidity/2990#2990" rel="noopener ugc nofollow" target="_blank">用定点数学来表示小数。</a></p><pre class="kj kk kl km gt ne nd nf ng aw nh bi"><span id="392c" class="ni md it nd b gy nj nk l nl nm">req.addInt("times", 100);</span></pre><p id="1c65" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这将再次调整我们的结果为<code class="fe na nb nc nd b">39141</code>(因为我们通过乘以100将小数位移动了两次)。</p><h2 id="a210" class="ni md it bd me of og dn mi oh oi dp mm li oj ok mo lm ol om mq lq on oo ms op bi translated">以太网256</h2><p id="ca95" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">您会注意到，在我们上面的代码中，我们不向这个适配器传递任何参数；那是因为我们不需要。这个适配器只是将我们的答案<code class="fe na nb nc nd b">39141</code>转换成了可靠的可理解的格式。</p><h2 id="a97f" class="ni md it bd me of og dn mi oh oi dp mm li oj ok mo lm ol om mq lq on oo ms op bi translated">ethtx</h2><p id="07d3" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">这个也不需要任何参数。这是实际将数据发送回链上的适配器。</p><p id="124a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在我们使用<code class="fe na nb nc nd b">sendChainlinkRequestTo</code>方法，使用从market.link获得的oracle地址、请求本身和oracle_payment。</p><pre class="kj kk kl km gt ne nd nf ng aw nh bi"><span id="5c48" class="ni md it nd b gy nj nk l nl nm">sendChainlinkRequestTo(ORACLE_ADDRESS, req, ORACLE_PAYMENT);</span></pre><p id="4b92" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们从<a class="ae ky" href="https://market.link/" rel="noopener ugc nofollow" target="_blank"> market.link </a>中获得<code class="fe na nb nc nd b">ORACLE_ADDRESS</code>和<code class="fe na nb nc nd b">ORACLE_PAYMENT</code>。甲骨文付款是多少环节甲骨文天然气，我们要发送甲骨文，每个工作有自己的最低成本发送。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="2436" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">发送它</h1><p id="981c" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">现在，让我们再运行一次！让我们部署合同，用link提供资金，然后请求ETH的价格。如果你不知道如何做，你可以浏览<a class="ae ky" href="https://docs.chain.link/docs/example-walkthrough" rel="noopener ugc nofollow" target="_blank">示例演练</a>。或者更详细的YouTube视频:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oq or l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">介绍可靠性和再混合，并部署您的第一个智能合同</p></figure><p id="1ed2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">Chainlink节点将通过从区块链中读取请求来获取该请求。同样，它可以从区块链读取它，因为它正在使用运行日志发起程序。一旦它选择了作业，它就通过适配器运行，并将作业发送回链上，供您的智能契约使用！</p><p id="dfc0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">Oracles也可以在它们的作业定义中定义参数(称为<code class="fe na nb nc nd b">jobspec</code>)，您可以直接调用作业，而根本不需要输入任何参数。</p><p id="ee5e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这是一个关于如何使用Chainlink节点的非常深入的研究，但是有了这个，你现在有了很多基本的工具来在区块链生态系统中构建一些令人惊叹的项目。</p><p id="c425" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如你所见，使用chainlink在以太坊和任何区块链中获取<a class="ae ky" href="https://dev.to/patrickalphac/off-chain-data-in-ethereum-how-to-access-4395" rel="noopener ugc nofollow" target="_blank">链外数据是简单、安全和可靠的。让我们看看一些建筑吧！</a></p></div></div>    
</body>
</html>