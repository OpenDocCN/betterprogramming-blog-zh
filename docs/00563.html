<html>
<head>
<title>Beginning Python Programming — Part 12</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Python编程入门—第12部分</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/beginning-python-programming-part-12-5450ae804936?source=collection_archive---------8-----------------------#2019-06-10">https://betterprogramming.pub/beginning-python-programming-part-12-5450ae804936?source=collection_archive---------8-----------------------#2019-06-10</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="10ac" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">迭代器和生成器介绍</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/8120974e7abe2a71f6452434add85f72.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*PAb7ciq1C0Xcq916"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">照片由<a class="ae ky" href="https://unsplash.com/@timothycdykes?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">蒂莫西·戴克斯</a>在<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</p></figure><p id="0138" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在上一篇文章中，我们讨论了包和虚拟环境。</p><div class="lv lw gp gr lx ly"><a href="https://medium.com/better-programming/beginning-python-programming-part-11-1dc915b4f0fd" rel="noopener follow" target="_blank"><div class="lz ab fo"><div class="ma ab mb cl cj mc"><h2 class="bd iu gy z fp md fr fs me fu fw is bi translated">Python编程入门—第11部分</h2><div class="mf l"><h3 class="bd b gy z fp md fr fs me fu fw dk translated">使用模块和虚拟环境</h3></div><div class="mg l"><p class="bd b dl z fp md fr fs me fu fw dk translated">medium.com</p></div></div><div class="mh l"><div class="mi l mj mk ml mh mm ks ly"/></div></div></a></div><p id="50b9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">今天，我们将跳回来介绍一些我们还没有介绍的内置类方法。</p><p id="f64e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在开始之前，我们应该了解一些基本的算法。这些都是非常基本的，但为我们开始提供了一个很好的基线。</p><p id="ea7a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们从我们之前讨论过的<em class="mn"> while循环</em>开始:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mo mp l"/></div></figure><p id="658e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我承认有更好的方法可以做到这一点，但是这为我们提供了一个简单的例子来为本文的其余部分做准备。</p><p id="94b3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><em class="mn">带有while循环的正向循环</em>对我们来说并不陌生，但是，我们还没有介绍过<em class="mn">反向循环</em>。虽然这对你们中的一些人来说可能是微不足道的，但我不会假设我的所有读者都已经理解了遍历列表是如何工作的。</p><p id="0e4e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在一个反向循环中，我们首先需要获得列表的长度，并将我们的<code class="fe mq mr ms mt b">index</code>变量设置为length - 1。我们这样做是因为列表是从0开始的，这意味着最后一个可访问的索引将比列表中的项目总数少1。</p><p id="3868" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">与我们在正向循环中比较<code class="fe mq mr ms mt b">index</code>的值和列表的长度不同，我们需要确保<code class="fe mq mr ms mt b">index</code>的值在循环中不小于0。</p><p id="1bf1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们可以执行列表中需要的工作，然后从<code class="fe mq mr ms mt b">index</code>中减去1，得到列表中的前一个条目。一旦<code class="fe mq mr ms mt b">index</code>小于0，while循环就退出。</p><p id="b697" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">最后，我创建了一个返回给定列表中最后一项的函数。不管我们给它什么列表，它总是返回最后一项。我添加这一点是因为我们需要熟悉这个概念才能继续。</p></div><div class="ab cl mu mv hx mw" role="separator"><span class="mx bw bk my mz na"/><span class="mx bw bk my mz na"/><span class="mx bw bk my mz"/></div><div class="im in io ip iq"><h1 id="737c" class="nb nc it bd nd ne nf ng nh ni nj nk nl jz nm ka nn kc no kd np kf nq kg nr ns bi translated">迭代器</h1><p id="5b36" class="pw-post-body-paragraph kz la it lb b lc nt ju le lf nu jx lh li nv lk ll lm nw lo lp lq nx ls lt lu im bi translated">有时我们需要创建包含一系列对象的类，我们可以循环遍历这些对象，同时对循环遍历的数据执行一些持续的操作。这些对象的范围可以从一系列数字到一系列类。迭代器是提供这种功能的类。</p><p id="9f7b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">您需要熟悉两个类方法:</p><ul class=""><li id="f8db" class="ny nz it lb b lc ld lf lg li oa lm ob lq oc lu od oe of og bi translated"><code class="fe mq mr ms mt b">__iter__(self)</code>—返回一个迭代器对象</li><li id="2f59" class="ny nz it lb b lc oh lf oi li oj lm ok lq ol lu od oe of og bi translated"><code class="fe mq mr ms mt b">__next__(self)</code> —用于返回序列中的下一项</li></ul><p id="2604" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">理解<code class="fe mq mr ms mt b">__iter__</code>和<code class="fe mq mr ms mt b">__init__</code>的区别很重要。</p><p id="7f31" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe mq mr ms mt b">__init__</code>用于在向类提供数据的同时创建类的实例；这是我们将数据赋给迭代器的地方。</p><p id="e3c0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">当你想用一个序列(list，ordered_dict等)创建一个类的实例时，使用<code class="fe mq mr ms mt b">__iter__</code>。)来播种迭代器将循环遍历的数据。</p><p id="2bf9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe mq mr ms mt b">__iter__</code>用一个<code class="fe mq mr ms mt b">__next__</code>方法返回一个对象，如果你在类里面有一个自定义的<code class="fe mq mr ms mt b">__next__</code>方法，你只需要从<code class="fe mq mr ms mt b">__iter__</code>方法返回<code class="fe mq mr ms mt b">return self</code>。</p><p id="b0f5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">举例来说:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mo mp l"/></div></figure><p id="4755" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这里我们有一个带有<code class="fe mq mr ms mt b">__init__</code>、<code class="fe mq mr ms mt b">__iter__</code>和<code class="fe mq mr ms mt b">__next__</code>方法的<code class="fe mq mr ms mt b">Doubled</code>类。</p><p id="203e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe mq mr ms mt b">__init__</code>在初始化类时要求参数<code class="fe mq mr ms mt b">data</code>。在我们的例子中，我们设计了这个类来对一个数字列表进行双精度处理。为此，我们需要确保向类传递一个整数或浮点值的列表。</p><p id="828b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">然后<code class="fe mq mr ms mt b">__init__</code>方法获取数据的长度，这样我们就知道何时需要停止遍历传入的列表。它将数据保存到名为<code class="fe mq mr ms mt b">data</code>的类属性中，并将当前索引位置设置为0。我们设置了当前索引，所以当我们创建一个新的迭代器时，我们总是从0开始。</p><p id="f77b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">因为我们在这个类中定义了自己的<code class="fe mq mr ms mt b">__next__</code>方法，所以我们只需要在<code class="fe mq mr ms mt b">__iter__</code>方法内部定义<code class="fe mq mr ms mt b">return self</code>。</p><p id="d4d2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe mq mr ms mt b">__next__</code>包含我们用来返回我们传递的列表中下一个值的逻辑。如果我们要传入一个字典，它将返回字典中的值，尽管我们需要指定如何返回下一个键的值。</p><p id="4471" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在我们的<code class="fe mq mr ms mt b">__next__</code>方法中，我们首先检查当前的索引位置不等于数据的长度。如果是，我们需要抛出<code class="fe mq mr ms mt b">StopIteration</code>异常。这与<code class="fe mq mr ms mt b">IndexError</code>不同，当我们到达列表的末尾时，我们会收到这个迭代器，因为我们可能对不同的数据类型使用这个迭代器。</p><p id="3c9f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe mq mr ms mt b">StopIteration</code>具体到我们收到了什么错误，如果我们需要再次迭代序列，那么我们要么需要创建另一个迭代器对象，要么想一个不同的方法来迭代我们的数据。</p><p id="53d7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">接下来，我们执行这个迭代器的逻辑。因为我们将列表中的每一项都加倍，所以我们将当前索引的值乘以2保存到一个结果变量中。我们这样做是因为我们需要为下一次运行准备索引，这将在下一行中进行。最后，如果一切顺利，我们返回结果。</p><p id="cf78" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">迭代器的存在是为了使我们的工作更容易，但也是为了确保我们逻辑的一致性。然而，它们不是循环代码的唯一方式。</p></div><div class="ab cl mu mv hx mw" role="separator"><span class="mx bw bk my mz na"/><span class="mx bw bk my mz na"/><span class="mx bw bk my mz"/></div><div class="im in io ip iq"><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi om"><img src="../Images/65e27396376794c14c0f470f4f6bcfb2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*bShb4zTfdA6Iz8z5"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">Jason Blackeye 在<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</p></figure><h1 id="954a" class="nb nc it bd nd ne on ng nh ni oo nk nl jz op ka nn kc oq kd np kf or kg nr ns bi translated">发电机</h1><p id="cc85" class="pw-post-body-paragraph kz la it lb b lc nt ju le lf nu jx lh li nv lk ll lm nw lo lp lq nx ls lt lu im bi translated">生成器类似于迭代器，除了它们是像迭代器一样工作的函数。生成器的巧妙之处在于它允许你的函数暂停，直到被再次调用。从某种意义上说，他们有自己的<code class="fe mq mr ms mt b">__next__</code>和<code class="fe mq mr ms mt b">__iter__</code>方法。与函数不同，它们使用关键字<code class="fe mq mr ms mt b">yield</code>返回数据。让我们看一个简单的例子:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mo mp l"/></div></figure><p id="96d9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">出于错误处理的考虑，我在这里添加了一个try/except。</p><p id="f42c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">首先，我们创建一个名为<code class="fe mq mr ms mt b">increment</code>的函数，它接受一个参数:<code class="fe mq mr ms mt b">number</code>。在函数体中，我们有两条<code class="fe mq mr ms mt b">yield</code>语句；第一个返回传入的数字并加1，第二个返回该数字加2。</p><p id="3434" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">然后我们需要将增量函数存储在变量<code class="fe mq mr ms mt b">incrementor</code>中，为上面的增量函数提供初始值。这些都将存储在变量中，并被视为类对象。</p><p id="ee72" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">从这里我们可以像使用迭代器一样使用它，通过将<code class="fe mq mr ms mt b">incrementor</code>传递给<code class="fe mq mr ms mt b">next()</code>函数，我们按顺序接收每个<code class="fe mq mr ms mt b">yield</code>语句。这意味着我们会看到<code class="fe mq mr ms mt b">5</code>和<code class="fe mq mr ms mt b">6</code>被打印到控制台上。如果我们第三次调用<code class="fe mq mr ms mt b">next(incrementor)</code>，如上所述，我们会收到一个<code class="fe mq mr ms mt b">StopIteration</code>异常。</p><p id="4992" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让生成器如此有趣的是我们对它们使用无限循环。由于<code class="fe mq mr ms mt b">yield</code>暂停了函数的执行，我们一次只能收到一个结果。这意味着下面的代码是有效的，不会引起问题。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mo mp l"/></div></figure><p id="64f4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这里我们有一个新的incrementor函数，它接受一个数字。<code class="fe mq mr ms mt b">=0</code>表示如果没有提供数字，则使用0作为默认值。然后我们创建一个局部变量<code class="fe mq mr ms mt b">n</code>并给它赋值<code class="fe mq mr ms mt b">number</code>。</p><p id="49f1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">接下来，我们有一个无限循环，虽然这样做通常不太好，但在这里是可以接受的，因为每次调用<code class="fe mq mr ms mt b">yield</code>都会暂停执行。在函数的末尾，我们有了<code class="fe mq mr ms mt b">n = n + 1</code>，它增加了我们的局部变量<code class="fe mq mr ms mt b">n</code>。</p><p id="3810" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">由于函数在传递<code class="fe mq mr ms mt b">yield</code>时暂停，所以下次我们将incrementor传递给<code class="fe mq mr ms mt b">next()</code>函数时，它会在包含<code class="fe mq mr ms mt b">n = n + 1</code>的行上恢复。</p><p id="90d6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">生成器也可以用接近列表理解的格式编写。唯一的区别是我们在表达式两边使用圆括号，而不是方括号。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mo mp l"/></div></figure><p id="b4d0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">从这里我们可以使用一个简单的for循环访问<code class="fe mq mr ms mt b">generator_object</code>中的每一项，就像我们访问<code class="fe mq mr ms mt b">list_comp_object</code>中的结果列表一样，或者我们可以使用<code class="fe mq mr ms mt b">next(generator_object)</code>获得下一个值。</p><p id="da58" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">迭代器和生成器的一个显著区别是迭代器预先计算所有的值并把它们存储在内存中，而生成器只把每次运行所需的值存储在内存中。</p><p id="4bb3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">生成器的运行速度比列表理解要慢，所以除非你面临内存不足的情况，否则你应该使用列表理解。嘿，如果需要的话很容易重构。</p><p id="18a3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">生成器可用于递归任务，如搜索硬盘上的文件或在web抓取工具中搜索网页。</p></div><div class="ab cl mu mv hx mw" role="separator"><span class="mx bw bk my mz na"/><span class="mx bw bk my mz na"/><span class="mx bw bk my mz"/></div><div class="im in io ip iq"><h1 id="92cf" class="nb nc it bd nd ne nf ng nh ni nj nk nl jz nm ka nn kc no kd np kf nq kg nr ns bi translated">摘要</h1><p id="e39a" class="pw-post-body-paragraph kz la it lb b lc nt ju le lf nu jx lh li nv lk ll lm nw lo lp lq nx ls lt lu im bi translated">迭代器和生成器更多的是一个中间话题，但是一旦你使用它们几次，你就开始寻找在任何地方使用它们的方法。了解迭代器和生成器之间的区别对于应用程序的性能至关重要；在“仅仅因为”而包含它们之前，确保你知道它们的区别。</p></div><div class="ab cl mu mv hx mw" role="separator"><span class="mx bw bk my mz na"/><span class="mx bw bk my mz na"/><span class="mx bw bk my mz"/></div><div class="im in io ip iq"><h1 id="174d" class="nb nc it bd nd ne nf ng nh ni nj nk nl jz nm ka nn kc no kd np kf nq kg nr ns bi translated">下一步是什么？</h1><p id="8a74" class="pw-post-body-paragraph kz la it lb b lc nt ju le lf nu jx lh li nv lk ll lm nw lo lp lq nx ls lt lu im bi translated">接下来是Async，这个主题非常高级，提供了许多同步代码的选项。不仅可以配置计时，还可以同时运行代码。坚持住，直到那时，继续练习！</p></div></div>    
</body>
</html>