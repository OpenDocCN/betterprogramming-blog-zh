<html>
<head>
<title>A Better, More Developer-Friendly Way of Creating Dockerfile Files</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">一种更好、对开发人员更友好的创建Dockerfile文件的方式</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/a-better-developer-friendly-way-of-creating-dockerfile-files-e4d81b0ed819?source=collection_archive---------12-----------------------#2020-02-11">https://betterprogramming.pub/a-better-developer-friendly-way-of-creating-dockerfile-files-e4d81b0ed819?source=collection_archive---------12-----------------------#2020-02-11</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="6958" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">在这个容器世界中，许多图像都是通过Dockerfile文件定义的。有些简单，有些复杂</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/b235692fd75e6dbd6d25913f46729a7e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*xrgQbtjSfz-J6ek50yQmMg.jpeg"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">在<a class="ae ky" href="https://unsplash.com/s/photos/programming?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上由<a class="ae ky" href="https://unsplash.com/@taskinhoo?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Taskin Ashiq </a>拍摄的照片</p></figure><h1 id="d491" class="kz la it bd lb lc ld le lf lg lh li lj jz lk ka ll kc lm kd ln kf lo kg lp lq bi translated">摘要</h1><h2 id="7149" class="lr la it bd lb ls lt dn lf lu lv dp lj lw lx ly ll lz ma mb ln mc md me lp mf bi translated">问题</h2><p id="2c10" class="pw-post-body-paragraph mg mh it mi b mj mk ju ml mm mn jx mo lw mp mq mr lz ms mt mu mc mv mw mx my im bi translated">复杂的docker文件通常是那些包含大而长的命令的文件。<br/>当你看到这些，你的大脑开始旋转。这样我们就有了第一个问题:长docker文件的可理解性。</p><p id="a928" class="pw-post-body-paragraph mg mh it mi b mj mz ju ml mm na jx mo lw nb mq mr lz nc mt mu mc nd mw mx my im bi translated"><strong class="mi iu">示例链接A. </strong>(您可能想让它保持打开，我会引用它):</p><p id="4be1" class="pw-post-body-paragraph mg mh it mi b mj mz ju ml mm na jx mo lw nb mq mr lz nc mt mu mc nd mw mx my im bi translated"><a class="ae ky" href="https://raw.githubusercontent.com/nginxinc/docker-nginx/5971de30c487356d5d2a2e1a79e02b2612f9a72f/mainline/buster/Dockerfile" rel="noopener ugc nofollow" target="_blank">https://raw . githubusercontent . com/nginxinc/docker-nginx/5971 de 30 c 487356 D5 D2 a2 E1 a 79 e 02 b 2612 f 9 a 72 f/mainline/buster/docker file</a></p><p id="d6b4" class="pw-post-body-paragraph mg mh it mi b mj mz ju ml mm na jx mo lw nb mq mr lz nc mt mu mc nd mw mx my im bi translated">另一个问题:为了图像大小，最终图像通常应该有尽可能少的层，而在开发期间，您希望有更多的层，以便在您修复一些脚本时使用Docker的缓存功能。相反的方向…</p><p id="ccfd" class="pw-post-body-paragraph mg mh it mi b mj mz ju ml mm na jx mo lw nb mq mr lz nc mt mu mc nd mw mx my im bi translated">面临的另一个问题是:可重用性。</p><h2 id="17fa" class="lr la it bd lb ls lt dn lf lu lv dp lj lw lx ly ll lz ma mb ln mc md me lp mf bi translated">让我们努力做得更好</h2><p id="f1f4" class="pw-post-body-paragraph mg mh it mi b mj mk ju ml mm mn jx mo lw mp mq mr lz ms mt mu mc mv mw mx my im bi translated">在这篇文章中，我将探讨一种非常简单的方法来改善上述问题。</p><p id="22e4" class="pw-post-body-paragraph mg mh it mi b mj mz ju ml mm na jx mo lw nb mq mr lz nc mt mu mc nd mw mx my im bi translated">您将获得一种开发友好的方式，在各种docker文件中使用可重用的代码片段来创建docker文件。它可以生成更高质量的docker文件，并在开发过程中使用图层缓存时自动生成小的最终图像。</p><p id="3d16" class="pw-post-body-paragraph mg mh it mi b mj mz ju ml mm na jx mo lw nb mq mr lz nc mt mu mc nd mw mx my im bi translated">我认为它可以进一步改进，带来额外的好处。</p><p id="1da8" class="pw-post-body-paragraph mg mh it mi b mj mz ju ml mm na jx mo lw nb mq mr lz nc mt mu mc nd mw mx my im bi translated">注意:这不是关于容器、Docker或Docker文件的介绍性课程。这方面还有很多其他的好资源。</p><p id="049e" class="pw-post-body-paragraph mg mh it mi b mj mz ju ml mm na jx mo lw nb mq mr lz nc mt mu mc nd mw mx my im bi translated">代码可以在以下位置找到:</p><ul class=""><li id="659b" class="ne nf it mi b mj mz mm na lw ng lz nh mc ni my nj nk nl nm bi translated"><a class="ae ky" href="https://github.com/cr1st1p/dockerfile-lib" rel="noopener ugc nofollow" target="_blank">https://github.com/cr1st1p/dockerfile-li</a>b—库和指令</li><li id="4751" class="ne nf it mi b mj nn mm no lw np lz nq mc nr my nj nk nl nm bi translated"><a class="ae ky" href="https://github.com/cr1st1p/docker-simplestreams-server" rel="noopener ugc nofollow" target="_blank">https://github.com/cr1st1p/docker-simplestreams-server</a>—一个用例</li><li id="dcbc" class="ne nf it mi b mj nn mm no lw np lz nq mc nr my nj nk nl nm bi translated"><a class="ae ky" href="https://github.com/cr1st1p/docker-shinobi-cctv" rel="noopener ugc nofollow" target="_blank">https://github.com/cr1st1p/docker-shinobi-cctv</a>—另一个用例</li></ul></div><div class="ab cl ns nt hx nu" role="separator"><span class="nv bw bk nw nx ny"/><span class="nv bw bk nw nx ny"/><span class="nv bw bk nw nx"/></div><div class="im in io ip iq"><h1 id="b9a3" class="kz la it bd lb lc nz le lf lg oa li lj jz ob ka ll kc oc kd ln kf od kg lp lq bi translated">让我想想…</h1><p id="eea0" class="pw-post-body-paragraph mg mh it mi b mj mk ju ml mm mn jx mo lw mp mq mr lz ms mt mu mc mv mw mx my im bi translated">让我们开始我们的旅程。我们在这里:我们必须为我们的超级杀手……项目……呃..集装箱。</p><h2 id="b5d8" class="lr la it bd lb ls lt dn lf lu lv dp lj lw lx ly ll lz ma mb ln mc md me lp mf bi translated">认知负荷</h2><p id="ca5e" class="pw-post-body-paragraph mg mh it mi b mj mk ju ml mm mn jx mo lw mp mq mr lz ms mt mu mc mv mw mx my im bi translated">根据需要，Dockerfile文件可以是:</p><ul class=""><li id="ab4d" class="ne nf it mi b mj mz mm na lw ng lz nh mc ni my nj nk nl nm bi translated">非常简单，或多或少由几个运行命令、几个复制命令、一个入口点组成，瞧！做完了，该吃冰淇淋或喝咖啡了！</li><li id="37a2" class="ne nf it mi b mj nn mm no lw np lz nq mc nr my nj nk nl nm bi translated">庞大而复杂，运行命令要做很多事情——更新包存储库数据、下载GPG密钥、引入包、设置配置文件等等。再看链接一个<strong class="mi iu">，上面的</strong>。冰淇淋可以等，把咖啡端进来。</li></ul><p id="711b" class="pw-post-body-paragraph mg mh it mi b mj mz ju ml mm na jx mo lw nb mq mr lz nc mt mu mc nd mw mx my im bi translated">所以，我们要写一个长的。之后，我们希望能够不大惊小怪地捡起来，对吗？我们不想陷入“只写一次，从不阅读”的境地(谢谢，我已经有多年的Perl编程经验了。)</p><p id="d504" class="pw-post-body-paragraph mg mh it mi b mj mz ju ml mm na jx mo lw nb mq mr lz nc mt mu mc nd mw mx my im bi translated">当然，我们总是会遇到大型代码库，但是我们总是希望容易理解它们是关于什么的。那些大的运行Dockerfile命令并没有什么帮助，对吗？</p><p id="9bef" class="pw-post-body-paragraph mg mh it mi b mj mz ju ml mm na jx mo lw nb mq mr lz nc mt mu mc nd mw mx my im bi translated">这里，再开一个例子，<strong class="mi iu">链接</strong> <strong class="mi iu"> B </strong>:</p><p id="b08a" class="pw-post-body-paragraph mg mh it mi b mj mz ju ml mm na jx mo lw nb mq mr lz nc mt mu mc nd mw mx my im bi translated"><a class="ae ky" href="https://github.com/docker-library/cassandra/blob/master/Dockerfile.template" rel="noopener ugc nofollow" target="_blank">https://github . com/docker-library/Cassandra/blob/master/docker file . template</a>。</p><p id="d6fb" class="pw-post-body-paragraph mg mh it mi b mj mz ju ml mm na jx mo lw nb mq mr lz nc mt mu mc nd mw mx my im bi translated">最近不小心碰到了这个。(幸运的是，至少他们有一些评论——谢谢！)</p><h2 id="2065" class="lr la it bd lb ls lt dn lf lu lv dp lj lw lx ly ll lz ma mb ln mc md me lp mf bi translated">优化—层数</h2><p id="6528" class="pw-post-body-paragraph mg mh it mi b mj mk ju ml mm mn jx mo lw mp mq mr lz ms mt mu mc mv mw mx my im bi translated">让我们引入另一个方面:<em class="oe">优化。</em>你现在可能知道图像越小越好。您知道每个Dockerfile命令(包括RUN)都会创建一个新层。</p><p id="4bfd" class="pw-post-body-paragraph mg mh it mi b mj mz ju ml mm na jx mo lw nb mq mr lz nc mt mu mc nd mw mx my im bi translated">当您存储或传输图像时，所有层都被存储/传输——这意味着如果在一个运行命令中您安装了一些最终图像中不需要的辅助工具，然后在另一个运行命令中您删除了它，这实际上并不重要。您的图像中仍然会有这些数据，只是不在最终图层中。</p><p id="991b" class="pw-post-body-paragraph mg mh it mi b mj mz ju ml mm na jx mo lw nb mq mr lz nc mt mu mc nd mw mx my im bi translated">提示:因此，从安全角度来说，您不应该在其中一个层中使用秘密数据，然后删除它，因为该信息实际上仍然存在！</p><p id="439e" class="pw-post-body-paragraph mg mh it mi b mj mz ju ml mm na jx mo lw nb mq mr lz nc mt mu mc nd mw mx my im bi translated">注意:层本身不一定是坏的(有待进一步讨论)，但是当它们也包含数据时，就有问题了。</p><p id="4ff1" class="pw-post-body-paragraph mg mh it mi b mj mz ju ml mm na jx mo lw nb mq mr lz nc mt mu mc nd mw mx my im bi translated">好了，我们知道了——尽可能少的层数！那你是怎么做到的呢？</p><p id="e96e" class="pw-post-body-paragraph mg mh it mi b mj mz ju ml mm na jx mo lw nb mq mr lz nc mt mu mc nd mw mx my im bi translated">你把所有或者几乎所有的运行命令组合在一个层或者更少的层中。你看到了那个大文本，所有的行都以<code class="fe of og oh oi b">&amp;&amp;</code>开始，以<code class="fe of og oh oi b">\</code>结束，对吗？没有吗？你没有打开<strong class="mi iu">链接</strong> <strong class="mi iu">一个</strong>？</p><p id="0215" class="pw-post-body-paragraph mg mh it mi b mj mz ju ml mm na jx mo lw nb mq mr lz nc mt mu mc nd mw mx my im bi translated">下面是一个基于Debian/Ubuntu映像起点的更简单的虚构示例:</p><pre class="kj kk kl km gt oj oi ok ol aw om bi"><span id="24f4" class="lr la it oi b gy on oo l op oq">RUN \<br/>    apt-get update \<br/>    &amp;&amp; DEBIAN_FRONTEND=noninteractive apt-get install apt-transport-https ca-certificates \<br/>    &amp;&amp; apt-key adv --keyserver SERVER --recv-keys KEY_ID \<br/>    &amp;&amp; DEBIAN_FRONTEND=noninteractive apt-get install some_packages \<br/>    &amp;&amp; sed -e s/something/otherthing/ \<br/>    &amp;&amp; rm somefile \<br/>    &amp;&amp; mkdir someDir \<br/>    &amp;&amp; run_a_script with_some_parameters \<br/>    &amp;&amp; repeat_above a_few_times</span></pre><p id="689e" class="pw-post-body-paragraph mg mh it mi b mj mz ju ml mm na jx mo lw nb mq mr lz nc mt mu mc nd mw mx my im bi translated">应该比那个容易读。如果没有注释，就不容易看到各个部分的开始和结束，以及每个部分在做什么。</p><p id="b14c" class="pw-post-body-paragraph mg mh it mi b mj mz ju ml mm na jx mo lw nb mq mr lz nc mt mu mc nd mw mx my im bi translated">Docker确实提供了一个替代方案，解决了由于使用多层而可能在最终图像中出现各种垃圾的问题:<a class="ae ky" href="https://docs.docker.com/develop/develop-images/multistage-build/" rel="noopener ugc nofollow" target="_blank">多阶段构建</a>。如果您密切关注它的作用，那么它似乎主要在构建阶段的结果只包含一到三个目录时有用。也就是说，您可以轻松地列举它们，以便将它们从多层建筑docker图像复制到最终图像中。</p><p id="12f0" class="pw-post-body-paragraph mg mh it mi b mj mz ju ml mm na jx mo lw nb mq mr lz nc mt mu mc nd mw mx my im bi translated">如果你在那种情况下，对你有好处，你消除了最终图像大小的问题，也可能降低了认知负荷。其他问题仍然存在，所以请继续阅读。</p><p id="978e" class="pw-post-body-paragraph mg mh it mi b mj mz ju ml mm na jx mo lw nb mq mr lz nc mt mu mc nd mw mx my im bi translated">Docker也有一个<code class="fe of og oh oi b"><a class="ae ky" href="https://docs.docker.com/engine/reference/commandline/build/#squash-an-images-layers---squash-experimental" rel="noopener ugc nofollow" target="_blank">--squash</a></code>命令行参数来将所有层压缩成一个层，但这是一个实验性的特性，你必须在服务器上手动启用。嗯。</p><p id="ddfc" class="pw-post-body-paragraph mg mh it mi b mj mz ju ml mm na jx mo lw nb mq mr lz nc mt mu mc nd mw mx my im bi translated">此外，如果你真的想有几层而不是一层，我想命令行参数不会有用。</p><p id="4704" class="pw-post-body-paragraph mg mh it mi b mj mz ju ml mm na jx mo lw nb mq mr lz nc mt mu mc nd mw mx my im bi translated">和之前一样的评论——这仅仅解决了最终图像尺寸的问题，而不是全部。</p><h2 id="c675" class="lr la it bd lb ls lt dn lf lu lv dp lj lw lx ly ll lz ma mb ln mc md me lp mf bi translated">开发期间的Dockerfile文件与最终版本</h2><p id="493a" class="pw-post-body-paragraph mg mh it mi b mj mk ju ml mm mn jx mo lw mp mq mr lz ms mt mu mc mv mw mx my im bi translated">假设在你的Dockerfile开发过程中，你犯了一些错误(我们都犯了，对吧？).您将会多次运行<code class="fe of og oh oi b">docker build</code>流程。Docker很好地缓存了每一层，并在后续的构建中尽可能重用这些层。重建时拥有的资源越多，重用的机会就越大。</p><p id="ad81" class="pw-post-body-paragraph mg mh it mi b mj mz ju ml mm na jx mo lw nb mq mr lz nc mt mu mc nd mw mx my im bi translated">“哦，”你说，“缓存很好！”嗯，是的，但是根据前面的部分，这是我们寻求一个尽可能少的层的更小的图像的相反方向。</p><p id="7840" class="pw-post-body-paragraph mg mh it mi b mj mz ju ml mm na jx mo lw nb mq mr lz nc mt mu mc nd mw mx my im bi translated">简而言之，看起来在开发过程中您可能需要许多RUN命令，但是对于最终的变体，越少越好。嗯。</p><p id="6e9d" class="pw-post-body-paragraph mg mh it mi b mj mz ju ml mm na jx mo lw nb mq mr lz nc mt mu mc nd mw mx my im bi translated">一种方法是，当我们开发的时候，将这个庞大的命令列表分割成多个不太大的RUN命令，在编码结束的时候，将它们重新组合成一个列表。后来，当改变/修复某个东西时，重复这个过程。</p><p id="30d9" class="pw-post-body-paragraph mg mh it mi b mj mz ju ml mm na jx mo lw nb mq mr lz nc mt mu mc nd mw mx my im bi translated">以上面的虚构例子为例，我们可以这样分割它:</p><pre class="kj kk kl km gt oj oi ok ol aw om bi"><span id="302f" class="lr la it oi b gy on oo l op oq">RUN \<br/>    apt-get update \<br/>    &amp;&amp; DEBIAN_FRONTEND=noninteractive apt-get install apt-transport-https ca-certificates<br/># split point 1</span><span id="2f94" class="lr la it oi b gy or oo l op oq">RUN    <br/>    &amp;&amp; apt-key adv --keyserver SERVER --recv-keys KEY_ID \<br/>    &amp;&amp; DEBIAN_FRONTEND=noninteractive apt-get install some_packages<br/>    <br/># split point 2    <br/>RUN \    <br/>    &amp;&amp; sed -e s/something/otherthing/ \<br/>    &amp;&amp; rm somefile \<br/>    &amp;&amp; mkdir someDir \<br/>    &amp;&amp; run_a_script with_some_parameters</span><span id="5c2e" class="lr la it oi b gy or oo l op oq"># split point 3    <br/>RUN \<br/>    repeat_above a_few_times</span></pre><p id="5498" class="pw-post-body-paragraph mg mh it mi b mj mz ju ml mm na jx mo lw nb mq mr lz nc mt mu mc nd mw mx my im bi translated">所以我们这样做，我们做我们的编辑/修复/增强，最后，我们重组这些块。</p><p id="5f9d" class="pw-post-body-paragraph mg mh it mi b mj mz ju ml mm na jx mo lw nb mq mr lz nc mt mu mc nd mw mx my im bi translated">乏味。去喝杯咖啡，还有更多。</p><p id="f36d" class="pw-post-body-paragraph mg mh it mi b mj mz ju ml mm na jx mo lw nb mq mr lz nc mt mu mc nd mw mx my im bi translated">为什么是那些分裂点？</p><p id="69a8" class="pw-post-body-paragraph mg mh it mi b mj mz ju ml mm na jx mo lw nb mq mr lz nc mt mu mc nd mw mx my im bi translated"><strong class="mi iu">分割点1 </strong>:因为你不太可能希望每次都运行一个<code class="fe of og oh oi b">apt-get update</code>。而且这是一个耗时的过程，所以不管接下来会发生什么，你都希望它被缓存。</p><p id="5e43" class="pw-post-body-paragraph mg mh it mi b mj mz ju ml mm na jx mo lw nb mq mr lz nc mt mu mc nd mw mx my im bi translated"><strong class="mi iu"> Split point 2 </strong>:在列出必需的软件包安装步骤的部分中，您不太可能犯(许多)错误，所以您希望缓存这个可能很耗时的部分。所以你把它和后面的分开。接下来呢？配置。这比软件包列表更有可能需要一些更新，所以这个分割点是一个明智的决定。</p><p id="916e" class="pw-post-body-paragraph mg mh it mi b mj mz ju ml mm na jx mo lw nb mq mr lz nc mt mu mc nd mw mx my im bi translated"><strong class="mi iu">分割点3 </strong>:我们在它们之间分离我们拥有的任何高级组件。我们可能已经成功配置了其中一个组件，您可以开始着手下一个组件了。您希望将缓存层与目前为止您对第一个组件所做的操作结合使用。</p><p id="b4cf" class="pw-post-body-paragraph mg mh it mi b mj mz ju ml mm na jx mo lw nb mq mr lz nc mt mu mc nd mw mx my im bi translated">提示1:按照章节被改变的可能性降低来排序章节。例如，包配置最有可能改变，所以那些通常在最后结束。或者入口点脚本。</p><p id="07ec" class="pw-post-body-paragraph mg mh it mi b mj mz ju ml mm na jx mo lw nb mq mr lz nc mt mu mc nd mw mx my im bi translated">技巧2:特别是如果您没有缓存代理，当您添加一个新的存储库时，您还需要从中获取信息(通过一个<code class="fe of og oh oi b">apt-get update</code>)。如果您有多个存储库，首先添加存储库，然后运行一个<code class="fe of og oh oi b">apt-get update</code>。当然，这是Debian/Ubuntu特有的，但是其他人也可能有类似的行为。</p><h2 id="7300" class="lr la it bd lb ls lt dn lf lu lv dp lj lw lx ly ll lz ma mb ln mc md me lp mf bi translated">复用性</h2><p id="b323" class="pw-post-body-paragraph mg mh it mi b mj mk ju ml mm mn jx mo lw mp mq mr lz ms mt mu mc mv mw mx my im bi translated">看<strong class="mi iu">链接</strong>B、docker文件名(<code class="fe of og oh oi b">Dockerfile.template</code>、<em class="oe">、</em>如果没有打开链接)。这不是Dockerfile的最终版本。它实际上似乎是一个简单的模板文件，其中一些变量被替换为<code class="fe of og oh oi b">sed</code>。</p><p id="279d" class="pw-post-body-paragraph mg mh it mi b mj mz ju ml mm na jx mo lw nb mq mr lz nc mt mu mc nd mw mx my im bi translated">这背后的原因是，他们希望能够强制对其进行一些更改。通常，您会更改基本映像名称和版本，以及您的应用程序版本。</p><p id="91fd" class="pw-post-body-paragraph mg mh it mi b mj mz ju ml mm na jx mo lw nb mq mr lz nc mt mu mc nd mw mx my im bi translated">嘿，不错，这里有可重用性——但是太单薄了。另一方面，我们已经得到了提示:模板化或生成Dockerfile！</p><p id="6680" class="pw-post-body-paragraph mg mh it mi b mj mz ju ml mm na jx mo lw nb mq mr lz nc mt mu mc nd mw mx my im bi translated">让我们看看上面虚构的Dockerfile部分示例的内容，甚至可能在<strong class="mi iu">链接</strong> <strong class="mi iu"> B </strong>处。</p><p id="38e8" class="pw-post-body-paragraph mg mh it mi b mj mz ju ml mm na jx mo lw nb mq mr lz nc mt mu mc nd mw mx my im bi translated">我们有一个<code class="fe of og oh oi b">apt-get update</code>司令部。很好。在某种程度上，我意识到添加<code class="fe of og oh oi b">-qq</code>可能会更好，不那么冗长。(记下:编辑我所有的docker文件来改变这一点。)</p><p id="0ed3" class="pw-post-body-paragraph mg mh it mi b mj mz ju ml mm na jx mo lw nb mq mr lz nc mt mu mc nd mw mx my im bi translated">我们来安装一个包:<code class="fe of og oh oi b">apt-get install some_package</code>。很好。</p><p id="6da4" class="pw-post-body-paragraph mg mh it mi b mj mz ju ml mm na jx mo lw nb mq mr lz nc mt mu mc nd mw mx my im bi translated">后来你了解到，无论那个软件包建议你安装什么，最好更精确地说明你想安装什么和不想安装什么。这使得图像更薄，从安全角度来看更好(攻击面更小)。(记下:编辑我所有的docker文件以使用<code class="fe of og oh oi b">apt-get install — no-install-suggests — no-install-recommends</code>。)</p><p id="6dae" class="pw-post-body-paragraph mg mh it mi b mj mz ju ml mm na jx mo lw nb mq mr lz nc mt mu mc nd mw mx my im bi translated">啊，把<code class="fe of og oh oi b">DEBIAN_FRONTEND=noninteractive</code>和<code class="fe of og oh oi b">-yqq</code>也加进去。在Dockerfile文件中，您可能有几个安装包的地方。你应该把它们都换成那条大线。你闻到另一个问题了吗？(如果你感冒了，那就是复制粘贴。)</p><p id="f155" class="pw-post-body-paragraph mg mh it mi b mj mz ju ml mm na jx mo lw nb mq mr lz nc mt mu mc nd mw mx my im bi translated">我需要一个NGINX服务器加上一个Python守护程序代码加上一个Python web服务器。我想我是从https://hub.docker.com/r/tiangolo/uwsgi-nginx/的<a class="ae ky" href="https://hub.docker.com/r/tiangolo/uwsgi-nginx/" rel="noopener ugc nofollow" target="_blank">开始的</a>。</p><p id="ea9b" class="pw-post-body-paragraph mg mh it mi b mj mz ju ml mm na jx mo lw nb mq mr lz nc mt mu mc nd mw mx my im bi translated">我们还要注意到它到Dockerfile的链接:<br/><strong class="mi iu">Link</strong><strong class="mi iu">C</strong>:<a class="ae ky" href="https://raw.githubusercontent.com/tiangolo/uwsgi-nginx-docker/master/python3.7/Dockerfile" rel="noopener ugc nofollow" target="_blank">https://raw . githubusercontent . com/tiangolo/uws gi-nginx-docker/master/python 3.7/docker file</a></p><p id="473f" class="pw-post-body-paragraph mg mh it mi b mj mz ju ml mm na jx mo lw nb mq mr lz nc mt mu mc nd mw mx my im bi translated">无论如何，我很快就放弃了那个源码，因为开始的镜像已经很大了，安装了很多不必要的包。但实际上可能是因为它自己的起始层。</p><p id="075f" class="pw-post-body-paragraph mg mh it mi b mj mz ju ml mm na jx mo lw nb mq mr lz nc mt mu mc nd mw mx my im bi translated">所以，我说，我要给自己造一个。</p><p id="2d88" class="pw-post-body-paragraph mg mh it mi b mj mz ju ml mm na jx mo lw nb mq mr lz nc mt mu mc nd mw mx my im bi translated">我以NGINX的资源库为起点看了一下(比如<strong class="mi iu">链接</strong>T15】A)——顺便借鉴一下好东西！</p><p id="b79c" class="pw-post-body-paragraph mg mh it mi b mj mz ju ml mm na jx mo lw nb mq mr lz nc mt mu mc nd mw mx my im bi translated">有趣的是:当通过<code class="fe of og oh oi b">apt</code> : <code class="fe of og oh oi b">Dpkg::Options::= — force-unsafe-io</code>安装包时，我发现了另一个很好的选择。(所以我自己注意:编辑我所有的docker文件来改变安装包命令。嗯，我要开始重复我的待办事项吗？)</p><p id="ffba" class="pw-post-body-paragraph mg mh it mi b mj mz ju ml mm na jx mo lw nb mq mr lz nc mt mu mc nd mw mx my im bi translated">我看到了安装NGINX的另一个有趣的部分——寻找一个好的服务器来导入GPG密钥。我知道我会在其他Docker图像中需要NGINX，所以……(你已经知道该怎么做了，对吗？记录:改变我在所有docker文件中安装NGINX的方式。)</p><p id="9565" class="pw-post-body-paragraph mg mh it mi b mj mz ju ml mm na jx mo lw nb mq mr lz nc mt mu mc nd mw mx my im bi translated">还有…注意如何清理:缓存目录、日志目录清理、包缓存、库列表、自动安装的包和可以自动删除的包，等等。通过查看每一个Dockerfile文件，您将会了解到可以清理的新内容，并且您将会收获更多！(我自己注意:更新我的Dockerfiles，清理部分，用我可能错过的东西，从我给你的这些链接。)</p><p id="7613" class="pw-post-body-paragraph mg mh it mi b mj mz ju ml mm na jx mo lw nb mq mr lz nc mt mu mc nd mw mx my im bi translated">记下所有这些事情后，我要做什么？去编辑我的每一个docker文件。每次我发现我能改进的事情，我都会再做一次。我的大脑开始尖叫:可重用性在哪里？好的开发实践在哪里？</p></div><div class="ab cl ns nt hx nu" role="separator"><span class="nv bw bk nw nx ny"/><span class="nv bw bk nw nx ny"/><span class="nv bw bk nw nx"/></div><div class="im in io ip iq"><h1 id="2c8d" class="kz la it bd lb lc nz le lf lg oa li lj jz ob ka ll kc oc kd ln kf od kg lp lq bi translated">开始改善情况</h1><p id="b58b" class="pw-post-body-paragraph mg mh it mi b mj mk ju ml mm mn jx mo lw mp mq mr lz ms mt mu mc mv mw mx my im bi translated">目标:</p><ul class=""><li id="4e71" class="ne nf it mi b mj mz mm na lw ng lz nh mc ni my nj nk nl nm bi translated">目标A——降低认知负荷。有你能命名的小的独立部分。当程序是由更小的、名字更好的函数构建而成时，考虑函数和理解整个程序的方式。</li><li id="ad2f" class="ne nf it mi b mj nn mm no lw np lz nq mc nr my nj nk nl nm bi translated">目标B——使用相同的代码库，允许Dockerfiles寻找生产构建运行或开发构建运行。</li><li id="9848" class="ne nf it mi b mj nn mm no lw np lz nq mc nr my nj nk nl nm bi translated">目标C——允许docker文件基于一些参数(如版本、映像起始点等)看起来有一点不同。).</li><li id="41c3" class="ne nf it mi b mj nn mm no lw np lz nq mc nr my nj nk nl nm bi translated">目标D—允许从可重复使用的片段创建docker文件。</li></ul><p id="17e4" class="pw-post-body-paragraph mg mh it mi b mj mz ju ml mm na jx mo lw nb mq mr lz nc mt mu mc nd mw mx my im bi translated">思想开始流动…</p><ul class=""><li id="a62a" class="ne nf it mi b mj mz mm na lw ng lz nh mc ni my nj nk nl nm bi translated">不打算直接使用docker文件，而是生成一个。模板机制什么的。没什么新鲜的，别人都在做，但我觉得没有做到极致。</li><li id="edf5" class="ne nf it mi b mj nn mm no lw np lz nq mc nr my nj nk nl nm bi translated">由于大多数问题来自shell命令，模板引擎将是shell脚本(<a class="ae ky" href="https://en.wikipedia.org/wiki/Bash_(Unix_shell)" rel="noopener ugc nofollow" target="_blank"> Bash </a>)。也就是说，我们将从shell脚本中生成代码。这意味着没有额外的依赖。无论如何，要编写docker文件，您必须知道一些shell脚本，所以您可以重用这些知识。很可能您已经有了一个shell构建脚本(<code class="fe of og oh oi b">build.sh</code>、<code class="fe of og oh oi b">update.sh</code>等等)。</li><li id="079c" class="ne nf it mi b mj nn mm no lw np lz nq mc nr my nj nk nl nm bi translated">因此，脚本将是输出实际Dockerfile内容的Bash代码。参数/变量可用于定制输出(如来自图像源)。作为shell脚本，您应该能够轻松获得目标C)。</li><li id="d60c" class="ne nf it mi b mj nn mm no lw np lz nq mc nr my nj nk nl nm bi translated">更容易理解:使用更小、更好命名的Bash函数。目标A检查过了！起个好名字是主观的，但仍然比没有名字大了一步。</li><li id="f1ea" class="ne nf it mi b mj nn mm no lw np lz nq mc nr my nj nk nl nm bi translated">我开始感觉好些了。我们正在接近一种更加以开发者为中心的方式。吃冰淇淋。</li><li id="899f" class="ne nf it mi b mj nn mm no lw np lz nq mc nr my nj nk nl nm bi translated">我们需要跟踪Dockerfile是需要在开发者模式还是生产模式下生成。</li><li id="636e" class="ne nf it mi b mj nn mm no lw np lz nq mc nr my nj nk nl nm bi translated">为了实现前面的思想，我们需要能够区分RUN命令和其他命令。正在运行的将在生产模式中加入。(这一项和前一项是针对目标b的。)</li><li id="1f51" class="ne nf it mi b mj nn mm no lw np lz nq mc nr my nj nk nl nm bi translated">可重用性:你将你的公共函数创建到一个单独的SCM存储库中，然后以某种方式将它用作SCM依赖(例如，作为Git子模块)。)</li><li id="4b6b" class="ne nf it mi b mj nn mm no lw np lz nq mc nr my nj nk nl nm bi translated">Bash脚本将使用大量“here文档”来生成内容。不喜欢那个，但还是可以接受的。</li><li id="53bc" class="ne nf it mi b mj nn mm no lw np lz nq mc nr my nj nk nl nm bi translated">所有生成的内容(用于运行命令)需要以<code class="fe of og oh oi b">;</code>开始，以<code class="fe of og oh oi b">\</code>结束。强制:在你的代码前需要有<code class="fe of og oh oi b">set -e</code>。比起<code class="fe of og oh oi b">&amp;&amp;</code>，我更喜欢<code class="fe of og oh oi b">;</code>。有些结构用<code class="fe of og oh oi b">&amp;&amp;</code>方式实现会更难，而<code class="fe of og oh oi b">;</code>更自然——它是为分隔语句而创建的。我不喜欢这样的事实，我仍然不得不用一些东西来限定语句。尽管如此，这是一种可以接受的痛苦。暂时如此。</li></ul></div><div class="ab cl ns nt hx nu" role="separator"><span class="nv bw bk nw nx ny"/><span class="nv bw bk nw nx ny"/><span class="nv bw bk nw nx"/></div><div class="im in io ip iq"><h1 id="2a5b" class="kz la it bd lb lc nz le lf lg oa li lj jz ob ka ll kc oc kd ln kf od kg lp lq bi translated">密码</h1><p id="7338" class="pw-post-body-paragraph mg mh it mi b mj mk ju ml mm mn jx mo lw mp mq mr lz ms mt mu mc mv mw mx my im bi translated">共享(可重用)代码片段:</p><p id="98a4" class="pw-post-body-paragraph mg mh it mi b mj mz ju ml mm na jx mo lw nb mq mr lz nc mt mu mc nd mw mx my im bi translated"><code class="fe of og oh oi b">main.sh</code>:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="os ot l"/></div></figure><p id="cb09" class="pw-post-body-paragraph mg mh it mi b mj mz ju ml mm na jx mo lw nb mq mr lz nc mt mu mc nd mw mx my im bi translated"><code class="fe of og oh oi b">apt.sh</code>:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="os ot l"/></div></figure><p id="86bd" class="pw-post-body-paragraph mg mh it mi b mj mz ju ml mm na jx mo lw nb mq mr lz nc mt mu mc nd mw mx my im bi translated"><code class="fe of og oh oi b">dockerfile-gen.sh </code> —真实项目的主文件:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="os ot l"/></div></figure><h2 id="4f42" class="lr la it bd lb ls lt dn lf lu lv dp lj lw lx ly ll lz ma mb ln mc md me lp mf bi translated">使用</h2><p id="1e43" class="pw-post-body-paragraph mg mh it mi b mj mk ju ml mm mn jx mo lw mp mq mr lz ms mt mu mc mv mw mx my im bi translated">生成docker文件并运行构建:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="os ot l"/></div></figure><p id="40c8" class="pw-post-body-paragraph mg mh it mi b mj mz ju ml mm na jx mo lw nb mq mr lz nc mt mu mc nd mw mx my im bi translated">假设您处于开发模式:</p><ul class=""><li id="5bd5" class="ne nf it mi b mj mz mm na lw ng lz nh mc ni my nj nk nl nm bi translated">运行一次。您将获得一个包含许多运行条目的文件(每个<code class="fe of og oh oi b">run_*</code>函数调用至少有一个)</li><li id="2bd5" class="ne nf it mi b mj nn mm no lw np lz nq mc nr my nj nk nl nm bi translated">现在修改脚本中的一些内容，比如与配置相关的代码。运行构建脚本，它应该显示Docker正在重用一些缓存层。</li><li id="b00e" class="ne nf it mi b mj nn mm no lw np lz nq mc nr my nj nk nl nm bi translated">当一切正常时，用不同的参数运行构建脚本，这将进一步删除<code class="fe of og oh oi b">— dev</code>参数。</li><li id="c2e2" class="ne nf it mi b mj nn mm no lw np lz nq mc nr my nj nk nl nm bi translated">代码应该再次生成docker文件，但是这次使用的RUN命令要少得多。</li><li id="662d" class="ne nf it mi b mj nn mm no lw np lz nq mc nr my nj nk nl nm bi translated">对这张图片再做一次测试。</li></ul><p id="0549" class="pw-post-body-paragraph mg mh it mi b mj mz ju ml mm na jx mo lw nb mq mr lz nc mt mu mc nd mw mx my im bi translated">搞定了。</p><p id="b3e9" class="pw-post-body-paragraph mg mh it mi b mj mz ju ml mm na jx mo lw nb mq mr lz nc mt mu mc nd mw mx my im bi translated">除了那些函数调用，从主观上来说，这些函数调用命名得很好，能让你很快理解我们在做什么，可能会出现一个问题:条件调用是怎么回事？</p><h2 id="9e5b" class="lr la it bd lb ls lt dn lf lu lv dp lj lw lx ly ll lz ma mb ln mc md me lp mf bi translated"><strong class="ak">把</strong> <code class="fe of og oh oi b"><strong class="ak">copy_files</strong></code> <strong class="ak">叫做</strong></h2><p id="8387" class="pw-post-body-paragraph mg mh it mi b mj mk ju ml mm mn jx mo lw mp mq mr lz ms mt mu mc mv mw mx my im bi translated">您很可能需要将一些文件(配置文件、代码、启动脚本等)推送到映像中。在开发过程中，它们发生变化的概率非常高，因此，正如我们所讨论的，我们希望在docker文件中尽可能晚地发生这种情况。但是我们还需要在那之后运行一些代码来对它们做一些真正需要的动作(<code class="fe of og oh oi b">chmod +x</code>、<code class="fe of og oh oi b">mv</code>等等)。).</p><p id="da03" class="pw-post-body-paragraph mg mh it mi b mj mz ju ml mm na jx mo lw nb mq mr lz nc mt mu mc nd mw mx my im bi translated">这就是在它之后调用函数<code class="fe of og oh oi b">run_fix_files</code>的原因。不幸的是，这将迫使一个新的层，但我们无能为力。将该功能保持在最低限度。在生产模式下，我们不希望在清理功能和开始更新/安装软件的行之间有任何东西。您希望那里只有<code class="fe of og oh oi b">run_*</code>风格的函数调用。</p><h2 id="badc" class="lr la it bd lb ls lt dn lf lu lv dp lj lw lx ly ll lz ma mb ln mc md me lp mf bi translated"><code class="fe of og oh oi b">run_cleanup</code>呼叫</h2><p id="c5f1" class="pw-post-body-paragraph mg mh it mi b mj mk ju ml mm mn jx mo lw mp mq mr lz ms mt mu mc mv mw mx my im bi translated">您可能不希望它处于开发模式，因为这需要时间，并且您对运行它或最终图像的大小不感兴趣。<br/>另一方面，这使得测试由生产other文件创建的图像变得更加必要，因为您还想测试清理的副作用。</p><p id="2f88" class="pw-post-body-paragraph mg mh it mi b mj mz ju ml mm na jx mo lw nb mq mr lz nc mt mu mc nd mw mx my im bi translated">想想看:如果你的应用程序依赖于某个库，但是这个函数和它所做的任何事情都认为它是自动安装的，并不是真正需要的，那该怎么办？</p><p id="b34f" class="pw-post-body-paragraph mg mh it mi b mj mz ju ml mm na jx mo lw nb mq mr lz nc mt mu mc nd mw mx my im bi translated">对于目标D，为了从共享代码中获益，你应该把它放在一个专用的存储库中，比如g it，或者这个<a class="ae ky" href="https://github.com/cr1st1p/dockerfile-lib" rel="noopener ugc nofollow" target="_blank">存储库</a>。在你的应用程序的安装说明中，你应该提到用户应该如何<code class="fe of og oh oi b">git clone</code>你的库，这样他们也可以获得依赖关系。</p><p id="29b2" class="pw-post-body-paragraph mg mh it mi b mj mz ju ml mm na jx mo lw nb mq mr lz nc mt mu mc nd mw mx my im bi translated">如果您为某个产品创建了一个映像，这个映像很有可能稍后被集成到不同的容器中，那么您应该将您的函数(来自那个<code class="fe of og oh oi b">dockerfile-gen.sh</code>脚本)放在单独的文件中，以允许它们被重用。例如，在<a class="ae ky" href="https://github.com/cr1st1p/docker-simplestreams-server" rel="noopener ugc nofollow" target="_blank">这个库</a>中，我把一些函数放在目录<code class="fe of og oh oi b">dockerfile</code>中。</p><p id="7d4f" class="pw-post-body-paragraph mg mh it mi b mj mz ju ml mm na jx mo lw nb mq mr lz nc mt mu mc nd mw mx my im bi translated">关于复用性，本来想多说一点，但是只要同时打开上面那三个链接(A、B、C)自己找找就好了。</p><p id="48db" class="pw-post-body-paragraph mg mh it mi b mj mz ju ml mm na jx mo lw nb mq mr lz nc mt mu mc nd mw mx my im bi translated">重要提示:您不能将这种编写docker文件的方式强加给其他人，但是在您的组织中，如果您正在创建许多具有目前为止所讨论的问题的图像，您可能会从改变编写它们的方式中受益。</p></div><div class="ab cl ns nt hx nu" role="separator"><span class="nv bw bk nw nx ny"/><span class="nv bw bk nw nx ny"/><span class="nv bw bk nw nx"/></div><div class="im in io ip iq"><h1 id="4f26" class="kz la it bd lb lc nz le lf lg oa li lj jz ob ka ll kc oc kd ln kf od kg lp lq bi translated">进一步的改进和想法</h1><ul class=""><li id="3565" class="ne nf it mi b mj mk mm mn lw ou lz ov mc ow my nj nk nl nm bi translated">这可能对那些拥有大量使用缓存的专用构建节点的人有所帮助:您可以拥有一段时间后自动使缓存层失效的代码。想想几个多小时后就不想用<code class="fe of og oh oi b">FROM ubuntu:latest RUN apt-get update</code>的缓存层了。</li><li id="4081" class="ne nf it mi b mj nn mm no lw np lz nq mc nr my nj nk nl nm bi translated">有一个好的<code class="fe of og oh oi b">apt</code>处理库，或者你正在使用的任何包管理。也许可以定义一种方法来声明运行时需要的包和构建时需要的包。</li><li id="5ccc" class="ne nf it mi b mj nn mm no lw np lz nq mc nr my nj nk nl nm bi translated">最重要的是:找到一种不使用Bash“here documents”的方法，而是使用真正的shell代码。你会获得更多的优势。别走开，我对此有一些想法。</li></ul></div><div class="ab cl ns nt hx nu" role="separator"><span class="nv bw bk nw nx ny"/><span class="nv bw bk nw nx ny"/><span class="nv bw bk nw nx"/></div><div class="im in io ip iq"><p id="1792" class="pw-post-body-paragraph mg mh it mi b mj mz ju ml mm na jx mo lw nb mq mr lz nc mt mu mc nd mw mx my im bi translated">哇！太久了！</p><p id="2a9e" class="pw-post-body-paragraph mg mh it mi b mj mz ju ml mm na jx mo lw nb mq mr lz nc mt mu mc nd mw mx my im bi translated">即使你不会使用或应用我上面描述的，我仍然希望你喜欢它，并且你学到了关于写Docker图片的新东西。如有任何问题、意见或建议，请随时联系我。</p></div></div>    
</body>
</html>