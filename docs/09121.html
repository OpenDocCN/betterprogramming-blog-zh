<html>
<head>
<title>Observe Your iOS App’s Network Connection Using Combine</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用Combine观察您的iOS应用程序的网络连接</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/observe-your-ios-apps-network-connection-using-combine-d96864111b83?source=collection_archive---------6-----------------------#2021-07-16">https://betterprogramming.pub/observe-your-ios-apps-network-connection-using-combine-d96864111b83?source=collection_archive---------6-----------------------#2021-07-16</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="78e4" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">SwiftUI和UIKit示例</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/c2d855180326152b893637b244da58b5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*LGnR28_kkvBPFaiT"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">照片由<a class="ae ky" href="https://unsplash.com/@anhnhat1205?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Anh Nhat </a>在<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄。</p></figure><p id="13ff" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在本文中，我们将学习如何使用<a class="ae ky" href="https://developer.apple.com/documentation/network" rel="noopener ugc nofollow" target="_blank">网络</a>框架和<a class="ae ky" href="https://developer.apple.com/documentation/combine" rel="noopener ugc nofollow" target="_blank">组合</a>发布器来观察网络状态变化并做出反应。</p><p id="48c8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">简而言之，这就是我们将在本教程中掌握的内容:</p><ul class=""><li id="bbca" class="lv lw it lb b lc ld lf lg li lx lm ly lq lz lu ma mb mc md bi translated">如何为<code class="fe me mf mg mh b">NWPathMonitor</code>创建一个自定义的可重用的联合发布器，一个会观察网络状态的组件。</li><li id="ca0e" class="lv lw it lb b lc mi lf mj li mk lm ml lq mm lu ma mb mc md bi translated">如何将网络状态更新绑定到UIKit和SwiftUI中的UI元素。</li></ul><p id="2dda" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">该项目的源代码可以在文章的底部找到。</p></div><div class="ab cl mn mo hx mp" role="separator"><span class="mq bw bk mr ms mt"/><span class="mq bw bk mr ms mt"/><span class="mq bw bk mr ms"/></div><div class="im in io ip iq"><h1 id="16d8" class="mu mv it bd mw mx my mz na nb nc nd ne jz nf ka ng kc nh kd ni kf nj kg nk nl bi translated">我们开始吧</h1><p id="d74f" class="pw-post-body-paragraph kz la it lb b lc nm ju le lf nn jx lh li no lk ll lm np lo lp lq nq ls lt lu im bi translated">首先，让我们导入网络和组合框架，并在<code class="fe me mf mg mh b">NWPathMonitor</code>上定义一个扩展:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nr ns l"/></div></figure><p id="a3b3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在我们需要实施一个<code class="fe me mf mg mh b">Subscription</code>:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nr ns l"/></div></figure><ol class=""><li id="3ba6" class="lv lw it lb b lc ld lf lg li lx lm ly lq lz lu nt mb mc md bi translated">我们依赖于接受<code class="fe me mf mg mh b">NWPath.Status</code>作为输入的<code class="fe me mf mg mh b">Subscriber</code>。</li><li id="9a39" class="lv lw it lb b lc mi lf mj li mk lm ml lq mm lu nt mb mc md bi translated">我们还创建了<code class="fe me mf mg mh b">monitor</code>和<code class="fe me mf mg mh b">queue</code>依赖项，这样我们可以在以后启动网络监控过程。</li><li id="f879" class="lv lw it lb b lc mi lf mj li mk lm ml lq mm lu nt mb mc md bi translated">为了符合<code class="fe me mf mg mh b">Subscription</code>协议，我们实现了<code class="fe me mf mg mh b">request(_ demand:)</code>和<code class="fe me mf mg mh b">cancel()</code>方法。在<code class="fe me mf mg mh b">request</code>方法中，我们将启动监控过程。在<code class="fe me mf mg mh b">cancel</code>里面，我们会在必要的时候取消进程。</li></ol><p id="44c3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们更新<code class="fe me mf mg mh b">request</code>和<code class="fe me mf mg mh b">cancel</code>方法如下:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nr ns l"/></div></figure><ol class=""><li id="0694" class="lv lw it lb b lc ld lf lg li lx lm ly lq lz lu nt mb mc md bi translated">我们使用<code class="fe me mf mg mh b">pathUpdateHandler</code>属性来接收包含当前网络状态的<code class="fe me mf mg mh b">NWPath</code>。一旦状态改变，<code class="fe me mf mg mh b">Subscriber</code>将接收到一个<code class="fe me mf mg mh b">NWPath.Status</code>值。</li><li id="efc3" class="lv lw it lb b lc mi lf mj li mk lm ml lq mm lu nt mb mc md bi translated">我们开始监控过程，以便能够获得<code class="fe me mf mg mh b">pathUpdateHandler</code>闭包内部的状态变化。</li><li id="d866" class="lv lw it lb b lc mi lf mj li mk lm ml lq mm lu nt mb mc md bi translated">在<code class="fe me mf mg mh b">cancel()</code>方法中，一旦订阅被取消，我们就相应地禁用监控过程。</li></ol><p id="abce" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">完成<code class="fe me mf mg mh b">Subscription</code>后，现在我们将再次扩展<code class="fe me mf mg mh b">NWPathMonitor</code>来创建一个自定义的<code class="fe me mf mg mh b">Publisher</code>:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nr ns l"/></div></figure><p id="15e7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">下面是我们用这段代码实现的结果:</p><ol class=""><li id="52a9" class="lv lw it lb b lc ld lf lg li lx lm ly lq lz lu nt mb mc md bi translated">我们定义了一个符合<code class="fe me mf mg mh b">Publisher</code>协议的定制<code class="fe me mf mg mh b">NetworkStatusPublisher</code>。</li><li id="b33d" class="lv lw it lb b lc mi lf mj li mk lm ml lq mm lu nt mb mc md bi translated">发布器<em class="nu">发出</em> <code class="fe me mf mg mh b">NWPath.Status</code>值，从不出错。</li><li id="69c5" class="lv lw it lb b lc mi lf mj li mk lm ml lq mm lu nt mb mc md bi translated">与我们之前定义的订阅非常相似，我们也依赖于<code class="fe me mf mg mh b">NWPathMonitor</code>和<code class="fe me mf mg mh b">DispatchQueue</code>。</li><li id="96be" class="lv lw it lb b lc mi lf mj li mk lm ml lq mm lu nt mb mc md bi translated">在所需的<code class="fe me mf mg mh b">receive&lt;S&gt;(subscriber:)</code>方法中，我们将很快创建之前创建的<code class="fe me mf mg mh b">NetworkStatusSubscription</code>，并为<code class="fe me mf mg mh b">NetworkStatusPublisher</code>附加一个订阅者。</li><li id="c901" class="lv lw it lb b lc mi lf mj li mk lm ml lq mm lu nt mb mc md bi translated">我们定义了一个<code class="fe me mf mg mh b">publisher(queue:)</code>方法，它将允许我们稍后从一个<code class="fe me mf mg mh b">NWPathMonitor</code>属性创建一个<code class="fe me mf mg mh b">Publisher</code>，并观察例如<code class="fe me mf mg mh b">UIViewController</code>中的网络状态变化。</li></ol><p id="4e45" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在让我们完成<code class="fe me mf mg mh b">receive&lt;S&gt;(subscriber:)</code>方法:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nr ns l"/></div></figure><ol class=""><li id="bdf0" class="lv lw it lb b lc ld lf lg li lx lm ly lq lz lu nt mb mc md bi translated">我们用提供的订阅者<code class="fe me mf mg mh b">NWPathMonitor</code>和一个<code class="fe me mf mg mh b">DispatchQueue</code>初始化<code class="fe me mf mg mh b">NetworkStatusSubscription</code>。</li><li id="9561" class="lv lw it lb b lc mi lf mj li mk lm ml lq mm lu nt mb mc md bi translated">我们告诉订阅者我们已经成功地订阅了一个发布者。</li></ol><p id="b985" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">最后，我们准备在我们的应用程序中使用<code class="fe me mf mg mh b">NetworkStatusPublisher</code>。</p></div><div class="ab cl mn mo hx mp" role="separator"><span class="mq bw bk mr ms mt"/><span class="mq bw bk mr ms mt"/><span class="mq bw bk mr ms"/></div><div class="im in io ip iq"><h1 id="7253" class="mu mv it bd mw mx my mz na nb nc nd ne jz nf ka ng kc nh kd ni kf nj kg nk nl bi translated">SwiftUI实施</h1><p id="b480" class="pw-post-body-paragraph kz la it lb b lc nm ju le lf nn jx lh li no lk ll lm np lo lp lq nq ls lt lu im bi translated">下面是我们如何在使用MVVM设计模式的SwiftUI应用程序中使用它:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nr ns l"/></div></figure><ol class=""><li id="0578" class="lv lw it lb b lc ld lf lg li lx lm ly lq lz lu nt mb mc md bi translated">我们创建了一个带有名为<code class="fe me mf mg mh b">networkStatus</code>的<code class="fe me mf mg mh b">Published</code>属性的<code class="fe me mf mg mh b">ObservableObject</code>视图模型。</li><li id="6ad8" class="lv lw it lb b lc mi lf mj li mk lm ml lq mm lu nt mb mc md bi translated">在初始化器内部，我们启动订阅并观察<code class="fe me mf mg mh b">.sink</code>操作符内部的状态变化。一旦我们得到一个值，我们就把它赋给我们之前定义的<code class="fe me mf mg mh b">Published</code> <code class="fe me mf mg mh b">networkStatus</code>属性。</li><li id="a259" class="lv lw it lb b lc mi lf mj li mk lm ml lq mm lu nt mb mc md bi translated">在<code class="fe me mf mg mh b">ContentView</code>里面，我们只是根据当前网络状态显示不同的<code class="fe me mf mg mh b">Text</code>。一旦状态改变，<code class="fe me mf mg mh b">Text</code>会自动更新。</li></ol></div><div class="ab cl mn mo hx mp" role="separator"><span class="mq bw bk mr ms mt"/><span class="mq bw bk mr ms mt"/><span class="mq bw bk mr ms"/></div><div class="im in io ip iq"><h1 id="d9fa" class="mu mv it bd mw mx my mz na nb nc nd ne jz nf ka ng kc nh kd ni kf nj kg nk nl bi translated">UIKit实现</h1><p id="6614" class="pw-post-body-paragraph kz la it lb b lc nm ju le lf nn jx lh li no lk ll lm np lo lp lq nq ls lt lu im bi translated">a <code class="fe me mf mg mh b">UIViewController</code>内部的实现非常相似:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nr ns l"/></div></figure><p id="bf40" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这里，我们有一个<code class="fe me mf mg mh b">observeNetworkStatus()</code>方法，我们在其中观察状态并相应地更新<code class="fe me mf mg mh b">textLabel</code>。</p><p id="3f4b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">太好了！我们已经成功地实现了一个可重用的网络状态发布器，我们可以轻松地在我们的应用程序中使用。</p><p id="9012" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">注意，测试网络变化最好在真实设备上进行，因为模拟器不能准确显示应用程序中的网络变化。</p></div><div class="ab cl mn mo hx mp" role="separator"><span class="mq bw bk mr ms mt"/><span class="mq bw bk mr ms mt"/><span class="mq bw bk mr ms"/></div><div class="im in io ip iq"><h1 id="66e9" class="mu mv it bd mw mx my mz na nb nc nd ne jz nf ka ng kc nh kd ni kf nj kg nk nl bi translated">资源</h1><p id="3dd0" class="pw-post-body-paragraph kz la it lb b lc nm ju le lf nn jx lh li no lk ll lm np lo lp lq nq ls lt lu im bi translated">源代码可在<a class="ae ky" href="https://github.com/zafarivaev/networkconnectivity-combine" rel="noopener ugc nofollow" target="_blank"> GitHub </a>上获得。</p></div><div class="ab cl mn mo hx mp" role="separator"><span class="mq bw bk mr ms mt"/><span class="mq bw bk mr ms mt"/><span class="mq bw bk mr ms"/></div><div class="im in io ip iq"><h1 id="9cbc" class="mu mv it bd mw mx my mz na nb nc nd ne jz nf ka ng kc nh kd ni kf nj kg nk nl bi translated">包扎</h1><p id="8696" class="pw-post-body-paragraph kz la it lb b lc nm ju le lf nn jx lh li no lk ll lm np lo lp lq nq ls lt lu im bi translated">要了解更多关于<code class="fe me mf mg mh b">NWPathMonitor</code>的信息，请随意查阅<a class="ae ky" href="https://medium.com/@rwbutler/nwpathmonitor-the-new-reachability-de101a5a8835" rel="noopener">罗斯·巴特勒</a>的这篇文章。</p><p id="03eb" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我希望你觉得这个教程有用。感谢阅读！</p></div></div>    
</body>
</html>