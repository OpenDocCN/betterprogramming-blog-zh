<html>
<head>
<title>Test-Driven Development in React Application</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">React应用程序中的测试驱动开发</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/test-driven-development-in-react-application-f697f66467e5?source=collection_archive---------3-----------------------#2022-10-17">https://betterprogramming.pub/test-driven-development-in-react-application-f697f66467e5?source=collection_archive---------3-----------------------#2022-10-17</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="707e" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">如何应用TDD方法的详细指南</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/f3cfbe7f6d229bcf80a151c4b63cf86f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*w477nHMwDvt141G46cDJjg.jpeg"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">感谢来自unsplash.com<a class="ae kv" href="https://unsplash.com/" rel="noopener ugc nofollow" target="_blank">的<a class="ae kv" href="https://unsplash.com/@chiabra" rel="noopener ugc nofollow" target="_blank">基亚布拉</a>的图片</a></p></figure><p id="e2b0" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">测试是我们生活中非常重要的一部分。测试给你对事物的信心。现在你在厨房里做沙拉调料。你把所有的配料混合在一起，你或多或少知道它们的味道。你的过程的结果将是一个腌制的沙拉。在把酱放入沙拉之前，你可能想检查一下——它够咸、够甜或够辣吗？最后，你用调料给沙拉调味。</p><p id="55f7" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在完成过程的结尾之前试图理解它是怎样的就是测试。我们在上菜前测试食物，在建桥前测试组件的强度。我们在将药物送往药店之前会对其进行测试。美国宇航局在发射火箭前做了许多测试。这里可以给出十几个例子，但是测试的思想无处不在。有了编码，也是一样。</p><p id="d705" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在我们的项目中编写代码就像一个滚雪球一样越滚越大——出错和最终失败的几率非常高。此外，其他开发人员也参与到项目中，如果没有测试，破坏某些东西的几率会更高。当服务中出现问题时，企业会花费时间和金钱来修复它。所以，最好通过测试来预测潜在的错误。</p><p id="cd89" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在阅读Robert C. Martin的《干净的代码》时，我认为首先考虑测试，然后创建一个组件是非常困难的。但是经过一些训练和下面描述的技术，我对TDD比以前更有信心了。</p><p id="9fb1" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在这里，您将学习如何对React应用程序使用测试，以及一般的测试行为。你会看到不同类型的测试之间的区别，在哪里使用它们，什么时候使用。做好大量编码的准备。</p><p id="4784" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在开始编写测试之前，我想强调三个重要的概念:</p><ul class=""><li id="44e7" class="ls lt iq ky b kz la lc ld lf lu lj lv ln lw lr lx ly lz ma bi translated">DDD —领域驱动的开发</li><li id="617a" class="ls lt iq ky b kz mb lc mc lf md lj me ln mf lr lx ly lz ma bi translated">行为驱动的开发</li><li id="2b23" class="ls lt iq ky b kz mb lc mc lf md lj me ln mf lr lx ly lz ma bi translated">测试驱动开发</li></ul><h1 id="b71a" class="mg mh iq bd mi mj mk ml mm mn mo mp mq jw mr jx ms jz mt ka mu kc mv kd mw mx bi translated">DD是什么？</h1><p id="0613" class="pw-post-body-paragraph kw kx iq ky b kz my jr lb lc mz ju le lf na lh li lj nb ll lm ln nc lp lq lr ij bi translated">DD的意思是驱动发展。这意味着发展是基于某种行为的。请看下图:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nd"><img src="../Images/5fc62732bd1c4458ef35e07382fb3177.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*2Dd09t1UxX9od2P265UlbA.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">驱动发展</p></figure><h2 id="d548" class="ne mh iq bd mi nf ng dn mm nh ni dp mq lf nj nk ms lj nl nm mu ln nn no mw np bi translated">DDD</h2><p id="7fb5" class="pw-post-body-paragraph kw kx iq ky b kz my jr lb lc mz ju le lf na lh li lj nb ll lm ln nc lp lq lr ij bi translated">这是在代码中对商业思想的正确解释。就像写企业代码的技巧；产生的代码是基于商业理念的。它包括诸如通用语言这样的重要方面，通用语言是业务和开发方之间的一种独特的交流语言。另一方面，模型驱动设计基于一个模型和一些开发模式。</p><h2 id="5bfa" class="ne mh iq bd mi nf ng dn mm nh ni dp mq lf nj nk ms lj nl nm mu ln nn no mw np bi translated">BDD</h2><p id="6b4d" class="pw-post-body-paragraph kw kx iq ky b kz my jr lb lc mz ju le lf na lh li lj nb ll lm ln nc lp lq lr ij bi translated">这意味着改善开发团队和业务之间的沟通。这个概念是从TDD分出来的；这就像是它的变体或延伸。BDD是对行为的描述，它对集成测试和e2e很有帮助。</p><h2 id="7fab" class="ne mh iq bd mi nf ng dn mm nh ni dp mq lf nj nk ms lj nl nm mu ln nn no mw np bi translated">TimeDivisionDuplex 时分双工</h2><p id="3c04" class="pw-post-body-paragraph kw kx iq ky b kz my jr lb lc mz ju le lf na lh li lj nb ll lm ln nc lp lq lr ij bi translated">这是基于测试的发展。TDD认为你应该在写代码之前写测试，这样你就可以看到它是否会失败。只有在书面测试之后，您才开始为书面测试编写功能，并找出满足测试的组件。对于单元测试来说非常好。</p><h1 id="e538" class="mg mh iq bd mi mj mk ml mm mn mo mp mq jw mr jx ms jz mt ka mu kc mv kd mw mx bi translated">试验</h1><ul class=""><li id="2e9c" class="ls lt iq ky b kz my lc mz lf nq lj nr ln ns lr lx ly lz ma bi translated">单元测试——这是一种测试类型，当你测试一个元素(或实体)时，没有任何与其他元素的绑定(连接)。</li><li id="3d1e" class="ls lt iq ky b kz mb lc mc lf md lj me ln mf lr lx ly lz ma bi translated">集成测试——这是关于React向DOM呈现某些内容时的呈现逻辑。它着眼于相关的函数，枚举，一些逻辑依赖函数，等等。</li><li id="8d05" class="ls lt iq ky b kz mb lc mc lf md lj me ln mf lr lx ly lz ma bi translated">E2E测试——当我们测试用户如何与界面交互时。它关注的是渲染结束时用户对界面的行为。有浏览器和创建的用户，他们通过一个界面。</li></ul><h2 id="a894" class="ne mh iq bd mi nf ng dn mm nh ni dp mq lf nj nk ms lj nl nm mu ln nn no mw np bi translated">应用</h2><p id="9d0c" class="pw-post-body-paragraph kw kx iq ky b kz my jr lb lc mz ju le lf na lh li lj nb ll lm ln nc lp lq lr ij bi translated">在模式上，您可以看到应用程序非常简单。最后，您可以找到到<a class="ae kv" href="https://github.com/antonkalik/tdd-react-example" rel="noopener ugc nofollow" target="_blank"> GitHub资源库</a>的链接。但是现在，让我们专注于按照TDD方法构建应用程序。我们不会实现所有的组件。重要的是理解如何在React中使用TDD。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nt"><img src="../Images/4e055696333ea34980ee475c05f593ed.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*8V-oGRPVnqBme6unCf9ubQ.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">应用程序模式</p></figure><p id="18d6" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">开始时，理解我们要构建什么并确定实现这个应用程序需要什么组件是非常重要的。在我的解释中，我们从简单的开始。</p><p id="a933" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">该应用程序的想法是呈现从一个假API请求的卡片网格。此外，我们必须能够通过点击<code class="fe nu nv nw nx b">Add </code>按钮来添加新卡，而<code class="fe nu nv nw nx b">Clear</code>按钮必须从网格中移除所有的卡。最后，在<code class="fe nu nv nw nx b">Footer</code>中，我们显示了牌的总数。每张卡我们必须能够打开或删除。我用的是<code class="fe nu nv nw nx b">create-react-app</code>。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ny nz l"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">应用程序的包</p></figure><p id="2961" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">安装包之后，让我们来构造我们的文件夹。每个组件和视图文件夹必须有<code class="fe nu nv nw nx b">index.js</code>作为一个文件。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ny nz l"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">文件夹结构</p></figure><p id="d138" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">应用程序中的路由必须具有以下路由:</p><pre class="kg kh ki kj gt oa nx ob oc aw od bi"><span id="c80a" class="ne mh iq nx b gy oe of l og oh">/ -&gt; Home Page<br/>/cards -&gt; Cards Grid Page<br/>/card/:id -&gt; Card View<br/>/about -&gt; About View<br/>/* -&gt; Not Found View</span></pre><h1 id="8ca8" class="mg mh iq bd mi mj mk ml mm mn mo mp mq jw mr jx ms jz mt ka mu kc mv kd mw mx bi translated">试验</h1><p id="aab2" class="pw-post-body-paragraph kw kx iq ky b kz my jr lb lc mz ju le lf na lh li lj nb ll lm ln nc lp lq lr ij bi translated">当我们用技术语言描述应用程序时，我们已经调用了一些组件。每个组件都必须独立于测试。我们必须能够测试组件而不依赖于其他组件。我们将从视图开始编写组件。我们需要它们来呈现<code class="fe nu nv nw nx b">App</code>本身并测试路由。</p><pre class="kg kh ki kj gt oa nx ob oc aw od bi"><span id="3370" class="ne mh iq nx b gy oe of l og oh">└── views<br/>        ├── AboutView<br/>        ├── CardView<br/>        ├── CardsView<br/>        └── HomeView</span></pre><p id="fc3a" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在文件夹<code class="fe nu nv nw nx b">src/views/</code>里，我们把<code class="fe nu nv nw nx b">index.js. &lt;VIEW_NAME&gt;.spec.js</code>放在每个文件里。比如<code class="fe nu nv nw nx b">AboutView.spec.js</code>然后打开。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ny nz l"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">关于查看测试开始</p></figure><p id="4796" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">是的，我们正在抛出<code class="fe nu nv nw nx b">Error('Not implemented')</code>，你必须习惯它，因为最重要的部分是描述。我们必须描述我们将在每个<code class="fe nu nv nw nx b">it</code>中测试什么，以及我们期望从那个组件的每个测试中得到什么。现在将以下内容添加到<code class="fe nu nv nw nx b">index.js</code>:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ny nz l"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">对“关于视图”第一次测试的满意度</p></figure><p id="91c7" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">回到您的测试文件。我们将完全按照我们对这个组件的期望来编写测试。我们在期待什么？渲染后，我们将保存快照和<code class="fe nu nv nw nx b">About View</code>标题。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ny nz l"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">测试关于视图</p></figure><p id="d101" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">Jest帮助我们将组件结构的快照保存到磁盘，并在随后的测试运行中，将新的快照与先前保存的快照进行比较。在这种情况下，快照只是数据结构的文本表示。第一次触发测试快照时，它会将组件的文本表示结果写入磁盘。测试将通过并被记录为快照。</p><p id="8ced" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">下次操作组件时，测试将会失败，因为写入快照的数据会有差异。为什么它很重要？比较并防止组件中不需要的元素。检查快照中的差异非常重要。如果其中有未定义的值，默认情况下快照测试将被破坏。回到<code class="fe nu nv nw nx b">index.js</code>，为测试调整我们的视图组件。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ny nz l"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">关于视图</p></figure><p id="0414" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">对所有其他视图进行同样的操作。为你的组件、函数、工具、钩子等等写一个测试和实现。这是TDD的主要概念。</p><h2 id="f922" class="ne mh iq bd mi nf ng dn mm nh ni dp mq lf nj nk ms lj nl nm mu ln nn no mw np bi translated">路线</h2><p id="4b12" class="pw-post-body-paragraph kw kx iq ky b kz my jr lb lc mz ju le lf na lh li lj nb ll lm ln nc lp lq lr ij bi translated">如你所知，我们的应用程序中有<code class="fe nu nv nw nx b">Routes</code>可以呈现我们的视图。在文件夹<code class="fe nu nv nw nx b">src/Routes</code>中，创建<code class="fe nu nv nw nx b">index.js</code>和<code class="fe nu nv nw nx b">Routes.spec.js</code>，然后将其添加到文件中:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ny nz l"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">带组件路由器的TDD</p></figure><p id="2c16" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">到了<code class="fe nu nv nw nx b">it</code>，我们准确描述了我们对<code class="fe nu nv nw nx b">Routes</code>的预期。让我们先加入我们的<code class="fe nu nv nw nx b">HomeView</code>期望。了解我们对此组件的期望很重要。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ny nz l"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">路线测试</p></figure><p id="3175" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">第一个测试告诉我们<code class="fe nu nv nw nx b">HomeView</code>必须通过路线<code class="fe nu nv nw nx b">/</code>。如您所见，我们模仿它只是为了避免视图组件的意外导入。我们通过测试实现进行隔离。让我们为这个测试调整一下我们的<code class="fe nu nv nw nx b">Routes</code>。不多不少。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ny nz l"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">路线组件</p></figure><p id="20c1" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">运行您的测试。除了与<code class="fe nu nv nw nx b">HomeView</code>相关的第一个测试之外，结果必须与失败的测试相关。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi oi"><img src="../Images/f66bad89c35673d1e29f146fec444674.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*OReOajdn8xU3M1O4qGErGw.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">通过了路由组件的测试</p></figure><p id="4cc2" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><code class="fe nu nv nw nx b">it</code>一个接一个地为其他视图添加测试。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ny nz l"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">路由测试的完整描述</p></figure><p id="e9b2" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">并为每个描述的测试调整组件。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ny nz l"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">测试的路由组件更新</p></figure><h1 id="75e5" class="mg mh iq bd mi mj mk ml mm mn mo mp mq jw mr jx ms jz mt ka mu kc mv kd mw mx bi translated">应用程序组件</h1><p id="996e" class="pw-post-body-paragraph kw kx iq ky b kz my jr lb lc mz ju le lf na lh li lj nb ll lm ln nc lp lq lr ij bi translated">是时候用主<code class="fe nu nv nw nx b">App</code>组件绑定它了。进入<code class="fe nu nv nw nx b">App</code>文件夹，创建文件:<code class="fe nu nv nw nx b">index.js, App.spec.js</code>。记住<code class="fe nu nv nw nx b">App</code>必须有<code class="fe nu nv nw nx b">Routes</code>。我们来测试一下。</p><p id="36b6" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">打开<code class="fe nu nv nw nx b">App.spec.js</code>，像之前用<code class="fe nu nv nw nx b">throw Error("Not implemented");</code>一样描述app测试。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ny nz l"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">模拟应用程序测试</p></figure><p id="bc8e" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">当然，我们还没有任何<code class="fe nu nv nw nx b">App</code>组件，但是我们已经知道在这个组件中，我们将会有<code class="fe nu nv nw nx b">Routes</code>。让我们创建<code class="fe nu nv nw nx b">App</code>组件。我用的是<code class="fe nu nv nw nx b">styled-components</code>。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ny nz l"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">应用程序组件</p></figure><p id="5c40" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">现在，让我们为<code class="fe nu nv nw nx b">App</code>运行我们的测试。您将看到快照将被创建，并且测试已通过。</p><h2 id="446c" class="ne mh iq bd mi nf ng dn mm nh ni dp mq lf nj nk ms lj nl nm mu ln nn no mw np bi translated">页眉</h2><p id="5ce4" class="pw-post-body-paragraph kw kx iq ky b kz my jr lb lc mz ju le lf na lh li lj nb ll lm ln nc lp lq lr ij bi translated">是时候为我们的<code class="fe nu nv nw nx b">MainLayout</code>准备一些组件了。<code class="fe nu nv nw nx b">Header</code>有<code class="fe nu nv nw nx b">title</code>和两个按钮<code class="fe nu nv nw nx b">Add</code>和<code class="fe nu nv nw nx b">Clear</code>。让我们从测试开始。老规矩，用<code class="fe nu nv nw nx b">Test not implemented</code>。只有第一个测试将为我们的组件做好准备。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ny nz l"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">标题测试场景</p></figure><p id="4e89" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">然后让我们为笔试创建我们的<code class="fe nu nv nw nx b">Header</code>。只满足测试；没别的了。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ny nz l"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">标题组件</p></figure><p id="059b" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">然后进行测试。必须通过两个第一测试。好了，让我们将其他测试逐个添加到<code class="fe nu nv nw nx b">Header</code>中，并针对每个测试组件进行改进。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ny nz l"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">标题测试控件</p></figure><p id="887e" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在向<code class="fe nu nv nw nx b">Header</code>组件添加按钮之后——更新您的快照。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ny nz l"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">测试的标题自适应</p></figure><p id="7e36" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">如你所见，我们正在一步一步地进行。首先是测试，然后我们做实现来满足测试。让我们为<code class="fe nu nv nw nx b">Header</code>添加两个额外的测试，如下所示:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ny nz l"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">标题测试</p></figure><p id="6945" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">当然，还要为这些测试修改组件。我们必须确定我们的函数已经被调用。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ny nz l"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">测试标题的最终实现</p></figure><h2 id="da0b" class="ne mh iq bd mi nf ng dn mm nh ni dp mq lf nj nk ms lj nl nm mu ln nn no mw np bi translated">页脚</h2><p id="e0e9" class="pw-post-body-paragraph kw kx iq ky b kz my jr lb lc mz ju le lf na lh li lj nb ll lm ln nc lp lq lr ij bi translated">这个组件要简单得多，但是我们要在其中渲染一些卡片。你可以看看上面是什么样子。首先，创建一个名为<code class="fe nu nv nw nx b">Footer.spec.js</code>的测试。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ny nz l"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">页脚测试</p></figure><p id="61c9" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">并适应测试组件的每种情况。几乎与标题中的相同，但简单得多。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ny nz l"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">页脚组件</p></figure><h1 id="aea7" class="mg mh iq bd mi mj mk ml mm mn mo mp mq jw mr jx ms jz mt ka mu kc mv kd mw mx bi translated">钩住</h1><p id="b535" class="pw-post-body-paragraph kw kx iq ky b kz my jr lb lc mz ju le lf na lh li lj nb ll lm ln nc lp lq lr ij bi translated">是的，我们必须用同样的方法测试钩子。让我们假设我们将有一些请求卡的问题。我们有一个请求的链接，数据的预期结果必须是一个带有<code class="fe nu nv nw nx b">id</code>和<code class="fe nu nv nw nx b">title</code>的数组。</p><p id="e8c4" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">对于HTTP请求，我们将使用<code class="fe nu nv nw nx b">axios</code>。首先，我们要嘲笑这一切。让我们转到<code class="fe nu nv nw nx b">src/hooks</code>并创建一个文件夹<code class="fe nu nv nw nx b">useApi</code>。将会有<code class="fe nu nv nw nx b">index.js</code>和<code class="fe nu nv nw nx b">useApi.spec.js</code>，在开始时，让我们在那里添加这些模拟:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ny nz l"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">useApi钩子测试模拟</p></figure><p id="0611" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">好的，不。我们可以描述一下我们对钩子的期望。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ny nz l"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">使用Api测试</p></figure><p id="e511" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这一部分已经很熟悉了，我们必须为测试调整我们钩子。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ny nz l"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">为笔试使用Api挂钩改编</p></figure><p id="2ef2" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">让我们在测试中描述对钩子行为的期望。在这种情况下，<code class="fe nu nv nw nx b">mockImplementation</code>有助于独立返回每个测试中承诺的假数据。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ny nz l"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">挂钩使用测试</p></figure><p id="bc77" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们正在等待每一项测试中特定领域的变化。为什么我们会有它？因为钩子会用在有生命周期的组件中。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ny nz l"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">useApi挂钩实现</p></figure><h1 id="9611" class="mg mh iq bd mi mj mk ml mm mn mo mp mq jw mr jx ms jz mt ka mu kc mv kd mw mx bi translated">还原剂</h1><p id="2604" class="pw-post-body-paragraph kw kx iq ky b kz my jr lb lc mz ju le lf na lh li lj nb ll lm ln nc lp lq lr ij bi translated">完全相同的方法可以用于上下文中的reducer。让我们假设我们的应用程序有一个上下文，我们将在一个reducer的帮助下使用一些动作。记住我们使用<code class="fe nu nv nw nx b">initState</code>在<code class="fe nu nv nw nx b">useReducer</code>钩内的减速器:</p><pre class="kg kh ki kj gt oa nx ob oc aw od bi"><span id="68e2" class="ne mh iq nx b gy oe of l og oh">export const <em class="oj">initialState </em>= { cards: [] };</span><span id="9582" class="ne mh iq nx b gy ok of l og oh">const [state, dispatch] = useReducer(reducer, <em class="oj">initialState</em>);</span></pre><p id="b736" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">那么，让我们描述一下我们对那个减速器的期望。代码如下:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ny nz l"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">减速器测试</p></figure><p id="0404" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">当然，还要一个接一个地调整我们减速器。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ny nz l"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">减速器功能</p></figure><p id="e415" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">现在，更新测试以获得减速器行为的附加描述。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ny nz l"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">减速器测试更新</p></figure><p id="c407" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">同样，为所有的书面测试修改reducer。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ny nz l"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">减速器功能更新</p></figure><h1 id="cb1b" class="mg mh iq bd mi mj mk ml mm mn mo mp mq jw mr jx ms jz mt ka mu kc mv kd mw mx bi translated">其他组件</h1><p id="0269" class="pw-post-body-paragraph kw kx iq ky b kz my jr lb lc mz ju le lf na lh li lj nb ll lm ln nc lp lq lr ij bi translated">现在，尝试检查存储库中的其他组件，并编写自己的测试。有<code class="fe nu nv nw nx b">Card</code>、<code class="fe nu nv nw nx b">Cards</code>、<code class="fe nu nv nw nx b">MainLayout</code>带<code class="fe nu nv nw nx b">Header</code>、<code class="fe nu nv nw nx b">Footer</code>。首先，创建测试，然后是组件实现。</p><h1 id="9475" class="mg mh iq bd mi mj mk ml mm mn mo mp mq jw mr jx ms jz mt ka mu kc mv kd mw mx bi translated">结论</h1><p id="568f" class="pw-post-body-paragraph kw kx iq ky b kz my jr lb lc mz ju le lf na lh li lj nb ll lm ln nc lp lq lr ij bi translated">我只想向您展示如何在您的应用程序中使用TDD。刚开始的时候，感觉很烦，但是最后你节省了很多时间。因此，您将收到经过全面测试的独立组件，如果其他开发人员需要在那里做一些更新，这将是清楚的。</p><p id="2793" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">总的来说，TDD提供了稳定性、可靠性和成熟的解决方案，这些都是任何企业应用的基石<strong class="ky ir">。</strong></p><h1 id="377c" class="mg mh iq bd mi mj mk ml mm mn mo mp mq jw mr jx ms jz mt ka mu kc mv kd mw mx bi translated">资源</h1><p id="8e01" class="pw-post-body-paragraph kw kx iq ky b kz my jr lb lc mz ju le lf na lh li lj nb ll lm ln nc lp lq lr ij bi translated">GitHub库:<a class="ae kv" href="https://github.com/antonkalik/tdd-react-example" rel="noopener ugc nofollow" target="_blank">https://github.com/antonkalik/tdd-react-example</a></p><pre class="kg kh ki kj gt oa nx ob oc aw od bi"><span id="2879" class="ne mh iq nx b gy oe of l og oh"><strong class="nx ir">Want to Connect?</strong></span><span id="1911" class="ne mh iq nx b gy ok of l og oh">I'll be glad to keep in touch through <a class="ae kv" href="https://twitter.com/idedycom" rel="noopener ugc nofollow" target="_blank">Twitter</a>.</span><span id="5afc" class="ne mh iq nx b gy ok of l og oh">It's always a pleasure to receive any suggestions and comments related to the topic. Feel free to ask any questions.</span><span id="f317" class="ne mh iq nx b gy ok of l og oh">Thank you!</span></pre></div></div>    
</body>
</html>