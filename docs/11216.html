<html>
<head>
<title>Decoupling Your Concerns With Dependency Injection, the Repository Pattern, React, and TypeScript</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">用依赖注入、存储库模式、React和TypeScript来消除您的顾虑</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/decoupling-your-concerns-with-dependency-injection-the-repository-pattern-react-and-typescript-6b455788a374?source=collection_archive---------3-----------------------#2022-02-28">https://betterprogramming.pub/decoupling-your-concerns-with-dependency-injection-the-repository-pattern-react-and-typescript-6b455788a374?source=collection_archive---------3-----------------------#2022-02-28</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="ff5d" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">构建松散耦合的可伸缩应用程序</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/2cd5389e98fae53a54bf65dc4175097f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*SG-Cu3QpeLvlsz5W"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">Igor bispo 在<a class="ae kv" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</p></figure><p id="224c" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">你有没有被固化的应用程序逻辑所困扰？当供应商发生变化时，必须重写整个组件或项目？希望您的前端代码不依赖于特定的数据实现？被文章开头无情的问题所困扰？</p><p id="5de6" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在这篇文章中，我将通过一个例子来说明如何构建能够伸缩并适应未来变化的松耦合应用程序。我们将使用Typescript实现一种称为存储库模式的技术设计模式，并使用依赖注入来构建一个与实现无关的React前端。</p><p id="90e9" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">让我们从谈论存储库开始。</p><blockquote class="ls lt lu"><p id="2951" class="kw kx lv ky b kz la jr lb lc ld ju le lw lg lh li lx lk ll lm ly lo lp lq lr ij bi translated">存储库是封装了访问数据源所需的逻辑的类或组件。</p></blockquote><p id="a2bf" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">您可以将他们视为您的数据存储和前端之间的中间人。它们是数据操作的表示，充当前端和数据存储之间的契约。通常每个应用程序实体都有一个存储库<em class="lv">，并定义一组公共方法及其约定的返回值。这提供了与数据存储交互的通用接口，而无需指定任何关于<em class="lv">如何与该数据存储交互的具体信息。</em></em></p><p id="8143" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们可以使用依赖注入工具将我们创建的存储库注入到我们的前端代码中。</p><blockquote class="ls lt lu"><p id="d392" class="kw kx lv ky b kz la jr lb lc ld ju le lw lg lh li lx lk ll lm ly lo lp lq lr ij bi translated">在<a class="ae kv" href="https://en.wikipedia.org/wiki/Software_engineering" rel="noopener ugc nofollow" target="_blank">软件工程</a>中，依赖注入是一种技术，其中一个对象(或静态方法)提供另一个对象的依赖。依赖是可以使用的对象(一个<a class="ae kv" href="https://en.wikipedia.org/wiki/Service_(systems_architecture)" rel="noopener ugc nofollow" target="_blank">服务</a>)。</p></blockquote><p id="e8d4" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">用例子更容易理解依赖注入。</p><p id="dc81" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">想象💭您有一个React组件，它从一些API获取一些数据。您进行调用，然后如果调用成功，您解析它并将其存储在React状态中。您取出需要在前端显示的相关部分，也许您将整个嵌套对象传递给其他React组件，让它们在内部处理数据。</p><p id="09d1" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">现在想象一下💭您需要调用一个完全不同的API(假设您工作的公司更换了提供商，他们现在将这些信息存储在不同的数据存储中)，并且数据结构已经完全改变。当你的前端向内破裂时，你对着所有的<code class="fe lz ma mb mc b">TypeErrors</code>流泪。你谷歌一下怎么写辞职信。</p><p id="d45a" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">现在想象(这是我最后一次保证)你的前端完全不知道这个逻辑。</p><p id="251a" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">你同意需要打电话，但你不关心打给谁。</p><p id="b7ec" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">您同意您正在处理的实体的结构，并使用依赖注入来注入一个通用的<em class="lv">库</em>，该库公开了一个通用的<em class="lv"> getter。</em></p><p id="61ff" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">看不到具体的逻辑，这意味着当某些东西必须改变时，我们只需要编写另一个遵循相同规则的具体服务，并且前端已经构建好可以处理。</p><p id="1074" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">你合上谷歌标签，松了一口气。</p><p id="bcbe" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">让我们深入一些代码，看看它在一个实际的例子中是如何工作的。</p><p id="8946" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">假设我们有一个面向用户的应用程序，我们需要构建一个用户登录后将会看到的个人资料页面。我们还假设我们关注一个实体，一个<code class="fe lz ma mb mc b">User</code>，我们需要显示他们的全名、性别和出生日期(为了简单起见，这些都是可用的)。</p><p id="05f4" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">对于一个数据存储，我们将假设我们有一个用户服务，我们可以通过查询来获取用户ID。我将使用<a class="ae kv" href="https://randomuser.me/" rel="noopener ugc nofollow" target="_blank">这个</a>免费的API作为我们的第一个虚拟的具体用户服务，然后演示我们如何简单地将其转换为第二个。</p><p id="928e" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我已经用TypeScript 建立了一个<a class="ae kv" href="https://create-react-app.dev/docs/adding-typescript/" rel="noopener ugc nofollow" target="_blank"> create react app项目，安装了<code class="fe lz ma mb mc b">inversify</code>和<code class="fe lz ma mb mc b">reflect-metadata</code>，并在我的tsconfig中启用了实验装饰器和装饰器元数据属性:</a></p><pre class="kg kh ki kj gt md mc me mf aw mg bi"><span id="9299" class="mh mi iq mc b gy mj mk l ml mm">{<br/>"compilerOptions": {<br/>  ...,<br/>  "lib": ["dom", "dom.iterable", "es6", "esnext"],<br/>  "types": ["reflect-metadata", "node"],<br/>  "experimentalDecorators": true,<br/>  "emitDecoratorMetadata": true<br/>},<br/>...<br/>}</span></pre><p id="3319" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">首先要做的是定义一些类型。我们知道我们需要用户提供什么数据，因此我们定义:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mn mo l"/></div></figure><p id="ddc3" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">现在让我们定义一个非常简单的带有get by id的存储库泛型:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mn mo l"/></div></figure><p id="3879" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">请注意，这个存储库与我们的实体<code class="fe lz ma mb mc b">User</code>没有任何联系——这就是泛型的美妙之处！当实现并传递了<code class="fe lz ma mb mc b">User</code>类型时，它将绘制出一个数据访问模式，看起来有点像:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mn mo l"/></div></figure><p id="b1af" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">如果我们在应用程序中需要另一个实体类型，比如订单，我们可以这样定义另一个实现:</p><pre class="kg kh ki kj gt md mc me mf aw mg bi"><span id="5e8b" class="mh mi iq mc b gy mj mk l ml mm">interface OrderRepository implements IRepository&lt;Order&gt; {<br/>  get(id: string): Promise&lt;Order | null&gt;;<br/>}</span></pre><p id="4932" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">现在我们有了一个跨所有实体的通用的、一致同意的数据访问模式，我们可以围绕它而不是围绕任何具体的东西来构建前端。在我们开始构建存储库之前，我们还需要一种类型来帮助我们——一种表示数据存储中数据形状的类型。</p><p id="5888" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">回到我们从<code class="fe lz ma mb mc b">randomuser.me</code>开始的模拟API，我们可以概括如下:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mn mo l"/></div></figure><p id="f92d" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">请注意，这是一个不同于我们之前定义的<code class="fe lz ma mb mc b">User</code>类型的形状，这完全没问题，因为我们将构建一个简单的<em class="lv">解析器</em>，它将数据从具体的形状映射到所需的形状。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mn mo l"/></div></figure><p id="af4f" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">现在我们已经设计好了我们的类型，我们可以实现<code class="fe lz ma mb mc b">IRepository</code>泛型并构建一个具体的用户服务！</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mn mo l"/></div></figure><p id="acd5" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">存储库公开了一个get方法，该方法对我们的API进行简单的获取，如果成功，解析数据，将其映射到我们期望的<code class="fe lz ma mb mc b">User</code>类型。</p><p id="3d0f" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在真实的应用程序中，这将包含我们所有的其他数据访问方法！我们已经用inversify的decorator标记了我们的存储库，这允许我们立刻将我们的存储库注入到前端！</p><p id="c170" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们首先还需要一样东西:我们的存储库的唯一标识符:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mn mo l"/></div></figure><p id="de59" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">InversifyJS支持将符号作为服务标识符——这有助于避免命名冲突，因为符号是唯一且不可变的。</p><p id="fa50" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们现在可以用inversify设置控制容器的反转了！</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mn mo l"/></div></figure><p id="779e" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">拆开上面的；我们首先实例化一个从inversify导入的新容器。然后，我们将唯一的服务密钥绑定到我们的具体实现。因为我们想定义这个服务的实例，所以我们使用了<code class="fe lz ma mb mc b">inSingletonScope</code>方法(如果没有这个方法，每次请求这个依赖项时都会创建一个新的服务)。</p><p id="4d54" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">好了，现在我们有了一个可以使用的容器，让我们制作一个简单的react应用程序。我们将呈现一个按钮，上面写着<em class="lv"> GET USER </em>，当点击该按钮时，就会向API发出请求，并将其显示在屏幕上。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi mp"><img src="../Images/4cdfff8713d6d55c25c4a6e7851977af.png" data-original-src="https://miro.medium.com/v2/resize:fit:1200/1*UsBOBRkvc4P0XJ9z3BCXfg.gif"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">我保证我实际上是一个专业的前端开发</p></figure><p id="8f4d" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">根据之前的文档，我们需要将reflect-metadata polyfill导入到我们的<code class="fe lz ma mb mc b">index.tsx</code>文件中，以便使用inversify。然后我们有了一个类似这样的应用程序:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mn mo l"/></div></figure><p id="a2b9" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们现在可以导入我们的容器并使用我们之前构建的存储库:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mn mo l"/></div></figure><p id="3faa" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们使用我们的服务标识符向我们的容器请求<em class="lv">一个</em>用户存储库，但是我们的应用程序不需要知道具体的实现，这些都是在容器级别注入的。一旦我们获得了我们的服务，我们知道每个存储库都公开了一个异步的get方法，我们可以用它从API中拉出一个用户！这种设计使得定义业务逻辑不可知的前端成为可能——很酷吧？</p><p id="3fe9" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">为了演示我们适应变化有多容易，让我们将具体的实现换成另一个，并将我们的假数据存储转移到不同的提供商<a class="ae kv" href="https://random-data-api.com/" rel="noopener ugc nofollow" target="_blank">https://random-data-api.com</a>。</p><p id="7c23" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们首先来看看新数据存储中实体的形状:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mn mo l"/></div></figure><p id="5d24" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">并定义一个新的解析器:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mn mo l"/></div></figure><p id="11e0" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们现在可以实现IRepository并创建一个新的具体服务，如下所示:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mn mo l"/></div></figure><p id="77d9" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">现在转向我们的容器，我们可以注入这个实现:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mn mo l"/></div></figure><p id="6236" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">而前端却一无所知！</p><p id="0ab2" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">有希望的是，依赖注入和存储库模式的有用性已经变得清晰——它可以帮助消除任何未来的麻烦，并且通常使您的前端应用程序更容易维护和响应变化。</p><p id="078a" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">感谢阅读！</p></div></div>    
</body>
</html>