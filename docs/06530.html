<html>
<head>
<title>Building a Recommendation Engine With PyTorch</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">用PyTorch构建推荐引擎</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/building-a-recommendation-engine-with-pytorch-d64be4856fe7?source=collection_archive---------2-----------------------#2020-10-09">https://betterprogramming.pub/building-a-recommendation-engine-with-pytorch-d64be4856fe7?source=collection_archive---------2-----------------------#2020-10-09</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="531d" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">理解推荐引擎的内部</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/69102c0f14d9e6ac33fcd9250c1f6235.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ptGydg-rxqLVD_mQxQzKlg.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">照片来自<a class="ae ky" href="https://pytorch.org" rel="noopener ugc nofollow" target="_blank"> Pytorch </a>。</p></figure></div><div class="ab cl kz la hx lb" role="separator"><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le"/></div><div class="im in io ip iq"><h1 id="e17b" class="lg lh it bd li lj lk ll lm ln lo lp lq jz lr ka ls kc lt kd lu kf lv kg lw lx bi translated">为什么是推荐引擎？</h1><p id="b03f" class="pw-post-body-paragraph ly lz it ma b mb mc ju md me mf jx mg mh mi mj mk ml mm mn mo mp mq mr ms mt im bi translated">作为一个对ML(机器学习)几乎一无所知的开发人员，我发现构建一个推荐引擎是ML入门最容易的项目之一。对于没有机器学习背景的初学者来说，这很实用，也不难理解。</p></div><div class="ab cl kz la hx lb" role="separator"><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le"/></div><div class="im in io ip iq"><h1 id="0535" class="lg lh it bd li lj lk ll lm ln lo lp lq jz lr ka ls kc lt kd lu kf lv kg lw lx bi translated">入门指南</h1><p id="3eee" class="pw-post-body-paragraph ly lz it ma b mb mc ju md me mf jx mg mh mi mj mk ml mm mn mo mp mq mr ms mt im bi translated">在开始实际实现之前，我将简要回顾一些概念，您可能会发现这些概念有助于构建推荐引擎。</p><p id="0df2" class="pw-post-body-paragraph ly lz it ma b mb mu ju md me mv jx mg mh mw mj mk ml mx mn mo mp my mr ms mt im bi translated">在向用户推荐商品时，推荐引擎基本上可以使用三种算法:</p><h2 id="cac0" class="mz lh it bd li na nb dn lm nc nd dp lq mh ne nf ls ml ng nh lu mp ni nj lw nk bi translated">1.人口统计过滤</h2><p id="a5db" class="pw-post-body-paragraph ly lz it ma b mb mc ju md me mf jx mg mh mi mj mk ml mm mn mo mp mq mr ms mt im bi translated">这种类型的筛选基于具有相似人口统计的用户来查看项目的一般趋势和受欢迎程度。这意味着具有相似人口统计的用户被推荐相同的项目，并且个性化推荐非常有限。</p><h2 id="751d" class="mz lh it bd li na nb dn lm nc nd dp lq mh ne nf ls ml ng nh lu mp ni nj lw nk bi translated">2.基于内容的过滤</h2><p id="4099" class="pw-post-body-paragraph ly lz it ma b mb mc ju md me mf jx mg mh mi mj mk ml mm mn mo mp mq mr ms mt im bi translated">这种类型的过滤的基本算法基于项目的元数据来查看项目的相似性。例如，对于游戏，元数据可以是平台、类型和发行商之类的东西。因此，如果用户喜欢由Valve发布的PC动作RPG游戏，那么他们很可能会喜欢具有类似元数据的另一个游戏(即，由Valve发布并且是动作RPG PC游戏的游戏)。这意味着现在涉及到个性化推荐，因为用户喜欢的游戏被用来确定用户可能也喜欢的游戏。</p><h2 id="9f2e" class="mz lh it bd li na nb dn lm nc nd dp lq mh ne nf ls ml ng nh lu mp ni nj lw nk bi translated">3.协同过滤</h2><p id="efd3" class="pw-post-body-paragraph ly lz it ma b mb mc ju md me mf jx mg mh mi mj mk ml mm mn mo mp mq mr ms mt im bi translated">最后一种过滤可以分为两种类型。</p><ul class=""><li id="d3ed" class="nl nm it ma b mb mu me mv mh nn ml no mp np mt nq nr ns nt bi translated">基于用户:将用户与基于其他用户的项目相匹配。具体来说，算法确定与该用户相似的其他用户。这意味着给定一个用户和与该用户相似的另一个用户，将该另一个用户喜欢的推荐给该用户。</li><li id="e200" class="nl nm it ma b mb nu me nv mh nw ml nx mp ny mt nq nr ns nt bi translated">基于项目:根据项目与用户已评级项目的相似性，将用户与项目匹配。这意味着如果用户喜欢项目X，并且项目X被发现与项目Y高度相似，那么项目Y将被推荐给用户。</li></ul><p id="bafc" class="pw-post-body-paragraph ly lz it ma b mb mu ju md me mv jx mg mh mw mj mk ml mx mn mo mp my mr ms mt im bi translated">最佳类型的推荐引擎显然会集成所有这三种类型，但在本教程中，我们将专注于最后一种类型(协同过滤),因为它无疑是最强的类型。</p></div><div class="ab cl kz la hx lb" role="separator"><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le"/></div><div class="im in io ip iq"><h1 id="e3a9" class="lg lh it bd li lj lk ll lm ln lo lp lq jz lr ka ls kc lt kd lu kf lv kg lw lx bi translated">矩阵分解</h1><p id="a51a" class="pw-post-body-paragraph ly lz it ma b mb mc ju md me mf jx mg mh mi mj mk ml mm mn mo mp mq mr ms mt im bi translated">我们将看到的一类协作过滤算法叫做矩阵分解。矩阵分解的最终目标基本上是建立一个用户和项目的矩阵，其中填充了已知和预测的评级。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nz"><img src="../Images/eaf1523ddb74d70ae0f1acf0f2dad44c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*vfBFJZqNy1Qvjd99.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">作者照片。</p></figure><p id="48f2" class="pw-post-body-paragraph ly lz it ma b mb mu ju md me mv jx mg mh mw mj mk ml mx mn mo mp my mr ms mt im bi translated">从只有已知评级的原始矩阵开始，我们想要确定将产生原始矩阵的两个因素矩阵。这两个矩阵将依次表示用户、项目以及它们之间关系的信息。一个是定量表示用户的矩阵(用户矩阵)，其中矩阵的每一行是表示单个用户的大小为<em class="oa"> k </em>的向量，另一个是项目矩阵，其中每一列是表示单个项目的大小为<em class="oa"> k </em>的向量。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ob"><img src="../Images/b8e2c5212949241d62e4035b107448b5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*s4yxzwl8ZeIidvH_.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">作者照片。</p></figure><p id="2dc5" class="pw-post-body-paragraph ly lz it ma b mb mu ju md me mv jx mg mh mw mj mk ml mx mn mo mp my mr ms mt im bi translated"><em class="oa"> k </em>称为嵌入大小，是在矩阵分解模型中调整的超参数。较大的嵌入大小将允许模型捕捉更复杂的关系和信息，但是它可能导致过度拟合。</p></div><div class="ab cl kz la hx lb" role="separator"><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le"/></div><div class="im in io ip iq"><h1 id="8fe2" class="lg lh it bd li lj lk ll lm ln lo lp lq jz lr ka ls kc lt kd lu kf lv kg lw lx bi translated">PyTorch中的矩阵分解模型</h1><p id="cb58" class="pw-post-body-paragraph ly lz it ma b mb mc ju md me mf jx mg mh mi mj mk ml mm mn mo mp mq mr ms mt im bi translated">采用矩阵分解的思想，让我们在<a class="ae ky" href="https://pytorch.org/" rel="noopener ugc nofollow" target="_blank"> PyTorch </a>中实现它。</p><p id="6510" class="pw-post-body-paragraph ly lz it ma b mb mu ju md me mv jx mg mh mw mj mk ml mx mn mo mp my mr ms mt im bi translated">首先，让我们导入一些必要的模块:</p><pre class="kj kk kl km gt oc od oe of aw og bi"><span id="9f5f" class="mz lh it od b gy oh oi l oj ok">import torch<br/>import torch.nn as nn<br/>import torch.nn.functional as F<br/>from sklearn.model_selection import train_test_split</span></pre><p id="e924" class="pw-post-body-paragraph ly lz it ma b mb mu ju md me mv jx mg mh mw mj mk ml mx mn mo mp my mr ms mt im bi translated">接下来，让我们构建我们的<code class="fe ol om on od b">Matrix Factorization Model</code>类:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oo op l"/></div></figure><p id="dfd8" class="pw-post-body-paragraph ly lz it ma b mb mu ju md me mv jx mg mh mw mj mk ml mx mn mo mp my mr ms mt im bi translated">要实例化我们的模型，我们可以像这样简单地调用它:</p><pre class="kj kk kl km gt oc od oe of aw og bi"><span id="0d9f" class="mz lh it od b gy oh oi l oj ok">model = MF(num_users, num_items, emb_size=100)</span></pre><p id="bf50" class="pw-post-body-paragraph ly lz it ma b mb mu ju md me mv jx mg mh mw mj mk ml mx mn mo mp my mr ms mt im bi translated">其中<code class="fe ol om on od b">num_users</code>代表唯一用户的数量，<code class="fe ol om on od b">num_items</code>代表数据集中唯一项目的数量。</p><p id="cdd6" class="pw-post-body-paragraph ly lz it ma b mb mu ju md me mv jx mg mh mw mj mk ml mx mn mo mp my mr ms mt im bi translated">为了便于说明，这里有一个我正在使用的样本数据集:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi oq"><img src="../Images/ba3ce3168687957d4c663e36a0456b37.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*0B-HInyqYPcrU8bQ.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">作者截图。</p></figure><p id="2326" class="pw-post-body-paragraph ly lz it ma b mb mu ju md me mv jx mg mh mw mj mk ml mx mn mo mp my mr ms mt im bi translated">这里的项目是我们想推荐给用户的游戏。</p><p id="65dc" class="pw-post-body-paragraph ly lz it ma b mb mu ju md me mv jx mg mh mw mj mk ml mx mn mo mp my mr ms mt im bi translated">一旦模型被实例化，我们就可以继续分割数据集来训练和测试我们的模型。一般分成是20%测试，80%培训。</p><pre class="kj kk kl km gt oc od oe of aw og bi"><span id="531e" class="mz lh it od b gy oh oi l oj ok">train_df, valid_df = train_test_split(dataset, test_size=0.2)</span><span id="d781" class="mz lh it od b gy or oi l oj ok"># resetting indices to avoid indexing errors<br/>train_df = train_df.reset_index(drop=True)<br/>test_df = valid_df.reset_index(drop=True)</span></pre><p id="3a8c" class="pw-post-body-paragraph ly lz it ma b mb mu ju md me mv jx mg mh mw mj mk ml mx mn mo mp my mr ms mt im bi translated">现在，我们要创建训练函数来训练模型:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oo op l"/></div></figure><p id="0d77" class="pw-post-body-paragraph ly lz it ma b mb mu ju md me mv jx mg mh mw mj mk ml mx mn mo mp my mr ms mt im bi translated">在每次迭代中，训练函数基本上更新我们的模型，以接近更小的MSE(均方误差)。这就是梯度下降的思想。最后，我们的测试函数，将在训练完成后立即调用:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oo op l"/></div></figure><p id="a9bc" class="pw-post-body-paragraph ly lz it ma b mb mu ju md me mv jx mg mh mw mj mk ml mx mn mo mp my mr ms mt im bi translated">我们可以看到，尽管我们的模型在训练数据集中的最低MSE约为3.776，但基于我们的测试数据集的实际MSE约为8.778。一般来说，这是一个正常的结果，但训练和测试MSE之间的巨大差异可能表明我们的模型过度拟合。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi os"><img src="../Images/97ab57fe4a2f645d3b2dbb7f5e810479.png" data-original-src="https://miro.medium.com/v2/resize:fit:748/format:webp/0*XB5i18ZJossdBp1z.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">作者照片。</p></figure></div><div class="ab cl kz la hx lb" role="separator"><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le"/></div><div class="im in io ip iq"><h1 id="6c2d" class="lg lh it bd li lj lk ll lm ln lo lp lq jz lr ka ls kc lt kd lu kf lv kg lw lx bi translated">模型预测法</h1><p id="3cff" class="pw-post-body-paragraph ly lz it ma b mb mc ju md me mf jx mg mh mi mj mk ml mm mn mo mp mq mr ms mt im bi translated">现在，我们准备使用我们的模型进行预测！例如，为了预测<code class="fe ol om on od b">userId 10</code>用户的游戏评分，我们可以运行下面几行:</p><pre class="kj kk kl km gt oc od oe of aw og bi"><span id="afb8" class="mz lh it od b gy oh oi l oj ok">user = torch.tensor([10])<br/>games = torch.tensor(game_ratings['TitleId'].unique().tolist())<br/>predictions = model(user, games).tolist()<br/>print(predictions)</span></pre><p id="8179" class="pw-post-body-paragraph ly lz it ma b mb mu ju md me mv jx mg mh mw mj mk ml mx mn mo mp my mr ms mt im bi translated">请注意，一些预测超过了<code class="fe ol om on od b">10</code>。要解决这个问题，我们可以像这样简单地标准化我们的结果:</p><pre class="kj kk kl km gt oc od oe of aw og bi"><span id="d345" class="mz lh it od b gy oh oi l oj ok">normalized_predictions = [i/max(predictions)*10 for i in predictions]<br/>print(normalized_predictions)</span></pre><p id="fc02" class="pw-post-body-paragraph ly lz it ma b mb mu ju md me mv jx mg mh mw mj mk ml mx mn mo mp my mr ms mt im bi translated">最后，我们可以通过对我们的预测列表进行排序来推荐一些游戏:</p><pre class="kj kk kl km gt oc od oe of aw og bi"><span id="ba4b" class="mz lh it od b gy oh oi l oj ok">sortedIndices = predictions.argsort()<br/>recommendations = dataset['Title'].unique()[sortedIndices][:30]  # taking top 30<br/>print(recommendations)</span></pre><p id="59cb" class="pw-post-body-paragraph ly lz it ma b mb mu ju md me mv jx mg mh mw mj mk ml mx mn mo mp my mr ms mt im bi translated">显然，仍然有进一步改进这个模型的方法，但是我现在就把它留在这里。感谢阅读！</p><p id="3822" class="pw-post-body-paragraph ly lz it ma b mb mu ju md me mv jx mg mh mw mj mk ml mx mn mo mp my mr ms mt im bi translated">另外，请查看<a class="ae ky" href="https://steffy-lo.github.io/Gameo/" rel="noopener ugc nofollow" target="_blank"> Gameo </a>，这是一个使用这种算法和框架为今年的脸书开发者圈社区挑战赛而构建的项目！</p></div></div>    
</body>
</html>