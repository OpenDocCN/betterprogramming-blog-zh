<html>
<head>
<title>Exploring Caching Techniques in React</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">探索React中的缓存技术</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/exploring-caching-techniques-in-react-d30bbb78d54d?source=collection_archive---------0-----------------------#2021-02-11">https://betterprogramming.pub/exploring-caching-techniques-in-react-d30bbb78d54d?source=collection_archive---------0-----------------------#2021-02-11</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="315c" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">如何使用记忆、上下文、使用记忆、使用状态和使用效果</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/010a1d9a15b325519b498d2399c4bfbd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*LT0jhp8UwZRahePKZ9bEpg.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">我们今天将创造什么！作者照片。</p></figure><p id="2062" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">在React中获取数据是一回事。存储和缓存这些数据是另一回事。可能性似乎是无穷无尽的，差异往往是微妙的，这使得选择正确的技术有时有点困难。</p><p id="f446" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">今天，我们将探索不同的技术，看看它们所有的细节和微妙之处。我应该用<code class="fe lu lv lw lx b">useMemo</code>还是记忆？我应该用<code class="fe lu lv lw lx b">useState</code>和一个上下文来存储数据吗？当我们完成后，您应该能够轻松地做出关于缓存数据的明智选择。你会了解所有的来龙去脉。</p><p id="0878" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">而且还有大量的动画gif。你还能希望什么？</p><p id="6bcc" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">我们开始吧！</p></div><div class="ab cl ly lz hx ma" role="separator"><span class="mb bw bk mc md me"/><span class="mb bw bk mc md me"/><span class="mb bw bk mc md"/></div><div class="im in io ip iq"><h1 id="e804" class="mf mg it bd mh mi mj mk ml mm mn mo mp jz mq ka mr kc ms kd mt kf mu kg mv mw bi translated">我们的数据</h1><p id="a65d" class="pw-post-body-paragraph ky kz it la b lb mx ju ld le my jx lg lh mz lj lk ll na ln lo lp nb lr ls lt im bi translated">在深入研究代码之前，我们可以快速浏览一下我们将在(大部分)组件中获取的数据。作为我们的API的文件如下所示:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nc nd l"/></div></figure><p id="7c30" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">当我们向项目中的路径<code class="fe lu lv lw lx b">/api/people</code>发出请求时，就会执行这段代码。如您所见，我们返回一个具有两个属性的对象:</p><ul class=""><li id="7c51" class="ne nf it la b lb lc le lf lh ng ll nh lp ni lt nj nk nl nm bi translated"><code class="fe lu lv lw lx b">randomNumber</code>:0-10000范围内的随机数。</li><li id="8d0d" class="ne nf it la b lb nn le no lh np ll nq lp nr lt nj nk nl nm bi translated"><code class="fe lu lv lw lx b">people</code>:一个有三个虚构名字的静态数组。</li></ul><p id="3917" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">属性将帮助我们可视化我们是否在前端渲染缓存的数据。继续读下去。很快就说得通了。</p><p id="1cb3" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">注意，我们通过使用<code class="fe lu lv lw lx b">setTimeout</code>模拟了一点网络延迟。</p><h2 id="fe66" class="ns mg it bd mh nt nu dn ml nv nw dp mp lh nx ny mr ll nz oa mt lp ob oc mv od bi translated">人员组件</h2><p id="194a" class="pw-post-body-paragraph ky kz it la b lb mx ju ld le my jx lg lh mz lj lk ll na ln lo lp nb lr ls lt im bi translated">当我们呈现来自API的数据时，我们将把它传递给一个名为<code class="fe lu lv lw lx b"><a class="ae oe" href="https://gitlab.com/gvanderput/gerard-caching-techniques/-/blob/master/components/PeopleRenderer.jsx" rel="noopener ugc nofollow" target="_blank">PeopleRenderer</a></code>的组件。看起来是这样的:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi of"><img src="../Images/0ed0eaa23b0c00ca863f43844f8790e2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1108/format:webp/1*pCw1cUWOuSuowUfpaBbI9g.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">PeopleRenderer组件。</p></figure><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi of"><img src="../Images/d6b95b5d9dc770bd32af8a31c55b0007.png" data-original-src="https://miro.medium.com/v2/resize:fit:1108/format:webp/1*CGi7Zu8F3rxfdfVMT-E6Pw.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">显示相同(缓存)数据的两个组件。</p></figure><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi og"><img src="../Images/598642fb6a8ddf47990087fea836c508.png" data-original-src="https://miro.medium.com/v2/resize:fit:1110/format:webp/1*iO-NeG3BNNx5brRx3kEjsg.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">呈现不同(非缓存)数据的两个组件。</p></figure><p id="12e9" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">说了这么多，让我们来看看第一个技巧。</p></div><div class="ab cl ly lz hx ma" role="separator"><span class="mb bw bk mc md me"/><span class="mb bw bk mc md me"/><span class="mb bw bk mc md"/></div><div class="im in io ip iq"><h1 id="ba2e" class="mf mg it bd mh mi mj mk ml mm mn mo mp jz mq ka mr kc ms kd mt kf mu kg mv mw bi translated">使用效果</h1><p id="d60b" class="pw-post-body-paragraph ky kz it la b lb mx ju ld le my jx lg lh mz lj lk ll na ln lo lp nb lr ls lt im bi translated">在我们的组件内部，我们可以使用<code class="fe lu lv lw lx b"><a class="ae oe" href="https://reactjs.org/docs/hooks-effect.html" rel="noopener ugc nofollow" target="_blank">useEffect</a></code>钩子来获取数据。然后我们可以使用<code class="fe lu lv lw lx b"><a class="ae oe" href="https://reactjs.org/docs/hooks-state.html" rel="noopener ugc nofollow" target="_blank">useState</a></code>将它存储在本地(组件内部):</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nc nd l"/></div></figure><p id="f7ce" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">通过传递一个空数组作为第二个参数(见第11行)，当我们的组件被挂载到DOM时，将执行<code class="fe lu lv lw lx b">useEffect</code>钩子——只有在那时。当我们的组件被重新渲染时，它不会再次执行。这是一个“执行一次”的钩子。</p><p id="2cf9" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">以这种方式使用<code class="fe lu lv lw lx b">useEffect</code>的一个警告是，当我们的DOM中有组件的多个实例时，它们都将单独获取数据(当它们被挂载时):</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi oh"><img src="../Images/8e6515045bf598920cb3b0177f92bb6b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1190/1*sIjJj7wyvEDMVZJPf48Fcw.gif"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">动画:组件分别获取数据。</p></figure><p id="ba83" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">这个技术没有错。有时候，这正是我们想要的。但在其他时候，我们可能希望获取一次数据，并通过缓存在所有其他实例中重用它。我们可以使用几种技术来实现这一点。</p></div><div class="ab cl ly lz hx ma" role="separator"><span class="mb bw bk mc md me"/><span class="mb bw bk mc md me"/><span class="mb bw bk mc md"/></div><div class="im in io ip iq"><h1 id="d8a4" class="mf mg it bd mh mi mj mk ml mm mn mo mp jz mq ka mr kc ms kd mt kf mu kg mv mw bi translated">记忆化</h1><p id="be55" class="pw-post-body-paragraph ky kz it la b lb mx ju ld le my jx lg lh mz lj lk ll na ln lo lp nb lr ls lt im bi translated">记忆化是一个非常简单的技术的花哨词。这意味着您创建了一个函数，每次调用该函数时，它都会在返回函数之前将函数调用的结果存储在缓存中。</p><p id="ada4" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">当这个<em class="oi">记忆化的</em>函数第一次被调用时，结果被计算(或者获取，或者你在函数体内做的任何事情)。在返回结果之前，您将它们存储在缓存中用输入参数创建的键下:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nc nd l"/></div></figure><p id="0c0d" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">创建这种样板代码会很快变得很麻烦，所以像<a class="ae oe" href="https://lodash.com/docs/4.17.15#memoize" rel="noopener ugc nofollow" target="_blank"> Lodash </a>和<a class="ae oe" href="https://underscorejs.org/#memoize" rel="noopener ugc nofollow" target="_blank">understand</a>这样的流行库提供了实用函数，您可以使用它们轻松地创建记忆化的函数:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nc nd l"/></div></figure><h2 id="110d" class="ns mg it bd mh nt nu dn ml nv nw dp mp lh nx ny mr ll nz oa mt lp ob oc mv od bi translated">利用记忆获取数据</h2><p id="7466" class="pw-post-body-paragraph ky kz it la b lb mx ju ld le my jx lg lh mz lj lk ll na ln lo lp nb lr ls lt im bi translated">我们可以在获取数据时利用这种技术。我们创建了一个<code class="fe lu lv lw lx b">getData</code>函数，该函数返回一个<code class="fe lu lv lw lx b">Promise</code>，当获取请求完成时，该函数被解析。我们记住这个<code class="fe lu lv lw lx b">Promise</code>:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nc nd l"/></div></figure><p id="2632" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">请注意，在这个例子中我们没有处理错误。这应该有自己的文章——特别是当我们使用记忆化时(被拒绝的<code class="fe lu lv lw lx b">Promise</code>也会被记忆化，这可能会有问题)。</p><p id="5901" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">现在我们可以用另一个看起来像这样的钩子替换我们的<code class="fe lu lv lw lx b">useEffect</code>:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nc nd l"/></div></figure><p id="7b64" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">由于<code class="fe lu lv lw lx b">getData</code>的结果被记忆，我们的组件在安装时都会收到相同的数据:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi oh"><img src="../Images/34ae655f676df8ce6a69501b164b02c9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1190/1*OqOTRCkSvFgaSjH1V1fQvw.gif"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">动画:我们的组件使用相同的记忆承诺。</p></figure><p id="47a7" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">同样值得一提的是，当我们打开<code class="fe lu lv lw lx b">memoize.tsx</code>页面时(在我们挂载组件的第一个实例之前)，数据已经被预取了。这是因为我们在页面顶部的一个单独的文件中定义了我们的<code class="fe lu lv lw lx b">getData</code>函数，而<code class="fe lu lv lw lx b">Promise</code>是在加载该文件时创建的。</p><p id="1f98" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">我们也可以通过给内存化函数的<code class="fe lu lv lw lx b">cache</code>属性分配一个新的<code class="fe lu lv lw lx b">Cache</code>来使内存化函数的缓存无效(清空):</p><pre class="kj kk kl km gt oj lx ok ol aw om bi"><span id="d2f2" class="ns mg it lx b gy on oo l op oq">getData.cache = new memoize.Cache();</span></pre><p id="e706" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">或者，您可以清除现有的缓存(它是一个<code class="fe lu lv lw lx b"><a class="ae oe" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Map" rel="noopener ugc nofollow" target="_blank">Map</a></code>实例):</p><pre class="kj kk kl km gt oj lx ok ol aw om bi"><span id="83f3" class="ns mg it lx b gy on oo l op oq">getData.cache.clear();</span></pre><p id="49e6" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">不过，这是特定于Lodash的功能。其他库需要其他解决方案。在这里，您可以看到使缓存失效的过程:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi oh"><img src="../Images/55c2cc93562d366e80f6dcc7d4f9268f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1190/1*Vnf6nV7_FS1eqen0RSd7hw.gif"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">动画:重置内存化的getData函数的缓存。</p></figure></div><div class="ab cl ly lz hx ma" role="separator"><span class="mb bw bk mc md me"/><span class="mb bw bk mc md me"/><span class="mb bw bk mc md"/></div><div class="im in io ip iq"><h1 id="8ac3" class="mf mg it bd mh mi mj mk ml mm mn mo mp jz mq ka mr kc ms kd mt kf mu kg mv mw bi translated">反应上下文</h1><p id="50d1" class="pw-post-body-paragraph ky kz it la b lb mx ju ld le my jx lg lh mz lj lk ll na ln lo lp nb lr ls lt im bi translated">另一个流行且讨论广泛(但经常被误解)的工具是<a class="ae oe" href="https://reactjs.org/docs/context.html" rel="noopener ugc nofollow" target="_blank"> React Context </a>。我再次声明，它不会取代像Redux这样的工具。它不是一个状态管理工具。马克·埃里克森正在网上进行一场艰苦的战斗，并不断解释原因。我强烈推荐阅读他最近关于这个话题的文章。</p><p id="46d7" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">如果你真的感兴趣，也可以考虑阅读我的相关文章:</p><div class="ot ou gp gr ov ow"><a href="https://medium.com/swlh/react-hooks-and-redux-are-friends-not-enemies-cb0ecfa613ed" rel="noopener follow" target="_blank"><div class="ox ab fo"><div class="oy ab oz cl cj pa"><h2 class="bd iu gy z fp pb fr fs pc fu fw is bi translated">React Hooks和Redux是朋友，不是敌人</h2><div class="pd l"><h3 class="bd b gy z fp pb fr fs pc fu fw dk translated">他们相处得很好，目的不一样。</h3></div><div class="pe l"><p class="bd b dl z fp pb fr fs pc fu fw dk translated">medium.com</p></div></div><div class="pf l"><div class="pg l ph pi pj pf pk ks ow"/></div></div></a></div><p id="e435" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">那么什么是语境呢？这是一种将数据注入组件树的机制。如果您有一些数据，那么您可以用一个<code class="fe lu lv lw lx b">useState</code>钩子将这些数据存储在组件层次结构中较高的一个组件中。然后，您可以使用上下文<code class="fe lu lv lw lx b">Provider</code>将数据注入到您的树中，之后您可以读取(消费)下面任何组件中的数据。</p><p id="af2a" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">举个例子比较好理解。首先，创建新的上下文:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nc nd l"/></div></figure><p id="6bd6" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">然后我们用上下文<code class="fe lu lv lw lx b">Provider</code>包装呈现您的<code class="fe lu lv lw lx b">People</code>组件的组件:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nc nd l"/></div></figure><p id="9a0c" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">在第12行，我们可以渲染任何我们想要的东西。在某些时候，在树的更下面，我们将呈现我们的<code class="fe lu lv lw lx b">People</code>组件:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nc nd l"/></div></figure><p id="a3c2" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">我们可以通过使用一个<code class="fe lu lv lw lx b"><a class="ae oe" href="https://reactjs.org/docs/hooks-reference.html#usecontext" rel="noopener ugc nofollow" target="_blank">useContext</a></code>钩子来使用来自<code class="fe lu lv lw lx b">Provider</code>的值。结果看起来像这样:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi oh"><img src="../Images/c39741607b1e5904aed53b195c807aca.png" data-original-src="https://miro.medium.com/v2/resize:fit:1190/1*Dxd_0uv_1J9KysLM3xJXCA.gif"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">动画:从上下文中使用数据。</p></figure><p id="1f01" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">请注意这里的一个重要区别！在上面动画的结尾，我们按下按钮“设置新种子”这样，存储在我们的上下文<code class="fe lu lv lw lx b">Provider</code>中的数据被重新获取。完成后(750毫秒后)，新获取的数据成为我们的<code class="fe lu lv lw lx b">Provider</code>的新值，我们的<code class="fe lu lv lw lx b">People</code>组件被重新渲染。正如你所看到的，它们都<em class="oi">共享</em>相同的数据。</p><p id="2e00" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">这与我们上面看的记忆化例子有很大的不同。在这种情况下，每个组件通过使用<code class="fe lu lv lw lx b">useState</code>存储它自己的记忆数据副本。在这种情况下，通过使用和消费上下文，它们不存储副本，而只使用对同一对象的引用。这就是为什么当我们更新我们的<code class="fe lu lv lw lx b">Provider</code>中的值时，所有的组件都用相同的数据更新。</p></div><div class="ab cl ly lz hx ma" role="separator"><span class="mb bw bk mc md me"/><span class="mb bw bk mc md me"/><span class="mb bw bk mc md"/></div><div class="im in io ip iq"><h1 id="2871" class="mf mg it bd mh mi mj mk ml mm mn mo mp jz mq ka mr kc ms kd mt kf mu kg mv mw bi translated">使用备忘录</h1><p id="0b67" class="pw-post-body-paragraph ky kz it la b lb mx ju ld le my jx lg lh mz lj lk ll na ln lo lp nb lr ls lt im bi translated">最后但同样重要的是，快速看一下<code class="fe lu lv lw lx b"><a class="ae oe" href="https://reactjs.org/docs/hooks-reference.html#usememo" rel="noopener ugc nofollow" target="_blank">useMemo</a></code>。这个钩子不同于我们看到的其他技术，因为它只是一种本地级别的缓存形式:在组件的一个实例中。您不能使用<code class="fe lu lv lw lx b">useMemo</code>在几个组件之间共享数据——至少在没有诸如prop-drilling或依赖注入(例如，React Context)之类的变通方法的情况下。</p><p id="385e" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated"><code class="fe lu lv lw lx b">useMemo</code>是一个优化工具。您可以使用它来防止每次重新渲染组件时重新计算值。文档<a class="ae oe" href="https://reactjs.org/docs/hooks-reference.html#usememo" rel="noopener ugc nofollow" target="_blank">比我能更好地解释</a>，但是让我们看一个例子:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nc nd l"/></div></figure><ul class=""><li id="5af4" class="ne nf it la b lb lc le lf lh ng ll nh lp ni lt nj nk nl nm bi translated"><code class="fe lu lv lw lx b">getRnd</code>(第2行):返回0-10000范围内的随机数的函数。</li><li id="5fb5" class="ne nf it la b lb nn le no lh np ll nq lp nr lt nj nk nl nm bi translated"><code class="fe lu lv lw lx b">age</code>(第4行):用<code class="fe lu lv lw lx b">useState</code>存储代表年龄的数字。</li><li id="1abf" class="ne nf it la b lb nn le no lh np ll nq lp nr lt nj nk nl nm bi translated"><code class="fe lu lv lw lx b">randomNumber</code>(第5行):用<code class="fe lu lv lw lx b">useState</code>存储一个随机数。</li></ul><p id="fff2" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">最后，我们在第7行使用<code class="fe lu lv lw lx b">useMemo</code>。我们记忆函数调用的结果，并将结果存储在一个名为<code class="fe lu lv lw lx b">pow</code>的变量中。我们的函数返回一个数字，它是<code class="fe lu lv lw lx b">age</code>的2次方加上一个随机数的和。它依赖于<code class="fe lu lv lw lx b">age</code>变量，这就是为什么我们将它传递给<code class="fe lu lv lw lx b">useMemo</code>调用的依赖参数。</p><p id="f70e" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">该函数仅在年龄值改变时执行。如果我们的组件重新呈现并且<code class="fe lu lv lw lx b">age</code>的值没有改变，<code class="fe lu lv lw lx b">useMemo</code>将简单地返回记忆的结果。</p><p id="a991" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">在这个例子中，<code class="fe lu lv lw lx b">pow</code>的计算并不是很复杂，但是你可以想象当我们的函数比较重，我们必须经常重新渲染我们的组件时，这样做的好处。</p><p id="aeb6" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">最后两个动画将说明发生了什么。首先，我们更新<code class="fe lu lv lw lx b">randomNumber</code>并且我们不影响<code class="fe lu lv lw lx b">age</code>的值。因此，我们看到<code class="fe lu lv lw lx b">useMemo</code>在起作用(当组件被重新渲染时，<code class="fe lu lv lw lx b">pow</code>的值不会改变)。每次我们单击按钮，我们的组件都会重新呈现:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi oh"><img src="../Images/7a35a7a122a940bd2a95c029f021e7e8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1190/1*9RRMNqyBrwKQxLVDFwLguQ.gif"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">动画:许多重新渲染，但权力的价值是用记忆。</p></figure><p id="82db" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">然而，如果我们改变<code class="fe lu lv lw lx b">age</code>的值，那么<code class="fe lu lv lw lx b">pow</code>也会被重新呈现，因为我们的<code class="fe lu lv lw lx b">useMemo</code>调用依赖于<code class="fe lu lv lw lx b">age</code>的值:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi oh"><img src="../Images/5f0ac23e131c98c634e9b73e1233c107.png" data-original-src="https://miro.medium.com/v2/resize:fit:1190/1*lIHfc1smxTpCulGsPtOXvw.gif"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">动画:当我们更新依赖关系时，我们的记忆值也随之更新。</p></figure></div><div class="ab cl ly lz hx ma" role="separator"><span class="mb bw bk mc md me"/><span class="mb bw bk mc md me"/><span class="mb bw bk mc md"/></div><div class="im in io ip iq"><h1 id="e9ee" class="mf mg it bd mh mi mj mk ml mm mn mo mp jz mq ka mr kc ms kd mt kf mu kg mv mw bi translated">结论</h1><p id="09fc" class="pw-post-body-paragraph ky kz it la b lb mx ju ld le my jx lg lh mz lj lk ll na ln lo lp nb lr ls lt im bi translated">JavaScript中有许多缓存数据的技术和实用程序。本文只是触及了表面，但我希望它能提供一些您可以在开发之旅中随身携带的知识。</p><p id="2a30" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">本文中使用的所有代码都可以在我位于<a class="ae oe" href="https://gitlab.com/gvanderput/gerard-caching-techniques" rel="noopener ugc nofollow" target="_blank"> GitLab </a>的知识库中找到。</p><p id="c0b6" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">感谢您的宝贵时间！</p></div></div>    
</body>
</html>