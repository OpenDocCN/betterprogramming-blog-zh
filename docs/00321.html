<html>
<head>
<title>Crafting a Command Line Experience That Developers Love</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">打造开发人员喜爱的命令行体验</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/crafting-a-command-line-experience-that-developers-love-68657b20c28d?source=collection_archive---------0-----------------------#2019-04-10">https://betterprogramming.pub/crafting-a-command-line-experience-that-developers-love-68657b20c28d?source=collection_archive---------0-----------------------#2019-04-10</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="59bd" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">设计出色的CLI体验</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/a671f82c0c63a932a9244e8a079b716b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*TL5PEIK7LoHaq7S0YvBP-A.png"/></div></div></figure><p id="f4db" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">如果您打算构建一个高度可用的开发人员工具，不言而喻，一个合适的CLI来与您的API交互是至关重要的。由于Zeit和Heroku已经通过对命令行体验的最佳实践进行广泛的研究，为这些类型的开发人员工具定下了基调，我们通过挖掘他们的发现开始了我们的探索。</p><p id="78c5" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">由于<a class="ae lq" href="https://www.npmjs.com/package/getstream-cli" rel="noopener ugc nofollow" target="_blank">流客户端</a>目前处于公测阶段，我们从研究中发现的方法和理念，以及我们自己发掘的方法和理念，在我们的脑海中是新鲜的。我们想花几分钟时间概述一下我们在其他CLI工具中发现的最佳实践，以及开发人员在构建合适的CLI时的需求。</p><p id="0645" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">下面是我们将如何着手构建另一个CLI的逐步解释，以及我们为什么选择这样做的一些解释。</p></div><div class="ab cl lr ls hx lt" role="separator"><span class="lu bw bk lv lw lx"/><span class="lu bw bk lv lw lx"/><span class="lu bw bk lv lw"/></div><div class="im in io ip iq"><h1 id="655d" class="ly lz it bd ma mb mc md me mf mg mh mi jz mj ka mk kc ml kd mm kf mn kg mo mp bi translated">选择</h1><p id="2b15" class="pw-post-body-paragraph ku kv it kw b kx mq ju kz la mr jx lc ld ms lf lg lh mt lj lk ll mu ln lo lp im bi translated">大量开源项目的出现有助于促进CLI的搭建和整体开发。</p><p id="bb6d" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">除了我们在Stream的后端基础设施(主要用Go编写)之外，我们的许多工具都使用JavaScript它在前端和后端项目之间的灵活性、对它的大量开源贡献、它的全球存在和它的易用性(出于上述原因)都使它成为创建一个低门槛的强大工具的显而易见的选择。</p><p id="730d" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">同样，如果您开始着手构建CLI，将有几十个用JavaScript构建的开源项目可以帮助您入门。公平地说，当我们开始考虑构建一个CLI时，<a class="ae lq" href="https://www.npmjs.com/package/commander" rel="noopener ugc nofollow" target="_blank"> Commander </a>和<a class="ae lq" href="https://www.npmjs.com/package/caporal" rel="noopener ugc nofollow" target="_blank">下士</a>几乎在每个搜索中都登上了Google和npm的榜首，但我们想要更强大的东西——一个经过战斗考验的项目，一次性提供我们需要的一切，而不是一个简单解析参数并随命令传递的包。</p><p id="10a2" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">那时我们发现了奥克里夫。</p></div><div class="ab cl lr ls hx lt" role="separator"><span class="lu bw bk lv lw lx"/><span class="lu bw bk lv lw lx"/><span class="lu bw bk lv lw"/></div><div class="im in io ip iq"><h1 id="1c4f" class="ly lz it bd ma mb mc md me mf mg mh mi jz mj ka mk kc ml kd mm kf mn kg mo mp bi translated">奥克里夫</h1><p id="3ba4" class="pw-post-body-paragraph ku kv it kw b kx mq ju kz la mr jx lc ld ms lf lg lh mt lj lk ll mu ln lo lp im bi translated">oclif是一个基于JavaScript的CLI框架，由Heroku背后的团队开源。它打包了预建的功能，甚至通过使用插件来提供可扩展性。</p><p id="80a5" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">乍看之下，当我们研究oclif时，有几个突出的主要特性:</p><ul class=""><li id="a0a0" class="mv mw it kw b kx ky la lb ld mx lh my ll mz lp na nb nc nd bi translated">多命令支持</li><li id="4a3d" class="mv mw it kw b kx ne la nf ld ng lh nh ll ni lp na nb nc nd bi translated">命令参数或标志的自动解析</li><li id="5903" class="mv mw it kw b kx ne la nf ld ng lh nh ll ni lp na nb nc nd bi translated">配置支持</li><li id="dd50" class="mv mw it kw b kx ne la nf ld ng lh nh ll ni lp na nb nc nd bi translated">自动记录代码库</li></ul><p id="ae39" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">最终，这些特性的可用性也是我们选择使用oclif作为我们在Stream的CLI工具基础的主要原因。</p><p id="e4fd" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">记住，这些只是oclif自带的一些内置特性。要获得全面的选项列表，我们建议在这里看一下官方oclif文档<a class="ae lq" href="https://oclif.io/docs" rel="noopener ugc nofollow" target="_blank">。</a></p></div><div class="ab cl lr ls hx lt" role="separator"><span class="lu bw bk lv lw lx"/><span class="lu bw bk lv lw lx"/><span class="lu bw bk lv lw"/></div><div class="im in io ip iq"><h1 id="50a0" class="ly lz it bd ma mb mc md me mf mg mh mi jz mj ka mk kc ml kd mm kf mn kg mo mp bi translated">多命令支持与单命令支持</h1><p id="4388" class="pw-post-body-paragraph ku kv it kw b kx mq ju kz la mr jx lc ld ms lf lg lh mt lj lk ll mu ln lo lp im bi translated">重要的是要注意，如果您有一个单一的端点或者您正在调用的方法，那么您所需要的就是单一命令(例如，<code class="fe nj nk nl nm b">grep</code>)支持。如果您正在开发一个更大的CLI工具，比如我们为Stream创建的工具，您可能需要选择多命令支持(例如，<code class="fe nj nk nl nm b">npm</code>或<code class="fe nj nk nl nm b">git</code>)。以下是对这种差异的快速分析:</p><p id="0550" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">单身:</p><pre class="kj kk kl km gt nn nm no np aw nq bi"><span id="c466" class="nr lz it nm b gy ns nt l nu nv">$ stream --api_key=foo --api_secret=bar --name=baz --email=qux</span></pre><p id="8bab" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">多:</p><pre class="kj kk kl km gt nn nm no np aw nq bi"><span id="e7b5" class="nr lz it nm b gy ns nt l nu nv">$ stream config:set --api_key=foo --api_secret=bar --name=baz --email=qux</span></pre><p id="db04" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">虽然它们看起来相似，但这两个选项之间有一个关键的区别:单个命令不允许子命令，或者我们喜欢称之为作用域。这仅仅意味着复杂的或嵌套的命令在单一命令支持下是不可能的。</p><p id="6e91" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">无论配置如何，这两种类型的命令都需要参数。如果没有参数，它就不是CLI。多命令支持的一个优点是，它用冒号分隔调用，允许您组织事情。更好的是，您可以使用嵌套目录来组织您的目录结构，如<a class="ae lq" href="https://github.com/GetStream/stream-cli/tree/master/src/commands" rel="noopener ugc nofollow" target="_blank"> GitHub </a>上的src代码所示。</p><p id="ce3b" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">有时候在开始的时候有点难以概念化，但是，一旦你第一次动手创建了一个CLI，它就会变得清晰明了。</p></div><div class="ab cl lr ls hx lt" role="separator"><span class="lu bw bk lv lw lx"/><span class="lu bw bk lv lw lx"/><span class="lu bw bk lv lw"/></div><div class="im in io ip iq"><h1 id="c366" class="ly lz it bd ma mb mc md me mf mg mh mi jz mj ka mk kc ml kd mm kf mn kg mo mp bi translated">自动解析</h1><p id="6229" class="pw-post-body-paragraph ku kv it kw b kx mq ju kz la mr jx lc ld ms lf lg lh mt lj lk ll mu ln lo lp im bi translated">在幕后，oclif处理解析传入的命令行参数。一般来说，使用Node.js，您必须从process.argv提供的数组中提取参数。虽然这并不特别困难，但肯定容易出错……尤其是当您提出验证或转换为字符串/布尔值的要求时。</p><p id="fb88" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">如果您不打算使用oclif来为您处理解析，而只是需要进行简单的设置，我们推荐使用<a class="ae lq" href="https://www.npmjs.com/package/minimist" rel="noopener ugc nofollow" target="_blank">minimit</a>，这是一个专门用于命令行参数解析的包。</p></div><div class="ab cl lr ls hx lt" role="separator"><span class="lu bw bk lv lw lx"/><span class="lu bw bk lv lw lx"/><span class="lu bw bk lv lw"/></div><div class="im in io ip iq"><h1 id="e2de" class="ly lz it bd ma mb mc md me mf mg mh mi jz mj ka mk kc ml kd mm kf mn kg mo mp bi translated">配置支持</h1><p id="032f" class="pw-post-body-paragraph ku kv it kw b kx mq ju kz la mr jx lc ld ms lf lg lh mt lj lk ll mu ln lo lp im bi translated">对于任何服务器端集成，无论是API还是SDK，您(希望)都可能必须提供某种令牌(出于安全和身份原因)。</p><p id="eb38" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">对于我们的集成，我们需要将用户的配置凭证(例如，API密钥和密码、名称和电子邮件)保存在用户计算机上的安全位置。如果不持久存储这种类型的数据，我们就必须确保每个对Stream的API调用都包含正确的凭证，而且，让我们面对现实吧，没有人希望每个命令都传递参数。</p><p id="3d16" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">为了解决这个问题，我们利用oclif的内置支持来管理配置文件，方法是将用户凭证存储在机器上config目录下的一个<code class="fe nj nk nl nm b">config.js</code>文件中。通常，配置目录在Unix机器上驻留在<code class="fe nj nk nl nm b">~/.config/stream-cli</code>中，在Windows机器上驻留在<code class="fe nj nk nl nm b">%LOCALAPPDATA%\stream-cli</code>中。在oclif的帮助下，我们不必担心检测用户的机器类型，因为他们在幕后处理这种区别，使用<code class="fe nj nk nl nm b">this.config.configDir</code>很容易进入您的命令类。</p><p id="08ef" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">了解了这一点，我们就能够使用<a class="ae lq" href="https://www.npmjs.com/package/fs-extra" rel="noopener ugc nofollow" target="_blank"> fs-extra包</a>创建一个小工具来收集和存储必要的凭证。这里看一下代码<a class="ae lq" href="https://github.com/GetStream/stream-cli/blob/master/src/utils/config/credentials.js" rel="noopener ugc nofollow" target="_blank">。</a></p><p id="68d2" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">Oclif中配置选项的文档可以在<a class="ae lq" href="https://oclif.io/docs/config" rel="noopener ugc nofollow" target="_blank">这里</a>找到。</p></div><div class="ab cl lr ls hx lt" role="separator"><span class="lu bw bk lv lw lx"/><span class="lu bw bk lv lw lx"/><span class="lu bw bk lv lw"/></div><div class="im in io ip iq"><h1 id="4541" class="ly lz it bd ma mb mc md me mf mg mh mi jz mj ka mk kc ml kd mm kf mn kg mo mp bi translated">自动记录代码库</h1><p id="1101" class="pw-post-body-paragraph ku kv it kw b kx mq ju kz la mr jx lc ld ms lf lg lh mt lj lk ll mu ln lo lp im bi translated">我们很高兴(也很惊讶)地发现oclif支持自动记录命令。如果没有这种功能，我们将不得不在每次进行更改时手动更改我们的<a class="ae lq" href="https://github.com/GetStream/stream-cli/blob/master/README.md" rel="noopener ugc nofollow" target="_blank"> README </a>和底层文档，例如添加/删除命令参数、更改命令名称或修改命令子目录中的目录结构。您可以想象在像Stream CLI这样的大型CLI项目中维护它有多困难。</p><p id="c0c5" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">在<a class="ae lq" href="https://www.npmjs.com/package/@oclif/dev-cli" rel="noopener ugc nofollow" target="_blank"> @oclif/dev-cli </a>包的帮助下，我们能够将<a class="ae lq" href="https://github.com/GetStream/stream-cli/blob/master/package.json#L30" rel="noopener ugc nofollow" target="_blank">单个脚本</a>添加到我们的package.json文件中，该文件在构建过程中运行。该命令扫描目录结构并神奇地生成文档，如这里的<a class="ae lq" href="https://github.com/GetStream/stream-cli/blob/master/docs/chat.md" rel="noopener ugc nofollow" target="_blank">所示</a>。</p></div><div class="ab cl lr ls hx lt" role="separator"><span class="lu bw bk lv lw lx"/><span class="lu bw bk lv lw lx"/><span class="lu bw bk lv lw"/></div><div class="im in io ip iq"><h1 id="1ce6" class="ly lz it bd ma mb mc md me mf mg mh mi jz mj ka mk kc ml kd mm kf mn kg mo mp bi translated">交互式和原始参数支持</h1><p id="353f" class="pw-post-body-paragraph ku kv it kw b kx mq ju kz la mr jx lc ld ms lf lg lh mt lj lk ll mu ln lo lp im bi translated">有时，当通过CLI工具调用一个命令时，您可能最不愿意占用的就是该命令所需的所有参数，尤其是当参数数量很大时。虽然您总是可以使用— help标志来打印所需的参数，但有时最好提供一个交互式提示，如果所提供的标志中缺少这些信息，它会要求用户提供各种信息。</p><p id="f902" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">例如，不要调用:</p><pre class="kj kk kl km gt nn nm no np aw nq bi"><span id="3939" class="nr lz it nm b gy ns nt l nu nv">$ stream config:set --api_key=foo --api_secret=bar --name=baz --email=qux</span></pre><p id="62a9" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">用户可以调用(不传递任何参数):</p><pre class="kj kk kl km gt nn nm no np aw nq bi"><span id="6b23" class="nr lz it nm b gy ns nt l nu nv">$ stream config:set</span></pre><p id="9024" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">系统会提示他们:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nw"><img src="../Images/c85a76bcdb0f7b21a5711fb6aac784d5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ZjUkckupL0AiaE9pBD0feg.png"/></div></div></figure><p id="b056" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">有几个提示用户的选项，我们发现<a class="ae lq" href="https://www.npmjs.com/package/enquirer" rel="noopener ugc nofollow" target="_blank"> Enquirer </a>是最容易使用的软件包。虽然这个包在功能上与<a class="ae lq" href="https://www.npmjs.com/package/inquirer" rel="noopener ugc nofollow" target="_blank"> Inquirer </a>相似，但Enquirer API更宽容，也更容易使用。</p><p id="d927" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">如果可能的话，尝试在所有多参数命令上应用这种提示样式的功能是很重要的。但是，一定要检查这些标志，以确保如果用户已经传递了信息，您不会提示用户输入信息。例如:</p><pre class="kj kk kl km gt nn nm no np aw nq bi"><span id="ee5d" class="nr lz it nm b gy ns nt l nu nv">if (!flags.name || !flags.email || !flags.key || !flags.secret) {<br/>    const res = await prompt([<br/>        {<br/>            type: 'input',<br/>            name: 'name',<br/>            message: `What is your full name?`,<br/>            required: true,<br/>        },<br/>        {<br/>            type: 'input',<br/>            name: 'email',<br/>            message: `What is your email address associated with Stream?`,<br/>            required: true,<br/>        },<br/>        {<br/>            type: 'input',<br/>            name: 'key',<br/>            message: `What is your Stream API key?`,<br/>            required: true,<br/>        },<br/>        {<br/>            type: 'password',<br/>            name: 'secret',<br/>            message: `What is your Stream API secret?`,<br/>            required: true,<br/>        },<br/>    ]);<br/><br/>    for (const key in res) {<br/>        if (res.hasOwnProperty(key)) {<br/>            flags[key] = res[key];<br/>        }<br/>    }<br/>}</span></pre><p id="70a6" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">请注意我们是如何检查标志并仅在标志不存在时显示提示的。</p></div><div class="ab cl lr ls hx lt" role="separator"><span class="lu bw bk lv lw lx"/><span class="lu bw bk lv lw lx"/><span class="lu bw bk lv lw"/></div><div class="im in io ip iq"><h1 id="aa72" class="ly lz it bd ma mb mc md me mf mg mh mi jz mj ka mk kc ml kd mm kf mn kg mo mp bi translated">把它变漂亮</h1><p id="1acc" class="pw-post-body-paragraph ku kv it kw b kx mq ju kz la mr jx lc ld ms lf lg lh mt lj lk ll mu ln lo lp im bi translated">命令行通常被认为是黑色背景上平淡无奇的绿色和白色文本。新闻快讯:实际上没有什么可以阻止你让你的CLI脱颖而出。事实上，开发人员喜欢在命令行中引入颜色——颜色有助于将错误与成功消息、事件/时间戳等区分开来。</p><p id="796d" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">如果你想让事情变得漂亮，<a class="ae lq" href="https://www.npmjs.com/package/chalk" rel="noopener ugc nofollow" target="_blank">粉笔</a>就算不是最好的，也是一个很好的选择。它提供了一个扩展的API，以很少甚至没有开销的方式向您的CLI添加颜色。</p><p id="555c" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">要将Chalk集成到您的CLI中:</p><pre class="kj kk kl km gt nn nm no np aw nq bi"><span id="78d1" class="nr lz it nm b gy ns nt l nu nv">import chalk from ‘chalk’;</span></pre><p id="ab2b" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">然后，用粉笔方法、颜色和可选的样式(粗体、斜体等)包裹你的线。)为您的输出添加一些特色:</p><pre class="kj kk kl km gt nn nm no np aw nq bi"><span id="388d" class="nr lz it nm b gy ns nt l nu nv">this.log(`This is a response and it’s ${chalk.blue.bold.italic(‘bold, blue, and italicized’)}`);</span></pre></div><div class="ab cl lr ls hx lt" role="separator"><span class="lu bw bk lv lw lx"/><span class="lu bw bk lv lw lx"/><span class="lu bw bk lv lw"/></div><div class="im in io ip iq"><h1 id="4eab" class="ly lz it bd ma mb mc md me mf mg mh mi jz mj ka mk kc ml kd mm kf mn kg mo mp bi translated">使用表格进行大规模回复</h1><p id="3c04" class="pw-post-body-paragraph ku kv it kw b kx mq ju kz la mr jx lc ld ms lf lg lh mt lj lk ll mu ln lo lp im bi translated">让我们面对现实吧，没有一个开发人员愿意梳理你的API返回的大量响应。在这种情况下，总是返回一些有意义且易于阅读的内容是很重要的。为用户提供易于理解的输出，我们最喜欢的方法之一是使用表格:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nw"><img src="../Images/6a0470983653797605396099c3afd9cd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*VF0ddjEFEUb69CeFb-knxg.png"/></div></div></figure><p id="82cc" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">在上面的例子中，我们选择了<a class="ae lq" href="https://www.npmjs.com/package/cli-table" rel="noopener ugc nofollow" target="_blank"> cli-table包</a>来帮助显示表格中的数据，因为它提供了一个易于使用且灵活的API，支持以下内容:</p><ul class=""><li id="70ee" class="mv mw it kw b kx ky la lb ld mx lh my ll mz lp na nb nc nd bi translated">垂直和水平显示</li><li id="b356" class="mv mw it kw b kx ne la nf ld ng lh nh ll ni lp na nb nc nd bi translated">文本/背景颜色支持</li><li id="647a" class="mv mw it kw b kx ne la nf ld ng lh nh ll ni lp na nb nc nd bi translated">带填充的文本对齐方式(左对齐、居中、右对齐)</li><li id="1471" class="mv mw it kw b kx ne la nf ld ng lh nh ll ni lp na nb nc nd bi translated">自定义列宽支持</li><li id="5b66" class="mv mw it kw b kx ne la nf ld ng lh nh ll ni lp na nb nc nd bi translated">基于预定义的宽度自动截断</li></ul></div><div class="ab cl lr ls hx lt" role="separator"><span class="lu bw bk lv lw lx"/><span class="lu bw bk lv lw lx"/><span class="lu bw bk lv lw"/></div><div class="im in io ip iq"><h1 id="8952" class="ly lz it bd ma mb mc md me mf mg mh mi jz mj ka mk kc ml kd mm kf mn kg mo mp bi translated">用Bash和jq打印用于解析的JSON</h1><p id="a315" class="pw-post-body-paragraph ku kv it kw b kx mq ju kz la mr jx lc ld ms lf lg lh mt lj lk ll mu ln lo lp im bi translated">提供CLI的好处在于它既可以被用户调用，也可以被脚本调用。创建一个高度平易近人和可用的工具的一部分是默认的沟通，立即有意义的用户。也就是说，脚本允许一种不干涉的方法，这在用户想要运行一组命令而不是发出一次性命令时特别有用。</p><p id="fd39" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">虽然Stream CLI默认返回用户友好的(并且人类可读的)输出(请参见Make It Pretty and Use Tables for Large Responses ),但是我们知道在运行脚本时，您可能希望得到详细的响应，而不是人类可读的消息。为了访问原始响应数据，我们添加了一个<code class="fe nj nk nl nm b">--json</code>标志，允许用户将原始有效负载指定为响应输出的JSON。</p><p id="9c5d" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">下面是一个简单的例子，展示了如何从Stream CLI获取用户的凭证，将输出直接传送到一个轻量级且灵活的命令行JSON处理器<a class="ae lq" href="https://stedolan.github.io/jq/" rel="noopener ugc nofollow" target="_blank"> jq </a>:</p><pre class="kj kk kl km gt nn nm no np aw nq bi"><span id="0e7d" class="nr lz it nm b gy ns nt l nu nv">#! /bin/bash<br/><br/>run=$(stream config:get --json)<br/><br/>name=$(jq --raw-output '.name' &lt;&lt;&lt; "${run}")<br/>email=$(jq --raw-output '.email' &lt;&lt;&lt; "${run}")<br/>apiKey=$(jq --raw-output '.apiKey' &lt;&lt;&lt; "${run}")<br/>apiSecret=$(jq --raw-output '.apiSecret' &lt;&lt;&lt; "${run}")<br/><br/>echo $name<br/>echo $email<br/>echo $apiKey<br/>echo $apiSecret</span></pre><p id="2b69" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">我们发现，如果用户想要建立他们的聊天基础设施、提供用户和权限等，提供该功能对于流聊天特别有用。无需使用底层的REST API。</p></div><div class="ab cl lr ls hx lt" role="separator"><span class="lu bw bk lv lw lx"/><span class="lu bw bk lv lw lx"/><span class="lu bw bk lv lw"/></div><div class="im in io ip iq"><h1 id="1c6d" class="ly lz it bd ma mb mc md me mf mg mh mi jz mj ka mk kc ml kd mm kf mn kg mo mp bi translated">出版</h1><p id="d27f" class="pw-post-body-paragraph ku kv it kw b kx mq ju kz la mr jx lc ld ms lf lg lh mt lj lk ll mu ln lo lp im bi translated">发布一个CLI可能看起来令人望而生畏，但是它与在npm上发布任何其他包没有什么不同。基本步骤如下:</p><ol class=""><li id="3ce9" class="mv mw it kw b kx ky la lb ld mx lh my ll mz lp nx nb nc nd bi translated">使用<a class="ae lq" href="https://www.npmjs.com/package/@oclif/dev-cli" rel="noopener ugc nofollow" target="_blank"> @oclif/dev-cli </a>包提供的工具更新<code class="fe nj nk nl nm b">oclif.manifest.json</code>文件。该文件扫描目录，并使用CLI的更新版本以及用户可用的所有命令更新清单文件。清单文件可以通过从命令行调用<code class="fe nj nk nl nm b">rm -f oclif.manifest.json &amp;&amp; oclif-dev manifest</code>来更新。</li><li id="b77b" class="mv mw it kw b kx ne la nf ld ng lh nh ll ni lp nx nb nc nd bi translated">更新文档以反映对命令所做的任何更改。这也是一个由<a class="ae lq" href="https://www.npmjs.com/package/@oclif/dev-cli" rel="noopener ugc nofollow" target="_blank"> @oclif/dev-cli </a>包提供的工具，可以使用<code class="fe nj nk nl nm b">oclif-dev readme --multi</code>运行(或者如果您运行的是单命令cli，可以使用<code class="fe nj nk nl nm b">--single</code>)。</li><li id="1632" class="mv mw it kw b kx ne la nf ld ng lh nh ll ni lp nx nb nc nd bi translated">使用version命令(例如<code class="fe nj nk nl nm b">npm version prerelease</code>)来提升npm版本。关于<code class="fe nj nk nl nm b">npm version</code>命令的完整文档可以在<a class="ae lq" href="https://docs.npmjs.com/cli/version.html" rel="noopener ugc nofollow" target="_blank">这里</a>找到。</li><li id="4b5e" class="mv mw it kw b kx ne la nf ld ng lh nh ll ni lp nx nb nc nd bi translated">使用<code class="fe nj nk nl nm b">npm publish</code>命令将发布发布到npm。</li></ol><p id="9697" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">然后，用户可以使用npm或yarn全局安装CLI:</p><pre class="kj kk kl km gt nn nm no np aw nq bi"><span id="96a4" class="nr lz it nm b gy ns nt l nu nv">npm -g install &lt;YOUR_CLI_PACKAGE&gt;</span></pre><p id="b5ff" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">或者:</p><pre class="kj kk kl km gt nn nm no np aw nq bi"><span id="4ae6" class="nr lz it nm b gy ns nt l nu nv">yarn global add &lt;YOUR_CLI_PACKAGE&gt;</span></pre><p id="cfd8" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">如果您需要以tarball的形式分发您的CLI，我们建议查看由<a class="ae lq" href="https://www.npmjs.com/package/@oclif/dev-cli" rel="noopener ugc nofollow" target="_blank"> @oclif/dev-cli </a>包提供的oclif-dev pack命令。这个命令将允许您将包部署到Homebrew和其他特定于操作系统的包管理器，或者简单地在系统上独立运行它们。</p></div><div class="ab cl lr ls hx lt" role="separator"><span class="lu bw bk lv lw lx"/><span class="lu bw bk lv lw lx"/><span class="lu bw bk lv lw"/></div><div class="im in io ip iq"><h1 id="8128" class="ly lz it bd ma mb mc md me mf mg mh mi jz mj ka mk kc ml kd mm kf mn kg mo mp bi translated">关键要点</h1><p id="97f1" class="pw-post-body-paragraph ku kv it kw b kx mq ju kz la mr jx lc ld ms lf lg lh mt lj lk ll mu ln lo lp im bi translated">如果你想深入了解Stream CLI背后的完整源代码，你可以在这里找到开源的GitHub repo<a class="ae lq" href="https://github.com/getstream/stream-cli" rel="noopener ugc nofollow" target="_blank"/>。虽然这篇文章中的关键要点并不是我们建议的最佳实践的详尽列表，但我们确实希望您在阅读完这篇文章后，能够学到一些适用于您的CLI的额外知识。总结一下我们在这一努力中的主要收获:</p><ul class=""><li id="0aca" class="mv mw it kw b kx ky la lb ld mx lh my ll mz lp na nb nc nd bi translated">要获得灵感，请看一下<a class="ae lq" href="https://zeit.co/" rel="noopener ugc nofollow" target="_blank"> Zeit </a>和<a class="ae lq" href="https://getstream.io/" rel="noopener ugc nofollow" target="_blank"> Heroku </a>在他们的CLI中提供的功能，它们创造了令人敬畏的开发者命令行体验。</li><li id="c65b" class="mv mw it kw b kx ne la nf ld ng lh nh ll ni lp na nb nc nd bi translated">如果您的API/CLI需要数据持久性，请将该数据存储在特定于您的CLI的缓存目录中。使用一个<a class="ae lq" href="https://github.com/GetStream/stream-cli/blob/master/src/utils/config/credentials.js" rel="noopener ugc nofollow" target="_blank"> util文件加载它，就像我们在流</a>中做的那样。另外，请注意<a class="ae lq" href="https://www.npmjs.com/package/fs-extra" rel="noopener ugc nofollow" target="_blank"> fs-extra </a>包对于这种类型的事情会很方便(即使oclif中内置了支持)。</li><li id="7c82" class="mv mw it kw b kx ne la nf ld ng lh nh ll ni lp na nb nc nd bi translated">oclif 是一条可行之路，尤其是如果您正在构建一个大型的CLI，而不是一个单一命令的CLI。如果您正在构建一个单命令CLI，您仍然可以使用oclif在搭建CLI时，请确保指定它是一个单命令API。</li><li id="b5b0" class="mv mw it kw b kx ne la nf ld ng lh nh ll ni lp na nb nc nd bi translated">不想用框架？没关系！包<a class="ae lq" href="https://www.npmjs.com/package/minimist" rel="noopener ugc nofollow" target="_blank">minimit</a>在命令行中提供了参数解析，可以很容易地在你的项目中使用。</li><li id="2705" class="mv mw it kw b kx ne la nf ld ng lh nh ll ni lp na nb nc nd bi translated">使用<a class="ae lq" href="https://www.npmjs.com/package/enquirer" rel="noopener ugc nofollow" target="_blank">询问器</a>或您选择的其他软件包时，尽可能使用提示。应该引导用户完成命令的要求，并询问用户正确执行命令所需的数据。请注意，这不应该是必需的(例如，如果用户传递了正确的参数，就让他们绕过提示)。</li><li id="414c" class="mv mw it kw b kx ne la nf ld ng lh nh ll ni lp na nb nc nd bi translated">尽可能使用颜色，让你的CLI看起来更舒服。粉笔是一个很好的工具。</li><li id="81f6" class="mv mw it kw b kx ne la nf ld ng lh nh ll ni lp na nb nc nd bi translated">如果您有足够结构化的响应数据，不要只是将它打印给用户(除非这是他们指定的)。相反，使用<a class="ae lq" href="https://www.npmjs.com/package/cli-table" rel="noopener ugc nofollow" target="_blank"> cli-table </a>将其放入表格中。</li><li id="9182" class="mv mw it kw b kx ne la nf ld ng lh nh ll ni lp na nb nc nd bi translated">总是允许用户指定输出类型(例如，JSON)，但默认为人类可读的消息。</li><li id="dc5c" class="mv mw it kw b kx ne la nf ld ng lh nh ll ni lp na nb nc nd bi translated">保持速度！对于耗时的任务，如文件上传或需要多个API调用的命令，我们建议显示一个加载指示器，让用户知道工作正在后台进行。如果你在npm上寻找一个包，我们推荐你去看看<a class="ae lq" href="https://www.npmjs.com/package/ora" rel="noopener ugc nofollow" target="_blank">或者</a>。</li></ul><p id="2c6c" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">像往常一样，我们也很乐意听到你的想法和意见，所以请在下面的评论中提出来！</p><p id="85af" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">如果你有兴趣在Stream平台上构建一个聊天产品，我们推荐你浏览一下我们的<a class="ae lq" href="https://getstream.io/chat/get_started/" rel="noopener ugc nofollow" target="_blank">互动教程</a>。有关Stream Chat API上的完整文档，您可以在此处<a class="ae lq" href="https://getstream.io/chat/docs/js/" rel="noopener ugc nofollow" target="_blank">查看</a>。</p></div></div>    
</body>
</html>