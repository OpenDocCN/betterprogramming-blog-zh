<html>
<head>
<title>Simplifying a JavaScript Function With 12 Automated Refactorings</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">用12个自动化重构简化JavaScript函数</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/simplifying-a-javascript-function-with-12-automated-refactorings-24fa92d364c?source=collection_archive---------7-----------------------#2021-12-01">https://betterprogramming.pub/simplifying-a-javascript-function-with-12-automated-refactorings-24fa92d364c?source=collection_archive---------7-----------------------#2021-12-01</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="bb3b" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">在VS代码中使用重构助手</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/ab4f48428718d6570bf45d9899f13079.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*bAMiBeI17DRRO8JuzQyTfw.jpeg"/></div></div></figure><p id="1b8c" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">连续执行许多自动化重构是快速改进代码的一种有效方法。这种方法相对于手工重构的优势在于，它不太可能引入错误，而且使用正确的键盘快捷键通常会更快。然而，链接重构是一种艺术，因为它可能涉及非直观的操作来实现进一步的步骤。</p><p id="c694" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">这篇博文展示了一个例子，展示了如何在不改变行为的情况下，通过12次自动化重构来简化一个小的JavaScript函数。我将使用<a class="ae ln" href="https://code.visualstudio.com/" rel="noopener ugc nofollow" target="_blank"> Visual Studio代码</a>和<a class="ae ln" href="https://marketplace.visualstudio.com/items?itemName=p42ai.refactor" rel="noopener ugc nofollow" target="_blank"> P42 JavaScript Assistant重构扩展</a>。</p><p id="0060" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">最初，该函数(来自这篇<a class="ae ln" href="https://dev.to/luigizaccagnini/refactoring-code-in-octo-3397" rel="noopener ugc nofollow" target="_blank">博客文章</a>)看起来如下:</p><pre class="kg kh ki kj gt lo lp lq lr aw ls bi"><span id="b630" class="lt lu iq lp b gy lv lw l lx ly">const lineChecker = (line, isFirstLine) =&gt; {<br/>  let document = ``;</span><span id="2c0c" class="lt lu iq lp b gy lz lw l lx ly">  if (line !== "" &amp;&amp; isFirstLine) {<br/>    document += `&lt;h1&gt;${line}&lt;/h1&gt;`;<br/>  } else if (line !== "" &amp;&amp; !isFirstLine) {<br/>    document += `&lt;p&gt;${line}&lt;/p&gt;`;<br/>  } else if (line === "") {<br/>    document += "&lt;br /&gt;";<br/>  }</span><span id="2172" class="lt lu iq lp b gy lz lw l lx ly">  return document;<br/>};</span></pre><p id="fcec" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">重构后，函数变得更短，也更容易理解:</p><pre class="kg kh ki kj gt lo lp lq lr aw ls bi"><span id="ac98" class="lt lu iq lp b gy lv lw l lx ly">const lineChecker = (line, isFirstLine) =&gt; {<br/>  if (line === "") {<br/>    return `&lt;br /&gt;`<br/>  }</span><span id="9c59" class="lt lu iq lp b gy lz lw l lx ly">  return isFirstLine ? `&lt;h1&gt;${line}&lt;/h1&gt;` : `&lt;p&gt;${line}&lt;/p&gt;`;<br/>};</span></pre><p id="7abc" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">以下是我重构该函数的步骤:</p><h1 id="7f4e" class="ma lu iq bd mb mc md me mf mg mh mi mj jw mk jx ml jz mm ka mn kc mo kd mp mq bi translated">简化控制流程并删除变量</h1><p id="66db" class="pw-post-body-paragraph kr ks iq kt b ku mr jr kw kx ms ju kz la mt lc ld le mu lg lh li mv lk ll lm ij bi translated">第一次重构消除了文档变量，简化了控制流。这种变化使得推理函数变得更容易，因为状态更少(即，没有文档变量)并且几个执行路径提前返回。</p><ol class=""><li id="b8d2" class="mw mx iq kt b ku kv kx ky la my le mz li na lm nb nc nd ne bi translated"><strong class="kt ir">将</strong> <code class="fe nf ng nh lp b"><strong class="kt ir">+</strong></code> <strong class="kt ir">从</strong> <code class="fe nf ng nh lp b"><strong class="kt ir">+=</strong></code> <strong class="kt ir">赋值中拉出，变成常规字符串串联</strong>。这一步允许在下一步中引入早期return语句。</li><li id="86ae" class="mw mx iq kt b ku ni kx nj la nk le nl li nm lm nb nc nd ne bi translated"><strong class="kt ir">用提前返回语句替换重新分配</strong> <code class="fe nf ng nh lp b"><strong class="kt ir">document</strong></code> <strong class="kt ir">变量。</strong>这一步简化了控制流，并支持内联<code class="fe nf ng nh lp b">document</code>变量。</li><li id="f93e" class="mw mx iq kt b ku ni kx nj la nk le nl li nm lm nb nc nd ne bi translated"><strong class="kt ir">行内</strong> <code class="fe nf ng nh lp b"><strong class="kt ir">document</strong></code>行内<strong class="kt ir">变量</strong>。这一步删除了一个不必要的变量，并允许在下一步中删除空字符串。</li><li id="c2e9" class="mw mx iq kt b ku ni kx nj la nk le nl li nm lm nb nc nd ne bi translated">通过将空字符串合并到模板中来删除它们。</li></ol><p id="2635" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">应用这些步骤后，函数如下所示:</p><pre class="kg kh ki kj gt lo lp lq lr aw ls bi"><span id="592a" class="lt lu iq lp b gy lv lw l lx ly">const lineChecker = (line, isFirstLine) =&gt; {<br/>  if (line !== "" &amp;&amp; isFirstLine) {<br/>    return `&lt;h1&gt;${line}&lt;/h1&gt;`;<br/>  } else if (line !== "" &amp;&amp; !isFirstLine) {<br/>    return `&lt;p&gt;${line}&lt;/p&gt;`;<br/>  } else if (line === "") {<br/>    return `&lt;br /&gt;`;<br/>  }</span><span id="48c1" class="lt lu iq lp b gy lz lw l lx ly">  return ``;<br/>};</span></pre><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi nn"><img src="../Images/25d8f0aece2b06e3699c1bee2ed9c38d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1270/0*sNKTCz5mfcwhSRWN.gif"/></div></figure><h1 id="7ea7" class="ma lu iq bd mb mc md me mf mg mh mi mj jw mk jx ml jz mm ka mn kc mo kd mp mq bi translated">简化条件并删除代码</h1><p id="2eb7" class="pw-post-body-paragraph kr ks iq kt b ku mr jr kw kx ms ju kz la mt lc ld le mu lg lh li mv lk ll lm ij bi translated">下一个目标是简化if语句中的条件，并删除死代码或不必要的代码。这一变化进一步降低了函数的复杂性，使其更容易理解，因为代码更少，条件更简单。</p><ol class=""><li id="2370" class="mw mx iq kt b ku kv kx ky la my le mz li na lm nb nc nd ne bi translated"><strong class="kt ir">将</strong> <code class="fe nf ng nh lp b"><strong class="kt ir">isFirstLine</strong></code> <strong class="kt ir">条件分离成嵌套的if语句。</strong></li><li id="3086" class="mw mx iq kt b ku ni kx nj la nk le nl li nm lm nb nc nd ne bi translated"><strong class="kt ir">从</strong> <code class="fe nf ng nh lp b"><strong class="kt ir">!==</strong></code> <strong class="kt ir">拉起否定。</strong>这两个步骤为删除多余的else-if条件做准备。</li><li id="f421" class="mw mx iq kt b ku ni kx nj la nk le nl li nm lm nb nc nd ne bi translated"><strong class="kt ir">删除else-if </strong>上的冗余条件，因为它始终为真。在删除多余的else-if条件后，最终的<code class="fe nf ng nh lp b">return</code>语句显然是不可达的。</li><li id="7cfb" class="mw mx iq kt b ku ni kx nj la nk le nl li nm lm nb nc nd ne bi translated"><strong class="kt ir">删除无法访问的代码。</strong>不可及的代码毫无用处，毫无益处地消耗了我们的一些注意力。移除它几乎总是更好。</li><li id="d168" class="mw mx iq kt b ku ni kx nj la nk le nl li nm lm nb nc nd ne bi translated"><strong class="kt ir">把否定推回</strong> <code class="fe nf ng nh lp b"><strong class="kt ir">===</strong></code> <strong class="kt ir">。这个重构恢复了先前的一个步骤，这个步骤对于进一步的重构是暂时必要的。</strong></li><li id="8620" class="mw mx iq kt b ku ni kx nj la nk le nl li nm lm nb nc nd ne bi translated"><strong class="kt ir">反转</strong> <code class="fe nf ng nh lp b"><strong class="kt ir">!==</strong></code> <strong class="kt ir">条件并合并嵌套if。</strong>由此产生的<code class="fe nf ng nh lp b">line === ""</code>条件更容易理解，因为没有否定。更好的是，它允许将内部if语句提升到else-if序列中，并指示空行处理可能是一种特殊情况。</li></ol><p id="e333" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">应用这些步骤后，函数如下所示:</p><pre class="kg kh ki kj gt lo lp lq lr aw ls bi"><span id="e6b4" class="lt lu iq lp b gy lv lw l lx ly">const lineChecker = (line, isFirstLine) =&gt; {<br/>  if (line === "") {<br/>    return `&lt;br /&gt;`;<br/>  } else if (isFirstLine) {<br/>    return `&lt;h1&gt;${line}&lt;/h1&gt;`;<br/>  } else {<br/>    return `&lt;p&gt;${line}&lt;/p&gt;`;<br/>  }</span><span id="8e0f" class="lt lu iq lp b gy lz lw l lx ly">};</span></pre><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi nn"><img src="../Images/6ccea4ea8a6bd8988ac690c45f105f98.png" data-original-src="https://miro.medium.com/v2/resize:fit:1270/0*cygMDyjwm0pkSgGG.gif"/></div></figure><h1 id="88bb" class="ma lu iq bd mb mc md me mf mg mh mi mj jw mk jx ml jz mm ka mn kc mo kd mp mq bi translated">提高可读性</h1><p id="391f" class="pw-post-body-paragraph kr ks iq kt b ku mr jr kw kx ms ju kz la mt lc ld le mu lg lh li mv lk ll lm ij bi translated">最后一组重构旨在通过将特例<code class="fe nf ng nh lp b">line === ''</code>移入一个guard子句并使用条件返回表达式来提高可读性。</p><ol class=""><li id="4675" class="mw mx iq kt b ku kv kx ky la my le mz li na lm nb nc nd ne bi translated">将<code class="fe nf ng nh lp b">line === ''</code>条件转换为guard子句。</li><li id="d388" class="mw mx iq kt b ku ni kx nj la nk le nl li nm lm nb nc nd ne bi translated">用条件表达式简化返回。</li><li id="3e6d" class="mw mx iq kt b ku ni kx nj la nk le nl li nm lm nb nc nd ne bi translated">格式，例如保存时用<a class="ae ln" href="https://prettier.io/" rel="noopener ugc nofollow" target="_blank">更漂亮的</a>。</li></ol><p id="3e18" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">以下是最终结果:</p><pre class="kg kh ki kj gt lo lp lq lr aw ls bi"><span id="313a" class="lt lu iq lp b gy lv lw l lx ly">const lineChecker = (line, isFirstLine) =&gt; {<br/>  if (line === "") {<br/>    return `&lt;br /&gt;`<br/>  }</span><span id="dbd2" class="lt lu iq lp b gy lz lw l lx ly">  return isFirstLine ? `&lt;h1&gt;${line}&lt;/h1&gt;` : `&lt;p&gt;${line}&lt;/p&gt;`;<br/>};</span></pre><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi nn"><img src="../Images/9e3e7364cec211c72c10a8f759fc85b3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1270/0*ZipBaKoaOgg4Tjsq.gif"/></div></figure><h1 id="9699" class="ma lu iq bd mb mc md me mf mg mh mi mj jw mk jx ml jz mm ka mn kc mo kd mp mq bi translated">其他注意事项</h1><p id="fefd" class="pw-post-body-paragraph kr ks iq kt b ku mr jr kw kx ms ju kz la mt lc ld le mu lg lh li mv lk ll lm ij bi translated">这篇博文展示了如何使用自动化重构来简化JavaScript函数而不改变其行为。实际上，还有许多其他考虑因素:</p><ul class=""><li id="a131" class="mw mx iq kt b ku kv kx ky la my le mz li na lm no nc nd ne bi translated">自动化测试覆盖范围自动化测试对于确信重构没有无意中改变代码的行为是必不可少的。当存在容易出错的手动重构步骤时，这一点尤为重要。当测试覆盖率不足时，在重构代码之前添加测试是至关重要的。</li><li id="7457" class="mw mx iq kt b ku ni kx nj la nk le nl li nm lm no nc nd ne bi translated"><strong class="kt ir">发现潜在的错误</strong> <br/>更简单的代码可以发现潜在的错误，您可以在重构完成后调查这些错误。在这里的例子中，即使当<code class="fe nf ng nh lp b">isFirstLine</code>是<code class="fe nf ng nh lp b">true</code>时，函数也会返回一个<code class="fe nf ng nh lp b">&lt;br /&gt;</code>，这可能不是预期的行为。</li><li id="8f56" class="mw mx iq kt b ku ni kx nj la nk le nl li nm lm no nc nd ne bi translated"><strong class="kt ir">其他重构</strong> <br/>从这篇博文来看，重构函数的方法有很多。我着重于简化函数，但是重命名或者甚至分解它也是可能的。查看帖子"<a class="ae ln" href="https://dev.to/p42/how-would-you-refactor-this-js-function-4n71" rel="noopener ugc nofollow" target="_blank">你将如何重构这个JS函数？</a>“求更。</li></ul><p id="71aa" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">我希望这篇文章能让你了解如何对自动化重构步骤进行排序，以实现更显著的重构变化。</p></div></div>    
</body>
</html>