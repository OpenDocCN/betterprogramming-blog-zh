<html>
<head>
<title>7 JavaScript Fundamentals Every Web Developer Should Know</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">每个Web开发者都应该知道的7个JavaScript基础知识</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/7-javascript-fundamentals-every-web-developer-should-know-8c0f7e491167?source=collection_archive---------0-----------------------#2021-03-24">https://betterprogramming.pub/7-javascript-fundamentals-every-web-developer-should-know-8c0f7e491167?source=collection_archive---------0-----------------------#2021-03-24</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="8bd2" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">函数是值，对象从其他对象继承，等等</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/fe392adec6806093e516aa90202da067.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*s4pg_I-HRI_qKGGM"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">埃里克·布洛林在<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的照片。</p></figure><p id="7eb0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在本文中，我们将看看我认为JavaScript的一些最重要的——也是最独特的——特性。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="e9d7" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">1.功能是独立的行为单位</h1><p id="2cd5" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated"><a class="ae ky" rel="noopener ugc nofollow" target="_blank" href="/10-fundamentals-you-need-to-know-about-functions-in-javascript-8e74579b7a9a">功能</a>是行为的单位，但这里重要的一点是它们是独立的。在其他语言中，如Java或C#，函数必须在类中声明。在JavaScript中不是这样。</p><p id="573f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">函数可以在全局范围内声明，也可以在模块内定义为可以重用的独立单元。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="9212" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">2.对象是道具的动态集合</h1><p id="9b58" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">对象实际上只是属性的集合。在其他语言中，它们被称为映射、哈希映射或哈希表。</p><p id="f6ff" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">它们是动态的，因为一旦创建，就可以添加、编辑或删除属性。</p><p id="1308" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">下面是一个简单的<a class="ae ky" href="https://medium.com/dailyjs/15-fundamentals-you-should-know-on-javascript-objects-90f57cc9d78d" rel="noopener">对象</a>，使用对象的字面语法定义。它有两个属性:</p><pre class="kj kk kl km gt mz na nb nc aw nd bi"><span id="886a" class="ne md it na b gy nf ng l nh ni">const game = {<br/>  title : 'Settlers',<br/>  developer: 'Ubisoft'<br/>}</span></pre></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="e5aa" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">3.对象从其他对象继承</h1><p id="35d8" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">如果您来自基于类的语言，如Java或C#，您可能习惯于从其他类继承的类。同样，在JavaScript中情况并非如此。</p><p id="9d22" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">对象从称为原型的其他对象继承。</p><p id="c132" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如前所述，在这种语言中，对象是属性的集合。当创建一个对象时，它有一个名为<code class="fe nj nk nl na b">__proto__</code>的“隐藏”属性，用来保存对另一个对象的引用。这个被引用的对象称为原型。</p><p id="36f0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">下面是一个创建空对象的例子(可以说是一个没有属性的对象):</p><pre class="kj kk kl km gt mz na nb nc aw nd bi"><span id="8eed" class="ne md it na b gy nf ng l nh ni">const obj = {};</span></pre><p id="4d3d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">即使它看起来是空的并且没有属性，它也有一个对<code class="fe nj nk nl na b">Object.prototype</code>对象的引用。它拥有<code class="fe nj nk nl na b">__proto__</code>隐藏的属性:</p><pre class="kj kk kl km gt mz na nb nc aw nd bi"><span id="b35c" class="ne md it na b gy nf ng l nh ni">obj.__proto__ === Object.prototype;<br/>//true</span></pre><p id="ba07" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">例如，在这种对象上，我们可以访问<code class="fe nj nk nl na b">toString</code>方法，即使我们还没有定义这样的方法。这怎么可能呢？</p><p id="2290" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这种方法是从<code class="fe nj nk nl na b">Object.prototype</code>那里继承来的。当试图访问该方法时，引擎首先试图在当前对象上找到它，然后查看其原型的属性。</p><p id="746f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">不要被<a class="ae ky" href="https://medium.com/programming-essentials/class-vs-factory-function-exploring-the-way-forward-73258b6a8d15" rel="noopener">类</a>关键字误导。它只是原型系统上的语法糖，试图让来自基于类的语言的开发人员熟悉这种语言。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="3cf6" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">4.函数是值</h1><p id="c9a3" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated"><a class="ae ky" href="https://medium.com/programming-essentials/make-your-code-easier-to-read-with-functional-programming-94fb8cc69f9d" rel="noopener">函数是JavaScript中的值</a>。像其他值一样，它们可以分配给变量:</p><pre class="kj kk kl km gt mz na nb nc aw nd bi"><span id="35b4" class="ne md it na b gy nf ng l nh ni">const sum = function(x,y){ return x + y }</span></pre><p id="dc56" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这是任何其他语言都做不到的。</p><p id="b14f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">像其他值一样，函数可以传递给不同的函数或从函数返回。下面是一个函数返回另一个函数的示例:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nm nn l"/></div></figure><p id="98ac" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在同一个例子中，我们可以看到从<code class="fe nj nk nl na b">startsWith</code>函数返回的函数是如何作为参数发送给<code class="fe nj nk nl na b">filter</code>数组方法的。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="9cf1" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">5.函数可以变成闭包</h1><p id="576b" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">函数可以在其他函数中定义。内部函数可以引用其他函数中的变量。</p><p id="199e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">此外，在外部函数执行之后，内部函数可以引用外部函数中的变量。下面是一个例子:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nm nn l"/></div></figure><p id="6e8a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe nj nk nl na b">count</code>函数可以从<code class="fe nj nk nl na b">createCounter</code>父函数中访问<code class="fe nj nk nl na b">x</code>变量，即使在它被执行之后。<code class="fe nj nk nl na b">count</code>是一个<a class="ae ky" href="https://medium.com/programming-essentials/you-will-finally-understand-what-closure-is-13ba11825319" rel="noopener">闭合</a>。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="df74" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">6.图元被视为对象</h1><p id="9b1c" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">JavaScript给人一种错觉，认为原语就是对象，就像对待对象一样。事实是原语不是对象。原语不是属性的集合。</p><p id="a00e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">然而，我们可以在原语上调用方法。例如，我们可以在字符串上调用<code class="fe nj nk nl na b">toUpperCase</code>方法:</p><pre class="kj kk kl km gt mz na nb nc aw nd bi"><span id="d86d" class="ne md it na b gy nf ng l nh ni">const upperText = 'Minecraft'.toUpperCase();<br/>console.log(upperText);<br/>//'MINECRAFT'</span></pre><p id="44ce" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">像<code class="fe nj nk nl na b">'Minecraft'</code>这样的简单文本是原语，没有方法。JavaScript使用内置的<a class="ae ky" href="https://medium.com/programming-essentials/how-to-convert-values-into-strings-in-javascript-13df1c09b3ed" rel="noopener">字符串</a>构造函数将其转换成一个对象，然后对新创建的对象运行<code class="fe nj nk nl na b">toUpperCase</code>方法。</p><p id="1dfc" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">通过在幕后将原语转换为包装对象，JavaScript允许您调用它们的方法，从而将它们视为对象。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="6ae9" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">7.JavaScript是一种单线程语言</h1><p id="0b63" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">JavaScript是单线程的。这意味着在特定时间只执行一条语句。</p><p id="2b62" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">两个函数不能在主线程中同时执行。</p><p id="a7c2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">您可能听说过像web workers一样并行执行函数的选项，但是worker不与主线程共享数据。他们只通过信息传递来交流，没有什么是共享的。</p><p id="406b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这使得事情更容易理解，我们只需要注意让函数运行得更快。一个需要很长时间执行的函数会使页面没有响应。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><p id="b88a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">关于JavaScript基础的更多内容，你可以看看<a class="ae ky" href="https://medium.com/programming-essentials/learn-these-javascript-fundamentals-and-become-a-better-developer-2a031a0dc9cf" rel="noopener">学习这些JavaScript基础，成为更好的开发者</a>。</p><p id="eb52" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">感谢阅读。</p></div></div>    
</body>
</html>