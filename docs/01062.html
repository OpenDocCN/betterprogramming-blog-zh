<html>
<head>
<title>Auth With Firebase for React + Redux Apps: From 0 to 1</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">React + Redux应用程序的Firebase授权:从0到1</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/https-medium-com-clairechabas-auth-with-firebase-for-react-redux-apps-from-0-to-1-104e7343521b?source=collection_archive---------1-----------------------#2019-08-12">https://betterprogramming.pub/https-medium-com-clairechabas-auth-with-firebase-for-react-redux-apps-from-0-to-1-104e7343521b?source=collection_archive---------1-----------------------#2019-08-12</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><h2 id="59ac" class="ir is it bd b dl iu iv iw ix iy iz dk ja translated" aria-label="kicker paragraph">完整的分步指南</h2><div class=""/><div class=""><h2 id="e545" class="pw-subtitle-paragraph jz jc it bd b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq dk translated">Firebase使得为一个应用程序设置整个认证系统变得很容易</h2></div><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi kr"><img src="../Images/2c7de00d6184f4caade12f032e365d2b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*uub5If1_zSaODDNQVwYR-g.png"/></div></div><p class="ld le gj gh gi lf lg bd b be z dk translated">鸣谢:<a class="ae lh" href="https://unsplash.com/@sapegin?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Artem Sapegin </a>在<a class="ae lh" href="https://unsplash.com/search/photos/react?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>拍摄的电脑和杯子背景照片</p></figure><p id="ae34" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">认证是一个复杂的话题，不能掉以轻心。</p><p id="5a75" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">当我从零开始构建我的第一个现实世界应用程序<a class="ae lh" href="https://getmark.app/" rel="noopener ugc nofollow" target="_blank"> Mark </a>的认证系统时，我发现了它的来龙去脉，这是一个Chrome扩展，它可以让你在Chrome的<em class="me">新标签</em>主页中锁定网页。</p><p id="018d" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">令人欣慰的是，<a class="ae lh" href="https://firebase.google.com/" rel="noopener ugc nofollow" target="_blank"> Firebase </a>让我们在几个小时内为我们的应用程序建立整个认证系统变得非常容易，相比之下，如果你自己从头开始，需要几天甚至几周的时间。</p><p id="af56" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">本指南旨在使用Firebase Auth将您从一个空的React应用程序转变为一个具有完整身份验证系统的应用程序。正如您将看到的，我们只需五个步骤就能做到:</p><ul class=""><li id="3469" class="mf mg it lk b ll lm lo lp lr mh lv mi lz mj md mk ml mm mn bi translated">步骤1:安装和设置。</li><li id="21fa" class="mf mg it lk b ll mo lo mp lr mq lv mr lz ms md mk ml mm mn bi translated">步骤2:注册电子邮件验证。</li><li id="55e0" class="mf mg it lk b ll mo lo mp lr mq lv mr lz ms md mk ml mm mn bi translated">步骤3:登录并重定向。</li><li id="4b1f" class="mf mg it lk b ll mo lo mp lr mq lv mr lz ms md mk ml mm mn bi translated">第四步:注销。</li><li id="1875" class="mf mg it lk b ll mo lo mp lr mq lv mr lz ms md mk ml mm mn bi translated">第五步:密码重置。</li><li id="fea2" class="mf mg it lk b ll mo lo mp lr mq lv mr lz ms md mk ml mm mn bi translated">额外收获:根据授权状态限制页面访问。</li></ul><p id="f0b1" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">先决条件:我假设您已经熟悉React和Redux。</p><p id="ad2c" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">让我们开始这个认证派对吧！</p></div><div class="ab cl mt mu hx mv" role="separator"><span class="mw bw bk mx my mz"/><span class="mw bw bk mx my mz"/><span class="mw bw bk mx my"/></div><div class="im in io ip iq"><h1 id="53ed" class="na nb it bd nc nd ne nf ng nh ni nj nk ki nl kj nm kl nn km no ko np kp nq nr bi translated">步骤1:安装和设置</h1><p id="a972" class="pw-post-body-paragraph li lj it lk b ll ns kd ln lo nt kg lq lr nu lt lu lv nv lx ly lz nw mb mc md im bi translated">首先，你需要<a class="ae lh" href="https://firebase.google.com/" rel="noopener ugc nofollow" target="_blank">创建一个Firebase账号</a>。</p><p id="b66a" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">然后，连接到Firebase控制台，点击<em class="me">创建一个项目</em>。</p><p id="95d5" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">为您的项目选择一个名称和ID(明智地选择，您以后不能更改ID)，设置位置，同意将您一生的工作交给Google，然后单击<em class="me">创建项目</em>。</p><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi nx"><img src="../Images/0f4f345e7a1631861e2c5c1bff783b2a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*GqWQe8UOlJz-KkYusHubBA.png"/></div></div><p class="ld le gj gh gi lf lg bd b be z dk translated">创建您的Firebase项目</p></figure><p id="66ad" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">其次，你需要注册你的应用程序。选择<em class="me"> Web </em>图标，因为我们正在这里创建一个React web应用程序。</p><p id="29b4" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">输入你的应用程序名称(可选地，你可以设置Firebase托管，但我们现在不会这样做，因为这超出了本文的范围，所以不要选中此框)并点击<em class="me">注册应用程序</em>。</p><p id="c7e2" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">然后在<em class="me">中添加Firebase SDK </em>，复制<code class="fe ny nz oa ob b">firebaseConfig</code> <strong class="lk jd"> </strong>对象，这是你的应用程序的配置信息，你需要它来设置你的应用程序和Firebase之间的链接。</p><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi oc"><img src="../Images/fcbe3d3e0807d14c01c0887f2a1bec96.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*VdjPsxAJ3iAiXj-9UMuQig.jpeg"/></div></div><p class="ld le gj gh gi lf lg bd b be z dk translated">获取您的firebaseConfig</p></figure><p id="08d3" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">并点击<em class="me">继续到控制台</em>。</p><p id="edfb" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">第三，<em class="me">为你的Firebase项目激活认证</em>。点击<em class="me">认证</em>，然后点击<em class="me">设置登录方式</em>。</p><p id="5749" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">您可以看到，您可以使用各种第三方提供商进行身份验证，从谷歌、脸书、Twitter或GitHub，到使用匿名访客帐户以避免使用凭据，任您选择。</p><p id="ff27" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">这里我们将使用传统的电子邮件/密码登录选项，因此单击相应的行，<em class="me">启用</em>并点击<em class="me">保存</em>。现在这个登录选项已经启用，我们可以在我们的应用程序中使用相关的Firebase方法。</p><p id="aa19" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">在我们继续之前，请查看<em class="me">模板</em>部分。您将看到您有四个电子邮件模板，您可以对其稍加修改。</p><p id="a6ff" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">在撰写本文时，不可能进一步定制模板。如果您想使用自己的电子邮件模板，可以跳过使用与发送这些电子邮件模板相关的Firebase方法，自己用自己的电子邮件服务处理相关操作(电子邮件地址验证、密码重置……)。</p><p id="f01e" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">如果你对如何做到这一点感兴趣，请在评论中告诉我，我会就此写另一篇文章。</p><p id="f8dc" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">最后，设置React应用程序以使用Firebase:</p><ol class=""><li id="bf71" class="mf mg it lk b ll lm lo lp lr mh lv mi lz mj md od ml mm mn bi translated">安装<code class="fe ny nz oa ob b">firebase</code> npm包。</li></ol><pre class="ks kt ku kv gt oe ob of og aw oh bi"><span id="ae35" class="oi nb it ob b gy oj ok l ol om">npm install --save firebase</span></pre><p id="67f3" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">2.在你的应用程序文件夹中创建一个<code class="fe ny nz oa ob b">firebase.js</code>文件(我喜欢把它放在一个<code class="fe ny nz oa ob b">services</code>文件夹中，但这完全取决于你),并在这个文件中插入以下代码:</p><figure class="ks kt ku kv gt kw"><div class="bz fp l di"><div class="on oo l"/></div></figure><p id="2be2" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">你完了！</p><p id="1f9a" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">您已经成功地设置了一个用于身份验证的Firebase项目，并将其与一个React应用程序相关联。设置和配置阶段已经结束，现在我们可以继续做好的事情了:注册并验证用户的电子邮件地址。</p></div><div class="ab cl mt mu hx mv" role="separator"><span class="mw bw bk mx my mz"/><span class="mw bw bk mx my mz"/><span class="mw bw bk mx my"/></div><div class="im in io ip iq"><h1 id="cd49" class="na nb it bd nc nd ne nf ng nh ni nj nk ki nl kj nm kl nn km no ko np kp nq nr bi translated">步骤2:注册电子邮件验证</h1><p id="d78c" class="pw-post-body-paragraph li lj it lk b ll ns kd ln lo nt kg lq lr nu lt lu lv nv lx ly lz nw mb mc md im bi translated">您应该使用React路由器和您的登录组件设置React应用程序。以下是我的出发点:</p><p id="21dc" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated"><code class="fe ny nz oa ob b">index.js</code></p><pre class="ks kt ku kv gt oe ob of og aw oh bi"><span id="fc38" class="oi nb it ob b gy oj ok l ol om"><em class="me">import</em> React <em class="me">from</em> "react";<br/><em class="me">import</em> ReactDOM <em class="me">from</em> "react-dom";<br/><em class="me">import</em> { BrowserRouter <em class="me">as</em> Router } <em class="me">from</em> "react-router-dom";<br/><em class="me">import</em> "./css/index.css";<br/><em class="me">import</em> App <em class="me">from</em> "./components/App";</span><span id="875f" class="oi nb it ob b gy op ok l ol om">ReactDOM.render(<br/>  &lt;Router&gt;<br/>    &lt;App /&gt;<br/>  &lt;/Router&gt;,<br/>document.getElementById("root")<br/>);</span></pre><p id="dd26" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated"><code class="fe ny nz oa ob b">App.js</code></p><pre class="ks kt ku kv gt oe ob of og aw oh bi"><span id="ebe3" class="oi nb it ob b gy oj ok l ol om"><em class="me">import</em> React <em class="me">from</em> "react";<br/><em class="me">import</em> { Switch, Route } <em class="me">from</em> "react-router-dom";<br/><em class="me">import</em> Main <em class="me">from</em> "./Main";<br/><em class="me">import</em> Login <em class="me">from</em> "./Login";</span><span id="f94e" class="oi nb it ob b gy op ok l ol om">const App = () =&gt; {<br/>  <em class="me">return</em> (<br/>    &lt;div <em class="me">className</em>="App"&gt;<br/>      &lt;Switch&gt;<br/>        &lt;Route <em class="me">exact</em> <em class="me">path</em>="/" <em class="me">component</em>={Main} /&gt;<br/>        &lt;Route <em class="me">exact</em> <em class="me">path</em>="/login" <em class="me">component</em>={Login} /&gt;<br/>      &lt;/Switch&gt;<br/>    &lt;/div&gt;<br/>  );<br/>};</span><span id="4ce3" class="oi nb it ob b gy op ok l ol om"><em class="me">export</em> <em class="me">default</em> App;</span></pre><p id="9330" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated"><code class="fe ny nz oa ob b">Main.js</code>:</p><p id="1281" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">稍后将使用Main根据用户是否经过身份验证自动重定向到home或login组件。同时，我们现在只显示登录。</p><pre class="ks kt ku kv gt oe ob of og aw oh bi"><span id="9def" class="oi nb it ob b gy oj ok l ol om"><em class="me">import</em> React <em class="me">from</em> "react";<br/><em class="me">import</em> Login <em class="me">from</em> "./Login";</span><span id="9904" class="oi nb it ob b gy op ok l ol om">const Main = () =&gt; {<br/>  <em class="me">return</em> &lt;Login /&gt;;<br/>};</span><span id="18e2" class="oi nb it ob b gy op ok l ol om"><em class="me">export</em> <em class="me">default</em> Main;</span></pre><h2 id="a264" class="oi nb it bd nc oq or dn ng os ot dp nk lr ou ov nm lv ow ox no lz oy oz nq iz bi translated"><strong class="ak">安装Redux商店并用Firebase增强它</strong></h2><p id="6206" class="pw-post-body-paragraph li lj it lk b ll ns kd ln lo nt kg lq lr nu lt lu lv nv lx ly lz nw mb mc md im bi translated">首先，我们需要设置我们的Redux store，我们需要将它连接到Firebase，这样我们就可以访问Firebase reducer。这将允许我们在我们的应用程序中访问用户的身份验证状态。</p><p id="7f75" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">让我们安装必要的依赖项:</p><pre class="ks kt ku kv gt oe ob of og aw oh bi"><span id="6cba" class="oi nb it ob b gy oj ok l ol om">npm i redux react-redux redux-thunk</span></pre><p id="f91b" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">此外，我们还需要特定于Firebase的依赖项，这将允许我们将其绑定到我们的Redux存储:</p><pre class="ks kt ku kv gt oe ob of og aw oh bi"><span id="2892" class="oi nb it ob b gy oj ok l ol om">npm i react-redux-firebase</span></pre><p id="a93a" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">现在，在没有Firebase的情况下，我们之前创建商店的方式是这样的，您应该很熟悉:</p><pre class="ks kt ku kv gt oe ob of og aw oh bi"><span id="7875" class="oi nb it ob b gy oj ok l ol om"><em class="me">const store = <br/>createStore(rootReducer, {}, applyMiddleware(reduxThunk));</em></span></pre><p id="e1b0" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">在这里，我们将需要“增强”我们的redux store以利用Firebase，我们将使用store enhancer <code class="fe ny nz oa ob b">reactReduxFirebase</code>来完成这项工作，它来自我们的新npm包:<code class="fe ny nz oa ob b">react-redux-firebase</code>。</p><p id="db5c" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">正如你在下面看到的，我们正在使用redux中的<code class="fe ny nz oa ob b">compose</code>将我们的Firebase实例(位于我们的<code class="fe ny nz oa ob b">firebase.js</code>文件中，先前已启动)传递给<code class="fe ny nz oa ob b">reactReduxFirebase</code> <strong class="lk jd"> </strong>，并用这个增强器包装Redux <code class="fe ny nz oa ob b">createStore</code>方法。</p><p id="51b6" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">像这样:</p><pre class="ks kt ku kv gt oe ob of og aw oh bi"><span id="f97a" class="oi nb it ob b gy oj ok l ol om"><em class="me">// 1. Enhancing our createStore method with Firebase</em></span><span id="f596" class="oi nb it ob b gy op ok l ol om">const createStoreWithFirebase = compose(reactReduxFirebase(firebase))(createStore);<br/></span><span id="52c4" class="oi nb it ob b gy op ok l ol om"><em class="me">// 2. Creating our store with this newly enhanced store creator</em></span><span id="2e98" class="oi nb it ob b gy op ok l ol om">const store = <br/>createStoreWithFirebase(reducers,{},applyMiddleware(reduxThunk));</span></pre><p id="0622" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">下面是我们的<code class="fe ny nz oa ob b">index.js</code>文件在这个商店建立后的样子:</p><figure class="ks kt ku kv gt kw"><div class="bz fp l di"><div class="on oo l"/></div><p class="ld le gj gh gi lf lg bd b be z dk translated">index.js根文件，使用Firebase设置并增强了Redux存储</p></figure><h2 id="f215" class="oi nb it bd nc oq or dn ng os ot dp nk lr ou ov nm lv ow ox no lz oy oz nq iz bi translated">创建根缩减器并添加Firebase缩减器</h2><p id="445a" class="pw-post-body-paragraph li lj it lk b ll ns kd ln lo nt kg lq lr nu lt lu lv nv lx ly lz nw mb mc md im bi translated">现在我们设置存储文件夹结构，并为身份验证缩减器和操作创建者创建<code class="fe ny nz oa ob b">auth.js</code>文件:</p><pre class="ks kt ku kv gt oe ob of og aw oh bi"><span id="58c3" class="oi nb it ob b gy oj ok l ol om">store/ <br/> |- reducers/<br/>     |- index.js<br/>     |- auth.js<br/> |- actions/<br/>     |- actionTypes.js<br/>     |- auth.js</span></pre><p id="aa74" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">root reducer像往常一样创建，但是我们添加了Firebase reducer。因此，<code class="fe ny nz oa ob b">reducers</code>文件夹中的<code class="fe ny nz oa ob b">index.js</code>文件看起来像这样:</p><pre class="ks kt ku kv gt oe ob of og aw oh bi"><span id="2b44" class="oi nb it ob b gy oj ok l ol om"><em class="me">import</em> { combineReducers } <em class="me">from</em> "redux";<br/><em class="me">import</em> authReducer <em class="me">from</em> "./auth";<br/><em class="me">import</em> { firebaseReducer } <em class="me">from</em> "react-redux-firebase";</span><span id="bdfd" class="oi nb it ob b gy op ok l ol om"><em class="me">export</em> <em class="me">default</em> combineReducers({<br/>  firebaseReducer,<br/>  authReducer<br/>});</span></pre><h2 id="9d05" class="oi nb it bd nc oq or dn ng os ot dp nk lr ou ov nm lv ow ox no lz oy oz nq iz bi translated">用Firebase注册动作创建器</h2><p id="ecce" class="pw-post-body-paragraph li lj it lk b ll ns kd ln lo nt kg lq lr nu lt lu lv nv lx ly lz nw mb mc md im bi translated">最后，我们可以创建action creator，使用Firebase Auth方法为用户注册。</p><p id="4733" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">首先，我在<code class="fe ny nz oa ob b">actionTypes.js</code>文件中创建了两个<em class="me">动作类型</em>，这样我们可以向用户发送反馈，让他们知道注册是否有效:</p><pre class="ks kt ku kv gt oe ob of og aw oh bi"><span id="a954" class="oi nb it ob b gy oj ok l ol om"><em class="me">// SIGN UP<br/>export</em> const SIGNUP_SUCCESS = "SIGNUP_SUCCESS";<br/><em class="me">export</em> const SIGNUP_ERROR = "SIGNUP_ERROR";</span></pre><p id="fc72" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">然后，在我的<code class="fe ny nz oa ob b">actions</code>文件夹中的<code class="fe ny nz oa ob b">auth.js</code>文件中，我正在导入那些动作类型，以及我的Firebase实例，并且我正在为注册启动一个动作创建器:</p><pre class="ks kt ku kv gt oe ob of og aw oh bi"><span id="fcd6" class="oi nb it ob b gy oj ok l ol om"><em class="me">import</em> { AUTH_SUCCESS, AUTH_ERROR } <em class="me">from</em> "./actionTypes";</span><span id="eab7" class="oi nb it ob b gy op ok l ol om"><em class="me">import</em> firebase <em class="me">from</em> "../../services/firebase";</span><span id="508c" class="oi nb it ob b gy op ok l ol om"><em class="me">// Signing up with Firebase<br/>export</em> const signup = (email, password) =&gt; async dispatch =&gt; {<br/>  <em class="me">try</em> {<br/>    <em class="me">...<br/>  </em>} <em class="me">catch</em> (err) {<br/>    <em class="me">...<br/>  </em>}<br/>};</span></pre><p id="ca02" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">我们要做的就是调用Firebase提供的<code class="fe ny nz oa ob b">createUserWithEmailAndPassword</code>方法来创建新用户:</p><pre class="ks kt ku kv gt oe ob of og aw oh bi"><span id="30f5" class="oi nb it ob b gy oj ok l ol om">firebase.auth().createUserWithEmailAndPassword(email, password)</span></pre><p id="a082" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">这回报了一个承诺。然后我们可以使用<code class="fe ny nz oa ob b">onAuthStateChanged</code>，每当用户的登录状态发生变化时都会调用它。</p><p id="4c6e" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">这个方法让我们可以访问用户的数据，然后我们可以调用<code class="fe ny nz oa ob b">sendEmailVerification</code>方法来验证他们的电子邮件地址，如下所示:</p><pre class="ks kt ku kv gt oe ob of og aw oh bi"><span id="6aa5" class="oi nb it ob b gy oj ok l ol om">firebase.auth().onAuthStateChanged(function(user) {<br/>  user.sendEmailVerification();<br/>});</span></pre><p id="0923" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">以下是最终注册操作创建者:</p><figure class="ks kt ku kv gt kw"><div class="bz fp l di"><div class="on oo l"/></div><p class="ld le gj gh gi lf lg bd b be z dk translated">auth.js —使用Firebase Auth注册操作创建者</p></figure></div><div class="ab cl mt mu hx mv" role="separator"><span class="mw bw bk mx my mz"/><span class="mw bw bk mx my mz"/><span class="mw bw bk mx my"/></div><div class="im in io ip iq"><h1 id="807f" class="na nb it bd nc nd ne nf ng nh ni nj nk ki nl kj nm kl nn km no ko np kp nq nr bi translated">步骤3:登录并重定向</h1><p id="6bef" class="pw-post-body-paragraph li lj it lk b ll ns kd ln lo nt kg lq lr nu lt lu lv nv lx ly lz nw mb mc md im bi translated">我们快完成了。正如您将看到的，大部分工作已经完成，剩下的工作非常简单。</p><h2 id="1196" class="oi nb it bd nc oq or dn ng os ot dp nk lr ou ov nm lv ow ox no lz oy oz nq iz bi translated">正在登录</h2><p id="e9d3" class="pw-post-body-paragraph li lj it lk b ll ns kd ln lo nt kg lq lr nu lt lu lv nv lx ly lz nw mb mc md im bi translated">首先，让我们创建我们的操作类型:</p><pre class="ks kt ku kv gt oe ob of og aw oh bi"><span id="0a90" class="oi nb it ob b gy oj ok l ol om"><em class="me">// SIGN IN<br/>export</em> const SIGNIN_SUCCESS = "SIGNIN_SUCCESS";<br/><em class="me">export</em> const SIGNIN_ERROR = "SIGNIN_ERROR";</span></pre><p id="60cb" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">要使用Firebase登录用户，我们使用Firebase Auth的<code class="fe ny nz oa ob b">signInWithEmailAndPassword</code>方法，该方法将电子邮件和密码作为参数:</p><pre class="ks kt ku kv gt oe ob of og aw oh bi"><span id="e43c" class="oi nb it ob b gy oj ok l ol om">firebase.auth().signInWithEmailAndPassword(email, password)</span></pre><p id="e15b" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">以下是完整的<code class="fe ny nz oa ob b">signin</code>动作创建者:</p><figure class="ks kt ku kv gt kw"><div class="bz fp l di"><div class="on oo l"/></div><p class="ld le gj gh gi lf lg bd b be z dk translated">auth.js —使用Firebase Auth登录操作创建者</p></figure><h2 id="7604" class="oi nb it bd nc oq or dn ng os ot dp nk lr ou ov nm lv ow ox no lz oy oz nq iz bi translated">登录后重定向用户</h2><p id="2c8a" class="pw-post-body-paragraph li lj it lk b ll ns kd ln lo nt kg lq lr nu lt lu lv nv lx ly lz nw mb mc md im bi translated">如你所见，我正在给我的<code class="fe ny nz oa ob b">signin</code>动作创建器添加一个回调函数。这是为了在登录后将用户重定向到主组件。</p><p id="08cf" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">为此，我将使用<em class="me"> Firebase reducer </em>，它是我们之前添加到root reducer中的。事实上，Firebase reducer让我们可以访问包含用户数据(如果前者已登录)或以下内容的<code class="fe ny nz oa ob b">auth</code>对象:</p><pre class="ks kt ku kv gt oe ob of og aw oh bi"><span id="2310" class="oi nb it ob b gy oj ok l ol om">auth: { isLoaded: false, isEmpty: true }</span></pre><p id="8b42" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated"><code class="fe ny nz oa ob b">isLoaded</code>表示授权加载状态(当请求待定时，您可以使用它向用户显示加载程序)。<code class="fe ny nz oa ob b">isEmpty</code>如果用户未登录，则为真。</p><p id="af76" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">因此，登录后的流程将是:</p><p id="e5b1" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">1.将用户重定向到与主要组件相对应的根路径<code class="fe ny nz oa ob b">“/”</code>。为此，我们将对<code class="fe ny nz oa ob b">props.history.push(“/”)</code>的调用作为对<code class="fe ny nz oa ob b">signin</code>动作创建者的回调:</p><pre class="ks kt ku kv gt oe ob of og aw oh bi"><span id="0f5a" class="oi nb it ob b gy oj ok l ol om">signin(email, password, <strong class="ob jd">() =&gt; props.history.push("/")</strong>);</span></pre><p id="01c8" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">并且，我们在分派了<code class="fe ny nz oa ob b">SIGNIN_SUCCESS</code>动作之后，在<code class="fe ny nz oa ob b">signin</code>动作创建器中激活这个回调。</p><pre class="ks kt ku kv gt oe ob of og aw oh bi"><span id="40bc" class="oi nb it ob b gy oj ok l ol om"><em class="me">export</em> const signin = (email, password, callback) =&gt; <br/>  async dispatch =&gt; {<br/>    <em class="me">try</em> {<br/>      firebase<br/>      .auth()<br/>      .signInWithEmailAndPassword(email, password)<br/>      .then(data =&gt; {<br/>        <em class="me">if</em> (data.user.emailVerified) {<br/>          dispatch({ type: SIGNIN_SUCCESS });<br/>          <strong class="ob jd">callback();</strong><br/>       } <em class="me">else</em> {<br/>          ...</span></pre><p id="996b" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">2.将<code class="fe ny nz oa ob b">Main</code>组件连接到商店，观察来自Firebase reducer的auth对象，如果<code class="fe ny nz oa ob b">isEmpty</code>为真，则用户未登录，因此显示<code class="fe ny nz oa ob b">Login</code>组件，或者，当用户登录时，显示<code class="fe ny nz oa ob b">Home</code>组件。</p><figure class="ks kt ku kv gt kw"><div class="bz fp l di"><div class="on oo l"/></div><p class="ld le gj gh gi lf lg bd b be z dk translated">连接到Redux store的Main.js组件侦听来自Firebase reducer的auth对象，以便根据auth状态重定向用户。</p></figure><p id="459b" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">这也将处理一个非常重要的事情:<em class="me"> auth persisting </em>。</p><p id="0524" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">这可以确保我们的用户在成功登录后仍然与应用程序保持连接，直到他们正式退出。只需让我们的<code class="fe ny nz oa ob b">Main</code>组件成为我们应用程序的入口点，并监听来自Firebase reducer的auth对象，从而相应地重定向到<code class="fe ny nz oa ob b">Home</code>或登录页面。</p></div><div class="ab cl mt mu hx mv" role="separator"><span class="mw bw bk mx my mz"/><span class="mw bw bk mx my mz"/><span class="mw bw bk mx my"/></div><div class="im in io ip iq"><h1 id="e6ce" class="na nb it bd nc nd ne nf ng nh ni nj nk ki nl kj nm kl nn km no ko np kp nq nr bi translated">第四步:注销</h1><p id="cb9a" class="pw-post-body-paragraph li lj it lk b ll ns kd ln lo nt kg lq lr nu lt lu lv nv lx ly lz nw mb mc md im bi translated">我们再次创建相关的操作类型:</p><pre class="ks kt ku kv gt oe ob of og aw oh bi"><span id="f328" class="oi nb it ob b gy oj ok l ol om"><em class="me">// SIGN OUT<br/>export</em> const SIGNOUT_SUCCESS = "SIGNOUT_SUCCESS";<br/><em class="me">export</em> const SIGNOUT_ERROR = "SIGNOUT_ERROR";</span></pre><p id="52bd" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">对于注销用户，我们使用Firebase Auth的<code class="fe ny nz oa ob b">signOut</code>方法，该方法不带任何参数:</p><pre class="ks kt ku kv gt oe ob of og aw oh bi"><span id="af73" class="oi nb it ob b gy oj ok l ol om"><em class="me">// Signing out with Firebase</em></span><span id="b485" class="oi nb it ob b gy op ok l ol om"><em class="me">export</em> const signout = () =&gt; async dispatch =&gt; {<br/>  <em class="me">try</em> {<br/>    firebase<br/>    .auth()<br/>    .signOut()<br/>    .then(() =&gt; {<br/>      dispatch({ type: SIGNOUT_SUCCESS });<br/>    })<br/>    .catch(() =&gt; {<br/>      dispatch({ <br/>        type: SIGNOUT_ERROR, <br/>        payload: "...some error message for the user..."<br/>      });<br/>    });<br/>  } <em class="me">catch</em> (err) {<br/>    dispatch({ <br/>      type: SIGNOUT_ERROR, <br/>      payload: ...some error message for the user..."<br/>    });<br/>  }<br/>};</span></pre></div><div class="ab cl mt mu hx mv" role="separator"><span class="mw bw bk mx my mz"/><span class="mw bw bk mx my mz"/><span class="mw bw bk mx my"/></div><div class="im in io ip iq"><h1 id="e005" class="na nb it bd nc nd ne nf ng nh ni nj nk ki nl kj nm kl nn km no ko np kp nq nr bi translated">第五步:密码重置</h1><p id="99cd" class="pw-post-body-paragraph li lj it lk b ll ns kd ln lo nt kg lq lr nu lt lu lv nv lx ly lz nw mb mc md im bi translated">同样简单的是密码重置方法。我们使用Firebase Auth的<code class="fe ny nz oa ob b">sendPasswordResetEmail</code>方法，该方法将电子邮件作为参数:</p><pre class="ks kt ku kv gt oe ob of og aw oh bi"><span id="aa3a" class="oi nb it ob b gy oj ok l ol om"><em class="me">// Reset password with Firebase</em></span><span id="8b87" class="oi nb it ob b gy op ok l ol om"><em class="me">export</em> const resetPassword = email =&gt; async dispatch =&gt; {<br/>  <em class="me">try</em> {<br/>    firebase<br/>    .auth()<br/>    .sendPasswordResetEmail(email)<br/>    .then(() =&gt; <br/>      dispatch({<br/>        type: RESET_SUCCESS,<br/>        payload: "Reset email sent. Go check your inbox."<br/>      })<br/>    )<br/>    .catch(err =&gt; {<br/>      dispatch({<br/>        type: RESET_ERROR,<br/>        payload: "...some message for the user..."<br/>      });<br/>    });<br/>  } <em class="me">catch</em> (err) {<br/>    dispatch({ <br/>      type: RESET_ERROR, <br/>      payload: "...some message for the user..." <br/>    });<br/>  }<br/>};</span></pre></div><div class="ab cl mt mu hx mv" role="separator"><span class="mw bw bk mx my mz"/><span class="mw bw bk mx my mz"/><span class="mw bw bk mx my"/></div><div class="im in io ip iq"><h1 id="373c" class="na nb it bd nc nd ne nf ng nh ni nj nk ki nl kj nm kl nn km no ko np kp nq nr bi translated">额外收获:根据授权限制页面访问</h1><p id="6752" class="pw-post-body-paragraph li lj it lk b ll ns kd ln lo nt kg lq lr nu lt lu lv nv lx ly lz nw mb mc md im bi translated">到目前为止，我们已经做了很多，但在下班后去喝酒之前，还有一点需要解决。</p><p id="9d7d" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">为了说明我的观点，我将添加一个名为<code class="fe ny nz oa ob b">Bunny</code>的新组件，并将<code class="fe ny nz oa ob b">Route</code>添加到我的路由器交换机内的<code class="fe ny nz oa ob b">App.js</code>文件中的<code class="fe ny nz oa ob b">Bunny</code>:</p><pre class="ks kt ku kv gt oe ob of og aw oh bi"><span id="a927" class="oi nb it ob b gy oj ok l ol om">&lt;Route <em class="me">exact</em> <em class="me">path</em>="/bunny" <em class="me">component</em>={Bunny} /&gt;</span></pre><p id="eb72" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">现在，如果你没有登录，你改变网址去<code class="fe ny nz oa ob b">“/bunny”</code>，你会看到你可以访问这个组件。我们不想那样。我们需要告诉<code class="fe ny nz oa ob b">Bunny</code>组件，我们只希望经过身份验证的用户能够访问它。</p><p id="8ad6" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">为此，我们将创建一个更高阶的组件，它将包装我们想要限制访问的组件，并且如果用户没有登录，它将侦听来自Firebase auth的Auth对象并重定向到我们的<code class="fe ny nz oa ob b">Main</code>组件。</p><p id="e7a2" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">这是我们的<code class="fe ny nz oa ob b">requireAuth</code> HOC:</p><figure class="ks kt ku kv gt kw"><div class="bz fp l di"><div class="on oo l"/></div><p class="ld le gj gh gi lf lg bd b be z dk translated">requireAuth : HOC根据身份验证状态限制对组件的访问</p></figure><p id="aa65" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">这里是利用<code class="fe ny nz oa ob b">requireAuth</code> HOC的<code class="fe ny nz oa ob b">Bunny</code>组件:</p><pre class="ks kt ku kv gt oe ob of og aw oh bi"><span id="7bf4" class="oi nb it ob b gy oj ok l ol om"><em class="me">import</em> React <em class="me">from</em> "react";<br/><strong class="ob jd"><em class="me">import</em> requireAuth <em class="me">from</em> "./hoc/requireAuth";</strong></span><span id="41da" class="oi nb it ob b gy op ok l ol om">const Bunny = () =&gt; {<br/>  <em class="me">return</em> (<br/>    &lt;div <em class="me">className</em>="page"&gt;...&lt;/div&gt;<br/>  );<br/>};</span><span id="a48e" class="oi nb it ob b gy op ok l ol om"><em class="me">export</em> <em class="me">default</em> <strong class="ob jd">requireAuth(Bunny)</strong>;</span></pre><p id="d4d0" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">我们完事了。</p></div><div class="ab cl mt mu hx mv" role="separator"><span class="mw bw bk mx my mz"/><span class="mw bw bk mx my mz"/><span class="mw bw bk mx my"/></div><div class="im in io ip iq"><h1 id="3d90" class="na nb it bd nc nd ne nf ng nh ni nj nk ki nl kj nm kl nn km no ko np kp nq nr bi translated">结论</h1><p id="1609" class="pw-post-body-paragraph li lj it lk b ll ns kd ln lo nt kg lq lr nu lt lu lv nv lx ly lz nw mb mc md im bi translated">您可以在下面的专用报告中找到React样板应用程序的完整代码，使用Firebase和Redux实现身份验证:</p><div class="pa pb gp gr pc pd"><a href="https://github.com/clairechabas/firebase-auth-react-redux" rel="noopener  ugc nofollow" target="_blank"><div class="pe ab fo"><div class="pf ab pg cl cj ph"><h2 class="bd jd gy z fp pi fr fs pj fu fw jc bi translated">claire chabas/fire base-auth-react-redux</h2><div class="pk l"><h3 class="bd b gy z fp pi fr fs pj fu fw dk translated">这个项目是一个样板文件，用于在React应用程序上使用Firebase Auth初始化一个身份验证系统</h3></div><div class="pl l"><p class="bd b dl z fp pi fr fs pj fu fw dk translated">github.com</p></div></div><div class="pm l"><div class="pn l po pp pq pm pr lb pd"/></div></div></a></div><p id="0dbe" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">您可以根据自己的需要随意使用这个样板文件。</p><p id="c051" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">我希望这篇文章是有帮助的。如果你有任何问题或改进建议，我很乐意在评论中看到。</p><p id="948e" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">快乐编码💛</p></div></div>    
</body>
</html>