<html>
<head>
<title>Understanding Generators in Python</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">理解Python中的生成器</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/understanding-generators-in-python-2c3b9e070c7e?source=collection_archive---------2-----------------------#2020-06-21">https://betterprogramming.pub/understanding-generators-in-python-2c3b9e070c7e?source=collection_archive---------2-----------------------#2020-06-21</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="e60a" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">大数据的顺序方法</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/0325c38927f5909f7a851f369d443777.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*hFS3TwMubg2v1k8A"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">照片由<a class="ae kv" href="https://unsplash.com/@khiettam?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Khiet Tam </a>在<a class="ae kv" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</p></figure><p id="de4c" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">假设你有一系列的步骤。你一次走一步就能到达顶峰。你走一步，也许两步，也许三步，也取决于你一跳能跳过多少步。但是如果楼梯没有尽头呢？如果超过1000步呢。你不能一次跳过所有的。尽管如此，你可以跳到可管理的部分，然后到达顶端。</p><p id="407c" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">Python中的生成器就是这样。它们按顺序把你带到列表或集合或元组的末尾。数据结构或变量占用内存中分配的空间。</p><p id="0097" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">例如，假设我们有一个4 gb的大型数据集。一列有几百万行。当你给该列分配一些内存并试图遍历该列的每个单元格时。记忆崩溃开始！你的机器被压得喘不过气来。我们需要更好的方法。</p><p id="8a97" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">介绍发电机！它们允许我们以块为单位迭代这些大数据结构。</p><h2 id="01b4" class="ls lt iq bd lu lv lw dn lx ly lz dp ma lf mb mc md lj me mf mg ln mh mi mj mk bi translated">发电机</h2><p id="4f54" class="pw-post-body-paragraph kw kx iq ky b kz ml jr lb lc mm ju le lf mn lh li lj mo ll lm ln mp lp lq lr ij bi translated">我们先来看一个问题，然后了解生成器。</p><pre class="kg kh ki kj gt mq mr ms mt aw mu bi"><span id="1d68" class="ls lt iq mr b gy mv mw l mx my">i=0<br/>while True:<br/>    print(i)<br/>    i+=1</span></pre><p id="7c9f" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们有一个<code class="fe mz na nb mr b">while</code>循环，它一直运行到它为真，并且将<code class="fe mz na nb mr b">i</code>的值增加1，从而创建一个无限循环。</p><pre class="kg kh ki kj gt mq mr ms mt aw mu bi"><span id="b4aa" class="ls lt iq mr b gy mv mw l mx my">def run_till_end():<br/>    i=0<br/>    while True:<br/>        return i<br/>        i+=1</span></pre><p id="4a6c" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">现在，我们已经定义了一个函数—当我们调用它时，<code class="fe mz na nb mr b">0</code>将被返回。虽然，我们在函数定义中有一个无限循环，在返回值后它终止。</p><p id="e9e6" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">但是，我们想要每一个值！</p><pre class="kg kh ki kj gt mq mr ms mt aw mu bi"><span id="25c0" class="ls lt iq mr b gy mv mw l mx my">def run_till_end():<br/>    i=0<br/>    while True:<br/>        yield i<br/>        i+=1</span></pre><p id="718f" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这次我们使用了<code class="fe mz na nb mr b">yield</code>来返回输出。<code class="fe mz na nb mr b">yield</code>关键字用于从一个函数返回。再次调用该函数时，从最后一条yield语句开始执行。如果一个函数有<code class="fe mz na nb mr b">yield</code>关键字，它被称为<code class="fe mz na nb mr b">generator</code>。</p><pre class="kg kh ki kj gt mq mr ms mt aw mu bi"><span id="f4de" class="ls lt iq mr b gy mv mw l mx my">a=run_till_end()<br/>print(type(a))<br/>print(next(a)) #0<br/>print(next(a)) #1</span></pre><p id="b886" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">如果运行上面一行代码，函数类型将是<code class="fe mz na nb mr b">generator</code>。使用<code class="fe mz na nb mr b">next</code>方法的第一个打印语句将输出<code class="fe mz na nb mr b">0</code>。第二个会输出<code class="fe mz na nb mr b">1</code>。如果您希望顺序地或成批地输出生成器的值，应该使用下面的方法。</p><p id="533f" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">你可能会在列表上遇到同样的问题。您可以使用此方法从列表中顺序调用值:</p><pre class="kg kh ki kj gt mq mr ms mt aw mu bi"><span id="f92e" class="ls lt iq mr b gy mv mw l mx my">def next_list():<br/>    lst=["foo","baz","bar"]<br/>    for i in lst:<br/>        yield i</span><span id="e053" class="ls lt iq mr b gy nc mw l mx my">a=next_list()<br/>print(next(a))<br/>print(next(a))</span></pre><p id="0639" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这将产生<code class="fe mz na nb mr b">foo</code>和<code class="fe mz na nb mr b">baz</code>作为输出。</p><p id="805f" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">但是如果你在上面的函数中使用了四次next函数呢？在第四次运行时，将抛出错误类型为<code class="fe mz na nb mr b">StopIteration</code>的回溯。当生成器穷尽了数据结构的所有值时，它们会抛出这个<code class="fe mz na nb mr b">StopIteration</code>异常。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nd"><img src="../Images/773133b6746f774bd3980f967d6dc504.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*8J3ns71ji3PBDCmk5uRVKQ.png"/></div></div></figure><p id="ee5c" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">还有另一种创建生成器的方法——它类似于列表理解。</p><pre class="kg kh ki kj gt mq mr ms mt aw mu bi"><span id="a2c5" class="ls lt iq mr b gy mv mw l mx my">list_comprehension=[i for i in range(10)] #create a list</span><span id="3963" class="ls lt iq mr b gy nc mw l mx my">generators=(i for i in range(10)) #create a generator</span></pre><p id="cd7e" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">当你调用这些对象<code class="fe mz na nb mr b">list_comprehension</code>和<code class="fe mz na nb mr b">generators</code>时，前者会输出一个列表，后者会输出一个生成器对象。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi ne"><img src="../Images/05049e8f2c8714259b36f22220daecf1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*PolYaBZ8vvgCRCXsMmQmJQ.png"/></div></div></figure><ul class=""><li id="b469" class="nf ng iq ky b kz la lc ld lf nh lj ni ln nj lr nk nl nm nn bi translated">列表理解有方括号:<code class="fe mz na nb mr b">[ ]</code></li><li id="6738" class="nf ng iq ky b kz no lc np lf nq lj nr ln ns lr nk nl nm nn bi translated">生成器理解有左括号:<code class="fe mz na nb mr b"> ( )</code></li></ul></div><div class="ab cl nt nu hu nv" role="separator"><span class="nw bw bk nx ny nz"/><span class="nw bw bk nx ny nz"/><span class="nw bw bk nx ny"/></div><div class="ij ik il im in"><h1 id="d242" class="oa lt iq bd lu ob oc od lx oe of og ma jw oh jx md jz oi ka mg kc oj kd mj ok bi translated">空间和时间分析</h1><p id="d18f" class="pw-post-body-paragraph kw kx iq ky b kz ml jr lb lc mm ju le lf mn lh li lj mo ll lm ln mp lp lq lr ij bi translated">我在为分析做一个清单和一个生成器。两者都有一百万个数的平方值。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi ol"><img src="../Images/a58f1a454263fc5c80d2812afcfe9a23.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*cWWkn3QazVOVdUQc4GMhBA.png"/></div></div></figure><p id="20fc" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这是一个令人惊讶的结果。在一个案例中，8697472字节被分配给内存，而生成器理解只占用了128字节。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi om"><img src="../Images/03b088d804d7aa16aa28c3acb16f88d5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*9kGjDNSge92Ibocx6-vvgw.png"/></div></div></figure><p id="ee99" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">说到时间，生成器需要的不仅仅是列表理解。因此生成器理解占用更少的空间和时间。</p></div><div class="ab cl nt nu hu nv" role="separator"><span class="nw bw bk nx ny nz"/><span class="nw bw bk nx ny nz"/><span class="nw bw bk nx ny"/></div><div class="ij ik il im in"><h1 id="79ac" class="oa lt iq bd lu ob oc od lx oe of og ma jw oh jx md jz oi ka mg kc oj kd mj ok bi translated">摘要</h1><p id="164b" class="pw-post-body-paragraph kw kx iq ky b kz ml jr lb lc mm ju le lf mn lh li lj mo ll lm ln mp lp lq lr ij bi translated">我研究了Python中的生成器概念。文章包括以下主题:</p><ul class=""><li id="343f" class="nf ng iq ky b kz la lc ld lf nh lj ni ln nj lr nk nl nm nn bi translated">Yield关键字</li><li id="8d59" class="nf ng iq ky b kz no lc np lf nq lj nr ln ns lr nk nl nm nn bi translated">发电机怎么用？</li><li id="c96b" class="nf ng iq ky b kz no lc np lf nq lj nr ln ns lr nk nl nm nn bi translated">空间和时间分析</li></ul></div></div>    
</body>
</html>