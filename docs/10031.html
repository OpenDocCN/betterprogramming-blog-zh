<html>
<head>
<title>Practical Big O Notation for JavaScript Developers</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">面向JavaScript开发人员的实用大O符号</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/practical-big-o-notation-for-javascript-developers-115f6368085d?source=collection_archive---------6-----------------------#2021-11-16">https://betterprogramming.pub/practical-big-o-notation-for-javascript-developers-115f6368085d?source=collection_archive---------6-----------------------#2021-11-16</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="f5d6" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">理解这一工具的实用方法</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/5497033c836562550766bf882a6d9235.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*xwm8vqHbiBEo9JT5ivszng.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">由<a class="ae ky" href="https://unsplash.com/@xavi_cabrera?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">哈维·卡夫雷拉</a>在<a class="ae ky" href="https://unsplash.com/s/photos/o-mouth?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>拍摄的原始照片，由作者编辑</p></figure><p id="4b02" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">大O符号是我们在接受某种形式的正规教育(即大学)时通常会学到的东西之一，否则我们日常生活的实际方面会超出它的范围，让它成为一个完全次要的术语，我们可以没有它——你们很多人都是这样！</p><p id="a6eb" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">话虽如此，我仍然相信在高层次上理解这个符号是有好处的。快速理解算法的性能含义不仅有用，而且非常实用。</p><p id="c3ff" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">所以让我们快速地看一下什么是大O符号，以及你应该注意什么。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="3a6b" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">什么是大O记数法？</h1><p id="c6ec" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">大O符号只不过是一种描述算法复杂性和性能的数学方法。</p><p id="ce06" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我拒绝深入研究如何计算精确的表达式，因为老实说，你可能永远都不需要它。相反，你只需要它的缩略版本，这将让你知道一旦需要处理的值的数量增加，算法的复杂性会增长得多快。</p><p id="8201" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我这么说吧:大O符号是一种图形化表示算法复杂度增长速度的方法，同时它需要的数据点数量接近无穷大。或者这也是一种比较同一个域中两种算法的方法，具有较低BigO符号的算法通常更好，至少在性能方面。</p><p id="da7f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我知道，这听起来并不容易，但让我告诉你我的意思:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi mz"><img src="../Images/07ed81b46bb1ac42044aff9177bcd0c2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*fIkoSLU5yvhhYlZ3plniPw.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">图片取自<a class="ae ky" href="https://www.bigocheatsheet.com/" rel="noopener ugc nofollow" target="_blank"> <strong class="bd na"> BigOCheatSheet </strong> </a></p></figure><p id="14ca" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">请看上图，Y轴表示复杂度，而X轴表示算法要处理的元素数量(这里的“元素”可以是从变量数量到潜在的不同值，甚至是需要执行的指令数量，我们将看到一些例子)。</p><p id="31e3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我不会在这里深入讨论每一个选项，因为同样，如果您直到现在还没有使用过BigO，那么您已经可以通过理解O(n！)、<code class="fe nb nc nd ne b">O(nlogn)</code>、O <code class="fe nb nc nd ne b">(n)</code>、<code class="fe nb nc nd ne b">O(logn)</code>、<code class="fe nb nc nd ne b">O(1)</code>的意思。其余的都介于两者之间，读完这篇文章后，你应该能够确定它们是否对你有益。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="1848" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">O(n！)</h1><p id="0d1e" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">让我们从最坏的情况开始，O(n！)案例，就是上面图表中的黑线。</p><p id="f1b0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">有时你无法避免，但是如果可以的话，你应该试着远离这些类型的算法，因为它们是最糟糕的算法。</p><p id="995c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu">注意:</strong>如果你发现自己无法在不到<strong class="lb iu"> n的时间内用线性方法解决问题！</strong>时间，然后考虑替代方案，如并行处理、分布式计算或其他可能产生更好结果的更复杂的解决方案。</p><p id="d95c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">但是除了个人注释之外，一些算法，比如寻找一个值列表的所有排列，或者甚至计算一个值的阶乘数，都有非常常见的O(n！)解决方案。</p><p id="2f2e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">还有，另一个很常见的要解决的问题，比如计算斐波那契数列。如果你递归地做这件事——除非你使用的编程语言有“尾部调用优化”(而JS没有)，你会遇到非常小的数字的问题——你会得到一个O(n！)算法。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="2a49" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">O(nlogn)</h1><p id="d4bc" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">我认为理解这个特殊的数量级很重要，因为许多常见的算法都属于这个数量级。</p><p id="85c5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">特别是合并排序、堆排序、快速排序等排序算法都会有这种性能。这意味着，如果您试图用它们对足够多的元素进行排序，执行时间将不会很好地伸缩。事实上，它们会继续快速上升。</p><p id="d9ee" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">许多开发人员声称JavaScript的<code class="fe nb nc nd ne b">Array.sort</code>方法具有O(nlogn)的大O复杂度，但实际上，这取决于运行时使用的实现。例如，Firefox使用合并排序，所以作为一种常见的执行复杂度，O(nlogn)是正确的。然而，例如V8运行时(以及Chrome、Node.js甚至Deno)，使用<a class="ae ky" href="https://v8.dev/blog/array-sort" rel="noopener ugc nofollow" target="_blank"> Timsort </a>合并排序和插入排序的混合，最好的情况是O(n ),如果你从上面回到图表，它会好得多。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="3231" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">O(n)</h1><p id="e5f7" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">图表上的绿线可以解读为:你的算法将不得不遍历每一个数据点来执行手头的任务。要处理的数据点越多，花费的时间就越多。</p><p id="4149" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这些不一定是糟糕的算法，但如果n的值(即数据点的数量)打算增长得相当高，那么你必须考虑其影响，甚至可能进行某种优化。</p><p id="a179" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">经典的O(n)算法需要遍历列表中的所有元素来执行一个操作，例如，想象一下必须计算数组中奇数值的数量:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nf ng l"/></div></figure><p id="fdcd" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果我们处理数组中的10个元素，它会遍历所有的元素，但是会很快。但是，如果您的数组突然包含1.000.000个元素，这需要一段时间，因为它的复杂性也相应地增加了。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="9993" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">o(登录)</h1><p id="0717" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">蓝线(log2 n)告诉你，虽然复杂性会增加，但会增长得很慢，更好的是，增长率是有上限的。无论你增加多少数据点，它都不会超过某一点。这是一个非常好的算法，它可以扩展得相当高。</p><p id="478f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">一个经典的<code class="fe nb nc nd ne b">O(logn)</code>算法的例子是二分搜索法，它不断地将问题领域一分为二。</p><p id="a391" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果你不熟悉这个算法，这里有一个快速的运行，总是假设你在元素的排序列表中寻找一个值。</p><ol class=""><li id="166d" class="nh ni it lb b lc ld lf lg li nj lm nk lq nl lu nm nn no np bi translated">您识别列表中间的元素。</li><li id="bb0a" class="nh ni it lb b lc nq lf nr li ns lm nt lq nu lu nm nn no np bi translated">你比较你的目标值和中间值。如果匹配，你就完成了。否则，继续3。</li><li id="8384" class="nh ni it lb b lc nq lf nr li ns lm nt lq nu lu nm nn no np bi translated">如果目标值低于中间值，放下右侧列表，从左侧列表的步骤1开始重复。</li><li id="e203" class="nh ni it lb b lc nq lf nr li ns lm nt lq nu lu nm nn no np bi translated">如果目标值高于中间值，放下左侧列表，从右侧的步骤1开始重复。</li><li id="c8b4" class="nh ni it lb b lc nq lf nr li ns lm nt lq nu lu nm nn no np bi translated">重复该过程，直到找到目标或用完要比较的值。</li></ol><p id="b41d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这个算法的神奇之处在于，如果你增加列表中元素的数量，由于你不断地减少一半，你仍然可以很快完成。</p><p id="a7a4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">例如，在最坏的情况下，如果您有1.000.000个元素，您将不得不比较这些值20次。没错，20次(和13.8相当接近，是<code class="fe nb nc nd ne b">logn(1000000)</code>的值)。</p><p id="d5db" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果你考虑一下，你会从1.000.000到20，从O(n)到<code class="fe nb nc nd ne b">O(logn)</code>有一个变化。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="3509" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">O(1)</h1><p id="2431" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">或者其他人所说的恒定时间。</p><p id="6b4c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这是一个理想的符号，它意味着你总是能够执行你正在寻找的动作，而不用关心你必须处理的元素的数量。</p><p id="3e61" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果你能写出一个算法来实现恒定的时间，那么投入时间和精力绝对是值得的。</p><p id="c175" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这方面的一个例子是使用一个对象文字与使用多个IF语句来决定如何处理您的逻辑。让我用一个例子来解释，想象有这样的代码:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nf ng l"/></div></figure><p id="c202" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">最坏的情况是，代码检查每个IF语句，然后返回默认行为。当然，根据你决定<code class="fe nb nc nd ne b">myValue</code>值的外部逻辑，你可以认为你的最佳情况要好得多，10次中有8次<code class="fe nb nc nd ne b">myValue</code>的值是1。然而，我们做了最坏的打算，希望有最好的结果。由于我们有一个算法正在检查“n”乘以<code class="fe nb nc nd ne b">myValue</code>的值，我们可以说现在它的大O符号是<strong class="lb iu">O(n)</strong>——请注意，对于非常小数量的“n”，但尽管如此，如果您经常调用此函数，它可能会影响性能。</p><p id="ac5a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们能改进它吗？我会说是的，我们可以，让我们来看看:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nf ng l"/></div></figure><p id="840c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在你可能完全喜欢这个解决方案，也可能不完全喜欢，但是它不再检查每个值。实际上，它是在直接访问它应该调用的函数。由于我们正在为最坏的情况做准备，在我们的“最坏情况”中，首先检查索引在<code class="fe nb nc nd ne b">logic</code>中的存在，然后调用<code class="fe nb nc nd ne b">doTheDefaultThing</code>，这将是O(2)的一个大O符号，同样，对于潜在的数百万个调用来说，它是一个常数，因此我们可以安全地忽略2，并将其称为<code class="fe nb nc nd ne b">O(1)</code> <strong class="lb iu">。</strong></p><p id="b6b8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果你从头回到图表，这将是粉红色的线。当然，并不是每个算法都是O(1)。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><p id="c0d7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">大O符号无非是一个工具。它有助于我们在同一个空间内比较算法，并且一目了然地了解它们的性能如何，而不必阅读大量关于它们的文档或基准。</p><p id="7b1b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">许多库甚至其他软件产品也会使用这种符号，Redis就是一个典型的例子。Redis的文档说明了它的所有命令的大O符号，这有助于您理解考虑到它们将要交互的记录的数量，您是否应该使用它们。</p><p id="3f2f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">请记住，这也是一种“最坏情况”类型的测量，在适当的情况下，您仍然可以使用<code class="fe nb nc nd ne b">O(n^2)</code>算法。</p><p id="8483" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果你不知道大O是什么意思，或者如果你有任何进一步的问题，请留下评论，我很乐意帮助你理解这个概念！</p></div></div>    
</body>
</html>