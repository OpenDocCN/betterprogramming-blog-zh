<html>
<head>
<title>The Pros and Cons of Functional Components in React</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">React中功能组件的优缺点</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/pros-cons-of-functional-components-in-react-f52bded98db0?source=collection_archive---------8-----------------------#2020-07-06">https://betterprogramming.pub/pros-cons-of-functional-components-in-react-f52bded98db0?source=collection_archive---------8-----------------------#2020-07-06</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="ee20" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">功能组件比类组件更好实现吗？如果有，为什么？</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/d4eb9c1809b9e9e3e786ed3f6320f330.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*-OTV_N2smmbZk4qc"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated"><a class="ae kv" href="https://unsplash.com/@mangofantasy?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">蒂姆·约翰逊</a>在<a class="ae kv" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍照。</p></figure><p id="0a19" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在这篇文章中，我将解释什么是功能组件，以及何时应该在应用程序中使用它们！首先，我将快速概述一下类组件。然后，我们将进入功能组件。</p></div><div class="ab cl ls lt hu lu" role="separator"><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx"/></div><div class="ij ik il im in"><h1 id="0db9" class="lz ma iq bd mb mc md me mf mg mh mi mj jw mk jx ml jz mm ka mn kc mo kd mp mq bi translated">什么是类组件？</h1><p id="e741" class="pw-post-body-paragraph kw kx iq ky b kz mr jr lb lc ms ju le lf mt lh li lj mu ll lm ln mv lp lq lr ij bi translated">类组件有时被归类为智能组件或有状态组件，因为它们实现逻辑和状态。它们是ES6类，包含React中的<code class="fe mw mx my mz b">Component</code>类。生命周期方法可以在这些组件内部使用(<code class="fe mw mx my mz b">componentDidUpdate</code>、<code class="fe mw mx my mz b">componentDidMount</code>等)。).类组件有点复杂，因为你不仅要跟踪生命周期方法，还要跟踪它们的副作用，比如重新渲染和数据流管理。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="na nb l"/></div></figure></div><div class="ab cl ls lt hu lu" role="separator"><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx"/></div><div class="ij ik il im in"><h1 id="aebb" class="lz ma iq bd mb mc md me mf mg mh mi mj jw mk jx ml jz mm ka mn kc mo kd mp mq bi translated">功能组件</h1><p id="d005" class="pw-post-body-paragraph kw kx iq ky b kz mr jr lb lc ms ju le lf mt lh li lj mu ll lm ln mv lp lq lr ij bi translated">功能组件是返回React元素的JavaScript(或ES6)函数。它们更容易理解，因为不像类组件那样会发生很多事情。它们也可以写成简单的JS函数或使用ES6语法的arrow函数，它们的属性作为参数(如果有的话)传入。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="na nb l"/></div></figure><p id="a18f" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">与类组件不同，功能组件是无状态的，<strong class="ky ir"> </strong>这意味着没有生命周期方法或状态管理。然而，React钩子为我们提供了这样做的函数，比如<code class="fe mw mx my mz b">useState()</code> &amp; <code class="fe mw mx my mz b">useEffect()</code>。要了解更多关于钩子的信息，请查看文档。</p><h2 id="66b6" class="nc ma iq bd mb nd ne dn mf nf ng dp mj lf nh ni ml lj nj nk mn ln nl nm mp nn bi translated">赞成的意见</h2><ul class=""><li id="3a0b" class="no np iq ky b kz mr lc ms lf nq lj nr ln ns lr nt nu nv nw bi translated">更容易测试:您不必担心隐藏状态，而且在涉及功能组件时也不会有太多副作用，因此对于每个输入，函数都有一个输出。</li><li id="f719" class="no np iq ky b kz nx lc ny lf nz lj oa ln ob lr nt nu nv nw bi translated">更容易读/写:语法没有类组件复杂，而且更容易阅读，因为你已经知道你不能用功能组件做什么了。prop析构的使用使得查看组件发生了什么和输出了什么变得非常有用。</li><li id="3047" class="no np iq ky b kz nx lc ny lf nz lj oa ln ob lr nt nu nv nw bi translated">更容易调试:同样，功能组件依赖于它们被赋予的道具，不会在<code class="fe mw mx my mz b">state</code>上回复。没有理由让你的<code class="fe mw mx my mz b">state</code>不断了解正在发生的变化。</li></ul><h2 id="3c94" class="nc ma iq bd mb nd ne dn mf nf ng dp mj lf nh ni ml lj nj nk mn ln nl nm mp nn bi translated">骗局</h2><ul class=""><li id="79f1" class="no np iq ky b kz mr lc ms lf nq lj nr ln ns lr nt nu nv nw bi translated">重新学习新的语法:语法乍一看可能不寻常，并且很难掌握，因为类组件已经存在了很长时间。在类中，声明一个呈现函数。有了函数，你就没有了。为了在类中传递属性，您可以将它们作为类属性发送给组件，或者在组件下声明默认属性。相比之下，功能组件将道具作为参数发送。如果其他开发人员不习惯以这种方式编写他们的应用程序，理解这样的差异可能会很困难。</li><li id="ed82" class="no np iq ky b kz nx lc ny lf nz lj oa ln ob lr nt nu nv nw bi translated">性能优化:在哪些组件对您的性能更有好处方面，实际上并没有什么不同；然而，由于功能组件不能访问像<code class="fe mw mx my mz b">shouldComponentUpdate</code>和<code class="fe mw mx my mz b">PureComponent</code>这样的方法，为了性能而优化它们可能有点不方便。</li></ul></div><div class="ab cl ls lt hu lu" role="separator"><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx"/></div><div class="ij ik il im in"><h1 id="925f" class="lz ma iq bd mb mc md me mf mg mh mi mj jw mk jx ml jz mm ka mn kc mo kd mp mq bi translated">结论</h1><p id="73a9" class="pw-post-body-paragraph kw kx iq ky b kz mr jr lb lc ms ju le lf mt lh li lj mu ll lm ln mv lp lq lr ij bi translated">就功能性而言，功能组件变得和类组件一样了。开发人员通常使用功能组件，如果他们只是渲染一些东西，不需要传递状态或使用生命周期方法。</p><p id="2da8" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">虽然如前所述，钩子是在React版本中引入的。这允许开发人员使用生命周期方法和功能组件状态！不建议回到你的应用程序，把你的类转换成功能组件，因为状态的操作方式和生命周期的工作方式是不同的。</p><p id="3bce" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">一定要在新的应用程序中尝试功能组件，你会惊讶地发现你能创造出什么！</p></div><div class="ab cl ls lt hu lu" role="separator"><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx"/></div><div class="ij ik il im in"><h1 id="ea61" class="lz ma iq bd mb mc md me mf mg mh mi mj jw mk jx ml jz mm ka mn kc mo kd mp mq bi translated">资源</h1><div class="oc od gp gr oe of"><a href="https://overreacted.io/how-are-function-components-different-from-classes/" rel="noopener  ugc nofollow" target="_blank"><div class="og ab fo"><div class="oh ab oi cl cj oj"><h2 class="bd ir gy z fp ok fr fs ol fu fw ip bi translated">函数组件和类有什么不同？</h2><div class="om l"><h3 class="bd b gy z fp ok fr fs ol fu fw dk translated">React函数组件与React类有何不同？有一段时间，标准答案是类…</h3></div><div class="on l"><p class="bd b dl z fp ok fr fs ol fu fw dk translated">反应过度了</p></div></div><div class="oo l"><div class="op l oq or os oo ot kp of"/></div></div></a></div><div class="oc od gp gr oe of"><a href="https://reactjs.org/docs/hooks-intro.html" rel="noopener  ugc nofollow" target="_blank"><div class="og ab fo"><div class="oh ab oi cl cj oj"><h2 class="bd ir gy z fp ok fr fs ol fu fw ip bi translated">介绍钩子-反应</h2><div class="om l"><h3 class="bd b gy z fp ok fr fs ol fu fw dk translated">钩子是React 16.8中的新增功能。它们允许您使用状态和其他React特性，而无需编写类。这个…</h3></div><div class="on l"><p class="bd b dl z fp ok fr fs ol fu fw dk translated">reactjs.org</p></div></div><div class="oo l"><div class="ou l oq or os oo ot kp of"/></div></div></a></div></div></div>    
</body>
</html>