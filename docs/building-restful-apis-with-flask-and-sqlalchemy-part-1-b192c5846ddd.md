# 用 Flask 和 SQLAlchemy 构建 Restful APIs(第 1 部分)

> 原文：<https://betterprogramming.pub/building-restful-apis-with-flask-and-sqlalchemy-part-1-b192c5846ddd>

## 立即创建您的第一个 Python API

![](img/85c0024fdabc9063ffb3705620230154.png)

阿里·洛克汉瓦拉在 [Unsplash](https://unsplash.com?utm_source=medium&utm_medium=referral) 上的照片

我决定写一篇关于用 Flask 构建 RESTful APIs 的文章。因此，我们将为待办事项应用程序构建一个 API。该 API 将允许用户登录、创建、读取、更新和删除待办事项，但不能看到其他用户创建的待办事项。

也将有一个管理部分。作为管理员，您可以看到所有用户和待办事项的详细信息。管理员也可以过滤他们的搜索结果。

这将是一段漫长的旅程——因此，我决定将这篇文章分成三部分。这一部分将只关注构建用户和待办事项功能。第二部分将介绍身份验证和授权。最后一节将关注代码重构和错误处理。我还将向您介绍 Flask-Restful，这是一个 Flask 扩展，用于使用 Flask 轻松构建 RESTful APIs。

我很兴奋能和你一起开始，我希望你也是。

![](img/8018178b3cb3244b6cd8c2728086f1d5.png)

照片由[史蒂夫·哈拉马](https://unsplash.com/@steve3p_0?utm_source=medium&utm_medium=referral)在 [Unsplash](https://unsplash.com?utm_source=medium&utm_medium=referral) 上拍摄

# 入门指南

## 微观框架

Flask 是 Python 中 web 开发(后端)的微框架。尽管它是一个微框架，但我们可以构建一个复杂的应用程序，它可以很好地与 Flask 一起伸缩。

那么*微框架* 是什么意思呢？这意味着它不会把任何东西强加给我们——我们可以决定使用一种工具而不是另一种。本文将带您了解如何用 Flask 构建 restful APIs。如果你是 Flask 的新手，并且想了解如何设置 Flask 应用程序，你可以阅读我的文章[中关于这方面的内容。](https://medium.com/swlh/building-your-first-flask-app-753638ef9d7)

## 应用程序接口

在我们开始在 Flask 中构建我们的 API 之前，让我们先来定义什么是 API，并确定我们的 API 将会如何。API 代表应用程序编程接口，它就像一个连接/中介，允许两个应用程序相互通信——比如服务器和客户端。

服务器是后端(在这种情况下，是 Flask)，但客户端不一定是 web 浏览器，它可以是移动应用程序或单页应用程序(SPA)。这是 API 重要的一个原因。[这篇文章](https://www.freecodecamp.org/news/what-is-an-api-in-english-please-b880a3214a82/)深入探讨了什么是 API*。*

现在我们已经了解了什么是 API，让我们更深入地讨论 Restful APIs。RESTful APIs 允许我们使用 HTTP 请求(`GET`、`POST`、`PUT`、`DELETE`、`PATCH`等)。).构建 Restful APIs 时需要遵循一些规则——我将在下面列出。

1.  **客户端—服务器:**客户端和服务器相互独立。
2.  **无状态:**客户端发送的请求必须包含所有必要的信息；服务器不得存储有关客户端的任何状态。
3.  **缓存:**服务器可以将响应标记为可缓存或不可缓存。
4.  统一资源:客户端必须使用统一的、定义良好的、标准化的协议来访问服务器。大多数 RESTful APIs 中常用的协议是 HTTP 和 HTTPS 协议。
5.  **分层系统:**可以在客户端和服务器之间插入代理服务器来提高性能。
6.  客户端可以选择从服务器下载代码。
7.  大多数 API 用 **JSON** 响应，但有些使用 XML(不常见)。
8.  允许**过滤数据**。

## HTTP 动词

我上面提到了 HTTP 动词，但是它们是什么呢？

HTTP 动词只是我们用来告诉端点我们想要做什么的方法。虽然有些 HTTP 动词可以用来代替其他的，但这不是一个好的做法。使用最恰当的动词提出或处理请求。HTTP 动词有很多——有些是`GET`、`POST`、`PUT`、`PATCH`、`DELETE`、`HEAD`等。我将解释四种最常见的。

1.  `GET`:`GET`方法用于从服务器获取资源。它根据资源路径从服务器获取数据，资源路径可能包括用于过滤我们想要返回的内容的查询参数。从使用此方法的资源路径返回的状态代码应该是 200，表示正常。
2.  `POST`:`POST`方法用于为服务器创建一个新的资源。从使用此方法的资源路径返回的状态代码应该是 201，表示已创建。该资源不应返回任何值。
3.  `PUT`:`PUT`方法用于更新服务器中的资源。从使用此方法的资源路径返回的状态代码应该是 200，表示正常，或者 204，表示没有内容。
4.  `DELETE`:`DELETE`方法用于删除服务器上的资源。从使用此方法的资源路径返回的状态代码应该是 200，表示正常，或者 204，表示没有内容。

## 构建我们的 API

既然我们已经花了一些时间来理解什么是 API，那么让我们来考虑我们的 API 将是什么以及如何构造的。我可以决定从服务器或单个用户获取所有用户的数组。我还可以创建用户或更新用户详细信息。所有这些都有各自的 HTTP 请求。

*   `GET users/`:检索所有用户
*   `GET users/id/`:检索单个用户
*   `POST users/`:创建新用户
*   `PUT users/id/`:更新现有用户
*   `DELETE users/id/`:删除已有用户
*   `GET todos/`:检索所有待办事项
*   `Get todos/id/`:检索单个待办事项
*   `POST todos/`:创建新的待办事项
*   `PUT todos/id/`:更新现有的待办事项
*   `DELETE todos/id/`:删除现有的待办事项

## SQLAlchemy

现在我们来谈谈 SQLAlchemy。

SQLAlchemy 到底是什么？SQLAlchemy 是一个对象关系映射器(ORM)。这意味着使用 SQLAlchemy，我们不必编写原始的 SQL 命令。我们所需要做的就是以类(对象)的形式创建模型，SQLAlchemy 将完成将它们转换成 SQL(关系数据库)的工作——因此得名*对象关系映射器。*

我们可以用 ORM 做很多事情——从做普通的查询到插入、更新和删除，再到做高级的事情，比如连接、合并等等。SQLAlchemy 官网有更多信息[这里](https://www.sqlalchemy.org/) *。*但是在本文中，我们将使用 SQLAlchemy 的 Flask 包装器，即 [Flask-SQLAlchemy](https://flask-sqlalchemy.palletsprojects.com/en/2.x/) 。

## 创建我们的 API

让我们开始创建我们的 API。我们将从安装依赖项开始。我们只需要两个:烧瓶和烧瓶-SQLAlchemy。

让我们设置我们的 Flask 应用程序，我将使用 Postman 来测试我的 API——如果你不知道那是什么，你可以在这里查看*。*

我简单说几个关于 Postman 的事情，以及它有多好用。Postman 是一个用于验证项目 API 的交互式自动工具。Postman 是一款谷歌 Chrome 桌面应用(曾经是 Chrome 的扩展)，用于与 HTTP APIs 交互。它还支持 GraphQL。它为您提供了一个友好的 GUI 来构造请求和读取响应。

如果您愿意，您可以随时使用任何 HTTP 库来测试 API。

![](img/cd6005e5525e478c478e54633aa2580f.png)

让我们测试应用程序。用`flask run`、**、**运行服务器，向`localhost:5000/`发送请求。

![](img/3cb1df571d7c92c90ffe8380ce9c7593.png)

我们可以看到，当我们向端点`/`、**、**发送请求时，我们得到了我们想要的，这意味着一切都运行良好。

是时候构建我们的用户和待办事项模型了，这样我们就可以为用户模型定义端点。这两个模型将具有一对多的关系，即一个用户可以有多个待办事项，而一个待办事项需要有一个用户。

![](img/119222c8eb3120ecb9b9e0a05181f4b8.png)

这里发生了很多事！我们来详细的过一遍。

首先，我们从 Flask-SQLAlchemy 导入 SQLAlchemy，并将其连接到我们的应用程序。

接下来，我们在应用程序中添加了两个`config`变量。第一个是密钥，这是一个用于保护我们的应用程序的秘密变量。它被一些与安全性有关的中间件(扩展)使用(目前我们还没有——当我们到达认证部分时，我们将使用它)。第二个是`SQLALCHEMY_DATABASE_URI`，它是我们应用程序的数据库 curl。这里我使用的是 SQLite，但是您也可以使用您选择的任何 SQL 数据库(例如 MySQL)。那么该值将是`mysql://username:password@server/db`。你可以查看他们的官方文档[以获得更多细节和其他配置变量的列表。](https://flask-sqlalchemy.palletsprojects.com/en/2.x/config/)

然后我们定义了我们的用户模型，它从`db.Model` 类扩展而来。

最后，我们定义了列。`db.Column`用于创建一个列。我们定义的第一列是由 SQL 自动创建的`id`、**、**。第二列是姓名和电子邮件字段，必须是字符串。此外，电子邮件字段是唯一的。

我还添加了一个`public_id`字段，这是我希望用作路由参数的字段，因为 SQL 将`id`作为一个整数给出，我希望有一个类似于 UUID 值的值，类似于我们从 Mongo ID 中得到的值。

我还添加了一个`is_admin` 字段/列，我们将使用它进行授权。

最后，我们添加了一个`todos`字段，顾名思义(关系)，它是我们用来连接到待办事项模型的。这部分取三个值:第一个和其他类似，是它所在的字段类型。第二个是`backref`，是我们用来引用待办模型中用户模型的字段(变量)。最后一个参数是`lazy`，这就是数据是如何加载的。

待办事项模型类似于用户模型。它有`id`、`name`、`is_completed`和`user_id`字段，最后一个字段是外键，即用于引用另一个模型的键。通过这个`user_id`字段，我可以获得一个待办事项应用程序的用户 ID，通过 owner 字段(来自`backref`，我可以获得创建该待办事项的用户。

现在，即使数据库存在，模型本身还没有被创建。要创建这些，您可以打开数据库驱动程序。但是如果你正在使用 SQLite 并且没有数据库驱动，你可以在导入`db` 变量后打开你的终端并运行`db.create_all()` 。这将创建数据库以及用它定义的所有模型。另一个有用的方法是`db.drop_all()`，，它做的正好相反。

打开一个烧瓶外壳，让我们测试我们的模型。

![](img/3dd51d7022143ef16df71b8ff3d4c700.png)

如您所见，尝试从用户模型进行查询时出现了错误，因为我还没有创建数据库。

有一个 Flask 扩展充当我们和 SQLAlchemy(以及 Flask SQLAlchemy)之间的中间人。它给了我们一个命令，帮助我们创建和管理我们的模型。它使用 [Alembic](https://alembic.sqlalchemy.org/en/latest/) 来实现这一点。这样做的好处是，如果我们将来要更新我们的模型，我们需要做的只是运行一些命令，数据库就会被更新。如果我们不使用这个扩展，我们将不得不自己处理它。

![](img/343bf16a90f6ebcb50a1f75b64db98c1.png)

运行`db.create_all()`后，这些模型已经创建好了，我们可以查询了。

`db.Model`对象将我们的模型暴露给我们用来查询它们的查询方法。我们可以做很多查询—我们已经看到了`all`，它返回所有行的数组；`first`，返回查询中的第一行；`filter` 和`filter_by`用于过滤我们的查询；`get` 接受一个 ID 并返回具有该 ID 的行；如果查询本身(`get`或`first`)返回`None`，则`first_or_404`和`get_or_404`返回 404。

让我们在数据库中插入一些行。

![](img/2020097b59c3cfaa500f8df6e547e7e7.png)![](img/aa805e661bc6a7c23c411646879c4573.png)

从图像中，我使用了公共 ID 的`uuid`模块，以使其唯一。我创建了该对象的一个实例，并将其存储在一个变量中，但实际上还没有创建行。我通过获取`babs.id`、**、**的值确认了这一点，但没有给出任何值。

函数`db.session.add`向数据库临时添加一个变量。第二个功能`db.session.commit`，永久保存。其他函数包括`db.session.add_all`，它获取要添加到数据库中的对象数组，以及`db.session.delete`，它删除一个对象。

数据库对象在终端中的表示方式是使用类定义中的`__repr__` 方法完成的。`todo`方法也类似。但是当我们向数据库添加一个新的`todo`时，对象将有一个新的属性所有者，我们将它用作用户模型的`backref`。`todo`对象也存储在`user.todos`对象中。

## 端点

现在让我们开始创建端点。

让我们创建获取所有用户和获取单个用户的端点。

![](img/fd9b2b3dbdad6979a3df254f44df6714.png)

这两个函数的端点在`app.route`装饰器中给出。如果我们返回一个字典，Flask 会自动将它转换成 JSON，这就是为什么我们没有在第二个函数中使用`jsonify`函数。

在`get_users`函数中，我们返回一个用户数组。我们没有返回`id`，而是返回了`public_id`，它被用作路由参数。默认的状态码是 200，所以我们不需要在这里传递它。现在让我们测试这些端点。

![](img/67b7ba386c2b5cdd0fe41ea503497835.png)![](img/4424bdad595a7d1ad090aa744107d4d4.png)

下一步是为创建、更新和删除用户创建端点。

![](img/ae7769ddd4f6654cdc8dd5a7a1f383d0.png)

这个函数的装饰器接受另一个参数`method`、**、**，默认情况下是`[‘GET’]`。我们在这里把它指定为一个`POST`的方法。

`create_user`函数`POST`接收一位 JSON 数据。它首先验证给定的姓名和电子邮件，并且长度至少为四个字符(在前端也会有一些验证)。我们还可以使用正则表达式进行一些更高级的验证，但这不在本文的讨论范围之内。

我们最终创建了行，并将其保存到数据库中。我们返回用户的 JSON 数据和状态代码 201。

![](img/e0d967eae2bd0e18a804fbe1771725c3.png)

`update_user`函数注册了一个`PUT HTTP`动词。它还有我们想要更新的 JSON 数据——在这种情况下，它必须是`name`。

我们在更新数据库之前做了一些验证。我们首先在 route 参数中获得了具有公共 ID 的用户。然后，我们更新了字段并调用了`db.session.commit()`。我们最终返回了更新后的用户数据，状态代码为 200(默认值)。类似地，`delete_user`函数使用 route 参数中的 ID 来获取用户，并最终删除它。

这两个函数使用`first_or_404` 函数来过滤数据——这样，如果 URL 中没有用户拥有该公共 ID，就会返回 404 错误。让我们前往 Postman 测试这些端点。

![](img/235b3f663eb187cf9638d9e65810aef7.png)![](img/b17c5366152a260807524a5af3b51582.png)![](img/b218a2f9132c2777c8cf4690cbc120a2.png)

耶！我们已经完成了用户端点。现在让我们从`todo`端点开始。首先，一个`todo`需要有一个用户连接到它。我们可以使用`public_id`或 email 来获取用户对象，因为这两个字段是唯一的。我想我会选择电子邮件，因为它容易记忆。所以当创建一个新的`todo`时，我们也需要传递创建者的电子邮件。

![](img/74d261eaa0a8416ed930c52a33fc230f.png)![](img/3c69c9763aaf054d31596dc778a65d5f.png)![](img/d9c61d5e7e069345f2eee8bfd49a0699.png)

终点与我们之前看到的相似。让我们前往 Postman 测试这些端点。

![](img/c476c88247b71b945729c18daffc908d.png)![](img/635c13f7871b7c27e1df10a1840456f9.png)![](img/237685564a9f1c426ab0b7f2b5f76c07.png)![](img/10f8cf6430a5f845440e6891027719f4.png)![](img/de5d4774a8321dc626f59239f8503ac3.png)

# 结论

耶！我们已经完成了这个系列的第一部分。本文向您展示了如何用 Flask 和 SQLAlchemy 构建一个简单的待办事项 API。你可以在 GitHub [这里](https://gist.github.com/Babatunde13/81866103136d20090a6f5c17f5de336b)获得完整的代码。下一部分将重点讨论身份验证和授权。