<html>
<head>
<title>Calculating Pi (π) With Monte Carlo Using Parallel Computing With OpenMP and C</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">利用OpenMP和C并行计算蒙特卡罗方法计算圆周率</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/calculating-pi-%CF%80-with-monte-carlo-using-parallel-computing-with-openmp-and-c-2b3a357f0f78?source=collection_archive---------1-----------------------#2021-02-25">https://betterprogramming.pub/calculating-pi-%CF%80-with-monte-carlo-using-parallel-computing-with-openmp-and-c-2b3a357f0f78?source=collection_archive---------1-----------------------#2021-02-25</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="8392" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">利用并行计算更高效地解决高要求问题</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/2352d01467baa215694cfb1d00debd5d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*fom8V88Y0lOtJ_VR"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">由<a class="ae ky" href="https://unsplash.com/@magnusengo?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">马格努斯·恩格</a>在<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</p></figure><p id="fe0d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">圆周率的计算是一个非常重要的计算问题，吸引了许多人试图以尽可能高的精度计算它。</p><p id="4d0d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">有很多方法可以做到，但我们将使用蒙特卡罗来计算圆周率(π)。</p><p id="4644" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们选择蒙特卡罗方法是因为它简单，并且可以归类为“<a class="ae ky" href="https://www.microsoft.com/en-us/research/publication/optimization-monte-carlo-efficient-embarrassingly-parallel-likelihood-free-inference/" rel="noopener ugc nofollow" target="_blank">令人尴尬的可并行化</a>”，正如这些算法在文献中所描述的那样。它的并行性令人尴尬，因为它可以在没有任何数据共享的情况下分成更小的进程，这一问题会使进程变得复杂。</p><p id="604e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">计算π的蒙特卡罗方法有两种变体:</p><ul class=""><li id="651e" class="lv lw it lb b lc ld lf lg li lx lm ly lq lz lu ma mb mc md bi translated">单位圆和单位方方法</li><li id="59ad" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated">通过计算函数的平均值进行积分计算</li></ul><p id="4f7e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们将选择第一种方法。</p><p id="a62c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这种方法背后的逻辑是我们在单位正方形内创建随机点。然后我们计算单位圆内的点的比率，并计算这些点与总数的比率。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi mj"><img src="../Images/33bf8e79f30b74f63f7d021a9be765f6.png" data-original-src="https://miro.medium.com/v2/resize:fit:806/1*d2rJRISgAwLA0UmwPSvOkw.gif"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">迭代次数增加时的蒙特卡罗结果</p></figure><p id="6c4d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果你想了解更多关于单位圆技术和蒙特卡洛的知识，这篇文章是一个很好的资源。</p></div><div class="ab cl mk ml hx mm" role="separator"><span class="mn bw bk mo mp mq"/><span class="mn bw bk mo mp mq"/><span class="mn bw bk mo mp"/></div><div class="im in io ip iq"><h1 id="a6ab" class="mr ms it bd mt mu mv mw mx my mz na nb jz nc ka nd kc ne kd nf kf ng kg nh ni bi translated">履行</h1><p id="26b1" class="pw-post-body-paragraph kz la it lb b lc nj ju le lf nk jx lh li nl lk ll lm nm lo lp lq nn ls lt lu im bi translated">首先，我应用了没有并行性的算法，将这些时间作为参考基准。</p><p id="b5bc" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">算法背后的逻辑很简单。我们执行了大量的迭代，并且我们请求随机的x坐标值。最后，我们计算请求区域内外的点的比率。将比率乘以4后，我们得到圆周率(π)。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="np nq l"/></div></figure><p id="c5a4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">算法的简单性允许我们使用归约技术非常有效地并行化迭代部分。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nr"><img src="../Images/16ffa8ea0024b14217126a8fdc66d9ae.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*0iKBfOPzZNAlIMywhNdBxQ.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">更好地理解归约的图表</p></figure><p id="4852" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在并行代码中，我们只需要实现一个重要的变化。</p><p id="a4ab" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">传统的产生随机数的方法不能有效地并行工作。我们在单核版本中使用的函数<code class="fe ns nt nu nv b">rand()</code>，不是线程安全的；因此，我们不能并行执行这一部分。</p><p id="8bb0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们选择用<a class="ae ky" href="https://translate.google.com/translate?hl=en&amp;prev=_t&amp;sl=auto&amp;tl=en&amp;u=https://en.wikipedia.org/wiki/Linear_congruential_generator" rel="noopener ugc nofollow" target="_blank">线性同余生成器</a>算法而不是<code class="fe ns nt nu nv b">rand()</code>来创建随机数。</p><p id="ddee" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这个公式可以表达算法:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi nw"><img src="../Images/7b4c228d526ffcb79a47398bb5033473.png" data-original-src="https://miro.medium.com/v2/resize:fit:472/format:webp/1*0qb3wrkLyCAAepZttDaWvg.png"/></div></figure><p id="4f69" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">但特别是在C中，如果我们将两个32位的长数字相乘，我们会得到乘法结果的最低有效位，即64位(“Numerical Recipes”作者William H. Press，第7章:随机数)。</p><p id="775e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">因此，我们不需要用<em class="no"> mod m. </em>这个公式可以表示为:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi nx"><img src="../Images/8c7c72ad067dcabedd7fb283cd2924e5.png" data-original-src="https://miro.medium.com/v2/resize:fit:294/format:webp/1*JM-ZQrT09uEXdbmm2J8KIA.png"/></div></figure><p id="3667" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">根据书上的说法，我们应该为算法选择的数字是<em class="no"> a= </em> 1103515245和<em class="no"> c= </em> 12345，适合C99。</p><p id="4e4f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">以下代码是我们程序的更新版本，包含我们对随机数生成所做的更改以及OpenMP并行化所需的所有代码。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="np nq l"/></div></figure></div><div class="ab cl mk ml hx mm" role="separator"><span class="mn bw bk mo mp mq"/><span class="mn bw bk mo mp mq"/><span class="mn bw bk mo mp"/></div><div class="im in io ip iq"><h1 id="9a33" class="mr ms it bd mt mu mv mw mx my mz na nb jz nc ka nd kc ne kd nf kf ng kg nh ni bi translated">结果</h1><p id="b1a7" class="pw-post-body-paragraph kz la it lb b lc nj ju le lf nk jx lh li nl lk ll lm nm lo lp lq nn ls lt lu im bi translated">我们在一台八核机器上执行了不同迭代次数的代码，以提高代码的速度。</p><h2 id="fe8f" class="ny ms it bd mt nz oa dn mx ob oc dp nb li od oe nd lm of og nf lq oh oi nh oj bi translated">时间</h2><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ok"><img src="../Images/bd245d8bcb59385fd359a98944717d42.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*WhFd69c6LQC5jJ10v_ILbQ.png"/></div></div></figure><h2 id="65fd" class="ny ms it bd mt nz oa dn mx ob oc dp nb li od oe nd lm of og nf lq oh oi nh oj bi translated">错误</h2><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ol"><img src="../Images/0fb5f0f69e720b576da141b051da1c1c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*_sUHyzH4nf_im0ogj0VXtA.png"/></div></div></figure><p id="8996" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们观察到，对于少量迭代，单核解决方案更好，这是我们应该预料到的。程序的并行化在管理线程方面会有一些开销。随着迭代次数越来越大，这种开销就微不足道了，程序的并行化效率也高得令人难以置信。</p></div><div class="ab cl mk ml hx mm" role="separator"><span class="mn bw bk mo mp mq"/><span class="mn bw bk mo mp mq"/><span class="mn bw bk mo mp"/></div><div class="im in io ip iq"><h1 id="de86" class="mr ms it bd mt mu mv mw mx my mz na nb jz nc ka nd kc ne kd nf kf ng kg nh ni bi translated">结论</h1><p id="d5e1" class="pw-post-body-paragraph kz la it lb b lc nj ju le lf nk jx lh li nl lk ll lm nm lo lp lq nn ls lt lu im bi translated">并行计算至关重要，因为摩尔定律即将终结，我们更加依赖多核和分布式系统来满足不断增长的计算需求，尤其是在科学计算领域。</p><p id="9dfd" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">您可以在<a class="ae ky" href="http://ilias1111/parallel-monte-carlo-pi: Calculating π with a parallel Monte Carlo implantation in C (github.com)" rel="noopener ugc nofollow" target="_blank"> GitHub </a>上访问与文章相关的代码和一些其他信息。</p><p id="2608" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我希望这篇文章对你有用。更多关于并行计算和圆周率计算的文章将很快出现。敬请期待！</p></div></div>    
</body>
</html>