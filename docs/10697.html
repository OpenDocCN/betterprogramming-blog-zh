<html>
<head>
<title>How To Use Hilt to Setup a Solid Architecture in Android</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何使用Hilt在Android中建立一个稳固的架构</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/using-hilt-at-its-full-potential-our-success-story-be4445ef799d?source=collection_archive---------2-----------------------#2022-01-23">https://betterprogramming.pub/using-hilt-at-its-full-potential-our-success-story-be4445ef799d?source=collection_archive---------2-----------------------#2022-01-23</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="884b" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">充分发挥Hilt框架的潜力——我们的成功故事！</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/54fc5b1c99ecaf8b49c8cfca8815c989.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*tmXHmdcMR22LwB9aea7yVw.png"/></div></div></figure><p id="fd83" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">想要构建一个完整的端到端特性流，具有适当的状态管理，同时还能经受住配置更改，当然，还要赶走所有的错误？下面是Hilt如何帮助我们创建最适合这个用例的架构…</p><h1 id="1af5" class="ln lo iq bd lp lq lr ls lt lu lv lw lx jw ly jx lz jz ma ka mb kc mc kd md me bi translated"><strong class="ak">出了什么问题？</strong></h1><p id="9471" class="pw-post-body-paragraph kr ks iq kt b ku mf jr kw kx mg ju kz la mh lc ld le mi lg lh li mj lk ll lm ij bi translated">几个月前，当我们最初开发一个全新的特性时，我们使用了单一活动+导航图，以及仅仅一个<code class="fe mk ml mm mn b">ViewModel</code>来控制整个流程。</p><p id="2d25" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">这背后的思想过程是为数据和数据处理提供一个中心位置，但是我们没有预见到端到端流程日益增长的复杂性！</p><p id="5649" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">结果，这种单片<strong class="kt ir"> </strong>架构导致数据和逻辑处理被集中到一个大<code class="fe mk ml mm mn b">ViewModel</code>中，单个文件中有超过2k+行代码！</p><p id="d52c" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">代码库很快变成了一个非常稳定的版本，导致了大量的bug，大量的生产问题，以及在配置更改中的大混乱！让这种流动变得更好的想法在我们的脑海里徘徊了很长时间…</p><p id="652f" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">几个月过去了，一个需求来增强这个特性，来覆盖更多的用例以及所有可能的流程。该功能只能大幅扩展。我们决定抓住这个机会，重构我们的代码，使它更易于维护，错误更少，并且在所有配置更改的情况下也是一个真正的幸存者！</p><h1 id="88eb" class="ln lo iq bd lp lq lr ls lt lu lv lw lx jw ly jx lz jz ma ka mb kc mc kd md me bi translated">我们做了什么？</h1><p id="6e0c" class="pw-post-body-paragraph kr ks iq kt b ku mf jr kw kx mg ju kz la mh lc ld le mi lg lh li mj lk ll lm ij bi translated">我们分析了Android开发的最新趋势，这个场景中的几个设计模式，想出了自己的mods，在依赖注入框架<strong class="kt ir"> Hilt </strong>的帮助下，形成一个新的合适的架构。</p><p id="ec03" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">下图显示了我们遵循的总体架构:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi mo"><img src="../Images/746ca212ceeba063d64bd9007e20b718.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*dNptiKlc1jVDJmyRse0luA.png"/></div></div></figure><h1 id="1be6" class="ln lo iq bd lp lq lr ls lt lu lv lw lx jw ly jx lz jz ma ka mb kc mc kd md me bi translated">使用的组件？</h1><ol class=""><li id="edc0" class="mp mq iq kt b ku mf kx mg la mr le ms li mt lm mu mv mw mx bi translated">视图绑定</li><li id="e669" class="mp mq iq kt b ku my kx mz la na le nb li nc lm mu mv mw mx bi translated">依赖注入的句柄</li><li id="4f6e" class="mp mq iq kt b ku my kx mz la na le nb li nc lm mu mv mw mx bi translated">导航图+单一活动原则</li><li id="b5d4" class="mp mq iq kt b ku my kx mz la na le nb li nc lm mu mv mw mx bi translated"><code class="fe mk ml mm mn b">ViewModels</code>针对幸存配置+逻辑处理</li><li id="c029" class="mp mq iq kt b ku my kx mz la na le nb li nc lm mu mv mw mx bi translated">数据I/O操作的存储库模式(机房+改造)</li><li id="bbeb" class="mp mq iq kt b ku my kx mz la na le nb li nc lm mu mv mw mx bi translated">Hilt提供了一个活动范围的数据容器实例</li><li id="e153" class="mp mq iq kt b ku my kx mz la na le nb li nc lm mu mv mw mx bi translated">用于异步任务的Kotlin协程</li><li id="d41e" class="mp mq iq kt b ku my kx mz la na le nb li nc lm mu mv mw mx bi translated">输入表单验证的Kotlin流程</li></ol><h1 id="151c" class="ln lo iq bd lp lq lr ls lt lu lv lw lx jw ly jx lz jz ma ka mb kc mc kd md me bi translated">优点？</h1><ol class=""><li id="b8f0" class="mp mq iq kt b ku mf kx mg la mr le ms li mt lm mu mv mw mx bi translated">将整体架构分解成更容易单独管理和维护的小部分</li><li id="4fb9" class="mp mq iq kt b ku my kx mz la na le nb li nc lm mu mv mw mx bi translated">拥有独立的数据供应商(<code class="fe mk ml mm mn b">Repository</code>)、数据持有者(数据源)和数据处理器(<code class="fe mk ml mm mn b">ViewModel</code>)有助于实现更清晰的代码，因为它有效地遵循了关注点分离范式</li><li id="ab75" class="mp mq iq kt b ku my kx mz la na le nb li nc lm mu mv mw mx bi translated">直接从<code class="fe mk ml mm mn b">ViewModels</code>控制导航，使导航状态更容易管理，同时保持高测试性</li><li id="98bd" class="mp mq iq kt b ku my kx mz la na le nb li nc lm mu mv mw mx bi translated">从视图模型中的一个公共点控制进度指示器、Toast消息、资源和一些常规交互，使状态管理和测试更容易</li><li id="476d" class="mp mq iq kt b ku my kx mz la na le nb li nc lm mu mv mw mx bi translated">与Kotlin协同程序+流API的完全互操作性，产生干净、简洁且完全可测试的异步代码，错误更少</li><li id="955a" class="mp mq iq kt b ku my kx mz la na le nb li nc lm mu mv mw mx bi translated">逻辑处理+状态管理从<code class="fe mk ml mm mn b">ViewModels</code>开始发生，因此幸存的配置更改是一件轻而易举的事情！</li><li id="965e" class="mp mq iq kt b ku my kx mz la na le nb li nc lm mu mv mw mx bi translated">[附加]使用数据绑定和这个架构将进一步减少一些来自片段和活动的代码行</li><li id="b7f3" class="mp mq iq kt b ku my kx mz la na le nb li nc lm mu mv mw mx bi translated">[附加]完全支持Jetpack Compose，因为只需将布局更改为Composables，就可以保留底层架构</li></ol><h1 id="aa04" class="ln lo iq bd lp lq lr ls lt lu lv lw lx jw ly jx lz jz ma ka mb kc mc kd md me bi translated">给我看看代码</h1><p id="d038" class="pw-post-body-paragraph kr ks iq kt b ku mf jr kw kx mg ju kz la mh lc ld le mi lg lh li mj lk ll lm ij bi translated">整个架构的基本组件是<code class="fe mk ml mm mn b">BaseViewModel</code>、<code class="fe mk ml mm mn b">BaseFragment</code>和<code class="fe mk ml mm mn b">DataSource</code>类，它们几乎控制了整个架构！</p><p id="edf5" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated"><code class="fe mk ml mm mn b">BaseViewModel</code>的代码如下:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nd ne l"/></div></figure><p id="d31c" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated"><code class="fe mk ml mm mn b">BaseViewModel</code>这里控制整个流程中使用的几乎所有常规活动，包括片段到片段的导航(使用默认的导航参数，因此导航图XML不那么混乱)，显示/隐藏进度对话框(加载器)，显示相关的祝酒词，等等。</p><p id="58c7" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated"><code class="fe mk ml mm mn b">ViewModels</code>可以继承这个<code class="fe mk ml mm mn b">BaseViewModel</code>来直接使用所有的功能！</p><p id="2c0d" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated"><code class="fe mk ml mm mn b">BaseFragment</code>的代码是:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nd ne l"/></div></figure><p id="61cd" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">功能中所有片段的基类，由导航图连接。它特别支持<code class="fe mk ml mm mn b">ViewBinding</code>和我们心爱的<code class="fe mk ml mm mn b">BaseViewModel</code>，同时观察<code class="fe mk ml mm mn b">BaseViewModel</code>发出的常见实况数据。</p><p id="f2a8" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">由于使用了<code class="fe mk ml mm mn b">ViewBinding</code>,视图的创建和销毁可以很容易地在这个片段中通用化，所以子片段不必去管它！(它也可以在没有<code class="fe mk ml mm mn b">ViewBinding</code>的情况下使用，在这种情况下，构造函数需要一点调整)</p><p id="82d5" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">请注意，这个基础片段包含了一个抽象实例<code class="fe mk ml mm mn b">BaseViewModel</code>，每个片段都可以自己决定提供什么！(所以，如果一些片段仍然想要共享ViewModel，这是可能的)</p><p id="8a0e" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated"><code class="fe mk ml mm mn b">DataSource</code>的代码:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nd ne l"/></div></figure><p id="df89" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">我们特性的核心，数据容器类，或者说数据源(灵感来自于clean architecture)是一个特殊的由Hilt提供的类，它保存了整个流程中收集的数据和状态变量！</p><p id="8fd5" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">这个班的特长是<code class="fe mk ml mm mn b">@ActivityRetainedScope</code>注解！这意味着，所有注入了依赖关系的成员，只要他们生活在同一个活动实例中，就会收到相同的依赖关系实例。</p><p id="91b1" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">这本来可以通过创建一个<code class="fe mk ml mm mn b">Singleton</code>类来实现，但是通过在流完全终止后清除不需要的状态，Hilt进一步帮助减少了内存的使用！</p><p id="da46" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">这样，在相同的流在其他地方被重用的情况下，可以避免状态损坏。hilt还有助于在配置变化时提供相同的实例，因此状态总是以稳定的方式存储。</p><h1 id="7482" class="ln lo iq bd lp lq lr ls lt lu lv lw lx jw ly jx lz jz ma ka mb kc mc kd md me bi translated"><strong class="ak">示例用法</strong></h1><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nd ne l"/></div></figure><p id="64e6" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">这里有一个<code class="fe mk ml mm mn b">FragmentTwo</code> <strong class="kt ir"> </strong>的用例，继承自<code class="fe mk ml mm mn b">BaseFragment</code>，在<code class="fe mk ml mm mn b">setupUI()</code>方法中完成所有的UI处理，同时在单独的专用方法<code class="fe mk ml mm mn b">setupVM()</code>中负责<code class="fe mk ml mm mn b">ViewModel</code>活动。</p><p id="6236" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">注意，视图的创建和处理不是由单个片段处理的，而是由<code class="fe mk ml mm mn b">BaseFragment</code>本身管理的！如此少的代码，关注点被适当地分离。</p><p id="f942" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">还有一点，既然我们允许片段自己管理<code class="fe mk ml mm mn b">ViewModel</code>实例的创建，我们可以直接使用<code class="fe mk ml mm mn b">by</code> <code class="fe mk ml mm mn b">viewModels()</code>扩展来实现这个目的！如果某个片段仍想与其他片段共享<code class="fe mk ml mm mn b">ViewModel</code>，也可以根据需要使用<code class="fe mk ml mm mn b">by navGraphViewModels()</code>或<code class="fe mk ml mm mn b">by activityViewModels()</code>函数。</p><p id="ea2a" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">下面给出的是与我们的<code class="fe mk ml mm mn b">FragmentTwo</code>结合使用的<code class="fe mk ml mm mn b">ViewModelTwo</code>:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nd ne l"/></div></figure><p id="85c6" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated"><code class="fe mk ml mm mn b">ViewModelTwo</code>协助我们的<code class="fe mk ml mm mn b">FragmentTwo</code>应对配置变更，并处理和验证来自配置变更的事件/数据！</p><p id="7ecc" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">当在编辑文本中输入一个值时，它被传递到ViewModel上进行存储和验证，并且向片段公开一个流，片段用于进一步控制状态，例如继续按钮的启用或编辑文本的错误可见性。</p><p id="6b9a" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">单击该按钮，输入的值被存储在我们的数据存储中，这是在Hilt的帮助下注入的，相同的值可以被下一个出现的流入使用，因为数据源实例对于任何注入的组件都是相同的。</p><p id="ac2e" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">最后，根据输入的值，视图模型将负责导航。从单元测试的角度来看，所有这些代码都是完全可测试的，从而导致更高的代码覆盖率和更少的错误！</p><p id="600a" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">你可以查看完整的代码库，这是一个使用我构建的架构的完整的应用程序:<a class="ae nf" href="https://github.com/dkexception/architecture-with-hilt" rel="noopener ugc nofollow" target="_blank">https://github.com/dkexception/architecture-with-hilt</a></p></div><div class="ab cl ng nh hu ni" role="separator"><span class="nj bw bk nk nl nm"/><span class="nj bw bk nk nl nm"/><span class="nj bw bk nk nl"/></div><div class="ij ik il im in"><h1 id="0ea3" class="ln lo iq bd lp lq nn ls lt lu no lw lx jw np jx lz jz nq ka mb kc nr kd md me bi translated">摘要</h1><p id="3f05" class="pw-post-body-paragraph kr ks iq kt b ku mf jr kw kx mg ju kz la mh lc ld le mi lg lh li mj lk ll lm ij bi translated">将Hilt有效地与其他Android组件结合使用，帮助我们及时开发高质量的特性。</p><p id="27e3" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">开发优秀应用程序的秘诀是遵循一些核心原则和标准指南。这种架构解决了许多与Android应用程序相关的常见问题，非常适合基于流程的特性开发。</p><p id="535c" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">你觉得这个建筑怎么样？你想进一步改进它吗？有什么你担心的吗？请在评论中让我知道！</p></div><div class="ab cl ng nh hu ni" role="separator"><span class="nj bw bk nk nl nm"/><span class="nj bw bk nk nl nm"/><span class="nj bw bk nk nl"/></div><div class="ij ik il im in"><p id="e81e" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">特别感谢<a class="ns nt ep" href="https://medium.com/u/717811cd866a?source=post_page-----be4445ef799d--------------------------------" rel="noopener" target="_blank"> Rahul </a>提出数据源的想法，并在整个流程开发中始终支持它！</p></div></div>    
</body>
</html>