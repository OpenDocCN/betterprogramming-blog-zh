<html>
<head>
<title>Solidity: Do We Really Need a Safer Math?</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">可靠性:我们真的需要更安全的数学吗？</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/solidity-do-we-really-need-a-safer-math-733ea7a9ea44?source=collection_archive---------12-----------------------#2020-10-08">https://betterprogramming.pub/solidity-do-we-really-need-a-safer-math-733ea7a9ea44?source=collection_archive---------12-----------------------#2020-10-08</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="dbad" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">看看OpenZeppelin的安全数学库</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/afe9453f0d3d27fc42fa7c441c32165c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*n0-bQNcRIOm_6WPm"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">在<a class="ae kv" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上<a class="ae kv" href="https://unsplash.com/@lazycreekimages?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Michael Dziedzic </a>拍摄的照片。</p></figure><p id="015d" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在可靠性方面，在其他语言中，你认为理所当然的东西有很多不同的替代品。<a class="ae kv" href="https://medium.com/better-programming/solidity-playing-with-strings-aca62d118ae5" rel="noopener">字符串</a>和数学就是两个例子。</p><blockquote class="ls lt lu"><p id="38dc" class="kw kx lv ky b kz la jr lb lc ld ju le lw lg lh li lx lk ll lm ly lo lp lq lr ij bi translated">“实度中的算术运算在溢出时换行。这很容易导致错误，因为程序员通常认为溢出会引起错误，这是高级编程语言中的标准行为。“SafeMath”通过在操作溢出时恢复事务来恢复这种直觉。</p><p id="d593" class="kw kx lv ky b kz la jr lb lc ld ju le lw lg lh li lx lk ll lm ly lo lp lq lr ij bi translated">使用这个库代替未检查的操作消除了一整类的错误，所以建议总是使用它。”— <a class="ae kv" href="https://docs.openzeppelin.com/contracts/3.x/api/math" rel="noopener ugc nofollow" target="_blank"> OpenZeppelin文档</a></p></blockquote><p id="5af6" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">“实性运算在溢出时换行”指的是与数字在计算机中的表示方式，尤其是实性中的表示方式相关的特定事物。</p><p id="37d8" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在下面的智能契约中，我实现了一个简单的方法来测试下溢和上溢(像往常一样，就在<a class="ae kv" href="https://remix.ethereum.org/" rel="noopener ugc nofollow" target="_blank"> Remix </a>中):</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="lz ma l"/></div></figure><p id="a4ef" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">编译完成后，您将能够调用两个方法——通过适当的输入——来显示本地数字表示的弱点:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi mb"><img src="../Images/07f03875b6ab36c57078a2097dc6bd63.png" data-original-src="https://miro.medium.com/v2/resize:fit:856/format:webp/1*zTAPOmrWIYD9H5zvZDD-UQ.png"/></div></figure><p id="f5f8" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">请注意我是如何使用<code class="fe mc md me mf b">int8</code>作为方法的输入和输出类型的。这将允许我快速描述实现。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi mg"><img src="../Images/941be835dbee9e452401ec54bc9e954f.png" data-original-src="https://miro.medium.com/v2/resize:fit:880/format:webp/1*E_sXOe3R_EBf1hB6MGhUZg.png"/></div></figure><p id="bf48" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">你在上图中看到的就是“溢出时实性操作换行”这句话的意思。现在，想象一下，如果我们摆弄的<code class="fe mc md me mf b">uint8</code>代表一些珍贵资产的数量。这仅仅意味着你的系统在大多数情况下都可以很好地工作(增量和减量远离表示的极限),但是会显著地失败，产生不一致的状态。</p><p id="5e51" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在这一点上，很明显<em class="lv">我们确实需要一个更安全的数学方法——</em>即使是在最简单的智能合约中。</p><p id="9417" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">现在让我们看看前面的例子是如何使用<a class="ae kv" href="https://docs.openzeppelin.com/contracts/2.x/api/math#safemath" rel="noopener ugc nofollow" target="_blank"> SafeMath </a>进行增量/减量的。</p><p id="b968" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">SafeMath由OpenZeppelin为<code class="fe mc md me mf b">uint256</code>提供。这意味着它永远不会溢出我们使用<code class="fe mc md me mf b">uint8</code>的例子。例如，如果您传递一个255，您应该溢出，但是它不会，因为它将在SafeMath中表示为一个<code class="fe mc md me mf b">uint256</code>。</p><p id="1202" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">为了清楚起见，我“开发”了一个<code class="fe mc md me mf b">uint8</code> SafeMath版本，只是简单地将原来SafeMath中的<code class="fe mc md me mf b">uint256</code>替换为<code class="fe mc md me mf b">uint8</code>。我把它命名为SafeMath8:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="lz ma l"/></div></figure><p id="36b3" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">您可以在Remix中直接使用它，并导入它，如下例所示:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="lz ma l"/></div></figure><p id="dda7" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">您可能注意到了，我们要求Solidity将SafeMath8中定义的方法“附加”到<code class="fe mc md me mf b">uint8</code>。这样，我们就可以调用方法<code class="fe mc md me mf b">sub()</code>和<code class="fe mc md me mf b">add()</code>，它们代表了两个无符号整数相减和相加的新的、更安全的方法。</p><p id="04ab" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">下图显示了通过调用带有参数的两个方法来获取上溢/下溢的结果:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi mh"><img src="../Images/992bdad2c300e649c20b8c75d29af70f.png" data-original-src="https://miro.medium.com/v2/resize:fit:884/format:webp/1*qkOkR8TBeaDsIjMVjkGITQ.png"/></div></figure><p id="1d11" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">通过调用这些方法，除了控制台中显示的两个调用结果之外，您不会得到任何其他结果:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi mi"><img src="../Images/097ba0e7bac369ff9471625ac3501f11.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*gz0eAm_k0ACsEaXp9HtkHA.png"/></div></div></figure><p id="ee51" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这两种方法都会失败，并以人类可读的形式返回正确的错误消息。</p></div><div class="ab cl mj mk hu ml" role="separator"><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo"/></div><div class="ij ik il im in"><h1 id="6469" class="mq mr iq bd ms mt mu mv mw mx my mz na jw nb jx nc jz nd ka ne kc nf kd ng nh bi translated">结论</h1><p id="032c" class="pw-post-body-paragraph kw kx iq ky b kz ni jr lb lc nj ju le lf nk lh li lj nl ll lm ln nm lp lq lr ij bi translated">SafeMath(和SafeMath8)是构建安全智能合约的基础。考虑到你通常会处理价值数百枚<em class="lv">法币</em>的资产，这一点尤为重要。</p></div></div>    
</body>
</html>