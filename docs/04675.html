<html>
<head>
<title>How to Launch Parallel Tasks in Python</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何在Python中启动并行任务</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/how-to-launch-parallel-tasks-in-python-dd5735fb52c3?source=collection_archive---------2-----------------------#2020-04-29">https://betterprogramming.pub/how-to-launch-parallel-tasks-in-python-dd5735fb52c3?source=collection_archive---------2-----------------------#2020-04-29</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="f760" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">利用concurrent.futures，一个异步执行调用的高级接口</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/abdc1587791f74d407284479d4c34c06.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*V0DiPt53feXtd6uj1e3gqw.jpeg"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated"><a class="ae ky" href="https://unsplash.com/@jamie452?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">杰米街</a>在<a class="ae ky" href="https://unsplash.com/s/photos/parallel?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍照。</p></figure><p id="585f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">通过阅读这篇文章，您将了解如何使用<code class="fe lv lw lx ly b"><a class="ae ky" href="https://docs.python.org/3/library/concurrent.futures.html" rel="noopener ugc nofollow" target="_blank">concurrent.futures</a></code>库在Python中异步运行任务。它是Python中的<code class="fe lv lw lx ly b">threading</code>和<code class="fe lv lw lx ly b">multiprocessing</code>类的更好替代，因为它用相同的接口实现了<code class="fe lv lw lx ly b">Thread</code>和<code class="fe lv lw lx ly b">Process</code>，这是由抽象的<code class="fe lv lw lx ly b">Executor</code>类定义的。官方文件揭示了<code class="fe lv lw lx ly b">Thread</code>的一个主要问题:</p><blockquote class="lz ma mb"><p id="b8b2" class="kz la mc lb b lc ld ju le lf lg jx lh md lj lk ll me ln lo lp mf lr ls lt lu im bi translated">“在CPython中，由于<code class="fe lv lw lx ly b">Global Interpreter Lock</code>，一次只有一个线程可以执行Python代码(尽管某些面向性能的库可能会克服这一限制)。”</p></blockquote><p id="520e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">此外，<code class="fe lv lw lx ly b">threading</code>类不允许你从除<code class="fe lv lw lx ly b">null</code>之外的可调用函数中返回值。<code class="fe lv lw lx ly b">concurrent.futures</code>模块的主要概念在于<code class="fe lv lw lx ly b">Executor</code>类。它是一个抽象类，提供异步执行调用的方法。我们将使用从它继承的子类，而不是直接使用它:</p><ul class=""><li id="ed9a" class="mg mh it lb b lc ld lf lg li mi lm mj lq mk lu ml mm mn mo bi translated"><code class="fe lv lw lx ly b">ThreadPoolExecutor</code></li><li id="b02a" class="mg mh it lb b lc mp lf mq li mr lm ms lq mt lu ml mm mn mo bi translated"><code class="fe lv lw lx ly b">ProcessPoolExecutor</code></li></ul><p id="2324" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们进入下一节，开始编写一些Python代码。</p></div><div class="ab cl mu mv hx mw" role="separator"><span class="mx bw bk my mz na"/><span class="mx bw bk my mz na"/><span class="mx bw bk my mz"/></div><div class="im in io ip iq"><h1 id="b670" class="nb nc it bd nd ne nf ng nh ni nj nk nl jz nm ka nn kc no kd np kf nq kg nr ns bi translated">1.ThreadPoolExecutor</h1><h2 id="cf06" class="nt nc it bd nd nu nv dn nh nw nx dp nl li ny nz nn lm oa ob np lq oc od nr oe bi translated">导入</h2><p id="cb61" class="pw-post-body-paragraph kz la it lb b lc of ju le lf og jx lh li oh lk ll lm oi lo lp lq oj ls lt lu im bi translated">在Python文件的顶部添加以下导入声明:</p><pre class="kj kk kl km gt ok ly ol om aw on bi"><span id="5781" class="nt nc it ly b gy oo op l oq or">from concurrent.futures import ThreadPoolExecutor<br/>import time</span></pre><h2 id="3565" class="nt nc it bd nd nu nv dn nh nw nx dp nl li ny nz nn lm oa ob np lq oc od nr oe bi translated">可调用函数(目标)</h2><p id="7f90" class="pw-post-body-paragraph kz la it lb b lc of ju le lf og jx lh li oh lk ll lm oi lo lp lq oj ls lt lu im bi translated">让我们定义一个新函数，作为异步调用的可调用函数。我将只定义一个简单的函数，它休眠两秒钟，然后返回两个输入参数相乘的结果:</p><pre class="kj kk kl km gt ok ly ol om aw on bi"><span id="e5ef" class="nt nc it ly b gy oo op l oq or">def wait_function(x, y):<br/>    print('Task(', x,'multiply', y, ') started')<br/>    time.sleep(2)<br/>    print('Task(', x,'multiply', y, ') completed')<br/>    return x * y</span></pre><h2 id="db87" class="nt nc it bd nd nu nv dn nh nw nx dp nl li ny nz nn lm oa ob np lq oc od nr oe bi translated">单一任务</h2><p id="9119" class="pw-post-body-paragraph kz la it lb b lc of ju le lf og jx lh li oh lk ll lm oi lo lp lq oj ls lt lu im bi translated">下一步是创建一个<code class="fe lv lw lx ly b">ThreadPoolExecutor</code>对象。强烈建议将它包装在<code class="fe lv lw lx ly b">with</code>上下文管理器中，因为它会自己调用<code class="fe lv lw lx ly b">shutdown</code>函数，并在完成执行后释放资源。它接受以下输入参数。</p><ul class=""><li id="0818" class="mg mh it lb b lc ld lf lg li mi lm mj lq mk lu ml mm mn mo bi translated"><code class="fe lv lw lx ly b">max_workers</code> —该实例的工作线程数。对于3.5以上版本，它将默认为机器上的处理器数量乘以5。从版本3.8开始，默认值更改为<code class="fe lv lw lx ly b">min(32, os.cpu_count() + 4)</code>。</li><li id="da60" class="mg mh it lb b lc mp lf mq li mr lm ms lq mt lu ml mm mn mo bi translated"><code class="fe lv lw lx ly b">thread_name_prefix</code> —允许用户控制由池创建的工作线程的<code class="fe lv lw lx ly b">threading.Thread</code>名称，以便于调试。</li><li id="5117" class="mg mh it lb b lc mp lf mq li mr lm ms lq mt lu ml mm mn mo bi translated"><code class="fe lv lw lx ly b">initializer</code> —在每个工作进程开始时调用的可选可调用程序。</li><li id="30f1" class="mg mh it lb b lc mp lf mq li mr lm ms lq mt lu ml mm mn mo bi translated"><code class="fe lv lw lx ly b">initargs</code> —传递给<code class="fe lv lw lx ly b">initializer</code>的一组参数。</li></ul><p id="e3fb" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在本教程中，我将只使用<code class="fe lv lw lx ly b">max_workers</code>参数。让我们创建一个<code class="fe lv lw lx ly b">ThreadPoolExecutor</code>并用<code class="fe lv lw lx ly b">wait_function</code>作为输入可调用函数来调用<code class="fe lv lw lx ly b">submit</code>函数。记住<code class="fe lv lw lx ly b">wait_function</code>接受两个输入参数。我将把它们作为单独的参数传递，而不是一个元组:</p><pre class="kj kk kl km gt ok ly ol om aw on bi"><span id="e64f" class="nt nc it ly b gy oo op l oq or">with ThreadPoolExecutor(max_workers=1) as executor:<br/>    future = executor.submit(wait_function, 3, 4)</span></pre><p id="767b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe lv lw lx ly b">submit</code>函数将返回一个<code class="fe lv lw lx ly b">Future</code>对象，该对象封装了一个可调用对象的异步执行。<code class="fe lv lw lx ly b">Future</code>对象最常用的功能有:</p><ul class=""><li id="722b" class="mg mh it lb b lc ld lf lg li mi lm mj lq mk lu ml mm mn mo bi translated"><code class="fe lv lw lx ly b">cancel</code> —试图取消执行。返回一个boolean值，该值指示呼叫是否已成功取消。</li><li id="cb93" class="mg mh it lb b lc mp lf mq li mr lm ms lq mt lu ml mm mn mo bi translated"><code class="fe lv lw lx ly b">running</code> —检查呼叫是否正在执行。返回一个布尔值。</li><li id="1ab7" class="mg mh it lb b lc mp lf mq li mr lm ms lq mt lu ml mm mn mo bi translated"><code class="fe lv lw lx ly b">done</code> —检查通话是取消还是完成。返回一个布尔值。</li><li id="81e1" class="mg mh it lb b lc mp lf mq li mr lm ms lq mt lu ml mm mn mo bi translated"><code class="fe lv lw lx ly b">result</code> —返回调用返回的值。如果调用尚未完成，则该方法将等待输入参数<code class="fe lv lw lx ly b">timeout</code>给出的<em class="mc"> n </em>秒。强烈建议在调用结果之前使用<code class="fe lv lw lx ly b">done</code>函数进行检查，因为<code class="fe lv lw lx ly b">timeout</code>会阻止当前的执行。</li><li id="a1fd" class="mg mh it lb b lc mp lf mq li mr lm ms lq mt lu ml mm mn mo bi translated"><code class="fe lv lw lx ly b">add_done_callback</code> —将可调用函数附加到<code class="fe lv lw lx ly b">Future</code>对象上。当<code class="fe lv lw lx ly b">Future</code>被取消或结束运行时，这个函数将被调用，唯一的参数是<code class="fe lv lw lx ly b">Future</code>。</li></ul><p id="b4b2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">将下面的代码添加到<code class="fe lv lw lx ly b">submit</code>函数的正下方。这只是一个简单的循环，在线程运行时打印一个字符串。完成后，它将打印出结果:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="os ot l"/></div></figure><p id="9f95" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">查看GitHub 上的完整代码<a class="ae ky" href="https://gist.github.com/wfng92/f8a677d74fce8bb752290de4f64f966d" rel="noopener ugc nofollow" target="_blank">:</a></p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="os ot l"/></div></figure><p id="fb0f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">运行Python文件时，您应该会看到以下结果:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi ou"><img src="../Images/de8e4b299741dde0c403929dde04e865.png" data-original-src="https://miro.medium.com/v2/resize:fit:772/format:webp/1*YC6GGXd6QDM_QHUAaN7T7A.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">作者图片</p></figure><h2 id="4f6e" class="nt nc it bd nd nu nv dn nh nw nx dp nl li ny nz nn lm oa ob np lq oc od nr oe bi translated">多重任务</h2><p id="0101" class="pw-post-body-paragraph kz la it lb b lc of ju le lf og jx lh li oh lk ll lm oi lo lp lq oj ls lt lu im bi translated">接下来，我们将向它添加另一个任务，这样它们将并行运行。将Python文件中的代码更改为以下内容:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="os ot l"/></div></figure><p id="4059" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在，先将<code class="fe lv lw lx ly b">max_workers</code>设置为1。运行它，您应该注意到任务不是并行运行的。它将运行第一个任务，然后运行第二个任务。这主要是因为池中只有一个工人。让我们将<code class="fe lv lw lx ly b">max_workers</code>增加到2，您应该能够看到两个任务并行运行。</p><h2 id="cafd" class="nt nc it bd nd nu nv dn nh nw nx dp nl li ny nz nn lm oa ob np lq oc od nr oe bi translated">回调函数</h2><p id="293e" class="pw-post-body-paragraph kz la it lb b lc of ju le lf og jx lh li oh lk ll lm oi lo lp lq oj ls lt lu im bi translated">您可以给<code class="fe lv lw lx ly b">Future</code>对象附加一个回调函数。一旦执行被取消或完成，它将调用附加的函数。如果您打算在成功连接到数据库或完成URL请求后继续更新UI，这将非常有用。现在让我们创建一个简单的回调函数:</p><pre class="kj kk kl km gt ok ly ol om aw on bi"><span id="57df" class="nt nc it ly b gy oo op l oq or">def callback_function(future):<br/>    print('Callback with the following result', future.result())</span></pre><p id="765a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在<code class="fe lv lw lx ly b">submit</code>函数的正下方添加以下代码:</p><pre class="kj kk kl km gt ok ly ol om aw on bi"><span id="6d7e" class="nt nc it ly b gy oo op l oq or">future.add_done_callback(callback_function)</span></pre><p id="3c56" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">查看GitHub 上的完整代码<a class="ae ky" href="https://gist.github.com/wfng92/4a7c3993dc4873c6dc2aeb7ea11007f3" rel="noopener ugc nofollow" target="_blank">:</a></p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="os ot l"/></div></figure><p id="d8c6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">运行Python文件时，控制台中将显示以下结果:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi ov"><img src="../Images/9c335b5ad9eb5d1a3d619015083e4e7e.png" data-original-src="https://miro.medium.com/v2/resize:fit:958/format:webp/1*K_hdStNnPxOtlASY9J71wA.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">作者图片</p></figure></div><div class="ab cl mu mv hx mw" role="separator"><span class="mx bw bk my mz na"/><span class="mx bw bk my mz na"/><span class="mx bw bk my mz"/></div><div class="im in io ip iq"><h1 id="a274" class="nb nc it bd nd ne nf ng nh ni nj nk nl jz nm ka nn kc no kd np kf nq kg nr ns bi translated">2.进程池执行器</h1><p id="d036" class="pw-post-body-paragraph kz la it lb b lc of ju le lf og jx lh li oh lk ll lm oi lo lp lq oj ls lt lu im bi translated"><code class="fe lv lw lx ly b">ProcessPoolExecutor</code>类的工作方式与<code class="fe lv lw lx ly b">ThreadPoolExecutor</code>完全相同，但是有一些小的不同。它使用<code class="fe lv lw lx ly b">multiprocessing</code>模块，这允许它绕过<code class="fe lv lw lx ly b">Global Interpreter Lock</code>。然而，这也意味着只能执行和返回可选择的对象。</p><p id="ddef" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">此外，它不能在交互式解释器中工作，必须有一个可由工人子进程导入的<code class="fe lv lw lx ly b">__main__</code>函数。<code class="fe lv lw lx ly b">max_workers</code>将机器中的进程数。在Windows操作系统上，<code class="fe lv lw lx ly b">max_workers</code>必须等于或小于61。</p><p id="53d2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">您必须导入<code class="fe lv lw lx ly b">ProcessPoolExecutor</code>才能使用它:</p><pre class="kj kk kl km gt ok ly ol om aw on bi"><span id="ff83" class="nt nc it ly b gy oo op l oq or">from concurrent.futures import ProcessPoolExecutor</span></pre><p id="7f22" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">可以重用之前的代码，修改为<code class="fe lv lw lx ly b">ProcessPoolExecutor</code>而不是<code class="fe lv lw lx ly b">ThreadPoolExecutor</code>。将代码包装在一个函数内，直接从<code class="fe lv lw lx ly b">__main__</code>调用。在GitHub 上查看以下<a class="ae ky" href="https://gist.github.com/wfng92/d840c3a2ec5f72c3fb87c4364021283a" rel="noopener ugc nofollow" target="_blank">中的完整代码:</a></p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="os ot l"/></div></figure></div><div class="ab cl mu mv hx mw" role="separator"><span class="mx bw bk my mz na"/><span class="mx bw bk my mz na"/><span class="mx bw bk my mz"/></div><div class="im in io ip iq"><h1 id="2de6" class="nb nc it bd nd ne nf ng nh ni nj nk nl jz nm ka nn kc no kd np kf nq kg nr ns bi translated">3.键盘中断</h1><p id="8f1b" class="pw-post-body-paragraph kz la it lb b lc of ju le lf og jx lh li oh lk ll lm oi lo lp lq oj ls lt lu im bi translated">如果您打算在进程在线程中运行时通过<code class="fe lv lw lx ly b">Ctrl+C</code>停止执行，编译器很可能会挂起并卡在<code class="fe lv lw lx ly b">KeyboardInterupt</code>异常处。这主要是因为<code class="fe lv lw lx ly b">Ctrl+C</code>命令产生<code class="fe lv lw lx ly b">SIGINT</code>，不会停止或中断执行。你需要生成<code class="fe lv lw lx ly b">SIGBREAK</code>来结束执行，返回终端。根据操作系统和计算机型号，使用以下命令生成<code class="fe lv lw lx ly b">SIGBREAK</code>:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi ow"><img src="../Images/c396037ec0d1e748ad9eaf9e32a5548a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1178/format:webp/1*gf3z4tGkizrDVO2fZ0Mhag.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">来自<a class="ae ky" href="https://stackoverflow.com/questions/1364173/stopping-python-using-ctrlc" rel="noopener ugc nofollow" target="_blank">堆栈溢出</a>的图像。</p></figure></div><div class="ab cl mu mv hx mw" role="separator"><span class="mx bw bk my mz na"/><span class="mx bw bk my mz na"/><span class="mx bw bk my mz"/></div><div class="im in io ip iq"><h1 id="b2d4" class="nb nc it bd nd ne nf ng nh ni nj nk nl jz nm ka nn kc no kd np kf nq kg nr ns bi translated">4.结论</h1><p id="74bd" class="pw-post-body-paragraph kz la it lb b lc of ju le lf og jx lh li oh lk ll lm oi lo lp lq oj ls lt lu im bi translated">让我们回顾一下今天所学的内容。</p><p id="3a50" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们从简单解释<code class="fe lv lw lx ly b">concurrent.futures</code>模块开始。</p><p id="4d99" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">之后，我们深入探讨了基本的<code class="fe lv lw lx ly b">ThreadPoolExecutor</code>类和<code class="fe lv lw lx ly b">Future</code>类。我们尝试用不同数量的<code class="fe lv lw lx ly b">max_workers</code>并行运行多个任务。我们还测试了如何设置一个回调函数，该函数将在任务完成时执行。</p><p id="9c02" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们转到了<code class="fe lv lw lx ly b">ProcessPoolExecutor</code>，它与<code class="fe lv lw lx ly b">ThreadPoolExecutor</code>相似，只有一些小的不同。</p><p id="1a5c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">感谢你阅读这篇文章。希望下一篇文章能再见到你！</p></div><div class="ab cl mu mv hx mw" role="separator"><span class="mx bw bk my mz na"/><span class="mx bw bk my mz na"/><span class="mx bw bk my mz"/></div><div class="im in io ip iq"><h1 id="4601" class="nb nc it bd nd ne nf ng nh ni nj nk nl jz nm ka nn kc no kd np kf nq kg nr ns bi translated">参考</h1><ol class=""><li id="ebb8" class="mg mh it lb b lc of lf og li ox lm oy lq oz lu pa mm mn mo bi translated"><a class="ae ky" href="https://docs.python.org/3/library/concurrent.futures.html" rel="noopener ugc nofollow" target="_blank">期货文件</a></li><li id="b5cd" class="mg mh it lb b lc mp lf mq li mr lm ms lq mt lu pa mm mn mo bi translated"><a class="ae ky" href="https://docs.python.org/3.8/library/threading.html" rel="noopener ugc nofollow" target="_blank">线程文档</a></li><li id="6db8" class="mg mh it lb b lc mp lf mq li mr lm ms lq mt lu pa mm mn mo bi translated"><a class="ae ky" href="https://stackoverflow.com/questions/1364173/stopping-python-using-ctrlc" rel="noopener ugc nofollow" target="_blank">中断信号的快捷方式</a></li></ol></div></div>    
</body>
</html>