# 你可以在 10 分钟左右学会 5 种编程语言

> 原文：<https://betterprogramming.pub/5-programming-languages-you-can-learn-in-10-minutes-ish-66f77e2f815b>

## 你不需要成为每一种语言的专家，但是理解基本原理肯定会有所帮助

![](img/ff696110cae8f2c0ed7abc4a07418123.png)

在 [Unsplash](https://unsplash.com/s/photos/clock?utm_source=unsplash&utm_medium=referral&utm_content=creditCopyText) 上 [NeONBRAND](https://unsplash.com/@neonbrand?utm_source=unsplash&utm_medium=referral&utm_content=creditCopyText) 拍摄的照片

学习不同的语言——即使你不打算主动使用它们——对任何开发人员来说都是很好的实践。这是因为如果你把大部分时间花在一项技术上，你将会错过在其他地方可能发现的任何潜在的改进。

不要误解我的意思:这并不是说要掌握每一种语言——这既不实际也不可能。但是谁能说你没有错过一些函数式编程实践，因为直到现在你只关注面向对象的选择？

因此，本着我最喜欢的[编程书籍之一](https://medium.com/pragmatic-programmers/table-of-contents-bf907a514a34)的精神，我挑选了五种编程语言供你回顾。

即使它们不适用于你的日常生活，也要检查一下，看看它们能做些什么。他们可能会让你大吃一惊。

# Java Script 语言

我选择了 [JavaScript](https://www.javascript.com/) 作为第一个，因为不是每个人都在网络部门工作。即使在 it 内部，也不是每个后端开发人员都使用 Node。

JavaScript 现在是一种非常流行的语言，因为随着时间的推移，它的社区已经为多种架构创建了不同的解释器和运行时。因此，虽然 JavaScript 主要因其在 web 开发行业中的作用而闻名，但它也可以用于:

*   AI 和机器学习，得益于 [TensorFlow.js](https://www.tensorflow.org/js) 等项目。
*   工具，感谢 Node.js 和 Deno 等无头运行时。
*   移动应用，考虑到可用框架的数量(React，React Native，Ionic，其他)。
*   游戏开发，感谢[这么多可用的引擎和库](https://blog.bitsrc.io/9-top-js-gaming-engines-and-libraries-for-2020-81707d9f095)。
*   物联网解决方案:感谢像[mongose OS](https://mongoose-os.com/docs/mongoose-os/quickstart/setup.md)这样的框架，你可以使用 JavaScript 来编写微控制器。

## JavaScript 的主要特征

JavaScript 的一些最吸引人和有趣的特征是:

**动态打字**

JavaScript 支持动态类型，这意味着您可以在运行时更改变量的内容，而无需考虑数据的类型。

看看上面的例子——显然这不是利用动态类型的方法，但是由于 JavaScript 的灵活性，这是完全可能的。

动态分型系统的主要优点是:

*   你得到了一种更简单的语言，因为你不必太担心类型声明和定义。
*   开发时间减少了，因为编写代码的复杂性降低了。
*   您的代码可能更容易阅读(假设您也遵循其他最佳实践)，因为样板文件和重复代码更少。

**多途径支持**

不像其他语言那样关注单一的编程范式，JavaScript 试图将面向对象世界和函数世界的精华融合在一起。

该语言支持类、方法、方法覆盖以及公共和私有成员(至少，它很快会支持私有成员)。

而与此同时，JavaScript 有函数作为一等公民的概念。这反过来意味着你可以组合函数，编写更多的声明性代码、currying 函数和其他 FP 模式(比如`reduce`、`map`等等)。

**异步输入/输出**

异步代码是 JavaScript 固有的，这意味着该语言本身为您提供了一些难以置信的构造，您可以使用它们来编写非阻塞 I/O 操作，而不必担心线程或其他复杂的机制。当然，我们说的是回调函数、承诺和`async` / `await`。

摘自 Mozilla 开发者网站的例子

请注意上面的代码——它读起来很容易，您不必记住是谁发出了请求或何时收到了响应。`async` / `await`组合允许你编写异步代码，就像它是同步代码一样。

**对于解释型语言来说非常有性能**

关于 JavaScript 的一个误解是，因为它没有被编译，所以它的性能不会很好。然而，大多数 JS 运行时实现了一个[实时(JIT)编译器](https://blog.bitsrc.io/the-jit-in-javascript-just-in-time-compiler-798b66e44143)，这使得它的执行速度非常快。事实上，代码运行的时间越长，JIT 编译器优化执行的机会就越多。

# 木卫一

Io 是一种纯面向对象的语言，从 SmallTalk、Lisp 和 Lua 等其他语言中汲取了一些灵感。和 JavaScript(以及其他)一样，它有一个基于原型的对象模型，并且对区分类和对象不感兴趣。在木卫一中一切都是对象。

它运行在一个小型虚拟机上，这使得它非常适合可嵌入的用例。Io 曾经被皮克斯用于他们的 [RenderMan](https://renderman.pixar.com/resources/RenderMan_20/programming_it.html) 渲染管道——在他们转向 Python 之前。虽然作者被引用说它被谣传用作卫星的一部分，但我个人找不到任何证据。

也就是说，Io 的模型非常有趣，因为它是基于消息和对象的。我说过，Io 中的一切都是对象，消息只是你与它们交互的方式。我们来看一个基本的“你好，世界！”示例:

```
"hello there peeps!" print
```

这需要一点时间来适应，特别是如果你来自其他类似 C 语言的语言，但是在这个例子中，我们将`print`消息传递给我们的 string 对象。

让我们看另一个例子，一个处理数字列表的例子:

```
d := List clone append(30, 10, 5, 20)
d print
```

这是一个有趣的例子，因为它展示了消息传递的机制。上面可以这样理解:

```
d := (List.clone()).append(30, 10, 5, 20)
d.print()
```

首先要做的是我们克隆列表，这就是在 Io 中创建新对象的方法。然后，在新实例上调用`append`方法。如何添加对`sort`方法的调用，以使最终结果正确排序？

像这样:

```
d := List clone append(30, 10, 5, 20) sort
d print
```

## 那么木卫一有什么特别之处呢？

抛开特殊的语法不谈，Io 有一些非常有趣的特征:

*   **纯面向对象**，用原型代替类。这意味着你要创建一个新的对象，你所要做的就是克隆一个现有的对象。这极大地简化了模型。
*   **具有高阶功能**。这允许使用函数式方法进行编程。这与 JavaScript 处理这个问题的方式非常相似。这基本上允许您使用函数，或者在 Io 中被称为属性的*槽*，允许您组合和传递行为。这是这种语言具有巨大灵活性的众多特性之一。
*   **自省与反省**。在 Io 中，你可以获得任何方法的实际代码，并在执行过程中修改它。这反过来又允许通常所说的 [*元编程*](https://en.wikipedia.org/wiki/Metaprogramming)*或者使用你的代码改变语言本身的能力。*

*还有其他的，比如懒惰评估、增量垃圾收集、异常处理等等。Io 是一种完美的函数式语言，如果你想了解更多，你可以查看他们的文档。*

*作为对这个有趣样本的总结，我想让您一瞥它的元编程能力。这里我们将重新定义`+`操作数。这是非常基本的事情，很少有语言允许这样做。*

```
*originPlus := Number getSlot("+")
Number + := method(i, if( i < 10, self originPlus(i), "that's just crazy!"))
(1+2) println
(2 + 100) println*
```

*上面的代码是:*

1.  *获取对`Number`对象的`+`方法的引用。*
2.  *用接收变量`i`并返回`if`语句的动态方法覆盖`Number`对象的`+`方法。`if`语句检查`i`的值，并基于它决定做什么(并因此返回)。*
3.  *最后两行只是测试我们的更改。*

*当然，该脚本的输出是:*

```
*3
that's just crazy!*
```

*你可以在这个[实时 REPL](https://tio.run/##y8z//1/JIzUnJ19HITy/KCdFUUmhoCgzr@T/fwA) 上玩代码和更多 Io。*

# *序言*

*Prolog 是我最喜欢的“未使用但将来可能非常有用”的语言之一。它背后的范例是如此充满潜力，以至于我对它没有更受欢迎感到困惑。我过去曾就此写过一篇完整的文章，但其背后的要点如下:*

*Prolog 是一种逻辑编程语言。这真的非常违背我们在 It 行业的大多数经验，我们知道我们需要做什么，所以我们告诉计算机做什么——在某些情况下，甚至如何做。*

*不过，Prolog 有所不同。通过逻辑编程，你建立了一个宇宙，并向计算机解释你的现实是什么样子。然后，你向它提问。做什么和如何做取决于运行时。*

*很有趣，不是吗？*

*请看下面的代码示例:*

```
*magicNumber(3)
magicNumber(5)
magicNumber(7)
magicNumber(9)
?- magicNumber(X), magicNumber(Y), plus(X, Y, 12)*
```

*前四行是建立宇宙——我们告诉我们的解释者我们有四个幻数。然后我们在问一个问题:给定`X`中的一个幻数和`Y`中的一个幻数，如果我把它们加在一起，哪一个会返回`12`？*

*结果当然是:*

```
*3, 9
5, 7
7, 5
9, 3*
```

*请注意，我不必迭代它们，也不必寻找多种组合或任何其他逻辑。我只是问了个问题。*

## *那么是什么让 Prolog 如此酷呢？*

*您可能不同意我的观点，但是使 Prolog 如此有趣并且是任何开发人员必须尝试的主要和最重要的特性是逻辑。*

*你可能在性格形成时期学过真值表，也可能见过一两件用逻辑证明数学问题的事情。但是如果你没有见过逻辑被应用于解决编程问题，那么你就错过了。*

*Prolog 用纯粹简单的逻辑为你解决一个问题。您不必编写解决方案，而是依靠 Prolog 来找到解决方案。*

*想象以下场景:您必须对一组学生、教师和主题进行建模。每个学生可以学习几门课程，每个老师可以教授一门课程。*

*如果您要使用传统的编程技术对此建模，您可能会想到使用数据库并查询类似“学生 X 正在学习哪门课程？”或者“谁在学 X 学科？”*

*使用 Prolog，如果您使用事实和规则对问题进行建模，您可以执行以下操作:*

```
*studies(charlie, csc135).
studies(olivia, csc135).
studies(charlie, csc1000).
studies(jack, csc131).  
studies(arthur, csc134).

teaches(kirke, csc135).  
teaches(collins, csc131). 
teaches(collins, csc171). 
teaches(juniper, csc134).professor(X, Y) :- teaches(X, C), studies(Y, C).*
```

***注:**示例摘自[http://Athena . ECS . csus . edu/~ mei/logi CP/prolog/programming-examples . html](http://athena.ecs.csus.edu/~mei/logicp/prolog/programming-examples.html)。*

*你有事实说明谁在学什么，谁在教什么科目。最后一行是建立一个规则，规定学生`Y`的教授`X`是教授其他人学习的科目的人。*

*然后，你就完成了。这是您的新数据库，您可以像这样提问(或者说，查询):*

```
*studies(What, csc134). //who's studying 'csc135'
=> What=arthur
professor(kirke, What). //who's professor Kirke teaching?
=> What=charlie
=> What=olivia*
```

*如你所见，逻辑引擎负责重要的部分，你的工作基本上包括正确设置宇宙，这样你就可以问它正确的问题。*

*对我来说，这就是 Prolog 的奇妙之处，也是为什么它被用于人工智能项目，如 IBM 的 Watson 或 GeneXus 的代码生成工具。*

*你可以使用[这个 REPL](https://swish.swi-prolog.org/) 在线试用 Prolog。*

# *Clojure*

*如果你想谈论看起来奇怪的语言，Clojure 绝对是不二之选(当然，不会碰到深奥的语言)。*

*Clojure 是一种主要的函数式编程语言，它提供了很高水平的动态行为，以及对多线程的出色支持。*

*有趣的是，它看起来与其他类 C 语言如此不同的一个主要原因是，因为它是基于 Lisp 的，所以一切都是列表。*

```
*(def a "hello world")
(print a)*
```

*这段代码将输出`hello world`，但有趣的是，这只是两个列表。Clojure 中两个括号之间的一切都是列表。正因为如此，列表的第一项总是被当作一个函数，这意味着如果你想实际声明一个值列表，你需要调用`list`函数:*

```
*(list 1 2 3 4 5 6)
'(1 2 3 4 5)*
```

*第二行是一个简写符号，以避免使用明显的`list`函数。*

*关于 Clojure 需要知道的另一件有趣的事情是，与它的父 Lisp 不同，它运行在 JVM 之上，这意味着您可以访问 Java。允许您在 Clojure 代码中混合 Java 类型、类和 JVM 的其他特性。这意味着你可以这样做:*

```
*(new java.util.Date "2016/2/19")*
```

*您实际上将获得一个有效的 Java date 对象来使用。*

## *主要特征*

*   ***动态环境**。同样，Clojure 是另一种动态语言，允许您在运行时重新定义它的行为。这变成了一种非常强大的极简 JVM 语言。它混合了 JVM 的强大功能和 Java 开发人员未知的灵活性。*
*   ***更轻松的并发**。因为 Clojure 中的主要数据结构是不可变的，所以在线程之间共享它们更容易——您不必担心不必要的修改。使用 Clojure，您可以忘记管理线程间的锁。*
*   ***功能编程**。虽然 Clojure 不是完全纯粹的，但当它涉及到 FP 时，它非常倾向于函数式编程。就像这里的其他语言一样，它有作为一等公民的函数的概念，这意味着你可以四处传递它们，并组合它们来创建新的、更复杂的行为。*
*   ***像 Java 但是更好**。因为它运行在 JVM 之上，并且您可以访问它的所有特性，所以您可以熟练地做任何您能够用 Java 做的事情，甚至使用它自己的一些本机类型和类。这使得它成为 Java 开发人员的一个很好的目标，这些开发人员正在寻找一种更有趣的语言。*

*Clojure 正被各种规模和行业的数百家公司积极使用。*

*   ***沃尔玛**。他们使用 Clojure 创建了一个可以处理 5，000 多家商店的商店管理系统。他们在这里谈论这件事。*
*   ***亚特兰蒂斯**。他们使用 Clojure 构建实时协作功能。他们谈得很好，谈到了这个问题和他们在这里得到的结果。*
*   ***ThoughtWorks** 。他们使用 [Clojure 来减少开发时间](http://thoughtworks.github.io/p2/issue09/two-months-early/)并加速现有的 Java 团队。这清楚地表明了这种语言的一个主要优点。由于它工作在 JVM 之上，让您的 JAVA 团队切换到 Clojure 意味着您可以避免更改项目的底层技术。*

*这份清单还可以继续列下去——你可以在这里查看[所有成功案例](https://clojure.org/community/success_stories)。*

# *锈*

*最后， [Rust](https://www.rust-lang.org/) 是我们整个旅程的最后一站。我想涵盖这一点，因为它显示了一些非常明显的区别。*

*Rust 是在 Mozilla 研究项目中设计和开发的，考虑到了性能和安全性。从语法上来说，它看起来很像 C++，和它一样，在执行之前需要编译。*

*然而，即使它在视觉上可能与 C 或 C++非常相似，它也从其他语言中汲取了许多线索，使它变得独特而强大。例如:*

*   *《铁锈》中几乎所有的东西都是一种表达方式。这意味着您可以创建带有卷带的块，然后将其内容赋给一个变量，如下所示:*

```
*fn main() {
   let x = 42; let y = {
        let x_squared = x * x;
        let x_cube = x_squared * x;
        x_cube + x_squared + x //this is the return value of the expression 
    }; println!("y is {:?}", y);
}*
```

*   *像用 Lisp(和 Clojure)一样，**函数不需要使用** `return` **语句。函数的最后一行将定义它的返回值。***
*   ***模式匹配**。通过使用`match`关键字，您可以为您的变量定义不同的模式，并相应地进行匹配。以下代码将定义一个范围，您可以使用该范围来匹配变量的值，并在没有匹配的情况下默认为另一种行为:*

```
*let x = 5;
match x {
    1..=5 => println!("one through five"),
    _ => println!("something else"),
}*
```

## *是什么让 Rust 这么酷？*

*   ***静态分类与动态分类**。在这一点上，Rust 试图与两个世界友好相处。它不是强迫开发人员为所有东西编写和定义类型，而是只要求顶级变量(如函数参数和常数)声明它们的类型，然后在函数内部，允许类型推断。看看下面的例子，Rust 可以推断出`result`的类型，因为它知道`a`和`b`的类型以及函数的返回类型。*

```
*fn simple_adder(a: i32, b: i32) -> i32 {
    let result = a + b;
    result
}*
```

*   *没有接口，也没有类——但是有一个选择。Rust 没有提供经典的类+接口组合，而是将赌注压在了特征、实现和结构上。您可以用数据结构的字段定义一个结构，然后通过向它添加行为(例如，方法)来围绕它创建一个特定的实现。最后，您甚至可以创建特征，这些特征的行为就像抽象类或接口，它们声明了一组您必须实现的方法。*

*上面的工作示例展示了如何使用这些新的构造来解决面向对象的需求。你可以在这里用一个[在线 REPL](https://repl.it/new/rust)试试上面的例子。*

*   ***缺少垃圾收集器实际上有助于**。Rust 没有垃圾收集器。相反，它允许您决定在哪里存储数据(堆栈或堆)，然后决定何时不再需要该内存。这反过来又提供了更有效和高性能的内存利用。*
*   ***嵌入式系统的理想选择**。由于它的低级 API 和对硬件和内存的直接访问，Rust 是使用现代语言在嵌入式系统上工作的理想选择。*

*如果你来自静态类型的世界，或者只是比我们行业的其他部门更接近硬件，你可能想给 Rust 一个机会。*

# *结论*

*这就是我们对这些语言的快速概述。当然，还有很多其他的，我知道我可能已经把你最喜欢的排除在外了。然而，这样做的目的是为了涵盖不同编程范例的不同实现，向您展示语言的多功能性。*

*如果我设法激起你对这些选项中至少一个的兴趣，那么我就认为我的工作完成了。*