<html>
<head>
<title>Demystifying fold() in Dart</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">揭开省道中褶皱()的神秘面纱</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/demystifying-fold-in-dart-faacb3bd4efd?source=collection_archive---------4-----------------------#2022-09-17">https://betterprogramming.pub/demystifying-fold-in-dart-faacb3bd4efd?source=collection_archive---------4-----------------------#2022-09-17</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="56bb" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">对fold()的概念性理解以及fold()和reduce()之间的主要区别</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/077837e851a98d3c0f5c23ff38009e86.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*TXMSs3H1Otn__vZ2qZl-7A.jpeg"/></div></div></figure><h1 id="304c" class="kr ks iq bd kt ku kv kw kx ky kz la lb jw lc jx ld jz le ka lf kc lg kd lh li bi translated"><strong class="ak">前言</strong></h1><p id="10ea" class="pw-post-body-paragraph lj lk iq ll b lm ln jr lo lp lq ju lr ls lt lu lv lw lx ly lz ma mb mc md me ij bi translated">在我上一篇关于<code class="fe mf mg mh mi b">map(),</code> <code class="fe mf mg mh mi b">where()</code>和<code class="fe mf mg mh mi b">reduce()</code>方法的文章中，我们探讨了Dart中三种最常用的收集方法。如果你错过了那篇文章，并且想知道更多关于那些方法，你可以在这里<a class="ae mj" href="https://medium.com/@darsshanNair/map-filter-where-and-reduce-in-dart-key-concepts-and-practical-usages-e5441dbc5b7" rel="noopener">阅读。</a></p><p id="3021" class="pw-post-body-paragraph lj lk iq ll b lm mk jr lo lp ml ju lr ls mm lu lv lw mn ly lz ma mo mc md me ij bi translated">当我发表那篇文章时，开发社区中的许多人希望我把<code class="fe mf mg mh mi b">fold()</code>包括进去。看到<code class="fe mf mg mh mi b">fold()</code>如此广泛的应用和如此独特，我想写一篇专门关于它的文章。这一条的目的如下:</p><ul class=""><li id="4405" class="mp mq iq ll b lm mk lp ml ls mr lw ms ma mt me mu mv mw mx bi translated">对<code class="fe mf mg mh mi b">fold()</code>的概念性理解。</li><li id="0fd5" class="mp mq iq ll b lm my lp mz ls na lw nb ma nc me mu mv mw mx bi translated">带代码示例的<code class="fe mf mg mh mi b">fold()</code>和<code class="fe mf mg mh mi b">reduce()</code>的显著区别。</li></ul><h1 id="5377" class="kr ks iq bd kt ku kv kw kx ky kz la lb jw lc jx ld jz le ka lf kc lg kd lh li bi translated"><strong class="ak">概念理解</strong></h1><p id="da89" class="pw-post-body-paragraph lj lk iq ll b lm ln jr lo lp lq ju lr ls lt lu lv lw lx ly lz ma mb mc md me ij bi translated">与<code class="fe mf mg mh mi b">reduce()</code>、<code class="fe mf mg mh mi b">map()</code>或<code class="fe mf mg mh mi b">where()</code>一样，<code class="fe mf mg mh mi b">fold()</code>方法是forEach()循环的扩展，能够接受条件并返回单个值或新集合，而不修改原始集合(是的，<em class="nd">不变性</em>)。由于我在上一篇文章中已经简要讨论了不变性的重要性，我将在这里省略对它的引用<a class="ae mj" href="https://medium.com/@darsshanNair/map-filter-where-and-reduce-in-dart-key-concepts-and-practical-usages-e5441dbc5b7#d690:~:text=Dart%20emphasises%20developers,in%20fact%20necessary." rel="noopener">。</a></p><p id="0e41" class="pw-post-body-paragraph lj lk iq ll b lm mk jr lo lp ml ju lr ls mm lu lv lw mn ly lz ma mo mc md me ij bi translated"><code class="fe mf mg mh mi b">fold()</code>方法的操作几乎与<code class="fe mf mg mh mi b"><a class="ae mj" href="https://medium.com/@darsshanNair/map-filter-where-and-reduce-in-dart-key-concepts-and-practical-usages-e5441dbc5b7#d690:~:text=it%20null%2Dsafe.-,reduce(),-The%20reduce()%20method" rel="noopener">reduce()</a></code>完全一样，它是一个累加器功能。它根据提供给它的条件将当前值与前面的值进行比较，并返回一个值作为结果。作为操作的一部分，<code class="fe mf mg mh mi b">fold()</code>方法需要输入一个初始值。这是它的方法签名的一部分，它是这样实现的:</p><pre class="kg kh ki kj gt ne mi nf ng aw nh bi"><span id="dc58" class="ni ks iq mi b gy nj nk l nl nm">T fold&lt;T&gt;(T initialValue, T combine(T previousValue, E element)) {</span><span id="bfcf" class="ni ks iq mi b gy nn nk l nl nm">var value = initialValue;<br/>for (E element in this) value = combine(value, element);<br/>return value;</span><span id="d82c" class="ni ks iq mi b gy nn nk l nl nm">}</span></pre><h1 id="4d89" class="kr ks iq bd kt ku kv kw kx ky kz la lb jw lc jx ld jz le ka lf kc lg kd lh li bi translated"><strong class="ak">显著差异</strong></h1><p id="511b" class="pw-post-body-paragraph lj lk iq ll b lm ln jr lo lp lq ju lr ls lt lu lv lw lx ly lz ma mb mc md me ij bi translated">由于<code class="fe mf mg mh mi b">fold()</code>和<code class="fe mf mg mh mi b">reduce()</code>彼此相似，所以了解它们之间的差异对我们来说很重要。这使得我们可以做出明智的决定，决定何时使用前者或后者来解决我们的编程问题。</p><h2 id="4514" class="ni ks iq bd kt no np dn kx nq nr dp lb ls ns nt ld lw nu nv lf ma nw nx lh ny bi translated"><strong class="ak"> 1。接受初始值</strong></h2><p id="2e2f" class="pw-post-body-paragraph lj lk iq ll b lm ln jr lo lp lq ju lr ls lt lu lv lw lx ly lz ma mb mc md me ij bi translated"><code class="fe mf mg mh mi b">fold()</code>和<code class="fe mf mg mh mi b">reduce()</code>的主要区别之一是<code class="fe mf mg mh mi b">fold()</code>允许我们不仅给它提供一个条件，还提供一个初始值。</p><pre class="kg kh ki kj gt ne mi nf ng aw nh bi"><span id="af30" class="ni ks iq mi b gy nj nk l nl nm">List&lt;int&gt; ages = [22, 28, 27, 19, 18];</span></pre><p id="21a4" class="pw-post-body-paragraph lj lk iq ll b lm mk jr lo lp ml ju lr ls mm lu lv lw mn ly lz ma mo mc md me ij bi translated"><code class="fe mf mg mh mi b">reduce()</code>方法假设索引0处的值为初始值:</p><pre class="kg kh ki kj gt ne mi nf ng aw nh bi"><span id="7973" class="ni ks iq mi b gy nj nk l nl nm">int totalAge = ages.reduce((totalLength, element) =&gt; totalLength +<!-- --> <!-- -->element);</span></pre><p id="606d" class="pw-post-body-paragraph lj lk iq ll b lm mk jr lo lp ml ju lr ls mm lu lv lw mn ly lz ma mo mc md me ij bi translated">当我们打印出<code class="fe mf mg mh mi b">totalAge</code>时，我们会得到一个值114。</p><p id="997f" class="pw-post-body-paragraph lj lk iq ll b lm mk jr lo lp ml ju lr ls mm lu lv lw mn ly lz ma mo mc md me ij bi translated"><code class="fe mf mg mh mi b">fold()</code>方法将把提供给它的值作为初始值。这允许指示操作应该从哪个值开始，并影响整体结果:</p><pre class="kg kh ki kj gt ne mi nf ng aw nh bi"><span id="bc8a" class="ni ks iq mi b gy nj nk l nl nm">int totalAge = ages.fold(10, (totalLength, element) =&gt; totalLength +<!-- --> <!-- -->element);</span><span id="4765" class="ni ks iq mi b gy nn nk l nl nm">print(totalAge); // 124</span></pre><h2 id="5d1d" class="ni ks iq bd kt no np dn kx nq nr dp lb ls ns nt ld lw nu nv lf ma nw nx lh ny bi translated"><strong class="ak"> 2。能够对空集合进行操作</strong></h2><p id="8740" class="pw-post-body-paragraph lj lk iq ll b lm ln jr lo lp lq ju lr ls lt lu lv lw lx ly lz ma mb mc md me ij bi translated"><code class="fe mf mg mh mi b">reduce()</code>方法不能在空集合上操作。让我们看一个例子来进一步理解它。</p><pre class="kg kh ki kj gt ne mi nf ng aw nh bi"><span id="7c1a" class="ni ks iq mi b gy nj nk l nl nm">List&lt;String&gt; ages = [];</span><span id="7452" class="ni ks iq mi b gy nn nk l nl nm">String totalAge = ages.reduce((value, element) =&gt; value + element);</span></pre><p id="e7e3" class="pw-post-body-paragraph lj lk iq ll b lm mk jr lo lp ml ju lr ls mm lu lv lw mn ly lz ma mo mc md me ij bi translated">当它试图遍历<code class="fe mf mg mh mi b">names</code>集合时，会遇到一个错误:<code class="fe mf mg mh mi b">Bad state: No element</code></p><p id="d27d" class="pw-post-body-paragraph lj lk iq ll b lm mk jr lo lp ml ju lr ls mm lu lv lw mn ly lz ma mo mc md me ij bi translated">现在让我们看看使用fold()时会发生什么。</p><pre class="kg kh ki kj gt ne mi nf ng aw nh bi"><span id="6fe2" class="ni ks iq mi b gy nj nk l nl nm">List&lt;String&gt; ages = [];</span><span id="d637" class="ni ks iq mi b gy nn nk l nl nm">String totalAge = ages.fold(10, (value, element) =&gt; value + element);</span><span id="74c1" class="ni ks iq mi b gy nn nk l nl nm">print(totalAge); // 10</span></pre><p id="f597" class="pw-post-body-paragraph lj lk iq ll b lm mk jr lo lp ml ju lr ls mm lu lv lw mn ly lz ma mo mc md me ij bi translated"><code class="fe mf mg mh mi b">fold()</code>方法可以很好地处理这个问题。这主要是因为它有一个初始值作为后备。初始值成为最小支持度。</p><h2 id="59e4" class="ni ks iq bd kt no np dn kx nq nr dp lb ls ns nt ld lw nu nv lf ma nw nx lh ny bi translated"><strong class="ak"> 3。能够从集合中返回不同的值类型</strong></h2><p id="a3a5" class="pw-post-body-paragraph lj lk iq ll b lm ln jr lo lp lq ju lr ls lt lu lv lw lx ly lz ma mb mc md me ij bi translated">类似于<code class="fe mf mg mh mi b">reduce()</code>方法，<code class="fe mf mg mh mi b">fold()</code>也返回单个值，但是与reduce()不同，reduce()需要将与集合相同类型的值返回回调，<code class="fe mf mg mh mi b">fold()</code>可以返回完全不同类型的值，而不管集合的类型。</p><p id="253a" class="pw-post-body-paragraph lj lk iq ll b lm mk jr lo lp ml ju lr ls mm lu lv lw mn ly lz ma mo mc md me ij bi translated">因此，如果您正在处理类型为<code class="fe mf mg mh mi b">string</code>的集合，那么reduce()将只返回一个字符串作为最终结果。</p><p id="8aa8" class="pw-post-body-paragraph lj lk iq ll b lm mk jr lo lp ml ju lr ls mm lu lv lw mn ly lz ma mo mc md me ij bi translated">而<code class="fe mf mg mh mi b">fold()</code>可以在需要时返回一个整数，即使它正在对<code class="fe mf mg mh mi b">string</code>的列表进行操作。</p><p id="6071" class="pw-post-body-paragraph lj lk iq ll b lm mk jr lo lp ml ju lr ls mm lu lv lw mn ly lz ma mo mc md me ij bi translated">现在，这可能有点令人困惑，所以请允许我给出一个相对较长的例子来解释这一点。</p><p id="e7f6" class="pw-post-body-paragraph lj lk iq ll b lm mk jr lo lp ml ju lr ls mm lu lv lw mn ly lz ma mo mc md me ij bi translated">所以让我们来看一个问题，并弄清楚我们如何用<code class="fe mf mg mh mi b">fold()</code>方法的独特特征来解决它。</p><p id="64e7" class="pw-post-body-paragraph lj lk iq ll b lm mk jr lo lp ml ju lr ls mm lu lv lw mn ly lz ma mo mc md me ij bi translated">背景:</p><p id="0f05" class="pw-post-body-paragraph lj lk iq ll b lm mk jr lo lp ml ju lr ls mm lu lv lw mn ly lz ma mo mc md me ij bi translated">命理计算器应用程序有四个输入字段。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi nz"><img src="../Images/619230dc86af44014682a363560a9db9.png" data-original-src="https://miro.medium.com/v2/resize:fit:600/format:webp/1*IMvFoUD74ky8bqxb8-IoCw.jpeg"/></div></figure><p id="4b81" class="pw-post-body-paragraph lj lk iq ll b lm mk jr lo lp ml ju lr ls mm lu lv lw mn ly lz ma mo mc md me ij bi translated">这些字段的值被添加到字符串类型的<code class="fe mf mg mh mi b">List</code>中。</p><pre class="kg kh ki kj gt ne mi nf ng aw nh bi"><span id="af77" class="ni ks iq mi b gy nj nk l nl nm">List&lt;String&gt; names = ["John", "Doe", "Jane", "Doe"];</span></pre><p id="11c5" class="pw-post-body-paragraph lj lk iq ll b lm mk jr lo lp ml ju lr ls mm lu lv lw mn ly lz ma mo mc md me ij bi translated">计算兼容性的算法主要依赖于<code class="fe mf mg mh mi b">names</code>中名称的总长度。我们不能使用<code class="fe mf mg mh mi b">reduce()</code>来计算<code class="fe mf mg mh mi b">List</code>中所有字符串的总长度。</p><pre class="kg kh ki kj gt ne mi nf ng aw nh bi"><span id="f119" class="ni ks iq mi b gy nj nk l nl nm">names.reduce((totalLength, element) =&gt; totalLength + element.length);</span></pre><p id="29f7" class="pw-post-body-paragraph lj lk iq ll b lm mk jr lo lp ml ju lr ls mm lu lv lw mn ly lz ma mo mc md me ij bi translated">这样会产生一个错误说:<code class="fe mf mg mh mi b">The argument type ‘int’ can’t be assigned to the parameter type ‘String’</code> <em class="nd">。</em></p><p id="80c0" class="pw-post-body-paragraph lj lk iq ll b lm mk jr lo lp ml ju lr ls mm lu lv lw mn ly lz ma mo mc md me ij bi translated">这是因为，<code class="fe mf mg mh mi b">reduce()</code>要求返回值在整个操作中是相同的类型。</p><p id="f4e4" class="pw-post-body-paragraph lj lk iq ll b lm mk jr lo lp ml ju lr ls mm lu lv lw mn ly lz ma mo mc md me ij bi translated">在这些情况下，我们可以使用<code class="fe mf mg mh mi b">fold()</code>来解决这个问题:</p><pre class="kg kh ki kj gt ne mi nf ng aw nh bi"><span id="cc61" class="ni ks iq mi b gy nj nk l nl nm">int totalNamesLength = names.fold(0, (totalLength, element) =&gt; totalLength + element.length);</span><span id="3d9c" class="ni ks iq mi b gy nn nk l nl nm">print(totalNamesLength); // 14</span></pre><h1 id="4722" class="kr ks iq bd kt ku kv kw kx ky kz la lb jw lc jx ld jz le ka lf kc lg kd lh li bi translated"><strong class="ak">结论</strong></h1><p id="0663" class="pw-post-body-paragraph lj lk iq ll b lm ln jr lo lp lq ju lr ls lt lu lv lw lx ly lz ma mb mc md me ij bi translated">现在我们已经到了本文的结尾，以下是从中得到的启示:</p><ul class=""><li id="e80c" class="mp mq iq ll b lm mk lp ml ls mr lw ms ma mt me mu mv mw mx bi translated"><code class="fe mf mg mh mi b">fold()</code>是一种累加器方法，类似于<code class="fe mf mg mh mi b">reduce()</code></li><li id="4167" class="mp mq iq ll b lm my lp mz ls na lw nb ma nc me mu mv mw mx bi translated"><code class="fe mf mg mh mi b">fold()</code>允许我们给操作一个初始值，而不是假设集合中的第一个值为初始值</li><li id="5834" class="mp mq iq ll b lm my lp mz ls na lw nb ma nc me mu mv mw mx bi translated"><code class="fe mf mg mh mi b">fold()</code>可以对空集合进行操作并优雅地处理它</li><li id="1f49" class="mp mq iq ll b lm my lp mz ls na lw nb ma nc me mu mv mw mx bi translated"><code class="fe mf mg mh mi b">fold()</code>可以返回一个与它所操作的集合中的值类型不同的值。</li></ul></div></div>    
</body>
</html>