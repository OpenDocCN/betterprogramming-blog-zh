<html>
<head>
<title>Pair Programming With AI: Writing a Distributed, Fault-Tolerant Redis Client Using ChatGPT</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">用AI进行结对编程:使用ChatGPT编写分布式容错Redis客户机</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/pair-programming-with-ai-writing-a-distributed-fault-tolerant-redis-client-using-chatgpt-239dc0a90550?source=collection_archive---------1-----------------------#2022-12-07">https://betterprogramming.pub/pair-programming-with-ai-writing-a-distributed-fault-tolerant-redis-client-using-chatgpt-239dc0a90550?source=collection_archive---------1-----------------------#2022-12-07</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="a73e" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">使用ChatGPT提示符构建软件</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/6a59cd4e8a1a6abb306b7984ab46c55d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*0VwevxAJRVmC1tjc"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">在<a class="ae kv" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上由<a class="ae kv" href="https://unsplash.com/es/@courtneycorlew?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Courtney Corlew </a>拍摄的照片</p></figure><p id="f176" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><a class="ae kv" href="https://karpathy.medium.com/software-2-0-a64152b37c35" rel="noopener">软件2.0 </a>即将到来。我们工作、娱乐和社交方式的本质将会改变。除非你一直生活在岩石下，否则你很可能会在互联网上看到很酷的演示和截图。一个常见的主题是，它非常适合创造性的用例，如写故事、开玩笑、<a class="ae kv" href="https://twitter.com/goodside/status/1598129631609380864?s=20&amp;t=KhcW177IQLR_JXqHMJV0UQ" rel="noopener ugc nofollow" target="_blank">解释冒泡排序如何像1940年代的强盗那样工作</a>等。我想看看我们是否可以用它在我的领域里做一些更有用的事情:写一些好的软件1.0。</p><p id="49d2" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">作为一名“参谋工程师”，你日常工作的一部分就是想办法让自己和团队更有效率。这包括实现正确的抽象，采用有用的工具/框架，与高级/初级工程师一起工作并对他们进行培训，并使他们成长到不需要动手就能工作的程度。</p><p id="ae2e" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">那么应该如何看待ChatGPT呢？我应该把它看作一个有用的工具/框架吗？还是一个聪明的初级工程师，他只是需要一些指导？让我们找出答案。</p><h1 id="67c8" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">项目目标</h1><p id="7469" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">我这个项目的目标是深入了解以下内容:</p><ol class=""><li id="6311" class="mp mq iq ky b kz la lc ld lf mr lj ms ln mt lr mu mv mw mx bi translated">我能比平时更快地做出原型吗？</li><li id="cd04" class="mp mq iq ky b kz my lc mz lf na lj nb ln nc lr mu mv mw mx bi translated">类似于一个初级工程师，我能教ChatGPT足够多的东西以至于以后不用太多手握它吗？(也就是说，我能让ChatGPT增长到足以让它升职吗)</li><li id="a9c3" class="mp mq iq ky b kz my lc mz lf na lj nb ln nc lr mu mv mw mx bi translated">最后，我希望弄清楚ChatGPT在什么样的复杂程度上开始挣扎。</li></ol><p id="2cb1" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">因为这是我第一次尝试让ChatGPT为我做一些编码，所以我想确保我承担了一个合理范围的问题:</p><ol class=""><li id="78bf" class="mp mq iq ky b kz la lc ld lf mr lj ms ln mt lr mu mv mw mx bi translated"><strong class="ky ir">做一些它可能已经接触过的事情:</strong> Redis是一个拥有大量文档、代码样本和开源客户端的系统，我相信ChatGPT会在这方面进行大量培训。事实上，如果你只是要求它从头实现一个Redis客户端，它很可能会从内存中吐出一个，这与任何在线实现都非常相似。</li><li id="e245" class="mp mq iq ky b kz my lc mz lf na lj nb ln nc lr mu mv mw mx bi translated"><strong class="ky ir">通过引入新的概念来增加一定的复杂性:</strong> <br/>由于它可能见过许多Redis客户端，让我们看看是否可以从一个简单的客户端开始，然后添加<strong class="ky ir"> <em class="nd">复制</em> </strong>(用于容错)和<strong class="ky ir"> <em class="nd">分片</em> </strong>(用于可伸缩性)的概念。<br/>它可能已经学会了什么是复制和分片，但不是在构建我们的定制客户端的上下文中，所以我们必须指导它。</li></ol><p id="c183" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">结果呢？一个完全由ChatGPT编写的分布式容错Redis客户端，可以很容易地用其他语言重新实现！</p><p id="e249" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><em class="nd">请注意，这是一个POC实现，它具有很差的代码抽象和潜在的错误。这个项目的目标是看我们如何使用ChatGPT进行编码，而不是编写第200个Redis客户端，所以请不要推敲代码质量；可怜的人已经尽力了。</em></p><h1 id="90f8" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">我们想要建立什么？</h1><p id="9194" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">我们试图构建一个Redis客户端，它具有容错和可伸缩的密钥空间，这是一个非常高的级别，类似于最初的<a class="ae kv" href="https://www.allthingsdistributed.com/files/amazon-dynamo-sosp2007.pdf" rel="noopener ugc nofollow" target="_blank"> DynamoDB架构</a>。</p><p id="d36c" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这是一个Redis节点。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi ne"><img src="../Images/e2b5362363b88ba49aca25a25fee5500.png" data-original-src="https://miro.medium.com/v2/resize:fit:418/format:webp/1*rufD-zGmr4UiWvsdCRGwwg.png"/></div></figure><p id="acf6" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">为了实现容错，我们添加了复制。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi nf"><img src="../Images/5543a1964225716b0844878ea36a4142.png" data-original-src="https://miro.medium.com/v2/resize:fit:412/format:webp/1*s42HitUFh_j-9i2KMU5GRA.png"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">具有3个副本的Redis集群</p></figure><p id="21f5" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">为了实现可伸缩的地址空间，我们通过根据我们想要支持的数据集的大小选择服务器的数量来划分密钥空间。然后，我们通过某种一致的哈希算法运行每个密钥，以找到它属于哪个碎片。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi ng"><img src="../Images/6a915e2c347c44476aa2ba89c3a2ad93.png" data-original-src="https://miro.medium.com/v2/resize:fit:1276/format:webp/1*D0F4Cj4JuOpfpZ502tLXbQ.png"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">具有3个碎片和3个副本的Redis集群</p></figure><p id="32cd" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们将支持<code class="fe nh ni nj nk b">GET</code>、<code class="fe nh ni nj nk b">SET</code>和<code class="fe nh ni nj nk b">DELETE</code>行动。</p><p id="70a8" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在<code class="fe nh ni nj nk b">SET</code>和<code class="fe nh ni nj nk b">DELETE</code>上，我们的客户端库将为给定的密钥选择正确的碎片，并将<code class="fe nh ni nj nk b">SET</code> / <code class="fe nh ni nj nk b">DELETE</code>发送给所有3个副本。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nl"><img src="../Images/8329a445f4e7910a513ebdb1750046c1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*8HKV7YBU2E2betRUweknRw.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">例如:客户端向碎片1写入设置或删除</p></figure><p id="a4f2" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在GET中，我们的客户端库将为给定的密钥选择正确的碎片，并从该碎片的任何一个副本中读取。如果第一个副本返回错误，它将尝试下一个，直到其中任何一个返回成功值。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nm"><img src="../Images/127b55166d0612e9beb182271531fd2a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*3sloWRMiL8X_4WzlHb-Sow.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">客户端从一个碎片中读取数据。虚线表示故障转移。</p></figure><p id="92d6" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我选择Go是因为它在语法上不像C++那样复杂，也不像Python那样简单。我想给ChatGPT一个足够公平的挑战。</p><p id="6685" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><strong class="ky ir">限制:</strong>它是一个单线程客户端，不做任何日志记录或度量。这是纯粹的POC。</p><p id="e520" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">现在我们已经了解了我们正在构建什么，让我们开始吧。</p><h1 id="a95c" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">设置基本的单节点客户端</h1><p id="5d73" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">编写客户机的核心部分是支持客户机和服务器之间的有线协议。Redis有一个非常好记录的简单协议，叫做<a class="ae kv" href="https://redis.io/docs/reference/protocol-spec/" rel="noopener ugc nofollow" target="_blank"> RESP </a> (Redis序列化协议)，ChatGPT肯定会学习这个协议。<br/>我最初想尝试向它解释一个全新的协议，看看它是否理解它，并能为它编写一个客户端。这可能更复杂，但也是可行的。然而，为了简单起见，我使用了一个众所周知的协议。</p><p id="9503" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">首先，让我们确认它已经理解了RESP。</p><p id="080d" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><em class="nd">注意:我的问题以粗体显示。</em></p><blockquote class="nn no np"><p id="97cb" class="kw kx nd ky b kz la jr lb lc ld ju le nq lg lh li nr lk ll lm ns lo lp lq lr ij bi translated"><strong class="ky ir">你了解Redis序列化协议吗？</strong></p><p id="6fb5" class="kw kx nd ky b kz la jr lb lc ld ju le nq lg lh li nr lk ll lm ns lo lp lq lr ij bi translated">是的，我熟悉Redis序列化协议(RESP)。它是一个协议，指定Redis如何对其数据结构进行编码，并通过网络将它们发送到客户端或Redis集群中的实例之间。RESP用于以高效且易于解析的方式编码数据结构，如字符串、列表、集合和散列。它允许Redis以一致和可预测的方式与客户机和其他Redis实例通信。</p></blockquote><p id="2457" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">确实如此。让我们初始化我们的客户端:</p><blockquote class="nn no np"><p id="14e6" class="kw kx nd ky b kz la jr lb lc ld ju le nq lg lh li nr lk ll lm ns lo lp lq lr ij bi translated">我想让你在Go中写一个简单的Redis客户端库。它应该首先支持以下内容:</p><p id="7abe" class="kw kx nd ky b kz la jr lb lc ld ju le nq lg lh li nr lk ll lm ns lo lp lq lr ij bi translated"><strong class="ky ir"> 1。它应该采用一个IP:Port对并连接到服务器。<br/> 2。它应该能够处理整个RESP协议。<br/> 3。它应该支持GET、SET和DELETE命令，并为每个命令公开API。<br/> 4。它应该适当地处理错误。</strong></p><p id="0d97" class="kw kx nd ky b kz la jr lb lc ld ju le nq lg lh li nr lk ll lm ns lo lp lq lr ij bi translated">这里有一个简单的Go Redis客户端库，它支持GET、SET和DELETE命令，并使用RESP协议。该库接受一个IP:Port对，并使用它连接到指定的Redis服务器。它还包括错误处理。</p></blockquote><pre class="kg kh ki kj gt nt nk nu bn nv nw bi"><span id="3c30" class="nx lt iq nk b be ny nz l oa ob">package main<br/><br/>import (<br/> "bufio"<br/> "bytes"<br/> "errors"<br/> "fmt"<br/> "net"<br/> "strconv"<br/>)<br/><br/>const (<br/> GET byte = iota<br/> SET<br/> DELETE<br/>)<br/><br/>type RedisClient struct {<br/> conn net.Conn<br/> reader *bufio.Reader<br/> writer *bufio.Writer<br/>}<br/><br/>func NewRedisClient(ip string, port int) (*RedisClient, error) {<br/> address := fmt.Sprintf("%s:%d", ip, port)<br/> conn, err := net.Dial("tcp", address)<br/> if err != nil {<br/>  return nil, err<br/> }<br/><br/> return &amp;RedisClient{<br/>  conn: conn,<br/>  reader: bufio.NewReader(conn),<br/>  writer: bufio.NewWriter(conn),<br/> }, nil<br/>}<br/><br/>func (c *RedisClient) Get(key string) (string, error) {<br/> err := c.sendCommand(GET, key)<br/> if err != nil {<br/>  return "", err<br/> }<br/><br/> return c.readBulkString()<br/>}<br/><br/>func (c *RedisClient) Set(key, value string) error {<br/> err := c.sendCommand(SET, key, value)<br/> if err != nil {<br/>  return err<br/> }<br/><br/> _, err = c.readSimpleString()<br/> return err<br/>}<br/><br/>func (c *RedisClient) Delete(key string) error {<br/> err := c.sendCommand(DELETE, key)<br/> if err != nil {<br/>  return err<br/> }<br/><br/> _, err = c.readSimpleString()<br/> return err<br/>}<br/><br/>func (c *RedisClient) Close() error {<br/> return c.conn.Close()<br/>}<br/><br/>func (c *RedisClient) sendCommand(command byte, args ...string) error {<br/> c.writer.WriteByte('*')<br/> c.writer.WriteString(strconv.Itoa(len(args) + 1))<br/> c.writer.WriteByte('\r')<br/> c.writer.WriteByte('\n')<br/><br/> c.writer.WriteByte('$')<br/> c.writer.WriteString(strconv.Itoa(1))<br/> c.writer.WriteByte('\r')<br/> c.writer.WriteByte('\n')<br/><br/> c.writer.WriteByte(command)<br/> c.writer.WriteByte('\r')<br/> c.writer.WriteByte('\n')<br/><br/> for _, arg := range args {<br/>  c.writer.WriteByte('$')<br/>  c.writer.WriteString(strconv.Itoa(len(arg)))<br/>  c.writer.WriteByte('\r')<br/>  c.writer.WriteByte('\n')<br/>  c.writer.WriteString(arg)<br/>  c.writer.WriteByte('\r')<br/>  c.writer.WriteByte('\n')<br/> }</span></pre><p id="76c2" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这是我第一次挑战ChatGPT。如果响应太大，它会在中间划出区域—可能是由于一些字数限制。注意<code class="fe nh ni nj nk b">sendCommand()</code>是如何不完整的。</p><blockquote class="nn no np"><p id="3801" class="kw kx nd ky b kz la jr lb lc ld ju le nq lg lh li nr lk ll lm ns lo lp lq lr ij bi translated">你能完成sendCommand()的实现吗？</p><p id="a6fa" class="kw kx nd ky b kz la jr lb lc ld ju le nq lg lh li nr lk ll lm ns lo lp lq lr ij bi translated">当然可以。下面是完整的sendCommand()函数:</p></blockquote><pre class="kg kh ki kj gt nt nk nu bn nv nw bi"><span id="8bb5" class="nx lt iq nk b be ny nz l oa ob">func (c *RedisClient) sendCommand(command byte, args ...string) error {<br/> c.writer.WriteByte('*')<br/> c.writer.WriteString(strconv.Itoa(len(args) + 1))<br/> c.writer.WriteByte('\r')<br/> c.writer.WriteByte('\n')<br/><br/> c.writer.WriteByte('$')<br/> c.writer.WriteString(strconv.Itoa(1))<br/> c.writer.WriteByte('\r')<br/> c.writer.WriteByte('\n')<br/><br/> c.writer.WriteByte(command)<br/> c.writer.WriteByte('\r')<br/> c.writer.WriteByte('\n')<br/><br/> for _, arg := range args {<br/>  c.writer.WriteByte('$')<br/>  c.writer.WriteString(strconv.Itoa(len(arg)))<br/>  c.writer.WriteByte('\r')<br/>  c.writer.WriteByte('\n')<br/>  c.writer.WriteString(arg)<br/>  c.writer.WriteByte('\r')<br/>  c.writer.WriteByte('\n')<br/> }<br/><br/> return c.writer.Flush()<br/>}</span></pre><p id="c289" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">它还展示了一个关于<code class="fe nh ni nj nk b">sendCommand()</code>如何工作的简介，就像我问的几乎每一个代码更改一样，但是为了避免这篇文章变得太长，我删除了多余的回复。如果你有兴趣看它到底说了什么，完整的文字记录在这里。很长但是很有趣。</p><p id="e5ea" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">接下来，我让它实现readSimpleString()和readBulkString()命令。它最后实现了有bug的readSimpleString()，我只好要求它重新实现。它仍然返回错误，所以我必须告诉它要修复的确切错误。</p><blockquote class="nn no np"><p id="ebd3" class="kw kx nd ky b kz la jr lb lc ld ju le nq lg lh li nr lk ll lm ns lo lp lq lr ij bi translated"><strong class="ky ir"> readSimpleString()和readBulkString()未定义。你能实现这两个功能吗？记得支持整个RESP协议。</strong></p><p id="a5c6" class="kw kx nd ky b kz la jr lb lc ld ju le nq lg lh li nr lk ll lm ns lo lp lq lr ij bi">…</p></blockquote><pre class="kg kh ki kj gt nt nk nu bn nv nw bi"><span id="93d8" class="nx lt iq nk b be ny nz l oa ob">func (c *RedisClient) readSimpleString() (string, error) {<br/> prefix, err := c.reader.ReadByte()<br/> if err != nil {<br/>  return "", err<br/> }<br/><br/> if prefix != '+' {<br/>  return "", errors.New("unexpected prefix")<br/> }<br/><br/> line, err := c.reader.ReadString('\n')<br/> if err != nil {<br/>  return "", err<br/> }<br/><br/> return line[:len(line)-2], nil<br/>}</span></pre><p id="1600" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><code class="fe nh ni nj nk b">readSimpleString()</code>在这里其实是不完整的。</p><blockquote class="nn no np"><p id="cf36" class="kw kx nd ky b kz la jr lb lc ld ju le nq lg lh li nr lk ll lm ns lo lp lq lr ij bi translated"><strong class="ky ir"> readSimpleString()仅支持RESP的“+”。你也能支持'-'吗？</strong></p><p id="50a6" class="kw kx nd ky b kz la jr lb lc ld ju le nq lg lh li nr lk ll lm ns lo lp lq lr ij bi">…</p></blockquote><pre class="kg kh ki kj gt nt nk nu bn nv nw bi"><span id="8730" class="nx lt iq nk b be ny nz l oa ob">func (c *RedisClient) readSimpleString() (string, error) {<br/> prefix, err := c.reader.ReadByte()<br/> if err != nil {<br/>  return "", err<br/> }<br/><br/> if prefix != '+' &amp;&amp; prefix != '-' {<br/>  return "", errors.New("unexpected prefix")<br/> }<br/><br/> line, err := c.reader.ReadString('\n')<br/> if err != nil {<br/>  return "", err<br/> }<br/><br/> return line[:len(line)-2], nil<br/>}</span></pre><p id="dcb9" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">它最终“支持”“-”，但不是以正确的方式。在RESP，“-”表示错误，“+”表示响应成功。所以我不得不告诉它这样做:</p><blockquote class="nn no np"><p id="8012" class="kw kx nd ky b kz la jr lb lc ld ju le nq lg lh li nr lk ll lm ns lo lp lq lr ij bi translated"><strong class="ky ir">在readSimpleString()中，如果'前缀'是'-'，则返回剩余的一行作为错误。</strong></p><p id="df7a" class="kw kx nd ky b kz la jr lb lc ld ju le nq lg lh li nr lk ll lm ns lo lp lq lr ij bi">…</p></blockquote><pre class="kg kh ki kj gt nt nk nu bn nv nw bi"><span id="9de8" class="nx lt iq nk b be ny nz l oa ob">func (c *RedisClient) readSimpleString() (string, error) {<br/> prefix, err := c.reader.ReadByte()<br/> if err != nil {<br/>  return "", err<br/> }<br/><br/> if prefix != '+' &amp;&amp; prefix != '-' {<br/>  return "", errors.New("unexpected prefix")<br/> }<br/><br/> line, err := c.reader.ReadString('\n')<br/> if err != nil {<br/>  return "", err<br/> }<br/><br/> if prefix == '-' {<br/>  return "", errors.New(line[:len(line)-2])<br/> }<br/><br/> return line[:len(line)-2], nil<br/>}</span></pre><p id="ab40" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">它仍然没有得到它的权利。如果您阅读代码，它总是在<code class="fe nh ni nj nk b">ReadString()</code>之后将成功字符串和错误字符串重新解释为错误。所以我让它重做整个功能，但它回来的功能完全一样。在这里，我意识到我必须更加规范，就像代码审查一样；因为它不明白。</p><blockquote class="nn no np"><p id="5da0" class="kw kx nd ky b kz la jr lb lc ld ju le nq lg lh li nr lk ll lm ns lo lp lq lr ij bi translated"><strong class="ky ir">移动前缀= = '--'在ReadString()前检查。</strong></p><p id="cff7" class="kw kx nd ky b kz la jr lb lc ld ju le nq lg lh li nr lk ll lm ns lo lp lq lr ij bi">…</p></blockquote><pre class="kg kh ki kj gt nt nk nu bn nv nw bi"><span id="c34a" class="nx lt iq nk b be ny nz l oa ob">func (c *RedisClient) readSimpleString() (string, error) {<br/> prefix, err := c.reader.ReadByte()<br/> if err != nil {<br/>  return "", err<br/> }<br/><br/> if prefix == '-' {<br/>  line, err := c.reader.ReadString('\n')<br/>  if err != nil {<br/>   return "", err<br/>  }<br/><br/>  return "", errors.New(line[:len(line)-2])<br/> }<br/><br/> if prefix != '+' {<br/>  return "", errors.New("unexpected prefix")<br/> }<br/><br/> line, err := c.reader.ReadString('\n')<br/> if err != nil {<br/>  return "", err<br/> }<br/><br/> return line[:len(line)-2], nil<br/>}</span></pre><p id="d705" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这太好了，这意味着即使我必须是规定性的，我也可以像对一个人那样审查它的代码，它理解我。你可以看到代码质量很差，因为它有一些重复的代码，但它工作。在未来，我想看看我是否能教它写更干净的代码，但目前，我不想这么早就与太多的上下文混淆。</p><p id="2933" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">很好，现在我们有了初始客户端，但是它不能编译。问题是<code class="fe nh ni nj nk b">sendCommand()</code>接受一个常量字节的命令，并把它写到网络上，而RESP协议期望它是一个字符串。</p><blockquote class="nn no np"><p id="7e8c" class="kw kx nd ky b kz la jr lb lc ld ju le nq lg lh li nr lk ll lm ns lo lp lq lr ij bi translated"><strong class="ky ir">能否重新实现sendCommand()以将“Command”作为字符串？</strong></p><p id="8e61" class="kw kx nd ky b kz la jr lb lc ld ju le nq lg lh li nr lk ll lm ns lo lp lq lr ij bi">…</p></blockquote><pre class="kg kh ki kj gt nt nk nu bn nv nw bi"><span id="977a" class="nx lt iq nk b be ny nz l oa ob">func (c *RedisClient) sendCommand(command string, args ...string) error {<br/> c.writer.WriteByte('*')<br/> c.writer.WriteString(strconv.Itoa(len(args) + 1))<br/> c.writer.WriteByte('\r')<br/> c.writer.WriteByte('\n')<br/><br/> c.writer.WriteByte('$')<br/> c.writer.WriteString(strconv.Itoa(len(command)))<br/> c.writer.WriteByte('\r')<br/> c.writer.WriteByte('\n')<br/><br/> c.writer.WriteString(command)<br/> c.writer.WriteByte('\r')<br/> c.writer.WriteByte('\n')<br/><br/> for _, arg := range args {<br/>  c.writer.WriteByte('$')<br/>  c.writer.WriteString(strconv.Itoa(len(arg)))<br/>  c.writer.WriteByte('\r')<br/>  c.writer.WriteByte('\n')<br/>  c.writer.WriteString(arg)<br/>  c.writer.WriteByte('\r')<br/>  c.writer.WriteByte('\n')<br/> }<br/><br/> return c.writer.Flush()<br/>}</span></pre><p id="ae2d" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">现在，我们需要更新这个函数的调用者。</p><blockquote class="nn no np"><p id="1946" class="kw kx nd ky b kz la jr lb lc ld ju le nq lg lh li nr lk ll lm ns lo lp lq lr ij bi translated"><strong class="ky ir">现在重新实现Get()、Set()和Delete()以使用sendCommand()的新实现</strong></p><p id="7736" class="kw kx nd ky b kz la jr lb lc ld ju le nq lg lh li nr lk ll lm ns lo lp lq lr ij bi">…</p></blockquote><pre class="kg kh ki kj gt nt nk nu bn nv nw bi"><span id="d273" class="nx lt iq nk b be ny nz l oa ob">func (c *RedisClient) Get(key string) (string, error) {<br/> if err := c.sendCommand("GET", key); err != nil {<br/>  return "", err<br/> }<br/><br/> return c.readBulkString()<br/>}<br/><br/>func (c *RedisClient) Set(key, value string) error {<br/> if err := c.sendCommand("SET", key, value); err != nil {<br/>  return err<br/> }<br/><br/> _, err := c.readSimpleString()<br/> return err<br/>}<br/><br/>func (c *RedisClient) Delete(key string) error {<br/> if err := c.sendCommand("DELETE", key); err != nil {<br/>  return err<br/> }<br/><br/> _, err := c.readSimpleString()<br/> return err<br/>}</span></pre><p id="30cb" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我希望API的契约总是返回2个值。第一个值作为结果，第二个值作为错误。<code class="fe nh ni nj nk b">Get()</code>已经以这种方式定义了它的契约(尽管它的最后一行有一个小错误，我已经手动修复了)。所以在这里我不得不再次说明:</p><blockquote class="nn no np"><p id="ab06" class="kw kx nd ky b kz la jr lb lc ld ju le nq lg lh li nr lk ll lm ns lo lp lq lr ij bi translated"><strong class="ky ir">在Set()和Delete()中，readSimpleString()都返回2个值。第一个是成功返回值，第二个是错误字符串。如果错误字符串不为空，则返回错误字符串，否则返回成功返回值。</strong></p><p id="5683" class="kw kx nd ky b kz la jr lb lc ld ju le nq lg lh li nr lk ll lm ns lo lp lq lr ij bi">…</p></blockquote><pre class="kg kh ki kj gt nt nk nu bn nv nw bi"><span id="88a4" class="nx lt iq nk b be ny nz l oa ob">func (c *RedisClient) Set(key, value string) (string, error) {<br/> if err := c.sendCommand("SET", key, value); err != nil {<br/>  return "", err<br/> }<br/><br/> res, err := c.readSimpleString()<br/> if err != nil {<br/>  return "", err<br/> }<br/><br/> return res, nil<br/>}<br/><br/>func (c *RedisClient) Delete(key string) (string, error) {<br/> if err := c.sendCommand("DELETE", key); err != nil {<br/>  return "", err<br/> }<br/><br/> res, err := c.readSimpleString()<br/> if err != nil {<br/>  return "", err<br/> }<br/><br/> return res, nil<br/>}</span></pre><p id="dc17" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">太好了！现在，在一台Redis服务器上运行这个程序。我们有一个支持<code class="fe nh ni nj nk b">Get()</code>、<code class="fe nh ni nj nk b">Set()</code>和<code class="fe nh ni nj nk b">Delete()</code>的Redis客户端。<a class="ae kv" href="https://github.com/smukil/chatgptredisclient/blob/main/autoredisclient/basic_client.go" rel="noopener ugc nofollow" target="_blank">如果您想尝试一下，可以在这里</a>找到到目前为止的代码。</p><h1 id="3185" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">添加复制</h1><p id="2be8" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">这种平稳的体验让我觉得，我越是像对一个人那样对它说话，它的思维似乎就越有“结构”。</p><p id="c689" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这非常令人难以置信，这就是<a class="ae kv" href="http://ai.stanford.edu/blog/understanding-incontext/" rel="noopener ugc nofollow" target="_blank">上下文学习</a>的力量，当大型语言模型在足够大的数据集上训练时，它显示了这些“涌现属性”。它令人毛骨悚然，因为我们仍然不知道它是如何展示这些特性的。到目前为止，我们只是观察到确实如此。如果我说的“结构”对你来说还没有意义，我将在后面指出几个例子来解释我的意思。</p><p id="6486" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">因此，我加大了赞美的力度，谈到了“高可用性”之类的东西，这个术语我还从未向it部门提过，希望它能强化这种“结构”。随着时间的推移，我想用更抽象的术语和它说话，少一些指令性的东西，因为如果那样的话，它会为我节省更多的时间。</p><blockquote class="nn no np"><p id="8dd5" class="kw kx nd ky b kz la jr lb lc ld ju le nq lg lh li nr lk ll lm ns lo lp lq lr ij bi translated"><strong class="ky ir">干得好！这对我有用。现在假设有多个Redis服务器，我们希望这个客户端库的用户实现高可用性。我希望NewRedisClient()获取服务器列表并连接到所有服务器。注意，一个RedisClient对象应该支持所有的服务器。稍后我会告诉你如何使用其他功能。</strong></p><p id="c5dc" class="kw kx nd ky b kz la jr lb lc ld ju le nq lg lh li nr lk ll lm ns lo lp lq lr ij bi translated">当然可以。下面是NewRedisClient()的一个更新实现，它接受一个服务器列表并连接到所有服务器:</p></blockquote><pre class="kg kh ki kj gt nt nk nu bn nv nw bi"><span id="ae93" class="nx lt iq nk b be ny nz l oa ob">func NewRedisClient(servers []string) (*RedisClient, error) {<br/> var conns []net.Conn<br/> for _, server := range servers {<br/>  conn, err := net.Dial("tcp", server)<br/>  if err != nil {<br/>   return nil, err<br/>  }<br/>  conns = append(conns, conn)<br/> }<br/><br/> c := &amp;RedisClient{conns: conns}<br/> for _, conn := range conns {<br/>  c.readers = append(c.readers, bufio.NewReader(conn))<br/>  c.writers = append(c.writers, bufio.NewWriter(conn))<br/> }<br/><br/> return c, nil<br/>}</span></pre><blockquote class="nn no np"><p id="0673" class="kw kx nd ky b kz la jr lb lc ld ju le nq lg lh li nr lk ll lm ns lo lp lq lr ij bi translated">更新后的NewRedisClient()函数将服务器列表作为参数。对于列表中的每台服务器，它都使用网络创建一个到该服务器的新连接。Dial()函数。然后，它创建一个新的RedisClient对象，并将连接列表设置为conns字段。对于每个连接，它都会创建一个新的bufio。阅读器和一个新的bufio。Writer，并将它们分别添加到RedisClient对象的readers和writers字段中。最后，它返回RedisClient对象。</p></blockquote><p id="e9b9" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">很酷，但是它没有重写<code class="fe nh ni nj nk b">RedisClient</code>结构。我没有明确地告诉它，但我暗示它。但是，请注意，它有一些更新的<code class="fe nh ni nj nk b">RedisClient</code>的概念，因为它在上述函数中的使用方式与以前不同。所以也许它知道<code class="fe nh ni nj nk b">RedisClient</code>更新后的实现应该是什么样子，只是没有告诉我？我们来问一下。</p><blockquote class="nn no np"><p id="a772" class="kw kx nd ky b kz la jr lb lc ld ju le nq lg lh li nr lk ll lm ns lo lp lq lr ij bi translated"><strong class="ky ir">你能展示一下RedisClient的最新实现吗？</strong></p><p id="86a9" class="kw kx nd ky b kz la jr lb lc ld ju le nq lg lh li nr lk ll lm ns lo lp lq lr ij bi translated">当然可以。下面是支持多服务器的RedisClient结构的更新实现:<br/>更新后的RedisClient结构有以下字段:</p></blockquote><pre class="kg kh ki kj gt nt nk nu bn nv nw bi"><span id="bcaa" class="nx lt iq nk b be ny nz l oa ob">type RedisClient struct {<br/> conns   []net.Conn<br/> readers []*bufio.Reader<br/> writers []*bufio.Writer<br/>}</span></pre><blockquote class="nn no np"><p id="ce7e" class="kw kx nd ky b kz la jr lb lc ld ju le nq lg lh li nr lk ll lm ns lo lp lq lr ij bi translated">conns:Redis服务器的一部分连接。<br/>读者:一片蟾蜍。与conns中的每个连接相关联的读取器对象。<br/>编剧:一片卜菲欧。与conns中的每个连接相关联的Writer对象。</p><p id="cad2" class="kw kx nd ky b kz la jr lb lc ld ju le nq lg lh li nr lk ll lm ns lo lp lq lr ij bi translated">有了这个新的结构，RedisClient对象可以支持到多个Redis服务器的多个连接。</p></blockquote><p id="6791" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">请注意我刚才在那个问题中是如何要求更新实现的。虽然我之前已经告诉过它关于多个Redis服务器的事情，但是在那个问题中我没有说任何关于它的事情。我说的加“结构”就是这个意思。接下来，我们将更新<code class="fe nh ni nj nk b">Get()</code>、<code class="fe nh ni nj nk b">Set()</code>和<code class="fe nh ni nj nk b">Delete()</code>API。</p><blockquote class="nn no np"><p id="744f" class="kw kx nd ky b kz la jr lb lc ld ju le nq lg lh li nr lk ll lm ns lo lp lq lr ij bi translated"><strong class="ky ir">干得好。现在，我希望您更新Set()的实现，以写入所有服务器。记录所有的响应和错误。在函数结束时，如果至少有一个成功的响应，就返回它。否则，返回任何一个错误。</strong></p></blockquote><pre class="kg kh ki kj gt nt nk nu bn nv nw bi"><span id="8945" class="nx lt iq nk b be ny nz l oa ob">func (c *RedisClient) Set(key, value string) (string, error) {<br/> var res string<br/> var err error<br/> for i, conn := range c.conns {<br/>  writer := c.writers[i]<br/>  reader := c.readers[i]<br/>  if err := sendCommand(conn, writer, "SET", key, value); err != nil {<br/>   return "", err<br/>  }<br/><br/>  r, e := readSimpleString(conn, reader)<br/>  if e != nil {<br/>   err = e<br/>  } else {<br/>   res = r<br/>  }<br/> }<br/><br/> if res != "" {<br/>  return res, nil<br/> }<br/> return "", err<br/>}</span></pre><p id="f4b0" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这里是ChatGPT优化我的各种查询的地方。我提到了<em class="nd">“跟踪所有的响应和错误”</em>，但我也提到了<em class="nd">“在函数的最后，如果至少有一个成功的响应，则返回它。否则，返回任何一个错误。</em></p><p id="f704" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">请注意，它只记录了至少一个响应和至少一个错误，而不是将它们都存储在某个列表中，然后只返回一个。这太令人震惊了。</p><blockquote class="nn no np"><p id="54a6" class="kw kx nd ky b kz la jr lb lc ld ju le nq lg lh li nr lk ll lm ns lo lp lq lr ij bi translated"><strong class="ky ir">干得好。现在相应地更新sendCommand()和readSimpleString()。</strong></p><p id="7ca2" class="kw kx nd ky b kz la jr lb lc ld ju le nq lg lh li nr lk ll lm ns lo lp lq lr ij bi translated">当然可以。以下是sendCommand()和readSimpleString()的更新实现，它们将connection、writer和reader对象作为参数:</p></blockquote><pre class="kg kh ki kj gt nt nk nu bn nv nw bi"><span id="bbaf" class="nx lt iq nk b be ny nz l oa ob">func sendCommand(conn net.Conn, writer *bufio.Writer, command string, args ...string) error {<br/> writer.WriteByte('*')<br/> writer.WriteString(strconv.Itoa(len(args) + 1))<br/> writer.WriteByte('\r')<br/> writer.WriteByte('\n')<br/><br/> writer.WriteByte('$')<br/> writer.WriteString(strconv.Itoa(len(command)))<br/> writer.WriteByte('\r')<br/> writer.WriteByte('\n')<br/><br/> writer.WriteString(command)<br/> writer.WriteByte('\r')<br/> writer.WriteByte('\n')<br/><br/> for _, arg := range args {<br/>  writer.WriteByte('$')<br/>  writer.WriteString(strconv.Itoa(len(arg)))<br/>  writer.WriteByte('\r')<br/>  writer.WriteByte('\n')<br/>  writer.WriteString(arg)<br/>  writer.WriteByte('\r')<br/>  writer.WriteByte('\n')<br/> }<br/><br/> return writer.Flush()<br/>}<br/><br/>func readSimpleString(conn net.Conn, reader *bufio.Reader) (string, error) {<br/> prefix, err := reader.ReadByte()<br/> if err != nil {<br/>  return "", err<br/> }<br/><br/> if prefix == '-' {<br/>  line, err := reader.ReadString('\n')<br/>  if err != nil {<br/>   return "", err<br/>  }<br/><br/>  return "", errors.New(line[:len(line)-2])<br/> }<br/><br/> if prefix != '+' {<br/>  return "", errors.New("unexpected prefix")<br/> }<br/><br/> line, err := reader.ReadString('\n')<br/> if err != nil {<br/>  return "", err<br/> }<br/><br/> return line[:len(line)-2], nil<br/>}</span></pre><p id="db83" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">它将两个函数的契约从<code class="fe nh ni nj nk b">RedisClient</code>的结构级函数更改为顶级函数。我没有质疑这一点，而是想看看它将做出的后续代码选择。</p><blockquote class="nn no np"><p id="1486" class="kw kx nd ky b kz la jr lb lc ld ju le nq lg lh li nr lk ll lm ns lo lp lq lr ij bi translated"><strong class="ky ir">干得好！现在，我希望您也相应地更新Delete()。它应该尝试从所有服务器中删除。</strong></p></blockquote><p id="89bd" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><code omitted="">它用和Set()完全一样的逻辑写了delete，这就是我想要的。</code></p><blockquote class="nn no np"><p id="4555" class="kw kx nd ky b kz la jr lb lc ld ju le nq lg lh li nr lk ll lm ns lo lp lq lr ij bi translated"><strong class="ky ir">牛逼！让我们更新Get()的实现，一次从任意一个服务器获取值。如果一个服务器返回一个成功的值，立即将它返回给调用者，否则，尝试一个接一个地从剩余的服务器获取值，直到其中任何一个服务器返回一个成功的值。如果它们都返回一个错误，那么就把这个错误返回给调用者。</strong></p></blockquote><pre class="kg kh ki kj gt nt nk nu bn nv nw bi"><span id="81b4" class="nx lt iq nk b be ny nz l oa ob">func (c *RedisClient) Get(key string) (string, error) {<br/> for i, conn := range c.conns {<br/>  writer := c.writers[i]<br/>  reader := c.readers[i]<br/>  if err := sendCommand(conn, writer, "GET", key); err != nil {<br/>   return "", err<br/>  }<br/><br/>  res, err := readBulkString(conn, reader)<br/>  if err != nil {<br/>   continue<br/>  }<br/><br/>  return res, nil<br/> }<br/><br/> return "", errors.New("failed to get value from all servers")<br/>}</span></pre><p id="4ea4" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">它做出了一些创造性的选择，但第一次尝试就做对了。</p><p id="6414" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我也更新了<code class="fe nh ni nj nk b">readBulkString()</code>和<code class="fe nh ni nj nk b">Close()</code>。<code class="fe nh ni nj nk b">Close()</code>需要关闭所有的连接，它做到了:</p><pre class="kg kh ki kj gt nt nk nu bn nv nw bi"><span id="81af" class="nx lt iq nk b be ny nz l oa ob">func (c *RedisClient) Close() error {<br/> var err error<br/> for _, conn := range c.conns {<br/>  if e := conn.Close(); e != nil {<br/>   err = e<br/>  }<br/> }<br/> return err<br/>}</span></pre><p id="a83d" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这时候事情进展顺利多了。我需要修改的地方更少了。带复制的代码可在这里<a class="ae kv" href="https://github.com/smukil/chatgptredisclient/blob/main/autoredisclient/with_replication.go" rel="noopener ugc nofollow" target="_blank">获得。</a></p><h1 id="0e33" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">添加分片</h1><p id="9b11" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">我现在开始说得更抽象了，在提到复制的好处时，我不断引入新的术语，如“容错”,它理解了我的意思。</p><blockquote class="nn no np"><p id="dc59" class="kw kx nd ky b kz la jr lb lc ld ju le nq lg lh li nr lk ll lm ns lo lp lq lr ij bi translated"><strong class="ky ir">好极了！我们在这里所做的基本上是通过引入多个副本来增加容错能力。然而，我们仍然受到每个副本一台服务器的限制。我们希望我们的redis客户机也支持每个副本有多个分片，这样我们的系统更具可伸缩性。</strong></p><p id="4c81" class="kw kx nd ky b kz la jr lb lc ld ju le nq lg lh li nr lk ll lm ns lo lp lq lr ij bi translated"><strong class="ky ir">要做到这一点，首先让我们更新RedisClient结构，以了解副本。每个副本应该支持多个连接，每个连接到该副本中的每个服务器。</strong></p></blockquote><pre class="kg kh ki kj gt nt nk nu bn nv nw bi"><span id="fb21" class="nx lt iq nk b be ny nz l oa ob">type RedisClient struct {<br/> conns   [][]net.Conn<br/> readers [][]*bufio.Reader<br/> writers [][]*bufio.Writer<br/>}</span></pre><blockquote class="nn no np"><p id="4f9f" class="kw kx nd ky b kz la jr lb lc ld ju le nq lg lh li nr lk ll lm ns lo lp lq lr ij bi translated">更新后的RedisClient结构具有以下字段:<br/> conns:到Redis服务器的连接的切片，由副本组织。conns字段是一个切片，其中每个内部切片代表一个副本，并包含到该副本中的服务器的连接。</p><p id="b9c5" class="kw kx nd ky b kz la jr lb lc ld ju le nq lg lh li nr lk ll lm ns lo lp lq lr ij bi translated">读者:一片布菲欧。与conns中的每个连接相关联的读取器对象，由副本组织。readers字段是一个切片，其中每个内部切片代表一个副本并包含bufio。该副本中连接的读取器对象。</p><p id="585e" class="kw kx nd ky b kz la jr lb lc ld ju le nq lg lh li nr lk ll lm ns lo lp lq lr ij bi translated">编剧:一片布菲欧。与conns中的每个连接相关联的Writer对象，由副本组织。writers字段是一个片的片，其中每个内部片代表一个副本并包含bufio。该副本中连接的编写器对象。</p><p id="2833" class="kw kx nd ky b kz la jr lb lc ld ju le nq lg lh li nr lk ll lm ns lo lp lq lr ij bi translated">有了这个新的结构，RedisClient对象可以支持多个副本，每个副本包含到多个Redis服务器的多个连接。</p><p id="9845" class="kw kx nd ky b kz la jr lb lc ld ju le nq lg lh li nr lk ll lm ns lo lp lq lr ij bi translated"><strong class="ky ir">太棒了，现在让我们更新NewRedisClient()来获取多个副本并初始化到所有副本的连接。</strong></p></blockquote><pre class="kg kh ki kj gt nt nk nu bn nv nw bi"><span id="cc96" class="nx lt iq nk b be ny nz l oa ob">func NewRedisClient(replicas [][]string) (*RedisClient, error) {<br/> var conns [][]net.Conn<br/> var readers [][]*bufio.Reader<br/> var writers [][]*bufio.Writer<br/> for _, replica := range replicas {<br/>  var replicaConns []net.Conn<br/>  var replicaReaders []*bufio.Reader<br/>  var replicaWriters []*bufio.Writer<br/>  for _, server := range replica {<br/>   conn, err := net.Dial("tcp", server)<br/>   if err != nil {<br/>    return nil, err<br/>   }<br/><br/>   replicaConns = append(replicaConns, conn)<br/>   replicaReaders = append(replicaReaders, bufio.NewReader(conn))<br/>   replicaWriters = append(replicaWriters, bufio.NewWriter(conn))<br/>  }<br/>  conns = append(conns, replicaConns)<br/>  readers = append(readers, replicaReaders)<br/>  writers = append(writers, replicaWriters)<br/> }<br/><br/> return &amp;RedisClient{conns, readers, writers}, nil<br/>}</span></pre><blockquote class="nn no np"><p id="c80c" class="kw kx nd ky b kz la jr lb lc ld ju le nq lg lh li nr lk ll lm ns lo lp lq lr ij bi translated"><strong class="ky ir">干得好。现在，让我们介绍一个名为FindShard()的助手函数，它接受两个参数:<br/> 1。作为字符串的密钥<br/> 2。副本中的服务器数量</strong></p><p id="d795" class="kw kx nd ky b kz la jr lb lc ld ju le nq lg lh li nr lk ll lm ns lo lp lq lr ij bi translated"><strong class="ky ir">通过XXHash运行key通过跳转Hash传递结果和服务器数量，并将输出返回给调用者。</strong></p></blockquote><pre class="kg kh ki kj gt nt nk nu bn nv nw bi"><span id="c8b2" class="nx lt iq nk b be ny nz l oa ob">func FindShard(key string, numServers int) int {<br/> h := xxhash.New()<br/> if _, err := h.Write([]byte(key)); err != nil {<br/>  return 0<br/> }<br/> hash := h.Sum64()<br/> return int(jump.Hash(hash, numServers))<br/>}</span></pre><p id="7245" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">到目前为止一切看起来都很好。</p><blockquote class="nn no np"><p id="92e1" class="kw kx nd ky b kz la jr lb lc ld ju le nq lg lh li nr lk ll lm ns lo lp lq lr ij bi translated"><strong class="ky ir">好，现在让我们更新Set()的实现，首先找到密钥所属的分片，然后从每个副本中只向那个分片发送命令。</strong></p></blockquote><pre class="kg kh ki kj gt nt nk nu bn nv nw bi"><span id="797b" class="nx lt iq nk b be ny nz l oa ob">func (c *RedisClient) Set(key, value string) error {<br/> shard := FindShard(key, int32(len(c.conns[0])))<br/> var err error<br/> for i, replicaConns := range c.conns {<br/>  conn := replicaConns[shard]<br/>  writer := c.writers[i][shard]<br/>  if err = sendCommand(conn, writer, "SET", key, value); err != nil {<br/>   break<br/>  }<br/>  _, err = readSimpleString(conn, c.readers[i][shard])<br/> }<br/> return err<br/>}</span></pre><p id="e929" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">很好，它选对了钥匙碎片。我省略了一些小的调试和Delete()。下面是Get()和Close():</p><blockquote class="nn no np"><p id="f896" class="kw kx nd ky b kz la jr lb lc ld ju le nq lg lh li nr lk ll lm ns lo lp lq lr ij bi translated"><strong class="ky ir">干得好！现在，让我们更新Get()来一次一个副本地发送命令到各自的shard。一旦我们得到一个成功的结果，返回。否则，继续尝试剩余的副本，直到我们找到一个。如果它们都返回一个错误，则返回最后看到的错误。</strong></p></blockquote><pre class="kg kh ki kj gt nt nk nu bn nv nw bi"><span id="15ad" class="nx lt iq nk b be ny nz l oa ob">func (c *RedisClient) Get(key string) (string, error) {<br/> shard := FindShard(key, int32(len(c.conns[0])))<br/> var result string<br/> var err error<br/> for i, replicaConns := range c.conns {<br/>  conn := replicaConns[shard]<br/>  writer := c.writers[i][shard]<br/>  if err = sendCommand(conn, writer, "GET", key); err != nil {<br/>   continue<br/>  }<br/>  result, err = readBulkString(conn, c.readers[i][shard])<br/>  if err == nil {<br/>   break<br/>  }<br/> }<br/> return result, err<br/>}</span></pre><blockquote class="nn no np"><p id="3069" class="kw kx nd ky b kz la jr lb lc ld ju le nq lg lh li nr lk ll lm ns lo lp lq lr ij bi translated"><strong class="ky ir">更新Close()关闭每个连接。如果中途遇到错误，忽略它，继续关闭所有其他的东西。如果它们都出错了，返回最后一个。</strong></p></blockquote><pre class="kg kh ki kj gt nt nk nu bn nv nw bi"><span id="94e4" class="nx lt iq nk b be ny nz l oa ob">func (c *RedisClient) Close() error {<br/> var err error<br/> for _, replicaConns := range c.conns {<br/>  for _, conn := range replicaConns {<br/>   if err1 := conn.Close(); err1 != nil {<br/>    err = err1<br/>   }<br/>  }<br/> }<br/> return err<br/>}</span></pre><p id="afb5" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">现在，我们有了一个完整的工作分布式和容错客户端POC。这里是<a class="ae kv" href="https://github.com/smukil/chatgptredisclient" rel="noopener ugc nofollow" target="_blank"> Github链接</a>到整个代码和抄本。</p><h1 id="6b3a" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">ChatGPT能讲多国语言吗？</h1><p id="2eb6" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">科技产品公司面临的一个常见挑战是对基础设施组件的多语言支持。通常，这意味着客户端具有相同的逻辑，但使用多种不同的语言。这当然很难维护，因此像使用通用GRPC协议的<a class="ae kv" href="https://www.envoyproxy.io/" rel="noopener ugc nofollow" target="_blank">特使</a>这样的服务网格是首选。</p><p id="80b5" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">尽管如此，我还是很好奇，想看看我们到目前为止建立的所有“结构”是否能让ChatGPT将我们所有的工作翻译成不同的语言。</p><blockquote class="nn no np"><p id="7917" class="kw kx nd ky b kz la jr lb lc ld ju le nq lg lh li nr lk ll lm ns lo lp lq lr ij bi translated"><strong class="ky ir">现在我们有了一个用Go编写的分布式容错Redis客户端。我希望您用Python实现具有相同逻辑的整个客户端。</strong></p></blockquote><pre class="kg kh ki kj gt nt nk nu bn nv nw bi"><span id="982e" class="nx lt iq nk b be ny nz l oa ob"> import xxhash<br/> import jumphash<br/> import socket<br/> import struct<br/> <br/> <br/> class RedisClient:<br/>     def __init__(self, replicas):<br/>         self.conns = [[] for _ in replicas]<br/>         self.writers = [[] for _ in replicas]<br/>         self.readers = [[] for _ in replicas]<br/>         for i, servers in enumerate(replicas):<br/>             for server in servers:<br/>                 ip, port = server.split(":")<br/>                 conn = socket.socket()<br/>                 conn.connect((ip, int(port)))<br/>                 self.conns[i].append(conn)<br/>                 self.writers[i].append(conn.makefile("w"))<br/>                 self.readers[i].append(conn.makefile("r"))<br/> <br/>     @staticmethod<br/>     def find_shard(key, num_servers):<br/>         h = xxhash.xxh64()<br/>         h.update(key.encode("utf-8"))<br/>         return jumphash.jump_consistent(h.intdigest(), num_servers)<br/> <br/>     def set(self, key, value):<br/>         shard = self.find_shard(key, len(self.conns[0]))<br/>         result, err = None, None<br/>         for i, replica_conns in enumerate(self.conns):<br/>             conn = replica_conns[shard]<br/>             writer = self.writers[i][shard]<br/>             self.send_command(writer, "SET", key, value)<br/>             result, err = self.read_simple_string(conn)<br/>         return result, err<br/> <br/>     def delete(self, key):<br/>         shard = self.find_shard(key, len(self.conns[0]))<br/>         result, err = None, None<br/>         for i, replica_conns in enumerate(self.conns):<br/>             conn = replica_conns[shard]<br/>             writer = self.writers[i][shard]<br/>             self.send_command(writer, "DELETE", key)<br/>             result, err = self.read_simple_string(conn)<br/>         return result, err</span></pre><p id="69da" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">一点也不差。它是不完整的，但是不幸的是，在这里我点击了键盘上浏览器的“返回”快捷键，我失去了与ChatGPT的所有上下文:(</p><p id="7a2e" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">但是我们不需要看到代码的其余部分来得出结论。ChatGPT可以在一个提示中无缝地用不同的语言重写它。我也上传了这个不完整的文件到GitHub。我希望OpenAI很快支持在ChatGPT中保存聊天上下文，以便以后恢复。</p><h1 id="b86c" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">结论</h1><p id="35e2" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">根据我的经验，我相信这可以用来加速部分软件开发；简单组件的原型，在更小的模块中构建项目的各个部分，等等。我花了两个多小时才把它修好；我花了更长的时间写这篇文章。</p><p id="a006" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">给它更多的背景，就像我给一个真实的人一样，似乎会有所帮助。</p><p id="dca7" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">然而，考虑到代码质量问题和ChatGPT做出“创造性”选择的事实，意味着您对代码执行情况等事情的控制更少。代码维护也可能更加困难。</p><p id="b097" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">随着时间的推移，随着LLM的改进，并且是在更大的数据集上训练的结果，这些“涌现属性”可能会更加有效。然后，我们能想象这些LLM审查他们自己的代码，并可能写出越来越好的软件，甚至向我们解释它是如何工作的。</p><p id="543e" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">学习更好地提示这些类型的LLM也可能是一项非常有用的技能，这可能很快成为一项新的工作职能。我将在以后的文章中详细介绍我学到的技术，以便更好地推广ChatGPT。</p><ul class=""><li id="49d0" class="mp mq iq ky b kz la lc ld lf mr lj ms ln mt lr oc mv mw mx bi translated">GitHub回购:<a class="ae kv" href="https://github.com/smukil/chatgptredisclient" rel="noopener ugc nofollow" target="_blank">https://github.com/smukil/chatgptredisclient</a></li><li id="f12d" class="mp mq iq ky b kz my lc mz lf na lj nb ln nc lr oc mv mw mx bi translated">推特:【https://twitter.com/SaileshMukil T2】</li></ul></div></div>    
</body>
</html>