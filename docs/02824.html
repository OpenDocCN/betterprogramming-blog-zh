<html>
<head>
<title>An Overview of Server-Side HTTP APIs in Go</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Go中服务器端HTTP APIs概述</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/overview-of-server-side-http-apis-in-go-44f052737e4b?source=collection_archive---------7-----------------------#2020-01-03">https://betterprogramming.pub/overview-of-server-side-http-apis-in-go-44f052737e4b?source=collection_archive---------7-----------------------#2020-01-03</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="fe4a" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">探索net/http包</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/34e5a1fb88ed490118d6bd7e98ec0056.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*qiPMCI-j3akNvA8kcRNw-Q.jpeg"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated"><a class="ae kv" href="https://unsplash.com/@bmowinkel?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">布兰登·莫温克尔</a>在<a class="ae kv" href="https://unsplash.com/s/photos/trains?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的照片</p></figure><p id="e993" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">欢迎来到另一个版本的<a class="ae kv" href="https://medium.com/@abhishek1987/just-enough-go-blog-series-c1cd62b04beb" rel="noopener"><strong class="ky ir"/></a>——关于<a class="ae kv" href="https://golang.org/" rel="noopener ugc nofollow" target="_blank"> Go编程语言</a>的系列文章，涵盖了一些最常用的<a class="ae kv" href="https://golang.org/pkg" rel="noopener ugc nofollow" target="_blank"> Go标准库包</a> : <code class="fe ls lt lu lv b">encoding/json</code>、<code class="fe ls lt lu lv b">io</code>、<code class="fe ls lt lu lv b">net/http</code>、<code class="fe ls lt lu lv b">sync</code>等。</p><p id="aa9f" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在本文中，我们将探索为HTTP服务提供服务器端和客户端API的<code class="fe ls lt lu lv b"><a class="ae kv" href="https://golang.org/pkg/net/http/" rel="noopener ugc nofollow" target="_blank">net/http</a></code>包。这一部分将提供重要服务器组件的概述(客户端API将在另一篇文章中介绍)</p><p id="2236" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">所有的代码示例都可以在GitHub 上找到。</p><p id="b600" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">让我们从基本的构建模块开始:<code class="fe ls lt lu lv b">ServeMux</code>和<code class="fe ls lt lu lv b">Server</code></p></div><div class="ab cl lw lx hu ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="ij ik il im in"><h1 id="2138" class="md me iq bd mf mg mh mi mj mk ml mm mn jw mo jx mp jz mq ka mr kc ms kd mt mu bi translated">多路复用器</h1><p id="2369" class="pw-post-body-paragraph kw kx iq ky b kz mv jr lb lc mw ju le lf mx lh li lj my ll lm ln mz lp lq lr ij bi translated">简单来说，<code class="fe ls lt lu lv b">ServeMux</code>是一个HTTP请求复用器。它负责将请求中的URL匹配到适当的处理程序并执行它。你可以通过调用<code class="fe ls lt lu lv b">http.NewServeMux</code>来创建一个。接下来要做的是使用<code class="fe ls lt lu lv b">Handle</code>和<code class="fe ls lt lu lv b">HandleFunc</code>方法将URL和它们各自的处理程序实现附加到一个<code class="fe ls lt lu lv b">ServeMux</code>实例。</p><p id="da53" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们来看看如何使用<code class="fe ls lt lu lv b"><a class="ae kv" href="https://golang.org/pkg/net/http/#ServeMux.Handle" rel="noopener ugc nofollow" target="_blank">Handle</a></code> <a class="ae kv" href="https://golang.org/pkg/net/http/#ServeMux.Handle" rel="noopener ugc nofollow" target="_blank">方法</a>。它接受一个<code class="fe ls lt lu lv b">String</code>和一个<code class="fe ls lt lu lv b">http.Handler</code>:</p><pre class="kg kh ki kj gt na lv nb nc aw nd bi"><span id="ecb6" class="ne me iq lv b gy nf ng l nh ni">func (mux *ServeMux) Handle(pattern string, handler Handler)</span></pre><p id="b808" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><code class="fe ls lt lu lv b"><a class="ae kv" href="https://golang.org/pkg/net/http/#Handler" rel="noopener ugc nofollow" target="_blank">http.Handler</a></code> <a class="ae kv" href="https://golang.org/pkg/net/http/#Handler" rel="noopener ugc nofollow" target="_blank">是与<code class="fe ls lt lu lv b">ServeHTTP</code>方法的接口</a>(<code class="fe ls lt lu lv b">Handle</code>方法中的第二个参数):</p><pre class="kg kh ki kj gt na lv nb nc aw nd bi"><span id="9ed1" class="ne me iq lv b gy nf ng l nh ni">type Handler interface {<br/>    ServeHTTP(ResponseWriter, *Request)<br/>}</span></pre><p id="0801" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们可以简单地使用一个<code class="fe ls lt lu lv b">struct</code>来提供实现。例如:</p><pre class="kg kh ki kj gt na lv nb nc aw nd bi"><span id="206a" class="ne me iq lv b gy nf ng l nh ni">func (h home) ServeHTTP(rw http.ResponseWriter, r *http.Request) {<br/>	rw.Write([]byte("Welcome to the Just Enough Go! blog series!"))<br/>}</span></pre><p id="927c" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">然后将其连接到多路复用器，如下所示:</p><pre class="kg kh ki kj gt na lv nb nc aw nd bi"><span id="294e" class="ne me iq lv b gy nf ng l nh ni">mux := http.NewServeMux()<br/>mux.Handle("/", home{})</span></pre><p id="e653" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">让我们为我们的<code class="fe ls lt lu lv b">ServeMux</code> ( <code class="fe ls lt lu lv b">mux</code>)添加另一个处理程序。这一次，我们将使用签名如下的<code class="fe ls lt lu lv b"><a class="ae kv" href="https://golang.org/pkg/net/http/#ServeMux.HandleFunc" rel="noopener ugc nofollow" target="_blank">HandleFunc</a></code>变体:</p><pre class="kg kh ki kj gt na lv nb nc aw nd bi"><span id="3d52" class="ne me iq lv b gy nf ng l nh ni">func (mux *ServeMux) HandleFunc(pattern string, handler func(ResponseWriter, *Request))</span></pre><p id="6519" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">与<code class="fe ls lt lu lv b">Handle</code>方法不同，<code class="fe ls lt lu lv b">HandleFunc</code>接受函数形式的处理程序实现(以及调用它的路径)。你可以这样使用它:</p><pre class="kg kh ki kj gt na lv nb nc aw nd bi"><span id="e922" class="ne me iq lv b gy nf ng l nh ni">mux.HandleFunc("/posts", func(rw http.ResponseWriter, req *http.Request) {<br/>	rw.Write([]byte("Visit http://bit.ly/just-enough-go to get started"))<br/>})</span></pre></div><div class="ab cl lw lx hu ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="ij ik il im in"><h1 id="ffce" class="md me iq bd mf mg mh mi mj mk ml mm mn jw mo jx mp jz mq ka mr kc ms kd mt mu bi translated">服务器(HTTP服务器)</h1><p id="5da2" class="pw-post-body-paragraph kw kx iq ky b kz mv jr lb lc mw ju le lf mx lh li lj my ll lm ln mz lp lq lr ij bi translated">现在我们有了一个多路复用器，如果用户导航到我们服务的根目录，它可以做出响应；即<code class="fe ls lt lu lv b">/</code>以及<code class="fe ls lt lu lv b">/posts</code>。让我们用一个<code class="fe ls lt lu lv b">Server</code>把它们绑在一起。创建一个<code class="fe ls lt lu lv b">Server</code>的新实例很容易:</p><pre class="kg kh ki kj gt na lv nb nc aw nd bi"><span id="4f5f" class="ne me iq lv b gy nf ng l nh ni">server := http.Server{Addr: ":8080", Handler: mux}</span></pre><p id="60ae" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们可以为HTTP服务器定义许多参数，但是让我们来看看几个重要的参数，即<code class="fe ls lt lu lv b">Addr</code>和<code class="fe ls lt lu lv b">Handler</code>(上面突出显示)——<code class="fe ls lt lu lv b">Addr</code>是服务器监听的地址，例如<code class="fe ls lt lu lv b">http://localhost:8080</code>和<code class="fe ls lt lu lv b">Handler</code>实际上是一个<code class="fe ls lt lu lv b">http.Handler</code>实例。</p><p id="7c43" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><code class="fe ls lt lu lv b">Handler</code>位很有趣，因为我们刚刚看到了<code class="fe ls lt lu lv b">ServeMux</code>中的<code class="fe ls lt lu lv b">Handle</code>方法也接受一个<code class="fe ls lt lu lv b">http.Handler</code>。那么，我们是否在这里传递了与在<code class="fe ls lt lu lv b">ServeMux</code>中传递<code class="fe ls lt lu lv b">Handle</code>方法相同的实例呢？如果是的话，再做一次又有什么意义呢？</p><p id="ee73" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">如果您只有想要处理的路线或路径，您可以传递一个<code class="fe ls lt lu lv b">http.Handler</code>的实例(例如本例中的<code class="fe ls lt lu lv b">home{}</code>),并完全跳过<code class="fe ls lt lu lv b">ServeMux</code>。否则，在大多数情况下，您可以/应该传递一个<code class="fe ls lt lu lv b">ServeMux</code>的实例，这样您就可以处理多个路由/路径(例如<code class="fe ls lt lu lv b">/home</code>、<code class="fe ls lt lu lv b">/items</code>等)。)这是可能的，因为它实现了<code class="fe ls lt lu lv b">http.Handler</code>。在内部，它通过基于<code class="fe ls lt lu lv b">http.Request</code>中的路径(URL)分派或路由到适当的处理程序来工作。</p><p id="8faf" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">它根据<code class="fe ls lt lu lv b">http.Handler</code>接口的要求定义了一个<code class="fe ls lt lu lv b">ServeHTTP</code>方法:</p><pre class="kg kh ki kj gt na lv nb nc aw nd bi"><span id="998b" class="ne me iq lv b gy nf ng l nh ni">func (mux *ServeMux) ServeHTTP(w ResponseWriter, r *Request)<!-- --> </span></pre><p id="a957" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><em class="nj">注意:</em> <code class="fe ls lt lu lv b"><em class="nj">Handler</em></code> <em class="nj">可以是</em><code class="fe ls lt lu lv b"><em class="nj">nil</em></code><em class="nj">——这个场景将在本文后面讨论。</em></p><p id="6818" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">太好了！到目前为止，我们有一个带有两个处理程序的<code class="fe ls lt lu lv b">ServeMux</code>，我们将<code class="fe ls lt lu lv b">Server</code>与多路复用器相关联，并定义了它将监听的位置。最后，你只需要使用<code class="fe ls lt lu lv b"><a class="ae kv" href="https://golang.org/pkg/net/http/#Server.ListenAndServe" rel="noopener ugc nofollow" target="_blank">ListenAndServe</a></code>方法<code class="fe ls lt lu lv b">start</code>它:</p><pre class="kg kh ki kj gt na lv nb nc aw nd bi"><span id="574c" class="ne me iq lv b gy nf ng l nh ni">server.ListenAndServe()</span></pre><p id="9add" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">就是这样。下面是合并后的代码(相当小！):</p><pre class="kg kh ki kj gt na lv nb nc aw nd bi"><span id="7667" class="ne me iq lv b gy nf ng l nh ni">package main</span><span id="c054" class="ne me iq lv b gy nk ng l nh ni">import (<br/>	"log"<br/>	"net/http"<br/>)</span><span id="3811" class="ne me iq lv b gy nk ng l nh ni">func main() {<br/>	mux := http.NewServeMux()</span><span id="d723" class="ne me iq lv b gy nk ng l nh ni">	mux.Handle("/", home{})</span><span id="f24d" class="ne me iq lv b gy nk ng l nh ni">	mux.HandleFunc("/posts", func(rw http.ResponseWriter, req *http.Request) {<br/>		rw.Write([]byte("Visit http://bit.ly/just-enough-go to get started"))</span><span id="1ebb" class="ne me iq lv b gy nk ng l nh ni">	})</span><span id="bc3b" class="ne me iq lv b gy nk ng l nh ni">	server := http.Server{Addr: ":8080", Handler: mux}<br/>	log.Fatal(server.ListenAndServe())<br/>}</span><span id="df97" class="ne me iq lv b gy nk ng l nh ni">type home struct{}</span><span id="bc09" class="ne me iq lv b gy nk ng l nh ni">func (h home) ServeHTTP(rw http.ResponseWriter, r *http.Request) {<br/>	rw.Write([]byte("Welcome to the \"Just Enough Go\" blog series!!"))<br/>}</span></pre><p id="dd54" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">要尝试这种方法:</p><ul class=""><li id="ea98" class="nl nm iq ky b kz la lc ld lf nn lj no ln np lr nq nr ns nt bi translated">只需将代码保存在文件中(如<code class="fe ls lt lu lv b">go-http-1.go</code>)</li><li id="4efd" class="nl nm iq ky b kz nu lc nv lf nw lj nx ln ny lr nq nr ns nt bi translated">运行它— <code class="fe ls lt lu lv b">go run go-http-1.go</code></li><li id="9249" class="nl nm iq ky b kz nu lc nv lf nw lj nx ln ny lr nq nr ns nt bi translated">访问端点— <code class="fe ls lt lu lv b">curl http://localhost:8080/</code>和<code class="fe ls lt lu lv b">curl <a class="ae kv" href="http://localhost:8080/posts" rel="noopener ugc nofollow" target="_blank">http://localhost:8080/posts</a></code></li></ul><h2 id="8842" class="ne me iq bd mf nz oa dn mj ob oc dp mn lf od oe mp lj of og mr ln oh oi mt oj bi translated">默认多路复用器</h2><p id="e6fb" class="pw-post-body-paragraph kw kx iq ky b kz mv jr lb lc mw ju le lf mx lh li lj my ll lm ln mz lp lq lr ij bi translated">为了使事情更简单，有一个现成的多路复用器<code class="fe ls lt lu lv b">DefaultServeMux</code>。你不需要使用显式的<code class="fe ls lt lu lv b">ServeMux</code>。为此，<code class="fe ls lt lu lv b">ServeMux</code>中可用的<code class="fe ls lt lu lv b">Handle</code>和<code class="fe ls lt lu lv b">HandleFunc</code>方法也在<code class="fe ls lt lu lv b">net/http</code>包中作为全局函数公开——您可以以同样的方式使用它们！</p><pre class="kg kh ki kj gt na lv nb nc aw nd bi"><span id="9e15" class="ne me iq lv b gy nf ng l nh ni">http.Handle("/users",myHandler{})</span><span id="826c" class="ne me iq lv b gy nk ng l nh ni">http.HandleFunc("/items",func(rw http.ResponseWriter, req *http.Request){<br/>    //handler logic<br/>})</span></pre><p id="f30a" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">要启动HTTP服务器，可以使用<code class="fe ls lt lu lv b">http.ListenAndServe</code>函数，就像使用<code class="fe ls lt lu lv b">Server</code>实例一样。</p><pre class="kg kh ki kj gt na lv nb nc aw nd bi"><span id="eb03" class="ne me iq lv b gy nf ng l nh ni">func ListenAndServe(addr string, handler Handler) error</span></pre><p id="3099" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">如果您已经使用了<code class="fe ls lt lu lv b">http.Handle</code>和/或<code class="fe ls lt lu lv b">http.HandleFunc</code>来指定各个路由的处理程序实现，那么<code class="fe ls lt lu lv b">handler</code>参数可以是<code class="fe ls lt lu lv b">nil</code>。</p></div><div class="ab cl lw lx hu ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="ij ik il im in"><h1 id="9dc4" class="md me iq bd mf mg mh mi mj mk ml mm mn jw mo jx mp jz mq ka mr kc ms kd mt mu bi translated">充当处理程序</h1><p id="ad08" class="pw-post-body-paragraph kw kx iq ky b kz mv jr lb lc mw ju le lf mx lh li lj my ll lm ln mz lp lq lr ij bi translated">到目前为止，我们已经看到了如何使用struct来实现<code class="fe ls lt lu lv b">http.Handler</code>接口并在<code class="fe ls lt lu lv b">HandleFunc</code>中使用它。您可能还希望使用独立函数而不声明结构。<code class="fe ls lt lu lv b">net/http</code>包为此定义了一个函数类型:<code class="fe ls lt lu lv b"><a class="ae kv" href="https://golang.org/pkg/net/http/#HandlerFunc" rel="noopener ugc nofollow" target="_blank">http.HandlerFunc</a></code></p><pre class="kg kh ki kj gt na lv nb nc aw nd bi"><span id="d191" class="ne me iq lv b gy nf ng l nh ni">type HandlerFunc func(ResponseWriter, *Request)</span></pre><p id="d689" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><code class="fe ls lt lu lv b">HandlerFunc</code>允许您使用普通函数作为HTTP处理程序。例如:</p><pre class="kg kh ki kj gt na lv nb nc aw nd bi"><span id="92ee" class="ne me iq lv b gy nf ng l nh ni">func welcome(rw http.ResponseWriter, req *http.Request) {<br/>	rw.Write([]byte("Welcome to Just Enough Go"))<br/>}</span></pre><p id="c217" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><code class="fe ls lt lu lv b">welcome</code>是具有所需签名的独立函数。您可以在接受如下<code class="fe ls lt lu lv b">http.Handler</code>的<code class="fe ls lt lu lv b">Handle</code>方法中使用它:</p><pre class="kg kh ki kj gt na lv nb nc aw nd bi"><span id="a052" class="ne me iq lv b gy nf ng l nh ni">http.ListenAndServe(":8080", http.HandlerFunc(welcome))</span></pre><p id="8e3c" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><em class="nj">注意:</em> <code class="fe ls lt lu lv b"><em class="nj">HandlerFunc(f)</em></code> <em class="nj">是调用</em> <code class="fe ls lt lu lv b"><em class="nj">f</em></code>函数的处理程序</p><p id="b3c5" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">代码如下所示:</p><pre class="kg kh ki kj gt na lv nb nc aw nd bi"><span id="7cc2" class="ne me iq lv b gy nf ng l nh ni">package main</span><span id="6742" class="ne me iq lv b gy nk ng l nh ni">import "net/http"</span><span id="9aa1" class="ne me iq lv b gy nk ng l nh ni">func main() {<br/>	http.Handle("/welcome", http.HandlerFunc(welcome))<br/>	http.ListenAndServe(":8080", nil)<br/>}</span><span id="81dd" class="ne me iq lv b gy nk ng l nh ni">func welcome(rw http.ResponseWriter, req *http.Request) {<br/>	rw.Write([]byte("Welcome to Just Enough Go"))<br/>}</span></pre><p id="3d34" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">要尝试这种方法:</p><ul class=""><li id="4f96" class="nl nm iq ky b kz la lc ld lf nn lj no ln np lr nq nr ns nt bi translated">只需将代码保存在一个文件中(如<code class="fe ls lt lu lv b">go-http-2.go</code>)并</li><li id="f764" class="nl nm iq ky b kz nu lc nv lf nw lj nx ln ny lr nq nr ns nt bi translated">运行它— <code class="fe ls lt lu lv b">go run go-http-2.go</code></li><li id="4548" class="nl nm iq ky b kz nu lc nv lf nw lj nx ln ny lr nq nr ns nt bi translated">访问端点— <code class="fe ls lt lu lv b">curl <a class="ae kv" href="http://localhost:8080/welcome" rel="noopener ugc nofollow" target="_blank">http://localhost:8080/welcome</a></code></li></ul></div><div class="ab cl lw lx hu ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="ij ik il im in"><p id="4fa7" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这就是这篇博客的全部内容，我们在这里介绍了由<code class="fe ls lt lu lv b">net/http</code>包提供的服务器端HTTP APIs的基本构造。</p><p id="76cb" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我真的希望你喜欢并从中学到了一些东西。如果你做了，请喜欢并跟随！</p></div></div>    
</body>
</html>