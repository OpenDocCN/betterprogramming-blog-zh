<html>
<head>
<title>This Is How You Write Better Functions in JavaScript</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">这就是如何在JavaScript中编写更好的函数</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/this-is-how-you-write-better-functions-in-javascript-3afc84612c69?source=collection_archive---------7-----------------------#2021-05-31">https://betterprogramming.pub/this-is-how-you-write-better-functions-in-javascript-3afc84612c69?source=collection_archive---------7-----------------------#2021-05-31</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="3540" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">在JavaScript中使用纯函数的力量</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/0c7a5a8986b206377a507d4ca887c7f1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*N82FBiVAkxamcMjB"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">照片由<a class="ae kv" href="https://unsplash.com/@ricaros?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">丹尼尔·伊德里</a>在<a class="ae kv" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>拍摄。</p></figure><p id="815a" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">开发人员总是努力写出更好的代码。但是通过抽象，定义“好”代码变得非常困难。有些人会把好的代码定义为可读性强、不需要太多精力就能理解的代码。其他人会认为好的代码尽可能具有高性能。真正的价值是在两者之间找到平衡。</p><p id="38b4" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在本文中，我们将讨论纯函数，它们是什么，以及从长远来看，它们如何通过提高代码的可读性和可维护性来改进代码库。</p><p id="2451" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">为了展示可能性，我们需要先了解一些定义。<a class="ae kv" href="https://en.wikipedia.org/wiki/Pure_function" rel="noopener ugc nofollow" target="_blank">在维基百科</a>上，一个纯函数有两种定义。</p><blockquote class="ls"><p id="f6b9" class="lt lu iq bd lv lw lx ly lz ma mb lr dk translated">"对于相同的参数，函数返回值是相同的."</p></blockquote><p id="015a" class="pw-post-body-paragraph kw kx iq ky b kz mc jr lb lc md ju le lf me lh li lj mf ll lm ln mg lp lq lr ij bi translated">第一个定义很简单。我们应该努力让函数在每次传递给我们的函数的相同参数集合中返回相同的结果。根据这个定义，您将有希望认识到像<code class="fe mh mi mj mk b">Math.random()</code> <em class="ml"> </em>这样的函数不被认为是纯函数，因为它不会在您每次调用该函数时都返回相同的结果。另一个类似于<code class="fe mh mi mj mk b">Math.abs()</code>的函数可以被认为是纯函数，因为它总是为某个输入返回相同的输出。</p><p id="598d" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在编程中，我们把对相同参数总是返回相同结果的函数称为<em class="ml">幂等函数。</em>这意味着一个纯函数总是一个幂等函数。</p><blockquote class="ls"><p id="7278" class="lt lu iq bd lv lw lx ly lz ma mb lr dk translated">“函数应用没有副作用。”</p></blockquote><p id="4bbf" class="pw-post-body-paragraph kw kx iq ky b kz mc jr lb lc md ju le lf me lh li lj mf ll lm ln mg lp lq lr ij bi translated">这个定义不太清楚。副作用到底是什么？考虑这个例子:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mm mn l"/></div></figure><p id="456d" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在本例中，该函数计算<code class="fe mh mi mj mk b">x</code>和<code class="fe mh mi mj mk b">y</code>的总和，将其加到总和上，并返回总和。当一个函数除了返回值之外还有输出时，它被认为是副作用<em class="ml">。你看到这里有什么副作用了吗？</em></p><p id="5448" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们添加到代码中“某处”定义的总数中。这极大地损害了我们的代码。首先，整体代码质量降低了，因为我们代码的易错性显著增加了。如果其他代码开始写入总数，会发生什么情况？那么,<code class="fe mh mi mj mk b">total</code>变量并没有被用于它最初的设计目的。这可能会以有害的方式改变我们程序的行为。其次，伤害了可读性。想象一下，在一个更复杂的代码库中看到这种情况，并且不得不跳过几十个函数来试图理解作者的意图。我们现在有工具可以更快地浏览这些参考资料，但这并不意味着我们不必花费大量的精力去理解到底发生了什么。</p><p id="1c67" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们把<code class="fe mh mi mj mk b">total</code> <em class="ml">这样的变量叫做自由变量</em>。这些<em class="ml"> </em>变量定义在函数之外，可能会导致函数结果的不确定性。</p></div><div class="ab cl mo mp hu mq" role="separator"><span class="mr bw bk ms mt mu"/><span class="mr bw bk ms mt mu"/><span class="mr bw bk ms mt"/></div><div class="ij ik il im in"><p id="f7f8" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">所以从我们的定义中，我们理解一个纯函数是一个总是返回相同结果的函数，并且不使用或改变其自身范围之外的任何值。</p><p id="b57a" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这总是可能的吗？考虑下面的例子:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mm mn l"/></div></figure><p id="873a" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">当然不是！程序有异步的非固定输入。例如，如果一个函数执行一个<code class="fe mh mi mj mk b">ajax</code>调用，我们永远不知道这个函数是否会以同样的方式运行。服务器可能已关闭。他们的SSL证书可能有问题。这很好。纯函数的全部意义在于最大化你对一段代码的控制和信心。使用尽可能多的纯函数会让我们增加这种信心。</p><p id="338d" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">然而，在上面的例子中，还有另一个我们<em class="ml">可以控制的问题。你发现了吗？<code class="fe mh mi mj mk b">ajax</code>调用总是返回相同的结果。你能发现还有什么可能出错吗？</em></p><p id="7817" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这一小段代码还有另一个副作用！我们正在给大教堂写信。当我们打电话时:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mm mn l"/></div></figure><p id="dd93" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在这个例子中，完全有可能页面<code class="fe mh mi mj mk b">1</code>花费更多的时间来启动并导致一个竞争条件。注意到副作用对函数的可信度有多危险了吗？这就是为什么我们要努力写纯函数的原因。它给了我们更多的控制。</p><p id="7007" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">让我们看另一个例子:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mm mn l"/></div></figure><p id="c09f" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我知道我们可以使它变得更简单，但是我试图用几行文字来证明我的观点，所以请坚持我的观点。我们要做的是通过还原数组并拼接前两项来获得后两项。你能发现这里的副作用吗？它的<em class="ml"> </em> <code class="fe mh mi mj mk b">.reverse()</code> <em class="ml"> </em>叫上阵。一个<code class="fe mh mi mj mk b">reverse()</code>调用将我们的数组颠倒过来。这意味着如果我们在调用我们的函数后打印<code class="fe mh mi mj mk b">arr</code>，它将被反转！为了解决这个问题，我们可以像这样在函数本身中复制我们的数组:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mm mn l"/></div></figure><p id="b2e8" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们在第2行复制了我们的数组，现在如果我们在函数执行后打印我们的<code class="fe mh mi mj mk b">arr</code>变量，我们会看到它将是<code class="fe mh mi mj mk b">[2,3,6,3]</code>。我们的功能现在没有副作用了！</p></div><div class="ab cl mo mp hu mq" role="separator"><span class="mr bw bk ms mt mu"/><span class="mr bw bk ms mt mu"/><span class="mr bw bk ms mt"/></div><div class="ij ik il im in"><h1 id="3954" class="mv mw iq bd mx my mz na nb nc nd ne nf jw ng jx nh jz ni ka nj kc nk kd nl nm bi translated">结论</h1><p id="e908" class="pw-post-body-paragraph kw kx iq ky b kz nn jr lb lc no ju le lf np lh li lj nq ll lm ln nr lp lq lr ij bi translated">我希望你意识到使用纯函数并确保它们是有效的纯函数将会增强你的代码库的可读性和可预测性/信心。</p><p id="0d5a" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在本文中，我解释了纯函数背后的思想，并展示了一些例子，说明在哪里可以找到一些隐藏的副作用以及如何处理它们。虽然关于纯函数还有很多要说的，但我想尽可能保持这篇文章的简洁，这样你会有所启发。</p><p id="acc9" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">祝你好运！</p></div></div>    
</body>
</html>