<html>
<head>
<title>The What, Why, and How of TypeScript for JavaScript Developers</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">面向JavaScript开发人员的TypeScript是什么、为什么和如何</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/the-what-why-and-how-of-typescript-for-javascript-developers-a2177675f6d2?source=collection_archive---------8-----------------------#2020-11-30">https://betterprogramming.pub/the-what-why-and-how-of-typescript-for-javascript-developers-a2177675f6d2?source=collection_archive---------8-----------------------#2020-11-30</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="82c6" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">JavaScript的类型化介绍</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/6772a01c87b5257ce4d7e77ac8c3f63e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Yq-T7fg4uxOkqYeGCPUqtQ.jpeg"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">作者图片</p></figure><p id="1604" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">如果您是一名JavaScript开发人员，您一定在某个地方听说过TypeScript。如果您不愿意尝试Typescript，因为您不确定它如何能比JavaScript更好地为您服务，那么您来对地方了。</p><p id="c3ca" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">本指南为任何JavaScript开发人员提供了入门的全面的TypeScript指南。</p><p id="489b" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">什么是TypeScript，它的类型系统是什么，作为一名JavaScript开发人员，在您的下一个项目中使用TypeScript对您有什么好处？在这篇文章的结尾，你会找到所有这些问题的答案。</p><p id="72f3" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">注意:我可能有点偏向TypeScript。在我开始的项目中，没有一个是我更喜欢JS而不是TypeScript的。</p></div><div class="ab cl lu lv hx lw" role="separator"><span class="lx bw bk ly lz ma"/><span class="lx bw bk ly lz ma"/><span class="lx bw bk ly lz"/></div><div class="im in io ip iq"><h1 id="3790" class="mb mc it bd md me mf mg mh mi mj mk ml jz mm ka mn kc mo kd mp kf mq kg mr ms bi translated">什么是TypeScript？</h1><p id="cd7c" class="pw-post-body-paragraph ky kz it la b lb mt ju ld le mu jx lg lh mv lj lk ll mw ln lo lp mx lr ls lt im bi translated">您可以将TypeScript视为一种在JavaScript之上提供额外一层的语言。</p><h2 id="c49b" class="my mc it bd md mz na dn mh nb nc dp ml lh nd ne mn ll nf ng mp lp nh ni mr nj bi translated">为什么？</h2><p id="9411" class="pw-post-body-paragraph ky kz it la b lb mt ju ld le mu jx lg lh mv lj lk ll mw ln lo lp mx lr ls lt im bi translated">尽管我们最初用TypeScript编写代码，但我们不能像运行JavaScript那样在浏览器上直接运行TypeScript。相反，TypeScript通过一个额外的编译步骤将其代码转换为浏览器可识别的JavaScript。</p><p id="8ee4" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">所以即使我们用TypeScript编程，在浏览器上运行的最终程序也是用JavaScript编写的。</p><h2 id="f217" class="my mc it bd md mz na dn mh nb nc dp ml lh nd ne mn ll nf ng mp lp nh ni mr nj bi translated">那我们为什么还要使用TypeScript呢？</h2><p id="482a" class="pw-post-body-paragraph ky kz it la b lb mt ju ld le mu jx lg lh mv lj lk ll mw ln lo lp mx lr ls lt im bi translated">尽管TypeScript在运行时并没有提供比JavaScript更多的功能，但它提供了一组特性来确保我们这些开发人员与只使用JavaScript相比，能够编写出更少出错、更易维护的代码。</p><h2 id="49c6" class="my mc it bd md mz na dn mh nb nc dp ml lh nd ne mn ll nf ng mp lp nh ni mr nj bi translated">TypeScript是如何做到的？</h2><p id="6b97" class="pw-post-body-paragraph ky kz it la b lb mt ju ld le mu jx lg lh mv lj lk ll mw ln lo lp mx lr ls lt im bi translated">TypeScript，顾名思义，在普通JavaScript之上引入了一个类型系统。在JavaScript中，变量的类型是动态分配的，而TypeScript迫使我们预先定义我们要声明的变量的类型。</p><p id="63fa" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">使用JavaScript，我们可以在第一行给一个变量赋一个整数值，在下一行给它赋一个字符串值。</p><pre class="kj kk kl km gt nk nl nm nn aw no bi"><span id="23f5" class="my mc it nl b gy np nq l nr ns">let jsVar = 0;<br/>jsVar = "js";</span></pre><p id="184c" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">但是使用TypeScript，我们可以通过显式声明变量的类型来限制这种行为。如果我们试图将一个字符串赋给一个类型为<code class="fe nt nu nv nl b">number</code>的变量，它会产生一个错误。</p><pre class="kj kk kl km gt nk nl nm nn aw no bi"><span id="fdac" class="my mc it nl b gy np nq l nr ns">let tsVar: number = 0;<br/>tsVar = "ts"; //error</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nw"><img src="../Images/209f579dd65a70cec12b26b08ba7216c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*6I5iG3z4uVpmdo9bDMQRMg.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">错误类型分配的VS代码警告</p></figure><p id="51ee" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">简言之，这就是TypeScript与JavaScript的不同之处:使用类型来防止我们在代码中犯愚蠢的错误。</p></div><div class="ab cl lu lv hx lw" role="separator"><span class="lx bw bk ly lz ma"/><span class="lx bw bk ly lz ma"/><span class="lx bw bk ly lz"/></div><div class="im in io ip iq"><h1 id="ae67" class="mb mc it bd md me mf mg mh mi mj mk ml jz mm ka mn kc mo kd mp kf mq kg mr ms bi translated">TypeScript如何改进JavaScript</h1><p id="f12a" class="pw-post-body-paragraph ky kz it la b lb mt ju ld le mu jx lg lh mv lj lk ll mw ln lo lp mx lr ls lt im bi translated">虽然缺乏定义类型的能力不一定是JavaScript的缺陷，但它给了程序员太多的自由，这不可避免地导致他们编写糟糕的代码。</p><pre class="kj kk kl km gt nk nl nm nn aw no bi"><span id="181d" class="my mc it nl b gy np nq l nr ns">let aNumber = 123;</span><span id="afcf" class="my mc it nl b gy nx nq l nr ns">aNumber = {<br/>    name: "John",<br/>    age: 23<br/>}</span></pre><p id="f1a7" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">在上面的JavaScript场景中，没有什么可以阻止开发人员使用<code class="fe nt nu nv nl b">aNumber</code>变量来表示对象。虽然这不是一个会导致程序崩溃的错误，但它违背了使用变量名自我记录代码的目的。</p><p id="86c2" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">TypeScript通过在声明期间定义变量的类型很容易地解决了这个问题，这样它就不能被赋给另一种类型的值。</p><pre class="kj kk kl km gt nk nl nm nn aw no bi"><span id="4cf5" class="my mc it nl b gy np nq l nr ns">let aNumber: number = 123;</span></pre><p id="bd3b" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">如果另一个开发人员可以访问你程序中的这个变量，他们现在可以依赖它的值是一个数字，正如它的名字所暗示的。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ny nz l"/></div></figure><p id="a2eb" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">在这种情况下，<code class="fe nt nu nv nl b">isEligible</code>函数需要一个具有名为<code class="fe nt nu nv nl b">age</code>的字段的对象。但是JavaScript无法保证传递给函数的参数实际上是一个对象，或者它有一个名为<code class="fe nt nu nv nl b">age</code>的字段。</p><p id="d7e5" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">同样，TypeScript有这个问题的解决方案。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ny nz l"/></div></figure><p id="6ff0" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">现在，这段代码可能对你来说没有意义。但是请注意它是如何确保传递的变量的类型是在开头定义的类型<code class="fe nt nu nv nl b">Person</code>。</p><p id="560e" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">使用TypeScript可以从你的程序中去掉数百个粗心的编码错误，并避免你每次遇到最愚蠢的错误时都要抓狂。这也将使您的代码更好地自我记录，并增加其可维护性。</p><p id="2687" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">如果您对IDE中为JavaScript提供的代码建议不足感到沮丧，那么您还有另一个理由来尝试一下TypeScript。类型的存在使TypeScript能够在IDE中显示更好的代码建议。</p></div><div class="ab cl lu lv hx lw" role="separator"><span class="lx bw bk ly lz ma"/><span class="lx bw bk ly lz ma"/><span class="lx bw bk ly lz"/></div><div class="im in io ip iq"><h1 id="5071" class="mb mc it bd md me mf mg mh mi mj mk ml jz mm ka mn kc mo kd mp kf mq kg mr ms bi translated">将类型与TypeScript一起使用</h1><h2 id="9b2c" class="my mc it bd md mz na dn mh nb nc dp ml lh nd ne mn ll nf ng mp lp nh ni mr nj bi translated">基本类型</h2><p id="243d" class="pw-post-body-paragraph ky kz it la b lb mt ju ld le mu jx lg lh mv lj lk ll mw ln lo lp mx lr ls lt im bi translated">TypeScript有许多预定义的基本类型。数字、字符串、布尔和数组就是其中的几个例子。</p><p id="b88f" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">您可以在<a class="ae oa" href="https://www.typescriptlang.org/docs/handbook/basic-types.html" rel="noopener ugc nofollow" target="_blank"> TypeScript文档</a>中找到基本类型的完整列表。</p><p id="272d" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">这里有几个例子:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ny nz l"/></div></figure><p id="1269" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">请注意<code class="fe nt nu nv nl b">any</code> type如何将TypeScript转换为与JavaScript相同的行为方式。因为我们使用TypeScript的目的是给我们的代码一个更好的结构，所以尽可能避免使用<code class="fe nt nu nv nl b">any</code>类型。</p><p id="989e" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">同样，尽量避免使用类型的联合，但如果不可避免，则尽可能限制联合中允许的类型数量。</p><h2 id="d22f" class="my mc it bd md mz na dn mh nb nc dp ml lh nd ne mn ll nf ng mp lp nh ni mr nj bi translated">声明自定义类型</h2><p id="0f29" class="pw-post-body-paragraph ky kz it la b lb mt ju ld le mu jx lg lh mv lj lk ll mw ln lo lp mx lr ls lt im bi translated">还记得我在前面的代码示例中如何使用一个名为<code class="fe nt nu nv nl b">Person</code>的类型吗？但是<code class="fe nt nu nv nl b">Person</code>不是TypeScript中的基本数据类型。我根据自己的需求创建了Person类型，以将其用作给定函数接受的参数类型。</p><p id="44e8" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">我们使用接口来定义我们引入到应用程序中的新类型的基本结构。</p><pre class="kj kk kl km gt nk nl nm nn aw no bi"><span id="f843" class="my mc it nl b gy np nq l nr ns">interface Person {<br/>    name: string;<br/>    age: number;<br/>}</span></pre><p id="d292" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">现在，如果我们创建一个类型为<code class="fe nt nu nv nl b">Person</code>的新对象，它应该包含字段的名称和年龄。否则，TypeScript将引发错误。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ob"><img src="../Images/5aa982f1553adff2f90c3ff609e5f049.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*FYKmtb4d0MPXJLONdFDm9A.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">VS自定义类型中缺失属性的代码警告</p></figure><p id="241a" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">您还可以在接口中定义可选字段。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ny nz l"/></div></figure><p id="5bf2" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">然后，在定义另一种类型时，可以使用自定义类型作为字段的类型。</p><pre class="kj kk kl km gt nk nl nm nn aw no bi"><span id="ef3f" class="my mc it nl b gy np nq l nr ns">interface Person{<br/>    name: string;<br/>    age: number;<br/>    address: Address;<br/>}</span></pre><h2 id="d026" class="my mc it bd md mz na dn mh nb nc dp ml lh nd ne mn ll nf ng mp lp nh ni mr nj bi translated">扩展接口</h2><p id="9f23" class="pw-post-body-paragraph ky kz it la b lb mt ju ld le mu jx lg lh mv lj lk ll mw ln lo lp mx lr ls lt im bi translated">在TypeScript中，您可以通过扩展另一个类型的接口来继承它的属性。</p><p id="f411" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">假设您的应用程序需要两种不同的类型，<code class="fe nt nu nv nl b">Person</code>和<code class="fe nt nu nv nl b">Employee</code>。因为雇员也是人，所以在创建<code class="fe nt nu nv nl b">Employee</code>接口时继承<code class="fe nt nu nv nl b">Person</code>类型的属性是有意义的。它防止代码重复。</p><p id="8b8f" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">您可以通过扩展<code class="fe nt nu nv nl b">Person</code>接口来快速实现这一点。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ny nz l"/></div></figure><h2 id="1a3d" class="my mc it bd md mz na dn mh nb nc dp ml lh nd ne mn ll nf ng mp lp nh ni mr nj bi translated">函数参数类型和返回类型</h2><p id="1317" class="pw-post-body-paragraph ky kz it la b lb mt ju ld le mu jx lg lh mv lj lk ll mw ln lo lp mx lr ls lt im bi translated">与变量类型类似，您可以为函数参数和返回值定义类型。虽然参数类型是在参数名旁边声明的，但返回类型是在花括号之前声明的。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ny nz l"/></div></figure><p id="a7a0" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">通过定义参数和返回值的类型，我们可以保证您或任何使用该函数的人不会意外地传递不具有<code class="fe nt nu nv nl b">Car</code>类型特征的对象。</p><p id="edee" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">您还可以保证传递的任何对象中的字段<code class="fe nt nu nv nl b">sold</code>不会未定义或为空。并且它消除了许多可能在运行时抛出错误的场景。如果您使用JavaScript，您将不得不编写更多的代码来防止在运行时出现这种错误的可能性。</p><p id="3e87" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">与变量类似，您可以将返回和参数类型定义为几种类型的联合。</p><pre class="kj kk kl km gt nk nl nm nn aw no bi"><span id="f472" class="my mc it nl b gy np nq l nr ns">function buyCar(car : Car): Car | boolean {<br/>    if (car.sold === true){<br/>        return false;<br/>    }<br/>    return car;<br/>}</span></pre><p id="3708" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">当您声明接受的参数或返回类型时，扩展初始类型的接口的类型的对象也被接受为参数或返回值。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ny nz l"/></div></figure></div><div class="ab cl lu lv hx lw" role="separator"><span class="lx bw bk ly lz ma"/><span class="lx bw bk ly lz ma"/><span class="lx bw bk ly lz"/></div><div class="im in io ip iq"><h1 id="3b9e" class="mb mc it bd md me mf mg mh mi mj mk ml jz mm ka mn kc mo kd mp kf mq kg mr ms bi translated">使用泛型</h1><p id="45b7" class="pw-post-body-paragraph ky kz it la b lb mt ju ld le mu jx lg lh mv lj lk ll mw ln lo lp mx lr ls lt im bi translated">使用TypeScript，您可以像我们到目前为止所介绍的那样轻松地定义泛型变量。如果您正在定义一个泛型函数，您可以使用它来处理属于任何内置或自定义类型的数据。</p><pre class="kj kk kl km gt nk nl nm nn aw no bi"><span id="4ed8" class="my mc it nl b gy np nq l nr ns">function getInfo&lt;T&gt;(input: T): T {<br/>    return input;<br/>}</span><span id="04ed" class="my mc it nl b gy nx nq l nr ns">const stringInfo = getInfo&lt;string&gt;("Hello World");<br/>const numberInfo = getInfo&lt;number&gt;(3321);<br/>const carInfo = getInfo&lt;Car&gt;(car1);</span></pre><h2 id="15c9" class="my mc it bd md mz na dn mh nb nc dp ml lh nd ne mn ll nf ng mp lp nh ni mr nj bi translated">如果使用“any”类型而不是泛型会怎样？</h2><p id="abaa" class="pw-post-body-paragraph ky kz it la b lb mt ju ld le mu jx lg lh mv lj lk ll mw ln lo lp mx lr ls lt im bi translated">当然，您可以使用<code class="fe nt nu nv nl b">any</code>类型修改上述函数以接受任何类型的参数。</p><pre class="kj kk kl km gt nk nl nm nn aw no bi"><span id="3abc" class="my mc it nl b gy np nq l nr ns">function getInfo(input : any) {<br/>    return input;<br/>}</span><span id="c316" class="my mc it nl b gy nx nq l nr ns">const stringInfo: string = getInfo("Hello World");<br/>const numberInfo: number = getInfo(3321);<br/>const carInfo: Car = getInfo(car1);</span></pre><p id="3bc6" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">但是，这个方法不保留传递给函数的数据类型。相反，它记录作为属于任何类型传递的每个参数。另外，你要避免使用<code class="fe nt nu nv nl b">any</code>。</p><p id="26c5" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">不过，使用泛型，您可以保留传递给函数的数据类型。如果要根据传递的数据类型改变函数逻辑，使用泛型比接受任何类型的数据都好。</p></div><div class="ab cl lu lv hx lw" role="separator"><span class="lx bw bk ly lz ma"/><span class="lx bw bk ly lz ma"/><span class="lx bw bk ly lz"/></div><div class="im in io ip iq"><h1 id="f9f5" class="mb mc it bd md me mf mg mh mi mj mk ml jz mm ka mn kc mo kd mp kf mq kg mr ms bi translated">使用类型别名</h1><p id="6819" class="pw-post-body-paragraph ky kz it la b lb mt ju ld le mu jx lg lh mv lj lk ll mw ln lo lp mx lr ls lt im bi translated">当您要在应用程序中使用的特定字段可能属于几种类型之一时，您可以将其类型定义为这些独立类型的联合。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ny nz l"/></div></figure><p id="81e9" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">不需要像上面那样每次都重写联合，您可以使用type关键字为联合定义一个别名。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ny nz l"/></div></figure><p id="5e99" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">现在你不必使用长的类型联合。此外，如果您想在将来更改函数的返回类型，现在只需更改一行代码。</p></div><div class="ab cl lu lv hx lw" role="separator"><span class="lx bw bk ly lz ma"/><span class="lx bw bk ly lz ma"/><span class="lx bw bk ly lz"/></div><div class="im in io ip iq"><h1 id="8190" class="mb mc it bd md me mf mg mh mi mj mk ml jz mm ka mn kc mo kd mp kf mq kg mr ms bi translated">类型变换</h1><p id="ca80" class="pw-post-body-paragraph ky kz it la b lb mt ju ld le mu jx lg lh mv lj lk ll mw ln lo lp mx lr ls lt im bi translated">当一种类型通过扩展另一种类型的接口来定义时，两者之间生成的关系允许我们将其中一种类型中定义的对象转换为另一种类型。</p><p id="7297" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">以我之前定义的<code class="fe nt nu nv nl b">Car</code>和<code class="fe nt nu nv nl b">ImportedCar</code>类型为例。首先，我将创建一个类型为<code class="fe nt nu nv nl b">ImportedCar</code>的对象，看看转换是如何在其上进行的。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ny nz l"/></div></figure><p id="41f8" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">这段代码编译时没有错误。这种转换是有意义的，因为<code class="fe nt nu nv nl b">ImportedCar</code>类型已经拥有了在<code class="fe nt nu nv nl b">Car</code>类型中定义的所有字段。</p><p id="33f4" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">如果我们试图在转换前访问对象中定义的制造商字段，它会产生一个错误，因为转换后的对象是<code class="fe nt nu nv nl b">Car</code>类型。</p><pre class="kj kk kl km gt nk nl nm nn aw no bi"><span id="7726" class="my mc it nl b gy np nq l nr ns">convertedCar.manufacturer;  //error</span></pre><p id="baf6" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">这种转换也可以反过来进行。我们可以将一个<code class="fe nt nu nv nl b">Car</code>对象转换成一个<code class="fe nt nu nv nl b">ImportedCar</code>对象。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ny nz l"/></div></figure><p id="1c98" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">在这种情况下，如果您试图访问<code class="fe nt nu nv nl b">Car</code>对象以前没有的新字段<code class="fe nt nu nv nl b">manufacturer</code>，您将看到它返回<code class="fe nt nu nv nl b">undefined</code>。</p><pre class="kj kk kl km gt nk nl nm nn aw no bi"><span id="ed89" class="my mc it nl b gy np nq l nr ns">convertedImportedCar.manufacturer;   //undefined</span></pre></div><div class="ab cl lu lv hx lw" role="separator"><span class="lx bw bk ly lz ma"/><span class="lx bw bk ly lz ma"/><span class="lx bw bk ly lz"/></div><div class="im in io ip iq"><h1 id="da35" class="mb mc it bd md me mf mg mh mi mj mk ml jz mm ka mn kc mo kd mp kf mq kg mr ms bi translated">结论</h1><p id="57ec" class="pw-post-body-paragraph ky kz it la b lb mt ju ld le mu jx lg lh mv lj lk ll mw ln lo lp mx lr ls lt im bi translated">我希望这篇文章消除了您对使用TypeScript进行前端开发的任何疑虑。由于TypeScript中的大多数特性已经与JavaScript相似，您也将能够很快掌握TypeScript。这在你的下一个项目中肯定会有回报。</p><p id="7167" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">接下来，你会成为一名离不开TypeScript的JavaScript开发人员，就像我一样。</p><p id="b8b3" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">感谢阅读！</p></div></div>    
</body>
</html>