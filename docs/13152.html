<html>
<head>
<title>Use Deep Links to Speed Up Your UI Tests</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用深层链接来加速你的UI测试</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/use-deep-links-to-speed-up-your-ui-tests-5f84397581b2?source=collection_archive---------8-----------------------#2022-08-02">https://betterprogramming.pub/use-deep-links-to-speed-up-your-ui-tests-5f84397581b2?source=collection_archive---------8-----------------------#2022-08-02</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="b65d" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">避免深度链接测试中不必要的步骤</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/30041c91939fc0671bf768b6b976f944.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*eUQr93tV3M9a2Q7S"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">照片由<a class="ae ky" href="https://unsplash.com/@thekamranzadeh?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">卡姆兰·阿卜杜拉耶夫</a>在<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</p></figure><p id="9e08" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在上一篇文章中，我们谈到了<a class="ae ky" rel="noopener ugc nofollow" target="_blank" href="/scalable-navigation-with-deep-links-in-swiftui-96cea1764994">深度链接</a>:它们是什么，如何设置，如何在我们的app中处理。我们展示的只是一种可能的应用，但它们可以用于许多其他用例。</p><p id="bdb8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我最喜欢的深层链接用例之一是加速用户界面测试。如果您熟悉Xcode UI测试，您会知道它有一些缺点:</p><ul class=""><li id="31f0" class="lv lw it lb b lc ld lf lg li lx lm ly lq lz lu ma mb mc md bi translated">编写代码导航到正确的屏幕需要时间。</li><li id="ccd8" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated">很难正确地编写它(并且Xcode记录功能会生成奇怪的代码)。</li><li id="62d5" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated">它比正常的测试需要更多的时间来运行。</li></ul><p id="c34b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">深度链接主要针对前两点:通过使用深度链接，我们可以直接导航到我们想要测试的屏幕。然后，我们只需要为那个屏幕编写UITest，允许我们隔离测试。此外，我们还在端到端测试深层链接处理逻辑是否正常工作！</p><h1 id="784d" class="mj mk it bd ml mm mn mo mp mq mr ms mt jz mu ka mv kc mw kd mx kf my kg mz na bi translated">设置项目</h1><p id="43a0" class="pw-post-body-paragraph kz la it lb b lc nb ju le lf nc jx lh li nd lk ll lm ne lo lp lq nf ls lt lu im bi translated">在<strong class="lb iu">设置深层链接</strong>部分，项目的设置与这里的<a class="ae ky" rel="noopener ugc nofollow" target="_blank" href="/scalable-navigation-with-deep-links-in-swiftui-96cea1764994">所示的</a>非常相似。</p><ol class=""><li id="e2ac" class="lv lw it lb b lc ld lf lg li lx lm ly lq lz lu ng mb mc md bi translated">创建一个新的Xcode项目，并将其命名为<code class="fe nh ni nj nk b">DeepLinkUITests</code></li><li id="0bfc" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ng mb mc md bi translated">选择<code class="fe nh ni nj nk b">Swift</code>作为语言，<code class="fe nh ni nj nk b">SwiftUI</code>作为界面</li><li id="cb57" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ng mb mc md bi translated">确保选中<code class="fe nh ni nj nk b">Include Tests</code>复选框</li></ol><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nl"><img src="../Images/676e6163b9298be01e6800c185ad261a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*dXTndWAKTGS9S2M8iOKwGA.png"/></div></div></figure><p id="4951" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">Xcode创建完项目后，让我们通过以下方式设置深层链接:</p><ol class=""><li id="d14b" class="lv lw it lb b lc ld lf lg li lx lm ly lq lz lu ng mb mc md bi translated">在项目导航器中选择项目(<strong class="lb iu"> ⌘ + 1 </strong>)。</li><li id="9a3e" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ng mb mc md bi translated">选择<strong class="lb iu">信息</strong>标签。</li><li id="de3f" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ng mb mc md bi translated">向下滚动到<strong class="lb iu"> URL类型</strong>部分。</li><li id="f752" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ng mb mc md bi translated">点击底部的<strong class="lb iu"> + </strong>按钮。</li><li id="7cb6" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ng mb mc md bi translated">填写右上角的<strong class="lb iu"> URLSchemes </strong>字段。</li></ol><p id="4a7d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">对于这个例子，我使用的是<code class="fe nh ni nj nk b">deeplinkuitest</code>方案，因此如果我们安装了应用程序，并且我们试图从Safari导航到<code class="fe nh ni nj nk b">deeplinkuitest://</code>，我们将打开这个应用程序。</p><p id="e9ff" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">最后，让我们更新SwiftUI代码以接受深层链接并对其做出反应:下面是一个玩具示例，以查看设置是否有效。</p><h2 id="b533" class="nm mk it bd ml nn no dn mp np nq dp mt li nr ns mv lm nt nu mx lq nv nw mz nx bi translated">更新应用程序结构</h2><p id="67fc" class="pw-post-body-paragraph kz la it lb b lc nb ju le lf nc jx lh li nd lk ll lm ne lo lp lq nf ls lt lu im bi translated">打开<code class="fe nh ni nj nk b">DeepLinkUITestApp.swift</code>文件，让我们更新它，如下所示:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ny nz l"/></div></figure><p id="c7c2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在这里，我们添加了一些东西:</p><ol class=""><li id="ef4e" class="lv lw it lb b lc ld lf lg li lx lm ly lq lz lu ng mb mc md bi translated">一个<code class="fe nh ni nj nk b">@State</code>变量来选择要显示的文本。</li><li id="c3c2" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ng mb mc md bi translated"><code class="fe nh ni nj nk b">ContentView</code>中的一个<code class="fe nh ni nj nk b">text:</code>参数向其传递文本。</li><li id="69b3" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ng mb mc md bi translated">处理深层链接和更新文本的<code class="fe nh ni nj nk b">onOpenURL</code>修饰符。</li><li id="ab66" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ng mb mc md bi translated">在UITest中抓取视图的<code class="fe nh ni nj nk b">accessibilityModifier</code>。</li></ol><p id="7476" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">仅仅这样是不行的，因为我们还没有在<code class="fe nh ni nj nk b">ContentView</code>中绑定文本属性。</p><h2 id="bbbd" class="nm mk it bd ml nn no dn mp np nq dp mt li nr ns mv lm nt nu mx lq nv nw mz nx bi translated">更新内容视图</h2><p id="e028" class="pw-post-body-paragraph kz la it lb b lc nb ju le lf nc jx lh li nd lk ll lm ne lo lp lq nf ls lt lu im bi translated">打开<code class="fe nh ni nj nk b">ContentView.swift</code>文件，并按如下方式更新它:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ny nz l"/></div></figure><p id="dbb4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在这个文件中，我们是:</p><ol class=""><li id="68f1" class="lv lw it lb b lc ld lf lg li lx lm ly lq lz lu ng mb mc md bi translated">向<code class="fe nh ni nj nk b">ContentView</code>添加一个变量。</li><li id="ad25" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ng mb mc md bi translated">使用<code class="fe nh ni nj nk b">Text</code>组件中的变量。</li><li id="aac1" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ng mb mc md bi translated">更新<code class="fe nh ni nj nk b">ContentView_Previews</code>以构建项目。</li></ol><p id="59f6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们现在可以运行应用程序，这是我们在safari中测试深层链接时可以观察到的情况。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi oa"><img src="../Images/faa98a608cf00e366a9d37a21da47e13.png" data-original-src="https://miro.medium.com/v2/resize:fit:592/1*CKHyLcsOS7FNpWCKLjEpnQ.gif"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">手动打开深层链接的演示</p></figure><h1 id="f9d6" class="mj mk it bd ml mm mn mo mp mq mr ms mt jz mu ka mv kc mw kd mx kf my kg mz na bi translated">从UI测试中打开带有深度链接的应用程序</h1><p id="07b5" class="pw-post-body-paragraph kz la it lb b lc nb ju le lf nc jx lh li nd lk ll lm ne lo lp lq nf ls lt lu im bi translated">现在我们有了一个原型，我们可以编写第一个UI测试。我们的项目已经有了一个<code class="fe nh ni nj nk b">DeepLinkUITestUITests</code>文件夹，其中有几个为我们的测试创建框架的文件。</p><p id="83fb" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">要从深层链接打开应用程序，我们需要模拟我们在视频中手动执行的操作:</p><ol class=""><li id="7d21" class="lv lw it lb b lc ld lf lg li lx lm ly lq lz lu ng mb mc md bi translated">我们需要打开safari</li><li id="3876" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ng mb mc md bi translated">键入深层链接</li><li id="ac19" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ng mb mc md bi translated">导航回应用程序。</li></ol><p id="7ddb" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">来自<a class="ae ky" href="https://twitter.com/rockbruno_" rel="noopener ugc nofollow" target="_blank">的Bruno Rocha </a>有一篇关于该主题的很好的<a class="ae ky" href="https://swiftrocks.com/ui-testing-deeplinks-and-universal-links-in-ios" rel="noopener ugc nofollow" target="_blank">深度文章</a>。强烈建议看一下，了解一下是怎么回事。为了这篇文章，我提取了一个我们可以使用的小工具。</p><p id="e71b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在UI测试文件夹中，创建一个新的Swift文件，并将其命名为<code class="fe nh ni nj nk b">DeepLinkUtils</code>。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ny nz l"/></div></figure><p id="f522" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">该文件包含两个<code class="fe nh ni nj nk b">static</code>函数:<code class="fe nh ni nj nk b">openFromSafari</code>和<code class="fe nh ni nj nk b">tapIfExists</code>。</p><p id="0e34" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe nh ni nj nk b">openFromSafari</code>是我们用来从Safari启动应用程序的主要功能。该功能:</p><ol class=""><li id="8e19" class="lv lw it lb b lc ld lf lg li lx lm ly lq lz lu ng mb mc md bi translated">打开<code class="fe nh ni nj nk b">Safari</code>应用程序并等待其启动。</li><li id="2af9" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ng mb mc md bi translated">在Safari onboarding中导航，如果这是模拟器第一次启动它。这一步对于进行可靠的测试很重要。</li><li id="40ff" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ng mb mc md bi translated">抓取<code class="fe nh ni nj nk b">Address</code>文本字段，可以在其中输入URL。</li><li id="ba06" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ng mb mc md bi translated">处理键盘启动，如果有的话。</li><li id="bc8e" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ng mb mc md bi translated">输入深层链接。</li><li id="8dcc" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ng mb mc md bi translated">与对话框交互以打开深层链接。</li></ol><p id="5e31" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe nh ni nj nk b">tapIfExists</code>功能只是一个实用功能，给定一个应用程序和一个按钮名称，检查该按钮是否存在于当前屏幕中，并点击它。</p><h2 id="a18f" class="nm mk it bd ml nn no dn mp np nq dp mt li nr ns mv lm nt nu mx lq nv nw mz nx bi translated">第一次测试</h2><p id="885e" class="pw-post-body-paragraph kz la it lb b lc nb ju le lf nc jx lh li nd lk ll lm ne lo lp lq nf ls lt lu im bi translated">我们现在可以编写第一个测试来检查我们的设置是否正确。让我们打开<code class="fe nh ni nj nk b">DeepLinkUITestUITests.swift</code>文件，用下面的代码填充<code class="fe nh ni nj nk b">testExample</code>函数:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ny nz l"/></div></figure><p id="83bd" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">该测试的工作原理如下:</p><ol class=""><li id="c347" class="lv lw it lb b lc ld lf lg li lx lm ly lq lz lu ng mb mc md bi translated">它会启动我们的应用程序。</li><li id="2de7" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ng mb mc md bi translated">它抓取了<code class="fe nh ni nj nk b">ContentView</code>，并断言初始状态是我们所期望的。</li><li id="905a" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ng mb mc md bi translated">它使用实用程序功能从Safari中重新打开应用程序。这将把当前的前台应用从我们的应用切换到Safari。</li><li id="64f7" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ng mb mc md bi translated">它等待我们的应用程序回到前台。</li><li id="b21e" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ng mb mc md bi translated">它断言文本现在已经更改。</li></ol><p id="6e55" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们现在可以运行我们的UI测试并验证它成功了！</p><h1 id="b4f3" class="mj mk it bd ml mm mn mo mp mq mr ms mt jz mu ka mv kc mw kd mx kf my kg mz na bi translated">编写更复杂的测试</h1><p id="a602" class="pw-post-body-paragraph kz la it lb b lc nb ju le lf nc jx lh li nd lk ll lm ne lo lp lq nf ls lt lu im bi translated">既然我们知道设置工作正常，我们可以尝试构建一个更复杂的示例，实际使用我们的深层链接导航到正确的屏幕并运行测试。</p><p id="2463" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在本例中，我们有一个包含三个选项卡的选项卡栏:主页、产品和设置。该测试检查我们是否可以导航到具有给定描述的特定产品。</p><p id="5bda" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">通常，没有深层链接的UI测试需要:</p><ol class=""><li id="64c1" class="lv lw it lb b lc ld lf lg li lx lm ly lq lz lu ng mb mc md bi translated">启动应用程序，</li><li id="2054" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ng mb mc md bi translated">等待它被启动，</li><li id="3c6b" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ng mb mc md bi translated">抓住TabBarButton XCUIElement，</li><li id="6adc" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ng mb mc md bi translated">点击它，</li><li id="94f2" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ng mb mc md bi translated">从列表中抓取产品，</li><li id="726c" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ng mb mc md bi translated">点击它，</li><li id="83a2" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ng mb mc md bi translated">断言我们在正确的屏幕上，</li><li id="91df" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ng mb mc md bi translated">开始断言我们想要测试的东西。</li></ol><p id="230f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这个测试可能会在任何一个步骤中失败，并且需要编写一些(重复的)代码。有了深层的联系，反而会变成这样:</p><ol class=""><li id="8335" class="lv lw it lb b lc ld lf lg li lx lm ly lq lz lu ng mb mc md bi translated">启动应用程序，</li><li id="0b17" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ng mb mc md bi translated">等待它被启动，</li><li id="4930" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ng mb mc md bi translated">断言我们在正确的屏幕上，</li><li id="221f" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ng mb mc md bi translated">开始断言我们想要测试的东西。</li></ol><p id="fb32" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">一半的步骤只是为了这个玩具的例子！你能想象这一招在大app里能省多少步骤吗？</p><h2 id="a726" class="nm mk it bd ml nn no dn mp np nq dp mt li nr ns mv lm nt nu mx lq nv nw mz nx bi translated">创建应用程序</h2><p id="9398" class="pw-post-body-paragraph kz la it lb b lc nb ju le lf nc jx lh li nd lk ll lm ne lo lp lq nf ls lt lu im bi translated">我们需要为应用程序编写不同的屏幕。从导航树的底部开始，我们需要一个带有<code class="fe nh ni nj nk b">Product</code>模型的<code class="fe nh ni nj nk b">ProductView</code>。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ny nz l"/></div></figure><p id="b5f4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">该代码包含一个具有三个属性的<code class="fe nh ni nj nk b">Product</code>模型:</p><ul class=""><li id="cabc" class="lv lw it lb b lc ld lf lg li lx lm ly lq lz lu ma mb mc md bi translated">一个<code class="fe nh ni nj nk b">id</code>，</li><li id="ab61" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated">一个<code class="fe nh ni nj nk b">title</code>，</li><li id="61cf" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated">一个<code class="fe nh ni nj nk b">description</code>。</li></ul><p id="44cc" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">它还公开了一个静态变量来创建一个产品样本，就这个例子而言。</p><p id="29ca" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe nh ni nj nk b">ProductView</code>可以用一个产品的id来初始化，它用一个大标题来呈现它的描述。</p><p id="8831" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们需要的第二个屏幕是一个显示产品列表的<code class="fe nh ni nj nk b">ProductListView</code>。代码如下所示:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ny nz l"/></div></figure><p id="6a93" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这个视图有一个<code class="fe nh ni nj nk b">products</code>数组，用来自<code class="fe nh ni nj nk b">Product</code>模型的<code class="fe nh ni nj nk b">sampleData</code>初始化。它还有一个<code class="fe nh ni nj nk b">@Binding</code>变量来跟踪活动链接。可以通过传递一个<code class="fe nh ni nj nk b">productId</code>来初始化<code class="fe nh ni nj nk b">View</code>，以强制从复合层中进行选择。</p><p id="cd00" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">属性在<code class="fe nh ni nj nk b">NavigationView</code>组件中呈现产品列表。有趣的部分是<code class="fe nh ni nj nk b">NavigationLink</code>初始化器:通过使用<code class="fe nh ni nj nk b">init(_:destination:tag:selection)</code>构造函数，我们启用了编程导航。当<code class="fe nh ni nj nk b">selectedProduct</code>与分配的<code class="fe nh ni nj nk b">tag</code>匹配时，SwiftUI会自动导航到合适的<code class="fe nh ni nj nk b">ProductView</code>。</p><p id="a94b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们需要的最后一个组件是标签栏。我们可以打开<code class="fe nh ni nj nk b">DeepLinkUITestApp</code>并更新如下:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ny nz l"/></div></figure><p id="187f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">该应用程序会跟踪当前选定的选项卡和选定的产品(如果有)。这些状态变量用于以编程方式控制导航。</p><h2 id="893e" class="nm mk it bd ml nn no dn mp np nq dp mt li nr ns mv lm nt nu mx lq nv nw mz nx bi translated">处理深度链接</h2><p id="1ce3" class="pw-post-body-paragraph kz la it lb b lc nb ju le lf nc jx lh li nd lk ll lm ne lo lp lq nf ls lt lu im bi translated">然后，我们需要处理一个传入的深层链接。我们在主应用程序中使用了<code class="fe nh ni nj nk b">onOpenURL</code>修改器。代码将如下所示:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ny nz l"/></div></figure><p id="82bd" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe nh ni nj nk b">onOpenURL</code>关闭工作如下:</p><ol class=""><li id="9942" class="lv lw it lb b lc ld lf lg li lx lm ly lq lz lu ng mb mc md bi translated">它从<code class="fe nh ni nj nk b">URL</code>获取<code class="fe nh ni nj nk b">URLComponents</code>。</li><li id="5426" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ng mb mc md bi translated">它检查主机是否是已知的选项卡之一。</li><li id="cd8a" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ng mb mc md bi translated">如果主机是<code class="fe nh ni nj nk b">"products"</code>，它从<code class="fe nh ni nj nk b">queryItems</code>中提取<code class="fe nh ni nj nk b">id</code>。</li><li id="f98b" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ng mb mc md bi translated">它等待应用程序导航到选定的选项卡。</li><li id="8110" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ng mb mc md bi translated">它选择合适的产品。</li></ol><p id="aecb" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">下面的gif展示了运行中的代码。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi oa"><img src="../Images/d55854b54361081cceb530dc6a2a0d9d.png" data-original-src="https://miro.medium.com/v2/resize:fit:592/1*vYU_3LY4EVKNFsMKH930nw.gif"/></div></figure><h2 id="f9d5" class="nm mk it bd ml nn no dn mp np nq dp mt li nr ns mv lm nt nu mx lq nv nw mz nx bi translated">编写测试</h2><p id="4b89" class="pw-post-body-paragraph kz la it lb b lc nb ju le lf nc jx lh li nd lk ll lm ne lo lp lq nf ls lt lu im bi translated">最后，我们可以在我们的<code class="fe nh ni nj nk b">Product</code>屏幕上编写UITest。</p><p id="0601" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在编写测试之前，我们需要添加一些可访问性标识符，以获取我们需要运行断言的<code class="fe nh ni nj nk b">XCUIElement</code>:</p><ol class=""><li id="69d3" class="lv lw it lb b lc ld lf lg li lx lm ly lq lz lu ng mb mc md bi translated">在<code class="fe nh ni nj nk b">DeepLinkUITestApp</code>中，在<code class="fe nh ni nj nk b">.tag("home")</code>修饰符下面增加一个<code class="fe nh ni nj nk b">.accessibilityIdentifier("home")</code>。</li><li id="8ce9" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ng mb mc md bi translated">在<code class="fe nh ni nj nk b">ProductView</code>中，在<code class="fe nh ni nj nk b">Text</code>组件后增加一个<code class="fe nh ni nj nk b">.accessibilityIdentifier(“product_description”)</code>。</li></ol><p id="39eb" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们打开<code class="fe nh ni nj nk b">DeepLinkUITestUITests.swift</code>文件，用下面的代码更新<code class="fe nh ni nj nk b">testExample</code>函数。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ny nz l"/></div></figure><p id="85fc" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这些测试类似于我们在文章中写的第一个测试:</p><ol class=""><li id="6f14" class="lv lw it lb b lc ld lf lg li lx lm ly lq lz lu ng mb mc md bi translated">它会启动应用程序。</li><li id="d471" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ng mb mc md bi translated">它验证初始屏幕是否是预期的屏幕。</li><li id="bff0" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ng mb mc md bi translated">它打开来自<code class="fe nh ni nj nk b">Safari</code>的应用程序。</li><li id="022c" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ng mb mc md bi translated">它等待应用程序回到前台。</li><li id="2b36" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ng mb mc md bi translated">它获取<code class="fe nh ni nj nk b">productDescription</code>元素并断言它的存在及其值。</li></ol><h1 id="7563" class="mj mk it bd ml mm mn mo mp mq mr ms mt jz mu ka mv kc mw kd mx kf my kg mz na bi translated">结论</h1><p id="95fe" class="pw-post-body-paragraph kz la it lb b lc nb ju le lf nc jx lh li nd lk ll lm ne lo lp lq nf ls lt lu im bi translated">今天我们看了深度链接和UITests的一个有趣的应用。我们回顾了如何设置深层链接的应用程序以及UITests是如何工作的。我们还探索了如何以编程方式使用<code class="fe nh ni nj nk b">Safari</code>打开我们的应用程序，我们编写了一个测试来验证这一点。</p><p id="546a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">使用深层链接来写测试可以节省很多时间。此外，我们执行的操作越少，测试就越快:UITests操作比标准测试指令要重得多。UITest必须将这些指令从一个进程(ui test)传递到另一个进程(app ),这需要时间。</p><p id="493f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这种方法还有另一个好处:这是一个端到端的测试，检查我们的深层链接逻辑是否正常工作，我们还需要什么？</p></div></div>    
</body>
</html>