<html>
<head>
<title>React: Options for State Management</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">React:状态管理的选项</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/react-state-of-the-state-e30e98abdb01?source=collection_archive---------5-----------------------#2019-11-19">https://betterprogramming.pub/react-state-of-the-state-e30e98abdb01?source=collection_archive---------5-----------------------#2019-11-19</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="4c0a" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">Flux，Redux，共享状态，集中存储</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi ki"><img src="../Images/d6397b7bc158d702c0748c47be3c3f99.png" data-original-src="https://miro.medium.com/v2/resize:fit:1192/format:webp/1*7CnRgjqeM8lLTNeyvpJTgg.png"/></div><p class="kq kr gj gh gi ks kt bd b be z dk translated">外观复杂的图表:)</p></figure><p id="ccaa" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated"><a class="ae lq" href="https://reactjs.org/" rel="noopener ugc nofollow" target="_blank"> React </a>是一个基于组件的前端库，基础很容易掌握。复杂的关键领域之一是状态管理。</p><p id="bb2a" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">状态表示程序中数据的处理方式。在UI中，这意味着业务数据和界面元素的条件。在React中，状态主要存在于两个地方:组件中或中央存储中。</p><p id="ed9a" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">有多种处理状态的技术，包括渲染道具、<a class="ae lq" href="https://reactjs.org/docs/context.html" rel="noopener ugc nofollow" target="_blank">上下文API </a>和<a class="ae lq" href="https://redux.js.org/" rel="noopener ugc nofollow" target="_blank"> Redux </a>。大多数应用程序会混合使用多种选项。</p></div><div class="ab cl lr ls hx lt" role="separator"><span class="lu bw bk lv lw lx"/><span class="lu bw bk lv lw lx"/><span class="lu bw bk lv lw"/></div><div class="im in io ip iq"><h1 id="fd2f" class="ly lz it bd ma mb mc md me mf mg mh mi jz mj ka mk kc ml kd mm kf mn kg mo mp bi translated">纯组件和状态</h1><p id="9ebc" class="pw-post-body-paragraph ku kv it kw b kx mq ju kz la mr jx lc ld ms lf lg lh mt lj lk ll mu ln lo lp im bi translated">可以在React中构建无状态的功能性组件:所谓的<em class="mv">纯</em>组件。在这种情况下，我们可以将组件视为中央集权国家的表现形式。</p><p id="8193" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">这个状态仍然存在于<em class="mv">的某个地方</em>。如果不在组件中，则在集中状态对象中，其信息反映在组件中。</p></div><div class="ab cl lr ls hx lt" role="separator"><span class="lu bw bk lv lw lx"/><span class="lu bw bk lv lw lx"/><span class="lu bw bk lv lw"/></div><div class="im in io ip iq"><h1 id="a3fc" class="ly lz it bd ma mb mc md me mf mg mh mi jz mj ka mk kc ml kd mm kf mn kg mo mp bi translated">组件状态</h1><p id="98e3" class="pw-post-body-paragraph ku kv it kw b kx mq ju kz la mr jx lc ld ms lf lg lh mt lj lk ll mu ln lo lp im bi translated">传统上，每个组件都可以有自己的状态，也就是说，变量代表它们保存的内容。在OOP中，这不仅仅是类比，而是完全等同于对象中的状态。</p><p id="16ac" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">组件状态工作得很好，因为它封装了组件中的数据，所以在推理组件行为时，您可以主要考虑组件本身，而不需要参考外部参与者。</p><p id="e45d" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">这是一个易于理解的状态流模型。</p><p id="2ec0" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">组件状态工作得很好，直到应用程序的UI变得足够复杂，组件必须交互和<em class="mv">共享数据。</em></p><h2 id="8e25" class="mw lz it bd ma mx my dn me mz na dp mi ld nb nc mk lh nd ne mm ll nf ng mo nh bi translated">状态和道具</h2><p id="3822" class="pw-post-body-paragraph ku kv it kw b kx mq ju kz la mr jx lc ld ms lf lg lh mt lj lk ll mu ln lo lp im bi translated">将数据从父组件传递到子组件有一个清晰的机制:您可以使用<em class="mv"> props。</em>道具是React的基本特征，很好地服务于目的。</p><p id="a7fd" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">将道具从父级菊花链到子级的想法类似于图1。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi ni"><img src="../Images/66f52a96787543ca3a64a91f7f7eca0f.png" data-original-src="https://miro.medium.com/v2/resize:fit:692/format:webp/1*tE4OdyUq_3xFDEUJR9Ip4g.png"/></div><p class="kq kr gj gh gi ks kt bd b be z dk translated">图1:菊花链道具</p></figure></div><div class="ab cl lr ls hx lt" role="separator"><span class="lu bw bk lv lw lx"/><span class="lu bw bk lv lw lx"/><span class="lu bw bk lv lw"/></div><div class="im in io ip iq"><h2 id="c29a" class="mw lz it bd ma mx my dn me mz na dp mi ld nb nc mk lh nd ne mm ll nf ng mo nh bi translated">“全局”根组件</h2><p id="39d2" class="pw-post-body-paragraph ku kv it kw b kx mq ju kz la mr jx lc ld ms lf lg lh mt lj lk ll mu ln lo lp im bi translated">在这个模型中，不同的视图(因为大型应用程序会将它们的视图分解成不同的根组件)是根组件，最终充当一个集中的状态存储。</p><p id="2063" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">然后，根父节点的状态将状态分发给子节点，这与我们稍后将看到的集中式状态选项类似。这就是从父母到孩子的沟通状态。</p></div><div class="ab cl lr ls hx lt" role="separator"><span class="lu bw bk lv lw lx"/><span class="lu bw bk lv lw lx"/><span class="lu bw bk lv lw"/></div><div class="im in io ip iq"><h1 id="3c50" class="ly lz it bd ma mb mc md me mf mg mh mi jz mj ka mk kc ml kd mm kf mn kg mo mp bi translated">子到父</h1><p id="4668" class="pw-post-body-paragraph ku kv it kw b kx mq ju kz la mr jx lc ld ms lf lg lh mt lj lk ll mu ln lo lp im bi translated">当你需要从孩子到父母的沟通时，第一个难题就出现了。</p><h2 id="9c74" class="mw lz it bd ma mx my dn me mz na dp mi ld nb nc mk lh nd ne mm ll nf ng mo nh bi translated">渲染道具</h2><p id="5d43" class="pw-post-body-paragraph ku kv it kw b kx mq ju kz la mr jx lc ld ms lf lg lh mt lj lk ll mu ln lo lp im bi translated">官方<a class="ae lq" href="https://reactjs.org/docs/render-props.html" rel="noopener ugc nofollow" target="_blank"> React文档</a>已有<em class="mv">渲染道具</em>存在:</p><blockquote class="nj"><p id="4e9b" class="nk nl it bd nm nn no np nq nr ns lp dk translated">“…将一个组件封装的状态或行为共享给需要相同状态的其他组件。”</p></blockquote><p id="df92" class="pw-post-body-paragraph ku kv it kw b kx nt ju kz la nu jx lc ld nv lf lg lh nw lj lk ll nx ln lo lp im bi translated">渲染道具使用函数而不是具体的变量道具。(如果你对这个概念熟悉的话，它有点像mixin。)</p><p id="2fc9" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">render prop的本质是将一个函数传递给接收组件(即子组件)，然后在组件内部调用该函数。</p><p id="493c" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">这里的关键技巧是:您将一个函数从父节点传递给子节点，子节点调用它，从而使子节点能够通过满足该函数调用的任何参数将数据传递回父节点。</p><p id="fd2e" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">函数式编程的经典例子。</p><p id="dcfe" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">这里有一个JS摆弄的简单例子，这个例子来源于<a class="ae lq" href="https://medium.com/@matthewcarltyson/react-in-7-minutes-a4fe81eb13ef" rel="noopener">非感官介绍React </a>中的例子——如果你已经知道React的基础知识，你就会明白，如果没有，花七分钟来达到速度。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ny nz l"/></div></figure><p id="1799" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">所以，最重要的是:</p><pre class="kj kk kl km gt oa ob oc od aw oe bi"><span id="5aac" class="mw lz it ob b gy of og l oh oi">{this.props.renderProp(‘Hello’)}</span></pre><p id="d803" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">在调用函数的子组件中。请注意，我们将一个参数<code class="fe oj ok ol ob b">hello</code>传回给了函数。是的，孩子和父母之间有交流的能力。</p><p id="cfa1" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">当然，在真实的应用程序中，您可以使用任何您想要的真实数据，包括子组件状态，作为传递回父组件的参数。</p><p id="fd8e" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">所以——我们有一个在渲染属性模式中将状态从子节点传递到父节点的解决方案。</p><h2 id="b9a8" class="mw lz it bd ma mx my dn me mz na dp mi ld nb nc mk lh nd ne mm ll nf ng mo nh bi translated">想象一下</h2><p id="b3f2" class="pw-post-body-paragraph ku kv it kw b kx mq ju kz la mr jx lc ld ms lf lg lh mt lj lk ll mu ln lo lp im bi translated">我们可以将渲染道具的概念形象化，如图2所示。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi om"><img src="../Images/2dac516a1f89f1b093acea24b4f0e699.png" data-original-src="https://miro.medium.com/v2/resize:fit:918/format:webp/1*oFmWXeakTzT2miiS5OkbjA.png"/></div><p class="kq kr gj gh gi ks kt bd b be z dk translated">图2:菊花链渲染道具</p></figure><h2 id="fc69" class="mw lz it bd ma mx my dn me mz na dp mi ld nb nc mk lh nd ne mm ll nf ng mo nh bi translated">渲染道具的真实反映</h2><p id="a538" class="pw-post-body-paragraph ku kv it kw b kx mq ju kz la mr jx lc ld ms lf lg lh mt lj lk ll mu ln lo lp im bi translated">这不仅为子-父通信提供了一个干净的机制，还支持创建可重用的组件(以及<a class="ae lq" href="https://reactjs.org/docs/higher-order-components.html" rel="noopener ugc nofollow" target="_blank">更高阶的组件</a>，或者返回组件的组件)。</p><p id="d801" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">但是在组件间通信方面，这是相当有限的。如果状态需要在多个或远处的组件之间共享，这就变得难以维持。</p><p id="9ff9" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">我们不想做的一件事是开始跨遥远的组件菊花链一堆渲染道具来实现状态共享。这是脆弱的，只是简单的丑陋。</p></div><div class="ab cl lr ls hx lt" role="separator"><span class="lu bw bk lv lw lx"/><span class="lu bw bk lv lw lx"/><span class="lu bw bk lv lw"/></div><div class="im in io ip iq"><h1 id="c595" class="ly lz it bd ma mb mc md me mf mg mh mi jz mj ka mk kc ml kd mm kf mn kg mo mp bi translated">上下文API</h1><p id="ab40" class="pw-post-body-paragraph ku kv it kw b kx mq ju kz la mr jx lc ld ms lf lg lh mt lj lk ll mu ln lo lp im bi translated">处理共享状态的另一个候选是<a class="ae lq" href="https://reactjs.org/docs/context.html" rel="noopener ugc nofollow" target="_blank">上下文API </a>。</p><p id="1854" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">上下文API被明确设计为处理大量组件需要某种状态的情况。</p><p id="150d" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">在这种情况下，每个组件都可以访问上下文，而不是像props那样将组件关联在一起以共享状态。</p><p id="5163" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">这个概念如图3所示。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi on"><img src="../Images/ce0ce8d85f70593be066035f29a53482.png" data-original-src="https://miro.medium.com/v2/resize:fit:1012/format:webp/1*0XYVZqqYLX-5TPT7Gi8vZQ.png"/></div><p class="kq kr gj gh gi ks kt bd b be z dk translated">图3:上下文API</p></figure><p id="b16a" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">所以，这看起来更像是我们想要的处理复杂组件树的共享状态。</p><p id="3ef6" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">上下文API非常简单。要创建默认上下文:</p><pre class="kj kk kl km gt oa ob oc od aw oe bi"><span id="1874" class="mw lz it ob b gy of og l oh oi">const LanguageContext = React.createContext(‘english’);</span></pre><p id="a220" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">然后，您可以修改根或低级组件中的值，如下所示:</p><pre class="kj kk kl km gt oa ob oc od aw oe bi"><span id="b77b" class="mw lz it ob b gy of og l oh oi">class Parent extends React.Component {<br/>  render() {<br/>    return (<br/>      &lt;<!-- -->LanguageContext<!-- -->.Provider value="tibetan"&gt;<br/>        &lt;Child /&gt;<br/>      &lt;/<!-- -->LanguageContext<!-- -->.Provider&gt;<br/>    );<br/>  }<br/>}</span></pre><p id="bd09" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">一旦低级组件将上下文引入树中，任何子组件都可以访问它，不管它们的嵌套有多深。</p><p id="cf9d" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">您可以像这样访问该值:</p><pre class="kj kk kl km gt oa ob oc od aw oe bi"><span id="7d05" class="mw lz it ob b gy of og l oh oi">static lang = LanguageContext;<br/>  render() {<br/>    return &lt;Button language={this.lang} /&gt;;<br/>  }</span></pre><p id="3046" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">(注意:这是较新的上下文API)。</p><h2 id="0af2" class="mw lz it bd ma mx my dn me mz na dp mi ld nb nc mk lh nd ne mm ll nf ng mo nh bi translated">不废话</h2><p id="1690" class="pw-post-body-paragraph ku kv it kw b kx mq ju kz la mr jx lc ld ms lf lg lh mt lj lk ll mu ln lo lp im bi translated">所以，这是一个非常干净和简单的方式来传递简单的数据。然而，它不能很好地扩展，也不能很好地处理动态数据。它更适合静态的简单数据类型。</p><p id="b1ff" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">您不希望试图管理复杂的数据结构，这些数据结构被API调用和上下文中的用户交互所修改。</p><p id="3ab0" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">要了解更多选项，让我们来看看备受关注的…</p></div><div class="ab cl lr ls hx lt" role="separator"><span class="lu bw bk lv lw lx"/><span class="lu bw bk lv lw lx"/><span class="lu bw bk lv lw"/></div><div class="im in io ip iq"><h1 id="6f5f" class="ly lz it bd ma mb mc md me mf mg mh mi jz mj ka mk kc ml kd mm kf mn kg mo mp bi translated">Redux</h1><p id="f902" class="pw-post-body-paragraph ku kv it kw b kx mq ju kz la mr jx lc ld ms lf lg lh mt lj lk ll mu ln lo lp im bi translated">Redux从<a class="ae lq" href="https://facebook.github.io/flux/" rel="noopener ugc nofollow" target="_blank">通量</a>下降。通量是一个<em class="mv">想法</em>。</p><p id="c694" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">这个想法是，您创建一个集中的存储，然后以特定的方式控制对它的访问。在高层次上，这看起来类似于上下文API的工作方式。</p><p id="cd6d" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">改变Redux状态的核心限制是状态只能通过向商店提交一个<em class="mv">动作</em>来修改。(这类似于组件状态只能通过<code class="fe oj ok ol ob b">setState()</code>修改的要求)。</p><p id="b69a" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">动作定义了将要发生在状态上的一种离散的修改。一个<em class="mv">调度器</em>负责将动作发送到商店，在那里它被一个<em class="mv">缩减器</em>捕获，后者负责将动作应用到状态。</p><p id="4cf9" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">这本质上是一个基于事件的架构，类似于<a class="ae lq" href="https://en.wikipedia.org/wiki/Command_pattern" rel="noopener ugc nofollow" target="_blank">命令</a>设计模式(其中动作扮演命令的角色)。</p><p id="d72b" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">我们可以看看图4。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi oo"><img src="../Images/f10b0068109579b25cd14f7ca86f9c5b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1172/format:webp/1*_t2ornLjfDM-RJGouI4EqQ.png"/></div><p class="kq kr gj gh gi ks kt bd b be z dk translated">图4: Redux</p></figure><p id="c182" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">但是……为什么呢？</p><p id="0c74" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">它做的一件事是克服了上下文API的限制。该存储能够处理复杂的数据结构，并将它们与复杂的视图相关联。它还可以通过Redux中间件与后端API进行交互。</p><p id="2c48" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">但是我们再次问:“为什么它是这样构成的？”</p><p id="4c89" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">首先，我想真正锤这个家，Redux的发展有一个关键原因；它解决了一个<em class="mv">特定的</em>问题。</p><p id="5b16" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated"><em class="mv"> Redux解决了一个特定的问题:多参与者状态改变竞争条件</em></p><p id="72bf" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">它解决的问题是状态中的竞争条件被多个参与者修改。</p><p id="7f1e" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">通过强制向商店提交动作，您可以避免以下(<a class="ae lq" href="https://en.wikipedia.org/wiki/Race_condition" rel="noopener ugc nofollow" target="_blank">经典、规范编码</a>)问题:</p><ul class=""><li id="12d3" class="op oq it kw b kx ky la lb ld or lh os ll ot lp ou ov ow ox bi translated">组件A查看状态，得到一个值，比如:100。</li><li id="d850" class="op oq it kw b kx oy la oz ld pa lh pb ll pc lp ou ov ow ox bi translated">组件B也看，也得到100。</li><li id="0b0a" class="op oq it kw b kx oy la oz ld pa lh pb ll pc lp ou ov ow ox bi translated">组件A通过增加1来修改该值，使其成为101。</li><li id="3b00" class="op oq it kw b kx oy la oz ld pa lh pb ll pc lp ou ov ow ox bi translated">组件B现在通过增加1来修改<em class="mv">的</em>值，使其再次为101。</li></ul><p id="2911" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">其中该值应该以102结束。</p><p id="3b7e" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">现在，您可以看到，当多个组件竞争状态修改时，可能会出现这种竞争情况，但这实际上不太可能。更成问题的是到达UI的用户交互和API响应的交错。</p><p id="ae44" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">然而，让我们再次强调这一点，当WebSocket(或其他服务器推送)与用户动作直接竞争相同的状态时，真正的可重复问题出现了。</p><p id="d6b1" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">对于脸书来说，如果传说可信的话，这就是未读信息计数器。</p><p id="55d2" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">无论如何，让我们为这个做一个数字，因为它确实是中心。图5。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi ki"><img src="../Images/d6397b7bc158d702c0748c47be3c3f99.png" data-original-src="https://miro.medium.com/v2/resize:fit:1192/format:webp/1*7CnRgjqeM8lLTNeyvpJTgg.png"/></div><p class="kq kr gj gh gi ks kt bd b be z dk translated">图5:使用WebSockets的Redux</p></figure><p id="3c3b" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">这就是使用Redux的铁一般的理由:您正在处理竞争条件。</p><p id="f286" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">但是让我们先回顾一下。我们想避免一些严重的错误想法。</p><p id="0ef5" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">首先，除非万不得已，不要使用中央全局状态。如果满足您的需求，您希望封装您的组件状态并保持不变。</p><p id="6bf4" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">这一思路的第二点是:除非有充分的理由，否则不要使用复杂的中央存储来管理状态。</p><blockquote class="nj"><p id="b5f3" class="nk nl it bd nm nn no np nq nr ns lp dk translated">"<strong class="ak">最简单的解决方案</strong>几乎总是最好的."—奥卡姆剃刀</p></blockquote><p id="7da7" class="pw-post-body-paragraph ku kv it kw b kx nt ju kz la nu jx lc ld nv lf lg lh nw lj lk ll nx ln lo lp im bi translated">然而，Redux提供的一些好处可能会激励你。</p><h2 id="1d0d" class="mw lz it bd ma mx my dn me mz na dp mi ld nb nc mk lh nd ne mm ll nf ng mo nh bi translated">容易推理</h2><p id="65f9" class="pw-post-body-paragraph ku kv it kw b kx mq ju kz la mr jx lc ld ms lf lg lh mt lj lk ll mu ln lo lp im bi translated">除了竞态条件之外，最引人注目的(IMHO)是您正在创建一个更容易理解和推理的应用程序状态的想法。</p><p id="9236" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">简而言之:所有的状态都集中在一个地方，所有可能的状态变化都在动作中明确列出，并在调度程序中说明。</p><p id="4be6" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">这是一个有趣的想法。</p><p id="0870" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">我并不完全相信它，但是我认为它对于大规模应用是有意义的，只是有一些警告。</p><p id="11da" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">首先，你给管理状态的方式增加了复杂性，所以我们必须通过增加可理解性来克服这个问题。</p><p id="a6c3" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">另一方面，应用程序状态的复杂性(也可能是开发应用程序的团队的复杂性)应该值得采用。</p><p id="d614" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">我要赶紧补充一点，我认为大多数应用程序，<em class="mv">尤其是</em>敏捷、快速发展的新兴应用程序，应该避免(阅读:完全避免)处理Redux来管理状态的额外开销。</p><p id="c56b" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">如果您正在使用它，请填写下面的空白:“我们正在使用Redux到_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _”</p><p id="cee7" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">现在，让我们看看Redux提供的其他一些好处:</p><ul class=""><li id="be95" class="op oq it kw b kx ky la lb ld or lh os ll ot lp ou ov ow ox bi translated">可播放状态。</li><li id="08ee" class="op oq it kw b kx oy la oz ld pa lh pb ll pc lp ou ov ow ox bi translated">撤消历史记录。</li></ul><p id="3605" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">可回放状态意味着您能够发送完整的应用程序状态用于调试目的，本质上是重新创建错误发生时的状态。</p><p id="c912" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">我的感觉是，作为一个想法，这可能听起来更好，而且比它在实践中的表现更好(当然，除非你有一大群开发人员来对付它)。</p><p id="5a82" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">撤销历史依赖于这样一个事实，即您可以维护历史并恢复操作(就像我们前面提到的经典命令模式一样)。</p><p id="d203" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">最后，在面对集中式状态时，使用Redux还有一个更有说服力的理由:它很好理解，也很受欢迎。</p><p id="8b63" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">等等，等等——我并不是说你应该用它，因为它很流行。我的意思是，它比许多人知道和理解它更受欢迎。</p><p id="e83b" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">因此，您可以在对其有利的方面与增加的复杂性之间进行平衡，并奇怪地意识到实际上可能没有更简单、更干净的中央状态存储解决方案可以扔给React。</p></div><div class="ab cl lr ls hx lt" role="separator"><span class="lu bw bk lv lw lx"/><span class="lu bw bk lv lw lx"/><span class="lu bw bk lv lw"/></div><div class="im in io ip iq"><h1 id="9aa2" class="ly lz it bd ma mb mc md me mf mg mh mi jz mj ka mk kc ml kd mm kf mn kg mo mp bi translated">钩住</h1><p id="2a6c" class="pw-post-body-paragraph ku kv it kw b kx mq ju kz la mr jx lc ld ms lf lg lh mt lj lk ll mu ln lo lp im bi translated">现在，让我们考虑一个替代方案，使用本文中描述的<em class="mv">钩子</em>:使用React钩子 的<a class="ae lq" href="https://medium.com/javascript-in-plain-english/state-management-with-react-hooks-no-redux-or-context-api-8b3035ceecf8" rel="noopener"> <em class="mv">状态管理。</em></a></p><p id="0b40" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">这似乎是一个有趣的想法，然而，总的来说，我们又一次增加了复杂性，而不是减少它。</p><p id="e728" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">我认为这是作者进行的一个有价值的实验。也许他正在开发的npm包将会为我提供我正在寻找的东西，那就是…</p><h1 id="5ba0" class="ly lz it bd ma mb pd md me mf pe mh mi jz pf ka mk kc pg kd mm kf ph kg mo mp bi translated">金发姑娘</h1><p id="a529" class="pw-post-body-paragraph ku kv it kw b kx mq ju kz la mr jx lc ld ms lf lg lh mt lj lk ll mu ln lo lp im bi translated">我仍然在React中寻找我的状态管理“恰到好处”的解决方案。</p><p id="f060" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">感觉应该有一个简单的机制存在于上下文API和Redux之间。它允许一个集中的状态，可以处理复杂的结构，并以最小的复杂度服务API交互。</p><h2 id="aee7" class="mw lz it bd ma mx my dn me mz na dp mi ld nb nc mk lh nd ne mm ll nf ng mo nh bi translated">哪里是国家最好的地方？</h2><p id="bfaa" class="pw-post-body-paragraph ku kv it kw b kx mq ju kz la mr jx lc ld ms lf lg lh mt lj lk ll mu ln lo lp im bi translated">我想知道，在最后的分析中，是否有一个干净的集中状态或面向组件的状态，或者一个混合状态更好，更有意义，更容易理解和管理？</p><p id="b38d" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">像软件中的大多数事情一样，这可能会成为一个问题，即具体的需求是什么。你在构建什么，有多复杂，团队有多大，有多少API交互，等等。</p></div></div>    
</body>
</html>