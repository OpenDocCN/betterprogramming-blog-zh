<html>
<head>
<title>Gestures in SwiftUI</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">SwiftUI中的手势</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/gestures-in-swiftui-e94b784ecc7?source=collection_archive---------5-----------------------#2019-12-05">https://betterprogramming.pub/gestures-in-swiftui-e94b784ecc7?source=collection_archive---------5-----------------------#2019-12-05</a></blockquote><div><div class="fc ii ij ik il im"/><div class="in io ip iq ir"><div class=""/><div class=""><h2 id="f296" class="pw-subtitle-paragraph jr it iu bd b js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki dk translated">像在Tinder中一样滑动，创建一个手势状态属性包装器，等等</h2></div><figure class="kk kl km kn gu ko gi gj paragraph-image"><div role="button" tabindex="0" class="kp kq di kr bf ks"><div class="gi gj kj"><img src="../Images/81a629ce9ce929eafce9ac45157bafb6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*QrKDP-YYUfB0HHfIGy-qMg.png"/></div></div><p class="kv kw gk gi gj kx ky bd b be z dk translated">这是我在创作这件作品时创作的</p></figure><p id="498f" class="pw-post-body-paragraph kz la iu lb b lc ld jv le lf lg jy lh li lj lk ll lm ln lo lp lq lr ls lt lu in bi translated">手势识别负责侦听特定的触摸输入序列，并做出相应的反应。我们可以从这些交互中定义动作，甚至组成多个按顺序或同时工作的手势。</p><p id="7795" class="pw-post-body-paragraph kz la iu lb b lc ld jv le lf lg jy lh li lj lk ll lm ln lo lp lq lr ls lt lu in bi translated"><code class="fe lv lw lx ly b">GestureState</code>是一个属性包装器，仅适用于手势。它负责在手势改变时更新状态的属性值，并在手势完成后将其重置为初始值。</p><p id="caed" class="pw-post-body-paragraph kz la iu lb b lc ld jv le lf lg jy lh li lj lk ll lm ln lo lp lq lr ls lt lu in bi translated"><code class="fe lv lw lx ly b">GestureState</code>是不可变的属性，不像<code class="fe lv lw lx ly b">State</code>。</p><p id="4142" class="pw-post-body-paragraph kz la iu lb b lc ld jv le lf lg jy lh li lj lk ll lm ln lo lp lq lr ls lt lu in bi translated">目前，SwiftUI支持五种手势修改器:</p><ul class=""><li id="8e80" class="lz ma iu lb b lc ld lf lg li mb lm mc lq md lu me mf mg mh bi translated"><a class="ae mi" href="https://developer.apple.com/documentation/swiftui/tapgesture" rel="noopener ugc nofollow" target="_blank">点击手势</a></li><li id="c7a4" class="lz ma iu lb b lc mj lf mk li ml lm mm lq mn lu me mf mg mh bi translated"><a class="ae mi" href="https://developer.apple.com/documentation/swiftui/longpressgesture" rel="noopener ugc nofollow" target="_blank">长按手势</a></li><li id="a72b" class="lz ma iu lb b lc mj lf mk li ml lm mm lq mn lu me mf mg mh bi translated"><a class="ae mi" href="https://developer.apple.com/documentation/swiftui/draggesture" rel="noopener ugc nofollow" target="_blank">拖拽手势</a></li><li id="aa01" class="lz ma iu lb b lc mj lf mk li ml lm mm lq mn lu me mf mg mh bi translated"><a class="ae mi" href="https://developer.apple.com/documentation/swiftui/magnificationgesture" rel="noopener ugc nofollow" target="_blank">放大手势</a></li><li id="f5d7" class="lz ma iu lb b lc mj lf mk li ml lm mm lq mn lu me mf mg mh bi translated"><a class="ae mi" href="https://developer.apple.com/documentation/swiftui/rotationgesture" rel="noopener ugc nofollow" target="_blank">旋转手势</a></li></ul><p id="e584" class="pw-post-body-paragraph kz la iu lb b lc ld jv le lf lg jy lh li lj lk ll lm ln lo lp lq lr ls lt lu in bi translated">然而，我们仍然可以创建自己的自定义手势，或者将上述手势结合起来进行复杂的交互。以下是用于以不同方式组合手势的三种复合类型:</p><ul class=""><li id="5cfa" class="lz ma iu lb b lc ld lf lg li mb lm mc lq md lu me mf mg mh bi translated"><code class="fe lv lw lx ly b">Simultaneous</code> —所有的手势模式与此类型一起工作</li><li id="5ceb" class="lz ma iu lb b lc mj lf mk li ml lm mm lq mn lu me mf mg mh bi translated"><code class="fe lv lw lx ly b">Sequenced</code> —对手势进行排序，使得第二个手势在第一个手势结束之前不会收到任何事件</li><li id="97ec" class="lz ma iu lb b lc mj lf mk li ml lm mm lq mn lu me mf mg mh bi translated"><code class="fe lv lw lx ly b">Exclusive</code> —当只有一个手势成功时使用</li></ul></div><div class="ab cl mo mp hy mq" role="separator"><span class="mr bw bk ms mt mu"/><span class="mr bw bk ms mt mu"/><span class="mr bw bk ms mt"/></div><div class="in io ip iq ir"><h1 id="3eba" class="mv mw iu bd mx my mz na nb nc nd ne nf ka ng kb nh kd ni ke nj kg nk kh nl nm bi translated">我们的目标</h1><ul class=""><li id="13df" class="lz ma iu lb b lc nn lf no li np lm nq lq nr lu me mf mg mh bi translated">在接下来的几节中，我们将学习每个简单的手势修饰符。随后，我们从几个手势中创建一个复合手势。</li><li id="4e22" class="lz ma iu lb b lc mj lf mk li ml lm mm lq mn lu me mf mg mh bi translated">此外，我们将编写一个滑动视图的手势，这在约会应用程序中相当常见，如Tinder。</li></ul></div><div class="ab cl mo mp hy mq" role="separator"><span class="mr bw bk ms mt mu"/><span class="mr bw bk ms mt mu"/><span class="mr bw bk ms mt"/></div><div class="in io ip iq ir"><h1 id="90e7" class="mv mw iu bd mx my mz na nb nc nd ne nf ka ng kb nh kd ni ke nj kg nk kh nl nm bi translated">点击手势</h1><p id="89e5" class="pw-post-body-paragraph kz la iu lb b lc nn jv le lf no jy lh li ns lk ll lm nt lo lp lq nu ls lt lu in bi translated">当指定数量的点击发生在它所连接的视图上时,<code class="fe lv lw lx ly b">TapGesture</code>结束。以下SwiftUI示例在<code class="fe lv lw lx ly b">Circle</code>上添加了一个<code class="fe lv lw lx ly b">TapGesture</code>，并在手势完成后更改颜色和阴影:</p><pre class="kk kl km kn gu nv ly nw nx aw ny bi"><span id="3216" class="nz mw iu ly b gz oa ob l oc od">    @State private var didTap: Bool = false<br/>    <br/>    var body: some View {<br/>        <br/>        Circle()<br/>            .fill(didTap ? Color.blue : Color.red)<br/>            .shadow(radius: didTap ? 30 : 0)<br/>            .frame(width: 150, height: 150, alignment: .center)<br/>            .gesture(TapGesture()<br/>                .onEnded {_ in<br/>                    self.didTap.toggle()<br/>                }<br/>            )<br/>        }</span></pre><p id="0fd8" class="pw-post-body-paragraph kz la iu lb b lc ld jv le lf lg jy lh li lj lk ll lm ln lo lp lq lr ls lt lu in bi translated">要设置双击/多击手势，只需将<code class="fe lv lw lx ly b">TapGesture()</code>更改为<code class="fe lv lw lx ly b">TapGesture(count : 2)</code>。</p><p id="cd9d" class="pw-post-body-paragraph kz la iu lb b lc ld jv le lf lg jy lh li lj lk ll lm ln lo lp lq lr ls lt lu in bi translated">或者，我们可以直接在<code class="fe lv lw lx ly b">Circle</code>上使用<code class="fe lv lw lx ly b">onTapGesture{}</code>闭包，如下图所示:</p><figure class="kk kl km kn gu ko gi gj paragraph-image"><div role="button" tabindex="0" class="kp kq di kr bf ks"><div class="gi gj oe"><img src="../Images/103c0abffc5b6c1521a1fc54aa10baf7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*PlID25MMU6tl84hXYX_a_w.gif"/></div></div></figure></div><div class="ab cl mo mp hy mq" role="separator"><span class="mr bw bk ms mt mu"/><span class="mr bw bk ms mt mu"/><span class="mr bw bk ms mt"/></div><div class="in io ip iq ir"><h1 id="e2ec" class="mv mw iu bd mx my mz na nb nc nd ne nf ka ng kb nh kd ni ke nj kg nk kh nl nm bi translated">长按手势</h1><p id="1baf" class="pw-post-body-paragraph kz la iu lb b lc nn jv le lf no jy lh li ns lk ll lm nt lo lp lq nu ls lt lu in bi translated">当用户按下视图一段时间后,<code class="fe lv lw lx ly b">LongPressGesture</code>结束。下面的代码将<code class="fe lv lw lx ly b">LongPressGesture</code>添加到一个矩形上。手势完成后，视图会显示一个缩放效果。</p><pre class="kk kl km kn gu nv ly nw nx aw ny bi"><span id="2ca4" class="nz mw iu ly b gz oa ob l oc od">struct ContentView: View {<br/>    @State private var didLongPress: Bool = false<br/>    <br/>    var body: some View {<br/>        <br/>        Rectangle()<br/>            .foregroundColor(Color.purple)<br/>            .cornerRadius(40)<br/>            .scaleEffect(didLongPress ? 1.2 : 1)<br/>            .frame(width: 200, height: 200, alignment: .center)<br/>            .gesture(LongPressGesture(minimumDuration: 1.0)<br/>                .onEnded({_ in self.didLongPress.toggle() }))<br/>            .animation(.easeInOut)<br/>    }<br/>}</span></pre><figure class="kk kl km kn gu ko gi gj paragraph-image"><div class="gi gj of"><img src="../Images/d4acd0c5e42c53b3e7cf4a36262d1989.png" data-original-src="https://miro.medium.com/v2/resize:fit:506/1*QcJ_PJpAubXoXwnvXJllQQ.gif"/></div></figure></div><div class="ab cl mo mp hy mq" role="separator"><span class="mr bw bk ms mt mu"/><span class="mr bw bk ms mt mu"/><span class="mr bw bk ms mt"/></div><div class="in io ip iq ir"><h1 id="1702" class="mv mw iu bd mx my mz na nb nc nd ne nf ka ng kb nh kd ni ke nj kg nk kh nl nm bi translated">使用手势状态长按</h1><p id="b207" class="pw-post-body-paragraph kz la iu lb b lc nn jv le lf no jy lh li ns lk ll lm nt lo lp lq nu ls lt lu in bi translated">在上图中，为了回到初始位置，您需要再次长按或者通过在<code class="fe lv lw lx ly b">onChanged</code>功能中添加切换来调整代码。这可以通过使用<code class="fe lv lw lx ly b">GestureState</code>来简化，如下所示:</p><pre class="kk kl km kn gu nv ly nw nx aw ny bi"><span id="21c8" class="nz mw iu ly b gz oa ob l oc od">struct ContentView: View {<br/><strong class="ly iv">    @</strong><strong class="ly iv">GestureState</strong> private var didLongPress: Bool = false<br/>    <br/>    var body: some View {<br/>        <br/>        Rectangle()<br/>            .foregroundColor(Color.purple)<br/>            .cornerRadius(40)<br/>            .scaleEffect(didLongPress ? 1.2 : 1)<br/>            .frame(width: 200, height: 200, alignment: .center)<br/>            .gesture(LongPressGesture(minimumDuration: 1.0)<br/>                .<strong class="ly iv">updating($didLongPress)</strong> { value, state, transcation                         in<br/>                    state = value})<br/>            .animation(.easeInOut)<br/>    }<br/>}</span></pre><p id="297d" class="pw-post-body-paragraph kz la iu lb b lc ld jv le lf lg jy lh li lj lk ll lm ln lo lp lq lr ls lt lu in bi translated"><code class="fe lv lw lx ly b">updating</code>函数负责返回事件期间的瞬态事件。一旦手势结束，<code class="fe lv lw lx ly b">GestureState</code>将重置为初始值，从而带来一个不错的缩放效果。</p><figure class="kk kl km kn gu ko gi gj paragraph-image"><div role="button" tabindex="0" class="kp kq di kr bf ks"><div class="gi gj og"><img src="../Images/296beeaeb8456944ae8d1845c27e4f28.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*LhexPCP-gXSrh70b4-nY5Q.gif"/></div></div><p class="kv kw gk gi gj kx ky bd b be z dk translated">长按颜色开关的放大/缩小效果</p></figure></div><div class="ab cl mo mp hy mq" role="separator"><span class="mr bw bk ms mt mu"/><span class="mr bw bk ms mt mu"/><span class="mr bw bk ms mt"/></div><div class="in io ip iq ir"><p id="f674" class="pw-post-body-paragraph kz la iu lb b lc ld jv le lf lg jy lh li lj lk ll lm ln lo lp lq lr ls lt lu in bi translated">在我们完成接下来的三个手势之前，让我们先排除一个重要的障碍:</p><h2 id="f174" class="nz mw iu bd mx oh oi dn nb oj ok dp nf li ol om nh lm on oo nj lq op oq nl or bi translated">手势的顺序至关重要</h2><p id="60bd" class="pw-post-body-paragraph kz la iu lb b lc nn jv le lf no jy lh li ns lk ll lm nt lo lp lq nu ls lt lu in bi translated">对于您计划同时使用长按和点击手势的情况，顺序很重要。放置在<code class="fe lv lw lx ly b">TapGesture</code>之后的<code class="fe lv lw lx ly b">LongPressGesture</code>将允许两者独立工作，反之，颠倒它们将导致<code class="fe lv lw lx ly b">TapGesture</code>被忽略，如下所示:</p><pre class="kk kl km kn gu nv ly nw nx aw ny bi"><span id="fcc0" class="nz mw iu ly b gz oa ob l oc od">.onTapGesture {print("This will work")}<br/>.onLongPressGesture(minimumDuration: 0.1){print("This will work")}<br/></span><span id="a79f" class="nz mw iu ly b gz os ob l oc od">.onLongPressGesture(minimumDuration: 0.1){print("This will work")}<br/>.onTapGesture {print("<strong class="ly iv">This would not be recognised</strong>")}</span></pre></div><div class="ab cl mo mp hy mq" role="separator"><span class="mr bw bk ms mt mu"/><span class="mr bw bk ms mt mu"/><span class="mr bw bk ms mt"/></div><div class="in io ip iq ir"><h1 id="6d20" class="mv mw iu bd mx my mz na nb nc nd ne nf ka ng kb nh kd ni ke nj kg nk kh nl nm bi translated">拖拽手势</h1><p id="bb73" class="pw-post-body-paragraph kz la iu lb b lc nn jv le lf no jy lh li ns lk ll lm nt lo lp lq nu ls lt lu in bi translated">一个<code class="fe lv lw lx ly b">DragGesture</code>可以用来刷卡(例如在地图或Tinder中垂直或水平)。以下代码显示了一个这样的SwiftUI示例:</p><figure class="kk kl km kn gu ko gi gj paragraph-image"><div role="button" tabindex="0" class="kp kq di kr bf ks"><div class="gi gj ot"><img src="../Images/61a1172e653cd059dec46ed590136462.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*vlzOl2xBv5xQbZHxq6Oxtw.gif"/></div></div></figure><p id="5786" class="pw-post-body-paragraph kz la iu lb b lc ld jv le lf lg jy lh li lj lk ll lm ln lo lp lq lr ls lt lu in bi translated">在上面的代码中，<code class="fe lv lw lx ly b">onChanged</code>事件包含拖动值，从中我们可以确定当前的属性，如大小、宽度、高度等。我们使用了height属性来改变矩形的<code class="fe lv lw lx ly b">offset</code>。<code class="fe lv lw lx ly b">onEnded</code>事件将大小重置为初始值。</p></div><div class="ab cl mo mp hy mq" role="separator"><span class="mr bw bk ms mt mu"/><span class="mr bw bk ms mt mu"/><span class="mr bw bk ms mt"/></div><div class="in io ip iq ir"><h1 id="4493" class="mv mw iu bd mx my mz na nb nc nd ne nf ka ng kb nh kd ni ke nj kg nk kh nl nm bi translated">放大和旋转手势</h1><p id="3ef2" class="pw-post-body-paragraph kz la iu lb b lc nn jv le lf no jy lh li ns lk ll lm nt lo lp lq nu ls lt lu in bi translated">这是两个手势，工作方式与<code class="fe lv lw lx ly b">DragGesture</code>相似。放大手势的<code class="fe lv lw lx ly b">onChanged</code>事件返回一个<code class="fe lv lw lx ly b">CGFloat</code>值，该值可用于相应地缩放视图，而旋转手势返回一个<code class="fe lv lw lx ly b">Angle</code>属性值，该属性值在<code class="fe lv lw lx ly b">rotationEffect</code>上使用以产生旋转。</p><p id="079c" class="pw-post-body-paragraph kz la iu lb b lc ld jv le lf lg jy lh li lj lk ll lm ln lo lp lq lr ls lt lu in bi translated">下面的代码演示了放大和旋转手势同时工作的情况:</p><pre class="kk kl km kn gu nv ly nw nx aw ny bi"><span id="c6af" class="nz mw iu ly b gz oa ob l oc od">struct ContentView: View {<br/>    @State<!-- --> var magnificationValue: CGFloat = CGFloat(1)<br/>    @State var rotationValue: Angle = .zero<br/>    <br/>    var body: some View {<br/>        <br/>        Rectangle()<br/>            .foregroundColor(Color.purple)<br/>            .cornerRadius(40)<br/>            .scaleEffect(magnificationValue)<br/>            .rotationEffect(rotationValue)<br/>            .frame(width: 200, height: 200, alignment: .center)<br/>            .gesture(MagnificationGesture()<br/>            .onChanged { value in<br/>            self.magnificationValue = value<br/>            }<br/>            .simultaneously(with: RotationGesture().onChanged { value in<br/>                    self.rotationValue = value<br/>            }))<br/>            <br/>    }<br/>}</span></pre><p id="38f4" class="pw-post-body-paragraph kz la iu lb b lc ld jv le lf lg jy lh li lj lk ll lm ln lo lp lq lr ls lt lu in bi translated">我们在SwiftUI实时预览中获得了以下结果:</p><figure class="kk kl km kn gu ko gi gj paragraph-image"><div class="gi gj ou"><img src="../Images/8d7af2d29000e9cb95b646b94635c5f4.png" data-original-src="https://miro.medium.com/v2/resize:fit:484/1*pjl4M0LElVr5fWj1aPD50A.gif"/></div></figure></div><div class="ab cl mo mp hy mq" role="separator"><span class="mr bw bk ms mt mu"/><span class="mr bw bk ms mt mu"/><span class="mr bw bk ms mt"/></div><div class="in io ip iq ir"><h1 id="810e" class="mv mw iu bd mx my mz na nb nc nd ne nf ka ng kb nh kd ni ke nj kg nk kh nl nm bi translated">构建一个类似火绒的滑动手势</h1><p id="f6d0" class="pw-post-body-paragraph kz la iu lb b lc nn jv le lf no jy lh li ns lk ll lm nt lo lp lq nu ls lt lu in bi translated">左右滑动接受和拒绝是当今约会应用的规范。在本节中，我们将使用SwiftUI来完成这项工作。</p><p id="3cce" class="pw-post-body-paragraph kz la iu lb b lc ld jv le lf lg jy lh li lj lk ll lm ln lo lp lq lr ls lt lu in bi translated">为了创建一个可滑动的交互，我们将利用<code class="fe lv lw lx ly b">DragGesture</code>，它在某个部分被拖动后具有旋转效果。在下面的代码中，我们在一个<code class="fe lv lw lx ly b">ZStack</code>中添加了一些矩形卡片，每个卡片上都设置了手势修改器:</p><figure class="kk kl km kn gu ko"><div class="bz fq l di"><div class="ov ow l"/></div></figure><p id="ab21" class="pw-post-body-paragraph kz la iu lb b lc ld jv le lf lg jy lh li lj lk ll lm ln lo lp lq lr ls lt lu in bi translated">当拖动结束时，我们检查所走的距离。基于此，我们决定它是否通过刷卡阈值。此外，还有规模效应。</p><p id="78ae" class="pw-post-body-paragraph kz la iu lb b lc ld jv le lf lg jy lh li lj lk ll lm ln lo lp lq lr ls lt lu in bi translated"><code class="fe lv lw lx ly b">SwipeObserver</code>类负责根据手势交互更新状态。<code class="fe lv lw lx ly b">EnvironmentObject</code>在<code class="fe lv lw lx ly b">SceneDelegate</code>类中以如下方式被实例化:</p><pre class="kk kl km kn gu nv ly nw nx aw ny bi"><span id="c3c7" class="nz mw iu ly b gz oa ob l oc od">UIHostingController(rootView: contentView.environmentObject(SwipeObserver()))</span></pre><p id="9dc6" class="pw-post-body-paragraph kz la iu lb b lc ld jv le lf lg jy lh li lj lk ll lm ln lo lp lq lr ls lt lu in bi translated">以下代码跟踪每张卡片的拖动状态，并相应地更新SwiftUI <code class="fe lv lw lx ly b">body</code>:</p><pre class="kk kl km kn gu nv ly nw nx aw ny bi"><span id="0833" class="nz mw iu ly b gz oa ob l oc od">class SwipeObserver : ObservableObject{<br/>    <br/>    @Published<!-- --> var cards = [Cards]()<br/>    <br/>    init() {<br/>        <br/>        self.cards.append(Cards(id: 0, drag: 0, degree: 0, color: Color.purple))<br/>        //Skipping for brevity  <br/>    }<br/>    <br/>    func update(id : Cards,value : CGFloat,degree : Double){<br/>        <br/>        for i in 0..&lt;self.cards.count{<br/>            <br/>            if self.cards[i].id == id.id{<br/>                <br/>                self.cards[i].drag = value<br/>                self.cards[i].degree = degree<br/>            }<br/>        }<br/>    }<br/>}</span></pre><p id="1c3b" class="pw-post-body-paragraph kz la iu lb b lc ld jv le lf lg jy lh li lj lk ll lm ln lo lp lq lr ls lt lu in bi translated">每张卡都有阻力和度数状态:</p><pre class="kk kl km kn gu nv ly nw nx aw ny bi"><span id="1a75" class="nz mw iu ly b gz oa ob l oc od">struct Cards : Identifiable {</span><span id="0620" class="nz mw iu ly b gz os ob l oc od">var id : Int<br/>var drag : CGFloat<br/>var degree : Double<br/>var color : Color</span><span id="398a" class="nz mw iu ly b gz os ob l oc od">}</span></pre><p id="46d6" class="pw-post-body-paragraph kz la iu lb b lc ld jv le lf lg jy lh li lj lk ll lm ln lo lp lq lr ls lt lu in bi translated">因此，我们在应用程序中得到以下结果:</p><figure class="kk kl km kn gu ko gi gj paragraph-image"><div class="gi gj of"><img src="../Images/12450fea7c50a97d149e4b15480bbe2c.png" data-original-src="https://miro.medium.com/v2/resize:fit:506/1*zH7qAQ39A5mQ0D6pq9RsAw.gif"/></div></figure></div><div class="ab cl mo mp hy mq" role="separator"><span class="mr bw bk ms mt mu"/><span class="mr bw bk ms mt mu"/><span class="mr bw bk ms mt"/></div><div class="in io ip iq ir"><h1 id="8311" class="mv mw iu bd mx my mz na nb nc nd ne nf ka ng kb nh kd ni ke nj kg nk kh nl nm bi translated">结论</h1><p id="c93c" class="pw-post-body-paragraph kz la iu lb b lc nn jv le lf no jy lh li ns lk ll lm nt lo lp lq nu ls lt lu in bi translated">SwiftUI手势——以及动画和过渡——可以创建一些非常身临其境的用户体验。</p><p id="ca12" class="pw-post-body-paragraph kz la iu lb b lc ld jv le lf lg jy lh li lj lk ll lm ln lo lp lq lr ls lt lu in bi translated">我们使用了不同种类的手势，并看到了<code class="fe lv lw lx ly b">GestureState</code>在处理与指定视图的瞬时交互中所扮演的角色。随后，我们做了一个同时旋转和放大的复合手势。</p><p id="b329" class="pw-post-body-paragraph kz la iu lb b lc ld jv le lf lg jy lh li lj lk ll lm ln lo lp lq lr ls lt lu in bi translated">我们演示了可滑动的视图手势，就像在Tinder中做的那样，就像蛋糕上的糖衣一样。它的源代码可以在这个<a class="ae mi" href="https://github.com/anupamchugh/iowncode" rel="noopener ugc nofollow" target="_blank"> GitHub库</a>中找到。</p><p id="aebf" class="pw-post-body-paragraph kz la iu lb b lc ld jv le lf lg jy lh li lj lk ll lm ln lo lp lq lr ls lt lu in bi translated">这一次到此为止。我希望你喜欢SwiftUI视图的手势交互。</p></div></div>    
</body>
</html>