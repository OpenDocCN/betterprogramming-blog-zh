<html>
<head>
<title>Use Enums and Associated Values to Parse Polymorphic JSON in Swift</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用枚举和相关值解析Swift中的多态JSON</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/parse-items-with-different-key-value-pairs-in-a-json-array-with-the-help-of-enums-and-associated-301ffa81179e?source=collection_archive---------18-----------------------#2020-02-03">https://betterprogramming.pub/parse-items-with-different-key-value-pairs-in-a-json-array-with-the-help-of-enums-and-associated-301ffa81179e?source=collection_archive---------18-----------------------#2020-02-03</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="e628" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">解析多态项目</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/aea0891b1a4c8150ae564a4aa126a12f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*UFPiPGQ8lf5scIVjpQAmkg.jpeg"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated"><a class="ae ky" href="https://unsplash.com/@kyawthutun?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">觉吞</a>在<a class="ae ky" href="https://unsplash.com/s/photos/pair?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</p></figure><p id="54d8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">作为iOS开发人员，我们经常在应用程序中处理服务器响应和解析JSON。用Swift <code class="fe lv lw lx ly b">Codable</code> ( <code class="fe lv lw lx ly b">Decodable</code>和<code class="fe lv lw lx ly b">Encodable</code>)解析JSON肯定变得更容易了，但是在某些情况下，解析JSON可能会很棘手。</p><p id="870d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在本文中，我们将研究这样一个案例，并实现一个解决方案。</p></div><div class="ab cl lz ma hx mb" role="separator"><span class="mc bw bk md me mf"/><span class="mc bw bk md me mf"/><span class="mc bw bk md me"/></div><div class="im in io ip iq"><h1 id="18ea" class="mg mh it bd mi mj mk ml mm mn mo mp mq jz mr ka ms kc mt kd mu kf mv kg mw mx bi translated">了解我们的JSON</h1><pre class="kj kk kl km gt my ly mz na aw nb bi"><span id="cc4e" class="nc mh it ly b gy nd ne l nf ng">{<br/>    "items": [<br/>        {<br/>            "type": "square",<br/>            "side_length": 12<br/>        },<br/>        {<br/>            "type": "sphere",<br/>            "diameter": 4<br/>        },<br/>        {<br/>            "type": "cylinder",<br/>            "diameter": 4,<br/>            "height": 10<br/>        },<br/>        {<br/>            "type": "lalala",<br/>            "unknown_key": 0<br/>        }<br/>    ]<br/>}</span></pre><p id="6d03" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们来看看上面的JSON。它由几何对象类型的项目数组组成，如正方形、球体和圆柱体。对象的键值对互不相同，但是它们都有<code class="fe lv lw lx ly b">key</code>类型。</p><p id="8c27" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们如何解析这样的JSON——列表中提供的条目可能是不同的类型。我们能提供什么样的模式？</p><h2 id="5134" class="nc mh it bd mi nh ni dn mm nj nk dp mq li nl nm ms lm nn no mu lq np nq mw nr bi translated">实现模型</h2><p id="9d79" class="pw-post-body-paragraph kz la it lb b lc ns ju le lf nt jx lh li nu lk ll lm nv lo lp lq nw ls lt lu im bi translated">我们将借助带有关联值的枚举来实现它。让我们首先为每个形状创建一个模型，如下所示(我将从这些模型中排除type，因为稍后会用到它，但是您仍然可以在这些模型中包含type)。</p><pre class="kj kk kl km gt my ly mz na aw nb bi"><span id="ab23" class="nc mh it ly b gy nd ne l nf ng">struct Square: Decodable {<br/>    let sideLength: Int<br/>    <br/>    enum CodingKeys: String, CodingKey {<br/>        case sideLength = "side_length"<br/>    }<br/>}</span><span id="eefa" class="nc mh it ly b gy nx ne l nf ng">struct Sphere: Decodable {<br/>    let diameter: Int<br/>}</span><span id="712f" class="nc mh it ly b gy nx ne l nf ng">struct Cylinder: Decodable {<br/>    let diameter: Int<br/>    let height: Int<br/>}</span></pre><p id="3a95" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在，我们对JSON中提供的每个形状都有了一个模型。(<code class="fe lv lw lx ly b">Square</code>已经实现了<code class="fe lv lw lx ly b">CodingKeys</code>，因为<code class="fe lv lw lx ly b">sideLength</code>的键在JSON中写成了<code class="fe lv lw lx ly b">side_length</code>。)</p><p id="a1b0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们需要确定给定对象的类型，然后才能正确解码它，因此让我们创建一个枚举，如下所示:</p><pre class="kj kk kl km gt my ly mz na aw nb bi"><span id="a39e" class="nc mh it ly b gy nd ne l nf ng">enum ObjectType: String, Decodable {<br/>    case square<br/>    case sphere<br/>    case cylinder<br/>    case unknown<br/>    <br/>    init(from decoder: Decoder) throws {<br/>        let container = try decoder.singleValueContainer()<br/>        let type = try container.decode(String.self)<br/>        self = ObjectType(rawValue: type) ?? .unknown<br/>    }<br/>}</span></pre><p id="cf12" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在这里的<code class="fe lv lw lx ly b">ObjectType</code>枚举中，我们为每个条目准备了一个case，另外还有一个<code class="fe lv lw lx ly b">unknown</code> case，即使发送了一个<code class="fe lv lw lx ly b">unknown</code>类型，它仍然可以解析JSON。当在客户端更新之前在后端进行了更改时，这可能特别有用。</p><p id="b288" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">首先在单值容器的帮助下解码给定的字符串，然后用解码后的字符串的<code class="fe lv lw lx ly b">rawValue</code>初始化<code class="fe lv lw lx ly b">ObjectType</code>。如果给定的类型初始化失败，它被初始化为unknown(如果该类型不是enum的情况之一)。</p><h2 id="2132" class="nc mh it bd mi nh ni dn mm nj nk dp mq li nl nm ms lm nn no mu lq np nq mw nr bi translated">使用带有关联值的枚举分析不同的项类型</h2><p id="dcc2" class="pw-post-body-paragraph kz la it lb b lc ns ju le lf nt jx lh li nu lk ll lm nv lo lp lq nw ls lt lu im bi translated">我们已经到了这首曲子的关键部分。现在我们将实现一个符合<code class="fe lv lw lx ly b">Decodable</code>的名为<code class="fe lv lw lx ly b">Object</code>的枚举，包括所有形状的情况和一个额外的未知情况。</p><pre class="kj kk kl km gt my ly mz na aw nb bi"><span id="8de0" class="nc mh it ly b gy nd ne l nf ng">enum Object: Decodable {<br/>    case square(Square)<br/>    case sphere(Sphere)<br/>    case cylinder(Cylinder)<br/>    case unknown<br/>    <br/>    enum CodingKeys: String, CodingKey {<br/>        case type<br/>    }<br/>    <br/>    init(from decoder: Decoder) throws {<br/>        let container = try decoder.container(keyedBy: CodingKeys.self)<br/>        guard let type = try? container.decode(ObjectType.self, forKey: .type) else {<br/>            self = .unknown<br/>            return<br/>        }<br/>        <br/>        let objectContainer = try decoder.singleValueContainer()<br/>        <br/>        switch type {<br/>        case .square:<br/>            let square = try objectContainer.decode(Square.self)<br/>            self = .square(square)<br/>        case .sphere:<br/>            let sphere = try objectContainer.decode(Sphere.self)<br/>            self = .sphere(sphere)<br/>        case .cylinder:<br/>            let cylinder = try objectContainer.decode(Cylinder.self)<br/>            self = .cylinder(cylinder)<br/>        case .unknown:<br/>            self = .unknown<br/>        }<br/>    }<br/>}</span></pre><p id="ed83" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">只有一种<code class="fe lv lw lx ly b">CodingKey</code>型。首先确定类型并解析为<code class="fe lv lw lx ly b">ObjectType</code>。然后，根据类型使用单值容器解析实际形状。稍后，在初始化self时，这个解析的形状被用作关联值。</p><p id="2956" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">感谢<code class="fe lv lw lx ly b">Object</code>枚举，我们将能够解析一个条目列表，其中每个条目可以有不同的键值。只要我们有一个匹配<code class="fe lv lw lx ly b">key</code>类型的，在我们的例子中。)</p><p id="522d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们实现一个包装器模型<code class="fe lv lw lx ly b">GeometricShapes</code>，这样我们就可以测试解码将如何与我们的JSON一起工作:</p><pre class="kj kk kl km gt my ly mz na aw nb bi"><span id="88ed" class="nc mh it ly b gy nd ne l nf ng">struct GeometricShapes: Decodable {<br/>    let items: [Object]<br/>}</span></pre><p id="76d1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe lv lw lx ly b">GeometricShapes</code>仅由对象数组组成。</p><p id="b4db" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在我们将初始化<code class="fe lv lw lx ly b">data</code>作为我们的JSON:</p><pre class="kj kk kl km gt my ly mz na aw nb bi"><span id="00d6" class="nc mh it ly b gy nd ne l nf ng">let JSON = """<br/>    {<br/>        "items": [<br/>            {<br/>                "type": "square",<br/>                "side_length": 12<br/>            },<br/>            {<br/>                "type": "sphere",<br/>                "diameter": 4<br/>            },<br/>            {<br/>                "type": "cylinder",<br/>                "diameter": 4,<br/>                "height": 10<br/>            },<br/>            {<br/>                "type": "lalala",<br/>                "unknown_key": 0<br/>            }<br/>        ]<br/>    }<br/>""".data(using: .utf8)!</span></pre><p id="4d30" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们解析它:</p><pre class="kj kk kl km gt my ly mz na aw nb bi"><span id="fe65" class="nc mh it ly b gy nd ne l nf ng">let decoder = JSONDecoder()<br/>let geometricObjects = try decoder.decode(GeometricShapes.self, from: JSON)<br/>let items = geometricObjects.items</span><span id="aff5" class="nc mh it ly b gy nx ne l nf ng">// Here we just parse and print some values of the models.<br/>// This is how you can parse with a wrapper enum with associated value.<br/>items.forEach({<br/>    switch $0 {<br/>    case .cylinder(let cylinder):<br/>        print("Diameter of cylinder is: \(cylinder.diameter)")<br/>        print("Height of cylinder is: \(cylinder.height)")<br/>    case .sphere(let sphere):<br/>        print("Diameter of sphere is: \(sphere.diameter)")<br/>    case .square(let square):<br/>        print("Side length of square is: \(square.sideLength)")<br/>    case .unknown:<br/>        print("We have an unknown type.")<br/>    }<br/>})</span></pre><p id="1ece" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们执行以下操作:</p><ul class=""><li id="8480" class="ny nz it lb b lc ld lf lg li oa lm ob lq oc lu od oe of og bi translated">首先，我们得到一个<code class="fe lv lw lx ly b">Decoder</code>并将我们的数据解析为一个<code class="fe lv lw lx ly b">GeometricShape</code>模型</li><li id="3a9a" class="ny nz it lb b lc oh lf oi li oj lm ok lq ol lu od oe of og bi translated">用模型的项目创建一个名为items的常数</li><li id="014f" class="ny nz it lb b lc oh lf oi li oj lm ok lq ol lu od oe of og bi translated">通过切换来解析数组中的每一项</li><li id="4565" class="ny nz it lb b lc oh lf oi li oj lm ok lq ol lu od oe of og bi translated">根据项目类型打印每个项目的属性</li></ul><p id="6ba3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我只运行了一个<code class="fe lv lw lx ly b">for each</code>循环来展示如何用枚举和相关值解析每个元素。您可以使用相同的方法进行解析，然后根据类型初始化一些UI组件，或者创建一些数据源。解析完JSON后做什么都行。</p></div><div class="ab cl lz ma hx mb" role="separator"><span class="mc bw bk md me mf"/><span class="mc bw bk md me mf"/><span class="mc bw bk md me"/></div><div class="im in io ip iq"><h2 id="b016" class="nc mh it bd mi nh ni dn mm nj nk dp mq li nl nm ms lm nn no mu lq np nq mw nr bi translated">结论</h2><p id="483e" class="pw-post-body-paragraph kz la it lb b lc ns ju le lf nt jx lh li nu lk ll lm nv lo lp lq nw ls lt lu im bi translated">在本文中，我们已经看到了在解析JSON时，带有关联值的枚举是如何派上用场的。重要的是要记住，即使每一项都不同，它们至少应该有一个相同的键，这样我们才能知道应该为JSON数组中的特定项初始化哪个模型。</p><p id="05c3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我希望你喜欢这篇文章，它可能是有用的。你可以在这里找到操场要诀<a class="ae ky" href="https://gist.github.com/emrepun/0f2d76ffdedce26fc2dec95dfe037347" rel="noopener ugc nofollow" target="_blank">。</a></p></div></div>    
</body>
</html>