<html>
<head>
<title>Host a Local Folder of Web Dev Files Directly in the Browser Using TypeScript and Svelte</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用TypeScript和Svelte在浏览器中直接托管Web Dev文件的本地文件夹</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/host-a-local-folder-of-web-dev-files-directly-in-the-browser-using-typescript-and-svelte-397c113a8bf8?source=collection_archive---------20-----------------------#2022-02-01">https://betterprogramming.pub/host-a-local-folder-of-web-dev-files-directly-in-the-browser-using-typescript-and-svelte-397c113a8bf8?source=collection_archive---------20-----------------------#2022-02-01</a></blockquote><div><div class="fc ii ij ik il im"/><div class="in io ip iq ir"><div class=""/><div class=""><h2 id="21ce" class="pw-subtitle-paragraph jr it iu bd b js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki dk translated">为你的浏览器提供一个本地文件夹</h2></div><figure class="kk kl km kn gu ko gi gj paragraph-image"><div role="button" tabindex="0" class="kp kq di kr bf ks"><div class="gi gj kj"><img src="../Images/43989906362839d13bd94e4a05bc460f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*hpvbgHk2Gs_jgOOY"/></div></div><p class="kv kw gk gi gj kx ky bd b be z dk translated">由<a class="ae kz" href="https://unsplash.com/@brlimaproj?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">大卫·布鲁诺·席尔瓦</a>在<a class="ae kz" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>拍摄的照片</p></figure><p id="92f5" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">我在<a class="ae kz" href="https://javascript.plainenglish.io/the-journey-of-a-novice-programmer-82366ec7851a" rel="noopener ugc nofollow" target="_blank"> gest-dashboard </a>项目中遇到的困难之一是如何在浏览器中查看文件夹。或者说，如何使用包含本地保存的HTML文件的文件夹。只要它们是简单的文件，这就不是问题。当涉及到更复杂的web应用程序时，它变得更加困难。我试过两种解决方案。第一个是使用Node.js的<code class="fe lw lx ly lz b"><a class="ae kz" href="https://nodejs.org/api/http.html#httpcreateserveroptions-requestlistener" rel="noopener ugc nofollow" target="_blank">http.createServer([options][, requestListener])</a></code>。然而，这增加了我的项目的复杂性。</p><p id="9f6e" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">然后，<a class="ae kz" href="https://www.construct.net/en/blogs/ashleys-blog-2" rel="noopener ugc nofollow" target="_blank">阿什利·古伦</a>发了一个非常<a class="ae kz" href="https://github.com/AshleyScirra/servefolder.dev" rel="noopener ugc nofollow" target="_blank">有趣的知识库</a>:</p><pre class="kk kl km kn gu ma lz mb mc aw md bi"><span id="20a5" class="me mf iu lz b gz mg mh l mi mj">The page at servefolder.dev lets you host a local folder with web development files, such as HTML, JavaScript and CSS, directly in your browser. It works using Service Workers: everything is served from your local system only, nothing is uploaded to a server, and your files are not shared with anybody else.</span></pre><p id="7610" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">换句话说，我直接在浏览器中创建了一个本地服务器，我可以用它来查看我的文件夹，就像它们在线一样。但是不在线。</p><p id="a063" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">从这个库开始，我创建了我的版本，苗条服务文件夹:</p><figure class="kk kl km kn gu ko gi gj paragraph-image"><div role="button" tabindex="0" class="kp kq di kr bf ks"><div class="gi gj mk"><img src="../Images/3ad01a5ea37c7d1a04c336ebbe810c57.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*5JkiSYr1Odu_98lX.gif"/></div></div></figure><p id="9156" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">显然，最初的想法不是我的，我建议直接咨询Ashley的知识库。它的代码信息量很大。如此有教育意义，学习它是必要的。所以，在这篇文章中，我将报告我的笔记和我所理解的。我将通过重新创建原始存储库来实现这一点，只做一些更改:</p><ol class=""><li id="cc13" class="ml mm iu lc b ld le lg lh lj mn ln mo lr mp lv mq mr ms mt bi translated">我将尽可能使用用<a class="ae kz" href="https://www.typescriptlang.org/" rel="noopener ugc nofollow" target="_blank"> TypeScript </a>编写的代码:我已经注意到将来查阅TS代码对我来说更容易；</li><li id="db76" class="ml mm iu lc b ld mu lg mv lj mw ln mx lr my lv mq mr ms mt bi translated">在可能的情况下，我会使用<a class="ae kz" href="https://svelte.dev/" rel="noopener ugc nofollow" target="_blank"> Svelte </a>:在这种情况下，这不是必须的，但我计划用Svelte重用我在其他项目中学到的东西；</li><li id="272c" class="ml mm iu lc b ld mu lg mv lj mw ln mx lr my lv mq mr ms mt bi translated">我添加了通过一个<a class="ae kz" href="https://developer.mozilla.org/en-US/docs/Web/HTML/Element/iframe" rel="noopener ugc nofollow" target="_blank"> iframe </a>直接在主页上查看文件夹内容的功能:在这种情况下，我需要了解如何将这种技术集成到<a class="ae kz" rel="noopener ugc nofollow" target="_blank" href="/how-to-use-browserview-with-electron-9998fa834b44"> Electron的浏览器视图中</a></li></ol><p id="d7fd" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">有一点我不会用的是<a class="ae kz" href="https://github.com/rollup/plugins/tree/master/packages/html" rel="noopener ugc nofollow" target="_blank"> @rollup/plugin-html </a>创建html模板。但是我想在接下来的几天里考虑一下。</p></div><div class="ab cl mz na hy nb" role="separator"><span class="nc bw bk nd ne nf"/><span class="nc bw bk nd ne nf"/><span class="nc bw bk nd ne"/></div><div class="in io ip iq ir"><h1 id="4951" class="ng mf iu bd nh ni nj nk nl nm nn no np ka nq kb nr kd ns ke nt kg nu kh nv nw bi translated">JavaScript服务工作者</h1><p id="39a6" class="pw-post-body-paragraph la lb iu lc b ld nx jv lf lg ny jy li lj nz ll lm ln oa lp lq lr ob lt lu lv in bi translated">目前，我不考虑图形方面，而把重点放在服务人员上。如果你从未使用过它们，这就是我的情况，首先要做的是理解它们是什么。幸运的是，在Mozilla.org上你可以找到你需要的所有信息。所以，首先要做的是查看这个网站:</p><ul class=""><li id="ff24" class="ml mm iu lc b ld le lg lh lj mn ln mo lr mp lv oc mr ms mt bi translated"><a class="ae kz" href="https://developer.mozilla.org/en-US/docs/Web/API/Service_Worker_API" rel="noopener ugc nofollow" target="_blank">服务工作者API </a> —简而言之，服务工作者的目的是在浏览器托管的页面和生成页面的服务器之间建立一座桥梁。它们通常用于允许站点脱机工作，并在后台管理通知和操作。它们不能直接访问HTML页面(所谓的DOM)，它们是完全异步的，并且在浏览器处于匿名模式时不起作用。他们需要HTTPS的连接。</li></ul><p id="dc4c" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">使用需要一些强制性的步骤:</p><ul class=""><li id="8536" class="ml mm iu lc b ld le lg lh lj mn ln mo lr mp lv oc mr ms mt bi translated">每个服务人员必须首先通过<code class="fe lw lx ly lz b"><a class="ae kz" href="https://developer.mozilla.org/en-US/docs/Web/API/ServiceWorkerContainer/register" rel="noopener ugc nofollow" target="_blank">ServiceWorkerContainer.register()</a></code>方法注册</li><li id="e891" class="ml mm iu lc b ld mu lg mv lj mw ln mx lr my lv oc mr ms mt bi translated">然后下载服务人员:这是一个自动过程，不需要用户采取任何行动</li><li id="4e17" class="ml mm iu lc b ld mu lg mv lj mw ln mx lr my lv oc mr ms mt bi translated">下载后，是时候安装它了:这个动作也是自动的，但在某些情况下，强制安装会更好。在这个项目中，Ashley使用了[ <code class="fe lw lx ly lz b"><a class="ae kz" href="https://developer.mozilla.org/en-US/docs/Web/API/ServiceWorkerGlobalScope/skipWaiting" rel="noopener ugc nofollow" target="_blank">ServiceWorkerGlobalScope.skipWaiting()</a></code> ]和<code class="fe lw lx ly lz b"><a class="ae kz" href="https://developer.mozilla.org/en-US/docs/Web/API/Clients/claim" rel="noopener ugc nofollow" target="_blank">Clients.claim()</a></code>方法，这是一个很好的解决方案</li><li id="06f8" class="ml mm iu lc b ld mu lg mv lj mw ln mx lr my lv oc mr ms mt bi translated">最后，还有<a class="ae kz" href="https://developer.mozilla.org/en-US/docs/Web/API/ServiceWorkerGlobalScope/activate_event" rel="noopener ugc nofollow" target="_blank">激活</a>事件(可以被拦截和管理)</li></ul></div><div class="ab cl mz na hy nb" role="separator"><span class="nc bw bk nd ne nf"/><span class="nc bw bk nd ne nf"/><span class="nc bw bk nd ne"/></div><div class="in io ip iq ir"><h1 id="0d06" class="ng mf iu bd nh ni nj nk nl nm nn no np ka nq kb nr kd ns ke nt kg nu kh nv nw bi translated">如何用JavaScript安装服务人员</h1><p id="210b" class="pw-post-body-paragraph la lb iu lc b ld nx jv lf lg ny jy li lj nz ll lm ln oa lp lq lr ob lt lu lv in bi translated">一小段代码。用JavaScript注册服务人员很简单:</p><figure class="kk kl km kn gu ko"><div class="bz fq l di"><div class="od oe l"/></div></figure><p id="62db" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">将<code class="fe lw lx ly lz b">sw.js</code>文件(带有服务人员代码的文件)保存在根文件夹中是一个好主意:这将使您的生活变得容易得多。</p><p id="eee2" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">在<code class="fe lw lx ly lz b">sw.js</code>中，我添加了一个安装触发事件:</p><figure class="kk kl km kn gu ko"><div class="bz fq l di"><div class="od oe l"/></div></figure><p id="c20b" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">另一个由激活触发:</p><figure class="kk kl km kn gu ko"><div class="bz fq l di"><div class="od oe l"/></div></figure><p id="cec4" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">所以我安装了服务人员。但是如何使用它们呢？</p></div><div class="ab cl mz na hy nb" role="separator"><span class="nc bw bk nd ne nf"/><span class="nc bw bk nd ne nf"/><span class="nc bw bk nd ne"/></div><div class="in io ip iq ir"><h1 id="c25a" class="ng mf iu bd nh ni nj nk nl nm nn no np ka nq kb nr kd ns ke nt kg nu kh nv nw bi translated">使用文件系统访问API选择文件夹</h1><p id="4322" class="pw-post-body-paragraph la lb iu lc b ld nx jv lf lg ny jy li lj nz ll lm ln oa lp lq lr ob lt lu lv in bi translated">嗯，就是这个想法。可以将本地文件夹的内容存储在内存中，而不是离线保存站点代码(或仅保存站点代码)。这样，当我们试图访问它时，它看起来就像是虚拟服务器上的一个文件。</p><p id="ddd7" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">简而言之:我们可以让浏览器相信这个文件夹不在本地，而是由本地服务人员保存的远程文件夹。</p><p id="3a2a" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">我可以在完全离线的环境下使用web应用程序吗:</p><figure class="kk kl km kn gu ko gi gj paragraph-image"><div role="button" tabindex="0" class="kp kq di kr bf ks"><div class="gi gj of"><img src="../Images/b0e9012a6dcc9ffcf123423099a089c7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*b753d4l_IcMM64ay.gif"/></div></div></figure><p id="139e" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">显然，我们需要一种方法来允许文件从磁盘传递给服务人员。在这种情况下，<a class="ae kz" href="https://developer.mozilla.org/en-US/docs/Web/API/File_System_Access_API" rel="noopener ugc nofollow" target="_blank">文件系统访问API </a>非常优秀。</p><p id="a005" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">然后我创建了一个<code class="fe lw lx ly lz b">pickFolder</code>功能来选择pc上的一个文件夹。</p><figure class="kk kl km kn gu ko"><div class="bz fq l di"><div class="od oe l"/></div></figure><p id="7a66" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">得到文件夹后，我需要一种方法来通知服务人员我的选择。我使用了一个<code class="fe lw lx ly lz b">postToSW</code>函数:</p><figure class="kk kl km kn gu ko"><div class="bz fq l di"><div class="od oe l"/></div></figure><p id="6f4c" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">现在，我可以从HTML页面向服务人员发送消息。但是我需要给<code class="fe lw lx ly lz b">sw.js</code>文件添加一个函数:</p><figure class="kk kl km kn gu ko"><div class="bz fq l di"><div class="od oe l"/></div></figure><p id="5adc" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">但是如果服务工作器还没有初始化呢？</p><p id="e965" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">阿什利提出了一个优雅的解决方案，我花了一些时间才想出来。它由两个功能组成。第一种是创建一个计时器来等待必要的时间:</p><figure class="kk kl km kn gu ko"><div class="bz fq l di"><div class="od oe l"/></div></figure><p id="0ef2" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">然后，我需要<code class="fe lw lx ly lz b"><a class="ae kz" href="https://developer.mozilla.org/en-US/docs/Web/API/ServiceWorkerContainer/oncontrollerchange" rel="noopener ugc nofollow" target="_blank">ServiceWorkerContainer.oncontrollerchange</a></code>属性在服务工作者接收新的活动工作者时进行拦截:</p><figure class="kk kl km kn gu ko"><div class="bz fq l di"><div class="od oe l"/></div></figure><p id="f216" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">现在，我有了创建一个函数的所有工具，可以从pc上选择一个文件夹并通知服务人员:</p><figure class="kk kl km kn gu ko"><div class="bz fq l di"><div class="od oe l"/></div></figure><p id="2c4f" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">稍后，您可以在HTML页面中使用所有这些内容。在我的例子中，我创建了<code class="fe lw lx ly lz b">App.svelte</code>文件:</p><figure class="kk kl km kn gu ko"><div class="bz fq l di"><div class="od oe l"/></div></figure></div><div class="ab cl mz na hy nb" role="separator"><span class="nc bw bk nd ne nf"/><span class="nc bw bk nd ne nf"/><span class="nc bw bk nd ne"/></div><div class="in io ip iq ir"><h1 id="6ed0" class="ng mf iu bd nh ni nj nk nl nm nn no np ka nq kb nr kd ns ke nt kg nu kh nv nw bi translated">像在服务器上一样打开文件夹</h1><p id="83e0" class="pw-post-body-paragraph la lb iu lc b ld nx jv lf lg ny jy li lj nz ll lm ln oa lp lq lr ob lt lu lv in bi translated">总之，目前我可以从pc上选择一个文件夹，然后通知服务人员。但是接下来会发生什么呢？嗯，我需要一个<code class="fe lw lx ly lz b">StartHost(e)</code>函数:</p><figure class="kk kl km kn gu ko"><div class="bz fq l di"><div class="od oe l"/></div></figure><p id="ecd2" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">这允许我通过传递主机名和客户机id来回复HTML页面。我可以使用这些信息来创建一个按钮:</p><figure class="kk kl km kn gu ko"><div class="bz fq l di"><div class="od oe l"/></div></figure><p id="648a" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">当我点击按钮时，一个新的页面打开了。但显然页面什么都没有。我需要在<code class="fe lw lx ly lz b">sw.js</code>中添加一个特定的函数:</p><figure class="kk kl km kn gu ko"><div class="bz fq l di"><div class="od oe l"/></div></figure><p id="e4e2" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">现在我必须回到主页。我为<code class="fe lw lx ly lz b">fetch</code>事件添加了一个事件监听器</p><figure class="kk kl km kn gu ko"><div class="bz fq l di"><div class="od oe l"/></div></figure><p id="5a7c" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">然后我创建了<code class="fe lw lx ly lz b">handleFetch</code>函数:</p><figure class="kk kl km kn gu ko"><div class="bz fq l di"><div class="od oe l"/></div></figure><p id="6002" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated"><code class="fe lw lx ly lz b">generateDirectoryListing</code>函数创建一个包含文件和文件夹列表的HTML页面。</p><figure class="kk kl km kn gu ko"><div class="bz fq l di"><div class="od oe l"/></div></figure><p id="25eb" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">阿什利·古伦的功能相当基础。在我的版本中，我做了一点改动，但都是细节。</p></div><div class="ab cl mz na hy nb" role="separator"><span class="nc bw bk nd ne nf"/><span class="nc bw bk nd ne nf"/><span class="nc bw bk nd ne"/></div><div class="in io ip iq ir"><h1 id="bd0c" class="ng mf iu bd nh ni nj nk nl nm nn no np ka nq kb nr kd ns ke nt kg nu kh nv nw bi translated">在iframe中显示结果</h1><p id="5d3d" class="pw-post-body-paragraph la lb iu lc b ld nx jv lf lg ny jy li lj nz ll lm ln oa lp lq lr ob lt lu lv in bi translated">此存储库的原始版本是在另一个浏览器选项卡中打开上传的文件夹。在我的版本中，我增加了在同一页面上直接查看内容的功能。只需使用一个<code class="fe lw lx ly lz b">iframe</code>元素并输入相应的URL:</p><figure class="kk kl km kn gu ko"><div class="bz fq l di"><div class="od oe l"/></div></figure><p id="aaef" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">好了，暂时就这些了。还有许多其他有趣的细节，但这些都是基本概念。我再次建议参考原始存储库:</p><div class="og oh gq gs oi oj"><a href="https://github.com/AshleyScirra/servefolder.dev" rel="noopener  ugc nofollow" target="_blank"><div class="ok ab fp"><div class="ol ab om cl cj on"><h2 class="bd iv gz z fq oo fs ft op fv fx it bi translated">GitHub-Ashley scirra/Serve folder . dev:在您的浏览器中提供一个文件的本地文件夹，以便于…</h2><div class="oq l"><h3 class="bd b gz z fq oo fs ft op fv fx dk translated">在您的浏览器中提供一个本地文件夹，以便在不运行服务器的情况下进行测试。- GitHub …</h3></div><div class="or l"><p class="bd b dl z fq oo fs ft op fv fx dk translated">github.com</p></div></div><div class="os l"><div class="ot l ou ov ow os ox kt oj"/></div></div></a></div><p id="598a" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">我的版本:</p><div class="og oh gq gs oi oj"><a href="https://github.com/el3um4s/svelte-server-folder" rel="noopener  ugc nofollow" target="_blank"><div class="ok ab fp"><div class="ol ab om cl cj on"><h2 class="bd iv gz z fq oo fs ft op fv fx it bi translated">GitHub-El 3um 4s/svelte-server-folder:浏览器中的服务器文件夹</h2><div class="oq l"><h3 class="bd b gz z fq oo fs ft op fv fx dk translated">在浏览器中提供文件夹。在GitHub上创建一个帐户，为el3um4s/svelte-server-folder开发做贡献。</h3></div><div class="or l"><p class="bd b dl z fq oo fs ft op fv fx dk translated">github.com</p></div></div><div class="os l"><div class="oy l ou ov ow os ox kt oj"/></div></div></a></div></div><div class="ab cl mz na hy nb" role="separator"><span class="nc bw bk nd ne nf"/><span class="nc bw bk nd ne nf"/><span class="nc bw bk nd ne"/></div><div class="in io ip iq ir"><p id="4fe2" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">感谢阅读！敬请关注更多内容。</p></div><div class="ab cl mz na hy nb" role="separator"><span class="nc bw bk nd ne nf"/><span class="nc bw bk nd ne nf"/><span class="nc bw bk nd ne"/></div><div class="in io ip iq ir"><p id="9ef0" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated"><strong class="lc iv"> <em class="oz">不要错过我的下一篇文章—报名我的</em> </strong> <a class="ae kz" href="https://medium.com/subscribe/@el3um4s" rel="noopener"> <strong class="lc iv"> <em class="oz">中邮箱列表</em> </strong> </a></p><div class="og oh gq gs oi oj"><a href="https://el3um4s.medium.com/membership" rel="noopener follow" target="_blank"><div class="ok ab fp"><div class="ol ab om cl cj on"><h2 class="bd iv gz z fq oo fs ft op fv fx it bi translated">通过我的推荐链接加入Medium—Samuele</h2><div class="oq l"><h3 class="bd b gz z fq oo fs ft op fv fx dk translated">阅读萨缪尔的每一个故事(以及媒体上成千上万的其他作家)。不是中等会员？在这里加入一块…</h3></div><div class="or l"><p class="bd b dl z fq oo fs ft op fv fx dk translated">el3um4s.medium.com</p></div></div><div class="os l"><div class="pa l ou ov ow os ox kt oj"/></div></div></a></div><p id="185a" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated"><em class="oz">最初发表于</em><a class="ae kz" href="https://blog.stranianelli.com/how-to-serve-a-local-folder-of-files-in-your-browser/" rel="noopener ugc nofollow" target="_blank"><em class="oz">https://blog.stranianelli.com</em></a></p></div><div class="ab cl mz na hy nb" role="separator"><span class="nc bw bk nd ne nf"/><span class="nc bw bk nd ne nf"/><span class="nc bw bk nd ne"/></div><div class="in io ip iq ir"><h1 id="8e1c" class="ng mf iu bd nh ni nj nk nl nm nn no np ka nq kb nr kd ns ke nt kg nu kh nv nw bi translated">进一步阅读</h1><ul class=""><li id="aeed" class="ml mm iu lc b ld nx lg ny lj pb ln pc lr pd lv oc mr ms mt bi translated">在完成这篇文章后，我还发现了一个由韩写的很好的故事</li></ul></div></div>    
</body>
</html>