<html>
<head>
<title>Analyzing 3 Ways to Run Batch Tasks in Parallel Using TypeScript</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">分析使用TypeScript并行运行批处理任务的3种方式</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/several-variations-on-how-to-batch-run-tasks-in-parallel-tasks-grinding-ecf8324ddca3?source=collection_archive---------1-----------------------#2021-12-12">https://betterprogramming.pub/several-variations-on-how-to-batch-run-tasks-in-parallel-tasks-grinding-ecf8324ddca3?source=collection_archive---------1-----------------------#2021-12-12</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="22ac" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">看看如何并行批量运行任务的变化</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/9bda63b936d137db69512d8c9a7275eb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*1kZCj4EqlZFnXsKxyXLGSA.jpeg"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">任务研磨。来源:https://coffeeaffection.com/best-coffee-grinders/</p></figure><p id="8dc1" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我在许多变体上多次遇到批处理执行问题。或许，你也会。这是最有趣的问题之一，应该在技术层面而不是在面试中解决。</p><p id="a00e" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">有些语言，比如Java，让生活变得更容易，而其他语言却让生活变得更困难。在这篇文章中，我将使用Typescript讨论这个问题。</p><h1 id="9f52" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated"><strong class="ak">问题</strong></h1><p id="49de" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">给定一组要在有限资源下执行的任务，批处理执行这些任务的最佳方式是什么，在任务完成执行后，一个新的挂起任务会替换它？</p><h2 id="7baa" class="mp lt iq bd lu mq mr dn ly ms mt dp mc lf mu mv me lj mw mx mg ln my mz mi na bi translated"><strong class="ak">用例</strong></h2><ol class=""><li id="109b" class="nb nc iq ky b kz mk lc ml lf nd lj ne ln nf lr ng nh ni nj bi translated">您有许多SQL查询要通过具有有限会话的JDBC来执行。</li><li id="86f0" class="nb nc iq ky b kz nk lc nl lf nm lj nn ln no lr ng nh ni nj bi translated">您希望使用重试机制来批量运行任务</li><li id="f4bc" class="nb nc iq ky b kz nk lc nl lf nm lj nn ln no lr ng nh ni nj bi translated">任务之间存在依赖关系。</li></ol><h1 id="11a6" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated"><strong class="ak">解决方案</strong></h1><p id="1f5e" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">解决方案的复杂性随着任务定义的复杂性而增加。如果所有的任务消耗相同的时间，下一个解决方案是最简单的。</p><h2 id="7506" class="mp lt iq bd lu mq mr dn ly ms mt dp mc lf mu mv me lj mw mx mg ln my mz mi na bi translated"><strong class="ak">解决方案#1 </strong></h2><p id="ab0e" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">一个简单的解决方案是将这些任务分成组，然后一个组接一个组地同步执行，同时执行组中的任务。当当前组中的所有任务都被执行后，下一个组就会进入。</p><p id="5b9e" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">让我们用一个简单的问题来演示这个解决方案——给定10个任务，其中每个任务的本质消耗恒定的时间。我们希望一次批量运行3个任务。</p><p id="b10d" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">任务的定义如下所示:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="np nq l"/></div></figure><p id="a621" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们希望按如下方式批量运行这些任务:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="np nq l"/></div></figure><p id="ed68" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">任务执行者很简单:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="np nq l"/></div></figure><p id="bd36" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这个解决方案很简洁。输出如下所示:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="np nq l"/></div></figure><h2 id="cf62" class="mp lt iq bd lu mq mr dn ly ms mt dp mc lf mu mv me lj mw mx mg ln my mz mi na bi translated"><strong class="ak">弊端</strong></h2><p id="aa5b" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">如果其中一项任务提前完成了呢？</p><p id="f8ce" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">此解决方案不会用未完成的任务替换已完成的任务。那是浪费时间。</p><p id="df8d" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">因此，当任务运行时间变化时，解决方案#2就派上了用场。</p><h2 id="8484" class="mp lt iq bd lu mq mr dn ly ms mt dp mc lf mu mv me lj mw mx mg ln my mz mi na bi translated"><strong class="ak">解决方案2 </strong></h2><p id="3957" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">就像研磨机一样，每次一颗豆子被碾碎，另一颗豆子就会取代它。考虑到研磨机，如何创建几个工人。每个工作者从队列中取出一个任务并执行它。</p><p id="e780" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">完成后，工作线程要么接受下一个任务，要么在任务失败时将其排队。重试机制可能会成为该解决方案的障碍。因此，让我们在没有任何重试机制的情况下解决它。</p><h2 id="a4e1" class="mp lt iq bd lu mq mr dn ly ms mt dp mc lf mu mv me lj mw mx mg ln my mz mi na bi translated"><strong class="ak">用例</strong></h2><p id="fe42" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">如果任务的运行时间不同，第一种解决方案就不起作用。这个解决方案将解决这个问题。让我们首先创建我们的任务:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="np nq l"/></div></figure><p id="254e" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们有随机运行时间在1到30毫秒之间的任务。</p><p id="1bf8" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们想用4名工人完成10项任务。每个工人的指数在1到4之间。工作线程循环运行，直到任务队列为空:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="np nq l"/></div></figure><p id="ccde" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">使用<code class="fe nr ns nt nu b">Promise.all</code>触发一次工人:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="np nq l"/></div></figure><p id="177c" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">运行此示例后，输出将是:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="np nq l"/></div></figure><h2 id="ccd7" class="mp lt iq bd lu mq mr dn ly ms mt dp mc lf mu mv me lj mw mx mg ln my mz mi na bi translated"><strong class="ak">弊端</strong></h2><ul class=""><li id="3ce1" class="nb nc iq ky b kz mk lc ml lf nd lj ne ln nf lr nv nh ni nj bi translated"><strong class="ky ir">更新待定任务</strong>:代码很简单。但是，如果我们想要将新的或失败的任务添加回队列，我们可能需要雇用新的工作人员，而不是任何退休的工作人员，这样我们就能跟上预期的批处理水平。这是一个不太吸引人的解决方案，因为它需要额外的管理来跟上预期的水平。每个工人退休时都需要通知，每个雇佣的工人都需要登记，以保持批量平衡。</li><li id="a78c" class="nb nc iq ky b kz nk lc nl lf nm lj nn ln no lr nv nh ni nj bi translated"><strong class="ky ir">依赖</strong>:如果任务之间有依赖关系怎么办？确定一个恒定的工作人员数量并不是依赖关系的正确解决方案。例如，如果我们在任务和第一层上运行拓扑排序，我们有一个任务，其余的都依赖于它。在这种情况下，创建几个工人，其中只有一个实际上在工作，而其他人都被锁定等待该工人完成，这是疯狂和糟糕的行为。</li></ul><h2 id="8db9" class="mp lt iq bd lu mq mr dn ly ms mt dp mc lf mu mv me lj mw mx mg ln my mz mi na bi translated"><strong class="ak">解决方案3 </strong></h2><p id="e5d7" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">我记得我第一次不得不解决这个问题是在我为亚马逊工作的时候。我的任务是设计和实现一个搜索结果的排名模型。搜索结果将经过排序过程。一些进程相互依赖，而一些进程可以并行运行。在我的设计中，我使用了观察者设计模式。</p><p id="b09f" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">其思想是对任务进行拓扑排序，每当一个任务或一组任务完成执行时，它将发布一个主题来通知。我用Java实现了这个机制。我依赖于<code class="fe nr ns nt nu b">Completablefuture</code> <em class="nw"> </em>,所以任务会将自己锁定在先决条件主题上，直到它们被发布，然后它会继续执行。</p><p id="030b" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">允许我吹嘘一下。我真的为这个结果感到骄傲。我的设计文件是一个杰作，工作计划是100%准确的，周围都是干扰。对我来说这是一个成功，我付出了如此多的努力，让我相信了自己的能力。</p><h2 id="aec0" class="mp lt iq bd lu mq mr dn ly ms mt dp mc lf mu mv me lj mw mx mg ln my mz mi na bi translated"><strong class="ak">弊端</strong></h2><p id="a75d" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">当执行计划定义良好时，这个解决方案是完美的。然而，如果需要添加新的任务或FIFO模式中的重试机制，这将需要管理开销。</p><p id="6732" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">当任务之间没有依赖关系并且任务队列不稳定时，我们无法实现这个解决方案。在这种情况下，我们可能很容易造成饥饿。一个任务可能会失败，由于无望的重试，它的后续任务将需要挂起。在此等待时间内，当有一个等待的后继任务正在等待执行时，其余的任务可能已经完成。</p><p id="4c6d" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">饥饿的缺点可以通过消除由单个订户订阅每个主题的连锁思想来解决。一旦任务完成执行，它从挂起组中选择一个任务并触发它。一旦触发发生，第一个任务生命周期就结束了。这类似于没有环路的第二种解决方案。</p><h1 id="d6b1" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated"><strong class="ak">总结</strong></h1><p id="167b" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">我介绍了批处理运行问题的各种组合，重点是技术解决方法，而不是理论方法。技术方法最适合程序员的日常任务，而理论方法用于面试。</p><p id="4b85" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">如果你想看看代码，请访问我的<a class="ae kv" href="https://github.com/exhesham/batch-run/blob/main/main.ts" rel="noopener ugc nofollow" target="_blank">库这里</a>。</p><p id="2290" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">代码可能不是有限的。</p></div></div>    
</body>
</html>