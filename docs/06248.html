<html>
<head>
<title>A Beginner’s Guide to Big O Notation (Part 1)</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">大O符号初学者指南(第1部分)</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/a-beginners-guide-to-big-o-notation-pt-1-19ec031b698b?source=collection_archive---------8-----------------------#2020-09-14">https://betterprogramming.pub/a-beginners-guide-to-big-o-notation-pt-1-19ec031b698b?source=collection_archive---------8-----------------------#2020-09-14</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="3310" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">借助《料理鼠王》介绍时间复杂性</h2></div><p id="d93c" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">当我们编写代码时，理解我们对代码的选择如何影响我们正在创建的程序的速度和性能是很重要的。大O符号是一种对算法的运行时间/操作数或空间相对于输入<code class="fe le lf lg lh b">n</code>增加的速度进行分类的方法。它着眼于最坏的情况，假设在编写算法时触及了所有可能的元素。</p><p id="6acc" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在Big O符号中有七个分类，从奇妙的、快速的和/或节省空间的解决方案(不管输入大小如何都保持不变)到绝对糟糕的<em class="li">请不要使用这些</em>解决方案！</p><figure class="lk ll lm ln gt lo gh gi paragraph-image"><div role="button" tabindex="0" class="lp lq di lr bf ls"><div class="gh gi lj"><img src="../Images/d13e82d9171e032f3af066fd3a938c7c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*5VctXSES5PrSk-5lPb_CCg.jpeg"/></div></div></figure><p id="0cb4" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">了解不同的数据结构和算法如何适应这种大的复杂性梯度，可以帮助您选择正确的数据结构和算法，并在工作中优化您的代码——或者在技术编码面试中。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="5473" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">O(1)常数时间</h1><p id="17aa" class="pw-post-body-paragraph ki kj it kk b kl mu ju kn ko mv jx kq kr mw kt ku kv mx kx ky kz my lb lc ld im bi translated">让我们假设你是厨师雷米，你被要求做你的世界著名的杂烩。</p><figure class="lk ll lm ln gt lo gh gi paragraph-image"><div class="gh gi mz"><img src="../Images/1c95df6cb27bf57a8ea7953dd027398d.png" data-original-src="https://miro.medium.com/v2/resize:fit:960/format:webp/1*EnrJBWL_vgIzr3IvfuWnag.jpeg"/></div><p class="na nb gj gh gi nc nd bd b be z dk translated">好吃！图片来源:皮克斯</p></figure><p id="0cec" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">你要做的第一件事是收集配料、香料和香草来准备这道菜。厨房是你的第二个家，你知道在哪里可以找到你需要的一切:</p><pre class="lk ll lm ln gt ne lh nf ng aw nh bi"><span id="ed27" class="ni md it lh b gy nj nk l nl nm">let kitchen = {<br/>    vegetables: {<br/>        broccoli: {name: "broccoli", ...}, <br/>        zucchini: {name: "zucchini", ...}, <br/>        eggplant: {name: "eggplant", ...}, <br/>        carrot: {name: "carrot", ...}, <br/>        squash: {name: "squash", ...}, <br/>        tomato: {name: "tomato", ...}, <br/>        radish: {name: "radish", ...}, <br/>        cabbage: {name: "cabbage", ...}, <br/>        redPepper: {name: "redPepper", ...}<br/>    },<br/>    seasoning: {<br/>        onion: {name: "onion", ...}, <br/>        garlic: {name: "garlic", ...}, <br/>        basil: {name: "basil", ...}, <br/>        oregano: {name: "oregano", ...}, <br/>        herbesDeProvence: {name: "herbesDeProvence", ...}, <br/>        sage: {name: "sage", ...}, <br/>        ginger: {name: "ginger", ...}<br/>    }<br/>}</span></pre><p id="6d13" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">你不需要厨房里的所有东西来做这道菜——西兰花和生姜毕竟不属于《料理鼠王》!️:相反，你只拿你需要的配料，就像这样:</p><pre class="lk ll lm ln gt ne lh nf ng aw nh bi"><span id="2866" class="ni md it lh b gy nj nk l nl nm">let ingredients = []</span><span id="6594" class="ni md it lh b gy nn nk l nl nm">ingredients.push(kitchen.vegetables.zucchini.name)<br/>ingredients.push(kitchen.vegetables.eggplant.name)<br/>ingredients.push(kitchen.vegetables.squash.name)<br/>ingredients.push(kitchen.vegetables.tomato.name)<br/>ingredients.push(kitchen.vegetables.redPepper.name)</span><span id="7cef" class="ni md it lh b gy nn nk l nl nm">ingredients.push(kitchen.seasoning.onion.name)<br/>ingredients.push(kitchen.seasoning.garlic.name)<br/>ingredients.push(kitchen.seasoning.herbesDeProvence.name)</span><span id="85e5" class="ni md it lh b gy nn nk l nl nm">// ingredients = ["zucchini", "eggplant", "squash", "tomato", "redPepper", "onion", "garlic", "herbesDeProvence"]</span></pre><p id="c9ba" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这些操作的最大O符号时间复杂度是多少？🤔</p><p id="72ed" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这些操作中的每一个(抓取配料，将其推入<code class="fe le lf lg lh b">ingredients</code>数组)都需要恒定的时间，即O(1)。操作的数量不会随着数组的大小或厨房对象的大小而增加。我们可以直接访问每个元素来获取我们所需要的，所以时间复杂度不会改变。</p><p id="610d" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这是另一个例子:</p><pre class="lk ll lm ln gt ne lh nf ng aw nh bi"><span id="b15d" class="ni md it lh b gy nj nk l nl nm">function addDigitsUpToNumber(n) {<br/>    return n * (n + 1) / 2<br/>}</span><span id="65a7" class="ni md it lh b gy nn nk l nl nm">addDigitsUpToNumber(5) // 15, same as 1 + 2 + 3 + 4 + 5 = 15</span></pre><p id="912b" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在这个函数中，我们将从1到<code class="fe le lf lg lh b">n</code>的所有数字相加，并使用快速数学技巧返回总和。该函数也具有O(1)时间复杂度，因为无论<code class="fe le lf lg lh b">n</code>是等于5、10、1，000还是1，000，000，000，000，它都需要完全相同的运算次数。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="6ff8" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">O(n)线性时间</h1><p id="d399" class="pw-post-body-paragraph ki kj it kk b kl mu ju kn ko mv jx kq kr mw kt ku kv mx kx ky kz my lb lc ld im bi translated">要开始准备炖菜，你首先要切碎配料:</p><pre class="lk ll lm ln gt ne lh nf ng aw nh bi"><span id="af27" class="ni md it lh b gy nj nk l nl nm">let ingredients = ["zucchini", "eggplant", "squash", "tomato", "redPepper", "onion", "garlic", "herbesDeProvence"]</span><span id="9c52" class="ni md it lh b gy nn nk l nl nm">function chop(ingredients) {<br/>    for (let i = 0; i &lt; ingredients.length; i++) {<br/>        console.log(`${ingredients[i]} has been chopped!`)<br/>    } <br/>}</span></pre><p id="edbb" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们的<code class="fe le lf lg lh b">chop</code>函数需要多长时间才能完成？更好的是，需要进行多少次操作？🤔</p><p id="7e60" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">因为在我们的<code class="fe le lf lg lh b">ingredients</code>数组中有七个元素，并且该函数遍历每个元素一次(在我们进行的过程中进行斩波)，我们可以说需要进行七次操作(O(7))。如果我们向数组中添加额外的<code class="fe le lf lg lh b">n</code>元素，这个函数将会执行<code class="fe le lf lg lh b">n</code>操作，因为它需要接触这些元素中的每一个元素一次，也就是O(n)。</p><p id="25c2" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">O(n)时间复杂度也被称为<em class="li">线性时间</em> <strong class="kk iu"> </strong>，通常被认为是一种高效的解决方案。它不如O(1)或O(log n)好或快，我们将在后面讨论，但通常这种时间复杂度被认为是可以接受的。</p><p id="7c4d" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">如果我们添加另一个迭代会发生什么？毕竟那些杂烩食材需要在烤箱里烤！</p><figure class="lk ll lm ln gt lo gh gi paragraph-image"><div class="gh gi mz"><img src="../Images/d51f6d2af025419ae67ac8d5b9677a05.png" data-original-src="https://miro.medium.com/v2/resize:fit:960/format:webp/1*sgCk_fw-EkLTYNojbxf-ww.jpeg"/></div><p class="na nb gj gh gi nc nd bd b be z dk translated">图片来源:皮克斯</p></figure><pre class="lk ll lm ln gt ne lh nf ng aw nh bi"><span id="7bc6" class="ni md it lh b gy nj nk l nl nm">let ingredients = ["zucchini", "eggplant", "squash", "tomato", "redPepper", "onion", "garlic", "herbesDeProvence"]</span><span id="2393" class="ni md it lh b gy nn nk l nl nm">function chop(ingredients) {<br/>    for (let i = 0; i &lt; ingredients.length; i++) {<br/>        console.log(`${ingredients[i]} has been chopped!`)<br/>    }<br/>}</span><span id="ddd7" class="ni md it lh b gy nn nk l nl nm">function roast(ingredients) {<br/>    for (let i = 0; i &lt; ingredients.length; i++) {<br/>        console.log(`${ingredients[i]} has been roasted!`)<br/>    }<br/>}</span><span id="975b" class="ni md it lh b gy nn nk l nl nm">function makeRatatouille(ingredients) {<br/>    chop(ingredients)<br/>    roast(ingredients)<br/>}</span></pre><p id="b4f2" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们的<code class="fe le lf lg lh b">makeRatatouille</code>函数需要迭代所有的成分两次:第一次在<code class="fe le lf lg lh b">chop</code>函数中，然后再次在<code class="fe le lf lg lh b">roast</code>函数中。我们可以说这个函数需要O(2n)时间，因为它将遍历配料数组两次。</p><p id="f38c" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这个函数的时间复杂度仍然与<code class="fe le lf lg lh b">n</code>成比例增长，所以我们将删除任何常数(在这个例子中是数字2)并将它称为O(n)，就像以前一样。例如，即使这个函数有得出O(4n + 20)的额外操作，我们仍然会将其简化为O(n)，因为在大O符号中，c <em class="li">常量和更小的操作不计算在内。</em></p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="afe0" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">O(n)次时间</h1><p id="e13d" class="pw-post-body-paragraph ki kj it kk b kl mu ju kn ko mv jx kq kr mw kt ku kv mx kx ky kz my lb lc ld im bi translated">作为厨师雷米，你会听到著名的餐馆评论家(也是臭名昭著的坏脾气者)柯博先生第一次来评判你的食物。呀！😰</p><figure class="lk ll lm ln gt lo gh gi paragraph-image"><div class="gh gi no"><img src="../Images/6b943ad0f496bf78ca3f3adf81aa9fff.png" data-original-src="https://miro.medium.com/v2/resize:fit:1000/1*CivRIA-8y4J42AplSXc_2A.gif"/></div><p class="na nb gj gh gi nc nd bd b be z dk translated">图片来源:皮克斯</p></figure><p id="d4d4" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">他只会接受最好的，所以你决定整理所有切碎的蔬菜，为他的炖菜找到最好的。让我们假设每个部分都有一个从1到n的等级，1表示最好的部分，n表示最差:</p><pre class="lk ll lm ln gt ne lh nf ng aw nh bi"><span id="7e92" class="ni md it lh b gy nj nk l nl nm">let zucchiniSlices = [20, 11, 25, 3, 14, 5,...]</span><span id="dc3e" class="ni md it lh b gy nn nk l nl nm">function sortByBestSlices(veggieSlices) {<br/>    for (let i = 0; i &lt; veggieSlices.length; i++) {<br/>        for (let j = 0; j &lt; veggieSlices.length; j++) {<br/>            if (veggieSlices[i] &lt; veggieSlices[j]) {<br/>                let temp = veggieSlices[i];<br/>                veggieSlices[i] = veggieSlices[j];<br/>                veggieSlices[j] = temp;<br/>            }<br/>        }<br/>    }<br/>    return veggieSlices<br/>}</span><span id="2aac" class="ni md it lh b gy nn nk l nl nm">sortByBestSlices(zucchiniSlices)</span></pre><p id="7946" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这个函数的时间复杂度非常糟糕。这里我们看的是O(n)，也称为<em class="li">二次时间</em> <strong class="kk iu"> </strong>，因为我们有一个嵌套的<code class="fe le lf lg lh b">for</code>循环情况。在这个函数中，我们遍历我们的<code class="fe le lf lg lh b">veggieSlices</code>数组中的每一个片，一个接一个地与所有其他片进行比较，就像<code class="fe le lf lg lh b">n * n</code>一样。如果阵列有30个切片，我们将有30 x 30次操作(900)。如果我们有100个切片，以这种方式排序将需要10，000次操作！</p><p id="448a" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">运行时间可能会增长得相当快——柯博先生正等着吃饭呢！难道没有一种更有效的排序方法，对运行时影响更小吗？</p><p id="57ef" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">当然有！</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><p id="4593" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">有很多算法比O(n)快得多，比如运行时间为O(log n)和O(n log n)的算法。我们将在本系列的第2部分中探讨这些问题。</p><p id="f1aa" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">与此同时，让我们为柯博先生再倒一杯酒，希望他保持耐心。🍷敬请期待！</p><figure class="lk ll lm ln gt lo gh gi paragraph-image"><div class="gh gi no"><img src="../Images/ccf7f6c7f13dde1603fbe6555438cd5e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1000/1*V5i8Ctj5-yaZgFAcf9kOMw.gif"/></div><p class="na nb gj gh gi nc nd bd b be z dk translated">图片来源:皮克斯</p></figure><p id="2b12" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">更新:查看第2部分，我们将深入探讨O(log n)、O(n log n)、O(2^n)和O(n！)<a class="ae np" href="https://medium.com/swlh/a-beginners-guide-to-big-o-notation-part-2-c4ede76cea36" rel="noopener">这里</a>！</p></div></div>    
</body>
</html>