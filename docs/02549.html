<html>
<head>
<title>Setting Up Varnish-Cache 4 for WordPress</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">为WordPress设置Varnish-Cache 4</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/set-up-varnish-cache-for-wordpress-8e2ac92ce347?source=collection_archive---------5-----------------------#2019-12-08">https://betterprogramming.pub/set-up-varnish-cache-for-wordpress-8e2ac92ce347?source=collection_archive---------5-----------------------#2019-12-08</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="2f40" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">加速你的WordPress站点</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/b9a1822b721cd36857cacba29610ede9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*zB8InrY8_Eh1WSyTJYAh9g.jpeg"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">安妮·斯普拉特在<a class="ae ky" href="https://unsplash.com/s/photos/work?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的照片</p></figure><p id="6485" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如前一篇文章所述，我一直在使用Varnish来提高高流量网站的速度和可靠性，同时降低服务器成本:</p><div class="lv lw gp gr lx ly"><a href="https://medium.com/swlh/save-60-on-server-costs-with-this-setup-7f036e67bf70" rel="noopener follow" target="_blank"><div class="lz ab fo"><div class="ma ab mb cl cj mc"><h2 class="bd iu gy z fp md fr fs me fu fw is bi translated">通过这种设置节省60%的服务器成本</h2><div class="mf l"><h3 class="bd b gy z fp md fr fs me fu fw dk translated">使用Varnish来加速您的高流量网站，并在您的服务器上节省60%以上</h3></div><div class="mg l"><p class="bd b dl z fp md fr fs me fu fw dk translated">medium.com</p></div></div><div class="mh l"><div class="mi l mj mk ml mh mm ks ly"/></div></div></a></div></div><div class="ab cl mn mo hx mp" role="separator"><span class="mq bw bk mr ms mt"/><span class="mq bw bk mr ms mt"/><span class="mq bw bk mr ms"/></div><div class="im in io ip iq"><h1 id="708e" class="mu mv it bd mw mx my mz na nb nc nd ne jz nf ka ng kc nh kd ni kf nj kg nk nl bi translated">什么是清漆缓存？</h1><p id="f55a" class="pw-post-body-paragraph kz la it lb b lc nm ju le lf nn jx lh li no lk ll lm np lo lp lq nq ls lt lu im bi translated">Varnish是一个充当整页缓存机制的工具。它可以设置为反向代理—在它向后端系统请求某个HTTP请求之前，它会对自己的缓存存储进行缓存检查。如果缓存命中，它将返回之前存储的完整HTML页面，而如果未命中，它将请求一个后端端点来处理请求，存储它，然后将其返回给请求用户。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nr"><img src="../Images/742ca0db33249828e03d1a0f3f6b8fb9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*cVo5CpDmXc2-NVSlcwmm9g.png"/></div></div></figure></div><div class="ab cl mn mo hx mp" role="separator"><span class="mq bw bk mr ms mt"/><span class="mq bw bk mr ms mt"/><span class="mq bw bk mr ms"/></div><div class="im in io ip iq"><h1 id="aa91" class="mu mv it bd mw mx my mz na nb nc nd ne jz nf ka ng kc nh kd ni kf nj kg nk nl bi translated">表演</h1><p id="b737" class="pw-post-body-paragraph kz la it lb b lc nm ju le lf nn jx lh li no lk ll lm np lo lp lq nq ls lt lu im bi translated">清漆性能极佳。它通常受到网络速度的限制，实际上将性能变成了一个无关紧要的问题。我们已经看到Varnish在常规现成硬件上提供20 Gbps的速度。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ns"><img src="../Images/ed20b5f4c483a785cdf715e5dc8b3c18.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*7XNZVSJrF-wCbZ--z3-yGg.png"/></div></div></figure></div><div class="ab cl mn mo hx mp" role="separator"><span class="mq bw bk mr ms mt"/><span class="mq bw bk mr ms mt"/><span class="mq bw bk mr ms"/></div><div class="im in io ip iq"><h1 id="cf0f" class="mu mv it bd mw mx my mz na nb nc nd ne jz nf ka ng kc nh kd ni kf nj kg nk nl bi translated">如何为WordPress设置它</h1><p id="5ff9" class="pw-post-body-paragraph kz la it lb b lc nm ju le lf nn jx lh li no lk ll lm np lo lp lq nq ls lt lu im bi translated">与每个应用程序一样，有些请求可以完全缓存，而有些请求则根本无法缓存。</p><p id="1581" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">根据具体情况，可能会有无法缓存的get请求。通常，在WordPress站点上，所有get请求都可以被缓存。</p><p id="f79b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">对于WordPress，不应该被缓存的是API端点，它们在路径<code class="fe nt nu nv nw b">/wp-json/</code>下，当然还有所有的POST请求。我发现有些插件不需要使用任何缓存，比如Elementor。</p><p id="4fc0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">缓存的保留期显然取决于网站和内容更改的频率。在我的例子中，我为WordPress创建了一个简单的插件，在post/page更新时挂钩，它将为我清除缓存。正确的做法是只为刚刚更新的条目清除缓存。我没有做到那一步，只是在每次新文章或文章更新时删除所有缓存。</p></div><div class="ab cl mn mo hx mp" role="separator"><span class="mq bw bk mr ms mt"/><span class="mq bw bk mr ms mt"/><span class="mq bw bk mr ms"/></div><div class="im in io ip iq"><h1 id="ab1e" class="mu mv it bd mw mx my mz na nb nc nd ne jz nf ka ng kc nh kd ni kf nj kg nk nl bi translated">配置</h1><p id="ba39" class="pw-post-body-paragraph kz la it lb b lc nm ju le lf nn jx lh li no lk ll lm np lo lp lq nq ls lt lu im bi translated">这里我们有三个参与者:WordPress、Varnish-Cache反向代理和web服务器，在我的例子中是Nginx。</p><p id="405d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">首先，我们需要设置Varnish-Cache作为反向代理，不缓存任何东西。</p><h2 id="8741" class="nx mv it bd mw ny nz dn na oa ob dp ne li oc od ng lm oe of ni lq og oh nk oi bi translated">在Varnish-Cache中设置后端</h2><pre class="kj kk kl km gt oj nw ok ol aw om bi"><span id="d232" class="nx mv it nw b gy on oo l op oq">backend default {<br/>  .host = "10.0.0.5";<br/>  .port = "8080";<br/>}</span></pre><p id="9ff4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在我的配置中，所有实例都在Azure网络中，Web服务器的IP地址是10.0.0.5。</p><h2 id="ba64" class="nx mv it bd mw ny nz dn na oa ob dp ne li oc od ng lm oe of ni lq og oh nk oi bi translated">处理请求</h2><pre class="kj kk kl km gt oj nw ok ol aw om bi"><span id="31d0" class="nx mv it nw b gy on oo l op oq">sub vcl_recv {<br/>  return(pass);<br/>}</span></pre><p id="1eb7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">将忽略缓存，只将请求委托给后端。有了这两个块，Varnish-Cache就被设置为一个反向代理，它将总是向后端请求每个请求。</p><p id="432a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><em class="or">全档</em><strong class="lb iu"><em class="or">/etc/varnish/default . VCL:</em></strong></p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="os ot l"/></div></figure><h2 id="084f" class="nx mv it bd mw ny nz dn na oa ob dp ne li oc od ng lm oe of ni lq og oh nk oi bi translated"><strong class="ak"> NGinX设置</strong></h2><p id="27db" class="pw-post-body-paragraph kz la it lb b lc nm ju le lf nn jx lh li no lk ll lm np lo lp lq nq ls lt lu im bi translated">NGinX web服务器配置上唯一需要更新的是改变它监听的端口。</p><pre class="kj kk kl km gt oj nw ok ol aw om bi"><span id="660e" class="nx mv it nw b gy on oo l op oq">server {<br/>   server_name <strong class="nw iu">your_server_name.com</strong>;</span><span id="cd23" class="nx mv it nw b gy ou oo l op oq"><br/>   .....</span><span id="bf1c" class="nx mv it nw b gy ou oo l op oq">   <br/>   listen <strong class="nw iu">8080</strong>;<br/>}</span></pre><h2 id="5289" class="nx mv it bd mw ny nz dn na oa ob dp ne li oc od ng lm oe of ni lq og oh nk oi bi translated"><strong class="ak"> SSL设置</strong></h2><p id="f741" class="pw-post-body-paragraph kz la it lb b lc nm ju le lf nn jx lh li no lk ll lm np lo lp lq nq ls lt lu im bi translated">我正在用<a class="ov ow ep" href="https://medium.com/u/a00e599743a7?source=post_page-----8e2ac92ce347--------------------------------" rel="noopener" target="_blank"> Cloudflare </a>管理我的域，在Cloudflare admin上配置灵活的SSL当然就足够了。虽然我配置成满的。灵活和完整之间的区别在于，前者将确保客户端和Cloudflare之间的SSL连接，而Cloudflare和您的服务器之间的连接将不使用SSL。另一方面，Full意味着这个连接的两端都将使用SSL。</p><p id="b10f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">出于这个原因，我将我的web服务器设置为第一响应者，它只是作为握手过程的SSL端点。然后，这将把请求转发给Varnish-Cache，Varnish-Cache最终(在未命中时)将请求转发给后端(web服务器)。</p><p id="b5cb" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这是配置:</p><pre class="kj kk kl km gt oj nw ok ol aw om bi"><span id="8c87" class="nx mv it nw b gy on oo l op oq">server {</span><span id="4ae8" class="nx mv it nw b gy ou oo l op oq">  server_name servername1.com servername2.com *.servername.com ....;<br/>  location / {<br/>    proxy_pass <a class="ae ky" href="http://10.0.0.4:80;" rel="noopener ugc nofollow" target="_blank">http://10.0.0.4:80;</a><br/>    proxy_set_header X-Real-IP  $remote_addr;<br/>    proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;<br/>    proxy_set_header X-Forwarded-Proto https;<br/>    proxy_set_header X-Forwarded-Port 443;<br/>    proxy_set_header Host $host;<br/>  }</span><span id="bbad" class="nx mv it nw b gy ou oo l op oq"><em class="or">  # Certbot will eventually take care of the following if you<br/>  # generate the SSL certificate with it</em></span><span id="7eb0" class="nx mv it nw b gy ou oo l op oq">  listen <strong class="nw iu">443</strong> ssl;<br/>  ssl_certificate <strong class="nw iu">path_to_cetificate/fullchain.pem</strong>;<br/>  ssl_certificate_key <strong class="nw iu">path_to_private_key</strong>/privkey.pem;</span><span id="d81c" class="nx mv it nw b gy ou oo l op oq">}</span></pre><p id="5783" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在我的Azure网络内部，连接将不使用SSL，因此这个服务器块将调用转发到端口80上10.0.0.4处的Varnish-Cache实例。</p><p id="b3ba" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">它还将转发所有与HTTPS相关的标题，以便WordPress能够正常工作。</p><h2 id="78c3" class="nx mv it bd mw ny nz dn na oa ob dp ne li oc od ng lm oe of ni lq og oh nk oi bi translated">让WordPress使用上面的配置</h2><p id="507a" class="pw-post-body-paragraph kz la it lb b lc nm ju le lf nn jx lh li no lk ll lm np lo lp lq nq ls lt lu im bi translated">在WordPress安装的根目录下，在<code class="fe nt nu nv nw b">wp-config.php</code>文件的末尾添加以下内容:</p><pre class="kj kk kl km gt oj nw ok ol aw om bi"><span id="181c" class="nx mv it nw b gy on oo l op oq">if (strpos($_SERVER['HTTP_X_FORWARDED_PROTO'], 'https') !== false) {<br/>   $_SERVER['HTTPS']='on';<br/>}</span></pre><p id="7f9f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这将防止WordPress无限重定向到一个“https://”协议，因为它不知道当前请求已经在https上。</p></div><div class="ab cl mn mo hx mp" role="separator"><span class="mq bw bk mr ms mt"/><span class="mq bw bk mr ms mt"/><span class="mq bw bk mr ms"/></div><div class="im in io ip iq"><h1 id="db71" class="mu mv it bd mw mx my mz na nb nc nd ne jz nf ka ng kc nh kd ni kf nj kg nk nl bi translated">启用缓存</h1><p id="d5cc" class="pw-post-body-paragraph kz la it lb b lc nm ju le lf nn jx lh li no lk ll lm np lo lp lq nq ls lt lu im bi translated">现在我们已经有了所有的基础部分，我们可以配置Varnish来对请求进行缓存。</p><p id="3d5d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">首先，让我们为希望从缓存中排除的请求添加几个块:</p><pre class="kj kk kl km gt oj nw ok ol aw om bi"><span id="e6d8" class="nx mv it nw b gy on oo l op oq">sub vcl_recv {</span><span id="6b3f" class="nx mv it nw b gy ou oo l op oq"><strong class="nw iu">  # Exclude caching Ajax requests</strong><br/>  if (req.http.X-Requested-With == "XMLHttpRequest") {<br/>     return(pass);<br/>  }</span><span id="7817" class="nx mv it nw b gy ou oo l op oq"><strong class="nw iu">  # Exclude all POST requests or Authorization requests</strong><br/>  if (req.http.Authorization || req.method == "POST") {<br/>     return (pass);<br/>  }</span><span id="0f84" class="nx mv it nw b gy ou oo l op oq"><strong class="nw iu">  # Exclude everything that is neither GET nor HEAD</strong><br/>  if (req.method != "GET" &amp;&amp; req.method != "HEAD") {<br/>     return (pass);<br/>  }</span><span id="34ef" class="nx mv it nw b gy ou oo l op oq"><strong class="nw iu">  # Exclude everything related to the backed, using a <br/>  # Regular Expression we can match the url against <br/>  # wp-admin, post.php, edit.php, wp-login, wp-json.</strong><br/>  if (req.url ~ "(wp-admin|post\.php|edit\.php|wp-login|wp-json)") {<br/>     return(pass);<br/>  }</span><span id="eb8b" class="nx mv it nw b gy ou oo l op oq"><strong class="nw iu">  # Exclude wp-cron or when the front end is being <br/>  # previewed from the administrator/developer</strong><br/>  if (req.url ~ "/wp-cron.php" || req.url ~ "preview=true") {<br/>     return (pass);<br/>  }</span><span id="7173" class="nx mv it nw b gy ou oo l op oq"><strong class="nw iu">  # Exclude explicitly a specific file when requested<br/>  # from a specific host_name</strong><br/>  if ((req.http.host ~ "<strong class="nw iu">myhost.com</strong>" &amp;&amp; req.url ~ "^<strong class="nw iu">specific_file_name\.(css|js)</strong>")) {<br/>     return (pass);<br/>  }</span><span id="7359" class="nx mv it nw b gy ou oo l op oq">}</span></pre><p id="5ae5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">对于实际将被缓存的其他请求，应该应用以下内容:</p><pre class="kj kk kl km gt oj nw ok ol aw om bi"><span id="69c4" class="nx mv it nw b gy on oo l op oq">sub vcl_recv {</span><span id="1cc6" class="nx mv it nw b gy ou oo l op oq">  ...</span><span id="b3b5" class="nx mv it nw b gy ou oo l op oq"><strong class="nw iu">  # Remove the has_js cookie</strong><br/>  set req.http.Cookie = regsuball(req.http.Cookie, "has_js=[^;]+(; )?", "");</span><span id="4191" class="nx mv it nw b gy ou oo l op oq"><strong class="nw iu">  # Remove the wp-settings-1 cookie</strong><br/>  set req.http.Cookie = regsuball(req.http.Cookie, "wp-settings-1=[^;]+(; )?", "");</span><span id="ef1f" class="nx mv it nw b gy ou oo l op oq"><strong class="nw iu">  # Remove the wp-settings-time-1 cookie</strong><br/>  set req.http.Cookie = regsuball(req.http.Cookie, "wp-settings-time-1=[^;]+(; )?", "");</span><span id="c10c" class="nx mv it nw b gy ou oo l op oq"><strong class="nw iu">  # Remove the wp test cookie</strong><br/>  set req.http.Cookie = regsuball(req.http.Cookie, "wordpress_test_cookie=[^;]+(; )?", "");</span><span id="b706" class="nx mv it nw b gy ou oo l op oq"><strong class="nw iu">  # Remove the PHPSESSID in members area cookie</strong><br/>  set req.http.Cookie = regsuball(req.http.Cookie, "PHPSESSID=[^;]+(; )?", "");</span><span id="d1e1" class="nx mv it nw b gy ou oo l op oq">  unset req.http.Cookie;</span><span id="63ed" class="nx mv it nw b gy ou oo l op oq">}</span></pre><h2 id="359b" class="nx mv it bd mw ny nz dn na oa ob dp ne li oc od ng lm oe of ni lq og oh nk oi bi translated">清理缓存</h2><p id="5b42" class="pw-post-body-paragraph kz la it lb b lc nm ju le lf nn jx lh li no lk ll lm np lo lp lq nq ls lt lu im bi translated">最后一步是从特定的HTTP请求中清除缓存:</p><pre class="kj kk kl km gt oj nw ok ol aw om bi"><span id="0b05" class="nx mv it nw b gy on oo l op oq">sub vcl_recv {</span><span id="b5b7" class="nx mv it nw b gy ou oo l op oq">  if (req.method == "PURGE") {<br/>    return (purge);<br/>  }</span><span id="91e5" class="nx mv it nw b gy ou oo l op oq">  if (req.method == "CLEANFULLCACHE") {<br/>    ban("req.http.host ~ .*");<br/>    return (synth(200, "Full cache cleared"));<br/>  }</span><span id="0ba2" class="nx mv it nw b gy ou oo l op oq">}</span></pre><p id="e610" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">有了这两个条件，我们就可以轻松清空满缓存了。</p><p id="5f85" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">调用清理的CURL调用看起来像这样<code class="fe nt nu nv nw b">curl -XCLEANFULLCACHE http://varnishurl_or_ip</code>。</p><p id="c074" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">满<code class="fe nt nu nv nw b">/etc/varnish/default.vcl</code></p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="os ot l"/></div></figure></div><div class="ab cl mn mo hx mp" role="separator"><span class="mq bw bk mr ms mt"/><span class="mq bw bk mr ms mt"/><span class="mq bw bk mr ms"/></div><div class="im in io ip iq"><h1 id="c780" class="mu mv it bd mw mx my mz na nb nc nd ne jz nf ka ng kc nh kd ni kf nj kg nk nl bi translated"><strong class="ak">自动缓存更新</strong></h1><p id="cd73" class="pw-post-body-paragraph kz la it lb b lc nm ju le lf nn jx lh li no lk ll lm np lo lp lq nq ls lt lu im bi translated">这个难题的最后一部分是当一篇新文章/页面被创建，或者一个现有的实体被更新时，让WordPress清空缓存。</p><p id="e758" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">为此，在[WordPress-root-installation]/WP-content/plugins/内创建一个新文件夹，例如[WordPress-root-installation]/WP-content/plugins/<strong class="lb iu">cachecleaner.php</strong>。</p><p id="d6b3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在刚刚创建的文件夹中创建一个新文件。我们可以把cachcleaner.php的T2叫做T3。</p><p id="4670" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">将下面的代码添加到文件中，然后从WordPress管理面板中启用这个新插件。</p><p id="73ed" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">完整档案【cachecleaner.php T4】</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="os ot l"/></div></figure><p id="71c8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">根据你自己的需要，改变Varnish缓存地址和WordPress插件信息。</p></div></div>    
</body>
</html>