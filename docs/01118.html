<html>
<head>
<title>The perfect iOS app architecture</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">完美的iOS应用架构</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/the-perfect-ios-app-architecture-24259417843f?source=collection_archive---------1-----------------------#2019-08-16">https://betterprogramming.pub/the-perfect-ios-app-architecture-24259417843f?source=collection_archive---------1-----------------------#2019-08-16</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><figure class="is it gp gr iu iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi ir"><img src="../Images/db300ec3b52978e519dc0f30fb1a7324.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*2SrZtYjS21ezCVWbiyAhBQ.jpeg"/></div></div></figure><h2 id="f0fd" class="jc jd je bd b dl jf jg jh ji jj jk dk jl translated" aria-label="kicker paragraph">可扩展iOS应用架构的组成部分</h2><div class=""/><div class=""><h2 id="4e80" class="pw-subtitle-paragraph kk jn je bd b kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb dk translated">MVVM，干净的雨燕，毒蛇？—自己发明就好！</h2></div><p id="7b3e" class="pw-post-body-paragraph lc ld je le b lf lg ko lh li lj kr lk ll lm ln lo lp lq lr ls lt lu lv lw lx im bi translated">任何已经实现了一些iOS应用的人都会偶然发现<strong class="le jo">大规模视图控制器</strong> (MVC)问题，并且在某个时候肯定会问:</p><blockquote class="ly"><p id="993e" class="lz ma je bd mb mc md me mf mg mh lx dk translated">iOS应用的完美架构是什么？</p></blockquote><p id="752d" class="pw-post-body-paragraph lc ld je le b lf mi ko lh li mj kr lk ll mk ln lo lp ml lr ls lt mm lv lw lx im bi translated">警告:这是一个<strong class="le jo">陷阱</strong>和一个非常深的洞！😜</p><p id="accd" class="pw-post-body-paragraph lc ld je le b lf lg ko lh li lj kr lk ll lm ln lo lp lq lr ls lt lu lv lw lx im bi translated">当然，没有什么是“完美的”，当然也没有“完美的”架构，甚至没有“一个”完美的架构。见鬼，我们根本不是在谈论“建筑”！🤨</p><p id="74b0" class="pw-post-body-paragraph lc ld je le b lf lg ko lh li lj kr lk ll lm ln lo lp lq lr ls lt lu lv lw lx im bi translated">在他的YouTube视频“<a class="ae mn" href="https://youtu.be/qzTeyxIW_ow" rel="noopener ugc nofollow" target="_blank"> Clean iOS Architecture </a>”、<a class="mo mp ep" href="https://medium.com/u/27b1c64c3b48?source=post_page-----24259417843f--------------------------------" rel="noopener" target="_blank">卡伊奥·祖洛</a>非常清楚地解释了“软件架构”MVVM、VIPER、Clean Swift等。并不是真正的架构，而是<strong class="le jo">设计模式</strong>。</p><p id="5bba" class="pw-post-body-paragraph lc ld je le b lf lg ko lh li lj kr lk ll lm ln lo lp lq lr ls lt lu lv lw lx im bi translated">所以，即使不正确，我们还是坚持通常的术语“架构”。他们中哪一个现在是最好的？</p><p id="b7cc" class="pw-post-body-paragraph lc ld je le b lf lg ko lh li lj kr lk ll lm ln lo lp lq lr ls lt lu lv lw lx im bi translated">当然，永远是自己的！😁</p><p id="ed68" class="pw-post-body-paragraph lc ld je le b lf lg ko lh li lj kr lk ll lm ln lo lp lq lr ls lt lu lv lw lx im bi translated">如果你自己开发一个单屏幕的业余爱好应用，你通常需要一个不同的架构，而不是一个分散的10人团队开发一个价值100万美元的应用。</p><blockquote class="ly"><p id="c859" class="lz ma je bd mb mc md me mf mg mh lx dk translated">架构必须适合团队和项目！</p></blockquote><p id="cb21" class="pw-post-body-paragraph lc ld je le b lf mi ko lh li mj kr lk ll mk ln lo lp ml lr ls lt mm lv lw lx im bi translated">在他的讲座“<a class="ae mn" href="https://youtu.be/ujOc3a7Hav0" rel="noopener ugc nofollow" target="_blank">失落的系统设计艺术</a>”中，<a class="mo mp ep" href="https://medium.com/u/5486d7313999?source=post_page-----24259417843f--------------------------------" rel="noopener" target="_blank"> John Sundell </a>鼓励你开发适合你自己的团队和项目的架构。</p><p id="2035" class="pw-post-body-paragraph lc ld je le b lf lg ko lh li lj kr lk ll lm ln lo lp lq lr ls lt lu lv lw lx im bi translated">这正是我所做的，现在我想分享我在我的“<a class="ae mn" href="https://medium.com/@sven.korset/pieces-of-a-scalable-ios-app-architecture-7c182f9dcd2c" rel="noopener">可扩展的iOS应用架构</a>”系列博文中所学到的东西。我希望有一些开发人员会发现这很有趣，并能为他们自己的项目带来一些灵感。</p><p id="0d2c" class="pw-post-body-paragraph lc ld je le b lf lg ko lh li lj kr lk ll lm ln lo lp lq lr ls lt lu lv lw lx im bi translated">当然，我总是努力提高自己和我的架构，并期待适当的建设性批评。🤗</p></div><div class="ab cl mq mr hx ms" role="separator"><span class="mt bw bk mu mv mw"/><span class="mt bw bk mu mv mw"/><span class="mt bw bk mu mv"/></div><div class="im in io ip iq"><h1 id="0247" class="mx my je bd mz na nb nc nd ne nf ng nh kt ni ku nj kw nk kx nl kz nm la nn no bi translated">建筑的目标</h1><p id="cd0d" class="pw-post-body-paragraph lc ld je le b lf np ko lh li nq kr lk ll nr ln lo lp ns lr ls lt nt lv lw lx im bi translated">架构通常应该:</p><ul class=""><li id="731d" class="nu nv je le b lf lg li lj ll nw lp nx lt ny lx nz oa ob oc bi translated">修复大规模视图控制器问题</li><li id="7496" class="nu nv je le b lf od li oe ll of lp og lt oh lx nz oa ob oc bi translated">提高可测试性</li><li id="6e9f" class="nu nv je le b lf od li oe ll of lp og lt oh lx nz oa ob oc bi translated">提高可维护性</li><li id="0a6f" class="nu nv je le b lf od li oe ll of lp og lt oh lx nz oa ob oc bi translated">随团队规模扩展</li></ul><p id="d4b1" class="pw-post-body-paragraph lc ld je le b lf lg ko lh li lj kr lk ll lm ln lo lp lq lr ls lt lu lv lw lx im bi translated">解决方案其实很简单:<strong class="le jo">模块化😎</strong></p><blockquote class="ly"><p id="407f" class="lz ma je bd mb mc md me mf mg mh lx dk translated">模块化意味着将程序的功能分成独立的、可互换的单元，每个单元只负责程序的一个方面。</p></blockquote><p id="dda2" class="pw-post-body-paragraph lc ld je le b lf mi ko lh li mj kr lk ll mk ln lo lp ml lr ls lt mm lv lw lx im bi translated">比如在Swift中，你可以把代码外包到框架中，比如一个服务器模块，它只负责和一个服务器通信。在应用程序中，不再执行服务器请求，而是仅通过服务器模块。这个服务器模块可以与应用程序的其余部分分开替换、重写和测试。</p><p id="321e" class="pw-post-body-paragraph lc ld je le b lf lg ko lh li lj kr lk ll lm ln lo lp lq lr ls lt lu lv lw lx im bi translated">但是，您不必将所有事情都外包到框架中。如果您编写只负责一个方面并通过协议引用的专用类，这通常就足够了。同样，代码是捆绑在一起的，只做一件事，而且由于协议的原因，可以很容易地被替换。</p><p id="4ef4" class="pw-post-body-paragraph lc ld je le b lf lg ko lh li lj kr lk ll lm ln lo lp lq lr ls lt lu lv lw lx im bi translated">通过划分成模块，通常可以快速解决大规模视图控制器的问题，因为实际上不属于视图控制器的代码被外包到模块中。然后ViewController会自动收缩。😉</p><p id="e7e3" class="pw-post-body-paragraph lc ld je le b lf lg ko lh li lj kr lk ll lm ln lo lp lq lr ls lt lu lv lw lx im bi translated">互换性增加了可测试性，因为它使得模拟依赖性和分别测试模块变得容易。如果团队中的每个成员都只在他们独立的代码模块上工作，而这些模块也有一个高度标准化的接口，那么合并冲突应该是非常罕见的，所以它与团队的规模成比例。</p><p id="665d" class="pw-post-body-paragraph lc ld je le b lf lg ko lh li lj kr lk ll lm ln lo lp lq lr ls lt lu lv lw lx im bi translated">所有常见的架构通常都是基于模块化的。特殊的类，如控制器、模型或工人，无论你怎么称呼它们，都是分开的代码，通过协议变得更易测试。具体如何分离由各自的设计模式决定。</p><p id="88aa" class="pw-post-body-paragraph lc ld je le b lf lg ko lh li lj kr lk ll lm ln lo lp lq lr ls lt lu lv lw lx im bi translated">已建立的体系结构已经解决了列出的问题。因此，使用一个已建立的架构并没有错。Bohdan Orlov 在他的文章“<a class="ae mn" href="https://medium.com/ios-os-x-development/ios-architecture-patterns-ecba4c38de52" rel="noopener"> iOS架构模式</a>”中提供了对现有架构的深刻见解。如果你喜欢更复杂的，你可以看看<a class="ae mn" href="https://github.com/uber/RIBs/wiki" rel="noopener ugc nofollow" target="_blank">优步的排骨</a>。🧐</p><p id="38db" class="pw-post-body-paragraph lc ld je le b lf lg ko lh li lj kr lk ll lm ln lo lp lq lr ls lt lu lv lw lx im bi translated">就个人而言，我并不特别喜欢现有架构的某些方面。</p><p id="eb0a" class="pw-post-body-paragraph lc ld je le b lf lg ko lh li lj kr lk ll lm ln lo lp lq lr ls lt lu lv lw lx im bi translated">MVVM的结合非常有趣，但分离还不够。</p><p id="0fc4" class="pw-post-body-paragraph lc ld je le b lf lg ko lh li lj kr lk ll lm ln lo lp lq lr ls lt lu lv lw lx im bi translated">使用Clean Swift，我发现单向数据流很好，但大多数时候presenter会萎缩，因为它通常除了传递数据之外什么也不做。</p><p id="2b41" class="pw-post-body-paragraph lc ld je le b lf lg ko lh li lj kr lk ll lm ln lo lp lq lr ls lt lu lv lw lx im bi translated">VIPER仍然是我的最爱之一，显然不仅仅是我，但所有事情真的都要经过演示者吗？</p><p id="5fc4" class="pw-post-body-paragraph lc ld je le b lf lg ko lh li lj kr lk ll lm ln lo lp lq lr ls lt lu lv lw lx im bi translated">优步的排骨对我来说太复杂了。😑</p></div><div class="ab cl mq mr hx ms" role="separator"><span class="mt bw bk mu mv mw"/><span class="mt bw bk mu mv mw"/><span class="mt bw bk mu mv"/></div><div class="im in io ip iq"><h1 id="7187" class="mx my je bd mz na nb nc nd ne nf ng nh kt ni ku nj kw nk kx nl kz nm la nn no bi translated">我的方法</h1><p id="0023" class="pw-post-body-paragraph lc ld je le b lf np ko lh li nq kr lk ll nr ln lo lp ns lr ls lt nt lv lw lx im bi translated">当然，我的方法深受流行架构的启发。目标是一个架构，在每个项目由两到五个iOS开发人员组成的分散团队中运行良好，并且易于理解。</p><p id="421b" class="pw-post-body-paragraph lc ld je le b lf lg ko lh li lj kr lk ll lm ln lo lp lq lr ls lt lu lv lw lx im bi translated">可伸缩性、可维护性和可测试性是重要的方面。必须应用可靠的原则，尤其是视图和逻辑必须分离，视图控制器应该什么都不做，依赖关系应该通过依赖注入(DI)来解决。</p><p id="1ca1" class="pw-post-body-paragraph lc ld je le b lf lg ko lh li lj kr lk ll lm ln lo lp lq lr ls lt lu lv lw lx im bi translated">以下是一个粗略的概述:</p><figure class="oj ok ol om gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi oi"><img src="../Images/820b9d69775dceaf46c0f977e91aa52d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*XQvbNfQ5NOmeNcp6tRn2fA.png"/></div></div><p class="on oo gj gh gi op oq bd b be z dk translated">架构概述</p></figure><p id="2bdb" class="pw-post-body-paragraph lc ld je le b lf lg ko lh li lj kr lk ll lm ln lo lp lq lr ls lt lu lv lw lx im bi translated">在<em class="or">显示</em>中的用户交互通过<em class="or">交互器</em>传送到<em class="or">逻辑</em>。<em class="or">逻辑</em>然后通过其业务逻辑评估这些事件，可能改变内部状态并通过<em class="or">呈现器</em>将数据传输回<em class="or">显示器</em>。</p><p id="d2ec" class="pw-post-body-paragraph lc ld je le b lf lg ko lh li lj kr lk ll lm ln lo lp lq lr ls lt lu lv lw lx im bi translated">如果<em class="or">逻辑</em>决定切换到另一个<em class="or">场景</em>，那么这通过<em class="or">内核</em>中的<em class="or">导航器</em>来完成。<em class="or">核心</em>引用<em class="or">容器</em>和<em class="or">依赖</em>，包括一个<em class="or">工厂</em>。然后<em class="or">工厂</em>创建新的<em class="or">依赖</em>，比如<em class="or">场景</em>，其中<em class="or">依赖</em>被注入。</p><p id="3328" class="pw-post-body-paragraph lc ld je le b lf lg ko lh li lj kr lk ll lm ln lo lp lq lr ls lt lu lv lw lx im bi translated">新的<em class="or">场景</em>然后有了自己的<em class="or">核心</em>，因此有了<em class="or">视图控制器</em> (VC)，这又创建了相关的<em class="or">显示</em>和<em class="or">逻辑</em>。</p><p id="4072" class="pw-post-body-paragraph lc ld je le b lf lg ko lh li lj kr lk ll lm ln lo lp lq lr ls lt lu lv lw lx im bi translated">这个架构的核心概括起来就是<strong class="le jo"> <em class="or">场景</em> </strong>由一个<strong class="le jo"> <em class="or">显示器</em> </strong>、一个<strong class="le jo"> <em class="or">逻辑</em> </strong>和一个<strong class="le jo"> <em class="or">核心</em> </strong>组成。很简单，嗯？这并不比<em class="or">模型-视图-控制器</em>架构更复杂。😉</p></div><div class="ab cl mq mr hx ms" role="separator"><span class="mt bw bk mu mv mw"/><span class="mt bw bk mu mv mw"/><span class="mt bw bk mu mv"/></div><div class="im in io ip iq"><h1 id="9cb7" class="mx my je bd mz na nb nc nd ne nf ng nh kt ni ku nj kw nk kx nl kz nm la nn no bi translated">大局</h1><p id="6df7" class="pw-post-body-paragraph lc ld je le b lf np ko lh li nq kr lk ll nr ln lo lp ns lr ls lt nt lv lw lx im bi translated">为了更好地了解情况，下面是依赖关系图:</p><figure class="oj ok ol om gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi os"><img src="../Images/e3ad5a1b768c63d320f599a5bb9281b2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*zSEwVwX95IxsWMQtLy9xew.png"/></div></div><p class="on oo gj gh gi op oq bd b be z dk translated">依赖图</p></figure><p id="9cef" class="pw-post-body-paragraph lc ld je le b lf lg ko lh li lj kr lk ll lm ln lo lp lq lr ls lt lu lv lw lx im bi translated">到处都是箭！当然，那很简单！🤪</p><p id="bf84" class="pw-post-body-paragraph lc ld je le b lf lg ko lh li lj kr lk ll lm ln lo lp lq lr ls lt lu lv lw lx im bi translated">红色箭头表示直接依赖，因为具体的类是实例化的。例如，<em class="or"> VC </em>创建所有主要的<em class="or">显示</em>类和<em class="or">工厂</em>具体的<em class="or">视图控制器</em>。</p><p id="a11c" class="pw-post-body-paragraph lc ld je le b lf lg ko lh li lj kr lk ll lm ln lo lp lq lr ls lt lu lv lw lx im bi translated">由于方法调用，带有实心箭头的黑色箭头是依赖项。通常，方法是通过接口调用的，接口由名称中的尖括号标识。例如，<em class="or">逻辑</em>只知道<em class="or">呈现者</em>的接口，而不知道具体的<em class="or">呈现者</em>类，因此只调用<em class="or">呈现者</em>的接口的方法。</p><p id="c93c" class="pw-post-body-paragraph lc ld je le b lf lg ko lh li lj kr lk ll lm ln lo lp lq lr ls lt lu lv lw lx im bi translated">带白色尖端的黑色箭头表示接口的继承或实现。例如，<em class="or">显示</em>模块中的具体<em class="or"> Presenter </em>类实现了<em class="or"> Presenter </em>接口，而<em class="or"> VC </em>当然继承自<em class="or"> UIViewController </em>。</p><p id="66ba" class="pw-post-body-paragraph lc ld je le b lf lg ko lh li lj kr lk ll lm ln lo lp lq lr ls lt lu lv lw lx im bi translated">一个<em class="or">场景</em>代表一个应用视图，即一个<em class="or">视图</em>，包括<em class="or"> ViewController </em>以及与之相关的一切。一个<em class="or">场景</em> =一个app屏幕。</p><p id="2fef" class="pw-post-body-paragraph lc ld je le b lf lg ko lh li lj kr lk ll lm ln lo lp lq lr ls lt lu lv lw lx im bi translated">在项目结构中，这通过将所有<em class="or">场景</em>代码放入其自己的文件夹中来反映，以便相关联的代码不是分布式的而是彼此靠近的。如果两个开发者在不同的场景中工作，他们很少会互相妨碍。</p><p id="14c6" class="pw-post-body-paragraph lc ld je le b lf lg ko lh li lj kr lk ll lm ln lo lp lq lr ls lt lu lv lw lx im bi translated">如图所示，<em class="or">核心</em>模块包含<em class="or"> VC </em>和<em class="or">导航器。</em>导航员负责过渡到其他<em class="or">场景</em>。</p><p id="8aae" class="pw-post-body-paragraph lc ld je le b lf lg ko lh li lj kr lk ll lm ln lo lp lq lr ls lt lu lv lw lx im bi translated"><em class="or">显示</em>模块捆绑了<em class="or">视图</em>以及<em class="or">展示者</em>和<em class="or">互动者</em>，因为它们都与<em class="or">视图</em>交织在一起。任何格式器、<em class="or"> TableViewController </em>等也是<em class="or">显示</em>的一部分。</p><p id="a174" class="pw-post-body-paragraph lc ld je le b lf lg ko lh li lj kr lk ll lm ln lo lp lq lr ls lt lu lv lw lx im bi translated"><em class="or">逻辑</em>包含整个业务逻辑，以及当前场景状态。此外，<em class="or">逻辑</em>可以寻址任何<em class="or">工作者</em>。<em class="or">worker</em>是独立的外包逻辑单元，比如一个服务器请求框架。</p><p id="7761" class="pw-post-body-paragraph lc ld je le b lf lg ko lh li lj kr lk ll lm ln lo lp lq lr ls lt lu lv lw lx im bi translated"><em class="or">依赖</em>包括<em class="or">依赖容器</em>。还有一个<em class="or">工厂</em>，用于创建新的<em class="or">依赖</em>，比如新的<em class="or">场景</em>或者子依赖。</p><p id="68e0" class="pw-post-body-paragraph lc ld je le b lf lg ko lh li lj kr lk ll lm ln lo lp lq lr ls lt lu lv lw lx im bi translated">一切正常吗？🤓</p></div><div class="ab cl mq mr hx ms" role="separator"><span class="mt bw bk mu mv mw"/><span class="mt bw bk mu mv mw"/><span class="mt bw bk mu mv"/></div><div class="im in io ip iq"><h1 id="2fce" class="mx my je bd mz na nb nc nd ne nf ng nh kt ni ku nj kw nk kx nl kz nm la nn no bi translated">各个演员的细节</h1><p id="1202" class="pw-post-body-paragraph lc ld je le b lf np ko lh li nq kr lk ll nr ln lo lp ns lr ls lt nt lv lw lx im bi translated">参与者最好通过具体的实现来展示。所以我会建议平行看一下<a class="ae mn" href="https://github.com/indieSoftware/DemoArchitecture" rel="noopener ugc nofollow" target="_blank"> DemoApp项目</a> (DAP)。</p><p id="80e2" class="pw-post-body-paragraph lc ld je le b lf lg ko lh li lj kr lk ll lm ln lo lp lq lr ls lt lu lv lw lx im bi translated">在DAP中，我们看下面一个具体的<em class="or">场景</em>名为“场景1”。<em class="or">场景</em>可以在“DemoApp/Scenes/Act1/Scene1”下的项目中找到。</p><h2 id="6d8f" class="ot my je bd mz ou ov dn nd ow ox dp nh ll oy oz nj lp pa pb nl lt pc pd nn jk bi translated"><strong class="ak"> VC </strong></h2><p id="5323" class="pw-post-body-paragraph lc ld je le b lf np ko lh li nq kr lk ll nr ln lo lp ns lr ls lt nt lv lw lx im bi translated"><strong class="le jo"> <em class="or">场景1VC </em> </strong>在<em class="or">核心</em>中。它的任务是提供一个<em class="or"> UIViewController </em>的所有接口，例如在必要时实现<code class="fe pe pf pg ph b">viewWillAppear</code> <em class="or"> </em>。<code class="fe pe pf pg ph b">loadView</code>在这里被覆盖以创建它自己的<em class="or">场景1视图</em>。</p><p id="1f7e" class="pw-post-body-paragraph lc ld je le b lf lg ko lh li lj kr lk ll lm ln lo lp lq lr ls lt lu lv lw lx im bi translated">一个<em class="or"> ViewController </em>代表一个<em class="or">场景</em>的根对象，因此它也负责创建<em class="or">场景</em>的其他组件，例如<em class="or">呈现器</em>、<em class="or">逻辑</em>、<em class="or">导航器</em>、任何<em class="or">表格控制器</em>等。这通常在<code class="fe pe pf pg ph b">init</code>方法或<code class="fe pe pf pg ph b">loadView</code>中完成。</p><p id="9cdb" class="pw-post-body-paragraph lc ld je le b lf lg ko lh li lj kr lk ll lm ln lo lp lq lr ls lt lu lv lw lx im bi translated">不过一个<em class="or"> VC </em>应该不会做多。任何超出UIKit接口实现的东西都不再属于<em class="or"> VC </em>了。因此，如果你在没有<code class="fe pe pf pg ph b">override</code>关键字的情况下在<em class="or"> VC </em>中编写方法，你可能是在错误的类中。因此没有场景转换，没有视图的数据输入，当然也没有业务逻辑。</p><p id="3a5a" class="pw-post-body-paragraph lc ld je le b lf lg ko lh li lj kr lk ll lm ln lo lp lq lr ls lt lu lv lw lx im bi translated">对一个<em class="or"> VC </em>唯一有用的测试是端到端测试，这可以通过<em class="or">单元测试</em>来完成。</p><h2 id="022e" class="ot my je bd mz ou ov dn nd ow ox dp nh ll oy oz nj lp pa pb nl lt pc pd nn jk bi translated"><strong class="ak">导航仪</strong></h2><p id="e356" class="pw-post-body-paragraph lc ld je le b lf np ko lh li nq kr lk ll nr ln lo lp ns lr ls lt nt lv lw lx im bi translated"><em class="or">内核</em>中的<strong class="le jo"> <em class="or">场景导航器</em> </strong>实现<strong class="le jo"> <em class="or">场景导航器接口</em> </strong>协议。一个<em class="or">导航器</em>负责过渡到其他<em class="or">场景</em>，否则通常在<em class="or">视图控制器</em>中完成。</p><p id="9c04" class="pw-post-body-paragraph lc ld je le b lf lg ko lh li lj kr lk ll lm ln lo lp lq lr ls lt lu lv lw lx im bi translated"><em class="or">导航器</em>需要引用<em class="or">场景</em>的<em class="or"> UIViewController </em>。它还需要知道一个<em class="or"> UINavigationController </em>是否正在被使用，下一个<em class="or">场景</em>是否以模态方式呈现，或者如何定义结构设计。</p><p id="7a26" class="pw-post-body-paragraph lc ld je le b lf lg ko lh li lj kr lk ll lm ln lo lp lq lr ls lt lu lv lw lx im bi translated"><em class="or">工厂</em>可以通过<em class="or">act1d接口</em>中的<em class="or">依赖关系</em>访问。它创建了所需<em class="or">场景</em>的<em class="or"> UIViewController </em>以便<em class="or">导航器</em>不直接依赖于<em class="or">场景</em>而只关心一个<em class="or"> ViewController </em>的呈现。</p><p id="9c97" class="pw-post-body-paragraph lc ld je le b lf lg ko lh li lj kr lk ll lm ln lo lp lq lr ls lt lu lv lw lx im bi translated">更多信息可以在我的文章《iOS中场景过渡的<a class="ae mn" href="https://medium.com/@sven.korset/small-navigators-for-scene-transitions-in-ios-9645392e800a" rel="noopener">小导航仪</a>》中找到。</p><h2 id="aaef" class="ot my je bd mz ou ov dn nd ow ox dp nh ll oy oz nj lp pa pb nl lt pc pd nn jk bi translated"><strong class="ak">逻辑</strong></h2><p id="83a9" class="pw-post-body-paragraph lc ld je le b lf np ko lh li nq kr lk ll nr ln lo lp ns lr ls lt nt lv lw lx im bi translated"><strong class="le jo"> <em class="or">场景1逻辑</em> </strong>实现<strong class="le jo"> <em class="or">场景1逻辑接口</em> </strong>协议。该界面列出了所有用例，可能是用户发起的动作，如<code class="fe pe pf pg ph b">searchForText</code>，也可能是系统发起的动作，如<code class="fe pe pf pg ph b">displayRotated</code>。<em class="or">逻辑</em>最终实现相关的业务逻辑，其他的一切都外包给workers或子类。</p><p id="b938" class="pw-post-body-paragraph lc ld je le b lf lg ko lh li lj kr lk ll lm ln lo lp lq lr ls lt lu lv lw lx im bi translated">为了保存<em class="or">逻辑</em>的当前状态，使用<strong class="le jo"> <em class="or">场景1逻辑状态</em> </strong>中的<strong class="le jo"> <em class="or">逻辑状态</em> </strong>结构。初始状态通常在<em class="or">逻辑</em>初始化时设置。这些值由一个<em class="or">设置模型</em>参数提供。</p><p id="626e" class="pw-post-body-paragraph lc ld je le b lf lg ko lh li lj kr lk ll lm ln lo lp lq lr ls lt lu lv lw lx im bi translated"><em class="or">逻辑</em>需要访问<em class="or">呈现器</em>以将任何状态变化传达给<em class="or">视图</em>。它还需要访问<em class="or">导航器</em>来改变<em class="or">场景</em>。这些通过DI用<em class="or">逻辑</em>自己的<em class="or">log in dependencies</em>struct赋值，并且只被它们的接口引用。</p><p id="f799" class="pw-post-body-paragraph lc ld je le b lf lg ko lh li lj kr lk ll lm ln lo lp lq lr ls lt lu lv lw lx im bi translated">通过将所有专门的代码提取到workers中，<em class="or">逻辑</em>应该相对较轻，只留下状态操作、比较和委托。更少的代码意味着更少的东西会被破坏。当然，<em class="or">逻辑</em>实际上是在乞求单元和集成测试。😆</p><p id="636a" class="pw-post-body-paragraph lc ld je le b lf lg ko lh li lj kr lk ll lm ln lo lp lq lr ls lt lu lv lw lx im bi translated">关于<em class="or">逻辑</em>和其他<em class="or">显示</em>部分的更多信息，请阅读我的文章《<a class="ae mn" href="https://medium.com/@sven.korset/decoupling-display-and-logic-in-ios-4de5a334ffbd" rel="noopener">在iOS </a>中解耦显示和逻辑》。</p><h2 id="ea49" class="ot my je bd mz ou ov dn nd ow ox dp nh ll oy oz nj lp pa pb nl lt pc pd nn jk bi translated"><strong class="ak">视图</strong></h2><p id="b360" class="pw-post-body-paragraph lc ld je le b lf np ko lh li nq kr lk ll nr ln lo lp ns lr ls lt nt lv lw lx im bi translated"><em class="or">显示</em>中的<strong class="le jo"> <em class="or">场景1视图</em> </strong>代表一个<em class="or"> UIView </em>的具体子类。它的任务是创建视图层次结构，也就是说放置子视图，提供约束并定义它们的默认样式。</p><p id="f3bf" class="pw-post-body-paragraph lc ld je le b lf lg ko lh li lj kr lk ll lm ln lo lp lq lr ls lt lu lv lw lx im bi translated"><em class="or">视图</em>没有进一步的逻辑，所以它不知道数据的格式或任何应用程序状态。<em class="or">视图</em>的唯一逻辑是视图层次操作，例如添加和删除子视图，例如对于嵌入式子控制器，或者可能在激活和停用子视图时。</p><p id="3877" class="pw-post-body-paragraph lc ld je le b lf lg ko lh li lj kr lk ll lm ln lo lp lq lr ls lt lu lv lw lx im bi translated">模仿一个视图是没有意义的，所以没有<em class="or">视图</em>的接口协议。<em class="or">视图</em>可以通过快照测试进行单元测试，或者通过<em class="or">单元测试</em>进行测试。</p><h2 id="e20e" class="ot my je bd mz ou ov dn nd ow ox dp nh ll oy oz nj lp pa pb nl lt pc pd nn jk bi translated"><strong class="ak">交互器</strong></h2><p id="4f10" class="pw-post-body-paragraph lc ld je le b lf np ko lh li nq kr lk ll nr ln lo lp ns lr ls lt nt lv lw lx im bi translated"><em class="or">显示</em>中的<strong class="le jo"> <em class="or">场景1交互</em> </strong>也没有接口协议。它也不需要一个，因为只有<em class="or"> VC </em>知道它，并且只因为它创建了<em class="or">交互器</em>，然后它将自己钩入<em class="or">视图</em>和<em class="or">逻辑</em>。</p><p id="e8b2" class="pw-post-body-paragraph lc ld je le b lf lg ko lh li lj kr lk ll lm ln lo lp lq lr ls lt lu lv lw lx im bi translated"><em class="or">交互器</em>的任务是在<em class="or">视图</em>和<em class="or">逻辑</em>之间创建一个绑定，就像MVVM架构一样。因此，任何用户输入都被映射到<em class="or">逻辑</em>的用例方法。这里Rx似乎很合适，但这不是强制性的。</p><p id="9186" class="pw-post-body-paragraph lc ld je le b lf lg ko lh li lj kr lk ll lm ln lo lp lq lr ls lt lu lv lw lx im bi translated">就像<em class="or">视图</em>一样，这段代码将来也有可能被<em class="or"> SwiftUI </em>和<em class="or">组合</em>所取代。🤗</p><h2 id="ebdf" class="ot my je bd mz ou ov dn nd ow ox dp nh ll oy oz nj lp pa pb nl lt pc pd nn jk bi translated"><strong class="ak">主持人</strong></h2><p id="e091" class="pw-post-body-paragraph lc ld je le b lf np ko lh li nq kr lk ll nr ln lo lp ns lr ls lt nt lv lw lx im bi translated"><em class="or">显示屏</em>中的<strong class="le jo"> <em class="or">场景1呈现者</em> </strong>实现相关的<strong class="le jo"> <em class="or">场景1呈现者界面</em> </strong>协议。<em class="or">演示器</em>是<em class="or">交互器</em>的对应部分，因为<em class="or">演示器</em>允许从<em class="or">逻辑</em>到<em class="or">视图</em>的流程，而不是从<em class="or">视图</em>到<em class="or">逻辑</em>的流程。<em class="or">逻辑</em>和<em class="or">视图</em>彼此完全分离，由于分成类似Clean Swift架构的<em class="or">表示器</em>和<em class="or">交互器</em>，数据流是单向的。</p><p id="f7cc" class="pw-post-body-paragraph lc ld je le b lf lg ko lh li lj kr lk ll lm ln lo lp lq lr ls lt lu lv lw lx im bi translated"><em class="or">展示者</em>的任务是操纵<em class="or">视图</em>，以便显示传递的数据并应用任何样式。<em class="or">演示者</em>可以使用格式化程序来准备数据。视图或子视图中的数据由<em class="or">演示器</em>直接设置。<em class="or">视图</em>不需要知道任何关于数据的事情，<em class="or">逻辑</em>不知道任何关于<em class="or">视图的事情。</em>那是<em class="or">主持人</em>的地盘。</p><p id="2de3" class="pw-post-body-paragraph lc ld je le b lf lg ko lh li lj kr lk ll lm ln lo lp lq lr ls lt lu lv lw lx im bi translated">并非所有数据都要分配给<em class="or">视图</em>。有些可能也是为<em class="or">视图控制器</em>准备的，例如<em class="or">导航栏</em>的标题。为此，<em class="or">演示者</em>也需要引用<em class="or">场景</em>的<em class="or"> UIViewController </em>。</p><p id="3393" class="pw-post-body-paragraph lc ld je le b lf lg ko lh li lj kr lk ll lm ln lo lp lq lr ls lt lu lv lw lx im bi translated"><em class="or">演示者</em>还必须能够访问任何<em class="or">表格视图控制器</em>，以便能够更新子视图，例如<em class="or">表格视图</em>或<em class="or">集合视图</em>。</p><p id="05d9" class="pw-post-body-paragraph lc ld je le b lf lg ko lh li lj kr lk ll lm ln lo lp lq lr ls lt lu lv lw lx im bi translated">除了任何格式化之外，<em class="or">呈现器</em>的唯一逻辑是将数据放在<em class="or">视图</em>中的正确位置，并且可能根据状态变化来设计任何子视图的样式。然而，有时<em class="or">演示者</em>也负责应用一些动画，这会变得相当复杂。</p><p id="a80d" class="pw-post-body-paragraph lc ld je le b lf lg ko lh li lj kr lk ll lm ln lo lp lq lr ls lt lu lv lw lx im bi translated">作为<em class="or">显示</em>的一部分，并与<em class="or">视图</em>紧密相连，测试<em class="or">展示者</em>的最佳方式是通过<em class="or">单元测试</em>或通过快照测试部分通过单元测试视图。</p><h2 id="e842" class="ot my je bd mz ou ov dn nd ow ox dp nh ll oy oz nj lp pa pb nl lt pc pd nn jk bi translated">属国</h2><p id="28d4" class="pw-post-body-paragraph lc ld je le b lf np ko lh li nq kr lk ll nr ln lo lp ns lr ls lt nt lv lw lx im bi translated">将<strong class="le jo"><em class="or">act1依赖</em> </strong>与<strong class="le jo"><em class="or">act1依赖接口</em> </strong>放在一个父组中。不是单个<em class="or">场景</em>的一部分，但更像是一个戏剧动作，<em class="or">动作</em>代表一个应用程序状态的几个<em class="or">场景</em>，例如在几个视图上的预登录或登录。</p><p id="bb7d" class="pw-post-body-paragraph lc ld je le b lf lg ko lh li lj kr lk ll lm ln lo lp lq lr ls lt lu lv lw lx im bi translated">与<strong class="le jo"> <em class="or"> Act1DC </em> </strong>类似的<em class="or">dependency container</em>(DC)的任务是捆绑并保存各个<em class="or"> Act </em>的所有依赖关系，以便可以通过DI轻松分配给<em class="or">场景</em>的演员。</p><p id="645c" class="pw-post-body-paragraph lc ld je le b lf lg ko lh li lj kr lk ll lm ln lo lp lq lr ls lt lu lv lw lx im bi translated">一个特殊的依赖是<em class="or">工厂</em>像<strong class="le jo">工厂<em class="or">act1</em>工厂</strong>。一旦用户对象存在，它就负责创建新的依赖关系，例如<em class="or"> Act2DC </em>。<em class="or">工厂</em>也为<em class="or">导航器</em>创建了新的<em class="or">视图控制器</em>和<em class="or">场景</em>。</p><p id="02e4" class="pw-post-body-paragraph lc ld je le b lf lg ko lh li lj kr lk ll lm ln lo lp lq lr ls lt lu lv lw lx im bi translated">所有的<em class="or">场景</em>都通过<em class="or"> DC </em>相互解耦，因此没有<em class="or">场景</em>需要了解另一个场景的任何事情，至少不需要直接了解。一个<em class="or">逻辑</em>当然必须很好地知道导航到哪里，而<em class="or">导航器</em>必须确切地知道如何导航，但这是通过抽象来实现的，这要感谢<em class="or"> DC </em>。</p><p id="f04e" class="pw-post-body-paragraph lc ld je le b lf lg ko lh li lj kr lk ll lm ln lo lp lq lr ls lt lu lv lw lx im bi translated"><em class="or">行为</em>本身不被测试，但是它们对于测试其他部分是必不可少的。通过准备特殊的测试动作，其他依赖项可以被模仿并注入测试目的。</p><h2 id="ce5d" class="ot my je bd mz ou ov dn nd ow ox dp nh ll oy oz nj lp pa pb nl lt pc pd nn jk bi translated">工人</h2><p id="3079" class="pw-post-body-paragraph lc ld je le b lf np ko lh li nq kr lk ll nr ln lo lp ns lr ls lt nt lv lw lx im bi translated">一旦你可以将功能从应用中分离出来，你就应该这样做，并为它编写你自己的<strong class="le jo"> <em class="or"> Worker </em> </strong>。<em class="or">工作器</em>因此是从<em class="or">逻辑</em>或<em class="or">视图控制器</em>中提取出来的代码，这些代码至少在理论上可以用于其他<em class="or">场景</em>。因此，工人不是特殊场景的一部分。</p><p id="e661" class="pw-post-body-paragraph lc ld je le b lf lg ko lh li lj kr lk ll lm ln lo lp lq lr ls lt lu lv lw lx im bi translated">因此，不是直接绑定到特定<em class="or">场景</em>的用例的每一个逻辑都应该放入自己的<em class="or"> Worker </em>类中。</p><p id="9418" class="pw-post-body-paragraph lc ld je le b lf lg ko lh li lj kr lk ll lm ln lo lp lq lr ls lt lu lv lw lx im bi translated">应用程序应该执行服务器请求吗？那么只需要一个新的工作者来处理服务器请求！缓存？自己的工人！数据库？新工人！用户输入的复杂验证？工人！😊</p><p id="80f4" class="pw-post-body-paragraph lc ld je le b lf lg ko lh li lj kr lk ll lm ln lo lp lq lr ls lt lu lv lw lx im bi translated"><em class="or"> Workers </em>是包含逻辑代码的专门助手，只负责一个方面。因此，每个<em class="or">工作人员</em>都要经过大量的单元测试。</p><p id="026b" class="pw-post-body-paragraph lc ld je le b lf lg ko lh li lj kr lk ll lm ln lo lp lq lr ls lt lu lv lw lx im bi translated">模块化的力量来自于将代码外包给<em class="or">工人</em>。没有<em class="or">的工人</em>，巨大的班级规模问题只会转移到其他部分，就像MVVM建筑中的<em class="or">视图模型</em>。所以，这里的关键是将所有代码分成更小的模块，意味着<em class="or">工人</em>。</p></div><div class="ab cl mq mr hx ms" role="separator"><span class="mt bw bk mu mv mw"/><span class="mt bw bk mu mv mw"/><span class="mt bw bk mu mv"/></div><div class="im in io ip iq"><h2 id="dce1" class="ot my je bd mz ou ov dn nd ow ox dp nh ll oy oz nj lp pa pb nl lt pc pd nn jk bi translated">结论</h2><p id="afff" class="pw-post-body-paragraph lc ld je le b lf np ko lh li nq kr lk ll nr ln lo lp ns lr ls lt nt lv lw lx im bi translated">提出的方法应该作为通用架构的替代方案，或者作为自己架构的灵感。</p><p id="6bbd" class="pw-post-body-paragraph lc ld je le b lf lg ko lh li lj kr lk ll lm ln lo lp lq lr ls lt lu lv lw lx im bi translated">我希望，通过这篇文章，我能够展示如何将代码模块化成<strong class="le jo"> <em class="or">【显示】</em></strong><strong class="le jo"><em class="or">逻辑</em> </strong>和<strong class="le jo"> <em class="or">核心</em> </strong>导致一个具有<strong class="le jo"><em class="or"/></strong>场景的简单结构。<strong class="le jo"> <em class="or">工人</em> </strong>帮助分解大量代码。更详细的解释请阅读我的文章《<a class="ae mn" href="https://medium.com/@sven.korset/decoupling-display-and-logic-in-ios-4de5a334ffbd" rel="noopener">iOS中的显示与逻辑</a>解耦》。</p><p id="c2bc" class="pw-post-body-paragraph lc ld je le b lf lg ko lh li lj kr lk ll lm ln lo lp lq lr ls lt lu lv lw lx im bi translated">关于项目结构的更多信息，请阅读我的文章“<a class="ae mn" href="https://medium.com/@sven.korset/an-example-of-a-scalable-ios-project-dce56a256106" rel="noopener">一个可扩展的iOS项目的例子</a>”。在那篇文章中，我还提供了一些最佳实践来帮助进一步提高项目的可维护性。</p><p id="1ad1" class="pw-post-body-paragraph lc ld je le b lf lg ko lh li lj kr lk ll lm ln lo lp lq lr ls lt lu lv lw lx im bi translated">对了，我还缺少一个合理的名字给这个<strong class="le jo">D</strong>isplay-<strong class="le jo">L</strong>logic-<strong class="le jo">C</strong>ore-architecture。任何听起来不像<strong class="le jo"> D </strong>拥有<strong class="le jo"> L </strong>可装载<strong class="le jo"> C </strong>内容或<strong class="le jo"> L </strong>液体<strong class="le jo"> C </strong>晶体<strong class="le jo"> D </strong>显示的建议？😂</p></div></div>    
</body>
</html>