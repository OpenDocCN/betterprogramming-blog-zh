<html>
<head>
<title>Apple Silicon App Developer</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">苹果芯片应用开发者</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/apple-silicon-app-developer-9d725f10bee8?source=collection_archive---------12-----------------------#2020-09-02">https://betterprogramming.pub/apple-silicon-app-developer-9d725f10bee8?source=collection_archive---------12-----------------------#2020-09-02</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="aab5" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">你如何利用苹果新的片上系统架构？</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/e53b5c3ccedc191c28aaf8585f2255c0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*YCMzquwlQhany9FO"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated"><a class="ae ky" href="https://unsplash.com/@jjying?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> JJ英</a>在<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍照。</p></figure><p id="ca06" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">WWDC2020上更令人惊讶的公告之一是从英特尔转移到苹果芯片。在这篇文章中，我想看看它将如何影响我们这些卑微的开发者。我们将如何利用新硬件的优势？</p><p id="21a2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在这个关于主题为的<a class="ae ky" href="https://developer.apple.com/videos/play/wwdc2020/10686/" rel="noopener ugc nofollow" target="_blank"> WWDC2020视频中，主讲人(Gavin Barraclough)讲述了基于英特尔芯片的MAC和基于苹果芯片的MAC之间的一些差异，并在一定程度上回答了我的问题。让我们更深入地研究一下他的建议。</a></p><p id="02fe" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">他提出的主要观点之一是，基于苹果芯片的新MAC电脑将使用单芯片系统或SoC。SoC本身是一个非对称多处理单元，与英特尔的不同，如该演示中的图片所示:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi lv"><img src="../Images/1d64ad86e091777667da9cb7d4b17155.png" data-original-src="https://miro.medium.com/v2/resize:fit:904/format:webp/1*9-5ts7gsrnRWyv_tANxiXQ.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">对称内核与不对称内核</p></figure><p id="c125" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">重点是设计能够更有效地运行需要更少CPU的应用程序的硬件，同时保留更多CPU密集型应用程序所需的性能。在演示中，Gavin介绍了您需要关注的框架和格式，以便充分利用新SoC。类似这些专门命名的框架旨在利用多处理内核:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi lw"><img src="../Images/61732d71362ad12c428ec4634bc6156f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*GReItqajM6-mdjYSkpy2eA.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">苹果框架已经调整过了</p></figure><p id="5444" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">显然，这里有太多的细节需要涵盖，考虑到这一点，我想重点关注您可以做些什么来手动优化您的应用程序，以在非对称多处理苹果SoC硬件上运行——我怀疑您已经在进行优化了。</p><p id="cb2a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">你看，Swift利用这种架构已经有一段时间了，它有一个叫做GCD或Grand Central Dispatch的系统。</p><p id="f2a4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">使用GCD聚焦AMP硬件以使用QoS为中心。Apple在Swift中定义了四个QoS级别，在WWDC2015幻灯片中对此主题进行了说明:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi lx"><img src="../Images/a60ef919f1812beb60661f427cf94907.png" data-original-src="https://miro.medium.com/v2/resize:fit:1324/format:webp/1*G8m4tzF2X7Fiv4wOsM92sQ.png"/></div></div></figure><p id="dfef" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">默认情况下，主线程(用户交互)总是以最高优先级运行。从它调度的线程以用户启动的方式运行。除非您指定，否则不会作为实用程序或后台运行。让我们回顾一下它是什么样子的。</p><p id="9de1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">为了确保我们不是在拿苹果和橘子做比较，我将读入一个48，000行的文件，记录我开始和完成的时间。</p><p id="6c01" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我提供了一个非常简单的动画来展示正在发生的事情。下面的GIF说明了效果。当我启动演示应用程序时，两次上传都显示开始时间。随着数据的加载，UI在作为后台运行上传的线程上更新。由于上传和UI在同一个线程上运行，所以在上传完成之前，它不会给我们任何更新。将线程推到后台的代码如下所示:</p><pre class="kj kk kl km gt ly lz ma mb aw mc bi"><span id="9b33" class="md me it lz b gy mf mg l mh mi">DispatchQueue.global(qos: .background).async { <br/>  //background thread<br/>}</span></pre><p id="81e3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">正如您可以清楚地看到的，虽然加载花费的时间更少，但效果并不十分用户友好。在上传完成之前，用户不会被告知上传进度。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi mj"><img src="../Images/346c49b7a33a15e793954342df7594d5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1200/1*uwoqqicKBvEtit4znakRaw.gif"/></div></figure><p id="2996" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这将如何与苹果硅工作？理论上，如果代码的优先级正确，它将在后台任务中运行得更好(即使用更少的功率，产生更少的热量)。看起来应该没什么不同。</p><p id="ed71" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">但是等等，在后台有一个小小的警告:我发送回UI的消息将和它的父级(又名后台)以相同的优先级运行，这是行不通的。幸运的是，如果您犯了这个错误，Xcode会用以下信息之一警告您:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi mk"><img src="../Images/e85b5ba0658c1aa4c548a92d82e5fb48.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*p9DZuoCFiLceb7bcyo8NpA.png"/></div></div></figure><p id="3b7a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">要纠正这一点，您只需将UI代码包装在一个线程中，如下所示:</p><pre class="kj kk kl km gt ly lz ma mb aw mc bi"><span id="d8f4" class="md me it lz b gy mf mg l mh mi">DispatchQueue.main.async {<br/>  // Update UI<br/>}</span></pre><p id="5402" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">众所周知，作为一名程序员，成功的关键是有条理。为此，您可以使用如下代码创建标签来命名队列:</p><pre class="kj kk kl km gt ly lz ma mb aw mc bi"><span id="2c22" class="md me it lz b gy mf mg l mh mi">let background = DispatchQueue.init(label: "background", qos: .background, attributes: .concurrent, autoreleaseFrequency: .inherit, target: nil)<br/>background.async {<br/>  // do something<br/>}</span></pre><p id="e61e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在SoC笔记本电脑上获得最大优势的秘诀是更新您的代码，确保您的线程以正确的QoS运行。</p><p id="5da2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">回到苹果芯片和那些你将要用来运行线程的内核。我们对2020年第四季度的MBP (12核)有一个推测性的数字。我们被告知四核将专注于效率，八核专注于性能。在创建线程时，您应该记住这些数字。然而，在这一点上，我想提一下WWDC2015视频中展示的一段更新的代码<a class="ae ky" href="https://developer.apple.com/videos/play/wwdc2015/718/" rel="noopener ugc nofollow" target="_blank">:</a></p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ml mm l"/></div></figure><p id="f6fb" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">使用这个，运行的后台任务的数量(假设我只有四个以功耗为中心的内核)永远不会超过四个。如果我的硬件中只有四个节能内核，这一点非常关键。</p><p id="3624" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">当然，随着时间的推移，您的应用程序可能会在许多不同的硬件平台上运行，在理想情况下，您可以通过查询它有多少个内核来使这段代码更加智能。您可以使用此代码来找出您正在运行的硬件必须使用什么:</p><pre class="kj kk kl km gt ly lz ma mb aw mc bi"><span id="1564" class="md me it lz b gy mf mg l mh mi">let processInfo = ProcessInfo()<br/>print(processInfo.activeProcessorCount)</span></pre><p id="db21" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在我结束之前，让我们来看一下WWDC2017演示，它探讨了在MP硬件上更仔细/高效地控制代码的另一种方法。这个小片段:</p><pre class="kj kk kl km gt ly lz ma mb aw mc bi"><span id="47e7" class="md me it lz b gy mf mg l mh mi">DispatchQueue.concurrentPerform(iterations: 16) { ( process ) in<br/>  Thread.sleep(forTimeInterval: 1)<br/>  print("process \(process)")<br/>}</span></pre><p id="bc04" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这将在尽可能多的内核上并行执行进程，有效地启动尽可能多的内核来执行任务。显然，手头的任务需要仔细划分，这样才有意义。我建议观看关于主题的<a class="ae ky" href="https://developer.apple.com/videos/play/wwdc2017/706/" rel="noopener ugc nofollow" target="_blank"> WWDC2017演讲的前几分钟，以更好地了解它如何也能为你工作。</a></p><p id="e3b0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">继续向前发展，2021年可能会包含更多原语，帮助您在不同类别的处理器上构建最高效的代码库。</p><p id="f1e0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">回到我开始介绍WWDC2020的地方，Gavin继续讨论了几个方面，并确实列举了两个您应该观看的WWDC会议。我会在接下来的几周看看这些。敬请关注。</p><p id="7bf9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这就把我带到了这篇短文的结尾。通过写这篇文章，我学到了一些东西，我希望你在阅读的时候也能学到。</p><p id="d3e9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">保持冷静，继续编码。</p></div></div>    
</body>
</html>