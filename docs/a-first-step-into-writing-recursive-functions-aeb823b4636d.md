# 编写递归函数的第一步

> 原文：<https://betterprogramming.pub/a-first-step-into-writing-recursive-functions-aeb823b4636d>

## 学习编写调用自身的函数

![](img/ad6a5ae0365ff6019417a171d7207d66.png)

[视觉网](https://unsplash.com/@vision?utm_source=unsplash&utm_medium=referral&utm_content=creditCopyText)在 [Unsplash](https://unsplash.com/s/photos/repeat?utm_source=unsplash&utm_medium=referral&utm_content=creditCopyText) 上拍摄的照片

递归是导致眨眼、抓头和整体混乱的主题之一。函数调用自己的想法就像你掉进了一个兔子洞，事实是，这是对你的函数实际所做的相当准确的感觉。

即使在理解了递归多年之后，每当一个问题被递归地解决时，我必须停下来多花一分钟来确保我理解了我正在看的东西。

但是不要担心，因为我们将分解递归，并通过一个真实世界的例子。

我将用 Python 和 JavaScript 编写示例，到本文结束时，您将有望理解文章的标题实际上是一个双关语。

# 递归函数的组成部分

我发现通过例子教递归更容易。这个概念太抽象了，无法形象化。所以，让我们定义一个函数来计算一个数的阶乘。

一个数的阶乘值是该数乘以它下面的每个正整数。所以，3 阶乘——写成 3！—应该是 3 * 2 * 1，等于 6。

## 计算机编程语言

## Java Script 语言

分解这些例子，递归函数有两个主要部分:基本情况和递归情况。

在我们的阶乘函数中，我们使用一个`if/else`语句来分隔两者。现在，让我们一个命令一个命令地看一下这个函数实际上是如何执行的。

1.  调用`factorial(3)`被执行。在这个函数中，`3 * factorial(2)`的值应该被返回。所以，我们需要执行`factorial(2)`来完成我们的返回。
2.  调用`factorial(2)`被执行。请注意，我们的`factorial(3)`呼叫仍在等待完成。现在，`factorial(1)`必须进行评估。
3.  执行对`factorial(1)`的调用。`factorial(3)`和`factorial(2)`都在等待完成。我们向下递归到`factorial(0)`。
4.  对`factorial(0)`的调用返回`1`。
5.  现在，`factorial(1)`返回`1 * 1`，其中第二个 1 是`factorial(0)`的返回值。
6.  然后，`factorial(2)`返回`2 * 1`，其中 1 是`factorial(1)`的返回。
7.  最后，`factorial(3)`返回`3 * 2`，其中 2 是`factorial(2)`的返回。

用缩进可视化这些步骤有助于理解一切。

```
factorial(3)
  factorial(2)
    factorial(1)
      factorial(0) => returns 1
    returns 1 * 1
  returns 2 * 1
returns 3 * 2
```

因此，本质上，为了评估我们的原始函数调用`factorial(3)`，我们需要一遍又一遍地调用函数，直到遇到基本情况，打破递归循环，并允许所有先前的调用以相反的顺序进行评估。

# 我什么时候使用递归？

现在，我们已经完成了一个例子，我们需要一个令人信服的理由来花时间真正地记住和理解这个例子。

有时，递归是必要的。我最常用递归来操作复杂的数据结构，比如数组、字典和列表。

例如，如果我想从一个字典/对象中删除所有的空值，并且需要为嵌套的字典/对象做准备，那么我会使用这样的递归函数。

## 计算机编程语言

## Java Script 语言

# 结论

理解递归的局限性也很重要。递归函数非常占用内存。由于每个调用都要等待后续的递归调用，因此进程堆栈会很快变得很大。

学习实现递归函数，并在适当的时候识别用例。不是每一个可以用递归解决的问题都应该用递归解决；然而，一旦你需要它，你会很高兴它是你箭囊中的一支箭。

如果你现在明白了这个双关语，那么你已经在路上了！