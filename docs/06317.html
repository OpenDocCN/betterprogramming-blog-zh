<html>
<head>
<title>How to Do Text Search in MongoDB</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何在MongoDB中进行文本搜索</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/text-search-in-mongodb-34c1f70ab86d?source=collection_archive---------5-----------------------#2020-09-21">https://betterprogramming.pub/text-search-in-mongodb-34c1f70ab86d?source=collection_archive---------5-----------------------#2020-09-21</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="847f" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">从来没有这么简单</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/66b7ef2b0285edfebf8e94368877b6c4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*yrPY-D2SrJBx58Fj"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">照片由<a class="ae ky" href="https://unsplash.com/@ante_kante?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">安特·哈默斯特</a>在<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄。</p></figure><p id="8f3d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在大多数应用程序中，文本搜索是一个非常常见的需求，如果您在字段上创建了一个索引，您会希望大多数数据库都支持现成的文本搜索。</p><p id="9466" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">但是当我试图为我的应用程序实现文本搜索时，结果却复杂得多。经过一些研究，我发现了用<a class="ae ky" href="https://www.mongodb.com/" rel="noopener ugc nofollow" target="_blank"> MongoDB </a>实现文本搜索的三种主要方法。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="88b4" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">1.创建文本索引</h1><p id="8d81" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">如果你在谷歌上搜索“mongo全文搜索”，这是你会发现的第一种方法根据<a class="ae ky" href="https://docs.mongodb.com/manual/text-search/" rel="noopener ugc nofollow" target="_blank"> MongoDB的文档</a>，这是实现文本搜索最有效的方式。例如，考虑以下数据:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mz na l"/></div></figure><p id="10a7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在创建索引，因为索引将使它发生！</p><pre class="kj kk kl km gt nb nc nd ne aw nf bi"><span id="843e" class="ng md it nc b gy nh ni l nj nk">&gt; db.names.createIndex({ name: "text" })</span></pre><p id="7c3f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在尝试以下查询:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mz na l"/></div></figure><p id="87bc" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">正如您所看到的，如果您搜索<code class="fe nl nm nn nc b">Army</code>，它会在names列中显示所有包含单词<code class="fe nl nm nn nc b">Army</code>或该单词任何已知变体的文档。但这对<code class="fe nl nm nn nc b">Arm</code>不起作用。</p><p id="5f52" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">因此，当我们搜索<code class="fe nl nm nn nc b">Army</code>时，我们的文本搜索足够智能来匹配<code class="fe nl nm nn nc b">Armies</code>，但不会笨到部分匹配<code class="fe nl nm nn nc b">Arm</code>和<code class="fe nl nm nn nc b">Army</code>或<code class="fe nl nm nn nc b">Armies</code>。</p><p id="774c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我的产品经理希望(或者说期待)如果我搜索<code class="fe nl nm nn nc b">Arm</code>，它会显示我搜索<code class="fe nl nm nn nc b">Army</code>时出现的三个结果。</p><p id="76b1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">为了解决这个问题，我认为在我搜索<code class="fe nl nm nn nc b">Arm</code>而不是<code class="fe nl nm nn nc b">Army</code>时，了解为什么两个文档不匹配是个好主意。</p><p id="4bad" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">正如我所怀疑的，令牌化！文本索引通过空格将数据(在本例中是<code class="fe nl nm nn nc b">Army Ants</code>和<code class="fe nl nm nn nc b">Army of Ants</code>)分成标记。于是<code class="fe nl nm nn nc b">Army Ants</code>变成了<code class="fe nl nm nn nc b">[Army, Ants]</code>，<code class="fe nl nm nn nc b">Army of Ants</code>变成了<code class="fe nl nm nn nc b">[Army, of, Ants]</code>。并且当您搜索<code class="fe nl nm nn nc b">Army</code>时，该单词与两个文档中的一个标记相匹配，这就是当您搜索<code class="fe nl nm nn nc b">Army</code>时在结果中看到两个文档的原因。</p><p id="a5e2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><em class="no">注意:我在这里过于简单化了。标记化的实际过程包括更多的内容(例如，去除无关紧要的单词，如</em> <code class="fe nl nm nn nc b"><em class="no">of</em></code> <em class="no">)。</em></p><p id="d1a3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">因此，似乎用文本搜索来满足我们的总理的“希望”几乎是不可能的。您可能认为我们必须进入自动完成的世界。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="917d" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">2.使用简单但功能强大的旧正则表达式</h1><p id="5759" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">正则表达式在大多数数据库中是非常低效的，因为它们为我们提供了更加灵活的搜索方式，而技术总是需要权衡。我们用效率换取搜索的灵活性。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mz na l"/></div></figure><p id="b4fd" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">瞧啊。然而，这并不是一幅美丽的幕后画面。让我们戴上眼镜。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mz na l"/></div></figure><p id="b9b0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">看到那个躲在窗帘后面的<code class="fe nl nm nn nc b">COLLSCAN</code> <strong class="lb iu"> </strong>了吗？</p><p id="7aa0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们看看创建一个索引是否会让这一切变得更好。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mz na l"/></div></figure><p id="71e7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">嗯，<code class="fe nl nm nn nc b">IXSCAN</code>乍一看更好看。但是如果你够古怪，而且你的直觉不允许你认为事情会这么简单，那你就有得吃了。我们来看看<code class="fe nl nm nn nc b">executionStats</code>。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mz na l"/></div></figure><p id="9482" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">看<code class="fe nl nm nn nc b">totalKeysExamined</code>的值？就像索引中的所有键都被扫描了一样。让我们再添加几行，看看这个值是否成比例增加。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mz na l"/></div></figure><p id="7598" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe nl nm nn nc b">totalKeysExamined</code> <strong class="lb iu"> </strong>随着行数的增加而增加。所以很明显，我不能将它部署到生产环境中——即使它可以工作。整个索引扫描不好！</p><p id="42f0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">环顾了一下四周之后:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mz na l"/></div></figure><p id="60bb" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">所以这对于生产来说已经足够了！我们通过牺牲灵活性来限制扫描的行数(效率)。我们现在只能从名字开始匹配。</p><p id="8a7f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">但是任务还没有完成，不是吗？</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mz na l"/></div></figure><p id="8512" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">所以这不是匹配的<code class="fe nl nm nn nc b">Army of Ants</code>或<code class="fe nl nm nn nc b">Army Ants</code>，首相真的希望我也能做到这一点。</p><p id="31a6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我研究了一段时间，但没有找到任何可以让我开箱即用的东西。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="543a" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">3.黑掉它</h1><p id="9bc8" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">很明显，是时候进行一些创新思维了。</p><p id="e904" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">似乎我们的问题可以解决，如果我们可以用空格将名字分解，然后在每个分解的单词上使用带有<code class="fe nl nm nn nc b">^</code>的正则表达式。因此，如果我们可以将<code class="fe nl nm nn nc b">Army of Ants</code>分解成<code class="fe nl nm nn nc b">[Army, of, Ants]</code>，然后在所有分解的单词中搜索<code class="fe nl nm nn nc b">^Ant</code>，您将匹配<code class="fe nl nm nn nc b">Army of Ants</code>。</p><p id="a873" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">但是我们如何利用数据库来完成这些任务呢？MongoDB会比我们写的任何代码都更有效率。</p><p id="95e2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">数组字段来拯救。如果我们只是用空格将名字分开，将它们转换成一个列表(<code class="fe nl nm nn nc b">[Army, of, Ants]</code>)，并将其存储在一个数组字段中，我们就可以对每个名字进行<code class="fe nl nm nn nc b">^</code>正则表达式匹配。如果我们在这个字段上创建一个索引(<a class="ae ky" href="https://docs.mongodb.com/manual/core/index-multikey/" rel="noopener ugc nofollow" target="_blank"> multikey index </a>)，Mongo会处理它。</p><p id="d6d2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们看看它在新系列中的表现。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mz na l"/></div></figure><p id="5394" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">好吧，现在有用了。让我们检查一下我们是否仍然有效率。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mz na l"/></div></figure><p id="9a77" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">所以，很有效率。我们使用的是索引扫描，而不是扫描整个索引。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="0180" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">结论</h1><p id="df75" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">仅此而已。如果使用不当，数据库既复杂又低效。每个数据库都有一些限制，每当我们尝试新的东西时，我们必须确保它是有效的。否则，你只是在为自己将来的失败做准备。</p><p id="126c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">还记得我指出技术都是关于权衡的吗？你能看出最后一种方法的利弊吗？给我留言评论！</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="fffe" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">进一步阅读</h1><div class="np nq gp gr nr ns"><a href="https://scalegrid.io/blog/mongodb-regular-expressions-indexes-performance/" rel="noopener  ugc nofollow" target="_blank"><div class="nt ab fo"><div class="nu ab nv cl cj nw"><h2 class="bd iu gy z fp nx fr fs ny fu fw is bi translated">MongoDB正则表达式，索引和性能</h2><div class="nz l"><h3 class="bd b gy z fp nx fr fs ny fu fw dk translated">MongoDB支持使用$regex操作符的正则表达式。然而，这些MongoDB正则表达式查询有一个缺点…</h3></div><div class="oa l"><p class="bd b dl z fp nx fr fs ny fu fw dk translated">scalegrid.io</p></div></div><div class="ob l"><div class="oc l od oe of ob og ks ns"/></div></div></a></div><div class="np nq gp gr nr ns"><a href="https://docs.mongodb.com/manual/reference/method/db.collection.explain/index.html#explain-method-verbosity" rel="noopener  ugc nofollow" target="_blank"><div class="nt ab fo"><div class="nu ab nv cl cj nw"><h2 class="bd iu gy z fp nx fr fs ny fu fw is bi translated">db . collection . explain()-MongoDB手册</h2><div class="nz l"><h3 class="bd b gy z fp nx fr fs ny fu fw dk translated">的行为和返回的信息量取决于模式。queryPlanner模式(默认)执行启动…</h3></div><div class="oa l"><p class="bd b dl z fp nx fr fs ny fu fw dk translated">docs.mongodb.com</p></div></div><div class="ob l"><div class="oh l od oe of ob og ks ns"/></div></div></a></div><div class="np nq gp gr nr ns"><a href="https://docs.mongodb.com/manual/core/index-text/" rel="noopener  ugc nofollow" target="_blank"><div class="nt ab fo"><div class="nu ab nv cl cj nw"><h2 class="bd iu gy z fp nx fr fs ny fu fw is bi translated">文本索引- MongoDB手册</h2><div class="nz l"><h3 class="bd b gy z fp nx fr fs ny fu fw dk translated">MongoDB Atlas Search Atlas Search使在您的基础上构建快速、基于相关性的搜索功能变得非常容易</h3></div><div class="oa l"><p class="bd b dl z fp nx fr fs ny fu fw dk translated">docs.mongodb.com</p></div></div><div class="ob l"><div class="oi l od oe of ob og ks ns"/></div></div></a></div></div></div>    
</body>
</html>