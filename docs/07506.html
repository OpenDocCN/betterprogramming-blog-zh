<html>
<head>
<title>GraphQL Tutorial: How To Use Fields, Fragments, and More</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">GraphQL教程:如何使用字段、片段等等</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/graphql-tutorial-how-to-use-fields-fragments-and-more-ec478896ede7?source=collection_archive---------6-----------------------#2021-01-21">https://betterprogramming.pub/graphql-tutorial-how-to-use-fields-fragments-and-more-ec478896ede7?source=collection_archive---------6-----------------------#2021-01-21</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="d910" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">使用GraphQL的基本和中级概念构建复杂的应用程序</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/a52946e54c214209fec5e84e059e95db.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*bV1DBQjgT-9EOjGEGJhf3g.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">来源:作者</p></figure><p id="76a5" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">随着现代公司越来越依赖数据来完成日常任务，数据查询和操作正经历着历史性的普及。企业正在寻找能够在大量复杂数据的情况下高效产生结果的候选人和技术。</p><p id="ec27" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">GraphQL(图形查询语言)是许多公司正在寻找的答案。GraphQL提供了用于复杂查询的工具和获取调用的少即是多方法，预计它将很快取代REST API格式，成为未来就业市场的查询语言。</p><p id="6522" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">今天，我们将探索GraphQL的关键部分，并向您展示如何在您自己的模式中实现每一部分。</p><p id="44e0" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated"><strong class="kx ir">这是我们今天要讲的:</strong></p><ul class=""><li id="3eb2" class="lr ls iq kx b ky kz lb lc le lt li lu lm lv lq lw lx ly lz bi translated">GraphQL是什么？</li><li id="452d" class="lr ls iq kx b ky ma lb mb le mc li md lm me lq lw lx ly lz bi translated">图表QL构建模块</li><li id="d97e" class="lr ls iq kx b ky ma lb mb le mc li md lm me lq lw lx ly lz bi translated">中间GraphQL概念</li><li id="82ff" class="lr ls iq kx b ky ma lb mb le mc li md lm me lq lw lx ly lz bi translated">接下来学什么</li></ul></div><div class="ab cl mf mg hu mh" role="separator"><span class="mi bw bk mj mk ml"/><span class="mi bw bk mj mk ml"/><span class="mi bw bk mj mk"/></div><div class="ij ik il im in"><h1 id="5717" class="mm mn iq bd mo mp mq mr ms mt mu mv mw jw mx jx my jz mz ka na kc nb kd nc nd bi translated">什么是GraphQL</h1><p id="dc03" class="pw-post-body-paragraph kv kw iq kx b ky ne jr la lb nf ju ld le ng lg lh li nh lk ll lm ni lo lp lq ij bi translated">GraphQL是一种用于API的查询语言，它包括一个服务器端运行时来执行查询。GraphQL与Node、Express或Apollo等开源后端服务器软件一起使用。</p><p id="6a6d" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">GraphQL由脸书在2012年开发，旨在减少RESTful API格式中常见的空字段和迂回提取调用的数量。</p><p id="76cc" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">随着GraphQL的发展，该理念继续优先考虑减少任何行为的步骤数量。</p><p id="d891" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">REST API在特定的URL存储对象，但是GraphQL有一个用户创建的<strong class="kx ir">类型</strong>系统，它通过定义该类型的每个对象将拥有的一组<strong class="kx ir">字段</strong>来充当模板。您可以创建许多相同类型的对象，每个对象在定义的字段中都有自己的值。</p><p id="ed0a" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">这类似于Java等OOP语言中类和对象的关系。</p><p id="d33c" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">架构:</p><pre class="kg kh ki kj gt nj nk nl nm aw nn bi"><span id="0fa3" class="no mn iq nk b gy np nq l nr ns">{<br/>  data: {<br/>    User: {<br/>      name: "Jane Doe"<br/>    }<br/>  }<br/>}</span></pre><p id="8486" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">查询:</p><pre class="kg kh ki kj gt nj nk nl nm aw nn bi"><span id="eab4" class="no mn iq nk b gy np nq l nr ns">{<br/>  query User {<br/>    name<br/>  }<br/>}</span></pre><p id="8edc" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">在最简单的层面上，GraphQL是向不同的对象询问特定字段的值。这里的优点是GraphQL总是确切地知道您需要什么信息，并且只返回您想要的数据。</p><p id="b0ef" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">GraphQL允许您用复杂的查询超越这个简单的操作，这些查询可以导航嵌套的对象或使用对象突变修改获取的数据。</p></div><div class="ab cl mf mg hu mh" role="separator"><span class="mi bw bk mj mk ml"/><span class="mi bw bk mj mk ml"/><span class="mi bw bk mj mk"/></div><div class="ij ik il im in"><h1 id="a991" class="mm mn iq bd mo mp mq mr ms mt mu mv mw jw mx jx my jz mz ka na kc nb kd nc nd bi translated">GraphQL构建模块</h1><p id="7076" class="pw-post-body-paragraph kv kw iq kx b ky ne jr la lb nf ju ld le ng lg lh li nh lk ll lm ni lo lp lq ij bi translated">GraphQL的基本构件是<strong class="kx ir">模式</strong>和<strong class="kx ir">查询</strong>。</p><p id="a704" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated"><strong class="kx ir">模式</strong>:</p><p id="e7c2" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">GraphQL模式概述了数据可以分成的类别或<code class="fe nt nu nv nk b">type</code>。它还定义了每种类型将包含哪些信息。请将此视为显示数据库架构的蓝图。</p><pre class="kg kh ki kj gt nj nk nl nm aw nn bi"><span id="0fde" class="no mn iq nk b gy np nq l nr ns">type Book {<br/>        id: ID<br/>        title: String<br/>        published: Date<br/>        author: Author<br/>    }<br/>    type Author {<br/>        id: ID<br/>        name: String<br/>        book: [Book]<br/>    }</span></pre><p id="4bdb" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated"><strong class="kx ir">查询</strong>:</p><p id="ab6a" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">一旦你的数据被映射出来，你需要一种方法来获取它。GraphQL查询通过遵循到数据端点的输入路由来请求数据。返回的信息被称为<strong class="kx ir">有效载荷</strong>。</p><p id="46a3" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">这些可以是简单的请求，比如通过ID获取书名和作者。</p><pre class="kg kh ki kj gt nj nk nl nm aw nn bi"><span id="12fc" class="no mn iq nk b gy np nq l nr ns">type Query {<br/>        book(id: ID): Book<br/>        author(id: ID): Author<br/>    }</span></pre><p id="4a9d" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">查询也可能很复杂，比如询问姓名和简历，以及他们所写的所有书籍的名称。</p><pre class="kg kh ki kj gt nj nk nl nm aw nn bi"><span id="307e" class="no mn iq nk b gy np nq l nr ns">{<br/>        book(id: 100) {<br/>            title<br/>            isbn<br/>            date<br/>            author {<br/>                name<br/>                bio<br/>                books {<br/>                name<br/>                }<br/>            }<br/>        }<br/>    }</span></pre><p id="ae4b" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">下面，通过学习GraphQL的一些更具体的元素来更深入地研究模式和查询。</p><h2 id="89b4" class="no mn iq bd mo nw nx dn ms ny nz dp mw le oa ob my li oc od na lm oe of nc og bi translated">菲尔茨</h2><p id="8923" class="pw-post-body-paragraph kv kw iq kx b ky ne jr la lb nf ju ld le ng lg lh li nh lk ll lm ni lo lp lq ij bi translated"><code class="fe nt nu nv nk b">field</code>本质上是一个保存值的特定于对象的属性。对象的父类型定义了对象必须具有的字段。每个字段在定义时都被设置为保存特定的数据类型，如<code class="fe nt nu nv nk b">String</code>或<code class="fe nt nu nv nk b">Enum</code>。</p><p id="762d" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">让我们来看一个例子:</p><pre class="kg kh ki kj gt nj nk nl nm aw nn bi"><span id="91fa" class="no mn iq nk b gy np nq l nr ns">type User {<br/>   id: String!<br/>   email: String!<br/>   name: String<br/>}</span></pre><p id="c779" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">这里，我们有一个类型<code class="fe nt nu nv nk b">User</code>，我们将使用它作为模板来表示单个用户。每个类型为<code class="fe nt nu nv nk b">User</code>的对象都有三个字段:<code class="fe nt nu nv nk b">id</code>、<code class="fe nt nu nv nk b">email</code>和<code class="fe nt nu nv nk b">name</code>。</p><p id="9925" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">字段还可以引用其他对象来创建不同类型对象之间的层次结构。例如，我们可以向我们的<code class="fe nt nu nv nk b">User</code>添加一个<code class="fe nt nu nv nk b">friends</code>字段，其中包含一个填充了其他用户姓名的列表。</p><pre class="kg kh ki kj gt nj nk nl nm aw nn bi"><span id="6816" class="no mn iq nk b gy np nq l nr ns">type User {<br/>   id: String!<br/>   email: String!<br/>   name: String<br/>"friends": [<br/>        {<br/>          "name": "John Doe"<br/>        },<br/>        {<br/>          "name": "Jane Doe"<br/>        },<br/>        {<br/>          "name": "Guy Manson"<br/>        }<br/>}</span></pre><blockquote class="oh oi oj"><p id="c7c3" class="kv kw ok kx b ky kz jr la lb lc ju ld ol lf lg lh om lj lk ll on ln lo lp lq ij bi translated"><em class="iq">这里的</em> <code class="fe nt nu nv nk b"><em class="iq">!</em></code> <em class="iq">表示该字段不能保存</em> <code class="fe nt nu nv nk b"><em class="iq">null</em></code> <em class="iq">的值。换句话说，每个用户必须有一个</em> <code class="fe nt nu nv nk b"><em class="iq">id</em></code> <em class="iq">和</em> <code class="fe nt nu nv nk b"><em class="iq">email</em></code> <em class="iq">，但是</em> <code class="fe nt nu nv nk b"><em class="iq">name</em></code> <em class="iq">是可选的。</em></p></blockquote><p id="5611" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">GraphQL可以一次获取整个<code class="fe nt nu nv nk b">friends</code>列表对象，或者遍历该对象来查找特定的数据。这个函数允许您在一个查询中获取大量相关的数据/对象。</p><h2 id="7e94" class="no mn iq bd mo nw nx dn ms ny nz dp mw le oa ob my li oc od na lm oe of nc og bi translated">争论</h2><p id="cf32" class="pw-post-body-paragraph kv kw iq kx b ky ne jr la lb nf ju ld le ng lg lh li nh lk ll lm ni lo lp lq ij bi translated">GraphQL最有用的部分之一是可以将参数传递给查询中的任何字段或对象。与其他语言中的函数类似，字段接受参数，因为参数有一个名称和一个传递的值。然后，对象/字段将在引用参数名称的任何地方使用该值。</p><p id="355d" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">在REST API中，您只能发送查询参数和查询的URL段。GraphQL的方法允许您跳过几个查询，将参数传递给任何东西，并在一个查询中接收所需的确切信息。</p><p id="6175" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">参数最常见的用途是过滤您在类型中查询的对象。例如，我们可以在接受<code class="fe nt nu nv nk b">id</code>参数的<code class="fe nt nu nv nk b">User</code>类型中包含<code class="fe nt nu nv nk b">getUser</code>字段。由于每个用户都有一个特定的<code class="fe nt nu nv nk b">id</code>，这将允许我们轻松地获取关于特定用户的信息。</p><pre class="kg kh ki kj gt nj nk nl nm aw nn bi"><span id="6d0c" class="no mn iq nk b gy np nq l nr ns">{<br/>  getName(id: "1010") {<br/>    name<br/>  }<br/>}</span></pre><h2 id="704f" class="no mn iq bd mo nw nx dn ms ny nz dp mw le oa ob my li oc od na lm oe of nc og bi translated">别名</h2><p id="e92f" class="pw-post-body-paragraph kv kw iq kx b ky ne jr la lb nf ju ld le ng lg lh li nh lk ll lm ni lo lp lq ij bi translated">如果我们用不同的参数查询同一个字段，GraphQL将抛出一个错误。假设我们有自己的<code class="fe nt nu nv nk b">user</code>对象，并希望通过一个已实现的“subscriptionStatus”参数来过滤它们。</p><pre class="kg kh ki kj gt nj nk nl nm aw nn bi"><span id="16b5" class="no mn iq nk b gy np nq l nr ns">query getUsers {<br/>  user(subscriptionStatus: SUBSCRIBED) {<br/>  id<br/>  email<br/>  name<br/>  }<br/>  user(subscriptionStatus: UNSUBSCRIBED) {<br/>  id<br/>  email<br/>  name<br/>  }<br/>}</span></pre><p id="40a5" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">这将抛出一个错误，因为后面对<code class="fe nt nu nv nk b">users</code>类型的查询将覆盖前面的查询。</p><pre class="kg kh ki kj gt nj nk nl nm aw nn bi"><span id="080c" class="no mn iq nk b gy np nq l nr ns">message: "Fields "user" conflict because they have differing arguments. Use different aliases on the fields to fetch both if this was intentional."</span></pre><p id="b945" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">正如错误所说，我们需要为这些查询设置<strong class="kx ir">别名</strong>来同时获取这两个。您可以将别名视为一个类型中特定子组的昵称。</p><p id="eaa0" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">我们将为<code class="fe nt nu nv nk b">subscriptionStatus</code>为<code class="fe nt nu nv nk b">SUBSCRIBED</code>的用户对象设置别名<code class="fe nt nu nv nk b">subscribers</code>:</p><pre class="kg kh ki kj gt nj nk nl nm aw nn bi"><span id="5e49" class="no mn iq nk b gy np nq l nr ns">query getUsers {<br/>  subscribers: user(subscriptionStatus: SUBSCRIBED) {<br/>  id<br/>  email<br/>  name<br/>  }</span></pre><p id="26b3" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">我们可以稍后使用<code class="fe nt nu nv nk b">subscribers</code>别名作为快捷方式，随时查询<code class="fe nt nu nv nk b">user</code>的这个子组。别名是将更广泛的类型划分为更具体的组的有效方法，您将经常一起查询这些组。</p></div><div class="ab cl mf mg hu mh" role="separator"><span class="mi bw bk mj mk ml"/><span class="mi bw bk mj mk ml"/><span class="mi bw bk mj mk"/></div><div class="ij ik il im in"><h1 id="69a8" class="mm mn iq bd mo mp mq mr ms mt mu mv mw jw mx jx my jz mz ka na kc nb kd nc nd bi translated">中间GraphQL概念</h1><h2 id="9a45" class="no mn iq bd mo nw nx dn ms ny nz dp mw le oa ob my li oc od na lm oe of nc og bi translated">碎片</h2><p id="7087" class="pw-post-body-paragraph kv kw iq kx b ky ne jr la lb nf ju ld le ng lg lh li nh lk ll lm ni lo lp lq ij bi translated">在复杂的应用程序中，您可能会有几个引用相同字段的操作。简而言之，GraphQL包含了<strong class="kx ir">片段</strong>，允许您包装一组字段，以便在不同的查询中重用。片段是为一个对象类型定义的，比如<code class="fe nt nu nv nk b">User</code>，它们可以在任何以这些对象为特征的操作中使用。</p><p id="36d0" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">下面，我们将重新制作之前的参数示例，但这次用我们的<code class="fe nt nu nv nk b">AccountInfo</code>片段替换相同的字段。</p><p id="a75c" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">没有碎片:</p><pre class="kg kh ki kj gt nj nk nl nm aw nn bi"><span id="e2a4" class="no mn iq nk b gy np nq l nr ns">query getUsers {<br/>     subscribers: user(subscriptionStatus: SUBSCRIBED) {<br/>  id<br/>  email<br/>  name<br/>  }</span><span id="1114" class="no mn iq nk b gy oo nq l nr ns">  nonSubscribers: user(subscriptionStatus: UNSUBSCRIBED) {<br/>  id<br/>  email<br/>  name<br/>  }</span></pre><p id="5a14" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated"><strong class="kx ir">带片段:</strong></p><pre class="kg kh ki kj gt nj nk nl nm aw nn bi"><span id="4855" class="no mn iq nk b gy np nq l nr ns">query getUsers {<br/>     subscribers: user(subscriptionStatus: SUBSCRIBED) {<br/>  id<br/>  ...AccountInfo</span><span id="b45d" class="no mn iq nk b gy oo nq l nr ns">  nonSubscribers: user(subscriptionStatus: UNSUBSCRIBED) {<br/>  id<br/>  ...AccountInfo<br/>  }</span><span id="eeb7" class="no mn iq nk b gy oo nq l nr ns">fragment AccountInfo on User{<br/>  email<br/>  name<br/>}</span></pre><p id="c2fc" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">这两个代码段完成相同的行为。片段的优点是它们简化了我们的查询可读性，并允许我们模块化查询以便重用。</p><h2 id="0ba8" class="no mn iq bd mo nw nx dn ms ny nz dp mw le oa ob my li oc od na lm oe of nc og bi translated">变量</h2><p id="5163" class="pw-post-body-paragraph kv kw iq kx b ky ne jr la lb nf ju ld le ng lg lh li nh lk ll lm ni lo lp lq ij bi translated">有时，我们希望在查询中包含动态参数选项，比如在创建搜索栏时。GraphQL允许使用<strong class="kx ir">变量</strong>的动态参数。变量充当占位符，指向成对的JSON文件中的一个字段。</p><p id="af16" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">要实现一个变量，我们必须做三个改变:</p><ul class=""><li id="927d" class="lr ls iq kx b ky kz lb lc le lt li lu lm lv lq lw lx ly lz bi translated">用可变锚点替换静态参数，<code class="fe nt nu nv nk b">$subscriptionStatus: Subscription</code></li><li id="d8d5" class="lr ls iq kx b ky ma lb mb le mc li md lm me lq lw lx ly lz bi translated">将<code class="fe nt nu nv nk b">$subscriptionStatus</code>声明为查询接受的变量之一</li><li id="dbb6" class="lr ls iq kx b ky ma lb mb le mc li md lm me lq lw lx ly lz bi translated">在单独的变量字典文件(通常是JSON)中传递<code class="fe nt nu nv nk b">Subscription: value</code></li></ul><p id="d6a5" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">查询:</p><pre class="kg kh ki kj gt nj nk nl nm aw nn bi"><span id="5c48" class="no mn iq nk b gy np nq l nr ns">query getUsers ($subscriptionStatus: Subscription) {<br/>    user(subscriptionStatus: $subscriptionStatus) {<br/>  id<br/>  ...AccountInfo<br/>    }<br/>}</span></pre><p id="9b29" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">变量字典:</p><pre class="kg kh ki kj gt nj nk nl nm aw nn bi"><span id="1473" class="no mn iq nk b gy np nq l nr ns">"subscriptionStatus": "SUBSCRIBED"</span></pre><p id="4f7d" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">现在，我们可以通过简单地改变变量字典中<code class="fe nt nu nv nk b">subscriptionStatus</code>的值来改变我们在整个程序中分析的用户组。</p><p id="f664" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">因此，变量允许您的查询具有适应性，并拓宽了行为的可重用性。</p><h2 id="4e85" class="no mn iq bd mo nw nx dn ms ny nz dp mw le oa ob my li oc od na lm oe of nc og bi translated">突变</h2><p id="9427" class="pw-post-body-paragraph kv kw iq kx b ky ne jr la lb nf ju ld le ng lg lh li nh lk ll lm ni lo lp lq ij bi translated">查询让您获取数据，而<strong class="kx ir">突变</strong>让您创建、更新或删除服务器端数据。您可以将突变视为来自REST API的<code class="fe nt nu nv nk b">POST</code>的GraphQL等价物。</p><p id="0f2f" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">要实现变异，您需要设置字段名和它将接受的参数。想象一下，我们正试图添加一个突变，使我们能够创建更多的<code class="fe nt nu nv nk b">User</code>对象。我们需要创建一个变异查询，它将接受帐户创建的所有基本信息:</p><pre class="kg kh ki kj gt nj nk nl nm aw nn bi"><span id="6a23" class="no mn iq nk b gy np nq l nr ns">mutation createUser(email: String!, password: String!) {<br/>   createUser(email: $email, password: $password) {<br/>      id<br/>      email<br/>      password<br/>}</span></pre><p id="d66b" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">首先，我们声明<code class="fe nt nu nv nk b">createUser</code>将是一个突变，并接受名为<code class="fe nt nu nv nk b">email</code>和<code class="fe nt nu nv nk b">password</code>的参数。然后在<strong class="kx ir">第2行</strong>中，我们声明这些参数将用于填充下面单独的<code class="fe nt nu nv nk b">email</code>和<code class="fe nt nu nv nk b">password</code>字段。</p><p id="72ca" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">在<em class="ok">细粒度</em>和<em class="ok">粗粒度</em>之间存在变异，前者意味着它只编辑几个特定的字段，后者编辑整个类型。</p><h2 id="0c19" class="no mn iq bd mo nw nx dn ms ny nz dp mw le oa ob my li oc od na lm oe of nc og bi translated">指令</h2><p id="d32d" class="pw-post-body-paragraph kv kw iq kx b ky ne jr la lb nf ju ld le ng lg lh li nh lk ll lm ni lo lp lq ij bi translated">有时我们只想在特定条件下获取字段的值。为此，我们可以使用<strong class="kx ir">指令</strong>，它告诉服务器跳过或包含一个字段。指令总是包括一个类似<code class="fe nt nu nv nk b">if</code>的条件语句和一个布尔变量。</p><p id="d2ed" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">有了这个特性，您可以跳过复杂的字符串操作，或者允许您在UI读数上实现“显示更多”按钮。</p><p id="07ae" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">两种类型的基本指令充当逻辑开关。如果布尔值为真，则每个指令都激活，以避免双重否定；<code class="fe nt nu nv nk b">include</code>表示当布尔值为<code class="fe nt nu nv nk b">true</code>时显示该字段，当布尔值为<code class="fe nt nu nv nk b">true</code>时<code class="fe nt nu nv nk b">skip</code>表示不显示该字段。</p><ul class=""><li id="1112" class="lr ls iq kx b ky kz lb lc le lt li lu lm lv lq lw lx ly lz bi translated"><code class="fe nt nu nv nk b">@include(if: Boolean)</code>仅当参数为<code class="fe nt nu nv nk b">true</code>时，才在结果中包含该字段。</li><li id="c498" class="lr ls iq kx b ky ma lb mb le mc li md lm me lq lw lx ly lz bi translated"><code class="fe nt nu nv nk b">@skip(if: Boolean)</code>如果参数为<code class="fe nt nu nv nk b">true</code>，则跳过该字段。假设我们想获取用户数据，但只希望在特定设置被选中时包含电子邮件地址。</li></ul><p id="7188" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">查询:</p><pre class="kg kh ki kj gt nj nk nl nm aw nn bi"><span id="8803" class="no mn iq nk b gy np nq l nr ns">{<br/>query getUsers {<br/>User {   <br/>   name<br/>   email @include(if: $showEmail)<br/>  }<br/>}</span></pre><p id="ad07" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">变量字典:</p><pre class="kg kh ki kj gt nj nk nl nm aw nn bi"><span id="6375" class="no mn iq nk b gy np nq l nr ns">"showEmail": true</span></pre></div><div class="ab cl mf mg hu mh" role="separator"><span class="mi bw bk mj mk ml"/><span class="mi bw bk mj mk ml"/><span class="mi bw bk mj mk"/></div><div class="ij ik il im in"><h1 id="811c" class="mm mn iq bd mo mp mq mr ms mt mu mv mw jw mx jx my jz mz ka na kc nb kd nc nd bi translated">接下来学什么</h1><p id="2747" class="pw-post-body-paragraph kv kw iq kx b ky ne jr la lb nf ju ld le ng lg lh li nh lk ll lm ni lo lp lq ij bi translated">既然您已经看到了GraphQL的所有基本功能，那么您就可以探索更高级的概念了，比如解析器或者将GraphQL与后端软件相结合。</p><p id="869b" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">随着越来越多的企业采用数据驱动的方法，对API和数据操作的需求正在上升。现在是提升GraphQL技能的最佳时机。</p><p id="bb16" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated"><em class="ok">快乐学习！</em></p></div></div>    
</body>
</html>