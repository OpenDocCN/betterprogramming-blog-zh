<html>
<head>
<title>Securely Storing Your Credentials With HashiCorp Vault: Overview and Initialization</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用HashiCorp Vault安全存储您的凭证:概述和初始化</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/securely-storing-your-credentials-with-hashicorp-vault-overview-and-initialization-66cffe37733c?source=collection_archive---------8-----------------------#2022-01-12">https://betterprogramming.pub/securely-storing-your-credentials-with-hashicorp-vault-overview-and-initialization-66cffe37733c?source=collection_archive---------8-----------------------#2022-01-12</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="52ae" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">开始使用HashiCorp Vault安全存储您的数据科学凭据</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/a5ab05b4c895c41839942759bbdb62e7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*WMtrz_Y188ymSNHozfBDYQ.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">作者创建的标题图像</p></figure><p id="20f9" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">大家好！我们又回来了，推出了另一个关于如何安全存储您的凭据的新系列。本系列将带您了解如何使用<strong class="la iu"> HashiCorp Vault无缝地完成这项工作。</strong>(我就简称为<a class="ae lu" href="https://www.vaultproject.io" rel="noopener ugc nofollow" target="_blank">跳马</a>往前走。)</p><p id="5469" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">你可能熟悉HashiCorp，因为他们也维护Terraform，这是我们在<a class="ae lu" href="https://towardsdatascience.com/tagged/terraform-sagemaker" rel="noopener" target="_blank">与AWS SageMaker </a>合作的另一个系列中报道的另一个产品。</p><p id="e6c8" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">HashiCorp在使产品无缝交互方面做得很好，我们将在这个新系列中继续演示Terraform和Vault如何相互交互。</p><p id="76f1" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">出于本系列的目的，我们将让事情变得非常简单。这里的想法是给你一个更多的“从业者的视角”如何在日常基础上与Vault交互。也就是说，创建一个高可用性、容错的架构，并使用基于硬件的密钥来保护，这不在讨论范围之内。如果你在一个更大的组织中工作，我会认为这样的事情非常重要，但是应该由一个专门的“保险库管理”团队来管理。</p><p id="f80f" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">但是，即使我们不会使用企业级版本的Vault，我们仍然需要自己进行一些设置，以启动和运行我们自己的小型Vault服务器。虽然Vault确实为示例使用提供了“开发模式”,但我们将创建一个小型架构，它将在我们的本地计算机上持续运行，以便我们可以继续使用它。</p><p id="4780" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">在我们进入该体系结构之前，让我们简单地讨论一下为什么您可能会考虑跳过另一个解决方案。</p><h1 id="6747" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">为什么跳马？</h1><p id="fe02" class="pw-post-body-paragraph ky kz it la b lb mn ju ld le mo jx lg lh mp lj lk ll mq ln lo lp mr lr ls lt im bi translated">显然，Vault不是唯一的凭据存储解决方案。每个云提供商都有自己的本地解决方案，虽然我个人不熟悉其他本地解决方案，但我不得不相信可能还有其他解决方案。但像Terraform一样，Vault的伟大之处在于它可以覆盖所有那些云提供商、本地提供商等等。</p><p id="0364" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">Vault是一个开源产品，它做了很多非常酷的事情来帮助支持敏感凭据的安全存储和检索。事实上，它的作用如此之大，以至于我们可能不会在本系列中涉及它的所有功能。下面是Vault可以做的一些事情:</p><ul class=""><li id="28fe" class="ms mt it la b lb lc le lf lh mu ll mv lp mw lt mx my mz na bi translated">通过CLI、API或UI安全地存储和检索敏感凭据(喜欢这种灵活性！)</li><li id="26e2" class="ms mt it la b lb nb le nc lh nd ll ne lp nf lt mx my mz na bi translated">存储可以根据需要进行版本控制或旋转的静态键值对</li><li id="72c2" class="ms mt it la b lb nb le nc lh nd ll ne lp nf lt mx my mz na bi translated">动态生成令牌以与包括AWS、Google云平台和Microsoft Azure在内的云提供商进行交互</li><li id="db90" class="ms mt it la b lb nb le nc lh nd ll ne lp nf lt mx my mz na bi translated">允许企业级使用高可用性、容错后端存储</li><li id="92a2" class="ms mt it la b lb nb le nc lh nd ll ne lp nf lt mx my mz na bi translated">支持多种存储后端类型，包括本地存储、云存储和网络连接存储</li><li id="cc01" class="ms mt it la b lb nb le nc lh nd ll ne lp nf lt mx my mz na bi translated">使用各种机制在根级别保护Vault，包括基于云的加密密钥甚至基于硬件的密钥</li></ul><p id="97d2" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">与Terraform类似，Vault也提供分层服务，包括一个完全免费的层。虽然您可能想为大型组织考虑企业级版本的Vault(称为Vault Enterprise ),但它非常方便，因为我们可以完全免费创建自己的小型架构。我不知道你怎么想，但是我喜欢免费的！</p><p id="4179" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">正如我在上面提到的，我们可以通过我们的Vault体系结构的耐用性和可用性获得真正的健壮性，但是对于我们前面提到的“从业者的视角”，我认为更简单的体系结构就可以了。为此，让我们来看看这个架构是什么样子的！</p><h1 id="4798" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">我们的金库建筑</h1><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ng"><img src="../Images/84be71e6725fdf463161d6ce3ebff01d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Zy9ck7hs6A1eRgp9R1ntYA.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">作者创作的图形</p></figure><p id="9af4" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">正如你可能猜到的，我是一个喜欢图片的人，所以我创建了上面的图表来帮助我们了解更多。如果图片现在有点混乱，不要担心，因为我们肯定会在接下来的小节中把事情弄清楚。您会注意到，我们的保险库架构基本上有两个组件:</p><ul class=""><li id="e4f4" class="ms mt it la b lb lc le lf lh mu ll mv lp mw lt mx my mz na bi translated"><strong class="la iu">金库服务器</strong>:这个小服务器将允许我们以三种不同的能力与金库后端交互:用户界面(UI)、命令行界面(CLI)或API。我们不会在这篇文章中讨论这些交互，但是请继续关注，因为我们肯定会在以后的文章中讨论这三个问题！</li><li id="b907" class="ms mt it la b lb nb le nc lh nd ll ne lp nf lt mx my mz na bi translated"><strong class="la iu"> Vault后端</strong>:虽然Vault允许多种不同的后端类型，但我们将通过在本地机器上初始化一个后端来简化事情。这就像定义一个我们希望Vault存储加密凭证的目录一样简单。</li></ul><p id="9a38" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">虽然这看起来令人生畏，但是建立并运行这个架构实际上非常容易！在接下来的小节中我们如何启用这个架构之前，我已经在我的GitHub repo 中维护了下面的代码<a class="ae lu" href="https://github.com/dkhundley/vault-101" rel="noopener ugc nofollow" target="_blank">。本报告中的<code class="fe nh ni nj nk b">README</code>还包含了完成本教程所需安装的一些依赖项。</a></p><p id="38e9" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">现在，最后，让我们进入创建这个架构的第一部分！</p><h2 id="8593" class="nl lw it bd lx nm nn dn mb no np dp mf lh nq nr mh ll ns nt mj lp nu nv ml nw bi translated">1.启动Vault服务器</h2><p id="19d9" class="pw-post-body-paragraph ky kz it la b lb mn ju ld le mo jx lg lh mp lj lk ll mq ln lo lp mr lr ls lt im bi translated">我们需要做的第一件事是启动Vault服务器，为了做到这一点，我们首先需要创建一个小的配置文件，说明应该如何创建Vault。如果你不熟悉HashiCorp，他们维护自己的语法语言<strong class="la iu"> HashiCorp配置语言(HCL) </strong>，所以下面的配置是用HCL写的。我们的配置如下所示:</p><pre class="kj kk kl km gt nx nk ny nz aw oa bi"><span id="cc4b" class="nl lw it nk b gy ob oc l od oe">storage "raft" {<br/>    path = "./sensitive/data"<br/>    node_id = "node1"<br/>}</span><span id="86df" class="nl lw it nk b gy of oc l od oe">listener "tcp" {<br/>    address = "127.0.0.1:8200"<br/>    tls_disable = "true"<br/>}</span><span id="bf46" class="nl lw it nk b gy of oc l od oe">api_addr = "http://127.0.0.1:8200"<br/>cluster_addr = "https://127.0.0.1:8201"<br/>ui = true</span></pre><p id="5dd3" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">让我们来分析一下到底发生了什么:</p><ul class=""><li id="27eb" class="ms mt it la b lb lc le lf lh mu ll mv lp mw lt mx my mz na bi translated"><strong class="la iu">“raft”存储块</strong>:存储块记录了后端类型和我们将存储Vault加密数据的位置。在这种情况下，“raft”指的是本地存储(很明显，我不知道它为什么被称为raft)，它将数据存储在我的Git repo的位置中的<code class="fe nh ni nj nk b">./sensitive/data</code>下。你可以把这个改成任何你想要的。如果你进入我的个人GitHub repo，你会注意到没有一个叫做<code class="fe nh ni nj nk b">sensitive</code>的目录。这是因为我使用了一个<code class="fe nh ni nj nk b">.gitignore</code>文件来确保这个目录不会被推送到GitHub。该目录将在下一节中用于另一个目的。</li><li id="9456" class="ms mt it la b lb nb le nc lh nd ll ne lp nf lt mx my mz na bi translated"><strong class="la iu">“监听器”块</strong>:该块记录了我们将使用什么IP地址与Vault进行交互。默认情况下，Vault会将API / UI地址放在<code class="fe nh ni nj nk b">127.0.0.1:8200</code>(或<code class="fe nh ni nj nk b">localhost:8200</code>)，并将集群地址放在<code class="fe nh ni nj nk b">127.0.0.1:8201</code>。同样，这可以根据您的需要进行更改，但我将保持默认值不变。</li><li id="d8b5" class="ms mt it la b lb nb le nc lh nd ll ne lp nf lt mx my mz na bi translated"><strong class="la iu">其他内容</strong>:基于前面的代码块，配置文件末尾的最后一点应该是不言自明的。还要注意，我们通过设置<code class="fe nh ni nj nk b">ui = true</code>来启用用户界面。</li></ul><p id="3341" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">在我的Git repo中，我将这个文件存储为<code class="fe nh ni nj nk b">config/vault_config.hcl</code>。要实际启动Vault服务器，我们需要运行以下命令:</p><pre class="kj kk kl km gt nx nk ny nz aw oa bi"><span id="f5c2" class="nl lw it nk b gy ob oc l od oe">vault server -config=config/vault_config.hcl</span></pre><p id="e0a2" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">如果成功，您应该会看到类似下面的截图。请注意，如果您想继续与您的终端交互，您需要打开一个新窗口。但是你仍然可以完全关闭终端。只要您不明确停止Vault服务器，它就不会自行停止。如果您确实关闭了您的终端，然后决定停止您的服务器，下面的命令就可以解决这个问题:</p><pre class="kj kk kl km gt nx nk ny nz aw oa bi"><span id="fc7c" class="nl lw it nk b gy ob oc l od oe">kill $(ps aux | grep vault\ server\ -config | awk '{print $2}')</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi og"><img src="../Images/a8898871582c3e0c95a8bbc5985a28f9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*HGby_QROZvcV9Vu05rBhvA.jpeg"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">作者截图</p></figure><p id="7177" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">该命令不仅会启动Vault服务器，还会在<strong class="la iu">密封状态</strong>下创建您的Vault。让我们在下一节讨论这意味着什么。</p><h2 id="ab26" class="nl lw it bd lx nm nn dn mb no np dp mf lh nq nr mh ll ns nt mj lp nu nv ml nw bi translated">2.正在初始化存储库操作员</h2><p id="bffd" class="pw-post-body-paragraph ky kz it la b lb mn ju ld le mo jx lg lh mp lj lk ll mq ln lo lp mr lr ls lt im bi translated">启动Vault服务器时，您的Vault后端将在加密模式下初始化，在您的Vault解封之前，您将完全无法与该Vault后端进行交互。创建新的Vault服务器时，作为“操作员”的您需要首先初始化启封Vault的过程。</p><p id="f1f3" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">在我们展示命令如何做到这一点之前，让我们谈一谈打开保险库。自然，这可能是一个极其敏感的过程。你不希望任何人打开你的保险库，所以有很多方法可以打开保险库。正如我上面提到的，我们可以用类似云提供商甚至硬件密钥的东西来解封保险库，但出于我们的目的，我们将使用默认的<strong class="la iu">沙米尔的封印。</strong> Shamir的seal基本上是一种高级加密算法，它采用一个主加密密钥，然后根据您的需要将其拆分成任意多个密钥。这个想法是，然后你把每把钥匙给每一个单独委托的人。理论上这是一个非常酷的概念。我从HashiCorp网站上获得的图片很好地说明了这个概念:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi oh"><img src="../Images/b7d06fedfb1ca95bff6096f7b7f77b77.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*rGsr_9anW6c9EXZiOhGs0A.jpeg"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">图片来自哈希公司的金库网站(<a class="ae lu" href="https://learn.hashicorp.com/tutorials/vault/rekeying-and-rotating" rel="noopener ugc nofollow" target="_blank">链接</a>)</p></figure><p id="4aa3" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">默认情况下，Vault的Shamir封条将加密密钥分成5个密钥部分，提取主加密密钥需要其中的3个密钥部分。这可以根据您的偏好进行调整，因此出于简单的目的，我们将把它缩减为1个密钥共享。我们还将把这个密钥保存到一个JSON文件中，这样，如果我们重新启动本地计算机，就可以简单地重新启动Vault服务器。不言而喻，但请允许我重申:<em class="oi">这是</em> <strong class="la iu"> <em class="oi">而不是</em> </strong> <em class="oi">对真实世界设定的理想实践</em>。在现实世界的设置中，您至少应该使用HashiCorp默认的默认密钥共享，或者更好的是，使用类似硬件密钥的东西。</p><p id="2d07" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">为了生成这个Shamir密钥并在一行中将其保存到JSON文件中，您需要运行以下命令:</p><pre class="kj kk kl km gt nx nk ny nz aw oa bi"><span id="33ed" class="nl lw it nk b gy ob oc l od oe">vault operator init -format=json -key-shares 1 -key-threshold 1 &gt; sensitive/vault_creds.json</span></pre><p id="143b" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">如果这个命令成功，您应该能够查看JSON文件并看到下面的屏幕截图。(而且应该大概不用说了吧，不过我写了这篇帖子之后就把自己的金库作废了，所以下面截图里的这些凭证对你没什么好处。)</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi oj"><img src="../Images/746112004ebd28c5fe48972b36b512c1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*8U9xRmMOPfvlHW0Or0PRig.jpeg"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">作者截图</p></figure><p id="2324" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">我们特别关心两件事:</p><ul class=""><li id="ffdd" class="ms mt it la b lb lc le lf lh mu ll mv lp mw lt mx my mz na bi translated">这是我们刚刚生成的单个Shamir密钥的base64编码版本。在下一小节中，我们将需要这个来实际开启我们的保险库。</li><li id="7fb9" class="ms mt it la b lb nb le nc lh nd ll ne lp nf lt mx my mz na bi translated"><code class="fe nh ni nj nk b">root_token</code>:这是保险库根令牌，一旦它解封并运行，我们将使用它实际进入保险库。在这篇文章中我们不会做太多，但它对以后的文章很重要。</li></ul><h2 id="9926" class="nl lw it bd lx nm nn dn mb no np dp mf lh nq nr mh ll ns nt mj lp nu nv ml nw bi translated">3.开启保险库</h2><p id="6525" class="pw-post-body-paragraph ky kz it la b lb mn ju ld le mo jx lg lh mp lj lk ll mq ln lo lp mr lr ls lt im bi translated">Vault服务器正在运行？检查！运算符已初始化？检查！手里拿着沙米尔的钥匙？检查！我们现在准备使用JSON文件中的Shamir密钥打开我们的保险库。在此之前，如果您运行<code class="fe nh ni nj nk b">vault status</code>命令，您应该会看到如下所示:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi ok"><img src="../Images/2aad112caa36ba69cd7cd3bb711e177c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1250/format:webp/1*ubFD5M3ku94AJhnpwvuu-w.jpeg"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">作者截图</p></figure><p id="9daf" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">注意这里的<code class="fe nh ni nj nk b">Sealed</code>处于<code class="fe nh ni nj nk b">true</code>状态。当我们解封我们的保险库并再次运行该命令时，<code class="fe nh ni nj nk b">Sealed</code>状态将自然变为<code class="fe nh ni nj nk b">false</code>。</p><p id="5998" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">因为我们将Shamir密匙存储在JSON文件中，所以我们将使用另一个名为<code class="fe nh ni nj nk b">jq</code>的CLI工具来使用一点自动化魔法，从JSON文件中提取密匙作为环境变量，然后将该密匙输入到解封保险库的命令中。看起来是这样的:</p><pre class="kj kk kl km gt nx nk ny nz aw oa bi"><span id="a2d8" class="nl lw it nk b gy ob oc l od oe"># Getting creds from the JSON file<br/>export VAULT_UNSEAL_KEY=`jq -r '.unseal_keys_b64[0]' sensitive/vault_creds.json`</span><span id="c52b" class="nl lw it nk b gy of oc l od oe"># Unsealing the Vault with the Vault unseal key<br/>vault operator unseal $VAULT_UNSEAL_KEY</span></pre><p id="b767" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">运行该命令后，会显示以下屏幕截图。正如所料，<code class="fe nh ni nj nk b">Sealed</code>状态现在是<code class="fe nh ni nj nk b">false</code>，这意味着我们成功地解封了我们的保险库！</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ol"><img src="../Images/90f362dc315dbe667a79caff26fb4ab4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ayP_MXapLW2WWw6gx5Pwqw.jpeg"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">作者截图</p></figure><h2 id="8026" class="nl lw it bd lx nm nn dn mb no np dp mf lh nq nr mh ll ns nt mj lp nu nv ml nw bi translated">验证我们的保险库正在运行</h2><p id="6dde" class="pw-post-body-paragraph ky kz it la b lb mn ju ld le mo jx lg lh mp lj lk ll mq ln lo lp mr lr ls lt im bi translated">虽然我们不会在这篇文章中涉及更多，但我想你可能想验证你的保险库是否真的在运行！让我们通过用户界面登录Vault来验证这一点。为此，请打开任何web浏览器，导航到您在上面的配置中定义的任何地址。如果你坚持我所做的，这将是<code class="fe nh ni nj nk b">localhost:8200</code>。这是您应该看到的屏幕:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi og"><img src="../Images/3bb2b244082f4688a7adf6c02c053714.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ngn8NE_YlwJmgWjFP76uZA.jpeg"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">作者截图</p></figure><p id="0a15" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">还记得我们作为JSON文件的一部分存储在Shamir密钥旁边的根令牌吗？是时候利用这一点了！将该令牌复制并粘贴到此处的“令牌”字段，然后单击“登录”如果你做对了，这是你应该看到的屏幕:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi og"><img src="../Images/d97b70abe7d311ed263db6a0c4a5a9de.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*6xxUvq2zNj_7t3u9vbpMZA.jpeg"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">作者截图</p></figure><p id="1ca5" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">恭喜你。您现在拥有了自己的小型Vault服务器！</p><p id="c473" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">现在，在我们结束这篇文章之前，还有一件小事要做…</p><h1 id="2c5e" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">如果你重启你的机器会怎么样？</h1><p id="eebb" class="pw-post-body-paragraph ky kz it la b lb mn ju ld le mo jx lg lh mp lj lk ll mq ln lo lp mr lr ls lt im bi translated">当您重新启动机器时，您的Vault不会消失，但是Vault服务器会关闭，Vault会回到密封状态。幸运的是，有一种方法可以让保险库起死回生，只需重新启动保险库服务器并再次解封保险库。本着自动化的精神，我创建了一个脚本，让macOS的Automator在启动时自动为我执行这个任务。我不打算深入了解它是如何工作的，但我的Automator脚本看起来是这样的:</p><pre class="kj kk kl km gt nx nk ny nz aw oa bi"><span id="01bc" class="nl lw it nk b gy ob oc l od oe"># Changing the working directory appropriately<br/>cd ~<br/>cd Documents/Repositories/vault-101</span><span id="35da" class="nl lw it nk b gy of oc l od oe"># Noting the proper Vault address as an environemnt variableexport VAULT_ADDR='http://127.0.0.1:8200'</span><span id="596a" class="nl lw it nk b gy of oc l od oe"># Getting creds from the JSON file<br/>export VAULT_UNSEAL_KEY=`/opt/homebrew/bin/jq -r '.unseal_keys_b64[0]' sensitive/vault_creds.json`<br/>export VAULT_ROOT_TOKEN=`/opt/homebrew/bin/jq -r '.root_token' sensitive/vault_creds.json`</span><span id="beaf" class="nl lw it nk b gy of oc l od oe"># Killing the process behind the Vault server's last startup<br/>kill -9 $(&lt;sensitive/vault_pid.txt)</span><span id="54c0" class="nl lw it nk b gy of oc l od oe"># Starting the Vault server/opt/homebrew/bin/vault server -config=config/vault_config.hcl &amp;&gt; /dev/null &amp;</span><span id="68a8" class="nl lw it nk b gy of oc l od oe"># Waiting 1 second for Vault server to startsleep 1 # Saving PID of started server to text fileecho $! &gt; sensitive/vault_pid.txt</span><span id="c7f6" class="nl lw it nk b gy of oc l od oe"># Unsealing the Vault with the Vault unseal key/opt/homebrew/bin/vault operator unseal $VAULT_UNSEAL_KEY</span><span id="568d" class="nl lw it nk b gy of oc l od oe"># Waiting 10 seconds after unsealing<br/>sleep 10 # Logging in with the Vault root token/opt/homebrew/bin/vault login $VAULT_ROOT_TOKEN</span></pre><p id="4a9a" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">关于上面的Automator脚本，唯一需要注意的是，它需要完整的文件路径来运行专门安装的工具，如Vault和JQ。老实说，我不知道为什么，但它不会工作，直到我这样做。</p></div><div class="ab cl om on hx oo" role="separator"><span class="op bw bk oq or os"/><span class="op bw bk oq or os"/><span class="op bw bk oq or"/></div><div class="im in io ip iq"><p id="b481" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">这个帖子到此为止！我们在这篇文章中涉及了很多内容，所以让我们在这里休息一下，因为我们准备在下一篇文章中更深入地研究跳马。希望你们都觉得这是有帮助的！感谢阅读，下期再见！</p></div></div>    
</body>
</html>