<html>
<head>
<title>Detect and Blur Human Faces on Your Website Using JavaScript</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用JavaScript检测和模糊网站上的人脸</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/detect-and-blur-human-faces-on-your-website-8c4a2d69a538?source=collection_archive---------4-----------------------#2022-07-17">https://betterprogramming.pub/detect-and-blur-human-faces-on-your-website-8c4a2d69a538?source=collection_archive---------4-----------------------#2022-07-17</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="5c81" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">能够检测和模糊人脸的人工智能可以在网站的数字时代的内容调节中发挥关键作用。</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/ecd934c499ef38b22f63ca95ac412bee.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*r9rn9v1KcYzm6sIj5ZtoPw.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">使用Pixlab demo检测和模糊人脸</p></figure><p id="915c" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">内容适度对于一个网站来说是非常必要的。如果你正在开发一个用户可以上传图片的网站，那么你必须格外小心。你不能相信你的用户。如果他们上传一些令人反感的内容，那么有时你作为网站的创建者，成为它的受害者。</p><p id="34fc" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">在每个现代web 2.0应用程序中，都存在一个内容审核系统。一些受欢迎的网站，如脸书、Instagram和Twitter，都有自动和手动的内容审核系统。</p><p id="0777" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">但是对于小型团队和个人开发人员来说，手动内容审核是不可行的，也不太经济。因此，我们可以使用基于人工智能(AI)的自动化来检测任何令人反感的内容，并将其模糊化。</p><p id="33d9" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">构建基于人工智能的自动化并不容易。你必须雇佣一个有才华的开发人员，并且应该有很多数据来训练你的AI模型。但是我们可以走捷径。市场上有很多软件即服务(SaaS)平台，可以在这方面帮助我们。</p><p id="0a3d" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated"><a class="ae lr" href="https://pixlab.io/" rel="noopener ugc nofollow" target="_blank"> Pixlab </a>是一个SaaS平台，可以给他们最先进的人工智能模型提供一个用户友好的应用编程接口(API)。您可以轻松地将这些服务集成到您的应用中。查看此<a class="ae lr" href="https://pixlab.io/cmdls" rel="noopener ugc nofollow" target="_blank">链接</a>了解更多信息。</p><h1 id="7abf" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">议程</h1><p id="b113" class="pw-post-body-paragraph kv kw iq kx b ky mk jr la lb ml ju ld le mm lg lh li mn lk ll lm mo lo lp lq ij bi translated">在本文中，我们将使用P <a class="ae lr" href="https://pixlab.io/cmdls" rel="noopener ugc nofollow" target="_blank"> ixlab API </a>制作一个web应用程序。我将使用普通的JavaScript。</p><p id="3947" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">你可以对任何框架使用相同的逻辑，比如react、Vue、Angular等等。由于我们大量使用Pixlab API，请确保获得一个<a class="ae lr" href="https://pixlab.io/pricing" rel="noopener ugc nofollow" target="_blank"> API密匙</a>以便使用。</p><p id="6e8e" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">在web应用程序中，首先，我们获取用户输入的图像。然后我们检测图像中的人脸。最后，我们模糊图像的面部，并在我们的应用程序中渲染最终的图像。</p><p id="c717" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">我们将使用<code class="fe mp mq mr ms b"><a class="ae lr" href="https://pixlab.io/cmd?id=facedetect" rel="noopener ugc nofollow" target="_blank">facedetect</a></code> API端点来检测图像中的人脸。然后，我们向<a class="ae lr" href="https://pixlab.io/cmd?id=mogrify" rel="noopener ugc nofollow" target="_blank"> mogrify </a> endpoint发出另一个请求，使用从<code class="fe mp mq mr ms b">facedetect</code> API收到的面部坐标来模糊我们的图像。</p><p id="fe3c" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">我们项目的最终版本将是这样的。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi mt"><img src="../Images/a0d15d1684706d107c5d760f274546df.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*Zg9cuiypfPeidFkOnsI95A.gif"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">现场视频演示</p></figure><p id="9a5c" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">由于我们正在制作一个web应用程序，由于CORS的限制，我们不能直接请求Pixlab服务器。CORS限制是为了保护用户。你可以在这里了解更多关于CORS的信息。因此，我们使用Nodejs制作一个代理服务器，并在那里启用CORS。然后，我们从前端向代理服务器发出所有请求，并将这些请求路由到Pixlab APIs，以绕过CORS限制。</p><p id="f46b" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">说够了，让我们制作我们的web应用程序。</p><h1 id="5a76" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">项目设置</h1><p id="2c7c" class="pw-post-body-paragraph kv kw iq kx b ky mk jr la lb ml ju ld le mm lg lh li mn lk ll lm mo lo lp lq ij bi translated">在深入学习教程之前，让我们先搭建一下我们的项目。我们需要在这个项目中的前端和后端(作为代理服务器)。因此，在项目根目录下创建两个名为<code class="fe mp mq mr ms b">frontend</code>和<code class="fe mp mq mr ms b">backend</code>的目录。</p><p id="cbc2" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">在你的前端目录中，创建3个文件，分别命名为<code class="fe mp mq mr ms b">index.html</code>、<code class="fe mp mq mr ms b">style.css</code>、<code class="fe mp mq mr ms b">index.js</code>。在VSCode中安装live-server来服务这些静态文件。</p><p id="0b35" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">在后端目录中，通过运行以下命令启动一个npm项目。</p><pre class="kg kh ki kj gt mu ms mv mw aw mx bi"><span id="b329" class="my lt iq ms b gy mz na l nb nc">cd backend<br/>npm init -y</span></pre><p id="12a2" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">因为我们要将express.js应用程序作为代理服务器，所以让我们一次性安装所有的依赖项。</p><pre class="kg kh ki kj gt mu ms mv mw aw mx bi"><span id="bf42" class="my lt iq ms b gy mz na l nb nc">npm install axios cors dotenv express express-fileupload form-data<br/>npm install — save-dev nodemon</span></pre><p id="f1fe" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">现在用这两个命令更改您的<code class="fe mp mq mr ms b">package.json</code>文件的脚本部分。</p><pre class="kg kh ki kj gt mu ms mv mw aw mx bi"><span id="1e38" class="my lt iq ms b gy mz na l nb nc">"scripts": {<br/>    "dev": "nodemon server.js",<br/>    "start": "node server.js"<br/>  },</span></pre><p id="65c9" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">现在在你的后端目录中创建<code class="fe mp mq mr ms b">server.js</code>文件。</p><p id="a327" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">在所有这些设置之后，项目结构将看起来像这样。</p><pre class="kg kh ki kj gt mu ms mv mw aw mx bi"><span id="8f5c" class="my lt iq ms b gy mz na l nb nc">.<br/>├── backend<br/>│   ├── package.json<br/>│   ├── package-lock.json<br/>│   └── server.js<br/>└── frontend<br/>    ├── index.html<br/>    ├── index.js<br/>    └── style.css</span></pre><p id="8574" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">让我们快速了解一下所有这些npm包在我们的项目中有什么用。</p><ol class=""><li id="ad60" class="nd ne iq kx b ky kz lb lc le nf li ng lm nh lq ni nj nk nl bi translated"><code class="fe mp mq mr ms b">axios</code> : Axios是Node.js界非常流行的http客户端。它帮助我们非常容易地编写复杂的查询。</li><li id="6cf0" class="nd ne iq kx b ky nm lb nn le no li np lm nq lq ni nj nk nl bi translated"><code class="fe mp mq mr ms b">cors</code> : cors库用于在每个对我们服务器的请求中添加cors报头。您还可以使用该软件包对CORS策略进行大量定制。</li><li id="712b" class="nd ne iq kx b ky nm lb nn le no li np lm nq lq ni nj nk nl bi translated">这个包帮助我们在Node.js项目中创建和使用环境变量。这是隐藏你的API密匙或其他秘密所必需的，你不想把它们推给GitHub。</li><li id="c0d0" class="nd ne iq kx b ky nm lb nn le no li np lm nq lq ni nj nk nl bi translated">这个库不需要解释。这是Node.js世界中一个非常受欢迎的具有中间件功能的服务器库。</li><li id="023a" class="nd ne iq kx b ky nm lb nn le no li np lm nq lq ni nj nk nl bi translated"><code class="fe mp mq mr ms b">express-fileupload</code>:这个库作为中间件工作，让我们可以访问从客户端上传的所有文件。</li><li id="e207" class="nd ne iq kx b ky nm lb nn le no li np lm nq lq ni nj nk nl bi translated"><code class="fe mp mq mr ms b">form-data</code>:该包提供了Nodejs环境下的browser <a class="ae lr" href="https://developer.mozilla.org/en-US/docs/Web/API/FormData" rel="noopener ugc nofollow" target="_blank"> FormData </a>对象。为了向某个API发出多部分/表单数据请求，我在这个项目中使用了这个包。</li><li id="e18b" class="nd ne iq kx b ky nm lb nn le no li np lm nq lq ni nj nk nl bi translated">这是一个开发依赖项，每当javascript文件中的一些代码发生变化时，它会自动重启服务器。</li></ol><h1 id="c405" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">让我们将代理节点设为服务器</h1><p id="f150" class="pw-post-body-paragraph kv kw iq kx b ky mk jr la lb ml ju ld le mm lg lh li mn lk ll lm mo lo lp lq ij bi translated">正如我之前提到的，由于浏览器CORS政策，我们不能从我们的前端应用程序直接调用Pixlab API。因此，我们将制作一个Node.js服务器，代理我们对Pixlab API的请求。</p><blockquote class="nr ns nt"><p id="31e4" class="kv kw nu kx b ky kz jr la lb lc ju ld nv lf lg lh nw lj lk ll nx ln lo lp lq ij bi translated">在这一节中，我交替使用了客户端和前端。请记住这一点。</p></blockquote><h2 id="4df5" class="my lt iq bd lu ny nz dn ly oa ob dp mc le oc od me li oe of mg lm og oh mi oi bi translated">代理用户将图像上传到Pixlab API</h2><p id="9b40" class="pw-post-body-paragraph kv kw iq kx b ky mk jr la lb ml ju ld le mm lg lh li mn lk ll lm mo lo lp lq ij bi translated">这是我们项目中代理上传图像的最棘手的部分。Pixlab倾向于接受在线图像链接来处理我们的请求。为了将我们的本地图像上传到存储桶，Pixlab还提供了一个开发人员友好的API，称为<a class="ae lr" href="https://pixlab.io/cmd?id=store" rel="noopener ugc nofollow" target="_blank"> store </a>。</p><p id="6486" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">这个API接受POST请求。请求的主体应该是包含用户上传的图像和API密钥的多部分/格式数据。如果请求成功，API会获取您的图像并将其上传到在线存储桶，并提供该图像的链接。</p><p id="db05" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">在我们的代理服务器中，我们将用户文件输入到<code class="fe mp mq mr ms b">/upload</code>路径中。我们使用<code class="fe mp mq mr ms b">express-fileupload</code>包访问用户上传的图像。将这个包作为中间件添加后，我们可以使用<code class="fe mp mq mr ms b">req.files</code>方法访问用户上传文件。</p><p id="f40b" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">然后，我们使用我前面提到的<code class="fe mp mq mr ms b">form-data </code>包来构造我们的多部分/表单数据请求。在表单数据中附加用户上传的图像和API密钥。您可以在这里使用<code class="fe mp mq mr ms b">dotenv</code>包来隐藏您的API密钥，并将其作为环境变量来访问。</p><p id="6ae1" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">在构建了多部分/表单数据之后，我们将请求提交给Pixlab API。然后不管我们得到什么响应，如果是200，我们就把它作为对用户的响应。</p><p id="134b" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">我们的<code class="fe mp mq mr ms b">/upload</code>路径的代码如下所示。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="oj ok l"/></div></figure><p id="858b" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">如果这个请求成功，那么我们将获得一个到用户上传图像的链接。我们保留这个链接，以便在<code class="fe mp mq mr ms b">facedetect</code>和<code class="fe mp mq mr ms b">mogrify</code> API请求中使用。</p><h2 id="3b62" class="my lt iq bd lu ny nz dn ly oa ob dp mc le oc od me li oe of mg lm og oh mi oi bi translated">代理人脸检测API(人脸检测)</h2><p id="f743" class="pw-post-body-paragraph kv kw iq kx b ky mk jr la lb ml ju ld le mm lg lh li mn lk ll lm mo lo lp lq ij bi translated">现在让我们使用Node.js制作一个<strong class="kx ir"> Facedetect </strong> API代理。要读取用户发送的JSON数据，在我们的服务器中使用<code class="fe mp mq mr ms b">express.json()</code>中间件。</p><p id="4213" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">首先，我们获取用户发送的图像URL(来自我们之前的请求),并用这个图像URL和Pixlab API密钥向Pixlab API发出get请求。然后，我们只需将响应从服务器发送到客户端。</p><p id="8184" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">路径<code class="fe mp mq mr ms b">/facedetect</code>的代码如下所示。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="oj ok l"/></div></figure><p id="8d32" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">请求成功后，我们从服务器获得一个面部坐标列表。我们把这些坐标发给客户。我们需要这些坐标在<code class="fe mp mq mr ms b">mogrify</code> API中使用来模糊人们的脸。</p><h2 id="b373" class="my lt iq bd lu ny nz dn ly oa ob dp mc le oc od me li oe of mg lm og oh mi oi bi translated">代理mogrify API(面部模糊)</h2><p id="51f6" class="pw-post-body-paragraph kv kw iq kx b ky mk jr la lb ml ju ld le mm lg lh li mn lk ll lm mo lo lp lq ij bi translated">我们使用服务器的<code class="fe mp mq mr ms b">/mogrify</code>路径来调用Pixlab的<code class="fe mp mq mr ms b">mogrify</code> API。客户端提供我们从上述两个请求中获得的图像URL和面部坐标。解析用户提供的数据后，我们向Pixlab <code class="fe mp mq mr ms b">mogrify</code> API发出POST请求。</p><p id="0fa8" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated"><code class="fe mp mq mr ms b">/mogrify</code>里面的代码是这样的。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="oj ok l"/></div></figure><p id="5561" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">请求成功后，它会返回我们之前上传的图像的模糊脸部版本。</p><p id="3c60" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">然后，我们将新的模糊图像链接传递给客户端。现在，客户端可以使用这个链接来显示图像。</p><h1 id="f8a1" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">构建前端部分</h1><p id="8cda" class="pw-post-body-paragraph kv kw iq kx b ky mk jr la lb ml ju ld le mm lg lh li mn lk ll lm mo lo lp lq ij bi translated">增加一个直观的前端，对于用户的角度来说是非常必要的。在本节中，我们将这个前端作为应用程序的一部分。为了简单起见，我尽可能保持前端最小化。</p><h2 id="5a1c" class="my lt iq bd lu ny nz dn ly oa ob dp mc le oc od me li oe of mg lm og oh mi oi bi translated">获取用户文件输入</h2><p id="9dea" class="pw-post-body-paragraph kv kw iq kx b ky mk jr la lb ml ju ld le mm lg lh li mn lk ll lm mo lo lp lq ij bi translated">首先，用最少的html标记填充“index.html”文件。供你参考，这是我这个项目的HTML模板。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="oj ok l"/></div></figure><p id="864e" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">在上面的HTML代码中，我们用HTML链接了CSS和javascript文件，并创建了一个网站的基本结构。</p><p id="f328" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">现在，要从用户那里获取文件输入，我们必须在HTML文件内部添加一个输入标记。确保添加<code class="fe mp mq mr ms b">accept</code>属性以仅接受jpg和png图像。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="oj ok l"/></div></figure><p id="a271" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">现在，在HTML标记中添加两个图像标签。一个用于显示用户上传的图像，另一个用于渲染来自Pixlab API服务器的经过处理的模糊人脸图像。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="oj ok l"/></div></figure><p id="9b79" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">最后，添加一个按钮来调用图像处理。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="oj ok l"/></div></figure><h2 id="9cfa" class="my lt iq bd lu ny nz dn ly oa ob dp mc le oc od me li oe of mg lm og oh mi oi bi translated">让我们的前端互动</h2><p id="59e0" class="pw-post-body-paragraph kv kw iq kx b ky mk jr la lb ml ju ld le mm lg lh li mn lk ll lm mo lo lp lq ij bi translated">在<code class="fe mp mq mr ms b">index.js</code>文件中，首先，我们定义了这个过程中需要的所有DOM节点。这包括来自用户的图像(<code class="fe mp mq mr ms b">imageInput</code>)的输入标签，显示初始(图像)和最终(<code class="fe mp mq mr ms b">finalImage</code>)结果的两个图像标签，以及启动该过程的一个按钮(<code class="fe mp mq mr ms b">processBtn</code>)。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="oj ok l"/></div></figure><p id="2a3e" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">现在，当用户使用我们的文件选取器选取一个新图像时，我们将这个图像作为DataURL读取，然后将这个图像渲染到我们的初始图像标签中。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="oj ok l"/></div></figure><p id="bdd3" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">现在我们手中有了用户选择的图像。因此，这是向我们的代理服务器发送请求以开始图像处理的时候了。</p><h2 id="5990" class="my lt iq bd lu ny nz dn ly oa ob dp mc le oc od me li oe of mg lm og oh mi oi bi translated">使用Pixlab API进行图像处理</h2><p id="02a0" class="pw-post-body-paragraph kv kw iq kx b ky mk jr la lb ml ju ld le mm lg lh li mn lk ll lm mo lo lp lq ij bi translated">在这个过程中，每次用户上传图像时，我们总共向服务器发出3个请求。这些请求是连续的，所以我们必须严格按照顺序进行查询。</p><ol class=""><li id="057b" class="nd ne iq kx b ky kz lb lc le nf li ng lm nh lq ni nj nk nl bi translated"><strong class="kx ir">上传图像到远程服务器</strong>:为了上传图像到代理服务器，我们用用户选择的图像向代理服务器的<code class="fe mp mq mr ms b">/upload</code>路由发出POST请求。我们创建了一个助手函数来简化这个过程。</li></ol><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="oj ok l"/></div></figure><p id="0ba4" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">2.<strong class="kx ir">调用人脸检测API </strong>:通过使用我们从前面的请求中获得的远程图像链接，我们调用人脸检测API。我们向代理服务器的<code class="fe mp mq mr ms b">/facedetect</code>路由发出一个POST请求。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="oj ok l"/></div></figure><p id="753d" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">3.<strong class="kx ir">模糊检测到的人脸</strong>:我们从之前的查询中获取上传的图像的人脸坐标。现在我们称之为<code class="fe mp mq mr ms b">/mogrify</code>代理路线来模糊我们的形象。我们再次使用面部坐标和图像链接发出POST请求。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="oj ok l"/></div></figure><p id="2bea" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">我们从这个查询中得到模糊图像链接作为回报。我们将使用这个URL在我们的用户面前显示图像。</p><h2 id="6de5" class="my lt iq bd lu ny nz dn ly oa ob dp mc le oc od me li oe of mg lm og oh mi oi bi translated">管理所有这些功能的按钮</h2><p id="6b8f" class="pw-post-body-paragraph kv kw iq kx b ky mk jr la lb ml ju ld le mm lg lh li mn lk ll lm mo lo lp lq ij bi translated">所有这些过程都由我们前面定义的process按钮管理。它向每个端点逐个发出请求，并将所需的值从一个函数传递给另一个函数。处理按钮是我们前端部分的管理器。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="oj ok l"/></div></figure><h1 id="7f6c" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">奖金</h1><p id="2800" class="pw-post-body-paragraph kv kw iq kx b ky mk jr la lb ml ju ld le mm lg lh li mn lk ll lm mo lo lp lq ij bi translated">如果你读到这里，这是给你的GitHub项目链接。我必须在这里和那里做一些改变，让我们的网络应用程序看起来更好。此外，您可以查看我没有包括在本文中的CSS部分。</p></div><div class="ab cl ol om hu on" role="separator"><span class="oo bw bk op oq or"/><span class="oo bw bk op oq or"/><span class="oo bw bk op oq"/></div><div class="ij ik il im in"><p id="b8a1" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">如果你现在还在读这篇文章，我很高兴我能写出这样的内容让人们阅读。</p><pre class="kg kh ki kj gt mu ms mv mw aw mx bi"><span id="98ce" class="my lt iq ms b gy mz na l nb nc">Do you have any queries? I am available on Twitter as <a class="ae lr" href="http://twitter.com/hrishikshpathak" rel="noopener ugc nofollow" target="_blank">@hrishikshpathak</a>. Make your version of this web app and show me on Twitter. Till then bye.</span></pre></div></div>    
</body>
</html>