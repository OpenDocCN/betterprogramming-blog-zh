<html>
<head>
<title>How To Reduce Your App’s Memory Footprint</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何减少应用程序的内存占用</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/reducing-your-apps-memory-footprint-b7afcb9f3749?source=collection_archive---------3-----------------------#2019-07-09">https://betterprogramming.pub/reducing-your-apps-memory-footprint-b7afcb9f3749?source=collection_archive---------3-----------------------#2019-07-09</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="7d07" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">高内存使用率的原因，减少应用程序的内存占用和调试</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/a471f90090dacfc40a9d037a6b528703.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ByEOPeUXpUTE1I1bK4QjvQ.jpeg"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated"><a class="ae ky" href="https://unsplash.com/@freestocks?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">freestocks.org</a>在<a class="ae ky" href="https://unsplash.com/search/photos/app?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍照</p></figure><p id="fba5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这听起来似乎很明显，我们应该让我们的应用程序的内存占用尽可能的低，但是实际上为什么呢？</p><p id="3da1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">有几个原因:</p><ul class=""><li id="3e6c" class="lv lw it lb b lc ld lf lg li lx lm ly lq lz lu ma mb mc md bi translated">在某种程度上，高内存使用率会引发内存警告、性能问题，如果您反应不迅速，可能会终止您的应用程序。对内存警告做出快速反应并不像你想象的那么容易。</li><li id="c524" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated">当你的应用程序进入后台时，它就进入了与其他应用程序的某种竞争。当iOS需要内存来执行其他任务时，它会终止高使用率的应用程序，而你不想被列入黑名单。</li></ul><p id="0d5b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">最终，低效的、消耗内存的应用程序提供了糟糕的用户体验，所以系好安全带，抓紧你的应用程序。是时候减少内存使用了。</p></div><div class="ab cl mj mk hx ml" role="separator"><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo"/></div><div class="im in io ip iq"><h1 id="54ce" class="mq mr it bd ms mt mu mv mw mx my mz na jz nb ka nc kc nd kd ne kf nf kg ng nh bi translated">高内存使用率的常见原因</h1><h2 id="bbbd" class="ni mr it bd ms nj nk dn mw nl nm dp na li nn no nc lm np nq ne lq nr ns ng nt bi translated">1.保留周期</h2><p id="1bd4" class="pw-post-body-paragraph kz la it lb b lc nu ju le lf nv jx lh li nw lk ll lm nx lo lp lq ny ls lt lu im bi translated">几年前，我们必须手动分配和释放Objective-C对象。现在我们有了<a class="ae ky" href="https://developer.apple.com/swift/" rel="noopener ugc nofollow" target="_blank"> Swift </a>和<a class="ae ky" href="https://docs.swift.org/swift-book/LanguageGuide/AutomaticReferenceCounting.html" rel="noopener ugc nofollow" target="_blank"> ARC </a>(自动引用计数)，但是内存泄漏仍然会出现。当他们这样做的时候，是很痛苦的。</p><p id="92b0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">简而言之:对象可以通过几种方式指向其他点。两种基本方法是<em class="nz">弱</em>和<em class="nz">强</em>。</p><p id="9f65" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">当一个对象没有任何<em class="nz">强</em>引用时，它被释放。例如，当一个<code class="fe oa ob oc od b">UIViewController</code>有一个子视图控制器时，它对它的子视图有一个强引用，而子视图对它的父视图有一个弱引用。</p><p id="efec" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">但是如果两个对象用强引用指向对方呢？他们不会得到释放，直到应用程序被终止。这被称为<em class="nz">保持周期</em>。</p><p id="d8e8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们需要了解保留周期的两种主要使用情形:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi oe"><img src="../Images/658db8158d511a8ab1c597857c7b93a4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*pS32Qij_XHlhD_Ed"/></div></div></figure><ol class=""><li id="4993" class="lv lw it lb b lc ld lf lg li lx lm ly lq lz lu of mb mc md bi translated"><strong class="lb iu">委托</strong>—iOS中委托的基本模式是，有一个对象(某个其他对象用强引用持有它)，这个对象持有另一个对象，用强引用，充当它的委托人。在这种情况下，另一个对象应该有一个对委托的引用，因为委托用strong持有它，所以这个引用必须是弱的，否则我们将在这里有一个保留循环。</li><li id="dee4" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu of mb mc md bi translated"><strong class="lb iu">数据结构，</strong> <strong class="lb iu">这样的trie </strong> —有些数据结构需要双向引用。它可以是一棵trie树，也可以是一棵包含父视图和子视图的树(我向您展示了<code class="fe oa ob oc od b">UIViewController</code>和子视图控制器的例子)。请记住，每次添加返回引用时，都可能会创建一个保留循环，所以要小心。</li></ol><h2 id="d1de" class="ni mr it bd ms nj nk dn mw nl nm dp na li nn no nc lm np nq ne lq nr ns ng nt bi translated">2.定时器</h2><p id="cdae" class="pw-post-body-paragraph kz la it lb b lc nu ju le lf nv jx lh li nw lk ll lm nx lo lp lq ny ls lt lu im bi translated">计时器实际上是保留周期的一个特例。我之所以给timer单独一个项目符号，是因为它不是一个“常规的”保留周期案例。</p><p id="cb0c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">当你设置一个定时器时，它把它的目标作为一个强引用，在很多情况下，这个目标也把定时器作为一个强引用。</p><p id="8e8e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">有几种方法可以避免这种保留周期:</p><ol class=""><li id="3d78" class="lv lw it lb b lc ld lf lg li lx lm ly lq lz lu of mb mc md bi translated">传递一个弱引用作为计时器的目标。</li><li id="39ed" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu of mb mc md bi translated">让保存计时器的对象和目标成为两个不同的对象。</li><li id="b237" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu of mb mc md bi translated">确保在退出屏幕或者不需要的时候，定时器失效。无论如何，这是最佳实践。</li></ol><h2 id="fde2" class="ni mr it bd ms nj nk dn mw nl nm dp na li nn no nc lm np nq ne lq nr ns ng nt bi translated">3.大图像</h2><p id="5958" class="pw-post-body-paragraph kz la it lb b lc nu ju le lf nv jx lh li nw lk ll lm nx lo lp lq ny ls lt lu im bi translated">关于图像，你需要记住几件事。</p><ol class=""><li id="ea28" class="lv lw it lb b lc ld lf lg li lx lm ly lq lz lu of mb mc md bi translated">你加载到内存中的图像的大小不是文件的大小，而是它的尺寸大小。例如，如果您有一个100 KB的压缩JPEG，但图像尺寸为1000 x 1000，您实际上向内存中加载了100万个像素(！).现在，由于每个像素都包含额外的信息，所以实际上每个像素有4个字节，这意味着对于一个100 KB的文件，大约需要4 MB的内存。</li><li id="e7e5" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu of mb mc md bi translated">缩小的图像可以显著减少内存使用。</li></ol><h2 id="5a2f" class="ni mr it bd ms nj nk dn mw nl nm dp na li nn no nc lm np nq ne lq nr ns ng nt bi translated">4.隐藏物</h2><p id="9d24" class="pw-post-body-paragraph kz la it lb b lc nu ju le lf nv jx lh li nw lk ll lm nx lo lp lq ny ls lt lu im bi translated">我们都知道有些情况下可以用CPU换内存。但是当缓存变得更大时，我们可能会发现自己在处理内存问题，而不是CPU问题。</p></div><div class="ab cl mj mk hx ml" role="separator"><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo"/></div><div class="im in io ip iq"><h1 id="2000" class="mq mr it bd ms mt mu mv mw mx my mz na jz nb ka nc kc nd kd ne kf nf kg ng nh bi translated">减少内存占用的提示</h1><h2 id="359f" class="ni mr it bd ms nj nk dn mw nl nm dp na li nn no nc lm np nq ne lq nr ns ng nt bi translated">1.惰性装载</h2><p id="8def" class="pw-post-body-paragraph kz la it lb b lc nu ju le lf nv jx lh li nw lk ll lm nx lo lp lq ny ls lt lu im bi translated">惰性加载意味着只有在需要的时候才把对象加载到内存中。除了节省内存，它还减少了应用程序和屏幕的加载时间。</p><p id="8100" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">可以使用传统的方法，在使用对象之前检查对象是否为nil，如果为nil，则分配并使用它。</p><pre class="kj kk kl km gt og od oh oi aw oj bi"><span id="c3b1" class="ni mr it od b gy ok ol l om on">if image == nil {<br/>    image = UIImage(named : "ocean")<br/>}</span></pre><p id="469d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">或者您可以使用Swift极其简单的<code class="fe oa ob oc od b">lazy</code>关键字:</p><pre class="kj kk kl km gt og od oh oi aw oj bi"><span id="21cf" class="ni mr it od b gy ok ol l om on">lazy var image = UIImage(named : "ocean")</span></pre><h2 id="a811" class="ni mr it bd ms nj nk dn mw nl nm dp na li nn no nc lm np nq ne lq nr ns ng nt bi translated">2.实现内存警告方法</h2><p id="9f20" class="pw-post-body-paragraph kz la it lb b lc nu ju le lf nv jx lh li nw lk ll lm nx lo lp lq ny ls lt lu im bi translated">您的应用程序并不总是内存警告的原因，但它应该对它们做出响应，否则，它会变得滞后，最终崩溃。</p><p id="8247" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">开发人员在收到内存警告时做的第一件事就是释放缓存，但这实际上取决于缓存的类型。</p><p id="f92b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">当iOS注意到你不经常使用某个对象时，它会压缩它，所以释放它在内存方面不会有太大帮助，反而会损害用户体验。</p><p id="a44d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">您应该做的是释放未压缩的内存对象。例如，尝试关闭/弹出当前屏幕，或者卸载当前加载的大图像。</p><h2 id="b448" class="ni mr it bd ms nj nk dn mw nl nm dp na li nn no nc lm np nq ne lq nr ns ng nt bi translated">3.使用NSCache</h2><p id="3b1e" class="pw-post-body-paragraph kz la it lb b lc nu ju le lf nv jx lh li nw lk ll lm nx lo lp lq ny ls lt lu im bi translated">用<a class="ae ky" href="https://developer.apple.com/documentation/foundation/nscache" rel="noopener ugc nofollow" target="_blank"> NSCache </a>代替字典。令人惊讶的是，许多开发人员忽略了这个伟大的API。</p><p id="dfb6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">NSCache的行为就像一个普通的字典，但它有几个优点。它是线程安全的，当系统进入低内存状态时，它会释放对象。不仅如此，它还开始释放您不经常使用的对象，因此它为真正良好、高效的缓存进行了优化。</p><h2 id="75d5" class="ni mr it bd ms nj nk dn mw nl nm dp na li nn no nc lm np nq ne lq nr ns ng nt bi translated">4.请使用UIGraphicsImageRender，而不是UIGraphicsBeginImageContext</h2><p id="1642" class="pw-post-body-paragraph kz la it lb b lc nu ju le lf nv jx lh li nw lk ll lm nx lo lp lq ny ls lt lu im bi translated">我们前面提到过，将一幅图像加载到内存中时，每像素要加载四个字节。</p><p id="5923" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在处理图像时，这可能是一件大事。你能做的最好的事情就是用<code class="fe oa ob oc od b">UIGraphicsImageRender</code>代替<code class="fe oa ob oc od b">UIGrahpicsBeginImageContext</code>。</p><p id="9171" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe oa ob oc od b">UIGraphicsImageRender</code>实际识别你正在加载的图像类型，并分配优化的每像素字节数。例如，单色(黑/白)图像将使用一个像素或每个像素一个字节。</p><h2 id="b834" class="ni mr it bd ms nj nk dn mw nl nm dp na li nn no nc lm np nq ne lq nr ns ng nt bi translated">5.自动释放池</h2><p id="4e6b" class="pw-post-body-paragraph kz la it lb b lc nu ju le lf nv jx lh li nw lk ll lm nx lo lp lq ny ls lt lu im bi translated">请记住，我们使用ARC并不意味着我们不必保留、自动释放和释放命令。都在那里，由编译器自动添加。</p><p id="06e1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">自动释放池仍然存在，建议在循环内部使用。</p><p id="ab4f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">当您在循环中运行代码时，在循环中创建的对象只在作用域的末尾被释放。这意味着，在大型循环中，您可能会遇到内存高峰。</p><p id="7b17" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这里最好的做法是将每个循环迭代的重分配包装在autorelease块中，这样对象将在块的末尾被释放。</p></div><div class="ab cl mj mk hx ml" role="separator"><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo"/></div><div class="im in io ip iq"><h1 id="75a1" class="mq mr it bd ms mt mu mv mw mx my mz na jz nb ka nc kc nd kd ne kf nf kg ng nh bi translated">如何调试内存问题</h1><p id="c9cb" class="pw-post-body-paragraph kz la it lb b lc nu ju le lf nv jx lh li nw lk ll lm nx lo lp lq ny ls lt lu im bi translated">和每个技术问题一样，你要从概述你的应用开始。</p><p id="a39b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">幸运的是，我们在<a class="ae ky" href="https://developer.apple.com/xcode/" rel="noopener ugc nofollow" target="_blank"> Xcode </a>中内置了一个工具，叫做<em class="nz">记忆量表</em>。从这一点来说，你有额外的工具来挖掘，直到你找到你的问题。</p><h2 id="99ae" class="ni mr it bd ms nj nk dn mw nl nm dp na li nn no nc lm np nq ne lq nr ns ng nt bi translated">1.记忆量表</h2><p id="9b2b" class="pw-post-body-paragraph kz la it lb b lc nu ju le lf nv jx lh li nw lk ll lm nx lo lp lq ny ls lt lu im bi translated">内存标尺位于左侧导航器窗格中的调试导航器上。只有在调试中运行应用程序时，它才会显示出来。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi oo"><img src="../Images/4f46641e0692cd705ddd202216efb7c8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*SdBkERHrIuJ2791F"/></div></div></figure><p id="db07" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">内存标尺显示应用在其生命周期中的使用情况。</p><p id="4385" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">一般来说，当你运行你的应用程序时，你应该看看内存标尺，并尝试找出任何奇怪的行为。</p><p id="550e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">怪异行为的例子:</p><ol class=""><li id="c461" class="lv lw it lb b lc ld lf lg li lx lm ly lq lz lu of mb mc md bi translated"><strong class="lb iu">极高的内存使用率</strong> —苹果将内存使用率分为三类:绿色、黄色和红色。你应该总是试着让你的应用程序处于绿色部分。</li><li id="0fe4" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu of mb mc md bi translated"><strong class="lb iu">持续增长的内存</strong> —当你使用你的应用程序时，你应该期待你的内存使用量随着时间的推移保持不变。如果您看到它持续增长，那么您可能有内存泄漏或其他需要调查的问题。试着呈现屏幕并消除它们，看看你的记忆是否会收缩，以便确定具体的问题。</li><li id="283d" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu of mb mc md bi translated"><strong class="lb iu">去后台</strong> —当你去后台的时候，你应该会看到你的记忆力降低了。如果不是，你要想到释放资源，比如大图的加载，以便留在后台，内存占用小。</li></ol><p id="013f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果您在概述阶段遇到问题，您可以通过点击“仪器中的配置文件”按钮轻松进入仪器工具。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi op"><img src="../Images/742f584931a20082a6a8a890b4dee7f2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*KkPun6tq17-J8L36"/></div></div></figure><h2 id="567c" class="ni mr it bd ms nj nk dn mw nl nm dp na li nn no nc lm np nq ne lq nr ns ng nt bi translated">2.工具</h2><p id="08ff" class="pw-post-body-paragraph kz la it lb b lc nu ju le lf nv jx lh li nw lk ll lm nx lo lp lq ny ls lt lu im bi translated">我不打算解释如何使用这些工具，但这是一个低级工具(虽然不是最低级的)，用于识别应用程序中的泄漏和分配。</p><p id="3a3d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">除了查找应用程序中的错误分配，它还可以让你比较不同修复之间的运行情况。</p><h2 id="c7d4" class="ni mr it bd ms nj nk dn mw nl nm dp na li nn no nc lm np nq ne lq nr ns ng nt bi translated">3.Dealloc / deinit方法</h2><p id="5d05" class="pw-post-body-paragraph kz la it lb b lc nu ju le lf nv jx lh li nw lk ll lm nx lo lp lq ny ls lt lu im bi translated">每个对象都有<code class="fe oa ob oc od b">dealloc</code> (Obj-c)或<code class="fe oa ob oc od b">deinit</code> (Swift ),当对象被释放时会调用它们。</p><p id="f67b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">实现这个方法并放入一个日志或断点——这是一个很好的、先发制人的、快速的方法来验证对象是否如你所期望的那样被释放。</p><h2 id="9b70" class="ni mr it bd ms nj nk dn mw nl nm dp na li nn no nc lm np nq ne lq nr ns ng nt bi translated">4.使用内存度量的单元测试</h2><p id="41ae" class="pw-post-body-paragraph kz la it lb b lc nu ju le lf nv jx lh li nw lk ll lm nx lo lp lq ny ls lt lu im bi translated">在iOS 13中，我们在性能测试方面有了很大的增加。除了时间度量，我们还有一个内存度量。</p><p id="c313" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果您知道某段代码正在产生高内存使用率，那么最好使用内存指标来测量它。这样一来，一方面你可以调试方法，另一方面，你将有另一个测试，这总是很棒的。</p><h2 id="b9dc" class="ni mr it bd ms nj nk dn mw nl nm dp na li nn no nc lm np nq ne lq nr ns ng nt bi translated">5.模拟内存警告</h2><p id="cda0" class="pw-post-body-paragraph kz la it lb b lc nu ju le lf nv jx lh li nw lk ll lm nx lo lp lq ny ls lt lu im bi translated">在模拟器中，在调试菜单下，有一个选项“模拟内存警告”。您可以使用它来查看当它得到我们谈到的内存警告时，您的内存使用情况会发生什么。</p><p id="bafb" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在设备上模拟这个警告有点棘手。你可以在你的应用程序中进行一些加载来达到这种状态，或者你可以使用一个私有的API来模拟它(记住在你完成之后要移动这个方法)。</p><pre class="kj kk kl km gt og od oh oi aw oj bi"><span id="3408" class="ni mr it od b gy ok ol l om on">UIControl.sendAction(Selector(("_performMemoryWarning")), to:UIApplication.shared, for: nil)</span></pre><h2 id="27ca" class="ni mr it bd ms nj nk dn mw nl nm dp na li nn no nc lm np nq ne lq nr ns ng nt bi translated">6.内存调试器</h2><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi oq"><img src="../Images/0e5f49c11ee96556f721e59f66b420cc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1140/0*-vLO-8lhsSJXuWsK"/></div></figure><p id="e05f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在Xcode窗口的底部，您会找到“调试内存图”选项。</p><p id="701c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果你还没有用过，现在是时候了。这是一个神奇的工具。它可以让你看到应用程序中对象之间的关系，甚至保留循环。</p><p id="f1c3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">它还允许您计算每个类的实例数量(就像instruments工具一样)，这样您就可以快速检查您的内存映射。</p></div><div class="ab cl mj mk hx ml" role="separator"><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo"/></div><div class="im in io ip iq"><h1 id="0b48" class="mq mr it bd ms mt mu mv mw mx my mz na jz nb ka nc kc nd kd ne kf nf kg ng nh bi translated">摘要</h1><p id="f7d8" class="pw-post-body-paragraph kz la it lb b lc nu ju le lf nv jx lh li nw lk ll lm nx lo lp lq ny ls lt lu im bi translated">正如你所看到的，你的应用内存是一个需要观察、调试和维护的大问题。</p><p id="f755" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">遵循本文中的提示将有助于您通过编写适当的代码来防止内存泄漏。通过观察内存量规并使用一些工具(如仪器和内存调试器)修复它们，它将帮助您及时解决问题。</p></div></div>    
</body>
</html>