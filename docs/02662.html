<html>
<head>
<title>3 Property Wrappers to Control Your Data in Swift</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">在Swift中控制数据的3个属性包装器</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/3-property-wrappers-to-control-your-data-in-swift-84bcbb22c5be?source=collection_archive---------17-----------------------#2019-12-15">https://betterprogramming.pub/3-property-wrappers-to-control-your-data-in-swift-84bcbb22c5be?source=collection_archive---------17-----------------------#2019-12-15</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="8053" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">定义如何使用属性包装操作数据</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/bdb34593af8c04f4bec825fa9d0ae659.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*r_pQ4MYeRCUn8qiKCMgUQw.jpeg"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">像糖果一样包装它们——图片来自<a class="ae ky" href="https://pixabay.com/photos/pug-dog-pet-animal-puppy-cute-801826/" rel="noopener ugc nofollow" target="_blank"> pixabay </a>的<a class="ae ky" href="https://pixabay.com/users/stocksnap-894430/" rel="noopener ugc nofollow" target="_blank"> StockSnap </a></p></figure><p id="2302" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在本文中，我们将探索三种属性包装器来为我们的属性实施策略。通过使用它们，我们可以确保这些属性只在应该的时候使用。</p><p id="a786" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">第一个属性包装器将确保封装的值可以过期，并且在给定时间过去后不可访问。在第二个例子中，我们将创建一个确保一个值只能更新一次的方法。</p><p id="34b3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">该值的每次后续更新都将失败。最终的属性包装器确保包装的值只在预定义的步骤内更改。</p><p id="d525" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">对于这些包装器中的每一个，我们将看一些用例的例子，以及如何在我们的项目中实现和使用它们。</p><p id="a68c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">注意:如果你不知道什么是属性包装器以及如何使用它们，你可以阅读我上一篇关于它们的文章。</p><p id="5312" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们开始吧！</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="03ea" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">可补偿值</h1><p id="55da" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">属性可以在定义的秒数内保存一个值。时间过后，该属性的值将为零。</p><h2 id="3329" class="mz md it bd me na nb dn mi nc nd dp mm li ne nf mo lm ng nh mq lq ni nj ms nk bi translated"><strong class="ak">用例</strong></h2><ul class=""><li id="8807" class="nl nm it lb b lc mu lf mv li nn lm no lq np lu nq nr ns nt bi translated">用户可以使用演示功能20分钟。通过用这个包装器包装一个启用该功能的布尔标志，可以确保用户在时间结束后不能继续使用该功能。</li><li id="8294" class="nl nm it lb b lc nu lf nv li nw lm nx lq ny lu nq nr ns nt bi translated">在游戏中，玩家解锁了一个奖励等级，但是他们只有一个小时的时间来玩。该属性包装将在给定时间后禁用该级别。</li><li id="b952" class="nl nm it lb b lc nu lf nv li nw lm nx lq ny lu nq nr ns nt bi translated">登录令牌的有效期为一小时。通过包装，过期后就无法使用了。</li></ul><h2 id="8185" class="mz md it bd me na nb dn mi nc nd dp mm li ne nf mo lm ng nh mq lq ni nj ms nk bi translated"><strong class="ak">实施</strong></h2><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nz oa l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">实现一个属性包装，当值过期时返回nil</p></figure><p id="da8a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe ob oc od oe b">//1</code> —我们创建了一个名为<code class="fe ob oc od oe b">Expirable</code>的新结构，并为其添加了注释<code class="fe ob oc od oe b">@propertyWrapper</code>。这个结构有一个泛型参数<code class="fe ob oc od oe b">Value</code>，它将是包装属性的类型。</p><p id="a46f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe ob oc od oe b">//2</code> —为了检查封装的值是否过期，我们需要该值、它应该有效的秒数以及它的创建日期。</p><p id="9f82" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在这个例子中，这些值分别被称为<code class="fe ob oc od oe b">value</code>、<code class="fe ob oc od oe b">countdown</code>和<code class="fe ob oc od oe b">start</code>，它们被传递到初始化器中。</p><p id="ca83" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">注意:由于某种原因，私有属性<code class="fe ob oc od oe b">countdown</code>和<code class="fe ob oc od oe b">start</code>在<code class="fe ob oc od oe b">wrappedValue</code>的getter中会有错误的值，<code class="fe ob oc od oe b">countdown</code>将总是0，<code class="fe ob oc od oe b">start</code>将是2001年1月1日。</p><p id="fcd4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">为了防止这种情况发生，我们使用另一个属性包装器将它们存储在<code class="fe ob oc od oe b">UserDefaults</code>中。你可以在这篇文章中阅读这个是如何工作的<a class="ae ky" href="https://medium.com/better-programming/creating-a-history-with-property-wrappers-in-swift-5-1-4c0202060a7f" rel="noopener">。</a></p><p id="94ef" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe ob oc od oe b">//3</code> —每个属性包装器需要一个名为<code class="fe ob oc od oe b">wrappedValue</code>的计算属性，带有一个getter和一个setter。在这种情况下，我们将只返回没有过期的值，否则将返回<code class="fe ob oc od oe b">nil</code>。</p><p id="4600" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe ob oc od oe b">//4</code> —为了检查值是否过期，我们使用另一个计算属性。这里，我们首先解开<code class="fe ob oc od oe b">countdown</code>和<code class="fe ob oc od oe b">start</code>，最后检查经过了多长时间。</p><p id="aea0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">由于<code class="fe ob oc od oe b">timeIntervalSinceNow</code>返回一个过去日期的负数，我们需要将它乘以-1。</p><p id="b86d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们创建一个如何在您的应用程序中使用该属性包装器的示例:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nz oa l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">在应用程序中使用属性wrapper @Expirable。</p></figure><p id="90c1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe ob oc od oe b">//1</code> —我们可以用<code class="fe ob oc od oe b">@Expirable</code>注释任何属性，并传入该值有效的秒数。</p><p id="b536" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe ob oc od oe b">//2</code> —当我们用一个计时器每秒打印包装属性的值时，我们可以看到它将在三秒内具有初始值。一旦过了这段时间，该值将为零。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="3246" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">恰好更新一次值</h1><p id="0f7e" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">属性的值只能更改一次。完成后，将忽略以下所有更改。</p><h2 id="dbe4" class="mz md it bd me na nb dn mi nc nd dp mm li ne nf mo lm ng nh mq lq ni nj ms nk bi translated"><strong class="ak">用例</strong></h2><ul class=""><li id="6177" class="nl nm it lb b lc mu lf mv li nn lm no lq np lu nq nr ns nt bi translated">首次启动应用程序时，您会显示一个教程。然后存储一个布尔标志，以记住用户已经看过了教程。</li><li id="a51b" class="nl nm it lb b lc nu lf nv li nw lm nx lq ny lu nq nr ns nt bi translated">你的用户可以通过应用内购买移除广告。一旦用户这样做了，你就再也不会显示广告了。</li></ul><h2 id="2f04" class="mz md it bd me na nb dn mi nc nd dp mm li ne nf mo lm ng nh mq lq ni nj ms nk bi translated"><strong class="ak">实施</strong></h2><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nz oa l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">实现只更新一次值的属性包装。</p></figure><p id="52ba" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe ob oc od oe b">//1</code> —就像在第一个例子中一样，我们创建一个用<code class="fe ob oc od oe b">@propertyWrapper</code>注释的新结构。但是因为我们需要比较新旧值，它将只包装符合协议<code class="fe ob oc od oe b">Equatable</code>的类型。</p><p id="c743" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe ob oc od oe b">//2</code> —当初始化这个属性包装器时，我们将给定值存储为初始值和当前值。这让我们可以很容易地检查计算属性<code class="fe ob oc od oe b">wrappedValue</code>中的值是否已经改变。</p><p id="2e3b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe ob oc od oe b">//3</code> —最后，我们实现<code class="fe ob oc od oe b">wrappedValue</code>。每次要设置新值时，我们首先检查<code class="fe ob oc od oe b">currentValue</code>是否与<code class="fe ob oc od oe b">initialValue</code>相同。如果不是这样，这个值已经被改变了一次，因此，我们不会再更新它。</p><p id="3bda" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">下面，您可以看到如何使用此属性包装的示例:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nz oa l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">在应用程序中使用属性wrapper @UpdatableOnce。</p></figure><p id="69eb" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe ob oc od oe b">//1</code> —这一次，我们可以只将包装器添加到等价的属性中。</p><p id="d72e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe ob oc od oe b">//2</code> —我们可以像设置任何其他属性一样设置值，它会改变它的值。</p><p id="66eb" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">但是一旦我们做了这件事，下次就不能改变了。相反，该值将保持不变。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="fb5b" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">仅使用定义的步骤更新值</h1><p id="02fa" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">属性值只能按预定义的步骤增加。</p><h2 id="cd3f" class="mz md it bd me na nb dn mi nc nd dp mm li ne nf mo lm ng nh mq lq ni nj ms nk bi translated"><strong class="ak">用例</strong></h2><ul class=""><li id="aa4c" class="nl nm it lb b lc mu lf mv li nn lm no lq np lu nq nr ns nt bi translated">玩家可以在游戏中收集不同价值的硬币。一枚硬币增加玩家的信用1，另一枚增加3，最后一枚增加5。这个属性包装器确保没有其他数字可以添加到信用。</li><li id="c4ee" class="nl nm it lb b lc nu lf nv li nw lm nx lq ny lu nq nr ns nt bi translated">您的用户需要执行特定次数的给定任务。这个应用程序用一个计数器记录这个数字。通过确保该计数器只能增加1，您可以确保用户确实做了他们需要做的事情。</li></ul><h2 id="a746" class="mz md it bd me na nb dn mi nc nd dp mm li ne nf mo lm ng nh mq lq ni nj ms nk bi translated"><strong class="ak">实施</strong></h2><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nz oa l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">实现只在预定义步骤中更新值的属性包装。</p></figure><p id="a2d3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe ob oc od oe b">//1</code> —当创建结构<code class="fe ob oc od oe b">Steppable</code>时，我们需要将泛型参数<code class="fe ob oc od oe b">Value</code>约束到实现<code class="fe ob oc od oe b">AdditiveArithmetric</code>的所有类型。这意味着它只能包装支持加法和减法的类型。</p><p id="b20a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe ob oc od oe b">//2</code> — <code class="fe ob oc od oe b">Steppable</code>使用两个私有属性，它包装的值和可接受的更改。两者都在初始化器中设置。</p><p id="a923" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe ob oc od oe b">//3</code> —每当包装值更新时，我们检查旧值和新值之间的差异是否允许。如果是这种情况，我们更新该值。</p><p id="211b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">注意:我们有多种选择来处理不允许新值的情况。</p><p id="83c1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">例如，我们可以简单地返回而不做任何更改，或者向控制台打印一条消息，但是在这个例子中，我们使用<code class="fe ob oc od oe b">preconditionFailure</code>来显式地捕捉错误的更改并停止应用程序。</p><p id="7da0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">使用这个属性包装器非常简单:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nz oa l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">在应用程序中使用属性wrapper @ Steppable。</p></figure><p id="0fd7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe ob oc od oe b">//1</code> —当使用这个属性包装器时，我们需要用一个包含可接受更改的数组来初始化它。在这种情况下，我们希望允许我们的值改变1、3和5。</p><p id="d8c8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe ob oc od oe b">//2</code> —当增加这些值中的一个时，它会按预期更新。</p><p id="dd1b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe ob oc od oe b">//3</code> —但是当我们用任何其他值改变它时，它将保持不变。</p><p id="899c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe ob oc od oe b">//4</code> —此外，在分配新值时，需要遵循以下准则。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="29d2" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">结论</h1><p id="af69" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">正如我们在本文中看到的，属性包装器对于如何使用属性来说是非常强大的。</p><p id="e58a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">不用创建实现如何处理更改的逻辑的类，所有这些代码都可以在一个地方封装为属性包装器，这增加了可重用性并减少了代码重复。</p><p id="0045" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我希望您能和我一样发现属性包装器的神奇之处！请随意在您的项目中使用这些包装器并进行试验。</p></div></div>    
</body>
</html>