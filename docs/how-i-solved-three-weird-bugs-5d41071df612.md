# 我如何解决三个奇怪的错误

> 原文：<https://betterprogramming.pub/how-i-solved-three-weird-bugs-5d41071df612>

## 从编译器问题到 Rube Goldberg 机器，工程有时并不像你想的那样科学

![](img/f7efe1a970f5ac4c510c6bb1c016c088.png)

图片来自[罗恩·范·登伯格](https://pixabay.com/users/ronberg-3029970/?utm_source=link-attribution&utm_medium=referral&utm_campaign=image&utm_content=1593406)来自[皮克斯拜](https://pixabay.com/?utm_source=link-attribution&utm_medium=referral&utm_campaign=image&utm_content=1593406)

软件是复杂的，在很多情况下，是复杂的。即使是简单的系统也可能有许多活动部件，它们以神秘的、意想不到的方式相互作用。

如果你幸运的话，这些交互不会导致严重的问题。

如果你运气不好，他们会这样做，你会得到一堆错误。

如果你非常不幸，你不会得到任何错误，让问题恶化多年，而它悄悄地肆虐你的数据。

以下是我职业生涯中见过的一些令人难忘的错误。

# “此报告使我的计算机崩溃”

我的项目经理给我发了一封电子邮件，说一个用户报告说，在我工作的一个内部企业 web 应用程序上下载报告时，他们的计算机崩溃了。

我觉得很奇怪。生成 CSV 报告时的错误不应该导致计算机崩溃——用户一定弄错了。

深究了一下，原来电脑确实死机了。嗯，具体来说，**浏览器挂了。最终用户并不关心他们的电脑无法运行和浏览器无法运行之间的区别，对他们来说这是一回事。**

什么会导致浏览器挂起？我首先想到的是无限循环、CPU 使用率和内存泄漏。在加载报告时检查资源使用情况，我看到 CPU 使用保持稳定，但内存随着时间的推移不断攀升，直到消耗了千兆字节的内存。

我的第一个想法是，这是由于报告太大而无法呈现，但从根本上说，这没有意义——报告是在服务器端生成的，它甚至还没有到达前端。

## 源头

做了更多的调查，我找到了原因。事实证明，无论是谁开发了负载指示器组件，都构建了一些工作正常但存在根本问题的东西。代码如下所示:

```
function setLoading() {
  showLoadingIndicator(0);
}function showLoadingIndicator(frame) {
  if(this.isDone) {
   hidePopup();  
  }
  else {
    setTimeout(function() {
      var indicator = document.findByElementId('indicator');
      var number = (frame > 12 ? 0 : frame + 1);
      indicator.addElement('spinner_' + number + '.jpg');
      showLoadingIndicator(number);
    }, 100);
  }
}
```

先前的开发人员没有使用动画`.gif`或 CSS 过渡/转换，而是创造性地选择将加载动画分成一系列图像帧，然后通过 JavaScript 超时函数连续添加到 DOM 中。

## 问题是

从技术上讲，浏览器每隔几毫秒就会不断地将图像作为 DOM 元素添加进来。在这样做的时候，它并没有清除旧的元素——它只是在前一帧的基础上添加了下一帧动画。

巧合的是，图像本身也是不透明的，这意味着你看不到它下面的旧的装载指示器框架。然而，尽管它满足了“添加一个负载指示器”的标准，但它却以一种非常容易出错的方式来实现。

随着时间的推移，随着系统需要报告的数据越来越多，报告的加载时间也越来越长，页面上的图像也越来越多。它最终导致浏览器在等待时最大限度地使用内存，有效地使用户的浏览器崩溃并导致其挂起。

A+代表创造力。

我把它换成了 GIF，继续我的一天。

## 吸取的教训

实施质量很重要。

看似有效的东西可能以如此落后的方式实现，以至于将来会引发问题。

这就像一栋用劣质材料和工艺建造的房子:它可能满足了目的，但你面临着它全部倒塌或导致修复费用昂贵的问题的风险。

仅仅因为某样东西看起来满足了它的需求，并不意味着它不会引起问题。

# 兑换柜台的情况

> 病菌
> 
> 优先级:非常低
> 
> 区域:管理
> 
> 事务列表底部的计数器随机变化。

那是我有一天看到的 bug 报告。我在会议间隙有一些空闲时间，所以我想我可以解决一些在优先列表中永远不会出现的小问题。

该问题描述了一个关于内部面向管理的页面的小投诉。我和记者聊了聊，他笑着说他已经处理了一段时间了，没什么大不了的。他认为他应该指出这一点，以体现我们新的接收流程的精神。他并没有特别在意这件事，也没有影响到他的工作。

我向他表示感谢，并决心至少解决这个小问题，以表明遵循摄入过程是有好处的！尽管它被列为“非常低”的优先级，我还是有点担心:Jankiness 通常表示更深层次的结构问题。

第一步？重现该问题。我加载页面，果然，最下面的计数器变成了一个随机数——1289347 到 1289293。我刷新页面，数字又变了。哈哈，多么奇怪的系统怪癖…等一下。

哦哦。这个数字不是随机变化的，而是在减少。

## 正在调查

有方向性的东西都有原因。怀疑，我去了最后一页，然后刷新。那一页上的每一条记录都突然消失了——噗。快速浏览数据库证实了我的担心——果然，数据不见了。

这突然从一个有趣的视觉怪癖变成了一个全面的关键缺陷。我立即指示我们整个运营团队停止使用该页面。

## 原因

经过对代码的快速分析，我发现了这个问题。这是由于设计糟糕的服务类依赖于太多的实现细节。

这个类是这样工作的:

```
def load_records(record_ids)
  # A whole bunch of code
  records = get(record_ids)
  records = to_hash(records) rescue nil
  update_cache(records)
enddef update_cache(records)
  # A whole bunch of code
  records.each{|record| save_records_to_cache(record, field)}
enddef save_records_to_cache(record, field)
  # a whole bunch of code
  cache.delete(record['id'])
  # code to update hash values
  cache.save(record['id'], record)
end
```

**这做了什么？**它会加载一堆记录，或者在缓存中查找记录，或者，如果有缓存未命中，构建一个设置为缓存的值的散列。

在某些情况下，对象上的特定字段不再是最新的。在这些情况下，将重新计算该值，并更新缓存的值。

如果某个字段由于缓存未命中而必须更新，它会从哈希中删除旧值，计算新值，然后更新缓存。

**出了什么问题？**在系统开发过程中的某个时候，缓存功能被从内部页面中移除。它开始显示 ActiveRecord 对象，而不是显示缓存中存储为哈希的值。

在下游，隐藏在页面的某个地方，这个服务仍然在使用。它需要一个哈希，但却收到一个 ActiveRecord 对象。

由于对`rescue nil`的各种有趣的使用，代码神奇地工作了，这使得代码即使在其不变量被违反时也能继续运行。

当它点击`hash.delete(key)`时，它实际上是在调用`ActiveRecord#delete`而不是`Hash#delete`，因此删除了记录。

谜团解开了，但是谁知道窃听器存在了多久。

## 吸取的教训

鸭子打字是伟大的，但有时像鸭子一样嘎嘎叫的东西不是鸭子做的。检查不变量很重要，拥有定义良好的接口来实施前置条件/后置条件也很重要，尤其是在处理可能删除数据的事情时。

# “它在我的机器上工作，但在生产中不工作”

啊，古老的开发商问题。通常，这是配置问题或环境差异。

早在人们使用 Google Web Toolkit(一种 Java 到 JavaScript 的编译器)的时候，我就遇到了一个问题:这个应用在生产环境中会是空白的，但在临时环境和本地环境中运行良好。

太荒谬了。我们在代码中找不到错误。在当地，一切正常。我们甚至将前端指向我们的生产环境，以防出现数据问题，但一切仍然正常。

困惑之余，我构建了代码库，就好像它是一个生产环境一样(对于这样一个紧密集成的系统来说，这是一个困难的壮举)，它最终抛出了错误。

```
a.b is not defined
r.c() #1
f.l() #2
z.g(a,d,j)
```

## *什么？*

我一行一行地追踪混乱的代码。因为它是在应用程序加载时发生的，而且应用程序中的许多东西都是即时加载的，所以我们无法判断是哪部分代码引发了这个问题。

如果你曾经钻研过混乱的代码，你就会知道其中的挑战:随机的字母和符号让追踪变得很痛苦。

更糟糕的是，当我们将打印语句和其他标记添加到我们认为会触发它的区域时，错误似乎会移动到应用程序的完全不同的部分。另外，请注意，每个更改都需要大约 5 到 15 分钟的编译时间。

最后，我有了一个想法:我在我们看到行为的特定代码路径中重命名了我的所有变量。又编译了一次，成功了！

问题？原来在我们使用的 Google Web Toolkit 编译器版本中有一个不为人知的错误。在缩小的过程中，有相同名称但方法不同的变量被删除和遗忘。我们拥有的特定代码结构，加上变量的命名，随机触发了这个问题。

由于客户端环境问题，我们无法更新我们的 Google Web Toolkit 版本，因此我们通过添加一个约定来有意避免特定的代码结构，从而解决了这个问题。

## 吸取的教训

有时这不是你的错，不承认会导致你浪费大量时间在错误的地方寻找解决方案。