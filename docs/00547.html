<html>
<head>
<title>Kubernetes Tips: Give Access To Your Cluster With A Client Certificate</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Kubernetes提示:使用客户端证书访问您的集群</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/k8s-tips-give-access-to-your-clusterwith-a-client-certificate-dfb3b71a76fe?source=collection_archive---------0-----------------------#2019-06-08">https://betterprogramming.pub/k8s-tips-give-access-to-your-clusterwith-a-client-certificate-dfb3b71a76fe?source=collection_archive---------0-----------------------#2019-06-08</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="0925" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">让用户访问新的Kubernetes集群的简单指南，包括身份验证设置和角色绑定</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/5675a05ff0fc4cb7a64172932065c1e1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*bC9X7IX5KxUcpqOGWvFcWg.png"/></div></div></figure><p id="8032" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">我们刚刚建立了一个全新的Kubernetes集群(恭喜！🎉).它将很快在整个公司范围内使用，我们已经有了一位同事，来自<em class="lq">开发</em>团队的Dave，他想开始使用beast，并在其上部署和测试他的全新微服务应用。我们能做些什么简单的步骤让他进入？这就是这篇文章的内容(提示:我们将使用x509客户端证书)。</p></div><div class="ab cl lr ls hx lt" role="separator"><span class="lu bw bk lv lw lx"/><span class="lu bw bk lv lw lx"/><span class="lu bw bk lv lw"/></div><div class="im in io ip iq"><h1 id="443b" class="ly lz it bd ma mb mc md me mf mg mh mi jz mj ka mk kc ml kd mm kf mn kg mo mp bi translated">Kubernetes中的用户管理</h1><p id="9199" class="pw-post-body-paragraph ku kv it kw b kx mq ju kz la mr jx lc ld ms lf lg lh mt lj lk ll mu ln lo lp im bi translated">为了管理Kubernetes集群和其上运行的应用程序，通常使用<a class="ae mv" href="https://kubernetes.io/docs/tasks/tools/install-kubectl/" rel="noopener ugc nofollow" target="_blank"> kubectl </a>二进制文件或<a class="ae mv" href="https://kubernetes.io/docs/tasks/access-application-cluster/web-ui-dashboard/" rel="noopener ugc nofollow" target="_blank"> Web UI </a>。在幕后，这些工具调用API服务器:HTTP Rest API公开集群控制平面的所有端点。</p><p id="b796" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">(这个HTTP API的文档很棒，随便看看:<a class="ae mv" href="https://kubernetes.io/docs/reference/generated/kubernetes-api/v1.14" rel="noopener ugc nofollow" target="_blank">https://kubernetes . io/docs/reference/generated/kubernetes-API/v 1.14</a>)</p><p id="1e6a" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">当一个请求被发送到API服务器时，在它被授权(确保请求者被允许执行所请求的动作)之前，首先需要对它进行认证(确保请求者被系统识别)。</p><p id="ed7d" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">认证步骤是通过使用认证插件来完成的。有几个插件可以使用不同的认证机制:</p><ul class=""><li id="a1f0" class="mw mx it kw b kx ky la lb ld my lh mz ll na lp nb nc nd ne bi translated">客户端证书(我们将在本文中讨论)</li><li id="b377" class="mw mx it kw b kx nf la ng ld nh lh ni ll nj lp nb nc nd ne bi translated">不记名代币</li><li id="9f7a" class="mw mx it kw b kx nf la ng ld nh lh ni ll nj lp nb nc nd ne bi translated">认证代理</li><li id="8a98" class="mw mx it kw b kx nf la ng ld nh lh ni ll nj lp nb nc nd ne bi translated">HTTP基本身份验证</li></ul><p id="f4cf" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">根据所使用的认证机制，相应的插件期望在特定位置找到用户信息。例如，对于客户端证书认证，应该在证书的<em class="lq">通用名称</em> (CN)字段中提供用户的标识(他们的id、姓名、电子邮件等)，并且应该在<em class="lq">组织</em> (O)字段中提供组信息(如果有)。我们很快会在一个例子中看到这一点。</p><p id="4893" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">Kubernetes集群中既没有用户资源，也没有组资源。这应该在集群之外处理，并随发送到API服务器的每个请求一起提供。</p><p id="4dc5" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">如果事情还不太清楚，请不要担心，我们将在下面举例说明。</p></div><div class="ab cl lr ls hx lt" role="separator"><span class="lu bw bk lv lw lx"/><span class="lu bw bk lv lw lx"/><span class="lu bw bk lv lw"/></div><div class="im in io ip iq"><h1 id="9da9" class="ly lz it bd ma mb mc md me mf mg mh mi jz mj ka mk kc ml kd mm kf mn kg mo mp bi translated">一些考虑和假设</h1><ul class=""><li id="1fd8" class="mw mx it kw b kx mq la mr ld nk lh nl ll nm lp nb nc nd ne bi translated">集群将由几个团队/客户端使用(多租户方法)，因为每个租户的工作负载需要隔离。我们将首先创建一个名为<em class="lq"> development </em>的名称空间，专门用于开发团队(Dave所属的团队)。</li><li id="ea98" class="mw mx it kw b kx nf la ng ld nh lh ni ll nj lp nb nc nd ne bi translated">Dave需要部署标准的Kubernetes资源。然后，他将被授予仅创建、列出、更新、获取和删除部署和服务资源的权限。如果需要，以后可以提供额外的权利。我们将确保这些权利仅限于<em class="lq">开发</em>命名空间。</li><li id="a340" class="mw mx it kw b kx nf la ng ld nh lh ni ll nj lp nb nc nd ne bi translated">Dave团队的其他成员以后可能需要拥有相同级别的访问权限。因此，我们将考虑一个名为<em class="lq"> dev </em>的组，并提供组级别的权限。</li><li id="1327" class="mw mx it kw b kx nf la ng ld nh lh ni ll nj lp nb nc nd ne bi translated">Dave需要安装<em class="lq"> kubectl </em>(这可能已经发生了，因为他可能已经在这台本地机器上玩了<a class="ae mv" href="https://kubernetes.io/docs/setup/minikube/" rel="noopener ugc nofollow" target="_blank"> <em class="lq"> Minikube </em> </a>)，他还需要<a class="ae mv" href="https://www.openssl.org/" rel="noopener ugc nofollow" target="_blank"> <em class="lq"> openssl </em> </a>，因为他将生成一个私钥和一个证书登录请求。</li></ul></div><div class="ab cl lr ls hx lt" role="separator"><span class="lu bw bk lv lw lx"/><span class="lu bw bk lv lw lx"/><span class="lu bw bk lv lw"/></div><div class="im in io ip iq"><h1 id="8458" class="ly lz it bd ma mb mc md me mf mg mh mi jz mj ka mk kc ml kd mm kf mn kg mo mp bi translated">创建私钥和证书签名请求(CSR)</h1><p id="3d84" class="pw-post-body-paragraph ku kv it kw b kx mq ju kz la mr jx lc ld ms lf lg lh mt lj lk ll mu ln lo lp im bi translated">Dave首先需要生成一个私有rsa密钥和一个CSR。使用以下命令可以很容易地创建私钥:</p><pre class="kj kk kl km gt nn no np nq aw nr bi"><span id="0ab9" class="ns lz it no b gy nt nu l nv nw"><strong class="no iu">$ openssl genrsa -out dave.key 4096</strong></span></pre><p id="686a" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">企业社会责任有点复杂。戴夫需要确保他:</p><ul class=""><li id="9bfb" class="mw mx it kw b kx ky la lb ld my lh mz ll na lp nb nc nd ne bi translated">在Common Name (CN)字段中使用他的名字:这将用于在API服务器中识别他。</li><li id="341a" class="mw mx it kw b kx nf la ng ld nh lh ni ll nj lp nb nc nd ne bi translated">使用organization(O)字段中的组名:这将用于根据API服务器识别组。</li></ul><p id="73d7" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">下面是Dave将用来生成CSR的配置文件:</p><pre class="kj kk kl km gt nn no np nq aw nr bi"><span id="9100" class="ns lz it no b gy nt nu l nv nw">[ req ]<br/>default_bits = 2048<br/>prompt = no<br/>default_md = sha256<br/>distinguished_name = dn</span><span id="0f46" class="ns lz it no b gy nx nu l nv nw">[ dn ]<br/>CN = dave<br/>O = dev</span><span id="6d1c" class="ns lz it no b gy nx nu l nv nw">[ v3_ext ]<br/>authorityKeyIdentifier=keyid,issuer:always<br/>basicConstraints=CA:FALSE<br/>keyUsage=keyEncipherment,dataEncipherment<br/>extendedKeyUsage=serverAuth,<strong class="no iu">clientAuth</strong></span></pre><p id="ff1e" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated"><strong class="kw iu">注意</strong>:extendedkey usage字段中的clientAuth条目很重要，因为证书将用于识别客户端。</p><p id="68ee" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">使用上面的配置文件(保存在csr.cnf中)，可以使用以下命令创建csr:</p><pre class="kj kk kl km gt nn no np nq aw nr bi"><span id="3de6" class="ns lz it no b gy nt nu l nv nw">$ openssl req -config ./csr.cnf -new -key dave.key -nodes -out dave.csr</span></pre><p id="7a07" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">一旦。csr文件已创建，Dave需要将其发送给我们(管理员),这样我们就可以使用群集证书颁发机构对其进行签名。这是我们下一步要讨论的。</p></div><div class="ab cl lr ls hx lt" role="separator"><span class="lu bw bk lv lw lx"/><span class="lu bw bk lv lw lx"/><span class="lu bw bk lv lw"/></div><div class="im in io ip iq"><h1 id="e8b3" class="ly lz it bd ma mb mc md me mf mg mh mi jz mj ka mk kc ml kd mm kf mn kg mo mp bi translated">CSR的签名</h1><p id="fbc0" class="pw-post-body-paragraph ku kv it kw b kx mq ju kz la mr jx lc ld ms lf lg lh mt lj lk ll mu ln lo lp im bi translated">的签名。csr文件将导致证书的创建。这个将用于验证Dave发送给API服务器的每个请求。</p><p id="c3c8" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">我们将首先创建一个Kubernetes CertificateSigninRequest资源。</p><p id="78a1" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated"><strong class="kw iu">注意</strong>:我们可能已经建立了一个托管集群(有很多这样的集群:<a class="ae mv" href="https://digitalocean.com" rel="noopener ugc nofollow" target="_blank">数字海洋</a>、<a class="ae mv" href="https://cloud.google.com/kubernetes-engine/" rel="noopener ugc nofollow" target="_blank">谷歌的GKE </a>、<a class="ae mv" href="https://azure.microsoft.com/fr-fr/services/kubernetes-service/" rel="noopener ugc nofollow" target="_blank">微软的Azure AKS </a>、…)，或者创建了我们自己的集群(使用<a class="ae mv" href="https://kubernetes.io/fr/docs/setup/independent/install-kubeadm/" rel="noopener ugc nofollow" target="_blank"> kubeadm </a>、<a class="ae mv" href="https://github.com/kubernetes-sigs/kubespray" rel="noopener ugc nofollow" target="_blank"> kubespray </a>、…)。过程是一样的。</p><p id="5ef6" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">我们将使用下面的规范，并将其保存在<em class="lq"> csr.yaml </em>中。</p><pre class="kj kk kl km gt nn no np nq aw nr bi"><span id="f00b" class="ns lz it no b gy nt nu l nv nw">apiVersion: certificates.k8s.io/v1beta1<br/>kind: CertificateSigningRequest<br/>metadata:<br/>  name: mycsr<br/>spec:<br/>  groups:<br/>  - system:authenticated<br/>  request: ${BASE64_CSR}<br/>  usages:<br/>  - digital signature<br/>  - key encipherment<br/>  - server auth<br/>  - client auth</span></pre><p id="4581" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">正如我们所见，<em class="lq">请求</em>键的值是<em class="lq"> BASE64_CSR </em>环境变量的内容。第一步是获取。csr文件，然后在创建资源之前使用<a class="ae mv" href="https://www.gnu.org/software/gettext/manual/html_node/envsubst-Invocation.html" rel="noopener ugc nofollow" target="_blank"> <em class="lq"> envsubst </em> </a>二进制来替换该变量的值。</p><pre class="kj kk kl km gt nn no np nq aw nr bi"><span id="5e1c" class="ns lz it no b gy nt nu l nv nw"># Encoding the .csr file in base64<br/><strong class="no iu">$ export BASE64_CSR=$(cat ./dave.csr | base64 | tr -d '\n')</strong></span><span id="f528" class="ns lz it no b gy nx nu l nv nw"># Substitution of the BASE64_CSR env variable and creation of the CertificateSigninRequest resource<strong class="no iu"><br/>$ cat csr.yaml | envsubst | kubectl apply -f -</strong></span></pre><p id="f9f4" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">检查新创建的CSR的状态，我们可以看到它处于<em class="lq"> Pending </em>状态。</p><pre class="kj kk kl km gt nn no np nq aw nr bi"><span id="9438" class="ns lz it no b gy nt nu l nv nw"># Checking the status of the newly created CSR<br/><strong class="no iu">$ kubectl get csr<br/></strong>NAME        AGE   REQUESTOR            CONDITION<br/>mycsr       9s    28b93...d73801ee46   Pending</span></pre><p id="f62d" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">然后，我们可以使用以下命令批准该CSR:</p><pre class="kj kk kl km gt nn no np nq aw nr bi"><span id="f5ba" class="ns lz it no b gy nt nu l nv nw">$ kubectl certificate approve mycsr</span></pre><p id="92ae" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">再次检查CSR的状态，我们可以看到它现在已被批准。</p><pre class="kj kk kl km gt nn no np nq aw nr bi"><span id="8bb6" class="ns lz it no b gy nt nu l nv nw"><strong class="no iu">$ kubectl get csr<br/></strong>NAME        AGE   REQUESTOR            CONDITION<br/>mycsr       9s    28b93...d73801ee46   Approved,Issued</span></pre><p id="d30d" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">证书已创建。让我们将它从CSR资源中提取出来，并保存在一个名为<em class="lq"> dave.crt </em>的文件中，以检查里面有什么。</p><pre class="kj kk kl km gt nn no np nq aw nr bi"><span id="b49f" class="ns lz it no b gy nt nu l nv nw">$ kubectl get csr mycsr -o jsonpath='{.status.certificate}' \<br/>  | base64 --decode &gt; dave.crt</span></pre><p id="60c7" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">下面的<a class="ae mv" href="https://www.openssl.org/" rel="noopener ugc nofollow" target="_blank"> openssl </a>命令显示证书已经由DigitalOcean的集群CA(发行者部分)签名，主题包含CN (CommonName)字段中的<em class="lq"> dave </em>和O(organization)字段中的<em class="lq"> dev </em>，如dave在创建。csr文件。</p><pre class="kj kk kl km gt nn no np nq aw nr bi"><span id="2660" class="ns lz it no b gy nt nu l nv nw"><strong class="no iu">$ openssl x509 -in ./dave.crt -noout -text<br/></strong>Certificate:<br/>    Data:<br/>        Version: 3 (0x2)<br/>        Serial Number:<br/>            48:29:cf:ae:d6:...:09:33:ef:14:58<br/>    Signature Algorithm: sha256WithRSAEncryption<br/>        Issuer: O=DigitalOcean, CN=k8saas Cluster CA<br/>        Validity<br/>            Not Before: Jun  3 07:56:00 2019 GMT<br/>            Not After : Jun  2 07:56:00 2020 GMT<br/>        <strong class="no iu">Subject: O=dev, CN=dave</strong><br/>        Subject Public Key Info:<br/>            Public Key Algorithm: rsaEncryption<br/>                Public-Key: (4096 bit)<br/>                Modulus:<br/>...</span></pre><p id="7059" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated"><strong class="kw iu">注</strong>:本例中使用的集群是在<a class="ae mv" href="https://digitalocean.com" rel="noopener ugc nofollow" target="_blank"> DigitalOcean </a>上创建的托管Kubernetes集群。我们可以从群集证书颁发机构看到它。</p></div><div class="ab cl lr ls hx lt" role="separator"><span class="lu bw bk lv lw lx"/><span class="lu bw bk lv lw lx"/><span class="lu bw bk lv lw"/></div><div class="im in io ip iq"><h1 id="5c53" class="ly lz it bd ma mb mc md me mf mg mh mi jz mj ka mk kc ml kd mm kf mn kg mo mp bi translated">命名空间的创建</h1><p id="6581" class="pw-post-body-paragraph ku kv it kw b kx mq ju kz la mr jx lc ld ms lf lg lh mt lj lk ll mu ln lo lp im bi translated">我们首先创建一个名为<em class="lq"> development </em>的名称空间，这样Dave和他的团队将部署的所有资源都与集群的其他工作负载隔离开来。它可以用一个简单的命令创建:</p><pre class="kj kk kl km gt nn no np nq aw nr bi"><span id="8cb8" class="ns lz it no b gy nt nu l nv nw">$ kubectl create ns development</span></pre><p id="d5ff" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">或者用这个<em class="lq"> dev-ns.yaml </em>文件:</p><pre class="kj kk kl km gt nn no np nq aw nr bi"><span id="90a2" class="ns lz it no b gy nt nu l nv nw">apiVersion: v1<br/>kind: Namespace<br/>metadata:<br/>  name: <!-- -->development</span></pre><p id="6430" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">接着是通常的:</p><pre class="kj kk kl km gt nn no np nq aw nr bi"><span id="9071" class="ns lz it no b gy nt nu l nv nw">$ kubectl apply -f dev-ns.yaml</span></pre><p id="abe2" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated"><strong class="kw iu">注意</strong>:最佳实践是创建一个ResourceQuota资源并将其链接到名称空间，以便限制名称空间中可以使用的cpu和RAM的数量，但这是另一篇文章的内容。</p></div><div class="ab cl lr ls hx lt" role="separator"><span class="lu bw bk lv lw lx"/><span class="lu bw bk lv lw lx"/><span class="lu bw bk lv lw"/></div><div class="im in io ip iq"><h1 id="8ef8" class="ly lz it bd ma mb mc md me mf mg mh mi jz mj ka mk kc ml kd mm kf mn kg mo mp bi translated">设置RBAC规则</h1><p id="4501" class="pw-post-body-paragraph ku kv it kw b kx mq ju kz la mr jx lc ld ms lf lg lh mt lj lk ll mu ln lo lp im bi translated">通过创建一个证书，我们允许Dave针对API服务器进行身份验证，但是我们没有指定任何权限，因此他将不能做很多事情……我们将改变这一点，并授予他在<em class="lq"> dev </em>名称空间中创建、获取、更新、列出和删除部署和服务资源的权限。</p><p id="7216" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">下图显示了Kubernetes角色库访问控制(RBAC)中涉及的资源。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ny"><img src="../Images/016d5260e2b288c34917ffbe1d08bc9d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*s2OHCGlh-XH87ZT9xW2e0A.png"/></div></div><p class="nz oa gj gh gi ob oc bd b be z dk translated">所涉及资源的概述</p></figure><p id="512d" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">简而言之:角色(同样适用于集群角色)包含一系列规则。每个规则都定义了一些可以针对apiGroups(例如:core，apps/v1，…)内的资源列表(例如:Pod，Service，Secret)执行的操作(例如:list，get，watch，…)。角色定义特定命名空间的权限，而集群角色的范围是整个集群</p></div><div class="ab cl lr ls hx lt" role="separator"><span class="lu bw bk lv lw lx"/><span class="lu bw bk lv lw lx"/><span class="lu bw bk lv lw"/></div><div class="im in io ip iq"><h1 id="4904" class="ly lz it bd ma mb mc md me mf mg mh mi jz mj ka mk kc ml kd mm kf mn kg mo mp bi translated"><strong class="ak">角色的创建</strong></h1><p id="f454" class="pw-post-body-paragraph ku kv it kw b kx mq ju kz la mr jx lc ld ms lf lg lh mt lj lk ll mu ln lo lp im bi translated">让我们首先使用以下规范创建一个角色资源:</p><pre class="kj kk kl km gt nn no np nq aw nr bi"><span id="018c" class="ns lz it no b gy nt nu l nv nw">kind: Role<br/>apiVersion: rbac.authorization.k8s.io/v1<br/>metadata:<br/> namespace: development<br/> name: dev<br/>rules:<br/>- apiGroups: [""]<br/>  resources: ["pods", "services"]<br/>  verbs: ["create", "get", "update", "list", "delete"]<br/>- apiGroups: ["apps"]<br/>  resources: ["deployments"]<br/>  verbs: ["create", "get", "update", "list", "delete"]</span></pre><p id="7d15" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">Pods和服务资源属于<em class="lq">核心</em> API组(apiGroups键的值是空字符串)，而部署资源属于<em class="lq">应用</em> API组。对于这两个apiGroups，我们定义了资源列表和应该在这些资源上授权的操作。</p><p id="9a20" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">假设上面的内容在<em class="lq"> role.yaml </em>中，使用以下命令创建角色:</p><pre class="kj kk kl km gt nn no np nq aw nr bi"><span id="aff4" class="ns lz it no b gy nt nu l nv nw">$ kubectl apply -f role.yaml</span></pre></div><div class="ab cl lr ls hx lt" role="separator"><span class="lu bw bk lv lw lx"/><span class="lu bw bk lv lw lx"/><span class="lu bw bk lv lw"/></div><div class="im in io ip iq"><h1 id="fe35" class="ly lz it bd ma mb mc md me mf mg mh mi jz mj ka mk kc ml kd mm kf mn kg mo mp bi translated"><strong class="ak">创建角色绑定</strong></h1><p id="78fe" class="pw-post-body-paragraph ku kv it kw b kx mq ju kz la mr jx lc ld ms lf lg lh mt lj lk ll mu ln lo lp im bi translated">角色绑定的目的是链接角色(授权操作列表)和用户或组。为了让Dave拥有上述角色中指定的权限，我们需要将他绑定到这个角色。为此，我们将使用以下角色绑定资源:</p><pre class="kj kk kl km gt nn no np nq aw nr bi"><span id="23d1" class="ns lz it no b gy nt nu l nv nw">kind: RoleBinding<br/>apiVersion: rbac.authorization.k8s.io/v1<br/>metadata:<br/> name: dev<br/> namespace: development<br/>subjects:<br/>- kind: User<br/>  name: dave<br/>  apiGroup: rbac.authorization.k8s.io<br/>roleRef:<br/> kind: Role<br/> name: dev<br/> apiGroup: rbac.authorization.k8s.io</span></pre><p id="1909" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">此角色绑定链接:</p><ul class=""><li id="7574" class="mw mx it kw b kx ky la lb ld my lh mz ll na lp nb nc nd ne bi translated">一个主题:我们的用户戴夫。</li><li id="a8ca" class="mw mx it kw b kx nf la ng ld nh lh ni ll nj lp nb nc nd ne bi translated">角色:名为<em class="lq"> dev </em>的角色，它允许创建/获取/更新/列出/删除我们上面定义的部署和服务资源。</li></ul><p id="69ce" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated"><strong class="kw iu">注意</strong>:由于Dave属于<em class="lq"> dev </em>组，我们可以使用下面的RoleBinding将之前的角色与组绑定，而不是与单个用户绑定。请记住:组信息在随每个请求一起发送的证书的组织(O)字段中提供。</p><pre class="kj kk kl km gt nn no np nq aw nr bi"><span id="1064" class="ns lz it no b gy nt nu l nv nw">kind: RoleBinding<br/>apiVersion: rbac.authorization.k8s.io/v1<br/>metadata:<br/> name: dev<br/> namespace: development<br/>subjects:<br/>- kind: Group<br/>  name: dev<br/>  apiGroup: rbac.authorization.k8s.io<br/>roleRef:<br/> kind: Role<br/> name: dev<br/> apiGroup: rbac.authorization.k8s.io</span></pre><p id="3098" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">假设我们已经在<em class="lq"> role-binding.yaml </em>文件中保存了RoleBinding资源的规范，我们可以用下面的命令创建它:</p><pre class="kj kk kl km gt nn no np nq aw nr bi"><span id="7b85" class="ns lz it no b gy nt nu l nv nw">$ kubectl apply -f role-binding.yaml</span></pre></div><div class="ab cl lr ls hx lt" role="separator"><span class="lu bw bk lv lw lx"/><span class="lu bw bk lv lw lx"/><span class="lu bw bk lv lw"/></div><div class="im in io ip iq"><h1 id="77aa" class="ly lz it bd ma mb mc md me mf mg mh mi jz mj ka mk kc ml kd mm kf mn kg mo mp bi translated">为Dave构建Kube配置</h1><p id="92b9" class="pw-post-body-paragraph ku kv it kw b kx mq ju kz la mr jx lc ld ms lf lg lh mt lj lk ll mu ln lo lp im bi translated">一切都准备好了。我们现在必须向Dave发送他需要的信息，以配置他的本地kubectl客户机与我们的集群通信。</p><p id="c235" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">我们将首先创建一个<em class="lq"> kubeconfig.tpl </em>文件，它包含以下内容，我们将把它用作模板。</p><pre class="kj kk kl km gt nn no np nq aw nr bi"><span id="cc7d" class="ns lz it no b gy nt nu l nv nw">apiVersion: v1<br/>kind: Config<br/>clusters:<br/>- cluster:<br/>    certificate-authority-data: ${CLUSTER_CA}<br/>    server: ${CLUSTER_ENDPOINT}<br/>  name: ${CLUSTER_NAME}<br/>users:<br/>- name: ${USER}<br/>  user:<br/>    client-certificate-data: ${CLIENT_CERTIFICATE_DATA}<br/>contexts:<br/>- context:<br/>    cluster: ${CLUSTER_NAME}<br/>    user: dave<br/>  name: ${USER}-${CLUSTER_NAME}<br/>current-context: ${USER}-${CLUSTER_NAME}</span></pre><p id="e4f7" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">为了从这个模板构建一个基本的kube配置，我们首先需要设置所有需要的环境变量:</p><pre class="kj kk kl km gt nn no np nq aw nr bi"><span id="aacf" class="ns lz it no b gy nt nu l nv nw"># User identifier<br/><strong class="no iu">$ export USER="dave"</strong></span><span id="d8a9" class="ns lz it no b gy nx nu l nv nw"># Cluster Name (get it from the current context)<br/><strong class="no iu">$ export CLUSTER_NAME=$(kubectl config view --minify -o jsonpath={.current-context})</strong></span><span id="24ee" class="ns lz it no b gy nx nu l nv nw"># Client certificate<br/><strong class="no iu">$ export CLIENT_CERTIFICATE_DATA=$(kubectl get csr mycsr -o jsonpath='{.status.certificate}')</strong></span><span id="7fff" class="ns lz it no b gy nx nu l nv nw"># Cluster Certificate Authority<br/><strong class="no iu">$ export CLUSTER_CA=$(kubectl config view --raw -o json | jq -r '.clusters[] | select(.name == "'$(kubectl config current-context)'") | .cluster."certificate-authority-data"')</strong></span><span id="62f5" class="ns lz it no b gy nx nu l nv nw"># API Server endpoint<br/><strong class="no iu">$ export CLUSTER_ENDPOINT=$(kubectl config view --raw -o json | jq -r '.clusters[] | select(.name == "'$(kubectl config current-context)'") | .cluster."server"')</strong></span></pre><p id="8cd6" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">并再次使用方便的<a class="ae mv" href="https://www.gnu.org/software/gettext/manual/html_node/envsubst-Invocation.html" rel="noopener ugc nofollow" target="_blank"> envsubst </a>实用程序替换它们:</p><pre class="kj kk kl km gt nn no np nq aw nr bi"><span id="76e5" class="ns lz it no b gy nt nu l nv nw">$ cat kubeconfig.tpl | <!-- -->envsubst &gt; kubeconfig</span></pre><p id="3e38" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">我们现在可以将这个<em class="lq"> kubeconfig </em>文件发送给戴夫，他只需在其中添加自己的私钥，就可以与集群通信了。</p></div><div class="ab cl lr ls hx lt" role="separator"><span class="lu bw bk lv lw lx"/><span class="lu bw bk lv lw lx"/><span class="lu bw bk lv lw"/></div><div class="im in io ip iq"><h1 id="7541" class="ly lz it bd ma mb mc md me mf mg mh mi jz mj ka mk kc ml kd mm kf mn kg mo mp bi translated">上下文的使用</h1><p id="1be1" class="pw-post-body-paragraph ku kv it kw b kx mq ju kz la mr jx lc ld ms lf lg lh mt lj lk ll mu ln lo lp im bi translated">为了使用<em class="lq"> kubeconfig，</em> Dave可以用指向文件的路径设置kubeconfig环境变量。</p><pre class="kj kk kl km gt nn no np nq aw nr bi"><span id="d7f5" class="ns lz it no b gy nt nu l nv nw">$ export KUBECONFIG=$PWD/kubeconfig</span></pre><p id="74fa" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated"><strong class="kw iu">注意</strong>:使用Kubernetes配置有不同的方法:设置<em class="lq"> KUBECONFIG </em>环境变量，在默认的<em class="lq"> $HOME/中添加一个新条目。kube/config </em>文件，或者在每个<em class="lq"> kubectl </em>命令上使用- <em class="lq"> kubeconfig </em>标志。</p><p id="976e" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">要添加他的私有密钥，dave.key 在流程开始时生成，dave可以使用以下命令:</p><pre class="kj kk kl km gt nn no np nq aw nr bi"><span id="ccbd" class="ns lz it no b gy nt nu l nv nw">$ kubectl config set-credentials dave \<br/>  --client-key=$PWD/dave.key \<br/>  <!-- -->--embed-certs=true</span></pre><p id="761d" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">它将在<em class="lq"> kubeconfig </em>文件的用户条目中创建密钥<em class="lq"> client-key-data </em>，并将<em class="lq"> dave.key </em>的base64编码设置为值。</p><p id="5738" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">如果一切正常，Dave应该能够使用以下命令检查服务器(和客户机)的版本:</p><pre class="kj kk kl km gt nn no np nq aw nr bi"><span id="816e" class="ns lz it no b gy nt nu l nv nw">$ kubectl version<br/>Client Version: version.Info{Major:"1", Minor:"14", GitVersion:"v1.14.2", GitCommit:"66049e3b21efe110454d67df4fa62b08ea79a19b", GitTreeState:"clean", BuildDate:"2019-05-16T16:23:09Z", GoVersion:"go1.12.5", Compiler:"gc", Platform:"darwin/amd64"}<br/><strong class="no iu">Server Version: version.Info{Major:"1", Minor:"14", GitVersion:"v1.14.2", GitCommit:"66049e3b21efe110454d67df4fa62b08ea79a19b", GitTreeState:"clean", BuildDate:"2019-05-16T16:14:56Z", GoVersion:"go1.12.5", Compiler:"gc", Platform:"linux/amd64"}</strong></span></pre><p id="3227" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">让我们更进一步，检查与Dave关联的当前角色是否允许他列出集群的节点。</p><pre class="kj kk kl km gt nn no np nq aw nr bi"><span id="e73f" class="ns lz it no b gy nt nu l nv nw"><strong class="no iu">$ kubectl get nodes<br/></strong>Error from server (Forbidden): nodes is forbidden: User "dave" cannot list resource "nodes" in API group "" at the cluster scope</span></pre><p id="4c70" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">当然不是！但是Dave现在应该能够在集群上部署东西了——至少在名为<em class="lq"> development </em>的名称空间中。让我们用这个示例yml文件来检查一下，它定义了一个基于nginx映像的部署和一个公开它的服务。</p><pre class="kj kk kl km gt nn no np nq aw nr bi"><span id="a43e" class="ns lz it no b gy nt nu l nv nw"># www.yaml</span><span id="9c59" class="ns lz it no b gy nx nu l nv nw">apiVersion: apps/v1<br/>kind: Deployment<br/>metadata:<br/>  name: www<br/>  namespace: development<br/>spec:<br/>  replicas: 3<br/>  selector:<br/>    matchLabels:<br/>      app: www<br/>  template:<br/>    metadata:<br/>      labels:<br/>        app: www<br/>    spec:<br/>      containers:<br/>      - name: nginx<br/>        image: nginx:1.14-alpine<br/>        ports:<br/>        - containerPort: 80<br/>---<br/>apiVersion: v1<br/>kind: Service<br/>metadata:<br/>  name: www<br/>  namespace: development<br/>spec:<br/>  selector:<br/>    app: vote<br/>  type: ClusterIP<br/>  ports:<br/>  - port: 80<br/>    targetPort: 80</span></pre><p id="5153" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">我们可以从下面的命令中看到，Dave可以在集群中创建这些资源:</p><pre class="kj kk kl km gt nn no np nq aw nr bi"><span id="8daa" class="ns lz it no b gy nt nu l nv nw"><strong class="no iu">$ kubectl apply -f </strong><a class="ae mv" href="http://www.yaml" rel="noopener ugc nofollow" target="_blank"><strong class="no iu">www.yaml</strong></a><br/>deployment.apps/www created<br/>service/www created</span></pre><p id="fff1" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">Dave受限于<em class="lq">开发</em>名称空间。我们可以从他在试图列出默认名称空间中的所有窗格时得到的错误消息中确认这一点:</p><pre class="kj kk kl km gt nn no np nq aw nr bi"><span id="b187" class="ns lz it no b gy nt nu l nv nw"><strong class="no iu">$ kubectl get pods</strong><br/>Error from server (Forbidden): pods is forbidden: User “dave” cannot list resource “pods” in API group “” in the namespace “default”</span></pre><p id="32dd" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">此外，除了我们授予他访问权限的资源之外，他将无法创建其他资源。例如，我们可以考虑以下Secret类型资源的规范:</p><pre class="kj kk kl km gt nn no np nq aw nr bi"><span id="017c" class="ns lz it no b gy nt nu l nv nw"># credentials.yaml<br/>apiVersion: v1<br/>kind: Secret<br/>metadata:<br/>  name: mysecret<br/>  namespace: development<br/>data:<br/>  username: YWRtaW4=<br/>  password: MWYyZDFlMmU2N2Rm</span></pre><p id="7d57" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">让我们看看戴夫是如何创造它的:</p><pre class="kj kk kl km gt nn no np nq aw nr bi"><span id="1d9c" class="ns lz it no b gy nt nu l nv nw"><strong class="no iu">$ kubectl apply -f credentials.yaml</strong><br/>Error from server (Forbidden): error when retrieving current configuration of:<br/>Resource: “/v1, Resource=secrets”, GroupVersionKind: “/v1, Kind=Secret”<br/>Name: “mysecret”, Namespace: “development”<br/>Object: &amp;{map[“apiVersion”:”v1" “data”:map[“password”:”MWYyZDFlMmU2N2Rm” “username”:”YWRtaW4=”] “kind”:”Secret” “metadata”:map[“annotations”:map[“kubectl.kubernetes.io/last-applied-configuration”:””] “name”:”mysecret” “namespace”:”development”]]}<br/>from server for: “credentials.yaml”: secrets “mysecret” is forbidden: User “dave” cannot get resource “secrets” in API group “” in the namespace “development”</span></pre></div><div class="ab cl lr ls hx lt" role="separator"><span class="lu bw bk lv lw lx"/><span class="lu bw bk lv lw lx"/><span class="lu bw bk lv lw"/></div><div class="im in io ip iq"><h1 id="1cf3" class="ly lz it bd ma mb mc md me mf mg mh mi jz mj ka mk kc ml kd mm kf mn kg mo mp bi translated">摘要</h1><p id="bd72" class="pw-post-body-paragraph ku kv it kw b kx mq ju kz la mr jx lc ld ms lf lg lh mt lj lk ll mu ln lo lp im bi translated">在本文中，我们展示了如何使用客户端证书授权用户进入我们的Kubernetes集群。我们可以使用其他方法来设置这种身份验证，但这种方法非常简单(在另一篇文章中，我们将看到如何使用外部身份提供者)。</p><p id="6658" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">一旦建立了身份验证，我们就使用角色来定义一些仅限于名称空间的权限，并用RoleBinding将它绑定到用户。如果我们需要提供集群范围的权限，我们可以使用ClusterRole和ClusterRoleBinding资源。</p></div><div class="ab cl lr ls hx lt" role="separator"><span class="lu bw bk lv lw lx"/><span class="lu bw bk lv lw lx"/><span class="lu bw bk lv lw"/></div><div class="im in io ip iq"><p id="d15e" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">祝你好运！如果你尝试过，我很乐意在下面的评论中听到你的想法。</p></div></div>    
</body>
</html>