<html>
<head>
<title>Creating a Repository Data Layer With Kotlin Coroutines in Android</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">在Android中使用Kotlin协同程序创建存储库数据层</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/creating-a-repository-data-layer-with-kotlin-coroutines-in-android-1375ab79b6f0?source=collection_archive---------4-----------------------#2021-03-11">https://betterprogramming.pub/creating-a-repository-data-layer-with-kotlin-coroutines-in-android-1375ab79b6f0?source=collection_archive---------4-----------------------#2021-03-11</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="98e4" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">构建基于干净架构的Android应用的下一步</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/486bdb84af454f9649c64ffb210d3016.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*zHm3v2EUv4QBG-ZW"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated"><a class="ae ky" href="https://unsplash.com/@lazizli?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">拉拉·阿兹利</a>在<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的照片。</p></figure><p id="d875" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这是关于使用合适的干净架构构建Android应用程序的系列文章的第二部分。在今天的文章中，我们将通过创建一个存储库并讨论其实现和用例来关注领域和数据层。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="eeaa" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">快速回顾</h1><p id="5eab" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">在继续之前，我强烈推荐阅读本系列的第1部分，在其中我解释了为什么我们应该使用干净的架构以及如何使用Dagger2实现依赖注入。</p><ul class=""><li id="9a72" class="mz na it lb b lc ld lf lg li nb lm nc lq nd lu ne nf ng nh bi translated">【Android清洁架构教程(第一部分)</li></ul><p id="ff64" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这里，我选择使用协程而不是遗留的RxJava进行异步操作。我们正在用协程构建存储库和用例。为了实现网络请求，我们使用带有协程支持的<a class="ae ky" href="https://square.github.io/retrofit/" rel="noopener ugc nofollow" target="_blank">改型</a>。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="eda9" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">存储库和用例</h1><h2 id="c1d7" class="ni md it bd me nj nk dn mi nl nm dp mm li nn no mo lm np nq mq lq nr ns ms nt bi translated">贮藏室ˌ仓库</h2><p id="afd5" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">存储库是一个简单的接口，它提供了访问委托给<code class="fe nu nv nw nx b">Datasource</code>的数据的方法。简而言之，存储库是访问网络或本地数据库等数据源的抽象层。</p><p id="e531" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果你熟悉坚实的原则，你会知道高级模块不应该依赖于低级模块。两者都应该依赖于抽象。这里，我们将有两层:数据和域。</p><ul class=""><li id="74b1" class="mz na it lb b lc ld lf lg li nb lm nc lq nd lu ne nf ng nh bi translated">域:这包含应用程序的业务逻辑。它是独立的和最里面的模块。这是一个完整的Java模块。</li><li id="bcdf" class="mz na it lb b lc ny lf nz li oa lm ob lq oc lu ne nf ng nh bi translated">数据:这包括领域层。它将实现域层公开的接口，并将数据分发到应用程序。</li></ul><p id="f882" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">存储库接口位于域层之下，而存储库实现位于数据层之下，因此它可以委托给同样位于数据层之下的数据源。数据层可以依赖于域层，但反之则不然。这是将存储库接口保留在域层并将它的实现保留在数据层的原因之一。</p><h2 id="037a" class="ni md it bd me nj nk dn mi nl nm dp mm li nn no mo lm np nq mq lq nr ns ms nt bi translated">用例</h2><p id="cce1" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">很长一段时间，我觉得用例是架构工作的额外负担。我这么想是愚蠢的。我们来看看为什么。</p><p id="dfbb" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">例如，假设您将存储库中的<code class="fe nu nv nw nx b">doSomething</code>功能暴露给多个视图模型(例如5-6 <code class="fe nu nv nw nx b">ViewModels</code>)。如果将来那个函数的返回类型需要改变，我们将需要更新所有那些<code class="fe nu nv nw nx b">ViewModels</code>中的代码。这是可以通过用例解决的问题。</p><p id="fa77" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">一般来说，用例是从数据源(远程或本地)获取数据并将其返回给请求者的业务逻辑执行器。在我们的例子中，它是应用程序层。与存储库的每一个独特的交互都可以被视为一个用例。</p><p id="7e06" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们将为与存储库的每次交互创建一个用例，而不是直接从app模块访问存储库。我们使用我们的应用程序模块中的这种交互(如前所述，5-6 <code class="fe nu nv nw nx b">ViewModels</code>)来访问存储库。这样，如果您在数据源中进行任何更改，您可以在一个点上处理它们。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="bfe7" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">知识库模式</h1><p id="4982" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">为了在架构级别创建存储库模式，我们必须在主应用程序目录下创建两个包— <code class="fe nu nv nw nx b">data</code>和<code class="fe nu nv nw nx b">domain</code>。看一看:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi od"><img src="../Images/204b57ddae4e5371c3b2877498e2fc75.png" data-original-src="https://miro.medium.com/v2/resize:fit:1098/format:webp/1*HzOSz-wDGTc65O-W9ICuvA.png"/></div></figure><p id="5aee" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">第一步是在域层内创建一个名为<code class="fe nu nv nw nx b">Repository</code>的接口，并在数据层下创建一个名为<code class="fe nu nv nw nx b">RepositoryImpl</code>的实现类:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oe of l"/></div></figure><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi og"><img src="../Images/1ad199c8987415a11c11d07da32428e3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1150/format:webp/1*440M8NcZAqemG_8PhvtVpw.png"/></div></figure><p id="60f7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这是一个简单的存储库模式，满足了干净架构所基于的坚实原则。下一步是创建数据源。出于本文的考虑，我只包括一个远程数据源。如果您对如何创建多个数据源(例如远程和本地)并管理它们感兴趣，我强烈推荐您阅读以下文章:</p><div class="oh oi gp gr oj ok"><a href="https://levelup.gitconnected.com/how-to-create-a-perfect-repository-using-kotlin-exclusive-features-61c3121f22df" rel="noopener  ugc nofollow" target="_blank"><div class="ol ab fo"><div class="om ab on cl cj oo"><h2 class="bd iu gy z fp op fr fs oq fu fw is bi translated">如何使用Kotlin独有的特性创建一个完美的存储库</h2><div class="or l"><h3 class="bd b gy z fp op fr fs oq fu fw dk translated">组织您的数据和属性域图层</h3></div><div class="os l"><p class="bd b dl z fp op fr fs oq fu fw dk translated">levelup.gitconnected.com</p></div></div><div class="ot l"><div class="ou l ov ow ox ot oy ks ok"/></div></div></a></div><p id="de81" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">正如我所说的，我们使用协程来执行异步操作，并改进以发出网络请求。为了序列化数据，我们使用了<a class="ae ky" href="https://github.com/google/gson" rel="noopener ugc nofollow" target="_blank"> Gson </a>。要将这些库添加到您的项目中，请在应用程序级<code class="fe nu nv nw nx b">gradle</code>文件的依赖关系节点下添加以下几行:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oe of l"/></div></figure><p id="8b8f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在我们应该在数据层下创建一个API服务接口，作为远程数据源。在这个类中，我们将有<code class="fe nu nv nw nx b">suspend</code>函数，使用reform触发网络请求。看一看:</p><pre class="kj kk kl km gt oz nx pa pb aw pc bi"><span id="a1a4" class="ni md it nx b gy pd pe l pf pg">interface <strong class="nx iu">SampleApiService </strong>{</span><span id="b5d2" class="ni md it nx b gy ph pe l pf pg">}</span></pre><p id="446e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">包结构如下所示:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi pi"><img src="../Images/923fb1ffd0e6910c4717d46534669083.png" data-original-src="https://miro.medium.com/v2/resize:fit:1102/format:webp/1*tVf78dK7icwKPsnGjaxIjw.png"/></div></figure><h2 id="e7c0" class="ni md it bd me nj nk dn mi nl nm dp mm li nn no mo lm np nq mq lq nr ns ms nt bi translated">依赖注入</h2><p id="9f3c" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">在本系列的第一部分中，我们讨论了依赖注入——但只是在一定程度上。既然我们已经创建了一个经常充当依赖对象的数据源和存储库，我们需要使用Dagger2为这些组件实现依赖注入。</p><p id="2354" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">首先，我们需要创建一个返回远程数据源接口的函数。我们必须在本系列第一部分创建的<code class="fe nu nv nw nx b">NetworkModule</code>类中完成这项工作:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oe of l"/></div></figure><p id="e3c2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在我们可以将<code class="fe nu nv nw nx b">SampleApiService</code>注入到存储库的实现中来触发适当的服务。看一看:</p><pre class="kj kk kl km gt oz nx pa pb aw pc bi"><span id="5eae" class="ni md it nx b gy pd pe l pf pg">class RepositoryImpl <strong class="nx iu">@Inject constructor(<br/>    val sampleApiService: SampleApiService)</strong> : Repository {<br/>    <br/>}</span></pre></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="990a" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">用例</h1><p id="1fea" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">用例只不过是与存储库的独特交互。每个用例为来自数据源的相应响应提供了一个空间，在将响应传递回请求者之前，可以在这里进行必要的修改(在我们的例子中，是<code class="fe nu nv nw nx b">ViewModel</code>)。</p><p id="ce01" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">为了简化过程，我们将创建一个基本用例，每个用例都可以扩展它来导入必要的功能。首先，让我们用一个函数创建一个基本用例，该函数返回一个可以交付给<code class="fe nu nv nw nx b">ViewModel</code>的通用结果。</p><p id="8d73" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">基本上，我们将创建两个通用用例——一个有参数，另一个没有参数。我们将在<code class="fe nu nv nw nx b">base &gt; usecasetypes</code>包下创建它们。看一看:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oe of l"/></div></figure><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi pj"><img src="../Images/782b62999db37ab9a88e27111f7313fd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1324/format:webp/1*dIFcDRj2TXCaEiiKP-8R5A.png"/></div></figure><ul class=""><li id="dfc7" class="mz na it lb b lc ld lf lg li nb lm nc lq nd lu ne nf ng nh bi translated"><code class="fe nu nv nw nx b">P</code> —用例运行函数中要传递的参数类型。</li><li id="ceaa" class="mz na it lb b lc ny lf nz li oa lm ob lq oc lu ne nf ng nh bi translated"><code class="fe nu nv nw nx b">R</code> — <strong class="lb iu"> </strong>预期返回类型的结果类型。</li></ul><p id="bf16" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">为了更好地理解这一点，让我们创建一个简单的类并用<code class="fe nu nv nw nx b">BaseUseCaseWitOuthParams</code>扩展它。记住用例是在领域层下创建的。看一看:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oe of l"/></div></figure><h2 id="67ef" class="ni md it bd me nj nk dn mi nl nm dp mm li nn no mo lm np nq mq lq nr ns ms nt bi translated">依赖注入</h2><p id="ad52" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">用例的唯一目的是与存储库交互，这意味着我们需要将存储库注入到用例构造器中。在此之前，我们需要在数据模块中的<code class="fe nu nv nw nx b">di</code>目录下创建一个函数，该函数是在本系列的第1部分中创建的，返回类型为<code class="fe nu nv nw nx b">Repository</code>。看一看:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oe of l"/></div></figure><p id="e517" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在我们可以在<code class="fe nu nv nw nx b">SimpleUseCaseTest</code>中注入<code class="fe nu nv nw nx b">repository</code>对象，如下所示:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oe of l"/></div></figure><p id="efd9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在我们已经完成了依赖注入的存储库设置和用例。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="56b1" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">奖金</h1><h2 id="e347" class="ni md it bd me nj nk dn mi nl nm dp mm li nn no mo lm np nq mq lq nr ns ms nt bi translated">GitHub回购</h2><p id="f157" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">导入项目并切换到<code class="fe nu nv nw nx b">articles/repository_usecases</code>分支，查看与本文相关的代码:</p><div class="oh oi gp gr oj ok"><a href="https://github.com/SG-K/Clean-Architecture-Sample" rel="noopener  ugc nofollow" target="_blank"><div class="ol ab fo"><div class="om ab on cl cj oo"><h2 class="bd iu gy z fp op fr fs oq fu fw is bi translated">SG-K/Clean-架构-示例</h2><div class="or l"><h3 class="bd b gy z fp op fr fs oq fu fw dk translated">在GitHub上创建一个帐户，为SG-K/Clean-Architecture-Sample开发做贡献。</h3></div><div class="os l"><p class="bd b dl z fp op fr fs oq fu fw dk translated">github.com</p></div></div><div class="ot l"><div class="pk l ov ow ox ot oy ks ok"/></div></div></a></div><p id="7142" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">要了解有关高级Android开发和架构组件的更多信息，请阅读以下文章:</p><ul class=""><li id="9f4a" class="mz na it lb b lc ld lf lg li nb lm nc lq nd lu ne nf ng nh bi translated"><a class="ae ky" rel="noopener ugc nofollow" target="_blank" href="/best-practices-for-using-viewmodels-in-android-e986b25dc78f">“在Android中使用视图模型的最佳实践”</a></li><li id="e1cc" class="mz na it lb b lc ny lf nz li oa lm ob lq oc lu ne nf ng nh bi translated"><a class="ae ky" rel="noopener ugc nofollow" target="_blank" href="/no-more-livedata-in-repositories-in-kotlin-85f5a234a8fe">“科特林的存储库中不再有实时数据”</a></li><li id="f187" class="mz na it lb b lc ny lf nz li oa lm ob lq oc lu ne nf ng nh bi translated"><a class="ae ky" rel="noopener ugc nofollow" target="_blank" href="/advanced-android-programming-with-kotlin-5e40b1be22bb">《用Kotlin进行高级编程》</a></li><li id="af57" class="mz na it lb b lc ny lf nz li oa lm ob lq oc lu ne nf ng nh bi translated"><a class="ae ky" href="https://medium.com/android-dev-hacks/detailed-guide-on-android-clean-architecture-9eab262a9011" rel="noopener">《Android Clean架构详细指南》</a></li></ul><p id="8bcc" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">目前就这些。希望你学到了有用的东西。感谢阅读。</p></div></div>    
</body>
</html>