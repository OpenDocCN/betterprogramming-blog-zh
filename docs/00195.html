<html>
<head>
<title>Even the Smallest Side Project Deserves its CI/CD Pipeline</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">即使最小的次要项目也值得拥有CI/CD管道</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/even-the-smallest-side-project-deserves-its-ci-cd-pipeline-281f80f39fdf?source=collection_archive---------1-----------------------#2018-09-20">https://betterprogramming.pub/even-the-smallest-side-project-deserves-its-ci-cd-pipeline-281f80f39fdf?source=collection_archive---------1-----------------------#2018-09-20</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><figure class="gl gn jr js jt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi jq"><img src="../Images/3ea661945eb9ff4cf04e50fc5842aa73.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*qehZ1KLTEO6y8tcCwlwWzQ.png"/></div></div></figure><h1 id="9d15" class="kb kc it bd kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky bi translated"><strong class="ak">TL；博士</strong></h1><p id="20ef" class="pw-post-body-paragraph kz la it lb b lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw im bi translated">使用今天的工具，建立一个简单的CI/CD管道并不困难。即使是为了一个副业，这样做也是学习很多东西的好方法。Docker、GitLab和Portainer是用于这种设置的一些很好的组件。</p><h1 id="92b4" class="kb kc it bd kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky bi translated"><strong class="ak">样板工程</strong></h1><p id="2680" class="pw-post-body-paragraph kz la it lb b lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw im bi translated">作为Sophia-Antipolis地区(法国南部)技术活动的组织者，我经常被问到是否有办法了解所有即将到来的活动(聚会、壶、由当地协会组织的活动等)。)因为没有一个地方可以列出所有的事件，所以我想出了<a class="ae lx" href="https://sophia.events" rel="noopener ugc nofollow" target="_blank"> https://sophia.events </a>，一个简单的网页，试图保持这样的事件列表是最新的。这个项目在<a class="ae lx" href="https://gitlab.com/lucj/sophia.events" rel="noopener ugc nofollow" target="_blank"> GitLab </a>中可用</p><p id="ff2f" class="pw-post-body-paragraph kz la it lb b lc ly le lf lg lz li lj lk ma lm ln lo mb lq lr ls mc lu lv lw im bi translated">声明:这是一个简单的项目，但项目的复杂性在这里并不重要。我们将详述的CI/CD管道的组件可以以非常相似的方式用于更复杂的项目。不过，它们非常适合微服务。</p><h1 id="fdb8" class="kb kc it bd kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky bi translated"><strong class="ak">快速查看代码</strong></h1><p id="19be" class="pw-post-body-paragraph kz la it lb b lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw im bi translated">基本上，为了使事情非常简单，有一个events.json文件，其中添加了每个新事件。下面的代码片段中提供了该文件的一部分(抱歉是法语部分)。</p><figure class="md me mf mg gt ju"><div class="bz fp l di"><div class="mh mi l"/></div></figure><p id="8a60" class="pw-post-body-paragraph kz la it lb b lc ly le lf lg lz li lj lk ma lm ln lo mb lq lr ls mc lu lv lw im bi translated">小胡子<a class="ae lx" href="https://gitlab.com/lucj/sophia.events/blob/master/index.mustache" rel="noopener ugc nofollow" target="_blank">模板</a>被应用到这个文件来生成最终的web资产。</p><h1 id="d2c8" class="kb kc it bd kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky bi translated">Docker多阶段构建</h1><p id="26d3" class="pw-post-body-paragraph kz la it lb b lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw im bi translated">一旦生成了web资产，它们就被复制到nginx映像——部署在目标机器上的映像。</p><p id="a780" class="pw-post-body-paragraph kz la it lb b lc ly le lf lg lz li lj lk ma lm ln lo mb lq lr ls mc lu lv lw im bi translated">由于采用了多阶段构建，构建分两部分完成:</p><ul class=""><li id="1d14" class="mj mk it lb b lc ly lg lz lk ml lo mm ls mn lw mo mp mq mr bi translated">资产的生成</li><li id="f526" class="mj mk it lb b lc ms lg mt lk mu lo mv ls mw lw mo mp mq mr bi translated">创建包含资产的最终图像</li></ul><p id="7475" class="pw-post-body-paragraph kz la it lb b lc ly le lf lg lz li lj lk ma lm ln lo mb lq lr ls mc lu lv lw im bi translated">这是用于构建的docker文件:</p><pre class="md me mf mg gt mx my mz na aw nb bi"><span id="0b92" class="nc kc it my b gy nd ne l nf ng"># Generate the assets<br/>FROM node:8.12.0-alpine AS build<br/>COPY . /build<br/>WORKDIR /build<br/>RUN npm i<br/>RUN node clean.js<br/>RUN ./node_modules/mustache/bin/mustache events.json index.mustache &gt; index.html</span><span id="81cf" class="nc kc it my b gy nh ne l nf ng"># Build the final image used to serve them<br/>FROM nginx:1.14.0<br/>COPY --from=build /build/*.html /usr/share/nginx/html/<br/>COPY events.json /usr/share/nginx/html/<br/>COPY css /usr/share/nginx/html/css<br/>COPY js /usr/share/nginx/html/js<br/>COPY img /usr/share/nginx/html/img</span></pre><h1 id="aa62" class="kb kc it bd kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky bi translated">本地测试</h1><p id="88f6" class="pw-post-body-paragraph kz la it lb b lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw im bi translated">为了测试站点的生成，只需克隆repo并运行test.sh脚本。然后，它将创建一个图像，并从中运行一个容器。</p><pre class="md me mf mg gt mx my mz na aw nb bi"><span id="c116" class="nc kc it my b gy nd ne l nf ng">$ git clone <a class="ae lx" href="mailto:git@gitlab.com" rel="noopener ugc nofollow" target="_blank">git@gitlab.com</a>:lucj/sophia.events.git</span><span id="7a6b" class="nc kc it my b gy nh ne l nf ng">$ cd sophia.events</span><span id="2eb9" class="nc kc it my b gy nh ne l nf ng">$ ./test.sh<br/>Sending build context to Docker daemon  2.588MB<br/>Step 1/12 : FROM node:8.12.0-alpine AS build<br/> ---&gt; df48b68da02a<br/>Step 2/12 : COPY . /build<br/> ---&gt; f4005274aadf<br/>Step 3/12 : WORKDIR /build<br/> ---&gt; Running in 5222c3b6cf12<br/>Removing intermediate container 5222c3b6cf12<br/> ---&gt; 81947306e4af<br/>Step 4/12 : RUN npm i<br/> ---&gt; Running in de4e6182036b<br/>npm notice created a lockfile as package-lock.json. You should commit this file.<br/>npm WARN www@1.0.0 No repository field.</span><span id="1ed6" class="nc kc it my b gy nh ne l nf ng">added 2 packages from 3 contributors and audited 2 packages in 1.675s<br/>found 0 vulnerabilities</span><span id="01ba" class="nc kc it my b gy nh ne l nf ng">Removing intermediate container de4e6182036b<br/> ---&gt; d0eb4627e01f<br/>Step 5/12 : RUN node clean.js<br/> ---&gt; Running in f4d3c4745901<br/>Removing intermediate container f4d3c4745901<br/> ---&gt; 602987ce7162<br/>Step 6/12 : RUN ./node_modules/mustache/bin/mustache events.json index.mustache &gt; index.html<br/> ---&gt; Running in 05b5ebd73b89<br/>Removing intermediate container 05b5ebd73b89<br/> ---&gt; d982ff9cc61c<br/>Step 7/12 : FROM nginx:1.14.0<br/> ---&gt; 86898218889a<br/>Step 8/12 : COPY --from=build /build/*.html /usr/share/nginx/html/<br/> ---&gt; Using cache<br/> ---&gt; e0c25127223f<br/>Step 9/12 : COPY events.json /usr/share/nginx/html/<br/> ---&gt; Using cache<br/> ---&gt; 64e8a1c5e79d<br/>Step 10/12 : COPY css /usr/share/nginx/html/css<br/> ---&gt; Using cache<br/> ---&gt; e524c31b64c2<br/>Step 11/12 : COPY js /usr/share/nginx/html/js<br/> ---&gt; Using cache<br/> ---&gt; 1ef9dece9bb4<br/>Step 12/12 : COPY img /usr/share/nginx/html/img<br/> ---&gt; e50bf7836d2f<br/>Successfully built e50bf7836d2f<br/>Successfully tagged registry.gitlab.com/lucj/sophia.events:latest<br/>=&gt; web site available on <a class="ae lx" href="http://localhost:32768" rel="noopener ugc nofollow" target="_blank">http://localhost:32768</a></span></pre><p id="aa93" class="pw-post-body-paragraph kz la it lb b lc ly le lf lg lz li lj lk ma lm ln lo mb lq lr ls mc lu lv lw im bi translated">使用输出末尾提供的URL，我们可以访问该网页:</p><figure class="md me mf mg gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi ni"><img src="../Images/1a14229bf7ec6804e53ee51662177c7d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Y21lGvz9lCwXw6GAq_-1Bw.png"/></div></div></figure><h1 id="4202" class="kb kc it bd kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky bi translated"><strong class="ak">目标环境</strong></h1><h2 id="d130" class="nc kc it bd kd nj nk dn kh nl nm dp kl lk nn no kp lo np nq kt ls nr ns kx nt bi translated">在云提供商上调配的虚拟机</h2><p id="0b52" class="pw-post-body-paragraph kz la it lb b lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw im bi translated">您可能已经注意到，这个网站并不重要(每天只有几十次访问)，因此它只在一台虚拟机上运行。这是一个伟大的欧洲云提供商Exoscale上的Docker Machine创建的。</p><p id="a0bf" class="pw-post-body-paragraph kz la it lb b lc ly le lf lg lz li lj lk ma lm ln lo mb lq lr ls mc lu lv lw im bi translated">顺便说一句，如果你想试试Exoscale，ping me和我可以提供大约20张€代金券。</p><h2 id="e60d" class="nc kc it bd kd nj nk dn kh nl nm dp kl lk nn no kp lo np nq kt ls nr ns kx nt bi translated">群体模式下的Docker守护进程</h2><p id="61ed" class="pw-post-body-paragraph kz la it lb b lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw im bi translated">在上述虚拟机上运行的Docker守护进程被配置为在Swarm模式下运行，因此它允许使用Docker Swarm的堆栈、服务、配置和秘密原语以及强大(且易于使用)的编排功能。</p><h2 id="5487" class="nc kc it bd kd nj nk dn kh nl nm dp kl lk nn no kp lo np nq kt ls nr ns kx nt bi translated">应用程序作为Docker堆栈运行</h2><p id="bb9c" class="pw-post-body-paragraph kz la it lb b lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw im bi translated">以下文件定义了运行包含web资产的nginx web服务器的服务。</p><pre class="md me mf mg gt mx my mz na aw nb bi"><span id="e818" class="nc kc it my b gy nd ne l nf ng">version: "3.7"<br/>services:<br/>  www:<br/>    image: registry.gitlab.com/lucj/sophia.events<br/>    networks:<br/>      - proxy<br/>    deploy:<br/>      mode: replicated<br/>      replicas: 2<br/>      update_config:<br/>        parallelism: 1<br/>        delay: 10s<br/>      restart_policy:<br/>        condition: on-failure</span><span id="57fe" class="nc kc it my b gy nh ne l nf ng">networks:<br/>  proxy:<br/>    external: true</span></pre><p id="2c1c" class="pw-post-body-paragraph kz la it lb b lc ly le lf lg lz li lj lk ma lm ln lo mb lq lr ls mc lu lv lw im bi translated">一些解释:</p><ul class=""><li id="9d1f" class="mj mk it lb b lc ly lg lz lk ml lo mm ls mn lw mo mp mq mr bi translated">该图像位于gitlab.com托管的私人注册表中(这里不涉及Docker Hub)。</li><li id="1175" class="mj mk it lb b lc ms lg mt lk mu lo mv ls mw lw mo mp mq mr bi translated">服务处于复制模式，有两个副本，这意味着服务的两个任务/容器同时运行。通过Swarm将一个VIP(虚拟IP地址)与服务相关联，以便每个针对服务的请求在两个副本之间实现负载平衡。</li><li id="86b2" class="mj mk it lb b lc ms lg mt lk mu lo mv ls mw lw mo mp mq mr bi translated">每次完成服务更新(部署网站的新版本)时，都会更新一个副本，10秒钟后再更新第二个副本。这确保了网站在更新过程中仍然可用。我们也可以使用回滚策略，但此时不需要。</li><li id="68c5" class="mj mk it lb b lc ms lg mt lk mu lo mv ls mw lw mo mp mq mr bi translated">该服务连接到外部<em class="nu">代理</em>网络，因此TLS终端(运行在部署在swarm上的另一个服务中，但在该项目之外)可以向<em class="nu"> www </em>服务发送请求。</li></ul><p id="2e59" class="pw-post-body-paragraph kz la it lb b lc ly le lf lg lz li lj lk ma lm ln lo mb lq lr ls mc lu lv lw im bi translated">该堆栈使用以下命令运行:</p><pre class="md me mf mg gt mx my mz na aw nb bi"><span id="72ea" class="nc kc it my b gy nd ne l nf ng">$ docker stack deploy -c sophia.yml sophia_events</span></pre><h2 id="1105" class="nc kc it bd kd nj nk dn kh nl nm dp kl lk nn no kp lo np nq kt ls nr ns kx nt bi translated">Portainer来管理它们</h2><p id="ed77" class="pw-post-body-paragraph kz la it lb b lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw im bi translated"><a class="ae lx" href="https://portainer.io" rel="noopener ugc nofollow" target="_blank"> Portainer </a>是一个很棒的网络用户界面，可以让你非常容易地管理Docker主机和Docker Swarm集群。下面是Portainer界面的截图，列出了swarm中可用的堆栈。</p><figure class="md me mf mg gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi nv"><img src="../Images/784aa7d62b95431ae378b8d31b3d7c44.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Q28WiD0-_8zqDv_CtWdqRA.png"/></div></div></figure><p id="bc38" class="pw-post-body-paragraph kz la it lb b lc ly le lf lg lz li lj lk ma lm ln lo mb lq lr ls mc lu lv lw im bi translated">当前设置显示3个堆栈:</p><ul class=""><li id="0d83" class="mj mk it lb b lc ly lg lz lk ml lo mm ls mn lw mo mp mq mr bi translated">集装箱本身</li><li id="1709" class="mj mk it lb b lc ms lg mt lk mu lo mv ls mw lw mo mp mq mr bi translated">sophia_events包含运行我们网站的服务</li><li id="8b62" class="mj mk it lb b lc ms lg mt lk mu lo mv ls mw lw mo mp mq mr bi translated">tls，TLS终端</li></ul><p id="0b60" class="pw-post-body-paragraph kz la it lb b lc ly le lf lg lz li lj lk ma lm ln lo mb lq lr ls mc lu lv lw im bi translated">如果我们列出<em class="nu"> www </em>服务的详细信息，它在<em class="nu"> sophia_events </em>堆栈中，我们可以看到<strong class="lb iu">服务webhook </strong>被激活。这个特性从Portainer 1.19.2(到目前为止的最新版本)开始就可用了，它允许我们定义一个HTTP Post端点，可以调用这个端点来触发服务的更新。正如我们将在后面看到的，GitLab runner负责调用这个webhook。</p><figure class="md me mf mg gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi nv"><img src="../Images/f220086edcfff6b2f7f77d4323d90d7f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Cxk54DFLdcfZjvGTDvm56w.png"/></div></div></figure><p id="ae9c" class="pw-post-body-paragraph kz la it lb b lc ly le lf lg lz li lj lk ma lm ln lo mb lq lr ls mc lu lv lw im bi translated"><strong class="lb iu">注意</strong>:从截图可以看到，我从localhost:8888访问Portainer UI。因为我不想向外界公开Portainer实例，所以访问是通过ssh隧道完成的，该隧道是用以下命令打开的:</p><pre class="md me mf mg gt mx my mz na aw nb bi"><span id="9f44" class="nc kc it my b gy nd ne l nf ng">ssh -i ~/.docker/machine/machines/labs/id_rsa -NL 8888:localhost:9000 $USER@$HOST</span></pre><p id="3861" class="pw-post-body-paragraph kz la it lb b lc ly le lf lg lz li lj lk ma lm ln lo mb lq lr ls mc lu lv lw im bi translated">随后，所有以端口8888上的本地机器为目标的请求都通过ssh发送到虚拟机上的端口9000。9000是Portainer在虚拟机上运行的端口，但此端口不对外界开放，因为它被Exoscale配置中的安全组阻止。</p><p id="49d0" class="pw-post-body-paragraph kz la it lb b lc ly le lf lg lz li lj lk ma lm ln lo mb lq lr ls mc lu lv lw im bi translated"><strong class="lb iu">注意</strong>:在上面的命令中，用来连接虚拟机的ssh密钥是Docker Machine在创建虚拟机时生成的。</p><h2 id="c06c" class="nc kc it bd kd nj nk dn kh nl nm dp kl lk nn no kp lo np nq kt ls nr ns kx nt bi translated">GitLab runner</h2><p id="29a4" class="pw-post-body-paragraph kz la it lb b lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw im bi translated">GitLab runner是负责执行。gitlab-ci.yml文件。对于这个项目，我们将自己的runner定义为VM上的一个容器。</p><p id="2aea" class="pw-post-body-paragraph kz la it lb b lc ly le lf lg lz li lj lk ma lm ln lo mb lq lr ls mc lu lv lw im bi translated">第一步是注册跑步者，提供几个选项:</p><pre class="md me mf mg gt mx my mz na aw nb bi"><span id="86e6" class="nc kc it my b gy nd ne l nf ng">CONFIG_FOLDER=/tmp/gitlab-runner-config</span><span id="c1f5" class="nc kc it my b gy nh ne l nf ng">docker run — rm -t -i \<br/> -v $CONFIG_FOLDER:/etc/gitlab-runner \<br/> gitlab/gitlab-runner register \<br/>   --non-interactive \<br/>   --executor "docker" \<br/>   —-docker-image docker:stable \<br/>   --url "<a class="ae lx" href="https://gitlab.com/" rel="noopener ugc nofollow" target="_blank">https://gitlab.com/</a>" \<br/>   —-registration-token "$PROJECT_TOKEN" \<br/>   —-description "Exoscale Docker Runner" \<br/>   --tag-list "docker" \<br/>   --run-untagged \<br/>   —-locked="false" \<br/>   --docker-privileged</span></pre><p id="fbef" class="pw-post-body-paragraph kz la it lb b lc ly le lf lg lz li lj lk ma lm ln lo mb lq lr ls mc lu lv lw im bi translated">在这些选项中，PROJECT_TOKEN由GitLab.com的项目页面提供，用于注册外部跑步者:</p><figure class="md me mf mg gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi nw"><img src="../Images/47026b90e7cfc7f39a3f2c56e349a3bc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*fBHXnpbMKwM0yraHaj1-hw.png"/></div></div><p class="nx ny gj gh gi nz oa bd b be z dk translated">用于注册新跑步者的注册令牌</p></figure><p id="e909" class="pw-post-body-paragraph kz la it lb b lc ly le lf lg lz li lj lk ma lm ln lo mb lq lr ls mc lu lv lw im bi translated">当跑步者注册后，我们需要启动它:</p><pre class="md me mf mg gt mx my mz na aw nb bi"><span id="17db" class="nc kc it my b gy nd ne l nf ng">CONFIG_FOLDER=/tmp/gitlab-runner-config</span><span id="7bbd" class="nc kc it my b gy nh ne l nf ng">docker run -d \<br/> --name gitlab-runner \<br/> —-restart always \<br/> -v $CONFIG_FOLDER:/etc/gitlab-runner \<br/> -v /var/run/docker.sock:/var/run/docker.sock \<br/> gitlab/gitlab-runner:latest</span></pre><p id="675a" class="pw-post-body-paragraph kz la it lb b lc ly le lf lg lz li lj lk ma lm ln lo mb lq lr ls mc lu lv lw im bi translated">一旦注册并启动，跑步者就会列在GitLab.com上的项目页面中:</p><figure class="md me mf mg gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi ob"><img src="../Images/94dceb743c9adda762e430ab8d51d74e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*7evU79ZJ4VWH6QFdT_KCgA.png"/></div></div><p class="nx ny gj gh gi nz oa bd b be z dk translated">为此项目创建的跑步者</p></figure><p id="63aa" class="pw-post-body-paragraph kz la it lb b lc ly le lf lg lz li lj lk ma lm ln lo mb lq lr ls mc lu lv lw im bi translated">每当一个新的提交被推送到存储库时，这个运行者将接收一些工作要做。它依次执行在中定义的<em class="nu">测试</em>、<em class="nu">构建</em>和<em class="nu">部署</em>阶段。gitlab-ci.yml文件:</p><figure class="md me mf mg gt ju"><div class="bz fp l di"><div class="mh mi l"/></div></figure><ul class=""><li id="fa7d" class="mj mk it lb b lc ly lg lz lk ml lo mm ls mn lw mo mp mq mr bi translated">测试阶段运行一些预检查，确保events.json文件格式良好，并且没有丢失任何图像..</li><li id="5cfc" class="mj mk it lb b lc ms lg mt lk mu lo mv ls mw lw mo mp mq mr bi translated">构建阶段构建图像并将其推送到GitLab注册表。</li><li id="d307" class="mj mk it lb b lc ms lg mt lk mu lo mv ls mw lw mo mp mq mr bi translated">部署阶段通过发送到Portainer的webhook触发服务的更新。WWW_WEBHOOK变量是在GitLab.com项目页面的CI/CD设置中定义的。</li></ul><figure class="md me mf mg gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi oc"><img src="../Images/9bc1fb16f8b6100255c7c1036cb3f09b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*fpPmRJeAqtR6WWD_nc3xJQ.png"/></div></div></figure><p id="6f48" class="pw-post-body-paragraph kz la it lb b lc ly le lf lg lz li lj lk ma lm ln lo mb lq lr ls mc lu lv lw im bi translated"><strong class="lb iu">备注:</strong></p><p id="e454" class="pw-post-body-paragraph kz la it lb b lc ly le lf lg lz li lj lk ma lm ln lo mb lq lr ls mc lu lv lw im bi translated">这个跑步者在蜂群上的一个容器里跑步。我们可以使用一个共享的runner——公共可用的runner，它们在托管在itLab上的不同项目所需的作业之间共享时间——但是，由于runner需要访问Portainer端点(以发送webhook ),并且因为我不希望Portainer从外部被访问，所以将runner放在集群内部更安全。</p><p id="0189" class="pw-post-body-paragraph kz la it lb b lc ly le lf lg lz li lj lk ma lm ln lo mb lq lr ls mc lu lv lw im bi translated">此外，因为runner在容器中运行，所以它将webhook发送到Docker0桥网络的IP地址，以便通过它在主机上公开的端口9000联系Portainer。因此，webhook具有以下格式:<em class="nu">http://172 . 17 . 0 . 1:9000/API[…]a7-4a F2-a95b-b 748d 92 f1 B3 b</em></p><h1 id="79d5" class="kb kc it bd kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky bi translated"><strong class="ak">部署流程</strong></h1><p id="a227" class="pw-post-body-paragraph kz la it lb b lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw im bi translated">网站新版本的更新遵循如下所示的工作流程:</p><figure class="md me mf mg gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi jq"><img src="../Images/c5663306cb977b70ff4d63c5caf5d429.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*JrtraJp9Md7_HvPlEGiWWw.png"/></div></div></figure><ol class=""><li id="de39" class="mj mk it lb b lc ly lg lz lk ml lo mm ls mn lw od mp mq mr bi translated">一名开发人员对GitLab进行了一些修改。这些变化主要涉及events.json文件中的一个或几个新事件，以及一些额外的赞助商标志。</li></ol><p id="9898" class="pw-post-body-paragraph kz la it lb b lc ly le lf lg lz li lj lk ma lm ln lo mb lq lr ls mc lu lv lw im bi translated">2.GitLab runner执行中定义的操作。gitlab-ci.yml。</p><p id="ea2e" class="pw-post-body-paragraph kz la it lb b lc ly le lf lg lz li lj lk ma lm ln lo mb lq lr ls mc lu lv lw im bi translated">3.GitLab runner调用Portainer中定义的webhook。</p><p id="a8e0" class="pw-post-body-paragraph kz la it lb b lc ly le lf lg lz li lj lk ma lm ln lo mb lq lr ls mc lu lv lw im bi translated">4.收到webhook后，Portainer部署新版本的<em class="nu"> www </em>服务。它这样做，调用Docker Swarm API。Portainer可以访问API，因为socket /var/run/docker.sock是在启动时绑定安装的</p><p id="92fe" class="pw-post-body-paragraph kz la it lb b lc ly le lf lg lz li lj lk ma lm ln lo mb lq lr ls mc lu lv lw im bi translated">如果您想了解更多关于这个unix套接字的用法，您可能会对以前的文章感兴趣</p><div class="oe of gp gr og oh"><a href="https://medium.com/lucjuggery/about-var-run-docker-sock-3bfd276e12fd" rel="noopener follow" target="_blank"><div class="oi ab fo"><div class="oj ab ok cl cj ol"><h2 class="bd iu gy z fp om fr fs on fu fw is bi translated">关于/var/run/docker.sock</h2><div class="oo l"><h3 class="bd b gy z fp om fr fs on fu fw dk translated">TL；速度三角形定位法(dead reckoning)</h3></div><div class="op l"><p class="bd b dl z fp om fr fs on fu fw dk translated">medium.com</p></div></div><div class="oq l"><div class="or l os ot ou oq ov jz oh"/></div></div></a></div><p id="48cd" class="pw-post-body-paragraph kz la it lb b lc ly le lf lg lz li lj lk ma lm ln lo mb lq lr ls mc lu lv lw im bi translated">5.然后，用户可以看到网站的新版本</p><h2 id="43dc" class="nc kc it bd kd nj nk dn kh nl nm dp kl lk nn no kp lo np nq kt ls nr ns kx nt bi translated">例子</h2><p id="e9cf" class="pw-post-body-paragraph kz la it lb b lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw im bi translated">让我们更改代码中的一些内容，并提交/推送这些更改。</p><pre class="md me mf mg gt mx my mz na aw nb bi"><span id="e6ed" class="nc kc it my b gy nd ne l nf ng">$ git commit -m 'Fix image'<br/><br/>$ git push origin master</span></pre><p id="de44" class="pw-post-body-paragraph kz la it lb b lc ly le lf lg lz li lj lk ma lm ln lo mb lq lr ls mc lu lv lw im bi translated">下面的屏幕截图显示了由GitLab.com项目页面中的提交触发的管道</p><figure class="md me mf mg gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi ow"><img src="../Images/50ecc7e2cbd951e03c461afffdd67b86.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*JeVsifm36zx_ZfjXTqHzQQ.png"/></div></div></figure><p id="d5ad" class="pw-post-body-paragraph kz la it lb b lc ly le lf lg lz li lj lk ma lm ln lo mb lq lr ls mc lu lv lw im bi translated">在Portainer端，接收到了webhook并执行了服务更新。我们在这里看不清楚，但是一个副本已经被更新，使得可以通过第二个副本访问网站。然后，几秒钟后，第二个副本被更新。</p><figure class="md me mf mg gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi ox"><img src="../Images/de287a6932168e620098051148e8ea0c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*joNxer_6SRvyCLj8ACnmLA.png"/></div></div></figure><h2 id="6a38" class="nc kc it bd kd nj nk dn kh nl nm dp kl lk nn no kp lo np nq kt ls nr ns kx nt bi translated">摘要</h2><p id="76c9" class="pw-post-body-paragraph kz la it lb b lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw im bi translated">即使对于这个小项目，建立一个CI/CD管道也是一个很好的练习，特别是为了更熟悉GitLab(它已经在我的学习清单上很长时间了)。这是一款优秀的专业产品。这也是一个很好的机会来体验期待已久的Portainer最新版本(1.19.2)中的webhook特性。此外，对于像这样的副业项目，Docker Swarm的使用是显而易见的——它太酷了，而且易于使用！</p></div></div>    
</body>
</html>