<html>
<head>
<title>SwiftUI Microservices</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">SwiftUI微服务</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/swiftui-microservices-c7002228710?source=collection_archive---------1-----------------------#2019-11-12">https://betterprogramming.pub/swiftui-microservices-c7002228710?source=collection_archive---------1-----------------------#2019-11-12</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><figure class="is it gp gr iu iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi ir"><img src="../Images/1212e37d64c5aa0823b362ae11ec7d29.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ZaMhH9NbJBNRJ-kVZIHKUQ.jpeg"/></div></div></figure><div class=""/><div class=""><h2 id="bdfb" class="pw-subtitle-paragraph kb jd je bd b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks dk translated">SwiftUI中应用架构的现代方法</h2></div><p id="c7e4" class="pw-post-body-paragraph kt ku je kv b kw kx kf ky kz la ki lb lc ld le lf lg lh li lj lk ll lm ln lo im bi translated">SwiftUI为iOS、macOS和苹果所有其他设备上的应用程序开发带来了一种新的声明式、状态驱动、基于组件的方法。</p><p id="6d6d" class="pw-post-body-paragraph kt ku je kv b kw kx kf ky kz la ki lb lc ld le lf lg lh li lj lk ll lm ln lo im bi translated">因此，我们的应用程序架构方法也该向前发展了。</p><p id="04ff" class="pw-post-body-paragraph kt ku je kv b kw kx kf ky kz la ki lb lc ld le lf lg lh li lj lk ll lm ln lo im bi translated">但是在我们继续之前，让我们简要回顾一下历史和当前的技术水平。</p></div><div class="ab cl lp lq hx lr" role="separator"><span class="ls bw bk lt lu lv"/><span class="ls bw bk lt lu lv"/><span class="ls bw bk lt lu"/></div><div class="im in io ip iq"><h1 id="56c2" class="lw lx je bd ly lz ma mb mc md me mf mg kk mh kl mi kn mj ko mk kq ml kr mm mn bi translated">模型视图控制器</h1><p id="60a0" class="pw-post-body-paragraph kt ku je kv b kw mo kf ky kz mp ki lb lc mq le lf lg mr li lj lk ms lm ln lo im bi translated">iOS应用程序开发的经典方法依赖于MVC(模型视图控制器)。在MVC中，控制器在模型和代表我们界面的各种视图之间来回传递信息。</p><figure class="mu mv mw mx gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi mt"><img src="../Images/a4d32346856e5b07d2e39e81c2b3b8f5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*QA23oAHq1FUnZIhnjAMNWg.png"/></div></div></figure><p id="ce8a" class="pw-post-body-paragraph kt ku je kv b kw kx kf ky kz la ki lb lc ld le lf lg lh li lj lk ll lm ln lo im bi translated">在iOS中，控制器表现为一个单独的对象，UIViewController。视图控制器管理所有用户交互和状态更改，包括加载信息、操作和更新数据，它还处理用户在应用程序中各种屏幕和页面之间的导航。</p><p id="d5c0" class="pw-post-body-paragraph kt ku je kv b kw kx kf ky kz la ki lb lc ld le lf lg lh li lj lk ll lm ln lo im bi translated">这种方法意味着控制器在我们的应用程序架构中扮演了一个过大的角色。事实上，它的作用如此之大，以至于人们普遍称它为MVC(大规模视图控制器的简称)。</p><p id="622a" class="pw-post-body-paragraph kt ku je kv b kw kx kf ky kz la ki lb lc ld le lf lg lh li lj lk ll lm ln lo im bi translated">不用说，这种方法不是最理想的。</p></div><div class="ab cl lp lq hx lr" role="separator"><span class="ls bw bk lt lu lv"/><span class="ls bw bk lt lu lv"/><span class="ls bw bk lt lu"/></div><div class="im in io ip iq"><h1 id="42fe" class="lw lx je bd ly lz ma mb mc md me mf mg kk mh kl mi kn mj ko mk kq ml kr mm mn bi translated">模型-视图-视图模型</h1><p id="6c79" class="pw-post-body-paragraph kt ku je kv b kw mo kf ky kz mp ki lb lc mq le lf lg mr li lj lk ms lm ln lo im bi translated">已经提出了各种解决方案来对抗大规模视图控制器，但大多数归结为某种形式的模型-视图-视图模型(MVVM)。</p><p id="887d" class="pw-post-body-paragraph kt ku je kv b kw kx kf ky kz la ki lb lc ld le lf lg lh li lj lk ll lm ln lo im bi translated">就此而言，模型和视图仍然存在，视图控制器也是如此。但是应用程序的核心，数据操作和业务逻辑，已经从视图控制器中提取出来，并转移到视图模型中。</p><p id="5165" class="pw-post-body-paragraph kt ku je kv b kw kx kf ky kz la ki lb lc ld le lf lg lh li lj lk ll lm ln lo im bi translated">为什么？首先，它简化了视图控制器，但是从视图控制器中提取所有逻辑的主要目的是使逻辑可测试。我们可以实例化一个视图模型，向它提供信息，调用它的方法，并直接观察视图模型将呈现给视图控制器的状态变化。</p><figure class="mu mv mw mx gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi my"><img src="../Images/a8302757ffe384b849221416c4ac97f0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*XnXDtt4C7cBltVoVbgCmVA.png"/></div></div></figure><p id="bea1" class="pw-post-body-paragraph kt ku je kv b kw kx kf ky kz la ki lb lc ld le lf lg lh li lj lk ll lm ln lo im bi translated">由于视图控制器的工作已经简化为简单地将这些状态变化传递给组成我们应用程序的视图，我们可以相当有信心，如果视图模型的输出是正确的，我们的应用程序也将是正确的。</p><p id="991c" class="pw-post-body-paragraph kt ku je kv b kw kx kf ky kz la ki lb lc ld le lf lg lh li lj lk ll lm ln lo im bi translated">这个主题有多种变化:模型-视图-演示者(MVP)。毒蛇。干净。但是它们都基于相同的基本概念，主要区别在于它们如何在一组组件之间划分职责。</p><p id="b786" class="pw-post-body-paragraph kt ku je kv b kw kx kf ky kz la ki lb lc ld le lf lg lh li lj lk ll lm ln lo im bi translated">然而，所有人都同意一件事，那就是视图控制器应该尽可能的笨。</p></div><div class="ab cl lp lq hx lr" role="separator"><span class="ls bw bk lt lu lv"/><span class="ls bw bk lt lu lv"/><span class="ls bw bk lt lu"/></div><div class="im in io ip iq"><h1 id="0708" class="lw lx je bd ly lz ma mb mc md me mf mg kk mh kl mi kn mj ko mk kq ml kr mm mn bi translated">斯威夫特伊</h1><p id="2f1f" class="pw-post-body-paragraph kt ku je kv b kw mo kf ky kz mp ki lb lc mq le lf lg mr li lj lk ms lm ln lo im bi translated">苹果显然同意这一点，因为WWDC19出现了，苹果推出了SwiftUI，其中完全消除了大多数用户定义和管理视图控制器。</p><p id="bdea" class="pw-post-body-paragraph kt ku je kv b kw kx kf ky kz la ki lb lc ld le lf lg lh li lj lk ll lm ln lo im bi translated">在SwiftUI中，您使用简单的语法来声明您的用户界面。</p><p id="2a65" class="pw-post-body-paragraph kt ku je kv b kw kx kf ky kz la ki lb lc ld le lf lg lh li lj lk ll lm ln lo im bi translated">此外，在任何给定时间点，该界面完全由应用程序的状态驱动。更改应用程序状态，应用程序界面将立即更新以反映这些更改。</p><p id="3b8a" class="pw-post-body-paragraph kt ku je kv b kw kx kf ky kz la ki lb lc ld le lf lg lh li lj lk ll lm ln lo im bi translated">苹果将这一概念称为“真理的唯一来源”。</p><figure class="mu mv mw mx gt iv gh gi paragraph-image"><div class="gh gi mz"><img src="../Images/96b224d43c7d90a3752d0302e4d084bd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1302/format:webp/1*L_JvMKRn4FhJG76oakwl5g.png"/></div><p class="na nb gj gh gi nc nd bd b be z dk translated">WWDC19“通过SwiftUI的数据流”演示</p></figure><p id="a6ad" class="pw-post-body-paragraph kt ku je kv b kw kx kf ky kz la ki lb lc ld le lf lg lh li lj lk ll lm ln lo im bi translated">但是仅仅因为应用程序的任何给定部分都应该有一个真实的来源，并不意味着整个应用程序都应该有一个真实的来源。</p><p id="fc5e" class="pw-post-body-paragraph kt ku je kv b kw kx kf ky kz la ki lb lc ld le lf lg lh li lj lk ll lm ln lo im bi translated">迷茫？让我解释一下。</p></div><div class="ab cl lp lq hx lr" role="separator"><span class="ls bw bk lt lu lv"/><span class="ls bw bk lt lu lv"/><span class="ls bw bk lt lu"/></div><div class="im in io ip iq"><h1 id="3f0f" class="lw lx je bd ly lz ma mb mc md me mf mg kk mh kl mi kn mj ko mk kq ml kr mm mn bi translated">作文</h1><p id="fed2" class="pw-post-body-paragraph kt ku je kv b kw mo kf ky kz mp ki lb lc mq le lf lg mr li lj lk ms lm ln lo im bi translated">正如我在我的文章“<a class="ae ne" href="https://medium.com/swlh/structural-decomposition-in-swiftui-8892e512b18e" rel="noopener">swift ui</a>中的视图合成”中所写的，苹果鼓励你将视图分解成小的、紧密的、不同的组件，其中每个视图控制用户界面的特定部分。</p><p id="6533" class="pw-post-body-paragraph kt ku je kv b kw kx kf ky kz la ki lb lc ld le lf lg lh li lj lk ll lm ln lo im bi translated">让我们再来看看那篇文章中的一个组件，一个收藏夹按钮，用于指示给定的项目应该被记住并显示在应用程序的收藏夹列表中。</p><figure class="mu mv mw mx gt iv gh gi paragraph-image"><div class="gh gi nf"><img src="../Images/14016541a55f3718b17ff9324d51aad6.png" data-original-src="https://miro.medium.com/v2/resize:fit:806/format:webp/1*O6jnIkq89PPgQFljGUGQTQ.png"/></div></figure><p id="30ad" class="pw-post-body-paragraph kt ku je kv b kw kx kf ky kz la ki lb lc ld le lf lg lh li lj lk ll lm ln lo im bi translated">收藏夹按钮背后的代码如下:</p><pre class="mu mv mw mx gt ng nh ni nj aw nk bi"><span id="b36b" class="nl lx je nh b gy nm nn l no np">struct FavoritesButton: View {</span><span id="acd3" class="nl lx je nh b gy nq nn l no np">    let item: MenuItem</span><span id="d9b6" class="nl lx je nh b gy nq nn l no np">    @EnvironmentObject var favorites: FavoritesService</span><span id="f7b3" class="nl lx je nh b gy nq nn l no np">    var imageName: String {<br/>        favorites.isFavorite(item) ? "star.fill" : "star"<br/>    }</span><span id="74cf" class="nl lx je nh b gy nq nn l no np">    var body: some View {<br/>        Image(systemName: imageName)<br/>            .foregroundColor(.accentColor)<br/>            .scaleEffect(1.2)<br/>            .onTapGesture {<br/>                self.favorites.toggleFavorite(self.item)<br/>            }<br/>    }<br/>}</span></pre><p id="ed6c" class="pw-post-body-paragraph kt ku je kv b kw kx kf ky kz la ki lb lc ld le lf lg lh li lj lk ll lm ln lo im bi translated">favorites按钮界面和行为是完全独立的，可以在整个应用程序的任何视图中的任何地方使用。如截图所示，我们甚至可以将其拖放到导航栏中。</p><pre class="mu mv mw mx gt ng nh ni nj aw nk bi"><span id="9f6a" class="nl lx je nh b gy nm nn l no np">struct DetailView: View {<br/>    let item: MenuItem<br/>    var body: some View {<br/>        ScrollView(.vertical) {<br/>            VStack {<br/>                ...<br/>            }<br/>        }<br/>        .navigationBarTitle("Details", displayMode: .inline)<br/>        .navigationBarItems(trailing: FavoritesButton(item: item))<br/>    }<br/>}</span></pre><p id="f5ca" class="pw-post-body-paragraph kt ku je kv b kw kx kf ky kz la ki lb lc ld le lf lg lh li lj lk ll lm ln lo im bi translated">轻按导航栏中的“个人收藏”按钮，当前项目将被标记为个人收藏。或者被移除。无论如何，<code class="fe nr ns nt nh b">DetailView</code>不知道按钮的内部细节或实现。</p><h2 id="0e03" class="nl lx je bd ly nu nv dn mc nw nx dp mg lc ny nz mi lg oa ob mk lk oc od mm oe bi translated"><em class="of">最喜欢的服务</em></h2><p id="a70a" class="pw-post-body-paragraph kt ku je kv b kw mo kf ky kz mp ki lb lc mq le lf lg mr li lj lk ms lm ln lo im bi translated">虽然favorites按钮界面背后的代码是独立的，但是在内部，视图的基本功能依赖于<code class="fe nr ns nt nh b">FavoritesService</code>，这是一个环境对象，它已经被定义并插入到链上更高位置的视图层次结构中。</p><p id="e48c" class="pw-post-body-paragraph kt ku je kv b kw kx kf ky kz la ki lb lc ld le lf lg lh li lj lk ll lm ln lo im bi translated"><code class="fe nr ns nt nh b">FavoritesService</code>是一个SwiftUI ObservableObject，它向我们的视图公开了一个发布的值和两个方法。一个是<code class="fe nr ns nt nh b">isFavorite(item)</code> <em class="og"> </em>方法，用于确定该项是否已经是收藏，另一个是<code class="fe nr ns nt nh b">toggleFavorite(item)</code>，用于相应地切换该项的状态。</p><p id="75fb" class="pw-post-body-paragraph kt ku je kv b kw kx kf ky kz la ki lb lc ld le lf lg lh li lj lk ll lm ln lo im bi translated">请注意，当从这里或从应用程序中的任何地方调用<code class="fe nr ns nt nh b">toggleFavorite(item)</code>时，我们的收藏夹项目列表会更新，因此，任何依赖于<code class="fe nr ns nt nh b">FavoritesService</code>的视图都会被要求相应地更新其视图显示。</p><pre class="mu mv mw mx gt ng nh ni nj aw nk bi"><span id="9e8f" class="nl lx je nh b gy nm nn l no np">class FavoritesService: ObservableObject {</span><span id="3f07" class="nl lx je nh b gy nq nn l no np">    @Published var items: [MenuItem] = []</span><span id="44fb" class="nl lx je nh b gy nq nn l no np">    func isFavorite(_ menuItem: MenuItem) -&gt; Bool {<br/>        items.firstIndex(where: { $0.id == menuItem.id }) != nil<br/>    }</span><span id="fb1c" class="nl lx je nh b gy nq nn l no np">    func toggleFavorite(_ menuItem: MenuItem) {<br/>        if let index = items.firstIndex(where: { $0.id == menuItem.id }) {<br/>            items.remove(at: index)<br/>        } else {<br/>            items.append(menuItem)<br/>        }<br/>    }</span><span id="4f34" class="nl lx je nh b gy nq nn l no np">}</span></pre><p id="8993" class="pw-post-body-paragraph kt ku je kv b kw kx kf ky kz la ki lb lc ld le lf lg lh li lj lk ll lm ln lo im bi translated"><code class="fe nr ns nt nh b">FavoritesService</code>是这一特定观点的唯一真理来源。这也可能是其他观点的真实来源，但是<code class="fe nr ns nt nh b">FavoritesButton</code>并不关心这个。</p><p id="9a6d" class="pw-post-body-paragraph kt ku je kv b kw kx kf ky kz la ki lb lc ld le lf lg lh li lj lk ll lm ln lo im bi translated"><code class="fe nr ns nt nh b">FavoritesService</code>还坚持单一责任原则。它的目的是管理一个喜欢的菜单项列表，仅此而已。</p><h2 id="ea2d" class="nl lx je bd ly nu nv dn mc nw nx dp mg lc ny nz mi lg oa ob mk lk oc od mm oe bi translated">应用程序选项卡</h2><p id="cfbf" class="pw-post-body-paragraph kt ku je kv b kw mo kf ky kz mp ki lb lc mq le lf lg mr li lj lk ms lm ln lo im bi translated">让我们看看另一个服务，尽管是一个非常简约的服务。</p><pre class="mu mv mw mx gt ng nh ni nj aw nk bi"><span id="a247" class="nl lx je nh b gy nm nn l no np">enum AppTabs: Int {<br/>    case favorites<br/>    case menu<br/>    case order<br/>}</span><span id="8c01" class="nl lx je nh b gy nq nn l no np">class AppState: ObservableObject {<br/>    @Published var currentTab = AppTabs.favorites<br/>}</span></pre><p id="5645" class="pw-post-body-paragraph kt ku je kv b kw kx kf ky kz la ki lb lc ld le lf lg lh li lj lk ll lm ln lo im bi translated">在这里，我们跟踪应用程序的当前标签状态，这样我们可以根据需要有计划地移动到特定的标签。</p><pre class="mu mv mw mx gt ng nh ni nj aw nk bi"><span id="9807" class="nl lx je nh b gy nm nn l no np">struct AppTabView: View {<br/>    @EnvironmentObject var appState: AppState<br/>    var body: some View {<br/>        TabView(selection: $appState.currentTab) {<br/>            FavoritesView()<br/>                .tabItem {<br/>                    Image(systemName: "star")<br/>                    Text("Favorites")<br/>                    }<br/>                .tag(AppTabs.favorites)<br/>            ...<br/>            }<br/>    }<br/>}</span></pre><h2 id="dd5b" class="nl lx je bd ly nu nv dn mc nw nx dp mg lc ny nz mi lg oa ob mk lk oc od mm oe bi translated">订单服务</h2><p id="2668" class="pw-post-body-paragraph kt ku je kv b kw mo kf ky kz mp ki lb lc mq le lf lg mr li lj lk ms lm ln lo im bi translated">还有一个。这里有一个来自同一个应用程序<em class="og">、</em>的<code class="fe nr ns nt nh b">OrderService</code>、<em class="og">、</em>用于跟踪订购的商品。</p><pre class="mu mv mw mx gt ng nh ni nj aw nk bi"><span id="4b73" class="nl lx je nh b gy nm nn l no np">class OrderService: ObservableObject {</span><span id="afc4" class="nl lx je nh b gy nq nn l no np">    @Published var items = [MenuItem]()</span><span id="4dff" class="nl lx je nh b gy nq nn l no np">    var total: Int {<br/>        items.reduce(0) { $0 + $1.price }<br/>    }</span><span id="d3b4" class="nl lx je nh b gy nq nn l no np">    func isInCart(_ menuItem: MenuItem) -&gt; Bool {<br/>        items.firstIndex(where: { $0.id == menuItem.id }) != nil<br/>    }</span><span id="b89a" class="nl lx je nh b gy nq nn l no np">    func add(item: MenuItem) {<br/>        items.append(item)<br/>    }</span><span id="fb97" class="nl lx je nh b gy nq nn l no np">    func remove(item: MenuItem) {<br/>        if let index = items.firstIndex(of: item) {<br/>            items.remove(at: index)<br/>        }<br/>    }<br/>}</span></pre><h2 id="2fde" class="nl lx je bd ly nu nv dn mc nw nx dp mg lc ny nz mi lg oa ob mk lk oc od mm oe bi translated">Redux</h2><p id="2012" class="pw-post-body-paragraph kt ku je kv b kw mo kf ky kz mp ki lb lc mq le lf lg mr li lj lk ms lm ln lo im bi translated">由于应用程序的每个组件都应该有一个真实的来源，<a class="ae ne" href="https://medium.com/swlh/clean-architecture-for-swiftui-6d6c4eb1cf6a" rel="noopener">有些人建议</a>swift ui转移到Redux风格的状态模型，整个应用程序有一个真实的来源。</p><pre class="mu mv mw mx gt ng nh ni nj aw nk bi"><span id="ecf7" class="nl lx je nh b gy nm nn l no np">class AppState: ObservableObject {<br/>    @Published var currentTab = AppTabs.favorites<br/>    @Published var menuItems: [MenuItem] = []<br/>    @Published var favoriteItems: [MenuItem] = []<br/>    @Published var orderItems: [MenuItem] = []<br/>}</span></pre><p id="e61c" class="pw-post-body-paragraph kt ku je kv b kw kx kf ky kz la ki lb lc ld le lf lg lh li lj lk ll lm ln lo im bi translated">或者，如果您想在组件行之间保持功能性，也许可以尝试这样做:</p><pre class="mu mv mw mx gt ng nh ni nj aw nk bi"><span id="0b80" class="nl lx je nh b gy nm nn l no np">class AppState: ObservableObject {<br/>    @Published var currentTab = AppTabs.favorites<br/>    @Published var menu = MenuService()<br/>    @Published var favorites = FavoritesService()<br/>    @Published var order = OrderService()<br/>}</span></pre><p id="916e" class="pw-post-body-paragraph kt ku je kv b kw kx kf ky kz la ki lb lc ld le lf lg lh li lj lk ll lm ln lo im bi translated">将全局<code class="fe nr ns nt nh b">AppState</code>导入到每个需要数据的视图中，就大功告成了。</p><h2 id="d199" class="nl lx je bd ly nu nv dn mc nw nx dp mg lc ny nz mi lg oa ob mk lk oc od mm oe bi translated">单一全球国家的利弊</h2><p id="9020" class="pw-post-body-paragraph kt ku je kv b kw mo kf ky kz mp ki lb lc mq le lf lg mr li lj lk ms lm ln lo im bi translated">做单个<code class="fe nr ns nt nh b">AppState</code>的好处主要在于简单。如上所述，您只需要处理一个<code class="fe nr ns nt nh b">environmentObject</code>进口。</p><p id="04f7" class="pw-post-body-paragraph kt ku je kv b kw kx kf ky kz la ki lb lc ld le lf lg lh li lj lk ll lm ln lo im bi translated">但是对我来说，缺点很多。</p><p id="a617" class="pw-post-body-paragraph kt ku je kv b kw kx kf ky kz la ki lb lc ld le lf lg lh li lj lk ll lm ln lo im bi translated">首先，它们与性能有关。对应用程序状态进行一次更改——比方说，将一个项目标记为收藏夹——现在需要遍历应用程序中的每一个视图树并检查更改。为什么？因为每个视图所依赖的单个环境对象已经发出了发生更新的信号。</p><p id="5264" class="pw-post-body-paragraph kt ku je kv b kw kx kf ky kz la ki lb lc ld le lf lg lh li lj lk ll lm ln lo im bi translated">对于较小的应用程序，这种影响可以忽略不计。但是对于更大的呢？</p><p id="78e7" class="pw-post-body-paragraph kt ku je kv b kw kx kf ky kz la ki lb lc ld le lf lg lh li lj lk ll lm ln lo im bi translated">(应该注意，对于大型React/Redux web应用程序，这也是一个已知的问题。)</p><h2 id="b4f4" class="nl lx je bd ly nu nv dn mc nw nx dp mg lc ny nz mi lg oa ob mk lk oc od mm oe bi translated">全局数据</h2><p id="f041" class="pw-post-body-paragraph kt ku je kv b kw mo kf ky kz mp ki lb lc mq le lf lg mr li lj lk ms lm ln lo im bi translated">我的第二大反对意见与应用程序数据的全球公开有关。</p><p id="733e" class="pw-post-body-paragraph kt ku je kv b kw kx kf ky kz la ki lb lc ld le lf lg lh li lj lk ll lm ln lo im bi translated">导入<code class="fe nr ns nt nh b">AppState</code>到单一视图，所有东西都暴露出来让大家看。既然如此，在不遍历视图中的每一行代码的情况下，您如何确定给定的视图可能正在访问或操作什么信息呢？</p><p id="8d24" class="pw-post-body-paragraph kt ku je kv b kw kx kf ky kz la ki lb lc ld le lf lg lh li lj lk ll lm ln lo im bi translated">我们上面的<code class="fe nr ns nt nh b">FavoritesButton</code>就是不这么做的一个很好的例子。通过查看代码的开头，我可以知道这段代码唯一能看到或更改的是<code class="fe nr ns nt nh b">FavoritesService</code>，因为这是从应用程序环境导入的唯一对象。</p><p id="b812" class="pw-post-body-paragraph kt ku je kv b kw kx kf ky kz la ki lb lc ld le lf lg lh li lj lk ll lm ln lo im bi translated">此外，如果我想在另一个应用程序中使用<code class="fe nr ns nt nh b">FavoritesButton</code> <em class="og"> </em>，很容易就能看出我还需要什么来移动到另一个应用程序。</p><h2 id="f2be" class="nl lx je bd ly nu nv dn mc nw nx dp mg lc ny nz mi lg oa ob mk lk oc od mm oe bi translated">测试</h2><p id="65cb" class="pw-post-body-paragraph kt ku je kv b kw mo kf ky kz mp ki lb lc mq le lf lg mr li lj lk ms lm ln lo im bi translated">我的第三个反对意见与测试有关。我们将代码分解成视图模型和服务的主要动机之一在于使代码更容易测试。</p><p id="75b3" class="pw-post-body-paragraph kt ku je kv b kw kx kf ky kz la ki lb lc ld le lf lg lh li lj lk ll lm ln lo im bi translated">在SwiftUI中，我们的应用程序完全由它的状态控制。因此，如果我们将该状态放入模型或服务中，并且如果该状态由于用户触发的动作而改变，那么在测试中，我们可以触发那些动作并观察状态的结果变化。</p><p id="536a" class="pw-post-body-paragraph kt ku je kv b kw kx kf ky kz la ki lb lc ld le lf lg lh li lj lk ll lm ln lo im bi translated">如果对于每一个可能的变化或动作，状态都正确地更新了，那么我们就有相当高的信心相信我们的应用程序是正确的。</p><p id="153e" class="pw-post-body-paragraph kt ku je kv b kw kx kf ky kz la ki lb lc ld le lf lg lh li lj lk ll lm ln lo im bi translated">但是将我们所有的状态放在一个容器中，使得孤立地测试我们单独的模型或服务变得非常非常困难。它对于集成测试来说相当不错，但是对于单元测试来说就不那么好了。</p><p id="1e41" class="pw-post-body-paragraph kt ku je kv b kw kx kf ky kz la ki lb lc ld le lf lg lh li lj lk ll lm ln lo im bi translated">即使这样，全球国家也很有可能产生未经检验的、因此无法预见的副作用。"哦，我没意识到它也在改变<em class="og">那个</em>变量！"</p><h2 id="ce73" class="nl lx je bd ly nu nv dn mc nw nx dp mg lc ny nz mi lg oa ob mk lk oc od mm oe bi translated">后期绑定</h2><p id="428f" class="pw-post-body-paragraph kt ku je kv b kw mo kf ky kz mp ki lb lc mq le lf lg mr li lj lk ms lm ln lo im bi translated">正如在view-composition文章中指出的，SwiftUI的另一个最佳实践是在尽可能低的层次中绑定状态。</p><figure class="mu mv mw mx gt iv gh gi paragraph-image"><div class="gh gi oh"><img src="../Images/9021253b1b79bda217c7cf6c7474e1b9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1268/format:webp/1*vT1ADLUuPMtocwJJTfXqFQ.png"/></div><p class="na nb gj gh gi nc nd bd b be z dk translated">WWDC19“通过SwiftUI的数据流”演示</p></figure><p id="55d2" class="pw-post-body-paragraph kt ku je kv b kw kx kf ky kz la ki lb lc ld le lf lg lh li lj lk ll lm ln lo im bi translated">当我们在层次结构的底层绑定时，我们极大地减少了所需的界面更新和重新渲染的数量，因为视图树中只有一小部分会受到任何给定更新的影响，并且需要重新生成。</p><p id="c610" class="pw-post-body-paragraph kt ku je kv b kw kx kf ky kz la ki lb lc ld le lf lg lh li lj lk ll lm ln lo im bi translated">所有这些都极大地提高了应用程序的性能。</p><p id="5d90" class="pw-post-body-paragraph kt ku je kv b kw kx kf ky kz la ki lb lc ld le lf lg lh li lj lk ll lm ln lo im bi translated">上面，收藏夹服务直接绑定到需要它的对象。想要显示收藏夹按钮的<code class="fe nr ns nt nh b">DetailView</code>既不知道也不关心它。当然，更高层次的人必须提供它，但这是其他人要处理的不同责任。</p><h2 id="9c13" class="nl lx je bd ly nu nv dn mc nw nx dp mg lc ny nz mi lg oa ob mk lk oc od mm oe bi translated">为什么是服务而不是视图模型？</h2><p id="237c" class="pw-post-body-paragraph kt ku je kv b kw mo kf ky kz mp ki lb lc mq le lf lg mr li lj lk ms lm ln lo im bi translated">有人可能会问，为什么我们称它们为<em class="og">服务</em>，而不仅仅是<em class="og">视图模型</em>。</p><p id="044e" class="pw-post-body-paragraph kt ku je kv b kw kx kf ky kz la ki lb lc ld le lf lg lh li lj lk ll lm ln lo im bi translated">在这种情况下，关键的区别因素是视图模型通常被编写为驱动单个屏幕、页面或视图，并且该视图拥有视图模型。</p><p id="900b" class="pw-post-body-paragraph kt ku je kv b kw kx kf ky kz la ki lb lc ld le lf lg lh li lj lk ll lm ln lo im bi translated">另一方面，服务是在SwiftUI应用程序中的多个视图和组件之间创建和共享的，方法是将它们注入到视图层次结构的某个级别的应用程序环境中，供较低级别的元素使用。只要这一水平持续存在，它们就会持续存在。</p><p id="776a" class="pw-post-body-paragraph kt ku je kv b kw kx kf ky kz la ki lb lc ld le lf lg lh li lj lk ll lm ln lo im bi translated">事实上，当我们的初始内容视图在我们的<code class="fe nr ns nt nh b">SceneDelegate</code>中创建时，许多服务倾向于被创建并注入到视图层次结构的最顶层。</p><pre class="mu mv mw mx gt ng nh ni nj aw nk bi"><span id="3f43" class="nl lx je nh b gy nm nn l no np">func scene(_ scene: UIScene, willConnectTo session: UISceneSession, options connectionOptions: UIScene.ConnectionOptions) {</span><span id="85fc" class="nl lx je nh b gy nq nn l no np">    // Create the SwiftUI view that provides the window contents.<br/>    let contentView = AppTabView()<br/>        .environmentObject(AppState())<br/>        .environmentObject(MenuService())<br/>        .environmentObject(MessageService())<br/>        .environmentObject(FavoritesService())<br/>        .environmentObject(OrderService())<br/>        .environmentObject(RatingsService())</span><span id="a0e5" class="nl lx je nh b gy nq nn l no np">    // Use a UIHostingController as window root view controller.<br/>    if let windowScene = scene as? UIWindowScene {<br/>        let window = UIWindow(windowScene: windowScene)<br/>        window.rootViewController = UIHostingController(rootView: contentView)<br/>        self.window = window<br/>        window.makeKeyAndVisible()<br/>    }<br/>}</span></pre><p id="a296" class="pw-post-body-paragraph kt ku je kv b kw kx kf ky kz la ki lb lc ld le lf lg lh li lj lk ll lm ln lo im bi translated">尽管更好的解决方案可能是使用系统服务修饰符，如“<a class="ae ne" href="https://medium.com/swlh/swiftui-and-the-missing-environment-object-1a4bf8913ba7" rel="noopener"> SwiftUI和缺失的环境对象</a>”中所述</p><pre class="mu mv mw mx gt ng nh ni nj aw nk bi"><span id="0bdc" class="nl lx je nh b gy nm nn l no np">    let contentView = AppTabView()<br/>        .modifier(SystemServices())</span></pre><p id="e67d" class="pw-post-body-paragraph kt ku je kv b kw kx kf ky kz la ki lb lc ld le lf lg lh li lj lk ll lm ln lo im bi translated">服务修饰符如下:</p><pre class="mu mv mw mx gt ng nh ni nj aw nk bi"><span id="fa48" class="nl lx je nh b gy nm nn l no np">struct SystemServices: ViewModifier {</span><span id="9e87" class="nl lx je nh b gy nq nn l no np">    private static var appState: AppState = AppState()<br/>    private static var menu = MenuService()<br/>    private static var messages = MessageService()<br/>    private static var favorites = FavoritesService()<br/>    private static var ratings = RatingsService()<br/>    private static var order = OrderService()</span><span id="3234" class="nl lx je nh b gy nq nn l no np">    func body(content: Content) -&gt; some View {<br/>        content<br/>            // defaults<br/>            .accentColor(.red)<br/>            // messages<br/>            .overlay(MessageOverlayView(), alignment: .top)<br/>            // services<br/>            .environmentObject(Self.appState)<br/>            .environmentObject(Self.menu)<br/>            .environmentObject(Self.messages)<br/>            .environmentObject(Self.favorites)<br/>            .environmentObject(Self.order)<br/>            .environmentObject(Self.ratings)<br/>    }</span><span id="9b17" class="nl lx je nh b gy nq nn l no np">}</span></pre><p id="979b" class="pw-post-body-paragraph kt ku je kv b kw kx kf ky kz la ki lb lc ld le lf lg lh li lj lk ll lm ln lo im bi translated">注意，我们的<code class="fe nr ns nt nh b">SystemServices</code>修饰符的存在只是为了在需要时将我们的服务注入SwiftUI环境中(比如当我们呈现一个新的模态视图或动作表时)。这就是为什么它的成员是私有的。</p><h2 id="f5c4" class="nl lx je bd ly nu nv dn mc nw nx dp mg lc ny nz mi lg oa ob mk lk oc od mm oe bi translated">SwiftUI中的微服务</h2><p id="5dc9" class="pw-post-body-paragraph kt ku je kv b kw mo kf ky kz mp ki lb lc mq le lf lg mr li lj lk ms lm ln lo im bi translated">微服务架构被定义为将一个应用程序安排到一个松散耦合的服务集合中。这些服务是细粒度的，它们之间的协议是轻量级的。</p><p id="51f5" class="pw-post-body-paragraph kt ku je kv b kw kx kf ky kz la ki lb lc ld le lf lg lh li lj lk ll lm ln lo im bi translated">在微服务架构中，服务是可独立部署的。在上面的<code class="fe nr ns nt nh b">FavoritesService</code>案例中，我们已经看到，我们可以在另一个应用程序中轻松地重新部署该服务和那些接口组件。</p><p id="eaaa" class="pw-post-body-paragraph kt ku je kv b kw kx kf ky kz la ki lb lc ld le lf lg lh li lj lk ll lm ln lo im bi translated">最后，将它们称为<em class="og">微服务</em>进一步强调了我们的服务应该是小型的、定义良好的，并且每一个服务的实现都紧紧围绕管理我们应用程序的一个方面。</p><p id="443b" class="pw-post-body-paragraph kt ku je kv b kw kx kf ky kz la ki lb lc ld le lf lg lh li lj lk ll lm ln lo im bi translated">真相的唯一来源。</p><h2 id="84c4" class="nl lx je bd ly nu nv dn mc nw nx dp mg lc ny nz mi lg oa ob mk lk oc od mm oe bi translated">完成块</h2><p id="fc6d" class="pw-post-body-paragraph kt ku je kv b kw mo kf ky kz mp ki lb lc mq le lf lg mr li lj lk ms lm ln lo im bi translated">如果SwiftUI背后的一个主要目标是从良好组合的、独立的、可重用的视图中构建我们的应用程序，那么我们不应该考虑以同样的方式实现我们的内部服务架构吗？</p><p id="5442" class="pw-post-body-paragraph kt ku je kv b kw kx kf ky kz la ki lb lc ld le lf lg lh li lj lk ll lm ln lo im bi translated">这是我的看法，但是如果你有不同的看法，我想听听。</p><p id="957a" class="pw-post-body-paragraph kt ku je kv b kw kx kf ky kz la ki lb lc ld le lf lg lh li lj lk ll lm ln lo im bi translated"><strong class="kv jf">注意:</strong>我的idin应用程序源代码版本可以从我在GitHub 上的<a class="ae ne" href="https://github.com/hmlongco/iDine" rel="noopener ugc nofollow" target="_blank">idin库获得。它包括本文中提到的例子。</a></p></div><div class="ab cl lp lq hx lr" role="separator"><span class="ls bw bk lt lu lv"/><span class="ls bw bk lt lu lv"/><span class="ls bw bk lt lu"/></div><div class="im in io ip iq"><p id="ceff" class="pw-post-body-paragraph kt ku je kv b kw kx kf ky kz la ki lb lc ld le lf lg lh li lj lk ll lm ln lo im bi translated"><em class="og">如果你喜欢这篇文章，那就试试我最新的:</em><a class="ae ne" href="https://medium.com/@michaellong/deep-inside-views-state-and-performance-in-swiftui-d23a3a44b79" rel="noopener"><em class="og">swift ui</em></a><em class="og">中的深度观点、状态和表现。或者为什么这些词几乎没有一个是你所认为的意思… </em></p></div></div>    
</body>
</html>