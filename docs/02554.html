<html>
<head>
<title>Creating a History With Property Wrappers in Swift 5.1</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">在Swift 5.1中使用属性包装器创建历史</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/creating-a-history-with-property-wrappers-in-swift-5-1-4c0202060a7f?source=collection_archive---------10-----------------------#2019-12-08">https://betterprogramming.pub/creating-a-history-with-property-wrappers-in-swift-5-1-4c0202060a7f?source=collection_archive---------10-----------------------#2019-12-08</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="b1bb" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">使用属性包装器使调试更容易</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/7bb015c30b52e9c230aedf3f0350f3e2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*StafF2K6hqmnjfzcZWHlaQ.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">包装属性，就像他们是这只狗——图片来自<a class="ae ky" href="https://pixabay.com/photos/pug-dog-pet-animal-puppy-cute-801826/" rel="noopener ugc nofollow" target="_blank"> pixabay </a>的<a class="ae ky" href="https://pixabay.com/users/free-photos-242387/" rel="noopener ugc nofollow" target="_blank">免费照片</a></p></figure><p id="d4ff" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">有时，大型代码库会变得非常复杂，很难跟踪特定值在哪里以及如何变化。尤其是当新的开发人员来到一个现有的项目时，很难了解正在发生的事情。</p><p id="f3f7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">也许你有一个由属性的特定值引起的错误，但是你看不到应用程序是如何到达这一步的。如果能有一份该房产所有价值的历史记录，看看以前发生过什么，岂不是很棒？但是，创建这样的历史将意味着您需要更改代码的许多部分，以便在设置新值时保存它。</p><p id="1084" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在本文中，我们将探讨如何使用Swift的新物业包装器，通过对我们希望拥有历史记录的物业进行注释来轻松添加该功能。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h2 id="4f29" class="mc md it bd me mf mg dn mh mi mj dp mk li ml mm mn lm mo mp mq lq mr ms mt mu bi translated">什么是属性包装器？</h2><p id="572a" class="pw-post-body-paragraph kz la it lb b lc mv ju le lf mw jx lh li mx lk ll lm my lo lp lq mz ls lt lu im bi translated">属性包装是包装属性的结构，因此名称。这些结构提供对其封装属性的读写访问，并且可以在获取或设置值时执行代码。不要担心——当我们看一个例子时，这将变得更加清晰。</p><p id="d6b1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">一个简单的用例是在用户默认值或Keychain中存储一个更新的值。或者，您可以确保新值在有效范围内，或者进行其他转换或验证。通过使用属性包装器，您可以减少样板代码的数量，因为您只需要编写一次逻辑，并且通过简单地注释您的属性就可以在任何地方使用它。</p><p id="9551" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们看一个读取和写入UserDefaults的小示例属性包装:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="na nb l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">实现将值存储到UserDefaults的属性包装。</p></figure><p id="f4c5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe nc nd ne nf b">//1</code> —我们创建了一个名为<code class="fe nc nd ne nf b">UserDefaultsContained</code>的新结构，并在其中添加了<code class="fe nc nd ne nf b">@propertyWrapper</code>。这个结构有一个泛型参数<code class="fe nc nd ne nf b">Value</code>，它将是包装属性的类型。</p><p id="64af" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe nc nd ne nf b">//2</code> —每个属性包装器需要一个计算属性<code class="fe nc nd ne nf b">wrappedValue</code>。这就是奇迹发生的地方。这里，我们指定在获取和设置包装值时应该发生什么。在本例中，我们将只读取和写入标准用户默认值。</p><p id="db0b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe nc nd ne nf b">//3</code> —此外，这个结构有一个<code class="fe nc nd ne nf b">key</code>用于访问UserDefauls中的包装值，还有一个<code class="fe nc nd ne nf b">defaultValue</code>，在找不到值时用作后备。这两个值是在初始化器中设置的。</p><p id="087d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">该属性包装可以这样使用:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="na nb l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">使用属性包装@UserDefaultsContained。</p></figure><p id="9857" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe nc nd ne nf b">//1</code> —首先，我们通过在普通属性声明前添加属性包装器注释来创建一个新的<code class="fe nc nd ne nf b">UserDefaultsContained</code>属性。在这种情况下，我们只是使用一个简单的布尔标志来存储用户是否已经完成了教程。如前所述，我们需要将两个值<code class="fe nc nd ne nf b">key</code>和<code class="fe nc nd ne nf b">defaultValue</code>传递给初始化器。</p><p id="1db2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe nc nd ne nf b">//2</code> —现在我们可以像使用任何其他布尔值一样使用该属性，它将自动存储在UserDefaults中。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h2 id="329d" class="mc md it bd me mf mg dn mh mi mj dp mk li ml mm mn lm mo mp mq lq mr ms mt mu bi translated">使用属性包装跟踪更改</h2><p id="e017" class="pw-post-body-paragraph kz la it lb b lc mv ju le lf mw jx lh li mx lk ll lm my lo lp lq mz ls lt lu im bi translated">现在我们已经看到了如何创建和使用属性包装器，让我们看看是否可以使用它们来解决我们在开始时讨论的问题。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="na nb l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">实现创建属性历史记录的属性包装。</p></figure><p id="7319" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe nc nd ne nf b">//1</code>—就像之前一样，我们从创建一个新的结构开始。这一次我们称之为<code class="fe nc nd ne nf b">Traceable</code>，因为我们将能够跟踪包装值的历史。</p><p id="1ea5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe nc nd ne nf b">//2</code>—这一次我们需要保留名为<code class="fe nc nd ne nf b">value</code>的私有属性中的封装值，该值将在访问包装的属性时返回。在前面使用UserDefaults的例子中，我们不需要这样做，因为它总是可以通过从UserDefaults中读取来访问。为了改进历史信息，我们还将存储定义属性的文件的名称。</p><p id="b480" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe nc nd ne nf b">//3</code>—<code class="fe nc nd ne nf b">value</code>和<code class="fe nc nd ne nf b">file</code>都将在初始化器中设置。您可能会注意到，我们首先存储值，然后调用计算属性的setter<code class="fe nc nd ne nf b">wrappedValue</code>。起初这似乎是不必要的，但是通过更新<code class="fe nc nd ne nf b">wrappedValue</code>，我们用第一个元素触发了历史的创建。</p><p id="6070" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe nc nd ne nf b">//4</code> —这里我们定义一个结构<code class="fe nc nd ne nf b">HistoryEntry</code>来封装历史的一个条目的信息。每个条目都包含值、属性所在的文件名以及值更改的时间。</p><p id="b2d5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe nc nd ne nf b">//5</code> —最后，我们得到计算的属性<code class="fe nc nd ne nf b">wrappedValue</code>。getter非常简单:我们只需返回值。在setter中，我们将值更新为<code class="fe nc nd ne nf b">newValue</code>，创建一个新条目，并将其添加到现有的历史记录中。</p><p id="e2a8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们使用这个属性包装器！</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="na nb l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">使用属性wrapper @Tracable。</p></figure><p id="b1fd" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe nc nd ne nf b">//1</code> —假设我们想要为一个整数值创建一个历史记录。我们只需要在财产申报前面加上<code class="fe nc nd ne nf b">@Tracable(file: #file)</code>就可以了。</p><p id="e90a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe nc nd ne nf b">//2</code> —我们仍然可以像使用任何普通整数一样使用该属性。</p><p id="55b4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe nc nd ne nf b">//3</code> —但是当我们需要更多信息时，我们可以调用<code class="fe nc nd ne nf b">_<em class="ng">&lt;property_name&gt;</em>.history</code>并访问该属性的所有值。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="eea6" class="nh md it bd me ni nj nk mh nl nm nn mk jz no ka mn kc np kd mq kf nq kg mt nr bi translated">结论</h1><p id="388e" class="pw-post-body-paragraph kz la it lb b lc mv ju le lf mw jx lh li mx lk ll lm my lo lp lq mz ls lt lu im bi translated">属性包装器是向属性添加额外功能的好方法。它们允许我们在一个地方定义它们发生了什么，从而帮助我们减少代码。</p><p id="cbfd" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">正如我们所见，它们可以用于各种情况，从持久化到操纵值，最后通过提供值的历史来帮助我们调试代码。</p></div></div>    
</body>
</html>