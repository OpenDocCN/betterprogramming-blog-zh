<html>
<head>
<title>Property Wrappers: Three Real-Case Scenarios</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">属性包装器:三个真实场景</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/property-wrappers-three-real-case-scenarios-bd3e60a7c1ae?source=collection_archive---------4-----------------------#2020-01-18">https://betterprogramming.pub/property-wrappers-three-real-case-scenarios-bd3e60a7c1ae?source=collection_archive---------4-----------------------#2020-01-18</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="d9c4" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">验证、解码和依赖注入</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/4bbd0f6a73804e434b74b3f44693407e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*jY23LEmnGkdsTcZkw1sR_g.jpeg"/></div></div></figure></div><div class="ab cl ku kv hx kw" role="separator"><span class="kx bw bk ky kz la"/><span class="kx bw bk ky kz la"/><span class="kx bw bk ky kz"/></div><div class="im in io ip iq"><h1 id="0d54" class="lb lc it bd ld le lf lg lh li lj lk ll jz lm ka ln kc lo kd lp kf lq kg lr ls bi translated">介绍</h1><p id="924e" class="pw-post-body-paragraph lt lu it lv b lw lx ju ly lz ma jx mb mc md me mf mg mh mi mj mk ml mm mn mo im bi translated">属性包装器并不是一个新概念。其他语言如Java、<a class="ae mp" href="https://kotlinlang.org/" rel="noopener ugc nofollow" target="_blank"> Kotlin </a>和JavaScript已经使用这种常见模式有一段时间了。</p><p id="63ff" class="pw-post-body-paragraph lt lu it lv b lw mq ju ly lz mr jx mb mc ms me mf mg mt mi mj mk mu mm mn mo im bi translated">这些带有@前缀的属性有着不同的名称(注释、装饰等等)和不同的作用域，已经成为许多开发人员日常工作的一部分。</p><p id="b3ff" class="pw-post-body-paragraph lt lu it lv b lw mq ju ly lz mr jx mb mc ms me mf mg mt mi mj mk mu mm mn mo im bi translated">Swift是一种非常强大的函数式编程语言，有如此多的工具可用，而且相对较新。许多人想知道为什么Swift不支持注释，特别是考虑到苹果已经在使用注释:<code class="fe mv mw mx my b">@objc</code>、<code class="fe mv mw mx my b">@IBOutlet</code>和<code class="fe mv mw mx my b">@discardableResult</code>就是一些例子。</p><p id="2e36" class="pw-post-body-paragraph lt lu it lv b lw mq ju ly lz mr jx mb mc ms me mf mg mt mi mj mk mu mm mn mo im bi translated">虽然只是支持实例属性，但自从在Swift 5.1中引入属性包装器以来，苹果已经为美国开发者打开了无数的可能性。</p><p id="ea27" class="pw-post-body-paragraph lt lu it lv b lw mq ju ly lz mr jx mb mc ms me mf mg mt mi mj mk mu mm mn mo im bi translated">例如，通过用这些属性包装字段，我们能够很容易地从我们的类/结构中删除大量样板文件。</p><p id="ce84" class="pw-post-body-paragraph lt lu it lv b lw mq ju ly lz mr jx mb mc ms me mf mg mt mi mj mk mu mm mn mo im bi translated">在本教程中，我们将展示三个属性包装器派上用场的真实场景:</p><ul class=""><li id="74c4" class="mz na it lv b lw mq lz mr mc nb mg nc mk nd mo ne nf ng nh bi translated">属性验证。</li><li id="c67a" class="mz na it lv b lw ni lz nj mc nk mg nl mk nm mo ne nf ng nh bi translated">解码JSON结构。</li><li id="2ae3" class="mz na it lv b lw ni lz nj mc nk mg nl mk nm mo ne nf ng nh bi translated">依赖注入。</li></ul></div><div class="ab cl ku kv hx kw" role="separator"><span class="kx bw bk ky kz la"/><span class="kx bw bk ky kz la"/><span class="kx bw bk ky kz"/></div><div class="im in io ip iq"><h1 id="c84f" class="lb lc it bd ld le lf lg lh li lj lk ll jz lm ka ln kc lo kd lp kf lq kg lr ls bi translated">属性验证</h1><p id="f173" class="pw-post-body-paragraph lt lu it lv b lw lx ju ly lz ma jx mb mc md me mf mg mh mi mj mk ml mm mn mo im bi translated">我想我们在模拟银行卡。大多数cvv都是三位数长。在属性包装器出现之前，我们将这个属性建模为一个字符串，并在需要使用它的时候检查它的长度:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nn no l"/></div></figure><p id="4d6f" class="pw-post-body-paragraph lt lu it lv b lw mq ju ly lz mr jx mb mc ms me mf mg mt mi mj mk mu mm mn mo im bi translated">在Swift 5.1中，我们可以定义一个<code class="fe mv mw mx my b">CVV</code>属性包装器，并在包装器内完成所有这些验证:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nn no l"/></div></figure><p id="14ee" class="pw-post-body-paragraph lt lu it lv b lw mq ju ly lz mr jx mb mc ms me mf mg mt mi mj mk mu mm mn mo im bi translated">这样，我们现在可以使用<code class="fe mv mw mx my b">CVV</code>来包装我们的属性:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nn no l"/></div></figure></div><div class="ab cl ku kv hx kw" role="separator"><span class="kx bw bk ky kz la"/><span class="kx bw bk ky kz la"/><span class="kx bw bk ky kz"/></div><div class="im in io ip iq"><h1 id="a6d7" class="lb lc it bd ld le lf lg lh li lj lk ll jz lm ka ln kc lo kd lp kf lq kg lr ls bi translated">解码JSON结构</h1><p id="27a1" class="pw-post-body-paragraph lt lu it lv b lw lx ju ly lz ma jx mb mc md me mf mg mh mi mj mk ml mm mn mo im bi translated">如果您曾经使用过PHP内置的API，您会注意到，有时，两个不同的端点返回相同的模型，但格式不同，也就是说，模型属性根据端点的不同而具有不同的类型。这是由于后端的JSON编码。</p><p id="b3e7" class="pw-post-body-paragraph lt lu it lv b lw mq ju ly lz mr jx mb mc ms me mf mg mt mi mj mk mu mm mn mo im bi translated">虽然这并不理想，应该得到解决，但是我们总是可以手动实现<code class="fe mv mw mx my b">Decodable</code>协议，并尝试解码JSON密钥，例如，作为一个<code class="fe mv mw mx my b">Integer</code>，如果失败，作为一个<code class="fe mv mw mx my b">String</code>:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nn no l"/></div></figure><p id="fec1" class="pw-post-body-paragraph lt lu it lv b lw mq ju ly lz mr jx mb mc ms me mf mg mt mi mj mk mu mm mn mo im bi translated">正如你所看到的，这并不是世界上最好的任务，如果结构体封装了大量的信息，它会变得非常混乱。</p><p id="f83b" class="pw-post-body-paragraph lt lu it lv b lw mq ju ly lz mr jx mb mc ms me mf mg mt mi mj mk mu mm mn mo im bi translated">此外，如果这个问题发生一次，它很可能会发生在另一个端点的另一个模型上。我们不得不再次遵循同样的策略…</p><p id="2ee9" class="pw-post-body-paragraph lt lu it lv b lw mq ju ly lz mr jx mb mc ms me mf mg mt mi mj mk mu mm mn mo im bi translated">拯救财产包装者！我们可以定义一个属性包装器来处理这种情况。这样，我们可以让编译器替我们完成工作，自己处理<code class="fe mv mw mx my b">Decodable</code>:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nn no l"/></div></figure><p id="a3ff" class="pw-post-body-paragraph lt lu it lv b lw mq ju ly lz mr jx mb mc ms me mf mg mt mi mj mk mu mm mn mo im bi translated">使用<code class="fe mv mw mx my b">Converted</code>，很容易将前面的例子改写为:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nn no l"/></div></figure></div><div class="ab cl ku kv hx kw" role="separator"><span class="kx bw bk ky kz la"/><span class="kx bw bk ky kz la"/><span class="kx bw bk ky kz"/></div><div class="im in io ip iq"><h1 id="1bd9" class="lb lc it bd ld le lf lg lh li lj lk ll jz lm ka ln kc lo kd lp kf lq kg lr ls bi translated">依赖注入</h1><p id="c328" class="pw-post-body-paragraph lt lu it lv b lw lx ju ly lz ma jx mb mc md me mf mg mh mi mj mk ml mm mn mo im bi translated">我们可以使用属性包装器的另一个应用是将依赖关系注入到我们的对象中。想法和SwiftUI <em class="np">里的<code class="fe mv mw mx my b">EnvironmentObject</code>挺像的。</em></p><p id="e50b" class="pw-post-body-paragraph lt lu it lv b lw mq ju ly lz mr jx mb mc ms me mf mg mt mi mj mk mu mm mn mo im bi translated">假设我们有以下模型:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nn no l"/></div></figure><p id="cb0d" class="pw-post-body-paragraph lt lu it lv b lw mq ju ly lz mr jx mb mc ms me mf mg mt mi mj mk mu mm mn mo im bi translated">如您所见，<code class="fe mv mw mx my b">C</code>有<code class="fe mv mw mx my b">A</code>和<code class="fe mv mw mx my b">B</code>作为依赖项。我们可以将依赖关系存储在容器中，并使用属性包装器根据类型或名称注入这些依赖关系:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nn no l"/></div></figure><p id="e6aa" class="pw-post-body-paragraph lt lu it lv b lw mq ju ly lz mr jx mb mc ms me mf mg mt mi mj mk mu mm mn mo im bi translated">下面是你如何使用它:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nn no l"/></div></figure></div><div class="ab cl ku kv hx kw" role="separator"><span class="kx bw bk ky kz la"/><span class="kx bw bk ky kz la"/><span class="kx bw bk ky kz"/></div><div class="im in io ip iq"><h1 id="3660" class="lb lc it bd ld le lf lg lh li lj lk ll jz lm ka ln kc lo kd lp kf lq kg lr ls bi translated">结论</h1><p id="0a4a" class="pw-post-body-paragraph lt lu it lv b lw lx ju ly lz ma jx mb mc md me mf mg mh mi mj mk ml mm mn mo im bi translated">虽然这不是一个新概念，但是属性包装器是一颗未经雕琢的钻石。他们可以帮助我们:</p><ul class=""><li id="90f5" class="mz na it lv b lw mq lz mr mc nb mg nc mk nd mo ne nf ng nh bi translated">从我们的文件中删除样板文件。</li><li id="5b9a" class="mz na it lv b lw ni lz nj mc nk mg nl mk nm mo ne nf ng nh bi translated">重用代码。</li><li id="1678" class="mz na it lv b lw ni lz nj mc nk mg nl mk nm mo ne nf ng nh bi translated">保持我们的代码更干净。</li><li id="0bda" class="mz na it lv b lw ni lz nj mc nk mg nl mk nm mo ne nf ng nh bi translated">用新功能装饰房产。</li></ul></div></div>    
</body>
</html>