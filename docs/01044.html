<html>
<head>
<title>Cross-Platform Apps With Electron and React: Part 3</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">带有Electron和React的跨平台应用程序:第3部分</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/cross-platform-apps-with-electron-and-react-part-3-3992e358029f?source=collection_archive---------8-----------------------#2019-08-09">https://betterprogramming.pub/cross-platform-apps-with-electron-and-react-part-3-3992e358029f?source=collection_archive---------8-----------------------#2019-08-09</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="26a5" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">现在让我们重建菜单</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi ki"><img src="../Images/df053fd9a13b3c4497fb1200c0af1f3d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*8qE3KxLHlfU0aa07-KzF-g.png"/></div></figure><p id="8713" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">在<a class="ae lm" href="https://medium.com/better-programming/cross-platform-apps-with-electron-and-react-part-2-3307ae61014a" rel="noopener">第二部</a>中，我们给了我们的电子app一个适合各个操作系统的外观。根据平台的不同，我们为每个平台使用了额外的样式表，以确保应用程序能够很好地适应。</p><p id="4024" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">在这一部分，我们现在将重建<code class="fe ln lo lp lq b">gtk3-demo-application</code>的菜单。为此，我们将首先构建应用程序的app菜单。我们在启动应用程序时定义了这一点。第二步，我们将创建一个在应用程序运行时组成的上下文菜单。</p><p id="5dc2" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">最后，我们会对Mac OS做一些优化。Mac上的应用菜单与Windows和Linux下的菜单有着本质的不同。</p></div><div class="ab cl lr ls hx lt" role="separator"><span class="lu bw bk lv lw lx"/><span class="lu bw bk lv lw lx"/><span class="lu bw bk lv lw"/></div><div class="im in io ip iq"><h1 id="4d68" class="ly lz it bd ma mb mc md me mf mg mh mi jz mj ka mk kc ml kd mm kf mn kg mo mp bi translated">应用程序菜单</h1><p id="7b03" class="pw-post-body-paragraph kq kr it ks b kt mq ju kv kw mr jx ky kz ms lb lc ld mt lf lg lh mu lj lk ll im bi translated">app菜单在文件<code class="fe ln lo lp lq b">src/index</code>中创建。它在应用程序启动时加载。作为菜单的模板，我们使用JavaScript数组，其中包含JavaScript对象。JavaScript对象对应于一个菜单项。</p><p id="1099" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">菜单模板具有以下结构:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mv mw l"/></div></figure><p id="5c98" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">每个菜单项又可以包含自己的子菜单。生成的树提供了应用程序菜单。</p><p id="13e4" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">使用方法<code class="fe ln lo lp lq b">buildFromTemplate</code>，我们创建菜单对象。</p><p id="c60d" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">此外，我们给<code class="fe ln lo lp lq b">src/index.js</code>添加了一个函数<code class="fe ln lo lp lq b">showMessage</code>，作为一个虚拟回调函数。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mv mw l"/></div></figure><p id="91ac" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">之后，菜单应该是可见的。不再显示开发菜单。对于一个较大的项目，拥有一个在开发模式下显示并在生产时关闭的开发菜单可能是有用的。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi mx"><img src="../Images/9a3192d9a5f4f8af4d89a8fb37a9794b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1264/format:webp/1*DFpdxQqnUtuXqya8jAE6gg.png"/></div></figure></div><div class="ab cl lr ls hx lt" role="separator"><span class="lu bw bk lv lw lx"/><span class="lu bw bk lv lw lx"/><span class="lu bw bk lv lw"/></div><div class="im in io ip iq"><h1 id="4620" class="ly lz it bd ma mb mc md me mf mg mh mi jz mj ka mk kc ml kd mm kf mn kg mo mp bi translated">上下文菜单</h1><p id="6754" class="pw-post-body-paragraph kq kr it ks b kt mq ju kv kw mr jx ky kz ms lb lc ld mt lf lg lh mu lj lk ll im bi translated">演示应用程序也有一个文本编辑的上下文菜单。为了复制这一点，我们进行了一点不同。我们不再从模板中创建它，而是在运行时组合它。</p><p id="5c2d" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">因此，我们不再在<code class="fe ln lo lp lq b">src/index.js</code>中添加代码，而是在<code class="fe ln lo lp lq b">src/app.jsx</code>中添加。</p><p id="6c47" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">首先，我们在应用程序组件的构造函数中定义菜单。因为<a class="ae lm" href="https://electronjs.org/docs/api/menu" rel="noopener ugc nofollow" target="_blank">菜单类</a>只在主进程中可用，我们需要通过远程对象来访问它。</p><p id="c7b1" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">菜单本身比保留的app菜单简单多了。我们只是在上下文菜单中添加了一些标准函数和一个分隔符。我们广泛使用角色选项。这允许我们使用来自电子的<a class="ae lm" href="https://electronjs.org/docs/api/menu-item" rel="noopener ugc nofollow" target="_blank">预定义标准菜单。</a></p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mv mw l"/></div></figure><p id="ca78" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">为了访问上下文菜单，我们为文本区域定义了一个<code class="fe ln lo lp lq b">onContextMenu</code>处理程序。除了简单地打开上下文菜单并连接到主窗口之外，它什么也不做。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mv mw l"/></div></figure><p id="d69f" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">现在，您可以右键单击文本区域来打开上下文菜单。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi my"><img src="../Images/b96bc860f65e1dfd6fb21050ea608805.png" data-original-src="https://miro.medium.com/v2/resize:fit:1262/format:webp/1*nCeSr20XyS6JcqMKxPVA9A.png"/></div></figure></div><div class="ab cl lr ls hx lt" role="separator"><span class="lu bw bk lv lw lx"/><span class="lu bw bk lv lw lx"/><span class="lu bw bk lv lw"/></div><div class="im in io ip iq"><h1 id="e153" class="ly lz it bd ma mb mc md me mf mg mh mi jz mj ka mk kc ml kd mm kf mn kg mo mp bi translated">Mac菜单</h1><p id="135a" class="pw-post-body-paragraph kq kr it ks b kt mq ju kv kw mr jx ky kz ms lb lc ld mt lf lg lh mu lj lk ll im bi translated">Mac OS上的应用程序菜单与Windows和Linux下的应用程序菜单有很大不同。</p><p id="2f23" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">在Mac OS中，每个应用程序都应该提供3个标准菜单:</p><ul class=""><li id="5d28" class="mz na it ks b kt ku kw kx kz nb ld nc lh nd ll ne nf ng nh bi translated"><code class="fe ln lo lp lq b">window</code></li><li id="26e9" class="mz na it ks b kt ni kw nj kz nk ld nl lh nm ll ne nf ng nh bi translated"><code class="fe ln lo lp lq b">help</code></li><li id="97d3" class="mz na it ks b kt ni kw nj kz nk ld nl lh nm ll ne nf ng nh bi translated"><code class="fe ln lo lp lq b">services</code></li></ul><p id="81bc" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">为此，Electron在Mac OS上提供了一组标准菜单。这些有助于菜单的结构。</p><p id="c216" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">首先，在<code class="fe ln lo lp lq b">src/index.js</code>中，我们将应用程序菜单的模板保存在它自己的变量中。</p><p id="54f3" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">然后，我们调整帮助菜单的角色。</p><p id="1ffb" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">接下来，如果我们在Mac上，我们将在应用程序菜单中添加另外两个子菜单。我们使用标准的JavaScript方法来扩展模板数组。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mv mw l"/></div></figure><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi nn"><img src="../Images/30bfaef106fd99e8124dc89c3f97fb26.png" data-original-src="https://miro.medium.com/v2/resize:fit:1090/format:webp/1*zlo5HBV_fv_uRbINeOkDug.png"/></div></figure><p id="bfcb" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">现在，当我们在Mac上启动示例应用程序时，该菜单将出现在Mac OS的全局菜单中。</p></div><div class="ab cl lr ls hx lt" role="separator"><span class="lu bw bk lv lw lx"/><span class="lu bw bk lv lw lx"/><span class="lu bw bk lv lw"/></div><div class="im in io ip iq"><h1 id="8706" class="ly lz it bd ma mb mc md me mf mg mh mi jz mj ka mk kc ml kd mm kf mn kg mo mp bi translated">结论</h1><p id="babe" class="pw-post-body-paragraph kq kr it ks b kt mq ju kv kw mr jx ky kz ms lb lc ld mt lf lg lh mu lj lk ll im bi translated">你可以在GitHub上找到这个教程的源代码:【https://github.com/rockiger/electron-react-example<a class="ae lm" href="https://github.com/rockiger/electron-react-example" rel="noopener ugc nofollow" target="_blank"/></p><p id="7b1c" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">在最后一部分，我们将处理电子伪造的包装。</p></div></div>    
</body>
</html>