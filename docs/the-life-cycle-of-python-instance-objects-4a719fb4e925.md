# Python 实例对象的生命周期

> 原文：<https://betterprogramming.pub/the-life-cycle-of-python-instance-objects-4a719fb4e925>

## 探索实例如何在幕后工作

![](img/97ebd47d9ae80c2a25303341d57917bd.png)

[Jerry Zhang](https://unsplash.com/@z734923105?utm_source=medium&utm_medium=referral) 在 [Unsplash](https://unsplash.com?utm_source=medium&utm_medium=referral) 上拍照

当我们的项目范围扩大时，使用内置类型(如列表和字典)管理相关数据会变得非常繁琐。在这种情况下，我们定义自己的自定义类。当您学习实现定制类时，您可能会遇到与创建定制类实例相关的各种术语。这些术语中的一些对初学者来说听起来很混乱。因此，本文的第一部分将阐明这些术语，而第二部分将通过一些具体的代码示例回顾 Python 对象的一些关键事件。

# 第一部分.关键术语

## **实例和实例化**

实例也称为实例对象，它是保存数据的类的实际对象。例如，假设我们有一个名为 *Person* 的类。您可以将该类的一个实例想象成您生活中的一个实际的人，它可以有属性，如姓名和身高，也可以有功能，如行走和说话。

创建实例的过程称为实例化。基本上，你实例化一个特定类的实例对象。实际上，实例化涉及到为您正在创建的对象分配内存。有时，实例化也称为实例的构造。

## **初始化**和构造函数

在大多数情况下，作为实例化的一部分，您的类实例需要设置一些初始属性。设置实例初始状态的过程称为初始化。您可能知道，`__init__`方法的名称实际上代表初始化。

构造函数是用于创建自定义类的方法。假设自定义类 *Person* 将`__init__`方法定义为如下签名:`__init__(self, name)`，本质上等同于构造函数方法`Person(name)`。换句话说，你可以把构造函数想象成一个被类调用的特殊方法，默认情况下，它的执行是通过调用`__init__`方法来实现的。

## **变量和对象**

你可能会感到惊讶，我们甚至需要讨论什么是变量和对象。有些人可能会认为它们是一个意思，但事实并非如此。在 Python 中，对象是存储在内存中的实际数据项，而变量是引用底层对象的标签。换句话说，我们——程序员——处理变量，而 Python——解释器——根据我们与变量的交互来为我们处理幕后的对象。

## 命名空间和范围

当 Python 试图解释你的代码时，一个关键的任务是理解你引用的变量和函数。为了完成这项工作，Python 使用名称空间来跟踪它可以搜索的变量和函数。具体来说，您可以将名称空间视为存储所有可用变量的字典，它们是工具箱中的工具。

范围是一个与名称空间密切相关的概念。作用域定义了 Python 可以解析变量的边界(解析意味着 Python 知道应该使用什么变量)。如上所述，名称空间跟踪您的工具箱中的工具，而作用域是不同的工具箱——有些较大，有些较小(函数的局部作用域)并嵌入在较大的作用域中(例如，模块的全局作用域)。

## **引用计数**和**垃圾收集**

与前面的概念相关，每个变量都包含一个对底层对象的引用。Python 跟踪底层对象需要多少引用来决定它是否需要在内存中保持对象活动。这是一个非常重要的机制，可以防止计算机内存不足。

在正常的用例中，我们不需要管理 Python 对象的内存分配和释放，因为 Python 使用引用计数来释放内存空间。但是，有时引用计数不起作用(例如，引用周期)。换句话说，存储器中存在垃圾(例如，实际上不需要但具有非零引用的对象)。在这种情况下，Python 将尝试使用垃圾收集机制来释放这些对象使用的内存。

## **去初始化**

从内存中删除特定对象的过程称为反初始化。当对象的引用计数达到零或整个程序的执行完成时，就会发生这种情况。有些人也把这个过程称为毁灭。

# 第二部分。典型的生命周期

## 实例化

实例的生命始于它的诞生——实例化。在大多数情况下，我们使用构造函数实例化一个对象。例如，下面的代码片段向您展示了我们如何创建内置数据类型的实例对象。对于一些内置的数据类型，我们可以使用文字来实例化对象，比如对于一个 *list* 对象使用`[1, 2, 3]`，对于一个 *dict* 对象使用`{“a”: 1, “b”: 2}`。

实例化

自定义类允许我们编写一些日志信息，因此我们可以更好地理解自定义类的实例化过程。让我们看一个简单的例子，如下所示。

自定义类实例化

实例化包括两个关键步骤。

1.  **在内存中创建实例对象。**这一步涉及到调用`__new__()`方法，其名称仅仅意味着创建一个新的实例对象。这里的关键操作是给你正在构造的对象分配内存。在创建对象之后，通过调用`id()`函数，您可以看到一个内存槽已经与该对象相关联，这揭示了具有默认 [CPython 实现](https://docs.python.org/3/reference/datamodel.html)的底层对象的内存地址。
2.  设置对象的初始状态。一旦在内存中创建了对象，Python 将调用`__init__()`方法来完成对象的初始化过程。如果比较设置 name 属性前后的实例，您会注意到新对象开始时没有任何属性，在初始化后，它有了预期的 name 属性。值得注意的是，我们仍然在使用`__new__()`方法创建的同一个对象上工作，它具有相同的内存地址。

## 在命名空间中活动

一旦实例被创建，它将成为名称空间的一部分，因此它可以被其他变量和函数使用。为了了解哪些变量被跟踪，我们可以使用`globals()`函数，它将返回键值对，向我们显示被跟踪的标签和相关的对象。如果您尝试调用这个函数，您可能会注意到打印结果可能会很长。出于演示的目的，我将在下面的代码片段中向您展示映射的键。

全局名称空间

如您所见，键的最后一项是我们刚刚创建的`person`变量。当我们稍后在代码中访问这个变量时，映射对象用于为我们解析对象。如下图所示，我们实际上可以自己手动检索对象。

从全局名称空间中检索项目

*   我们可以使用`‘person’`键从全局名称空间的映射字典中检索`person`变量的关联对象。
*   检索到的对象通过十六进制值表示的内存地址来显示。(注意 0x 前缀吗？)为了验证这一点，我们可以使用内置的`hex()`函数从同一个对象中再现相同的十六进制值。

当一个对象在名称空间中处于活动状态时，Python 还会跟踪有多少对象持有对该对象的引用，以便进行内存管理。为了找出引用计数，我们可以利用 *sys* 和 *gc* 模块提供的功能。如下所示，下面的代码向您展示了该对象目前只有一个引用。

引用计数

现在，你应该只期待一个对`person`变量底层对象的引用，如`len(gc.get_referrers(person))`调用所示。但是，请不要对我们从`sys.getrefcount(person)`调用中得到的结果感到惊讶，因为它还包括对函数调用本身的对象的临时引用，这种行为是意料之中的，正如[官方文档](https://docs.python.org/3/library/sys.html#sys.getrefcount)中所讨论的。

> `sys.getrefcount` ( *对象*)
> 
> 返回*对象*的引用计数。返回的计数通常比您预期的要高一，因为它包含了(临时)引用作为`[getrefcount()](https://docs.python.org/3/library/sys.html#sys.getrefcount)`的参数。

引用计数的变化

上面的代码向您展示了 Python 为我们跟踪引用计数。首先，我们创建另一个对象，它保存了对`person`变量底层对象的引用，这导致对象的引用计数变为 2。其次，我们从内存中删除对象，正如所料，引用计数回到 1。

## 破坏

当一个对象的引用计数降到零时，它将被从内存中移除，这就是析构实例对象的过程。在正常情况下，我们不需要担心这些事情，因为 Python 会自动为我们管理内存。然而，为了理解这些过程，我们可以使用`del`语句手动将引用计数归零。我们在上一节中使用了它，但是我们没有解释它到底做了什么。下面的代码向您展示了到底发生了什么。

删除对象

*   在删除对象之前，引用底层对象的变量`person`位于全局名称空间中。
*   当我们使用`del`语句删除变量时，就会调用`__del__()`方法。您可以参考前面的代码片段，它向您展示了如何定义 *Person* 类，其中包括了`__del__`方法的实现。
*   删除后，变量`person`不再是全局名称空间的一部分。

需要注意的一点是，因为全局名称空间没有`person`变量，所以我们不能通过使用`person`标签来检查对象的引用计数，这是预期的行为，因为 Python 不能解析`person`变量。

```
>>> len(gc.get_referrers(person))
Traceback (most recent call last):
  File "<input>", line 1, in <module>
NameError: name 'person' is not defined
```

一些 Python 初学者可能会感到困惑的一件事是`del`语句实际上是做什么的。如果你记得我区分了变量和对象，下面的代码对你来说会更容易理解。

删除引用

*   上面的代码向您展示了我们创建了一个对象，但是有两个变量引用了同一个对象，正如使用`id()`函数通过同一个内存地址揭示的那样。
*   值得注意的是，删除其中一个不会触发我们为 *Person* 类实现的`__del__`方法的调用。但是，当基础对象因为在删除第二个变量后对象的引用计数为零而即将被删除时。

换句话说，`del`语句只从相应的名称空间中移除变量 label，而`__del__`方法关心的是底层对象何时从内存中被析构。

# 结论

在本文中，我们回顾了 Python 定制实例对象的生命周期。它也适用于大多数内置数据实例，但也有一些例外，比如小整数的内部化。理解这些潜在的机制可能有助于你对事物如何在引擎盖下工作有更深入的了解。这些基本概念对于您理解如何在垃圾收集的上下文中管理内存是必要的，这是一个更高级的主题，我们可以在将来讨论。

希望这篇文章对你有所帮助。