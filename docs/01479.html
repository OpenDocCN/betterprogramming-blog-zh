<html>
<head>
<title>How To Build a Better Command Line JSON/CSV Converter in Python</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何用Python构建更好的命令行JSON/CSV转换器</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/how-to-build-a-better-command-line-json-csv-converter-in-python-6022bce375a5?source=collection_archive---------7-----------------------#2019-09-16">https://betterprogramming.pub/how-to-build-a-better-command-line-json-csv-converter-in-python-6022bce375a5?source=collection_archive---------7-----------------------#2019-09-16</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="1a7d" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">关于我改进的Python命令行JSON/CSV转换器的分步教程</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/dae2a845069ffd68d496a67513e9d054.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*e1iypsouAGB6jABtPW-JyA.jpeg"/></div></div></figure><p id="226d" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">在之前的一篇文章中，我与你分享了我构建的一个<a class="ae lq" href="https://medium.com/better-programming/how-to-build-a-command-line-json-csv-converter-in-python-204d74563456" rel="noopener">命令行CSV/JSON转换器</a>。那个剧本是出于需要而写的——它当然符合要求，但在很大程度上是功能多于形式的例子。我决定重新构建转换器，这样我可以更容易地添加文件类型。在这样做的同时，我还优化了旧转换器的一些部分——结果是一个更快、更灵活的工具。一路上，我也学到了一些经验。</p></div><div class="ab cl lr ls hx lt" role="separator"><span class="lu bw bk lv lw lx"/><span class="lu bw bk lv lw lx"/><span class="lu bw bk lv lw"/></div><div class="im in io ip iq"><h1 id="926f" class="ly lz it bd ma mb mc md me mf mg mh mi jz mj ka mk kc ml kd mm kf mn kg mo mp bi translated">原件的问题</h1><p id="eb54" class="pw-post-body-paragraph ku kv it kw b kx mq ju kz la mr jx lc ld ms lf lg lh mt lj lk ll mu ln lo lp im bi translated">最初的脚本假设只涉及两种文件类型(CSV/JSON)。如果一个被导入，那么它将被转换为第二个，反之亦然。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi mv"><img src="../Images/fa35b46914f1394186a06ecf2b03ee7f.png" data-original-src="https://miro.medium.com/v2/resize:fit:960/format:webp/1*QHgExIXBXHnnJ3qu-jssUg.png"/></div></figure><p id="191e" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">但是当我们添加第三种文件类型时会发生什么呢？</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi mw"><img src="../Images/f13dd0d9da09eb6d7d0e312e77300717.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*E_feA8N1dNPdgyJDPj8acw.png"/></div></div></figure><p id="7174" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">每种附加的文件类型都需要一个函数来完成导入，然后为每种支持的文件类型创建新的转换函数。决定转换器的标准数据类型对于可伸缩性是必要的。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi mx"><img src="../Images/e316616258f073c578f5fcdab4091888.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*FxnkzU_EAP9bB79cOL5VRA.png"/></div></div></figure><p id="773d" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">现在，每当一个新的文件类型被添加到转换器，只需要做两个功能——转换到标准格式和从标准格式转换。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi mx"><img src="../Images/a4c07c75f9721c15d397de809cac4b34.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*1tcEVdf5VsolMSIwCW5GCw.png"/></div></div></figure></div><div class="ab cl lr ls hx lt" role="separator"><span class="lu bw bk lv lw lx"/><span class="lu bw bk lv lw lx"/><span class="lu bw bk lv lw"/></div><div class="im in io ip iq"><h1 id="1f72" class="ly lz it bd ma mb mc md me mf mg mh mi jz mj ka mk kc ml kd mm kf mn kg mo mp bi translated">骷髅</h1><p id="7987" class="pw-post-body-paragraph ku kv it kw b kx mq ju kz la mr jx lc ld ms lf lg lh mt lj lk ll mu ln lo lp im bi translated">根据上面给出的设计决策，我们创建了一个带有必要的导入/导出函数和注释的框架来概述执行。</p><pre class="kj kk kl km gt my mz na nb aw nc bi"><span id="89b3" class="nd lz it mz b gy ne nf l ng nh">import os<br/>import csv<br/>import json<br/>import xlsxwriter<br/>from collections import OrderedDict<br/>import math<br/><br/>def main():<br/>    # supported file types<br/>    # prompt user for file name<br/>    # attempt to import based on file name<br/>    # prompt user for export file name<br/>    # export data<br/><br/>################################<br/># IMPORT FUNCTIONS<br/>################################<br/><br/>def importJSON(f):<br/>    pass<br/><br/>def importCSV(f):<br/>    pass<br/><br/>################################<br/># EXPORT FUNCTIONS<br/>################################<br/><br/>def exportJSON(data,filename):<br/>    pass<br/><br/>def exportCSV(data,filename):<br/>    pass<br/><br/>#----------<br/><br/>if __name__ == "__main__":<br/>    main()</span></pre><p id="e8f9" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">下面是充实的<code class="fe ni nj nk mz b">main()</code>函数:</p><pre class="kj kk kl km gt my mz na nb aw nc bi"><span id="54c2" class="nd lz it mz b gy ne nf l ng nh">def main():<br/>    # supported file types<br/>    supported_file_types = (<br/>        "json",<br/>        "csv"<br/>    )<br/><br/>    # prompt user for file name<br/>    while True:<br/>        filename = input(f"Enter a file to load ({','.join(supported_file_types)}): ").strip()<br/>        if os.path.isfile(filename) == False:<br/>            print("&gt;&gt; Error, file does not exist")<br/>        elif os.path.basename(filename).split(".")[1].lower() not in supported_file_types:<br/>            print("&gt;&gt; Error, file type is not supported.")<br/>        else:<br/>            break<br/><br/>    # attempt to import based on file name<br/>    print("Attempting to load file...")<br/>    try:<br/>        f = open(filename)<br/>        file_type = os.path.basename(filename).split(".")[1].lower()<br/><br/>        if file_type == "json":<br/>            imported_data = importJSON(f)<br/>        elif file_type == "csv":<br/>            imported_data = importCSV(f)<br/><br/>        if imported_data is False:<br/>            raise Exception("&gt;&gt; Error, could not load file, exiting...")<br/>    except Exception as e:<br/>        print(e)<br/>    else:<br/>        print(f"&gt;&gt; File loaded, {len(imported_data)} records imported...")<br/><br/>    # prompt user for export file name<br/>    while True:<br/>        export_filename = input(f"Enter the output file name ({','.join(supported_file_types)}): ").strip().lower()<br/>        if os.path.basename(export_filename).split(".")[1].lower() not in supported_file_types:<br/>            print("&gt;&gt; Error, file type is not supported.")<br/>        elif os.path.isfile(export_filename) == True:<br/>            print("&gt;&gt; Error, file already exists")<br/>        else:<br/>            converted_file_type = os.path.basename(export_filename).split(".")[1].lower()<br/>            break<br/><br/>    # export data<br/>    if converted_file_type == "json":<br/>        data_size = exportJSON(imported_data, export_filename)<br/>    elif converted_file_type == "csv":<br/>        data_size = exportCSV(imported_data, export_filename)<br/><br/>    if data_size &gt; 1000000:<br/>        print(f"&gt;&gt; Records exported to: {export_filename} &lt;{math.floor(data_size/1000)/10} MB&gt;")<br/>    elif data_size &gt; 0:<br/>        print(f"&gt;&gt; Records exported to: {export_filename} &lt;{math.floor(data_size/10)/10} KB&gt;")<br/>    else:<br/>        print("&gt;&gt; Error, no file exported...")</span></pre><p id="ca57" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">为了将来的计划，我添加了一个元组来保存支持的文件类型，以便于验证。我选择使用<a class="ae lq" href="https://medium.com/better-programming/four-ways-to-print-variables-in-strings-28b346998d22" rel="noopener"> f-string文字来转置变量</a>，因为没有太多的插入，并且扫描代码时字符串仍然容易读取。</p></div><div class="ab cl lr ls hx lt" role="separator"><span class="lu bw bk lv lw lx"/><span class="lu bw bk lv lw lx"/><span class="lu bw bk lv lw"/></div><div class="im in io ip iq"><h1 id="4386" class="ly lz it bd ma mb mc md me mf mg mh mi jz mj ka mk kc ml kd mm kf mn kg mo mp bi translated">导入CSV和JSON文件</h1><p id="bc32" class="pw-post-body-paragraph ku kv it kw b kx mq ju kz la mr jx lc ld ms lf lg lh mt lj lk ll mu ln lo lp im bi translated">导入功能相对简单，除了一些小的性能调整外，与原始转换器没有什么变化。</p><pre class="kj kk kl km gt my mz na nb aw nc bi"><span id="af56" class="nd lz it mz b gy ne nf l ng nh">def importJSON(f):<br/>    try:<br/>        data = json.load(f,object_pairs_hook=OrderedDict)<br/>        if isinstance(data,OrderedDict):<br/>            data = [data]<br/>        return data<br/>    except Exception as e:<br/>        print(e)<br/>        return False<br/><br/>def importCSV(f):<br/>    try:<br/>        data = list(csv.reader(f))<br/>        keys = data[0]<br/>        converted = []<br/><br/>        for line in data[1:]:<br/>            obj = OrderedDict()<br/>            for key in keys:<br/>                if len(line[key]) &gt; 0:<br/>                    obj[key] = line[key]<br/>                else:<br/>                    obj[key] = None<br/>            converted.append(obj)<br/><br/>        return converted<br/>    except Exception as e:<br/>        print(e)<br/>        return False</span></pre><p id="084a" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">当导入CSV时，我选择直接遍历列表，而不是使用<code class="fe ni nj nk mz b">for i in range(len(data))</code>。此外，我选择使用切片符号来删除第一个索引。当导入JSON时，OrderedDicts用于在我们希望以相同的文件格式导入和导出时保留键-值对的排列，有效地创建一个相同的副本。</p></div><div class="ab cl lr ls hx lt" role="separator"><span class="lu bw bk lv lw lx"/><span class="lu bw bk lv lw lx"/><span class="lu bw bk lv lw"/></div><div class="im in io ip iq"><h1 id="6b24" class="ly lz it bd ma mb mc md me mf mg mh mi jz mj ka mk kc ml kd mm kf mn kg mo mp bi translated">导出CSV和JSON文件</h1><p id="cf13" class="pw-post-body-paragraph ku kv it kw b kx mq ju kz la mr jx lc ld ms lf lg lh mt lj lk ll mu ln lo lp im bi translated">因为这种转换的标准格式是JSON，所以导出JSON非常直接。按照这个转换器的设计，当导出CSV时，第一步是从JSON转换。</p><pre class="kj kk kl km gt my mz na nb aw nc bi"><span id="c432" class="nd lz it mz b gy ne nf l ng nh">def exportJSON(data,filename):<br/>    try:<br/>        with open(filename, 'w') as outfile:<br/>            json.dump(data, outfile,indent=2)<br/>        return os.path.getsize(filename)<br/>    except Exception as e:<br/>        print(e)<br/>        return False<br/><br/>def exportCSV(data,filename):<br/>    try:<br/>        keys = set([<br/>            cell<br/>            for line in data<br/>            for cell in line<br/>        ])<br/><br/>        # map data in each row to key index<br/>        converted = []<br/>        converted.append(keys)<br/><br/>        for line in data:<br/>            row = []<br/>            for key in keys:<br/>                if key in line:<br/>                    if isinstance(line[key],(list,OrderedDict,dict)):<br/>                        continue # skip nested data structures<br/>                    else:<br/>                        row.append(line[key])<br/>                else:<br/>                    row.append(None)<br/>            converted.append(row)<br/>        <br/>        with open(filename, 'w') as outfile:<br/>            writer = csv.writer(outfile)<br/>            writer.writerows(converted)<br/>        return os.path.getsize(filename)<br/>    except Exception as e:<br/>        print(e)<br/>        return False</span></pre><p id="b4ed" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">我喜欢在使用<code class="fe ni nj nk mz b">json.dump()</code>时设置缩进值，以避免长时间的单行转储，这会降低一些编辑器的速度，比如Atom。CSV导出使用<a class="ae lq" href="https://medium.com/better-programming/python-list-comprehension-by-example-9ce679aca41f" rel="noopener">列表理解</a>，而不是嵌套的for循环，以获得良好的性能和pythonic式的改进。</p></div><div class="ab cl lr ls hx lt" role="separator"><span class="lu bw bk lv lw lx"/><span class="lu bw bk lv lw lx"/><span class="lu bw bk lv lw"/></div><div class="im in io ip iq"><h1 id="9ef8" class="ly lz it bd ma mb mc md me mf mg mh mi jz mj ka mk kc ml kd mm kf mn kg mo mp bi translated">结论</h1><p id="ef32" class="pw-post-body-paragraph ku kv it kw b kx mq ju kz la mr jx lc ld ms lf lg lh mt lj lk ll mu ln lo lp im bi translated">我很高兴与社区分享这一点。这是持续改进和初学者优化的一个很好的例子。我计划在不久的将来为这个转换器添加XLS/XLSX支持，以及XML。访问<a class="ae lq" href="https://github.com/jhsu98/data-converter" rel="noopener ugc nofollow" target="_blank">库</a>查看最终结果，并了解该工具的最新添加内容。请随意使用和贡献它，或分叉它，使它成为你自己的。</p><p id="2b83" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated"><em class="nl">储存库:</em><a class="ae lq" href="https://github.com/jhsu98/data-converter" rel="noopener ugc nofollow" target="_blank"><em class="nl">https://github.com/jhsu98/data-converter</em></a></p></div></div>    
</body>
</html>