<html>
<head>
<title>Kubernetes — Different Ways of Deploying a Sample RESTful API Application</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">kubernetes——部署示例RESTful API应用程序的不同方式</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/kubernetes-different-ways-of-deploying-a-sample-restful-api-application-189accca8c6b?source=collection_archive---------6-----------------------#2022-05-21">https://betterprogramming.pub/kubernetes-different-ways-of-deploying-a-sample-restful-api-application-189accca8c6b?source=collection_archive---------6-----------------------#2022-05-21</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="5b2b" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">为了保持代码的灵活性</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/f0e20bb8c4614731011b3ba4d1c68ad1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Ja4_eqbLWrBKJDDg80eIeg.jpeg"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">集装箱船由<a class="ae kv" href="https://pixabay.com/users/dendoktoor-14802912/" rel="noopener ugc nofollow" target="_blank">登上<a class="ae kv" href="https://pixabay.com/photos/container-ship-container-transport-6631117/" rel="noopener ugc nofollow" target="_blank">码头或</a>登上</a></p></figure><p id="1916" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">让我们假设有一个API可以部署，并且有人决定使用业界领先的编排软件——Kubernetes。</p><p id="0afe" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">源自谷歌，<em class="ls"> Kubernetes </em>在希腊语中的意思是舵手或领航员，它正是为这个目的服务的——在这个例子中，指挥一个集装箱船队。它使扩展巨大的应用程序成为可能，并避免了向大众提供服务的常见陷阱。</p><p id="fce3" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">尽管一开始这非常符合逻辑并且很容易上手，但是如果没有端口转发，要实现对集群的访问可能会有点困难。就我个人而言，我不太喜欢端口转发。因此，即使开发本地应用程序，我袖手旁观开发他们，使他们准备好部署到生产没有任何突破性的变化。</p><p id="82fb" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">核心概念很容易掌握。但是，由于运行“真正的”——或者更正式地说，生产集群——需要一系列组件，大多数时候，人们从开发环境备选方案开始，如<code class="fe lt lu lv lw b">minikube</code>、<code class="fe lt lu lv lw b">microk8s</code>或内置的Docker Desktop Kubernetes引擎。</p><p id="214b" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">一般来说，有几种方法可以让流量进入Kubernetes集群，主要取决于它的部署位置。</p><p id="fcb3" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">每个选项的清单可以在<a class="ae kv" href="https://github.com/piotrostr/pong" rel="noopener ugc nofollow" target="_blank">这里</a>找到。</p><h1 id="84e0" class="lx ly iq bd lz ma mb mc md me mf mg mh jw mi jx mj jz mk ka ml kc mm kd mn mo bi translated">1.本地使用Minikube或k3s进行端口转发</h1><pre class="kg kh ki kj gt mp lw mq mr aw ms bi"><span id="50f9" class="mt ly iq lw b gy mu mv l mw mx">kubectl create deployment [deployment] --image=piotrostr/pong<br/>kubectl expose deployment [deployment]</span></pre><p id="6968" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">然后，它可以从节点转发到端口:</p><pre class="kg kh ki kj gt mp lw mq mr aw ms bi"><span id="14dd" class="mt ly iq lw b gy mu mv l mw mx">kubectl port-forward service/[deployment] [port-host]:[port-container]</span></pre><p id="6357" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这对于调试单个部署可能很有用。</p><p id="ed7c" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">还有一个选项是使用<code class="fe lt lu lv lw b">kubectl proxy</code>并直接与本地Kubernetes API交互，但是与下面的其他选项相比，这有点麻烦。</p><h1 id="db4d" class="lx ly iq bd lz ma mb mc md me mf mg mh jw mi jx mj jz mk ka ml kc mm kd mn mo bi translated">2.使用Docker桌面Kubernetes提供程序(参考资料:manifest-docker.yaml)</h1><p id="081e" class="pw-post-body-paragraph kw kx iq ky b kz my jr lb lc mz ju le lf na lh li lj nb ll lm ln nc lp lq lr ij bi translated">这是一个很好的例子，因为docker-desktop使用vpnkit来暴露任何负载平衡器并将流量转发到集群中。</p><p id="e1a1" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这里的清单只包括负载平衡器服务和部署本身，不包括入口。</p><p id="592e" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">代码如下:</p><pre class="kg kh ki kj gt mp lw mq mr aw ms bi"><span id="9132" class="mt ly iq lw b gy mu mv l mw mx">kubectl apply -f manifest-docker.yaml</span></pre><p id="3c2c" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">它使应用程序准备好被<code class="fe lt lu lv lw b">curl</code>调用。</p><p id="3207" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">值得注意的是，Docker Desktop只将流量转发给<code class="fe lt lu lv lw b">kind: LoadBalancer</code>的资源，这种方法不适用于<code class="fe lt lu lv lw b">kind: NodePort</code>等。</p><p id="c353" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我想说这是调试简单应用程序的必备工具，使用<code class="fe lt lu lv lw b">skaffold dev</code>非常有效。更多关于skaffold <a class="ae kv" href="https://github.com/GoogleContainerTools/skaffold" rel="noopener ugc nofollow" target="_blank">的信息，请点击</a>。</p><h1 id="29ee" class="lx ly iq bd lz ma mb mc md me mf mg mh jw mi jx mj jz mk ka ml kc mm kd mn mo bi translated">3.在Google Kubernetes引擎上(资源:<code class="fe lt lu lv lw b">manifest-gke.yaml</code>)</h1><p id="eaad" class="pw-post-body-paragraph kw kx iq ky b kz my jr lb lc mz ju le lf na lh li lj nb ll lm ln nc lp lq lr ij bi translated"><strong class="ky ir">注意:</strong>要求<code class="fe lt lu lv lw b">gcloud</code>配置正确的项目并启用GKE。</p><p id="82ff" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在清单中包含以下入口资源后，它可以用于在GCP云上无缝地供应集群。代码如下:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nd ne l"/></div></figure><p id="458e" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">创建一个GKE集群，并将<code class="fe lt lu lv lw b">kubectl</code>配置为使用<code class="fe lt lu lv lw b">gcloud</code>上下文:</p><pre class="kg kh ki kj gt mp lw mq mr aw ms bi"><span id="0dec" class="mt ly iq lw b gy mu mv l mw mx">gcloud container clusters create-auto [cluster-name] \<br/>  --region=[region]<br/>gcloud container clusters get-credentials [cluster-name] \<br/>  --region=[region]</span></pre><p id="8af0" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">应用yaml后，负载平衡器将从GCP进行配置，并将所有流量转发到集群中。</p><h1 id="2964" class="lx ly iq bd lz ma mb mc md me mf mg mh jw mi jx mj jz mk ka ml kc mm kd mn mo bi translated">4.使用Nginx入口(资源:manifest-nginx.yaml)</h1><p id="1150" class="pw-post-body-paragraph kw kx iq ky b kz my jr lb lc mz ju le lf na lh li lj nb ll lm ln nc lp lq lr ij bi translated">使用以下命令安装它:</p><pre class="kg kh ki kj gt mp lw mq mr aw ms bi"><span id="0b0d" class="mt ly iq lw b gy mu mv l mw mx">helm upgrade --install ingress-nginx ingress-nginx \<br/>  --repo <a class="ae kv" href="https://kubernetes.github.io/ingress-nginx" rel="noopener ugc nofollow" target="_blank">https://kubernetes.github.io/ingress-nginx</a> \<br/>  --namespace ingress-nginx \<br/>  --create-namespace</span></pre><p id="7bb3" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">通过包括与第三个相同的入口资源并在<code class="fe lt lu lv lw b">spec</code>下添加<code class="fe lt lu lv lw b">ingressClassName: nginx</code>(以定义使用哪个控制器)。</p><p id="1c3a" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">对于<code class="fe lt lu lv lw b">minikube</code>，有一个额外的启用入口的步骤，因为它不支持开箱入口。下面是如何做到这一点:</p><pre class="kg kh ki kj gt mp lw mq mr aw ms bi"><span id="2e44" class="mt ly iq lw b gy mu mv l mw mx">minikube addons enable ingress<br/>minikube tunnel</span></pre><p id="73f7" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这种方法支持外部流量进入集群和部署，而无需GKE或EKS(AWS的弹性Kubernetes服务)。该清单可以很容易地部署在虚拟机的单个节点集群上。</p><p id="5bf5" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">它使人受益于Kubernetes的强大功能，如自动伸缩和自动修复。它不会强迫用户使用AWS/GCP负载平衡服务和集群成本，这对于小型应用程序来说可能会越积越多。</p><p id="3d5c" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">NGINX入口是负载平衡的，这意味着<code class="fe lt lu lv lw b">curl</code>分布在五个pod之间(更改<code class="fe lt lu lv lw b">manifest-nginx.yaml</code>中的<code class="fe lt lu lv lw b">replicas</code>以修改pod编号)。</p><h1 id="e659" class="lx ly iq bd lz ma mb mc md me mf mg mh jw mi jx mj jz mk ka ml kc mm kd mn mo bi translated">结论</h1><p id="e512" class="pw-post-body-paragraph kw kx iq ky b kz my jr lb lc mz ju le lf na lh li lj nb ll lm ln nc lp lq lr ij bi translated">可以看到，在GCP上引入流量甚至部署自动扩展群集的速度非常快。有一些警告，主要是由于生产集群和集群一的不同结构，集群一将在本地运行以测试其应用程序。如果没有NGINX这样的入口控制器，需要记住许多额外的步骤。对于<code class="fe lt lu lv lw b">minikube</code>集群，需要启用入口，当它进入Docker Desktop时，需要确保服务资源是一个<code class="fe lt lu lv lw b">LoadBalancer</code>。实现入口控制器似乎是最合适的选择，因为从本地部署转移到生产部署时几乎没有开销，而且我们大多数开发人员都习惯于使用<code class="fe lt lu lv lw b">curl localhost</code>。</p></div><div class="ab cl nf ng hu nh" role="separator"><span class="ni bw bk nj nk nl"/><span class="ni bw bk nj nk nl"/><span class="ni bw bk nj nk"/></div><div class="ij ik il im in"><p id="bae6" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><em class="ls">最初发表于</em><a class="ae kv" href="https://gist.github.com/piotrostr/fbd029d428a336e3c7431e5fe20dcd25" rel="noopener ugc nofollow" target="_blank"><em class="ls"/></a><em class="ls">。</em></p></div></div>    
</body>
</html>