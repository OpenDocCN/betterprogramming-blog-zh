<html>
<head>
<title>K8s Tips: Playing With Nodes</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">K8s提示:使用节点</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/k8s-tips-playing-with-nodes-e6645af13a27?source=collection_archive---------15-----------------------#2021-02-12">https://betterprogramming.pub/k8s-tips-playing-with-nodes-e6645af13a27?source=collection_archive---------15-----------------------#2021-02-12</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="5359" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">熟悉集群管理的一些关键概念</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/46bb738853a1a409e7f44a75e86a878c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*tWbgTspr1uSMjrb21MEvSg.jpeg"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">迪米特里·豪特曼在<a class="ae ky" href="https://unsplash.com/s/photos/kitten-playing?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的照片。</p></figure><p id="73c7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">本文提供了一种回归基础的方法来帮助您理解可以在集群节点上完成的几种操作。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="8162" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">我们的测试集群</h1><p id="748f" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">让我们考虑一个新创建的包含一个主节点和两个工作节点的<code class="fe mz na nb nc b">kubeadm</code>集群:</p><pre class="kj kk kl km gt nd nc ne nf aw ng bi"><span id="a151" class="nh md it nc b gy ni nj l nk nl"><strong class="nc iu">$ kubectl get nodes<br/></strong>NAME    STATUS   ROLES                  AGE   VERSION<br/>k8s-1   Ready    control-plane,master   18m   v1.20.0<br/>k8s-2   Ready    &lt;none&gt;                 18m   v1.20.0<br/>k8s-3   Ready    &lt;none&gt;                 18m   v1.20.0</span></pre><p id="c507" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">首先，我们将安装<a class="ae ky" href="https://codeberg.org/hjacobs/kube-ops-view" rel="noopener ugc nofollow" target="_blank"> Kubernetes操作视图</a>(又名kube-ops-view)。这个应用程序非常方便地查看集群中运行的所有pods。目前有14个pod在运行:</p><ul class=""><li id="d9a6" class="nm nn it lb b lc ld lf lg li no lm np lq nq lu nr ns nt nu bi translated">其中两个位于默认名称空间中，并与kube-obs-view相关。它们在下面截图中k8s-2和k8s-3的左上角</li><li id="a6a5" class="nm nn it lb b lc nv lf nw li nx lm ny lq nz lu nr ns nt nu bi translated">其他12个位于kube-system名称空间中:kube-api-server、etcd、kube-controller-manager、kube-scheduler、kube-proxy (x3)、weave-net (x3)、core-dns (x2)。</li></ul><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi oa"><img src="../Images/046717a9085b837d2a499780eb2d17c2.png" data-original-src="https://miro.medium.com/v2/resize:fit:700/format:webp/1*5WdV9qWdhTIiwA9M-r6jyA.png"/></div></figure><p id="183b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们使用ghost映像创建一个有四个副本的部署(<a class="ae ky" href="https://github.com/TryGhost/Ghost" rel="noopener ugc nofollow" target="_blank"> ghost </a>是一个开源博客平台):</p><pre class="kj kk kl km gt nd nc ne nf aw ng bi"><span id="bb70" class="nh md it nc b gy ni nj l nk nl">$ kubectl create deploy ghost --image=ghost --replicas 4</span></pre><p id="5947" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">从kube-ops-view中，我们可以看到四个新的pod(在下面的红色圆圈中)部署在k8s-2和k8s-3上(每个节点上有两个ghost pods):</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi oa"><img src="../Images/7bd283b4ddf6b7e22fd3c6609d9be96f.png" data-original-src="https://miro.medium.com/v2/resize:fit:700/format:webp/1*qXM_NUxu8Hoa35NnJ2PNmQ.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">Ghost pods只安排在k8s-2和k8s-3上。</p></figure><p id="773b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这也可以通过使用以下命令来确认:</p><pre class="kj kk kl km gt nd nc ne nf aw ng bi"><span id="f0a6" class="nh md it nc b gy ni nj l nk nl"><strong class="nc iu">$ k get po -l app=ghost \<br/>  -o custom-columns=NAME:.metadata.name,NODE:.spec.nodeName<br/></strong>NAME                                   NODE<br/>ghost-dc9899fc7-9254f                  k8s-3<br/>ghost-dc9899fc7-946ck                  k8s-2<br/>ghost-dc9899fc7-lz94w                  k8s-3<br/>ghost-dc9899fc7-vsnqn                  k8s-2</span></pre><p id="974b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">k8s-1(主节点)上没有部署我们的幽灵舱。这是为什么呢？</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="fe03" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated"><strong class="ak">污点</strong></h1><p id="a687" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">默认情况下，k8s-1有一个污点，是由<code class="fe mz na nb nc b">kubeadm</code>在集群设置期间添加的。污点基本上是一个键值对(该值称为效果)。以下命令显示了k8s-1上存在的污点:</p><pre class="kj kk kl km gt nd nc ne nf aw ng bi"><span id="7732" class="nh md it nc b gy ni nj l nk nl"><strong class="nc iu">$ kubectl describe node k8s-1 | grep Taints<br/></strong>Taints:             node-role.kubernetes.io/master:NoSchedule</span></pre><ul class=""><li id="83c9" class="nm nn it lb b lc ld lf lg li no lm np lq nq lu nr ns nt nu bi translated">关键是<code class="fe mz na nb nc b">node-role.kubernetes.io/master</code>。</li><li id="dcb6" class="nm nn it lb b lc nv lf nw li nx lm ny lq nz lu nr ns nt nu bi translated">效果是<code class="fe mz na nb nc b">NoSchedule</code>。</li></ul><p id="756b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">当在节点上设置污点时，它会阻止在该节点上调度pod。把污点想象成一种不好的气味:一个pod不会去那里，除非它容忍这个污点，在pod的规范中定义一个与污点相同的键/效果的容忍。我们定义的幽灵舱不能容忍污染，所以它们不能被安排在k8s-1上。</p><p id="886c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><em class="ob">注意:为了容忍前面的污点，一个pod需要在其规范中有下面的</em> <code class="fe mz na nb nc b"><em class="ob">tolerations</em></code> <em class="ob">条目:</em></p><pre class="kj kk kl km gt nd nc ne nf aw ng bi"><span id="4143" class="nh md it nc b gy ni nj l nk nl">...<br/>spec:<br/>  <strong class="nc iu">tolerations:<br/>  - key: node-role.kubernetes.io/master<br/>    effect: NoSchedule</strong></span></pre><p id="4c46" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们去除污点，使k8s-1能够接收应用程序的一些pod。对于我们的例子来说，去掉这个污点是好的，但是在一个真实的集群中，我们可能不去管它，而在pods的规范中使用<code class="fe mz na nb nc b">tolerations</code>属性，这些pods也明确地需要部署在主节点上。</p><pre class="kj kk kl km gt nd nc ne nf aw ng bi"><span id="07e0" class="nh md it nc b gy ni nj l nk nl">$ kubectl taint node k8s-1 node-role.kubernetes.io/master-</span></pre><p id="487e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">清除污点不会触发现有吊舱的重新部署。我们需要强迫它:</p><pre class="kj kk kl km gt nd nc ne nf aw ng bi"><span id="21f8" class="nh md it nc b gy ni nj l nk nl">$ kubectl rollout restart deploy/ghost</span></pre><p id="fa9c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们现在可以看到，这四个pod已被重新安排。这一次，调度器考虑了三个节点，因为主节点没有任何污点。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi oa"><img src="../Images/5cc00dd172ac344ad05036508f5711d3.png" data-original-src="https://miro.medium.com/v2/resize:fit:700/format:webp/1*bp-OFKLgIf8kyQaRw_n6mA.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">k8s-1现在可以预定一个分离舱，因为污染被移除了。</p></figure><pre class="kj kk kl km gt nd nc ne nf aw ng bi"><span id="9752" class="nh md it nc b gy ni nj l nk nl"><strong class="nc iu">$ kubectl get po -l app=ghost \<br/>  -o custom-columns=NAME:.metadata.name,NODE:.spec.nodeName<br/></strong>NAME                     NODE<br/>ghost-7564b56ff4-26nth   k8s-3<br/>ghost-7564b56ff4-h2pm4   k8s-2<br/>ghost-7564b56ff4-m72c5   k8s-2<br/><strong class="nc iu">ghost-7564b56ff4-vd6nv   k8s-1</strong></span></pre></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="c1fa" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">警戒线/非警戒线</h1><p id="8417" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">有时，我们可能需要停止在一个节点上安排额外的pod，而不删除在该节点上运行的当前pod。为此，我们可以封锁节点。以下命令连接k8s-2节点:</p><pre class="kj kk kl km gt nd nc ne nf aw ng bi"><span id="6fa8" class="nh md it nc b gy ni nj l nk nl">$ kubectl cordon k8s-2</span></pre><p id="033c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在此阶段，在该节点上运行的pod仍在运行，但不能添加额外的pod。通过列出集群的节点，我们可以看到k8s-2现在被标记为<code class="fe mz na nb nc b">SchedulingDisabled</code>:</p><pre class="kj kk kl km gt nd nc ne nf aw ng bi"><span id="2928" class="nh md it nc b gy ni nj l nk nl"><strong class="nc iu">$ kubectl get node<br/></strong>NAME    STATUS                    ROLES                AGE   VERSION<br/>k8s-1   Ready                     control-plane,master 25m   v1.20.0<br/>k8s-2   Ready,<strong class="nc iu">SchedulingDisabled</strong>  &lt;none&gt;               25m   v1.20.0<br/>k8s-3   Ready                     &lt;none&gt;               25m   v1.20.0</span></pre><p id="e35f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们增加复制副本的数量，看看新的单元安排在哪里:</p><pre class="kj kk kl km gt nd nc ne nf aw ng bi"><span id="234d" class="nh md it nc b gy ni nj l nk nl">$ kubectl scale deploy/ghost --replicas=8</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi oa"><img src="../Images/5302a75f174bd4b8141ac347c3e82147.png" data-original-src="https://miro.medium.com/v2/resize:fit:700/format:webp/1*rm30KtWgqdI7AxZNSrrA1A.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">四个额外的幽灵吊舱仅部署在k8s-1和k8s-3上。</p></figure><p id="70d5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">正如我们所料，k8s-2上的吊舱数量保持不变。我们可以使用以下命令将节点恢复到之前的状态:</p><pre class="kj kk kl km gt nd nc ne nf aw ng bi"><span id="cdda" class="nh md it nc b gy ni nj l nk nl">$ kubectl uncordon k8s-2</span></pre><p id="7f6c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">k8s-2现在将能够接收额外的吊舱，因为该节点上的调度不再被禁用。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="343e" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">流干</h1><p id="d8cb" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">我们有时需要删除在特定节点上运行的现有pod，并在集群中的其他节点上对它们进行重新调度。当我们想要在节点上执行维护操作时，通常需要这样做。</p><p id="6a4a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">为此，我们可以使用<code class="fe mz na nb nc b">drain</code>命令，如下图k8s-3节点所示:</p><pre class="kj kk kl km gt nd nc ne nf aw ng bi"><span id="2319" class="nh md it nc b gy ni nj l nk nl">$ kubectl drain --ignore-daemonsets k8s-3</span></pre><p id="d3f2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><em class="ob">注意:当一个节点被排空时，穿过</em> <code class="fe mz na nb nc b"><em class="ob">DaemonSet</em></code> <em class="ob">的pod不能被移除(例如kube-proxy、weave-net等)。).当运行</em> <code class="fe mz na nb nc b"><em class="ob">drain</em></code> <em class="ob">命令时，我们需要使用</em> <code class="fe mz na nb nc b"><em class="ob">--ignore-daemonsets</em></code> <em class="ob">标志明确指出</em> <code class="fe mz na nb nc b"><em class="ob">DaemonSet</em></code> <em class="ob">的pod被忽略。</em></p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi oa"><img src="../Images/ee62c98929373aed2482f1e650ce28f4.png" data-original-src="https://miro.medium.com/v2/resize:fit:700/format:webp/1*R-f7MOObalaWRcpzmvxVCw.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">k8s-3上不再有豆荚(除了DaemonSet的豆荚)在运行，因为它已经被吸干了。</p></figure><p id="54f6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">正如我们在下面看到的，排空一个节点也阻止了新的吊舱被安排在那个节点上:k8s-3现在也被封锁了。</p><pre class="kj kk kl km gt nd nc ne nf aw ng bi"><span id="d2eb" class="nh md it nc b gy ni nj l nk nl"><strong class="nc iu">$ kubectl get node<br/></strong>NAME    STATUS                    ROLES                AGE   VERSION<br/>k8s-1   Ready                     control-plane,master 30m   v1.20.0<br/>k8s-2   Ready                     &lt;none&gt;               30m   v1.20.0<br/>k8s-3   Ready,<strong class="nc iu">SchedulingDisabled</strong>  &lt;none&gt;               30m   v1.20.0</span></pre><p id="9bfb" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们需要解除节点的锁定，以使调度再次可用:</p><pre class="kj kk kl km gt nd nc ne nf aw ng bi"><span id="f6df" class="nh md it nc b gy ni nj l nk nl">$ kubectl uncordon k8s-3</span><span id="c2e6" class="nh md it nc b gy oc nj l nk nl">$ kubectl get node<br/>NAME    STATUS   ROLES                  AGE   VERSION<br/>k8s-1   Ready    control-plane,master   22h   v1.20.0<br/>k8s-2   Ready    &lt;none&gt;                 22h   v1.20.0<br/>k8s-3   Ready    &lt;none&gt;                 22h   v1.20.0</span></pre><p id="1f72" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">正如我们之前所做的那样，我们需要根据命令强制重启部署，以便在集群的节点上重新创建和重新分布pod:</p><pre class="kj kk kl km gt nd nc ne nf aw ng bi"><span id="12cf" class="nh md it nc b gy ni nj l nk nl">$ kubectl rollout restart deploy/ghost</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi oa"><img src="../Images/5af45b4b0754437a60fa9af614f0292e.png" data-original-src="https://miro.medium.com/v2/resize:fit:700/format:webp/1*8sotkv8srEf9C5iHQgSODQ.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">现在已在三个节点上安排了pod。</p></figure></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="e658" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">结论</h1><p id="02cf" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">本文展示了在处理节点和准备维护节点时常用的一些命令。我们还简要介绍了污点，这是一个添加了调度约束的属性。</p><p id="00ba" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">pod规范中可用的其他几个属性可以用来改进调度阶段的粒度(<code class="fe mz na nb nc b">nodeSelector</code>、<code class="fe mz na nb nc b">nodeAffinity</code>、<code class="fe mz na nb nc b">podAffinity</code>和<code class="fe mz na nb nc b">podAntiAffinity</code>)。</p></div></div>    
</body>
</html>