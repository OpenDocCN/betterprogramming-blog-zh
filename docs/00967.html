<html>
<head>
<title>Utilize Open API 3 for the Faster Software Development Process</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">利用开放API 3加快软件开发过程</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/utilize-open-api-3-for-the-faster-software-development-process-6783f18c63d5?source=collection_archive---------4-----------------------#2019-08-01">https://betterprogramming.pub/utilize-open-api-3-for-the-faster-software-development-process-6783f18c63d5?source=collection_archive---------4-----------------------#2019-08-01</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="b211" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">如何使用开源工具在Kubernetes中轻松制作模拟服务器、APIClient SDK和实时API文档</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/c6a7a374106aa47e540dca45a79ea550.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*WDWRPHV9nttsoKwJ"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">在<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上<a class="ae ky" href="https://unsplash.com/@toineprojects?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">给</a>拍照</p></figure><p id="8f92" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我对开源世界充满热情。有这么多伟大的免费开源工具，如Linux、Kubernetes、Docker、NodeJS和Golang。这个生态系统还在继续发展，为这个世界(软件工程世界)带来了新的技术和解决方案。</p><p id="93ca" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">今天，我将探索一些可能对开发人员有用的开源项目。如果你曾经读过<a class="ae ky" href="https://toolbox.kurio.co.id/api-driven-development-in-kurio-speeding-up-the-development-process-with-open-api-3-addcc07cb9ce" rel="noopener ugc nofollow" target="_blank">我的关于我们在<a class="ae ky" href="https://kurio.id" rel="noopener ugc nofollow" target="_blank"> Kurio </a>中使用的API驱动开发实践的文章</a>，你会发现像开放API 3、模拟服务器和SDK生成器这样的术语。但是，在那篇文章中，我没有解释诸如利用Open API 3、创建模拟服务器或生成SDK之类的事情。</p><p id="1c09" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在这篇文章中，我将介绍如何创建一个模拟服务器，使用免费工具生成一个API SDK(也称为开源项目)并将其托管在Kubernetes(K8s)集群中。对于这种情况，我将使用我自己的Kubernetes集群。</p><p id="2a6c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">下面的所有步骤都将使用K8s集群，我将在假设您已经拥有一个可用的、生产就绪的K8s集群(或者至少是准备就绪的)的情况下工作。</p><p id="f7f6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">对于我的探索，我已经准备了一个Open API 3规范的例子，我将在本文中使用这个规范。规范可以在我的<a class="ae ky" href="https://github.com/bxcodec/tweetor/blob/master/docs/openapi.yaml" rel="noopener ugc nofollow" target="_blank"> Github repo </a>中找到。</p><p id="b1af" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">总而言之，我将使用开放API规范做三件事:</p><ul class=""><li id="d741" class="lv lw it lb b lc ld lf lg li lx lm ly lq lz lu ma mb mc md bi translated"><a class="ae ky" href="#d9c7" rel="noopener ugc nofollow">根据开放的API 3规范创建实时API文档</a></li><li id="c206" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated"><a class="ae ky" href="#b13e" rel="noopener ugc nofollow">从Open API 3中创建一个轻量级且速度极快的模拟服务器</a></li><li id="8d8a" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated"><a class="ae ky" href="#bbc2" rel="noopener ugc nofollow">从开放API 3规范生成HTTP SDK客户端</a></li></ul></div><div class="ab cl mj mk hx ml" role="separator"><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo"/></div><div class="im in io ip iq"><h1 id="d9c7" class="mq mr it bd ms mt mu mv mw mx my mz na jz nb ka nc kc nd kd ne kf nf kg ng nh bi translated">创建实时API文档</h1><p id="4a3e" class="pw-post-body-paragraph kz la it lb b lc ni ju le lf nj jx lh li nk lk ll lm nl lo lp lq nm ls lt lu im bi translated">需要准备的工具:</p><ul class=""><li id="7573" class="lv lw it lb b lc ld lf lg li lx lm ly lq lz lu ma mb mc md bi translated"><a class="ae ky" href="https://github.com/swagger-api/swagger-ui" rel="noopener ugc nofollow" target="_blank"> Swagger UI </a></li><li id="a762" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated">开放API的完整/现成安装</li><li id="4195" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated">一个实时的、生产就绪的K8s集群(或者至少是准备就绪的)</li></ul><p id="e609" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">最简单的方法是创建实时API文档。有了实时API文档，希望每个开发人员都能够阅读并理解我们的API，它是如何工作的，请求和响应。我们可以使用的工具有很多，但在本文中，我将使用Swagger提供的默认工具，Swagger UI <strong class="lb iu">。</strong></p><p id="7b4d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">他们已经提供了一个我们可以使用的公共docker图像。因此，如果您有一个K8s集群，只需将它的部署添加到我们的K8s集群中。很简单。</p><h2 id="67c8" class="nn mr it bd ms no np dn mw nq nr dp na li ns nt nc lm nu nv ne lq nw nx ng ny bi translated"><strong class="ak">第一步:创建Swagger UI的Docker图像</strong></h2><p id="e001" class="pw-post-body-paragraph kz la it lb b lc ni ju le lf nj jx lh li nk lk ll lm nl lo lp lq nm ls lt lu im bi translated">我们需要创建一个Docker映像，它将被使用并部署到我们的K8s集群中。不要忘记使用Swagger UI作为基本的docker-image。</p><p id="4fad" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">下面是我的Dockerfile文件的一个例子:</p><pre class="kj kk kl km gt nz oa ob oc aw od bi"><span id="9eca" class="nn mr it oa b gy oe of l og oh">FROM swaggerapi/swagger-ui:v3.23.1</span><span id="fd30" class="nn mr it oa b gy oi of l og oh">ADD <strong class="oa iu">tweetor.yaml</strong> /usr/share/nginx/html/tweetor.yaml<br/># Add another spec here</span></pre><ul class=""><li id="9ddb" class="lv lw it lb b lc ld lf lg li lx lm ly lq lz lu ma mb mc md bi translated"><code class="fe oj ok ol oa b">tweetor.yaml</code> <strong class="lb iu"> </strong>是我的开放API规范。只需将它添加到基本图像文件夹中。完整的文件可以在<a class="ae ky" href="https://github.com/bxcodec/tweetor/blob/master/docs/openapi.yaml" rel="noopener ugc nofollow" target="_blank">这里</a>找到。</li><li id="3770" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated">由于基础图像<code class="fe oj ok ol oa b">swaggerapi/swagger-ui:v3.23.1</code>使用了NGinx，我需要将我的<code class="fe oj ok ol oa b">Spec</code>添加到NGinx文件夹中，这个文件夹在<code class="fe oj ok ol oa b">/usr/share/nginx/html/</code>中。</li></ul><p id="82b4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">然后，我们可以构建并将其推送到私有容器注册中心(我使用GCR作为我的个人docker注册中心):</p><pre class="kj kk kl km gt nz oa ob oc aw od bi"><span id="9881" class="nn mr it oa b gy oe of l og oh">$ docker build -t asia.gcr.io/kube-xmas/tweetor-docs:latest .<br/>//docker build process will happen here...</span><span id="798c" class="nn mr it oa b gy oi of l og oh">$ docker push asia.gcr.io/kube-xmas/tweetor-docs:latest<br/>//docker push process will happen here...</span></pre><h2 id="8213" class="nn mr it bd ms no np dn mw nq nr dp na li ns nt nc lm nu nv ne lq nw nx ng ny bi translated"><strong class="ak">第二步:为Swagger UI创建一个Kubernetes部署配置</strong></h2><p id="7244" class="pw-post-body-paragraph kz la it lb b lc ni ju le lf nj jx lh li nk lk ll lm nl lo lp lq nm ls lt lu im bi translated">接下来，创建K8s部署组件。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="om on l"/></div></figure><p id="896d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在Kubernetes上执行和运行部署:</p><pre class="kj kk kl km gt nz oa ob oc aw od bi"><span id="d959" class="nn mr it oa b gy oe of l og oh">$ kubectl apply -f swagger_ui_deployment.yaml</span><span id="e0ca" class="nn mr it oa b gy oi of l og oh">$ kubectl get pods --namespace=tweetor-docs<br/>NAME                             READY   STATUS    RESTARTS   AGE<br/>tweetor-docs-786d889d67-65h45   1/1     Running   0          14m</span></pre><p id="cb6e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">所以，在上面的部署中，我只使用了三个组件，<code class="fe oj ok ol oa b">Namespace</code>、<code class="fe oj ok ol oa b">Deployment</code>和<code class="fe oj ok ol oa b">Service</code>(节点端口)。最后一步是将<code class="fe oj ok ol oa b">Ingress</code>组件添加到服务中，这样每个工程师都能看到文档。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="om on l"/></div></figure><pre class="kj kk kl km gt nz oa ob oc aw od bi"><span id="3044" class="nn mr it oa b gy oe of l og oh">$ kubectl apply -f ingress_swagger_docs.yaml</span></pre><p id="9eae" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在，任何工程师都可以获得这些文档。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi oo"><img src="../Images/dfacd9edaf405b138bbc132318f66827.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*C5ScoD2IvK3m1a_qEk_xdw.png"/></div></div></figure><p id="0a9b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">* <em class="op">注意:如果您在访问API-Docs时遇到Petstore swagger，请输入您在docker文件中创建的swagger yaml名称。在我的例子中，我使用tweetor.yaml，你可以在搜索栏/explore中看到。你所有的文档都可以放在一个docker容器中。</em> <em class="op">如果有时间的话，试着在索引页中更改默认的swagger文件。</em></p><p id="f81e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">仅此而已，很简单。</p></div><div class="ab cl mj mk hx ml" role="separator"><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo"/></div><div class="im in io ip iq"><h1 id="b13e" class="mq mr it bd ms mt mu mv mw mx my mz na jz nb ka nc kc nd kd ne kf nf kg ng nh bi translated">创建一个轻量级且速度极快的模拟服务器</h1><p id="05b4" class="pw-post-body-paragraph kz la it lb b lc ni ju le lf nj jx lh li nk lk ll lm nl lo lp lq nm ls lt lu im bi translated">需要准备的工具:</p><ul class=""><li id="c693" class="lv lw it lb b lc ld lf lg li lx lm ly lq lz lu ma mb mc md bi translated"><a class="ae ky" href="https://github.com/danielgtaylor/apisprout" rel="noopener ugc nofollow" target="_blank"> API萌芽</a></li><li id="7603" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated">开放API的完整/现成安装</li><li id="8f54" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated">一个实时的、生产就绪的K8s集群(或者至少是准备就绪的)</li></ul><p id="2c81" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">另一个对软件开发有用的技巧是创建一个模拟服务器。模拟服务器是一个虚拟服务器，它代表一个真实的服务器，但是通常没有任何特定的逻辑。他们可以接受任何请求，但响应通常是静态的。</p><p id="afc6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">为什么我们需要模拟服务器？你可以在我过去的文章<a class="ae ky" href="https://toolbox.kurio.co.id/api-driven-development-in-kurio-speeding-up-the-development-process-with-open-api-3-addcc07cb9ce" rel="noopener ugc nofollow" target="_blank">这里</a>中找到更多的细节，但我将在这里简单介绍一下。</p><p id="c618" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我能想到的最简单的例子是，想象我们在两个团队之间工作，一个在后端，另一个在前端。两个队开始了相同的冲刺。通常，前端团队需要先准备好API，这样他们才能工作，但是当工作在同一个sprint上时，它将被阻塞，因为后端仍然没有实现API。这就是模拟服务器有用的时候。</p><p id="8241" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">那么，我们如何轻松地创建一个模拟服务器呢？</p><h2 id="e010" class="nn mr it bd ms no np dn mw nq nr dp na li ns nt nc lm nu nv ne lq nw nx ng ny bi translated"><strong class="ak">第一步:创建docker文件</strong></h2><p id="44bb" class="pw-post-body-paragraph kz la it lb b lc ni ju le lf nj jx lh li nk lk ll lm nl lo lp lq nm ls lt lu im bi translated">我已经有了一个活的Kubernetes集群和一个现成的<a class="ae ky" href="https://github.com/bxcodec/tweetor/blob/master/docs/openapi.yaml" rel="noopener ugc nofollow" target="_blank"> Open API 3 specs </a>副本。</p><p id="41c4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这里有一个很好的工具/库<a class="ae ky" href="https://github.com/danielgtaylor/apisprout" rel="noopener ugc nofollow" target="_blank"/>。这是一个基于开放API 3规范的简单模拟服务器生成器。代码真的很简单，是用Golang写的。如果是我先有这个想法的话，这个工具可能就是我发明的。但是，没关系，而不是重新发明轮子，我只是用在我自己的。</p><p id="bdc5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我需要做的是从它创建一个docker映像，并将我的Open API规范添加到Docker映像中。</p><p id="143f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这是我的文档:</p><pre class="kj kk kl km gt nz oa ob oc aw od bi"><span id="68e0" class="nn mr it oa b gy oe of l og oh">FROM danielgtaylor/apisprout</span><span id="8903" class="nn mr it oa b gy oi of l og oh">ADD tweetor.yaml /data/tweetor.yaml</span></pre><p id="a3ab" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">创建Docker映像并将其推送到Docker注册表:</p><pre class="kj kk kl km gt nz oa ob oc aw od bi"><span id="cda5" class="nn mr it oa b gy oe of l og oh">$ docker build -t asia.gcr.io/kube-xmas/tweetor-mock:latest .<br/>//docker build process will happen here...</span><span id="f566" class="nn mr it oa b gy oi of l og oh">$ docker push asia.gcr.io/kube-xmas/tweetor-mock:latest<br/>//docker push process will happen here...</span></pre><p id="3305" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">就这样，我们剩下的就是向Kubernetes添加一个部署文件。</p><h2 id="1e9d" class="nn mr it bd ms no np dn mw nq nr dp na li ns nt nc lm nu nv ne lq nw nx ng ny bi translated"><strong class="ak">第二步:为模拟服务器创建Kubernetes部署</strong></h2><p id="ad94" class="pw-post-body-paragraph kz la it lb b lc ni ju le lf nj jx lh li nk lk ll lm nl lo lp lq nm ls lt lu im bi translated">接下来，添加K8的部署。以下是我的部署配置:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="om on l"/></div></figure><pre class="kj kk kl km gt nz oa ob oc aw od bi"><span id="a47c" class="nn mr it oa b gy oe of l og oh">$ kubectl apply -f mock_tweetor_deployment.yaml</span></pre><p id="0cab" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">将入口添加到DNS管理后，您现在可以访问模拟服务器:</p><pre class="kj kk kl km gt nz oa ob oc aw od bi"><span id="9783" class="nn mr it oa b gy oe of l og oh">$ curl mock.tweetor.xyz/tweets<br/>[<br/>  {<br/>    "createdTime": "2018-12-24T09:21:41.827Z",<br/>    "id": "abc-f45def-5sdaf-5636f",<br/>    "text": "Merry Christmast Everyone!!!"<br/>  },<br/>  {<br/>    "createdTime": "2018-12-23T09:21:41.827Z",<br/>    "id": "abc-f45def-5sdaf-5636f",<br/>    "text": "I believe santa will give me a great present"<br/>  },<br/>  {<br/>    "createdTime": "2018-12-22T09:21:41.827Z",<br/>    "id": "abc-f45def-5sdaf-5636f",<br/>    "text": "Hello my secret santa. Thank you!!!"<br/>  }<br/>]</span></pre><p id="f702" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在，我们的前端团队将能够使用模拟API开发前端。</p></div><div class="ab cl mj mk hx ml" role="separator"><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo"/></div><div class="im in io ip iq"><h1 id="bbc2" class="mq mr it bd ms mt mu mv mw mx my mz na jz nb ka nc kc nd kd ne kf nf kg ng nh bi translated">生成HTTP SDK客户端</h1><p id="4fe6" class="pw-post-body-paragraph kz la it lb b lc ni ju le lf nj jx lh li nk lk ll lm nl lo lp lq nm ls lt lu im bi translated">需要准备的工具:</p><ul class=""><li id="717c" class="lv lw it lb b lc ld lf lg li lx lm ly lq lz lu ma mb mc md bi translated"><a class="ae ky" href="https://github.com/OpenAPITools/openapi-generator" rel="noopener ugc nofollow" target="_blank">打开API生成器</a></li><li id="4915" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated">对于高级用法，在本文中，我不会使用CI/CD。</li></ul><p id="6089" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们要讨论的最后一件事是如何利用开放API规范来帮助我们生成HTTP客户端SDK。SDK代表软件开发工具包，意思是一组库或其他可以帮助我们集成或使用一些服务或工具的东西。</p><p id="6440" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在微服务世界中，有如此多的服务在运行并处理不同的任务。每个服务都有其可能与其他服务不同的端点，但在其差异内，它们仍然具有相同的模式(我说的是RESTfull微服务)。它们使用HTTP动词(GET、POST、PUT、DELETE)和状态代码(200、201、202、400、401、403、404、500等)。</p><p id="bd87" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">每个服务可能依赖于不止一个服务，当将每个服务连接到另一个服务时，通常，程序员构建他们的函数来执行HTTP请求。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi oq"><img src="../Images/6ddae05c9005efdc9bb60e839930dcb7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*wxs1ZT5XmnWyL-_QWiWhaQ.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">服务A和B依赖于C</p></figure><p id="3094" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">以上图为例:</p><blockquote class="or os ot"><p id="728d" class="kz la op lb b lc ld ju le lf lg jx lh ou lj lk ll ov ln lo lp ow lr ls lt lu im bi translated">假设服务A和服务B连接到服务C。现在想象一个程序员从服务A手动构建连接器(REST HTTP客户端)。该程序员还从服务B构建连接器。想象还有许多服务将连接到服务C，并且所有连接器都是手动构建的。</p></blockquote><p id="4306" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在上面的例子中，我们看到一个多余的任务。如果连接器是独立的，并作为库导入到我们的项目中，会怎么样？如果我们可以自动生成连接器，而不是手动构建，会怎么样呢？</p><p id="7c02" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这就是Open API在这里的用法。以前，在Open API 3的早期版本Swagger 2中，生成HTTP客户端SDK是很常见的。但是，在Open API 3中，它仍然是新的。</p><p id="82b7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">幸运的是，这里的社区<a class="ae ky" href="https://github.com/OpenAPITools/openapi-generator" rel="noopener ugc nofollow" target="_blank"/>已经开发了一个很棒的工具。它是开源的，免费的，非常容易使用。尤其是因为它们已经支持CLI和Docker映像。</p><h2 id="a933" class="nn mr it bd ms no np dn mw nq nr dp na li ns nt nc lm nu nv ne lq nw nx ng ny bi translated"><strong class="ak">用Docker生成SDK</strong></h2><p id="591d" class="pw-post-body-paragraph kz la it lb b lc ni ju le lf nj jx lh li nk lk ll lm nl lo lp lq nm ls lt lu im bi translated">我更喜欢和Docker一起使用，因为它可以在CI/CD中使用，特别是如果CI/CD像Buddy一样支持容器化的话。同样使用Docker，我们不需要安装Java SDK，因为如果要使用CLI安装，我们需要安装Java SDK。由于我不想添加任何额外的作业，所以我只使用Docker方法。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="om on l"/></div></figure><ul class=""><li id="0a2b" class="lv lw it lb b lc ld lf lg li lx lm ly lq lz lu ma mb mc md bi translated">用你的开放API规范改变<code class="fe oj ok ol oa b">./<strong class="lb iu">tweetor.yaml</strong></code> <strong class="lb iu"> </strong>。</li><li id="90f0" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated"><code class="fe oj ok ol oa b"><strong class="lb iu">-g</strong></code> <strong class="lb iu"> : </strong>指定生成的SDK的编程语言。支持的编程语言可以在<a class="ae ky" href="https://github.com/OpenAPITools/openapi-generator#overview" rel="noopener ugc nofollow" target="_blank">这里</a>看到。在上面的例子中，我想为Golang生成一个HTTP客户端SDK。</li><li id="a87b" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated"><code class="fe oj ok ol oa b"><strong class="lb iu">-o</strong></code>:指定生成的SDK的目标文件夹。</li></ul><p id="bad2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这里先睹为快生成的HTTP客户端SDK。这是在Go中生成客户端后的一个示例文件夹结构。</p><pre class="kj kk kl km gt nz oa ob oc aw od bi"><span id="84f5" class="nn mr it oa b gy oe of l og oh">.<br/>├── README.md<br/>├── api<br/>│   └── openapi.yaml<br/>├── api_tweet.go<br/>├── client.go<br/>├── configuration.go<br/>├── docs<br/>│   ├── Tweet.md<br/>│   └── TweetApi.md<br/>├── git_push.sh<br/>├── go.mod<br/>├── go.sum<br/>├── model_tweet.go<br/>└── response.go</span></pre><p id="fa85" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我不能确切地告诉你代码是如何生成的，但是你可以自己尝试一下，看看生成的SDK。如果在许多微服务上工作，这真的很有帮助，可以帮助我们更快地开发项目。</p><p id="d17c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">但是将来，这个生成的SDK可能会有一个问题:</p><ul class=""><li id="47a3" class="lv lw it lb b lc ld lf lg li lx lm ly lq lz lu ma mb mc md bi translated"><strong class="lb iu">维护目标API的版本</strong>。因为它是一个生成的HTTP客户端SDK，可能很难处理版本控制。因此，最佳解决方案是在我们生成SDK之后，我们必须推送到git存储库，并为每个生成的SDK添加Git标签(实际上，shell脚本已经在生成的文件夹中准备好了，所以它解决了:D)。</li></ul></div><div class="ab cl mj mk hx ml" role="separator"><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo"/></div><div class="im in io ip iq"><h1 id="19ae" class="mq mr it bd ms mt mu mv mw mx my mz na jz nb ka nc kc nd kd ne kf nf kg ng nh bi translated">下一步是什么？</h1><p id="a101" class="pw-post-body-paragraph kz la it lb b lc ni ju le lf nj jx lh li nk lk ll lm nl lo lp lq nm ls lt lu im bi translated">有很多工具可能对我们有用，这些工具与Open API或Swagger相关。这里列出的工具你都能找到:<a class="ae ky" href="https://openapi.tools/" rel="noopener ugc nofollow" target="_blank"> https://openapi.tools </a>。</p><p id="f686" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">下一步是使用(您选择的)CI/CD自动化该过程，因此当工程师更新开放API规范时，它将自动更新所有API文档、模拟服务器和生成的SDK。</p><p id="15f5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">上面写的所有流程我都做了自动化流程，但是还在找合适的时机写出来。🤧🤕</p></div></div>    
</body>
</html>