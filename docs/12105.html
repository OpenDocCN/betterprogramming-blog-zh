<html>
<head>
<title>Solidity Security Enhancements: Overflows and Underflows</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">可靠性安全增强:溢出和下溢</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/solidity-security-enhancements-overflows-and-underflows-8168a42547b1?source=collection_archive---------17-----------------------#2022-05-11">https://betterprogramming.pub/solidity-security-enhancements-overflows-and-underflows-8168a42547b1?source=collection_archive---------17-----------------------#2022-05-11</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="68f2" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">我们将着眼于一个你在编写智能合约时应该注意的主要安全特性:防止溢出和下溢。</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/0b884d6022b0692edd269709f59e51f8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*GrYJwyZUGWkFRFQwydcHsw.jpeg"/></div></div></figure><p id="5bfd" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">什么是<strong class="kt ir">溢出</strong>？</p><p id="fdb0" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">假设我们有一个<code class="fe ln lo lp lq b">uint8</code>，它只能有8位。这意味着我们可以存储的最大数是二进制数<code class="fe ln lo lp lq b">11111111</code>(或者十进制数，2^8 - 1 = 255)。</p><p id="b436" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">看一下下面的代码。<code class="fe ln lo lp lq b">number</code>最后等于什么？</p><pre class="kg kh ki kj gt lr lq ls lt aw lu bi"><span id="c938" class="lv lw iq lq b gy lx ly l lz ma">uint8 number = 255;<br/>number++;</span></pre><p id="efef" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">在这种情况下，我们已经导致它溢出——因此<code class="fe ln lo lp lq b">number</code>现在违反直觉地等于<code class="fe ln lo lp lq b">0</code>,即使我们增加了它。(如果你给二进制数<code class="fe ln lo lp lq b">11111111</code>加1，它会重置回<code class="fe ln lo lp lq b">00000000</code>，就像时钟从<code class="fe ln lo lp lq b">23:59</code>到<code class="fe ln lo lp lq b">00:00</code>。</p><p id="7bac" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">下溢是类似的，如果你从等于<code class="fe ln lo lp lq b">0</code>的<code class="fe ln lo lp lq b">uint8</code>中减去<code class="fe ln lo lp lq b">1</code>，它现在将等于<code class="fe ln lo lp lq b">255</code>(因为<code class="fe ln lo lp lq b">uint</code>是无符号的，不能为负)。</p><p id="3a65" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">虽然我们在这里没有使用<code class="fe ln lo lp lq b">uint8</code>，并且每次递增<code class="fe ln lo lp lq b">1</code>时<code class="fe ln lo lp lq b">uint256</code>似乎不太可能溢出(2^256是一个非常大的数字)，但在我们的合同中加入保护措施仍然是很好的，这样我们的DApp在未来就不会有意外的行为。</p><h1 id="42b8" class="mb lw iq bd mc md me mf mg mh mi mj mk jw ml jx mm jz mn ka mo kc mp kd mq mr bi translated">使用SafeMath</h1><p id="d31d" class="pw-post-body-paragraph kr ks iq kt b ku ms jr kw kx mt ju kz la mu lc ld le mv lg lh li mw lk ll lm ij bi translated">为了防止这种情况，OpenZeppelin创建了一个名为<a class="ae mx" href="https://docs.openzeppelin.com/contracts/2.x/api/math" rel="noopener ugc nofollow" target="_blank"> SafeMath </a>的<strong class="kt ir">库</strong>，默认情况下可以防止这些问题。</p><p id="85dc" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">但是在我们进入那个之前…什么是图书馆？</p><p id="6345" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">图书馆是一种特殊的不动产合同。它的用处之一是将函数附加到本地数据类型上。</p><p id="f90e" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">例如，对于SafeMath库，我们将使用语法<code class="fe ln lo lp lq b">using SafeMath for uint256</code>。SafeMath库有4个功能— <code class="fe ln lo lp lq b">add</code>、<code class="fe ln lo lp lq b">sub</code>、<code class="fe ln lo lp lq b">mul</code>和<code class="fe ln lo lp lq b">div</code>。现在我们可以从<code class="fe ln lo lp lq b">uint256</code>访问这些功能，如下所示:</p><pre class="kg kh ki kj gt lr lq ls lt aw lu bi"><span id="b218" class="lv lw iq lq b gy lx ly l lz ma">using SafeMath for uint256;<br/><br/>uint256 a = 5;<br/>uint256 b = a.add(3); <em class="my">// 5 + 3 = 8</em><br/>uint256 c = a.mul(2); <em class="my">// 5 * 2 = 10</em></span></pre><p id="4f2d" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">我们很快就会看到这些函数的作用。</p><h1 id="434c" class="mb lw iq bd mc md me mf mg mh mi mj mk jw ml jx mm jz mn ka mo kc mp kd mq mr bi translated">让我们来看看SafeMath背后的代码:</h1><pre class="kg kh ki kj gt lr lq ls lt aw lu bi"><span id="6257" class="lv lw iq lq b gy lx ly l lz ma">library SafeMath {<br/><br/>  function mul(uint256 a, uint256 b) internal pure returns (uint256) {<br/>    if (a == 0) {<br/>      return 0;<br/>    }<br/>    uint256 c = a * b;<br/>    assert(c / a == b);<br/>    return c;<br/>  }<br/><br/>  function div(uint256 a, uint256 b) internal pure returns (uint256) {<br/>    <em class="my">// assert(b &gt; 0); // Solidity automatically throws when dividing by 0</em><br/>    uint256 c = a / b;<br/>    <em class="my">// assert(a == b * c + a % b); // There is no case in which this doesn't hold</em><br/>    return c;<br/>  }<br/><br/>  function sub(uint256 a, uint256 b) internal pure returns (uint256) {<br/>    assert(b &lt;= a);<br/>    return a - b;<br/>  }<br/><br/>  function add(uint256 a, uint256 b) internal pure returns (uint256) {<br/>    uint256 c = a + b;<br/>    assert(c &gt;= a);<br/>    return c;<br/>  }<br/>}</span></pre><p id="0423" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">首先我们有关键字<code class="fe ln lo lp lq b">library</code>——库与<code class="fe ln lo lp lq b">contract</code>相似，但是有一些不同。出于我们的目的，库允许我们使用<code class="fe ln lo lp lq b">using</code>关键字，它会自动将库的所有方法附加到另一种数据类型上:</p><pre class="kg kh ki kj gt lr lq ls lt aw lu bi"><span id="625c" class="lv lw iq lq b gy lx ly l lz ma">using SafeMath for uint;<br/>// now we can use these methods on any uint<br/>uint test = 2;<br/>test = test.mul(3); // test now equals 6<br/>test = test.add(5); // test now equals 11</span></pre><p id="5d80" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">注意，<code class="fe ln lo lp lq b">mul</code>和<code class="fe ln lo lp lq b">add</code>函数每个都需要2个参数，但是当我们声明<code class="fe ln lo lp lq b">using SafeMath for uint</code>时，我们调用on ( <code class="fe ln lo lp lq b">test</code>)函数的<code class="fe ln lo lp lq b">uint</code>会自动作为第一个参数传入。</p><p id="2c5b" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">让我们看看<code class="fe ln lo lp lq b">add</code>背后的代码，看看SafeMath做了什么:</p><pre class="kg kh ki kj gt lr lq ls lt aw lu bi"><span id="c4ac" class="lv lw iq lq b gy lx ly l lz ma">function add(uint256 a, uint256 b) internal pure returns (uint256) {<br/>  uint256 c = a + b;<br/>  assert(c &gt;= a);<br/>  return c;<br/>}</span></pre><p id="8bb3" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">基本上<code class="fe ln lo lp lq b">add</code>只是像<code class="fe ln lo lp lq b">+</code>一样加了2个<code class="fe ln lo lp lq b">uint</code>，但是它也包含了一个<code class="fe ln lo lp lq b">assert</code>语句来确保总和大于<code class="fe ln lo lp lq b">a</code>。这保护我们免受溢出。</p><p id="27c1" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated"><code class="fe ln lo lp lq b">assert</code>类似于<code class="fe ln lo lp lq b">require</code>，如果为假，将抛出错误。<code class="fe ln lo lp lq b">assert</code>和<code class="fe ln lo lp lq b">require</code>的区别在于<code class="fe ln lo lp lq b">require</code>会在功能失效时退还用户剩余的汽油，而<code class="fe ln lo lp lq b">assert</code>不会。所以大多数时候你想在代码中使用<code class="fe ln lo lp lq b">require</code>；<code class="fe ln lo lp lq b">assert</code>通常在代码出现严重错误时使用(比如<code class="fe ln lo lp lq b">uint</code>溢出)。</p><p id="cc8c" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">因此，简单地说，SafeMath的<code class="fe ln lo lp lq b">add</code>、<code class="fe ln lo lp lq b">sub</code>、<code class="fe ln lo lp lq b">mul</code>和<code class="fe ln lo lp lq b">div</code>是进行基本的4种数学运算的函数，但是如果发生上溢或下溢，就会抛出错误。</p><h1 id="e48f" class="mb lw iq bd mc md me mf mg mh mi mj mk jw ml jx mm jz mn ka mo kc mp kd mq mr bi translated">在代码中使用SafeMath。</h1><p id="524f" class="pw-post-body-paragraph kr ks iq kt b ku ms jr kw kx mt ju kz la mu lc ld le mv lg lh li mw lk ll lm ij bi translated">为了防止溢出和下溢，我们可以在代码中寻找使用<code class="fe ln lo lp lq b">+</code>、<code class="fe ln lo lp lq b">-</code>、<code class="fe ln lo lp lq b">*</code>或<code class="fe ln lo lp lq b">/</code>的地方，并用<code class="fe ln lo lp lq b">add</code>、<code class="fe ln lo lp lq b">sub</code>、<code class="fe ln lo lp lq b">mul</code>、<code class="fe ln lo lp lq b">div</code>替换它们。</p></div></div>    
</body>
</html>