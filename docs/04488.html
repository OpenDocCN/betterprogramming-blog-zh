<html>
<head>
<title>Don’t Fret With Git Rebase</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">不要为Git Rebase烦恼</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/dont-fret-with-git-rebase-75fe3ed5ca8f?source=collection_archive---------0-----------------------#2020-04-16">https://betterprogramming.pub/dont-fret-with-git-rebase-75fe3ed5ca8f?source=collection_archive---------0-----------------------#2020-04-16</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="f88f" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">无论你的队友会告诉你什么，重新构建Git分支都是一件轻而易举的事情</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/f364f99cb49801ec5f1fd7647ae096f9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*lcikom2XRzi0tV7902AzCg.jpeg"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated"><a class="ae ky" href="https://unsplash.com/@yancymin?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Yancy Min </a>在<a class="ae ky" href="https://unsplash.com/?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍照。</p></figure><p id="8b71" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果你熟悉Git，你可能听说过<a class="ae ky" href="https://git-scm.com/docs/git-rebase" rel="noopener ugc nofollow" target="_blank"> Git rebase </a>。这个强大的命令允许您将Git分支附加到Git树上的任何位置。</p><p id="5d97" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">但是，我经常听说开发人员对这个命令不屑一顾。相反，他们更喜欢Git merge——一种更安全但有限的处理分支历史的方法。</p><p id="4399" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们首先用一个简单的例子来说明它们之间的区别。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="fc3d" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">合并与重设基础</h1><p id="bdf7" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">假设你有一个基础分支叫做<code class="fe mz na nb nc b">develop</code>。想象你从<code class="fe mz na nb nc b">develop</code> <em class="nd"> </em>创建一个分支叫做<em class="nd"> </em> <code class="fe mz na nb nc b">awesome_branch</code>。与此同时，有人提交了<code class="fe mz na nb nc b">develop</code>。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ne"><img src="../Images/ad6bd74409bc46bf84964542243234d3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*dry4h36efp-gxBA_84Romw.png"/></div></div></figure><p id="d6bd" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">当您想要将<code class="fe mz na nb nc b">awesome_branch</code>合并到<code class="fe mz na nb nc b">develop</code>时，您会发现您的分支落后于一个提交。您可以:</p><ul class=""><li id="2bda" class="nf ng it lb b lc ld lf lg li nh lm ni lq nj lu nk nl nm nn bi translated">将<code class="fe mz na nb nc b">develop</code>合并成<code class="fe mz na nb nc b">awesome_branch</code>。</li><li id="ea9a" class="nf ng it lb b lc no lf np li nq lm nr lq ns lu nk nl nm nn bi translated">在<code class="fe mz na nb nc b">develop</code>上重设<code class="fe mz na nb nc b">awesome_branch</code>的基础。</li></ul><p id="4cb9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">合并将融合两个分支的内容，让您一次处理所有冲突，并产生一个合并提交(下图顶部的<code class="fe mz na nb nc b">1f9884f</code>提交散列)。</p><p id="6223" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">另一方面，Rebasing将拔出所有的提交，将它们一个接一个地应用到目标分支中(从底部图的<code class="fe mz na nb nc b">b18ac2f</code>提交散列中)。如果Git在特定的提交上检测到冲突，rebase将暂停，直到您解决它。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nt"><img src="../Images/a88e99ae147c12fa7753fe0c9efde5db.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*f7ckeEAzbAyR171XOO8Q7w.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">合并</p></figure><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nu"><img src="../Images/6e877d4b4077b71979cc5d4b945d9cfe.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*kYFfdAq1X--w2PKY8BTbqg.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">重定…的基准</p></figure><p id="33dc" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">最终，merge和rebase都能完美地工作，并产生一个稍微不同的树。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="7981" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">有什么大惊小怪的？</h1><p id="321d" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">作为一名开发人员，您会有因为一个错误的Git策略而不得不挽救局面的时候。我不得不挣扎几次才明白发生了什么，哪里出了问题。即使当我在一个相对较小的团队中工作时——大约有7名开发人员——我也可能有几十个并行的分支。有些可能与其他的交织在一起，使得阅读更加困难。</p><p id="99de" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">通过使用Git rebase，您可能已经注意到我们保存了一个桥和一个合并提交。即使是一个简单的例子，正确的树也因其最佳显示而脱颖而出。如上所述，同时拥有多个分支会使你的工作更加困难。它强调了拥有一棵紧凑的树是多么重要。</p><p id="b7d9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">保持线性树简化了版本控制。</p><p id="5895" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果你对如何进一步清理你的Git树感兴趣，我鼓励你阅读“<a class="ae ky" href="https://medium.com/better-programming/from-messy-to-beauty-with-git-rebase-2d2e9ec6070f" rel="noopener">用Git Rebase </a>从凌乱到美丽”。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="eeec" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">成为Rebase向导</h1><p id="d494" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">首先你要明白Git rebase是一个破坏性的操作。Git根据您之前对目标分支的提交生成新的提交。因此，你以前的承诺将被销毁。基本上，你重写你的Git历史！</p><p id="3ef3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">只需遵循以下步骤:</p><ol class=""><li id="b8f3" class="nf ng it lb b lc ld lf lg li nh lm ni lq nj lu nv nl nm nn bi translated">检查出你的分行，你想重新基地。</li><li id="1c03" class="nf ng it lb b lc no lf np li nq lm nr lq ns lu nv nl nm nn bi translated">更新您的本地存储库。</li><li id="13a8" class="nf ng it lb b lc no lf np li nq lm nr lq ns lu nv nl nm nn bi translated">将您的分支重置到所需的分支上。</li><li id="3c57" class="nf ng it lb b lc no lf np li nq lm nr lq ns lu nv nl nm nn bi translated">修复潜在的冲突。</li><li id="39ce" class="nf ng it lb b lc no lf np li nq lm nr lq ns lu nv nl nm nn bi translated">确保您的树是正确的。</li><li id="0e11" class="nf ng it lb b lc no lf np li nq lm nr lq ns lu nv nl nm nn bi translated">推动您当地的分公司</li></ol><p id="1148" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们抽出魔杖，把东西打碎吧！</p><h2 id="8fdd" class="nw md it bd me nx ny dn mi nz oa dp mm li ob oc mo lm od oe mq lq of og ms oh bi translated">1.看看你的分行</h2><p id="fc5b" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">您可以选择跳过这一步，因为您可以从任何地方重新确定任何分支的基础。为了清楚起见，我们还是这么做吧:</p><pre class="kj kk kl km gt oi nc oj ok aw ol bi"><span id="c04e" class="nw md it nc b gy om on l oo op">$ git checkout feature/awesome_branch</span></pre><h2 id="6206" class="nw md it bd me nx ny dn mi nz oa dp mm li ob oc mo lm od oe mq lq of og ms oh bi translated">2.更新您的本地存储库</h2><p id="bdba" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">可能是最受关注的一步。假设有人在<code class="fe mz na nb nc b">develop</code>、<em class="nd">和</em>提交了新的提交，忘记这一步将导致对一个过时的分支重新定基。更糟糕的是，重定基数本身看起来会运行良好。您将忽略来自目标分支的最新提交。</p><p id="35fd" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">人们通常无法重定他们的分支，因为他们没有同步他们的本地库。</p><p id="c771" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">事不宜迟，只需获取您的所有分支:</p><pre class="kj kk kl km gt oi nc oj ok aw ol bi"><span id="2130" class="nw md it nc b gy om on l oo op">$ git fetch --all</span></pre><h2 id="6540" class="nw md it bd me nx ny dn mi nz oa dp mm li ob oc mo lm od oe mq lq of og ms oh bi translated">3.重定你的分行</h2><p id="bb22" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">一个经验法则:总是根据你的远程分支机构调整基准。因为您已经获取了所有的分支，所以您已经确保了所有的远程分支都是最新的。</p><pre class="kj kk kl km gt oi nc oj ok aw ol bi"><span id="8eba" class="nw md it nc b gy om on l oo op">$ git rebase origin/develop</span></pre><h2 id="9d8d" class="nw md it bd me nx ny dn mi nz oa dp mm li ob oc mo lm od oe mq lq of og ms oh bi translated">4.解决你们的冲突</h2><p id="979f" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">不可避免地，你会有冲突。当发生这种情况时，rebase将在每次与目标分支冲突的提交时停止。您可以:</p><pre class="kj kk kl km gt oi nc oj ok aw ol bi"><span id="f265" class="nw md it nc b gy om on l oo op">$ git rebase --continue // proceed the execution<br/>$ git rebase --skip     // ignore this conflict<br/>$ git rebase --abort    // cancel the operation</span></pre><h2 id="acf4" class="nw md it bd me nx ny dn mi nz oa dp mm li ob oc mo lm od oe mq lq of og ms oh bi translated">5.检查你的Git树</h2><p id="6cab" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">这是我们在犯潜在错误前的最后一道防线。花几秒钟来确保你的圣诞树看起来不错。它可以避免您丢失宝贵的提交！</p><h2 id="a75a" class="nw md it bd me nx ny dn mi nz oa dp mm li ob oc mo lm od oe mq lq of og ms oh bi translated">6.推动您当地的分公司</h2><p id="f572" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">我们终于准备好推动我们的本地分支机构:</p><pre class="kj kk kl km gt oi nc oj ok aw ol bi"><span id="818c" class="nw md it nc b gy om on l oo op">$ git push --force</span></pre><p id="39e8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">因为你重写了你的Git历史，Git强迫你使用<code class="fe mz na nb nc b">— force</code> <strong class="lb iu"> </strong>选项。在使用这个命令之前，确保检查您的Git树！</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="18f8" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">包扎</h1><p id="5166" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">我们来总结一下如何重基。如果你很懒(像我一样)，用<a class="ae ky" href="https://github.com/ohmyzsh/ohmyzsh/wiki/Cheatsheet" rel="noopener ugc nofollow" target="_blank"> ohmyzsh </a>利用Git别名:</p><pre class="kj kk kl km gt oi nc oj ok aw ol bi"><span id="be91" class="nw md it nc b gy om on l oo op">$ gco awesome_branch  // checkout your branch<br/>$ gfa                 // fetch all your branches<br/>$ grb origin/develop  // start rebase your branch onto develop<br/>$ gp -f               // push force your local branch</span></pre><p id="9612" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">就这些了，伙计们！我希望您使用这个命令会更有信心。</p><p id="9b41" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果您想进一步了解Git rebase，请随意阅读我的其他文章。</p><div class="oq or gp gr os ot"><a href="https://medium.com/better-programming/git-rebase-for-nested-branches-7a6bbb4a6688" rel="noopener follow" target="_blank"><div class="ou ab fo"><div class="ov ab ow cl cj ox"><h2 class="bd iu gy z fp oy fr fs oz fu fw is bi translated">Git Rebase如何让我失望</h2><div class="pa l"><h3 class="bd b gy z fp oy fr fs oz fu fw dk translated">如果重置基础变得乏味，你可能做错了</h3></div><div class="pb l"><p class="bd b dl z fp oy fr fs oz fu fw dk translated">medium.com</p></div></div><div class="pc l"><div class="pd l pe pf pg pc ph ks ot"/></div></div></a></div><div class="oq or gp gr os ot"><a href="https://medium.com/better-programming/from-messy-to-beauty-with-git-rebase-2d2e9ec6070f" rel="noopener follow" target="_blank"><div class="ou ab fo"><div class="ov ab ow cl cj ox"><h2 class="bd iu gy z fp oy fr fs oz fu fw is bi translated">用Git Rebase从凌乱到美丽</h2><div class="pa l"><h3 class="bd b gy z fp oy fr fs oz fu fw dk translated">用交互式基础绘制整齐的树</h3></div><div class="pb l"><p class="bd b dl z fp oy fr fs oz fu fw dk translated">medium.com</p></div></div><div class="pc l"><div class="pi l pe pf pg pc ph ks ot"/></div></div></a></div></div></div>    
</body>
</html>