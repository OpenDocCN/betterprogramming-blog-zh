<html>
<head>
<title>How to Use Coil, Kotlin First Image Loader</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何使用Coil，Kotlin第一图像加载器</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/how-to-use-coil-kotlins-native-image-loader-d6715dda7d26?source=collection_archive---------2-----------------------#2020-05-14">https://betterprogramming.pub/how-to-use-coil-kotlins-native-image-loader-d6715dda7d26?source=collection_archive---------2-----------------------#2020-05-14</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="ef15" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">Android上更好的图像加载</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/2340d22ca17ad6f6c77c901e8ec766e5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*aIirdflusJbFiySf"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">阿诺德·弗朗西斯卡在<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的照片</p></figure></div><div class="ab cl kz la hx lb" role="separator"><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le"/></div><div class="im in io ip iq"><h1 id="8f29" class="lg lh it bd li lj lk ll lm ln lo lp lq jz lr ka ls kc lt kd lu kf lv kg lw lx bi translated">这篇文章的要点</h1><p id="f23e" class="pw-post-body-paragraph ly lz it ma b mb mc ju md me mf jx mg mh mi mj mk ml mm mn mo mp mq mr ms mt im bi translated">在本文结束时，您将学习如何使用Instacart团队的新图像加载器。除了一般用法，您还可以获得关于Coil的转换、请求取消和图像采样特性的知识。最后但同样重要的是，有一个从格莱德和毕加索到线圈的迁移指南。</p></div><div class="ab cl kz la hx lb" role="separator"><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le"/></div><div class="im in io ip iq"><h1 id="7db5" class="lg lh it bd li lj lk ll lm ln lo lp lq jz lr ka ls kc lt kd lu kf lv kg lw lx bi translated">介绍</h1><p id="df1b" class="pw-post-body-paragraph ly lz it ma b mb mc ju md me mf jx mg mh mi mj mk ml mm mn mo mp mq mr ms mt im bi translated"><a class="ae ky" href="https://coil-kt.github.io/coil/" rel="noopener ugc nofollow" target="_blank"> Coil </a>是来自Instacart团队的新图像加载器，使用了许多高级功能，如coroutines、OkHttp和<code class="fe mu mv mw mx b">androidX.lifecycle</code>s。Coil为您的APK添加了大约1500个功能，与<a class="ae ky" href="https://square.github.io/picasso/" rel="noopener ugc nofollow" target="_blank"> Picasso </a>相当，比<a class="ae ky" href="https://bumptech.github.io/glide/" rel="noopener ugc nofollow" target="_blank"> Glide </a>和<a class="ae ky" href="https://frescolib.org/" rel="noopener ugc nofollow" target="_blank"> Fresco </a>要少。Coil还包括几个高级特性，如图像采样、有效的内存使用和自动取消/暂停请求。</p><p id="283f" class="pw-post-body-paragraph ly lz it ma b mb my ju md me mz jx mg mh na mj mk ml nb mn mo mp nc mr ms mt im bi translated">默认情况下，Coil完全兼容R8优化技术，因此开发人员无需添加任何与Coil相关的ProGuard规则。</p></div><div class="ab cl kz la hx lb" role="separator"><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le"/></div><div class="im in io ip iq"><h1 id="5549" class="lg lh it bd li lj lk ll lm ln lo lp lq jz lr ka ls kc lt kd lu kf lv kg lw lx bi translated">综合</h1><p id="5806" class="pw-post-body-paragraph ly lz it ma b mb mc ju md me mf jx mg mh mi mj mk ml mm mn mo mp mq mr ms mt im bi translated">Coil需要Java 8字节代码，所以在您的<code class="fe mu mv mw mx b">build.gradle</code>文件中添加以下几行来使它工作。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nd ne l"/></div></figure><p id="56f5" class="pw-post-body-paragraph ly lz it ma b mb my ju md me mz jx mg mh na mj mk ml nb mn mo mp nc mr ms mt im bi translated">线圈有四个工件；各有各的用途。但我们主要使用以下两种:</p><ol class=""><li id="5f3b" class="nf ng it ma b mb my me mz mh nh ml ni mp nj mt nk nl nm nn bi translated"><code class="fe mu mv mw mx b">io.coil-kt: Coil</code>:默认工件，有<code class="fe mu mv mw mx b">Coil </code>单例。如果您没有使用依赖注入或者在应用程序中维护任何Coil实例，那么最好使用这个构件。</li><li id="6784" class="nf ng it ma b mb no me np mh nq ml nr mp ns mt nk nl nm nn bi translated"><code class="fe mu mv mw mx b">io.coil-kt:coil-base</code>:基础神器，<strong class="ma iu">不</strong>包含<code class="fe mu mv mw mx b">Coil</code>单体。如果您使用依赖注入来注入线圈实例，那么最好使用这个工件。</li></ol><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nd ne l"/></div></figure></div><div class="ab cl kz la hx lb" role="separator"><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le"/></div><div class="im in io ip iq"><h1 id="7095" class="lg lh it bd li lj lk ll lm ln lo lp lq jz lr ka ls kc lt kd lu kf lv kg lw lx bi translated">功能</h1><p id="c3a0" class="pw-post-body-paragraph ly lz it ma b mb mc ju md me mf jx mg mh mi mj mk ml mm mn mo mp mq mr ms mt im bi translated">既然我们已经成功地集成了库，是时候让Coil投入使用了。让我们从加载一个简单的远程映像开始。看一看:</p><pre class="kj kk kl km gt nt mx nu nv aw nw bi"><span id="9dcb" class="nx lh it mx b gy ny nz l oa ob">imageView.<strong class="mx iu">load</strong>("https://www.example.com/image.jpg")</span></pre><p id="a9ba" class="pw-post-body-paragraph ly lz it ma b mb my ju md me mz jx mg mh na mj mk ml nb mn mo mp nc mr ms mt im bi translated">由于Coil是Kotlin开发的第一个图像加载器，它利用了许多高级特性，其中之一就是扩展。<code class="fe mu mv mw mx b">load </code>是来自Coil的一个<code class="fe mu mv mw mx b">extension </code>函数，这使得加载远程镜像比任何其他库都简单。</p><p id="248d" class="pw-post-body-paragraph ly lz it ma b mb my ju md me mz jx mg mh na mj mk ml nb mn mo mp nc mr ms mt im bi translated">有了<code class="fe mu mv mw mx b">load </code>扩展，Coil节省了我们传递上下文和创建<code class="fe mu mv mw mx b">imageloader</code>实例的时间。看看线圈的延伸部分:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nd ne l"/></div></figure><p id="b99b" class="pw-post-body-paragraph ly lz it ma b mb my ju md me mz jx mg mh na mj mk ml nb mn mo mp nc mr ms mt im bi translated">它利用了从<code class="fe mu mv mw mx b">imageView </code>获取上下文并创建线圈加载器的杠杆作用。这就是为什么本地语言库更好的原因。</p><h2 id="8d0a" class="nx lh it bd li oc od dn lm oe of dp lq mh og oh ls ml oi oj lu mp ok ol lw om bi translated">占位符和错误图像</h2><p id="2d14" class="pw-post-body-paragraph ly lz it ma b mb mc ju md me mf jx mg mh mi mj mk ml mm mn mo mp mq mr ms mt im bi translated">几乎所有像Glide、Picasso和Fresco这样的库都有这个特性——在原始图像载入视图之前显示一个虚拟图像(占位符),如果请求失败则显示一个错误图像(错误)。Coil也有开箱即用的特性，令人兴奋的部分是语法:实现它们更多地是沉浸在语言语法中，如Kotlin中的<code class="fe mu mv mw mx b">let</code>和<code class="fe mu mv mw mx b">apply </code>特性。看一看:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nd ne l"/></div></figure><h2 id="6613" class="nx lh it bd li oc od dn lm oe of dp lq mh og oh ls ml oi oj lu mp ok ol lw om bi translated">预加载图像</h2><p id="2117" class="pw-post-body-paragraph ly lz it ma b mb mc ju md me mf jx mg mh mi mj mk ml mm mn mo mp mq mr ms mt im bi translated">Coil利用协程更有效地下载图像。我们可以使用<code class="fe mu mv mw mx b">get</code>暂停功能下载远程图像。看一看:</p><pre class="kj kk kl km gt nt mx nu nv aw nw bi"><span id="3f2c" class="nx lh it mx b gy ny nz l oa ob">val image = Coil.<strong class="mx iu">get</strong>(imageUrl)</span></pre><p id="3ac8" class="pw-post-body-paragraph ly lz it ma b mb my ju md me mz jx mg mh na mj mk ml nb mn mo mp nc mr ms mt im bi translated">通过<code class="fe mu mv mw mx b">get</code>暂停功能，我们可以下载一个远程镜像作为<code class="fe mu mv mw mx b">drawable</code>。</p><h2 id="fdbb" class="nx lh it bd li oc od dn lm oe of dp lq mh og oh ls ml oi oj lu mp ok ol lw om bi translated">复试</h2><p id="01d9" class="pw-post-body-paragraph ly lz it ma b mb mc ju md me mf jx mg mh mi mj mk ml mm mn mo mp mq mr ms mt im bi translated">在某些情况下，您需要在下载远程映像后进行回调。线圈用<code class="fe mu mv mw mx b">targets</code>功能盖住它。看一看:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nd ne l"/></div></figure><p id="02d7" class="pw-post-body-paragraph ly lz it ma b mb my ju md me mz jx mg mh na mj mk ml nb mn mo mp nc mr ms mt im bi translated">有三种类型的目标:<code class="fe mu mv mw mx b">Target</code>、<code class="fe mu mv mw mx b">ViewTarget</code>和<code class="fe mu mv mw mx b">possibleViewTarget</code>。</p><ul class=""><li id="89df" class="nf ng it ma b mb my me mz mh nh ml ni mp nj mt on nl nm nn bi translated"><code class="fe mu mv mw mx b">Target </code>在请求没有链接到任何视图时使用。</li><li id="78b9" class="nf ng it ma b mb no me np mh nq ml nr mp ns mt on nl nm nn bi translated">当请求链接到一个<code class="fe mu mv mw mx b">imageview</code>时，使用<code class="fe mu mv mw mx b">ViewTarget </code>，比如显示一个占位符，直到请求完成。</li><li id="c205" class="nf ng it ma b mb no me np mh nq ml nr mp ns mt on nl nm nn bi translated">如果需要位图池，使用<code class="fe mu mv mw mx b">possibleViewTarget </code>。</li></ul></div><div class="ab cl kz la hx lb" role="separator"><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le"/></div><div class="im in io ip iq"><h1 id="8b35" class="lg lh it bd li lj lk ll lm ln lo lp lq jz lr ka ls kc lt kd lu kf lv kg lw lx bi translated">转换</h1><p id="26ca" class="pw-post-body-paragraph ly lz it ma b mb mc ju md me mf jx mg mh mi mj mk ml mm mn mo mp mq mr ms mt im bi translated">现在我们已经完成了来自Coil的不同类型的图像加载技术，是时候探索转换了。变换是任何图像加载器都应该包含的一个方便的功能。开箱即用，线圈自带四种变换:<a class="ae ky" href="https://coil-kt.github.io/coil/api/coil-base/coil.transform/-blur-transformation/" rel="noopener ugc nofollow" target="_blank">模糊</a>、<a class="ae ky" href="https://coil-kt.github.io/coil/api/coil-base/coil.transform/-circle-crop-transformation/" rel="noopener ugc nofollow" target="_blank">圆形裁剪</a>、<a class="ae ky" href="https://coil-kt.github.io/coil/api/coil-base/coil.transform/-grayscale-transformation/" rel="noopener ugc nofollow" target="_blank">灰度</a>、<a class="ae ky" href="https://coil-kt.github.io/coil/api/coil-base/coil.transform/-rounded-corners-transformation/" rel="noopener ugc nofollow" target="_blank">圆角</a>。下面的代码演示了用法:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nd ne l"/></div></figure></div><div class="ab cl kz la hx lb" role="separator"><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le"/></div><div class="im in io ip iq"><h1 id="6e42" class="lg lh it bd li lj lk ll lm ln lo lp lq jz lr ka ls kc lt kd lu kf lv kg lw lx bi translated">取消请求</h1><p id="4842" class="pw-post-body-paragraph ly lz it ma b mb mc ju md me mf jx mg mh mi mj mk ml mm mn mo mp mq mr ms mt im bi translated">有效利用资源是应用程序性能的关键。默认情况下，当<code class="fe mu mv mw mx b">imageview</code>被分离，或者上下文被破坏，或者另一个请求被视图启动时，Coil会取消请求。默认情况下，Coil涵盖了所有内存泄漏的情况，但是当您想要取消请求时会出现这种情况。为此，Coil为每个加载请求返回<code class="fe mu mv mw mx b"><a class="ae ky" href="https://coil-kt.github.io/coil/api/coil-base/coil.request/-request-disposable" rel="noopener ugc nofollow" target="_blank">RequestDisposable</a></code>，通过它您可以取消请求。看一看:</p><pre class="kj kk kl km gt nt mx nu nv aw nw bi"><span id="366c" class="nx lh it mx b gy ny nz l oa ob">val <strong class="mx iu">disposable </strong>= imageView.<strong class="mx iu">load</strong>("https://www.example.com/image.jpg")<br/><br/>// Cancel the request.<br/>disposable.<strong class="mx iu">dispose</strong>()</span></pre></div><div class="ab cl kz la hx lb" role="separator"><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le"/></div><div class="im in io ip iq"><h1 id="eb99" class="lg lh it bd li lj lk ll lm ln lo lp lq jz lr ka ls kc lt kd lu kf lv kg lw lx bi translated">图像采样</h1><p id="4af8" class="pw-post-body-paragraph ly lz it ma b mb mc ju md me mf jx mg mh mi mj mk ml mm mn mo mp mq mr ms mt im bi translated">图像采样是最先进的技术，用于根据<code class="fe mu mv mw mx b">imageview</code>的大小加载高质量的图像。假设磁盘上有一个大小为500 x 500的图像。最初，线圈加载100 x 100，并将其用作占位符，直到加载全部质量。它作为一个<a class="ae ky" href="https://www.liquidweb.com/kb/what-is-a-progressive-jpeg/" rel="noopener ugc nofollow" target="_blank">渐进JPEG </a>工作。我们可以在通过<code class="fe mu mv mw mx b">crossfade</code>功能加载来自Coil的任何<code class="fe mu mv mw mx b">imageloader</code>请求时启用此功能。看一看:</p><pre class="kj kk kl km gt nt mx nu nv aw nw bi"><span id="d1e2" class="nx lh it mx b gy ny nz l oa ob">imageView.<strong class="mx iu">load</strong>(imageUrl)<strong class="mx iu">{<br/>    crossfade</strong>(true)<br/><strong class="mx iu">}</strong></span></pre></div><div class="ab cl kz la hx lb" role="separator"><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le"/></div><div class="im in io ip iq"><h1 id="f248" class="lg lh it bd li lj lk ll lm ln lo lp lq jz lr ka ls kc lt kd lu kf lv kg lw lx bi translated">从格莱德/毕加索的迁移</h1><p id="1f01" class="pw-post-body-paragraph ly lz it ma b mb mc ju md me mf jx mg mh mi mj mk ml mm mn mo mp mq mr ms mt im bi translated">线圈是一个易于使用的Kotlin原生图像加载器。它涵盖了所有的基本和高级用法，并通过扩展使其对开发人员来说更简单。现在，让我们比较Glide、Picasso和Coil之间的图像加载代码。</p><h2 id="6dcd" class="nx lh it bd li oc od dn lm oe of dp lq mh og oh ls ml oi oj lu mp ok ol lw om bi translated">基本用法:</h2><pre class="kj kk kl km gt nt mx nu nv aw nw bi"><span id="f762" class="nx lh it mx b gy ny nz l oa ob">// Glide<br/><strong class="mx iu">Glide</strong>.with(context)<br/>    .load(url)<br/>    .into(imageView)<br/><br/>// Picasso<br/><strong class="mx iu">Picasso</strong>.get()<br/>    .load(url)<br/>    .into(imageView)<br/><br/>// Coil<br/>imageView.<strong class="mx iu">load</strong>(url)</span></pre><h2 id="e05a" class="nx lh it bd li oc od dn lm oe of dp lq mh og oh ls ml oi oj lu mp ok ol lw om bi translated">回拨请求</h2><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nd ne l"/></div></figure><h2 id="39a4" class="nx lh it bd li oc od dn lm oe of dp lq mh og oh ls ml oi oj lu mp ok ol lw om bi translated">自定义请求</h2><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nd ne l"/></div></figure></div><div class="ab cl kz la hx lb" role="separator"><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le"/></div><div class="im in io ip iq"><h1 id="5d51" class="lg lh it bd li lj lk ll lm ln lo lp lq jz lr ka ls kc lt kd lu kf lv kg lw lx bi translated">奖金</h1><p id="9bc2" class="pw-post-body-paragraph ly lz it ma b mb mc ju md me mf jx mg mh mi mj mk ml mm mn mo mp mq mr ms mt im bi translated">要了解更多关于Kotlin的信息，请阅读Kotlin高级编程系列的前几部分:</p><ul class=""><li id="2acf" class="nf ng it ma b mb my me mz mh nh ml ni mp nj mt on nl nm nn bi translated"><a class="ae ky" href="https://medium.com/better-programming/advanced-android-programming-with-kotlin-5e40b1be22bb" rel="noopener">“使用Kotlin进行高级编程</a></li><li id="e06f" class="nf ng it ma b mb no me np mh nq ml nr mp ns mt on nl nm nn bi translated"><a class="ae ky" href="https://medium.com/android-dev-hacks/advanced-android-programming-with-kotlin-part-2-aae2a15258b0" rel="noopener">“使用Kotlin进行高级编程—第二部分</a>”</li><li id="6007" class="nf ng it ma b mb no me np mh nq ml nr mp ns mt on nl nm nn bi translated"><a class="ae ky" href="https://medium.com/better-programming/advanced-programming-in-kotlin-2e01fbc39134" rel="noopener">“用Kotlin进行高级编程—第三部分</a>”</li><li id="97d1" class="nf ng it ma b mb no me np mh nq ml nr mp ns mt on nl nm nn bi translated"><a class="ae ky" href="https://medium.com/better-programming/advanced-android-programing-in-kotlin-part-4-187b88fea048" rel="noopener">“kot Lin中的高级Android编程—第四部分”</a></li></ul><p id="774a" class="pw-post-body-paragraph ly lz it ma b mb my ju md me mz jx mg mh na mj mk ml nb mn mo mp nc mr ms mt im bi translated">要了解更多关于Kotlin协同例程和Kotlin的其他高级特性，请阅读以下文章:</p><ul class=""><li id="2fc5" class="nf ng it ma b mb my me mz mh nh ml ni mp nj mt on nl nm nn bi translated"><a class="ae ky" href="https://medium.com/better-programming/kotlin-coroutines-from-basics-to-advanced-ad3eb1421006" rel="noopener">“科特林协程，从基础到高级</a>”</li><li id="5499" class="nf ng it ma b mb no me np mh nq ml nr mp ns mt on nl nm nn bi translated"><a class="ae ky" href="https://medium.com/better-programming/how-to-use-kotlin-sealed-classes-for-state-management-c1cfb81abc6a" rel="noopener">“如何使用Kotlin密封类进行状态管理”</a></li><li id="6b14" class="nf ng it ma b mb no me np mh nq ml nr mp ns mt on nl nm nn bi translated"><a class="ae ky" href="https://medium.com/better-programming/asynchronous-data-loading-with-new-kotlin-flow-233f85ae1d8b" rel="noopener">“使用新Kotlin流进行异步数据加载</a></li><li id="0722" class="nf ng it ma b mb no me np mh nq ml nr mp ns mt on nl nm nn bi translated"><a class="ae ky" href="https://medium.com/better-programming/exploring-collections-and-sequences-in-kotlin-3a324ea08fb9" rel="noopener">“探索Kotlin中的集合和序列”</a></li><li id="67e7" class="nf ng it ma b mb no me np mh nq ml nr mp ns mt on nl nm nn bi translated"><a class="ae ky" href="https://medium.com/better-programming/why-and-how-to-use-kotlins-native-serialization-library-c88c0f14f93d" rel="noopener">为什么以及如何使用Kotlin的原生序列化库</a></li><li id="9f62" class="nf ng it ma b mb no me np mh nq ml nr mp ns mt on nl nm nn bi translated"><a class="ae ky" href="https://medium.com/@sgkantamani/learn-how-to-combine-kotlin-flows-317849a71d3e" rel="noopener">了解如何组合Kotlin流</a></li></ul><p id="158c" class="pw-post-body-paragraph ly lz it ma b mb my ju md me mz jx mg mh na mj mk ml nb mn mo mp nc mr ms mt im bi translated">感谢您的阅读。</p></div></div>    
</body>
</html>