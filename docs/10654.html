<html>
<head>
<title>The Power of Caching in JavaScript</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">JavaScript中缓存的威力</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/the-power-of-caching-in-javascript-9a4c985ba8e8?source=collection_archive---------6-----------------------#2022-01-20">https://betterprogramming.pub/the-power-of-caching-in-javascript-9a4c985ba8e8?source=collection_archive---------6-----------------------#2022-01-20</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="3403" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">数据和缓存携手提升性能</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi ki"><img src="../Images/2ac8a783fc571331da2a0d1372373d2a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1280/format:webp/1*oFjCh7X_MuUXcG9BvAVxfQ.jpeg"/></div><p class="kq kr gj gh gi ks kt bd b be z dk translated">照片由Unsplash上的this engineering RAEng拍摄</p></figure><p id="f0cf" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">随着我们的应用程序变得越来越大，对性能的需求也在增长。性能可以通过缓存来实现。这是在web应用程序中利用的一个重要策略，因为加载网页需要<em class="lr">时间</em>和<em class="lr">资源</em>。当我们减少时间和资源时，我们的应用程序变得更快，性能更好。此外，这增加了我们的用户在用户体验方面的积极反馈。</p><p id="45c1" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">用户体验是巨大的，通过利用缓存，你可以取得很大的成就，比如提高你的搜索结果排名。</p><p id="dd65" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">在本帖中，我们将回顾缓存可以改善你思考和编写高效代码的方式。</p><h1 id="3b8c" class="ls lt it bd lu lv lw lx ly lz ma mb mc jz md ka me kc mf kd mg kf mh kg mi mj bi translated">在困难时期，缓存可以用来“复兴”您的应用程序</h1><p id="6f02" class="pw-post-body-paragraph kv kw it kx b ky mk ju la lb ml jx ld le mm lg lh li mn lk ll lm mo lo lp lq im bi translated">当你的网站在谷歌的搜索结果中被编入索引时，每次机器人爬进你的网站时，谷歌机器人都会拍一张快照。当它这样做的时候，它会为你的网站做一个“备份”。这被称为谷歌缓存。</p><p id="7fef" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">例如，如果你的网站因为一些奇怪的原因被黑客攻击或关闭，谷歌会比较你当前的网站和它最后一次的样子。如果你的网站回复了404，那么谷歌就能够从缓存中提供你的网站上一次的“工作”状态，有效地避免你的网站引起用户跳转到其他地方。</p><p id="f158" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">我们可以通过应用类似的技术来学习这一点，比如缓存我们应用的资源，以便在用户断开互联网连接时提供离线体验。</p><h1 id="7b24" class="ls lt it bd lu lv lw lx ly lz ma mb mc jz md ka me kc mf kd mg kf mh kg mi mj bi translated">线下体验</h1><p id="b386" class="pw-post-body-paragraph kv kw it kx b ky mk ju la lb ml jx ld le mm lg lh li mn lk ll lm mo lo lp lq im bi translated">在现代社会，用户的离线体验变得比以往任何时候都更加重要。</p><p id="2ce1" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">例如，当用户打开飞行模式时，我们可以为他们提供离线体验，这样他们仍然可以使用我们的应用程序。</p><p id="7170" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">我们可以为此利用缓存。一种方法是通过注册如下所示的侦听器来保存DOM的上次使用状态:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mp mq l"/></div></figure><p id="8be7" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">这是一个示例的一般概念，可以帮助您开始使用更正式或更安全的解决方案。</p><p id="ba30" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">JavaScript的伟大之处在于它能够利用不同的技术，而无需学习一门新的语言。</p><p id="9303" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">我们可以利用<a class="ae ku" href="https://developer.mozilla.org/en-US/docs/Web/API/Service_Worker_API" rel="noopener ugc nofollow" target="_blank">服务工作者</a>(位于独立于DOM的上下文中)来预缓存资源和拦截请求，以便它们获得更快的响应时间。它甚至更安全，因为它在一个单独的线程上执行操作。</p><p id="0f2a" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">服务人员可以使用许多其他的<a class="ae ku" href="https://developers.google.com/web/tools/workbox/modules/workbox-precaching" rel="noopener ugc nofollow" target="_blank">缓存策略</a>,为您的用户提供更强大的用户体验。</p><p id="db1a" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">如果您不熟悉Workers，这里有一个简短的示例，展示了在使用Workers时它的语法:</p><p id="c09b" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">对于<a class="ae ku" href="https://developer.mozilla.org/en-US/docs/Web/API/DedicatedWorkerGlobalScope" rel="noopener ugc nofollow" target="_blank">敬业的工人</a>:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mp mq l"/></div></figure><p id="a16d" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">对于<a class="ae ku" href="https://developer.mozilla.org/en-US/docs/Web/API/ServiceWorker" rel="noopener ugc nofollow" target="_blank">服务人员</a>:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mp mq l"/></div></figure><p id="a30f" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">对于<a class="ae ku" href="https://developer.mozilla.org/en-US/docs/Web/API/SharedWorker" rel="noopener ugc nofollow" target="_blank">共享工人</a>:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mp mq l"/></div></figure><p id="db42" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">工作者需要被分开，因为他们在单独的上下文中运行，所以他们应该被隔离在他们自己的文件中:</p><blockquote class="mr ms mt"><p id="95ac" class="kv kw lr kx b ky kz ju la lb lc jx ld mu lf lg lh mv lj lk ll mw ln lo lp lq im bi translated"><em class="it"> myServiceWorker.js </em></p></blockquote><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mp mq l"/></div></figure><blockquote class="mr ms mt"><p id="2458" class="kv kw lr kx b ky kz ju la lb lc jx ld mu lf lg lh mv lj lk ll mw ln lo lp lq im bi translated"><em class="it"> myWorker.js </em></p></blockquote><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mp mq l"/></div></figure><p id="2605" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">你可以在这里了解更多关于工人的信息。</p><p id="9ac8" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">Spotify和网飞就是线下体验的好例子。由于Spotify的缓存，大多数时候我们很难注意到我的手机在听Spotify时没有信号。</p><h1 id="0b5b" class="ls lt it bd lu lv lw lx ly lz ma mb mc jz md ka me kc mf kd mg kf mh kg mi mj bi translated">“假装”良好的表现</h1><p id="0457" class="pw-post-body-paragraph kv kw it kx b ky mk ju la lb ml jx ld le mm lg lh li mn lk ll lm mo lo lp lq im bi translated">缓存的力量在“伪造”事物方面表现得非常好。“作伪”这个词用在现实世界中有很不好的含义，但在DOM的上下文中它是积极的！web应用程序的首要目标(可以说)是让用户开心，在假装良好的性能时，你实际上帮助用户感觉他们得到了很好的照顾。</p><p id="9edd" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">以下是缓存帮助用户伪造良好性能的一些方法:</p><h1 id="3e6e" class="ls lt it bd lu lv lw lx ly lz ma mb mc jz md ka me kc mf kd mg kf mh kg mi mj bi translated">1.加载图像时提供占位符</h1><p id="d1f2" class="pw-post-body-paragraph kv kw it kx b ky mk ju la lb ml jx ld le mm lg lh li mn lk ll lm mo lo lp lq im bi translated">为了让用户在我们的页面上有宾至如归的感觉，他们不应该被迫等待图片被加载。通过利用占位符图像，我们可以让用户在我们的页面上有一个简单的体验，如果我们用别的东西(比如一个跟踪的SVG)代替大的图像<em class="lr">而</em>它完成加载真实的图像。我们可以缓存下一次用户访问时要立即加载的实际图像，或者我们可以<em class="lr">缓存尺寸</em>，这使我们能够在加载时立即显示类似于预测尺寸的轮廓的东西。</p><p id="5931" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">如果您不熟悉什么是跟踪的SVG，这是它的样子，左边是完全加载的图像，右边是部分(跟踪的SVG)占位符:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="my mz di na bf nb"><div class="gh gi mx"><img src="../Images/8f126c3ddc8ad2996e743465011910d4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*WuqAxq1pPZqdSwSqGkFktQ.png"/></div></div></figure><h1 id="d01e" class="ls lt it bd lu lv lw lx ly lz ma mb mc jz md ka me kc mf kd mg kf mh kg mi mj bi translated">2.惰性装载</h1><p id="e23e" class="pw-post-body-paragraph kv kw it kx b ky mk ju la lb ml jx ld le mm lg lh li mn lk ll lm mo lo lp lq im bi translated">惰性加载是web开发中的一个流行术语。这是一个有用的策略，它只在需要时为用户客户端请求数据。如果我们缓存<em class="lr">将在时机成熟时被</em>请求的资源，缓存可以帮助加速延迟加载。这是一个重要的概念，因为<em class="lr">web应用程序中的许多</em>数据几乎从未被用户客户端请求过。延迟加载帮助您考虑缓存什么，以便只在需要时才被使用。您很可能利用这个概念与网页上的某个组件进行了交互。</p><p id="8622" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">例如，任何呈现某种形式的<em class="lr">分页</em>的网页都是这种方法的实现。</p><h1 id="a428" class="ls lt it bd lu lv lw lx ly lz ma mb mc jz md ka me kc mf kd mg kf mh kg mi mj bi translated">3.重用请求响应</h1><p id="a00e" class="pw-post-body-paragraph kv kw it kx b ky mk ju la lb ml jx ld le mm lg lh li mn lk ll lm mo lo lp lq im bi translated">之前我们谈到了服务人员，这里值得一提的是，这是他们真正为你的用户打造高性能应用的地方。</p><p id="af5d" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">在我工作的公司，我惊讶于通过服务人员实现<em class="lr">缓存响应</em>后收到的积极反馈。普通用户(我说的普通用户是指那些不是开发人员的人)不知道他们的页面只是在后台工作人员缓存他们的访问时，他们得到的“即时响应”时间内从浏览器的早期会话中获取的。</p><p id="1e63" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">另一件重要的事情是，当我们提供缓存响应时，我们也跳过了额外的请求(假设内容不会经常改变)，这有利于节省带宽和资源。</p><h1 id="0a41" class="ls lt it bd lu lv lw lx ly lz ma mb mc jz md ka me kc mf kd mg kf mh kg mi mj bi translated">更快的功能</h1><p id="69e6" class="pw-post-body-paragraph kv kw it kx b ky mk ju la lb ml jx ld le mm lg lh li mn lk ll lm mo lo lp lq im bi translated">通过缓存函数的结果，我们可以让函数更快地处理数据，这可以有效地提升应用程序的性能。</p><p id="df9b" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">作为工程师，考虑我们数据的哪些部分应该被缓存是绝对必要的。根据具体情况，了解哪种缓存策略是最佳选择也很重要。</p><p id="8953" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">我们尤其应该考虑:</p><ol class=""><li id="095f" class="nc nd it kx b ky kz lb lc le ne li nf lm ng lq nh ni nj nk bi translated"><em class="lr">当</em>从缓存中更新数据或使数据无效时。在web开发中，当维护最新的缓存时，错误地处理缓存并不少见。</li><li id="494d" class="nc nd it kx b ky nl lb nm le nn li no lm np lq nh ni nj nk bi translated">保存经常访问的数据，以便我们在不需要执行耗时或昂贵的操作时检索使用。用户很重要，所以我们也需要考虑定期更新缓存，让他们看到最新的信息。</li></ol><p id="d245" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">例如，当我们有一个负责检索和返回数据的函数时，我们可以使用一个叫做<em class="lr">内存化</em>的策略从缓存中检索数据，如果它之前已经被提取过的话:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mp mq l"/></div></figure><p id="a2f3" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">通过垃圾邮件发送此函数，它将只在第一次执行提取，并在后续调用时立即返回缓存的数据:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mp mq l"/></div></figure><p id="127c" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">一旦你使用像<a class="ae ku" href="https://en.wikipedia.org/wiki/Time_to_live" rel="noopener ugc nofollow" target="_blank"> TTL </a>这样的无效策略，这种策略部分被称为缓存备用模式。</p><h1 id="a325" class="ls lt it bd lu lv lw lx ly lz ma mb mc jz md ka me kc mf kd mg kf mh kg mi mj bi translated">真实世界场景</h1><ul class=""><li id="b3a4" class="nc nd it kx b ky mk lb ml le nq li nr lm ns lq nt ni nj nk bi translated">Gatsby将构建缓存到JSON对象中，这些对象在后续的构建中被拾取，以便使构建过程更快</li><li id="a7ed" class="nc nd it kx b ky nl lb nm le nn li no lm np lq nt ni nj nk bi translated"><a class="ae ku" href="https://swr.vercel.app/" rel="noopener ugc nofollow" target="_blank"> SWR </a>利用一种叫做<a class="ae ku" href="https://datatracker.ietf.org/doc/html/rfc5861" rel="noopener ugc nofollow" target="_blank">的HTTP缓存失效策略来提供快速响应，同时保证及时更新数据</a></li><li id="ea22" class="nc nd it kx b ky nl lb nm le nn li no lm np lq nt ni nj nk bi translated">Chrome <a class="ae ku" href="https://v8.dev/blog/code-caching-for-devs" rel="noopener ugc nofollow" target="_blank"> V8引擎分三个阶段缓存编译好的代码</a>，快速高效</li></ul><h1 id="2848" class="ls lt it bd lu lv lw lx ly lz ma mb mc jz md ka me kc mf kd mg kf mh kg mi mj bi translated">结论</h1><p id="f202" class="pw-post-body-paragraph kv kw it kx b ky mk ju la lb ml jx ld le mm lg lh li mn lk ll lm mo lo lp lq im bi translated">本帖到此结束！我希望你发现这是有价值的，并期待在未来更多！</p></div></div>    
</body>
</html>