# 如何为角度组件编写有用的测试

> 原文：<https://betterprogramming.pub/how-to-reach-100-test-coverage-without-testing-anything-64d07d226bff>

## 轻松实现几乎 100%的代码覆盖率

![](img/76cefc268710a630772fe8a3dc7c2154.png)

由[马库斯·斯皮斯克](https://unsplash.com/@markusspiske?utm_source=medium&utm_medium=referral)在 [Unsplash](https://unsplash.com?utm_source=medium&utm_medium=referral) 拍摄的照片

在不同的项目中用不同的语言和不同的框架进行了多年的开发之后，我以为我什么都见过了。但在我们的行业中，唯一自然不变的是，你一直面临着你从未见过的东西。我最近的一个项目仍然打动着我，我想和你分享我的想法。这是关于我们为角度应用程序编写组件测试的方式。

如您所知，您可以使用 angular cli 生成新组件，angular cli 会在组件旁边为我们生成一个规格文件。如果仔细查看，您会发现有一个`TestBed`用于为组件创建一个测试工具。但是如果我们比较不同的编写组件测试的方法，我们会发现有一种非常简单的方法叫做组件类测试([https://angular.io/guide/testing-components-basics](https://angular.io/guide/testing-components-basics))。https://angular.io/guide/testing-components-scenarios 中描述了一个更加详细的测试策略。如果我看一下这两种情况下的文档数量，我会觉得有点像丹尼尔·卡内曼的“快速和慢速思维”。但是今天属于慢思考的范畴，明天可能会是快思考。这是一个练习和动机的问题。

够哲学化了。让我们来看看一些代码。假设我们想要编写一个自定义表单控件，它的行为应该像一个非常基本的选择框(为了本文的目的而简化)。有用户可以选择的选项，选择的值应该反映在`FormControl`中。下面是实现所需的`ControlValueAccessor`的组件类型脚本代码:

这是相应的 html 模板

现在，我们想测试我们的代码，以便达到 100%的测试覆盖率。以下是完整的规范文件:

下面是测试覆盖报告的结果:

```
Statements   : 100% ( 32/32 )
Branches     : 100% ( 2/2 )
Functions    : 100% ( 14/14 )
Lines        : 100% ( 29/29 )
```

太好了！我们有 100%的代码覆盖率。每一行，每一个函数的每一个分支。这怎么可能这么容易达成？

*   首先，你可能注意到使用了组件类测试方法。组件构造函数被直接调用。唯一的参数应该是一个`NgControl`实例。因为我们没有这样一个对象，我们只是提供了一个模拟。
*   模板被完全忽略。
*   组件中有许多私有的函数和属性。为了避免编译器错误，组件必须被转换成`any`，这样我们就可以在编译期间访问这些函数和属性。
*   每一个被调用的函数都用一个 spy 来测试——例如，测试检查函数是否被调用。
*   不要在意你是否正在调用框架应该调用的函数(例如`registerOnTouch`)——记住我们想要达到 100%的测试覆盖率。

测试的实现非常简单:从顶部开始，为每个函数创建一个测试，并通过一个间谍检查被调用的方法是否存在于被测试的函数中。为了模拟真实的测试，只需检查函数中被改变的一些属性。如果函数或属性是私有的——不要在意——只需将您的组件转换为`any`,您就可以做任何事情。它会编译。在运行时，私有不存在。

你对此有意见吗？不客气——我也是。

# 这里到底发生了什么？

测试是测试组件实现的方式，而不是期望的行为。让我们检查一下，如果我们在实现级别更改某些东西，会发生什么情况:

*   如果模板代码被改变，测试仍然通过。最后，可以删除完整的模板代码，测试将会通过——因为它不是测试的一部分。所以每一个改变都可能破坏组件行为。
*   如果有人删除了构造函数中的行(`ngControl.valueAccessor = this;`)。该组件不再可用作控件。但是测试还是通过了。
*   如果从代码中删除了`updateSelection`函数，并使用了一个设置器来确保`selectedOption`和`viewModel`同步，测试将不会通过。这不会改变组件的行为，但会改变实现。(4 测试因运行时错误而失败)
*   如果`optionClicked`函数的实现被改变，并且确保每次调用`onChange`时输出`selectionChanged`发出值，测试将不会通过。同样，这不会改变行为，但会改变组件的实现方式。(2 测试失败，因为回调函数不再是在`registerOnChange`函数中传递的函数，并且`emit`不再被调用，因为对`onChange`函数的窥探)
*   如果`onChange`功能的名称被更改，测试将会中断。IDE 也不能确保函数在测试中被重命名，因为存在到`any`的强制转换。(3 个测试因运行时错误而失败)

如果你想自己试验一下，找到新的方法在不改变行为的情况下破坏测试:下面是代码[https://github . com/mseemann/testing-with-100-percent-test coverage](https://github.com/mseemann/testing-with-100-percent-testcoverage)。

那么这个问题的原因是什么呢？测试被绑定到实现。如果您想要或者需要更改实现，您的测试将会中断。现在你必须调整你的测试。但结果是这些测试完全没有用——它们不能阻止我们打破想要的行为。这种类型的测试确实确保了在不改变或修复测试代码的情况下，实现不会被改变。更糟糕的是:由于对`any`的过度使用，编译器无能为力，测试将因运行时错误而失败。如果熟悉角形控制 api，这在本例中可能很容易。但是如果事情更复杂，你必须付出巨大的努力来修复这些错误。

所以让我们说清楚:

*期望的行为是我们代码的不变量——实现不是。有价值的测试是测试不变量。绝对没有理由做相反的事情。*

# 我们怎样才能做得更好？

如果您不想编写与模板交互的测试。那么就根本不要编写任何组件测试。只需将组件代码中的业务逻辑提取到纯函数中。并测试这些功能。但是不要写测试来确保你的实现不被改变。*这是没有用的，会导致维护成本成倍增加*。

编写测试行为而不是实现的测试。这需要您与组件的输入和输出进行交互。组件的输入和输出是什么？当然，这些是`@Input`和`@Output`属性和事件。但事实上，真正的输入和输出是你的模板中呈现的内容，以及用户可以用你的模板做什么。

下面是一个如何测试组件行为的示例:

只是为了强调几件事:

*   一个特殊的`TestComponent`用于与被测组件交互。这也是一个很好的文档，因为组件的用户可以看到应该如何使用组件。
*   测试用例的数量只有 5 个而不是 10 个。
*   每个测试都检查组件的预期行为，而不是实现。
*   模板被渲染——模板中的突破性变化会破坏测试。
*   完整代码中绝对没有`any`关键字与被测组件交互(实际上 angular test API 中有一些隐藏类型)。

让我们看看报道:

```
Statements   : 100% ( 30/30 )
Branches     : 100% ( 2/2 )
Functions    : 84.61% ( 11/13 )
Lines        : 100% ( 27/27 )
```

几乎和以前一样。我没有包括无用的测试`(component as any).onTouched()`。这段代码只是为了确保`onTouched`成员永远不会为空或未定义。这样我就可以避免在每次需要调用时检查`onTouched`成员是否被设置。这是覆盖率报告中缺失的两个功能——谁在乎呢。

对了！我上面列出的每一个改变都可以在不破坏测试的情况下进行，因为组件的行为没有改变。这个版本在 github 也有:[https://github . com/mseemann/testing-with-100-percent-test coverage/tree/not-100-percent-but-valued-test](https://github.com/mseemann/testing-with-100-percent-testcoverage/tree/not-100-percent-but-valuable-test)。

# 我们能做得更好吗？

是的，肯定的。

*   可以引入一个`option`组件，之后，测试中的一些 css 查询也可以删除。之后，有人可以改变组件的风格，而不会潜在地破坏测试。
*   页面对象模式可以用来避免冗余的代码片段——因此测试甚至可以变得更加干涩和不那么脆弱。
*   我们可以为我们的组件提供测试工具。你可以看看这篇关于如何使用它们的文章。
*   如果你关心性能。从 karma 切换到 jest 是可能的——`jsdom`可能比浏览器中的真实 dom 快一点，测试可以并行运行。如果你想更进一步，你可以切换到`nrwl` `nx`，只运行受代码变更影响的测试。

# 结论

我承认——我也沉迷于绿色徽章。但正如你所看到的，获得绿卡的方式可能会非常不同。将来，在我再次编写测试用例以达到 100%的代码覆盖率之前，我会三思而行。如果我怀疑测试是否真的在测试行为，我最好在开始测试实现之前省略代码。

当然，编写正确的测试需要更多的努力，但是只有在那个时候，代码才被首先创建。在每一个需要的改变上，你将从这种努力中获得巨大的回报，并且你的测试是有价值的，因为它们测试了期望的行为。

顺便说一句，如果在实现完成之前编写测试，这整个问题就不会出现——这是我需要考虑的一个方面。