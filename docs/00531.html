<html>
<head>
<title>Scalable Ruby — Concurrency and Parallelism Explained</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">可扩展的Ruby——并发性和并行性解释</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/scalable-ruby-concurrency-and-parallelism-explained-68b09a7aeb53?source=collection_archive---------3-----------------------#2019-06-06">https://betterprogramming.pub/scalable-ruby-concurrency-and-parallelism-explained-68b09a7aeb53?source=collection_archive---------3-----------------------#2019-06-06</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="b841" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">以及为什么差异如此重要</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/4e88113aacdfeab0a2001eafbb8fa377.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*vhdyFoSgflORnK4yOz4TRA.jpeg"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">谭爱红摄</p></figure><p id="a0bd" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">几年前，Ruby统治了网络。构建新的应用程序非常容易，有许多解决常见问题的方法，因此，构建新功能也很容易。</p><p id="c29a" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">但是后来事情发生了变化。Twitter努力让Ruby扩展，并切换到不同的平台来满足他们的性能需求。越来越多的声音指出Ruby太慢，无法满足网络的需求。</p><p id="f900" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">这产生了更容易扩展、更好扩展的新技术。<a class="ae lu" href="https://en.wikipedia.org/wiki/Node.js" rel="noopener ugc nofollow" target="_blank">节点</a>特别满足了这种需求，并围绕它创造了新的炒作。其他出现的技术还有<a class="ae lu" href="https://golang.org/" rel="noopener ugc nofollow" target="_blank"> Golang </a>、<a class="ae lu" href="https://elixir-lang.org/" rel="noopener ugc nofollow" target="_blank">elixin</a>和<a class="ae lu" href="https://akka.io/" rel="noopener ugc nofollow" target="_blank"> Scala/Akka </a>等等。</p><p id="ca9a" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">注意:当我谈论Ruby中的并发性时，我不会谈论多进程架构或如何使用负载平衡器。这篇文章的目标是展示如何在一个进程中利用Ruby中的并发性，并展示并行性和并发性之间的区别。</p><p id="4714" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">Node是如何实现这种可伸缩性的？Node运行在V8 JavaScript引擎上，采用了非常复杂和快速的事件循环。借助这一点和非阻塞IO操作，Node可以处理大量并行传入请求。</p><p id="1c2a" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">这是否意味着节点也在<em class="lv">并行</em>中运行所有这些请求？事实上，没有。事件循环和非阻塞IO操作使V8可以并发运行请求，但不是并行的。</p><p id="ae90" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">“等等，什么？”我听到你说。“有什么区别，我为什么要关心？”</p></div><div class="ab cl lw lx hx ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="im in io ip iq"><h1 id="b482" class="md me it bd mf mg mh mi mj mk ml mm mn jz mo ka mp kc mq kd mr kf ms kg mt mu bi translated">什么是并发和并行？</h1><h2 id="418f" class="mv me it bd mf mw mx dn mj my mz dp mn lh na nb mp ll nc nd mr lp ne nf mt ng bi translated">并发</h2><p id="003a" class="pw-post-body-paragraph ky kz it la b lb nh ju ld le ni jx lg lh nj lj lk ll nk ln lo lp nl lr ls lt im bi translated">我发现并发性的一个非常准确的定义是这样的:</p><blockquote class="nm nn no"><p id="99e5" class="ky kz lv la b lb lc ju ld le lf jx lg np li lj lk nq lm ln lo nr lq lr ls lt im bi translated">“独立执行部门的协调和管理。这些执行可以真正并行，也可以简单地通过交错来管理。他们可以通过共享内存或消息传递进行交流。”</p></blockquote><p id="21b9" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">当谈到并发性时，我将只谈<em class="lv">通过交错</em>类型的并发性管理的<em class="lv">。</em></p><p id="10b5" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">让我们以Node为例来解释并发性，因为许多人都知道Node，而且(几乎)每个人都知道JavaScript。因此，让我们看一个例子，看看并发在实践中意味着什么。</p><p id="3606" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">假设我们有两个客户请求。其中一个想要更新员工的一些数据，另一个想要访问公司所有部门的列表。V8发动机如何处理这种情况？</p><p id="253c" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">将首先处理第一个请求。例如，服务器检查是否允许用户保存客户。为此，应用程序向数据库发出请求。现在，它发生了！这个对数据库的请求是非阻塞的，这意味着应用程序不会等待响应而继续。因为在数据库响应之前，当前请求没有任何事情可做，所以它通知节点调度器它处于空闲状态。现在，节点可以处理第二个请求。</p><p id="f502" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">顺便说一下，这就是JS开发人员必须使用async/await、promises或callbacks的原因。所有这些技术都允许JS引擎继续其流程<em class="lv">和</em>在数据库发送数据后处理响应，而开发人员将代码放在一个地方。</p><h2 id="5289" class="mv me it bd mf mw mx dn mj my mz dp mn lh na nb mp ll nc nd mr lp ne nf mt ng bi translated">这对Ruby意味着什么？</h2><p id="8dae" class="pw-post-body-paragraph ky kz it la b lb nh ju ld le ni jx lg lh nj lj lk ll nk ln lo lp nl lr ls lt im bi translated">由于(几乎)所有的web应用程序都有大量的网络请求要处理，在Ruby中抑制性能的主要因素是请求和等待响应，因为它默认使用了一个<strong class="la iu">阻塞IO </strong>。</p><p id="84b0" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">稍后我们将看到我们Ruby开发人员可以做些什么来使并发工作。</p><h2 id="b9ee" class="mv me it bd mf mw mx dn mj my mz dp mn lh na nb mp ll nc nd mr lp ne nf mt ng bi translated">平行</h2><p id="e0bc" class="pw-post-body-paragraph ky kz it la b lb nh ju ld le ni jx lg lh nj lj lk ll nk ln lo lp nl lr ls lt im bi translated">定义如下:</p><p id="cea2" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated"><em class="lv">真正同时执行或评价事物</em></p><p id="cd43" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">并行更容易理解，因为它就像你想象的那样工作。两个请求到达服务器，两个请求同时从服务器并行处理。对于计算机来说，这意味着两个内核同时工作。</p></div><div class="ab cl lw lx hx ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="im in io ip iq"><h1 id="80a5" class="md me it bd mf mg mh mi mj mk ml mm mn jz mo ka mp kc mq kd mr kf ms kg mt mu bi translated">如何在Ruby中实现(非并行)并发</h1><p id="c743" class="pw-post-body-paragraph ky kz it la b lb nh ju ld le ni jx lg lh nj lj lk ll nk ln lo lp nl lr ls lt im bi translated">现在我们来看看这篇文章的目标:<em class="lv">如何在Ruby中实现并发性？</em></p><p id="57e3" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">如上所述，这是可能的，但现在还不那么容易。Ruby没有async/await，它没有承诺，要使用非阻塞IO，你必须编写自己的ORM适配器。</p><p id="f52b" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">“但是我们有线！”我听到你尖叫。是的，你是对的。对于线程，我们可以使用并发。你会怎么做？下面是一个关于<a class="ae lu" href="https://guides.rubyonrails.org/active_record_basics.html" rel="noopener ugc nofollow" target="_blank">Rails</a>active record的简单例子:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ns nt l"/></div></figure><h2 id="882a" class="mv me it bd mf mw mx dn mj my mz dp mn lh na nb mp ll nc nd mr lp ne nf mt ng bi translated">与节点并发相比的缺点</h2><p id="ad00" class="pw-post-body-paragraph ky kz it la b lb nh ju ld le ni jx lg lh nj lj lk ll nk ln lo lp nl lr ls lt im bi translated">每个线程映射到一个操作系统线程。因此，不可能创建数百甚至数千个线程。开发商要做更多的仪式。换句话说，他必须更明确地做很多事情。</p><p id="a593" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">因为我们使用线程，而Ruby线程转换成OS线程…</p></div><div class="ab cl lw lx hx ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="im in io ip iq"><h1 id="3454" class="md me it bd mf mg mh mi mj mk ml mm mn jz mo ka mp kc mq kd mr kf ms kg mt mu bi translated">我们也能在Ruby中利用并行性吗？</h1><p id="40eb" class="pw-post-body-paragraph ky kz it la b lb nh ju ld le ni jx lg lh nj lj lk ll nk ln lo lp nl lr ls lt im bi translated">不幸的是，不是在一个过程中。Ruby有一种叫做GVL(Global Virtual Machine Lock——有时称为GIL——全局解释器锁)的东西。通过这种机制，Ruby可以确保当前只有一个操作系统线程在运行。本质上，这是一个全局标志，用于显示在当前线程中运行代码是否合适。</p><p id="d08a" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">对于IO操作，比如上面例子中的数据库请求，这完全没问题，因为线程正在等待数据库，而您的操作系统无论如何都会让它进入睡眠状态。因此，可以处理第二个线程——至少直到它因为数据库请求或者因为操作系统切换线程而被置于睡眠状态。</p><p id="92d2" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">但是对于Ruby代码来说，就有点不同了。您可以在没有IO绑定操作的情况下使用Ruby线程，但是您不会看到任何性能提升。MRI Ruby会检查GVL，只有当这个标志为真时，它才会运行您的代码。</p><h2 id="6163" class="mv me it bd mf mw mx dn mj my mz dp mn lh na nb mp ll nc nd mr lp ne nf mt ng bi translated">你为什么要创造像GVL这样的东西？</h2><p id="6026" class="pw-post-body-paragraph ky kz it la b lb nh ju ld le ni jx lg lh nj lj lk ll nk ln lo lp nl lr ls lt im bi translated">Ruby使用GVL的原因是基于它的理念:让程序员快乐！</p><p id="a2be" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">编写多线程程序是非常困难的。GVL使这变得更容易，因为你不能(如此容易地)有一个<a class="ae lu" href="https://en.wikipedia.org/wiki/Deadlock" rel="noopener ugc nofollow" target="_blank">死锁</a>，或者其他在多线程程序中很容易发生的讨厌的事情。</p><p id="b3c7" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">顺便提一下，<a class="ae lu" href="https://wiki.python.org/moin/GlobalInterpreterLock" rel="noopener ugc nofollow" target="_blank"> Python也在使用GIL </a>。所以，这是语言设计者经常做的事情。</p></div><div class="ab cl lw lx hx ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="im in io ip iq"><h1 id="800c" class="md me it bd mf mg mh mi mj mk ml mm mn jz mo ka mp kc mq kd mr kf ms kg mt mu bi translated"><strong class="ak">那么不同的Ruby实现呢？</strong></h1><h2 id="20b2" class="mv me it bd mf mw mx dn mj my mz dp mn lh na nb mp ll nc nd mr lp ne nf mt ng bi translated">JRuby</h2><p id="c326" class="pw-post-body-paragraph ky kz it la b lb nh ju ld le ni jx lg lh nj lj lk ll nk ln lo lp nl lr ls lt im bi translated"><a class="ae lu" href="https://www.jruby.org/" rel="noopener ugc nofollow" target="_blank"> JRuby </a>可以使用真正的并行。没有任何GVL会阻止你的代码。当然，缺点是，现在你要负责确保你的代码是线程安全的，并且你要避免死锁和其他不好的事情。</p><h2 id="8cab" class="mv me it bd mf mw mx dn mj my mz dp mn lh na nb mp ll nc nd mr lp ne nf mt ng bi translated">松露红宝石</h2><p id="fe15" class="pw-post-body-paragraph ky kz it la b lb nh ju ld le ni jx lg lh nj lj lk ll nk ln lo lp nl lr ls lt im bi translated"><a class="ae lu" href="https://github.com/oracle/truffleruby" rel="noopener ugc nofollow" target="_blank">松露红宝石</a>也不使用GVL。甚至有一些讨论更进一步，试图把所有东西都放在一个<a class="ae lu" href="https://en.wikipedia.org/wiki/Mutual_exclusion" rel="noopener ugc nofollow" target="_blank">互斥体</a>下，如果——且仅如果——你的代码使用线程。这样，您将拥有GVL的优势，以及多线程应用程序带来的性能提升。但是，现在，这仍然是一个实验性的功能。只有时间才能证明它是否会成为有用的东西。</p><h2 id="579d" class="mv me it bd mf mw mx dn mj my mz dp mn lh na nb mp ll nc nd mr lp ne nf mt ng bi translated">回到未来— Ruby 3</h2><p id="0b19" class="pw-post-body-paragraph ky kz it la b lb nh ju ld le ni jx lg lh nj lj lk ll nk ln lo lp nl lr ls lt im bi translated"><a class="ae lu" href="https://twitter.com/yukihiro_matz" rel="noopener ugc nofollow" target="_blank"> Matz </a>已经认识到并行性和并发性的问题。为此他已经公布了<a class="ae lu" href="https://rubykaigi.org/2019/presentations/yukihiro_matz.html" rel="noopener ugc nofollow" target="_blank">《并发之年》</a>(此视频只有日文)。Ruby如何实现与Node类似甚至更好的可伸缩性呢？这里有三个项目想让这成为可能</p><p id="0f75" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">- <a class="ae lu" href="https://www.youtube.com/watch?v=XiujvihOLq8" rel="noopener ugc nofollow" target="_blank">公会</a> <br/> - <a class="ae lu" href="https://www.codeotaku.com/journal/2018-11/fibers-are-the-right-solution/index" rel="noopener ugc nofollow" target="_blank">并发纤维</a>-<br/>-<a class="ae lu" href="https://bugs.ruby-lang.org/issues/13618" rel="noopener ugc nofollow" target="_blank">自动::线程</a>(这个项目可能死了)</p></div><div class="ab cl lw lx hx ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="im in io ip iq"><h1 id="0354" class="md me it bd mf mg mh mi mj mk ml mm mn jz mo ka mp kc mq kd mr kf ms kg mt mu bi translated">可扩展性—真的重要吗？</h1><p id="63c0" class="pw-post-body-paragraph ky kz it la b lb nh ju ld le ni jx lg lh nj lj lk ll nk ln lo lp nl lr ls lt im bi translated">大多数时候答案是否定的。当你开始一个新项目或应用程序时，你的应用程序只有非常非常少的用户。Ruby(也叫Rails)可以很好地处理一般数量的用户，没有任何问题。很多公司都表现出了这一点。Ruby甚至可以处理许多用户，正如Basecamp、Shopify、GitHub和AirBnB所显示的那样。而且，如果你来到像Twitter这样需要更高性能的地方，你会有更多的资源。更多的钱来打破一个庞然大物，更多的领域知识，以及更多的技术知识，因为到那时你可能会有雇员。</p><p id="d1ff" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">(MRI) Ruby的未来似乎把这个障碍推得更远了，所以你可以愉快地用你喜欢的语言编写代码，并且非常高效！</p></div><div class="ab cl lw lx hx ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="im in io ip iq"><p id="3964" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated"><em class="lv">不是中等会员？</em> <a class="ae lu" href="https://grnt-grdwhl.medium.com/membership" rel="noopener"> <em class="lv">在这里报名</em> </a> <em class="lv">并支持我的写作过程！</em></p></div></div>    
</body>
</html>