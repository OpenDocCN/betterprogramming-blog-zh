<html>
<head>
<title>7 Golang Features You Might Find Weird</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">你可能会觉得奇怪的7个Golang特性</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/7-golang-features-newbies-and-not-so-newbies-may-find-weird-e0542d079097?source=collection_archive---------8-----------------------#2020-09-07">https://betterprogramming.pub/7-golang-features-newbies-and-not-so-newbies-may-find-weird-e0542d079097?source=collection_archive---------8-----------------------#2020-09-07</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="c800" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">围棋写作三年回顾</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/6041063f1ba13291cc4e532fb4193d7e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*NzRuuCAFKox0qZfs1p9XjQ.jpeg"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated"><a class="ae kv" href="https://unsplash.com/@nosoylasonia?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">胡安·戈麦斯</a>在<a class="ae kv" href="https://unsplash.com/s/photos/keyboard?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍照</p></figure><p id="b0f8" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">人类天生就有偏见。当我们开始用一种我们觉得不舒服的编程语言编码时，我们总是指出最让我们恼火的特性。</p><p id="fc55" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">有时很难将这些特性放到相应的环境中，也很难理解设计它们的原因。这并不一定意味着这些功能是错误的或设计不正确的。它们是学习过程的一部分，并逐渐融入我们的编程技能。</p><p id="6118" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在本文中，我将列举我在学习Golang时发现的一些最麻烦/怪异的特性(在本例中是七个)。</p><p id="89aa" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这是一篇个人的完全主观的文章。下面的列表只是我选择的一小部分，没有任何特别的标准。给读者一些背景，我有很多语言的经验:C、C++、Java、Scala、Python、R(如果我们可以把R看作一种语言的话)等等——并且有将近20年的编写代码的经验。</p><p id="a273" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">总的来说，我发现Go是一种学习曲线平滑的语言。这可能是因为它有一个明确定义的目的，消除了一些隐含更复杂语法的特性。无论如何，这是我的清单。</p></div><div class="ab cl ls lt hu lu" role="separator"><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx"/></div><div class="ij ik il im in"><h1 id="92bc" class="lz ma iq bd mb mc md me mf mg mh mi mj jw mk jx ml jz mm ka mn kc mo kd mp mq bi translated"><strong class="ak"> 1。不必要的导入和变量</strong></h1><h2 id="3dcf" class="mr ma iq bd mb ms mt dn mf mu mv dp mj lf mw mx ml lj my mz mn ln na nb mp nc bi translated"><strong class="ak"> Go强制代码最小化</strong></h2><p id="9c4d" class="pw-post-body-paragraph kw kx iq ky b kz nd jr lb lc ne ju le lf nf lh li lj ng ll lm ln nh lp lq lr ij bi translated">这意味着未使用的导入和变量会触发编译错误。例如:</p><pre class="kg kh ki kj gt ni nj nk nl aw nm bi"><span id="0700" class="mr ma iq nj b gy nn no l np nq">import (<br/>    "fmt"<br/>    "os" //not used<br/>)</span><span id="f645" class="mr ma iq nj b gy nr no l np nq">func main() {<br/>    fmt.Println("Hola")<br/>}</span></pre><p id="437c" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">编译器返回:</p><pre class="kg kh ki kj gt ni nj nk nl aw nm bi"><span id="0164" class="mr ma iq nj b gy nn no l np nq">imported and not used: "os"</span></pre></div><div class="ab cl ls lt hu lu" role="separator"><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx"/></div><div class="ij ik il im in"><h1 id="da87" class="lz ma iq bd mb mc md me mf mg mh mi mj jw mk jx ml jz mm ka mn kc mo kd mp mq bi translated"><strong class="ak"> 2。迭代集合</strong></h1><h2 id="619e" class="mr ma iq bd mb ms mt dn mf mu mv dp mj lf mw mx ml lj my mz mn ln na nb mp nc bi translated"><strong class="ak">用于迭代集合的range函数返回两个值</strong></h2><p id="6792" class="pw-post-body-paragraph kw kx iq ky b kz nd jr lb lc ne ju le lf nf lh li lj ng ll lm ln nh lp lq lr ij bi translated">第一个是条目在集合中的位置。第二个值包含条目值本身。</p><pre class="kg kh ki kj gt ni nj nk nl aw nm bi"><span id="fb6f" class="mr ma iq nj b gy nn no l np nq">x := [4]string{"one","two","three","four"}<br/>for i, entry := range(x) {<br/>   fmt.Printf("Element at position %d is %s\n", i, entry)<br/>}</span></pre><p id="6d54" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这非常方便，因为在每次迭代中，您都有两个最常用的值可以在循环中使用。然而，它们并不总是必需的。你可能会这样做:</p><pre class="kg kh ki kj gt ni nj nk nl aw nm bi"><span id="ccad" class="mr ma iq nj b gy nn no l np nq">x := [4]string{"one","two","three","four"}<br/>for i, entry := range(x) {<br/>  fmt.Printf("Element %s\n", entry)<br/>}</span></pre><p id="4822" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这将在编译期间返回一个错误:</p><pre class="kg kh ki kj gt ni nj nk nl aw nm bi"><span id="7b81" class="mr ma iq nj b gy nn no l np nq">i declared but not used</span></pre><p id="e547" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">或者更糟，你会跳过<code class="fe ns nt nu nj b">i</code>变量，就像这样:</p><pre class="kg kh ki kj gt ni nj nk nl aw nm bi"><span id="f24c" class="mr ma iq nj b gy nn no l np nq">x := [4]string{"one","two","three","four"}<br/>for entry := range(x) {<br/>   fmt.Printf("Element %s\n", entry)<br/>}</span></pre><p id="49c7" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这可能会引起混淆，因为它返回了一个变量中的位置值，该值应该是入口值。</p><pre class="kg kh ki kj gt ni nj nk nl aw nm bi"><span id="fc34" class="mr ma iq nj b gy nn no l np nq">Element %!s(int=0)<br/>Element %!s(int=1)<br/>Element %!s(int=2)<br/>Element %!s(int=3)</span></pre><p id="a3a8" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们只需指出一个未使用的变量<code class="fe ns nt nu nj b">i</code>。</p><pre class="kg kh ki kj gt ni nj nk nl aw nm bi"><span id="7ef0" class="mr ma iq nj b gy nn no l np nq">x := [4]string{"one","two","three","four"}<br/>    for _, entry := range(x) {<br/>       fmt.Printf("Element %s\n", entry)<br/>    }</span></pre></div><div class="ab cl ls lt hu lu" role="separator"><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx"/></div><div class="ij ik il im in"><h1 id="ae6c" class="lz ma iq bd mb mc md me mf mg mh mi mj jw mk jx ml jz mm ka mn kc mo kd mp mq bi translated"><strong class="ak"> 3。属性可见性</strong></h1><h2 id="51eb" class="mr ma iq bd mb ms mt dn mf mu mv dp mj lf mw mx ml lj my mz mn ln na nb mp nc bi translated"><strong class="ak">如果属性以大写字母</strong>开头，则属性可见</h2><p id="c588" class="pw-post-body-paragraph kw kx iq ky b kz nd jr lb lc ne ju le lf nf lh li lj ng ll lm ln nh lp lq lr ij bi translated">如果不是，它们是私有的。很简单。然而，我经常忘记这一点，导致愚蠢的错误。</p><pre class="kg kh ki kj gt ni nj nk nl aw nm bi"><span id="1da2" class="mr ma iq nj b gy nn no l np nq">type Message struct {<br/> Text string // This is public<br/> text string // This is private<br/>}</span></pre></div><div class="ab cl ls lt hu lu" role="separator"><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx"/></div><div class="ij ik il im in"><h1 id="e82b" class="lz ma iq bd mb mc md me mf mg mh mi mj jw mk jx ml jz mm ka mn kc mo kd mp mq bi translated"><strong class="ak"> 4。重载方法怎么了？</strong></h1><h2 id="198f" class="mr ma iq bd mb ms mt dn mf mu mv dp mj lf mw mx ml lj my mz mn ln na nb mp nc bi translated">没有任何重载方法</h2><p id="c784" class="pw-post-body-paragraph kw kx iq ky b kz nd jr lb lc ne ju le lf nf lh li lj ng ll lm ln nh lp lq lr ij bi translated">如果您来自Java世界，您可能习惯于重载方法。对于重载方法，在一个方法中，我们可以有几个签名。嗯… Golang没有方法重载。</p></div><div class="ab cl ls lt hu lu" role="separator"><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx"/></div><div class="ij ik il im in"><h1 id="bd22" class="lz ma iq bd mb mc md me mf mg mh mi mj jw mk jx ml jz mm ka mn kc mo kd mp mq bi translated"><strong class="ak"> 5。遗产怎么了？</strong></h1><h2 id="026f" class="mr ma iq bd mb ms mt dn mf mu mv dp mj lf mw mx ml lj my mz mn ln na nb mp nc bi translated"><strong class="ak">没有继承</strong></h2><p id="55ba" class="pw-post-body-paragraph kw kx iq ky b kz nd jr lb lc ne ju le lf nf lh li lj ng ll lm ln nh lp lq lr ij bi translated">仅此而已。你可以做一些变通，像这里描述的<a class="ae kv" href="https://golangbot.com/inheritance/" rel="noopener ugc nofollow" target="_blank">这里的</a>，但我不能说这真的是继承。</p></div><div class="ab cl ls lt hu lu" role="separator"><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx"/></div><div class="ij ik il im in"><h1 id="f884" class="lz ma iq bd mb mc md me mf mg mh mi mj jw mk jx ml jz mm ka mn kc mo kd mp mq bi translated"><strong class="ak"> 6。接口呢？</strong></h1><h2 id="3c87" class="mr ma iq bd mb ms mt dn mf mu mv dp mj lf mw mx ml lj my mz mn ln na nb mp nc bi translated"><strong class="ak">有接口</strong></h2><p id="fa6e" class="pw-post-body-paragraph kw kx iq ky b kz nd jr lb lc ne ju le lf nf lh li lj ng ll lm ln nh lp lq lr ij bi translated">它们可以被定义为方法签名的集合。然而，它们很奇怪，因为你在其他语言中使用它们。</p><p id="8d88" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">为什么？因为你没有以编程的方式指明你的结构实现了一个接口(类似于类<code class="fe ns nt nu nj b">A</code>实现了接口<code class="fe ns nt nu nj b">I</code>)。如果您的结构具有接口枚举的方法，则它会实现该接口。举个例子比较好理解。</p><pre class="kg kh ki kj gt ni nj nk nl aw nm bi"><span id="25a1" class="mr ma iq nj b gy nn no l np nq">package main</span><span id="fe61" class="mr ma iq nj b gy nr no l np nq">import (<br/>    "fmt"<br/>)</span><span id="bb9c" class="mr ma iq nj b gy nr no l np nq">type Speaker interface {<br/>    SayYourName() string<br/>    SayHello(b Speaker) string<br/>}</span><span id="610e" class="mr ma iq nj b gy nr no l np nq">type HappySpeaker struct {}</span><span id="71b0" class="mr ma iq nj b gy nr no l np nq">func(hs HappySpeaker) SayYourName() string {<br/>    return "Happy"<br/>}</span><span id="0558" class="mr ma iq nj b gy nr no l np nq">func(hs HappySpeaker) SayHello(b Speaker) string {<br/>    return fmt.Sprintf("Hello %s!",b.SayYourName())<br/>}</span><span id="11fe" class="mr ma iq nj b gy nr no l np nq">type AngrySpeaker struct {}</span><span id="a1f5" class="mr ma iq nj b gy nr no l np nq">func(as AngrySpeaker) SayYourName() string {<br/>    return "Angry"<br/>}</span><span id="caf2" class="mr ma iq nj b gy nr no l np nq">func(as AngrySpeaker) SayHello(b Speaker) string {<br/>    return fmt.Sprintf("I'm not going to say hello to %s!",b.SayYourName())<br/>}</span><span id="67c1" class="mr ma iq nj b gy nr no l np nq">func main() {<br/>    // We have two different structs<br/>    happy := HappySpeaker{}<br/>    angry := AngrySpeaker{}<br/>    // they can say their names<br/>    fmt.Println(happy.SayYourName())<br/>    fmt.Println(angry.SayYourName())</span><span id="b231" class="mr ma iq nj b gy nr no l np nq">    // But they are also speakers<br/>    fmt.Println(happy.SayHello(angry))<br/>    fmt.Println(angry.SayHello(happy))</span><span id="f2df" class="mr ma iq nj b gy nr no l np nq">    // This is also valid<br/>    var mrSpeaker Speaker = happy<br/>    fmt.Println(mrSpeaker.SayHello(angry))<br/>}</span></pre><p id="d792" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">可以想象，这在编码时会产生影响。Go中的接口是一个更深入的讨论主题，您可以找到许多讨论其利弊的例子。</p></div><div class="ab cl ls lt hu lu" role="separator"><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx"/></div><div class="ij ik il im in"><h1 id="83a3" class="lz ma iq bd mb mc md me mf mg mh mi mj jw mk jx ml jz mm ka mn kc mo kd mp mq bi translated"><strong class="ak"> 7。构造函数呢？</strong></h1><h2 id="91e4" class="mr ma iq bd mb ms mt dn mf mu mv dp mj lf mw mx ml lj my mz mn ln na nb mp nc bi translated"><strong class="ak">当实例化一个新的结构时，可以跳过属性集</strong></h2><p id="1753" class="pw-post-body-paragraph kw kx iq ky b kz nd jr lb lc ne ju le lf nf lh li lj ng ll lm ln nh lp lq lr ij bi translated">在任何面向对象的语言中，你都找不到类似的构造函数。结构定义与C中使用的结构定义非常相似。有一个潜在的问题:在实例化一个新的结构时，可以跳过属性集。在下面的代码中，<code class="fe ns nt nu nj b">halfMessage1</code>和<code class="fe ns nt nu nj b">halfMessage2</code>有未设置的属性。</p><pre class="kg kh ki kj gt ni nj nk nl aw nm bi"><span id="a18e" class="mr ma iq nj b gy nn no l np nq">package main</span><span id="b2a5" class="mr ma iq nj b gy nr no l np nq">import (<br/>    "fmt"<br/>)</span><span id="21b9" class="mr ma iq nj b gy nr no l np nq">type Message struct {<br/>    MsgA string<br/>    MsgB string<br/>}</span><span id="58a8" class="mr ma iq nj b gy nr no l np nq">func(m Message) SayIt() {<br/>  fmt.Printf("[%s] - [%s]\n",m.MsgA, m.MsgB)<br/>}</span><span id="dd63" class="mr ma iq nj b gy nr no l np nq">func main() {</span><span id="f3f3" class="mr ma iq nj b gy nr no l np nq">    fullMessage1 := Message{"hello","bye"}<br/>    fullMessage2 := Message{MsgA: "hello", MsgB: "bye"}</span><span id="5e0c" class="mr ma iq nj b gy nr no l np nq">    halfMessage1 := Message{"hello",""}<br/>    halfMessage2 := Message{MsgA: "hello"}</span><span id="d65a" class="mr ma iq nj b gy nr no l np nq">    emptyMessage := Message{}</span><span id="761d" class="mr ma iq nj b gy nr no l np nq">    fullMessage1.SayIt()<br/>    fullMessage2.SayIt()<br/>    halfMessage1.SayIt()<br/>    halfMessage2.SayIt()    <br/>    emptyMessage.SayIt()        <br/>}</span></pre><p id="c73a" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">输出是:</p><pre class="kg kh ki kj gt ni nj nk nl aw nm bi"><span id="58a5" class="mr ma iq nj b gy nn no l np nq">[hello] - [bye]<br/>[hello] - [bye]<br/>[hello] - []<br/>[hello] - []<br/>[] - []<!-- --> </span></pre><p id="b612" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这总是一个潜在的问题，因为您可能有期望设置值的方法。减轻这种情况的一种方法是定义静态构造函数。</p><pre class="kg kh ki kj gt ni nj nk nl aw nm bi"><span id="26dc" class="mr ma iq nj b gy nn no l np nq">package main</span><span id="09b3" class="mr ma iq nj b gy nr no l np nq">import (<br/>    "fmt"<br/>)</span><span id="db84" class="mr ma iq nj b gy nr no l np nq">type Message struct {<br/>    MsgA string<br/>    MsgB string<br/>}</span><span id="ee04" class="mr ma iq nj b gy nr no l np nq">func(m Message) SayIt() {<br/>  fmt.Printf("[%s] - [%s]\n",m.MsgA, m.MsgB)<br/>}</span><span id="d0c2" class="mr ma iq nj b gy nr no l np nq">func NewMessage(msgA string, msgB string) *Message{<br/>  if len(msgA) * len(msgB) == 0 {<br/>     return nil<br/>  } <br/>  return &amp;Message{MsgA: msgA, MsgB: msgB}<br/>}</span><span id="b5a0" class="mr ma iq nj b gy nr no l np nq">func main() {<br/>   // A correct message<br/>   msg1 := NewMessage("hello","bye")    <br/>   if msg1 != nil {<br/>      msg1.SayIt()<br/>   } else {<br/>      fmt.Println("There was an error")<br/>   }</span><span id="1ac1" class="mr ma iq nj b gy nr no l np nq">   // An incorrect message<br/>   msg2 := NewMessage("","")</span><span id="9d05" class="mr ma iq nj b gy nr no l np nq">   if msg2 != nil {<br/>      msg2.SayIt()<br/>   } else {<br/>      fmt.Println("There was an error")<br/>   }<br/>}</span></pre></div><div class="ab cl ls lt hu lu" role="separator"><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx"/></div><div class="ij ik il im in"><h1 id="9b89" class="lz ma iq bd mb mc md me mf mg mh mi mj jw mk jx ml jz mm ka mn kc mo kd mp mq bi translated">摘要</h1><p id="4978" class="pw-post-body-paragraph kw kx iq ky b kz nd jr lb lc ne ju le lf nf lh li lj ng ll lm ln nh lp lq lr ij bi translated">这是在Go中编码时要考虑的所有潜在因素的一小部分。我想听听你的经历。你觉得最诡异的围棋特点是什么？</p></div></div>    
</body>
</html>