<html>
<head>
<title>Better Null-Handling With Java Optionals</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用Java选项更好地处理空值</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/better-null-handling-with-java-optionals-4793a8566710?source=collection_archive---------4-----------------------#2019-12-17">https://betterprogramming.pub/better-null-handling-with-java-optionals-4793a8566710?source=collection_archive---------4-----------------------#2019-12-17</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="f0fd" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">可怕的<code class="fe ki kj kk kl b">NullPointerException</code>是许多Java开发人员的祸根</h2></div><figure class="kn ko kp kq gt kr gh gi paragraph-image"><div role="button" tabindex="0" class="ks kt di ku bf kv"><div class="gh gi km"><img src="../Images/7d017641bb72fdb463747bc1497488b8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*nAF7aO9x8QX0LObMXeLDgg.jpeg"/></div></div><p class="ky kz gj gh gi la lb bd b be z dk translated"><a class="ae lc" href="https://unsplash.com/photos/OEdSGyyRWgs" rel="noopener ugc nofollow" target="_blank">https://unsplash.com/photos/OEdSGyyRWgs</a></p></figure><p id="17f5" class="pw-post-body-paragraph ld le it lf b lg lh ju li lj lk jx ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated">在Java 8之前，处理<code class="fe ki kj kk kl b">null</code> <em class="lz"> </em>引用最好的方法就是处处检查变量。新的阶层<code class="fe ki kj kk kl b">java.util.Optional&lt;T&gt;</code>极大地改变了这一点。</p><p id="c66b" class="pw-post-body-paragraph ld le it lf b lg lh ju li lj lk jx ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated">但首先，一些历史和与其他语言的比较。</p></div><div class="ab cl ma mb hx mc" role="separator"><span class="md bw bk me mf mg"/><span class="md bw bk me mf mg"/><span class="md bw bk me mf"/></div><div class="im in io ip iq"><h1 id="1e79" class="mh mi it bd mj mk ml mm mn mo mp mq mr jz ms ka mt kc mu kd mv kf mw kg mx my bi translated">一个十亿美元的错误</h1><p id="29ce" class="pw-post-body-paragraph ld le it lf b lg mz ju li lj na jx ll lm nb lo lp lq nc ls lt lu nd lw lx ly im bi translated">空引用的<a class="ae lc" href="https://en.wikipedia.org/wiki/Tony_Hoare" rel="noopener ugc nofollow" target="_blank">发明者</a>于2009年为其创造道歉:</p><blockquote class="ne nf ng"><p id="d409" class="ld le lz lf b lg lh ju li lj lk jx ll nh ln lo lp ni lr ls lt nj lv lw lx ly im bi translated">我称之为我的十亿美元错误。这是1965年零引用的发明。当时，我正在用面向对象语言(ALGOL W)设计第一个用于引用的综合类型系统。</p><p id="fc93" class="ld le lz lf b lg lh ju li lj lk jx ll nh ln lo lp ni lr ls lt nj lv lw lx ly im bi translated">我的目标是确保引用的所有使用都是绝对安全的，由编译器自动执行检查。但是我无法抗拒放入空引用的诱惑，仅仅是因为它太容易实现了。</p><p id="7e1f" class="ld le lz lf b lg lh ju li lj lk jx ll nh ln lo lp ni lr ls lt nj lv lw lx ly im bi translated">这导致了数不清的错误、漏洞和系统崩溃，在过去的四十年里，这些可能造成了数十亿美元的痛苦和损失。—查尔斯·安东尼·理查德·霍尔爵士2009年在伦敦QCon</p></blockquote><p id="3e97" class="pw-post-body-paragraph ld le it lf b lg lh ju li lj lk jx ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated">编程语言处理这种“错误”的方式非常不同。他们中的许多人都有处理<code class="fe ki kj kk kl b">null</code>的适当方法，直接集成到语言本身中。</p><p id="4911" class="pw-post-body-paragraph ld le it lf b lg lh ju li lj lk jx ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated"><a class="ae lc" href="http://groovy-lang.org/" rel="noopener ugc nofollow" target="_blank"> Groovy </a>，<a class="ae lc" href="https://developer.apple.com/swift/" rel="noopener ugc nofollow" target="_blank"> Swift </a>，<a class="ae lc" href="https://www.ruby-lang.org/en/" rel="noopener ugc nofollow" target="_blank"> Ruby </a>，<a class="ae lc" href="https://kotlinlang.org/" rel="noopener ugc nofollow" target="_blank"> Kotlin </a>，<a class="ae lc" href="https://docs.microsoft.com/en-us/dotnet/csharp/" rel="noopener ugc nofollow" target="_blank"> C# </a>，更支持一个<a class="ae lc" href="https://en.wikipedia.org/wiki/Safe_navigation_operator" rel="noopener ugc nofollow" target="_blank">安全导航操作符</a> : <code class="fe ki kj kk kl b">.?</code>，或者在Ruby的情况下<code class="fe ki kj kk kl b">&amp;.</code>。</p><p id="186d" class="pw-post-body-paragraph ld le it lf b lg lh ju li lj lk jx ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated">其他语言，如<a class="ae lc" href="https://developer.apple.com/library/archive/documentation/Cocoa/Conceptual/ObjectiveC/Introduction/introObjectiveC.html" rel="noopener ugc nofollow" target="_blank"> Objective-C </a>或<a class="ae lc" href="https://clojure.org/" rel="noopener ugc nofollow" target="_blank"> Clojure </a>，决定嵌入更好的空处理。是时候用一些不同的方法来处理空值了。</p></div><div class="ab cl ma mb hx mc" role="separator"><span class="md bw bk me mf mg"/><span class="md bw bk me mf mg"/><span class="md bw bk me mf"/></div><div class="im in io ip iq"><h1 id="2742" class="mh mi it bd mj mk ml mm mn mo mp mq mr jz ms ka mt kc mu kd mv kf mw kg mx my bi translated">迅速发生的</h1><p id="4b00" class="pw-post-body-paragraph ld le it lf b lg mz ju li lj na jx ll lm nb lo lp lq nc ls lt lu nd lw lx ly im bi translated">在<a class="ae lc" href="https://swift.org/" rel="noopener ugc nofollow" target="_blank"> Swift </a>中，空引用被称为nil。该语言对可选类型和<code class="fe ki kj kk kl b">nil</code>处理有很好的支持。在它的帮助下，我们可以安全地调用属性，甚至流畅地将它们链接在一起:</p><figure class="kn ko kp kq gt kr"><div class="bz fp l di"><div class="nk nl l"/></div></figure><p id="c09b" class="pw-post-body-paragraph ld le it lf b lg lh ju li lj lk jx ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated">结合一个<a class="ae lc" href="https://en.wikipedia.org/wiki/Null_coalescing_operator" rel="noopener ugc nofollow" target="_blank">零合并操作符</a>，我们可以做得更好，并且不必处理可选类型:</p><figure class="kn ko kp kq gt kr"><div class="bz fp l di"><div class="nk nl l"/></div></figure></div><div class="ab cl ma mb hx mc" role="separator"><span class="md bw bk me mf mg"/><span class="md bw bk me mf mg"/><span class="md bw bk me mf"/></div><div class="im in io ip iq"><h1 id="f135" class="mh mi it bd mj mk ml mm mn mo mp mq mr jz ms ka mt kc mu kd mv kf mw kg mx my bi translated">Clojure</h1><p id="ddf3" class="pw-post-body-paragraph ld le it lf b lg mz ju li lj na jx ll lm nb lo lp lq nc ls lt lu nd lw lx ly im bi translated">这篇文章是关于Java的，所以让我们看一个来自另一种JVM语言的例子。对于空引用，Clojure 也倾向于nil。</p><p id="0134" class="pw-post-body-paragraph ld le it lf b lg lh ju li lj lk jx ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated">但是Clojure没有提供一个安全的导航操作器来解决这个问题，而是决定尝试去掉<code class="fe ki kj kk kl b">NullPointerException</code>。</p><p id="3671" class="pw-post-body-paragraph ld le it lf b lg lh ju li lj lk jx ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated">即使nil等于Java的<code class="fe ki kj kk kl b">null</code>，它也只是另一种值类型。只有nil的一个实例存在，它测试到<code class="fe ki kj kk kl b">false</code>。</p><p id="2d20" class="pw-post-body-paragraph ld le it lf b lg lh ju li lj lk jx ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated">仍然有可能遇到一个<code class="fe ki kj kk kl b">NullPointerException</code>，但是如果你按照预期的方式使用Clojure，那就更难了。由于nil是一个表示空的值，而不是空无一物，所以处理和合并到您的代码中要容易得多。</p></div><div class="ab cl ma mb hx mc" role="separator"><span class="md bw bk me mf mg"/><span class="md bw bk me mf mg"/><span class="md bw bk me mf"/></div><div class="im in io ip iq"><h1 id="cd78" class="mh mi it bd mj mk ml mm mn mo mp mq mr jz ms ka mt kc mu kd mv kf mw kg mx my bi translated">目标-C</h1><p id="a2c8" class="pw-post-body-paragraph ld le it lf b lg mz ju li lj na jx ll lm nb lo lp lq nc ls lt lu nd lw lx ly im bi translated">作为一种受Smalltalk启发的语言，Objective-C不调用方法或字段，而是向对象发送消息。并且向nil发送消息不会引发异常，那么消息将会无声无息地失败。</p><p id="a54d" class="pw-post-body-paragraph ld le it lf b lg lh ju li lj lk jx ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated">这可能很好，你不必检查所有的东西，但这也是不好的，因为你可能没有意识到一条消息没有得到回复。</p></div><div class="ab cl ma mb hx mc" role="separator"><span class="md bw bk me mf mg"/><span class="md bw bk me mf mg"/><span class="md bw bk me mf"/></div><div class="im in io ip iq"><h1 id="2d6c" class="mh mi it bd mj mk ml mm mn mo mp mq mr jz ms ka mt kc mu kd mv kf mw kg mx my bi translated">Java选项</h1><p id="5a97" class="pw-post-body-paragraph ld le it lf b lg mz ju li lj na jx ll lm nb lo lp lq nc ls lt lu nd lw lx ly im bi translated">随着Java 8的发布，以新类的形式提供了一种处理<code class="fe ki kj kk kl b">null</code>引用的直接方式:<code class="fe ki kj kk kl b">java.util.Optional&lt;T&gt;</code>。</p><p id="53e4" class="pw-post-body-paragraph ld le it lf b lg lh ju li lj lk jx ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated">它是其他对象的一个薄薄的包装，所以如果包含的对象不存在，您可以直接与<code class="fe ki kj kk kl b">Optional</code>而不是空引用进行交互。</p><h2 id="1c84" class="nm mi it bd mj nn no dn mn np nq dp mr lm nr ns mt lq nt nu mv lu nv nw mx nx bi translated">创建选项</h2><p id="ec8c" class="pw-post-body-paragraph ld le it lf b lg mz ju li lj na jx ll lm nb lo lp lq nc ls lt lu nd lw lx ly im bi translated">可选件的创建方式有多种:</p><figure class="kn ko kp kq gt kr"><div class="bz fp l di"><div class="nk nl l"/></div></figure><p id="0e28" class="pw-post-body-paragraph ld le it lf b lg lh ju li lj lk jx ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated">每个案例都有其存在的理由:</p><ul class=""><li id="8ace" class="ny nz it lf b lg lh lj lk lm oa lq ob lu oc ly od oe of og bi translated">案例一。我们知道/需要一个价值:即使期权是处理<code class="fe ki kj kk kl b">NullPointerExceptions</code>的好方法，如果我们真的需要一个呢？仅仅因为API设计使用了选项，就可能需要在特定情况下抛出异常。这就是<code class="fe ki kj kk kl b">Optional#of(...)</code>的作用，它不接受空值。</li><li id="4bd2" class="ny nz it lf b lg oh lj oi lm oj lq ok lu ol ly od oe of og bi translated">案例二。我们不确定:最常用的创作形式。不执行空值检查。</li><li id="d337" class="ny nz it lf b lg oh lj oi lm oj lq ok lu ol ly od oe of og bi translated">案例三。我们确信没有值:<code class="fe ki kj kk kl b">Optional.empty()</code>返回一个<code class="fe ki kj kk kl b">static final</code>字段。没有必要在每次空的时候都创建一个新的可选的，我们肯定知道它。</li></ul><h2 id="73cb" class="nm mi it bd mj nn no dn mn np nq dp mr lm nr ns mt lq nt nu mv lu nv nw mx nx bi translated">检查值</h2><p id="97ec" class="pw-post-body-paragraph ld le it lf b lg mz ju li lj na jx ll lm nb lo lp lq nc ls lt lu nd lw lx ly im bi translated">最简单的检查方法是<code class="fe ki kj kk kl b">Optional#isPresent()</code>:</p><figure class="kn ko kp kq gt kr"><div class="bz fp l di"><div class="nk nl l"/></div></figure><p id="07f6" class="pw-post-body-paragraph ld le it lf b lg lh ju li lj lk jx ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated">为了不总是检查<code class="fe ki kj kk kl b">false</code>，Java 11引入了<code class="fe ki kj kk kl b">Optional#isEmpty()</code>。</p><h2 id="28e3" class="nm mi it bd mj nn no dn mn np nq dp mr lm nr ns mt lq nt nu mv lu nv nw mx nx bi translated">获取内部值</h2><p id="da8e" class="pw-post-body-paragraph ld le it lf b lg mz ju li lj na jx ll lm nb lo lp lq nc ls lt lu nd lw lx ly im bi translated">仅仅检查一个值是否存在并没有太大的帮助，我们想要使用它！最简单的方法是<code class="fe ki kj kk kl b">get()</code>:</p><figure class="kn ko kp kq gt kr"><div class="bz fp l di"><div class="nk nl l"/></div></figure><p id="4956" class="pw-post-body-paragraph ld le it lf b lg lh ju li lj lk jx ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated">恭喜，我们刚刚抛出了一个异常！即使它不是一个<code class="fe ki kj kk kl b">NullPointerException</code>，也一定有一个比我们每次使用选项都检查<code class="fe ki kj kk kl b">isPresent()</code>更好的方法。</p></div><div class="ab cl ma mb hx mc" role="separator"><span class="md bw bk me mf mg"/><span class="md bw bk me mf mg"/><span class="md bw bk me mf"/></div><div class="im in io ip iq"><h1 id="68c6" class="mh mi it bd mj mk ml mm mn mo mp mq mr jz ms ka mt kc mu kd mv kf mw kg mx my bi translated">更好的方法</h1><p id="6b15" class="pw-post-body-paragraph ld le it lf b lg mz ju li lj na jx ll lm nb lo lp lq nc ls lt lu nd lw lx ly im bi translated">在真正的代码中，我们不只是想得到内部的值。相反，我们想和它一起工作。感谢<a class="ae lc" href="https://docs.oracle.com/javase/tutorial/java/javaOO/lambdaexpressions.html" rel="noopener ugc nofollow" target="_blank"> lambda表达式</a>，我们可以轻松而懒散地做到这一点。</p><p id="3bc3" class="pw-post-body-paragraph ld le it lf b lg lh ju li lj lk jx ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated">在我们得到期权之前，处理价值的通常方式是这样的:</p><figure class="kn ko kp kq gt kr"><div class="bz fp l di"><div class="nk nl l"/></div></figure><p id="cce6" class="pw-post-body-paragraph ld le it lf b lg lh ju li lj lk jx ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated">通过选项，我们可以将这段代码压缩到一个易读的单一方法调用链中:</p><figure class="kn ko kp kq gt kr"><div class="bz fp l di"><div class="nk nl l"/></div></figure><p id="8ce3" class="pw-post-body-paragraph ld le it lf b lg lh ju li lj lk jx ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated"><code class="fe ki kj kk kl b">Optional#map(...)</code>只有在可选项实际包含一个值时才会被调用，否则，<code class="fe ki kj kk kl b">Optional#orElse(...)</code>会被调用。</p></div><div class="ab cl ma mb hx mc" role="separator"><span class="md bw bk me mf mg"/><span class="md bw bk me mf mg"/><span class="md bw bk me mf"/></div><div class="im in io ip iq"><h1 id="5bcd" class="mh mi it bd mj mk ml mm mn mo mp mq mr jz ms ka mt kc mu kd mv kf mw kg mx my bi translated">零合并</h1><p id="e9ae" class="pw-post-body-paragraph ld le it lf b lg mz ju li lj na jx ll lm nb lo lp lq nc ls lt lu nd lw lx ly im bi translated">Java不像其他语言那样支持空合并操作符:</p><figure class="kn ko kp kq gt kr"><div class="bz fp l di"><div class="nk nl l"/></div></figure><p id="2ed4" class="pw-post-body-paragraph ld le it lf b lg lh ju li lj lk jx ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated">对于可选件，我们可以通过使用<code class="fe ki kj kk kl b">Optional#orElse</code>来使用相同的模式，中间没有任何额外的动作:</p><figure class="kn ko kp kq gt kr"><div class="bz fp l di"><div class="nk nl l"/></div></figure></div><div class="ab cl ma mb hx mc" role="separator"><span class="md bw bk me mf mg"/><span class="md bw bk me mf mg"/><span class="md bw bk me mf"/></div><div class="im in io ip iq"><h1 id="fd82" class="mh mi it bd mj mk ml mm mn mo mp mq mr jz ms ka mt kc mu kd mv kf mw kg mx my bi translated">行动和替代方案</h1><p id="e25c" class="pw-post-body-paragraph ld le it lf b lg mz ju li lj na jx ll lm nb lo lp lq nc ls lt lu nd lw lx ly im bi translated"><code class="fe ki kj kk kl b">java.util.Optional</code>的方法大致可以分为两组:动作和替代。</p><h2 id="d485" class="nm mi it bd mj nn no dn mn np nq dp mr lm nr ns mt lq nt nu mv lu nv nw mx nx bi translated">行动</h2><ul class=""><li id="a532" class="ny nz it lf b lg mz lj na lm om lq on lu oo ly od oe of og bi translated"><code class="fe ki kj kk kl b"><a class="ae lc" href="https://docs.oracle.com/javase/8/docs/api/java/util/Optional.html#map-java.util.function.Function-" rel="noopener ugc nofollow" target="_blank">map(Function&lt;? super T,? extends U&gt; mapper)</a></code> <br/>如果存在一个值，将应用映射函数，并返回一个新的可选结果。否则，将返回一个空的可选项。</li><li id="9681" class="ny nz it lf b lg oh lj oi lm oj lq ok lu ol ly od oe of og bi translated"><code class="fe ki kj kk kl b"><a class="ae lc" href="https://docs.oracle.com/javase/8/docs/api/java/util/Optional.html#flatMap-java.util.function.Function-" rel="noopener ugc nofollow" target="_blank">flatMap(Function&lt;? super T,Optional&lt;U&gt;&gt; mapper)</a><br/></code>与<code class="fe ki kj kk kl b">map(...)</code>相似，但可以自己处理选项。</li><li id="9c7e" class="ny nz it lf b lg oh lj oi lm oj lq ok lu ol ly od oe of og bi translated"><code class="fe ki kj kk kl b"><a class="ae lc" href="https://docs.oracle.com/javase/8/docs/api/java/util/Optional.html#filter-java.util.function.Predicate-" rel="noopener ugc nofollow" target="_blank">filter(Predicate&lt;? super T&gt; predicate)</a><br/></code>如果一个值存在并且与谓词匹配，则返回可选的。否则，将返回一个空的可选项。</li><li id="2d96" class="ny nz it lf b lg oh lj oi lm oj lq ok lu ol ly od oe of og bi translated"><code class="fe ki kj kk kl b"><a class="ae lc" href="https://docs.oracle.com/javase/8/docs/api/java/util/Optional.html#ifPresent-java.util.function.Consumer-" rel="noopener ugc nofollow" target="_blank">ifPresent(Consumer&lt;? super T&gt; consumer)</a><br/></code>只有值存在时，才会调用消费者。</li></ul><h2 id="3985" class="nm mi it bd mj nn no dn mn np nq dp mr lm nr ns mt lq nt nu mv lu nv nw mx nx bi translated">可供选择的事物</h2><p id="013b" class="pw-post-body-paragraph ld le it lf b lg mz ju li lj na jx ll lm nb lo lp lq nc ls lt lu nd lw lx ly im bi translated">从<code class="fe ki kj kk kl b">or</code>开始，在没有价值的情况下提供替代方案的方法:</p><ul class=""><li id="12c5" class="ny nz it lf b lg lh lj lk lm oa lq ob lu oc ly od oe of og bi translated"><code class="fe ki kj kk kl b"><a class="ae lc" href="https://docs.oracle.com/javase/8/docs/api/java/util/Optional.html#orElse-T-" rel="noopener ugc nofollow" target="_blank">orElse(T other)</a><br/></code>如果没有值，则返回<code class="fe ki kj kk kl b">other</code>。</li><li id="1038" class="ny nz it lf b lg oh lj oi lm oj lq ok lu ol ly od oe of og bi translated"><code class="fe ki kj kk kl b"><a class="ae lc" href="https://docs.oracle.com/javase/8/docs/api/java/util/Optional.html#orElseGet-java.util.function.Supplier-" rel="noopener ugc nofollow" target="_blank">orElseGet(Supplier&lt;? extends T&gt; other)</a><br/></code>如果在可选的。</li><li id="c97a" class="ny nz it lf b lg oh lj oi lm oj lq ok lu ol ly od oe of og bi translated"><code class="fe ki kj kk kl b"><a class="ae lc" href="https://docs.oracle.com/javase/8/docs/api/java/util/Optional.html#orElseThrow-java.util.function.Supplier-" rel="noopener ugc nofollow" target="_blank">orElseThrow(Supplier&lt;? extends X&gt; exceptionSupplier)</a><br/></code>如果不存在任何值，则调用供应商进行例外处理，例如<code class="fe ki kj kk kl b">orElseThrow(IllegalArgumentException::new)</code>。</li></ul></div><div class="ab cl ma mb hx mc" role="separator"><span class="md bw bk me mf mg"/><span class="md bw bk me mf mg"/><span class="md bw bk me mf"/></div><div class="im in io ip iq"><h1 id="6b8e" class="mh mi it bd mj mk ml mm mn mo mp mq mr jz ms ka mt kc mu kd mv kf mw kg mx my bi translated">原始数据类型</h1><p id="5db7" class="pw-post-body-paragraph ld le it lf b lg mz ju li lj na jx ll lm nb lo lp lq nc ls lt lu nd lw lx ly im bi translated">由于<code class="fe ki kj kk kl b">java.util.Optional&lt;T&gt;</code>是泛型类型，我们应该如何处理像<code class="fe ki kj kk kl b">int</code>或<code class="fe ki kj kk kl b">long</code>这样的原始数据类型？</p><p id="d745" class="pw-post-body-paragraph ld le it lf b lg lh ju li lj lk jx ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated">当然，原语永远不可能是<code class="fe ki kj kk kl b">null</code>，但这不一定是一件好事。与未初始化/默认值相比，能够表示空值是一个优势。</p><p id="08d1" class="pw-post-body-paragraph ld le it lf b lg lh ju li lj lk jx ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated">处理原语的一种方式是不使用它们，而是依赖于它们对应的对象包装类，例如<code class="fe ki kj kk kl b">int -&gt; Integer</code>。但是这只会产生来自<a class="ae lc" href="https://docs.oracle.com/javase/tutorial/java/data/autoboxing.html" rel="noopener ugc nofollow" target="_blank">自动装箱/拆箱</a>的开销。</p><p id="373f" class="pw-post-body-paragraph ld le it lf b lg lh ju li lj lk jx ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated">在<a class="ae lc" href="https://wiki.openjdk.java.net/display/valhalla/Main" rel="noopener ugc nofollow" target="_blank">项目Valhalla </a>及其改进的值类型处理对我们可用之前，我们可以使用专门的可选类来使用基本数据类型的可选功能:</p><ul class=""><li id="173e" class="ny nz it lf b lg lh lj lk lm oa lq ob lu oc ly od oe of og bi translated"><code class="fe ki kj kk kl b">java.util.OptionalDouble</code></li><li id="af62" class="ny nz it lf b lg oh lj oi lm oj lq ok lu ol ly od oe of og bi translated"><code class="fe ki kj kk kl b">java.util.OptionalInt</code></li><li id="86ff" class="ny nz it lf b lg oh lj oi lm oj lq ok lu ol ly od oe of og bi translated"><code class="fe ki kj kk kl b">java.util.OptionalLong</code></li></ul><p id="5441" class="pw-post-body-paragraph ld le it lf b lg lh ju li lj lk jx ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated">仍然缺少一些原始数据类型，但这是一个开始。而且，他们缺乏所有的行动方法，除了<code class="fe ki kj kk kl b">ifPresent(LongConsumer consumer)</code>。</p></div><div class="ab cl ma mb hx mc" role="separator"><span class="md bw bk me mf mg"/><span class="md bw bk me mf mg"/><span class="md bw bk me mf"/></div><div class="im in io ip iq"><h1 id="bb72" class="mh mi it bd mj mk ml mm mn mo mp mq mr jz ms ka mt kc mu kd mv kf mw kg mx my bi translated">警告</h1><p id="6c02" class="pw-post-body-paragraph ld le it lf b lg mz ju li lj na jx ll lm nb lo lp lq nc ls lt lu nd lw lx ly im bi translated">选项就像任何其他对象一样是Java对象，所以它们本身可能是<code class="fe ki kj kk kl b">null</code>。如果我们设计一个API并决定使用可选的，我们<em class="lz">不能</em>返回<code class="fe ki kj kk kl b">null</code>为可选的，<em class="lz">总是</em>使用<code class="fe ki kj kk kl b">Optional.empty()</code>。</p><p id="72f5" class="pw-post-body-paragraph ld le it lf b lg lh ju li lj lk jx ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated">这必须按照惯例来执行，编译器不能帮助我们，除非使用额外的工具和<code class="fe ki kj kk kl b">@NonNull</code>注释。</p><p id="f9c5" class="pw-post-body-paragraph ld le it lf b lg lh ju li lj lk jx ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated">其他我们不应该直接与可选项一起使用的标准Java特性是关于等式的:<code class="fe ki kj kk kl b">equals(...)</code>和<code class="fe ki kj kk kl b">hashCode()</code>首先是关于比较可选项，其次才是关于值。</p><p id="c52e" class="pw-post-body-paragraph ld le it lf b lg lh ju li lj lk jx ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated">文档警告我们，结果可能是不可预测的。</p></div><div class="ab cl ma mb hx mc" role="separator"><span class="md bw bk me mf mg"/><span class="md bw bk me mf mg"/><span class="md bw bk me mf"/></div><div class="im in io ip iq"><h1 id="4cd6" class="mh mi it bd mj mk ml mm mn mo mp mq mr jz ms ka mt kc mu kd mv kf mw kg mx my bi translated">结论</h1><p id="2455" class="pw-post-body-paragraph ld le it lf b lg mz ju li lj na jx ll lm nb lo lp lq nc ls lt lu nd lw lx ly im bi translated">选项是以更简洁的方式处理空引用的好方法。我们可以替换许多<code class="fe ki kj kk kl b">if-else</code>结构，甚至合并lambda表达式。</p><p id="d456" class="pw-post-body-paragraph ld le it lf b lg lh ju li lj lk jx ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated">因此，如果可能和适用的话，我们应该用选项来设计我们的API，而不是使用<code class="fe ki kj kk kl b">null</code>。甚至原语在一定程度上也是可用的，所以在我们的下一个项目中没有理由使用可选的。</p></div><div class="ab cl ma mb hx mc" role="separator"><span class="md bw bk me mf mg"/><span class="md bw bk me mf mg"/><span class="md bw bk me mf"/></div><div class="im in io ip iq"><pre class="kn ko kp kq gt op kl oq bn or os bi"><span id="b5d5" class="ot mi it kl b be ou ov l ow ox"><strong class="kl iu">You like my ramblings about Java? Check out my upcoming book!</strong><br/><a class="ae lc" href="https://belief-driven-design.com/book/" rel="noopener ugc nofollow" target="_blank">https://belief-driven-design.com/book/</a></span></pre><h1 id="249a" class="mh mi it bd mj mk oy mm mn mo oz mq mr jz pa ka mt kc pb kd mv kf pc kg mx my bi translated">资源</h1><ul class=""><li id="c3b7" class="ny nz it lf b lg mz lj na lm om lq on lu oo ly od oe of og bi translated"><a class="ae lc" href="https://en.wikipedia.org/wiki/Null_pointer" rel="noopener ugc nofollow" target="_blank">空指针</a>(维基百科</li><li id="fe65" class="ny nz it lf b lg oh lj oi lm oj lq ok lu ol ly od oe of og bi translated"><a class="ae lc" href="https://docs.oracle.com/javase/8/docs/api/java/util/Optional.html" rel="noopener ugc nofollow" target="_blank">可选件</a>(甲骨文)</li><li id="6cb5" class="ny nz it lf b lg oh lj oi lm oj lq ok lu ol ly od oe of og bi translated"><a class="ae lc" href="https://www.oracle.com/technical-resources/articles/java/java8-optional.html" rel="noopener ugc nofollow" target="_blank"> Java 8选项</a>(甲骨文)</li><li id="e93f" class="ny nz it lf b lg oh lj oi lm oj lq ok lu ol ly od oe of og bi translated"><a class="ae lc" href="https://livebook.manning.com/book/java-8-in-action/chapter-10?origin=product-toc" rel="noopener ugc nofollow" target="_blank">运行中的Java 8</a>(曼宁)</li><li id="dd57" class="ny nz it lf b lg oh lj oi lm oj lq ok lu ol ly od oe of og bi translated"><a class="ae lc" href="https://wiki.openjdk.java.net/display/valhalla/Main" rel="noopener ugc nofollow" target="_blank">瓦尔哈拉</a> (OpenJDK)</li></ul></div></div>    
</body>
</html>