<html>
<head>
<title>How to Persist Transforming Logic with Swift Combine</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何坚持转换逻辑与快速合并</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/persist-transforming-logic-with-swift-combine-84238accf1fa?source=collection_archive---------16-----------------------#2020-02-18">https://betterprogramming.pub/persist-transforming-logic-with-swift-combine-84238accf1fa?source=collection_archive---------16-----------------------#2020-02-18</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="1598" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">数据驱动联合收割机</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi ki"><img src="../Images/2b73df4bdc7e1f68ad1b64b80fee1bde.png" data-original-src="https://miro.medium.com/v2/resize:fit:1152/format:webp/1*JoLBOaFHtT5lX_MQADEexA.png"/></div></figure><p id="9ec0" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">上一集我们序列化持久化了过滤逻辑，并成功反序列化回<code class="fe lm ln lo lp b">Combine Publishers</code>。</p><p id="2940" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">今天，我们将在转换逻辑上表演同样的魔术。我们将对<code class="fe lm ln lo lp b">map and scan</code>的逻辑进行建模、序列化、反序列化，最后用给定的上游值运行逻辑。</p></div><div class="ab cl lq lr hx ls" role="separator"><span class="lt bw bk lu lv lw"/><span class="lt bw bk lu lv lw"/><span class="lt bw bk lu lv"/></div><div class="im in io ip iq"><h1 id="0112" class="lx ly it bd lz ma mb mc md me mf mg mh jz mi ka mj kc mk kd ml kf mm kg mn mo bi translated">转换运算符</h1><p id="03de" class="pw-post-body-paragraph kq kr it ks b kt mp ju kv kw mq jx ky kz mr lb lc ld ms lf lg lh mt lj lk ll im bi translated">变换操作符变换由<code class="fe lm ln lo lp b">Publisher</code>发出的项目。</p></div><div class="ab cl lq lr hx ls" role="separator"><span class="lt bw bk lu lv lw"/><span class="lt bw bk lu lv lw"/><span class="lt bw bk lu lv"/></div><div class="im in io ip iq"><h1 id="037a" class="lx ly it bd lz ma mb mc md me mf mg mh jz mi ka mj kc mk kd ml kf mm kg mn mo bi translated">地图操作员</h1><p id="c149" class="pw-post-body-paragraph kq kr it ks b kt mp ju kv kw mq jx ky kz mr lb lc ld ms lf lg lh mt lj lk ll im bi translated"><code class="fe lm ln lo lp b">map</code>操作符通过对每个项目应用一个函数来转换由<code class="fe lm ln lo lp b">Publisher</code>发出的项目。下面的GIF展示了一个例子，说明了<code class="fe lm ln lo lp b">map</code>操作符如何转换整数并将它们乘以2。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi mu"><img src="../Images/416786e0fdbaac19b8ea128e65d1a990.png" data-original-src="https://miro.medium.com/v2/resize:fit:600/1*GU5aDxi550UGWIxbKpgGoA.gif"/></div><p class="mv mw gj gh gi mx my bd b be z dk translated">。地图{ $0 * 2 }</p></figure><p id="f2de" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">如果你有兴趣了解动画视图是如何创建的，可以看看系列<a class="ae mz" href="https://medium.com/better-programming/visualize-combine-magic-with-swiftui-part-2-2c613370388b" rel="noopener">可视化结合魔术和SwiftUI </a>。</p></div><div class="ab cl lq lr hx ls" role="separator"><span class="lt bw bk lu lv lw"/><span class="lt bw bk lu lv lw"/><span class="lt bw bk lu lv"/></div><div class="im in io ip iq"><h1 id="64d3" class="lx ly it bd lz ma mb mc md me mf mg mh jz mi ka mj kc mk kd ml kf mm kg mn mo bi translated">持久映射逻辑</h1><p id="3698" class="pw-post-body-paragraph kq kr it ks b kt mp ju kv kw mq jx ky kz mr lb lc ld ms lf lg lh mt lj lk ll im bi translated">为了序列化转换逻辑，我们必须将业务逻辑、函数或闭包转换成可编码的原始类型。</p><p id="ab96" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">就像我们之前的<a class="ae mz" href="https://medium.com/better-programming/persist-filtering-logics-with-swift-combine-6c3594be77cc" rel="noopener">持续过滤逻辑</a>一样，我们在这里使用一个字符串表达式。例如，<code class="fe lm ln lo lp b">%d * 2</code>不仅解释了主要逻辑，还暗示了结果将是整数类型。</p><pre class="kj kk kl km gt na lp nb nc aw nd bi"><span id="40e9" class="ne ly it lp b gy nf ng l nh ni"><strong class="lp iu">enum</strong> TransformingOperator: Codable {<br/>  <strong class="lp iu">case</strong> <strong class="lp iu">map</strong>(expression: String)<br/>}</span></pre><p id="0162" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">注意<code class="fe lm ln lo lp b">TransformingOperator</code>是一个<code class="fe lm ln lo lp b">Codable</code>枚举。我们将在本章末尾附上完整的定制一致性。</p></div><div class="ab cl lq lr hx ls" role="separator"><span class="lt bw bk lu lv lw"/><span class="lt bw bk lu lv lw"/><span class="lt bw bk lu lv"/></div><div class="im in io ip iq"><h1 id="90f9" class="lx ly it bd lz ma mb mc md me mf mg mh jz mi ka mj kc mk kd ml kf mm kg mn mo bi translated">使用NSExpression映射</h1><p id="9433" class="pw-post-body-paragraph kq kr it ks b kt mp ju kv kw mq jx ky kz mr lb lc ld ms lf lg lh mt lj lk ll im bi translated">不像过滤操作符可以简单地使用带有布尔类型的<code class="fe lm ln lo lp b">NSPredicate</code>作为结果，这里我们在最后使用带有类型转换的<code class="fe lm ln lo lp b">NSExpression</code>来实现这种动态计算。我们用代表映射逻辑的<code class="fe lm ln lo lp b">NSExpression</code>映射给定的<code class="fe lm ln lo lp b">Publisher</code>。然后我们将上游值作为一个参数传递给<code class="fe lm ln lo lp b">NSExpression</code>。请注意，这是一个通用方法，因为我们希望能够将来自<code class="fe lm ln lo lp b">NSExpression</code>的结果转换为与给定的<code class="fe lm ln lo lp b">Publisher</code>相同的类型。</p><pre class="kj kk kl km gt na lp nb nc aw nd bi"><span id="2c5c" class="ne ly it lp b gy nf ng l nh ni"><strong class="lp iu">extension</strong> TransformingOperator {</span><span id="ec8c" class="ne ly it lp b gy nj ng l nh ni"><strong class="lp iu">func</strong> applyPublisher&lt;Output: Numeric&gt;(<strong class="lp iu">_</strong> publisher: AnyPublisher&lt;Output, Never&gt;) -&gt; AnyPublisher&lt;Output, Never&gt; {<strong class="lp iu">  <br/>  switch</strong> <strong class="lp iu">self</strong> {<br/><strong class="lp iu">    case</strong> .map(<strong class="lp iu">let</strong> expression):<br/>    <strong class="lp iu">return</strong> publisher.map { value <strong class="lp iu">in<br/>             </strong>NSExpression(format: expression, <br/>                          argumentArray: [value])<br/>             .expressionValue(with: <strong class="lp iu">nil</strong>, context: <strong class="lp iu">nil</strong>) <strong class="lp iu">as!</strong> Output<br/>           }.eraseToAnyPublisher()<br/>}}</span></pre><p id="ad77" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">现在我们将<code class="fe lm ln lo lp b">map</code>操作符应用于给定的<code class="fe lm ln lo lp b">Publisher</code>。不仅仅是映射逻辑被保留，我们还可以通过在运行时改变表达式来改变它，如下所示:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi mu"><img src="../Images/ab235d411fd05ec4de305cb063315c1d.png" data-original-src="https://miro.medium.com/v2/resize:fit:600/1*9c6Aa5y6gFtHM3a9pqfZww.gif"/></div></figure></div><div class="ab cl lq lr hx ls" role="separator"><span class="lt bw bk lu lv lw"/><span class="lt bw bk lu lv lw"/><span class="lt bw bk lu lv"/></div><div class="im in io ip iq"><h1 id="2eda" class="lx ly it bd lz ma mb mc md me mf mg mh jz mi ka mj kc mk kd ml kf mm kg mn mo bi translated">扫描操作员</h1><p id="37ac" class="pw-post-body-paragraph kq kr it ks b kt mp ju kv kw mq jx ky kz mr lb lc ld ms lf lg lh mt lj lk ll im bi translated"><code class="fe lm ln lo lp b"><a class="ae mz" href="https://developer.apple.com/documentation/combine/publishers/combinelatest/3229133-scan" rel="noopener ugc nofollow" target="_blank">Scan</a></code>依次对由<code class="fe lm ln lo lp b">Publisher</code>发出的每个项目应用一个函数，并发出每个连续的值。下面是一个<code class="fe lm ln lo lp b">scan</code>操作的例子，它显示了所有上游数字的总和列表:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi mu"><img src="../Images/24b10e60516a9bd673f2e5824d9d2065.png" data-original-src="https://miro.medium.com/v2/resize:fit:600/1*TN09c8kg9BBlyqRv7haStw.gif"/></div></figure><p id="57ad" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">同样，你可以在以前的系列中找到SwiftUI模拟，<a class="ae mz" href="https://medium.com/better-programming/visualize-combine-magic-with-swiftui-part-2-2c613370388b" rel="noopener">可视化将Magic与SwiftUI </a>结合。</p></div><div class="ab cl lq lr hx ls" role="separator"><span class="lt bw bk lu lv lw"/><span class="lt bw bk lu lv lw"/><span class="lt bw bk lu lv"/></div><div class="im in io ip iq"><h1 id="c3a1" class="lx ly it bd lz ma mb mc md me mf mg mh jz mi ka mj kc mk kd ml kf mm kg mn mo bi translated">扫描挑战</h1><p id="b03b" class="pw-post-body-paragraph kq kr it ks b kt mp ju kv kw mq jx ky kz mr lb lc ld ms lf lg lh mt lj lk ll im bi translated">到目前为止，我们还没有怎么处理泛型。尽管我们确实在<code class="fe lm ln lo lp b">applyPublisher</code>方法中考虑了泛型<code class="fe lm ln lo lp b">Output</code>，但它只是<code class="fe lm ln lo lp b">enum</code>的扩展方法，而不是在声明级别。然而，对于<code class="fe lm ln lo lp b">scan</code>，我们不得不面对它的泛型本质，因为<code class="fe lm ln lo lp b">scan</code>总是以泛型形式接受<code class="fe lm ln lo lp b">initialResult</code>。</p><pre class="kj kk kl km gt na lp nb nc aw nd bi"><span id="3cd4" class="ne ly it lp b gy nf ng l nh ni">func scan&lt;T&gt;(_ initialResult: T, _ nextPartialResult: @escaping (T, (A.Output, B.Output)) -&gt; T) -&gt; <a class="ae mz" href="https://developer.apple.com/documentation/combine/publishers" rel="noopener ugc nofollow" target="_blank">Publishers</a>.<a class="ae mz" href="https://developer.apple.com/documentation/combine/publishers/scan" rel="noopener ugc nofollow" target="_blank">Scan</a>&lt;<a class="ae mz" href="https://developer.apple.com/documentation/combine/publishers" rel="noopener ugc nofollow" target="_blank">Publishers</a>.<a class="ae mz" href="https://developer.apple.com/documentation/combine/publishers/combinelatest" rel="noopener ugc nofollow" target="_blank">CombineLatest</a>&lt;A, B&gt;, T&gt;</span></pre></div><div class="ab cl lq lr hx ls" role="separator"><span class="lt bw bk lu lv lw"/><span class="lt bw bk lu lv lw"/><span class="lt bw bk lu lv"/></div><div class="im in io ip iq"><h1 id="dd95" class="lx ly it bd lz ma mb mc md me mf mg mh jz mi ka mj kc mk kd ml kf mm kg mn mo bi translated">使用NSExpression扫描</h1><p id="be86" class="pw-post-body-paragraph kq kr it ks b kt mp ju kv kw mq jx ky kz mr lb lc ld ms lf lg lh mt lj lk ll im bi translated">我很懒，试着用0硬编码<code class="fe lm ln lo lp b">intialResult</code>，用map跟踪相同的路径，然后用<code class="fe lm ln lo lp b">NSExpression</code>简单地扫描。在这种情况下，表达式可以是类似于<code class="fe lm ln lo lp b">%d + %d </code>的东西——两个整数的和。让我们看看结果如何。</p><pre class="kj kk kl km gt na lp nb nc aw nd bi"><span id="db4e" class="ne ly it lp b gy nf ng l nh ni"><strong class="lp iu">enum</strong> TransformingOperator: Codable {<br/>  case map(expression: String)<br/>  <strong class="lp iu">case</strong> <strong class="lp iu">scan</strong>(expression: String)<br/>}</span></pre><p id="35b8" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">我们只是添加了一个与<code class="fe lm ln lo lp b">map</code>案例具有相同关联值的<code class="fe lm ln lo lp b"> scan</code>案例:</p><pre class="kj kk kl km gt na lp nb nc aw nd bi"><span id="0a4f" class="ne ly it lp b gy nf ng l nh ni"><strong class="lp iu">extension</strong> TransformingOperator {<br/><strong class="lp iu">func</strong> applyPublisher&lt;Output&gt;(<strong class="lp iu">_</strong> publisher: AnyPublisher&lt;Output, Never&gt;) -&gt; AnyPublisher&lt;Output, Never&gt; {<strong class="lp iu">  <br/>  switch</strong> <strong class="lp iu">self</strong> {<br/>。。。。。。。。。。。。。。。。。。。。。。。。。。。。。。。。。。。。。。<br/>  case .scan(let expression):<br/>       <strong class="lp iu">return</strong> publisher.scan(<strong class="lp iu"><em class="nk">0</em></strong>) { (sum, num) <strong class="lp iu">in <br/>       let</strong> expressionValue = <br/>           NSExpression(format: expression,<br/>                       argumentArray: <br/>          [sum,  num]).expressionValue(with: <strong class="lp iu">nil</strong>, context: <strong class="lp iu">nil</strong>)</span><span id="8505" class="ne ly it lp b gy nj ng l nh ni"><strong class="lp iu">       return</strong> expressionValue <strong class="lp iu">as</strong>! Output<br/>}.eraseToAnyPublisher()<br/>}}</span></pre><p id="51b2" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">注意，我们将两个参数<code class="fe lm ln lo lp b">sum</code>和<code class="fe lm ln lo lp b">num</code>都传递给了<code class="fe lm ln lo lp b">NSExpression</code>。在我们构建它之前，这看起来还不错:</p><pre class="kj kk kl km gt na lp nb nc aw nd bi"><span id="baac" class="ne ly it lp b gy nf ng l nh ni">Cannot convert return expression of type 'AnyPublisher&lt;Int, Never&gt;' to return type 'AnyPublisher&lt;Output, Never&gt;'</span></pre><p id="734c" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">这里的问题是编译器不能将泛型类型转换成整数<code class="fe lm ln lo lp b">0</code>。另外，从API设计的角度来看，<code class="fe lm ln lo lp b">initialResult</code>应该是灵活的，由用户提供。</p></div><div class="ab cl lq lr hx ls" role="separator"><span class="lt bw bk lu lv lw"/><span class="lt bw bk lu lv lw"/><span class="lt bw bk lu lv"/></div><div class="im in io ip iq"><h1 id="96f8" class="lx ly it bd lz ma mb mc md me mf mg mh jz mi ka mj kc mk kd ml kf mm kg mn mo bi translated">持续扫描逻辑</h1><p id="17a8" class="pw-post-body-paragraph kq kr it ks b kt mp ju kv kw mq jx ky kz mr lb lc ld ms lf lg lh mt lj lk ll im bi translated">我们需要做的是包含<code class="fe lm ln lo lp b">initialResult</code>作为<code class="fe lm ln lo lp b">scan</code>的关联值。该关联值类型需要是通用的。换句话说，与预期的发布者输出相同的类型。</p><pre class="kj kk kl km gt na lp nb nc aw nd bi"><span id="2b16" class="ne ly it lp b gy nf ng l nh ni"><strong class="lp iu">enum</strong> TransformingOperator&lt;Output: Codable&gt;: Codable {<br/>  case map(expression: String)<br/>  <strong class="lp iu">case</strong> <strong class="lp iu">scan</strong>(initialResult: Output, expression: String)<br/>}</span></pre><p id="079e" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">现在我们正式踏上通用领域。<code class="fe lm ln lo lp b">TransformingOperator</code>现在包含了<code class="fe lm ln lo lp b">Output</code>类型，它显式地存储了转换逻辑及其结果类型。请参见以下示例:</p><pre class="kj kk kl km gt na lp nb nc aw nd bi"><span id="97ff" class="ne ly it lp b gy nf ng l nh ni">TransformingOperator.scan(initialResult: 0, expression: "%d + %d")</span></pre><p id="e9fe" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">我们现在可以用<code class="fe lm ln lo lp b">initialResult</code>反序列化并应用到publisher，如图所示。</p><pre class="kj kk kl km gt na lp nb nc aw nd bi"><span id="5d7f" class="ne ly it lp b gy nf ng l nh ni"><strong class="lp iu">extension</strong> TransformingOperator {<br/><strong class="lp iu">func</strong> applyPublisher&lt;Output&gt;(<strong class="lp iu">_</strong> publisher: <br/>AnyPublisher&lt;Output, Never&gt;) -&gt; AnyPublisher&lt;Output, Never&gt; {<strong class="lp iu">  <br/>  switch</strong> <strong class="lp iu">self</strong> {<br/>。。。。。。。。。。。。。。。。。。。。。。。。。。。。。。。。。。。。。。<br/>  case .scan(let <strong class="lp iu">initialValue</strong>, let expression):<br/>       <strong class="lp iu">return</strong> publisher.scan(<strong class="lp iu"><em class="nk">initialValue</em></strong>) { (sum, num) <strong class="lp iu">in <br/>              let</strong> expressionValue = <br/>                  NSExpression(format: expression,<br/>                               argumentArray: <br/>                               [sum,  num])<br/>                  .expressionValue(with: <strong class="lp iu">nil</strong>, context: <strong class="lp iu">nil</strong>)<strong class="lp iu">                  </strong></span><span id="6fd2" class="ne ly it lp b gy nj ng l nh ni"><strong class="lp iu">              return</strong> expressionValue <strong class="lp iu">as</strong>! Output<br/>        }.eraseToAnyPublisher()<br/>}}</span></pre><p id="d66a" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">同样，我们将通过动态改变其逻辑来演示scan的序列化和反序列化:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi mu"><img src="../Images/6a5a1c80f91e31464cb2dffc5636154a.png" data-original-src="https://miro.medium.com/v2/resize:fit:600/1*jyDkbjNn5vCr6MPlP7fL2A.gif"/></div></figure></div><div class="ab cl lq lr hx ls" role="separator"><span class="lt bw bk lu lv lw"/><span class="lt bw bk lu lv lw"/><span class="lt bw bk lu lv"/></div><div class="im in io ip iq"><p id="c820" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">正如承诺的，这里是完整的<code class="fe lm ln lo lp b">Codable</code>列举供你参考。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nl nm l"/></div></figure></div><div class="ab cl lq lr hx ls" role="separator"><span class="lt bw bk lu lv lw"/><span class="lt bw bk lu lv lw"/><span class="lt bw bk lu lv"/></div><div class="im in io ip iq"><p id="6066" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">在对<code class="fe lm ln lo lp b">map</code>和<code class="fe lm ln lo lp b">scan</code>进行反序列化的过程中，您可能已经注意到有一些限制。</p><ul class=""><li id="93f3" class="nn no it ks b kt ku kw kx kz np ld nq lh nr ll ns nt nu nv bi translated"><code class="fe lm ln lo lp b">Publisher</code>的输出必须是<code class="fe lm ln lo lp b">Numeric</code>类型。</li><li id="dd54" class="nn no it ks b kt nw kw nx kz ny ld nz lh oa ll ns nt nu nv bi translated"><code class="fe lm ln lo lp b">Expression</code>必须产生一个有效值，否则，<code class="fe lm ln lo lp b">expression</code>值的强制解包会崩溃。</li><li id="9c54" class="nn no it ks b kt nw kw nx kz ny ld nz lh oa ll ns nt nu nv bi translated"><code class="fe lm ln lo lp b">Output</code>的类型无法转换。</li></ul><p id="99b6" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">我们将在以后的文章中逐一解决并改进它们，但是现在，就到此为止吧！</p><h2 id="316f" class="ne ly it bd lz ob oc dn md od oe dp mh kz of og mj ld oh oi ml lh oj ok mn ol bi translated">接下来:持久化组合操作符:合并和追加</h2><p id="ec20" class="pw-post-body-paragraph kq kr it ks b kt mp ju kv kw mq jx ky kz mr lb lc ld ms lf lg lh mt lj lk ll im bi translated">在下一篇文章中，我们将添加另一个代表包括<code class="fe lm ln lo lp b">Merge</code>和<code class="fe lm ln lo lp b">Append</code>在内的<code class="fe lm ln lo lp b">Combining</code>操作符的<code class="fe lm ln lo lp b">enum</code>。它将能够将两个发布者合并成一个，而不是对一个<code class="fe lm ln lo lp b">Publisher</code>应用操作符。</p><p id="7404" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">直到下一次，你可以在这个<a class="ae mz" href="https://github.com/kevinjohnason/combine-magic-swiftui" rel="noopener ugc nofollow" target="_blank">combine-magic-swi fui repo</a>中找到源代码，在combine-playground文件夹下。</p></div></div>    
</body>
</html>