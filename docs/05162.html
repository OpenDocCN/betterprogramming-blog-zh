<html>
<head>
<title>Create Zero-Point Failure Distributed Tasks With Python and ZeroMQ</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用Python和ZeroMQ创建零点故障分布式任务</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/create-zero-point-failure-distributed-tasks-with-python-and-zeromq-e2a20941d85b?source=collection_archive---------3-----------------------#2020-06-16">https://betterprogramming.pub/create-zero-point-failure-distributed-tasks-with-python-and-zeromq-e2a20941d85b?source=collection_archive---------3-----------------------#2020-06-16</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="aa00" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">关于如何在没有代理的情况下构建分布式发布-订阅架构的指南</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/3c6fc739c726fdcfb83ed9ce92e36fa2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*5vGaDInzulUxd4xA1wHvQw.jpeg"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">安娜斯塔西娅·杜尔吉尔在<a class="ae ky" href="https://unsplash.com/s/photos/connected?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的照片</p></figure><p id="3465" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">促进不同应用程序服务之间通信的常见解决方案是使用消息队列。大多数传统的消息队列充当集线器，以便于分布式软件组件之间通过网络交换消息。这通常是通过应用程序经由使用API的集中队列来完成的。</p><p id="1295" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">最近，我开始探索一个<a class="ae ky" href="https://zeromq.org/" rel="noopener ugc nofollow" target="_blank"> ZeroMQ </a>(又名MQ、0MQ或zmq)这是一个固执己见的轻量级库，自称是一个高性能的异步消息库，没有中间件代理，旨在用于分布式或并发应用程序。</p><p id="55bd" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">当您想到微服务或服务之间的通信时，对于我们中的一些人来说，首先想到的是带有服务发现或消息代理的REST API，它有助于服务之间的相互通信。MQ采取了不同的方法，追溯到网络的根源。</p><p id="6758" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在这篇文章中，我们将会看到</p><ul class=""><li id="4ef0" class="lv lw it lb b lc ld lf lg li lx lm ly lq lz lu ma mb mc md bi translated">什么是MQ</li><li id="5454" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated">探索ZeroMQ设计模式</li><li id="fa7d" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated">MQ在构建分布式应用程序时出现的问题</li><li id="d753" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated">如何分配您的Python任务，并一窥其可能性</li></ul></div><div class="ab cl mj mk hx ml" role="separator"><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo"/></div><div class="im in io ip iq"><h1 id="de85" class="mq mr it bd ms mt mu mv mw mx my mz na jz nb ka nc kc nd kd ne kf nf kg ng nh bi translated">用ZeroMQ来包装你的脑袋</h1><p id="0a78" class="pw-post-body-paragraph kz la it lb b lc ni ju le lf nj jx lh li nk lk ll lm nl lo lp lq nm ls lt lu im bi translated">套用一下<a class="ae ky" href="http://wiki.zeromq.org/docs:welcome-from-amqp" rel="noopener ugc nofollow" target="_blank">MQ文档</a>在描述这个库时所说的话</p><blockquote class="nn"><p id="20fd" class="no np it bd nq nr ns nt nu nv nw lu dk translated">MQ是基于统一性、可扩展性和插入性的特定设计原则，并受互联网协议(IP)的启发，对消息传递进行的全新重新设计</p></blockquote><p id="96d0" class="pw-post-body-paragraph kz la it lb b lc nx ju le lf ny jx lh li nz lk ll lm oa lo lp lq ob ls lt lu im bi translated">ZeroMQ是一个允许您执行低级消息传递的库，但是与面向消息的中间件不同，MQ系统可以在没有专用消息代理的情况下运行。为了理解MQ，您需要从跨各种传输方式传送原子消息的网络套接字的角度来考虑。您可以使用扇出、发布-订阅、任务分布和双向请求-应答(即客户端-服务器)等模式连接网络套接字。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi oc"><img src="../Images/57c3dab15c253a26006bd216f19627f0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*jZ5D7PEuDcXSHnwcMJJDKw.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">MQ语言绑定(图片来源:作者)</p></figure><p id="ab30" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">MQ有30+ <a class="ae ky" href="https://en.wikipedia.org/wiki/Language_binding" rel="noopener ugc nofollow" target="_blank">语言绑定</a>可用于支持在底层C编程套接字库之上编写您的系统。</p><p id="1569" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这意味着您可以用不同的语言构建一个分布式多线程服务或微服务网络，它们都能够通过一个公共库进行通信。您可以在文档中看到更全面的受支持的绑定/语言列表。本质上，我们可以在没有传统的服务发现和中间件代理模型的情况下构建类似下图的东西。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi od"><img src="../Images/f5f635f9a7c8a0a0a6d02cefe34fe4ed.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*eJT7163yVdqMO0tKxO00aw.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">P2P风格的沟通可能性是无限的(图片来源:作者)</p></figure><p id="e41d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">MQ是自然分布的。消息不必经过任何单点故障，可以以对等的方式直接从源传送到目的地。</p><p id="cf1a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">它们与成熟的中间件解决方案(如Rabbit和MQ)有很多不同之处。例如，MQ的极简特性、缺少仪表板、极简路由模式(如果需要，您可以扩展这些模式来构建自己的附加模式)以及对通过TCP、inproc、IPC和多播进行消息交换的支持。</p></div><div class="ab cl mj mk hx ml" role="separator"><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo"/></div><div class="im in io ip iq"><h1 id="312b" class="mq mr it bd ms mt mu mv mw mx my mz na jz nb ka nc kc nd kd ne kf nf kg ng nh bi translated">ZeroMQ与其他开源中间件产品的比较</h1><p id="07f1" class="pw-post-body-paragraph kz la it lb b lc ni ju le lf nj jx lh li nk lk ll lm nl lo lp lq nm ls lt lu im bi translated">考虑到成本和时间，当你只想完成任务时，使用ZeroMQ是有意义的。</p><p id="f7d3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果您试图最大限度地减少应用中的活动部件数量，MQ更有意义。由于任务之间的通信可以通过MQ的IPC传输在本地通过进程进行，或者通过TCP任务分发在远程进行，因此可以实现容器化，而不必担心有托管的rabbitMQ或类似的中介服务。您需要担心的唯一成本因素是带宽和运行应用程序的服务器。</p><p id="0cbb" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">MQ还可用于设计允许设备加入对等网络的服务，从而构建更多基于利基的服务。您可以将MQ视为可以构建其他中间件代理解决方案的底层服务。</p></div><div class="ab cl mj mk hx ml" role="separator"><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo"/></div><div class="im in io ip iq"><h1 id="9e36" class="mq mr it bd ms mt mu mv mw mx my mz na jz nb ka nc kc nd kd ne kf nf kg ng nh bi translated">探索ZeroMQ设计模式</h1><p id="fc04" class="pw-post-body-paragraph kz la it lb b lc ni ju le lf nj jx lh li nk lk ll lm nl lo lp lq nm ls lt lu im bi translated">开箱即用，我们可以通过套接字消息传递使用一些模式，如客户端/服务器通信模式或发布/订阅，这对于事件发布、实时服务注册/发现和批量处理等非常有用。下面我们将介绍主要的核心模式，这样你就可以了解这个库是如何工作的。</p><h2 id="f978" class="oe mr it bd ms of og dn mw oh oi dp na li oj ok nc lm ol om ne lq on oo ng op bi translated">ZeroMQ 5模式</h2><ul class=""><li id="2cb9" class="lv lw it lb b lc ni lf nj li oq lm or lq os lu ma mb mc md bi translated">同步请求/响应</li><li id="3aed" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated">异步请求/响应</li><li id="a22b" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated">发布/订阅</li><li id="13a0" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated">推/拉</li><li id="3206" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated">互斥对</li></ul><h2 id="dae9" class="oe mr it bd ms of og dn mw oh oi dp na li oj ok nc lm ol om ne lq on oo ng op bi translated">同步请求-响应</h2><p id="d492" class="pw-post-body-paragraph kz la it lb b lc ni ju le lf nj jx lh li nk lk ll lm nl lo lp lq nm ls lt lu im bi translated">让我们来看看下面的一些Python例子。确保您安装了Python 3.4或更高版本。我个人用Python 3.7运行了下面所有的例子。我建议在一个新的虚拟环境中运行程序，以确保没有包冲突。</p><pre class="kj kk kl km gt ot ou ov ow aw ox bi"><span id="058f" class="oe mr it ou b gy oy oz l pa pb">$ python3 -m venv env</span><span id="cee8" class="oe mr it ou b gy pc oz l pa pb">$ source env/bin/activate</span></pre><p id="d6ec" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果您在conda上运行，您可以运行下面的命令来设置conda环境。</p><pre class="kj kk kl km gt ot ou ov ow aw ox bi"><span id="1335" class="oe mr it ou b gy oy oz l pa pb">$ conda create -n env python<strong class="ou iu">=</strong>3.5 pyzmq &amp;&amp; source activate env</span></pre><p id="0018" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">要获得更全面的Python示例列表，您可以在这里查看<a class="ae ky" href="https://github.com/zeromq/pyzmq/tree/master/examples" rel="noopener ugc nofollow" target="_blank">pyzmq git repo</a>。</p><p id="e221" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">继续创建一个<code class="fe pd pe pf ou b">client.py</code>脚本并添加下面的代码。客户端将负责将数据发送到节点进行处理。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="pg ph l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">Python ZeroMQ基本客户端. py</p></figure><p id="d385" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">关于代码最重要的一点是上下文创建部分。MQ下的底层技术是由套接字驱动的，因此上下文有助于管理创建的任何套接字以及MQ在幕后使用的线程数量。上下文是初始化流程时应该创建的第一件事，在流程终止时应该销毁。上下文可以在线程之间共享。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi pi"><img src="../Images/d0810279b8994896c4b9d430d7caffe2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*7GVSS1-2UlHUdNrXaFYurw.png"/></div></div></figure><p id="2d1d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们创建一个<code class="fe pd pe pf ou b">server.py</code>文件并添加下面的代码。然后，我们创建一个响应套接字，并使用连接字符串绑定它，后跟一个请求套接字并连接它。与常规TCP套接字非常相似，一端必须绑定，另一端必须连接。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="pg ph l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">ZeroMQ server.py，它充当传入套接字消息的接收者</p></figure><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi pj"><img src="../Images/5e3b54830dd0a7c73cb14ab4887d5c1d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*UGYwFO1VaNQObDNsmAjU4A.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">ZeroMQ接收器输出随机二进制字符串</p></figure><p id="88f6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">记下连接字符串。一旦创建了套接字，就需要绑定或连接它。为此，以“transport:endpoint”的形式传入一个字符串。传输可以是以下任何值:</p><ul class=""><li id="607d" class="lv lw it lb b lc ld lf lg li lx lm ly lq lz lu ma mb mc md bi translated"><strong class="lb iu"> inproc </strong>单个进程内的线程到线程</li><li id="1bbf" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated">ipc 进程间通信(仅适用于Linux，尚未在任何本地端口中提供)</li><li id="c0c5" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated"><strong class="lb iu">当ipc不可用时，tcp </strong>盒对盒通信和进程间通信</li><li id="1359" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated"><strong class="lb iu"> epgm，pgm </strong>组播协议</li></ul><p id="7d13" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">与常规TCP套接字非常相似，一端必须绑定，另一端必须连接。</p><p id="0896" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">一旦我们的套接字被配置好，我们就发送一个响应，读取并打印它。因为请求和响应套接字是同步的，所以它们的发送和接收调用必须按照特定的顺序进行。请求套接字必须先发送，然后接收，响应套接字则相反。如果您以错误的顺序尝试这些操作，或者重复其中一个操作，就会引发异常。</p><p id="dfa7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们可能会有数千个并发客户端。服务器应用程序不会直接看到它们。MQ socket的作用就像一个小型多线程服务器，它促进后台通信、管理状态、确保连接是私有的和不可见的，并以网络能够处理的最快速度静默接受客户端请求。</p></div><div class="ab cl mj mk hx ml" role="separator"><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo"/></div><div class="im in io ip iq"><h2 id="e9aa" class="oe mr it bd ms of og dn mw oh oi dp na li oj ok nc lm ol om ne lq on oo ng op bi translated">发布-订阅</h2><p id="96b8" class="pw-post-body-paragraph kz la it lb b lc ni ju le lf nj jx lh li nk lk ll lm nl lo lp lq nm ls lt lu im bi translated">如果您想发布一个数据流并允许任意数量的客户机使用该数据流，MQ有一个使用发布和订阅套接字的模式。MQ中的Pub-sub通过在发送端和接收端本地对消息进行排队来工作，因此，如果接收方暂时停机并再次返回，不会丢失任何消息，而对于大多数关键任务系统，消息可以写入磁盘。</p><p id="40e9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在本例中，我们将把客户机和服务器分成可以跨越多个物理节点的独立进程。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi pk"><img src="../Images/830da8dbe8d5425d909320e833f7a8a8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*dEEblxN2h11eVuaN8l6UyA.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">发布者订阅者设计模式在ZeroMQ中的应用</p></figure><p id="1693" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们创建一个基本的<code class="fe pd pe pf ou b">publisher.py</code>和一个基本的<code class="fe pd pe pf ou b">subscriber.py</code>来说明上图。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="pg ph l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">publisher.py</p></figure><p id="27bf" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">创建<code class="fe pd pe pf ou b">subscriber.py</code> <strong class="lb iu"> </strong>文件并添加以下代码片段:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="pg ph l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">subscriber.py</p></figure><p id="17e9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">执行<code class="fe pd pe pf ou b">publisher.py</code></p><pre class="kj kk kl km gt ot ou ov ow aw ox bi"><span id="9602" class="oe mr it ou b gy oy oz l pa pb">$ python publisher.py</span></pre><p id="1720" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">和<code class="fe pd pe pf ou b">subscriber.py</code>在两个不同的码头。</p><pre class="kj kk kl km gt ot ou ov ow aw ox bi"><span id="8856" class="oe mr it ou b gy oy oz l pa pb">$ python subscriber.py</span></pre><p id="13b9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">订户绑定到默认端口5556。因为这是一个单向通信通道，所以不需要显式发送确认。</p><h2 id="6508" class="oe mr it bd ms of og dn mw oh oi dp na li oj ok nc lm ol om ne lq on oo ng op bi translated">动态发现问题</h2><p id="90b3" class="pw-post-body-paragraph kz la it lb b lc ni ju le lf nj jx lh li nk lk ll lm nl lo lp lq nm ls lt lu im bi translated">如果您已经注意到，在我们的示例中，我们定义了承载处理请求的接收器侦听器的端口。当我们有许多节点需要添加到集群中时，会发生什么情况？由于添加新的消费者和生产者变得难以维护，我们需要一种方法来拥有一个用于消费消息的静态端口。</p><p id="a403" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这就是MQ代理发挥作用的地方。在下面的例子中，我们有一个由MQ监控的队列处理的发布-订阅代理。它就像一个代理，允许消息在具有invite能力的套接字之间传递。zhelpers Python脚本可以在这里找到。</p><p id="f113" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">代理绑定到端口6001上的所有发布者和端口6000上的所有订阅者。</p><p id="6ee8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe pd pe pf ou b">XPUB</code> =【多家发行商】<code class="fe pd pe pf ou b">PUB</code> =【单家发行商】</p><p id="2ef8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe pd pe pf ou b">XSUB</code> =【多用户】<code class="fe pd pe pf ou b">SUB</code> =【单用户】</p><p id="006d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果您想将许多订阅者连接到许多发布者，同时仍然拥有动态发现的好处，那么您需要一个中间代理。<code class="fe pd pe pf ou b">PUB</code>套接字向代理发送消息；<code class="fe pd pe pf ou b">XSUB</code>将消息转发给<code class="fe pd pe pf ou b">XPUB</code>，然后<code class="fe pd pe pf ou b">XPUB</code>将这些消息分发给所有的<code class="fe pd pe pf ou b">SUB</code>听众。</p><p id="4ea6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">发布者是用ZMQ创建的。酒吧插座类型。数据与主题一起发布。订阅者通常对这些主题设置过滤器，并订阅他们感兴趣的主题。<br/> <br/>如果发布者没有连接的订阅者，那么它将简单地丢弃所有消息。如果您使用的是TCP，并且订阅者很慢，消息将在发布者上排队。在MQ的当前版本中，过滤发生在订阅者端，而不是发布者端。这是你需要注意的<em class="pl">。</em>让我们创建一个名为<code class="fe pd pe pf ou b">multi-publisher_sub.py</code>的新文件，并附上以下代码:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="pg ph l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">发布Scriber ZeroMQ代理</p></figure><p id="f2db" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">执行上述代码可以在一个终端中完成，因为我们使用Python线程来模拟多个订阅者和发布者。</p></div><div class="ab cl mj mk hx ml" role="separator"><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo"/></div><div class="im in io ip iq"><h1 id="fbb2" class="mq mr it bd ms mt mu mv mw mx my mz na jz nb ka nc kc nd kd ne kf nf kg ng nh bi translated">作为订阅者的Java绑定</h1><p id="bac3" class="pw-post-body-paragraph kz la it lb b lc ni ju le lf nj jx lh li nk lk ll lm nl lo lp lq nm ls lt lu im bi translated">我们可以进一步扩展我们的代理示例，用完全不同的编程语言(比如Java)创建另一个订阅者，它订阅并监听我们的网络。下面的订阅者只从我们硬编码的主题C和D中提取消息。</p><p id="7300" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">要测试下面的示例，您需要在您的IDE中运行下面的Java示例的同时，运行Python中的初始发布-订阅代理示例。如果您在本地局域网上有一台额外的计算机，您也可以测试这个设置，确保您的路由器不会阻塞端口6001。<strong class="lb iu"> </strong>这个例子假设你使用Java 8并拥有。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="pg ph l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">Java MQ订户绑定</p></figure><p id="be4c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果您使用Maven运行项目，那么您可以将下面的MQ Maven依赖项添加到您的<code class="fe pd pe pf ou b">pom.xml</code>中，或者显式下载这个包并将其添加到您的类路径中。</p><pre class="kj kk kl km gt ot ou ov ow aw ox bi"><span id="5588" class="oe mr it ou b gy oy oz l pa pb">&lt;dependencies&gt;<br/>    &lt;dependency&gt;<br/>        &lt;groupId&gt;org.zeromq&lt;/groupId&gt;<br/>        &lt;artifactId&gt;jeromq&lt;/artifactId&gt;<br/>        &lt;version&gt;0.5.2&lt;/version&gt;<br/>    &lt;/dependency&gt;<br/>&lt;/dependencies&gt;</span></pre><p id="d7a0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">下面是我们同时运行Python publisher和Java subscriber时生成的输出。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi pm"><img src="../Images/379b2a40d3d1440bea9d4290740bb124.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*OoYWDgnK_Bs5PsIYqh19Dw.png"/></div></div></figure></div><div class="ab cl mj mk hx ml" role="separator"><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo"/></div><div class="im in io ip iq"><h1 id="0a14" class="mq mr it bd ms mt mu mv mw mx my mz na jz nb ka nc kc nd kd ne kf nf kg ng nh bi translated">ZeroMQ可以用于视频流吗？</h1><p id="0795" class="pw-post-body-paragraph kz la it lb b lc ni ju le lf nj jx lh li nk lk ll lm nl lo lp lq nm ls lt lu im bi translated">这是我开始探索ZeroMQ时首先想到的事情之一。毕竟，它确实使用了套接字，所以从逻辑上来说，这意味着可以从它那里传输内容。</p><p id="f8a2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在下面的示例中，我们创建了一个客户端和服务器模型，允许我们使用OpenCV图像处理库直接从网络摄像头实时传输视频内容。性能和质量完全取决于您的堆栈和网络速度。要运行下面的示例，请确保您已经安装了OpenCV和pyzmq。</p><p id="5fd4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果您在pip上运行:</p><pre class="kj kk kl km gt ot ou ov ow aw ox bi"><span id="b541" class="oe mr it ou b gy oy oz l pa pb">$ pip install pyzmq <!-- -->opencv-python</span></pre><p id="5008" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果你在康达:</p><pre class="kj kk kl km gt ot ou ov ow aw ox bi"><span id="3476" class="oe mr it ou b gy oy oz l pa pb">$ <!-- -->conda install <!-- -->-n env <!-- -->-c https://conda.anaconda.org/menpo opencv3</span></pre><p id="3a5a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这两个包都应该安装在客户机和服务器上。创建一个名为<code class="fe pd pe pf ou b">video_server.py</code> <strong class="lb iu"> </strong>的Python文件，并添加以下代码:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="pg ph l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">视频_服务器. py</p></figure><p id="b41b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">然后创建<code class="fe pd pe pf ou b">video_receiver.py</code>并添加如下代码:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="pg ph l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">视频_接收器. py</p></figure><p id="3260" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在两个独立的终端窗口中执行客户机和服务器，或者，如果您有本地局域网，通过两台机器。服务器将初始化您的网络摄像头，并将网络摄像头馈送流传输到收听接收器。以上绝不是一个健壮的架构，但它足以说明一个简单的客户端-服务器视频流模型。</p></div><div class="ab cl mj mk hx ml" role="separator"><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo"/></div><div class="im in io ip iq"><h1 id="d593" class="mq mr it bd ms mt mu mv mw mx my mz na jz nb ka nc kc nd kd ne kf nf kg ng nh bi translated">使用ZeroMQ的怪癖和问题</h1><ul class=""><li id="93ea" class="lv lw it lb b lc ni lf nj li oq lm or lq os lu ma mb mc md bi translated">对于MQ，很容易陷入异常。如果您碰巧没有在接收端进行任何验证，您的应用程序将会陷入沉默。</li><li id="8a86" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated">MQ不提供标准的持久性机制。例如，当您发送一个大的对象或数据集时，在您处理它之前，您可能需要首先获取它。因此，如果您有这样的用例，这个<a class="ae ky" href="https://pypi.org/project/persizmq/" rel="noopener ugc nofollow" target="_blank"> Python包</a>可能会有用。</li><li id="1caa" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated">透明重新连接是ZeroMQ提供的现成功能。在这些情况下，应用程序需要快速检测有多少节点连接到网络，或者某个节点是否已经离开网络。如果这是您的一个典型用例，那么您将不得不花一些时间来设计您自己的发现中介器。</li><li id="7694" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated">没有保证交货。由于<strong class="lb iu"> </strong> ZeroMQ不使用代理，如果不存储状态，就没有办法再处理。你需要评估你需要多少这种状态，以及它是否保证了一个实际经纪人的需要。</li></ul><p id="6038" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">消息传递和可靠性受局域网和网络的限制。因此，延迟是你必须解决的问题。其中一些怪癖是可以解决的。在<a class="ae ky" href="http://zguide.zeromq.org/page:chapter4" rel="noopener ugc nofollow" target="_blank"> ZeroMQ指南</a>中可以找到更好的可靠性模式的更多细节。</p></div><div class="ab cl mj mk hx ml" role="separator"><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo"/></div><div class="im in io ip iq"><h1 id="047f" class="mq mr it bd ms mt mu mv mw mx my mz na jz nb ka nc kc nd kd ne kf nf kg ng nh bi translated">最后的想法</h1><p id="3e40" class="pw-post-body-paragraph kz la it lb b lc ni ju le lf nj jx lh li nk lk ll lm nl lo lp lq nm ls lt lu im bi translated">分布式消息传递长期以来一直由消息传递中间件代理解决方案主导，这通常会成为您的堆栈中维护成本较高的软件之一。</p><p id="9da7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">由于MQ最初的简单性，它使快速启动和运行成为可能，并且它提供了一个平台来构建一些有趣的分布式项目。不过，我确实觉得，一旦你开始从简单的用例中分支出来，就需要花相当多的时间来理解如何构建更复杂的用例。</p><p id="0f7d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">归根结底，使用工具没有对错之分。退一步，客观地看待事物总是很重要的。中间件解决方案有它们的位置，像MQ这样的轻量级库也有它们的位置。</p><p id="9460" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">MQ不是万能的，但它确实解决了一些有趣的分布式问题，作为一种轻量级的方式来执行分布式，而不会给代码库增加额外的复杂性，它绝对值得投入时间。<br/> <br/>希望你喜欢阅读。如果您有任何意见或经验，甚至是使用MQ的基准，请在下面分享您的见解。</p><p id="6f85" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">编码快乐！</p></div></div>    
</body>
</html>