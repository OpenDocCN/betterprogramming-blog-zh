<html>
<head>
<title>Dealing With Code Performance— Micro and Macro Optimizations</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">处理代码性能—微观和宏观优化</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/dealing-with-code-performance-micro-and-macro-optimizations-128269484932?source=collection_archive---------3-----------------------#2022-06-03">https://betterprogramming.pub/dealing-with-code-performance-micro-and-macro-optimizations-128269484932?source=collection_archive---------3-----------------------#2022-06-03</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="cee3" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">作为一名开发人员，我们应该在哪些方面进行性能优化？我们如何衡量影响？阅读这篇文章来学习这个框架</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/a6e260d4366f62ae02878bb70851a937.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*NhXUdUl1RbVlR-PRTiVJmw.jpeg"/></div></div></figure><p id="7165" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">性能优化是任何软件或硬件的修改，使平台更快，更具可扩展性，改善<a class="ae ln" href="https://medium.com/@nbosco/latency-vs-throughput-d7a4459b5cdb" rel="noopener">延迟或吞吐量</a>或两者。</p><p id="b7be" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">你可以花大量的时间在不同的方面来提高性能，但是你最需要关注哪一方面呢？</p><p id="3d9d" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">这篇文章将向你展示我开发的一个框架来对性能变化进行分类。我使用这个框架来了解我的团队或我应该在哪些方面花更多时间来提高绩效，以及在哪些情况下我应该停止在这些方面的工作。用了好几年了，决定写下来分享一下。它并不完美，但对我来说效果很好。</p><p id="32aa" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">这篇文章使用了延迟改进的例子，但是它也适用于吞吐量改进。</p><h1 id="25fc" class="lo lp iq bd lq lr ls lt lu lv lw lx ly jw lz jx ma jz mb ka mc kc md kd me mf bi translated"><strong class="ak">宏观和微观优化</strong></h1><p id="d0cf" class="pw-post-body-paragraph kr ks iq kt b ku mg jr kw kx mh ju kz la mi lc ld le mj lg lh li mk lk ll lm ij bi translated">作为开发人员，我们经常会遇到一些可以提高性能的地方。在某些情况下，更改很简单，例如删除不必要的查询，通过批处理避免后端的N+1查询，或者消除对前端服务器的不必要调用。在其他情况下，更改更加复杂，需要重新设计解决方案，例如跨系统实现不同的缓存策略，或者实现全新的、更快的服务。</p><p id="a193" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">该框架将性能优化分为两种类型:微观和宏观优化:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi ml"><img src="../Images/d908d32ebfa93c278b7081c3d3cbdf78.png" data-original-src="https://miro.medium.com/v2/resize:fit:710/format:webp/1*unrS6B88kd6kL213MGmZoQ.png"/></div><p class="mm mn gj gh gi mo mp bd b be z dk translated">图一。微观和宏观优化</p></figure><h2 id="eda1" class="mq lp iq bd lq mr ms dn lu mt mu dp ly la mv mw ma le mx my mc li mz na me nb bi translated">微观优化</h2><p id="38c0" class="pw-post-body-paragraph kr ks iq kt b ku mg jr kw kx mh ju kz la mi lc ld le mj lg lh li mk lk ll lm ij bi translated">它们是应用于非常具体的领域的优化。在大多数情况下，影响通常是中低的(例如，提高使用率低的端点的性能)。在一些罕见的情况下，影响非常大，例如，通过改进身份验证流程来减少所有已验证请求的开销时间。</p><p id="5717" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">由于这种努力，最常见的优化变化属于这一类。</p><p id="62d6" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">一些例子:</p><ul class=""><li id="1dcb" class="nc nd iq kt b ku kv kx ky la ne le nf li ng lm nh ni nj nk bi translated">缓存和批处理特定的APIs模型。</li><li id="2810" class="nc nd iq kt b ku nl kx nm la nn le no li np lm nh ni nj nk bi translated">去除不必要的呼叫。</li><li id="3ebc" class="nc nd iq kt b ku nl kx nm la nn le no li np lm nh ni nj nk bi translated">减少内存分配。</li><li id="ab13" class="nc nd iq kt b ku nl kx nm la nn le no li np lm nh ni nj nk bi translated">在前端删除不必要的库。</li><li id="c74c" class="nc nd iq kt b ku nl kx nm la nn le no li np lm nh ni nj nk bi translated">减少客户的一口消费。</li><li id="7d7e" class="nc nd iq kt b ku nl kx nm la nn le no li np lm nh ni nj nk bi translated">添加数据库索引。</li></ul><p id="223a" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">我看到的属于这一类的优化的一个常见错误是没有防止系统在未来出现同样的性能下降。让我们用一个例子:<em class="nq"> Ignacio通过删除N + 1个查询改进了端点X，但没有阻止任何其他开发人员再次添加N + 1个查询</em>。完整的修复需要Ignacio编写测试，防止端点在将来重新添加N + 1个查询。<a class="ae ln" href="https://medium.com/p/7d5346313807" rel="noopener">不要错过这关键的一步</a>！</p><p id="ad73" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">关于这一类别的一个有趣的事情是，与调查花费的时间相比，修复问题的时间通常很短。调查可能需要很多天，修复可能只需简单地改变线路，但影响可能是巨大的！</p><h2 id="9695" class="mq lp iq bd lq mr ms dn lu mt mu dp ly la mv mw ma le mx my mc li mz na me nb bi translated">宏优化</h2><p id="bcf8" class="pw-post-body-paragraph kr ks iq kt b ku mg jr kw kx mh ju kz la mi lc ld le mj lg lh li mk lk ll lm ij bi translated">这是我觉得最好玩的一类。通常，努力程度和范围为中/高。它需要大量的调查、验证和测试，开发者需要证明这些努力是值得的。</p><p id="3772" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">这种类型的优化通常会使平台更难理解。一个例子是引入一个新的缓存系统。它以使平台<em class="nq"> Y </em>更加复杂为代价，使平台<em class="nq"> X </em>快了几倍。</p><p id="a0c9" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">一些例子:</p><ul class=""><li id="6df4" class="nc nd iq kt b ku kv kx ky la ne le nf li ng lm nh ni nj nk bi translated">跨平台引入新的缓存策略。</li><li id="5118" class="nc nd iq kt b ku nl kx nm la nn le no li np lm nh ni nj nk bi translated">新技术(数据库、图书馆等。).</li><li id="7ab0" class="nc nd iq kt b ku nl kx nm la nn le no li np lm nh ni nj nk bi translated">数据库迁移。</li><li id="9af8" class="nc nd iq kt b ku nl kx nm la nn le no li np lm nh ni nj nk bi translated">模型重新设计。</li><li id="23d6" class="nc nd iq kt b ku nl kx nm la nn le no li np lm nh ni nj nk bi translated">平台的重新架构。</li></ul><p id="3bac" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">一个宏优化的真实例子:在<a class="ae ln" href="https://shopify.com/" rel="noopener ugc nofollow" target="_blank"> Shopify </a>，我们从所有API中移除了<em class="nq"> page </em> param，并用游标取而代之。这允许所有分页查询使用<a class="ae ln" href="https://ignaciochiazzo.medium.com/paginating-requests-in-apis-d4883d4c1c4c" rel="noopener">基于光标的分页</a>基，而不是<a class="ae ln" href="https://ignaciochiazzo.medium.com/paginating-requests-in-apis-d4883d4c1c4c" rel="noopener">基于偏移量的分页</a>，极大地提高了性能。付出的努力和影响非常大，我们必须让不同的人相信这样做是值得的。如果你想了解更多关于这个变化的信息，请看<a class="ae ln" href="https://ignaciochiazzo.medium.com/paginating-requests-in-apis-d4883d4c1c4c" rel="noopener">这篇文章</a>。</p><h1 id="5286" class="lo lp iq bd lq lr ls lt lu lv lw lx ly jw lz jx ma jz mb ka mc kc md kd me mf bi translated"><strong class="ak">开发人员花费的最佳时间</strong></h1><p id="752d" class="pw-post-body-paragraph kr ks iq kt b ku mg jr kw kx mh ju kz la mi lc ld le mj lg lh li mk lk ll lm ij bi translated">在决定我们应该关注哪些领域时，我们应该关注以下三个主要方面:</p><ul class=""><li id="5b5d" class="nc nd iq kt b ku kv kx ky la ne le nf li ng lm nh ni nj nk bi translated"><strong class="kt ir">影响:</strong>根据平台的不同，有不同的方法来衡量影响(例如，受影响的用户数、请求数/总请求数)。</li><li id="236a" class="nc nd iq kt b ku nl kx nm la nn le no li np lm nh ni nj nk bi translated"><strong class="kt ir">努力:</strong>需要多少时间和资源。</li><li id="7f9d" class="nc nd iq kt b ku nl kx nm la nn le no li np lm nh ni nj nk bi translated"><strong class="kt ir">增加了平台的复杂性:</strong>应用优化后，平台的复杂性增加了多少？宏优化的复杂度通常很高。</li></ul><div class="kg kh ki kj gt ab cb"><figure class="nr kk ns nt nu nv nw paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><img src="../Images/ef90c028766b6bc8d02d3b8985078a8f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1030/format:webp/1*ldPlQOvalglwzYvo-Dczug.jpeg"/></div></figure><figure class="nr kk nx nt nu nv nw paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><img src="../Images/757228738849db0e634aa86700cdfc35.png" data-original-src="https://miro.medium.com/v2/resize:fit:972/format:webp/1*uQj6pLlXgA4WMm_Ot04IjA.jpeg"/></div><p class="mm mn gj gh gi mo mp bd b be z dk ny di nz oa translated">图二。微观和宏观优化分类。</p></figure></div><p id="0e1c" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">必须避免任何宏观优化和低影响的更改！具有高影响力的微优化是必备的。</p><p id="bfc3" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">应该只做一部分具有高影响的宏优化，但是开发人员必须证明这种努力是值得的。</p><p id="0bee" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">除非影响非常大，否则必须避免任何增加平台高度复杂性的更改！这些优化通常是花费大量时间的项目，会使平台过于复杂，不值得付出努力。它可能以降低平台的可扩展性为代价来解决特定的问题。请参见以下示例:</p><p id="6f06" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">想象一下，如果Airbnb有一个非常复杂的系统来计算价格。“<em class="nq"> stay </em>的价格考虑了许多因素，如需求、报价、位置、价格历史、用户位置等等。我们可以根据影响价格的所有因素，引入仅用于定价的缓存层。这可以很好地工作，但是它使系统依赖于这个缓存。任何添加到定价中的新因素都必须使缓存无效，任何错过的因素都会导致金钱损失！</p><h1 id="5b60" class="lo lp iq bd lq lr ls lt lu lv lw lx ly jw lz jx ma jz mb ka mc kc md kd me mf bi translated"><strong class="ak">结论</strong></h1><p id="b46f" class="pw-post-body-paragraph kr ks iq kt b ku mg jr kw kx mh ju kz la mi lc ld le mj lg lh li mk lk ll lm ij bi translated">这个框架让您知道哪些性能优化是值得努力的。它并不完美，也不详尽，但对我来说效果很好。</p><p id="920b" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">在处理性能时，考虑添加到平台的工作量、影响和复杂性。</p><p id="af38" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">最后，性能应该是开发者核心的一部分，不应该被认为是次要的东西。理想情况下，我们交付性能最佳的软件。然而，在实践中，这是非常困难的，并且需要项目后的绩效计划。</p><p id="6ae0" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">在<a class="ae ln" href="https://medium.com/p/7d5346313807" rel="noopener">的下一篇文章</a>中学习如何应用这个框架，这篇文章描述了<a class="ae ln" href="https://medium.com/p/7d5346313807" rel="noopener">提高绩效的6个步骤</a>。</p><p id="9565" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">你见过最多的是哪一类？感谢您的阅读。我很想听听你的想法。</p><p id="ca5a" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">感谢<a class="ae ln" href="https://twitter.com/alexcwatt" rel="noopener ugc nofollow" target="_blank"> Alex Watt </a>和<a class="ae ln" href="https://twitter.com/sidb_97" rel="noopener ugc nofollow" target="_blank"> Siddhant Bajaj </a>审阅这篇文章。</p></div></div>    
</body>
</html>