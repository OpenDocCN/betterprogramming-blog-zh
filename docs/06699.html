<html>
<head>
<title>How to Secure Angular Environment Variables for Use in GitHub Actions</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何保护GitHub动作中使用的角度环境变量</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/how-to-secure-angular-environment-variables-for-use-in-github-actions-39c07587d590?source=collection_archive---------2-----------------------#2020-10-27">https://betterprogramming.pub/how-to-secure-angular-environment-variables-for-use-in-github-actions-39c07587d590?source=collection_archive---------2-----------------------#2020-10-27</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="501a" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">通过公共存储库保护Angular项目中的机密API密钥，并为自动化工作流设置它们</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi kf"><img src="../Images/697cc34c1242724861c95ea742792f7b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*k0l8GMM0IRV0LIxRqri6dw.png"/></div><p class="kn ko gj gh gi kp kq bd b be z dk translated">在GitHub操作中使用dotenv保护角度环境变量。作者照片。</p></figure><p id="15d9" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">在花了一个月的时间浏览了GitHub的各种新特性之后——尤其是GitHub动作——是时候在我的一个开源Angular项目中使用它了。然而，一个关键的问题是隐藏我用来将它部署到Firebase中的API密钥。我要求应用程序在我的本地环境中正常工作，同时设置它在代码签入GitHub后持续部署。所有这些都不会损害API密钥。通常，在将您的代码放入任何公共存储库之前，保护这些机密信息被认为是一种安全的做法。</p><p id="0a52" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">在谷歌上搜索这一设置导致了一篇关于这一主题的极好的文章。这个信息丰富的指南帮助我设置了在本地工作的基本配置，但不幸的是，我无法使用GitHub Actions让它为自动化工作流工作。当然，我最终还是成功了！因此，让我们详细检查一下解决方案。</p></div><div class="ab cl lo lp hu lq" role="separator"><span class="lr bw bk ls lt lu"/><span class="lr bw bk ls lt lu"/><span class="lr bw bk ls lt"/></div><div class="ij ik il im in"><h1 id="449c" class="lv lw iq bd lx ly lz ma mb mc md me mf jw mg jx mh jz mi ka mj kc mk kd ml mm bi translated">目标</h1><p id="b540" class="pw-post-body-paragraph kr ks iq kt b ku mn jr kw kx mo ju kz la mp lc ld le mq lg lh li mr lk ll lm ij bi translated">保护Angular项目的<code class="fe ms mt mu mv b">environments</code>目录中的机密API密钥，以便在GitHub操作中使用。</p></div><div class="ab cl lo lp hu lq" role="separator"><span class="lr bw bk ls lt lu"/><span class="lr bw bk ls lt lu"/><span class="lr bw bk ls lt"/></div><div class="ij ik il im in"><h1 id="905d" class="lv lw iq bd lx ly lz ma mb mc md me mf jw mg jx mh jz mi ka mj kc mk kd ml mm bi translated">步伐</h1><h2 id="3727" class="mw lw iq bd lx mx my dn mb mz na dp mf la nb nc mh le nd ne mj li nf ng ml nh bi translated">1.设置. gitignore文件</h2><p id="ed12" class="pw-post-body-paragraph kr ks iq kt b ku mn jr kw kx mo ju kz la mp lc ld le mq lg lh li mr lk ll lm ij bi translated">确保<code class="fe ms mt mu mv b">environments</code>目录的内容是<code class="fe ms mt mu mv b">.gitignore</code>文件的一部分(在项目根目录下),这样它们就不会是被推到公共存储库中的代码的一部分。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi ni"><img src="../Images/2c3b4b1087924f49e946ba4c263204ab.png" data-original-src="https://miro.medium.com/v2/resize:fit:1006/format:webp/1*FJs8XYjScoKsl1wh_b_J6A.png"/></div></figure><h2 id="5b07" class="mw lw iq bd lx mx my dn mb mz na dp mf la nb nc mh le nd ne mj li nf ng ml nh bi translated">2.安装Node.js包</h2><p id="861a" class="pw-post-body-paragraph kr ks iq kt b ku mn jr kw kx mo ju kz la mp lc ld le mq lg lh li mr lk ll lm ij bi translated">我们需要安装<code class="fe ms mt mu mv b">yargs</code>来解析命令行参数，安装<code class="fe ms mt mu mv b">dotenv</code>来将环境变量从<code class="fe ms mt mu mv b">.env</code>文件加载到<code class="fe ms mt mu mv b">process.env</code>。此外，我们将使用本机<code class="fe ms mt mu mv b">fs</code>包(无需安装)来处理文件系统。</p><pre class="kg kh ki kj gt nj mv nk nl aw nm bi"><span id="4c8a" class="mw lw iq mv b gy nn no l np nq">npm i -D yargs dotenv</span></pre><h2 id="00b5" class="mw lw iq bd lx mx my dn mb mz na dp mf la nb nc mh le nd ne mj li nf ng ml nh bi translated">3.设置一个<code class="fe ms mt mu mv b">.env</code>文件</h2><p id="415b" class="pw-post-body-paragraph kr ks iq kt b ku mn jr kw kx mo ju kz la mp lc ld le mq lg lh li mr lk ll lm ij bi translated">应该在项目根文件夹中创建<code class="fe ms mt mu mv b">.env</code>文件。它允许我们安全地定义秘密API密钥(例如<code class="fe ms mt mu mv b">FIREBASE_API_KEY</code>)。您可以根据需要向该文件添加任意数量的密钥或访问令牌。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi nr"><img src="../Images/0c5e407d9c3906c53bf15f3c838bd9a8.png" data-original-src="https://miro.medium.com/v2/resize:fit:936/format:webp/1*X-xOGo-8pK_z9eWrUd535A.png"/></div></figure><h2 id="6da1" class="mw lw iq bd lx mx my dn mb mz na dp mf la nb nc mh le nd ne mj li nf ng ml nh bi translated">4.设置setEnv.ts文件</h2><p id="1322" class="pw-post-body-paragraph kr ks iq kt b ku mn jr kw kx mo ju kz la mp lc ld le mq lg lh li mr lk ll lm ij bi translated">有人可能想知道为什么我们不在Angular项目中使用默认提供的<code class="fe ms mt mu mv b">environment.ts</code>和<code class="fe ms mt mu mv b">environment.prod.ts</code>文件。这是因为Angular默认情况下认为这些文件是静态的，因此它们不会被编译。</p><p id="3693" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">因此，我们有必要找到一种在编译过程中动态生成这些文件的方法。这就是<code class="fe ms mt mu mv b">setEnv.ts</code>文件出现的地方。我们在哪里添加这个文件？让我们在<code class="fe ms mt mu mv b">src\assets</code>中创建一个<code class="fe ms mt mu mv b">scripts</code>目录来保存这个文件(<code class="fe ms mt mu mv b">src\assets\setEnv.ts</code>)。</p><ul class=""><li id="e1e0" class="ns nt iq kt b ku kv kx ky la nu le nv li nw lm nx ny nz oa bi translated">为了取消TypeScript lint建议，我们将代码放在:</li></ul><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi ob"><img src="../Images/5888c4b818d04ebd758f845523756f07.png" data-original-src="https://miro.medium.com/v2/resize:fit:952/format:webp/1*bP_ojIog7FjBf4lGGFyNkw.png"/></div></figure><ul class=""><li id="c73a" class="ns nt iq kt b ku kv kx ky la nu le nv li nw lm nx ny nz oa bi translated">我们使用以下方式导入要使用的方法:</li></ul><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi oc"><img src="../Images/d0317ebed80ed2b109c2864917aa417d.png" data-original-src="https://miro.medium.com/v2/resize:fit:996/format:webp/1*WcQTvGLAn-FEjlZuzq3YuA.png"/></div></figure><ul class=""><li id="5c45" class="ns nt iq kt b ku kv kx ky la nu le nv li nw lm nx ny nz oa bi translated">我们将配置<code class="fe ms mt mu mv b">dotenv</code>将所有环境变量从<code class="fe ms mt mu mv b">.env</code>文件传递到<code class="fe ms mt mu mv b">process.env</code>。此外，我们将使用<code class="fe ms mt mu mv b">yargs</code>来读取调用该文件时传递的命令行参数(<code class="fe ms mt mu mv b">— environment=prod</code>或<code class="fe ms mt mu mv b">— environment=dev</code>)。</li></ul><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi od"><img src="../Images/94ea95d432fae11403657263b0c806cc.png" data-original-src="https://miro.medium.com/v2/resize:fit:990/format:webp/1*cP8V6i9PkwkZFSGeRqjnLw.png"/></div></figure><ul class=""><li id="897f" class="ns nt iq kt b ku kv kx ky la nu le nv li nw lm nx ny nz oa bi translated">我们将创建一个助手函数，允许我们将动态生成的环境变量复制到它们各自的文件中。如果文件不存在，它将在给定的路径下创建一个新文件。</li></ul><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi oe"><img src="../Images/8677bee6d9ed1b595679492e6fc903a5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1060/format:webp/1*P7-ljAAUBhe34127oRGj7Q.png"/></div></figure><ul class=""><li id="8186" class="ns nt iq kt b ku kv kx ky la nu le nv li nw lm nx ny nz oa bi translated">由于我们将<code class="fe ms mt mu mv b">environment.ts</code>和<code class="fe ms mt mu mv b">environment.prod.ts</code>添加到了<code class="fe ms mt mu mv b">.gitignore</code>文件中，这些文件和<code class="fe ms mt mu mv b">environments</code>目录将不会出现在GitHub的公共存储库中。因此，每次触发新的自动化工作流时，都会动态地创建这些工作流。</li></ul><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi of"><img src="../Images/11710d4759a4f1d4f48dcb82ccf54b3f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1328/format:webp/1*UQrEpb1Qio3Udpg61emJDA.png"/></div></figure><ul class=""><li id="9fdd" class="ns nt iq kt b ku kv kx ky la nu le nv li nw lm nx ny nz oa bi translated">最后，我们动态生成特定于所选环境的环境变量，其中包含秘密的API密钥。对于本地开发(<code class="fe ms mt mu mv b">npm run serve</code>)，环境变量将被添加到<code class="fe ms mt mu mv b">environment.ts</code>，而对于生产环境<em class="og"> </em> ( <code class="fe ms mt mu mv b">npm run build</code>)，它们将被添加到<code class="fe ms mt mu mv b">environment.prod.ts</code>文件。</li></ul><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="oi oj di ok bf ol"><div class="gh gi oh"><img src="../Images/97b6e84082b5fc54efe14bb486f36447.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*VUwDWmBpAcRYnQhIMbT-lQ.png"/></div></div></figure><p id="8bf9" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">完整的<code class="fe ms mt mu mv b">.setEnv</code>文件如下所示:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="om on l"/></div></figure><h2 id="7a3a" class="mw lw iq bd lx mx my dn mb mz na dp mf la nb nc mh le nd ne mj li nf ng ml nh bi translated">5.更新<code class="fe ms mt mu mv b">package.json</code></h2><p id="0db0" class="pw-post-body-paragraph kr ks iq kt b ku mn jr kw kx mo ju kz la mp lc ld le mq lg lh li mr lk ll lm ij bi translated">为了用特定的命令行参数调用<code class="fe ms mt mu mv b">setEnv.ts</code>，我们需要更新<code class="fe ms mt mu mv b">package.json</code>:</p><ul class=""><li id="5cc6" class="ns nt iq kt b ku kv kx ky la nu le nv li nw lm nx ny nz oa bi translated">我们将创建一个执行<code class="fe ms mt mu mv b">setEnv.ts</code>的<code class="fe ms mt mu mv b">config</code>脚本。</li><li id="5bfc" class="ns nt iq kt b ku oo kx op la oq le or li os lm nx ny nz oa bi translated">对于本地开发，<code class="fe ms mt mu mv b">npm run start</code>将运行<code class="fe ms mt mu mv b">config </code>脚本和<code class="fe ms mt mu mv b">dev</code>参数。</li><li id="a99e" class="ns nt iq kt b ku oo kx op la oq le or li os lm nx ny nz oa bi translated">对于生产，<code class="fe ms mt mu mv b">npm run build</code>将运行<code class="fe ms mt mu mv b">config </code>脚本和<code class="fe ms mt mu mv b">prod</code>的参数。</li></ul><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi ot"><img src="../Images/0e7e9e2aabbe29dcd6dad94c1e0c98c1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1138/format:webp/1*JResIkZB0VRZZ_Z11TBq9w.png"/></div></figure></div><div class="ab cl lo lp hu lq" role="separator"><span class="lr bw bk ls lt lu"/><span class="lr bw bk ls lt lu"/><span class="lr bw bk ls lt"/></div><div class="ij ik il im in"><h1 id="06f3" class="lv lw iq bd lx ly lz ma mb mc md me mf jw mg jx mh jz mi ka mj kc mk kd ml mm bi translated">GitHub操作中的自动化工作流</h1><p id="f0d6" class="pw-post-body-paragraph kr ks iq kt b ku mn jr kw kx mo ju kz la mp lc ld le mq lg lh li mr lk ll lm ij bi translated">现在可以使用GitHub Actions自动测试、构建项目，并将其部署到任何主机提供商(Firebase、Netlify、Heroku等)中。).尽管环境变量不存在于公共存储库中，但是每次触发工作流时，都会动态生成这些变量。</p></div><div class="ab cl lo lp hu lq" role="separator"><span class="lr bw bk ls lt lu"/><span class="lr bw bk ls lt lu"/><span class="lr bw bk ls lt"/></div><div class="ij ik il im in"><h1 id="ea71" class="lv lw iq bd lx ly lz ma mb mc md me mf jw mg jx mh jz mi ka mj kc mk kd ml mm bi translated">结论</h1><p id="09ca" class="pw-post-body-paragraph kr ks iq kt b ku mn jr kw kx mo ju kz la mp lc ld le mq lg lh li mr lk ll lm ij bi translated">我们能够在<code class="fe ms mt mu mv b">.env</code>文件中指定机密的API密钥，根据所选的环境，将环境变量动态生成到Angular项目中的<code class="fe ms mt mu mv b">environment.ts</code>和<code class="fe ms mt mu mv b">environment.prod.ts</code>中。</p><p id="ab10" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">此外，由于这些文件都没有签入GitHub，我们不仅设法保护了它，还允许GitHub Actions中的任何CI或CD工作流独立执行。</p></div></div>    
</body>
</html>