<html>
<head>
<title>Advanced TypeScript: How to Use Interface Inheritance With Discriminated Unions</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">高级TypeScript:如何对有区别的联合使用接口继承</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/advanced-typescript-how-to-use-interface-inheritance-with-discriminated-unions-dddf77cb3836?source=collection_archive---------3-----------------------#2020-09-01">https://betterprogramming.pub/advanced-typescript-how-to-use-interface-inheritance-with-discriminated-unions-dddf77cb3836?source=collection_archive---------3-----------------------#2020-09-01</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="7a61" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">当您的事件相互延伸时，您需要做什么</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/51c75c610336a637fb797f4a41186077.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*5Xb4DWevClI5OA0zKnBSXw.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">修改图像。原via <a class="ae kv" href="https://unsplash.com/photos/PH8GUKG-Do0" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>。</p></figure><p id="b598" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">最近，我需要为将在TypeScript项目中使用的JavaScript事件侦听器创建类型。有多个相互扩展的事件——子事件包含父事件的属性，事件属性需要在侦听器中访问。</p><p id="7784" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">显而易见的解决方案是对联合类型使用接口继承。我使用可靠的资源TypeScript Handbook、Stack Overflow和Medium——寻找实现这一点的方法，但是，我找不到如何使它工作的描述。我需要继续使用这种方法，因为另一个明显的解决方案很糟糕:复制事件属性🤢。</p><p id="da83" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">所以，我用这个问题做了一个玩具例子，和我在<a class="ae kv" href="https://tradeshift.com/jobs/" rel="noopener ugc nofollow" target="_blank">贸易班</a>的队友讨论了这个问题，我们一起想出了一个解决方案😎。</p><p id="9cb5" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这是我希望找到的文章。</p></div><div class="ab cl ls lt hu lu" role="separator"><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx"/></div><div class="ij ik il im in"><h1 id="0a62" class="lz ma iq bd mb mc md me mf mg mh mi mj jw mk jx ml jz mm ka mn kc mo kd mp mq bi translated">受歧视的工会</h1><p id="88e4" class="pw-post-body-paragraph kw kx iq ky b kz mr jr lb lc ms ju le lf mt lh li lj mu ll lm ln mv lp lq lr ij bi translated">TypeScript提供了一个强大的功能，允许将多个接口组合成一个联合类型。这意味着可以用一个参数调用一个函数，该参数的接口是union类型中的任何一个接口。像<code class="fe mw mx my mz b">type</code>这样的公共属性应该包含在每个接口中，TypeScript使用它来确定在访问属性时验证哪个接口。</p><h2 id="a9cd" class="na ma iq bd mb nb nc dn mf nd ne dp mj lf nf ng ml lj nh ni mn ln nj nk mp nl bi translated"><strong class="ak">区别并集的一个例子:</strong></h2><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nm nn l"/></div></figure><pre class="kg kh ki kj gt no mz np nq aw nr bi"><span id="3d8b" class="na ma iq mz b gy ns nt l nu nv">Output:</span><span id="5069" class="na ma iq mz b gy nw nt l nu nv">Stewie's bark volume is 77 db. <br/>Reginald's coat type is tabby.</span></pre></div><div class="ab cl ls lt hu lu" role="separator"><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx"/></div><div class="ij ik il im in"><h1 id="9dbc" class="lz ma iq bd mb mc md me mf mg mh mi mj jw mk jx ml jz mm ka mn kc mo kd mp mq bi translated">接口继承</h1><p id="a9fe" class="pw-post-body-paragraph kw kx iq ky b kz mr jr lb lc ms ju le lf mt lh li lj mu ll lm ln mv lp lq lr ij bi translated">TypeScript的另一个有用的特性是接口继承。接口可以扩展其他接口，这导致父接口的属性被添加到子接口。这对于维护软件开发的<a class="ae kv" href="https://en.wikipedia.org/wiki/Don%27t_repeat_yourself" rel="noopener ugc nofollow" target="_blank"> DRY原则来说非常棒。</a></p><h2 id="a49a" class="na ma iq bd mb nb nc dn mf nd ne dp mj lf nf ng ml lj nh ni mn ln nj nk mp nl bi translated"><strong class="ak">接口继承的一个例子:</strong></h2><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nm nn l"/></div></figure><p id="a018" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">目前为止一切顺利！</p></div><div class="ab cl ls lt hu lu" role="separator"><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx"/></div><div class="ij ik il im in"><h1 id="8c5b" class="lz ma iq bd mb mc md me mf mg mh mi mj jw mk jx ml jz mm ka mn kc mo kd mp mq bi translated">问题:继承接口的联合</h1><p id="3430" class="pw-post-body-paragraph kw kx iq ky b kz mr jr lb lc ms ju le lf mt lh li lj mu ll lm ln mv lp lq lr ij bi translated">当联合类型中的接口互相扩展时会发生什么？这是我在建模<a class="ae kv" href="https://docs.appcues.com/article/301-client-side-events-reference" rel="noopener ugc nofollow" target="_blank">客户端AppCues事件</a>时需要使用的模式。</p><p id="4ab4" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><strong class="ky ir">第一次尝试(失败🥺): </strong></p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nx"><img src="../Images/ec89014689611c90a797e28b07acd599.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Xe6-xlY35pgH59eiwwLuBg.png"/></div></div></figure><p id="d93d" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">因为<code class="fe mw mx my mz b">name</code>存在于所有接口中，所以父接口需要包含所有子<code class="fe mw mx my mz b">name</code>值(子属性是父属性的专门化)。这意味着将子事件名称添加到父事件中，这并不理想。更糟糕的是，由于父母包含了孩子的<code class="fe mw mx my mz b">name</code>价值观(见红色曲线),歧视失败了😬).</p></div><div class="ab cl ls lt hu lu" role="separator"><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx"/></div><div class="ij ik il im in"><h1 id="31a6" class="lz ma iq bd mb mc md me mf mg mh mi mj jw mk jx ml jz mm ka mn kc mo kd mp mq bi translated">解决方案:引入基本接口</h1><p id="5083" class="pw-post-body-paragraph kw kx iq ky b kz mr jr lb lc ms ju le lf mt lh li lj mu ll lm ln mv lp lq lr ij bi translated">我们得出的解决方案是为每个事件添加一个基本接口，基本接口互相扩展。<strong class="ky ir">基本接口包含的属性也需要出现在子事件</strong>中。</p><p id="a9b5" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">每个事件还有一个从其基本接口扩展而来的辅助接口。<strong class="ky ir">因为辅助接口不互相扩展，所以它们包含不被继承的值</strong>——在本例中，是<code class="fe mw mx my mz b">name</code>属性。辅助接口被组合成联合类型。</p><p id="935d" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><strong class="ky ir">继承接口的区别并集:</strong></p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nm nn l"/></div></figure><pre class="kg kh ki kj gt no mz np nq aw nr bi"><span id="23e5" class="na ma iq mz b gy ns nt l nu nv">Output:</span><span id="4d19" class="na ma iq mz b gy nw nt l nu nv">best flow <br/>best flow, best step <br/>best flow, best step, best interaction</span></pre><p id="aa98" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">有用！🙌</p><p id="6e77" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">遵循最佳实践，我还使用了一个<code class="fe mw mx my mz b">enum</code>作为事件名称，并在接口属性中添加了<code class="fe mw mx my mz b">readonly</code>修饰符。</p></div><div class="ab cl ls lt hu lu" role="separator"><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx"/></div><div class="ij ik il im in"><h1 id="4a81" class="lz ma iq bd mb mc md me mf mg mh mi mj jw mk jx ml jz mm ka mn kc mo kd mp mq bi translated">结论</h1><p id="ca3e" class="pw-post-body-paragraph kw kx iq ky b kz mr jr lb lc ms ju le lf mt lh li lj mu ll lm ln mv lp lq lr ij bi translated">TypeScript是一种用于向JavaScript APIs添加开发时检查的表达性语言。使用具有区别联合的接口继承模式可以防止无效的属性访问，并简化开发体验。编码快乐！</p></div></div>    
</body>
</html>