<html>
<head>
<title>Dependency Injection in Less Than 100 Lines of Pure JavaScript</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">不到100行纯JavaScript代码中的依赖注入</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/dependency-injection-in-less-than-100-lines-of-pure-javascript-9f349c9c6b47?source=collection_archive---------4-----------------------#2019-11-16">https://betterprogramming.pub/dependency-injection-in-less-than-100-lines-of-pure-javascript-9f349c9c6b47?source=collection_archive---------4-----------------------#2019-11-16</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="cce1" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">使用Agular令人敬畏的依赖注入</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi ki"><img src="../Images/f1df9f66c8590637ddca1ea763feebde.png" data-original-src="https://miro.medium.com/v2/resize:fit:1222/format:webp/1*yl-uGt_0kW3ZjJ5prFkx-Q.png"/></div></figure><p id="a952" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">如果你曾经使用过Angular很长时间，你可能已经注意到它的依赖注入有多棒。只需调用<a class="ae lm" href="https://angular.io/api/core/Injectable" rel="noopener ugc nofollow" target="_blank">injectible decorator</a>，您就可以在应用程序中引入任何服务的可重用实例，只需引用类型:</p><pre class="kj kk kl km gt ln lo lp lq aw lr bi"><span id="c8fe" class="ls lt it lo b gy lu lv l lw lx">import {Injectable} from '@angular/core';<br/>import {BackendService} from './backend.service';<br/><br/>@Injectable()<br/>export class AuthService {<br/>  constructor(<br/>      private backend: BackendService,<br/>  ) {<br/>     this.backend.somethingAwesome();<br/>  }<br/>}</span></pre><p id="22a6" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">注意，我不需要在任何地方实例化<code class="fe ly lz ma lo b">BackendService</code>,因为Angular已经为我处理了它。这有一个额外的好处，确保在运行时只创建一个<code class="fe ly lz ma lo b">BackendService</code>实例，这对内存有好处！</p></div><div class="ab cl mb mc hx md" role="separator"><span class="me bw bk mf mg mh"/><span class="me bw bk mf mg mh"/><span class="me bw bk mf mg"/></div><div class="im in io ip iq"><h1 id="9596" class="mi lt it bd mj mk ml mm mn mo mp mq mr jz ms ka mt kc mu kd mv kf mw kg mx my bi translated">背景—过滤器</h1><p id="1b1a" class="pw-post-body-paragraph kq kr it ks b kt mz ju kv kw na jx ky kz nb lb lc ld nc lf lg lh nd lj lk ll im bi translated">在过去一年左右的时间里，我一直在创建一个名为<a class="ae lm" href="https://flitter.garrettmills.dev/" rel="noopener ugc nofollow" target="_blank"> Flitter </a>的Express支持的JavaScript网络应用框架。Flitter的主要哲学之一是一切都应该是一个类。因此，虽然Flitter合并了许多传统的ES5库——Express、Mongoose、Agenda.js等——但它提供了一个使用ES6+类定义资源的系统。这就是为什么在Flitter中你永远看不到，例如，基于模式的模型定义:</p><pre class="kj kk kl km gt ln lo lp lq aw lr bi"><span id="6ada" class="ls lt it lo b gy lu lv l lw lx">// Mongoose - from the getting started guide<br/>var kittySchema = new mongoose.Schema({<br/>  name: String<br/>});<br/><br/>kittySchema.methods.speak = function () {<br/>  var greeting = this.name<br/>    ? "Meow name is " + this.name<br/>    : "I don't have a name";<br/>  console.log(greeting);<br/>}</span></pre><p id="5223" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">相反，我们定义适当的类:</p><pre class="kj kk kl km gt ln lo lp lq aw lr bi"><span id="147b" class="ls lt it lo b gy lu lv l lw lx">// Using Flitter classes<br/>const Model = require('libflitter/database/Model')<br/>class Kitty extends Model {<br/>  static get __context() {<br/>    return {<br/>      name: String<br/>    }<br/>  }<br/><br/>  speak() {<br/>    const greeting = this.name<br/>      ? `Meow name is ${this.name}` : `I don't have a name`<br/>    console.log(greeting)<br/>  }<br/>}</span></pre><p id="3ffa" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">将我们所有的资源定义在标准类中，从主观上来说，比大量不同的模式格式和函数调用更容易维护和推理。此外，它还有一个额外的好处，那就是能够继承我们所有现成的资源。然而，它提出了一个有趣的问题。</p></div><div class="ab cl mb mc hx md" role="separator"><span class="me bw bk mf mg mh"/><span class="me bw bk mf mg mh"/><span class="me bw bk mf mg"/></div><div class="im in io ip iq"><h1 id="c5de" class="mi lt it bd mj mk ml mm mn mo mp mq mr jz ms ka mt kc mu kd mv kf mw kg mx my bi translated">更高级服务的问题是</h1><p id="1fa2" class="pw-post-body-paragraph kq kr it ks b kt mz ju kv kw na jx ky kz nb lb lc ld nc lf lg lh nd lj lk ll im bi translated">如果一切都是一个类，我们如何从我们的应用程序中访问可重用的方法？如果我们使用对象，这将很容易:</p><pre class="kj kk kl km gt ln lo lp lq aw lr bi"><span id="1468" class="ls lt it lo b gy lu lv l lw lx">// logHelpers.js<br/>module.exports = exports = {<br/>  loggingLevel: 2,<br/>  out(what, level) {<br/>    if ( !Array.isArray(what) ) what = [what]<br/>    if ( level &gt;= this.loggingLevel ) console.log(...what)<br/>  },<br/>  error(what, level = 0) { this.out(what, level) },<br/>  warn(what, level = 1) { this.out(what, level) },<br/>  info(what, level = 2) { this.out(what, level) },<br/>  debug(what, level = 3) { this.out(what, level) },<br/>}</span></pre><p id="56fb" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">这个好像很好用。我们只需导入模块，一切就绪:</p><pre class="kj kk kl km gt ln lo lp lq aw lr bi"><span id="69df" class="ls lt it lo b gy lu lv l lw lx">const logging = require('./logHelpers')<br/>const someFunction = () =&gt; {<br/>  logging.info('someFunction has executed!')<br/>}</span></pre><p id="f437" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">但是，如果我们想要创建一个不同的助手“类”来在记录错误时发送电子邮件，会发生什么情况呢？嗯，我们<em class="ne">可能</em>只是从头再写一遍整个事情，但是那不是很<a class="ae lm" href="https://en.wikipedia.org/wiki/Don't_repeat_yourself" rel="noopener ugc nofollow" target="_blank">干</a>。因此，我们替代了原始助手的特定属性:</p><pre class="kj kk kl km gt ln lo lp lq aw lr bi"><span id="ff0b" class="ls lt it lo b gy lu lv l lw lx">// emailLogHelpers.js<br/>const logHelpers = require('./logHelpers')<br/>module.exports = exports = Object.assign(logHelpers, {<br/>  emailOut(what, level) {<br/>    sendAnImaginaryEmailSomewhere(what);<br/>    this.out(what, level);<br/>  },<br/>  error(what, level = 0) {  this.emailOut(what, level) },<br/>})</span></pre><p id="844e" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">但是这引入了模糊性。<code class="fe ly lz ma lo b">error()</code>中的<code class="fe ly lz ma lo b">this</code>指的是什么？在<code class="fe ly lz ma lo b">emailOut()</code>怎么样？你能发现这个错误吗？从OOP的角度来看，这是正确的。然而，如果我们在email helpers对象上调用<code class="fe ly lz ma lo b">error()</code>，我们会得到以下错误:</p><pre class="kj kk kl km gt ln lo lp lq aw lr bi"><span id="4f9a" class="ls lt it lo b gy lu lv l lw lx">ReferenceError: out is not defined<br/>  at Object.emailLogHelpers (emailLogHelpers.js:6:4)</span></pre><p id="975f" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">为什么？因为<code class="fe ly lz ma lo b">emailOut</code>函数中的<code class="fe ly lz ma lo b">this</code>实际上并不是指组合对象，而是指创建时的原始对象。也就是右边的<code class="fe ly lz ma lo b">Object.assign</code>称呼。</p><p id="30c9" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">这可以通过定义一个<code class="fe ly lz ma lo b">LogHelper</code>类并创建一个子类<code class="fe ly lz ma lo b">EmailLogHelper</code>来轻松解决。然后，在<code class="fe ly lz ma lo b">EmailLogHelper</code>类中，<code class="fe ly lz ma lo b">this</code>将明确地引用实例本身，它已经有了所有的<code class="fe ly lz ma lo b">LogHelper</code>方法。例如:</p><pre class="kj kk kl km gt ln lo lp lq aw lr bi"><span id="605e" class="ls lt it lo b gy lu lv l lw lx">// EmailLogHelper.js<br/>const LogHelper = require('./LogHelper')<br/>class EmailLogHelper extends LogHelper {<br/>  out(what, level) {<br/>    sendAnImaginaryEmailSomewhere(what);<br/>    super.out(what, level);<br/>  }<br/>}</span></pre><p id="773a" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">但是这给我们留下了基于类的服务的根本问题:</p><blockquote class="nf ng nh"><p id="ac23" class="kq kr ne ks b kt ku ju kv kw kx jx ky ni la lb lc nj le lf lg nk li lj lk ll im bi translated">服务类必须先实例化，然后才能使用。</p></blockquote><p id="1785" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">为什么这是一个问题？那么，如果有一些配置服务<code class="fe ly lz ma lo b">LogHelper</code>依赖于(或依赖于)获得日志记录级别呢？在这种情况下，要在任何地方使用该服务，我们还必须实例化配置服务并将其传递给日志助手。但是接下来我们有20个几乎相同的相同类的实例在做同样的事情。有什么解决办法？</p><h2 id="385b" class="ls lt it bd mj nl nm dn mn nn no dp mr kz np nq mt ld nr ns mv lh nt nu mx nv bi translated">ES6中的依赖注入:比你想象的容易！</h2><p id="5754" class="pw-post-body-paragraph kq kr it ks b kt mz ju kv kw na jx ky kz nb lb lc ld nc lf lg lh nd lj lk ll im bi translated">以上所有问题的解决方案是让某个依赖注入器管理器类在应用程序启动时创建所有相关服务的实例。然后，每当一个类需要访问服务时，它就从DI获取共享实例。这节省了内存并防止了上面的手动依赖链接问题。</p><p id="4df8" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">事实证明，由于ES6类语法的好处，用普通的JavaScript实现基本的DI非常容易！我们将从多个方面着手。</p></div><div class="ab cl mb mc hx md" role="separator"><span class="me bw bk mf mg mh"/><span class="me bw bk mf mg mh"/><span class="me bw bk mf mg"/></div><div class="im in io ip iq"><h1 id="2fea" class="mi lt it bd mj mk ml mm mn mo mp mq mr jz ms ka mt kc mu kd mv kf mw kg mx my bi translated">服务类别</h1><p id="d85d" class="pw-post-body-paragraph kq kr it ks b kt mz ju kv kw na jx ky kz nb lb lc ld nc lf lg lh nd lj lk ll im bi translated">服务(对于我们的基本目的来说)只是一个类，在第一次需要它的时候应该实例化一次，然后在后续调用中重用。所以服务类现在可以完全空出来:</p><pre class="kj kk kl km gt ln lo lp lq aw lr bi"><span id="3fa0" class="ls lt it lo b gy lu lv l lw lx">class Service {<br/><br/>}</span></pre><p id="ae0a" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">最终，您可以通过跟踪服务状态或者甚至使服务本身可注入来使这个系统更加高级！也许在以后的文章中，我们会探讨这个问题。</p></div><div class="ab cl mb mc hx md" role="separator"><span class="me bw bk mf mg mh"/><span class="me bw bk mf mg mh"/><span class="me bw bk mf mg"/></div><div class="im in io ip iq"><h1 id="0793" class="mi lt it bd mj mk ml mm mn mo mp mq mr jz ms ka mt kc mu kd mv kf mw kg mx my bi translated">注射类</h1><p id="622c" class="pw-post-body-paragraph kq kr it ks b kt mz ju kv kw na jx ky kz nb lb lc ld nc lf lg lh nd lj lk ll im bi translated">这个类将是每个可以使用自动DI的类的父类。在我们的角度类比中，这类似于可注射的装饰。它应该做两件事:指定我们想要访问的服务，并提供访问它们的机制。这里有一个基于<a class="ae lm" href="https://git.garrettmills.dev/flitter/libflitter/src/branch/master/di/Injectable.js" rel="noopener ugc nofollow" target="_blank"> Flitter的可注入类</a>的例子:</p><pre class="kj kk kl km gt ln lo lp lq aw lr bi"><span id="fa61" class="ls lt it lo b gy lu lv l lw lx">// Injectable.js<br/>class Injectable {<br/>  static services = []<br/>  static __inject(container) {<br/>    this.services.forEach(serviceName =&gt; {<br/>      this.prototype[serviceName] = container.getService(serviceName)<br/>    }<br/>  }<br/>}</span></pre><p id="39be" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">显然，这缺少了一些细节和类型检查，但是基本的功能还是有的。静态地，我们定义一个服务名数组供实例访问，然后，在类被实例化之前的某个时刻，调用<code class="fe ly lz ma lo b">__inject</code>方法。该方法将服务实例注入到类'<code class="fe ly lz ma lo b">prototype</code>，这是为该类的每个实例复制的底层函数。它从一个不可思议的<code class="fe ly lz ma lo b">container</code>那里获得这些服务实例，我们很快就会谈到。</p><p id="c063" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">这使得类访问服务变得非常容易。例如:</p><pre class="kj kk kl km gt ln lo lp lq aw lr bi"><span id="6341" class="ls lt it lo b gy lu lv l lw lx">// DarkSideHelpers.js<br/>const Injectable = require('./Injectable')<br/>class DarkSideHelpers extends Injectable {<br/>  static services = ['logging']<br/>  doItAnakin() {<br/>    try {<br/>      somethingDangerous()<br/>    } catch (error) {<br/>      this.logging.error('It\'s not the Jedi way!')<br/>    }<br/>  }<br/>}</span></pre><p id="1ca0" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">不需要实例化<code class="fe ly lz ma lo b">LogHelper</code>类！这不是很棒吗？</p></div><div class="ab cl mb mc hx md" role="separator"><span class="me bw bk mf mg mh"/><span class="me bw bk mf mg mh"/><span class="me bw bk mf mg"/></div><div class="im in io ip iq"><h1 id="c70e" class="mi lt it bd mj mk ml mm mn mo mp mq mr jz ms ka mt kc mu kd mv kf mw kg mx my bi translated">服务容器</h1><p id="37cb" class="pw-post-body-paragraph kq kr it ks b kt mz ju kv kw na jx ky kz nb lb lc ld nc lf lg lh nd lj lk ll im bi translated">但是如果没有服务注入，花哨的静态对我们来说毫无用处。我们需要为他们创造一个生活的地方。因为我们希望尽可能多地重用实例，所以我们需要一个容器来为我们创建和管理那些实例。这个容器应该包含服务名到服务类的映射，如果请求的服务还不存在，实例化它们，并根据请求返回这些实例。让我们试一个:</p><pre class="kj kk kl km gt ln lo lp lq aw lr bi"><span id="5b65" class="ls lt it lo b gy lu lv l lw lx">// ServiceContainer.js<br/>const LogHelper = require('./LogHelper')<br/>const EmailLogHelper = require('./EmailLogHelper')<br/><br/>class ServiceContainer {<br/>  constructor() {<br/>    // We define the service classes here, but we won't<br/>    // instantiate them until they're needed.<br/>    this.definitions = {<br/>      logging: LogHelper,<br/>      emailLogging: EmailLogHelper,<br/>    }<br/><br/>    // This is where the container will store service instances<br/>    // so they can be reused when requested.<br/>    this.instances = {}<br/>  }<br/><br/>  getService(serviceName) {<br/>    // Create a service instance if one doesn't already exist.<br/>    if ( !this.instances[serviceName] ) {<br/>      const ServiceClass = this.definitions[serviceName]<br/>      this.instances[serviceName] = new ServiceClass()<br/>    }<br/>    return this.instances[serviceName]<br/>  }<br/>}</span></pre><p id="88aa" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">我们的基本服务容器包含服务定义列表和检索服务实例的方法。它满足了我们的需求，因为它不会在需要时实例化服务，而是重用现有的实例。因此，我们有了服务的容器，但现在我们是使所有三个部分一起工作的最后一块。</p></div><div class="ab cl mb mc hx md" role="separator"><span class="me bw bk mf mg mh"/><span class="me bw bk mf mg mh"/><span class="me bw bk mf mg"/></div><div class="im in io ip iq"><h1 id="2abe" class="mi lt it bd mj mk ml mm mn mo mp mq mr jz ms ka mt kc mu kd mv kf mw kg mx my bi translated">依赖注入器主机</h1><p id="3c4b" class="pw-post-body-paragraph kq kr it ks b kt mz ju kv kw na jx ky kz nb lb lc ld nc lf lg lh nd lj lk ll im bi translated">DI主机是整个操作的老板。它负责创建容器的一个实例(甚至多个不同的实例)并跟踪它们。它还负责在类被实例化之前调用神奇的<code class="fe ly lz ma lo b">__inject</code>方法。有几种不同的策略可以做到这一点。根据具体情况，每种方法都有自己的优点，但是我们将会看到一种适用于独立应用程序的方法:</p><pre class="kj kk kl km gt ln lo lp lq aw lr bi"><span id="d7e5" class="ls lt it lo b gy lu lv l lw lx">// DependencyInjector.js<br/>const ServiceContainer = require('./ServiceContainer.js')<br/>class DependencyInjector {<br/>  constructor() {<br/>    this.container = new ServiceContainer()<br/>  }<br/><br/>  // Injects the dependencies into an uninstantiated class<br/>  make(Class) {<br/>    return Class.__inject(this.container)<br/>  }<br/>}</span></pre><p id="cf78" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">像我们其余的类一样，这个非常简单。构造时，它创建一个新的服务容器。然后我们可以将类传递给<code class="fe ly lz ma lo b">make</code>方法，它会将容器中的依赖注入到类中。</p><p id="7de0" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">DI实例应该在整个应用程序中共享。这将有助于尽可能多地重用服务实例。这里有一个愚蠢的例子。</p><h2 id="8483" class="ls lt it bd mj nl nm dn mn nn no dp mr kz np nq mt ld nr ns mv lh nt nu mx nv bi translated">一个产生垃圾邮件的示例应用程序</h2><p id="13f1" class="pw-post-body-paragraph kq kr it ks b kt mz ju kv kw na jx ky kz nb lb lc ld nc lf lg lh nd lj lk ll im bi translated">作为如何使用这个系统的例子，让我们创建一个非常基本的应用程序。这个应用程序应该反复发送垃圾邮件给它的所有者。为此，我们将使用我们奇特的依赖注入器。</p><pre class="kj kk kl km gt ln lo lp lq aw lr bi"><span id="8ea6" class="ls lt it lo b gy lu lv l lw lx">// App.js<br/>const Injectable = require('./Injectable')<br/>class App extends Injectable {<br/>  static services = ['emailLogging']<br/>  run() {<br/>    setInterval(() =&gt; {<br/>      this.emailLogging.error('Haha made ya\' look!')<br/>    }, 5000)<br/>  }<br/>}</span></pre><p id="986e" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">我们将其与DI结合在一起，并运行应用程序:</p><pre class="kj kk kl km gt ln lo lp lq aw lr bi"><span id="bb20" class="ls lt it lo b gy lu lv l lw lx">// index.js<br/>// Create the dependency injector instance for the application<br/>const DI = require('./DependencyInjector')<br/>const di = new DI()<br/><br/>// Now, create the instance of our application using the DI to inject services<br/>const App = di.make(require('./App'))<br/>const app = new App() // Has access to the emailLogging service<br/><br/>app.run();</span></pre></div><div class="ab cl mb mc hx md" role="separator"><span class="me bw bk mf mg mh"/><span class="me bw bk mf mg mh"/><span class="me bw bk mf mg"/></div><div class="im in io ip iq"><h1 id="bb8e" class="mi lt it bd mj mk ml mm mn mo mp mq mr jz ms ka mt kc mu kd mv kf mw kg mx my bi translated">结论</h1><blockquote class="nf ng nh"><p id="2e46" class="kq kr ne ks b kt ku ju kv kw kx jx ky ni la lb lc nj le lf lg nk li lj lk ll im bi translated">依赖注入是一个强大的工具……用于降低代码的复杂性，并适当地将代码细分为纯粹的、可维护的部分。</p></blockquote><p id="c6cd" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">我们在vanilla ES6中构建了一个具有可注入依赖关系的基本应用程序。显然，这里可以进行许多增强和改进。例如，对服务和容器进行类型检查，使服务本身成为可注入的，将<code class="fe ly lz ma lo b">Injectable</code>基类移动到<a class="ae lm" href="https://www.martin-brennan.com/es7-decorators/" rel="noopener ugc nofollow" target="_blank"> ES7装饰器</a>中，这样它就可以应用到有其他父类的类中，等等。也许将来我会做一个后续。但是我希望这篇文章很好地展示了DI在使代码变得更好方面的威力。</p><p id="13f9" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">依赖注入是一个强大的工具，不仅可以降低内存负载，还可以降低代码复杂性，并适当地将代码细分为纯粹的、可维护的部分。谢谢你能走到这一步。</p><p id="5667" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">如果有问题，一定要在下面评论。</p><p id="5b54" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">加勒特（m.）</p><p id="6b96" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated"><em class="ne">附注——你可以在这里</em>  <em class="ne">找到本例中使用的代码</em> <a class="ae lm" href="https://git.garrettmills.dev/garrettmills/es6-di" rel="noopener ugc nofollow" target="_blank"> <em class="ne">。</em></a></p></div></div>    
</body>
</html>