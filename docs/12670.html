<html>
<head>
<title>Python Best Practices to Secure APIs</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">保护API的Python最佳实践</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/secure-your-python-api-7e52c475665e?source=collection_archive---------3-----------------------#2022-06-21">https://betterprogramming.pub/secure-your-python-api-7e52c475665e?source=collection_archive---------3-----------------------#2022-06-21</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="b510" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">从三个方面保护您的API</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/179b54bb89a93fbd269c012f2e268b3d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*OQlQZv2KxbdZvcFM"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">托拜厄斯·图利乌斯在<a class="ae ky" href="https://unsplash.com/" rel="noopener ugc nofollow" target="_blank"> unsplash </a>上的照片</p></figure><p id="2f0b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">API已经成为当今应用驱动世界的基础元素。包括亚马逊在内的许多公司都采用了API优先的方法。它将API的角色视为独立的产品，而不是与其他系统集成的解决方案。</p><p id="18e7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">通过设计，API向世界公开了有价值的信息，如公共天气数据和私人敏感个人身份信息(PII)数据，正因为如此，<a class="ae ky" href="https://securityboulevard.com/2021/07/for-hackers-apis-are-low-hanging-fruit/" rel="noopener ugc nofollow" target="_blank">API成为黑客的新目标。</a>没有安全的API，就不可能构建成功的产品。</p><p id="9d29" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果您还没有对您的API应用任何安全策略，那么这篇文章应该是一个警钟。像往常一样，我将为一些最佳实践提供Python实现。保护您的API可以被视为一个非功能性需求(NFR)。与性能和可靠性等其他nfr一样，很难定义API何时足够安全。</p><p id="9d99" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这就是为什么许多公司会聘请第三方来执行API渗透测试，以获得公平的判断。简而言之，pen tester将尝试攻击您的API来检查任何可利用的漏洞。</p><h2 id="976f" class="lv lw it bd lx ly lz dn ma mb mc dp md li me mf mg lm mh mi mj lq mk ml mm mn bi translated">API安全性的上下文</h2><p id="c2df" class="pw-post-body-paragraph kz la it lb b lc mo ju le lf mp jx lh li mq lk ll lm mr lo lp lq ms ls lt lu im bi translated">重要的事情先来。为什么我们甚至需要关心API安全性？API定义了调用者可以使用的一组操作。如果我不希望这个操作被调用，那么我可以简单地排除它或者把它放在防火墙后面。</p><p id="256b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">要回答这个问题，我们需要知道我们到底需要保护什么。API安全涉及几个安全领域:信息安全、网络安全和应用程序安全。</p><p id="24a9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">信息安全与保护敏感数据有关。每个端点都是应用于一个或多个对象的操作。只有具有特殊角色的一组用户才能访问对象的操作。</p><p id="b322" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">不同角色的人可以坐在同一个房间里共享同一个wifi，因此简单地阻断网络并不是最优的解决方案。当API从客户端接收请求时，需要进行某种身份验证和授权。</p><blockquote class="mt mu mv"><p id="40fc" class="kz la mw lb b lc ld ju le lf lg jx lh mx lj lk ll my ln lo lp mz lr ls lt lu im bi translated">身份验证和授权的区别。简单来说，认证就是验证你是谁的过程。例如，公司内部有一个公开员工工资的内部端点。</p><p id="b3a1" class="kz la mw lb b lc ld ju le lf lg jx lh mx lj lk ll my ln lo lp mz lr ls lt lu im bi translated">身份验证确认您是该公司的员工。授权是验证您有权访问哪些特定对象的过程。在这种情况下，如果您的身份检查通过，它将验证您是否有权检查公司PII数据。</p></blockquote><p id="72f6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">网络安全保护网络和数据免受破坏和其他威胁。围绕这个主题有很多东西，但是在API的上下文中，最适用的组件是TLS协议(传输层安全性),它提供通信安全性。</p><p id="2baf" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这基本上是HTTPS协议的S部分。在TLS握手期间，双方交换消息以确认对方，并就他们将使用的加密算法和会话密钥达成一致。从那时起，将使用会话密钥对通信进行加密。</p><p id="c581" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这是为了避免<a class="ae ky" href="https://en.wikipedia.org/wiki/Man-in-the-middle_attack" rel="noopener ugc nofollow" target="_blank">中间人</a>的攻击。</p><p id="d3e1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">值得注意的是，TLS用于加密传输中的数据，而不是静态数据。这超出了本文的范围。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi na"><img src="../Images/1bc64e0e2b4f06a538fbfbab2adbb8b2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*C2lHS6RqXIp65oxs.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">来源:<a class="ae ky" href="https://www.ssl2buy.com/wiki/wp-content/uploads/2021/02/ssl-tls-handshake.png" rel="noopener ugc nofollow" target="_blank"> TLS握手步骤</a></p></figure><p id="4f21" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">应用程序安全性确保软件能够抵御攻击和误用。例如，黑客可以在请求中注入脚本或代码，恶意数据可以欺骗软件执行非预期的命令。应用输入验证变得至关重要。</p><p id="ebc9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在本文的剩余部分，我将列出一些实用的Python安全技巧来保护应用程序。</p><h1 id="0a84" class="nb lw it bd lx nc nd ne ma nf ng nh md jz ni ka mg kc nj kd mj kf nk kg mm nl bi translated">Python中的API安全提示和实现</h1><p id="66ac" class="pw-post-body-paragraph kz la it lb b lc mo ju le lf mp jx lh li mq lk ll lm mr lo lp lq ms ls lt lu im bi translated">在了解了我们想要在API的上下文中保护什么之后，让我们跳到一些受这个<a class="ae ky" href="https://owasp.org/www-project-api-security/" rel="noopener ugc nofollow" target="_blank"> OWASP API安全十大</a>列表启发的例子。</p><h2 id="79e2" class="lv lw it bd lx ly lz dn ma mb mc dp md li me mf mg lm mh mi mj lq mk ml mm mn bi translated"><strong class="ak">认证和授权</strong></h2><p id="f2ac" class="pw-post-body-paragraph kz la it lb b lc mo ju le lf mp jx lh li mq lk ll lm mr lo lp lq ms ls lt lu im bi translated">这可能是我们在API安全性方面需要遵循的最重要的原则。有几种身份验证和授权方法，它们在复杂性和安全性方面各不相同。但是他们达成了共识——客户端必须提供某种与其身份相关的凭证，服务器将比较发送的内容和存储的内容。</p><p id="2e2c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果凭据匹配，服务器将创建一个用户会话，并向客户端发布一个cookie。</p><h2 id="9e36" class="lv lw it bd lx ly lz dn ma mb mc dp md li me mf mg lm mh mi mj lq mk ml mm mn bi translated"><em class="nm">基本认证</em></h2><p id="9714" class="pw-post-body-paragraph kz la it lb b lc mo ju le lf mp jx lh li mq lk ll lm mr lo lp lq ms ls lt lu im bi translated">基本认证是非常基本的。客户端只需在请求头中包含他们的用户名和密码。它可以是明文或编码成base 64以节省空间。</p><pre class="kj kk kl km gt nn no np nq aw nr bi"><span id="b5a2" class="lv lw it no b gy ns nt l nu nv">requests.get('https://httpbin.org/basic-auth/foo/bar', auth=('foo', 'bar'))</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nw"><img src="../Images/861a7dbf5801c53d2d01d680c5b3632d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*xQHq8ORV-VU82mr77YedCA.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">使用base64编码(由作者创建)</p></figure><p id="4fba" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">基本身份验证是最少的身份验证方法，因为如果流量被黑客劫持，黑客可以很容易地从请求头中获得凭据，或者执行暴力攻击，他们可以尝试不同的用户名和密码，直到他们发现可以工作为止。</p><h2 id="197c" class="lv lw it bd lx ly lz dn ma mb mc dp md li me mf mg lm mh mi mj lq mk ml mm mn bi translated"><em class="nm"> API键</em></h2><p id="db79" class="pw-post-body-paragraph kz la it lb b lc mo ju le lf mp jx lh li mq lk ll lm mr lo lp lq ms ls lt lu im bi translated">API密钥是服务器生成的唯一字符串，用于对客户端进行身份验证。它不同于基本身份验证中的base64字符串，在基本身份验证中，该字符串由客户端自己生成。一旦API客户机从服务器获得了密钥，它们就可以将它包含在由提供者指定的请求中的某个地方，提供者可以是查询字符串参数、请求头或请求体。</p><p id="1ea7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">密钥生成的过程取决于提供者。比如<a class="ae ky" href="https://api.nasa.gov/" rel="noopener ugc nofollow" target="_blank"> NASA开放API </a>要求客户提供姓名和邮箱。并且该密钥应该作为URL参数传递。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nx"><img src="../Images/e8a8d3a77a36fe5488dba2bf88b680bc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*OZC0LiHsxs79rwAFcCq7lQ.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">NASA API的关键一代</p></figure><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ny nz l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">在Python中使用API键</p></figure><p id="fee2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">API密钥比基本身份验证更安全。首先，它很长，很复杂，而且是随机生成的，这使得黑客很难进行暴力攻击。此外，密钥可以包含更多信息，如到期时间。即使以某种方式泄露了密钥，过了过期时间，它也会很快失效。</p><p id="2d09" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">然而，API密钥仍然不被认为是安全的。通常，软件使用一种算法来生成密钥，密钥可能包含用户信息。黑客可能只是通过学习API客户端来猜测算法。</p><p id="c0a5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">根据来自Google的<a class="ae ky" href="https://cloud.google.com/endpoints/docs/openapi/when-why-api-key" rel="noopener ugc nofollow" target="_blank">建议</a>，如果您想要了解API流量中的使用模式、阻止匿名流量或控制调用数量，则需要API密钥是有意义的，但不要使用API密钥来认证或授权用户。</p><h2 id="e6ea" class="lv lw it bd lx ly lz dn ma mb mc dp md li me mf mg lm mh mi mj lq mk ml mm mn bi translated"><em class="nm"> JWT (JSON Web令牌)</em></h2><p id="b9b1" class="pw-post-body-paragraph kz la it lb b lc mo ju le lf mp jx lh li mq lk ll lm mr lo lp lq ms ls lt lu im bi translated">JWT是一种基于令牌的身份验证。客户端首先使用用户名和密码向API提供者进行身份验证。提供者生成一个JWT并将其发送回客户端。然后，客户端将令牌添加到API请求的授权头中。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ny nz l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">Python中的JWT令牌</p></figure><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi oa"><img src="../Images/b392f471cb338fd31e356e9515b8656b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*MdCOGPPcoPcGCZWmJmZD3A.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">JWT验证流程(由作者创建)</p></figure><p id="6614" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">令牌本身有三个部分:<code class="fe ob oc od no b">Header</code>部分包含用于签名和令牌类型的算法。<code class="fe ob oc od no b">Payload</code>部分包含令牌数据，如用户名、令牌生成日期和到期日期。<code class="fe ob oc od no b">Signature</code>部分是<code class="fe ob oc od no b">Header</code>和<code class="fe ob oc od no b">Payload</code>的结果，用私钥连接和加密。</p><p id="c3b9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">当服务器收到令牌时，它将使用私钥解密签名，并将其与报头和有效负载进行比较。JWT比API密钥更安全，因为1)令牌不包含密码等敏感数据，2)使用HMAC-SHA256签署的签名更难解密。</p><p id="e8de" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">PyJWT是一个Python库，允许你编码和解码JSON Web令牌(JWT)。多用于服务器端。</p><p id="1396" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">然而，JWT仍然有一些缺点。如果用户想要更改他们的密码，并且事先已经执行了身份验证，则具有先前密码的令牌在到期之前仍然有效。此外，用户需要在令牌过期后重新认证。</p><p id="b736" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">为了应对这些挑战，一些JWT库允许刷新令牌机制，或者在某些情况下强制用户重新进行身份验证。</p><h2 id="543d" class="lv lw it bd lx ly lz dn ma mb mc dp md li me mf mg lm mh mi mj lq mk ml mm mn bi translated"><em class="nm"> OAuth 2.0 </em></h2><p id="7c69" class="pw-post-body-paragraph kz la it lb b lc mo ju le lf mp jx lh li mq lk ll lm mr lo lp lq ms ls lt lu im bi translated">OAuth 2.0是一种授权标准，允许不同的服务访问彼此的数据。一个用例是，我的应用程序可以登录到用户的Twitter帐户，并在不知道用户的Twitter凭据的情况下检索用户的推文。</p><p id="2f88" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在OAuth之前，应用程序只是通过表单检索您的Twitter凭据，然后代表您登录，这通常是有风险的，因为应用程序可能会存储所有用户的Twitter凭据。使用OAuth，服务之间的通信是基于令牌的。</p><p id="5a12" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">下面是抽象的Oauth2.0流程。总的来说，有六个步骤。应用程序首先向用户请求访问Twitter数据的授权。如果用户授权请求，意味着成功登录Twitter，应用程序将收到授权许可。</p><p id="b662" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">随后，应用程序通过提供自己的身份认证和授权许可向Twitter请求访问令牌。如果一切都通过验证，应用程序将通过提供一个访问令牌来检索用户资源。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi oe"><img src="../Images/4e0f38cb33716c6197f0f8ff5c354b49.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ertYZ38qLEHLuVKntWznyA.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">抽象Oauth 2.0流程(由作者创建)</p></figure><p id="2aa8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">实际的实现因提供商而异。我写过一篇关于<a class="ae ky" href="https://medium.com/swlh/build-a-twitter-login-component-using-nextjs-and-python-flask-44c17f057096" rel="noopener">使用NextJS和Flask </a>构建Twitter登录组件的文章，其中我详细解释了Twitter Oauth流程。</p><h1 id="ada2" class="nb lw it bd lx nc nd ne ma nf ng nh md jz ni ka mg kc nj kd mj kf nk kg mm nl bi translated"><strong class="ak">速率限制</strong></h1><p id="af32" class="pw-post-body-paragraph kz la it lb b lc mo ju le lf mp jx lh li mq lk ll lm mr lo lp lq ms ls lt lu im bi translated">速率限制是用户在给定时间段内可以进行的API调用的次数。如果超过此限制，用户可能会受到限制。任何公共API都有速率限制，因为它保护API不被过度使用，以避免DDoS攻击之类的事情。</p><p id="81a8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这里是Zoom的漏洞，由于缺乏速率限制，<a class="ae ky" href="https://cloudsecurityalliance.org/blog/2021/05/11/understanding-the-owasp-api-security-top-10/" rel="noopener ugc nofollow" target="_blank">允许攻击者在几分钟内尝试100万个Zoom密码</a>。简而言之，速率限制基于API提供者设置的阈值来限制用户对API的访问。</p><p id="0580" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">除了保护资源使用，还可以实施速率限制来控制数据流。在分布式系统中，API负载可能不会均匀地分布在处理器上。具有速率限制可以避免一个处理器过载而另一个处理器空闲的情况。</p><p id="c55c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">还可以实施费率限制来控制成本。每个请求总会产生一个成本，API收到的请求越多，它累积的成本就越多。费率限制对于节约成本可以起到极其重要的作用。API用户也是如此。</p><p id="30bb" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">许多现代API服务基于速率限制提供不同的订阅模型。在这种情况下，可以根据个人用户的需求对其应用不同的速率限制，这将确保公平使用，而不会干扰其他人的访问。</p><p id="8344" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">实现速率限制的Python库之一是<code class="fe ob oc od no b"><a class="ae ky" href="https://pypi.org/project/ratelimiter/" rel="noopener ugc nofollow" target="_blank">ratelimiter</a></code>。事实上，这个库对任何函数都应用了速率限制，而不仅仅是针对API。您可以选择将其用作装饰器或上下文管理器。</p><pre class="kj kk kl km gt nn no np nq aw nr bi"><span id="384a" class="lv lw it no b gy ns nt l nu nv">from ratelimiter import RateLimiter<br/><br/>@RateLimiter(max_calls=10, period=1)<br/>def api_call():<br/>    pass</span><span id="d967" class="lv lw it no b gy of nt l nu nv">rate_limiter = RateLimiter(max_calls=10, period=1)<br/><br/>for i in range(100):<br/>    with rate_limiter:<br/>        do_something()</span></pre><p id="46a5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">当设置并触发了速率限制时，您的API应该返回下面的HTTP状态代码:<code class="fe ob oc od no b">429 Too Many Requests</code>。虽然HTTP头没有标准名称来通知用户速率限制，但是许多现代API服务，包括GitHub和Twitter，都使用下面的头。</p><p id="af81" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">每个报头的描述可能因提供商而异。但一般来说，他们的意思是:</p><ul class=""><li id="c0f4" class="og oh it lb b lc ld lf lg li oi lm oj lq ok lu ol om on oo bi translated"><code class="fe ob oc od no b">X-RateLimit-Limit</code>:每个限制窗口允许的最大通话次数(可以是1小时/分钟)。</li><li id="9fbb" class="og oh it lb b lc op lf oq li or lm os lq ot lu ol om on oo bi translated"><code class="fe ob oc od no b">X-RateLimit-Remaning</code>:当前限制窗口中剩余的请求数。</li><li id="72bb" class="og oh it lb b lc op lf oq li or lm os lq ot lu ol om on oo bi translated"><code class="fe ob oc od no b">X-RateLimit-Reset</code>:当前速率限制窗口重置的时间，以UTC表示。</li></ul><p id="d617" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">一些API也使用类似<code class="fe ob oc od no b">Retry-After</code>的头来告诉用户何时可以再次调用它。因此，请在API文档中找到这些信息。</p><p id="0e58" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">作为一个用户，当我们收到一个429状态码时应该怎么做？我们不应该回避它，而是应该相应地处理它。有几个选项:1)响应通常包含上面的一个头，带有您应该等待直到下一个请求的秒数。请记住，在任务队列中等待太久不是一个好习惯。</p><p id="42bd" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">您应该稍后重试请求，以便为其他事情释放队列。2)如果服务器没有告诉你要等多久，可以用<a class="ae ky" href="https://cloud.google.com/iot/docs/how-tos/exponential-backoff" rel="noopener ugc nofollow" target="_blank">指数退避</a>。客户端定期重试失败的请求，请求之间的延迟不断增加。延迟从一秒、两秒、四秒、八秒或更长时间开始增加。Google在<a class="ae ky" href="https://pypi.org/project/google-api-core/" rel="noopener ugc nofollow" target="_blank"> google-api-core </a>中提供了一个<a class="ae ky" href="https://googleapis.dev/python/google-api-core/latest/retry.html" rel="noopener ugc nofollow" target="_blank">重试</a>类，这是一个使用指数回退重试函数的助手。</p><h1 id="4d7f" class="nb lw it bd lx nc nd ne ma nf ng nh md jz ni ka mg kc nj kd mj kf nk kg mm nl bi translated"><strong class="ak">审计日志</strong></h1><p id="168a" class="pw-post-body-paragraph kz la it lb b lc mo ju le lf mp jx lh li mq lk ll lm mr lo lp lq ms ls lt lu im bi translated">保护您的API的另一个方面是全面了解“谁在何时何地做了什么”？许多企业，如<a class="ae ky" href="https://cloud.google.com/service-infrastructure/docs/audit-logging" rel="noopener ugc nofollow" target="_blank"> Google </a>和<a class="ae ky" href="https://api.slack.com/admins/audit-logs#who_this_document_is_for" rel="noopener ugc nofollow" target="_blank"> Slack </a>都提供了审计日志API，它提供了对你的资源是如何被访问的分析。</p><p id="45f0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这个想法是给资源所有者查询用户操作的能力。有了这个API，资源所有者可以将资源访问数据提供给审计工具。所有者还可以监控潜在的安全问题或恶意访问企图。</p><p id="9984" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">因此，如果您是客户，可以考虑利用审计日志API来构建监控和警报系统。如果您是服务提供商，考虑向您的客户提供这样的API，并帮助他们了解任何恶意的用户模式。</p><h1 id="406b" class="nb lw it bd lx nc nd ne ma nf ng nh md jz ni ka mg kc nj kd mj kf nk kg mm nl bi translated"><strong class="ak">验证输入</strong></h1><p id="427b" class="pw-post-body-paragraph kz la it lb b lc mo ju le lf mp jx lh li mq lk ll lm mr lo lp lq ms ls lt lu im bi translated">输入验证是应用程序安全性的一部分。这是为了确保只有格式正确的数据进入系统，防止格式错误的数据在数据库中持续存在或触发恶意脚本。输入验证应该在数据流中尽可能早地发生。在API的上下文中，它应该在从客户端收到数据时立即发生。</p><p id="cf0d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">当数据到达时，应用自动模式验证通常是一个好的实践。许多API框架如<a class="ae ky" href="https://connexion.readthedocs.io/en/latest/" rel="noopener ugc nofollow" target="_blank"> connexion </a>支持<a class="ae ky" href="https://www.openapis.org/" rel="noopener ugc nofollow" target="_blank"> OpenAPI </a>规范。规范文件包括所有类型的验证，这些验证将由框架自动应用于请求体。</p><p id="0b46" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">返回的状态代码通常是<code class="fe ob oc od no b">400: Bad Request</code>和类似<code class="fe ob oc od no b">The value is expected to be a positive integer.</code>的描述性错误消息，它帮助客户了解哪里出错了，并相应地更改他们的请求。</p><h1 id="463a" class="nb lw it bd lx nc nd ne ma nf ng nh md jz ni ka mg kc nj kd mj kf nk kg mm nl bi translated">不要暴露不必要的数据</h1><p id="3b11" class="pw-post-body-paragraph kz la it lb b lc mo ju le lf mp jx lh li mq lk ll lm mr lo lp lq ms ls lt lu im bi translated">当错误发生在客户端或服务器端时，API响应应该给出一些关于错误原因的提示。但是API不应该泄露太多关于内部服务器错误的信息。例如，状态500表示内部服务器错误。这就足够了。</p><p id="9746" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">不要将实际的错误原因放在响应体中，例如，特定的数据库错误消息或内存错误。与<code class="fe ob oc od no b">400 Bad Request</code>错误不同，这种类型的消息对客户没有帮助，因为他们对此无能为力。经验法则是确保API只返回完成其功能所需的信息。</p><h1 id="4b45" class="nb lw it bd lx nc nd ne ma nf ng nh md jz ni ka mg kc nj kd mj kf nk kg mm nl bi translated">结论</h1><p id="12ca" class="pw-post-body-paragraph kz la it lb b lc mo ju le lf mp jx lh li mq lk ll lm mr lo lp lq ms ls lt lu im bi translated">希望这篇文章对你有用！这个清单可以一直列下去。</p><p id="ed83" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果你知道其他每个人都需要知道的API安全项目，请在下面随意评论。</p><p id="2317" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">干杯！</p><h1 id="d75a" class="nb lw it bd lx nc nd ne ma nf ng nh md jz ni ka mg kc nj kd mj kf nk kg mm nl bi translated">参考</h1><p id="a716" class="pw-post-body-paragraph kz la it lb b lc mo ju le lf mp jx lh li mq lk ll lm mr lo lp lq ms ls lt lu im bi translated"><a class="ae ky" href="https://brightsec.com/blog/api-security/" rel="noopener ugc nofollow" target="_blank">https://brightsec.com/blog/api-security/</a></p></div></div>    
</body>
</html>