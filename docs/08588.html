<html>
<head>
<title>Javascript Closures and Curried Functions</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Javascript闭包和Curried函数</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/javascript-closures-and-curried-functions-63c75bcded11?source=collection_archive---------4-----------------------#2021-05-18">https://betterprogramming.pub/javascript-closures-and-curried-functions-63c75bcded11?source=collection_archive---------4-----------------------#2021-05-18</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="b009" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">什么是闭包，为什么它是一个重要的概念，它有什么帮助？</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/95a46af5b8bb8d13ea8d485e27f70178.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*vB41KSeFYBZU_Po2"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">卡罗琳·阿特伍德在<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的照片</p></figure><h1 id="f9d1" class="kz la it bd lb lc ld le lf lg lh li lj jz lk ka ll kc lm kd ln kf lo kg lp lq bi translated">关于JavaScript作用域的快速提示</h1><h2 id="f72e" class="lr la it bd lb ls lt dn lf lu lv dp lj lw lx ly ll lz ma mb ln mc md me lp mf bi translated">什么是范围？</h2><p id="18fa" class="pw-post-body-paragraph mg mh it mi b mj mk ju ml mm mn jx mo lw mp mq mr lz ms mt mu mc mv mw mx my im bi translated">作用域提供了限制对变量或函数的访问并防止干预的能力。那是什么意思？</p><p id="3504" class="pw-post-body-paragraph mg mh it mi b mj mz ju ml mm na jx mo lw nb mq mr lz nc mt mu mc nd mw mx my im bi translated">看看下面的例子:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ne nf l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">JS功能范围</p></figure><p id="ef15" class="pw-post-body-paragraph mg mh it mi b mj mz ju ml mm na jx mo lw nb mq mr lz nc mt mu mc nd mw mx my im bi translated"><code class="fe ng nh ni nj b">two</code>、<code class="fe ng nh ni nj b">count</code>、<code class="fe ng nh ni nj b">run2</code>的可见性仅限于函数边界。在功能范围内<em class="nk">可访问，在</em>范围外<em class="nk">不可访问:</em></p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nl"><img src="../Images/4d17728b902570959b3128275f4c9350.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*R0MMqb1DTxzz7OdpbtNZ8g.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">范围可访问性边框(图片由作者提供)</p></figure><h2 id="8da0" class="lr la it bd lb ls lt dn lf lu lv dp lj lw lx ly ll lz ma mb ln mc md me lp mf bi translated">范围链</h2><p id="3511" class="pw-post-body-paragraph mg mh it mi b mj mk ju ml mm mn jx mo lw mp mq mr lz ms mt mu mc mv mw mx my im bi translated">让我们看看下面这个神奇的例子:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ne nf l"/></div></figure><p id="2933" class="pw-post-body-paragraph mg mh it mi b mj mz ju ml mm na jx mo lw nb mq mr lz nc mt mu mc nd mw mx my im bi translated">正如你所看到的，我们有许多同名的变量，<code class="fe ng nh ni nj b">message</code>和<em class="nk">它们的值没有被篡改！</em></p><blockquote class="nm nn no"><p id="004e" class="mg mh nk mi b mj mz ju ml mm na jx mo np nb mq mr nq nc mt mu nr nd mw mx my im bi translated">相同的标识符名称可以在多层嵌套作用域中指定，<strong class="mi iu">这被称为“隐藏”(内部标识符“隐藏”外部标识符)</strong>。</p><p id="8a58" class="mg mh nk mi b mj mz ju ml mm na jx mo np nb mq mr nq nc mt mu nr nd mw mx my im bi translated">——你不知道的JS，scope&amp;closures，Kyle Simpson。</p></blockquote><p id="9a12" class="pw-post-body-paragraph mg mh it mi b mj mz ju ml mm na jx mo lw nb mq mr lz nc mt mu mc nd mw mx my im bi translated">每次，JavaScript引擎都会试图找到最近的用名字<code class="fe ng nh ni nj b">message</code>声明的变量<em class="nk">，并假设它是正确的。如果变量没有在块范围内定义，引擎将尝试在函数范围内，然后在全局范围内找到它。Thi <strong class="mi iu"> <em class="nk"> s </em> </strong> <em class="nk">就是我们所说的JS作用域链</em>:</em></p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ns"><img src="../Images/cbe81488987f8305f0fc18541bb2a659.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*OsiKUJp7scPnVmtYatihPw.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">JS范围链(图片由作者提供)</p></figure><p id="446b" class="pw-post-body-paragraph mg mh it mi b mj mz ju ml mm na jx mo lw nb mq mr lz nc mt mu mc nd mw mx my im bi translated">范围查找在找到第一个匹配项时停止。</p><ul class=""><li id="f236" class="nt nu it mi b mj mz mm na lw nv lz nw mc nx my ny nz oa ob bi translated"><strong class="mi iu">全局变量</strong>可从任何范围(窗口、文档、流程……)访问。</li><li id="e411" class="nt nu it mi b mj oc mm od lw oe lz of mc og my ny nz oa ob bi translated">每一个私有变量(没有被导出)都是模块的内部细节，模块作用域保护这些变量不被外部访问。</li><li id="e607" class="nt nu it mi b mj oc mm od lw oe lz of mc og my ny nz oa ob bi translated"><strong class="mi iu">函数</strong>变量在函数范围内是可访问的，但在函数范围外是不可访问的。</li><li id="13ac" class="nt nu it mi b mj oc mm od lw oe lz of mc og my ny nz oa ob bi translated"><strong class="mi iu">块</strong>变量在块范围内可访问，但在块范围外不可访问。</li></ul><p id="0dff" class="pw-post-body-paragraph mg mh it mi b mj mz ju ml mm na jx mo lw nb mq mr lz nc mt mu mc nd mw mx my im bi translated">⚠️ <strong class="mi iu">代码块不会为</strong> <code class="fe ng nh ni nj b"><strong class="mi iu">var</strong></code> <strong class="mi iu">变量创建作用域，但函数体会:</strong></p><pre class="kj kk kl km gt oh nj oi oj aw ok bi"><span id="ee51" class="lr la it nj b gy ol om l on oo">const outerFunc = () =&gt; {<br/><br/>  if (true) {<br/>    // "if" block scope<br/>    <strong class="nj iu">var count = 12;</strong><br/>    console.log(count); // 12<br/>  }<br/>  <br/>  <strong class="nj iu">console.log(count); // 12</strong><br/>}<br/><br/>outerFunc();<br/><strong class="nj iu">// console.log(count); // ReferenceError</strong></span></pre><h2 id="ec1e" class="lr la it bd lb ls lt dn lf lu lv dp lj lw lx ly ll lz ma mb ln mc md me lp mf bi translated">范围可以嵌套</h2><p id="3056" class="pw-post-body-paragraph mg mh it mi b mj mk ju ml mm mn jx mo lw mp mq mr lz ms mt mu mc mv mw mx my im bi translated">让我们看看下面的例子:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ne nf l"/></div></figure><p id="53ba" class="pw-post-body-paragraph mg mh it mi b mj mz ju ml mm na jx mo lw nb mq mr lz nc mt mu mc nd mw mx my im bi translated"><em class="nk">access是如何组织的？</em></p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi op"><img src="../Images/89a031714a94f791f74d38d58b863792.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*4dwiG3QosDwE9Z4CgOWRuw.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">范围气泡(图片由作者提供)</p></figure><p id="7608" class="pw-post-body-paragraph mg mh it mi b mj mz ju ml mm na jx mo lw nb mq mr lz nc mt mu mc nd mw mx my im bi translated">每当一个作用域被嵌套时，它从创建者那里继承上下文并用自己的变量扩展它:</p><ul class=""><li id="2f92" class="nt nu it mi b mj mz mm na lw nv lz nw mc nx my ny nz oa ob bi translated"><strong class="mi iu"> Outer </strong>是global的孩子——它可以访问所有global，以及在Outer函数作用域中创建的变量。</li><li id="b575" class="nt nu it mi b mj oc mm od lw oe lz of mc og my ny nz oa ob bi translated"><strong class="mi iu"> inner </strong>是outer的孩子，outer是global的孩子——那么Inner就可以访问所有在Inner函数内部创建的全局、外部和变量。</li></ul><p id="8e3f" class="pw-post-body-paragraph mg mh it mi b mj mz ju ml mm na jx mo lw nb mq mr lz nc mt mu mc nd mw mx my im bi translated"><em class="nk">引擎将如何查找和解析变量？</em></p><ol class=""><li id="eb38" class="nt nu it mi b mj mz mm na lw nv lz nw mc nx my oq nz oa ob bi translated">我可以看到你定义了一个<code class="fe ng nh ni nj b">globalVar</code>。好吧！</li><li id="e944" class="nt nu it mi b mj oc mm od lw oe lz of mc og my oq nz oa ob bi translated">我可以看到你定义了一个函数<code class="fe ng nh ni nj b">outerFunc()</code>，它有一个变量<code class="fe ng nh ni nj b">outerVar</code>。很好！</li><li id="86d7" class="nt nu it mi b mj oc mm od lw oe lz of mc og my oq nz oa ob bi translated">在<code class="fe ng nh ni nj b">outerFunc()</code>里面，我可以看到你定义了一个函数<code class="fe ng nh ni nj b">innerFunc()</code>。</li><li id="9d40" class="nt nu it mi b mj oc mm od lw oe lz of mc og my oq nz oa ob bi translated">在<code class="fe ng nh ni nj b">innerFunc()</code>里面，我可以看到一个没有声明的变量<code class="fe ng nh ni nj b">outerVar</code> <em class="nk">。</em></li><li id="88e3" class="nt nu it mi b mj oc mm od lw oe lz of mc og my oq nz oa ob bi translated">让我们来看看<code class="fe ng nh ni nj b">outerFunc()</code>的内部。</li><li id="df56" class="nt nu it mi b mj oc mm od lw oe lz of mc og my oq nz oa ob bi translated">找到了！我认为<code class="fe ng nh ni nj b">innerFunc()</code>中的变量<code class="fe ng nh ni nj b">outerVar</code>与<code class="fe ng nh ni nj b">outerFunc()</code>中的<code class="fe ng nh ni nj b">outerVar</code>是同一个变量。</li><li id="68cd" class="nt nu it mi b mj oc mm od lw oe lz of mc og my oq nz oa ob bi translated">在<code class="fe ng nh ni nj b">innerFunc()</code>里面，我可以看到一个没有声明的变量<code class="fe ng nh ni nj b">globalVar</code>、<em class="nk">。</em></li><li id="d365" class="nt nu it mi b mj oc mm od lw oe lz of mc og my oq nz oa ob bi translated">我试图在<code class="fe ng nh ni nj b">outerFunc()</code>范围内找到<code class="fe ng nh ni nj b">globalVar</code>。</li><li id="e508" class="nt nu it mi b mj oc mm od lw oe lz of mc og my oq nz oa ob bi translated">不存在，我们就在全局范围内搜索吧。</li><li id="8fe5" class="nt nu it mi b mj oc mm od lw oe lz of mc og my oq nz oa ob bi translated">找到了！我认为<code class="fe ng nh ni nj b">innerFunc()</code>中的变量<code class="fe ng nh ni nj b">globalVar</code>与全局范围的变量<code class="fe ng nh ni nj b">globalVar</code>是同一个变量。</li></ol><h2 id="6b1e" class="lr la it bd lb ls lt dn lf lu lv dp lj lw lx ly ll lz ma mb ln mc md me lp mf bi translated">让我们回顾一下</h2><ul class=""><li id="293c" class="nt nu it mi b mj mk mm mn lw or lz os mc ot my ny nz oa ob bi translated">作用域是一个<em class="nk">空间安排</em>，它规定了变量的可访问性。</li><li id="d7c8" class="nt nu it mi b mj oc mm od lw oe lz of mc og my ny nz oa ob bi translated">作用域是由代码块、函数和模块创建的。</li><li id="c165" class="nt nu it mi b mj oc mm od lw oe lz of mc og my ny nz oa ob bi translated">在作用域内定义的变量只能在该作用域内访问，在作用域外是不可访问的。</li><li id="8e1f" class="nt nu it mi b mj oc mm od lw oe lz of mc og my ny nz oa ob bi translated">范围可以嵌套。在内部作用域中，您可以访问外部作用域的变量。</li></ul><p id="5861" class="pw-post-body-paragraph mg mh it mi b mj mz ju ml mm na jx mo lw nb mq mr lz nc mt mu mc nd mw mx my im bi translated">那么，闭包和作用域之间有什么关系呢？让我们来了解一下！</p><h1 id="641b" class="kz la it bd lb lc ld le lf lg lh li lj jz lk ka ll kc lm kd ln kf lo kg lp lq bi translated">关闭</h1><p id="eb10" class="pw-post-body-paragraph mg mh it mi b mj mk ju ml mm mn jx mo lw mp mq mr lz ms mt mu mc mv mw mx my im bi translated">让我们对最后一段代码做一些修改:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ou"><img src="../Images/49cd24b24e25b0c3eaccde26bf139b78.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*zTn5aNIUoUdGhhK98oW6nQ.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">封闭概念(图片由作者提供)</p></figure><p id="3f95" class="pw-post-body-paragraph mg mh it mi b mj mz ju ml mm na jx mo lw nb mq mr lz nc mt mu mc nd mw mx my im bi translated">有什么区别？在第一段代码中，我们在<code class="fe ng nh ni nj b">outerFunc</code>内部执行<code class="fe ng nh ni nj b">innerFunc</code>，在第二段代码中，我们返回<code class="fe ng nh ni nj b">innerFunc</code>，它是从外部执行的！</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ov"><img src="../Images/6a249e1b23a10d80b3d6c554eeae0d83.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*4yvOSNXyOgQuXd3K8nug0Q.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">innerFunction的外部执行(图片由作者提供)</p></figure><p id="5b57" class="pw-post-body-paragraph mg mh it mi b mj mz ju ml mm na jx mo lw nb mq mr lz nc mt mu mc nd mw mx my im bi translated"><code class="fe ng nh ni nj b">innerFun()</code>调用发生在<code class="fe ng nh ni nj b">outerFunc()</code>范围之外。</p><p id="e767" class="pw-post-body-paragraph mg mh it mi b mj mz ju ml mm na jx mo lw nb mq mr lz nc mt mu mc nd mw mx my im bi translated">重要的是什么？</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ne nf l"/></div></figure><ul class=""><li id="45e6" class="nt nu it mi b mj mz mm na lw nv lz nw mc nx my ny nz oa ob bi translated"><code class="fe ng nh ni nj b">innerFunc()</code>在其词法范围之外执行。</li><li id="2e05" class="nt nu it mi b mj oc mm od lw oe lz of mc og my ny nz oa ob bi translated"><code class="fe ng nh ni nj b">innerFunc()</code>仍然可以从其词法范围访问<code class="fe ng nh ni nj b">outerVar</code>,即使它是在其词法范围之外执行的。</li><li id="7150" class="nt nu it mi b mj oc mm od lw oe lz of mc og my ny nz oa ob bi translated"><code class="fe ng nh ni nj b">innerFunc()</code>从其词法范围中捕获或记忆变量<code class="fe ng nh ni nj b">outerVar</code>。</li></ul><p id="1e3a" class="pw-post-body-paragraph mg mh it mi b mj mz ju ml mm na jx mo lw nb mq mr lz nc mt mu mc nd mw mx my im bi translated">事情是这样的。</p><blockquote class="ow"><p id="4e8f" class="ox oy it bd oz pa pb pc pd pe pf my dk translated">闭包是一个访问其词法范围的函数，即使在其词法范围之外执行。</p></blockquote><p id="51da" class="pw-post-body-paragraph mg mh it mi b mj pg ju ml mm ph jx mo lw pi mq mr lz pj mt mu mc pk mw mx my im bi translated">太神奇了！</p><blockquote class="ow"><p id="a007" class="ox oy it bd oz pa pb pc pd pe pf my dk translated">闭包是一个函数，它从定义的地方记住变量，而不管它以后在哪里执行。</p></blockquote><p id="a4ca" class="pw-post-body-paragraph mg mh it mi b mj pg ju ml mm ph jx mo lw pi mq mr lz pj mt mu mc pk mw mx my im bi translated">让我们看一个具体的例子:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ne nf l"/></div></figure><p id="f264" class="pw-post-body-paragraph mg mh it mi b mj mz ju ml mm na jx mo lw nb mq mr lz nc mt mu mc nd mw mx my im bi translated"><code class="fe ng nh ni nj b">increment</code>和<code class="fe ng nh ni nj b">decrement</code>在<code class="fe ng nh ni nj b">counter</code>之外执行。在<code class="fe ng nh ni nj b">increment</code>和<code class="fe ng nh ni nj b">decrement</code>的不同操作期间，执行上下文被保存。这就像是单例模式！</p><ul class=""><li id="cf3b" class="nt nu it mi b mj mz mm na lw nv lz nw mc nx my ny nz oa ob bi translated">在<code class="fe ng nh ni nj b">line 21</code>我们实例化一个单例或沙箱或运行时池。</li><li id="fc1e" class="nt nu it mi b mj oc mm od lw oe lz of mc og my ny nz oa ob bi translated"><code class="fe ng nh ni nj b">increment</code>和<code class="fe ng nh ni nj b">decrement</code>返回内部函数。</li><li id="bb7f" class="nt nu it mi b mj oc mm od lw oe lz of mc og my ny nz oa ob bi translated"><code class="fe ng nh ni nj b">increment</code>和<code class="fe ng nh ni nj b">decrement</code>可以访问<code class="fe ng nh ni nj b">privateCounter</code>和<code class="fe ng nh ni nj b">changeBy</code>，即使它们是在它们的词法范围之外执行的。</li><li id="80b3" class="nt nu it mi b mj oc mm od lw oe lz of mc og my ny nz oa ob bi translated"><code class="fe ng nh ni nj b">increment</code>和<code class="fe ng nh ni nj b">decrement</code>持有<code class="fe ng nh ni nj b">privateCounter</code>的同一个实例(同一个<code class="fe ng nh ni nj b">counterFunc</code>实例)。</li></ul><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi pl"><img src="../Images/3075ae32e497ff1b80f58993512029c7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*XUn-FXnTmshAbMY4nAjTrA.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">结束是如何工作的？(图片由作者提供)</p></figure><p id="bd40" class="pw-post-body-paragraph mg mh it mi b mj mz ju ml mm na jx mo lw nb mq mr lz nc mt mu mc nd mw mx my im bi translated">神奇！再来看一个例子！</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ne nf l"/></div></figure><ul class=""><li id="a43d" class="nt nu it mi b mj mz mm na lw nv lz nw mc nx my ny nz oa ob bi translated">在<code class="fe ng nh ni nj b">line 25</code>我们实例化一个单例，或者沙箱，或者运行时池。</li><li id="fb8b" class="nt nu it mi b mj oc mm od lw oe lz of mc og my ny nz oa ob bi translated"><code class="fe ng nh ni nj b">insert</code>和<code class="fe ng nh ni nj b">removeAtIndex</code>返回内部函数。</li><li id="1f41" class="nt nu it mi b mj oc mm od lw oe lz of mc og my ny nz oa ob bi translated"><code class="fe ng nh ni nj b">insert</code>和<code class="fe ng nh ni nj b">removeAtIndex</code>可以访问<code class="fe ng nh ni nj b">privateArray</code>、<code class="fe ng nh ni nj b">addItem</code>和<code class="fe ng nh ni nj b">removeItem</code>——即使它们是在它们的词法范围之外执行的。</li><li id="09b2" class="nt nu it mi b mj oc mm od lw oe lz of mc og my ny nz oa ob bi translated"><code class="fe ng nh ni nj b">insert</code>和<code class="fe ng nh ni nj b">removeAtIndex</code>持有<code class="fe ng nh ni nj b">privateArray</code>的同一个实例(<code class="fe ng nh ni nj b">arrayApi</code>的同一个实例)。</li></ul><p id="a70b" class="pw-post-body-paragraph mg mh it mi b mj mz ju ml mm na jx mo lw nb mq mr lz nc mt mu mc nd mw mx my im bi translated">闭包有什么用？让我们一起发现吧！</p><h1 id="7289" class="kz la it bd lb lc ld le lf lg lh li lj jz lk ka ll kc lm kd ln kf lo kg lp lq bi translated">简化的功能</h1><h2 id="78aa" class="lr la it bd lb ls lt dn lf lu lv dp lj lw lx ly ll lz ma mb ln mc md me lp mf bi translated">什么是咖喱功能？</h2><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ne nf l"/></div></figure><p id="a765" class="pw-post-body-paragraph mg mh it mi b mj mz ju ml mm na jx mo lw nb mq mr lz nc mt mu mc nd mw mx my im bi translated">这个功能有什么问题？</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi pm"><img src="../Images/ccbcfe343dca74ec350f466ee627f84f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*jJa16e67Wk24FCCOT1Hncw.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">不良功能气味(图片由作者提供)</p></figure><p id="a657" class="pw-post-body-paragraph mg mh it mi b mj mz ju ml mm na jx mo lw nb mq mr lz nc mt mu mc nd mw mx my im bi translated">以上功能:</p><ul class=""><li id="5642" class="nt nu it mi b mj mz mm na lw nv lz nw mc nx my ny nz oa ob bi translated">需要很多参数。</li><li id="9ac9" class="nt nu it mi b mj oc mm od lw oe lz of mc og my ny nz oa ob bi translated">因为JS不是类型化的，我们应该记住每个参数的类型和位置。</li><li id="b64b" class="nt nu it mi b mj oc mm od lw oe lz of mc og my ny nz oa ob bi translated">调用函数时有一些常量部分。</li></ul><p id="2daf" class="pw-post-body-paragraph mg mh it mi b mj mz ju ml mm na jx mo lw nb mq mr lz nc mt mu mc nd mw mx my im bi translated">有没有减少参数数量的现有技术？是的:currying！</p><blockquote class="nm nn no"><p id="bb70" class="mg mh nk mi b mj mz ju ml mm na jx mo np nb mq mr nq nc mt mu nr nd mw mx my im bi translated">在数学和计算机科学中，<strong class="mi iu"> currying是一种将接受多个参数的函数转换成一系列接受单个参数的函数的技术</strong>。</p><p id="7b0a" class="mg mh nk mi b mj mz ju ml mm na jx mo np nb mq mr nq nc mt mu nr nd mw mx my im bi translated">—维基百科</p></blockquote><p id="93c7" class="pw-post-body-paragraph mg mh it mi b mj mz ju ml mm na jx mo lw nb mq mr lz nc mt mu mc nd mw mx my im bi translated">那是什么意思？</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi pn"><img src="../Images/d307cb8e871bad6d51fb13ae95a968fc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*-gzOiq9NVGm7l99UZv7osQ.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">Currying和局部应用(图片由作者提供)</p></figure><p id="d594" class="pw-post-body-paragraph mg mh it mi b mj mz ju ml mm na jx mo lw nb mq mr lz nc mt mu mc nd mw mx my im bi translated">运用这一原则，我们的职能将转变为:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ne nf l"/></div></figure><p id="12ac" class="pw-post-body-paragraph mg mh it mi b mj mz ju ml mm na jx mo lw nb mq mr lz nc mt mu mc nd mw mx my im bi translated"><code class="fe ng nh ni nj b">kmConverter</code>现在是一个只有一个参数的函数。在每一步中，我们应用单个参数。</p><p id="a363" class="pw-post-body-paragraph mg mh it mi b mj mz ju ml mm na jx mo lw nb mq mr lz nc mt mu mc nd mw mx my im bi translated">因为函数没有所有需要的参数，所以没有执行<code class="fe ng nh ni nj b">kmConverterWithUnit</code>和<code class="fe ng nh ni nj b">kmConverterWithFactor</code>函数。厉害！</p><blockquote class="ow"><p id="d40c" class="ox oy it bd oz pa pb pc pd pe pf my dk translated">我们已经将一个普通的运行完成函数转换成了一个懒惰函数。</p></blockquote><p id="3be7" class="pw-post-body-paragraph mg mh it mi b mj pg ju ml mm ph jx mo lw pi mq mr lz pj mt mu mc pk mw mx my im bi translated"><code class="fe ng nh ni nj b">converterOld2('km')</code>返回另一个函数(<code class="fe ng nh ni nj b">kmConverterWithUnit</code>):</p><pre class="kj kk kl km gt oh nj oi oj aw ok bi"><span id="4936" class="lr la it nj b gy ol om l on oo">(factor) =&gt; (offset) =&gt; (input) =&gt; {<br/>     const converterOffset = offset || 0;<br/>     return [((converterOffset + input) * factor).toFixed(2), toUnit].join(' ');<br/>}</span></pre><p id="b01e" class="pw-post-body-paragraph mg mh it mi b mj mz ju ml mm na jx mo lw nb mq mr lz nc mt mu mc nd mw mx my im bi translated"><code class="fe ng nh ni nj b">converterOld2('km')(1.60936)</code>返回另一个函数(<code class="fe ng nh ni nj b">kmConverterWithFactor</code>):</p><pre class="kj kk kl km gt oh nj oi oj aw ok bi"><span id="5783" class="lr la it nj b gy ol om l on oo">(offset) =&gt; (input) =&gt; {<br/>     const converterOffset = offset || 0;<br/>     return [((converterOffset + input) * factor).toFixed(2), toUnit].join(' ');<br/>}</span></pre><p id="c4cf" class="pw-post-body-paragraph mg mh it mi b mj mz ju ml mm na jx mo lw nb mq mr lz nc mt mu mc nd mw mx my im bi translated"><code class="fe ng nh ni nj b">converterOld2('km')(1.60936)(undefined)</code>返回另一个函数(<code class="fe ng nh ni nj b">kmConverter</code>):</p><pre class="kj kk kl km gt oh nj oi oj aw ok bi"><span id="3149" class="lr la it nj b gy ol om l on oo">(input) =&gt; {<br/>     const converterOffset = offset || 0;<br/>     return [((converterOffset + input) * factor).toFixed(2), toUnit].join(' ');<br/>}</span></pre><p id="5e63" class="pw-post-body-paragraph mg mh it mi b mj mz ju ml mm na jx mo lw nb mq mr lz nc mt mu mc nd mw mx my im bi translated"><code class="fe ng nh ni nj b">converterOld2</code>可以这样改写:</p><pre class="kj kk kl km gt oh nj oi oj aw ok bi"><span id="0c32" class="lr la it nj b gy ol om l on oo">const converterOld2 = (toUnit) =&gt; {<br/>  return (factor) =&gt; {<br/>    return (offset) =&gt; {<br/>      return (input) =&gt; {<br/>        const converterOffset = offset || 0;<br/>        return [((converterOffset + input) * factor).toFixed(2), toUnit].join(' ');<br/>      }<br/>    }<br/>  }<br/>};</span></pre><p id="1495" class="pw-post-body-paragraph mg mh it mi b mj mz ju ml mm na jx mo lw nb mq mr lz nc mt mu mc nd mw mx my im bi translated">这将创建一个<em class="nk">外-内模式</em>，因为我们每次都返回一个函数，所以我们创建闭包:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi po"><img src="../Images/c4f21771d813ee6af187c2d7d6bffcd0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*hbCLuACfYQ8Xv1NgQ1HvAA.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">Curried函数作为闭包应用程序(图片由作者提供)</p></figure><p id="5424" class="pw-post-body-paragraph mg mh it mi b mj mz ju ml mm na jx mo lw nb mq mr lz nc mt mu mc nd mw mx my im bi translated">多亏了闭包，上下文在调用之间被保存了！</p><h2 id="a191" class="lr la it bd lb ls lt dn lf lu lv dp lj lw lx ly ll lz ma mb ln mc md me lp mf bi translated">用作模板</h2><p id="825b" class="pw-post-body-paragraph mg mh it mi b mj mk ju ml mm mn jx mo lw mp mq mr lz ms mt mu mc mv mw mx my im bi translated">让我们回到我们的例子:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ne nf l"/></div></figure><p id="823c" class="pw-post-body-paragraph mg mh it mi b mj mz ju ml mm na jx mo lw nb mq mr lz nc mt mu mc nd mw mx my im bi translated">在最后一步中，我们解决了函数有多个参数的问题。但是常量部分呢？</p><pre class="kj kk kl km gt oh nj oi oj aw ok bi"><span id="b3eb" class="lr la it nj b gy ol om l on oo">converterOld2<strong class="nj iu">('km')(1.60936)(undefined)</strong>(10);<br/>converterOld2<strong class="nj iu">('km')(1.60936)(undefined)</strong>(20);<br/>converterOld2<strong class="nj iu">('km')(1.60936)(undefined)</strong>(30);<br/>converterOld2<strong class="nj iu">('kg')(0.45460)(undefined)(2.5);</strong><br/>converterOld2<strong class="nj iu">('kg')(0.45460)(undefined)(5);</strong><br/>converterOld2<strong class="nj iu">('kg')(0.45460)(undefined)(10);</strong><br/>converterOld2<strong class="nj iu">('degrees C')(0.5556)(-32)(98);</strong><br/>converterOld2<strong class="nj iu">('degrees C')(0.5556)(-32)(28);</strong></span></pre><p id="9b83" class="pw-post-body-paragraph mg mh it mi b mj mz ju ml mm na jx mo lw nb mq mr lz nc mt mu mc nd mw mx my im bi translated">我们如何增强这一点？</p><p id="df41" class="pw-post-body-paragraph mg mh it mi b mj mz ju ml mm na jx mo lw nb mq mr lz nc mt mu mc nd mw mx my im bi translated"><strong class="mi iu">第一步:重命名我们的函数:</strong></p><pre class="kj kk kl km gt oh nj oi oj aw ok bi"><span id="444b" class="lr la it nj b gy ol om l on oo">const <strong class="nj iu">universalConverter</strong> = toUnit =&gt; factor =&gt; offset =&gt; (input) =&gt;{<br/>  const converterOffset = offset || 0;<br/>  return [((converterOffset + input) * factor).toFixed(2), toUnit].join(' ');<br/>};</span></pre><p id="5494" class="pw-post-body-paragraph mg mh it mi b mj mz ju ml mm na jx mo lw nb mq mr lz nc mt mu mc nd mw mx my im bi translated"><strong class="mi iu">第二步:从这个通用转换器</strong>创建不同的<em class="nk">模板</em></p><pre class="kj kk kl km gt oh nj oi oj aw ok bi"><span id="62cd" class="lr la it nj b gy ol om l on oo">const <strong class="nj iu">universalConverter</strong> = toUnit =&gt; factor =&gt; offset =&gt; (input) =&gt;{<br/>  const converterOffset = offset || 0;<br/>  return [((converterOffset + input) * factor).toFixed(2), toUnit].join(' ');<br/>};<br/><br/>// template for km<br/>const <strong class="nj iu">milesToKm</strong> = universalConverter('km')(1.60936)(undefined); </span><span id="8701" class="lr la it nj b gy pp om l on oo">// template for kg<br/>const <strong class="nj iu">poundsToKg</strong> = universalConverter('kg')(0.45460)(undefined); </span><span id="2de5" class="lr la it nj b gy pp om l on oo">// template for degrees C<br/>const <strong class="nj iu">farenheitToCelsius</strong> = universalConverter('degrees C')(0.5556)(-32);</span></pre><p id="0ca5" class="pw-post-body-paragraph mg mh it mi b mj mz ju ml mm na jx mo lw nb mq mr lz nc mt mu mc nd mw mx my im bi translated">每个模板都是一个函数，因为<code class="fe ng nh ni nj b">universalConverter</code>是一个定制函数。</p><p id="96ce" class="pw-post-body-paragraph mg mh it mi b mj mz ju ml mm na jx mo lw nb mq mr lz nc mt mu mc nd mw mx my im bi translated">在这个级别，模板还没有被执行！</p><p id="d696" class="pw-post-body-paragraph mg mh it mi b mj mz ju ml mm na jx mo lw nb mq mr lz nc mt mu mc nd mw mx my im bi translated"><strong class="mi iu">第三步:执行我们的模板</strong></p><pre class="kj kk kl km gt oh nj oi oj aw ok bi"><span id="d8ce" class="lr la it nj b gy ol om l on oo">console.log(milesToKm(10)); //  "16.09 km"<br/>console.log(poundsToKg(2.5)); //  "1.14 kg"<br/>console.log(farenheitToCelsius(98)); //  "36.67 degrees C"</span></pre><p id="a724" class="pw-post-body-paragraph mg mh it mi b mj mz ju ml mm na jx mo lw nb mq mr lz nc mt mu mc nd mw mx my im bi translated">我们可以看到:</p><ul class=""><li id="e125" class="nt nu it mi b mj mz mm na lw nv lz nw mc nx my ny nz oa ob bi translated">由于闭包(内部-外部函数)，上下文得以保存。</li><li id="8247" class="nt nu it mi b mj oc mm od lw oe lz of mc og my ny nz oa ob bi translated">函数参数被简化为单个参数。</li></ul><p id="a980" class="pw-post-body-paragraph mg mh it mi b mj mz ju ml mm na jx mo lw nb mq mr lz nc mt mu mc nd mw mx my im bi translated">⭐ <strong class="mi iu">提示</strong> : <code class="fe ng nh ni nj b">universalConverter</code>可能在通用<code class="fe ng nh ni nj b">utils package</code>保持私有，我们只公开<code class="fe ng nh ni nj b">templates</code>。</p><blockquote class="ow"><p id="67aa" class="ox oy it bd oz pa pb pc pd pe pf my dk translated">Currying和functions as template是减少函数参数数量的两种强大技术。</p></blockquote><h2 id="6ebf" class="lr la it bd lb ls pq dn lf lu pr dp lj lw ps ly ll lz pt mb ln mc pu me lp mf bi translated">部分应用</h2><p id="4e3d" class="pw-post-body-paragraph mg mh it mi b mj mk ju ml mm mn jx mo lw mp mq mr lz ms mt mu mc mv mw mx my im bi translated">我们来看看这个<em class="nk">万能匹配器</em>:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ne nf l"/></div></figure><p id="a2ad" class="pw-post-body-paragraph mg mh it mi b mj mz ju ml mm na jx mo lw nb mq mr lz nc mt mu mc nd mw mx my im bi translated">我们已经部分应用了论证:</p><ul class=""><li id="4bff" class="nt nu it mi b mj mz mm na lw nv lz nw mc nx my ny nz oa ob bi translated">我们从<code class="fe ng nh ni nj b">pattern.</code>开始</li><li id="a611" class="nt nu it mi b mj oc mm od lw oe lz of mc og my ny nz oa ob bi translated">然后是动态<code class="fe ng nh ni nj b">value.</code></li></ul><p id="284d" class="pw-post-body-paragraph mg mh it mi b mj mz ju ml mm na jx mo lw nb mq mr lz nc mt mu mc nd mw mx my im bi translated">同样的事情也适用于这个<em class="nk">通用的排序依据</em>:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ne nf l"/></div></figure><p id="8a41" class="pw-post-body-paragraph mg mh it mi b mj mz ju ml mm na jx mo lw nb mq mr lz nc mt mu mc nd mw mx my im bi translated">我们已经部分应用了论证:</p><ul class=""><li id="f2e9" class="nt nu it mi b mj mz mm na lw nv lz nw mc nx my ny nz oa ob bi translated">我们从<code class="fe ng nh ni nj b">property</code>开始。</li><li id="0010" class="nt nu it mi b mj oc mm od lw oe lz of mc og my ny nz oa ob bi translated">然后是<code class="fe ng nh ni nj b">value</code>的动态。</li></ul><h2 id="48ca" class="lr la it bd lb ls lt dn lf lu lv dp lj lw lx ly ll lz ma mb ln mc md me lp mf bi translated">这些有什么好处？</h2><ul class=""><li id="1c51" class="nt nu it mi b mj mk mm mn lw or lz os mc ot my ny nz oa ob bi translated">干:不要重复自己。</li><li id="d067" class="nt nu it mi b mj oc mm od lw oe lz of mc og my ny nz oa ob bi translated">代码一次使用多次(通用函数和模板)。</li><li id="2402" class="nt nu it mi b mj oc mm od lw oe lz of mc og my ny nz oa ob bi translated">抽象(通用函数)。</li><li id="5dcc" class="nt nu it mi b mj oc mm od lw oe lz of mc og my ny nz oa ob bi translated">本地化重构(通用函数)。</li><li id="efa7" class="nt nu it mi b mj oc mm od lw oe lz of mc og my ny nz oa ob bi translated">部分应用:从多参数到单参数。</li><li id="9d2a" class="nt nu it mi b mj oc mm od lw oe lz of mc og my ny nz oa ob bi translated">惰性求值:函数直到收到全部参数后才执行。</li></ul></div><div class="ab cl pv pw hx px" role="separator"><span class="py bw bk pz qa qb"/><span class="py bw bk pz qa qb"/><span class="py bw bk pz qa"/></div><div class="im in io ip iq"><h1 id="dd6e" class="kz la it bd lb lc qc le lf lg qd li lj jz qe ka ll kc qf kd ln kf qg kg lp lq bi translated">结论</h1><p id="9151" class="pw-post-body-paragraph mg mh it mi b mj mk ju ml mm mn jx mo lw mp mq mr lz ms mt mu mc mv mw mx my im bi translated">在这篇文章中，我们回答了以下问题:什么是闭包？为什么它是一个重要的概念？终结怎么会有帮助呢？</p><p id="6caa" class="pw-post-body-paragraph mg mh it mi b mj mz ju ml mm na jx mo lw nb mq mr lz nc mt mu mc nd mw mx my im bi translated">闭包的神奇之处在于保存的上下文，就像单例一样，以及内部函数如何从定义变量的地方记住变量，而不管它们后来在哪里执行。</p><p id="3b40" class="pw-post-body-paragraph mg mh it mi b mj mz ju ml mm na jx mo lw nb mq mr lz nc mt mu mc nd mw mx my im bi translated">保存的上下文让我想起了一些数组函数的链和管道概念，尤其是<code class="fe ng nh ni nj b">map</code> / <code class="fe ng nh ni nj b">filter</code> / <code class="fe ng nh ni nj b">reduce</code>。在不同的<code class="fe ng nh ni nj b">map</code>之间，必须保存上下文(如<code class="fe ng nh ni nj b">playWithArray</code>示例)。</p><p id="b1c5" class="pw-post-body-paragraph mg mh it mi b mj mz ju ml mm na jx mo lw nb mq mr lz nc mt mu mc nd mw mx my im bi translated">Curried函数也是闭包的一个重要应用。他们把一个有许多参数的函数分解成每个只有一个参数的函数。由于闭包(外部-内部模式)，函数调用之间的上下文得以保存。</p><p id="9aa1" class="pw-post-body-paragraph mg mh it mi b mj mz ju ml mm na jx mo lw nb mq mr lz nc mt mu mc nd mw mx my im bi translated">currying最重要的优点是函数的惰性求值:函数的执行被挂起，直到收到所有的参数。</p><p id="83f9" class="pw-post-body-paragraph mg mh it mi b mj mz ju ml mm na jx mo lw nb mq mr lz nc mt mu mc nd mw mx my im bi translated">最后，作为currying的结果，我们发现了两个有趣的概念:通用函数和模板，以及部分应用。</p></div><div class="ab cl pv pw hx px" role="separator"><span class="py bw bk pz qa qb"/><span class="py bw bk pz qa qb"/><span class="py bw bk pz qa"/></div><div class="im in io ip iq"><h1 id="385d" class="kz la it bd lb lc qc le lf lg qd li lj jz qe ka ll kc qf kd ln kf qg kg lp lq bi translated">进一步的信息</h1><div class="qh qi gp gr qj qk"><a href="https://www.amazon.fr/You-Dont-Know-JS-Closures/dp/1449335586" rel="noopener  ugc nofollow" target="_blank"><div class="ql ab fo"><div class="qm ab qn cl cj qo"><h2 class="bd iu gy z fp qp fr fs qq fu fw is bi translated">你不知道JS - Scope和闭包</h2><div class="qr l"><h3 class="bd b gy z fp qp fr fs qq fu fw dk translated">诺特/5。你不知道的范围和关闭和亚马逊股票上的数百万里弗</h3></div><div class="qs l"><p class="bd b dl z fp qp fr fs qq fu fw dk translated">www.amazon.fr</p></div></div><div class="qt l"><div class="qu l qv qw qx qt qy ks qk"/></div></div></a></div></div><div class="ab cl pv pw hx px" role="separator"><span class="py bw bk pz qa qb"/><span class="py bw bk pz qa qb"/><span class="py bw bk pz qa"/></div><div class="im in io ip iq"><p id="52e9" class="pw-post-body-paragraph mg mh it mi b mj mz ju ml mm na jx mo lw nb mq mr lz nc mt mu mc nd mw mx my im bi translated">感谢您阅读我的文章。</p><p id="f69b" class="pw-post-body-paragraph mg mh it mi b mj mz ju ml mm na jx mo lw nb mq mr lz nc mt mu mc nd mw mx my im bi translated">您可以通过以下方式找到我:</p><p id="6122" class="pw-post-body-paragraph mg mh it mi b mj mz ju ml mm na jx mo lw nb mq mr lz nc mt mu mc nd mw mx my im bi translated">推特:<a class="ae ky" href="https://twitter.com/b_k_hela" rel="noopener ugc nofollow" target="_blank">https://twitter.com/b_k_hela</a></p><p id="687d" class="pw-post-body-paragraph mg mh it mi b mj mz ju ml mm na jx mo lw nb mq mr lz nc mt mu mc nd mw mx my im bi translated">github:<a class="ae ky" href="https://github.com/helabenkhalfallah" rel="noopener ugc nofollow" target="_blank">https://github.com/helabenkhalfallah</a></p></div></div>    
</body>
</html>