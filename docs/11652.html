<html>
<head>
<title>Handling Transactions in TypeORM and Nest.js With Ease</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">轻松处理TypeORM和Nest.js中的事务</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/handling-transactions-in-typeorm-and-nest-js-with-ease-3a417e6ab5?source=collection_archive---------0-----------------------#2022-04-06">https://betterprogramming.pub/handling-transactions-in-typeorm-and-nest-js-with-ease-3a417e6ab5?source=collection_archive---------0-----------------------#2022-04-06</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="fac3" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">在TypeORM和Nest.js中处理数据库事务的一种方便而简单的方法</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/75c3c5b9ac688bf66fcb38be06980f73.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ei6vnOcvX73EByRduzTJlQ.jpeg"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">照片由<a class="ae kv" href="https://www.pexels.com/photo/close-up-photo-of-mining-rig-1148820/" rel="noopener ugc nofollow" target="_blank"> panumas nikhomkhai </a>拍摄</p></figure><p id="e839" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在许多情况下，必须将几个数据块作为一个逻辑单元同时创建/更新(即创建一个实体没有意义，并且在不更新另一个实体的情况下不应该发生，因为它们相互依赖)。PostgreSQL等数据库为我们提供了适合这种情况的工具:事务(这类数据库称为“事务数据库”)。</p><blockquote class="ls lt lu"><p id="473c" class="kw kx lv ky b kz la jr lb lc ld ju le lw lg lh li lx lk ll lm ly lo lp lq lr ij bi translated">根据<a class="ae kv" href="https://en.wikipedia.org/wiki/Database_transaction" rel="noopener ugc nofollow" target="_blank">维基百科</a>的说法，事务本质上是被视为具有“全有或全无”效果的单个工作单元的多个操作。它开始进行一些数据库更改，然后要么提交，要么在任何失败的情况下回滚。通过这种方式，数据库要么具有应用了所有更改的新状态，要么返回到其原始状态，就像什么都没发生一样。</p></blockquote><h1 id="b656" class="lz ma iq bd mb mc md me mf mg mh mi mj jw mk jx ml jz mm ka mn kc mo kd mp mq bi translated">交易类型</h1><p id="333a" class="pw-post-body-paragraph kw kx iq ky b kz mr jr lb lc ms ju le lf mt lh li lj mu ll lm ln mv lp lq lr ij bi translated">TypeORM支持数据库事务，它的<a class="ae kv" href="https://typeorm.io/transactions" rel="noopener ugc nofollow" target="_blank">文档</a>很好地解释了如何使用它们:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mw mx l"/></div></figure><blockquote class="ls lt lu"><p id="4a0f" class="kw kx lv ky b kz la jr lb lc ld ju le lw lg lh li lx lk ll lm ly lo lp lq lr ij bi translated">正如文档中所提到的，使用所提供的<code class="fe my mz na nb b">EntityManager</code>实例是非常重要的，千万不要使用全局管理器，否则将会出现错误和/或不可预知的结果。</p></blockquote><h2 id="5b0f" class="nc ma iq bd mb nd ne dn mf nf ng dp mj lf nh ni ml lj nj nk mn ln nl nm mp nn bi translated">直接使用TypeORM的缺点</h2><p id="6808" class="pw-post-body-paragraph kw kx iq ky b kz mr jr lb lc ms ju le lf mt lh li lj mu ll lm ln mv lp lq lr ij bi translated">我们看到TypeORM使我们的生活变得更加容易，因为我们不必处理SQL事务本身，但是在业务代码中使用它仍然有一些缺点:</p><ol class=""><li id="9ce1" class="no np iq ky b kz la lc ld lf nq lj nr ln ns lr nt nu nv nw bi translated">如果我们遵循<code class="fe my mz na nb b">DataSource</code> / <code class="fe my mz na nb b">EntityManager</code>方法，我们必须将所有的数据库操作放入这个回调中，不管它们有多复杂，也不管有多少个回调。</li><li id="b5b6" class="no np iq ky b kz nx lc ny lf nz lj oa ln ob lr nt nu nv nw bi translated">如果我们遵循<code class="fe my mz na nb b">QueryRunner</code>方法，我们必须写很多样板代码，并确保我们没有遗漏任何东西。</li><li id="8895" class="no np iq ky b kz nx lc ny lf nz lj oa ln ob lr nt nu nv nw bi translated">在这两种情况下，我们的代码都变得难以阅读、维护和重用。</li></ol><p id="cf66" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">那么我们还有什么其他选择呢(考虑到我们使用的是Nest.js框架)？</p><ol class=""><li id="8cf5" class="no np iq ky b kz la lc ld lf nq lj nr ln ns lr nt nu nv nw bi translated">使用decorators来控制事务(<code class="fe my mz na nb b">@Transaction()</code>和<code class="fe my mz na nb b">@TransactionManager()</code>)，这在<a class="ae kv" href="https://docs.nestjs.com/techniques/database#:~:text=Using%20decorators%20to%20control%20the%20transaction%20(%40Transaction()%20and%20%40TransactionManager())%20is%20not%20recommended." rel="noopener ugc nofollow" target="_blank"> Nest.js文档</a>中并不推荐。</li><li id="97ff" class="no np iq ky b kz nx lc ny lf nz lj oa ln ob lr nt nu nv nw bi translated">包括一些第三方库，如<a class="ae kv" href="https://github.com/odavid/typeorm-transactional-cls-hooked" rel="noopener ugc nofollow" target="_blank">type ORM-transactional-cls-hooked</a>(基于这个很酷的<a class="ae kv" href="https://github.com/typeorm/typeorm/issues/1895" rel="noopener ugc nofollow" target="_blank">“延续本地存储”</a>概念)或<a class="ae kv" href="https://github.com/alphamikle/nest_transact" rel="noopener ugc nofollow" target="_blank"> nest_transact </a>。</li><li id="bf92" class="no np iq ky b kz nx lc ny lf nz lj oa ln ob lr nt nu nv nw bi translated">自己构建一些相对简单的东西来满足我们的需求，并抽象出使用TypeORM事务接口的工作。</li></ol><p id="52c0" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">你可能已经猜到了，我将在这篇文章中讨论第三种选择。</p><h1 id="eff4" class="lz ma iq bd mb mc md me mf mg mh mi mj jw mk jx ml jz mm ka mn kc mo kd mp mq bi translated">抽象事务类</h1><p id="b91b" class="pw-post-body-paragraph kw kx iq ky b kz mr jr lb lc ms ju le lf mt lh li lj mu ll lm ln mv lp lq lr ij bi translated">我的朋友(<a class="oc od ep" href="https://medium.com/u/a3ba5a2f62f5?source=post_page-----3a417e6ab5--------------------------------" rel="noopener" target="_blank"> Anton Pavlov </a>)和我开始思考如何在我们的Nest.js应用程序中隐藏事务的所有内部工作方式，使其远离业务逻辑。我们提出了一个抽象的transaction类，它处理所有的事务，并为我们提供了一种简单的方法来编写事务，并在代码库中的任何地方重用它们的代码:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mw mx l"/></div></figure><p id="df3c" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">如您所见，这个类包含了<code class="fe my mz na nb b">QueryRunner</code>的样板代码，因此我们不必再处理它，而将所有与实际操作相关的事情留给这个类的后代。如果我们需要创建一个事务，我们从这个基类继承，然后实现<code class="fe my mz na nb b">execute</code>函数，把我们所有的逻辑放在那里。</p></div><div class="ab cl oe of hu og" role="separator"><span class="oh bw bk oi oj ok"/><span class="oh bw bk oi oj ok"/><span class="oh bw bk oi oj"/></div><div class="ij ik il im in"><h1 id="296f" class="lz ma iq bd mb mc ol me mf mg om mi mj jw on jx ml jz oo ka mn kc op kd mp mq bi translated">最简单的用法示例</h1><p id="32f3" class="pw-post-body-paragraph kw kx iq ky b kz mr jr lb lc ms ju le lf mt lh li lj mu ll lm ln mv lp lq lr ij bi translated">现在让我们看看如何使用我们已经创建的这个事务类。请记住，这段代码只有一个目的——展示如何处理事务，我们并不关心某些实现细节(或适当的变量名)。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mw mx l"/></div></figure><ol class=""><li id="b986" class="no np iq ky b kz la lc ld lf nq lj nr ln ns lr nt nu nv nw bi translated">首先我们创建从我们的<code class="fe my mz na nb b">BaseTransaction</code>继承而来的<code class="fe my mz na nb b">CreateUserTransaction</code>类，为事务的输入和输出提供类型化的参数。</li><li id="93ec" class="no np iq ky b kz nx lc ny lf nz lj oa ln ob lr nt nu nv nw bi translated">事务本身非常简单:我们只需创建一个<code class="fe my mz na nb b">User</code>，然后使用在基类的幕后创建的管理器创建一个连接到我们的<code class="fe my mz na nb b">User</code>的<code class="fe my mz na nb b">Balance</code>实体。</li><li id="e35c" class="no np iq ky b kz nx lc ny lf nz lj oa ln ob lr nt nu nv nw bi translated">然后，在我们的<code class="fe my mz na nb b">UserService</code>中，我们只是注入<code class="fe my mz na nb b">CreateUserTransaction</code>并调用它的<code class="fe my mz na nb b">run</code>方法。</li><li id="8dfd" class="no np iq ky b kz nx lc ny lf nz lj oa ln ob lr nt nu nv nw bi translated">只有在<code class="fe my mz na nb b">run</code>方法返回后，事务才会被提交。我们可以100%肯定，我们的用户将只与平衡，而不是以任何其他方式创建。如果有任何错误，它将被捕获，事务将被回滚，这意味着数据库中没有任何更改。</li></ol></div><div class="ab cl oe of hu og" role="separator"><span class="oh bw bk oi oj ok"/><span class="oh bw bk oi oj ok"/><span class="oh bw bk oi oj"/></div><div class="ij ik il im in"><h1 id="3db1" class="lz ma iq bd mb mc ol me mf mg om mi mj jw on jx ml jz oo ka mn kc op kd mp mq bi translated">更高级的例子</h1><p id="a650" class="pw-post-body-paragraph kw kx iq ky b kz mr jr lb lc ms ju le lf mt lh li lj mu ll lm ln mv lp lq lr ij bi translated">比方说，我们有两个场景:我们可以创建一个余额为空的简单用户，或者创建一个有奖金的高级用户。</p><p id="c520" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">此外，假设我们的项目中有某种抽象层，它与数据库一起工作并处理关于实体的所有细节。</p><p id="b8d0" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">为了简洁起见，我将只提供一个这种抽象实现的表面例子，其余的应该非常简单和相似。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mw mx l"/></div></figure><p id="df8d" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在本例中:</p><ol class=""><li id="4714" class="no np iq ky b kz la lc ld lf nq lj nr ln ns lr nt nu nv nw bi translated">我们的<code class="fe my mz na nb b">UserService</code>启动“大”主<code class="fe my mz na nb b">CreateUserTransaction</code>来创建一个用户。</li><li id="93c0" class="no np iq ky b kz nx lc ny lf nz lj oa ln ob lr nt nu nv nw bi translated">在主事务内部，我们首先调用我们的<code class="fe my mz na nb b">CreateBasicUserTransaction</code>的<code class="fe my mz na nb b">runWithinTransaction</code>方法，传递由外部事务创建的管理器。这是非常重要的，因为这个经理将是把所有事情联系在一起的一部分。</li><li id="a7ed" class="no np iq ky b kz nx lc ny lf nz lj oa ln ob lr nt nu nv nw bi translated">然后，我们调用我们的数据库抽象层类，如<code class="fe my mz na nb b">DbUserService</code>、<code class="fe my mz na nb b">DbBalanceService</code>，它们处理我们需要的一切(与实体相关)，无论是对TypeORM存储库的简单调用、几个这样的调用、一些获取和转换数据，还是您认为适合这一层的任何东西。再次强调，对每个数据库操作使用传递的<code class="fe my mz na nb b">EntityManager</code>是至关重要的。</li><li id="01ef" class="no np iq ky b kz nx lc ny lf nz lj oa ln ob lr nt nu nv nw bi translated">在<code class="fe my mz na nb b">CreateBasicUserTransaction</code>完成用户创建之后，我们的主事务继续检查用户是否是高级用户，如果需要的话做一些额外的工作，提交对数据库的更改(通过<code class="fe my mz na nb b">BaseTransaction</code>类)，并为我们的<code class="fe my mz na nb b">UserService</code>返回<code class="fe my mz na nb b">CreatedUserData</code>。</li><li id="bf8b" class="no np iq ky b kz nx lc ny lf nz lj oa ln ob lr nt nu nv nw bi translated">和前面的例子一样，如果在上面的任何步骤中出现任何错误，事务将被回滚，我们的数据库将不会受到任何“部分”更改的影响。</li></ol><h1 id="23bc" class="lz ma iq bd mb mc md me mf mg mh mi mj jw mk jx ml jz mm ka mn kc mo kd mp mq bi translated">结论</h1><p id="5ad6" class="pw-post-body-paragraph kw kx iq ky b kz mr jr lb lc ms ju le lf mt lh li lj mu ll lm ln mv lp lq lr ij bi translated">所描述的使用TypeORM和Nest.js处理事务的方式允许我们将任何连接的业务相关的数据库逻辑分成可管理和可重用的部分，并且我们不必关心事务处理本身。</p><p id="4d73" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这种方法的唯一缺点是必须沿着与数据库交互的方法到处“拖动”事务性<code class="fe my mz na nb b">EntityManager</code>。</p><p id="a48c" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们找不到一个简单的方法来解决它，因为我们不想让我们的代码过于复杂，例如，通过加入前面提到的“延续本地存储”的概念，或者为管理人员发明一些智能容器。如果你想到了一个，请给这篇文章留下评论，我们会很高兴地看看你的任何建议。</p><h2 id="1258" class="nc ma iq bd mb nd ne dn mf nf ng dp mj lf nh ni ml lj nj nk mn ln nl nm mp nn bi translated">文章的附加阅读和链接</h2><ol class=""><li id="fdef" class="no np iq ky b kz mr lc ms lf oq lj or ln os lr nt nu nv nw bi translated"><a class="ae kv" href="https://en.wikipedia.org/wiki/Database_transaction" rel="noopener ugc nofollow" target="_blank">维基百科中的交易</a></li><li id="bec8" class="no np iq ky b kz nx lc ny lf nz lj oa ln ob lr nt nu nv nw bi translated"><a class="ae kv" href="https://typeorm.io/transactions" rel="noopener ugc nofollow" target="_blank">交易表格文件</a></li><li id="b0e0" class="no np iq ky b kz nx lc ny lf nz lj oa ln ob lr nt nu nv nw bi translated"><a class="ae kv" href="https://docs.nestjs.com/techniques/database" rel="noopener ugc nofollow" target="_blank"> Nest.js关于使用数据库的文档</a></li><li id="b78b" class="no np iq ky b kz nx lc ny lf nz lj oa ln ob lr nt nu nv nw bi translated"><a class="ae kv" href="https://github.com/odavid/typeorm-transactional-cls-hooked" rel="noopener ugc nofollow" target="_blank">利用延续本地存储概念构建的Nest.js事务库</a></li><li id="083d" class="no np iq ky b kz nx lc ny lf nz lj oa ln ob lr nt nu nv nw bi translated">G <a class="ae kv" href="https://hackernoon.com/the-most-convenient-ways-of-writing-transactions-within-the-nestjs-typeorm-stack-3q3q33jd" rel="noopener ugc nofollow" target="_blank"> reat文章作者</a> <a class="oc od ep" href="https://medium.com/u/d364fcad7a5c?source=post_page-----3a417e6ab5--------------------------------" rel="noopener" target="_blank"> Mikhail Alfa </a> <a class="ae kv" href="https://hackernoon.com/the-most-convenient-ways-of-writing-transactions-within-the-nestjs-typeorm-stack-3q3q33jd" rel="noopener ugc nofollow" target="_blank">用TypeORM和Nest.js </a>和<a class="ae kv" href="https://github.com/alphamikle/nest_transact" rel="noopener ugc nofollow" target="_blank"> his库</a>提供不同的处理事务的方法</li></ol></div></div>    
</body>
</html>