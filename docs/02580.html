<html>
<head>
<title>Better Unit Testing (Part 2)</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">更好的单元测试(第2部分)</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/better-unit-testing-part-2-80d29fc0f4b3?source=collection_archive---------21-----------------------#2019-12-09">https://betterprogramming.pub/better-unit-testing-part-2-80d29fc0f4b3?source=collection_archive---------21-----------------------#2019-12-09</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="6e08" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">了解如何模拟依赖关系并在测试过程中节省时间</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/98ef87b5a48b5c1d9053c8df5072902d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*UeAA1VFsaQmutqFdStmkHw.jpeg"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">照片由<a class="ae ky" href="https://unsplash.com/@mometrixtestprep?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Mometrix测试准备</a>在<a class="ae ky" href="https://unsplash.com/s/photos/test?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>拍摄</p></figure><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="kz la l"/></div></figure><p id="68d3" class="pw-post-body-paragraph lb lc it ld b le lf ju lg lh li jx lj lk ll lm ln lo lp lq lr ls lt lu lv lw im bi translated">这个故事是<em class="lx">更好的单元测试</em>系列的延续，在这个系列中，我们已经介绍了基础知识，在你阅读这个系列之前，请检查一下。</p><div class="ly lz gp gr ma mb"><a href="https://medium.com/better-programming/better-unit-testing-part-1-aeac3c1aea77" rel="noopener follow" target="_blank"><div class="mc ab fo"><div class="md ab me cl cj mf"><h2 class="bd iu gy z fp mg fr fs mh fu fw is bi translated">更好的单元测试—第1部分</h2><div class="mi l"><h3 class="bd b gy z fp mg fr fs mh fu fw dk translated">在没有任何单元测试知识的情况下阅读这篇文章？那就更好了，我们开始吧</h3></div><div class="mj l"><p class="bd b dl z fp mg fr fs mh fu fw dk translated">medium.com</p></div></div><div class="mk l"><div class="ml l mm mn mo mk mp ks mb"/></div></div></a></div><p id="108e" class="pw-post-body-paragraph lb lc it ld b le lf ju lg lh li jx lj lk ll lm ln lo lp lq lr ls lt lu lv lw im bi translated">以下是你将从这篇文章中学到的东西:</p><ol class=""><li id="712c" class="mq mr it ld b le lf lh li lk ms lo mt ls mu lw mv mw mx my bi translated">什么是依赖？</li><li id="5367" class="mq mr it ld b le mz lh na lk nb lo nc ls nd lw mv mw mx my bi translated">如何测试有依赖关系的类？</li><li id="4b4b" class="mq mr it ld b le mz lh na lk nb lo nc ls nd lw mv mw mx my bi translated">一个独立于领域的例子来进一步说明问题。</li><li id="074f" class="mq mr it ld b le mz lh na lk nb lo nc ls nd lw mv mw mx my bi translated">如果你刚刚开始单元测试，你肯定应该知道的重要知识。</li><li id="4f09" class="mq mr it ld b le mz lh na lk nb lo nc ls nd lw mv mw mx my bi translated">成功完成单元测试后如何结束工作？</li></ol></div><div class="ab cl ne nf hx ng" role="separator"><span class="nh bw bk ni nj nk"/><span class="nh bw bk ni nj nk"/><span class="nh bw bk ni nj"/></div><div class="im in io ip iq"><h1 id="8f44" class="nl nm it bd nn no np nq nr ns nt nu nv jz nw ka nx kc ny kd nz kf oa kg ob oc bi translated">什么是依赖？</h1><p id="3882" class="pw-post-body-paragraph lb lc it ld b le od ju lg lh oe jx lj lk of lm ln lo og lq lr ls oh lu lv lw im bi translated">在我们的项目中，作为专业开发人员，我们通过构建不同的类来保持逻辑和责任的良好分离，这些类相互交互/通信以满足我们的需求，同时试图保持我们的系统干净和可维护。</p><p id="5770" class="pw-post-body-paragraph lb lc it ld b le lf ju lg lh li jx lj lk ll lm ln lo lp lq lr ls lt lu lv lw im bi translated">有时候，当你测试一个依赖于其他类的类时，你应该如何测试这个类呢？</p></div><div class="ab cl ne nf hx ng" role="separator"><span class="nh bw bk ni nj nk"/><span class="nh bw bk ni nj nk"/><span class="nh bw bk ni nj"/></div><div class="im in io ip iq"><h1 id="3e42" class="nl nm it bd nn no np nq nr ns nt nu nv jz nw ka nx kc ny kd nz kf oa kg ob oc bi translated">如何测试有依赖关系的类？</h1><p id="6ab0" class="pw-post-body-paragraph lb lc it ld b le od ju lg lh oe jx lj lk of lm ln lo og lq lr ls oh lu lv lw im bi translated">如果我们运行整个项目，所有需要的类都设置好了，我们可以测试我们通常做的事情，但这可能很耗时(首先是整个项目的构建时间，然后在运行时设置依赖类)。</p><p id="e9f4" class="pw-post-body-paragraph lb lc it ld b le lf ju lg lh li jx lj lk ll lm ln lo lp lq lr ls lt lu lv lw im bi translated">因此，我们将会浪费大量的时间来设置我们现在不关心的类，只是为了测试我们现在关心的类。</p><p id="d117" class="pw-post-body-paragraph lb lc it ld b le lf ju lg lh li jx lj lk ll lm ln lo lp lq lr ls lt lu lv lw im bi translated">嘲讽是答案。我们嘲笑我们的依赖类，就像它们已经被设置了一些虚拟数据一样，只是为了看看我们的<strong class="ld iu"> </strong>必需类是否正常工作。</p></div><div class="ab cl ne nf hx ng" role="separator"><span class="nh bw bk ni nj nk"/><span class="nh bw bk ni nj nk"/><span class="nh bw bk ni nj"/></div><div class="im in io ip iq"><h1 id="3aed" class="nl nm it bd nn no np nq nr ns nt nu nv jz nw ka nx kc ny kd nz kf oa kg ob oc bi translated">一个例子</h1><p id="13ce" class="pw-post-body-paragraph lb lc it ld b le od ju lg lh oe jx lj lk of lm ln lo og lq lr ls oh lu lv lw im bi translated">让我们举一个最简单的例子，它总是在我们的大多数项目中使用——登录屏幕。让我们为我们的登录系统编写测试，但是，首先，让我们了解我们的登录系统中涉及的组件。</p><ul class=""><li id="2c24" class="mq mr it ld b le lf lh li lk ms lo mt ls mu lw oi mw mx my bi translated">我们有<code class="fe oj ok ol om b">LoginSync</code>负责在登录后同步我们的设备，这取决于服务器的响应，这听起来像一个长时间运行的线程阻塞过程(实际上是这样，但我们现在不关心阻塞)。</li><li id="4053" class="mq mr it ld b le mz lh na lk nb lo nc ls nd lw oi mw mx my bi translated"><code class="fe oj ok ol om b">LoginApiSync</code>管理与API的联网并获得响应。</li><li id="c9ff" class="mq mr it ld b le mz lh na lk nb lo nc ls nd lw oi mw mx my bi translated"><code class="fe oj ok ol om b">AuthTokenCache</code>负责将从服务器收到的认证令牌保存在设备上。</li><li id="eed7" class="mq mr it ld b le mz lh na lk nb lo nc ls nd lw oi mw mx my bi translated">只有一个名为<code class="fe oj ok ol om b">loginSync()</code>的函数，它获取用户名和密码并返回<code class="fe oj ok ol om b">LoginResult</code> <strong class="ld iu"> </strong>，然后根据<code class="fe oj ok ol om b">LoginResult</code>，它要么缓存<code class="fe oj ok ol om b">AuthToken</code>要么保持不变。</li></ul><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="on la l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">来源:<a class="ae ky" href="https://gist.github.com/devDeejay/a1fd7fd702c5086809118d04cd732854" rel="noopener ugc nofollow" target="_blank">https://gist . github . com/devDeejay/a1fd 7 FD 702 c 5086809118d 04 CD 732854</a></p></figure></div><div class="ab cl ne nf hx ng" role="separator"><span class="nh bw bk ni nj nk"/><span class="nh bw bk ni nj nk"/><span class="nh bw bk ni nj"/></div><div class="im in io ip iq"><h1 id="9a88" class="nl nm it bd nn no np nq nr ns nt nu nv jz nw ka nx kc ny kd nz kf oa kg ob oc bi translated">让我们开始编写LoginSync的测试</h1><ol class=""><li id="7c25" class="mq mr it ld b le od lh oe lk oo lo op ls oq lw mv mw mx my bi translated">创建一个<code class="fe oj ok ol om b">LoginSyncTest</code>文件和一个<code class="fe oj ok ol om b">LoginSyncTest</code>类。容易识别被测系统的一个好的变量名是<code class="fe oj ok ol om b">SUT</code>，因此，将我们的<code class="fe oj ok ol om b">LoginSync</code>引用变量命名为<code class="fe oj ok ol om b">SUT</code>。</li><li id="2ba4" class="mq mr it ld b le mz lh na lk nb lo nc ls nd lw mv mw mx my bi translated">通常，<code class="fe oj ok ol om b">setup()</code>是我们实例化我们想要测试的类的实例的地方，但是在这里，我们不能直接这样做，因为它还需要另外两个类的实例。如您所见，我们有一个红色错误，表示它需要两个参数。</li></ol><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi or"><img src="../Images/ba421d98aac903d7602bce813eb14c8c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*yVyPunyFMpzhtLiM2yOuFw.png"/></div></div></figure><p id="736a" class="pw-post-body-paragraph lb lc it ld b le lf ju lg lh li jx lj lk ll lm ln lo lp lq lr ls lt lu lv lw im bi translated">3.让我们替换所需的依赖项，这些被替换的依赖项被称为<em class="lx">测试替身。</em></p><p id="5a78" class="pw-post-body-paragraph lb lc it ld b le lf ju lg lh li jx lj lk ll lm ln lo lp lq lr ls lt lu lv lw im bi translated">有不同类型的测试替身，如假的，模拟的，和存根。稍后我们将了解其中的每一个。</p><p id="22a0" class="pw-post-body-paragraph lb lc it ld b le lf ju lg lh li jx lj lk ll lm ln lo lp lq lr ls lt lu lv lw im bi translated">为了创建<code class="fe oj ok ol om b">TestDoubles</code>，我们创建了实现<code class="fe oj ok ol om b">LoginApiSync</code>和<code class="fe oj ok ol om b">AuthTokenCache</code>相同接口的类，但是实现的逻辑将是一个虚拟的。</p><h2 id="c70e" class="os nm it bd nn ot ou dn nr ov ow dp nv lk ox oy nx lo oz pa nz ls pb pc ob pd bi translated"><strong class="ak">创建测试双类</strong></h2><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi pe"><img src="../Images/fac2cb9759dd2fbe7a7876e141dda304.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*iQR06V_jB_HSKX31EROvzQ.png"/></div></div></figure><p id="4397" class="pw-post-body-paragraph lb lc it ld b le lf ju lg lh li jx lj lk ll lm ln lo lp lq lr ls lt lu lv lw im bi translated">现在，我们可以通过以下操作实例化我们的SUT:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi pf"><img src="../Images/bf4d8b29d23fa8ba1e712066c42118fe.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*RIbUqt2vc8geU367rzUvPw.png"/></div></div></figure><p id="fae1" class="pw-post-body-paragraph lb lc it ld b le lf ju lg lh li jx lj lk ll lm ln lo lp lq lr ls lt lu lv lw im bi translated">现在，让我们编写第一个测试函数。但这是另一个挑战。</p><p id="145f" class="pw-post-body-paragraph lb lc it ld b le lf ju lg lh li jx lj lk ll lm ln lo lp lq lr ls lt lu lv lw im bi translated">4.你如何测试<code class="fe oj ok ol om b">loginSync()</code>函数，甚至不知道它做什么？我们当然不能读取函数的实现，因为这样我们就把潜在的bug当成了特性。</p><p id="1537" class="pw-post-body-paragraph lb lc it ld b le lf ju lg lh li jx lj lk ll lm ln lo lp lq lr ls lt lu lv lw im bi translated">另一种方法是思考、尝试所有可能的场景，这就是单元测试的要点，不是吗？所以，让我们开始吧。</p><p id="3eb9" class="pw-post-body-paragraph lb lc it ld b le lf ju lg lh li jx lj lk ll lm ln lo lp lq lr ls lt lu lv lw im bi translated">让我们想想<code class="fe oj ok ol om b">LoginSync</code>类的所有用例。</p><ul class=""><li id="9fbb" class="mq mr it ld b le lf lh li lk ms lo mt ls mu lw oi mw mx my bi translated">用户名和密码被传递给网络API。</li><li id="676d" class="mq mr it ld b le mz lh na lk nb lo nc ls nd lw oi mw mx my bi translated">如果登录成功，<code class="fe oj ok ol om b">AuthTokenId</code>被更新并缓存。</li><li id="da02" class="mq mr it ld b le mz lh na lk nb lo nc ls nd lw oi mw mx my bi translated">如果登录失败，<code class="fe oj ok ol om b">AuthToken</code>不应该改变。</li></ul><p id="5e8b" class="pw-post-body-paragraph lb lc it ld b le lf ju lg lh li jx lj lk ll lm ln lo lp lq lr ls lt lu lv lw im bi translated">大概就这些吧！</p><p id="df9c" class="pw-post-body-paragraph lb lc it ld b le lf ju lg lh li jx lj lk ll lm ln lo lp lq lr ls lt lu lv lw im bi translated">5.让我们编写每一个测试用例。</p><p id="a8b8" class="pw-post-body-paragraph lb lc it ld b le lf ju lg lh li jx lj lk ll lm ln lo lp lq lr ls lt lu lv lw im bi translated">一个好的实践是添加所有测试场景的注释，然后为每个场景编写函数。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="on la l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">来源:<a class="ae ky" href="https://gist.github.com/devDeejay/3818b8df125a191f2e0cef446371f1af" rel="noopener ugc nofollow" target="_blank">https://gist . github . com/devDeejay/3818 b 8df 125 a 191 F2 E0 cef 446371 f1 af</a></p></figure><p id="9354" class="pw-post-body-paragraph lb lc it ld b le lf ju lg lh li jx lj lk ll lm ln lo lp lq lr ls lt lu lv lw im bi translated">然后，您可以在编写完所有测试后继续运行您的<code class="fe oj ok ol om b">Test</code>类，并查看您自己的类的结果。</p><p id="39ed" class="pw-post-body-paragraph lb lc it ld b le lf ju lg lh li jx lj lk ll lm ln lo lp lq lr ls lt lu lv lw im bi translated">在<a class="ae ky" href="https://developer.android.com/studio" rel="noopener ugc nofollow" target="_blank"> Android Studio </a>中，我们弹出这个按钮，有三个选项:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi pg"><img src="../Images/2b7c07b2f16d23618166dc39f6fd7daa.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*kWDAK80RRmhAoSFnUJsY0w.png"/></div></div></figure><ul class=""><li id="7611" class="mq mr it ld b le lf lh li lk ms lo mt ls mu lw oi mw mx my bi translated">运行—运行所有测试。</li><li id="7e53" class="mq mr it ld b le mz lh na lk nb lo nc ls nd lw oi mw mx my bi translated">调试——调试并观察测试类的行为。</li><li id="bcb9" class="mq mr it ld b le mz lh na lk nb lo nc ls nd lw oi mw mx my bi translated">带覆盖率运行——这告诉您关于您的代码覆盖率。测试中覆盖的行数和方法数。超级有帮助。我们应该始终以100%为目标，因为我们希望100%的组件都能工作。</li></ul></div><div class="ab cl ne nf hx ng" role="separator"><span class="nh bw bk ni nj nk"/><span class="nh bw bk ni nj nk"/><span class="nh bw bk ni nj"/></div><div class="im in io ip iq"><h1 id="29ec" class="nl nm it bd nn no np nq nr ns nt nu nv jz nw ka nx kc ny kd nz kf oa kg ob oc bi translated">重要的学习</h1><h2 id="39a0" class="os nm it bd nn ot ou dn nr ov ow dp nv lk ox oy nx lo oz pa nz ls pb pc ob pd bi translated">1.使用实例方法而不是静态方法</h2><p id="2f12" class="pw-post-body-paragraph lb lc it ld b le od ju lg lh oe jx lj lk of lm ln lo og lq lr ls oh lu lv lw im bi translated">您应该尽可能不要在类中编写静态方法，因为它们变得更加难以进行单元测试。</p><p id="f8a1" class="pw-post-body-paragraph lb lc it ld b le lf ju lg lh li jx lj lk ll lm ln lo lp lq lr ls lt lu lv lw im bi translated">因此，尝试编写实例方法，并使用该类的对象来访问它们，这样，您总是可以模拟该类的对象来测试其方法。</p><h2 id="1a89" class="os nm it bd nn ot ou dn nr ov ow dp nv lk ox oy nx lo oz pa nz ls pb pc ob pd bi translated">2.单体是你在单元测试中的敌人</h2><p id="44cc" class="pw-post-body-paragraph lb lc it ld b le od ju lg lh oe jx lj lk of lm ln lo og lq lr ls oh lu lv lw im bi translated">当你有多个单元测试，并且多个单元测试访问一个单元时，当你一个接一个地运行这些函数时，它们都可能通过，但是如果你一起运行它们，你将会面临冲突。</p><p id="533e" class="pw-post-body-paragraph lb lc it ld b le lf ju lg lh li jx lj lk ll lm ln lo lp lq lr ls lt lu lv lw im bi translated">在某些情况下，这些多重测试中的任何一个都会随机失败！因此，如果你坐下来调试它们，你是在兜风。</p><p id="a2c8" class="pw-post-body-paragraph lb lc it ld b le lf ju lg lh li jx lj lk ll lm ln lo lp lq lr ls lt lu lv lw im bi translated">这是因为singleton是共享的，如果你愿意的话，是交叉的，这违反了单元测试的原则——你的测试应该彼此独立地运行。</p><p id="8c23" class="pw-post-body-paragraph lb lc it ld b le lf ju lg lh li jx lj lk ll lm ln lo lp lq lr ls lt lu lv lw im bi translated">底线是，如果你想保持你的代码单元测试和开发者友好，不要使用单例。</p><h2 id="d1b2" class="os nm it bd nn ot ou dn nr ov ow dp nv lk ox oy nx lo oz pa nz ls pb pc ob pd bi translated">3.了解测试框架和库</h2><p id="23a1" class="pw-post-body-paragraph lb lc it ld b le od ju lg lh oe jx lj lk of lm ln lo og lq lr ls oh lu lv lw im bi translated">了解将使您的生活更轻松的测试框架。</p><p id="6f73" class="pw-post-body-paragraph lb lc it ld b le lf ju lg lh li jx lj lk ll lm ln lo lp lq lr ls lt lu lv lw im bi translated">例如，如果你是一名Android开发人员，<a class="ae ky" href="https://site.mockito.org/" rel="noopener ugc nofollow" target="_blank"> Mockito </a>是一个很棒的库，可以帮助你模仿你的测试替身，让你的开发生活变得简单而高效。</p></div><div class="ab cl ne nf hx ng" role="separator"><span class="nh bw bk ni nj nk"/><span class="nh bw bk ni nj nk"/><span class="nh bw bk ni nj"/></div><div class="im in io ip iq"><h1 id="46b8" class="nl nm it bd nn no np nq nr ns nt nu nv jz nw ka nx kc ny kd nz kf oa kg ob oc bi translated">结束你的工作</h1><p id="01ba" class="pw-post-body-paragraph lb lc it ld b le od ju lg lh oe jx lj lk of lm ln lo og lq lr ls oh lu lv lw im bi translated">我不能过多地谈论干净代码的重要性，这包括你的生产代码和测试代码库。如果您让您的测试代码库腐烂，您的生产代码也会腐烂！</p><p id="9efb" class="pw-post-body-paragraph lb lc it ld b le lf ju lg lh li jx lj lk ll lm ln lo lp lq lr ls lt lu lv lw im bi translated">因此，通过删除所有不必要的注释、空格来清理单元测试代码，也许可以为变量、函数和类想出更好的、更具描述性的、明确的名称。</p></div></div>    
</body>
</html>