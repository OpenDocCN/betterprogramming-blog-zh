# 编写可测试的 Kotlin 服务

> 原文：<https://betterprogramming.pub/writing-testable-services-in-kotlin-e56d0de0b82b>

## 你的测试不是问题，而是你不可测试的代码

![](img/c6bfd3d3c85e73ffa668810c9f852338.png)

图片由 [Testalize.me](https://unsplash.com/@testalizeme) 在 [Unsplash](https://unsplash.com/photos/0jE8ynV4mis) 上拍摄

在某种程度上，我们都曾抱怨过编写测试。我们在制作的时候已经做了大量的测试，那么为什么我们还要浪费时间去尝试自动化测试呢？它们很难写，一旦我们做出新的改变，它们就会崩溃。我曾一度分享过这种观点，但当我意识到一些事情后，它就改变了:

*   良好的测试覆盖率意味着更少的手工测试
*   回归测试确保错误不再出现
*   只要测试仍然通过，尽可能地重构
*   失败的测试比通过的测试更有用

你让我陷入了无限重构，但是考虑一下通过投资自动化测试可以节省的时间。如果它们能够可靠地覆盖最重要的流程，那么重复的手工测试就是浪费时间！但是这并没有改变测试很难编写和维护的事实；我们如何让投资物有所值？通过让你的代码**可测试**。

但是如何编写**可测试代码**？你把你的测试当作一等公民；通过设计您的服务，首先测试，然后运行。在本指南中，我将通过示例向您展示我学到的策略:实现众所周知的 [Swagger Petstore API](https://petstore.swagger.io/#/) 的一部分。

# 放弃

我试图让代码尽可能集中在本指南的主要目标上。我已经省略了任何对这个目标没有直接贡献的代码，因此代码可能看起来不完整或者不健壮。

这里提供的示例摘自一个示例项目。要了解它们是如何组合在一起的，你可以在这里找到它。

# 战略

我们将使用两个主要策略来实现我们今天的目标，模拟和依赖注入。

模拟是我们模仿真实物体的一种方式，用我们可以控制的物体来代替它的行为。当我们为应用程序构建测试时，我们用模拟版本替换外部依赖。有一些库可以使用反射来实现这一点，但是我更喜欢自己编写自己的库。

依赖注入是一个简单的概念:它本质上归结为将我们所有的数据库和客户端类作为参数传递给我们的业务逻辑，而不是静态地访问它们。它促使我们在构建服务时更加深思熟虑，但它也将作为我们模拟的交付机制。

# 数据库访问

出于本指南的考虑，让我们从自下而上开始:在我们的数据库访问对象(DAO)——或存储库。这是我们的`Pet` 模型，我们想从 MySQL 数据库中检索它。

我们可能会想出这样的刀…我这里用的是普通的 JDBC，但是大多数 ORM 会让你注入你自己的`DataSource`或者`Connection`。为了使我们未来的测试简单，我们确保在我们的 DAO 中没有嵌入业务逻辑；它应该只关注访问。

这里需要注意的重要一点是，我们在构造函数中注入了一个`DataSource`供 DAO 使用。这意味着我们可以自由地创建这个 DAO，并将其连接到我们想要的任何数据库。

现在您可能认为测试数据库代码是一件非常痛苦的事情，因为它涉及到在您的 CI 环境中建立一个数据库，但这并不是必须的。如果我们能在一些多余的特性上妥协，我们就能写出与 MySQL 和H2 兼容的 SQL:一个具有内存模式的纯 java 数据库。所以让我们把它加入到我们的项目中。

```
testImplementation("com.h2database:h2:2.1.210")
```

我们需要做的第一件事是创建一些我们可以在测试中重用的工具。这个`PetsDao.mock`扩展函数将构建一个通过依赖注入连接到测试数据库的 DAO。

如果您愿意，甚至可以将您的数据库种子转储到一个 SQL 文件中并执行它。

这是我们的第一个测试。它需要做的就是创建一个连接到 H2 的新 DAO，并运行我们的测试。由于每次测试都会创建一个新的数据库，所以我们不需要担心测试会相互影响。

我们的第一次测试非常简单；它验证了我们的 DAO 中的代码，并为我们提供了一个稳定的构建平台。

# API 客户端

接下来我想介绍的是 API 客户端。这些都可以通过正确的 HTTP 客户端进行全面测试。我强烈推荐[http4k](https://www.http4k.org/)；将一个假的服务器注入到一个客户端中是非常容易的，并且可以在不使用网络的情况下运行。

对于这个例子，我们将集成一个第三方图片托管服务，这样我们就不必担心存储大量的猫图片。让我们做一个客户。

重要的还是我们的构造函数参数，我们在这里注入了一个`HttpHandler`。在`http4k`中，`HttpHandler`字面上只是`(Request) -> Response`的`typealias`。这是非常强大的，因为我们可以注入一个实际的 http 客户端——像 okhttp 或 Java http——我们也可以注入我们自己的假服务器。

您可能会注意到没有主机名或凭证，但是它们可以由一个`Filter`注入到`HttpHandler`中。我们的测试后端不关心主机名和凭证，所以我们的客户端不一定需要关心；尽管不同意和无视，但我们会在以后准备好真正跑步时添加这些内容。

另一种方法是制作一个`ImageClient`接口，制作一个假的版本，然后不必处理一个假的 http 服务器。这是可以的，但这意味着我们在客户中没有任何测试覆盖，这可能隐藏一些最严重的错误。

现在，让我们写我们的假服务器。

看我们的山寨怎么也是个`HttpHandler`？我们可以将它直接注入到我们的客户机中，所有请求都将被路由到它。现在，在这一点上，我们可以做一些测试，但我通常不直接测试 API 客户端；再次强调，不同意也可以无视；但是当我们测试我们的业务逻辑时，它将得到检验。

需要注意的一点是，这个伪造品生成的 id 是连续的，这使得副作用和返回值很容易提前知道。给测试增加随机性会使它们变得脆弱，所以通常使用更可预测的东西会更安全。

# 业务逻辑(服务层)

因此，我知道我们一直在做这件事，但在这里，我们终于要写一些业务逻辑，把它们联系在一起。

服务代码本身非常简单；你应该再次注意到我们的`PetsDao`和`ThirdPartyImageClient` 都是通过构造函数注入的。您还应该注意到，绝对没有数据库事务逻辑污染我们的业务逻辑。

许多框架会训练您将服务调用与数据库事务结合起来，但是我们在这里不打算这么做。为什么？因为我们的业务逻辑都知道，我们的`PetsDao`可以由任何东西支持，比如 DynamoDB、内存或 API。

但是`PetsDaoTest`是事情开始变得真正有趣的地方。为了构建我们的`PetService`,我们需要用假数据库构建一个`PetsDao`,用假服务器构建一个`ThirdPartyImageClient`。然后我们可以开始做一些非常有趣的测试。

以`add image`测试为例:我们从现有的`Pet`开始，所以我们通过调用`petsDao.create`来播种测试。我们不调用`PetService.create`,因为它可能隐藏副作用或其他我们尚未测试的逻辑。如果测试失败，我们就不知道哪个对`PetService`的呼叫出了问题。

这样，如果测试失败，而我们的`PetsDaoTest`方法通过，我们就能更好地诊断故障。或者，您可以从 SQL 文件中加载一个全局种子。

一旦我们的测试调用了`petsDao.uploadImage`,我们就进行三次验证。首先是验证由`uploadImage`返回的`Pet` 看起来像我们期望的那样。但是我们知道应该有两个副作用，所以我们需要验证它们。为此，我们将直接在`PetsDao`和`FakeThirdPartyImageBackend`上执行断言。

# 界面(控制器/视图模型)

既然我们的服务中已经有了业务逻辑，下一步就是为客户提供一个接口来使用它。我们已经使我们的服务足够模块化，接口可以是 REST、RPC、WebSocket、流监听器，甚至是本地应用程序的视图模型。

但是对于这个例子，我们将构建一个 REST 服务器。再次强烈推荐 [http4k](https://www.http4k.org/) ，因为不启动服务器，不使用网络就可以测试；Ktor 也有这个能力。

对于这个 REST API，我们唯一的依赖是在我们的`PetService`上。注意它是如何返回一个`HttpHandler`的，这和我们注入到`ThirdPartyImageClient`中的一样。

客户端后端和服务器是一回事；整洁！

在我们的测试中，我们用与在`PetServiceTest`中相同的方式创建了一个`PetService`，但是我们将它注入到我们的`RestApi`中，这提供了一个`HttpHandler`，我们可以对其发出请求。

我建议你不要过度使用你的 API 测试；它们更难维护，并且在某一点之后，它们不会提供我们的`PetServiceTest`还没有提供的任何覆盖。如果您创建一个新版本的 API，它可能最终会使用完全相同的`PetService`调用，因此该 API 的额外测试是多余的。一个好的经验法则可能是只测试您期望收到的不同变化的状态代码。例如，200、400 和 404 案例。

你可能还注意到我们还在验证一些副作用。我们不需要走得太远，但我们确实需要验证我们希望发生的事情确实发生了。完全有可能 API 只是返回一些样本数据，而实际上并没有做任何事情。

# 运行服务器

经过这么长时间，我们已经完全测试了我们的服务，但是我们还没有真正运行它。没问题。我们可以构建一个`Runner`模块来收集我们的配置，构建我们的`RestApi`，然后将其连接到一个真实的服务器。

您可以按照自己的意愿收集配置参数，但是 ENV 在这里完成了这项工作。本质上，这个运行程序与设置一个测试没有太大的不同，但是有一些重要的区别:

*   `dataSource`是一个`MySqlDataSource`，指向一个真正的 MySQL 服务器
*   `ThirdPartyImageClient`将一个真实的客户端作为`HttpHandler`，但是将它包装在一个`Filter`中，后者将主机名和凭证添加到请求中
*   `RestApi`被转换成一个真实的服务器并启动

现在，我们可以运行我们的新`main`方法，我们的应用程序正在真正运行。

# 人工测试

因此，隔离测试很好，但是我们在`ThirdPartyImageClient`和`PetsDao`中做了几个假设。这些假设可能不正确，所以这是唯一需要手工测试的地方。

我们需要真正运行我们的应用程序，调用真正的 MySQL 数据库和第三方图像托管服务。如果我们遇到任何错误，修改我们的自动化测试或假后端来重现错误，然后修复我们的产品代码是非常重要的。这允许我们的手动测试实际上为我们的套件贡献回归测试，减少未来手动测试的需要。

例如，假设第三方图像托管站点返回 404，因为我们的路径错误。当我们将假设融入到模拟中时，这样的错误是不可避免的，但是通过将修正融入到我们的模拟和生产代码中，我们调整了不正确的假设，并强化了正确的假设。如果我们在产品代码中犯了一个被我们的 mock 发现的错误，那将会是一个非常强大的反馈，这是我们在手工测试中根本不会遇到的。

# 最后的想法

我希望本指南中展示的例子有助于提高代码的可测试性。随着测试覆盖率的增加，您将开始感受到几个优势:

*   虽然自动化测试可以关注细节，但是手动测试可能仅限于简单的冒烟测试
*   更少的测试时间意味着更快的开发速度
*   测试创建了一个安全网，使得大型重构变得可行
*   对部署和发布更有信心

我祝你好运，让你的服务可测试；让我知道它是如何为你工作的，感谢你的阅读！

# 回购样本

本指南是围绕一个样例回购编写的，这个样例回购可以在 Github 上找到。它可能会提供一个更完整的图片来帮助您制作自己的可测试代码。

[](https://github.com/oharaandrew314/testable-code-kotlin) [## GitHub-oharaandrew 314/testable-Code-kot Lin:我关于这个主题的中型文章的示例代码

### 此时您不能执行该操作。您已使用另一个标签页或窗口登录。您已在另一个选项卡中注销，或者…

github.com](https://github.com/oharaandrew314/testable-code-kotlin) 

# 额外收获:嘲笑 AWS SDK

你甚至可以嘲笑 AWS SDK！有两种方法:

*   创建客户端接口的模拟实现
*   启动一个假的 AWS 服务器并覆盖您的客户端的端点

您总是可以创建自己的 SDK 客户端的模拟实现，但是由于 AWS 有一个众所周知和理解的 API，所以有一些现成的工具可以节省您大量的时间。

## [spulec/moto](https://github.com/spulec/moto)

Moto 众所周知，有两种操作模式。它可以直接集成到 python 应用程序中，也可以启动模拟服务器。这是我为 python 应用程序选择的工具。

## [http4k/http4k-连接](https://github.com/http4k/http4k-connect)

AWS SDK 实际上只是 REST API 的一个臃肿的客户端，所以 http4k 有一个附带项目，为一些最流行的 AWS 服务提供轻量级的预构建客户端。这个工具似乎主要是为了取代 AWS SDK，但是它确实为一些受支持的服务提供了模拟后端。这对于无服务器环境来说非常好，因为您可以用 Jackson 和 Apache HttpClient 来代替冷启动性能不太好的适配器。

## [oharaandrew314/mock-AWS-Java-SDK](https://github.com/oharaandrew314/mock-aws-java-sdk)

我想要一个纯 java 的工具，可以容易地注入，并支持 Dynamo DB Mapper。上面的工具都不能给我所有这些东西。

所以我开始了这个项目，让我和我的同事在我们所有的服务中使用。它支持最常用的 AWS 服务，95%的时间都能完成工作。要使用它，您只需创建一个模拟客户端，并注入它来代替 AWS SDK 接口。希望你来看看！