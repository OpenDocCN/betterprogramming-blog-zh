<html>
<head>
<title>How To Run Your Entire Development Environment in Docker Containers on macOS</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何在macOS上的Docker容器中运行整个开发环境</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/php-how-to-run-your-entire-development-environment-in-docker-containers-on-macos-787784e94f9a?source=collection_archive---------2-----------------------#2019-12-15">https://betterprogramming.pub/php-how-to-run-your-entire-development-environment-in-docker-containers-on-macos-787784e94f9a?source=collection_archive---------2-----------------------#2019-12-15</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="4e22" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">使用Docker容器创建PHP 7.2本地主机、MySQL 8服务器和Redis服务器开发环境的分步指南</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi ki"><img src="../Images/6afcf1d0cdf7a844a1721e521f5f2f28.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*b1bgV_nQk_FLayYHBehgAQ.jpeg"/></div></figure><p id="3239" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">我写过几篇关于使用Homebrew在各种macOS机器版本上设置PHP localhost开发环境的文章，包括两篇关于在Docker容器中运行MySQL 8.0的文章。</p><p id="daab" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">现在我已经升级到了macOS 10.15 Catalina，它具有只读文件系统卷，我决定将我的开发环境完全从macOS中剥离出来，并在Docker容器中运行。这开启了各种可能性。首先，我不仅应该能够在所有版本的macOS上运行完全相同的开发环境，而且如果我愿意的话，我还应该能够在Ubuntu桌面上运行这些完全相同的容器——或者任何其他能够托管Docker的操作系统。其次，通过在容器中创建我的开发环境，我可以很容易地在一台新机器上设置我的整个开发环境，只需要几分钟，只需要几个Docker命令。</p><p id="e310" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">此外，通过将我的Apache/PHP环境放在一个容器中，我能够与不同版本的PHP或运行Wordpress的容器一起运行额外的容器。</p></div><div class="ab cl lm ln hx lo" role="separator"><span class="lp bw bk lq lr ls"/><span class="lp bw bk lq lr ls"/><span class="lp bw bk lq lr"/></div><div class="im in io ip iq"><h1 id="c380" class="lt lu it bd lv lw lx ly lz ma mb mc md jz me ka mf kc mg kd mh kf mi kg mj mk bi translated">我们要做的是</h1><p id="cdf9" class="pw-post-body-paragraph kq kr it ks b kt ml ju kv kw mm jx ky kz mn lb lc ld mo lf lg lh mp lj lk ll im bi translated">在本文中，我们将创建并启动三个Docker容器。第一个将包含我们的Redis服务器，我们将使用它进行PHP会话管理。通过单独运行Redis服务器，我们将更接近地模拟生产环境。</p><p id="47c8" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">第二个容器将遵循我之前在文章<a class="ae mq" href="https://medium.com/@crmcmullen/how-to-run-mysql-in-a-docker-container-on-macos-with-persistent-local-data-58b89aec496a" rel="noopener">中提供的说明，如何在macOS上的Docker容器中使用持久本地数据运行MySQL</a>，并且是一个MySQL 8.0服务器，使用<a class="ae mq" href="https://medium.com/@crmcmullen/how-to-run-mysql-8-0-with-native-password-authentication-502de5bac661" rel="noopener">本地密码认证作为本地主机MySQL实例运行</a>。</p><p id="eb96" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">第三个也是最后一个容器是我们的Apache/PHP 7.2本地主机服务器。为了实现这一点，我们将使用一个Dockerfile，它将集合我们开发环境中需要的所有组件，包括Xdebug、Redis和Igbinary PHP扩展。</p><p id="5579" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">所有这三个容器都将加入同一个Docker网络，以便Docker的本地DNS功能可以发挥作用，并且容器可以通过名称而不是IP地址相互通信。</p><p id="edce" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">我们开始吧！</p></div><div class="ab cl lm ln hx lo" role="separator"><span class="lp bw bk lq lr ls"/><span class="lp bw bk lq lr ls"/><span class="lp bw bk lq lr"/></div><div class="im in io ip iq"><h1 id="6d3a" class="lt lu it bd lv lw lx ly lz ma mb mc md jz me ka mf kc mg kd mh kf mi kg mj mk bi translated">家政</h1><h2 id="7812" class="mr lu it bd lv ms mt dn lz mu mv dp md kz mw mx mf ld my mz mh lh na nb mj nc bi translated">下载并安装docker</h2><p id="c774" class="pw-post-body-paragraph kq kr it ks b kt ml ju kv kw mm jx ky kz mn lb lc ld mo lf lg lh mp lj lk ll im bi translated">如果你还没有，从稳定渠道安装最新版本的docker for MAC:【https://docs.docker.com/docker-for-mac/install/<a class="ae mq" href="https://docs.docker.com/docker-for-mac/install/" rel="noopener ugc nofollow" target="_blank"/></p><h2 id="c1b8" class="mr lu it bd lv ms mt dn lz mu mv dp md kz mw mx mf ld my mz mh lh na nb mj nc bi translated">创建本地绑定文件夹</h2><p id="13d2" class="pw-post-body-paragraph kq kr it ks b kt ml ju kv kw mm jx ky kz mn lb lc ld mo lf lg lh mp lj lk ll im bi translated">我们将在macOS用户文件夹中创建一些文件夹，用于保存Redis和MySQL容器的配置文件，以及保存Apache和PHP日志文件的文件夹，以便于查找和访问。这些将在Docker运行语句期间被绑定到容器内的适当文件夹。</p><p id="521a" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">我们还将创建一个文件夹来存放我们构建的网站，这个文件夹将被绑定到PHP容器中的<code class="fe nd ne nf ng b">/var/www/html</code>文件夹。</p><p id="ba0a" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">打开终端并输入下面的命令。确保用您自己的macOS用户名替换<code class="fe nd ne nf ng b">[your_username]</code>。</p><p id="2839" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">注意。个人偏好:我喜欢把我的开发工具收集到一个名为<code class="fe nd ne nf ng b">Develop</code>的文件夹中。你可以根据自己的喜好随意调整位置。</p><pre class="kj kk kl km gt nh ng ni nj aw nk bi"><span id="4dfb" class="mr lu it ng b gy nl nm l nn no">mkdir /Users/[your_username]/Develop</span><span id="9242" class="mr lu it ng b gy np nm l nn no">mkdir /Users/[your_username]/Develop/docker_configs<br/>mkdir /Users/[your_username]/Develop/docker_configs/mysql<br/>mkdir /Users/[your_username]/Develop/docker_configs/redis</span><span id="e7bf" class="mr lu it ng b gy np nm l nn no">mkdir /Users/[your_username]/Develop/mysql_data</span><span id="9c7c" class="mr lu it ng b gy np nm l nn no">mkdir /Users/[your_username]/Develop/logs<br/>mkdir /Users/[your_username]/Develop/logs/apache<br/>mkdir /Users/[your_username]/Develop/logs/php</span><span id="0353" class="mr lu it ng b gy np nm l nn no">mkdir /Users/[your_username]/Sites</span></pre><p id="7d23" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">因为Docker已经默认将<code class="fe nd ne nf ng b">/Users</code>文件夹识别为文件共享，所以我们不需要在Docker文件共享首选项中做任何事情。</p><h2 id="c2bb" class="mr lu it bd lv ms mt dn lz mu mv dp md kz mw mx mf ld my mz mh lh na nb mj nc bi translated">创建Redis配置文件</h2><p id="e35a" class="pw-post-body-paragraph kq kr it ks b kt ml ju kv kw mm jx ky kz mn lb lc ld mo lf lg lh mp lj lk ll im bi translated">我们将为我们的Redis服务器创建一个配置文件。这主要是一个占位符文件，供您在以后想要更改其他设置时使用，但在本例中，我们将确保注释掉该行，以绑定Redis服务器侦听特定的IP地址。我们将允许开发环境中的服务器监听我们将在后面的步骤中创建的Docker网络上的所有IP地址端口。</p><p id="d12c" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">现在，我们将创建一个本地的<code class="fe nd ne nf ng b">redis.conf</code>文件，其中包含我们想要用来在Docker运行时修改Redis服务器容器内部配置的设置。</p><pre class="kj kk kl km gt nh ng ni nj aw nk bi"><span id="d497" class="mr lu it ng b gy nl nm l nn no">nano /Users/[your_username]/Develop/docker_configs/redis/redis.conf</span></pre><p id="2e3b" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">将以下两行添加到文件中:</p><pre class="kj kk kl km gt nh ng ni nj aw nk bi"><span id="307c" class="mr lu it ng b gy nl nm l nn no"># bind 127.0.0.1<br/>protected-mode yes</span></pre><p id="1a41" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">Control + o保存。<br/> Control + x退出。</p><h2 id="09c4" class="mr lu it bd lv ms mt dn lz mu mv dp md kz mw mx mf ld my mz mh lh na nb mj nc bi translated">创建一个MySQL配置文件</h2><p id="02bf" class="pw-post-body-paragraph kq kr it ks b kt ml ju kv kw mm jx ky kz mn lb lc ld mo lf lg lh mp lj lk ll im bi translated">现在我们将创建一个<code class="fe nd ne nf ng b">my.cnf</code>文件，该文件将包含一个设置，该设置将我们的MySQL 8服务器实例设置为使用本地密码认证而不是默认的<code class="fe nd ne nf ng b">caching_sha2_password</code>来运行。</p><pre class="kj kk kl km gt nh ng ni nj aw nk bi"><span id="8705" class="mr lu it ng b gy nl nm l nn no">nano /Users/[your_username]/Develop/docker_configs/mysql/my.cnf</span></pre><p id="95b8" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">将以下两行添加到文件中:</p><pre class="kj kk kl km gt nh ng ni nj aw nk bi"><span id="f8d2" class="mr lu it ng b gy nl nm l nn no">[mysqld]<br/>default-authentication-plugin=mysql_native_password</span></pre><p id="0f4e" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">Control + o保存。<br/> Control + x退出。</p><h2 id="1753" class="mr lu it bd lv ms mt dn lz mu mv dp md kz mw mx mf ld my mz mh lh na nb mj nc bi translated">创建一个PHP登陆页面</h2><p id="07d3" class="pw-post-body-paragraph kq kr it ks b kt ml ju kv kw mm jx ky kz mn lb lc ld mo lf lg lh mp lj lk ll im bi translated">让我们创建一个index.php登陆页面，稍后我们可以用它来验证我们的PHP服务器是否正常工作。</p><pre class="kj kk kl km gt nh ng ni nj aw nk bi"><span id="670e" class="mr lu it ng b gy nl nm l nn no">echo "&lt;?php phpinfo();" &gt; ~/Sites/index.php</span></pre><h2 id="df36" class="mr lu it bd lv ms mt dn lz mu mv dp md kz mw mx mf ld my mz mh lh na nb mj nc bi translated">禁用macOS版本的Apache</h2><p id="cd71" class="pw-post-body-paragraph kq kr it ks b kt ml ju kv kw mm jx ky kz mn lb lc ld mo lf lg lh mp lj lk ll im bi translated">macOS 10.15 Catalina预装了Apache。然而，我们将在一个容器中运行Apache，然后将端口80绑定到它，而不是使用交付的版本。</p><p id="f79b" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">如果您已经运行了预安装版本的macOS Apache，则需要首先关闭它，并删除任何自动加载脚本。运行以下两个命令没有坏处，即使是在全新安装时。</p><p id="0648" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">请注意，第二个命令是一个单行，由于页面宽度限制，它在Medium中换行了。确保复制整行。</p><pre class="kj kk kl km gt nh ng ni nj aw nk bi"><span id="d9c8" class="mr lu it ng b gy nl nm l nn no">sudo apachectl stop</span><span id="7b3a" class="mr lu it ng b gy np nm l nn no">sudo launchctl unload -w /System/Library/LaunchDaemons/org.apache.httpd.plist 2&gt;/dev/null</span></pre><p id="9fd4" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">就是这样。我们做完家务了。我们已经准备好了所有的本地文件夹和文件，并准备开始启动容器。</p></div><div class="ab cl lm ln hx lo" role="separator"><span class="lp bw bk lq lr ls"/><span class="lp bw bk lq lr ls"/><span class="lp bw bk lq lr"/></div><div class="im in io ip iq"><h1 id="373c" class="lt lu it bd lv lw lx ly lz ma mb mc md jz me ka mf kc mg kd mh kf mi kg mj mk bi translated">创建码头工人网络</h1><p id="024d" class="pw-post-body-paragraph kq kr it ks b kt ml ju kv kw mm jx ky kz mn lb lc ld mo lf lg lh mp lj lk ll im bi translated">Docker内置了DNS。因此，我们将为Docker容器创建一个本地网络。通过这样做，只要所有的容器都被添加到同一个网络中，我们所有的容器就能够通过名称而不是IP来相互通信。我的例子中的所有容器都是同一个网络的一部分。</p><p id="32b0" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">您可以随意命名您的网络。因为我们正在构建一个开发环境，所以我将它命名为<code class="fe nd ne nf ng b">dev-network.</code></p><pre class="kj kk kl km gt nh ng ni nj aw nk bi"><span id="f60e" class="mr lu it ng b gy nl nm l nn no">docker network create dev-network</span></pre></div><div class="ab cl lm ln hx lo" role="separator"><span class="lp bw bk lq lr ls"/><span class="lp bw bk lq lr ls"/><span class="lp bw bk lq lr"/></div><div class="im in io ip iq"><h1 id="3d4d" class="lt lu it bd lv lw lx ly lz ma mb mc md jz me ka mf kc mg kd mh kf mi kg mj mk bi translated">启动Redis服务器容器</h1><p id="24b5" class="pw-post-body-paragraph kq kr it ks b kt ml ju kv kw mm jx ky kz mn lb lc ld mo lf lg lh mp lj lk ll im bi translated">使用以下命令启动我们将用于PHP会话管理的Redis服务器容器:</p><pre class="kj kk kl km gt nh ng ni nj aw nk bi"><span id="3d0b" class="mr lu it ng b gy nl nm l nn no">docker run --restart always --name redis-localhost --net dev-network -v /Users/[your_username]/Develop/docker_configs/redis/redis.conf:/usr/local/etc/redis/redis.conf -d redis:5.0.6</span></pre><p id="6681" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">以下是每个参数的含义:</p><ul class=""><li id="6a67" class="nq nr it ks b kt ku kw kx kz ns ld nt lh nu ll nv nw nx ny bi translated"><code class="fe nd ne nf ng b">--restart always</code>会在Docker启动时重启这个容器，比如重启笔记本电脑或者Docker关闭后重启。如果您想每次都启动自己的容器，请不要使用这个参数。</li><li id="0f4c" class="nq nr it ks b kt nz kw oa kz ob ld oc lh od ll nv nw nx ny bi translated"><code class="fe nd ne nf ng b">--name redis-localhost</code>将这个名称分配给容器实例。</li><li id="23ab" class="nq nr it ks b kt nz kw oa kz ob ld oc lh od ll nv nw nx ny bi translated"><code class="fe nd ne nf ng b">--network dev-network</code>将把这个容器加入我们在上一步中创建的docker网络。</li><li id="fd85" class="nq nr it ks b kt nz kw oa kz ob ld oc lh od ll nv nw nx ny bi translated"><code class="fe nd ne nf ng b">-v /Users/[your_username]/Develop/docker_configs/redis/redis.conf:/usr/local/etc/redis/redis.conf</code> <strong class="ks iu"> </strong>会将容器内的配置文件绑定到我们提供的配置文件。</li><li id="70b8" class="nq nr it ks b kt nz kw oa kz ob ld oc lh od ll nv nw nx ny bi translated"><code class="fe nd ne nf ng b">-d</code>将在分离模式下运行容器，以便它在后台运行。</li><li id="7031" class="nq nr it ks b kt nz kw oa kz ob ld oc lh od ll nv nw nx ny bi translated"><code class="fe nd ne nf ng b">redis:5.0.6</code>表示官方DockerHub Redis版本标签5.0.6是要安装的版本。</li></ul><p id="d928" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">除非您已经将Redis Docker映像下载到您的笔记本电脑上，否则您第一次运行上述命令时，它会下载该映像。之后，后续运行将会快得多。</p><p id="e926" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">您可以运行以下命令来查看您的容器是否正在运行:</p><pre class="kj kk kl km gt nh ng ni nj aw nk bi"><span id="7cb8" class="mr lu it ng b gy nl nm l nn no">docker ps</span></pre></div><div class="ab cl lm ln hx lo" role="separator"><span class="lp bw bk lq lr ls"/><span class="lp bw bk lq lr ls"/><span class="lp bw bk lq lr"/></div><div class="im in io ip iq"><h1 id="85d2" class="lt lu it bd lv lw lx ly lz ma mb mc md jz me ka mf kc mg kd mh kf mi kg mj mk bi translated">启动MySQL 8.0服务器容器</h1><p id="3be9" class="pw-post-body-paragraph kq kr it ks b kt ml ju kv kw mm jx ky kz mn lb lc ld mo lf lg lh mp lj lk ll im bi translated">使用以下命令启动MySQL服务器容器。记得用你的Mac用户名代替<code class="fe nd ne nf ng b">[your_username]</code> <em class="oe"> </em>，用你最喜欢的MySQL root密码代替<code class="fe nd ne nf ng b">[your_password]</code>。</p><pre class="kj kk kl km gt nh ng ni nj aw nk bi"><span id="1311" class="mr lu it ng b gy nl nm l nn no">docker run --restart always --name mysql-localhost --net dev-network -v /Users/[your_username]/Develop/mysql_data/8.0:/var/lib/mysql -v /Users/[your_username]/Develop/docker_configs/mysql:/etc/mysql/conf.d -p 3306:3306 -d -e MYSQL_ROOT_PASSWORD=[your_password] mysql:8.0</span></pre><p id="ee2b" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">这些参数在上面的Redis服务器和我的其他文章中都有很好的解释，所以我将在这里跳过这些细节。请注意，您正在将您的<code class="fe nd ne nf ng b">mysql_data/8.0</code>文件夹绑定到容器内的<code class="fe nd ne nf ng b">/var/lib/mysql</code>，这将在容器重启后提供您的持久数据。您还将容器内的<code class="fe nd ne nf ng b">docker_configs/mysql</code>文件夹绑定到<code class="fe nd ne nf ng b"> /etc/mysql/conf </code>，这将覆盖MySQL服务器设置。</p><p id="c708" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">您可以运行以下命令来查看当前的容器列表:</p><pre class="kj kk kl km gt nh ng ni nj aw nk bi"><span id="fd3a" class="mr lu it ng b gy nl nm l nn no">docker ps</span></pre></div><div class="ab cl lm ln hx lo" role="separator"><span class="lp bw bk lq lr ls"/><span class="lp bw bk lq lr ls"/><span class="lp bw bk lq lr"/></div><div class="im in io ip iq"><h1 id="64e3" class="lt lu it bd lv lw lx ly lz ma mb mc md jz me ka mf kc mg kd mh kf mi kg mj mk bi translated">启动Apache/PHP 7.2服务器容器</h1><p id="1725" class="pw-post-body-paragraph kq kr it ks b kt ml ju kv kw mm jx ky kz mn lb lc ld mo lf lg lh mp lj lk ll im bi translated">在这一步中，我们将使用Docker文件构建一个自定义映像，该映像将包含Apache和PHP 7.2以及来自PECL的Xdebug、Igbinary和Redis PHP扩展。</p><p id="386a" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">一旦构建完成，我们将启动图像到一个容器中。</p><h2 id="ed4b" class="mr lu it bd lv ms mt dn lz mu mv dp md kz mw mx mf ld my mz mh lh na nb mj nc bi translated">创建Dockerfile文件</h2><p id="87fd" class="pw-post-body-paragraph kq kr it ks b kt ml ju kv kw mm jx ky kz mn lb lc ld mo lf lg lh mp lj lk ll im bi translated">首先创建一个存储Docker文件的位置，它将成为您的Docker开发环境:</p><pre class="kj kk kl km gt nh ng ni nj aw nk bi"><span id="8c5a" class="mr lu it ng b gy nl nm l nn no">mkdir /Users/[your_username]/Develop/docker_dev_env</span></pre><p id="f2e3" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">使用下面的Gist文件中的代码创建一个名为<code class="fe nd ne nf ng b">Dockerfile</code>(没有文件扩展名)的文件，并将其保存到上面创建的目录中。</p><p id="df86" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">如果你使用VSCode作为你的编辑器，我强烈推荐安装Docker扩展。它支持在Docker文件中进行颜色编码的语法编辑。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="of og l"/></div></figure><p id="5b87" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">在我们对这个docker文件运行build命令之前，让我们讨论一下它要做什么:</p><pre class="kj kk kl km gt nh ng ni nj aw nk bi"><span id="a520" class="mr lu it ng b gy nl nm l nn no">FROM php:7.2-apache</span><span id="a121" class="mr lu it ng b gy np nm l nn no"># run non-interactive. <br/>ENV DEBIAN_FRONTEND=noninteractive</span><span id="5487" class="mr lu it ng b gy np nm l nn no"># update OS and install utils<br/>RUN apt-get update; \<br/>    apt-get -yq upgrade; \<br/>    apt-get install -y --no-install-recommends \<br/>    apt-utils \<br/>    nano; \<br/>    apt-get -yq autoremove; \<br/>    apt-get clean; \<br/>    rm -rf /var/lib/apt/lists/*</span></pre><p id="afd0" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">在第一部分中，我们从官方的PHP Docker Hub仓库中提取，特别是提取7.2-apache标签。</p><p id="955a" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">然后，我们指出我们希望在非交互模式下运行这个docker文件，这将取消提示。</p><p id="0a1e" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">接下来，我们运行基本的Debian Linux更新和升级，在我们的容器中安装<code class="fe nd ne nf ng b">apt-utils </code>和<code class="fe nd ne nf ng b">nano</code>，并做一些日常工作。</p><pre class="kj kk kl km gt nh ng ni nj aw nk bi"><span id="03d9" class="mr lu it ng b gy nl nm l nn no"># make sure custom log directories exist<br/>RUN mkdir /usr/local/log; \<br/>    mkdir /usr/local/log/apache2; \<br/>    mkdir /usr/local/log/php; \<br/>    chmod -R ug+w /usr/local/log</span><span id="c34f" class="mr lu it ng b gy np nm l nn no"># create official PHP.ini file<br/>RUN cp /usr/local/etc/php/php.ini-development /usr/local/etc/php/php.ini</span></pre><p id="c966" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">在下一节中，我们将为Apache和PHP创建自定义日志目录。这些文件将映射到我们在本文开头的整理步骤中创建的本地文件夹。</p><p id="3b25" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">然后我们将提供的<code class="fe nd ne nf ng b">php.ini</code>文件的开发版本复制到<code class="fe nd ne nf ng b">php.ini</code>的可运行版本。</p><pre class="kj kk kl km gt nh ng ni nj aw nk bi"><span id="6d02" class="mr lu it ng b gy nl nm l nn no"># install MySQLi<br/>RUN docker-php-ext-install mysqli</span><span id="2508" class="mr lu it ng b gy np nm l nn no"># update PECL and install xdebug, igbinary and redis w/ igbinary enabled<br/>RUN pecl channel-update pecl.php.net; \<br/>    pecl install xdebug-2.7.2; \<br/>    pecl install igbinary-3.0.1; \<br/>    pecl bundle redis-5.0.2 &amp;&amp; cd redis &amp;&amp; phpize &amp;&amp; ./configure --enable-redis-igbinary &amp;&amp; make &amp;&amp; make install; \<br/>    docker-php-ext-enable xdebug igbinary redis</span><span id="84ef" class="mr lu it ng b gy np nm l nn no"># Delete the resulting ini files created by the PECL install commands<br/>RUN rm -rf /usr/local/etc/php/conf.d/docker-php-ext-igbinary.ini; \<br/>    rm -rf /usr/local/etc/php/conf.d/docker-php-ext-redis.ini; \ <br/>    rm -rf /usr/local/etc/php/conf.d/docker-php-ext-xdebug.ini</span></pre><p id="240b" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">在下一节中，我们将安装PHP扩展。首先，我们安装<code class="fe nd ne nf ng b">mysqli</code>扩展，在这种情况下，PHP 7.2不会默认安装这个扩展。</p><p id="5bdb" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">接下来，我们使用PECL安装Xdebug、Igbinary和Redis，并将Igbinary设置为序列化程序。然后我们在Docker中启用这些扩展。</p><p id="b4bc" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">PECL安装创建了额外的ini文件，我们删除了这些文件，因为对这些扩展的引用将在我们自己的定制<code class="fe nd ne nf ng b">php.ini </code>覆盖中完成。</p><pre class="kj kk kl km gt nh ng ni nj aw nk bi"><span id="d203" class="mr lu it ng b gy nl nm l nn no"># Add PHP config file to conf.d<br/>RUN { \<br/>        echo 'short_open_tag = Off'; \<br/>        echo 'expose_php = Off'; \    <br/>        echo 'error_reporting = E_ALL &amp; ~E_STRICT'; \<br/>        echo 'display_errors = On'; \<br/>        echo 'error_log = /usr/local/log/php/php_errors.log'; \<br/>        echo 'upload_tmp_dir = /tmp/'; \<br/>        echo 'allow_url_fopen = on'; \<br/>        echo '[xdebug]'; \<br/>        echo 'zend_extension="xdebug.so"'; \<br/>        echo 'xdebug.remote_enable = 1'; \<br/>        echo 'xdebug.remote_port = 9001'; \<br/>        echo 'xdebug.remote_autostart = 1'; \<br/>        echo 'xdebug.remote_connect_back = 0'; \<br/>        echo 'xdebug.remote_host = host.docker.internal'; \<br/>        echo 'xdebug.idekey = VSCODE'; \<br/>        echo '[redis]'; \<br/>        echo 'extension="igbinary.so"'; \<br/>        echo 'extension="redis.so"'; \<br/>        echo 'session.save_handler = "redis"'; \<br/>        echo 'session.save_path = "tcp://redis-localhost:6379?weight=1&amp;timeout=2.5"'; \<br/>    } &gt; /usr/local/etc/php/conf.d/php-config.ini</span></pre><p id="22ea" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">在上面的下一节中，我们将在容器内的<code class="fe nd ne nf ng b">php/conf.d</code>文件夹中创建一个<code class="fe nd ne nf ng b">php-config.ini</code>文件。这些配置设置将在运行时覆盖<code class="fe nd ne nf ng b">php.ini </code>文件夹。</p><p id="2075" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">需要注意的事项:</p><p id="cf76" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">我们将<code class="fe nd ne nf ng b">error_log</code>指向我们之前在这个Docker文件中创建的日志文件夹。</p><p id="de82" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">我做了以下Xdebug覆盖:</p><pre class="kj kk kl km gt nh ng ni nj aw nk bi"><span id="9ffc" class="mr lu it ng b gy nl nm l nn no">xdebug.remote_port = 9001<br/>xdebug.remote_host = host.docker.internal<br/>xdebug.idekey = VSCODE</span></pre><p id="64aa" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">这将启用从VSCode到Docker容器的远程调试(我使用VSCode)。如果您使用的是VSCode之外的IDE(例如PHPStorm等。)，那么您可能需要试验这些设置以使您的Xdebug正常工作。但是，因为我已经将端口改为9001，而不是使用默认端口9000，所以PHPStorm可以开箱即用。</p><p id="9888" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">在VSCode中，只需确保Xdebug端口指向9001。使用以下VSCode <code class="fe nd ne nf ng b">launch.json</code>文件设置:</p><pre class="kj kk kl km gt nh ng ni nj aw nk bi"><span id="3287" class="mr lu it ng b gy nl nm l nn no">{<br/>    "version": "0.2.0",<br/>    "configurations": [<br/>        <br/>        {<br/>            "name": "Listen for XDebug",<br/>            "type": "php",<br/>            "request": "launch",<br/>            "port": 9001,<br/>            "log": false,<br/>            "pathMappings": {<br/>                "/var/www/html/":"/Users/[your_username]/Sites/"<br/>            }<br/>        },<br/>        {<br/>            "name": "Launch currently open script",<br/>            "type": "php",<br/>            "request": "launch",<br/>            "program": "${file}",<br/>            "cwd": "${fileDirname}",<br/>            "port": 9001<br/>        }<br/>    ]<br/>}</span></pre><p id="380b" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">此外，我们还进行了以下会话覆盖:</p><pre class="kj kk kl km gt nh ng ni nj aw nk bi"><span id="f760" class="mr lu it ng b gy nl nm l nn no">session.save_path = "tcp://redis-localhost:6379?weight=1&amp;timeout=2.5"</span></pre><p id="c51b" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">这将我们的PHP会话保存路径指向我们在本文前面创建的<code class="fe nd ne nf ng b">redis-localhost</code> Redis服务器容器。</p><pre class="kj kk kl km gt nh ng ni nj aw nk bi"><span id="3c57" class="mr lu it ng b gy nl nm l nn no"># Manually set up the apache environment variables<br/>ENV APACHE_RUN_USER www-data<br/>ENV APACHE_RUN_GROUP www-data<br/>ENV APACHE_LOG_DIR /usr/local/log/apache2</span><span id="3738" class="mr lu it ng b gy np nm l nn no"># Configure apache mods<br/>RUN a2enmod rewrite</span><span id="857d" class="mr lu it ng b gy np nm l nn no"># Add ServerName parameter<br/>RUN echo "ServerName localhost" | tee /etc/apache2/conf-available/servername.conf<br/>RUN a2enconf servername</span><span id="85bf" class="mr lu it ng b gy np nm l nn no"># Update the default apache site with the config we created.<br/>RUN { \<br/> echo '&lt;VirtualHost *:80&gt;'; \<br/> echo '    ServerAdmin <a class="ae mq" href="mailto:crmcmullen@gmail.com" rel="noopener ugc nofollow" target="_blank">your_email@example.com</a>'; \<br/> echo '    DocumentRoot /var/www/html'; \<br/> echo '    &lt;Directory /var/www/html/&gt;'; \<br/> echo '        Options Indexes FollowSymLinks MultiViews'; \<br/> echo '        AllowOverride All'; \<br/> echo '        Order deny,allow'; \<br/> echo '        Allow from all'; \<br/> echo '    &lt;/Directory&gt;'; \<br/> echo '    ErrorLog /usr/local/log/apache2/error.log'; \<br/> echo '    CustomLog /usr/local/log/apache2/access.log combined' ; \<br/> echo '&lt;/VirtualHost&gt;'; \<br/> } &gt; /etc/apache2/sites-enabled/000-default.conf</span></pre><p id="72b5" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">在最后一部分，我们将实现Apache服务器覆盖，启用<code class="fe nd ne nf ng b">rewrite</code>和<code class="fe nd ne nf ng b">servername</code>模块，并创建<code class="fe nd ne nf ng b">000-default.conf</code>文件覆盖。</p></div><div class="ab cl lm ln hx lo" role="separator"><span class="lp bw bk lq lr ls"/><span class="lp bw bk lq lr ls"/><span class="lp bw bk lq lr"/></div><div class="im in io ip iq"><h1 id="5688" class="lt lu it bd lv lw lx ly lz ma mb mc md jz me ka mf kc mg kd mh kf mi kg mj mk bi translated">构建开发环境映像</h1><p id="5fe9" class="pw-post-body-paragraph kq kr it ks b kt ml ju kv kw mm jx ky kz mn lb lc ld mo lf lg lh mp lj lk ll im bi translated">使用终端，导航到您创建的保存Docker文件的新<code class="fe nd ne nf ng b">docker_dev_environment</code>文件夹。</p><pre class="kj kk kl km gt nh ng ni nj aw nk bi"><span id="951f" class="mr lu it ng b gy nl nm l nn no">cd /Users/[your_username]/Develop/docker_dev_env</span></pre><p id="a4e6" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">现在，我们将运行Docker build命令，该命令将使用您刚刚创建的Docker文件来创建一个新的自定义映像。我们将把我们的图像命名为<code class="fe nd ne nf ng b">dev-environment.</code></p><pre class="kj kk kl km gt nh ng ni nj aw nk bi"><span id="9c77" class="mr lu it ng b gy nl nm l nn no">docker build -t dev-environment .</span></pre><p id="c123" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">当您看到消息时，<code class="fe nd ne nf ng b">Successfully tagged dev-environment:latest</code>您的映像将被构建并准备好发布到一个容器中。</p><p id="5423" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">如果您想查看到目前为止您拥有的Docker图像列表，您可以使用以下命令:</p><pre class="kj kk kl km gt nh ng ni nj aw nk bi"><span id="3f97" class="mr lu it ng b gy nl nm l nn no">docker images -a</span></pre><p id="884a" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">这将向您显示一个类似如下的列表:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="oi oj di ok bf ol"><div class="gh gi oh"><img src="../Images/cbd1609e320e64865df3c7d18cfc4304.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Yg7V3fxyxy-MEPhXXLmNoQ.png"/></div></div></figure></div><div class="ab cl lm ln hx lo" role="separator"><span class="lp bw bk lq lr ls"/><span class="lp bw bk lq lr ls"/><span class="lp bw bk lq lr"/></div><div class="im in io ip iq"><h1 id="93d5" class="lt lu it bd lv lw lx ly lz ma mb mc md jz me ka mf kc mg kd mh kf mi kg mj mk bi translated">将开发环境映像启动到容器中</h1><p id="94c0" class="pw-post-body-paragraph kq kr it ks b kt ml ju kv kw mm jx ky kz mn lb lc ld mo lf lg lh mp lj lk ll im bi translated">现在，我们将把我们的新<code class="fe nd ne nf ng b">dev-environment </code>图像发布到一个容器中。</p><pre class="kj kk kl km gt nh ng ni nj aw nk bi"><span id="e522" class="mr lu it ng b gy nl nm l nn no">docker run --restart always --name www-localhost --net dev-network -v /Users/[your_username]/Sites:/var/www/html -v /Users/[your_username]/Develop/logs:/usr/local/log -p 80:80 -d dev-environment</span></pre><p id="ae00" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">让我们来分解这些Docker运行设置:</p><ul class=""><li id="6a5e" class="nq nr it ks b kt ku kw kx kz ns ld nt lh nu ll nv nw nx ny bi translated"><code class="fe nd ne nf ng b">--restart always</code>会在Docker启动的任何时候重启这个容器，比如笔记本电脑重启或者Docker关闭后重新启动。如果您想每次都启动自己的容器，请不要使用这个参数。</li><li id="a19f" class="nq nr it ks b kt nz kw oa kz ob ld oc lh od ll nv nw nx ny bi translated"><code class="fe nd ne nf ng b"><strong class="ks iu">--name www-localhost</strong></code>将这个名称分配给容器实例。</li><li id="c10e" class="nq nr it ks b kt nz kw oa kz ob ld oc lh od ll nv nw nx ny bi translated"><code class="fe nd ne nf ng b">--network dev-network</code>将把这个容器加入我们在上一步中创建的docker网络。</li><li id="5f38" class="nq nr it ks b kt nz kw oa kz ob ld oc lh od ll nv nw nx ny bi translated"><code class="fe nd ne nf ng b">-v /Users/[your_username]/Sites:/var/www/html</code> <strong class="ks iu"> </strong>会将我们在本文顶部的内务处理部分创建的<code class="fe nd ne nf ng b">/Sites</code>文件夹绑定到容器内的<code class="fe nd ne nf ng b">/var/www/html</code>文件夹。这会将您的站点文件夹设置为根web目录。</li><li id="5f4c" class="nq nr it ks b kt nz kw oa kz ob ld oc lh od ll nv nw nx ny bi translated"><code class="fe nd ne nf ng b">-v /Users/[your_username]/Develop/logs:/usr/local/log</code> <strong class="ks iu"> </strong>会将<code class="fe nd ne nf ng b">/Develop/logs</code>文件夹绑定到我们在Docker文件的容器内创建的自定义日志文件夹。现在，您的Apache和PHP日志将很容易在Finder的用户文件夹中访问。</li><li id="25bc" class="nq nr it ks b kt nz kw oa kz ob ld oc lh od ll nv nw nx ny bi translated"><code class="fe nd ne nf ng b">-p 80:80</code>将macOS上的端口80绑定到容器内部的端口80。</li><li id="9499" class="nq nr it ks b kt nz kw oa kz ob ld oc lh od ll nv nw nx ny bi translated"><code class="fe nd ne nf ng b">-d </code>将在分离模式下运行容器，以便它在后台运行。</li><li id="ef88" class="nq nr it ks b kt nz kw oa kz ob ld oc lh od ll nv nw nx ny bi translated"><code class="fe nd ne nf ng b">dev-environment</code>告诉Docker使用我们在上一步中创建的开发环境映像启动容器。</li></ul></div><div class="ab cl lm ln hx lo" role="separator"><span class="lp bw bk lq lr ls"/><span class="lp bw bk lq lr ls"/><span class="lp bw bk lq lr"/></div><div class="im in io ip iq"><h1 id="d0b3" class="lt lu it bd lv lw lx ly lz ma mb mc md jz me ka mf kc mg kd mh kf mi kg mj mk bi translated">验证您的环境是否正常工作</h1><p id="bbc9" class="pw-post-body-paragraph kq kr it ks b kt ml ju kv kw mm jx ky kz mn lb lc ld mo lf lg lh mp lj lk ll im bi translated">此时，您应该能够打开浏览器并导航到您的本地主机。我们在内务处理步骤中创建的index.php文件应该会立即加载。如果一切正常，您应该会看到类似如下的屏幕:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="oi oj di ok bf ol"><div class="gh gi om"><img src="../Images/d3298245a24151deb476fa0485216cf0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Knz7uZVudSBsQC9xLzz05A.png"/></div></div></figure><p id="f543" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">您应该能够向下滚动PHP信息，看到Igbinary、MySQLi、Redis和Xdebug都已加载并运行。</p></div><div class="ab cl lm ln hx lo" role="separator"><span class="lp bw bk lq lr ls"/><span class="lp bw bk lq lr ls"/><span class="lp bw bk lq lr"/></div><div class="im in io ip iq"><h1 id="7e77" class="lt lu it bd lv lw lx ly lz ma mb mc md jz me ka mf kc mg kd mh kf mi kg mj mk bi translated">回顾</h1><p id="ae3d" class="pw-post-body-paragraph kq kr it ks b kt ml ju kv kw mm jx ky kz mn lb lc ld mo lf lg lh mp lj lk ll im bi translated">我知道这里看起来有很多步骤，但是真的不太复杂。它基本上分为以下六个步骤:</p><ul class=""><li id="789e" class="nq nr it ks b kt ku kw kx kz ns ld nt lh nu ll nv nw nx ny bi translated">内务处理:创建您将在Docker运行命令中绑定到的所有文件夹和配置文件。现在您已经将这些配置资产构建到了<code class="fe nd ne nf ng b">/Develop</code>文件夹中，我建议您将该文件夹保存在某个地方，这样您就可以在将来加载时使用它了。</li><li id="5f67" class="nq nr it ks b kt nz kw oa kz ob ld oc lh od ll nv nw nx ny bi translated">创建码头工人网络。</li><li id="7aee" class="nq nr it ks b kt nz kw oa kz ob ld oc lh od ll nv nw nx ny bi translated">启动Redis容器。</li><li id="e883" class="nq nr it ks b kt nz kw oa kz ob ld oc lh od ll nv nw nx ny bi translated">启动MySQL容器。</li><li id="046b" class="nq nr it ks b kt nz kw oa kz ob ld oc lh od ll nv nw nx ny bi translated">构建<code class="fe nd ne nf ng b">dev-environment</code>图像。</li><li id="44a4" class="nq nr it ks b kt nz kw oa kz ob ld oc lh od ll nv nw nx ny bi translated">启动<code class="fe nd ne nf ng b">dev-environment</code>容器。</li></ul><p id="68dc" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">在Docker容器中运行开发环境的美妙之处在于，现在您可以在几分钟之内在一个新的负载上设置好您的开发环境。你现在也可以用不同版本的PHP或Wordpress自由运行不同的容器，而不必担心本地macOS上的设置。您甚至可以通过绑定到不同的端口来并排运行这些容器。您可以在端口80上运行您的自定义PHP容器，在端口8080上运行Wordpress容器，两者可以共享相同的MySQL和Redis容器。</p><p id="eea0" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">最后，像这样在Linux容器中运行您的开发环境将更有可能复制生产环境中运行的内容。</p></div><div class="ab cl lm ln hx lo" role="separator"><span class="lp bw bk lq lr ls"/><span class="lp bw bk lq lr ls"/><span class="lp bw bk lq lr"/></div><div class="im in io ip iq"><h1 id="4cf7" class="lt lu it bd lv lw lx ly lz ma mb mc md jz me ka mf kc mg kd mh kf mi kg mj mk bi translated">有用的Docker命令</h1><p id="38a0" class="pw-post-body-paragraph kq kr it ks b kt ml ju kv kw mm jx ky kz mn lb lc ld mo lf lg lh mp lj lk ll im bi translated">以下是我在Docker文件中尝试不同更改时随手可得的Docker命令列表:</p><ul class=""><li id="13f6" class="nq nr it ks b kt ku kw kx kz ns ld nt lh nu ll nv nw nx ny bi translated">查看所有图像:<br/> <code class="fe nd ne nf ng b"> docker images -a</code></li><li id="35b5" class="nq nr it ks b kt nz kw oa kz ob ld oc lh od ll nv nw nx ny bi translated">删除孤立的图像工件(当Docker构建中途失败时很方便):<br/> <code class="fe nd ne nf ng b"> docker system prune</code></li><li id="ed0d" class="nq nr it ks b kt nz kw oa kz ob ld oc lh od ll nv nw nx ny bi translated">删除Docker图片:<br/> <code class="fe nd ne nf ng b"> docker rmi [image_name]:[tag_name]</code></li><li id="965a" class="nq nr it ks b kt nz kw oa kz ob ld oc lh od ll nv nw nx ny bi translated">撞上正在运行的容器:<br/> <code class="fe nd ne nf ng b"> docker exec -it [containter_name] /bin/bash</code></li></ul><p id="4afe" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">就是这样！我希望这篇文章能帮助您找到一种在macOS上运行PHP开发环境的新方法。请访问我的其他文章来学习其他技巧和技术！</p></div></div>    
</body>
</html>