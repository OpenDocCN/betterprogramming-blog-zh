<html>
<head>
<title>The State Design Pattern in JavaScript</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">JavaScript中的状态设计模式</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/the-state-design-pattern-in-javascript-4eebdf5e471?source=collection_archive---------8-----------------------#2022-04-06">https://betterprogramming.pub/the-state-design-pattern-in-javascript-4eebdf5e471?source=collection_archive---------8-----------------------#2022-04-06</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="ae1d" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">收获国家模式的力量</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi ki"><img src="../Images/cfad498ea605f9b63130bd7dfd53ca1e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1280/format:webp/1*Q59enh669IQwibl2ktXhbg.jpeg"/></div><p class="kq kr gj gh gi ks kt bd b be z dk translated"><em class="ku">Mikhail Nilov在Pexels上拍摄的照片</em></p></figure><p id="b726" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">状态模式确保对象根据应用程序的当前“状态”以可预测的、协调的方式运行。</p><p id="395b" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">行为是在状态对象上定义的，当整体状态转换到它自己的状态时，该对象负责运行某个处理程序。这些状态对象操作的接口被称为<code class="fe lr ls lt lu b">Context</code>。</p><p id="ec00" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">这种模式在实践中的工作方式是，通过将某些动作的工作委托给代表一部分状态的状态对象，代表这部分状态的动作负责从它们对该状态的处理中更新它。</p><p id="0a15" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">这意味着<code class="fe lr ls lt lu b">Context</code>可能有一个或多个处理程序，但最终持有对<code class="fe lr ls lt lu b">Context</code>触发器状态的引用的状态对象会一次一个地在它们之间完全改变。</p><p id="f750" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">这是因为状态对象定义了触发动作的处理程序，这些动作可以根据处理程序发生的事情来确定下一个状态转换到什么状态。</p><h1 id="6ed7" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">状态模式解决什么问题？</h1><p id="c3a5" class="pw-post-body-paragraph kv kw it kx b ky mn ju la lb mo jx ld le mp lg lh li mq lk ll lm mr lo lp lq im bi translated">它解决的最重要的问题是当你的状态变大，有很多情况的时候。当我们的应用程序的状态会以多种方式改变时，尤其是当我们的应用程序变得巨大时，调试问题变得很困难。</p><p id="c4bb" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">redux是一个库，它成功地提供了一个易于使用、可预测的接口来解决复杂的状态问题。</p><h1 id="b1bb" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">履行</h1><p id="695c" class="pw-post-body-paragraph kv kw it kx b ky mn ju la lb mo jx ld le mp lg lh li mq lk ll lm mr lo lp lq im bi translated">假设我们正在实现某种状态，在这种状态下我们将使用计数器:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mt mu l"/></div></figure><p id="a63c" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">计数器从<code class="fe lr ls lt lu b">0</code>开始计数，每秒钟我们将把计数器增加<code class="fe lr ls lt lu b">1</code>。如果计数器小于<code class="fe lr ls lt lu b">5</code>，颜色保持<code class="fe lr ls lt lu b">"green"</code>。如果计数器在<code class="fe lr ls lt lu b">5</code>和<code class="fe lr ls lt lu b">7</code>之间，颜色将为<code class="fe lr ls lt lu b">"orange"</code>。最后，如果计数器为<code class="fe lr ls lt lu b">8</code>或更高，颜色将被设置为<code class="fe lr ls lt lu b">"red"</code>。</p><p id="04b9" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">如果没有状态模式，这可以通过如下方式实现:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mt mu l"/></div></figure><p id="5b8a" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">这非常简单，而且可以完成工作。由于这段代码非常短，所以没有必要实现state模式，因为这样做太过了。</p><p id="bb1e" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">假设我们的代码随着时间的推移增长到5000行。想想吧。你认为你会有一个简单的时间单元来测试你的程序吗？如果你的代码每次都是完美的，你就不会，但是真的没有一个开发人员在大型应用程序中从不出错。在某些时候肯定会有一些错误，所以在编写代码时，我们应该小心谨慎，做出明智的决定，这是对我们最有利的。代码应该总是易于测试。</p><p id="3526" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">这就是为什么状态模式是有用的，因为它是容易测试的，并且对于具有大型或复杂状态的应用程序是可伸缩的。</p><p id="b09d" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">当我们运行该代码片段时，我们得到如下结果:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mt mu l"/></div></figure><p id="5f7d" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">这意味着我们的代码在工作。在我们的<code class="fe lr ls lt lu b">start</code>函数中，实现只写了一次，但是几乎没有任何控制。<em class="mv">控制</em>也是状态模式的另一个好处。</p><p id="b0e7" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">让我们看看使用状态模式是什么样子的:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mt mu l"/></div></figure><p id="561b" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">从这个例子中可以挑选出一些东西。</p><p id="52d8" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">代码的其余部分没有使用行<code class="fe lr ls lt lu b">const ACTION = Symbol('_action_')</code>,但是我想说的是，使用这种策略来验证发送给<code class="fe lr ls lt lu b">send</code>方法的动作是用于更新状态的实际动作是一个很好的实践。</p><p id="af64" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">例如，我们可以在我们的<code class="fe lr ls lt lu b">send</code>方法开始时立即进行验证:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mt mu l"/></div></figure><p id="804f" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">如果我们不这样做，我们的代码可能更容易出错，因为我们可以像这样传入任何对象，但它仍然可以工作:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mt mu l"/></div></figure><p id="efb5" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">这看起来似乎是一件积极的事情，但是我们<em class="mv">想要确保触发状态更新</em>的唯一动作是那些由我们通过<code class="fe lr ls lt lu b">createAction</code>公开提供给它们的<em class="mv">接口产生的对象。为了有目的地进行调试，我们希望降低复杂性，并确保错误来自正确的位置。</em></p><p id="e724" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">接下来我们要看的是这几行:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mt mu l"/></div></figure><p id="4d9a" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">记得之前我们说过(没有双关语的意思):</p><blockquote class="mw mx my"><p id="b0c7" class="kv kw mv kx b ky kz ju la lb lc jx ld mz lf lg lh na lj lk ll nb ln lo lp lq im bi translated"><em class="it">这种模式在实践中的工作方式是，通过将某些动作的工作委托给代表一部分状态的状态对象，代表该部分状态的动作负责从它们对该状态的处理中更新它。</em></p></blockquote><p id="7c27" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">我们定义了一个<code class="fe lr ls lt lu b">increment</code>动作，它负责在通过<code class="fe lr ls lt lu b">send</code>使用时每秒递增一次。它接收当前的<code class="fe lr ls lt lu b">state</code>并获取返回值以合并到下一个状态。</p><p id="e97d" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">我们现在能够轻松地隔离和单元测试这种状态的行为:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mt mu l"/></div></figure><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mt mu l"/></div></figure><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mt mu l"/></div></figure><p id="6070" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">在我们的第一个例子中，我们将实现硬编码到函数中。同样，对该功能进行单元测试将会很困难。我们不能像这里一样隔离代码的各个部分。</p><p id="07f9" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">隔离在编程中非常强大。状态模式让我们孤立。隔离为将碎片组合在一起提供了更广泛的可能性，这一点现在很容易实现:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mt mu l"/></div></figure><p id="8a72" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">记住，我们也提到过状态模式是可伸缩的。随着我们的应用程序规模的增长，该模式用有用的组合功能来保护我们，以对抗可伸缩性:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mt mu l"/></div></figure><p id="fbf0" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">这个故事的寓意是。状态模式<em class="mv">工作</em>。</p><h1 id="dea2" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">大局</h1><p id="a245" class="pw-post-body-paragraph kv kw it kx b ky mn ju la lb mo jx ld le mp lg lh li mq lk ll lm mr lo lp lq im bi translated">在这篇文章的最后，这里是这篇文章中展示的状态设计模式的一个视觉视角:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="nd ne di nf bf ng"><div class="gh gi nc"><img src="../Images/817d1a1efe83076b975e91012ca870ff.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*XaLZOOsQilXyDpoX.png"/></div></div></figure></div><div class="ab cl nh ni hx nj" role="separator"><span class="nk bw bk nl nm nn"/><span class="nk bw bk nl nm nn"/><span class="nk bw bk nl nm"/></div><div class="im in io ip iq"><p id="8322" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">本帖到此结束！我希望你发现这是有价值的，并期待在未来更多！</p></div></div>    
</body>
</html>