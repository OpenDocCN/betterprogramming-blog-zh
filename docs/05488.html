<html>
<head>
<title>A Starter Guide to Building Real-Time Apps With Node.js</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用Node.js构建实时应用程序的入门指南</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/a-starter-guide-to-building-real-time-apps-with-node-js-a2a7b31944f2?source=collection_archive---------5-----------------------#2020-07-13">https://betterprogramming.pub/a-starter-guide-to-building-real-time-apps-with-node-js-a2a7b31944f2?source=collection_archive---------5-----------------------#2020-07-13</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="7939" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">通过构建聊天应用了解实时应用</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/5fdeff5bccb1a1a64634550d3fd091eb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*CsbgcTALydsfNHgKHx6D4g.jpeg"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated"><a class="ae ky" href="https://unsplash.com/@jeshoots?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">JESHOOTS.COM</a>在<a class="ae ky" href="https://unsplash.com/s/photos/chat?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍照</p></figure><p id="ed94" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在一个时间价值稳步增长的世界里，构建用户可以实时交互的应用程序已经成为大多数开发人员的准则。我们今天看到的大多数应用程序，无论是移动、桌面还是web应用程序，都至少包含一个实时功能。例如，实时消息和通知是应用程序中最常用的两种实时功能。</p><p id="a912" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在本文中，我们将通过构建一个实时聊天，向您介绍使用<a class="ae ky" href="https://nodejs.org/en/" rel="noopener ugc nofollow" target="_blank"> Node.js </a>开发实时应用程序。虽然本文将关注这个特定的用例，但是这里教授的概念可以应用于其他场景。</p><p id="3eca" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">事实上，由于其事件驱动和异步的特性，Node是构建实时应用程序的最佳编程语言之一。在开始构建实时应用程序之前，我们先来看看使用Node.js可以构建什么样的实时应用程序。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="3976" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">我们如何构建实时应用程序？</h1><p id="fe7d" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">构建实时应用程序与构建普通的web应用程序有什么不同吗？答案是肯定的。</p><p id="dc0b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">想象一个用户可以实时发送消息的消息应用程序。这些消息应该在发送后立即出现在其他用户的应用程序中。如果我们像普通的web应用程序一样实现这个应用程序，其中只有客户端可以向服务器发起接收数据的请求，用户必须定期刷新网页以查看最新的消息，或者客户端必须在很短的时间间隔内向服务器发送Ajax请求以检索最新的消息。前者对用户不太友好，后者浪费应用程序资源。那么，很明显，我们必须有一种不同的方法来构建更有意义的实时应用程序。</p><p id="a2cd" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">WebSocket 提供了我们需要的解决方案。WebSocket是一种允许客户端和服务器发起通信的通信协议。换句话说，使用WebSocket，服务器可以随时向客户端发送数据，而无需客户端先请求数据。在前面的消息应用程序中，我们可以使用WebSockets通过服务器向所有用户即时发送消息。我们可以使用WebSocket API，在构建应用程序时使用WebSockets进行通信。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="519b" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">用Node.js建立一个实时聊天室</h1><p id="55d2" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">现在我们已经介绍了实时应用程序开发的背景，我们可以开始创建我们自己的实时应用程序了。在本教程中，我们将建立一个简单的聊天室，用户可以使用它与其他连接的用户进行交流。任何数量的用户都可以连接到聊天室，一个用户发送的消息可以被所有连接到聊天室的用户立即看到。</p><p id="1e82" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们的简单聊天室将具有以下功能:</p><ul class=""><li id="371d" class="mz na it lb b lc ld lf lg li nb lm nc lq nd lu ne nf ng nh bi translated">更改用户的用户名</li><li id="43dd" class="mz na it lb b lc ni lf nj li nk lm nl lq nm lu ne nf ng nh bi translated">发送消息</li><li id="66e0" class="mz na it lb b lc ni lf nj li nk lm nl lq nm lu ne nf ng nh bi translated">显示另一个用户是否正在输入消息</li></ul><p id="11cd" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">酷毙了。现在我们有了我们的需求，让我们开始构建环境和设置结构。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="d7e3" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">设置应用程序环境</h1><p id="139a" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">首先，为应用程序创建一个新目录。然后，运行<code class="fe nn no np nq b">the npm init</code>来设置<code class="fe nn no np nq b">package.json</code>文件。确保在这一步，你指定<code class="fe nn no np nq b">app.js</code>作为你的主脚本。如果你没有，不要担心，你随时可以在你的<code class="fe nn no np nq b">package.json</code>中改变它。</p><h2 id="8cd9" class="nr md it bd me ns nt dn mi nu nv dp mm li nw nx mo lm ny nz mq lq oa ob ms oc bi translated">安装依赖项</h2><p id="3970" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">在本教程中，我们将使用express、ejs、socket.io和nodemon包来构建应用程序。</p><ul class=""><li id="7a14" class="mz na it lb b lc ld lf lg li nb lm nc lq nd lu ne nf ng nh bi translated">ejs是一个流行的js模板引擎</li><li id="4f87" class="mz na it lb b lc ni lf nj li nk lm nl lq nm lu ne nf ng nh bi translated">socket.io允许我们建立WebSocket连接</li><li id="51e0" class="mz na it lb b lc ni lf nj li nk lm nl lq nm lu ne nf ng nh bi translated">Nodemon是一个包，每当我们对应用程序代码进行更改时，它都会重新启动服务器。它消除了我们每次进行更改时手动停止和启动服务器的需要。与其他包不同，我们将nodemon作为开发依赖项安装，因为我们仅将它用于开发目的。</li></ul><p id="4bef" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">使用以下命令安装express、ejs和socket.io。</p><pre class="kj kk kl km gt od nq oe of aw og bi"><span id="eb82" class="nr md it nq b gy oh oi l oj ok">npm install express ejs socket.io --save</span></pre><p id="67f2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">使用以下命令将nodemon作为开发依赖项安装。</p><pre class="kj kk kl km gt od nq oe of aw og bi"><span id="91aa" class="nr md it nq b gy oh oi l oj ok">npm install nodemon --save-dev</span></pre><p id="af34" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">要用nodemon启动应用程序，我们应该向我们的<code class="fe nn no np nq b">package.json</code>文件添加一个启动脚本。</p><pre class="kj kk kl km gt od nq oe of aw og bi"><span id="7644" class="nr md it nq b gy oh oi l oj ok">"scripts": {<br/>    "start": "nodemon app.js",<br/> },</span></pre><p id="2aa3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">然后，我们可以通过在命令行上运行以下命令来启动应用程序。</p><pre class="kj kk kl km gt od nq oe of aw og bi"><span id="9782" class="nr md it nq b gy oh oi l oj ok">npm run start</span></pre><p id="3d84" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果失败了，不要担心，那基本上是因为我们还没有任何代码文件。</p><h2 id="72de" class="nr md it bd me ns nt dn mi nu nv dp mm li nw nx mo lm ny nz mq lq oa ob ms oc bi translated">设置应用程序结构</h2><p id="b5bf" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">安装了这个项目所需的所有依赖项后，让我们构建项目结构。为此，您需要创建几个目录，现在，创建一个名为<code class="fe nn no np nq b">app.js</code>的文件。让我们完成这项工作，使您的应用程序结构如下所示:</p><pre class="kj kk kl km gt od nq oe of aw og bi"><span id="a136" class="nr md it nq b gy oh oi l oj ok">|--app.js<br/>|--views<br/>|--node_modules<br/>|--package.json<br/>|--public<br/>   |--css<br/>   |--js</span></pre><p id="8ab1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我认为结构非常清楚，但让我们快速浏览一遍:</p><ul class=""><li id="06ef" class="mz na it lb b lc ld lf lg li nb lm nc lq nd lu ne nf ng nh bi translated"><code class="fe nn no np nq b">app.js</code>:我们将用来存放服务器端代码的文件</li><li id="bdd4" class="mz na it lb b lc ni lf nj li nk lm nl lq nm lu ne nf ng nh bi translated"><code class="fe nn no np nq b">views</code>:包含视图(ejs)的文件夹</li><li id="1802" class="mz na it lb b lc ni lf nj li nk lm nl lq nm lu ne nf ng nh bi translated"><code class="fe nn no np nq b">node_modules</code>:我们安装依赖项的地方</li><li id="d9d2" class="mz na it lb b lc ni lf nj li nk lm nl lq nm lu ne nf ng nh bi translated"><code class="fe nn no np nq b">package.json</code> : npm配置文件</li><li id="f916" class="mz na it lb b lc ni lf nj li nk lm nl lq nm lu ne nf ng nh bi translated"><code class="fe nn no np nq b">public</code>:我们将用来存储资产的目录，比如CSS文件、JavaScript文件(用于客户端)和图像。</li></ul></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="7450" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">构建服务器的第一步</h1><p id="82bc" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">在我们考虑进行实时连接之前，我们需要做的第一件事就是启动并运行<code class="fe nn no np nq b">express</code>。为此，让我们打开我们的<code class="fe nn no np nq b">app.js</code>文件并粘贴以下代码:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ol om l"/></div></figure><p id="21a9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">一旦我们配置了<code class="fe nn no np nq b">express</code>并使用<code class="fe nn no np nq b">ejs</code>作为模板系统，我们就可以开始sockets.io初始化工作了。为此，在您的<code class="fe nn no np nq b">app.js</code>文件的末尾添加以下代码。</p><pre class="kj kk kl km gt od nq oe of aw og bi"><span id="b9c8" class="nr md it nq b gy oh oi l oj ok">//initialize socket for the server<br/>const io = socketio(server)</span><span id="e49b" class="nr md it nq b gy on oi l oj ok">io.on('connection', socket =&gt; {<br/>    console.log("New user connected")<br/>})</span></pre><p id="ded1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">代码非常简单。我们正在从我们的<code class="fe nn no np nq b">server</code>连接(express)初始化<code class="fe nn no np nq b">socket.io</code>，然后我们使用<code class="fe nn no np nq b">io.on()</code>设置一个事件，该事件将在每次建立到套接字的新连接时被触发。</p><p id="a756" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果您现在使用<code class="fe nn no np nq b">npm start</code>运行您的服务器，您将能够接收新的套接字连接。所以让我们开始构建我们的前端。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="a2f5" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">构建您的前端</h1><p id="4df3" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">我们不会花太多时间来使我们的前端看起来令人惊叹，但是我们将解释如何连接到服务器以及如何<code class="fe nn no np nq b">emit</code>和<code class="fe nn no np nq b">capture</code>套接字事件。我们还会将所有这些应用到我们的聊天示例中。</p><p id="0514" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们首先在视图文件夹中创建一个模板。为此，创建一个<code class="fe nn no np nq b">index.ejs</code>文件并粘贴以下代码:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ol om l"/></div></figure><p id="d265" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">请注意我们是如何包含客户端socket.io库的脚本以及我们将在这段代码中使用的自定义JavaScript文件的。</p><pre class="kj kk kl km gt od nq oe of aw og bi"><span id="b477" class="nr md it nq b gy oh oi l oj ok">&lt;script src="https://cdnjs.cloudflare.com/ajax/libs/socket.io/2.0.4/socket.io.js"&gt;&lt;/script&gt;<br/>&lt;script src="/js/chatroom.js"&gt;&lt;/script&gt;</span></pre><p id="5707" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们还有一个ID为<code class="fe nn no np nq b">messageBtn</code>的按钮来发送新消息，还有一个ID为<code class="fe nn no np nq b">usernameBtn</code>的按钮来提交新用户名。用户名和消息输入分别具有id<code class="fe nn no np nq b">username</code>和<code class="fe nn no np nq b">message</code>。所有用户消息都应该出现在ID为<code class="fe nn no np nq b">message-list</code>的无序列表中。如果用户绑定了一条消息，该信息将出现在带有类<code class="fe nn no np nq b">info</code>的div中。</p><p id="5677" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果您打开我们的浏览器并前往<code class="fe nn no np nq b">http://localhost:3000/</code>，您的应用程序将如下所示:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi oo"><img src="../Images/111fd6c857fd7ef2bc05f6932db83c79.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*nQ-gnHVXq2J5IjPu2-Qh8g.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">实时聊天室布局</p></figure><p id="a231" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">但它什么也没做。按钮不起作用，它将是一个非常静态的应用程序。接下来，让我们开始将前端连接到服务器。</p><p id="2757" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">为此，在公共目录的<code class="fe nn no np nq b">js</code>文件夹中创建一个名为<code class="fe nn no np nq b">chatroom.js</code>的新JavaScript文件(注意，在上面的HTML中，我已经引用了这个文件)。在JavaScript文件内部，我们需要从前端连接到套接字。我们可以这样做:</p><pre class="kj kk kl km gt od nq oe of aw og bi"><span id="bb05" class="nr md it nq b gy oh oi l oj ok">(function connect(){<br/>    let socket = io.connect('http://localhost:3000')<br/>})()</span></pre><p id="8eb2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">再次访问您的网站，在您的终端(在服务器端)中，您将会看到类似如下的内容:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi op"><img src="../Images/bfaffad127e4c502f600ac41631ff7c2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*c2DVBM3LELxOwxz8D_SwcQ.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">终端日志示例</p></figure><p id="5830" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">厉害！你的应用已经在工作了，尽管它做的不多。接下来让我们构建功能。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="7b7a" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">更改用户名</h1><p id="f8fb" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">我们用于每个连接的默认用户名是“匿名”我们为用户提供了更改用户名的选项。我们将设置后端在前端发出一个<code class="fe nn no np nq b">change_username</code>事件时改变用户名。回到您的服务器端代码(<code class="fe nn no np nq b">app.js</code>)并编辑您的<code class="fe nn no np nq b">connection</code>事件以添加新代码。</p><pre class="kj kk kl km gt od nq oe of aw og bi"><span id="0ad6" class="nr md it nq b gy oh oi l oj ok">io.on('connection', socket =&gt; {<br/>    console.log("New user connected")</span><span id="5aa2" class="nr md it nq b gy on oi l oj ok">    socket.username = "Anonymous"</span><span id="9a27" class="nr md it nq b gy on oi l oj ok">    socket.on('change_username', data =&gt; {<br/>        socket.username = data.username<br/>    })<br/>})</span></pre><p id="643f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">接下来，我们需要调整我们的前端，以便当我们按下“更改用户名”按钮时，它向服务器发出一个名为<code class="fe nn no np nq b">change_username</code>的事件。看看我们是如何通过发射和捕获相同的事件名称来构建名称的？</p><p id="b7d8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在<code class="fe nn no np nq b">chatroom.js</code>内部，我们将为<code class="fe nn no np nq b">usernameBtn</code>添加一个事件监听器，以便在按钮被点击时发出一个<code class="fe nn no np nq b">change_username</code>事件。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ol om l"/></div></figure><p id="409e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在，如果您重新加载网页并提交新的用户名，您将看到您当前的用户名更改为新的用户名。接下来，让我们开始发送消息。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="43aa" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">发送消息</h1><p id="6578" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">我们要实现的下一个特性是发送消息。在这里，事情开始变得有点不同。到目前为止，我们说前端每发出一条消息，服务器都会收到。然而，在我们的新例子中，前端需要发出一个<code class="fe nn no np nq b">new_message</code>事件，然后需要将该事件发送给所有连接的客户端，以便它们可以打印新消息。</p><p id="2539" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">首先，我们将设置前端在提交新消息时发出一个<code class="fe nn no np nq b">new_message</code>事件。由于客户端也应该配置为接收其他用户从服务器发送的新消息，应用程序也应该在前端监听<code class="fe nn no np nq b">receive_message</code>事件，并在网页上适当地显示新消息。我们可以使用下面的代码来完成这两项任务，这些代码位于前面的<code class="fe nn no np nq b">chatroom.js</code>中的<code class="fe nn no np nq b">connect</code>函数内。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ol om l"/></div></figure><p id="8ae7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">每次客户端发生<code class="fe nn no np nq b">receive_message</code>事件时，我们都会更改DOM来在屏幕上显示消息。</p><p id="3eaa" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在后端，当我们接收到一个<code class="fe nn no np nq b">new_message</code>事件时，我们需要向所有客户端发出一个新事件。为此，我们使用了<code class="fe nn no np nq b">io.sockets.emit()</code>函数。将<code class="fe nn no np nq b">app.js</code>文件中的<code class="fe nn no np nq b">connection</code>事件更改如下:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ol om l"/></div></figure><p id="e4b9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">当处理<code class="fe nn no np nq b">new_message</code>事件时，服务器本身向连接的客户端发出一个<code class="fe nn no np nq b">receive_message</code>事件，其中包含关于新消息的数据。所有连接到服务器的用户都会收到这个事件，包括发送消息的用户，这样新消息就会显示在他们的聊天室界面上。</p><p id="ef7d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果您现在在浏览器中打开您的web应用程序(您可以有多个实例)，您可以开始聊天(与您自己？:p)</p><p id="b1e5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">您可以使用两个不同的浏览器连接到聊天室，并体验发送消息的功能。查看一个用户发送的消息如何立即出现在两个用户的应用程序界面上。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi oq"><img src="../Images/ad7c0432a9fe71c776c74f6c5f5104ef.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ZN5VSb2lOlhK2MVHzteiKA.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">实时聊天室—发送消息</p></figure></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="beff" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">我在打字…</h1><p id="9823" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">在我们今天使用的大多数实时消息应用程序中，每当另一个用户正在输入消息时，我们都会看到一条简单的文本，上面写着“用户X正在输入…”。这给了应用程序更实时的感觉，并改善了用户体验。我们将把这个特性添加到我们的应用程序中。</p><p id="b030" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">首先，我们来考虑前端实现。我们在消息输入框中添加了一个新的事件监听器，以便在按键发生时发出一个<code class="fe nn no np nq b">typing</code>事件。因为消息输入框上的按键指示用户正在键入消息，所以<code class="fe nn no np nq b">typing</code>事件告诉服务器用户正在键入消息。客户端还监听服务器发出的<code class="fe nn no np nq b">typing</code>事件，以了解另一个用户是否正在输入消息，并将其显示在用户界面上。</p><p id="a792" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">同样，在<code class="fe nn no np nq b">chatroom.js</code>的connect函数中，我们添加了以下代码。</p><pre class="kj kk kl km gt od nq oe of aw og bi"><span id="60fe" class="nr md it nq b gy oh oi l oj ok">let info = document.querySelector('.info')</span><span id="474d" class="nr md it nq b gy on oi l oj ok">message.addEventListener('keypress', e =&gt; {<br/>    socket.emit('typing')<br/>})</span><span id="753b" class="nr md it nq b gy on oi l oj ok">socket.on('typing', data =&gt; {<br/>    info.textContent = data.username + " is typing..."<br/>    setTimeout(() =&gt; {info.textContent=''}, 5000)<br/>})</span></pre><p id="d7aa" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果一个用户正在键入一条消息，其他用户会看到文本“用户X正在键入…”五秒钟。</p><p id="666c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在我们需要设置后端来处理输入事件。我们这里使用的代码是这样的:</p><pre class="kj kk kl km gt od nq oe of aw og bi"><span id="8c13" class="nr md it nq b gy oh oi l oj ok">socket.on('typing', data =&gt; {<br/>    socket.broadcast.emit('typing', {username: socket.username})<br/>})</span></pre><p id="f2c0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这里，socket.io使用<code class="fe nn no np nq b">broadcast</code>函数来通知连接的客户端。当我们使用<code class="fe nn no np nq b">broadcast</code>时，除了正在键入消息的用户之外的每个用户都从服务器接收到键入事件，因此除了正在键入消息的用户之外的每个用户都被显示文本“用户X正在键入…”。</p><p id="4412" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">同样，你可以从两个浏览器连接到聊天室，看看这是如何实时工作的。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi or"><img src="../Images/dbbb86c6abd432d75158adde6f8a9759.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*oTnaNArN9PXle72Sqsn-xw.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">实时聊天室—打字</p></figure><p id="2a97" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">厉害！</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="06ca" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">摘要</h1><p id="c649" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">今天，在桌面、移动和web应用程序中使用实时功能几乎已经成为一种必然。在本文中，我们讨论了一些实时应用程序的应用程序，并学习了如何在Node.js和Socket.io的帮助下创建实时聊天室。从这里继续，您可以尝试通过添加更多功能和使用数据库来保存旧消息来改进这个聊天室，或者您可以实现另一个具有不同用例的实时应用程序。</p><p id="a0d6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">感谢阅读！</p></div></div>    
</body>
</html>