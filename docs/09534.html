<html>
<head>
<title>An Interactive and Documented Playground for React Components With Storybook</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">React组件与故事书的交互式和文档化平台</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/an-interactive-and-documented-playground-for-react-components-with-storybook-6-bbc87dcb4258?source=collection_archive---------11-----------------------#2021-09-06">https://betterprogramming.pub/an-interactive-and-documented-playground-for-react-components-with-storybook-6-bbc87dcb4258?source=collection_archive---------11-----------------------#2021-09-06</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="df75" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">展示您的组件以及详细的文档</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/616f72d1e9c6a3fcced075afe40ae6ad.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*54zPgtqtmnHXQFim-FUyOw.jpeg"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated"><a class="ae ky" href="https://unsplash.com/@magicpattern?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">在<a class="ae ky" href="https://unsplash.com/@magicpattern?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的</a>魔术图案</p></figure><p id="5900" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">Storybook是我最近一直在使用的一个非常强大的工具，它可以在一个被文档包围的交互式游戏中展示组件。有几个特性使它变得高效且易于使用，但它最大的好处是允许您在一个隔离的环境中开发UI组件，也就是说，不需要任何连接的UI、API或数据来触发不同的组件状态。</p><p id="9b7d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">支撑这些孤立环境的是“故事”。编写故事是为了利用组件，就像应用程序的其他部分使用组件一样。不同之处在于，显示组件并与之交互不需要应用程序的任何业务逻辑，这完全可以通过包含某些控件的交互式UI来完成。</p><p id="858b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们想想这在以下几个场景中会有用:</p><ul class=""><li id="d581" class="lv lw it lb b lc ld lf lg li lx lm ly lq lz lu ma mb mc md bi translated">开源软件包的文档</li><li id="9756" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated">向这些组件的潜在消费者展示组件的不同变化，例如启用/禁用按钮</li><li id="4d68" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated">跨团队设置设计标准</li></ul><p id="6a1b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">像AirBnB这样的组织已经利用Storybook来展示他们的设计系统和文档。</p><p id="09d1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在本教程中，我将使用一个TypeScript模板完成Create React应用程序(CRA)的基本故事书设置。如果JavaScript模板有什么需要做的不同，我会在后面指出来。</p></div><div class="ab cl mj mk hx ml" role="separator"><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo"/></div><div class="im in io ip iq"><h1 id="b2b3" class="mq mr it bd ms mt mu mv mw mx my mz na jz nb ka nc kc nd kd ne kf nf kg ng nh bi translated">设置</h1><p id="cd95" class="pw-post-body-paragraph kz la it lb b lc ni ju le lf nj jx lh li nk lk ll lm nl lo lp lq nm ls lt lu im bi translated">假设您已经在使用CRA搭建的应用程序，让我们继续将<a class="ae ky" href="https://storybook.js.org/docs/react/get-started/install" rel="noopener ugc nofollow" target="_blank"> Storybook </a>安装在您的项目目录的根目录下:</p><pre class="kj kk kl km gt nn no np nq aw nr bi"><span id="5b69" class="ns mr it no b gy nt nu l nv nw">npx sb init</span></pre><p id="a538" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">然后用:<code class="fe nx ny nz no b">npm run storybook</code> / <code class="fe nx ny nz no b">yarn storybook</code>运行它</p><p id="6929" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">您应该看到下面的屏幕展示了几个示例故事(<code class="fe nx ny nz no b">Introduction</code>、<code class="fe nx ny nz no b">Button</code>、<code class="fe nx ny nz no b">Header</code>和<code class="fe nx ny nz no b">Page</code>)。侧边栏将包含您的所有故事，主画布部分包含您的UI组件。Docs选项卡将包含为每个故事的组件自动生成的<code class="fe nx ny nz no b">prop</code>类型的表格，以及组件本身。“文档”选项卡非常灵活且可定制——我们稍后会谈到这一点。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi oa"><img src="../Images/fc79f4f1a70134961b245fa739a38ecc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Tp1Ez158TP7HIDMQGzfTyA.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">故事书文档</p></figure></div><div class="ab cl mj mk hx ml" role="separator"><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo"/></div><div class="im in io ip iq"><h1 id="1758" class="mq mr it bd ms mt mu mv mw mx my mz na jz nb ka nc kc nd kd ne kf nf kg ng nh bi translated">深入示例故事</h1><p id="bab0" class="pw-post-body-paragraph kz la it lb b lc ni ju le lf nj jx lh li nk lk ll lm nl lo lp lq nm ls lt lu im bi translated">在<code class="fe nx ny nz no b">src/stories</code>里面，你会发现标准的TypeScript React组件和它们对应的故事，名为<code class="fe nx ny nz no b">&lt;component-name&gt;.stories.tsx</code></p><h2 id="8ff4" class="ns mr it bd ms ob oc dn mw od oe dp na li of og nc lm oh oi ne lq oj ok ng ol bi translated">Button.tsx</h2><p id="757c" class="pw-post-body-paragraph kz la it lb b lc ni ju le lf nj jx lh li nk lk ll lm nl lo lp lq nm ls lt lu im bi translated">让我们先来看看组件——记住，每个故事背后都有一个组件或它的变体。<code class="fe nx ny nz no b">button.tsx</code>渲染一个<code class="fe nx ny nz no b">button</code>，接受几个道具。</p><p id="8440" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu">提示:</strong>你在每个道具和组件上面看到的注释是用来记录故事的。尝试更改文本“<em class="om">用户交互的主要UI组件”</em>，并在“文档”选项卡中重新加载您的故事书页面。</p><h2 id="695a" class="ns mr it bd ms ob oc dn mw od oe dp na li of og nc lm oh oi ne lq oj ok ng ol bi translated">Button.stories.tsx —导出故事</h2><p id="3219" class="pw-post-body-paragraph kz la it lb b lc ni ju le lf nj jx lh li nk lk ll lm nl lo lp lq nm ls lt lu im bi translated">这个文件包含了<code class="fe nx ny nz no b">Button</code>组件的故事。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="on oo l"/></div></figure><ul class=""><li id="8f0a" class="lv lw it lb b lc ld lf lg li lx lm ly lq lz lu ma mb mc md bi translated">看一下第一个块，我们看到一个非常不同的默认导出，它们包含属性。属性定义了这个文件中的故事在侧边栏中的位置。查看Storybook提供的网页，我们看到<code class="fe nx ny nz no b">Button</code>属于一个叫做<code class="fe nx ny nz no b">EXAMPLE</code>的部分，然后属于<code class="fe nx ny nz no b">Button</code> <strong class="lb iu">。</strong></li><li id="8263" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated"><code class="fe nx ny nz no b">component</code>道具告诉Storybook你具体指的是哪个组件，这样它就可以自动获取它的道具和它们的类型。还记得<code class="fe nx ny nz no b">Button.tsx</code>收了几个道具吗？您应该可以在<code class="fe nx ny nz no b">Docs</code>选项卡下看到这些完全相同的道具。Storybook只需要一个简单的属性就可以承认这些:</li></ul><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi op"><img src="../Images/c9967d04142a22d3ca935e9356c8b45f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*7-reYCSThv_aqUcdIZLUrg.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">图片来源:作者</p></figure><ul class=""><li id="69fa" class="lv lw it lb b lc ld lf lg li lx lm ly lq lz lu ma mb mc md bi translated">最后，<code class="fe nx ny nz no b">argTypes</code> —我之前提到过Storybook给你一个图形用户界面来与组件交互。这是通过一个<a class="ae ky" href="https://storybook.js.org/docs/react/essentials/controls" rel="noopener ugc nofollow" target="_blank">控件</a>附件来实现的，你可以利用<code class="fe nx ny nz no b">args</code>或<code class="fe nx ny nz no b">argsTypes</code>属性来激活它。在某些情况下，这些是根据参数的类型自动添加的。</li></ul><h2 id="a51c" class="ns mr it bd ms ob oc dn mw od oe dp na li of og nc lm oh oi ne lq oj ok ng ol bi translated">为什么我们只把backgroundColor看作一个argType？</h2><p id="cbe5" class="pw-post-body-paragraph kz la it lb b lc ni ju le lf nj jx lh li nk lk ll lm nl lo lp lq nm ls lt lu im bi translated">你可能已经注意到<code class="fe nx ny nz no b">primary</code>也使用一种类型的控件，但是与<code class="fe nx ny nz no b">backgroundColor</code>不同，它没有在<code class="fe nx ny nz no b">export</code>对象的<code class="fe nx ny nz no b">args</code>属性中指定。默认情况下，Storybook将根据参数的初始值为每个道具类型选择一个控件。这将与一些参数一起工作，如<code class="fe nx ny nz no b">boolean</code>和<code class="fe nx ny nz no b">strings</code>(因此有<code class="fe nx ny nz no b">primary</code>控件)，但可能有其他场景(即选择一种颜色)，你可能需要一个更高级的控件。这就是你应该利用<code class="fe nx ny nz no b">argTypes</code>的地方</p><h2 id="59d9" class="ns mr it bd ms ob oc dn mw od oe dp na li of og nc lm oh oi ne lq oj ok ng ol bi translated">Button.stories.tsx —故事设置</h2><p id="ff58" class="pw-post-body-paragraph kz la it lb b lc ni ju le lf nj jx lh li nk lk ll lm nl lo lp lq nm ls lt lu im bi translated">Storybook有效地允许您创建模板，然后可以扩展这些模板以避免一遍又一遍地编写相同的标记。</p><p id="14d8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">一个按钮是一个很好的例子来说明这是如何工作的。一个按钮可以有不同的变体、大小等，但是标记将总是包含一个HTML按钮标签。</p><p id="7072" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在这个特定的文件中，我们有不同的故事来展示按钮组件的不同变化(主要的、次要的、大的和小的)。使用下面的模板，我们使用底层的<code class="fe nx ny nz no b">Button</code>组件来标记故事:</p><pre class="kj kk kl km gt nn no np nq aw nr bi"><span id="5411" class="ns mr it no b gy nt nu l nv nw">const Template: ComponentStory&lt;typeof Button&gt; = (<em class="om">args</em>) =&gt; &lt;Button {...args} /&gt;;</span></pre><p id="fc9a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">创建基础模板后，其他故事利用模板展示不同的尺寸、颜色等。</p><pre class="kj kk kl km gt nn no np nq aw nr bi"><span id="843b" class="ns mr it no b gy nt nu l nv nw">export const Primary = Template.bind({});</span><span id="49a2" class="ns mr it no b gy oq nu l nv nw">Primary.args = {</span><span id="ff0c" class="ns mr it no b gy oq nu l nv nw">   primary: true,</span><span id="2f7a" class="ns mr it no b gy oq nu l nv nw">   label: 'Button',</span><span id="a88e" class="ns mr it no b gy oq nu l nv nw">};</span></pre><p id="01af" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe nx ny nz no b">Button</code>组件的主要故事将自己绑定到模板，并传入自定义道具来定义主要变化的样子。第二个故事展示了没有<code class="fe nx ny nz no b">primary</code>的按钮会是什么样子:</p><pre class="kj kk kl km gt nn no np nq aw nr bi"><span id="fbcc" class="ns mr it no b gy nt nu l nv nw">export const Secondary = Template.bind({});</span><span id="93fc" class="ns mr it no b gy oq nu l nv nw">Secondary.args = {</span><span id="4020" class="ns mr it no b gy oq nu l nv nw">    label: 'Button',</span><span id="dbf5" class="ns mr it no b gy oq nu l nv nw">};</span></pre><p id="e7bd" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我前面提到，有些类型足以让Storybook选择相关控件。在上面的两个故事中，我们使用简单的<code class="fe nx ny nz no b">args</code>类型(string和boolean)，足以让Storybook选择控件。我们还可以看到，它们不需要在<code class="fe nx ny nz no b">export</code>对象中定义，而是可以附加到每个story对象上。</p><p id="b30d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">注意:您必须导出文件中的所有故事<em class="om">才能在侧边栏中显示，但是只能有一个<code class="fe nx ny nz no b">default export</code>。</em></p></div><div class="ab cl mj mk hx ml" role="separator"><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo"/></div><div class="im in io ip iq"><h1 id="41ff" class="mq mr it bd ms mt mu mv mw mx my mz na jz nb ka nc kc nd kd ne kf nf kg ng nh bi translated">非模板化故事</h1><p id="8b9f" class="pw-post-body-paragraph kz la it lb b lc ni ju le lf nj jx lh li nk lk ll lm nl lo lp lq nm ls lt lu im bi translated">故事不一定要绑定到模板，你也可以这样写故事:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="on oo l"/></div></figure></div><div class="ab cl mj mk hx ml" role="separator"><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo"/></div><div class="im in io ip iq"><h1 id="861d" class="mq mr it bd ms mt mu mv mw mx my mz na jz nb ka nc kc nd kd ne kf nf kg ng nh bi translated">MDX</h1><p id="942f" class="pw-post-body-paragraph kz la it lb b lc ni ju le lf nj jx lh li nk lk ll lm nl lo lp lq nm ls lt lu im bi translated">到目前为止，在上面的例子中，我们已经看到了以标准的<a class="ae ky" href="https://storybook.js.org/docs/react/api/csf" rel="noopener ugc nofollow" target="_blank">组件故事格式(CSF) </a>编写的故事。但这不是Storybook接受的唯一格式。从版本6开始，Storybook也支持<a class="ae ky" href="https://storybook.js.org/docs/react/api/mdx" rel="noopener ugc nofollow" target="_blank"> MDX </a>语法——一个结合了Markdown和JSX的文件。</p><p id="5cc4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">当我们想要将包含代码块和其他Markdown特性的冗长文档与UI组件结合在一起时，MDX尤其重要。如果我们将演示项目的<code class="fe nx ny nz no b">Button.stories.tsx</code>写入MDX，它看起来会像下面这样:</p><h2 id="6ff4" class="ns mr it bd ms ob oc dn mw od oe dp na li of og nc lm oh oi ne lq oj ok ng ol bi translated"><strong class="ak"> Button.stories.mdx </strong></h2><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="on oo l"/></div></figure><p id="0163" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">注意:将<code class="fe nx ny nz no b">.mdx</code> gists嵌入到Medium中会导致实际内容被呈现到页面上，所以我必须用不同的名称来命名它。请遵循您代码库中的<code class="fe nx ny nz no b">*stories.mdx</code>格式。</p><p id="7c89" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">将这个文件作为<code class="fe nx ny nz no b">Button.stories.mdx</code>复制到您的项目中，注意它与演示项目中的CSF示例完全相同。</p><p id="44d1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">要在MDX中显示arg表，需要<code class="fe nx ny nz no b">&lt;ArgsTable of={Button} /&gt;</code>。</p><p id="516d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">MDX文件可以包含故事以及Markdown，这使得它非常灵活，可以适应许多用例。</p></div><div class="ab cl mj mk hx ml" role="separator"><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo"/></div><div class="im in io ip iq"><h1 id="3b29" class="mq mr it bd ms mt mu mv mw mx my mz na jz nb ka nc kc nd kd ne kf nf kg ng nh bi translated">自定义</h1><p id="d5ad" class="pw-post-body-paragraph kz la it lb b lc ni ju le lf nj jx lh li nk lk ll lm nl lo lp lq nm ls lt lu im bi translated">Storybook为其消费者提供了大量的定制内容，其中一些我们已经看过了，例如<code class="fe nx ny nz no b">argTypes</code>。以下是其他一些例子:</p><ul class=""><li id="a2af" class="lv lw it lb b lc ld lf lg li lx lm ly lq lz lu ma mb mc md bi translated"><a class="ae ky" href="https://storybook.js.org/docs/react/configure/theming" rel="noopener ugc nofollow" target="_blank">主题化</a>——在<code class="fe nx ny nz no b">addons</code>和<code class="fe nx ny nz no b">theming</code>包的帮助下改变默认网页的颜色和品牌。使用文档中显示的配置文件<code class="fe nx ny nz no b">.storybook/manager.ts</code>和<code class="fe nx ny nz no b">.storybook/preview.js</code>在明暗主题之间切换，或者创建你自己的主题。</li><li id="6c00" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated"><a class="ae ky" href="https://storybook.js.org/docs/react/essentials/actions" rel="noopener ugc nofollow" target="_blank">动作</a> —当您使用<code class="fe nx ny nz no b">actions</code>插件与您的组件交互时，显示每个处理器收到的数据。</li><li id="8e84" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated"><a class="ae ky" href="https://storybook.js.org/docs/react/essentials/measure-and-outline" rel="noopener ugc nofollow" target="_blank">测量和概述</a> —直接从故事书组件页面检查和调试CSS。</li><li id="ecae" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated"><a class="ae ky" href="https://storybook.js.org/docs/react/essentials/viewport" rel="noopener ugc nofollow" target="_blank"> Viewport </a> —验证您的组件在不同设备上的响应能力。</li></ul></div><div class="ab cl mj mk hx ml" role="separator"><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo"/></div><div class="im in io ip iq"><h1 id="bd70" class="mq mr it bd ms mt mu mv mw mx my mz na jz nb ka nc kc nd kd ne kf nf kg ng nh bi translated">MDX extras</h1><p id="b6ef" class="pw-post-body-paragraph kz la it lb b lc ni ju le lf nj jx lh li nk lk ll lm nl lo lp lq nm ls lt lu im bi translated">虽然Storybook CSF的大多数功能都是现成的，但有些功能需要通过MDX手动添加:</p><ul class=""><li id="71c2" class="lv lw it lb b lc ld lf lg li lx lm ly lq lz lu ma mb mc md bi translated">参数/道具表— <code class="fe nx ny nz no b">&lt;ArgsTable of={Button} /&gt;</code></li><li id="b052" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated">准确的组件描述— <code class="fe nx ny nz no b">&lt;Description of={Button} /&gt;</code></li><li id="8b0e" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated">带缩放图标的“文档”选项卡工具栏— <code class="fe nx ny nz no b">&lt;Canvas withToolbar&gt;</code></li><li id="ba74" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated">更改参数控件:</li></ul><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="on oo l"/></div></figure></div><div class="ab cl mj mk hx ml" role="separator"><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo"/></div><div class="im in io ip iq"><h1 id="332f" class="mq mr it bd ms mt mu mv mw mx my mz na jz nb ka nc kc nd kd ne kf nf kg ng nh bi translated">摘要</h1><p id="3e75" class="pw-post-body-paragraph kz la it lb b lc ni ju le lf nj jx lh li nk lk ll lm nl lo lp lq nm ls lt lu im bi translated">故事书是一个强大的工具，它为设计系统和开源包的开发者提供了一个完美的平台来隔离和显示他们的UI组件。</p><p id="fd70" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">反过来，为这些设计系统和软件包的消费者提供了一个交互式游戏环境来试用这些组件。</p><p id="e695" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">除了开箱即用的特性和类型脚本支持之外，它的主要优势是不再需要任何附加到组件的API或业务逻辑。他们被展示在一个完全隔离的环境中，并直接从互动游戏场接受辩论。</p></div></div>    
</body>
</html>