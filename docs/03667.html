<html>
<head>
<title>When to Use Vue Over React</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">何时使用Vue Over React</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/when-to-use-vue-over-react-9a4e0f01e064?source=collection_archive---------11-----------------------#2020-02-25">https://betterprogramming.pub/when-to-use-vue-over-react-9a4e0f01e064?source=collection_archive---------11-----------------------#2020-02-25</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="aa89" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">这是一篇非常有见解的文章，基于我过去四年作为前端web开发人员的经验</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/0b20a23171c0673d67291a4976a5d452.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*xVAOuSmrd1VCKirVS6RzCg.jpeg"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">Javier Allegue Barros 在<a class="ae ky" href="https://unsplash.com/s/photos/choices?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</p></figure><p id="e4f1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在我目前的工作中，我专业地使用<a class="ae ky" href="https://reactjs.org/" rel="noopener ugc nofollow" target="_blank"> React </a>，但是对于所有个人项目，我选择<a class="ae ky" href="https://vuejs.org/" rel="noopener ugc nofollow" target="_blank"> Vue </a>。这是我首选的框架。我在之前的上市公司中使用过Vue，它的扩展性非常好。</p><p id="893a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">任何经验丰富的开发人员都会告诉你，软件都是关于权衡取舍的，抛出“框架x比框架y更好”这样的客观陈述通常是没有意义的。用什么标准？在谁看来？出于这个原因，我将比较Vue，并对三个主要问题做出反应，这三个问题通常是相互竞争的权衡。</p><ol class=""><li id="e80c" class="lv lw it lb b lc ld lf lg li lx lm ly lq lz lu ma mb mc md bi translated">表演</li><li id="ced9" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated">可量测性</li><li id="3e6d" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated">工作市场</li></ol></div><div class="ab cl mj mk hx ml" role="separator"><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo"/></div><div class="im in io ip iq"><h1 id="78aa" class="mq mr it bd ms mt mu mv mw mx my mz na jz nb ka nc kc nd kd ne kf nf kg ng nh bi translated">表演</h1><p id="9706" class="pw-post-body-paragraph kz la it lb b lc ni ju le lf nj jx lh li nk lk ll lm nl lo lp lq nm ls lt lu im bi translated">当讨论框架或语言时，性能通常是人们想要开始的地方。每个写软件的人都在打造下一个FAANG公司，每一纳秒的性能都要从我们的代码中提取出来。</p><p id="92b0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我将从性能的两个方面比较这两个框架，即硅时间和碳时间。<em class="nn">芯片时间</em>指的是原始执行性能——它在浏览器中运行的速度。<em class="nn">碳时间</em>是指开发者在代码中构建产品的速度。</p><h2 id="a195" class="no mr it bd ms np nq dn mw nr ns dp na li nt nu nc lm nv nw ne lq nx ny ng nz bi translated">硅时间比较</h2><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi oa"><img src="../Images/272bd8c8b2db9c3f6f92a1a9aebc8b67.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*7mJ82zEHJdQY_giUkG4QlA.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">JS框架对性能的权衡</p></figure><p id="8a3f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">React <strong class="lb iu"> <em class="nn"> </em> </strong>利用了JSX，这给了开发人员很大的权力来构建任意复杂的逻辑。我们可以利用JavaScript的图灵完备能力，将视图视为数据。类似Svelte的东西利用了为视图层提供刚性结构的标记模板。</p><p id="9e6e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">React <strong class="lb iu"> <em class="nn"> </em> </strong>和Vue都使用一个<a class="ae ky" href="https://stackoverflow.com/questions/21965738/what-is-virtual-dom" rel="noopener ugc nofollow" target="_blank">虚拟DOM </a> (VDOM)，虽然实际上足够快，但固有的昂贵和<a class="ae ky" href="https://svelte.dev/blog/virtual-dom-is-pure-overhead" rel="noopener ugc nofollow" target="_blank">几乎纯粹的开销</a>。Svelte将模板代码编译成原始JS并直接操作DOM，这意味着它没有维护VDOM的性能开销。</p><p id="ea02" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我喜欢Vue <strong class="lb iu"> <em class="nn"> </em> </strong>的一点是它有点对冲赌注。使用Vue最常见的方法是在<a class="ae ky" href="https://vuejs.org/v2/guide/single-file-components.html" rel="noopener ugc nofollow" target="_blank">单文件组件</a>中使用模板。这使得Vue团队可以在即将到来的Vue 3版本中做一些非常聪明的事情，提前(AOT)进行优化。</p><p id="970f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">模板的结构化本质意味着编译器可以了解你的代码并执行优化。Vue引入的主要优化是删除VDOM差异中的所有静态数据。VDOM性能直接受到它必须跟踪的节点数量的影响。通过从这个VDOM差分过程中过滤掉静态数据，我们可以减少被跟踪的节点数量。这使得代码运行得更快，因为它不必在每个渲染周期比较任意节点的递归树。</p><p id="8225" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">虽然Vue看起来在大多数情况下使用模板，但编译器实际上在幕后为您将这些模板变成了<a class="ae ky" href="https://vuejs.org/v2/guide/render-function.html" rel="noopener ugc nofollow" target="_blank">渲染函数</a>。这意味着任何时候Vue的模板化妨碍了你，你可以直接下拉并编写渲染函数，就像在React <strong class="lb iu"> <em class="nn">中一样。</em> </strong>这意味着您可以获得渲染功能和JSX的所有灵活性，并从Svelte这样的模板化框架中获得一些<strong class="lb iu"> </strong>性能优势。显然，如果你写一个100%渲染的Vue应用程序，你会失去所有的模板优化。</p><p id="46de" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在我看来，代码基准测试有点浪费时间，但一些测试显示Vue 2比默认反应快2.5倍，Vue 3的基准测试比Vue 2快3-5倍。实际上，您使用的JS框架将是应用程序的一个很小的组件，这些基准几乎没有意义。然而，如果你构建的模板将利用Vue 3的AoT优化模板，那么同样的应用程序在React中是不可能写得更快的。</p><p id="0070" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu">获胜者:</strong> Vue</p><h2 id="7786" class="no mr it bd ms np nq dn mw nr ns dp na li nt nu nc lm nv nw ne lq nx ny ng nz bi translated">碳时间性能</h2><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ob"><img src="../Images/ad4b87e8b2ec54cae97d90282fca8667.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*HbtXKUXCUSlz5J5gqWdN5A.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">软件开发的碳成本与硅成本</p></figure><p id="832b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">一个高级开发人员将花费你大约150美元/小时，这取决于你在世界的哪个地方。即使是初级到中级的开发人员也挣得足够多的薪水，以至于你想把开发时间和成本考虑到你的技术堆栈中。这就是为什么PHP、Python、Node、Ruby等语言。非常受欢迎，我们不只是用c写所有的东西。</p><p id="62a5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">对于前端应用，我们受到浏览器、设备资源和网络延迟的限制，因此芯片性能仍然是一个影响因素，但碳性能也应该是任何首席技术官考虑的首要问题。</p><p id="d872" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在我看来，Vue成功的一个最大的贡献因素是它平易近人的文档、资源和简单易学。我同时学习了React和Vue，Vue显然更容易上手。如果你知道HTML、CSS和JS的基本知识，你可以用Vue构建一个应用程序。我花了半天时间和一个设计团队在一起，让他们在Vue中将更改发送到生产前端。这为开发团队腾出了大量时间，并允许设计人员实施A/B测试和设计更新，而不会受到软件积压的阻碍。</p><p id="0476" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我喜欢Vue的一点是它的选择加入工具的分层设计。可以从通过CDN拉入Vue开始。这意味着您可以使用它，而无需经历复杂的构建步骤(webpack/Babel config、npm等)。然后，您可以进入Vue CLI并构建基本应用程序。如果您需要状态管理解决方案，Vuex中有官方支持和记录的解决方案。同样，Vue路由器是官方认可和支持的Vue路由器解决方案。</p><p id="56a1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">另一方面，React引入了选择的<a class="ae ky" href="https://en.wikipedia.org/wiki/The_Paradox_of_Choice" rel="noopener ugc nofollow" target="_blank">悖论，</a>会给新来者造成困难。</p><p id="c9f4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">React是一个小范围、单一用途的库，它引入了一个接收道具并返回VDOM树的组件模型。这提供了很大的灵活性，React社区已经在这个简单的库之上构建了许多复杂的系统。</p><p id="2fef" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">有一个庞大的生态系统，有很多很多解决任务的选择。这些由用户独立维护。这种模型为人们提供了很多机会，可以在React之上构建东西，构建流行的库和工具。</p><p id="30c6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这也使得东西很难找到和学习。您不得不选择状态管理、路由或配置新应用程序的最佳选项。以我的经验来看，这也使得雇佣React开发者更加困难。当有多种方法做事情时，让新成员加入React项目比加入Vue项目会有更多的摩擦。</p><p id="e484" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu">获胜者:</strong> Vue</p></div><div class="ab cl mj mk hx ml" role="separator"><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo"/></div><div class="im in io ip iq"><h1 id="b821" class="mq mr it bd ms mt mu mv mw mx my mz na jz nb ka nc kc nd kd ne kf nf kg ng nh bi translated">可量测性</h1><p id="4307" class="pw-post-body-paragraph kz la it lb b lc ni ju le lf nj jx lh li nk lk ll lm nl lo lp lq nm ls lt lu im bi translated">我对这些框架可伸缩性的大部分想法在性能部分都有所涉及。可伸缩性通常与性能有着内在的联系，所以这并不奇怪。</p><p id="f7fa" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我通常从以下方面考虑可伸缩性:</p><h2 id="954d" class="no mr it bd ms np nq dn mw nr ns dp na li nt nu nc lm nv nw ne lq nx ny ng nz bi translated"><strong class="ak">扩展应用中视图/组件/工作流的数量</strong></h2><p id="fb5a" class="pw-post-body-paragraph kz la it lb b lc ni ju le lf nj jx lh li nk lk ll lm nl lo lp lq nm ls lt lu im bi translated">就扩展组件数量而言，我非常喜欢单文件组件(SFC)。组件的逻辑分组对我来说很有意义。许多人不同意这一点，这是一个观点而不是一个客观的说法。</p><p id="2e5b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我喜欢sfc的原因是因为它们提供了一种很好的方式来加强关注点的分离。<em class="nn"> </em>有些人认为混合HTML、CSS和JavaScript与分离关注点背道而驰。我已经改变了我在前端思考这个原则的方式，很大程度上是因为我痴迷于采用<a class="ae ky" href="https://tailwindcss.com/" rel="noopener ugc nofollow" target="_blank">的Tailwind CSS </a>来设计我的组件。</p><p id="5071" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">Adam Wathan写了一篇关于SoC的概念以及它如何应用于HTML和CSS的伟大文章。我以类似的方式思考我的前端组件。在我看来，组件就是它看起来如何(HTML/CSS) <em class="nn">和</em>如何工作。对我来说，将标记从JS中分离出来是武断的。如果你认为你的观点是数据，那么(对我来说)把它们和你的数据放在一起是有意义的。</p><p id="7ba2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">甚至不要让我开始谈论JSX和CSS-in-JS。HTML和CSS没有死。它们是网络不可思议的强大构件。使用它们！</p><p id="5e75" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">官方支持的常见问题解决方案的好处在大规模使用时也很方便。如果你在扩展一个Vue应用程序时遇到了困难，那么有可能任何其他的Vue应用程序都使用了相同的架构，你将能够找到建议和帮助。你不需要担心别人说“用钩子/<a class="ae ky" href="https://mobx.js.org/README.html" rel="noopener ugc nofollow" target="_blank">MobX</a>/<a class="ae ky" href="https://medium.com/p/9a4e0f01e064/edit" rel="noopener">Redux</a>/<a class="ae ky" href="https://redux-saga.js.org/" rel="noopener ugc nofollow" target="_blank">Redux-Saga</a>就行了。”</p><h2 id="414b" class="no mr it bd ms np nq dn mw nr ns dp na li nt nu nc lm nv nw ne lq nx ny ng nz bi translated"><strong class="ak">扩大团队中开发人员的数量</strong></h2><p id="61ed" class="pw-post-body-paragraph kz la it lb b lc ni ju le lf nj jx lh li nk lk ll lm nl lo lp lq nm ls lt lu im bi translated">我已经提到过，我曾经见过一个设计团队，在几个小时的帮助下，就可以将变更推向生产。对于任何面向消费者的应用程序来说，这都是一种疯狂的生产力提升。</p><p id="1e07" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">普遍的共识是Vue更容易学习，这也意味着你可以更快地培训初级开发人员，这对团队有好处。你也可以不费吹灰之力就搭载一个React开发者(假设他们懂HTML和CSS)。</p><p id="ac98" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">同样，对常见问题有一致的解决方案使得团队中的每个人更容易对大型代码库进行代码审查和推理。</p><p id="7e9f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这两者的关键是保持开发速度，同时保持满足用户需求的高性能应用程序。在我看来，Vue在这里达到了完美的平衡。</p><p id="af11" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu">获胜者:</strong> Vue</p></div><div class="ab cl mj mk hx ml" role="separator"><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo"/></div><div class="im in io ip iq"><h1 id="bc5b" class="mq mr it bd ms mt mu mv mw mx my mz na jz nb ka nc kc nd kd ne kf nf kg ng nh bi translated">就业市场</h1><p id="d976" class="pw-post-body-paragraph kz la it lb b lc ni ju le lf nj jx lh li nk lk ll lm nl lo lp lq nm ls lt lu im bi translated">好吧，我已经说服你Vue比React在每一个可以想象的方式。但如果你拿不到工资(或者找不到开发人员来雇佣)，这就没有意义了。</p><p id="aed2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">React在就业市场的份额要高得多(至少在澳大利亚和美国)。如果你在大部分的工作论坛上看到，相对于Vue来说，React的招聘数量是相当可观的(根据10秒钟的工作论坛搜索，React的招聘数量是我写这篇文章时的近8倍)。</p><p id="50f0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">虽然React似乎在这个指标上赢了，但我拒绝让React在棋盘上得分，所以我将提出以下(无懈可击的)论点。</p><p id="2a81" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">React和Vue在就业市场上都有机会。使用Vue或React的公司都发现很难招到人，而且，以我的经验来看，这两家公司都缺乏技能。作为一个正在找工作的人，你可以比使用React更快地掌握Vue。这意味着你将获得一条通往高薪的捷径。你在面试时的竞争也会更少，因为React仍然是许多开发者最受欢迎的选择，他们目前是沉没成本谬论的受害者。</p><p id="5d57" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">作为一家担心在当前市场上争夺人才的公司或招聘经理，Vue提供了一个机会，可以利用每种资源生产更多产品(Vue的碳时间优势)并培养自己的人才(更快的学习曲线)。在招聘时，为绿地项目或新的创业公司选择Vue可能是你做过的最好的决定。</p><p id="73eb" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">随着越来越多的公司意识到Vue的好处，我相信它将继续吞噬市场份额——甚至可能在未来取代React成为首选框架。</p><p id="5a04" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu">胜者:</strong>平局</p></div><div class="ab cl mj mk hx ml" role="separator"><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo"/></div><div class="im in io ip iq"><h1 id="e68d" class="mq mr it bd ms mt mu mv mw mx my mz na jz nb ka nc kc nd kd ne kf nf kg ng nh bi translated">结论和结束语</h1><p id="feef" class="pw-post-body-paragraph kz la it lb b lc ni ju le lf nj jx lh li nk lk ll lm nl lo lp lq nm ls lt lu im bi translated">这是一篇关于Vue的半开玩笑的文章，以及为什么我认为反应是最好的。我认为React是构建前端的一个非常合理的工具，我并不是说它不好。我只是相信Vue在框架设计上取得了更好的平衡。</p><p id="19d2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在以下情况下，我会选择React而不是Vue:</p><ul class=""><li id="51ef" class="lv lw it lb b lc ld lf lg li lx lm ly lq lz lu oc mb mc md bi translated">你想在使用React的地方工作，例如脸书</li><li id="0731" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu oc mb mc md bi translated">你有一个经验丰富的React开发团队</li><li id="034d" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu oc mb mc md bi translated">在你所在的地区雇佣React更容易</li></ul><p id="ad23" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">老实说，我不认为有任何一个技术原因让我选择React而不是Vue来开发我构建或工作的应用程序。这并不意味着一个不存在，但我只是没有遇到一个。</p><p id="d819" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">Svelte和Elm都是令人难以置信的有趣选项，我正在密切关注，但我不确定它们在这个时间点上对于大规模企业应用程序的可行性。</p><p id="f636" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果你想学习Vue，我强烈推荐<a class="ae ky" href="https://laracasts.com/series/learn-vue-2-step-by-step" rel="noopener ugc nofollow" target="_blank">这个由神奇的Jeffrey Way提供的免费课程</a>。</p></div></div>    
</body>
</html>