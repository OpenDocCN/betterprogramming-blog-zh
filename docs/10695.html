<html>
<head>
<title>Functional Error Handling in Flutter</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">颤振中的功能误差处理</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/functional-error-handling-in-flutter-ac6fcf8ae22b?source=collection_archive---------0-----------------------#2022-01-23">https://betterprogramming.pub/functional-error-handling-in-flutter-ac6fcf8ae22b?source=collection_archive---------0-----------------------#2022-01-23</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="2baf" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">更好、更安全的错误处理</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/42461ce3fd0ec391c915306ef538332b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ESeX6bKgZRv4V8FnGLfSmw.jpeg"/></div></div></figure><p id="6584" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">虽然函数式编程(FP)是一种在特定软件领域(编译器、涉及并行性、并发性、分布式计算等的程序)带来许多优势的编程范式，但我认为FP的一些元素在状态密集型应用程序中也非常有益。</p><p id="af5a" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">在我的第一篇博文中，我将重点介绍错误处理，并向您展示我如何使用FP错误处理来更干净、更安全地处理我的软件中的错误流。</p></div><div class="ab cl ln lo hu lp" role="separator"><span class="lq bw bk lr ls lt"/><span class="lq bw bk lr ls lt"/><span class="lq bw bk lr ls"/></div><div class="ij ik il im in"><h1 id="290b" class="lu lv iq bd lw lx ly lz ma mb mc md me jw mf jx mg jz mh ka mi kc mj kd mk ml bi translated">项目概述</h1><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi mm"><img src="../Images/9008acecfa6d97ac2960139cee80f202.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*EB2PMph2P735ZJBxQuni3g.jpeg"/></div></div></figure><p id="fe48" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">为了这篇文章，我创建了一个简单的应用程序(<a class="ae mn" href="https://github.com/mariopepe/medium_articles/tree/master/functional_error_handling" rel="noopener ugc nofollow" target="_blank">这里</a>是GitHub的链接)。这个应用程序从一个远程API <code class="fe mo mp mq mr b"><a class="ae mn" href="https://jsonplaceholder.typicode.com/posts" rel="noopener ugc nofollow" target="_blank">https://jsonplaceholder.typicode.com/posts</a></code>(对这个伟大的实用程序来说是巨大的大喊@typicode)获取一个帖子列表，并在一个列表中显示它们。如果出现任何错误，应用程序会在UI中正确地反映出来。</p><p id="41c7" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">示例应用程序的架构受到了干净架构(+存储库模式)原则的启发，并且为了目标的简单性，它确实被过度设计了，但是由于本文想要展示一种处理软件错误的高级方法，我认为拥有一个架构良好的示例应用程序更有意义(另外，我打算在以后的文章中重用它的一部分)。</p><p id="3393" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">示例应用程序的某些方面，如状态管理技术、密封类的使用、存储库模式等。超出了本文的范围，我现在也不会关注它们，但是我欢迎对所展示的软件的任何方面提出问题。</p><h1 id="bba0" class="lu lv iq bd lw lx ms lz ma mb mt md me jw mu jx mg jz mv ka mi kc mw kd mk ml bi translated">使用的库</h1><p id="d200" class="pw-post-body-paragraph kr ks iq kt b ku mx jr kw kx my ju kz la mz lc ld le na lg lh li nb lk ll lm ij bi translated">我将在这篇文章中使用的库是<code class="fe mo mp mq mr b"><a class="ae mn" href="https://pub.dev/packages/dartz" rel="noopener ugc nofollow" target="_blank">dartz</a></code>，它是<a class="ae mn" href="http://pub.dev" rel="noopener ugc nofollow" target="_blank"> pub.dev </a>上最受欢迎的FP包，有579个赞。</p><p id="c585" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">值得一提的是，在撰写本文时，在flutter生态系统中还存在另一个FP库，名为<a class="ae mn" href="https://pub.dev/packages/fpdart" rel="noopener ugc nofollow" target="_blank"> fpdart </a>，有143个赞。</p><h1 id="a899" class="lu lv iq bd lw lx ms lz ma mb mt md me jw mu jx mg jz mv ka mi kc mw kd mk ml bi translated">类型和折叠方法</h1><p id="a915" class="pw-post-body-paragraph kr ks iq kt b ku mx jr kw kx my ju kz la mz lc ld le na lg lh li nb lk ll lm ij bi translated">对于FP风格的错误处理，我发现使用定制类型<code class="fe mo mp mq mr b">Either&lt;Left, Right&gt;</code>和它包含的<code class="fe mo mp mq mr b">.fold()</code>方法特别有用。</p><p id="1479" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated"><code class="fe mo mp mq mr b">Either&lt;L, R&gt;</code>是一个特殊的数据类型，它可以包含两个不同的对象(<strong class="kt ir">而不是</strong>当代)，在我们的示例应用程序中，我们将有<code class="fe mo mp mq mr b">Either&lt;Failure, List&lt;Posts&gt;&gt;</code>，所以它要么包含失败细节(在左侧，这里通常存储错误)，要么包含一个帖子列表，在右侧。为了非常清楚，我重复一遍，自然地，不可能同时有左右两个对象，要么你发现你自己有你正在寻找的数据，要么有一个错误状态，而不是两者都有。</p><p id="f328" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">我们稍后将使用<code class="fe mo mp mq mr b">fold</code>函数根据变量中包含的值是<code class="fe mo mp mq mr b">Left</code>还是<code class="fe mo mp mq mr b">Right</code>来执行不同的动作，例如，我们将有:</p><pre class="kg kh ki kj gt nc mr nd ne aw nf bi"><span id="8aff" class="ng lv iq mr b gy nh ni l nj nk">// We connect with the API trying to get some value<br/>final Either&lt;Failure, List&lt;Post&gt;&gt; postsEither = await postsRepository.fetchPosts();</span><span id="db12" class="ng lv iq mr b gy nl ni l nj nk">postsEither.fold(<br/>  // If any error happened, we will emit a Failure state<br/>  (failure) =&gt; emit(PostsListState.loadFailure(failure)),<br/></span><span id="0ce8" class="ng lv iq mr b gy nl ni l nj nk">  // If we managed to retrieve the data from the API, the bloc will emit a success state<br/>  (postsList) =&gt; emit(PostsListState.loadSuccess(postsList)),<br/>);</span></pre><h1 id="920d" class="lu lv iq bd lw lx ms lz ma mb mt md me jw mu jx mg jz mv ka mi kc mw kd mk ml bi translated">项目文件夹结构</h1><pre class="kg kh ki kj gt nc mr nd ne aw nf bi"><span id="984d" class="ng lv iq mr b gy nh ni l nj nk">.<br/>├── lib/<br/>│   ├── core/<br/>│   │   ├── error_handling/<br/>│   │   │   ├── error_object.dart<br/>│   │   │   ├── exceptions.dart<br/>│   │   │   └── failures.dart<br/>│   │   └── presentation/text_styles.dart<br/>│   └── features/<br/>│       └── post/<br/>│           ├── data/<br/>│           │   ├── datasource/json_placholder_v1.dart<br/>│           │   ├── models/post_model.dart<br/>│           │   └── repositories_impl/posts_repository_impl.dart<br/>│           ├── domain/<br/>│           │   ├── entities/post_entity.dart<br/>│           │   └── repositories/post_repository.dart<br/>│           └── presentation/<br/>│               ├── bloc/posts_list_bloc.dart<br/>│               ├── widgets/<br/>│               │   ├── custom_list_tile.dart<br/>│               │   └── error_dialog.dart<br/>│               └── posts_list_page.dart<br/>└── main.dart</span></pre><p id="6106" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">与功能性错误处理主题最相关的文件是:</p><ul class=""><li id="5f0d" class="nm nn iq kt b ku kv kx ky la no le np li nq lm nr ns nt nu bi translated">(folder) <code class="fe mo mp mq mr b">"error_handling"</code>，这里我定义了定制的异常和失败对象，以及一个名为ErrorObject的类，我将在UI中使用它将失败转换成对用户有意义的消息。</li><li id="d701" class="nm nn iq kt b ku nv kx nw la nx le ny li nz lm nr ns nt nu bi translated">(file) <code class="fe mo mp mq mr b">“json_placholder_v1.dart”</code>，是JSON占位符API连接的实际实现，这个应用程序的最外层。我们只在这一层接受<code class="fe mo mp mq mr b">Exceptions</code>。从这一层到存储库实现层，异常(不纯的应用程序状态)被转换为失败(纯状态)。</li><li id="9fd1" class="nm nn iq kt b ku nv kx nw la nx le ny li nz lm nr ns nt nu bi translated">【文件】(T8)，这里发生了异常→转换失败</li><li id="13a1" class="nm nn iq kt b ku nv kx nw la nx le ny li nz lm nr ns nt nu bi translated">(file) <code class="fe mo mp mq mr b">“posts_list_bloc.dart”</code>，最后但同样重要的是，这是借助于<code class="fe mo mp mq mr b">fold()</code>方法，我们根据API交互的结果是成功还是错误发出不同状态的地方。</li></ul></div><div class="ab cl ln lo hu lp" role="separator"><span class="lq bw bk lr ls lt"/><span class="lq bw bk lr ls lt"/><span class="lq bw bk lr ls"/></div><div class="ij ik il im in"><h1 id="8ebe" class="lu lv iq bd lw lx ly lz ma mb mc md me jw mf jx mg jz mh ka mi kc mj kd mk ml bi translated">履行</h1><h2 id="3742" class="ng lv iq bd lw oa ob dn ma oc od dp me la oe of mg le og oh mi li oi oj mk ok bi translated">1-例外</h2><p id="aca5" class="pw-post-body-paragraph kr ks iq kt b ku mx jr kw kx my ju kz la mz lc ld le na lg lh li nb lk ll lm ij bi translated">我们在<code class="fe mo mp mq mr b">lib/core/error_handling/exceptions.dart</code>中定义了我们的自定义异常。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ol om l"/></div></figure><h2 id="b23e" class="ng lv iq bd lw oa ob dn ma oc od dp me la oe of mg le og oh mi li oi oj mk ok bi translated">2 —失败</h2><p id="69c0" class="pw-post-body-paragraph kr ks iq kt b ku mx jr kw kx my ju kz la mz lc ld le na lg lh li nb lk ll lm ij bi translated">我们定义了与之前在<code class="fe mo mp mq mr b">‘lib/core/error_handling/failures.dart’</code>中创建的3个异常相关的3个故障实体。故障实体包括:</p><ul class=""><li id="3672" class="nm nn iq kt b ku kv kx ky la no le np li nq lm nr ns nt nu bi translated"><code class="fe mo mp mq mr b">ServerFailure</code></li><li id="2389" class="nm nn iq kt b ku nv kx nw la nx le ny li nz lm nr ns nt nu bi translated"><code class="fe mo mp mq mr b">DataParsingFailure</code></li><li id="27f4" class="nm nn iq kt b ku nv kx nw la nx le ny li nz lm nr ns nt nu bi translated"><code class="fe mo mp mq mr b">NoConnectionFailure</code></li></ul><p id="6eb7" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">当然，这是所有可能错误的简单表示，但它是呈现本文核心概念的合理代理。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ol om l"/></div></figure><p id="bb31" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated"><em class="on">(我使用</em> <code class="fe mo mp mq mr b"><em class="on">freezed</em></code> <em class="on">，但为了这个练习，这肯定是不需要的)</em></p><h2 id="d46d" class="ng lv iq bd lw oa ob dn ma oc od dp me la oe of mg le og oh mi li oi oj mk ok bi translated">3-错误对象</h2><p id="86c7" class="pw-post-body-paragraph kr ks iq kt b ku mx jr kw kx my ju kz la mz lc ld le na lg lh li nb lk ll lm ij bi translated">我们在<code class="fe mo mp mq mr b">‘lib/core/error_handling/error_object.dart’</code>中定义了一个<code class="fe mo mp mq mr b">ErrorObject</code>。<code class="fe mo mp mq mr b">ErrorObject</code>是一个实用程序类，用于将失败转换成可由用户界面表示的对象(例如，它包含用户可读的错误标题和错误消息)。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ol om l"/></div></figure><h2 id="2bb7" class="ng lv iq bd lw oa ob dn ma oc od dp me la oe of mg le og oh mi li oi oj mk ok bi translated">4 — API集成</h2><p id="17fc" class="pw-post-body-paragraph kr ks iq kt b ku mx jr kw kx my ju kz la mz lc ld le na lg lh li nb lk ll lm ij bi translated">我们在<code class="fe mo mp mq mr b">‘lib/features/post/data/datasources/json_placholder_v1.dart’</code>中创建了与JSON占位符API的连接，并基于不同的可能错误抛出了之前定义的适当的定制异常。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ol om l"/></div></figure><h2 id="d445" class="ng lv iq bd lw oa ob dn ma oc od dp me la oe of mg le og oh mi li oi oj mk ok bi translated">5 —异常→故障</h2><p id="2a6a" class="pw-post-body-paragraph kr ks iq kt b ku mx jr kw kx my ju kz la mz lc ld le na lg lh li nb lk ll lm ij bi translated">在<code class="fe mo mp mq mr b">‘lib/features/post/data/repositories_impl/posts_repository_impl.dart’ </code>中，我们将异常(不纯状态)转换为失败对象(纯状态)，我们要么在任一对象的右侧返回一个帖子列表，要么如我们所说，在左侧返回一个失败。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ol om l"/></div></figure><h2 id="5789" class="ng lv iq bd lw oa ob dn ma oc od dp me la oe of mg le og oh mi li oi oj mk ok bi translated">6 —任一种的折叠</h2><p id="bb3b" class="pw-post-body-paragraph kr ks iq kt b ku mx jr kw kx my ju kz la mz lc ld le na lg lh li nb lk ll lm ij bi translated">最后，我们在<code class="fe mo mp mq mr b">‘lib/features/post/presentation/bloc/posts_list.dart’</code>解包块中的任一对象，并根据需要发出不同的状态。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ol om l"/></div></figure><h2 id="591a" class="ng lv iq bd lw oa ob dn ma oc od dp me la oe of mg le og oh mi li oi oj mk ok bi translated">7-用户界面表示</h2><p id="7aa9" class="pw-post-body-paragraph kr ks iq kt b ku mx jr kw kx my ju kz la mz lc ld le na lg lh li nb lk ll lm ij bi translated">所有这一切的UI结果在<code class="fe mo mp mq mr b">‘lib/features/post/presentation/posts_list_page.dart’</code>中可以观察到，通过使用冻结的密封类，块产生的每个可能的状态都被映射到不同的UI表示中。</p><p id="0f52" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">密封类非常强大，有许多应用，我打算在以后的文章中详细介绍。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ol om l"/></div></figure></div><div class="ab cl ln lo hu lp" role="separator"><span class="lq bw bk lr ls lt"/><span class="lq bw bk lr ls lt"/><span class="lq bw bk lr ls"/></div><div class="ij ik il im in"><h1 id="d6d3" class="lu lv iq bd lw lx ly lz ma mb mc md me jw mf jx mg jz mh ka mi kc mj kd mk ml bi translated">结论</h1><p id="4390" class="pw-post-body-paragraph kr ks iq kt b ku mx jr kw kx my ju kz la mz lc ld le na lg lh li nb lk ll lm ij bi translated">在进行错误处理时，我们有两个主要的目标:</p><ul class=""><li id="891d" class="nm nn iq kt b ku kv kx ky la no le np li nq lm nr ns nt nu bi translated">确保每一个错误状态都在用户界面中被恰当地呈现出来，以告知用户正在发生的事情(也就是说，我们必须向用户呈现真正有意义的对话框)。事实上，最糟糕的用户体验莫过于那些对用户不清晰、不透明的内容。</li><li id="1adc" class="nm nn iq kt b ku nv kx nw la nx le ny li nz lm nr ns nt nu bi translated">确保每个异常都被正确捕获和处理。生产代码中自由流动的异常意味着应用程序崩溃，这反过来是可怕的UX，这反过来对业务非常不利。</li></ul><p id="7b10" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">我希望在本文中，我成功地展示了函数式编程如何极大地帮助我们实现这些目标，因为它迫使我们思考可能的应用程序状态，并主动管理它们。</p><p id="0e2a" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">为了让事情变得更清楚，考虑一下这个:当我们想要访问文章列表时，我们必须调用<code class="fe mo mp mq mr b">fold()</code>方法，我们必须为左右两种情况都提供适当的动作，否则代码将无法编译，我认为这是一种非常安全的处理错误的方法！</p><p id="eed7" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">非常感谢你阅读到这里，如果你有任何问题，建议或者你会做任何不同的事情，请告诉我！</p><div class="oo op gp gr oq or"><a href="https://github.com/mariopepe/medium_articles/tree/master/functional_error_handling" rel="noopener  ugc nofollow" target="_blank"><div class="os ab fo"><div class="ot ab ou cl cj ov"><h2 class="bd ir gy z fp ow fr fs ox fu fw ip bi translated">medium _ articles/functional _ error _ master Mario pee/medium _ articles的处理</h2><div class="oy l"><h3 class="bd b gy z fp ow fr fs ox fu fw dk translated">一个新的颤振项目。这个项目是颤振应用的起点。一些帮助您入门的资源…</h3></div><div class="oz l"><p class="bd b dl z fp ow fr fs ox fu fw dk translated">github.com</p></div></div><div class="pa l"><div class="pb l pc pd pe pa pf kp or"/></div></div></a></div></div></div>    
</body>
</html>