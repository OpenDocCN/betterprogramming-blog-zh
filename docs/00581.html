<html>
<head>
<title>Uploading Files in React While Keeping The UI Completely In Sync</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Good quality, quality assurance</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/keep-your-users-constantly-occupied-ff8ba0b0e673?source=collection_archive---------4-----------------------#2019-06-13">https://betterprogramming.pub/keep-your-users-constantly-occupied-ff8ba0b0e673?source=collection_archive---------4-----------------------#2019-06-13</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><h2 id="0929" class="ir is it bd b dl iu iv iw ix iy iz dk ja translated" aria-label="kicker paragraph">现在，当它完成时，进入目录:</h2><div class=""/><div class=""><h2 id="66ad" class="pw-subtitle-paragraph jz jc it bd b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq dk translated">我们要做的第一件事是打开<code class="fe my mz na nb b">App.js</code>，用我们自己的实现替换默认代码:</h2></div><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi kr"><img src="../Images/94065134a61475c40d5c2d9cd4b80795.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*VCNG2x1xSa9XhuFy-SUFPA.jpeg"/></div></div></figure><p id="9d3a" class="pw-post-body-paragraph ld le it lf b lg lh kd li lj lk kg ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated"><code class="fe my mz na nb b"><em class="it">src/App.js</em></code></p><p id="8999" class="pw-post-body-paragraph ld le it lf b lg lh kd li lj lk kg ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated">这里我们定义了一个<code class="fe my mz na nb b">form</code>元素，并传入了一个<code class="fe my mz na nb b">onSubmit</code>处理程序，这样一旦用户点击提交，我们就可以访问用户选择的所有文件。</p><p id="9da6" class="pw-post-body-paragraph ld le it lf b lg lh kd li lj lk kg ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated">在表单内部，我们定义了文件输入组件，它将允许用户选择他们的任何文件。输入接受一个<code class="fe my mz na nb b">onChange</code>处理程序，所以我们也把它传入。onChange处理程序将能够通过访问第一个参数中的<code class="fe my mz na nb b">e.target.files</code>来接收文件。</p><p id="eb41" class="pw-post-body-paragraph ld le it lf b lg lh kd li lj lk kg ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated">我在<code class="fe my mz na nb b">App.css</code>里面应用了一些基本的样式。您可以选择使用它们或跳过这一步:</p><p id="3094" class="pw-post-body-paragraph ld le it lf b lg lh kd li lj lk kg ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated"><code class="fe my mz na nb b"><em class="it">App.css</em></code></p><p id="8f1e" class="pw-post-body-paragraph ld le it lf b lg lh kd li lj lk kg ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated">因此，我们已经建立了一个基本组件，并在适当的位置设置了处理程序。我们现在要创建一个自定义的react挂钩，这样我们就可以将所有脏状态逻辑放在里面——远离UI组件。</p><h1 id="3efe" class="mb mc it bd md me mf mg mh mi mj mk ml ki mm kj mn kl mo km mp ko mq kp mr ms bi translated">我要把这个叫做<code class="fe my mz na nb b">useFileHandlers.js</code>:</h1><p id="4bc2" class="pw-post-body-paragraph ld le it lf b lg mt kd li lj mu kg ll lm mv lo lp lq mw ls lt lu mx lw lx ly im bi translated"><code class="fe my mz na nb b"><em class="it">src/useFileHandlers.js</em></code></p><p id="2123" class="pw-post-body-paragraph ld le it lf b lg lh kd li lj lk kg ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated">整篇文章中最重要的部分可能是上面显示的<code class="fe my mz na nb b">initialState</code>。这将允许用户界面进入文件上传过程的每一个瞬间。</p><p id="c34f" class="pw-post-body-paragraph ld le it lf b lg lh kd li lj lk kg ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated"><code class="fe my mz na nb b">files</code>是用户最初通过从文件输入中选择文件来加载一个<em class="lz">数组</em>的地方。</p><p id="c04b" class="pw-post-body-paragraph ld le it lf b lg lh kd li lj lk kg ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated"><code class="fe my mz na nb b">pending</code>将用于让UI知道<em class="lz">当前正在处理什么</em>文件，以及还有多少<em class="lz">文件剩余。</em></p><pre class="ks kt ku kv gt nc nb nd ne aw nf bi"><span id="4cbc" class="ng mc it nb b gy nh ni l nj nk">npx create-react-app file-upload-with-ux</span></pre><p id="c850" class="pw-post-body-paragraph ld le it lf b lg lh kd li lj lk kg ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated">当代码检测到准备就绪时，<code class="fe my mz na nb b">next</code>将被分配给<em class="lz">待定</em>数组中的下一项。</p><pre class="ks kt ku kv gt nc nb nd ne aw nf bi"><span id="508e" class="ng mc it nb b gy nh ni l nj nk">cd file-upload-with-ux</span></pre><p id="b7a6" class="pw-post-body-paragraph ld le it lf b lg lh kd li lj lk kg ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated"><code class="fe my mz na nb b">uploading</code>将用于代码，以了解文件仍在上传。</p><blockquote class="nl nm nn"><p id="4323" class="ld le lz lf b lg lh kd li lj lk kg ll no ln lo lp np lr ls lt nq lv lw lx ly im bi translated"><code class="fe my mz na nb b">uploaded</code>将是文件上传完成后我们插入的对象。</p></blockquote><figure class="ks kt ku kv gt kw"><div class="bz fp l di"><div class="nr ns l"/></div></figure><p id="0c1d" class="pw-post-body-paragraph ld le it lf b lg lh kd li lj lk kg ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated">最后，<code class="fe my mz na nb b">status</code>是作为额外的便利提供的，主要供<em class="lz">用户</em> <code class="fe my mz na nb b">interface</code>利用其优势。</p><p id="e07d" class="pw-post-body-paragraph ld le it lf b lg lh kd li lj lk kg ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated">我们将使用react的<code class="fe my mz na nb b">useReducer</code> hook api，因为它非常适合我们的使用。</p><p id="1837" class="pw-post-body-paragraph ld le it lf b lg lh kd li lj lk kg ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated">但是首先，让我们在<code class="fe my mz na nb b">useFileHandlers</code>钩子上定义一些常量，这样我们可以确保以后在应用状态更新时不会输入错误:</p><blockquote class="nl nm nn"><p id="6ef1" class="ld le lz lf b lg lh kd li lj lk kg ll no ln lo lp np lr ls lt nq lv lw lx ly im bi translated"><code class="fe my mz na nb b"><em class="it">src/useFileHandlers.js</em></code></p></blockquote><figure class="ks kt ku kv gt kw"><div class="bz fp l di"><div class="nr ns l"/></div></figure><p id="f116" class="pw-post-body-paragraph ld le it lf b lg lh kd li lj lk kg ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated">这些将进入作为第一个参数传递给<code class="fe my mz na nb b">useReducer</code>的<em class="lz">缩减器</em>。</p><p id="41c5" class="pw-post-body-paragraph ld le it lf b lg lh kd li lj lk kg ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated">现在定义减速器:</p><blockquote class="nl nm nn"><p id="5cce" class="ld le lz lf b lg lh kd li lj lk kg ll no ln lo lp np lr ls lt nq lv lw lx ly im bi translated"><code class="fe my mz na nb b"><em class="it">src/useFileHandlers.js</em></code></p></blockquote><figure class="ks kt ku kv gt kw"><div class="bz fp l di"><div class="nr ns l"/></div></figure><p id="05df" class="pw-post-body-paragraph ld le it lf b lg lh kd li lj lk kg ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated">我们也许不应该忘记从react now进口<code class="fe my mz na nb b">useReducer</code>，嗯？</p><p id="188c" class="pw-post-body-paragraph ld le it lf b lg lh kd li lj lk kg ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated"><code class="fe my mz na nb b"><em class="it">src/useFileHandlers.js</em></code></p><p id="4024" class="pw-post-body-paragraph ld le it lf b lg lh kd li lj lk kg ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated">现在将状态/调度API定义到钩子中:</p><p id="ab64" class="pw-post-body-paragraph ld le it lf b lg lh kd li lj lk kg ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated"><code class="fe my mz na nb b"><em class="it">src/useFileHandlers.js</em></code></p><p id="4209" class="pw-post-body-paragraph ld le it lf b lg lh kd li lj lk kg ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated">现在我们将回到我们之前设置的<code class="fe my mz na nb b">onChange</code>实现，并进一步增强它。</p><p id="cfa9" class="pw-post-body-paragraph ld le it lf b lg lh kd li lj lk kg ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated">在此之前，让我们在减速器中添加一个新的开关盒:</p><p id="1e58" class="pw-post-body-paragraph ld le it lf b lg lh kd li lj lk kg ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated"><code class="fe my mz na nb b"><em class="it">src/useFileHandlers.js</em></code></p><p id="5ca6" class="pw-post-body-paragraph ld le it lf b lg lh kd li lj lk kg ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated">这将允许<code class="fe my mz na nb b">onChange</code>处理程序一调用就将文件传递到状态:</p><p id="efe9" class="pw-post-body-paragraph ld le it lf b lg lh kd li lj lk kg ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated"><code class="fe my mz na nb b"><em class="it">src/useFileHandlers.js</em></code></p><blockquote class="nl nm nn"><p id="def9" class="ld le lz lf b lg lh kd li lj lk kg ll no ln lo lp np lr ls lt nq lv lw lx ly im bi translated">这里需要注意的是，当我们从事件对象中检索时，<code class="fe my mz na nb b">e.target.files</code>不是一个数组，而是一个<a class="ae ma" href="https://developer.mozilla.org/en-US/docs/Web/API/FileList" rel="noopener ugc nofollow" target="_blank">文件列表</a>。</p></blockquote><pre class="ks kt ku kv gt nc nb nd ne aw nf bi"><span id="1aa9" class="ng mc it nb b gy nh ni l nj nk">const LOADED = 'LOADED'<br/>const INIT = 'INIT'<br/>const PENDING = 'PENDING'<br/>const FILES_UPLOADED = 'FILES_UPLOADED'<br/>const UPLOAD_ERROR = 'UPLOAD_ERROR'</span></pre><p id="a4d7" class="pw-post-body-paragraph ld le it lf b lg lh kd li lj lk kg ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated">我们将它转换为数组的原因是为了让UI组件可以映射到数组上，并显示有用的信息，如文件大小和文件类型。否则，组件会使试图映射到<code class="fe my mz na nb b"><em class="lz">FileLists</em></code>的应用崩溃。</p><p id="c5b1" class="pw-post-body-paragraph ld le it lf b lg lh kd li lj lk kg ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated">到目前为止，这里是我们的定制钩子的完整实现:</p><blockquote class="nl nm nn"><p id="48aa" class="ld le lz lf b lg lh kd li lj lk kg ll no ln lo lp np lr ls lt nq lv lw lx ly im bi translated"><code class="fe my mz na nb b"><em class="it">src/useFileHandlers.js</em></code></p></blockquote><pre class="ks kt ku kv gt nc nb nd ne aw nf bi"><span id="1744" class="ng mc it nb b gy nh ni l nj nk">const reducer = (state, action) =&gt; {<br/>  switch (action.type) {<br/>    default:<br/>      return state<br/>  }<br/>}</span></pre><p id="89c1" class="pw-post-body-paragraph ld le it lf b lg lh kd li lj lk kg ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated">现在我们将关注另一个处理程序— <code class="fe my mz na nb b">onSubmit</code>。这在用户提交表单时调用(很明显)。在<code class="fe my mz na nb b">onSubmit</code>处理程序中，我们用一个<code class="fe my mz na nb b"><a class="ae ma" href="https://reactjs.org/docs/hooks-reference.html#usecallback" rel="noopener ugc nofollow" target="_blank">useCallback</a></code>包装它，这样它将总是获得最新的状态值。</p><blockquote class="nl nm nn"><p id="7ef1" class="ld le lz lf b lg lh kd li lj lk kg ll no ln lo lp np lr ls lt nq lv lw lx ly im bi translated"><code class="fe my mz na nb b"><em class="it">src/useFileHandlers.js</em></code></p></blockquote><pre class="ks kt ku kv gt nc nb nd ne aw nf bi"><span id="2970" class="ng mc it nb b gy nh ni l nj nk">import { useReducer } from 'react'</span></pre><p id="29e6" class="pw-post-body-paragraph ld le it lf b lg lh kd li lj lk kg ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated"><code class="fe my mz na nb b"><em class="it">src/useFileHandlers.js</em></code></p><blockquote class="nl nm nn"><p id="f9d1" class="ld le lz lf b lg lh kd li lj lk kg ll no ln lo lp np lr ls lt nq lv lw lx ly im bi translated">这个onSubmit处理程序在 <code class="fe my mz na nb b">onChange</code>之后调用<em class="lz">，所以它可以从刚刚由<code class="fe my mz na nb b">onChange</code>设置的<code class="fe my mz na nb b">state.files</code>中拉入文件，以实例化上传过程。</em></p></blockquote><pre class="ks kt ku kv gt nc nb nd ne aw nf bi"><span id="8aa2" class="ng mc it nb b gy nh ni l nj nk">const useFileHandlers = () =&gt; {<br/>  const [state, dispatch] = useReducer(reducer, initialState)</span><span id="2ee8" class="ng mc it nb b gy nt ni l nj nk">  return {}<br/>}</span><span id="6c1f" class="ng mc it nb b gy nt ni l nj nk">export default useFileHandlers</span></pre><p id="7e87" class="pw-post-body-paragraph ld le it lf b lg lh kd li lj lk kg ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated">为了实例化上传过程，我们需要另一个开关案例:</p><p id="43d4" class="pw-post-body-paragraph ld le it lf b lg lh kd li lj lk kg ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated"><code class="fe my mz na nb b"><em class="it">src/useFileHandlers.js</em></code></p><blockquote class="nl nm nn"><p id="52e0" class="ld le lz lf b lg lh kd li lj lk kg ll no ln lo lp np lr ls lt nq lv lw lx ly im bi translated">好吧，现在事情是这样的:</p></blockquote><pre class="ks kt ku kv gt nc nb nd ne aw nf bi"><span id="dca6" class="ng mc it nb b gy nh ni l nj nk">const reducer = (state, action) =&gt; {<br/>  switch (action.type) {<br/>    case 'load':<br/>      return { ...state, files: action.files, status: LOADED }<br/>    default:<br/>      return state<br/>  }<br/>}</span></pre><p id="7ef3" class="pw-post-body-paragraph ld le it lf b lg lh kd li lj lk kg ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated">它将<code class="fe my mz na nb b">state.uploading</code>变为<code class="fe my mz na nb b">true</code>。当您将<code class="fe my mz na nb b">state.uploading</code>改为<code class="fe my mz na nb b">true</code>时，您可以开始破坏UI组件，并向用户显示您想要的任何内容，只要他们明白您试图向他们传达文件正在上传的信息。</p><blockquote class="nl nm nn"><p id="f25e" class="ld le lz lf b lg lh kd li lj lk kg ll no ln lo lp np lr ls lt nq lv lw lx ly im bi translated">它用用户选择的所有文件启动<code class="fe my mz na nb b">state.pending</code>。您也可以用它来破坏UI组件。使用这部分状态的方法非常多。但是现在，我将跳过这一部分，因为我想先和你一起完成整个教程。</p></blockquote><pre class="ks kt ku kv gt nc nb nd ne aw nf bi"><span id="8d9e" class="ng mc it nb b gy nh ni l nj nk">const onChange = (e) =&gt; {<br/>  if (e.target.files.length) {<br/>    const arrFiles = Array.from(e.target.files)<br/>    const files = arrFiles.map((file, index) =&gt; {<br/>      const src = window.URL.createObjectURL(file)<br/>      return { file, id: index, src }<br/>    })<br/>    dispatch({ type: 'load', files })<br/>  }<br/>}</span></pre><p id="1ff6" class="pw-post-body-paragraph ld le it lf b lg lh kd li lj lk kg ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated">它将状态的便利部分<code class="fe my mz na nb b">status</code>设置为<code class="fe my mz na nb b">“INIT”</code>。您也可以在钩子或UI中的某个地方使用它来触发一些<code class="fe my mz na nb b">onStart </code>逻辑，或者您想要的任何东西——因为它不会返回到这个值，直到一个新的上传过程开始。</p><p id="3962" class="pw-post-body-paragraph ld le it lf b lg lh kd li lj lk kg ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated">现在我们将返回状态以及<code class="fe my mz na nb b">onSubmit</code>和<code class="fe my mz na nb b">onChange</code>处理程序，以便UI可以愉快地访问它们:</p><p id="c5c3" class="pw-post-body-paragraph ld le it lf b lg lh kd li lj lk kg ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated"><code class="fe my mz na nb b"><em class="it">src/useFileHandlers.js</em></code></p><blockquote class="nl nm nn"><p id="3896" class="ld le lz lf b lg lh kd li lj lk kg ll no ln lo lp np lr ls lt nq lv lw lx ly im bi translated"><code class="fe my mz na nb b"><em class="it">src/useFileHandlers.js</em></code></p></blockquote><figure class="ks kt ku kv gt kw"><div class="bz fp l di"><div class="nr ns l"/></div></figure><p id="b6b8" class="pw-post-body-paragraph ld le it lf b lg lh kd li lj lk kg ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated">接下来我们要解决的是<code class="fe my mz na nb b">useEffect</code>部分。我们需要<code class="fe my mz na nb b">useEffect</code>来促进“运行到完成”的功能。</p><blockquote class="nl nm nn"><p id="5165" class="ld le lz lf b lg lh kd li lj lk kg ll no ln lo lp np lr ls lt nq lv lw lx ly im bi translated">这些useEffects在本教程中是一个非常重要的实现，因为它们在UI和定制钩子之间创建了一个完美的、一致的同步流— <em class="lz">无处不在</em>,稍后您将会看到。</p></blockquote><pre class="ks kt ku kv gt nc nb nd ne aw nf bi"><span id="1b45" class="ng mc it nb b gy nh ni l nj nk">import { useCallback, useReducer } from 'react'</span></pre><blockquote class="nl nm nn"><p id="78f2" class="ld le lz lf b lg lh kd li lj lk kg ll no ln lo lp np lr ls lt nq lv lw lx ly im bi translated"><code class="fe my mz na nb b"><em class="it">src/useFileHandlers.js</em></code></p></blockquote><pre class="ks kt ku kv gt nc nb nd ne aw nf bi"><span id="f923" class="ng mc it nb b gy nh ni l nj nk">const onSubmit = useCallback(<br/>  (e) =&gt; {<br/>    e.preventDefault()<br/>    if (state.files.length) {<br/>      dispatch({ type: 'submit' })<br/>    } else {<br/>      window.alert("You don't have any files loaded.")<br/>    }<br/>  },<br/>  [state.files.length],<br/>)</span></pre><p id="42fc" class="pw-post-body-paragraph ld le it lf b lg lh kd li lj lk kg ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated">我们将定义我们的第一个<em class="lz"> </em> <code class="fe my mz na nb b">useEffect</code>，它将负责在检测到准备好上传下一个文件时(只要<code class="fe my mz na nb b">state.pending</code>中仍有项目)促进该文件的上传:</p><p id="87ce" class="pw-post-body-paragraph ld le it lf b lg lh kd li lj lk kg ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated"><code class="fe my mz na nb b"><em class="it">src/useFileHandlers.js</em></code></p><blockquote class="nl nm nn"><p id="5e07" class="ld le lz lf b lg lh kd li lj lk kg ll no ln lo lp np lr ls lt nq lv lw lx ly im bi translated">它抓取<code class="fe my mz na nb b">state.pending</code>数组中的下一个可用文件，并使用<code class="fe my mz na nb b">dispatch</code>创建一个信号，将该文件作为下一个<code class="fe my mz na nb b">state.next</code>对象发送:</p></blockquote><pre class="ks kt ku kv gt nc nb nd ne aw nf bi"><span id="3f1c" class="ng mc it nb b gy nh ni l nj nk">const reducer = (state, action) =&gt; {<br/>  switch (action.type) {<br/>    case 'load':<br/>      return { ...state, files: action.files, status: LOADED }<br/>    case 'submit':<br/>      return { ...state, uploading: true, pending: state.files, status: INIT }<br/>    default:<br/>      return state<br/>  }<br/>}</span></pre><p id="3062" class="pw-post-body-paragraph ld le it lf b lg lh kd li lj lk kg ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated"><code class="fe my mz na nb b"><em class="it">src/useFileHandlers.js</em></code></p><ol class=""><li id="46c8" class="nu nv it lf b lg lh lj lk lm nw lq nx lu ny ly nz oa ob oc bi translated">我们在这里又加了一个<code class="fe my mz na nb b">status: PENDING</code>作为方便。然而，你选择处理上传过程的这一部分完全取决于你！</li><li id="c4f7" class="nu nv it lf b lg od lj oe lm of lq og lu oh ly nz oa ob oc bi translated">下一个代码片段将展示一个实用函数，我提供这个函数只是为了帮助你登录到控制台，只是为了这个教程。</li><li id="12bb" class="nu nv it lf b lg od lj oe lm of lq og lu oh ly nz oa ob oc bi translated"><code class="fe my mz na nb b"><em class="it">src/useFileHandlers.js</em></code></li></ol><p id="efdb" class="pw-post-body-paragraph ld le it lf b lg lh kd li lj lk kg ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated">我们接下来要应用的第二个<em class="lz"> </em> <code class="fe my mz na nb b">useEffect</code>将负责<em class="lz">上传</em>刚刚设置好状态的<code class="fe my mz na nb b">next</code>文件:</p><blockquote class="nl nm nn"><p id="a97f" class="ld le lz lf b lg lh kd li lj lk kg ll no ln lo lp np lr ls lt nq lv lw lx ly im bi translated"><code class="fe my mz na nb b"><em class="it">src/useFileHandlers.js</em></code></p></blockquote><pre class="ks kt ku kv gt nc nb nd ne aw nf bi"><span id="1f67" class="ng mc it nb b gy nh ni l nj nk">return {<br/>  ...state,<br/>  onSubmit,<br/>  onChange,<br/>}</span></pre><blockquote class="nl nm nn"><p id="a398" class="ld le lz lf b lg lh kd li lj lk kg ll no ln lo lp np lr ls lt nq lv lw lx ly im bi translated">在<code class="fe my mz na nb b">.then()</code>处理程序中，我创建了一个新变量<code class="fe my mz na nb b">prev</code>，并赋予它完成上传的<code class="fe my mz na nb b">next</code>对象。这只是为了可读性，因为我们不想在开关的情况下混淆，我们将看到一点。</p></blockquote><p id="24ed" class="pw-post-body-paragraph ld le it lf b lg lh kd li lj lk kg ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated">你可能已经注意到有一个<code class="fe my mz na nb b">useRef</code>偷偷溜进去了。是的，我承认。我做到了。但我这样做的原因是因为我们将使用它并对它进行修改，用于我提供的<code class="fe my mz na nb b">logUploadedFile</code>实用函数。</p><p id="54d4" class="pw-post-body-paragraph ld le it lf b lg lh kd li lj lk kg ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated"><code class="fe my mz na nb b"><em class="it">src/useFileHandlers.js</em></code></p><blockquote class="nl nm nn"><p id="2785" class="ld le lz lf b lg lh kd li lj lk kg ll no ln lo lp np lr ls lt nq lv lw lx ly im bi translated">哦，如果您需要一些模拟函数来模拟“上传”承诺处理程序，如代码片段所示，您可以使用:</p></blockquote><pre class="ks kt ku kv gt nc nb nd ne aw nf bi"><span id="9920" class="ng mc it nb b gy nh ni l nj nk">import { useCallback, useEffect, useReducer } from 'react'</span></pre><p id="3a61" class="pw-post-body-paragraph ld le it lf b lg lh kd li lj lk kg ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated">现在，通过应用<code class="fe my mz na nb b">file-uploaded</code>和<code class="fe my mz na nb b">set-upload-error</code>开关盒来更新您的减速器:</p><blockquote class="nl nm nn"><p id="d95f" class="ld le lz lf b lg lh kd li lj lk kg ll no ln lo lp np lr ls lt nq lv lw lx ly im bi translated"><code class="fe my mz na nb b"><em class="it">src/useFileHandlers.js</em></code></p></blockquote><pre class="ks kt ku kv gt nc nb nd ne aw nf bi"><span id="0604" class="ng mc it nb b gy nh ni l nj nk"><em class="lz">// Sets the next file when it detects that state.next can be set again</em><br/>useEffect(() =&gt; {<br/>  if (state.pending.length &amp;&amp; state.next == null) {<br/>    const next = state.pending[0]<br/>    dispatch({ type: 'next', next })<br/>  }<br/>}, [state.next, state.pending])</span></pre><p id="fc49" class="pw-post-body-paragraph ld le it lf b lg lh kd li lj lk kg ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated">对于<em class="lz">文件上传的</em>案例，我们将<code class="fe my mz na nb b">next</code>重置回<code class="fe my mz na nb b">null</code>，以便第一个<em class="lz"> </em> <code class="fe my mz na nb b">useEffect</code>可以再次响应。当它这样做时，它将拉入<code class="fe my mz na nb b">state.pending</code>队列中的下一个文件，并将其分配给下一个<code class="fe my mz na nb b">state.next</code>值。您已经可以开始看到这是如何成为一个自运行过程的了——一个从<em class="lz">运行到完成</em>的实现！</p><blockquote class="nl nm nn"><p id="d7f6" class="ld le lz lf b lg lh kd li lj lk kg ll no ln lo lp np lr ls lt nq lv lw lx ly im bi translated">总之，我们应用刚刚上传到<code class="fe my mz na nb b">state.uploaded</code>对象的文件，这样用户界面也可以利用这一点。这在本教程中也是一个非常有用的功能，因为如果你正在渲染一堆缩略图，你可以在上传后对每一行进行着色。:)本文末尾截图。</p></blockquote><figure class="ks kt ku kv gt kw"><div class="bz fp l di"><div class="nr ns l"/></div></figure><p id="a711" class="pw-post-body-paragraph ld le it lf b lg lh kd li lj lk kg ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated">第三个<em class="lz"> </em> <code class="fe my mz na nb b">useEffect</code>将负责通过向减速器发送<code class="fe my mz na nb b">files-uploaded</code>信号来关闭上传过程；</p><p id="4529" class="pw-post-body-paragraph ld le it lf b lg lh kd li lj lk kg ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated"><code class="fe my mz na nb b"><em class="it">src/useFileHandlers.js</em></code></p><blockquote class="nl nm nn"><p id="54d8" class="ld le lz lf b lg lh kd li lj lk kg ll no ln lo lp np lr ls lt nq lv lw lx ly im bi translated">将它添加到缩减器看起来像这样:</p></blockquote><pre class="ks kt ku kv gt nc nb nd ne aw nf bi"><span id="4e82" class="ng mc it nb b gy nh ni l nj nk">const logUploadedFile = (num, color = 'green') =&gt; {<br/>  const msg = `%cUploaded ${num} files.`<br/>  const style = `color:${color};font-weight:bold;`<br/>  console.log(msg, style)<br/>}</span></pre><p id="627c" class="pw-post-body-paragraph ld le it lf b lg lh kd li lj lk kg ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated"><code class="fe my mz na nb b"><em class="it">src/useFileHandlers.js</em></code></p><blockquote class="nl nm nn"><p id="29b5" class="ld le lz lf b lg lh kd li lj lk kg ll no ln lo lp np lr ls lt nq lv lw lx ly im bi translated">我们已经完成了定制挂钩！万岁！</p></blockquote><figure class="ks kt ku kv gt kw"><div class="bz fp l di"><div class="nr ns l"/></div></figure><p id="aafa" class="pw-post-body-paragraph ld le it lf b lg lh kd li lj lk kg ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated">下面是自定义挂钩的最终代码:</p><p id="bb19" class="pw-post-body-paragraph ld le it lf b lg lh kd li lj lk kg ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated"><code class="fe my mz na nb b"><em class="it">src/useFileHandlers.js</em></code></p><blockquote class="nl nm nn"><p id="c825" class="ld le lz lf b lg lh kd li lj lk kg ll no ln lo lp np lr ls lt nq lv lw lx ly im bi translated">但是等等，还没有结束。我们仍然需要将这种逻辑应用到用户界面中。啊，呸！</p></blockquote><pre class="ks kt ku kv gt nc nb nd ne aw nf bi"><span id="7b04" class="ng mc it nb b gy nh ni l nj nk">import { useCallback, useEffect, useReducer, useRef } from 'react'</span></pre><p id="a200" class="pw-post-body-paragraph ld le it lf b lg lh kd li lj lk kg ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated">我们将导入<code class="fe my mz na nb b">useFileHandlers</code>钩子并在组件中使用它。我们还将在每个文件上创建UI映射，并将它们呈现为缩略图:</p><pre class="ks kt ku kv gt nc nb nd ne aw nf bi"><span id="a052" class="ng mc it nb b gy nh ni l nj nk">const api = {<br/>  uploadFile({ timeout = 550 ) {<br/>    return new Promise((resolve) =&gt; {<br/>      setTimeout(() =&gt; {<br/>        resolve()<br/>      }, timeout)<br/>    })<br/>  },<br/>}</span></pre><p id="5b8a" class="pw-post-body-paragraph ld le it lf b lg lh kd li lj lk kg ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated"><code class="fe my mz na nb b"><em class="it">src/App.js</em></code></p><blockquote class="nl nm nn"><p id="4cff" class="ld le lz lf b lg lh kd li lj lk kg ll no ln lo lp np lr ls lt nq lv lw lx ly im bi translated">这个基本组件只是在加载时呈现一堆缩略图。我不太喜欢这种风格，因为我会让你尽情享受。</p></blockquote><figure class="ks kt ku kv gt kw"><div class="bz fp l di"><div class="nr ns l"/></div></figure><p id="b249" class="pw-post-body-paragraph ld le it lf b lg lh kd li lj lk kg ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated">但是如果你想使用这里的基本风格，它们是:</p><p id="8f51" class="pw-post-body-paragraph ld le it lf b lg lh kd li lj lk kg ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated"><code class="fe my mz na nb b"><em class="it">src/App.css</em></code></p><p id="2c93" class="pw-post-body-paragraph ld le it lf b lg lh kd li lj lk kg ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated">当所有文件上传完毕后会发生什么？嗯，还没什么。但是我们至少可以向用户展示一些东西，让他们知道已经完成了:</p><blockquote class="nl nm nn"><p id="7139" class="ld le lz lf b lg lh kd li lj lk kg ll no ln lo lp np lr ls lt nq lv lw lx ly im bi translated"><code class="fe my mz na nb b"><em class="it">src/App.js</em></code></p></blockquote><pre class="ks kt ku kv gt nc nb nd ne aw nf bi"><span id="0ffa" class="ng mc it nb b gy nh ni l nj nk"><em class="lz">// Ends the upload process</em><br/>useEffect(() =&gt; {<br/>  if (!state.pending.length &amp;&amp; state.uploading) {<br/>    dispatch({ type: 'files-uploaded' })<br/>  }<br/>}, [state.pending.length, state.uploading])</span></pre><p id="5dde" class="pw-post-body-paragraph ld le it lf b lg lh kd li lj lk kg ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated"><code class="fe my mz na nb b"><em class="it">src/App.css</em></code></p><blockquote class="nl nm nn"><p id="dbef" class="ld le lz lf b lg lh kd li lj lk kg ll no ln lo lp np lr ls lt nq lv lw lx ly im bi translated">这一次，这里使用的是<code class="fe my mz na nb b">status</code>。看，这很有用，不是吗？当与<code class="fe my mz na nb b">state.pending</code>和其他值结合使用时，你可以用其他的<code class="fe my mz na nb b">status</code>值制作一些看起来非常复杂的UI。如果你在本教程中做了一些惊人的事情，请给我发一封电子邮件，附上几张截图。</p></blockquote><figure class="ks kt ku kv gt kw"><div class="bz fp l di"><div class="nr ns l"/></div></figure><p id="a423" class="pw-post-body-paragraph ld le it lf b lg lh kd li lj lk kg ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated">最终输出:</p><p id="b684" class="pw-post-body-paragraph ld le it lf b lg lh kd li lj lk kg ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated"><code class="fe my mz na nb b"><em class="it">src/App.js</em></code></p><blockquote class="nl nm nn"><p id="8935" class="ld le lz lf b lg lh kd li lj lk kg ll no ln lo lp np lr ls lt nq lv lw lx ly im bi translated"><code class="fe my mz na nb b"><em class="it">src/App.css</em></code></p></blockquote><figure class="ks kt ku kv gt kw"><div class="bz fp l di"><div class="nr ns l"/></div></figure><p id="9cfd" class="pw-post-body-paragraph ld le it lf b lg lh kd li lj lk kg ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated">(包括对移动设备的媒体查询)</p><p id="aa51" class="pw-post-body-paragraph ld le it lf b lg lh kd li lj lk kg ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated">截屏</p><blockquote class="nl nm nn"><p id="ee9b" class="ld le lz lf b lg lh kd li lj lk kg ll no ln lo lp np lr ls lt nq lv lw lx ly im bi translated">我使用本教程中的代码提供了一些基本UX实现的截图:</p></blockquote><figure class="ks kt ku kv gt kw"><div class="bz fp l di"><div class="nr ns l"/></div></figure><p id="f2f4" class="pw-post-body-paragraph ld le it lf b lg lh kd li lj lk kg ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated"><strong class="ak"> onChange </strong></p><p id="2413" class="pw-post-body-paragraph ld le it lf b lg lh kd li lj lk kg ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated">logUploadedFile()</p><blockquote class="nl nm nn"><p id="a419" class="ld le lz lf b lg lh kd li lj lk kg ll no ln lo lp np lr ls lt nq lv lw lx ly im bi translated">状态.待定</p></blockquote><figure class="ks kt ku kv gt kw"><div class="bz fp l di"><div class="nr ns l"/></div></figure><p id="bd0d" class="pw-post-body-paragraph ld le it lf b lg lh kd li lj lk kg ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated">结论</p><blockquote class="nl nm nn"><p id="a272" class="ld le lz lf b lg lh kd li lj lk kg ll no ln lo lp np lr ls lt nq lv lw lx ly im bi translated">这篇文章到此结束。我希望你喜欢它。感谢您的阅读，如果您有任何问题，请告诉我！</p></blockquote><figure class="ks kt ku kv gt kw"><div class="bz fp l di"><div class="nr ns l"/></div></figure><blockquote class="nl nm nn"><p id="97e8" class="ld le lz lf b lg lh kd li lj lk kg ll no ln lo lp np lr ls lt nq lv lw lx ly im bi"><code class="fe my mz na nb b"><em class="it">src/App.css</em></code></p></blockquote><figure class="ks kt ku kv gt kw"><div class="bz fp l di"><div class="nr ns l"/></div></figure><p id="44f9" class="pw-post-body-paragraph ld le it lf b lg lh kd li lj lk kg ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi">This time, <code class="fe my mz na nb b">status</code> is being used here. See, it’s pretty useful, isn’t it? You can make some pretty amazing complex looking UI with the other <code class="fe my mz na nb b">status</code> values as well when combined with <code class="fe my mz na nb b">state.pending</code> and others. Send me an email with a couple of screenshots if you did something amazin with this tutorial!</p><p id="1393" class="pw-post-body-paragraph ld le it lf b lg lh kd li lj lk kg ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi">Final output:</p><blockquote class="nl nm nn"><p id="cbd4" class="ld le lz lf b lg lh kd li lj lk kg ll no ln lo lp np lr ls lt nq lv lw lx ly im bi"><code class="fe my mz na nb b"><em class="it">src/App.js</em></code></p></blockquote><figure class="ks kt ku kv gt kw"><div class="bz fp l di"><div class="nr ns l"/></div></figure><blockquote class="nl nm nn"><p id="c891" class="ld le lz lf b lg lh kd li lj lk kg ll no ln lo lp np lr ls lt nq lv lw lx ly im bi"><code class="fe my mz na nb b"><em class="it">src/App.css</em></code></p></blockquote><p id="81a6" class="pw-post-body-paragraph ld le it lf b lg lh kd li lj lk kg ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi">(Media queries for mobile devices included)</p><figure class="ks kt ku kv gt kw"><div class="bz fp l di"><div class="nr ns l"/></div></figure></div><div class="ab cl oi oj hx ok" role="separator"><span class="ol bw bk om on oo"/><span class="ol bw bk om on oo"/><span class="ol bw bk om on"/></div><div class="im in io ip iq"><h1 id="e851" class="mb mc it bd md me op mg mh mi oq mk ml ki or kj mn kl os km mp ko ot kp mr ms bi">Screenshots</h1><p id="6858" class="pw-post-body-paragraph ld le it lf b lg mt kd li lj mu kg ll lm mv lo lp lq mw ls lt lu mx lw lx ly im bi">I provided some screenshots of a basic UX implementation using the code in this tutorial:</p><h2 id="1a6e" class="ng mc it bd md ou ov dn mh ow ox dp ml lm oy oz mn lq pa pb mp lu pc pd mr iz bi"><strong class="ak">onChange</strong></h2><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div class="gh gi pe"><img src="../Images/1f444f1973d8eebcccd0351b522f76c7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1124/format:webp/1*sevo1tC80akHw_zWo9T5DA.jpeg"/></div></figure><h2 id="c0d8" class="ng mc it bd md ou ov dn mh ow ox dp ml lm oy oz mn lq pa pb mp lu pc pd mr iz bi">logUploadedFile()</h2><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi pf"><img src="../Images/c3c6e5c78beb231db2be6058e29c96a3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1344/0*uquVaR9yMEWcCabZ.JPG"/></div></div></figure><h2 id="0796" class="ng mc it bd md ou ov dn mh ow ox dp ml lm oy oz mn lq pa pb mp lu pc pd mr iz bi">state.pending</h2><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div class="gh gi pg"><img src="../Images/2e7ba553aa97ed56456993ec48afaa1f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1024/1*ZYCpZ087eAMmRb4cFiQ58A.gif"/></div></figure></div><div class="ab cl oi oj hx ok" role="separator"><span class="ol bw bk om on oo"/><span class="ol bw bk om on oo"/><span class="ol bw bk om on"/></div><div class="im in io ip iq"><h1 id="51d9" class="mb mc it bd md me op mg mh mi oq mk ml ki or kj mn kl os km mp ko ot kp mr ms bi">Conclusion</h1><p id="f8d5" class="pw-post-body-paragraph ld le it lf b lg mt kd li lj mu kg ll lm mv lo lp lq mw ls lt lu mx lw lx ly im bi">That concludes the end of this post. I hope you liked it. Thanks for reading and let me know if you had any questions implementing this on your own!</p></div></div>    
</body>
</html>