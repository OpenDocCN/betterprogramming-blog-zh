<html>
<head>
<title>Using the Scientific Method to Debug Containerized Applications</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用科学方法调试容器化应用程序</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/using-the-scientific-method-to-debug-containerized-applications-96749a4940ae?source=collection_archive---------3-----------------------#2020-11-21">https://betterprogramming.pub/using-the-scientific-method-to-debug-containerized-applications-96749a4940ae?source=collection_archive---------3-----------------------#2020-11-21</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="4c66" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">这是一个很有用的过程，可以找出什么地方坏了</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/16bcb51a62a635772f95a830092ceb82.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*ZdSY_23H8Drk-GRR"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">由<a class="ae ky" href="https://unsplash.com/@nasa?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> NASA </a>在<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</p></figure><p id="4748" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">啊，是的，“它在我的机器上运行良好！”也许是我们这个行业最著名的一句话。即使出现了跨SDLC提供一致环境的容器，我们仍然听到开发人员在发现缺陷时使用这种说法。但最终，如果代码在测试或生产中不起作用，它就不起作用，即使它在本地起作用。因此，作为一名开发人员，不管环境如何，能够深入到您的容器化应用程序中来解决问题，是我们都必须学习的一项关键技能。</p><p id="0b6d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们来看一个示例应用程序，它可以在本地工作，但是在部署时会失败，以及您可能如何使用科学方法(您还记得在学校学到的，对吗？)来调试容器化app中的这些故障。</p></div><div class="ab cl lw lx hx ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="im in io ip iq"><h1 id="9b1f" class="md me it bd mf mg mh mi mj mk ml mm mn jz mo ka mp kc mq kd mr kf ms kg mt mu bi translated">我们的例子</h1><p id="639d" class="pw-post-body-paragraph kz la it lb b lc mv ju le lf mw jx lh li mx lk ll lm my lo lp lq mz ls lt lu im bi translated">对于我们的<a class="ae ky" href="https://github.com/Tokugero/kubernetes-hello-world/tree/heroku" rel="noopener ugc nofollow" target="_blank">示例</a>，我们将使用一个简单的Flask应用程序，部署在Kubernetes容器中，显示使用过我们应用程序的名人。它在我们的本地系统上完美地工作！</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi na"><img src="../Images/54cd93d7b4060fe7806da3aac3c856e0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1222/0*aR5fsb1XOKahRDo1"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">名人</p></figure><p id="93a9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在，让我们将它部署到我们的Heroku服务中，看看它的行为是否相同(提示:不会)。</p><p id="4db6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe nb nc nd ne b">heroku container:push worker -a heroku-troubleshooting</code></p><p id="5e49" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe nb nc nd ne b">heroku container:release worker -a heroku-troubleshooting</code></p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi nf"><img src="../Images/490fbf25defbf5a70f1443617b44257e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1168/0*RZYQbhz2qmmtkHsy"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">出错信息</p></figure><p id="08a9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">该死。被生产环境的力量所挫败。现在我们可以开始挖掘发生了什么，看看我们有什么工具可以使用。</p></div><div class="ab cl lw lx hx ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="im in io ip iq"><h1 id="9505" class="md me it bd mf mg mh mi mj mk ml mm mn jz mo ka mp kc mq kd mr kf ms kg mt mu bi translated">我们的方法</h1><p id="8288" class="pw-post-body-paragraph kz la it lb b lc mv ju le lf mw jx lh li mx lk ll lm my lo lp lq mz ls lt lu im bi translated">当你的应用程序失败时，采取不偏不倚和客观的方法来诊断问题和理解错误是有帮助的。一种经典的方法是科学方法。经过数百年的严格重复和审查，我发现这种方法非常适合现代调试。</p><p id="b052" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">开发人员和DevOps工程师经常采取“让我们看看这能做什么”的分散方法进行调试。我们抓住想到的第一件事，即<em class="lv">可能</em>是错误的，改变我们的代码/配置，部署，并看看这是否有效。如果这不起作用，我们就继续尝试，有时会忘记我们已经尝试过的东西，有时会花几个小时甚至几天的时间沿着一条路走下去，如果我们停下来想一想，这条路显然是错误的。但是如果我们使用一个更合理、更结构化的方法，比如科学方法，我们的调试过程会更有效率、更快，最终会更好。</p><p id="38c6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">科学方法，最基本的，包括形成一个假设，进行实验，观察结果，然后完善你的假设。我用来调试容器化应用的科学方法是这样的:</p><ol class=""><li id="4ca0" class="ng nh it lb b lc ld lf lg li ni lm nj lq nk lu nl nm nn no bi translated">问“应该发生什么？”</li><li id="16c4" class="ng nh it lb b lc np lf nq li nr lm ns lq nt lu nl nm nn no bi translated">确定可能解释为什么<em class="lv">没有</em>发生的原因。</li><li id="8320" class="ng nh it lb b lc np lf nq li nr lm ns lq nt lu nl nm nn no bi translated">通过调整配置或使用工具，设计一个测试来验证/否定这些声明。</li><li id="dcc7" class="ng nh it lb b lc np lf nq li nr lm ns lq nt lu nl nm nn no bi translated">观察结果。</li><li id="70c0" class="ng nh it lb b lc np lf nq li nr lm ns lq nt lu nl nm nn no bi translated">得出结论。</li><li id="8662" class="ng nh it lb b lc np lf nq li nr lm ns lq nt lu nl nm nn no bi translated">重复，直到结果是应该发生的。</li></ol></div><div class="ab cl lw lx hx ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="im in io ip iq"><h1 id="4b6b" class="md me it bd mf mg mh mi mj mk ml mm mn jz mo ka mp kc mq kd mr kf ms kg mt mu bi translated">行动中的科学方法</h1><p id="2627" class="pw-post-body-paragraph kz la it lb b lc mv ju le lf mw jx lh li mx lk ll lm my lo lp lq mz ls lt lu im bi translated">现在让我们看看这种方法的实际应用。</p><h2 id="208d" class="nu me it bd mf nv nw dn mj nx ny dp mn li nz oa mp lm ob oc mr lq od oe mt of bi translated"><strong class="ak"> 1。问“应该发生什么？”</strong></h2><p id="9860" class="pw-post-body-paragraph kz la it lb b lc mv ju le lf mw jx lh li mx lk ll lm my lo lp lq mz ls lt lu im bi translated">首先，我们需要理解我们的应用程序试图做什么。要开始研究，我们需要了解页面呈现的细节。让我们看看docker文件是如何描述我们的服务的:</p><pre class="kj kk kl km gt og ne oh oi aw oj bi"><span id="8aae" class="nu me it ne b gy ok ol l om on">FROM python:3</span><span id="b3d6" class="nu me it ne b gy oo ol l om on">WORKDIR /usr/src/app</span><span id="86da" class="nu me it ne b gy oo ol l om on">COPY requirements.txt ./</span><span id="34fe" class="nu me it ne b gy oo ol l om on">RUN pip install --no-cache-dir -r requirements.txt</span><span id="a392" class="nu me it ne b gy oo ol l om on">RUN echo "healthy" &gt;&gt; /tmp/healthy &amp;&amp; \</span><span id="573a" class="nu me it ne b gy oo ol l om on">        cat /tmp/healthy</span><span id="9432" class="nu me it ne b gy oo ol l om on">ENV FLASK_ENV=development</span><span id="1400" class="nu me it ne b gy oo ol l om on">ENV FLASK_APP=myapp.py</span><span id="1f12" class="nu me it ne b gy oo ol l om on">COPY myapp.py .</span><span id="4a55" class="nu me it ne b gy oo ol l om on">CMD [ "python3", "myapp.py" ]</span></pre><p id="b45e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">很简单。我们有一个Python3应用程序，它安装一些需求，然后启动<code class="fe nb nc nd ne b">myapp.py</code>。让我们快速看一下我们的Python应用程序正在做什么，然后我们可以决定如何最好地继续。</p><pre class="kj kk kl km gt og ne oh oi aw oj bi"><span id="3cca" class="nu me it ne b gy ok ol l om on">from flask import Flask, Response</span><span id="e550" class="nu me it ne b gy oo ol l om on">import os</span><span id="8af2" class="nu me it ne b gy oo ol l om on">import psycopg2</span><span id="3b4d" class="nu me it ne b gy oo ol l om on">app = Flask(__name__)</span><span id="c7d0" class="nu me it ne b gy oo ol l om on">query = ("select * from actor order by random() limit 5;")</span><span id="0469" class="nu me it ne b gy oo ol l om on">host = os.getenv("host")</span><span id="5640" class="nu me it ne b gy oo ol l om on">password = os.getenv("PSQL_PASSWORD")</span><span id="d1cf" class="nu me it ne b gy oo ol l om on">user = os.getenv("PSQL_USERNAME")</span><span id="0965" class="nu me it ne b gy oo ol l om on">dbname = os.getenv("PSQL_DBNAME")</span><span id="8d7e" class="nu me it ne b gy oo ol l om on">print(host)</span><span id="ea9a" class="nu me it ne b gy oo ol l om on">print(user)</span><span id="74e2" class="nu me it ne b gy oo ol l om on">print(dbname)</span><span id="db33" class="nu me it ne b gy oo ol l om on">def callpsql():</span><span id="16d1" class="nu me it ne b gy oo ol l om on">    conn = psycopg2.connect(dbname=dbname, user=user, password=password, host=host, port="5432")</span><span id="1787" class="nu me it ne b gy oo ol l om on">    cur = conn.cursor()</span><span id="ccb4" class="nu me it ne b gy oo ol l om on">    cur.execute(query)</span><span id="97e8" class="nu me it ne b gy oo ol l om on">    results = cur.fetchall()</span><span id="3732" class="nu me it ne b gy oo ol l om on">    cur.close()</span><span id="6538" class="nu me it ne b gy oo ol l om on">    conn.close()</span><span id="2f35" class="nu me it ne b gy oo ol l om on">    return results</span><span id="795b" class="nu me it ne b gy oo ol l om on">@app.route('/')</span><span id="5031" class="nu me it ne b gy oo ol l om on">def index():</span><span id="78dc" class="nu me it ne b gy oo ol l om on">    response = callpsql()</span><span id="1383" class="nu me it ne b gy oo ol l om on">    print("Getting some juicy logs")</span><span id="3709" class="nu me it ne b gy oo ol l om on">    results = "I've sold to these famous people from server "+os.getenv("DYNO")+": &lt;br&gt;\n"</span><span id="7f41" class="nu me it ne b gy oo ol l om on">    for row in response:</span><span id="7129" class="nu me it ne b gy oo ol l om on">        results = results+"&lt;br&gt;\n"+str(row[1])+"\t"+str(row[2])</span><span id="7b1f" class="nu me it ne b gy oo ol l om on">    return results</span><span id="1d52" class="nu me it ne b gy oo ol l om on">@app.route('/health')</span><span id="5a3b" class="nu me it ne b gy oo ol l om on">def health():</span><span id="f9fb" class="nu me it ne b gy oo ol l om on">    f = open("/tmp/healthy", "r")</span><span id="0b3c" class="nu me it ne b gy oo ol l om on">    print(f)</span><span id="8067" class="nu me it ne b gy oo ol l om on">    health = f.readline().rstrip()</span><span id="36ab" class="nu me it ne b gy oo ol l om on">    resp = Response(health)</span><span id="71b5" class="nu me it ne b gy oo ol l om on">    if health != "healthy":</span><span id="c565" class="nu me it ne b gy oo ol l om on">        resp.status=500</span><span id="b6b1" class="nu me it ne b gy oo ol l om on">    resp.headers['health-check'] = health</span><span id="9148" class="nu me it ne b gy oo ol l om on">    return resp</span><span id="2815" class="nu me it ne b gy oo ol l om on">if __name__ == "__main__":</span><span id="63df" class="nu me it ne b gy oo ol l om on">    port = 5000</span><span id="753a" class="nu me it ne b gy oo ol l om on">    app.run(debug=True, host='0.0.0.0', port=port)</span></pre><p id="041d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">另一个非常简单的应用程序。这需要几个环境变量进行身份验证，并在根页面被调用时对Postgres数据库执行SQL查询。</p><h2 id="8359" class="nu me it bd mf nv nw dn mj nx ny dp mn li nz oa mp lm ob oc mr lq od oe mt of bi translated"><strong class="ak"> 2。确定可能解释为什么<em class="op">没有</em>发生</strong>的原因</h2><p id="8e1a" class="pw-post-body-paragraph kz la it lb b lc mv ju le lf mw jx lh li mx lk ll lm my lo lp lq mz ls lt lu im bi translated">既然我们知道了应用程序正在<em class="lv">尝试</em>做什么，我们进入下一步，解释为什么在我们的新环境中没有发生。</p><p id="e431" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这里我们可以看看错误页面上建议的Heroku logs <code class="fe nb nc nd ne b">--tail</code>命令。这应该让我们很好地了解我们的服务在任何时间点正在做什么，并且还帮助我们形成一个假设，即可能是什么问题。</p><pre class="kj kk kl km gt og ne oh oi aw oj bi"><span id="0252" class="nu me it ne b gy ok ol l om on">$ heroku logs --tail -a heroku-troubleshooting</span><span id="7a15" class="nu me it ne b gy oo ol l om on">...</span><span id="c48f" class="nu me it ne b gy oo ol l om on">2020-08-22T22:45:34.805282+00:00 heroku[router]: at=error code=H14 desc="No web processes running" method=GET path="/" host=heroku-troubleshooting.herokuapp.com request_id=09292b76-b372-49e9-858b-e8611c020fd5 fwd="xx.xx.xx.xx" dyno= connect= service= status=503 bytes= protocol=https</span><span id="f827" class="nu me it ne b gy oo ol l om on">…</span></pre><p id="24cf" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">每次加载页面时，我们都会看到“没有web进程正在运行”的错误。看起来Heroku并不知道我们已经启动了Flask。太好了！我们有我们的假设:“Flask可能不在Heroku的环境中运行。”</p><h2 id="16e9" class="nu me it bd mf nv nw dn mj nx ny dp mn li nz oa mp lm ob oc mr lq od oe mt of bi translated"><strong class="ak"> 3。通过调整配置或使用工具设计一个测试来验证/否定这些声明</strong></h2><p id="d1ba" class="pw-post-body-paragraph kz la it lb b lc mv ju le lf mw jx lh li mx lk ll lm my lo lp lq mz ls lt lu im bi translated">现在让我们进入下一步:创建一个测试来验证我们认为正在发生的事情，观察结果，并得出结论。</p><p id="cf51" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们来测试一下我们的假设。我们将跳到我们的dyno上，验证Flask服务是否正在运行。我们的docker文件指定python应该是一个运行的、监听的服务。</p><pre class="kj kk kl km gt og ne oh oi aw oj bi"><span id="3b99" class="nu me it ne b gy ok ol l om on">$ heroku ps:exec -a heroku-troubleshooting</span><span id="c83e" class="nu me it ne b gy oo ol l om on">Establishing credentials... error</span><span id="1738" class="nu me it ne b gy oo ol l om on"> ▸    Could not connect to dyno!</span><span id="fc9f" class="nu me it ne b gy oo ol l om on"> ▸    Check if the dyno is running with `heroku ps'</span></pre><h2 id="168a" class="nu me it bd mf nv nw dn mj nx ny dp mn li nz oa mp lm ob oc mr lq od oe mt of bi translated"><strong class="ak"> 4。观察结果</strong></h2><p id="cef9" class="pw-post-body-paragraph kz la it lb b lc mv ju le lf mw jx lh li mx lk ll lm my lo lp lq mz ls lt lu im bi translated">我们释放了我们的容器，所以它应该在运行。然而，我们测试的日志告诉我们，我们无法连接到应该运行代码的dyno。执行建议的命令可能会给我们另一个线索。</p><p id="c41b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe nb nc nd ne b">$ heroku ps -a heroku-troubleshooting</code></p><p id="900e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe nb nc nd ne b">No dynos on ⬢ heroku-troubleshooting</code></p><h2 id="d035" class="nu me it bd mf nv nw dn mj nx ny dp mn li nz oa mp lm ob oc mr lq od oe mt of bi translated"><strong class="ak"> 5。得出结论</strong></h2><p id="fce5" class="pw-post-body-paragraph kz la it lb b lc mv ju le lf mw jx lh li mx lk ll lm my lo lp lq mz ls lt lu im bi translated">这太尴尬了。科学方法的结论？我们最初的断言是错误的，我们发布的代码留给我们一个运行的dyno来服务代码。我们确实推出并发布了我们的图像，但是我们没有在应用程序中添加任何dynos。看来我们已经验证了应用程序没有运行，我们的假设是不正确的。</p><h2 id="b5ed" class="nu me it bd mf nv nw dn mj nx ny dp mn li nz oa mp lm ob oc mr lq od oe mt of bi translated"><strong class="ak"> 6。重复直到结果是应该发生的</strong></h2><p id="1d91" class="pw-post-body-paragraph kz la it lb b lc mv ju le lf mw jx lh li mx lk ll lm my lo lp lq mz ls lt lu im bi translated">因此，我们进入下一步，即<em class="lv">重复这个过程，</em>我们将在整篇文章中继续重复这个过程，直到我们的问题得到解决。</p><p id="0b4a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">所以我们来形成一个新的假设，检验一下。基于上一次测试，我们的新假设是，随着dyno的运行，我们应该能够从外部世界访问我们的Flask应用程序。我们将扩展一个dyno来启动应用程序，并再次检查日志来测试这个断言。</p><pre class="kj kk kl km gt og ne oh oi aw oj bi"><span id="c925" class="nu me it ne b gy ok ol l om on">$ heroku dyno:scale -a heroku-troubleshooting worker=1</span><span id="8642" class="nu me it ne b gy oo ol l om on">Scaling dynos... done, now running worker at 1:Standard-1X</span><span id="1d03" class="nu me it ne b gy oo ol l om on">$ heroku logs --tail -a heroku-troubleshooting</span><span id="a884" class="nu me it ne b gy oo ol l om on">2020-08-22T23:29:05.207217+00:00 app[api]: Scaled to worker@1:Standard-1X by user</span><span id="7ce2" class="nu me it ne b gy oo ol l om on">2020-08-22T23:29:18.202160+00:00 heroku[worker.1]: Starting process with command `python3 myapp.py`</span><span id="8aa3" class="nu me it ne b gy oo ol l om on">2020-08-22T23:29:18.760500+00:00 heroku[worker.1]: State changed from starting to up</span><span id="70d4" class="nu me it ne b gy oo ol l om on">2020-08-22T23:29:21.559386+00:00 app[worker.1]: None</span><span id="d3e3" class="nu me it ne b gy oo ol l om on">2020-08-22T23:29:21.559547+00:00 app[worker.1]: None</span><span id="3289" class="nu me it ne b gy oo ol l om on">2020-08-22T23:29:21.559548+00:00 app[worker.1]: None</span><span id="4a93" class="nu me it ne b gy oo ol l om on">2020-08-22T23:29:21.559549+00:00 app[worker.1]: * Serving Flask app "myapp" (lazy loading)</span><span id="1378" class="nu me it ne b gy oo ol l om on">2020-08-22T23:29:21.559556+00:00 app[worker.1]: * Environment: development</span><span id="863a" class="nu me it ne b gy oo ol l om on">2020-08-22T23:29:21.559556+00:00 app[worker.1]: * Debug mode: on</span><span id="56a6" class="nu me it ne b gy oo ol l om on">2020-08-22T23:29:21.636027+00:00 app[worker.1]: * Running on http://0.0.0.0:5000/ (Press CTRL+C to quit)</span><span id="06a5" class="nu me it ne b gy oo ol l om on">2020-08-22T23:29:21.637965+00:00 app[worker.1]: * Restarting with stat</span><span id="a0f2" class="nu me it ne b gy oo ol l om on">2020-08-22T23:29:21.897821+00:00 app[worker.1]: * Debugger is active!</span><span id="571c" class="nu me it ne b gy oo ol l om on">2020-08-22T23:29:21.929543+00:00 app[worker.1]: * Debugger PIN: 485-744-571</span></pre><p id="ab6b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们走吧。现在应用已经开始了！是时候再次测试该网站，观察它是否工作。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi nf"><img src="../Images/42921968a0b5450ab171a498982e3003.png" data-original-src="https://miro.medium.com/v2/resize:fit:1168/0*7hmdfnJvm-IAMc4A"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">出错信息</p></figure><p id="f585" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们现在的结论是，肯定不是。我们应该再次检查我们的命令，看看状态是否发生了变化，这样我们就可以创建一个新的假设。</p><pre class="kj kk kl km gt og ne oh oi aw oj bi"><span id="cbf3" class="nu me it ne b gy ok ol l om on">$ heroku logs -a heroku-troubleshooting<br/>2020-08-22T23:32:12.098568+00:00 heroku[router]: at=error code=H14 desc="No web processes running" method=GET path="/" host=heroku-troubleshooting.herokuapp.com request_id=4d3cbafa-cb31-4452-bfc6-7ee18ce72eb0 fwd="xx.xx.xx.xx" dyno= connect= service= status=503 bytes= protocol=https<br/></span><span id="0230" class="nu me it ne b gy oo ol l om on">$ heroku ps -a heroku-troubleshooting<br/>=== worker (Standard-1X): python3 myapp.py (1)<br/>worker.1: up 2020/08/22 16:31:59 -0700 (~ 3m ago)</span></pre><p id="2127" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">看起来我们正在运行一项服务，但是仅仅使用日志我们无法获得更多的数据。假设，我们可以进入服务，并确保它的工作。</p><pre class="kj kk kl km gt og ne oh oi aw oj bi"><span id="7d95" class="nu me it ne b gy ok ol l om on">$ heroku ps:exec -d worker.1 -a heroku-troubleshooting</span><span id="5027" class="nu me it ne b gy oo ol l om on">Establishing credentials... error</span><span id="f10a" class="nu me it ne b gy oo ol l om on"> ▸    Could not connect to dyno!</span><span id="3277" class="nu me it ne b gy oo ol l om on"> ▸    Check if the dyno is running with `heroku ps'</span></pre><p id="c846" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这里我们可以观察到，即使dyno在运行，我们也无法连接到它。回顾我们的docker文件和一些文档，我们可以得出结论，Heroku环境需要一些必要条件来支持exec到部署的容器中。当我们在这里测试这个新配置是否允许我们连接时，我们应该添加一些我们可能需要的实用程序命令来测试未来的假设。</p><p id="0ef3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">Dockerfile文件</p><pre class="kj kk kl km gt og ne oh oi aw oj bi"><span id="12f6" class="nu me it ne b gy ok ol l om on">...</span><span id="07db" class="nu me it ne b gy oo ol l om on">RUN apt-get update &amp;&amp; \</span><span id="e7a8" class="nu me it ne b gy oo ol l om on">        apt-get install -y \</span><span id="00c6" class="nu me it ne b gy oo ol l om on">                curl \</span><span id="d2ce" class="nu me it ne b gy oo ol l om on">                openssh-server \</span><span id="154c" class="nu me it ne b gy oo ol l om on">                           net-tools \</span><span id="f6db" class="nu me it ne b gy oo ol l om on">                           dnsutils \</span><span id="2add" class="nu me it ne b gy oo ol l om on">                           iproute2</span><span id="a622" class="nu me it ne b gy oo ol l om on">RUN mkdir -p /app/.profile.d &amp;&amp; \</span><span id="e9bf" class="nu me it ne b gy oo ol l om on">        touch /app/.profile.d/heroku-exec.sh &amp;&amp; \</span><span id="72ce" class="nu me it ne b gy oo ol l om on">        echo '[ -z "$SSH_CLIENT" ] &amp;&amp; source &lt;(curl --fail --retry 3 -sSL "$HEROKU_EXEC_URL")' &gt;&gt; /app/.profile.d/heroku-exec.sh &amp;&amp; \</span><span id="58a2" class="nu me it ne b gy oo ol l om on">        chmod +x /app/.profile.d/heroku-exec.sh</span><span id="c10c" class="nu me it ne b gy oo ol l om on">...</span></pre><p id="7687" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">稍后再按一次并释放，我们已经验证了我们的结论是正确的，我们最终可以连接:</p><pre class="kj kk kl km gt og ne oh oi aw oj bi"><span id="4064" class="nu me it ne b gy ok ol l om on">$ heroku ps:exec -d worker.1 -a heroku-troubleshooting</span><span id="0b62" class="nu me it ne b gy oo ol l om on">Establishing credentials... done</span><span id="af54" class="nu me it ne b gy oo ol l om on">Connecting to worker.1 on ⬢ heroku-troubleshooting...</span><span id="cdb6" class="nu me it ne b gy oo ol l om on">The programs included with the Debian GNU/Linux system are free software;</span><span id="5191" class="nu me it ne b gy oo ol l om on">the exact distribution terms for each program are described in the</span><span id="0ecb" class="nu me it ne b gy oo ol l om on">individual files in /usr/share/doc/*/copyright.</span><span id="a9d9" class="nu me it ne b gy oo ol l om on">Debian GNU/Linux comes with ABSOLUTELY NO WARRANTY, to the extent</span><span id="18f9" class="nu me it ne b gy oo ol l om on">permitted by applicable law.</span><span id="5cfb" class="nu me it ne b gy oo ol l om on">~ $</span></pre><p id="1bdc" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在我们已经在应用程序中了，我们可以检查我们的假设，即端口正在监听，并且我们的应用程序从容器本身内部做出响应。我们可以使用" net-tools" <code class="fe nb nc nd ne b">netstat</code>命令作为测试，向我们显示容器上打开的端口列表，并监听打开套接字的调用。</p><pre class="kj kk kl km gt og ne oh oi aw oj bi"><span id="5db9" class="nu me it ne b gy ok ol l om on">~ $ netstat -apn | grep 5000 | grep LIST</span><span id="a3a2" class="nu me it ne b gy oo ol l om on">(Not all processes could be identified, non-owned process info</span><span id="adbf" class="nu me it ne b gy oo ol l om on"> will not be shown, you would have to be root to see it all.)</span><span id="f477" class="nu me it ne b gy oo ol l om on">tcp        0      0 0.0.0.0:5000            0.0.0.0:*               LISTEN      3/python3</span></pre><p id="3a0d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们的分析表明，端口如预期的那样打开，我们的假设是正确的。</p><p id="fa52" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">因为什么都没有改变，我们必须设计一个新的测试。“Curl”可以作为我们的命令行互联网浏览器，向我们显示一个简化的端口视图，我们现在已经验证该端口是打开的，并且正在正确侦听。</p><pre class="kj kk kl km gt og ne oh oi aw oj bi"><span id="e9f7" class="nu me it ne b gy ok ol l om on">~ $ curl -I localhost:5000</span><span id="5b32" class="nu me it ne b gy oo ol l om on">HTTP/1.0 500 INTERNAL SERVER ERROR</span><span id="a209" class="nu me it ne b gy oo ol l om on">Content-Type: text/html; charset=utf-8</span><span id="c092" class="nu me it ne b gy oo ol l om on">X-XSS-Protection: 0</span><span id="4733" class="nu me it ne b gy oo ol l om on">Server: Werkzeug/1.0.1 Python/3.8.5</span><span id="7ed7" class="nu me it ne b gy oo ol l om on">Date: Sun, 23 Aug 2020 00:27:14 GMT</span><span id="864e" class="nu me it ne b gy oo ol l om on">~ $ curl localhost:5000</span><span id="78cd" class="nu me it ne b gy oo ol l om on">...</span><span id="5e14" class="nu me it ne b gy oo ol l om on">psycopg2.OperationalError: could not connect to server: No such file or directory</span><span id="224c" class="nu me it ne b gy oo ol l om on">        Is the server running locally and accepting</span><span id="e540" class="nu me it ne b gy oo ol l om on">        connections on Unix domain socket "/var/run/postgresql/.s.PGSQL.5432"?</span><span id="e327" class="nu me it ne b gy oo ol l om on">...</span></pre><p id="8b35" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">啊哈！我们对这个错误的分析证明，调用失败是因为我们的应用程序中出现了一个500错误。我们的新假设是，这肯定是Heroku不向我们的应用程序发送流量的至少<em class="lv">个</em>原因。如果我们回头看看我们的Python代码，我们可以看到它需要一些环境变量。在我们的本地主机中，我们将它们作为开发虚拟环境的一部分导出。我们现在可以得出结论，这些也需要添加到Heroku的应用程序中。</p><p id="6b83" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们的新假设变成了:“服务应该在本地和生产环境中都像预期的那样工作。”为了测试这个假设并获得新的变化，我们需要重新启动我们的worker，让应用程序获得新的环境变量。</p><pre class="kj kk kl km gt og ne oh oi aw oj bi"><span id="133d" class="nu me it ne b gy ok ol l om on">$ heroku ps:restart worker.1 -a heroku-troubleshooting</span><span id="6907" class="nu me it ne b gy oo ol l om on">Restarting worker.1 dyno on ⬢ heroku-troubleshooting... done</span><span id="a3ed" class="nu me it ne b gy oo ol l om on">$ heroku ps:exec -d worker.1 -a heroku-troubleshooting</span><span id="2bf2" class="nu me it ne b gy oo ol l om on">Establishing credentials... done</span><span id="cb4a" class="nu me it ne b gy oo ol l om on">Connecting to worker.1 on ⬢ heroku-troubleshooting...</span><span id="22f9" class="nu me it ne b gy oo ol l om on">The programs included with the Debian GNU/Linux system are free software;</span><span id="792e" class="nu me it ne b gy oo ol l om on">the exact distribution terms for each program are described in the</span><span id="e4fe" class="nu me it ne b gy oo ol l om on">individual files in /usr/share/doc/*/copyright.</span><span id="541f" class="nu me it ne b gy oo ol l om on">Debian GNU/Linux comes with ABSOLUTELY NO WARRANTY, to the extent</span><span id="549f" class="nu me it ne b gy oo ol l om on">permitted by applicable law.</span><span id="e020" class="nu me it ne b gy oo ol l om on">~ $ curl -I localhost:5000</span><span id="65ec" class="nu me it ne b gy oo ol l om on">HTTP/1.0 200 OK</span><span id="5951" class="nu me it ne b gy oo ol l om on">Content-Type: text/html; charset=utf-8</span><span id="129a" class="nu me it ne b gy oo ol l om on">Content-Length: 148</span><span id="67d9" class="nu me it ne b gy oo ol l om on">Server: Werkzeug/1.0.1 Python/3.8.5</span><span id="6af0" class="nu me it ne b gy oo ol l om on">Date: Sun, 23 Aug 2020 00:50:35 GMT</span><span id="c4a2" class="nu me it ne b gy oo ol l om on">~ $ curl localhost:5000</span><span id="afba" class="nu me it ne b gy oo ol l om on">I've sold to these famous people from server worker.1: &lt;br&gt;</span><span id="c1cd" class="nu me it ne b gy oo ol l om on">&lt;br&gt;</span><span id="13f4" class="nu me it ne b gy oo ol l om on">Julianne        Dench&lt;br&gt;</span><span id="7670" class="nu me it ne b gy oo ol l om on">Sylvester       Dern&lt;br&gt;</span><span id="e1d8" class="nu me it ne b gy oo ol l om on">Greta   Keitel&lt;br&gt;</span><span id="8b03" class="nu me it ne b gy oo ol l om on">Dustin  Tautou&lt;br&gt;</span><span id="e47b" class="nu me it ne b gy oo ol l om on">Penelope        Monroe</span></pre><p id="1153" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在重新运行之前的测试之后，我们现在已经验证了本地容器正在按照我们的预期工作。尽管如此，我们的日志和浏览器得出结论，该应用程序仍然没有按预期运行。</p><p id="2c60" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们内部卷曲的日志:</p><pre class="kj kk kl km gt og ne oh oi aw oj bi"><span id="a86d" class="nu me it ne b gy ok ol l om on">2020-08-23T00:50:35.931678+00:00 app[worker.1]: 127.0.0.1 - - [23/Aug/2020 00:50:35] "[37mHEAD / HTTP/1.1[0m" 200 -<br/></span><span id="8eb7" class="nu me it ne b gy oo ol l om on">2020-08-23T00:50:41.807629+00:00 app[worker.1]: 127.0.0.1 - - [23/Aug/2020 00:50:41] "[37mGET / HTTP/1.1[0m" 200 -</span></pre><p id="b488" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">来自我们外部浏览器的日志:</p><pre class="kj kk kl km gt og ne oh oi aw oj bi"><span id="6208" class="nu me it ne b gy ok ol l om on">2020-08-23T00:50:47.151656+00:00 heroku[router]: at=error code=H14 desc="No web processes running" method=GET path="/" host=heroku-troubleshooting.herokuapp.com request_id=a9421f09-94f2-4822-9608-f2f63ffe5123 fwd="68.251.62.251" dyno= connect= service= status=503 bytes= protocol=https</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi nf"><img src="../Images/b274cbd98915645c9b5da009cd02bbd7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1168/0*6W8MR--ghpknkJ05"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">出错信息</p></figure><p id="eac0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">假设应用程序在容器中工作，似乎一切都应该工作正常。利用我们之前重新运行的测试，并进一步分析错误“没有web进程运行”给了我们另一个提示。有两种类型的dyno，我们将它部署为“工人”dyno。查看<a class="ae ky" href="https://devcenter.heroku.com/articles/dynos#dyno-configurations" rel="noopener ugc nofollow" target="_blank">文档</a>，我们可以得出结论，也许我们已经部署了错误的资源类型，没有获得入口。假设Heroku应该提供一个动态外部端口，如果我们将dyno配置为“web”而不是“worker”作为“web”动态测试重新部署的时间到了。</p><pre class="kj kk kl km gt og ne oh oi aw oj bi"><span id="6bb3" class="nu me it ne b gy ok ol l om on">heroku ps:scale worker=0 -a heroku-troubleshooting</span><span id="1843" class="nu me it ne b gy oo ol l om on">heroku container:push web -a heroku-troubleshooting</span><span id="43a1" class="nu me it ne b gy oo ol l om on">heroku container:release web -a heroku-troubleshooting</span><span id="e023" class="nu me it ne b gy oo ol l om on">heroku ps:scale web=1 -a heroku-troubleshooting</span></pre><p id="ed70" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">浏览网站仍然会给出与我们最初测试相同的结论，但是现在我们观察到的日志给了我们下一个要研究的线索。</p><pre class="kj kk kl km gt og ne oh oi aw oj bi"><span id="da2b" class="nu me it ne b gy ok ol l om on">2020-08-23T01:03:12.890612+00:00 app[web.1]:  * Serving Flask app "myapp" (lazy loading)</span><span id="4d42" class="nu me it ne b gy oo ol l om on">2020-08-23T01:03:12.890619+00:00 app[web.1]:  * Environment: development</span><span id="cca8" class="nu me it ne b gy oo ol l om on">2020-08-23T01:03:12.890620+00:00 app[web.1]:  * Debug mode: on</span><span id="a1d9" class="nu me it ne b gy oo ol l om on">2020-08-23T01:03:12.905580+00:00 app[web.1]:  * Running on http://0.0.0.0:5000/ (Press CTRL+C to quit)</span><span id="11ab" class="nu me it ne b gy oo ol l om on">2020-08-23T01:03:12.906860+00:00 app[web.1]:  * Restarting with stat</span><span id="590b" class="nu me it ne b gy oo ol l om on">2020-08-23T01:03:13.661451+00:00 app[web.1]:  * Debugger is active!</span><span id="10df" class="nu me it ne b gy oo ol l om on">2020-08-23T01:03:13.662395+00:00 app[web.1]:  * Debugger PIN: 196-723-097</span><span id="390d" class="nu me it ne b gy oo ol l om on">2020-08-23T01:04:07.990856+00:00 heroku[web.1]: Error R10 (Boot timeout) -&gt; Web process failed to bind to $PORT within 60 seconds of launch</span><span id="42dc" class="nu me it ne b gy oo ol l om on">2020-08-23T01:04:08.016515+00:00 heroku[web.1]: Stopping process with SIGKILL</span><span id="efe1" class="nu me it ne b gy oo ol l om on">2020-08-23T01:04:08.224860+00:00 heroku[web.1]: Process exited with status 137</span><span id="0ef0" class="nu me it ne b gy oo ol l om on">2020-08-23T01:04:08.290383+00:00 heroku[web.1]: State changed from starting to crashed</span><span id="12fa" class="nu me it ne b gy oo ol l om on">2020-08-23T01:04:08.293139+00:00 heroku[web.1]: State changed from crashed to starting</span><span id="0fd0" class="nu me it ne b gy oo ol l om on">“Web process failed to bind to $PORT”</span></pre><p id="90bb" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们可以得出结论，我们需要将我们的进程绑定到一个变量，而不是默认的Flask端口。这很容易在我们的Python应用程序中解决。如果我们在生产环境中映射了正确的变量，并且我们的应用程序将该变量用作其端口配置，那么我们应该有一个功能完整的站点。为了测试这一点，我们可以从主机传入环境变量，并在我们的<code class="fe nb nc nd ne b">app.run</code>参数中使用它。</p><pre class="kj kk kl km gt og ne oh oi aw oj bi"><span id="c26a" class="nu me it ne b gy ok ol l om on">myapp.py</span><span id="4993" class="nu me it ne b gy oo ol l om on">if __name__ == "__main__":</span><span id="1cfd" class="nu me it ne b gy oo ol l om on">    port = int(os.getenv("PORT", 5000))</span><span id="6489" class="nu me it ne b gy oo ol l om on">    app.run(debug=True, host='0.0.0.0', port=port)</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi oq"><img src="../Images/d0d8f1a48cc63539e362e347aea3008b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*ixueYfPFwim_buAG"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">名人</p></figure><p id="f0b1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在你知道了！我们对测试的分析表明，该应用程序在本地和部署时都可以工作。最后一次验证，以确保我们的更改也能在我们的开发环境中继续工作。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi or"><img src="../Images/0246148a203b39fa17a0ef69ee198402.png" data-original-src="https://miro.medium.com/v2/resize:fit:1230/0*gJSahpZcYp9w_r92"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">更有名的人。</p></figure></div><div class="ab cl lw lx hx ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="im in io ip iq"><h1 id="26b4" class="md me it bd mf mg mh mi mj mk ml mm mn jz mo ka mp kc mq kd mr kf ms kg mt mu bi translated">把它放在一起</h1><p id="03b5" class="pw-post-body-paragraph kz la it lb b lc mv ju le lf mw jx lh li mx lk ll lm my lo lp lq mz ls lt lu im bi translated">在这个工作流程中，我们使用科学的方法来调查一个无法在生产中呈现的应用程序。调试托管基础架构是一项令人望而生畏的任务，但这仅仅是因为其各部分的总和。通过分解产品的每一层，回顾它在标准化工具下的行为，从日志和应用程序输出中获取线索，并回顾各种产品文档，我们可以将这些复杂的结构分解成有意义的简单结论，这些结论将复活任何服务。</p><p id="0703" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果你想进一步分析我们部署的应用程序，你可以在这里看到它<a class="ae ky" href="https://github.com/Tokugero/kubernetes-hello-world/tree/heroku" rel="noopener ugc nofollow" target="_blank">。下次你发现自己在研究一个难题时，记得一次一层地研究每一个组成部分，并在这个过程中应用系统的、科学的方法。通过这样做，你可以消除很多个人偏见，否则这些偏见可能会让你陷入对StackOverflow文章和随机社区论坛的盲目追逐。</a></p></div></div>    
</body>
</html>