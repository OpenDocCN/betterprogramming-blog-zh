<html>
<head>
<title>Monitoring Kafka Topic Consumer Lag With AWS Lambda</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">用AWS Lambda监控Kafka主题消费者滞后</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/monitoring-kafka-topic-consumer-lag-with-aws-lambda-b6638c7da135?source=collection_archive---------6-----------------------#2022-07-08">https://betterprogramming.pub/monitoring-kafka-topic-consumer-lag-with-aws-lambda-b6638c7da135?source=collection_archive---------6-----------------------#2022-07-08</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="1dec" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">Kafka消费者滞后监测与合流计量API</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/aef27c0b2aef69b20139fb88204a9c37.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*XWxSPuEDWp3r0NjBOQY5EA.jpeg"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">照片由<a class="ae ky" href="https://unsplash.com/@cnf271?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">纳温·丰塞卡</a>在<a class="ae ky" href="https://unsplash.com/@cnf271?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>拍摄</p></figure><p id="17df" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">最近在我的工作中，我们遇到了几个服务级别的问题，导致Kafka的消息不能被Kafka的消费者服务和适当地处理。为了识别这种情况，我们决定提出一种机制，在这种机制中，我们可以获得关于Kafka主题消费者滞后的及时更新。我们正在使用由<a class="ae ky" href="https://www.confluent.io/" rel="noopener ugc nofollow" target="_blank"> Confluent </a>提供的Kafka管理的集群。</p><p id="c9e0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在我们最初的研究中，我们发现Confluent提供了几个API端点来使用它们的<a class="ae ky" href="https://docs.confluent.io/cloud/current/monitoring/metrics-api.html" rel="noopener ugc nofollow" target="_blank">度量API</a>检索集群级信息。</p><h1 id="0446" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated"><strong class="ak">融合度量API</strong></h1><p id="747b" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated"><code class="fe ms mt mu mv b">consumer_lag_offset</code>指标可以使用公开可用的指标API从每个Kafka主题中检索消费者滞后信息。要使用Confluent的Metric APIs，了解他们自己的“表达性查询语言”是必须的。使用自定义查询，我们可以灵活地从提供的时间范围过滤数据。</p><p id="259b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在我解释如何在Lambda函数中使用<code class="fe ms mt mu mv b">consumer_lag_offset</code>指标之前，最好先了解一下如何使用一个示例查询来检索消费者滞后补偿。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mw mx l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">从汇合中检索消费者滞后的示例查询</p></figure><p id="a593" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在接下来的步骤中，我将简要解释每个查询参数。让我们从聚合开始。</p><ul class=""><li id="a146" class="my mz it lb b lc ld lf lg li na lm nb lq nc lu nd ne nf ng bi translated"><code class="fe ms mt mu mv b">aggregations</code>:该字段用于指定要查询的指标。在撰写本文时，每个请求只允许一个指标。</li><li id="c43c" class="my mz it lb b lc nh lf ni li nj lm nk lq nl lu nd ne nf ng bi translated"><code class="fe ms mt mu mv b">filter</code>:该字段定义过滤参数。<code class="fe ms mt mu mv b">filter</code>字段带有几个子参数。如下:<br/>–<code class="fe ms mt mu mv b">op</code>:定义操作员参数。例如:EQ，FT，GTE，AND，OR，NOT<br/>–<code class="fe ms mt mu mv b">field</code>:定义要过滤的字段。例如:卡夫卡集群(<code class="fe ms mt mu mv b">resource.kafka.id</code>)。过滤字段的完整列表可在<a class="ae ky" href="https://api.telemetry.confluent.cloud/docs#section/Object-Model/Resources" rel="noopener ugc nofollow" target="_blank">这里</a>找到。<br/>–<code class="fe ms mt mu mv b">filter</code>:定义单个指标过滤器<br/>–<code class="fe ms mt mu mv b">filters</code>:当你需要使用一组过滤器时，这个参数就派上用场了<br/>–<code class="fe ms mt mu mv b">value</code>:要过滤的值。例如:Kafka集群Id ( lkc-1qwe3)</li><li id="e5ea" class="my mz it lb b lc nh lf ni li nj lm nk lq nl lu nd ne nf ng bi translated"><code class="fe ms mt mu mv b">group_by</code>:定义如何标记响应数据。在上面的示例查询中，我决定使用<code class="fe ms mt mu mv b">consumer_group_id</code>和<code class="fe ms mt mu mv b">topic</code>对响应进行分组。group_by标签的完整列表可以在<a class="ae ky" href="https://api.telemetry.confluent.cloud/docs#section/Object-Model/Labels" rel="noopener ugc nofollow" target="_blank">这里</a>找到。</li><li id="a12d" class="my mz it lb b lc nh lf ni li nj lm nk lq nl lu nd ne nf ng bi translated"><code class="fe ms mt mu mv b">granularity</code>:定义执行指标查询的时间范围。时间范围是预定义的，我在上面的示例查询中使用了PT5M粒度。其他一些粒度是PT1M、PT15M、PT30M、PT1H等。粒度与区间参数紧密相关。因此，粒度受到查询间隔长度的限制。例如，如果我使用PT5M粒度，我的查询的最大间隔长度应该小于24小时(1天)。</li><li id="acf4" class="my mz it lb b lc nh lf ni li nj lm nk lq nl lu nd ne nf ng bi translated"><code class="fe ms mt mu mv b">intervals</code>:定义我们计划运行查询的时间范围。ISO-8601标准中应给出时间范围。</li><li id="1b50" class="my mz it lb b lc nh lf ni li nj lm nk lq nl lu nd ne nf ng bi translated"><code class="fe ms mt mu mv b">limit</code>:定义查询应该返回的最大结果数。</li></ul><p id="cfd2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">一旦您构建了定制查询(请求体)，我们就可以向Metric API端点发出API请求。然而，在发出API请求之前，我们还需要做一步就是API认证。为了验证我们的API请求，我们必须创建一个API密钥对。访问密钥可以使用汇合器的<a class="ae ky" href="https://confluent.cloud/" rel="noopener ugc nofollow" target="_blank">控制台</a>或通过<a class="ae ky" href="https://docs.confluent.io/confluent-cli/current/install.html" rel="noopener ugc nofollow" target="_blank">汇合器命令行界面</a>创建。</p><p id="a8c8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在汇合中创建云API密钥的步骤。</p><ul class=""><li id="e861" class="my mz it lb b lc ld lf lg li na lm nb lq nc lu nd ne nf ng bi translated">登录合流控制台。</li><li id="f979" class="my mz it lb b lc nh lf ni li nj lm nk lq nl lu nd ne nf ng bi translated">导航到管理部分。</li><li id="12cc" class="my mz it lb b lc nh lf ni li nj lm nk lq nl lu nd ne nf ng bi translated">选择云API密钥</li><li id="31b2" class="my mz it lb b lc nh lf ni li nj lm nk lq nl lu nd ne nf ng bi translated">选择添加密钥</li><li id="3e23" class="my mz it lb b lc nh lf ni li nj lm nk lq nl lu nd ne nf ng bi translated">最好对我们将要创建的这些键进行粒度访问。</li><li id="a5fe" class="my mz it lb b lc nh lf ni li nj lm nk lq nl lu nd ne nf ng bi translated">给你的钥匙贴上标签。</li><li id="dec9" class="my mz it lb b lc nh lf ni li nj lm nk lq nl lu nd ne nf ng bi translated">将您的API密钥和秘密密钥保存在安全的地方，因为在初始创建之后您将无法检索秘密密钥。</li></ul><p id="32e0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">生成的API Key需要作为请求头添加到API请求中，请确保对API Key进行<a class="ae ky" href="https://www.base64decode.org/" rel="noopener ugc nofollow" target="_blank"> base64编码</a>。</p><p id="d79c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">为Kafka集群“lkc-1qwe3”检索<code class="fe ms mt mu mv b">consumer_lag</code>的样本CURL请求如下所示:</p><pre class="kj kk kl km gt nm mv nn no aw np bi"><span id="fdad" class="nq lw it mv b gy nr ns l nt nu">curl --location --request POST '<a class="ae ky" href="https://api.telemetry.confluent.cloud/v2/metrics/cloud/query'" rel="noopener ugc nofollow" target="_blank">https://api.telemetry.confluent.cloud/v2/metrics/cloud/query'</a> \<br/>--header 'Content-Type: application/json' \<br/>--header 'Authorization: Basic QVBJX0tFWTpBUElfU0VDUkVUX0tFWQ==' \<br/>--data-raw '{<br/>    "aggregations": [<br/>        {<br/>            "metric": "io.confluent.kafka.server/consumer_lag_offsets"<br/>        }<br/>    ],<br/>    "filter": {<br/>        "op": "OR",<br/>        "filters": [<br/>            {<br/>                "field": "resource.kafka.id",<br/>                "op": "EQ",<br/>                "value": "lkc-1qwe3"<br/>            }<br/>        ]<br/>    },<br/>    "group_by": [<br/>        "metric.consumer_group_id",<br/>        "metric.topic"<br/>    ],<br/>    "granularity": "PT5M",<br/>    "intervals": [<br/>        "2022-05-23T18:05:22.65+05:30/2022-05-23T18:10:22.65+05:30"<br/>    ],<br/>    "limit": 100<br/>}'</span></pre><p id="636a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">您可以通过更改认证和其他特定参数(如<code class="fe ms mt mu mv b">resource.kafka.id</code>、<code class="fe ms mt mu mv b">intervals</code>)来尝试上述请求。在成功执行请求后，您应该会得到与我收到的以下内容类似的响应:</p><pre class="kj kk kl km gt nm mv nn no aw np bi"><span id="19a0" class="nq lw it mv b gy nr ns l nt nu">{<br/>    "data": [<br/>        {<br/>            "timestamp": "2022-05-23T12:40:00Z",<br/>            "value": 42.0,<br/>            "metric.topic": "TEST_TOPIC_1",<br/>            "metric.consumer_group_id": ".test-consumer-1"<br/>        },<br/>        {<br/>            "timestamp": "2022-05-23T12:40:00Z",<br/>            "value": 8.0,<br/>            "metric.topic": "TEST_TOPIC_2",<br/>            "metric.consumer_group_id": ".test-consumer-2"<br/>        }<br/>    ]<br/>}</span></pre><h1 id="e4a2" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">让我们开始吃吧</h1><p id="0e33" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">既然我们对消费者滞后指标API请求和响应有了清晰的概念，让我们继续实际的实现，在这里我使用AWS Lambda和AWS Eventbridge向Slack发送通知。下图应该会让你清楚地了解我们从现在开始努力实现的目标。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nv"><img src="../Images/103dfd813becf16bc1632883b9b09ebf.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*1uOYLfN_-hu9yflDInbxnw.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">Kafka消费者滞后通知—高级图片</p></figure><p id="45c0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如上图所示，我将使用无服务器框架创建一个lambda函数，并将其与Eventbridge规则一起部署到AWS中。预定的Eventbridge规则将定期调用lambda函数。Lambda函数将调用Confluent的Metric API来收集消费者滞后数据。</p><p id="ac3c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果滞后数据超过预定义的阈值，Lambda功能将向预配置的松弛信道发送通知。</p><h2 id="6707" class="nq lw it bd lx nw nx dn mb ny nz dp mf li oa ob mh lm oc od mj lq oe of ml og bi translated">带有Eventbridge的AWS Lambda</h2><p id="d989" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">首先，我从这里的<a class="ae ky" href="https://start.spring.io/" rel="noopener ugc nofollow" target="_blank">创建了一个简单的java spring boot应用程序。完整的代码可以在我的</a><a class="ae ky" href="https://github.com/cnf271/serverless-kafka-consumer-lag-monitor" rel="noopener ugc nofollow" target="_blank"> GitHub </a>资源库中找到。</p><p id="59e7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在下面的外观中，一旦我们部署到AWS Lambda中，<code class="fe ms mt mu mv b">evaluateTopicConsumerLag()</code>就会在预定义的时间间隔内被调用。<code class="fe ms mt mu mv b">evaluateTopicConsumerLag()</code>方法最初使用提供的凭证从汇合度量API中检索Kafka主题消费者滞后数据。随后，根据预定义的阈值评估消费者滞后数据。之后，被标记的消费者被一个接一个地送到空闲通道。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mw mx l"/></div></figure><h2 id="926e" class="nq lw it bd lx nw nx dn mb ny nz dp mf li oa ob mh lm oc od mj lq oe of ml og bi translated">使用Slack webhook APIs发送通知</h2><p id="49a7" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">正如介绍中提到的，我将向一个松弛通道发送通知警报。您可以决定如何接收通知。因此，在下面的步骤中，我将解释如何创建一个Slack webhook端点来向Slack通道发送警报。</p><p id="0640" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">您可以自由使用现有的松弛信道或创建新的信道来接收警报。我创建了一个专门的频道#kafka-consumer-lag-alerts来接收消费者滞后提醒。</p><p id="7a28" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">创建一个Slack应用程序和一个Webhook端点。</p><p id="a567" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">导航到Slack Web <a class="ae ky" href="https://api.slack.com/apps" rel="noopener ugc nofollow" target="_blank">应用控制台</a>，如果没有应用，创建一个新的应用。我在我的个人Slack工作空间中创建了一个名为alerts的新应用。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi oh"><img src="../Images/fe6960f1e350bd590440c229d324fc16.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*1W62AaS1dgRTwWkuxnErtQ.jpeg"/></div></div></figure><p id="52e1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在让我们给这个应用程序添加一个频道。导航到Incoming Webhooks功能，并按照所需步骤添加频道。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi oh"><img src="../Images/2d3ec0263d51a40cdaebdc3ea36132fc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*0w8GaiPL1shlPvYsWjDB4w.jpeg"/></div></div></figure><p id="028d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我在应用程序中使用了Webhook URL作为环境变量<code class="fe ms mt mu mv b">SLACK_WEBHOOK_URL</code>。请参考<a class="ae ky" href="https://github.com/cnf271/serverless-kafka-consumer-lag-monitor" rel="noopener ugc nofollow" target="_blank"> GitHub </a>库来检查Slack实现。</p><h2 id="aca7" class="nq lw it bd lx nw nx dn mb ny nz dp mf li oa ob mh lm oc od mj lq oe of ml og bi translated">在AWS中部署Lambda函数</h2><p id="fe8f" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">在我们可以将Lambda函数部署到云中的许多方法中，我大部分时间使用<a class="ae ky" href="https://www.serverless.com/" rel="noopener ugc nofollow" target="_blank">无服务器框架</a>，因为它在配置上很简单。</p><p id="397b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果您尚未安装无服务器框架，请参考本<a class="ae ky" href="https://www.serverless.com/framework/docs/getting-started" rel="noopener ugc nofollow" target="_blank">指南</a>在您的本地机器上安装无服务器框架。安装框架后，您需要做的就是在我们的应用程序的根目录中添加serverless.yml类。我们可以在<code class="fe ms mt mu mv b">serverless.yml</code>文件中包含与应用程序相关的配置级别信息，比如应用程序运行时、部署函数的区域和环境变量。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mw mx l"/></div></figure><p id="6df4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">参考上面的文件，我已经使用了无服务器框架中的环境特性来将变量传递给我的应用程序。yml类从。env文件，并将它们传递给应用程序。一旦我们部署了应用程序，我们就可以在lambda控制台中检查这些值。</p><p id="55d0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">请注意，为了创建本教程，我将敏感信息如<code class="fe ms mt mu mv b">KAFKA_MONITOR_API_KEY</code>和<code class="fe ms mt mu mv b">KAFKA_MONITOR_SECRET_KEY</code>作为环境变量传递。我不建议你在实际实现的时候这么做，我强烈建议使用<a class="ae ky" href="https://docs.aws.amazon.com/lambda/latest/dg/configuration-envvars.html" rel="noopener ugc nofollow" target="_blank"> AWS KMS管理器</a>来保护你的环境变量。此外，您可以使用<a class="ae ky" href="https://docs.aws.amazon.com/systems-manager/latest/userguide/systems-manager-parameter-store.html" rel="noopener ugc nofollow" target="_blank"> AWS参数存储库</a>或<a class="ae ky" href="https://docs.aws.amazon.com/secretsmanager/latest/userguide/intro.html" rel="noopener ugc nofollow" target="_blank"> AWS秘密管理器</a>来存储和检索敏感信息。</p><p id="61a5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">下面的代码片段将创建一个AWS Eventbridge规则，它每五分钟调用一次Lambda函数。</p><pre class="kj kk kl km gt nm mv nn no aw np bi"><span id="c6c9" class="nq lw it mv b gy nr ns l nt nu">events:<br/>  - schedule: rate(5 minutes)</span></pre><p id="04b4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在一切就绪，让我们将我们的功能部署到AWS中。在通过CLI将此功能部署到AWS之前，请确保您已经在本地配置了<a class="ae ky" href="https://docs.aws.amazon.com/cli/latest/userguide/cli-configure-files.html" rel="noopener ugc nofollow" target="_blank">AWS凭证。</a></p><p id="11f5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们使用下面的命令构建我们的Java maven项目。下面的命令将在目标目录中创建一个可执行的jar，它已经在serverless.yml中作为打包的工件使用。</p><pre class="kj kk kl km gt nm mv nn no aw np bi"><span id="1848" class="nq lw it mv b gy nr ns l nt nu">mvn clean install</span></pre><p id="b943" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们在根目录中执行以下命令，将我们的功能部署到AWS中:</p><pre class="kj kk kl km gt nm mv nn no aw np bi"><span id="395c" class="nq lw it mv b gy nr ns l nt nu">serverless deploy<br/>OR<br/>sls deploy</span></pre><p id="acad" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果我们在应用程序的实现或配置过程中没有搞砸任何事情，上面的命令应该将我们的功能部署到Lambda控制台中。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi oi"><img src="../Images/df6579576ffb94aa8bcb2c073a4da414.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*8TZiVAYJu3d3uPae5pfsUQ.jpeg"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">SLS部署的执行结果</p></figure><p id="20a0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们回到AWS来检查我们的应用程序在Lambda控制台上是否可见。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi oj"><img src="../Images/cea0e716a1fe802cd139a119d815cc76.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ZAW25v5rzdw1kw9ZXchjPw.jpeg"/></div></div></figure><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ok"><img src="../Images/b837b1513604f36fb2dd5a898ad860af.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*e9g3WFSdXdNqU3v3KFYwyw.jpeg"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">带有EventBridge规则的Lambda函数</p></figure><p id="2234" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">上图显示，lambda函数已经成功部署了五分钟间隔Eventbridge规则。</p><h1 id="674a" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">让我们测试Lambda函数</h1><p id="a19d" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">根据我们添加的Eventbridge规则，我们的函数每五分钟调用一次。然而，出于测试目的，我们可以使用Lambda控制台提供的测试功能来调用Lambda函数。</p><p id="0954" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在一次成功的测试调用之后，我收到了下面的slack消息。您可以自由地将<a class="ae ky" href="https://emoji.slack-edge.com/TL6QD3196/alert/940122083239eb24.gif" rel="noopener ugc nofollow" target="_blank">提醒</a>图标添加到您的Slack表情集合中。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ol"><img src="../Images/622baea41c4baca8ea315909c51aaec5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*pQMXoGiAXcagIF-MidAa1w.jpeg"/></div></div></figure><p id="c660" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">本教程的完整代码可以通过<a class="ae ky" href="https://github.com/cnf271/serverless-kafka-consumer-lag-monitor" rel="noopener ugc nofollow" target="_blank"> GitHub </a>访问。</p><h1 id="918c" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated"><strong class="ak">参考文献</strong></h1><ol class=""><li id="d118" class="my mz it lb b lc mn lf mo li om lm on lq oo lu op ne nf ng bi translated">融合云指标-<a class="ae ky" href="https://docs.confluent.io/cloud/current/monitoring/metrics-api.html" rel="noopener ugc nofollow" target="_blank">https://docs . confluent . io/Cloud/current/monitoring/Metrics-API . html</a></li><li id="f56c" class="my mz it lb b lc nh lf ni li nj lm nk lq nl lu op ne nf ng bi translated">slack Web API-【https://api.slack.com/web T2】</li><li id="3bc1" class="my mz it lb b lc nh lf ni li nj lm nk lq nl lu op ne nf ng bi translated">无服务器框架文档-【https://www.serverless.com/framework/docs T4】</li></ol></div></div>    
</body>
</html>