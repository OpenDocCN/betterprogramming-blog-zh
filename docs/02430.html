<html>
<head>
<title>Functional Fundamentals: Currying</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">功能基础:Currying</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/functional-fundamentals-currying-576b8cd3080d?source=collection_archive---------3-----------------------#2019-11-30">https://betterprogramming.pub/functional-fundamentals-currying-576b8cd3080d?source=collection_archive---------3-----------------------#2019-11-30</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="2fc4" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">冷静看待函数式编程中最令人困惑的概念之一</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/06d2215c0883b71d047ac0356112b3c2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*qbX4ZzIcNGdBjILh"/></div></div></figure><p id="02dc" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">这是本博客讨论函数式编程概念的第二篇文章。下面是第一个链接，<a class="ae lq" href="https://thesharperdev.com/pure-v-impure-functions/" rel="noopener ugc nofollow" target="_blank"> <em class="lr">纯函数与不纯函数</em> </a>。</p><p id="f91b" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">前一段时间，我看了Scott Wlaschin在一个关于函数式编程的会议上的演讲。他说，不懂函数式编程的人经常会被术语T7和T8吓跑。诸如currying、部分应用、函子、单子等术语。</p><p id="9516" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">人们很容易认为这些是超级复杂的概念，但实际上，这些术语并不熟悉。</p><p id="f5fa" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">面向对象编程有类似的术语、封装、多态、继承等。我们刚刚接触到这些术语，所以它们已经不再可怕。</p><p id="fba5" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">今天，我们就来切入正题，逢迎。</p></div><div class="ab cl ls lt hx lu" role="separator"><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx"/></div><div class="im in io ip iq"><h1 id="7fad" class="lz ma it bd mb mc md me mf mg mh mi mj jz mk ka ml kc mm kd mn kf mo kg mp mq bi translated">面向对象领域的方法参数</h1><p id="37b1" class="pw-post-body-paragraph ku kv it kw b kx mr ju kz la ms jx lc ld mt lf lg lh mu lj lk ll mv ln lo lp im bi translated">在大多数OO风格的编程语言中，<a class="ae lq" href="https://docs.microsoft.com/en-us/dotnet/csharp/" rel="noopener ugc nofollow" target="_blank"> C# </a>，Java，Python，C/C++等。一个方法有一定数量的参数。</p><p id="e848" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">以这个连接字符串的C#方法为例。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mw mx l"/></div></figure><p id="e88d" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">它接受两个字符串作为输入，并返回一个字符串。</p><p id="f6a8" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">每次调用此方法时，都必须提供两个参数。如果不这样做，C#编译器会报错。</p></div><div class="ab cl ls lt hx lu" role="separator"><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx"/></div><div class="im in io ip iq"><h1 id="d306" class="lz ma it bd mb mc md me mf mg mh mi mj jz mk ka ml kc mm kd mn kf mo kg mp mq bi translated">功能用地中的功能参数</h1><p id="c816" class="pw-post-body-paragraph ku kv it kw b kx mr ju kz la ms jx lc ld mt lf lg lh mu lj lk ll mv ln lo lp im bi translated">另一方面，在大多数函数式编程语言中，<a class="ae lq" href="https://fsharp.org/" rel="noopener ugc nofollow" target="_blank"> F# </a>、<a class="ae lq" href="https://elm-lang.org/" rel="noopener ugc nofollow" target="_blank"> Elm </a>、<a class="ae lq" href="https://www.haskell.org/" rel="noopener ugc nofollow" target="_blank"> Haskell </a>等。，函数参数被不同地定义和利用。</p><p id="7536" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">下面是我们如何在Elm中定义一个函数，该函数在返回输出字符串之前需要两个字符串作为输入。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mw mx l"/></div></figure><p id="4cbf" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">请注意，在Elm中，函数的定义与实现在不同的行上。很多函数式语言都是这样。</p><p id="7448" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">还要注意定义的格式是不同的，<code class="fe my mz na nb b">“string -&gt; string -&gt; string”</code>。如果你以前从未接触过函数式语言，那可能有点奇怪。</p><p id="2047" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">在F#中定义一个类似的函数有点不同。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mw mx l"/></div></figure><p id="6e3d" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">但是签名是一样的，下面是这个函数在VS代码中使用<a class="ae lq" href="http://ionide.io/" rel="noopener ugc nofollow" target="_blank"> Ionide </a>插件的截图。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi nc"><img src="../Images/10ef9fb12b9726a0c36c519cadf117e8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1172/0*pMYYYpWUoeJwk0tN"/></div></figure><p id="c8c9" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">Ionide自动添加了<code class="fe my mz na nb b">(// string -&gt; string -&gt; string)</code>函数定义，您会注意到它与Elm的相同。</p><p id="f0cd" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">尽管这需要两个字符串作为输入，但我只能给它一个，编译器对此没有任何问题。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mw mx l"/></div></figure><p id="a746" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated"><code class="fe my mz na nb b">concateWordWith</code>的签名现在是<code class="fe my mz na nb b">“string -&gt; string”</code>。</p><p id="4c22" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">或者，我可以给它两个参数，但是在两组括号里。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mw mx l"/></div></figure><p id="50b6" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">这是为什么呢？</p><p id="5065" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">原因是因为阿谀奉承。</p></div><div class="ab cl ls lt hx lu" role="separator"><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx"/></div><div class="im in io ip iq"><h1 id="4f72" class="lz ma it bd mb mc md me mf mg mh mi mj jz mk ka ml kc mm kd mn kf mo kg mp mq bi translated">柯林解释道</h1><p id="5d6b" class="pw-post-body-paragraph ku kv it kw b kx mr ju kz la ms jx lc ld mt lf lg lh mu lj lk ll mv ln lo lp im bi translated">Currying是一种完全不同的处理函数参数的方式。在面向对象语言中，要么全有，要么全无。如果一个方法有三个输入，给我三个输入或者嘣！编译错误。</p><p id="5cbe" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">Curried函数提供了更多的灵活性。他们让你随着时间的推移建立输入参数。你现在可以给出一个输入。然后，稍后，给它另一个输入。最后，也是使用前的最后一个。</p><p id="22b7" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">换个方式说:如果一个函数有三个输入，你只给它一个，它会返回一个有两个输入的函数。然后，你可以给这个双输入函数一个输入，它将返回一个接受一个输入的函数。</p><p id="3e4c" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">然后你可以给这个输入函数一个输入，它最终会返回输出。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mw mx l"/></div></figure><p id="9f6e" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">所以，如果你看到一个函数有一个<code class="fe my mz na nb b">“string -&gt; string -&gt; string”</code>的签名，一个面向对象的方法来描述它应该是“一个函数接受两个字符串作为输入，返回一个字符串作为输出”。</p><p id="6f91" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">一种更实用的描述方式是“一个接受字符串的函数，返回一个接受字符串的中间函数，返回一个字符串。</p><p id="3b15" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">因为currying，在大多数函数式编程语言中没有多参数函数这种东西。如果您传递多个参数，它们实际上是一次一个地应用于一系列中间函数。编译器会自动为您完成这项工作。</p><p id="b3d2" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">事实上，<a class="ae lq" href="https://en.wikipedia.org/wiki/Currying" rel="noopener ugc nofollow" target="_blank">维基百科</a>对阿谀奉承的定义是:</p><blockquote class="nd"><p id="c5a7" class="ne nf it bd ng nh ni nj nk nl nm lp dk translated">“……将带有多个参数的函数的计算转化为带有单个参数的函数序列的计算的技术。”</p></blockquote><p id="f857" class="pw-post-body-paragraph ku kv it kw b kx nn ju kz la no jx lc ld np lf lg lh nq lj lk ll nr ln lo lp im bi translated">所以，把每个论点分解成独立的函数。</p></div><div class="ab cl ls lt hx lu" role="separator"><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx"/></div><div class="im in io ip iq"><h1 id="bf1c" class="lz ma it bd mb mc md me mf mg mh mi mj jz mk ka ml kc mm kd mn kf mo kg mp mq bi translated">为什么阿谀奉承有用？</h1><p id="e6db" class="pw-post-body-paragraph ku kv it kw b kx mr ju kz la ms jx lc ld mt lf lg lh mu lj lk ll mv ln lo lp im bi translated">所以，现在你知道了什么是currying，下一个合乎逻辑的问题就是:“它有用吗？”这仅仅是那些“功能性”的东西中的一种，它们的存在只是为了让生活变得更加复杂吗？</p><p id="e7a2" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">在支持currying的语言中，currying为调用函数提供了很大的灵活性。</p><p id="b887" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">以下面这个C#中的例子为例，它给列表中的每个数字加2。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mw mx l"/></div></figure><p id="a4f1" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">相当简单的代码。下面是如何在F#中不利用currying*就能做到这一点。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mw mx l"/></div></figure><p id="1065" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">相当简单。但是由于F# curries函数，这里有一个更函数化的方法。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mw mx l"/></div></figure><p id="1560" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated"><code class="fe my mz na nb b">add</code>函数有两个输入，但是在这个例子中我们给了它一个输入(2)。然后，让<code class="fe my mz na nb b">List.map</code>提供第二个输入，列表的每个元素一个输入。</p><p id="b5d2" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">诚然，这并不是改变世界的差异。在我的日常工作中，我写C#，所以我一直在处理非curried函数。但是如果你花足够的时间在一门课程语言上，你就会开始错过那些小捷径和小细节。</p><p id="d856" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">*是的，每个函数都是自动生成的，所以从技术上讲，这不是一个正确的说法。但与下一个例子不同。</p></div><div class="ab cl ls lt hx lu" role="separator"><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx"/></div><div class="im in io ip iq"><h1 id="5e28" class="lz ma it bd mb mc md me mf mg mh mi mj jz mk ka ml kc mm kd mn kf mo kg mp mq bi translated">包扎</h1><p id="33dd" class="pw-post-body-paragraph ku kv it kw b kx mr ju kz la ms jx lc ld mt lf lg lh mu lj lk ll mv ln lo lp im bi translated">使用函数式语言时，Currying是一个需要了解的重要概念。这是一个很棒的语言特性，在任何地方都很方便。</p><p id="e82b" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">Currying只是我在OO世界中从未接触过的许多概念之一。我希望你花一些时间来学习函数式编程和它所提供的所有独特的特性。</p></div><div class="ab cl ls lt hx lu" role="separator"><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx"/></div><div class="im in io ip iq"><h1 id="9e79" class="lz ma it bd mb mc md me mf mg mh mi mj jz mk ka ml kc mm kd mn kf mo kg mp mq bi translated">来源</h1><ul class=""><li id="d955" class="ns nt it kw b kx mr la ms ld nu lh nv ll nw lp nx ny nz oa bi translated"><a class="ae lq" href="https://en.wikipedia.org/wiki/Currying" rel="noopener ugc nofollow" target="_blank">维基百科:阿谀奉承</a></li><li id="d14b" class="ns nt it kw b kx ob la oc ld od lh oe ll of lp nx ny nz oa bi translated"><a class="ae lq" href="https://softwareengineering.stackexchange.com/questions/185585/what-is-the-advantage-of-currying" rel="noopener ugc nofollow" target="_blank">拍马屁有什么好处？</a> —堆叠交换</li><li id="687f" class="ns nt it kw b kx ob la oc ld od lh oe ll of lp nx ny nz oa bi translated">函数式编程中curry有什么优势 — Quora</li></ul></div></div>    
</body>
</html>