<html>
<head>
<title>How the React Reconciliation Algorithm Works</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">React协调算法的工作原理</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/how-the-react-reconciliation-algorithm-works-e29bf77a4d78?source=collection_archive---------11-----------------------#2020-05-25">https://betterprogramming.pub/how-the-react-reconciliation-algorithm-works-e29bf77a4d78?source=collection_archive---------11-----------------------#2020-05-25</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="1bb0" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">JavaScript中使用最多的UI库是什么？</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/7f0702952ff091e83e829ad2ef319d47.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*_FwPWO125YNveVWB"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">由<a class="ae ky" href="https://unsplash.com/@mecdjino?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Sitraka Rakotoarivelo </a>在<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>拍摄的照片。</p></figure><p id="0f14" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">React是数百万人使用的UI库，他们有充分的理由这样做。React是第一个实现真正的反应式开发用户界面的方法，它可以在任何可以想象的平台上工作。但是很少有人知道，如果没有React协调算法，这一切都是不可能的。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="b2ae" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">画一些按钮有什么难的？</h1><p id="0b97" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">当使用React开发时，很容易忘记(或者根本不知道)创建和管理UI的必要方式。打个比方，React让您“描述”您想要的接口，而本机库和框架必须使用原语“构建”它。因此，虽然对您来说它看起来像一个return语句，但在本机代码中它会转换成数百个对象、赋值和表达式。</p><p id="3a71" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">更新本地(DOM或平台)接口不是一个简单的过程。谢天谢地，我们不必经常这样做。大多数时候，你的应用程序不会在每次渲染时完全改变UI结构。通常，按钮会改变颜色，或者标签会更新文本。在少数情况下，当一切都改变时(导航到另一个屏幕)，我们将不得不处理它。但是React如何知道对底层接口最有效的改变是什么呢？协调算法。</p><p id="d3c3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">你可能熟悉一种叫做<code class="fe mz na nb nc b">tree</code> <em class="nd">的数据结构。即使你不是，你也每天都在使用它。树是节点(组件)的集合。每个节点都可以有自己是节点的子节点。基本上，JSX和HTML都可以被描述为树。</em></p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi ne"><img src="../Images/03fa612d514fdeccd13e1156de4c083e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1360/0*IjyNZWsDvxqBl4qO"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">作者照片。</p></figure><p id="6cf3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">然后，协调算法比较两棵树，并返回一组操作来更新第二棵树，使其与第一棵树匹配。在计算机科学领域，这被称为<a class="ae ky" href="https://grfia.dlsi.ua.es/ml/algorithms/references/editsurvey_bille.pdf" rel="noopener ugc nofollow" target="_blank">树距离问题</a>。当然，它有几个通用的解决方案，但是它们的复杂度是<em class="nd"> O(n ) </em>，完全不适合用户界面。为了让它更快，React团队不得不做出一些权衡。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="d5eb" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">调和算法是如何解决问题的？</h1><p id="ef82" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">回想一下，该算法针对用户界面进行了优化，以及我们之前所做的关于用户界面的假设。这些是调和算法的基础。根据这些假设，算法采取以下措施:</p><ol class=""><li id="f139" class="nf ng it lb b lc ld lf lg li nh lm ni lq nj lu nk nl nm nn bi translated">如果一个节点已经改变了它的类型(<code class="fe mz na nb nc b">H1</code> - &gt; <code class="fe mz na nb nc b">MARKUEE</code>或<code class="fe mz na nb nc b">View</code> - &gt; <code class="fe mz na nb nc b">Text</code>)，那么旧的节点将被删除，新的节点将从头开始递归渲染。</li><li id="e5a8" class="nf ng it lb b lc no lf np li nq lm nr lq ns lu nk nl nm nn bi translated">如果两棵树中的两个节点具有相同的<code class="fe mz na nb nc b">key</code>属性，那么它们就是同一个节点，无需创建新的节点就可以被重用。</li></ol><p id="fc93" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">使用这些作为公理，你可以很容易地推导出算法的其余部分。如果节点不同，旧的会被删除，新的会从头开始创建。如果节点是相同的，该算法将比较其属性，对它们进行必要的更改，并继续递归到子节点。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="fd79" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">调和算法的缺点</h1><p id="b423" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">由于这些都是折衷方案，它们会带来一些不想要的结果。考虑一个项目列表。它可能有数百个相同类型的节点，可以编辑和重新排列。如果我们要重新排列它们，协调算法将不知道两棵树中的哪些是哪些，从而导致完全重新渲染。</p><p id="b68a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这就是<code class="fe mz na nb nc b">key</code>发挥作用的地方。如果您为每个列表项分配一个唯一的键，算法将很容易在树之间匹配它们，不会有任何问题。这也是为什么绝不能使用数组索引或随机数作为键的原因。如果您使用索引并且重新排列了项目，它们的索引将会改变。算法会以错误的方式匹配节点，你的用户界面会完全不可预测。如果您使用在每次渲染时生成的随机数，将不会破坏任何东西，但这将是非常低效的，因为每次渲染时每个节点都将从头开始重新创建。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="1d4e" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">结束语</h1><p id="00ce" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">感谢您的阅读。我希望你喜欢这篇文章。React的并发模式将对React处理UI的方式带来一些变化，敬请关注更新！</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="8ee6" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">资源</h1><ul class=""><li id="837c" class="nf ng it lb b lc mu lf mv li nt lm nu lq nv lu nw nl nm nn bi translated"><code class="fe mz na nb nc b"><a class="ae ky" href="https://github.com/facebook/react/tree/master/packages/react-reconciler" rel="noopener ugc nofollow" target="_blank">react-reconciler</a></code> <a class="ae ky" href="https://github.com/facebook/react/tree/master/packages/react-reconciler" rel="noopener ugc nofollow" target="_blank">包</a></li><li id="6031" class="nf ng it lb b lc no lf np li nq lm nr lq ns lu nw nl nm nn bi translated"><a class="ae ky" href="http://tree-edit-distance.dbresearch.uni-salzburg.at/" rel="noopener ugc nofollow" target="_blank">树编辑距离问题</a></li></ul></div></div>    
</body>
</html>