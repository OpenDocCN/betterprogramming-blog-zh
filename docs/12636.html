<html>
<head>
<title>How to Use Docker Bind Mounts and the CLI</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何使用Docker绑定挂载和CLI</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/sharing-is-caring-using-docker-bind-mounts-and-the-cli-34ff6f7cc0b2?source=collection_archive---------2-----------------------#2022-06-18">https://betterprogramming.pub/sharing-is-caring-using-docker-bind-mounts-and-the-cli-34ff6f7cc0b2?source=collection_archive---------2-----------------------#2022-06-18</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="1e63" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">分享是关怀</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/2e2ec5bb5b219ff320a0205b58e4b81f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*SEyTa8xKi2jipZBBuBLdHQ.png"/></div></div></figure><p id="0cd5" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">就像Snapchat上那些令人遗憾的滤镜自拍一样，Docker容器被设计成短暂的——当容器消失时，内部数据也随之消失。</p><p id="04ca" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">幸运的是，有办法用Docker容器存储持久数据。在下面详细介绍的演练中，Docker初学者将能够使用CLI命令探索Docker容器的<code class="fe ln lo lp lq b">bind mounts</code>。</p><p id="a15c" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">对于更有冒险精神的Docker用户，我建议使用Docker Compose探索Docker卷——敬请关注该演练！</p><h1 id="e07f" class="lr ls iq bd lt lu lv lw lx ly lz ma mb jw mc jx md jz me ka mf kc mg kd mh mi bi translated">目标</h1><p id="3ab6" class="pw-post-body-paragraph kr ks iq kt b ku mj jr kw kx mk ju kz la ml lc ld le mm lg lh li mn lk ll lm ij bi translated">对于本演练，我将使用CLI构建和部署两个具有相同映像和网络的容器，每个容器都使用一种方法来处理持久数据；<em class="mo">绑定装载</em>又称<em class="mo">主机卷</em>。</p><h2 id="2385" class="mp ls iq bd lt mq mr dn lx ms mt dp mb la mu mv md le mw mx mf li my mz mh na bi translated">绑定安装</h2><p id="9009" class="pw-post-body-paragraph kr ks iq kt b ku mj jr kw kx mk ju kz la ml lc ld le mm lg lh li mn lk ll lm ij bi translated">绑定挂载，或<em class="mo">主机卷</em>，允许文件或目录从它们在主机上的绝对路径位置直接挂载到容器。</p><p id="910b" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">这种方法依赖于主机的目录和文件结构，因此不可移植。</p><p id="f4a3" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">该选项的管理通常发生在Docker之外，这可能会导致权限问题。此外，还存在提供对主机文件系统的访问权限的风险。</p><h1 id="a71f" class="lr ls iq bd lt lu lv lw lx ly lz ma mb jw mc jx md jz me ka mf kc mg kd mh mi bi translated">环境和先决条件</h1><p id="aa8b" class="pw-post-body-paragraph kr ks iq kt b ku mj jr kw kx mk ju kz la ml lc ld le mm lg lh li mn lk ll lm ij bi translated">下面的规范是我用来完成本文中详细描述的任务的:</p><h2 id="4db8" class="mp ls iq bd lt mq mr dn lx ms mt dp mb la mu mv md le mw mx mf li my mz mh na bi translated">我的本地机器和操作系统</h2><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nb"><img src="../Images/bc53ace9fd82945d2ca2e03aa1c01018.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*MjCe4MgiDvO_zYhzVSmodw.png"/></div></div><p class="nc nd gj gh gi ne nf bd b be z dk translated"><em class="ng"> MacBook Pro，2017；蒙特雷诉第12.4条</em></p></figure><h2 id="4455" class="mp ls iq bd lt mq mr dn lx ms mt dp mb la mu mv md le mw mx mf li my mz mh na bi translated">集成开发环境</h2><ul class=""><li id="31e8" class="nh ni iq kt b ku mj kx mk la nj le nk li nl lm nm nn no np bi translated"><strong class="kt ir">Visual Studio Code</strong><em class="mo">v . 1.68(通常称为“VSCode”)→添加这个VSCode扩展</em>:<strong class="kt ir"><em class="mo">Remote—SSH</em></strong>(<em class="mo">我需要将这个扩展添加到vs Code，以便轻松地SSH到我的EC2实例</em>)。<em class="mo">这里有一个很有帮助的</em> <a class="ae nq" href="https://www.youtube-nocookie.com/embed/dS0dX3SGMAM?playlist=dS0dX3SGMAM&amp;autoplay=1&amp;iv_load_policy=3&amp;loop=1&amp;modestbranding=1&amp;start=" rel="noopener ugc nofollow" target="_blank"> <em class="mo">视频教程</em> </a> <em class="mo">的设置，或者用这个</em> <a class="ae nq" href="https://dev.to/dre4success/ssh-to-an-ec2-instance-from-vs-code-2707" rel="noopener ugc nofollow" target="_blank"> <em class="mo">分步指导</em> </a> <em class="mo">。</em></li></ul><div class="kg kh ki kj gt ab cb"><figure class="nr kk ns nt nu nv nw paragraph-image"><img src="../Images/2d1bf0c7f6a867527fc7bda4b457e441.png" data-original-src="https://miro.medium.com/v2/resize:fit:144/format:webp/1*fd8QJOZIBACQQUaZtDVi9w.png"/></figure><figure class="nr kk nx nt nu nv nw paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><img src="../Images/ebadb9d261bccee9f7a53b5a4489ec05.png" data-original-src="https://miro.medium.com/v2/resize:fit:1594/format:webp/1*VkMy68rV02gUDrvh1GSGGg.png"/></div><p class="nc nd gj gh gi ne nf bd b be z dk ny di nz oa translated">虚拟工作室代码v. 1.86 for Mac，远程SSH扩展</p></figure></div><h2 id="86d8" class="mp ls iq bd lt mq mr dn lx ms mt dp mb la mu mv md le mw mx mf li my mz mh na bi translated">虚拟服务器</h2><ul class=""><li id="3b71" class="nh ni iq kt b ku mj kx mk la nj le nk li nl lm nm nn no np bi translated"><strong class="kt ir"> AWS EC2实例</strong></li></ul><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi ob"><img src="../Images/4a6a6c171004cc0bffe6b8a04ffcc1f4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*KQcYi2iFdqIkXn0txkHpvA.png"/></div></div><p class="nc nd gj gh gi ne nf bd b be z dk translated">实例AMI —运行Ubuntu 22.04 LTS海哲明</p></figure></div><div class="ab cl oc od hu oe" role="separator"><span class="of bw bk og oh oi"/><span class="of bw bk og oh oi"/><span class="of bw bk og oh"/></div><div class="ij ik il im in"><h1 id="e89c" class="lr ls iq bd lt lu oj lw lx ly ok ma mb jw ol jx md jz om ka mf kc on kd mh mi bi translated">任务</h1><ol class=""><li id="023d" class="nh ni iq kt b ku mj kx mk la nj le nk li nl lm oo nn no np bi translated">安装Docker并确保Docker守护进程正在运行</li><li id="62a6" class="nh ni iq kt b ku op kx oq la or le os li ot lm oo nn no np bi translated">创建两个本地目录——一个名为<code class="fe ln lo lp lq b">webfiles</code>,包含以下文件:<code class="fe ln lo lp lq b">infofile.txt</code>和<code class="fe ln lo lp lq b">exportfile.txt</code>,另一个名为<code class="fe ln lo lp lq b">webexport</code>,包含文件<code class="fe ln lo lp lq b">websales.txt</code>。</li><li id="cfbc" class="nh ni iq kt b ku op kx oq la or le os li ot lm oo nn no np bi translated">创建一个名为<code class="fe ln lo lp lq b">webnet</code>的Docker网络</li><li id="45dc" class="nh ni iq kt b ku op kx oq la or le os li ot lm oo nn no np bi translated">启动两个带有CentOS映像的容器，并将其分配给<code class="fe ln lo lp lq b">webnet</code>网络</li><li id="63bc" class="nh ni iq kt b ku op kx oq la or le os li ot lm oo nn no np bi translated">在两个容器中创建本地目录<code class="fe ln lo lp lq b">webfiles</code>的挂载点</li><li id="c921" class="nh ni iq kt b ku op kx oq la or le os li ot lm oo nn no np bi translated">验证两个容器都能看到<code class="fe ln lo lp lq b">infofile.txt</code>和<code class="fe ln lo lp lq b">exportfile.txt</code></li></ol></div><div class="ab cl oc od hu oe" role="separator"><span class="of bw bk og oh oi"/><span class="of bw bk og oh oi"/><span class="of bw bk og oh"/></div><div class="ij ik il im in"><h1 id="08cd" class="lr ls iq bd lt lu oj lw lx ly ok ma mb jw ol jx md jz om ka mf kc on kd mh mi bi translated">安装Docker并确保Docker守护进程正在运行</h1><p id="1619" class="pw-post-body-paragraph kr ks iq kt b ku mj jr kw kx mk ju kz la ml lc ld le mm lg lh li mn lk ll lm ij bi translated">有几种安装Docker的方法，但是，我选择从存储库中安装，就像在新的主机上一样。文档<a class="ae nq" href="https://docs.docker.com/engine/install/ubuntu/" rel="noopener ugc nofollow" target="_blank">很容易理解:</a></p><blockquote class="ou ov ow"><p id="2315" class="kr ks mo kt b ku kv jr kw kx ky ju kz ox lb lc ld oy lf lg lh oz lj lk ll lm ij bi translated"><strong class="kt ir">设置存储库</strong></p></blockquote><ol class=""><li id="3e21" class="nh ni iq kt b ku kv kx ky la pa le pb li pc lm oo nn no np bi translated">更新包并允许<code class="fe ln lo lp lq b">apt</code>通过https使用存储库:</li></ol><pre class="kg kh ki kj gt pd lq pe pf aw pg bi"><span id="8a2d" class="mp ls iq lq b gy ph pi l pj pk">$ sudo apt-get update<br/><br/>$ sudo apt-get install \<br/>    ca-certificates \<br/>    curl \<br/>    gnupg \<br/>    lsb-release</span></pre><p id="7262" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">2.添加Docker的官方GPG密钥。这将在安装前验证软件的完整性。</p><pre class="kg kh ki kj gt pd lq pe pf aw pg bi"><span id="62e5" class="mp ls iq lq b gy ph pi l pj pk">$ sudo mkdir -p /etc/apt/keyrings<br/>$ curl -fsSL https://download.docker.com/linux/ubuntu/gpg | sudo gpg --dearmor -o /etc/apt/keyrings/docker.gpg</span></pre><p id="8410" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">3.设置存储库。这个命令会将Ubuntu 22.04海哲明版的Docker库添加到<code class="fe ln lo lp lq b">apt</code>源代码中。</p><pre class="kg kh ki kj gt pd lq pe pf aw pg bi"><span id="47f3" class="mp ls iq lq b gy ph pi l pj pk">$ echo \<br/>"deb [arch=$(dpkg --print-architecture) signed-     by=/etc/apt/keyrings/docker.gpg]https://download.docker.com/linux/ubuntu \<br/>$(lsb_release -cs) stable" | sudo tee /etc/apt/sources.list.d/docker.list &gt; /dev/null</span></pre><blockquote class="ou ov ow"><p id="9e36" class="kr ks mo kt b ku kv jr kw kx ky ju kz ox lb lc ld oy lf lg lh oz lj lk ll lm ij bi translated"><strong class="kt ir">安装码头工人</strong></p></blockquote><ol class=""><li id="f51c" class="nh ni iq kt b ku kv kx ky la pa le pb li pc lm oo nn no np bi translated">再次更新<code class="fe ln lo lp lq b">apt</code>包，安装最新版本的Docker。</li></ol><pre class="kg kh ki kj gt pd lq pe pf aw pg bi"><span id="202d" class="mp ls iq lq b gy ph pi l pj pk">$ sudo apt-get update</span><span id="4b4d" class="mp ls iq lq b gy pl pi l pj pk">$ sudo apt-get install docker-ce docker-ce-cli containerd.io docker-compose-plugin</span></pre><p id="7b25" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">2.使用<code class="fe ln lo lp lq b">hello-world</code>映像验证Docker守护程序正在运行。</p><pre class="kg kh ki kj gt pd lq pe pf aw pg bi"><span id="9ec6" class="mp ls iq lq b gy ph pi l pj pk">$ sudo docker run hello-world</span></pre><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi pm"><img src="../Images/e317c9f3e30abe7721fd00dd4792cf46.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Jr_oilaU7jWTFOu8KqovAQ.png"/></div></div><p class="nc nd gj gh gi ne nf bd b be z dk translated">安装成功了！太神奇了！</p></figure><p id="0b78" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated"><strong class="kt ir"> <em class="mo">我真的要对每个Docker命令都使用</em> </strong> <code class="fe ln lo lp lq b">sudo</code> <strong class="kt ir"> <em class="mo">吗？</em> </strong></p><p id="1bf6" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">如果您试图运行Docker命令sans <code class="fe ln lo lp lq b">sudo</code>，那么您可能会遇到以下错误:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi pn"><img src="../Images/5226907b20903bd767ba4320923c2fd6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*oIpAsrtmzW2GnyfRi53McQ.png"/></div></div><p class="nc nd gj gh gi ne nf bd b be z dk translated">啊..</p></figure><ul class=""><li id="34c6" class="nh ni iq kt b ku kv kx ky la pa le pb li pc lm nm nn no np bi translated">默认情况下，Docker守护进程仅使用root权限运行，因此有两种选择:要么使用<code class="fe ln lo lp lq b">sudo</code>运行每个命令，要么将当前用户添加到Docker组，以允许非root用户运行Docker命令。</li><li id="c25a" class="nh ni iq kt b ku op kx oq la or le os li ot lm nm nn no np bi translated">为了更改当前用户的访问权限，需要使用<code class="fe ln lo lp lq b">$ sudo gpasswd -a $USER docker</code>将他们添加到Docker组，然后使用<code class="fe ln lo lp lq b">$ newgrp docker</code>激活更改。</li><li id="fdc9" class="nh ni iq kt b ku op kx oq la or le os li ot lm nm nn no np bi translated">通过运行一个简单的Docker命令如<code class="fe ln lo lp lq b">$ docker --version</code>来测试您的无根访问，以确保更改是有效的。</li></ul><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi po"><img src="../Images/8211aa3132b7b604ce1de0e2f6a83489.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*0KUIjraUgVhD3LTMDFQDdA.png"/></div></div><p class="nc nd gj gh gi ne nf bd b be z dk translated">耶！没有须藤了！</p></figure></div><div class="ab cl oc od hu oe" role="separator"><span class="of bw bk og oh oi"/><span class="of bw bk og oh oi"/><span class="of bw bk og oh"/></div><div class="ij ik il im in"><h1 id="981c" class="lr ls iq bd lt lu oj lw lx ly ok ma mb jw ol jx md jz om ka mf kc on kd mh mi bi translated">创建包含文件的本地目录</h1><p id="c142" class="pw-post-body-paragraph kr ks iq kt b ku mj jr kw kx mk ju kz la ml lc ld le mm lg lh li mn lk ll lm ij bi translated">下面创建的目录和文件将代表Docker容器将访问的本地文件系统。</p><p id="c82f" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">创建一个名为<code class="fe ln lo lp lq b"><em class="mo">webfiles</em></code>的新本地目录</p><p id="6306" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">从终端，使用命令<code class="fe ln lo lp lq b">$ mkdir webfiles &amp;&amp; cd $_</code>创建并切换到新目录</p><p id="fd73" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">在该目录中创建新文件:</p><pre class="kg kh ki kj gt pd lq pe pf aw pg bi"><span id="4942" class="mp ls iq lq b gy ph pi l pj pk">$ touch infofile.txt exportfile.txt</span></pre><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi pp"><img src="../Images/82500bce7ddd189079deed0b80a8efb3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*O25gfnx64Meis8c9RySbGg.png"/></div></div><p class="nc nd gj gh gi ne nf bd b be z dk translated">使用ls命令验证这两个文件都已创建</p></figure><p id="be87" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">退出<code class="fe ln lo lp lq b"><em class="mo">webfiles</em></code>目录，返回工作目录。<code class="fe ln lo lp lq b">$ cd —</code></p></div><div class="ab cl oc od hu oe" role="separator"><span class="of bw bk og oh oi"/><span class="of bw bk og oh oi"/><span class="of bw bk og oh"/></div><div class="ij ik il im in"><h1 id="7dcc" class="lr ls iq bd lt lu oj lw lx ly ok ma mb jw ol jx md jz om ka mf kc on kd mh mi bi translated">创建码头工人网络</h1><blockquote class="ou ov ow"><p id="27a8" class="kr ks mo kt b ku kv jr kw kx ky ju kz ox lb lc ld oy lf lg lh oz lj lk ll lm ij bi translated"><em class="iq">创建一个名为</em> <code class="fe ln lo lp lq b"><em class="iq">webnet</em></code>的网络</p></blockquote><p id="3d03" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">Docker安装本身包含三个默认的网络驱动程序— <em class="mo">主机</em>、<em class="mo">桥</em>和<em class="mo">空</em>。<em class="mo">网桥</em>是默认使用的网络驱动程序，如果没有指定的话，它允许同一个网络上的两个或多个容器进行通信。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi pq"><img src="../Images/64ce555f7af6b4ee0be546469e922b2f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*zLq4G_Rnyogph-hbUq94Xg.png"/></div></div><p class="nc nd gj gh gi ne nf bd b be z dk translated">使用docker网络ls，您可以列出现有的Docker网络。</p></figure><p id="35a5" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">在本练习中，我将创建一个<a class="ae nq" href="https://docs.docker.com/network/bridge/" rel="noopener ugc nofollow" target="_blank">用户定义的桥接网络</a>，而不是使用默认网络。</p><p id="cefd" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">这种方法有几个优点，其中一些包括提供与附加的、不相关的容器及其应用程序堆栈的更好的隔离，以及附加和分离容器而不需要先停止和重新创建它们。</p><p id="2777" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">本练习的优势在于，用户定义的桥接网络可以允许多个容器共享环境变量，从而使它们能够装载Docker卷来共享信息:</p><pre class="kg kh ki kj gt pd lq pe pf aw pg bi"><span id="6146" class="mp ls iq lq b gy ph pi l pj pk">$ docker network create &lt;network_name&gt;</span></pre><p id="8298" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">要验证网络是否已创建，请使用<code class="fe ln lo lp lq b">$ docker network ls</code>。要查看该网络的详细信息，请使用<code class="fe ln lo lp lq b">$ docker network inspect &lt;network_name&gt;</code>。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi pr"><img src="../Images/8d09ae76e09e6bb788db312e7060736b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*xkVkxJl76arngRIYX7AqQQ.png"/></div></div><p class="nc nd gj gh gi ne nf bd b be z dk translated">使用$ network ls列出网络</p></figure><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi ps"><img src="../Images/2888c50a9c3a922d6a18f116bd08e4e4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*aTzunPChJ2TyHGVSZMw-lw.png"/></div></div><p class="nc nd gj gh gi ne nf bd b be z dk translated">新创建的网络当前没有附加容器</p></figure></div><div class="ab cl oc od hu oe" role="separator"><span class="of bw bk og oh oi"/><span class="of bw bk og oh oi"/><span class="of bw bk og oh"/></div><div class="ij ik il im in"><h1 id="9bba" class="lr ls iq bd lt lu oj lw lx ly ok ma mb jw ol jx md jz om ka mf kc on kd mh mi bi translated">启动两个运行相同映像的容器，分配给用户定义的网络，并使用绑定装载</h1><p id="306c" class="pw-post-body-paragraph kr ks iq kt b ku mj jr kw kx mk ju kz la ml lc ld le mm lg lh li mn lk ll lm ij bi translated">把CentOS图像作为容器的基础。(提示:从技术上讲，您可以跳过这一步——如果您想使用官方图像而不是自定义图像，那么当您使用<code class="fe ln lo lp lq b">docker run</code>创建容器时，就会创建该图像。)</p><pre class="kg kh ki kj gt pd lq pe pf aw pg bi"><span id="c225" class="mp ls iq lq b gy ph pi l pj pk">$ docker pull centos:latest</span></pre><p id="0a95" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">使用映像启动容器，以分离模式运行，连接到用户定义的网络，绑定挂载指向本地目录。</p><pre class="kg kh ki kj gt pd lq pe pf aw pg bi"><span id="8d08" class="mp ls iq lq b gy ph pi l pj pk">$ docker run --network &lt;network_name&gt; \<br/>-d \<br/>-it \ <br/>-v "$(pwd)"/target:/app \<br/>--name &lt;container_name&gt; \<br/>&lt;image&gt; \</span></pre><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi pt"><img src="../Images/60755222cccce6d9de5173d4ac5e3230.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Fg3koAPG1f8jDk701fF2bA.png"/></div></div><p class="nc nd gj gh gi ne nf bd b be z dk translated">运行命令两次，并更改名称以区分容器。</p></figure><p id="2897" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">运行<code class="fe ln lo lp lq b">$ docker inspect &lt;container_name&gt;</code>来验证本地目录是否正确挂载。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi pu"><img src="../Images/82307d7d406192378391ccf2c1d6c019.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*FioGmbiY4oGNvIabaisxSQ.png"/></div></div><p class="nc nd gj gh gi ne nf bd b be z dk translated">每个容器应该包含相同的信息。</p></figure></div><div class="ab cl oc od hu oe" role="separator"><span class="of bw bk og oh oi"/><span class="of bw bk og oh oi"/><span class="of bw bk og oh"/></div><div class="ij ik il im in"><h1 id="226b" class="lr ls iq bd lt lu oj lw lx ly ok ma mb jw ol jx md jz om ka mf kc on kd mh mi bi translated">验证两个容器都可以访问挂载的本地目录中的文件。</h1><p id="ee1d" class="pw-post-body-paragraph kr ks iq kt b ku mj jr kw kx mk ju kz la ml lc ld le mm lg lh li mn lk ll lm ij bi translated">使用命令<code class="fe ln lo lp lq b">$ docker exec -it &lt;container_name&gt; bash</code>登录到正在运行的容器并运行命令。</p><p id="9fc1" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">在容器内部，使用<code class="fe ln lo lp lq b">ls</code>查看容器的文件系统，然后使用<code class="fe ln lo lp lq b">cd</code>切换到包含已挂载卷的目录(<code class="fe ln lo lp lq b">app</code>)。再次使用<code class="fe ln lo lp lq b">ls</code>来列出它的内容，您应该看到两个文件— <code class="fe ln lo lp lq b">exportfiles.txt</code>和<code class="fe ln lo lp lq b">infofile.txt</code> —确认容器确实可以访问它们。对另一个容器重复该过程。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi ob"><img src="../Images/7dfb0df2a98ad3ed399f5f6cdd1ed44e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*VI5tC_HRZTh2lGu44YPvrg.png"/></div></div><p class="nc nd gj gh gi ne nf bd b be z dk translated">一旦进入容器，就可以使用ls查看容器的文件系统。</p></figure></div><div class="ab cl oc od hu oe" role="separator"><span class="of bw bk og oh oi"/><span class="of bw bk og oh oi"/><span class="of bw bk og oh"/></div><div class="ij ik il im in"><h2 id="3d40" class="mp ls iq bd lt mq mr dn lx ms mt dp mb la mu mv md le mw mx mf li my mz mh na bi translated">分解资源</h2><p id="3566" class="pw-post-body-paragraph kr ks iq kt b ku mj jr kw kx mk ju kz la ml lc ld le mm lg lh li mn lk ll lm ij bi translated">使用<code class="fe ln lo lp lq b">$ docker rm -f $(docker ps -a -q)</code>和任何用<code class="fe ln lo lp lq b">$ docker rmi -f $(docker images -a -q)</code>创建的图像清理并移除容器。</p><h1 id="f44a" class="lr ls iq bd lt lu lv lw lx ly lz ma mb jw mc jx md jz me ka mf kc mg kd mh mi bi translated">思想</h1><p id="0da9" class="pw-post-body-paragraph kr ks iq kt b ku mj jr kw kx mk ju kz la ml lc ld le mm lg lh li mn lk ll lm ij bi translated">虽然本演练面向Docker和Docker卷的初学者，但也有一些以这种方式创建容器和卷的用例。</p><p id="6633" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">这对于创建一个或几个需要访问主机配置文件的容器，或者在Docker主机和容器的开发环境之间共享代码或工件非常有用。</p></div></div>    
</body>
</html>