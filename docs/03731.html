<html>
<head>
<title>How to Use Kotlin Coroutines With Firebase</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何在Firebase中使用Kotlin协同程序</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/how-to-use-kotlin-coroutines-with-firebase-6f8577a3e00f?source=collection_archive---------0-----------------------#2020-03-02">https://betterprogramming.pub/how-to-use-kotlin-coroutines-with-firebase-6f8577a3e00f?source=collection_archive---------0-----------------------#2020-03-02</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="836f" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">给你的Firebase请求增加一些悬念</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/83fd90801dc8647f3d3de7ad2392c081.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*uCTieiCv1fa4Q6h7sq7sqg.png"/></div></div></figure><h1 id="a184" class="ku kv it bd kw kx ky kz la lb lc ld le jz lf ka lg kc lh kd li kf lj kg lk ll bi translated">介绍</h1><p id="967b" class="pw-post-body-paragraph lm ln it lo b lp lq ju lr ls lt jx lu lv lw lx ly lz ma mb mc md me mf mg mh im bi translated">Firebase通过<code class="fe mi mj mk ml b"><a class="ae mm" href="https://github.com/Kotlin/kotlinx.coroutines/tree/master/integration/kotlinx-coroutines-play-services" rel="noopener ugc nofollow" target="_blank">kotlinx-coroutines-play-services</a></code>库增加了对协程的支持。Firebase身份验证和Firestore数据库操作可以暂停，以确保它们不在主线程上运行。请继续阅读，了解如何使用它以及它是如何在引擎盖下工作的。</p><p id="13e9" class="pw-post-body-paragraph lm ln it lo b lp mn ju lr ls mo jx lu lv mp lx ly lz mq mb mc md mr mf mg mh im bi translated">从Google Play服务版本9.0.0开始，您可以使用一个<code class="fe mi mj mk ml b">Task</code> API和许多返回<code class="fe mi mj mk ml b">Task</code>或其子类的函数。<code class="fe mi mj mk ml b">Task </code>是一个代表异步方法调用的API。Firebase认证和Firestore操作返回由<code class="fe mi mj mk ml b">Task</code>包装的结果。看一看:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ms"><img src="../Images/1ea93c1167ddc4548e77e7ee8a337ad9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*3givw0jzB9ngEzh0BvDqvQ.png"/></div></div><p class="mt mu gj gh gi mv mw bd b be z dk translated">Firebase身份验证返回类型。</p></figure><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi mx"><img src="../Images/d2cd85105e589ce8d83f2edeb4259339.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*dypSDRvk_eBSGj1iitBI6A.png"/></div></div><p class="mt mu gj gh gi mv mw bd b be z dk translated">Firestore操作返回类型。</p></figure><p id="52d4" class="pw-post-body-paragraph lm ln it lo b lp mn ju lr ls mo jx lu lv mp lx ly lz mq mb mc md mr mf mg mh im bi translated">在<code class="fe mi mj mk ml b">Task</code>中，我们添加了一个监听器，将我们与事件的变化联系起来，比如成功和失败:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="my mz l"/></div><p class="mt mu gj gh gi mv mw bd b be z dk translated">Firebase简单验证示例</p></figure><p id="b140" class="pw-post-body-paragraph lm ln it lo b lp mn ju lr ls mo jx lu lv mp lx ly lz mq mb mc md mr mf mg mh im bi translated">通过使用<code class="fe mi mj mk ml b">addOnCompleteListener</code>，我们适应了回调风格。协程的主要目标之一是将我们从回调地狱中解放出来，回调地狱可能不知道发起请求的组件的生命周期。</p><p id="a0c5" class="pw-post-body-paragraph lm ln it lo b lp mn ju lr ls mo jx lu lv mp lx ly lz mq mb mc md mr mf mg mh im bi translated">这就是<code class="fe mi mj mk ml b">kotlinx-coroutines-play-services</code>的用武之地——它通过在<code class="fe mi mj mk ml b">Task</code>上使用<code class="fe mi mj mk ml b">await</code>而不是添加一个监听器来为Firebase和Firestore操作提供协同支持。</p></div><div class="ab cl na nb hx nc" role="separator"><span class="nd bw bk ne nf ng"/><span class="nd bw bk ne nf ng"/><span class="nd bw bk ne nf"/></div><div class="im in io ip iq"><h1 id="f398" class="ku kv it bd kw kx nh kz la lb ni ld le jz nj ka lg kc nk kd li kf nl kg lk ll bi translated">它是如何工作的</h1><p id="7c0a" class="pw-post-body-paragraph lm ln it lo b lp lq ju lr ls lt jx lu lv lw lx ly lz ma mb mc md me mf mg mh im bi translated"><code class="fe mi mj mk ml b">suspend fun &lt;T&gt; Task&lt;T&gt;.await(): T</code></p><p id="d274" class="pw-post-body-paragraph lm ln it lo b lp mn ju lr ls mo jx lu lv mp lx ly lz mq mb mc md mr mf mg mh im bi translated">当你在一个<code class="fe mi mj mk ml b">task</code>上应用<code class="fe mi mj mk ml b">await</code>时，它会一直等待，直到它完成，而不会阻塞线程。</p><p id="97d8" class="pw-post-body-paragraph lm ln it lo b lp mn ju lr ls mo jx lu lv mp lx ly lz mq mb mc md mr mf mg mh im bi translated">当你在一个任务上应用<code class="fe mi mj mk ml b">await()</code>时，它将返回可取消的暂停功能。如果当前协程的<a class="ae mm" href="https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/-job/index.html" rel="noopener ugc nofollow" target="_blank">作业</a>被取消或完成，而该暂停函数正在等待，则该函数停止等待完成阶段，并立即通过<code class="fe mi mj mk ml b"><a class="ae mm" href="https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/-cancellation-exception.html" rel="noopener ugc nofollow" target="_blank">CancellationException</a></code>恢复。</p><p id="23f2" class="pw-post-body-paragraph lm ln it lo b lp mn ju lr ls mo jx lu lv mp lx ly lz mq mb mc md mr mf mg mh im bi translated">这意味着您不再需要编写样板代码来维护生命周期支持，因为协程是生命周期感知的。如果你的项目在MVVM或者清洁建筑中，这将会更有帮助。</p><p id="177d" class="pw-post-body-paragraph lm ln it lo b lp mn ju lr ls mo jx lu lv mp lx ly lz mq mb mc md mr mf mg mh im bi translated">在Firebase中,<code class="fe mi mj mk ml b">await</code>扩展功能并不是现成的特性——您必须深入研究协程库才能了解它是如何工作的。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="my mz l"/></div></figure><p id="9f83" class="pw-post-body-paragraph lm ln it lo b lp mn ju lr ls mo jx lu lv mp lx ly lz mq mb mc md mr mf mg mh im bi translated">它首先检查给定的任务是否已经完成。如果是，它将进行一系列检查，以检查它是否已被取消或是否发生了任何异常。如果满足任何异常检查，它将返回适当的异常，否则，它将返回结果。</p><p id="5cc9" class="pw-post-body-paragraph lm ln it lo b lp mn ju lr ls mo jx lu lv mp lx ly lz mq mb mc md mr mf mg mh im bi translated">另一方面，如果请求没有完成，它将返回一个使用了原来的<code class="fe mi mj mk ml b">completelistener</code>的<code class="fe mi mj mk ml b">suspendCancellableCoroutine</code>。有了<code class="fe mi mj mk ml b">await</code>的支持，Firebase请求将具有生命周期意识。</p><p id="150e" class="pw-post-body-paragraph lm ln it lo b lp mn ju lr ls mo jx lu lv mp lx ly lz mq mb mc md mr mf mg mh im bi translated">是时候编码了！</p></div><div class="ab cl na nb hx nc" role="separator"><span class="nd bw bk ne nf ng"/><span class="nd bw bk ne nf ng"/><span class="nd bw bk ne nf"/></div><div class="im in io ip iq"><h1 id="de0c" class="ku kv it bd kw kx nh kz la lb ni ld le jz nj ka lg kc nk kd li kf nl kg lk ll bi translated">综合</h1><p id="1d04" class="pw-post-body-paragraph lm ln it lo b lp lq ju lr ls lt jx lu lv lw lx ly lz ma mb mc md me mf mg mh im bi translated">要首先将<code class="fe mi mj mk ml b">await()</code>应用于认证和数据库操作，您需要将Firebase认证和Firestore库与<code class="fe mi mj mk ml b">kotlinx-coroutines-play-services</code>库集成在一起。看一看:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="my mz l"/></div><p class="mt mu gj gh gi mv mw bd b be z dk translated">必需的库</p></figure></div><div class="ab cl na nb hx nc" role="separator"><span class="nd bw bk ne nf ng"/><span class="nd bw bk ne nf ng"/><span class="nd bw bk ne nf"/></div><div class="im in io ip iq"><h1 id="b9e8" class="ku kv it bd kw kx nh kz la lb ni ld le jz nj ka lg kc nk kd li kf nl kg lk ll bi translated">使用协程的Firebase认证</h1><p id="44fa" class="pw-post-body-paragraph lm ln it lo b lp lq ju lr ls lt jx lu lv lw lx ly lz ma mb mc md me mf mg mh im bi translated">首先，让我们看看如何为那些不知道的人执行一个标准的firebase auth请求。为了简单起见，我使用了电子邮件和密码功能(Firebase具有广泛的身份验证功能，如电话号码、脸书、动态登录链接等等):</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="my mz l"/></div><p class="mt mu gj gh gi mv mw bd b be z dk translated">Firebase使用电子邮件和密码登录</p></figure><p id="be15" class="pw-post-body-paragraph lm ln it lo b lp mn ju lr ls mo jx lu lv mp lx ly lz mq mb mc md mr mf mg mh im bi translated">很简单——您创建一个<code class="fe mi mj mk ml b">FirebaseAuth</code>的实例，然后通过提供电子邮件和密码来调用<strong class="lo iu"> </strong> <code class="fe mi mj mk ml b">signInWithEmailAndPassword</code>函数。这将返回由<code class="fe mi mj mk ml b">Task</code>包装的<code class="fe mi mj mk ml b">FirebaseUser </code>，因此我们添加了<code class="fe mi mj mk ml b">onCompleteListener</code>来在任务完成后更新UI。</p><p id="1fa6" class="pw-post-body-paragraph lm ln it lo b lp mn ju lr ls mo jx lu lv mp lx ly lz mq mb mc md mr mf mg mh im bi translated">现在，让我们看看如何使用协程执行相同的请求:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="my mz l"/></div><p class="mt mu gj gh gi mv mw bd b be z dk translated">使用协同例程的Firebase Auth</p></figure><p id="7536" class="pw-post-body-paragraph lm ln it lo b lp mn ju lr ls mo jx lu lv mp lx ly lz mq mb mc md mr mf mg mh im bi translated">我们没有添加监听器，而是使用协程中的<code class="fe mi mj mk ml b">await()</code>来停止执行，直到任务完成。一旦完成，我们将结果赋给<code class="fe mi mj mk ml b">data</code>变量。您不需要添加任何回调或者检查组件是否是活动的，因为协程是生命周期感知的。</p></div><div class="ab cl na nb hx nc" role="separator"><span class="nd bw bk ne nf ng"/><span class="nd bw bk ne nf ng"/><span class="nd bw bk ne nf"/></div><div class="im in io ip iq"><h1 id="2bb5" class="ku kv it bd kw kx nh kz la lb ni ld le jz nj ka lg kc nk kd li kf nl kg lk ll bi translated">带有协程的Firestore</h1><p id="3883" class="pw-post-body-paragraph lm ln it lo b lp lq ju lr ls lt jx lu lv lw lx ly lz ma mb mc md me mf mg mh im bi translated">不管是Firebase Auth请求还是Firestore数据库操作，如果它们返回<code class="fe mi mj mk ml b">Task</code>，我们可以使用<code class="fe mi mj mk ml b">await()</code>来暂停执行，直到它完成，如上所示。首先，让我们看一个没有协程的简单Firestore更新操作:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="my mz l"/></div><p class="mt mu gj gh gi mv mw bd b be z dk translated">没有协程的Firestore更新请求</p></figure><p id="0dd1" class="pw-post-body-paragraph lm ln it lo b lp mn ju lr ls mo jx lu lv mp lx ly lz mq mb mc md mr mf mg mh im bi translated">现在，让我们看看使用协程执行相同的请求。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="my mz l"/></div><p class="mt mu gj gh gi mv mw bd b be z dk translated">带有协同例程的Firestore更新请求</p></figure><p id="5833" class="pw-post-body-paragraph lm ln it lo b lp mn ju lr ls mo jx lu lv mp lx ly lz mq mb mc md mr mf mg mh im bi translated">因为这是一个更新请求，所以返回类型将是void。另一方面，Firestore上的<code class="fe mi mj mk ml b">GET </code>请求与此类似，但它的返回类型是document-snapshot，我们必须将它转换成适当的数据类型。用协程程序查看Firestore <code class="fe mi mj mk ml b">GET </code>请求:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="my mz l"/></div><p class="mt mu gj gh gi mv mw bd b be z dk translated">Firestore使用协程获取请求</p></figure></div><div class="ab cl na nb hx nc" role="separator"><span class="nd bw bk ne nf ng"/><span class="nd bw bk ne nf ng"/><span class="nd bw bk ne nf"/></div><div class="im in io ip iq"><h1 id="33f6" class="ku kv it bd kw kx nh kz la lb ni ld le jz nj ka lg kc nk kd li kf nl kg lk ll bi translated">Firebase、协程程序和<strong class="ak"> KTX </strong></h1><p id="94ac" class="pw-post-body-paragraph lm ln it lo b lp lq ju lr ls lt jx lu lv lw lx ly lz ma mb mc md me mf mg mh im bi translated">我们已经看到了如何使用协程执行Firebase和Firestore请求。现在是时候学习如何使用<code class="fe mi mj mk ml b">ktx</code>函数了，这些函数让开发人员的生活变得如此简单。</p><p id="5e60" class="pw-post-body-paragraph lm ln it lo b lp mn ju lr ls mo jx lu lv mp lx ly lz mq mb mc md mr mf mg mh im bi translated">我们必须将以下库集成到应用程序级<code class="fe mi mj mk ml b">build.gradle</code>文件中，以便使用带有Kotlin扩展的Firestore。</p><pre class="kj kk kl km gt nm ml nn no aw np bi"><span id="77f5" class="nq kv it ml b gy nr ns l nt nu">implementation 'com.google.firebase:firebase-firestore-ktx:$VERSION'</span></pre><p id="bec1" class="pw-post-body-paragraph lm ln it lo b lp mn ju lr ls mo jx lu lv mp lx ly lz mq mb mc md mr mf mg mh im bi translated">现在，让我们来看看一些有扩展和没有扩展的Firebase操作</p><h2 id="fbf7" class="nq kv it bd kw nv nw dn la nx ny dp le lv nz oa lg lz ob oc li md od oe lk of bi translated">1.将DocumentSnapshot转换为数据类</h2><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="my mz l"/></div></figure><h2 id="08c0" class="nq kv it bd kw nv nw dn la nx ny dp le lv nz oa lg lz ob oc li md od oe lk of bi translated">2.获取FirebaseFirestore的实例</h2><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="my mz l"/></div></figure><h2 id="5697" class="nq kv it bd kw nv nw dn la nx ny dp le lv nz oa lg lz ob oc li md od oe lk of bi translated">3.使用本地模拟器设置Firestore</h2><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="my mz l"/></div></figure></div><div class="ab cl na nb hx nc" role="separator"><span class="nd bw bk ne nf ng"/><span class="nd bw bk ne nf ng"/><span class="nd bw bk ne nf"/></div><div class="im in io ip iq"><h1 id="bfa7" class="ku kv it bd kw kx nh kz la lb ni ld le jz nj ka lg kc nk kd li kf nl kg lk ll bi translated">奖金！</h1><p id="8763" class="pw-post-body-paragraph lm ln it lo b lp lq ju lr ls lt jx lu lv lw lx ly lz ma mb mc md me mf mg mh im bi translated">要了解更多关于Kotlin和coroutines的知识，请阅读下面的文章并关注我以获取更新。</p><ul class=""><li id="30f5" class="og oh it lo b lp mn ls mo lv oi lz oj md ok mh ol om on oo bi translated"><a class="ae mm" href="https://medium.com/better-programming/advanced-android-programming-with-kotlin-5e40b1be22bb" rel="noopener">使用Kotlin进行高级编程</a></li><li id="9b64" class="og oh it lo b lp op ls oq lv or lz os md ot mh ol om on oo bi translated"><a class="ae mm" href="https://medium.com/android-dev-hacks/advanced-android-programming-with-kotlin-part-2-aae2a15258b0" rel="noopener">使用Kotlin进行高级编程-第2部分</a></li><li id="4217" class="og oh it lo b lp op ls oq lv or lz os md ot mh ol om on oo bi translated"><a class="ae mm" href="https://medium.com/better-programming/advanced-programming-in-kotlin-2e01fbc39134" rel="noopener">使用Kotlin进行高级编程-第3部分</a></li><li id="c39b" class="og oh it lo b lp op ls oq lv or lz os md ot mh ol om on oo bi translated"><a class="ae mm" href="https://medium.com/better-programming/kotlin-coroutines-from-basics-to-advanced-ad3eb1421006" rel="noopener"> Kotlin协程，从基础到高级</a></li><li id="fbd1" class="og oh it lo b lp op ls oq lv or lz os md ot mh ol om on oo bi translated"><a class="ae mm" href="https://medium.com/@sgkantamani/sealed-classes-in-kotlin-e48e072daca8" rel="noopener">科特林的密封类</a></li><li id="69da" class="og oh it lo b lp op ls oq lv or lz os md ot mh ol om on oo bi translated"><a class="ae mm" href="https://medium.com/better-programming/asynchronous-data-loading-with-new-kotlin-flow-233f85ae1d8b" rel="noopener">使用新的Kotlin流进行异步数据加载</a></li></ul></div><div class="ab cl na nb hx nc" role="separator"><span class="nd bw bk ne nf ng"/><span class="nd bw bk ne nf ng"/><span class="nd bw bk ne nf"/></div><div class="im in io ip iq"><p id="4034" class="pw-post-body-paragraph lm ln it lo b lp mn ju lr ls mo jx lu lv mp lx ly lz mq mb mc md mr mf mg mh im bi translated">感谢您的阅读。</p></div></div>    
</body>
</html>