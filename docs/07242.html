<html>
<head>
<title>How to Create a Swift Package From a C++ Library</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何从C++库创建Swift包</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/how-to-create-a-swift-package-from-a-c-library-fb5cd606220f?source=collection_archive---------4-----------------------#2020-12-22">https://betterprogramming.pub/how-to-create-a-swift-package-from-a-c-library-fb5cd606220f?source=collection_archive---------4-----------------------#2020-12-22</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="25fc" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">了解Swift和C++如何相互通信</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/d185f33c4e584ee4719e7d1c3245326c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*Rl7X0az-cA99CnhK"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">在<a class="ae kv" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上由<a class="ae kv" href="https://unsplash.com/@kadh?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Kira auf der Heide </a>拍摄的照片。</p></figure><p id="d236" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">本教程将指导您创建自己的<a class="ae kv" href="https://swift.org/package-manager/" rel="noopener ugc nofollow" target="_blank"> Swift包</a>的过程。它将为一个流行的C++线性代数库— <a class="ae kv" href="https://gitlab.com/libeigen/eigen" rel="noopener ugc nofollow" target="_blank"> Eigen </a>提供绑定。为简单起见，只有Eigen功能的一个子集将被移植到Swift。</p></div><div class="ab cl ls lt hu lu" role="separator"><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx"/></div><div class="ij ik il im in"><h1 id="7816" class="lz ma iq bd mb mc md me mf mg mh mi mj jw mk jx ml jz mm ka mn kc mo kd mp mq bi translated">C++和Swift互操作的挑战</h1><p id="55e3" class="pw-post-body-paragraph kw kx iq ky b kz mr jr lb lc ms ju le lf mt lh li lj mu ll lm ln mv lp lq lr ij bi translated">C++到Swift的绑定是一个复杂的故事，很大程度上取决于您希望移植哪种C++代码。这两种语言没有明显的一对一的API映射。虽然存在自动绑定解决方案(例如<a class="ae kv" href="https://github.com/scapix-com/scapix" rel="noopener ugc nofollow" target="_blank"> Scapix </a>、<a class="ae kv" href="https://github.com/heremaps/gluecodium" rel="noopener ugc nofollow" target="_blank"> Gluecodium </a>)，但它们只能成功映射C++语言的一个子集。如果您是一名愿意编写可轻松转换成其他语言的代码的库开发人员，您可能会从这种绑定解决方案中受益。然而，如果您希望使用第三方库，那么您通常会遇到困难。在这种情况下，您可能只有一个选择:手动编写绑定。</p><p id="f4e7" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">Swift的团队已经在其工具链中提供了<a class="ae kv" href="https://github.com/apple/swift/blob/main/docs/HowSwiftImportsCAPIs.md" rel="noopener ugc nofollow" target="_blank"> C </a>和<a class="ae kv" href="https://github.com/apple/swift/blob/main/docs/ObjCInterop.md" rel="noopener ugc nofollow" target="_blank"> Objective-C </a>互操作性。与此同时，<a class="ae kv" href="https://github.com/apple/swift/blob/main/docs/CppInteroperabilityManifesto.md" rel="noopener ugc nofollow" target="_blank"> C++ interop </a>有一个没有明确实现时间表的清单。该清单讨论了C++/Swift互操作性的可能设计和权衡。最具挑战性的问题之一是导入模板。似乎C++模板和Swift泛型是相似的。然而，它们有重要的区别。在撰写本文时，Swift不支持非类型模板参数、模板模板参数和参数包。同样，Swift泛型是基于约束的(类似于<a class="ae kv" href="https://en.cppreference.com/w/cpp/concepts" rel="noopener ugc nofollow" target="_blank"> C++20概念</a>)。同时，C++模板执行语法替换(即尝试在调用位置用具体类型替换模板，并查看该类型是否支持模板中调用的语法)。</p><p id="7071" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">总而言之，如果你想从Swift调用一个高度模板化的C++库，运气真不好！</p></div><div class="ab cl ls lt hu lu" role="separator"><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx"/></div><div class="ij ik il im in"><h1 id="3e3f" class="lz ma iq bd mb mc md me mf mg mh mi mj jw mk jx ml jz mm ka mn kc mo kd mp mq bi translated">问题设置</h1><p id="96e2" class="pw-post-body-paragraph kw kx iq ky b kz mr jr lb lc ms ju le lf mt lh li lj mu ll lm ln mv lp lq lr ij bi translated">让我们尝试为高度模板化的C++库<a class="ae kv" href="https://gitlab.com/libeigen/eigen" rel="noopener ugc nofollow" target="_blank"> Eigen </a>进行手动绑定。这是一个流行的线性代数(矩阵、向量、数值解算器和相关算法)库。包装器的基本策略如下:选择一个具体类型，并将其包装成Objective-C类，该类将被导入Swift。</p><p id="55cc" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">将Objective-C API导入Swift的方法之一是直接向Xcode项目添加C++库，并提供一个<a class="ae kv" href="https://developer.apple.com/documentation/swift/imported_c_and_objective-c_apis/importing_objective-c_into_swift" rel="noopener ugc nofollow" target="_blank">桥接头</a>。但是，您通常希望您的包装器作为一个单独的模块进行编译。在这种情况下，您需要软件包管理器的帮助。Swift团队大力推广<a class="ae kv" href="https://swift.org/package-manager/" rel="noopener ugc nofollow" target="_blank"> Swift包管理器(SPM) </a>。从历史上看，SPM缺乏一些阻止许多开发人员迁移到它的特性。然而，这几年已经有了很大的改善。在Xcode 12中，您终于可以将资源与您的包捆绑在一起，甚至可以在Swift playground中使用包。</p><p id="71f2" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在本教程中，我们将创建一个名为<code class="fe mw mx my mz b">SwiftyEigen</code>的SPM包。作为具体使用的类型，我们将采用一个具有任意行数和列数的浮点矩阵。<code class="fe mw mx my mz b">Matrix</code>类将有一个初始化器、下标和计算矩阵逆的逆方法。完整的项目托管在GitHub 上<a class="ae kv" href="https://github.com/ksemianov/SwiftyEigen" rel="noopener ugc nofollow" target="_blank">。</a></p></div><div class="ab cl ls lt hu lu" role="separator"><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx"/></div><div class="ij ik il im in"><h1 id="4086" class="lz ma iq bd mb mc md me mf mg mh mi mj jw mk jx ml jz mm ka mn kc mo kd mp mq bi translated">项目结构</h1><p id="d888" class="pw-post-body-paragraph kw kx iq ky b kz mr jr lb lc ms ju le lf mt lh li lj mu ll lm ln mv lp lq lr ij bi translated">SPM有一个创建新库的有用模板:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="na nb l"/></div></figure><p id="3b23" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">然后我们添加第三方库(Eigen)作为子模块:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="na nb l"/></div></figure><p id="33e1" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们编辑我们的包裹清单，<code class="fe mw mx my mz b">Package.swift</code>:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="na nb l"/></div></figure><p id="41aa" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这个包清单是包编译的诀窍。Swift的构建系统将为Objective-C和Swift编译两个独立的目标。SPM不允许在同一个目标中混合使用这两种语言。<code class="fe mw mx my mz b">ObjCEigen</code>目标使用来自<code class="fe mw mx my mz b">Sources/ObjC</code>文件夹的源代码，将<code class="fe mw mx my mz b">Sources/CPP</code>文件夹添加到标题搜索路径中，并定义<code class="fe mw mx my mz b">EIGEN_MPL2_ONLY</code>以保证在使用Eigen时获得MPL2许可。<code class="fe mw mx my mz b">SwiftyEigen</code>目标依赖于<code class="fe mw mx my mz b">ObjCEigen</code>并使用来自<code class="fe mw mx my mz b">Sources/Swift</code>文件夹的源。</p></div><div class="ab cl ls lt hu lu" role="separator"><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx"/></div><div class="ij ik il im in"><h1 id="6375" class="lz ma iq bd mb mc md me mf mg mh mi mj jw mk jx ml jz mm ka mn kc mo kd mp mq bi translated">手动绑定</h1><p id="254e" class="pw-post-body-paragraph kw kx iq ky b kz mr jr lb lc ms ju le lf mt lh li lj mu ll lm ln mv lp lq lr ij bi translated">现在我们为Objective-C类提供一个头文件，并把它放在<code class="fe mw mx my mz b">Sources/ObjCEigen/include</code>文件夹中:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="na nb l"/></div></figure><p id="0320" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们有<code class="fe mw mx my mz b">rows</code>和<code class="fe mw mx my mz b">cols</code> get属性，一个带有零和一个单位的初始化器，获取和设置单个值的方法，以及一个逆向方法。</p><p id="5112" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这是在<code class="fe mw mx my mz b">Sources/ObjCEigen</code>文件夹中的实现:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="na nb l"/></div></figure><p id="a8ec" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">现在我们在<code class="fe mw mx my mz b">Sources/Swift</code>向Swift公开我们的Objective-C代码(更多信息，请参见<a class="ae kv" href="https://forums.swift.org/t/why-does-a-package-expose-the-targets-names-for-import-instead-of-product-library-name/16648/2" rel="noopener ugc nofollow" target="_blank"> Swift论坛</a>):</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="na nb l"/></div></figure><p id="1dbe" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">并为更干净的API提供下标:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="na nb l"/></div></figure></div><div class="ab cl ls lt hu lu" role="separator"><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx"/></div><div class="ij ik il im in"><h1 id="fb5c" class="lz ma iq bd mb mc md me mf mg mh mi mj jw mk jx ml jz mm ka mn kc mo kd mp mq bi translated">用法示例</h1><p id="8834" class="pw-post-body-paragraph kw kx iq ky b kz mr jr lb lc ms ju le lf mt lh li lj mu ll lm ln mv lp lq lr ij bi translated">现在我们可以如下使用这个类:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="na nb l"/></div></figure><p id="2670" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">最后，我们可以创建一个简单的示例项目，展示我们的包装器库<code class="fe mw mx my mz b">SwiftyEigen</code>的功能。它将允许我们输入一个2x2矩阵的值，然后计算它的逆。为此，您在Xcode中创建新的iOS项目，将包的文件夹从Finder拖放到Project navigator以添加本地依赖项，并在<code class="fe mw mx my mz b">Example target</code>的常规设置中添加<code class="fe mw mx my mz b">SwiftyEigen</code>框架。然后我们编写UI并完成项目:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi nc"><img src="../Images/6f1b1eb221b3ec4f1f18e3648f82ce78.png" data-original-src="https://miro.medium.com/v2/resize:fit:472/1*vR1QCJhu4rhYXW5NhR40lA.gif"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">作者截屏</p></figure><p id="8d18" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">参见GitHub 上的完整代码<a class="ae kv" href="https://github.com/ksemianov/SwiftyEigen" rel="noopener ugc nofollow" target="_blank">。</a></p></div><div class="ab cl ls lt hu lu" role="separator"><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx"/></div><div class="ij ik il im in"><h1 id="3edb" class="lz ma iq bd mb mc md me mf mg mh mi mj jw mk jx ml jz mm ka mn kc mo kd mp mq bi translated">参考</h1><ul class=""><li id="098b" class="nd ne iq ky b kz mr lc ms lf nf lj ng ln nh lr ni nj nk nl bi translated"><a class="ae kv" href="https://github.com/ksemianov/SwiftyEigen" rel="noopener ugc nofollow" target="_blank"> SwiftyEigen项目</a></li><li id="d33e" class="nd ne iq ky b kz nm lc nn lf no lj np ln nq lr ni nj nk nl bi translated"><a class="ae kv" href="https://gitlab.com/libeigen/eigen" rel="noopener ugc nofollow" target="_blank">特征线性代数库</a></li><li id="326b" class="nd ne iq ky b kz nm lc nn lf no lj np ln nq lr ni nj nk nl bi translated"><a class="ae kv" href="https://swift.org/package-manager/" rel="noopener ugc nofollow" target="_blank"> Swift包管理器</a></li><li id="4154" class="nd ne iq ky b kz nm lc nn lf no lj np ln nq lr ni nj nk nl bi translated"><a class="ae kv" href="https://github.com/apple/swift/blob/main/docs/HowSwiftImportsCAPIs.md" rel="noopener ugc nofollow" target="_blank"> C/Swift互操作</a></li><li id="d220" class="nd ne iq ky b kz nm lc nn lf no lj np ln nq lr ni nj nk nl bi translated"><a class="ae kv" href="https://github.com/apple/swift/blob/main/docs/ObjCInterop.md" rel="noopener ugc nofollow" target="_blank">目标-C/Swift互操作</a></li><li id="f86f" class="nd ne iq ky b kz nm lc nn lf no lj np ln nq lr ni nj nk nl bi translated"><a class="ae kv" href="https://developer.apple.com/documentation/swift/imported_c_and_objective-c_apis/importing_objective-c_into_swift" rel="noopener ugc nofollow" target="_blank">目标-C桥接接头</a></li><li id="8bc8" class="nd ne iq ky b kz nm lc nn lf no lj np ln nq lr ni nj nk nl bi translated"><a class="ae kv" href="https://github.com/apple/swift/blob/main/docs/CppInteroperabilityManifesto.md" rel="noopener ugc nofollow" target="_blank"> C++/Swift互操作清单</a></li><li id="0975" class="nd ne iq ky b kz nm lc nn lf no lj np ln nq lr ni nj nk nl bi translated"><a class="ae kv" href="https://en.cppreference.com/w/cpp/concepts" rel="noopener ugc nofollow" target="_blank"> C++20个概念</a></li><li id="d0ac" class="nd ne iq ky b kz nm lc nn lf no lj np ln nq lr ni nj nk nl bi translated"><a class="ae kv" href="https://github.com/scapix-com/scapix" rel="noopener ugc nofollow" target="_blank">自动桥接解决方案</a></li></ul><p id="77bf" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">感谢您的阅读！</p></div></div>    
</body>
</html>