<html>
<head>
<title>A Simple Technique for Sharing State With React and RxJS</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">与React和RxJS共享状态的简单技术</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/simple-technique-for-sharing-state-with-react-and-rxjs-710dc06e9732?source=collection_archive---------8-----------------------#2021-04-26">https://betterprogramming.pub/simple-technique-for-sharing-state-with-react-and-rxjs-710dc06e9732?source=collection_archive---------8-----------------------#2021-04-26</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="0361" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">让我们通过React和RxJS了解组件之间的通信技术</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/e0de10cbaf98ba88a38dc269af71fc22.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*HhqZ2WZiyXLiKjua"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">照片由<a class="ae ky" href="https://unsplash.com/@myleon?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">莱昂</a>在<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</p></figure><p id="4893" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在这篇文章中，让我们来看一个用React和RxJS在组件之间进行通信的简单技术。</p><p id="7965" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">Redux是很多人处理状态管理的首选库。虽然它是一个强大的工具，但Redux不应该被用作解决所有状态管理问题的瑞士刀。</p><p id="34b4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">通常，更精简的方法是首选。例如，您可以使用一个简单的观察者模式与RxJS共享状态。与Redux和Context API相比，以这种方式在组件之间进行通信有几个显著的优点。我会在文章的最后列出所有的问题。</p><h1 id="4c47" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">RxJS用于状态管理</h1><p id="98ce" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated"><a class="ae ky" href="https://rxjs-dev.firebaseapp.com/guide/overview" rel="noopener ugc nofollow" target="_blank"> RxJS </a>是<a class="ae ky" href="https://en.wikipedia.org/wiki/Reactive_programming" rel="noopener ugc nofollow" target="_blank">反应式编程</a>的流行库。RxJS帮助编写用于处理副作用和异步操作的声明性代码。为此，它使用了连续数据流和订阅的概念。</p><p id="90a4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">RxJS是一个功能强大的工具。然而，在这篇文章中，我们将把RxJS的使用限制在组件间共享状态的数据流上。</p><p id="8d22" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">简单地说，这个想法是这样的:客户端订阅一个数据流，当新数据到达时，该数据流不断地推送新数据。数据流可以有多个订阅者，他们可以随心所欲地订阅/取消订阅。</p><p id="a9c0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们将使用的主要RxJS对象:</p><ol class=""><li id="cdab" class="ms mt it lb b lc ld lf lg li mu lm mv lq mw lu mx my mz na bi translated">主题—带有数据流的对象。</li><li id="9856" class="ms mt it lb b lc nb lf nc li nd lm ne lq nf lu mx my mz na bi translated">观察者——主体发出的价值的消费者。在我们的例子中，它只是一个在新数据到达时更新状态的函数。</li></ol><p id="e42a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">下图说明了主体和观察者之间的关系:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ng"><img src="../Images/0e0d90e1ffdf6534bbc4cae0acecfba7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*p-rQbs2HKrB4ZQbfEffMWg.png"/></div></div></figure><h1 id="ba14" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">使用React和RxJS</h1><h2 id="5638" class="nh lw it bd lx ni nj dn mb nk nl dp mf li nm nn mh lm no np mj lq nq nr ml ns bi translated">我们正在建造的东西</h2><p id="5157" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">我们来搭建一个简单的笔记app。我们将有两个兄弟组件:</p><ol class=""><li id="c438" class="ms mt it lb b lc ld lf lg li mu lm mv lq mw lu mx my mz na bi translated">标题—将包含用于清除和添加新注释的控件。</li><li id="6028" class="ms mt it lb b lc nb lf nc li nd lm ne lq nf lu mx my mz na bi translated">内容—将负责显示注释。</li></ol><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nt"><img src="../Images/9d1a198864f43c3a3162b2525920c2a1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*xODfU1KIyTe0Iz6t3PIVJg.png"/></div></div></figure><p id="058a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们从添加使用共享状态的逻辑开始。下面是我们处理共享状态的<code class="fe nu nv nw nx b">notesState.js</code>文件:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ny nz l"/></div></figure><p id="d2d7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">需要注意的一点是:<code class="fe nu nv nw nx b">getNotes</code>是一个用于获取笔记当前状态的实用函数。你可以在应用程序的任何地方使用它，而不仅仅是React组件。</p><p id="0290" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe nu nv nw nx b">useSharedNotes</code>是一个定制的钩子，你可以用它来获取和改变笔记的当前状态。<code class="fe nu nv nw nx b">useSharedNotes</code>使用<code class="fe nu nv nw nx b">useEffect</code>方法在组件加载时订阅主题。</p><p id="f822" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">为了订阅，我们使用<code class="fe nu nv nw nx b">subject.subscribe</code>方法。每当收到新的notes数据时，我们的订阅者函数都会更新状态。<code class="fe nu nv nw nx b">subject.subscribe</code>返回一个订阅对象，每当组件被卸载时，我们用它来取消订阅。</p><p id="7b29" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe nu nv nw nx b">useSharedNotes</code>返回<code class="fe nu nv nw nx b">addNotes</code>、<code class="fe nu nv nw nx b">clear</code>函数，以及包含当前notes状态的<code class="fe nu nv nw nx b">notes</code>数组。这就是让我们的应用程序正常工作所需的全部内容。</p><h2 id="a38d" class="nh lw it bd lx ni nj dn mb nk nl dp mf li nm nn mh lm no np mj lq nq nr ml ns bi translated">成分</h2><p id="4110" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">现在让我们开始添加<code class="fe nu nv nw nx b">Header</code>和<code class="fe nu nv nw nx b">Content</code>组件。<br/>首先我们来定义一下<code class="fe nu nv nw nx b">Header</code>。该组件包含用于添加和清除新注释的控件。这是我们的header.js文件:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ny nz l"/></div></figure><p id="c002" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">很简单。我们有输入和两个按钮，用于添加和清除笔记。我们使用<code class="fe nu nv nw nx b">addNote</code>和<code class="fe nu nv nw nx b">clear</code>方法来将更改推送到共享状态。</p><p id="679a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在让我们定义负责显示注释的<code class="fe nu nv nw nx b">Content</code>组件。下面是content.js文件:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ny nz l"/></div></figure><p id="6b4d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们只使用共享状态中的<code class="fe nu nv nw nx b">notes</code>字段。这是因为这个组件唯一的工作就是显示注释。</p><p id="971a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">仅此而已！如我所说，这是一个比Redux更精简的方法。</p><h2 id="e5cd" class="nh lw it bd lx ni nj dn mb nk nl dp mf li nm nn mh lm no np mj lq nq nr ml ns bi translated">重构共享状态</h2><p id="0a79" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">对于像我们这样简单的应用程序，我们的共享状态代码是可以的。然而，在一个有多个共享状态的大项目中，为每个状态编写单独的钩子可能很麻烦。</p><p id="01a5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们使我们的<code class="fe nu nv nw nx b">notesState</code>更加可重用。shareState.js文件如下所示:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ny nz l"/></div></figure><p id="0032" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们重构后的代码类似于前面的代码。但是现在我们有了一个包含多个不同主题的<code class="fe nu nv nw nx b">subjects</code>地图。我们使用静态定义的键来访问它们。</p><p id="0e90" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们将这些键作为第一个参数传递给<code class="fe nu nv nw nx b">useSharedState</code>钩子，以指定我们订阅哪个主题。对于我们的笔记应用程序，我们将使用<code class="fe nu nv nw nx b">NOTES_STATE</code>键来访问和改变共享状态。对于每个新的状态，我们可以不断添加新的键，并根据需要使用它们。</p><h1 id="3bef" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">我们方法的优势</h1><p id="9f8e" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">让我们总结一下React和RxJS使用共享状态的好处:</p><ol class=""><li id="f3cf" class="ms mt it lb b lc ld lf lg li mu lm mv lq mw lu mx my mz na bi translated"><strong class="lb iu">更精简的代码。这种共享状态的方法通常需要编写更少的代码。</strong></li><li id="8f84" class="ms mt it lb b lc nb lf nc li nd lm ne lq nf lu mx my mz na bi translated"><strong class="lb iu">从任何地方进入该州。</strong>使用redux和上下文API，您只能从组件或Redux动作访问全局状态。使用我们的共享状态方法，您可以使用<code class="fe nu nv nw nx b">getSharedStateValue</code>从任何地方读取状态，包括静态util方法。</li><li id="724a" class="ms mt it lb b lc nb lf nc li nd lm ne lq nf lu mx my mz na bi translated"><strong class="lb iu">明显的副作用。</strong>使用共享状态方法可以更容易地跟踪副作用。使用Redux，您首先需要找到受操作影响的reducer，然后是订阅这些reducer的所有组件。使用我们的方法，您可以搜索一个订阅密钥(如<code class="fe nu nv nw nx b">NOTES_STATE</code>)，您将立即看到订阅它的所有组件。</li><li id="916f" class="ms mt it lb b lc nb lf nc li nd lm ne lq nf lu mx my mz na bi translated"><strong class="lb iu">避免重新渲染整个组件树。与Context API相比，这种方法的一个优点是它只会重新呈现订阅的组件。有了上下文API，当状态有任何变化时，整个组件树都会被重新渲染。</strong></li></ol><p id="69d7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这个帖子到此为止！希望您发现这种模式足够简单和有用，可以在您的项目中尝试。对于大的应用，我建议结合Redux使用。对于不经常改变的全局状态，如用户会话和令牌，使用Redux。对于经常变化并且影响少量组件的事情，使用RxJS。</p><p id="f7fc" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这里是本教程的<a class="ae ky" href="https://codesandbox.io/s/react-rxjs-tq3j0" rel="noopener ugc nofollow" target="_blank">代码沙箱</a>的链接。</p></div><div class="ab cl oa ob hx oc" role="separator"><span class="od bw bk oe of og"/><span class="od bw bk oe of og"/><span class="od bw bk oe of"/></div><div class="im in io ip iq"><p id="b8c5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><em class="oh">原载于2021年4月26日https://isamatov.com</em><a class="ae ky" href="https://isamatov.com/react-rxjs-shared-state/" rel="noopener ugc nofollow" target="_blank"><em class="oh"/></a><em class="oh">。</em></p></div></div>    
</body>
</html>