<html>
<head>
<title>Deploy an iOS App to TestFlight or the App Store Using GitHub Actions</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用GitHub操作将iOS应用程序部署到TestFlight或App Store</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/deploy-an-ios-app-to-testflight-or-the-app-store-using-github-actions-c4d7082b1430?source=collection_archive---------0-----------------------#2020-06-17">https://betterprogramming.pub/deploy-an-ios-app-to-testflight-or-the-app-store-using-github-actions-c4d7082b1430?source=collection_archive---------0-----------------------#2020-06-17</a></blockquote><div><div class="fc ii ij ik il im"/><div class="in io ip iq ir"><div class=""/><div class=""><h2 id="2446" class="pw-subtitle-paragraph jr it iu bd b js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki dk translated">建立一个持续的部署渠道来连接App Store</h2></div><figure class="kk kl km kn gu ko gi gj paragraph-image"><div role="button" tabindex="0" class="kp kq di kr bf ks"><div class="gi gj kj"><img src="../Images/3216df490b855e13c96a5fe3c9ac2dbc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*PACxR8n-4fxrJz_J"/></div></div><p class="kv kw gk gi gj kx ky bd b be z dk translated">尼古拉斯·天梭在<a class="ae kz" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片。</p></figure><p id="0a6c" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">在本教程中，我们将配置一个<a class="ae kz" href="https://github.com" rel="noopener ugc nofollow" target="_blank"> GitHub </a>存储库，使用<a class="ae kz" href="https://github.com/features/actions" rel="noopener ugc nofollow" target="_blank"> GitHub动作</a>将<a class="ae kz" href="https://www.apple.com/ios/" rel="noopener ugc nofollow" target="_blank"> iOS </a>应用发布部署到<a class="ae kz" href="http://appstoreconnect.apple.com" rel="noopener ugc nofollow" target="_blank">应用商店连接</a>。我们将创建一个GitHub Actions工作流，在每次向GitHub推送提交时构建我们的iOS应用程序项目，并在每次推送发布标签时将我们构建的应用程序上传到App Store Connect。</p><p id="8c71" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">关于代码签名和配置文件，我们将尽可能保持简单。对于只有一个主要开发人员的简单应用程序和项目来说，这应该很好。如果您在一个大型团队中工作，或者您的项目包括多个目标，那么您可能会从采用不同的方法中受益。</p><p id="1af5" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">如果你想看一个配置成使用本教程中描述的工作流的存储库的实例，你可以看看这个项目。</p></div><div class="ab cl lw lx hy ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="in io ip iq ir"><h1 id="436c" class="md me iu bd mf mg mh mi mj mk ml mm mn ka mo kb mp kd mq ke mr kg ms kh mt mu bi translated">工作流程假设</h1><p id="865c" class="pw-post-body-paragraph la lb iu lc b ld mv jv lf lg mw jy li lj mx ll lm ln my lp lq lr mz lt lu lv in bi translated">本教程中描述的GitHub Actions工作流程假设它正在其中运行的存储库包含单个Xcode项目或工作区，并且项目或工作区的第一个方案构建了一个iOS应用程序。</p><p id="cd82" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">该工作流程还假设iOS应用程序目标配置如下。</p></div><div class="ab cl lw lx hy ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="in io ip iq ir"><h1 id="5d68" class="md me iu bd mf mg mh mi mj mk ml mm mn ka mo kb mp kd mq ke mr kg ms kh mt mu bi translated">代码签名和配置文件</h1><p id="7e2a" class="pw-post-body-paragraph la lb iu lc b ld mv jv lf lg mw jy li lj mx ll lm ln my lp lq lr mz lt lu lv in bi translated">签署证书和配置文件的情况过去更令人困惑和费力。这是一段漫长的旅程，但有了Xcode 11，事情就变得相当简单了。几乎所有过去需要访问苹果开发者门户网站的任务现在都可以在Xcode中处理。可以在Xcode的偏好设置中创建签名证书(用于开发和分发)。为目标启用“自动管理签名”时，会自动生成预置描述文件。</p><p id="56c2" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">自动管理签名对于开发来说非常好，但是在GitHub Actions这样的平台环境中，这使得事情变得更加复杂。因为签名证书和配置文件不存储在项目存储库中，并且因为项目每次都在不同的主机上构建，所以自动管理的签名可能会导致每次工作流运行时都创建新的证书和相应的配置文件。这导致了开发人员门户中证书和概要文件的激增。</p><p id="d209" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">有多种方法可以处理这种复杂情况。例如，<a class="ae kz" href="https://fastlane.tools" rel="noopener ugc nofollow" target="_blank"> fastlane项目</a>包括对<a class="ae kz" href="https://codesigning.guide" rel="noopener ugc nofollow" target="_blank">代码签名工作流</a>的支持，该工作流依赖于加密证书和配置文件，然后将它们保存在CI系统可访问的独立git存储库中。</p><p id="16f7" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">我们将在本教程中采用的方法是将签名证书和配置文件存储为GitHub存储库机密。我们的工作流会将签名证书导入到一个keychain中，并在构建项目之前将配置文件写入文件系统。</p></div><div class="ab cl lw lx hy ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="in io ip iq ir"><h1 id="f5a2" class="md me iu bd mf mg mh mi mj mk ml mm mn ka mo kb mp kd mq ke mr kg ms kh mt mu bi translated">项目设置</h1><p id="8bc8" class="pw-post-body-paragraph la lb iu lc b ld mv jv lf lg mw jy li lj mx ll lm ln my lp lq lr mz lt lu lv in bi translated">您可以随意为iOS应用程序目标的“调试”构建配置启用“自动管理签名”，但必须为您的“发布”构建配置禁用该设置。通过在项目中禁用自动管理签名，我们确保可以使用与工作流中使用的相同证书和配置文件来手动测试我们的签名和分发流程。</p><p id="b03e" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">立即禁用“自动管理签名”生成设置:</p><figure class="kk kl km kn gu ko gi gj paragraph-image"><div role="button" tabindex="0" class="kp kq di kr bf ks"><div class="gi gj na"><img src="../Images/c4a97e17fce68fbf018489962a0766f8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*9s4DylaH4mptWDu3mbtr5A.png"/></div></div></figure><p id="54ef" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">创建一个<a class="ae kz" href="https://developer.apple.com/account/resources/identifiers/list" rel="noopener ugc nofollow" target="_blank">应用商店标识符</a>和一个<a class="ae kz" href="https://developer.apple.com/account/resources/profiles/list" rel="noopener ugc nofollow" target="_blank">分发预置描述文件</a>。根据应用的功能，您可以使用通配符应用标识或特定应用标识来创建预置描述文件。</p><p id="181d" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">下载档案。</p><p id="86a9" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">使用“Release”构建配置中的“Provisioning Profile”菜单将概要文件导入到项目中:</p><figure class="kk kl km kn gu ko gi gj paragraph-image"><div role="button" tabindex="0" class="kp kq di kr bf ks"><div class="gi gj nb"><img src="../Images/0439010856fb7f68a3da43492dd0100d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*-5ynbB-Jrf0azExAJM1POQ.png"/></div></div></figure><p id="236b" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">导入配置文件会将“预配配置文件”构建设置设为导入配置文件的名称，将“代码签名身份”构建设置设为“iOS分发”，将“开发团队”<em class="nc"> </em>构建设置设为与预配配置文件关联的团队名称。</p><p id="cb0a" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">确定您拥有“iOS分发版”或“Apple分发版”签名证书。导航到“Xcode”&gt;“偏好设置”…&gt;“帐户”,选择您的Apple ID，然后点按“管理证书”…。如果您没有看到合适的签名证书，您应该使用+˅按钮来创建“Apple Distribution”签名证书。</p><p id="1c67" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">项目配置到此为止。您可能应该尝试使用Xcode手动将您的应用程序提交到App Store Connect至少一次，以验证您的项目设置是否正确。</p></div><div class="ab cl lw lx hy ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="in io ip iq ir"><h1 id="1de0" class="md me iu bd mf mg mh mi mj mk ml mm mn ka mo kb mp kd mq ke mr kg ms kh mt mu bi translated">GitHub秘密</h1><p id="d0c8" class="pw-post-body-paragraph la lb iu lc b ld mv jv lf lg mw jy li lj mx ll lm ln my lp lq lr mz lt lu lv in bi translated">为了让工作流成功运行，我们需要在GitHub中存储五个秘密:</p><ul class=""><li id="11f7" class="nd ne iu lc b ld le lg lh lj nf ln ng lr nh lv ni nj nk nl bi translated">签名证书数据的加密密码</li><li id="a738" class="nd ne iu lc b ld nm lg nn lj no ln np lr nq lv ni nj nk nl bi translated">签名证书数据</li><li id="f122" class="nd ne iu lc b ld nm lg nn lj no ln np lr nq lv ni nj nk nl bi translated">供应简档数据</li><li id="0f3b" class="nd ne iu lc b ld nm lg nn lj no ln np lr nq lv ni nj nk nl bi translated">App Store连接用户名</li><li id="f01d" class="nd ne iu lc b ld nm lg nn lj no ln np lr nq lv ni nj nk nl bi translated">App Store连接密码</li></ul><p id="c4d3" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">要将每个秘密添加到GitHub存储库中，首先需要导航到存储库的“设置”选项卡。然后从侧边栏选择“秘密”。点按“新密码”，然后输入密码的名称和值。最后，点击“添加密码”</p><h2 id="a2e7" class="nr me iu bd mf ns nt dn mj nu nv dp mn lj nw nx mp ln ny nz mr lr oa ob mt oc bi translated">签名_证书_密码</h2><p id="42e1" class="pw-post-body-paragraph la lb iu lc b ld mv jv lf lg mw jy li lj mx ll lm ln my lp lq lr mz lt lu lv in bi translated">我们必须首先选择一个加密密码。您可以选择您喜欢的任何密码，但是如果您想要一些灵感，这里有我最喜欢的shell一行程序来生成密码，将其复制到剪贴板，并打印出来:</p><pre class="kk kl km kn gu od oe of og aw oh bi"><span id="42b7" class="nr me iu oe b gz oi oj l ok ol">&lt; /dev/urandom \<br/>  LANG= \<br/>  tr -dc a-zA-Z0-9 \<br/>  | head -c 32 \<br/>  | pbcopy \<br/>  &amp;&amp; pbpaste \<br/>  &amp;&amp; echo</span></pre><p id="dd23" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">粘贴密码作为<code class="fe om on oo oe b">SIGNING_CERTIFICATE_PASSWORD</code>密码的值。</p><h2 id="c48d" class="nr me iu bd mf ns nt dn mj nu nv dp mn lj nw nx mp ln ny nz mr lr oa ob mt oc bi translated">签名_证书_ P12 _数据</h2><p id="c53a" class="pw-post-body-paragraph la lb iu lc b ld mv jv lf lg mw jy li lj mx ll lm ln my lp lq lr mz lt lu lv in bi translated">为了生成加密的证书数据，我们接下来将从“钥匙串访问”应用程序中导出证书身份。为此，请打开“钥匙串访问”应用程序，确定您的默认“登录”钥匙串已选定，然后选择“我的证书”类别。从列表中选择您的“Apple分发版”(或“iOS分发版”)证书，并从“文件”菜单中选取“导出项目…”。将文件格式设置为“个人信息交换(<code class="fe om on oo oe b">.p12</code>)”，然后单击“保存”当提示输入加密密码时，粘贴<code class="fe om on oo oe b">SIGNING_CERTIFICATE_PASSWORD</code>密码的值。然后在“钥匙串访问”提示时输入您的本地帐户凭据。</p><p id="b2cb" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">接下来，打开一个终端窗口，在磁盘上找到<code class="fe om on oo oe b">p12</code>文件。运行以下命令对文件进行base64编码，并将其复制到剪贴板:</p><pre class="kk kl km kn gu od oe of og aw oh bi"><span id="ba9a" class="nr me iu oe b gz oi oj l ok ol">cat Certificates.p12 | base64 | pbcopy</span></pre><p id="3369" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">粘贴复制的文本作为<code class="fe om on oo oe b">SIGNING_CERTIFICATE_P12_DATA</code>秘密的值。</p><h2 id="c4a6" class="nr me iu bd mf ns nt dn mj nu nv dp mn lj nw nx mp ln ny nz mr lr oa ob mt oc bi translated">预配_配置文件_数据</h2><p id="055e" class="pw-post-body-paragraph la lb iu lc b ld mv jv lf lg mw jy li lj mx ll lm ln my lp lq lr mz lt lu lv in bi translated">我们需要对我们在项目设置期间创建和下载的配置文件进行base64编码，然后将其复制到我们的剪贴板。运行以下命令，用您下载的预置描述文件的名称替换<code class="fe om on oo oe b">profile.mobileprovision</code>文件名:</p><pre class="kk kl km kn gu od oe of og aw oh bi"><span id="d7c5" class="nr me iu oe b gz oi oj l ok ol">cat profile.mobileprovision | base64 | pbcopy</span></pre><p id="04c5" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">粘贴复制的文本作为<code class="fe om on oo oe b">PROVISIONING_PROFILE_DATA</code> secret的值。</p><h2 id="cd89" class="nr me iu bd mf ns nt dn mj nu nv dp mn lj nw nx mp ln ny nz mr lr oa ob mt oc bi translated">应用商店连接用户名</h2><p id="416e" class="pw-post-body-paragraph la lb iu lc b ld mv jv lf lg mw jy li lj mx ll lm ln my lp lq lr mz lt lu lv in bi translated">此密码应设置为您的开发者帐户的Apple ID。</p><h2 id="9b31" class="nr me iu bd mf ns nt dn mj nu nv dp mn lj nw nx mp ln ny nz mr lr oa ob mt oc bi translated">应用商店连接密码</h2><p id="1fd1" class="pw-post-body-paragraph la lb iu lc b ld mv jv lf lg mw jy li lj mx ll lm ln my lp lq lr mz lt lu lv in bi translated">此密码应设定为Apple ID帐户的特定于应用程序的密码。按照这些说明<a class="ae kz" href="https://support.apple.com/en-us/HT204397" rel="noopener ugc nofollow" target="_blank">创建一个特定于应用程序的密码。</a></p></div><div class="ab cl lw lx hy ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="in io ip iq ir"><h1 id="f36c" class="md me iu bd mf mg mh mi mj mk ml mm mn ka mo kb mp kd mq ke mr kg ms kh mt mu bi translated">关于认证的一个注释</h1><p id="4422" class="pw-post-body-paragraph la lb iu lc b ld mv jv lf lg mw jy li lj mx ll lm ln my lp lq lr mz lt lu lv in bi translated">当在GitHub Actions上下文中运行时，我们需要使用特定于应用程序的密码来验证App Store Connect，因为当帐户启用了<a class="ae kz" href="https://support.apple.com/en-us/HT204915" rel="noopener ugc nofollow" target="_blank">双因素验证</a>时，我们将用于向App Store Connect提交应用程序的工具不支持使用常规密码。自2019年起，具有“账户持有人”角色<a class="ae kz" href="https://developer.apple.com/news/?id=02202019a" rel="noopener ugc nofollow" target="_blank">的开发者账户需要进行双因素认证。</a></p><p id="e4c0" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">我们可以创建一个单独的Apple ID，不启用双因素认证，而不是创建一个特定于应用程序的密码。然后，我们会将其添加到团队中，但不添加“帐户持有人”角色。这可能是一个更安全的解决方案，但它需要更多的工作来设置和维护。对于本教程，我们将使用特定于应用程序的密码。</p></div><div class="ab cl lw lx hy ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="in io ip iq ir"><h1 id="d820" class="md me iu bd mf mg mh mi mj mk ml mm mn ka mo kb mp kd mq ke mr kg ms kh mt mu bi translated">工作流脚本</h1><p id="9855" class="pw-post-body-paragraph la lb iu lc b ld mv jv lf lg mw jy li lj mx ll lm ln my lp lq lr mz lt lu lv in bi translated">为了保持工作流文件的可读性，并使步骤更易于调试，我们将把一些工作流步骤逻辑放在单独的脚本文件中。我们将编写三个脚本，并将它们安装到与<code class="fe om on oo oe b">.github</code>目录中的工作流相邻的<code class="fe om on oo oe b">scripts</code>目录中。第一个脚本将读取项目文件并设置工作流作业环境变量。第二个将设置一个默认的钥匙串，并将签名证书导入其中。第三个将把配置文件写入磁盘。</p><p id="75ba" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">创造<code class="fe om on oo oe b">.github/scripts/set-env-from-xcodeproj.sh</code>:</p><figure class="kk kl km kn gu ko"><div class="bz fq l di"><div class="op oq l"/></div></figure><p id="2fa0" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">该脚本确定项目中第一个方案的名称，然后读取<code class="fe om on oo oe b">PRODUCT_NAME</code>构建设置的值。它使用<code class="fe om on oo oe b"><a class="ae kz" href="https://help.github.com/en/actions/reference/workflow-commands-for-github-actions#setting-an-environment-variable" rel="noopener ugc nofollow" target="_blank">set-env</a></code> <a class="ae kz" href="https://help.github.com/en/actions/reference/workflow-commands-for-github-actions#setting-an-environment-variable" rel="noopener ugc nofollow" target="_blank">工作流命令</a>设置一个同名的作业级<a class="ae kz" href="https://help.github.com/en/actions/configuring-and-managing-workflows/using-environment-variables" rel="noopener ugc nofollow" target="_blank">环境变量</a>。环境变量将在工作流的后续步骤中使用。</p><p id="2ddf" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">创建<code class="fe om on oo oe b">.github/scripts/import-certificate.sh</code>:</p><figure class="kk kl km kn gu ko"><div class="bz fq l di"><div class="op oq l"/></div></figure><p id="ae0d" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">此脚本创建一个新的钥匙串，将其设为默认，解锁它，并将其配置为保持解锁状态。然后，它对来自<code class="fe om on oo oe b">SIGNING_CERTIFICATE_P12_DATA</code>环境变量的签名证书数据进行base64解码，并使用来自<code class="fe om on oo oe b">SIGNING_CERTIFICATE_PASSWORD</code>环境变量的解密密码将其导入到钥匙串中。最后，<a class="ae kz" href="https://stackoverflow.com/a/40039594" rel="noopener ugc nofollow" target="_blank">一些钥匙扣魔法</a>撒在上面。</p><p id="f9b0" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">创造<code class="fe om on oo oe b">.github/scripts/import-profile.sh</code>:</p><figure class="kk kl km kn gu ko"><div class="bz fq l di"><div class="op oq l"/></div></figure><p id="adb4" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">这个脚本创建了<code class="fe om on oo oe b">~/Library/MobileDevice/Provisioning Profiles</code>目录，然后对来自<code class="fe om on oo oe b">PROVISIONING_PROFILE_DATA</code>环境变量的配置文件数据进行base64解码，并存入文件<code class="fe om on oo oe b">profile.mobileprovision</code>。</p><p id="b9af" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">运行以下命令将脚本标记为可执行:</p><pre class="kk kl km kn gu od oe of og aw oh bi"><span id="6dd5" class="nr me iu oe b gz oi oj l ok ol">chmod a+x .github/scripts/*.sh</span></pre></div><div class="ab cl lw lx hy ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="in io ip iq ir"><h1 id="497c" class="md me iu bd mf mg mh mi mj mk ml mm mn ka mo kb mp kd mq ke mr kg ms kh mt mu bi translated">工作流程</h1><p id="8b00" class="pw-post-body-paragraph la lb iu lc b ld mv jv lf lg mw jy li lj mx ll lm ln my lp lq lr mz lt lu lv in bi translated">创建<code class="fe om on oo oe b">.github/workflows/deploy.yml</code>:</p><figure class="kk kl km kn gu ko"><div class="bz fq l di"><div class="op oq l"/></div></figure><p id="620a" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">该工作流以两种方式触发。每当新的提交被推送到<code class="fe om on oo oe b">master</code>分支时，以及每当新的发布标签被推送到存储库时(按照惯例，发布标签是以字母“<code class="fe om on oo oe b">v</code>”开头的任何标签，如“<code class="fe om on oo oe b">v1.2.3</code>”)，它都会被触发。无论工作流是如何触发的，初始步骤都将运行，但是工作流中的最后两个步骤将仅在工作流被发行标签触发时运行。</p><p id="398f" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">工作流从签出与触发工作流运行的项目相同的项目提交开始。</p><p id="30c3" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">接下来，工作流运行我们的<code class="fe om on oo oe b">set-env-from-xcodeproj.sh</code>脚本来设置<code class="fe om on oo oe b">PRODUCT_NAME</code>环境变量。</p><p id="8153" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">然后，工作流运行我们的<code class="fe om on oo oe b">import-certificate.sh</code>脚本，并将<code class="fe om on oo oe b">SIGNING_CERTIFICATE_P12_DATA</code>和<code class="fe om on oo oe b">SIGNING_CERTIFICATE_PASSWORD</code>秘密作为同名的环境变量传递给脚本。</p><p id="5689" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">之后，工作流运行我们的<code class="fe om on oo oe b">import-profile.sh</code>脚本，并将<code class="fe om on oo oe b">PROVISIONING_PROFILE_DATA</code> GitHub secret作为同名的环境变量传递给脚本。</p><p id="8e7f" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">然后，工作流使用来自<code class="fe om on oo oe b"><a class="ae kz" href="https://docs.fastlane.tools/advanced/fastlane/" rel="noopener ugc nofollow" target="_blank">fastlane</a></code>工具的<code class="fe om on oo oe b"><a class="ae kz" href="https://docs.fastlane.tools/actions/build_app/" rel="noopener ugc nofollow" target="_blank">build_app</a></code>动作构建应用程序。<code class="fe om on oo oe b">fastlane</code>工具预装在GitHub builder主机上。我们没有在我们的项目中使用<code class="fe om on oo oe b"><a class="ae kz" href="https://docs.fastlane.tools/advanced/Fastfile/" rel="noopener ugc nofollow" target="_blank">Fastfile</a></code>或者<a class="ae kz" href="https://docs.fastlane.tools/getting-started/ios/setup/#use-a-gemfile" rel="noopener ugc nofollow" target="_blank">将</a> <code class="fe om on oo oe b"><a class="ae kz" href="https://docs.fastlane.tools/getting-started/ios/setup/#use-a-gemfile" rel="noopener ugc nofollow" target="_blank">fastlane</a></code> <a class="ae kz" href="https://docs.fastlane.tools/getting-started/ios/setup/#use-a-gemfile" rel="noopener ugc nofollow" target="_blank">定义为依赖</a>——我们只是利用动作和工具的便利来简化我们的工作流程。如果我们想要更多的控制，我们可以用复杂的调用<code class="fe om on oo oe b">xcodebuild archive</code>和<code class="fe om on oo oe b">xcodebuild -exportArchive</code>来代替这个简单的命令。但是对于我们的目的来说，使用<code class="fe om on oo oe b">fastlane</code>要容易得多。</p><p id="e354" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">接下来，工作流上传构建日志作为<a class="ae kz" href="https://help.github.com/en/actions/configuring-and-managing-workflows/persisting-workflow-data-using-artifacts" rel="noopener ugc nofollow" target="_blank"> GitHub Actions工件</a>。这些日志对于诊断失败的构建可能很有用。通过将它们保存为工件，它们在作业完成后仍然可供下载。</p><p id="565a" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">如果工作流由发布标签触发，则工作流将执行两个最终发布步骤。</p><p id="cc89" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">首先，工作流上传由构建步骤输出的iOS应用商店包(<code class="fe om on oo oe b">ipa</code>)和调试符号(<code class="fe om on oo oe b">dSYMs</code>)作为<a class="ae kz" href="https://help.github.com/en/github/administering-a-repository/about-releases" rel="noopener ugc nofollow" target="_blank"> GitHub release </a>资产。<code class="fe om on oo oe b">GITHUB_TOKEN</code>秘密作为环境变量传递给脚本。虽然保存这些资产并不是绝对必要的，但它们可能有一天会派上用场。如果自动上传到App Store Connect失败，您需要手动重试，则<code class="fe om on oo oe b">ipa</code>可能会有用。如果您想将用户崩溃报告符号化，那么<code class="fe om on oo oe b">dSYMs</code>可能会很有用。</p><p id="18d2" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">然后，工作流将<code class="fe om on oo oe b">ipa</code>上传到App Store Connect。一旦应用程序成功上传，它将可用于TestFlight并提交到应用程序商店。<code class="fe om on oo oe b">APP_STORE_CONNECT_USERNAME</code>和<code class="fe om on oo oe b">APP_STORE_CONNECT_PASSWORD</code>秘密作为同名的环境变量传递给脚本。</p><p id="24e9" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">最后两个发布步骤依赖于我们在工作流的前面从项目的构建设置中设置的<code class="fe om on oo oe b">PRODUCT_NAME</code>环境变量。通过使用这种模式，我们避免了将项目的任何细节硬编码到工作流中，并确保相同的工作流可以跨多个项目存储库使用。</p><p id="2f36" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">提交脚本和工作流，并将它们推送到GitHub，然后转到存储库的“Actions”选项卡，查看工作流的运行情况。</p></div><div class="ab cl lw lx hy ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="in io ip iq ir"><h1 id="aae8" class="md me iu bd mf mg mh mi mj mk ml mm mn ka mo kb mp kd mq ke mr kg ms kh mt mu bi translated">后续步骤</h1><p id="e2f1" class="pw-post-body-paragraph la lb iu lc b ld mv jv lf lg mw jy li lj mx ll lm ln my lp lq lr mz lt lu lv in bi translated">安装了这个工作流之后，每当您将新的提交推送到项目的GitHub存储库时，您应该会看到您的工作流正在运行，并且您可以在标记发布的提交之前验证您的项目是否构建成功。</p><p id="396c" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">如果您的项目包含测试，那么您可能需要考虑在工作流中添加一个额外的步骤(在“构建应用程序”步骤之前)，该步骤运行您的项目测试，并在任何测试失败时返回一个错误。添加一个测试步骤会在每次推送之后给你额外的反馈，并且会防止你意外地发布一个没有通过任何测试的构建。例如，您可以添加一个运行<code class="fe om on oo oe b">fastlane run run_tests</code>的步骤。</p><p id="78fc" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">本教程到此结束。我希望你学到了一些东西。编码快乐！</p></div></div>    
</body>
</html>