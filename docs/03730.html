<html>
<head>
<title>Multithreaded Python: Slithering Through an I/O Bottleneck</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">多线程Python:滑过I/O瓶颈</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/multithreaded-python-slithering-through-an-i-o-bottleneck-65250022b467?source=collection_archive---------8-----------------------#2020-03-01">https://betterprogramming.pub/multithreaded-python-slithering-through-an-i-o-bottleneck-65250022b467?source=collection_archive---------8-----------------------#2020-03-01</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="79d2" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">如何利用Python中的并行性使您的软件速度提高几个数量级</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi ki"><img src="../Images/10d441befd0100a244df96e87484460f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1280/format:webp/0*078rChh1BIgIWXBJ.png"/></div></figure><p id="27b8" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">我最近开发了一个项目，我称之为<a class="ae lm" href="https://github.com/victoriadrake/hydra-link-checker" rel="noopener ugc nofollow" target="_blank"> Hydra </a>:用Python编写的多线程链接检查器。</p><p id="bb04" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">与我在研究中发现的许多Python网站爬虫不同，Hydra只使用标准库，没有像<a class="ae lm" href="https://www.crummy.com/software/BeautifulSoup/bs4/doc/" rel="noopener ugc nofollow" target="_blank"> Beautiful Soup </a>这样的外部依赖。它旨在作为CI/CD流程的一部分运行，因此它的成功部分取决于速度。</p><p id="ea04" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">Python中的多线程是一个有点棘手的问题(不好意思),因为Python解释器实际上并不允许多线程同时执行。</p><p id="bca2" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">Python的<a class="ae lm" href="https://wiki.python.org/moin/GlobalInterpreterLock" rel="noopener ugc nofollow" target="_blank">全局解释器锁</a>，或GIL，防止多个线程同时执行Python字节码。每个想要执行的线程必须首先等待当前正在执行的线程释放GIL。</p><p id="d2e0" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">GIL几乎是低预算会议小组中的麦克风，除了没有人能大声说话的地方。</p><p id="eabe" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">这具有防止<a class="ae lm" href="https://en.wikipedia.org/wiki/Race_condition" rel="noopener ugc nofollow" target="_blank">竞态条件</a>的优点。然而，它缺乏并行运行多个任务所带来的性能优势。(如果你想重温一下并发、并行和多线程，请参阅<a class="ae lm" href="https://victoria.dev/blog/concurrency-parallelism-and-the-many-threads-of-santa-claus/" rel="noopener ugc nofollow" target="_blank"> <em class="ln">并发、并行和圣诞老人的多线程</em> </a>。)</p><p id="ff7c" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">虽然我更喜欢<a class="ae lm" href="https://golang.org/" rel="noopener ugc nofollow" target="_blank"> Go </a>，因为它方便、支持并发的一流原语(参见<a class="ae lm" href="https://tour.golang.org/concurrency/1" rel="noopener ugc nofollow" target="_blank"> Goroutines </a>)，但这个项目的接受者更习惯使用Python。我把它当成了一个考验和探索的机会！</p><p id="42f3" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">在Python中同时执行多个任务并非不可能；只是需要做一些额外的工作。对于Hydra来说，主要优势在于克服输入/输出(I/O)瓶颈。</p><p id="a72c" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">为了让网页被检查，Hydra需要到互联网上获取它们。与CPU单独执行的任务相比，通过网络执行的任务相对较慢。有多慢？</p><p id="30f3" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">以下是在典型电脑上执行任务的大致时间:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="lo lp l"/></div></figure><p id="967e" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">Peter Norvig在几年前的<a class="ae lm" href="http://norvig.com/21-days.html#answers" rel="noopener ugc nofollow" target="_blank"> <em class="ln">十年自学编程</em> </a>中首次发表了这些数字。</p><p id="33da" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">由于计算机及其组件每年都在变化，上面显示的确切数字并不是重点。这些数字有助于说明不同操作之间的数量级差异。</p><p id="c304" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">比较从主存中取数据和通过互联网发送一个简单的数据包的区别。</p><p id="5a84" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">虽然从人类的角度来看，这两种操作都发生在不到一眨眼的时间内，但您可以看到，通过互联网发送一个简单的数据包比从RAM中读取要慢100多万倍。</p><p id="e1cb" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">在单线程程序中，这种差异会很快积累起来，形成麻烦的瓶颈。</p><p id="e4aa" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">在Hydra中，解析响应数据和将结果组装成报告的任务相对较快，因为这都发生在CPU上。程序执行最慢的部分是网络延迟，超过六个数量级。</p><p id="fab3" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">Hydra不仅需要获取数据包，还需要获取整个网页！提高Hydra性能的一个方法是找到一种方法，让页面获取任务在不阻塞主线程的情况下执行。</p><p id="0ec3" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">Python有几个并行执行任务的选项:多个进程或多个线程。这些方法允许您避开GIL，并以几种不同的方式加速执行。</p></div><div class="ab cl lq lr hx ls" role="separator"><span class="lt bw bk lu lv lw"/><span class="lt bw bk lu lv lw"/><span class="lt bw bk lu lv"/></div><div class="im in io ip iq"><h1 id="b25e" class="lx ly it bd lz ma mb mc md me mf mg mh jz mi ka mj kc mk kd ml kf mm kg mn mo bi translated">多重过程</h1><p id="0809" class="pw-post-body-paragraph kq kr it ks b kt mp ju kv kw mq jx ky kz mr lb lc ld ms lf lg lh mt lj lk ll im bi translated">要使用多个进程执行并行任务，可以使用Python的<code class="fe mu mv mw mx b"><a class="ae lm" href="https://docs.python.org/3/library/concurrent.futures.html#concurrent.futures.ProcessPoolExecutor" rel="noopener ugc nofollow" target="_blank">ProcessPoolExecutor</a></code>。来自<code class="fe mu mv mw mx b"><a class="ae lm" href="https://docs.python.org/3/library/concurrent.futures.html" rel="noopener ugc nofollow" target="_blank">concurrent.futures</a></code> <a class="ae lm" href="https://docs.python.org/3/library/concurrent.futures.html" rel="noopener ugc nofollow" target="_blank">模块</a><code class="fe mu mv mw mx b">ProcessPoolExecutor</code>的<code class="fe mu mv mw mx b"><a class="ae lm" href="https://docs.python.org/3/library/concurrent.futures.html#concurrent.futures.Executor" rel="noopener ugc nofollow" target="_blank">Executor</a></code>的一个具体子类使用由<code class="fe mu mv mw mx b"><a class="ae lm" href="https://docs.python.org/3/library/multiprocessing.html#module-multiprocessing" rel="noopener ugc nofollow" target="_blank">multiprocessing</a></code> <a class="ae lm" href="https://docs.python.org/3/library/multiprocessing.html#module-multiprocessing" rel="noopener ugc nofollow" target="_blank">模块</a>产生的进程池来避免GIL。</p><p id="b5a5" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">该选项使用最大默认为机器上处理器数量的工作子进程。<code class="fe mu mv mw mx b">multiprocessing</code>模块允许您跨进程最大限度地并行执行功能，这可以真正加速计算绑定(或<a class="ae lm" href="https://en.wikipedia.org/wiki/CPU-bound" rel="noopener ugc nofollow" target="_blank"> CPU绑定</a>)任务。</p><p id="ad98" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">因为Hydra的主要瓶颈是I/O，而不是CPU要完成的处理，所以使用多线程会更好。</p></div><div class="ab cl lq lr hx ls" role="separator"><span class="lt bw bk lu lv lw"/><span class="lt bw bk lu lv lw"/><span class="lt bw bk lu lv"/></div><div class="im in io ip iq"><h1 id="3810" class="lx ly it bd lz ma mb mc md me mf mg mh jz mi ka mj kc mk kd ml kf mm kg mn mo bi translated">多线程</h1><p id="f9af" class="pw-post-body-paragraph kq kr it ks b kt mp ju kv kw mq jx ky kz mr lb lc ld ms lf lg lh mt lj lk ll im bi translated">顾名思义，Python的<code class="fe mu mv mw mx b"><a class="ae lm" href="https://docs.python.org/3/library/concurrent.futures.html#concurrent.futures.ThreadPoolExecutor" rel="noopener ugc nofollow" target="_blank">ThreadPoolExecutor</a></code>使用线程池来执行异步任务。</p><p id="4ffc" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">也是<code class="fe mu mv mw mx b"><a class="ae lm" href="https://docs.python.org/3/library/concurrent.futures.html#concurrent.futures.Executor" rel="noopener ugc nofollow" target="_blank">Executor</a></code>的一个子类，它使用规定数量的最大工作线程(根据公式<code class="fe mu mv mw mx b">min(32, os.cpu_count() + 4)</code>，默认情况下至少五个)，并在启动新线程之前重用空闲线程，这使得它非常高效。</p><p id="8b38" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">下面是Hydra的一个片段，其中的注释展示了Hydra如何使用<code class="fe mu mv mw mx b">ThreadPoolExecutor</code>来实现并行多线程的好处:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="lo lp l"/></div></figure><p id="e5b9" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">你可以在<a class="ae lm" href="https://github.com/victoriadrake/hydra-link-checker" rel="noopener ugc nofollow" target="_blank"> Hydra的GitHub库</a>中查看完整代码。</p></div><div class="ab cl lq lr hx ls" role="separator"><span class="lt bw bk lu lv lw"/><span class="lt bw bk lu lv lw"/><span class="lt bw bk lu lv"/></div><div class="im in io ip iq"><h1 id="aa6c" class="lx ly it bd lz ma mb mc md me mf mg mh jz mi ka mj kc mk kd ml kf mm kg mn mo bi translated">单线程到多线程</h1><p id="102d" class="pw-post-body-paragraph kq kr it ks b kt mp ju kv kw mq jx ky kz mr lb lc ld ms lf lg lh mt lj lk ll im bi translated">如果你想看完整的效果，我比较了一个原型单线程程序和多线程程序的运行时间。</p><pre class="kj kk kl km gt my mx mz na aw nb bi"><span id="4fd1" class="nc ly it mx b gy nd ne l nf ng">time python3 slow-link-check.py <a class="ae lm" href="https://victoria.dev" rel="noopener ugc nofollow" target="_blank">https://victoria.dev</a></span><span id="a2cf" class="nc ly it mx b gy nh ne l nf ng">real 17m34.084s<br/>user 11m40.761s<br/>sys 0m5.436s</span><span id="2a77" class="nc ly it mx b gy nh ne l nf ng">time python3 hydra.py <a class="ae lm" href="https://victoria.dev" rel="noopener ugc nofollow" target="_blank">https://victoria.dev</a></span><span id="eedd" class="nc ly it mx b gy nh ne l nf ng">real 0m15.729s<br/>user 0m11.071s<br/>sys 0m2.526s</span></pre><p id="7582" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">阻塞I/O的单线程程序运行了大约17分钟。当我第一次运行多线程版本时，它在1分钟13.358秒内完成——经过一些分析和调优，它用了不到16秒。</p><p id="4a2a" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">同样，确切的时间并不意味着什么；它们会根据不同的因素而变化，比如被抓取的站点的大小，你的网络速度，以及你的程序在线程管理的开销和并行性的好处之间的平衡。</p><p id="424e" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">更重要的事情，也是我将随时看到的结果，是一个运行速度快几个数量级的程序。</p></div></div>    
</body>
</html>