<html>
<head>
<title>How Python Lazily Evaluates Boolean-Based Expressions</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Python如何懒惰地评估基于布尔的表达式</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/how-python-lazily-evaluates-boolean-based-expressions-fc9d55d20d8d?source=collection_archive---------16-----------------------#2020-01-27">https://betterprogramming.pub/how-python-lazily-evaluates-boolean-based-expressions-fc9d55d20d8d?source=collection_archive---------16-----------------------#2020-01-27</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="67db" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">蟒蛇皮下的一瞥</h2></div><p id="fc61" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><em class="le">惰性评估</em>是许多编程语言在运行时帮助优化性能的一个概念。</p><p id="7ac8" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在它的核心，惰性计算意味着一个对象在需要的时候被计算，而不是在创建的时候。在Python中，惰性求值的一个简洁特性是如何计算基于逻辑运算符的条件。例如，假设我创建了一个名为<code class="fe lf lg lh li b">boolean_result</code>的布尔变量，它的值是两个函数的<code class="fe lf lg lh li b">or</code>操作符的结果，这两个函数都返回布尔值。</p><figure class="lk ll lm ln gt lo gh gi paragraph-image"><div role="button" tabindex="0" class="lp lq di lr bf ls"><div class="gh gi lj"><img src="../Images/2b13ee89c5355d3fb615693221a1d8f8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*zBOOMI8-BMIG_4beX-SXxA.png"/></div></div><p class="lv lw gj gh gi lx ly bd b be z dk translated">创建一个变量，其值是返回布尔值的两个函数的结果或运算符</p></figure><p id="c3e4" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">如果我运行这个，输出将如下。</p><figure class="lk ll lm ln gt lo gh gi paragraph-image"><div class="gh gi lz"><img src="../Images/50eb8a163d854fdeacd446d744526bf2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1372/format:webp/1*ph9EBDT_GkEpJaJTLUsjSA.png"/></div><p class="lv lw gj gh gi lx ly bd b be z dk translated">运行前面代码的输出</p></figure><p id="d920" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">原因是为了让一个<code class="fe lf lg lh li b">or</code>条件计算为<code class="fe lf lg lh li b">True</code>,<code class="fe lf lg lh li b">or</code>两边的表达式都必须返回<code class="fe lf lg lh li b">True</code>。因为函数<code class="fe lf lg lh li b">condition_one()</code>返回<code class="fe lf lg lh li b">False</code>，所以执行函数<code class="fe lf lg lh li b">condition_two()</code>来检查返回什么值。结果，两个函数都被执行，变量<code class="fe lf lg lh li b">boolean_value</code>的值为<code class="fe lf lg lh li b">False</code>。</p><p id="54ef" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">现在让我们看看当我们更改第8行并使函数<code class="fe lf lg lh li b">condition_one()</code>返回<code class="fe lf lg lh li b">True</code>时会发生什么。所以如果我们做出改变:</p><figure class="lk ll lm ln gt lo gh gi paragraph-image"><div role="button" tabindex="0" class="lp lq di lr bf ls"><div class="gh gi ma"><img src="../Images/93694cf45c762dbc806263a762e61301.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*gvgt_PLdx8hFRaELcxB0HQ.png"/></div></div><p class="lv lw gj gh gi lx ly bd b be z dk translated">注意condition_one()中的第8行返回True</p></figure><p id="0b2f" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">运行之后，输出将是:</p><figure class="lk ll lm ln gt lo gh gi paragraph-image"><div role="button" tabindex="0" class="lp lq di lr bf ls"><div class="gh gi mb"><img src="../Images/c5cfd57aeb95a612ba0d087a656fb933.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*0tfGZn1fEu6rqxxISDPwvg.png"/></div></div><p class="lv lw gj gh gi lx ly bd b be z dk translated">只打印condition_one()的输出</p></figure><p id="2574" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这很酷，因为只执行了功能<code class="fe lf lg lh li b">condition_one()</code>，而没有执行<code class="fe lf lg lh li b">condition_two()</code>。发生这种情况是因为函数<code class="fe lf lg lh li b">condition_one()</code>返回<code class="fe lf lg lh li b">True</code>，并且对于基于<code class="fe lf lg lh li b">or</code>的逻辑表达式，无论<code class="fe lf lg lh li b">condition_two() returns</code>是什么，结果评估值将总是<code class="fe lf lg lh li b">True</code>。Python足够聪明，知道这一点，所以它不运行<code class="fe lf lg lh li b">condition_two()</code>，而是懒洋洋地将结果值评估为<code class="fe lf lg lh li b">True</code>。</p><p id="fb97" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">尽管这两个函数都只打印出一行，但是您可以想象在真实的工作环境中，这两个函数会充满业务逻辑，并且每一个都需要几秒钟(如果不是几分钟的话)才能执行。</p><p id="b6e4" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">因此，可以用来优化<code class="fe lf lg lh li b">or</code> / <code class="fe lf lg lh li b">and</code>表达式的一个很酷的技巧是首先列出计算开销较小的函数，因为表达式是按从左到右的顺序计算的。如果该函数为使用<code class="fe lf lg lh li b">and</code>逻辑运算符的表达式返回一个<code class="fe lf lg lh li b">False</code>,或者为使用<code class="fe lf lg lh li b">or</code>逻辑运算符的表达式返回一个<code class="fe lf lg lh li b">True</code>,那么就没有理由对表达式的其余部分求值，从而节省了时间和计算能力。</p><p id="8d2c" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">虽然上面的例子只是由<code class="fe lf lg lh li b">or</code>组合在一起的两个表达式，但一个非常夸张的例子可能是:</p><figure class="lk ll lm ln gt lo gh gi paragraph-image"><div role="button" tabindex="0" class="lp lq di lr bf ls"><div class="gh gi mc"><img src="../Images/befba2c1af516628457fcb4725c49da9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Y6wyXOexbzBHD6q6wM3p6A.png"/></div></div></figure><p id="4953" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">运行时，将产生以下输出:</p><figure class="lk ll lm ln gt lo gh gi paragraph-image"><div role="button" tabindex="0" class="lp lq di lr bf ls"><div class="gh gi md"><img src="../Images/ef91038a462326bdc95253f2cae172bb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*62mdqEE6DagJXgj63G0h5A.png"/></div></div></figure><p id="dbe9" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">如果我们将<code class="fe lf lg lh li b">condition_one()</code>中的第9行改为返回<code class="fe lf lg lh li b">True</code>，我们会得到:</p><figure class="lk ll lm ln gt lo gh gi paragraph-image"><div role="button" tabindex="0" class="lp lq di lr bf ls"><div class="gh gi me"><img src="../Images/132b162567fb72009be36e4d11b6353c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*dBgPG5R8ROOClH6G_6vYEQ.png"/></div></div></figure><p id="6af6" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">输出将是:</p><figure class="lk ll lm ln gt lo gh gi paragraph-image"><div class="gh gi mf"><img src="../Images/ecbf24a5b14561b7e7393925bea834d0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1348/format:webp/1*yGXk1zl76_QmuN5B2L6Zmw.png"/></div></figure><p id="7350" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">很酷，对吧？</p></div><div class="ab cl mg mh hx mi" role="separator"><span class="mj bw bk mk ml mm"/><span class="mj bw bk mk ml mm"/><span class="mj bw bk mk ml"/></div><div class="im in io ip iq"><h1 id="8d6e" class="mn mo it bd mp mq mr ms mt mu mv mw mx jz my ka mz kc na kd nb kf nc kg nd ne bi translated">实际例子</h1><p id="ebdb" class="pw-post-body-paragraph ki kj it kk b kl nf ju kn ko ng jx kq kr nh kt ku kv ni kx ky kz nj lb lc ld im bi translated">Python条件的延迟求值的这种实现的另一个用途是用于错误检查。举个例子，假设我给你一个表示井字游戏棋盘的类(一个3x3的矩阵)。我预先填充了一些单元格，以便更容易地测试我们将要创建的方法，因为我不会实现整个游戏。</p><figure class="lk ll lm ln gt lo gh gi paragraph-image"><div role="button" tabindex="0" class="lp lq di lr bf ls"><div class="gh gi nk"><img src="../Images/a87337224e7796a07b5164a92a93b806.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*GlxeYEOtGEObkVUTSVuN5A.png"/></div></div></figure><p id="d7b4" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">假设我想让你写一个名为<code class="fe lf lg lh li b">is_cell_empty(row_num, col_num)</code>的方法，它接受两个参数，即行号和列号，并检查棋盘上的那个点是否为玩家下一步棋的位置空着。</p><p id="d460" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">您可以假设一个单元格有三个值:空字符串<code class="fe lf lg lh li b">“”</code>、<code class="fe lf lg lh li b">“X”</code>或<code class="fe lf lg lh li b">“O”</code>。请记住，行号和列号可能会超出界限，即检查第七行第七列的单元格。在这种情况下，让我们假设我们应该返回<code class="fe lf lg lh li b">False</code>,因为那个单元格无论如何都不会是空的。为了简单起见，让我们假设这个助手方法将在一个不同的方法中使用，以实际创建一个有效的井字游戏。</p><p id="3136" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">解决这个问题的一种方法是写下如下内容:</p><figure class="lk ll lm ln gt lo gh gi paragraph-image"><div role="button" tabindex="0" class="lp lq di lr bf ls"><div class="gh gi nl"><img src="../Images/9fb6b37de6ce689ae64932e8e49d817c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*7R_yvscGzejCjwFiBQMqDQ.png"/></div></div></figure><p id="89a6" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">现在这一切都很好，但是因为条件中的表达式是按照它们出现的顺序计算的，我们可以将<code class="fe lf lg lh li b">is_cell_empty()</code>重构为:</p><figure class="lk ll lm ln gt lo gh gi paragraph-image"><div role="button" tabindex="0" class="lp lq di lr bf ls"><div class="gh gi nm"><img src="../Images/7d180d910240bbcf77d2b7604942ea3c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*HuNwBtRClmSghWLcJj8XUA.png"/></div></div></figure><p id="fe1a" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们仍然会得到相同的输出，因为如果前四个条件都评估为<code class="fe lf lg lh li b">True</code>，我们知道<code class="fe lf lg lh li b">row_num</code>和<code class="fe lf lg lh li b">col_num</code>都必须在0和2之间。这使我们可以立即使用这些值来索引游戏板，而不用担心索引错误，因为条件是按从左到右的顺序计算的。</p><p id="519a" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">现在，如果我们把最后一个条件放在第一位，比如…</p><figure class="lk ll lm ln gt lo gh gi paragraph-image"><div role="button" tabindex="0" class="lp lq di lr bf ls"><div class="gh gi nn"><img src="../Images/845184d4ca03d1b466b1f6a3db99519d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*FZuL-BcPSjlS8vpbxc0MWg.png"/></div></div></figure><p id="c78f" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">…如果指定的单元格在边界内，它会工作，但是如果它们不在边界内(比如当我们检查第七行第七列的单元格时)，我们会得到一个越界错误。</p><p id="9921" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">就像我之前说的，这是因为Python按照条件出现的顺序从左到右计算条件(我们假设没有括号)。</p><figure class="lk ll lm ln gt lo gh gi paragraph-image"><div role="button" tabindex="0" class="lp lq di lr bf ls"><div class="gh gi no"><img src="../Images/98936dda260155b4ccf548700cc71d4f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*efAU1pEfEnoywSmmaNyFLg.png"/></div></div></figure><p id="e74b" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在技术访谈期间，当实现广度优先和深度优先的基于搜索矩阵的解决方案时，我使用过在索引之前进行越界检查的技巧。</p><p id="968f" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">不仅Python懒惰地评估基于操作符的逻辑表达式，JavaScript也是如此。我希望这篇文章对你们有用！</p></div></div>    
</body>
</html>