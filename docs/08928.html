<html>
<head>
<title>Authentication in JavaScript: Using Keys, BasicAuth, and OAuth2</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">JavaScript中的身份验证:使用密钥、BasicAuth和OAuth2</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/authentication-in-javascript-using-keys-basicauth-and-oauth2-8360ce624d3a?source=collection_archive---------1-----------------------#2021-06-27">https://betterprogramming.pub/authentication-in-javascript-using-keys-basicauth-and-oauth2-8360ce624d3a?source=collection_archive---------1-----------------------#2021-06-27</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="4907" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">并不是所有的API都像Twilio一样有完整的文档。本指南帮助您使用通过密钥、BasicAuth或OAuth保护的API</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/e9d23f89bfc82c1c1506b2c542fc97c0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*vOZSEvcbW0MbYYg6"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">玛利亚·齐格勒在<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</p></figure><p id="e974" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们将使用以下API:</p><ul class=""><li id="ced4" class="lv lw it lb b lc ld lf lg li lx lm ly lq lz lu ma mb mc md bi translated"><a class="ae ky" href="https://dukengn.github.io/Dog-facts-API/" rel="noopener ugc nofollow" target="_blank">狗的事实</a></li><li id="82a6" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated"><a class="ae ky" href="https://thecatapi.com/" rel="noopener ugc nofollow" target="_blank">卡特彼勒API —卡特彼勒服务</a></li><li id="9257" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated"><a class="ae ky" href="https://www.twilio.com/docs/usage/api" rel="noopener ugc nofollow" target="_blank"> Twilio API </a></li><li id="7848" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated"><a class="ae ky" href="https://docs.github.com/en/rest" rel="noopener ugc nofollow" target="_blank"> GitHub API </a></li><li id="f0ff" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated"><a class="ae ky" href="https://docs.genius.com/" rel="noopener ugc nofollow" target="_blank"> Genius API </a></li></ul><p id="eb87" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果您对类似的Python指南感兴趣，请查看我以前的文章<a class="ae ky" href="https://www.realpythonproject.com/how-to-authenticate-using-keys-basicauth-oauth-in-python/" rel="noopener ugc nofollow" target="_blank">。</a></p><p id="c2ad" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">希望对JavaScript中的承诺有所了解。查看Eric Elliott<a class="mj mk ep" href="https://medium.com/u/c359511de780?source=post_page-----8360ce624d3a--------------------------------" rel="noopener" target="_blank">的这篇</a><a class="ae ky" href="https://medium.com/javascript-scene/master-the-javascript-interview-what-is-a-promise-27fc71e77261" rel="noopener">文章</a>，了解JavaScript中的承诺。</p><p id="03cd" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">还应该对Fetch API有所了解。这里有一篇由Swapnil Bangare 撰写的的文章。</p><h1 id="36e9" class="ml mm it bd mn mo mp mq mr ms mt mu mv jz mw ka mx kc my kd mz kf na kg nb nc bi translated">目录</h1><pre class="kj kk kl km gt nd ne nf ng aw nh bi"><span id="0a7c" class="ni mm it ne b gy nj nk l nl nm"><a class="ae ky" href="#6c6c" rel="noopener ugc nofollow">Insecure APIs</a><a class="ae ky" href="#3d69" rel="noopener ugc nofollow"><br/>Reading values from .env files</a><br/><a class="ae ky" href="#bc2e" rel="noopener ugc nofollow">APIs with keys</a><br/><a class="ae ky" href="#8bb3" rel="noopener ugc nofollow">APIs with basic auth</a><br/><a class="ae ky" href="#ad0d" rel="noopener ugc nofollow">API wrappers</a><br/><a class="ae ky" href="#fee4" rel="noopener ugc nofollow">APIs secured via OAuth2</a><br/><a class="ae ky" href="#7ab6" rel="noopener ugc nofollow">Using the GitHub API (OAuth2)</a><br/><a class="ae ky" href="#2ae3" rel="noopener ugc nofollow">Using the Genius API (OAuth2)</a></span></pre><p id="6b35" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">希望对承诺和异步/等待有所了解。我将在一个<a class="ae ky" href="https://nodejs.org/en/" rel="noopener ugc nofollow" target="_blank"> NodeJS </a>环境中运行代码。</p><p id="b10c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">你可以在<a class="ae ky" href="https://github.com/rahulbanerjee26/javascript_apis" rel="noopener ugc nofollow" target="_blank"> GitHub </a>中找到源代码。</p><h1 id="6c6c" class="ml mm it bd mn mo mp mq mr ms mt mu mv jz mw ka mx kc my kd mz kf na kg nb nc bi translated">不安全的API</h1><p id="2439" class="pw-post-body-paragraph kz la it lb b lc nn ju le lf no jx lh li np lk ll lm nq lo lp lq nr ls lt lu im bi translated"><a class="ae ky" href="https://dukengn.github.io/Dog-facts-API/" rel="noopener ugc nofollow" target="_blank"> Dog Facts API </a>不需要任何认证，并且是公开可用的。使用它相当简单。</p><p id="e786" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们将向以下端点发出请求:</p><pre class="kj kk kl km gt nd ne nf ng aw nh bi"><span id="b3da" class="ni mm it ne b gy nj nk l nl nm"><a class="ae ky" href="https://dog-facts-api.herokuapp.com/api/v1/resources/dogs/all" rel="noopener ugc nofollow" target="_blank">https://dog-facts-api.herokuapp.com/api/v1/resources/dogs/all</a></span></pre><p id="755f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">首先，我们需要安装节点获取库:</p><pre class="kj kk kl km gt nd ne nf ng aw nh bi"><span id="f740" class="ni mm it ne b gy nj nk l nl nm">npm install node-fetch</span></pre><p id="e52a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在，让我们用JavaScript向上述端点发出GET请求:</p><pre class="kj kk kl km gt nd ne nf ng aw nh bi"><span id="85e9" class="ni mm it ne b gy nj nk l nl nm">const fetch = require("node-fetch");</span><span id="b757" class="ni mm it ne b gy ns nk l nl nm">const apiURL = "https://dog-facts-api.herokuapp.com/api/v1/resources/dogs/all";<br/>console.log(`Making Request to ${apiURL}`);<br/>fetch(apiURL)<br/>  .then((result) =&gt; result.json())<br/>  .then((res) =&gt; {<br/>    res.map((element, idx) =&gt; console.log(`${idx}. ${element.fact}`));<br/>  })<br/>  .catch((err) =&gt; console.log(err));</span></pre><p id="6eab" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们导入节点获取库并向端点发出请求。我们添加一个<code class="fe nt nu nv ne b">.then</code>来解析承诺，添加一个<code class="fe nt nu nv ne b">.catch</code>来处理错误。</p><h1 id="3d69" class="ml mm it bd mn mo mp mq mr ms mt mu mv jz mw ka mx kc my kd mz kf na kg nb nc bi translated">阅读来自。环境文件</h1><p id="971b" class="pw-post-body-paragraph kz la it lb b lc nn ju le lf no jx lh li np lk ll lm nq lo lp lq nr ls lt lu im bi translated">在进入下一节之前，让我们看看如何从一个<code class="fe nt nu nv ne b">.env</code>文件中读取变量。强烈建议将您的凭证存储在一个<code class="fe nt nu nv ne b">.env</code>文件中，以避免它们暴露给其他人。</p><p id="5606" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们需要安装dotenv库:</p><pre class="kj kk kl km gt nd ne nf ng aw nh bi"><span id="c60d" class="ni mm it ne b gy nj nk l nl nm">npm install dotenv</span></pre><p id="d5f1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">假设我们有一个带有随机API令牌的<code class="fe nt nu nv ne b">.env</code>文件:</p><pre class="kj kk kl km gt nd ne nf ng aw nh bi"><span id="512f" class="ni mm it ne b gy nj nk l nl nm">API_TOKEN = "SOME API TOKEN"</span></pre><p id="993f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们尝试用JavaScript读取API令牌:</p><pre class="kj kk kl km gt nd ne nf ng aw nh bi"><span id="e81e" class="ni mm it ne b gy nj nk l nl nm">require('dotenv').config()</span><span id="4519" class="ni mm it ne b gy ns nk l nl nm">const API_KEY=  process.env.API_KEY</span></pre><h1 id="bc2e" class="ml mm it bd mn mo mp mq mr ms mt mu mv jz mw ka mx kc my kd mz kf na kg nb nc bi translated">带键的API</h1><p id="a980" class="pw-post-body-paragraph kz la it lb b lc nn ju le lf no jx lh li np lk ll lm nq lo lp lq nr ls lt lu im bi translated">这是使用API时最常见的身份验证形式。在发出请求时，API密钥/令牌作为标头传入。我们将使用<a class="ae ky" href="https://thecatapi.com/" rel="noopener ugc nofollow" target="_blank">卡特彼勒API —卡特彼勒服务</a>。你可以在这里得到一把钥匙。</p><pre class="kj kk kl km gt nd ne nf ng aw nh bi"><span id="bf48" class="ni mm it ne b gy nj nk l nl nm">const fetch = require("node-fetch");<br/>require("dotenv").config();</span><span id="49f2" class="ni mm it ne b gy ns nk l nl nm">const CAT_API_KEY = process.env.API_KEY;<br/>const headers = {<br/>  "x-api-key": CAT_API_KEY,<br/>};<br/>const api_url = "https://api.thecatapi.com/v1/breeds";</span><span id="728f" class="ni mm it ne b gy ns nk l nl nm">fetch(api_url, {<br/>  headers: headers,<br/>})<br/>  .then((result) =&gt; result.json())<br/>  .then((res) =&gt; {<br/>    res.map((element, idx) =&gt;<br/>      console.log(`${idx}. ${element.name} : ${element.description}`)<br/>    );<br/>  })<br/>  .catch((err) =&gt; console.log(err));</span></pre><p id="cb70" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们创建了一个名为<code class="fe nt nu nv ne b">headers</code>的对象来存储API密钥。对象中的关键是<code class="fe nt nu nv ne b">x-api-key</code>。但是，这可能会因您使用的API而异。有些API要求将键命名为<code class="fe nt nu nv ne b">Authorization</code>、<code class="fe nt nu nv ne b">authorization</code>、<code class="fe nt nu nv ne b">token</code>等。最好参考您的API文档的认证部分。</p><p id="07c1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">载体认证很常见，它要求单词<code class="fe nt nu nv ne b">Bearer </code>(注意后面的空格)在API token/ey的开头。</p><pre class="kj kk kl km gt nd ne nf ng aw nh bi"><span id="1816" class="ni mm it ne b gy nj nk l nl nm">headers = {<br/>    "authorization": f"Bearer {access_token}"<br/>}</span></pre><p id="2592" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们将在后面的示例中使用载体认证。</p><h1 id="8bb3" class="ml mm it bd mn mo mp mq mr ms mt mu mv jz mw ka mx kc my kd mz kf na kg nb nc bi translated">具有基本身份验证的API</h1><p id="8e97" class="pw-post-body-paragraph kz la it lb b lc nn ju le lf no jx lh li np lk ll lm nq lo lp lq nr ls lt lu im bi translated">使用基本身份验证保护的API需要用户名和密码。通常，用户名是客户端ID，密码是API的客户端机密。在某些情况下，用户名可以留空。这应该在API文档中提及。</p><p id="d312" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">使用基本认证来保护<a class="ae ky" href="https://www.twilio.com/docs/usage/api" rel="noopener ugc nofollow" target="_blank"> Twilio API </a>。你可以在Twilio网站上注册并获得API证书。</p><p id="b3b7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们将使用base-64库，您可以使用npm安装该库:</p><pre class="kj kk kl km gt nd ne nf ng aw nh bi"><span id="f715" class="ni mm it ne b gy nj nk l nl nm">npm install base-64</span></pre><p id="d549" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">唯一的区别是在发出GET请求时我们将传递的<code class="fe nt nu nv ne b">headers</code>对象。我们将使用如下所示的标题对象:</p><pre class="kj kk kl km gt nd ne nf ng aw nh bi"><span id="0d42" class="ni mm it ne b gy nj nk l nl nm">headers = {<br/>    'Authorization' : 'Basic ' + base64.encode(twilio_id + ":" + twilio_token)<br/>}</span></pre><p id="6d31" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">注意<code class="fe nt nu nv ne b">Basic </code>后面有一个空格。</p><p id="f503" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">对于Twilio，用户名是您的帐户ID，密码是您的帐户令牌。如前所述，对于不同的API，它可以是不同的。如果您使用的API使用基本身份验证来保护其端点，请参考文档以获取用户名和密码。</p><p id="6ed5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在让我们向Twilio API发出一个请求:</p><pre class="kj kk kl km gt nd ne nf ng aw nh bi"><span id="5814" class="ni mm it ne b gy nj nk l nl nm">const fetch = require("node-fetch");<br/>const base64 = require("base-64");</span><span id="9343" class="ni mm it ne b gy ns nk l nl nm">require("dotenv").config();<br/>const twilio_id = process.env.TWILIO_ACCOUNT_SID;<br/>const twilio_token = process.env.TWILIO_ACCOUNT_TOKEN;</span><span id="2a64" class="ni mm it ne b gy ns nk l nl nm">headers = {<br/>  Authorization: "Basic " + base64.encode(twilio_id + ":" + twilio_token),<br/>};<br/>const api_url = `https://api.twilio.com/2010-04-01/Accounts/${twilio_id}/Calls.json?PageSize=5`;</span><span id="e2bf" class="ni mm it ne b gy ns nk l nl nm">fetch(api_url, {<br/>  headers: headers,<br/>})<br/>  .then((res) =&gt; res.json())<br/>  .then((res) =&gt; console.log(res))<br/>  .catch((err) =&gt; console.log(err));</span></pre><p id="5c22" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如您所见，该代码与我们向Cat API发出请求时编写的代码非常相似，唯一的区别在于<code class="fe nt nu nv ne b">headers</code>对象。</p><h1 id="ad0d" class="ml mm it bd mn mo mp mq mr ms mt mu mv jz mw ka mx kc my kd mz kf na kg nb nc bi translated">API包装</h1><p id="dcc9" class="pw-post-body-paragraph kz la it lb b lc nn ju le lf no jx lh li np lk ll lm nq lo lp lq nr ls lt lu im bi translated">API包装器本质上是可以使用npm安装的包。它们使与API的交互更加容易，并使您的代码看起来更加整洁。在幕后，这个包将使用fetch和headers来验证您的请求。然而，包装器使代码看起来更干净。</p><p id="ab45" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">Twilio有一个可以使用npm安装的包装器:</p><pre class="kj kk kl km gt nd ne nf ng aw nh bi"><span id="c748" class="ni mm it ne b gy nj nk l nl nm">npm install twilio</span></pre><p id="d7d0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们使用Twilio包装器与Twilio API进行交互:</p><pre class="kj kk kl km gt nd ne nf ng aw nh bi"><span id="9dbe" class="ni mm it ne b gy nj nk l nl nm">const twilio = require('twilio')<br/>require('dotenv').config()<br/>const twilio_id = process.env.TWILIO_ACCOUNT_SID<br/>const twilio_token = process.env.TWILIO_ACCOUNT_TOKEN</span><span id="48b4" class="ni mm it ne b gy ns nk l nl nm">const client = new twilio(twilio_id,twilio_token)<br/>client.calls.each(call =&gt; console.log(call),pageSize = 5);</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nw"><img src="../Images/194200bfdb04f1dc68bde877875a6d6f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*7sp3yPY3-EheMRIh.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">作者截图</p></figure><p id="6103" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">为了处理错误，我们可以将代码放在try中..接住滑轮。</p><p id="4c7d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">不幸的是，不是所有的API都有包装器。然而，他们中的许多人确实如此。在直接使用API之前，尝试为它搜索一个包装器。这将大大简化API的使用。</p><h1 id="fee4" class="ml mm it bd mn mo mp mq mr ms mt mu mv jz mw ka mx kc my kd mz kf na kg nb nc bi translated">通过OAuth2保护的API</h1><p id="19b1" class="pw-post-body-paragraph kz la it lb b lc nn ju le lf no jx lh li np lk ll lm nq lo lp lq nr ls lt lu im bi translated"><a class="ae ky" href="https://oauth.net/2/" rel="noopener ugc nofollow" target="_blank"> OAuth2 </a>当你需要“使用谷歌注册”或“使用脸书注册”选项时，web flow通常用于在Express应用程序中进行身份验证。然而，一些API需要OAuth2用于它们的所有端点。GitHub API支持OAuth2认证以及基于密钥的认证。在本文中，我们将使用OAuth web流来处理GitHub API和Genius API。</p><p id="a302" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">关于OAuth2是如何工作的，我不会说得太详细，因为这超出了本文的范围。下面是一个高层次的概述。如果没有意义，跳到GitHub或者Genius API部分，应该会更有意义。</p><ul class=""><li id="5f1d" class="lv lw it lb b lc ld lf lg li lx lm ly lq lz lu ma mb mc md bi translated">我们将不得不在API的网站上创建一个客户端应用程序。</li><li id="5db5" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated">客户端应用程序将有一个客户端ID和客户端密码。</li><li id="ad38" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated">我们必须向API的认证端点发出请求。客户端ID和客户端密码将作为查询参数传递。</li><li id="ffe1" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated">身份验证端点将请求许可，并且必须被授权。</li></ul><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi nx"><img src="../Images/7a8c6c772e866b3a99a3e132baf33798.png" data-original-src="https://miro.medium.com/v2/resize:fit:886/format:webp/0*tHLswzFYTzNMpV3J.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">作者截图</p></figure><ul class=""><li id="4ffd" class="lv lw it lb b lc ld lf lg li lx lm ly lq lz lu ma mb mc md bi translated">一旦授权，它将返回一个代码。</li><li id="7443" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated">该代码将必须被提供给另一个端点，该端点将把它交换为访问令牌。</li><li id="7f99" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated">这个访问令牌现在可以用作密钥，并在向端点发出请求时作为header对象传递。</li></ul><p id="7bc2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们来看几个例子。</p><h1 id="7ab6" class="ml mm it bd mn mo mp mq mr ms mt mu mv jz mw ka mx kc my kd mz kf na kg nb nc bi translated">使用GitHub API (OAuth2)</h1><p id="b6a8" class="pw-post-body-paragraph kz la it lb b lc nn ju le lf no jx lh li np lk ll lm nq lo lp lq nr ls lt lu im bi translated">如上所述，OAuth2主要用于Express应用程序。使用OAuth2时，您将需要一个web应用程序URL和一个URL，以便在用户授权/授予权限后将用户重定向到该URL。由于我们没有网络应用程序，我们没有任何网址。但是，我们可以使用<a class="ae ky" href="https://httpbin.org/" rel="noopener ugc nofollow" target="_blank"> HTTPBin </a>。每当我们需要一个URL时，我们可以使用下面的URL:</p><pre class="kj kk kl km gt nd ne nf ng aw nh bi"><span id="2b11" class="ni mm it ne b gy nj nk l nl nm"><a class="ae ky" href="https://httpbin.org/anything" rel="noopener ugc nofollow" target="_blank">https://httpbin.org/anything</a></span></pre><p id="bea3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">首先，你必须<a class="ae ky" href="https://docs.github.com/en/developers/apps/building-github-apps/creating-a-github-app" rel="noopener ugc nofollow" target="_blank">创建一个GitHub应用</a>。当询问web应用程序URL或重定向URL时，使用上面讨论的URL。创建应用程序后，将客户端ID和客户端密码存储在<code class="fe nt nu nv ne b">.env</code>文件中。</p><p id="7069" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们将使用async/await编写我们的代码，使其更具可读性。</p><pre class="kj kk kl km gt nd ne nf ng aw nh bi"><span id="d031" class="ni mm it ne b gy nj nk l nl nm">const client_id = process.env.GITHUB_API_CLIENT_ID;<br/>  const client_secret = process.env.GITHUB_API_CLIENT_SECRET;<br/>  const redirect_uri = "https://httpbin.org/anything";</span><span id="011f" class="ni mm it ne b gy ns nk l nl nm">  let params = {<br/>    client_id: client_id,<br/>    redirect_uri: redirect_uri,<br/>    scope: "user",<br/>  };</span><span id="ead8" class="ni mm it ne b gy ns nk l nl nm">  let endpoint = "https://github.com/login/oauth/authorize?";<br/>  endpoint = endpoint + new URLSearchParams(params);</span><span id="095d" class="ni mm it ne b gy ns nk l nl nm">  const open = require("open");<br/>  open(endpoint);</span></pre><p id="aaab" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">前几行只是从我们的<code class="fe nt nu nv ne b">.env</code>文件中读取凭证。params对象包含客户机ID、重定向URL(我们前面讨论过的HTTPBin URL)和作用域。范围的值决定了可以访问的端点和可以执行的HTTP谓词操作。</p><p id="1e5b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">为了给我们的URL添加参数，我们可以使用<code class="fe nt nu nv ne b">URLSearchParams</code>。要打开URL，我们将使用<code class="fe nt nu nv ne b">open()</code>功能。可以使用npm安装它:</p><pre class="kj kk kl km gt nd ne nf ng aw nh bi"><span id="3593" class="ni mm it ne b gy nj nk l nl nm">npm install open</span></pre><p id="03cc" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">单击Authorize后，您应该被重定向到HTTPBin URL，并且应该显示一个JSON对象。查看键“代码”的值这个值将被交换成一个API令牌。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nw"><img src="../Images/9ca6e8cd4c6a27c73d536fce54601bb5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*G-PZ84APMQlMPlSG.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">作者截图</p></figure><p id="e59e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们可以使用readline-sync来获取输入。</p><pre class="kj kk kl km gt nd ne nf ng aw nh bi"><span id="3aad" class="ni mm it ne b gy nj nk l nl nm">npm install readline-sync</span></pre><p id="2e44" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们将等待用户输入他们的访问代码:</p><pre class="kj kk kl km gt nd ne nf ng aw nh bi"><span id="ba66" class="ni mm it ne b gy nj nk l nl nm">const readlineSync = require("readline-sync");<br/>  const access_code = readlineSync.question("Please enter the access code ");<br/>  console.log("CODE IS ", access_code);</span></pre><p id="0061" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">一旦我们获得了代码，我们向一个端点发出另一个请求来获得一个访问令牌。这一次，我们将代码和客户机秘密作为参数传递。在GitHub验证了凭证和代码之后，它将返回一个访问令牌。这个访问令牌可以用作API密钥。</p><pre class="kj kk kl km gt nd ne nf ng aw nh bi"><span id="28bd" class="ni mm it ne b gy nj nk l nl nm">params["client_secret"] = client_secret;<br/>  params["code"] = access_code;<br/>  const access_token_url = "https://github.com/login/oauth/access_token?";<br/>  let response = await fetch(access_token_url + new URLSearchParams(params), {<br/>    headers: { Accept: "application/json", method: "POST" },<br/>  });<br/>  let data = await response.json();<br/>  const access_token = data["access_token"];<br/>  console.log(access_token);</span></pre><p id="170c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这个访问令牌可以用来验证我们自己并向API端点发出请求。</p><pre class="kj kk kl km gt nd ne nf ng aw nh bi"><span id="b6ca" class="ni mm it ne b gy nj nk l nl nm">const headers = {<br/>    Authorization: `token ${access_token}`,<br/>  };</span><span id="bbd9" class="ni mm it ne b gy ns nk l nl nm">  const base_api_endpoint = "https://api.github.com/user";<br/>  response = await fetch(base_api_endpoint + "/repos", {<br/>    headers: headers,<br/>  });<br/>  data = await response.json();<br/>  console.log(data);</span></pre><h1 id="2ae3" class="ml mm it bd mn mo mp mq mr ms mt mu mv jz mw ka mx kc my kd mz kf na kg nb nc bi translated">使用Genius API (OAuth2)</h1><p id="a90c" class="pw-post-body-paragraph kz la it lb b lc nn ju le lf no jx lh li np lk ll lm nq lo lp lq nr ls lt lu im bi translated">让我们看另一个例子。我将跳过导入包和阅读凭证的部分。</p><pre class="kj kk kl km gt nd ne nf ng aw nh bi"><span id="3223" class="ni mm it ne b gy nj nk l nl nm">let params = {<br/>    client_id: genius_client_id,<br/>    redirect_uri: redirect_uri,<br/>    response_type: "code",<br/>    scope: "me",<br/>  };</span><span id="5eda" class="ni mm it ne b gy ns nk l nl nm">  let endpoint = "https://api.genius.com/oauth/authorize?";<br/>  endpoint = endpoint + new URLSearchParams(params);</span><span id="64ce" class="ni mm it ne b gy ns nk l nl nm">  const open = require("open");<br/>  open(endpoint);</span></pre><p id="0d57" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">对于某些API来说，<code class="fe nt nu nv ne b">response_type</code>是强制的，其值应该总是<code class="fe nt nu nv ne b">“code”</code>。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nw"><img src="../Images/39fdb7065bac15e82448d23f0093de90.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*6i22RRH6iecFvt7H.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">作者截图</p></figure><p id="eeee" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在我们授权之后，我们将看到一个JSON对象，类似于我们在使用GitHub API时看到的对象。输入代码。</p><pre class="kj kk kl km gt nd ne nf ng aw nh bi"><span id="47ee" class="ni mm it ne b gy nj nk l nl nm">const readlineSync = require("readline-sync");<br/>  const access_code = readlineSync.question("Please enter the access code ");<br/>  console.log("CODE IS ", access_code);</span><span id="0e5f" class="ni mm it ne b gy ns nk l nl nm">  params["client_secret"] = genius_client_secret;<br/>  params["code"] = access_code;<br/>  params["grant_type"] = "authorization_code";</span><span id="f6e7" class="ni mm it ne b gy ns nk l nl nm">  const access_token_url = "https://api.genius.com/oauth/token?";<br/>  let response = await fetch(access_token_url + new URLSearchParams(params), {<br/>    headers: { Accept: "application/json" },<br/>    method: "POST",<br/>  });<br/>  let data = await response.json();<br/>  const access_token = data["access_token"];<br/>  console.log(access_token);</span></pre><p id="a64f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe nt nu nv ne b">grant_type</code>也是一些API所要求的。值总是<code class="fe nt nu nv ne b">“authorization_code”</code>。在我们的代码被验证之后，我们得到一个访问令牌。这个令牌可以用作API密钥。</p><pre class="kj kk kl km gt nd ne nf ng aw nh bi"><span id="eb0f" class="ni mm it ne b gy nj nk l nl nm">const headers = {<br/>    authorization: `Bearer ${access_token}`,<br/>  };</span><span id="0d6d" class="ni mm it ne b gy ns nk l nl nm">  const base_api_endpoint = "https://api.genius.com/account";<br/>  response = await fetch(base_api_endpoint, {<br/>    headers: headers,<br/>  });<br/>  data = await response.json();<br/>  console.log(data);</span></pre><p id="055c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">Genius API使用不记名身份验证。</p><h1 id="c553" class="ml mm it bd mn mo mp mq mr ms mt mu mv jz mw ka mx kc my kd mz kf na kg nb nc bi translated">结论</h1><p id="cff8" class="pw-post-body-paragraph kz la it lb b lc nn ju le lf no jx lh li np lk ll lm nq lo lp lq nr ls lt lu im bi translated">我希望这篇文章能成为在JavaScript中使用API的好指南。在直接使用API之前，总是要寻找一个包装器。你花五分钟找一个包装纸可能会让你省去几个小时的头痛。</p><p id="78fb" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><em class="ny">原贴于</em><a class="ae ky" href="https://www.realpythonproject.com/how-to-authenticate-using-keys-basicauth-oauth2-in-javascript/" rel="noopener ugc nofollow" target="_blank"><em class="ny">【realpythonproject.com】</em></a></p><p id="4205" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><em class="ny">在</em><a class="ae ky" href="https://www.linkedin.com/in/rahulbanerjee2699/" rel="noopener ugc nofollow" target="_blank"><em class="ny">LinkedIn</em></a><em class="ny">，</em> <a class="ae ky" href="https://twitter.com/rahulbanerjee99" rel="noopener ugc nofollow" target="_blank"> <em class="ny"> Twitter </em> </a>上与我联系</p></div></div>    
</body>
</html>