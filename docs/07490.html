<html>
<head>
<title>How To Listen for Any Dispatched NgRx Actions With ActionsSubject</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何使用ActionsSubject侦听任何调度的NgRx操作</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/how-to-listen-for-any-dispatched-ngrx-actions-with-actionssubject-9916b69b1e93?source=collection_archive---------7-----------------------#2021-01-20">https://betterprogramming.pub/how-to-listen-for-any-dispatched-ngrx-actions-with-actionssubject-9916b69b1e93?source=collection_archive---------7-----------------------#2021-01-20</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="3d06" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">每当调度任何操作时得到通知</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/7d8ed7c355fe802e7f279a7703f6eeeb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*KPW8uReGNd85xL2Z"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">克里斯·莱佩尔特在<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片。</p></figure><p id="deed" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><a class="ae ky" href="https://ngrx.io" rel="noopener ugc nofollow" target="_blank"> NgRx </a>是一个广泛用于角度应用的反应式状态管理库。受Redux的启发，NgRx使用<a class="ae ky" href="https://rxjs-dev.firebaseapp.com" rel="noopener ugc nofollow" target="_blank"> RxJS </a>来允许用户以快速和一致的方式管理整个应用程序的全局状态。不是每个应用程序都需要状态管理解决方案，但是将应用程序的状态和逻辑集中起来可以实现强大的功能，比如撤销/重做、状态持久化等等。</p><p id="553c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">为了使用NgRx，需要理解一些关键概念，而<a class="ae ky" href="https://ngrx.io/guide/store/actions" rel="noopener ugc nofollow" target="_blank">动作</a>就是其中之一。在NgRx上下文中，动作描述了可以从任何地方(例如，从组件和服务)分派的唯一事件。下面的代码显示了一个简单的操作可能是什么样子。显示登录屏幕的组件可以分派这个动作来告诉正在监听的人(例如<a class="ae ky" href="https://ngrx.io/guide/effects" rel="noopener ugc nofollow" target="_blank">效果</a>)应该向我们后端的登录端点发送一个HTTP请求。登录数据是通过调度的操作提供的:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="lv lw l"/></div></figure><p id="3f6d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">一个<a class="ae ky" href="https://medium.com/better-programming/how-to-write-better-ui-component-tests-with-testing-library-e80bc489051c" rel="noopener">组件测试</a>可以验证一个特定的动作已经被分派(例如，在提交登录表单之后),我推荐编写这种类型的测试。这种测试可以包含断言，即包含您想要共享的任何数据(例如登录数据)的特定动作已经被分派。</p><p id="174e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果您的应用程序变得更大，您的应用程序状态也会随之增长。你可能从几个动作、一个<a class="ae ky" href="https://ngrx.io/guide/store/reducers" rel="noopener ugc nofollow" target="_blank">缩减器</a>和总共两个效果开始，但几年后，你可能突然有了分散在不同团队拥有的不同应用和库中的动作、缩减器和效果。</p><p id="cbef" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在这篇短文中，我想向您展示一种简单的方法来检测一个动作何时被调度。在这个简单的例子中，我将简单地将任何分派的操作记录到浏览器控制台。</p></div><div class="ab cl lx ly hx lz" role="separator"><span class="ma bw bk mb mc md"/><span class="ma bw bk mb mc md"/><span class="ma bw bk mb mc"/></div><div class="im in io ip iq"><h1 id="a0f0" class="me mf it bd mg mh mi mj mk ml mm mn mo jz mp ka mq kc mr kd ms kf mt kg mu mv bi translated">如何用ActionsSubject检测调度的NgRx操作</h1><p id="5100" class="pw-post-body-paragraph kz la it lb b lc mw ju le lf mx jx lh li my lk ll lm mz lo lp lq na ls lt lu im bi translated">NgRx提供了一个名为<code class="fe nb nc nd ne b"><a class="ae ky" href="https://ngrx.io/api/store/ActionsSubject" rel="noopener ugc nofollow" target="_blank">ActionsSubject</a></code>的实用程序，我们可以通过依赖注入来访问它。这个名字已经表明我们正在处理一个<code class="fe nb nc nd ne b"><a class="ae ky" href="https://rxjs-dev.firebaseapp.com/guide/subject" rel="noopener ugc nofollow" target="_blank">Subject</a></code>。一只<code class="fe nb nc nd ne b">Subject</code>是一种特殊类型的<code class="fe nb nc nd ne b"><a class="ae ky" href="https://rxjs-dev.firebaseapp.com/api/index/class/Observable" rel="noopener ugc nofollow" target="_blank">Observable</a></code>。因此，我们可以订阅它以获取它的最新值。在这种情况下，我们通过这个流获取的任何值都是一个已经被分派的NgRx动作。</p><p id="315c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">通过订阅<code class="fe nb nc nd ne b">ActionsSubject</code>，我们将被通知我们应用程序中任何地方发出的任何动作。我们可以记录传入的操作，以验证是否已经使用正确的数据并以正确的顺序分派了适当的操作。这有助于理解在整个会话中如何以及何时分派动作。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="lv lw l"/></div></figure><p id="a0bf" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">关于上面的代码，需要注意一些事情:</p><ul class=""><li id="7d30" class="nf ng it lb b lc ld lf lg li nh lm ni lq nj lu nk nl nm nn bi translated">我添加了<code class="fe nb nc nd ne b">skip(1)</code>来避免记录NgRx自己调度的第一个动作。</li><li id="45aa" class="nf ng it lb b lc no lf np li nq lm nr lq ns lu nk nl nm nn bi translated">您应该考虑是否真的要记录任何调度的操作。毕竟，您可能不希望在生产中记录用户凭证。一种方法是在开发模式下只进行监听，从而禁止生产中的任何操作记录。</li><li id="c432" class="nf ng it lb b lc no lf np li nq lm nr lq ns lu nk nl nm nn bi translated">您应该取消订阅以避免内存泄漏。例如，您可以在Angular提供的<code class="fe nb nc nd ne b">ngOnDestroy</code>生命周期钩子中保存对订阅和取消订阅的引用。</li><li id="8c35" class="nf ng it lb b lc no lf np li nq lm nr lq ns lu nk nl nm nn bi translated">请不要用这种方法来代替减压器或效果。就个人而言，我认为<code class="fe nb nc nd ne b">ActionsSubject</code>更像是一个高级特性，对调试很有用。</li></ul></div><div class="ab cl lx ly hx lz" role="separator"><span class="ma bw bk mb mc md"/><span class="ma bw bk mb mc md"/><span class="ma bw bk mb mc"/></div><div class="im in io ip iq"><h1 id="37b0" class="me mf it bd mg mh mi mj mk ml mm mn mo jz mp ka mq kc mr kd ms kf mt kg mu mv bi translated">结论</h1><p id="6925" class="pw-post-body-paragraph kz la it lb b lc mw ju le lf mx jx lh li my lk ll lm mz lo lp lq na ls lt lu im bi translated">感谢阅读这篇文章。在较大的应用程序中，这种方法可以通过记录任何调度的动作来帮助我们理解动作何时以及如何被调度。幸运的是，NgRx让我们变得非常容易。不需要另一个软件包或浏览器扩展。</p><p id="3c56" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">您知道在这种情况下使调试更容易的其他方法吗？请在评论中告诉我。</p></div></div>    
</body>
</html>