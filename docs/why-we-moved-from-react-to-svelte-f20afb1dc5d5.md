# 为什么我们从反应到苗条

> 原文：<https://betterprogramming.pub/why-we-moved-from-react-to-svelte-f20afb1dc5d5>

## JavaScript 真的应该那么复杂吗？

![](img/ebd4f3ff9eedf550cd31c1a4061970a9.png)

Fabrizio Chiagano 在 [Unsplash](https://unsplash.com/s/photos/zen?utm_source=unsplash&utm_medium=referral&utm_content=creditCopyText) 上拍摄的照片

我觉得我老了，曾经如此轻微地想到“真的应该是*那么复杂吗？”赶时髦。简化创建动态前端的过程变得相当混乱。*

当你为一家大公司工作，并期望多年保持一个产品时，这是一个极好的解决方案。当一切都围绕一个共同认可的工作流程时，这是最好的。React 带来了极大的自由，让你可以随心所欲地工作。

我们是一个小团队，为大中型客户生产快速迭代的数字产品——通常是几个并行的客户。我们认识到，跟上“一时的时尚”会损害我们的生产力。React 生态系统不时地改变范例。项目的临时负载使得维护成为一种负担。我们有规律地让大脑回到过去发生的事情。

容器化让一切变得更加舒适，因为我们可以及时锚定开发环境。很大一部分 JavaScript 疲劳是不断地在不同的捆绑器和任务管理器之间来回移动——Grunt、Gulp、Webpack 1-2-3-4-5、Browsersync、Nodemon、blahhh！现在这一切都在 docker-compose 后面，它帮助我们晚上睡觉。我们的 CI/CD 渠道(几乎)确保我们在生产中不会做傻事。

但是，这并没有让我们更快乐。React 变得繁琐而*老套*。

我想我们都想找到卑微起点的刺激。一切都令人兴奋。“看，当我按下那个按钮时，那个东西就会移动。圣牛！”但是后来你慢慢意识到你包含了一个 250kb 的库，写了一个类，笨拙地处理了你的 DOM 的一个模糊表示——与你的字体、你的社会保险号和最近的天气预报捆绑在一起。什么鬼东西？复杂的应该是*吧？*

我向你保证，我们在继续前进之前尝试了所有很酷的东西，但就像在一段慢慢疏远的关系中，很难回到早期和天真的兴奋。每当有新的东西被考虑测试时，我们会立刻感受到一种巨大的压力，那就是记住过去没有使用那个范例的项目。默认情况下，远离我们“已知”领域的变化会导致技术债务。

加入新忍者对我们来说是一场斗争。当然，你可以在申请表中声明你正在寻找有经验的 React 开发人员，但是也有很多不同的方式。决定合适工具的神圣战争已经过时了——就像我一样。

我看着代码库，感觉我需要把近藤从他们身上去掉，找到与他们一起工作的乐趣。

于是我们开始了我们的旅程:Vue、Angular、Yew、Blazer，应有尽有。但是我们总是带着我们的修正回来，因为我们，开发者，是习惯的动物。

我们专注于为我们的客户创造优秀的开发者体验或直接价值。这些镜片减少了更换工具带的麻烦和时间。我们选定了我们定制的服务器端渲染 React 项目和我们喜欢了很长时间的极少数库。

# 然后苗条发生了

一天晚上，我正在 YouTube 上做我平常的冲浪，这时我看到了一个视频，视频中的 Rich Harris(T2 的创始人)解释了为什么 React 不是真正的反应。起初，它向我挑战。那么他的论点的重量和清晰度是不可避免的。他用苗条来解决他提出的问题的方式让我着迷。这一次，这是一个解决问题的工具，而不仅仅是试图做一些不同的事情。

值得注意的第一点是从在浏览器中完成大部分工作到在编译时完成大部分工作的转变。如果你像我一样，你困扰于你的灯塔网页速度的结果。在某种程度上，使用传统的方法，您将通过网络加载一个大规模的库，该库运行脚本和算法以使您的页面在数据包加载后显示。这样做会损害你的页面速度和搜索引擎优化，并且通常会给用户带来糟糕的连接速度慢的体验。当然，你可以认为树摇动和动态导入是一个解决方案。话说回来，为什么要把事情搞得这么复杂？

一旦你编译并构建了你的第一个苗条的应用程序，看看包的大小和内容，你就会明白为什么提前做这些工作是有意义的。

有人可能会说，在 Svelte 中添加组件的增量成本高于 React。然而，苗条从一个低得多的点开始，对于我们所做的工作类型，这是一个甜蜜的地方。拐点很难达到(理论上在 500-1000 个组件之间)，所以你必须考虑一些大规模的应用。

另一方面，包的大小并不重要。这都是关于 JavaScript *最初*如何努力工作来显示你的应用程序，并通过加载(或不加载)你的框架块来使其动态化。

# 它编译

Svelte 是一个框架，但它肯定首先是一个编译器。这种方法最大的好处是，无需对代码库做太多改动，就可以改善上下文。

编译器通过提供创建组件或管理组件状态的快捷方式来帮助您避免编写样板文件。写苗条的感觉就像回到了 Jquery 时代。事情很简单，直接与你的页面互动。

通用模式通过快速宏进行抽象，帮助您将状态或值绑定到组件。编写复杂的表单现在变得既有趣又容易。在用它真正构建生产应用的最初几个月，我们有很多“啊哈！”我们发现许多能让您生活更轻松的帮手的时刻。它们都是烤出来的。

在使用了一段时间后，我们的团队发现我们现在编写的代码少多了。我们的组件文件非常简洁，只包含它们必须处理的逻辑，只有很少的库导入。

一段时间后，我们注意到一件事，你可能需要一台优秀的机器来编译和运行你的苗条项目。随着项目的增长，我们的编译时间非常长(对于前端开发来说),每次更新的时间从 30 秒到 1 分钟不等。我们把旧的 MacBook Pros 换成了运行 Ubuntu 的 L15 ThinkPads，同样的项目的编译时间缩短到了 700-900 毫秒。选择 ThinkPads 还是 MacBooks 是另一篇文章的主题！

Svelte 还有一个更固执己见的层，叫做 Sapper。它将帮助您组织您的项目，并为您提供服务器端渲染以及免费的服务人员！你可以只使用 Svelte 来构建你的 SSR 平台，但是单独维护和 Sapper 一样质量的东西会变得很乏味。

如果你真的想要一个进步的网络应用，这可能是你最直接的选择。如果您喜欢为您的项目使用更明确的架构，这将有助于您，因为基本的 Svelte 只为您的架构提供了一些工具——最明显的是，没有默认路由器。

我们还不得不重新思考如何设计组件的样式。在 React 中，你可以用多种不同的方式来实现这一点，比如使用样式化的组件，或者只是使用老式的 CSS。在苗条中，你用你的组件来限定你的风格。编译器巧妙地重命名了你的类和 CSS 指针，这样你的指令就不会泄漏到其他元素中。

这感觉就像回到了直接在 HTML 中编写样式和脚本，但是我是以一种“好”的方式说的。你可以直接在你的组件中定位像`H1` s 这样的东西，而不用写一个占位符类，因为它只会强制这个组件。随着时间的推移，我们觉得管理和维护 CSS 变得更加容易。这也使得拥有一堆像 Bootstrap 这样的助手的库变得毫无用处。开销更少！

# 它让我们快乐

回想起来，我想你可以说这只是另一个花哨的框架，但我们找到了适合我们正在做的工作的工具。这可能不是每个人的最佳解决方案，但也许这篇文章会启发你尝试一下。

如果你对学习如何减肥感兴趣，最简单快捷的方法就是试试[互动 REPL 在线](https://svelte.dev/tutorial/basics)。

让我知道你有什么故事！