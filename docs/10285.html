<html>
<head>
<title>Build an Animated Custom Tab Bar in Your iOS Apps</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">在您的iOS应用程序中构建动画自定义标签栏</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/how-to-build-an-animated-custom-tab-bar-for-ios-application-5eb3a72e07a8?source=collection_archive---------6-----------------------#2021-12-21">https://betterprogramming.pub/how-to-build-an-animated-custom-tab-bar-for-ios-application-5eb3a72e07a8?source=collection_archive---------6-----------------------#2021-12-21</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="2c8a" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">创造漂亮的iOS设计</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/cc8a7826bbec35b157895615218e7af7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*KKazIMvg3LbrRx8MHwXnDw.jpeg"/></div></div></figure><p id="f2b3" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">每个用户界面设计师都喜欢漂亮的动画标签栏。另一方面，对于必须实现该设计的开发人员来说，这是一场噩梦。当然，使用苹果的原生标签栏组件会更容易，而且可以专注于更有趣的事情，比如业务逻辑实现。但是如果我们必须创建一个自定义标签栏呢？从哪里开始？</p><p id="cda1" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">我将在本文中尝试回答这些问题。我们将讨论创建自定义选项卡栏的最重要的方面。最终的效果将是一个动画的、易于扩展的、完全定制的标签栏，我希望它能在未来节省您的时间，并使实现设计者梦想的标签栏更快、更舒适。你准备好了吗？我们走吧！</p></div><div class="ab cl ln lo hu lp" role="separator"><span class="lq bw bk lr ls lt"/><span class="lq bw bk lr ls lt"/><span class="lq bw bk lr ls"/></div><div class="ij ik il im in"><p id="95d1" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">首先，给出的例子使用了一些依赖关系。多亏了他们，实现本文中描述的解决方案更快了。请随意用您的本机代码或其他库来替换它们。这些依赖关系是:</p><ul class=""><li id="41d1" class="lu lv iq kt b ku kv kx ky la lw le lx li ly lm lz ma mb mc bi translated"><a class="ae md" href="https://snapkit.io" rel="noopener ugc nofollow" target="_blank"> SnapKit </a>用于布局目的</li><li id="db05" class="lu lv iq kt b ku me kx mf la mg le mh li mi lm lz ma mb mc bi translated"><a class="ae md" href="https://github.com/RxSwiftCommunity/RxGesture" rel="noopener ugc nofollow" target="_blank"> RxGesture </a>用于处理选项卡栏项目上的点击</li><li id="e929" class="lu lv iq kt b ku me kx mf la mg le mh li mi lm lz ma mb mc bi translated"><a class="ae md" href="https://github.com/ReactiveX/RxSwift" rel="noopener ugc nofollow" target="_blank"> RxSwift </a>用于通知TabBarController项目已被点击</li></ul><p id="ec5c" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">现在我们可以进入实现部分了！</p><h1 id="fca0" class="mj mk iq bd ml mm mn mo mp mq mr ms mt jw mu jx mv jz mw ka mx kc my kd mz na bi translated">标签栏项目</h1><p id="0642" class="pw-post-body-paragraph kr ks iq kt b ku nb jr kw kx nc ju kz la nd lc ld le ne lg lh li nf lk ll lm ij bi translated">item组件由两个耦合在一起的不同部分组成:视图层和处理所有已定义项目类型的enum。为什么枚举类型而不是简单的结构？</p><p id="1bfb" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">这很简单，枚举在编程中是强大的类型，尤其是在Swift语言中。它们将熟悉的案例收集在一起，是案例可迭代的，可以扩展以扩展关于特定案例的信息，或者可以在其中使用计算属性。</p><p id="90dc" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">此外，枚举是与结构相同的值类型。很酷吧。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ng nh l"/></div></figure><p id="f068" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">如您所见，<code class="fe ni nj nk nl b">CustomTabItem</code>具有图标、选定图标、名称和相关联的<code class="fe ni nj nk nl b">viewController</code>的属性。这就是全部，每个值都是使用switch语句定义的，为每个枚举情况返回一个特定的值。</p><p id="1d99" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">第二部分是选项卡栏项目的视图层。它与<code class="fe ni nj nk nl b">CustomTabItem</code>直接耦合，因为一个条目是初始化期间传递给视图的两个参数之一。第二个是索引，对于每个视图都是唯一的，它将在以后用于改变标签栏的<code class="fe ni nj nk nl b">selectedIndex</code>。</p><p id="5f9d" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">而且，每个视图都有一个简单的过渡动画。项目的设计很简单，顶部有一个图标，下面有一个标题。根据项目是否被选中，标题可以变成图标下面的圆形线。</p><p id="a472" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">自动布局和配置视图属性并不复杂，所以我有意省略了这一部分。如果你想知道我是如何实现这一部分的，可以查看文章末尾提到的GitHub库。</p><p id="709a" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">由于我们的项目已经完成，我们可以移动到主视图—选项卡栏。</p><h1 id="e3e8" class="mj mk iq bd ml mm mn mo mp mq mr ms mt jw mu jx mv jz mw ka mx kc my kd mz na bi translated">标签栏实现</h1><p id="bcbc" class="pw-post-body-paragraph kr ks iq kt b ku nb jr kw kx nc ju kz la nd lc ld le ne lg lh li nf lk ll lm ij bi translated">让我们讨论一下负责收集所有标签栏条目并处理它们的选择的主要组件。自动布局很容易，因为它是作为<code class="fe ni nj nk nl b">UIStackView</code>组件的子类创建的。唯一要做的就是使用<code class="fe ni nj nk nl b">addArrangedSubview(_ view: UIView)</code>添加我们的项目。那是在<code class="fe ni nj nk nl b">setupHierarchy()</code>方法内部处理的。</p><p id="d231" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">在GitHub资源库的<code class="fe ni nj nk nl b"><strong class="kt ir">Extensions.swift</strong></code>文件中，您可以找到一些有用的扩展，比如在一行代码中向<code class="fe ni nj nk nl b">UIStackView</code>添加许多子视图的扩展。</p><p id="1fc1" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">此外，对于我们想要添加到标签栏的每个项目，我们必须设置<code class="fe ni nj nk nl b">translatesAutoresizingMaskIntoConstraints</code>到<code class="fe ni nj nk nl b">false</code>来防止为它们自动创建自动布局，并设置<code class="fe ni nj nk nl b">clipsToBounds</code>到<code class="fe ni nj nk nl b">true</code>来将我们的项目裁剪到标签栏的边界。我们将在其他属性配置中，在<code class="fe ni nj nk nl b">setupProperties()</code>方法中实现该部分。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ng nh l"/></div></figure><p id="b966" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">除了选项卡栏项目声明，我们还必须添加负责发出所选项目索引的可观察序列属性。</p><p id="d177" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">从上面可以看出，subject本身被声明为私有常量，在subject的值上有一个暴露的可观察值。</p><p id="7b98" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">因此，我们确保没有人能够从<code class="fe ni nj nk nl b">CustomTabBar</code>类之外搞乱这个主题发出的值。</p><p id="bdae" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">最后但同样重要的是，我们必须在我们的<code class="fe ni nj nk nl b">CustomTabBar</code>实现中添加两个方法。第一个是<code class="fe ni nj nk nl b">selectItem(index: Int)</code>，这里我们将处理负责更新当前所选项的整个逻辑。</p><p id="b174" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">首先，我们更新每个项目中的<code class="fe ni nj nk nl b">isSelected</code>属性，以反映最新的选择。</p><p id="5543" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">其次，我们使用上面描述的主题发出所选项的索引。这样，我们更新了— <code class="fe ni nj nk nl b">TabBarController</code>和选项卡栏项目中的选择。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ng nh l"/></div></figure><p id="0f18" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">我们必须实现的第二个方法是一个<code class="fe ni nj nk nl b">bind()</code>，负责处理每个项目的用户触摸。</p><p id="5888" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">实现使用的是<code class="fe ni nj nk nl b">RxGesture</code>，但是如果你愿意，你可以用你的反应式扩展来代替它。</p><p id="d07d" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated"><code class="fe ni nj nk nl b">RxGesture</code>提供了识别用户交互的方法<code class="fe ni nj nk nl b">.tapGesture()</code>,但是在绑定到那个动作之前，我们必须过滤用户手势，只过滤那些有<code class="fe ni nj nk nl b">recognized</code>状态的手势。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ng nh l"/></div></figure><p id="ca01" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">如您所见，<code class="fe ni nj nk nl b">selectItem(index: Int)</code>方法是在<code class="fe ni nj nk nl b">animateClick(completion: @escaping () -&gt; Void)</code>的闭包内调用的。这是一个<code class="fe ni nj nk nl b">UIView</code>的扩展，负责我们项目的缩放动画。</p><p id="0dfe" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">上面的代码示例展示了如何处理<code class="fe ni nj nk nl b">profileItem</code>的用户交互。但是，不要忘记以同样的方式处理其余的项目！</p><h1 id="75df" class="mj mk iq bd ml mm mn mo mp mq mr ms mt jw mu jx mv jz mw ka mx kc my kd mz na bi translated">将所有这些放在标签栏控制器中</h1><p id="323b" class="pw-post-body-paragraph kr ks iq kt b ku nb jr kw kx nc ju kz la nd lc ld le ne lg lh li nf lk ll lm ij bi translated">几乎所有的事情都做好了，现在我们要把所有的零件组装起来！<code class="fe ni nj nk nl b">CustomTabBarController</code>是一个完美的地方，但首先，我们需要一个简单的视图控制器来处理与标签栏项目相关的不同屏幕。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ng nh l"/></div></figure><p id="c0af" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">上面的例子故意省略了自动布局和属性配置，因为这是一个很容易添加的东西。如果你想用我的，可以查看文章末尾的GitHub库。每个视图控制器都用<code class="fe ni nj nk nl b">CustomTabItem</code>初始化，这样我们就可以在屏幕上显示项目的名称。</p><p id="4a1c" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">回到标签栏控制器，除了设置层次和布局，我们必须配置一些属性。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ng nh l"/></div></figure><p id="a3da" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">首先，隐藏名为— <code class="fe ni nj nk nl b">tabBar</code>的类属性下的本地选项卡栏。</p><p id="7205" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">其次，我们将设置<code class="fe ni nj nk nl b">translatesAutoresizingMaskIntoConstraints</code>为<code class="fe ni nj nk nl b">false</code>，并为我们的<code class="fe ni nj nk nl b">customTabBar</code>组件添加一些阴影。</p><p id="1403" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">最后，我们必须将选项卡栏控制器的<code class="fe ni nj nk nl b">selectedIndex</code>属性设置为初始值(最常见的情况是将该值设置为0 ),并设置将由选项卡栏控制器处理的视图控制器。由于我们的选项卡栏项目的实现有一个关联视图控制器的属性，它是<code class="fe ni nj nk nl b">CaseIterable</code>,我们可以很容易地将枚举的所有情况映射到分配给每个情况的视图控制器值。映射后，使用以下方式设置它们:</p><pre class="kg kh ki kj gt nm nl nn no aw np bi"><span id="8f0c" class="nq mk iq nl b gy nr ns l nt nu">setViewControllers(_ controllers: [UIViewController], animated: true)</span></pre><p id="49b5" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">现在只剩下一步了，我们必须处理当前<code class="fe ni nj nk nl b">selectedIndex</code>的变更。</p><p id="4045" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">如果你以前关注过，你会立即知道我们将如何实现这一点。当然，通过从<code class="fe ni nj nk nl b">CustomTabBar</code>类订阅先前创建的可观察序列。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ng nh l"/></div></figure><p id="83cf" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">因为我们不希望在这里出现任何错误，所以我们可以使用bind方法来代替订阅。对于每个发出的索引值，我们使用<code class="fe ni nj nk nl b">selectTabWith(index: Int)</code>方法选择一个特定的选项卡，该方法将作为参数传递的索引分配给选项卡栏控制器的<code class="fe ni nj nk nl b">selectedIndex</code>属性。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi nv"><img src="../Images/16ce0d8a43126315569f644e5bdfddf1.png" data-original-src="https://miro.medium.com/v2/resize:fit:390/1*bq_8L1WzMS5cGBBS27T9LQ.gif"/></div><p class="nw nx gj gh gi ny nz bd b be z dk translated">自定义选项卡栏实现的最终结果</p></figure><p id="ad3e" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">我们到了。欣赏我们新的美丽的自定义标签栏！</p></div><div class="ab cl ln lo hu lp" role="separator"><span class="lq bw bk lr ls lt"/><span class="lq bw bk lr ls lt"/><span class="lq bw bk lr ls"/></div><div class="ij ik il im in"><p id="d9aa" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">如果你还在阅读，这意味着现在你知道如何创建你的自定义标签栏！恭喜你。非常感谢你的时间，希望你喜欢。</p><p id="0675" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">欢迎在评论区提问。此外，如果你想检查整个实现，你可以在我的GitHub页面找到库<a class="ae md" href="https://github.com/jcholuj/CustomTabBarExample" rel="noopener ugc nofollow" target="_blank">这里【T3:)</a></p></div></div>    
</body>
</html>