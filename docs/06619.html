<html>
<head>
<title>What Is a BehaviorSubject in RxJS?</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">RxJS中的行为主体是什么？</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/what-is-a-behaviorsubject-in-rxjs-f580e934a5b2?source=collection_archive---------8-----------------------#2020-10-19">https://betterprogramming.pub/what-is-a-behaviorsubject-in-rxjs-f580e934a5b2?source=collection_archive---------8-----------------------#2020-10-19</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="e2a1" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">行为主体基础知识以及如何在角度</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/7d3b57eaa0537f37cc1fbbca1f896d25.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*Raja5Qnt3M-dJJXN.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">图片来自<a class="ae ky" href="https://rxjs-dev.firebaseapp.com/" rel="noopener ugc nofollow" target="_blank"> RxJS </a>。</p></figure><p id="c082" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在这篇文章中，我们将讨论你需要知道的关于<code class="fe lv lw lx ly b">BehaviorSubject</code>的一切。我们将从基础开始。在文章的后面，我们将讨论如何在Angular中使用它。在文章的最后，你不仅会理解它，而且你还会掌握这门学科。</p><p id="0e87" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">所有这些只需要你几分钟的时间。</p></div><div class="ab cl lz ma hx mb" role="separator"><span class="mc bw bk md me mf"/><span class="mc bw bk md me mf"/><span class="mc bw bk md me"/></div><div class="im in io ip iq"><h1 id="1d70" class="mg mh it bd mi mj mk ml mm mn mo mp mq jz mr ka ms kc mt kd mu kf mv kg mw mx bi translated">基础知识</h1><p id="e500" class="pw-post-body-paragraph kz la it lb b lc my ju le lf mz jx lh li na lk ll lm nb lo lp lq nc ls lt lu im bi translated">让我们从文档中的定义开始:</p><blockquote class="nd"><p id="f550" class="ne nf it bd ng nh ni nj nk nl nm lu dk translated">“[behavior subject]需要一个初始值，并将当前值发送给新的订阅者。”— <a class="ae ky" href="https://www.learnrxjs.io/learn-rxjs/subjects/behaviorsubject" rel="noopener ugc nofollow" target="_blank">学习RxJs </a></p></blockquote><p id="2367" class="pw-post-body-paragraph kz la it lb b lc nn ju le lf no jx lh li np lk ll lm nq lo lp lq nr ls lt lu im bi translated">所以，<code class="fe lv lw lx ly b">BehaviorSubject</code>是一个我们可以订阅的主题。像任何其他主题一样，它将向订阅该主题的任何人广播添加到该主题的新值。</p><p id="a2fc" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">因为当前值总是发送给新的/迟交的订阅者，所以您有机会在任何人订阅之前提供一个初始值。这一部分在我们后面的角度部分讨论时会变得更清楚。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ns"><img src="../Images/970cb225254ba2008e491118f04db705.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*K6e-2QIn57IMBHMOzAIqEw.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">自己带着RxJS<a class="ae ky" href="https://rxjs-playground.github.io/" rel="noopener ugc nofollow" target="_blank">在这个操场上玩</a>。</p></figure><p id="be45" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在我的第一个例子中，我们来玩一个行为主体。</p><p id="4d16" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们创建一个。如果我们直接订阅它，它将打印当前值(在本例中，<code class="fe lv lw lx ly b">3</code>)。</p><p id="d124" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果我们调用我们主题的下一个函数，第一个订阅者将会注意到并打印出下一个值(<code class="fe lv lw lx ly b">4</code>)。</p><p id="edaf" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">后期订阅者在调用下一个函数后订阅，并且不知道之前的值。它看到的是行为主体的当前价值。很酷，不是吗？</p><p id="422a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><em class="nt">注意:如果你想让后来的订阅者知道之前发出的值，使用</em> <code class="fe lv lw lx ly b"><em class="nt">ReplaySubject</em></code> <em class="nt">。</em></p><p id="5444" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">请继续玩它。我一直推荐的一个典型练习是玩普通的<code class="fe lv lw lx ly b">Subject</code>、<code class="fe lv lw lx ly b">BehaviorSubject</code>和<code class="fe lv lw lx ly b">ReplaySubject</code>，因为这些是最常用的。</p></div><div class="ab cl lz ma hx mb" role="separator"><span class="mc bw bk md me mf"/><span class="mc bw bk md me mf"/><span class="mc bw bk md me"/></div><div class="im in io ip iq"><h1 id="e211" class="mg mh it bd mi mj mk ml mm mn mo mp mq jz mr ka ms kc mt kd mu kf mv kg mw mx bi translated">用例:角度</h1><p id="885e" class="pw-post-body-paragraph kz la it lb b lc my ju le lf mz jx lh li na lk ll lm nb lo lp lq nc ls lt lu im bi translated">在Angular中使用<code class="fe lv lw lx ly b">BehaviorSubject</code>非常方便，因为它是一种特殊的<code class="fe lv lw lx ly b">Observable</code>。有时，我们喜欢对输入变量做一些事情(例如，检索文章的后端调用)。或者我们想在不改变输入变量本身的情况下对输入变量执行一些操作。通过使用RxJS，我们建立了一个非常有效的——当然，这取决于你如何实现它——数据流。</p><p id="de09" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们不想在输入属性的所有操作完成之前呈现HTML模板。为此，我们可以使用异步管道订阅这些结果。因为这个异步管道是后期订阅，所以我们也想访问初始值。这就是<code class="fe lv lw lx ly b">BehaviorSubject</code>发挥作用的地方。</p><p id="3bc9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我给你看基本的。</p><p id="3d19" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">因为输入属性的值是在<code class="fe lv lw lx ly b">OnInit</code>中初始化的，而不是在构造函数中，所以这是——大多数时候——创建行为主体的唯一正确的地方。</p><p id="4cb3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><em class="nt">注意:过去，我也曾在</em> <code class="fe lv lw lx ly b"><em class="nt">ngOnInit</em></code> <em class="nt">之外创建过</em> <code class="fe lv lw lx ly b"><em class="nt">BehaviorSubject</em></code> <em class="nt">，方法是传递一个</em> <code class="fe lv lw lx ly b"><em class="nt">null</em></code> <em class="nt">，然后过滤掉那个</em> <code class="fe lv lw lx ly b"><em class="nt">null</em></code> <em class="nt">。但事实证明，这只会让事情变得更复杂。</em></p><pre class="kj kk kl km gt nu ly nv nw aw nx bi"><span id="de18" class="ny mh it ly b gy nz oa l ob oc">ngOnInit(): void {</span><span id="eb87" class="ny mh it ly b gy od oa l ob oc">    mySubject$<!-- --> = new BehaviorSubject(myInputVariable);<br/><br/>}</span></pre><p id="e249" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">稍后在<code class="fe lv lw lx ly b">ngOnChanges</code>中，我们可以对主题调用<code class="fe lv lw lx ly b">next</code>来提供一个新的值。需要注意的是，只有在发生变化时才发出值。</p><p id="85ec" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><em class="nt">注意:只有当该属性发生变化时，当它不是第一次变化时，以及当该值不同于先前的输入值时(不仅仅是参考变化)，才会发生变化。</em></p><pre class="kj kk kl km gt nu ly nv nw aw nx bi"><span id="a7a8" class="ny mh it ly b gy nz oa l ob oc">ngOnChanges(changes: SimpleChanges): void {<br/>  if (<em class="nt">hasChangesForProperty</em>(changes, 'myInputVariable')) {<br/>    this.mySubject$.next(this.myInputVariable);<br/>  }<br/>}</span></pre><p id="8910" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">最后一部分是异步管道。这是我们后期订阅主题的位置。因为我们使用管道在模板内部订阅，所以我们不需要自己取消订阅。太棒了。</p><pre class="kj kk kl km gt nu ly nv nw aw nx bi"><span id="0b10" class="ny mh it ly b gy nz oa l ob oc">&lt;ng-container *ngIf="mySubject$ | async as <strong class="ly iu"><em class="nt">mySubject</em></strong>"&gt;</span><span id="1dd6" class="ny mh it ly b gy od oa l ob oc">  &lt;!-- something you like here --&gt;</span><span id="73fb" class="ny mh it ly b gy od oa l ob oc">&lt;/ng-container&gt;</span></pre><p id="abe0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">仔细想想，我们可以在模板中直接使用输入变量。这确实会有同样的结果。但是请记住，这第一个例子只是让你开始！</p><p id="8f15" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">因为我喜欢让事情变得简单，这是一个最简单的关于<code class="fe lv lw lx ly b">BehaviorSubject</code>的有角度的例子。为了真正理解它的威力，我们需要深入更高级的例子，所以坚持住。</p><p id="7b2c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我给你看三个。</p><h2 id="99c4" class="ny mh it bd mi oe of dn mm og oh dp mq li oi oj ms lm ok ol mu lq om on mw oo bi translated"><strong class="ak">例1 </strong></h2><p id="4a4c" class="pw-post-body-paragraph kz la it lb b lc my ju le lf mz jx lh li na lk ll lm nb lo lp lq nc ls lt lu im bi translated">您可以对值执行操作。请注意，在这个简单的例子中，您也可以使用纯管道，这在效率方面是相同的。通过使用<code class="fe lv lw lx ly b">tap</code>也可以很容易地添加像日志这样的副作用。一旦你有了这个想法，建立一个数据流就变得非常简单。</p><pre class="kj kk kl km gt nu ly nv nw aw nx bi"><span id="c76d" class="ny mh it ly b gy nz oa l ob oc">this.newSubject$ = this.mySubject$.pipe(<br/>    tap(value =&gt; console.log(value)),<br/>    map(value =&gt; mapToDifferentRepresentation(value))<br/>);</span></pre><h2 id="19cc" class="ny mh it bd mi oe of dn mm og oh dp mq li oi oj ms lm ok ol mu lq om on mw oo bi translated"><strong class="ak">例二</strong></h2><p id="566a" class="pw-post-body-paragraph kz la it lb b lc my ju le lf mz jx lh li na lk ll lm nb lo lp lq nc ls lt lu im bi translated">你可以把两个可观测量结合起来，当其中任何一个发生变化时，进行一些运算。这已经表明，这种工作方式变得非常强大，非常快。RxJs有很多不同的函数，所以一定要检查一下<a class="ae ky" href="https://www.learnrxjs.io/learn-rxjs/operators/combination/combinelatest" rel="noopener ugc nofollow" target="_blank">文档</a>！</p><pre class="kj kk kl km gt nu ly nv nw aw nx bi"><span id="719e" class="ny mh it ly b gy nz oa l ob oc">this.subject$ = combineLatest(<br/>   [this.mySubject1$, this.mySubject2$]<br/>).pipe(<br/>    map(([value1, value2]) =&gt; value2 - value1)<br/>);</span></pre><h2 id="6dca" class="ny mh it bd mi oe of dn mm og oh dp mq li oi oj ms lm ok ol mu lq om on mw oo bi translated"><strong class="ak">例3 </strong></h2><p id="5a2b" class="pw-post-body-paragraph kz la it lb b lc my ju le lf mz jx lh li na lk ll lm nb lo lp lq nc ls lt lu im bi translated">您可以使用<code class="fe lv lw lx ly b">switchMap</code>函数将一个可观察对象映射到一个不同的可观察对象。在这个具体的例子中，我们通过使用文章服务的UUID从文章服务中检索文章。让那件事过去一段时间…</p><p id="bbf5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">你明白了吗？</p><p id="77bd" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">注意，我们只检索我们真正需要的文章。我们只在值改变的时候做一个运算。这是令人难以置信的效率。文章格式不对吗？好吧，继续使用<code class="fe lv lw lx ly b">map</code>功能来改变它。</p><blockquote class="op oq or"><p id="ebb5" class="kz la nt lb b lc ld ju le lf lg jx lh os lj lk ll ot ln lo lp ou lr ls lt lu im bi translated">开关映射是最常用的一种，但也有其他映射操作符来处理内部观察。</p></blockquote><pre class="kj kk kl km gt nu ly nv nw aw nx bi"><span id="b121" class="ny mh it ly b gy nz oa l ob oc">this.article$ = this.uuid$.pipe(<br/>    switchMap(uuid =&gt; this.articleService.getArticle(uuid))<br/>);</span></pre></div><div class="ab cl lz ma hx mb" role="separator"><span class="mc bw bk md me mf"/><span class="mc bw bk md me mf"/><span class="mc bw bk md me"/></div><div class="im in io ip iq"><h1 id="5c47" class="mg mh it bd mi mj mk ml mm mn mo mp mq jz mr ka ms kc mt kd mu kf mv kg mw mx bi translated">结论</h1><p id="5dd7" class="pw-post-body-paragraph kz la it lb b lc my ju le lf mz jx lh li na lk ll lm nb lo lp lq nc ls lt lu im bi translated">RxJS允许我们处理流中的数据。这是一种非常方便的工作方式。这使得异步代码更容易理解。如果使用正确，<code class="fe lv lw lx ly b">BehaviorSubject</code>是一个简单且非常强大的概念。您可以在Angular、Vue、React和其他流行的框架中使用它。因此，将它作为工具之一对于任何前端开发人员来说都是有益的。</p><p id="8876" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如本文所示，它确实与Angular中的事件周期结合得很好。如果你喜欢这篇文章或者对这个主题有任何疑问(双关语)，请在下面留下评论。感谢阅读！</p></div></div>    
</body>
</html>