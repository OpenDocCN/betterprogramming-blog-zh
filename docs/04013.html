<html>
<head>
<title>How to Build Async Infinite Scroll in React.js</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何在React.js中构建异步无限滚动</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/async-infinite-scroll-in-react-js-71a6f1210c75?source=collection_archive---------13-----------------------#2020-03-18">https://betterprogramming.pub/async-infinite-scroll-in-react-js-71a6f1210c75?source=collection_archive---------13-----------------------#2020-03-18</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="dc91" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">*滚动，获取，滚动，获取，滚动…*</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/14cb9812e8e58b68bb75208d75d1eac8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*SGWofvj3QwPkWw3QBgupLg.jpeg"/></div></div></figure><p id="2759" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">假设您正在设计一个社交媒体提要，并且希望在其中实现一个无限滚动特性。有两种方法可以做这件事。</p><ol class=""><li id="b385" class="lq lr it kw b kx ky la lb ld ls lh lt ll lu lp lv lw lx ly bi translated">您调用一个API来检索属于特定提要的所有帖子。在获得所有这些帖子之后，您在前端解析它们并显示给用户。</li><li id="bc6b" class="lq lr it kw b kx lz la ma ld mb lh mc ll md lp lv lw lx ly bi translated">每当用户第一次进入页面并滚动到底部时，您就为特定数量的帖子发出一个API调用。</li></ol><p id="d84c" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">这正是我在熨斗学校创建顶点工程时遇到的十字路口。虽然第一条路线是两条路线中比较容易的一条，但我心想，“如果我的应用程序有数百万用户，他们之间有数十亿条帖子，那么加载和存储这么大规模的提要会破坏我的应用程序！”那时我决定走第二条路。我是怎么做到的？好吧，继续读下去，让我们找到答案！</p><h2 id="5275" class="me mf it bd mg mh mi dn mj mk ml dp mm ld mn mo mp lh mq mr ms ll mt mu mv mw bi translated"><strong class="ak">免责声明:</strong></h2><ul class=""><li id="1857" class="lq lr it kw b kx mx la my ld mz lh na ll nb lp nc lw lx ly bi translated">这个应用程序使用React前端和Ruby on Rails后端。如果你不熟悉Rails，尽管你想用你的专业语言达到同样的效果，我99%确定这里的逻辑是可以移植的。</li><li id="927a" class="lq lr it kw b kx lz la ma ld mb lh mc ll md lp nc lw lx ly bi translated">这个应用程序使用了<code class="fe nd ne nf ng b">fetch</code>关键字。这就是允许我对我的Rails后端进行API调用的方式。如果你不熟悉如何获取发生，然后检查<a class="ae nh" href="https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API/Using_Fetch" rel="noopener ugc nofollow" target="_blank">一些文件在这里</a>。</li></ul><h2 id="a210" class="me mf it bd mg mh mi dn mj mk ml dp mm ld mn mo mp lh mq mr ms ll mt mu mv mw bi translated">我们开始吧！</h2><p id="4aab" class="pw-post-body-paragraph ku kv it kw b kx mx ju kz la my jx lc ld ni lf lg lh nj lj lk ll nk ln lo lp im bi translated">下面是我的应用程序的一个新闻提要在实现后的样子:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi nl"><img src="../Images/9b02446fcbb69f360b53d7c845aef946.png" data-original-src="https://miro.medium.com/v2/resize:fit:1200/1*JrRJfhgNzr5FXTuQDN3A8g.gif"/></div></figure><p id="2b60" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">这是正在发生的逻辑流程:</p><ol class=""><li id="221b" class="lq lr it kw b kx ky la lb ld ls lh lt ll lu lp lv lw lx ly bi translated">有一个存储在本地状态中的计数器，其默认值设置为1。</li><li id="a8f8" class="lq lr it kw b kx lz la ma ld mb lh mc ll md lp lv lw lx ly bi translated">当组件挂载时，默认的计数器值被发送到后端以检索第一组帖子。</li><li id="f2da" class="lq lr it kw b kx lz la ma ld mb lh mc ll md lp lv lw lx ly bi translated">当用户滚动到页面底部时，会触发一个事件监听器。一旦被触发，我的状态中的计数器递增，然后用新的递增值完成另一个获取请求。有了新的增量值，我可以获得下一组帖子。</li><li id="daa1" class="lq lr it kw b kx lz la ma ld mb lh mc ll md lp lv lw lx ly bi translated">加载下一组立柱。用户滚动到底部，计数器递增，获取发生，下一组帖子被检索和加载。</li><li id="2637" class="lq lr it kw b kx lz la ma ld mb lh mc ll md lp lv lw lx ly bi translated">这可以一直进行到给定提要中不再有帖子为止。</li></ol><p id="b945" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">首先，我们要建立我们的州。我们希望有一个计数器变量，一个布尔值，它将指示是否正在进行提取(如果您希望有一个加载动画/指示器，这很有帮助)，另一个布尔值，它表示我们是否已经到达提要的末尾(如果您希望在用户到达提要的末尾时告诉他们，这很有帮助)。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi nm"><img src="../Images/a6eed79761cf1a455b4690201f5b5245.png" data-original-src="https://miro.medium.com/v2/resize:fit:712/format:webp/1*F4niVaUhXsg7cU5D3okyMQ.png"/></div></figure><p id="dc90" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">以下是我的componentDidMount函数:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi nl"><img src="../Images/b201163aa3c35ef077ba8227c456d79f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1200/format:webp/1*Rs8sKEaAh1FO2DpCuqpcUQ.png"/></div></figure><p id="6f30" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">对于这个博客来说，重要的是第二个被调用的函数。让我们看看fetch函数是如何定义的。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nn"><img src="../Images/19b9e07f2a29051ad431388d131454fa.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*psJY2wsT5k43M12aoIt8TQ.png"/></div></div></figure><p id="21ea" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">现在，这里发生了很多事情，让我们来分解一下:</p><ol class=""><li id="07f6" class="lq lr it kw b kx ky la lb ld ls lh lt ll lu lp lv lw lx ly bi translated">在第28行，我声明了一个名为<code class="fe nd ne nf ng b">slug</code>的变量。这是正在访问的提要的名称。</li><li id="9acb" class="lq lr it kw b kx lz la ma ld mb lh mc ll md lp lv lw lx ly bi translated">在第29行，我将这个slug以及在我的状态中定义的计数器作为参数传递给我从中获取数据的URL。(我将在本文的后面介绍如何为此设置端点和控制器配置)。</li><li id="0b4b" class="lq lr it kw b kx lz la ma ld mb lh mc ll md lp lv lw lx ly bi translated">从第32行开始，重要的是如果我得到一个有效的响应(一个post数组)，那么loading变量被设置为false，我将检索到的post发送到Redux中的我的state以进行显示(this.props.getPostsForTopic)。</li><li id="9d66" class="lq lr it kw b kx lz la ma ld mb lh mc ll md lp lv lw lx ly bi translated">如果没有有效的响应，那么通过将endOfPosts的state设置为true来指示提要的结束。</li></ol><p id="5249" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">现在，在我深入到事件监听器，描述它是如何工作的，以及实现加载指示器之前，让我们快速地回到后端。</p><h2 id="5503" class="me mf it bd mg mh mi dn mj mk ml dp mm ld mn mo mp lh mq mr ms ll mt mu mv mw bi translated">后端</h2><p id="5869" class="pw-post-body-paragraph ku kv it kw b kx mx ju kz la my jx lc ld ni lf lg lh nj lj lk ll nk ln lo lp im bi translated">在我的后端，我有一个如下设置的路由:</p><p id="f2bd" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated"><code class="fe nd ne nf ng b">get 'posts/:slug/:page', to: 'posts#infinite_scroll'</code></p><p id="3047" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">这允许我们将不同的参数传入获取URL。一旦有人访问这个端点，那么所需的逻辑就在我的Posts控制器的infinite_scroll函数中处理。以下是所述函数，以及我使用的一个助手函数:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi no"><img src="../Images/68aeba7318aad8b147f023137db7a413.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*80ht2gMLsfBFB3eexy6Avw.png"/></div></div></figure><p id="7539" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">这里发生了很多事情，但这本质上是奇迹发生的地方！让我们再一次分解一下:</p><ol class=""><li id="2277" class="lq lr it kw b kx ky la lb ld ls lh lt ll lu lp lv lw lx ly bi translated">在无限滚动函数中，我首先找到使用我们之前传递的slug参数引用的主题。</li><li id="2b85" class="lq lr it kw b kx lz la ma ld mb lh mc ll md lp lv lw lx ly bi translated">一旦我有了我需要的主题，我就用主题的参数调用我定义的名为‘posts _ by _ topic’的函数。</li><li id="0cd5" class="lq lr it kw b kx lz la ma ld mb lh mc ll md lp lv lw lx ly bi translated">当我们查看截图下半部分定义的函数时，它实际上是在返回一个属于主题的帖子的反向数组。(注意:在Post类上调用的方法‘consistent _ order’是我在Post的模型文件中定义的一个类方法。它的目的是确保我加载的帖子的顺序与最初创建时一致。)</li><li id="dd4a" class="lq lr it kw b kx lz la ma ld mb lh mc ll md lp lv lw lx ly bi translated">回到infinite_scroll函数——一旦我们得到函数的返回值，我们就对它调用slice方法。如果你不熟悉切片法，<a class="ae nh" href="https://dev.to/jeremy/ruby-method-spotlight-slice-1f3j" rel="noopener ugc nofollow" target="_blank">这里有一些文档！</a></li><li id="be88" class="lq lr it kw b kx lz la ma ld mb lh mc ll md lp lv lw lx ly bi translated">在第一次加载时(组件已安装)，这个slice方法的第一个参数为0，第二个参数为8。如果你对第一个参数不清楚，我正在做8倍的页面计数，在我的获取中传递下去。在我第一次加载时，页数是1。八乘以一等于八。然后我减去8，得到0。这样，我可以从索引0开始，从中获得8个post元素(直到第7个索引)。</li></ol><p id="1b49" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">在前端，当页面滚动到底部时，计数器增加到2，并发生另一次提取。在这个切片方法中，第一个参数变成8，因为8乘以2等于16。16减8得8。现在，我们从第8个索引(直到第15个索引)中获取所有的posts 8元素。</p><p id="7071" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">用户再次滚动到底部，并将计数器增加到3。Fetch发生了，我们现在用参数16和8再次切片。16因为8乘以3等于24。24减8等于16。现在我们从第16个索引中得到所有的第8个元素。</p><p id="c6c6" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">如果文章数组中剩下的文章少于8篇，那么slice方法将返回剩余的文章。如果我们到达一个超过数组长度的初始参数，slice将返回nil——这是我们上面的fetch函数中条件语句的关键。</p><p id="fc5d" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">一旦我们得到了我们的文章集，我们将它们保存到一个变量中，然后将这个变量呈现给我们的前端。</p><p id="b9b5" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">现在，让我们设置我们的事件监听器！</p><h2 id="2d9d" class="me mf it bd mg mh mi dn mj mk ml dp mm ld mn mo mp lh mq mr ms ll mt mu mv mw bi translated">回到前面去！</h2><p id="efa7" class="pw-post-body-paragraph ku kv it kw b kx mx ju kz la my jx lc ld ni lf lg lh nj lj lk ll nk ln lo lp im bi translated">在我的前端，我下载了npm包“反应-底部-滚动-监听器”。您可以通过点击此处的<a class="ae nh" href="https://www.npmjs.com/package/react-bottom-scroll-listener" rel="noopener ugc nofollow" target="_blank">找到文档。</a>这个包提供了一个组件，它有一个名为‘on bottom’的属性，该属性接受一个回调函数的参数。这里，它正在我的应用程序中使用。我将该组件的所有JSX都包装在BottomScrollListener组件中。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi np"><img src="../Images/a437cb0dcfec87c895c33ea17d253dcc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*q3ipI1dhQabVS-7Hgv0pBg.png"/></div></div></figure><p id="17ac" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">在这里，您还可以看到当加载帖子时(当fetch发生时)，或者当没有更多帖子要加载时，用户所看到的逻辑。我在第70行和第71行使用了三元运算符(<a class="ae nh" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Conditional_Operator" rel="noopener ugc nofollow" target="_blank">关于三元运算符的文档！</a>)。</p><p id="ccb7" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">虽然拥有这些指标并不是这篇博文的主要焦点，但是如果你一直遵循我的代码，我相信你也可以在你的代码中实现它。</p><p id="fc07" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">另外，请注意，我在我的JSX中调用了一个名为renderPosts的函数。所有这些都是从我的Redux状态开始遍历一个posts数组，并为每个元素创建组件。</p><p id="db98" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">现在，让我们看看回调函数的逻辑:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nq"><img src="../Images/dd12d0089bd68cfa09fad0100b6fc15b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Ib9zuVzGd39Zq1d-5e-_mA.png"/></div></div></figure><p id="1692" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">在这个函数中，有一个检查来查看我们的帖子是否结束。</p><ul class=""><li id="ff58" class="lq lr it kw b kx ky la lb ld ls lh lt ll lu lp nc lw lx ly bi translated">如果我们还没有到达帖子的末尾，那么我们就增加状态中的页面计数器，将状态中的loading变量设置为true，然后运行函数，再次获取新的计数器值。当fetch返回一个有效的posts数组时，我们将loading设置为false，并将数组发送到Redux状态进行解析。</li><li id="bd7c" class="lq lr it kw b kx lz la ma ld mb lh mc ll md lp nc lw lx ly bi translated">如果我们到达了页面的末尾，没有更多的文章要显示(endOfPosts === true)，那么我们什么也不做。(记住！只有我们的fetch函数有能力将我们状态中的endOfPost变量更改为true。如果我们不再从后端获得一组帖子，它就会变成真的)。</li></ul><p id="2bec" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">所以你有它！这是我对异步无限滚动的尝试。如果你有任何问题，反馈，或者如果你觉得你可以使这更有效，随时联系。我希望您的React应用程序在实现这一点后内存效率会高得多！</p></div><div class="ab cl nr ns hx nt" role="separator"><span class="nu bw bk nv nw nx"/><span class="nu bw bk nv nw nx"/><span class="nu bw bk nv nw"/></div><div class="im in io ip iq"><h1 id="3ee2" class="ny mf it bd mg nz oa ob mj oc od oe mm jz of ka mp kc og kd ms kf oh kg mv oi bi translated">资源:</h1><div class="oj ok gp gr ol om"><a href="https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API/Using_Fetch" rel="noopener  ugc nofollow" target="_blank"><div class="on ab fo"><div class="oo ab op cl cj oq"><h2 class="bd iu gy z fp or fr fs os fu fw is bi translated">使用获取</h2><div class="ot l"><h3 class="bd b gy z fp or fr fs os fu fw dk translated">这种功能以前是使用XMLHttpRequest实现的。Fetch提供了一个更好的选择，可以…</h3></div><div class="ou l"><p class="bd b dl z fp or fr fs os fu fw dk translated">developer.mozilla.org</p></div></div><div class="ov l"><div class="ow l ox oy oz ov pa ks om"/></div></div></a></div><div class="oj ok gp gr ol om"><a href="https://www.npmjs.com/package/react-bottom-scroll-listener" rel="noopener  ugc nofollow" target="_blank"><div class="on ab fo"><div class="oo ab op cl cj oq"><h2 class="bd iu gy z fp or fr fs os fu fw is bi translated">反应-底部-滚动-监听器</h2><div class="ot l"><h3 class="bd b gy z fp or fr fs os fu fw dk translated">一个简单的React钩子和React组件，当你滚动到底部时，它可以让你监听。</h3></div><div class="ou l"><p class="bd b dl z fp or fr fs os fu fw dk translated">www.npmjs.com</p></div></div><div class="ov l"><div class="pb l ox oy oz ov pa ks om"/></div></div></a></div><div class="oj ok gp gr ol om"><a href="https://dev.to/jeremy/ruby-method-spotlight-slice-1f3j" rel="noopener  ugc nofollow" target="_blank"><div class="on ab fo"><div class="oo ab op cl cj oq"><h2 class="bd iu gy z fp or fr fs os fu fw is bi translated">Ruby方法聚焦:切片</h2><div class="ot l"><h3 class="bd b gy z fp or fr fs os fu fw dk translated">在我们开始之前，先简单说明一下:这篇文章假设你对Ruby数据结构有基本的了解，因为我真的不能…</h3></div><div class="ou l"><p class="bd b dl z fp or fr fs os fu fw dk translated">开发到</p></div></div><div class="ov l"><div class="pc l ox oy oz ov pa ks om"/></div></div></a></div><div class="oj ok gp gr ol om"><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Conditional_Operator" rel="noopener  ugc nofollow" target="_blank"><div class="on ab fo"><div class="oo ab op cl cj oq"><h2 class="bd iu gy z fp or fr fs os fu fw is bi translated">条件(三元)运算符</h2><div class="ot l"><h3 class="bd b gy z fp or fr fs os fu fw dk translated">条件(三元)操作符是唯一接受三个操作数的JavaScript操作符:一个条件后跟一个…</h3></div><div class="ou l"><p class="bd b dl z fp or fr fs os fu fw dk translated">developer.mozilla.org</p></div></div><div class="ov l"><div class="pd l ox oy oz ov pa ks om"/></div></div></a></div></div></div>    
</body>
</html>