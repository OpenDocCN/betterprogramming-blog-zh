<html>
<head>
<title>Building a React Components Library</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">构建React组件库</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/lets-build-react-components-library-part-3-b2e7aec478a2?source=collection_archive---------3-----------------------#2019-09-02">https://betterprogramming.pub/lets-build-react-components-library-part-3-b2e7aec478a2?source=collection_archive---------3-----------------------#2019-09-02</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="52cf" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">第3部分—将库捆绑并发布到NPM</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/2bceb307e001056bfecb1cc3fbebf1f7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*bmaWfveszbEa8yJBxuiBjg.jpeg"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">NPM和累计</p></figure><p id="84c4" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">在前面的部分中，我们<a class="ae lu" href="https://medium.com/better-programming/building-a-react-components-library-f5a390d5973d" rel="noopener">用组件</a>构建了库并且<a class="ae lu" href="https://medium.com/better-programming/building-a-react-components-library-6a05c2bca538" rel="noopener">测试了</a>它们。现在，我们已经准备好发布这个库，让公众可以使用它。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="24e3" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">图书馆的入口点</h1><p id="68e6" class="pw-post-body-paragraph ky kz it la b lb mu ju ld le mv jx lg lh mw lj lk ll mx ln lo lp my lr ls lt im bi translated">为了让我们的库工作，我们需要做的第一件事是配置其他项目应该如何使用和访问它。</p><p id="7ae6" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">为此，我们需要在<code class="fe mz na nb nc b">package.json</code>文件中指定<code class="fe mz na nb nc b">main</code>字段。这是程序的主要入口点。这指向我们将生成的捆绑文件，而不是源代码。</p><p id="7ad5" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">让我们把它设置为<code class="fe mz na nb nc b">lib/index.js</code>。该文件将成为捆绑器的输出文件。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nd ne l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">package.json</p></figure><p id="7dfb" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">我们需要再添加一个文件，它将实际定义从库中导出的内容以及用户可以导入的内容。我们正在构建一个组件库，所以让我们导出之前创建的<code class="fe mz na nb nc b">Button</code>组件。创建一个<code class="fe mz na nb nc b">src/index.js</code>文件，并键入以下代码:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nd ne l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">src/index.js</p></figure><p id="4149" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">这两个文件<code class="fe mz na nb nc b">src/index.js</code>和<code class="fe mz na nb nc b">lib/index.js</code>分别是捆绑器的输入和输出文件。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="a809" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">捆绑库</h1><p id="a150" class="pw-post-body-paragraph ky kz it la b lb mu ju ld le mv jx lg lh mw lj lk ll mx ln lo lp my lr ls lt im bi translated">我们将使用<a class="ae lu" href="https://rollupjs.org/guide/en/" rel="noopener ugc nofollow" target="_blank">卷</a>模块捆扎机。显然，第一步是安装它，以及一些重要的插件:</p><pre class="kj kk kl km gt nf nc ng nh aw ni bi"><span id="2877" class="nj md it nc b gy nk nl l nm nn">npm i -D rollup rollup-plugin-commonjs rollup-plugin-babel</span></pre><p id="501d" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">第一个插件将使CommonJS模块包含在捆绑包中，第二个插件用于与现有的Babel config无缝集成。</p><p id="8b6f" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">让我们创建汇总配置文件，<code class="fe mz na nb nc b">rollup.config.js</code>:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nd ne l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">rollup .配置. js</p></figure><p id="e29a" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">可以看到两个字段:<code class="fe mz na nb nc b">input</code>和<code class="fe mz na nb nc b">output</code>。这是我们告诉Rollup将<code class="fe mz na nb nc b">src/index.js</code>捆绑到<code class="fe mz na nb nc b">lib/index.js</code>的地方。输出模块将采用CommonJS格式。我们稍后将讨论其他类型。让我们将构建脚本— <code class="fe mz na nb nc b">"build": "rollup -c"</code> —添加到<code class="fe mz na nb nc b">package.json</code>并运行它。我们应该看到类似这样的内容:</p><pre class="kj kk kl km gt nf nc ng nh aw ni bi"><span id="b75d" class="nj md it nc b gy nk nl l nm nn">./src/index.js → lib/index.js...<br/>(!) Unresolved dependencies<br/>...<br/>react (imported by src/components/Button.js)<br/><a class="ae lu" href="http://twitter.com/emotion/styled" rel="noopener ugc nofollow" target="_blank">@emotion/styled</a> (imported by src/components/Button.js)<br/><a class="ae lu" href="http://twitter.com/emotion/core" rel="noopener ugc nofollow" target="_blank">@emotion/core</a> (imported by src/config/styles.js)<br/>created lib/index.js in 1.3s</span></pre><p id="c466" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">Rollup警告我们未解决的依赖关系<em class="no">。</em>这是什么意思？默认情况下，汇总将只解析相对于的<em class="no">模块id。这意味着像<code class="fe mz na nb nc b">import X from 'Y';</code>这样的导入语句不会导致<code class="fe mz na nb nc b">X</code>包含在您的包中。相反，它将是运行时所需的外部依赖项。</em></p><p id="0502" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">如果用户已经在项目中安装了<code class="fe mz na nb nc b">Y</code>的话，这是可行的，但是这并不是构建共享库的便捷方式。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h2 id="e99d" class="nj md it bd me np nq dn mi nr ns dp mm lh nt nu mo ll nv nw mq lp nx ny ms nz bi translated">解析模块</h2><p id="06f8" class="pw-post-body-paragraph ky kz it la b lb mu ju ld le mv jx lg lh mw lj lk ll mx ln lo lp my lr ls lt im bi translated">有一个插件可以解析第三方模块，并将它们包含在包中。让我们安装<code class="fe mz na nb nc b">npm i -D rollup-plugin-node-resolve</code>，并将其添加到汇总配置文件中。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nd ne l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">rollup .配置. js</p></figure><p id="a9df" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">再次运行构建并…</p><pre class="kj kk kl km gt nf nc ng nh aw ni bi"><span id="d615" class="nj md it nc b gy nk nl l nm nn">$ npm run build</span><span id="e1db" class="nj md it nc b gy oa nl l nm nn">./src/index.js → lib/index.js...<br/>[!] Error: 'createContext' is not exported by node_modules/react/index.js</span></pre><p id="122a" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">现在我们有一个外部库的问题。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h2 id="eb51" class="nj md it bd me np nq dn mi nr ns dp mm lh nt nu mo ll nv nw mq lp nx ny ms nz bi translated">处理对等依赖关系</h2><p id="0da7" class="pw-post-body-paragraph ky kz it la b lb mu ju ld le mv jx lg lh mw lj lk ll mx ln lo lp my lr ls lt im bi translated">在教程的第一部分，我们添加了React和Emotion作为项目的对等依赖项。这些依赖关系应该由库的消费者提供，而不是直接捆绑到代码中。</p><p id="174f" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">在汇总配置中有一个<code class="fe mz na nb nc b">external</code>选项，用于指定应该被视为对等依赖的库。显然，这已经在<code class="fe mz na nb nc b">peerDependecies</code>字段的<code class="fe mz na nb nc b">package.json</code>中指定了，所以我们将使用另一个Rollup插件来自动处理该列表并将其添加到配置中。</p><p id="1be6" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">让我们安装它— <code class="fe mz na nb nc b">npm i -D rollup-plugin-peer-deps-external</code> —并将其添加到汇总配置中:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nd ne l"/></div></figure><p id="7db9" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">让我们重建包并检查<code class="fe mz na nb nc b">lib/index.js</code>。我们可以看到我们的<code class="fe mz na nb nc b">Button</code>组件被捆绑，对等依赖项被正确导入。</p><p id="3623" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">此时，这个库应该已经可以使用了。例如，在<code class="fe mz na nb nc b">react-sample-components-library</code>下发布后，您或其他人可以通过以下方式在他们的项目中使用<code class="fe mz na nb nc b">Button</code>:</p><p id="3ec8" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated"><code class="fe mz na nb nc b">import { Button } from 'react-sample-components-library';</code></p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="8b4b" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">在本地怎么查？</h1><p id="a3ae" class="pw-post-body-paragraph ky kz it la b lb mu ju ld le mv jx lg lh mw lj lk ll mx ln lo lp my lr ls lt im bi translated">好吧，如果每次我们做一个小的改变来看看相关项目中的所有东西是否都工作了，那么发布这个库就很麻烦了。</p><p id="ae86" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">幸运的是，我们有一个命令叫做<code class="fe mz na nb nc b">link</code> ( <code class="fe mz na nb nc b"><a class="ae lu" href="https://yarnpkg.com/lang/en/docs/cli/link/" rel="noopener ugc nofollow" target="_blank">yarn link</a></code>或<code class="fe mz na nb nc b"><a class="ae lu" href="https://docs.npmjs.com/cli/link" rel="noopener ugc nofollow" target="_blank">npm link</a></code>)。</p><p id="48eb" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">假设我们的库，在<code class="fe mz na nb nc b">~/library</code>目录中本地开发，命名为<code class="fe mz na nb nc b">react-sample-components-library</code>(<code class="fe mz na nb nc b">~/library/package.json</code>中的<code class="fe mz na nb nc b">name</code>字段)。<br/>我们也有一些使用该库的独立项目。该项目位于<code class="fe mz na nb nc b">~/project</code>目录下。现在我们可以做以下事情(我鼓励你在这里使用<code class="fe mz na nb nc b">yarn</code>，因为它给出了复制粘贴的提示)。</p><pre class="kj kk kl km gt nf nc ng nh aw ni bi"><span id="fb05" class="nj md it nc b gy nk nl l nm nn">$ cd ~/library<br/>$ yarn link</span><span id="5db0" class="nj md it nc b gy oa nl l nm nn">success Registered "react-sample-components-library".<br/>info You can now run `yarn link "react-sample-components-library"` in the projects ...<br/><br/>$ cd ~/project<br/>$ yarn link "react-sample-components-library"</span></pre><p id="46c3" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">现在，您的项目将使用本地目录中的库。它使用生成的包，所以记得在对库本身进行更改后重新构建它们。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="8013" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">缩小</h1><p id="ef98" class="pw-post-body-paragraph ky kz it la b lb mu ju ld le mv jx lg lh mw lj lk ll mx ln lo lp my lr ls lt im bi translated">如果不缩小，捆的重量应该在<code class="fe mz na nb nc b">1.8kB</code>左右。这很小，但是记住我们在库中只有一个组件。随着库的增长，每个字节都开始计数。</p><p id="1c35" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">为了缩小我们的包，我们将使用丑陋插件。让我们安装它— <code class="fe mz na nb nc b">npm i -D rollup-plugin-uglify</code> —并将其添加到配置中。我们现在将把我们的配置分成两部分:一部分用于普通捆绑包，另一部分用于迷你捆绑包。我们还将添加一个小的辅助函数<code class="fe mz na nb nc b">minifyExtension</code>来将<code class="fe mz na nb nc b">.min</code>添加到缩小的文件输出路径中:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nd ne l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">rollup .配置. js</p></figure><p id="2ed6" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">让我们运行构建并检查<code class="fe mz na nb nc b">lib</code>目录的内容:</p><pre class="kj kk kl km gt nf nc ng nh aw ni bi"><span id="5e86" class="nj md it nc b gy nk nl l nm nn">1.4K  index.min.js<br/>1.8K  index.js</span></pre><p id="5ed7" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">很好，我们通过缩小保存了<code class="fe mz na nb nc b">0.4k</code>！⚖</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="4ebd" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">其他模块类型:UMD、爱沙尼亚</h1><p id="5650" class="pw-post-body-paragraph ky kz it la b lb mu ju ld le mv jx lg lh mw lj lk ll mx ln lo lp my lr ls lt im bi translated">除了CommonJS模块格式，还有<a class="ae lu" href="https://github.com/umdjs/umd" rel="noopener ugc nofollow" target="_blank"> UMD </a>和<a class="ae lu" href="https://nodejs.org/api/esm.html" rel="noopener ugc nofollow" target="_blank"> ES </a>格式。第一个缩写代表<em class="no">通用模块定义。它可以在任何地方工作，无论是在客户端、服务器还是其他地方。ES实际上是ECMAScript模块，是封装JavaScript代码的官方标准格式。</em></p><p id="7f6e" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">类似于<code class="fe mz na nb nc b">package.json</code>中为CommonJS模块类型指定输出文件路径的<code class="fe mz na nb nc b">main</code>字段，我们也有:</p><ul class=""><li id="9bcb" class="ob oc it la b lb lc le lf lh od ll oe lp of lt og oh oi oj bi translated"><code class="fe mz na nb nc b">browser</code>:针对UMD版本和浏览器的使用</li><li id="ba63" class="ob oc it la b lb ok le ol lh om ll on lp oo lt og oh oi oj bi translated"><code class="fe mz na nb nc b">module</code>:用于ES包格式(可用于ES模块感知工具)</li></ul><p id="343e" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">最好使库尽可能易于访问，因此我们将在所有这些模块类型中生成包。</p><p id="631a" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">让我们通过添加<code class="fe mz na nb nc b">browser</code>和<code class="fe mz na nb nc b">module</code>字段来修改我们的<code class="fe mz na nb nc b">package.json</code>:</p><pre class="kj kk kl km gt nf nc ng nh aw ni bi"><span id="9880" class="nj md it nc b gy nk nl l nm nn">{<br/>  ...<br/>  "main": "lib/index.js",<br/>  "browser": "lib/index.umd.js",<br/>  "module": "lib/index.es.js",<br/>  ...<br/>}</span></pre><p id="8e6b" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">为了更新配置，让我们从UMD部分开始:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nd ne l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">rollup .配置. js</p></figure><p id="d890" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">除了更改<code class="fe mz na nb nc b">output.format</code>和<code class="fe mz na nb nc b">output.file</code>以读取<code class="fe mz na nb nc b">browser</code>字段外，还有其他几个更改:</p><ul class=""><li id="7c20" class="ob oc it la b lb lc le lf lh od ll oe lp of lt og oh oi oj bi translated">为了告诉Rollup如何访问给定的依赖项，有一个新的<code class="fe mz na nb nc b"><a class="ae lu" href="https://rollupjs.org/guide/en/" rel="noopener ugc nofollow" target="_blank">output.globals</a></code>字段</li><li id="88d7" class="ob oc it la b lb ok le ol lh om ll on lp oo lt og oh oi oj bi translated">为了简化UMD/ES代码，我们需要<code class="fe mz na nb nc b">terser</code>而不是<code class="fe mz na nb nc b">uglify</code>。安装<code class="fe mz na nb nc b">rollup-plugin-terser</code></li></ul><p id="1791" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">现在，对于ES部分:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nd ne l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">rollup .配置. js</p></figure><p id="a7cc" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">现在让我们运行构建并查看输出:</p><pre class="kj kk kl km gt nf nc ng nh aw ni bi"><span id="e143" class="nj md it nc b gy nk nl l nm nn">1.5K  index.es.js<br/>827B  index.es.min.js<br/>1.8K  index.js<br/>1.4K  index.min.js<br/>2.3K  index.umd.js<br/>1.2K  index.umd.min.js</span></pre><p id="a7aa" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">我们现在有几种格式的包，可以被各种不同的工具使用。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="9001" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">出版前的最后准备</h1><p id="235a" class="pw-post-body-paragraph ky kz it la b lb mu ju ld le mv jx lg lh mw lj lk ll mx ln lo lp my lr ls lt im bi translated">在发布这个包之前，让我们给<code class="fe mz na nb nc b">package.json</code>添加一些助手脚本:</p><pre class="kj kk kl km gt nf nc ng nh aw ni bi"><span id="e1c8" class="nj md it nc b gy nk nl l nm nn">"prepublishOnly": "rm -rf lib &amp;&amp; npm run build",<br/>"postbuild": "npm pack &amp;&amp; tar -xvzf *.tgz &amp;&amp; rm -rf package *.tgz"</span></pre><p id="a259" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">使用<code class="fe mz na nb nc b">prepublishOnly</code>，每次我们想要发布包时，<code class="fe mz na nb nc b">lib</code>目录将被清理并重建源文件。这是一个非常好的检查，可以防止我们意外发布旧文件。</p><p id="4bff" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated"><code class="fe mz na nb nc b">postbuild</code>中的命令将显示发布到NPM的包的内容。</p><p id="bd08" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated"><strong class="la iu">注意:</strong><code class="fe mz na nb nc b">package.json</code>中的<code class="fe mz na nb nc b">name</code>属性是您的包的名称，<em class="no">必须是唯一的</em>。检查NPM，看看你想得到的名字是否是免费的。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="f0dc" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">将包发布到NPM</h1><p id="6803" class="pw-post-body-paragraph ky kz it la b lb mu ju ld le mv jx lg lh mw lj lk ll mx ln lo lp my lr ls lt im bi translated">为了把这个包发布到NPM，你应该在www.npmjs.com有一个账户。如果还没有，就创建它。</p><p id="0104" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">让我们跳到终端，通过运行<code class="fe mz na nb nc b">npm login</code>登录NPM。如果一切顺利，您应该会看到这样的内容:</p><pre class="kj kk kl km gt nf nc ng nh aw ni bi"><span id="1fa3" class="nj md it nc b gy nk nl l nm nn">$ npm login<br/>Username: tfiechowski<br/>Password: ***<br/>Email: (this IS public) <a class="ae lu" href="mailto:tomasz.fiechowski@gmail.com" rel="noopener ugc nofollow" target="_blank">tomasz.fiechowski@gmail.com</a><br/>Logged in as tfiechowski on <a class="ae lu" href="https://registry.npmjs.org/" rel="noopener ugc nofollow" target="_blank">https://registry.npmjs.org/</a>.</span></pre><p id="a7bb" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">最后运行<code class="fe mz na nb nc b">npm publish</code>。</p><p id="2dfb" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">假设一切顺利，你可以进入<code class="fe mz na nb nc b">npmjs.com/package/&lt;package-name&gt;</code>，开一瓶啤酒。</p><p id="106a" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated"><strong class="la iu">注意:</strong>你可以检出<code class="fe mz na nb nc b">part3-first-publish</code>标签来查看文章这个阶段的存储库(就<code class="fe mz na nb nc b">git checkout part3-first-publish</code>)。</p><p id="a8bb" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">让我们后退一步，看看<code class="fe mz na nb nc b">npm publish</code>命令的输出。等等，那是什么？</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="614c" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">优化包装</h1><p id="3ce6" class="pw-post-body-paragraph ky kz it la b lb mu ju ld le mv jx lg lh mw lj lk ll mx ln lo lp my lr ls lt im bi translated">当您查看<code class="fe mz na nb nc b">npm publish</code>输出中的文件列表时，您的存储库中确实有一个文件:</p><pre class="kj kk kl km gt nf nc ng nh aw ni bi"><span id="f842" class="nj md it nc b gy nk nl l nm nn">=== Tarball Contents === <br/>1.4kB package.json                 <br/>121B  .babelrc                     <br/>68B   jest.config.js               <br/>408B  README.md                    <br/>2.3kB rollup.config.js             <br/>204B  styleguide.config.js         <br/>1.6kB lib/index.es.js              <br/>827B  lib/index.es.min.js          <br/>1.8kB lib/index.js                 <br/>1.4kB lib/index.min.js             <br/>2.3kB lib/index.umd.js             <br/>1.2kB lib/index.umd.min.js         <br/>309B  src/components/Button.js     <br/>103B  src/components/Button.md     <br/>887B  src/components/Button.test.js<br/>328B  src/config/styles.js         <br/>55B   src/index.js                 <br/>66B   src/setupTests.js</span></pre><p id="f214" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">那不优雅。我们不需要这些文件中的大部分。让我们改进这一点。</p><p id="6868" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">我们可以在<code class="fe mz na nb nc b">package.json</code>中指定<code class="fe mz na nb nc b">files</code>字段。它基本上把将要包含在包中的文件列入白名单。默认情况下，它接受我们已经看到的来自存储库的所有文件(考虑到<code class="fe mz na nb nc b">.gitignore</code>)。</p><p id="ab02" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated"><strong class="la iu">注:</strong>有可能把<code class="fe mz na nb nc b">.npmignore</code>加到你的黑名单里，但是<a class="ae lu" href="https://medium.com/@jdxcode/for-the-love-of-god-dont-use-npmignore-f93c08909d8d" rel="noopener">看在上帝的份上，不要用</a>。</p><p id="e8ad" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">让我们修改<code class="fe mz na nb nc b">files</code>,只包含我们的捆绑文件:</p><pre class="kj kk kl km gt nf nc ng nh aw ni bi"><span id="82b6" class="nj md it nc b gy nk nl l nm nn">{<br/>  ...<br/>  "files": [<br/>    "/lib"<br/>  ],<br/>  ...<br/>}</span></pre><p id="2714" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated"><strong class="la iu">注意:</strong>在<code class="fe mz na nb nc b">lib</code>前没有<code class="fe mz na nb nc b">/</code>前缀，所有嵌套的<code class="fe mz na nb nc b">lib</code>目录，例如<code class="fe mz na nb nc b">abc/def/lib</code>，也将被包括在内。</p><p id="124e" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">现在，让我们使用我们的<code class="fe mz na nb nc b">postbuild</code>助手来检查包内容，而不实际发布它:</p><pre class="kj kk kl km gt nf nc ng nh aw ni bi"><span id="12e8" class="nj md it nc b gy nk nl l nm nn">$ npm run build</span><span id="1d2f" class="nj md it nc b gy oa nl l nm nn">=== Tarball Contents === <br/>1.4kB package.json        <br/>408B  README.md           <br/>1.6kB lib/index.es.js     <br/>827B  lib/index.es.min.js <br/>1.8kB lib/index.js        <br/>1.4kB lib/index.min.js    <br/>2.3kB lib/index.umd.js    <br/>1.2kB lib/index.umd.min.js</span></pre><p id="6a4e" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">太好了，我们只拿到需要的文件，没有多余的。</p><p id="02b5" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated"><strong class="la iu">注意:</strong>如果你的包变得可疑的大，或者你只是想分析它的内容，有两个伟大的插件可以帮助你:<br/> <code class="fe mz na nb nc b"><a class="ae lu" href="https://github.com/doesdev/rollup-plugin-analyzer" rel="noopener ugc nofollow" target="_blank">rollup-plugin-analyzer</a></code>和<code class="fe mz na nb nc b"><a class="ae lu" href="https://github.com/btd/rollup-plugin-visualizer" rel="noopener ugc nofollow" target="_blank">rollup-plugin-</a>visualizer</code>。</p><h2 id="ba53" class="nj md it bd me np nq dn mi nr ns dp mm lh nt nu mo ll nv nw mq lp nx ny ms nz bi translated">对库进行版本控制</h2><p id="b6fb" class="pw-post-body-paragraph ky kz it la b lb mu ju ld le mv jx lg lh mw lj lk ll mx ln lo lp my lr ls lt im bi translated">使用<a class="ae lu" href="https://docs.npmjs.com/about-semantic-versioning" rel="noopener ugc nofollow" target="_blank">语义版本化</a>来指定对您的包的更新。</p><p id="6a77" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">我们优化了软件包，所以发布新版本会很好。将<code class="fe mz na nb nc b">package.json</code>中的<code class="fe mz na nb nc b">version</code>向上撞至<code class="fe mz na nb nc b">1.0.1</code>，再次运行<code class="fe mz na nb nc b">npm publish</code>。</p><p id="1e27" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">就是这样。您和其他人现在可以将您的库导入到各自的项目中了！</p><h2 id="9a6a" class="nj md it bd me np nq dn mi nr ns dp mm lh nt nu mo ll nv nw mq lp nx ny ms nz bi translated">生成源地图</h2><p id="f886" class="pw-post-body-paragraph ky kz it la b lb mu ju ld le mv jx lg lh mw lj lk ll mx ln lo lp my lr ls lt im bi translated">最后，我们可以将源映射添加到包中，使用户能够在必要时检查源，并轻松调试库。</p><p id="b98a" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">要生成源映射，只需在您的汇总配置中将<code class="fe mz na nb nc b">output.sourcemap</code>设置为<code class="fe mz na nb nc b">true</code>，例如:</p><pre class="kj kk kl km gt nf nc ng nh aw ni bi"><span id="fd31" class="nj md it nc b gy nk nl l nm nn">output: {<br/>  file: packageJSON.main,<br/>  format: "cjs",<br/>  sourcemap: true<br/>}</span></pre></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="534e" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">摘要</h1><p id="2734" class="pw-post-body-paragraph ky kz it la b lb mu ju ld le mv jx lg lh mw lj lk ll mx ln lo lp my lr ls lt im bi translated">我们设置了Rollup来捆绑我们的代码，并在这个过程中加入了缩减。后来我们添加了更多类型的生成模块:UMD和es。然后我们发布了库的初始版本，并优化了包的内容，以尽可能减轻包的重量。</p><p id="5af0" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">完整的代码可以在<a class="ae lu" href="https://github.com/tfiechowski/react-sample-components-library" rel="noopener ugc nofollow" target="_blank"> GitHub库</a>中找到。您可以查看<code class="fe mz na nb nc b">part3</code>标签(<code class="fe mz na nb nc b">git checkout part3</code>)来查看这部分的完整示例。</p><h2 id="5840" class="nj md it bd me np nq dn mi nr ns dp mm lh nt nu mo ll nv nw mq lp nx ny ms nz bi translated">下一部分</h2><p id="76e4" class="pw-post-body-paragraph ky kz it la b lb mu ju ld le mv jx lg lh mw lj lk ll mx ln lo lp my lr ls lt im bi translated">在下一个也是最后一个部分，我们负责将文档自动部署到GitHub页面<a class="ae lu" href="https://medium.com/@tomasz.fiechowski/building-a-react-components-library-2e116df187b5" rel="noopener">。</a></p><h2 id="c247" class="nj md it bd me np nq dn mi nr ns dp mm lh nt nu mo ll nv nw mq lp nx ny ms nz bi translated">关于<code class="fe mz na nb nc b"><em class="op">@emotion/styled</em></code>的重要说明</h2><p id="4c6c" class="pw-post-body-paragraph ky kz it la b lb mu ju ld le mv jx lg lh mw lj lk ll mx ln lo lp my lr ls lt im bi translated">如果你想使用Emotion的很酷的特性，比如作为选择器的组件，你需要安装一个Babel插件来处理这些预处理。取名<code class="fe mz na nb nc b">babel-plugin-emotion</code>。</p><p id="63ff" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">玩情绪的时候也请检查一下捆绑的大小。我有一些很大的问题，包裹太重了。最后，我注意到包中有一些非常大的blob文本块。结果是源代码地图包含在捆绑包中。留意那个。</p></div></div>    
</body>
</html>