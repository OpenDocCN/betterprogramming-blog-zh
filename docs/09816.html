<html>
<head>
<title>Deploying a Kotlin App With Heroku</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用Heroku部署Kotlin应用程序</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/deploying-a-kotlin-app-with-heroku-a9b2880529e0?source=collection_archive---------2-----------------------#2021-10-15">https://betterprogramming.pub/deploying-a-kotlin-app-with-heroku-a9b2880529e0?source=collection_archive---------2-----------------------#2021-10-15</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="2c33" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">用PostgreSQL数据库构建一个简单的API</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/5a0e54aaa83a4f5d4c597948672f71ae.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*_pz_dIByXkNFuAo4"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">照片由<a class="ae ky" href="https://unsplash.com/@helloimnik?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">你好我是尼克</a>在<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a></p></figure><p id="e258" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">自从最早发布以来，Java一直标榜自己是一种“<a class="ae ky" href="https://en.wikipedia.org/wiki/Write_once,_run_anywhere" rel="noopener ugc nofollow" target="_blank">编写一次，到处运行</a>”的编程语言。这个想法是，程序员可以用Java开发一个应用程序，将其编译成字节码，并成为一个可在任何平台上运行的可执行文件，而不管是什么操作系统或平台。它之所以能够做到这一点，部分是因为运行时被称为Java虚拟机，或JVM。</p><p id="11d9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">值得称赞的是，JVM过去是(现在仍然是！)一个令人难以置信的微调运行时，它抽象出了计算机的底层硬件。虽然Java作为一种编程语言生存到了今天，但它经常被认为是笨重、乏味的，并且是实现解决方案的过时方法的代表。</p><p id="f189" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在过去的十年中，越来越多运行在JVM上的语言已经开发出来，但是看起来和感觉上一点也不像Java。一种这样的语言是科特林语。由于JVM的原因，它与普通Java相比并没有真正的性能优势。尽管如此，它的优势在于它以一种Java没有的方式优先考虑易读性。例如，考虑用Java打印一个子字符串:</p><pre class="kj kk kl km gt lv lw lx ly aw lz bi"><span id="bd1b" class="ma mb it lw b gy mc md l me mf">// Java<br/>String input = "What is the answer to the Ultimate Question of Life, the Universe, and Everything? 42";<br/>String answer = input.substring(input.indexOf("?") + 1);<br/>System.out.println(answer);</span></pre><p id="6bb0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">你必须首先得到你想要在子串中的字符的索引，加一(因为字符串是零索引的)，然后调用<code class="fe mg mh mi lw b">System.out.println</code>写到stdout。</p><p id="1fe7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在科特林，这要短得多:</p><pre class="kj kk kl km gt lv lw lx ly aw lz bi"><span id="04fb" class="ma mb it lw b gy mc md l me mf">// Kotlin<br/>val input = "What is the answer to the Ultimate Question of Life, the Universe, and Everything? 42"<br/>val answer = input.substringAfter("?")<br/>println(answer)</span></pre><p id="9d4a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">Kotlin吸引了如此多的兴趣，以至于谷歌甚至推荐它而不是Java来开发Android应用程序。</p><p id="7ccd" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在这篇文章中，我们将快速了解如何用Kotlin开发一个应用程序。我们将使用PostgreSQL数据库构建一个简单的API，并将其部署到Heroku进行现场演示。</p><h1 id="ba76" class="mj mb it bd mk ml mm mn mo mp mq mr ms jz mt ka mu kc mv kd mw kf mx kg my mz bi translated">先决条件</h1><p id="05aa" class="pw-post-body-paragraph kz la it lb b lc na ju le lf nb jx lh li nc lk ll lm nd lo lp lq ne ls lt lu im bi translated">在我们开始之前，您需要确保您的计算机上安装了以下软件:</p><ol class=""><li id="28fc" class="nf ng it lb b lc ld lf lg li nh lm ni lq nj lu nk nl nm nn bi translated">关于Heroku的报道。这是完全免费的，不需要任何支付信息。</li><li id="1323" class="nf ng it lb b lc no lf np li nq lm nr lq ns lu nk nl nm nn bi translated">Heroku CLI 。一旦你的应用程序在Heroku上，这将使管理它更容易。</li><li id="a29f" class="nf ng it lb b lc no lf np li nq lm nr lq ns lu nk nl nm nn bi translated">你需要安装<a class="ae ky" href="https://kotlinlang.org/docs/command-line.html" rel="noopener ugc nofollow" target="_blank">kot Lin</a>(&gt;= 1.4)。</li><li id="b488" class="nf ng it lb b lc no lf np li nq lm nr lq ns lu nk nl nm nn bi translated">你还需要安装<a class="ae ky" href="https://gradle.org/install/" rel="noopener ugc nofollow" target="_blank">Gradle</a>(&gt;= 7.0)。</li></ol><p id="8ff0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">你还需要稍微熟悉一下Git，并在你的机器上安装它。</p><p id="79b3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们将为这个Kotlin应用程序使用IntelliJ IDE。他们的文档提供了一些关于如何创建新项目的指导。确保选择以下选项:</p><ul class=""><li id="ce8c" class="nf ng it lb b lc ld lf lg li nh lm ni lq nj lu nt nl nm nn bi translated">我们想要创建一个使用Gradle作为构建系统的Kotlin应用程序</li><li id="9726" class="nf ng it lb b lc no lf np li nq lm nr lq ns lu nt nl nm nn bi translated">将项目名称设置为<code class="fe mg mh mi lw b">kotlin-api</code></li><li id="aed6" class="nf ng it lb b lc no lf np li nq lm nr lq ns lu nt nl nm nn bi translated">将JDK版本设置为16。如果您没有安装此版本，可以从下拉列表中选择下载JDK…,然后选择Oracle Open JDK版本16</li></ul><p id="4565" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">IDE完成所有设置后，您应该有一个大致如下所示的目录结构:</p><pre class="kj kk kl km gt lv lw lx ly aw lz bi"><span id="1638" class="ma mb it lw b gy mc md l me mf">kotlin-api<br/>├── build.gradle.kts<br/>└── src<br/>    ├── main<br/>    │   ├── kotlin</span></pre><p id="6eea" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们的Kotlin文件将保存在<code class="fe mg mh mi lw b">src/main/kotlin</code>中，我们的构建逻辑将保存在<code class="fe mg mh mi lw b">build.gradle.kts</code>中。</p><h1 id="53b4" class="mj mb it bd mk ml mm mn mo mp mq mr ms jz mt ka mu kc mv kd mw kf mx kg my mz bi translated">入门指南</h1><p id="deb4" class="pw-post-body-paragraph kz la it lb b lc na ju le lf nb jx lh li nc lk ll lm nd lo lp lq ne ls lt lu im bi translated">Gradle是多种语言的构建工具。它还充当依赖管理工具，类似于Maven。在您的<code class="fe mg mh mi lw b">build.gradle.kts</code>文件中已经有了一些行，IDE自动添加了这些行以提供帮助。您可以删除所有这些内容，并粘贴以下代码行:</p><pre class="kj kk kl km gt lv lw lx ly aw lz bi"><span id="caa4" class="ma mb it lw b gy mc md l me mf">plugins {<br/>    id("java")<br/>    id("org.jetbrains.kotlin.jvm") version "1.5.10"<br/>    id("org.springframework.boot") version "2.4.3"<br/>    id("io.spring.dependency-management") version "1.0.11.RELEASE"<br/>}<br/>group "com.example"<br/>version "0.0.1"<br/>repositories {<br/>    mavenCentral()<br/>}<br/>dependencies {<br/>    implementation("org.jetbrains.kotlin:kotlin-stdlib") <br/>    implementation("org.springframework.boot:spring-boot-starter-web")    <br/>    implementation("org.springframework.boot:spring-boot-starter")<br/>    developmentOnly("org.springframework.boot:spring-boot-devtools")<br/>}</span></pre><p id="6dfc" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这些行指定了我们项目的依赖项以及在哪里可以找到它们。例如，我们想在版本2.4.3中使用<code class="fe mg mh mi lw b">[org.springframework.boot](https://plugins.gradle.org/plugin/org.springframework.boot)</code>，这就是为什么它被定义在<code class="fe mg mh mi lw b">plugins</code>块中。我们指出在哪里可以找到包——在<code class="fe mg mh mi lw b">mavenCentral()</code>——以及我们想要使用哪些公开的类(<code class="fe mg mh mi lw b">implementation( "org.springframework.boot:spring-boot-starter-web")</code>)。</p><p id="6542" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们创建两个小文件来测试我们的设置。在<code class="fe mg mh mi lw b">src/main/kotlin</code>文件夹中创建一个名为<code class="fe mg mh mi lw b">Application.kt</code>的文件，并粘贴如下内容:</p><pre class="kj kk kl km gt lv lw lx ly aw lz bi"><span id="9c28" class="ma mb it lw b gy mc md l me mf">package com.example</span><span id="4a24" class="ma mb it lw b gy nu md l me mf">import org.springframework.boot.SpringApplication<br/>import org.springframework.boot.autoconfigure.SpringBootApplication</span><span id="16a0" class="ma mb it lw b gy nu md l me mf">@SpringBootApplication<br/>open class Application</span><span id="1192" class="ma mb it lw b gy nu md l me mf">fun main(args: Array&lt;String&gt;) {<br/>    SpringApplication.run(Application::class.java, *args)<br/>}</span></pre><p id="8b3d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这将启动一个使用Spring框架的默认应用程序。真正神奇的事情发生在下一个文件<code class="fe mg mh mi lw b">Controller.kt</code>中，您应该在<em class="nv"> src/main/kotlin </em>中与<code class="fe mg mh mi lw b">Application.kt</code>一起创建这个文件:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nw nx l"/></div></figure><p id="cd46" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在这里，我们定义了一条路由(<code class="fe mg mh mi lw b">@GetMapping("/{name}")</code>，其中<code class="fe mg mh mi lw b">{name}</code>是一个动态值。通过将这个装饰器放在一个Kotlin方法上(<code class="fe mg mh mi lw b">fun get</code>，或者“一个名为get的函数”)，我们能够将路由匹配到我们想要的任何行为——在本例中，为一个<code class="fe mg mh mi lw b">GET</code>请求返回一个带有路径名的问候。</p><p id="c206" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">为了让IDE知道如何启动我们的应用程序，我们需要创建一个运行配置。在IDE菜单的顶部，单击“添加配置”按钮。选择添加新的运行配置，然后从列表中选择Gradle。</p><p id="9ab6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">对于Gradle项目名称，输入<code class="fe mg mh mi lw b">kotlin-api</code>。在“任务”字段中，键入<code class="fe mg mh mi lw b">bootRun</code>。<code class="fe mg mh mi lw b"><a class="ae ky" href="https://docs.spring.io/spring-boot/docs/2.5.0/gradle-plugin/reference/htmlsingle/#running-your-application" rel="noopener ugc nofollow" target="_blank">bootRun</a></code>是Spring框架提供的一个Gradle任务，它将编译我们的代码并启动服务器。单击“Ok ”,现在IDE菜单栏中应该有一个绿色的Play按钮。当您点击它时，IDE将执行<code class="fe mg mh mi lw b">gradle bootRun</code>来构建这个Kotlin应用程序并启动服务器。完成后，导航至<code class="fe mg mh mi lw b">http:<em class="nv">//localhost:8080/world</em></code>。你应该看到一个很好的问候。</p><h1 id="f18c" class="mj mb it bd mk ml mm mn mo mp mq mr ms jz mt ka mu kc mv kd mw kf mx kg my mz bi translated">与数据库交互</h1><p id="cca1" class="pw-post-body-paragraph kz la it lb b lc na ju le lf nb jx lh li nc lk ll lm nd lo lp lq ne ls lt lu im bi translated">现在，让我们进入(有点)严肃的话题。假设我们想在这个项目中附加一个数据库。在Maven/Java世界中，我们需要更新XML文件并添加对JAR文件的引用。在Gradle中，我们只需在我们的<code class="fe mg mh mi lw b">build.gradle.kts</code>文件中添加几行就可以了:</p><pre class="kj kk kl km gt lv lw lx ly aw lz bi"><span id="39db" class="ma mb it lw b gy mc md l me mf">dependencies {<br/>    # ...</span><span id="a331" class="ma mb it lw b gy nu md l me mf">    implementation("com.zaxxer:HikariCP:4.0.3")<br/>    runtimeOnly("org.postgresql:postgresql")</span><span id="2b2c" class="ma mb it lw b gy nu md l me mf">    # ...<br/>}</span></pre><p id="8608" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这里，我们在项目中包含了<a class="ae ky" href="https://github.com/brettwooldridge/HikariCP" rel="noopener ugc nofollow" target="_blank"> HikariCP </a>，它是一个流行的数据库连接驱动程序。我们还指出我们希望在运行时“加载”库<code class="fe mg mh mi lw b">org.postgresql</code>。仅用这两行代码，我们就让我们的配置知道我们想要与PostgreSQL数据库进行交互。如果您已经有一个PostgreSQL数据库在本地运行，那就太好了。您将能够在本地继续本指南的剩余部分，并在浏览localhost时看到结果。如果你没有PostgreSQL，不要担心——我们将向你展示在Heroku上部署这个应用程序是多么容易，它将为你管理基础设施。</p><p id="d8ba" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">回到<code class="fe mg mh mi lw b">Controller.kt</code>，用下面的内容替换它。这需要一些我们以前有的东西，但是增加了它。我们将很快检查这些变化。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nw nx l"/></div></figure><p id="fc3d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这里发生了很多事情！让我们从底层开始。我们定义了一个名为<code class="fe mg mh mi lw b">dataSource</code>的函数，它提供了到我们数据库的连接。因为我们正在构建<a class="ae ky" href="https://12factor.net/config" rel="noopener ugc nofollow" target="_blank">一个12因素的应用</a>，我们的数据库凭证存储在一个名为<code class="fe mg mh mi lw b">DATABASE_URL</code>的环境变量中。我们获取那个URL，如果存在的话，从中提取用户名和密码。如果没有，我们检查另外两个环境变量来获取信息— <code class="fe mg mh mi lw b">DATABASE_USERNAME</code>和<code class="fe mg mh mi lw b">DATABASE_PASSWORD</code>。</p><p id="d45d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">然后，我们将所有信息放在一起，形成数据库连接器需要的格式。<code class="fe mg mh mi lw b">initDb</code>函数创建一个名为<code class="fe mg mh mi lw b">names</code>的表，其中有一个名为<code class="fe mg mh mi lw b">name</code>的文本列。和之前一样，<code class="fe mg mh mi lw b">/everyone</code>端点有一个<code class="fe mg mh mi lw b">@GetMapping</code>装饰器。这定义了一个<code class="fe mg mh mi lw b">GET /everyone</code>路由，它从数据库中获取所有的名字。</p><p id="6358" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">最后，我们添加了一些相当新的东西:一个<code class="fe mg mh mi lw b">@PostMapping</code>装饰器。这里，我们需要定义这个<code class="fe mg mh mi lw b">POST</code>路由可以接受什么类型的内容。在这种情况下，它是<code class="fe mg mh mi lw b">consumes</code>一个<code class="fe mg mh mi lw b">TEXT_PLAIN_VALUE</code>媒体类型(换句话说，<code class="fe mg mh mi lw b">"Content-Type: text/plain"</code>)。我们放在请求体中的任何信息字符串都将被添加到数据库中。只用几行代码，我们就构建了一个可以添加和查询的小API。</p><p id="ab1b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果您现在启动此服务器，并且您在本地运行PostgreSQL，您应该能够与它进行交互。尝试提出以下请求:</p><pre class="kj kk kl km gt lv lw lx ly aw lz bi"><span id="dc33" class="ma mb it lw b gy mc md l me mf">$ curl -H "Content-Type: text/plain" -X POST http://localhost:8080/add-name -d 'Frank'</span></pre><p id="5374" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果你导航到<code class="fe mg mh mi lw b">http://localhost:8080/everyone</code>，你会看到<code class="fe mg mh mi lw b">Frank</code>被包括在内。</p><h1 id="0893" class="mj mb it bd mk ml mm mn mo mp mq mr ms jz mt ka mu kc mv kd mw kf mx kg my mz bi translated">部署到Heroku</h1><p id="dfe2" class="pw-post-body-paragraph kz la it lb b lc na ju le lf nb jx lh li nc lk ll lm nd lo lp lq ne ls lt lu im bi translated">是时候看看让Kotlin在Heroku上运行有多容易了。首先，我们需要创建一个特定于Heroku的文件:<a class="ae ky" href="https://devcenter.heroku.com/articles/procfile" rel="noopener ugc nofollow" target="_blank">proc file</a>。这个文本文件定义了我们的应用程序应该如何引导和运行。</p><p id="ac1e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在根目录下创建一个名为<code class="fe mg mh mi lw b">Procfile</code>的文件，就在你的<code class="fe mg mh mi lw b">build.gradle.kts</code>文件旁边。将以下几行复制并粘贴到其中:</p><pre class="kj kk kl km gt lv lw lx ly aw lz bi"><span id="cb60" class="ma mb it lw b gy mc md l me mf">web: java -jar build/libs/kotlin-api.jar --server.port=$PORT</span></pre><p id="9a48" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在这里，我们说，我们希望Heroku运行<code class="fe mg mh mi lw b">java -jar build/libs/kotlin-api.jar</code>。这个JAR是在部署过程中打包和构建的；Heroku会自动为我们创建它，因为它知道如何执行Gradle任务来这样做。我们还绑定了<code class="fe mg mh mi lw b">$PORT</code>环境变量，以便Heroku知道服务器正在监听哪个端口。</p><p id="be27" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">接下来，运行以下Git命令:</p><pre class="kj kk kl km gt lv lw lx ly aw lz bi"><span id="196a" class="ma mb it lw b gy mc md l me mf">$ git init<br/>$ git add .<br/>$ git commit -m "Preparing my first Kotlin app"</span></pre><p id="2c62" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">既然我们已经安装了Heroku CLI，我们可以<a class="ae ky" href="https://devcenter.heroku.com/articles/creating-apps" rel="noopener ugc nofollow" target="_blank">在命令行上调用heroku create来生成一个app </a>:</p><pre class="kj kk kl km gt lv lw lx ly aw lz bi"><span id="4fcc" class="ma mb it lw b gy mc md l me mf">$ heroku create<br/>Creating app... done, ⬢ desolate-plains-67007<br/>Created http://desolate-plains-67007.herokuapp.com/ | git@heroku.com:desolate-plains-67007.git</span></pre><p id="6259" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">您的应用程序将被分配一个随机名称——在本例中，它是<code class="fe mg mh mi lw b">desolate-plains-67007</code>——以及一个公共访问的URL。</p><p id="222c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">为了提供数据库，我们使用了<code class="fe mg mh mi lw b"><a class="ae ky" href="https://devcenter.heroku.com/articles/heroku-cli-commands#heroku-addons-all-app-app" rel="noopener ugc nofollow" target="_blank">heroku addons</a></code>命令。无参数调用它会让我们知道是否存在:</p><pre class="kj kk kl km gt lv lw lx ly aw lz bi"><span id="7ef7" class="ma mb it lw b gy mc md l me mf">$ heroku addons<br/>No add-ons for app desolate-plains-67007.</span></pre><p id="bafd" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们的应用程序不存在任何附加组件，这很有意义——我们只是创建了它！要添加PostgreSQL数据库，我们可以像这样使用<code class="fe mg mh mi lw b">addons:create</code>命令:</p><pre class="kj kk kl km gt lv lw lx ly aw lz bi"><span id="01df" class="ma mb it lw b gy mc md l me mf">$ heroku addons:create heroku-postgresql:hobby-dev</span></pre><p id="eeb6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">Heroku提供了几层PostgreSQL数据库。<code class="fe mg mh mi lw b">hobby-dev</code>是免费层，所以我们可以不花一分钱就玩这个。</p><p id="c041" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">您的代码已准备好；您的Heroku应用程序已配置好，您可以开始部署了。这是容易的部分！只需输入以下命令:</p><pre class="kj kk kl km gt lv lw lx ly aw lz bi"><span id="8aaf" class="ma mb it lw b gy mc md l me mf">$ git push heroku master</span></pre><p id="c61f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">你的代码会被推送到Heroku。从那时起，赫罗库将接管一切。你会看到你的构建日志在你的终端上滚动。这将向您显示Heroku正在为您安装什么，以及您在构建过程中的位置。完成后，您可以在浏览器中访问您的特殊URL(在本例中为<code class="fe mg mh mi lw b">https://desolate-plains-67007.herokuapp.com</code>)并与互联网上的API进行交互！</p><h1 id="7e4b" class="mj mb it bd mk ml mm mn mo mp mq mr ms jz mt ka mu kc mv kd mw kf mx kg my mz bi translated">了解更多信息</h1><p id="1802" class="pw-post-body-paragraph kz la it lb b lc na ju le lf nb jx lh li nc lk ll lm nd lo lp lq ne ls lt lu im bi translated">Kotlin的<a class="ae ky" href="https://blog.heroku.com/rise-of-kotlin" rel="noopener ugc nofollow" target="_blank">高性能设计和清晰的语法</a>——结合Gradle的易用性——使其成为需要依赖久经考验的Java包的企业的理想选择。由于与Java的互操作性，Kotlin是理想的过渡语言；大量的Java代码可以被转换成Kotlin，同时仍然保持应用程序的功能。部署到Heroku很顺利，我甚至没有利用不同的方法<a class="ae ky" href="https://devcenter.heroku.com/categories/java-support" rel="noopener ugc nofollow" target="_blank">来微调Java和基于JVM的应用程序进行部署</a>。</p></div></div>    
</body>
</html>