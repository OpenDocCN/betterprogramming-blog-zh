<html>
<head>
<title>SwiftUI: Calculate Scroll Offset in ScrollViews</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">SwiftUI:计算ScrollViews中的滚动偏移量</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/swiftui-calculate-scroll-offset-in-scrollviews-c3b121f0b0dc?source=collection_archive---------1-----------------------#2022-01-08">https://betterprogramming.pub/swiftui-calculate-scroll-offset-in-scrollviews-c3b121f0b0dc?source=collection_archive---------1-----------------------#2022-01-08</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="669b" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">了解如何在SwiftUI ScrollView中计算实时偏移量</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/60b0bf8eb0df2029c3cea1f0e5ff4727.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*EG9sheBDQa-Q3B6Z"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">由<a class="ae ky" href="https://unsplash.com/@markusspiske?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Markus Spiske </a>在<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</p></figure><p id="669f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">SwiftUI，创建用户界面的新的声明式方法，确实是一个令人惊叹的框架。有了完整的实时预览，很多事情都可以马上完成，但有时，复制UIKit中很常见的东西会变得很麻烦。滚动视图偏移量就是其中之一！</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><p id="5108" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在UIKit中，每个<code class="fe mc md me mf b">UIScrollView</code>都有一个属性，允许我们轻松地读取视图本身的偏移量:</p><pre class="kj kk kl km gt mg mf mh mi aw mj bi"><span id="eb4e" class="mk ml it mf b gy mm mn l mo mp">var contentOffset: CGPoint { get set }</span></pre><p id="9e28" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">它返回一个带有x <code class="fe mc md me mf b"> </code>和<code class="fe mc md me mf b">y</code>值的结构。超级简单，超级方便！</p><p id="c98d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">遗憾的是，SwiftUI今天缺少了这个简单的属性。所以我们必须发明一种方法来获取这个值。</p><p id="7410" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在本教程结束时，您将能够创建类似于以下内容的内容:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi mq"><img src="../Images/1276b835ba4ed8f6c504f3075ded7c5d.png" data-original-src="https://miro.medium.com/v2/resize:fit:656/1*Caadc-WggJBXSMNjvP-6pA.gif"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">作者图片</p></figure></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><p id="06a5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">SwiftUI框架经常允许(或迫使)我们跳出框框思考问题，这是一个很好的机会。</p><p id="0e1c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们首先构建一个非常简单的UI，它有一个很长的列表和一个<code class="fe mc md me mf b">Text</code>标签，不能显示真实的偏移值(当然我们稍后会添加这个特性)，正如你可以看到的<code class="fe mc md me mf b">verticalOffset</code> var从来没有改变:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mr ms l"/></div></figure><p id="d5d0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">为了达到上面视频的效果，我们将编写一个<code class="fe mc md me mf b">View</code>代码，它的行为与SwiftUI <code class="fe mc md me mf b">ScrollView</code>完全一样，但会以某种方式广播其偏移量的实时值。</p><p id="c9c0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">首先，我们需要创建一个符合协议<code class="fe mc md me mf b">PreferenceKey</code>的新结构。</p><p id="42c8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">苹果官方文档给了我们这个协议的定义如下:</p><blockquote class="mt mu mv"><p id="96b1" class="kz la mw lb b lc ld ju le lf lg jx lh mx lj lk ll my ln lo lp mz lr ls lt lu im bi translated">由视图产生的命名值。<br/>具有多个子视图的视图自动将其给定首选项的值组合成对其祖先可见的单个值。</p></blockquote><p id="4f93" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">说我们允许一个视图与包含它的视图对话并传递值是一种复杂的方式。</p><p id="031f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">为了符合该协议，必须实现属性和函数，两者都是静态的:</p><pre class="kj kk kl km gt mg mf mh mi aw mj bi"><span id="20a1" class="mk ml it mf b gy mm mn l mo mp">static var defaultValue: Self.Value { get }</span><span id="ced8" class="mk ml it mf b gy na mn l mo mp">static func reduce(value: inout Self.Value, nextValue: () -&gt; Self.Value)</span></pre><p id="b62f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">默认值将是我们的偏移量a <code class="fe mc md me mf b">CGPoint</code>，起始值为<code class="fe mc md me mf b">0,0</code>。</p><p id="e8dc" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们创建<code class="fe mc md me mf b">OffsetPreferenceKey</code>结构，就像这样:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mr ms l"/></div></figure><p id="21db" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">干得好，现在是时候创建我们的版本了。<br/>让我们创建一个struct，它具有SwiftUI <code class="fe mc md me mf b">ScrollView</code>的相同属性，但是多了一个东西，<code class="fe mc md me mf b">onOffsetChanged</code>一个当<code class="fe mc md me mf b">scrollview</code>修改其位置时触发的闭包:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mr ms l"/></div></figure><p id="8f71" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">正如你所看到的，我使用了一个通用的var内容来传递<code class="fe mc md me mf b">ScrollView</code>的所有内容。如定义中所述，结构<code class="fe mc md me mf b">T</code>的类型为<code class="fe mc md me mf b">View</code>。</p><p id="fed4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在让我们看看<code class="fe mc md me mf b">body</code>属性的实现:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mr ms l"/></div></figure><ul class=""><li id="1def" class="nb nc it lb b lc ld lf lg li nd lm ne lq nf lu ng nh ni nj bi translated">在第2行，我创建了一个<code class="fe mc md me mf b">ScrollView</code></li><li id="0a8c" class="nb nc it lb b lc nk lf nl li nm lm nn lq no lu ng nh ni nj bi translated">第3行的<code class="fe mc md me mf b">GeometryReader</code>包含一个空视图，而<code class="fe mc md me mf b">Color.Clear</code>没有尺寸。我们需要跟踪一个视图的位置，使用一个无量纲的视图是一个聪明的想法。在其中，我设置了<code class="fe mc md me mf b">OffsetPreferenceKey</code>键，将帧本身的原点作为值传递。我已经使用了<code class="fe mc md me mf b">coordinateSpace(name:)</code>来允许另一个函数找到并操作我们的<code class="fe mc md me mf b">Color</code>视图，并操作与该视图相关的维度。</li><li id="041a" class="nb nc it lb b lc nk lf nl li nm lm nn lq no lu ng nh ni nj bi translated">我把原点位置传递给外界，当这个值改变时，在第15行启动闭包。</li><li id="6556" class="nb nc it lb b lc nk lf nl li nm lm nn lq no lu ng nh ni nj bi translated">在第12行，我使用了传递给初始化器的<code class="fe mc md me mf b">content</code>。</li></ul><p id="385e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这是整个结构:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mr ms l"/></div></figure><p id="6969" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">就这么定了！我们有了全新的<code class="fe mc md me mf b">OffsettableScrollView</code>,它将能够在偏移值改变时传递它！</p><p id="03af" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在是时候用最后连接的<code class="fe mc md me mf b">Text</code>来修改我们的原始内容视图了:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mr ms l"/></div></figure><p id="6d7b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">结束了！正如你所看到的是超级容易和超级干净了！</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><p id="ff4d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我希望你喜欢这篇文章。如果你对视频版感兴趣，我的YouTube频道上也有这个指南:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="np ms l"/></div></figure><p id="205f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">编码快乐！</p></div></div>    
</body>
</html>