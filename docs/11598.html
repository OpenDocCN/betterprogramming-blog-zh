<html>
<head>
<title>Implementing an HTTP Proxy for Rest API in Next.js</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">在Next.js中实现Rest API的HTTP代理</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/implementing-an-http-proxy-for-rest-api-in-next-js-65cdcd18fb73?source=collection_archive---------2-----------------------#2022-04-02">https://betterprogramming.pub/implementing-an-http-proxy-for-rest-api-in-next-js-65cdcd18fb73?source=collection_archive---------2-----------------------#2022-04-02</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="d4b9" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">如果您的后端服务对公共用户和其他各种恶意攻击隐藏起来，那不是很好吗？Next.js提供的后端服务有助于您的沟通</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/e67711e3a6f8d516b8f7e03c0c189666.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*mUS86vtcQN9mDUjddmD-Ow.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">资料来源:undraw.co</p></figure><p id="e4eb" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">在构建web应用程序时，安全性肯定是您最关心的问题之一。通常情况下，你不想暴露用户的敏感数据。</p><p id="7594" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">大多数现代web应用程序使用令牌进行身份验证。令牌应该由客户端存储，以便以后发送请求。有很多方法可以在用户的浏览器中存储用户的令牌。然而，最流行的方法是将所有类型的令牌保存在本地存储或普通cookies中。不幸的是，这不是存放代币最安全的地方。</p><p id="0ac0" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">本地存储和普通cookies这两者都可以通过第三方脚本和浏览器扩展来访问。我将讨论将令牌作为HttpOnly存储在cookies中。</p><h1 id="bdb3" class="lr ls iq bd lt lu lv lw lx ly lz ma mb jw mc jx md jz me ka mf kc mg kd mh mi bi translated">为什么必须使用HttpOnly cookies来存储令牌？</h1><p id="5bff" class="pw-post-body-paragraph kv kw iq kx b ky mj jr la lb mk ju ld le ml lg lh li mm lk ll lm mn lo lp lq ij bi translated">HttpOnly cookies不能通过客户端JavaScript代码访问。因此，浏览器扩展和任何在客户端运行的JavaScript代码都无法访问这些cookies。因此，你的JWT或其他东西是安全的。最后。</p><p id="a405" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">使用HTTP代理不仅仅来自安全cookies。它还提供了安全优势—即使存在跨站点脚本(XSS)缺陷，并且用户意外访问了利用该缺陷的链接，浏览器也不会将cookie泄露给第三方。</p></div><div class="ab cl mo mp hu mq" role="separator"><span class="mr bw bk ms mt mu"/><span class="mr bw bk ms mt mu"/><span class="mr bw bk ms mt"/></div><div class="ij ik il im in"><h1 id="b2fe" class="lr ls iq bd lt lu mv lw lx ly mw ma mb jw mx jx md jz my ka mf kc mz kd mh mi bi translated">设计API代理</h1><p id="1da4" class="pw-post-body-paragraph kv kw iq kx b ky mj jr la lb mk ju ld le ml lg lh li mm lk ll lm mn lo lp lq ij bi translated">在我们写代码之前，我将与你分享这个流程。我们将为BFF创建两个不同的端点。第一个只是处理登录操作。第二个将用于将所有请求转发给实际的API。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi na"><img src="../Images/3ba67239e1cdff5111e0b9f2e8cf804d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*IabxTTUntP3uO3lOuprr8A.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">登录流程</p></figure><p id="8c03" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">上面的流程说明了登录端点是如何工作的。事实上，我们可以在一个点上实现这一切。将所有逻辑保存在一个文件中是没有意义的。正因为如此，我已经将<a class="ae nb" href="https://en.wikipedia.org/wiki/Separation_of_concerns" rel="noopener ugc nofollow" target="_blank">的</a>登录逻辑分离到其他地方。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nc"><img src="../Images/14b63587c784e203a0915fba8bb0c34f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*8GeDxmENNsG6lbcfBsXmjw.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">认证后使用代理与BFF通信</p></figure><h1 id="bf84" class="lr ls iq bd lt lu lv lw lx ly lz ma mb jw mc jx md jz me ka mf kc mg kd mh mi bi translated">实现API代理</h1><p id="6ee2" class="pw-post-body-paragraph kv kw iq kx b ky mj jr la lb mk ju ld le ml lg lh li mm lk ll lm mn lo lp lq ij bi translated">在这一步中，我们将添加并启用API代理。我们必须创建一个代理服务器来将请求转发到目标资源。</p><h2 id="87a8" class="nd ls iq bd lt ne nf dn lx ng nh dp mb le ni nj md li nk nl mf lm nm nn mh no bi translated"><strong class="ak"> 0。设置环境变量</strong></h2><p id="9343" class="pw-post-body-paragraph kv kw iq kx b ky mj jr la lb mk ju ld le ml lg lh li mm lk ll lm mn lo lp lq ij bi translated">在开始之前，您必须定义一些环境变量。如果没有文件，在根目录下创建一个名为<code class="fe np nq nr ns b">.env</code>的文件。我们将从env变量中获取后端服务URL。</p><p id="bdaf" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">注意:<em class="nt">我们不应该用NEXT_PUBLIC_*作为env变量的前缀，以避免</em> <a class="ae nb" href="https://nextjs.org/docs/basic-features/environment-variables#exposing-environment-variables-to-the-browser" rel="noopener ugc nofollow" target="_blank"> <em class="nt">将其暴露给浏览器</em> </a> <em class="nt">。</em></p><pre class="kg kh ki kj gt nu ns nv nw aw nx bi"><span id="043f" class="nd ls iq ns b gy ny nz l oa ob">SERVICE_URL=http://localhost:8000/api</span></pre><h2 id="a400" class="nd ls iq bd lt ne nf dn lx ng nh dp mb le ni nj md li nk nl mf lm nm nn mh no bi translated"><strong class="ak"> 1。将http-proxy和cookies包作为依赖项安装</strong></h2><p id="ef49" class="pw-post-body-paragraph kv kw iq kx b ky mj jr la lb mk ju ld le ml lg lh li mm lk ll lm mn lo lp lq ij bi translated">我们需要<code class="fe np nq nr ns b">http-proxy</code>来创建一个代理服务器和cookie包来处理cookie。</p><pre class="kg kh ki kj gt nu ns nv nw aw nx bi"><span id="8862" class="nd ls iq ns b gy ny nz l oa ob">npm install http-proxy cookies</span></pre><h2 id="7520" class="nd ls iq bd lt ne nf dn lx ng nh dp mb le ni nj md li nk nl mf lm nm nn mh no bi translated"><strong class="ak"> 2。创建代理服务器</strong></h2><p id="c238" class="pw-post-body-paragraph kv kw iq kx b ky mj jr la lb mk ju ld le ml lg lh li mm lk ll lm mn lo lp lq ij bi translated">您必须创建一个代理服务器实例来使用API路由。首先，在根目录下创建一个名为<code class="fe np nq nr ns b">server</code>的文件夹。这个文件夹包含所有你的服务器类型的东西等等。为了以防万一，你可以在这个文件夹中设置你自己的定制服务器。</p><p id="dc44" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">创建服务器文件夹后。在<code class="fe np nq nr ns b">/server</code>目录下创建一个名为<code class="fe np nq nr ns b">proxy.js</code>的文件夹。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="oc od l"/></div></figure><h2 id="788e" class="nd ls iq bd lt ne nf dn lx ng nh dp mb le ni nj md li nk nl mf lm nm nn mh no bi translated"><strong class="ak"> 3。实现登录端点</strong></h2><p id="b680" class="pw-post-body-paragraph kv kw iq kx b ky mj jr la lb mk ju ld le ml lg lh li mm lk ll lm mn lo lp lq ij bi translated">您必须创建一个端点来处理登录操作。我假设您有一个认证服务来登录用户。为此，创建一个名为<code class="fe np nq nr ns b">api</code>的文件夹。此文件夹包含路由。</p><p id="28a4" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">完成这些步骤后。您必须在您的<code class="fe np nq nr ns b">api/auth</code>文件夹中创建一个名为<code class="fe np nq nr ns b">login.js</code>的路径文件。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="oc od l"/></div></figure><h2 id="7d91" class="nd ls iq bd lt ne nf dn lx ng nh dp mb le ni nj md li nk nl mf lm nm nn mh no bi translated"><strong class="ak"> 4。实现API代理</strong></h2><p id="7b35" class="pw-post-body-paragraph kv kw iq kx b ky mj jr la lb mk ju ld le ml lg lh li mm lk ll lm mn lo lp lq ij bi translated">我们需要一个入口点来将请求转发到目标资源。为此，我们将在已经创建的<code class="fe np nq nr ns b">api</code>文件夹下创建一个名为<code class="fe np nq nr ns b">[..path].js</code>的文件。这条路由将处理所有跟在<code class="fe np nq nr ns b">/api</code>前缀后面的端点。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="oc od l"/></div></figure></div><div class="ab cl mo mp hu mq" role="separator"><span class="mr bw bk ms mt mu"/><span class="mr bw bk ms mt mu"/><span class="mr bw bk ms mt"/></div><div class="ij ik il im in"><p id="c2b8" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">就是这样。您已经准备好使用您的代理服务器。事实上，您可以给这个实现添加一些特性。我还添加了一个注销API路由。我准备了一个演示。可以从Github查看。</p><ul class=""><li id="0b3b" class="oe of iq kx b ky kz lb lc le og li oh lm oi lq oj ok ol om bi translated"><a class="ae nb" href="https://github.com/fdemir/next-proxy" rel="noopener ugc nofollow" target="_blank">Github上的演示项目</a></li></ul><h1 id="fabc" class="lr ls iq bd lt lu lv lw lx ly lz ma mb jw mc jx md jz me ka mf kc mg kd mh mi bi translated">警告</h1><p id="6081" class="pw-post-body-paragraph kv kw iq kx b ky mj jr la lb mk ju ld le ml lg lh li mm lk ll lm mn lo lp lq ij bi translated">这个特性实际上伴随着所有的缺点和优点。因为我们用代理和BFF交流。这导致TTFB时间增加。此外，代理服务器的设置和维护成本也很高。</p></div><div class="ab cl mo mp hu mq" role="separator"><span class="mr bw bk ms mt mu"/><span class="mr bw bk ms mt mu"/><span class="mr bw bk ms mt"/></div><div class="ij ik il im in"><p id="4a99" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">感谢您阅读本文。</p></div></div>    
</body>
</html>