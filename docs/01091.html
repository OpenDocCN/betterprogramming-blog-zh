<html>
<head>
<title>KEDA Up Close: Kubernetes-based, Event-Driven Autoscaling</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">KEDA特写:基于Kubernetes的事件驱动自动缩放</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/keda-kubernetes-up-close-f47cdf43920b?source=collection_archive---------7-----------------------#2019-08-13">https://betterprogramming.pub/keda-kubernetes-up-close-f47cdf43920b?source=collection_archive---------7-----------------------#2019-08-13</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><p id="1d8f" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">距离上次微软Build 2019大会已经有一段时间了。从那时起，吸引我们注意力的新闻是基于Kubernetes的事件驱动自动缩放(KEDA)的发布。我们想更深入地了解一下这个解决方案。</p></div><div class="ab cl ko kp hx kq" role="separator"><span class="kr bw bk ks kt ku"/><span class="kr bw bk ks kt ku"/><span class="kr bw bk ks kt"/></div><div class="im in io ip iq"><h1 id="8a97" class="kv kw it bd kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls bi translated"><strong class="ak">什么是KEDA？</strong></h1><p id="5714" class="pw-post-body-paragraph jq jr it js b jt lt jv jw jx lu jz ka kb lv kd ke kf lw kh ki kj lx kl km kn im bi translated">KEDA是红帽和微软工程团队合作的结果。它通常被定义为一个开源组件，我们可以将其安装在Kubernetes集群中，以实现基于事件的容器伸缩。它扩展了Kubernetes的功能，利用CPU指标和内存来扩展容器。由于该项目仍在开发中，你可以在GitHub 上跟踪其进展<a class="ae ly" href="https://github.com/kedacore/keda" rel="noopener ugc nofollow" target="_blank">。</a></p><p id="9c6a" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">KEDA包括一组特殊的适配器(连接到数据源以获取指标的组件)。这些指标进一步用于确定是否以及如何扩展环境。目前，有七个这样的连接器:RabbitMQ、Redis DB、Azure Service Bus、Azure IoT Hub和Cosmos DB。</p><p id="9554" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">正如我们所见，KEDA允许Kubernetes集群成为事件驱动架构的有效基础设施，而无需基于事件队列创建其扩展组件。</p><figure class="ma mb mc md gt me gh gi paragraph-image"><div role="button" tabindex="0" class="mf mg di mh bf mi"><div class="gh gi lz"><img src="../Images/5736847f5b20b8956e1fca8c5997ad0e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*DiLtbu4iaB3tzuF3J9R_oQ.png"/></div></div><p class="ml mm gj gh gi mn mo bd b be z dk translated"><em class="mp"> KEDA图由其创建者开发，可在GitHub上获得</em></p></figure></div><div class="ab cl ko kp hx kq" role="separator"><span class="kr bw bk ks kt ku"/><span class="kr bw bk ks kt ku"/><span class="kr bw bk ks kt"/></div><div class="im in io ip iq"><h1 id="38b9" class="kv kw it bd kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls bi translated"><strong class="ak"> KEDA建筑</strong></h1><p id="ca02" class="pw-post-body-paragraph jq jr it js b jt lt jv jw jx lu jz ka kb lv kd ke kf lw kh ki kj lx kl km kn im bi translated">根据上图，KEDA为每个集群提供了三个基本要素:</p><ul class=""><li id="cf8a" class="mq mr it js b jt ju jx jy kb ms kf mt kj mu kn mv mw mx my bi translated"><strong class="js iu"> Scaler </strong> —连接到所选源(例如RabbitMQ)并读取其指标(队列大小)的组件</li><li id="4ee0" class="mq mr it js b jt mz jx na kb nb kf nc kj nd kn mv mw mx my bi translated"><strong class="js iu">指标适配器</strong> —将缩放器读取的指标转发给水平Pod自动缩放器(HPA)以启用水平app自动缩放的元素</li><li id="7683" class="mq mr it js b jt mz jx na kb nb kf nc kj nd kn mv mw mx my bi translated"><strong class="js iu">控制器</strong> —为容器的消费者提供从0到1(或从1到0)的缩放的最后一个，也可能是最重要的元素。为什么只有1和0？因为整个解决方案旨在扩展Kubernetes的功能，而不是从头开始提供任何功能。控制器扩展到第一个实例，HPA使用指标适配器转发的指标执行进一步的克隆。控制器还负责持续监控是否出现新的<code class="fe ne nf ng nh b">ScaledObject </code>部署。</li></ul></div><div class="ab cl ko kp hx kq" role="separator"><span class="kr bw bk ks kt ku"/><span class="kr bw bk ks kt ku"/><span class="kr bw bk ks kt"/></div><div class="im in io ip iq"><h1 id="7d69" class="kv kw it bd kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls bi translated"><strong class="ak">如何创建ScaledObject部署</strong></h1><p id="8b11" class="pw-post-body-paragraph jq jr it js b jt lt jv jw jx lu jz ka kb lv kd ke kf lw kh ki kj lx kl km kn im bi translated">要在我们的容器中使用KEDA，我们首先必须创建一个<code class="fe ne nf ng nh b">ScaledObject </code>部署。例如，在YAML中，我们可以指定缩放规则并选择要复制的容器。</p><p id="ef03" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">这里有一个例子:</p><pre class="ma mb mc md gt ni nh nj nk aw nl bi"><span id="5eb9" class="nm kw it nh b gy nn no l np nq">apiVersion: keda.k8s.io/v1alpha1</span><span id="6258" class="nm kw it nh b gy nr no l np nq">kind: ScaledObject</span><span id="4ceb" class="nm kw it nh b gy nr no l np nq">metadata:</span><span id="3057" class="nm kw it nh b gy nr no l np nq">  name: keda-service-bus-function</span><span id="f247" class="nm kw it nh b gy nr no l np nq">  labels:</span><span id="5674" class="nm kw it nh b gy nr no l np nq">    deploymentName: keda-service-bus-function</span><span id="5415" class="nm kw it nh b gy nr no l np nq">spec:</span><span id="e4cf" class="nm kw it nh b gy nr no l np nq">  scaleTargetRef:</span><span id="40be" class="nm kw it nh b gy nr no l np nq">    deploymentName: keda-service-bus-function</span><span id="e13c" class="nm kw it nh b gy nr no l np nq">    containerName: azure-functions-container</span><span id="3bf3" class="nm kw it nh b gy nr no l np nq">  pollingInterval: 30</span><span id="9af5" class="nm kw it nh b gy nr no l np nq">  cooldownPeriod: 300</span><span id="0709" class="nm kw it nh b gy nr no l np nq">  minReplicaCount: 1</span><span id="a281" class="nm kw it nh b gy nr no l np nq">  maxReplicaCount: 500</span><span id="8291" class="nm kw it nh b gy nr no l np nq">triggers:</span><span id="a1b9" class="nm kw it nh b gy nr no l np nq">  type: azure-servicebus</span><span id="e0d7" class="nm kw it nh b gy nr no l np nq">  metadata:</span><span id="653f" class="nm kw it nh b gy nr no l np nq">    queueName: my-queue</span><span id="d3b1" class="nm kw it nh b gy nr no l np nq">    connection: SB_CONN_STRING</span><span id="c81a" class="nm kw it nh b gy nr no l np nq">    queueLength: ‘10’</span></pre><p id="9942" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">对于创建具有有效扩展机制的环境来说,<code class="fe ne nf ng nh b">ScaledObject</code>配置知识是必不可少的。比如设置为<code class="fe ne nf ng nh b">‘1’</code>的时候看一下<code class="fe ne nf ng nh b"><em class="ns">minReplicaCount</em>;</code>；它会保护我们免受冷启动。</p></div><div class="ab cl ko kp hx kq" role="separator"><span class="kr bw bk ks kt ku"/><span class="kr bw bk ks kt ku"/><span class="kr bw bk ks kt"/></div><div class="im in io ip iq"><h1 id="9224" class="kv kw it bd kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls bi translated"><strong class="ak"> KEDA — Azure功能集成</strong></h1><p id="c312" class="pw-post-body-paragraph jq jr it js b jt lt jv jw jx lu jz ka kb lv kd ke kf lw kh ki kj lx kl km kn im bi translated">您可能想知道如何在您的架构中利用KEDA。微软Azure的KEDA的基本应用是将Azure功能迁移到Kubernetes。</p><p id="a05d" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">是的，这在以前确实是可能的。我们已经可以在Docker容器中运行Azure函数，然后在Kubernetes中运行。KEDA没有带来任何新的东西。</p><p id="a6d3" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">然而，到目前为止，我们完全负责创建一个合适的orchestrator来扩展我们函数的实例。现在，KEDA作为我们的规模控制者正在为我们做这件事。</p></div><div class="ab cl ko kp hx kq" role="separator"><span class="kr bw bk ks kt ku"/><span class="kr bw bk ks kt ku"/><span class="kr bw bk ks kt"/></div><div class="im in io ip iq"><h1 id="78f3" class="kv kw it bd kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls bi translated"><strong class="ak"> KEDA和Azure功能核心工具</strong></h1><p id="c673" class="pw-post-body-paragraph jq jr it js b jt lt jv jw jx lu jz ka kb lv kd ke kf lw kh ki kj lx kl km kn im bi translated">当KEDA第一次出现时，微软紧接着修改了它的Azure Functions核心工具。Azure Functions与KEDA的集成特别适用于这些获得额外代码行的工具:</p><pre class="ma mb mc md gt ni nh nj nk aw nl bi"><span id="fa1c" class="nm kw it nh b gy nn no l np nq">func kubernetes</span></pre><p id="59ca" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">让我们看看如何使用它。</p><h2 id="b308" class="nm kw it bd kx nt nu dn lb nv nw dp lf kb nx ny lj kf nz oa ln kj ob oc lr od bi translated"><strong class="ak"> KEDA在练习</strong></h2><p id="119c" class="pw-post-body-paragraph jq jr it js b jt lt jv jw jx lu jz ka kb lv kd ke kf lw kh ki kj lx kl km kn im bi translated">我们将进行一个快速演示，其中我们将创建一个Azure函数，该函数应该由KEDA在我们的集群中进行扩展。</p><p id="3657" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">1.先从强制工具和组件说起。</p><ul class=""><li id="5f58" class="mq mr it js b jt ju jx jy kb ms kf mt kj mu kn mv mw mx my bi translated">Azure Functions核心工具(最低版本2.7)——此处<a class="ae ly" href="https://docs.microsoft.com/pl-pl/azure/azure-functions/functions-run-local#windows-npm" rel="noopener ugc nofollow" target="_blank">可用</a></li><li id="84fc" class="mq mr it js b jt mz jx na kb nb kf nc kj nd kn mv mw mx my bi translated">Visual Studio代码(带有Azure函数)</li><li id="eaf9" class="mq mr it js b jt mz jx na kb nb kf nc kj nd kn mv mw mx my bi translated">Kubectl <strong class="js iu"> </strong>连接到我们的集群</li><li id="9534" class="mq mr it js b jt mz jx na kb nb kf nc kj nd kn mv mw mx my bi translated">码头工人</li></ul><p id="6fec" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">我在Azure (AKS)中配置了我的集群，并创建了以下服务:</p><ul class=""><li id="63ba" class="mq mr it js b jt ju jx jy kb ms kf mt kj mu kn mv mw mx my bi translated">Azure服务总线(带队列)</li><li id="30ba" class="mq mr it js b jt mz jx na kb nb kf nc kj nd kn mv mw mx my bi translated">Azure存储帐户(用于我们的功能)</li><li id="2a83" class="mq mr it js b jt mz jx na kb nb kf nc kj nd kn mv mw mx my bi translated">Azure Container Registry(这里是我们的函数Docker image在Kubernetes中运行之前出现的地方)</li></ul><p id="b0d5" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">2.接下来，我们转到Visual Studio代码并创建一个新函数，使用我之前提到的扩展:<a class="ae ly" href="https://code.visualstudio.com/tutorials/functions-extension/create-function%20" rel="noopener ugc nofollow" target="_blank">https://Code . Visual Studio . com/tutorials/functions-extension/create-function</a></p><figure class="ma mb mc md gt me gh gi paragraph-image"><div role="button" tabindex="0" class="mf mg di mh bf mi"><div class="gh gi oe"><img src="../Images/2bfc26d63afa89f47439406265afe90c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*IJROC_jkv4p_eCA9lN8n1Q.png"/></div></div><p class="ml mm gj gh gi mn mo bd b be z dk translated"><em class="mp">新KEDA功能</em></p></figure><p id="bf69" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">请注意，在第19行，我暂停了线程执行30秒。我这样做只是为了更明确地证明这种缩放方法是可行的。</p><p id="33b4" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">3.我们继续吧。在<em class="ns"> </em> <code class="fe ne nf ng nh b">local.settings.json</code>中，我们应该为两种设置提供配置:</p><ul class=""><li id="1e71" class="mq mr it js b jt ju jx jy kb ms kf mt kj mu kn mv mw mx my bi translated"><code class="fe ne nf ng nh b">AzureWebJobStorage</code> <strong class="js iu"> </strong> —这里，我们陈述了之前创建的Azure存储的连接字符串的值</li><li id="52cd" class="mq mr it js b jt mz jx na kb nb kf nc kj nd kn mv mw mx my bi translated">这是我们服务总线的连接字符串</li></ul><pre class="ma mb mc md gt ni nh nj nk aw nl bi"><span id="cfbe" class="nm kw it nh b gy nn no l np nq">  “IsEncrypted”: false,</span><span id="2385" class="nm kw it nh b gy nr no l np nq">  “Values”: {</span><span id="6b17" class="nm kw it nh b gy nr no l np nq">    “AzureWebJobsStorage”: “DefaultEndpointsProtocol=……”,</span><span id="689b" class="nm kw it nh b gy nr no l np nq">    “FUNCTIONS_WORKER_RUNTIME”: “dotnet”,</span><span id="d9bd" class="nm kw it nh b gy nr no l np nq">    “keda-test_SERVICEBUS”: “Endpoint=sb://…..</span><span id="5d31" class="nm kw it nh b gy nr no l np nq">    }</span><span id="180f" class="nm kw it nh b gy nr no l np nq">}</span></pre><h2 id="98ba" class="nm kw it bd kx nt nu dn lb nv nw dp lf kb nx ny lj kf nz oa ln kj ob oc lr od bi translated"><strong class="ak">集群中的KEDA安装</strong></h2><p id="cc68" class="pw-post-body-paragraph jq jr it js b jt lt jv jw jx lu jz ka kb lv kd ke kf lw kh ki kj lx kl km kn im bi translated">4.现在，我们将重点关注集群中的KEDA安装。这里，我们将使用我前面提到的集成。从终端级别留给我们的唯一事情是调用以下请求:</p><pre class="ma mb mc md gt ni nh nj nk aw nl bi"><span id="1714" class="nm kw it nh b gy nn no l np nq">func kubernetes install — namespace keda-test</span></pre><p id="2020" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">在KEDA的GitHub上，你还会发现其他的安装方式(比如Helm)。然而，我们对Azure功能核心工具感兴趣。</p><p id="e89d" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">让我们来看看我们环境中的新特性:</p><figure class="ma mb mc md gt me gh gi paragraph-image"><div role="button" tabindex="0" class="mf mg di mh bf mi"><div class="gh gi oe"><img src="../Images/287f43acc2cf7db19bd5b7543852f1f5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*1u-7ZyQ8hjLoC38piCtwfQ.png"/></div></div><p class="ml mm gj gh gi mn mo bd b be z dk translated">KEDA装置</p></figure><p id="0756" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">你可以立即在这里发现一个新元素。除了KEDA，我们还安装了奥西里斯。</p><p id="dced" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">它是一个独立的组件，负责扩展用<code class="fe ne nf ng nh b">HTTP</code>请求调用的函数。KEDA对除<code class="fe ne nf ng nh b">HTTP</code>以外的所有其余请求做出答复。</p><p id="451d" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">5.下一步，我们必须准备在容器中工作的函数。同样，对于KEDA来说，这是一个微不足道的任务，简化为一行代码:</p><pre class="ma mb mc md gt ni nh nj nk aw nl bi"><span id="b239" class="nm kw it nh b gy nn no l np nq">func init –docker</span></pre><p id="52c7" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">因此，项目中会出现一个新的Dockerfile文件。</p><p id="7c23" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">6.现在，我建议您编译整个项目，并在Visual Studio代码中分析错误列表窗口。如果没有错误，我们可以进入最后一个阶段:运行我们的函数。</p><p id="95a4" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">7.要部署该功能，请运行以下命令:</p><pre class="ma mb mc md gt ni nh nj nk aw nl bi"><span id="6247" class="nm kw it nh b gy nn no l np nq">func kubernetes deploy \</span><span id="8a7c" class="nm kw it nh b gy nr no l np nq">    --name keda-service-bus-function \</span><span id="de07" class="nm kw it nh b gy nr no l np nq">    --namespace keda-test \</span><span id="381a" class="nm kw it nh b gy nr no l np nq">    --registry kedatest.azurecr.io/keda-service-bus-function</span><span id="44f6" class="nm kw it nh b gy nr no l np nq">    --pull-secret regcred</span></pre><p id="20f7" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">我们来分析一下它的参数:</p><ul class=""><li id="9192" class="mq mr it js b jt ju jx jy kb ms kf mt kj mu kn mv mw mx my bi translated"><code class="fe ne nf ng nh b">name</code> —我们功能的名称</li><li id="a087" class="mq mr it js b jt mz jx na kb nb kf nc kj nd kn mv mw mx my bi translated"><code class="fe ne nf ng nh b">namespace</code> —我们函数的名称空间</li><li id="9585" class="mq mr it js b jt mz jx na kb nb kf nc kj nd kn mv mw mx my bi translated"><code class="fe ne nf ng nh b">registry </code> —存储函数的图像的地址/名称(我使用的是Azure容器注册表)</li><li id="7a50" class="mq mr it js b jt mz jx na kb nb kf nc kj nd kn mv mw mx my bi translated"><code class="fe ne nf ng nh b">pull-secret<strong class="js iu"> </strong></code> —我定义的秘密，允许我们的集群从存储库中下载图像。点击<a class="ae ly" href="https://kubernetes.io/docs/tasks/configure-pod-container/pull-image-private-registry/#create-a-secret-by-providing-credentials-on-the-command-line" rel="noopener ugc nofollow" target="_blank">这里</a>了解如何定义它。</li></ul><p id="29a8" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">记住，在执行这个命令之前，您必须登录到<a class="ae ly" href="https://docs.docker.com/engine/reference/commandline/login/" rel="noopener ugc nofollow" target="_blank">远程Docker注册表的终端</a>。</p><h2 id="5c0d" class="nm kw it bd kx nt nu dn lb nv nw dp lf kb nx ny lj kf nz oa ln kj ob oc lr od bi translated"><strong class="ak">集群中的KEDA配置</strong></h2><p id="2367" class="pw-post-body-paragraph jq jr it js b jt lt jv jw jx lu jz ka kb lv kd ke kf lw kh ki kj lx kl km kn im bi translated">让我们看看集群中的KEDA配置是否正确。</p><p id="a0aa" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">我的函数有一个触发队列— <code class="fe ne nf ng nh b">service-bus</code>。因此，我必须使用一种在我的队列中生成消息的机制。在这里，我可以建议以下三种解决方案中的一种(我选择了最后一种):</p><ul class=""><li id="66a2" class="mq mr it js b jt ju jx jy kb ms kf mt kj mu kn mv mw mx my bi translated">在门户中创建Azure功能</li><li id="677f" class="mq mr it js b jt mz jx na kb nb kf nc kj nd kn mv mw mx my bi translated">中为服务总线队列编写一个简单的消息生成器。使用Visual Studio代码或Visual Studio . NET项目</li><li id="f9eb" class="mq mr it js b jt mz jx na kb nb kf nc kj nd kn mv mw mx my bi translated">使用服务总线浏览器(<a class="ae ly" href="https://github.com/paolosalvatori/ServiceBusExplorer" rel="noopener ugc nofollow" target="_blank">https://github.com/paolosalvatori/ServiceBusExplorer</a>)</li></ul><p id="dfca" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">在我的例子中，我想尽可能快地测试解决方案，所以我使用了一个现成的应用程序，只需要安装并连接到服务总线。</p><p id="006a" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">当我将消息添加到队列中时，我运行了几次以下命令:</p><pre class="ma mb mc md gt ni nh nj nk aw nl bi"><span id="59f6" class="nm kw it nh b gy nn no l np nq">kubectl get pods — namespace keda-test | grep ‘keda-service-bus-function’</span></pre><p id="4d22" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">正如你在下图中看到的，我们的解决方案非常有效。该函数首先由KEDA缩放(从0到1)，然后HPA负责进一步的POD缩放。</p><figure class="ma mb mc md gt me gh gi paragraph-image"><div role="button" tabindex="0" class="mf mg di mh bf mi"><div class="gh gi oe"><img src="../Images/53cbdeefd6aeb464b0aac0646f7f3ff6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*zXjiP5B_DuOhbG-pvi0pKA.png"/></div></div></figure></div><div class="ab cl ko kp hx kq" role="separator"><span class="kr bw bk ks kt ku"/><span class="kr bw bk ks kt ku"/><span class="kr bw bk ks kt"/></div><div class="im in io ip iq"><h1 id="44b3" class="kv kw it bd kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls bi translated"><strong class="ak"> KEDA总结</strong></h1><p id="abe5" class="pw-post-body-paragraph jq jr it js b jt lt jv jw jx lu jz ka kb lv kd ke kf lw kh ki kj lx kl km kn im bi translated">KEDA目前处于早期开发阶段，不应该在生产中部署。尽管如此，我还是建议关注这个项目，了解它是如何工作的，尤其是基于事件的架构在Azure中非常流行。</p><p id="82eb" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">如果您使用AKS，还需要记住虚拟节点功能。它将允许您将功能扩展到Azure容器实例，以扩展整个基础架构的功能。</p><p id="1bea" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">毫无疑问，KEDA的少量定标器使得它的使用目前非常有限。然而，正在开展工作以增加对CosmosDB和Azure IoT Hub等的支持，这将大大增加该项目的应用数量。</p></div></div>    
</body>
</html>