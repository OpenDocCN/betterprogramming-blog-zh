<html>
<head>
<title>Sharing a Cached Layer Between Docker and Docker Compose Builds</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">在Docker和Docker Compose构建之间共享缓存层</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/sharing-cached-layer-between-docker-and-docker-compose-builds-c2e5f751cee4?source=collection_archive---------7-----------------------#2020-10-13">https://betterprogramming.pub/sharing-cached-layer-between-docker-and-docker-compose-builds-c2e5f751cee4?source=collection_archive---------7-----------------------#2020-10-13</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="9132" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">改进您的Docker缓存</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/8887e2c4e0487279c6a34ac7c03bf441.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*UwymbgyHoQ8xP1Gy"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">Marc-Olivier Jodoin 在<a class="ae kv" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</p></figure><p id="302c" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">本文是我们探索Docker缓存的第二部分——如果您还没有看过的话，请阅读第一部分,其中我们介绍了Docker层和缓存机制。现在让我们看看Docker Compose，以及同时使用Docker和Docker Compose时的一些挑战。</p></div><div class="ab cl ls lt hu lu" role="separator"><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx"/></div><div class="ij ik il im in"><h1 id="eea2" class="lz ma iq bd mb mc md me mf mg mh mi mj jw mk jx ml jz mm ka mn kc mo kd mp mq bi translated">Docker Compose是一个很棒的开发工具</h1><p id="5822" class="pw-post-body-paragraph kw kx iq ky b kz mr jr lb lc ms ju le lf mt lh li lj mu ll lm ln mv lp lq lr ij bi translated">我们使用<code class="fe mw mx my mz b">docker build</code>和<code class="fe mw mx my mz b">docker run</code>命令在本地从Docker映像构建/运行我们的应用程序。如果我们有一个包含多个组件的项目(例如，一个客户端和一个服务器)，构建和运行每个组件会很快变得繁琐和低效。幸运的是，有Docker Compose——一个为运行多容器应用程序而设计的CLI工具。</p><p id="9ad6" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">Docker Compose完全独立于Docker，但在内部使用Docker引擎来协调多个容器的构建和运行。Docker Compose的概述和安装说明可以在<a class="ae kv" href="https://docs.docker.com/compose/" rel="noopener ugc nofollow" target="_blank">官方网站</a>找到。</p><p id="b3b5" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">虽然每个组件仍然有自己的Dockerfile来描述应该如何构建映像，但是我们现在也有了一个<code class="fe mw mx my mz b">docker-compose.yml</code>文件——所有需要一起运行的容器及其运行时属性的YAML描述符。</p><p id="3745" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><strong class="ky ir">注意:</strong>你可以在这里获得关于如何在开发过程中使用Docker Compose的更深入的细节<a class="ae kv" href="https://medium.com/tsftech/how-to-fully-utilise-docker-compose-during-development-4b723caed798" rel="noopener">。</a></p><p id="c80e" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">让我们来看看<code class="fe mw mx my mz b">docker-compose.yml</code>如何看待我们的例子(这相当简单，因为我们只有一个组件):</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="na nb l"/></div></figure><p id="9ecf" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们只需定义一个名为<code class="fe mw mx my mz b">hello-world-react-docker</code>的服务，将构建上下文设置为包含Dockerfile的目录，并公开相关端口——就像我们在使用<code class="fe mw mx my mz b">docker run</code>启动容器时所做的那样</p><p id="ecb9" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><strong class="ky ir">注意:</strong> <code class="fe mw mx my mz b">stdin_open: true</code>是react-scripts 3.4.1在编写时对<a class="ae kv" href="https://github.com/facebook/create-react-app/issues/8688" rel="noopener ugc nofollow" target="_blank">开放bug </a>的一种变通方法，其中react的<code class="fe mw mx my mz b">npm start</code>命令在开发服务器启动后立即退出，状态代码为<code class="fe mw mx my mz b">0</code>。</p><p id="f02f" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">现在，运行<code class="fe mw mx my mz b">docker-compose up</code>将构建相关的图像并启动它们，因此在浏览器中，您将再次看到熟悉的React主页。万岁，我们正在使用Docker Compose从Docker映像运行React应用程序！</p></div><div class="ab cl ls lt hu lu" role="separator"><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx"/></div><div class="ij ik il im in"><h1 id="7802" class="lz ma iq bd mb mc md me mf mg mh mi mj jw mk jx ml jz mm ka mn kc mo kd mp mq bi translated">问题:Docker和Docker合成版本之间的缓存共享</h1><p id="c3b1" class="pw-post-body-paragraph kw kx iq ky b kz mr jr lb lc ms ju le lf mt lh li lj mu ll lm ln mv lp lq lr ij bi translated">因此，我们有一个示例应用程序——我们可以将其打包为Docker映像，并在任何地方运行。我们可以使用标准的Docker命令(<code class="fe mw mx my mz b">build</code>和<code class="fe mw mx my mz b">run</code>)或者使用对开发人员更友好的<code class="fe mw mx my mz b">docker-compose</code>来本地构建和测试我们的应用程序。</p><p id="e7fd" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">然而，您可能已经注意到了一个小问题——尽管我们已经首先使用<code class="fe mw mx my mz b">docker build</code>命令构建了一个Docker映像(并且缓存了所有相关的层),但是使用<code class="fe mw mx my mz b">docker-compose</code>构建会导致整个映像的重建(因此我们必须等待<code class="fe mw mx my mz b">npm install</code>完成几分钟)。当我们使用Docker Compose运行后续构建时，缓存的表现与预期一样，构建周期很快。</p><p id="75c6" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">看看下面的输出——虽然之前已经用Docker构建了映像，但用Docker Compose构建并不使用缓存层，而是重建一切(正如我们所看到的，慢速的<code class="fe mw mx my mz b">npm install</code>命令一直在运行)。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nc"><img src="../Images/36a3bd4af15dc88a3c75185f695c80a0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*NRjWlBaWlxqzXsr0"/></div></div></figure><p id="81eb" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">因此，Docker和Docker Compose像预期的那样单独工作，重用以前构建中缓存的层。但是当使用这两种工具并在它们之间切换时，缓存似乎不起作用</p><p id="4c3c" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">为什么这是一个问题？好吧，让我们假设你有一个包含许多容器化组件的项目，所有这些都需要一些时间来从头构建。您正在处理单个组件，但是团队中的其他开发人员不断地将更改推给其他人。每个提交都构建在CI服务器上，因此您可以下载它。</p><p id="d9fe" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这是为什么呢？</p><p id="8f36" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">好吧，原因隐藏在Docker Compose代码库中。Docker Compose使用Docker Python客户端库与Docker引擎进行交互，而Docker命令本身就可以做到这一点，不同的实现会导致使用任一工具构建的图像具有不同的图像id，这会对缓存层产生上述影响。</p><p id="44fb" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在Docker和Docker Compose项目的几个标签中报告并讨论了该问题:</p><ul class=""><li id="1443" class="nd ne iq ky b kz la lc ld lf nf lj ng ln nh lr ni nj nk nl bi translated"><a class="ae kv" href="https://github.com/docker/compose/issues/5873" rel="noopener ugc nofollow" target="_blank">https://github.com/docker/compose/issues/5873</a></li><li id="a348" class="nd ne iq ky b kz nm lc nn lf no lj np ln nq lr ni nj nk nl bi translated"><a class="ae kv" href="https://github.com/docker/compose/issues/883" rel="noopener ugc nofollow" target="_blank">https://github.com/docker/compose/issues/883</a></li></ul></div><div class="ab cl ls lt hu lu" role="separator"><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx"/></div><div class="ij ik il im in"><h1 id="14ed" class="lz ma iq bd mb mc md me mf mg mh mi mj jw mk jx ml jz mm ka mn kc mo kd mp mq bi translated">解决方案:输入BuildKit</h1><p id="a26f" class="pw-post-body-paragraph kw kx iq ky b kz mr jr lb lc ms ju le lf mt lh li lj mu ll lm ln mv lp lq lr ij bi translated">虽然对于如何为当前的Docker引擎版本解决这个问题还没有达成一致，但有一个简单的解决方案，使用仍然处于实验阶段(但很快成为主流)<a class="ae kv" href="https://docs.docker.com/develop/develop-images/build_enhancements/" rel="noopener ugc nofollow" target="_blank"> BuildKit </a> Docker引擎。</p><p id="81ee" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">BuildKit带来了期待已久的新架构和Docker引擎的重构，这应该会带来性能、存储管理和安全性方面的许多改进，包括增加Docker和Docker Compose映像构建之间的缓存一致性。</p><p id="e5c6" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们希望BuildKit在Docker的下一个版本中成为默认的，但是现在，虽然它仍然是试验性的，但它可以通过简单地设置<code class="fe mw mx my mz b">DOCKER_BUILDKIT=1</code>环境变量来启用。</p><p id="e22d" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><strong class="ky ir">注意:</strong>在撰写本文时，BuildKit只适用于Linux容器。</p><p id="1a6d" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">让我们使用<code class="fe mw mx my mz b">docker build</code>命令重新构建我们的应用程序:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nr"><img src="../Images/ee5da107945a02de7fd940c757c9bc50.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*ENN8Vi6La0GRTSsO"/></div></div></figure><p id="2225" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">您将看到一个更简单的构建过程的内联输出，这是BuildKit的特征，以及每一层的计时——和以前一样，<code class="fe mw mx my mz b">npm install</code>命令花费了最多的时间。您会注意到整个图像都是从头开始构建的——build kit具有不同的层存储策略，因此使用传统引擎构建的层不能作为缓存重用。</p><p id="b540" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">重复该命令将大大加快构建速度，因为所有图层都将被缓存并重复使用，而无需重新构建。您可以在下面的代码片段中看到使用层缓存的构建步骤前面的<code class="fe mw mx my mz b">CACHED</code>输出:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nr"><img src="../Images/272d904e9767b8a5a5758dad1b356a48.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*pbdquHdHQETQ9TDM"/></div></div></figure><p id="7978" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">Docker Compose怎么样？之前，我们已经看到Docker Compose没有重用使用<code class="fe mw mx my mz b">docker build</code>命令构建的缓存层——让我们看看这是如何改变的。</p><p id="2cd3" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">要启用Docker Compose的BuildKit，需要一个额外的环境变量<code class="fe mw mx my mz b">COMPOSE_DOCKER_CLI_BUILD=1</code>。让我们使用Docker Compose重新构建应用程序:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nr"><img src="../Images/48011af7a287bb0d504c3bf2ddccd11a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*jL4Ht8CQSh5pzD7i"/></div></div></figure><p id="7163" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">呜-呼！构建速度非常快，因为所有层都被重用了，尽管这是第一个Docker构建的图像。使用<code class="fe mw mx my mz b">docker build</code>命令构建的层已经从缓存中重用，如上面输出中的<code class="fe mw mx my mz b">CACHE</code>标签所示。</p><p id="374b" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在本文中，我试图阐明Docker缓存以及在开发过程中使用Docker和Docker Compose工具的相关问题。请记住，无论您使用什么引擎或工具，关键是要构建您的docker文件描述符，以便它们能够感知层缓存—确保通过使用多个<code class="fe mw mx my mz b">COPY</code>、<code class="fe mw mx my mz b">ADD</code>和<code class="fe mw mx my mz b">RUN</code>命令，根据引用组件的生命周期，将最频繁更改的文件或命令复制/运行到docker文件的底部！</p></div></div>    
</body>
</html>