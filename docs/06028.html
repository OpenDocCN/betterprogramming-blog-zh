<html>
<head>
<title>Implement User Authentication With Next.js and Firebase</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">用Next.js和Firebase实现用户认证</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/implement-user-authentication-with-next-js-and-firebase-fb9414adba08?source=collection_archive---------0-----------------------#2020-08-27">https://betterprogramming.pub/implement-user-authentication-with-next-js-and-firebase-fb9414adba08?source=collection_archive---------0-----------------------#2020-08-27</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="8692" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">Auth不一定很难或者很耗时</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/c0c200480c16522961be57e71184a55a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*eYnazDZPQQyWh4ED"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">里卡多·戈麦斯·安吉尔在<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的照片</p></figure><p id="eaaf" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">构建您自己的身份验证系统可能是一项困难且耗时的任务。使用现有平台来处理您的身份验证流程将为您节省大量时间，甚至不需要花费您任何金钱。Firebase是最受欢迎的平台之一，可以为您处理身份验证，它的免费计划允许任何开发人员轻松快速地构建安全的身份验证系统。它帮助您快速构建应用程序，而无需管理基础架构。在本教程中，我们将使用这个平台来快速实现我们自己的认证流程。我们将使用Next.js、Typescript和TailwindCSS来实现这一点。</p><p id="f3b3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">要跟进，你应该有一个现有的项目。您可以遵循以下关于更好编程的其他教程来设置您的项目:</p><div class="lv lw gp gr lx ly"><a href="https://medium.com/better-programming/how-to-set-up-next-js-with-typescript-5f912766c88" rel="noopener follow" target="_blank"><div class="lz ab fo"><div class="ma ab mb cl cj mc"><h2 class="bd iu gy z fp md fr fs me fu fw is bi translated">如何用TypeScript设置Next.js</h2><div class="mf l"><h3 class="bd b gy z fp md fr fs me fu fw dk translated">使用Next.js和TypeScript启动新的React项目</h3></div><div class="mg l"><p class="bd b dl z fp md fr fs me fu fw dk translated">medium.com</p></div></div><div class="mh l"><div class="mi l mj mk ml mh mm ks ly"/></div></div></a></div><div class="lv lw gp gr lx ly"><a href="https://medium.com/better-programming/how-to-set-up-next-js-with-tailwind-css-b93ccd2d4164" rel="noopener follow" target="_blank"><div class="lz ab fo"><div class="ma ab mb cl cj mc"><h2 class="bd iu gy z fp md fr fs me fu fw is bi translated">如何用Tailwind CSS设置Next.js</h2><div class="mf l"><h3 class="bd b gy z fp md fr fs me fu fw dk translated">在React项目中使用Tailwind CSS和Next.js</h3></div><div class="mg l"><p class="bd b dl z fp md fr fs me fu fw dk translated">medium.com</p></div></div><div class="mh l"><div class="mn l mj mk ml mh mm ks ly"/></div></div></a></div><div class="lv lw gp gr lx ly"><a href="https://medium.com/better-programming/how-to-use-eslint-and-prettier-in-your-next-js-application-with-typescript-8ffc9ac5b672" rel="noopener follow" target="_blank"><div class="lz ab fo"><div class="ma ab mb cl cj mc"><h2 class="bd iu gy z fp md fr fs me fu fw is bi translated">如何在带有TypeScript的Next.js应用程序中使用ESLint和appearlier</h2><div class="mf l"><h3 class="bd b gy z fp md fr fs me fu fw dk translated">让每个人都在同一页上，用同一种风格</h3></div><div class="mg l"><p class="bd b dl z fp md fr fs me fu fw dk translated">medium.com</p></div></div><div class="mh l"><div class="mo l mj mk ml mh mm ks ly"/></div></div></a></div></div><div class="ab cl mp mq hx mr" role="separator"><span class="ms bw bk mt mu mv"/><span class="ms bw bk mt mu mv"/><span class="ms bw bk mt mu"/></div><div class="im in io ip iq"><h1 id="698f" class="mw mx it bd my mz na nb nc nd ne nf ng jz nh ka ni kc nj kd nk kf nl kg nm nn bi translated">概观</h1><p id="1eb2" class="pw-post-body-paragraph kz la it lb b lc no ju le lf np jx lh li nq lk ll lm nr lo lp lq ns ls lt lu im bi translated">在本教程中，我们将实现以下内容:</p><ul class=""><li id="27dd" class="nt nu it lb b lc ld lf lg li nv lm nw lq nx lu ny nz oa ob bi translated">实现一个登录、注册和重置密码的表单。</li><li id="586a" class="nt nu it lb b lc oc lf od li oe lm of lq og lu ny nz oa ob bi translated">在Firestore数据库中存储额外的用户数据，并在用户登录时获取这些数据..</li><li id="ab54" class="nt nu it lb b lc oc lf od li oe lm of lq og lu ny nz oa ob bi translated">创建了一个useAuth挂钩，并使用上下文API向所有组件提供用户数据。</li><li id="5579" class="nt nu it lb b lc oc lf od li oe lm of lq og lu ny nz oa ob bi translated">每当我们获取数据时，显示一个加载微调图标。</li><li id="65fc" class="nt nu it lb b lc oc lf od li oe lm of lq og lu ny nz oa ob bi translated">每当出错时显示错误消息。</li><li id="68fa" class="nt nu it lb b lc oc lf od li oe lm of lq og lu ny nz oa ob bi translated">创建了一个钩子，当用户输入一个已验证但未登录时重定向用户。</li><li id="54cb" class="nt nu it lb b lc oc lf od li oe lm of lq og lu ny nz oa ob bi translated">创建一个注销按钮。</li></ul></div><div class="ab cl mp mq hx mr" role="separator"><span class="ms bw bk mt mu mv"/><span class="ms bw bk mt mu mv"/><span class="ms bw bk mt mu"/></div><div class="im in io ip iq"><h1 id="7cd7" class="mw mx it bd my mz na nb nc nd ne nf ng jz nh ka ni kc nj kd nk kf nl kg nm nn bi translated">创建登录和注册页面</h1><p id="ec42" class="pw-post-body-paragraph kz la it lb b lc no ju le lf np jx lh li nq lk ll lm nr lo lp lq ns ls lt lu im bi translated">让我们从设置我们的认证页面开始，并确保我们可以在我们的应用程序中导航这些页面。</p><p id="6461" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">创建文件<code class="fe oh oi oj ok b">/pages/signup.tsx</code>:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ol om l"/></div></figure><p id="eafb" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们为我们的<code class="fe oh oi oj ok b">Login</code>页面(<code class="fe oh oi oj ok b">/pages/login.tsx</code>)做同样的事情，并确保我们可以在两者之间导航。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ol om l"/></div></figure><p id="90c7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果你还没有这样做，用<code class="fe oh oi oj ok b">yarn dev</code>启动你的服务器，在你的浏览器中导航到<code class="fe oh oi oj ok b">/login</code>来测试页面是否工作。</p></div><div class="ab cl mp mq hx mr" role="separator"><span class="ms bw bk mt mu mv"/><span class="ms bw bk mt mu mv"/><span class="ms bw bk mt mu"/></div><div class="im in io ip iq"><h1 id="a4cc" class="mw mx it bd my mz na nb nc nd ne nf ng jz nh ka ni kc nj kd nk kf nl kg nm nn bi translated">创建表单</h1><p id="a3c3" class="pw-post-body-paragraph kz la it lb b lc no ju le lf np jx lh li nq lk ll lm nr lo lp lq ns ls lt lu im bi translated">现在我们有了自己的页面，让我们创建实际的注册和登录表单。在React中处理表单的一个很好的库是<code class="fe oh oi oj ok b">[react-hook-form](&lt;https://react-hook-form.com/&gt;)</code>。它帮助您构建高性能、灵活且可扩展的表单，并提供易于使用的验证。让我们先安装它:</p><pre class="kj kk kl km gt on ok oo op aw oq bi"><span id="7b24" class="or mx it ok b gy os ot l ou ov">yarn add react-hook-form</span></pre><p id="9fea" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在我们可以创建我们的注册表单:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ol om l"/></div></figure><p id="0499" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在在<code class="fe oh oi oj ok b">pages/signup.tsx</code>中导入<code class="fe oh oi oj ok b">SignUpForm</code>组件，并用刚刚创建的<code class="fe oh oi oj ok b">&lt;SignUpForm /&gt;</code>替换“todo”注释。</p><p id="b541" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">您可以通过提交表单并在控制台中检查日志来测试表单。它应该会向您显示一个如下所示的对象:</p><pre class="kj kk kl km gt on ok oo op aw oq bi"><span id="9385" class="or mx it ok b gy os ot l ou ov">{<br/>  name: Jake,<br/>  email: jake@prins.com,<br/>  password: secretpassword,<br/>}</span></pre><p id="6769" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">此外，尝试验证是否有效。所有字段都应该是必填的。应该验证电子邮件的格式是否正确，并且密码应该至少有6个字符长。</p><p id="0dca" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们做得很好，让我们对登录表单做同样的事情。</p><p id="32bd" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">创建<code class="fe oh oi oj ok b">/components/forms/LoginForm.tsx</code>，复制并粘贴你的注册表单代码。把名字改成<code class="fe oh oi oj ok b">LoginForm</code>，去掉“姓名”输入，因为我们登录只需要邮箱和密码。另外，调整<code class="fe oh oi oj ok b">LoginData</code>界面</p><p id="e7ab" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">您的表单应该如下所示:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ol om l"/></div></figure></div><div class="ab cl mp mq hx mr" role="separator"><span class="ms bw bk mt mu mv"/><span class="ms bw bk mt mu mv"/><span class="ms bw bk mt mu"/></div><div class="im in io ip iq"><h1 id="0164" class="mw mx it bd my mz na nb nc nd ne nf ng jz nh ka ni kc nj kd nk kf nl kg nm nn bi translated">创建一个Firebase项目</h1><p id="2271" class="pw-post-body-paragraph kz la it lb b lc no ju le lf np jx lh li nq lk ll lm nr lo lp lq ns ls lt lu im bi translated">现在我们已经准备好了表单，我们需要将它们与Firebase集成。让我们从建立一个Firebase项目开始。</p><p id="5e06" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">首先，我们需要创建一个Firebase帐户。前往<a class="ae ky" href="https://firebase.google.com/" rel="noopener ugc nofollow" target="_blank">https://firebase.google.com/</a>，点击“开始”按钮，并按照指示创建您的项目。</p><p id="096e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">一旦创建了项目，您应该在Firebase控制台中注册您的应用程序。在项目概述页面中，单击web图标将Firebase添加到您的web应用程序中。创建完成后，您将收到firebase配置，看起来应该是这样的:</p><pre class="kj kk kl km gt on ok oo op aw oq bi"><span id="b0b7" class="or mx it ok b gy os ot l ou ov">const firebaseConfig = {<br/>    apiKey: "xxxx",<br/>    authDomain: "your-project-name.firebaseapp.com",<br/>    databaseURL: "&lt;https://your-project-name.firebaseio.com&gt;",<br/>    projectId: "your-project-name",<br/>    storageBucket: "your-project-name.appspot.com",<br/>    messagingSenderId: "xxx",<br/>    appId: "xxx",<br/>    measurementId: "G-xxx"<br/>  };</span></pre><p id="1123" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们现在应该激活要添加到应用程序中的注册方法。导航至<em class="ow">认证</em>，通过激活<em class="ow">电子邮件/密码</em>方法开始。</p><h2 id="b573" class="or mx it bd my ox oy dn nc oz pa dp ng li pb pc ni lm pd pe nk lq pf pg nm ph bi translated"><strong class="ak">添加Firestore(可选)</strong></h2><p id="22f4" class="pw-post-body-paragraph kz la it lb b lc no ju le lf np jx lh li nq lk ll lm nr lo lp lq ns ls lt lu im bi translated">如果您想在注册时保存额外的信息，比如用户名或全名，您需要建立一个数据库来保存这些数据。<a class="ae ky" href="https://firebase.google.com/docs/firestore" rel="noopener ugc nofollow" target="_blank"> Cloud Firestore </a>是Firebase的一款灵活、可扩展的数据库。它提供了与Firebase和其他谷歌云平台产品的无缝集成，比如云功能。就像Firebase一样，它完全免费。只有当您的应用程序真正开始扩展时，您可能会超过免费计划，但即使这样，您也只需为您使用的内容付费。一个非常有趣的价格模型，如果你刚开始时不想花很多(或任何)钱的话。</p><p id="7223" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果您想要设置Firestore，请导航到<em class="ow">数据库</em>，然后单击第一个<em class="ow">创建数据库</em>按钮，将云Firestore添加到您的项目中。选择在测试模式下启动的选项。我们以后再来担心Firestore规则。</p></div><div class="ab cl mp mq hx mr" role="separator"><span class="ms bw bk mt mu mv"/><span class="ms bw bk mt mu mv"/><span class="ms bw bk mt mu"/></div><div class="im in io ip iq"><h1 id="b630" class="mw mx it bd my mz na nb nc nd ne nf ng jz nh ka ni kc nj kd nk kf nl kg nm nn bi translated">在您的项目中实现Firebase</h1><p id="acc2" class="pw-post-body-paragraph kz la it lb b lc no ju le lf np jx lh li nq lk ll lm nr lo lp lq ns ls lt lu im bi translated">我们现在准备在我们的项目中实现Firebase。</p><p id="4606" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">首先，安装Firebase:</p><pre class="kj kk kl km gt on ok oo op aw oq bi"><span id="65f6" class="or mx it ok b gy os ot l ou ov">yarn add firebase</span></pre><p id="a600" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们需要将我们的Firebase配置保存到一些环境变量中。</p><p id="c8ee" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">Next.js自带对环境变量的内置支持，允许你<a class="ae ky" href="https://nextjs.org/docs/basic-features/environment-variables#loading-environment-variables" rel="noopener ugc nofollow" target="_blank">使用</a> <code class="fe oh oi oj ok b"><a class="ae ky" href="https://nextjs.org/docs/basic-features/environment-variables#loading-environment-variables" rel="noopener ugc nofollow" target="_blank">.env.local</a></code> <a class="ae ky" href="https://nextjs.org/docs/basic-features/environment-variables#loading-environment-variables" rel="noopener ugc nofollow" target="_blank">加载环境变量</a>和<a class="ae ky" href="https://nextjs.org/docs/basic-features/environment-variables#exposing-environment-variables-to-the-browser" rel="noopener ugc nofollow" target="_blank">将环境变量暴露给浏览器</a>。</p><p id="2b41" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">转到您的<code class="fe oh oi oj ok b">.env.local</code>文件(或者创建它，如果它还不存在的话)。然后，在下面的示例中传递，用您自己的Firebase凭证更改虚拟数据。</p><pre class="kj kk kl km gt on ok oo op aw oq bi"><span id="c56b" class="or mx it ok b gy os ot l ou ov">NEXT_PUBLIC_FIREBASE_API_KEY="yourapikey"<br/>NEXT_PUBLIC_FIREBASE_AUTH_DOMAIN="yourappname.firebaseapp.com"<br/>NEXT_PUBLIC_FIREBASE_DATABASE_URL="&lt;https://appname.firebaseio.com&gt;"<br/>NEXT_PUBLIC_FIREBASE_PROJECT_ID="yourappname"<br/>NEXT_PUBLIC_FIREBASE_STORAGE_BUCKET="yourappname.appspot.com"<br/>NEXT_PUBLIC_FIREBASE_MESSAGING_SENDER_ID="yoursenderid"<br/>NEXT_PUBLIC_FIREBASE_APP_ID="yourappid"<br/>NEXT_PUBLIC_FIREBASE_MEASUREMENT_ID="yourmeasurementid"</span></pre><p id="ce3a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">只有在低于9.4的Next.js版本上，你才应该创建一个<code class="fe oh oi oj ok b">next.config.ts</code>文件并自己导出你的环境变量。</p><p id="a763" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">太好了，我们现在可以这样访问我们的数据了:<code class="fe oh oi oj ok b">process.env.NEXT_PUBLIC_FIREBASE_API_KEY</code>。仔细检查<code class="fe oh oi oj ok b">.env.local</code>是否被添加到您的<code class="fe oh oi oj ok b">.gitignore</code>中，这样您就不会意外地提交这些数据。还要记住，在部署应用程序时，首先需要设置生产环境变量。当在<a class="ae ky" href="https://vercel.com" rel="noopener ugc nofollow" target="_blank"> Vercel </a>上部署时，您可以在Vercel仪表板的项目的<a class="ae ky" href="https://vercel.com/docs/v2/build-step#environment-variables" rel="noopener ugc nofollow" target="_blank">环境变量</a>部分中配置秘密。</p><p id="c3ef" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">接下来，创建一个文件<code class="fe oh oi oj ok b">/config/firebase.ts</code>并添加您的配置。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ol om l"/></div></figure><p id="b936" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在这个文件中，我们首先声明我们的Firebase配置，然后用<code class="fe oh oi oj ok b">firebase.initializeApp(firebaseConfig)</code>初始化我们项目中的Firebase。</p><p id="ee67" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如您所见，我们还导出了一些在开发应用程序时需要的函数。</p></div><div class="ab cl mp mq hx mr" role="separator"><span class="ms bw bk mt mu mv"/><span class="ms bw bk mt mu mv"/><span class="ms bw bk mt mu"/></div><div class="im in io ip iq"><h1 id="cf38" class="mw mx it bd my mz na nb nc nd ne nf ng jz nh ka ni kc nj kd nk kf nl kg nm nn bi translated">签约雇用</h1><p id="1b48" class="pw-post-body-paragraph kz la it lb b lc no ju le lf np jx lh li nq lk ll lm nr lo lp lq ns ls lt lu im bi translated">现在我们已经准备好在我们的项目中使用Firebase，让我们转到我们的<code class="fe oh oi oj ok b">SignUpForm</code>组件，开始创建我们的<code class="fe oh oi oj ok b">signUp</code>函数。</p><pre class="kj kk kl km gt on ok oo op aw oq bi"><span id="0bb1" class="or mx it ok b gy os ot l ou ov">...<br/>import { auth } from 'config/firebase';<br/>...</span><span id="c1a1" class="or mx it ok b gy pi ot l ou ov">const signUp = ({ name, email, password }) =&gt; {<br/> return auth<br/>  .createUserWithEmailAndPassword(email, password)<br/>  .then((response) =&gt; {<br/>   console.log(response)<br/>  })<br/>  .catch((error) =&gt; {<br/>   return { error };<br/>  });<br/>};</span></pre><p id="3c02" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在你可以尝试你的形式:</p><pre class="kj kk kl km gt on ok oo op aw oq bi"><span id="5dbd" class="or mx it ok b gy os ot l ou ov">const onSubmit = (data: SignUpData) =&gt; {<br/> return signUp(data).then((user) =&gt; {<br/>  console.log(user);<br/> });<br/>};</span></pre><p id="d0f1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果你现在尝试这种形式，你将注册你的firebase项目。转到Firebase控制台，并转到身份验证概述。您应该在这里看到提交的数据。</p><p id="9003" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">太神奇了！仅仅用这几行代码，您就构建了一个注册表单！</p><p id="bd6d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">太好了，但是<em class="ow"> name </em>属性会怎么样呢？嗯，如果我们想存储额外的数据，我们还想在Firestore数据库中创建用户。因此，让我们创建一个在数据库中创建用户文档的函数，并确保记录的UID是相同的。</p><pre class="kj kk kl km gt on ok oo op aw oq bi"><span id="ac2f" class="or mx it ok b gy os ot l ou ov">...<br/>import { auth } from 'config/firebase';<br/>...</span><span id="9660" class="or mx it ok b gy pi ot l ou ov">const createUser = (user) =&gt; {<br/> return db<br/>  .collection('users')<br/>  .doc(user.uid)<br/>  .set(user)<br/>  .then(() =&gt; {<br/>   console.log("Success")<br/>  })<br/>  .catch((error) =&gt; {<br/>   console.log(error)<br/>  });<br/>};</span></pre><p id="0f8d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在，一旦用户成功注册，我们就可以调用这个函数。继续更新您的<code class="fe oh oi oj ok b">signUp</code>函数:</p><pre class="kj kk kl km gt on ok oo op aw oq bi"><span id="1b94" class="or mx it ok b gy os ot l ou ov">const signUp = ({ name, email, password }) =&gt; {<br/> return auth<br/>  .createUserWithEmailAndPassword(email, password)<br/>  .then((response) =&gt; {<br/>   return createUser({ uid: response.user.uid, email, name });<br/>  })<br/>  .catch((error) =&gt; {<br/>   return { error };<br/>  });<br/>};</span></pre><p id="b866" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果你现在再试一次，你会得到一个错误信息，因为你不能用同一个电子邮件地址注册两次。确保您已经删除了<a class="ae ky" href="https://console.firebase.google.com/" rel="noopener ugc nofollow" target="_blank"> Firebase控制台</a>中的第一个条目，然后重试(或者尝试使用不同的电子邮件)。</p><p id="28f8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">提交注册表单后，在<a class="ae ky" href="https://console.firebase.google.com/" rel="noopener ugc nofollow" target="_blank"> Firebase控制台</a>中的<em class="ow">认证</em>和<em class="ow">数据库</em>中查看是否创建了两条记录。</p><p id="a07c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">太好了，你现在应该有一个工作的注册表单了！</p><h2 id="c5a7" class="or mx it bd my ox oy dn nc oz pa dp ng li pb pc ni lm pd pe nk lq pf pg nm ph bi translated">句柄状态</h2><p id="83d4" class="pw-post-body-paragraph kz la it lb b lc no ju le lf np jx lh li nq lk ll lm nr lo lp lq ns ls lt lu im bi translated">基于成功响应，我们现在可以在用户注册后将他们重定向到不同的路由，但唯一的问题是我们将丢失我们的状态。在重定向的页面上，我们仍然需要能够判断用户是否登录。我们还希望在应用程序的多个地方使用当前用户的数据。</p><p id="87e1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">此时，我们需要考虑全局状态。我们可以使用像<a class="ae ky" href="https://redux.js.org/" rel="noopener ugc nofollow" target="_blank"> Redux </a>这样的状态管理库，但是这也引入了很多复杂性，并不总是你想要的。特别是现在React有了上下文和钩子，我们在这一点上并不真正需要状态管理库。</p></div><div class="ab cl mp mq hx mr" role="separator"><span class="ms bw bk mt mu mv"/><span class="ms bw bk mt mu mv"/><span class="ms bw bk mt mu"/></div><div class="im in io ip iq"><h1 id="aec9" class="mw mx it bd my mz na nb nc nd ne nf ng jz nh ka ni kc nj kd nk kf nl kg nm nn bi translated">创建身份验证提供程序</h1><p id="9cfc" class="pw-post-body-paragraph kz la it lb b lc no ju le lf np jx lh li nq lk ll lm nr lo lp lq ns ls lt lu im bi translated"><a class="ae ky" href="https://reactjs.org/docs/context.html" rel="noopener ugc nofollow" target="_blank">上下文</a>提供了一种通过组件树传递数据的方法，而不必在每一层手动向下传递属性。</p><p id="11a0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们从创建我们的<code class="fe oh oi oj ok b">useAuthProvider</code>钩子开始，将我们的<code class="fe oh oi oj ok b">signUp</code>和<code class="fe oh oi oj ok b">createUser</code>函数移到这个钩子中。我们还用<code class="fe oh oi oj ok b">useState</code>设置成功或出错后的用户状态。</p><p id="3342" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">创建一个名为<code class="fe oh oi oj ok b">hooks/useAuth</code>的文件，并添加以下代码:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ol om l"/></div></figure><p id="8415" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在让我们使用<a class="ae ky" href="https://reactjs.org/docs/context.html" rel="noopener ugc nofollow" target="_blank">上下文</a>来创建一个提供者。在刚刚放入<code class="fe oh oi oj ok b">hooks/useAuth.tsx</code>的代码上添加以下代码</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ol om l"/></div></figure><p id="ff40" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">很好——现在用这个提供者包装你的<code class="fe oh oi oj ok b">AppComponent</code>,这样我们就可以在应用程序的任何地方使用这个<code class="fe oh oi oj ok b">useAuth</code>钩子。在你的<code class="fe oh oi oj ok b">_app.tsx</code>:</p><pre class="kj kk kl km gt on ok oo op aw oq bi"><span id="8073" class="or mx it ok b gy os ot l ou ov">import { AppProps } from 'next/app';<br/>import { AuthProvider } from 'hooks/useAuth';<br/>export default function MyApp({ Component, pageProps }: AppProps): any {<br/> return (<br/>  &lt;AuthProvider&gt;<br/>   &lt;Component {...pageProps} /&gt;<br/>  &lt;/AuthProvider&gt;<br/> );<br/>}</span></pre><p id="316a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们也来做一个如果成功登录可以重定向到的页面:<code class="fe oh oi oj ok b">pages/dashboard.tsx</code>。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ol om l"/></div></figure><p id="432d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">酷，现在让我们来试试吧！如果你想用同一个电子邮件再试一次，那么在你提交表格之前，首先从Firebase中删除你的用户数据(或者使用不同的电子邮件)。如果一切正常，您现在应该会被重定向到仪表板页面。</p><p id="b637" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">噪音。这看起来越来越像了。让我们利用我们的势头，继续前进。</p></div><div class="ab cl mp mq hx mr" role="separator"><span class="ms bw bk mt mu mv"/><span class="ms bw bk mt mu mv"/><span class="ms bw bk mt mu"/></div><div class="im in io ip iq"><h1 id="6088" class="mw mx it bd my mz na nb nc nd ne nf ng jz nh ka ni kc nj kd nk kf nl kg nm nn bi translated">注册</h1><p id="277e" class="pw-post-body-paragraph kz la it lb b lc no ju le lf np jx lh li nq lk ll lm nr lo lp lq ns ls lt lu im bi translated">让我们创建我们的登录功能。在<code class="fe oh oi oj ok b">useAuth.tsx</code>内添加以下功能。</p><pre class="kj kk kl km gt on ok oo op aw oq bi"><span id="bb54" class="or mx it ok b gy os ot l ou ov">const signIn = ({ email, password }) =&gt; {<br/> return auth<br/>  .signInWithEmailAndPassword(email, password)<br/>  .then((response) =&gt; {<br/>   setUser(response.user);<br/>   return response.user;<br/>  })<br/>  .catch((error) =&gt; {<br/>   return { error };<br/>  });<br/>};</span></pre><p id="dffe" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">确保导出它。</p><pre class="kj kk kl km gt on ok oo op aw oq bi"><span id="c9ca" class="or mx it ok b gy os ot l ou ov">...<br/>return { user, signUp, signIn };<br/>...</span></pre><p id="5a55" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在在<code class="fe oh oi oj ok b">LoginForm.tsx</code>中调用提交时函数:</p><pre class="kj kk kl km gt on ok oo op aw oq bi"><span id="3922" class="or mx it ok b gy os ot l ou ov">...</span><span id="6a6a" class="or mx it ok b gy pi ot l ou ov">const LoginForm: React.FC = () =&gt; {<br/> const { register, errors, handleSubmit } = useForm();<br/> const auth = useAuth();<br/> const router = useRouter();</span><span id="c491" class="or mx it ok b gy pi ot l ou ov">const onSubmit = (data: LoginData) =&gt; {<br/>  return auth.signIn(data).then(() =&gt; {<br/>   router.push('/dashboard');<br/>  });<br/> };</span><span id="141b" class="or mx it ok b gy pi ot l ou ov">...</span></pre><p id="9e58" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">酷，现在让我们试试这是否可行。</p><p id="dc25" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">你现在应该可以登录了，接受我们缺少了<em class="ow">名字</em>。这是因为该名称不是来自Firebase身份验证，而是存储在我们的Firestore数据库中。我们需要监听身份验证状态的变化，并从数据库中获取数据。</p><p id="20d7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在<code class="fe oh oi oj ok b">useAuthProvider</code>钩子内添加这个函数:</p><pre class="kj kk kl km gt on ok oo op aw oq bi"><span id="8632" class="or mx it ok b gy os ot l ou ov">const getUserAdditionalData = (user: firebase.User) =&gt; {<br/> return db<br/>  .collection('users')<br/>  .doc(user.uid)<br/>  .get()<br/>  .then((userData) =&gt; {<br/>   if (userData.data()) {<br/>    setUser(userData.data());<br/>   }<br/>  });<br/>};</span></pre><p id="3134" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">然后，在成功的登录请求后调用这个函数。</p><pre class="kj kk kl km gt on ok oo op aw oq bi"><span id="3089" class="or mx it ok b gy os ot l ou ov">const signIn = ({ email, password }) =&gt; {<br/> return auth<br/>  .signInWithEmailAndPassword(email, password)<br/>  .then((response) =&gt; {<br/>   setUser(response.user);<br/>   getUserAdditionalData(user);<br/>   return response.user;<br/>  })<br/>  .catch((error) =&gt; {<br/>   return { error };<br/>  });<br/>};</span></pre><p id="4ef7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">太好了，现在这应该可以解决我们的问题了。但它并不能解决所有问题，因为Firebase还能帮助我们保持用户登录。但是在用户登录后，当他们重新进入我们的应用程序时，我们也需要获取额外的数据。</p><p id="cee9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">因此，让我们也订阅<code class="fe oh oi oj ok b">onAuthStateChanged</code>事件，并调用<code class="fe oh oi oj ok b">getUserAdditionalData</code>来获取数据:</p><pre class="kj kk kl km gt on ok oo op aw oq bi"><span id="4761" class="or mx it ok b gy os ot l ou ov">const handleAuthStateChanged = (user: firebase.User) =&gt; {<br/> setUser(user);<br/> if (user) {<br/>  getUserAdditionalData(user);<br/> }<br/>};</span><span id="ecbb" class="or mx it ok b gy pi ot l ou ov">useEffect(() =&gt; {<br/> const unsub = auth.onAuthStateChanged(handleAuthStateChanged);<br/> <br/> return () =&gt; unsub();<br/>}, []);</span></pre><p id="568b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果你刷新页面，你应该看到你的名字。神奇！🎩</p><p id="bfb6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">为了进一步改进这一点，我们还可以确保每当用户的文档更新时，我们也更新应用程序中的用户状态。我们可以通过向useAuth钩子添加另一个效果来做到这一点，该钩子订阅用户的文档并在它改变时更新状态。</p><pre class="kj kk kl km gt on ok oo op aw oq bi"><span id="73f0" class="or mx it ok b gy os ot l ou ov">useEffect(() =&gt; {<br/>  if (user?.uid) {<br/>    // Subscribe to user document on mount<br/>    const unsubscribe = db<br/>      .collection('users')<br/>      .doc(user.uid)<br/>      .onSnapshot((doc) =&gt; setUser(doc.data()));</span><span id="2e4d" class="or mx it ok b gy pi ot l ou ov">return () =&gt; unsubscribe();<br/>  }<br/>}, []);</span></pre></div><div class="ab cl mp mq hx mr" role="separator"><span class="ms bw bk mt mu mv"/><span class="ms bw bk mt mu mv"/><span class="ms bw bk mt mu"/></div><div class="im in io ip iq"><h1 id="5961" class="mw mx it bd my mz na nb nc nd ne nf ng jz nh ka ni kc nj kd nk kf nl kg nm nn bi translated">注销</h1><p id="beb8" class="pw-post-body-paragraph kz la it lb b lc no ju le lf np jx lh li nq lk ll lm nr lo lp lq ns ls lt lu im bi translated">我们现在确保从我们的数据库中获取用户数据，并更新我们的本地状态，以便用户知道他或她已经登录。这很好，但是我们还没有完成。我们还要确保用户可以注销。</p><p id="6c46" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">将此<code class="fe oh oi oj ok b">signOut</code>功能添加到<code class="fe oh oi oj ok b">useAuthProvider</code>中:</p><pre class="kj kk kl km gt on ok oo op aw oq bi"><span id="26d7" class="or mx it ok b gy os ot l ou ov">...</span><span id="8926" class="or mx it ok b gy pi ot l ou ov">const signOut = () =&gt; {<br/>  return auth.signOut().then(() =&gt; setUser(false));<br/>};</span><span id="309a" class="or mx it ok b gy pi ot l ou ov">...</span></pre><p id="c57e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们希望能够在任何地方调用这个函数，所以不要忘记导出它。</p><pre class="kj kk kl km gt on ok oo op aw oq bi"><span id="e7db" class="or mx it ok b gy os ot l ou ov">...<br/>return { user, signUp, signIn, signOut };<br/>...</span></pre><p id="5ccf" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在，我们要做的就是做一个按钮，当它被点击时调用这个函数。将此按钮添加到您的<code class="fe oh oi oj ok b">pages/dashboard.tsx</code>:</p><pre class="kj kk kl km gt on ok oo op aw oq bi"><span id="8cd3" class="or mx it ok b gy os ot l ou ov">...<br/>&lt;button<br/> onClick={() =&gt; auth.signOut()}<br/> className="w-full flex justify-center py-2 px-4 border border-transparent text-sm font-medium rounded-md text-white bg-indigo-600 hover:bg-indigo-500 focus:outline-none focus:border-indigo-700 focus:shadow-outline-indigo active:bg-indigo-700 transition duration-150 ease-in-out"<br/>&gt;<br/> Sign out<br/>&lt;/button&gt;</span></pre><p id="ced2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">试试吧！</p><p id="dbb8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果工作正常，你将会看到一个白屏。这不是我们真正想要的。我们实际上从来不希望用户在没有登录的情况下能够进入<code class="fe oh oi oj ok b">/dashboard</code>，所以让我们创建一个钩子，如果用户没有登录，它将重定向用户。</p><p id="bddb" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在<code class="fe oh oi oj ok b">hooks/useRequireAuth.tsx</code>处创建以下钩子</p><pre class="kj kk kl km gt on ok oo op aw oq bi"><span id="d9c4" class="or mx it ok b gy os ot l ou ov">import { useEffect } from 'react';<br/>import { useRouter } from 'next/router';<br/>import { useAuth } from 'hooks/useAuth';</span><span id="2278" class="or mx it ok b gy pi ot l ou ov">export const useRequireAuth = () =&gt; {<br/> const auth = useAuth();<br/> const router = useRouter();</span><span id="eca6" class="or mx it ok b gy pi ot l ou ov">useEffect(() =&gt; {<br/>  if (auth.user === false) {<br/>   router.push('/login');<br/>  }<br/> }, [auth, router]);<br/> <br/> return auth;<br/>};</span></pre><p id="ed87" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在使用<code class="fe oh oi oj ok b">dashboard.tsx</code>里面的这个钩子。用我们的新吊钩替换旧的<code class="fe oh oi oj ok b">const auth = useAuth()</code>:</p><pre class="kj kk kl km gt on ok oo op aw oq bi"><span id="33a9" class="or mx it ok b gy os ot l ou ov">...<br/>const auth = useRequireAuth()<br/>...</span></pre><p id="c061" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">又来了，魔法！🎩</p><p id="1a8b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">你做得太棒了。我们建立了一个工作注册和登录流程。不错！去喝杯咖啡吧，这是你应得的。当你回来的时候，我们还需要再写一些代码。</p></div><div class="ab cl mp mq hx mr" role="separator"><span class="ms bw bk mt mu mv"/><span class="ms bw bk mt mu mv"/><span class="ms bw bk mt mu"/></div><div class="im in io ip iq"><h1 id="d791" class="mw mx it bd my mz na nb nc nd ne nf ng jz nh ka ni kc nj kd nk kf nl kg nm nn bi translated">重置密码</h1><p id="d16b" class="pw-post-body-paragraph kz la it lb b lc no ju le lf np jx lh li nq lk ll lm nr lo lp lq ns ls lt lu im bi translated">因为当用户忘记密码时会发生什么？我们也需要处理这个问题，所以让我们给我们的<code class="fe oh oi oj ok b">useAuth</code>钩子添加一个函数来发送一个重置密码链接。</p><pre class="kj kk kl km gt on ok oo op aw oq bi"><span id="962a" class="or mx it ok b gy os ot l ou ov">const sendPasswordResetEmail = (email) =&gt; {<br/>  return auth.sendPasswordResetEmail(email).then((response) =&gt; {<br/>   return response;<br/>  });<br/> };</span><span id="f128" class="or mx it ok b gy pi ot l ou ov">...</span><span id="c4d0" class="or mx it ok b gy pi ot l ou ov">return {<br/> user,<br/> signUp,<br/> signIn,<br/> signOut,<br/> sendPasswordResetEmail,<br/>};</span></pre><p id="c31f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在创建一个<code class="fe oh oi oj ok b">ResetPasswordForm</code>组件，用户可以在其中输入他们的电子邮件。在提交时，它应该调用新<code class="fe oh oi oj ok b">sendPasswordResetEmail</code>函数。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ol om l"/></div></figure><p id="fd0d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">太好了。现在创建显示我们新的<code class="fe oh oi oj ok b">ResetPasswordForm</code>组件的<code class="fe oh oi oj ok b">reset-password</code>页面。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ol om l"/></div></figure><p id="d583" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">此外，在我们的登录表单上添加一个到这个新的<code class="fe oh oi oj ok b">reset-password</code>页面的链接。将此代码添加到密码输入的正下方:</p><pre class="kj kk kl km gt on ok oo op aw oq bi"><span id="f043" class="or mx it ok b gy os ot l ou ov">...</span><span id="3514" class="or mx it ok b gy pi ot l ou ov">&lt;div className="mt-4 flex items-end"&gt;<br/> &lt;div className="text-sm leading-5"&gt;<br/>  &lt;Link href="/reset-password"&gt;<br/>   &lt;a<br/>    href="#"<br/>    className="font-medium text-indigo-600 hover:text-indigo-500 focus:outline-none focus:underline transition ease-in-out duration-150"<br/>   &gt;<br/>    Forgot your password?<br/>   &lt;/a&gt;<br/>  &lt;/Link&gt;<br/> &lt;/div&gt;<br/>&lt;/div&gt;</span><span id="c589" class="or mx it ok b gy pi ot l ou ov">...</span></pre><p id="4e8d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">很好。现在测试一下，看看您全新的认证流程！</p><p id="d244" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这里总是有一些改进的空间。让我们来处理加载状态和错误消息。</p></div><div class="ab cl mp mq hx mr" role="separator"><span class="ms bw bk mt mu mv"/><span class="ms bw bk mt mu mv"/><span class="ms bw bk mt mu"/></div><div class="im in io ip iq"><h1 id="01ac" class="mw mx it bd my mz na nb nc nd ne nf ng jz nh ka ni kc nj kd nk kf nl kg nm nn bi translated">加载状态和错误消息</h1><p id="c816" class="pw-post-body-paragraph kz la it lb b lc no ju le lf np jx lh li nq lk ll lm nr lo lp lq ns ls lt lu im bi translated">我们现在有了一个有效的认证流程，这很好，但仍有很大的改进空间。让我们从处理加载状态开始，并确保在出错时显示错误消息。</p><p id="a70e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在您的<code class="fe oh oi oj ok b">SignInForm</code>组件中，导入<code class="fe oh oi oj ok b">useState</code>并使用它来设置<code class="fe oh oi oj ok b">isLoading</code>和<code class="fe oh oi oj ok b">error</code>的状态。当我们提交表单时，我们将<code class="fe oh oi oj ok b">isLoading</code>设置为<code class="fe oh oi oj ok b">true</code>并清除错误。响应返回后，我们将<code class="fe oh oi oj ok b">isLoading</code>设置回<code class="fe oh oi oj ok b">false</code>，只有当出现错误时，我们才设置错误。</p><pre class="kj kk kl km gt on ok oo op aw oq bi"><span id="5886" class="or mx it ok b gy os ot l ou ov">import { useState } from 'react';</span><span id="a471" class="or mx it ok b gy pi ot l ou ov">const [isLoading, setIsLoading] = useState(false);<br/>const [error, setError] = useState(null);</span><span id="929f" class="or mx it ok b gy pi ot l ou ov">const onSubmit = (data: LoginData) =&gt; {<br/> setIsLoading(true);<br/> setError(null);<br/> return auth.signIn(data).then((response) =&gt; {<br/>  setIsLoading(false);<br/>  response.error ? setError(response.error) : router.push('/dashboard');<br/> });<br/>};</span></pre><p id="450a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果存在错误，我们希望在表单中显示出来:</p><pre class="kj kk kl km gt on ok oo op aw oq bi"><span id="f720" class="or mx it ok b gy os ot l ou ov">{error?.message &amp;&amp; (<br/> &lt;div className="mb-4 text-red-500 text-center border-dashed border border-red-600 p-2 rounded"&gt;<br/>  &lt;span&gt;{error.message}&lt;/span&gt;<br/> &lt;/div&gt;<br/>)}</span></pre><p id="b272" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们也喜欢向用户显示我们正在获取数据，所以让我们在<code class="fe oh oi oj ok b">isLoading</code>为<code class="fe oh oi oj ok b">true</code>时更改提交按钮的文本。</p><p id="4f13" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">因为我们在所有的表单上都使用这个按钮，所以让我们创建一个可重用的按钮组件，我们可以在不同的地方导入它。</p><pre class="kj kk kl km gt on ok oo op aw oq bi"><span id="812e" class="or mx it ok b gy os ot l ou ov">interface ButtonProps {<br/> title?: string;<br/> isLoading?: boolean;<br/>}</span><span id="b7aa" class="or mx it ok b gy pi ot l ou ov">const Button = ({<br/> isLoading,<br/> title,<br/> children,<br/> ...buttonProps<br/>}: ButtonProps &amp;<br/> React.ButtonHTMLAttributes&lt;HTMLButtonElement&gt;): JSX.Element =&gt; {<br/> return (<br/>  &lt;button<br/>   className="w-full flex justify-center py-2 px-4 border border-transparent text-sm font-medium rounded-md text-white bg-indigo-600 hover:bg-indigo-500 focus:outline-none focus:border-indigo-700 focus:shadow-outline-indigo active:bg-indigo-700 transition duration-150 ease-in-out"<br/>   {...buttonProps}<br/>  &gt;<br/>   {isLoading ? 'Loading...' : title}<br/>   {children}<br/>  &lt;/button&gt;<br/> );<br/>};</span><span id="4f4a" class="or mx it ok b gy pi ot l ou ov">export default Button;</span></pre><p id="2f38" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在，我们可以像这样在表单组件中使用按钮:</p><pre class="kj kk kl km gt on ok oo op aw oq bi"><span id="522a" class="or mx it ok b gy os ot l ou ov">import Button from 'components/elements/Button';</span><span id="498e" class="or mx it ok b gy pi ot l ou ov">...</span><span id="52ab" class="or mx it ok b gy pi ot l ou ov">&lt;Button title="Login" type="submit" isLoading={isLoading} /&gt;</span><span id="975d" class="or mx it ok b gy pi ot l ou ov">...</span></pre><p id="0f24" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">那好多了。我们可以通过显示一个微调图标来代替“加载…”文本，这样会更好。</p><p id="b2bc" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在<code class="fe oh oi oj ok b">icons/spinner.tsx</code>，创建微调图标组件:</p><pre class="kj kk kl km gt on ok oo op aw oq bi"><span id="9c1c" class="or mx it ok b gy os ot l ou ov">const Spinner = (props: React.SVGProps&lt;SVGSVGElement&gt;): JSX.Element =&gt; {<br/> return (<br/>  &lt;svg viewBox="0 0 100 100" {...props}&gt;<br/>   &lt;path d="M90.9 58.2c-3.8 18.9-20.1 32.7-39.7 33-22 .4-40.7-17-41.9-39C8 28.5 26.9 8.8 50.4 8.8c19 0 35.5 13.1 40 31.2.3 1.2 1.4 2.1 2.7 2.1 1.8 0 3.1-1.7 2.7-3.5C90.6 18.1 72 3.3 50.4 3.3c-27.2 0-49 23.4-46.6 51.1 2.1 23 21 41.2 44 42.4C71.6 98 91.7 81.9 96.2 59.4c.3-1.7-1-3.3-2.7-3.3-1.3-.1-2.4.8-2.6 2.1z" /&gt;<br/>  &lt;/svg&gt;<br/> );<br/>};</span><span id="544a" class="or mx it ok b gy pi ot l ou ov">export default Spinner;</span></pre><p id="7d6a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在，在我们的<code class="fe oh oi oj ok b">Button</code>组件中，用微调组件替换加载文本:</p><pre class="kj kk kl km gt on ok oo op aw oq bi"><span id="9a7e" class="or mx it ok b gy os ot l ou ov">{isLoading ? (<br/> &lt;Spinner width="20" fill="white" className="animate-spin" /&gt;<br/>) : (<br/> title<br/>)}</span></pre><p id="e81b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">注意:确保你的版本至少是1.7，这样你就可以使用<code class="fe oh oi oj ok b">animate-spin</code>类。</p><p id="0d3e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">噪音。现在，继续为注册和重置密码表单做同样的事情，今天到此为止。</p></div><div class="ab cl mp mq hx mr" role="separator"><span class="ms bw bk mt mu mv"/><span class="ms bw bk mt mu mv"/><span class="ms bw bk mt mu"/></div><div class="im in io ip iq"><h1 id="9861" class="mw mx it bd my mz na nb nc nd ne nf ng jz nh ka ni kc nj kd nk kf nl kg nm nn bi translated">摘要</h1><ul class=""><li id="becd" class="nt nu it lb b lc no lf np li pj lm pk lq pl lu ny nz oa ob bi translated">我们为身份验证表单实现了不同的页面。</li><li id="958e" class="nt nu it lb b lc oc lf od li oe lm of lq og lu ny nz oa ob bi translated">我们已经实现了登录、注册和重置密码表单。</li><li id="9b12" class="nt nu it lb b lc oc lf od li oe lm of lq og lu ny nz oa ob bi translated">我们在Firestore数据库中存储额外的用户数据，并在用户登录时获取这些数据。</li><li id="847a" class="nt nu it lb b lc oc lf od li oe lm of lq og lu ny nz oa ob bi translated">我们实现了一个注销按钮。</li><li id="e197" class="nt nu it lb b lc oc lf od li oe lm of lq og lu ny nz oa ob bi translated">我们已经创建了一个useAuth挂钩，并使用上下文API向所有组件提供用户数据。</li><li id="0329" class="nt nu it lb b lc oc lf od li oe lm of lq og lu ny nz oa ob bi translated">每当我们获取数据时，我们显示一个加载微调图标。</li><li id="46d0" class="nt nu it lb b lc oc lf od li oe lm of lq og lu ny nz oa ob bi translated">每当出现问题时，我们都会显示错误消息。</li><li id="c8e0" class="nt nu it lb b lc oc lf od li oe lm of lq og lu ny nz oa ob bi translated">我们已经创建了一个钩子，当用户输入一个经过身份验证但没有登录时，它可以重定向用户。</li></ul><p id="08dc" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">就是这样！感谢阅读。我希望它有帮助。祝你项目的下一步顺利。</p></div></div>    
</body>
</html>