<html>
<head>
<title>Build a Configurable Chain of Responsibility in Go</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">在Go中建立一个可配置的责任链</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/build-a-configurable-chain-of-responsibility-in-go-80a7cdcd1ab2?source=collection_archive---------8-----------------------#2021-04-20">https://betterprogramming.pub/build-a-configurable-chain-of-responsibility-in-go-80a7cdcd1ab2?source=collection_archive---------8-----------------------#2021-04-20</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="d67f" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">使用责任链设计模式根据配置变更修改应用程序行为</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/de8e04496d003de5d7b625bdb3402ba6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*DLj103QI9xVOmDlz"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">Erik Mclean 在<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片。</p></figure><p id="1084" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">责任链或指挥链<strong class="lb iu"> </strong>是一种<a class="ae ky" href="https://refactoring.guru/design-patterns/chain-of-responsibility" rel="noopener ugc nofollow" target="_blank">设计模式</a>，它让你沿着<code class="fe lv lw lx ly b">Handlers</code>链传递请求。每个<code class="fe lv lw lx ly b">Handler</code>决定处理请求并丰富它，或者将它传递给下一个<code class="fe lv lw lx ly b">Handler</code>。</p><p id="b434" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">它允许您在每个步骤之间有很大的隔离，避免在一些技术逻辑中间有业务逻辑。如果你的应用程序应该做的事情发生了变化，它也给你重新排序你的链的可能性。</p><p id="810f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这很好，但是为什么我们希望它是可配置的呢？</p><p id="5bf5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">背后的原因是能够快速改变你的应用程序的行为，而无需部署代码。</p><p id="6f3a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">假设我们有一组<code class="fe lv lw lx ly b">Handlers</code>可用于我们的服务:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi lz"><img src="../Images/4ec9c165f7b0928895703bff0e4ba317.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*cjMtonHlqlXKFLgS_YY-0Q.jpeg"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">初始管道。作者照片。</p></figure><p id="305f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">正如您所看到的，我们这里有一个简单的管道，在这里我们链接了<code class="fe lv lw lx ly b">Handlers</code>来处理请求。它可以很容易地用如下所示的配置来表示:</p><pre class="kj kk kl km gt ma ly mb mc aw md bi"><span id="37ef" class="me mf it ly b gy mg mh l mi mj"><strong class="ly iu">root</strong>: step1<br/><strong class="ly iu">steps</strong>:<br/>  <strong class="ly iu">step1</strong>:<br/>    type: handlerImpl1<br/>    next: step2<br/><br/>  <strong class="ly iu">step2</strong>:<br/>    type: handlerImpl2<br/>    next: step3</span><span id="c465" class="me mf it ly b gy mk mh l mi mj">  <strong class="ly iu">step</strong>3:<br/>    type: handlerImpl3</span></pre><p id="f02b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">但是，假设您处于生产环境中，并且希望在调用步骤3之前添加一个缓存层。您很幸运，因为管理您的缓存解决方案的<code class="fe lv lw lx ly b">Handler</code>已经存在于另一个管道中。</p><p id="dc84" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">通过更改配置，您可以很容易地通过这个缓存步骤获得不同的管道:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ml"><img src="../Images/e023fa2f9035c718394bc3cd05ed5a4e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*COWugLq4fIBWxq8zmHGfQg.jpeg"/></div></div></figure><pre class="kj kk kl km gt ma ly mb mc aw md bi"><span id="6ead" class="me mf it ly b gy mg mh l mi mj"><strong class="ly iu">root</strong>: step1<br/><strong class="ly iu">steps</strong>:<br/>  <strong class="ly iu">step1</strong>:<br/>    type: handlerImpl1<br/>    next: <strong class="ly iu">step2</strong><br/><br/>  <strong class="ly iu">step2</strong>:<br/>    type: handlerImpl2<br/>    next: <strong class="ly iu">step4</strong></span><span id="41b8" class="me mf it ly b gy mk mh l mi mj"><strong class="ly iu">step3:</strong><br/>    type: handlerImpl3</span><span id="d428" class="me mf it ly b gy mk mh l mi mj"><strong class="ly iu">step4:</strong><br/>    type: RewriteHandler<br/>    next: <strong class="ly iu">step3</strong></span></pre><h2 id="efb9" class="me mf it bd mm mn mo dn mp mq mr dp ms li mt mu mv lm mw mx my lq mz na nb nc bi translated">现实生活中的用例</h2><p id="dabc" class="pw-post-body-paragraph kz la it lb b lc nd ju le lf ne jx lh li nf lk ll lm ng lo lp lq nh ls lt lu im bi translated">假设您正在构建一个搜索API。基本上，它接收搜索请求并通过响应进行回答。</p><p id="eaea" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">API在Elasticsearch之上，<strong class="lb iu"> </strong>所以我们做的是直接从API调用ES(超级简单)。一段时间后，您发现一些顶级搜索查询的命中率有点过高，因此您决定在调用es之前引入Redis缓存。<br/>假设在某个时候，你想要更快，在你的应用中建立一个本地缓存，以超快的速度响应这些顶级查询。</p><p id="6b0b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">所以你能做的就是有如下三个<code class="fe lv lw lx ly b">Handlers</code>。每个<code class="fe lv lw lx ly b">Handler</code>负责一个动作，可以根据是否需要进入下一步；</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ni"><img src="../Images/d21c3a6fc0b70132b313576b085d9b8b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Cc_MgelioefVM5eulasVsw.jpeg"/></div></div></figure><p id="b282" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">可配置性还允许您在不更改任何代码的情况下随时删除缓存步骤。例如，如果您发现您的本地缓存消耗了太多的内存，并且您想要清除它，您可以只更改您的配置文件，您的请求将能够直接进入Redis缓存。</p></div><div class="ab cl nj nk hx nl" role="separator"><span class="nm bw bk nn no np"/><span class="nm bw bk nn no np"/><span class="nm bw bk nn no"/></div><div class="im in io ip iq"><h1 id="057b" class="nq mf it bd mm nr ns nt mp nu nv nw ms jz nx ka mv kc ny kd my kf nz kg nb oa bi translated">如何实施</h1><p id="f26d" class="pw-post-body-paragraph kz la it lb b lc nd ju le lf ne jx lh li nf lk ll lm ng lo lp lq nh ls lt lu im bi translated">如果你想看完整的代码，你可以跳到下一节。<br/>本节将详细介绍代码的所有部分。</p><h2 id="ab5c" class="me mf it bd mm mn mo dn mp mq mr dp ms li mt mu mv lm mw mx my lq mz na nb nc bi translated">处理配置文件</h2><p id="3edf" class="pw-post-body-paragraph kz la it lb b lc nd ju le lf ne jx lh li nf lk ll lm ng lo lp lq nh ls lt lu im bi translated">第一步是从配置文件加载配置。在这个例子中，我将使用一个托管在<a class="ae ky" href="https://gist.github.com/thomaspoignant/2499a88c939f654c7e15295194445fd7" rel="noopener ugc nofollow" target="_blank"> gist </a>上的YAML文件。</p><p id="3db9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">格式如下:</p><pre class="kj kk kl km gt ma ly mb mc aw md bi"><span id="d2d3" class="me mf it ly b gy mg mh l mi mj"><strong class="ly iu">root</strong>: handler1_name<br/><strong class="ly iu">steps</strong>:<br/>  handler1_name:<br/>    <strong class="ly iu">type</strong>: handlerImpl1<br/>    <strong class="ly iu">next</strong>: handler2_name<br/><br/>  handler2_name:<br/>    <strong class="ly iu">type</strong>: handlerImpl2</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ob"><img src="../Images/2cef7e03ac5d22903ddb3a15879af37e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*6mtHALUKZOoLxjBKn4Sb9w.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated"><a class="ae ky" href="https://gist.github.com/thomaspoignant/a8cd2ea31630b249ebc17418168d60b6" rel="noopener ugc nofollow" target="_blank">参见完整要点</a></p></figure><p id="7a75" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">作为函数<code class="fe lv lw lx ly b">main</code>的第一步，我们将解组到我们的结构中:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi oc"><img src="../Images/d26096161121b5f0804d0630274e4f3e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*0yvkDX6DZwwez34ktDCzIw.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated"><a class="ae ky" href="https://gist.github.com/thomaspoignant/a8cd2ea31630b249ebc17418168d60b6" rel="noopener ugc nofollow" target="_blank">见完整要旨</a></p></figure><h2 id="8acd" class="me mf it bd mm mn mo dn mp mq mr dp ms li mt mu mv lm mw mx my lq mz na nb nc bi translated">创建管道</h2><p id="dcf6" class="pw-post-body-paragraph kz la it lb b lc nd ju le lf ne jx lh li nf lk ll lm ng lo lp lq nh ls lt lu im bi translated">我们有配置。这样，我们将创建管道本身。我们将在我们的<code class="fe lv lw lx ly b">main</code>函数中调用<code class="fe lv lw lx ly b">NewPipeline</code>:</p><pre class="kj kk kl km gt ma ly mb mc aw md bi"><span id="6812" class="me mf it ly b gy mg mh l mi mj"><strong class="ly iu">pipeline, _ := NewPipeline(pipelineConfig)</strong></span></pre><p id="49c0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe lv lw lx ly b">NewPipeline</code>函数将把配置文件转换成一个带有初始化的<code class="fe lv lw lx ly b">Handler</code>的管道结构实例，以便在您的请求中使用。</p><p id="afe3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">为此，它会将<code class="fe lv lw lx ly b">StepType</code>转换为实际的<code class="fe lv lw lx ly b">Handler</code>，如果该步骤有下一步，则使用现有的<code class="fe lv lw lx ly b">Next</code> <code class="fe lv lw lx ly b">Handler</code>为每个<code class="fe lv lw lx ly b">Handler</code>调用<code class="fe lv lw lx ly b">init</code> <strong class="lb iu"> </strong>函数:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi od"><img src="../Images/92e892e9dfeb5ed780124d32a6811e29.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*4wCzY77cjZKLkx-p5Io_Uw.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated"><a class="ae ky" href="https://gist.github.com/thomaspoignant/a8cd2ea31630b249ebc17418168d60b6" rel="noopener ugc nofollow" target="_blank">见完整要旨</a></p></figure><p id="6aec" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">使用的<code class="fe lv lw lx ly b">StepType</code>和<code class="fe lv lw lx ly b">Handler</code>之间的映射在<code class="fe lv lw lx ly b">getHandlerFromType()</code>函数中完成:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi oe"><img src="../Images/f2db4ae841c6c015cefd606d44102671.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*FdDxh47Djw1UvizMsEwmfw.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated"><a class="ae ky" href="https://gist.github.com/thomaspoignant/a8cd2ea31630b249ebc17418168d60b6" rel="noopener ugc nofollow" target="_blank">见完整要旨</a></p></figure><h2 id="d5cd" class="me mf it bd mm mn mo dn mp mq mr dp ms li mt mu mv lm mw mx my lq mz na nb nc bi translated">创建处理程序</h2><p id="4649" class="pw-post-body-paragraph kz la it lb b lc nd ju le lf ne jx lh li nf lk ll lm ng lo lp lq nh ls lt lu im bi translated">创建一个<code class="fe lv lw lx ly b">Handler</code>很简单。它遵循以下接口:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi of"><img src="../Images/a10871ecf3d6cfaa773ff1030fd7041e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ueEHIL7mQKO5hnnLG7nqQA.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated"><a class="ae ky" href="https://gist.github.com/thomaspoignant/a8cd2ea31630b249ebc17418168d60b6" rel="noopener ugc nofollow" target="_blank">见完整要旨</a></p></figure><p id="ea41" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe lv lw lx ly b">Init</code>功能主要用于根据配置初始化该步骤的下一个<code class="fe lv lw lx ly b">Handler</code>。</p><p id="5cee" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">调用<code class="fe lv lw lx ly b">Execute</code>函数来应用真正的逻辑。这是我们决定是否要进行下一步的函数。如你所见，它需要一个<code class="fe lv lw lx ly b">context</code> <strong class="lb iu"> </strong>参数。这是一个给每个<code class="fe lv lw lx ly b">Handler</code>的参数，可以在每一步中丰富。在示例中，这是一个<code class="fe lv lw lx ly b">*[]string</code>，但它可以是任何东西上的指针。</p><p id="a4a8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">一个<code class="fe lv lw lx ly b">Handler</code>的例子:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi oe"><img src="../Images/cb9c0330b8372580fb7f0e7a2070b209.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*qf0NWlzjfhOH2_7UCRro-w.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated"><a class="ae ky" href="https://gist.github.com/thomaspoignant/a8cd2ea31630b249ebc17418168d60b6" rel="noopener ugc nofollow" target="_blank">参见完整要点</a></p></figure><p id="dbeb" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如您所见，我们在从<code class="fe lv lw lx ly b">next</code> <code class="fe lv lw lx ly b">Handler</code>调用<code class="fe lv lw lx ly b">Execute()</code>函数时给出了上下文。我们也可以在得到下一步的结果后做一个动作。</p><h2 id="1a01" class="me mf it bd mm mn mo dn mp mq mr dp ms li mt mu mv lm mw mx my lq mz na nb nc bi translated">执行管道</h2><p id="038c" class="pw-post-body-paragraph kz la it lb b lc nd ju le lf ne jx lh li nf lk ll lm ng lo lp lq nh ls lt lu im bi translated">最后一步是调用管道本身的<code class="fe lv lw lx ly b">Execute()</code>函数<strong class="lb iu"> </strong>:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi of"><img src="../Images/98b94f2a6bc26b8b5079fad54344bb81.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*gHAMkd5EKjdgDJuQuR98Yw.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated"><a class="ae ky" href="https://gist.github.com/thomaspoignant/a8cd2ea31630b249ebc17418168d60b6" rel="noopener ugc nofollow" target="_blank">见完整要旨</a></p></figure><p id="edc7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">它执行<code class="fe lv lw lx ly b">root</code> <strong class="lb iu"> </strong>步骤并执行相关的<code class="fe lv lw lx ly b">Handler</code>。通过这样做，整个链将被执行，因为每个<code class="fe lv lw lx ly b">Handler</code>都知道下一步是什么。</p></div><div class="ab cl nj nk hx nl" role="separator"><span class="nm bw bk nn no np"/><span class="nm bw bk nn no np"/><span class="nm bw bk nn no"/></div><div class="im in io ip iq"><h1 id="7046" class="nq mf it bd mm nr ns nt mp nu nv nw ms jz nx ka mv kc ny kd my kf nz kg nb oa bi translated">代码</h1><p id="e952" class="pw-post-body-paragraph kz la it lb b lc nd ju le lf ne jx lh li nf lk ll lm ng lo lp lq nh ls lt lu im bi translated">下面是完整的实现。在这个例子中，<code class="fe lv lw lx ly b">Handlers</code>是微不足道的，但是你可以在它上面有更复杂的逻辑，并开始链接东西:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="og oh l"/></div></figure></div><div class="ab cl nj nk hx nl" role="separator"><span class="nm bw bk nn no np"/><span class="nm bw bk nn no np"/><span class="nm bw bk nn no"/></div><div class="im in io ip iq"><h1 id="404c" class="nq mf it bd mm nr ns nt mp nu nv nw ms jz nx ka mv kc ny kd my kf nz kg nb oa bi translated">结论</h1><p id="01c1" class="pw-post-body-paragraph kz la it lb b lc nd ju le lf ne jx lh li nf lk ll lm ng lo lp lq nh ls lt lu im bi translated">正如你所看到的，在Go中使用责任链或指挥链<strong class="lb iu"> </strong>设计模式可以非常强大，并且给你一个很好的解耦逻辑的方法。</p><p id="4775" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果您的<code class="fe lv lw lx ly b">Handlers</code>足够通用，可以移动到链中的不同位置，那么能够从代码外部配置它会给您带来很多潜在的改进。</p><p id="27c8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">从经验来看，如果你有一个可以针对不同客户定制的产品，会对你有很大帮助。您将在开始时花费时间来开发您的处理程序，但最终，您将拥有一套完整的处理程序，允许您只需选择正确的链，而无需开发任何东西。</p></div></div>    
</body>
</html>