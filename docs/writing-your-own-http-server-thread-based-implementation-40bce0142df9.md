# 编写自己的 HTTP 服务器(第 2 部分)

> 原文：<https://betterprogramming.pub/writing-your-own-http-server-thread-based-implementation-40bce0142df9>

## 我们基于线程的实现

![](img/c335d158292e565d24fb698ebc3ec354.png)

伊利亚·巴甫洛夫在 [Unsplash](https://unsplash.com/s/photos/create?utm_source=unsplash&utm_medium=referral&utm_content=creditCopyText) 拍摄的照片

*这是“编写自己的 HTTP 服务器”系列的第二部分可以在这里阅读* [*Part 1*](https://medium.com/p/b2f94581268b/edit) *和*[*Part 3*](https://medium.com/p/97706588ac20/edit)*。*

在对 HTTP 服务器必须具备的功能有了基本的了解，并且知道了我们想要使用的传输层和应用层协议之后，我们现在就可以开始实现服务器了。所以让我们开始吧。

# 服务器设置

让我们首先完成一些基本的设置。我将概述应用程序的结构，并在这里处理像配置和信号处理这样的事情，然后实现真正的逻辑。设置代码如下，将在以下小节中讨论。

服务器的设置代码

## 配置

所有生产服务器都有许多不同的参数可以配置，通常通过一个配置文件，从而让用户根据他们的使用情况调整服务器。我们也将支持这样的配置。当运行服务器时，我们将要求用户使用 *-c* 命令行选项来分析配置文件的位置。配置文件应该是 T21 YAML 的格式。我们使用 pyyaml 库来解析 yaml 文件。

然后将`read config`传递给服务器和服务器的工作组件。我们将在后面的章节中讨论这些组件。但是正是这些组件使用所提供的配置来设置它们的参数。

## 信号处理

我们做的另一件事是为 SIGINT、SIGTERM 和 SIGHUP 信号设置信号处理程序。当接收到这些信号之一时，我们希望优雅地关闭服务器。因此，我们将 shutdown 函数注册为信号处理程序，该函数调用 server 和 worker 类的 shutdown 方法。

这基本上就是我们需要的所有设置代码。现在让我们讨论驻留在服务器和工作者中的服务器的核心逻辑。

# 监听连接

正如我们在本系列的第 1 部分中了解到的，首先我们需要设置传输，以便客户端可以连接到服务器，然后发送和接收数据。

我们了解到我们需要使用的传输层协议是 TCP。要使用 TCP，我们可以使用几乎所有主流操作系统提供的 socket API。套接字 API 提供了传输层协议的抽象。它让你像访问文件一样访问网络。因此，您可以读取和写入套接字，这些读取和写入被转换为所使用的底层传输层协议格式的网络数据包。在两个进程之间的通信中，这两个进程都有一个套接字连接到另一个进程。套接字充当通信的端点。

让我们看看 Linux 操作系统提供的 socket 系统调用的[手册页。API 的细节可以从那里阅读。但是简单地说，可以使用下面的函数创建一个新的套接字](http://man7.org/linux/man-pages/man2/socket.2.html)

```
int socket(int *domain*, int *type*, int *protocol*);
```

API 可以使用不同的域和类型参数，它们代表不同的传输层协议及其行为。我们关心 IPv4 上的 TCP 协议。它的领域是`AF_INET`。并且需要的插座类型是`SOCK_STREAM`。同样的的 [Python API 的细节也是可用的。为了在 Python 中创建一个套接字，我们调用下面的函数，它与我们上面看到的 C 版本相同。](https://docs.python.org/3/library/socket.html)

```
socket.socket(*family=AF_INET*, *type=SOCK_STREAM*, *proto=0*, *fileno=None*)
```

现在我们知道了什么是 socket，让我们来看看如何使用它。在服务器端，有两种套接字。一个叫做*监听器套接字*，另一个叫做*客户端套接字*。(服务器和客户机都使用客户机套接字，但只有服务器使用侦听器套接字)。

侦听器套接字是特殊的。我们将一个侦听器套接字绑定到一个 IP 和端口，然后等待客户端连接。当你在浏览器中键入任何网站的地址时，这就是幕后发生的事情。浏览器在其一端创建一个客户端套接字，然后尝试使用通过网站域的 DNS 解析获得的 IP 地址连接到 web 服务器。默认情况下，使用端口号 80，但您可以在浏览器中显式给出不同的端口号。

当浏览器试图连接到服务器时，它实际上是在与服务器的侦听器套接字建立连接。当连接请求到达时，侦听器套接字在服务器上创建一个新的客户机套接字，并将客户机的客户机套接字连接到这个新的客户机套接字。现在，两个客户端套接字都可以自由地相互对话了。侦听器套接字可以自由地接受任何新的连接请求。这就是为什么我们在服务器上需要两种类型的套接字。如果侦听器套接字开始与客户机的客户机套接字对话，那么在连接终止之前，没有其他人能够连接到服务器。

我提到侦听器套接字绑定到一个 IP 地址和端口号。因此，套接字只能接收发送到该 IP 和端口的数据。假设一台机器有多个以太网接口，每个接口都有不同的 IP 地址。如果我们只想接受来自其中一个接口的请求，我们可以绑定到该接口的 IP 地址。类似地，如果我们绑定到虚拟本地主机接口(127.0.0.1)，我们只能接受来自同一台机器的请求。如果我们不关心请求的目的地是哪个 IP 地址，那么我们可以绑定到 IP 地址 0.0.0.0。

绑定后，需要开始监听套接字。为此，将调用 listen 方法。这是套接字成为侦听器套接字并可用于连接请求的时候。接下来，要实际等待连接请求并在它到达时接受它，需要调用 accept 方法。这是一个阻塞函数(默认情况下，除非我们使用非阻塞套接字，我们还不需要担心这一点)，它将阻塞，直到连接请求到达。当请求到达时，它将创建一个新的客户端套接字，建立连接，并返回客户端套接字和绑定到连接另一端的套接字的地址。

在我们的服务器中，我们创建一个监听器套接字，绑定它，并在服务器类中监听它。

设置监听器套接字

在服务器类中，我们使用发送给我们的配置找到地址和端口号来绑定侦听器套接字。代码非常简洁，一目了然。唯一未知的是传递给 listen 方法的 backlog 参数。

Backlog 指定当服务器忙于接受其他连接时，操作系统应该在队列中保留多少个连接请求。如果服务器负载过重，它可能无法立即接受所有传入的连接。一旦挂起的连接数超过了积压，任何新的连接请求都会立即失败。这个数字是作为一个配置元素提供的，这样服务器的用户就可以决定队列应该有多大。

队列越大，操作系统用于保持这些连接的资源就越多。阅读 StackOverflow 上的这个[回答，获得关于积压的更详细的讨论。](https://stackoverflow.com/questions/4253454/question-about-listening-and-backlog-for-sockets/4254062#4254062)

# 处理连接

既然我们的套接字已经设置为侦听传入的连接，我们需要调用套接字的 accept 方法。如前所述，这个方法会一直阻塞，直到有新的连接进来。然后，它将返回为与客户机通信而创建的新客户机套接字。

这是我们需要考虑下一步该做什么的时候。我们有一个客户端套接字，客户端将通过它发送请求消息。我们需要调用`recv`方法来等待消息到达，一旦消息到达，就处理它。但是，如果我们开始等待客户端发送数据，然后处理它，那么在此之前，我们无法接受另一个连接。记住，要接受任何新的连接，我们需要调用 accept 方法。

一般来说，服务器是一个无限循环，其中 accept 方法被一次又一次地调用，以接受任何到达的新连接。我们希望能够尽快处理一个连接的请求，这样我们就可以再次调用 accept 并处理新的连接。

但是快速处理请求并不总是可能的。如果客户端发送请求很慢怎么办？如果我们需要做的处理非常耗时，该怎么办？如果我们需要通过网络访问其他系统(比如数据库服务器)来满足请求，该怎么办？如果我们开始处理任何一个请求，所有其他客户端都将被阻塞。想象一下，因为别人连接了你最喜欢的网站而无法连接。

因此，我们必须将客户端套接字的处理委托给一个单独的任务，该任务可以在我们尝试和接受新连接时并发运行。我特意使用了*任务*这个词，因为我们可以在这里使用任何并发模型。不同的选择会有不同的权衡，应该根据我们试图使用服务器服务的应用程序的特征来做出选择。在我们的例子中，让我们使用操作系统线程作为并发模型。

我们希望每个客户端套接字由一个线程提供服务。但是这有几个问题。如果我们在每次接收连接时都创建一个新线程，我们将会增加请求处理的延迟，因为创建线程需要一些时间。另一个问题更严重。如果服务器负载过重，甚至受到攻击，我们可能每秒钟收到数千个请求。如果我们创建同样多的线程，那么操作系统将会停止，从而阻止我们成功地服务任何请求。

为了克服这两个问题，我们将有一个预先创建的线程池来处理请求。池中可用的线程数量将从配置文件中选取。应该根据可用的硬件资源、处理请求所需完成的工作类型以及服务器上的预期负载来设置该数量。当所有线程都忙时，客户机套接字将被放入一个队列中，并在一个线程可用时得到服务。

我们不能在这里有一个无限的队列，因为在负载很重的情况下，它会再次关闭服务器。因此，队列需要有固定的大小。如果队列已满，对它的 PUT 调用将会阻塞。我们不想无限期地阻止它，所以我们将在那里设置一个超时。如果我们不能在超时前将连接添加到队列中，那么我们将向客户端返回一个错误( *503 服务不可用*)。

工作线程同时处理请求

当请求被一个线程获取并进行处理时，我们需要实际读取请求并发送响应的地方就会调用 process 方法。因为我们在这里没有一个实际的应用程序，现在我们将总是发送回一个硬编码的响应。一旦发送了响应，通信就完成了，因此，我们关闭了套接字。HTTP 允许客户端请求服务器不要关闭连接。

这是因为客户端可能希望向同一服务器发出更多的请求，因此为每个请求创建一个新的连接是不必要的工作。客户端可以通过 HTTP 请求中的 Keep-Alive 报头来表明它的愿望。服务器可以选择接受这个请求，也可以像我们一样忽略它。我们甚至没有查看请求，而且，不管客户要求什么，我们都返回了相同的虚假响应。

我们确实通过调用`recv`方法读取了一部分请求数据。此方法正在阻塞，直到至少有一个字节可供读取时才会返回。因此，不超时调用`recv`并不是一个好主意。想象一下，如果攻击者想要关闭您的服务会发生什么。它们可以创建许多连接，但实际上从不发送任何数据。您的 receive 调用将无限期地阻塞以等待数据到达，同时，您的池中的所有线程都将被阻塞，从而无法为真正用户的任何其他请求提供服务。我们可以在创建套接字时通过设置一个标志(`SO_RCVTIMEO`)来设置套接字的`recv`超时。然后，如果超时发生，我们可以向客户端发送一个响应，带有 *408 请求超时*错误代码。

虽然我们没有处理一些错误/安全场景，也没有实际解析 HTTP 请求，但是我们已经构建了一个实际的 HTTP 服务器。它在现实世界中不是很有用，但它确实告诉你事物内部是如何工作的，以及在构建这样一个应用程序时我们需要考虑什么样的事情。服务器的下一个职责是解析传入的 HTTP 请求，然后将它交给应用程序，应用程序将产生响应。因为我们还没有使用这个服务器的应用程序，所以我们现在只处理请求解析。

# HTTP 请求解析

典型的 HTTP 请求如下所示

```
POST /test HTTP/1.1
Host: foo.example
Content-Type: application/x-www-form-urlencoded
Content-Length: 27

field1=value1&field2=value2
```

第一行包含 HTTP 方法/动词，后跟资源 URL，以 HTTP 版本结束。在这一行之后是可变数量的行，每一行包含一个标题和值，用冒号分隔。当所有的标题都完成后，会有一个空行，空行后面的就是正文。Content-Length 头部告诉主体有多长，以便服务器可以读取这些字节，然后知道它不需要等待更多的数据到达。

上述所有数据可能不会马上到达。因此，需要多次调用套接字的`recv`方法，直到解析出完整的请求。虽然编写解析器的逻辑并不复杂，但是编写解析器却很乏味。让我们用一个图书馆来做这件事。我们将使用 [http 解析器](https://pypi.org/project/http-parser/)库。让我们修改流程函数，以便解析请求。

HTTP 请求解析

最后，我们也解析了请求。我们仍然发送回硬编码的响应，因为我们还没有一个应用程序可以为我们生成有效的响应。这是下一篇的主题。但是现在我们能够在我们的机器上运行这个服务器，并通过浏览器或任何其他 HTTP 客户端(如 cURL 或 Postman)访问它。

# 下一个

接下来，我们需要找出一种方法，让应用程序代码可以由我们的服务器加载，这样我们就可以将解析后的 HTTP 请求传递给它，它可以为我们生成一个比迄今为止硬编码的响应更有用的响应。这就是 WSGI 的用武之地。在下一部的[中，我们将了解这一切。](https://medium.com/@vaibhav_sinha/writing-your-own-http-server-implementing-wsgi-97706588ac20)