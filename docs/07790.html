<html>
<head>
<title>How To Avoid Bottlenecks in Node.js Applications</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何避免Node.js应用程序中的瓶颈</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/how-to-avoid-bottlenecks-in-node-js-applications-8085d86b6b2e?source=collection_archive---------1-----------------------#2021-02-19">https://betterprogramming.pub/how-to-avoid-bottlenecks-in-node-js-applications-8085d86b6b2e?source=collection_archive---------1-----------------------#2021-02-19</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="dec4" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">配置Sequelize和Mongoose来处理并发的数据密集型请求</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/07979ac6e5d2210d9c0b9709e3746a8e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*lSsxByt0IJ0H9eMsCr8ZUw.jpeg"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">约书亚·阿拉贡在<a class="ae ky" href="https://unsplash.com/s/photos/coding?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片。</p></figure><p id="7a8b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">最近，我在<a class="ae ky" href="https://nodejs.org/" rel="noopener ugc nofollow" target="_blank"> Node.js </a>中处理了一个巨大的性能问题。我用<a class="ae ky" href="https://sequelize.org/" rel="noopener ugc nofollow" target="_blank"> Sequelize </a>和<a class="ae ky" href="https://mongoosejs.com/" rel="noopener ugc nofollow" target="_blank">mongose</a>构建的后端经常几分钟都无法响应任何请求。</p><p id="9d4e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们看看我是如何识别瓶颈的，为什么Node.js开发人员会遇到这样的问题，以及如何避免它们。</p><div class="lv lw gp gr lx ly"><a href="https://medium.com/quick-code/what-a-recurring-outofmemory-error-taught-me-11f2061063a1" rel="noopener follow" target="_blank"><div class="lz ab fo"><div class="ma ab mb cl cj mc"><h2 class="bd iu gy z fp md fr fs me fu fw is bi translated">处理Spring Boot的记忆缺失错误</h2><div class="mf l"><h3 class="bd b gy z fp md fr fs me fu fw dk translated">一个重复出现的OutOfMemoryError异常教会了我什么</h3></div><div class="mg l"><p class="bd b dl z fp md fr fs me fu fw dk translated">medium.com</p></div></div><div class="mh l"><div class="mi l mj mk ml mh mm ks ly"/></div></div></a></div></div><div class="ab cl mn mo hx mp" role="separator"><span class="mq bw bk mr ms mt"/><span class="mq bw bk mr ms mt"/><span class="mq bw bk mr ms"/></div><div class="im in io ip iq"><h1 id="088c" class="mu mv it bd mw mx my mz na nb nc nd ne jz nf ka ng kc nh kd ni kf nj kg nk nl bi translated">检测瓶颈</h1><p id="b83e" class="pw-post-body-paragraph kz la it lb b lc nm ju le lf nn jx lh li no lk ll lm np lo lp lq nq ls lt lu im bi translated">在意识到问题出在别处之前，我已经监测了我的VPS好几天，没有发现任何令人担忧的事情。应用程序使用的每个数据库都有自己的VPS。数据非常大——数以亿计的记录——但我使用的16GB 4 CPU VPSs从未使其资源饱和。尽管如此，问题仍然存在。</p><p id="ee9a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">当监控应用程序和数据库时，我发现一切似乎都很好，即使我的后端正在努力响应。</p><p id="2ae1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">首先，我必须复制这个问题。为此，我强调了我的申请。经过一些测试后，我能够重现这个问题。只有在处理大型查询时才会出现这种情况，但CPU密集型操作不会出现这种情况。</p><p id="63d6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">为了了解发生了什么，我开始监视以下查询的结果:</p><pre class="kj kk kl km gt nr ns nt nu aw nv bi"><span id="7ec0" class="nw mv it ns b gy nx ny l nz oa"><a class="ae ky" href="https://dev.mysql.com/doc/refman/8.0/en/show-processlist.html" rel="noopener ugc nofollow" target="_blank">SHOW PROCESSLIST</a></span></pre><p id="1310" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">通过这个特殊的查询，MySQL返回一个进程列表，指示服务器中执行的线程组当前正在执行的操作。</p><p id="319a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">答对了。通过观察这个查询的结果，同时强调我的应用程序，我能够理解问题的起源。我的Express应用程序一次使用的进程不超过五个，对额外的请求进行排队。</p></div><div class="ab cl mn mo hx mp" role="separator"><span class="mq bw bk mr ms mt"/><span class="mq bw bk mr ms mt"/><span class="mq bw bk mr ms"/></div><div class="im in io ip iq"><h1 id="3931" class="mu mv it bd mw mx my mz na nb nc nd ne jz nf ka ng kc nh kd ni kf nj kg nk nl bi translated">什么是连接池？</h1><p id="3f75" class="pw-post-body-paragraph kz la it lb b lc nm ju le lf nn jx lh li no lk ll lm np lo lp lq nq ls lt lu im bi translated">打开和关闭数据库连接涉及CPU时间和内存，因此它们是开销很大的操作。因此，如果应用程序为每个数据库请求打开一个新的连接，对性能的影响将是巨大的。</p><p id="b295" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">为了节省资源和重用连接，大多数<a class="ae ky" href="https://www.jdatalab.com/information_system/2017/02/16/database-driver.html" rel="noopener ugc nofollow" target="_blank">数据库驱动程序</a>使用不同的方法。每次需要对数据库执行操作时，他们不是建立一个新的连接，而是从一个特殊的缓存中借用一个连接。一旦要求的操作结束，他们就把它归还，释放它。这个特殊的缓存被称为<a class="ae ky" href="https://en.wikipedia.org/wiki/Connection_pool" rel="noopener ugc nofollow" target="_blank">连接池</a>。</p><p id="5768" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这种方法的缺点是，当达到连接池限制时，任何新请求都必须等待前一个请求释放连接。</p><p id="b46f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这就是为什么应该仔细选择池的大小。如果您的数据不是很大，或者您不希望有很多并发用户，您可能不会遇到任何问题。否则，这很容易成为你的应用程序的瓶颈。</p><p id="ec10" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">连接池的大小通常在每个数据库驱动程序中都是可配置的。默认池大小因驱动程序而异。为了找到正确的值，需要考虑的最重要的方面是预期的应用程序负载和并发级别。</p><p id="3c4b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们看看Sequelize和Mongoose中默认的连接池大小值是多少，以及如何配置它。</p></div><div class="ab cl mn mo hx mp" role="separator"><span class="mq bw bk mr ms mt"/><span class="mq bw bk mr ms mt"/><span class="mq bw bk mr ms"/></div><div class="im in io ip iq"><h1 id="54a6" class="mu mv it bd mw mx my mz na nb nc nd ne jz nf ka ng kc nh kd ni kf nj kg nk nl bi translated">在序列中配置连接池大小</h1><p id="af5d" class="pw-post-body-paragraph kz la it lb b lc nm ju le lf nn jx lh li no lk ll lm np lo lp lq nq ls lt lu im bi translated">每当您的应用程序连接到数据库时，它实际上会派生一个新的进程来完成请求。</p><p id="72f0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">正如<a class="ae ky" href="https://sequelize.org/master/manual/connection-pool.html" rel="noopener ugc nofollow" target="_blank">官方文档</a>中所述，Sequelize在初始化时设置一个连接池，可以通过构造函数的<code class="fe ob oc od ns b">options</code>参数进行配置。</p><p id="e201" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">默认情况下，该池仅限于<code class="fe ob oc od ns b">5</code>个连接。这意味着无论收到多少请求，您的应用程序一次使用的连接都不会超过五个。如前所述，如果六个用户同时访问任何需要连接到数据库的API，其中一个将会排队等待。</p><p id="5db6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">当调用<a class="ae ky" href="https://sequelize.org/master/class/lib/sequelize.js~Sequelize.html#instance-constructor-constructor" rel="noopener ugc nofollow" target="_blank">序列化构造函数</a>时，可以通过改变<code class="fe ob oc od ns b">pool.max</code>参数值来修改该值，如下所示:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oe of l"/></div></figure><p id="475d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">请注意，<code class="fe ob oc od ns b">max</code>属性的正确值也取决于您的MySQL服务器配置。</p><p id="07fe" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">请记住，<a class="ae ky" href="https://dev.mysql.com/doc/refman/5.6/en/mysqld.html" rel="noopener ugc nofollow" target="_blank"> mysqld </a>实际上只允许<code class="fe ob oc od ns b"><a class="ae ky" href="https://dev.mysql.com/doc/refman/5.6/en/server-system-variables.html#sysvar_max_connections" rel="noopener ugc nofollow" target="_blank">max_connections</a></code>个客户端连接，外加一个为拥有<code class="fe ob oc od ns b"><a class="ae ky" href="https://dev.mysql.com/doc/refman/5.6/en/privileges-provided.html#priv_super" rel="noopener ugc nofollow" target="_blank">SUPER</a></code>权限的帐户保留的额外连接。在MySQL 5.6中，它的默认值是151。</p><p id="f68e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">当到达<code class="fe ob oc od ns b">max_connections</code>时，服务器拒绝任何其他连接——这与在应用层发生的情况相反，在应用层请求被排队。</p><p id="e702" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">为<code class="fe ob oc od ns b">max_connections</code>找到一个好的值是复杂的，这不是本文要讨论的。相反，我推荐阅读MySQL官方文档中的<a class="ae ky" href="https://dev.mysql.com/doc/refman/5.6/en/connection-interfaces.html" rel="noopener ugc nofollow" target="_blank">这一页</a>。</p></div><div class="ab cl mn mo hx mp" role="separator"><span class="mq bw bk mr ms mt"/><span class="mq bw bk mr ms mt"/><span class="mq bw bk mr ms"/></div><div class="im in io ip iq"><h1 id="440e" class="mu mv it bd mw mx my mz na nb nc nd ne jz nf ka ng kc nh kd ni kf nj kg nk nl bi translated">在Mongoose中配置连接池大小</h1><p id="1d1b" class="pw-post-body-paragraph kz la it lb b lc nm ju le lf nn jx lh li no lk ll lm np lo lp lq nq ls lt lu im bi translated">当使用Mongoose处理MongoDB时，也会出现完全相同的问题。</p><p id="f2b9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">正如<a class="ae ky" href="https://mongoosejs.com/docs/connections.html#connection_pools" rel="noopener ugc nofollow" target="_blank">官方文档</a>中所述，每个<code class="fe ob oc od ns b">connection</code>——无论是用<code class="fe ob oc od ns b">mongoose.connect</code>还是<code class="fe ob oc od ns b">mongoose.createConnection</code>创建的——都有一个内部可配置的连接池作为支持。再次，<strong class="lb iu"> </strong>其默认最大值为<code class="fe ob oc od ns b">5</code>。</p><p id="e57d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">调用<code class="fe ob oc od ns b"><a class="ae ky" href="https://mongoosejs.com/docs/connections.html#options" rel="noopener ugc nofollow" target="_blank">mongoose.connect</a></code>时，您可以通过改变<code class="fe ob oc od ns b">poolSize</code>选项值来修改该值，如下所示:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oe of l"/></div></figure><p id="4eed" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">至于MySQL，<code class="fe ob oc od ns b">poolSize</code>值应该基于您的MongoDB服务器配置。具体来说，<code class="fe ob oc od ns b"><a class="ae ky" href="https://docs.mongodb.com/manual/reference/program/mongos/#bin.mongos" rel="noopener ugc nofollow" target="_blank">mongos</a></code>或<code class="fe ob oc od ns b"><a class="ae ky" href="https://docs.mongodb.com/manual/reference/program/mongod/#bin.mongod" rel="noopener ugc nofollow" target="_blank">mongod</a></code>将接受的最大同时连接数由<code class="fe ob oc od ns b"><a class="ae ky" href="https://docs.mongodb.com/manual/reference/configuration-options/#net.maxIncomingConnections" rel="noopener ugc nofollow" target="_blank">maxIncomingConnections</a></code>定义。在MongoDB 4.4中，<strong class="lb iu"> </strong>其默认值为65536。</p><p id="4fbc" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">根据<a class="ae ky" href="https://docs.mongodb.com/manual/reference/configuration-options/#net.maxIncomingConnections" rel="noopener ugc nofollow" target="_blank"> MongoDB文档</a>，该参数的值应该大于连接池的最大大小。</p><p id="5334" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">请记住，处理<code class="fe ob oc od ns b">maxIncomingConnections</code>参数可能很棘手，如果没有很好的理由，你不应该改变它。</p></div><div class="ab cl mn mo hx mp" role="separator"><span class="mq bw bk mr ms mt"/><span class="mq bw bk mr ms mt"/><span class="mq bw bk mr ms"/></div><div class="im in io ip iq"><h1 id="410c" class="mu mv it bd mw mx my mz na nb nc nd ne jz nf ka ng kc nh kd ni kf nj kg nk nl bi translated">结论</h1><p id="bb9d" class="pw-post-body-paragraph kz la it lb b lc nm ju le lf nn jx lh li no lk ll lm np lo lp lq nq ls lt lu im bi translated">在本文中，我们研究了连接池如何成为Node.js应用程序中的瓶颈。了解什么是连接池及其工作原理对于理解如何正确配置它至关重要。事实上，Sequelize和Mongoose的默认限制可能会对应用程序的性能产生不利影响。如图所示，在处理并发数据密集型请求时尤其如此。</p><p id="de82" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">感谢阅读！我希望这篇文章对你有所帮助。如果有任何问题、意见或建议，请随时联系我。</p></div></div>    
</body>
</html>