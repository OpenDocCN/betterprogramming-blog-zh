# 可组合的反应式用户界面—预览

> 原文：<https://betterprogramming.pub/composable-reactive-ui-preview-d197cbbc0a71>

## 通过制作 ToDo 应用程序展示 CRUI 功能

![](img/d8933d81c9c8f4357672ed1900eab66b.png)

用户界面(UI 从现在开始)是面向用户的应用程序确保最大参与度的最重要因素之一，然而构建它们并不容易。

使构建 UI 具有挑战性的是它们的动态性、有状态性和交互性；每个用户的动作都会改变应用程序状态的某个部分，并可能引发许多其他副作用，比如从服务器请求一些新的信息，切换语言等…

与编程一样，我们有许多方法来解决同一个问题，并且解决方案根据上下文的不同而不同。

CRUI(Composable Reactive UI)是一个新的库，通过以声明的方式关注反应性，同时确保一切都可以很好地组合在一起，来帮助您为 Web 应用程序构建出色的 UI。

**免责声明:** *CRUI 目前只有 Typescript 版本，还在 alpha 阶段！从现在开始，你会读到的所有东西都会发生巨大的变化。
本文使用的版本为* `*0.1.0-alpha.11*`

# ToDo 示例

按照惯例，让我们制作一个 ToDo 应用程序来展示 CRUI 功能。

如果您不熟悉，我们的验收标准将是:

*   向待办事项列表添加新任务
*   显示待办事项列表
*   按可见性过滤待办事项:
    *所有
    *要完成的任务
    *已经完成

因此，我们的应用程序的主要组件将是:

*   标题
*   添加新的
*   待办事项列表
*   过滤

先从最简单的说起:题目。

## 标题

标题是一个静态组件，它不会因任何用户交互而改变。在 CRUI 中实现这一点非常简单:

恭喜，我们刚刚声明了我们的第一个组件！

这里我们声明 Title 是一个带有子文本节点`TODO App`的`h1`标签。
我们使用`hc`来声明一个带有子元素的元素，而`text`用于创建一个文本节点。使用文本节点对于防止 XSS 攻击很重要，默认情况下，这是使用 CRUI 插入文本的唯一方法。

如果您熟悉 React，您可能会对直接为孩子使用数组感到惊讶，但对于 CRUI，这完全没问题，而且确实有助于可组合性。

考虑到用文本显示元素很常见，我们也有一个快捷方式:

组件只是需要做什么的定义，要实际呈现它，我们需要将它安装在 DOM 中:

第三个参数是上下文，您可以忽略这个细节，因为本文不会涉及到它。

## 投入

现在让我们关注与用户的交互。我们希望他们能够在列表中输入新的待办事项。

我们将需要一个输入标签，让我们也给它添加一些样式:

是通用元素，也是大多数其他元素的基础。它接收一个`Setup`，在这种情况下，它将为这个特定的元素设置`className`属性。

鉴于我们使用的是 Typescript，`props`将确保只传递有效的属性，因此您不可能错误地使用`class`。

为了使这个组件有用，我们还需要提取用户输入的值:

`on`将设置一个特定事件，在本例中为`input`事件。考虑到我们还需要设置`props`，我们需要使用`sc2`:**s**etup**c**om bine 2 将两个设置合并为一个。

## 反应

这个`core`包是关于可组合性和构建 ui 的，因此，它根本不关心设计的反应性，它只是设置了支持它的基础。

这种选择的一个好结果是，CRUI 中的 reactivity 只是一个库，因此可以用许多不同的方式实现。

CRUI 官方 R 来自`@crui/reactive`包:

这里我们再次声明了我们的输入组件，但是这次我们用 StreamBox 绑定了它的值。

我们决定避免虚拟 DOM，而是使用流作为反应性构建块。流在概念上是可观察的:每次`$box`中的值改变时，它都会通知所有的观察者。

`bindValue`将确保`$box`和输入值始终同步，相应地改变两侧。

这意味着如果我们运行:

```
$box.set('hello!')
```

输入值也会立即改变。

## 使服从

既然我们有了捕捉用户输入的好方法，我们需要一个按钮来触发新 todo 的创建:

`sc`将任意数量的`Setup`组合成一个。
`ctext`是`child`和`text`的组合，因此会增加一个新的文本节点。
顾名思义，`onClick`会设置一个`click`事件处理程序。

声明部分现在应该很熟悉了，重要的是理解如何实际执行这个操作。

从概念上讲，我们需要从输入中获取值，然后将它放入某种 todo 列表中。就像在生活中，当你不知道如何做某事时，就去问别人！

细心的读者会注意到，我们也在清理，确保一个美好的 UX。

## 添加更多结构

如果你想以库的形式发布一个组件，只公开我们需要的是最好的方法，但是，如果我们想在这里构建一个应用程序，我们可以更进一步，给它更多的结构:

请记住，由于订阅机制的工作方式，垃圾收集器将无法清理流，因此在不需要时销毁它们以避免内存泄漏非常重要。

理解流的所有者(即:谁将破坏它)是正确使用流的基础，但是跟踪它可能是棘手的，并且容易出现错误。猜猜谁擅长记录？一个编译器！

这就是为什么我们提供了一套接口，使工作与流相当愉快。让我们来关注一下`getInput`型签名:

```
getInput(): RW$B<string>
```

这个有趣的返回类型代表**R**EAD-**W**rite**$**Stream**B**ox，它给了我们一个可以自由操纵，但不能破坏的流！为了能够被破坏，它还应该包括接口`Destroyable`。通过限制暴露类型，我们确保没有其他人可以破坏它，同时也承诺我们会保护它。

新的 submit 元素将类似于:

## 更新输入

setup `bindValue`期望对所提供的流拥有完全的所有权，这意味着它将销毁它。然而，我们刚刚说过，TodoStore 是输入流的实际所有者，因此我们需要克隆所提供流的读写版本，这正是`cloneRW`所做的。

## AddTodo

现在我们已经拥有了创建 AddTodo 所需的全部内容:

## 待办事项列表

我们需要显示一个所有待办事项的列表，我们已经有了这样一个列表，所以我们可能会写类似这样的内容:

这将为第一次渲染工作，但同样没有反应的知识。

我们需要另一个流，而`@crui/reactive`提供了一个优化列表的流:StreamList。

```
type TodoList = R$L<Todo>
```

在这里，我们将暴露类型进一步限制为**R**EAD**$**stream**L**ist，因此我们只能从中读取值，而不能更改或破坏它。

唯一值得一提的是，`DRW$L`代表**D**estroyable**R**EAD-**W**rite**$**stream**L**ist。

接下来是实际的待办事项列表:

TodoList 现在是反应式的，每个新的 todo 都会像预期的那样自动添加到 DOM 中。

## 切换待办事项状态

我们的 Todo 目前只是文本，但我们也需要将其标记为已完成:

到现在为止，您应该已经意识到这是多么具有宣示性了。通过查看类型，您可以推断出`done`属性将随着时间而改变，而`text`将保持不变。

让我们更新我们的 TodoStore:

然后是我们的 Todo 元素:

待办事项文本附近将显示一个复选框。值得一提的是，`bindChecked`将只适用于`input` HTML 标签，如果你试图通过其他任何东西，Typescript 会抱怨！`bindChecked`也会将输入`type`属性设置为`checkbox`。

在`hcc`中，我们进一步抽象了具有 CSS 类和子元素的元素的概念，这对于创建小的、集中的实用函数来说是很棒的，这使得代码更易于维护。

## 过滤器

接下来，我们需要处理 3 个过滤器。为了建立它们，我们首先必须从可见性的概念开始，即:我们可以过滤什么。

```
enum Visibility {
    ALL,
    TODO,
    DONE,
}
```

单个过滤器可以只是一个将设置适当可见性的按钮:

我们将收到一个可见性的读写流和一个由这个特定过滤器表示的可见性。

值得一提的是，`map`将创建另一个 StreamBox，它将相应地更新其父流；一旦不再需要，就会清理干净。

现在让我们更新商店以支持可见性:

我们只包括了我们需要添加到前面的 TodoStore 定义中的内容，以便不使读者感到困惑。

## 过滤

这个现在很简单:

## 过滤 TodoList

即使我们添加了可见性的概念，我们的列表也不知道它。

我们的列表需要对 3 种不同的用户交互做出反应:

*   一个新项目被推入列表
*   应用了新的可见性过滤器
*   todo 项目状态被切换

我们已经讨论了第一种情况，并且已经有了一个可见性流，所以我们可以将它放入谓词流中:

```
Predicate<T> = (val: T) => boolean
```

我们的第一次尝试可能是:

这可以做到，但是切换 todo 项目状态不会再次激活过滤器逻辑，所以我们真正需要的是我们称之为谓词流的流:

```
$Predicate$<T> = R$B<Predicate$<T>>
Predicate$<T> = (val: T) => DR$B<boolean>
```

TodoStore 将成为:

`clone`将创建一个只读的、可销毁的流副本，这有助于避免代码的其他部分与原始流混淆。

最难的部分已经完成了，现在我们可以声明我们的 TodoList 被一个$Predicate$过滤。幸运的是，有一个函数可以做到这一点:

`c$filter$$`类似于`c$map`，但是除了映射项目之外，它还会相应地过滤它们。考虑到它期望过滤器生成一个布尔流，一旦不再需要它们，它也会负责销毁所有的布尔流。切换过滤器会破坏当前的过滤器逻辑和它使用的所有流，这就是为什么使用`clone`很重要。

我想指出的一点是，这个函数和`c$map` **都不会在每次有变化时重新计算整个列表**，而是会根据流更新来外科手术式地更新 DOM。这意味着从列表中添加/删除元素的算法复杂度与`Array.prototype.splice`相同。

这是拼图的最后一块，我们的实现也随之结束了！你可以在 GitHub 上看到完整的例子: [CRUI Todos](https://github.com/cruijs/crui/tree/master/packages/eg-reactive-todos)

# 谢谢大家！

如果你一直读到这里，非常感谢，非常感激！

我希望这至少能激起你的兴趣。我正计划发布更多的文章:一篇关于事物如何在幕后工作，另一篇解释这个库背后的动机。

敬请期待，下期再见！