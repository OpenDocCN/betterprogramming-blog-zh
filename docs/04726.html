<html>
<head>
<title>How to Build an App to Display Maps and Routes With Apple’s MapKit</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何建立一个应用程序，用苹果的地图工具包显示地图和路线</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/how-to-build-a-maps-and-routes-app-with-mapkit-f7b1be8cfffb?source=collection_archive---------7-----------------------#2020-05-04">https://betterprogramming.pub/how-to-build-a-maps-and-routes-app-with-mapkit-f7b1be8cfffb?source=collection_archive---------7-----------------------#2020-05-04</a></blockquote><div><div class="fc ii ij ik il im"/><div class="in io ip iq ir"><div class=""/><div class=""><h2 id="9a7b" class="pw-subtitle-paragraph jr it iu bd b js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki dk translated">向你的用户展示如何到达某个地方</h2></div><figure class="kk kl km kn gu ko gi gj paragraph-image"><div role="button" tabindex="0" class="kp kq di kr bf ks"><div class="gi gj kj"><img src="../Images/50e753932f731f3be3d873b3f1550492.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*j9s_VQMC6QB66D0K66wMow.jpeg"/></div></div><p class="kv kw gk gi gj kx ky bd b be z dk translated">Sebastian Hietsch 在<a class="ae kz" href="https://unsplash.com/s/photos/maps?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</p></figure><figure class="kk kl km kn gu ko gi gj paragraph-image"><a href="https://raulferrer.dev"><div class="gi gj la"><img src="../Images/4559de80fb63bfa9a7c3d7a9ceaa962f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*JG2ALPF7dH51wuAxTnReEQ.png"/></div></a></figure><p id="1845" class="pw-post-body-paragraph lb lc iu ld b le lf jv lg lh li jy lj lk ll lm ln lo lp lq lr ls lt lu lv lw in bi translated">你有没有注意到有多少应用程序向我们展示了他们给我们定位的地图，指出附近有趣的地方，标记路线…？在本文中，我将解释如何用<a class="ae kz" href="https://developer.apple.com/documentation/mapkit" rel="noopener ugc nofollow" target="_blank"> MapKit </a>构建一个地图和路线应用程序。</p><p id="66f0" class="pw-post-body-paragraph lb lc iu ld b le lf jv lg lh li jy lj lk ll lm ln lo lp lq lr ls lt lu lv lw in bi translated">但是什么是地图工具包呢？MapKit是一个Apple框架，其操作基于API和来自Apple Maps的数据，因此您可以轻松地将地图添加到为iOS开发的应用程序中。</p><p id="d0b6" class="pw-post-body-paragraph lb lc iu ld b le lf jv lg lh li jy lj lk ll lm ln lo lp lq lr ls lt lu lv lw in bi translated">这个项目可以在<a class="ae kz" href="https://github.com/raulferrerdev/MapKitTracker" rel="noopener ugc nofollow" target="_blank"> GitHub </a>上找到全文:</p><div class="lx ly gq gs lz ma"><a href="https://github.com/raulferrerdev/MapKitTracker" rel="noopener  ugc nofollow" target="_blank"><div class="mb ab fp"><div class="mc ab md cl cj me"><h2 class="bd iv gz z fq mf fs ft mg fv fx it bi translated">raulferrerdev/MapKitTracker</h2><div class="mh l"><h3 class="bd b gz z fq mf fs ft mg fv fx dk translated">在GitHub上创建一个帐户，为raulferrerdev/MapKitTracker的开发做出贡献。</h3></div><div class="mi l"><p class="bd b dl z fq mf fs ft mg fv fx dk translated">github.com</p></div></div><div class="mj l"><div class="mk l ml mm mn mj mo kt ma"/></div></div></a></div><p id="e91c" class="pw-post-body-paragraph lb lc iu ld b le lf jv lg lh li jy lj lk ll lm ln lo lp lq lr ls lt lu lv lw in bi translated">Swift Think还有更多内容:</p><div class="lx ly gq gs lz ma"><a href="https://www.raulferrergarcia.com/en/blog-2/" rel="noopener  ugc nofollow" target="_blank"><div class="mb ab fp"><div class="mc ab md cl cj me"><h2 class="bd iv gz z fq mf fs ft mg fv fx it bi translated">Swift中的博客思维</h2><div class="mh l"><h3 class="bd b gz z fq mf fs ft mg fv fx dk translated">你有没有注意到有多少应用程序向我们展示了他们放置我们的地图，指出有趣的地方…</h3></div><div class="mi l"><p class="bd b dl z fq mf fs ft mg fv fx dk translated">www.raulferrergarcia.com</p></div></div><div class="mj l"><div class="mp l ml mm mn mj mo kt ma"/></div></div></a></div><h1 id="6b03" class="mq mr iu bd ms mt mu mv mw mx my mz na ka nb kb nc kd nd ke ne kg nf kh ng nh bi translated">UI设计</h1><p id="b7aa" class="pw-post-body-paragraph lb lc iu ld b le ni jv lg lh nj jy lj lk nk lm ln lo nl lq lr ls nm lu lv lw in bi translated">这个项目将基本上由一个<code class="fe nn no np nq b">MKMapView</code>组件组成，它将向我们显示地图，我们将根据我们想要添加到应用程序中的功能向它添加不同的组件。另外，在这个项目中，这一切都将通过代码来完成，不需要使用故事板或者<code class="fe nn no np nq b">.xib</code>文件。</p><figure class="kk kl km kn gu ko gi gj paragraph-image"><div class="gi gj nr"><img src="../Images/87bdeb00be13073118168b06ec201d5b.png" data-original-src="https://miro.medium.com/v2/resize:fit:728/format:webp/0*ki1DLvXvriTXNNwA.png"/></div></figure></div><div class="ab cl ns nt hy nu" role="separator"><span class="nv bw bk nw nx ny"/><span class="nv bw bk nw nx ny"/><span class="nv bw bk nw nx"/></div><div class="in io ip iq ir"><h1 id="e595" class="mq mr iu bd ms mt nz mv mw mx oa mz na ka ob kb nc kd oc ke ne kg od kh ng nh bi translated">项目的创建</h1><p id="e0c9" class="pw-post-body-paragraph lb lc iu ld b le ni jv lg lh nj jy lj lk nk lm ln lo nl lq lr ls nm lu lv lw in bi translated">要在Xcode 11中建立项目时不使用故事板，我们必须在创建项目后执行一些步骤:</p><ul class=""><li id="a9a2" class="oe of iu ld b le lf lh li lk og lo oh ls oi lw oj ok ol om bi translated">删除文件<code class="fe nn no np nq b">Main.storyboard</code>。</li><li id="b762" class="oe of iu ld b le on lh oo lk op lo oq ls or lw oj ok ol om bi translated">在General选项卡(TARGETS)中，我们转到主界面选择器并删除“Main”，将该字段留空。</li></ul><figure class="kk kl km kn gu ko gi gj paragraph-image"><div class="gi gj os"><img src="../Images/7e158afe0e1def8803eb3eb4a74b2564.png" data-original-src="https://miro.medium.com/v2/resize:fit:1182/format:webp/0*USSj72p828ocBO_I.png"/></div></figure><ul class=""><li id="d48f" class="oe of iu ld b le lf lh li lk og lo oh ls oi lw oj ok ol om bi translated">最后，在信息选项卡(目标)中，我们转到应用场景清单&gt;场景配置&gt;应用会话角色&gt;项目0(默认配置)并删除故事板名称字段。</li></ul><figure class="kk kl km kn gu ko gi gj paragraph-image"><div role="button" tabindex="0" class="kp kq di kr bf ks"><div class="gi gj ot"><img src="../Images/d27081d28734eea8a27f3f7232193b7e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*YBs6-5ZT0cPotBCU.png"/></div></div></figure><p id="28d8" class="pw-post-body-paragraph lb lc iu ld b le lf jv lg lh li jy lj lk ll lm ln lo lp lq lr ls lt lu lv lw in bi translated">由于我们不再调用<code class="fe nn no np nq b">Main.storyboard</code>来启动项目，我们转到<code class="fe nn no np nq b">SceneDelegate.swift</code>文件，在函数<code class="fe nn no np nq b">scene(_ scene: UIScene, willConnectTo session: UISceneSession, options connectionOptions: UIScene.ConnectionOptions)</code>中，用下面的代码替换它的内容:</p><figure class="kk kl km kn gu ko"><div class="bz fq l di"><div class="ou ov l"/></div></figure></div><div class="ab cl ns nt hy nu" role="separator"><span class="nv bw bk nw nx ny"/><span class="nv bw bk nw nx ny"/><span class="nv bw bk nw nx"/></div><div class="in io ip iq ir"><h1 id="66a1" class="mq mr iu bd ms mt nz mv mw mx oa mz na ka ob kb nc kd oc ke ne kg od kh ng nh bi translated">向我们的应用程序添加地图</h1><p id="aa49" class="pw-post-body-paragraph lb lc iu ld b le ni jv lg lh nj jy lj lk nk lm ln lo nl lq lr ls nm lu lv lw in bi translated">要将地图添加到屏幕上，只需创建一个<code class="fe nn no np nq b">MKMapView </code>实例并将其添加到屏幕视图中。为此，在<code class="fe nn no np nq b">ViewController</code>类中，首先我们必须导入<code class="fe nn no np nq b">MapKit</code>库，然后我们创建一个<code class="fe nn no np nq b">MKMapView</code>的实例并呈现它:</p><figure class="kk kl km kn gu ko"><div class="bz fq l di"><div class="ou ov l"/></div></figure><p id="38a8" class="pw-post-body-paragraph lb lc iu ld b le lf jv lg lh li jy lj lk ll lm ln lo lp lq lr ls lt lu lv lw in bi translated">如果我们运行该应用程序，我们将能够在屏幕上看到我们所在位置的大致地图。</p><figure class="kk kl km kn gu ko gi gj paragraph-image"><div class="gi gj ow"><img src="../Images/7623cbfa55ee0e52902a593c676c5794.png" data-original-src="https://miro.medium.com/v2/resize:fit:832/format:webp/0*k6rzh_93gbffLadT.png"/></div></figure><p id="36cf" class="pw-post-body-paragraph lb lc iu ld b le lf jv lg lh li jy lj lk ll lm ln lo lp lq lr ls lt lu lv lw in bi translated">为了让这张地图向我们显示一个准确的位置，我们必须使用<code class="fe nn no np nq b"><a class="ae kz" href="https://developer.apple.com/documentation/corelocation/cllocationmanager" rel="noopener ugc nofollow" target="_blank">CLLocationManager</a></code>类，正如Apple所指出的，它允许我们开始和结束向我们的应用程序发送位置事件:</p><ul class=""><li id="910d" class="oe of iu ld b le lf lh li lk og lo oh ls oi lw oj ok ol om bi translated">检测用户位置的变化</li><li id="e9e4" class="oe of iu ld b le on lh oo lk op lo oq ls or lw oj ok ol om bi translated">查看指南针方向的变化</li><li id="f4e1" class="oe of iu ld b le on lh oo lk op lo oq ls or lw oj ok ol om bi translated">监控感兴趣的区域</li><li id="b130" class="oe of iu ld b le on lh oo lk op lo oq ls or lw oj ok ol om bi translated">检测附近信标的位置</li></ul></div><div class="ab cl ns nt hy nu" role="separator"><span class="nv bw bk nw nx ny"/><span class="nv bw bk nw nx ny"/><span class="nv bw bk nw nx"/></div><div class="in io ip iq ir"><h1 id="71d6" class="mq mr iu bd ms mt nz mv mw mx oa mz na ka ob kb nc kd oc ke ne kg od kh ng nh bi translated">许可</h1><p id="2496" class="pw-post-body-paragraph lb lc iu ld b le ni jv lg lh nj jy lj lk nk lm ln lo nl lq lr ls nm lu lv lw in bi translated">请记住，要使用定位功能，我们必须首先征求用户的许可。为此，我们在<code class="fe nn no np nq b">Info.plist</code>文件中添加了一系列参数(正如我也向<a class="ae kz" href="https://www.raulferrergarcia.com/en/how-to-test-push-notifications-in-xcode-11-4-simulator/" rel="noopener ugc nofollow" target="_blank">显示的使用通知</a>):</p><ul class=""><li id="e8fb" class="oe of iu ld b le lf lh li lk og lo oh ls oi lw oj ok ol om bi translated">隐私—位置总是和使用时使用说明</li><li id="b82b" class="oe of iu ld b le on lh oo lk op lo oq ls or lw oj ok ol om bi translated">隐私—位置总是用法描述</li><li id="63ae" class="oe of iu ld b le on lh oo lk op lo oq ls or lw oj ok ol om bi translated">隐私—使用时的位置使用说明</li></ul><p id="9cb7" class="pw-post-body-paragraph lb lc iu ld b le lf jv lg lh li jy lj lk ll lm ln lo lp lq lr ls lt lu lv lw in bi translated">我们将向用户显示的请求许可的消息作为一个值(在这个例子中，“允许位置访问以使用这个应用”)。</p><figure class="kk kl km kn gu ko gi gj paragraph-image"><div role="button" tabindex="0" class="kp kq di kr bf ks"><div class="gi gj ox"><img src="../Images/985bc3f0eb8cbc55eb25ebe3ccbe9c32.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*jW0X5VsaCTL1EPiI.png"/></div></div></figure><p id="eaec" class="pw-post-body-paragraph lb lc iu ld b le lf jv lg lh li jy lj lk ll lm ln lo lp lq lr ls lt lu lv lw in bi translated">一旦修改了<code class="fe nn no np nq b">Info.plist</code>文件，我们将首先让应用程序检查位置服务是否启用，然后检查用户是否给予了许可以及许可的类型。我们首先要做的是实例化<code class="fe nn no np nq b">CLLocationManager</code>类:</p><figure class="kk kl km kn gu ko"><div class="bz fq l di"><div class="ou ov l"/></div></figure><p id="8366" class="pw-post-body-paragraph lb lc iu ld b le lf jv lg lh li jy lj lk ll lm ln lo lp lq lr ls lt lu lv lw in bi translated">然后，我们创建<code class="fe nn no np nq b">checkLocationService</code>方法，在该方法中，我们将检查设备上是否启用了位置服务。如果是这样，我们将按照文档中的指示为此类设置委托，并指出我们希望位置工作的精度:</p><figure class="kk kl km kn gu ko"><div class="bz fq l di"><div class="ou ov l"/></div></figure><p id="6f2e" class="pw-post-body-paragraph lb lc iu ld b le lf jv lg lh li jy lj lk ll lm ln lo lp lq lr ls lt lu lv lw in bi translated">我们将从<code class="fe nn no np nq b">viewDidLoad</code>方法中调用这个函数。在我们设置委托的同时，我们采用这个委托的几个方法，这些方法将允许我们知道用户给出的使用位置的许可是否改变(<code class="fe nn no np nq b"><a class="ae kz" href="https://developer.apple.com/documentation/corelocation/cllocationmanagerdelegate/1423701-locationmanager" rel="noopener ugc nofollow" target="_blank">locationManager (: didChangeAuthorization:</a>)</code> ) <em class="oy"> </em>，以及用户的位置<em class="oy"> </em>何时改变<em class="oy"> </em> ( <code class="fe nn no np nq b"><a class="ae kz" href="https://developer.apple.com/documentation/corelocation/cllocationmanagerdelegate/1423615-locationmanager" rel="noopener ugc nofollow" target="_blank">locationManager (: didUpdateLocations:</a>)</code>)。(我们在<code class="fe nn no np nq b">ViewController</code>类的扩展中这样做是为了组织代码。)</p><figure class="kk kl km kn gu ko"><div class="bz fq l di"><div class="ou ov l"/></div></figure><p id="1bd7" class="pw-post-body-paragraph lb lc iu ld b le lf jv lg lh li jy lj lk ll lm ln lo lp lq lr ls lt lu lv lw in bi translated">现在我们可以通过添加方法来继续完成<code class="fe nn no np nq b">ViewController</code>类，该方法将查看应用程序是否有使用本地化的权限，以及权限的类型。在这个方法中，我们所做的是调用<code class="fe nn no np nq b">CLLocationManager</code>类的<code class="fe nn no np nq b">authorizationStatus</code>方法，并检查我们得到的值:</p><figure class="kk kl km kn gu ko"><div class="bz fq l di"><div class="ou ov l"/></div></figure><p id="f4fc" class="pw-post-body-paragraph lb lc iu ld b le lf jv lg lh li jy lj lk ll lm ln lo lp lq lr ls lt lu lv lw in bi translated">可以看出，关于<a class="ae kz" href="https://developer.apple.com/documentation/corelocation/cllocationmanager/1423523-authorizationstatus" rel="noopener ugc nofollow" target="_blank">授权使用位置</a>有不同的可能性:</p><ul class=""><li id="1fc3" class="oe of iu ld b le lf lh li lk og lo oh ls oi lw oj ok ol om bi translated"><code class="fe nn no np nq b">authorizedWhenInUse</code> <strong class="ld iv"> <em class="oy">。</em> </strong>用户授权应用程序在使用中启动定位服务。</li><li id="41d6" class="oe of iu ld b le on lh oo lk op lo oq ls or lw oj ok ol om bi translated"><code class="fe nn no np nq b">authorizedAlways</code><strong class="ld iv">T27】。 </strong>用户授权应用程序随时启动定位服务。</li><li id="9d94" class="oe of iu ld b le on lh oo lk op lo oq ls or lw oj ok ol om bi translated"><code class="fe nn no np nq b">denied</code> <strong class="ld iv"> <em class="oy">。</em> </strong>用户拒绝使用应用程序的定位服务，或者在设置中全局禁用。</li><li id="0ea8" class="oe of iu ld b le on lh oo lk op lo oq ls or lw oj ok ol om bi translated"><code class="fe nn no np nq b">notDetermined</code> <strong class="ld iv"> <em class="oy">。</em> </strong>用户尚未选择应用程序是否可以使用位置服务。</li><li id="fd28" class="oe of iu ld b le on lh oo lk op lo oq ls or lw oj ok ol om bi translated"><code class="fe nn no np nq b">restricted</code> <strong class="ld iv"> <em class="oy">。</em></strong>app未被授权使用定位服务。</li></ul><p id="743b" class="pw-post-body-paragraph lb lc iu ld b le lf jv lg lh li jy lj lk ll lm ln lo lp lq lr ls lt lu lv lw in bi translated">这个函数，<code class="fe nn no np nq b">checkAuthorizationForLocation</code>，我们将在两点调用:</p><ul class=""><li id="bf30" class="oe of iu ld b le lf lh li lk og lo oh ls oi lw oj ok ol om bi translated">在<code class="fe nn no np nq b">checkLocationServices()</code>方法中设置委托后，进入应用程序后</li><li id="225a" class="oe of iu ld b le on lh oo lk op lo oq ls or lw oj ok ol om bi translated">在<code class="fe nn no np nq b">locationManager(_: didChangeAuthorization:)</code>方法中，如果用户授权在使用应用程序时发生变化</li></ul><figure class="kk kl km kn gu ko"><div class="bz fq l di"><div class="ou ov l"/></div></figure><p id="888e" class="pw-post-body-paragraph lb lc iu ld b le lf jv lg lh li jy lj lk ll lm ln lo lp lq lr ls lt lu lv lw in bi translated">如果我们现在运行这个应用程序，我们将会看到一个警告，询问我们是否允许使用定位服务。</p><figure class="kk kl km kn gu ko gi gj paragraph-image"><div class="gi gj ow"><img src="../Images/4a8863c8e4e5e7b754068dba58dbbdf1.png" data-original-src="https://miro.medium.com/v2/resize:fit:832/format:webp/0*OJgM9M_vYTYJXhf0.png"/></div></figure><p id="b4d3" class="pw-post-body-paragraph lb lc iu ld b le lf jv lg lh li jy lj lk ll lm ln lo lp lq lr ls lt lu lv lw in bi translated">一旦我们允许应用程序使用定位服务，我们要做的就是告诉它现在可以激活设备的位置跟踪。为了在<code class="fe nn no np nq b">checkAuthorizationForLocation()</code>方法中以及允许使用它的情况下做到这一点，我们添加了以下代码:</p><figure class="kk kl km kn gu ko"><div class="bz fq l di"><div class="ou ov l"/></div></figure><p id="7df6" class="pw-post-body-paragraph lb lc iu ld b le lf jv lg lh li jy lj lk ll lm ln lo lp lq lr ls lt lu lv lw in bi translated">我们在这里做的是说<code class="fe nn no np nq b">MKMapView</code>实例必须显示用户的位置(<code class="fe nn no np nq b">mapView.showsUserLocation = true</code>)，将视图集中在用户上(使用我们现在将创建的方法)，并激活位置更新。</p></div><div class="ab cl ns nt hy nu" role="separator"><span class="nv bw bk nw nx ny"/><span class="nv bw bk nw nx ny"/><span class="nv bw bk nw nx"/></div><div class="in io ip iq ir"><h1 id="d6d4" class="mq mr iu bd ms mt nz mv mw mx oa mz na ka ob kb nc kd oc ke ne kg od kh ng nh bi translated">在地图上显示我们的位置</h1><p id="4d8d" class="pw-post-body-paragraph lb lc iu ld b le ni jv lg lh nj jy lj lk nk lm ln lo nl lq lr ls nm lu lv lw in bi translated"><code class="fe nn no np nq b">centerViewOnUser()</code>方法的作用是确定用户的位置，并围绕这个点建立一个居中的矩形区域。为此我们使用<code class="fe nn no np nq b"><a class="ae kz" href="https://developer.apple.com/documentation/mapkit/mkcoordinateregion" rel="noopener ugc nofollow" target="_blank">MKCoordinateRegion</a></code>。</p><figure class="kk kl km kn gu ko"><div class="bz fq l di"><div class="ou ov l"/></div></figure><p id="a7df" class="pw-post-body-paragraph lb lc iu ld b le lf jv lg lh li jy lj lk ll lm ln lo lp lq lr ls lt lu lv lw in bi translated">在这里，我们首先确定我们有用户的位置。然后我们建立一个以用户为中心的10×10公里的区域。最后，我们在地图上建立这个区域。这样，我们在设备上获得了以下图像。</p><figure class="kk kl km kn gu ko gi gj paragraph-image"><div class="gi gj ow"><img src="../Images/4495381974aa9655b472778a58ca733a.png" data-original-src="https://miro.medium.com/v2/resize:fit:832/format:webp/0*SGqK_atuEkQUm8Gk.png"/></div></figure><p id="3794" class="pw-post-body-paragraph lb lc iu ld b le lf jv lg lh li jy lj lk ll lm ln lo lp lq lr ls lt lu lv lw in bi translated">最后，为了更新用户在地图上的位置，在方法<code class="fe nn no np nq b">locationManager(_: didUpdateLocations:)</code>中，我们做了一些类似于我们所做的事情来将视图聚焦在用户身上:</p><figure class="kk kl km kn gu ko"><div class="bz fq l di"><div class="ou ov l"/></div></figure><p id="6ebc" class="pw-post-body-paragraph lb lc iu ld b le lf jv lg lh li jy lj lk ll lm ln lo lp lq lr ls lt lu lv lw in bi translated">但是在这种情况下，位置是从方法返回的位置列表中的最后一个值获得的。</p><p id="ca58" class="pw-post-body-paragraph lb lc iu ld b le lf jv lg lh li jy lj lk ll lm ln lo lp lq lr ls lt lu lv lw in bi translated">打开应用程序时，我们默认看到的地图是标准地图。MapKit允许通过更改<code class="fe nn no np nq b">MKMapView</code>实例的<code class="fe nn no np nq b"><a class="ae kz" href="https://developer.apple.com/documentation/mapkit/mkmaptype" rel="noopener ugc nofollow" target="_blank">mapType</a></code>参数值来显示不同类型的地图:</p><ul class=""><li id="85b2" class="oe of iu ld b le lf lh li lk og lo oh ls oi lw oj ok ol om bi translated"><code class="fe nn no np nq b">standard</code>。显示所有道路位置和一些道路名称的街道地图</li><li id="ed22" class="oe of iu ld b le on lh oo lk op lo oq ls or lw oj ok ol om bi translated"><code class="fe nn no np nq b">satellite</code>。该地区的卫星图像</li><li id="97d4" class="oe of iu ld b le on lh oo lk op lo oq ls or lw oj ok ol om bi translated"><code class="fe nn no np nq b">hybrid</code>。带有道路信息及其名称的区域的卫星图像(在地图上方的图层中)</li><li id="d3b1" class="oe of iu ld b le on lh oo lk op lo oq ls or lw oj ok ol om bi translated"><code class="fe nn no np nq b">satelliteFlyover</code>。该地区的卫星图像和该地区的数据(如果有的话)</li><li id="bb7b" class="oe of iu ld b le on lh oo lk op lo oq ls or lw oj ok ol om bi translated"><code class="fe nn no np nq b">hybridFlyover</code>。来自该地区的数据的混合卫星图像(如果有的话)</li><li id="5aa1" class="oe of iu ld b le on lh oo lk op lo oq ls or lw oj ok ol om bi translated"><code class="fe nn no np nq b">muteStandard</code>。地图详细信息中突出显示我们的数据的街道地图</li></ul><p id="2729" class="pw-post-body-paragraph lb lc iu ld b le lf jv lg lh li jy lj lk ll lm ln lo lp lq lr ls lt lu lv lw in bi translated">在这种情况下，我们将只使用三种类型的地图:<code class="fe nn no np nq b">standard</code>、<code class="fe nn no np nq b">satellite</code>和<code class="fe nn no np nq b">hybrid</code>。</p><p id="d4c2" class="pw-post-body-paragraph lb lc iu ld b le lf jv lg lh li jy lj lk ll lm ln lo lp lq lr ls lt lu lv lw in bi translated">我们希望在应用程序中显示的地图类型的选择将通过一个带有下拉菜单的按钮来完成，该按钮可以作为一个Swift包(<a class="ae kz" href="https://www.raulferrergarcia.com/en/create-a-fab-button-with-swift/" rel="noopener ugc nofollow" target="_blank"> FABButton </a>)来下载。为此，我们遵循以下步骤:</p><ul class=""><li id="e6a8" class="oe of iu ld b le lf lh li lk og lo oh ls oi lw oj ok ol om bi translated">从Xcode File &gt; Swift Package &gt; Add Package dependency…菜单，我们添加FABButton组件。网址是:<a class="ae kz" href="https://github.com/raulferrerdev/FABButton.git" rel="noopener ugc nofollow" target="_blank">https://github.com/raulferrerdev/FABButton.git</a></li><li id="470b" class="oe of iu ld b le on lh oo lk op lo oq ls or lw oj ok ol om bi translated">接下来，我们创建按钮及其配置的实例(所使用的图标已经包含在<a class="ae kz" href="https://github.com/raulferrerdev/MapKitTracker" rel="noopener ugc nofollow" target="_blank">项目</a>中):</li></ul><figure class="kk kl km kn gu ko"><div class="bz fq l di"><div class="ou ov l"/></div></figure><ul class=""><li id="1cf5" class="oe of iu ld b le lf lh li lk og lo oh ls oi lw oj ok ol om bi translated">正如你所看到的，我们已经为<code class="fe nn no np nq b">FABView</code>类型设置了委托，所以我们必须让<code class="fe nn no np nq b">ViewController</code>类符合这个协议。为此，我们在项目中添加了以下扩展:</li></ul><figure class="kk kl km kn gu ko"><div class="bz fq l di"><div class="ou ov l"/></div></figure><p id="3448" class="pw-post-body-paragraph lb lc iu ld b le lf jv lg lh li jy lj lk ll lm ln lo lp lq lr ls lt lu lv lw in bi translated">最后，在<code class="fe nn no np nq b">layoutUI</code>方法中，我们将按钮添加到视图中并指示其位置:</p><figure class="kk kl km kn gu ko"><div class="bz fq l di"><div class="ou ov l"/></div></figure><p id="7a10" class="pw-post-body-paragraph lb lc iu ld b le lf jv lg lh li jy lj lk ll lm ln lo lp lq lr ls lt lu lv lw in bi translated">如果我们运行该应用程序，我们可以看到我们可以更改地图的类型:</p><figure class="kk kl km kn gu ko gi gj paragraph-image"><div role="button" tabindex="0" class="kp kq di kr bf ks"><div class="gi gj oz"><img src="../Images/a350cb2fbd26a3cd1c3bb644b1eb3a8f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*ucdKwhyOBHhmV3o_74PRoA.gif"/></div></div></figure></div><div class="ab cl ns nt hy nu" role="separator"><span class="nv bw bk nw nx ny"/><span class="nv bw bk nw nx ny"/><span class="nv bw bk nw nx"/></div><div class="in io ip iq ir"><h1 id="ad8a" class="mq mr iu bd ms mt nz mv mw mx oa mz na ka ob kb nc kd oc ke ne kg od kh ng nh bi translated">显示方向</h1><p id="8589" class="pw-post-body-paragraph lb lc iu ld b le ni jv lg lh nj jy lj lk nk lm ln lo nl lq lr ls nm lu lv lw in bi translated">现在我们要做的是在屏幕上显示地图上一个点(中心)的坐标地址，这将使用<code class="fe nn no np nq b"><a class="ae kz" href="https://developer.apple.com/documentation/corelocation/cllocation" rel="noopener ugc nofollow" target="_blank">CLLocation</a></code>类获得。为此，我们创建了一个<code class="fe nn no np nq b">getCenterLocation</code>函数，并将我们拥有的<code class="fe nn no np nq b">MKMapView</code>的实例传递给它。它将返回中心点的坐标:</p><figure class="kk kl km kn gu ko"><div class="bz fq l di"><div class="ou ov l"/></div></figure><p id="f283" class="pw-post-body-paragraph lb lc iu ld b le lf jv lg lh li jy lj lk ll lm ln lo lp lq lr ls lt lu lv lw in bi translated">为了确切地知道地图的中心是什么，我们将在地图的中心放置一个图标。我们将使用一个<code class="fe nn no np nq b">UIImageView</code>元素和一个大头针的图像(我们将从苹果的<a class="ae kz" href="https://www.raulferrergarcia.com/en/use-the-new-apple-sf-symbols-in-your-applications/" rel="noopener ugc nofollow" target="_blank"> SF Symbols </a>库中获得)来实现这一点。</p><figure class="kk kl km kn gu ko"><div class="bz fq l di"><div class="ou ov l"/></div></figure><p id="43f2" class="pw-post-body-paragraph lb lc iu ld b le lf jv lg lh li jy lj lk ll lm ln lo lp lq lr ls lt lu lv lw in bi translated">为了使大头针的底部正好位于地图的中心，我们将该图标向上移动其高度的一半(-14.5px)。</p><p id="a7a4" class="pw-post-body-paragraph lb lc iu ld b le lf jv lg lh li jy lj lk ll lm ln lo lp lq lr ls lt lu lv lw in bi translated">此外，为了显示地址，我们将在屏幕顶部放置一个标签，如设计所示。为此，我们创建了一个<code class="fe nn no np nq b">UILabel</code>实例，对其进行配置，并将其放在屏幕上:</p><figure class="kk kl km kn gu ko"><div class="bz fq l di"><div class="ou ov l"/></div></figure></div><div class="ab cl ns nt hy nu" role="separator"><span class="nv bw bk nw nx ny"/><span class="nv bw bk nw nx ny"/><span class="nv bw bk nw nx"/></div><div class="in io ip iq ir"><h1 id="e28f" class="mq mr iu bd ms mt nz mv mw mx oa mz na ka ob kb nc kd oc ke ne kg od kh ng nh bi translated">获取地址</h1><p id="d1ee" class="pw-post-body-paragraph lb lc iu ld b le ni jv lg lh nj jy lj lk nk lm ln lo nl lq lr ls nm lu lv lw in bi translated">为了从坐标中获取一个地方的地址，我们将使用<code class="fe nn no np nq b"><a class="ae kz" href="https://developer.apple.com/documentation/corelocation/clgeocoder" rel="noopener ugc nofollow" target="_blank">CLGeocoder</a></code>类，如Apple文档所示，它允许我们从一个点的经度和纬度中获取该位置的用户友好的表示:</p><blockquote class="pa pb pc"><p id="0a66" class="lb lc oy ld b le lf jv lg lh li jy lj pd ll lm ln pe lp lq lr pf lt lu lv lw in bi translated">“<code class="fe nn no np nq b">CLGeododer</code>类提供了坐标(指定为纬度和经度)和该坐标的用户友好表示之间的转换服务。用户友好的坐标表示通常包含与给定位置相对应的街道、城市、州和国家信息，但也可能包含相关的兴趣点、地标或其他识别信息。”</p><p id="0d44" class="lb lc oy ld b le lf jv lg lh li jy lj pd ll lm ln pe lp lq lr pf lt lu lv lw in bi translated">苹果文档(<code class="fe nn no np nq b"><em class="iu">CLGeocoder</em></code>)</p></blockquote><p id="f54b" class="pw-post-body-paragraph lb lc iu ld b le lf jv lg lh li jy lj lk ll lm ln lo lp lq lr ls lt lu lv lw in bi translated">为了知道地图中心点的坐标，我们将实现<code class="fe nn no np nq b">MKMapView</code>委托和每次移动地图时它收集的方法。</p><figure class="kk kl km kn gu ko"><div class="bz fq l di"><div class="ou ov l"/></div></figure><p id="b11d" class="pw-post-body-paragraph lb lc iu ld b le lf jv lg lh li jy lj lk ll lm ln lo lp lq lr ls lt lu lv lw in bi translated">在此方法中，我们执行以下操作:</p><ul class=""><li id="3369" class="oe of iu ld b le lf lh li lk og lo oh ls oi lw oj ok ol om bi translated">首先，我们得到地图中心的坐标(感谢<code class="fe nn no np nq b">getCenterLocation</code> <em class="oy"> </em>函数，我们之前已经看到了)。</li><li id="d8fb" class="oe of iu ld b le on lh oo lk op lo oq ls or lw oj ok ol om bi translated">下一步是知道是否有先前的位置(<code class="fe nn no np nq b">previousLocation</code>，我们在开始时已经实例化了)，在这种情况下，检查到新位置的距离差是否更大，在这种情况下，25米。如果满足这些条件，新坐标的值被分配给<code class="fe nn no np nq b">previousLocation</code>变量。</li><li id="2d6f" class="oe of iu ld b le on lh oo lk op lo oq ls or lw oj ok ol om bi translated">接下来，我们取一个<code class="fe nn no np nq b">CLGeocoder</code>函数的实例并调用<code class="fe nn no np nq b">reverseGeocodeLocation</code>方法，我们将屏幕中心的坐标传递给它。</li><li id="8680" class="oe of iu ld b le on lh oo lk op lo oq ls or lw oj ok ol om bi translated">该函数返回一个带有两个参数的<a class="ae kz" href="https://developer.apple.com/documentation/corelocation/clgeocodecompletionhandler" rel="noopener ugc nofollow" target="_blank">块:</a></li></ul><figure class="kk kl km kn gu ko"><div class="bz fq l di"><div class="ou ov l"/></div></figure><ul class=""><li id="f997" class="oe of iu ld b le lf lh li lk og lo oh ls oi lw oj ok ol om bi translated">在这两个值中，我们检查没有错误发生并且它返回了一个位置。<code class="fe nn no np nq b">CLPlacemark</code>对象存储关于特定纬度和经度的数据(例如国家、州、城市和街道地址、poi和地理相关数据)。</li><li id="59b8" class="oe of iu ld b le on lh oo lk op lo oq ls or lw oj ok ol om bi translated">从这些信息中，我们对两个参数感兴趣:<code class="fe nn no np nq b">thoroughfare</code>(与指定位置相关联的街道地址)和<code class="fe nn no np nq b">subThoroughfare</code>(给出关于该地址的附加信息)。</li><li id="9b37" class="oe of iu ld b le on lh oo lk op lo oq ls or lw oj ok ol om bi translated">最后，在主线程中，我们将这些信息添加到标签中。</li></ul><figure class="kk kl km kn gu ko gi gj paragraph-image"><div class="gi gj pg"><img src="../Images/c5b906283b49732b65535b76aa7a9d84.png" data-original-src="https://miro.medium.com/v2/resize:fit:1200/1*_-kjlz-gxqI6PnwNfq95kg.gif"/></div></figure></div><div class="ab cl ns nt hy nu" role="separator"><span class="nv bw bk nw nx ny"/><span class="nv bw bk nw nx ny"/><span class="nv bw bk nw nx"/></div><div class="in io ip iq ir"><h1 id="7202" class="mq mr iu bd ms mt nz mv mw mx oa mz na ka ob kb nc kd oc ke ne kg od kh ng nh bi translated">设置路线</h1><p id="57eb" class="pw-post-body-paragraph lb lc iu ld b le ni jv lg lh nj jy lj lk nk lm ln lo nl lq lr ls nm lu lv lw in bi translated">现在我们在这个项目中剩下要做的就是实现一个路由系统。也就是说，从一个起点和另一个终点开始，建立路径的最佳路线。</p><p id="5d91" class="pw-post-body-paragraph lb lc iu ld b le lf jv lg lh li jy lj lk ll lm ln lo lp lq lr ls lt lu lv lw in bi translated">多亏了MapKit，我们可以用简单的方式做到这一点。在这种情况下，我们将使用<code class="fe nn no np nq b"><a class="ae kz" href="https://developer.apple.com/documentation/mapkit/mkdirections/request" rel="noopener ugc nofollow" target="_blank">MKDirections.Request</a></code>类，它允许我们建立一个请求，在这个请求中，我们指出起点、目的地、运输类型，以及我们是否希望显示替代路线。</p><ul class=""><li id="64f6" class="oe of iu ld b le lf lh li lk og lo oh ls oi lw oj ok ol om bi translated"><code class="fe nn no np nq b">var source: MKMapItem?</code>。这是路线的起点。</li><li id="c25c" class="oe of iu ld b le on lh oo lk op lo oq ls or lw oj ok ol om bi translated"><code class="fe nn no np nq b">var destination: MKMapItem?</code>。它是路线的终点。</li><li id="bda7" class="oe of iu ld b le on lh oo lk op lo oq ls or lw oj ok ol om bi translated"><code class="fe nn no np nq b">var transportType: MKDirectionsTransportType</code>。这是适用于计算路线的运输类型。它可以是汽车，步行，交通，或任何其他。</li><li id="0a38" class="oe of iu ld b le on lh oo lk op lo oq ls or lw oj ok ol om bi translated"><code class="fe nn no np nq b">var requestsAlternateRoutes: Bool</code>。表示如果有替代路线，我们是否需要这些路线。</li><li id="5055" class="oe of iu ld b le on lh oo lk op lo oq ls or lw oj ok ol om bi translated"><code class="fe nn no np nq b">var departureDate: Date?</code>。这是旅行的出发日期。</li><li id="e761" class="oe of iu ld b le on lh oo lk op lo oq ls or lw oj ok ol om bi translated"><code class="fe nn no np nq b">var arrivalDate: Date?</code>。这是旅行的到达日期。</li></ul><p id="4ca7" class="pw-post-body-paragraph lb lc iu ld b le lf jv lg lh li jy lj lk ll lm ln lo lp lq lr ls lt lu lv lw in bi translated">我们所做的是创建一个返回类型为<code class="fe nn no np nq b">MKDirections.Request</code>的对象的方法:</p><figure class="kk kl km kn gu ko"><div class="bz fq l di"><div class="ou ov l"/></div></figure><p id="ac72" class="pw-post-body-paragraph lb lc iu ld b le lf jv lg lh li jy lj lk ll lm ln lo lp lq lr ls lt lu lv lw in bi translated">在这种方法中，我们首先获得屏幕中心点的坐标。然后我们用原点(我们所在的点)和目标坐标创建<code class="fe nn no np nq b">MKPlacemark</code>类型的对象。最后，我们创建了一个类型为<code class="fe nn no np nq b">MKDirections.Request</code>的实例，指明了出发地、目的地、运输工具(汽车)的类型，以及我们想要的替代路线。</p><p id="0103" class="pw-post-body-paragraph lb lc iu ld b le lf jv lg lh li jy lj lk ll lm ln lo lp lq lr ls lt lu lv lw in bi translated">为了绘制路线，我们需要做的是用我们创建的请求启动一个top <code class="fe nn no np nq b">MKDirections</code>对象。如<a class="ae kz" href="https://developer.apple.com/documentation/mapkit/mkdirections" rel="noopener ugc nofollow" target="_blank">苹果文档</a>所示，该对象根据您提供的路线信息计算方向和旅行时间信息。</p><p id="6ddd" class="pw-post-body-paragraph lb lc iu ld b le lf jv lg lh li jy lj lk ll lm ln lo lp lq lr ls lt lu lv lw in bi translated">因此，我们将创建一个方法，从请求的创建中获取一个类型为<code class="fe nn no np nq b">MKDirections</code>的对象，并表示路由:</p><figure class="kk kl km kn gu ko"><div class="bz fq l di"><div class="ou ov l"/></div></figure><p id="f7ce" class="pw-post-body-paragraph lb lc iu ld b le lf jv lg lh li jy lj lk ll lm ln lo lp lq lr ls lt lu lv lw in bi translated">在这个方法中，一旦获得了<code class="fe nn no np nq b">MKDirections</code>对象，我们就使用方法<code class="fe nn no np nq b">calculate(completionHandler: MKDirections.DirectionsHandler)</code>，它返回一个类型为<code class="fe nn no np nq b">MKDirections.Response</code>的对象和一个可能的错误:</p><figure class="kk kl km kn gu ko"><div class="bz fq l di"><div class="ou ov l"/></div></figure><p id="0e9e" class="pw-post-body-paragraph lb lc iu ld b le lf jv lg lh li jy lj lk ll lm ln lo lp lq lr ls lt lu lv lw in bi translated">然后，我们检查答案是否有效，并接受routes参数，这是一个由<code class="fe nn no np nq b">MKRoute</code>类型对象组成的数组，表示起点和终点之间的路线。</p><p id="2c49" class="pw-post-body-paragraph lb lc iu ld b le lf jv lg lh li jy lj lk ll lm ln lo lp lq lr ls lt lu lv lw in bi translated">如果我们看一下<a class="ae kz" href="https://developer.apple.com/documentation/mapkit/mkroute" rel="noopener ugc nofollow" target="_blank">苹果文档</a>,<code class="fe nn no np nq b">MKRoute</code>对象提供了一个名为<code class="fe nn no np nq b">polyline</code>的参数，其中包含了路线图。为了表示这个图，我们所做的是将这个参数传递给<code class="fe nn no np nq b">MKMapView</code>对象的<code class="fe nn no np nq b">addOverlay(_ overlay: MKOverlay)</code>方法。然后我们使用方法<code class="fe nn no np nq b">setVisibleMapRect(_ mapRect: MKMapRect, animated animate: Bool)</code>改变地图的可见部分。</p><p id="8bee" class="pw-post-body-paragraph lb lc iu ld b le lf jv lg lh li jy lj lk ll lm ln lo lp lq lr ls lt lu lv lw in bi translated">此外，我们必须添加一个<code class="fe nn no np nq b">MKMapViewDelegate</code>协议的方法，以便绘制路由(用绿色和5px线宽绘制):</p><figure class="kk kl km kn gu ko"><div class="bz fq l di"><div class="ou ov l"/></div></figure><p id="cb69" class="pw-post-body-paragraph lb lc iu ld b le lf jv lg lh li jy lj lk ll lm ln lo lp lq lr ls lt lu lv lw in bi translated">现在我们需要的是添加一个按钮，允许我们开始计算路线。从我们在开始展示的界面设计中，我们添加并配置了一个<code class="fe nn no np nq b">UIButton</code>元素，我们将把<code class="fe nn no np nq b">drawRoutes()</code>方法作为目标添加到该元素中:</p><figure class="kk kl km kn gu ko"><div class="bz fq l di"><div class="ou ov l"/></div></figure><figure class="kk kl km kn gu ko gi gj paragraph-image"><div class="gi gj pg"><img src="../Images/2bdb9be5784518effddea7e763c247a3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1200/1*cpFkXxHIMp8W1P3hcLoeiQ.gif"/></div></figure><p id="2c7b" class="pw-post-body-paragraph lb lc iu ld b le lf jv lg lh li jy lj lk ll lm ln lo lp lq lr ls lt lu lv lw in bi translated">最终的路线图像:</p><figure class="kk kl km kn gu ko gi gj paragraph-image"><div role="button" tabindex="0" class="kp kq di kr bf ks"><div class="gi gj ph"><img src="../Images/8b335b7b39abab00c3af1427524b3dac.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*JJNdU85RstwoIanZj3TDWg.png"/></div></div></figure></div><div class="ab cl ns nt hy nu" role="separator"><span class="nv bw bk nw nx ny"/><span class="nv bw bk nw nx ny"/><span class="nv bw bk nw nx"/></div><div class="in io ip iq ir"><h1 id="cf97" class="mq mr iu bd ms mt nz mv mw mx oa mz na ka ob kb nc kd oc ke ne kg od kh ng nh bi translated">结论</h1><p id="7806" class="pw-post-body-paragraph lb lc iu ld b le ni jv lg lh nj jy lj lk nk lm ln lo nl lq lr ls nm lu lv lw in bi translated">Apple MapKit库允许您轻松开发一个应用程序来显示地图，显示我们在地图上的位置，从地图上的一个选定点向我们显示方向，并显示到达该地址的路线。</p></div></div>    
</body>
</html>