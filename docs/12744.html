<html>
<head>
<title>Storage and Memory Secrets in Solidity</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">固体中的储存和记忆秘密</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/storage-and-memory-secrets-in-solidity-cd88ea0a981b?source=collection_archive---------1-----------------------#2022-06-28">https://betterprogramming.pub/storage-and-memory-secrets-in-solidity-cd88ea0a981b?source=collection_archive---------1-----------------------#2022-06-28</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="6a7a" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">在执行函数时，我们是否希望数据在调用智能协定或保存在本地之间保持不变？</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/d43883e14038cf9398be3bab0abc0d6e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*73iHUn-KVVeL6h1HMozCdw.jpeg"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">照片由<a class="ae ky" href="https://unsplash.com/@melodi2" rel="noopener ugc nofollow" target="_blank"> Lia Trevarthen </a>在<a class="ae ky" href="https://unsplash.com/?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄。</p></figure><p id="d145" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这一次，我们将讨论Solidity编程语言中的存储位置，特别是关于<code class="fe lv lw lx ly b">storage</code>和<code class="fe lv lw lx ly b">memory</code>位置。不知道它们代表什么以及它们如何工作会导致我们的智能合同出现问题。</p><h1 id="f78c" class="lz ma it bd mb mc md me mf mg mh mi mj jz mk ka ml kc mm kd mn kf mo kg mp mq bi translated">储存；储备</h1><p id="adc1" class="pw-post-body-paragraph kz la it lb b lc mr ju le lf ms jx lh li mt lk ll lm mu lo lp lq mv ls lt lu im bi translated">智能合约中的存储保存函数调用之间的数据。我们可以想象,<code class="fe lv lw lx ly b">storage</code>会被当成电脑中的硬盘。即使我们将其关闭，数据也不会被删除。在区块链上，我们在存储器中写的东西被存储起来。</p><h1 id="7212" class="lz ma it bd mb mc md me mf mg mh mi mj jz mk ka ml kc mm kd mn kf mo kg mp mq bi translated">默认存储</h1><h2 id="86af" class="mw ma it bd mb mx my dn mf mz na dp mj li nb nc ml lm nd ne mn lq nf ng mp nh bi translated">状态变量</h2><p id="52f8" class="pw-post-body-paragraph kz la it lb b lc mr ju le lf ms jx lh li mt lk ll lm mu lo lp lq mv ls lt lu im bi translated">默认情况下，Solidity将保存存储智能合同的状态变量。</p><pre class="kj kk kl km gt ni ly nj nk aw nl bi"><span id="0f8c" class="mw ma it ly b gy nm nn l no np">contract StorageContract {<br/>  struct LuckyNumber {<br/>    uint256 number;<br/>    string reason;<br/>  }</span><span id="44b6" class="mw ma it ly b gy nq nn l no np">  mapping(address =&gt; LuckyNumber) luckyNumbers;<br/>}</span></pre><p id="4a9c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在这个例子中，智能合约的状态变量<code class="fe lv lw lx ly b">luckyNumbers</code>保存在存储器中，并且数据将在函数调用之间保持不变。</p><p id="3969" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">当我们相加并得到幸运数字时，我们有一个可预测的结果。</p><pre class="kj kk kl km gt ni ly nj nk aw nl bi"><span id="1d76" class="mw ma it ly b gy nm nn l no np">function addLuckyNumber(LuckyNumber memory luckyNumber) external {<br/>  require(luckyNumber.number != 0, "Lucky number can't be 0!");<br/>  require(luckyNumbers[msg.sender].number == 0, "You already have set lucky number. Edit it if you have another one.");</span><span id="8913" class="mw ma it ly b gy nq nn l no np">  luckyNumbers[msg.sender] = luckyNumber;<br/>}</span><span id="5b34" class="mw ma it ly b gy nq nn l no np">function getMyLuckyNumber() external view returns(uint256) {<br/>  require(luckyNumbers[msg.sender].number != 0, "You don't have a lucky number set yet.");</span><span id="b6bc" class="mw ma it ly b gy nq nn l no np">  LuckyNumber memory luckyNumber = luckyNumbers[msg.sender];</span><span id="ece8" class="mw ma it ly b gy nq nn l no np">  return luckyNumber.number;<br/>}</span></pre><h2 id="55b7" class="mw ma it bd mb mx my dn mf mz na dp mj li nb nc ml lm nd ne mn lq nf ng mp nh bi translated">局部函数变量</h2><p id="aebc" class="pw-post-body-paragraph kz la it lb b lc mr ju le lf ms jx lh li mt lk ll lm mu lo lp lq mv ls lt lu im bi translated">默认情况下，结构、数组或映射的局部函数变量保存在存储中。这意味着，如果我们在函数中声明这些值，它们会保存在存储中，这可能会导致难以跟踪的意外问题。</p><p id="7b89" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果我们在代码示例中添加一个函数<code class="fe lv lw lx ly b">editLuckyNumber</code>，并将本地副本标记为<code class="fe lv lw lx ly b">storage</code>，它将编辑我们期望的状态变量。</p><pre class="kj kk kl km gt ni ly nj nk aw nl bi"><span id="18bf" class="mw ma it ly b gy nm nn l no np">function editLuckyNumber(uint256 luckyNumber) external {<br/>  require(luckyNumber != 0, "Lucky number can't be 0!");<br/>  require(luckyNumbers[msg.sender].number != 0, "You don't have a lucky number set yet.");</span><span id="520d" class="mw ma it ly b gy nq nn l no np">  LuckyNumber storage _luckyNumber = luckyNumbers[msg.sender];<br/>  _luckyNumber.number = luckyNumber;<br/>}</span></pre><h1 id="4c56" class="lz ma it bd mb mc md me mf mg mh mi mj jz mk ka ml kc mm kd mn kf mo kg mp mq bi translated">记忆</h1><p id="f71c" class="pw-post-body-paragraph kz la it lb b lc mr ju le lf ms jx lh li mt lk ll lm mu lo lp lq mv ls lt lu im bi translated">在内存中，Solidity保留所有本地定义的值类型，可以是uint、string等。，但不是数组、结构或映射。函数参数也保存在内存中。记住<code class="fe lv lw lx ly b">memory</code>不能在智能合约级别使用，只能在函数中本地使用。</p><pre class="kj kk kl km gt ni ly nj nk aw nl bi"><span id="58bc" class="mw ma it ly b gy nm nn l no np">function multiplyByItself(uint256 number) external pure returns(uint256) {<br/>  uint256 result = number * number;</span><span id="7807" class="mw ma it ly b gy nq nn l no np">  return result;<br/>}</span></pre><p id="171e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在这个例子中，我们在函数中传递的函数参数<code class="fe lv lw lx ly b">number</code>存储在内存中。此外，<code class="fe lv lw lx ly b">result</code>的本地定义变量存储在内存中，一旦函数执行结束，该变量将被释放。</p><h1 id="3b9a" class="lz ma it bd mb mc md me mf mg mh mi mj jz mk ka ml kc mm kd mn kf mo kg mp mq bi translated">使用内存和存储的缺陷</h1><p id="cc24" class="pw-post-body-paragraph kz la it lb b lc mr ju le lf ms jx lh li mt lk ll lm mu lo lp lq mv ls lt lu im bi translated">Solidity编程语言中错误使用关键字<code class="fe lv lw lx ly b">storage</code>和<code class="fe lv lw lx ly b">memory</code>的一个主要陷阱是，我们在没有考虑清楚的情况下声明变量<code class="fe lv lw lx ly b">storage</code>或<code class="fe lv lw lx ly b">memory</code>。首先，在<code class="fe lv lw lx ly b">storage</code>保存数据会消耗更多的汽油，因为我们需要为块空间付费。其次，我们应该问自己是否需要访问保存在函数调用之间的数据。通过函数调用，甚至可以有两个不同的函数。</p><p id="2741" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果我们使用关键字<code class="fe lv lw lx ly b">memory</code>定义函数<code class="fe lv lw lx ly b">editLuckyNumber</code>中的<code class="fe lv lw lx ly b">_luckyNumber</code>，它将只在本地编辑这个函数，而不会将更改写入区块链。</p><pre class="kj kk kl km gt ni ly nj nk aw nl bi"><span id="b893" class="mw ma it ly b gy nm nn l no np">function editLuckyNumber(uint256 luckyNumber) external {<br/>  require(luckyNumber != 0, "Lucky number can't be 0!");<br/>  require(luckyNumbers[msg.sender].number != 0, "You don't have a lucky number set yet.");</span><span id="3e97" class="mw ma it ly b gy nq nn l no np">  LuckyNumber memory _luckyNumber = luckyNumbers[msg.sender];<br/>  _luckyNumber.number = luckyNumber;<br/>}</span></pre><p id="bf71" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这个函数的结果将导致编辑幸运数字不起作用，因为我们只在本地更新它。</p><h1 id="8e8c" class="lz ma it bd mb mc md me mf mg mh mi mj jz mk ka ml kc mm kd mn kf mo kg mp mq bi translated">TL；速度三角形定位法(dead reckoning)</h1><p id="65bc" class="pw-post-body-paragraph kz la it lb b lc mr ju le lf ms jx lh li mt lk ll lm mu lo lp lq mv ls lt lu im bi translated">在我们的智能合约中使用Solidity语言存储数据是一件至关重要的事情。使用值类型更容易，但是使用数组、结构和映射就更难了。这就是为什么当我们想要保存这些变量时，询问是必要的。在执行函数时，我们是否希望数据在调用智能协定或保存在本地之间保持不变？</p><h1 id="1a16" class="lz ma it bd mb mc md me mf mg mh mi mj jz mk ka ml kc mm kd mn kf mo kg mp mq bi translated">链接</h1><ul class=""><li id="e4a0" class="nr ns it lb b lc mr lf ms li nt lm nu lq nv lu nw nx ny nz bi translated"><a class="ae ky" href="https://gist.github.com/fassko/5b19bee0c78e3e41aa5d52573b2e696e" rel="noopener ugc nofollow" target="_blank">样本代码</a></li><li id="125c" class="nr ns it lb b lc oa lf ob li oc lm od lq oe lu nw nx ny nz bi translated"><a class="ae ky" href="https://docs.soliditylang.org/en/v0.3.3/frequently-asked-questions.html#what-is-the-memory-keyword-what-does-it-do" rel="noopener ugc nofollow" target="_blank">什么是记忆关键词？它是做什么的？</a></li><li id="c5b1" class="nr ns it lb b lc oa lf ob li oc lm od lq oe lu nw nx ny nz bi translated"><a class="ae ky" href="https://www.geeksforgeeks.org/storage-vs-memory-in-solidity/" rel="noopener ugc nofollow" target="_blank">存储与存储的稳固性</a></li><li id="9b13" class="nr ns it lb b lc oa lf ob li oc lm od lq oe lu nw nx ny nz bi translated"><a class="ae ky" href="https://stackoverflow.com/questions/33839154/in-ethereum-solidity-what-is-the-purpose-of-the-memory-keyword" rel="noopener ugc nofollow" target="_blank">在以太坊Solidity中，“记忆”关键字的用途是什么？</a></li></ul></div></div>    
</body>
</html>