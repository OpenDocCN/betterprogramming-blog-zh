<html>
<head>
<title>Distributed Instant Logs Made Easy With Docker</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Docker简化了分布式即时日志</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/distributed-instant-logs-made-easy-with-docker-b5e7f501f045?source=collection_archive---------11-----------------------#2020-10-28">https://betterprogramming.pub/distributed-instant-logs-made-easy-with-docker-b5e7f501f045?source=collection_archive---------11-----------------------#2020-10-28</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="3960" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">如何在Slack上轻松通知您的微服务基础架构中出现的错误</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/7e093ccba6ee188cacc0327b2ba8d2a0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*2TV7eHsPD7zZDRzr23qkoQ.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">在微服务基础设施上，日志监控仍然是一个具有挑战性的问题</p></figure><p id="b40b" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated"><a class="ae lu" href="http://searchmicroservices.techtarget.com/definition/microservices" rel="noopener ugc nofollow" target="_blank">微服务架构风格</a>为开发团队提供了一种更加分散的构建软件的方法，每个服务都被独立地隔离、构建、部署和管理。因此，<a class="ae lu" href="https://medium.com/swlh/what-exactly-is-docker-1dd62e1fde38" rel="noopener">容器</a>已经成为包装个人服务的事实上一致且资源高效的标准。然后出现了编排工具，如<a class="ae lu" href="https://docs.docker.com/engine/swarm/" rel="noopener ugc nofollow" target="_blank"> Docker Swarm </a>、<a class="ae lu" href="https://kubernetes.io/" rel="noopener ugc nofollow" target="_blank"> Kubernetes </a>和<a class="ae lu" href="https://www.nomadproject.io/" rel="noopener ugc nofollow" target="_blank"> Nomad </a>。这些工具有助于自动化扩展、部署和容器管理。</p><p id="715f" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">尽管由于这些突破，微服务管理的复杂性正在降低，但一些挑战仍然存在，如对此类基础设施的平稳轻松监控。例如，<a class="ae lu" href="https://blog.jhink.com/centralize-docker-logs-using-elastic-stack-e55670bfb714" rel="noopener ugc nofollow" target="_blank"> ELK堆栈</a>通常用于满足这种需求。解决方案也作为<a class="ae lu" href="https://docs.aws.amazon.com/AmazonCloudWatch/latest/monitoring/ContainerInsights.html" rel="noopener ugc nofollow" target="_blank">托管</a> <a class="ae lu" href="https://www.dynatrace.com/technologies/docker-monitoring/" rel="noopener ugc nofollow" target="_blank">服务</a>存在于云中。</p><p id="7afc" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">然而，如果您想要管理自己的基于Docker的基础架构，而不引入太多的复杂性或太多的工具，同时限制对云提供商的依赖，那么剩下的选择就很少了。本文介绍了<a class="ae lu" href="https://github.com/gliderlabs/logspout" rel="noopener ugc nofollow" target="_blank"> Logspout </a>和一个新的<a class="ae lu" href="https://github.com/kalisio/logspout-slack" rel="noopener ugc nofollow" target="_blank"> Slack adapter </a>作为Docker容器的轻量级日志监控替代方案，您可以快速配置和部署它。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="4739" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">一言以蔽之</h1><p id="99c1" class="pw-post-body-paragraph ky kz it la b lb mu ju ld le mv jx lg lh mw lj lk ll mx ln lo lp my lr ls lt im bi translated">Logspout是Docker容器的日志路由器，在Docker内部运行。它附加到主机上的所有容器，然后将它们的日志路由到目的地。它在每个Docker实例上充当非侵入式代理，从每个运行的守护进程收集日志。使用<a class="ae lu" href="http://github.com/gliderlabs/logspout/blob/master/httpstream" rel="noopener ugc nofollow" target="_blank"> httpstream模块</a>，您可以简单地在给定的实例上连接curl，以实时查看您的本地聚合日志:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi mz"><img src="../Images/4d6fc0a7393c22df624ed723f9a40df8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*wIT5SzLKhDHqj2pNF3LiVg.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">来自我们的一个基础架构的聚合日志输出</p></figure><p id="69b3" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">这已经是一个有趣的替代方案，例如，<a class="ae lu" href="https://docs.docker.com/engine/reference/commandline/service_logs/" rel="noopener ugc nofollow" target="_blank"> Docker Swarm服务日志</a>，其中来自不同基础设施实例的交错日志并不总是易于阅读。</p><p id="a88d" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">Logspout是模块化的，允许您通过适配器导出各种格式的日志。最常见的方法是获取所有的日志并将它们发送到一个远程的<a class="ae lu" href="https://en.wikipedia.org/wiki/Syslog" rel="noopener ugc nofollow" target="_blank"> syslog </a>，比如<a class="ae lu" href="https://www.papertrail.com/" rel="noopener ugc nofollow" target="_blank"> Papertrail </a>。除了内置适配器，您还会发现<a class="ae lu" href="https://github.com/gliderlabs/logspout#third-party-modules" rel="noopener ugc nofollow" target="_blank">社区驱动的适配器</a>。一旦选择了适配器，Logspout的部署非常简单:</p><pre class="kj kk kl km gt na nb nc nd aw ne bi"><span id="cf00" class="nf md it nb b gy ng nh l ni nj">docker run --name="logspout" \<br/>	--volume=/var/run/docker.sock:/var/run/docker.sock \<br/>	gliderlabs/logspout \<br/>	syslog+tls://logs.papertrailapp.com:55555</span></pre><p id="28c3" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">它还为您提供了根据名称和输出类型(<code class="fe nk nl nm nb b">stdout</code>、<code class="fe nk nl nm nb b">stderr</code>或两者)过滤要记录的容器的能力:</p><pre class="kj kk kl km gt na nb nc nd aw ne bi"><span id="f5fd" class="nf md it nb b gy ng nh l ni nj">docker run --name="logspout" \<br/>	--volume=/var/run/docker.sock:/var/run/docker.sock \<br/>	gliderlabs/logspout \<br/>	syslog+tls://logs.papertrailapp.com:55555?filter.sources=stdout%2Cstderr&amp;filter.name=*my_container*'</span></pre><p id="db7d" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated"><strong class="la iu">注意:</strong>您必须对参数值进行URL编码，这样逗号和名称过滤器就不是正则表达式，而是一个<a class="ae lu" href="https://godoc.org/path#Match" rel="noopener ugc nofollow" target="_blank">路径模式</a> <em class="nn">。</em></p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="e52e" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">Logspout松弛适配器</h1><p id="cbbe" class="pw-post-body-paragraph ky kz it la b lb mu ju ld le mv jx lg lh mw lj lk ll mx ln lo lp my lr ls lt im bi translated">Logspout的这个<a class="ae lu" href="https://github.com/kalisio/logspout-slack" rel="noopener ugc nofollow" target="_blank">极简适配器</a>背后的想法非常简单:发送重要的日志(意外错误、警告等)。)作为对你懈怠的通知，使用<a class="ae lu" href="https://api.slack.com/messaging/webhooks" rel="noopener ugc nofollow" target="_blank">网钩</a>。</p><p id="5db7" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">首先，您可以使用<code class="fe nk nl nm nb b">SLACK_WEBHOOK_URL</code>环境变量定义您的web hook URL/路径。然后，有不同的<a class="ae lu" href="https://github.com/kalisio/logspout-slack#configuration-options" rel="noopener ugc nofollow" target="_blank">配置选项</a>作为一组环境变量来定制您如何过滤和格式化通知:</p><ul class=""><li id="ed53" class="no np it la b lb lc le lf lh nq ll nr lp ns lt nt nu nv nw bi translated"><code class="fe nk nl nm nb b">SLACK_MESSAGE_FILTER</code>:转到<a class="ae lu" href="https://godoc.org/regexp#Regexp.MatchString" rel="noopener ugc nofollow" target="_blank"> regex </a>根据日志内容选择要发送到Slack的日志</li><li id="a7f1" class="no np it la b lb nx le ny lh nz ll oa lp ob lt nt nu nv nw bi translated"><code class="fe nk nl nm nb b">SLACK_TITLE_TEMPLATE</code>:转到<a class="ae lu" href="https://golang.org/pkg/text/template/" rel="noopener ugc nofollow" target="_blank">模板表达式</a>根据上下文格式化通知标题</li><li id="58aa" class="no np it la b lb nx le ny lh nz ll oa lp ob lt nt nu nv nw bi translated"><code class="fe nk nl nm nb b">SLACK_LINK_TEMPLATE</code> : Go <a class="ae lu" href="https://golang.org/pkg/text/template/" rel="noopener ugc nofollow" target="_blank">模板表达式</a>根据上下文生成通知标题链接</li><li id="d4e8" class="no np it la b lb nx le ny lh nz ll oa lp ob lt nt nu nv nw bi translated"><code class="fe nk nl nm nb b">SLACK_MESSAGE_TEMPLATE</code>:进入<a class="ae lu" href="https://golang.org/pkg/text/template/" rel="noopener ugc nofollow" target="_blank">模板表达式</a>根据上下文格式化通知内容</li><li id="b1ed" class="no np it la b lb nx le ny lh nz ll oa lp ob lt nt nu nv nw bi translated"><code class="fe nk nl nm nb b">SLACK_COLOR_TEMPLATE</code>:转<a class="ae lu" href="https://golang.org/pkg/text/template/" rel="noopener ugc nofollow" target="_blank">模板表达式</a>根据上下文生成通知颜色</li></ul><p id="836c" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">不同模板的评估上下文包括以下对象:</p><ul class=""><li id="9cd2" class="no np it la b lb lc le lf lh nq ll nr lp ns lt nt nu nv nw bi translated"><code class="fe nk nl nm nb b">Message</code>:log spout路由器消息，除了作为<code class="fe nk nl nm nb b">Data</code>字段的日志内容本身之外，它还拥有关于容器的大量信息(请参考相关的Go类型以了解详细信息)</li><li id="28b6" class="no np it la b lb nx le ny lh nz ll oa lp ob lt nt nu nv nw bi translated"><code class="fe nk nl nm nb b">Env</code>:环境变量的映射，您可以使用模板中的<a class="ae lu" href="https://golang.org/pkg/text/template/#hdr-Functions" rel="noopener ugc nofollow" target="_blank">索引函数</a>从您的特定环境设置中提取一些信息</li></ul><p id="d5ce" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">Logspout模块由<a class="ae lu" href="https://github.com/progrium/go-extpoints" rel="noopener ugc nofollow" target="_blank"> go-extpoints </a>启用，这是一种用于<a class="ae lu" href="http://en.wikipedia.org/wiki/Inversion_of_control" rel="noopener ugc nofollow" target="_blank">反转控制</a>的机制，类似于<a class="ae lu" href="http://en.wikipedia.org/wiki/Dependency_injection" rel="noopener ugc nofollow" target="_blank">依赖注入</a>。每个扩展点代表模块可以挂接的Logspout 的一部分。更具体地说，我们依靠<code class="fe nk nl nm nb b">AdapterFactory</code>来添加我们的新型路由适配器(例如<code class="fe nk nl nm nb b">slack</code>)。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="ce71" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">监控你自己的日志</h1><p id="0b00" class="pw-post-body-paragraph ky kz it la b lb mu ju ld le mv jx lg lh mw lj lk ll mx ln lo lp my lr ls lt im bi translated">幸运的是，分叉Logspout是不必要的，因为它包含了类似于Nginx模块的模块概念。</p><p id="0648" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">模块是在编译时添加或删除的功能块。按照说明构建您自己的<a class="ae lu" href="https://github.com/gliderlabs/logspout/tree/master/custom" rel="noopener ugc nofollow" target="_blank"> Logspout映像</a>，包括我们的Logspout Slack适配器。简而言之，复制<code class="fe nk nl nm nb b">custom</code>文件夹的内容，并在<code class="fe nk nl nm nb b">modules.go</code>中的其他内容之上添加以下导入行:</p><pre class="kj kk kl km gt na nb nc nd aw ne bi"><span id="8d1d" class="nf md it nb b gy ng nh l ni nj">import (<br/>  _ "github.com/kalisio/logspout-slack"<br/>  ...<br/>)</span></pre><p id="7908" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">如果您想为生产部署选择一个特定的版本，只需像这样更新<code class="fe nk nl nm nb b">Dockerfile</code>:</p><pre class="kj kk kl km gt na nb nc nd aw ne bi"><span id="3526" class="nf md it nb b gy ng nh l ni nj">ARG VERSION<br/>FROM gliderlabs/logspout:$VERSION</span><span id="d115" class="nf md it nb b gy oc nh l ni nj">ONBUILD COPY ./build.sh /src/build.sh<br/>ONBUILD COPY ./modules.go /src/modules.go</span></pre><p id="7f7c" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">然后，通过提供所需的<code class="fe nk nl nm nb b">VERSION</code>标记来构建您的映像:</p><p id="1094" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated"><code class="fe nk nl nm nb b">docker build --no-cache --pull --force-rm --build-arg VERSION=v3.2.11 -f dockerfile -t logspout:v3.2.11 .</code></p><p id="f361" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">最后，在每个实例上使用您的配置运行它:</p><pre class="kj kk kl km gt na nb nc nd aw ne bi"><span id="d7e8" class="nf md it nb b gy ng nh l ni nj">docker run --name="logspout" \<br/>	--volume=/var/run/docker.sock:/var/run/docker.sock \<br/>	logspout:v3.2.11 \<br/>        -e SLACK_MESSAGE_FILTER=".*error" \<br/>	slack://<!-- -->hooks.slack.com<!-- -->?filter.sources=stdout%2Cstderr&amp;filter.name=*my_container*'</span></pre><p id="f703" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">如果您使用Docker Swarm，下面是一个更完整的Docker合成文件示例，以便将其部署为一个全局服务:</p><pre class="kj kk kl km gt na nb nc nd aw ne bi"><span id="ed70" class="nf md it nb b gy ng nh l ni nj">version: '3.5'<br/><br/>services:<br/>  logspout:<br/>    image: logspout:v3.2.11<br/>    volumes:<br/>      - /etc/hostname:/etc/host_hostname:ro<br/>      - /var/run/docker.sock:/var/run/docker.sock<br/>    command:<br/>      - 'slack://hooks.slack.com?filter.sources=stdout%2Cstderr&amp;filter.name=*app*'<br/>    environment:<br/>      - SUBDOMAIN<br/>      - SLACK_TITLE_TEMPLATE={{`{{ .Message.Container.Name }}`}}<br/>      - SLACK_MESSAGE_TEMPLATE={{`{{ .Message.Data }}`}}<br/>      - SLACK_LINK_TEMPLATE={{`<a class="ae lu" href="https://aktnmap.{{" rel="noopener ugc nofollow" target="_blank">https://app.{{</a> index .Env "SUBDOMAIN" }}`}}<br/>      - SLACK_WEBHOOK_URL=/services/xxx<br/>      - SLACK_MESSAGE_FILTER=".*error"<br/>      - BACKLOG=false<br/>    healthcheck:<br/>      test: ["CMD", "wget", "-q", "--tries=1", "--spider", "http://localhost:80/health"]<br/>      interval: 30s<br/>      timeout: 5s<br/>      retries: 3<br/>      start_period: 1m<br/>    deploy:<br/>      mode: global<br/>      resources:<br/>        limits:<br/>          cpus: '0.20'<br/>          memory: 256M<br/>        reservations:<br/>          cpus: '0.10'<br/>          memory: 128M<br/>      restart_policy:<br/>        condition: on-failure<br/>    networks:<br/>      - network<br/><br/>networks:<br/>  network:<br/>    name: your_name<br/>    external: true</span></pre><p id="ee9e" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated"><strong class="la iu">注意:</strong>注意将你的模板表达式括在<code class="fe nk nl nm nb b">`{{</code>和<code class="fe nk nl nm nb b">`}} </code>之间，因为Docker Swarm <a class="ae lu" href="https://github.com/gliderlabs/logspout/issues/273" rel="noopener ugc nofollow" target="_blank">也将变量作为模板表达式</a>处理。</p><p id="8d92" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">一旦部署了Logspout服务，您应该会在Slack中看到一些通知:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi od"><img src="../Images/349abbbafe0b199a6df1b2e49bcf5534.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*hgkguSRgJFxEpBuiLuXgJQ.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">最终的结果是:在您的alert Slack通道上有一些来自您的基础设施的错误日志</p></figure></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="d323" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">结论</h1><p id="dad6" class="pw-post-body-paragraph ky kz it la b lb mu ju ld le mv jx lg lh mw lj lk ll mx ln lo lp my lr ls lt im bi translated">我希望你会发现这个解决方案非常简单和有用——如果是这样，请不要犹豫，在我们新的Logspout Slack adapter <a class="ae lu" href="https://github.com/kalisio/logspout-slack" rel="noopener ugc nofollow" target="_blank">存储库中打开问题或PR，</a>因为我们需要来自社区的一些反馈。</p><p id="338f" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">如果你和我们一样在<a class="ae lu" href="http://kalisio.com/" rel="noopener ugc nofollow" target="_blank"> Kalisio </a>工作，对构建一个<a class="ae lu" href="https://blog.feathersjs.com/a-use-case-of-microservices-with-feathersjs-building-a-geospatial-platform-56373604db71" rel="noopener ugc nofollow" target="_blank">基于微服务的平台</a>感兴趣，你可以看看我们的一些<a class="ae lu" href="https://github.com/kalisio" rel="noopener ugc nofollow" target="_blank">开源项目</a>，比如:</p><ul class=""><li id="143a" class="no np it la b lb lc le lf lh nq ll nr lp ns lt nt nu nv nw bi translated"><a class="ae lu" href="https://kalisio.github.io/kaabah/" rel="noopener ugc nofollow" target="_blank"> Kaabah </a>，一个构建和运营Docker群基础设施的解决方案</li><li id="eb9d" class="no np it la b lb nx le ny lh nz ll oa lp ob lt nt nu nv nw bi translated">Kargo是一个基于Docker的解决方案，用于在Docker Swarm基础设施上部署服务</li></ul><p id="cace" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">我在本文中介绍的现在是Kargo内置监控栈的<a class="ae lu" href="https://kalisio.github.io/kargo/reference/environment.html#logspout" rel="noopener ugc nofollow" target="_blank">部分。</a></p></div></div>    
</body>
</html>