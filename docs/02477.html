<html>
<head>
<title>Callbacks vs. Promises in JavaScript</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">JavaScript中的回调与承诺</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/callbacks-vs-promises-in-javascript-1f074e93a3b5?source=collection_archive---------0-----------------------#2019-12-03">https://betterprogramming.pub/callbacks-vs-promises-in-javascript-1f074e93a3b5?source=collection_archive---------0-----------------------#2019-12-03</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="4909" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">这种区别可能会令人困惑，让我们来澄清一下</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/5f0589c8a12d122556f08ec3c638c65e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*qCZwZeokLzlJY2qPA8In2A.jpeg"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">罗伯特·鲁杰罗在<a class="ae ky" href="https://unsplash.com/s/photos/confusion?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的照片</p></figure><p id="0e2d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果你是JavaScript新手，并且很难理解承诺是如何工作的，希望这篇文章能帮助你更清楚地理解它们。</p><p id="90f7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">也就是说，这篇文章是针对那些对承诺有点不确定的人。</p><p id="5a01" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这篇文章不会讨论如何使用<a class="ae ky" href="https://javascript.info/async-await" rel="noopener ugc nofollow" target="_blank"> async/await </a>来执行承诺(尽管它们在功能上是一样的——只是async/await在大多数情况下更符合语法)。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="2834" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">什么</h1><p id="6b25" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">承诺实际上已经过时了一段时间，甚至在JavaScript出现之前。比如promises变成原生之前实现这个模式的两个库是<a class="ae ky" href="https://github.com/kriskowal/q" rel="noopener ugc nofollow" target="_blank"> Q </a>和<a class="ae ky" href="https://github.com/cujojs/when" rel="noopener ugc nofollow" target="_blank"> when </a>。</p><p id="4112" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">那么什么是承诺呢？承诺是JavaScript对象，<a class="ae ky" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise" rel="noopener ugc nofollow" target="_blank">表示异步操作</a>的最终完成或失败。您可以通过使用回调方法或使用承诺执行异步操作来获得结果。但是两者之间有一些细微的区别。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="7fb4" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">回访和承诺的主要区别</h1><p id="0180" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">两者之间的一个关键区别是，当使用回调方法时，我们通常只是将回调传递给一个函数，该函数在完成后被调用，以获得结果。然而，在promises中，您在返回的promise对象上附加回调。</p><p id="c251" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">回访:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mz na l"/></div></figure><p id="544d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">承诺:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mz na l"/></div></figure></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="2f24" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">许诺对象</h1><p id="0d96" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">我们刚刚提到了promise对象，这很好，因为它们是JavaScript中构成承诺的核心。</p><p id="4582" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">所以问题是<em class="nb">为什么</em>我们需要JavaScript中的承诺？</p><p id="9aed" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">为了更好地回答这个问题，我们必须问为什么使用回调方法对于大多数JavaScript开发人员来说还不够。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="9146" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">回调地狱</h1><p id="f7e6" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">使用回调方法的一个常见问题是，当我们最终不得不一次执行多个异步操作时，我们很容易以所谓的<a class="ae ky" href="https://stackoverflow.com/questions/4234619/how-to-avoid-long-nesting-of-asynchronous-functions-in-node-js" rel="noopener ugc nofollow" target="_blank"> <em class="nb">回调地狱</em> </a> <em class="nb">，</em>结束，这可能会成为一场噩梦，因为它会导致难以管理和难以阅读的代码。换句话说，这是每个开发人员最糟糕的噩梦。</p><p id="91cd" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这里有一个例子:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mz na l"/></div></figure><p id="3a64" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">您可以在代码片段中直观地看到一些笨拙的形状正在形成。仅仅从三个异步API调用开始，回调地狱就开始了与通常的自顶向下相反的下沉。</p><p id="9284" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">有了承诺，这不再是一个问题，因为我们可以通过链接<code class="fe nc nd ne nf b">.then</code>方法将代码保存在第一个处理程序的根:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mz na l"/></div></figure><p id="9c15" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在回调代码片段中，如果我们嵌套得再深一些，事情就会变得很糟糕，很难管理。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="325e" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">回调地狱出现的问题</h1><p id="49b6" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">只要看看我们之前代表这个回调地狱的代码片段，我们就可以得出从中出现的一系列危险问题，这些问题足以证明承诺是对语言的一个很好的补充:</p><h2 id="a1e4" class="ng md it bd me nh ni dn mi nj nk dp mm li nl nm mo lm nn no mq lq np nq ms nr bi translated">阅读变得越来越困难</h2><p id="7308" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">代码开始向两个方向移动(从上到下，然后从左到右)</p><h2 id="890d" class="ng md it bd me nh ni dn mi nj nk dp mm li nl nm mo lm nn no mq lq np nq ms nr bi translated">管理变得越来越困难</h2><ul class=""><li id="9fb9" class="ns nt it lb b lc mu lf mv li nu lm nv lq nw lu nx ny nz oa bi translated">当代码被嵌套得更深时，还不清楚发生了什么</li><li id="9220" class="ns nt it lb b lc ob lf oc li od lm oe lq of lu nx ny nz oa bi translated">我们必须始终确保不会意外地声明与外部作用域中已经声明的变量同名的变量(这被称为<a class="ae ky" href="https://stackoverflow.com/questions/11901427/an-example-of-variable-shadowing-in-javascript" rel="noopener ugc nofollow" target="_blank"> <em class="nb">隐藏</em> </a>)</li><li id="eac9" class="ns nt it lb b lc ob lf oc li od lm oe lq of lu nx ny nz oa bi translated">我们必须考虑三个不同地点的三个不同的错误</li><li id="73ac" class="ns nt it lb b lc ob lf oc li od lm oe lq of lu nx ny nz oa bi translated">我们甚至不得不重命名每个错误，以确保我们不会掩盖它上面的错误。如果我们最终在这一系列操作中做了额外的请求，我们必须找到额外的变量名，它们不会与上面的作用域中的错误冲突。</li></ul><p id="92f5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果我们仔细观察这些例子，我们会注意到这些问题中的大部分都是通过能够用<code class="fe nc nd ne nf b">.then</code>链接承诺来解决的，我们接下来会谈到这一点。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="3691" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">承诺链</h1><p id="7340" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">当我们需要执行一系列异步任务时，承诺链变得非常有用。每个被链接的任务只能在前一个任务完成后开始，由链中的<code class="fe nc nd ne nf b">.then</code>控制。</p><p id="8c4f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这些<code class="fe nc nd ne nf b">.then</code>块是在内部设置的，因此它们允许回调函数返回一个承诺，该承诺随后被应用到链中的每个<code class="fe nc nd ne nf b">.then</code>。</p><p id="62b8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">除了来自<code class="fe nc nd ne nf b">.catch</code>区块的拒绝承诺之外，你从<code class="fe nc nd ne nf b">.then</code>返回的任何东西最终都变成了已解决的承诺。</p><p id="b89c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这里有一个简短的例子:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mz na l"/></div></figure></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="3ed6" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">承诺方法</h1><p id="c6b2" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">JavaScript中的promise构造函数定义了几个静态方法，可用于从promise中检索一个或多个结果:</p><h2 id="c2fc" class="ng md it bd me nh ni dn mi nj nk dp mm li nl nm mo lm nn no mq lq np nq ms nr bi translated">承诺。所有</h2><p id="3581" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">当您想要累积一批异步操作并最终以数组的形式接收它们的每个值时，满足这个目标的promise方法之一是<code class="fe nc nd ne nf b">Promise.all</code>。</p><p id="e7c1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe nc nd ne nf b">Promise.all</code>当所有操作都成功结束时，收集操作结果。这类似于<code class="fe nc nd ne nf b">Promise.allSettled </code>——只是在这里，如果这些操作中至少有一个以失败告终，那么promise会出错拒绝。这最终会在承诺链的<code class="fe nc nd ne nf b">.catch</code>块中结束。</p><p id="de28" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">承诺拒绝可能发生在任何时候——从操作开始到结束。如果拒绝发生在所有结果完成之前，那么发生的情况是那些没有完成的结果将终止中止，并且永远不会完成。换句话说，这是一个孤注一掷的交易。</p><p id="ed02" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这里有一个简单的代码示例，其中的<code class="fe nc nd ne nf b">Promise.all</code>方法使用了承诺<code class="fe nc nd ne nf b">getFrogs</code>和<code class="fe nc nd ne nf b">getLizards</code>。在将结果存储到本地存储之前，它在<code class="fe nc nd ne nf b">.then</code>处理程序中以数组的形式检索结果:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mz na l"/></div></figure><h2 id="8202" class="ng md it bd me nh ni dn mi nj nk dp mm li nl nm mo lm nn no mq lq np nq ms nr bi translated">承诺.比赛</h2><p id="62f1" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">每当iterable中的一个承诺用该承诺的值或原因解析或拒绝时，该方法返回一个履行或拒绝的承诺。</p><p id="02e7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">下面是<code class="fe nc nd ne nf b">promise1</code>和<code class="fe nc nd ne nf b">promise2</code>以及<code class="fe nc nd ne nf b">Promise.race</code>方法之间的一个简单例子:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mz na l"/></div></figure><p id="4780" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这将产生以下结果:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi og"><img src="../Images/57525e5033e152e43bcb45af85a26d2f.png" data-original-src="https://miro.medium.com/v2/resize:fit:946/format:webp/0*v9buR6LLeThyjZgq.jpg"/></div></figure><p id="8517" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">返回值最终是承诺拒绝，因为另一个承诺延迟了200毫秒。</p><h2 id="da8f" class="ng md it bd me nh ni dn mi nj nk dp mm li nl nm mo lm nn no mq lq np nq ms nr bi translated">承诺。都解决了</h2><p id="84c7" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated"><code class="fe nc nd ne nf b">Promise.allSettled</code>方法最终有点类似于<code class="fe nc nd ne nf b">Promise.all</code>共享一个相似的目标，除了当一个承诺失败时，<code class="fe nc nd ne nf b">Promise.allSettled</code>不是立即拒绝一个错误，而是返回一个承诺，该承诺最终总是在所有给定的承诺已经解决或拒绝之后解决，将结果累积到一个数组中，其中每个项目表示它们的承诺操作的结果。</p><p id="4534" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这意味着您将总是以数组数据类型结束。下面是一个实际例子:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mz na l"/></div></figure><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi oh"><img src="../Images/7447a8ef9031c013b0dff13a562628ce.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*YdQvnUYTG37Eo7ra.jpg"/></div></div></figure><h2 id="4fda" class="ng md it bd me nh ni dn mi nj nk dp mm li nl nm mo lm nn no mq lq np nq ms nr bi translated">承诺。任何</h2><p id="b1c4" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated"><code class="fe nc nd ne nf b">Promise.any</code>是添加到<code class="fe nc nd ne nf b">Promise</code>建造商的提案，目前处于TC39流程的<a class="ae ky" href="https://github.com/tc39/proposal-promise-any" rel="noopener ugc nofollow" target="_blank">阶段3。</a></p><p id="b6f6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe nc nd ne nf b">Promise.any</code>被提议做的是接受一个可重复的承诺，并试图返回一个从第一个被履行或被拒绝的给定承诺开始履行的承诺，如果所有给定的承诺都被拒绝<a class="ae ky" href="https://github.com/tc39/proposal-promise-any" rel="noopener ugc nofollow" target="_blank">(来源</a>)。</p><p id="afad" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这意味着，如果有一个操作消耗了15个承诺，其中14个失败了<em class="nb"> </em>，而一个被解决了，那么<code class="fe nc nd ne nf b">Promise.any</code>的结果就成为解决的承诺的值:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mz na l"/></div></figure><p id="b619" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">点击阅读更多相关信息<a class="ae ky" href="https://github.com/tc39/proposal-promise-any" rel="noopener ugc nofollow" target="_blank">。</a></p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="1d07" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">成功/错误处理</h1><p id="07b4" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">很高兴知道可以使用这些变体来处理成功或失败的承诺操作:</p><h2 id="81cf" class="ng md it bd me nh ni dn mi nj nk dp mm li nl nm mo lm nn no mq lq np nq ms nr bi translated">变体1:</h2><pre class="kj kk kl km gt oi nf oj ok aw ol bi"><span id="24e9" class="ng md it nf b gy om on l oo op">add(5, 5).then(<br/>  function success(result) {<br/>    return result<br/>  },<br/>  function error(error) {<br/>    console.error(error)<br/>  },<br/>)</span></pre><h2 id="41ef" class="ng md it bd me nh ni dn mi nj nk dp mm li nl nm mo lm nn no mq lq np nq ms nr bi translated">变体2:</h2><pre class="kj kk kl km gt oi nf oj ok aw ol bi"><span id="371d" class="ng md it nf b gy om on l oo op">add(5, 5)<br/>  .then(function success(result) {<br/>    return result<br/>  })<br/>  .catch(function(error) {<br/>    console.error(error)<br/>  })</span></pre><p id="2525" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">然而，这两个例子并不完全相同。在变体2中，如果我们试图在resolve处理程序中抛出一个错误，那么我们将能够在<code class="fe nc nd ne nf b">.catch</code>块中检索捕获到的错误:</p><pre class="kj kk kl km gt oi nf oj ok aw ol bi"><span id="cf40" class="ng md it nf b gy om on l oo op">add(5, 5)<br/>  .then(function success(result) {<br/>    throw new Error("You aren't getting passed me")<br/>  })<br/>  .catch(function(error) {<br/>    <em class="nb">// The error ends up here</em><br/>  })</span></pre><p id="9391" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">然而，在变体1中，如果我们试图在resolve处理程序中抛出一个错误，我们将无法捕获这个错误:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mz na l"/></div></figure></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="2228" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">结论</h1><p id="eff4" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">本文到此结束。我希望你发现这是有价值的。以后多多关照！</p></div></div>    
</body>
</html>