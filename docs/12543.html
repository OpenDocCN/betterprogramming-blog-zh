<html>
<head>
<title>Distributed Tracing With OpenTelemetry, Spring Cloud Sleuth, Kafka, and Jaeger</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用OpenTelemetry、Spring Cloud Sleuth、Kafka和Jaeger进行分布式跟踪</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/distributed-tracing-with-opentelemetry-spring-cloud-sleuth-kafka-and-jaeger-939e35f45821?source=collection_archive---------0-----------------------#2022-06-13">https://betterprogramming.pub/distributed-tracing-with-opentelemetry-spring-cloud-sleuth-kafka-and-jaeger-939e35f45821?source=collection_archive---------0-----------------------#2022-06-13</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="de69" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">微服务中分布式跟踪实施的分步指南</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/056e0cf6195e87fe5d73478f598223e8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*QX2aJeO-ANSCEPGtEnRduQ.jpeg"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">图片由<a class="ae ky" href="https://pixabay.com/users/rud0070-1337509/?utm_source=link-attribution&amp;amp;utm_medium=referral&amp;amp;utm_campaign=image&amp;amp;utm_content=2338138" rel="noopener ugc nofollow" target="_blank"> rud0070 </a>来自<a class="ae ky" href="https://pixabay.com/?utm_source=link-attribution&amp;amp;utm_medium=referral&amp;amp;utm_campaign=image&amp;amp;utm_content=2338138" rel="noopener ugc nofollow" target="_blank"> Pixabay </a></p></figure><p id="41d4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">分布式跟踪使您能够深入了解特定服务作为分布式软件系统整体的一部分是如何执行的。它跟踪并记录从起点到目的地的请求，以及请求通过的系统。</p><p id="b026" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在本文中，我们将使用OpenTelemetry、Spring Cloud Sleuth、Kafka和Jaeger在三个Spring Boot微服务中实现分布式跟踪。</p><p id="e25c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们先来看看分布式跟踪中的一些基本术语。</p><p id="dd97" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">Span:表示系统中的单个工作单元。跨度可以相互嵌套，以模拟工作的分解。例如，一个span可能调用一个REST端点，而另一个子span可能是调用另一个端点的端点，以此类推，在不同的服务中。</p><p id="37c8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">Trace:共享同一个根span的span的集合，或者更简单地说，是作为原始请求的直接结果而创建的所有span。跨度的层次结构(每个跨度在根跨度旁边都有自己的父跨度)可用于形成有向非循环图，该图显示了请求通过各种组件时的路径。</p><h1 id="8568" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">开放式遥测</h1><p id="38d1" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated"><a class="ae ky" href="https://opentelemetry.io/" rel="noopener ugc nofollow" target="_blank"> OpenTelemetry </a>，也简称OTel，是一个厂商中立的开源可观测性框架，用于检测、生成、收集和导出遥测数据，如<a class="ae ky" href="https://opentelemetry.io/docs/concepts/observability-primer/#distributed-traces" rel="noopener ugc nofollow" target="_blank">轨迹</a>、<a class="ae ky" href="https://opentelemetry.io/docs/concepts/observability-primer/#reliability--metrics" rel="noopener ugc nofollow" target="_blank">度量</a>和<a class="ae ky" href="https://opentelemetry.io/docs/concepts/observability-primer/#logs" rel="noopener ugc nofollow" target="_blank">日志</a>。作为云原生计算基金会(CNCF)的孵化项目，OTel旨在提供统一的供应商无关库和API集——主要用于收集数据并将其传输到某个地方。OTel正在成为生成和管理遥测数据的世界标准，并被广泛采用。</p><h1 id="fb64" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">春云侦探</h1><p id="fc4f" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated"><a class="ae ky" href="https://spring.io/projects/spring-cloud-sleuth" rel="noopener ugc nofollow" target="_blank"> Sleuth </a>是由Spring Cloud团队管理和维护的项目，旨在将分布式跟踪功能集成到Spring Boot应用程序中。它作为一个典型的<code class="fe ms mt mu mv b">Spring Starter</code>捆绑在一起，因此只需将其作为一个依赖项添加，自动配置就可以处理整个应用程序的所有集成和工具。这里有一些现成的侦探工具:</p><ul class=""><li id="5d80" class="mw mx it lb b lc ld lf lg li my lm mz lq na lu nb nc nd ne bi translated">在Spring MVC控制器(REST端点)上接收的请求</li><li id="3223" class="mw mx it lb b lc nf lf ng li nh lm ni lq nj lu nb nc nd ne bi translated">通过Kafka或MQ等消息传递技术的请求</li><li id="ee19" class="mw mx it lb b lc nf lf ng li nh lm ni lq nj lu nb nc nd ne bi translated">使用<code class="fe ms mt mu mv b">RestTemplate</code>、<code class="fe ms mt mu mv b">WebClient</code>等提出请求。</li></ul><p id="5bca" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">Sleuth添加了一个拦截器来确保所有的跟踪信息都在请求中传递。每次调用时，都会创建一个新的Span。它在收到响应时关闭。</p><p id="251a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">Sleuth能够跟踪您的请求和消息，因此您可以将该通信与相应的日志条目相关联。您还可以将跟踪信息导出到外部系统，以直观显示延迟。</p><h1 id="c0fb" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">贼鸥</h1><p id="5192" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">Jaeger最初由优步的团队建造，然后在2015年开源。它于2017年被接受为云原生孵化项目，并于2019年毕业。作为CNCF的一部分，Jaeger是云原生架构中公认的项目。它的源代码主要是用Go编写的。耶格的架构包括:</p><ul class=""><li id="fd63" class="mw mx it lb b lc ld lf lg li my lm mz lq na lu nb nc nd ne bi translated">检测库</li><li id="06ca" class="mw mx it lb b lc nf lf ng li nh lm ni lq nj lu nb nc nd ne bi translated">收集者</li><li id="708c" class="mw mx it lb b lc nf lf ng li nh lm ni lq nj lu nb nc nd ne bi translated">查询服务和web用户界面</li><li id="63c9" class="mw mx it lb b lc nf lf ng li nh lm ni lq nj lu nb nc nd ne bi translated">数据库存储</li></ul><p id="8d95" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">与Jaeger类似，Zipkin也在其架构中提供了相同的组件集。虽然Zipkin是一个较老的项目，但Jaeger有一个更现代和可扩展的设计。对于这个例子，我们选择了Jaeger作为后端。</p><h1 id="c03f" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">跟踪系统设计</h1><p id="05e4" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">让我们设计三个Spring Boot微服务:</p><ul class=""><li id="b1df" class="mw mx it lb b lc ld lf lg li my lm mz lq na lu nb nc nd ne bi translated"><code class="fe ms mt mu mv b">customer-service-bff</code>:使用<code class="fe ms mt mu mv b">backend for frontend</code>模式，这个服务位于用户界面和后端之间。它由一个UI web应用程序调用，该应用程序又通过REST API调用来调用后端客户服务。</li><li id="2a10" class="mw mx it lb b lc nf lf ng li nh lm ni lq nj lu nb nc nd ne bi translated"><code class="fe ms mt mu mv b">customer-service</code>:简单的客户CRUD服务。除了在CRUD操作时将数据保存到数据库之外，它还在创建、更新或删除客户记录时将事件发布到Kafka。</li><li id="76bc" class="mw mx it lb b lc nf lf ng li nh lm ni lq nj lu nb nc nd ne bi translated"><code class="fe ms mt mu mv b">order-service</code>:监听Kafka主题，消费客户创建/更新/删除的事件。</li></ul><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nk"><img src="../Images/3e86f9d501fc05ca1da91109124a8dfe.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*L5ywvWo5d8VrXG9myArU6g.png"/></div></div></figure><p id="e773" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这三种微服务旨在:</p><ul class=""><li id="6807" class="mw mx it lb b lc ld lf lg li my lm mz lq na lu nb nc nd ne bi translated">通过REST API ( <code class="fe ms mt mu mv b">customer-service-bff</code>和<code class="fe ms mt mu mv b">customer-service</code>)进行通信</li><li id="46b7" class="mw mx it lb b lc nf lf ng li nh lm ni lq nj lu nb nc nd ne bi translated">通过Kafka ( <code class="fe ms mt mu mv b">customer-service</code>和<code class="fe ms mt mu mv b">order-service</code>)经由事件驱动的发布/订阅进行通信</li></ul><p id="906d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这是为了观察OpenTelemetry结合Spring Cloud Sleuth如何处理代码的自动插装，并生成和传输跟踪数据。上面的虚线捕获了跟踪数据的路径，由微服务导出，通过OTLP (OpenTelemetry Protocol)传输到OpenTelemetry收集器，收集器反过来处理并导出跟踪数据到后端Jaeger进行存储和查询。</p><p id="a819" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">使用monorepo，我们的项目结构如下:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi nl"><img src="../Images/fe755a967715631398bfb7da77858471.png" data-original-src="https://miro.medium.com/v2/resize:fit:568/format:webp/1*W3191-FQpr1GBbJVSjpsHQ.png"/></div></figure><h1 id="848c" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">步骤1:添加POM依赖项</h1><p id="2707" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">这是使用OTel和Spring Cloud Sleuth实现分布式跟踪的关键。我们的目标是不需要手动检测我们的代码，所以我们依靠这些依赖来做它们被设计来做的事情——自动检测我们的代码，除了跟踪实现，将遥测数据导出到OTel收集器，等等。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nm nn l"/></div></figure><ul class=""><li id="e118" class="mw mx it lb b lc ld lf lg li my lm mz lq na lu nb nc nd ne bi translated"><code class="fe ms mt mu mv b">spring-cloud-dependencies</code>:春云相依</li><li id="59cf" class="mw mx it lb b lc nf lf ng li nh lm ni lq nj lu nb nc nd ne bi translated"><code class="fe ms mt mu mv b">spring-cloud-sleuth-otel-dependencies</code>:春云Sleuth OpenTelemetry依赖</li><li id="057e" class="mw mx it lb b lc nf lf ng li nh lm ni lq nj lu nb nc nd ne bi translated"><code class="fe ms mt mu mv b">spring-cloud-starter-sleuth</code> : Sleuth通过<code class="fe ms mt mu mv b">spring-cloud-sleuth-brave</code>模块中可用的桥与OpenZipkin Brave tracer集成。由于我们将在示例中使用OpenTelemetry tracer，我们从<code class="fe ms mt mu mv b">spring-cloud-starter-sleuth</code>依赖项中排除了<code class="fe ms mt mu mv b">spring-cloud-sleuth-brave</code>,而是添加了<code class="fe ms mt mu mv b">spring-cloud-sleuth-otel-autoconfigure</code>依赖项。这将基于<a class="ae ky" href="https://github.com/openzipkin/brave/tree/master/brave" rel="noopener ugc nofollow" target="_blank"> Brave </a>的默认追踪实现替换为基于OpenTelemetry的实现。</li><li id="5ebf" class="mw mx it lb b lc nf lf ng li nh lm ni lq nj lu nb nc nd ne bi translated"><code class="fe ms mt mu mv b">opentelemetry-exporter-otlp-trace</code>:这是Spring Cloud Sleuth OTel中向OpenTelemetry收集器发送跟踪的组件。</li></ul><h1 id="6e37" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">步骤2:打开遥测配置</h1><h2 id="eb50" class="no lw it bd lx np nq dn mb nr ns dp mf li nt nu mh lm nv nw mj lq nx ny ml nz bi translated">打开遥测收集器端点</h2><p id="bd7f" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">对于每个微服务，我们需要在<code class="fe ms mt mu mv b">application.yml</code>中添加以下配置(参见下一节中的示例片段)。<code class="fe ms mt mu mv b">spring.sleuth.otel.exporter.otlp.endpoint</code>主要是配置OTel收集器端点。它告诉导出器，在我们的例子中是Sleuth，通过OTLP将跟踪数据发送到指定的收集器端点<code class="fe ms mt mu mv b"><a class="ae ky" href="http://otel-collector:4317." rel="noopener ugc nofollow" target="_blank">http://otel-collector:4317</a></code>。注意端点URL中的<code class="fe ms mt mu mv b">otel-collector</code>来自<code class="fe ms mt mu mv b">otel-collector</code>图像的docker-compose服务。</p><h2 id="f39e" class="no lw it bd lx np nq dn mb nr ns dp mf li nt nu mh lm nv nw mj lq nx ny ml nz bi translated">追踪数据概率抽样</h2><p id="119a" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated"><code class="fe ms mt mu mv b">spring.sleuth.otel.config.trace-id-ratio-based</code>属性定义了跟踪数据的采样概率。它根据提供给采样器的部分采样一小部分轨迹。概率抽样允许OpenTelemetry tracing用户通过使用随机抽样技术降低跨度收集成本。如果该比率小于1.0，某些轨迹将不会导出。对于本例，我们将采样配置为1.0，100%。</p><p id="3e96" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">有关其他OTel Spring Cloud Sleuth属性，请参见<a class="ae ky" href="https://spring-projects-experimental.github.io/spring-cloud-sleuth-otel/docs/current/reference/html/appendix.html#common-application-properties" rel="noopener ugc nofollow" target="_blank">通用应用程序属性</a>。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nm nn l"/></div></figure><h2 id="8eac" class="no lw it bd lx np nq dn mb nr ns dp mf li nt nu mh lm nv nw mj lq nx ny ml nz bi translated">打开遥测配置文件</h2><p id="0889" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">我们需要在项目根目录下有一个OTel配置文件<code class="fe ms mt mu mv b">otel-config.yaml</code>。内容如下。这个配置文件定义了OTel接收器、处理器和导出器的行为。正如我们所看到的，我们定义了我们的接收器来监听gRPC和HTTP，处理器使用batch，导出器使用jaeger和logging。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nm nn l"/></div></figure><h1 id="233e" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">第三步:docker-compose将所有内容串在一起</h1><p id="1cf9" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">让我们来看看为了运行这三个微服务并观察它们的分布式跟踪，我们需要启动的docker容器，前三个微服务在上一节中已有解释。</p><ul class=""><li id="3e81" class="mw mx it lb b lc ld lf lg li my lm mz lq na lu nb nc nd ne bi translated"><code class="fe ms mt mu mv b">customer-service-bff</code></li><li id="67cb" class="mw mx it lb b lc nf lf ng li nh lm ni lq nj lu nb nc nd ne bi translated"><code class="fe ms mt mu mv b">customer-service</code></li><li id="f9b9" class="mw mx it lb b lc nf lf ng li nh lm ni lq nj lu nb nc nd ne bi translated"><code class="fe ms mt mu mv b">order-service</code></li><li id="fd0d" class="mw mx it lb b lc nf lf ng li nh lm ni lq nj lu nb nc nd ne bi translated"><code class="fe ms mt mu mv b">postgres-customer</code>:用于<code class="fe ms mt mu mv b">customer-service</code>的数据库</li><li id="7e6a" class="mw mx it lb b lc nf lf ng li nh lm ni lq nj lu nb nc nd ne bi translated"><code class="fe ms mt mu mv b">postgres-order</code>:用于<code class="fe ms mt mu mv b">order-service</code>的数据库</li><li id="1553" class="mw mx it lb b lc nf lf ng li nh lm ni lq nj lu nb nc nd ne bi translated"><code class="fe ms mt mu mv b">jaeger-all-in-one</code>:运行所有Jaeger后端组件和UI的单一映像</li><li id="7cd5" class="mw mx it lb b lc nf lf ng li nh lm ni lq nj lu nb nc nd ne bi translated"><code class="fe ms mt mu mv b">otel-collector</code>:open telemetry tracing的引擎，接收、处理并导出跟踪数据到后端</li><li id="566b" class="mw mx it lb b lc nf lf ng li nh lm ni lq nj lu nb nc nd ne bi translated"><code class="fe ms mt mu mv b">zookeeper</code>:跟踪Kafka集群中节点的状态，维护Kafka主题和消息列表</li><li id="3657" class="mw mx it lb b lc nf lf ng li nh lm ni lq nj lu nb nc nd ne bi translated"><code class="fe ms mt mu mv b">kafka</code>:发布/订阅事件流处理平台</li></ul><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nm nn l"/></div></figure><p id="4ea6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">运行<code class="fe ms mt mu mv b">docker-compose up -d</code>调出所有九个容器:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi oa"><img src="../Images/f5d9a539cf6de71823ed82989494dd1b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*UO9iAJTfy8D7zu-A4DaEMQ.png"/></div></div></figure><h1 id="7603" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">步骤4:跟踪运行中的数据</h1><h2 id="08d4" class="no lw it bd lx np nq dn mb nr ns dp mf li nt nu mh lm nv nw mj lq nx ny ml nz bi translated">快乐之路</h2><p id="7c66" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">现在，让我们启动我们的<code class="fe ms mt mu mv b">customer-service-bff</code>，流程的入口点，来创建一个新客户。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ob"><img src="../Images/b193a6a56c27bbd8a41ab9370016b849.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*M9gT9Viu3t3tsK48jIBwTw.png"/></div></div></figure><p id="36b3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">启动Jaeger UI，<code class="fe ms mt mu mv b"><a class="ae ky" href="http://localhost:16686/," rel="noopener ugc nofollow" target="_blank">http://localhost:16686/</a></code> <a class="ae ky" href="http://localhost:16686/," rel="noopener ugc nofollow" target="_blank">，</a>按服务搜索<code class="fe ms mt mu mv b">customer-service-bff</code>，点击<code class="fe ms mt mu mv b">Find Traces</code>按钮，这里是我们看到的创建客户跟踪:它跨越了三个服务，总共跨越了六个，持续时间82.35毫秒</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi oc"><img src="../Images/251d52f8d35a6a230d8c86604e6ba6c3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*w7DUwFYv9zVde_WbR6rvUQ.png"/></div></div></figure><p id="4c30" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">除了跟踪时间线视图(上面的截图)，Jaeger还提供了一个图形视图(在右上方的下拉菜单中选择<code class="fe ms mt mu mv b">Trace Graph</code>):</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi od"><img src="../Images/cfb5acb742dbcc3f478c32732ea22111.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*G7sP-PZaGU6F2oUJqdHnag.png"/></div></div></figure><p id="f75d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">docker中三个微服务的日志输出显示了相同的trace id，以红色突出显示，而不同的span id根据它们的应用程序名称而不同(应用程序名称及其对应的span id以匹配的颜色突出显示)。在<code class="fe ms mt mu mv b">customer-service</code>的例子中，相同的span id从REST API请求传递到Kafka publisher请求。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi oe"><img src="../Images/60d3314ccc307f637afc038643ff9ccd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*P2ZkDVRO1eLQnF_3lujkCw.png"/></div></div></figure><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi of"><img src="../Images/e372838a223d1239d2f503da1be548ec.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*WqcL5igezZpbo55S2tqesA.png"/></div></div></figure><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi og"><img src="../Images/a8d3853eff21b4df97b9ca7064ae91ce.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*wIudBUbAoXbtJyZKwGyi4g.png"/></div></div></figure><h2 id="a84d" class="no lw it bd lx np nq dn mb nr ns dp mf li nt nu mh lm nv nw mj lq nx ny ml nz bi translated">错误场景</h2><p id="e03b" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">让我们暂停docker中的<code class="fe ms mt mu mv b">customer-service</code> PostgreSQL数据库，并从<code class="fe ms mt mu mv b">customer-service-bff</code>开始重复创建客户流。我们得到了<code class="fe ms mt mu mv b">500 internal server error</code>，不出所料。在Jaeger中，我们看到了下面的跟踪，除了stacktrace抱怨<code class="fe ms mt mu mv b">SocketTimeoutException</code>之外，还是和预期的一样。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi oh"><img src="../Images/e54f303ae9eeddeed403bede53d6d793.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*TOxPGTfydjtkMBmQg8bILw.png"/></div></div></figure><h2 id="f438" class="no lw it bd lx np nq dn mb nr ns dp mf li nt nu mh lm nv nw mj lq nx ny ml nz bi translated">识别长期跨度</h2><p id="67e2" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">Jaeger UI允许我们搜索超过指定最大持续时间的轨迹。例如，我们可以搜索所有耗时超过1000毫秒的轨迹。然后，我们可以深入长期运行的跟踪，调查它们的根本原因。</p><h1 id="abbb" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">摘要</h1><p id="d7c2" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">在本文中，我们从OpenTelemetry、Spring Cloud Sleuth和Jaeger的角度展开了分布式跟踪，在REST API调用和Kafka pub/sub中验证了分布式跟踪的自动检测。我希望这个故事能让你更好地理解这些跟踪框架和工具，尤其是OpenTelemetry，以及它如何从根本上改变我们在分布式系统中的可观测性。</p><p id="5bcf" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这个故事的源代码可以在<a class="ae ky" href="https://github.com/wenqiglantz/opentelemetry-sleuth-kafka-jaeger.git" rel="noopener ugc nofollow" target="_blank">我的GitHub repo </a>中找到。</p><p id="d535" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">有关如何将DataDog与OpenTelemetry集成用于分布式跟踪的说明，请查看我的故事<a class="ae ky" rel="noopener ugc nofollow" target="_blank" href="/distributed-tracing-with-opentelemetry-and-datadog-712f8f4d520b?sk=37f65dd5977968bae9c98bdcac9b047d">使用OpenTelemetry和DataDog的分布式跟踪</a>。</p><p id="0512" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">编码快乐！</p><h1 id="46eb" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">参考</h1><p id="2162" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated"><a class="ae ky" href="https://opentelemetry.io/docs/" rel="noopener ugc nofollow" target="_blank">https://opentelemetry.io/docs/</a></p><p id="86b1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><a class="ae ky" href="https://docs.spring.io/spring-cloud-sleuth/docs/current/reference/html/getting-started.html#getting-started" rel="noopener ugc nofollow" target="_blank">https://docs . spring . io/spring-cloud-sleuth/docs/current/reference/html/getting-started . html # getting-started</a></p><p id="6158" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><a class="ae ky" href="https://storiesfromtheherd.com/unpacking-observability-the-observability-stack-93d4733e2a72" rel="noopener ugc nofollow" target="_blank">https://storiesfromtheerd . com/unpacking-observability-the-observability-stack-93d 4733 e2a 72</a></p><p id="ade4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><a class="ae ky" href="https://medium.com/dzerolabs/observability-journey-understanding-logs-events-traces-and-spans-836524d63172" rel="noopener">https://medium . com/dzerolabs/observability-journey-understanding-logs-events-traces-and-spans-836524d 63172</a></p><p id="cfba" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><a class="ae ky" href="https://ryanharrison.co.uk/2021/08/06/distributed-tracing-spring-boot-jaeger.html" rel="noopener ugc nofollow" target="_blank">https://ryanharrison . co . uk/2021/08/06/distributed-tracing-spring-boot-jaeger . html</a></p><p id="82aa" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><a class="ae ky" href="https://towardsdev.com/opentelemetry-spring-boot-kafka-and-jaeger-in-action-8ef1912c8044" rel="noopener ugc nofollow" target="_blank">https://towardsdev . com/open telemetry-spring-boot-Kafka-and-jaeger-in-action-8ef 1912 c 8044</a></p><p id="44a1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><a class="ae ky" href="https://reflectoring.io/spring-boot-tracing" rel="noopener ugc nofollow" target="_blank">https://reflectoring.io/spring-boot-tracing</a></p></div></div>    
</body>
</html>