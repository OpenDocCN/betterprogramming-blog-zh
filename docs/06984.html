<html>
<head>
<title>The Stateful Widget Lifecycle</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">有状态小部件生命周期</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/stateful-widget-lifecycle-a01c44dc89b0?source=collection_archive---------2-----------------------#2020-11-24">https://betterprogramming.pub/stateful-widget-lifecycle-a01c44dc89b0?source=collection_archive---------2-----------------------#2020-11-24</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><h2 id="3747" class="ir is it bd b dl iu iv iw ix iy iz dk ja translated" aria-label="kicker paragraph">发现颤动——第13周</h2><div class=""/><div class=""><h2 id="0c65" class="pw-subtitle-paragraph jz jc it bd b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq dk translated">求职面试中最常见的问题之一</h2></div><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi kr"><img src="../Images/e37a99981afb7f1961b8c2fa43669394.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*GvuiZDGWVqkskrHQgRm8yA.jpeg"/></div></div><p class="ld le gj gh gi lf lg bd b be z dk translated"><a class="ae lh" href="https://unsplash.com/@kencheungphoto?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">张艺</a>在<a class="ae lh" href="https://unsplash.com/@kencheungphoto?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍照。</p></figure><p id="3173" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">不像无状态窗口小部件，每当我们想要做一些改变时，我们必须销毁并重新创建，有状态窗口小部件具有可变的状态。</p><p id="72f9" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">工作面试中经常出现的一个问题是关于有状态小部件的生命周期，因此这篇文章专门讨论这个主题。</p></div><div class="ab cl me mf hx mg" role="separator"><span class="mh bw bk mi mj mk"/><span class="mh bw bk mi mj mk"/><span class="mh bw bk mi mj"/></div><div class="im in io ip iq"><h1 id="fa26" class="ml mm it bd mn mo mp mq mr ms mt mu mv ki mw kj mx kl my km mz ko na kp nb nc bi translated">StatefulWidget的七个周期</h1><p id="53bf" class="pw-post-body-paragraph li lj it lk b ll nd kd ln lo ne kg lq lr nf lt lu lv ng lx ly lz nh mb mc md im bi translated">当Flutter构建有状态小部件时，它首先执行小部件的<code class="fe ni nj nk nl b">constructor</code>函数，然后调用<code class="fe ni nj nk nl b">createState()</code>方法。如果我们看一下有状态小部件，首先执行构造函数。另一方面，如果我们看一下有状态小部件的<code class="fe ni nj nk nl b">State</code>对象，它的生命周期从调用<code class="fe ni nj nk nl b">createState()</code>方法时开始。</p><p id="b557" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated"><em class="nm">注意:</em> <code class="fe ni nj nk nl b"><em class="nm">constructor</em></code> <em class="nm">函数不是生命周期的一部分，因为</em> <code class="fe ni nj nk nl b"><em class="nm">widget</em></code> <em class="nm">属性的状态在那时是空的。</em></p><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi nn"><img src="../Images/a0806eb5c7480eb68fbf7caf4989282a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*9kFme2gBIl9HtYFidAZw0w.jpeg"/></div></div><p class="ld le gj gh gi lf lg bd b be z dk translated">图片由贾云馨·约万诺斯基提供。</p></figure><h2 id="8cf0" class="no mm it bd mn np nq dn mr nr ns dp mv lr nt nu mx lv nv nw mz lz nx ny nb iz bi translated">1.创建状态()</h2><p id="9a9b" class="pw-post-body-paragraph li lj it lk b ll nd kd ln lo ne kg lq lr nf lt lu lv ng lx ly lz nh mb mc md im bi translated">这个方法创建了一个<code class="fe ni nj nk nl b"><a class="ae lh" href="https://docs.flutter.io/flutter/widgets/State-class.html" rel="noopener ugc nofollow" target="_blank">State</a></code>对象。这个对象保存了该小部件的所有可变状态。这个方法是<code class="fe ni nj nk nl b">StatefulWidget</code>内的<code class="fe ni nj nk nl b">required</code>:</p><pre class="ks kt ku kv gt nz nl oa ob aw oc bi"><span id="fa03" class="no mm it nl b gy od oe l of og"><em class="nm">class </em>MyHomePage <em class="nm">extends </em>StatefulWidget {<br/>  @override<br/>  _MyHomePageState createState() =&gt; _MyHomePageState();<br/>}</span></pre><h2 id="7cc9" class="no mm it bd mn np nq dn mr nr ns dp mv lr nt nu mx lv nv nw mz lz nx ny nb iz bi translated">已安装(真)</h2><p id="d0b4" class="pw-post-body-paragraph li lj it lk b ll nd kd ln lo ne kg lq lr nf lt lu lv ng lx ly lz nh mb mc md im bi translated">一旦我们创建了一个<code class="fe ni nj nk nl b">State</code>对象，框架就会通过将名为<code class="fe ni nj nk nl b">mounted</code>的布尔属性设置为<code class="fe ni nj nk nl b">true</code>来将<code class="fe ni nj nk nl b">State</code>对象与<code class="fe ni nj nk nl b">BuildContext</code>相关联。这个属性告诉我们这个<code class="fe ni nj nk nl b"><a class="ae lh" href="https://api.flutter.dev/flutter/widgets/State-class.html" rel="noopener ugc nofollow" target="_blank">State</a></code>对象当前是否在小部件树中。</p><p id="ee16" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated"><em class="nm">注意:这一步并没有被标记为生命周期中的一个真正的步骤，但是知道后台正在发生什么是很重要的。</em></p><h2 id="86e2" class="no mm it bd mn np nq dn mr nr ns dp mv lr nt nu mx lv nv nw mz lz nx ny nb iz bi translated">2.initState()</h2><p id="0d30" class="pw-post-body-paragraph li lj it lk b ll nd kd ln lo ne kg lq lr nf lt lu lv ng lx ly lz nh mb mc md im bi translated">当对象被插入到树中时(<code class="fe ni nj nk nl b">mounted</code>属性被设置为<code class="fe ni nj nk nl b">true</code>)，该方法在类构造函数之后自动执行。<code class="fe ni nj nk nl b">initState()</code>只被调用一次，当状态对象第一次被创建时。</p><p id="56c8" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated"><em class="nm">注意:不能从该方法中使用</em> <code class="fe ni nj nk nl b"><em class="nm">BuildContext</em></code> <em class="nm">。</em></p><p id="3738" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated"><em class="nm">提示:使用这个方法来管理HTTP请求和订阅流或任何其他可能改变这个小部件上的数据的对象。</em></p><pre class="ks kt ku kv gt nz nl oa ob aw oc bi"><span id="d091" class="no mm it nl b gy od oe l of og">@override<br/><em class="nm">void </em>initState() {<br/>  <em class="nm">super</em>.initState();<br/>  <em class="nm">// TODO: implement initState<br/></em>}</span></pre><h2 id="a83d" class="no mm it bd mn np nq dn mr nr ns dp mv lr nt nu mx lv nv nw mz lz nx ny nb iz bi translated">3.didChangeDependencies()</h2><p id="c74f" class="pw-post-body-paragraph li lj it lk b ll nd kd ln lo ne kg lq lr nf lt lu lv ng lx ly lz nh mb mc md im bi translated">框架会在<code class="fe ni nj nk nl b">initState()</code>之后立即调用这个方法。当小部件所依赖的对象发生变化时，也会调用它。<code class="fe ni nj nk nl b">build</code>方法总是在这个方法之后被调用，所以很少需要这个方法。然而，这个方法是第一个可以用来调用<code class="fe ni nj nk nl b">BuildContext.inheritFromWidgetOfExactType</code>的方法。</p><h2 id="1adc" class="no mm it bd mn np nq dn mr nr ns dp mv lr nt nu mx lv nv nw mz lz nx ny nb iz bi translated">4.构建()</h2><p id="26e0" class="pw-post-body-paragraph li lj it lk b ll nd kd ln lo ne kg lq lr nf lt lu lv ng lx ly lz nh mb mc md im bi translated">这个方法是<code class="fe ni nj nk nl b">required</code>，在生命周期中会被调用很多次，但是第一次是在<code class="fe ni nj nk nl b">didChangeDependencies()</code>方法之后。所以每当属于状态的小部件被更新时，框架总是会执行这个方法(即每次调用<code class="fe ni nj nk nl b">didUpdateWidget()</code>或<code class="fe ni nj nk nl b">setState()</code>方法)。</p><h2 id="b818" class="no mm it bd mn np nq dn mr nr ns dp mv lr nt nu mx lv nv nw mz lz nx ny nb iz bi translated">5.didUpdateWidget()</h2><p id="1023" class="pw-post-body-paragraph li lj it lk b ll nd kd ln lo ne kg lq lr nf lt lu lv ng lx ly lz nh mb mc md im bi translated">如果父小部件更改了其配置并且必须重新构建小部件，则调用该函数。框架将旧的小部件作为一个参数提供给你，你可以用它与新的小部件进行比较。Flutter会在它之后调用<code class="fe ni nj nk nl b">build()</code>方法。</p><p id="f63d" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated"><em class="nm">提示:如果你需要比较新旧部件，可以使用这个方法。</em></p><pre class="ks kt ku kv gt nz nl oa ob aw oc bi"><span id="6972" class="no mm it nl b gy od oe l of og">@override<br/><em class="nm">void </em>didUpdateWidget(<em class="nm">covariant </em>MyHomePage <em class="nm">oldWidget</em>) {<br/>  <em class="nm">super</em>.didUpdateWidget(<em class="nm">oldWidget</em>);<br/>  <em class="nm">// TODO: implement didUpdateWidget<br/></em>}</span></pre><h2 id="cf47" class="no mm it bd mn np nq dn mr nr ns dp mv lr nt nu mx lv nv nw mz lz nx ny nb iz bi translated">setState()</h2><p id="afdd" class="pw-post-body-paragraph li lj it lk b ll nd kd ln lo ne kg lq lr nf lt lu lv ng lx ly lz nh mb mc md im bi translated">这个方法通常从Flutter框架本身和开发人员那里调用。<code class="fe ni nj nk nl b">setState()</code>方法通知框架当前对象的内部状态是“脏的”，这意味着它已经以一种可能影响UI的方式被改变。在这个通知之后，框架将调用<code class="fe ni nj nk nl b">build()</code>方法来更新和重建一个小部件。</p><p id="3538" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated"><em class="nm">提示:每当你改变一个</em> <code class="fe ni nj nk nl b"><a class="ae lh" href="https://api.flutter.dev/flutter/widgets/State-class.html" rel="noopener ugc nofollow" target="_blank"><em class="nm">State</em></a></code> <em class="nm">对象的内部状态时，在</em> <code class="fe ni nj nk nl b"><em class="nm">setState()</em></code> <em class="nm">方法中进行改变。</em></p><pre class="ks kt ku kv gt nz nl oa ob aw oc bi"><span id="f9aa" class="no mm it nl b gy od oe l of og">setState(() {<br/>  <em class="nm">// implement setState<br/></em>});</span></pre><p id="969f" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated"><em class="nm">注意:我不会将</em> <code class="fe ni nj nk nl b"><em class="nm">setState</em></code> <em class="nm">标记为生命周期方法中的一个步骤，因为它是开发人员调用的唯一方法。</em></p><h2 id="e150" class="no mm it bd mn np nq dn mr nr ns dp mv lr nt nu mx lv nv nw mz lz nx ny nb iz bi translated">6.停用()</h2><p id="89b3" class="pw-post-body-paragraph li lj it lk b ll nd kd ln lo ne kg lq lr nf lt lu lv ng lx ly lz nh mb mc md im bi translated">当小部件从小部件树中移除时，调用该方法，但是当状态从树中的一点移动到另一点时，可以在当前帧更改完成之前重新插入该方法。</p><pre class="ks kt ku kv gt nz nl oa ob aw oc bi"><span id="8a61" class="no mm it nl b gy od oe l of og">@override<br/><em class="nm">void </em>deactivate() {<br/>  <em class="nm">super</em>.deactivate();<br/>  <em class="nm">// TODO: implement deactivate<br/></em>}</span></pre><h2 id="1401" class="no mm it bd mn np nq dn mr nr ns dp mv lr nt nu mx lv nv nw mz lz nx ny nb iz bi translated">7.处置()</h2><p id="7b55" class="pw-post-body-paragraph li lj it lk b ll nd kd ln lo ne kg lq lr nf lt lu lv ng lx ly lz nh mb mc md im bi translated">当<code class="fe ni nj nk nl b">State</code>对象从窗口小部件树中永久删除时，就会调用这个函数。</p><p id="cb60" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated"><em class="nm">提示:使用这个方法来清理数据监听器或生命连接。</em></p><pre class="ks kt ku kv gt nz nl oa ob aw oc bi"><span id="a598" class="no mm it nl b gy od oe l of og">@override<br/><em class="nm">void </em>dispose() {<br/>  <em class="nm">super</em>.dispose();<br/>  <em class="nm">// TODO: implement dispose<br/></em>}</span></pre><h2 id="7279" class="no mm it bd mn np nq dn mr nr ns dp mv lr nt nu mx lv nv nw mz lz nx ny nb iz bi translated">已安装(假)</h2><p id="4a9d" class="pw-post-body-paragraph li lj it lk b ll nd kd ln lo ne kg lq lr nf lt lu lv ng lx ly lz nh mb mc md im bi translated">在<code class="fe ni nj nk nl b">dispose()</code>方法之后，<code class="fe ni nj nk nl b"><a class="ae lh" href="https://api.flutter.dev/flutter/widgets/State-class.html" rel="noopener ugc nofollow" target="_blank">State</a></code>对象当前不在树中，所以<code class="fe ni nj nk nl b">mounted</code>属性现在是<code class="fe ni nj nk nl b">false</code>。状态对象永远不能重新挂载。</p></div><div class="ab cl me mf hx mg" role="separator"><span class="mh bw bk mi mj mk"/><span class="mh bw bk mi mj mk"/><span class="mh bw bk mi mj"/></div><div class="im in io ip iq"><h1 id="1b01" class="ml mm it bd mn mo mp mq mr ms mt mu mv ki mw kj mx kl my km mz ko na kp nb nc bi translated">结论</h1><p id="d8cb" class="pw-post-body-paragraph li lj it lk b ll nd kd ln lo ne kg lq lr nf lt lu lv ng lx ly lz nh mb mc md im bi translated">如果你是涵盖各种Flutter主题的简短有趣文章的粉丝，并且你想养成在接下来的18周内和我一起学习Flutter的习惯，你可以每周二阅读我的文章。</p><p id="2625" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">如果你对这篇文章有任何问题或评论，请在评论区告诉我。</p><p id="977c" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">对于那些想加入我们的颤振之旅的人，可以在下面找到前几周的链接:</p><ul class=""><li id="eb2d" class="oh oi it lk b ll lm lo lp lr oj lv ok lz ol md om on oo op bi translated"><a class="ae lh" href="https://medium.com/the-innovation/discover-flutter-roadmap-for-learning-flutter-why-textalign-property-does-not-work-aa055a469025" rel="noopener">第一周</a>——“学习颤振路线图”</li><li id="d350" class="oh oi it lk b ll oq lo or lr os lv ot lz ou md om on oo op bi translated"><a class="ae lh" href="https://medium.com/@jelenajjovanoski/discover-flutter-how-to-create-sliders-how-to-create-cool-text-designs-8adb0e1feea3" rel="noopener">第2周</a>——“如何创建简介滑块”</li><li id="e0e2" class="oh oi it lk b ll oq lo or lr os lv ot lz ou md om on oo op bi translated"><a class="ae lh" href="https://medium.com/@jelenajjovanoski/discover-flutter-how-to-easily-generate-routes-how-to-flatten-deeply-nested-widget-trees-9c66dae99a73" rel="noopener">第三周</a>——“如何轻松生成路线”</li><li id="d10f" class="oh oi it lk b ll oq lo or lr os lv ot lz ou md om on oo op bi translated"><a class="ae lh" href="https://medium.com/datadriveninvestor/discover-flutter-great-packages-for-pdf-viewing-tagging-flush-bar-26066e3c0d3b" rel="noopener">第4周</a>——“某些颤振包的建议”</li><li id="1515" class="oh oi it lk b ll oq lo or lr os lv ot lz ou md om on oo op bi translated">第五周——“底部导航栏”</li><li id="3063" class="oh oi it lk b ll oq lo or lr os lv ot lz ou md om on oo op bi translated">第六周——“每个动画的神圣三位一体”</li><li id="2899" class="oh oi it lk b ll oq lo or lr os lv ot lz ou md om on oo op bi translated"><a class="ae lh" href="https://medium.com/@jelenajjovanoski/discover-flutter-new-material-buttons-in-flutter-version-1-22-39b8f1887d8" rel="noopener">第7周</a>——“Flutter版本1.22中的新材料按钮”</li><li id="874e" class="oh oi it lk b ll oq lo or lr os lv ot lz ou md om on oo op bi translated"><a class="ae lh" href="https://medium.com/@jelenajjovanoski/discover-flutter-october-recommendation-for-flutter-packages-9d1b07f3490f" rel="noopener">第8周</a>——“我10月份对颤振套件的建议”</li><li id="4b29" class="oh oi it lk b ll oq lo or lr os lv ot lz ou md om on oo op bi translated"><a class="ae lh" href="https://levelup.gitconnected.com/discover-flutter-flutter-version-manager-fvm-411dc2bff4b4" rel="noopener ugc nofollow" target="_blank">第九周</a>——“Flutter版本经理——FVM”</li></ul><p id="8613" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">下周见。不要打破记录！</p></div></div>    
</body>
</html>