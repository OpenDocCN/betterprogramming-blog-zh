<html>
<head>
<title>The Making of a CarPlay Audio Application</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">一个CarPlay音频应用程序的制作</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/the-making-of-a-carplay-audio-application-18df87c36eae?source=collection_archive---------7-----------------------#2022-04-06">https://betterprogramming.pub/the-making-of-a-carplay-audio-application-18df87c36eae?source=collection_archive---------7-----------------------#2022-04-06</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="61fa" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">一个关于Qobuz的CarPlay应用的故事</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/6778f7a84b2d648d73bc35526d48037a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*hhmU8N-etlkaJu5qeG5SFg.jpeg"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">照片来自<a class="ae kv" href="https://www.hifipig.com/qobuz-my-weekly-q-and-qobuz-carplay-online/" rel="noopener ugc nofollow" target="_blank"> Hifipig </a></p></figure><p id="ac83" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在为高质量高保真音乐流媒体服务Qobuz工作时，我负责重新制作我们的CarPlay应用程序，这个应用程序存在一些问题。法国context公司Qobuz正在美国音响发烧友市场占有份额，我们收到了美国用户对我们的CarPlay应用程序的负面反馈，他们真的喜欢在车里听音乐。</p><p id="e815" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">由于我们的目标是拥有优质声音的优质用户，我们显然需要提供优质的体验，即使是在他们的车里。因此，我们开始着手修复和改进我们的CarPlay应用程序。遗憾的是，我很难在互联网上找到音频应用的例子。现在，我们的新应用程序已经启动并运行，我想我应该给自己添加一些关于制作CarPlay音频应用程序的内容，并包括一些关于开发过程的反馈。所以让我们开始吧！</p><h1 id="99d1" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">2021年CarPlay开发套件的状况</h1><p id="93b1" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">我很幸运，也让我惊喜的是，苹果在2020年的iOS 14中宣布了一个新的框架，巧妙地命名为CarPlay，它引入了一种新的更现代的方法来开发CarPlay应用程序。好消息！我不能说我是老方法的忠实粉丝，那就是使用MediaPlayer框架。它对开发人员不友好，有一个奇怪的实现，我发现自己不得不多次编写代码来解决我的问题。1/10，不推荐。</p><p id="2d9c" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">但是回到2021年，我们支持iOS 12.0和更高版本，由于新的CarPlay套件只能从iOS 14.0开始提供，为了给我们所有的用户提供CarPlay体验，我别无选择，只能同时处理这两种方法。因为我不认为，在2022年，谈论旧的方式是相关的，我将主要用CarPlay Kit覆盖我的工作，并快速谈论MediaPlayer。</p><p id="f5ff" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">但是如果你不得不在旧版本的iOS上使用这个框架(运气不好)并且遇到了麻烦，请随时在Medium上给我发消息，我会看看是否能帮到你:)。</p><h1 id="1eb8" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">CarPlay套件，新方式</h1><p id="1360" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">因为我想有一个好的开始，所以我决定使用CarPlay框架来解决这个版本，这是一个旨在代表未来的版本，显然也是两个版本中最重要的版本。事情是这样运作的:</p><h2 id="043e" class="mp lt iq bd lu mq mr dn ly ms mt dp mc lf mu mv me lj mw mx mg ln my mz mi na bi translated">权利</h2><p id="5abc" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">首先，权利。你需要在这里越过<a class="ae kv" href="https://developer.apple.com/documentation/carplay/requesting_carplay_entitlements" rel="noopener ugc nofollow" target="_blank">，提供你的申请信息。苹果公司会审查它，如果它符合他们的标准，会积极地通知你。</a></p><p id="8abe" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">一旦它被接受，您必须创建一个包含这个新授权的新配置文件，并将其添加到您的项目中。</p><p id="f7e1" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">然后，在<code class="fe nb nc nd ne b">Entitlement.plist</code>文件中(如果不存在，则创建一个)，通过放置以下键来结束:</p><pre class="kg kh ki kj gt nf ne ng nh aw ni bi"><span id="1483" class="mp lt iq ne b gy nj nk l nl nm">&lt;key&gt;com.apple.developer.carplay-audio&lt;/key&gt;<br/>&lt;true/&gt;</span></pre><h2 id="1ca4" class="mp lt iq bd lu mq mr dn ly ms mt dp mc lf mu mv me lj mw mx mg ln my mz mi na bi translated">设置场景</h2><p id="d0bf" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">自从iOS 13推出以来，苹果一直在推动一种新的方法来处理你的应用程序的不同屏幕(这可能是你的主应用程序、CarPlay应用程序，或者是你在iPad上的分屏视图中复制的应用程序)，这就是<code class="fe nb nc nd ne b">UIScene</code>。如果你像我们一样在Qobuz没有或不支持这个，那么，你需要做一点工作，然后再推进你的花式CarPlay应用程序新一代。</p><p id="2389" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在我们的例子中，我们有两个不同的场景:一个名为<code class="fe nb nc nd ne b">AppSceneDelegate</code>，另一个名为<code class="fe nb nc nd ne b">CarplaySceneDelegate</code>。这里的名字不言自明。在创建了这些场景之后，在<code class="fe nb nc nd ne b">Info.plist</code>里面添加了一个新的键:<code class="fe nb nc nd ne b">UIApplicationSceneManifest</code>。它包含一个描述应用程序内部场景的字典。</p><p id="8255" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在这里，您首先要指定您的应用程序将支持多个场景，然后是各种属性，最值得注意的是代表场景入口点的类的名称(因此在我们的例子中，<code class="fe nb nc nd ne b">AppSceneDelegate</code>和<code class="fe nb nc nd ne b">CarplaySceneDelegate</code>)。你可以在下面看看我们的场景清单是如何表示的，但是如果你想要更多的信息，请查看苹果的相关文档:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nn no l"/></div></figure><p id="4eaf" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">但是等等，是什么使我告诉你的那些类成为<code class="fe nb nc nd ne b">UIScene</code>？根据Apple文档，<code class="fe nb nc nd ne b">UIScene</code>是实现<code class="fe nb nc nd ne b">UISceneDelegate</code>的类，提供在应用程序生命周期中调用的方法。似曾相识？的确，它注定要取代<code class="fe nb nc nd ne b">AppDelegate</code>。</p><p id="7050" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">当填充<code class="fe nb nc nd ne b">AppSceneDelegate</code>中的方法时，我实际上从我们的<code class="fe nb nc nd ne b">AppDelegate</code>中转移了代码，因为我让场景接管启动iOS 13。这个其实不多说，但是对于<code class="fe nb nc nd ne b">CarplaySceneDelegate</code>，还有最后一件事要做，就是让它符合<code class="fe nb nc nd ne b">CPTemplateApplicationSceneDelegate</code>。嗯，实际上没有需要添加的方法，但仍然有两个方法在我们今天的应用程序中使用:</p><pre class="kg kh ki kj gt nf ne ng nh aw ni bi"><span id="8693" class="mp lt iq ne b gy nj nk l nl nm">templateApplicationScene(_ , didConnect:)<br/>templateApplicationScene(_ , didDisconnectInterfaceController:)</span></pre><p id="3a74" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">它是我们的CarPlay应用程序的入口和出口点。在这些方法中，进行了一个简单的调用:</p><pre class="kg kh ki kj gt nf ne ng nh aw ni bi"><span id="0499" class="mp lt iq ne b gy nj nk l nl nm">//Entry point<br/>carplayTemplateManager.connect(interfaceController)</span><span id="e176" class="mp lt iq ne b gy np nk l nl nm">//Exit point<br/>carplayTemplateManager.disconnect()</span></pre><p id="619f" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">但是这个<code class="fe nb nc nd ne b">carplayTemplateManager</code>是什么？嗯，这是类型为<code class="fe nb nc nd ne b">CarplayTemplateManager</code>的<code class="fe nb nc nd ne b">CarplaySceneDelegate</code>的属性。这是一个处理所有与我们的iOS版本14及以上的CarPlay应用程序相关的代码的类，也是开发的下一步。</p><h2 id="73de" class="mp lt iq bd lu mq mr dn ly ms mt dp mc lf mu mv me lj mw mx mg ln my mz mi na bi translated">CarplayTemplateManager</h2><p id="8aa7" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">现在是时候真正构建我们的应用程序了！顾名思义，构建CarPlay应用程序是基于模板的。基类是<code class="fe nb nc nd ne b">CPTemplate</code>，在我们的例子中，我们使用<code class="fe nb nc nd ne b">CPTabBarTemplate</code>，它提供了与<code class="fe nb nc nd ne b">UITabBarController</code>相似的体验</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nq"><img src="../Images/ed665376e659469b482193b3a9f9244c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*QrAoVjGJFkFS9jyzdbD25Q.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">原谅我的法语，但你可以清楚地看到我们的CarPlay应用程序有三个标签</p></figure><p id="95f2" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">最基本的是建立一个根模板，在这种情况下是<code class="fe nb nc nd ne b">CPTabBarTemplate</code>，然后为每个菜单和子菜单创建其他模板和项目。我们的根模板初始化的基本代码如下所示:</p><pre class="kg kh ki kj gt nf ne ng nh aw ni bi"><span id="7bc1" class="mp lt iq ne b gy nj nk l nl nm">var tabTemplates = [CPTemplate]()<br/>tabTemplates.append(myQobuzTemplate())<br/>tabTemplates.append(localLibraryTemplate())<br/>tabTemplates.append(discoverTemplate())<br/>self.carplayInterfaceController!<br/>    .setRootTemplate(CPTabBarTemplate(templates: tabTemplates), <br/>                     animated: true, completion: nil)</span></pre><p id="ba7b" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在我看来，这是开发人员友好的代码。非常容易设置，非常容易阅读和理解，并且它马上产生一个结果。爱死了。</p><p id="a5fc" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">对于每个选项卡，都会创建一个<code class="fe nb nc nd ne b">CPListTemplate</code>。该模板由<code class="fe nb nc nd ne b">CPListItem</code>填充。我用了一点代码来创建My Qobuz模板，只是为了向您展示总体思路(请记住，为了清楚起见，我也修改了一点，真正的方法要长一点)</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nn no l"/></div></figure><p id="f613" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">有趣的部分肯定是<code class="fe nb nc nd ne b">CPListItem</code>中的属性处理器。分配给它的代码块将在用户点击列表项时执行。如果在内部进行了异步操作，CarPlay kit会自动在项目上放置一个滚轮微调器，等待操作完成。</p><p id="33d3" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在上面的例子中，没有异步操作，而是创建了另一个模板，使用方法<code class="fe nb nc nd ne b"><em class="nr">pushTemplate(:)</em></code>将该模板推送到接口上。它肯定会提醒你如何与一个<code class="fe nb nc nd ne b">UINavigationController</code>互动。这使得它更加友好。</p><p id="27c7" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这是我们创建<code class="fe nb nc nd ne b">CPListItem</code>的方法之一。在这个例子中，有一个异步操作，从我们的web服务加载相册。当点击成功模块时，一个由<code class="fe nb nc nd ne b">CPListItem</code>组成的数组被创建，每个数组代表一个专辑，被分配给一个<code class="fe nb nc nd ne b">CPListTemplate</code>，然后被推送到<code class="fe nb nc nd ne b">carplayInterfaceController</code>。最后要注意的是<code class="fe nb nc nd ne b"><em class="nr">completion()</em></code>。它是由handler属性提供的参数。调用它让处理程序知道您已经完成了操作，并且它可以继续执行。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nn no l"/></div></figure><p id="0b95" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">最后一件事:在我们的track <code class="fe nb nc nd ne b">CPListItem</code>处理程序中，我们不推送定制模板，而是这样做:</p><pre class="kg kh ki kj gt nf ne ng nh aw ni bi"><span id="c201" class="mp lt iq ne b gy nj nk l nl nm">self.pushNowPlayingTemplate()</span></pre><p id="62fe" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><code class="fe nb nc nd ne b">NowPlayingTemplate</code>是CarPlay kit提供的默认模板，可配置按钮(随机播放、重复播放等)、播放曲目的插图、曲目队列以及工作播放器所需的一切。模板是标准的，这意味着除了一些按钮，我们有或多或少相同的播放器看起来像Spotify或Apple Music。</p><p id="b6fd" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">仅此而已。剩下的代码只是更多的<code class="fe nb nc nd ne b">CPListTemplate</code>和更多的<code class="fe nb nc nd ne b">CPListItem</code>创作放在一起，瞧，你得到了一个CarPlay音频应用程序，它有一个干净的用户界面和良好的UX。</p><h1 id="e84b" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">简单说说MediaPlayer，老方法</h1><p id="4062" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">正如我所说的，我不会涉及我使用MediaPlayer框架的开发冒险的细节，因为这个版本的代码库注定要尽快在垃圾桶中完成。这里还有一些小细节可以帮助你。</p><h2 id="bcce" class="mp lt iq bd lu mq mr dn ly ms mt dp mc lf mu mv me lj mw mx mg ln my mz mi na bi translated">限制</h2><p id="2751" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">不要忘记指定您的CarPlay应用程序的限制。你必须限制屏幕上的项目数量(<code class="fe nb nc nd ne b">contentLimitItemCount</code>)和导航树的深度(<code class="fe nb nc nd ne b">contentLimitTreeDepth</code>)。苹果建议树的深度不要超过5，但他们也明确指出汽车制造商可以控制这些数字，并可以根据各种参数(如车速等)实现自己的算法。</p><p id="4f7c" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">关于<code class="fe nb nc nd ne b">contentLimitItemCount</code>，在出现性能问题后，我将200设置为任意数字。这就是我说的那种黑客。</p><pre class="kg kh ki kj gt nf ne ng nh aw ni bi"><span id="0847" class="mp lt iq ne b gy nj nk l nl nm">var contentLimitItemCount: Int = 200<br/>var contentLimitTreeDepth: Int = 5</span></pre><h2 id="f99e" class="mp lt iq bd lu mq mr dn ly ms mt dp mc lf mu mv me lj mw mx mg ln my mz mi na bi translated">复制新方式</h2><p id="e949" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">从CarPlay Kit开始，我从他们的API中获得灵感，在旧版本的开发过程中帮助我。所以最后我有了自己版本的基本款，如下图:</p><pre class="kg kh ki kj gt nf ne ng nh aw ni bi"><span id="a8af" class="mp lt iq ne b gy nj nk l nl nm">class CarplayContentItem: MPContentItem {<br/>    var subItems: [CarplayContentItem] = []<br/>    var handler: (@escaping (Error?) -&gt; Void)-&gt;() = { _ in }<br/>}</span></pre><p id="c40b" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">由于这段代码，它使得实现有点类似。只是工作不太顺利。我有很多性能问题，我不得不到处改进，这让我为少数用户浪费了很多时间。有点令人沮丧，但最终，我们所有的用户都被覆盖了，所以这是值得的(我还是会尽快把这段代码扔到最近的垃圾桶里)。</p><h1 id="cc06" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">结论</h1><p id="fef1" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">开发这个特性对大多数人来说绝对是一件有趣的事情。这也是令人难以置信的回报，甚至在一些新闻文章中被提及(像<a class="ae kv" href="https://www.whathifi.com/us/news/qobuz-unveils-new-personalised-playlists-and-carplay-online-features" rel="noopener ugc nofollow" target="_blank">这个</a>)，所以我肯定会接受。我在美国自驾游的时候也能使用它(我在法国没有车)，这也增加了一些满足感:)。</p><p id="0b2c" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我希望你会发现这篇文章的某些部分对你的CarPlay音频应用程序(或任何其他种类的CarPlay应用程序)的开发有用。</p><p id="029d" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">你可以在这里查看苹果<a class="ae kv" href="https://developer.apple.com/carplay/documentation/CarPlay-App-Programming-Guide.pdf" rel="noopener ugc nofollow" target="_blank">的开发指南</a>。这对我很有帮助，尤其是在设置基础的时候。</p><p id="9613" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">祝大家编码愉快，安全驾驶！</p></div></div>    
</body>
</html>