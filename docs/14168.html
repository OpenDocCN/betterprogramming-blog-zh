<html>
<head>
<title>Resolving the AttributeError on AWS Lambda</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">解决AWS Lambda上的AttributeError</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/attributeerror-on-aws-lambda-dca8a62dcca6?source=collection_archive---------5-----------------------#2022-11-13">https://betterprogramming.pub/attributeerror-on-aws-lambda-dca8a62dcca6?source=collection_archive---------5-----------------------#2022-11-13</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="e49c" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">无缝迁移到云</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/c575ed66dca3335a27be89e562671ae8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*PmzjgMVZfUeHAYj50IdSfA.jpeg"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">客户端对象—属性不存在</p></figure><p id="0da4" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">你是否曾经在本地处理过一个脚本，并且发现当它迁移到AWS Lambda时，你得到的结果与预期的不同？在下面的博文中，我将介绍一个例子，Boto3客户端API可以在本地工作，但不能在AWS Lambda上工作，具体来说，我将介绍如何调试客户端对象AttributeError。</p><h1 id="237c" class="lr ls iq bd lt lu lv lw lx ly lz ma mb jw mc jx md jz me ka mf kc mg kd mh mi bi translated">先决条件</h1><ul class=""><li id="446f" class="mj mk iq kx b ky ml lb mm le mn li mo lm mp lq mq mr ms mt bi translated">AWS帐户</li><li id="4025" class="mj mk iq kx b ky mu lb mv le mw li mx lm my lq mq mr ms mt bi translated">Python3/Pip</li><li id="5f2e" class="mj mk iq kx b ky mu lb mv le mw li mx lm my lq mq mr ms mt bi translated">Boto3</li></ul><h1 id="46e6" class="lr ls iq bd lt lu lv lw lx ly lz ma mb jw mc jx md jz me ka mf kc mg kd mh mi bi translated"><strong class="ak">代码演练</strong></h1><p id="8269" class="pw-post-body-paragraph kv kw iq kx b ky ml jr la lb mm ju ld le mz lg lh li na lk ll lm nb lo lp lq ij bi translated">在本演练中，我将对Amazon Connect实例进行API调用。错误本身并不特定于这个AWS资源。如果您想了解Amazon Connect实例，那么它所需要的只是几个用户(在我的例子中，我创建了两个)和实例本身的创建。</p><pre class="kg kh ki kj gt nc nd ne bn nf ng bi"><span id="5e10" class="nh ls iq nd b be ni nj l nk nl">#example.py - vscode local script<br/><br/>import boto3<br/><br/>#initialize env var<br/>connect_instance_id = "c1febbea-7409-4221-b374-333def95aacc"<br/><br/>#initialize client<br/>connect = boto3.client("connect")<br/><br/>def filter_users_by_value(value_to_filter, comparison_type):<br/> response = connect.search_users(<br/>  InstanceId=connect_instance_id,<br/>  SearchCriteria={<br/>   "StringCondition": {"FieldName": "Username","Value": value_to_filter,"ComparisonType": comparison_type}<br/>  }<br/>  )["Users"]<br/><br/> usernames_arr = list(map(lambda x: x["Username"], response))<br/> return usernames_arr</span></pre><p id="9742" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">在上面的代码片段中，我们导入了boto3库，并初始化了一个connect客户端对象来访问Amazon Connect的资源。我将在这个演示中使用的API是connect中的<code class="fe nm nn no nd b">list_users</code>和<code class="fe nm nn no nd b">search_users</code>。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi np"><img src="../Images/cc6e8659cd30eafd74d08375d3344f11.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*KEG0rukKU7SZ8_Go83MW1A.jpeg"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">connect client list _ users()API boto 3文档</p></figure><pre class="kg kh ki kj gt nc nd ne bn nf ng bi"><span id="f7f8" class="nh ls iq nd b be ni nj l nk nl">def get_all_users():<br/> try:<br/>  response = connect.list_users(<br/>   InstanceId=connect_instance_id,<br/>   MaxResults=100<br/>  )["UserSummaryList"]<br/><br/>  all_usernames_arr = list(map(lambda x: x["Username"], response))<br/>  return all_usernames_arr<br/> except Exception as err:<br/>  print(err)<br/>  exit(1)</span></pre><p id="7e22" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">上面定义的函数将使用<code class="fe nm nn no nd b">list_users()</code> API检索多达100个用户的列表，并过滤响应以返回该列表中每个用户的用户名列表。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nq"><img src="../Images/7f8cc0f3dcde68043dad8adeb2ad3c4e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*YkAI-LBzANsqBkgO6L5G1g.jpeg"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">连接客户端search_users() api boto3文档</p></figure><pre class="kg kh ki kj gt nc nd ne bn nf ng bi"><span id="6503" class="nh ls iq nd b be ni nj l nk nl">def filter_users_by_value(value_to_filter, comparison_type):<br/> try:<br/>  response = connect.search_users(<br/>   InstanceId=connect_instance_id,<br/>   SearchCriteria={<br/>    "StringCondition": {"FieldName": "Username","Value": value_to_filter,"ComparisonType": comparison_type}<br/>   }<br/>   )["Users"]<br/><br/>  usernames_arr = list(map(lambda x: x["Username"], response))<br/>  return usernames_arr<br/> except Exception as err:<br/>  print(err)<br/>  exit(1)</span></pre><p id="1754" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated"><code class="fe nm nn no nd b">filter_users_by_value</code>函数将使用<code class="fe nm nn no nd b">search_users()</code> api检索满足应用于搜索的过滤条件的用户列表。然后，我们使用该映射过滤该响应，以返回从API调用返回的每个用户的用户名列表。</p><pre class="kg kh ki kj gt nc nd ne bn nf ng bi"><span id="c869" class="nh ls iq nd b be ni nj l nk nl">def main():<br/> all_users = get_all_users()<br/> print(f"all users: {all_users}")<br/> print("")<br/><br/> filtered_value, filter_condition = "G", "STARTS_WITH"<br/> filtered_usernames_arr = filter_users_by_value(filtered_value, filter_condition)<br/> print(f"Usernames that {filter_condition} {filtered_value}: {filtered_usernames_arr}")<br/> print("")<br/><br/> filtered_value = "H"<br/> filtered_usernames_arr = filter_users_by_value(filtered_value, filter_condition)<br/> print(f"Usernames that {filter_condition} {filtered_value}: {filtered_usernames_arr}")<br/><br/><br/>if __name__ == "__main__":<br/> main()</span></pre><p id="5bc7" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">主程序将首先执行<code class="fe nm nn no nd b">list_users()</code> API，然后针对两种不同的过滤条件分别执行<code class="fe nm nn no nd b">search_users()</code> API。这段代码是同步运行的。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nr"><img src="../Images/58a03c90e9f43f628fdb340666c0172d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*RzcQ5lsaV2yYsqdEr99fRw.jpeg"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">vscode脚本执行</p></figure><p id="b2bc" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">我们看到在这个例子中总共有2个用户，我们成功地获得了所有以G开头的用户和以h开头的用户。</p><h1 id="2032" class="lr ls iq bd lt lu lv lw lx ly lz ma mb jw mc jx md jz me ka mf kc mg kd mh mi bi translated">AWS Lambda代码演练</h1><p id="feea" class="pw-post-body-paragraph kv kw iq kx b ky ml jr la lb mm ju ld le mz lg lh li na lk ll lm nb lo lp lq ij bi translated">在本地运行这段代码时，我们看到三次执行都成功返回了预期的结果，太棒了！现在将这段代码导入AWS Lambda。(这里我用python3.9运行时、arm64架构、128 MB内存和基本lambda执行创建了一个通用Lambda)。</p><pre class="kg kh ki kj gt nc nd ne bn nf ng bi"><span id="3896" class="nh ls iq nd b be ni nj l nk nl">import os<br/><br/>import boto3<br/><br/>#initialize env var<br/>connect_instance_id = os.environ["connect_instance_id"]<br/><br/>#initialize client<br/>connect = boto3.client("connect")<br/><br/>def get_all_users():<br/> try:<br/>  response = connect.list_users(<br/>   InstanceId=connect_instance_id,<br/>   MaxResults=100<br/>  )["UserSummaryList"]<br/><br/>  all_usernames_arr = list(map(lambda x: x["Username"], response))<br/>  return all_usernames_arr<br/> except Exception as err:<br/>  print(err)<br/>  exit(1)<br/><br/>def filter_users_by_value(value_to_filter, comparison_type):<br/> try:<br/>  response = connect.search_users(<br/>   InstanceId=connect_instance_id,<br/>   SearchCriteria={<br/>    "StringCondition": {"FieldName": "Username","Value": value_to_filter,"ComparisonType": comparison_type}<br/>   }<br/>   )["Users"]<br/><br/>  usernames_arr = list(map(lambda x: x["Username"], response))<br/>  return usernames_arr<br/> except Exception as err:<br/>  print(err)<br/>  exit(1)<br/><br/><br/>def lambda_handler(event, _):<br/> all_users = get_all_users()<br/> print(f"all users: {all_users}")<br/> print("")<br/><br/> filtered_value, filter_condition = "G", "STARTS_WITH"<br/> filtered_usernames_arr = filter_users_by_value(filtered_value, filter_condition)<br/> print(f"Usernames that {filter_condition} {filtered_value}: {filtered_usernames_arr}")<br/> print("")<br/><br/> filtered_value = "H"<br/> filtered_usernames_arr = filter_users_by_value(filtered_value, filter_condition)<br/> print(f"Usernames that {filter_condition} {filtered_value}: {filtered_usernames_arr}")</span></pre><p id="528f" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">与本地脚本的不同之处在于<code class="fe nm nn no nd b">main()</code>已被重命名为<code class="fe nm nn no nd b">lambda_handler()</code>，并且末尾的if-check已被移除(因为这是一个单文件脚本)。我还将connect_instance_id移动到环境变量中，并使用<code class="fe nm nn no nd b">os.environ</code>来访问它的值。其他一切都保持不变。</p><h1 id="3842" class="lr ls iq bd lt lu lv lw lx ly lz ma mb jw mc jx md jz me ka mf kc mg kd mh mi bi translated">AWS Lambda权限</h1><p id="75c2" class="pw-post-body-paragraph kv kw iq kx b ky ml jr la lb mm ju ld le mz lg lh li na lk ll lm nb lo lp lq ij bi translated">为了让lambda服务正确地执行上述代码，我们需要确保我们为lambda执行角色(或附属于该Lambda的IAM角色)提供了正确的权限。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi ns"><img src="../Images/a8cfc38388d9d50806fa37227047a62b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*9ctKeS3GgMbHngV9qYBErg.jpeg"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">λ权限</p></figure><p id="78fd" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">为了找到附加到lambda的角色，在Lambda控制台上，单击所选功能的Configuration选项卡并导航到Permissions。然后点击角色名称。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nt"><img src="../Images/6f365b70a341fa966b6ec44341269580.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*704l70Coomqew9UVYaMTGg.jpeg"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">IAM角色权限策略</p></figure><p id="0478" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">这将导航到IAM中的角色。在权限策略下，我们现在可以添加一个新的权限策略，或者通过单击链接并点击<em class="nu"> edit </em>来编辑现有的权限策略。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nv"><img src="../Images/7f176c2fdd43e44a425518770ad9dca6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*n2JlhW1onfbG4Lj20xmT3w.jpeg"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">连接服务权限</p></figure><p id="3a3d" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">我们需要提供的权限如上所示。它们对应于</p><ul class=""><li id="a64a" class="mj mk iq kx b ky kz lb lc le nw li nx lm ny lq mq mr ms mt bi translated"><code class="fe nm nn no nd b">connect:ListUsers</code></li><li id="542b" class="mj mk iq kx b ky mu lb mv le mw li mx lm my lq mq mr ms mt bi translated"><code class="fe nm nn no nd b">connect:DescribeUser</code></li><li id="7b89" class="mj mk iq kx b ky mu lb mv le mw li mx lm my lq mq mr ms mt bi translated"><code class="fe nm nn no nd b">connect:SearchUsers</code></li></ul><p id="c314" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">如果愿意，我们可以将资源限制为仅指向这一个特定的实例，但是出于演示的目的，我将它设置为所有资源。</p><h1 id="ec1e" class="lr ls iq bd lt lu lv lw lx ly lz ma mb jw mc jx md jz me ka mf kc mg kd mh mi bi translated">Boto3属性错误</h1><p id="4f43" class="pw-post-body-paragraph kv kw iq kx b ky ml jr la lb mm ju ld le mz lg lh li na lk ll lm nb lo lp lq ij bi translated">现在，当执行这个脚本时，我们会看到不同的结果。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nz"><img src="../Images/6064fc1cd3136c23300d3bc19a7c06b6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*L5pNZVgGSTyy5Ci4esnksQ.jpeg"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">属性错误</p></figure><p id="6f7b" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">如函数日志所示，<code class="fe nm nn no nd b">list_users()</code> API已经成功执行，并获得了我们期望的结果。尽管<code class="fe nm nn no nd b">search_users</code> API返回了一个有点模糊的<code class="fe nm nn no nd b">AttributeError</code> …当我们在boto3文档中清楚地看到它时，我们的connect client对象怎么会没有search_users属性呢？</p><p id="83c1" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">需要注意的一点是，文档页面将指向该库的最新版本，或者有时只是落后几个补丁版本(因此，尽管版本1.26.8可以下载，但文档可能暂时仍指向1.26.78)。</p><p id="84ec" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">文档的当前版本明确显示在页面的左上角。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/6e23f2a9d91708777e70898f1a66dd1b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*sRYImiEYS-MEjJ9y5F-TQw.jpeg"/></div></div></figure><p id="5ef5" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">在撰写本文时，boto3文档指向版本1.26.8。</p><p id="f0c1" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">现在让我们看看我们的本地环境指向什么版本的boto3。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi oa"><img src="../Images/3dd33bddfe515a3c538550bdb66d86e4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Ce2zKzMAqY4jgC0gnaQyMQ.jpeg"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">vscode: boto3 ==版本1.25.2</p></figure><p id="2b60" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">运行pip freeze命令，我们可以看到boto3指向我的本地机器上的版本1.25.2。</p><p id="c06b" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">虽然我的本地boto3包没有指向当前可用的boto3库的最新版本，但它仍然指向一个可以访问脚本中使用的特性/API的版本。</p><p id="5e67" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated"><strong class="kx ir">注意:</strong>要在本地升级boto3，请运行以下命令</p><pre class="kg kh ki kj gt nc nd ne bn nf ng bi"><span id="62b3" class="nh ls iq nd b be ni nj l nk nl">pip install boto3 --upgrade</span></pre><p id="4aa8" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">这将使boto3指向最新版本，在本例中是1.26.8</p><p id="1982" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">现在来看看boto3 AWS Lambda指向什么版本。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi ob"><img src="../Images/53a0951a429ea5f9618cb9b717ac36df.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*J135QjK8N45M4dw7khIxtg.jpeg"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">Lambda运行时(AWS文档):<a class="ae oc" href="https://docs.aws.amazon.com/lambda/latest/dg/lambda-runtimes.html" rel="noopener ugc nofollow" target="_blank">https://docs . AWS . Amazon . com/lambda/latest/DG/lambda-Runtimes . html</a></p></figure><p id="20d6" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">参考AWS文档，我们看到对于所有三个可用的python运行时，SDK、boto3指向版本1.20.32！与我们的1.25.xx和当前版本1.26.xx相比，这是一个很大的差异，因为从1.20.xx到1.26.xx的变化表明发生了6个较小的版本变化。这意味着从boto3版本1.20.xx开始，公共API功能已经被废弃、添加或改进</p><p id="6b1f" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">确认boto3在lambda上指向1.20.32版本的一种方法是在boto3库上使用version dunder方法并打印它。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi od"><img src="../Images/21355295dc8484818342ea3d205c902f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*GAJ6EWVGOb60D_yt2FvGBA.jpeg"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">第5行—调用boto3导入的dunder version方法</p></figure><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi oe"><img src="../Images/82b1e5692252097d7ea79cd9123b9bed.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*1YQxW5ZSNQVW1zeI8Dks0w.jpeg"/></div></div></figure><p id="f867" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">“Function Logs”下面的第一个日志对应于我们的第一个print语句，它在第5行，因此<code class="fe nm nn no nd b">print(boto3.__version__)</code>输出1.20.32，并确认了我们在文档中已经看到的内容。</p><p id="a69d" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">因此，boto3库的新版本必须考虑这个属性错误。由于boto3的1.20.32版本(AWS Lambda当前支持的版本)中不存在<code class="fe nm nn no nd b">search_users</code>属性，为了更新boto3以指向最新版本，我们需要创建一个层。</p><h1 id="f6a1" class="lr ls iq bd lt lu lv lw lx ly lz ma mb jw mc jx md jz me ka mf kc mg kd mh mi bi translated">AWS层</h1><p id="63e6" class="pw-post-body-paragraph kv kw iq kx b ky ml jr la lb mm ju ld le mz lg lh li na lk ll lm nb lo lp lq ij bi translated">Lambda层是一个. zip文件，它遵循特定的文件结构，并提供了一种打包库和其他可用于Lambda函数的外部依赖项的方法。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi of"><img src="../Images/19e257a46145a57a4c60331da16895ba.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*W_lOJ23XztPLItFE1XB3hQ.jpeg"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">创建图层(Python)——<a class="ae oc" href="https://docs.aws.amazon.com/lambda/latest/dg/configuration-layers.html" rel="noopener ugc nofollow" target="_blank">https://docs . AWS . Amazon . com/lambda/latest/DG/configuration-Layers . html</a></p></figure><p id="6188" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">要为python创建一个图层，我们首先需要创建一个python目录。嵌套在里面的是我们想导入Lambda服务的包。这个python目录需要压缩，然后上传到AWS Lambda。</p><p id="3430" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">下面的代码展示了使用bash在当前目录中创建boto3层的执行步骤。</p><pre class="kg kh ki kj gt nc nd ne bn nf ng bi"><span id="2d85" class="nh ls iq nd b be ni nj l nk nl">#!/bin/bash<br/>mkdir python<br/>pip install boto3 -t ./python<br/>zip -r boto3-pkg.zip python</span></pre><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi og"><img src="../Images/11a78574dc7ebe0ff454e28c52774324.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*fB9UEjemkmXZIxF12FwfpQ.jpeg"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">创建boto3层</p></figure><p id="3ee7" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">要在AWS上添加层，首先转到AWS Lambda控制台。然后导航到侧面菜单的图层，点击<em class="nu">创建图层</em>。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi oh"><img src="../Images/4586741b62f04580ef2fdfb69c83feab.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Qa0DCdXHBgaSGqDAMf2QkQ.jpeg"/></div></div></figure><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi oi"><img src="../Images/341af17b956278cc5528041aec1e8579.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*YyZTzmxzk9s0ddg3R5HF2g.jpeg"/></div></div></figure><p id="f4c7" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated"><strong class="kx ir">注意:</strong>对于大于10 MB的zip文件，AWS建议首先将zip文件上传到S3桶，然后使用<em class="nu">从亚马逊S3 </em>上传文件，并向该压缩的S3对象提供S3 URI，以便创建层。</p><p id="373d" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">该层实际上最终为我创建了手动上传，尽管大于10 MB。为了完整起见，一旦S3 URI上传到S3桶，我将显示在哪里可以得到它。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi oj"><img src="../Images/59ce5510507288db33547cdac665aa0b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*LkbyilRJLJS2j1lOlYHYZQ.jpeg"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">点击S3上的对象可以找到S3 Uri—S3://<bucket-name>/<zip-file-name/></bucket-name></p></figure><p id="7ae3" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">现在我们的层已经创建好了，是时候把它添加到我们的Lambda中了。</p><p id="ea95" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">回到Lambda控制台，在functions下，选择感兴趣的函数后，向下滚动并点击<em class="nu"> Add a layer </em>。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi ok"><img src="../Images/8a54a7cd1adfa019465157e8b7752039.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*6I8eUYBZ2wnjD5WFLMdVuw.jpeg"/></div></div></figure><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi ol"><img src="../Images/d024b2ec28c990ec7a313cc2692397aa.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*r7tsTn5N4Jt_6ycLKKQg9A.jpeg"/></div></div></figure><p id="9cca" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">现在选择<em class="nu">自定义图层</em>，会出现两个下拉菜单。首先，选择给boto3层的zip文件的名称。其次，如果这是第一次创建这个层，它将自动填充下拉列表中的版本1。否则，选择最新版本将指向对该层所做的最新更改。剩下的就是点击<em class="nu">添加</em></p><p id="cb3a" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">现在这个层已经关联到这个lambda，当Lambda启动容器加载库并运行代码时，层中提供的库将优先于AWS Lambda的内置库。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi om"><img src="../Images/906f22fb335f3107a1e7ddb61a8edd76.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*eZnIH36RBJToTQKiE83Kng.jpeg"/></div></div></figure><p id="ed2d" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">再次执行lambda，我们看到boto3现在指向最新版本(在编写本文时对应于版本1.26.8)！此外，我们的<code class="fe nm nn no nd b">AttributeError</code>已经解决，我们的结果现在也与我们在当地环境中看到的结果相匹配。</p><h1 id="5287" class="lr ls iq bd lt lu lv lw lx ly lz ma mb jw mc jx md jz me ka mf kc mg kd mh mi bi translated">外卖食品</h1><p id="4cf0" class="pw-post-body-paragraph kv kw iq kx b ky ml jr la lb mm ju ld le mz lg lh li na lk ll lm nb lo lp lq ij bi translated">重要的是要确保在本地开发和迁移到云中时，所使用的依赖项在两个环境中都指向相同的版本。</p><p id="9c3d" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">感谢您的阅读！</p><p id="5cd3" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">也可以随时在LinkedIn 上与我联系！</p><h1 id="9538" class="lr ls iq bd lt lu lv lw lx ly lz ma mb jw mc jx md jz me ka mf kc mg kd mh mi bi translated">资源</h1><ul class=""><li id="e88f" class="mj mk iq kx b ky ml lb mm le mn li mo lm mp lq mq mr ms mt bi translated"><a class="ae oc" href="https://docs.aws.amazon.com/lambda/latest/dg/lambda-runtimes.html" rel="noopener ugc nofollow" target="_blank">https://docs . AWS . Amazon . com/lambda/latest/DG/lambda-runtimes . html</a></li><li id="3600" class="mj mk iq kx b ky mu lb mv le mw li mx lm my lq mq mr ms mt bi translated"><a class="ae oc" href="https://boto3.amazonaws.com/v1/documentation/api/latest/index.html" rel="noopener ugc nofollow" target="_blank">https://boto 3 . Amazon AWS . com/v1/documentation/API/latest/index . html</a></li></ul></div></div>    
</body>
</html>