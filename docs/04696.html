<html>
<head>
<title>Mastering Software Engineering in iOS: Liskov Substitution Principle</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">掌握iOS中的软件工程:利斯科夫替代原理</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/mastering-software-engineering-in-ios-liskov-substitution-principle-f98d6e1e6b19?source=collection_archive---------7-----------------------#2020-04-30">https://betterprogramming.pub/mastering-software-engineering-in-ios-liskov-substitution-principle-f98d6e1e6b19?source=collection_archive---------7-----------------------#2020-04-30</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="60ea" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">LSP:软件开发基础简单易懂</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/f3a7a1dc1db42c217cdf6aabf7517e2b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*bm5eZKv8RkfcuxUZ"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">丹尼尔·科尔派在<a class="ae kv" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的照片</p></figure><h1 id="0be8" class="kw kx iq bd ky kz la lb lc ld le lf lg jw lh jx li jz lj ka lk kc ll kd lm ln bi translated">固体</h1><p id="c09e" class="pw-post-body-paragraph lo lp iq lq b lr ls jr lt lu lv ju lw lx ly lz ma mb mc md me mf mg mh mi mj ij bi translated">让我们继续第三个<em class="mk">坚实的</em>原理，称为利斯科夫替代原理或简称<em class="mk"> LSP </em>。<a class="ae kv" href="https://medium.com/flawless-app-stories/from-hobbyist-to-professional-ios-developer-open-close-principle-5f28d2f09f8c" rel="noopener">和之前的文章</a>一样，我将坚持同样的惯例:</p><ul class=""><li id="fcc9" class="ml mm iq lq b lr mn lu mo lx mp mb mq mf mr mj ms mt mu mv bi translated">我给个简单的定义</li><li id="0ca5" class="ml mm iq lq b lr mw lu mx lx my mb mz mf na mj ms mt mu mv bi translated">我将给出一个糟糕代码的例子，它在某种程度上违背了我们讨论的原则</li><li id="2d82" class="ml mm iq lq b lr mw lu mx lx my mb mz mf na mj ms mt mu mv bi translated">我将解释为什么这个原则在给定的例子中被打破了</li><li id="8fb1" class="ml mm iq lq b lr mw lu mx lx my mb mz mf na mj ms mt mu mv bi translated">我将重构代码，因此该示例符合所讨论的原则</li><li id="2997" class="ml mm iq lq b lr mw lu mx lx my mb mz mf na mj ms mt mu mv bi translated">我将解释为什么现在它符合它</li></ul><p id="3fbd" class="pw-post-body-paragraph lo lp iq lq b lr mn jr lt lu mo ju lw lx nb lz ma mb nc md me mf nd mh mi mj ij bi translated">这次我们甚至将编写一些简单的单元测试来检查我们的代码是否符合LSP。如果你从未写过它们，不要担心，我会指导你完成整个过程。</p><h1 id="0b83" class="kw kx iq bd ky kz la lb lc ld le lf lg jw lh jx li jz lj ka lk kc ll kd lm ln bi translated">利斯科夫替代原理</h1><blockquote class="ne nf ng"><p id="019f" class="lo lp mk lq b lr mn jr lt lu mo ju lw nh nb lz ma ni nc md me nj nd mh mi mj ij bi translated">“设ϕ(x)是关于t类型的对象x的一个可证明的性质。那么ϕ(y)对于s类型的对象y应该是真的，其中s是t的子类型。”</p><p id="c05d" class="lo lp mk lq b lr mn jr lt lu mo ju lw nh nb lz ma ni nc md me nj nd mh mi mj ij bi translated"><em class="iq"> -芭芭拉·利斯科夫</em></p></blockquote><p id="de65" class="pw-post-body-paragraph lo lp iq lq b lr mn jr lt lu mo ju lw lx nb lz ma mb nc md me mf nd mh mi mj ij bi translated">等等，什么？虽然这听起来很复杂，但实际上非常简单。罗伯特·马丁的释义(为了清晰起见，放弃了正式语言)击中了靶心。</p><blockquote class="ne nf ng"><p id="e167" class="lo lp mk lq b lr mn jr lt lu mo ju lw nh nb lz ma ni nc md me nj nd mh mi mj ij bi translated">派生类必须可以替换它们的基类。</p><p id="13a6" class="lo lp mk lq b lr mn jr lt lu mo ju lw nh nb lz ma ni nc md me nj nd mh mi mj ij bi translated"><em class="iq">——罗伯特·马丁</em></p></blockquote><p id="c0bd" class="pw-post-body-paragraph lo lp iq lq b lr mn jr lt lu mo ju lw lx nb lz ma mb nc md me mf nd mh mi mj ij bi translated">这个原则的意思是，子类应该总是有可能像基类一样被使用(或多或少有相同的效果)。</p><p id="9ecd" class="pw-post-body-paragraph lo lp iq lq b lr mn jr lt lu mo ju lw lx nb lz ma mb nc md me mf nd mh mi mj ij bi translated">最简单的例子是<code class="fe nk nl nm nn b">Animal</code>基类的<code class="fe nk nl nm nn b">Dog</code>子类，以及一个允许你抚摸任何动物的函数(<code class="fe nk nl nm nn b">pet(animal: Animal)</code>)。你应该总是能够在<code class="fe nk nl nm nn b">Animal</code>级和<code class="fe nk nl nm nn b">Dog</code>级上使用这个功能。有了继承和多态，它会自动正确地工作。你可以说这是面向对象编程101。</p><p id="63ea" class="pw-post-body-paragraph lo lp iq lq b lr mn jr lt lu mo ju lw lx nb lz ma mb nc md me mf nd mh mi mj ij bi translated">那么，你为什么还要关心所有现代编程语言默认遵循的原则呢？</p><p id="b072" class="pw-post-body-paragraph lo lp iq lq b lr mn jr lt lu mo ju lw lx nb lz ma mb nc md me mf nd mh mi mj ij bi translated">事情是这样的:你可能会改变子类的内部逻辑，以至于它不再是基类的替代品。它将在代码级别上编译和工作，但它将提供糟糕和意外的结果，这实际上比简单的编译错误要糟糕得多。</p><p id="1753" class="pw-post-body-paragraph lo lp iq lq b lr mn jr lt lu mo ju lw lx nb lz ma mb nc md me mf nd mh mi mj ij bi translated">为了说明这一点，我们将使用两个最流行的例子和一个来自我们自己的<code class="fe nk nl nm nn b">UIKit</code>后院的例子。</p><h1 id="8e6a" class="kw kx iq bd ky kz la lb lc ld le lf lg jw lh jx li jz lj ka lk kc ll kd lm ln bi translated">示例1:过度使用的鸭子示例</h1><p id="29d1" class="pw-post-body-paragraph lo lp iq lq b lr ls jr lt lu lv ju lw lx ly lz ma mb mc md me mf mg mh mi mj ij bi translated">这是迄今为止对该问题最常见的解释。让我们制作一个<code class="fe nk nl nm nn b">Bird</code>基类和一些子类:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="no np l"/></div></figure><p id="e49d" class="pw-post-body-paragraph lo lp iq lq b lr mn jr lt lu mo ju lw lx nb lz ma mb nc md me mf nd mh mi mj ij bi translated">现在让我们试试我们的鸟会有什么表现:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="no np l"/></div></figure><p id="9cdd" class="pw-post-body-paragraph lo lp iq lq b lr mn jr lt lu mo ju lw lx nb lz ma mb nc md me mf nd mh mi mj ij bi translated"><code class="fe nk nl nm nn b">EmperorPenguin</code>断了<em class="mk"> LSP </em>作为派生类(<code class="fe nk nl nm nn b">EmperorPenguin</code>)一定是可以替它们的基类(<code class="fe nk nl nm nn b">Bird</code>)的，然而却不是。</p><p id="14f9" class="pw-post-body-paragraph lo lp iq lq b lr mn jr lt lu mo ju lw lx nb lz ma mb nc md me mf nd mh mi mj ij bi translated">不能将<code class="fe nk nl nm nn b">fly(birds:allBirds, to:)</code>与<code class="fe nk nl nm nn b">EmperorPenguin</code>类一起使用。代码编译并运行，但是它并没有做它承诺要做的事情。这就是为什么我们的健全检查<code class="fe nk nl nm nn b">assert</code>在运行时使应用程序崩溃。</p><p id="6d34" class="pw-post-body-paragraph lo lp iq lq b lr mn jr lt lu mo ju lw lx nb lz ma mb nc md me mf nd mh mi mj ij bi translated">我们犯的主要错误是假设每只鸟都会飞。这根本不是对现实世界的正确描述。我们需要记住，基类应该只有每个子类共享的行为(方法),并且能够正确使用。</p><p id="705e" class="pw-post-body-paragraph lo lp iq lq b lr mn jr lt lu mo ju lw lx nb lz ma mb nc md me mf nd mh mi mj ij bi translated">在Swift中，我们可以通过使用面向协议的编程来修复这个错误:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="no np l"/></div></figure><p id="fede" class="pw-post-body-paragraph lo lp iq lq b lr mn jr lt lu mo ju lw lx nb lz ma mb nc md me mf nd mh mi mj ij bi translated">现在我们看到，如果我们试图让一些鸟飞起来，编译器会立即通知我们，而这些鸟根本不会这么做。</p><p id="73fa" class="pw-post-body-paragraph lo lp iq lq b lr mn jr lt lu mo ju lw lx nb lz ma mb nc md me mf nd mh mi mj ij bi translated">在这个实现中，<code class="fe nk nl nm nn b">Bird</code>基类并不承担在每个现有的<code class="fe nk nl nm nn b">bird</code>类型中不共享的行为。</p><p id="4447" class="pw-post-body-paragraph lo lp iq lq b lr mn jr lt lu mo ju lw lx nb lz ma mb nc md me mf nd mh mi mj ij bi translated">它简单地假设每只鸟都“在某个地方”(在我们简化的世界模型中，它们只能在两个地方)，并且它有一定数量的翅膀(默认分配2，因为每只没有灭绝的鸟显然都有一对翅膀)。</p><p id="0114" class="pw-post-body-paragraph lo lp iq lq b lr mn jr lt lu mo ju lw lx nb lz ma mb nc md me mf nd mh mi mj ij bi translated">如果一个对象既是一个<code class="fe nk nl nm nn b">Bird</code>又符合一个<code class="fe nk nl nm nn b">Flyable</code>协议，它会自动获得<code class="fe nk nl nm nn b">fly(to city:)</code>函数的默认实现。</p><p id="5227" class="pw-post-body-paragraph lo lp iq lq b lr mn jr lt lu mo ju lw lx nb lz ma mb nc md me mf nd mh mi mj ij bi translated">这样我们就拥有了两个世界的最佳之处:我们不必重复代码并分别为每个<code class="fe nk nl nm nn b">Bird</code>子类实现<code class="fe nk nl nm nn b">fly(to city:)</code>，而且我们不会破坏LSP。</p><h1 id="c218" class="kw kx iq bd ky kz la lb lc ld le lf lg jw lh jx li jz lj ka lk kc ll kd lm ln bi translated">例2:在编程中，正方形不是长方形</h1><p id="20b1" class="pw-post-body-paragraph lo lp iq lq b lr ls jr lt lu lv ju lw lx ly lz ma mb mc md me mf mg mh mi mj ij bi translated">这里我们将编写承诺的单元测试。</p><p id="debe" class="pw-post-body-paragraph lo lp iq lq b lr mn jr lt lu mo ju lw lx nb lz ma mb nc md me mf nd mh mi mj ij bi translated">打开<em class="mk"> Xcode </em>，创建一个<em class="mk">单视图应用</em>，确保选中<em class="mk">包含单元测试</em>复选框。让我们给这个项目命名为<code class="fe nk nl nm nn b">LearningLiskov</code>:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nq"><img src="../Images/02265c6ce77cf606dcec34f51d803140.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*jUiRgWeXMNeA2qd_CZI-dw.png"/></div></div></figure><p id="40a3" class="pw-post-body-paragraph lo lp iq lq b lr mn jr lt lu mo ju lw lx nb lz ma mb nc md me mf nd mh mi mj ij bi translated">一旦有了这些，创建一个名为<code class="fe nk nl nm nn b">SquareExample.swift</code>的新Swift文件，我们将使用它来创建我们的示例。在此实现rectangle类:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="no np l"/></div></figure><p id="696d" class="pw-post-body-paragraph lo lp iq lq b lr mn jr lt lu mo ju lw lx nb lz ma mb nc md me mf nd mh mi mj ij bi translated">现在要为那个类创建单元测试，打开<code class="fe nk nl nm nn b">LearningLiskovTests.swift</code>并用下面的代码替换它的内容:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="no np l"/></div></figure><p id="84a0" class="pw-post-body-paragraph lo lp iq lq b lr mn jr lt lu mo ju lw lx nb lz ma mb nc md me mf nd mh mi mj ij bi translated">现在按下<code class="fe nk nl nm nn b">⌘+U</code>或选择<code class="fe nk nl nm nn b"><em class="mk">Product ➡ Test</em></code>，过一会儿你会看到:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi nr"><img src="../Images/e17de3d82c2a72911e91af6fae7b046a.png" data-original-src="https://miro.medium.com/v2/resize:fit:760/format:webp/1*CoL8a19yRsEA7ao7xXOYrA.png"/></div></figure><p id="d91a" class="pw-post-body-paragraph lo lp iq lq b lr mn jr lt lu mo ju lw lx nb lz ma mb nc md me mf nd mh mi mj ij bi translated">我们的简单测试已经成功通过。</p><p id="ad5e" class="pw-post-body-paragraph lo lp iq lq b lr mn jr lt lu mo ju lw lx nb lz ma mb nc md me mf nd mh mi mj ij bi translated">让我们回到<code class="fe nk nl nm nn b">SquareExample.swift</code>并创建一个<code class="fe nk nl nm nn b">Square</code>，它将从<code class="fe nk nl nm nn b">Rectangle</code>继承而来(因为根据数学，正方形是矩形的一个子类型)。</p><p id="d0e9" class="pw-post-body-paragraph lo lp iq lq b lr mn jr lt lu mo ju lw lx nb lz ma mb nc md me mf nd mh mi mj ij bi translated">我们首先会看到的是<code class="fe nk nl nm nn b">Square</code>没有同时拥有<code class="fe nk nl nm nn b">x</code>和<code class="fe nk nl nm nn b">y</code>。它只有<code class="fe nk nl nm nn b">x</code>。但是我们继承了拥有<code class="fe nk nl nm nn b">y</code>的类！为了处理这个问题，我们需要编写如下代码:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="no np l"/></div></figure><p id="ca88" class="pw-post-body-paragraph lo lp iq lq b lr mn jr lt lu mo ju lw lx nb lz ma mb nc md me mf nd mh mi mj ij bi translated">这样，无论何时任何人改变<code class="fe nk nl nm nn b">Square</code>任何一边的长度，它都会改变所有其他边。</p><p id="59cb" class="pw-post-body-paragraph lo lp iq lq b lr mn jr lt lu mo ju lw lx nb lz ma mb nc md me mf nd mh mi mj ij bi translated">让我提醒你，根据<em class="mk"> LSP </em>“派生类必须可替换它们的基类”，所以<code class="fe nk nl nm nn b">provideTestObject()</code>应该能够提供任何<code class="fe nk nl nm nn b">Rectangle</code>或它的子类型，测试应该通过！</p><p id="00bf" class="pw-post-body-paragraph lo lp iq lq b lr mn jr lt lu mo ju lw lx nb lz ma mb nc md me mf nd mh mi mj ij bi translated">所以只需将<code class="fe nk nl nm nn b">provideTestObject()</code>改为<code class="fe nk nl nm nn b">return Square()</code>并进行测试<code class="fe nk nl nm nn b">(⌘+U)</code>。</p><p id="d2f9" class="pw-post-body-paragraph lo lp iq lq b lr mn jr lt lu mo ju lw lx nb lz ma mb nc md me mf nd mh mi mj ij bi translated">您将看到测试失败:</p><pre class="kg kh ki kj gt ns nn nt nu aw nv bi"><span id="9fa9" class="nw kx iq nn b gy nx ny l nz oa">XCTAssertEqual failed: ("100") is not equal to ("50")</span></pre><p id="2781" class="pw-post-body-paragraph lo lp iq lq b lr mn jr lt lu mo ju lw lx nb lz ma mb nc md me mf nd mh mi mj ij bi translated">事实证明，我们对<code class="fe nk nl nm nn b">Sqare</code>类的行为做了如此大的改变，它是不可替代的<code class="fe nk nl nm nn b">Rectangle</code>。它打破了利斯科夫替代原理。这里没有简单的解决方法。</p><h2 id="cb13" class="nw kx iq bd ky ob oc dn lc od oe dp lg lx of og li mb oh oi lk mf oj ok lm ol bi translated"><code class="fe nk nl nm nn b">Square</code>不应从<code class="fe nk nl nm nn b">Rectangle</code>继承</h2><p id="69c2" class="pw-post-body-paragraph lo lp iq lq b lr ls jr lt lu lv ju lw lx ly lz ma mb mc md me mf mg mh mi mj ij bi translated">面向对象编程中的继承意味着子类化的对象将获得基类的属性(类变量)和行为(函数和类似<code class="fe nk nl nm nn b">didSet</code>的东西)。</p><p id="8fe7" class="pw-post-body-paragraph lo lp iq lq b lr mn jr lt lu mo ju lw lx nb lz ma mb nc md me mf nd mh mi mj ij bi translated"><code class="fe nk nl nm nn b">Square</code>的行为(改变<code class="fe nk nl nm nn b">x</code>或<code class="fe nk nl nm nn b">y</code>会同时改变<code class="fe nk nl nm nn b">x</code>和<code class="fe nk nl nm nn b">y</code>)与<code class="fe nk nl nm nn b">Rectangle</code>的行为(改变<code class="fe nk nl nm nn b">x</code>或<code class="fe nk nl nm nn b">y</code>，只改变它们自己)直接矛盾，所以我们不能用一个代替另一个。</p><p id="1d1c" class="pw-post-body-paragraph lo lp iq lq b lr mn jr lt lu mo ju lw lx nb lz ma mb nc md me mf nd mh mi mj ij bi translated">在不违反利斯科夫替换原则的情况下，我们根本无法使用继承来模拟矩形和正方形。</p><p id="dfc1" class="pw-post-body-paragraph lo lp iq lq b lr mn jr lt lu mo ju lw lx nb lz ma mb nc md me mf nd mh mi mj ij bi translated">这就是这个例子如此不直观的关键所在:在面向对象编程中，当你说“X是Y”(如“正方形是一个矩形”)时，你指的是继承，它有一个非常严格的含义，在现实世界中并不总是相同。</p><p id="a64f" class="pw-post-body-paragraph lo lp iq lq b lr mn jr lt lu mo ju lw lx nb lz ma mb nc md me mf nd mh mi mj ij bi translated">对于这个例子，最好使用<code class="fe nk nl nm nn b">structs</code>并使<code class="fe nk nl nm nn b">x</code>和<code class="fe nk nl nm nn b">y</code>为常量值。结构没有继承，所以我们立即避免了LSP问题。我们会马上发现应该对两者进行单独的测试，并且两个结构有不同的构造函数(你只需要正方形的一边！).</p><h1 id="b84b" class="kw kx iq bd ky kz la lb lc ld le lf lg jw lh jx li jz lj ka lk kc ll kd lm ln bi translated">例3: <code class="fe nk nl nm nn b">UIKit</code>自己的“鸭子”</h1><p id="61f0" class="pw-post-body-paragraph lo lp iq lq b lr ls jr lt lu lv ju lw lx ly lz ma mb mc md me mf mg mh mi mj ij bi translated">i̵n̵̵<code class="fe nk nl nm nn b">U̵I̵K̵i̵t</code>̵̵f̵r̵a̵m̵e̵w̵o̵r̵k̵̵<code class="fe nk nl nm nn b">U̵I̵S̵t̵a̵c̵k̵V̵i̵e̵w̵</code>̵i̵s̵̵b̵r̵e̵a̵k̵i̵n̵g̵̵l̵s̵p̵̵b̵e̵c̵a̵u̵s̵e̵̵o̵f̵̵t̵h̵e̵<code class="fe nk nl nm nn b">̵b̵a̵c̵k̵g̵r̵o̵u̵n̵d̵C̵o̵l̵o̵r̵</code>̵p̵r̵o̵p̵e̵r̵t̵y̵.̵̵t̵h̵i̵s̵̵p̵r̵o̵p̵e̵r̵t̵y̵̵w̵o̵r̵k̵s̵̵f̵o̵r̵̵t̵h̵e̵̵b̵a̵s̵e̵̵c̵l̵a̵s̵s̵̵(̵̵<code class="fe nk nl nm nn b">U̵I̵V̵i̵e̵w̵</code>)̵̵a̵n̵d̵̵y̵e̵t̵̵d̵o̵e̵s̵n̵'̵t̵̵f̵o̵r̵̵t̵h̵e̵̵d̵e̵r̵i̵v̵e̵d̵̵c̵l̵a̵s̵s̵̵(̵̵<code class="fe nk nl nm nn b">U̵I̵S̵t̵a̵c̵k̵V̵i̵e̵w̵</code>)̵.̵̵<code class="fe nk nl nm nn b">U̵I̵S̵t̵a̵c̵k̵V̵i̵e̵w̵</code>̵s̵i̵m̵p̵l̵y̵̵i̵g̵n̵o̵r̵e̵s̵̵t̵h̵e̵̵b̵a̵c̵k̵g̵r̵o̵u̵n̵d̵̵c̵o̵l̵o̵r̵̵w̵h̵i̵c̵h̵̵i̵s̵̵i̵n̵̵c̵o̵n̵t̵r̵a̵d̵i̵c̵t̵i̵o̵n̵̵o̵f̵̵<a class="ae kv" href="https://developer.apple.com/documentation/uikit/uiview/1622591-backgroundcolor" rel="noopener ugc nofollow" target="_blank">a̵p̵p̵l̵e̵'̵s̵̵o̵w̵n̵̵d̵o̵c̵u̵m̵e̵n̵t̵a̵t̵i̵o̵n̵</a>法国</p><p id="b5fa" class="pw-post-body-paragraph lo lp iq lq b lr mn jr lt lu mo ju lw lx nb lz ma mb nc md me mf nd mh mi mj ij bi translated"><em class="mk">编辑:</em>他们已经修复了，所以我再举一个例子:<code class="fe nk nl nm nn b">UINavigationController</code>是从<code class="fe nk nl nm nn b">UIViewController</code>继承的，但是你不能在<code class="fe nk nl nm nn b">UINavigationController</code>实例上使用<code class="fe nk nl nm nn b">pushViewController(_:animated:)</code>函数。如果你尝试，这将会发生:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi om"><img src="../Images/b4cf73a106123e8a7175b7e9e1923c65.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*KliaxkGLcJ4tPERgM6M-HA.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">苹果打破了LSP</p></figure><h1 id="c808" class="kw kx iq bd ky kz la lb lc ld le lf lg jw lh jx li jz lj ka lk kc ll kd lm ln bi translated">总结</h1><p id="629e" class="pw-post-body-paragraph lo lp iq lq b lr ls jr lt lu lv ju lw lx ly lz ma mb mc md me mf mg mh mi mj ij bi translated">利斯科夫替代原理是最容易遵循的原理之一，然而，一旦被打破，它是最难修复的原理之一。</p><p id="c2b1" class="pw-post-body-paragraph lo lp iq lq b lr mn jr lt lu mo ju lw lx nb lz ma mb nc md me mf nd mh mi mj ij bi translated">当子类化时，特别是当大量使用<code class="fe nk nl nm nn b">override</code>(没有从<code class="fe nk nl nm nn b">super</code>调用相同的方法)时，如果你没有破坏这个特定子类的<em class="mk"> LSP </em>，请三思。如果你能记住这一点，你会没事的！</p></div></div>    
</body>
</html>