# OOP 与函数式编程——哪个更好？

> 原文：<https://betterprogramming.pub/oop-vs-functional-programming-which-is-better-4f0dd89b7987>

## 这个古老的问题终于有了答案。有点儿

![](img/12a15740c654b5e513cf939856779a67.png)

原照片由[静止在运动中](https://unsplash.com/@stillnes_in_motion?utm_source=unsplash&utm_medium=referral&utm_content=creditCopyText)在 [Unsplash](https://unsplash.com/s/photos/fight?utm_source=unsplash&utm_medium=referral&utm_content=creditCopyText) 上拍摄，作者编辑

PHP 和 Node.js 哪个好？或者这个:前端开发和后端开发哪个更容易？

作为开发人员，我们倾向于问这类问题，试图找到一个并不存在的答案。面向对象编程和函数式编程哪个更好？那就好比问能看见和能听见哪个更好。

让我简单快速地解开这个谜:它们同等重要，只有你才能根据你的特定背景和需求来决定哪一个更好。你的回答会适用于我或者我们行业的其他人吗？我几乎不怀疑这一点，所以坚持“它们都非常有用”，就是这样。

但是问题仍然存在:您选择哪一个，以及您如何知道哪一个更适合您的项目？

让我们了解一下每种范式，然后理解如何做出选择。

# 什么是 OOP 和 FP？

面向对象编程(OOP)和函数式编程(FP)都是编程范式。本质上，它们是编码的方式，决定了我们将拥有的工具类型，以及我们将如何构建代码的内部架构。

每种范式都有自己的一套约束。考虑到每一个的特点和你想要达到的目标，你最终会选择其中一个，因为它们更适合不同的活动。

但是无论您决定做什么，如果您想从本文中获得任何类型的知识，请理解以下几点:这些是决定您编写代码的方式的标准。他们不会限制你做任何事。您可以使用它们中的任何一种来编写任何类型的项目。

## 那么 OOP 是怎么回事呢？

面向对象编程是编写代码最常见的方式之一，出于某种原因，也是最著名的范例之一。当你开始在任何地方学习编码的时候，这一个通常被包括。

它的要点是，它试图通过代码中的抽象结构来表示真实世界。本质上，你试图解决的问题的任何“真实”都可以在 OOP 中表示为一个对象，也可以表示为关于它的任何抽象事物(这使得处理非物质概念变得容易)。

假设你正在开发一款格斗游戏。让我们想象一下我们会有什么样的物品:

“真实”对象:

*   每个玩家都有自己的目标
*   他们战斗的竞技场
*   每个战士的健康
*   测量比赛持续时间的计时器

但是也有一些“抽象”对象可以成为这个 OOP 宇宙的一部分:

*   很可能每一步都将被封装在不同的对象中
*   如果你在玩单人游戏，关卡本身
*   与你战斗并决定如何攻击你的人工智能

我可以继续在这里列出一些东西，但是重点是，你可以将简单和复杂的概念概念化为“对象”有什么好处呢？每个对象都将由一个状态和一些行为组成，并且都将被表示为同一个逻辑实体中的代码:一个类。

让我们来分解一下这个陈述:

*   对于*状态，*我指的是一组变量，这些变量将代表对象在任何给定时间点的行为。如果我们谈论的是玩家，那可能是它的坐标，剩余的生命值，等等。
*   所谓的*行为，*我指的是实际的代码“做”与之相关的事情，例如，通过修改玩家的坐标来移动玩家，或者通过在任何给定的时间显示不同的帧来动画化玩家。这些都是分组在一起的动作或行为，因为它们有逻辑意义。

作为范例的一部分，这些“类”充当同一类型对象的不同副本的蓝图。本质上，通过一次实例化一个对象，它们允许您拥有同一个对象的多个版本。想象一下我们现在的格斗游戏也是多人的。你愿意让我们谈论的代码为每个玩家复制几次吗？或者你更愿意写一次，然后为每个玩家单独行动？

第二个选项是正确的答案，OOP 允许你很容易地做到这一点。

现在，如果我们想更进一步，在 OOP 中，关于它的多种工具和特性允许更动态的行为，例如:

*   [多态](https://medium.com/@shanikae/polymorphism-explained-simply-7294c8deeef7)，它允许对象呈现不同的“形状”(即不同的方法集)。
*   [封装](https://www.sumologic.com/glossary/encapsulation/)，指的是每个对象内部如何拥有自己的状态和行为。
*   [继承](https://stackify.com/oop-concept-inheritance/)，它允许你从一种类型的对象到其他多种类型的对象共享状态和行为。它帮助您表示与对象的父子关系类型。

在我们的代码中将我们的实体表示为对象的另一个有趣的好处是，我们可以很容易地在一种称为[类图](https://en.wikipedia.org/wiki/Class_diagram)的图表类型上绘制它们如何相互关联，这通过 UML(或统一建模语言)允许我们捕获每个实体如何在我们的代码中与其他实体关联和使用它们。

还有很多关于 OOP 的内容我无法在这样的文章中介绍，但是如果你还在学习它，我建议你关注我在整个解释中留下的链接，因为它们会提供额外的细节。

如果你对学习一门严格遵循 OOP 原则的语言感兴趣，我会推荐你选择 JAVA、C#，或者 C++(如果你对底层的东西感兴趣的话)。

## 函数式编程呢？

另一方面，函数式编程(FP)只关注行为，换句话说:函数。

虽然 OOP 有类和方法的概念，以及处理这些结构的复杂方式，但函数式编程试图将所有这些简化为一个基本概念:函数。

FP 中的函数非常重要，你可能已经猜到了它的名字。事实上，如果你来自纯粹的 OOP 语言，你会惊讶地发现 FP 中的函数被视为一等公民，这意味着它们也可以作为值使用。

在 OOP 和其他范例中，您可以使用方法(即函数)来抽象一个可以调用的逻辑行为，而在 FP 中，您也可以将该行为作为一个值传递(即，就像我们在谈论一个字符串或一个数字)或作为另一个函数的执行结果返回它。这很疯狂，但如果你仔细想想，也会很有帮助。它允许你将函数组合在一起，这是使用 FP 的主要方式。

因为你真的不必担心 FP 的状态或实体，你担心的是行为并把它提炼成基本的动作，这些动作可以组成更复杂的动作。

与 OOP 相比，FP 的坏名声是因为 FP 是在学术界教授的，大多是在非常纯粹和严格的条件下。我这么说是什么意思？FP 从 Lambda calculus 诞生并发展而来，Lambda calculus 是数学逻辑中用于表达基于逻辑表达式的计算的形式系统。这听起来太理论化了，似乎对我们的日常工作没什么作用。然而，这并不是什么 FP，老实说，如果它是从一个更实际的角度来教授的话，会有更多的开发者知道它，他们会更经常地使用它。

就像 OOP 是表现涉及多个实体(无论它们是真实的还是抽象的)的场景的极好方法一样，当涉及到行为时，函数式编程是一个难以置信的范例。

想象一下，必须开发一个数据流解决方案，该方案需要捕获数据、清理数据、转换数据(例如，改变数据格式)，然后保存数据。这些都是您可以实现并表示为函数的转换，而不必担心实体、它们的关系、状态或行为。

```
function captureData(source) {
  //...capture data
  return data;
}function cleanUpData(rawData) {
  //...clean it up
  return cleanData;
}function translate(cleanData) { 
   //...apply transformations
  return newDataFormat;
}function saveData(data) {
   //...save the data
   return data;
}
```

这些都是简单的函数，接受一个输入，围绕它执行一些操作，然后返回其他内容。这里不需要类、对象、继承或任何其他额外的抽象。只是功能。现在请注意它们的签名是多么简单，而且，假设我们在这里讨论 FP，我们可以做类似于 [*组合*](https://en.wikipedia.org/wiki/Function_composition_(computer_science)) 它们的事情:

```
saveData(translate(cleanUpData(captureData(source))))
```

这看起来很像是在构造数学函数，不是吗？

```
F(G(Z(x)))
```

首先用`x`调用`Z`，然后结果值将被用作`G`的输入，这又将产生一个结果，该结果将被用作`F`的输入。我们的功能也是如此。从`captureData`开始，它返回稍后被`cleanUpData`使用的原始数据。返回的干净数据然后被`translate`用作输入，最终被`saveData`返回并使用。

这种方法的好处是它是非常声明性的，因为我们没有真正使用任何低级抽象(如`FOR`循环或变量或任何真正的东西)来表示数据流。我们只是简单地陈述我们的数据必须发生什么，我们让环境(运行我们的代码)来处理剩下的事情。

当试图理解 FP 时，要理解的主要概念是纯函数的概念，或者更确切地说，是没有副作用的函数。这意味着每次你用相同的输入调用一个纯函数，你应该期待相同的结果。如果函数以某种方式更新全局变量或者将不同的数据保存到一个文件中，那么这个函数就不再是纯粹的了，你应该考虑将它分解并提炼出它的行为。

其他有趣的 FP 技术包括:

*   [*Currying*](https://en.wikipedia.org/wiki/Currying)functions，允许您创建具有预定义参数的子功能。
*   [*闭包*](https://en.wikipedia.org/wiki/Closure_(computer_programming)) ，可以在任何给定时间充当函数作用域的快照。这些在从其他函数的执行中返回函数时非常有用。

你可以用 FP 解决任何类型的问题。从 web 开发到数据处理，什么都有 FP 框架。就像我一开始说的:范式不会限制你的可能性。

也就是说，来自 OOP 的人们一开始很难意识到这一点，因此他们将 FP 标记为学习玩具，并转向“更大更好”的选项。这是一个巨大的错误，希望这篇文章有助于揭示这个错误。

如果你有兴趣学习更多关于 FP 的知识，试着去学一些语言，比如 [Scala](https://www.scala-lang.org/) 、 [Lisp](https://en.wikipedia.org/wiki/Lisp_(programming_language)) 或者 [Erlang](https://www.erlang.org/) 。

# 等等，那我应该用哪一个呢？

简而言之:都有，要么，我不在乎。

真的，为了更丰富的体验，我会建议两者都用，因为它们是解决相同问题(潜在的)的不同方法。从学习的角度来看，这很棒，因为:

*   你会学到别人不会教你的工具和方法。
*   在实践中，您会发现许多语言都接受这两种范式的混合(在某种程度上，比如 JavaScript 或 Python)。知道如何使用这两种语言将有助于你充分利用这些语言。

因此，我的建议是，不要只关注一种范式而忽略另一种范式:

*   关注抽象、功能和你的目标。您试图解决的问题应该决定您将使用的范式，而不是相反。
*   请记住，范式就像语言一样，只是一种工具。如果你对 OOP 和 FP 中的任何一个都足够熟练，你也可以做同样的事情，那么为什么要关注范式呢？相反，试着在每种情况下使用最好的工具。

最后，考虑相反的情况:如果你决定只想学习和使用 OOP 会怎么样？那太好了；如果你探索得足够多，你会成为一个伟大的 OOP 大师。但是对于你在这个过程中发现的每一个问题，你都将试图把一组对象强加给它。行得通吗？是的，绝对的。在某些情况下，有没有更容易的选择？是的，绝对是，但是你会错过它，因为你只是通过你的 OOP 眼镜在看它。

在编程中，没有一个解决方案或一种方法可以解决所有问题——我们都知道这一点。那为什么要花时间和精力去做一个纯粹主义者呢？这听起来可能很疯狂，但是如果有足够的时间，你会发现应用错误的范式需要更多的工作时间来解决的问题，比你适应、学习一种新的工作方式并使用它来解决问题要多得多。

从那次经历中你会成为一名更好的程序员。相信我，即使只是为了好玩，学习一种新的范式，学习一门新的语言——这将帮助你用你的主要技术改进你的编码方式。

让我问你:你是纯粹主义者吗？还是愿意对不同的问题应用不同的范式？在评论中分享你的经验吧！