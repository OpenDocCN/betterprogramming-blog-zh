<html>
<head>
<title>The Importance of Hash Maps</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">哈希映射的重要性</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/the-importance-of-hash-maps-831884307806?source=collection_archive---------10-----------------------#2020-08-24">https://betterprogramming.pub/the-importance-of-hash-maps-831884307806?source=collection_archive---------10-----------------------#2020-08-24</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="8a70" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated"><em class="kf">哈希映射可以解决一大堆不同的问题</em></h2></div><figure class="kh ki kj kk gt kl gh gi paragraph-image"><div role="button" tabindex="0" class="km kn di ko bf kp"><div class="gh gi kg"><img src="../Images/6e9f2d55f04a274f8cad155637b85ec8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*xs9VIqM97YsDa0HJ"/></div></div><p class="ks kt gj gh gi ku kv bd b be z dk translated">照片由<a class="ae kw" href="https://unsplash.com/@hjrc33?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Héctor J. Rivas </a>在<a class="ae kw" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄。</p></figure><p id="a426" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">哈希是计算机科学中的一种传统方法，称为哈希映射的数据结构用于存储键值对<em class="lt">。</em>除了存储键值对，哈希映射还可以用来解决计算机科学中的各种问题。当与优先级队列和其他容器适配器(如堆栈和队列)一起使用时，哈希映射可以通过降低运行时间的复杂性来加快问题的解决。</p><p id="d4df" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">让我们深入了解哈希映射的基本概念，它们在C++中的用法，以及对一些最重要问题的应用。</p></div><div class="ab cl lu lv hu lw" role="separator"><span class="lx bw bk ly lz ma"/><span class="lx bw bk ly lz ma"/><span class="lx bw bk ly lz"/></div><div class="ij ik il im in"><h1 id="4070" class="mb mc iq bd md me mf mg mh mi mj mk ml jw mm jx mn jz mo ka mp kc mq kd mr ms bi translated"><strong class="ak">哈希映射背后的概念</strong></h1><p id="f77b" class="pw-post-body-paragraph kx ky iq kz b la mt jr lc ld mu ju lf lg mv li lj lk mw lm ln lo mx lq lr ls ij bi translated">哈希映射通常将元素存储为键值对。考虑这个例子:我们想将一个食品杂货列表及其价格存储到哈希映射中。商品的名称作为一个键，它的价格就是价值。这个键值对存储在一个哈希映射中，如下所示:</p><figure class="kh ki kj kk gt kl gh gi paragraph-image"><div class="gh gi my"><img src="../Images/650cd9640304487ebf77a9650252c116.png" data-original-src="https://miro.medium.com/v2/resize:fit:388/format:webp/1*xKFm8S0guRV3X1OLzzrPGw.png"/></div><p class="ks kt gj gh gi ku kv bd b be z dk translated">价格存储在无序地图中的项目。</p></figure><p id="e517" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">在无序散列映射(也称为无序映射)中，存储键值的顺序没有保证。当我们将一个项目插入到无序的散列图中时，它可以驻留在<code class="fe mz na nb nc b">Map</code>对象中的任何位置。如果我们想要严格地按照键的升序排列项目，我们可以使用有序散列映射或简单的映射。对于上述示例，项目在地图中的存储方式如下:</p><figure class="kh ki kj kk gt kl gh gi paragraph-image"><div class="gh gi nd"><img src="../Images/96be7a2940c4901683a0ccd23b607ccc.png" data-original-src="https://miro.medium.com/v2/resize:fit:450/format:webp/1*kWrMUOlhM1waroBJlWgR9A.png"/></div><p class="ks kt gj gh gi ku kv bd b be z dk translated">价格存储在地图中的项目。</p></figure><p id="ed33" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">这些键按照字典顺序从最小的字母<em class="lt"> c </em>开始排序。当一个价格为<em class="lt"/>【12】<em class="lt"/>的新物品如果汁<em class="lt"> </em>需要添加到地图中时，它被插入到<em class="lt"> </em>巧克力<em class="lt"> </em>之后的位置3，以保持字典顺序<em class="lt">。</em></p><figure class="kh ki kj kk gt kl gh gi paragraph-image"><div class="gh gi ne"><img src="../Images/0ef9dec2cefc9d7e9a3c0caba06fb210.png" data-original-src="https://miro.medium.com/v2/resize:fit:364/format:webp/1*2khxOC-FczvfFUKV6t4aIg.png"/></div><p class="ks kt gj gh gi ku kv bd b be z dk translated">果汁<strong class="bd nf"> </strong>加入地图。</p></figure></div><div class="ab cl lu lv hu lw" role="separator"><span class="lx bw bk ly lz ma"/><span class="lx bw bk ly lz ma"/><span class="lx bw bk ly lz"/></div><div class="ij ik il im in"><h1 id="55db" class="mb mc iq bd md me mf mg mh mi mj mk ml jw mm jx mn jz mo ka mp kc mq kd mr ms bi translated">编码哈希映射</h1><p id="61aa" class="pw-post-body-paragraph kx ky iq kz b la mt jr lc ld mu ju lf lg mv li lj lk mw lm ln lo mx lq lr ls ij bi translated">无序映射和映射是C++中标准模板库(STL)的一部分。要声明地图和无序地图<em class="lt">，</em>运行以下命令:</p><pre class="kh ki kj kk gt ng nc nh ni aw nj bi"><span id="3857" class="nk mc iq nc b gy nl nm l nn no">map&lt;key_type, value_type&gt;mp;</span><span id="2cd0" class="nk mc iq nc b gy np nm l nn no">unordered_map&lt;key_type, value_type&gt;unmp;</span></pre><p id="33d3" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated"><code class="fe mz na nb nc b">key_type</code>和<code class="fe mz na nb nc b">value_type</code>可以是标准数据类型，如<code class="fe mz na nb nc b">int</code>、<code class="fe mz na nb nc b">float</code>、<code class="fe mz na nb nc b">char</code>、<code class="fe mz na nb nc b">pair</code>等。</p><p id="e07f" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">大多数成员函数对于<code class="fe mz na nb nc b">unordered_map</code>和<code class="fe mz na nb nc b">map object</code>是通用的。让我们来看看其中的一些函数。</p><h2 id="567a" class="nk mc iq bd md nq nr dn mh ns nt dp ml lg nu nv mn lk nw nx mp lo ny nz mr oa bi translated"><strong class="ak"> 1。将项目插入散列图</strong></h2><p id="a6ff" class="pw-post-body-paragraph kx ky iq kz b la mt jr lc ld mu ju lf lg mv li lj lk mw lm ln lo mx lq lr ls ij bi translated">要将项目插入到<code class="fe mz na nb nc b">unordered_map</code>或<code class="fe mz na nb nc b">map</code>中，运行以下命令:</p><pre class="kh ki kj kk gt ng nc nh ni aw nj bi"><span id="717c" class="nk mc iq nc b gy nl nm l nn no">mp.insert(pair&lt;key_name, value&gt;);</span></pre><p id="4f77" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated"><code class="fe mz na nb nc b">key_name</code>和<code class="fe mz na nb nc b">value</code> <em class="lt"> </em>分别是要插入到<code class="fe mz na nb nc b">map</code>中的项目名称和值。在上例中，我们将<code class="fe mz na nb nc b">Carrots</code> <em class="lt"> </em>作为<code class="fe mz na nb nc b">key_name</code><em class="lt"/><code class="fe mz na nb nc b">$2</code><em class="lt"/>作为<code class="fe mz na nb nc b">value</code> <em class="lt">。</em>我们也可以使用赋值操作符插入项目:</p><pre class="kh ki kj kk gt ng nc nh ni aw nj bi"><span id="7d70" class="nk mc iq nc b gy nl nm l nn no">mp["Carrots"] = 2;</span></pre><h2 id="6d09" class="nk mc iq bd md nq nr dn mh ns nt dp ml lg nu nv mn lk nw nx mp lo ny nz mr oa bi translated">2.从哈希映射中删除项目</h2><p id="556c" class="pw-post-body-paragraph kx ky iq kz b la mt jr lc ld mu ju lf lg mv li lj lk mw lm ln lo mx lq lr ls ij bi translated">要从哈希映射中删除一个条目，我们使用<code class="fe mz na nb nc b">erase</code> <em class="lt"> </em>函数:</p><pre class="kh ki kj kk gt ng nc nh ni aw nj bi"><span id="a649" class="nk mc iq nc b gy nl nm l nn no">mp.erase(mp.begin()); //Delete an item at start</span><span id="5e80" class="nk mc iq nc b gy np nm l nn no">mp.erase("Carrots"); //Delete an item with key "Carrots"</span><span id="a3aa" class="nk mc iq nc b gy np nm l nn no">mp.erase(mp.begin(), mp.end()); //Delete all items in the map</span></pre><h2 id="7c22" class="nk mc iq bd md nq nr dn mh ns nt dp ml lg nu nv mn lk nw nx mp lo ny nz mr oa bi translated">3.在哈希映射中查找项目</h2><p id="8faf" class="pw-post-body-paragraph kx ky iq kz b la mt jr lc ld mu ju lf lg mv li lj lk mw lm ln lo mx lq lr ls ij bi translated">为了在散列图中找到一个条目，我们使用了<code class="fe mz na nb nc b">find</code> <em class="lt"> </em>函数:</p><pre class="kh ki kj kk gt ng nc nh ni aw nj bi"><span id="0613" class="nk mc iq nc b gy nl nm l nn no">const_iterator itr = mp.find("Carrots");</span></pre><p id="54b4" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">如果在映射中找到了<code class="fe mz na nb nc b">Carrots</code> <em class="lt"> </em>，那么<code class="fe mz na nb nc b">itr</code> <em class="lt"> </em>包含散列映射中元素的迭代器。如果没有找到指定的键，<code class="fe mz na nb nc b">itr</code> <em class="lt"> </em>包含<code class="fe mz na nb nc b">unordered_map::end</code>的值。</p><h2 id="a9a1" class="nk mc iq bd md nq nr dn mh ns nt dp ml lg nu nv mn lk nw nx mp lo ny nz mr oa bi translated"><strong class="ak"> 4。其他哈希映射函数</strong></h2><p id="179e" class="pw-post-body-paragraph kx ky iq kz b la mt jr lc ld mu ju lf lg mv li lj lk mw lm ln lo mx lq lr ls ij bi translated">下面是哈希映射中使用的一些其他常用函数:</p><pre class="kh ki kj kk gt ng nc nh ni aw nj bi"><span id="55fb" class="nk mc iq nc b gy nl nm l nn no">value = mp.at("Carrots"); //Returns the value at key </span><span id="8459" class="nk mc iq nc b gy np nm l nn no">cnt = mp.count("Carrots"); //Returns the total number of carrot</span><span id="de08" class="nk mc iq nc b gy np nm l nn no">is_empty = mp.empty(); //Returns if the Hash Map is Empty</span><span id="f272" class="nk mc iq nc b gy np nm l nn no">total_size = mp.size(); //Returns the total number of items</span></pre></div><div class="ab cl lu lv hu lw" role="separator"><span class="lx bw bk ly lz ma"/><span class="lx bw bk ly lz ma"/><span class="lx bw bk ly lz"/></div><div class="ij ik il im in"><h1 id="03f4" class="mb mc iq bd md me mf mg mh mi mj mk ml jw mm jx mn jz mo ka mp kc mq kd mr ms bi translated">哈希映射的应用</h1><p id="3f87" class="pw-post-body-paragraph kx ky iq kz b la mt jr lc ld mu ju lf lg mv li lj lk mw lm ln lo mx lq lr ls ij bi translated">使用散列映射的最大优点之一是它们为搜索、插入和删除操作提供了一个恒定的时间<em class="lt"> O(1) </em>。这使得它们更适用于与查找重复项、查找项目频率和查找不同元素相关的问题。</p><h2 id="39d7" class="nk mc iq bd md nq nr dn mh ns nt dp ml lg nu nv mn lk nw nx mp lo ny nz mr oa bi translated"><strong class="ak"> 1。与项目频率相关的问题</strong></h2><p id="fff3" class="pw-post-body-paragraph kx ky iq kz b la mt jr lc ld mu ju lf lg mv li lj lk mw lm ln lo mx lq lr ls ij bi translated">哈希映射对于解决大多数与项目频率相关的问题非常有用。这类问题的一个例子是在字符串列表中查找常见字符。如果一个项目在所有字符串中出现两次，则需要在输出中包含两次:</p><pre class="kh ki kj kk gt ng nc nh ni aw nj bi"><span id="5e31" class="nk mc iq nc b gy nl nm l nn no"><strong class="nc ir">Input: </strong>["bella","label","roller"]<br/><strong class="nc ir">Output: </strong>["e","l","l"]</span></pre><p id="2937" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">为了解决这个问题，我们可以使用两个<code class="fe mz na nb nc b">for</code> <em class="lt"> </em>循环来比较一个字符串和其他字符串的列表。但是这种方法的时间复杂度是O(n ) 。为了最小化时间复杂度，我们可以使用哈希映射将字符存储为键，将字符串编号和频率存储为一对值。然后，我们可以迭代哈希映射来检查所有字符串中的常见字符及其出现频率。这就把时间复杂度降低到了<em class="lt"> O(n) </em>。</p><h2 id="251c" class="nk mc iq bd md nq nr dn mh ns nt dp ml lg nu nv mn lk nw nx mp lo ny nz mr oa bi translated"><strong class="ak"> 2。字典</strong></h2><p id="75f7" class="pw-post-body-paragraph kx ky iq kz b la mt jr lc ld mu ju lf lg mv li lj lk mw lm ln lo mx lq lr ls ij bi translated">字典是另一个更频繁使用散列映射的常见例子。如果我们要制作一个搜索单词意思的在线门户，我们将在后端<em class="lt"> </em>建立一个词典<em class="lt"> </em>来存储单词及其意思。当用户搜索一个单词时，它使用<code class="fe mz na nb nc b">find</code> <em class="lt"> </em>散列函数来检索其含义。</p><h2 id="1916" class="nk mc iq bd md nq nr dn mh ns nt dp ml lg nu nv mn lk nw nx mp lo ny nz mr oa bi translated"><strong class="ak"> 3。文件系统</strong></h2><p id="0c5e" class="pw-post-body-paragraph kx ky iq kz b la mt jr lc ld mu ju lf lg mv li lj lk mw lm ln lo mx lq lr ls ij bi translated">哈希映射用于链接文件名和文件路径。为了存储文件名和路径与该文件在磁盘上的物理位置之间的对应关系，系统使用映射。该映射通常以哈希表的形式实现。</p><h2 id="cfb2" class="nk mc iq bd md nq nr dn mh ns nt dp ml lg nu nv mn lk nw nx mp lo ny nz mr oa bi translated"><strong class="ak"> 4。密码验证</strong></h2><p id="d599" class="pw-post-body-paragraph kx ky iq kz b la mt jr lc ld mu ju lf lg mv li lj lk mw lm ln lo mx lq lr ls ij bi translated">考虑一个web应用程序，当用户输入用户名和密码时，它允许用户登录和验证。在大多数现代系统中，用户名和密码不会以纯文本形式发送到后端服务器进行身份验证。相反，它们被编码为哈希值并发送给服务器。然后，服务器用存储的哈希值检查接收到的哈希值。如果匹配，则允许用户登录。为此使用了特殊的加密函数，因此用户是安全的。</p><h2 id="09eb" class="nk mc iq bd md nq nr dn mh ns nt dp ml lg nu nv mn lk nw nx mp lo ny nz mr oa bi translated"><strong class="ak"> 5。云中的存储优化</strong></h2><p id="f88d" class="pw-post-body-paragraph kx ky iq kz b la mt jr lc ld mu ju lf lg mv li lj lk mw lm ln lo mx lq lr ls ij bi translated">Dropbox <em class="lt"> </em>在云端使用哈希表进行存储优化。假设有多个用户将同一个视频上传到他们的Dropbox <em class="lt"> </em>账户。由于存储同一视频的多个副本会消耗太多的存储空间，Dropbox存储文件的单个副本，并提供链接供每个用户访问。当一个新用户上传同一个文件时，Dropbox <em class="lt"> </em>会计算文件的哈希值。如果它与哈希表中存储的值匹配，则向用户返回该文件的链接。</p><h2 id="99b6" class="nk mc iq bd md nq nr dn mh ns nt dp ml lg nu nv mn lk nw nx mp lo ny nz mr oa bi translated"><strong class="ak"> 6。编译器操作</strong></h2><p id="f480" class="pw-post-body-paragraph kx ky iq kz b la mt jr lc ld mu ju lf lg mv li lj lk mw lm ln lo mx lq lr ls ij bi translated">为了识别编程语言中的关键字，编译器将它们存储在哈希表中。然后，编译器用哈希表检查程序，以验证程序语法是否正确。</p></div><div class="ab cl lu lv hu lw" role="separator"><span class="lx bw bk ly lz ma"/><span class="lx bw bk ly lz ma"/><span class="lx bw bk ly lz"/></div><div class="ij ik il im in"><h1 id="4563" class="mb mc iq bd md me mf mg mh mi mj mk ml jw mm jx mn jz mo ka mp kc mq kd mr ms bi translated">结论</h1><p id="2423" class="pw-post-body-paragraph kx ky iq kz b la mt jr lc ld mu ju lf lg mv li lj lk mw lm ln lo mx lq lr ls ij bi translated">这些只是使用哈希映射的几个应用程序。哈希映射是每个开发人员都需要知道的最重要的工具之一。这使得解决问题变得更快更容易——尤其是处理项目频率的问题。</p></div></div>    
</body>
</html>