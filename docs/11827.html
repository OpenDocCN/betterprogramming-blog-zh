<html>
<head>
<title>How to Create Dynamic Queries in Spring Data</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何在Spring数据中创建动态查询</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/how-to-create-dynamic-queries-in-spring-data-355ff69e81d0?source=collection_archive---------1-----------------------#2022-04-20">https://betterprogramming.pub/how-to-create-dynamic-queries-in-spring-data-355ff69e81d0?source=collection_archive---------1-----------------------#2022-04-20</a></blockquote><div><div class="fc ii ij ik il im"/><div class="in io ip iq ir"><div class=""/><div class=""><h2 id="b39e" class="pw-subtitle-paragraph jr it iu bd b js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki dk translated">如何使用JPA Criteria API编写完全动态的查询</h2></div><figure class="kk kl km kn gu ko gi gj paragraph-image"><div role="button" tabindex="0" class="kp kq di kr bf ks"><div class="gi gj kj"><img src="../Images/d574e0074c1c2c56718b2dac68d61574.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*utkfLfNhWwgLaWFu"/></div></div><p class="kv kw gk gi gj kx ky bd b be z dk translated">奥斯卡·伊尔迪兹在<a class="ae kz" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</p></figure><p id="5a62" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">最近，我遇到了一个复杂的问题，我必须创建一个完全动态的查询。因为找到解决方案有点耗时，所以值得在一篇专门的文章中写出来。希望对别人有帮助。</p><h2 id="d356" class="lw lx iu bd ly lz ma dn mb mc md dp me lj mf mg mh ln mi mj mk lr ml mm mn mo bi translated">方案</h2><p id="1292" class="pw-post-body-paragraph la lb iu lc b ld mp jv lf lg mq jy li lj mr ll lm ln ms lp lq lr mt lt lu lv in bi translated">考虑以下情况:</p><p id="1a65" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">您有一个包含5列的实体。<code class="fe mu mv mw mx b">group by</code>子句根据用户输入而变化。例如，假设有一个UI，用户可以在其中选择要选择的列以及如何对它们进行分组。</p><p id="9628" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">例如:</p><figure class="kk kl km kn gu ko gi gj paragraph-image"><div role="button" tabindex="0" class="kp kq di kr bf ks"><div class="gi gj my"><img src="../Images/587dbe360c977fbe2f8880576dfa4952.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*nq0AQEihMwOZW5DkB5fwyg.png"/></div></div><p class="kv kw gk gi gj kx ky bd b be z dk translated">作者选择的列的示例</p></figure><p id="a411" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">用户已经选择了绿色字段。</p><p id="1a2f" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">假设您的应用程序产生以下JPA查询。它有什么问题？</p><pre class="kk kl km kn gu mz mx na nb aw nc bi"><span id="ff8e" class="lw lx iu mx b gz nd ne l nf ng">select sr.user, sr.timestamp, <strong class="mx iv">sr.status</strong>, sr.date, sr.instances from SERVER_RECORD sr where sr.user = 'user123' group by <strong class="mx iv">sr.status</strong>;</span></pre><p id="418b" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">它将显示一个错误，说明其余的列，即“<em class="nh">用户、时间戳、日期、实例</em>”，没有包含在<code class="fe mu mv mw mx b">group by </code>子句中或者没有聚合:</p><pre class="kk kl km kn gu mz mx na nb aw nc bi"><span id="6282" class="lw lx iu mx b gz nd ne l nf ng">Column ‘{the column name}’ is invalid in the select list because it is not contained in either an aggregate function or the GROUP BY clause</span></pre><p id="301d" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">在<code class="fe mu mv mw mx b">select</code>子句中没有<code class="fe mu mv mw mx b">aggregate</code>的所有列都需要在<code class="fe mu mv mw mx b">group by</code>部分中。</p><p id="60de" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">在这篇文章中，我将向你展示一种解决这个问题的方法。</p><p id="8dc8" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated"><em class="nh">本教程假设你已经熟悉了</em> <a class="ae kz" href="https://en.wikibooks.org/wiki/Java_Persistence/Criteria" rel="noopener ugc nofollow" target="_blank"> <em class="nh"> Java持久性标准API </em> </a> <em class="nh">。</em></p><p id="6c81" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">让我们开始吧！</p></div><div class="ab cl ni nj hy nk" role="separator"><span class="nl bw bk nm nn no"/><span class="nl bw bk nm nn no"/><span class="nl bw bk nm nn"/></div><div class="in io ip iq ir"><h1 id="5da8" class="np lx iu bd ly nq nr ns mb nt nu nv me ka nw kb mh kd nx ke mk kg ny kh mn nz bi translated">项目解决方案</h1><p id="e77c" class="pw-post-body-paragraph la lb iu lc b ld mp jv lf lg mq jy li lj mr ll lm ln ms lp lq lr mt lt lu lv in bi translated">为了说明这种情况，让我们创建一个简单的例子。假设您想要查询名为<code class="fe mu mv mw mx b">SERVER_RECORD</code>的表中的记录。下面是实体类:</p><figure class="kk kl km kn gu ko"><div class="bz fq l di"><div class="oa ob l"/></div><p class="kv kw gk gi gj kx ky bd b be z dk translated">ServerRecord实体</p></figure><p id="947d" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">让我们命名将查询数据<code class="fe mu mv mw mx b">ServerRecordFinder </code>并获得<code class="fe mu mv mw mx b">EntityManager</code>实例的服务:</p><figure class="kk kl km kn gu ko"><div class="bz fq l di"><div class="oa ob l"/></div><p class="kv kw gk gi gj kx ky bd b be z dk translated">创建记录查找服务</p></figure><p id="8f6a" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">让我们编写一个返回记录的方法:</p><figure class="kk kl km kn gu ko"><div class="bz fq l di"><div class="oa ob l"/></div><p class="kv kw gk gi gj kx ky bd b be z dk translated">getRecords()方法第一部分</p></figure><p id="19ca" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">由于我们没有UI，我们将对用户输入进行硬编码，以便进行演示:</p><p id="07ec" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">选择部分:</p><ul class=""><li id="b57b" class="oc od iu lc b ld le lg lh lj oe ln of lr og lv oh oi oj ok bi translated"><code class="fe mu mv mw mx b">IMESTAMP</code>，<code class="fe mu mv mw mx b">USER</code></li></ul><p id="2378" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">分组依据部分:</p><ul class=""><li id="c891" class="oc od iu lc b ld le lg lh lj oe ln of lr og lv oh oi oj ok bi translated"><code class="fe mu mv mw mx b">DATE</code></li></ul><p id="63ec" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">让我们构建查询:</p><figure class="kk kl km kn gu ko"><div class="bz fq l di"><div class="oa ob l"/></div><p class="kv kw gk gi gj kx ky bd b be z dk translated">getRecords()方法第二部分</p></figure><p id="e3dd" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">select部分从用户输入中获取选中的列，并将它们放入<code class="fe mu mv mw mx b">Selection</code>列表中。</p><p id="aca6" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">这就是<code class="fe mu mv mw mx b">getSelectedColumns(root)</code>方法的内容:</p><figure class="kk kl km kn gu ko"><div class="bz fq l di"><div class="oa ob l"/></div></figure><ul class=""><li id="5b75" class="oc od iu lc b ld le lg lh lj oe ln of lr og lv oh oi oj ok bi translated"><code class="fe mu mv mw mx b">alias</code>方法非常重要<strong class="lc iv"/>——这就是我们如何在将结果映射到实体时引用别名。</li><li id="f623" class="oc od iu lc b ld ol lg om lj on ln oo lr op lv oh oi oj ok bi translated">我们将选择列表传递给<code class="fe mu mv mw mx b">multiselect</code>查询方法。</li><li id="5ef1" class="oc od iu lc b ld ol lg om lj on ln oo lr op lv oh oi oj ok bi translated"><code class="fe mu mv mw mx b">where</code>子句向<code class="fe mu mv mw mx b">criteriabuilder</code>添加谓词。在这个例子中，我们想要查询用户<em class="nh">= "<em class="nh">XYZ</em>"的记录。</em></li><li id="2ede" class="oc od iu lc b ld ol lg om lj on ln oo lr op lv oh oi oj ok bi translated">在最后的查询部分，我们构建了<code class="fe mu mv mw mx b">group by</code>子句。请注意，我们将<code class="fe mu mv mw mx b">group by</code>值与<code class="fe mu mv mw mx b">select</code>值相结合。这确保了没有集合的每个选择都包含在<code class="fe mu mv mw mx b">group by</code>零件中。</li></ul><p id="5243" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">现在该创建一个<code class="fe mu mv mw mx b">TypedQuery</code>并执行它了:</p><figure class="kk kl km kn gu ko"><div class="bz fq l di"><div class="oa ob l"/></div></figure><ul class=""><li id="22d9" class="oc od iu lc b ld le lg lh lj oe ln of lr og lv oh oi oj ok bi translated"><code class="fe mu mv mw mx b">query.getResultList()</code>方法返回一个包含查询结果的<code class="fe mu mv mw mx b">Tuple</code>。</li><li id="81d1" class="oc od iu lc b ld ol lg om lj on ln oo lr op lv oh oi oj ok bi translated">创建一个新方法来访问<code class="fe mu mv mw mx b">TupleElement</code>。<code class="fe mu mv mw mx b">getAlias()</code>方法收集我们之前定义的所有别名。</li></ul><figure class="kk kl km kn gu ko"><div class="bz fq l di"><div class="oa ob l"/></div></figure><p id="a246" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">现在，我们可以遍历查询结果并将其映射到<code class="fe mu mv mw mx b">ServerRecord</code>实体:</p><figure class="kk kl km kn gu ko"><div class="bz fq l di"><div class="oa ob l"/></div></figure><p id="e763" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">这就是<code class="fe mu mv mw mx b">getValueByColumnName()</code>方法的样子:</p><figure class="kk kl km kn gu ko"><div class="bz fq l di"><div class="oa ob l"/></div></figure><p id="80b4" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">你可能想知道这个方法的目的是什么。记住，我们为<code class="fe mu mv mw mx b">select</code>子句定义了一个动态选择列表。因此，它可能不包含所有列。所以，如果你试图使用<code class="fe mu mv mw mx b">tuple.get(“some alias name”)</code>，而它并不存在，它会抛出这样一个异常:</p><pre class="kk kl km kn gu mz mx na nb aw nc bi"><span id="09cf" class="lw lx iu mx b gz nd ne l nf ng">java.lang.IllegalArgumentException: Given alias [some alias] did not correspond to an element in the result tuple at org.hibernate.jpa.spi.CriteriaQueryTupleTransformer$TupleImpl.get(CriteriaQueryTupleTransformer.java:93)</span></pre><p id="3ed5" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">因此，我们只需要设置那些列在<code class="fe mu mv mw mx b">selectedResultColumns</code>集合中的值。否则，我们将属性值设置为<code class="fe mu mv mw mx b">null</code>以跳过它。</p><p id="cbff" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">最后，生成的查询如下所示:</p><pre class="kk kl km kn gu mz mx na nb aw nc bi"><span id="0515" class="lw lx iu mx b gz nd ne l nf ng">select sr.TIMESTAMP, sr.USER from SERVER_RECORD sr where sr.USER = 'xyz' group by sr.TIMESTAMP, sr.USER, sr.DATE;</span></pre></div><div class="ab cl ni nj hy nk" role="separator"><span class="nl bw bk nm nn no"/><span class="nl bw bk nm nn no"/><span class="nl bw bk nm nn"/></div><div class="in io ip iq ir"><h1 id="a47f" class="np lx iu bd ly nq nr ns mb nt nu nv me ka nw kb mh kd nx ke mk kg ny kh mn nz bi translated">总结</h1><p id="af3b" class="pw-post-body-paragraph la lb iu lc b ld mp jv lf lg mq jy li lj mr ll lm ln ms lp lq lr mt lt lu lv in bi translated">在本教程中，您学习了如何编写高级动态JPA查询。</p><p id="1326" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">让我们来看看关键点:</p><ul class=""><li id="5e36" class="oc od iu lc b ld le lg lh lj oe ln of lr og lv oh oi oj ok bi translated">我们使用<a class="ae kz" href="https://docs.oracle.com/javaee/7/api/javax/persistence/criteria/CriteriaQuery.html" rel="noopener ugc nofollow" target="_blank"> CriteriaQuery </a>和<a class="ae kz" href="https://docs.oracle.com/javaee/7/api/javax/persistence/criteria/CriteriaBuilder.html" rel="noopener ugc nofollow" target="_blank"> CriteriaBuilder </a>来构建一个JPA查询。</li><li id="e3c7" class="oc od iu lc b ld ol lg om lj on ln oo lr op lv oh oi oj ok bi translated">我们为<code class="fe mu mv mw mx b">select</code>子句中的列分配了别名。</li><li id="f878" class="oc od iu lc b ld ol lg om lj on ln oo lr op lv oh oi oj ok bi translated">我们通过引用别名将元组查询结果映射到实体。</li></ul><p id="c613" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">这个例子的完整代码片段可以在<a class="ae kz" href="https://gist.github.com/kirshiyin89/17af57c97598350521e8ecc3631afa3d" rel="noopener ugc nofollow" target="_blank">这里</a>找到。</p><p id="6213" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">希望这篇教程有所帮助。感谢您的阅读，祝您编码愉快！</p></div></div>    
</body>
</html>