<html>
<head>
<title>Don’t Use CRUD Styled APIs, Consider Intent-Based Rest APIs</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">不要使用CRUD风格的API，考虑基于意图的Rest APIs</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/intent-based-rest-apis-or-an-alternative-to-crud-based-rest-apis-1815599db60a?source=collection_archive---------0-----------------------#2022-01-15">https://betterprogramming.pub/intent-based-rest-apis-or-an-alternative-to-crud-based-rest-apis-1815599db60a?source=collection_archive---------0-----------------------#2022-01-15</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="b21d" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">为什么基于意图或动作的REST APIs是更好的选择</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/2662ab45a197fef8b6ae2950423ae402.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*lbEgtKi6Qm69pFAN"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">照片由<a class="ae kv" href="https://unsplash.com/@tezos?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">泰佐斯</a>在<a class="ae kv" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>拍摄</p></figure><h1 id="849d" class="kw kx iq bd ky kz la lb lc ld le lf lg jw lh jx li jz lj ka lk kc ll kd lm ln bi translated">修正案</h1><p id="d2df" class="pw-post-body-paragraph lo lp iq lq b lr ls jr lt lu lv ju lw lx ly lz ma mb mc md me mf mg mh mi mj ij bi translated">回头看看这篇文章，我相信在基于意图的API的上下文中，所用的例子相当糟糕。由于这一点，我写了这篇文章的续篇，不仅扩展了这个主题，而且更好地解释了我在这里解释得不好的一些部分。<a class="ae kv" href="https://techblog.pointsbet.com/a-structured-approach-to-designing-intent-based-apis-910ed1fc78f2" rel="noopener ugc nofollow" target="_blank">随意阅读下一篇</a>这里链接的文章，它应该填补了很多空白，重新更好更正确地解释了一些概念。出于对更好编程的考虑，我想提一下sequel文章是在不同的出版物上发表的。</p><h1 id="63ca" class="kw kx iq bd ky kz la lb lc ld le lf lg jw lh jx li jz lj ka lk kc ll kd lm ln bi translated">关于休息和垃圾的快速复习</h1><p id="16a8" class="pw-post-body-paragraph lo lp iq lq b lr ls jr lt lu lv ju lw lx ly lz ma mb mc md me mf mg mh mi mj ij bi translated">REST APIs在最近几年已经成为行业标准，在流行程度上似乎已经超过了RPC和SOAP APIs。</p><p id="7f35" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">Roy Fielding在他2000年的论文中创造了这个术语，REST或RESTful代表具象状态转移，是一个构建API的设计范例，它有几个核心约束:</p><ol class=""><li id="19fe" class="mp mq iq lq b lr mk lu ml lx mr mb ms mf mt mj mu mv mw mx bi translated"><strong class="lq ir">客户端-服务器</strong>:客户端和服务器都独立工作。</li><li id="a2a4" class="mp mq iq lq b lr my lu mz lx na mb nb mf nc mj mu mv mw mx bi translated"><strong class="lq ir">无状态</strong>:服务器不记录客户端的状态。</li><li id="cf81" class="mp mq iq lq b lr my lu mz lx na mb nb mf nc mj mu mv mw mx bi translated"><strong class="lq ir">可缓存</strong>:服务器标记数据是否可缓存。</li><li id="eb9a" class="mp mq iq lq b lr my lu mz lx na mb nb mf nc mj mu mv mw mx bi translated"><strong class="lq ir">统一接口</strong>:客户端和服务器的行为遵循统一的接口，或者可以预见。</li><li id="b5e6" class="mp mq iq lq b lr my lu mz lx na mb nb mf nc mj mu mv mw mx bi translated">分层系统:应用程序从客户机和服务器之间的所有层中抽象出来。</li></ol><p id="b20f" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">通常，REST API被构建为模仿类似CRUD的接口，这源于HTTP标准方法的结构非常类似于CRUD接口，并且REST API处理可以由所述接口操纵的资源。</p><p id="6761" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">由此推断，REST资源的CRUD生命周期是这样的:你<code class="fe nd ne nf ng b">create</code> <strong class="lq ir"> </strong>一个资源，也许你偶尔想要<code class="fe nd ne nf ng b">update</code> <strong class="lq ir"> </strong>它。顺着这个轨迹，你<code class="fe nd ne nf ng b">read</code> <strong class="lq ir"> </strong>这个资源，也许你决定<code class="fe nd ne nf ng b">delete</code> <strong class="lq ir"> </strong>它。</p><pre class="kg kh ki kj gt nh ng ni nj aw nk bi"><span id="f45d" class="nl kx iq ng b gy nm nn l no np">HTTP Method | CRUD Operation<br/>POST        | Create Resource<br/>PUT         | Update / Set Resource<br/>GET         | Retrieve Resource<br/>DELETE      | Delete Resource</span></pre><h1 id="7230" class="kw kx iq bd ky kz la lb lc ld le lf lg jw lh jx li jz lj ka lk kc ll kd lm ln bi translated">我最关心的是污垢</h1><p id="5c3c" class="pw-post-body-paragraph lo lp iq lq b lr ls jr lt lu lv ju lw lx ly lz ma mb mc md me mf mg mh mi mj ij bi translated">我保证，这篇文章不是一篇恶意中伤的文章。它在这个世界上有它的位置(在大多数系统中，事实上)，而且我个人认为它在大多数情况下确实很方便。</p><p id="a6af" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">然而，当一个领域或问题集在复杂性方面开始向外螺旋上升时，我相信CRUD开始显示出它的一些弱点。</p><p id="edd2" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">无论如何，让我们创建一个可以用于本文其余部分的示例，这不是一个非常复杂的设计，但它应该可以满足演示的目的。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nr"><img src="../Images/a243335b6805d33afbf7b9200b7ba1e0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*cFvHX3AKJjSAVg1T4o0-FA.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">订单模型</p></figure><p id="f6b4" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">这里我们有一个针对某种产品运输领域的简单模型。</p><p id="15b1" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">这里的实体是订单，它封装了一个活动的订单状态，其中有几个值对象来帮助解释该状态。</p><h2 id="2b97" class="nl kx iq bd ky ns nt dn lc nu nv dp lg lx nw nx li mb ny nz lk mf oa ob lm oc bi translated">CRUD需要非常粗粒度的设计</h2><p id="9c0b" class="pw-post-body-paragraph lo lp iq lq b lr ls jr lt lu lv ju lw lx ly lz ma mb mc md me mf mg mh mi mj ij bi translated">这是真的，在很多情况下这是没问题的，尤其是对于较小的领域或模型。许多资源包含子资源或其中的字段，这些子资源或字段与某些领域逻辑相关联。</p><p id="3e98" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">在上例中，如果您想对订单<code class="fe nd ne nf ng b">CurrentLocation</code>进行更改，可能有三个原因:</p><ol class=""><li id="3733" class="mp mq iq lq b lr mk lu ml lx mr mb ms mf mt mj mu mv mw mx bi translated">订单从<code class="fe nd ne nf ng b">pending</code> <em class="nq"> </em>到<code class="fe nd ne nf ng b">in progress</code>，现在有了实际的<code class="fe nd ne nf ng b">CurrentLocation</code></li><li id="fa6d" class="mp mq iq lq b lr my lu mz lx na mb nb mf nc mj mu mv mw mx bi translated"> <code class="fe nd ne nf ng b">progress</code> <em class="nq"> </em>中的<em class="nq">的顺序已经移动</em></li><li id="c8c5" class="mp mq iq lq b lr my lu mz lx na mb nb mf nc mj mu mv mw mx bi translated">原来的<code class="fe nd ne nf ng b">in progress</code> <em class="nq"> </em>订单已经移到了它的<code class="fe nd ne nf ng b">Destination</code></li></ol><p id="3ad7" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">假设给你一个正在进行中的<code class="fe nd ne nf ng b">Order</code><em class="nq">，</em>，它的<code class="fe nd ne nf ng b">CurrentLocation</code>是“亚利桑那”。它的目的地是“墨西哥”。</p><p id="55d1" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">在一个普通的CRUD类操作中，要对<code class="fe nd ne nf ng b">Order</code>的<code class="fe nd ne nf ng b">CurrentLocation</code> <em class="nq"> </em>进行更改以交付<code class="fe nd ne nf ng b">Order</code>，您可能需要做如下事情:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi od"><img src="../Images/5981d268c54d83dc5779e21e7b0f1661.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*edC03IBnTGiCrVe1m4Tp7A.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">订单实体的更新请求</p></figure><p id="abed" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">这是粗粒度的，因为它将整个对象作为有效负载，这迫使用户了解业务逻辑如何工作，以便创建正确的调用(即，如果<code class="fe nd ne nf ng b">CurrentLocation == Destination</code>，则<code class="fe nd ne nf ng b">status</code> <em class="nq"> </em>应该是<code class="fe nd ne nf ng b">Delivered</code>)。</p><p id="19a4" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">这是一个为CRUD接口定制的请求，而不是为手边的问题定制的。</p><h1 id="e0a2" class="kw kx iq bd ky kz la lb lc ld le lf lg jw lh jx li jz lj ka lk kc ll kd lm ln bi translated">输入:基于意图或动作的REST API</h1><p id="cc08" class="pw-post-body-paragraph lo lp iq lq b lr ls jr lt lu lv ju lw lx ly lz ma mb mc md me mf mg mh mi mj ij bi translated">通过理解用户将与您的API交互以执行特定的<em class="nq">动作</em>或者在头脑中有特定的<em class="nq">意图</em>，很容易根据这些意图定制请求的模型，以减轻来自最终用户的知识负担，并将其转移到系统的责任中。</p><p id="ee6a" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">这偏离了REST的一些传统方面，几乎进入了RPC风格的领域，因为API允许对基于动词的资源或意图/动作进行操作，而不是传统的名词。</p><p id="36f6" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">在上面的例子中，我们在CRUD风格的请求中看到了一些缺点，所以让我们将其与<em class="nq">进行比较，后者是一种可能的基于</em>意图的变体:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi od"><img src="../Images/7b28691a96022526c66798b3a85a8d17.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*rO_u0A97BFcUUzHgHm6EuQ.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">向意向资源发出的交付订单的请求</p></figure><p id="5789" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">很简单，是吧？我们正在处理一个非常简单的领域。无论如何，这要求用户对领域的了解少得多，并且使用户不可能创建会使数据处于不良状态的请求。</p><p id="4a6e" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">通过发布到这个资源，我们确认用户想要将给定的<code class="fe nd ne nf ng b">Orders</code>状态设置为已交付。因此，让我们将它的<code class="fe nd ne nf ng b">CurrentLocation</code> <em class="nq"> </em>设置为<code class="fe nd ne nf ng b">Destination</code>，同时，让我们将它的<code class="fe nd ne nf ng b">Status</code> <em class="nq"> </em>更改为delivered。</p><p id="708e" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">通过这样做，我们实现了用户的意图，并在我们的系统中执行了所需的业务逻辑，而不需要用户理解字段应该如何连接在一起。</p><p id="2f01" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">如前所述，这是一个非常简单的例子，这就是为什么它看起来有点简单明了，然而，GitHub <a class="ae kv" href="https://docs.github.com/en/rest/reference/branches#merge-a-branch" rel="noopener ugc nofollow" target="_blank">实际上在它的合并和它的API中的其他地方做了一些类似的事情。它使用资源<em class="nq"> merges </em>并接受一个POST请求和几个必需的字段，然而，它最终为<em class="nq"> commit </em>资源返回一个“201 created”。<em class="nq">合并</em>资源并不映射到物理实体，而是映射到意图。整洁！</a></p><h1 id="770e" class="kw kx iq bd ky kz la lb lc ld le lf lg jw lh jx li jz lj ka lk kc ll kd lm ln bi translated">结论</h1><p id="12b9" class="pw-post-body-paragraph lo lp iq lq b lr ls jr lt lu lv ju lw lx ly lz ma mb mc md me mf mg mh mi mj ij bi translated">这可能会让你感到震惊，但是即使CRUD APIs在很多用例中工作得很好，它并不是在所有用例中都工作得很好。意图API是将用户意图具体化为API模型的一种方式，它将域逻辑从请求或请求链中分离出来，并放入意图资源的处理程序中，很好且安全地远离了糟糕的客户端。</p><p id="1572" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">ThoughtWorks有一篇关于这个话题的精彩文章,内容更加详细。一定要去看看！</p></div></div>    
</body>
</html>