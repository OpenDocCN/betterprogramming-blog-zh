<html>
<head>
<title>How to Combine Kotlin Suspend Function and Retrofit</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Kotlin悬挂功能与改造如何结合</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/a-solution-for-combining-kotlin-suspend-function-retrofit-8d17e1f4886?source=collection_archive---------2-----------------------#2022-06-27">https://betterprogramming.pub/a-solution-for-combining-kotlin-suspend-function-retrofit-8d17e1f4886?source=collection_archive---------2-----------------------#2022-06-27</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="f4c0" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">简化功能的简要指南</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/5ffb3f58345eb1faecabf496627117ba.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*bGWneJYNq1XQ078cYYSqyg.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">照片由<a class="ae kv" href="https://unsplash.com/@cstembridge?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">查德·斯特姆布里奇</a>在<a class="ae kv" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</p></figure><p id="a38a" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在Kotlin协程之前，当我们使用Before时，我们通常将它与RxJava结合使用，通过Single来表示创建的请求。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ls lt l"/></div></figure><p id="aac8" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">RxJava中的Single表示只包含一个事件的流，所以作为网络请求使用相对合理。</p><p id="0db5" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">但是，由于是HTTP网络请求，返回值必须只有一次，否则会引发异常。用流来形容似乎不太合适。毕竟，由单个事件组成的流听起来很奇怪。</p><p id="6b1e" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">所以对于发起网络请求形式的函数，直接返回数据或者抛出异常更实际。</p><p id="19e8" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">所以对于科特林来说，这种函数就是挂起函数。并且改造后还支持了暂停功能。</p><p id="14ea" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们来看看<code class="fe lu lv lw lx b">suspend</code> +改造的网络要求是什么样子的。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ls lt l"/></div></figure><p id="ef65" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这样看起来更直观，调用请求函数直接返回响应数据，或者抛出异常。</p><p id="19b1" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">但似乎还是有点问题，有点啰嗦，还得写try-catch，不够简洁优雅。</p><p id="3a75" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">其实也可以换成<code class="fe lu lv lw lx b">Flow</code>，但感觉还是不是最好的方案。<code class="fe lu lv lw lx b">Flow</code>的设计不适合用在这里，肯定有更好的解决方案。</p><p id="8831" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">前段时间，我在切换到Kotlin协程时遇到了这个问题。当时想到了一个看起来不错的解决方案，分享到这里。</p><p id="c32e" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">目前要解决的问题是，我们期望使用suspend函数发起网络请求，直接返回响应数据，但同时又不想写try-catch。</p><p id="d377" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我的想法是在改型得到请求后，构建一个响应类来包装数据和异常，调用者通过这个类得到数据或异常。其他的还是可以按照前面的逻辑，写法和下面差不多:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ls lt l"/></div></figure><p id="d69c" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><code class="fe lu lv lw lx b">Response</code>就是上面说的包装器类，<code class="fe lu lv lw lx b">onSuccess</code>和<code class="fe lu lv lw lx b">onError</code>代码块对应成功或失败，看起来比以前简单多了。</p><p id="81e1" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">下面是怎么做的。</p><p id="9973" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">由于需要添加返回类型进行改造，所以需要先创建一个与<code class="fe lu lv lw lx b">Response</code>对应的<code class="fe lu lv lw lx b">CallAdapterFactory</code>。获得响应数据或异常后，构造一个<code class="fe lu lv lw lx b">Response</code>,并将数据或异常存储在其中。大致就是这个思路，比较简单。那么我们就一步步来看一下具体的实现。</p><h1 id="23f9" class="ly lz iq bd ma mb mc md me mf mg mh mi jw mj jx mk jz ml ka mm kc mn kd mo mp bi translated">反应</h1><p id="c47a" class="pw-post-body-paragraph kw kx iq ky b kz mq jr lb lc mr ju le lf ms lh li lj mt ll lm ln mu lp lq lr ij bi translated">我们先来看看上面说的<code class="fe lu lv lw lx b">Response</code>是怎么定义的。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ls lt l"/></div></figure><p id="0046" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这个比较简单，<code class="fe lu lv lw lx b">success</code>表示请求是否成功，这个是在<code class="fe lu lv lw lx b">Response</code>构造好之后外部分配的。泛型<code class="fe lu lv lw lx b">S</code>代表请求成功后返回的数据类型，泛型<code class="fe lu lv lw lx b">E</code>是请求成功但接口返回错误数据的类型。</p><p id="0cfe" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><code class="fe lu lv lw lx b">ErrorResponse</code>定义如下。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ls lt l"/></div></figure><p id="0487" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">考虑到对调用者的友好性，错误数据被限制在至少一个<code class="fe lu lv lw lx b">errorMessage</code>。</p><h1 id="376a" class="ly lz iq bd ma mb mc md me mf mg mh mi jw mj jx mk jz ml ka mm kc mn kd mo mp bi translated">创建CallAdapterFactory</h1><p id="df06" class="pw-post-body-paragraph kw kx iq ky b kz mq jr lb lc mr ju le lf ms lh li lj mt ll lm ln mu lp lq lr ij bi translated">首先，创建一个扩展<code class="fe lu lv lw lx b">CallAdapter.Factory</code>并实现<code class="fe lu lv lw lx b">get</code>方法的<code class="fe lu lv lw lx b">ResponseCallAdapterFactory</code>。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ls lt l"/></div></figure><p id="4d04" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">改型将调用这个方法来尝试获得一个对应类型的<code class="fe lu lv lw lx b">CallAdapter</code>，并使用它来构造最终的返回值。</p><h1 id="2b32" class="ly lz iq bd ma mb mc md me mf mg mh mi jw mj jx mk jz ml ka mm kc mn kd mo mp bi translated">确定请求返回类型是否为回应</h1><p id="7324" class="pw-post-body-paragraph kw kx iq ky b kz mq jr lb lc mr ju le lf ms lh li lj mt ll lm ln mu lp lq lr ij bi translated">在这个<code class="fe lu lv lw lx b">get</code>方法中，你需要首先确定它是否是返回类型。我们需要处理输入的参数，否则，返回<code class="fe lu lv lw lx b">null</code>。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ls lt l"/></div></figure><p id="6250" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">上面的代码主要判断是不是挂起函数，返回值是不是我们上面说的<code class="fe lu lv lw lx b">Response</code>。此外，您需要获得特定的<code class="fe lu lv lw lx b">Response</code>类型(<code class="fe lu lv lw lx b">Response</code>被设计为可继承的)和泛型类型。</p><h1 id="ee6a" class="ly lz iq bd ma mb mc md me mf mg mh mi jw mj jx mk jz ml ka mm kc mn kd mo mp bi translated">构建CallAdapter</h1><p id="ca95" class="pw-post-body-paragraph kw kx iq ky b kz mq jr lb lc mr ju le lf ms lh li lj mt ll lm ln mu lp lq lr ij bi translated">代码按照上面的逻辑来到这里，意味着我们遇到了一个需要处理的函数。这时我们需要结合上面得到的类型，创建并返回对应的<code class="fe lu lv lw lx b">CallAdapter</code>对象。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ls lt l"/></div></figure><p id="6557" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">上面返回的<code class="fe lu lv lw lx b">ResponseCallAdapter</code>也是我们创建的类。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ls lt l"/></div></figure><p id="2660" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这个类主要用于确定处理类型和建立一个<code class="fe lu lv lw lx b">Call</code>对象。</p><h1 id="88d6" class="ly lz iq bd ma mb mc md me mf mg mh mi jw mj jx mk jz ml ka mm kc mn kd mo mp bi translated">创建响应呼叫</h1><p id="e789" class="pw-post-body-paragraph kw kx iq ky b kz mq jr lb lc mr ju le lf ms lh li lj mt ll lm ln mu lp lq lr ij bi translated"><code class="fe lu lv lw lx b">ResponseCall</code>需要继承<code class="fe lu lv lw lx b">Call</code>并设置泛型类型。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ls lt l"/></div></figure><p id="6496" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">大部分方法可以委托给<code class="fe lu lv lw lx b">delegate</code>对象，其中<code class="fe lu lv lw lx b">execute</code>会直接抛出异常，因为这里是<code class="fe lu lv lw lx b">suspend</code>函数。</p><p id="4770" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">主要逻辑还是在<code class="fe lu lv lw lx b">enqueue</code>功能里。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ls lt l"/></div></figure><p id="6b73" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">仍然首先调用delete方法的enqueue方法。<code class="fe lu lv lw lx b">Callback</code>将包含请求结束的<code class="fe lu lv lw lx b">retrofit2.Response</code>，我们将让它继续构建我们的<code class="fe lu lv lw lx b">Response</code>。</p></div><div class="ab cl mv mw hu mx" role="separator"><span class="my bw bk mz na nb"/><span class="my bw bk mz na nb"/><span class="my bw bk mz na"/></div><div class="ij ik il im in"><p id="6324" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">另外，一般情况下，服务的接口数据类型是约定不变的，即所有响应数据都有相同的<code class="fe lu lv lw lx b">ErrorEntry</code>。然后为了方便，可以定义一个具体的服务<code class="fe lu lv lw lx b">Response</code>，服务的<code class="fe lu lv lw lx b">Error</code>泛型类型就是这个<code class="fe lu lv lw lx b">ErrorEntry</code>。这就是为什么上面的<code class="fe lu lv lw lx b">Response</code>设计成<code class="fe lu lv lw lx b">open</code>的原因。</p><p id="2614" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">例如，idea的公共API具有相同的<code class="fe lu lv lw lx b">Error</code>类型。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ls lt l"/></div></figure><p id="e9e2" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们可以为概念服务定义一个<code class="fe lu lv lw lx b">NotionResponse</code>。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ls lt l"/></div></figure><h1 id="e153" class="ly lz iq bd ma mb mc md me mf mg mh mi jw mj jx mk jz ml ka mm kc mn kd mo mp bi translated">结论</h1><p id="241a" class="pw-post-body-paragraph kw kx iq ky b kz mq jr lb lc mr ju le lf ms lh li lj mt ll lm ln mu lp lq lr ij bi translated">前一段时间学Compose的时候，我拿了一个观念API，做了一个开源项目叫NotionLight(一个轻量级的观念客户端)。这篇文章的内容也是我在做这个项目的时候。遇到的问题，上面所有的代码，具体的用例也都在这个开源项目里。</p><pre class="kg kh ki kj gt nc lx nd ne aw nf bi"><span id="9062" class="ng lz iq lx b gy nh ni l nj nk"><strong class="lx ir">Want to Connect?</strong></span><span id="5d84" class="ng lz iq lx b gy nl ni l nj nk">Here's <a class="ae kv" href="https://github.com/0xZhangKe/NotionLight" rel="noopener ugc nofollow" target="_blank">my GitHub</a> to see the specific code.</span></pre></div></div>    
</body>
</html>