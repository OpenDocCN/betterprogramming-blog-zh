<html>
<head>
<title>Asynchronous Programming With Kotlin Coroutines</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">用Kotlin协程进行异步编程</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/asynchronous-programming-with-kotlin-coroutines-5b3417f53ac6?source=collection_archive---------2-----------------------#2020-08-23">https://betterprogramming.pub/asynchronous-programming-with-kotlin-coroutines-5b3417f53ac6?source=collection_archive---------2-----------------------#2020-08-23</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="01c5" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">用协程程序编写阻塞和非阻塞代码</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi ki"><img src="../Images/6e5572df44477ba4a9f67403f10a0e50.png" data-original-src="https://miro.medium.com/v2/resize:fit:1374/format:webp/1*3ljUzJlh8GJAxdMWmzq-OQ.png"/></div><p class="kq kr gj gh gi ks kt bd b be z dk translated">作者照片。</p></figure><p id="8f1f" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">Kotlin 的一个有趣特性是协程。在Android开发中，线程的管理总是有点挑战性，因为在处理与UI或主线程相关的事情上有一些限制。通常的做法是使用UI或主线程来执行与UI相关的操作，使用后台线程来阻止网络调用、数据库操作、繁重的计算任务等操作。</p><p id="8705" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">如果线程管理不当，会对应用程序的性能产生巨大影响，导致ANRs、UI冻结、崩溃等。因此，在正确的思路上做事至关重要。</p><p id="554c" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">线程管理或多线程可以通过多种方式实现。但是Kotlin协程为处理线程提供了最简单的解决方案。协程只不过是轻量级线程。它们为我们提供了一种简单的方法来进行同步和异步编程。协程允许我们在不阻塞主线程的情况下替换回调并构建主安全。</p><p id="34a5" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">让我们看看如何做到这一点。</p><p id="a18a" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated"><em class="lr">注:</em> <code class="fe ls lt lu lv b"><em class="lr">AsyncTask</em></code> <em class="lr">类在Android 11中已被弃用。Kotlin协同例程现在是异步代码的推荐解决方案。</em></p></div><div class="ab cl lw lx hx ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="im in io ip iq"><h1 id="b9e4" class="md me it bd mf mg mh mi mj mk ml mm mn jz mo ka mp kc mq kd mr kf ms kg mt mu bi translated">暂停功能的使用</h1><p id="fede" class="pw-post-body-paragraph ku kv it kw b kx mv ju kz la mw jx lc ld mx lf lg lh my lj lk ll mz ln lo lp im bi translated">让我们通过一个简单的例子来理解这一点，这个例子从一个API请求或本地数据库获取用户详细信息，并将它们显示给用户。如果我们试图通过主线程上的API调用获取细节，它会抛出一个<code class="fe ls lt lu lv b">NetworkOnMainThreadException</code>。如果我们从数据库中获取详细信息，这个操作将阻止主线程执行它的操作，直到数据被获取，导致糟糕的用户体验。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi na"><img src="../Images/025b2b9d825b9c5e06ac1b6fc76ad8aa.png" data-original-src="https://miro.medium.com/v2/resize:fit:1188/format:webp/1*okDFgjmQ8DEr9E2HlZ6LwQ.png"/></div><p class="kq kr gj gh gi ks kt bd b be z dk translated">作者照片。</p></figure><p id="24bf" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">我们可以通过在协程中使用<code class="fe ls lt lu lv b">suspend</code>函数来简单地做到这一点。<code class="fe ls lt lu lv b">suspend</code> <strong class="kw iu"> </strong>表示与该修饰符关联的方法是同步的，不会立即返回。与之关联的方法将暂停一段时间，然后在结果可用时返回结果。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nb nc l"/></div></figure><p id="b45c" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">让我们更清楚地想象一下:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi nd"><img src="../Images/2dba299f483457a2bb31b84d2b71d1f2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1036/format:webp/1*aTefeLBIe7beZ9CDWmem9g.png"/></div><p class="kq kr gj gh gi ks kt bd b be z dk translated">作者照片。</p></figure><p id="37ed" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">当一个协程被挂起时，它不是在执行。暂停了。当它恢复时，它会从停止的地方继续。当我们在主线程上调用一个<code class="fe ls lt lu lv b">suspend</code>函数时，该函数被挂起，并在任何其他工作线程上执行它的工作。一旦它完成了，它就带着结果继续运行，这样我们就可以在主线程上使用结果了。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi ne"><img src="../Images/16bc00fe07eb73aab6b6727a812eda1e.png" data-original-src="https://miro.medium.com/v2/resize:fit:952/format:webp/1*j6IokER2NnR3u59Sm9iKWQ.png"/></div><p class="kq kr gj gh gi ks kt bd b be z dk translated">作者照片。</p></figure><p id="3e12" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">但是使用<code class="fe ls lt lu lv b">suspend</code>函数有一些限制。它们既可以在协程构建器内部调用，也可以从另一个<code class="fe ls lt lu lv b">suspend</code>函数中调用。</p><p id="8d4c" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">调度程序<strong class="kw iu"> </strong>用于指定协程应该在哪个线程上执行。它们类似于Rx中的调度程序。我们可以指定希望在哪个调度程序上执行<code class="fe ls lt lu lv b">fetchUser</code> API请求(在我们的例子中，是<code class="fe ls lt lu lv b">Dispatchers.IO</code>)。我们用<code class="fe ls lt lu lv b">withContext</code>方法来说明这一点:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nb nc l"/></div></figure><p id="6807" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">一旦API请求完成，我们就可以使用<code class="fe ls lt lu lv b">Dispatchers.Main</code>在主线程上使用结果。可用不同调度程序有:</p><ul class=""><li id="a1d9" class="nf ng it kw b kx ky la lb ld nh lh ni ll nj lp nk nl nm nn bi translated"><code class="fe ls lt lu lv b">Dispatchers.Default</code> : <strong class="kw iu"> </strong>这是默认的协程调度程序，被所有协程构建器使用，如<code class="fe ls lt lu lv b">launch</code>、<code class="fe ls lt lu lv b">async</code>等。如果在其上下文中没有指定dispatcher或任何其他<code class="fe ls lt lu lv b">ContinuationInterceptor</code>。它用于在主线程之外进行CPU密集型工作的场景。</li><li id="8921" class="nf ng it kw b kx no la np ld nq lh nr ll ns lp nk nl nm nn bi translated"><code class="fe ls lt lu lv b">Dispatchers.IO</code> : <strong class="kw iu"> </strong>这个协程调度器是为处理阻塞磁盘IO操作和网络操作而设计的。该池中的其他线程会根据需要创建和关闭。</li><li id="0883" class="nf ng it kw b kx no la np ld nq lh nr ll ns lp nk nl nm nn bi translated"><code class="fe ls lt lu lv b">Dispatchers.Main</code> : <strong class="kw iu"> </strong>一个协程调度器，被限制在主线程<strong class="kw iu"> </strong>上操作UI对象。如果类路径中没有主线程调度程序，对该属性的访问可能会抛出<code class="fe ls lt lu lv b">IllegalStateException</code>。它主要用于消费来自API操作、数据库操作等的响应结果。</li></ul><p id="71d6" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">根据您的需求使用合适的调度程序。</p></div><div class="ab cl lw lx hx ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="im in io ip iq"><h1 id="84be" class="md me it bd mf mg mh mi mj mk ml mm mn jz mo ka mp kc mq kd mr kf ms kg mt mu bi translated">引擎盖下发生了什么</h1><p id="a3fd" class="pw-post-body-paragraph ku kv it kw b kx mv ju kz la mw jx lc ld mx lf lg lh my lj lk ll mz ln lo lp im bi translated">当计算可以暂停时，Kotlin编译器编写回调。协程程序调用这些回调作为延续<strong class="kw iu">。延续不过是一个普通的回调接口，里面有一些额外的信息。状态机应该是这样的:</strong></p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="nu nv di nw bf nx"><div class="gh gi nt"><img src="../Images/4f0833c24319b22d9a7d526c22cc0573.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*7Ophzeo-q-Iyv0R84oYj7w.png"/></div></div><p class="kq kr gj gh gi ks kt bd b be z dk translated">来源:<a class="ae lq" href="https://www.youtube.com/watch?v=ZTDXo0-SKuU" rel="noopener ugc nofollow" target="_blank">科特林协程101 —安卓会议讲座</a></p></figure></div><div class="ab cl lw lx hx ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="im in io ip iq"><h1 id="2697" class="md me it bd mf mg mh mi mj mk ml mm mn jz mo ka mp kc mq kd mr kf ms kg mt mu bi translated">结构化并发</h1><p id="6f1c" class="pw-post-body-paragraph ku kv it kw b kx mv ju kz la mw jx lc ld mx lf lg lh my lj lk ll mz ln lo lp im bi translated">结构化并发是协程中的一种设计模式系统，它试图解决内存泄漏问题。这有助于我们思考以下几点:</p><ol class=""><li id="8ea7" class="nf ng it kw b kx ky la lb ld nh lh ni ll nj lp ny nl nm nn bi translated">谁可以取消协程的执行？</li><li id="496b" class="nf ng it kw b kx no la np ld nq lh nr ll ns lp ny nl nm nn bi translated">协程有生命周期吗？</li><li id="a83a" class="nf ng it kw b kx no la np ld nq lh nr ll ns lp ny nl nm nn bi translated">当协程失败时，谁会得到异常？</li></ol><p id="08c6" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">结构化并发通过引入一个叫做范围的概念来管理这些事情。</p><h2 id="606c" class="nz me it bd mf oa ob dn mj oc od dp mn ld oe of mp lh og oh mr ll oi oj mt ok bi translated">协程范围</h2><p id="4a78" class="pw-post-body-paragraph ku kv it kw b kx mv ju kz la mw jx lc ld mx lf lg lh my lj lk ll mz ln lo lp im bi translated">一个<code class="fe ls lt lu lv b">CoroutineScope</code>是<a class="ae lq" href="https://kotlin.github.io/kotlinx.coroutines/" rel="noopener ugc nofollow" target="_blank"> kotlinx.coroutines </a>包中的一个接口。</p><ol class=""><li id="1385" class="nf ng it kw b kx ky la lb ld nh lh ni ll nj lp ny nl nm nn bi translated">它跟踪协程。</li><li id="956e" class="nf ng it kw b kx no la np ld nq lh nr ll ns lp ny nl nm nn bi translated">它提供了取消<strong class="kw iu"> </strong>协程的能力。</li><li id="f601" class="nf ng it kw b kx no la np ld nq lh nr ll ns lp ny nl nm nn bi translated">无论何时发生故障，它都会得到通知。</li></ol><p id="b920" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">协程作用域只不过是一个非常容易创建的变量。它不会包含任何重物的参照物。因此，每当我们想要控制协程生命周期时，我们都需要创建一个作用域。它可以很容易地创建如下:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nb nc l"/></div></figure><p id="a453" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">现在，上面使用<code class="fe ls lt lu lv b">launch</code> <strong class="kw iu"> </strong>协程生成器创建的协程将遵循作用域的生命周期。如果出现任何异常，将会传达给范围，以便我们可以处理它。在许多情况下，当用户在网络请求正在进行时退出屏幕，我们需要取消所有正在进行的请求。所以在<code class="fe ls lt lu lv b">ViewModel</code>、<code class="fe ls lt lu lv b">onCleared()</code>、<strong class="kw iu">、</strong>回调中，或者在<code class="fe ls lt lu lv b">onDestroy()</code>回调活动中，我们可以取消作用域，让所有的协程停止执行。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nb nc l"/></div></figure><p id="6bfd" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">取消范围意味着:</p><ol class=""><li id="3bd2" class="nf ng it kw b kx ky la lb ld nh lh ni ll nj lp ny nl nm nn bi translated">它取消它启动的所有子协程。</li><li id="c726" class="nf ng it kw b kx no la np ld nq lh nr ll ns lp ny nl nm nn bi translated">我们不能用这个范围启动更多的协程。</li></ol><h2 id="cd33" class="nz me it bd mf oa ob dn mj oc od dp mn ld oe of mp lh og oh mr ll oi oj mt ok bi translated">处理协程范围的异常</h2><p id="c8f6" class="pw-post-body-paragraph ku kv it kw b kx mv ju kz la mw jx lc ld mx lf lg lh my lj lk ll mz ln lo lp im bi translated">作用域还将作业<strong class="kw iu"> </strong>作为参数。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nb nc l"/></div></figure><p id="ae5f" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">作业可以用来定义作用域和协程的生命周期。如果我们将一个作业传递给作用域，它将以特定的方式处理异常。当有多个子范围与该范围相关联时:</p><ul class=""><li id="1387" class="nf ng it kw b kx ky la lb ld nh lh ni ll nj lp nk nl nm nn bi translated">如果任何一个孩子失败了，它会把异常传播给其他孩子。</li><li id="d382" class="nf ng it kw b kx no la np ld nq lh nr ll ns lp nk nl nm nn bi translated">当通知失败时，作用域将取消自身并向上传播异常。</li></ul><p id="717d" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">在大多数失败的情况下，停止其他子进程并抛出异常并不理想，通常会导致崩溃。对于这些情况，我们需要使用一个<code class="fe ls lt lu lv b">SupervisorJob</code> <strong class="kw iu">。</strong></p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nb nc l"/></div></figure><p id="d363" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">当我们使用一个<code class="fe ls lt lu lv b">SupervisorJob</code>时，它不会停止相同作用域上其他子进程的执行。当通知失败时，作用域什么也不做。由于异常可能会向上传播，为了安全起见，我们可能必须在代码中使用<code class="fe ls lt lu lv b">try/catch</code>块。</p><p id="9415" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">我将写一篇关于处理协程、作用域等异常的文章。</p></div><div class="ab cl lw lx hx ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="im in io ip iq"><h1 id="27f8" class="md me it bd mf mg mh mi mj mk ml mm mn jz mo ka mp kc mq kd mr kf ms kg mt mu bi translated">如何创建协程</h1><p id="6a87" class="pw-post-body-paragraph ku kv it kw b kx mv ju kz la mw jx lc ld mx lf lg lh my lj lk ll mz ln lo lp im bi translated">我们可以使用现有的协程构建器来创建协程。我们通常使用两个:</p><ol class=""><li id="ce6e" class="nf ng it kw b kx ky la lb ld nh lh ni ll nj lp ny nl nm nn bi translated"><code class="fe ls lt lu lv b">launch</code></li><li id="5bfb" class="nf ng it kw b kx no la np ld nq lh nr ll ns lp ny nl nm nn bi translated"><code class="fe ls lt lu lv b">async</code></li></ol><h2 id="ec5f" class="nz me it bd mf oa ob dn mj oc od dp mn ld oe of mp lh og oh mr ll oi oj mt ok bi translated">发动</h2><p id="1e67" class="pw-post-body-paragraph ku kv it kw b kx mv ju kz la mw jx lc ld mx lf lg lh my lj lk ll mz ln lo lp im bi translated"><code class="fe ls lt lu lv b">launch{}</code> <strong class="kw iu"> </strong>是一个协程生成器，用于创建一个新的一次性协程。<code class="fe ls lt lu lv b">launch</code>函数创建一个协程并立即返回。但是，工作在后台线程池中继续进行。它启动并忘记了协程。它通常用在不需要返回值的时候。例如，如果我们想上传一些东西到服务器，我们不关心结果:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nb nc l"/></div></figure><h2 id="57b5" class="nz me it bd mf oa ob dn mj oc od dp mn ld oe of mp lh og oh mr ll oi oj mt ok bi translated"><strong class="ak">异步</strong></h2><p id="91b9" class="pw-post-body-paragraph ku kv it kw b kx mv ju kz la mw jx lc ld mx lf lg lh my lj lk ll mz ln lo lp im bi translated"><code class="fe ls lt lu lv b">async{}</code> <strong class="kw iu"> </strong>是一个协程构建器，它创建一个新的协程，用于预期返回值的情况。例如，让我们考虑上面从API调用获取用户数据的例子:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nb nc l"/></div></figure><p id="2a42" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated"><code class="fe ls lt lu lv b">async</code>将返回延期对象。我们在延迟对象上调用<code class="fe ls lt lu lv b">await()</code>，所以<code class="fe ls lt lu lv b">await</code>将等待，暂停协程的执行，直到<code class="fe ls lt lu lv b">async</code>完成它的计算，并返回协程的值。</p><h2 id="67c1" class="nz me it bd mf oa ob dn mj oc od dp mn ld oe of mp lh og oh mr ll oi oj mt ok bi translated">比较</h2><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="nu nv di nw bf nx"><div class="gh gi ol"><img src="../Images/0f637a14b484cc86e3fae96ce58c562e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*TkShLSq-VtGm8I5rGz11vQ.png"/></div></div><p class="kq kr gj gh gi ks kt bd b be z dk translated">来源:<a class="ae lq" href="https://www.youtube.com/watch?v=ZTDXo0-SKuU" rel="noopener ugc nofollow" target="_blank">参考:科特林协程101 —安卓会议讲座</a></p></figure><p id="1467" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated"><code class="fe ls lt lu lv b">launch</code>和<code class="fe ls lt lu lv b">async</code>不是<code class="fe ls lt lu lv b">suspend</code>功能。它们是协程的入口点。我们可以将它们视为作用域之上的扩展函数。</p></div><div class="ab cl lw lx hx ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="im in io ip iq"><h1 id="e11b" class="md me it bd mf mg mh mi mj mk ml mm mn jz mo ka mp kc mq kd mr kf ms kg mt mu bi translated">外卖食品</h1><ul class=""><li id="6b07" class="nf ng it kw b kx mv la mw ld om lh on ll oo lp nk nl nm nn bi translated">除非需要，否则不要标记函数<code class="fe ls lt lu lv b">suspend</code>。</li><li id="cf5e" class="nf ng it kw b kx no la np ld nq lh nr ll ns lp nk nl nm nn bi translated">检查读取文件等繁重计算操作中的<code class="fe ls lt lu lv b">yield</code>或<code class="fe ls lt lu lv b">ensureActive</code>方法，以便每当取消协程并调用该函数时，它将停止该协程的执行。</li><li id="d4de" class="nf ng it kw b kx no la np ld nq lh nr ll ns lp nk nl nm nn bi translated">处理异常。否则可能会导致app崩溃。</li></ul></div><div class="ab cl lw lx hx ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="im in io ip iq"><h1 id="03e4" class="md me it bd mf mg mh mi mj mk ml mm mn jz mo ka mp kc mq kd mr kf ms kg mt mu bi translated">摘要</h1><p id="9840" class="pw-post-body-paragraph ku kv it kw b kx mv ju kz la mw jx lc ld mx lf lg lh my lj lk ll mz ln lo lp im bi translated">您现在应该了解什么是协程及其基本用法。在我接下来的文章中，我们将了解更多关于这些协程、作用域和异常处理的内容。</p><p id="eaf2" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">还有，我从下面提到的参考资料中学到了很多东西。别忘了去看看。</p></div><div class="ab cl lw lx hx ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="im in io ip iq"><h1 id="acee" class="md me it bd mf mg mh mi mj mk ml mm mn jz mo ka mp kc mq kd mr kf ms kg mt mu bi translated">参考</h1><ul class=""><li id="ace6" class="nf ng it kw b kx mv la mw ld om lh on ll oo lp nk nl nm nn bi translated"><a class="ae lq" href="https://www.youtube.com/watch?v=ZTDXo0-SKuU" rel="noopener ugc nofollow" target="_blank">科特林协同程序101 —安卓会议讲座</a></li><li id="43f1" class="nf ng it kw b kx no la np ld nq lh nr ll ns lp nk nl nm nn bi translated"><a class="ae lq" href="https://www.youtube.com/watch?v=BOHK_w09pVA" rel="noopener ugc nofollow" target="_blank">了解Android上的Kotlin协同程序(Google I/O’19)</a></li><li id="1b06" class="nf ng it kw b kx no la np ld nq lh nr ll ns lp nk nl nm nn bi translated"><a class="ae lq" href="https://www.youtube.com/watch?v=_hfBv0a09Jc" rel="noopener ugc nofollow" target="_blank">KotlinConf 2017—Roman Eliza ROV的协程介绍</a></li><li id="7e42" class="nf ng it kw b kx no la np ld nq lh nr ll ns lp nk nl nm nn bi translated"><a class="ae lq" href="https://kotlinlang.org/docs/reference/coroutines/basics.html#extract-function-refactoring" rel="noopener ugc nofollow" target="_blank">协程基础知识</a></li></ul></div></div>    
</body>
</html>