<html>
<head>
<title>Policy As Code on Kubernetes With Kyverno</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Kubernetes与Kyverno的政策代码</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/policy-as-code-on-kubernetes-with-kyverno-b144749f144?source=collection_archive---------1-----------------------#2020-11-06">https://betterprogramming.pub/policy-as-code-on-kubernetes-with-kyverno-b144749f144?source=collection_archive---------1-----------------------#2020-11-06</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="6d0d" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">通过CRD为您的组织实施Kubernetes最佳实践</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/166b4742d34e2cbfa00eae1a1d6994bb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*zaTs-8Hmun5g0XGb"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated"><a class="ae ky" href="https://unsplash.com/@dnevozhai?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Denys Nevozhai </a>在<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍照。</p></figure><p id="e5ee" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">Kubernetes已经能够通过允许人们大规模运行分布式应用程序来彻底改变云原生生态系统。尽管Kubernetes是一个功能丰富且健壮的容器编排平台，但它也有自己的复杂性。在多个团队一起工作的情况下大规模管理Kubernetes并不容易，确保人们做正确的事情并且不越线也很难管理。</p><p id="1b2a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">Kyverno 正是解决这一问题的合适工具。它是一个开源的Kubernetes-native策略引擎，帮助您使用简单的Kubernetes清单定义策略。它可以验证、变异和生成Kubernetes资源。因此，它可以允许组织定义和执行策略，以便开发人员和管理员保持一定的标准。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="b338" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">Kyverno是如何工作的？</h1><p id="9964" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">Kyverno的工作原理是使用一个动态准入控制器，它检查你通过Kubectl发送到Kube API服务器的每一个请求。如果请求与策略匹配，Kyverno就应用它。否则，它用定义的消息拒绝请求。</p><p id="3f45" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">因此，这使得Kyverno能够提供以下功能:</p><ul class=""><li id="3ae6" class="mz na it lb b lc ld lf lg li nb lm nc lq nd lu ne nf ng nh bi translated">检查CPU和内存限制。</li><li id="8005" class="mz na it lb b lc ni lf nj li nk lm nl lq nm lu ne nf ng nh bi translated">确保用户不会更改默认网络策略。</li><li id="9766" class="mz na it lb b lc ni lf nj li nk lm nl lq nm lu ne nf ng nh bi translated">检查资源名称是否与特定模式匹配。</li><li id="3e0d" class="mz na it lb b lc ni lf nj li nk lm nl lq nm lu ne nf ng nh bi translated">确保特定的资源总是包含特定的标签。</li><li id="1524" class="mz na it lb b lc ni lf nj li nk lm nl lq nm lu ne nf ng nh bi translated">拒绝对特定资源的删除和更改。</li><li id="bbb5" class="mz na it lb b lc ni lf nj li nk lm nl lq nm lu ne nf ng nh bi translated">如果图像标签为<code class="fe nn no np nq b">latest</code>，自动将<code class="fe nn no np nq b">imagePullPolicy</code>更改为<code class="fe nn no np nq b">Always</code>。</li><li id="1e8f" class="mz na it lb b lc ni lf nj li nk lm nl lq nm lu ne nf ng nh bi translated">为每个新命名空间生成默认网络策略。</li></ul><p id="512e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">Kyverno使用自定义资源定义来定义策略，编写策略就像使用kubectl应用策略一样简单。</p><p id="f0d9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">Kyverno提供了三个主要功能:</p><ul class=""><li id="b47e" class="mz na it lb b lc ld lf lg li nb lm nc lq nd lu ne nf ng nh bi translated">确认</li><li id="97a8" class="mz na it lb b lc ni lf nj li nk lm nl lq nm lu ne nf ng nh bi translated">变化</li><li id="2546" class="mz na it lb b lc ni lf nj li nk lm nl lq nm lu ne nf ng nh bi translated">产生</li></ul><p id="6472" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们来看看每个清单的例子。</p><h2 id="b5ed" class="nr md it bd me ns nt dn mi nu nv dp mm li nw nx mo lm ny nz mq lq oa ob ms oc bi translated">确认</h2><p id="9844" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">一个很好的用例是确保所有的pod都应该有一个资源请求和限制集。下面的例子很好地解释了这一点:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="od oe l"/></div></figure><p id="4e12" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">虽然大部分是不言自明的，但是<code class="fe nn no np nq b">validationFailureAction</code>指定了是强制执行这个需求(通过使用<code class="fe nn no np nq b">enforce</code>)还是仅仅审计它(通过使用<code class="fe nn no np nq b">audit</code>)并报告违规。</p><h2 id="6422" class="nr md it bd me ns nt dn mi nu nv dp mm li nw nx mo lm ny nz mq lq oa ob ms oc bi translated">变化</h2><p id="0cd9" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">突变意味着改变资源，如果它们符合特定的场景。一个很好的例子是，如果图像标签是<code class="fe nn no np nq b">latest</code>，将<code class="fe nn no np nq b">imagePullPolicy</code>改为<code class="fe nn no np nq b">Always</code>。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="od oe l"/></div></figure><h2 id="f78d" class="nr md it bd me ns nt dn mi nu nv dp mm li nw nx mo lm ny nz mq lq oa ob ms oc bi translated">产生</h2><p id="7801" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">顾名思义，生成针对特定事件的资源。例如，如果有人创建了一个新的名称空间，我们可能希望实施一个默认的网络策略。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="od oe l"/></div></figure></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="24d7" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">亲自动手</h1><p id="8a5b" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">现在让我们动手看看Kyverno的实际操作。我们将安装Kyverno，然后应用一个验证策略来检查特定的标签。如果标签不存在，Kyverno将拒绝该请求。否则，它将应用它。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="ff28" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">先决条件</h1><p id="b8ab" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">对于先决条件，我们需要一个功能性的Kubernetes集群。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="df54" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">安装Kyverno</h1><p id="bd67" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">安装Kyverno很简单。您可以应用GitHub上的Kyverno Kubernetes清单，也可以安装最新的舵图。</p><h2 id="16f5" class="nr md it bd me ns nt dn mi nu nv dp mm li nw nx mo lm ny nz mq lq oa ob ms oc bi translated">使用清单</h2><pre class="kj kk kl km gt of nq og oh aw oi bi"><span id="58d3" class="nr md it nq b gy oj ok l ol om">kubectl create -f https://raw.githubusercontent.com/kyverno/kyverno/master/definitions/release/install.yaml</span></pre><h2 id="a375" class="nr md it bd me ns nt dn mi nu nv dp mm li nw nx mo lm ny nz mq lq oa ob ms oc bi translated">使用舵图</h2><pre class="kj kk kl km gt of nq og oh aw oi bi"><span id="8a55" class="nr md it nq b gy oj ok l ol om">helm repo add kyverno https://kyverno.github.io/kyverno/<br/>kubectl create ns kyverno<br/>helm install kyverno --namespace kyverno kyverno/kyverno</span></pre><p id="f59d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">要检查我们是否成功安装了Kyverno，请列出<code class="fe nn no np nq b">kyverno</code>名称空间中的所有资源:</p><pre class="kj kk kl km gt of nq og oh aw oi bi"><span id="f759" class="nr md it nq b gy oj ok l ol om"># kubectl get all -n kyverno<br/>NAME                           READY   STATUS    RESTARTS   AGE<br/>pod/kyverno-5f7769d697-x8lkj   0/1     Running   0          21s</span><span id="e327" class="nr md it nq b gy on ok l ol om">NAME                  TYPE        CLUSTER-IP    EXTERNAL-IP   PORT(S)   AGE<br/>service/kyverno-svc   ClusterIP   10.96.167.8   &lt;none&gt;        443/TCP   21s</span><span id="2463" class="nr md it nq b gy on ok l ol om">NAME                      READY   UP-TO-DATE   AVAILABLE   AGE<br/>deployment.apps/kyverno   0/1     1            0           21s</span><span id="8f4a" class="nr md it nq b gy on ok l ol om">NAME                                 DESIRED   CURRENT   READY   AGE<br/>replicaset.apps/kyverno-5f7769d697   1         1         0       21s</span></pre></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="230f" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">应用策略</h1><p id="b121" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">现在我们到了政策部分。让我们应用一个策略，确保所有的pod都包含一个名为<code class="fe nn no np nq b">app</code>的标签。创建一个名为<code class="fe nn no np nq b">require-app-label.yaml</code>的文件，内容如下:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="od oe l"/></div></figure><p id="664d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果您查看YAML，我们会看到有一个匹配部分，其中包含我们应该匹配的资源种类。在这个场景中，我们看到一个pod。validate部分定义了如果验证失败我们应该输出的消息，以及解释我们需要匹配什么的模式。</p><p id="3729" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">由于这是一个CRD，我们可以直接应用它并获得想要的结果:</p><pre class="kj kk kl km gt of nq og oh aw oi bi"><span id="9e4e" class="nr md it nq b gy oj ok l ol om">kubectl apply -f <!-- -->require-app-label.yaml</span></pre></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="4e6f" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">测试</h1><p id="9999" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">所以是时候做些测试了！让我们创建一个没有标签的pod，看看我们会得到什么:</p><pre class="kj kk kl km gt of nq og oh aw oi bi"><span id="de87" class="nr md it nq b gy oj ok l ol om">kubectl run nginx --image=nginx</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi oo"><img src="../Images/b9e0a392c3cb03f7ed001ef0a10a9b82.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*XikWWRJWy22l3C6Xoa455Q.gif"/></div></div></figure><p id="7478" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">正如我们所见，验证失败的原因如下:</p><pre class="kj kk kl km gt of nq og oh aw oi bi"><span id="761d" class="nr md it nq b gy oj ok l ol om">Error from server: admission webhook "nirmata.kyverno.resource.validating-webhook" denied the request:</span><span id="7531" class="nr md it nq b gy on ok l ol om">resource Deployment/default/nginx was blocked due to the following policies</span><span id="dc64" class="nr md it nq b gy on ok l ol om">require-app-label:<br/>  autogen-check-for-app-label: 'Validation error: label `app` is required; Validation rule autogen-check-for-app-label failed at path /spec/template/metadata/labels/app/'</span></pre><p id="0614" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这和预期的一样，因为我们还没有提供标签。现在让我们试试标签<code class="fe nn no np nq b">name=nginx</code>:</p><pre class="kj kk kl km gt of nq og oh aw oi bi"><span id="49e4" class="nr md it nq b gy oj ok l ol om">kubectl run nginx --image=nginx --labels="name=nginx" --generator=run-pod/v1</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi op"><img src="../Images/c0fe3b433cd398973d01f0cff1074769.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*IXUDk4CKhM5CXDvAghveKw.gif"/></div></div></figure><p id="c287" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这个也失败了，因为应用程序标签仍然丢失。让我们创建一个标签为<code class="fe nn no np nq b">app=nginx</code>的NGINX pod:</p><pre class="kj kk kl km gt of nq og oh aw oi bi"><span id="7e7e" class="nr md it nq b gy oj ok l ol om">kubectl run nginx --image=nginx --labels="app=nginx" --generator=run-pod/v1</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi oq"><img src="../Images/5149db88275c9a39c5a7e76f739210d3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*RdoCCduBGYTY6_Z4fy2-zw.gif"/></div></div></figure><p id="5275" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如我们所见，pod创建成功。现在，让我们使用kubectl来获取pod和标签:</p><pre class="kj kk kl km gt of nq og oh aw oi bi"><span id="6041" class="nr md it nq b gy oj ok l ol om">kubectl get pod nginx --show-labels</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi or"><img src="../Images/e73d6d94e0446e5b1f6884ad875f3a75.png" data-original-src="https://miro.medium.com/v2/resize:fit:1244/1*eJh0opcCabwmW2bCJQVK0g.gif"/></div></figure><p id="8aa6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">pod正在运行并包含<code class="fe nn no np nq b">app=nginx</code>标签。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="2277" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">结论</h1><p id="4573" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">Kyverno是一个优秀的政策代码工具，在组织层面上执行最佳实践时非常强大。因为它是Kubernetes-native，所以编写和操作都很简单，不需要专业开发人员来维护。</p><p id="7037" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">感谢阅读！我希望你喜欢这篇文章。</p></div></div>    
</body>
</html>