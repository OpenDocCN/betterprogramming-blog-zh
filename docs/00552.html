<html>
<head>
<title>Managing IPFS Image Uploads With Angular NgRx v8</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用Angular NgRx v8管理IPFS图像上传</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/manage-the-ipfs-image-uploading-with-angular-ngrx-v8-61aaaf0be0d5?source=collection_archive---------5-----------------------#2019-06-08">https://betterprogramming.pub/manage-the-ipfs-image-uploading-with-angular-ngrx-v8-61aaaf0be0d5?source=collection_archive---------5-----------------------#2019-06-08</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="4e19" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">本系列的第三部分展示了我们如何为<strong class="ak"> FleaMarket </strong>智能合约构建NgRx供电的DApp</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/802c1985ff08788600bd7ca60cf732c0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*tbaimo5WnqOEwCggVLi84A.jpeg"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">图片来自<a class="ae ky" href="https://pixabay.com/?utm_source=link-attribution&amp;utm_medium=referral&amp;utm_campaign=image&amp;utm_content=2750995" rel="noopener ugc nofollow" target="_blank"> Pixabay </a>的<a class="ae ky" href="https://pixabay.com/users/KELLEPICS-4893063/?utm_source=link-attribution&amp;utm_medium=referral&amp;utm_campaign=image&amp;utm_content=2750995" rel="noopener ugc nofollow" target="_blank">斯蒂芬·凯勒</a></p></figure><p id="98e7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这篇文章是我们的博客系列第二部分的延续，在那里我们演示了如何将我们的DApp连接到运行在Infura上的IPFS节点。在本文中，我们将重点关注由NgRx支持的IPFS图像上传功能的编码。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="26fa" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">更新到8️版本</h1><p id="dec8" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">首先将我们的FleaMarketDApp项目升级到最新的Angular版本v8。</p><p id="2362" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe mz na nb nc b">ng update @angular/cli @angular/core @angular/material</code></p><p id="30fc" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们希望确保使用Node.js版本12或更高版本，并安装必要的工具来编译本地节点模块。</p><p id="2e0d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们还需要将NgRx库更新到它的最新版本v8。</p><p id="ccd9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">为了启用惰性路由的动态导入，我们必须在<code class="fe mz na nb nc b">tsconfig.json</code>文件中将<code class="fe mz na nb nc b">module</code>编译属性设置为值<code class="fe mz na nb nc b">esnext</code>:</p><pre class="kj kk kl km gt nd nc ne nf aw ng bi"><span id="195f" class="nh md it nc b gy ni nj l nk nl">"compilerOptions": {<br/>  "baseUrl": "./",<br/>  "outDir": "./dist/out-tsc",<br/>  "sourceMap": true,<br/> <strong class="nc iu"> "module": "esnext",</strong><br/>   ....</span></pre><p id="8297" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这个版本中包含的一个很酷的<a class="ae ky" href="https://next.ngrx.io/guide/migration/v8" rel="noopener ugc nofollow" target="_blank">特性</a>是所有的特效在出错时会自动恢复。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="3f04" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">IPFS属地</h1><p id="2d73" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">为了与IPFS网络交互，我们需要安装<a class="ae ky" href="https://github.com/ipfs/js-ipfs-http-client" rel="noopener ugc nofollow" target="_blank"> IPFS HTTP客户端库</a>:</p><pre class="kj kk kl km gt nd nc ne nf aw ng bi"><span id="0daa" class="nh md it nc b gy ni nj l nk nl">npm install <!-- -->ipfs-http-client</span></pre><p id="768b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们需要创建一个定制的Webpack配置文件来告诉Angular在编译中包含加密的<code class="fe mz na nb nc b">node</code>模块。首先安装自定义Webpack生成器:</p><p id="0b21" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe mz na nb nc b">npm install -save-dev @angular-builders/custom-webpack</code></p><p id="c97e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><em class="nm">* * *注意:在Angular v8中我们不再需要安装</em> <code class="fe mz na nb nc b"><em class="nm">@angular-builders/dev-server</em></code> <em class="nm">包⚠️*** </em></p><p id="3ae4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">然后，我们使用以下上下文向项目添加一个<code class="fe mz na nb nc b">extra-webpack.config.js</code>文件:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nn no l"/></div></figure><p id="7136" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们修改了<code class="fe mz na nb nc b">angular.js</code>文件以包含定制构建器:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nn no l"/></div></figure></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="e22e" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">IPFS文件上传服务</h1><p id="81ad" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">让我们创建一个服务<code class="fe mz na nb nc b">IpfsDaemonService</code>，它将处理从IPFS Infura网络上传和检索文件的逻辑:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nn no l"/></div></figure><p id="7ec0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在服务构造函数中，注入实例化全局对象<code class="fe mz na nb nc b">IpfsHttpClient</code>的<code class="fe mz na nb nc b">ipfsToken</code>，该全局对象负责连接到Infura运行的IPFS节点:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nn no l"/></div></figure><p id="be68" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在服务的第一个方法中，我们向IPFS添加一个图像文件。它接受文件对象及其名称，并在成功执行后返回存储文件的散列。第二种方法是从IPFS读取图像文件。它接受散列参数并返回图像blob对象。</p><p id="178e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们将原始缓冲流编码为base64编码的字符串。然后我们通过使用<code class="fe mz na nb nc b">HttpClient</code>和设置为“blob”的<code class="fe mz na nb nc b">responseType</code>选项来等待图像blob被返回。布莱恩·洛夫的这个<a class="ae ky" href="https://brianflove.com/2017/11/02/angular-http-client-blob/" rel="noopener ugc nofollow" target="_blank">想法</a>值得称赞。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="b73e" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">播种功能模块</h1><p id="c7bc" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">IPFS文件上传逻辑负责存储和检索卖方的产品图像。图像文件的散列码存储在<code class="fe mz na nb nc b">SafeRemotePurchase </code>智能契约的<code class="fe mz na nb nc b">ipfsHash</code>状态变量中。将该功能捆绑到功能模块<code class="fe mz na nb nc b">SellerBoothModule.</code>中是很自然的</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nn no l"/></div></figure><p id="9e02" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在上面的代码中，我们使用新的<code class="fe mz na nb nc b">import()</code>语法来声明惰性加载路径。这个功能是Angular v8中引入的。</p><p id="5eff" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在让我们把注意力转向在特征模块<code class="fe mz na nb nc b">SellerBoothModule</code>中注册的组件<code class="fe mz na nb nc b">PurchaseContractComponent</code>:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nn no l"/></div></figure><p id="0558" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这是一个智能组件，除了其他功能之外，它还为以下各项提供用户界面:</p><ul class=""><li id="2162" class="nr ns it lb b lc ld lf lg li nt lm nu lq nv lu nw nx ny nz bi translated">图像预览</li><li id="1a5a" class="nr ns it lb b lc oa lf ob li oc lm od lq oe lu nw nx ny nz bi translated">上传图像到IPFS</li><li id="1e42" class="nr ns it lb b lc oa lf ob li oc lm od lq oe lu nw nx ny nz bi translated">基于散列码从IPFS检索图像文件</li></ul><p id="e59a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们进一步看看其中的每一项。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="b8d6" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">图像预览</h1><p id="8854" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">该组件的模板包括按钮“<em class="nm">选择产品图片</em>”，让我们在上传到IPFS之前预览图片。为了连接预览逻辑，我们使用角度材料反应上传表单。图像文件存储在组件变量<code class="fe mz na nb nc b">fileBlob</code>中。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi of"><img src="../Images/f0e973f1dbe0fdcae81b16e22554b98a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*rVVy1P5g_-_9PqKSwyN_bg.jpeg"/></div></div></figure></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="17fd" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">将图像文件上传到IPFS</h1><p id="c39b" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">由我们的特征库管理的状态接口定义如下:</p><pre class="kj kk kl km gt nd nc ne nf aw ng bi"><span id="206d" class="nh md it nc b gy ni nj l nk nl">export interface State {<br/>   status: FileUploadStatus;<br/>   ipfsHash: string | null;<br/>   imageBlob?: Blob;<br/>}</span></pre><p id="51ed" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">要启动上传过程，用户需要点击标记为<em class="nm">“上传到IPFS”</em>的按钮，在我们选择图像文件后，哪个<em class="nm"> </em>会变为活动状态。这触发了存储动作类型<code class="fe mz na nb nc b">[IPFS/Image] Upload</code>，该类型在其有效负载中携带变量<code class="fe mz na nb nc b">fileBlob</code>的值。该动作将被分派到专用商店效果<code class="fe mz na nb nc b">uploadFile$</code>，该商店效果只监听这种类型的动作:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nn no l"/></div></figure><p id="9336" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们仔细看看这个效果里面的逻辑。我们使用<code class="fe mz na nb nc b">exhaustMap </code>操作符从动作负载中接收<code class="fe mz na nb nc b">File</code>对象。在这种情况下，使用这个映射操作符的优点是，它将忽略后续的文件上载请求，而当前的请求仍在进行中。然后，我们将该值传递给<code class="fe mz na nb nc b">IpfsDaemonService.</code>中的<code class="fe mz na nb nc b">addFile</code>方法。在成功执行该方法后，我们使用<code class="fe mz na nb nc b">map </code>操作符将接收到的哈希值投射到<code class="fe mz na nb nc b">[IPFS/Image] Upload Success</code>动作。该操作将触发由我们的功能存储管理的以下事件链:</p><ol class=""><li id="fb70" class="nr ns it lb b lc ld lf lg li nt lm nu lq nv lu og nx ny nz bi translated">携带IPFS映像散列有效载荷的动作被分派给相应的缩减器</li><li id="504f" class="nr ns it lb b lc oa lf ob li oc lm od lq oe lu og nx ny nz bi translated">减速器将用新值更新状态属性<code class="fe mz na nb nc b">ipfsHash</code>和<code class="fe mz na nb nc b">status</code></li><li id="c473" class="nr ns it lb b lc oa lf ob li oc lm od lq oe lu og nx ny nz bi translated">观察这些状态变化的存储选择器将设法相应地更新组件模板</li></ol><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi oh"><img src="../Images/b88974f67167e76afb7a8c7f7b8977b7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*LPD1ookiKWbvZvCOcJNztg.jpeg"/></div></div></figure></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="b589" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">从IPFS检索图像</h1><p id="5524" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">一旦产品图片上传到IPFS网络上，我们想确保我们可以使用它的散列来检索它。</p><p id="4457" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们的智能模板组件中有一个按钮，当<code class="fe mz na nb nc b">ipfsHash$</code>选择器发出一个哈希值时，该按钮变得可见。让我们看看当我们点击它时会发生什么:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi oi"><img src="../Images/7aac626fda1362ec523562ae788b7406.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*TxxsfB19qBb5oVBXFLqAvw.jpeg"/></div></div></figure><p id="b88c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">点击按钮触发组件<code class="fe mz na nb nc b">ShowIpfsImageComponent</code>中定义的材料对话框:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nn no l"/></div></figure><p id="35d2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在组件内部，我们声明了返回blob observable的方法<code class="fe mz na nb nc b">checkStore</code>。该方法检查状态属性<code class="fe mz na nb nc b">imageBlog</code>的<code class="fe mz na nb nc b">getImageBlob</code>选择器。如果该值尚未设置，该方法将分派<code class="fe mz na nb nc b">'[IPFS/Image] Load Image'</code>动作来将请求广播到效果<code class="fe mz na nb nc b">loadFile$</code>:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nn no l"/></div></figure><p id="a334" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">hash属性的当前值从存储中取出，并作为参数传递给服务方法<code class="fe mz na nb nc b">getFile</code>。该方法使用从IPFS节点检索的<code class="fe mz na nb nc b">image: Blob</code>值进行解析。然后我们将它送回商店。减速器相应地更新状态属性<code class="fe mz na nb nc b">imageBlob </code>。新值将立即被<code class="fe mz na nb nc b">getImageBlob </code>选择器拾取，并首先使用<code class="fe mz na nb nc b">checkStore</code>方法，然后使用<code class="fe mz na nb nc b">tap</code>操作符通过管道向下传递:</p><pre class="kj kk kl km gt nd nc ne nf aw ng bi"><span id="702d" class="nh md it nc b gy ni nj l nk nl">this.image$ = this.checkStore().pipe(<br/>   tap((blob) =&gt;<br/>this.image.nativeElement.src =          this.windowRef.URL.createObjectURL(blob)));</span></pre><p id="5946" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在操作符<code class="fe mz na nb nc b">tap</code>中，我们使用模板引用变量<code class="fe mz na nb nc b">#ipfsImage</code>将斑点图像连接到模板<code class="fe mz na nb nc b">&lt;img&gt;</code>本地元素中。</p><p id="dbac" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这种方法的最大好处是，我们现在可以控制从IPFS节点接收的图像二进制流。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="430e" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">结论</h1><p id="cbb9" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">🐯谢谢大家！<strong class="lb iu"> </strong>请继续关注本博客系列的其他作品。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="1ff1" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">参考</h1><ul class=""><li id="92de" class="nr ns it lb b lc mu lf mv li oj lm ok lq ol lu nw nx ny nz bi translated"><a class="ae ky" href="https://www.amazon.com/dp/B085B918LG" rel="noopener ugc nofollow" target="_blank">建筑以太坊DApp用有角的、有角的材料和NgRx </a>，<em class="nm">可用</em><a class="ae ky" href="http://www.amazon.co.uk/kindlestore" rel="noopener ugc nofollow" target="_blank"><em class="nm">http://www.amazon.co.uk/kindlestore</em></a><em class="nm">2020年3月5日</em>)作者<a class="np nq ep" href="https://medium.com/u/4f27e57aa12a?source=post_page-----61aaaf0be0d5--------------------------------" rel="noopener" target="_blank"> Alex Yevseyevich </a></li></ul></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><p id="aa22" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我用于商品图片的那套图标是由<a class="ae ky" href="https://www.flaticon.com/" rel="noopener ugc nofollow" target="_blank">www.flaticon.com</a>的<a class="ae ky" href="https://www.flaticon.com/authors/eucalyp" rel="noopener ugc nofollow" target="_blank">桉树</a>制作的，由授权<a class="ae ky" href="http://creativecommons.org/licenses/by/3.0/" rel="noopener ugc nofollow" target="_blank"> CC 3.0</a></p><p id="1d8a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">👍特别感谢我的儿子丹尼尔·叶夫谢维奇审阅了这篇文章。</p></div></div>    
</body>
</html>