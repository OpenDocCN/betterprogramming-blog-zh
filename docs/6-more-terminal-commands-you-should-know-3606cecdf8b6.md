# 您应该知道的另外 6 个终端命令

> 原文：<https://betterprogramming.pub/6-more-terminal-commands-you-should-know-3606cecdf8b6>

## 来自/usr/bin 深处的另一轮巧妙命令

![](img/43540378f665d7321e0e8e9548a18f92.png)

Joan Gamell 在 [Unsplash](https://unsplash.com/s/photos/code?utm_source=unsplash&utm_medium=referral&utm_content=creditCopyText) 上拍摄的照片

在大多数 Linux 或 macOS 系统上浏览一下`/usr/bin`,您会发现即使没有数千个命令，也有数百个。可供你选择的数量似乎令人眼花缭乱。尽管这些命令中的一些不会每天都是最相关或最有用的，但它们中的大部分都非常方便，有些非常聪明。

如果我们计算一下全新安装的 Debian 10 (Buster)上可用的命令数量，会超过 2000 个(你可以运行`compgen -c`来查看列表)。你将花费数年时间来梳理和掌握所有的选项。幸运的是，你不必这样做。

在这篇文章中(你应该知道的 [6 个终端命令的续篇](/6-terminal-commands-you-should-know-8e9767bdfec))，我们将会看到六个更加有趣和有用的命令，当你把它们添加到你的指令清单中时，它们将会使你成为一个生产力大师。

下面就开始探索几个吧！

# 1.使用 cmp 比较文件中的差异

```
cmp <file1> <file2>
```

让我们假设你有两个文本文件。每个文件中都有几行简单的文本，如下所示:

```
file1.txt           file2.txt
--------           --------
line1              line1
line2              line2
line4              line3
```

如果您不想打开每个文件并通过寻找不同的行来检查它，您可以使用`cmp`来快速确定文件中的任何差异。

如果您通过了`cmp file1.txt file2.txt`，您将看到以下输出:

```
file1.txt file2.txt differ: char 17, line 3
```

通过识别行号和字符号，这可以快速地向您显示这两个文件的分歧所在。这个工具对于进行即时文件比较非常方便。您可以通过验证文件是否相同来检查复制作业的基本有效性，或者通过比较一些源文件来找出它们的不同之处，从而找出代码中的错误。

# 2.用 comm 查找文件中的公共行

```
comm <file1> <file2>
```

另一方面，`comm`实用程序扫描相似的线，而不是像`cmp`那样寻找不同的线。使用这个命令，您可以识别两个文件的*公共*行。

让我们使用前一个示例中相同的两个文件，看看这个实用程序是如何工作的:

```
file1.txt           file2.txt
--------           --------
line1              line1
line2              line2
line4              line3
```

现在，如果我们运行`comm file1.txt file2.txt`，我们应该会看到以下输出:

```
 line1
            line2
      line3
line4
```

起初，这个输出可能有点令人困惑，但是它向您显示的是三个特定的结果列:

*   第一列包含仅来自第一个输入文件的行
*   第二列仅包含第二个输入文件中的行
*   两个文件共有的最后一列行

使用这个工具，我们可以快速识别包含相同行的文件。这对于查找在多个文件中定义的变量或者在一些文本输出中寻找重复条目是很有用的。

如果您需要不区分大小写，您也可以将`-i`标志传递给`comm`。

# 3.使用 ssh-keyscan 预加载可信的 SSH 密钥

```
ssh-keyscan <hostname> >> ~/.ssh/known_hosts
```

您有多少次连接到新机器并收到一般警告:

```
"The authenticity of host <foo> can't be established.Are you sure you want to continue connecting? (yes/no)?"
```

如果你正在连接到你已经知道是可信的主机(从内部网络或者像 GitHub 这样的公共服务),那么这条消息并不能保护你。

大多数时候，用户只是简单地输入“是”，比你说出“安全漏洞”还要快。那么，如果我们连接到许多主机，有什么方法可以减少我们看到这个消息的次数呢？是啊！

使用`ssh-keyscan`,您可以扫描一个特定的主机或一列主机的公共 SSH 密钥，并将它们添加到您的`known_hosts`文件中。现在当你连接到那个主机时，你不会得到提示，因为密钥已经存在于你的`known_hosts`文件中。例如，假设您想要扫描 [GitLab](https://about.gitlab.com/) 中的键并自动添加它们:

```
ssh-keyscan gitlab.com >> ~/.ssh/known_hosts
```

现在，您应该能够 SSH 到公共 GitLab 主机，而不会在继续之前被提示添加密钥。

# 4.用脚本记录您的终端会话日志

```
script <filename>
```

你是否曾经在一个终端会话中处理一些复杂或令人沮丧的东西，并且希望你能自动保存所有的输出供以后使用？`script`命令可以让你做到这一点。

这个简单的程序最初是为学生设计的，用于保存他们所有作业的日志，以显示他们是如何得出解决方案的。然而，这种用途并不仅限于学术界。

我已经使用这个工具在敏感的操作中保存日志，在这些操作中，我必须再次确认我运行了一个特定的命令。这也被实现为记录特定用户会话的基本方法，以便以后进行安全审查。

# 5.用 jot 生成测试数据

```
jot <number>
```

非常快速地需要大量随机或顺序数据？使用`jot`。这个漂亮且极其简单的实用程序可以让您生成一个巨大的数字列表，并创建一些非常大的数据输出。

有了`jot`，你可以构建连续的数字、字符串和字节集，或者只是输出随机数据。以下命令将生成一个从 1 到 100 的序列号列表:

```
jot 1001
2
...
100
```

看到这有多简单了吗？那么，一些随机数呢？

```
jot -r 10019
27
...
49
```

几根大长弦怎么样？

```
jot -s abc 1001abc2abc3abc4abc5abc6abc7abc8abc9abc10abc11abc12abc13abc14abc15abc16abc17abc18abc19abc20abc21abc22abc23abc24abc25abc26abc27abc28abc29abc30abc31abc32abc33abc34abc35abc36abc37abc38abc39abc40abc41abc42abc43abc44abc45abc46abc47abc48abc49abc50abc51abc52abc53abc54abc55abc56abc57abc58abc59abc60abc61abc62abc63abc64abc65abc66abc67abc68abc69abc70abc71abc72abc73abc74abc75abc76abc77abc78abc79abc80abc81abc82abc83abc84abc85abc86abc87abc88abc89abc90abc91abc92abc93abc94abc95abc96abc97abc98abc99abc100
```

这个命令快速、简单，比我用来快速生成简单测试数据的任何其他命令都要简单。

# 6.使用 iptab 联网的快速参考

```
iptab
```

我不敢相信我忽略了这一点。这非常简单，但是当你急着想改变网络时，却非常有用。发出不带参数的`iptab`命令将显示子网掩码和其他 IP 地址空间详细信息的参考表:

```
+----------------------------------------------+
| addrs   bits   pref   class  mask            |
+----------------------------------------------+
|     1      0    /32          255.255.255.255 |
|     2      1    /31          255.255.255.254 |
|     4      2    /30          255.255.255.252 |
|     8      3    /29          255.255.255.248 |
|    16      4    /28          255.255.255.240 |
|    32      5    /27          255.255.255.224 |
|    64      6    /26          255.255.255.192 |
|   128      7    /25          255.255.255.128 |
|   256      8    /24      1C  255.255.255.0   |
|   512      9    /23      2C  255.255.254.0   |
|    1K     10    /22      4C  255.255.252.0   |
|    2K     11    /21      8C  255.255.248.0   |
|    4K     12    /20     16C  255.255.240.0   |
|    8K     13    /19     32C  255.255.224.0   |
|   16K     14    /18     64C  255.255.192.0   |
|   32K     15    /17    128C  255.255.128.0   |
|   64K     16    /16      1B  255.255.0.0     |
|  128K     17    /15      2B  255.254.0.0     |
|  256K     18    /14      4B  255.252.0.0     |
|  512K     19    /13      8B  255.248.0.0     |
|    1M     20    /12     16B  255.240.0.0     |
|    2M     21    /11     32B  255.224.0.0     |
|    4M     22    /10     64B  255.192.0.0     |
|    8M     23     /9    128B  255.128.0.0     |
|   16M     24     /8      1A  255.0.0.0       |
|   32M     25     /7      2A  254.0.0.0       |
|   64M     26     /6      4A  252.0.0.0       |
|  128M     27     /5      8A  248.0.0.0       |
|  256M     28     /4     16A  240.0.0.0       |
|  512M     29     /3     32A  224.0.0.0       |
| 1024M     30     /2     64A  192.0.0.0       |
| 2048M     31     /1    128A  128.0.0.0       |
| 4096M     32     /0    256A  0.0.0.0         |
+----------------------------------------------+
```

该命令没有参数，只是一个简单的表格供您参考，然后继续进行这些关键的网络更改。

这一篇就到此为止——感谢阅读！