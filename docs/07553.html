<html>
<head>
<title>3 Useful Python Tricks for Beginners</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">对初学者有用的3个Python技巧</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/useful-tricks-in-python3-e953430c002c?source=collection_archive---------15-----------------------#2021-01-26">https://betterprogramming.pub/useful-tricks-in-python3-e953430c002c?source=collection_archive---------15-----------------------#2021-01-26</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="567c" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">编写干净的Pythonic代码</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/a77750515f02a1a2dfd3604f9d07f21e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*dPDB80wvYRtrGCzo"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated"><a class="ae kv" href="https://unsplash.com/@writecodenow?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Boitumelo Phetla </a>在<a class="ae kv" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍照。</p></figure><p id="7c62" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">当我开始探索编程时，我在<a class="ae kv" href="https://www.udacity.com/" rel="noopener ugc nofollow" target="_blank"> Udacity </a>上了一些关于Python 2的数据科学课程。当我最终投身编程时，我主要使用Ruby on Rails和JavaScript (React)进行web开发。现在，几年后，由于Python的多功能性和广泛的开发者支持，我又回到了学习Python的道路上。Python已经发展了很多，现在最常用的Python版本是更强大的Python 3！</p><p id="757c" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">虽然Python一直被誉为易于阅读的开发人员友好的语言，但我想分享一些我最喜欢的技巧，这些技巧让它变得更加有趣。</p></div><div class="ab cl ls lt hu lu" role="separator"><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx"/></div><div class="ij ik il im in"><h1 id="d25c" class="lz ma iq bd mb mc md me mf mg mh mi mj jw mk jx ml jz mm ka mn kc mo kd mp mq bi translated">1.默认字典</h1><p id="3675" class="pw-post-body-paragraph kw kx iq ky b kz mr jr lb lc ms ju le lf mt lh li lj mu ll lm ln mv lp lq lr ij bi translated">有多长时间你想做一个字典(如果你不熟悉Python，可以考虑HashMap)来跟踪一些东西，并且你必须检查你的键是否存在来决定添加什么值？</p><p id="9754" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">让我们举一个计算字符串中所有字符的例子。一种常见的方法是创建一个字典，遍历字符串，并将字符数存储在字典中。当我们遍历字符串时，如果我们发现一个我们以前没有见过的字符，我们初始化这个字符并设置它的计数为<code class="fe mw mx my mz b">1</code>。如果我们发现一个我们以前见过的，我们增加计数<code class="fe mw mx my mz b">1</code>:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="na nb l"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated"><a class="ae kv" href="https://repl.it/@dtluther/countcharsinstringpy#main.py" rel="noopener ugc nofollow" target="_blank">在repl.it </a>试试。</p></figure><p id="4179" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在Python中，这没有太多代码，这很好。但是我们必须检查该字符是否在字典中，因为如果我们试图访问字典中缺少的字符，我们将得到一个<code class="fe mw mx my mz b">KeyError</code>:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="na nb l"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated"><a class="ae kv" href="https://repl.it/@dtluther/brokencountcharspy#main.py" rel="noopener ugc nofollow" target="_blank">在repl.it </a>试试看。</p></figure><p id="d9ea" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">幸运的是，Python有一个工具可以让这变得更高效:那就是<code class="fe mw mx my mz b">defaultdict</code>。<code class="fe mw mx my mz b">defaultdict</code>接受一个参数类型(称为<code class="fe mw mx my mz b">default_factory</code>)，并在访问缺少的字典键时用它来设置默认值。我们需要做的就是从Python <code class="fe mw mx my mz b">collections</code>库中导入它:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="na nb l"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">演示defaultdict(int)如何处理丢失的键</p></figure><p id="f971" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">由于我们将<code class="fe mw mx my mz b">int</code>传递给了<code class="fe mw mx my mz b">defaultdict</code>，当我们试图访问一个丢失的键时，它将返回<code class="fe mw mx my mz b">0</code>。因此，通过使用<code class="fe mw mx my mz b">defaultdict(int)</code>，我们可以在我们的字符计数示例中去掉条件检入:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="na nb l"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated"><a class="ae kv" href="https://repl.it/@dtluther/cleanercountcharspy" rel="noopener ugc nofollow" target="_blank">在repl.it </a>试试看。</p></figure><p id="3259" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们可以使用其他数据结构作为<code class="fe mw mx my mz b">default_factory</code>，比如列表(比如数组)和集合。例如，如果我们想创建一个邻接表来表示一个图，传递一个<code class="fe mw mx my mz b">list</code>到<code class="fe mw mx my mz b">defaultdict</code>是一个很好的选择。</p></div><div class="ab cl ls lt hu lu" role="separator"><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx"/></div><div class="ij ik il im in"><h1 id="ace9" class="lz ma iq bd mb mc md me mf mg mh mi mj jw mk jx ml jz mm ka mn kc mo kd mp mq bi translated">2.柜台</h1><p id="d662" class="pw-post-body-paragraph kw kx iq ky b kz mr jr lb lc ms ju le lf mt lh li lj mu ll lm ln mv lp lq lr ij bi translated">首先，是的，这是一个大写的“c”。我们需要确保它是大写的。不要问我有多少次因为打错而得了一个<code class="fe mw mx my mz b">ImportError</code>。还记得我们上面用过的<code class="fe mw mx my mz b">defaultdict(int)</code>吗？一个<code class="fe mw mx my mz b">Counter</code>有内置的功能，甚至更多，我们将很快介绍。我们可以用一个<code class="fe mw mx my mz b">Counter</code>来代替我们用来计数字符的<code class="fe mw mx my mz b">defaultdict(int)</code>:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="na nb l"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated"><a class="ae kv" href="https://repl.it/@dtluther/countcharswithcounterpy" rel="noopener ugc nofollow" target="_blank">在repl.it </a>试试看。</p></figure><p id="95cb" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><code class="fe mw mx my mz b">Counter</code>的顺序可能会有所不同，但不要担心。<code class="fe mw mx my mz b">Counter</code>和<code class="fe mw mx my mz b">defaultdict</code>都是标准<code class="fe mw mx my mz b">dictionary</code>的子类，所以顺序并不重要。事实上，即使打印的值表明了对象的具体类型，我们也可以将它们放在一起比较，它们将评估为<code class="fe mw mx my mz b">True</code>:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="na nb l"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated"><a class="ae kv" href="https://repl.it/@dtluther/comparingdefaultdictandcounterpy" rel="noopener ugc nofollow" target="_blank">在repl.it </a>试试吧。</p></figure><p id="437f" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><code class="fe mw mx my mz b">Counters</code>居然有办法让代码<em class="nc">甚至</em>更短！我不需要迭代，只需将一个字符串(或任何可以迭代的Python对象)传递给一个<code class="fe mw mx my mz b">Counter</code>，然后<em class="nc">瞧</em>，它会处理它:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="na nb l"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated"><a class="ae kv" href="https://repl.it/@dtluther/cleanestcountcharspy" rel="noopener ugc nofollow" target="_blank">在repl.it </a>试试吧。</p></figure><p id="aee0" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">也有一些很好的内置方法，使它们非常有用，包括一种按照最高频率顺序返回项目的方法。更多信息，请查看<a class="ae kv" href="https://docs.python.org/3/library/collections.html?highlight=defaultdict#collections.Counter" rel="noopener ugc nofollow" target="_blank"> Python文档</a>。</p></div><div class="ab cl ls lt hu lu" role="separator"><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx"/></div><div class="ij ik il im in"><h1 id="e6bf" class="lz ma iq bd mb mc md me mf mg mh mi mj jw mk jx ml jz mm ka mn kc mo kd mp mq bi translated">3.获取字典中最大值的关键字</h1><p id="1fd9" class="pw-post-body-paragraph kw kx iq ky b kz mr jr lb lc ms ju le lf mt lh li lj mu ll lm ln mv lp lq lr ij bi translated">找到每个字符的频率后，常见的下一步是返回最常见/最不常见的字符。我们来找最常见的。我们可以通过在字典中查找最大值来做到这一点。然后，我们可以遍历键，检查键的值，当我们找到等于最大值的值时，我们知道我们找到了正确的值:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="na nb l"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated"><a class="ae kv" href="https://repl.it/@dtluther/findmostcommoncharpy" rel="noopener ugc nofollow" target="_blank">在repl.it </a>试试。</p></figure><p id="3e6b" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在我们得到每个字母在字典对象中出现的频率后(<code class="fe mw mx my mz b">Counter</code>是<code class="fe mw mx my mz b">dictionary</code>的子类)，第7-10行演示了一种非常简单的方法来查找最常见的字母。对于Python中的其他常见事物，我们有一种更简短的写法:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="na nb l"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated"><a class="ae kv" href="https://repl.it/@dtluther/cleanerfindmostcommonpy" rel="noopener ugc nofollow" target="_blank">在repl.it </a>试试。</p></figure><p id="41b6" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">哇哦。如果你像我一样，你可能会认为这看起来有点神奇，但我保证它不像看起来那么花哨。Python的<code class="fe mw mx my mz b">max()</code>函数可以比较多个值:</p><pre class="kg kh ki kj gt nd mz ne nf aw ng bi"><span id="8d6d" class="nh ma iq mz b gy ni nj l nk nl">max(1, 2, 3)<br/>&gt; 3</span></pre><p id="c466" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">或者我们可以给它传递一个iterable(可以排序的东西，比如我们的<code class="fe mw mx my mz b">Counter</code>)，一个字符串，一个列表，等等。)它将返回最大值:</p><pre class="kg kh ki kj gt nd mz ne nf aw ng bi"><span id="e44a" class="nh ma iq mz b gy ni nj l nk nl">max(Counter({'l': 3, 'o': 2, 'H': 1, 'e': 1, ' ': 1, 'W': 1, 'r': 1, 'd': 1}))<br/>&gt; 'w'</span></pre><p id="92cc" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">如果我们将计数器传递给<code class="fe mw mx my mz b">max()</code>，它将比较我们字典中的字母(键)并返回“max”字母，在本例中是<code class="fe mw mx my mz b">w</code>。然而，额外的<code class="fe mw mx my mz b">key</code>参数允许我们传递一个单参数函数，类似于我们在<code class="fe mw mx my mz b">sort()</code>中所做的。让我们再看一次我们的<em class="nc">奇特的</em>例子:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="na nb l"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">再试一次。为什么不呢？</p></figure><p id="0608" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们将<code class="fe mw mx my mz b">ch_count.get</code>传递给了<code class="fe mw mx my mz b">key</code>参数。<code class="fe mw mx my mz b">ch_count.get(key)</code>是获取键值的另一种方式。<code class="fe mw mx my mz b">ch_count[key]</code>与<code class="fe mw mx my mz b">ch_count.get(key)</code>非常相似，但是<code class="fe mw mx my mz b">ch_count.get(key)</code>有一个额外的好处，那就是能够传入一个默认值。你可以在文档中读到更多关于这个<a class="ae kv" href="https://docs.python.org/3/library/stdtypes.html#mapping-types-dict" rel="noopener ugc nofollow" target="_blank">的内容。</a></p><p id="6dd6" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">自从我们通过了<code class="fe mw mx my mz b">key=ch_count.get</code>，我们本质上是在告诉Python，“嘿，去查字典，给我max字母。但是，我希望您对每个字母调用<code class="fe mw mx my mz b">ch_count.get</code>并使用这些值来确定最大值，而不是将字母相互比较来找到最大值。”起初这可能看起来有点古怪，但是我鼓励你尝试一下，让你的代码更加整洁。</p></div><div class="ab cl ls lt hu lu" role="separator"><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx"/></div><div class="ij ik il im in"><h1 id="bbe6" class="lz ma iq bd mb mc md me mf mg mh mi mj jw mk jx ml jz mm ka mn kc mo kd mp mq bi translated">结论</h1><p id="dcfd" class="pw-post-body-paragraph kw kx iq ky b kz mr jr lb lc ms ju le lf mt lh li lj mu ll lm ln mv lp lq lr ij bi translated">今天就到这里吧！非常感谢你阅读这篇文章。如果你觉得这很有用或有任何问题，请随时分享你的反馈，我非常感谢。</p><p id="bf6e" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">本周下面的资源列表有点短，但还是很有帮助的！</p></div><div class="ab cl ls lt hu lu" role="separator"><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx"/></div><div class="ij ik il im in"><h1 id="8b84" class="lz ma iq bd mb mc md me mf mg mh mi mj jw mk jx ml jz mm ka mn kc mo kd mp mq bi translated">资源</h1><ul class=""><li id="38e3" class="nm nn iq ky b kz mr lc ms lf no lj np ln nq lr nr ns nt nu bi translated"><a class="ae kv" href="https://docs.python.org/3/" rel="noopener ugc nofollow" target="_blank">好的ol' Python文档</a></li><li id="f98a" class="nm nn iq ky b kz nv lc nw lf nx lj ny ln nz lr nr ns nt nu bi translated">在经常重复和优化编码模式的地方练习算法。</li></ul></div></div>    
</body>
</html>