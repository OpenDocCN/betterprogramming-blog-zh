<html>
<head>
<title>Secure Access to Kubernetes Deployment Endpoints on Amazon EKS</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">安全访问亚马逊EKS上的Kubernetes部署端点</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/secure-access-to-kubernetes-deployment-endpoints-on-amazon-eks-4826a8e87c6f?source=collection_archive---------4-----------------------#2020-07-09">https://betterprogramming.pub/secure-access-to-kubernetes-deployment-endpoints-on-amazon-eks-4826a8e87c6f?source=collection_archive---------4-----------------------#2020-07-09</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="1236" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">如何为您在亚马逊EKS上的Kubernetes部署端点提供安全的HTTPS访问</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/9488bd683a9104a7a8dddb3227c93a02.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*ASMGzgJwxPZlCHR2"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">图片由Pixabay提供</p></figure></div><div class="ab cl ky kz hx la" role="separator"><span class="lb bw bk lc ld le"/><span class="lb bw bk lc ld le"/><span class="lb bw bk lc ld"/></div><div class="im in io ip iq"><h1 id="9b27" class="lf lg it bd lh li lj lk ll lm ln lo lp jz lq ka lr kc ls kd lt kf lu kg lv lw bi translated">目录</h1><pre class="kj kk kl km gt lx ly lz ma aw mb bi"><span id="233e" class="mc lg it ly b gy md me l mf mg"><a class="ae mh" href="https://medium.com/p/4826a8e87c6f#780d" rel="noopener"><strong class="ly iu">Introduction</strong></a><strong class="ly iu"><br/>  </strong><a class="ae mh" href="https://medium.com/p/4826a8e87c6f#3e6e" rel="noopener">The idea</a><br/><a class="ae mh" href="https://medium.com/p/4826a8e87c6f#101e" rel="noopener"><strong class="ly iu">Requirements</strong></a><br/><a class="ae mh" href="https://medium.com/p/4826a8e87c6f#3ef1" rel="noopener"><strong class="ly iu">Setting Up an Ingress Controller</strong></a><br/>  <a class="ae mh" href="https://medium.com/p/4826a8e87c6f#ba8c" rel="noopener">Installing ingress-nginx</a><br/>  <a class="ae mh" href="https://medium.com/p/4826a8e87c6f#8020" rel="noopener">Setting an external IP</a><br/><a class="ae mh" href="https://medium.com/p/4826a8e87c6f#af7c" rel="noopener"><strong class="ly iu">Setting Up a Certificate Issuer</strong></a><br/>  <a class="ae mh" href="https://medium.com/p/4826a8e87c6f#6860" rel="noopener">Installing cert-manager</a><br/>  <a class="ae mh" href="https://medium.com/p/4826a8e87c6f#d7d8" rel="noopener">Adding support for private VPCs</a><br/>  <a class="ae mh" href="https://medium.com/p/4826a8e87c6f#1671" rel="noopener">Providing DNS access</a><br/>  <a class="ae mh" href="https://medium.com/p/4826a8e87c6f#66f9" rel="noopener">Deploying the certificate issuer</a><br/><a class="ae mh" href="https://medium.com/p/4826a8e87c6f#f651" rel="noopener"><strong class="ly iu">Setting Up Your Ingress</strong></a><br/><a class="ae mh" href="https://medium.com/p/4826a8e87c6f#9cbd" rel="noopener"><strong class="ly iu">Summary</strong></a></span></pre></div><div class="ab cl ky kz hx la" role="separator"><span class="lb bw bk lc ld le"/><span class="lb bw bk lc ld le"/><span class="lb bw bk lc ld"/></div><div class="im in io ip iq"><h1 id="780d" class="lf lg it bd lh li lj lk ll lm ln lo lp jz lq ka lr kc ls kd lt kf lu kg lv lw bi translated">介绍</h1><p id="4d00" class="pw-post-body-paragraph mi mj it mk b ml mm ju mn mo mp jx mq mr ms mt mu mv mw mx my mz na nb nc nd im bi translated">因此，您的所有负载都在最先进的<a class="ae mh" href="https://kubernetes.io/" rel="noopener ugc nofollow" target="_blank"> Kubernetes </a>集群中运行，一切都比以往更加顺畅。</p><p id="454e" class="pw-post-body-paragraph mi mj it mk b ml ne ju mn mo nf jx mq mr ng mt mu mv nh mx my mz ni nb nc nd im bi translated">此外，由于一切都在VPC内，感觉安全问题已经解决了。这在某种程度上是正确的:如果一切都配置正确，就没有对集群资源的外部访问。</p><p id="d7d0" class="pw-post-body-paragraph mi mj it mk b ml ne ju mn mo nf jx mq mr ng mt mu mv nh mx my mz ni nb nc nd im bi translated">但是我们仍然需要保护内部交通。我们从不希望任何普通数据在传输中，尤其是当它涉及敏感的客户数据时。</p><p id="4d94" class="pw-post-body-paragraph mi mj it mk b ml ne ju mn mo nf jx mq mr ng mt mu mv nh mx my mz ni nb nc nd im bi translated">在我以前的文章中，“<a class="ae mh" href="https://medium.com/better-programming/turn-your-own-docker-image-into-an-auto-scaling-kubernetes-deployment-using-amazon-eks-bd2ab8ef56cc" rel="noopener">使用Amazon EKS将Docker映像转变为自动伸缩的Kubernetes部署</a>”和“<a class="ae mh" href="https://itnext.io/utilize-jenkins-in-an-auto-scaling-kubernetes-deployment-on-amazon-eks-with-spot-instances-f9159df00aee" rel="noopener ugc nofollow" target="_blank">使用Spot实例在Amazon EKS上的自动伸缩Kubernetes部署中利用Jenkins</a>”，我演示了如何使用自定义Docker映像、Spot实例等在自动伸缩的EKS环境中设置Kubernetes部署，但是我们没有讨论安全性。现在是时候投入进去了。</p><h2 id="3e6e" class="mc lg it bd lh nj nk dn ll nl nm dp lp mr nn no lr mv np nq lt mz nr ns lv nt bi translated">这个想法</h2><p id="9503" class="pw-post-body-paragraph mi mj it mk b ml mm ju mn mo mp jx mq mr ms mt mu mv mw mx my mz na nb nc nd im bi translated">如果你对Kubernetes稍有了解，你就会知道其中的几乎所有东西都是(或者可以是)动态的。您的部署可以由许多基于输入、负载等来来去去的单元组成。，并且手动跟踪安全端点，尤其是使用证书，可能是一场噩梦。有一些解决方案，比如在图像中嵌入证书，但是这些仍然很难管理。</p><p id="268d" class="pw-post-body-paragraph mi mj it mk b ml ne ju mn mo nf jx mq mr ng mt mu mv nh mx my mz ni nb nc nd im bi translated">幸运的是，Kubernetes带来了另一个名为<em class="nu"> Ingress </em>的概念，这将是我们解决方案的基石。</p><p id="f574" class="pw-post-body-paragraph mi mj it mk b ml ne ju mn mo nf jx mq mr ng mt mu mv nh mx my mz ni nb nc nd im bi translated">入口提供对Kubernetes集群端点的访问。可以将它想象成一个路由器，它接收外部流量并将其定向到集群服务:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nv"><img src="../Images/5730d4f55d90240ca10c4241c9551c92.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*SIkhnzpkRKNqMfJ8"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">图片由作者提供</p></figure></div><div class="ab cl ky kz hx la" role="separator"><span class="lb bw bk lc ld le"/><span class="lb bw bk lc ld le"/><span class="lb bw bk lc ld"/></div><div class="im in io ip iq"><h1 id="101e" class="lf lg it bd lh li lj lk ll lm ln lo lp jz lq ka lr kc ls kd lt kf lu kg lv lw bi translated">要求</h1><p id="c378" class="pw-post-body-paragraph mi mj it mk b ml mm ju mn mo mp jx mq mr ms mt mu mv mw mx my mz na nb nc nd im bi translated">本文假设您将AWS作为云提供商，并且您可以访问EKS和ECR管理控制台，以及AWS CLI。</p><p id="c464" class="pw-post-body-paragraph mi mj it mk b ml ne ju mn mo nf jx mq mr ng mt mu mv nh mx my mz ni nb nc nd im bi translated">我还假设您已经安装并配置了<code class="fe nw nx ny ly b">eksctl</code>和<code class="fe nw nx ny ly b">kubectl</code>，并且在您的集群上有某种带有web端点的部署。</p><p id="a507" class="pw-post-body-paragraph mi mj it mk b ml ne ju mn mo nf jx mq mr ng mt mu mv nh mx my mz ni nb nc nd im bi translated">我再一次尝试对以前的知识做最少的假设，并尽我所能解释，但我确实假设对Kubernetes的概念有些熟悉。</p><p id="5d37" class="pw-post-body-paragraph mi mj it mk b ml ne ju mn mo nf jx mq mr ng mt mu mv nh mx my mz ni nb nc nd im bi translated">最后，请注意，本文中所有的<a class="ae mh" href="https://gist.github.com/ohanetz/bf2c4ef9cc4fe47cb366de59cd37c53c" rel="noopener ugc nofollow" target="_blank">代码片段和引用文件</a>都可以在GitHub上获得。</p></div><div class="ab cl ky kz hx la" role="separator"><span class="lb bw bk lc ld le"/><span class="lb bw bk lc ld le"/><span class="lb bw bk lc ld"/></div><div class="im in io ip iq"><h1 id="3ef1" class="lf lg it bd lh li lj lk ll lm ln lo lp jz lq ka lr kc ls kd lt kf lu kg lv lw bi translated">设置入口控制器</h1><p id="d5ec" class="pw-post-body-paragraph mi mj it mk b ml mm ju mn mo mp jx mq mr ms mt mu mv mw mx my mz na nb nc nd im bi translated">在添加入口之前，我们将向Kubernetes集群添加几个组件。我们需要的第一个组件是入口控制器，它将管理我们集群的传入流量。</p><p id="e660" class="pw-post-body-paragraph mi mj it mk b ml ne ju mn mo nf jx mq mr ng mt mu mv nh mx my mz ni nb nc nd im bi translated">我们将使用ingress-nginx，也称为Kubernetes的nginx ingress控制器，这是Kubernetes社区官方支持和维护的两个Ingress控制器之一(另一个是ingress-gce)。</p><p id="eacf" class="pw-post-body-paragraph mi mj it mk b ml ne ju mn mo nf jx mq mr ng mt mu mv nh mx my mz ni nb nc nd im bi translated">有关备选入口控制器的列表，请查看Kubernetes文档。</p><p id="2cc2" class="pw-post-body-paragraph mi mj it mk b ml ne ju mn mo nf jx mq mr ng mt mu mv nh mx my mz ni nb nc nd im bi translated">Kubernetes的nginx入口控制器是一个简单的入口控制器，它基于nginx web服务器，并利用其反向代理和负载平衡器功能来处理流量。</p><h2 id="ba8c" class="mc lg it bd lh nj nk dn ll nl nm dp lp mr nn no lr mv np nq lt mz nr ns lv nt bi translated">安装ingress-nginx</h2><p id="7e39" class="pw-post-body-paragraph mi mj it mk b ml mm ju mn mo mp jx mq mr ms mt mu mv mw mx my mz na nb nc nd im bi translated">打开您的终端并运行以下命令:</p><pre class="kj kk kl km gt lx ly lz ma aw mb bi"><span id="2070" class="mc lg it ly b gy md me l mf mg">kubectl apply -f <a class="ae mh" href="https://raw.githubusercontent.com/kubernetes/ingress-nginx/master/deploy/static/provider/aws/deploy.yaml" rel="noopener ugc nofollow" target="_blank">https://raw.githubusercontent.com/kubernetes/ingress-nginx/master/deploy/static/provider/aws/deploy.yaml</a></span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nz"><img src="../Images/380dc00855a8e9bd58d4df32e2e4559d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*HJMqWbZwgk4HHzeA"/></div></div></figure><p id="383e" class="pw-post-body-paragraph mi mj it mk b ml ne ju mn mo nf jx mq mr ng mt mu mv nh mx my mz ni nb nc nd im bi translated">注意，这个命令将部署最新版本的ingress-nginx。对于以前的版本或其他平台，检查<a class="ae mh" href="https://github.com/kubernetes/ingress-nginx" rel="noopener ugc nofollow" target="_blank">https://github.com/kubernetes/ingress-nginx</a>。有关ingress-nginx的更多信息，请查看项目主页<a class="ae mh" href="https://kubernetes.github.io/ingress-nginx/" rel="noopener ugc nofollow" target="_blank">https://kubernetes.github.io/ingress-nginx/</a>。</p><h2 id="8020" class="mc lg it bd lh nj nk dn ll nl nm dp lp mr nn no lr mv np nq lt mz nr ns lv nt bi translated">设置外部IP</h2><p id="ef8f" class="pw-post-body-paragraph mi mj it mk b ml mm ju mn mo mp jx mq mr ms mt mu mv mw mx my mz na nb nc nd im bi translated">接下来我们需要为<code class="fe nw nx ny ly b">ingress-nginx-controller</code>服务设置一个外部访问点，我们将使用它来管理对集群的访问。</p><p id="b99a" class="pw-post-body-paragraph mi mj it mk b ml ne ju mn mo nf jx mq mr ng mt mu mv nh mx my mz ni nb nc nd im bi translated">如果你读过我以前的Kubernetes文章，你已经知道当你在私人VPC上使用EKS时，你的服务不会自动分配一个外部IP。</p><p id="cd45" class="pw-post-body-paragraph mi mj it mk b ml ne ju mn mo nf jx mq mr ng mt mu mv nh mx my mz ni nb nc nd im bi translated">我已经在我的文章“使用亚马逊EKS将您的Docker映像转变为自动伸缩的Kubernetes部署”中描述了一种通过注释您的服务来解决这个问题的方法另一种解决方案是在服务规范中手动设置负载平衡器外部IP。</p><p id="aa70" class="pw-post-body-paragraph mi mj it mk b ml ne ju mn mo nf jx mq mr ng mt mu mv nh mx my mz ni nb nc nd im bi translated">运行以下命令找到您的<code class="fe nw nx ny ly b">ingress-nginx-controller</code>服务外部IP(如果您不知道):</p><pre class="kj kk kl km gt lx ly lz ma aw mb bi"><span id="da2e" class="mc lg it ly b gy md me l mf mg">kubectl describe service ingress-nginx-controller -n ingress-nginx | grep Endpoints | awk -F'[ :]+' 'NR==1{print $2}'</span></pre><p id="fab4" class="pw-post-body-paragraph mi mj it mk b ml ne ju mn mo nf jx mq mr ng mt mu mv nh mx my mz ni nb nc nd im bi translated">运行以下命令来编辑您的<code class="fe nw nx ny ly b">ingress-nginx-controller</code>服务:</p><pre class="kj kk kl km gt lx ly lz ma aw mb bi"><span id="4a70" class="mc lg it ly b gy md me l mf mg">kubectl edit svc/ingress-nginx-controller -n ingress-nginx</span></pre><p id="676d" class="pw-post-body-paragraph mi mj it mk b ml ne ju mn mo nf jx mq mr ng mt mu mv nh mx my mz ni nb nc nd im bi translated">将下列行添加到规范部分的末尾(请参见下面的示例):</p><pre class="kj kk kl km gt lx ly lz ma aw mb bi"><span id="7870" class="mc lg it ly b gy md me l mf mg">externalIPs:<br/>- YOUR_EXTERNAL_IP</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi oa"><img src="../Images/b4e0315e89f0877d7c330a598d034799.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*IY4nD5dtwJbl2ykm"/></div></div></figure><p id="4fbf" class="pw-post-body-paragraph mi mj it mk b ml ne ju mn mo nf jx mq mr ng mt mu mv nh mx my mz ni nb nc nd im bi translated">完成编辑后保存文件。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ob"><img src="../Images/1e78f32842dc083a324c5292c5f3f5ac.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*_14ew6l1j5dzMpyF"/></div></div></figure></div><div class="ab cl ky kz hx la" role="separator"><span class="lb bw bk lc ld le"/><span class="lb bw bk lc ld le"/><span class="lb bw bk lc ld"/></div><div class="im in io ip iq"><h1 id="af7c" class="lf lg it bd lh li lj lk ll lm ln lo lp jz lq ka lr kc ls kd lt kf lu kg lv lw bi translated">设置证书颁发者</h1><p id="84e1" class="pw-post-body-paragraph mi mj it mk b ml mm ju mn mo mp jx mq mr ms mt mu mv mw mx my mz na nb nc nd im bi translated">我们需要的下一个组件是一个证书发行者，它将管理我们集群的端点证书，以确保安全访问。</p><p id="37de" class="pw-post-body-paragraph mi mj it mk b ml ne ju mn mo nf jx mq mr ng mt mu mv nh mx my mz ni nb nc nd im bi translated">我们将使用cert-manager，这是一个Kubernetes证书管理控制器，它可以自动发布和更新来自各个提供商的证书。</p><p id="e0fe" class="pw-post-body-paragraph mi mj it mk b ml ne ju mn mo nf jx mq mr ng mt mu mv nh mx my mz ni nb nc nd im bi translated">在本文中，我们将建立一个自动更新的加密证书(查看<a class="ae mh" href="https://letsencrypt.org/" rel="noopener ugc nofollow" target="_blank">让我们加密</a>了解更多细节)。</p><h2 id="6860" class="mc lg it bd lh nj nk dn ll nl nm dp lp mr nn no lr mv np nq lt mz nr ns lv nt bi translated">正在安装证书管理器</h2><p id="66f2" class="pw-post-body-paragraph mi mj it mk b ml mm ju mn mo mp jx mq mr ms mt mu mv mw mx my mz na nb nc nd im bi translated">打开您的终端并运行以下命令:</p><pre class="kj kk kl km gt lx ly lz ma aw mb bi"><span id="f3f7" class="mc lg it ly b gy md me l mf mg">kubectl apply --validate=false -f <a class="ae mh" href="https://github.com/jetstack/cert-manager/releases/download/v0.14.2/cert-manager.yaml" rel="noopener ugc nofollow" target="_blank">https://github.com/jetstack/cert-manager/releases/download/v0.14.2/cert-manager.yaml</a></span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi oc"><img src="../Images/6497ef7706da6af6824df0bf4af3ef86.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*Wjv0hwVWd4owYmTW"/></div></div></figure><p id="f962" class="pw-post-body-paragraph mi mj it mk b ml ne ju mn mo nf jx mq mr ng mt mu mv nh mx my mz ni nb nc nd im bi translated">该命令将为Kubernetes引擎版本1.15及更高版本部署最新版本的cert-manager。</p><p id="ca36" class="pw-post-body-paragraph mi mj it mk b ml ne ju mn mo nf jx mq mr ng mt mu mv nh mx my mz ni nb nc nd im bi translated">注意，<code class="fe nw nx ny ly b">--validate=false</code>标志只有在运行Kubernetes 1.15.4或更早版本时才需要，否则会导致良性的验证错误。</p><p id="f1cd" class="pw-post-body-paragraph mi mj it mk b ml ne ju mn mo nf jx mq mr ng mt mu mv nh mx my mz ni nb nc nd im bi translated">有关不同的Kubernetes引擎版本和安装过程的其他信息，请查看证书管理器Kubernetes安装指南:<a class="ae mh" href="https://cert-manager.io/docs/installation/kubernetes/" rel="noopener ugc nofollow" target="_blank">https://cert-manager.io/docs/installation/kubernetes/</a>。</p><p id="3807" class="pw-post-body-paragraph mi mj it mk b ml ne ju mn mo nf jx mq mr ng mt mu mv nh mx my mz ni nb nc nd im bi translated">有关cert-manager的更多信息，请查看项目主页<a class="ae mh" href="https://cert-manager.io/" rel="noopener ugc nofollow" target="_blank"> https://cert-manager.io </a>。</p><h2 id="d7d8" class="mc lg it bd lh nj nk dn ll nl nm dp lp mr nn no lr mv np nq lt mz nr ns lv nt bi translated">添加对私有VPC的支持</h2><p id="89b4" class="pw-post-body-paragraph mi mj it mk b ml mm ju mn mo mp jx mq mr ms mt mu mv mw mx my mz na nb nc nd im bi translated">如果您使用的是私有VPC,“让我们加密”将使用您的私有DNS名称服务器，通过ACME质询来尝试验证您的DNS所有权。但是，由于无法从互联网访问这些名称服务器，验证将会失败。</p><p id="5670" class="pw-post-body-paragraph mi mj it mk b ml ne ju mn mo nf jx mq mr ng mt mu mv nh mx my mz ni nb nc nd im bi translated">我们需要给cert-manager添加一个标志，以便使用公共DNS名称服务器(比如谷歌的8.8.8.8)来验证您的DNS。</p><p id="7a4c" class="pw-post-body-paragraph mi mj it mk b ml ne ju mn mo nf jx mq mr ng mt mu mv nh mx my mz ni nb nc nd im bi translated">运行以下命令编辑证书管理器部署:</p><pre class="kj kk kl km gt lx ly lz ma aw mb bi"><span id="9656" class="mc lg it ly b gy md me l mf mg">kubectl edit deployments.apps/cert-manager -n cert-manager</span></pre><p id="4fe4" class="pw-post-body-paragraph mi mj it mk b ml ne ju mn mo nf jx mq mr ng mt mu mv nh mx my mz ni nb nc nd im bi translated">将以下行添加到cert-manager args部分:</p><pre class="kj kk kl km gt lx ly lz ma aw mb bi"><span id="7ec6" class="mc lg it ly b gy md me l mf mg">- --dns01-recursive-nameservers="8.8.8.8:53"<br/>- --dns01-recursive-nameservers-only</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/5ae665eff249af7f0c4bd3aa8b465b4f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*E5F7B7js-kPLZap1"/></div></div></figure><p id="e290" class="pw-post-body-paragraph mi mj it mk b ml ne ju mn mo nf jx mq mr ng mt mu mv nh mx my mz ni nb nc nd im bi translated">保存文件，注意部署已被编辑:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi od"><img src="../Images/9885972321d5d69ecf31eb141f6bbb3c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*zg8Z78UXygEGFAaT"/></div></div></figure><h2 id="1671" class="mc lg it bd lh nj nk dn ll nl nm dp lp mr nn no lr mv np nq lt mz nr ns lv nt bi translated">提供DNS访问</h2><p id="641a" class="pw-post-body-paragraph mi mj it mk b ml mm ju mn mo mp jx mq mr ms mt mu mv mw mx my mz na nb nc nd im bi translated">我们将使用Let's Encrypt来颁发我们的证书。Let's Encrypt是一个提供免费证书的证书颁发机构(CA)。证书的有效期很短，但可以轻松更新(cert-manager会自动为您更新)。</p><p id="fd7c" class="pw-post-body-paragraph mi mj it mk b ml ne ju mn mo nf jx mq mr ng mt mu mv nh mx my mz ni nb nc nd im bi translated">为了给一个域颁发证书，CA必须确认您拥有该域。让我们加密使用ACME挑战来进行验证。在这种方法中，CA为您提供一个唯一的文本密钥来存储在您的域中，然后尝试访问您的域并读取该密钥来验证所有权。</p><p id="0d2a" class="pw-post-body-paragraph mi mj it mk b ml ne ju mn mo nf jx mq mr ng mt mu mv nh mx my mz ni nb nc nd im bi translated">在我们的例子中，cert-manager使用一个名为<em class="nu">证书发行者</em>的实体来为我们处理这个过程。但是，我们需要为证书颁发者提供对我们的DNS服务器的访问，以便自动将密钥放在那里进行质询。</p><p id="a4ff" class="pw-post-body-paragraph mi mj it mk b ml ne ju mn mo nf jx mq mr ng mt mu mv nh mx my mz ni nb nc nd im bi translated">我们将假设您使用AWS Route 53作为您的DNS提供者，并演示如何为证书颁发者提供访问它的权限。</p><p id="63ce" class="pw-post-body-paragraph mi mj it mk b ml ne ju mn mo nf jx mq mr ng mt mu mv nh mx my mz ni nb nc nd im bi translated">请注意，如果您使用不同的DNS提供商，您仍然可以使用Route 53来公开管理您的域的特定子域。</p><p id="97da" class="pw-post-body-paragraph mi mj it mk b ml ne ju mn mo nf jx mq mr ng mt mu mv nh mx my mz ni nb nc nd im bi translated">最后，如果您使用Route 53作为您的私有VPC的私有DNS，您需要为相同的子域创建一个额外的公共DNS托管区域，这只是为了ACME challenges的目的。</p><p id="7679" class="pw-post-body-paragraph mi mj it mk b ml ne ju mn mo nf jx mq mr ng mt mu mv nh mx my mz ni nb nc nd im bi translated">在这两种情况下，为您的子域创建一个公共托管区域，并在您的外部DNS提供商中设置名称服务器。</p><p id="34a3" class="pw-post-body-paragraph mi mj it mk b ml ne ju mn mo nf jx mq mr ng mt mu mv nh mx my mz ni nb nc nd im bi translated">在53号公路上设置好公共托管区域后，复制托管区域ID。</p><p id="ff57" class="pw-post-body-paragraph mi mj it mk b ml ne ju mn mo nf jx mq mr ng mt mu mv nh mx my mz ni nb nc nd im bi translated">接下来，我们需要创建一个策略来提供对该托管区域的访问。</p><p id="4e03" class="pw-post-body-paragraph mi mj it mk b ml ne ju mn mo nf jx mq mr ng mt mu mv nh mx my mz ni nb nc nd im bi translated">在AWS管理控制台中打开IAM。在访问管理下选择策略<em class="nu"> </em>并点击‘创建策略’按钮。</p><p id="cedd" class="pw-post-body-paragraph mi mj it mk b ml ne ju mn mo nf jx mq mr ng mt mu mv nh mx my mz ni nb nc nd im bi translated">选择JSON选项卡并粘贴以下文本(在<a class="ae mh" href="https://gist.github.com/ohanetz/bf2c4ef9cc4fe47cb366de59cd37c53c#file-aws-iam-route53-policy-json" rel="noopener ugc nofollow" target="_blank">要点</a>中也有):</p><pre class="kj kk kl km gt lx ly lz ma aw mb bi"><span id="9e68" class="mc lg it ly b gy md me l mf mg">{<br/>  "Version": "2012–10–17",<br/>  "Statement": [<br/>    {<br/>      "Effect": "Allow",<br/>      "Action": "route53:GetChange",<br/>      "Resource": "arn:aws:route53:::change/*"<br/>    },<br/>    {<br/>      "Effect": "Allow",<br/>      "Action": [<br/>        "route53:ChangeResourceRecordSets",<br/>        "route53:ListResourceRecordSets"<br/>      ],<br/>      "Resource": "arn:aws:route53:::hostedzone/YOUR_HOSTED_ZONE_ID"<br/>    }<br/>  ]<br/>}</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/35d757c3e9609e84e65f7b58fde169ef.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*X1Vc0S65919cWiUP"/></div></div></figure><p id="107c" class="pw-post-body-paragraph mi mj it mk b ml ne ju mn mo nf jx mq mr ng mt mu mv nh mx my mz ni nb nc nd im bi translated">确保将<code class="fe nw nx ny ly b"> YOUR_HOSTED_ZONE_ID</code>占位符替换为您从Route 53复制的托管区域ID。</p><p id="5879" class="pw-post-body-paragraph mi mj it mk b ml ne ju mn mo nf jx mq mr ng mt mu mv nh mx my mz ni nb nc nd im bi translated">单击“查看策略”，键入名称，然后单击“创建策略”完成。</p><p id="6b67" class="pw-post-body-paragraph mi mj it mk b ml ne ju mn mo nf jx mq mr ng mt mu mv nh mx my mz ni nb nc nd im bi translated">接下来，我们需要创建一个用户并附加这个策略。</p><p id="f4a5" class="pw-post-body-paragraph mi mj it mk b ml ne ju mn mo nf jx mq mr ng mt mu mv nh mx my mz ni nb nc nd im bi translated">仍然在IAM中，在访问管理下选择用户<em class="nu"> </em>并点击“创建用户”按钮。</p><p id="a30c" class="pw-post-body-paragraph mi mj it mk b ml ne ju mn mo nf jx mq mr ng mt mu mv nh mx my mz ni nb nc nd im bi translated">键入名称，并为“访问类型”选择“编程访问”</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/51c6bb796981ab5567d5a14e84c323c5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*E2DuoSIhtsCp5DRT"/></div></div></figure><p id="cd79" class="pw-post-body-paragraph mi mj it mk b ml ne ju mn mo nf jx mq mr ng mt mu mv nh mx my mz ni nb nc nd im bi translated">点击【下一步:权限】<em class="nu"> </em>按钮。选择“直接附加现有策略”<em class="nu"> </em>并选择您刚刚创建的策略。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi oe"><img src="../Images/ccf573b583b5b9e6fc61a03afff95d1b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*xnom0y50NDPDDXnK"/></div></div></figure><p id="0b79" class="pw-post-body-paragraph mi mj it mk b ml ne ju mn mo nf jx mq mr ng mt mu mv nh mx my mz ni nb nc nd im bi translated">继续单击“下一步”,最后单击“创建用户”按钮。</p><p id="610f" class="pw-post-body-paragraph mi mj it mk b ml ne ju mn mo nf jx mq mr ng mt mu mv nh mx my mz ni nb nc nd im bi translated">在下一个屏幕上，您将获得用户访问密钥ID和秘密访问密钥。把它们放在手边——我们接下来会用到它们。请注意，AWS不会再向您显示秘密访问密钥，但是如果您丢失了它，您可以很容易地生成一个新的密钥。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/99deaa9f75415dc6a17780368ea2e5c3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*50uGOIDgLo1fSSw4"/></div></div></figure><h2 id="66f9" class="mc lg it bd lh nj nk dn ll nl nm dp lp mr nn no lr mv np nq lt mz nr ns lv nt bi translated">部署证书颁发者</h2><p id="3436" class="pw-post-body-paragraph mi mj it mk b ml mm ju mn mo mp jx mq mr ms mt mu mv mw mx my mz na nb nc nd im bi translated">现在，我们需要部署一个证书颁发者，它将连接到Let's Encrypt来为我们颁发证书。</p><p id="546f" class="pw-post-body-paragraph mi mj it mk b ml ne ju mn mo nf jx mq mr ng mt mu mv nh mx my mz ni nb nc nd im bi translated">发行者将使用我们刚刚创建的用户自动将ACME挑战放入Route 53并验证我们的域所有权。</p><p id="69c9" class="pw-post-body-paragraph mi mj it mk b ml ne ju mn mo nf jx mq mr ng mt mu mv nh mx my mz ni nb nc nd im bi translated">因此，我们首先需要在Kubernetes中存储一个秘密实体来保存AWS访问凭证。</p><p id="bf0f" class="pw-post-body-paragraph mi mj it mk b ml ne ju mn mo nf jx mq mr ng mt mu mv nh mx my mz ni nb nc nd im bi translated">从要点中获取<code class="fe nw nx ny ly b"><a class="ae mh" href="https://gist.github.com/ohanetz/bf2c4ef9cc4fe47cb366de59cd37c53c#file-letsencrypt-issuer-secret-yaml" rel="noopener ugc nofollow" target="_blank">letsencrypt-issuer-secret.yaml</a></code>示例文件。Secret <em class="nu"> </em>实体包含一个键-值记录，其中键是AWS用户名，值是用户的秘密访问键。将占位符替换为您刚刚在IAM中创建的用户名，该值是您之前保存的秘密访问密钥，以base64编码。</p><p id="d8be" class="pw-post-body-paragraph mi mj it mk b ml ne ju mn mo nf jx mq mr ng mt mu mv nh mx my mz ni nb nc nd im bi translated">为了用base64编码您的密钥，请打开您的终端并运行以下命令:</p><pre class="kj kk kl km gt lx ly lz ma aw mb bi"><span id="b1d2" class="mc lg it ly b gy md me l mf mg">python3 -c "import base64;print(base64.b64encode(b'YOUR_SECRET_ACCESS_KEY_HERE').decode())"</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi of"><img src="../Images/ad70ec8848168e65167e22a4b9735e60.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*LzLPpZgG6_Pw2qSO"/></div></div></figure><p id="06d3" class="pw-post-body-paragraph mi mj it mk b ml ne ju mn mo nf jx mq mr ng mt mu mv nh mx my mz ni nb nc nd im bi translated">运行以下命令来部署您的机密:</p><pre class="kj kk kl km gt lx ly lz ma aw mb bi"><span id="292c" class="mc lg it ly b gy md me l mf mg">kubectl apply -f letsencrypt-issuer-secret.yaml</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi og"><img src="../Images/ccd4d28abd13bd5c0df87723f3654487.png" data-original-src="https://miro.medium.com/v2/resize:fit:1140/0*KMqU2-9RIC2wRAgT"/></div></figure><p id="1dd3" class="pw-post-body-paragraph mi mj it mk b ml ne ju mn mo nf jx mq mr ng mt mu mv nh mx my mz ni nb nc nd im bi translated">最后，我们需要部署证书颁发者本身。</p><p id="efc8" class="pw-post-body-paragraph mi mj it mk b ml ne ju mn mo nf jx mq mr ng mt mu mv nh mx my mz ni nb nc nd im bi translated">从要点中获取<code class="fe nw nx ny ly b"><a class="ae mh" href="https://gist.github.com/ohanetz/bf2c4ef9cc4fe47cb366de59cd37c53c#file-letsencrypt-issuer-yaml" rel="noopener ugc nofollow" target="_blank">letsencrypt-issuer.yaml</a></code>示例文件。替换您的域名(您希望为其创建一个安全子域)、您的AWS区域、您刚刚在IAM中创建的用户名以及您之前复制的那个用户的访问密钥ID <em class="nu"> </em>的占位符(请注意，这不是我们之前使用的秘密访问密钥)。</p><p id="8144" class="pw-post-body-paragraph mi mj it mk b ml ne ju mn mo nf jx mq mr ng mt mu mv nh mx my mz ni nb nc nd im bi translated">运行以下命令部署证书颁发者:</p><pre class="kj kk kl km gt lx ly lz ma aw mb bi"><span id="23b9" class="mc lg it ly b gy md me l mf mg">kubectl apply -f letsencrypt-issuer.yaml</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi oh"><img src="../Images/36eb88f93bc4553e60211017d140cd45.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*tELXg0t-UkNyhh9U"/></div></div></figure><p id="71d8" class="pw-post-body-paragraph mi mj it mk b ml ne ju mn mo nf jx mq mr ng mt mu mv nh mx my mz ni nb nc nd im bi translated">有关使用AWS Route 53创建cert-manager证书颁发者的更多详细信息，请查看cert-manager文档中的<a class="ae mh" href="https://cert-manager.io/docs/configuration/acme/dns01/route53/" rel="noopener ugc nofollow" target="_blank">一文。</a></p></div><div class="ab cl ky kz hx la" role="separator"><span class="lb bw bk lc ld le"/><span class="lb bw bk lc ld le"/><span class="lb bw bk lc ld"/></div><div class="im in io ip iq"><h1 id="f651" class="lf lg it bd lh li lj lk ll lm ln lo lp jz lq ka lr kc ls kd lt kf lu kg lv lw bi translated">设置您的入口</h1><p id="07d5" class="pw-post-body-paragraph mi mj it mk b ml mm ju mn mo mp jx mq mr ms mt mu mv mw mx my mz na nb nc nd im bi translated">我们要做的最后一步是创建<em class="nu"> </em>入口实体，它将为您的端点提供实际的安全访问。</p><p id="1ea4" class="pw-post-body-paragraph mi mj it mk b ml ne ju mn mo nf jx mq mr ng mt mu mv nh mx my mz ni nb nc nd im bi translated">从要点中获取<code class="fe nw nx ny ly b"><a class="ae mh" href="https://gist.github.com/ohanetz/bf2c4ef9cc4fe47cb366de59cd37c53c#file-my-ingress-yaml" rel="noopener ugc nofollow" target="_blank">my-ingress.yaml</a></code>示例文件。该文件将创建一个入口实体，该实体将自动为您的主机颁发证书，并将该主机的传入请求定向到您的Kubernetes端点服务。</p><p id="de1a" class="pw-post-body-paragraph mi mj it mk b ml ne ju mn mo nf jx mq mr ng mt mu mv nh mx my mz ni nb nc nd im bi translated">入口配置文件中有两个规范部分:一个为您的主机设置证书，另一个为您的服务设置请求路由。</p><p id="2b61" class="pw-post-body-paragraph mi mj it mk b ml ne ju mn mo nf jx mq mr ng mt mu mv nh mx my mz ni nb nc nd im bi translated">在两个位置替换主机URL的占位符(一个用于TLS证书设置，一个用于路由规则)，以及Kubernetes端点服务名称和端口的占位符。</p><p id="a985" class="pw-post-body-paragraph mi mj it mk b ml ne ju mn mo nf jx mq mr ng mt mu mv nh mx my mz ni nb nc nd im bi translated">运行以下命令来部署入口:</p><pre class="kj kk kl km gt lx ly lz ma aw mb bi"><span id="1eed" class="mc lg it ly b gy md me l mf mg">kubectl apply -f my-ingress.yaml</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi oi"><img src="../Images/37f31b30b5bbd714827dd9fcc93157b4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1252/0*n4lDvsPfDDmGP99L"/></div></figure><p id="9749" class="pw-post-body-paragraph mi mj it mk b ml ne ju mn mo nf jx mq mr ng mt mu mv nh mx my mz ni nb nc nd im bi translated">运行以下命令检查您的证书状态:</p><pre class="kj kk kl km gt lx ly lz ma aw mb bi"><span id="7610" class="mc lg it ly b gy md me l mf mg">kubectl describe certificate my-ingress-tls</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/d2602e277102dcc94af145a65932cfd5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*SD81M-xfxln-F3Jl"/></div></div></figure><p id="2794" class="pw-post-body-paragraph mi mj it mk b ml ne ju mn mo nf jx mq mr ng mt mu mv nh mx my mz ni nb nc nd im bi translated">请注意，证书申请正在进行中。等待几分钟，让cert-manager颁发您的证书，然后再次检查状态:</p><pre class="kj kk kl km gt lx ly lz ma aw mb bi"><span id="4bbd" class="mc lg it ly b gy md me l mf mg">kubectl describe certificate my-ingress-tls</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi oj"><img src="../Images/a3db0f775733e2d41f07aece77b6f016.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*kiSuHBfgws0cyrQ-"/></div></div></figure><p id="4ecf" class="pw-post-body-paragraph mi mj it mk b ml ne ju mn mo nf jx mq mr ng mt mu mv nh mx my mz ni nb nc nd im bi translated">最后，您的证书准备好了，您可以通过您提供的主机URL访问您的服务，并安全地路由到您的Kubernetes端点。</p></div><div class="ab cl ky kz hx la" role="separator"><span class="lb bw bk lc ld le"/><span class="lb bw bk lc ld le"/><span class="lb bw bk lc ld"/></div><div class="im in io ip iq"><h1 id="9cbd" class="lf lg it bd lh li lj lk ll lm ln lo lp jz lq ka lr kc ls kd lt kf lu kg lv lw bi translated">摘要</h1><p id="90bf" class="pw-post-body-paragraph mi mj it mk b ml mm ju mn mo mp jx mq mr ms mt mu mv mw mx my mz na nb nc nd im bi translated">即使在您的私有网络中，您的web端点仍然是您的云架构中最脆弱的部分。无论您的设计有多可靠，您的Kubernetes实体得到了多好的保护，您都必须确保您的数据管道在每个端点以及端点之间的任何地方都是安全的。</p><p id="8f1a" class="pw-post-body-paragraph mi mj it mk b ml ne ju mn mo nf jx mq mr ng mt mu mv nh mx my mz ni nb nc nd im bi translated">在本文中，我展示了如何使用Kubernetes Ingress概念，并将其与流行的开源组件和AWS功能相结合，以提供一个简单但强大且安全的解决方案。</p><p id="177c" class="pw-post-body-paragraph mi mj it mk b ml ne ju mn mo nf jx mq mr ng mt mu mv nh mx my mz ni nb nc nd im bi translated">通过这个基本用例，我试图向您介绍概念和功能，我相信根据您的特定需求进行调整会相对容易。</p><p id="972f" class="pw-post-body-paragraph mi mj it mk b ml ne ju mn mo nf jx mq mr ng mt mu mv nh mx my mz ni nb nc nd im bi translated">要了解更多关于EKS及其功能的信息，请访问https://docs.aws.amazon.com/eks/index.html的EKS AWS文档。</p><p id="d67f" class="pw-post-body-paragraph mi mj it mk b ml ne ju mn mo nf jx mq mr ng mt mu mv nh mx my mz ni nb nc nd im bi translated">你还应该参考亚马逊提供的这个EKS在线研讨会，它也可以帮助你入门，并向你介绍https://eksworkshop.com/<a class="ae mh" href="https://eksworkshop.com/" rel="noopener ugc nofollow" target="_blank">的所有EKS特色。</a></p></div></div>    
</body>
</html>