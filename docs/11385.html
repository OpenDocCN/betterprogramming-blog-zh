<html>
<head>
<title>Building a Simple REST API in Go With Gorilla/Mux</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">用Gorilla/Mux在Go中构建一个简单的REST API</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/building-a-simple-rest-api-in-go-with-gorilla-mux-892ceb128c6f?source=collection_archive---------4-----------------------#2022-03-15">https://betterprogramming.pub/building-a-simple-rest-api-in-go-with-gorilla-mux-892ceb128c6f?source=collection_archive---------4-----------------------#2022-03-15</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="cd76" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">启动你的后端</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/c2f8ed750786c7a0102244873733336b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*87Oa6Lkggzyodm2W"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">照片由<a class="ae kv" href="https://unsplash.com/@synkevych?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">罗曼·辛克维奇·🇺🇦</a>在<a class="ae kv" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</p></figure><p id="323a" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">最近我开始学习如何用Gorilla/mux构建API，主要是因为我对后端开发感兴趣，并且我一直在学习。</p><p id="1977" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我找到了Gorilla/mux，老实说它的<a class="ae kv" href="https://pkg.go.dev/github.com/gorilla/mux" rel="noopener ugc nofollow" target="_blank">文档</a>非常好，解释得很好。</p><p id="a43b" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">根据其文档，Gorilla/mux是:</p><blockquote class="ls lt lu"><p id="300e" class="kw kx lv ky b kz la jr lb lc ld ju le lw lg lh li lx lk ll lm ly lo lp lq lr ij bi translated">Package gorilla/mux实现了一个请求路由器和调度程序，用于将传入的请求匹配到它们各自的处理程序。</p><p id="8497" class="kw kx lv ky b kz la jr lb lc ld ju le lw lg lh li lx lk ll lm ly lo lp lq lr ij bi translated">mux这个名称代表“HTTP请求多路复用器”。比如标准的http。ServeMux，Mux。路由器将传入的请求与注册的路由列表进行匹配，并为匹配URL或其他条件的路由调用处理程序。主要特点是:</p><p id="c62f" class="kw kx lv ky b kz la jr lb lc ld ju le lw lg lh li lx lk ll lm ly lo lp lq lr ij bi translated">它实现了http。处理程序接口，因此它与标准的http.ServeMux兼容。可以基于URL主机、路径、路径前缀、方案、标头和查询值、http方法或使用自定义匹配器来匹配请求。URL主机、路径和查询值可以包含带有可选正则表达式的变量。注册的URL可以被构建，或者“反转”，这有助于维护对资源的引用。路由可以用作子路由:只有当父路由匹配时，才会测试嵌套路由。这对于定义共享相同条件(如主机、路径前缀或其他重复属性)的路由组非常有用。另外，这优化了请求匹配。</p></blockquote><p id="9baf" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">根据它的文档，我学会了构建一个简单的杂货API，以获取特定的杂货及其数量、所有杂货及其数量，发布一个杂货项目并更新它。</p><p id="9b4a" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这个项目的三个部分看起来像这样:</p><pre class="kg kh ki kj gt lz ma mb mc aw md bi"><span id="cd39" class="me mf iq ma b gy mg mh l mi mj">------groceriesAPI<br/>       |---grocery.go<br/>       |---handler.go<br/>       |---main.go</span></pre><p id="e451" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在<code class="fe mk ml mm ma b">grocery.go</code>中，我们定义API的模型，<code class="fe mk ml mm ma b">handler.go</code>是管理请求的函数，<code class="fe mk ml mm ma b">main.go</code>是注册我们的URL路径。</p><p id="23c8" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">首先，我们安装Gorilla/mux。</p><pre class="kg kh ki kj gt lz ma mb mc aw md bi"><span id="f7c0" class="me mf iq ma b gy mg mh l mi mj">go get -u github.com/gorilla/mux</span></pre><p id="d06f" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><code class="fe mk ml mm ma b">grocery.go</code>的代码是:</p><pre class="kg kh ki kj gt lz ma mb mc aw md bi"><span id="e310" class="me mf iq ma b gy mg mh l mi mj">package main<br/><br/>type Grocery struct {<br/><br/>    Name     string `json: "name"`<br/>    Quantity int    `json: "quantity"`<br/>}</span></pre><p id="e385" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们的模型很简单，只有两个字段，食品名称和数量。</p><p id="b791" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><code class="fe mk ml mm ma b">main.go is</code>的代号:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mn mo l"/></div></figure><p id="d337" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在上面的代码中，我们将“r”定义为路由器后。在上面的例子中，方法<code class="fe mk ml mm ma b">HandleFunc</code>有两个参数，第一个是URL路径，第二个是处理它的函数，当第一个匹配时，调用第二个。例如，如果请求“all杂货”，函数<code class="fe mk ml mm ma b">AllGroceries</code>将处理它并提供所请求的数据，在这种情况下，是数据库中的所有杂货(我们在这个项目中没有使用数据库)。</p><p id="96e9" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们有五条路径，一条请求所有的食品杂货，一条按名称请求食品杂货，一条添加食品杂货，一条更新按名称请求的食品杂货，还有一条按名称删除食品杂货。它们都使用端口10000，如果发生错误，将会触发信息错误并停止程序。</p><p id="dce0" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">现在，我们将转移到<code class="fe mk ml mm ma b">handler.go</code>来定义处理每个请求的函数:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mn mo l"/></div></figure><p id="51e2" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们定义了一个变量<code class="fe mk ml mm ma b">groceries</code>，并给它分配了一个包含两个杂货信息的数组，因为我们没有使用数据库。当<code class="fe mk ml mm ma b">AllGroceries</code>被调用时，它将返回包含所有杂货的数组，但以JSON的形式返回。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mn mo l"/></div></figure><p id="b11b" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在这个函数中，我们使用<code class="fe mk ml mm ma b">mux.Vars()</code>从路线中检索杂货店的名称。然后遍历切片，只返回请求的杂货。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mn mo l"/></div></figure><p id="418d" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在<code class="fe mk ml mm ma b">GroceriesToBuy</code>中，我们接收post请求并将其分配给<code class="fe mk ml mm ma b">reqBody</code>，然后我们用<code class="fe mk ml mm ma b">Grocery</code>定义一个变量杂货作为类型。我们使用JSON包中的unmarshal方法解析JSON数据发布请求，并将其存储在杂货变量中。之后，我们将它添加到食品杂货中。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mn mo l"/></div></figure><p id="34e4" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><code class="fe mk ml mm ma b">DeleteGrocery</code>如果名称路径与切片中的一个杂货店匹配，将删除该杂货店。然后更新切片。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mn mo l"/></div></figure><p id="c93c" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">如果名称路径与切片中的一个杂货店匹配，最后一个函数将更新一个杂货店。它将接受PUT请求，对其进行解码并将其存储在<code class="fe mk ml mm ma b">updateGrocery</code>变量中。然后它会把它附加到杂货上。</p><p id="02ea" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">老实说，我很喜欢学习如何在go中创建Rest API。下一步是添加一个类似SQLite或PostgreSQL的数据库。</p><p id="3b85" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">完整的代码是<a class="ae kv" href="https://github.com/carlosm27/Go_projects/tree/main/groceriesApi" rel="noopener ugc nofollow" target="_blank">这里的</a></p><h2 id="65b6" class="me mf iq bd mp mq mr dn ms mt mu dp mv lf mw mx my lj mz na nb ln nc nd ne nf bi translated"><strong class="ak">资源</strong></h2><div class="ng nh gp gr ni nj"><a href="https://pkg.go.dev/github.com/gorilla/mux" rel="noopener  ugc nofollow" target="_blank"><div class="nk ab fo"><div class="nl ab nm cl cj nn"><h2 class="bd ir gy z fp no fr fs np fu fw ip bi translated">复用器</h2><div class="nq l"><h3 class="bd b gy z fp no fr fs np fu fw dk translated">https://www.gorillatoolkit.org/pkg/mux包gorilla/mux实现了一个请求路由器和调度器，用于匹配…</h3></div><div class="nr l"><p class="bd b dl z fp no fr fs np fu fw dk translated">pkg.go.dev</p></div></div></div></a></div></div></div>    
</body>
</html>