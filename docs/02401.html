<html>
<head>
<title>Introducing Cerializr: (De)Serialize Like a Pro</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">介绍Cerializr:(反)像专家一样连载</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/introducing-cerializr-de-serialize-like-a-pro-3e9143e8ff6e?source=collection_archive---------12-----------------------#2019-11-27">https://betterprogramming.pub/introducing-cerializr-de-serialize-like-a-pro-3e9143e8ff6e?source=collection_archive---------12-----------------------#2019-11-27</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="d222" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">一个开源库，使序列化变得更好</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/1f86e8d8385b5b3a2e31739883c15156.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*hUYCd8498HpMODFsEW-2Fg.jpeg"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">由<a class="ae ky" href="https://unsplash.com/@sortino?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">约书亚·索蒂诺</a>在<a class="ae ky" href="https://unsplash.com/s/photos/sunny?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</p></figure><p id="dbd7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">序列化主要用于当我们与发送给我们一个JSON文件的后端通信时，我们希望我们的类在TypeScript/JavaScript中有实例，反之亦然。为JSON文件中的每个属性定义构造函数和创建实例是一件痛苦的事情。</p><p id="0ec1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">存在许多解决方案——<a class="ae ky" href="https://github.com/typestack/class-transformer" rel="noopener ugc nofollow" target="_blank">class-transformer</a>、<a class="ae ky" href="https://github.com/mobxjs/serializr" rel="noopener ugc nofollow" target="_blank">serializer</a>等。</p><p id="6c0c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">但是有一个库引起了我的注意，它是<a class="ae ky" href="https://github.com/weichx/cerialize" rel="noopener ugc nofollow" target="_blank"> <strong class="lb iu">铈化</strong> </a> <strong class="lb iu">。它使用简单，非常快，没有硬设置，而且它使用装饰者！</strong></p><p id="9b53" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">但是，即使这个库很强大，也没有维持两年。甚至还有一个版本2，它已经准备好了，但是隐藏在一个拉请求中。<a class="ae ky" href="https://github.com/weichx/cerialize/pull/78#issuecomment-403751508" rel="noopener ugc nofollow" target="_blank">库的作者自己也承认他不再在上面工作了(这就是生活！)</a>。</p><p id="e68a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">使用<code class="fe lv lw lx ly b">npm i — save cerialize</code>可以轻松安装cerialize v1。可以使用<code class="fe lv lw lx ly b">cerialize@next</code>安装v2。这就是为什么许多人没有使用这个库的所有功能。</p><p id="68f8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">所以我花了一点时间来恢复这个项目，分叉，更新TypeScript和jest，并更新测试。现在，我们都可以享受这个图书馆。</p><p id="edad" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu">我很高兴地宣布</strong><a class="ae ky" href="https://github.com/kmathy/cerializr" rel="noopener ugc nofollow" target="_blank"><strong class="lb iu">Cerializr</strong></a><strong class="lb iu">的发布！</strong></p></div><div class="ab cl lz ma hx mb" role="separator"><span class="mc bw bk md me mf"/><span class="mc bw bk md me mf"/><span class="mc bw bk md me"/></div><div class="im in io ip iq"><h1 id="2207" class="mg mh it bd mi mj mk ml mm mn mo mp mq jz mr ka ms kc mt kd mu kf mv kg mw mx bi translated">快速示例</h1><h2 id="751b" class="my mh it bd mi mz na dn mm nb nc dp mq li nd ne ms lm nf ng mu lq nh ni mw nj bi translated">问题是</h2><p id="ee70" class="pw-post-body-paragraph kz la it lb b lc nk ju le lf nl jx lh li nm lk ll lm nn lo lp lq no ls lt lu im bi translated">当我们从服务器接收数据时，它是原始形式的，通常是JSON格式的。在客户端，我们需要建立一个到类的映射，否则我们将在一个数组中接收对象。</p><p id="82da" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">使用TypeScript，我们可以指定我们接收的数据的类型，但这只是一种键入！对象的实例没有被创建，所以我们不能使用一个包含放入我们模型的所有方法或特性的对象。</p><p id="9486" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们在一个小的Stackblitz项目中验证一下…</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="np nq l"/></div></figure><h2 id="7d36" class="my mh it bd mi mz na dn mm nb nc dp mq li nd ne ms lm nf ng mu lq nh ni mw nj bi translated">解决方案</h2><p id="ba43" class="pw-post-body-paragraph kz la it lb b lc nk ju le lf nl jx lh li nm lk ll lm nn lo lp lq no ls lt lu im bi translated">做了很多工作却收效甚微——我们能改进吗？当我们从服务器接收数据时，在模型的属性上使用一个装饰器来自动生成我们的实例不是更好吗？</p><p id="c9d9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu">这就是</strong> <a class="ae ky" href="https://github.com/kmathy/cerializr" rel="noopener ugc nofollow" target="_blank"> <strong class="lb iu">铈锆</strong> </a> <strong class="lb iu">的用武之地！</strong></p><p id="ee0d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">存在几个decorators，但是它们使用一个简单的案例来处理我们属性的序列化和反序列化。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="np nq l"/></div></figure><p id="bc73" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如您所见，我们不再需要管理模型中的构造函数。装潢师为我们做的！</p><p id="65b2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这只是一个简单的反序列化的例子，但实际上，<a class="ae ky" href="http://twitter.com/autoserializeAs" rel="noopener ugc nofollow" target="_blank"> @autoserializeAs </a>也会负责你的数据序列化到后端！</p></div><div class="ab cl lz ma hx mb" role="separator"><span class="mc bw bk md me mf"/><span class="mc bw bk md me mf"/><span class="mc bw bk md me"/></div><div class="im in io ip iq"><p id="ba56" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">还有许多其他功能，下面是一个简短的总结:</p><ul class=""><li id="e488" class="nr ns it lb b lc ld lf lg li nt lm nu lq nv lu nw nx ny nz bi translated">在一种类型中指定序列化，在另一种类型中指定反序列化。</li><li id="873e" class="nr ns it lb b lc oa lf ob li oc lm od lq oe lu nw nx ny nz bi translated">指定不同于您的型号的特定键。</li><li id="5f47" class="nr ns it lb b lc oa lf ob li oc lm od lq oe lu nw nx ny nz bi translated">定义您自己的序列化(反序列化)函数。例如，根据我们模型中的不同属性计算一个金额。</li><li id="bb0e" class="nr ns it lb b lc oa lf ob li oc lm od lq oe lu nw nx ny nz bi translated">定义一个实例化方法(使用new、object.create或不使用它们)。</li><li id="97dc" class="nr ns it lb b lc oa lf ob li oc lm od lq oe lu nw nx ny nz bi translated">从父级继承序列化。例如，从UserModel继承属性的AdminModel。</li><li id="9dc2" class="nr ns it lb b lc oa lf ob li oc lm od lq oe lu nw nx ny nz bi translated">还有更多…</li></ul><p id="f89c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">不要犹豫给一些关于你的用户体验的反馈，如果你有任何问题，请随时提出。</p><p id="352c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">祝你愉快，别忘了带着激情工作！</p></div></div>    
</body>
</html>