<html>
<head>
<title>Build a Rails-Like Migration Runner for Your Go Projects</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">为您的Go项目构建一个类似Rails的迁移运行器</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/build-a-rails-like-migration-runner-for-your-go-projects-b72f551597a3?source=collection_archive---------13-----------------------#2020-09-02">https://betterprogramming.pub/build-a-rails-like-migration-runner-for-your-go-projects-b72f551597a3?source=collection_archive---------13-----------------------#2020-09-02</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="c90d" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">可靠地向上和向下迁移开发和测试数据库</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/1711729f91f563eb48dd0f0ad3120bf8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*Ow42NeXdu_mA8vYC"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">照片由<a class="ae ky" href="https://unsplash.com/@wallendorff?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">路德维希·沃伦多夫</a>在<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</p></figure><p id="41fc" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">发现自己有一周的空闲时间，我决定将一个旧的Rails项目移植到Go中。我努力整理数据库模式，规划我将使用的包，并就是否使用serial IDs、UUIDs或ULIDs进行内部辩论。只有当所有的细节都确定后，我才意识到一个显而易见的事实——在我开始应用程序之前，我需要一些管理迁移的方法。</p><p id="7638" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">Rails是一个全栈的web框架，旨在让项目轻而易举地启动。Go是一种编程语言，擅长分布式系统，原则上避开框架。虽然Go web框架已经存在(例如Gin)，但是我觉得通过最小化“魔法”和编写自己的工具，还可以学到更多东西。</p><p id="1b42" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">具体来说，我需要可靠地上下迁移开发和测试数据库的能力，这样当我不可避免地把应用程序开发搞得一团糟时，回滚数据库并重试就不会有任何痛苦。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="e1c5" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">1.环境</h1><p id="6c2d" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">Migrate ( <code class="fe mz na nb nc b"><a class="ae ky" href="https://github.com/golang-migrate/migrate" rel="noopener ugc nofollow" target="_blank">golang-migrate/migrate</a></code>)是一个运行迁移的出色的包，它附带了一个可以在Go应用程序中使用的库和一个生成和触发迁移文件的命令行工具。</p><p id="8ca1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">然而，使用现成的CLI的问题是，设置环境变量和手动键入数据库地址有很多麻烦。我想要无缝的解决方案，它可以为我的应用程序加载正确的环境配置，并迁移正确的数据库，而不需要我亲自操作。这意味着被困在图书馆里。</p><p id="ed81" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">作为第一步，我选定了一个变量来向我的程序发送当前环境的信号:<code class="fe mz na nb nc b">FB05_ENV=[development|test|staging|production]</code>。<code class="fe mz na nb nc b">FB05</code>是我的应用程序的名字——随便你怎么称呼你的。我希望这是我必须手动更改的唯一env变量。</p><p id="7cce" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">第二，我在我的项目根中创建了<code class="fe mz na nb nc b">environment.yaml</code>。这将最终保存我的应用程序需要运行的每个env变量(当然，注意隐藏敏感的变量)。到目前为止，它仅限于数据库配置:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nd ne l"/></div></figure><p id="b58c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这不一定是YAML的文件。如果你是一个<code class="fe mz na nb nc b">.env</code>或者其他配置格式的粉丝，那也可以。</p><p id="83b5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">假设您已经单独创建了相应的数据库，这就是开始构建我们的跑步者所需的所有设置。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="0f62" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">2.'迁移. go '</h1><p id="6c18" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">我将运行程序命名为<code class="fe mz na nb nc b">migrate.go</code>，它位于项目根下的<code class="fe mz na nb nc b">cmd/migrate/migrate.go</code>。最后，我们将使用类似于Rail的<code class="fe mz na nb nc b">rake db:migrate</code>的<code class="fe mz na nb nc b">make</code>命令来运行这个带有适当参数的脚本。</p><p id="a770" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们从<code class="fe mz na nb nc b">main</code>功能开始:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nd ne l"/></div></figure><p id="221a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在第3-13行，我们指定并解析了控制我们的程序应该在哪里寻找环境配置文件的标志。在这种情况下，我将默认值设置为指向我们项目的根目录中的<code class="fe mz na nb nc b">environment.yaml</code>。</p><p id="2bac" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">接下来，我们检查以确保调用脚本时至少有一个参数:让<code class="fe mz na nb nc b">Migrate</code>包运行的命令。其中一些命令(例如<code class="fe mz na nb nc b">(m* Migrate) Steps(n int)</code>)带有自己的参数，但是我们还没有检查这一点。</p><p id="1e5e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在第24-29行，我们加载由我们的标志描述的环境文件。在幕后，这是由一个名为Viper的包完成的。稍后会有更多内容。</p><p id="cf20" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">成功加载环境后，我们就可以使用指定的命令和传递的任何参数来运行迁移了。</p><p id="8310" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们仔细看看<code class="fe mz na nb nc b">loadEnvVars</code>和<code class="fe mz na nb nc b">runMigration</code>。</p><h2 id="a934" class="nf md it bd me ng nh dn mi ni nj dp mm li nk nl mo lm nm nn mq lq no np ms nq bi translated"><code class="fe mz na nb nc b">'loadEnvVars'</code></h2><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nd ne l"/></div></figure><p id="8867" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe mz na nb nc b">loadEnvVars</code>获取我们在<code class="fe mz na nb nc b">main</code>中解析的<code class="fe mz na nb nc b">configName</code>和<code class="fe mz na nb nc b">configPath</code>标志，并返回一个指向<code class="fe mz na nb nc b">viper.Viper</code>的指针。</p><p id="0e83" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><a class="ae ky" href="https://github.com/spf13/viper" rel="noopener ugc nofollow" target="_blank"> Viper是一个用于Go应用程序的高性能配置包</a>,因此，它对于这样的脚本来说是多余的。然而，我计划在我的项目中的其他地方使用Viper，所以把它放在这里也是有意义的。如果你喜欢轻量级的，可以考虑<a class="ae ky" href="https://github.com/kelseyhightower/envconfig" rel="noopener ugc nofollow" target="_blank"> envconfig </a>、<a class="ae ky" href="https://github.com/joho/godotenv" rel="noopener ugc nofollow" target="_blank"> GoDotEnv </a>，或者只是自己解析环境文件。</p><p id="4a99" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在第12-14行，我们将Viper配置为从位于项目根目录下的名为<code class="fe mz na nb nc b">environment.yaml</code>的文件中读取数据。注意，我没有创建一个名为<code class="fe mz na nb nc b">configType</code>的标志——我已经硬编码了<code class="fe mz na nb nc b">yaml</code>，因为我知道我的配置文件将总是YAML。你可能会有不同的决定。</p><p id="cea4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe mz na nb nc b">viper.ReadInConfig</code>使Viper读取源文件中包含的env变量并创建一个<code class="fe mz na nb nc b">*viper.Viper</code>。当我们想要访问一个环境变量时，我们用像<code class="fe mz na nb nc b">(v *Viper) Get(key string)</code>这样的方法查询这个结构，而不是运行<code class="fe mz na nb nc b">os.Getenv</code>。</p><p id="44dc" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">但我们还没完！Viper已经加载了整个<code class="fe mz na nb nc b">environment.yaml</code>文件，包括<code class="fe mz na nb nc b">test</code>、<code class="fe mz na nb nc b">production</code>的配置，以及您可能已经存储在那里的任何其他组。这就是为什么<code class="fe mz na nb nc b">loadEnvVars</code>做的第一件事就是用<code class="fe mz na nb nc b">os.Getenv("FB05_ENV")</code>寻找目标环境。我们将这个值传递给<code class="fe mz na nb nc b">viper.Sub</code>以返回一个<code class="fe mz na nb nc b">*viper.Viper</code>，它只包含与我们的目标环境匹配的环境变量的子集。</p><p id="759f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">当<code class="fe mz na nb nc b">loadEnvVars</code>返回时，这个<code class="fe mz na nb nc b">*viper.Viper</code>会发生什么？你会注意到，当我在<code class="fe mz na nb nc b">main:25</code>上调用<code class="fe mz na nb nc b">env, err = loadEnvVars(*configName, *configPath)</code>时，我没有在中声明任何新的变量。<code class="fe mz na nb nc b">env</code>实际上是在<code class="fe mz na nb nc b">main</code> : <code class="fe mz na nb nc b">var env *viper.Viper</code>之外声明的全局变量。这样，就可以在脚本的任何地方访问它，就像<code class="fe mz na nb nc b">os.Getenv</code>一样。</p><h2 id="d9e0" class="nf md it bd me ng nh dn mi ni nj dp mm li nk nl mo lm nm nn mq lq no np ms nq bi translated">'运行迁移'</h2><p id="8c25" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">这是一个矮胖的。抓紧了:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nd ne l"/></div></figure><p id="d61a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">首先，我们使用迁移包创建一个新的<code class="fe mz na nb nc b">*migrate.Migration</code>。这里的设置有些复杂，因为您必须根据迁移的存储位置和使用的DBMS，通过空白导入来注册不同的Migrate子包。</p><p id="716f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我将迁移存储在本地，我选择的药物是PostgreSQL。所以我的导入看起来像这样:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nd ne l"/></div></figure><p id="6028" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe mz na nb nc b">migrate.New</code>的第一个参数是<code class="fe mz na nb nc b">source</code>:迁移文件存储的位置。我的在我的项目根目录下的<code class="fe mz na nb nc b">db/migrations</code>。</p><p id="3c5a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">第二个是数据库URL，这就是为什么在运行迁移之前加载环境变量如此重要的原因:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nd ne l"/></div></figure><p id="2f34" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">想象一下，每当您想要运行迁移时，都必须键入这些内容。想象一下，在生产中必须手动运行您的迁移。这些就是这个小型项目要解决的问题。</p><p id="db7a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在创建了<code class="fe mz na nb nc b">*migrate.Migration</code>并验证了所提供的任何数字参数确实是数字之后，我们使用指定的命令<code class="fe mz na nb nc b">switch</code>并触发相应的迁移方法。</p><p id="b4ff" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我不会在这里重复文档，但是作为一个例子，<code class="fe mz na nb nc b">(m *Migration) Up()</code>通过迁移文件夹中的每次向上迁移向前迁移数据库<em class="nr"/>，而<code class="fe mz na nb nc b">(m *Migration) Down()</code>则相反。如果您来自Rails，这一点需要记住——这里没有单一的<code class="fe mz na nb nc b">change</code>方法。每次迁移都必须有单独的up和down SQL文件，以分别应用和撤销更改。</p><p id="4241" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">简单的向上迁移可能如下所示:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nd ne l"/></div></figure><p id="f80e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">而相应的向下迁移如下所示:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nd ne l"/></div></figure><p id="4d91" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">(如果你还没猜到的话，我正在打造一个老式的脸书克隆版)。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="dbb1" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">运行迁移</h1><p id="15c0" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">我们现在有了运行迁移的代码，但是输入命令<code class="fe mz na nb nc b">go run cmd/migrate/migrate.go steps 5</code>并不方便。</p><p id="b64d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">最后，我们将创建一个简单的Makefile，为我们的迁移任务提供方便的简写。额外的好处是，每当我们更新数据库模式时，我们将自动执行转储数据库模式这一至关重要的任务。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nd ne l"/></div></figure><p id="25c6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这看起来更像Rails。少数需要变量的任务由<code class="fe mz na nb nc b">make db_migrate_steps STEPS=3</code>触发。这是一个粗糙的边缘，但对我的目的来说足够好。</p><p id="9e6b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果我们想更进一步，使之成为一个真正优雅的迁移者，我会探索使<code class="fe mz na nb nc b">migrate.go</code>与项目无关的方法(如果我们真的想推动自己，与DBMS无关)。然后我们可以安装二进制文件，并把我们的迁移运行器带到每个新项目中。</p><p id="6089" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">采用更懒惰的方法，<code class="fe mz na nb nc b">db_dump_schema</code>是拼图的最后一块。您很少希望在项目的整个生命周期中依赖于迁移，尤其是如果项目将在生产中运行的话。一年后，您将有数千个迁移文件混杂在源代码控制中，每次重建数据库时都要一个接一个地应用。</p><p id="f506" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">将当前数据库模式的转储签入源代码控制更为简洁。这样，您就可以在一个SQL文件中为DBMS提供数据库应该有的样子，而不是将一步一步的指令输入到DBMS中以最终达到所需的状态。</p><p id="26f7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">Rails是这样建立测试数据库的:它获取开发数据库的转储，并将其应用到测试环境中。这就是我选择在Makefile中快速添加的内容:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nd ne l"/></div></figure><p id="642c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在<code class="fe mz na nb nc b">db_dump_schema</code>中，我们检查当前环境是否为<code class="fe mz na nb nc b">development</code>，以确保我们不会用测试数据库的结构覆盖现有的转储。在<code class="fe mz na nb nc b">if</code>块开始的<code class="fe mz na nb nc b">@</code>只是防止<code class="fe mz na nb nc b">make</code>在命令运行时回应命令。</p><p id="06ce" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果环境是<code class="fe mz na nb nc b">development</code>，我们运行Postgres的<code class="fe mz na nb nc b">pg_dump</code>工具，在<code class="fe mz na nb nc b">SCHEMA</code>中指定输出文件。如果您没有使用Postgres，请务必查找如何从首选DBMS转储。</p><p id="4fe6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">注意每个改变数据库结构的迁移操作是如何自动调用我们的<code class="fe mz na nb nc b">pg_dump</code>方法:<code class="fe mz na nb nc b">@$(MAKE) db_dump_schema</code>。我们可以放心，因为我们签入源代码控制的模式总是与开发数据库的当前状态相匹配。(<code class="fe mz na nb nc b">@$(MAKE)</code>仅仅意味着“使用<code class="fe mz na nb nc b">make</code>运行下面的任务，而不回显命令”)。</p><p id="7fd6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">为了快速建立一个测试数据库，我编写了<code class="fe mz na nb nc b">make</code>任务<code class="fe mz na nb nc b">db_test_prepare</code>，它只不过是从转储的SQL构建模式的Postgres语法。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="aa09" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">结论</h1><p id="023b" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">这就是:为您的Go项目构建一个超快速的类似Rails的迁移运行器。<a class="ae ky" href="https://github.com/AngusGMorrison/fb-class-of-05" rel="noopener ugc nofollow" target="_blank">在这里找到源代码</a>。</p><p id="df85" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">下一步是用每个项目的配置文件将它概括成一个可安装的二进制文件，使您可以灵活地选择使用命名约定和DBMS。交给你了。</p></div></div>    
</body>
</html>