<html>
<head>
<title>Tips for Migrating a React App to TypeScript</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">将React应用程序迁移到TypeScript的提示</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/tips-for-migrating-a-react-app-to-typescript-5de2817b9731?source=collection_archive---------18-----------------------#2020-03-19">https://betterprogramming.pub/tips-for-migrating-a-react-app-to-typescript-5de2817b9731?source=collection_archive---------18-----------------------#2020-03-19</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="b25a" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">我希望在开始迁移之前就知道的事情</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/a0471983b5e713a0620f4ceca5ded492.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*JuTc-gL5XpZMZibD"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated"><a class="ae ky" href="https://unsplash.com/@7bbbailey?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">巴斯贝利</a>在<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍照。</p></figure><p id="9fb8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">所以，我现在已经做了快半年的公司项目了。在特性开发完成后，工作速度变慢了，我决定采取下一步——这是我六个月前不敢采取的——将项目“迁移”到TypeScript。</p><p id="e242" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我很幸运能够与一位思想非常开放的技术领导者和产品经理一起工作，所以在我与他们讨论了这一举措的可能优点后，我能够继续推进这一举措。</p><p id="c08a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这些都是我学到的东西，现在回想起来，我希望我在开始迁移时就知道了。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="7fcd" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">放弃</h1><ul class=""><li id="d704" class="mu mv it lb b lc mw lf mx li my lm mz lq na lu nb nc nd ne bi translated">这篇文章假设你是ts的初学者，但是它的目的不是教你TS。它的目的是给下一个想尝试类似事情的人一些建议，让他们的生活更轻松。</li><li id="b832" class="mu mv it lb b lc nf lf ng li nh lm ni lq nj lu nb nc nd ne bi translated">这篇文章假设您正在从事一个CRA项目，并且大部分设置和配置已经为您做好了。然而，大多数建议可以应用于任何React项目。</li><li id="a43e" class="mu mv it lb b lc nf lf ng li nh lm ni lq nj lu nb nc nd ne bi translated">这篇文章是基于我将一个相当大的代码库迁移到TS的经验。</li></ul></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="acb0" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">开始之前</h1><h2 id="91ab" class="nl md it bd me nm nn dn mi no np dp mm li nq nr mo lm ns nt mq lq nu nv ms nw bi translated">将tsconfig中的allowJs设置为true</h2><p id="806a" class="pw-post-body-paragraph kz la it lb b lc mw ju le lf mx jx lh li nx lk ll lm ny lo lp lq nz ls lt lu im bi translated">仅此而已。这将确保您在启用类型检查器时不会淹没在红色中，并允许您逐渐迁移，让您保留现有的<code class="fe oa ob oc od b">.js</code>文件，直到它们到来。</p><h2 id="92cf" class="nl md it bd me nm nn dn mi no np dp mm li nq nr mo lm ns nt mq lq nu nv ms nw bi translated">在src目录中创建一个global.d.ts文件</h2><p id="c744" class="pw-post-body-paragraph kz la it lb b lc mw ju le lf mx jx lh li nx lk ll lm ny lo lp lq nz ls lt lu im bi translated">这将派上用场，因为你很可能想要<a class="ae ky" href="https://www.typescriptlang.org/docs/handbook/declaration-merging.html" rel="noopener ugc nofollow" target="_blank">增加或扩展</a>你正在使用的现有库的类型。</p><h2 id="b14d" class="nl md it bd me nm nn dn mi no np dp mm li nq nr mo lm ns nt mq lq nu nv ms nw bi translated">在src目录中创建一个custom.d.ts文件</h2><p id="ee33" class="pw-post-body-paragraph kz la it lb b lc mw ju le lf mx jx lh li nx lk ll lm ny lo lp lq nz ls lt lu im bi translated">为了能够<a class="ae ky" href="https://webpack.js.org/guides/typescript/#importing-other-assets" rel="noopener ugc nofollow" target="_blank">导入不是代码模块</a>的文件，例如图像文件、<code class="fe oa ob oc od b">.json</code>文件等，您将需要这个。为了帮助你开始，只需将这个添加到你的<code class="fe oa ob oc od b">.custom.d.ts</code>文件中:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oe of l"/></div></figure><p id="c643" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">瞧，现在你可以在你的代码模块中导入<code class="fe oa ob oc od b">.svg</code>和<code class="fe oa ob oc od b">.json</code>文件，而TS不会向你抛出错误。</p><h2 id="f908" class="nl md it bd me nm nn dn mi no np dp mm li nq nr mo lm ns nt mq lq nu nv ms nw bi translated">如果您想启用noImplicitAny和no-explicit-any，请在开始之前执行</h2><p id="1eaf" class="pw-post-body-paragraph kz la it lb b lc mw ju le lf mx jx lh li nx lk ll lm ny lo lp lq nz ls lt lu im bi translated"><code class="fe oa ob oc od b">noImplicitAny</code>是一个<a class="ae ky" href="https://www.typescriptlang.org/docs/handbook/compiler-options.html" rel="noopener ugc nofollow" target="_blank">编译器选项</a>，它会在带有隐含<code class="fe oa ob oc od b">any</code>类型的表达式和声明中引发错误。</p><p id="62cd" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe oa ob oc od b">no-explicit-any</code>是一个<code class="fe oa ob oc od b"><a class="ae ky" href="https://github.com/typescript-eslint/typescript-eslint/blob/master/packages/eslint-plugin/docs/rules/no-explicit-any.md" rel="noopener ugc nofollow" target="_blank">eslint</a></code> <a class="ae ky" href="https://github.com/typescript-eslint/typescript-eslint/blob/master/packages/eslint-plugin/docs/rules/no-explicit-any.md" rel="noopener ugc nofollow" target="_blank">规则</a>，不允许你定义任何东西为<code class="fe oa ob oc od b">any</code>类型。</p><p id="3625" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果您启用了这些选项，<code class="fe oa ob oc od b">unknown</code>类型将成为您的朋友。</p><p id="0976" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">理想情况下，应该从一开始就启用这些选项。无论如何，不要在迁移过程中启用它们。我犯了那个错误，结果突然不得不花很多很多时间去解决我“强加”给自己的很多错误。当您还在迁移过程中时，可能会非常沮丧。</p><h2 id="19a2" class="nl md it bd me nm nn dn mi no np dp mm li nq nr mo lm ns nt mq lq nu nv ms nw bi translated">设置您的eslint配置以用于TS</h2><p id="589b" class="pw-post-body-paragraph kz la it lb b lc mw ju le lf mx jx lh li nx lk ll lm ny lo lp lq nz ls lt lu im bi translated">我碰巧对<code class="fe oa ob oc od b">eslint</code>的默认<code class="fe oa ob oc od b">no-unused-vars</code>规则和TS有问题。原来TS有一个特定的<code class="fe oa ob oc od b"><a class="ae ky" href="https://github.com/typescript-eslint/typescript-eslint/blob/master/packages/eslint-plugin/docs/rules/no-unused-vars.md" rel="noopener ugc nofollow" target="_blank">no-unused-vars</a></code>规则。启用此选项，禁用默认选项。</p><h2 id="7879" class="nl md it bd me nm nn dn mi no np dp mm li nq nr mo lm ns nt mq lq nu nv ms nw bi translated">确定你将如何定义你的类型</h2><p id="f8cf" class="pw-post-body-paragraph kz la it lb b lc mw ju le lf mx jx lh li nx lk ll lm ny lo lp lq nz ls lt lu im bi translated">您将使用接口还是类型？您是将类型写在代码文件中还是作为一个单独的文件？我建议你在开始之前确定这些细节，因为你不想中途改变主意，不得不修改你已经处理过的所有文件。</p><p id="a3d1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我的建议是使用类型，除非接口是绝对必要的，并且将类型定义与组件文件本身分开。</p><p id="6efd" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我应用的系统如下:</p><ul class=""><li id="83c9" class="mu mv it lb b lc ld lf lg li og lm oh lq oi lu nb nc nd ne bi translated">如果该文件是一个React组件文件，在同一个目录中创建一个单独的<code class="fe oa ob oc od b">types.d.ts</code>文件，并将所有类型定义放在那里——除了<code class="fe oa ob oc od b">Props</code>类型定义(我将它保存在组件文件本身中，因为它便于随时获取props定义)。</li><li id="44a6" class="mu mv it lb b lc nf lf ng li nh lm ni lq nj lu nb nc nd ne bi translated">如果文件不是React组件类型，声明将与代码一起出现。没有单独的<code class="fe oa ob oc od b">types.d.ts</code>文件。除非类型太多，导致代码文件非常混乱。然后在自己的文件中取出。</li></ul><h2 id="770a" class="nl md it bd me nm nn dn mi no np dp mm li nq nr mo lm ns nt mq lq nu nv ms nw bi translated">阅读文档</h2><p id="30b0" class="pw-post-body-paragraph kz la it lb b lc mw ju le lf mx jx lh li nx lk ll lm ny lo lp lq nz ls lt lu im bi translated">说真的。至少读一些重要的部分，比如:</p><ul class=""><li id="d5e6" class="mu mv it lb b lc ld lf lg li og lm oh lq oi lu nb nc nd ne bi translated"><a class="ae ky" href="https://www.typescriptlang.org/docs/handbook/basic-types.html" rel="noopener ugc nofollow" target="_blank">基本类型</a></li><li id="24ff" class="mu mv it lb b lc nf lf ng li nh lm ni lq nj lu nb nc nd ne bi translated"><a class="ae ky" href="https://www.typescriptlang.org/docs/handbook/generics.html" rel="noopener ugc nofollow" target="_blank">仿制药</a></li><li id="6730" class="mu mv it lb b lc nf lf ng li nh lm ni lq nj lu nb nc nd ne bi translated"><a class="ae ky" href="https://www.typescriptlang.org/docs/handbook/advanced-types.html" rel="noopener ugc nofollow" target="_blank">高级类型</a> —尤其是<a class="ae ky" href="https://www.typescriptlang.org/docs/handbook/advanced-types.html#intersection-types" rel="noopener ugc nofollow" target="_blank">交集</a>和<a class="ae ky" href="https://www.typescriptlang.org/docs/handbook/advanced-types.html#union-types" rel="noopener ugc nofollow" target="_blank">联合</a>的工作方式，因为它们并不与联合和交集的数学定义精确地1:1映射。</li><li id="52a6" class="mu mv it lb b lc nf lf ng li nh lm ni lq nj lu nb nc nd ne bi translated"><a class="ae ky" href="https://www.typescriptlang.org/docs/handbook/type-compatibility.html" rel="noopener ugc nofollow" target="_blank">类型兼容性</a></li><li id="eb1e" class="mu mv it lb b lc nf lf ng li nh lm ni lq nj lu nb nc nd ne bi translated"><a class="ae ky" href="https://www.typescriptlang.org/docs/handbook/utility-types.html" rel="noopener ugc nofollow" target="_blank">实用工具类型</a>——那些<em class="nk">非常</em>方便。给他们一个眼神，至少知道他们的存在。</li><li id="7636" class="mu mv it lb b lc nf lf ng li nh lm ni lq nj lu nb nc nd ne bi translated">发行说明——我发现有时新版本的发行说明中提到的东西在文档中并没有提到。例如，这个<a class="ae ky" href="https://www.typescriptlang.org/docs/handbook/release-notes/typescript-3-7.html#assertion-functions" rel="noopener ugc nofollow" target="_blank">非常方便的断言函数功能</a>是在3.7版本中添加的，并且(据我所知)在文档中没有提到。</li></ul><h2 id="314c" class="nl md it bd me nm nn dn mi no np dp mm li nq nr mo lm ns nt mq lq nu nv ms nw bi translated">当你编码时，准备开始更彻底</h2><p id="325c" class="pw-post-body-paragraph kz la it lb b lc mw ju le lf mx jx lh li nx lk ll lm ny lo lp lq nz ls lt lu im bi translated">TypeScript最终会让你对编码时所做的一些假设更加透彻。在你看来，对你的代码来说正确的假设对TS来说是不够的。TypeScript将总是要求通过编写更多的代码来验证这些假设，主要是以如下形式:</p><pre class="kj kk kl km gt oj od ok ol aw om bi"><span id="8ac0" class="nl md it od b gy on oo l op oq">if (notCondition) { <br/> throw new Error()<br/>}</span><span id="65be" class="nl md it od b gy or oo l op oq">// Otherwise all is well</span></pre><p id="83ec" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">你会习惯的，最终，它会自然而然的来到你身边。</p><h2 id="050a" class="nl md it bd me nm nn dn mi no np dp mm li nq nr mo lm ns nt mq lq nu nv ms nw bi translated">准备好犯错吧</h2><p id="7709" class="pw-post-body-paragraph kz la it lb b lc mw ju le lf mx jx lh li nx lk ll lm ny lo lp lq nz ls lt lu im bi translated">接受这个事实，99.999%的时候，TS编译器是对的，而你是错的。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="0cd4" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">实际的迁移</h1><h2 id="a91b" class="nl md it bd me nm nn dn mi no np dp mm li nq nr mo lm ns nt mq lq nu nv ms nw bi translated">从小处着手</h2><p id="9af5" class="pw-post-body-paragraph kz la it lb b lc mw ju le lf mx jx lh li nx lk ll lm ny lo lp lq nz ls lt lu im bi translated">当您从JS过渡到TS时，您希望从小处着手。看到你的实用函数目录了吗？到目前为止，它们是您可以开始迁移到TS的最简单的东西。</p><p id="ec88" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">一旦你迁移了一个简单的函数，看看这个函数在哪里被使用，还有什么其他的文件导入了它(编译器可能会在这时抛出一些错误让你知道)。</p><p id="5c7b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">继续迁移这些文件并重复这个过程，本质上是向上爬(向下？)依存关系树。如果您到达一个对于这个迁移阶段来说太复杂的文件，不要害怕在它的第一行加上一个<code class="fe oa ob oc od b"><a class="ae ky" href="http://twitter.com/ts" rel="noopener ugc nofollow" target="_blank">@ts</a>-nocheck</code>指令，以后再迁移它。</p><h2 id="40ed" class="nl md it bd me nm nn dn mi no np dp mm li nq nr mo lm ns nt mq lq nu nv ms nw bi translated">不要害怕做类型断言</h2><p id="6e17" class="pw-post-body-paragraph kz la it lb b lc mw ju le lf mx jx lh li nx lk ll lm ny lo lp lq nz ls lt lu im bi translated">TS中的类型断言类似于其他语言中的类型转换。本质上，你是在告诉TS编译器你知道得更清楚，在这种情况下，一个特定的变量——即使它<em class="nk">可能</em>有许多类型——除了一个特定的类型之外不能是任何别的。有时候，事实上你更清楚。但只是有时候。</p><p id="891b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我发现这在使用提供一些<a class="ae ky" href="https://reactjs.org/docs/hooks-reference.html#usecontext" rel="noopener ugc nofollow" target="_blank">上下文</a>值的React挂钩时很有用。当您初始化<code class="fe oa ob oc od b">Context</code>时，上下文值以一个“缺省”值开始，它可能不总是与传递给提供者的实际值兼容。在本文的<a class="ae ky" href="https://dev.to/mitchkarajohn/working-with-react-context-providers-in-typescript-1fk0" rel="noopener ugc nofollow" target="_blank">中有更多相关信息。</a></p><p id="978f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">自定义<a class="ae ky" href="https://www.typescriptlang.org/docs/handbook/advanced-types.html#type-guards-and-differentiating-types" rel="noopener ugc nofollow" target="_blank">类型保护</a>和<a class="ae ky" href="https://www.typescriptlang.org/docs/handbook/release-notes/typescript-3-7.html#assertion-functions" rel="noopener ugc nofollow" target="_blank">断言函数</a>也非常有助于你帮助TS做出正确的类型断言。</p><h2 id="54bc" class="nl md it bd me nm nn dn mi no np dp mm li nq nr mo lm ns nt mq lq nu nv ms nw bi translated">不要将提供的FC类型用于React组件</h2><p id="7a12" class="pw-post-body-paragraph kz la it lb b lc mw ju le lf mx jx lh li nx lk ll lm ny lo lp lq nz ls lt lu im bi translated">我强烈建议您不要像这样定义React组件:</p><pre class="kj kk kl km gt oj od ok ol aw om bi"><span id="561f" class="nl md it od b gy on oo l op oq">const Comp = FC&lt;Props&gt;(props) =&gt; { …. }</span></pre><p id="808f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我发现它的用法比什么都麻烦，因为它对你的组件做了一些相当武断的假设(比如总是有<code class="fe oa ob oc od b">children</code>道具，并且不能很好地与<code class="fe oa ob oc od b">PropTypes</code>一起工作)，并且通常会剥夺你对以你想要的方式定义组件的一些控制。请改用这个:</p><pre class="kj kk kl km gt oj od ok ol aw om bi"><span id="c8e4" class="nl md it od b gy on oo l op oq">function Comp(props: Props) { …. }</span></pre><p id="c4f2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">TS足够聪明，可以推断出返回类型本身，并且对于所有意图和目的，这是一个有效的React组件，您可以在编译器需要React组件的任何情况下使用它。</p><h2 id="c1b0" class="nl md it bd me nm nn dn mi no np dp mm li nq nr mo lm ns nt mq lq nu nv ms nw bi translated">保持你的PropTypes</h2><p id="657e" class="pw-post-body-paragraph kz la it lb b lc mw ju le lf mx jx lh li nx lk ll lm ny lo lp lq nz ls lt lu im bi translated">虽然TS对于确保您在开发期间不犯任何类型相关的错误非常有用，但是<code class="fe oa ob oc od b">PropTypes</code>对于让您了解运行期间的类型相关错误非常有用。你会问，如果使用TS进行开发，在运行时怎么会有类型相关的错误呢？考虑这个场景:</p><ul class=""><li id="4c76" class="mu mv it lb b lc ld lf lg li og lm oh lq oi lu nb nc nd ne bi translated">您已经将TS中的API响应类型定义为带回一个应该是<code class="fe oa ob oc od b">number</code>的字段。您还将您的相关<code class="fe oa ob oc od b">PropTypes</code>字段定义成这样。一切都好。</li><li id="2306" class="mu mv it lb b lc nf lf ng li nh lm ni lq nj lu nb nc nd ne bi translated">现在，想象一下，如果您的API在那个字段中返回一个<code class="fe oa ob oc od b">string</code>而不是一个<code class="fe oa ob oc od b">number</code>。如果你去掉了<code class="fe oa ob oc od b">PropTypes</code>，你永远不会意识到这个错误，直到应用程序在某个时候崩溃。使用<code class="fe oa ob oc od b">PropTypes</code>，如果出现任何此类不匹配，您将在浏览器控制台中得到一个非常有用的警告。</li></ul><p id="51f9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果你在一个被弹出的CRA项目上工作，或者可以访问<code class="fe oa ob oc od b">babelrc</code>文件，要知道有一个<a class="ae ky" href="https://www.npmjs.com/package/babel-plugin-typescript-to-proptypes" rel="noopener ugc nofollow" target="_blank">插件</a>可以自动将你的ts类型转换成<code class="fe oa ob oc od b">PropTypes</code>，这样你就不必手动更新两者。</p><h2 id="72bc" class="nl md it bd me nm nn dn mi no np dp mm li nq nr mo lm ns nt mq lq nu nv ms nw bi translated">导出您的所有类型</h2><p id="c289" class="pw-post-body-paragraph kz la it lb b lc mw ju le lf mx jx lh li nx lk ll lm ny lo lp lq nz ls lt lu im bi translated">即使您最终没有将它们全部导入到其他文件中，也要养成导出它们的习惯，因为您永远不知道何时会需要在另一个模块中定义的类型。</p><h2 id="9518" class="nl md it bd me nm nn dn mi no np dp mm li nq nr mo lm ns nt mq lq nu nv ms nw bi translated">不要害怕使用泛型</h2><p id="e9ba" class="pw-post-body-paragraph kz la it lb b lc mw ju le lf mx jx lh li nx lk ll lm ny lo lp lq nz ls lt lu im bi translated">TS <a class="ae ky" href="https://www.typescriptlang.org/docs/handbook/generics.html" rel="noopener ugc nofollow" target="_blank">泛型</a>非常有用，你也可以拥有泛型React组件。例如:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oe of l"/></div></figure><p id="c2a2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">根据我的经验，如果一个React组件是对某个东西的抽象，那么可以放心地假设这个组件的类型定义将是一个泛型。</p><h2 id="3e77" class="nl md it bd me nm nn dn mi no np dp mm li nq nr mo lm ns nt mq lq nu nv ms nw bi translated">阅读您使用的库的类型定义</h2><p id="0e9a" class="pw-post-body-paragraph kz la it lb b lc mw ju le lf mx jx lh li nx lk ll lm ny lo lp lq nz ls lt lu im bi translated">如有疑问，请务必阅读您使用的库的类型定义。这也将帮助您了解如何定义自己的组件类型，以便与外部库中的组件一起使用。</p><h2 id="5029" class="nl md it bd me nm nn dn mi no np dp mm li nq nr mo lm ns nt mq lq nu nv ms nw bi translated">您不必总是定义返回类型</h2><p id="47c7" class="pw-post-body-paragraph kz la it lb b lc mw ju le lf mx jx lh li nx lk ll lm ny lo lp lq nz ls lt lu im bi translated">TS(大部分)足够聪明，可以正确地推断出函数返回值的类型。就我个人而言，我也喜欢定义返回值，但那是因为我有某种强迫症。</p><p id="0357" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">请注意，有时您必须严格定义返回值才能正确工作。</p><h2 id="0d12" class="nl md it bd me nm nn dn mi no np dp mm li nq nr mo lm ns nt mq lq nu nv ms nw bi translated">为您的API响应进行类型定义</h2><p id="daef" class="pw-post-body-paragraph kz la it lb b lc mw ju le lf mx jx lh li nx lk ll lm ny lo lp lq nz ls lt lu im bi translated">它们将极大地帮助你，因为你很可能会在你的应用程序中使用服务器提供的数据。</p><h2 id="15c1" class="nl md it bd me nm nn dn mi no np dp mm li nq nr mo lm ns nt mq lq nu nv ms nw bi translated">学习阅读TS编译器错误</h2><p id="b234" class="pw-post-body-paragraph kz la it lb b lc mw ju le lf mx jx lh li nx lk ll lm ny lo lp lq nz ls lt lu im bi translated">TS错误可能是令人生畏的。然而，如何阅读它们有一个“诀窍”。请务必阅读错误消息的第一行和最后几行。如果它仍然对你没有意义，阅读整个错误。通常，只要阅读这些行就能给你理解错误所需要的信息。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="e6ce" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">随机打字提示</h1><h2 id="ce34" class="nl md it bd me nm nn dn mi no np dp mm li nq nr mo lm ns nt mq lq nu nv ms nw bi translated">Do (TypeA | TypeB)[]，not TypeA[]| TypeB[]</h2><p id="905b" class="pw-post-body-paragraph kz la it lb b lc mw ju le lf mx jx lh li nx lk ll lm ny lo lp lq nz ls lt lu im bi translated">当您有一个数组，其类型可以是数组<code class="fe oa ob oc od b">TypeA</code>或数组<code class="fe oa ob oc od b">TypeB</code>时，将其声明为:</p><pre class="kj kk kl km gt oj od ok ol aw om bi"><span id="a606" class="nl md it od b gy on oo l op oq">const arr: (TypeA | TypeB)[]</span></pre><p id="898e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">而不是:</p><pre class="kj kk kl km gt oj od ok ol aw om bi"><span id="aaae" class="nl md it od b gy on oo l op oq">const arr: TypeA[] | TypeB[]</span></pre><p id="1279" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这两个声明之间有一个<a class="ae ky" href="https://stackoverflow.com/a/49511416/4651083" rel="noopener ugc nofollow" target="_blank">微妙的区别</a>，如果你试图在<code class="fe oa ob oc od b">arr</code>上<code class="fe oa ob oc od b">.map()</code>，第二个将导致错误。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="67b6" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">结束语</h1><p id="3508" class="pw-post-body-paragraph kz la it lb b lc mw ju le lf mx jx lh li nx lk ll lm ny lo lp lq nz ls lt lu im bi translated">事实上，你决定迁移你的应用程序，而不是从一开始就用ts编写，这可能掩盖了一开始就使用TS的好处，因为你的整个代码库已经准备好了。</p><p id="a0d5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">然而，一旦你继续开发，你<em class="nk">就会</em>看到优点，现在你所有的新代码都必须遵守ts规则。</p><p id="3ea8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">请记住，您的代码现在在处理错误情况方面更加彻底了。结合一些适当的测试，这将确保您的代码尽可能健壮。</p><p id="a40a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">感谢您的阅读！</p></div></div>    
</body>
</html>