<html>
<head>
<title>Test Cases and Test Coverage for High Order Components</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">高阶组件的测试用例及测试覆盖</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/test-cases-and-test-coverage-for-high-order-components-2fb6fbddc33c?source=collection_archive---------7-----------------------#2020-07-28">https://betterprogramming.pub/test-cases-and-test-coverage-for-high-order-components-2fb6fbddc33c?source=collection_archive---------7-----------------------#2020-07-28</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="639d" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">关于如何为高阶组件编写测试用例以及如何测量测试覆盖率的例子</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/7d6cc3e7df04f5573e26100dc5be8a99.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*fwYQOGc0iUZqAJpAl5T8gA.jpeg"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">照片由<a class="ae ky" href="https://unsplash.com/@the_roaming_platypus?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> timJ </a>在<a class="ae ky" href="https://unsplash.com/s/photos/spectacular?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</p></figure><p id="f4fe" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们最近写了一篇关于<a class="ae ky" href="https://medium.com/better-programming/headless-ui-components-a-journey-with-high-order-components-render-props-and-custom-hooks-811c9677b4cf" rel="noopener">无头UI组件</a>的文章，探讨了高阶组件(hoc)和定制钩子。下一个问题是如何编写<a class="ae ky" href="https://medium.com/better-programming/testing-your-components-in-react-967abda02396" rel="noopener">测试用例</a>和测量测试覆盖率。虽然在另一篇文章的<a class="ae ky" href="https://medium.com/better-programming/test-custom-hooks-using-react-hooks-testing-library-a3a37031a9be" rel="noopener">中介绍了测试定制钩子，但是在这里，我们将通过例子介绍如何使用Jest和React测试库来测试hoc。</a></p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="204f" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">术语</h1><p id="28b7" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated"><strong class="lb iu">单元测试用例</strong>:开发人员编写并运行的自动化测试用例。他们隔离程序的每个部分，并验证各个部分是正确的。</p><p id="cc4b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu">集成测试用例</strong>:将单个部分组合起来并作为一个组进行测试的自动化测试用例。</p><p id="0d1b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu">测试覆盖率</strong>:一个度量由一组测试用例执行的测试量的指标。收集关于语句、分支等的执行百分比的信息。也有迹象表明哪些线路尚待测试。</p><p id="0a41" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><a class="ae ky" href="https://github.com/facebook/jest" rel="noopener ugc nofollow" target="_blank"> <strong class="lb iu"> Jest </strong> </a>:保证任何JavaScript代码库正确性的JavaScript测试框架。它是最受欢迎的测试程序之一，也是React项目的默认选择。</p><p id="d8fb" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><a class="ae ky" href="https://github.com/testing-library/react-testing-library" rel="noopener ugc nofollow" target="_blank"> <strong class="lb iu"> React测试库</strong> </a>:测试React组件的轻量级解决方案。它在react-dom和react-dom/test-utils的基础上提供了实用函数，通过react组件的使用方式来测试它们。React测试库以及Jest运行单元测试案例和集成测试案例。</p><p id="2e04" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><a class="ae ky" href="https://reactjs.org/docs/higher-order-components.html" rel="noopener ugc nofollow" target="_blank"> <strong class="lb iu">高阶分量</strong> </a>:取一个分量，返回一个新分量的函数。这是一种复用组件逻辑的组合方法。</p><p id="4cf4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><a class="ae ky" href="https://medium.com/better-programming/10-fun-facts-about-create-react-app-eb7124aa3785" rel="noopener"> <strong class="lb iu">创建React App </strong> </a>:搭建React项目的快速方法。这样，我们专注于代码，而不是构建工具。它有内置的Jest和React测试库，是<code class="fe mz na nb nc b">package.json</code>中<code class="fe mz na nb nc b"><a class="ae ky" href="https://medium.com/better-programming/package-jsons-dependencies-in-depth-a1f0637a3129" rel="noopener">dependencies</a></code>的一部分:</p><pre class="kj kk kl km gt nd nc ne nf aw ng bi"><span id="d555" class="nh md it nc b gy ni nj l nk nl">"dependencies": {<br/>  "@testing-library/jest-dom": "^4.2.4",<br/>  "@testing-library/react": "^9.5.0",<br/>  "@testing-library/user-event": "^7.2.1"<br/>}</span></pre></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="ee90" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">带颜色的测试和覆盖范围</h1><p id="ebd3" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">在无头UI组件的文章中，我们编写了<code class="fe mz na nb nc b">withColor</code>组件。这是一个为底层组件设置颜色的包装器:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nm nn l"/></div></figure><p id="a998" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在一个简化和隔离的环境中，编写测试用例类似于编写实际的代码。对于一个特设，我们需要创建一个可以显示颜色的要包装的组件:<code class="fe mz na nb nc b">&lt;div&gt;Test Color&lt;/div&gt;</code>。该组件用于在以下测试代码的第6行生成<code class="fe mz na nb nc b">withColor</code> HOC:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nm nn l"/></div></figure><p id="b3bb" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">第7-10行呈现了一个快照测试用例，它拍摄了一个快照，并将其存储在<code class="fe mz na nb nc b">__snapshots__</code>目录下作为引用(选项<code class="fe mz na nb nc b">—- updateSnapshot, or -u</code>)。第9行将新快照与引用进行比较，并验证UI没有意外更改。</p><p id="95b5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这是生成的参考快照，它类似于浏览器中的表示:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nm nn l"/></div></figure><p id="5485" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">该快照为接下来的两个测试用例提供了清晰的画面:</p><ul class=""><li id="7554" class="no np it lb b lc ld lf lg li nq lm nr lq ns lu nt nu nv nw bi translated">当没有指定颜色时，验证父节点是否具有默认颜色<code class="fe mz na nb nc b">red</code>(第12-15行)。</li><li id="f606" class="no np it lb b lc nx lf ny li nz lm oa lq ob lu nt nu nv nw bi translated">当颜色被指定为<code class="fe mz na nb nc b">blue</code>时，验证父节点具有颜色<code class="fe mz na nb nc b">blue</code>(第17-20行)。</li></ul><p id="3f4c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">然后我们可以运行测试:<code class="fe mz na nb nc b">npm test</code>。</p><p id="5b70" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">它将在Create React App中运行<code class="fe mz na nb nc b">App.test.js</code>和<code class="fe mz na nb nc b">withColor.test.js</code>。我们怎么能只运行我们的特设测试用例呢？</p><p id="1436" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe mz na nb nc b">npm</code>有一个<code class="fe mz na nb nc b">—-</code>选项，它将<code class="fe mz na nb nc b">--</code>之后的所有参数直接传递给脚本。</p><p id="2d1c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">以下是一些帮助消息:</p><pre class="kj kk kl km gt nd nc ne nf aw ng bi"><span id="6324" class="nh md it nc b gy ni nj l nk nl">$ npm test -- --help</span><span id="314f" class="nh md it nc b gy oc nj l nk nl">Usage: test.js [--config=&lt;pathToConfigFile&gt;] [TestPathPattern]</span><span id="9cf6" class="nh md it nc b gy oc nj l nk nl">Options:<br/>  --help, -h                    Show help                          <br/>  --version, -v                 Print the version and exit             <br/>  --collectCoverage             Alias for --coverage.                  <br/>  --collectCoverageFrom         A glob pattern relative to &lt;rootDir&gt; matching the files that coverage info needs to be collected from.<br/>  --coverage                    Indicates that test coverage information should be collected and reported in the output.                                                                                    <br/>  --testMatch                   The glob patterns Jest uses to detect test files.  <br/>  --updateSnapshot, -u          Use this flag to re-record snapshots.</span></pre><p id="2296" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">然后，下面的命令将使用<code class="fe mz na nb nc b">with*.test.js</code>的命名约定运行所有特设测试:</p><pre class="kj kk kl km gt nd nc ne nf aw ng bi"><span id="a491" class="nh md it nc b gy ni nj l nk nl">npm test -- --testMatch="&lt;rootDir&gt;/src/with*.test.js" --collectCoverage --collectCoverageFrom="src/with*.js"</span></pre><p id="1f1a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">运行该命令会产生以下输出。我们很高兴地看到<code class="fe mz na nb nc b">withColor.js</code>已经通过了语句、分支、函数和行的100%覆盖率测试。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi od"><img src="../Images/3ed7f7623a1e105bc7764a69bf09727c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*4Gvq5B8PYNM8qwo4_t_AsQ.png"/></div></div></figure></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="c53e" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">withFontStyle的测试和覆盖率</h1><p id="c4da" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">让我们继续另一个特设，<code class="fe mz na nb nc b">withFontStyle</code>。这是一个为底层组件设置字体样式的包装器:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nm nn l"/></div></figure><p id="9405" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">运行测试命令，我们发现<code class="fe mz na nb nc b">withFontStyle.js</code>已经覆盖了<code class="fe mz na nb nc b">0%</code>。它清楚地列举了上面的代码需要在第三行、第四行和第五行进行测试。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi od"><img src="../Images/c74f2ea8ec425422f471a27c04b8cfba.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*w7lCtQaCzsf7UhAB_uPfTQ.png"/></div></div></figure><p id="78d2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们创建一个可以显示字体样式的组件:<code class="fe mz na nb nc b">&lt;div&gt;Test Font Style&lt;/div&gt;</code>。该组件用于在下面的测试代码中的第六行生成<code class="fe mz na nb nc b">withFontStyle</code> HOC。</p><p id="8005" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">第33行创建了另一个组件。该组件由<code class="fe mz na nb nc b">withColor</code>和<code class="fe mz na nb nc b">withFontStyle</code>两者包裹:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nm nn l"/></div></figure><p id="4ae3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">下面是生成的快照，一个用于<code class="fe mz na nb nc b">withFontStyle</code>测试，另一个用于测试<code class="fe mz na nb nc b">withColor</code>和<code class="fe mz na nb nc b">withFontStyle</code>的组合:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nm nn l"/></div></figure><p id="bb9a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在我们对<code class="fe mz na nb nc b">withFontStyle.js</code>也有了100%的覆盖率:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi od"><img src="../Images/14fc9563f56d607614f39823725a5696.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*dPqqHHD0S8l_H9ZS27Dgug.png"/></div></div></figure></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="83df" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">withMultipleValue的测试和覆盖率</h1><p id="f98a" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated"><code class="fe mz na nb nc b">withMultipleValue</code>写的有点不一样。它没有添加<code class="fe mz na nb nc b">div</code>包装器，而是修改了底层组件的属性:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nm nn l"/></div></figure><p id="d0b2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">以下是测试案例:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nm nn l"/></div></figure><p id="8db6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这是生成的快照:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nm nn l"/></div></figure><p id="f56d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们运行测试命令，得到以下结果:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi od"><img src="../Images/1bcba45d731fb4069f27f639fc2ebf32.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*7rErzVxAY1hKRC-IA-JUXQ.png"/></div></div></figure><p id="dc6b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">上面写着声明覆盖范围是<code class="fe mz na nb nc b">75%</code>。<code class="fe mz na nb nc b">withMultipleValue.js </code>的第11行尚未测试。</p><p id="5d0c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">因此，我们在第27-40行添加测试用例来调用<code class="fe mz na nb nc b">onClick</code>回调:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nm nn l"/></div></figure><p id="e244" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们再次运行测试——这是覆盖率报告:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi od"><img src="../Images/a9c8e8aab64e1a6befeaf5c5067f4d92.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*VWmvAzx0YVjFSqCu3yHIlg.png"/></div></div></figure><p id="d508" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">报表覆盖率100%，但分支机构没有完全覆盖。</p><p id="987a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe mz na nb nc b">withMultipleValue.js</code>中的第六行是条件(三元)运算符<code class="fe mz na nb nc b">Number(props.value) ? props.value * factor : factor</code>。我们已经测试了<code class="fe mz na nb nc b">truthy</code>条件，但没有测试<code class="fe mz na nb nc b">falsy</code>条件。那么解决方案是在下面的第20-25行添加测试用例，没有初始值。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nm nn l"/></div></figure><p id="7353" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在，我们实现了所有项目的100%覆盖率:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi od"><img src="../Images/a0a6f3faaffa8509ebd8a308d9e4bd42.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*591gHWKX_8V21ab448u6ZA.png"/></div></div></figure></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="3d71" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">结论</h1><p id="b3a7" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">我们已经使用了特别的例子来说明如何为HOC编写测试用例。同时，我们还展示了如何提高测试覆盖率。</p><p id="8b16" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在现实世界中，事情通常更复杂。有异步代码、不确定的执行序列、第三方库等等。可能无法达到100%的覆盖率，70% — 80%的覆盖率是一个合理的目标，尽管值得努力追求高目标。通常，它在最后10%-20%的覆盖范围内更有效。</p><p id="0ce0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">感谢阅读。我希望这有所帮助。你可以在这里看到我的其他媒体出版物<a class="ae ky" href="https://medium.com/@jenniferfubook/jennifer-fus-web-development-publications-1a887e4454af" rel="noopener"/>。</p></div></div>    
</body>
</html>