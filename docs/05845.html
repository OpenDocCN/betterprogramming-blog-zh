<html>
<head>
<title>Is It Safe to Delete Kubernetes Pods Under Load?</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">在负载下删除Kubernetes Pods安全吗？</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/is-it-safe-to-delete-kubernetes-pods-under-load-83c85d268024?source=collection_archive---------6-----------------------#2020-08-11">https://betterprogramming.pub/is-it-safe-to-delete-kubernetes-pods-under-load-83c85d268024?source=collection_archive---------6-----------------------#2020-08-11</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="5569" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated"><em class="ki">TL；大卫:是的，如果一切都设置正确的话。继续阅读，看看你是否有</em></h2></div><figure class="kk kl km kn gt ko gh gi paragraph-image"><div role="button" tabindex="0" class="kp kq di kr bf ks"><div class="gh gi kj"><img src="../Images/1dc2c727aa17e567c2bd68fab9577fd4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*QXNIqsgp0o1TkM7znuv3Eg.gif"/></div></div><p class="kv kw gj gh gi kx ky bd b be z dk translated">图片来源:作者</p></figure><p id="a92d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们都在努力构建弹性和自我修复的应用程序，但偶尔我们会犯一个错误，不得不重新开始。希望我们有时间解决这个问题，但在此之前，我们可能需要手动干预。在本文中，我们了解当我们删除一个正在提供实时流量服务的<a class="ae lv" href="https://kubernetes.io/" rel="noopener ugc nofollow" target="_blank"> Kubernetes </a> (K8s) pod时会发生什么。然后，我们可以将这些知识应用到我们的运营中，这样我们就不会影响客户的体验。</p></div><div class="ab cl lw lx hx ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="im in io ip iq"><h1 id="1261" class="md me it bd mf mg mh mi mj mk ml mm mn jz mo ka mp kc mq kd mr kf ms kg mt mu bi translated">Pod生命周期</h1><p id="2839" class="pw-post-body-paragraph kz la it lb b lc mv ju le lf mw jx lh li mx lk ll lm my lo lp lq mz ls lt lu im bi translated">首先，让我们了解当一个pod被删除时实际上会发生什么。</p><p id="2678" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">当容器被删除时，Kubernetes向容器中的流程发送两个信号。第一个是<code class="fe na nb nc nd b">SIGTERM</code>，后面是<code class="fe na nb nc nd b">SIGKILL</code>。<code class="fe na nb nc nd b">SIGTERM</code>有点像委婉地要求进程关闭，而<code class="fe na nb nc nd b">SIGKILL</code>立即停止了进程。我们可以监听<code class="fe na nb nc nd b">SIGTERM</code>，整理我们正在使用的任何资源，比如数据库和其他连接。应用程序不应在收到<code class="fe na nb nc nd b">SIGTERM</code>时立即关闭。相反，它们应该停止接受新的请求，等待现有请求完成。如果有任何后台任务正在运行，该进程也应该等待它们完成后再退出。</p><p id="fb05" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">到目前为止我们只提到了<code class="fe na nb nc nd b">SIGTERM</code>。如果应用程序在收到该信号后退出时间过长，K8s会发送一个<code class="fe na nb nc nd b">SIGKILL</code>信号。在完美的设置中，这不会被发送到应用程序，因为它会优雅地退出。如果真的发生这种情况，很可能请求会被中断，客户会不高兴。您可以使用容器的<code class="fe na nb nc nd b">terminationGracePeriodSeconds</code>设置来配置K8s在发送<code class="fe na nb nc nd b">SIGKILL</code>之前等待的时间。</p><p id="e3f6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果应用程序是K8s服务的一部分或启用了入口，当pod被删除时，它首先从流量中移除。这允许应用程序处理<code class="fe na nb nc nd b">SIGTERM</code>信号，并且在该过程中不接收新的请求。通过这样做，K8s允许我们向客户提供无缝体验，同时仍然允许底层基础架构发生变化。</p><p id="12c6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">不仅仅是删除pod会导致pod被移除。当发布应用程序的新版本或缩小规模时，pods将经历这个生命周期。正确配置您的服务非常重要。否则，客户可能会请求失败。要更深入地了解pod生命周期，请查看关于pod生命周期的<a class="ae lv" href="https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle/" rel="noopener ugc nofollow" target="_blank">文档。</a></p></div><div class="ab cl lw lx hx ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="im in io ip iq"><h1 id="f6b0" class="md me it bd mf mg mh mi mj mk ml mm mn jz mo ka mp kc mq kd mr kf ms kg mt mu bi translated">复制品</h1><p id="c9fa" class="pw-post-body-paragraph kz la it lb b lc mv ju le lf mw jx lh li mx lk ll lm my lo lp lq mz ls lt lu im bi translated">本文的大部分内容假设有多个服务实例在运行。在K8s中，这是通过使用一个副本集来完成的，或者更好的是，部署将为您创建一个副本集。如果您手动部署单个pod，然后将其删除，您的服务将会关闭，并且不会恢复。如果服务通过副本集运行，但只有一个pod，则在删除pod后，该服务将不可用。然后，副本集将自动调出一个新的pod来替换被删除的pod，您的服务将再次可用。</p><p id="7f88" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">通过为每个服务运行至少两个pod，我们可以解决这个问题。当我们删除其中一个pod时，K8s会将流量无缝发送到其他pod。作为标准运行两个pod是个好主意，因为应用程序可能会崩溃。至少有一个备份pod将为您提供在这种情况下保持服务可用所需的冗余。如果您决定只为一个服务运行一个pod，并且需要删除一个pod，您可能需要考虑向上扩展到两个pod，删除pod，然后再向下扩展。</p><p id="1e3c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">当在K8s中移动pod时，考虑服务必须处理的容量是很重要的。如果我们删除一个pod，同时等待一个新的pod启动，是否仍有足够的pod来处理所有请求？配置单元数量或自动缩放时，应考虑这一点。您可能想要n+1个pod，这样您就有足够的数量来避免其中一个不可用。您可能希望检查您的部署更新策略，因为默认情况下，它可能会使服务处于容量不足的状态。有关这方面的更多信息，请查看我的另一篇文章，<a class="ae lv" href="https://medium.com/better-programming/how-to-stop-kubenetes-from-dosing-your-application-during-deployment-42672b4dfa42" rel="noopener">如何在部署期间阻止Kubernetes向您的应用程序添加剂量</a>。</p><p id="a5f9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们可以对部署进行更改，而不是删除特定的单元。我们可以使用K8s标签，而不是更改应用程序的源代码来导致更新。下面的命令更新名为<code class="fe na nb nc nd b">load-app</code>的部署，并添加或更新标签<code class="fe na nb nc nd b">restarted-at</code>。这将导致我们的pod滚动更新，使用更新的标签创建新的pod。该命令将标签的值设置为运行该命令的时间戳，用于审计目的。这种滚动更新将遵循部署策略，为工作负载保留足够的pod。</p><figure class="kk kl km kn gt ko"><div class="bz fp l di"><div class="ne nf l"/></div></figure></div><div class="ab cl lw lx hx ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="im in io ip iq"><h1 id="5ef6" class="md me it bd mf mg mh mi mj mk ml mm mn jz mo ka mp kc mq kd mr kf ms kg mt mu bi translated">健康检查</h1><p id="d75e" class="pw-post-body-paragraph kz la it lb b lc mv ju le lf mw jx lh li mx lk ll lm my lo lp lq mz ls lt lu im bi translated">健康检查在应用程序崩溃的情况下非常有用，因为K8s会重新安排服务。这些检查在其他场景中也很有用，如下所述。</p><p id="7934" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">先来了解一下K8s中不同类型的健康检查。有两种类型的健康检查，<em class="ng">就绪</em>和<em class="ng">有效</em>。Alive检查进程是否启动并运行。如果这个失败了，K8s会重启它(保持同一个pod)。如果pod正在使用或启用了入口，则如果运行状况检查失败，就绪检查会将该服务从流量中移除。</p><p id="c838" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">准备就绪检查是我们讨论删除pod时的重要检查——有趣的是，不是针对被删除的pod，而是针对将取代它的新pod。如果没有准备好检查，新的pod将立即投入使用。即使是简单的应用程序也需要一些时间来启动，在这个窗口中，可以向它发送请求。由于应用程序仍在启动，请求将失败。这很容易通过添加一个ready check来修复，该check卷曲一个总是返回状态码<code class="fe na nb nc nd b">200</code>的端点。</p></div><div class="ab cl lw lx hx ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="im in io ip iq"><h1 id="429c" class="md me it bd mf mg mh mi mj mk ml mm mn jz mo ka mp kc mq kd mr kf ms kg mt mu bi translated">Node.js中的实现</h1><p id="dc28" class="pw-post-body-paragraph kz la it lb b lc mv ju le lf mw jx lh li mx lk ll lm my lo lp lq mz ls lt lu im bi translated">如果您的应用程序使用Node.js服务器，您可以使用下面的代码来确保所有请求在退出应用程序之前完成。这是通过用回调调用<code class="fe na nb nc nd b">server.close()</code>为<code class="fe na nb nc nd b">SIGTERM</code>注册一个监听器来实现的。close函数将关闭服务器，但允许现有请求在进程退出前完成。如果您没有这个代码或类似的代码，流程将在收到<code class="fe na nb nc nd b">SIGTERM</code>时立即退出。</p><figure class="kk kl km kn gt ko"><div class="bz fp l di"><div class="ne nf l"/></div></figure></div><div class="ab cl lw lx hx ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="im in io ip iq"><h1 id="fd8b" class="md me it bd mf mg mh mi mj mk ml mm mn jz mo ka mp kc mq kd mr kf ms kg mt mu bi translated">演示</h1><p id="9583" class="pw-post-body-paragraph kz la it lb b lc mv ju le lf mw jx lh li mx lk ll lm my lo lp lq mz ls lt lu im bi translated">为了将你所学的一切付诸行动，并尝试不同的场景，你可以尝试<a class="ae lv" href="https://www.katacoda.com/harryemartland/scenarios/deleting-k8s-pods" rel="noopener ugc nofollow" target="_blank">这个Katacoda场景</a>。在这里，您可以使用一个部署了示例服务的K8s集群。该场景引导您以不同的方式删除pod，并观察客户请求是如何受到影响的。</p><figure class="kk kl km kn gt ko gh gi paragraph-image"><a href="https://www.katacoda.com/harryemartland/scenarios/deleting-k8s-pods"><div class="gh gi nh"><img src="../Images/80a90bcf49d00b0031b01599d9f8deec.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*OA3Iuq2847YJduIR7_7Zfw.png"/></div></a></figure></div><div class="ab cl lw lx hx ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="im in io ip iq"><p id="626e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这是Kubernetes的一些特性的短暂停留，这些特性可以帮助您构建有弹性的服务。我希望你现在有信心和知识删除Kubernetes豆荚不影响你的客户。</p></div></div>    
</body>
</html>