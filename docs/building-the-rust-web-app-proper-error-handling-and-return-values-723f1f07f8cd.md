# 构建 Rust Web 应用程序—正确的错误处理和返回值

> 原文：<https://betterprogramming.pub/building-the-rust-web-app-proper-error-handling-and-return-values-723f1f07f8cd>

## 要使您的 web 应用程序正常工作

![](img/bbaf5f3f33f2e0afb3907383da796ad7.png)

照片由[阿鲁迪巴 S](https://unsplash.com/@aldebarans) 在 [Unsplash](https://unsplash.com/)

这是关于编写 web 应用程序的系列文章的第四部分。对于这个系列，我们将在 [Rust](https://www.rust-lang.org/learn/get-started) 中编写 web 应用程序，我将向您解释如何自己编写它。

但是，如果您不愿意自己编写代码，我在这里创建了一个包含本系列所有代码的库。在本系列每一部分的结尾，我都提交了一个存储库。[在上一部分](/building-the-rust-web-app-how-to-use-object-relational-mapper-3af2084555b6)中，我们讨论了使用对象关系映射器，或简称 ORM，来使我们的数据库工作更加容易。在这一部分，我们给我们的应用程序提供了更合适的错误处理和返回值。最终，它将看起来更像一个标准的网络应用程序。

# 正确的返回值

到目前为止，我们的回报都是纯数据。JSON 的片段或字符串。然而，正如我在开始时提到的，我们的应用程序应该接受请求并返回 HTML、JavaScript 和 CSS 来显示网页。从技术上来说，这是一个谎言。我们已经制定的`GET`、`PUT`、`POST`和`DELETE`方法基本上保持不变。然而，我们的服务器中的一些路径会返回 HTML，这是事实。恰好有些路径返回正在显示的东西，有些路径用来做事。无论如何，让我们实现一个实际返回显示内容的路径。

我们已经非常广泛地使用 Rocket 来返回值，因为它是最后一个触及我们的值并在它们被发送到浏览器之前将它们转化为响应的东西。可想而知，Rocket 还提供了对返回 HTML、CSS 和 JavaScript 的支持。

现在，我们可以把一系列的字符串放在一起，通过简单地操作字符串，用 CSS 和 JavaScript 制作我们自己的 HTML 文件，但是我不打算这么做。它很乏味，很长，而且我不认为它真的提供了任何有价值的东西。我们将直接跳到在此基础上构建的抽象，即使用模板引擎。基本上，我们写出一个 HTML 文件，但是我们留下可以输入数据的地方，并且在发送回模板之前提供数据。为什么这种抽象存在是显而易见的。编写一个漂亮的 HTML 文件并提供必要的数据比处理一大堆乱七八糟的字符串更容易。

正如所料，Rocket 允许您使用和返回模板，还允许您从列表中选择想要使用的模板引擎(模板引擎是获取我们的模板并将其转换为正确的 HTML 的工具)。出于我们的目的，我们将使用名为 [Tera](https://tera.netlify.app/) 的模板引擎。

首先，我们需要配置 Rocket 从某个目录中提取模板，因此修改`Rocket.toml`如下所示

之后，我们需要导入解释模板的 Rocket 库，所以修改`Cargo.toml`如下所示

现在，在与`Rocket.toml`相同的层次上，创建一个名为`templates`的目录。对于我们创建的模板，我们将在最后使用文件扩展名`.tera`来让 Rocket 知道我们想用 handlebars 来编译它。说到这里，在`templates`目录下，创建一个名为`base.html.tera`的文件。这个文件基本上是我们所有内容的包装器。其他每一个模板基本都会说“从`base.html.tera`中间开始”，所以我们只需要写出`<!DOCTYPE html>`和其他那些繁琐的导入一次。现在，将以下代码添加到`base.html.tera`

之后，我们将创建待办事项的实际列表。创建一个名为`todo_list.html.tera`的文件。用下面的代码填充它(这将把内容放在我们命名为 content 的块中)

如您所见，我们正在使用模板引擎根据我们将从数据库中提取的数据动态创建项目。在`main.rs`中，我们将设置正确渲染模板的函数，并将模板引擎添加到 Rocket 应用程序中。它的代码看起来像这样

这样，如果我们再次运行程序，并在浏览器中打开链接，我们将看到数据库中的项目列表。不过，看起来也不是特别好。如果我们可以使用一些 CSS 来改善外观，那就太好了，但是我们如何将 CSS 放到我们的前端呢？这使我们走上了提供静态内容的道路。

# 提供静态内容

[静态内容](https://blog.stackpath.com/static-content/)是不变的内容。这意味着，无论用户做什么，无论应用程序中发生什么，文件都不会改变。大多数 CSS 文件和图像都是静态内容。它们在应用程序的过程中不会真正改变。它们只是存在并提供额外的信息。

很多时候，我们希望静态内容可以自由获取。换句话说，我们真的希望能够简单地提交一个快速的`GET`请求，然后毫不费力地撤回这些内容。幸运的是，包括 Rocket 在内的大多数 web 框架都提供了一种功能来公开一个充满静态内容的文件夹。在这个文件夹被“公开”后，我们可以运行`GET`请求，就像我们在那个文件夹的路径中移动一样，并且可以拉回相关的文件。

因此，让我们将所有静态内容放在一个名为`public`的新文件夹中，该文件夹与`Cargo.toml`位于同一层。在这个文件夹中，我们将放置所有的 CSS，图片和其他静态内容，我们希望我们的网站能够使用。然后，我们将使用 Rocket 来显示该文件夹。让 Rocket 暴露该文件夹的代码发生在`main.rs`，如下所示

如您所见，我们已经安装了 public 中所有从`/`开始使用的文件。这意味着，如果我们的公共文件夹中有一个名为`todo_list.css`的文件，调用`http://127.0.0.1:8000/todo_list.css`将返回那个 CSS。如果我们有一个名为`images`的公共文件夹，我们把一个名为`pizza.png`的图像放在那里，调用`http://127.0.0.1:8000/images/pizza.png`将返回那个图像。使用这个，我们现在可以为我们的模板编写 CSS，并且当我们在前端时可以检索它们。

所以，让我们使用我们的新能力来服务静态内容！在`public`文件夹中，创建一个名为`todo_list.css`的文件，并放入以下代码

现在，在我们的`base.html.tera`文件中，我们需要导入 CSS。为此，我们需要使用一个`link`元素来引入一个样式表。我们使用`href`道具传入一个包含 CSS 的 URL。如果现在开始给定 URL，则假定基本 URL 是我们的网站。

用非行话的术语来说，将下面的代码放在`base.html.tera`中的 meta 标签之间

```
<link rel="stylesheet" href="/todo_list.css" />
```

现在，如果你重新运行你的应用程序，表格看起来会好一点。现在，本着做一点样式的精神，让我们用下面的代码在`public`中创建另一个名为`container.css`的文件

并在`base.html.tera`中的 meta 标记之间添加以下样式表链接

```
<link rel="stylesheet" href="/container.css" />
```

有了它，我们的造型看起来更过得去了。

# 修正我们反应的代码

现在，我们的函数仍然返回不正确的值。即使在实现了前面的修复之后，如果您尝试添加一个任务，您将会看到一个充满 JSON 的空白页面，这是我们不希望看到的。我们更愿意做的是重定向到我们的 TODO 列表页面，并添加一个类似“任务已创建！”。幸运的是，Rocket 有一个名为`[Flash](https://api.rocket.rs/v0.4/rocket/response/struct.Flash.html)`的结构，可以完美地为我们做到这一点。

因此，让我们修改我们的`add_task`函数，以便更好地与我们的应用程序一起工作！我们需要做的就是修改它，使用那个`Flash`结构来重定向和发送消息

接下来，我们修改`index`来接收消息并将其传递给我们的 HTML

然后，我们修改`todo_list.html.tera`的顶部以使用该消息。

```
{% extends "base" %} {% block content %}
<h1>Todo List</h1>
{% if flash %}
<p class="{{ flash.0 }}-flash">
  {{ flash.1 }}
</p>
{% endif %}
...
```

最后，将以下 CSS 添加到`container.css`

现在让我们修改删除任务，使其也能正常工作。将函数更改为如下所示

至此，我们的删除应该可以正常工作了。

# 困难的编辑操作

可悲的是，编辑操作将使我们的生活更加困难。实现它的最简单的方法是在我们的应用程序中创建另一个打开新页面的路由。在此页面中，我们可以编辑任务并提交编辑内容。

首先，我们需要创建将要访问的模板。在`templates`中创建一个名为`edit_task_form.html.tera`的新文件，并在其中输入以下代码

然后，在`main.rs`中，添加以下代码

当然，把它放到`rocket`的`routes!`宏中。接下来，修改`todo_list.html.tera`中的编辑按钮，改为如下所示

之后，进入`main.rs`，修改`edit_task`功能如下

最后，进入`todo_list.css`并添加以下 CSS

这样，如果您停止并重新启动应用程序，并尝试 web 部件。现在，您可以正确地使用所有 CRUD 操作了。

# 处理错误

现在，我们处理错误的方式是不充分的。即使我们的错误不会使服务器崩溃，它们仍然会将用户带到 404、500 或其他状态页面。如果这个错误能更好地集成到应用程序中，并且不影响用户体验，那就更好了。我们可以使用相同的`Flash`结构，我们已经使用我们的成功回报，也使用它为我们的不良回报。事实上，`Flash`通过关联函数`Flash::error`支持这一点。所以，我们将遍历那些不返回模板的函数，并让它们在失败时返回`Flash::error` s，而不是将用户发送到 404 或 500 页面。下面是`delete_task`的代码

这里是`edit_task`的代码

这里是`add_task`

而且，你可能已经注意到`read_tasks`不再真的需要被使用，因为`index`现在基本上做同样的事情，所以你可以自由地保留那个函数用于调试，或者如果你不想要它就删除它。

虽然你可能看不到错误，除非你特意去引起一个错误，但是要意识到，当错误确实发生时，它确实工作。

现在，你可能已经注意到，我没有切换从返回`Template` s 的路线返回的`DatabaseError`，因为如果页面加载失败，404 或 500 页面出现来取代它的位置要正常得多。所以，它在那里工作。

# 页码

现在，我们的 Todo 列表是一个未知数量的项目列表。一个人可能有 100 多项任务，也可能有 3 项。通常，当我们显示一个数据列表时，这个列表可能会很长，我们必须对数据进行分页。这意味着我们把列表分成几页，每一页都有一定数量的条目。然后，当我们想要查看项目时，我们一次只显示一页项目。

`<Quick Aside>`

在许多社交媒体应用程序中，如 Reddit、Instagram、Twitter 或脸书，主页将是你所关注的人的帖子列表。然而，你可以继续滚动，只要你想。当你到达主页上文章的末尾时，它会加载更多的内容，然后你就可以浏览这些内容了。我们通常称之为[无限滚动列表](https://blog.hubspot.com/website/pagination-vs-infinite-scroll)。但是，这也是分页！这个应用程序显然不只是加载无限数量的帖子。它也以块或页的形式加载文章，并把它们放在列表中，它只是试图获取下一页的文章，并在你到达底部之前把它们添加到列表中。

`</Quick Aside>`

显然，我们希望为我们的应用程序实现这一点。不仅仅是为了学习分页，还因为它会让这个应用程序更容易使用。

然而，要做到这一点，我们需要稍微改变一下`index`的工作方式。我们不只是返回数据库中的每一个任务，而是希望获取一个参数来了解用户需要哪一页的任务。此外，我们希望浏览器能够指定每个页面有多少任务。这可以在以后使用，通过根据垂直尺寸改变每页的任务数量，使列表更好地适用于不同的设备。我们也可以只放一个输入，并允许用户指定他们想要在每个页面上有多少项目。两者都可以很好地工作，但这显然是我们想要的选择。

添加它很简单。分页由`sea-orm`提供。只需修改`index`如下所示

你可能会注意到`index`的路线现在有了一些新的参数。它们的编写方式使它们成为可选的，所以它们不需要打开页面。在任何情况下，修改`todo_list.html.tera`如下所示

最后，修改`todo_list.css`,如下所示

至此，我们已经添加了基本的分页。然而，这种分页有一个可用性问题。因为我们的添加、删除和编辑任务都要经过路径`/`，所以每当我们试图对列表做新的事情时，我们都会回到第一页，这并不理想。但是，它符合我们演示分页的目的。我们也可以增加其他的可用性特性，比如过滤和排序列表，但是我不会在这里做这些。我不认为它们对更大的网络应用架构真的那么重要。然而，如果您想知道，`sql`和 SeaORM [实现了过滤和排序项目的方法](https://sqlbolt.com/lesson/filtering_sorting_query_results)，您只需在您运行的任何查询中使用这些方法来取回您的项目。

但这就是我今天的全部内容。在本系列的下一部分中，我们将解决多用户问题，并将授权添加到我们的基本 web 应用程序中。

感谢您阅读这篇文章。我希望这个系列能够继续帮助您提高 web 开发技能。

# 资源

*   【rust-lang.org】Rust 编程语言(T4)
*   [本系列的 GitHub 库](https://github.com/garrettudstrand/rust-web-app/tree/main)
*   [万亿](https://tera.netlify.app/)
*   [什么是静态内容？静态内容如何工作(stackpath.com)](https://blog.stackpath.com/static-content/)
*   [火箭闪光::响应—生锈](https://api.rocket.rs/v0.4/rocket/response/struct.Flash.html)
*   [分页与无限滚动:哪一个对你的内容更好？(hubspot.com)](https://blog.hubspot.com/website/pagination-vs-infinite-scroll)
*   [SQLBolt —学习 SQL — SQL 第四课:查询结果的过滤和排序](https://sqlbolt.com/lesson/filtering_sorting_query_results)