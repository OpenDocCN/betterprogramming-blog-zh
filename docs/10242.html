<html>
<head>
<title>How To Time Threaded Python Loops Efficiently</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何高效地计时线程化Python循环</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/how-to-time-threaded-python-loops-efficiently-93435b6f350f?source=collection_archive---------2-----------------------#2021-12-16">https://betterprogramming.pub/how-to-time-threaded-python-loops-efficiently-93435b6f350f?source=collection_archive---------2-----------------------#2021-12-16</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="bcdf" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">在不牺牲性能的情况下，了解多线程应用的速度</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/5c63acf00277c662fb96b2ff7fafea0e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*1X0-98EiQNkwBJj2vnTTqQ.jpeg"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">照片由<a class="ae ky" href="https://unsplash.com/@cdr6934?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">克里斯里德</a>在<a class="ae ky" href="https://unsplash.com/s/photos/programming?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>拍摄</p></figure><p id="3542" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我喜欢Python，但有时它会慢得要命。在选择解释型语言还是编译型语言时，总会有所取舍，但是Python中有一些奇怪的地方会严重影响性能。这些可能容易被忽视的怪癖之一，<em class="lv">打印</em>。</p><p id="6e41" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">当您在Python中将一些输出打印到屏幕上时，它会对性能产生很大的影响，以至于一些对延迟敏感的应用程序会遇到严重的问题。检查:<a class="ae ky" href="https://medium.com/spencerweekly/console-output-overhead-why-is-writing-to-stdout-so-slow-b0cc7c88704c" rel="noopener"> <em class="lv">控制台输出开销:为什么写入stdout这么慢？</em> </a> <em class="lv"> </em>由<a class="lw lx ep" href="https://medium.com/u/ef0e6a9f5fb?source=post_page-----93435b6f350f--------------------------------" rel="noopener" target="_blank">斯潘塞拉拢</a>对印刷潜伏期进行深入探讨。</p><p id="36d6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在这篇文章中，我们将看看打印有多慢，以及一些方法来真正利用打印语句进行计时，而不会让您的核心应用程序代码嘎然而止。</p><h1 id="dcfd" class="ly lz it bd ma mb mc md me mf mg mh mi jz mj ka mk kc ml kd mm kf mn kg mo mp bi translated">简单循环有多快？</h1><p id="ccf2" class="pw-post-body-paragraph kz la it lb b lc mq ju le lf mr jx lh li ms lk ll lm mt lo lp lq mu ls lt lu im bi translated">在下面的第一个例子中，我们将设置一个基本的<code class="fe mv mw mx my b">for</code>循环计时器，然后在没有任何打印语句的情况下运行它，当我们在1000的范围内迭代时，只使用<code class="fe mv mw mx my b">pass</code>。这会给我们一个快速的基线。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mz na l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">基本Python循环时序。</p></figure><p id="0e9f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">运行此示例，您应该会得到类似如下的结果:</p><pre class="kj kk kl km gt nb my nc nd aw ne bi"><span id="b5a9" class="nf lz it my b gy ng nh l ni nj">loop time in <br/>nanoseconds: 20795<br/>microseconds: 20.795<br/>milliseconds: 0.020795</span></pre><p id="b625" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如你所见，<code class="fe mv mw mx my b">for</code>循环非常快，因为它不做任何事情。原始循环在大约20微秒内完成。</p><h1 id="cfcc" class="ly lz it bd ma mb mc md me mf mg mh mi jz mj ka mk kc ml kd mm kf mn kg mo mp bi translated">印刷让我们慢了多少？</h1><p id="736a" class="pw-post-body-paragraph kz la it lb b lc mq ju le lf mr jx lh li ms lk ll lm mt lo lp lq mu ls lt lu im bi translated">现在让我们在循环内部打印一些东西。将示例更改为如下所示:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mz na l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">在循环中使用print语句的基本Python循环计时。</p></figure><p id="c256" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">再运行一次，数字会更糟:</p><pre class="kj kk kl km gt nb my nc nd aw ne bi"><span id="ce4d" class="nf lz it my b gy ng nh l ni nj">loop time in <br/>nanoseconds: 2376836<br/>microseconds: 2376.836<br/>milliseconds: 2.376836</span></pre><p id="fbc2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在循环在2毫秒内结束。这可不好。当您将这些速度与C或C++之类的东西进行比较时，结果相当糟糕。请记住，这些都是非常基本的例子，对于实际的产品代码来说，在循环中如何做以及做什么将更加重要。</p><h1 id="972f" class="ly lz it bd ma mb mc md me mf mg mh mi jz mj ka mk kc ml kd mm kf mn kg mo mp bi translated">计时线程循环</h1><p id="1285" class="pw-post-body-paragraph kz la it lb b lc mq ju le lf mr jx lh li ms lk ll lm mt lo lp lq mu ls lt lu im bi translated">现在，让我们假设您有一个多线程应用程序，并希望获得线程内循环速度的一些基本统计数据。如果你正在运行一个多线程服务器，它运行在一个无限循环或者一个长时间运行的循环中，这就有点棘手了。</p><p id="1291" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们看看下面的基本示例服务器代码:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mz na l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">基本线程Python服务器。</p></figure><p id="a255" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这是一个简单的线程服务器。它将启动一个无限的<code class="fe mv mw mx my b">while</code>循环，然后在里面做一些工作。这个服务器不是很令人兴奋，它所做的就是在循环结束时休眠并打印一条消息。</p><p id="e77a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们假设在这个无限循环中，我们想要处理一些其他的逻辑。假设我们想要迭代前面的相同范围的数字:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mz na l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">带范围循环打印的基本线程Python服务器。</p></figure><p id="ca30" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在，我们在与之前简单测试相同的数字范围内循环。但是，如果我们想计算在线程内部完成这个循环需要多长时间呢？</p><p id="4503" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们可以添加这样的内容:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mz na l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">一种在无限循环中计时的糟糕方法。</p></figure><p id="6ad7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">但是如果我们的无限循环线程没有那1秒钟的睡眠呢？如果它真的尽可能快了呢？拥有所有这些代价高昂的<code class="fe mv mw mx my b">print</code>语句将会减慢整个循环的速度。计时代码将开始影响实际的应用程序代码。<em class="lv">不好</em>。</p><p id="100c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们可以处理这个问题的方法之一是对最后一次或最后几次循环迭代计时。当服务器中断并关闭时，我们可以这样做:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mz na l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">线程无限循环中的简单计时。</p></figure><p id="ca67" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在这个例子中，我们没有在我们的线程无限循环中打印任何东西，我们只是执行时间分析，然后将它存储在一个实例变量中。然后我们可以访问这个变量来获得最后一次循环迭代的时间。</p><p id="63e0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">为了让服务器有时间正常关闭，我们将捕获键盘中断，然后告诉无限线程停止，强制保存最后的循环时间并退出线程。</p><p id="0398" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">一旦线程退出，我们只需打印出计时数据。</p><p id="df69" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">运行该示例应该会产生类似如下的结果:</p><pre class="kj kk kl km gt nb my nc nd aw ne bi"><span id="ae24" class="nf lz it my b gy ng nh l ni nj">loop time in<br/>nanoseconds: 41000<br/>microseconds: 41.0<br/>milliseconds: 0.041</span></pre><p id="79ac" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">正如我们所看到的，这个结果非常接近于我们之前大约20微秒的第一个结果。如果您要在循环中添加一个print语句，您将会看到类似如下的输出:</p><pre class="kj kk kl km gt nb my nc nd aw ne bi"><span id="3856" class="nf lz it my b gy ng nh l ni nj">loop time in<br/>nanoseconds: 3205000<br/>microseconds: 3205.0<br/>milliseconds: 3.205</span></pre><p id="6a79" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这个结果再次类似于我们之前的第二个简单例子，大约2.3毫秒。</p><p id="e7d4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">使用这种方法，您可以从无限线程中获得非常准确的循环计时，而无需使用任何额外的库或复杂的分析器。</p></div><div class="ab cl nk nl hx nm" role="separator"><span class="nn bw bk no np nq"/><span class="nn bw bk no np nq"/><span class="nn bw bk no np"/></div><div class="im in io ip iq"><p id="e7cf" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><em class="lv">感谢您的阅读。尽管Python对于某些操作来说可能很慢，但它确实很灵活，并且有大量的优化可用。查看官方Python Wiki </em>  <em class="lv">获得一些性能提示和技巧。</em></p></div></div>    
</body>
</html>