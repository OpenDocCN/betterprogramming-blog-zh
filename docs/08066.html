<html>
<head>
<title>How To Write Clean API Calls With Axios</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何用Axios编写干净的API调用</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/how-to-write-clean-api-calls-with-axios-ddbc7df4256c?source=collection_archive---------4-----------------------#2021-03-22">https://betterprogramming.pub/how-to-write-clean-api-calls-with-axios-ddbc7df4256c?source=collection_archive---------4-----------------------#2021-03-22</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="3f71" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">使用Axios编写更好、更可读的前端API</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/35fd407ea2705c2065a27f782d674d20.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*NIyIL37tpI-QLQHp"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">莎拉·多维勒在<a class="ae kv" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片。</p></figure><p id="fc6c" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">做前端应用不像以前那么简单了。像React和Vue.js这样的前端框架严重依赖API。这增加了我们应用程序的复杂性，因为我们需要管理如何调用这些API。一个解决方案是通过编写干净的API调用来简化这个过程。</p><p id="3bd4" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">但是等等，什么是“干净的API调用”？对我来说，这意味着API调用的适当结构，使它们易于阅读和维护。首先，我利用单一责任原则来做到这一点。每个功能必须有一个单一的职责，记住这个原则，我们需要为每个端点分离逻辑。</p><p id="b2b3" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我尝试考虑的另一件事是干原则(“不要重复自己”)。这一点非常重要——对于前端API提供者来说更是如此——因为它给人一种代码整洁的感觉，从而提高了可读性。我使用<a class="ae kv" href="https://www.npmjs.com/package/axios" rel="noopener ugc nofollow" target="_blank"> Axios </a>，因为它提供了诸如拦截器、默认值等特性。它减少了您需要为每个API端点编写的样板代码的数量。</p></div><div class="ab cl ls lt hu lu" role="separator"><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx"/></div><div class="ij ik il im in"><h1 id="324e" class="lz ma iq bd mb mc md me mf mg mh mi mj jw mk jx ml jz mm ka mn kc mo kd mp mq bi translated">使用Axios的利与弊</h1><p id="3cf1" class="pw-post-body-paragraph kw kx iq ky b kz mr jr lb lc ms ju le lf mt lh li lj mu ll lm ln mv lp lq lr ij bi translated">有许多方法可以实现这一点。您可以使用Fetch API，也可以使用名为Axios的第三方库。通过这篇文章的标题，你可以猜到我更喜欢Axios。为什么？让我们权衡利弊。</p><h2 id="af31" class="mw ma iq bd mb mx my dn mf mz na dp mj lf nb nc ml lj nd ne mn ln nf ng mp nh bi translated"><strong class="ak">亲:简单</strong></h2><p id="00e3" class="pw-post-body-paragraph kw kx iq ky b kz mr jr lb lc ms ju le lf mt lh li lj mu ll lm ln mv lp lq lr ij bi translated">我最喜欢Axios的一点是，它使用起来非常简单。编程API非常容易使用，我已经完全习惯了。嗯，这可能是过于个人化的偏好，但你可以自己尝试一下。我使用过jQuery的AJAX和Fetch API，我会把Axios排在所有这些API之上——尽管差距不是很大，因为这三个API都很好使用。</p><h2 id="c229" class="mw ma iq bd mb mx my dn mf mz na dp mj lf nb nc ml lj nd ne mn ln nf ng mp nh bi translated"><strong class="ak"> Pro:向后兼容性</strong></h2><p id="82ea" class="pw-post-body-paragraph kw kx iq ky b kz mr jr lb lc ms ju le lf mt lh li lj mu ll lm ln mv lp lq lr ij bi translated">老实说，你不会想到这个功能，直到你需要它。我的意思是，大多数人都有现代浏览器，但如果你的一些客户不是大多数人，他们可能无法使用你的应用程序，如果它不是向后兼容的。Fetch API相对较新，旧的浏览器不能使用它。否则，像Axios和jQuery的AJAX这样的库是建立在JavaScript的XMLHttpRequest之上的。对于那些想知道的人，XMLHttpRequest是JavaScript内置HTTP调用机制的旧版本。</p><h2 id="90db" class="mw ma iq bd mb mx my dn mf mz na dp mj lf nb nc ml lj nd ne mn ln nf ng mp nh bi translated"><strong class="ak"> Pro:具有大量特性的成熟库</strong></h2><p id="ca96" class="pw-post-body-paragraph kw kx iq ky b kz mr jr lb lc ms ju le lf mt lh li lj mu ll lm ln mv lp lq lr ij bi translated">你可以用Axios做很多事情——很多事情。例如，在撰写本文时，Fetch API还没有内置的请求/响应拦截器。你必须使用第三方。与Fetch相比，使用Axios编写干净的API非常简单。Axios已经有了如此多的内置便利。举几个例子，您可以使用Axios设置默认的头和默认的基本URL。</p><h2 id="42fe" class="mw ma iq bd mb mx my dn mf mz na dp mj lf nb nc ml lj nd ne mn ln nf ng mp nh bi translated"><strong class="ak">缺点:对小型应用来说太复杂</strong></h2><p id="aca8" class="pw-post-body-paragraph kw kx iq ky b kz mr jr lb lc ms ju le lf mt lh li lj mu ll lm ln mv lp lq lr ij bi translated">我使用Axios已经很长时间了，我明白这个库对于小应用程序来说可能是多余的。如果您只需要使用它的GET和POST-API，那么无论如何，使用Fetch API可能会更好。Fetch是JavaScript自带的，而Axios不是。这就把我们带到了下一点。</p><h2 id="136c" class="mw ma iq bd mb mx my dn mf mz na dp mj lf nb nc ml lj nd ne mn ln nf ng mp nh bi translated"><strong class="ak">缺点:Axios增加了您的包大小</strong></h2><p id="c697" class="pw-post-body-paragraph kw kx iq ky b kz mr jr lb lc ms ju le lf mt lh li lj mu ll lm ln mv lp lq lr ij bi translated">这第二点与第一点完全一致。我避免在小型应用中使用Axios的一个主要原因是它会增加你的生产规模。当然，你可能没有注意到像电子商务等大型应用程序的大小峰值。但是如果你做一个简单的投资组合网站，你会注意到一个巨大的增长。要吸取的教训？为正确的工作使用正确的工具。</p><h2 id="3622" class="mw ma iq bd mb mx my dn mf mz na dp mj lf nb nc ml lj nd ne mn ln nf ng mp nh bi translated"><strong class="ak">弊:是第三方</strong></h2><p id="084f" class="pw-post-body-paragraph kw kx iq ky b kz mr jr lb lc ms ju le lf mt lh li lj mu ll lm ln mv lp lq lr ij bi translated">听着，让我先说第三点是非常主观的，有些人可能会有相反的观点。Axios是第三方。是的，你没看错。与Fetch不同，它不是浏览器固有的。你依靠社区来维护你宝贵的应用。话说回来，如今大多数应用程序都使用开源产品。所以这会是个问题吗？不完全是。同样，这是一个偏好。我不是建议你重新发明轮子。只要明白你并不拥有<em class="ni">方向盘。</em></p></div><div class="ab cl ls lt hu lu" role="separator"><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx"/></div><div class="ij ik il im in"><h1 id="5c83" class="lz ma iq bd mb mc md me mf mg mh mi mj jw mk jx ml jz mm ka mn kc mo kd mp mq bi translated">安装Axios</h1><p id="a127" class="pw-post-body-paragraph kw kx iq ky b kz mr jr lb lc ms ju le lf mt lh li lj mu ll lm ln mv lp lq lr ij bi translated">Axios在多个JavaScript存储库中可用。你可以使用纱线和NPM来访问它。如果您使用的是常规HTML，可以从jsDelivr、Unpkg或Cloudflare等cdn导入。</p><p id="e7d8" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">假设您使用的是NPM，我们需要使用以下命令安装Axios:</p><pre class="kg kh ki kj gt nj nk nl nm aw nn bi"><span id="7f1c" class="mw ma iq nk b gy no np l nq nr">npm install -S axios</span></pre><p id="1b5a" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">如果安装中没有错误，您可以继续下一步。您可以在GitHub 上查看替代安装方法<a class="ae kv" href="https://github.com/axios/axios#installing" rel="noopener ugc nofollow" target="_blank">。</a></p></div><div class="ab cl ls lt hu lu" role="separator"><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx"/></div><div class="ij ik il im in"><h1 id="ff8e" class="lz ma iq bd mb mc md me mf mg mh mi mj jw mk jx ml jz mm ka mn kc mo kd mp mq bi translated">制作单独的Axios客户端</h1><p id="7f3b" class="pw-post-body-paragraph kw kx iq ky b kz mr jr lb lc ms ju le lf mt lh li lj mu ll lm ln mv lp lq lr ij bi translated">什么是Axios客户端？客户端是我们为每个API调用设置默认参数的方式。我们在Axios客户端中设置默认值，然后使用JavaScript的<code class="fe ns nt nu nk b">export default</code>导出客户端。之后，我们可以从应用程序的其余部分引用客户端。</p><p id="2a74" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">首先，创建一个新文件，最好命名为<code class="fe ns nt nu nk b">apiClient.js</code>，并导入Axios:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nv nw l"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">导入Axios。</p></figure><p id="8faf" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">然后使用<code class="fe ns nt nu nk b">axios.create</code>制作客户端:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nv nw l"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">Axios客户端JS示例。</p></figure><p id="7300" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">如您所见，我们为所有HTTP调用初始化了基本URL和默认头。</p></div><div class="ab cl ls lt hu lu" role="separator"><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx"/></div><div class="ij ik il im in"><h1 id="ed9b" class="lz ma iq bd mb mc md me mf mg mh mi mj jw mk jx ml jz mm ka mn kc mo kd mp mq bi translated">使用拦截器进行干净的重定向</h1><p id="fb85" class="pw-post-body-paragraph kw kx iq ky b kz mr jr lb lc ms ju le lf mt lh li lj mu ll lm ln mv lp lq lr ij bi translated">当调用交互API时——特别是当涉及身份验证时——您需要定义调用未经授权时的条件，并使您的应用程序做出适当的反应。拦截器非常适合这个用例。</p><p id="ab30" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">比方说，当我们的cookie过期时，我们需要应用程序将我们重定向到我们的主页，当我们的cookie过期时，API将返回401状态代码。你应该这样做:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nv nw l"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">使用Axios拦截器的例子。</p></figure><p id="10cc" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">简单吧？在定义了客户机并附加了拦截器之后，您只需要导出客户机以便在其他页面上使用。</p></div><div class="ab cl ls lt hu lu" role="separator"><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx"/></div><div class="ij ik il im in"><h1 id="d6a9" class="lz ma iq bd mb mc md me mf mg mh mi mj jw mk jx ml jz mm ka mn kc mo kd mp mq bi translated">导出Axios客户端</h1><p id="8fed" class="pw-post-body-paragraph kw kx iq ky b kz mr jr lb lc ms ju le lf mt lh li lj mu ll lm ln mv lp lq lr ij bi translated">配置完Axios客户端后，您需要将其导出，以使其可用于整个项目。您可以通过使用<code class="fe ns nt nu nk b">export default</code>功能来实现:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nv nw l"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">导出Axios客户端。</p></figure><p id="63bd" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">现在，我们已经使Axios客户端可用于整个项目。接下来，我们将为每个端点制作API处理程序。</p></div><div class="ab cl ls lt hu lu" role="separator"><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx"/></div><div class="ij ik il im in"><h1 id="3a82" class="lz ma iq bd mb mc md me mf mg mh mi mj jw mk jx ml jz mm ka mn kc mo kd mp mq bi translated">文件夹结构</h1><p id="87ba" class="pw-post-body-paragraph kw kx iq ky b kz mr jr lb lc ms ju le lf mt lh li lj mu ll lm ln mv lp lq lr ij bi translated">在我们继续之前，我认为向您展示如何排列子文件夹是有用的。与其写一个冗长全面的解释，我想我不如给你一个我正在谈论的东西的形象:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi nx"><img src="../Images/aaac6ad43588448a47fd50653299c5df.png" data-original-src="https://miro.medium.com/v2/resize:fit:436/0*XguqOdqULAhmTARG"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">我会如何安排我的文件夹。</p></figure><p id="4780" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这假设我们将有管理、用户和产品端点。我们将把<code class="fe ns nt nu nk b">apiClient.js</code>文件放在网络文件夹的根目录下。文件夹的命名甚至结构都只是我个人的喜好。</p><p id="70c5" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">端点将被放在一个<code class="fe ns nt nu nk b">lib</code>文件夹中，并由每个文件中的关注点分开。例如，出于身份验证的目的，用户端点将被放在用户文件中。与产品相关的端点将放在产品文件中。</p></div><div class="ab cl ls lt hu lu" role="separator"><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx"/></div><div class="ij ik il im in"><h1 id="d1cf" class="lz ma iq bd mb mc md me mf mg mh mi mj jw mk jx ml jz mm ka mn kc mo kd mp mq bi translated">编写API处理程序</h1><p id="2c7f" class="pw-post-body-paragraph kw kx iq ky b kz mr jr lb lc ms ju le lf mt lh li lj mu ll lm ln mv lp lq lr ij bi translated">现在我们将编写API处理程序。每个端点都有自己的带有自定义参数的异步函数。所有端点都将使用我们之前定义的客户端。在下面的例子中，我将编写两个API处理程序来获取新产品和添加新产品:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nv nw l"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">产品端点提供商示例。</p></figure><p id="abae" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这基本上概括了我将如何编写API处理程序，正如你所看到的，每个API调用都是干净的，并且都应用了单一责任原则。现在，您可以在主页上引用这些处理程序。</p></div><div class="ab cl ls lt hu lu" role="separator"><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx"/></div><div class="ij ik il im in"><h1 id="783b" class="lz ma iq bd mb mc md me mf mg mh mi mj jw mk jx ml jz mm ka mn kc mo kd mp mq bi translated">在Web应用程序中使用处理程序</h1><p id="c852" class="pw-post-body-paragraph kw kx iq ky b kz mr jr lb lc ms ju le lf mt lh li lj mu ll lm ln mv lp lq lr ij bi translated">假设您使用一个NPM项目来完成所有这些，那么您可以使用<code class="fe ns nt nu nk b">import</code>方法轻松地引用您的JavaScript API处理程序。在这种情况下，我将使用<code class="fe ns nt nu nk b">getProduct</code>端点:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nv nw l"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">使用获取产品端点。</p></figure><p id="6651" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这就是:一个简洁的API处理程序。你已经成功地使你的应用程序可读性更强，更易于维护。</p></div><div class="ab cl ls lt hu lu" role="separator"><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx"/></div><div class="ij ik il im in"><h1 id="ad84" class="lz ma iq bd mb mc md me mf mg mh mi mj jw mk jx ml jz mm ka mn kc mo kd mp mq bi translated">最后的话</h1><p id="fb8d" class="pw-post-body-paragraph kw kx iq ky b kz mr jr lb lc ms ju le lf mt lh li lj mu ll lm ln mv lp lq lr ij bi translated">有一个可用的应用程序是很棒的。你得到了所有的功能，你几乎完成了。然而，人们往往会忘记他们需要维护这个应用程序。因此，迟早，你将不得不重新阅读这些代码。如果它可读性强，易于理解，并且关注点分离得很好，那不是更好吗？我想我们都希望这样，我甚至可以说，如果我们能够阅读我们一年前编写的代码，我们会感到非常自豪。</p><p id="c21f" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">快速并不能保证成功，但是持续和负责能保证成功。写出更好的代码，帮助你的团队成长！感谢阅读。</p></div><div class="ab cl ls lt hu lu" role="separator"><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx"/></div><div class="ij ik il im in"><p id="5069" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><em class="ni">原载于2021年3月9日</em><a class="ae kv" href="https://daily.dev/blog/a-guide-to-writing-clean-api-calls-using-axios" rel="noopener ugc nofollow" target="_blank"><em class="ni">https://daily . dev</em></a><em class="ni">。</em></p><p id="0cc0" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><em class="ni">编辑注:我说错了，说Fetch API是Javascript原生的，而实际上，</em> <a class="ae kv" href="https://stackoverflow.com/questions/44058726/is-the-fetch-api-an-ecmascript-feature" rel="noopener ugc nofollow" target="_blank"> <em class="ni">不是，是浏览器</em> </a> <em class="ni">原生的，老浏览器不支持。你可以在这里</em>  <em class="ni">了解更多</em> <a class="ae kv" href="https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API" rel="noopener ugc nofollow" target="_blank"> <em class="ni">。感谢评论</em> </a><a class="ny nz ep" href="https://medium.com/u/52e936b1a62b?source=post_page-----ddbc7df4256c--------------------------------" rel="noopener" target="_blank"> <em class="ni">尼克·霍华德</em> </a> <em class="ni">！</em></p></div></div>    
</body>
</html>