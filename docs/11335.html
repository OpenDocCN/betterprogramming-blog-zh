<html>
<head>
<title>The Importance of Proper Serverless API Design</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">正确的无服务器API设计的重要性</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/the-importance-of-proper-serverless-api-design-878dfc3d3fcf?source=collection_archive---------10-----------------------#2022-03-09">https://betterprogramming.pub/the-importance-of-proper-serverless-api-design-878dfc3d3fcf?source=collection_archive---------10-----------------------#2022-03-09</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="741e" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">无服务器使您能够在几分钟内创建API。但是仅仅因为你可以，并不意味着你应该</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/909c2dab5bc74849af72c969ea2a84c6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*wuVCDCaLEwKQXn6C95Vs7A.jpeg"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated"><a class="ae ky" href="https://unsplash.com/@campaign_creators?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">活动发起人</a>在<a class="ae ky" href="https://unsplash.com/s/photos/whiteboard?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的照片</p></figure><p id="22b4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">上周，我正在解决一个生产问题。这个问题表明，一些共享文件没有出现在我们的应用程序中，即使它们已经被共享了多次。</p><p id="5c05" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">看起来这是一个很简单的问题。</p><p id="68b2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我去CloudWatch查看负责共享文件的lambda的日志。但是没有错误。一切似乎都很顺利。</p><p id="60ef" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">所以我查看了DynamoDB中“丢失”的一些文件，看看它们是否处于奇怪的状态。又一次，一切似乎都已就绪。日志中没有任何错误是有道理的，数据看起来都是正确的。</p><p id="1eb9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我试着自己重现。我从头开始，但一切似乎又恢复了正常。我觉得一切都很好。所以我去了bug报告的区域，果然，文件不见了。</p><p id="5798" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><em class="lv">到底发生了什么事？</em></p><p id="dab3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我花了很多时间查看lambda文件中同样的100行代码。只是盯着它看。在我脑子里走来走去，试图找出哪里可能会出错。</p><p id="30d0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">然后我遇到了一个转折点。我将报告问题的区域与我试图重现的区域进行了比较，发现了一些问题。我只分享了7或8个文件，但本期报道的那位分享了2000个。<em class="lv">这一定是数据大小的问题</em>。</p><p id="223b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">回到代码中，我看到当我们查询数据时，我们加载了所有的数据。所有文件，相关实体，作品。但是我们不传呼。DynamoDB在单个查询中最多可以检索1 MB的数据。这是我的问题。</p><p id="79cb" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">当DynamoDB的结果超过1 MB的限制时，它会在响应中返回一个<code class="fe lw lx ly lz b">LastEvaluatedKey</code>,这样您就可以从它停止的地方开始运行后续的查询。</p><p id="db44" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">代码忽略了这一点。我从未想到用户会在生产中拥有这么多数据。因此，我后退一步，思考我们建立了什么，哪里出了问题。</p><p id="21d6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这一切都归结于糟糕的REST API设计和糟糕的NoSQL数据建模。</p></div><div class="ab cl ma mb hx mc" role="separator"><span class="md bw bk me mf mg"/><span class="md bw bk me mf mg"/><span class="md bw bk me mf"/></div><div class="im in io ip iq"><h1 id="2a40" class="mh mi it bd mj mk ml mm mn mo mp mq mr jz ms ka mt kc mu kd mv kf mw kg mx my bi translated">分离你的实体</h1><p id="8e9c" class="pw-post-body-paragraph kz la it lb b lc mz ju le lf na jx lh li nb lk ll lm nc lo lp lq nd ls lt lu im bi translated">REST的一个重要方面是它允许直观地深入到您的实体中。如果实体有子代，您应该有一个端点来加载实体，还有一个端点来加载子代。如果孩子有孩子，你就有一个端点来加载孩子的孩子(等等)。假设我们有下面描述的实体模型:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ne"><img src="../Images/b6aed8ca9b1ef100628edef8e995fc13.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*MViTEZFmzee_FV6r.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated"><em class="nf">街坊实体关系图(ERD)</em></p></figure><p id="40fb" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">该视图显示了一个4级实体层次结构，其中<code class="fe lw lx ly lz b">neighborhood</code>位于顶层，它有两个子实体<em class="lv">属性</em>和<em class="lv"> HOA(业主协会)</em>。对于RESTful API设计，端点的结构如下:</p><pre class="kj kk kl km gt ng lz nh ni aw nj bi"><span id="bc6b" class="nk mi it lz b gy nl nm l nn no">/neighborhoods/{neighborhoodId} /neighborhoods/{neighborhoodId}/properties /neighborhoods/{neighborhoodId}/hoa</span></pre><p id="c7eb" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">端点结构是从层次结构的顶部开始，并为您遍历的每个层添加一个路径。</p><p id="042f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在我们的下一层中，<code class="fe lw lx ly lz b">property</code>实体有两个子实体，<code class="fe lw lx ly lz b">trees</code>和<code class="fe lw lx ly lz b">buildings</code>。我们将把这些组织成:</p><pre class="kj kk kl km gt ng lz nh ni aw nj bi"><span id="3655" class="nk mi it lz b gy nl nm l nn no">/neighborhoods/{neighborhoodId}/properties/{propertyId}/trees /neighborhoods/{neighborhoodId}/properties/{propertyId}/buildings</span></pre><p id="3078" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们可以看到<code class="fe lw lx ly lz b">buildings</code>有一个名为<code class="fe lw lx ly lz b">rooms</code>的子实体。因此，我们将这些端点构造为:</p><pre class="kj kk kl km gt ng lz nh ni aw nj bi"><span id="c784" class="nk mi it lz b gy nl nm l nn no">/neighborhoods/{neighborhoodId}/properties/{propertyId}/buildings/{buildingId}/rooms </span><span id="879d" class="nk mi it lz b gy np nm l nn no">/neighborhoods/{neighborhoodId}/properties/{propertyId}/buildings/{buildingId}/rooms/{roomId}</span></pre><p id="fe74" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">上面列出的每个端点都将返回url中列出的最后一个实体(假设这些都是<strong class="lb iu"> GET </strong>端点)。</p><ul class=""><li id="8f72" class="nq nr it lb b lc ld lf lg li ns lm nt lq nu lu nv nw nx ny bi translated"><code class="fe lw lx ly lz b">/neighborhoods/{neighboorhoodId}</code>返回关于<code class="fe lw lx ly lz b">neighborhood</code>实体的数据</li><li id="97c8" class="nq nr it lb b lc nz lf oa li ob lm oc lq od lu nv nw nx ny bi translated"><code class="fe lw lx ly lz b">/neighborhoods/{neighborhoodId}/properties/{propertyId}</code>返回关于特定<code class="fe lw lx ly lz b">property</code>实体的数据</li><li id="b445" class="nq nr it lb b lc nz lf oa li ob lm oc lq od lu nv nw nx ny bi translated"><code class="fe lw lx ly lz b">/neighborhoods/{neighborhoodId}/properties/{propertyId}/buildings/{buildingId}/rooms</code>返回特定<code class="fe lw lx ly lz b">building</code>中所有<em class="lv">房间</em>的列表</li></ul><p id="110a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">以这种方式构造您的数据和端点不仅是一种实现REST的行业标准方式，也是一种帮助您识别和设计NoSQL访问模式的方式。</p><p id="1789" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果您让<code class="fe lw lx ly lz b">/neighborhoods/{neighborhoodId}</code>端点返回关于<code class="fe lw lx ly lz b">neighborhood</code>、<code class="fe lw lx ly lz b">properties</code>、<code class="fe lw lx ly lz b">HOA</code>、<code class="fe lw lx ly lz b">trees</code>、<code class="fe lw lx ly lz b">buildings</code>和<code class="fe lw lx ly lz b">rooms</code>的详细信息，您将会有一个大规模的API调用，它会使<a class="ae ky" href="https://www.howtographql.com/basics/1-graphql-is-the-better-rest/#:~:text=Overfetching%20means%20that%20a%20client,JSON%20array%20with%20user%20data." rel="noopener ugc nofollow" target="_blank">严重地过量获取</a>数据，并且会向您收取过多的费用来调用DynamoDB的数据库。</p></div><div class="ab cl ma mb hx mc" role="separator"><span class="md bw bk me mf mg"/><span class="md bw bk me mf mg"/><span class="md bw bk me mf"/></div><div class="im in io ip iq"><h1 id="825c" class="mh mi it bd mj mk ml mm mn mo mp mq mr jz ms ka mt kc mu kd mv kf mw kg mx my bi translated">单一和多实体NoSQL设计</h1><p id="5afe" class="pw-post-body-paragraph kz la it lb b lc mz ju le lf na jx lh li nb lk ll lm nc lo lp lq nd ls lt lu im bi translated">如果您坚持REST标准，您应该总是有一种简单的方法来获得实体列表并通过id获得单个实体。</p><p id="e1dc" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">有了DynamoDB，就可以用<a class="ae ky" href="https://aws.amazon.com/blogs/database/choosing-the-right-dynamodb-partition-key" rel="noopener ugc nofollow" target="_blank"> <em class="lv">组合键</em> </a>采取下钻的方式。这意味着您可以构建您的散列和范围键来包含多个实体，以便查询您的列表或获得单个实体。</p><p id="06dd" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">例如，对于一个属性，我可以像这样构造我的散列和范围键:</p><pre class="kj kk kl km gt ng lz nh ni aw nj bi"><span id="927d" class="nk mi it lz b gy nl nm l nn no">pk: `${neighborhoodId}#${propertyId}`, <br/>sk: `metadata`</span></pre><p id="04d7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我可以像这样过载排序/范围键:</p><pre class="kj kk kl km gt ng lz nh ni aw nj bi"><span id="e57c" class="nk mi it lz b gy nl nm l nn no">pk: `${neighborhoodId}#${propertyId}`, <br/>sk: `building#${buildingId}`</span></pre><p id="e3ba" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">因此，如果我想获得<em class="lv">属性</em>的细节，我可以用第一个<code class="fe lw lx ly lz b">pk/sk</code>组合做一个<code class="fe lw lx ly lz b">GetItem</code>。如果我想获得关于那个属性的一个列表，我可以使用相同的pk，但是在这里查询。如果我想获得某个特定建筑的详细信息，我可以用该建筑的<code class="fe lw lx ly lz b">pk/sk</code>做一个<code class="fe lw lx ly lz b">GetItem</code>。</p><p id="013f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">您想要避免的是构建一个需要<a class="ae ky" href="https://docs.aws.amazon.com/amazondynamodb/latest/APIReference/API_Query.html#DDB-Query-request-FilterExpression" rel="noopener ugc nofollow" target="_blank"> FilterExpression </a>来查找您想要的数据的结构。在查询之后应用一个<code class="fe lw lx ly lz b">FilterExpression</code>，这意味着您为所有的<a class="ae ky" href="https://docs.aws.amazon.com/amazondynamodb/latest/developerguide/HowItWorks.ReadWriteCapacityMode.html#HowItWorks.requests" rel="noopener ugc nofollow" target="_blank">读取容量单元(rcu)</a>付费。</p><p id="c601" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">无服务器就是为你所使用的东西付费，你不希望不必要地为你永远不会使用的阅读付费。如果您发现自己处于可能过度使用<code class="fe lw lx ly lz b">FilterExpression</code>的情况，后退一步，看看是否可以用不同的方式处理您的数据模型。</p><p id="84a0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我正在研究的虫子碰到了这个。我们围绕共享文件设计了一个不恰当的数据模型，这导致我们结合使用了<code class="fe lw lx ly lz b">FilterExpressions</code>和查询后过滤。这是一些严重的过度提取！</p><p id="4be2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">因此，我们很快就遇到了这个问题(这个问题被忽略了很久), DynamoDB返回了<code class="fe lw lx ly lz b">LastEvaluatedKey</code>,通知我们有更多的数据要加载。</p><p id="06cd" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">但是因为我们没有预料到如此大量的数据，所以我们的代码没有在响应中检查这一点。这导致我们不能处理所有的实体，并且看起来文件丢失了。</p><p id="5a14" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果我们正确设计了数据模型，所有这些都是可以避免的。</p></div><div class="ab cl ma mb hx mc" role="separator"><span class="md bw bk me mf mg"/><span class="md bw bk me mf mg"/><span class="md bw bk me mf"/></div><div class="im in io ip iq"><h1 id="eeee" class="mh mi it bd mj mk ml mm mn mo mp mq mr jz ms ka mt kc mu kd mv kf mw kg mx my bi translated">为大量行动制定计划</h1><p id="de9c" class="pw-post-body-paragraph kz la it lb b lc mz ju le lf na jx lh li nb lk ll lm nc lo lp lq nd ls lt lu im bi translated">使用适当的REST设计，您的端点应该是一串名词。它们提供了一种简单的方法来获得元素的层次结构。但是如果您的应用程序要同时更新数百(或数千)个实体，该怎么办呢？</p><p id="2bf3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">您可能需要为每个实体更新调用一个API。无服务器API绝对可以扩展以满足需求。<em class="lv">但是应该是</em>吗？如果一个用户执行一个操作导致了1000个API调用，那么如果10个用户同时执行这个操作会发生什么呢？100个用户呢？</p><p id="dce6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在并发lambda执行的情况下，您将很快遇到一些服务限制<a class="ae ky" href="https://docs.aws.amazon.com/lambda/latest/dg/gettingstarted-limits.html" rel="noopener ugc nofollow" target="_blank">。你总是可以增加这些限制，但是，你应该这样做吗？</a></p><blockquote class="oe"><p id="3166" class="of og it bd oh oi oj ok ol om on lu dk translated">有时候打破规则是可以的。不要做原教旨主义者。</p></blockquote><p id="1eac" class="pw-post-body-paragraph kz la it lb b lc oo ju le lf op jx lh li oq lk ll lm or lo lp lq os ls lt lu im bi translated">在像这样的场景中，单个用户试图同时更新数百或数千个实体，这时可能需要一个<strong class="lb iu">批处理操作端点</strong>。一个<a class="ae ky" href="https://www.mscharhag.com/api-design/bulk-and-batch-operations" rel="noopener ugc nofollow" target="_blank">批处理动作端点</a>是否是RESTful可以被讨论，但是在某些情况下，它是绝对必要的。</p><p id="faa6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果我们试图更新1000个实体，那么调用10次100可能比调用1000次1更好。这将保持您的并发lambda计数下降，并有助于避免瓶颈。</p><p id="372e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">对于高吞吐量端点，另一种选择是直接从API Gateway集成到SQS，这样您就可以控制批处理大小并限制从队列中读取的lambda函数的并发执行。</p></div><div class="ab cl ma mb hx mc" role="separator"><span class="md bw bk me mf mg"/><span class="md bw bk me mf mg"/><span class="md bw bk me mf"/></div><div class="im in io ip iq"><h1 id="3ad8" class="mh mi it bd mj mk ml mm mn mo mp mq mr jz ms ka mt kc mu kd mv kf mw kg mx my bi translated">改变永远不会太晚</h1><p id="f024" class="pw-post-body-paragraph kz la it lb b lc mz ju le lf na jx lh li nb lk ll lm nc lo lp lq nd ls lt lu im bi translated">如果您发现自己在开始项目时不知道访问模式或高流量端点，那也没关系！使用您所知道的和您预期的主要用例。</p><p id="1d7f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">有很多方法可以在你完成之前获得洞察力。阿尔贝托·赛唯雅的<a class="ae ky" href="https://www.pretotyping.org/" rel="noopener ugc nofollow" target="_blank">《正确的It》一书</a>讲述了你可以采取的降低风险和提前设计的策略。</p><p id="48be" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果你已经构建了你的软件，并且开始遇到像我一样的问题，<em class="lv">解决问题永远不会太晚</em>。您可以构建新的端点，修改现有的端点，或者废弃一些不再使用的端点。只要确保你的应用程序在生产中不会产生<a class="ae ky" href="https://blog.postman.com/how-to-catch-breaking-changes-before-they-happen/" rel="noopener ugc nofollow" target="_blank">突破性的变化</a>就行了。</p><p id="e52b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">您可以重新设计数据模型。在无服务器数据模型之间迁移分为五个步骤:</p><ol class=""><li id="9448" class="nq nr it lb b lc ld lf lg li ns lm nt lq nu lu ot nw nx ny bi translated"><strong class="lb iu">设计</strong> —根据您已知/预期的访问模式开发您的数据模型</li><li id="b823" class="nq nr it lb b lc nz lf oa li ob lm oc lq od lu ot nw nx ny bi translated"><strong class="lb iu">添加</strong> —将新数据模型与旧数据模型并排添加到您的lambdas中</li><li id="4d73" class="nq nr it lb b lc nz lf oa li ob lm oc lq od lu ot nw nx ny bi translated"><strong class="lb iu"> Convert </strong> —创建一个lambda，将旧的数据模型转换为新的数据模型(确保保留旧的实体，以防出错！)</li><li id="cd66" class="nq nr it lb b lc nz lf oa li ob lm oc lq od lu ot nw nx ny bi translated"><strong class="lb iu">移动</strong> —更新您的用户界面或集成，以使用您的新端点或版本，或者访问您的新数据模型的查询字符串参数</li><li id="457d" class="nq nr it lb b lc nz lf oa li ob lm oc lq od lu ot nw nx ny bi translated"><strong class="lb iu">删除</strong> —在所有东西都被迁移后，删除支持旧数据模型的代码。您也可以删除旧数据</li></ol><p id="8c0a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">该方法特别适用于遵循<a class="ae ky" rel="noopener ugc nofollow" target="_blank" href="/are-you-really-ready-for-ci-cd-9a8bf6d01b8a"> CI/CD方法</a>的应用。当您一点一点地进行更改时，您必须确保迁移成功，没有任何停机时间。</p><p id="1b1f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">使用指标来确定您呼叫最多的端点。是否有任何运行的并发执行比其他运行的多得多？是同一个用户打了大量的电话吗？对于lambda函数，您可以获得<a class="ae ky" href="https://docs.aws.amazon.com/lambda/latest/dg/monitoring-insights.html" rel="noopener ugc nofollow" target="_blank">难以置信的有价值的洞察力</a>,让您挑选出异常值和批量操作的候选者。</p><p id="2019" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">软件，尤其是无服务器软件，应该处于不断重构的<a class="ae ky" rel="noopener ugc nofollow" target="_blank" href="/how-to-refactor-serverless-applications-the-right-way-fb5e80c71d36">状态</a>。您可以深入了解应用程序每天的使用情况，添加功能，调试问题。这些事情中的每一件都是改进您的应用程序的学习机会。</p><blockquote class="ou ov ow"><p id="693c" class="kz la lv lb b lc ld ju le lf lg jx lh ox lj lk ll oy ln lo lp oz lr ls lt lu im bi translated"><em class="it">你永远不会比现在知道得更少。</em></p></blockquote><p id="bcf2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">利用这些见解来改进您的数据模型，优化性能和成本，并为您的用户带来<a class="ae ky" href="https://medium.com/swlh/design-to-delight-raising-the-bar-on-software-design-a1eec234188b" rel="noopener">愉悦的体验</a>。</p><p id="329e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">编码快乐！</p></div></div>    
</body>
</html>