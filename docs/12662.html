<html>
<head>
<title>Android MultiTriggerBomb — Prevent Code Execution Till All Triggers Are Down (or Timer Is Expired)</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Android MultiTriggerBomb —阻止代码执行，直到所有触发器都关闭(或定时器到期)</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/how-to-prevent-code-execution-till-all-triggers-are-down-or-timer-is-expired-989248849392?source=collection_archive---------18-----------------------#2022-06-20">https://betterprogramming.pub/how-to-prevent-code-execution-till-all-triggers-are-down-or-timer-is-expired-989248849392?source=collection_archive---------18-----------------------#2022-06-20</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="6665" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">上一次，您需要在“n”个事件(同步/异步)完成之前阻止(而不是等待)代码的执行，您是如何解决这个问题的？</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/afeb929ef031ee4801da0c40ad0d044a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*Z8O_6aXKT-XWjbax"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">Jason Mitrione 在<a class="ae kv" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</p></figure><p id="52e8" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">看到这个问题第一个想到的解决方案就是Java的<code class="fe ls lt lu lv b">CountDownLatch</code>。倒计时锁存器有一个<code class="fe ls lt lu lv b"><a class="ae kv" href="https://medium.com/microsoft-mobile-engineering/improve-android-app-screen-launch-times-using-lazylifecycle-callbacks-d48b5c9cdb5e" rel="noopener">await</a>()</code>调用，使调用线程等待，直到<code class="fe ls lt lu lv b">n</code>个<code class="fe ls lt lu lv b">countDowns()</code>被调用。这里，我们不希望线程等待。这更像是我们在使用应用程序，当“<code class="fe ls lt lu lv b">n</code>”事件发生时，我们触发一段代码，或者如果截止日期被覆盖，我们仍然执行代码。</p><p id="7fbf" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">要求是条件可以在多线程上变为真，但是我们必须确保代码不应该执行超过一次。我们必须处理计时器到期和条件匹配同时发生的情况，并确保它不会多次触发代码或进入不稳定状态。</p><blockquote class="lw lx ly"><p id="469d" class="kw kx lz ky b kz la jr lb lc ld ju le ma lg lh li mb lk ll lm mc lo lp lq lr ij bi translated">在转向解决方案之前，如果我们必须用清晰的语言来定义问题陈述，那么“<code class="fe ls lt lu lv b"><em class="iq">MultiTriggerBomb</em></code>有助于通知，并在多个异步/同步调用完成时执行一些代码它还提供了额外的超时来保护执行。</p><p id="07cf" class="kw kx lz ky b kz la jr lb lc ld ju le ma lg lh li mb lk ll lm mc lo lp lq lr ij bi translated">您还可以使用bomb连接代码库中的多个回调/事件/条件，并获得开箱即用的状态管理和线程安全。</p></blockquote><p id="0964" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们可以通过使用if-else检查和布尔来维护条件的状态，从而构建一个解决方案。但是，在微软团队工作时，我们会多次遇到这种情况。因此，这是不可扩展的，并且容易出错。</p><p id="13af" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><em class="lz">一个例子是，我们希望阻止一些非关键代码(如预取图像、刷新身份验证令牌、下载用户头像等)。)直到一些关键代码路径完成(一些关键路径是，</em> <strong class="ky ir"> <em class="lz"> 1。</em> </strong> <em class="lz">屏幕得到渲染，</em> <strong class="ky ir"> <em class="lz"> 2。</em> </strong> <em class="lz">消息计数已更新，</em> <strong class="ky ir"> <em class="lz"> 3。</em> </strong> <em class="lz">当前屏幕已完成同步)被跟踪为应用程序的关键错误并影响应用程序的整体性能。所以基本上我们会保留其他工作，直到1、2和3完成。如果出现一些错误，并且一个或所有步骤都失败了，那么超时可以帮助我们执行代码。</em></p><p id="0fd8" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">如果您的调用与android的生命周期回调有关，我们已经构建了一个名为<code class="fe ls lt lu lv b">LazyLifecycleCallbacks</code>的构造，您可以在这里查看，它有<code class="fe ls lt lu lv b">onLazyCreate()</code>、<code class="fe ls lt lu lv b">onLazyStart()</code>和<code class="fe ls lt lu lv b">onLazyResume()</code>。我们用一个叫做<code class="fe ls lt lu lv b">Barrier</code>的概念构建了这个结构，但是很快意识到<code class="fe ls lt lu lv b">barrier</code>有它的局限性，所以我们用<code class="fe ls lt lu lv b">MultiTriggerBomb</code>重新实现了它。</p><div class="md me gp gr mf mg"><a href="https://medium.com/microsoft-mobile-engineering/improve-android-app-screen-launch-times-using-lazylifecycle-callbacks-d48b5c9cdb5e" rel="noopener follow" target="_blank"><div class="mh ab fo"><div class="mi ab mj cl cj mk"><h2 class="bd ir gy z fp ml fr fs mm fu fw ip bi translated">使用LazyLifecycle回调改进android应用/屏幕启动时间。</h2><div class="mn l"><h3 class="bd b gy z fp ml fr fs mm fu fw dk translated">想改善你的android应用程序的屏幕启动时间吗？了解如何实现这一目标！</h3></div><div class="mo l"><p class="bd b dl z fp ml fr fs mm fu fw dk translated">medium.com</p></div></div><div class="mp l"><div class="mq l mr ms mt mp mu kp mg"/></div></div></a></div><p id="0fe9" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">回到主题，我们需要一些通用的东西，可以在多种条件下工作，是线程安全的，并且可以很容易地被开发人员接受。此外，经过适当测试，因此我们可以信任其功能。</p><p id="c590" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这个用例看起来像一个多触发器炸弹。一个炸弹有多个触发器，在炸弹爆炸前按下，并有一个计时器。它看起来像这样:</p><pre class="kg kh ki kj gt mv lv mw mx aw my bi"><span id="8d02" class="mz na iq lv b gy nb nc l nd ne"><em class="lz">* |-----------------------------------------------|<br/>* |                                               |<br/>* | [s1] --- [s2] --- [s3] ---[s4] --- [s5] ---   |  ----&gt; [CHARGE]<br/>* |                                               |        ^<br/>* |------------|----------------------------------|        |<br/>*              |                                           |<br/>*              |________________t seconds__________________|</em></span></pre><p id="df41" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我觉得如果我能做一个API界面，看起来像一个真正的炸弹的交互方式，那就太好了。开发人员将能够很容易地与它联系起来，一个新的行话将被引入来解决这类问题。因此，公开的API如下:</p><pre class="kg kh ki kj gt mv lv mw mx aw my bi"><span id="c6fa" class="mz na iq lv b gy nb nc l nd ne">var hasExploded = false<br/>    private set</span><span id="f111" class="mz na iq lv b gy nf nc l nd ne">var isPlanted = false<br/>    private set</span><span id="d075" class="mz na iq lv b gy nf nc l nd ne">private val charge: () -&gt; Unit</span><span id="7af4" class="mz na iq lv b gy nf nc l nd ne">fun plant()<br/>fun down(cause: String = "")<br/>fun tryDiffuse()</span><span id="07e2" class="mz na iq lv b gy nf nc l nd ne">private fun explode()</span></pre><p id="e737" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">就像真的炸弹一样，一旦炸弹被制造出来，它就会被植入炸药，你可以<code class="fe ls lt lu lv b">plant()</code>它，同时计时器也会启动。要按下扳机，你需要一个<code class="fe ls lt lu lv b">down()</code>按钮。一旦所有的触发器都关闭或者计时器超时，炸弹就会爆炸。炸弹也可以在爆炸发生前爆炸。</p><p id="f0a2" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">现在我知道了炸弹需要遵守的所有合同，我们都可以参与其中。不是吗？然后我写了实际的实现。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ng nh l"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">MultiTriggerBomb.kt</p></figure><p id="c089" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">要使用它，我们需要编写一个简单的代码:</p><pre class="kg kh ki kj gt mv lv mw mx aw my bi"><span id="ed4c" class="mz na iq lv b gy nb nc l nd ne">// Create a bomb.<br/>multiTriggerBomb = MultiTriggerBomb(5, timerDuration) {<br/>   // Code that needs to get fired on explosion<br/>}</span><span id="1a1e" class="mz na iq lv b gy nf nc l nd ne">// plant it!<br/>multiTriggerBomb?.plant()</span></pre><p id="168e" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">每当其中一个条件为真时，用可选的原因参数调用<code class="fe ls lt lu lv b">down()</code>。</p><pre class="kg kh ki kj gt mv lv mw mx aw my bi"><span id="6f47" class="mz na iq lv b gy nb nc l nd ne">multiTriggerBomb?.down("some condition satisfied")</span></pre><p id="f842" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">当所有的条件都为真或者计时器超时，我们的炸弹就会爆炸并执行植入其中的代码。</p><p id="5a7e" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这就是我们如何在代码库中植入炸弹的！</p></div></div>    
</body>
</html>