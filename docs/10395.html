<html>
<head>
<title>Introduction to Concurrency Swift With Async and Await</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">带异步和等待的并发Swift简介</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/introduction-to-concurrency-swift-with-async-and-await-1d3b03226585?source=collection_archive---------7-----------------------#2022-01-04">https://betterprogramming.pub/introduction-to-concurrency-swift-with-async-and-await-1d3b03226585?source=collection_archive---------7-----------------------#2022-01-04</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><h2 id="2cb4" class="ir is it bd b dl iu iv iw ix iy iz dk ja translated" aria-label="kicker paragraph">并发</h2><div class=""/><div class=""><h2 id="8765" class="pw-subtitle-paragraph jz jc it bd b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq dk translated">了解如何使用Swift并发功能</h2></div><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi kr"><img src="../Images/69b3a8bcd533244670aef35d344fca1a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*bDnFW4EsdQATGbw3"/></div></div><p class="ld le gj gh gi lf lg bd b be z dk translated">尼古拉斯·霍伊泽在<a class="ae lh" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</p></figure><p id="8339" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">你的app有没有遭遇用户界面时不时被冻结的情况？你的应用程序会因为没有响应而被系统杀死吗？</p><p id="8418" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">出现上述情况的应用程序可能是因为您的应用程序在负责响应用户界面交互的同一进程中执行了繁重和/或长时间的任务。</p><p id="94dd" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">例如，您可以从web服务器获取图像，这可能需要几秒钟的时间。当你的应用程序的进程等待接收图像时，它不会响应用户的交互。</p><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi me"><img src="../Images/fccb993f0686d9248b125b4374e5df5c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*5tXs_6a5BLGR6STMh4tgMQ.jpeg"/></div></div></figure><p id="f85b" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">那么，在执行繁重或长时间的任务时，如何防止应用程序的用户界面冻结甚至崩溃呢？</p><p id="40f0" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">答案是将任务从负责响应用户界面的应用程序流程部分转移到一个新的部分。应用程序进程的一部分被称为线程。</p><p id="40e5" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">线程允许你同时执行多段代码——这是并发的。</p><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi mf"><img src="../Images/1adf497ae21b4b4ca91af6fb85f2c4e7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*jqcaelX0FNIUFdFfb1x0fg.jpeg"/></div></div></figure><p id="37f3" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">委派任务并继续执行自己的任务，直到委派的任务返回结果，这种行为称为异步执行任务。</p><p id="316d" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">在任务执行之前，我们不会等待阻塞。当等待任务被执行时，我们才继续自己的任务，这被称为<strong class="lk jd">同步</strong>。</p><p id="05f3" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">Apple提供了多种方式在iOS平台上同时执行任务:</p><ul class=""><li id="34b6" class="mg mh it lk b ll lm lo lp lr mi lv mj lz mk md ml mm mn mo bi translated">中央车站调度</li><li id="0a42" class="mg mh it lk b ll mp lo mq lr mr lv ms lz mt md ml mm mn mo bi translated">操作和操作队列</li></ul><p id="e8a7" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">最近，Swift开始提供一种新的并发执行方式——通过使用<a class="ae lh" href="https://docs.swift.org/swift-book/LanguageGuide/Concurrency.html" rel="noopener ugc nofollow" target="_blank"> async和await </a>关键字。</p><p id="b372" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">在这篇文章中，我将通过一个制作沙拉的应用程序示例，向您展示如何使用Swift并发特性并发执行任务。在此之前，我将更详细地解释一下进程和线程这两个词的含义。</p><p id="8920" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">对于这篇文章，我假设你至少对iOS和Swift开发有基本的了解。</p><p id="da81" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">示例应用程序使用SwiftUI，但不要求具备SwiftUI知识。</p><h1 id="2d81" class="mu mv it bd mw mx my mz na nb nc nd ne ki nf kj ng kl nh km ni ko nj kp nk nl bi translated">什么是进程和线程？</h1><p id="22ac" class="pw-post-body-paragraph li lj it lk b ll nm kd ln lo nn kg lq lr no lt lu lv np lx ly lz nq mb mc md im bi translated">假设用户在主屏幕上。用户点击你的应用。这会告诉iOS启动您的应用程序。在这种情况下，iOS将为您的应用程序创建一个新进程，并创建一个线程。</p><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi nr"><img src="../Images/215264bec004763dd4da0be2fed6492e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*hP0CsIPuODfEfrW5qUjDOA.jpeg"/></div></div></figure><p id="c0d0" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">进程是程序的一个实例——在这种情况下，是您的应用程序。在iOS中，你只能运行一个应用实例。对于每个进程或实例，操作系统将把你的程序从磁盘加载到内存中。</p><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div class="gh gi ns"><img src="../Images/377726cc5ee6431d857b3d03a6ecb3a4.png" data-original-src="https://miro.medium.com/v2/resize:fit:900/format:webp/1*k5KY5X5jXtC57VCiyXM6Aw.jpeg"/></div></figure><p id="fca2" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">iOS中的每个app进程都是用一个线程启动的。这被称为<strong class="lk jd">主线程</strong>或<strong class="lk jd"> UI线程</strong>。您的应用程序或程序可以访问其他线程。线程共享相同的内存空间。</p><p id="2efc" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">线程是一系列指令。你的程序向线程发送指令。这些被排队并执行先来先服务，或者更普遍地被称为先进先出(FIFO)。</p><h1 id="abbf" class="mu mv it bd mw mx my mz na nb nc nd ne ki nf kj ng kl nh km ni ko nj kp nk nl bi translated">如何用async和await同时执行任务</h1><p id="4e8c" class="pw-post-body-paragraph li lj it lk b ll nm kd ln lo nn kg lq lr no lt lu lv np lx ly lz nq mb mc md im bi translated">在本节中，我们将实际使用Swift的async和await。我们将从现有的应用程序开始。这个应用程序为我们创造了一个沙拉碗。沙拉准备顺序如下:</p><ol class=""><li id="af25" class="mg mh it lk b ll lm lo lp lr mi lv mj lz mk md nt mm mn mo bi translated">生菜；莴苣</li><li id="5e4e" class="mg mh it lk b ll mp lo mq lr mr lv ms lz mt md nt mm mn mo bi translated">番茄</li><li id="2088" class="mg mh it lk b ll mp lo mq lr mr lv ms lz mt md nt mm mn mo bi translated">红洋葱</li><li id="699e" class="mg mh it lk b ll mp lo mq lr mr lv ms lz mt md nt mm mn mo bi translated">甜玉米</li><li id="66b9" class="mg mh it lk b ll mp lo mq lr mr lv ms lz mt md nt mm mn mo bi translated">葵花籽油金枪鱼</li></ol><p id="17be" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">在准备沙拉的时候，应用程序会冻结，因为制作沙拉的工作是在主线程(也称为UI线程)上完成的。我们将使用Swift并发功能(异步和等待)修复应用程序冻结问题。</p><p id="f817" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">以下是本部分将采取的步骤:</p><ol class=""><li id="ffa0" class="mg mh it lk b ll lm lo lp lr mi lv mj lz mk md nt mm mn mo bi translated">下载入门包</li><li id="4fa7" class="mg mh it lk b ll mp lo mq lr mr lv ms lz mt md nt mm mn mo bi translated">使用async和await将沙拉准备从UI线程中移走</li><li id="542e" class="mg mh it lk b ll mp lo mq lr mr lv ms lz mt md nt mm mn mo bi translated">不点菜准备沙拉</li></ol><p id="06f2" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">我们开始吧！</p><p id="9425" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">对于本文，我使用了Swift 5.5.2和Xcode 13.2.1。</p><h2 id="3b52" class="nv mv it bd mw nw nx dn na ny nz dp ne lr oa ob ng lv oc od ni lz oe of nk iz bi translated">1.下载入门包</h2><p id="d771" class="pw-post-body-paragraph li lj it lk b ll nm kd ln lo nn kg lq lr no lt lu lv np lx ly lz nq mb mc md im bi translated">让我们从下载入门包开始。打开终端应用程序并执行以下命令:</p><pre class="ks kt ku kv gt og oh oi oj aw ok bi"><span id="b821" class="nv mv it oh b gy ol om l on oo">cd $HOME<br/>curl <a class="ae lh" href="https://github.com/anuragajwani/swift-concurrency-salad-maker/archive/starter.zip" rel="noopener ugc nofollow" target="_blank">https://github.com/anuragajwani/swift-concurrency-salad-maker/archive/starter.zip</a> -o salad_maker.zip -L -s<br/>unzip -q salad_maker.zip<br/>cd swift-concurrency-salad-maker-starter<br/>open -a Xcode SaladMaker.xcodeproj</span></pre><p id="5ba0" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">在模拟器上运行应用程序。点击“准备沙拉”按钮。你会注意到应用程序在开始做沙拉时会冻结。让我们在下一节中研究为什么会出现这种情况，并解决它。</p><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div class="gh gi op"><img src="../Images/75f3923090e3c4ffe221510cf4295a7d.png" data-original-src="https://miro.medium.com/v2/resize:fit:592/1*qPPZEZxSQaLnE-etpF2Tdw.gif"/></div></figure><h2 id="38c0" class="nv mv it bd mw nw nx dn na ny nz dp ne lr oa ob ng lv oc od ni lz oe of nk iz bi translated">2.使用async和await将沙拉准备从UI线程中移走</h2><p id="2792" class="pw-post-body-paragraph li lj it lk b ll nm kd ln lo nn kg lq lr no lt lu lv np lx ly lz nq mb mc md im bi translated">在这一节中，我们将把沙拉制作过程从同步改为异步。我们将只查看一个文件。在Xcode内打开<code class="fe oq or os oh b">SaladMaker.swift</code>。</p><pre class="ks kt ku kv gt og oh oi oj aw ok bi"><span id="439c" class="nv mv it oh b gy ol om l on oo"><strong class="oh jd">class</strong> SaladMaker {<br/>    <strong class="oh jd">func</strong> make(onIngrdientPrepped: <strong class="oh jd">@escaping</strong> (Ingredient) -&gt; ()) {<br/>        Ingredient.allCases.forEach { (ingredient) <strong class="oh jd">in<br/>            self</strong>.prepareIngredient(ingredient)<br/>            onIngrdientPrepped(ingredient)<br/>        }<br/>    }</span><span id="c782" class="nv mv it oh b gy ot om l on oo"><strong class="oh jd">    private</strong> <strong class="oh jd">func</strong> prepareIngredient(_ ingredient: Ingredient) {<br/>        <strong class="oh jd">let</strong> randomTime = UInt32.random(in: 1...5)<br/>        sleep(randomTime) // chop, cut, etc...<br/>    }<br/>}</span></pre><p id="669d" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">当前的代码将成分按顺序排列并“准备”它们。但是它在主线程上同步完成。从而阻止用户界面响应用户交互。</p><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi ou"><img src="../Images/ffe8b00555d2e0f6932f978724f3e438.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*wwIoHZ_WDt8WM3QeVAfD6w.jpeg"/></div></div></figure><p id="a454" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">让我们将<code class="fe oq or os oh b">SaladMaker</code>类改为使用async和await来异步准备沙拉。然而，我们将同步准备每种成分，因为准备的顺序很重要。将<code class="fe oq or os oh b">SaladMaker</code>改为:</p><pre class="ks kt ku kv gt og oh oi oj aw ok bi"><span id="2e63" class="nv mv it oh b gy ol om l on oo"><strong class="oh jd">class</strong> SaladMaker {<br/>    <strong class="oh jd">func</strong> make(onIngrdientPrepped: <strong class="oh jd">@escaping</strong> (Ingredient) -&gt; ()) {<br/>        Task(priority: .userInitiated) {<br/>            <strong class="oh jd">for</strong> ingredient <strong class="oh jd">in</strong> Ingredient.allCases {<br/>                <strong class="oh jd">await</strong> prepareIngredient(ingredient)<br/>                onIngrdientPrepped(ingredient)<br/>            }<br/>        }<br/>    }</span><span id="cf91" class="nv mv it oh b gy ot om l on oo"><strong class="oh jd">    private</strong> <strong class="oh jd">func</strong> prepareIngredient(_ ingredient: Ingredient) <strong class="oh jd">async</strong> {<br/>        <strong class="oh jd">return</strong> <strong class="oh jd">await</strong> withCheckedContinuation({ continuation <strong class="oh jd">in<br/>            </strong>// using DispatchQueue here instead of Task due to unexpected behaviour<strong class="oh jd"><br/>            </strong>DispatchQueue.global(qos: .userInitiated).async {<br/>                <strong class="oh jd">let</strong> randomTime = UInt32.random(in: 1...5)<br/>                sleep(randomTime)<br/>                continuation.resume()<br/>            }<br/>        })<br/>    }<br/>}</span></pre><p id="b1e1" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">在上面的代码中，我们已经从同步准备每种成分转移到异步准备它们。在模拟器上运行应用程序。</p><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div class="gh gi op"><img src="../Images/0f2870bef0cf74634f9d4dc23c4d0529.png" data-original-src="https://miro.medium.com/v2/resize:fit:592/1*XQJLD8LV0tWM1MyCaKTaKw.gif"/></div></figure><p id="7e41" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">你会注意到应用程序不再冻结。让我们分解解决方案，看看上面的代码是如何实现的。</p><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi ov"><img src="../Images/dcdbc61e681fb04d30d178f84664c88f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ey2VM8gTyRGj6EoXtXZy7w.jpeg"/></div></div></figure><p id="7704" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">注意上面的main/UI线程现在是如何清晰地响应用户交互的。</p><p id="c5cb" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">让我们从探索<code class="fe oq or os oh b">prepareIngredient</code>功能变化开始:</p><pre class="ks kt ku kv gt og oh oi oj aw ok bi"><span id="d24a" class="nv mv it oh b gy ol om l on oo"><strong class="oh jd">private</strong> <strong class="oh jd">func</strong> prepareIngredient(_ ingredient: Ingredient) <strong class="oh jd">async</strong> {<br/>    <strong class="oh jd">return</strong> <strong class="oh jd">await</strong> withCheckedContinuation({ continuation <strong class="oh jd">in<br/>        </strong>// using DispatchQueue here instead of Task due to unexpected behaviour<br/>        DispatchQueue.global(qos: .userInitiated).async {<br/>            <strong class="oh jd">let</strong> randomTime = UInt32.random(in: 1...5)<br/>            sleep(randomTime)<br/>            continuation.resume()<br/>        }<br/>    })<br/>}</span></pre><p id="b596" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">注意，函数在函数返回类型语句之前声明了<code class="fe oq or os oh b">async</code>。这告诉Swift编译器该函数异步执行。</p><p id="0d43" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">以前<code class="fe oq or os oh b">prepareIngredient</code>功能代码是同步的。</p><p id="41ea" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">为了将同步代码转移到异步代码，我们使用了<code class="fe oq or os oh b"><a class="ae lh" href="https://developer.apple.com/documentation/swift/3814988-withcheckedcontinuation" rel="noopener ugc nofollow" target="_blank">withCheckedContinuation</a></code>函数。</p><p id="b784" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated"><a class="ae lh" href="https://developer.apple.com/documentation/swift/checkedcontinuation" rel="noopener ugc nofollow" target="_blank"> Swift有内置功能</a>比如这个功能，以弥补同步和异步功能之间的差距。该函数将检查<code class="fe oq or os oh b"><a class="ae lh" href="https://developer.apple.com/documentation/swift/checkedcontinuation/3814760-resume" rel="noopener ugc nofollow" target="_blank">continuation.resume()</a></code>是否被调用过一次。</p><p id="349a" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">此时，每种配料都是异步准备的。但是，我们希望按照顺序并在前一个配料完成后准备配料。那么，我们如何才能做到这一点呢？</p><p id="2f57" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">通过在调用异步<code class="fe oq or os oh b">prepareIngredient</code>函数之前使用关键字<code class="fe oq or os oh b">await</code>:</p><pre class="ks kt ku kv gt og oh oi oj aw ok bi"><span id="8c92" class="nv mv it oh b gy ol om l on oo"><strong class="oh jd">await</strong> prepareIngredient(ingredient)</span></pre><p id="e1bf" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">我们按顺序一个接一个地循环检查配料，直到它准备好。</p><p id="f3ad" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">然后我们通知<code class="fe oq or os oh b">make</code>函数调用者该配料的准备状态(<code class="fe oq or os oh b">onIngrdientPrepped</code>关闭):</p><pre class="ks kt ku kv gt og oh oi oj aw ok bi"><span id="8954" class="nv mv it oh b gy ol om l on oo"><strong class="oh jd">for</strong> ingredient <strong class="oh jd">in</strong> Ingredient.allCases {<br/>    <strong class="oh jd">await</strong> prepareIngredient(ingredient)<br/>    onIngrdientPrepped(ingredient)<br/>}</span></pre><p id="c1d3" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">注意<code class="fe oq or os oh b">make</code>功能是同步功能。我们不能只在同步函数中调用异步函数。我们不能在<code class="fe oq or os oh b">make</code>内调用<code class="fe oq or os oh b">prepareIngredient</code>。</p><p id="e99d" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">为了允许在同步函数中调用异步函数，我们可以使用<code class="fe oq or os oh b"><a class="ae lh" href="https://developer.apple.com/documentation/swift/task" rel="noopener ugc nofollow" target="_blank">Task</a></code>。该任务允许我们在其中运行异步代码。</p><h2 id="5c86" class="nv mv it bd mw nw nx dn na ny nz dp ne lr oa ob ng lv oc od ni lz oe of nk iz bi translated">3.不点菜准备沙拉</h2><p id="2e82" class="pw-post-body-paragraph li lj it lk b ll nm kd ln lo nn kg lq lr no lt lu lv np lx ly lz nq mb mc md im bi translated">如果做沙拉的顺序不重要呢？如果沙拉顾客不想要花哨的展示，只想在旅途中吃沙拉，该怎么办？</p><p id="6933" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">假设每种配料需要1秒钟的准备时间。有5种配料，所以准备沙拉需要5秒钟。如果我们不在乎沙拉的顺序，那么我们可以同时准备所有的配料。因此，我们有可能在1秒钟内完成沙拉(基于可用的系统资源)。</p><p id="74b0" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">那么，我们如何并行(或同时)快速地准备沙拉配料呢？有两种方法:</p><ol class=""><li id="8d86" class="mg mh it lk b ll lm lo lp lr mi lv mj lz mk md nt mm mn mo bi translated"><code class="fe oq or os oh b"><a class="ae lh" href="https://docs.swift.org/swift-book/LanguageGuide/Concurrency.html#ID641" rel="noopener ugc nofollow" target="_blank">async let</a></code></li><li id="f3fc" class="mg mh it lk b ll mp lo mq lr mr lv ms lz mt md nt mm mn mo bi translated"><code class="fe oq or os oh b"><a class="ae lh" href="https://developer.apple.com/documentation/swift/taskgroup/" rel="noopener ugc nofollow" target="_blank">TaskGroup</a></code></li></ol><p id="86fb" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">让我们从<a class="ae lh" href="https://docs.swift.org/swift-book/LanguageGuide/Concurrency.html#ID641" rel="noopener ugc nofollow" target="_blank">异步let </a>开始。</p><p id="6b55" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">这种机制允许我们并行准备所有的配料。代码将在第一次调用<code class="fe oq or os oh b">await</code>时暂停。</p><p id="b8bd" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">当所有的异步let在<code class="fe oq or os oh b">await</code>之前完成时，代码将继续执行。</p><p id="bd90" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">将<code class="fe oq or os oh b">make</code>功能体更改如下:</p><pre class="ks kt ku kv gt og oh oi oj aw ok bi"><span id="0117" class="nv mv it oh b gy ol om l on oo"><strong class="oh jd">func</strong> make(onIngrdientPrepped: <strong class="oh jd">@escaping</strong> (Ingredient) -&gt; ()) {<br/>    Task(priority: .userInitiated) {<br/>        <strong class="oh jd">async</strong> <strong class="oh jd">let</strong> lettuce = prepareIngredient(.lettuce)<br/>        <strong class="oh jd">async</strong> <strong class="oh jd">let</strong> tomatoes = prepareIngredient(.tomatoes)<br/>        <strong class="oh jd">async</strong> <strong class="oh jd">let</strong> redOnion = prepareIngredient(.redOnion)<br/>        <strong class="oh jd">async</strong> <strong class="oh jd">let</strong> sweetcorn = prepareIngredient(.sweetcorn)<br/>        <strong class="oh jd">async</strong> <strong class="oh jd">let</strong> tuna = prepareIngredient(.tuna)<br/>        <strong class="oh jd">let</strong> ingredients = <strong class="oh jd">await</strong> [lettuce, tomatoes, redOnion, sweetcorn, tuna]<br/>        ingredients.forEach(onIngrdientPrepped)<br/>    }<br/>}</span></pre><p id="8305" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">和下面的<code class="fe oq or os oh b">prepareIngredient</code>功能:</p><pre class="ks kt ku kv gt og oh oi oj aw ok bi"><span id="0809" class="nv mv it oh b gy ol om l on oo"><strong class="oh jd">private</strong> <strong class="oh jd">func</strong> prepareIngredient(_ ingredient: Ingredient) <strong class="oh jd">async</strong> -&gt; Ingredient {<br/>    <strong class="oh jd">return</strong> <strong class="oh jd">await</strong> withCheckedContinuation({ continuation <strong class="oh jd">in<br/>        </strong>// using DispatchQueue here instead of Task due to unexpected behaviour<br/>        DispatchQueue.global(qos: .userInitiated).async {<br/>            <strong class="oh jd">let</strong> randomTime = UInt32.random(in: 1...5)<br/>            sleep(randomTime)<br/>            continuation.resume(returning: ingredient)<br/>        }<br/>    })<br/>}</span></pre><p id="48da" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">注意我们如何通过使用关键字<code class="fe oq or os oh b">async let</code>来存储异步引用。</p><p id="e62e" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">然而，我们不能将它们直接存储在一个数组中。该选项目前在Swift中不可用，因此我们必须将每个异步字母存储为一个单独变量。</p><p id="5e9b" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">此外，我们需要让<code class="fe oq or os oh b">prepareIngredient</code>返回一个结果，以便能够存储异步let引用。</p><p id="2882" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">对<code class="fe oq or os oh b">async let</code>还有另一个警告。在上面的解决方案中，我们只通知<code class="fe oq or os oh b">SaladMaker.make</code>调用者所有的配料都准备好了，而不是它们准备好了。</p><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div class="gh gi op"><img src="../Images/17e64603ee64603ffd88c47ad536988b.png" data-original-src="https://miro.medium.com/v2/resize:fit:592/1*LqJSh6pYvlJtiSHJiIuytw.gif"/></div></figure><p id="ae5f" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">那么，我们如何并行运行所有的异步函数，并在每种成分都准备好时更新调用者呢？</p><p id="7fb3" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">通过使用<a class="ae lh" href="https://developer.apple.com/documentation/swift/taskgroup/" rel="noopener ugc nofollow" target="_blank">任务组</a>。让我们将<code class="fe oq or os oh b">SaladMaker</code>函数体修改如下:</p><pre class="ks kt ku kv gt og oh oi oj aw ok bi"><span id="e3bd" class="nv mv it oh b gy ol om l on oo"><strong class="oh jd">func</strong> make(onIngrdientPrepped: <strong class="oh jd">@escaping</strong> (Ingredient) -&gt; ()) {<br/>    Task(priority: .userInitiated) {<br/>        <strong class="oh jd">await</strong> withTaskGroup(of: Ingredient.<strong class="oh jd">self</strong>, body: { group <strong class="oh jd">in<br/>            for</strong> ingredient <strong class="oh jd">in</strong> Ingredient.allCases {<br/>                group.addTask(priority: .userInitiated) {<br/>                   <strong class="oh jd">await</strong> <strong class="oh jd">self</strong>.prepareIngredient(ingredient)<br/>                }<br/>            }</span><span id="2f73" class="nv mv it oh b gy ot om l on oo"><strong class="oh jd">            for</strong> <strong class="oh jd">await</strong> ingredientPrepped <strong class="oh jd">in</strong> group {<br/>                onIngrdientPrepped(ingredientPrepped)<br/>            }<br/>        })<br/>    }<br/>}</span></pre><p id="c1fa" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">TaskGroup允许我们并行运行多个异步功能:</p><pre class="ks kt ku kv gt og oh oi oj aw ok bi"><span id="5ad2" class="nv mv it oh b gy ol om l on oo"><strong class="oh jd">for</strong> ingredient <strong class="oh jd">in</strong> Ingredient.allCases {<br/>    group.addTask(priority: .userInitiated) {<br/>        <strong class="oh jd">await</strong> <strong class="oh jd">self</strong>.prepareIngredient(ingredient)<br/>    }<br/>}</span></pre><p id="92f3" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">此外，<a class="ae lh" href="https://developer.apple.com/documentation/swift/taskgroup/" rel="noopener ugc nofollow" target="_blank"> TaskGroup </a>会在结果出来时通知我们:</p><pre class="ks kt ku kv gt og oh oi oj aw ok bi"><span id="35ed" class="nv mv it oh b gy ol om l on oo"><strong class="oh jd">for</strong> <strong class="oh jd">await</strong> ingredientPrepped <strong class="oh jd">in</strong> group {<br/>    onIngrdientPrepped(ingredientPrepped)<br/>}</span></pre><p id="fb90" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">运行应用程序，在配料准备好后立即查看用户界面更新:</p><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div class="gh gi op"><img src="../Images/d2dbd4b8c18af76cc1447cde3e8c0fe3.png" data-original-src="https://miro.medium.com/v2/resize:fit:592/1*XuIgjtYJBmMJFkshnnorqw.gif"/></div></figure><p id="d332" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">就是这样！现在，您已经掌握了Swift并发性的基础知识！</p><h1 id="07ff" class="mu mv it bd mw mx my mz na nb nc nd ne ki nf kj ng kl nh km ni ko nj kp nk nl bi translated">摘要</h1><p id="051f" class="pw-post-body-paragraph li lj it lk b ll nm kd ln lo nn kg lq lr no lt lu lv np lx ly lz nq mb mc md im bi translated">在这篇文章中，我们了解到:</p><ul class=""><li id="c520" class="mg mh it lk b ll lm lo lp lr mi lv mj lz mk md ml mm mn mo bi translated">什么是并发</li><li id="51e1" class="mg mh it lk b ll mp lo mq lr mr lv ms lz mt md ml mm mn mo bi translated">什么是进程和线程</li><li id="24e4" class="mg mh it lk b ll mp lo mq lr mr lv ms lz mt md ml mm mn mo bi translated">如何在Swift中执行异步任务</li><li id="3f16" class="mg mh it lk b ll mp lo mq lr mr lv ms lz mt md ml mm mn mo bi translated">如何将同步代码转换成Swift异步代码</li><li id="3742" class="mg mh it lk b ll mp lo mq lr mr lv ms lz mt md ml mm mn mo bi translated">如何使用Swift并发并行执行任务</li></ul><h1 id="d97e" class="mu mv it bd mw mx my mz na nb nc nd ne ki nf kj ng kl nh km ni ko nj kp nk nl bi translated">最后的想法</h1><p id="c10c" class="pw-post-body-paragraph li lj it lk b ll nm kd ln lo nn kg lq lr no lt lu lv np lx ly lz nq mb mc md im bi translated">你可以在下面的Github repo中找到这篇文章的源代码:</p><div class="ow ox gp gr oy oz"><a href="https://github.com/anuragajwani/swift-concurrency-salad-maker" rel="noopener  ugc nofollow" target="_blank"><div class="pa ab fo"><div class="pb ab pc cl cj pd"><h2 class="bd jd gy z fp pe fr fs pf fu fw jc bi translated">GitHub-anuragajwani/Swift-Concurrency-salad-maker:Swift博客文章中的并发性介绍</h2><div class="pg l"><h3 class="bd b gy z fp pe fr fs pf fu fw dk translated">此时您不能执行该操作。您已使用另一个标签页或窗口登录。您已在另一个选项卡中注销，或者…</h3></div><div class="ph l"><p class="bd b dl z fp pe fr fs pf fu fw dk translated">github.com</p></div></div><div class="pi l"><div class="pj l pk pl pm pi pn lb oz"/></div></div></a></div><p id="266f" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">Swift的async和await简化了异步代码的读写。</p><p id="4962" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">我还没有介绍过<a class="ae lh" href="https://docs.swift.org/swift-book/LanguageGuide/Concurrency.html" rel="noopener ugc nofollow" target="_blank"> Swift concurrency </a>相对于生成并发代码的其他解决方案的优势(<a class="ae lh" href="https://anuragajwani.medium.com/introduction-to-concurrency-in-ios-using-grand-central-dispatch-gcd-8280b57a91ec" rel="noopener">大中央调度</a>和<a class="ae lh" href="https://anuragajwani.medium.com/introduction-to-operation-and-operationqueues-in-ios-and-swift-3c32525c7c1e" rel="noopener">操作和操作队列</a>)。这超出了本文的范围。然而，我将在以后的文章中介绍解决方案之间的差异。</p><p id="0ce5" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">这篇文章只打算介绍并发性的基础知识。并发是一个非常复杂的话题。以后我会继续就这个话题发帖。敬请关注更多内容。</p><pre class="ks kt ku kv gt og oh oi oj aw ok bi"><span id="3755" class="nv mv it oh b gy ol om l on oo"><strong class="oh jd">Want to Connect With the Author?</strong></span><span id="9f42" class="nv mv it oh b gy ot om l on oo">Connect with me on <a class="ae lh" href="https://twitter.com/anuragajwani?source=post_page---------------------------" rel="noopener ugc nofollow" target="_blank">Twitter</a></span></pre></div></div>    
</body>
</html>