<html>
<head>
<title>Should We Really Hate Singletons?</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">我们真的应该讨厌单身族吗？</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/should-we-really-hate-singletons-c75d1fe07111?source=collection_archive---------6-----------------------#2020-06-14">https://betterprogramming.pub/should-we-really-hate-singletons-c75d1fe07111?source=collection_archive---------6-----------------------#2020-06-14</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="a880" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">单身者受到很多讨厌，但这是合理的吗？</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/f7e5f530a98c7c57a2433671364bc108.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*dqA1vsqwBIZB5CGy"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">斯科特·韦伯在<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</p></figure><p id="4f76" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">大约四年来，我一直是一名iOS开发人员。任何有类似经历的人可能一生中至少和单身人士一起工作过一次。当然，我们也听说过关于辛格尔顿的诅咒。对设计模式有一种广泛的憎恨。</p><p id="eb6b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">但是，我们仍然多次看到它们的用法，甚至在iOS核心库中，如<code class="fe lv lw lx ly b">UserDefaults</code>、<code class="fe lv lw lx ly b">NotificationCentre</code>等。</p></div><div class="ab cl lz ma hx mb" role="separator"><span class="mc bw bk md me mf"/><span class="mc bw bk md me mf"/><span class="mc bw bk md me"/></div><div class="im in io ip iq"><h1 id="f081" class="mg mh it bd mi mj mk ml mm mn mo mp mq jz mr ka ms kc mt kd mu kf mv kg mw mx bi translated">那么我们为什么要使用它呢？</h1><ul class=""><li id="543b" class="my mz it lb b lc na lf nb li nc lm nd lq ne lu nf ng nh ni bi translated">共享资源:我们希望一个单独的对象来控制一些东西</li><li id="79e5" class="my mz it lb b lc nj lf nk li nl lm nm lq nn lu nf ng nh ni bi translated">容易访问:你只需要类名和共享对象，瞧，你有你的实例。另外，它是封装的(pssst …不再有自由飞行的全局实例)。</li></ul></div><div class="ab cl lz ma hx mb" role="separator"><span class="mc bw bk md me mf"/><span class="mc bw bk md me mf"/><span class="mc bw bk md me"/></div><div class="im in io ip iq"><h1 id="14ec" class="mg mh it bd mi mj mk ml mm mn mo mp mq jz mr ka ms kc mt kd mu kf mv kg mw mx bi translated">有利有弊</h1><p id="d292" class="pw-post-body-paragraph kz la it lb b lc na ju le lf nb jx lh li no lk ll lm np lo lp lq nq ls lt lu im bi translated">可能有很多原因，但是憎恨单例的根本原因是<em class="nr">他们使代码紧密耦合，所以我不能对我的类进行单元测试，等等等等。</em></p><p id="7731" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">那么，如果我们可以让它们松散耦合，并实际测试它们，会怎么样呢？</p><p id="7a3b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">好吧，让我给你讲一个我做的例子。它被称为<code class="fe lv lw lx ly b">WidgetPersistanceManager</code>。</p><h2 id="08a4" class="ns mh it bd mi nt nu dn mm nv nw dp mq li nx ny ms lm nz oa mu lq ob oc mw od bi translated"><strong class="ak">用例</strong></h2><p id="188c" class="pw-post-body-paragraph kz la it lb b lc na ju le lf nb jx lh li no lk ll lm np lo lp lq nq ls lt lu im bi translated">通常，我们会展示一些onboarding小部件来介绍一些特性。也许在其他屏幕上显示要使用的特性时会再次需要这些小部件。</p><p id="5f90" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在你想知道小部件是可以显示的，还是交互的？我需要解散吗？所以我需要一些类来维护这些。此外，我希望该实例在我需要时随时可用。所以是的，我们这里需要一个独生子。</p><h2 id="f99f" class="ns mh it bd mi nt nu dn mm nv nw dp mq li nx ny ms lm nz oa mu lq ob oc mw od bi translated">表演开始了</h2><ol class=""><li id="7aea" class="my mz it lb b lc na lf nb li nc lm nd lq ne lu oe ng nh ni bi translated">抽象:我们的主要目标是可测试性。于是抽象的游戏开始了。句号。(附:前方协议。)首先，我需要一个小部件，它在这里:</li></ol><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi of"><img src="../Images/02186a7f03db97d3d79f34402f0a1c4a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*opxZBKWG1S2CxZZbofi71A.png"/></div></div></figure><p id="6ee4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">一个widget包含一个<code class="fe lv lw lx ly b">rawValue</code>(可以帮助识别我的widget的唯一ID)、一个<code class="fe lv lw lx ly b">maxValue</code>(用于存储这个widget可以显示的次数)、一个<code class="fe lv lw lx ly b">persistentEntity</code>(用于维护显示和交互次数)。和一些方法，这些方法将具有小部件显示和交互的逻辑。</p><p id="2509" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">下面是<code class="fe lv lw lx ly b">PersistentEntity</code>:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi og"><img src="../Images/f7283e85c17551c14d93920d8a073490.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*RO6fD-9EPYKgtNiCH1eKpA.png"/></div></div></figure><p id="0a9a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">2.<strong class="lb iu">让我们介绍一下我们的持久性管理器:</strong></p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi oh"><img src="../Images/88b8f4702773695051fe9d47ffaee2fc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*KeBmaCvMsh9K4Qbb5ULQyw.png"/></div></div></figure><p id="941c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">持久性管理器应该有一些基本要求:</p><ul class=""><li id="8cce" class="my mz it lb b lc ld lf lg li oi lm oj lq ok lu nf ng nh ni bi translated">添加小部件的一些方法</li><li id="cab4" class="my mz it lb b lc nj lf nk li nl lm nm lq nn lu nf ng nh ni bi translated">移除小部件的一些方法</li><li id="796f" class="my mz it lb b lc nj lf nk li nl lm nm lq nn lu nf ng nh ni bi translated">一个知道小部件是否可以显示的函数</li><li id="701d" class="my mz it lb b lc nj lf nk li nl lm nm lq nn lu nf ng nh ni bi translated">当窗口小部件被交互时做某事的功能</li><li id="4082" class="my mz it lb b lc nj lf nk li nl lm nm lq nn lu nf ng nh ni bi translated">知道小部件是否被交互的方法</li></ul><p id="f9a3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">3.<strong class="lb iu">具体化</strong>:我们来看看以上抽象的一些具体实现。</p><p id="3190" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe lv lw lx ly b"><strong class="lb iu">WidgetPersistenceManager</strong></code>:一个<code class="fe lv lw lx ly b">WidgetPersistenceManageable</code>的具体化，带有添加、删除和显示小部件的方法。</p><p id="42a6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu">注意:</strong>功能之间没有逻辑耦合。这些函数简单地调用与各个小部件相关联的逻辑，这对于每个小部件都是可配置的。因此，没有紧密耦合。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ol om l"/></div></figure><p id="f8c1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在我的例子中，我需要使用一个动画的人字形来指向一个特性。所以我把这个小工具命名为<code class="fe lv lw lx ly b">Chevron</code> <em class="nr">。</em></p><p id="8533" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">注意，这里的逻辑封装在函数中。这就是我们想要的。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ol om l"/></div></figure><p id="4cb4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu">注意:</strong>还有一些辅助函数，像上面用的<code class="fe lv lw lx ly b">dataFor(key: String)</code>、<code class="fe lv lw lx ly b">saveData(widget: Widget, key: String)</code>。这些来自于<code class="fe lv lw lx ly b">PersistentEntity</code>的扩展(创建<code class="fe lv lw lx ly b">PersistentEntity</code>对象的全部要点)。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi on"><img src="../Images/51cd6a7b06709c733a0ff44fcc7e4bcc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*EGDJC1B1MhIxkYgthc7JmA.png"/></div></div></figure><p id="bee5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">4.<strong class="lb iu">用法</strong>:</p><p id="e297" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">所以我们创建了一些类。现在是表演的时间了。</p><p id="a238" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们创建一个演示者，并将<code class="fe lv lw lx ly b">WidgetPersistenceManageable</code> <em class="nr"> </em>作为我们的依赖项。这种依赖性是由某个构建器用共享实例初始化它来实现的。</p><p id="153c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">注意依赖项的类型是<code class="fe lv lw lx ly b">WidgetPersistenceManageable</code>(一个协议)。因此，我们可以在单元测试时注入一个模拟管理器，而演示者将采用类型<code class="fe lv lw lx ly b">Widget</code>(另一个协议)，这样我们就可以在测试时提供一个模拟小部件。耶。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ol om l"/></div></figure></div><div class="ab cl lz ma hx mb" role="separator"><span class="mc bw bk md me mf"/><span class="mc bw bk md me mf"/><span class="mc bw bk md me"/></div><div class="im in io ip iq"><h1 id="2093" class="mg mh it bd mi mj mk ml mm mn mo mp mq jz mr ka ms kc mt kd mu kf mv kg mw mx bi translated">结论</h1><p id="29f9" class="pw-post-body-paragraph kz la it lb b lc na ju le lf nb jx lh li no lk ll lm np lo lp lq nq ls lt lu im bi translated">所以到这里，我们已经到了文章的结尾。我们看到了如何使用抽象和依赖注入<em class="nr"> </em>让我们的单例单元可测试。尽管我还没有为上述内容创建任何测试用例，但我保证我会写另一篇文章来展示<code class="fe lv lw lx ly b">WidgetPeristenceManager</code>的测试部分(很快会发布链接)。</p><p id="a49b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果你想看代码，这里有回购协议的<a class="ae ky" href="https://github.com/akhilesh-gandotra/WidgetPersistanceManager" rel="noopener ugc nofollow" target="_blank">链接。</a></p><p id="90ee" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">最后，我只想说，单件属于设计模式的一个家族。它们被放在那里是有目的的。除了我们给他们的所有仇恨，他们仍然有他们的优势。我认为与其憎恨，我们应该驱使自己减少他们的缺点，然后我们可以从他们身上得到最多。</p><p id="fcca" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">感谢阅读！</p></div></div>    
</body>
</html>