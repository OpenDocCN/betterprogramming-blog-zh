<html>
<head>
<title>Understanding the Use of Interface and Abstract Classes</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">理解接口和抽象类的使用</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/understanding-use-of-interface-and-abstract-class-9a82f5f15837?source=collection_archive---------3-----------------------#2017-11-26">https://betterprogramming.pub/understanding-use-of-interface-and-abstract-class-9a82f5f15837?source=collection_archive---------3-----------------------#2017-11-26</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="0448" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">何时以及如何实现抽象和接口</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/1cdb85e4a18230fe3928aac7ef2614af.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*g7LoOyPcMg9TmjRQRmgR0A.jpeg"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">照片由<a class="ae ky" href="https://unsplash.com/@melindagimpel?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">梅林达·金佩尔</a>在<a class="ae ky" href="https://unsplash.com/search/photos/newspaper-calculator?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</p></figure></div><div class="ab cl kz la hx lb" role="separator"><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le"/></div><div class="im in io ip iq"><h1 id="e1b0" class="lg lh it bd li lj lk ll lm ln lo lp lq jz lr ka ls kc lt kd lu kf lv kg lw lx bi translated"><strong class="ak">接口类</strong></h1><p id="895d" class="pw-post-body-paragraph ly lz it ma b mb mc ju md me mf jx mg mh mi mj mk ml mm mn mo mp mq mr ms mt im bi translated">我们知道接口是由关键字<code class="fe mu mv mw mx b">interface</code>定义的，所有的方法都是抽象的。接口中声明的所有方法都必须是公共的；这就是接口的本质。</p><p id="6d57" class="pw-post-body-paragraph ly lz it ma b mb my ju md me mz jx mg mh na mj mk ml nb mn mo mp nc mr ms mt im bi translated">这里有一个例子:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nd ne l"/></div></figure><p id="c2fe" class="pw-post-body-paragraph ly lz it ma b mb my ju md me mz jx mg mh na mj mk ml nb mn mo mp nc mr ms mt im bi translated">在接口中，没有定义方法体，只有名称和参数。如果我们不使用接口，会遇到什么问题？为什么要用<code class="fe mu mv mw mx b">interface</code>？</p><p id="aa0b" class="pw-post-body-paragraph ly lz it ma b mb my ju md me mz jx mg mh na mj mk ml nb mn mo mp nc mr ms mt im bi translated">你会在这篇文章中找到这些问题的答案。请参见下面的代码:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nd ne l"/></div></figure><p id="82d3" class="pw-post-body-paragraph ly lz it ma b mb my ju md me mz jx mg mh na mj mk ml nb mn mo mp nc mr ms mt im bi translated">在上面的例子中，我没有使用<code class="fe mu mv mw mx b">interface</code>。我使用<code class="fe mu mv mw mx b">LogToFile</code>类写入日志。</p><p id="f003" class="pw-post-body-paragraph ly lz it ma b mb my ju md me mz jx mg mh na mj mk ml nb mn mo mp nc mr ms mt im bi translated">但是，如果我想用<code class="fe mu mv mw mx b">LogToDatabase</code>写一个日志，我必须在上面代码的第23行修改硬编码的类引用。</p><p id="f7fc" class="pw-post-body-paragraph ly lz it ma b mb my ju md me mz jx mg mh na mj mk ml nb mn mo mp nc mr ms mt im bi translated">那行代码是:</p><pre class="kj kk kl km gt nf mx ng nh aw ni bi"><span id="b669" class="nj lh it mx b gy nk nl l nm nn">public function __construct(LogToFile $logger)</span></pre><p id="ec7a" class="pw-post-body-paragraph ly lz it ma b mb my ju md me mz jx mg mh na mj mk ml nb mn mo mp nc mr ms mt im bi translated">该代码将是:</p><pre class="kj kk kl km gt nf mx ng nh aw ni bi"><span id="07f0" class="nj lh it mx b gy nk nl l nm nn">public function __construct(LogToDatabase $logger)</span></pre><p id="7dc4" class="pw-post-body-paragraph ly lz it ma b mb my ju md me mz jx mg mh na mj mk ml nb mn mo mp nc mr ms mt im bi translated">在一个大型项目中，如果我有多个类，并且我需要更改它们，我必须手动更改所有的类。</p><p id="3b87" class="pw-post-body-paragraph ly lz it ma b mb my ju md me mz jx mg mh na mj mk ml nb mn mo mp nc mr ms mt im bi translated">但是，如果我们使用一个接口，这个问题就解决了；我们将不需要手动更改代码。</p><p id="370e" class="pw-post-body-paragraph ly lz it ma b mb my ju md me mz jx mg mh na mj mk ml nb mn mo mp nc mr ms mt im bi translated">现在，看下面的代码，试着理解如果我使用<code class="fe mu mv mw mx b">interface</code>会发生什么:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nd ne l"/></div></figure><p id="63e0" class="pw-post-body-paragraph ly lz it ma b mb my ju md me mz jx mg mh na mj mk ml nb mn mo mp nc mr ms mt im bi translated">现在，如果我从<code class="fe mu mv mw mx b">LogToDatabase</code>更改为<code class="fe mu mv mw mx b">LogToFile</code>，我不必手动更改构造函数方法。在构造函数方法中，我注入了一个<code class="fe mu mv mw mx b">interface</code>；不是任意类。</p><p id="9464" class="pw-post-body-paragraph ly lz it ma b mb my ju md me mz jx mg mh na mj mk ml nb mn mo mp nc mr ms mt im bi translated">如果您有多个类，并且从一个类交换到另一个类，您将获得相同的结果，而不会改变任何类引用。</p><p id="57fb" class="pw-post-body-paragraph ly lz it ma b mb my ju md me mz jx mg mh na mj mk ml nb mn mo mp nc mr ms mt im bi translated">在上面的例子中，我用<code class="fe mu mv mw mx b">LogToDatabase</code>写日志，现在我想用<code class="fe mu mv mw mx b">LogToFile</code>写日志。</p><p id="07c0" class="pw-post-body-paragraph ly lz it ma b mb my ju md me mz jx mg mh na mj mk ml nb mn mo mp nc mr ms mt im bi translated">我可以这样称呼它:</p><pre class="kj kk kl km gt nf mx ng nh aw ni bi"><span id="a6bf" class="nj lh it mx b gy nk nl l nm nn">$controller = new UsersController(new LogToFile);<br/>$controller-&gt;show();</span></pre><p id="9224" class="pw-post-body-paragraph ly lz it ma b mb my ju md me mz jx mg mh na mj mk ml nb mn mo mp nc mr ms mt im bi translated">我不用改变其他类就能得到结果，因为<code class="fe mu mv mw mx b">interface</code>处理了这个交换问题。</p></div><div class="ab cl kz la hx lb" role="separator"><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le"/></div><div class="im in io ip iq"><h1 id="e224" class="lg lh it bd li lj lk ll lm ln lo lp lq jz lr ka ls kc lt kd lu kf lv kg lw lx bi translated"><strong class="ak">抽象类</strong></h1><p id="d058" class="pw-post-body-paragraph ly lz it ma b mb mc ju md me mf jx mg mh mi mj mk ml mm mn mo mp mq mr ms mt im bi translated">抽象类是只由程序员部分实现的类。它可能包含至少一个<code class="fe mu mv mw mx b">abstract</code>方法，这是一个没有任何实际代码的方法——只有名称和参数，并且被标记为“抽象”。</p><p id="744c" class="pw-post-body-paragraph ly lz it ma b mb my ju md me mz jx mg mh na mj mk ml nb mn mo mp nc mr ms mt im bi translated">抽象方法只是一个函数定义，用来告诉程序员该方法必须在子类中实现。</p><p id="c9d2" class="pw-post-body-paragraph ly lz it ma b mb my ju md me mz jx mg mh na mj mk ml nb mn mo mp nc mr ms mt im bi translated">这里有一个例子:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nd ne l"/></div></figure><p id="6d72" class="pw-post-body-paragraph ly lz it ma b mb my ju md me mz jx mg mh na mj mk ml nb mn mo mp nc mr ms mt im bi translated">现在，问题是:“我们如何知道一个方法将被需要，并且它必须被实现？”我将在这里尝试解释这一点。</p><p id="7ca5" class="pw-post-body-paragraph ly lz it ma b mb my ju md me mz jx mg mh na mj mk ml nb mn mo mp nc mr ms mt im bi translated">请看<code class="fe mu mv mw mx b">Tea</code>课:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nd ne l"/></div></figure><p id="578f" class="pw-post-body-paragraph ly lz it ma b mb my ju md me mz jx mg mh na mj mk ml nb mn mo mp nc mr ms mt im bi translated">现在，我们来看看<code class="fe mu mv mw mx b">Coffee</code>类。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nd ne l"/></div></figure><p id="5702" class="pw-post-body-paragraph ly lz it ma b mb my ju md me mz jx mg mh na mj mk ml nb mn mo mp nc mr ms mt im bi translated">在上面的两个类中，三个方法<code class="fe mu mv mw mx b">addHotWater()</code>、<code class="fe mu mv mw mx b">addSugar()</code>和<code class="fe mu mv mw mx b">addMilk()</code>是相同的。</p><p id="5d69" class="pw-post-body-paragraph ly lz it ma b mb my ju md me mz jx mg mh na mj mk ml nb mn mo mp nc mr ms mt im bi translated">所以，我们应该删除重复的代码。我们可以这样做:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nd ne l"/></div></figure><p id="655d" class="pw-post-body-paragraph ly lz it ma b mb my ju md me mz jx mg mh na mj mk ml nb mn mo mp nc mr ms mt im bi translated">我创建了一个<code class="fe mu mv mw mx b">abstract</code>类，并将其命名为<code class="fe mu mv mw mx b">Template</code>。</p><p id="0656" class="pw-post-body-paragraph ly lz it ma b mb my ju md me mz jx mg mh na mj mk ml nb mn mo mp nc mr ms mt im bi translated">这里我定义了<code class="fe mu mv mw mx b">addHotWater()</code>、<code class="fe mu mv mw mx b">addSugar()</code>、<code class="fe mu mv mw mx b">addMilk()</code>，做了一个抽象方法命名为<code class="fe mu mv mw mx b">addPrimaryToppings</code>。</p><p id="c692" class="pw-post-body-paragraph ly lz it ma b mb my ju md me mz jx mg mh na mj mk ml nb mn mo mp nc mr ms mt im bi translated">现在，如果我让<code class="fe mu mv mw mx b">Tea</code>类扩展<code class="fe mu mv mw mx b">Template</code>类，我将得到三个已定义的方法，并且我必须定义<code class="fe mu mv mw mx b">addPrimaryToppings()</code>方法。以类似的方式，<code class="fe mu mv mw mx b">Coffee</code>类也是如此。</p><p id="5243" class="pw-post-body-paragraph ly lz it ma b mb my ju md me mz jx mg mh na mj mk ml nb mn mo mp nc mr ms mt im bi translated"><em class="no">如果你想练习并获得关于</em> <code class="fe mu mv mw mx b">interface</code>和<code class="fe mu mv mw mx b">abstract</code>职业<em class="no">的代码，请查看我的</em><a class="ae ky" href="https://github.com/nahidulhasan/oop" rel="noopener ugc nofollow" target="_blank"><em class="no">GitHub</em></a><em class="no">(星星总赞赏)资源库。</em></p><p id="127b" class="pw-post-body-paragraph ly lz it ma b mb my ju md me mz jx mg mh na mj mk ml nb mn mo mp nc mr ms mt im bi translated">感谢阅读。</p></div></div>    
</body>
</html>