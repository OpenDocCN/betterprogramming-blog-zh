<html>
<head>
<title>Practical Guide to Regex API in JavaScript</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">JavaScript中的Regex API实用指南</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/mastering-regex-tooling-in-javascript-c3fbbb19fd32?source=collection_archive---------12-----------------------#2021-08-30">https://betterprogramming.pub/mastering-regex-tooling-in-javascript-c3fbbb19fd32?source=collection_archive---------12-----------------------#2021-08-30</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="13e5" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">RegExp、replaceAll、replace、exec、search、test等等</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/7f83e67322da0d6cb65072dbc3fd5b41.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ioq05KvswTBJiudWcQ3UfA.png"/></div></div></figure><p id="5829" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">正则表达式是包含帮助您匹配、定位和管理文本的模式的文本字符串。非常有用，几乎每种语言都有某种正则表达式支持。</p><p id="0b1e" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">虽然Perl和Python是regex的全功能语言，但是JavaScript有很多工具。</p><p id="64e1" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">您了解JavaScript的全部功能吗？您想知道每种工具之间的区别吗？</p><p id="429c" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">在本文中，我们不会深入探讨正则表达式的语法，而是探讨可以在JavaScript中使用哪些工具来充分利用它们。正则表达式一开始可能有点让人不知所措。我们将看到如何有效地创建和使用它们。</p><h1 id="7cec" class="lq lr it bd ls lt lu lv lw lx ly lz ma jz mb ka mc kc md kd me kf mf kg mg mh bi translated">创建正则表达式</h1><p id="c0c8" class="pw-post-body-paragraph ku kv it kw b kx mi ju kz la mj jx lc ld mk lf lg lh ml lj lk ll mm ln lo lp im bi translated">掌握正则表达式的第一步是能够创建这些正则表达式。在创建regex express时，您有两种选择:</p><h2 id="1f91" class="mn lr it bd ls mo mp dn lw mq mr dp ma ld ms mt mc lh mu mv me ll mw mx mg my bi translated">1.使用正则表达式文字</h2><p id="eafa" class="pw-post-body-paragraph ku kv it kw b kx mi ju kz la mj jx lc ld mk lf lg lh ml lj lk ll mm ln lo lp im bi translated">当我们知道我们的表达式不会在运行时运行时，我们可以使用<code class="fe mz na nb nc b">regular expression literals</code>来创建它们。语法很简单；正则表达式用斜线括起来。标志(如果有)被附加在末尾。</p><pre class="kj kk kl km gt nd nc ne nf aw ng bi"><span id="158e" class="mn lr it nc b gy nh ni l nj nk"><strong class="nc iu">/<em class="nl">pattern</em>/<em class="nl">flags</em></strong></span></pre><p id="d5ca" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">让我们看一个例子:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nm nn l"/></div></figure><p id="b521" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">这就是所谓的文字符号。正则表达式将在编译时进行解析和计算。这意味着这将是一个非常高效的解决方案。</p><h2 id="0759" class="mn lr it bd ls mo mp dn lw mq mr dp ma ld ms mt mc lh mu mv me ll mw mx mg my bi translated">2.使用常规构造函数</h2><p id="5d86" class="pw-post-body-paragraph ku kv it kw b kx mi ju kz la mj jx lc ld mk lf lg lh ml lj lk ll mm ln lo lp im bi translated">当你的正则表达式被设置为在运行时改变或者依赖于一个运行时变量时，我们可以使用<code class="fe mz na nb nc b">RegExp</code> API。第一个参数是表达式。有一个可选的第二个参数来设置标志。</p><pre class="kj kk kl km gt nd nc ne nf aw ng bi"><span id="9862" class="mn lr it nc b gy nh ni l nj nk"><strong class="nc iu">new RegExp(<em class="nl">pattern </em>[, flags]<em class="nl">)</em></strong></span><span id="5f06" class="mn lr it nc b gy no ni l nj nk">// factory notation without the new keywod is possible<br/><strong class="nc iu">RegExp(<em class="nl">pattern </em>[, flags]<em class="nl">)</em></strong></span></pre><p id="a53a" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">让我们看一个例子:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nm nn l"/></div></figure><p id="e038" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">表达式的编译将在运行时进行；执行时会比较慢。</p><p id="07a2" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">使用<code class="fe mz na nb nc b">RegExp</code>构造函数的另一个缺点是需要对特殊字符进行转义。例如，我们将需要<code class="fe mz na nb nc b">\\s</code>而不是<code class="fe mz na nb nc b">\s</code>。请检查<a class="ae np" href="https://riptutorial.com/regex/example/15848/what-characters-need-to-be-escaped-" rel="noopener ugc nofollow" target="_blank">这里</a>参考需要转义的内容。</p><p id="10e5" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">使用两种风格声明相同正则表达式的示例:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nm nn l"/></div></figure><p id="4732" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">创建正则表达式的方法对其功能或用法没有任何影响。任何正则表达式最终都会有相同的原型:<code class="fe mz na nb nc b">RegExp.prototype</code>。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nm nn l"/></div></figure><h2 id="2801" class="mn lr it bd ls mo mp dn lw mq mr dp ma ld ms mt mc lh mu mv me ll mw mx mg my bi translated"><strong class="ak">JavaScript中支持的标志</strong></h2><p id="805d" class="pw-post-body-paragraph ku kv it kw b kx mi ju kz la mj jx lc ld mk lf lg lh ml lj lk ll mm ln lo lp im bi translated">我们之前讨论过正则表达式和标志。标志是可选的，必须用小写字母书写；否则，它们将无效。</p><p id="3b81" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">让我们检查JavaScript引擎接受的不同标志:</p><ul class=""><li id="918f" class="nq nr it kw b kx ky la lb ld ns lh nt ll nu lp nv nw nx ny bi translated"><code class="fe mz na nb nc b">i</code>:使搜索不区分大小写</li><li id="ad5d" class="nq nr it kw b kx nz la oa ld ob lh oc ll od lp nv nw nx ny bi translated"><code class="fe mz na nb nc b">g</code>:查找所有匹配，而不是返回第一个。</li><li id="8b04" class="nq nr it kw b kx nz la oa ld ob lh oc ll od lp nv nw nx ny bi translated"><code class="fe mz na nb nc b">m</code>:多线模式。</li><li id="cd19" class="nq nr it kw b kx nz la oa ld ob lh oc ll od lp nv nw nx ny bi translated"><code class="fe mz na nb nc b">s</code>:启用“dotall”模式。它允许<code class="fe mz na nb nc b">.</code>匹配换行符<code class="fe mz na nb nc b">\n</code></li><li id="3d74" class="nq nr it kw b kx nz la oa ld ob lh oc ll od lp nv nw nx ny bi translated"><code class="fe mz na nb nc b">u</code>:启用完全Unicode支持。</li><li id="2c2e" class="nq nr it kw b kx nz la oa ld ob lh oc ll od lp nv nw nx ny bi translated"><code class="fe mz na nb nc b">y</code>:启用粘滞模式:表达式将从其指示的<code class="fe mz na nb nc b">lastIndex</code>属性开始搜索。</li></ul><h1 id="f03a" class="lq lr it bd ls lt lu lv lw lx ly lz ma jz mb ka mc kc md kd me kf mf kg mg mh bi translated">JavaScript方法</h1><p id="a2d2" class="pw-post-body-paragraph ku kv it kw b kx mi ju kz la mj jx lc ld mk lf lg lh ml lj lk ll mm ln lo lp im bi translated">现在我们知道了如何创建正则表达式，让我们看看可以用它们做些什么。有八种方法接受正则表达式:</p><ul class=""><li id="9803" class="nq nr it kw b kx ky la lb ld ns lh nt ll nu lp nv nw nx ny bi translated">两个来自<code class="fe mz na nb nc b">RegexExp.prototype</code>。</li><li id="66b7" class="nq nr it kw b kx nz la oa ld ob lh oc ll od lp nv nw nx ny bi translated">六个来自<code class="fe mz na nb nc b">String.prototype</code>。</li></ul><p id="7206" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">让我们来详细看看它们:</p><h2 id="ea52" class="mn lr it bd ls mo mp dn lw mq mr dp ma ld ms mt mc lh mu mv me ll mw mx mg my bi translated">1.测试()</h2><ul class=""><li id="afd6" class="nq nr it kw b kx mi la mj ld oe lh of ll og lp nv nw nx ny bi translated">仅与正则表达式一起使用</li></ul><p id="8717" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">这个方法很有用，因为我们只关心一个给定的目标是否符合我们的标准。它将返回真或假。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nm nn l"/></div></figure><p id="bf6b" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">如前所述，上述代码与执行以下操作相同:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nm nn l"/></div></figure><h2 id="a9b8" class="mn lr it bd ls mo mp dn lw mq mr dp ma ld ms mt mc lh mu mv me ll mw mx mg my bi translated">2.执行()</h2><ul class=""><li id="865f" class="nq nr it kw b kx mi la mj ld oe lh of ll og lp nv nw nx ny bi translated">仅与正则表达式一起使用</li></ul><p id="59a1" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated"><code class="fe mz na nb nc b">exec()</code>方法用于通过多次调用来迭代搜索结果。如果返回是<code class="fe mz na nb nc b">null</code>则意味着你到达了终点。如果不是<code class="fe mz na nb nc b">null</code>，您将获得<code class="fe mz na nb nc b">latIndex</code>位置和匹配的结果。它支持分组。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nm nn l"/></div></figure><h2 id="6000" class="mn lr it bd ls mo mp dn lw mq mr dp ma ld ms mt mc lh mu mv me ll mw mx mg my bi translated">3.匹配()</h2><ul class=""><li id="5131" class="nq nr it kw b kx mi la mj ld oe lh of ll og lp nv nw nx ny bi translated">仅与正则表达式一起使用</li></ul><p id="3ffb" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated"><code class="fe mz na nb nc b">match()</code>方法返回一个包含所有匹配事件的数组，而不是像<code class="fe mz na nb nc b">exec</code>那样一次一个。将不会返回关于该匹配的任何附加信息。如果不与<code class="fe mz na nb nc b">g</code>标志一起使用，它会返回捕获组。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nm nn l"/></div></figure><h2 id="a210" class="mn lr it bd ls mo mp dn lw mq mr dp ma ld ms mt mc lh mu mv me ll mw mx mg my bi translated">4.matchAll()</h2><ul class=""><li id="48a7" class="nq nr it kw b kx mi la mj ld oe lh of ll og lp nv nw nx ny bi translated">仅与正则表达式一起使用</li></ul><p id="f008" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated"><code class="fe mz na nb nc b">matchAll()</code>方法类似于<code class="fe mz na nb nc b">exec</code>，尽管它会给我们一个迭代器作为结果。然后我们可以使用<code class="fe mz na nb nc b">for</code>循环遍历所有结果。它确实返回捕获组。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nm nn l"/></div></figure><h2 id="b649" class="mn lr it bd ls mo mp dn lw mq mr dp ma ld ms mt mc lh mu mv me ll mw mx mg my bi translated">5.搜索()</h2><ul class=""><li id="9023" class="nq nr it kw b kx mi la mj ld oe lh of ll og lp nv nw nx ny bi translated">仅与正则表达式一起使用</li></ul><p id="0aa1" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">当你想在一个字符串中定位一个匹配的位置时,<code class="fe mz na nb nc b">search()</code>方法很有用。它类似于<code class="fe mz na nb nc b">indexOf</code>方法，但是使用正则表达式而不是普通字符串。如果找不到索引或匹配起始位置，将返回<code class="fe mz na nb nc b">-1</code>。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nm nn l"/></div></figure><h2 id="947f" class="mn lr it bd ls mo mp dn lw mq mr dp ma ld ms mt mc lh mu mv me ll mw mx mg my bi translated">6.替换()</h2><ul class=""><li id="218b" class="nq nr it kw b kx mi la mj ld oe lh of ll og lp nv nw nx ny bi translated">与正则表达式或字符串一起使用</li></ul><p id="6bb4" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated"><code class="fe mz na nb nc b">replace()</code>方法返回一个新的字符串，其中一些或所有匹配被定义的替换所替换。它适用于字符串或正则表达式文字。与前者一起使用时，只会替换第一个出现的内容。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nm nn l"/></div></figure><h2 id="6fd3" class="mn lr it bd ls mo mp dn lw mq mr dp ma ld ms mt mc lh mu mv me ll mw mx mg my bi translated">7.replaceAll()</h2><ul class=""><li id="e8a4" class="nq nr it kw b kx mi la mj ld oe lh of ll og lp nv nw nx ny bi translated">与正则表达式或字符串一起使用</li></ul><p id="19bf" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated"><code class="fe mz na nb nc b">replaceAll()</code>方法类似于<code class="fe mz na nb nc b">replace()</code>。有两个主要区别:</p><ul class=""><li id="31c5" class="nq nr it kw b kx ky la lb ld ns lh nt ll nu lp nv nw nx ny bi translated">当使用字符串时，它将替换所有出现的内容。</li><li id="60d0" class="nq nr it kw b kx nz la oa ld ob lh oc ll od lp nv nw nx ny bi translated">它将要求正则表达式具有<code class="fe mz na nb nc b">g</code>参数，否则将失败。</li></ul><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nm nn l"/></div></figure><p id="1629" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">请注意，<code class="fe mz na nb nc b">replaceAll</code>方法刚刚被添加到最新的ES2021规格中。</p><h2 id="c4e6" class="mn lr it bd ls mo mp dn lw mq mr dp ma ld ms mt mc lh mu mv me ll mw mx mg my bi translated">8.拆分()</h2><ul class=""><li id="fe53" class="nq nr it kw b kx mi la mj ld oe lh of ll og lp nv nw nx ny bi translated">与正则表达式或字符串一起使用</li></ul><p id="85ad" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated"><code class="fe mz na nb nc b">split()</code>方法使用搜索模式分割字符串。它将返回子字符串的有序数组。可以使用字符串或正则表达式来完成除法。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nm nn l"/></div></figure><p id="dfe7" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">方法<code class="fe mz na nb nc b">match()</code>、<code class="fe mz na nb nc b">matchAll()</code>和<code class="fe mz na nb nc b">search()</code>接受正则表达式和字符串作为参数。然而，如果没有给定正则表达式，字符串将使用<code class="fe mz na nb nc b">new RegExp(argument)</code>转换为<code class="fe mz na nb nc b">RegExp</code>。</p><p id="0349" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">为了防止这种情况，如果可行的话，像<code class="fe mz na nb nc b">search()</code>一样，最好在使用字符串时将它们的字符串对应物实现。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nm nn l"/></div></figure><h1 id="ed61" class="lq lr it bd ls lt lu lv lw lx ly lz ma jz mb ka mc kc md kd me kf mf kg mg mh bi translated">ECMAScript功能</h1><h2 id="6489" class="mn lr it bd ls mo mp dn lw mq mr dp ma ld ms mt mc lh mu mv me ll mw mx mg my bi translated">命名捕获组</h2><p id="ebcf" class="pw-post-body-paragraph ku kv it kw b kx mi ju kz la mj jx lc ld mk lf lg lh ml lj lk ll mm ln lo lp im bi translated">捕获组是一个有用的正则表达式特性。在<code class="fe mz na nb nc b">ES2018</code>规范中，引入了捕获命名组特性。它允许组名有更一致的访问。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nm nn l"/></div></figure><h2 id="226c" class="mn lr it bd ls mo mp dn lw mq mr dp ma ld ms mt mc lh mu mv me ll mw mx mg my bi translated"><strong class="ak">正则表达式后视断言</strong></h2><p id="3460" class="pw-post-body-paragraph ku kv it kw b kx mi ju kz la mj jx lc ld mk lf lg lh ml lj lk ll mm ln lo lp im bi translated">所有主流浏览器都已经提供了前瞻功能。look back是作为<code class="fe mz na nb nc b">ES2018</code>规格的一部分发布的。它允许我们将正则表达式建立在匹配背后。它的工作方向与前瞻相反。它可以接受积极和消极的条件。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nm nn l"/></div></figure><h2 id="adca" class="mn lr it bd ls mo mp dn lw mq mr dp ma ld ms mt mc lh mu mv me ll mw mx mg my bi translated">RegExp unicode属性转义</h2><p id="d5d6" class="pw-post-body-paragraph ku kv it kw b kx mi ju kz la mj jx lc ld mk lf lg lh ml lj lk ll mm ln lo lp im bi translated">在此之前，目前无法使用本地JavaScript引擎访问regex的Unicode字符。它作为<code class="fe mz na nb nc b">ES2018</code>规范的一部分发布。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nm nn l"/></div></figure><h2 id="436a" class="mn lr it bd ls mo mp dn lw mq mr dp ma ld ms mt mc lh mu mv me ll mw mx mg my bi translated">正则表达式匹配索引</h2><p id="792e" class="pw-post-body-paragraph ku kv it kw b kx mi ju kz la mj jx lc ld mk lf lg lh ml lj lk ll mm ln lo lp im bi translated">这尚未发布，将与<code class="fe mz na nb nc b">ES2022</code>规格一起发货。通过使用新添加的标志<code class="fe mz na nb nc b">d</code>，我们可以访问比赛的<code class="fe mz na nb nc b">start</code>和<code class="fe mz na nb nc b">end</code>索引位置。</p><p id="754f" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">它甚至适用于捕获组和命名组。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nm nn l"/></div></figure></div><div class="ab cl oh oi hx oj" role="separator"><span class="ok bw bk ol om on"/><span class="ok bw bk ol om on"/><span class="ok bw bk ol om"/></div><div class="im in io ip iq"><h1 id="8a20" class="lq lr it bd ls lt oo lv lw lx op lz ma jz oq ka mc kc or kd me kf os kg mg mh bi translated">最后的想法</h1><p id="bf74" class="pw-post-body-paragraph ku kv it kw b kx mi ju kz la mj jx lc ld mk lf lg lh ml lj lk ll mm ln lo lp im bi translated">正则表达式是我们编程生活中不可或缺的工具。在这里，我们已经看到了JavaScript引擎中所有不同的选择。有了对其内部的清晰理解，我们现在能够为正确的工作选择正确的工具。</p><p id="b1a5" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">JavaScript中仍然有一些缺失的特性。然而，它很快覆盖地面。像<code class="fe mz na nb nc b">Match Indices</code>这样令人兴奋的事情即将发生。</p><p id="3e10" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">一些新功能的唯一警告是，它们对polyfill来说并不总是微不足道的。这就是一个人背后的样子。</p><p id="eb70" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">希望这篇文章能帮助你理解和阐明如何更好地使用正则表达式。</p><p id="6f76" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">感谢阅读。</p></div></div>    
</body>
</html>