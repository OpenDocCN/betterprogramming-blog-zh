<html>
<head>
<title>How to Use Skaffold With Docker and Kustomize to Build a Pipeline for Stateful Applications Running in Kubernetes</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何将Skaffold与Docker和Kustomize结合使用，为运行在Kubernetes中的有状态应用程序构建一个管道</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/how-to-use-skaffold-with-docker-and-kustomize-to-build-a-pipeline-for-stateful-applications-running-c74ca0e1c13a?source=collection_archive---------10-----------------------#2022-06-13">https://betterprogramming.pub/how-to-use-skaffold-with-docker-and-kustomize-to-build-a-pipeline-for-stateful-applications-running-c74ca0e1c13a?source=collection_archive---------10-----------------------#2022-06-13</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="b00c" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">第3部分:让我们添加数据！</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/d6302048c9c47ad76d324e746154be6a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*stZK2RyalrdfS_g3"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">照片由<a class="ae ky" href="https://unsplash.com/@xoforoct?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">EJ·斯特拉特</a>在<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>拍摄</p></figure><p id="d50d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这是“<a class="ae ky" rel="noopener ugc nofollow" target="_blank" href="/how-to-build-a-ci-cd-pipeline-for-kubernetes-stateful-applications-aef6c8c5edc2">如何为Kubernetes有状态应用</a>构建CI/CD管道”系列的最后一部分。到目前为止，我们已经部署和配置了:</p><ul class=""><li id="750d" class="lv lw it lb b lc ld lf lg li lx lm ly lq lz lu ma mb mc md bi translated">草泽</li><li id="c92d" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated">MongoDB社区运营商</li><li id="4f8d" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated">翁达特</li></ul><p id="cc7d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在本文中，我们将把应用程序和MongoDB数据库一起部署为Kubernetes <code class="fe mj mk ml mm b">StatefulSet</code>,使用Operator和Skaffold为我们的本地k3s集群创建一个持续开发管道。最后，我们将测试管道，并更新我们的真棒漫威应用程序！我们开始吧！</p><p id="18c1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><em class="mn">注意:</em>如果你想继续，你可以在Github上找到我们使用的资源:</p><ul class=""><li id="0f70" class="lv lw it lb b lc ld lf lg li lx lm ly lq lz lu ma mb mc md bi translated">MongoDB操作员清单:<a class="ae ky" href="https://github.com/vfiftyfive/mongodb-community-operator-manifests" rel="noopener ugc nofollow" target="_blank">https://github . com/vfiftyfive/MongoDB-community-operator-manifests</a></li><li id="4e33" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated">应用代码、管道和包装配置:<a class="ae ky" href="https://github.com/vfiftyfive/FlaskMarvelApp" rel="noopener ugc nofollow" target="_blank">https://github.com/vfiftyfive/FlaskMarvelApp</a></li><li id="9688" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated">申请清单:<a class="ae ky" href="https://github.com/vfiftyfive/CFD12-Demo-Manifests" rel="noopener ugc nofollow" target="_blank">https://github.com/vfiftyfive/CFD12-Demo-Manifests</a>。使用<code class="fe mj mk ml mm b">dev</code>分支。</li></ul><h1 id="b35a" class="mo mp it bd mq mr ms mt mu mv mw mx my jz mz ka na kc nb kd nc kf nd kg ne nf bi translated">创建MongoDB定制资源并定义数据服务需求</h1><p id="69f7" class="pw-post-body-paragraph kz la it lb b lc ng ju le lf nh jx lh li ni lk ll lm nj lo lp lq nk ls lt lu im bi translated">像往常一样，定制资源作为YAML文件传递给Kubernetes。MongoDB社区运营商repo在这里给出了几个例子<a class="ae ky" href="https://github.com/mongodb/mongodb-kubernetes-operator/tree/master/config/samples" rel="noopener ugc nofollow" target="_blank">。您需要根据您的用例调整特定的参数。</a></p><p id="681d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在您之前克隆的<strong class="lb iu"> </strong>应用程序清单repo的根目录下，您会发现我们使用的MongoDB定制资源。这是Kustomize在运行<code class="fe mj mk ml mm b">kustomize build overlay/dev</code>后计算的结果。文件名为<code class="fe mj mk ml mm b">mongodb-config.yaml</code>，具体如下:</p><pre class="kj kk kl km gt nl mm nm nn aw no bi"><span id="2852" class="np mp it mm b gy nq nr l ns nt">apiVersion: mongodbcommunity.mongodb.com/v1<br/>kind: MongoDBCommunity<br/>metadata:<br/>  name: mongodb<br/>spec:<br/>  <strong class="mm iu">members: 3<br/>  version: 5.0.5<br/>  </strong>security:<br/>    authentication:<br/>      modes:<br/>      - SCRAM<br/>  statefulSet:<br/>    spec:<br/>      selector: {}<br/>      serviceName: mongodb<br/>      volumeClaimTemplates:<br/>      - metadata:<br/>          name: data-volume<br/>        spec:<br/>          accessModes:<br/>          - ReadWriteOnce<br/>          resources:<br/>            requests:<br/>              storage: 1Gi<br/>          <strong class="mm iu">storageClassName: ondat-replicated</strong><br/>      - metadata:<br/>          name: logs-volume<br/>        spec:<br/>          accessModes:<br/>          - ReadWriteOnce<br/>          resources:<br/>            requests:<br/>              storage: 1Gi<br/>          <strong class="mm iu">storageClassName: ondat-replicated</strong><br/>  type: ReplicaSet<br/>  users:<br/>  - <strong class="mm iu">db: admin</strong><br/>    name: admin<br/>    <strong class="mm iu">passwordSecretRef:<br/>      name: admin-password-df8t2cdf9f</strong><br/>    <strong class="mm iu">roles:<br/>    - db: admin<br/>      name: clusterAdmin<br/>    - db: admin<br/>      name: userAdminAnyDatabase<br/>    - db: admin<br/>      name: dbAdminAnyDatabase<br/>    - db: admin<br/>      name: readWriteAnyDatabase</strong><br/>    <strong class="mm iu">scramCredentialsSecretName: admin</strong></span></pre><p id="24ef" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们已经用<strong class="lb iu">粗体</strong>突出了基本特性。定制资源定义集群中初始MongoDB节点的数量、MongoDB的版本、配置MongoDB副本集、Kubernetes <code class="fe mj mk ml mm b">StorageClass</code>，并指定数据库管理员用户名/密码和角色。它封装了创建数据库所需的信息，并在逻辑上表示了所需数据库配置的抽象。这些参数由Kustomize根据覆盖图中描述的目标环境动态计算。</p><p id="2385" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe mj mk ml mm b">StorageClass</code>决定MongoDB <code class="fe mj mk ml mm b">StatefulSet</code>使用哪个CSI来管理它的数据。从开发到生产，在应用程序生命周期的每一步选择合适的提供商是至关重要的。“左移”的前提已经在<a class="ae ky" href="https://medium.com/@nvermande/3-reasons-to-shift-left-your-data-with-kubernetes-and-ondat-52a753343d0b?sk=bb23b2c30052fc3d91dbd967460abecb" rel="noopener">之前的博客</a>中讨论过了，所以我就不深究了。这个想法是，从开发到生产，从他们的笔记本电脑到100节点的生产集群，开发人员需要一致的工具。他们应该能够在开发的每个阶段用相同的能力测试他们的代码。Ondat为Kubernetes持久卷和其他企业功能提供了这种一致性，这些功能在大规模生产中运行有状态工作负载时至关重要。它包括同步复制、性能优化、传输中和静态的强加密，以及管理这些功能的Kube-Native方法。</p><p id="222a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe mj mk ml mm b">ondat-replicated</code> StorageClass在Kustomize生成的清单中定义。Kubernetes API在Kustomize计算之后获取的<code class="fe mj mk ml mm b">StorageClass</code>配置如下:</p><pre class="kj kk kl km gt nl mm nm nn aw no bi"><span id="d8f2" class="np mp it mm b gy nq nr l ns nt">apiVersion: storage.k8s.io/v1<br/>kind: StorageClass<br/>metadata:<br/>  name: ondat-replicated<br/>parameters:<br/>  <strong class="mm iu">csi.storage.k8s.io/fstype: xfs</strong><br/>  csi.storage.k8s.io/secret-name: storageos-api<br/>  csi.storage.k8s.io/secret-namespace: storageos<br/>  <strong class="mm iu">storageos.com/encryption: "true"<br/>  storageos.com/replicas: "1"</strong><br/>provisioner: csi.storageos.com<br/>allowVolumeExpansion: true<br/>reclaimPolicy: Delete<br/>volumeBindingMode: Immediate</span></pre><p id="2f77" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">同样，我们在<strong class="lb iu">粗体</strong>中突出显示了基本特性。按照MongoDB的建议，我们将用于持久卷的默认文件系统更改为XFS，以获得更好的可伸缩性和性能。我们还启用了加密，并将卷副本的数量设置为1。这意味着，由Ondat CSI提供并由该<code class="fe mj mk ml mm b">StorageClass</code>配置的每个永久卷将被格式化为XFS，使用AES-256密码进行静态加密(传输中加密默认启用且不可更改)，并在Ondat数据网格中有一个副本可用。</p><h1 id="efad" class="mo mp it bd mq mr ms mt mu mv mw mx my jz mz ka na kc nb kd nc kf nd kg ne nf bi translated">部署数据库</h1><p id="b119" class="pw-post-body-paragraph kz la it lb b lc ng ju le lf nh jx lh li ni lk ll lm nj lo lp lq nk ls lt lu im bi translated">数据库本身不需要手动部署。Skaffold将处理应用程序部署工作流，其中包括MongoDB集群。惟一的先决条件是运行MongoDB操作符，并在Kubernetes中提供定制资源类型。使用以下命令检查操作员是否正在运行:</p><pre class="kj kk kl km gt nl mm nm nn aw no bi"><span id="df5b" class="np mp it mm b gy nq nr l ns nt">$ kubectl get pods -n mongo-operator<br/>NAME                                           READY   STATUS  ...</span><span id="ec77" class="np mp it mm b gy nu nr l ns nt">mongodb-kubernetes-operator-6d46dd4b74-ldfcc   1/1     Running ...</span></pre><p id="a16b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">此外，检查自定义资源类型是否已定义:</p><pre class="kj kk kl km gt nl mm nm nn aw no bi"><span id="0fef" class="np mp it mm b gy nq nr l ns nt">$ kubectl  api-resources | grep mongo<br/>mongodbcommunity  mdbc  mongodbcommunity.mongodb.com  ...</span></pre><h1 id="ae2b" class="mo mp it bd mq mr ms mt mu mv mw mx my jz mz ka na kc nb kd nc kf nd kg ne nf bi translated">使用Pymongo处理数据库</h1><p id="8d23" class="pw-post-body-paragraph kz la it lb b lc ng ju le lf nh jx lh li ni lk ll lm nj lo lp lq nk ls lt lu im bi translated">在深入Skaffold的管道配置之前，让我们看看如何编写Kubernetes <code class="fe mj mk ml mm b">Job</code>和FE来访问MongoDB数据库。</p><p id="0c3a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe mj mk ml mm b">Pymongo</code>提供Python绑定与MongoDB交互。在撰写本文时，最新版本是4.0.1，文档可从<a class="ae ky" href="https://pymongo.readthedocs.io/en/stable/index.html" rel="noopener ugc nofollow" target="_blank">https://pymongo.readthedocs.io/en/stable/index.html</a>获得。使用起来非常简单，这里有一个代码示例，展示了Kubernetes <code class="fe mj mk ml mm b">Job</code>如何连接到数据库，创建一个MongoDB <em class="mn">集合</em>，并向其中添加一个JSON文档。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nv nw l"/></div></figure><p id="9838" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">因为我们使用的是Mongo副本集，所以驱动程序需要一个种子列表。它将尝试在种子列表中查找集合的所有成员，但是操作没有阻塞。它无声无息地回来了。因此，如果您想捕捉任何连接错误，您应该将以下内容添加到您的代码中(来自文档):</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nv nw l"/></div></figure><p id="32c7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在<code class="fe mj mk ml mm b">add_mongo_document</code>函数代码中，我们指定了一个包含三个成员的种子列表，该列表通过环境变量传递给应用程序。这些变量包含在Kubernetes <code class="fe mj mk ml mm b">ConfigMap</code>中，它是由我们之前提到的Kustomize <code class="fe mj mk ml mm b">configMapGenerator</code>自动生成的。Kubernetes <code class="fe mj mk ml mm b">Job</code>和FE <code class="fe mj mk ml mm b">Deployment</code>清单都包含对那个<code class="fe mj mk ml mm b">ConfigMap</code>的引用。同样，可以通过运行<code class="fe mj mk ml mm b">kustomize build overlay/dev</code>来检查。有趣的部分如下:</p><pre class="kj kk kl km gt nl mm nm nn aw no bi"><span id="e7a0" class="np mp it mm b gy nq nr l ns nt">spec:<br/>  containers:<br/>  - envFrom:<br/>    - configMapRef:<br/>        name: mongo-config-b29f887ch6</span></pre><p id="2b90" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">您可以注意到Kustomize有效地生成了一个带有随机字符串后缀的惟一名称，这个名称被<code class="fe mj mk ml mm b">Job</code>和<code class="fe mj mk ml mm b">Deployment</code>清单引用。这些清单中定义的变量在<code class="fe mj mk ml mm b">kustomization.yaml</code>文件的<code class="fe mj mk ml mm b">configMagGenerator</code>部分中被指定为文字:</p><pre class="kj kk kl km gt nl mm nm nn aw no bi"><span id="f4a0" class="np mp it mm b gy nq nr l ns nt">configMapGenerator:<br/>- name: mongo-config<br/>  literals:<br/>  - MONGO_SEED0=mongodb-0.mongodb.default.svc.cluster.local<br/>  - MONGO_SEED1=mongodb-1.mongodb.default.svc.cluster.local<br/>  - MONGO_SEED2=mongodb-2.mongodb.default.svc.cluster.local<br/>  - OFFSET=600<br/>  - MONGO_USERNAME=admin</span></pre><p id="6a0a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">类似地，该功能所需的密码通过一个<code class="fe mj mk ml mm b">Secret </code>传递，其中密码值与一个名为<em class="mn">密码的键相关联。</em></p><pre class="kj kk kl km gt nl mm nm nn aw no bi"><span id="8940" class="np mp it mm b gy nq nr l ns nt">secretGenerator:<br/>- name: admin-password<br/>  literals:<br/>  - password=mongo</span></pre><p id="52ad" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">接下来在第10行，<code class="fe mj mk ml mm b">db.marvel</code>隐式定义了一个新的MongoDB <em class="mn">集合</em>(相当于关系数据库表的NoSQL)。</p><p id="045f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在第11行，<code class="fe mj mk ml mm b">db.characters.insert_one(document)</code>在集合中创建新文档。来自漫威API端点的每个JSON响应都被解析为符合以下结构:</p><pre class="kj kk kl km gt nl mm nm nn aw no bi"><span id="e07b" class="np mp it mm b gy nq nr l ns nt">{<br/>  "id": 10093467,<br/>  "name": "Iron Fist (Danny Rand)",<br/>  "thumbnail": "<a class="ae ky" href="http://i.annihil.us/u/prod/marvel/i/mg/3/f0/52616788ebc63" rel="noopener ugc nofollow" target="_blank">http://i.annihil.us/u/prod/marvel</a>...",<br/>  "extension": "jpg",<br/>  "comics":<br/>    {<br/>      "available": "98",<br/>      "collectionURI": "<a class="ae ky" href="http://gateway.marvel.com/v1/public/characters/1009367/comics" rel="noopener ugc nofollow" target="_blank">http://gateway.marvel.com/v1/public/cha</a>...",<br/>      "items": <br/>      [{<br/>          "resourceURI": "<a class="ae ky" href="http://gateway.marvel.com/v1/public/comics/43504" rel="noopener ugc nofollow" target="_blank">http://gateway.marvel.com/v1/public/</a>...",<br/>          "name": "A+X (2012) #5"<br/>       },<br/>       {  "resourceURI": "<a class="ae ky" href="http://gateway.marvel.com/v1/public/comics/77062" rel="noopener ugc nofollow" target="_blank">http://gateway.marvel.com/v1/public/</a>...",<br/>          "name": "Absolute Carnage: Lethal Protectors (2019) #2"<br/>       }<br/>       ...<br/>      "returned": 20<br/>    }<br/>}</span></pre><h1 id="d471" class="mo mp it bd mq mr ms mt mu mv mw mx my jz mz ka na kc nb kd nc kf nd kg ne nf bi translated">安装和配置Skaffold</h1><p id="7dc2" class="pw-post-body-paragraph kz la it lb b lc ng ju le lf nh jx lh li ni lk ll lm nj lo lp lq nk ls lt lu im bi translated">安装Skaffold非常简单，只需按照这里的<a class="ae ky" href="https://skaffold.dev/docs/install/" rel="noopener ugc nofollow" target="_blank">所示的步骤进行</a>。下一步是通过运行<code class="fe mj mk ml mm b">skaffold init</code>来配置Skaffold。它生成一个名为<code class="fe mj mk ml mm b">skaffold.yaml</code>的文件，该文件提供了一个标准的工作模板。该命令会问一些问题，但您可以选择任何答案，目标只是从一个非空的YAML文件开始…我的意思是谁喜欢从一个空的YAML配置开始:-)？</p><p id="988f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这是我们指定构建和部署选项的地方，最终配置如下所示(<code class="fe mj mk ml mm b">skaffold.yaml</code>配置文件位于应用程序存储库的根目录):</p><pre class="kj kk kl km gt nl mm nm nn aw no bi"><span id="afe3" class="np mp it mm b gy nq nr l ns nt">apiVersion: skaffold/v2beta26<br/>kind: Config<br/>metadata:<br/>  name: demo-marvel-app<br/>build:<br/>  artifacts:<br/>  - image: vfiftyfive/flask_marvel<br/>    custom:<br/>      buildCommand: sh build.sh<br/>  local:<br/>    push: true<br/>deploy:<br/>  kustomize:<br/>    paths: <br/>    - &lt;path_to_dev_overlay&gt;</span></pre><p id="9c4d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">定制构建命令是我前面提到的<code class="fe mj mk ml mm b">build.sh</code>文件，Kustomize路径是本地<em class="mn"> dev </em>覆盖目录的路径。我们还将图片发布在Docker Hub上，这需要Skaffold了解您的Docker Hub证书。与Docker Hub集成最简单的方法是用<code class="fe mj mk ml mm b">docker login</code>登录Docker，然后通过运行<code class="fe mj mk ml mm b">skaffold dev --default-repo=&lt;your_registry&gt;</code>配置Skaffold使用您的注册表，其中<code class="fe mj mk ml mm b">&lt;your_registry&gt;</code> Docker Hub是您的用户名。</p><p id="e394" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">一旦您设置了您的<code class="fe mj mk ml mm b">KUBECONFIG</code>环境变量来连接到您的dev Kubernetes集群，剩下的唯一事情就是运行<code class="fe mj mk ml mm b">skaffold dev</code>:</p><pre class="kj kk kl km gt nl mm nm nn aw no bi"><span id="8a12" class="np mp it mm b gy nq nr l ns nt">$ export KUBECONFIG=&lt;path_to_kubeconfig_file&gt;<br/>$ skaffold dev<br/>Listing files to watch...<br/> - vfiftyfive/flask_marvel<br/>Generating tags...<br/> - vfiftyfive/flask_marvel -&gt; vfiftyfive/flask_marvel:6f061f0<br/>Checking cache...<br/> - vfiftyfive/flask_marvel: Not found. Building<br/>Starting build...<br/>Building [vfiftyfive/flask_marvel]...<br/>+ docker buildx build --builder skaffold-builder --tag vfiftyfive/flask_marvel:6f061f0 --platform linux/amd64,linux/arm64 --push /Users/nvermande/Documents/Dev/Ondat/FlaskMarvelApp<br/>#1 [internal] load build definition from Dockerfile<br/>#1 transferring dockerfile: 299B 0.0s done<br/>#1 DONE 0.1s</span><span id="f0a7" class="np mp it mm b gy nu nr l ns nt">#2 [internal] load .dockerignore<br/>#2 transferring context: 2B 0.0s done<br/>#2 DONE 0.0s</span><span id="e714" class="np mp it mm b gy nu nr l ns nt">#3 [linux/arm64 internal] load metadata for docker.io/library/python:3.9<br/>#3 ...</span><span id="5313" class="np mp it mm b gy nu nr l ns nt">...</span><span id="c55f" class="np mp it mm b gy nu nr l ns nt">Tags used in deployment:<br/> - vfiftyfive/flask_marvel -&gt; vfiftyfive/flask_marvel:6f061f0@sha256:629734c5e62206752f051e9f47fdc3bc6d1f61e399b9a89920c8d7d9f87ee0f8<br/>Starting deploy...<br/> - storageclass.storage.k8s.io/ondat created<br/> - service/marvel-frontend created<br/> - service/mongodb created<br/> - deployment.apps/marvel-frontend created<br/> - statefulset.apps/mongodb created<br/> - job.batch/add-data-to-mongodb created<br/>Waiting for deployments to stabilize...<br/> - deployment/marvel-frontend: creating container flask-marvel<br/>    - pod/marvel-frontend-5bdd684d78-zpbvm: creating container flask-marvel<br/>    - pod/marvel-frontend-5bdd684d78-2mf4m: creating container flask-marvel<br/> - statefulset/mongodb: creating container mongodb<br/>    - pod/mongodb-0: creating container mongodb<br/> - deployment/marvel-frontend is ready. [1/2 deployment(s) still pending]</span><span id="fef6" class="np mp it mm b gy nu nr l ns nt">...</span><span id="fc93" class="np mp it mm b gy nu nr l ns nt">Generating tags...<br/> - vfiftyfive/flask_marvel -&gt; vfiftyfive/flask_marvel:6f061f0<br/>Checking cache...<br/> - vfiftyfive/flask_marvel: Found Remotely<br/>Tags used in deployment:<br/> - vfiftyfive/flask_marvel -&gt; vfiftyfive/flask_marvel:6f061f0@sha256:629734c5e62206752f051e9f47fdc3bc6d1f61e399b9a89920c8d7d9f87ee0f8<br/>Starting deploy...<br/>Waiting for deployments to stabilize...<br/> - statefulset/mongodb is ready. [1/2 deployment(s) still pending]<br/> - deployment/marvel-frontend is ready.<br/>Deployments stabilized in 1.49 second<br/>Watching for changes...</span></pre><p id="4f3f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">从上面的输出可以看出，Skaffold构建了Docker映像，并使用Kustomize部署了Kubernetes清单，作为映像构建的结果，用特定的映像标记和摘要配置了新的FE映像。</p><p id="4670" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">Skaffold还有另一个有趣的特性，那就是能够实时输出它所监控的<code class="fe mj mk ml mm b">Pods</code>的日志。例如，如果您构建了一个<em class="mn"> foo </em>和一个<em class="mn"> bar </em>工件，Skaffold将在它们被更新时显示<em class="mn"> foo </em>和<em class="mn">bar</em>T1】的输出。当Skaffold以守护模式运行时，可以使用上面的<code class="fe mj mk ml mm b">dev</code>选项。这意味着当您开发应用程序时，您不必使用<code class="fe mj mk ml mm b">kubectl</code>从多个地方收集容器的日志。Skaffold将它们集中起来，然后发送到守护程序标准输出！我不得不承认很方便。</p><p id="28a4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果我们看看Kubernetes集群中现在正在运行什么，我们可以看到以下内容(年龄字段已被截断):</p><pre class="kj kk kl km gt nl mm nm nn aw no bi"><span id="37ea" class="np mp it mm b gy nq nr l ns nt">$ kubectl get pods<br/>NAME                               READY   STATUS      RESTARTS   <br/>add-data-to-mongodb-9brkw          0/1     Completed   0          <br/>marvel-frontend-5bdd684d78-2mf4m   1/1     Running     0          <br/>marvel-frontend-5bdd684d78-zpbvm   1/1     Running     0          <br/>mongodb-0                          1/1     Running     0          <br/>mongodb-1                          1/1     Running     0          <br/>mongodb-2                          1/1     Running     0</span></pre><p id="a4d1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">Skaffold已经部署了我们的应用程序运行所需的所有组件。在试图修改源代码之前，让我们检查一下应用程序是否工作正常。为此，我们只需使用<code class="fe mj mk ml mm b">kubectl port-forward</code>,并用我们首选的浏览器在本地检查结果:</p><pre class="kj kk kl km gt nl mm nm nn aw no bi"><span id="eaf0" class="np mp it mm b gy nq nr l ns nt">$ kubectl port-forward svc/marvel-frontend 8080<br/>Forwarding from 127.0.0.1:8080 -&gt; 80<br/>Forwarding from [::1]:8080 -&gt; 80</span></pre><p id="7ded" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果我们浏览到<code class="fe mj mk ml mm b"><a class="ae ky" href="http://localhost:8080" rel="noopener ugc nofollow" target="_blank">http://localhost:8080</a></code>，我们可以看到应用程序正在工作:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nx"><img src="../Images/4a0fb5b3b707315abf68cc3b156b9bf6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*4aSK4D5lhqsM2OhXJMafBQ.png"/></div></div></figure><p id="e262" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">假设我们现在想要修改这个应用程序中的一些文本。我们想用“漫画”代替“漫画”。为此，只需编辑<code class="fe mj mk ml mm b">app &gt; templates &gt; pages.html</code>下应用程序存储库中的HTML代码</p><p id="ac5d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">将所有出现的“漫画”替换为“漫画”。以下是一个实例:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nv nw l"/></div></figure><p id="2a6d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">然后保存文件，您应该会看到来自Skaffold的以下输出:</p><pre class="kj kk kl km gt nl mm nm nn aw no bi"><span id="caf9" class="np mp it mm b gy nq nr l ns nt">Generating tags...<br/> - vfiftyfive/flask_marvel -&gt; vfiftyfive/flask_marvel:186a97d<br/>Checking cache...<br/> - vfiftyfive/flask_marvel: Found. Tagging<br/>Tags used in deployment:<br/> - vfiftyfive/flask_marvel -&gt; vfiftyfive/flask_marvel:186a97d@sha256:33034d0241d6fbd586f550766ae22ed8633f099b53cca9a4544510c856f77811<br/> - vfiftyfive/marvel_init_db -&gt; vfiftyfive/marvel_init_db:186a97d@sha256:ca57d37157384fb83616708b69ee12e60b8023fa05cef2325b9537b13bd934ce<br/>Starting deploy...<br/> - deployment.apps/marvel-frontend configured<br/>Waiting for deployments to stabilize...<br/> - dev:deployment/marvel-frontend is ready.<br/>Deployments stabilized in 4.263 seconds<br/>Watching for changes...</span></pre><p id="049e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在Kubernetes中，您应该看到新的前端容器被创建，旧的被销毁:</p><pre class="kj kk kl km gt nl mm nm nn aw no bi"><span id="2eb4" class="np mp it mm b gy nq nr l ns nt">$ kubectl get pods -w<br/>marvel-frontend-7d876b7bff-57vxb  1/1     Running      0 10s<br/>marvel-frontend-7d876b7bff-wr9s9  1/1     Running      0 9s<br/>marvel-frontend-7d876b7bff-6hnx5  1/1     Running      0 7s<br/>marvel-frontend-65d655d644-fksdl  0/1     Terminating  0 7m23s<br/>marvel-frontend-65d655d644-fksdl  0/1     Terminating  0 7m26s<br/>marvel-frontend-65d655d644-fksdl  0/1     Terminating  0 7m26s</span></pre><p id="776c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">您可以浏览到相同的URL并查看更新后的应用程序:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ny"><img src="../Images/f9d4e3518192aa6b9129c0e06d8f62ab.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Snp7t8RawVlDYQktfauy0w.png"/></div></div></figure><h1 id="7fc2" class="mo mp it bd mq mr ms mt mu mv mw mx my jz mz ka na kc nb kd nc kf nd kg ne nf bi translated">结论</h1><p id="4622" class="pw-post-body-paragraph kz la it lb b lc ng ju le lf nh jx lh li ni lk ll lm nj lo lp lq nk ls lt lu im bi translated">我们希望Kubernetes对有状态应用程序的开发生命周期的深入研究能够突出他们所面临的挑战。</p><p id="cdab" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">首先，它们需要一个抽象层次来管理它们的配置和部署，这可以通过利用特定的操作符来实现。尽管如此，他们的数据库方法仍然缺乏标准，这可能会在需要微调时导致混乱和技术挑战。</p><p id="8d29" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">其次，Kubernetes提供了将基础设施需求封装成YAML的能力。因此，它们可以很容易地注入到CI/CD管道中，但需要大量的胶水来绘制不同的组件。Skaffold是一个有价值的工具，它为构建阶段集成了Docker和定制脚本，为部署阶段集成了Kustomize。在开发模式下，只要您在开发环境中本地保存了更改，Skaffold就会更新相关的组件。</p><p id="1632" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">最后，Kubernetes默认不提供高级存储功能。但是，在事实上的云操作系统上运行有状态的应用程序时，复制、加密、精简配置和持久卷的优化性能是关键要求。Ondat提供数据平面来实现这些功能，同时与Kubernetes控制平面完全集成。无论Kubernetes集群位于何处(例如在您的本地数据中心、公共云中或在您的笔记本电脑上)，Ondat都能提供分布式软件定义存储解决方案。然后，您可以利用关键数据服务来确保有状态应用程序的伸缩性、弹性和性能一致性。</p><h1 id="94c5" class="mo mp it bd mq mr ms mt mu mv mw mx my jz mz ka na kc nb kd nc kf nd kg ne nf bi translated">我一路走来学到的东西</h1><ul class=""><li id="1c9b" class="lv lw it lb b lc ng lf nh li nz lm oa lq ob lu ma mb mc md bi translated">如果你在Skaffold有Kubernetes <code class="fe mj mk ml mm b">jobs</code>，使用<code class="fe mj mk ml mm b">skaffold dev</code>时需要通过<code class="fe mj mk ml mm b">--force</code>。这是因为一旦一个<code class="fe mj mk ml mm b">job</code>存在于Kubernetes中，它的包含<code class="fe mj mk ml mm b">image</code>属性的<code class="fe mj mk ml mm b">template</code>部分就是不可变的。<code class="fe mj mk ml mm b">force</code>选项删除它而不是更新它，就像你对<code class="fe mj mk ml mm b">kubectl replace --force -f my-job.yaml</code>做的一样</li><li id="1265" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated">MongoDB社区Kubernetes操作员默认启用身份验证并创建一个用户。用户名是可配置的，但是记住它是由操作员管理的。通过mongo命令对该用户进行的任何手动修改都将被恢复。这是因为运营商依赖于确保定制资源配置占上风的协调循环。因此，例如，如果您需要向该用户添加角色，请从负责用户配置的自定义资源部分进行添加:</li></ul><pre class="kj kk kl km gt nl mm nm nn aw no bi"><span id="0aef" class="np mp it mm b gy nq nr l ns nt">users:<br/>    - name: admin<br/>      db: admin<br/>      passwordSecretRef:<br/>        name: admin-password<br/>      roles:<br/>        - name: clusterAdmin<br/>          db: admin<br/>        - name: userAdminAnyDatabase<br/>          db: admin<br/>        <strong class="mm iu">- name: dbAdminAnyDatabase<br/>          db: admin<br/>        - name: readWriteAnyDatabase<br/>          db: admin</strong><br/>      scramCredentialsSecretName: my-scram</span></pre><p id="4950" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们添加了几个粗体的新角色，因此我们的管理员用户对所有数据库都有合适的权限。</p><ul class=""><li id="0a6e" class="lv lw it lb b lc ld lf lg li lx lm ly lq lz lu ma mb mc md bi translated">操作员还希望用户<code class="fe mj mk ml mm b">Secret</code>中有一个名为“password”的密钥。密码值代表用户密码。</li><li id="4d4e" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated">在Kustomize中，每个YAML节点都需要在位于基目录中的清单中有一个name字段。如果您省略了基本文件夹中的名称，并在Kustomization文件中添加了一个补丁，该补丁将不会被应用。</li><li id="1427" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated">当使用Kustomize用Kustomize生成器的输出值替换自定义资源中的特定域时，Kustomize文件中需要一个配置节来定义附加映射。例如，如果您需要将Kustomize <code class="fe mj mk ml mm b">secretgenerator</code>生成的<code class="fe mj mk ml mm b">Secret</code>的名称指定为<code class="fe mj mk ml mm b">MongoDBCommunity</code>自定义资源<code class="fe mj mk ml mm b">passwordSecretRef</code>字段的值，您需要告诉Kustomize每次运行到<code class="fe mj mk ml mm b">passwordSecretRef</code>时，它必须用生成的Kubernetes <code class="fe mj mk ml mm b">Secret</code>名称的值替换它的值。</li></ul><h1 id="7385" class="mo mp it bd mq mr ms mt mu mv mw mx my jz mz ka na kc nb kd nc kf nd kg ne nf bi translated">奖金</h1><p id="57e2" class="pw-post-body-paragraph kz la it lb b lc ng ju le lf nh jx lh li ni lk ll lm nj lo lp lq nk ls lt lu im bi translated">上周，我有幸在CNCF直播期间展示了本博客系列中使用的技术，还通过Tekton和Kyverno添加了完整的Kubernetes-native CI/CD管道。请点击下面的链接:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oc nw l"/></div></figure></div></div>    
</body>
</html>