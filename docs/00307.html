<html>
<head>
<title>Clock-In/Out System Part 9: Back-End Testing — Unit Testing of Services</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">上下班打卡系统第9部分:后端测试—服务的单元测试</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/part-9-testing-backend-testing-2d021f48403b?source=collection_archive---------1-----------------------#2019-03-15">https://betterprogramming.pub/part-9-testing-backend-testing-2d021f48403b?source=collection_archive---------1-----------------------#2019-03-15</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="6fca" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">NestJS + Angular教程</h2></div><figure class="ki kj kk kl gt km gh gi paragraph-image"><div class="ab gu cl kn"><img src="../Images/e6c3fdb25434835230d0b2d6f489e857.png" data-original-src="https://miro.medium.com/v2/format:webp/1*KhCkmbtORw2Ux3n5WCrtzA.png"/></div></figure><p id="caaa" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">这篇文章是我描述上下班打卡系统的系列文章的一部分。如果你想了解更多，你可以阅读以下内容:</p><ul class=""><li id="ace6" class="lm ln it ks b kt ku kw kx kz lo ld lp lh lq ll lr ls lt lu bi translated"><a class="ae lv" href="https://medium.com/@ccaballero/part-1-clock-in-out-system-diagram-a0a51bab02a7?source=post_page---------------------------" rel="noopener">上下班打卡系统第1部分:图</a></li><li id="02aa" class="lm ln it ks b kt lw kw lx kz ly ld lz lh ma ll lr ls lt lu bi translated"><a class="ae lv" href="https://medium.com/better-programming/part-2-clock-in-out-system-basic-backend-i-authmodule-66d4a5c56122?source=post_page---------------------------" rel="noopener">上下班打卡系统第二部分:基础后端— AuthModule </a></li><li id="f56b" class="lm ln it ks b kt lw kw lx kz ly ld lz lh ma ll lr ls lt lu bi translated"><a class="ae lv" href="https://medium.com/better-programming/part-3-clock-in-out-system-basic-backend-ii-usersmodule-a56f42b20f62?source=post_page---------------------------" rel="noopener">上下班打卡系统第3部分:基本后端——用户模块</a></li><li id="570e" class="lm ln it ks b kt lw kw lx kz ly ld lz lh ma ll lr ls lt lu bi translated"><a class="ae lv" href="https://medium.com/better-programming/part-4-clock-in-out-system-basic-backend-iii-appmodule-850dd17883e?source=post_page---------------------------" rel="noopener">上下班打卡系统第4部分:基础后端— AppModule </a></li><li id="4035" class="lm ln it ks b kt lw kw lx kz ly ld lz lh ma ll lr ls lt lu bi translated"><a class="ae lv" href="https://medium.com/better-programming/part-5-clock-in-out-system-seed-database-and-migration-data-cf037be21aac?source=post_page---------------------------" rel="noopener">上下班打卡系统第5部分:种子数据库和迁移数据</a></li><li id="09ca" class="lm ln it ks b kt lw kw lx kz ly ld lz lh ma ll lr ls lt lu bi translated"><a class="ae lv" href="https://medium.com/@ccaballero/part-6-clock-in-out-system-basic-frontend-an-7e5f9ed08c3f?source=post_page---------------------------" rel="noopener">上下班打卡系统第6部分:基本前端</a></li><li id="cb20" class="lm ln it ks b kt lw kw lx kz ly ld lz lh ma ll lr ls lt lu bi translated"><a class="ae lv" href="https://medium.com/@ccaballero/part-7-deploy-backend-nestjs-docker-docker-compose-2429c0b6aa9c?source=post_page---------------------------" rel="noopener">上下班打卡系统第7部分:使用Docker/Docker-Compose部署后端(NestJS)</a></li><li id="8948" class="lm ln it ks b kt lw kw lx kz ly ld lz lh ma ll lr ls lt lu bi translated"><a class="ae lv" href="https://medium.com/@ccaballero/part-8-clock-in-out-system-deploy-frontend-angular-6-using-environments-ad267325d3b6?source=post_page---------------------------" rel="noopener">上下班打卡系统第8部分:使用环境部署前端(角度6+)</a></li><li id="e6a0" class="lm ln it ks b kt lw kw lx kz ly ld lz lh ma ll lr ls lt lu bi translated"><a class="ae lv" href="https://medium.com/@ccaballero/part-9-testing-backend-testing-2d021f48403b?source=post_page---------------------------" rel="noopener">上下班打卡系统第9部分:后端测试——服务的单元测试</a></li><li id="9ede" class="lm ln it ks b kt lw kw lx kz ly ld lz lh ma ll lr ls lt lu bi translated"><a class="ae lv" href="https://medium.com/@ccaballero/part-10-testing-backend-testing-unit-testing-controllers-4177370ef581?source=post_page---------------------------" rel="noopener">上下班打卡系统第10部分:后端测试——控制器单元测试</a></li><li id="ddde" class="lm ln it ks b kt lw kw lx kz ly ld lz lh ma ll lr ls lt lu bi translated">上下班打卡系统第11部分:后端测试-e2e测试</li><li id="9c7b" class="lm ln it ks b kt lw kw lx kz ly ld lz lh ma ll lr ls lt lu bi translated">上下班打卡系统第12部分:前端测试单元测试</li><li id="701a" class="lm ln it ks b kt lw kw lx kz ly ld lz lh ma ll lr ls lt lu bi translated">上下班打卡系统第13部分:前端测试集成测试</li></ul></div><div class="ab cl mb mc hx md" role="separator"><span class="me bw bk mf mg mh"/><span class="me bw bk mf mg mh"/><span class="me bw bk mf mg"/></div><div class="im in io ip iq"><h1 id="0fcf" class="mi mj it bd mk ml mm mn mo mp mq mr ms jz mt ka mu kc mv kd mw kf mx kg my mz bi translated">后端测试概述</h1><p id="3518" class="pw-post-body-paragraph kq kr it ks b kt na ju kv kw nb jx ky kz nc lb lc ld nd lf lg lh ne lj lk ll im bi translated">这是关于测试的第一篇文章，也可以认为是关于质量评估(QA)的第一篇文章。</p><p id="117e" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">这个项目不是从一开始就使用测试驱动开发(TDD)开发的，但我目前正在测试阶段进行。多亏了测试阶段，我发现了很多小错误。如果这个项目已经投入生产，这可能是一个大问题。事实是，该项目将在接下来的几周内进入生产模式。这些测试对于修复目前已经发现的几个bug非常有用。</p><p id="7a0e" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">测试的第一步是决定你应该测试什么。人们可能会说，你必须测试整个应用程序，你必须获得接近100%的覆盖率。事实上，你不需要测试整个应用程序——但是你必须测试软件中最关键的部分。这可能接近90%或70%，取决于您的应用程序。</p><p id="48b3" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">在我们的例子中，我将建议我们应该测试服务(app.service、user.service和auth.service)和控制器(app.controller、user.controller)。不需要测试d to、常量、实体或模块。那些测试很难，价值也很小。</p><p id="5972" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">后端使用<a class="ae lv" href="https://nestjs.com/" rel="noopener ugc nofollow" target="_blank"> NestJS </a>框架开发，该框架使用<a class="ae lv" href="https://jestjs.io/" rel="noopener ugc nofollow" target="_blank"> Jest </a>作为测试工具。此外，NestJS包括一个强大的测试包，它模拟了一个类似于<a class="ae lv" href="https://angular.io/guide/testing" rel="noopener ugc nofollow" target="_blank">角度测试包</a>的环境。</p></div><div class="ab cl mb mc hx md" role="separator"><span class="me bw bk mf mg mh"/><span class="me bw bk mf mg mh"/><span class="me bw bk mf mg"/></div><div class="im in io ip iq"><h1 id="65ad" class="mi mj it bd mk ml mm mn mo mp mq mr ms jz mt ka mu kc mv kd mw kf mx kg my mz bi translated">服务测试</h1><p id="d5b1" class="pw-post-body-paragraph kq kr it ks b kt na ju kv kw nb jx ky kz nc lb lc ld nd lf lg lh ne lj lk ll im bi translated">在这篇文章中，我将描述服务单元测试，这是测试金字塔中最简单的测试。我对那些开始从事测试工作的人的建议是，从对服务进行单元测试开始。这些都是小功能，有独特的任务，很容易被隔离。因此，它们是最简单、最容易测试的。</p><figure class="ki kj kk kl gt km gh gi paragraph-image"><div role="button" tabindex="0" class="ng nh di ni bf nj"><div class="gh gi nf"><img src="../Images/231acacea0344b60dfcc0af9c66f9ef5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*RuN5s7cMjVG2wA2L.png"/></div></div><p class="nk nl gj gh gi nm nn bd b be z dk translated">测试金字塔</p></figure><h1 id="395a" class="mi mj it bd mk ml no mn mo mp np mr ms jz nq ka mu kc nr kd mw kf ns kg my mz bi translated">应用服务</h1><p id="2ad7" class="pw-post-body-paragraph kq kr it ks b kt na ju kv kw nb jx ky kz nc lb lc ld nd lf lg lh ne lj lk ll im bi translated">我们要测试的第一个服务是<code class="fe nt nu nv nw b">app.service.ts</code>。它使用两种服务:<code class="fe nt nu nv nw b">AuthService</code>和<code class="fe nt nu nv nw b">UserService</code>。我们的测试套件必须检查<code class="fe nt nu nv nw b">app.service</code>将使用正确的参数调用服务。</p><p id="989e" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">第一步包括我们将要开发的每个测试的初始配置。<code class="fe nt nu nv nw b">app.service.ts</code>在其构造函数中需要两个服务(<code class="fe nt nu nv nw b">AuthService</code>和<code class="fe nt nu nv nw b">UserService</code>)，这两个服务将是间谍。来自<code class="fe nt nu nv nw b">@nestjs/testing</code>的<code class="fe nt nu nv nw b">Test</code>包提供了创建测试模块进行测试的方法<code class="fe nt nu nv nw b">createTestingModule </code>。在这个<code class="fe nt nu nv nw b">testingModule</code>中，<code class="fe nt nu nv nw b">providers</code>数组由<code class="fe nt nu nv nw b">AppService</code>和两个使用工厂创建的间谍组成。以下代码向您展示了这一初始配置:</p><figure class="ki kj kk kl gt km gh gi paragraph-image"><div role="button" tabindex="0" class="ng nh di ni bf nj"><div class="gh gi nx"><img src="../Images/0e388e66243afcae76b737ecdabb4d8b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*x6MJpxZrY-lit2ZpPOWBbQ.png"/></div></div></figure><p id="26c5" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">下一步包括知道我们想要测试什么。主要思想是独立于任何其他函数/方法来测试每个函数/方法。以下方法是<code class="fe nt nu nv nw b">app.service.ts</code>中代码的一部分。</p><figure class="ki kj kk kl gt km gh gi paragraph-image"><div role="button" tabindex="0" class="ng nh di ni bf nj"><div class="gh gi ny"><img src="../Images/fb8f82c75702aab75860f301dc91dac4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*UM9Sx3JebcndEFD4qEostQ.png"/></div></div></figure><p id="806b" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated"><code class="fe nt nu nv nw b">authIn</code>和<code class="fe nt nu nv nw b">authOut</code>方法应该检查是否使用正确的参数调用了<code class="fe nt nu nv nw b">authService</code>。在我们的例子中，测试是单元，因此方法<code class="fe nt nu nv nw b">this.authService.authIn</code>和<code class="fe nt nu nv nw b">this.authService.authOut</code>不应该使用真正的函数/方法来调用。这就是为什么我们用间谍来做这些事。测试函数的代码如下:</p><figure class="ki kj kk kl gt km gh gi paragraph-image"><div role="button" tabindex="0" class="ng nh di ni bf nj"><div class="gh gi nz"><img src="../Images/a5ab30f0daaab37120280feca7cc998a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ypj9PTe8CSyXfcIS9aPvFw.png"/></div></div></figure><p id="0e23" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">在之前的测试中，您可以注意到<code class="fe nt nu nv nw b">expect</code>与方法<code class="fe nt nu nv nw b">authIn</code>和<code class="fe nt nu nv nw b">authOut</code>相关。它检查这些方法是否被调用，参数是否正确。方法<code class="fe nt nu nv nw b">authIn</code>或<code class="fe nt nu nv nw b">authOut</code>中抛出的错误是不相关的，因为在这些方法中，责任被委托给了其他服务。</p><p id="902d" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">与<code class="fe nt nu nv nw b">usersTicketing</code>方法相关的测试如下:</p><figure class="ki kj kk kl gt km gh gi paragraph-image"><div role="button" tabindex="0" class="ng nh di ni bf nj"><div class="gh gi oa"><img src="../Images/5093dec75009386c5c3f72fd548a142a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Z03NkUUMq-aSLOqqKHS9fw.png"/></div></div></figure><p id="4322" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">当执行<code class="fe nt nu nv nw b">Date</code>中的功能<code class="fe nt nu nv nw b">now</code>时，创建一个间谍供使用。这是为了防止用户在同一天返回。(测试必须是纯粹的，不依赖于外部因素)。在这个测试中，我们需要检查方法<code class="fe nt nu nv nw b">getUsersMustBeWorkingNow</code>是否已经被调用，方法<code class="fe nt nu nv nw b">usersTicketing</code>的结果是否是一个包含密匙<code class="fe nt nu nv nw b">users</code>的对象，密匙<code class="fe nt nu nv nw b">UserService</code>中提供了密匙值和当天的时间戳。</p><h1 id="0b1a" class="mi mj it bd mk ml no mn mo mp np mr ms jz nq ka mu kc nr kd mw kf ns kg my mz bi translated">用户服务程序</h1><p id="78bc" class="pw-post-body-paragraph kq kr it ks b kt na ju kv kw nb jx ky kz nc lb lc ld nd lf lg lh ne lj lk ll im bi translated">测试用户服务的程序与<code class="fe nt nu nv nw b">app.service.ts</code>中使用的程序相同。第一步是创建测试模块，其中包含将在下面的测试中使用的spy和服务。</p><figure class="ki kj kk kl gt km gh gi paragraph-image"><div role="button" tabindex="0" class="ng nh di ni bf nj"><div class="gh gi ob"><img src="../Images/4e8c7a70e7ffe2da66ed83fad28cea33.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*XaVDsPVh8pmCoLNjoWGZYw.png"/></div></div></figure><p id="33aa" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">第一种方法非常简单，因为使用的技术与<code class="fe nt nu nv nw b">app.service.ts</code>中的相同。要测试的代码如下:</p><figure class="ki kj kk kl gt km gh gi paragraph-image"><div role="button" tabindex="0" class="ng nh di ni bf nj"><div class="gh gi oc"><img src="../Images/c3f1fc024221205e8b02f3729d13197b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*O62herRe3cby0zZIWbtP5Q.png"/></div></div></figure><p id="138a" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">它的测试套件只检查方法<code class="fe nt nu nv nw b">save</code>是否用正确的参数(<code class="fe nt nu nv nw b">User</code>原型和初始参数)调用，如下面的代码所示:</p><figure class="ki kj kk kl gt km gh gi paragraph-image"><div role="button" tabindex="0" class="ng nh di ni bf nj"><div class="gh gi od"><img src="../Images/e9e7d99557243b52d4a84c64bbc9cfe8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*6yBB6L8UxyyjVfZlTj6V7A.png"/></div></div></figure><p id="b3e7" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">下一个要测试的方法是调用<code class="fe nt nu nv nw b">TypeORM</code> ORM，如下所示:</p><figure class="ki kj kk kl gt km gh gi paragraph-image"><div role="button" tabindex="0" class="ng nh di ni bf nj"><div class="gh gi oe"><img src="../Images/1cde593cc1b984ac2b15fd387b920f70.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*sFghvDgWDqfrfzw-n_1hlg.png"/></div></div></figure><p id="3d1b" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">在这个测试中，我们需要使用链式责任从<code class="fe nt nu nv nw b">usersRepository</code>中窥探每个方法。为此，我们使用Jest提供的工厂。</p><figure class="ki kj kk kl gt km gh gi paragraph-image"><div role="button" tabindex="0" class="ng nh di ni bf nj"><div class="gh gi of"><img src="../Images/c43af915ae5bdfc7ed5bca4f24fa6dc4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*xh6miGfI-lIJ6VM5EcuOQQ.png"/></div></div></figure><p id="3514" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">如你所见，我们正在检查从<code class="fe nt nu nv nw b">TypeORM</code>调用的每一个方法，以及调用它的参数——简单快捷。</p><p id="6085" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">下面的方法可能有强烈的代码味道(长方法)。但是如果您仔细阅读该方法，您会注意到它是一个很好的数据库查询调用，并且没有代码味道。</p><figure class="ki kj kk kl gt km gh gi paragraph-image"><div role="button" tabindex="0" class="ng nh di ni bf nj"><div class="gh gi og"><img src="../Images/fbe4dda2d6be5f5b51814cdc51a36d04.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*k8BtYAgyOVeypMp2WIoidQ.png"/></div></div></figure><p id="7f4e" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">该查询有几个参数组合，但测试是相同的。为了做这个测试，我们需要包含一个输入和输出的表格。Jest有一个名为<code class="fe nt nu nv nw b">each</code>的参数，可以用来参数化我们的测试。</p><p id="af84" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">下表列出了:</p><figure class="ki kj kk kl gt km gh gi paragraph-image"><div role="button" tabindex="0" class="ng nh di ni bf nj"><div class="gh gi oh"><img src="../Images/1ca605c925e910b6eb717b7f24553013.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*DWUpBlflF9p4OKAqhiAArg.png"/></div></div></figure><p id="a6d0" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">您可以看到，我们的表格中用于测试的参数如下:</p><ul class=""><li id="799f" class="lm ln it ks b kt ku kw kx kz lo ld lp lh lq ll lr ls lt lu bi translated"><strong class="ks iu">年</strong>:对应于我们想要测试用户是否在建筑物中的时刻的年份</li><li id="d892" class="lm ln it ks b kt lw kw lx kz ly ld lz lh ma ll lr ls lt lu bi translated"><strong class="ks iu">月</strong>:对应于我们想要测试用户是否在建筑物中的时刻的月份</li><li id="80d9" class="lm ln it ks b kt lw kw lx kz ly ld lz lh ma ll lr ls lt lu bi translated"><strong class="ks iu">日</strong>:对应于我们想要测试用户是否在建筑物中的时刻的一天</li><li id="3238" class="lm ln it ks b kt lw kw lx kz ly ld lz lh ma ll lr ls lt lu bi translated"><strong class="ks iu">小时</strong>:对应于我们想要测试用户是否在建筑物中的时刻的小时</li><li id="2bea" class="lm ln it ks b kt lw kw lx kz ly ld lz lh ma ll lr ls lt lu bi translated"><strong class="ks iu">分钟</strong>:对应于我们想要测试用户是否在建筑物中的时刻的分钟</li><li id="6dc7" class="lm ln it ks b kt lw kw lx kz ly ld lz lh ma ll lr ls lt lu bi translated"><strong class="ks iu">秒</strong>:对应于我们想要测试用户是否在建筑物中的时刻的秒。</li><li id="4692" class="lm ln it ks b kt lw kw lx kz ly ld lz lh ma ll lr ls lt lu bi translated"><strong class="ks iu"> hourNowExpected </strong>:使用另一个参数列表返回方法的小时</li><li id="1e95" class="lm ln it ks b kt lw kw lx kz ly ld lz lh ma ll lr ls lt lu bi translated"><strong class="ks iu"> dayNowExpected </strong>:应使用其他参数列表返回方法的日期</li></ul><p id="6a9a" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">我们的测试需要很多间谍来测试ORM。表中的预期值用于检查私有方法是否返回将用于ORM查询的值。如果私有方法是公共的，测试会更容易，但是测试不应该改变原始代码(除非发现了bug)。</p><figure class="ki kj kk kl gt km gh gi paragraph-image"><div role="button" tabindex="0" class="ng nh di ni bf nj"><div class="gh gi oi"><img src="../Images/502e371b281784d81effe45392d60aec.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*BWOhk2kZEcbdhGXnFLkQ3g.png"/></div></div></figure><p id="0176" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">测试的第一部分是创建间谍来检查它是否使用正确的参数被调用。然后，调用方法<code class="fe nt nu nv nw b">service.getUsersMustBeWorkingNow()</code>。最后，有一个期望列表，它检查ORM的方法是使用正确的参数调用的。</p><p id="d2fb" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">该测试的最终代码如下:</p><figure class="ki kj kk kl gt km gh gi paragraph-image"><div role="button" tabindex="0" class="ng nh di ni bf nj"><div class="gh gi oh"><img src="../Images/9e26b46db7f3ce73db575baf07adef6f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*eaP25aa7elrwqvKManY2yg.png"/></div></div></figure><h1 id="6820" class="mi mj it bd mk ml no mn mo mp np mr ms jz nq ka mu kc nr kd mw kf ns kg my mz bi translated">授权服务</h1><p id="f829" class="pw-post-body-paragraph kq kr it ks b kt na ju kv kw nb jx ky kz nc lb lc ld nd lf lg lh ne lj lk ll im bi translated">最后要测试的服务是<code class="fe nt nu nv nw b">auth.service.ts</code>。该技术类似于前面的测试。每个测试的第一步是初始配置。</p><figure class="ki kj kk kl gt km gh gi paragraph-image"><div role="button" tabindex="0" class="ng nh di ni bf nj"><div class="gh gi oj"><img src="../Images/7328f3a7e110554111f6447153d6ddc8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*5Eg1U50h-QL8EyfLIZe7yA.png"/></div></div></figure><p id="6632" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">要测试的代码如下:</p><figure class="ki kj kk kl gt km gh gi paragraph-image"><div role="button" tabindex="0" class="ng nh di ni bf nj"><div class="gh gi ok"><img src="../Images/2752d527ac4e6dfc2b96c32ef53598d3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*jiz9mRIxJ1NYOTndqoikog.png"/></div></div></figure><p id="59e6" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">您可以看到，有几个私有方法无法直接测试。这是因为私有方法类似于在公共方法中复制/粘贴这段代码。因此，这些方法不是测试套件的一部分。</p><p id="7c44" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">私有方法如下:</p><figure class="ki kj kk kl gt km gh gi paragraph-image"><div role="button" tabindex="0" class="ng nh di ni bf nj"><div class="gh gi ol"><img src="../Images/16ac8c7308cf55dd53ed63b869d3cf79.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*wr6G74F2ZZUfr-6wLQZ12A.png"/></div></div></figure><p id="592f" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">在我们的方法<code class="fe nt nu nv nw b">authIn</code>和<code class="fe nt nu nv nw b">authOut</code>的测试套件中，有三个不同的测试。它们代表了您在下面看到的场景。</p><p id="22c1" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated"><code class="fe nt nu nv nw b">authIn</code>应该:</p><ol class=""><li id="9dd9" class="lm ln it ks b kt ku kw kx kz lo ld lp lh lq ll om ls lt lu bi translated">进行身份验证并回复问候</li><li id="1955" class="lm ln it ks b kt lw kw lx kz ly ld lz lh ma ll om ls lt lu bi translated">找不到用户时返回错误</li><li id="46e5" class="lm ln it ks b kt lw kw lx kz ly ld lz lh ma ll om ls lt lu bi translated">出现意外错误时返回错误。</li></ol><p id="4fa3" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated"><code class="fe nt nu nv nw b">authOut</code>应该:</p><ol class=""><li id="ade9" class="lm ln it ks b kt ku kw kx kz lo ld lp lh lq ll om ls lt lu bi translated">保存认证并返回<em class="on">再见</em></li><li id="d6e8" class="lm ln it ks b kt lw kw lx kz ly ld lz lh ma ll om ls lt lu bi translated">找不到用户时返回错误</li><li id="5ffa" class="lm ln it ks b kt lw kw lx kz ly ld lz lh ma ll om ls lt lu bi translated">出现意外错误时返回错误</li></ol><p id="abe7" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated"><code class="fe nt nu nv nw b">authIn</code>代码如下:</p><figure class="ki kj kk kl gt km gh gi paragraph-image"><div role="button" tabindex="0" class="ng nh di ni bf nj"><div class="gh gi oo"><img src="../Images/11d0563768d9cb45a261fb5e078da045.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ZteQT-EJ6beLwOalKpnT4Q.png"/></div></div></figure><p id="2fdb" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated"><code class="fe nt nu nv nw b">authOut</code>代码如下:</p><figure class="ki kj kk kl gt km gh gi paragraph-image"><div role="button" tabindex="0" class="ng nh di ni bf nj"><div class="gh gi oo"><img src="../Images/2a7610d5018b0f878658feefe856c90c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*t49o_jALC35a2hRpTObpJg.png"/></div></div></figure></div><div class="ab cl mb mc hx md" role="separator"><span class="me bw bk mf mg mh"/><span class="me bw bk mf mg mh"/><span class="me bw bk mf mg"/></div><div class="im in io ip iq"><h1 id="3cdf" class="mi mj it bd mk ml mm mn mo mp mq mr ms jz mt ka mu kc mv kd mw kf mx kg my mz bi translated">结论</h1><p id="a59f" class="pw-post-body-paragraph kq kr it ks b kt na ju kv kw nb jx ky kz nc lb lc ld nd lf lg lh ne lj lk ll im bi translated">在本文中，我解释了如何使用Jest和NestJS框架测试后端服务。这段代码最有趣的特性是，我们可以使用spies来隔离我们的测试，我们可以创建一个输入和输出表来自动化许多相同但使用不同参数的测试。</p><p id="bc8e" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">在下一篇文章中，我将向您展示如何对控制器进行单元测试。</p><ul class=""><li id="3c64" class="lm ln it ks b kt ku kw kx kz lo ld lp lh lq ll lr ls lt lu bi translated">GitHub项目是<a class="ae lv" href="https://github.com/Caballerog/clock-in-out" rel="noopener ugc nofollow" target="_blank">https://github.com/Caballerog/clock-in-out</a>。</li><li id="6edf" class="lm ln it ks b kt lw kw lx kz ly ld lz lh ma ll lr ls lt lu bi translated">GitHub分支是<a class="ae lv" href="https://github.com/Caballerog/clock-in-out/tree/part9-backend-unit-test" rel="noopener ugc nofollow" target="_blank">https://GitHub . com/Caballerog/clock-in-out/tree/part 9-back end-unit-test</a>。</li></ul></div></div>    
</body>
</html>