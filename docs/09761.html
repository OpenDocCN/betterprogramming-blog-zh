<html>
<head>
<title>Understanding Method Swizzling in Obj-C</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">理解Obj-C中的Swizzling方法</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/method-swizzling-in-obj-c-b85d37f99ce4?source=collection_archive---------12-----------------------#2021-10-06">https://betterprogramming.pub/method-swizzling-in-obj-c-b85d37f99ce4?source=collection_archive---------12-----------------------#2021-10-06</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="5762" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">什么是“方法切换”,什么时候应该使用该功能</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/1e7af0bc520d96d0dcf9babfbce5a918.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*eWND7E5VzC5IHu1o.jpg"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">照片由来自Unsplash的Belinda Fewings提供</p></figure><p id="efbc" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">当我开始在遗留的iOS应用程序上工作时，我首先遇到的事情之一就是“方法切换”。</p><p id="aeb6" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">Swizzling允许开发人员改变一个预先存在的方法的底层实现，而不必改变原来的实现。实际上，您可以用一种方法替换另一种方法。如果JavaScript开发人员曾经做过猴子补丁，他们可能对这个概念很熟悉。</p><p id="675f" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">如果您从基类继承，大多数现代面向对象和静态类型的语言都有重写现有方法的方法。这有时被称为多态性。但是如果你想改变原来的实现而不改变基类中原来的底层代码呢？</p><p id="0d6e" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">你可以在大多数苹果语言中使用swizzling方法来做到这一点。您可能会问自己，如果您有需要更改的方法的原始代码，为什么要这样做？主要原因是，如果你正在使用一个你不能改变或者没有权限改变的库，你至少可以在运行时使用swizzling来改变一个方法的行为。</p><h1 id="516e" class="lu lv it bd lw lx ly lz ma mb mc md me jz mf ka mg kc mh kd mi kf mj kg mk ml bi translated">Objective-C运行时</h1><p id="f9d8" class="pw-post-body-paragraph ky kz it la b lb mm ju ld le mn jx lg lh mo lj lk ll mp ln lo lp mq lr ls lt im bi translated">Objective-C的运行时为在应用程序运行时执行操作提供了一些很好的工具。您可以使用选择器来创建对Objective-C中方法签名的引用，然后使用这些选择器来操作运行时。</p><p id="dc1a" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">在下面的例子中，我们有一个类，它有一个我们需要改变的方法。我们将调用这个类<code class="fe mr ms mt mu b">TaxCalculator</code>和我们想要调用的方法<code class="fe mr ms mt mu b">whatAreMyTaxes</code>:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mv mw l"/></div></figure><p id="d205" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">现在我们将创建一个Objective-C类别，它类似于Swift中的一个扩展，为我们的<code class="fe mr ms mt mu b">TaxCalculator</code>类添加一个新方法:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mv mw l"/></div></figure><p id="b465" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">这个类别增加了一个叫做<code class="fe mr ms mt mu b">swizzle_whatAreMyTaxes</code>的新方法。这将是我们用来调酒的原始方法<code class="fe mr ms mt mu b">whatAreMyTaxes</code>的方法。</p><p id="38ec" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">为了让我们的应用程序使用swizzled方法，我们需要在首次加载应用程序时交换方法。我们将使用Objective-C的<code class="fe mr ms mt mu b">load</code>方法来交换我们的方法。类的<code class="fe mr ms mt mu b">load</code>方法总是在应用程序初始化时执行。我们还需要确保它只被加载一次。</p><p id="44ce" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">我们将使用Grand Central Dispatch (GCD)来确保该方法只被加载一次。实现将类似于下面的示例:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mv mw l"/></div></figure><p id="f663" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">看看上面的方法，让我们来分解一下我们为每一行做了什么。我们在<code class="fe mr ms mt mu b">load</code>方法中做的第一件事是检查<code class="fe mr ms mt mu b">self</code>是<code class="fe mr ms mt mu b">TaxCalculator</code>类的一个实例。</p><p id="9481" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">一旦我们验证了在运行时加载了正确的类，我们就创建一个将在<code class="fe mr ms mt mu b">dispatch_once</code>方法中使用的<code class="fe mr ms mt mu b">dispatch_once_t</code>令牌。这个方法有两个参数，第一个是令牌的地址，第二个是闭包或块。</p><p id="b772" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">在out <code class="fe mr ms mt mu b">dispatch_once</code>闭包中，我们通过使用<code class="fe mr ms mt mu b">Class</code>类型并调用<code class="fe mr ms mt mu b">[self class]</code>来创建对当前类的引用。然后，我们可以为原始方法和swizzled方法创建两个选择器。在Objective-C中，我们使用<code class="fe mr ms mt mu b">@selector</code>方法来获取对我们的方法签名的引用。</p><p id="32fd" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">在定义了我们的选择器之后，我们将需要获得实际的方法引用。这是我们开始使用Objective-C运行时的地方。我们将使用<code class="fe mr ms mt mu b">class_getInstanceMethod</code>方法为这两种方法创建引用。如果你正在重组类方法，有一个不同的运行时方法可以使用，叫做<code class="fe mr ms mt mu b">class_getClassMethod</code>。这两种方法都将类引用和选择器引用作为参数。</p><p id="d02b" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">现在我们有了两个方法引用，我们使用<code class="fe mr ms mt mu b">method_exchangeImplementations</code>方法来混合它们。这种方法也可以用来将它们交换回来。</p><h1 id="0385" class="lu lv it bd lw lx ly lz ma mb mc md me jz mf ka mg kc mh kd mi kf mj kg mk ml bi translated">Swizzle实用程序</h1><p id="b500" class="pw-post-body-paragraph ky kz it la b lb mm ju ld le mn jx lg lh mo lj lk ll mp ln lo lp mq lr ls lt im bi translated">我创建了一个实用程序类，您可以使用它轻松地交换实例或类方法。下面是我的<code class="fe mr ms mt mu b">SimpleSwizzleHelper</code>课:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mv mw l"/></div></figure><p id="5d75" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">使用这个助手类，我们现在可以重构我们的load方法来支持swizzling。注意<code class="fe mr ms mt mu b">SimpleSwizzleHelper</code>可以处理实例和类方法。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mv mw l"/></div></figure><div class="mx my gp gr mz na"><a href="https://github.com/davidfekke/SwizzleExample" rel="noopener  ugc nofollow" target="_blank"><div class="nb ab fo"><div class="nc ab nd cl cj ne"><h2 class="bd iu gy z fp nf fr fs ng fu fw is bi translated">GitHub-davidfekke/Swizzle Example:一个Swizzle示例</h2><div class="nh l"><h3 class="bd b gy z fp nf fr fs ng fu fw dk translated">这是我编写的一个示例项目，展示了如何使用Objective-C运行时简单地混合Obj-C方法。的…</h3></div><div class="ni l"><p class="bd b dl z fp nf fr fs ng fu fw dk translated">github.com</p></div></div><div class="nj l"><div class="nk l nl nm nn nj no ks na"/></div></div></a></div></div><div class="ab cl np nq hx nr" role="separator"><span class="ns bw bk nt nu nv"/><span class="ns bw bk nt nu nv"/><span class="ns bw bk nt nu"/></div><div class="im in io ip iq"><h1 id="5643" class="lu lv it bd lw lx nw lz ma mb nx md me jz ny ka mg kc nz kd mi kf oa kg mk ml bi translated">结论</h1><p id="ebfc" class="pw-post-body-paragraph ky kz it la b lb mm ju ld le mn jx lg lh mo lj lk ll mp ln lo lp mq lr ls lt im bi translated">方法重组是Objective-C运行时的一个非常强大的特性。使用此功能时要小心。只有当您不能直接更改底层实现时，才应该使用这种方法。</p><p id="8971" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">任何使用该特性的开发人员都应该小心地剔除那些不知道原始实现是什么的方法，也就是说，您有头文件和静态库，但无法访问原始代码。我也会避免从苹果的操作系统中删除任何系统代码。如果使用不当，这可能会造成伤害。</p><p id="6a6a" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">既然你已经读了这篇文章，祝你喝得开心！</p><h2 id="06e3" class="ob lv it bd lw oc od dn ma oe of dp me lh og oh mg ll oi oj mi lp ok ol mk om bi translated">想联系作者？</h2><p id="1376" class="pw-post-body-paragraph ky kz it la b lb mm ju ld le mn jx lg lh mo lj lk ll mp ln lo lp mq lr ls lt im bi translated">本文原载于<a class="ae on" href="https://fek.io/blog/method-swizzling-in-obj-c-and-swift/" rel="noopener ugc nofollow" target="_blank"> https://fek.io </a>。你也可以在YouTube 上查看<a class="ae on" href="https://www.youtube.com/watch?v=EubqhkP1ggw&amp;t=1s" rel="noopener ugc nofollow" target="_blank">的视频教程。</a></p></div></div>    
</body>
</html>