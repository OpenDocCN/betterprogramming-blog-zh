<html>
<head>
<title>Learn Solidity: The Factory Pattern</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">学习可靠性:工厂模式</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/learn-solidity-the-factory-pattern-75d11c3e7d29?source=collection_archive---------0-----------------------#2020-12-13">https://betterprogramming.pub/learn-solidity-the-factory-pattern-75d11c3e7d29?source=collection_archive---------0-----------------------#2020-12-13</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="1cba" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">如何在智能合约中使用工厂模式</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/de50507f629ddfcbfede71b2073b0d9c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*OgGnaHrFje6yrrR7"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">安特·罗泽茨基在<a class="ae kv" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>拍摄的照片。</p></figure><p id="bf82" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">欢迎来到学习可靠性系列的另一部分。在<a class="ae kv" href="https://medium.com/better-programming/learn-solidity-smart-contract-creation-and-inheritance-8424adac3570" rel="noopener">上一篇文章</a>中，我们讨论了如何从另一个智能合约中创建一个智能合约。今天，我们将看一下这一场景的典型使用案例。</p></div><div class="ab cl ls lt hu lu" role="separator"><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx"/></div><div class="ij ik il im in"><h1 id="66f8" class="lz ma iq bd mb mc md me mf mg mh mi mj jw mk jx ml jz mm ka mn kc mo kd mp mq bi translated">工厂模式是什么？</h1><p id="fd4f" class="pw-post-body-paragraph kw kx iq ky b kz mr jr lb lc ms ju le lf mt lh li lj mu ll lm ln mv lp lq lr ij bi translated">工厂模式的思想是拥有一个契约(工厂),它将承载创建其他契约的使命。在基于类的编程中，这种模式的主要动机来自于单责任原则(一个类不需要知道如何创建其他类的实例)，这种模式为构造函数提供了一种抽象。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi mw"><img src="../Images/d96e3d63445459b2b32c5ab9659b9706.png" data-original-src="https://miro.medium.com/v2/resize:fit:938/format:webp/1*YR3sci8LfusUJ6_zog5MPg.png"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">图片来自<a class="ae kv" href="https://en.wikipedia.org/wiki/Factory_method_pattern" rel="noopener ugc nofollow" target="_blank">维基百科</a>。</p></figure></div><div class="ab cl ls lt hu lu" role="separator"><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx"/></div><div class="ij ik il im in"><h1 id="e629" class="lz ma iq bd mb mc md me mf mg mh mi mj jw mk jx ml jz mm ka mn kc mo kd mp mq bi translated">为什么在Solidity中使用工厂模式？</h1><p id="7d4b" class="pw-post-body-paragraph kw kx iq ky b kz mr jr lb lc ms ju le lf mt lh li lj mu ll lm ln mv lp lq lr ij bi translated">在Solidity中，出于以下原因之一，您可能希望使用工厂模式:</p><ul class=""><li id="bd65" class="mx my iq ky b kz la lc ld lf mz lj na ln nb lr nc nd ne nf bi translated">如果您想要创建同一契约的多个实例，并且您正在寻找一种方法来跟踪它们并使它们的管理更容易。</li></ul><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ng nh l"/></div></figure><ul class=""><li id="2e7f" class="mx my iq ky b kz la lc ld lf mz lj na ln nb lr nc nd ne nf bi translated">节省部署时间:您可以只部署工厂，稍后使用它来部署其他合同。</li><li id="45e6" class="mx my iq ky b kz ni lc nj lf nk lj nl ln nm lr nc nd ne nf bi translated">提高合同安全性(参见<a class="ae kv" href="https://consensys.net/diligence/blog/2019/09/factories-improve-smart-contract-security/" rel="noopener ugc nofollow" target="_blank">本文</a>)。</li></ul></div><div class="ab cl ls lt hu lu" role="separator"><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx"/></div><div class="ij ik il im in"><h1 id="7ece" class="lz ma iq bd mb mc md me mf mg mh mi mj jw mk jx ml jz mm ka mn kc mo kd mp mq bi translated">如何与部署的智能合约交互</h1><p id="e1f9" class="pw-post-body-paragraph kw kx iq ky b kz mr jr lb lc ms ju le lf mt lh li lj mu ll lm ln mv lp lq lr ij bi translated">在深入讨论如何实现工厂模式的细节之前，我想先弄清楚我们与已部署的智能契约交互的方式。工厂模式是关于创建子契约的，为了更好地管理这些契约，我们可能需要调用它们的一些函数。</p><p id="0214" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">当我们想要调用已部署的智能合约时，需要两件事情:</p><ol class=""><li id="db7e" class="mx my iq ky b kz la lc ld lf mz lj na ln nb lr nn nd ne nf bi translated">协定的ABI(提供有关函数签名的信息)。如果合同在同一个项目中。您可以使用<code class="fe no np nq nr b">import</code>关键字导入它。</li><li id="ce43" class="mx my iq ky b kz ni lc nj lf nk lj nl ln nm lr nn nd ne nf bi translated">已部署协定的地址。</li></ol><p id="f867" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">让我们举个例子:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ng nh l"/></div></figure><p id="31db" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在Remix中，从部署契约B开始，然后复制它的地址，在部署的时候给A的构造函数。你现在可以调用<code class="fe no np nq nr b">callHello()</code>函数，你将得到契约b的<code class="fe no np nq nr b">sayHello()</code>函数的结果</p></div><div class="ab cl ls lt hu lu" role="separator"><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx"/></div><div class="ij ik il im in"><h1 id="5ab2" class="lz ma iq bd mb mc md me mf mg mh mi mj jw mk jx ml jz mm ka mn kc mo kd mp mq bi translated">正常工厂模式</h1><p id="84fb" class="pw-post-body-paragraph kw kx iq ky b kz mr jr lb lc ms ju le lf mt lh li lj mu ll lm ln mv lp lq lr ij bi translated">在这个模式中，我们创建一个工厂契约，其中包含一个处理子契约创建的函数，我们还可能添加其他函数来有效管理这些契约(例如，查找特定的契约或禁用契约)。在create函数中，我们使用<code class="fe no np nq nr b">new</code>关键字来部署子契约。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ng nh l"/></div></figure></div><div class="ab cl ls lt hu lu" role="separator"><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx"/></div><div class="ij ik il im in"><h1 id="fe0d" class="lz ma iq bd mb mc md me mf mg mh mi mj jw mk jx ml jz mm ka mn kc mo kd mp mq bi translated">克隆工厂模式</h1><p id="1292" class="pw-post-body-paragraph kw kx iq ky b kz mr jr lb lc ms ju le lf mt lh li lj mu ll lm ln mv lp lq lr ij bi translated">前一种模式的问题是它浪费了大量的时间，因为所有的子契约都有相同的逻辑，我们每次都重新部署几乎相同的契约——相同的代码，但不同的上下文。我们需要一种方法，只部署一个具有所有功能的子契约，并让所有其他子契约充当代理，将调用委托给我们创建的第一个子契约，并让功能在代理契约的上下文中执行。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi ns"><img src="../Images/00931d392aaa78cda6c5ce5191e36708.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*BUkhztjSfZQar_g5T0sutw.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">作者照片。</p></figure><p id="fa25" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">幸运的是，EIP-1167规范定义了如何廉价地实现代理契约。该代理将所有调用和100%的gas转发给实现契约，然后将返回值转发给调用者。根据规范代理契约的字节码是<br/> <code class="fe no np nq nr b">363d3d373d3d3d363d73bebebebebebebebebebebebebebebebebebebebe5af43d82803e903d91602b57fd5bf3</code>。索引10-29(包括10-29)处的字节被替换为主功能契约(我们将向其委托调用的契约)的20字节地址。</p><p id="dd93" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">代理合同的全部魔力都是通过使用<code class="fe no np nq nr b">delegatecall</code>完成的。你可以通过阅读这篇文章来了解它是如何工作的。</p><p id="df5a" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">现在让我们来看看如何实现这一点。首先，你需要获取这个规范的实现，你可以在<a class="ae kv" href="https://github.com/optionality/clone-factory/blob/master/contracts/CloneFactory.sol" rel="noopener ugc nofollow" target="_blank"> GitHub </a>上找到。将<code class="fe no np nq nr b">CloneFactory</code>的代码复制粘贴到您的项目中。</p><p id="740e" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们这次要用的代码如下:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ng nh l"/></div></figure><p id="6be0" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这一次，我们使用GitHub存储库中的<code class="fe no np nq nr b">createClone</code>函数来创建子契约，而不是使用<code class="fe no np nq nr b">new</code>关键字。</p><p id="040e" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">您可以通过在Truffle中创建新的迁移文件来部署合同，如下所示:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ng nh l"/></div></figure><p id="2936" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">为了测试代码是否工作，我创建了一个测试文件，您可以自己尝试，以确保一切都按预期工作:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ng nh l"/></div></figure></div><div class="ab cl ls lt hu lu" role="separator"><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx"/></div><div class="ij ik il im in"><h1 id="7a1a" class="lz ma iq bd mb mc md me mf mg mh mi mj jw mk jx ml jz mm ka mn kc mo kd mp mq bi translated">结论</h1><p id="7aa9" class="pw-post-body-paragraph kw kx iq ky b kz mr jr lb lc ms ju le lf mt lh li lj mu ll lm ln mv lp lq lr ij bi translated">本文到此为止。请继续关注智能合约开发的更多信息！</p></div></div>    
</body>
</html>