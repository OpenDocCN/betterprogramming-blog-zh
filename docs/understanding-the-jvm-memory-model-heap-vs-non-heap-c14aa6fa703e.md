# 理解 JVM 内存模型——堆与非堆

> 原文：<https://betterprogramming.pub/understanding-the-jvm-memory-model-heap-vs-non-heap-c14aa6fa703e>

## 简单明了

![](img/6711fc0ad920cc66e3b49016f63d9905.png)

内森·杜姆劳在 [Unsplash](https://unsplash.com/s/photos/java?utm_source=unsplash&utm_medium=referral&utm_content=creditCopyText) 上的照片

JVM 是一个受欢迎的概念，每个计算机科学本科生都烂熟于心。自 1994 年以来，它一直伴随着我们，尽管此后经历了几次迭代，但它仍然保持着强劲的势头。

# 为什么您应该关心 JVM 内存模型？

无论您是使用 Java、Kotlin、Scala、Groovy，甚至是 Neo4j 来构建图形数据库，都有 JVM 在幕后工作。

因此，要想在你的领域拥有更强的控制力，了解它是如何工作的是有意义的，特别是它的记忆模型是如何建立的，除非你碰巧是 OOM 错误的粉丝。

理解如何管理内存在当今尤为重要，因为我们许多人都在使用运行在内存容量有限的容器内的微服务。如果您想降低成本并保持应用程序的性能，您需要有效地管理容器的内存。

现在，您可能会问——我不是 DevOps 工程师，这与我有什么关系？
首先，我个人认为，即使在你的专业领域之外，掌握一些基本概念的工作知识总是一个好主意。它让你变得更加有用和多才多艺，有时甚至会提出创造性的想法——将看似独立的领域之间的点连接起来。其次，它允许您更好地管理您的应用程序，因为您将能够理解您的应用程序的内部工作方式，允许您发现潜在的问题，甚至是潜在的改进领域。

那么，我们还在等什么？让我们开始吧！对于 JVM 内存，一个重要的区别是内存存储在哪里，因为它影响应用程序的各个方面。

我们可以大致将 JVM 内存分为两部分:

*   堆内存
*   非堆内存

让我们从大多数人已经熟悉的东西开始——堆内存。

# JVM 堆内存

概括地说，JVM 堆由对象(和数组)组成。JVM 启动后，创建的堆有一个初始大小和它可以增长到的最大大小。例如:

```
-Xms256m // An initial heap size of 256 Megabytes
-Xmx2g // A maximum heap size of 2 Gigabytes 
```

每次创建一个新对象，JVM 都会为它分配内存，并占用这个空间，直到被垃圾收集器(也称为 GC)回收。一旦被回收，新的对象就可以重用这些内存。

值得一提的是，堆包含应用程序中创建的所有对象，而不管创建它们的线程是什么。这与线程堆栈中的变量相反，线程堆栈中的变量只能在同一线程的上下文中访问，而对其他线程不可见。

## 堆内存结构

堆本身可以分为两个主要部分:

*   年轻一代(又名托儿所)——本身分为 3 个部分——伊甸园记忆和两个幸存者记忆空间。
*   老一代人

年轻一代包含最近分配的新对象。这些新的物体在伊甸园空间开始了它们的生命。一旦 Eden 空间开始填满，就会发生小规模的 GC(GC 发生得相对更快)，幸存的对象会移动到幸存者空间。一旦幸存者空间填满，它也会经历次要 GC，如果对象在次要 GC 中存活了足够多的周期，它们就会被移到旧的代。

老一代包含的对象经历了多次小规模 GC 循环，证明了自己的价值。然而，它也可能被填满，启动一个大的 GC，这通常需要更长的时间。

这种分离背后的逻辑是，大多数新创建的对象很可能是短命的，因此这种分离允许我们执行更有效的 GC。与在单代堆上执行 GC 相比，更高效的 GC 允许我们以更快的速度释放内存，这意味着整体性能更好。

值得一提的是，以前还有另一个重要的区域，与主堆分开，称为永久代(又名 Perm/Perm Gen)。它曾经包含应用程序元数据、Java 标准库类、字符串池等等。因为 Java 8 它不存在，所以它的内容被分割在主堆(字符串池)和元空间(应用程序元数据)之间。

# JVM 非堆内存

简而言之，非堆内存是不属于堆空间的任何东西。简单吧？嗯，如果*和*一样简单，你就不需要为此写文章了。

# 非堆内存结构

非堆内存(也称为本机内存/堆外内存)由几个区域组成:

*   元空间
*   线程内存(堆栈内存)
*   代码缓存
*   垃圾收集器数据

# 元空间

这位[佩尔姆根的](https://www.javatpoint.com/permgen-space-java)继任者。Java 8 中引入。
元空间占据了 JVM 非堆内存的很大一部分。它的主要目的是存储类元数据 Java 类的内部运行时表示。

默认情况下，元空间由两部分组成——类空间和非类空间。

## 课堂空间

也称为压缩类空间，因为使用了[压缩类指针](https://stuefe.de/posts/metaspace/what-is-compressed-class-space/)。此空间包含与类相关的元数据:

*   [“Klass”结构](https://openjdk.java.net/groups/hotspot/docs/StorageManagement.html) —包含一个类的内部运行时表示
*   [Vtable](https://wiki.openjdk.java.net/display/HotSpot/VirtualCalls)—包含该类拥有的每个虚拟方法的元数据的表。(在 Java 中，所有可重写的方法都是虚拟的)。
*   `Itable` —类似于 Vtable，除了它引用继承的接口方法。
*   OOP map—存储类的对象引用数据成员位置的结构。(以便在堆垃圾收集时更新它们的内存引用)。

## 非课堂空间

这个空间包含了其他一切:

*   [常量池](https://www.baeldung.com/jvm-constant-pool) —类似于符号表的构造。包含使 JVM 能够运行类代码的常数。
*   方法元数据——类中方法的内部表示——相当于运行时的 [method_info](https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-4.html#jvms-4.6) 结构。包括方法字节码、异常表等。
*   方法计数器—用于 JIT 编译器优化
*   注释元数据
*   还有更多。

值得一提的是，如果前面提到的[压缩类指针](https://stuefe.de/posts/metaspace/what-is-compressed-class-space/)被禁用，所有内存将存储在一个全局元空间上下文中，并且没有压缩类空间。

## 内存管理

元空间中的数据分配与类装入器紧密耦合。
当类装入器装入一个类时，它在元空间中为它的元数据分配内存。该内存归类装入器所有，只有当类装入器卸载时才被释放。

元空间的内存由三个标志控制:

*   `-XX:MaxMetaspaceSize` *—* 控制可提交的最大内存—包括类空间和非类空间。默认情况下，这个大小实际上是无限的(最大 64 位整数)。默认情况下，元空间动态增长，但不会超过上述限制。
*   `-XX:MetaspaceSize` *—* 控制 GC 的内存阈值。当超过这个阈值时，将触发 GC。为了避免频繁的 GC 循环，建议高于默认大小(12–20mb，具体取决于平台)，对于大规模应用程序来说，默认大小通常太小。
*   `-XX:CompressedClassSpaceSize` *—* 控制为类空间预留的内存。正如我上面提到的，如果压缩的类指针被禁用，那么类&非类空间之间没有分隔，所以这个限制将被忽略。

## Metaspace 与 PermGen

元空间和 PermGen 之间有几个主要区别:

*   它位于堆外，作为操作系统提供的本机内存的一部分，而 Permgen 存在于堆内(尽管与主堆分离)
*   它在运行时动态调整大小——而 Permgen 有一个固定的最大大小(尽管两者都有与大小相关的配置标志)。这是对经常出现的“Java . lang . out of memory error:PermGen”问题的一种急需的补救措施，该问题是由于 perm gen 的默认大小较小，无法很好地扩展而导致的。
*   它具有更高效的 GC——当类元数据使用达到其最大值时自动触发，而 Permgen 具有固定的配置大小，这会触发频繁的高成本 GC 操作。

# 线程内存——又名堆栈内存

在 JVM 环境中运行的每个线程都有自己的内存——自己的堆栈。顾名思义，内存被组织成一个 LIFO 数据结构，这意味着新的数据被添加到顶部并首先被访问。

堆栈包含线程调用的没有完成执行的每个方法，包括这些方法中的每个局部变量。如果局部变量是一个原语——它完全存储在堆栈中(因此它们对其他线程是不可见的)。如果它是一个对象—只存储它的引用，它的实际值存储在堆上。

堆栈内存更常见的问题之一是 StackOverflow 错误，当调用堆栈使用的内存多于分配给它的内存时，就会发生这种错误。一般是递归调用太多/无限导致的。

## 关于线程/堆栈内存的要点:

*   一旦方法执行完毕，内存分配和释放会自动发生。
*   与堆内存相比，内存处理速度更快。
*   在堆栈中分配的内存只能在线程的上下文中访问，这样更安全——没有其他线程可以访问它。而堆内存是全局的，可能会被任何线程访问。
*   与堆内存相比，内存容量往往要小得多。

# 代码缓存

基于 JVM 的应用程序通过一个三步过程来执行。

1.  它们从各自的语言(Java、Kotlin、Groovy 等)编译成字节码。
2.  JVM 解释器然后获取编译后的字节码，并将其解释成机器码。
3.  为了获得性能提升， [JIT 编译器](https://en.wikipedia.org/wiki/Just-in-time_compilation)在运行时执行额外的优化。

所有这些优化的机器代码都需要存储在某个地方。这就是代码缓存发挥作用的地方。JVM 使用代码缓存来存储程序执行所需的所有已编译的字节码。

从 Java 9 开始，为了提高性能，代码缓存被分成三个部分。(通过改进引用的局部性—相似的代码段存储在附近的内存位置以便更好地访问)。
每个片段包含特定类型的编译代码:

*   内部 JVM 代码(编译器缓冲区、字节码解释器)——在整个应用程序的生命周期中倾向于留在代码缓存中。它的大小由`-XX:NonMethodCodeHeapSize`标志控制，通常固定在 3-5mb 左右。
*   轻度分析的代码—包含经过基本分析的轻度优化的方法(由 JIT C1 编译器提供)。这里的方法往往寿命较短。它的大小由
    标志控制。
*   非概要代码—包含完全优化的代码(由 JIT C2 编译器提供)。由于这里的方法经历了密集的优化，它们往往有更长的生命周期。这个区域的大小由
    `-XX:NonProfiledCodeHeapSize` 标志控制。

## 有几个问题

*   代码缓存具有固定的大小。这意味着当它变满时，JIT 编译器将有效地停止优化代码，这意味着我们的应用程序的性能将受到影响。幸运的是，我们有一些有用的标志可以用来降低这种风险。特别是 *ReservedCodeCacheSize* 用于增加最大大小(默认为 48MB，通常太小)，以及`UseCodeCacheFlushing` 用于在满足特定条件时刷新代码缓存)
*   当使用[分层编译](https://www.baeldung.com/jvm-tiered-compilation)(从 Java 7 开始可用)时，代码缓存变得更加重要，因为编译的代码量显著增加(2–4 倍)。然而，这种增加自然会影响代码缓存本身的大小，如果不加控制，它可能会填满并实际降低应用程序的性能。

# 垃圾收集器数据

这可能并不完全令人惊讶，但是为了完成它的工作，垃圾收集器本身需要将数据保存在内存中。

因为它的主要工作是清理堆，所以它自己的数据必须存储在堆外，因此它也是非堆区域的一部分。

垃圾收集器可以使用许多不同的算法来完成它的工作。这些算法中的每一个都使用数据结构，有时甚至使用多线程来完成它的工作。这些都占用了 JVM 的非堆区域的内存。然而，值得一提的是，所使用的内存量没有上面的星球大战迷因所保证的那么引人注目，所以通常不用担心。

# 我们今天学到了什么

这一次的旅程相当漫长。我们讨论了堆、它的组成部分以及它的操作方式。我们还讨论了非堆区域，它由相当多有趣的区域组成，最著名的是元空间。
我们甚至讨论了使我们能够调整各种内存区域以获得更好性能的关键标志。

因此，下次当您发现自己在 Grafana(或您最喜欢的应用程序监控仪表板)中查看应用程序的指标时，请记住这篇文章。它可能只是帮助您找到一个生产错误，甚至提高您的应用程序的性能！