<html>
<head>
<title>Reactive Programming With React and RxJs</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">用React和RxJs进行反应式编程</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/reactive-programming-with-react-and-rxjs-88d2789e408a?source=collection_archive---------3-----------------------#2021-06-30">https://betterprogramming.pub/reactive-programming-with-react-and-rxjs-88d2789e408a?source=collection_archive---------3-----------------------#2021-06-30</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="0b34" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">减少依赖性，增强模块化，鼓励共享公共逻辑，并提高可测试性</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/ce2405d03f0a3302ec03334b27e94367.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*HxwSwyIoTt04mPodtOZZ2w.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">图片由作者提供。</p></figure><p id="d387" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">反应式编程正在成为前端开发的流行范例。在本文中，我们旨在重温这一概念背后的关键思想，看看它可以应用于反应的方式，以及它可以带来哪些好处。</p><p id="92fb" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">采用反应式编程和带有React的<a class="ae lu" href="https://rxjs.dev/" rel="noopener ugc nofollow" target="_blank"> RxJs </a>可以帮助减少依赖性，增强模块化，鼓励应用程序之间共享公共逻辑，并提高可测试性。</p><p id="c910" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">和React一起，我们将只使用RxJs，JavaScript/TypeScript的反应式扩展。不需要其他外部依赖。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="35ac" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">反应式编程:基本思想</h1><blockquote class="mu"><p id="27ab" class="mv mw it bd mx my mz na nb nc nd lt dk translated">“反应式编程是一种与<strong class="ak">数据流</strong>和<strong class="ak">变化传播相关的<strong class="ak">声明式</strong>编程范例。</strong>——<a class="ae lu" href="https://en.wikipedia.org/wiki/Reactive_programming" rel="noopener ugc nofollow" target="_blank">维基百科</a></p></blockquote><p id="de29" class="pw-post-body-paragraph ky kz it la b lb ne ju ld le nf jx lg lh ng lj lk ll nh ln lo lp ni lr ls lt im bi translated">这个定义背后的基本思想是，对于反应式编程，应用程序逻辑是基于数据流的，数据流是一段时间内的事件序列。每个事件都可以带来数据。</p><p id="a8af" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">我们的程序预先声明它们对哪些流感兴趣，如何转换它们，以及当某些事件发生时如何反应和改变应用程序的状态。一旦这个意向声明完成，应用程序就可以实际启动了。应用程序中的所有内容都将来自我们声明中的事件流。我们可以说，应用程序只是随着时间的推移自动展开，将事件流转化为所需的行为。</p><p id="014d" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">在本文的其余部分，我们将看到一种在React应用程序中实现这些概念的方法，使用简单的示例来使这些概念具体化。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="0b38" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">React应用分层:组件和服务</h1><p id="711c" class="pw-post-body-paragraph ky kz it la b lb nj ju ld le nk jx lg lh nl lj lk ll nm ln lo lp nn lr ls lt im bi translated">我们用React实现的反应式编程从两层组织应用开始:组件层和服务层。</p><h2 id="7beb" class="no md it bd me np nq dn mi nr ns dp mm lh nt nu mo ll nv nw mq lp nx ny ms nz bi translated">组件层</h2><p id="719a" class="pw-post-body-paragraph ky kz it la b lb nj ju ld le nk jx lg lh nl lj lk ll nm ln lo lp nn lr ls lt im bi translated">根据这种设计，React组件负责几个明确的任务:</p><ul class=""><li id="a5a9" class="oa ob it la b lb lc le lf lh oc ll od lp oe lt of og oh oi bi translated">UI的呈现部分——这种呈现发生在应用程序开始时，或者作为对从外部世界接收的事件 <em class="oj">的<em class="oj">反应(例如，当由于调用外部API而接收到一些新数据时)。</em></em></li><li id="4100" class="oa ob it la b lb ok le ol lh om ll on lp oo lt of og oh oi bi translated">处理用户交互——拦截用户交互，并根据逻辑决定将哪个<em class="oj">命令</em>发送给外界。该组件不执行该命令。它只是发送它。</li></ul><p id="4a47" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">如果一个React组件——至少使用这种方法——只有<em class="oj">对事件</em>做出 <em class="oj">反应，并发送<em class="oj">命令</em>，那么我们需要<em class="oj">其他东西</em>来生成这样的事件并执行这样的命令。我们称之为服务。</em></p><h2 id="b12e" class="no md it bd me np nq dn mi nr ns dp mm lh nt nu mo ll nv nw mq lp nx ny ms nz bi translated">服务层</h2><p id="956d" class="pw-post-body-paragraph ky kz it la b lb nj ju ld le nk jx lg lh nl lj lk ll nm ln lo lp nn lr ls lt im bi translated">服务是一个类的实例，它代表组件或其他服务执行<em class="oj">命令</em>，并生成组件可以<em class="oj">对其做出</em>反应的<em class="oj">事件</em>。</p><p id="0790" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">为了履行这样的职责，服务为客户端公开API，可以采取两种形式:</p><ul class=""><li id="0bcf" class="oa ob it la b lb lc le lf lh oc ll od lp oe lt of og oh oi bi translated">当客户端想要执行一个<em class="oj">命令</em>时可以调用的公共方法。</li><li id="6677" class="oa ob it la b lb ok le ol lh om ll on lp oo lt of og oh oi bi translated">如果客户端希望<em class="oj">对</em> <strong class="la iu"> <em class="oj"> </em> </strong>事件做出反应，它可以订阅事件流。这样的流被实现为RxJs <code class="fe op oq or os b">Observables</code>。</li></ul><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ot"><img src="../Images/1c059bd4dc36f058617c372be354290e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*_frdA1FaNTuJPIm_4r4Ogw.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">服务公开和客户端组件使用的API</p></figure><p id="865f" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">如果我们严格遵守这些职责，React组件最终在逻辑上非常简单，而大部分工作由服务执行。稍后我们将对此进行详细阐述。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="ff26" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">组件和服务交互</h1><p id="15f4" class="pw-post-body-paragraph ky kz it la b lb nj ju ld le nk jx lg lh nl lj lk ll nm ln lo lp nn lr ls lt im bi translated">但是这个机制是如何更详细地工作的呢？让我们考虑一些典型的例子。</p><h2 id="dcf9" class="no md it bd me np nq dn mi nr ns dp mm lh nt nu mo ll nv nw mq lp nx ny ms nz bi translated">组件和远程服务之间的交互</h2><p id="ab4e" class="pw-post-body-paragraph ky kz it la b lb nj ju ld le nk jx lg lh nl lj lk ll nm ln lo lp nn lr ls lt im bi translated">让我们考虑一个仅由两个组件组成的简单应用程序:<code class="fe op oq or os b">MyComponent</code>和<code class="fe op oq or os b">AnotherComponent</code>。点击<code class="fe op oq or os b">MyComponent</code>的“调用远程API”按钮，调用远程服务。这样调用返回的数据应该由<code class="fe op oq or os b">AnotherComponent</code>显示。</p><p id="5c10" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">为了以一种被动的方式完成这一行为，我们可以创建一个服务(<code class="fe op oq or os b">MyService</code>)并组织应用程序各个部分的交互，如下所示:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ou"><img src="../Images/06838d021f30c98983c6198b766a30a2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*aQFzKNO9FJjejBgjiaVOeQ.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">远程端点调用的反应式实现</p></figure><ul class=""><li id="904d" class="oa ob it la b lb lc le lf lh oc ll od lp oe lt of og oh oi bi translated">app启动时，<code class="fe op oq or os b">MyService</code> <em class="oj"> </em>被实例化。因此，创建了<code class="fe op oq or os b">remoteData$</code> <em class="oj"> </em>流(一个<code class="fe op oq or os b">MyService</code>的实例变量)。</li><li id="f86b" class="oa ob it la b lb ok le ol lh om ll on lp oo lt of og oh oi bi translated"><code class="fe op oq or os b">AnotherComponent</code>订阅<code class="fe op oq or os b">remoteData$</code>并指定一旦接收到事件就在哪里显示数据。这是我们的应用程序的声明部分(即，我们告诉我们的程序我们对哪些事件流感兴趣，以及当这些事件流上发生事件时，应用程序必须如何做出反应)。应用程序的行为是这种声明的结果。</li><li id="6c6a" class="oa ob it la b lb ok le ol lh om ll on lp oo lt of og oh oi bi translated">当点击“调用远程API”时，通过调用<code class="fe op oq or os b">MyService</code> <em class="oj">的<code class="fe op oq or os b">callRemoteAPI</code>方法向<code class="fe op oq or os b">MyService</code>发送命令。</em></li><li id="9667" class="oa ob it la b lb ok le ol lh om ll on lp oo lt of og oh oi bi translated"><code class="fe op oq or os b">callRemoteAPI</code>方法<em class="oj"> </em>执行命令<em class="oj"> </em>调用远程端点。</li><li id="199f" class="oa ob it la b lb ok le ol lh om ll on lp oo lt of og oh oi bi translated">一旦<code class="fe op oq or os b">MyService</code>收到响应，它就会在<code class="fe op oq or os b">remoteData$</code>流上生成一个新事件，并将收到的数据作为响应。</li><li id="ce53" class="oa ob it la b lb ok le ol lh om ll on lp oo lt of og oh oi bi translated">订阅了<code class="fe op oq or os b">remoteData$</code> <em class="oj"> </em>流的<code class="fe op oq or os b">AnotherComponent</code>被通知新事件，并通过在UI上呈现数据来对事件做出反应。</li></ul><h2 id="643e" class="no md it bd me np nq dn mi nr ns dp mm lh nt nu mo ll nv nw mq lp nx ny ms nz bi translated">一个组件与另一个组件的交互</h2><p id="8854" class="pw-post-body-paragraph ky kz it la b lb nj ju ld le nk jx lg lh nl lj lk ll nm ln lo lp nn lr ls lt im bi translated">现在让我们考虑用户点击<code class="fe op oq or os b">MyComponent</code> <em class="oj">的“复位”按钮的情况。</em>在这种情况下，我们希望<code class="fe op oq or os b">AnotherComponent</code> <em class="oj"> </em>清除由于调用远程端点而显示的任何数据。</p><p id="0bda" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">在这种情况下，交互描述如下:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ov"><img src="../Images/5e4b231a2653c47100595bd48ac46f63.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*a8hayINlWTGmMrFv_ojj0A.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">两个组件之间交互的反应式实现</p></figure><ul class=""><li id="4924" class="oa ob it la b lb lc le lf lh oc ll od lp oe lt of og oh oi bi translated">在应用程序开始时，会创建<code class="fe op oq or os b">MyService</code>和<code class="fe op oq or os b">reset$</code>流。</li><li id="4075" class="oa ob it la b lb ok le ol lh om ll on lp oo lt of og oh oi bi translated"><code class="fe op oq or os b">AnotherComponent</code>订阅<code class="fe op oq or os b">reset$</code>流，并指定当它在该流上收到通知时，它将通过删除它可能已经呈现的任何数据来做出反应。</li><li id="6c0b" class="oa ob it la b lb ok le ol lh om ll on lp oo lt of og oh oi bi translated">点击“复位”后，<em class="oj"> </em> <code class="fe op oq or os b">MyComponent</code> <em class="oj"> </em>通过调用<em class="oj"> </em>的<code class="fe op oq or os b">reset</code> API方法<em class="oj">向<em class="oj"> </em> <code class="fe op oq or os b">MyService</code> <em class="oj"> </em>发送命令。</em></li><li id="7a7d" class="oa ob it la b lb ok le ol lh om ll on lp oo lt of og oh oi bi translated">这种方法在<code class="fe op oq or os b">reset$</code> <em class="oj"> </em>流<em class="oj">上生成一个新事件。</em></li><li id="cb8b" class="oa ob it la b lb ok le ol lh om ll on lp oo lt of og oh oi bi translated"><code class="fe op oq or os b">AnotherComponent</code>通过清除它可能已经呈现的任何数据来对其做出反应。</li></ul></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="e507" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">如何编码</h1><p id="e19b" class="pw-post-body-paragraph ky kz it la b lb nj ju ld le nk jx lg lh nl lj lk ll nm ln lo lp nn lr ls lt im bi translated">现在，这种反应式编程的方法已经通过它的基本原理进行了说明，我们可以更具体地看一下实现上面显示的两个基本交互的代码。</p><h2 id="7a0e" class="no md it bd me np nq dn mi nr ns dp mm lh nt nu mo ll nv nw mq lp nx ny ms nz bi translated"><em class="ow"> MyService </em></h2><p id="6497" class="pw-post-body-paragraph ky kz it la b lb nj ju ld le nk jx lg lh nl lj lk ll nm ln lo lp nn lr ls lt im bi translated">首先要做的是编码<code class="fe op oq or os b">MyService</code>。正如我们已经看到的，<code class="fe op oq or os b">MyService</code>提供了作为API的:</p><ul class=""><li id="2d9d" class="oa ob it la b lb lc le lf lh oc ll od lp oe lt of og oh oi bi translated">两种方法:<code class="fe op oq or os b">callRemoteAPI</code>和<code class="fe op oq or os b">reset</code></li><li id="eb0f" class="oa ob it la b lb ok le ol lh om ll on lp oo lt of og oh oi bi translated">两个流:<code class="fe op oq or os b">remoteData$</code>和<code class="fe op oq or os b">reset$</code></li></ul><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ox oy l"/></div></figure><p id="5482" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">我们来推理一下<code class="fe op oq or os b">callRemoteAPI</code>。首先，它从调用<code class="fe op oq or os b">REST</code>端点返回的<code class="fe op oq or os b">Promise</code>中创建一个RxJs <code class="fe op oq or os b">Observable</code>。然后，它使用<code class="fe op oq or os b">tap</code>操作符通过<code class="fe op oq or os b">next</code>方法通知<code class="fe op oq or os b">_remoteData$</code>主题上的新事件。<code class="fe op oq or os b">_remoteData$</code>是私人的。我们不想公开它，因为只有<code class="fe op oq or os b">MyService</code>可以在它上面生成事件。我们想要公开的是一个纯<code class="fe op oq or os b">Observable</code>流，这是通过使用<code class="fe op oq or os b">asObservable</code>方法从<code class="fe op oq or os b">_remoteData$</code>获得的<code class="fe op oq or os b">remoteData$</code>流来完成的。</p><p id="3208" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">我们刚刚描述的是在服务提供的API中经常遇到的一种模式:API方法完成工作(在这种情况下，它是远程端点的调用，但也可以是其他任何东西),然后在作为<code class="fe op oq or os b">Observable</code> API公开的主题上发出一个事件。客户端执行调用服务的API方法的命令，并通过订阅由服务公开为API的公共<code class="fe op oq or os b">Observable</code>来对事件做出反应。</p><h2 id="8382" class="no md it bd me np nq dn mi nr ns dp mm lh nt nu mo ll nv nw mq lp nx ny ms nz bi translated">提供服务的上下文挂钩</h2><p id="ac35" class="pw-post-body-paragraph ky kz it la b lb nj ju ld le nk jx lg lh nl lj lk ll nm ln lo lp nn lr ls lt im bi translated"><code class="fe op oq or os b">MyService</code>是一个类，但是我们的组件需要的是这个类的一个共享实例，这样它们就可以共享相同的<code class="fe op oq or os b">Observable</code>流在它们之间进行通信。</p><p id="d54f" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">React <code class="fe op oq or os b">context</code>钩子提供了一种简洁的方式。<code class="fe op oq or os b">context</code>钩子允许你定义一个默认值，这就是我们在这里利用的。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ox oy l"/></div></figure><p id="05ca" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">一旦我们以这种方式将<code class="fe op oq or os b">MyService</code>实例定义为<code class="fe op oq or os b">MyServiceContext</code>的默认值，任何需要访问服务实例的组件只需通过<code class="fe op oq or os b">useContext</code> API获得<code class="fe op oq or os b">MyServiceContext</code>。</p><p id="bc39" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">同时，React <code class="fe op oq or os b">context</code>的使用使得在需要时用不同的实现覆盖<code class="fe op oq or os b">MyService</code>变得非常容易。</p><h2 id="7aeb" class="no md it bd me np nq dn mi nr ns dp mm lh nt nu mo ll nv nw mq lp nx ny ms nz bi translated">控制呈现的状态挂钩</h2><p id="daa2" class="pw-post-body-paragraph ky kz it la b lb nj ju ld le nk jx lg lh nl lj lk ll nm ln lo lp nn lr ls lt im bi translated">如果我们看看前面定义的例子中的<code class="fe op oq or os b">AnotherComponent</code>,我们会看到它根据以下逻辑控制渲染:</p><ul class=""><li id="a6f0" class="oa ob it la b lb lc le lf lh oc ll od lp oe lt of og oh oi bi translated">当从远程端点获取的数据到达时，显示这些数据。</li><li id="1670" class="oa ob it la b lb ok le ol lh om ll on lp oo lt of og oh oi bi translated">如果引发了<code class="fe op oq or os b">reset</code>事件，则清理UI。</li></ul><p id="9e09" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">为了控制渲染，<code class="fe op oq or os b">AnotherComponent</code>使用<code class="fe op oq or os b">state</code>钩子定义了一些状态。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ox oy l"/></div></figure><h2 id="5b6c" class="no md it bd me np nq dn mi nr ns dp mm lh nt nu mo ll nv nw mq lp nx ny ms nz bi translated">效果挂钩订阅和取消订阅可观察的流</h2><p id="9454" class="pw-post-body-paragraph ky kz it la b lb nj ju ld le nk jx lg lh nl lj lk ll nm ln lo lp nn lr ls lt im bi translated">现在的问题是<code class="fe op oq or os b">AnotherComponent</code>如何以及在哪里订阅<code class="fe op oq or os b">MyService</code>提供的流媒体。</p><p id="325f" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">当组件想要对事件做出反应时，它们订阅API流。对事件的反应通常意味着一些副作用，如组件状态的改变或在使用路由器的情况下导航到其他页面。这就是<code class="fe op oq or os b">AnotherComponent</code>的情况，它需要订阅由<code class="fe op oq or os b">MyService</code> ( <code class="fe op oq or os b">remoteData$</code>和<code class="fe op oq or os b">reset$</code>)提供的两个流，并在每种情况下做出适当的反应。首先，从事件接收的数据被传递给触发UI呈现的<code class="fe op oq or os b">setData</code>方法。对于第二种情况，不需要数据。触发<code class="fe op oq or os b">setData("")</code>清理UI的只是事件的通知。</p><p id="c0eb" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">在functional React中，<code class="fe op oq or os b">effect</code>钩子是专门用于运行副作用的地方，所以这是我们放置订阅逻辑的地方。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ox oy l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">为AnotherComponent.tsx实现useEffect</p></figure><p id="46a6" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">正如我们从代码中看到的，<code class="fe op oq or os b">remoteData$</code>和<code class="fe op oq or os b">reset$</code>流都使用了<code class="fe op oq or os b">tap</code>操作符来驱动副作用(在这种情况下，按照RxJs的建议，是组件状态的改变)。</p><p id="5bdc" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">使用返回一个<code class="fe op oq or os b">subscription</code>的<code class="fe op oq or os b">merge</code>函数同时订阅两个流。有了RxJs，一旦不再使用<code class="fe op oq or os b">Observables</code>就要退订，这一点很重要。这由<code class="fe op oq or os b">useEffect</code>返回的函数保证。对于React <code class="fe op oq or os b">useEffect</code> API的定义，返回的函数在组件被卸载时运行。我们返回的函数执行<code class="fe op oq or os b">unsubscribe</code>，这就是我们在这种情况下要做的事情。</p><p id="68ff" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">这个简单例子的完整实现可以在GitHub 上找到。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="bb62" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">经验法则</h1><p id="241e" class="pw-post-body-paragraph ky kz it la b lb nj ju ld le nk jx lg lh nl lj lk ll nm ln lo lp nn lr ls lt im bi translated">我们可以用几条经验法则来总结我们使用React进行反应式编程的方法:</p><ul class=""><li id="8376" class="oa ob it la b lb lc le lf lh oc ll od lp oe lt of og oh oi bi translated">组件中的订阅逻辑应该仅限于副作用，例如更改状态以触发重新呈现或导航到其他页面。因此，在组件的订阅逻辑中出现除了<code class="fe op oq or os b">tap</code>之外的任何操作符都应该是可疑的，我们应该质疑是否可以将它移到服务层。</li><li id="6c89" class="oa ob it la b lb ok le ol lh om ll on lp oo lt of og oh oi bi translated">由于上述原因，所有的流转换逻辑都应该局限于服务。</li><li id="a515" class="oa ob it la b lb ok le ol lh om ll on lp oo lt of og oh oi bi translated">组件中用户交互的处理应该非常简单，仅限于使用相关输入调用服务的API方法。</li></ul></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="2e04" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">轻组件和丰富的服务</h1><p id="6c98" class="pw-post-body-paragraph ky kz it la b lb nj ju ld le nk jx lg lh nl lj lk ll nm ln lo lp nn lr ls lt im bi translated">如果我们遵循这种方法，组件仍然非常轻——至少尽可能轻。他们专注于处理用户交互和渲染。任何需要的计算和逻辑都应该在服务中实现。</p><p id="000e" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">另一方面，服务是普通的JavaScript/TypeScript类，不依赖于任何React库，可以包含丰富的逻辑和代码。我们看到的例子都是基本的，目的是关注设计原则。但是在真实的例子中，由服务实现的API方法和流转换可能非常复杂——至少是所需的复杂程度。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="cc1c" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">用RxJs应用反应式编程的好处</h1><p id="fa41" class="pw-post-body-paragraph ky kz it la b lb nj ju ld le nk jx lg lh nl lj lk ll nm ln lo lp nn lr ls lt im bi translated">下面列出了采用这种方法的主要好处。</p><h2 id="6343" class="no md it bd me np nq dn mi nr ns dp mm lh nt nu mo ll nv nw mq lp nx ny ms nz bi translated">减少依赖性的轻量级状态管理</h2><p id="522d" class="pw-post-body-paragraph ky kz it la b lb nj ju ld le nk jx lg lh nl lj lk ll nm ln lo lp nn lr ls lt im bi translated">这是一个轻量级的状态管理实现。这是一个状态管理实现，因为服务实际上可以被视为一个存储应用程序状态的网络。它是轻量级的，因为它只需要RxJs作为依赖项，没有主要的样板文件。</p><h2 id="fddd" class="no md it bd me np nq dn mi nr ns dp mm lh nt nu mo ll nv nw mq lp nx ny ms nz bi translated">增强组件的模块化</h2><p id="61b4" class="pw-post-body-paragraph ky kz it la b lb nj ju ld le nk jx lg lh nl lj lk ll nm ln lo lp nn lr ls lt im bi translated">组件依赖于它们使用的服务，而不是它们所在的嵌套结构。适当传播可以用订阅来代替。对于深度嵌套的应用程序，这会导致代码的极大简化。</p><h2 id="faa6" class="no md it bd me np nq dn mi nr ns dp mm lh nt nu mo ll nv nw mq lp nx ny ms nz bi translated">共享库</h2><p id="21d4" class="pw-post-body-paragraph ky kz it la b lb nj ju ld le nk jx lg lh nl lj lk ll nm ln lo lp nn lr ls lt im bi translated">如果我们将所有的逻辑移到服务层，让组件来管理渲染和用户交互，那么在组件之间共享逻辑就变得更容易了，因为不同的组件可以共享相同的服务。甚至可以想象共享库只包含与一些后端集成的服务。不同的前端可以使用这样的库，它们必须与相同的后端进行交互。</p><h2 id="954d" class="no md it bd me np nq dn mi nr ns dp mm lh nt nu mo ll nv nw mq lp nx ny ms nz bi translated">可测试性(最后但绝对不是最不重要的)</h2><p id="8c8c" class="pw-post-body-paragraph ky kz it la b lb nj ju ld le nk jx lg lh nl lj lk ll nm ln lo lp nn lr ls lt im bi translated">服务包含了绝大部分的逻辑。服务是纯JavaScript/TypeScript类。因此，它们可以作为普通的JavaScript/TypeScript类进行测试，而不需要测试ui所涉及的所有额外的复杂性。我们甚至可以在纯JavaScript测试中模拟用户交互。该测试可以模拟整个用户旅程，并通过订阅相关的<code class="fe op oq or os b">Observable</code>流来检查预期的结果。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="0d3f" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">结论</h1><p id="ea65" class="pw-post-body-paragraph ky kz it la b lb nj ju ld le nk jx lg lh nl lj lk ll nm ln lo lp nn lr ls lt im bi translated">我们已经用React和RxJs展示了一种实现反应式编程原则的方法。我们试图用非常基本的例子来阐明设计原则。我们还强调了这种方法的主要优势。</p><p id="49cc" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">在后续文章中，我们计划展示如何将相同的原则成功地应用于更复杂和现实的应用场景。</p></div></div>    
</body>
</html>