<html>
<head>
<title>Lightweight and Type-Safe Localisation in React</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">React中轻量级和类型安全的本地化</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/lightweight-and-type-safe-localisation-in-react-493b2609c282?source=collection_archive---------20-----------------------#2022-04-04">https://betterprogramming.pub/lightweight-and-type-safe-localisation-in-react-493b2609c282?source=collection_archive---------20-----------------------#2022-04-04</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="b15f" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">使用React上下文API和钩子</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/05f0446fa5e8f71a181c8c8c617cb567.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*-lDIay_OlMEFSKYGkxnXdQ.jpeg"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">图片由<a class="ae kv" href="https://unsplash.com/@ratushny" rel="noopener ugc nofollow" target="_blank"> Dmitry Ratushny </a>从<a class="ae kv" href="https://unsplash.com/photos/wpi3sDUrSEk" rel="noopener ugc nofollow" target="_blank"> unsplash </a>拍摄</p></figure><p id="fcb9" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">本地化(或多语言支持)是几乎所有生产就绪应用的核心部分。大多数情况下，保持所有翻译最新是一项耗时的任务，如果您需要在编写代码时保持翻译最新，甚至可能会停止您的编码流程。</p><p id="e69b" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在我的经验中，我经常在引用一个丢失的语言键时遇到语言文件中的错别字和未翻译的字符串。我观察到混合键或添加重复键太容易了。</p><p id="a8e6" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">因此，我为React实现了一个轻量级、类型安全的本地化。它使用React上下文API和钩子来简化功能组件内部的使用，并使用Typescript强制转换和键查找是类型安全的。如果您感兴趣，让我们深入研究一下实现吧！</p><h1 id="7295" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">在上下文中实现本地化</h1><p id="29f9" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">首先，让我们看看用户选择的当前地区的实际商店。我决定将这些信息保存在React上下文中，因为它应该可以在整个应用程序中访问，并且在当前语言环境中预期的更改较少，所以不用担心性能问题。</p><p id="ec4d" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">所选的语言环境保存在Localstorage中，并在上下文首次装载时加载，以保存用户的决定。如果无法从Localstorage中加载任何语言环境，则使用默认语言环境(在我的例子中主要是英语)。在Localstorage中，只存储<code class="fe mp mq mr ms b">localeId </code>(如en_US)而不是整个语言环境。</p><p id="be6a" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">上下文文件导出一个<code class="fe mp mq mr ms b">Provider </code>,我们将它放在整个示例应用程序中。在这个上下文中，我提供了可用的语言环境、当前语言环境和一个函数，用于设置要在组件中访问的当前语言环境。</p><p id="f79a" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">为了将<code class="fe mp mq mr ms b">LocaleContextProvider</code>注入到React组件树中的任何位置，<code class="fe mp mq mr ms b">props.children</code>被简单地设置为React子组件，因此被传递。整个上下文显示在以下要点中:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mt mu l"/></div></figure><p id="f3dc" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这就是上下文方面，现在让我们切换到语言资源。</p><h1 id="d1d3" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">语言文件</h1><p id="b344" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">作为语言文件，我们使用<code class="fe mp mq mr ms b">simple.ts</code>文件，它导出一个包含查找关键字及其翻译的JS对象。对于每个语言环境，都会添加一个导出特定翻译对象的文件。对于输入性能，我体验到如果所有的lang键都以一个前缀开始，例如lang，那么自动补全会显著提高。这对我来说效果很好，很容易区分翻译和其他变量。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mt mu l"/></div></figure><h2 id="9f94" class="mv lt iq bd lu mw mx dn ly my mz dp mc lf na nb me lj nc nd mg ln ne nf mi ng bi translated">添加类型安全</h2><p id="4000" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">因为我将JS对象用于我们的翻译映射，所以实现可以受益于通过Typescript启用类型检查。为了避免创建包含完成翻译所需的所有键的专用类型(相信我，我这样做了，这很烦人……)，我使用<code class="fe mp mq mr ms b">typeof</code>操作符来获取我们默认的英语翻译的类型，并强制所有其他翻译具有相同的类型。</p><p id="9758" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在这种情况下，这意味着默认翻译的所有键都需要在另一个翻译中可用。因此，这会导致正确的语法突出显示，并为丢失或错误的翻译键生成错误。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mt mu l"/></div></figure><h2 id="3c98" class="mv lt iq bd lu mw mx dn ly my mz dp mc lf na nb me lj nc nd mg ln ne nf mi ng bi translated">在应用中的使用</h2><p id="a626" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">实现翻译和本地化后，最后一步是在我们的应用程序中包含翻译。因此，我定义了一些有用的钩子，可以用在每个组件中(在<code class="fe mp mq mr ms b">LocaleContext</code>的组件树内部)。以下钩子在我的默认实现中可用，并且可以很容易地扩展:</p><ul class=""><li id="2011" class="nh ni iq ky b kz la lc ld lf nj lj nk ln nl lr nm nn no np bi translated"><code class="fe mp mq mr ms b">useLanguage</code>:返回当前地区的翻译对象</li><li id="2252" class="nh ni iq ky b kz nq lc nr lf ns lj nt ln nu lr nm nn no np bi translated"><code class="fe mp mq mr ms b">useLocales</code>:返回可用的语言环境</li><li id="ffc4" class="nh ni iq ky b kz nq lc nr lf ns lj nt ln nu lr nm nn no np bi translated"><code class="fe mp mq mr ms b">useSetLocale</code>:返回一个设置新语言环境的函数</li></ul><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mt mu l"/></div></figure><p id="c345" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在下面的例子中，描述了所有这三个钩子的用法。通过一个按钮点击，应用程序遍历所有可用的语言环境，并相应地更改当前的语言环境。翻译可以在任何jsx或其他函数逻辑中用作string类型的普通变量。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mt mu l"/></div></figure><p id="c0c8" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这里是使用Typescript的主要线索:您不能在语言键中做任何打字错误，因为翻译是键入的，只允许访问现有的键，并且所有的翻译都需要完整，所以没有半生不熟的翻译可用。</p><h1 id="feb0" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">摘要</h1><p id="977c" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">在这个故事中，我想分享我用React上下文和钩子实现的轻量级、类型安全的本地化。该实现允许轻松使用翻译后的字符串，强制完成翻译(否则typescript会责怪您)，并消除了使用翻译时输入错误的可能性。即使翻译的设置看起来相对复杂，但它的好处对我来说相当不错。</p><p id="c6cd" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">整个代码可在<a class="ae kv" href="https://stackblitz.com/edit/react-starter-typescript-b7m7ct?file=App.tsx" rel="noopener ugc nofollow" target="_blank"> stackblitz </a>上获得。</p><p id="9948" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我希望您喜欢我在<br/> React中对本地化方法的小小探索。</p><p id="2663" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">请随时分享任何反馈，我会很感激，并相应地更新故事。</p></div></div>    
</body>
</html>