# 开始使用您的第一份智能合同

> 原文：<https://betterprogramming.pub/get-started-with-your-first-smart-contract-de2b54261d65>

## 什么是智能合约，我们如何使用以太坊的可靠性来编写它们？

![](img/9a5e1ed01c4d0685e6ce30672ead05b0.png)

照片由来自 [Pexels](https://www.pexels.com/photo/round-gold-colored-ethereum-ornament-730552/?utm_content=attributionCopyText&utm_medium=referral&utm_source=pexels) 的[大卫·麦克比](https://www.pexels.com/@davidmcbee?utm_content=attributionCopyText&utm_medium=referral&utm_source=pexels)拍摄。

*先决条件:这篇文章的目标读者是那些有初级到中级编程经验的人，他们知道以太坊和智能合约，但是不知道从哪里开始。到最后，你应该能够理解和写简单的智能合同。*

把比特币钱包想象成一个你可以完全控制的银行账户。每个钱包在区块链上都有地址*。*如果你拥有私钥(它就像一个无法破解的密码)，你就可以把那个钱包里的比特币发送到任何其他地址*。*

以太坊也不例外。如果你有一个以太钱包，它有一个地址，如果你有私钥，你可以发送以太到另一个地址。

# 智能合约呢？

智能合约和其他钱包一样有一个地址。它们也可以像其他钱包一样装东西。就底层账本而言，它是一个钱包。

这是一个有规则的钱包。

代码控制着钱包，而不是人通过 Metamask 或 Exodus 这样的接口来控制钱包。你决定从你的钱包里把 ETH 发送到哪里，智能合约根据它们的规则自动做出这些决定，而无需人类的交互。一旦部署，这些规则对于该地址是不可变的。

不可变意味着一旦这些规则被部署，它们就永远不能被改变。

这些规则用代码定义，并用一种叫做 Solidity 的语言编写，这种语言是由 [Vitalik Buterin](https://vitalik.ca/) 和[以太坊基金会](https://ethereum.org/)创建的。任何人都可以制定一些规则，编写代码，并以智能合约的形式部署到以太坊区块链。

# 制定规则

如果你熟悉面向对象的编程语言，可以把 Solidity smart contract 想象成一个类。

像任何其他语言一样，Solidity 有一系列数据类型，包括:

*   布尔运算
*   整数
*   用线串
*   地址
*   定点数
*   数组

访问修饰符定义了谁和什么可以访问变量和函数:

*   公共
*   私人的
*   内部的
*   外部的

智能协定可以有状态和局部变量、构造函数和函数。

至关重要的是，Solidity 允许任何合同使用全局可用的变量来访问区块链信息(如特定地址有多少 ETH)。这些对于执行基于规则的安全操作至关重要，例如将 ETH 发送到其他地址。

因此，如果智能合约是一个有规则的钱包，让我们以此为例。让我们创建一个简单的钱包契约，它可以保存、发送和接收 ETH。

图 1: MyWallet.sol

让我们从上到下，然后检查我们是否满足我们为钱包设定的所有标准。

## 定义坚实度版本

用`pragma solidity …`定义 solidity 编译器版本。我们这里用的是`0.6.0`。

## 定义合同名称

```
contract MyWallet {
```

## 所有者状态变量

我们需要追踪这个钱包的主人。这存储在一个名为`owner`的状态变量中，我们在契约中定义了这个变量，但是不包含在任何函数中。这意味着所有函数都可以访问存储在这个变量中的值。

它具有`private`可见性，意味着只有该契约中的函数可以访问它。它存储`address payable`类型的数据。`payable`表示本合同可以向其发送以太。

## 构造函数

`constructor()`在区块链上创建合同时执行。这个函数中唯一的一行是存储部署者的地址。我们已经知道每个智能合约都有一个地址，但是它们必须使用现有的地址进行部署。

这是我们第一次看到全局变量的用法。`msg.sender`表示部署者的地址(执行此功能的人/钱包/智能契约)。

任何地址都可以部署智能合约或调用智能合约中的任何功能，无论是人控钱包还是另一个智能合约。

在这一点上，有两个地址在起作用:部署者地址(`msg.sender`)和这个契约被部署到的地址(在我们研究代码时会有更多的介绍)。

## 接受乙醚

为了让这个契约能够从发送给它的地址接收 ETH，它需要一个`receive()`函数。这是 Solidity 中定义的一个特殊功能，任何希望接收 ETH 的合同都必须实现该功能。它必须有访问修饰符`external`以便外部地址可以访问它，并且它必须是`payable`，这意味着它可以接收 ETH(很像我们的所有者可以接收 ETH，因此也是可支付的)。

## 发送乙醚

最后一个函数叫做`sendEther()`。这有助于所有者将 ETH 从这个钱包合同发送到另一个地址。它有两个参数:发送 ETH 的地址和发送的数量。

注意在这个函数的开始有两个`require`语句。这些确保了在函数继续之前某些标准为真。如果任何要求失败，事务将完全恢复。

第一个要求:

```
require(msg.sender == owner, "...");
```

这确保了调用该函数的地址是钱包的所有者。我们不希望任何不是所有者的人能够将 ETH 发送给其他人。应该只有所有者能够做到这一点。

第二个要求:

```
require(address(this).balance >= _amount, "...");
```

这确保了钱包契约有足够的 ETH 来发送。它不能转让超过它拥有的。

这是使用全局可访问变量来查询该合同的 ETH 数量的另一个示例。`address(this)`获取该智能合约部署到的地址，然后`.balance`返回该地址拥有的 ETH 数量。只要它大于或等于函数想要发送的数量(`_amount`，那么我们就可以继续！

最后，该函数使用`_to.transfer(_amount);`将 ETH 发送到目标地址。

# 它做了我们想要的吗？

我们需要一个智能契约，它可以充当钱包，可以容纳、发送和接收电子邮件。我们知道可以使用`receive()`函数接收并保存它，也可以使用`sendEther()`函数将 ETH 发送到其他地址。此外，只有该契约的所有者可以调用`sendEther()`，使其安全。

它确实做到了我们想要的！

就钱包而言，这是非常原始的，并不能满足我们对钱包的期望。

# 现在轮到你了

使用这段代码，尝试添加一些功能。首先，添加一个返回钱包余额的函数。

如果你认为你已经实现了一些很酷的新特性，请在评论中添加你的代码。

要了解智能合约的用途，请阅读下一篇解释如何创建 ERC20 令牌的文章:

[](https://medium.com/better-programming/what-are-smart-contracts-used-for-2583af2c62bc) [## 智能合约有什么用途？

### 智能合约如何用于创建令牌

medium.com](https://medium.com/better-programming/what-are-smart-contracts-used-for-2583af2c62bc) 

# 进一步阅读

如果你对区块链开发感兴趣，我会写一些教程、演练、提示以及如何开始和建立投资组合的技巧。

查看以下资源:

[](https://medium.com/blockcentric/blockchain-development-resources-b44b752f3248) [## 区块链开发资源马上跟进

### 学习区块链、以太坊和 DApp 开发的资源列表

medium.com](https://medium.com/blockcentric/blockchain-development-resources-b44b752f3248)