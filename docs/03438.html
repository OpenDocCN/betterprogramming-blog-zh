<html>
<head>
<title>Continuously Build Node.js Docker Images Using GitHub Actions</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用GitHub操作不断构建Node.js Docker映像</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/continuously-build-node-js-docker-images-using-github-actions-1e58df9c9faa?source=collection_archive---------11-----------------------#2020-02-10">https://betterprogramming.pub/continuously-build-node-js-docker-images-using-github-actions-1e58df9c9faa?source=collection_archive---------11-----------------------#2020-02-10</a></blockquote><div><div class="fc ii ij ik il im"/><div class="in io ip iq ir"><div class=""/><div class=""><h2 id="3d62" class="pw-subtitle-paragraph jr it iu bd b js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki dk translated">向您的节点应用程序添加配置项</h2></div><figure class="kk kl km kn gu ko gi gj paragraph-image"><div role="button" tabindex="0" class="kp kq di kr bf ks"><div class="gi gj kj"><img src="../Images/e33d56cfe7b6fa11aa956f5782c1b4a3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*5CeTuJgRBVHf7AHb-7uIoA.jpeg"/></div></div><p class="kv kw gk gi gj kx ky bd b be z dk translated">雅各布·欧文斯在<a class="ae kz" href="https://unsplash.com/s/photos/action?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的照片</p></figure><p id="cb22" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">来自GitHub的伟大人们为他们的服务添加了新的东西——<em class="lw">GitHub Actions</em>。截至<a class="ae kz" href="https://github.blog/changelog/2019-11-11-github-actions-is-generally-available" rel="noopener ugc nofollow" target="_blank">2019年11月11日</a>，GitHub Actions面向所有人开放。当从公共库使用时，它是免费的。</p><p id="1e04" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">您可以使用GitHub操作来自动化各种软件开发任务。作为开发人员，您创建了一个YAML工作流文件。GitHub将文件存储在您的存储库中，并执行工作流。</p><p id="35d9" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">为了编辑工作流文件，GitHub创建了一个<a class="ae kz" href="https://github.blog/2019-10-01-new-workflow-editor-for-github-actions/" rel="noopener ugc nofollow" target="_blank">工作流编辑器</a>。相反，我更喜欢使用我的普通编辑器，Visual Studio代码。我添加了一个<a class="ae kz" href="https://github.com/formulahendry/vscode-github-actions" rel="noopener ugc nofollow" target="_blank">扩展</a>来帮助编辑。</p><p id="a794" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">我开始使用GitHub Actions构建<a class="ae kz" href="https://github.com/PatrickKalkman/MiniVideoEncoder" rel="noopener ugc nofollow" target="_blank">迷你视频编码器</a>，这是我的副业。当我提交一个变更时，它首先构建并测试项目。如果成功，该操作将创建Docker映像并将其推送到Docker Hub。</p><p id="ef4d" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">在本文中，我描述了如何创建GitHub动作来构建、测试和推送Node.js项目的Docker映像。如果您对最终的工作流文件感兴趣，可以随意查看我的<a class="ae kz" href="https://github.com/PatrickKalkman/MiniVideoEncoder/blob/master/.github/workflows/workflowengine.yml" rel="noopener ugc nofollow" target="_blank"> GitHub资源库</a>中的文件。</p></div><div class="ab cl lx ly hy lz" role="separator"><span class="ma bw bk mb mc md"/><span class="ma bw bk mb mc md"/><span class="ma bw bk mb mc"/></div><div class="in io ip iq ir"><h1 id="7beb" class="me mf iu bd mg mh mi mj mk ml mm mn mo ka mp kb mq kd mr ke ms kg mt kh mu mv bi translated">构建、测试和推送Docker映像的步骤</h1><p id="ea74" class="pw-post-body-paragraph la lb iu lc b ld mw jv lf lg mx jy li lj my ll lm ln mz lp lq lr na lt lu lv in bi translated">要构建、测试和推送我的Node.js项目的Docker映像，GitHub操作必须执行以下步骤:</p><ol class=""><li id="3784" class="nb nc iu lc b ld le lg lh lj nd ln ne lr nf lv ng nh ni nj bi translated">查看迷你视频编码器库。</li><li id="75aa" class="nb nc iu lc b ld nk lg nl lj nm ln nn lr no lv ng nh ni nj bi translated">从版本文件中读取当前版本。</li><li id="da76" class="nb nc iu lc b ld nk lg nl lj nm ln nn lr no lv ng nh ni nj bi translated">使用<a class="ae kz" href="https://semver.org/" rel="noopener ugc nofollow" target="_blank">语义版本化</a>增加版本。</li><li id="bbb6" class="nb nc iu lc b ld nk lg nl lj nm ln nn lr no lv ng nh ni nj bi translated">将新版本号写入版本文件。</li><li id="66e5" class="nb nc iu lc b ld nk lg nl lj nm ln nn lr no lv ng nh ni nj bi translated">构建、标记和发布Docker图像。</li><li id="a05c" class="nb nc iu lc b ld nk lg nl lj nm ln nn lr no lv ng nh ni nj bi translated">提交版本文件。</li><li id="766d" class="nb nc iu lc b ld nk lg nl lj nm ln nn lr no lv ng nh ni nj bi translated">发送一条宽限消息，通知您新版本已经发布。</li></ol><p id="1eb1" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">我将把每个步骤翻译成工作流YAML文件中的一个部分，并对其进行解释。</p></div><div class="ab cl lx ly hy lz" role="separator"><span class="ma bw bk mb mc md"/><span class="ma bw bk mb mc md"/><span class="ma bw bk mb mc"/></div><div class="in io ip iq ir"><h1 id="f0e4" class="me mf iu bd mg mh mi mj mk ml mm mn mo ka mp kb mq kd mr ke ms kg mt kh mu mv bi translated">定义工作流文件</h1><p id="c9db" class="pw-post-body-paragraph la lb iu lc b ld mw jv lf lg mx jy li lj my ll lm ln mz lp lq lr na lt lu lv in bi translated">每个工作流文件都以操作的名称开头。GitHub在动作概览中显示了这个名字。</p><figure class="kk kl km kn gu ko"><div class="bz fq l di"><div class="np nq l"/></div><p class="kv kw gk gi gj kx ky bd b be z dk translated">GitHub动作工作流文件定义的开始</p></figure><p id="46df" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">第二行下面的语句定义了何时触发工作流。我用两种类型。第一个开始于我提交到存储库的时候。第二个让我在一个特定的时间<code class="fe nr ns nt nu b">schedule</code>触发这个过程。</p><p id="3c8d" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">该计划使用与Linux cron作业相同的语法。我总是努力记住每个部分的意思。对我来说幸运的是，<a class="ae kz" href="https://cronitor.io/" rel="noopener ugc nofollow" target="_blank"> Cronitor </a>创造了一个叫做<a class="ae kz" href="https://crontab.guru/#0_1_*_*_*" rel="noopener ugc nofollow" target="_blank"> crontab.guru </a>的工具来帮助我。字符串<code class="fe nr ns nt nu b">'0 1 * * *'</code>表示我想在每晚01:00触发动作。</p><h2 id="88cb" class="nv mf iu bd mg nw nx dn mk ny nz dp mo lj oa ob mq ln oc od ms lr oe of mu og bi translated">1.查看迷你视频编码器库</h2><p id="aba0" class="pw-post-body-paragraph la lb iu lc b ld mw jv lf lg mx jy li lj my ll lm ln mz lp lq lr na lt lu lv in bi translated">工作流程的第一步是在执行动作的机器上检出迷你视频编码器存储库。</p><figure class="kk kl km kn gu ko"><div class="bz fq l di"><div class="np nq l"/></div><p class="kv kw gk gi gj kx ky bd b be z dk translated">从资源库中签出源代码</p></figure><p id="5fe7" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">您必须使用<code class="fe nr ns nt nu b">runs-on</code>标签来定义您希望动作在哪个平台上运行。我用的是Ubuntu。如果你需要另一个平台，他们是可用的。您也可以使用Windows Server或Mac OS。</p><p id="53ae" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">在<code class="fe nr ns nt nu b">steps:</code>下面，你要定义你工作流程的所有阶段。第一步是下载主分支的<code class="fe nr ns nt nu b">action/checkout@master</code>。几乎总是，一个动作的第一步是检出存储库。</p><h2 id="1a21" class="nv mf iu bd mg nw nx dn mk ny nz dp mo lj oa ob mq ln oc od ms lr oe of mu og bi translated">2.从版本文件中读取当前版本</h2><p id="56d0" class="pw-post-body-paragraph la lb iu lc b ld mw jv lf lg mx jy li lj my ll lm ln mz lp lq lr na lt lu lv in bi translated">我使用一个名为<code class="fe nr ns nt nu b">VERSION</code>的文件来存储项目的版本。在第二步中，我从这个文件中读取版本。</p><figure class="kk kl km kn gu ko"><div class="bz fq l di"><div class="np nq l"/></div><p class="kv kw gk gi gj kx ky bd b be z dk translated">使用read_properties操作读取版本文件</p></figure><p id="f932" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">Christian Draeger创造了一个伟大的GitHub动作，我一直在使用它。动作<code class="fe nr ns nt nu b">christian-draeger/read-properties</code>读取在<code class="fe nr ns nt nu b">VERSION</code>文件中定义的键值对的值。</p><p id="62f8" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">该版本在变量<code class="fe nr ns nt nu b">steps.read_property.outputs.value</code>中可用。在最后一行，我打印了变量，这样它在<a class="ae kz" href="https://github.com/PatrickKalkman/MiniVideoEncoder/runs/433032036?check_suite_focus=true" rel="noopener ugc nofollow" target="_blank">构建日志</a>中就可见了。</p><h2 id="0436" class="nv mf iu bd mg nw nx dn mk ny nz dp mo lj oa ob mq ln oc od ms lr oe of mu og bi translated">3.使用语义版本化增加版本</h2><p id="d01c" class="pw-post-body-paragraph la lb iu lc b ld mw jv lf lg mx jy li lj my ll lm ln mz lp lq lr na lt lu lv in bi translated">当我向存储库推送变更时，我想自动增加版本。根据<a class="ae kz" href="https://semver.org/" rel="noopener ugc nofollow" target="_blank">语义版本方案</a>增加版本号。</p><figure class="kk kl km kn gu ko"><div class="bz fq l di"><div class="np nq l"/></div><p class="kv kw gk gi gj kx ky bd b be z dk translated">使用增量语义版本操作自动增加版本号</p></figure><p id="105c" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">对我来说幸运的是，Christian Draeger创建了另一个名为<code class="fe nr ns nt nu b"><a class="ae kz" href="https://github.com/christian-draeger/increment-semantic-version" rel="noopener ugc nofollow" target="_blank">christian-draeger/increment-semantic-version</a></code>的优秀动作，它根据语义版本规则更新版本号。</p><p id="9ce9" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">在第5行，我将变量<code class="fe nr ns nt nu b">current-version</code>赋给变量<code class="fe nr ns nt nu b">steps.read_property.output.value</code>。记住，在前面的步骤中，它在<code class="fe nr ns nt nu b">steps.read_property.output.value</code>变量中读取并存储了版本号。</p><p id="24dc" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">通过第6行的<code class="fe nr ns nt nu b">version-fragment</code>,您向操作指出您想要更新版本号的哪一部分。我用<code class="fe nr ns nt nu b">'bug'</code>增加版本号的<a class="ae kz" href="https://semver.org/" rel="noopener ugc nofollow" target="_blank">补丁</a>。其他选项参见动作的<a class="ae kz" href="https://github.com/christian-draeger/increment-semantic-version" rel="noopener ugc nofollow" target="_blank">文档</a>。</p><h2 id="dc93" class="nv mf iu bd mg nw nx dn mk ny nz dp mo lj oa ob mq ln oc od ms lr oe of mu og bi translated">4.将新版本号写入版本文件</h2><p id="b3eb" class="pw-post-body-paragraph la lb iu lc b ld mw jv lf lg mx jy li lj my ll lm ln mz lp lq lr na lt lu lv in bi translated">我使用<code class="fe nr ns nt nu b">write-properties</code>动作将更新的版本号存储在<code class="fe nr ns nt nu b">VERSION</code>文件中。</p><p id="2bfb" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">我无法获得<code class="fe nr ns nt nu b">write-properties</code>动作来更新文件中的版本号。相反，我首先删除<code class="fe nr ns nt nu b">VERSION</code>文件，并用包含新版本号的新文件替换它。</p><figure class="kk kl km kn gu ko"><div class="bz fq l di"><div class="np nq l"/></div><p class="kv kw gk gi gj kx ky bd b be z dk translated">使用write-properties操作将更新的版本号写入版本文件</p></figure><h2 id="57d2" class="nv mf iu bd mg nw nx dn mk ny nz dp mo lj oa ob mq ln oc od ms lr oe of mu og bi translated">5.构建、标记和发布新的Docker图像</h2><p id="020b" class="pw-post-body-paragraph la lb iu lc b ld mw jv lf lg mx jy li lj my ll lm ln mz lp lq lr na lt lu lv in bi translated">存储库中的<code class="fe nr ns nt nu b">WorkflowEngine</code>文件夹包含用于构建工作流引擎的Docker映像的<code class="fe nr ns nt nu b">Dockerfile</code>。</p><figure class="kk kl km kn gu ko"><div class="bz fq l di"><div class="np nq l"/></div><p class="kv kw gk gi gj kx ky bd b be z dk translated">构建、标记Docker映像并将其发布到Docker Hub</p></figure><p id="632c" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">Lars Elgohr创建了动作<code class="fe nr ns nt nu b"><a class="ae kz" href="https://github.com/elgohr/Publish-Docker-Github-Action" rel="noopener ugc nofollow" target="_blank">elgohr/Publish-Docker-Github-Action</a></code>,该动作构建、标记并向Docker Hub发布Docker图像。</p><p id="2b87" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">您必须为动作提供Docker Hub存储库的名称，<code class="fe nr ns nt nu b">pkalkman/mve-workflowengine</code>。在第9行，我使用带有更新版本号的变量来标记Docker图像。</p><p id="216e" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">为了能够将您的图像上传到Docker Hub，您必须使用用户名和密码字段提供您的凭证。</p><p id="0028" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">如果需要使用敏感信息，就不得不使用GitHub Secrets。GitHub秘密是特定于存储库的。它们可以通过<em class="lw">设置</em>和<em class="lw">机密</em>选项卡创建。</p><p id="a6b6" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">创建后，您可以在工作流定义文件中使用它们。</p><figure class="kk kl km kn gu ko gi gj paragraph-image"><div role="button" tabindex="0" class="kp kq di kr bf ks"><div class="gi gj oh"><img src="../Images/705b640a5d22ee5c43d8aec1c927db14.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Ob-zr_6yitj2vgb0lFXjWQ.jpeg"/></div></div><p class="kv kw gk gi gj kx ky bd b be z dk translated">通过GitHub在您的存储库中创建秘密</p></figure><h2 id="e118" class="nv mf iu bd mg nw nx dn mk ny nz dp mo lj oa ob mq ln oc od ms lr oe of mu og bi translated">6.提交版本文件</h2><p id="9866" class="pw-post-body-paragraph la lb iu lc b ld mw jv lf lg mx jy li lj my ll lm ln mz lp lq lr na lt lu lv in bi translated">在步骤3和4中，版本号被更新并保存在<code class="fe nr ns nt nu b">VERSION</code>文件中。我们仍然需要提交这个变更并将其推送到存储库。</p><figure class="kk kl km kn gu ko"><div class="bz fq l di"><div class="np nq l"/></div><p class="kv kw gk gi gj kx ky bd b be z dk translated">使用git-commit操作提交和推送Git更改</p></figure><p id="060b" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">Matheus Albino创造了一个动作来提交和推动你的改变。您必须指定一个<code class="fe nr ns nt nu b">github-token</code>,以便动作可以与存储库交互。我再次使用一个秘密。</p><p id="ea49" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated"><code class="fe nr ns nt nu b">message</code>字段允许您设置提交消息。我在消息中使用更新的版本号。有关更多选项，如指定执行提交的用户，请参见<a class="ae kz" href="https://github.com/matheusalbino/git-commit" rel="noopener ugc nofollow" target="_blank">操作</a>的文档。</p><h2 id="87ee" class="nv mf iu bd mg nw nx dn mk ny nz dp mo lj oa ob mq ln oc od ms lr oe of mu og bi translated">7.发送一条宽限消息，通知新版本已发布</h2><p id="c2f1" class="pw-post-body-paragraph la lb iu lc b ld mw jv lf lg mx jy li lj my ll lm ln mz lp lq lr na lt lu lv in bi translated">工作流文件的最后一步向松弛通道发送消息，通知有新版本可用。</p><figure class="kk kl km kn gu ko"><div class="bz fq l di"><div class="np nq l"/></div><p class="kv kw gk gi gj kx ky bd b be z dk translated">使用action-slack-notify操作发送时差消息</p></figure><p id="ab15" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">我用的动作<code class="fe nr ns nt nu b"><a class="ae kz" href="https://github.com/marketplace/actions/slack-notify" rel="noopener ugc nofollow" target="_blank">rtCamp/action-slack-notify@v2.0</a></code>。RtCamp创建了这个动作来发送一个关于Slack的消息。</p><p id="cce5" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">您必须创建一个<a class="ae kz" href="https://api.slack.com/tutorials/slack-apps-hello-world" rel="noopener ugc nofollow" target="_blank"> Slack webhook </a>来允许动作使用您的Slack通道。你必须在<code class="fe nr ns nt nu b">SLACK_WEBHOOK</code>字段中设置它。我为此使用了一个秘密。</p><p id="b78c" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">如果操作成功完成，它会在Slack通道中生成以下消息。</p><figure class="kk kl km kn gu ko gi gj paragraph-image"><div role="button" tabindex="0" class="kp kq di kr bf ks"><div class="gi gj oh"><img src="../Images/8485372371f3087bec06c0bd4d37cfac.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*sFUIOnKBQ_EEbGcIMLFMCw.jpeg"/></div></div><p class="kv kw gk gi gj kx ky bd b be z dk translated">操作“时差-通知”生成的时差消息</p></figure></div><div class="ab cl lx ly hy lz" role="separator"><span class="ma bw bk mb mc md"/><span class="ma bw bk mb mc md"/><span class="ma bw bk mb mc"/></div><div class="in io ip iq ir"><h1 id="ee3b" class="me mf iu bd mg mh mi mj mk ml mm mn mo ka mp kb mq kd mr ke ms kg mt kh mu mv bi translated">结论和开源的力量</h1><p id="2487" class="pw-post-body-paragraph la lb iu lc b ld mw jv lf lg mx jy li lj my ll lm ln mz lp lq lr na lt lu lv in bi translated">我很喜欢GitHub动作。我发现将现有的动作结合起来创建一个复杂的工作流非常容易。在撰写本文时，市场中已经有<a class="ae kz" href="https://github.com/marketplace?type=actions" rel="noopener ugc nofollow" target="_blank"> 2118个动作</a>。</p><p id="f0cd" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">如果你想看完整的工作流程，我邀请你看看我的<a class="ae kz" href="https://github.com/PatrickKalkman/MiniVideoEncoder/blob/master/.github/workflows/workflowengine.yml" rel="noopener ugc nofollow" target="_blank"> GitHub仓库中的文件。</a></p><p id="b80c" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">我要感谢克里斯蒂安·德雷格尔、马修斯·阿尔比诺、拉尔斯·埃尔戈尔、杰西·塔拉贝拉-格林伯格和rtCamp，感谢他们为我的工作流程提供了所有出色的操作。</p><p id="5ea2" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">感谢您的阅读。如果你已经使用或者计划使用GitHub Actions，请告诉我。我很感兴趣。另外，如果你对这篇文章有任何问题或评论，请随时回复。</p></div></div>    
</body>
</html>