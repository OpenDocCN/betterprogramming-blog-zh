<html>
<head>
<title>Angular Lifecycle Hooks: A Complete Guide</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">角度生命周期挂钩:完全指南</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/angular-lifecycle-hooks-a-complete-guide-3040e3c93f97?source=collection_archive---------6-----------------------#2022-02-09">https://betterprogramming.pub/angular-lifecycle-hooks-a-complete-guide-3040e3c93f97?source=collection_archive---------6-----------------------#2022-02-09</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="748f" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">我们将深入挖掘每个生命周期挂钩，看看它们是如何在Angular中使用的</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/34c401c773a1a173f29b0c0ba8e3b685.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*5W2alFqHtstrXkXI"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">照片由<a class="ae ky" href="https://unsplash.com/@nate_dumlao?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">内森·杜姆劳</a>在<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</p></figure><p id="3c18" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在Angular中，组件实例的生命周期始于Angular实例化组件类并呈现组件视图及其子视图。生命周期继续变化检测，Angular检测数据绑定属性的变化，并根据需要更新视图和组件实例。当Angular销毁组件实例并从DOM中删除其呈现的模板时，生命周期就完成了。</p><p id="09db" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">指令的生命周期与实例相似，Angular在执行过程中会创建、更新和销毁实例。</p><p id="86c6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">Angular应用程序可以使用生命周期挂钩方法来拦截组件或指令生命周期中的关键事件，以便初始化新的实例，在必要时启动更改检测，在更改检测期间响应更新，并在删除实例之前进行清理。</p><p id="521e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">Angular按以下顺序调用这些挂钩方法:</p><ol class=""><li id="ceb8" class="lv lw it lb b lc ld lf lg li lx lm ly lq lz lu ma mb mc md bi translated"><code class="fe me mf mg mh b">ngOnChanges</code>:当输入/输出绑定值改变时</li><li id="d343" class="lv lw it lb b lc mi lf mj li mk lm ml lq mm lu ma mb mc md bi translated"><code class="fe me mf mg mh b">ngOnInit</code>:先<code class="fe me mf mg mh b">ngOnChanges</code>后</li><li id="89d4" class="lv lw it lb b lc mi lf mj li mk lm ml lq mm lu ma mb mc md bi translated"><code class="fe me mf mg mh b">ngDoCheck</code>:开发者自定义变更检测</li><li id="fb75" class="lv lw it lb b lc mi lf mj li mk lm ml lq mm lu ma mb mc md bi translated"><code class="fe me mf mg mh b">ngAfterContentInit</code>:组件内容初始化后</li><li id="fc51" class="lv lw it lb b lc mi lf mj li mk lm ml lq mm lu ma mb mc md bi translated"><code class="fe me mf mg mh b">ngAfterContentChecked</code>:每次检查成分含量后</li><li id="94ae" class="lv lw it lb b lc mi lf mj li mk lm ml lq mm lu ma mb mc md bi translated"><code class="fe me mf mg mh b">ngAfterViewInit</code>:组件视图初始化后</li><li id="98a4" class="lv lw it lb b lc mi lf mj li mk lm ml lq mm lu ma mb mc md bi translated"><code class="fe me mf mg mh b">ngAfterViewChecked</code>:每次检查组件视图后</li><li id="d8cd" class="lv lw it lb b lc mi lf mj li mk lm ml lq mm lu ma mb mc md bi translated"><code class="fe me mf mg mh b">ngOnDestroy</code>:就在组件/指令被销毁之前</li></ol><h1 id="f984" class="mn mo it bd mp mq mr ms mt mu mv mw mx jz my ka mz kc na kd nb kf nc kg nd ne bi translated">设置新项目</h1><p id="74bb" class="pw-post-body-paragraph kz la it lb b lc nf ju le lf ng jx lh li nh lk ll lm ni lo lp lq nj ls lt lu im bi translated">使用Angular CLI，我们将创建一个新的练习项目:</p><pre class="kj kk kl km gt nk mh nl nm aw nn bi"><span id="a9e6" class="no mo it mh b gy np nq l nr ns">ng new angular-lifecycle-hooks</span></pre><p id="6aa3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在，我们将创建两个独立的组件，父组件和子组件。</p><pre class="kj kk kl km gt nk mh nl nm aw nn bi"><span id="3e8e" class="no mo it mh b gy np nq l nr ns">ng g c components/parent<br/>ng g c components/child</span></pre><p id="be38" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">然后，我们将把<code class="fe me mf mg mh b">app.component.html</code>的内容替换成这样:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nt nu l"/></div></figure><p id="3d6c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe me mf mg mh b">parent.component.html</code>和<code class="fe me mf mg mh b">parent.component.ts</code>的启动代码看起来会像这样:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nt nu l"/></div></figure><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nt nu l"/></div></figure><p id="8e35" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">同样，我们必须在<code class="fe me mf mg mh b">child.component.ts</code>和<code class="fe me mf mg mh b">child.component.html</code>中更新以下启动代码。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nt nu l"/></div></figure><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nt nu l"/></div></figure><p id="4480" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">至此，演示应用程序的初始设置完成。现在，只需用<code class="fe me mf mg mh b">ng s</code>或<code class="fe me mf mg mh b">ng serve</code>编译应用程序，并在你最喜欢的网络浏览器中打开<code class="fe me mf mg mh b"><a class="ae ky" href="http://localhost:4200/" rel="noopener ugc nofollow" target="_blank">http://localhost:4200/</a></code>。输出将如下所示:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi nv"><img src="../Images/50386a2cb3197d5db72797bda4c2c46c.png" data-original-src="https://miro.medium.com/v2/resize:fit:680/format:webp/1*EMyUi7PPdpl6_T9t-lvhLg.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">作者图片</p></figure><p id="f062" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在，让我们彻底理解上面提到的每一个生命周期挂钩。</p><h2 id="7db6" class="no mo it bd mp nw nx dn mt ny nz dp mx li oa ob mz lm oc od nb lq oe of nd og bi translated"><strong class="ak"> 1。ngOnChanges </strong></h2><p id="386c" class="pw-post-body-paragraph kz la it lb b lc nf ju le lf ng jx lh li nh lk ll lm ni lo lp lq nj ls lt lu im bi translated">该方法在创建组件时调用一次，然后每当组件的输入属性之一发生更改时调用一次。作为一个参数，它接收一个<a class="ae ky" href="https://angular.io/api/core/SimpleChanges" rel="noopener ugc nofollow" target="_blank"> SimpleChanges </a>对象，该对象包含关于哪个输入属性已经更改的信息——如果不止一个——以及其当前和以前的值。</p><p id="de36" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">需要注意的是，如果你的组件没有输入，或者你在没有任何输入的情况下使用它，框架不会调用<code class="fe me mf mg mh b">ngOnChanges()</code>。</p><p id="7aec" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这是生命周期挂钩之一，在各种情况下都很有用。当您需要根据接收到的输入属性处理组件中的任何特定逻辑时，它会很方便。</p><p id="c896" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">为了理解这一点，让我们用下面的代码更新<code class="fe me mf mg mh b">child.component.ts</code>:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nt nu l"/></div></figure><p id="bbdb" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">您可能已经注意到，我们从<code class="fe me mf mg mh b">@angular/core</code> <strong class="lb iu"> </strong>中导入了<code class="fe me mf mg mh b">OnChanges</code>，然后在<code class="fe me mf mg mh b">implements </code>列表中为<code class="fe me mf mg mh b">ChildComponent</code>类添加了<code class="fe me mf mg mh b">OnChanges </code>。现在我们添加了来自<code class="fe me mf mg mh b">OnChanges</code>接口的<code class="fe me mf mg mh b">ngOnChanges()</code>，并接受一个基本上是<code class="fe me mf mg mh b">SimpleChanges</code>对象的参数。然后我们简单地添加了<code class="fe me mf mg mh b">console.log</code>语句来打印作为参数接收的值。</p><p id="56eb" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在，如果我们刷新浏览器并打开控制台，我们会看到第一次刷新/打开应用程序后调用了<code class="fe me mf mg mh b">console.log()</code>。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi oh"><img src="../Images/32c80631d1e9bf26b505aa2453468eba.png" data-original-src="https://miro.medium.com/v2/resize:fit:1224/format:webp/1*WXebz2H1BD2ujaUURyJKQg.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">作者图片</p></figure><p id="9555" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们可以看到，接收到的<code class="fe me mf mg mh b">changes</code>对象有三个键:<code class="fe me mf mg mh b">currentValue</code> <em class="oi">、</em> <code class="fe me mf mg mh b">previousValue</code>、和<em class="oi"> </em> <code class="fe me mf mg mh b">firstChange</code>。这三个键的工作原理和它们听起来的一样。</p><p id="4c5b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果这不是我们第一次这样做，或者如果当前值只有<code class="fe me mf mg mh b">Bob</code>，我们可以说我们想要改变<code class="fe me mf mg mh b">userName</code>值。我们可以在这里做任何事情，所以让我们进行第二个场景。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nt nu l"/></div></figure><p id="92e2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这里，我们添加了一个条件来检查它是否是第一次/初始变更，然后我们检查<code class="fe me mf mg mh b">currentValue</code>是否仅仅是<code class="fe me mf mg mh b">Bob</code>。</p><p id="d50b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在，如果我们点击<code class="fe me mf mg mh b">Update</code>按钮，我们应该看到<code class="fe me mf mg mh b">console.log()</code>功能再次被触发。发生这种情况是因为<code class="fe me mf mg mh b">@Input()</code>值从<code class="fe me mf mg mh b">John</code>变为<code class="fe me mf mg mh b">Bob</code>。如果我们持续点击<code class="fe me mf mg mh b">Update</code>按钮，我们将不会在控制台上看到任何新内容，这是因为<code class="fe me mf mg mh b">@Input()</code>没有改变。</p><p id="5d43" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果我们现在点击<code class="fe me mf mg mh b">Update</code>按钮，我们应该看到<code class="fe me mf mg mh b">console.log()</code>功能再次被调用。这是因为<code class="fe me mf mg mh b">@Input()</code>值从<code class="fe me mf mg mh b">John</code>更改为<code class="fe me mf mg mh b">Bob</code>。如果我们一直点击<code class="fe me mf mg mh b">Update</code>按钮，我们将不会在控制台上看到任何新内容，因为<code class="fe me mf mg mh b">@Input()</code>没有改变。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi oj"><img src="../Images/9061bd879cf752fee2817e2914968dec.png" data-original-src="https://miro.medium.com/v2/resize:fit:616/format:webp/1*z-iUfv9pTq1R8WKPAT3ZWw.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">作者图片</p></figure><p id="faa5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们甚至可以在控制台中验证我们的更改。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi ok"><img src="../Images/b0c6a546f98d8ca901e3f657dc5152ed.png" data-original-src="https://miro.medium.com/v2/resize:fit:848/format:webp/1*xCddmENL65-LtiI4aLnwSw.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">作者图片</p></figure><h2 id="0bcf" class="no mo it bd mp nw nx dn mt ny nz dp mx li oa ob mz lm oc od nb lq oe of nd og bi translated">2.恩戈尼特</h2><p id="4307" class="pw-post-body-paragraph kz la it lb b lc nf ju le lf ng jx lh li nh lk ll lm ni lo lp lq nj ls lt lu im bi translated">在组件的生命周期中，这个方法只在第一次<code class="fe me mf mg mh b">ngOnChanges</code>调用之后调用一次。当没有模板绑定输入时，即使<code class="fe me mf mg mh b">ngOnChanges</code>没有，也仍然调用<code class="fe me mf mg mh b">ngOnInit</code>。</p><p id="1dba" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在Angular中，这是最常用的生命周期挂钩之一。在这里，您可以请求服务器加载内容，为该组件处理的表单创建一个<a class="ae ky" href="https://angular.io/api/forms/FormGroup" rel="noopener ugc nofollow" target="_blank">表单组</a>，设置<a class="ae ky" href="https://rxjs.dev/guide/subscription" rel="noopener ugc nofollow" target="_blank">订阅</a>，等等。在组件构建完成后，您可以在这里进行任何初始化。甚至，每当我们使用Angular CLI创建一个新组件时，<code class="fe me mf mg mh b">ngOnInit</code>是默认情况下唯一可用的钩子。</p><p id="0663" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">但是如果同样的工作(初始化<code class="fe me mf mg mh b">FormGroup</code>或者从服务器获取数据)可以在组件的<code class="fe me mf mg mh b">constructor()</code>中完成，那么使用<code class="fe me mf mg mh b">ngOnInit</code>钩子又有什么意义呢？请允许我解释一下。</p><p id="6893" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">以下是一些最重要的要点:</p><h2 id="fb5e" class="no mo it bd mp nw nx dn mt ny nz dp mx li oa ob mz lm oc od nb lq oe of nd og bi translated">构造函数()</h2><ul class=""><li id="deb5" class="lv lw it lb b lc nf lf ng li ol lm om lq on lu oo mb mc md bi translated">当类被实例化时，默认方法，即<code class="fe me mf mg mh b">constructor()</code>被调用，这确保了类及其子类中的所有字段都被正确初始化</li><li id="0300" class="lv lw it lb b lc mi lf mj li mk lm ml lq mm lu oo mb mc md bi translated">在Angular中，依赖注入器(DI)分析构造函数参数，当它通过调用<code class="fe me mf mg mh b">new MyClass()</code>创建一个新的实例时，它寻找与构造函数参数类型相匹配的提供者，解析它们，并像new <code class="fe me mf mg mh b">MyClass(someArg)</code>一样将它们传递给构造函数</li><li id="f24f" class="lv lw it lb b lc mi lf mj li mk lm ml lq mm lu oo mb mc md bi translated">应该仅用于初始化类成员，而不应该用于执行实际工作。因为<code class="fe me mf mg mh b">constructor</code>在<code class="fe me mf mg mh b">ngOnInit</code>之前被调用，所以组件还没有被创建；只有组件类被实例化了，所以引入了依赖项，但是初始化代码不会运行。</li></ul><h2 id="7da6" class="no mo it bd mp nw nx dn mt ny nz dp mx li oa ob mz lm oc od nb lq oe of nd og bi translated">恩戈尼特人()</h2><ul class=""><li id="c1e8" class="lv lw it lb b lc nf lf ng li ol lm om lq on lu oo mb mc md bi translated">这是Angular调用的一个生命周期挂钩，表示组件已经完成。</li><li id="2318" class="lv lw it lb b lc mi lf mj li mk lm ml lq mm lu oo mb mc md bi translated">所有初始化/声明都应该用这个方法完成。因为组件将在此时被初始化。</li></ul><p id="6013" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">为了清楚地理解这个钩子，让我们这样做:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nt nu l"/></div></figure><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nt nu l"/></div></figure><p id="8ff3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们只是在ngOnInit中为<code class="fe me mf mg mh b">parent</code>和<code class="fe me mf mg mh b">child</code>组件添加了<code class="fe me mf mg mh b">console.log</code>语句。现在让我们看看输出。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi op"><img src="../Images/b898448cf2d94b3055feaf36c2ae1148.png" data-original-src="https://miro.medium.com/v2/resize:fit:744/format:webp/1*AGkqvxPI-sGViWKYI9ZpoQ.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">作者图片</p></figure><p id="79db" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">首先创建父组件是有意义的(首先触发<code class="fe me mf mg mh b">parent</code>组件中的<code class="fe me mf mg mh b">ngOnInit</code>，然后是<code class="fe me mf mg mh b">child</code>组件)。如果我们点击<code class="fe me mf mg mh b">Update</code>按钮，则<code class="fe me mf mg mh b">ngOnInit</code>不会被触发。因为，如前所述，它只会出现一次。</p><h2 id="09f1" class="no mo it bd mp nw nx dn mt ny nz dp mx li oa ob mz lm oc od nb lq oe of nd og bi translated"><strong class="ak"> 3。ngDoCheck </strong></h2><p id="9a61" class="pw-post-body-paragraph kz la it lb b lc nf ju le lf ng jx lh li nh lk ll lm ni lo lp lq nj ls lt lu im bi translated">该挂钩可视为<code class="fe me mf mg mh b">ngOnChanges</code>挂钩的延伸。此方法可用于检测Angular无法或不愿检测的变化。在每次变化检测中，在<code class="fe me mf mg mh b">ngOnChanges</code>和<code class="fe me mf mg mh b">ngOnInit</code>钩子之后调用它。</p><p id="c081" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><em class="oi">这个钩子很贵，因为叫得太频繁；在每个变更检测周期之后，不管变更发生在哪里。因此，应该谨慎使用它，以免对用户体验产生负面影响。</em></p><p id="5fde" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们使用以下代码将这个钩子添加到我们的<code class="fe me mf mg mh b">child</code>组件中:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nt nu l"/></div></figure><p id="dff6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在，我们将在运行应用程序后看到这个结果。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi oq"><img src="../Images/d23fb1562f4b83a19daaddabbe1942dd.png" data-original-src="https://miro.medium.com/v2/resize:fit:694/format:webp/1*lEwBQYmxLDn-9ed5Na4IIA.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">作者图片</p></figure><p id="9498" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">当我们点击<code class="fe me mf mg mh b">Update</code>按钮时，我们应该看到<code class="fe me mf mg mh b">ngOnChanges</code>和<code class="fe me mf mg mh b">ngDoCheck</code>被激活。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi or"><img src="../Images/84d3d28cf2093bf34e2a7cb259764eb0.png" data-original-src="https://miro.medium.com/v2/resize:fit:704/format:webp/1*uQ1iax-F_qJ82WoH-xbDlw.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">作者图片</p></figure><p id="b8ba" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果我们继续点击<code class="fe me mf mg mh b">Update</code>按钮，我们应该看到每次点击后只有<code class="fe me mf mg mh b">ngDoCheck</code>被触发，因为<code class="fe me mf mg mh b">ngDoCheck</code>检测到了变化。</p><p id="e2dc" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">所以现在的问题是:</p><p id="522b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果<code class="fe me mf mg mh b">@Input()</code> <em class="oi"> </em>属性没有变化，<code class="fe me mf mg mh b">ngDoCheck</code>如何捕捉变化？</p><p id="057f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">因为Angular跟踪对象引用，如果我们在不改变引用的情况下改变对象，Angular将不会检测到变化，也不会对组件运行变化检测。因此，新的name属性值将不会再次呈现在DOM中。幸运的是，我们可以检查对象突变，并使用<code class="fe me mf mg mh b">ngDoCheck</code>生命周期钩子通知Angular。</p><h2 id="a862" class="no mo it bd mp nw nx dn mt ny nz dp mx li oa ob mz lm oc od nb lq oe of nd og bi translated">4.ngAfterContentInit</h2><p id="9737" class="pw-post-body-paragraph kz la it lb b lc nf ju le lf ng jx lh li nh lk ll lm ni lo lp lq nj ls lt lu im bi translated">在第一个<code class="fe me mf mg mh b">ngDoCheck</code>之后，这个方法在组件的生命周期中只被调用一次。在这个钩子中，我们在组件创建后第一次访问了<a class="ae ky" href="https://angular.io/api/core/ContentChildren" rel="noopener ugc nofollow" target="_blank"> ContentChild </a>的<a class="ae ky" href="https://angular.io/api/core/ElementRef" rel="noopener ugc nofollow" target="_blank">element ref</a>；这是在Angular已经将外部内容投影到组件视图中之后。</p><p id="7593" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">为了理解这一点，让我们添加以下代码:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nt nu l"/></div></figure><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nt nu l"/></div></figure><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nt nu l"/></div></figure><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi os"><img src="../Images/adbd50c65e01c50c573f9e1396e83bee.png" data-original-src="https://miro.medium.com/v2/resize:fit:1018/format:webp/1*qJt8uDlR8o4pg_glY7Ne7w.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">作者图片</p></figure><p id="0919" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在前面的代码片段中，我们将内容从<code class="fe me mf mg mh b">parent</code>组件投影到<code class="fe me mf mg mh b">child</code>组件。查看本文档以了解更多关于内容投影的信息。</p><p id="c432" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们此时只能访问投影内容(contentWrapper拥有投影内容的值)。此外，组件的模板还没有初始化(包装器是<code class="fe me mf mg mh b">undefined</code>)。在<code class="fe me mf mg mh b">ngAfterViewInit</code>挂钩上，它将被初始化并准备使用。</p><h2 id="461a" class="no mo it bd mp nw nx dn mt ny nz dp mx li oa ob mz lm oc od nb lq oe of nd og bi translated">5.ngAfterContentChecked</h2><p id="9b4b" class="pw-post-body-paragraph kz la it lb b lc nf ju le lf ng jx lh li nh lk ll lm ni lo lp lq nj ls lt lu im bi translated">在组件的生命周期中，这个方法在<code class="fe me mf mg mh b">ngAfterContentInit</code>之后被调用一次，然后在每个后续的<code class="fe me mf mg mh b">ngDoCheck</code>之后被调用。在Angular检查了当前摘要循环中投射到组件中的内容后，它被调用。</p><p id="aa56" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">为了理解这一点，让我们添加以下代码:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nt nu l"/></div></figure><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi ot"><img src="../Images/b571e5c59b3bfc7045ef1b7ffdfd3386.png" data-original-src="https://miro.medium.com/v2/resize:fit:984/format:webp/1*6lU4Bnx8cVCo6VR5PYCEyg.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">作者图片</p></figure><p id="8fe6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果我们点击<code class="fe me mf mg mh b">Update</code>按钮，每次都会触发<code class="fe me mf mg mh b">ngAfterContentChecked</code>，同样也会触发<code class="fe me mf mg mh b">ngDoCheck</code>。</p><h2 id="0ad5" class="no mo it bd mp nw nx dn mt ny nz dp mx li oa ob mz lm oc od nb lq oe of nd og bi translated">6.ngAfterViewInit</h2><p id="1c1d" class="pw-post-body-paragraph kz la it lb b lc nf ju le lf ng jx lh li nh lk ll lm ni lo lp lq nj ls lt lu im bi translated">这个方法在组件的生命周期中只被调用一次，紧接在<code class="fe me mf mg mh b">ngAfterContentChecked</code>之后。在这个钩子中，我们可以在组件创建后第一次访问<a class="ae ky" href="https://angular.io/api/core/ViewChildren" rel="noopener ugc nofollow" target="_blank"> ViewChildren </a>的<a class="ae ky" href="https://angular.io/api/core/ElementRef" rel="noopener ugc nofollow" target="_blank">element ref</a>；那是在Angular已经组成了组件的视图和它的子视图之后。</p><p id="6227" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">当您需要在依赖于视图组件的视图上加载内容时，例如当您需要设置视频播放器或从canvas元素创建图表时，这个钩子非常有用。</p><p id="e108" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">为了理解这一点，让我们添加以下代码:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nt nu l"/></div></figure><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi ou"><img src="../Images/33ecd8683c582cc5e8b48f2172d91338.png" data-original-src="https://miro.medium.com/v2/resize:fit:990/format:webp/1*NfMg2vzsKMfLQf8_e01fuQ.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">作者图片</p></figure><p id="6fea" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">至此，组件的模板已经创建，我们可以访问它了。</p><h2 id="15f4" class="no mo it bd mp nw nx dn mt ny nz dp mx li oa ob mz lm oc od nb lq oe of nd og bi translated">7.ngAfterViewChecked</h2><p id="e05c" class="pw-post-body-paragraph kz la it lb b lc nf ju le lf ng jx lh li nh lk ll lm ni lo lp lq nj ls lt lu im bi translated">这个方法在<code class="fe me mf mg mh b">ngAfterViewInit</code>之后被调用一次，之后每次<code class="fe me mf mg mh b">ngAfterContentChecked</code>都被调用。在Angular已经检查了当前摘要循环中组件的视图和子视图之后，将调用该函数。</p><p id="1f90" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">为了理解这一点，让我们添加以下代码:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nt nu l"/></div></figure><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ov"><img src="../Images/5df7eccbc7956f225c98842c7a1340a5.png" data-original-src="https://miro.medium.com/v2/resize:fit:982/format:webp/1*kny2Ydi6-8IE3cLEwAHWOg.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">作者图片</p></figure><p id="1259" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果我们一直点击<code class="fe me mf mg mh b">Update</code>按钮，每次都会触发<code class="fe me mf mg mh b">ngAfterViewChecked</code>、<code class="fe me mf mg mh b">ngDoCheck</code>和<code class="fe me mf mg mh b">ngAfterContentChecked</code>。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi ow"><img src="../Images/f9cef62d37637881429886202278a47c.png" data-original-src="https://miro.medium.com/v2/resize:fit:710/format:webp/1*WzwdBOQ6UY6JvZKC_dijeg.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">作者图片</p></figure><h2 id="4d23" class="no mo it bd mp nw nx dn mt ny nz dp mx li oa ob mz lm oc od nb lq oe of nd og bi translated">8.恩贡德斯特罗伊</h2><p id="078e" class="pw-post-body-paragraph kz la it lb b lc nf ju le lf ng jx lh li nh lk ll lm ni lo lp lq nj ls lt lu im bi translated">最后，这个方法在组件的生命周期中只被调用一次，就在它被Angular销毁之前。在这个钩子中，您应该通知应用程序的其余部分组件正在被销毁，以防需要根据该信息采取任何操作。</p><p id="ee5b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这也是您应该为该组件放置所有清理逻辑的地方。例如，您可以在这里删除任何本地存储信息，更重要的是，取消订阅观察、分离事件处理程序、停止计时器等。为了避免<a class="ae ky" href="https://www.geeksforgeeks.org/what-is-memory-leak-how-can-we-avoid/" rel="noopener ugc nofollow" target="_blank">内存泄漏</a>。</p><p id="eabd" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">值得注意的是，当用户刷新页面或关闭浏览器时，不会调用<code class="fe me mf mg mh b">ngOnDestroy</code>。因此，如果您需要在这些情况下处理任何清理逻辑，您可以使用<a class="ae ky" href="https://angular.io/api/core/HostListener" rel="noopener ugc nofollow" target="_blank"> HostListener </a> decorator，如下所示:</p><pre class="kj kk kl km gt nk mh nl nm aw nn bi"><span id="c225" class="no mo it mh b gy np nq l nr ns"><a class="ae ky" href="http://twitter.com/HostListener" rel="noopener ugc nofollow" target="_blank">@HostListener</a>(‘window:beforeunload’)<br/>ngOnDestroy() {<br/>  // Insert Logic Here!<br/>}</span></pre><p id="5794" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">为了理解这一点，让我们添加以下代码:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nt nu l"/></div></figure><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nt nu l"/></div></figure><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nt nu l"/></div></figure><p id="663e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">运行应用程序后，这是我们更新后的UI的外观:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi ox"><img src="../Images/9c0cdadc82fcec69a931ec7f46a9c400.png" data-original-src="https://miro.medium.com/v2/resize:fit:564/format:webp/1*FNNi8BuWCFH5tCzmP-arPg.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">作者图片</p></figure><p id="e83a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">当我们点击<code class="fe me mf mg mh b">Destroy Child</code>按钮时，<code class="fe me mf mg mh b">ngOnDestroy()</code>被调用，组件被从DOM中移除。</p><p id="f486" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">下图描述了单击销毁子按钮之前的DOM。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi oy"><img src="../Images/349286941213c768ca48f754b453b728.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*YNyVOs4a9GtVLeWX08RzJg.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">作者图片</p></figure><p id="3d1d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">下图描绘了点击<code class="fe me mf mg mh b">Destroy Child</code>按钮后的DOM。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi oz"><img src="../Images/16d767b8cc25bc8c04c088c41415d839.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*bdxZ49OgFXxTIDA8QcnVCw.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">作者图片</p></figure><h1 id="2850" class="mn mo it bd mp mq mr ms mt mu mv mw mx jz my ka mz kc na kd nb kf nc kg nd ne bi translated">长话短说</h1><p id="22c4" class="pw-post-body-paragraph kz la it lb b lc nf ju le lf ng jx lh li nh lk ll lm ni lo lp lq nj ls lt lu im bi translated">长话短说，通过将过程分成两步，我们可以更好地理解生命周期挂钩:第一次挂钩和每个变更检测周期中的挂钩。</p><p id="f6c1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu">第一步:首次挂钩，</strong>触发的挂钩有:</p><ul class=""><li id="2c08" class="lv lw it lb b lc ld lf lg li lx lm ly lq lz lu oo mb mc md bi translated"><code class="fe me mf mg mh b">onChanges</code></li><li id="981a" class="lv lw it lb b lc mi lf mj li mk lm ml lq mm lu oo mb mc md bi translated"><code class="fe me mf mg mh b">onInit</code></li><li id="7460" class="lv lw it lb b lc mi lf mj li mk lm ml lq mm lu oo mb mc md bi translated"><code class="fe me mf mg mh b">doCheck</code></li><li id="d0bc" class="lv lw it lb b lc mi lf mj li mk lm ml lq mm lu oo mb mc md bi translated"><code class="fe me mf mg mh b">afterContentInit</code></li><li id="8bdf" class="lv lw it lb b lc mi lf mj li mk lm ml lq mm lu oo mb mc md bi translated"><code class="fe me mf mg mh b">afterContentChecked</code></li><li id="3a4c" class="lv lw it lb b lc mi lf mj li mk lm ml lq mm lu oo mb mc md bi translated"><code class="fe me mf mg mh b">afterViewInit</code></li><li id="3fdd" class="lv lw it lb b lc mi lf mj li mk lm ml lq mm lu oo mb mc md bi translated"><code class="fe me mf mg mh b">afterViewChecked</code></li><li id="fb09" class="lv lw it lb b lc mi lf mj li mk lm ml lq mm lu oo mb mc md bi translated"><code class="fe me mf mg mh b">onDestroy</code>:一旦组件从DOM中移除，就会调用这个函数</li></ul><p id="6e4c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu">第二步:在每个变化检测周期挂钩</strong>中，触发的挂钩有:</p><ul class=""><li id="6bb5" class="lv lw it lb b lc ld lf lg li lx lm ly lq lz lu oo mb mc md bi translated"><code class="fe me mf mg mh b">onChanges</code></li><li id="9fa6" class="lv lw it lb b lc mi lf mj li mk lm ml lq mm lu oo mb mc md bi translated"><code class="fe me mf mg mh b">doCheck</code></li><li id="d1ed" class="lv lw it lb b lc mi lf mj li mk lm ml lq mm lu oo mb mc md bi translated"><code class="fe me mf mg mh b">afterContentChecked</code></li><li id="ff96" class="lv lw it lb b lc mi lf mj li mk lm ml lq mm lu oo mb mc md bi translated"><code class="fe me mf mg mh b">afterViewChecked</code></li></ul><p id="8753" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">下图详细描述了角度组件/指令生命周期。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi pa"><img src="../Images/fed80b9d777c183146e6dd0c06dcd672.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*oJfUPdKYIOmsLRHW"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">作者图片</p></figure><h2 id="cc99" class="no mo it bd mp nw nx dn mt ny nz dp mx li oa ob mz lm oc od nb lq oe of nd og bi translated">结论</h2><p id="c39b" class="pw-post-body-paragraph kz la it lb b lc nf ju le lf ng jx lh li nh lk ll lm ni lo lp lq nj ls lt lu im bi translated">我们学习了Angular生命周期挂钩，它们的目标，它们何时被调用，以及它们在开发Angular应用程序时如何非常有用。因此，了解它们的工作原理以及你可以用它们实现什么是至关重要的，这样你就可以在需要的时候应用它们。</p></div><div class="ab cl pb pc hx pd" role="separator"><span class="pe bw bk pf pg ph"/><span class="pe bw bk pf pg ph"/><span class="pe bw bk pf pg"/></div><div class="im in io ip iq"><p id="6410" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这就是这篇文章的内容。我希望你今天学到了一些新东西。想看更多这样的文章，敬请期待！</p><p id="c3f7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">感谢阅读！</p></div></div>    
</body>
</html>