# 在 Python 中处理异常时避免这 5 个错误

> 原文：<https://betterprogramming.pub/avoid-these-5-mistakes-when-handling-exceptions-in-python-645f0ce92c92>

## 使用最佳实践来处理代码中的错误

![](img/5a7de878b2f6854336cf03b54229b2c4.png)

照片由[尼克·费因斯](https://unsplash.com/@jannerboy62?utm_source=medium&utm_medium=referral)在 [Unsplash](https://unsplash.com?utm_source=medium&utm_medium=referral) 拍摄

谁也不能保证他们的代码没有 bug。随着我们项目范围的扩大，我们越来越有可能错过一些在项目交付时可能发生的意想不到的方面。这都是因为我们不能总是考虑最终客户会对我们的项目做什么。因此，当我们编写代码时，我们应该尝试解决可能的异常用例，处理这些意外情况的一种方法是在开发阶段处理可能的异常。下面的代码向您展示了可能是最简单的错误处理示例。

异常处理示例

如上所示，该函数计算两个数字之间的比率。然而，人们可能会通过将分母设置为零来调用这个函数，这将导致`ZeroDivisionError`被提高。通过处理这个异常，我们通知代码的用户他们不能除以零。这样，他们可以调整如何使用这一特殊功能。

作为 Python 中错误处理的经典例子，您可能已经多次看到上面的代码或其排列。您可能已经对如何处理异常有了一些想法。然而，当您在代码中处理异常时，会犯一些错误。在本文中，我们将探讨一些你应该避免的错误。

# 1.缺乏特异性

显然，当我们处理特定的异常时，我们应该对将要遇到的异常有所预期。通过识别这些异常，我们知道如何正确处理它们。然而，我看到一些代码具有非常普通的异常处理，这完全违背了错误处理的目的——一件不愉快的事情刚刚发生，阻止了我们的代码正常运行，我们正在试图恢复它。

因此，一些程序员犯的第一个错误是他们没有指定他们正在处理什么异常。此外，它们没有给出任何关于错误的有意义的信息。让我们通过修改我最初分享的代码来看一个这样的例子。

通用异常处理

上面的代码向您展示了错误消息是多么的无意义。正如您可能看到的，函数的两次调用有两个不同的问题。第一次调用使用字符串作为分母，而第二次调用使用零作为分母。应该区别对待！此外，我们应该对每个异常给出具体的错误消息。让我们看看下面的代码，看看可能的修复方法。

请注意，理论上，我们可以在运行操作之前检查参数的类型。这个解决方案只是为了向您展示如何具体处理异常。另一个实现见下一节。

特定异常处理

# 2.没有尝试解决这个问题

在上面的代码中，我们向您展示了我们可以为我们获得的参数获得一个字符串值，并且我们编写了一些代码来处理可能的异常(即`TypeError`)。在大多数情况下，我们会引发异常，因为我们不希望这些情况经常发生，但是如果我们代码的许多用户以字符串格式发送数字呢？当然，我们仍然可以继续引发`TypeError`异常，但是用户体验可能不会很好。换句话说，如果我们能够提出一些特殊的异常，我们至少可以尝试解决这个问题。请看下面的代码修改。

错误校正

在上面的代码中，我们只是使用了不同的实现策略。具体来说，在执行除法之前，我们可以将传递的参数转换为浮点数。通过这样做，如果用户意外地传递了字符串格式的数字(即上面示例中的 4)，我们仍然可以处理该操作，这可能会改善用户体验。

# 3.“try”子句中的代码太多

另一个常见的错误是有些人在`try`条款中放了大量代码。*试*是什么意思？意思是某件事可能行得通，也可能行不通，我们在运行它之前是不知道的。这很像进行一项实验，可能会失败。我们可能不应该也不需要去尝试一些肯定会发生的事情。让我们看看本文中使用的例子的一个变体。

try 子句有问题

在上面的代码中，`try`子句包含了对`print`函数的四次调用，这可能会非常混乱，因为我们不知道哪些行会导致问题。您认为在前三次调用中，在什么情况下调用`print`函数可能会失败？可能没什么可想的。唯一导致问题的代码是第四次调用，这可能会导致`ZeroDivisionError`异常。因此，我们应该从`try`条款中去掉预期没有问题的那一行。通过这样做，我们非常清楚地表明了我们的意图，即只有调用分部才能引发异常。

干净的尝试子句

# 4.没有利用‘else’子句

在前面的章节中，我们探索了`try`和`except`子句，这是 Python 中异常处理的主干。然而，Python 支持在处理异常时使用`else`子句。具体来说，`else`子句中的代码在成功执行`try`子句中的代码后运行。通过这样做，我们可以保持`try`子句中的代码尽可能的简洁，这将提高我们期望在`try`子句中处理的可能异常的可见性。让我们利用`else`子句来修改这个例子。

利用 Else 子句

如上所示，我们通过放置`print`函数来利用`else`子句，该函数仅在我们使用有效参数调用函数时执行。值得注意的是，当出现异常时，它不会被执行。

# 5.不明白‘finally’子句何时执行

除了`else`子句，Python 的异常处理也支持`finally`子句。`finally`条款位于`else`条款之后。但是，如果没有 `else`条款，则应该遵循`except`条款。无论是否捕获到异常，都会执行`finally`子句中的代码，这也是为什么有人说`finally`子句保证运行的原因。让我们看看如何使用它。

用 Finally 处理异常

如上所示，在两个函数调用中，`finally`子句中的代码在没有异常时运行(因此，`else`子句也执行)，并且有一个异常被捕获(因此，`except`子句执行)。值得注意的是，有些人确实理解`finally`子句在异常处理中的用法，但他们不知道执行顺序。让我们看看下面这个可能的错误。

Finally 子句执行顺序

在上面的代码中，`finally`子句返回一个`None`值，同时，`try`子句返回计算出的值。有些人可能认为`finally`子句中的返回值无关紧要，因为`try`子句将首先被执行，因此将返回正确的值。

令人惊讶的是，如你所见，计算出的值是`None`。到底发生了什么？这是因为如果`try`子句要通过 break、continue 或 return 语句来完成它的执行，那么`finally`子句将在 break、continue 或 return 语句执行之前执行。因此，在我们的例子中，我们返回的是`None`值。

# **结论**

在本文中，我们回顾了人们在 Python 异常处理方面可能犯的五个常见错误。当然，人们还会犯其他的错误，但是避免这些错误会让你为在项目中正确处理异常做好准备。