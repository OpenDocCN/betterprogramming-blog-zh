# 借助计数器对象计算 Python 中的项目

> 原文：<https://betterprogramming.pub/count-items-in-python-with-the-help-of-counter-objects-c08d8d486e45>

## 对数据容器中的对象进行计数的简单方法

![](img/924bf3615a48e3016814a4fa448daffe.png)

照片由 [Djim Loic](https://unsplash.com/@loic?utm_source=medium&utm_medium=referral) 在 [Unsplash](https://unsplash.com?utm_source=medium&utm_medium=referral) 上拍摄

# 前提

当我们在 Python 中处理数据容器(比如元组和列表)时，我们经常需要对特定的元素进行计数。一种常见的方法是使用`count()`函数——指定要计数的元素，函数返回计数。

让我们来看看它的一些使用代码:

count()函数

正如您在上面看到的，我们使用了带有分数列表的`count()`函数。

需要注意的一点是:当函数中指定的元素没有包含在列表中时，我们将得到一个零计数，这是意料之中的。如果我们想计算所有元素的出现次数，我们必须迭代它们，如下面的代码片段所示:

计算所有元素

上面有几件事值得强调:

*   为了避免计算相同值的元素，我们使用`set()`构造函数将这些 iterables 转换为 set 对象。这意味着删除了重复的元素 for 循环将只遍历不同的元素，以获得正确的累积计数。
*   `count()`函数不仅可以处理列表对象，还可以处理元组和字符串。更一般地说，`count()`函数处理 Python 中的序列数据，包括字符串、列表、元组和字节。

如上所示，我们必须使用 for 循环来迭代元素，以检索每个单独元素的计数。有点繁琐。

有没有另一个更好的方法来解决这个问题？如果你懂 Python，你应该猜到答案是肯定的。`Counter`类是专门为计算这些数据结构中的元素而设计的。

# 计数器类-概述

作为 Python 标准库的一部分，可以通过`collections`模块获得`Counter`类。作为`dict`类的子类，它提供了一些处理对象计数的高度专门化的方法。要创建计数器对象，只需将 iterable 设置为`Counter`类实例构造函数，如下所示:

计数器对象创建

正如您在第七行看到的，一个`Counter`对象看起来像一个包含一系列键值对的字典。具体来说，键是被计数的元素，而值是对应键的计数器。如果您想要检索单个项目的计数，您可以像使用字典一样进行操作。下面是一些简单的例子。值得注意的是，如果键不存在于`Counter`对象中，计数将为零。

访问单个项目

需要注意的一个关键点是，由于键值映射机制，只有可散列对象才能被`Counter`对象跟踪。在 Python 中，不可变的对象，如字符串、整数和元组都是可散列的，而可变的对象，如列表、集合和字典是不可散列的。关于对象散列能力的详细讨论超出了本文的范围，如果您感兴趣，您可以在我的[上一篇关于这个主题的文章](https://medium.com/better-programming/3-essential-questions-about-hashable-in-python-33e981042bcb)中找到更多信息。

下面的代码向您展示了一个简单的例子，当我们试图将`Counter`与不可混淆的对象`lists`一起使用时。错误消息清楚地告诉我们 Python 不能为我们实例化一个`Counter`对象，因为`lists`在 Python 中是不可销毁的对象。

不可洗柜台

# 确定最常见的项目

通常，我们需要知道数据容器中频繁出现的项目(例如，列表和元组)是什么。在我们看到使用`Counter`对象的解决方案之前，让我们看看如何使用一些繁琐的代码来实现这个功能:

非惯用的方式

如上所示，我们首先需要使用 list 的`count()`方法对列表中的每个唯一项进行计数，并将计数结果保存到字典中。接下来，我们必须使用内置的`max()`函数，通过指定排序键来使用每个键-值对的值，从而对字典的条目进行排序。当然，这种方式可行，但不是惯用的方式，在这种情况下，我们应该考虑使用`Counter`。

最常见的项目

如上所示，您的第一印象应该是，与该功能的非惯用实现相比，代码有多简洁。这都是因为`Counter`对象有一个方便的`most_common()`方法，它可以快速获取我们需要的信息——最频繁出现的项目及其相关计数。实际上，为了给我们更多的灵活性，我们可以选择找出任意数量的最频繁出现的项目，如下所示。

最常见的项目

请注意，当您没有在`most_common()`方法中指定任何数字时，所有的元素将作为一个列表按照计数的降序返回。这种降序非常有用，它允许我们检索计数最少的项目，如下所示。

最不常用的项目

## 更新计数器对象

之前，我们看到`Counter`对象用于计算列表中的元素。但是如果我们得到了另一个列表，并且想要更新原来的`Counter`对象而不创建一个新的，该怎么办呢？

一个可能的解决方案是利用一个`Counter`对象，实现映射协议，这样我们就可以相应地更新每个键的值。值得注意的是，如果键不存在于原始的`Counter`对象中，与内置的`dict`数据类型不同，将不会引发`KeyValue`异常，因为默认情况下，`Counter`对象中缺少的键的值为`0`，正如我们在访问单个项目时看到的那样。

更新计数器对象

有一种更优雅的方式来更新原始的`Counter`对象——使用`Counter`的`update()`方法。不要将这个`update()`方法与`*dict’*` s `update()`方法混淆，后者更新匹配键的值。相反，`Counter`的`update()`方法将在内部生成项目的计数，并使用这些计数来更新原始的`Counter`对象，如下面的代码片段所示。

update()方法

# 数学运算

`Counter`类的名字是信息性的，告诉你它对我们很重要。正如我们已经看到的，我们可以用`update()`方法更新计数。更广泛地说，当我们有多个`Counter`对象时，我们可以对它们进行加法和减法运算。当我们添加`Counter`对象时，元素的计数被合并。

下面的代码向您展示了这样的操作，这应该是不言自明的:

计数器对象的添加

以类似的方式，我们可以使用减号运算符从另一个`Counter`对象中减去一个`Counter`对象，如下所示。

计数器对象的减法

在上面的代码中，需要注意的一点是，当我们使用减法运算符时，得到的`Counter`对象将只包括那些具有正计数的键值对。这种行为不同于`Counter`的方法`subtract()`，后者也将包含负计数。另外，如前所述，当`Counter`不包含元素时，默认情况下它们的计数为零。记住这两件事，让我们看看`subtract()`方法如何处理`Counter`对象。

subtract()方法

正如您所看到的，产生的`Counter`对象包括几个负计数的元素。另一件要注意的事情是，`subtract()`方法就地改变计数，这意味着`subtract()`方法返回`None`并改变原始`Counter`对象的计数。

# 类似集合的操作

除了数学运算的支持外，`Counter`对象还有两个类似集合的运算:`union`和`intersection`。要创建两个`Counter`对象的“联合”,只需使用 OR 运算符(即竖线)将它们连接起来。联合操作将通过使用产生的`Counter`对象中每个匹配键的最大计数来执行。下面是一个简单的例子:

计数器的联合

要创建两个`Counter`对象的“交集”,只需使用 AND 运算符(即`&`符号)将它们连接起来。交集操作将通过使用产生的`Counter`对象中每个匹配键的最小计数来执行。下面是一个简单的例子。

计数器的交集

# 其他特色亮点

在前面的章节中，我们了解到我们可以从 iterables 创建`Counter`对象，包括元组、列表和字符串。如前所述，`Counter`类是内置`dict`类的子类，因此我们可以使用对`dict`类可用的实例化方法。下面列出了一些例子，并附有解释性说明:

构建计数器

我们已经看到`Counter`对象的计数来自计数或数学运算。如果适用的话，我们可以直接设置特定元素的数量。此外，我们可以从`Counter`对象中移除元素，就像从`dict`对象中移除键值对一样。这些用法见下文:

操作计数器对象

`Counter`对象的另一个有用的方法是`elements()`方法，它创建一个所有项目的迭代器，每个项目都有与其计数匹配的期望出现次数。这种方法对于迭代已知数字的不同项特别方便。

elements()方法

# 结论

在本文中，我们回顾了有趣的`Counter`类，用于计算序列中可散列对象的数量，包括元组、列表和字符串。作为`dict`数据类型的子类，我们可以从序列以及映射和关键字参数中创建`Counter`对象，就像常规的`dict`对象一样。`Counter`对象是高度灵活的，因为您可以根据需要操纵这些元素的计数。您甚至可以更新、合并和相交`Counter`对象。

最有趣的是，它有`most_common()`方法，允许我们用一行代码找出最频繁出现的项目。还可以利用`most_common()`方法找出最不常用的项目，该方法按降序排列项目，允许我们检索最不常用项目的最后一个项目。

感谢阅读。