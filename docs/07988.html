<html>
<head>
<title>The Cloud Isn’t Developer-Friendly Anymore</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">云不再对开发者友好</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/the-cloud-isnt-developer-friendly-anymore-9f57ad55d6be?source=collection_archive---------8-----------------------#2021-03-11">https://betterprogramming.pub/the-cloud-isnt-developer-friendly-anymore-9f57ad55d6be?source=collection_archive---------8-----------------------#2021-03-11</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="a239" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">这是生产中断的主要原因</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/57240378d4b7450090ee1923b85caf50.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*zDHWranjiAFe3Qzx"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated"><a class="ae ky" href="https://unsplash.com/@sigmund?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">西格蒙德</a>在<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍照。</p></figure><p id="7a7b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">当我提到配置管理时，我知道身经百战的开发人员会发抖。我无法计算由于一个看似无关紧要的配置改变而导致的失败发布的数量。甚至谷歌也发布了七份与配置错误相关的事后报告。<a class="ae ky" href="https://github.com/danluu/post-mortems#config-errors" rel="noopener ugc nofollow" target="_blank">在一次事件</a>中，他们拒绝列出<code class="fe lv lw lx ly b">/</code>提示每个网址显示警告。</p><p id="4f05" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在，使用现代部署策略，我们的发布应该在进入生产之前就失败了。那么，这些问题究竟为什么会持续存在呢？残酷的事实是懒惰的实例化是懒惰的，现在是我们为各方解决问题的时候了。</p></div><div class="ab cl lz ma hx mb" role="separator"><span class="mc bw bk md me mf"/><span class="mc bw bk md me mf"/><span class="mc bw bk md me"/></div><div class="im in io ip iq"><h1 id="bf49" class="mg mh it bd mi mj mk ml mm mn mo mp mq jz mr ka ms kc mt kd mu kf mv kg mw mx bi translated">让我们从简单的开始</h1><p id="2e27" class="pw-post-body-paragraph kz la it lb b lc my ju le lf mz jx lh li na lk ll lm nb lo lp lq nc ls lt lu im bi translated">那么，惰性实例化到底是什么，它与配置更改导致的生产中断有什么关系呢？解释这一点最简单的方法是通过一个例子。</p><p id="d89d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">下面是用Go编写的一段代码，其中一个应用程序使用外部MySQL数据库:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nd ne l"/></div></figure><p id="00cb" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果变量<code class="fe lv lw lx ly b">connStr</code>不正确，这个代码会不会死机？</p><p id="cc2f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在这种情况下，答案实际上是否定的。虽然看起来代码打开了一个到数据库的连接，但它实际上只是延迟地实例化了一个数据库池对象，并等待第一个请求。</p><p id="be99" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这可能因数据库驱动程序而异。<code class="fe lv lw lx ly b"><a class="ae ky" href="https://golang.org/pkg/database/sql/#Open" rel="noopener ugc nofollow" target="_blank">sql.Open</a></code> <a class="ae ky" href="https://golang.org/pkg/database/sql/#Open" rel="noopener ugc nofollow" target="_blank">文档</a>建议实际确认来源有效:</p><blockquote class="nf"><p id="acad" class="ng nh it bd ni nj nk nl nm nn no lu dk translated">"若要验证数据源名称是否有效，请调用Ping命令."</p></blockquote><p id="21bb" class="pw-post-body-paragraph kz la it lb b lc np ju le lf nq jx lh li nr lk ll lm ns lo lp lq nt ls lt lu im bi translated">假设您有一个API服务器，它将这个数据库对象传递给请求处理程序。在这种情况下，当每个传入的请求随后失败时，服务器将启动并看起来很健康。</p><p id="0dd6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">简单地说，惰性实例化就是在急切地工作之前等待第一件事去做的过程(在本例中，打开一个到数据库的连接)。这就产生了一个大问题:除非服务失败，否则无法知道我们的服务是否被破坏了。这里的教训是<strong class="lb iu"> </strong>服务应该在启动时验证配置选项。否则，由于纯粹的懒惰或无知，我们有排除错误检测的风险。</p><p id="135b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果比仅仅运行<code class="fe lv lw lx ly b">Ping</code>来确认要困难得多，会发生什么？让我们看看如何验证S3木桶策略，这个问题在哪里出现。</p></div><div class="ab cl lz ma hx mb" role="separator"><span class="mc bw bk md me mf"/><span class="mc bw bk md me mf"/><span class="mc bw bk md me"/></div><div class="im in io ip iq"><h1 id="03f4" class="mg mh it bd mi mj mk ml mm mn mo mp mq jz mr ka ms kc mt kd mu kf mv kg mw mx bi translated">木桶策略</h1><p id="a7da" class="pw-post-body-paragraph kz la it lb b lc my ju le lf mz jx lh li na lk ll lm nb lo lp lq nc ls lt lu im bi translated">如果你不知道，S3是亚马逊的一项对象存储服务，它让云文件存储的问题变得非常简单。这里的问题是，为了正确使用，它需要相当多的设置和配置。</p><p id="ecf1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">一般来说，当与S3交互时，我们有一些凭证，可以有各种权限，如<code class="fe lv lw lx ly b">ListBucket</code>、<code class="fe lv lw lx ly b">GetObject</code>、<code class="fe lv lw lx ly b">PutObject</code>或<code class="fe lv lw lx ly b">DeleteObject</code>。</p><p id="5999" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">假设我们的应用程序依赖于需要获取、放置和删除对象的凭证。我们如何确保这个给定的凭证在启动时是正确的呢？</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi nu"><img src="../Images/15e9c38d15a03bbdcc6832ee2b27b987.png" data-original-src="https://miro.medium.com/v2/resize:fit:1236/format:webp/1*CXSlMUSjZ2iQMgecclDRWA.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">应用程序需要权限才能在互联网上对S3存储桶执行不同的操作。使用<a class="ae ky" href="https://app.diagrams.net/" rel="noopener ugc nofollow" target="_blank">app.diagrams.net</a>设计的图表。</p></figure><p id="be4f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果您认为我们需要尝试获取、放置和删除一个对象，那么您是对的！不幸的是，S3不支持任何测试凭证的行为。下面是这种情况下验证的一个例子:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nd ne l"/></div></figure><p id="c32d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这里的要点应该是:当编写开发人员软件时，我们应该尽力支持用户的全部需求。是的，一个具有“11个9”的持久性的工作API是很棒的，但是当你考虑持续集成和交付这样的事情时，它如何适应整个画面呢？</p><p id="bb0d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">你可能会认为这只是亚马逊的问题，或者是SaaS或PaaS提供商的问题，但是让我们看看最后一个例子，它应该会改变你的想法。</p></div><div class="ab cl lz ma hx mb" role="separator"><span class="mc bw bk md me mf"/><span class="mc bw bk md me mf"/><span class="mc bw bk md me"/></div><div class="im in io ip iq"><h1 id="ee69" class="mg mh it bd mi mj mk ml mm mn mo mp mq jz mr ka ms kc mt kd mu kf mv kg mw mx bi translated">什么代理？在哪里？</h1><p id="5e9f" class="pw-post-body-paragraph kz la it lb b lc my ju le lf mz jx lh li na lk ll lm nb lo lp lq nc ls lt lu im bi translated">最近刚面临这个问题。假设您的应用程序支持一个<a class="ae ky" href="https://en.wikipedia.org/wiki/Proxy_server" rel="noopener ugc nofollow" target="_blank">出站HTTP(S)代理</a>。这意味着您的应用程序向代理发送传出的HTTP请求，然后代理与互联网通信。您如何确保代理正确配置<em class="nv">而不</em>向互联网发出请求？</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nw"><img src="../Images/591172f569da4363037fb207784541f5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*qJpJkgQectdYtP-ujiNQOw.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">通过代理发送所有HTTP(S)流量的应用程序拓扑示例。使用<a class="ae ky" href="https://app.diagrams.net/" rel="noopener ugc nofollow" target="_blank">app.diagrams.net</a>设计的图表。</p></figure><p id="27a6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">也许我们可以用正确的头向代理发出一个<code class="fe lv lw lx ly b"><a class="ae ky" href="https://developer.mozilla.org/en-US/docs/Web/HTTP/Methods/HEAD" rel="noopener ugc nofollow" target="_blank">HEAD</a></code> <a class="ae ky" href="https://developer.mozilla.org/en-US/docs/Web/HTTP/Methods/HEAD" rel="noopener ugc nofollow" target="_blank">请求</a>，如果我们得到一个<code class="fe lv lw lx ly b"><a class="ae ky" href="https://httpstatuses.com/" rel="noopener ugc nofollow" target="_blank">200 OK</a></code>返回，一切就都好了？</p><p id="e746" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果不知道更多关于特定代理或实现的信息，这可能行不通。我们可能会有不好的证书，无论如何会得到一个<code class="fe lv lw lx ly b">200 OK </code>！我们可以通过使用<a class="ae ky" href="https://hackage.haskell.org/package/hprox" rel="noopener ugc nofollow" target="_blank"> hprox </a>来确认这一点:</p><pre class="kj kk kl km gt nx ly ny nz aw oa bi"><span id="9b88" class="ob mh it ly b gy oc od l oe of">&gt; hprox -p 1122 -a userpass.txt &amp;<br/>&gt; curl -I localhost:1122<br/>HTTP/1.1 200 OK<br/>Date: Thu, 04 Mar 2021 21:03:10 GMT<br/>Server: Apache<br/>Vary: Accept-Encoding<br/>Content-Type: text/html</span></pre><p id="aefb" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">所以这是行不通的。代替一些现有的标准，我们将不得不自己凑合。<a class="ae ky" href="https://tools.ietf.org/html/rfc7231#section-4.3.6" rel="noopener ugc nofollow" target="_blank"> RFC 7231第4.3.6节</a>谈到了<code class="fe lv lw lx ly b">CONNECT</code>方法，甚至提到了<code class="fe lv lw lx ly b"><a class="ae ky" href="https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Proxy-Authorization" rel="noopener ugc nofollow" target="_blank">Proxy-Authorization</a></code>头。当我们这样做时:</p><pre class="kj kk kl km gt nx ly ny nz aw oa bi"><span id="95f6" class="ob mh it ly b gy oc od l oe of">&gt; hprox -p 1122 -a userpass.txt &amp;<br/>&gt; curl -X CONNECT -v localhost:1122<br/>...<br/>&lt; HTTP/1.1 407 Proxy Authentication Required<br/>&lt; Transfer-Encoding: chunked<br/>&lt; Date: Thu, 04 Mar 2021 21:06:37 GMT<br/>&lt; Server: Apache<br/>&lt; Vary: Accept-Encoding<br/>&lt; Proxy-Authenticate: Basic realm="hprox"<br/>...</span></pre><p id="c4f0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这为我们提供了正确的响应，直到我们提供正确的凭证。现在，利用这一点，我们可以编写一些在引导时使用的验证代码，以确保任何糟糕的配置都不会进入生产环境:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nd ne l"/></div></figure><p id="bd19" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">是时候从一开始就努力支持配置验证了。我认为最简单的方法是通过更彻底的契约测试。</p><blockquote class="nf"><p id="9b7f" class="ng nh it bd ni nj nk nl nm nn no lu dk translated">“契约测试断言应用程序间的消息符合契约中记录的共享理解。”— <a class="ae ky" href="https://docs.pact.io/" rel="noopener ugc nofollow" target="_blank">契约文件</a></p></blockquote><p id="3ed2" class="pw-post-body-paragraph kz la it lb b lc np ju le lf nq jx lh li nr lk ll lm ns lo lp lq nt ls lt lu im bi translated">最简单的契约测试之一是<code class="fe lv lw lx ly b">Connect</code>或<code class="fe lv lw lx ly b">Ping</code>，所以通过在我们的应用程序中实现更多的契约测试，我们可以隐式地解决这个问题。</p></div><div class="ab cl lz ma hx mb" role="separator"><span class="mc bw bk md me mf"/><span class="mc bw bk md me mf"/><span class="mc bw bk md me"/></div><div class="im in io ip iq"><h1 id="e56b" class="mg mh it bd mi mj mk ml mm mn mo mp mq jz mr ka ms kc mt kd mu kf mv kg mw mx bi translated">结论</h1><p id="051c" class="pw-post-body-paragraph kz la it lb b lc my ju le lf mz jx lh li na lk ll lm nb lo lp lq nc ls lt lu im bi translated">直到世界发生变化，每个服务都公开一个API来帮助应用程序验证配置选项并确保运行时的可用性，我们才能想出办法来确保一切都是正确的。如果我们希望减少应用在部署后崩溃的次数，我们需要:</p><ul class=""><li id="7c71" class="og oh it lb b lc ld lf lg li oi lm oj lq ok lu ol om on oo bi translated">让应用程序在启动时验证每个配置选项。</li><li id="cde5" class="og oh it lb b lc op lf oq li or lm os lq ot lu ol om on oo bi translated">编写支持完整CI/CD方法的开发人员软件。</li><li id="5bda" class="og oh it lb b lc op lf oq li or lm os lq ot lu ol om on oo bi translated">引入合同测试作为标准实践，以发现我们服务中的漏洞。</li></ul></div></div>    
</body>
</html>