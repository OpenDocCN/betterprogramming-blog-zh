# Android 中的依赖注入与 Dagger2

> 原文：<https://betterprogramming.pub/dependency-injection-in-android-with-dagger2-d260b8a72bb0>

## 了解你需要知道的关于 Dagger2 的一切

![](img/6a45ea3e425a96de5c3f55eed2b3beaa.png)

图片由 [NESA 制作](https://unsplash.com/@nesabymakers?utm_source=medium&utm_medium=referral)在 [Unsplash](https://unsplash.com?utm_source=medium&utm_medium=referral) 上拍摄

1.  [什么是依赖注入？](#f0d1)
2.  [依赖注入的类型](#3d94)
3.  [为您的应用选择正确的技术](http://62c4)
4.  [Android 中的依赖注入](#85dc)
5.  [匕首的历史及其优点](#3ca9)
6.  [术语](#b853)
7.  [整合](#4221)
8.  [Dagger2 设置](#9fca)
9.  [用法](#ef07)
10.  [多模块应用程序中的 dagger 2](#ea82)
11.  [有用链接](#e9c2)

# 什么是依赖注入？

依赖注入是类获取其他类的引用的另一种方式。例如，有一个类`BananaMilkshake`，它可能需要`Milk`类。在这里，`BananaMilkShake`依赖于`Milk`类。通常这些必需的类，像`Milk`，被称为依赖。

实现依赖注入为您提供了以下优势:

*   代码的可重用性
*   易于重构
*   易于测试

依赖注入有三种类型

1.  在类本身中创建所需的对象(类似于在`BananaMilkshake`类中创建的`Milk`类对象)。
2.  从其他地方获取所需的对象(比如 Android-activity 组件中的上下文)。
3.  提供所需的类对象作为参数(可以通过构造函数来创建)。

# 依赖注入的类型

## 手动依赖注入

让我们以上面的例子为例，看看在没有依赖注入的情况下它是如何工作的。看一看:

手动依赖注入

这似乎很容易做到，因为这是一个简单的例子。

这里的`BananaMilkshake`和`Milk`类是紧密耦合的，这在编程世界中不是一件好事。`BananaMilkshake`在测试的时候对`Milk` 也有依赖，这就很难了。

当它变得复杂时怎么办——比如当`BananaMilkshake`需要多个类时，如下所示:

复杂情况下的手动依赖注入

是不是显得势不可挡？在实时情况下会更复杂。

## 手动依赖注入的替代方法

基本上，我们在这里做的是创建所有类都可用的更高级别的类，创建我们在其中需要的所有对象，并在需要时从不同的类访问它们。看一看:

手动依赖注入

下面是我们所做的:我们有一个 a 对象类，`ServiceGenerater`，在其中我们创建了我们需要的所有对象，当`BananaMilkshake`需要`Milk`类时，它只是从`ServiceGenerater`中获取对象。

服务生成器的问题:

1.  维护生存期对象很困难，这可能会导致在某个时候崩溃。
2.  这也使得测试变得复杂，因为所有的依赖都应该来自一个类。
3.  我们无法维持对象的范围。

## 依赖注入

有两种方法可以通过 DI。

*   **构造函数注入:**通过这种方式，我们可以在构造函数中传递所有需要类的对象，并使用它们。看一看:

构造函数注入

*   **字段注入(或者 setter 注入):**某些 Android 框架类，比如 activities 和 fragments，是由系统实例化的，所以构造函数注入是不可能的。
*   使用字段注入，依赖关系在类创建后被实例化。代码应该是这样的:

现场注射

# 为您的应用选择正确的技术

如上所述，我们有不同类型的方法来实现依赖注入。

正如 Android 团队建议的那样，如果你的应用程序包含三个或更少的屏幕，你可以不进行依赖注入。但是超过三个屏幕时，总是推荐使用依赖注入。

如果您对 DI 提供的功能有深入的了解，那么选择它会更容易

*   **可重用性:**随着项目的扩展，创建依赖关系的多个实现将变得更加容易，但是有了 DI 反转控制，依赖类不再控制依赖关系的创建方式
*   **易于重构:**依赖对象的创建可以在编译时检查，而不是在运行时隐藏。
*   **易于测试:**有了 DI，它将不再是一个产生依赖的类，所以测试将会更容易。

# Android 中的依赖注入

安卓里的 DI 和别人没什么区别。在这里，Android 组件，如 activities、fragments 等，依赖于 reform、Glide 等实例。在 Android 中，我们用[匕首](https://dagger.dev/)来维护 DI。

使用 Dagger 的主要优点是它会在编译时生成创建所需对象的代码。这有两个主要优点。一个是不再有运行时错误，因为 Dagger 是一个编译时静态库。另一个是你不再需要写所有的代码来维护依赖关系。

简而言之，Dagger 提供了编译时依赖管理，无需编写样板代码。

# 匕首的历史及其优势

## 匕首的历史

Dagger 是由 Square 的开发人员在 2012 年创建的一个依赖注入库。Dagger1 使用反射的概念来创建类和依赖关系的实例。

之后，他们与谷歌的开发人员合作，通过去除反射来构建 Dagger2，这非常强大。Dagger2 基于注释处理器。

## 优势

Dagger 通过以下方式将您从编写乏味且容易出错的样板代码中解放出来:

*   创建您在手动 DI 部分手动实现的`AppContainer`代码(应用程序图)。
*   为应用程序图中可用的类创建工厂。这就是依赖性在内部得到满足的方式，也是我们不需要编写所有样板代码的原因。
*   重用依赖项或创建类型的新实例取决于您如何使用范围配置类型。
*   Daggers 还通过释放不再使用的对象来关心内存管理。

# 术语

## @模块

这用于创建依赖类对象的类。

## @提供

这用于模块类内部的方法，并提供依赖关系。

## @注入

这用于请求依赖项的构造函数、字段或方法中。

## @组件

模块类不会直接提供依赖关系——相反，它会创建一个接口作为`@Module`和`@Inject`之间的桥梁。

## @单身

这也用于模块中的方法，但是，具体来说，依赖对象应该只创建一次。

# 综合

Dagger2 集成和其他库一样简单——您只需要将下面这段代码包含到`build.gradle`文件中。

Dagger2 集成

确保您使用的是[这里](https://github.com/google/dagger/releases)的最新版本。

# Dagger2 设置

正如我所说的，模块类中会有返回依赖关系的`@Provides`方法，所以我们的第一项工作是创建模块类。我们来看看怎么做。

这里我将创建一个改进实例，我需要 OkHttp 和 Moshi 实例。与此同时，我将创建`ApiService`类实例来调用服务调用。看一看:

Dagger2 模块设置

我们可以创建任意多的模块，关键是要提到`appcomponent`类中的所有模块——这是我们的下一步。在此之前，我们为什么需要不同的模块类？我们不能在一个模块类中包含所有的依赖吗？

当然，但是在一个模块中声明所有的网络、数据和其他依赖项会在项目增长时造成混乱，所以如果我们为不同类型的依赖项创建不同的模块类，会更清楚、更容易理解。

既然我们已经创建了所需网络依赖关系的实例，下一步将是创建`AppComponent`，它充当`module`和`inject`之间的桥梁。

Dagger2 组件设置

如果您清楚地观察了上面的代码，我使用了六个模块类来提供所有需要的依赖项，并在我的`AppcCmponent`接口中声明了它们。

现在，我们已经完成了所有的工作——唯一剩下的就是将`AppComponent`与应用程序生命周期联系起来。在此之前，我们需要重新构建项目，这样 Dagger 将在后台创建所有的样板代码。成功重建后，就该在应用程序类中声明`AppComponent`了。看一看:

将组件与应用程序生命周期联系起来

这就是我们要通过 Dagger2 建立对 onjection 的依赖所要做的一切。

# 使用

既然我们已经完成了基本的设置和所有的事情，剩下的唯一事情就是将依赖项注入到所需的类中并使用它们。让我们看看如何注入一个改造实例。

dagger2 的用法

这被称为*字段注入*，因为我们通过一个称为变量的字段注入所需的依赖关系。

我们还可以通过构造函数注入来实现这一点，我们将通过类的构造函数传递所需的依赖关系。看一看:

通过构造函数使用 Dagger2

# 多模块应用中的匕首

要理解这个模块，首先你应该理解什么是多模块应用。

当我们开始一个新的应用程序时，我们不知道随着时间的推移我们需要做的一切是正常的。这意味着久而久之，你的产品经理将提出不同的想法，以实施在应用程序中。在软件世界里很正常。一般来说，在这种情况下，我们所做的是在同一个模块中创建那些特性，随着时间的推移，这些特性会在维护代码时引起严重的问题。

这就是多模块概念发挥作用的时候了。

无论需要什么样的新特性，都将作为项目中的新模块来实现，因此代码的维护将变得简单，也更容易处理——即使有多个开发人员在这个项目中工作

现在我们知道了什么是多模块项目，是时候处理模块间的依赖注入了。

应用程序的每个模块都需要某些资源，这是很常见的，比如用于服务调用的翻新实例或`SharedPreference`实例。所以我们需要跨模块共享资源，而不是创建新的实例——这就是多模块项目中依赖注入的样子。

看看我们是怎么实现的吧。

我们主要做的是为每个功能模块创建一个单独的组件。假设我们有一个登录模块。正如我所说的，我们需要一个登录组件，如下所示创建:

Dagger2 模块组件创建

这就是我们如何在模块级实现组件。

现在，让我们看看如何使用它们。

模块组件使用

# 有用的链接

[](https://developer.android.com/training/dependency-injection/dagger-android) [## 在 Android 应用中使用 Dagger | Android 开发者

### Dagger 基础页面解释了 Dagger 如何帮助您在应用程序中自动化依赖注入。用匕首，你…

developer.android.com](https://developer.android.com/training/dependency-injection/dagger-android) [](https://developer.android.com/training/dependency-injection/dagger-multi-module) [## 在多模块应用中使用 Dagger | Android 开发者

### 注意:在这一页中，提到的模块是指 Gradle 模块，而不是 Dagger 模块。在一个有多个…

developer.android.com](https://developer.android.com/training/dependency-injection/dagger-multi-module)