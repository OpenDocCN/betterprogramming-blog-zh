<html>
<head>
<title>Data Structures With JavaScript: Graphs</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">JavaScript的数据结构:图形</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/data-structures-with-javascript-graphs-42084ec4db22?source=collection_archive---------6-----------------------#2020-07-17">https://betterprogramming.pub/data-structures-with-javascript-graphs-42084ec4db22?source=collection_archive---------6-----------------------#2020-07-17</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="6c4a" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">我们来谈谈图形数据结构</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/25ad9adb669dbcde0e04f66fc5633db4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*VXlI6qBDGBD-b-ob"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">由<a class="ae ky" href="https://unsplash.com/@fabioha?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">法比奥</a>在<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>拍摄的照片。</p></figure><p id="b8ae" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">图形数据结构是节点的集合。但是与树不同的是，没有关于节点应该如何连接的规则。没有根节点、父节点或子节点。此外，节点被称为顶点，它们由边连接。下面是一个图表的示例:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi lv"><img src="../Images/012dd7b67cbecb478cb5f6c06387631c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ippUFJwESODRk9SQK4Fn8Q.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">作者照片。</p></figure><p id="3f0d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">通常，图的边比顶点多。边数多于顶点数的图称为稠密图。如果边比顶点少，那么它是一个稀疏图。</p><p id="c98b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在一些图中，边是有方向的。这些被称为有向图或有向图。边都是双向的图称为无向图、无序图或简称为图。默认情况下，图被认为是无序的。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi lw"><img src="../Images/abcade9c371db991ed149912b4378d09.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*9qbAQu73FrVY0nZdabCFTg.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">作者照片。</p></figure><p id="6450" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在一些图中，边可以有权重。这些被称为加权图。重量通常被称为成本。每个成本代表什么取决于应用。例如，每个成本可能是你在社交网络中认识某人的概率、交通堵塞率等。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi lx"><img src="../Images/af349a0050973f4621e6fc091f3f071e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ER9FygH8tDCegmtZ64jE8g.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">作者照片。</p></figure><p id="a340" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">路径是图形数据结构的另一个重要部分。它是图中顶点的序列。如果从一个顶点到另一个顶点有一条路，则认为图是连通的。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ly"><img src="../Images/a0e8f97aa2e8077cdbd6c584210206c0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*b-61Dv2AdnB8pj7wtbki0A.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">作者照片。</p></figure><p id="f36c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">一个圈是一条起点也是终点的路径。树是一种特殊类型的图，它包括从起始顶点(根)到某个其他顶点的路径。然而，该树没有循环。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi lz"><img src="../Images/5ff6ea7a803358d251df74896bdab1d5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Z3nIazv_t6m-pz9eoNNS8w.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">作者照片。</p></figure></div><div class="ab cl ma mb hx mc" role="separator"><span class="md bw bk me mf mg"/><span class="md bw bk me mf mg"/><span class="md bw bk me mf"/></div><div class="im in io ip iq"><h1 id="b9f4" class="mh mi it bd mj mk ml mm mn mo mp mq mr jz ms ka mt kc mu kd mv kf mw kg mx my bi translated"><strong class="ak">图形表示</strong></h1><p id="a7aa" class="pw-post-body-paragraph kz la it lb b lc mz ju le lf na jx lh li nb lk ll lm nc lo lp lq nd ls lt lu im bi translated">图可以表示为一组顶点和一组边。让我们来看看这张图表:</p><ul class=""><li id="384a" class="ne nf it lb b lc ld lf lg li ng lm nh lq ni lu nj nk nl nm bi translated">G = (V，E)</li><li id="705a" class="ne nf it lb b lc nn lf no li np lm nq lq nr lu nj nk nl nm bi translated">V = {A，B，C，D，E}</li></ul><p id="103a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们可以列出所有的顶点，并将它们存储在对象<code class="fe ns nt nu nv b">V</code>中。每条边可以作为一对顶点列出。</p><p id="5ae4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">对于加权图，我们可以将每条边的成本添加到以下符号中:</p><ul class=""><li id="0905" class="ne nf it lb b lc ld lf lg li ng lm nh lq ni lu nj nk nl nm bi translated">V = {A，B，C，D，E}</li><li id="09ba" class="ne nf it lb b lc nn lf no li np lm nq lq nr lu nj nk nl nm bi translated">E = {(A，B，1)，(D，A，6)，(B，D，7)，(D，E，3)，(B，E，3)，(B，C，5)，(E，C，5)}</li></ul><p id="5cfa" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在无向图中，我们必须分别列出所有可能的方向:</p><ul class=""><li id="a478" class="ne nf it lb b lc ld lf lg li ng lm nh lq ni lu nj nk nl nm bi translated">E = {(A，B)、(A，D)、(B，A)、(C，D)、(B，D)、(B，E)、(C，B)、(C，E)、(D，A)、(D，B)、(D，E)、(E，B)、(E，B)、(E，C)、(E，D) }</li></ul></div><div class="ab cl ma mb hx mc" role="separator"><span class="md bw bk me mf mg"/><span class="md bw bk me mf mg"/><span class="md bw bk me mf"/></div><div class="im in io ip iq"><h1 id="91e6" class="mh mi it bd mj mk ml mm mn mo mp mq mr jz ms ka mt kc mu kd mv kf mw kg mx my bi translated"><strong class="ak">实现</strong></h1><p id="ece9" class="pw-post-body-paragraph kz la it lb b lc mz ju le lf na jx lh li nb lk ll lm nc lo lp lq nd ls lt lu im bi translated">图可以通过邻接表和邻接矩阵来实现。</p><h2 id="3ec2" class="nw mi it bd mj nx ny dn mn nz oa dp mr li ob oc mt lm od oe mv lq of og mx oh bi translated"><strong class="ak">邻接表</strong></h2><p id="7369" class="pw-post-body-paragraph kz la it lb b lc mz ju le lf na jx lh li nb lk ll lm nc lo lp lq nd ls lt lu im bi translated">有了邻接表，我们就有了一个顶点的主列表。对于每条边，每个起始顶点都维护一个结束顶点列表。每个顶点都有一个它的近邻列表。</p><p id="5516" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们可以用面向对象的方式实现它。下面是JavaScript中图形和顶点的样子:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi oi"><img src="../Images/16b3c054b61d8ab9179ac270906d9f56.png" data-original-src="https://miro.medium.com/v2/resize:fit:762/format:webp/1*x99hk0OrGMGaSazOBrorMA.png"/></div></figure><p id="9ca3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">同样，让我们创建添加顶点和边的方法:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi oj"><img src="../Images/6f3445ee330eae8e086cab86e68c18e1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1100/format:webp/1*uC6QulFPARYxfgGhG1LEKw.png"/></div></figure><h2 id="d192" class="nw mi it bd mj nx ny dn mn nz oa dp mr li ob oc mt lm od oe mv lq of og mx oh bi translated"><strong class="ak">邻接矩阵</strong></h2><p id="64fe" class="pw-post-body-paragraph kz la it lb b lc mz ju le lf na jx lh li nb lk ll lm nc lo lp lq nd ls lt lu im bi translated">使用邻接矩阵，每个顶点都被写成网格中的行标题和列标题。如果边存在于顶点之间，那么它的权重可以由适当的行和列的交点来表示。对于无向图，我们可以简单地用一个布尔值来表示每条边。</p><p id="e77f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">邻接矩阵可以在二维数组中实现。图的实际连通性将由边的2D阵列来定义:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi ok"><img src="../Images/2c1a4310f9bb7ffa52e30fe67e5f243d.png" data-original-src="https://miro.medium.com/v2/resize:fit:530/format:webp/1*X3ytlhLrlrR9aCrTsp3iBg.png"/></div></figure></div><div class="ab cl ma mb hx mc" role="separator"><span class="md bw bk me mf mg"/><span class="md bw bk me mf mg"/><span class="md bw bk me mf"/></div><div class="im in io ip iq"><h1 id="00e0" class="mh mi it bd mj mk ml mm mn mo mp mq mr jz ms ka mt kc mu kd mv kf mw kg mx my bi translated"><strong class="ak">结论</strong></h1><p id="580b" class="pw-post-body-paragraph kz la it lb b lc mz ju le lf na jx lh li nb lk ll lm nc lo lp lq nd ls lt lu im bi translated">使用矩阵优于列表的主要优点是，确定两个顶点之间是否存在边需要简单的数组查找。但是一个矩阵在空间上不是很有效率。例如，对于稀疏图，矩阵的大部分将是空的。对于一个无向图，一半的存储信息只是简单的复制。您应该使用哪种方法取决于您所代表的应用程序和信息以及您如何处理它。</p><p id="4cfd" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">图形是一种非常流行的数据结构。谷歌地图用它来计算路线。WWW被认为是一个图，网站之间的每个链接都是一条边。脸书用一个未被发现的图表向你推荐朋友。应用是无限的！在下一篇文章中，我们将讨论如何使用不同的图表。</p><p id="d3e1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">不断学习，不断成长。</p><p id="47b0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">感谢阅读！</p></div></div>    
</body>
</html>