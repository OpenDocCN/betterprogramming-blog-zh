<html>
<head>
<title>Using the Spread Operator in JavaScript</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">在JavaScript中使用Spread运算符</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/using-spread-operator-in-javascript-1b89f0c77ab3?source=collection_archive---------5-----------------------#2019-10-22">https://betterprogramming.pub/using-spread-operator-in-javascript-1b89f0c77ab3?source=collection_archive---------5-----------------------#2019-10-22</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="3162" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">spread语法允许我们将一组对象(如数组)分解成单独的参数</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/8fee8d7aa4e634d56853b7e3b6f5c950.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*0r5FhnIzYOcyOJul"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">由<a class="ae ky" href="https://unsplash.com/@jessysmith?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">鞠波·史密斯</a>在<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</p></figure><p id="83b5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">spread语法允许我们将一组对象(如数组)分解成单独的参数，或者将它们插入到不同的可迭代对象(如数组)中。</p><p id="b1a7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">有了2018版本的JavaScript，我们还可以将一个对象的属性传播到另一个对象中，将键和值传播到另一个对象中。扩展语法由对象前的三个句点表示。</p><p id="d82c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">例如，我们可以写:</p><pre class="kj kk kl km gt lv lw lx ly aw lz bi"><span id="6d7f" class="ma mb it lw b gy mc md l me mf">...arr</span></pre><p id="e719" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">spread语法的工作方式是复制原始数组的值，然后将它们插入到另一个数组中，或者按照它们在数组中出现的顺序将它们作为函数中的参数列表以相同的顺序放置。</p><p id="ed1a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">当spread运算符用于对象时，键值对的出现顺序与它们在原始对象中的出现顺序相同。</p><p id="8f49" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们可以使用spread语法将一组值作为函数的参数展开。例如，我们可以写:</p><pre class="kj kk kl km gt lv lw lx ly aw lz bi"><span id="e589" class="ma mb it lw b gy mc md l me mf">const arr = [1,2,3];<br/>const add = (a,b,c) =&gt; a+b+c;<br/>add(...arr) // returns 6</span></pre><p id="3e0c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在上面的示例中，spread运算符将变量按照它们在数组中出现的顺序展开到参数中。所以1传入<code class="fe mg mh mi lw b">a</code>，2传入<code class="fe mg mh mi lw b">b</code>，3传入<code class="fe mg mh mi lw b">c</code>。</p></div><div class="ab cl mj mk hx ml" role="separator"><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo"/></div><div class="im in io ip iq"><h1 id="68b0" class="mq mb it bd mr ms mt mu mv mw mx my mz jz na ka nb kc nc kd nd kf ne kg nf ng bi translated">分散阵列</h1><p id="f17b" class="pw-post-body-paragraph kz la it lb b lc nh ju le lf ni jx lh li nj lk ll lm nk lo lp lq nl ls lt lu im bi translated">对于数组，我们也可以使用spread语法将一个数组的值插入另一个数组。例如，我们可以写:</p><pre class="kj kk kl km gt lv lw lx ly aw lz bi"><span id="bf05" class="ma mb it lw b gy mc md l me mf">const arr = [1,2,3];<br/>const arr2 = ['a','b','c',...arr,'d']; // arr2 is ['a','b','c',1,2,3,'d']</span></pre><p id="c949" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">正如我们所看到的，spread操作符将值准确地插入到我们展开数组的位置，与它们在数组中出现的顺序相同。</p><p id="ea73" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">所以，1插在<code class="fe mg mh mi lw b">a</code>和<code class="fe mg mh mi lw b">d</code>之间，然后2插在1和<code class="fe mg mh mi lw b">d</code>之间，3插在2和<code class="fe mg mh mi lw b">d</code>之间。结果是，我们用spread操作符将一个数组的值复制到另一个数组中，复制的顺序与它们出现的顺序相同，并且正好是放置数组spread表达式的位置。</p><p id="a102" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">没有spread操作符，我们必须编写循环来将它们插入到我们想要的位置。我们<code class="fe mg mh mi lw b">slice</code>将数组分成两部分，然后对这三部分调用<code class="fe mg mh mi lw b">concat</code>，然后将结果赋给你插入内容的数组。光是想想就听起来很痛苦。</p><p id="01ff" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">注意，使用spread操作符，只有数组的第一级被展开。如果我们有嵌套或多维数组，它将原样复制引用。它不会对嵌套的项目做任何事情。</p><p id="9337" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">借助ES2018，我们可以对对象做同样的事情，如下所示:</p><pre class="kj kk kl km gt lv lw lx ly aw lz bi"><span id="c64b" class="ma mb it lw b gy mc md l me mf">const obj = {a: 1, b: 2};<br/>let objClone = { ...obj }; // objClone is {a: 1, b: 2}</span></pre><p id="158a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这将创建对象的浅表副本。这意味着只复制对象的第一级。</p><p id="8cc8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">对于嵌套对象，它将原样复制引用。它不会对嵌套的项目做任何事情。对象的顶层键和值将被复制到<code class="fe mg mh mi lw b">objClone</code>。</p><p id="86c4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">因此，如果我们有嵌套的对象，我们得到:</p><pre class="kj kk kl km gt lv lw lx ly aw lz bi"><span id="9e7b" class="ma mb it lw b gy mc md l me mf">const obj = {<br/>  a: 1,<br/>  b: {<br/>    c: 2<br/>  }<br/>};<br/>let objClone = {<br/>  ...obj<br/>};<br/>console.log(objClone) </span></pre><p id="3a43" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在<code class="fe mg mh mi lw b">objClone</code>中，我们得到:</p><pre class="kj kk kl km gt lv lw lx ly aw lz bi"><span id="cd63" class="ma mb it lw b gy mc md l me mf">{<br/>  a: 1,<br/>  b: {<br/>    c: 2<br/>  }<br/>}</span></pre><p id="d190" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">因此，嵌套对象将引用与原始对象相同的对象。</p><p id="0af6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">spread运算符可用作以前存在的其他函数的替代函数。</p><p id="4c3b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">例如，我们可以用它来代替<code class="fe mg mh mi lw b">apply</code>函数来传递函数的参数。<code class="fe mg mh mi lw b">apply</code>函数将它所调用的函数的参数数组作为第二个参数。</p><p id="fe0f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">对于<code class="fe mg mh mi lw b">apply</code>函数，我们调用如下:</p><pre class="kj kk kl km gt lv lw lx ly aw lz bi"><span id="73da" class="ma mb it lw b gy mc md l me mf">const arr = [1,2,3]<br/>const sum = (a,b,c)=&gt; a+b+c;<br/>sum.apply(null, arr); // 6</span></pre><p id="6d0a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">使用spread语法，我们可以改为编写以下代码:</p><pre class="kj kk kl km gt lv lw lx ly aw lz bi"><span id="c97f" class="ma mb it lw b gy mc md l me mf">const arr = [1,2,3]<br/>const sum = (a,b,c)=&gt; a+b+c;<br/>sum(...arr)</span></pre><p id="4fb6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">spread运算符也处理字符串。我们将spread操作符应用于字符串，得到一个包含字符串中各个字符的数组。</p><p id="16bd" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">例如，如果我们写:</p><pre class="kj kk kl km gt lv lw lx ly aw lz bi"><span id="226e" class="ma mb it lw b gy mc md l me mf">const str = 'abcd';<br/>const chars = [...str];</span></pre><p id="7982" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们得到<code class="fe mg mh mi lw b">[“a”, “b”, “c”, “d”]</code>作为<code class="fe mg mh mi lw b">chars</code>的值。</p></div><div class="ab cl mj mk hx ml" role="separator"><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo"/></div><div class="im in io ip iq"><h1 id="a06b" class="mq mb it bd mr ms mt mu mv mw mx my mz jz na ka nb kc nc kd nd kf ne kg nf ng bi translated">多次使用扩展运算符</h1><p id="3b00" class="pw-post-body-paragraph kz la it lb b lc nh ju le lf ni jx lh li nj lk ll lm nk lo lp lq nl ls lt lu im bi translated">我们可以在一个地方多次使用spread语法。例如，我们可以有以下内容:</p><pre class="kj kk kl km gt lv lw lx ly aw lz bi"><span id="481e" class="ma mb it lw b gy mc md l me mf">const arr = [1,2,3];<br/>const arr2 = [4,5];<br/>const sum = (a,b,c,d,e,f)=&gt; a+b+c+d+e+f;<br/>sum(...arr, ...arr2, 6)</span></pre><p id="d4ce" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">像往常一样，spread语法将数字数组按照它们在中出现的顺序展开到数组的参数中。</p><p id="4c6e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">所以，<code class="fe mg mh mi lw b">sum(…arr, …arr2, 6)</code>和<code class="fe mg mh mi lw b">sum(1,2,3,4,5,6)</code>一样。</p><p id="0a09" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">1、2、3是前三个自变量，是<code class="fe mg mh mi lw b">arr</code>的条目，顺序相同，4、5是第四、第五个自变量，分散在1、2、3之后。</p><p id="f876" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">最后，我们把6作为最后一个参数。我们还可以看到spread语法与普通的函数调用语法一起工作。</p></div><div class="ab cl mj mk hx ml" role="separator"><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo"/></div><div class="im in io ip iq"><h1 id="0f46" class="mq mb it bd mr ms mt mu mv mw mx my mz jz na ka nb kc nc kd nd kf ne kg nf ng bi translated">在构造函数中使用它</h1><p id="e217" class="pw-post-body-paragraph kz la it lb b lc nh ju le lf ni jx lh li nj lk ll lm nk lo lp lq nl ls lt lu im bi translated">我们可以使用spread操作符作为对象构造函数的参数。例如，如果我们想创建一个新的<code class="fe mg mh mi lw b">Date</code>对象，我们可以写:</p><pre class="kj kk kl km gt lv lw lx ly aw lz bi"><span id="164a" class="ma mb it lw b gy mc md l me mf">let <!-- -->dateFields = [2001, 0, 1];<br/>let <!-- -->date = new Date(...dateFields);</span></pre><p id="4364" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe mg mh mi lw b">dateFields</code>数组中的项目按照它们出现的顺序作为参数传递给构造函数。另一种写法可能会更长，比如:</p><pre class="kj kk kl km gt lv lw lx ly aw lz bi"><span id="0464" class="ma mb it lw b gy mc md l me mf">let <!-- -->dateFields = [2001, 0, 1];<br/>const year = dateFields[0];<br/>const month = dateFields[1];<br/>const day = dateFields[2];<br/>let <!-- -->date = new Date(year, month, day);</span></pre></div><div class="ab cl mj mk hx ml" role="separator"><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo"/></div><div class="im in io ip iq"><h1 id="c67b" class="mq mb it bd mr ms mt mu mv mw mx my mz jz na ka nb kc nc kd nd kf ne kg nf ng bi translated">复制项目</h1><p id="780a" class="pw-post-body-paragraph kz la it lb b lc nh ju le lf ni jx lh li nj lk ll lm nk lo lp lq nl ls lt lu im bi translated">spread语法也可用于创建数组或对象的浅层副本，方法是创建数组或对象的键值对的顶级元素的副本，然后将它们插入到使用spread运算符的位置。</p><p id="ee3c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">对于复制数组，我们可以写:</p><pre class="kj kk kl km gt lv lw lx ly aw lz bi"><span id="590b" class="ma mb it lw b gy mc md l me mf">const arr = [1, 2, 3];<br/>const arr2 = [...arr, 4, 5];</span></pre><p id="1140" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">上面的例子，<code class="fe mg mh mi lw b">arr2</code>是<code class="fe mg mh mi lw b">[1,2,3,4,5]</code>，而<code class="fe mg mh mi lw b">arr1</code>还是<code class="fe mg mh mi lw b">[1,2,3]</code>。</p><p id="28da" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe mg mh mi lw b">arr1</code>没有被<code class="fe mg mh mi lw b">arr2</code>引用，因为spread操作符实际上复制了数组，然后插入了值。请注意，这不适用于多维数组，因为它只复制顶级元素。</p><p id="3d70" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们可以在一个数组或对象中多次应用spread语法。数组的一个例子是:</p><pre class="kj kk kl km gt lv lw lx ly aw lz bi"><span id="1ebb" class="ma mb it lw b gy mc md l me mf">let <!-- -->arr = [1, 2, 3];<br/>let <!-- -->arr2 = [4, 5];<br/>let <!-- -->arr3 = [...arr2, ...arr];</span></pre><p id="1196" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在上面的例子中，我们得到了<code class="fe mg mh mi lw b">[4,5,1,2,3]</code>。<code class="fe mg mh mi lw b">arr1</code>和<code class="fe mg mh mi lw b">arr2</code>不受影响，因为来自<code class="fe mg mh mi lw b">arr1</code>和<code class="fe mg mh mi lw b">arr2</code>的值的副本被插入<code class="fe mg mh mi lw b">arr3</code>。</p></div><div class="ab cl mj mk hx ml" role="separator"><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo"/></div><div class="im in io ip iq"><h1 id="35b2" class="mq mb it bd mr ms mt mu mv mw mx my mz jz na ka nb kc nc kd nd kf ne kg nf ng bi translated">展开运算符和对象</h1><p id="bbf4" class="pw-post-body-paragraph kz la it lb b lc nh ju le lf ni jx lh li nj lk ll lm nk lo lp lq nl ls lt lu im bi translated">在ES2018中，spread运算符处理对象文字。然后，可以用spread操作符将一个对象的键值对插入到另一个对象中。</p><p id="7901" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果在同一个对象中有两个对象具有相同的关键点，并且spread运算符应用于这两个对象，那么后面插入的对象将覆盖前面插入的对象。</p><p id="ac05" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">例如，如果我们有以下内容:</p><pre class="kj kk kl km gt lv lw lx ly aw lz bi"><span id="fc4c" class="ma mb it lw b gy mc md l me mf">let obj1 = {foo: 'bar', a: 1};<br/>let obj2 = {foo: 'baz', b: 1};<br/>let obj3 = {...obj1, ...obj2 }</span></pre><p id="bf79" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">然后我们得到<code class="fe mg mh mi lw b">{foo: “baz”, a: 1, b: 1}</code>作为<code class="fe mg mh mi lw b">obj3</code>的值，因为<code class="fe mg mh mi lw b">obj1</code>在<code class="fe mg mh mi lw b">obj2</code>之前展开。</p><p id="7601" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">它们都有<code class="fe mg mh mi lw b">foo</code>作为对象中的键。首先，<code class="fe mg mh mi lw b">foo: 'bar'</code>被展开操作符插入到<code class="fe mg mh mi lw b">obj3</code>。然后，<code class="fe mg mh mi lw b">foo: 'baz'</code>在<code class="fe mg mh mi lw b">obj2</code>被合并后覆盖<code class="fe mg mh mi lw b">foo</code>的值，因为它有相同的键<code class="fe mg mh mi lw b">foo</code>但后来被插入。</p><p id="7afb" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这对于合并对象非常有用，因为我们不必遍历键并输入值，这比一行代码要多得多。</p><p id="6bdf" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">需要注意的一点是，我们不能在常规对象和可迭代对象之间混合spread运算符。例如，如果我们写下以下内容，我们将得到<code class="fe mg mh mi lw b">TypeError</code>:</p><pre class="kj kk kl km gt lv lw lx ly aw lz bi"><span id="8ff3" class="ma mb it lw b gy mc md l me mf">let <!-- -->obj = {foo: 'bar'};<br/>let <!-- -->array = [...obj];</span></pre></div><div class="ab cl mj mk hx ml" role="separator"><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo"/></div><div class="im in io ip iq"><h1 id="4945" class="mq mb it bd mr ms mt mu mv mw mx my mz jz na ka nb kc nc kd nd kf ne kg nf ng bi translated">结论</h1><p id="7a22" class="pw-post-body-paragraph kz la it lb b lc nh ju le lf ni jx lh li nj lk ll lm nk lo lp lq nl ls lt lu im bi translated">正如我们所见，spread语法是JavaScript的一个非常方便的特性。它让我们把不同的数组组合成一个。</p><p id="a500" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">此外，它让我们只用一行代码就可以将数组作为参数传递给函数。借助ES2018，我们还可以使用相同的运算符将键值对扩展到其他对象中，从而将一个对象的键值对填充到另一个对象中。</p><p id="4d5c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">spread操作符的工作方式是复制顶级项，并在使用spread操作符的地方填充它们，因此我们也可以使用它来制作数组和对象的浅层副本。</p></div></div>    
</body>
</html>