<html>
<head>
<title>Opinionated React: Use Context for Your Shared State</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">固执己见的反应:为你的共享状态使用上下文</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/opinionated-react-use-context-for-your-shared-state-31d2a8d278ed?source=collection_archive---------17-----------------------#2020-06-23">https://betterprogramming.pub/opinionated-react-use-context-for-your-shared-state-31d2a8d278ed?source=collection_archive---------17-----------------------#2020-06-23</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="960d" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">在应用中使用React的上下文API的有效模式</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/d5f54ab3b7a7ed734afda5f456850c1f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*k0-SFHa7_1AK4zB4f1XXhw.jpeg"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">照片由<a class="ae ky" href="https://unsplash.com/@priscilladupreez?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">普里西拉·杜·普里兹</a>在<a class="ae ky" href="/collections/10646975/wise-humanity?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>拍摄</p></figure><h1 id="7996" class="kz la it bd lb lc ld le lf lg lh li lj jz lk ka ll kc lm kd ln kf lo kg lp lq bi translated">介绍</h1><p id="2454" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">我已经和React合作了四年多。在这段时间里，我形成了一些我认为应用程序应该是什么样子的观点。这是这类固执己见的文章系列的第5部分。</p></div><div class="ab cl mn mo hx mp" role="separator"><span class="mq bw bk mr ms mt"/><span class="mq bw bk mr ms mt"/><span class="mq bw bk mr ms"/></div><div class="im in io ip iq"><h1 id="90aa" class="kz la it bd lb lc mu le lf lg mv li lj jz mw ka ll kc mx kd ln kf my kg lp lq bi translated">我对上下文的反应模式</h1><p id="90c1" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">我的好友Nader <a class="ae ky" href="https://twitter.com/dabit3/status/1233180102747246593" rel="noopener ugc nofollow" target="_blank">问</a>我如何在我的应用程序中使用React上下文。我答应过要写下来，所以我们来了。</p></div><div class="ab cl mn mo hx mp" role="separator"><span class="mq bw bk mr ms mt"/><span class="mq bw bk mr ms mt"/><span class="mq bw bk mr ms"/></div><div class="im in io ip iq"><h1 id="2f87" class="kz la it bd lb lc mu le lf lg mv li lj jz mw ka ll kc mx kd ln kf my kg lp lq bi translated">为什么</h1><p id="3ee7" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">在某些情况下，多个组件需要您的应用程序状态。如果这个共享状态需要大量的训练，我将使用上下文。在过去，Redux是避免支柱钻孔的流行解决方案。但是，我相信Redux已经不需要了。React的上下文API非常适合这一点。</p></div><div class="ab cl mn mo hx mp" role="separator"><span class="mq bw bk mr ms mt"/><span class="mq bw bk mr ms mt"/><span class="mq bw bk mr ms"/></div><div class="im in io ip iq"><h1 id="467d" class="kz la it bd lb lc mu le lf lg mv li lj jz mw ka ll kc mx kd ln kf my kg lp lq bi translated">用例—重要！</h1><ul class=""><li id="e604" class="mz na it lt b lu lv lx ly ma nb me nc mi nd mm ne nf ng nh bi translated">您应该对全局状态使用React上下文。也就是说，一个全球国家没有那么多的组成部分。全局状态的一些很好的例子是当前用户、当前语言设置或功能标志的映射。</li><li id="46b7" class="mz na it lt b lu ni lx nj ma nk me nl mi nm mm ne nf ng nh bi translated">您不需要只对全局状态使用上下文。上下文可以应用于应用程序的特定子树。</li><li id="cb2e" class="mz na it lt b lu ni lx nj ma nk me nl mi nm mm ne nf ng nh bi translated">拥有多个特定于子树的上下文是很常见的</li></ul></div><div class="ab cl mn mo hx mp" role="separator"><span class="mq bw bk mr ms mt"/><span class="mq bw bk mr ms mt"/><span class="mq bw bk mr ms"/></div><div class="im in io ip iq"><h1 id="98c5" class="kz la it bd lb lc mu le lf lg mv li lj jz mw ka ll kc mx kd ln kf my kg lp lq bi translated">灵感</h1><p id="abbd" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">我最初是从Kent C. Dodd的精彩文章“如何有效地使用React上下文”中学到这个模式的推荐看这个。Tanner Linsley也在他的演讲“<a class="ae ky" href="https://www.youtube.com/watch?v=J-g9ZJha8FE&amp;feature=emb_title" rel="noopener ugc nofollow" target="_blank">React中的定制钩子:终极UI抽象层</a>”中涉及了类似的概念</p></div><div class="ab cl mn mo hx mp" role="separator"><span class="mq bw bk mr ms mt"/><span class="mq bw bk mr ms mt"/><span class="mq bw bk mr ms"/></div><div class="im in io ip iq"><h1 id="e555" class="kz la it bd lb lc mu le lf lg mv li lj jz mw ka ll kc mx kd ln kf my kg lp lq bi translated">例子</h1><p id="bab9" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">最终目标是有一个类似这样的API。</p><pre class="kj kk kl km gt nn no np nq aw nr bi"><span id="dfcb" class="ns la it no b gy nt nu l nv nw">export const App = ({ userId }) =&gt; {<br/>  return (<br/>    &lt;UserProvider id={userId}&gt;<br/>      &lt;Dashboard /&gt;<br/>    &lt;/UserProvider&gt;<br/>  );<br/>};<br/><br/>const Dashboard = () =&gt; {<br/>  const { isLoading, user } = useUserState();<br/>  if (isLoading) {<br/>    return &lt;div&gt;Loading...&lt;/div&gt;;<br/>  }<br/>  return (<br/>    &lt;div&gt;<br/>      &lt;h1&gt;Dashboard&lt;/h1&gt;<br/>      &lt;div&gt;Hello {user.displayName}!&lt;/div&gt;<br/>    &lt;/div&gt;<br/>  );<br/>};</span></pre><p id="0886" class="pw-post-body-paragraph lr ls it lt b lu nx ju lw lx ny jx lz ma nz mc md me oa mg mh mi ob mk ml mm im bi translated">让我们倒推得出这个解。</p><p id="8096" class="pw-post-body-paragraph lr ls it lt b lu nx ju lw lx ny jx lz ma nz mc md me oa mg mh mi ob mk ml mm im bi translated">首先，让我们从定义上下文的状态开始，以及我们将要创建的两个上下文。</p><pre class="kj kk kl km gt nn no np nq aw nr bi"><span id="330d" class="ns la it no b gy nt nu l nv nw">interface UserState {<br/>  user?: User;<br/>  isLoading: boolean;<br/>}<br/><br/>const UserStateContext = React.createContext&lt;UserState | undefined&gt;(undefined);<br/>const UserDispatchContext = React.createContext&lt;UserDispatch | undefined&gt;(<br/>  undefined<br/>);</span></pre><p id="9c25" class="pw-post-body-paragraph lr ls it lt b lu nx ju lw lx ny jx lz ma nz mc md me oa mg mh mi ob mk ml mm im bi translated">我们正在创建两个独立的上下文，因为不是所有的组件都需要访问<code class="fe oc od oe no b">State</code>和<code class="fe oc od oe no b">Dispatch</code>。这样，组件可以只使用它需要的上下文。额外的好处是，如果一个组件只使用<code class="fe oc od oe no b">Dispatch</code>，它不会在<code class="fe oc od oe no b">State</code>变更时重新呈现，因为它没有使用那个上下文。</p><p id="cd82" class="pw-post-body-paragraph lr ls it lt b lu nx ju lw lx ny jx lz ma nz mc md me oa mg mh mi ob mk ml mm im bi translated">对于上下文中的状态管理，我们将使用<code class="fe oc od oe no b">useReducer</code>。</p><pre class="kj kk kl km gt nn no np nq aw nr bi"><span id="8a21" class="ns la it no b gy nt nu l nv nw">// omitted rest of the file<br/><br/>enum UserActionTypes {<br/>  LOADING = "loading",<br/>  SUCCESS = "success"<br/>}<br/>type UserAction =<br/>  | { type: UserActionTypes.LOADING }<br/>  | { type: UserActionTypes.SUCCESS; payload: User };<br/>type UserDispatch = (action: UserAction) =&gt; void;<br/><br/>function userReducer(state: UserState, action: UserAction): UserState {<br/>  switch (action.type) {<br/>    case UserActionTypes.LOADING: {<br/>      return { isLoading: true };<br/>    }<br/>    case UserActionTypes.SUCCESS: {<br/>      return { isLoading: false, user: action.payload };<br/>    }<br/>    default: {<br/>      throw new Error("Invalid action type");<br/>    }<br/>  }<br/>}</span></pre><p id="336e" class="pw-post-body-paragraph lr ls it lt b lu nx ju lw lx ny jx lz ma nz mc md me oa mg mh mi ob mk ml mm im bi translated">我经常这样写上下文。在应用程序启动时，我们希望获取当前登录用户的信息，并在全球范围内提供这些数据。</p><p id="863a" class="pw-post-body-paragraph lr ls it lt b lu nx ju lw lx ny jx lz ma nz mc md me oa mg mh mi ob mk ml mm im bi translated">您想要获取的用户可能由一个ID决定，由于<code class="fe oc od oe no b">Provider</code>组件可以接受props，我们可以简单地传入一个<code class="fe oc od oe no b">id</code>，这样当我们的上下文装载时，我们就可以获取用户。</p><p id="ca9e" class="pw-post-body-paragraph lr ls it lt b lu nx ju lw lx ny jx lz ma nz mc md me oa mg mh mi ob mk ml mm im bi translated">下面是<code class="fe oc od oe no b">Provider</code>组件的样子。</p><pre class="kj kk kl km gt nn no np nq aw nr bi"><span id="a83b" class="ns la it no b gy nt nu l nv nw">export const UserProvider: React.FC&lt;{ id: string }&gt; = ({ id, children }) =&gt; {<br/>  const [state, dispatch] = React.useReducer(userReducer, { isLoading: true });<br/><br/>  React.useEffect(() =&gt; {<br/>    const handleGetUser = async id =&gt; {<br/>      dispatch({ type: UserActionTypes.LOADING });<br/>      const user = await getUserById(id);<br/>      dispatch({ type: UserActionTypes.SUCCESS, payload: user });<br/>      return;<br/>    };<br/>    handleGetUser(id);<br/>    return;<br/>  }, [id]);<br/><br/>  return (<br/>    &lt;UserStateContext.Provider value={state}&gt;<br/>      &lt;UserDispatchContext.Provider value={dispatch}&gt;<br/>        {children}<br/>      &lt;/UserDispatchContext.Provider&gt;<br/>    &lt;/UserStateContext.Provider&gt;<br/>  );<br/>};</span></pre><p id="8ed1" class="pw-post-body-paragraph lr ls it lt b lu nx ju lw lx ny jx lz ma nz mc md me oa mg mh mi ob mk ml mm im bi translated">在我的大多数应用程序中，我使用了钩子，所以我们将在这里定义钩子。</p><pre class="kj kk kl km gt nn no np nq aw nr bi"><span id="3461" class="ns la it no b gy nt nu l nv nw">export const useUserState = () =&gt; {<br/>  const userStateContext = React.useContext(UserStateContext);<br/>  if (userStateContext === undefined) {<br/>    throw new Error("useUserState must be used within a UserProvider");<br/>  }<br/>  return userStateContext;<br/>};<br/><br/>export const useUserDispatch = () =&gt; {<br/>  const userDispatchContext = React.useContext(UserDispatchContext);<br/>  if (userDispatchContext === undefined) {<br/>    throw new Error("useUserDispatch must be used within a UserProvider");<br/>  }<br/>  return userDispatchContext;<br/>}</span></pre></div><div class="ab cl mn mo hx mp" role="separator"><span class="mq bw bk mr ms mt"/><span class="mq bw bk mr ms mt"/><span class="mq bw bk mr ms"/></div><div class="im in io ip iq"><h1 id="cbed" class="kz la it bd lb lc mu le lf lg mv li lj jz mw ka ll kc mx kd ln kf my kg lp lq bi translated">包扎</h1><p id="6cd8" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">这是所有的东西:</p><pre class="kj kk kl km gt nn no np nq aw nr bi"><span id="953b" class="ns la it no b gy nt nu l nv nw">import * as React from "react";<br/>import { getUserById } from "../services/user-service";<br/>import { User } from "../types/user";<br/><br/>interface UserState {<br/>  user?: User;<br/>  isLoading: boolean;<br/>}<br/>enum UserActionTypes {<br/>  LOADING = "loading",<br/>  SUCCESS = "success"<br/>}<br/>type UserAction =<br/>  | { type: UserActionTypes.LOADING }<br/>  | { type: UserActionTypes.SUCCESS; payload: User };<br/>type UserDispatch = (action: UserAction) =&gt; void;<br/><br/>const UserStateContext = React.createContext&lt;UserState | undefined&gt;(undefined);<br/>const UserDispatchContext = React.createContext&lt;UserDispatch | undefined&gt;(<br/>  undefined<br/>);<br/><br/>function userReducer(state: UserState, action: UserAction): UserState {<br/>  switch (action.type) {<br/>    case UserActionTypes.LOADING: {<br/>      return { isLoading: true };<br/>    }<br/>    case UserActionTypes.SUCCESS: {<br/>      return { isLoading: false, user: action.payload };<br/>    }<br/>    default: {<br/>      throw new Error("Invalid action type");<br/>    }<br/>  }<br/>}<br/><br/>export const UserProvider: React.FC&lt;{ id: string }&gt; = ({ id, children }) =&gt; {<br/>  const [state, dispatch] = React.useReducer(userReducer, { isLoading: true });<br/><br/>  React.useEffect(() =&gt; {<br/>    const handleGetUser = async id =&gt; {<br/>      dispatch({ type: UserActionTypes.LOADING });<br/>      const user = await getUserById(id);<br/>      dispatch({ type: UserActionTypes.SUCCESS, payload: user });<br/>      return;<br/>    };<br/>    handleGetUser(id);<br/>    return;<br/>  }, [id]);<br/><br/>  return (<br/>    &lt;UserStateContext.Provider value={state}&gt;<br/>      &lt;UserDispatchContext.Provider value={dispatch}&gt;<br/>        {children}<br/>      &lt;/UserDispatchContext.Provider&gt;<br/>    &lt;/UserStateContext.Provider&gt;<br/>  );<br/>};<br/><br/>export const useUserState = () =&gt; {<br/>  const userStateContext = React.useContext(UserStateContext);<br/>  if (userStateContext === undefined) {<br/>    throw new Error("useUserState must be used within a UserProvider");<br/>  }<br/>  return userStateContext;<br/>};<br/><br/>export const useUserDispatch = () =&gt; {<br/>  const userDispatchContext = React.useContext(UserDispatchContext);<br/>  if (userDispatchContext === undefined) {<br/>    throw new Error("useUserDispatch must be used within a UserProvider");<br/>  }<br/>  return userDispatchContext;<br/>};</span></pre></div><div class="ab cl mn mo hx mp" role="separator"><span class="mq bw bk mr ms mt"/><span class="mq bw bk mr ms mt"/><span class="mq bw bk mr ms"/></div><div class="im in io ip iq"><h1 id="8e49" class="kz la it bd lb lc mu le lf lg mv li lj jz mw ka ll kc mx kd ln kf my kg lp lq bi translated">结论</h1><p id="beb5" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">这是我将要做的系列文章中的第五篇。下面是另外四篇文章。</p><div class="of og gp gr oh oi"><a href="https://medium.com/better-programming/an-opinionated-guide-to-react-folder-structure-file-naming-8b723d39a0d6" rel="noopener follow" target="_blank"><div class="oj ab fo"><div class="ok ab ol cl cj om"><h2 class="bd iu gy z fp on fr fs oo fu fw is bi translated">一个固执己见的指南反应文件夹结构和文件命名</h2><div class="op l"><h3 class="bd b gy z fp on fr fs oo fu fw dk translated">如何以简洁的方式组织你的项目</h3></div><div class="oq l"><p class="bd b dl z fp on fr fs oo fu fw dk translated">medium.com</p></div></div><div class="or l"><div class="os l ot ou ov or ow ks oi"/></div></div></a></div><div class="of og gp gr oh oi"><a href="https://medium.com/better-programming/an-opinionated-guide-to-react-component-file-structure-5eb9f4a8d763" rel="noopener follow" target="_blank"><div class="oj ab fo"><div class="ok ab ol cl cj om"><h2 class="bd iu gy z fp on fr fs oo fu fw is bi translated">固执己见的反应指南</h2><div class="op l"><h3 class="bd b gy z fp on fr fs oo fu fw dk translated">组件文件结构</h3></div><div class="oq l"><p class="bd b dl z fp on fr fs oo fu fw dk translated">medium.com</p></div></div><div class="or l"><div class="ox l ot ou ov or ow ks oi"/></div></div></a></div><div class="of og gp gr oh oi"><a href="https://medium.com/better-programming/opinionated-react-state-management-200d577ff122" rel="noopener follow" target="_blank"><div class="oj ab fo"><div class="ok ab ol cl cj om"><h2 class="bd iu gy z fp on fr fs oo fu fw is bi translated">固执己见的反应:状态管理</h2><div class="op l"><h3 class="bd b gy z fp on fr fs oo fu fw dk translated">您不需要使用第三方库来管理React应用程序中的状态</h3></div><div class="oq l"><p class="bd b dl z fp on fr fs oo fu fw dk translated">medium.com</p></div></div><div class="or l"><div class="oy l ot ou ov or ow ks oi"/></div></div></a></div><div class="of og gp gr oh oi"><a href="https://medium.com/better-programming/opinionated-react-use-state-co-location-8123b904a971" rel="noopener follow" target="_blank"><div class="oj ab fo"><div class="ok ab ol cl cj om"><h2 class="bd iu gy z fp on fr fs oo fu fw is bi translated">固执己见的反应:使用状态协同定位</h2><div class="op l"><h3 class="bd b gy z fp on fr fs oo fu fw dk translated">为什么你应该把你的状态放在尽可能靠近它被使用的地方</h3></div><div class="oq l"><p class="bd b dl z fp on fr fs oo fu fw dk translated">medium.com</p></div></div><div class="or l"><div class="oz l ot ou ov or ow ks oi"/></div></div></a></div><p id="58b0" class="pw-post-body-paragraph lr ls it lt b lu nx ju lw lx ny jx lz ma nz mc md me oa mg mh mi ob mk ml mm im bi translated">感谢阅读。</p></div></div>    
</body>
</html>