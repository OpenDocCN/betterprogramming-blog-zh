<html>
<head>
<title>5 Must-Know Python Concepts for Experienced Developers</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">经验丰富的开发人员必须了解的5个Python概念</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/must-know-python-concepts-for-experienced-developers-4554ceea3d95?source=collection_archive---------0-----------------------#2022-01-14">https://betterprogramming.pub/must-know-python-concepts-for-experienced-developers-4554ceea3d95?source=collection_archive---------0-----------------------#2022-01-14</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="511b" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">深入了解高级Python特性</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/0bc3bc6dfdf9d8433970b518d81e1066.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*qPnXZdfSvtMqrd7U"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated"><a class="ae kv" href="https://unsplash.com/@metelevan?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">安德烈·梅捷列夫</a>在<a class="ae kv" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">解锁</a>时拍摄的照片</p></figure><p id="0746" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><em class="ls">这个故事最初是在我的个人博客</em><a class="ae kv" href="https://bettersoftwarewithsid.com/must-know-python-concepts-for-experienced-developers" rel="noopener ugc nofollow" target="_blank"><em class="ls"/></a><em class="ls">上发表的，bettersoftwarewithsid.com</em><em class="ls"><em class="ls">。</em></em></p><p id="742d" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><strong class="ky ir"> <em class="ls">先决条件- </em> </strong> <em class="ls">本文假设对诸如OOPs、类、继承等编程概念有中级的理解。</em></p><p id="3d6f" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">开发人员以不同的能力使用Python编程语言。许多人用它来对独立的组件进行胶着编码，其他人用它来自动化任务，许多人把它作为他们的主要编程语言。作为一个严肃的Python程序员，你需要了解除了基本的Python构造之外的概念。</p><p id="91dc" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">下面是一些这样的概念的汇编，没有特别的顺序，这有助于加深对漂亮的Python语言的理解。</p><h1 id="2457" class="lt lu iq bd lv lw lx ly lz ma mb mc md jw me jx mf jz mg ka mh kc mi kd mj mk bi translated">1.多重继承及其MRO处理</h1><p id="eba5" class="pw-post-body-paragraph kw kx iq ky b kz ml jr lb lc mm ju le lf mn lh li lj mo ll lm ln mp lp lq lr ij bi translated">多重继承是一种OOPs构造，其中一个子类可以有多个父类，比如</p><pre class="kg kh ki kj gt mq mr ms mt aw mu bi"><span id="01d6" class="mv lu iq mr b gy mw mx l my mz">class Toddler(ParentA, ParentB):<br/>    pass</span></pre><p id="ae28" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">Python允许多种继承，但是许多其他高级语言如Java不允许。</p><p id="3440" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这类语言不赞成多重继承，主要是为了避免<strong class="ky ir">钻石问题</strong>。下面是我们<code class="fe na nb nc mr b">Toddler</code>类的父类。</p><pre class="kg kh ki kj gt mq mr ms mt aw mu bi"><span id="1374" class="mv lu iq mr b gy mw mx l my mz">class ParentA:<br/>    def how_to_talk():<br/>        print("Hello")</span><span id="4373" class="mv lu iq mr b gy nd mx l my mz">class ParentB:<br/>    def how_to_talk():<br/>        print("Namaste")</span></pre><p id="7816" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">Diamond问题是当一个子类(<code class="fe na nb nc mr b">Toddler</code>)从多个父类(<code class="fe na nb nc mr b">ParentA</code>、<code class="fe na nb nc mr b">ParentB</code>)继承时出现的一个模糊性问题。由于子类没有重写(有自己的实现)方法(<code class="fe na nb nc mr b">how_to_talk</code>)而产生了歧义，这在两个父类中都有不同的实现。实际上，我们的<code class="fe na nb nc mr b">Toddler</code>并不确定<code class="fe na nb nc mr b">how_to_talk</code>，也就是说<code class="fe na nb nc mr b">Hello</code>(按照<code class="fe na nb nc mr b">ParentA</code>)或者<code class="fe na nb nc mr b">Namaste</code>(按照<code class="fe na nb nc mr b">ParentB</code>)！。</p><p id="9350" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">Python通过使用方法解决顺序(MRO)来解决菱形问题。顾名思义，MRO定义了父类中方法查找的顺序。在Python中，简单来说就是从下到上，从左到右。因此，在我们的例子中，MRO将从左到右查看父类，并将首先遇到<code class="fe na nb nc mr b">ParentA</code>。所以，我们的<code class="fe na nb nc mr b">Toddler</code>会用<code class="fe na nb nc mr b">ParentA</code>的<code class="fe na nb nc mr b">how_to_talk</code>说<code class="fe na nb nc mr b">Hello</code>。</p><p id="9b11" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">准确地说，Python的MRO使用<a class="ae kv" href="https://en.wikipedia.org/wiki/C3_linearization" rel="noopener ugc nofollow" target="_blank"> C3线性化</a>算法来解析顺序。该算法保证对于任何复杂的类关系，它将总是给出相同的解决顺序，否则如果不能确定这样的顺序，它将给出失败。</p><p id="03c8" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">值得注意的一点是，Python在2.2版之前有一个不同的MRO，<a class="ae kv" href="https://www.python.org/download/releases/2.3/mro/" rel="noopener ugc nofollow" target="_blank">从2.3版使用C3线性化将</a>移到了新版本。</p><h1 id="c232" class="lt lu iq bd lv lw lx ly lz ma mb mc md jw me jx mf jz mg ka mh kc mi kd mj mk bi translated">2.<code class="fe na nb nc mr b">keyword 'type'</code>的元类和双重用途</h1><p id="02a0" class="pw-post-body-paragraph kw kx iq ky b kz ml jr lb lc mm ju le lf mn lh li lj mo ll lm ln mp lp lq lr ij bi translated">注意:我们将只讨论Python3的类和元类概念。</p><p id="f8ea" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">你一定在OOPs concepts中学习过，一个<code class="fe na nb nc mr b">Class</code>可以被认为是一个模板，描述了从它们创建的所有<code class="fe na nb nc mr b">Object</code>的属性和行为。在Python中，如果你想知道一个对象的类，你可以使用关键字<code class="fe na nb nc mr b">type</code>如下:</p><pre class="kg kh ki kj gt mq mr ms mt aw mu bi"><span id="e42f" class="mv lu iq mr b gy mw mx l my mz"><strong class="mr ir">//Method 1</strong><br/>class Car:<br/>  wheel_count = 4</span><span id="3da8" class="mv lu iq mr b gy nd mx l my mz">my_car = Car()</span><span id="909d" class="mv lu iq mr b gy nd mx l my mz">&gt;&gt;&gt; type(my_car)<br/><strong class="mr ir">&lt;class '__main__.Car'&gt;</strong></span></pre><p id="de72" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这里，我们定义了一个类<code class="fe na nb nc mr b">Car</code>并创建了它的对象<code class="fe na nb nc mr b">my_car</code>。然后我们使用关键字<code class="fe na nb nc mr b">type</code>来获得我们对象的类。因为Python是一种动态类型语言，所以<code class="fe na nb nc mr b">type</code>关键字有助于在运行时获取任何变量的类型。</p><p id="9f35" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">Python与大多数其他语言的区别在于，在Python中一个<code class="fe na nb nc mr b">Class</code>本身就是一个<code class="fe na nb nc mr b">Object</code>！。所以在上面的代码片段中，当我做<code class="fe na nb nc mr b">class Car:</code>时，一个对象被创建。这个对象属于一个名为<code class="fe na nb nc mr b">Metaclass</code>的类，一个用于创建类的<code class="fe na nb nc mr b">class</code>。</p><p id="619a" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">当Python中没有提供元类时，默认的元类是<code class="fe na nb nc mr b">type</code>，我们同样的好的旧关键字<code class="fe na nb nc mr b">type</code>，它也让你知道任何变量的类型。我们也可以在类定义中提供元类，如下所示:</p><pre class="kg kh ki kj gt mq mr ms mt aw mu bi"><span id="9438" class="mv lu iq mr b gy mw mx l my mz"><strong class="mr ir">//Method 2</strong><br/>class Car(object, metaclass=type):<br/>    wheel_count = 4</span></pre><p id="13cd" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">上面对类<code class="fe na nb nc mr b">Car</code>(方法2)的定义与之前定义的(方法1)相同，因为<code class="fe na nb nc mr b">object</code>是默认的超类，正如前面提到的，<code class="fe na nb nc mr b">type</code>是所有类的默认元类。我们也可以使用关键字<code class="fe na nb nc mr b">type</code>动态创建类，如下所示:</p><pre class="kg kh ki kj gt mq mr ms mt aw mu bi"><span id="581b" class="mv lu iq mr b gy mw mx l my mz"><strong class="mr ir">//Method 3</strong><br/>Car = type(‘Car’, (object), {'wheel_count':4})</span></pre><p id="ade0" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">其中第一个参数是类名，第二个是超类元组，第三个是类名称空间属性字典。虽然方法3与前两种方法不完全相同，因为<code class="fe na nb nc mr b">class</code>关键字不仅仅是语法上的糖，它还做了一些额外的事情，比如设置适当的<code class="fe na nb nc mr b">__qualname__</code>和<strong class="ky ir"> </strong> <code class="fe na nb nc mr b">__doc__</code>属性或者调用<code class="fe na nb nc mr b"> __prepare__</code>。</p><p id="40fa" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">自定义元类可以通过子类化默认元类<code class="fe na nb nc mr b">type</code>来定义。然后它可以用来创建一个类，就像我们之前看到的那样。</p><pre class="kg kh ki kj gt mq mr ms mt aw mu bi"><span id="ab57" class="mv lu iq mr b gy mw mx l my mz">class MyCustomMetaClass(type):<br/>    will_fly = True</span><span id="3bba" class="mv lu iq mr b gy nd mx l my mz">class FlyingCar(metaclass=MyCustomMetaClass):<br/>    pass</span></pre><p id="78dc" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">元类是什么，它们能做什么，什么时候应该使用，还有更多内容。但是它本身保证了一个单独的帖子，并且上面的内容足以让一个有经验的Python开发人员了解元类。</p><h1 id="1f58" class="lt lu iq bd lv lw lx ly lz ma mb mc md jw me jx mf jz mg ka mh kc mi kd mj mk bi translated">3.Python程序执行和PVM</h1><p id="4f67" class="pw-post-body-paragraph kw kx iq ky b kz ml jr lb lc mm ju le lf mn lh li lj mo ll lm ln mp lp lq lr ij bi translated">我们知道Python是一种解释型语言，而Java是一种编译型语言。不幸的是，这是对实际执行过程的过于简单化的看法。如果你解构Python解释器，你会发现一个Python虚拟机和一个编译器(喘息！).所以让我们从头开始。</p><p id="e603" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">当我们通过执行<code class="fe na nb nc mr b">&gt; python helloworld.py</code>来执行我们的python文件时，代码首先被<em class="ls">编译</em>为一个更简单的版本，称为字节码<strong class="ky ir"> <em class="ls"> </em> </strong>，并被存储在类似<code class="fe na nb nc mr b">helloworld.pyc</code>的<code class="fe na nb nc mr b">.pyc</code>或<code class="fe na nb nc mr b">.pyo</code>扩展中。</p><p id="930d" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">字节码代表Python开发人员创建的固定指令集，代表所有类型的操作。每个字节代码指令的大小是1字节(或8位)，因此这些被称为“字节”代码指令。这个字节码是一组低级指令，然后由Python虚拟机解释。</p><p id="22e2" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">将python代码编译成字节码是一个多步骤的过程，处理编译的不同方面。例如，第一步将Python代码解析成解析树，解析树识别并标记代码中的所有语法错误。</p><p id="4abd" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">当Python程序被编译时，解释器检查<code class="fe na nb nc mr b">.py</code>文件的最后一次编辑时间戳，并将其与<code class="fe na nb nc mr b">.pyc</code>文件中字节码的时间戳进行比较。如果字节码比Python代码旧，解释器会重新编译并生成新的字节码。否则，它将跳过编译并重用现有的字节码。</p><p id="42f6" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">解释器将所有的字节码<code class="fe na nb nc mr b">.pyc</code>文件保存在<code class="fe na nb nc mr b">__pycache__</code>文件夹中。因此，不提交您的<code class="fe na nb nc mr b">__pycache__</code>文件夹或<code class="fe na nb nc mr b">.pyc</code>文件是一个好的开发实践。为了防止解释器保存字节码文件，还可以将<code class="fe na nb nc mr b">PYTHONDONTWRITEBYTECODE</code>标志设置为任何非零值。在创建基于Python的<a class="ae kv" href="https://faun.pub/the-near-perfect-dockerfile-for-django-applications-8bc352a1e871" rel="noopener ugc nofollow" target="_blank">docker文件</a>时，这个标志非常方便，因为我们不想在docker映像中保存字节码文件。</p><p id="1f66" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">与将高级语言编译成CPU可理解的机器代码的其他编译器不同，Python编译器将Python代码转换成另一种更简单的代码(字节码)，这种代码不是机器代码，因此不能由CPU执行。</p><p id="0fd8" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">相反，Python虚拟机或PVM将这个字节码解释成由CPU执行的机器码。这就是为什么Python被认为是一种解释语言，尽管编译是它的执行阶段之一。</p><p id="e3e2" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">PVM允许Python独立于平台。给定相同的字节码和PVM版本，Python字节码可以在任何平台上执行。下一步是学习<a class="ae kv" href="https://packaging.python.org/en/latest/overview/" rel="noopener ugc nofollow" target="_blank">如何打包</a> python应用程序和发行版。</p><h1 id="9653" class="lt lu iq bd lv lw lx ly lz ma mb mc md jw me jx mf jz mg ka mh kc mi kd mj mk bi translated">4.Python的GIL和多线程面临的挑战</h1><p id="a127" class="pw-post-body-paragraph kw kx iq ky b kz ml jr lb lc mm ju le lf mn lh li lj mo ll lm ln mp lp lq lr ij bi translated">众所周知，Python在多线程方面表现不佳。这种情况的根本原因是Python如何使用引用计数方法执行垃圾收集。</p><p id="6f5c" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在引用计数垃圾收集中，Python记录有多少个变量指向一个特定的变量，这个变量一直在变化。如果引用一个对象的变量计数达到零，则该变量有资格进行垃圾收集。</p><pre class="kg kh ki kj gt mq mr ms mt aw mu bi"><span id="57f9" class="mv lu iq mr b gy mw mx l my mz">&gt;&gt;&gt; import sys<br/>&gt;&gt;&gt; my_dict = dict()<br/>&gt;&gt;&gt; another_variable = my_dict<br/>&gt;&gt;&gt; <!-- -->sys.getrefcount(<!-- -->my_dict<!-- -->)<br/><strong class="mr ir">3</strong></span></pre><p id="e3e1" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在上面的例子中，我们初始化了一个字典对象，两个变量<code class="fe na nb nc mr b">my_dict</code>和<code class="fe na nb nc mr b">another_variable</code>指向它。我们使用<code class="fe na nb nc mr b">sys.getrefcount()</code>方法检查引用我们对象的变量，在检查的同时，我们也给我们的对象分配了一个变量，函数参数。因此，我们得到的预期结果是3。如前所述，当这个引用计数达到零时，该对象就有资格进行垃圾收集。</p><p id="6976" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">现在假设两个线程正在更新同一个对象的引用计数。它们可能会同时写入，从而导致竞态条件。<a class="ae kv" href="https://www.techtarget.com/searchstorage/definition/race-condition" rel="noopener ugc nofollow" target="_blank">这个</a>简洁地描述了竞态条件:</p><blockquote class="ne nf ng"><p id="667b" class="kw kx ls ky b kz la jr lb lc ld ju le nh lg lh li ni lk ll lm nj lo lp lq lr ij bi translated">竞态条件是指程序的行为取决于多个线程或进程的相对时间的条件。一个或多个可能的结果可能是不期望的，从而导致bug。</p></blockquote><p id="a353" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">可以通过为每个对象引入锁来避免竞争情况，但是它们会带来死锁问题。</p><p id="0fb7" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">Python在解释器本身上有一个超级锁，称为全局解释器锁(GIL ),以减轻这些复杂性。然而，如果两个线程正在运行，它们轮流获取GIL，然后另一个线程不能访问解释器本身。这解决了竞争条件和死锁的问题，但禁止两个线程同时执行，即使代码是多线程的，Python也能有效地实现单线程。</p><p id="e2a3" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">人们一直在努力废除GIL教，但是还没有一个成功。最近，开发人员Sam Gross<a class="ae kv" href="https://mail.python.org/archives/list/python-dev@python.org/thread/ABR2L6BENNA6UPSPKV474HCS4LWT26GY/" rel="noopener ugc nofollow" target="_blank">提议</a>在GIL进行一项重大变革，以提升多线程性能。所以，让我们祈祷吧。</p><h1 id="43c3" class="lt lu iq bd lv lw lx ly lz ma mb mc md jw me jx mf jz mg ka mh kc mi kd mj mk bi translated">5.__str__和__repr__的魔术方法和实际使用</h1><p id="f94a" class="pw-post-body-paragraph kw kx iq ky b kz ml jr lb lc mm ju le lf mn lh li lj mo ll lm ln mp lp lq lr ij bi translated">大多数Python开发者都熟悉magic或dunder方法，如<code class="fe na nb nc mr b">__str__</code>、<code class="fe na nb nc mr b">__repr__</code>、<code class="fe na nb nc mr b">__add__</code>等。在Python中，魔术方法或dunder方法是以Dunder(双下划线)开始和结束的预定义方法。它们主要用于运算符重载和为类提供附加功能。让我们看一个用来重载操作符<code class="fe na nb nc mr b">+</code>的神奇方法<code class="fe na nb nc mr b">__add__</code>的例子。</p><pre class="kg kh ki kj gt mq mr ms mt aw mu bi"><span id="9ddc" class="mv lu iq mr b gy mw mx l my mz">class Handbag:<br/>  def __init__(self, item_count):<br/>    self.item_count = item_count</span><span id="7742" class="mv lu iq mr b gy nd mx l my mz">handbag1 = Handbag(item_count=5)<br/>handbag2 = Handbag(item_count=3)</span><span id="a44b" class="mv lu iq mr b gy nd mx l my mz">&gt;&gt; handbag1 + handbag2<br/>&gt;&gt; <strong class="mr ir">TypeError: unsupported operand type(s) for +: 'Handbag' and 'Handbag'</strong></span></pre><p id="f1a4" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在上面的代码中，我们定义了一个类<code class="fe na nb nc mr b">Handbag</code>，这个类中存储了物品的数量。现在，我们希望我们的<code class="fe na nb nc mr b">Handbag</code>类有一个属性，当我们添加两个<code class="fe na nb nc mr b">Handbags</code>时，我们将获得两个<code class="fe na nb nc mr b">Handbags</code>中的总项目。</p><p id="4823" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">但是，正如我们在上面的例子中看到的，我们得到一个错误，即<code class="fe na nb nc mr b">Handbag</code>类不支持<code class="fe na nb nc mr b">+</code>。为了实现我们的目标，我们必须做到以下几点:</p><pre class="kg kh ki kj gt mq mr ms mt aw mu bi"><span id="6438" class="mv lu iq mr b gy mw mx l my mz">class Handbag:<br/>  def __init__(self, item_count):<br/>    self.item_count = item_count</span><span id="1184" class="mv lu iq mr b gy nd mx l my mz"><strong class="mr ir">  def __add__(self, second_handbag):<br/>    return self.item_count + second_handbag.item_count</strong></span><span id="95d8" class="mv lu iq mr b gy nd mx l my mz">handbag1 = Handbag(item_count=5)<br/>handbag2 = Handbag(item_count=3)</span><span id="1c0d" class="mv lu iq mr b gy nd mx l my mz">&gt;&gt; handbag1 + handbag2<br/><strong class="mr ir">&gt;&gt; 8</strong></span></pre><p id="6235" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在上面的例子中，我们添加了神奇的方法<code class="fe na nb nc mr b">__add__</code>，这将允许我们对<code class="fe na nb nc mr b">Handbag</code>对象使用<code class="fe na nb nc mr b">+</code>操作符。<code class="fe na nb nc mr b">__add__</code>接受两个对象输入，一个是self，即第一个操作数，另一个是第二个操作数，并返回两个包中项目的总和。</p><h2 id="7a9b" class="mv lu iq bd lv nk nl dn lz nm nn dp md lf no np mf lj nq nr mh ln ns nt mj nu bi translated">__str__和__repr__魔术方法</h2><p id="ec37" class="pw-post-body-paragraph kw kx iq ky b kz ml jr lb lc mm ju le lf mn lh li lj mo ll lm ln mp lp lq lr ij bi translated"><code class="fe na nb nc mr b">__str__</code>和<code class="fe na nb nc mr b">__repr__</code>是两种经常被混淆的流行魔术方法。然而，对它们的充分理解对调试和文档记录大有帮助。</p><p id="c7c3" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><code class="fe na nb nc mr b">__repr__</code>的默认目标是拥有一个对象的字符串表示，可以使用Python的<code class="fe na nb nc mr b">eval</code>从该字符串表示中再次形成对象，如下所示:</p><pre class="kg kh ki kj gt mq mr ms mt aw mu bi"><span id="63ea" class="mv lu iq mr b gy mw mx l my mz"><strong class="mr ir">object = eval(repr(object))</strong></span></pre><p id="b24f" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这对于像<code class="fe na nb nc mr b">list</code>这样的简单对象是可能的，但对于复杂对象是不可能的。让我们看一个简单对象的例子，一个<code class="fe na nb nc mr b">list</code>。</p><pre class="kg kh ki kj gt mq mr ms mt aw mu bi"><span id="4945" class="mv lu iq mr b gy mw mx l my mz">&gt;&gt;&gt; mylist = [1, 2, 3]<br/>&gt;&gt;&gt; repr(mylist)<br/>'[1, 2, 3]'</span><span id="92fb" class="mv lu iq mr b gy nd mx l my mz">&gt;&gt;&gt; eval(repr(mylist))<br/>[1, 2, 3]</span><span id="64c3" class="mv lu iq mr b gy nd mx l my mz">&gt;&gt;&gt; mylist == eval(repr(mylist))<br/><strong class="mr ir">True</strong></span></pre><p id="e28c" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">另一个神奇的方法<code class="fe na nb nc mr b">__str__</code>用于获取一个对象的字符串表示，以用于文档和日志记录。如果没有定义任何类的<code class="fe na nb nc mr b">__str__</code>，但是定义了<code class="fe na nb nc mr b">__repr__</code>，则该类的对象将使用<code class="fe na nb nc mr b">__repr__</code>代替<code class="fe na nb nc mr b">__str__</code>，反之则无效。</p><p id="6e47" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">写代码的时候，<code class="fe na nb nc mr b">__repr__</code>的目标应该是不含糊，<code class="fe na nb nc mr b">__str__</code>的目标应该是可读性。<code class="fe na nb nc mr b">__repr__</code>应该提供能够唯一识别对象的表示。正如我们在上面的<code class="fe na nb nc mr b">list</code>例子中看到的，它可以是分配给每个对象或对象组成部分的任何标识符。</p><p id="171a" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">另一方面，<code class="fe na nb nc mr b">__str__</code>的目标应该是可读性，如果一个对象被记录和打印，用户可以容易地阅读和理解它的描述，即使这是以唯一性为代价的。</p><p id="930c" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">魔术方法是Python工具包中非常有用的工具，能够轻松地添加和修改许多基本特性。</p><p id="8964" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">上面提到的主题绝不是详尽的，而是根据我与其他开发人员的交流挑选出来的。我觉得更多的话题应该被包括在这里，但由于博客的长度而没有包括在内。以后我会把剩下的这类题目整理出来，写一篇补充文章。</p><p id="c087" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">本博客到此为止，后续文章请关注，谢谢！如果你喜欢你读到的东西，也可以看看这个故事:</p><p id="a6c3" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><a class="ae kv" href="https://bettersoftwarewithsid.com/the-near-perfect-dockerfile-for-django-applications" rel="noopener ugc nofollow" target="_blank"><strong class="ky ir"/></a></p></div></div>    
</body>
</html>