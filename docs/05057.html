<html>
<head>
<title>Functional Programming: Using the Functor Type Class in TypeScript</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">函数式编程:在TypeScript中使用仿函数类型类</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/functional-programming-using-the-functor-type-class-in-typescript-beae60abe6af?source=collection_archive---------17-----------------------#2020-06-03">https://betterprogramming.pub/functional-programming-using-the-functor-type-class-in-typescript-beae60abe6af?source=collection_archive---------17-----------------------#2020-06-03</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="981a" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">探索函子类型类及其用例</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/9397cabc0cbe5cd278869a3e3305cb19.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*L9GM0JtG26cxbp_iBHUVNw.jpeg"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">由<a class="ae kv" href="https://unsplash.com/@goshua13?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Joshua Aragon </a>在<a class="ae kv" href="https://unsplash.com/?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片。</p></figure><p id="61f0" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这将是一个包含几篇文章的系列，在这些文章中，我试图解释和展示一些函数式编程模式的用例。</p><p id="b76b" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们将使用TypeScript并使用函数式编程库<a class="ae kv" href="https://github.com/gcanti/fp-ts" rel="noopener ugc nofollow" target="_blank"> fp-ts </a>。这些例子和解释受到了<code class="fe ls lt lu lv b">fp-ts</code>作者的<a class="ae kv" href="https://dev.to/gcanti/getting-started-with-fp-ts-ord-5f1e" rel="noopener ugc nofollow" target="_blank">伟大文章系列</a>的启发。</p><p id="4283" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这是我们系列的第5部分，这篇文章是关于<code class="fe ls lt lu lv b">Functors</code>。我们将探索什么是<code class="fe ls lt lu lv b">Functors</code>以及我们可以用它们做什么。</p></div><div class="ab cl lw lx hu ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="ij ik il im in"><h1 id="a03d" class="md me iq bd mf mg mh mi mj mk ml mm mn jw mo jx mp jz mq ka mr kc ms kd mt mu bi translated">关于函数式编程</h1><p id="005b" class="pw-post-body-paragraph kw kx iq ky b kz mv jr lb lc mw ju le lf mx lh li lj my ll lm ln mz lp lq lr ij bi translated">本质上，函数式编程完全是关于组合的——更确切地说，是函数组合。</p><h2 id="bf5d" class="na me iq bd mf nb nc dn mj nd ne dp mn lf nf ng mp lj nh ni mr ln nj nk mt nl bi translated">作文</h2><p id="1252" class="pw-post-body-paragraph kw kx iq ky b kz mv jr lb lc mw ju le lf mx lh li lj my ll lm ln mz lp lq lr ij bi translated">什么是作文？</p><p id="c68f" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">组合是将两个或更多不太复杂的事物组合成更复杂的事物的过程。应用于函数，是将两个或两个以上的简单函数变成更复杂函数的过程。</p><p id="1ba5" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们用两个函数(<code class="fe ls lt lu lv b">f</code>和<code class="fe ls lt lu lv b">g</code>)来构建一个更复杂的函数(<code class="fe ls lt lu lv b">h</code>)，它结合了<code class="fe ls lt lu lv b">f</code>和<code class="fe ls lt lu lv b">g</code>。我们组成<code class="fe ls lt lu lv b">f</code>和<code class="fe ls lt lu lv b">g</code> → <code class="fe ls lt lu lv b">h = g</code> ∘ <code class="fe ls lt lu lv b">f</code>(读作:在<code class="fe ls lt lu lv b">f</code>之后执行<code class="fe ls lt lu lv b">g</code>)。等效的编程如下所示:</p><pre class="kg kh ki kj gt nm lv nn no aw np bi"><span id="8431" class="na me iq lv b gy nq nr l ns nt">const h = (x) =&gt; g(f(x))</span></pre><p id="d27e" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">当一个代码示例只不过是将来自<code class="fe ls lt lu lv b">f()</code>的返回值作为输入值传递给<code class="fe ls lt lu lv b">g()</code>时，它看起来不应该那么可怕。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nu nv l"/></div></figure><p id="94af" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在这里，我们有一个具体的例子，即使它不是那么有用。我们编写了<code class="fe ls lt lu lv b">add()</code>和<code class="fe ls lt lu lv b">say()</code>来构建一个更复杂的函数(<code class="fe ls lt lu lv b">sayAddResult()</code>，它将<code class="fe ls lt lu lv b">add()</code>和<code class="fe ls lt lu lv b">say()</code>的功能组合成一个函数。</p><p id="7cc1" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们可以说我们的<code class="fe ls lt lu lv b">add()</code>函数将我们的输入<code class="fe ls lt lu lv b">A</code>转换为<code class="fe ls lt lu lv b">B</code>(我们接受两个数字<code class="fe ls lt lu lv b">A</code>并返回一个新数字<code class="fe ls lt lu lv b">B</code>)。此外，我们可以说我们的<code class="fe ls lt lu lv b">say()</code>函数接受一个<code class="fe ls lt lu lv b">B</code>并返回一个<code class="fe ls lt lu lv b">C</code>(我们接受一个数字<code class="fe ls lt lu lv b">B</code>并返回一个新的字符串<code class="fe ls lt lu lv b">C</code>)。所以基本上，我们用我们的两个函数先从<code class="fe ls lt lu lv b">A</code>到<code class="fe ls lt lu lv b">B</code>，然后从<code class="fe ls lt lu lv b">B</code>到<code class="fe ls lt lu lv b">C</code>。</p><p id="65ba" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">一定有办法直接从<code class="fe ls lt lu lv b">A</code>到<code class="fe ls lt lu lv b">C</code>，你说呢？</p><p id="04e9" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">你是对的。有，我们实际上已经看到了。这是我们的<code class="fe ls lt lu lv b">sayAddResult()</code>功能。它从我们的<code class="fe ls lt lu lv b">A</code>(两个数字)直接到我们的<code class="fe ls lt lu lv b">C</code>(字符串)。因为我们组合了两个函数(<code class="fe ls lt lu lv b">add()</code>和<code class="fe ls lt lu lv b">say()</code>)，所以我们构建了一个直接从<code class="fe ls lt lu lv b">A</code>到<code class="fe ls lt lu lv b">C</code>的新函数。</p><p id="9eb1" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">听起来棒极了！所以我们可以组合/组成任何我们想要的功能？</p><p id="7419" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">可悲的是，事情没那么简单。为了能够组合函数，它们的输入和输出类型必须匹配。在我们的例子中，我们编写了<code class="fe ls lt lu lv b">add()</code>和<code class="fe ls lt lu lv b">say()</code>，它们的输入和输出类型匹配。<code class="fe ls lt lu lv b">add()</code>返回类型为<code class="fe ls lt lu lv b">number</code>的东西，而<code class="fe ls lt lu lv b">say()</code>接受类型为<code class="fe ls lt lu lv b">number</code>的东西。如果<code class="fe ls lt lu lv b">add()</code>返回另一个类型或者<code class="fe ls lt lu lv b">say()</code>接受另一个类型，我们就无法合成它们。</p><p id="a6ad" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">例如，如果一个函数的输出类型是一个<code class="fe ls lt lu lv b">boolean</code>，而另一个函数的输入类型是一个<code class="fe ls lt lu lv b">object</code>，我们就不能真正地组合它们。我们必须使用某种中间函数来排列我们的类型。</p><p id="beb3" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">函数式编程经常发生的是函数返回效果。例如，<code class="fe ls lt lu lv b">(a: A) =&gt; F&lt;B&gt;</code>，其中<code class="fe ls lt lu lv b">F</code>是某种类型的构造函数。类型构造函数基本上是一个函数，它接受一个或多个类型作为参数(<code class="fe ls lt lu lv b">n-ary type operator</code>)，并返回另一个类型。因此，<code class="fe ls lt lu lv b">F</code>的例子可以是<code class="fe ls lt lu lv b">Option</code>、<code class="fe ls lt lu lv b">Either</code>、<code class="fe ls lt lu lv b">Task</code>或<code class="fe ls lt lu lv b">Array</code>。所以<code class="fe ls lt lu lv b">(a: A) =&gt; F&lt;B&gt;</code>可能类似于<code class="fe ls lt lu lv b">(a: string) =&gt; Option&lt;number&gt;</code>。如果我们想用类型签名<code class="fe ls lt lu lv b">(a: A) =&gt; F&lt;B&gt;</code> &amp; <code class="fe ls lt lu lv b">(b: B) =&gt; C</code>组合两个函数，我们将没有办法，因为它们的输入和输出类型不匹配。</p><p id="7194" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">但是请不要放弃！有一个英雄可以帮助我们摆脱困境。万能的<code class="fe ls lt lu lv b">Functor</code>！</p></div><div class="ab cl lw lx hu ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="ij ik il im in"><h1 id="a406" class="md me iq bd mf mg mh mi mj mk ml mm mn jw mo jx mp jz mq ka mr kc ms kd mt mu bi translated">函子</h1><p id="6df1" class="pw-post-body-paragraph kw kx iq ky b kz mv jr lb lc mw ju le lf mx lh li lj my ll lm ln mz lp lq lr ij bi translated"><code class="fe ls lt lu lv b">Functors</code>可以帮助我们解决这样一个问题:我们想要构造一个函数，用一个纯函数返回某种效果。在我们的上下文中，纯函数意味着它只是一个不返回结果而是返回原始值的函数(例如，pure: <code class="fe ls lt lu lv b">(a: number) =&gt; number</code>和effective:<code class="fe ls lt lu lv b">(a: number) =&gt; Option&lt;number&gt;</code>)。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nu nv l"/></div></figure><p id="a5ff" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">如您所见，我们需要某种方法来转换<code class="fe ls lt lu lv b">say()</code>函数，使其具有<code class="fe ls lt lu lv b">(x: O.Option&lt;number&gt;) =&gt; O.Option&lt;string&gt;</code>而不是<code class="fe ls lt lu lv b">(x: number) =&gt; string</code>的类型签名。我们必须以某种方式将纯函数(不返回效果的函数)引入效果世界，这样我们就可以再次使用我们的基本函数组合。</p><p id="1987" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在这里，我们有两个例子来说明我们如何能够<code class="fe ls lt lu lv b">lift</code>一个纯函数到世界的<code class="fe ls lt lu lv b">Arrays</code>或<code class="fe ls lt lu lv b">Options</code>:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nu nv l"/></div></figure><p id="7ddc" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在<code class="fe ls lt lu lv b">lift</code>函数中，我们只需解开<code class="fe ls lt lu lv b">Array</code>或<code class="fe ls lt lu lv b">Option</code>中的值，然后将它应用于我们想要提升的纯函数。</p><h2 id="66a2" class="na me iq bd mf nb nc dn mj nd ne dp mn lf nf ng mp lj nh ni mr ln nj nk mt nl bi translated">那么到底什么是函子呢？</h2><p id="0875" class="pw-post-body-paragraph kw kx iq ky b kz mv jr lb lc mw ju le lf mx lh li lj my ll lm ln mz lp lq lr ij bi translated">一个<code class="fe ls lt lu lv b">Functor</code>就像一个<code class="fe ls lt lu lv b">Semigroup</code>、<code class="fe ls lt lu lv b">Monoid</code>、<code class="fe ls lt lu lv b">Ord</code>或者<code class="fe ls lt lu lv b">Eq</code>——一个<code class="fe ls lt lu lv b">type class</code>。和其他的一样，它需要定义某些东西。对于<code class="fe ls lt lu lv b">Functors</code>，是一个可以把一个函数<code class="fe ls lt lu lv b">(a: A) =&gt; B</code>提升到<code class="fe ls lt lu lv b">(a: F&lt;A&gt;) =&gt; F&lt;B&gt;</code>的方法。<br/>这个<code class="fe ls lt lu lv b">lift</code>功能更俗称<code class="fe ls lt lu lv b">map</code>。<code class="fe ls lt lu lv b">map</code>类似于<code class="fe ls lt lu lv b">lift</code>，但是参数被重新排列:</p><ul class=""><li id="5108" class="nw nx iq ky b kz la lc ld lf ny lj nz ln oa lr ob oc od oe bi translated">电梯:<code class="fe ls lt lu lv b">&lt;A, B&gt;(f: (a: A) =&gt; B) =&gt; ((fa: F&lt;A&gt;) =&gt; F&lt;B&gt;)</code></li><li id="8c94" class="nw nx iq ky b kz of lc og lf oh lj oi ln oj lr ob oc od oe bi translated">地图:<code class="fe ls lt lu lv b">&lt;A, B&gt;(fa: F&lt;A&gt;, f: (a: A) =&gt; B) =&gt; F&lt;B&gt;</code></li></ul><p id="5c01" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">所以<code class="fe ls lt lu lv b">Functors</code>允许我们将纯函数提升到它们的“世界”中</p><h2 id="d897" class="na me iq bd mf nb nc dn mj nd ne dp mn lf nf ng mp lj nh ni mr ln nj nk mt nl bi translated">我们自己的仿函数实例</h2><p id="dbbe" class="pw-post-body-paragraph kw kx iq ky b kz mv jr lb lc mw ju le lf mx lh li lj my ll lm ln mz lp lq lr ij bi translated">为了创建一个<code class="fe ls lt lu lv b">Functor</code>实例，您必须定义一个<code class="fe ls lt lu lv b">map</code>方法，将函数<code class="fe ls lt lu lv b">(a: A) =&gt; B</code>映射/提升到它的上下文<code class="fe ls lt lu lv b">(a: F&lt;A&gt;) =&gt; F&lt;B&gt;</code>:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nu nv l"/></div></figure><p id="3c7c" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们刚刚定义了一个<code class="fe ls lt lu lv b">map</code>方法，将一个纯函数提升到<code class="fe ls lt lu lv b">Option</code>上下文，现在我们有了一个<code class="fe ls lt lu lv b">Option</code>的<code class="fe ls lt lu lv b">Functor</code>实例。</p><p id="76d3" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><code class="fe ls lt lu lv b">map()</code>方法允许我们获取一个纯函数，该函数接受类似于<code class="fe ls lt lu lv b">number</code>类型的东西，并将其应用于<code class="fe ls lt lu lv b">effect</code>(类似于<code class="fe ls lt lu lv b">Option</code>、<code class="fe ls lt lu lv b">Either</code>等)。).</p><p id="f364" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><code class="fe ls lt lu lv b">map()</code>方法与JavaScript中内置的<code class="fe ls lt lu lv b">Array</code>方法非常相似(<code class="fe ls lt lu lv b">Array.prototype.map</code>)。JavaScript中的一个<code class="fe ls lt lu lv b">Array</code>实际上也是<code class="fe ls lt lu lv b">Functor</code>类型类的一个实例。</p><p id="6480" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">下面是我们在上面的要点中所做的:我们采用了纯函数<code class="fe ls lt lu lv b">double()</code>，它接受了类型<code class="fe ls lt lu lv b">number</code>的内容，并应用了类型为<code class="fe ls lt lu lv b">Option&lt;number&gt;</code>的<code class="fe ls lt lu lv b">O.some(4)</code>中的值。我们用来自<code class="fe ls lt lu lv b">Functor</code>实例的<code class="fe ls lt lu lv b">map()</code>方法完成了所有这些工作。</p></div><div class="ab cl lw lx hu ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="ij ik il im in"><h1 id="7a84" class="md me iq bd mf mg mh mi mj mk ml mm mn jw mo jx mp jz mq ka mr kc ms kd mt mu bi translated">用有效函数合成纯函数</h1><p id="5aa0" class="pw-post-body-paragraph kw kx iq ky b kz mv jr lb lc mw ju le lf mx lh li lj my ll lm ln mz lp lq lr ij bi translated">为了将一个纯函数与一个有效函数组合起来，我们只需要将纯函数与“世界”联系起来。</p><p id="d860" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">为此，我们需要创建一个<code class="fe ls lt lu lv b">lift</code>函数，它接收一个纯函数并返回一个接收<code class="fe ls lt lu lv b">effect</code>的函数。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nu nv l"/></div></figure><p id="7d0e" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们现在可以用一个纯函数组合一个有效函数。但是我们仍然有一个限制。我们想要提升的<code class="fe ls lt lu lv b">pure</code>函数必须是<code class="fe ls lt lu lv b">unary</code>(取一个参数)。如果我们想使用一个接受两个或更多参数的纯函数，我们仍然会被卡住。</p><p id="7880" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">幸运的是，我们的问题有一个解决方案:<code class="fe ls lt lu lv b">Applicative Functors</code>。我们将在下一篇文章中讨论它们。</p></div></div>    
</body>
</html>