# Native 或 NumPy—您应该选择哪个？

> 原文：<https://betterprogramming.pub/native-or-numpy-which-should-you-choose-d30377f2f7e9>

## NumPy 不是最佳选择的情况

![](img/85143d23647616812ca00b1e85e19b50.png)

对于使用原生集合数据类型的初学者来说，Python 非常直观。随着代码越来越高级，运行时间也越来越长。这篇文章将比较 Python 中的原生数组和 NumPy 数组的速度。

首先:如果大小保持较小，使用原生数据结构可能更容易。每当我有一个想法要在我的沙箱中测试，并且它涉及一个包含十个元素的列表时，我就使用原生数据结构。

# 让我们准备做一些编码

为了比较 NumPy 和本机数组，让我们构建一些代码。

这段代码创建了两个数组——一个原生 python 数组和一个 NumPy 对象。它们都包含从 0 到 9 的整数元素。我还导入了时间模块——我们稍后会讲到。

## 如何求速度差

很简单。我们只需使用时间模块，找出两个时刻之间的差异:执行代码块之前的时刻和之后的时刻。我使用`perf_counter_ns()`函数代替`time()`,因为我想要尽可能高的精度。请注意，一秒是 10 亿分之一秒。

这样我们可以测量持续时间。整洁！

现在我们必须在这两个时刻之间放置一些代码。测试时，我将改变数组长度和不同的数组方法，其他什么都不做。

*注意:我的电脑目前使用 AMD 锐龙 5 作为 CPU。根据您的 CPU，您的结果可能会有所不同。*

## 测试 1:打印功能

可能每个人都使用 print 函数来调试或者简单地显示数组的内容。让我们看看它在各种数组大小下的表现。为了便于阅读，持续时间被转换为秒。

```
+------------+-------------------+------------------+
| Array size | Duration (Native) | Duration (NumPy) |
+------------+-------------------+------------------+
|         10 |         0.0002097 |        0.0001529 |
|      1 000 |         0.0096579 |        0.0134756 |
|  1 000 000 |          9.481898 |       10.7749533 |
+------------+-------------------+------------------+
```

对于较大的阵列，本机阵列似乎表现更好。否则，差异是不存在的。

## 测试 2:求算术平均值

让我们做一些计算。为了找到 Python 数组中的平均值，我们必须找到所有元素的总和，然后除以元素的数量。在 NumPy 中，我们可以用同样的方式来做*或*我们可以简单地使用`mean()`函数。

```
native_mean = sum(native_lst)/len(native_lst)numpy_mean1 = numpy_lst.sum()/numpy_lst.size
numpy_mean2 = numpy_lst.mean()
```

我们会记录下这三次的持续时间。方法发现`numpy_mean1`被标记为 *Dur。(NumPy 1)* ”而对于`numpy_mean2`则是“ *Dur。(NumPy 2)* ”。

由于持续时间很短，下表使用纳秒作为时间单位。

```
+------------+---------------+----------------+----------------+
| Array size | Dur. (Native) | Dur. (NumPy 1) | Dur. (NumPy 2) |
+------------+---------------+----------------+----------------+
|         10 |          2400 |          80000 |         100600 |
|      1 000 |         15000 |          61000 |          95100 |
|  1 000 000 |      49311000 |         737000 |        1233100 |
+------------+---------------+----------------+----------------+
```

哇！我们至少可以观察到三点:

*   随着数组大小的增加，本机方法的速度会变慢。可以说，在某个时刻，如果数组的大小增长了 10 倍，那么要找到所有元素的平均值就要多花 10 倍的时间。
*   在处理小数组时，处理 NumPy 数组要花长得多的时间。编码时的时间损失也暴露出来了——导入 NumPy 和初始化 NumPy 数组可能需要一秒多的时间。
*   第一种 NumPy 方法比第二种方法快。对我来说，这是不直观的:两个函数调用比一个多，我期望`mean()`函数做同样的事情，但是更快。

# 结论:什么时候应该使用 NumPy？

毫无疑问，使用 NumPy 很有诱惑力。但是，在处理小型数组时，最好使用原生数组。可能大多数人都想知道确切的数组大小，但最好忘记那些本机数据结构，而使用 NumPy，即它们执行相同功能时的数组大小。

为了估计这个大小，我进行了反复试验，并使用了本文中的第二个测试。在这个测试中，我使用了更快的 NumPy 方法(第一种)。

## 击鼓…结果！

根据我的结果，当数组大小在 4000–5000 左右时会出现这种情况。

如果这篇文章中有什么引起了你的注意并且值得一提的，请在评论区发表。其他测试方法也是受欢迎的——特别是如果它们显示出小型 NumPy 阵列性能更好的结果。