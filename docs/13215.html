<html>
<head>
<title>Understanding Partial Indexing</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">了解部分索引</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/partial-indexing-faq-55d6f1e10c08?source=collection_archive---------8-----------------------#2022-08-08">https://betterprogramming.pub/partial-indexing-faq-55d6f1e10c08?source=collection_archive---------8-----------------------#2022-08-08</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="7a2f" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">何时以及如何使用部分索引</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/8f06201ed18b33ea1532d567b377dfbf.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*Qh8C7h4nVT3CTPZi.jpg"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">Maksym Kaharlytskyi 在<a class="ae kv" href="https://unsplash.com/photos/Q9y3LRuuxmg" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</p></figure><p id="1500" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">几天前，一个团队成员问了我一个关于部分索引的问题，我觉得这是一个很好的话题，所以今天我们来谈谈部分索引:</p><ol class=""><li id="8713" class="ls lt iq ky b kz la lc ld lf lu lj lv ln lw lr lx ly lz ma bi translated">部分索引有什么好处？</li><li id="cdfe" class="ls lt iq ky b kz mb lc mc lf md lj me ln mf lr lx ly lz ma bi translated">什么时候应该使用部分索引？</li></ol><p id="f2b3" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在谈以上两个问题之前，我们先对部分索引有个基本的了解。</p><p id="0b4b" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">数据库索引的目的是通过特殊的数据结构将数据存储在内存中，从而提高查询性能，以避免硬盘上长时间的访问延迟。</p><p id="28f1" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">目前主流的RDBMS MySQL和PostgreSQL，他们用的是B+树，而基于文档的MongoDB用的是B树。</p><p id="7c8d" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">大部分的数据库索引并没有把数据库中的每一行都当作一个单独的叶子节点，而是把“值”作为叶子，记录其中的主键，所以找到叶子之后，就需要把其他的数据从主键中拉出来。</p><p id="c319" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">部分索引只为满足特定条件的“值”创建节点。目前MongoDB和PostgreSQL都支持部分索引，但MySQL经常使用的InnoDB不支持。MySQL 8.0以后支持函数索引，可以用来实现部分索引的效果。</p><h1 id="a279" class="mg mh iq bd mi mj mk ml mm mn mo mp mq jw mr jx ms jz mt ka mu kc mv kd mw mx bi translated">部分索引有什么好处？</h1><p id="08eb" class="pw-post-body-paragraph kw kx iq ky b kz my jr lb lc mz ju le lf na lh li lj nb ll lm ln nc lp lq lr ij bi translated">了解了部分索引的背景，应该也就难怪部分索引最大的好处就是减少索引占用的内存大小了。与为所有值创建节点相比，部分索引只为某些值创建节点，因此减少的百分比取决于所使用的标准。</p><p id="c332" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">例如，如果我有一个值从0到9的单字段(a)索引，如果我将部分索引条件设置为<code class="fe nd ne nf ng b">a &gt;= 5</code>，我可以节省大约50%的空间开销。请注意，这与数据量无关，只与取值范围有关。即使<code class="fe nd ne nf ng b">a = 0</code>数据只有一行，它仍然有一个索引节点，以及有1000行的<code class="fe nd ne nf ng b">a = 1</code>数据。</p><p id="6f47" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">除了节省空间，查询性能也会得到提高。B树的查询效率是<code class="fe nd ne nf ng b">O(log N)</code>，这里的<code class="fe nd ne nf ng b">N</code>是指索引节点的数量，而不是行数。</p><p id="570a" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">部分索引后，我们可以得到一个更紧凑的树，假设它有M个节点。由于<code class="fe nd ne nf ng b">M &lt; N</code>，所以<code class="fe nd ne nf ng b">O(log M) &lt; O(log N)</code>，我们由此知道部分索引可以提高查询性能。不过好处不大，因为在<code class="fe nd ne nf ng b">log</code>之后，除非<code class="fe nd ne nf ng b">N</code>和<code class="fe nd ne nf ng b">M</code>的差别显著，否则对查询性能的影响并不大。</p><p id="6fb8" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">综上所述，部分索引最大的优点是减少了索引的空间开销，提高了部分查询性能。</p><h1 id="235c" class="mg mh iq bd mi mj mk ml mm mn mo mp mq jw mr jx ms jz mt ka mu kc mv kd mw mx bi translated">什么时候应该使用部分索引？</h1><p id="aeab" class="pw-post-body-paragraph kw kx iq ky b kz my jr lb lc mz ju le lf na lh li lj nb ll lm ln nc lp lq lr ij bi translated">为了确定使用它的时间，我们首先需要知道当“查询结果”包含不符合部分索引标准的节点时会发生什么。</p><p id="a0d9" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">有点抽象，对吧？我们以MongoDB为例。</p><p id="8291" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">首先，有一个建立在用户列表复合索引上的部分索引，目的是让索引成年人更快。</p><pre class="kg kh ki kj gt nh ng ni nj aw nk bi"><span id="d043" class="nl mh iq ng b gy nm nn l no np">db.users.createIndex(<br/>   { name: 1 },<br/>   { partialFilterExpression: { age: { $gte: 18 } } }<br/>)</span></pre><p id="d8d6" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">但是，如果我们的场景可能需要查询没有年龄限制的姓名，那么这样的查询将不会使用索引。</p><pre class="kg kh ki kj gt nh ng ni nj aw nk bi"><span id="3561" class="nl mh iq ng b gy nm nn l no np">db.users.find({name: "Tom"})</span></pre><p id="98f3" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">例如，如果有三个年龄分别为8、18和28岁的Toms，那么<code class="fe nd ne nf ng b">("Tom", 18)</code>和<code class="fe nd ne nf ng b">("Tom", 28)</code>都将被创建，但<code class="fe nd ne nf ng b">("Tom", 8)</code>不会被创建，因此MongoDB优化器知道这种情况，不会使用部分索引，而是使用全表扫描。</p><p id="18a6" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">对，就是这个价。只要场景包含不在部分索引的值范围内的条件，它就会变成全表扫描。</p><p id="6a2f" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">所以，什么样的场景适合做部分索引？在我看来，需要满足两个条件。</p><ol class=""><li id="3921" class="ls lt iq ky b kz la lc ld lf lu lj lv ln lw lr lx ly lz ma bi translated">取值范围大，但常用数据范围小。</li><li id="cf9a" class="ls lt iq ky b kz mb lc mc lf md lj me ln mf lr lx ly lz ma bi translated">即使没有索引，查询也不会对数据库产生太大影响，例如查询频率、集合大小等。</li></ol><p id="18ad" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">第二点更容易理解，但是第一点到底是什么意思呢？</p><p id="00de" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">从上一节中，我们知道部分索引的最大优势是减少索引的空间，而不是提高查询的性能，因此最有效的场景是当数据分散并且只有一小部分公共数据被应用程序使用时。</p><p id="5205" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">举个会员制的实际例子。</p><p id="aa45" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">从注册到成为会员，用户可能需要经历许多程序，直到通过电子邮件验证后最终成为会员。但是这个系统，对于非会员基本不关心，它只专注于处理经过验证的会员数据。</p><p id="86e1" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">然后，可以这样设计部分索引。</p><pre class="kg kh ki kj gt nh ng ni nj aw nk bi"><span id="560c" class="nl mh iq ng b gy nm nn l no np">db.users.createIndex(<br/>   { name: 1 },<br/>   { partialFilterExpression: { email: { $exists: true } } }<br/>)</span></pre><p id="99bc" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">因为这个会员系统只关心会员信息，也就是说，用户必须有电子邮件。可能会有大量用户在开始时经过部分注册过程，但在最后没有通过验证过程，那么就会有大量数据不需要被索引。这样可以尽可能的减少索引空间，提高成员的查询效率。</p><h1 id="59c4" class="mg mh iq bd mi mj mk ml mm mn mo mp mq jw mr jx ms jz mt ka mu kc mv kd mw mx bi translated">结论</h1><p id="fe4f" class="pw-post-body-paragraph kw kx iq ky b kz my jr lb lc mz ju le lf na lh li lj nb ll lm ln nc lp lq lr ij bi translated">毕竟没有完美的解决方案。部分索引节省了索引空间并提高了查询性能，但是全表扫描也有相应的代价。</p><p id="4716" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">因此，理解部分索引的原理和使用它的场景是很重要的。</p><p id="95d3" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">索引机制的有效性完全取决于数据分布和应用程序的特征，无论是常规索引还是部分索引。因此，这篇文章不能告诉你一个放之四海而皆准的解决方案，它只能为你提供一个指导方针，由你决定取舍。</p></div></div>    
</body>
</html>