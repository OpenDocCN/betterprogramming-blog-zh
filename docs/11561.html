<html>
<head>
<title>Getting Started With Vapor 4 — Model Relationships</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Vapor 4入门—模型关系</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/getting-started-with-vapor-4-model-relationships-e6e73d6c2412?source=collection_archive---------10-----------------------#2022-03-30">https://betterprogramming.pub/getting-started-with-vapor-4-model-relationships-e6e73d6c2412?source=collection_archive---------10-----------------------#2022-03-30</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="4ea9" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">扩展待办事项应用程序，了解这一以Swift编写的服务器优先工具的更多高级功能</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/e65d8681e5146783b12af4739dd82a5d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*DuHsgJrzw6zc96EZQVUlRw.png"/></div></div></figure><h1 id="a09f" class="ku kv it bd kw kx ky kz la lb lc ld le jz lf ka lg kc lh kd li kf lj kg lk ll bi translated">介绍</h1><p id="5ea8" class="pw-post-body-paragraph lm ln it lo b lp lq ju lr ls lt jx lu lv lw lx ly lz ma mb mc md me mf mg mh im bi translated">在上一篇文章中，我们介绍了Vapor并开始创建一个TODO应用程序。</p><div class="mi mj gp gr mk ml"><a rel="noopener  ugc nofollow" target="_blank" href="/getting-started-with-vapor-4-part-1-3d731e64fb45"><div class="mm ab fo"><div class="mn ab mo cl cj mp"><h2 class="bd iu gy z fp mq fr fs mr fu fw is bi translated">Vapor 4入门—在Swift中构建一个基本的Todo应用程序</h2><div class="ms l"><h3 class="bd b gy z fp mq fr fs mr fu fw dk translated">了解这一以Swift编写的服务器优先工具的基础知识(不那么基础)</h3></div><div class="mt l"><p class="bd b dl z fp mq fr fs mr fu fw dk translated">better编程. pub</p></div></div><div class="mu l"><div class="mv l mw mx my mu mz ks ml"/></div></div></a></div><p id="4a10" class="pw-post-body-paragraph lm ln it lo b lp na ju lr ls nb jx lu lv nc lx ly lz nd mb mc md ne mf mg mh im bi translated">就目前而言，这款应用没什么用。它只是让你创建一个列表，但你还不能添加任何提醒。我们稍后会解决这个问题。</p><p id="3ded" class="pw-post-body-paragraph lm ln it lo b lp na ju lr ls nb jx lu lv nc lx ly lz nd mb mc md ne mf mg mh im bi translated">到本文结束时，我们将有一个工作的web应用程序来存储我们的待办事项列表。在这个过程中，我们将继续了解Vapor及其工作原理。你可以在我的回购协议中找到完整的实现:</p><p id="d45d" class="pw-post-body-paragraph lm ln it lo b lp na ju lr ls nb jx lu lv nc lx ly lz nd mb mc md ne mf mg mh im bi translated"><a class="ae nf" href="https://github.com/fermoya/vapor-tutorial" rel="noopener ugc nofollow" target="_blank">https://github.com/fermoya/vapor-tutorial</a></p><h1 id="03fb" class="ku kv it bd kw kx ky kz la lb lc ld le jz lf ka lg kc lh kd li kf lj kg lk ll bi translated">高级路由</h1><p id="b1c5" class="pw-post-body-paragraph lm ln it lo b lp lq ju lr ls lt jx lu lv lw lx ly lz ma mb mc md me mf mg mh im bi translated">到目前为止，我们直接在<code class="fe ng nh ni nj b">routes.swift</code>中定义所有端点，如下所示:</p><pre class="kj kk kl km gt nk nj nl nm aw nn bi"><span id="3f5b" class="no kv it nj b gy np nq l nr ns">app.get("todo-lists") { ... }<br/>app.post("todo-lists") { ... }<br/>...</span></pre><p id="0c4c" class="pw-post-body-paragraph lm ln it lo b lp na ju lr ls nb jx lu lv nc lx ly lz nd mb mc md ne mf mg mh im bi translated">一旦我们推出新型号，情况就会变得非常混乱。想象一个真实的web应用程序，数据库中保存了多少不同的实体:用户、集合、设置、集合等。我们需要一个更好的策略。</p><p id="bc0e" class="pw-post-body-paragraph lm ln it lo b lp na ju lr ls nb jx lu lv nc lx ly lz nd mb mc md ne mf mg mh im bi translated">此外，想想你知道的任何REST APIs。您很可能已经注意到部分路径引用了一个API版本。比如说，<code class="fe ng nh ni nj b">https://&lt;organization&gt;.atlassian.net/api/3/&lt;path&gt;</code>或者<code class="fe ng nh ni nj b">https://api.appstoreconnect.apple.com/v1/&lt;path&gt;</code>。这在我们的应用程序中会是什么样子？</p><pre class="kj kk kl km gt nk nj nl nm aw nn bi"><span id="a307" class="no kv it nj b gy np nq l nr ns">app.get("v1", "todo-lists") { ... }<br/>app.post("v1", "todo-lists") { ... }<br/>...</span></pre><p id="f401" class="pw-post-body-paragraph lm ln it lo b lp na ju lr ls nb jx lu lv nc lx ly lz nd mb mc md ne mf mg mh im bi translated">这看起来不太容易维护。幸运的是，Vapor允许您“分组”路线和“注册”控制器。</p><p id="5253" class="pw-post-body-paragraph lm ln it lo b lp na ju lr ls nb jx lu lv nc lx ly lz nd mb mc md ne mf mg mh im bi translated">让我们付诸行动吧。打开<code class="fe ng nh ni nj b">routes.swift</code>，删除<code class="fe ng nh ni nj b">routes(_:)</code>的内容，改为粘贴以下代码:</p><pre class="kj kk kl km gt nk nj nl nm aw nn bi"><span id="3925" class="no kv it nj b gy np nq l nr ns">let v1Routes = app.grouped("v1")</span><span id="0429" class="no kv it nj b gy nt nq l nr ns">let todoListsRoutes = v1Routes.grouped("todo-lists")<br/>try todoListsRoutes.register(collection: TodoListController())</span></pre><p id="1d68" class="pw-post-body-paragraph lm ln it lo b lp na ju lr ls nb jx lu lv nc lx ly lz nd mb mc md ne mf mg mh im bi translated">这里发生了什么事？</p><ul class=""><li id="6ef0" class="nu nv it lo b lp na ls nb lv nw lz nx md ny mh nz oa ob oc bi translated">我们将所有端点分组到<code class="fe ng nh ni nj b">v1</code>路径下。这意味着针对<code class="fe ng nh ni nj b">v1Routes</code>定义的每个端点路径都将在路径前面加上<code class="fe ng nh ni nj b">v1</code>。例如，<code class="fe ng nh ni nj b">/v1/todo-lists</code></li><li id="eaa3" class="nu nv it lo b lp od ls oe lv of lz og md oh mh nz oa ob oc bi translated">我们再次对包含<code class="fe ng nh ni nj b">todo-lists</code>的一组路径进行分组。这很好，因为我们所有的CRUD操作都将<code class="fe ng nh ni nj b">todo-lists</code>定义为它们的路径</li><li id="811c" class="nu nv it lo b lp od ls oe lv of lz og md oh mh nz oa ob oc bi translated">最后，<code class="fe ng nh ni nj b">TodoListController</code>被定义为负责子路径<code class="fe ng nh ni nj b">/v1/todo-lists</code>的<code class="fe ng nh ni nj b">class</code></li></ul><p id="c930" class="pw-post-body-paragraph lm ln it lo b lp na ju lr ls nb jx lu lv nc lx ly lz nd mb mc md ne mf mg mh im bi translated">让我们看看<code class="fe ng nh ni nj b">TodoListController</code>会是什么样子:</p><pre class="kj kk kl km gt nk nj nl nm aw nn bi"><span id="7b46" class="no kv it nj b gy np nq l nr ns">import Vapor</span><span id="40f6" class="no kv it nj b gy nt nq l nr ns">final class <!-- -->TodoListController: RouteCollection {<br/>  <!-- -->func boot(routes: RoutesBuilder) throws {<br/>    // routing here<br/>  }<br/>}</span></pre><p id="96e8" class="pw-post-body-paragraph lm ln it lo b lp na ju lr ls nb jx lu lv nc lx ly lz nd mb mc md ne mf mg mh im bi translated">一个<code class="fe ng nh ni nj b">Controller</code>仅仅是一个<code class="fe ng nh ni nj b">RouteCollection</code>，当启动时，它将我们希望允许的每个操作路由到一个特定的方法。让我们实现这个方法:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oi oj l"/></div></figure><p id="2525" class="pw-post-body-paragraph lm ln it lo b lp na ju lr ls nb jx lu lv nc lx ly lz nd mb mc md ne mf mg mh im bi translated">让我们来分解一下:</p><ul class=""><li id="6abd" class="nu nv it lo b lp na ls nb lv nw lz nx md ny mh nz oa ob oc bi translated">当<code class="fe ng nh ni nj b">get</code>请求<code class="fe ng nh ni nj b">/v1/todo-lists</code>时，调用<code class="fe ng nh ni nj b">getAllEntities(req:)</code></li><li id="84b1" class="nu nv it lo b lp od ls oe lv of lz og md oh mh nz oa ob oc bi translated">根据对<code class="fe ng nh ni nj b">/v1/todo-lists</code>的<code class="fe ng nh ni nj b">post</code>请求，调用<code class="fe ng nh ni nj b">postEntity(req:)</code></li><li id="153c" class="nu nv it lo b lp od ls oe lv of lz og md oh mh nz oa ob oc bi translated">注意这两个方法是如何保存之前在<code class="fe ng nh ni nj b">routes.swift</code>中的代码的</li></ul><p id="10c9" class="pw-post-body-paragraph lm ln it lo b lp na ju lr ls nb jx lu lv nc lx ly lz nd mb mc md ne mf mg mh im bi translated">这很整洁，不是吗？比以前干净多了。现在，我们可以继续分组子路径，继续构建我们的应用程序。</p><p id="7ccd" class="pw-post-body-paragraph lm ln it lo b lp na ju lr ls nb jx lu lv nc lx ly lz nd mb mc md ne mf mg mh im bi translated">注意:不要忘记现在你的请求应该以<code class="fe ng nh ni nj b">v1</code>为前缀。就是<code class="fe ng nh ni nj b">localhost:8080/todo-lists</code>不再起作用，而是，<code class="fe ng nh ni nj b">localhost:8080/v1/todo-lists</code>。</p><h1 id="2343" class="ku kv it bd kw kx ky kz la lb lc ld le jz lf ka lg kc lh kd li kf lj kg lk ll bi translated">参数和查询项</h1><p id="dcb0" class="pw-post-body-paragraph lm ln it lo b lp lq ju lr ls lt jx lu lv lw lx ly lz ma mb mc md me mf mg mh im bi translated">在继续前进并继续开发<code class="fe ng nh ni nj b">TodoApp</code>之前，让我们先来看看如何改进我们的<code class="fe ng nh ni nj b">GET operations</code>。首先，有没有办法检索某个特定的<code class="fe ng nh ni nj b">TodoList</code>？在REST中，这将通过从<code class="fe ng nh ni nj b">GET /todo-lists/&lt;id&gt;</code>获取来完成。也就是说，路径需要参数化。</p><p id="3686" class="pw-post-body-paragraph lm ln it lo b lp na ju lr ls nb jx lu lv nc lx ly lz nd mb mc md ne mf mg mh im bi translated">此外，是否可以不检索<code class="fe ng nh ni nj b">all(_:)</code>列表，而只检索一定数量的列表？也就是说，我们可以根据返回结果的数量来过滤列表吗？</p><h2 id="f848" class="no kv it bd kw ok ol dn la om on dp le lv oo op lg lz oq or li md os ot lk ou bi translated">路由参数</h2><p id="2ebf" class="pw-post-body-paragraph lm ln it lo b lp lq ju lr ls lt jx lu lv lw lx ly lz ma mb mc md me mf mg mh im bi translated">Vapor让我们通过传递一个由<code class="fe ng nh ni nj b">:</code>前置的字符串来参数化到一个端点的路径。例如:</p><pre class="kj kk kl km gt nk nj nl nm aw nn bi"><span id="1d7f" class="no kv it nj b gy np nq l nr ns">app.get("users", ":userID") { ... }</span></pre><p id="6ea7" class="pw-post-body-paragraph lm ln it lo b lp na ju lr ls nb jx lu lv nc lx ly lz nd mb mc md ne mf mg mh im bi translated">将解析为<code class="fe ng nh ni nj b">/users/&lt;userID&gt;</code>并将创建一个可从<code class="fe ng nh ni nj b">request</code>对象中检索的<code class="fe ng nh ni nj b">userID</code>。类似地，这可以在我们当前的路由结构中完成，我们只需要在<code class="fe ng nh ni nj b">func routes(boot:)</code>中定义一个新的路由，并为它提供一个实现:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oi oj l"/></div></figure><p id="a283" class="pw-post-body-paragraph lm ln it lo b lp na ju lr ls nb jx lu lv nc lx ly lz nd mb mc md ne mf mg mh im bi translated">注意我们是如何通过调用<code class="fe ng nh ni nj b">req.parameters.get(_:as:)</code>来获取参数的。如果一个<code class="fe ng nh ni nj b">TodoList</code>不存在，将返回<code class="fe ng nh ni nj b">HTTP 404</code>。</p><p id="7a92" class="pw-post-body-paragraph lm ln it lo b lp na ju lr ls nb jx lu lv nc lx ly lz nd mb mc md ne mf mg mh im bi translated">让我们测试这个新的端点。首先，让我们修改<code class="fe ng nh ni nj b">POST /todo-lists</code>来返回创建的列表:</p><pre class="kj kk kl km gt nk nj nl nm aw nn bi"><span id="6cb1" class="no kv it nj b gy np nq l nr ns">private func postEntity(req: Request) throws -&gt; EventLoopFuture&lt;Response&gt; {<br/>  let todoList = try req.content.decode(TodoList.self)<br/>  return todoList.save(on: req.db)<br/>    .map { todoList }<br/>    .encodeResponse(status: .created, for: req)<br/>}</span></pre><p id="f507" class="pw-post-body-paragraph lm ln it lo b lp na ju lr ls nb jx lu lv nc lx ly lz nd mb mc md ne mf mg mh im bi translated">最后，我们可以测试一下:</p><pre class="kj kk kl km gt nk nj nl nm aw nn bi"><span id="2b47" class="no kv it nj b gy np nq l nr ns">$ curl -X POST localhost:8080/v1/todo-lists \<br/>    -H "Content-Type:application/json"<br/>    --data "{ \"name\": \"Test my new endpoint\" }" | jq<br/>{<br/>  "id": "CF880521-A913-4977-8D84-4CC70EC2977D",<br/>  "name": "Test my new endpoint"<br/>}<br/>$ curl localhost:8080/v1/todo-lists/8359807A-FCE3-48AA-8AC6-EFF619913900 | jq<br/>{<br/>  "id": "CF880521-A913-4977-8D84-4CC70EC2977D",<br/>  "name": "Test my new endpoint"<br/>}</span></pre><h2 id="dd19" class="no kv it bd kw ok ol dn la om on dp le lv oo op lg lz oq or li md os ot lk ou bi translated">询问</h2><p id="a9a1" class="pw-post-body-paragraph lm ln it lo b lp lq ju lr ls lt jx lu lv lw lx ly lz ma mb mc md me mf mg mh im bi translated">之前，<code class="fe ng nh ni nj b">GET /todo-lists</code>会返回所有可用的<code class="fe ng nh ni nj b">TodoList</code>。然而，这在将来会非常低效。想象一下，我们最终拥有成千上万的列表。</p><p id="b920" class="pw-post-body-paragraph lm ln it lo b lp na ju lr ls nb jx lu lv nc lx ly lz nd mb mc md ne mf mg mh im bi translated">我们希望支持这个端点的分页，为此我们需要一种方法来访问请求中的<code class="fe ng nh ni nj b">query-items</code> send。幸运的是，<code class="fe ng nh ni nj b">Request</code>带有<code class="fe ng nh ni nj b">subscript</code>方法，允许您检索预期的<code class="fe ng nh ni nj b">query-item</code>。转到<code class="fe ng nh ni nj b">func getAllEntities(req:)</code>，我们将其重命名为<code class="fe ng nh ni nj b">getEntities</code>，因为我们不再返回每个实例。然后，将其修改如下:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oi oj l"/></div></figure><p id="9cc3" class="pw-post-body-paragraph lm ln it lo b lp na ju lr ls nb jx lu lv nc lx ly lz nd mb mc md ne mf mg mh im bi translated">注意我们如何在这里限制结果的<code class="fe ng nh ni nj b">range(_:)</code>，然后检索匹配的<code class="fe ng nh ni nj b">all(_:)</code>。让我们通过创建20个列表来尝试一下:</p><pre class="kj kk kl km gt nk nj nl nm aw nn bi"><span id="7020" class="no kv it nj b gy np nq l nr ns">for i in $(seq 0 20); do<br/>  curl localhost:8080/v1/todo-lists \<br/>  -X POST \<br/>  -H "Content-Type:application/json" \<br/>  --data "{ \"name\": \"TODO List $i\" }"<br/>done</span></pre><p id="d7b5" class="pw-post-body-paragraph lm ln it lo b lp na ju lr ls nb jx lu lv nc lx ly lz nd mb mc md ne mf mg mh im bi translated">并获取列表10至14:</p><pre class="kj kk kl km gt nk nj nl nm aw nn bi"><span id="1311" class="no kv it nj b gy np nq l nr ns">$ curl "localhost:8080/v1/todo-lists?offset=10&amp;limit=5" | jq<br/>[<br/>  {<br/>    "id": "77CD7685-1105-4E81-8A35-F775CEDDA28F",<br/>    "name": "TODO List 10"<br/>  },<br/>  {...},<br/>  {...},<br/>  {...},<br/>  {<br/>    "id": "77CD7685-1105-4E81-8A35-F775CEDDA28F",<br/>    "name": "TODO List 14"<br/>  }<br/>]</span></pre><p id="1dfa" class="pw-post-body-paragraph lm ln it lo b lp na ju lr ls nb jx lu lv nc lx ly lz nd mb mc md ne mf mg mh im bi translated">如果您想知道，越界(在我们的例子中是<code class="fe ng nh ni nj b">offset=21</code>)将会变成一个空数组。</p><h1 id="9ed6" class="ku kv it bd kw kx ky kz la lb lc ld le jz lf ka lg kc lh kd li kf lj kg lk ll bi translated">模型关系</h1><h2 id="0be3" class="no kv it bd kw ok ol dn la om on dp le lv oo op lg lz oq or li md os ot lk ou bi translated">定义待办事项</h2><p id="7bfc" class="pw-post-body-paragraph lm ln it lo b lp lq ju lr ls lt jx lu lv lw lx ly lz ma mb mc md me mf mg mh im bi translated">至此，你应该有了一个可以存储和返回<code class="fe ng nh ni nj b">TodoList</code>的web app。我们在实际列表中添加一些<code class="fe ng nh ni nj b">Todo</code>怎么样？让我们从思考我们想要达到的目标开始。一个<code class="fe ng nh ni nj b">TodoList</code>可以被视为一个包含<code class="fe ng nh ni nj b">Todo</code> s的文件夹；</p><pre class="kj kk kl km gt nk nj nl nm aw nn bi"><span id="6c9a" class="no kv it nj b gy np nq l nr ns">├── my-todo-list<br/>│   ├── todo-1<br/>│   ├── todo-2<br/>│   └── ...</span></pre><p id="fb50" class="pw-post-body-paragraph lm ln it lo b lp na ju lr ls nb jx lu lv nc lx ly lz nd mb mc md ne mf mg mh im bi translated">在这里，您将看到以下内容:</p><ul class=""><li id="5435" class="nu nv it lo b lp na ls nb lv nw lz nx md ny mh nz oa ob oc bi translated">没有<code class="fe ng nh ni nj b">TodoList</code>就没有<code class="fe ng nh ni nj b">Todo</code></li><li id="f17e" class="nu nv it lo b lp od ls oe lv of lz og md oh mh nz oa ob oc bi translated">一个<code class="fe ng nh ni nj b">TodoList</code>可以有任意数量的<code class="fe ng nh ni nj b">Todo</code></li></ul><p id="e4b0" class="pw-post-body-paragraph lm ln it lo b lp na ju lr ls nb jx lu lv nc lx ly lz nd mb mc md ne mf mg mh im bi translated">这就是所谓的<code class="fe ng nh ni nj b">one-to-many</code>关系。为了告诉<code class="fe ng nh ni nj b">Vapor</code>，或者实际上告诉ORM <code class="fe ng nh ni nj b">Fluent</code>，这两个模型是相关的，我们需要使用两个新的包装器:</p><ul class=""><li id="19a8" class="nu nv it lo b lp na ls nb lv nw lz nx md ny mh nz oa ob oc bi translated"><code class="fe ng nh ni nj b">@Parent</code>将把一个<code class="fe ng nh ni nj b">Todo</code>和一个<code class="fe ng nh ni nj b">TodoList</code>联系起来</li><li id="cd8a" class="nu nv it lo b lp od ls oe lv of lz og md oh mh nz oa ob oc bi translated"><code class="fe ng nh ni nj b">@Children</code>将执行<code class="fe ng nh ni nj b">TodoList</code>和<code class="fe ng nh ni nj b">Todo</code>之间的等效操作</li></ul><p id="9cda" class="pw-post-body-paragraph lm ln it lo b lp na ju lr ls nb jx lu lv nc lx ly lz nd mb mc md ne mf mg mh im bi translated">考虑到这些，我们可以将<code class="fe ng nh ni nj b">Todo</code>定义为:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oi oj l"/></div></figure><p id="5c56" class="pw-post-body-paragraph lm ln it lo b lp na ju lr ls nb jx lu lv nc lx ly lz nd mb mc md ne mf mg mh im bi translated">并更新<code class="fe ng nh ni nj b">TodoList</code>以反映两个模型之间已建立的关系:</p><pre class="kj kk kl km gt nk nj nl nm aw nn bi"><span id="779d" class="no kv it nj b gy np nq l nr ns">@Children(for: \.$list)<br/>var todos: [Todo]</span></pre><p id="0f91" class="pw-post-body-paragraph lm ln it lo b lp na ju lr ls nb jx lu lv nc lx ly lz nd mb mc md ne mf mg mh im bi translated">请注意，<code class="fe ng nh ni nj b">list</code>是在<code class="fe ng nh ni nj b">Todo</code>中定义的属性，它保存了对<code class="fe ng nh ni nj b">TodoList</code>的引用。</p><p id="ad45" class="pw-post-body-paragraph lm ln it lo b lp na ju lr ls nb jx lu lv nc lx ly lz nd mb mc md ne mf mg mh im bi translated">接下来，我们需要在数据库中创建一个新表。如果您还记得第1部分，这是通过<code class="fe ng nh ni nj b">Migration</code>完成的:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oi oj l"/></div></figure><p id="07ca" class="pw-post-body-paragraph lm ln it lo b lp na ju lr ls nb jx lu lv nc lx ly lz nd mb mc md ne mf mg mh im bi translated">注意字段<code class="fe ng nh ni nj b">description</code>是如何被定义为<code class="fe ng nh ni nj b">String?</code>的，因此，它没有被标记为<code class="fe ng nh ni nj b">.required</code>。对于<code class="fe ng nh ni nj b">TodoList</code>，我们不需要任何额外的迁移。</p><p id="937a" class="pw-post-body-paragraph lm ln it lo b lp na ju lr ls nb jx lu lv nc lx ly lz nd mb mc md ne mf mg mh im bi translated">最后，添加迁移到<code class="fe ng nh ni nj b">configure.swift</code>:</p><pre class="kj kk kl km gt nk nj nl nm aw nn bi"><span id="5d68" class="no kv it nj b gy np nq l nr ns">app.migrations.add(CreateTodoListMigration(), to: .sqlite)<br/>app.migrations.add(CreateTodoMigration(), to: .sqlite)</span></pre><h2 id="c73f" class="no kv it bd kw ok ol dn la om on dp le lv oo op lg lz oq or li md os ot lk ou bi translated">创建新的待办事项</h2><p id="09eb" class="pw-post-body-paragraph lm ln it lo b lp lq ju lr ls lt jx lu lv lw lx ly lz ma mb mc md me mf mg mh im bi translated">我们的新模型已经准备好了，数据库也创建好了，但是我们还没有开始路由。我们希望定义看起来像<code class="fe ng nh ni nj b">/todo-lists/&lt;id&gt;/todos</code>的新端点。如果您还记得，我们已经在<code class="fe ng nh ni nj b">TodoListsController</code>中定义了一个端点<code class="fe ng nh ni nj b">/todo-lists/&lt;id&gt;</code>和一组路由<code class="fe ng nh ni nj b">singleListRoutes</code>。我们可以在此基础上继续建设。</p><pre class="kj kk kl km gt nk nj nl nm aw nn bi"><span id="e401" class="no kv it nj b gy np nq l nr ns">// TodoListController<br/>func boot(routes: RoutesBuilder) throws {<br/>  ...<br/>  let singleListRoutes = routes.grouped(":id")<br/>  singleListRoutes.get(use: getEntity)<br/>  let todosRoutes = singleListRoutes.grouped("todos")<br/>  try todosRoutes.register(collection: TodoController())<br/>}</span></pre><p id="0a92" class="pw-post-body-paragraph lm ln it lo b lp na ju lr ls nb jx lu lv nc lx ly lz nd mb mc md ne mf mg mh im bi translated">而类似于<code class="fe ng nh ni nj b">TodoListController</code>，我们可以将<code class="fe ng nh ni nj b">TodoController</code>定义为:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oi oj l"/></div></figure><p id="20c6" class="pw-post-body-paragraph lm ln it lo b lp na ju lr ls nb jx lu lv nc lx ly lz nd mb mc md ne mf mg mh im bi translated">让我们从实现<code class="fe ng nh ni nj b">postEntity</code>开始:</p><pre class="kj kk kl km gt nk nj nl nm aw nn bi"><span id="515e" class="no kv it nj b gy np nq l nr ns">guard let listID = req.parameters.get("id", as: UUID.self) else {<br/>  throw Abort(.notFound)<br/>}</span><span id="8eea" class="no kv it nj b gy nt nq l nr ns">let todo = try req.content.decode(Todo.self)<br/>todo.$list.id = listID</span><span id="7188" class="no kv it nj b gy nt nq l nr ns">return todo.save(on: req.db)<br/>  .map { todo }<br/>  .encodeResponse(status: .created, for: req)</span></pre><p id="1d69" class="pw-post-body-paragraph lm ln it lo b lp na ju lr ls nb jx lu lv nc lx ly lz nd mb mc md ne mf mg mh im bi translated">并尝试一下:</p><pre class="kj kk kl km gt nk nj nl nm aw nn bi"><span id="9e5c" class="no kv it nj b gy np nq l nr ns">$ curl localhost:8080/v1/todo-lists \<br/>    -X POST \<br/>    -H "Content-Type:application/json" \<br/>    --data "{ \"name\": \"Foo\" }"</span><span id="e8d7" class="no kv it nj b gy nt nq l nr ns">{"id":"9F5D21D3-11F3-434D-907E-2DA083404C3F","name":"Foo"}</span><span id="cf23" class="no kv it nj b gy nt nq l nr ns">$ curl -X POST \<br/>    "localhost:8080/v1/todo-lists/9F5D21D3-11F3-434D-907E-2DA083404C3F/todos" \<br/>    -H "Content-Type:application/json" \<br/>    --data "{ \"title\": \"My first TODO\" }"</span><span id="0baf" class="no kv it nj b gy nt nq l nr ns">{"error":true,"reason":"Value of type 'TodoList' required for key 'list'."}<strong class="nj iu">%</strong></span></pre><p id="e270" class="pw-post-body-paragraph lm ln it lo b lp na ju lr ls nb jx lu lv nc lx ly lz nd mb mc md ne mf mg mh im bi translated">注意错误:键<code class="fe ng nh ni nj b">list</code>需要类型<code class="fe ng nh ni nj b">TodoList</code>的值。不幸的是，Vapor不会让你解码一个<code class="fe ng nh ni nj b">Todo</code>，除非你通过一个<code class="fe ng nh ni nj b">list</code>。有两种方法可以解决这个问题:</p><ul class=""><li id="5531" class="nu nv it lo b lp na ls nb lv nw lz nx md ny mh nz oa ob oc bi translated">备选方案1。删除<code class="fe ng nh ni nj b">guard/else</code>、<code class="fe ng nh ni nj b">todo.$list.id = listID</code>并在请求体中传递<code class="fe ng nh ni nj b">listID</code>:</li></ul><pre class="kj kk kl km gt nk nj nl nm aw nn bi"><span id="2a50" class="no kv it nj b gy np nq l nr ns">POST /v1/todo-lists/9F5D21D3-11F3-434D-907E-2DA083404C3F/todos<br/>{<br/>  "title": ...<br/>  "list": {<br/>    "id": "9F5D21D3-11F3-434D-907E-2DA083404C3F"<br/>  }<br/>}</span></pre><ul class=""><li id="7806" class="nu nv it lo b lp na ls nb lv nw lz nx md ny mh nz oa ob oc bi translated">选项2。创建一个<code class="fe ng nh ni nj b">struct</code>来解码信息(<code class="fe ng nh ni nj b">title</code>、<code class="fe ng nh ni nj b">description</code>)，从头开始创建一个新的<code class="fe ng nh ni nj b">todo</code>，填充其字段并保存:</li></ul><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oi oj l"/></div></figure><p id="3306" class="pw-post-body-paragraph lm ln it lo b lp na ju lr ls nb jx lu lv nc lx ly lz nd mb mc md ne mf mg mh im bi translated">选项2比选项1更麻烦，所以我们选择选项1。</p><p id="5784" class="pw-post-body-paragraph lm ln it lo b lp na ju lr ls nb jx lu lv nc lx ly lz nd mb mc md ne mf mg mh im bi translated">现在，如果我们使用添加的字段再次重试相同的操作:</p><pre class="kj kk kl km gt nk nj nl nm aw nn bi"><span id="6322" class="no kv it nj b gy np nq l nr ns">$ curl -X POST \<br/>    "localhost:8080/v1/todo-lists/9F5D21D3-11F3-434D-907E-2DA083404C3F/todos" \<br/>    -H "Content-Type:application/json" \<br/>    --data "{ \"title\": \"My first TODO\", \"list\": { \"id\": \"9F5D21D3-11F3-434D-907E-2DA083404C3F\" } }"</span><span id="7cbb" class="no kv it nj b gy nt nq l nr ns">{"id":"1840A97A-631A-4B35-9381-BD2FC27A3FA5","title":"My First TODO","list":{"id":"9F5D21D3-11F3-434D-907E-2DA083404C3F"},"description":null}<strong class="nj iu">%</strong></span></pre><p id="45a7" class="pw-post-body-paragraph lm ln it lo b lp na ju lr ls nb jx lu lv nc lx ly lz nd mb mc md ne mf mg mh im bi translated">我们的<code class="fe ng nh ni nj b">Todo</code>创造出来了！让我们通过获取父节点<code class="fe ng nh ni nj b">TodoList</code>来检查一下:</p><pre class="kj kk kl km gt nk nj nl nm aw nn bi"><span id="e415" class="no kv it nj b gy np nq l nr ns">curl -X GET "localhost:8080/v1/todo-lists/9F5D21D3-11F3-434D-907E-2DA083404C3F" | jq</span><span id="bea3" class="no kv it nj b gy nt nq l nr ns">{<br/>  "id": "9F5D21D3-11F3-434D-907E-2DA083404C3F",<br/>  "name":"Foo"<br/>}</span></pre><p id="f8d8" class="pw-post-body-paragraph lm ln it lo b lp na ju lr ls nb jx lu lv nc lx ly lz nd mb mc md ne mf mg mh im bi translated">哎呦！这份名单中似乎没有<code class="fe ng nh ni nj b">Todo</code>…或者有吗？让我们检查一下<code class="fe ng nh ni nj b">GET /v1/todo-lists/&lt;id&gt;</code>的实施情况:</p><pre class="kj kk kl km gt nk nj nl nm aw nn bi"><span id="a058" class="no kv it nj b gy np nq l nr ns">let uuid = req.parameters.get("id", as: UUID.self)<br/>return TodoList.find(uuid, on: req.db)<br/>  .unwrap(orError: Abort(.notFound))<br/>  .encodeResponse(for: req)</span></pre><p id="9bed" class="pw-post-body-paragraph lm ln it lo b lp na ju lr ls nb jx lu lv nc lx ly lz nd mb mc md ne mf mg mh im bi translated">注意我们是如何试图<code class="fe ng nh ni nj b">find</code> a <code class="fe ng nh ni nj b">TodoList</code>的，但是我们没有加载/获取任何子节点！实现需要稍微改变:</p><pre class="kj kk kl km gt nk nj nl nm aw nn bi"><span id="ca6e" class="no kv it nj b gy np nq l nr ns">let uuid = req.parameters.get("id", as: UUID.self)<br/>return TodoList.find(uuid, on: req.db)<br/>  .unwrap(orError: Abort(.notFound))<br/>  .flatMap { list in<br/>    list.$todos.load(on: req.db).map { list }<br/>  }<br/>  .encodeResponse(for: req)</span></pre><p id="d68f" class="pw-post-body-paragraph lm ln it lo b lp na ju lr ls nb jx lu lv nc lx ly lz nd mb mc md ne mf mg mh im bi translated">如果我们现在再试一次:</p><pre class="kj kk kl km gt nk nj nl nm aw nn bi"><span id="c297" class="no kv it nj b gy np nq l nr ns">curl -X GET "localhost:8080/v1/todo-lists/9F5D21D3-11F3-434D-907E-2DA083404C3F" | jq</span><span id="7757" class="no kv it nj b gy nt nq l nr ns">{<br/>  "id": "9F5D21D3-11F3-434D-907E-2DA083404C3F",<br/>  "name":"Foo",<br/>  "todos": [<br/>    {<br/>      "id": "1840A97A-631A-4B35-9381-BD2FC27A3FA5",<br/>      "title": "My First TODO",<br/>      "list": {<br/>        "id": "9F5D21D3-11F3-434D-907E-2DA083404C3F"<br/>      },<br/>      "description": null<br/>    }<br/>  ]<br/>}</span></pre><p id="29dd" class="pw-post-body-paragraph lm ln it lo b lp na ju lr ls nb jx lu lv nc lx ly lz nd mb mc md ne mf mg mh im bi translated">同样，<code class="fe ng nh ni nj b">/v1/todo-lists</code>也需要更新。这一次我们可以使用<code class="fe ng nh ni nj b">with</code>来创建连接查询:</p><pre class="kj kk kl km gt nk nj nl nm aw nn bi"><span id="d4ba" class="no kv it nj b gy np nq l nr ns">return TodoList.query(on: req.db)<br/>    .range(offset..&lt;(limit + offset))<br/>    .with(\.$todos)<br/>    .all()<br/>    .encodeResponse(for: req)</span></pre><h2 id="8dc4" class="no kv it bd kw ok ol dn la om on dp le lv oo op lg lz oq or li md os ot lk ou bi translated">提取所有待办事项</h2><p id="6f49" class="pw-post-body-paragraph lm ln it lo b lp lq ju lr ls lt jx lu lv lw lx ly lz ma mb mc md me mf mg mh im bi translated">我们在一个<code class="fe ng nh ni nj b">TodoList</code>中获取所有的<code class="fe ng nh ni nj b">Todo</code>怎么样？为此，我们需要通过一个<code class="fe ng nh ni nj b">listID</code>来<code class="fe ng nh ni nj b">query</code>所有的todos和<code class="fe ng nh ni nj b">filter</code>。让我们这样做:</p><pre class="kj kk kl km gt nk nj nl nm aw nn bi"><span id="09ae" class="no kv it nj b gy np nq l nr ns">private func getEntities(req: Request) throws -&gt; EventLoopFuture&lt;Response&gt; {<br/>  guard let listID = req.parameters.get("id", as: UUID.self) else {<br/>    throw Abort(.notFound)<br/>  }<br/>  return Todo.query(on: req.db)<br/>    .filter(\.$list.$id == listID)<br/>    .all()<br/>    .encodeResponse(for: req)<br/>}</span></pre><h1 id="a9ba" class="ku kv it bd kw kx ky kz la lb lc ld le jz lf ka lg kc lh kd li kf lj kg lk ll bi translated">结论</h1><p id="b169" class="pw-post-body-paragraph lm ln it lo b lp lq ju lr ls lt jx lu lv lw lx ly lz ma mb mc md me mf mg mh im bi translated">在本文中，我们在TodoApp的基础上构建了新的特性，并学习了构建Vapor项目的良好实践。我们还探索了模型关系的想法，以成功地将一个<code class="fe ng nh ni nj b">Todo</code>关联到一个<code class="fe ng nh ni nj b">TodoList</code>。</p><p id="d6d1" class="pw-post-body-paragraph lm ln it lo b lp na ju lr ls nb jx lu lv nc lx ly lz nd mb mc md ne mf mg mh im bi translated">在本文结束时，您应该有一个功能性的TodoApp。在最后一篇文章中，我将解释Vapor的更多高级特性，以将图像添加到<code class="fe ng nh ni nj b">TodoList</code>中。</p><p id="d5e8" class="pw-post-body-paragraph lm ln it lo b lp na ju lr ls nb jx lu lv nc lx ly lz nd mb mc md ne mf mg mh im bi translated">感谢阅读！</p><p id="44af" class="pw-post-body-paragraph lm ln it lo b lp na ju lr ls nb jx lu lv nc lx ly lz nd mb mc md ne mf mg mh im bi translated">敬请关注。</p></div></div>    
</body>
</html>