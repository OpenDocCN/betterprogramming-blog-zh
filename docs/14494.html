<html>
<head>
<title>Improving Python with Rust</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">用Rust改进Python</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/improving-python-with-rust-ed12bffd2ca4?source=collection_archive---------1-----------------------#2022-12-26">https://betterprogramming.pub/improving-python-with-rust-ed12bffd2ca4?source=collection_archive---------1-----------------------#2022-12-26</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="29ec" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">通过在Rust中创建自己的包，为您的Python代码增加一点本机速度和内存安全性</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/0e18d4938a0adc5cb2230e6577653246.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*G79gsJHvi7oFdJFr"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">詹姆斯·哈里逊在<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</p></figure><p id="46d5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">Rust，有时被称为Rustlang，是许多程序员最喜欢和钟爱的语言…尽管事实上它在Mozilla的出现仅仅是十年前的事情！</p><p id="21f3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">有些读到这里的人可能偶尔会看到一些文章或YouTube视频，宣传这种新的、令人难以置信的表演语言，但它到底是什么呢？</p><blockquote class="lv lw lx"><p id="1fd9" class="kz la ly lb b lc ld ju le lf lg jx lh lz lj lk ll ma ln lo lp mb lr ls lt lu im bi translated"><em class="it"> Rust是一种静态类型的编程语言，旨在提高性能和安全性，尤其是安全并发和内存管理。它的语法类似于c++……因为Rust没有持续运行的垃圾收集器，它的项目可以通过外部函数接口被其他编程语言用作库。这是现有项目的理想场景，在现有项目中，确保高性能同时维护内存安全至关重要</em></p></blockquote><p id="4734" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">更令人印象深刻的是，根据Stack Overflow民意调查，Rust连续六年保持了"<em class="ly">最受社区欢迎的</em>"语言！</p><h1 id="0584" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">永恒的最爱</h1><p id="4a5b" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">另一方面，Python在过去几年中一直保持在搜索次数最多的语言的前三名。虽然有些人坚持认为Python有点被高估了，也许不应该在顶级排名中，但我(以及无数其他人)认为它绝对应该有这样的地位！</p><p id="d872" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">下面的图表来自另一个堆栈溢出民意调查，它只是几个显示类似趋势的图表之一，概述了Python的持续流行:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi mz"><img src="../Images/878b2efebd4000d0bd8185a6ad78f040.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ZMsrnMq7NZ04WsxmAzPoqQ.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">民调依然强劲！</p></figure></div><div class="ab cl na nb hx nc" role="separator"><span class="nd bw bk ne nf ng"/><span class="nd bw bk ne nf ng"/><span class="nd bw bk ne nf"/></div><div class="im in io ip iq"><h1 id="d7f4" class="mc md it bd me mf nh mh mi mj ni ml mm jz nj ka mo kc nk kd mq kf nl kg ms mt bi translated">挥之不去的问题</h1><p id="1d22" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">因此，我们已经确定Python是一种非常受欢迎且(仍在)增长的语言，但这就是故事的全部吗？不，不尽然…尽管Python 3.11的最新版本给这种语言带来了显著的速度提升(而且是显著的！)，房间里还有一头巨大的大象，许多经验丰富的程序员在解释为什么他们不只用Python写所有东西时会指出:<em class="ly">这是一种解释语言，往往缺乏大量、低级的性能能力。</em></p><p id="dc69" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">然而，作为一种解释型语言，<em class="ly">无论如何也不会让它变坏！</em>Python作为一种真正受欢迎的、易于使用的语言继续保持其统治地位是有原因的(嗯，有几个原因)。</p><p id="00b0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">但问题是，因为它是一种解释语言，所以在运行时必须通过目标系统上的<code class="fe nm nn no np b">just in time</code>编译器来运行。这使得它的效率略低于其他语言，如Rust、Go和C/C++，这些语言都编译成本机代码二进制，系统可以立即运行<em class="ly">而不需要</em>中间程序。</p><h1 id="b8c4" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">切实可行的解决办法</h1><p id="cb43" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">我敢肯定，你们中的许多人，包括我自己，都希望利用Python提供的出色的可读性、灵活性和包容量……同时在需要执行密集的低级任务时实现Rust提供的更高的性能提升。想要鱼与熊掌兼得并没有错！毕竟，如果你连蛋糕都吃不下，那吃蛋糕又有什么意义呢？！</p><p id="0e24" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">正如所发生的那样，有一个很好的选择可以让我们实现这两个目标！</p><p id="1969" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在本文的剩余部分，我们将看到一个名为<code class="fe nm nn no np b">pyo3</code>的优秀包，它允许我们使用Rust编写和发布自己的Python包。之后，我们可以使用<code class="fe nm nn no np b">pip</code> <em class="ly">将它们安装并导入到我们的Python项目中，就像我们对任何其他模块所做的那样</em>...很简单！</p><p id="2559" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">像这样的项目的现实需求可能来自许多不同的场景:</p><ul class=""><li id="e812" class="nq nr it lb b lc ld lf lg li ns lm nt lq nu lu nv nw nx ny bi translated">您有一个团队，他们在创建基于Python的命令行应用程序方面更加熟练，但是需要合并一些密集的I/O任务，这些任务需要更高效、更低级的语言(如Rust)来实现</li><li id="d234" class="nq nr it lb b lc nz lf oa li ob lm oc lq od lu nv nw nx ny bi translated">您已经使用Python开发了一个项目，但是希望将来的代码添加用Rust编写，以便利用它的性能和资源安全性</li><li id="21cc" class="nq nr it lb b lc nz lf oa li ob lm oc lq od lu nv nw nx ny bi translated">Python的<em class="ly">直截了当的语法</em>和大量第三方<em class="ly">包</em>使其成为构建终端应用程序的绝佳选择……结合一些针对低级任务的本地Rust代码，您就拥有了一个可供您使用的框架！</li></ul><p id="c68f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">不管您需要这样的混合项目结构的原因是什么，目标都是一样的:</p><blockquote class="oe"><p id="132c" class="of og it bd oh oi oj ok ol om on lu dk translated">将这两种语言的精华结合在一起，创建出高性能、内存安全、外观漂亮的程序。</p></blockquote><p id="da73" class="pw-post-body-paragraph kz la it lb b lc oo ju le lf op jx lh li oq lk ll lm or lo lp lq os ls lt lu im bi translated">在将这个小项目的各个部分放在一起之后，如果您想要或需要使用Rust来改进基于Python的应用程序，您应该对可用的可能性有一个相当好的理解！</p></div><div class="ab cl na nb hx nc" role="separator"><span class="nd bw bk ne nf ng"/><span class="nd bw bk ne nf ng"/><span class="nd bw bk ne nf"/></div><div class="im in io ip iq"><h1 id="fea4" class="mc md it bd me mf nh mh mi mj ni ml mm jz nj ka mo kc nk kd mq kf nl kg ms mt bi translated">入门指南</h1><p id="1e9a" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">我们将在这里创建的整个项目将由两个子部分组成:</p><ul class=""><li id="da93" class="nq nr it lb b lc ld lf lg li ns lm nt lq nu lu nv nw nx ny bi translated">由我们的Python应用程序将导入和调用的测试函数组成的Rust crate(第1部分)</li><li id="cce7" class="nq nr it lb b lc nz lf oa li ob lm oc lq od lu nv nw nx ny bi translated">一个Python应用程序，它将作为我们命令行界面的主要基础(第2部分)</li></ul><p id="c70d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">从表面上看，这似乎需要做很多工作，但实际上，开发和扩展起来都相对简单明了。</p><p id="9cb9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果您想下载项目这一部分的示例代码，请在GitHub上访问并克隆它的repo！</p><div class="ot ou gp gr ov ow"><a href="https://github.com/dedSyn4ps3/rusty-python" rel="noopener  ugc nofollow" target="_blank"><div class="ox ab fo"><div class="oy ab oz cl cj pa"><h2 class="bd iu gy z fp pb fr fs pc fu fw is bi translated">GitHub - dedSyn4ps3/rusty-python</h2><div class="pd l"><h3 class="bd b gy z fp pb fr fs pc fu fw dk translated">这个机箱是为了测试python-with-rust命令行应用程序而编写的，而这个项目绝不是…</h3></div><div class="pe l"><p class="bd b dl z fp pb fr fs pc fu fw dk translated">github.com</p></div></div><div class="pf l"><div class="pg l ph pi pj pf pk ks ow"/></div></div></a></div><h1 id="2101" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">建造我们的锈箱</h1><p id="fa61" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">首先，如果你还没有安装Rust和它的软件包管理器，你可能想尽快安装。</p><ul class=""><li id="5dc1" class="nq nr it lb b lc ld lf lg li ns lm nt lq nu lu nv nw nx ny bi translated">在Unix上，在您的shell中运行<code class="fe nm nn no np b">curl https://sh.rustup.rs -sSf | sh</code>。这将下载并运行<code class="fe nm nn no np b"><a class="ae ky" href="https://static.rust-lang.org/rustup/rustup-init.sh" rel="noopener ugc nofollow" target="_blank">rustup-init.sh</a></code>，它将依次下载并运行适用于您的平台的正确版本的<code class="fe nm nn no np b">rustup-init</code>可执行文件。</li><li id="8474" class="nq nr it lb b lc nz lf oa li ob lm oc lq od lu nv nw nx ny bi translated">在Windows上，下载并运行<code class="fe nm nn no np b"><a class="ae ky" href="https://static.rust-lang.org/rustup/dist/i686-pc-windows-gnu/rustup-init.exe" rel="noopener ugc nofollow" target="_blank">rustup-init.exe</a></code></li></ul><p id="f9a1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">为了给我们的新板条箱打基础，我们将使用两个重要的工具，<code class="fe nm nn no np b">pyo3</code>和<code class="fe nm nn no np b">maturin</code>...后者将允许我们轻松地生成导出Rust代码以用于Python所需的框架。安装最后这些要求非常简单，根据您的操作系统，可以通过以下方式实现:</p><ul class=""><li id="0d7e" class="nq nr it lb b lc ld lf lg li ns lm nt lq nu lu nv nw nx ny bi translated">macOS用户可以通过运行<code class="fe nm nn no np b">brew install maturin</code>使用自制软件进行安装</li><li id="0639" class="nq nr it lb b lc nz lf oa li ob lm oc lq od lu nv nw nx ny bi translated">所有人都可以选择使用<code class="fe nm nn no np b">pip install maturin</code>进行全局安装</li><li id="8990" class="nq nr it lb b lc nz lf oa li ob lm oc lq od lu nv nw nx ny bi translated">推荐的方法是使用<code class="fe nm nn no np b">pipx</code>在隔离的虚拟环境中安装<code class="fe nm nn no np b">maturin</code></li></ul><p id="fb43" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">解决了这个问题后，继续前进并导航到您想要创建项目的位置，然后使用您喜欢的shell运行以下命令:</p><pre class="kj kk kl km gt pl np pm bn pn po bi"><span id="5a92" class="pp md it np b be pq pr l ps pt">maturin new -b pyo3 rusty-python &amp;&amp; cd rusty-python</span></pre><p id="0f79" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这将生成我们的基本项目结构，包括必要的<code class="fe nm nn no np b">Cargo.toml</code>文件，我们将向其中添加我们需要的依赖项，以及一个<code class="fe nm nn no np b">pyproject.toml</code>文件Python将在适当的时候使用它来构建和安装我们的包。<code class="fe nm nn no np b">-b pyo3</code>标志告诉<code class="fe nm nn no np b">maturin</code>我们将使用那个框架来创建我们的新模块。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi pu"><img src="../Images/a8ca8ea9b5b5e35709de9d6ddf39dacf.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*M2PB6myDryw2wsh18iJJYw.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">我们的新项目</p></figure><h1 id="7789" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">积木</h1><p id="7abd" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">你会注意到<code class="fe nm nn no np b">maturin</code>也为我们创建了一个<code class="fe nm nn no np b">src/lib.rs</code>文件。这是我们板条箱的所有代码和功能将驻留的地方。</p><p id="ca36" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">它已经包含了一些简单的样板文件，展示了我们如何创建函数导出供Python应用程序使用:</p><pre class="kj kk kl km gt pl np pm bn pn po bi"><span id="4eac" class="pp md it np b be pq pr l ps pt">use pyo3::prelude::*;<br/><br/>/// Formats the sum of two numbers as string.<br/>#[pyfunction]<br/>fn sum_as_string(a: usize, b: usize) -&gt; PyResult&lt;String&gt; {<br/> Ok((a + b).to_string())<br/>}<br/><br/>/// A Python module implemented in Rust.<br/>#[pymodule]<br/>fn rusty_python(_py: Python, m: &amp;PyModule) -&gt; PyResult&lt;()&gt; {<br/> m.add_function(wrap_pyfunction!(sum_as_string, m)?)?;<br/> Ok(())<br/>}</span></pre><p id="85c9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们的crate由不同的函数定义组成，这些函数定义用<code class="fe nm nn no np b">pyfunction</code>属性进行了注释。为了使用这些函数，我们定义另一个用<code class="fe nm nn no np b">pymodule</code>属性注释的函数体，然后使用<code class="fe nm nn no np b">add_function</code>实现<code class="fe nm nn no np b">pyfunction(s)</code>:</p><pre class="kj kk kl km gt pl np pm bn pn po bi"><span id="b659" class="pp md it np b be pq pr l ps pt">/// Says hello.<br/>#[pyfunction]<br/>fn say_hello(name: &amp;str) {<br/> println!("Hello there {name}!");<br/>}<br/><br/>/// Runs several test loops<br/>#[pyfunction]<br/>fn run_loops() {<br/> logger::info("Running test loops...");<br/> let mut _count: u32 = 0;  <br/> for _ in 0..1000 {<br/>  for _ in 0..100 {<br/>   _count += 1;<br/>  }<br/> } <br/> print!("\n");<br/> logger::debug("Process Finished");<br/>}<br/><br/>#[pymodule]<br/>fn rusty_python(_py: Python, m: &amp;PyModule) -&gt; PyResult&lt;()&gt; {<br/> m.add_function(wrap_pyfunction!(sum_as_string, m)?)?;<br/> m.add_function(wrap_pyfunction!(say_hello, m)?)?;<br/> m.add_function(wrap_pyfunction!(run_loops, m)?)?;<br/> Ok(())<br/>}</span></pre><p id="2184" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">样板文件本身为我们提供了一个用Python进行测试的工作解决方案，但是出于演示的目的，我们将继续创建一个额外的<code class="fe nm nn no np b">pyfunction</code>,它使用一些提供的输入来打印Hello消息。你可以在上面的<em class="ly">代码信息</em>中看到如何做这件事:</p><ul class=""><li id="5227" class="nq nr it lb b lc ld lf lg li ns lm nt lq nu lu nv nw nx ny bi translated">使用<code class="fe nm nn no np b">pyfunction</code>属性声明两个新函数</li><li id="bd8f" class="nq nr it lb b lc nz lf oa li ob lm oc lq od lu nv nw nx ny bi translated">将新创建的<code class="fe nm nn no np b">pyfunctions</code>添加到我们的<code class="fe nm nn no np b">rusty-python</code>模块中</li></ul></div><div class="ab cl na nb hx nc" role="separator"><span class="nd bw bk ne nf ng"/><span class="nd bw bk ne nf ng"/><span class="nd bw bk ne nf"/></div><div class="im in io ip iq"><h1 id="db27" class="mc md it bd me mf nh mh mi mj ni ml mm jz nj ka mo kc nk kd mq kf nl kg ms mt bi translated">上传我们的板条箱</h1><p id="62c4" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">为了方便地安装我们的新Rust crate并将其导入到未来的Python项目中，我们必须将它上传到一个版本控制系统，如<code class="fe nm nn no np b">Github</code>或<code class="fe nm nn no np b">Gitlab</code>(或任何其他您可能使用的服务)。</p><p id="84c3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">对于那些不熟悉创建存储库并将我们的代码推送到存储库的过程的人来说，这里有一个简短的纲要:</p><ul class=""><li id="7566" class="nq nr it lb b lc ld lf lg li ns lm nt lq nu lu nv nw nx ny bi translated">登录到您的GitHub/Gitlab帐户，创建一个新的空存储库</li><li id="b6f8" class="nq nr it lb b lc nz lf oa li ob lm oc lq od lu nv nw nx ny bi translated">切换回您的终端，从项目目录的根目录运行<code class="fe nm nn no np b">git init</code></li><li id="198e" class="nq nr it lb b lc nz lf oa li ob lm oc lq od lu nv nw nx ny bi translated">初始化完成后，您需要将它链接到您的远程存储库，这样您就可以将所有新的更改推送给它。只需运行以下命令:</li></ul><pre class="kj kk kl km gt pl np pm bn pn po bi"><span id="7e85" class="pp md it np b be pq pr l ps pt">git remote add origin https://github.com/&lt;username&gt;/&lt;repo-name&gt;.git<br/>git branch -M main<br/>git add .<br/>git commit -m "First Commit"<br/>git push -u origin main</span></pre><p id="b232" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">简单回顾一下，下面是我们需要为Rust-Python混合应用程序准备的内容:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi pv"><img src="../Images/59c42ffc3c81f081a3f459ebae6bb40d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ePzyCFEZPfsOM78lILoEPw.png"/></div></div></figure><p id="116a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果您想继续了解项目这一部分的代码，请访问GitHub repo并克隆它！</p><div class="ot ou gp gr ov ow"><a href="https://github.com/dedSyn4ps3/python-with-rust" rel="noopener  ugc nofollow" target="_blank"><div class="ox ab fo"><div class="oy ab oz cl cj pa"><h2 class="bd iu gy z fp pb fr fs pc fu fw is bi translated">GitHub-dedsyn 4 PS 3/python-with-rust</h2><div class="pd l"><h3 class="bd b gy z fp pb fr fs pc fu fw dk translated">虽然这是一个非常简单的例子，但这个应用程序是为用rusty-python测试箱进行测试而编写的…</h3></div><div class="pe l"><p class="bd b dl z fp pb fr fs pc fu fw dk translated">github.com</p></div></div><div class="pf l"><div class="pw l ph pi pj pf pk ks ow"/></div></div></a></div><h1 id="034b" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">构建我们的Python应用</h1><p id="7b48" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">现在是时候完成我们项目的最后一站了！如果你现在还没有注意到，我们需要安装Python来完成工作！</p><ul class=""><li id="e62b" class="nq nr it lb b lc ld lf lg li ns lm nt lq nu lu nv nw nx ny bi translated">对于Linux用户，只需打开终端，运行<code class="fe nm nn no np b">sudo pacman install python3</code>、<code class="fe nm nn no np b">sudo apt install -y python3</code>等。这取决于您的软件包管理员。您的系统应该已经安装了Python，但是我强烈建议至少安装<code class="fe nm nn no np b">v3.8+</code>(最好安装<code class="fe nm nn no np b">3.11</code>，这样会快很多)。</li><li id="831d" class="nq nr it lb b lc nz lf oa li ob lm oc lq od lu nv nw nx ny bi translated">在Windows和macOS上，您可以从python.org下载安装程序可执行文件</li></ul><p id="7161" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">为了把这个小例子放在一起，我们将只使用少数几个包来提供一个可以扩展并用于其他项目的工作代码库。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi px"><img src="../Images/829e625212c7d2f645848dfc20104a48.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*s8PgEXSmPtyT2RmtXZ6jww.png"/></div></div></figure><h1 id="88f0" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">积木</h1><p id="2e4c" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">为Python应用程序创建一个新的项目文件夹，并创建几个示例文件进行测试:</p><pre class="kj kk kl km gt pl np pm bn pn po bi"><span id="9ac2" class="pp md it np b be pq pr l ps pt">├── api<br/>│   ├── __init__.py<br/>│   └── update.py<br/>└── cmd.py</span></pre><p id="9b54" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe nm nn no np b">api</code>模块目录只包含几个函数，我们可以在主命令行应用程序中使用它们来模拟典型的应用程序导入:</p><pre class="kj kk kl km gt pl np pm bn pn po bi"><span id="7bad" class="pp md it np b be pq pr l ps pt">import time<br/>from rich.progress import track<br/><br/>def checkVersion(name):<br/> version = "1.0.0"<br/> getUpdate(f"Fetching current version for {name}...")<br/> print(f"\n[+] All Good! You're using the most recent of {name} --&gt; {version}\n")<br/><br/>def getUpdate(description):<br/> for i in track(range(100), description=description):<br/>  time.sleep(.1) # Simulate work being done</span></pre><p id="5ec1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果您注意到引用了<code class="fe nm nn no np b">rich</code>的import语句，并且不熟悉这个库，<a class="ae ky" href="https://github.com/Textualize/rich" rel="noopener ugc nofollow" target="_blank">请查看一下！</a>我一直喜欢将Python终端应用程序放在一起的最大原因之一是因为它为寻求创造伟大事物的开发人员提供了大量的灵活性和库选项！</p><p id="7a74" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">主<code class="fe nm nn no np b">cmd.py</code>文件是我们命令行应用程序的逻辑所在之处:</p><pre class="kj kk kl km gt pl np pm bn pn po bi"><span id="39ee" class="pp md it np b be pq pr l ps pt">#!/usr/bin/env python<br/>import argparse<br/>from api import update<br/>import rusty_python as rp<br/><br/>d = """<br/>API test application using a combination<br/>of pure Python functions and additional<br/>helper modules written in Rust.<br/>This application uses several Python libraries to<br/>create a colorful commandline app with example<br/>functionality implemented in Rust<br/>"""<br/><br/>def cli():<br/> parser = argparse.ArgumentParser(<br/>  description=d<br/> )<br/><br/> parser.add_argument(<br/>  "-n", "--app-name",<br/>  action="store",<br/>  required=False,<br/>  help="App name to use for update download simulation"<br/> )<br/><br/> parser.add_argument(<br/>  "-l", "--loop",<br/>  action="store_true",<br/>  required=False,<br/>  help="Run some test loops!. Uses `run_loops` implemented in Rust"<br/>  )<br/><br/> parser.add_argument(<br/>  "-r", "--rust-arg",<br/>  action="store",<br/>  required=False,<br/>  help="""<br/>  Tell us your name! This `string` value gets passed<br/>  to the `say_hello` function implemented in Rust. The function also runs<br/>  multiple `async` requests<br/>  """<br/> )<br/> <br/> args = parser.parse_args()<br/><br/> if args:<br/>  if args.app_name:<br/>   update.checkVersion(args.app_name)<br/>  if args.loop:<br/>   rp.run_loops()<br/>  if args.rust_arg:<br/>   rp.say_hello(args.rust_arg)<br/>   rp.begin_request_test()<br/> else:<br/>  parser.print_usage()  <br/><br/>if __name__ == '__main__':<br/> cli()</span></pre></div><div class="ab cl na nb hx nc" role="separator"><span class="nd bw bk ne nf ng"/><span class="nd bw bk ne nf ng"/><span class="nd bw bk ne nf"/></div><div class="im in io ip iq"><h1 id="1aec" class="mc md it bd me mf nh mh mi mj ni ml mm jz nj ka mo kc nk kd mq kf nl kg ms mt bi translated">快速分解</h1><p id="0358" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">尽管上面的代码非常简单，但是随着项目复杂性和规模的增加，它与您将在未来项目中使用的结构类型完全相同。组装<code class="fe nm nn no np b">CLI</code>应用程序时，设计遵循相同的标准指南:</p><ul class=""><li id="6176" class="nq nr it lb b lc ld lf lg li ns lm nt lq nu lu nv nw nx ny bi translated">安装并导入<code class="fe nm nn no np b">argparse</code>库，以便在程序执行期间定义和读取输入参数</li><li id="b22d" class="nq nr it lb b lc nz lf oa li ob lm oc lq od lu nv nw nx ny bi translated">定义我们的主<code class="fe nm nn no np b">cli</code>函数来处理所有的程序逻辑</li><li id="8b31" class="nq nr it lb b lc nz lf oa li ob lm oc lq od lu nv nw nx ny bi translated">创建并实例化一个新的<code class="fe nm nn no np b">parser</code>对象，并定义应用程序将接受的不同标志和参数</li></ul><h1 id="be1b" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">把所有的放在一起</h1><p id="ba12" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">现在终于到了测试这个项目并利用我们在Rust上一篇文章中实现的定制包的时候了！然而，在您跳到前面运行<code class="fe nm nn no np b">cmd.py</code>之前，请记住导入到我们的应用程序中的几个模块不能立即供Python使用！</p><p id="62b6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">请记住，我们包含了<code class="fe nm nn no np b">rich</code>库，以帮助我们的应用程序看起来更好，并随着项目的扩大提供额外的功能。我们还添加了import语句，允许我们从Rust中实现的包中调用函数。</p><p id="3ca6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">为了把最后的部分放好，我们只需要运行几个<code class="fe nm nn no np b">pip</code>命令来安装缺失的依赖项:</p><pre class="kj kk kl km gt pl np pm bn pn po bi"><span id="cb66" class="pp md it np b be pq pr l ps pt">$ pip install rich<br/>$ pip install -i https://test.pypi.org/simple/ rusty-python</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi px"><img src="../Images/c248648a56b9f0d9463dd949d24d160f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*-VUVXu5I786OGKoeN91M6A.png"/></div></div></figure><p id="4006" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">安装完最后的依赖项后，我们终于可以运行新的小命令行应用程序并测试一些东西了！与大多数CLI应用程序一样，除了<code class="fe nm nn no np b">-h</code>或<code class="fe nm nn no np b">— help</code>之外，在没有任何参数的情况下开始运行代码通常是一个好主意，以验证我们的使用信息是否为我们的用户打印出来:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi py"><img src="../Images/b28fb5f64771ee613d354886599a4e67.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*LfGgOY6XhEyycc-t_nHOdw.png"/></div></div></figure></div><div class="ab cl na nb hx nc" role="separator"><span class="nd bw bk ne nf ng"/><span class="nd bw bk ne nf ng"/><span class="nd bw bk ne nf"/></div><div class="im in io ip iq"><p id="3d32" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">到目前为止一切顺利！之后，我们可以通过向应用程序传递参数来测试常规的Python函数… <em class="ly">，然后对来自Rust包</em>的函数做同样的事情。如果一切顺利，不应该有任何意外的错误或崩溃…输出应该就像任何其他正常的函数调用。</p><h1 id="7488" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">包裹</h1><p id="e624" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">在经历了各种步骤之后，达到这一步可能看起来有点乏味，但实际上，您已经成功地将Rust中实现的功能整合到Python应用程序中，并在其中使用它……从这一点开始，您的选择几乎是无限的！</p></div></div>    
</body>
</html>