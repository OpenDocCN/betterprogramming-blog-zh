<html>
<head>
<title>A Look Into Variables and Immutability in Rust</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">《铁锈》中的变量和不变性</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/quick-look-into-variables-and-immutability-in-rust-writing-safe-code-from-the-start-b31635478779?source=collection_archive---------10-----------------------#2022-06-05">https://betterprogramming.pub/quick-look-into-variables-and-immutability-in-rust-writing-safe-code-from-the-start-b31635478779?source=collection_archive---------10-----------------------#2022-06-05</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="4263" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">从一开始就编写安全代码</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/d9161f75de75c677d89f6f6a02c9b0dd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*CAojeDWuntM_lnX3eMUB-g.jpeg"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">Rust原则——不变性和可预测行为</p></figure><p id="376e" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">本文讨论了变量和Rust语言中与可变性相关的一些概念。默认情况下，Rust中的所有变量都是不可变的。我们将看看可变性，以及这些约定如何让我们这些程序员受益。我们还将看到编译器如何帮助我们确保程序的正确性。</p><p id="117e" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">考虑下面的例子</p><pre class="kj kk kl km gt lu lv lw lx aw ly bi"><span id="5512" class="lz ma it lv b gy mb mc l md me">#[test]<br/><strong class="lv iu">pub fn </strong>test_create_new_event_in_different_scope() {<br/>    <strong class="lv iu">let </strong>event_name = <strong class="lv iu">"user_logged_in"</strong>.to_string();<br/>    println!(<strong class="lv iu">"Original event name is {} " </strong>, event_name)<br/>}</span></pre><p id="142c" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">在这个例子中，我们考虑一个字符串。字符串很特殊，因为它们不是基本类型，需要堆空间来存储。在现实世界中，当处理内存问题或共享状态时，人们会更频繁地处理结构或复杂对象。</p><p id="6974" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">在Rust中，任何改变变量名的尝试都会导致编译器错误。试试下面的例子</p><pre class="kj kk kl km gt lu lv lw lx aw ly bi"><span id="44f0" class="lz ma it lv b gy mb mc l md me">#[test]<br/><strong class="lv iu">pub fn </strong>test_create_new_event_change_name() {<br/>    <strong class="lv iu">let </strong>event_name = <strong class="lv iu">"user_logged_in"</strong>.to_string();<br/>    event_name = <strong class="lv iu">"Hello_world"</strong>.to_string(); <br/>    println!(<strong class="lv iu">"Original event name is {} " </strong>, event_name)<br/>}</span></pre><p id="f3da" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">编译这个程序会抛出一个错误。</p><pre class="kj kk kl km gt lu lv lw lx aw ly bi"><span id="bd2e" class="lz ma it lv b gy mb mc l md me">   |<br/>41 |         let event_name = "user_logged_in".to_string();<br/>   |             ----------<br/>   |             |<br/>   |             first assignment to `event_name`<br/>   |             help: consider making this binding mutable: `mut event_name`<br/>42 |         event_name = "Hello_world".to_string();<br/>   |         ^^^^^^^^^^ cannot assign twice to immutable variable</span></pre><p id="65ca" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">在任何情况下，错误消息都是极好的。在上面的例子中，修改一个字符串变量需要程序重新分配内存和移动一些引用。如果我们想改变它，我们必须声明它是可变的。这不仅限于字符串和对象。甚至像<code class="fe mf mg mh lv b">u32</code>、<code class="fe mf mg mh lv b">i64</code>、<code class="fe mf mg mh lv b">floats</code>这样的原始类型也有同样的限制。</p><p id="7df4" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">让我们再看几个例子，我们想变异一个变量..</p><h1 id="abd7" class="mi ma it bd mj mk ml mm mn mo mp mq mr jz ms ka mt kc mu kd mv kf mw kg mx my bi translated">可变变量</h1><pre class="kj kk kl km gt lu lv lw lx aw ly bi"><span id="56c2" class="lz ma it lv b gy mb mc l md me">#[derive(Deserialize, Debug)]<br/><strong class="lv iu">pub struct </strong>Event {<br/>    <strong class="lv iu">pub client_id</strong>: ClientIdentifier,<br/>    <strong class="lv iu">pub name</strong>: String,<br/>    <strong class="lv iu">pub data</strong>: HashMap&lt;String, Value&gt;,<br/>}</span><span id="61e0" class="lz ma it lv b gy mz mc l md me">#[test]<br/><strong class="lv iu">pub fn </strong>test_create_new_event_update_data() {</span><span id="54a9" class="lz ma it lv b gy mz mc l md me">    <strong class="lv iu">let </strong>event_name = <strong class="lv iu">"user_logged_in"</strong>.to_string();<br/>    <strong class="lv iu">let </strong>client_id = <strong class="lv iu">"test_client"</strong>.to_string();<br/>    <strong class="lv iu">let </strong>new_event = Event { <strong class="lv iu">name</strong>: event_name, <strong class="lv iu">client_id</strong>: client_id, <strong class="lv iu">data</strong>: HashMap::<em class="na">new</em>() };<br/>    new_event.<strong class="lv iu">data</strong>.insert(<strong class="lv iu">"device_model"</strong>.to_string(), Value::<em class="na">String</em>(<strong class="lv iu">"iPhone"</strong>.to_string()));<br/>    println!(<strong class="lv iu">"Event name is {} "</strong>, &amp;new_event.<strong class="lv iu">name</strong>);<br/>}</span></pre><p id="04a7" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">考虑这个例子。对于任何接触过Java、Python或其他高级编程语言的人来说，这是一个非常简单的操作。一旦我们运行测试，我们期望用新的键/值对更新<code class="fe mf mg mh lv b">HashMap</code>。</p><p id="4748" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">在Rust的情况下，这个程序编译失败。这是我们将会看到的错误信息。</p><pre class="kj kk kl km gt lu lv lw lx aw ly bi"><span id="42cc" class="lz ma it lv b gy mb mc l md me">error[E0596]: cannot borrow `new_event.data` as mutable, as `new_event` is not declared as mutable<br/>  --&gt; analytix/core/src/models.rs:40:9<br/>   |<br/>39 |         let new_event = Event { name: event_name, client_id: client_id, data: HashMap::new() };<br/>   |             --------- help: consider changing this to be mutable: `mut new_event`<br/>40 |         new_event.data.insert("device_model".to_string(), Value::String("iPhone".to_string()));<br/>   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ cannot borrow as mutable</span></pre><p id="6e00" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated"><strong class="la iu">插入</strong> <code class="fe mf mg mh lv b"><strong class="la iu">HashMap</strong></code> <strong class="la iu">是一个更新操作</strong>。<strong class="la iu">数据被修改并插入其内部结构</strong>。当这种情况发生时，我们必须明确告诉Rust我们打算在测试中更新<code class="fe mf mg mh lv b">HashMap</code>。为了解决这个问题，我们使用一个<code class="fe mf mg mh lv b">mut</code>关键字重新声明我们的<code class="fe mf mg mh lv b">HashMap</code>。</p><pre class="kj kk kl km gt lu lv lw lx aw ly bi"><span id="429d" class="lz ma it lv b gy mb mc l md me"><strong class="lv iu">let mut </strong>new_event = Event { <strong class="lv iu">name</strong>: event_name, <strong class="lv iu">client_id</strong>: client_id, <strong class="lv iu">data</strong>: HashMap::<em class="na">new</em>() };</span></pre><p id="e219" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">关键字告诉编译器一个变量将会有一个可变的操作。无论我们处理哪种数据类型，<code class="fe mf mg mh lv b">mut</code>关键字适用于一切。</p><h1 id="e197" class="mi ma it bd mj mk ml mm mn mo mp mq mr jz ms ka mt kc mu kd mv kf mw kg mx my bi translated">可变函数</h1><p id="19c2" class="pw-post-body-paragraph ky kz it la b lb nb ju ld le nc jx lg lh nd lj lk ll ne ln lo lp nf lr ls lt im bi translated">在上面的例子中，我们将变量标记为可变的。当我们更新一个<code class="fe mf mg mh lv b">HashMap.</code>时，我们知道不仅仅是我们的变量被更新了，而且<code class="fe mf mg mh lv b">HashMap</code>本身也发生了变异。</p><p id="f750" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">当插入数据时，内部结构需要计算散列，检测冲突，并将值插入正确的桶中。这需要函数告诉开发人员可变操作也存在于内部。看看下面HashMap的函数签名:</p><pre class="kj kk kl km gt lu lv lw lx aw ly bi"><span id="922b" class="lz ma it lv b gy mb mc l md me">#[inline]<br/>#[stable(feature = <strong class="lv iu">"rust1"</strong>, since = <strong class="lv iu">"1.0.0"</strong>)]<br/><strong class="lv iu">pub fn </strong>insert(&amp;<strong class="lv iu">mut self</strong>, k: K, v: V) -&gt; Option&lt;V&gt; {<br/>    <strong class="lv iu">self</strong>.<strong class="lv iu">base</strong>.insert(k, v)<br/>}</span></pre><p id="fb1c" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">这个定义是标准Rust库的一部分。它清楚地说明，任何试图在HashMap中插入键的调用者都必须传入一个对<code class="fe mf mg mh lv b">HashMap</code>本身的可变引用来更新它。像变量声明一样，Rust函数/方法声明也希望开发人员这样做。否则，当我们试图编码我们的程序时，我们会看到很多编译错误。</p><h1 id="1b1e" class="mi ma it bd mj mk ml mm mn mo mp mq mr jz ms ka mt kc mu kd mv kf mw kg mx my bi translated">有什么帮助？</h1><p id="3a25" class="pw-post-body-paragraph ky kz it la b lb nb ju ld le nc jx lg lh nd lj lk ll ne ln lo lp nf lr ls lt im bi translated">通过在代码的每个部分定义可变性限制，我们从Rust获得的一个巨大好处是它的编译器能够检测我们代码中的数据竞争、内存泄漏和漏洞。上面的例子非常简单。但是在更复杂的应用程序中，多线程可能会改变数据，我们真的不希望在处理这些时出现意外的行为。铁锈阻止我们犯这样的错误和行为。</p><p id="6217" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">就个人而言，它帮助我们以一些额外的代码为代价编写可预测的程序。但是这个方面可能会节省我们在检测和修复代码问题上的时间，甚至是几天。和不变性通常是一种好的实践！</p></div><div class="ab cl ng nh hx ni" role="separator"><span class="nj bw bk nk nl nm"/><span class="nj bw bk nk nl nm"/><span class="nj bw bk nk nl"/></div><div class="im in io ip iq"><p id="2cfb" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">我不建议每个用例都用Rust。在决定框架/语言之前，必须选择并仔细分析开发和系统的所有方面。但是理解Rust的原则会让每个开发人员想到正确的方法和原则来编写干净、可预测和高性能的代码。</p></div></div>    
</body>
</html>