<html>
<head>
<title>React State Management in 2020</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">2020年反应状态管理</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/react-state-management-in-2020-719d10c816bf?source=collection_archive---------0-----------------------#2020-01-17">https://betterprogramming.pub/react-state-management-in-2020-719d10c816bf?source=collection_archive---------0-----------------------#2020-01-17</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="8001" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">我们还需要像Redux和MobX这样的状态管理框架吗？</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/4436763a62f537f25d83d253eed745fb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*JNpk3yLpt9f4x_aEO5pa-w.jpeg"/></div></div></figure><h1 id="c086" class="ku kv it bd kw kx ky kz la lb lc ld le jz lf ka lg kc lh kd li kf lj kg lk ll bi translated">介绍</h1><p id="9f7f" class="pw-post-body-paragraph lm ln it lo b lp lq ju lr ls lt jx lu lv lw lx ly lz ma mb mc md me mf mg mh im bi translated">React钩子的引入无疑改变了对状态管理的看法。</p><p id="a38a" class="pw-post-body-paragraph lm ln it lo b lp mi ju lr ls mj jx lu lv mk lx ly lz ml mb mc md mm mf mg mh im bi translated">在我们拥有这个特性之前，很难在组件之间共享状态逻辑。现在就像给它做一个抽象的钩子一样简单(例:<code class="fe mn mo mp mq b">useUserLogin</code>)。</p><p id="9412" class="pw-post-body-paragraph lm ln it lo b lp mi ju lr ls mj jx lu lv mk lx ly lz ml mb mc md mm mf mg mh im bi translated">这就提出了一个问题，为什么我们仍然需要状态管理框架？在这篇文章中，我将描述我在哪里保留<code class="fe mn mo mp mq b">state</code>的决策过程。我还将分享我对2020年我们是否还需要国家管理框架的看法。</p></div><div class="ab cl mr ms hx mt" role="separator"><span class="mu bw bk mv mw mx"/><span class="mu bw bk mv mw mx"/><span class="mu bw bk mv mw"/></div><div class="im in io ip iq"><h1 id="3fb2" class="ku kv it bd kw kx my kz la lb mz ld le jz na ka lg kc nb kd li kf nc kg lk ll bi translated">什么变了？</h1><p id="7345" class="pw-post-body-paragraph lm ln it lo b lp lq ju lr ls lt jx lu lv lw lx ly lz ma mb mc md me mf mg mh im bi translated">那么在钩子出现之前，我们是如何定义状态的呢？基本上，有两种选择:在组件中定义一个本地状态，或者使用状态管理框架将其设置为全局状态(例如MobX / Redux)。</p><h2 id="53b1" class="nd kv it bd kw ne nf dn la ng nh dp le lv ni nj lg lz nk nl li md nm nn lk no bi translated"><strong class="ak">本地状态(挂钩前)</strong></h2><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="np nq l"/></div></figure><p id="d59d" class="pw-post-body-paragraph lm ln it lo b lp mi ju lr ls mj jx lu lv mk lx ly lz ml mb mc md mm mf mg mh im bi translated">只有这两个选项的问题在下面的场景中得到最好的描述。假设我们的状态不一定是全局的，但是我们可能希望在多个组件中重用我们定义本地状态的方式。</p><p id="66fd" class="pw-post-body-paragraph lm ln it lo b lp mi ju lr ls mj jx lu lv mk lx ly lz ml mb mc md mm mf mg mh im bi translated">在上面的例子中，我们可能想要重用设置加载和错误状态——在钩子之前这是不可能的。我们唯一的选择是用Redux使它可重用。在Redux中，每个想要搜索用户的组件可以简单地分派一个动作(<code class="fe mn mo mp mq b">searchUsers()</code>)并监听全局状态的变化。</p><p id="ddf2" class="pw-post-body-paragraph lm ln it lo b lp mi ju lr ls mj jx lu lv mk lx ly lz ml mb mc md mm mf mg mh im bi translated">然而，使用这种全局状态(Redux/MobX)会导致一些问题:</p><ul class=""><li id="f7b7" class="nr ns it lo b lp mi ls mj lv nt lz nu md nv mh nw nx ny nz bi translated">更多样板代码</li><li id="949b" class="nr ns it lo b lp oa ls ob lv oc lz od md oe mh nw nx ny nz bi translated">复杂流动</li><li id="7bc3" class="nr ns it lo b lp oa ls ob lv oc lz od md oe mh nw nx ny nz bi translated">多个组件正在操纵全局状态，这可能会导致不必要的副作用</li></ul><h2 id="c44c" class="nd kv it bd kw ne nf dn la ng nh dp le lv ni nj lg lz nk nl li md nm nn lk no bi translated"><strong class="ak">解决方案:React Hooks！</strong></h2><p id="6a36" class="pw-post-body-paragraph lm ln it lo b lp lq ju lr ls lt jx lu lv lw lx ly lz ma mb mc md me mf mg mh im bi translated">谢天谢地，React在React 16.8中引入了hook。从那天起，在多个组件之间共享状态逻辑成为可能。</p><p id="29bd" class="pw-post-body-paragraph lm ln it lo b lp mi ju lr ls mj jx lu lv mk lx ly lz ml mb mc md mm mf mg mh im bi translated">在下面的示例中，我们现在能够共享加载和错误行为:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="np nq l"/></div></figure><p id="080d" class="pw-post-body-paragraph lm ln it lo b lp mi ju lr ls mj jx lu lv mk lx ly lz ml mb mc md mm mf mg mh im bi translated"><strong class="lo iu">好处</strong>:如果多个组件想要提供搜索用户列表的功能，我们也可以制作一个<code class="fe mn mo mp mq b">useUserSearch</code>。</p><p id="f212" class="pw-post-body-paragraph lm ln it lo b lp mi ju lr ls mj jx lu lv mk lx ly lz ml mb mc md mm mf mg mh im bi translated">然而，钩子并不是银弹。将状态保存在钩子中并不意味着它成为一个单体，状态只绑定到一个组件。在某些情况下，我们可能只想保存一个状态实例(例如，只获取一次用户信息)。这就是状态管理框架证明其价值的地方。</p></div><div class="ab cl mr ms hx mt" role="separator"><span class="mu bw bk mv mw mx"/><span class="mu bw bk mv mw mx"/><span class="mu bw bk mv mw"/></div><div class="im in io ip iq"><h1 id="dccd" class="ku kv it bd kw kx my kz la lb mz ld le jz na ka lg kc nb kd li kf nc kg lk ll bi translated">如何决定在哪里保存状态</h1><p id="1216" class="pw-post-body-paragraph lm ln it lo b lp lq ju lr ls lt jx lu lv lw lx ly lz ma mb mc md me mf mg mh im bi translated">既然可以跨组件共享状态逻辑，我们如何决定是将状态保存在组件中(本地)还是保存在状态管理框架中(全局)？</p><p id="d1ed" class="pw-post-body-paragraph lm ln it lo b lp mi ju lr ls mj jx lu lv mk lx ly lz ml mb mc md mm mf mg mh im bi translated">下面是我决策过程的一个图像。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi of"><img src="../Images/4f0504b0678509ac7d2f2c241fbd78fb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*NPIE1cX1ofWR-_46IYikYA.png"/></div></div><p class="og oh gj gh gi oi oj bd b be z dk translated">在哪里保存状态的决策过程</p></figure></div><div class="ab cl mr ms hx mt" role="separator"><span class="mu bw bk mv mw mx"/><span class="mu bw bk mv mw mx"/><span class="mu bw bk mv mw"/></div><div class="im in io ip iq"><h1 id="53fa" class="ku kv it bd kw kx my kz la lb mz ld le jz na ka lg kc nb kd li kf nc kg lk ll bi translated">状态管理框架有什么好处？</h1><p id="26de" class="pw-post-body-paragraph lm ln it lo b lp lq ju lr ls lt jx lu lv lw lx ly lz ma mb mc md me mf mg mh im bi translated">现在我们知道何时在全局状态和本地状态之间做出决定。但是为什么我们在2020年仍然使用国家管理框架呢？上面使用React钩子有什么好处？</p><p id="251a" class="pw-post-body-paragraph lm ln it lo b lp mi ju lr ls mj jx lu lv mk lx ly lz ml mb mc md mm mf mg mh im bi translated">以下是一些好处:</p><ul class=""><li id="0ab4" class="nr ns it lo b lp mi ls mj lv nt lz nu md nv mh nw nx ny nz bi translated">全局定义，这意味着只有一个数据实例</li><li id="da1e" class="nr ns it lo b lp oa ls ob lv oc lz od md oe mh nw nx ny nz bi translated">仅提取远程数据一次</li><li id="d8d4" class="nr ns it lo b lp oa ls ob lv oc lz od md oe mh nw nx ny nz bi translated">丰富的开发工具</li><li id="4e28" class="nr ns it lo b lp oa ls ob lv oc lz od md oe mh nw nx ny nz bi translated">为软件工程师提供标准化的工作方式</li></ul></div><div class="ab cl mr ms hx mt" role="separator"><span class="mu bw bk mv mw mx"/><span class="mu bw bk mv mw mx"/><span class="mu bw bk mv mw"/></div><div class="im in io ip iq"><h1 id="5792" class="ku kv it bd kw kx my kz la lb mz ld le jz na ka lg kc nb kd li kf nc kg lk ll bi translated">结论</h1><p id="61d8" class="pw-post-body-paragraph lm ln it lo b lp lq ju lr ls lt jx lu lv lw lx ly lz ma mb mc md me mf mg mh im bi translated">我们已经看到React Hooks已经动摇了整个国家管理格局。自从它们的引入，在组件之间共享状态逻辑变得更加容易了。</p><p id="1ce2" class="pw-post-body-paragraph lm ln it lo b lp mi ju lr ls mj jx lu lv mk lx ly lz ml mb mc md mm mf mg mh im bi translated">然而，钩子不是银弹，我们可能仍然需要状态管理框架。这并不意味着我们需要在全局范围内保持每个状态——大多数情况下最好保持在组件级别。只有在绝对必要的时候，才应该将状态转移到状态管理框架中。</p></div></div>    
</body>
</html>