<html>
<head>
<title>Build a Cryptocurrency Miner in Rust and Run It on Your Browser</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">在Rust中构建一个加密货币挖掘器，并在您的浏览器上运行它</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/build-a-cryptominer-in-rust-and-run-it-on-your-browser-300662204131?source=collection_archive---------5-----------------------#2022-08-10">https://betterprogramming.pub/build-a-cryptominer-in-rust-and-run-it-on-your-browser-300662204131?source=collection_archive---------5-----------------------#2022-08-10</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="defe" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">了解黑客如何利用WASM进行区块链采矿</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/89b30b75a70ee5f82cafb89a8dd41b05.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*HPuFYiDvFM9E59XF"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">阿尔伯特·希塞尼在<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</p></figure><p id="395c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我在做bug bounty的时候，一直很好奇那些没有极高流量，也没有Bug Bounty计划或者责任披露计划的网站的安全性。我经常感到失望:通过最少的测试，我通常很有可能发现安全问题，至少在应用程序的一个功能上。我还应该提到，我只是一个足够体面的猎人。我无法想象优秀的黑客能够找到什么。</p><p id="49f0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这是一个重要的互联网问题:有着不错流量的网站却没有坚实的安全保障。恶意方喜欢利用这些类型的域。最近，我看到了关于黑帽黑客<a class="ae ky" href="https://thehackernews.com/2022/07/hackers-increasingly-using-webassembly.html" rel="noopener ugc nofollow" target="_blank">利用</a>注入漏洞在网站访问者的浏览器上运行他们自己的矿工的新闻。</p><p id="4f3e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这立即引起了我的注意，所以我在这里与你的浏览器挖掘区块链动手文章。我相信这篇文章可以帮助读者了解区块链矿业基础知识，一些铁锈，以及WebAssembly的威力。</p><h1 id="a225" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">简单挖掘概述</h1><p id="12bc" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">众所周知，密码可以保护你的钱包，但如果没有一个中央实体可以确定我不能给你10 BTC，因为我没有持有它们，或者我不能在没有你签署交易的情况下从你的钱包给自己发送资产，会发生什么？</p><p id="d698" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">拥有一个分布式分类帐解决了这个问题:如果所有验证者之间达成共识，独立的计算机验证被批准的交易(这个阶段因网络而异)。在许多链中，这些人被称为矿工，因为他们有机会挖掘交易块，并在验证交易后收集交易块的奖励。</p><h1 id="1944" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">为什么是WASM</h1><p id="8385" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">也就是说，使用工作一致性算法的证明来挖掘块需要挖掘者解决数学计算，作为挖掘者已经努力验证块中的事务的证明。黑客很聪明，他们更喜欢让你在浏览器上完成繁重的工作，然后收取报酬。</p><p id="3ce2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">但是繁重的计算和Javascript并不匹配。</p><p id="a413" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">进入wasm模式，在这里你可以运行Rust、C、C++、Zig以及任何可以在大多数浏览器中编译成WASM二进制文件的语言。这加快了速度，允许浏览器端更快的计算。现在你可以明白为什么黑客选择WebAssembly来执行这些计算了。</p><h1 id="ae12" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">实现简单的挖掘机制</h1><p id="0bc3" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">现在让我们构建自己的“特洛伊”矿工。因为我们不想挖掘真正的加密，我们将构建我们自己的块表示。我们的区块表示将非常简单:</p><pre class="kj kk kl km gt ms mt mu mv aw mw bi"><span id="85cd" class="mx lw it mt b gy my mz l na nb">{<br/>  "ts": &lt;timestamp&gt;,<br/>  "nonce": &lt;nonce integer&gt;,<br/>  "prev_block_hash": &lt;hash of previous block&gt;,<br/>  "txs": &lt;set of transactions within the block&gt;<br/>}</span></pre><p id="0cef" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">为了简单起见，我们将不在本教程中介绍事务的验证，因此我们的挖掘“特洛伊木马”所要做的唯一任务就是找到正确的<code class="fe nc nd ne mt b">nonce</code>作为工作证明。如果你还记得的话，挖矿者必须执行繁重的计算，才能获得区块奖励。当谈到矿工必须解决的散列问题时，就像试图破解散列密码一样。过程如下:</p><ol class=""><li id="7ff4" class="nf ng it lb b lc ld lf lg li nh lm ni lq nj lu nk nl nm nn bi translated">我们把区块搞得一团糟</li><li id="233c" class="nf ng it lb b lc no lf np li nq lm nr lq ns lu nk nl nm nn bi translated">看看散列是否遵守我们的条件，使其有效</li><li id="ae39" class="nf ng it lb b lc no lf np li nq lm nr lq ns lu nk nl nm nn bi translated">如果是这样，挖掘任务就成功了，矿工现在可以添加一个新区块并收集区块奖励。</li><li id="a0b9" class="nf ng it lb b lc no lf np li nq lm nr lq ns lu nk nl nm nn bi translated">否则，更改<code class="fe nc nd ne mt b">nonce</code>(这是矿工可更改的唯一字段，同时仍保持块有效)，然后重试。</li></ol><p id="b50c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">例如，我们可能需要解决的一个任务是确保我们在修改<code class="fe nc nd ne mt b">nonce</code>时试图生成的散列是一个大于前一个块的散列的数字。不过，这样做的计算代价会非常高，所以我决定使用一个更简单的条件:哈希的开头和结尾必须为<code class="fe nc nd ne mt b">aa</code>，这种条件的代价要低得多，而且更适合于概念证明。</p><h2 id="a2de" class="mx lw it bd lx nt nu dn mb nv nw dp mf li nx ny mh lm nz oa mj lq ob oc ml od bi translated">设置并定义我们的区块</h2><p id="0356" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">首先，我们必须创建一个新的WASM项目。如果不知道怎么才能看懂<a class="ae ky" rel="noopener ugc nofollow" target="_blank" href="/get-started-with-wasm-in-rust-2347056bab4">这个基本的Rust+WASM介绍</a> ( <code class="fe nc nd ne mt b">cargo generate — git <a class="ae ky" href="https://github.com/rustwasm/wasm-pack-template" rel="noopener ugc nofollow" target="_blank">https://github.com/rustwasm/wasm-pack-template</a></code>)。</p><p id="1af0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">然后我们把一些配置和依赖关系放到<code class="fe nc nd ne mt b">Cargo.toml</code>文件中，在你的<code class="fe nc nd ne mt b">[dependencies]</code>下添加:</p><pre class="kj kk kl km gt ms mt mu mv aw mw bi"><span id="4603" class="mx lw it mt b gy my mz l na nb">serde_json = "1.0"<br/>serde = { version = "1.0", features = ["derive"] }<br/>rust-crypto-wasm = "0.3.0"</span></pre><p id="adec" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">并且在文件的末尾，添加web-sys和它的一些特性，以便能够修改DOM(正如<a class="ae ky" href="https://medium.com/r?url=https%3A%2F%2Fbetterprogramming.pub%2Fget-started-with-wasm-in-rust-2347056bab4" rel="noopener">在这里更好地解释</a>):</p><pre class="kj kk kl km gt ms mt mu mv aw mw bi"><span id="7fba" class="mx lw it mt b gy my mz l na nb">[dependencies.web-sys]<br/>version = "0.3.4"<br/>features = [<br/>  'Document',<br/>  'Element',<br/>  'HtmlElement',<br/>  'Node',<br/>  'Window',<br/>]</span></pre><p id="6ab4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">最后，我们定义了<code class="fe nc nd ne mt b">Block</code>和<code class="fe nc nd ne mt b">Transaction</code>结构(注意，我们使用serde的<code class="fe nc nd ne mt b">derive</code>宏为<code class="fe nc nd ne mt b">Block</code>和<code class="fe nc nd ne mt b">Transaction</code>生成<code class="fe nc nd ne mt b">Serialize</code>的实现):</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oe of l"/></div></figure><h2 id="0619" class="mx lw it bd lx nt nu dn mb nv nw dp mf li nx ny mh lm nz oa mj lq ob oc ml od bi translated">加上我们的工作条件证明</h2><p id="7b54" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">正如我前面说过的，散列有效的条件是它必须以<code class="fe nc nd ne mt b">aa</code>开始和结束。我们可以简单地用下面的函数实现它:</p><pre class="kj kk kl km gt ms mt mu mv aw mw bi"><span id="db1d" class="mx lw it mt b gy my mz l na nb">fn is_valid(hash: &amp;str, to_match: &amp;str) -&gt; bool {<br/>    hash.starts_with(to_match) &amp;&amp; hash.ends_with(to_match)<br/>}</span></pre><h2 id="daa1" class="mx lw it bd lx nt nu dn mb nv nw dp mf li nx ny mh lm nz oa mj lq ob oc ml od bi translated">实现基本块行为</h2><p id="2e9c" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">接下来，我们想为我们的<code class="fe nc nd ne mt b">Block</code>结构实现一些基本行为，比如:</p><ul class=""><li id="4508" class="nf ng it lb b lc ld lf lg li nh lm ni lq nj lu og nl nm nn bi translated">返回链的第一个块(或起源块)—第13–26行。</li><li id="61e7" class="nf ng it lb b lc no lf np li nq lm nr lq ns lu og nl nm nn bi translated">创建新块—第4–11行</li><li id="3942" class="nf ng it lb b lc no lf np li nq lm nr lq ns lu og nl nm nn bi translated"><a class="ae ky" rel="noopener ugc nofollow" target="_blank" href="/how-to-work-with-json-in-rust-35ddc964009e">将块序列化为JSON </a> —第28–30行</li><li id="55a9" class="nf ng it lb b lc no lf np li nq lm nr lq ns lu og nl nm nn bi translated">散列块—第32–36行。注意，这里我们使用的是从<code class="fe nc nd ne mt b">rust-crypto-wasm</code>依赖项导入的<code class="fe nc nd ne mt b">Sha256</code>散列函数。</li><li id="ca70" class="nf ng it lb b lc no lf np li nq lm nr lq ns lu og nl nm nn bi translated">开采区块—第38–42行。一个非常简单的while循环(虽然不是很有效，但是对于这样一个简单的数学任务来说非常合适),它只是改变块的<code class="fe nc nd ne mt b">nonce</code>,直到散列被验证(还记得我们在“添加我们的工作条件证明”一节中定义的<code class="fe nc nd ne mt b">is_valid</code>函数)。</li></ul><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oe of l"/></div></figure><h2 id="8772" class="mx lw it bd lx nt nu dn mb nv nw dp mf li nx ny mh lm nz oa mj lq ob oc ml od bi translated">其他一些帮助者</h2><p id="c0dc" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">我们的采矿机制现在都准备好了。为了完整性和修改DOM，我们只需要几个额外的帮助函数。代码如下:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oe of l"/></div></figure><p id="7c00" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们有三个新的函数:前两个，正如评论中所描述的，只是为了完整和展示如何在真实的链上实现这个挖掘器(你也应该实现链的块结构和解决区块链需要的数学难题)。另一方面，<code class="fe nc nd ne mt b">add_heading_block</code>函数将只在主体中添加一个标题，其中包含正确的nonce和相应的事务哈希。</p><h1 id="900d" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">主要功能</h1><p id="482d" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">最后，我们将所有这些打包成一个可以从JS调用的函数:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oe of l"/></div></figure><p id="e5bb" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们只是找到两个后续块的有效nonce，并在找到它们时将它们添加到页面主体中。</p><h1 id="24d1" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">将它们包装在一起并进行测试</h1><p id="7866" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated"><a class="ae ky" href="https://gist.github.com/heytdep/e270cdddc7f960a3ac2e7ad4eef21f49" rel="noopener ugc nofollow" target="_blank">这个</a>是我们剩下的<code class="fe nc nd ne mt b">lib.rs</code>文件。我还想你会想看看我们在过去几分钟里所做的工作的结果，所以我将快速地引导你编译到WASM，并在一个网页上从JS调用<code class="fe nc nd ne mt b">rust_mine</code>函数:</p><ol class=""><li id="b2aa" class="nf ng it lb b lc ld lf lg li nh lm ni lq nj lu nk nl nm nn bi translated">用wasm-pack编译到WASM用于浏览器:<code class="fe nc nd ne mt b">wasm-pack build --target web</code>。</li><li id="0278" class="nf ng it lb b lc no lf np li nq lm nr lq ns lu nk nl nm nn bi translated">在板条箱的根目录下创建和<code class="fe nc nd ne mt b">index.html</code>文件，如下所示:</li></ol><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oe of l"/></div></figure><p id="7f40" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">3.服<code class="fe nc nd ne mt b">index.html</code>文件，比如我用<code class="fe nc nd ne mt b">snowpack dev</code>。</p><p id="90c1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这是你应该在浏览器上看到的，两个新解决的哈希难题:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi oh"><img src="../Images/3a537aa9a7ca1e8417ced392b014a787.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*rO04QTHz-eqwEkWITj3g4w.png"/></div></div></figure><h1 id="a8c8" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">黑客部分</h1><p id="16f7" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">这篇文章源于作者的好奇心，想探索黑客如何利用WebAssembly从日常web访问者的浏览器中挖掘密码。虽然我不知道他们的矿工长什么样，但这是使用我们构建的矿工在我们部分实现的虚拟区块链上采矿的工作流程:</p><ol class=""><li id="38f6" class="nf ng it lb b lc ld lf lg li nh lm ni lq nj lu nk nl nm nn bi translated">在网站上找到一个注入漏洞，比如一个存储的跨站点脚本漏洞，在页面上加载我们的<code class="fe nc nd ne mt b">wasm_miner.js</code>文件。</li><li id="1119" class="nf ng it lb b lc no lf np li nq lm nr lq ns lu nk nl nm nn bi translated">随着计算和进程通过Websocket消息或fetch调用将我们为块找到的<code class="fe nc nd ne mt b">nonce</code>发送回服务器。</li><li id="c66b" class="nf ng it lb b lc no lf np li nq lm nr lq ns lu nk nl nm nn bi translated">服务器现在应该会收到挖掘新区块所需的数据，并获得区块奖励。</li></ol></div><div class="ab cl oi oj hx ok" role="separator"><span class="ol bw bk om on oo"/><span class="ol bw bk om on oo"/><span class="ol bw bk om on"/></div><div class="im in io ip iq"><p id="79b5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">根据我们希望矿工工作的链，有无尽的定制要做。本文的目的是通过Rust实践教程让您更熟悉加密挖掘的概念。此外，有趣的是，WebAssembly在网络安全领域也能发挥作用。</p><p id="e37b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><em class="op">感谢阅读！</em></p></div></div>    
</body>
</html>