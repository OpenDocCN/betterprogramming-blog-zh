<html>
<head>
<title>Cloud-Native Event Streaming With Pravega</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用Pravega的云原生事件流</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/cloud-native-event-streaming-with-pravega-f353cb010c64?source=collection_archive---------4-----------------------#2022-11-27">https://betterprogramming.pub/cloud-native-event-streaming-with-pravega-f353cb010c64?source=collection_archive---------4-----------------------#2022-11-27</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="4b62" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">构建高效的流媒体系统</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/4021b5b9e13589f6a89638949a2ad909.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*rA--N19EwqXKDDR1fbs67Q.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">作者图片| Python和Pravega的徽标</p></figure><p id="bd3b" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">所以，最近我利用网络套接字建立了一个有趣的小FastAPI聊天室，我很喜欢它。然而，我想到了web sockets，以及在过去几年中有多少研究进入了流媒体服务。web套接字仍然是未来的发展方向吗？如果没有，有什么新的工具可以帮助促进这一过程？</p><p id="4840" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">我以前用过卡夫卡，对RabitMQ也隐约熟悉，但还有什么呢？！</p><p id="2b21" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">所以，我去了CNCF沙盒，看看我是否能找到新的东西来玩。一些存储，一个简单的接口，并希望一些python绑定，我可以相对容易地挂钩。我在CNCF的沙盒中发现了两个非常诱人的流媒体服务，似乎符合这个要求:</p><ul class=""><li id="9e27" class="lr ls iq kx b ky kz lb lc le lt li lu lm lv lq lw lx ly lz bi translated"><a class="ae ma" href="https://www.cncf.io/projects/pravega/" rel="noopener ugc nofollow" target="_blank">普拉威加</a></li><li id="8bdd" class="lr ls iq kx b ky mb lb mc le md li me lm mf lq lw lx ly lz bi translated"><a class="ae ma" href="https://www.cncf.io/projects/tremor/" rel="noopener ugc nofollow" target="_blank">震颤</a></li></ul><p id="03ef" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">我之所以选择Pravega，是因为它非常容易启动和运行，具有独立和分布式模式，看起来非常高效，并且具有自动伸缩功能(我是SRE，非常喜欢自动伸缩)。还有很多其他的好特性，我鼓励你去看看。</p><p id="2aa0" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">那么，为什么是聊天室？嗯，只要我发送一条消息，用户就应该被提醒这条消息，然后有能力作出回应。这听起来像是基于事件或流系统的完美用例！那么，我们开始吧。</p><h1 id="2766" class="mg mh iq bd mi mj mk ml mm mn mo mp mq jw mr jx ms jz mt ka mu kc mv kd mw mx bi translated">普拉维加</h1><p id="7427" class="pw-post-body-paragraph kv kw iq kx b ky my jr la lb mz ju ld le na lg lh li nb lk ll lm nc lo lp lq ij bi translated">什么是Pravega？Pravega是一个开源的流和存储实用程序，承诺无与伦比的性能、长期存储和自动伸缩。这听起来是不是很适合聊天室？</p><p id="1a47" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">在我们的聊天室中，我们将使用它来代替基本套接字、网络套接字或其他流行的聊天室媒介。</p><h1 id="79be" class="mg mh iq bd mi mj mk ml mm mn mo mp mq jw mr jx ms jz mt ka mu kc mv kd mw mx bi translated">运行Pravega</h1><p id="a9c5" class="pw-post-body-paragraph kv kw iq kx b ky my jr la lb mz ju ld le na lg lh li nb lk ll lm nc lo lp lq ij bi translated">运行Pravega有多种方式，但我只是将它作为一个独立的容器来运行。配置Pravega也有很多方法，比如出于可靠性的目的，将单独的部分分布在不同的容器中(这是我在生产系统中推荐的)。但是，为了方便起见，我们将在独立模式下运行它:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nd ne l"/></div></figure><p id="d645" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">就是这样。现在您将看到Pravega在终端中运行，准备接受连接！</p><h1 id="e329" class="mg mh iq bd mi mj mk ml mm mn mo mp mq jw mr jx ms jz mt ka mu kc mv kd mw mx bi translated">StreamCli</h1><p id="1e05" class="pw-post-body-paragraph kv kw iq kx b ky my jr la lb mz ju ld le na lg lh li nb lk ll lm nc lo lp lq ij bi translated">我们将把我们的Python应用程序称为StreamCli。这将是一个易于运行的CLI，它以读写能力连接到一个Pravega代理。Slack还启发我加入了一些“斜杠命令”,以帮助我们最大限度地减少常见任务(问候、笑话等)的输入。).</p><p id="63fc" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">要实现这一切，我们需要以下条件:</p><ul class=""><li id="31d6" class="lr ls iq kx b ky kz lb lc le lt li lu lm lv lq lw lx ly lz bi translated">从Pravega流中读取并对消息进行操作的内容</li><li id="bd7c" class="lr ls iq kx b ky mb lb mc le md li me lm mf lq lw lx ly lz bi translated">接收用户输入并将其写入Pravega流的东西</li><li id="bc2f" class="lr ls iq kx b ky mb lb mc le md li me lm mf lq lw lx ly lz bi translated">管理读者和作者的东西</li></ul><p id="4780" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">这听起来很多，但我保证这很快，很容易，只有200行代码。</p><h1 id="35ae" class="mg mh iq bd mi mj mk ml mm mn mo mp mq jw mr jx ms jz mt ka mu kc mv kd mw mx bi translated">读者</h1><p id="ab10" class="pw-post-body-paragraph kv kw iq kx b ky my jr la lb mz ju ld le na lg lh li nb lk ll lm nc lo lp lq ij bi translated">让我们从读者开始，因为它是最复杂的。过了这一关，就全走下坡路了。在实际发送消息之前，我们应该就消息的格式达成一致。这样，无论发送什么，都可以在流的接收端得到正确的处理。为此，我们可以使用pydantic模型:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nd ne l"/></div></figure><p id="43f3" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">这定义了一个python对象，它有两个字符串属性:</p><ul class=""><li id="c0f6" class="lr ls iq kx b ky kz lb lc le lt li lu lm lv lq lw lx ly lz bi translated">发送者:发送用户的ID</li><li id="c2c1" class="lr ls iq kx b ky mb lb mc le md li me lm mf lq lw lx ly lz bi translated">消息:消息的内容</li></ul><p id="0d6e" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">Pydantic模型有大量的助手与之相关联，例如:</p><ul class=""><li id="5d46" class="lr ls iq kx b ky kz lb lc le lt li lu lm lv lq lw lx ly lz bi translated">JSON函数</li><li id="40dd" class="lr ls iq kx b ky mb lb mc le md li me lm mf lq lw lx ly lz bi translated">解析函数</li><li id="bb80" class="lr ls iq kx b ky mb lb mc le md li me lm mf lq lw lx ly lz bi translated">更加</li></ul><p id="e2e4" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">既然我们已经就消息格式达成一致，我们可以开始编写我们的阅读器了。我们的读者将需要两个属性:</p><ul class=""><li id="a0e9" class="lr ls iq kx b ky kz lb lc le lt li lu lm lv lq lw lx ly lz bi translated">一个ID，这样它就知道它是为谁接收的</li><li id="0e0e" class="lr ls iq kx b ky mb lb mc le md li me lm mf lq lw lx ly lz bi translated">Pravega读取器实例，以便它可以附加到流</li></ul><p id="9123" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">它的定义和初始化很简单。代码如下:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nd ne l"/></div></figure><p id="e532" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">从逻辑上讲，我们需要一种方法来:</p><ul class=""><li id="165c" class="lr ls iq kx b ky kz lb lc le lt li lu lm lv lq lw lx ly lz bi translated">从溪流中阅读</li><li id="0d26" class="lr ls iq kx b ky mb lb mc le md li me lm mf lq lw lx ly lz bi translated">根据信息采取行动</li><li id="135a" class="lr ls iq kx b ky mb lb mc le md li me lm mf lq lw lx ly lz bi translated">当它完成监听时告诉流(关闭连接)</li></ul><p id="bdda" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">我们可以通过使用Pravega实例从流中读取。Pravega将消息组织成称为<code class="fe nf ng nh ni b">slices</code>的东西。切片是段的一部分，段是流的碎片或片段。一旦我们从段中读取了那个片，我们需要通知Pravega它已经被处理了，不应该被同一个读取组再次处理。最后，我们需要处理这个切片，做一些可操作的事情。因此，在代码中，我们的<code class="fe nf ng nh ni b">read</code>函数看起来像这样:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nd ne l"/></div></figure><p id="3c4c" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">注意，我们首先使用<code class="fe nf ng nh ni b">get_segment_slice_async</code>从片段中读取一个片段。一旦我们从该段中读取了所有数据，我们就让Pravega知道这个读者组已经处理了消息，并且不需要这个读者组用<code class="fe nf ng nh ni b">release_segment</code>再次处理。最后，我们用<code class="fe nf ng nh ni b">_process_message</code>处理消息(稍后会有更多介绍)。</p><p id="da48" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">既然我们已经阅读了一条信息，我们需要用它做一些可操作的事情。这就是<code class="fe nf ng nh ni b">_process_message</code>发挥作用的地方。从逻辑上讲，我们的<code class="fe nf ng nh ni b">_process_message</code>函数必须:</p><ul class=""><li id="0ba7" class="lr ls iq kx b ky kz lb lc le lt li lu lm lv lq lw lx ly lz bi translated">将消息从其格式解析为我们的消息格式</li><li id="2e54" class="lr ls iq kx b ky mb lb mc le md li me lm mf lq lw lx ly lz bi translated">以某种方式处理它</li><li id="58f2" class="lr ls iq kx b ky mb lb mc le md li me lm mf lq lw lx ly lz bi translated">将它显示给接收用户</li></ul><p id="995f" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">值得注意的是，我想在我的聊天系统中添加两个特殊的命令:</p><ul class=""><li id="2794" class="lr ls iq kx b ky kz lb lc le lt li lu lm lv lq lw lx ly lz bi translated">关键字<code class="fe nf ng nh ni b">greet</code>应该通过说<code class="fe nf ng nh ni b">&lt;Sending User&gt; says hi!</code>来问候用户。</li><li id="62ed" class="lr ls iq kx b ky mb lb mc le md li me lm mf lq lw lx ly lz bi translated">关键字<code class="fe nf ng nh ni b">joke</code>应该告诉接收用户一个随机的笑话</li></ul><p id="8c82" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">所以我们的<code class="fe nf ng nh ni b">_process_message</code>函数变成如下:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nd ne l"/></div></figure><p id="e2f6" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">注意我们是如何首先从JSON格式加载消息的。它将作为(下面讨论的)我们想要的消息格式发送。接下来，因为我们正在读和写一个流，我们想确保我们不是写给自己。最后，我们利用所需的格式处理消息，并将其返回给调用者。为了完整起见，<code class="fe nf ng nh ni b">_tell_joke</code>和<code class="fe nf ng nh ni b">_greet</code>功能如下所示:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nd ne l"/></div></figure><p id="c658" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">最后，我们需要一个close方法来告诉Pravega，“这个侦听器完成了，将从聊天室中删除！”：</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nd ne l"/></div></figure><p id="47f4" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">就是这样！我们现在有了一个对象，它可以从流中读取数据，并根据从流中接收到的消息执行半智能操作。</p><h1 id="fd34" class="mg mh iq bd mi mj mk ml mm mn mo mp mq jw mr jx ms jz mt ka mu kc mv kd mw mx bi translated">作者</h1><p id="1dc6" class="pw-post-body-paragraph kv kw iq kx b ky my jr la lb mz ju ld le na lg lh li nb lk ll lm nc lo lp lq ij bi translated">作者比读者简单得多。它需要两条信息:</p><ul class=""><li id="532b" class="lr ls iq kx b ky kz lb lc le lt li lu lm lv lq lw lx ly lz bi translated">它的ID</li><li id="b889" class="lr ls iq kx b ky mb lb mc le md li me lm mf lq lw lx ly lz bi translated">Pravega编写器实例</li></ul><p id="3792" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">它的定义和初始化如下:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nd ne l"/></div></figure><p id="c02b" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">它只需要一两种方法:</p><ul class=""><li id="8f54" class="lr ls iq kx b ky kz lb lc le lt li lu lm lv lq lw lx ly lz bi translated">一个用来框定信息</li><li id="61a0" class="lr ls iq kx b ky mb lb mc le md li me lm mf lq lw lx ly lz bi translated">一个发送消息</li></ul><p id="ca1f" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">让我们来看看如何构建信息。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nd ne l"/></div></figure><p id="77dc" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">因此，看看这个，我们创建一个pydantic模型(称为<code class="fe nf ng nh ni b">Message</code>)并输入所需的信息。最后，我们将其作为JSON字符串返回，通过流发送。作为旁注，在讨论阅读器时，我们简要地看了一下<code class="fe nf ng nh ni b">Message</code> pydantic模型。</p><p id="0d9c" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">最后，我们可以发送消息。看起来是这样的:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nd ne l"/></div></figure><p id="302a" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">我们看到，我们构造消息，然后通过Pravega writer实例发送出去。</p><h1 id="2cba" class="mg mh iq bd mi mj mk ml mm mn mo mp mq jw mr jx ms jz mt ka mu kc mv kd mw mx bi translated">潺潺流水声</h1><p id="6643" class="pw-post-body-paragraph kv kw iq kx b ky my jr la lb mz ju ld le na lg lh li nb lk ll lm nc lo lp lq ij bi translated">所以，我们有我们的读者，我们有我们的作者。为了聊天，我们需要将两者结合成一个干净的对象。我们将称该对象为我们的<code class="fe nf ng nh ni b">Chatter</code>(参见下面的定义和初始化):</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nd ne l"/></div></figure><p id="e9e6" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">我们的chatter对象将维护它的读者和作者，并通知他们使用<code class="fe nf ng nh ni b">running</code>属性关闭(稍后将详细介绍)。</p><p id="ad7c" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">从概念上讲，我们的chatter将需要与其成员相同的功能。即:</p><ul class=""><li id="a667" class="lr ls iq kx b ky kz lb lc le lt li lu lm lv lq lw lx ly lz bi translated">一个read函数来告诉读者做它该做的事情</li><li id="08d6" class="lr ls iq kx b ky mb lb mc le md li me lm mf lq lw lx ly lz bi translated">一个写函数，告诉作者做它的事情</li><li id="0bf2" class="lr ls iq kx b ky mb lb mc le md li me lm mf lq lw lx ly lz bi translated">优雅地终止其片段的close函数</li></ul><p id="4d58" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">我们也不想要一个阻塞系统(在写之前强制读)，所以我们将为读者和作者使用不同的线程。</p><p id="bb40" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">chatter对象中的read函数比reader对象中的函数简单得多，因为它所要做的就是等待<code class="fe nf ng nh ni b">reader.read</code>方法返回、格式化并打印出来:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nd ne l"/></div></figure><p id="2b05" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">您会注意到，当我们完成运行时(<code class="fe nf ng nh ni b">self.running</code>为假)，我们将自动关闭我们的阅读器。</p><p id="175d" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">在这个意义上,<code class="fe nf ng nh ni b">write</code>方法是相似的。它只需要接受用户输入并将其发送给编写器。看起来是这样的:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nd ne l"/></div></figure><p id="ef1a" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">然后，我们的close方法只需终止这些循环，读取器将被优雅地关闭:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nd ne l"/></div></figure><p id="f6ac" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">我们可以用线程将所有这些部分捆绑成一个漂亮的并发包:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nd ne l"/></div></figure><p id="2625" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">如果我们对此进行进一步分析，我们可以做到以下几点:</p><ul class=""><li id="5a1f" class="lr ls iq kx b ky kz lb lc le lt li lu lm lv lq lw lx ly lz bi translated">创建一个读者线程。因为read是一个异步函数(所以它不会阻塞)，我们需要用<code class="fe nf ng nh ni b">asyncio</code>包装我们的目标。该线程将运行异步回调。</li><li id="43b4" class="lr ls iq kx b ky mb lb mc le md li me lm mf lq lw lx ly lz bi translated">创建编写器线程。编写不是异步的，因为我们必须等待用户输入。所以我们可以在这里使用典型的线程目标。</li><li id="1a2d" class="lr ls iq kx b ky mb lb mc le md li me lm mf lq lw lx ly lz bi translated">开始我们的线程！</li></ul><h1 id="334b" class="mg mh iq bd mi mj mk ml mm mn mo mp mq jw mr jx ms jz mt ka mu kc mv kd mw mx bi translated">把这一切联系在一起</h1><p id="c210" class="pw-post-body-paragraph kv kw iq kx b ky my jr la lb mz ju ld le na lg lh li nb lk ll lm nc lo lp lq ij bi translated">最后，我们将它们结合在一起，打包成一个CLI。有很多很棒的Python参数解析工具。这里有三个很棒的:</p><ul class=""><li id="0762" class="lr ls iq kx b ky kz lb lc le lt li lu lm lv lq lw lx ly lz bi translated"><a class="ae ma" href="https://docs.python.org/3/library/argparse.html" rel="noopener ugc nofollow" target="_blank"> argparse </a></li><li id="32a7" class="lr ls iq kx b ky mb lb mc le md li me lm mf lq lw lx ly lz bi translated"><a class="ae ma" href="https://click.palletsprojects.com/en/8.1.x/" rel="noopener ugc nofollow" target="_blank">点击</a></li><li id="4a99" class="lr ls iq kx b ky mb lb mc le md li me lm mf lq lw lx ly lz bi translated"><a class="ae ma" href="http://docopt.org/" rel="noopener ugc nofollow" target="_blank"> docopt </a></li></ul><p id="5629" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">今天我选择了<code class="fe nf ng nh ni b">docopt</code>,因为它易于使用，并且减轻了程序员的负担。<code class="fe nf ng nh ni b">docopt</code>将解析我们的文档字符串，然后基于它生成参数。我们的docstring看起来像这样:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nd ne l"/></div></figure><p id="e77e" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">因此<code class="fe nf ng nh ni b">docopt</code>将解析它，创建一个可能参数的字典，然后我们可以相应地对它们进行操作。</p><p id="fe15" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">我们的主要功能就是这样做的。<code class="fe nf ng nh ni b">Main</code>将:</p><ul class=""><li id="bd23" class="lr ls iq kx b ky kz lb lc le lt li lu lm lv lq lw lx ly lz bi translated">解析我们的docstring并分析用户提供的参数</li><li id="b06b" class="lr ls iq kx b ky mb lb mc le md li me lm mf lq lw lx ly lz bi translated">创建一个Pravega流管理器、作用域、流、读取器和写入器</li><li id="b99b" class="lr ls iq kx b ky mb lb mc le md li me lm mf lq lw lx ly lz bi translated">创建我们的读者和作者包装</li><li id="b1ac" class="lr ls iq kx b ky mb lb mc le md li me lm mf lq lw lx ly lz bi translated">创建我们的聊天</li><li id="a9cc" class="lr ls iq kx b ky mb lb mc le md li me lm mf lq lw lx ly lz bi translated">开始聊天</li></ul><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nd ne l"/></div></figure><p id="8943" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">重要的部分是Pravega API调用。我们首先创建一个<code class="fe nf ng nh ni b">StreamManager</code>，它允许我们为Pravega集群运行一些管理任务。然后，我们创建或使用一个类似于名称空间的作用域。然后，我们在该范围内创建一个流，并在该流和范围内创建一个读者组。每个用户都有自己的读者群，这意味着当<code class="fe nf ng nh ni b">userA</code>从流中读取时，<code class="fe nf ng nh ni b">userB</code>和<code class="fe nf ng nh ni b">userC</code>不会受到影响。最后，我们创建单独的读取器和写入器，以便能够显式地从流中读取和写入。</p><h1 id="a3bd" class="mg mh iq bd mi mj mk ml mm mn mo mp mq jw mr jx ms jz mt ka mu kc mv kd mw mx bi translated">运转</h1><p id="413d" class="pw-post-body-paragraph kv kw iq kx b ky my jr la lb mz ju ld le na lg lh li nb lk ll lm nc lo lp lq ij bi translated">我们现在准备运行！</p><p id="e396" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">在一个终端中，确保您的Pravega docker映像正在运行！如果没有，您可以运行以下命令:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nd ne l"/></div></figure><p id="a183" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">现在，打开另外两个终端。其中一个运行<code class="fe nf ng nh ni b">python streamcli.py tcp://127.0.0.1:9090 alex</code>，另一个运行<code class="fe nf ng nh ni b">python streamcli.py tcp://127.0.0.1:9090 tim</code>，开始来回聊天！</p><p id="2c39" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">看下面的视频！</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nj"><img src="../Images/8f4127a11c1815aa3a4304bab947173d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*bdcB689nTWsYuFk9.gif"/></div></div></figure><h1 id="293d" class="mg mh iq bd mi mj mk ml mm mn mo mp mq jw mr jx ms jz mt ka mu kc mv kd mw mx bi translated">参考</h1><p id="06b5" class="pw-post-body-paragraph kv kw iq kx b ky my jr la lb mz ju ld le na lg lh li nb lk ll lm nc lo lp lq ij bi translated">所有代码都可以在我的公开回购中找到，链接<a class="ae ma" href="https://github.com/afoley587/cloud-native-streaming" rel="noopener ugc nofollow" target="_blank">https://github.com/afoley587/cloud-native-streaming</a>。</p></div></div>    
</body>
</html>