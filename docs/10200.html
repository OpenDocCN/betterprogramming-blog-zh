<html>
<head>
<title>Android JobScheduler — What’s Inside? Exploring the Internals</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Android job scheduler——里面有什么？探索内部</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/android-jobscheduler-whats-inside-exploring-the-internals-51d301059d55?source=collection_archive---------0-----------------------#2021-12-12">https://betterprogramming.pub/android-jobscheduler-whats-inside-exploring-the-internals-51d301059d55?source=collection_archive---------0-----------------------#2021-12-12</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="66c7" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">了解JobSchedulers如何在幕后工作。在本文中，我们将探讨android作业调度器是如何在内部实现的？他们是如何做到所有的魔法，甚至更多？如果这些是你正在问自己的问题，那么恭喜你，你的寻找今天结束了！但是做好准备，这将是一个漫长的旅程。</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/6f5696181b045a7d470093a424cf8317.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*fYbH2MPifzz0nd7a428kdg.jpeg"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated"><a class="ae kv" href="https://unsplash.com/@hansonluu?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Hanson Lu </a>在<a class="ae kv" href="https://unsplash.com/s/photos/internal?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的照片</p></figure><p id="5b38" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">所以在我们开始之前，我想提醒一下，对于至少使用过一次JobSchedulers并且熟悉它所提供的API的人来说，这篇文章是有用的。</p><p id="9e0f" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">如果你是新手，那么我强烈建议你看一看我不久前写的作业调度入门。</p><div class="ls lt gp gr lu lv"><a href="https://medium.com/@kiitvishal89/android-jobscheduler-schedule-your-jobs-like-a-master-cfa0d80e5f10" rel="noopener follow" target="_blank"><div class="lw ab fo"><div class="lx ab ly cl cj lz"><h2 class="bd ir gy z fp ma fr fs mb fu fw ip bi translated">Android JobScheduler —像主人一样安排您的作业！</h2><div class="mc l"><h3 class="bd b gy z fp ma fr fs mb fu fw dk translated">在作业调度器出现之前，每当我遇到想做一些后台处理的用例时，我必须…</h3></div><div class="md l"><p class="bd b dl z fp ma fr fs mb fu fw dk translated">medium.com</p></div></div><div class="me l"><div class="mf l mg mh mi me mj kp lv"/></div></div></a></div><p id="eeb7" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">因此，我将组织这篇文章的方式是这样的，我将首先解释作业调度程序的所有重要组件，一旦我们理解了所有组件以及它们的作用，然后我们将尝试构建其功能的整体图。</p><p id="d389" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在我解释的同时，我也将发布框架中的代码，并提供有限的细节以便于理解。事不宜迟，我们开始吧。</p><h1 id="89e9" class="mk ml iq bd mm mn mo mp mq mr ms mt mu jw mv jx mw jz mx ka my kc mz kd na nb bi translated">JobScheduler的关键组件</h1><ol class=""><li id="1df7" class="nc nd iq ky b kz ne lc nf lf ng lj nh ln ni lr nj nk nl nm bi translated"><code class="fe nn no np nq b">JobSchedulerService</code></li><li id="e9f2" class="nc nd iq ky b kz nr lc ns lf nt lj nu ln nv lr nj nk nl nm bi translated"><code class="fe nn no np nq b">JobStatus</code></li><li id="8ead" class="nc nd iq ky b kz nr lc ns lf nt lj nu ln nv lr nj nk nl nm bi translated"><code class="fe nn no np nq b">JobStore</code>和<code class="fe nn no np nq b">JobSet</code></li><li id="e08d" class="nc nd iq ky b kz nr lc ns lf nt lj nu ln nv lr nj nk nl nm bi translated"><code class="fe nn no np nq b">Controllers</code>和<code class="fe nn no np nq b">StatusChangedListeners</code></li><li id="3414" class="nc nd iq ky b kz nr lc ns lf nt lj nu ln nv lr nj nk nl nm bi translated"><code class="fe nn no np nq b">JobServiceContext</code></li><li id="5ce8" class="nc nd iq ky b kz nr lc ns lf nt lj nu ln nv lr nj nk nl nm bi translated"><code class="fe nn no np nq b">JobConcurrencyManager</code></li><li id="2c18" class="nc nd iq ky b kz nr lc ns lf nt lj nu ln nv lr nj nk nl nm bi translated">工作<code class="fe nn no np nq b">Restriction</code></li></ol><h1 id="c9be" class="mk ml iq bd mm mn mo mp mq mr ms mt mu jw mv jx mw jz mx ka my kc mz kd na nb bi translated">JobSchedulerService</h1><p id="d69d" class="pw-post-body-paragraph kw kx iq ky b kz ne jr lb lc nf ju le lf nw lh li lj nx ll lm ln ny lp lq lr ij bi translated">当您调用<code class="fe nn no np nq b">getSystemService(Context.JobSchedulerService)</code> <em class="nz">时，这是JobScheduler API与之交互的facade。</em></p><p id="d149" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">提到的所有其他组件都是这个类的助手。这是一项系统服务，在系统启动时启动。您在JobService实现中收到的所有回调都是从该类中触发的。</p><p id="99bf" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">通俗地说，我们可以说这是主编排器，它负责发送命令来启动准备执行的作业，或者当系统状态改变时，这个类触发作业的执行。我们将在最后一节处理关于这个类的更多细节，因为我们需要先理解其他组件才能正确地理解它。</p><h1 id="11a3" class="mk ml iq bd mm mn mo mp mq mr ms mt mu jw mv jx mw jz mx ka my kc mz kd na nb bi translated">作业状态</h1><p id="923f" class="pw-post-body-paragraph kw kx iq ky b kz ne jr lb lc nf ju le lf nw lh li lj nx ll lm ln ny lp lq lr ij bi translated">这是你工作的内在表现。作为一个用户，我们创建一个<code class="fe nn no np nq b">JobInfo</code>对象，包含关于我们工作的重要信息，例如，需要运行的组件(<code class="fe nn no np nq b">JobService</code>实现)、工作的约束、周期细节等。</p><p id="95f8" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">当我们使用<code class="fe nn no np nq b">schedule()</code> <em class="nz"> </em> API将<code class="fe nn no np nq b">JobInfo</code>提交给框架时，所有的信息都被消化了，一个新的<code class="fe nn no np nq b">JobStatus</code>对象被创建，它有更多关于作业的细节，所有的内部类彼此共享这个类。他们不知道工作信息。</p><p id="12f6" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><code class="fe nn no np nq b">JobStatus</code>有两个内部列表，一个叫做待定列表，另一个叫做执行列表。</p><p id="dc9b" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们知道，我们可以使用<code class="fe nn no np nq b">enqueue()</code>将多个<code class="fe nn no np nq b">JobWorkItems</code>添加到作业信息中，并使用<code class="fe nn no np nq b">param.dequeue()</code>提取作业服务中的作业工作项。因此，简单地说，每当使用<code class="fe nn no np nq b">enqueue()</code>添加一个工作时，它就被添加到待定列表中，每当它出队时，它就从待定列表中移除并被添加到执行列表中。一旦使用<code class="fe nn no np nq b">JobParameter.completeWork(JobWorkItem)</code> API将工作标记为完成，该项也将从执行列表中删除。</p><h2 id="8366" class="oa ml iq bd mm ob oc dn mq od oe dp mu lf of og mw lj oh oi my ln oj ok na ol bi translated"><strong class="ak">入队</strong></h2><pre class="kg kh ki kj gt om nq on oo aw op bi"><span id="4e30" class="oa ml iq nq b gy oq or l os ot">public void enqueueWorkLocked(IActivityManager am, JobWorkItem work) {<br/>    if (pendingWork == null) {<br/>        pendingWork = new ArrayList&lt;&gt;();<br/>    }<br/>    work.setWorkId(nextPendingWorkId);<br/>    nextPendingWorkId++;<br/>    // .. some framework code stripped.<br/>    pendingWork.add(work);<br/>}</span></pre><h2 id="a1ce" class="oa ml iq bd mm ob oc dn mq od oe dp mu lf of og mw lj oh oi my ln oj ok na ol bi translated"><strong class="ak">出列</strong></h2><pre class="kg kh ki kj gt om nq on oo aw op bi"><span id="ba96" class="oa ml iq nq b gy oq or l os ot">public JobWorkItem dequeueWorkLocked() {<br/>    if (pendingWork != null &amp;&amp; pendingWork.size() &gt; 0) {<br/>        JobWorkItem work = pendingWork.remove(0);<br/>        if (work != null) {<br/>            if (executingWork == null) {<br/>                executingWork = new ArrayList&lt;&gt;();<br/>            }<br/>            executingWork.add(work);<br/>        }<br/>        return work;<br/>    }<br/>    return null;<br/>}</span></pre><p id="b12f" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">该组件还负责作业传输，如中所示，当调度了一个作业并且已经有一个作业使用相同的ID运行时，那么旧作业中的工作项必须复制到新作业中，并且旧作业被取消。</p><p id="b27d" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">旧作业的所有正在执行的工作被转移到传入作业的未决作业，并且未决工作被原样复制。参见下面的代码:</p><pre class="kg kh ki kj gt om nq on oo aw op bi"><span id="0761" class="oa ml iq nq b gy oq or l os ot">public void stopTrackingJobLocked(IActivityManager am, JobStatus incomingJob) {<br/>    if (incomingJob != null) {<br/>        <em class="nz">// We are replacing with a new job -- transfer the work!  We do any executing<br/>        // work first, since that was originally at the front of the pending work.<br/>       </em><strong class="nq ir"><em class="nz"> </em>if (executingWork != null &amp;&amp; executingWork.size() &gt; 0) {<br/>            incomingJob.pendingWork = executingWork;<br/>        }<br/>        if (incomingJob.pendingWork == null) {<br/>            incomingJob.pendingWork = pendingWork;<br/>        } else if (pendingWork != null &amp;&amp; pendingWork.size() &gt; 0) {<br/>            incomingJob.pendingWork.addAll(pendingWork);<br/>        }</strong><br/>        pendingWork = null;<br/>        executingWork = null;<br/>        incomingJob.nextPendingWorkId = nextPendingWorkId;<br/>        incomingJob.updateEstimatedNetworkBytesLocked();<br/>    } else {<br/>        <em class="nz">// We are completely stopping the job...  need to clean up work.<br/>       </em><br/>        pendingWork = null;<br/>        executingWork = null;<br/>    }<br/>   <br/>}</span></pre><p id="f7aa" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">简单不是吗。</p><p id="578b" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">让我们试着理解这堂课的下一组责任。每个作业都有一组特定的运行约束条件，例如只有连接电池时才运行、只有网络处于活动状态时才运行、如果网络不符合给定的标准则不运行，或者只有在存储容量不低时才运行，等等。因此，每当系统状态改变时，这个对象就用相关约束的当前状态进行更新。我们将讨论它如何在即将到来的组件中得到更新。</p><p id="8158" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">它使用一个位屏蔽整数来跟踪约束的状态。每个约束用整数中的一个位来表示，每当状态改变时，这个位就会相应地增加和清除。并且该对象提供getter/setter方法来轮询各个约束的当前状态。以及检查作业整体状态的方法，即<code class="fe nn no np nq b">isReady()</code>。</p><p id="9736" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">通俗地说，它有一个整数表示运行作业所需的约束(来自我们提供的JobInfo ),还有一个整数表示约束的当前状态。如果有2个相等，那么<code class="fe nn no np nq b">isReady()</code>返回真。</p><pre class="kg kh ki kj gt om nq on oo aw op bi"><span id="b01b" class="oa ml iq nq b gy oq or l os ot">private boolean isConstraintsSatisfied(int satisfiedConstraints) {<br/>    if (overrideState == <em class="nz">OVERRIDE_FULL</em>) {<br/>        <em class="nz">// force override: the job is always runnable<br/>        </em>return true;<br/>    }<br/><br/>    int sat = satisfiedConstraints;<br/>    if (overrideState == <em class="nz">OVERRIDE_SOFT</em>) {<br/>        <em class="nz">// override: pretend all 'soft' requirements are satisfied<br/>        </em>sat |= (requiredConstraints &amp; <em class="nz">SOFT_OVERRIDE_CONSTRAINTS</em>);<br/>    }<br/><br/>    return (sat &amp; mRequiredConstraintsOfInterest) ==   mRequiredConstraintsOfInterest;<br/>}</span></pre><p id="2870" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">一旦你看到这个类，你会看到这个类是一个应用周期限制到你的工作，即最大周期不能超过1年，最小不能少于15分钟。</p><h1 id="cba6" class="mk ml iq bd mm mn mo mp mq mr ms mt mu jw mv jx mw jz mx ka my kc mz kd na nb bi translated">作业存储和作业集</h1><p id="8c7d" class="pw-post-body-paragraph kw kx iq ky b kz ne jr lb lc nf ju le lf nw lh li lj nx ll lm ln ny lp lq lr ij bi translated">该组件维护您的系统上运行的所有作业的列表(是的，在您的系统上)。这作为XML文件<code class="fe nn no np nq b">jobs.xml</code>保存在系统数据目录下的<code class="fe nn no np nq b">/system/jobs</code>目录中。每当一个作业被创建时，它被记录在这个类中，当一个作业被删除时，它必须从这个类中删除。它公开了简单的API，例如，<code class="fe nn no np nq b">add(JobStatus)</code>，<code class="fe nn no np nq b">remove(JobStatus)</code>，<code class="fe nn no np nq b">contains(JobStatus)</code>，<code class="fe nn no np nq b">removeAllForUid(userID)</code>等。</p><p id="2660" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">当系统启动时，这个组件被创建，所有写入XML的作业被读取并转换成<code class="fe nn no np nq b">JobStatus</code>对象，然后<code class="fe nn no np nq b">JobSchedulerService</code>发出一个运行命令来运行任何适用的作业。</p><p id="d355" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">如果我们看一下它的内部，我们会看到作业是按照用户id存储和分组的。这样做是因为，如果用户被删除，它可以轮询所有作业并取消它。如果它必须为用户启动作业，也可以做类似的事情。所以数据看起来像<code class="fe nn no np nq b">Map&lt;UserID, Set&lt;JobStatus&gt; &gt;</code>。</p><pre class="kg kh ki kj gt om nq on oo aw op bi"><span id="69ba" class="oa ml iq nq b gy oq or l os ot">private JobStore(Context context, Object lock, File dataDir) {<br/>    mLock = lock;<br/>    mWriteScheduleLock = new Object();<br/>    mContext = context;<br/><br/>    File systemDir = new File(dataDir, "system");<br/>    File jobDir = new File(systemDir, "job");<br/>    jobDir.mkdirs();<br/>    mJobsFile = new AtomicFile(new File(jobDir, "jobs.xml"), "jobs");<br/><br/>    mJobSet = new JobSet();<br/>    readJobMapFromDisk(mJobSet, mRtcGood);<br/>}</span></pre><p id="2169" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这是你的作业调度器的内存。这就是它记住您的作业的方式，如果设备重新启动多次，就会重新安装这些作业。</p><h2 id="8600" class="oa ml iq bd mm ob oc dn mq od oe dp mu lf of og mw lj oh oi my ln oj ok na ol bi translated">控制器和状态改变监听器</h2><p id="389c" class="pw-post-body-paragraph kw kx iq ky b kz ne jr lb lc nf ju le lf nw lh li lj nx ll lm ln ny lp lq lr ij bi translated">JS的特殊能力是，当满足/不满足约束时，它可以运行作业并抢占它们。控制器是实现此功能的组件。</p><blockquote class="ou ov ow"><p id="d805" class="kw kx nz ky b kz la jr lb lc ld ju le ox lg lh li oy lk ll lm oz lo lp lq lr ij bi translated">控制器是JobScheduler框架的感知器官，它监听系统的实时状态。</p></blockquote><p id="bc22" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">理想情况下，对于您在<code class="fe nn no np nq b">JobInfo</code>中提供的每个约束，至少有一个控制器映射到它。其中有<code class="fe nn no np nq b">BatteryController</code>、<code class="fe nn no np nq b">ChargingController</code>、<code class="fe nn no np nq b">ConnectivityController</code>、<code class="fe nn no np nq b">IdleController</code>、<code class="fe nn no np nq b">QuotaController</code>等等很多。</p><p id="f6a4" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">每个控制器都遵循一个控制器契约，该契约有两个重要的方法，<code class="fe nn no np nq b">maybeStartTracking(JobStatus)</code>、<code class="fe nn no np nq b">maybeStopTracking(JobStatus)</code></p><p id="d9ab" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这些API的帮助方式是，每当一个任务被调度时，<code class="fe nn no np nq b">JobSchedulerService</code>有一个所有控制器(<code class="fe nn no np nq b">List&lt;Controllers&gt;</code>)的列表，它在一个for循环中运行并触发<code class="fe nn no np nq b">maybeStartTracking()</code>。在每个控制器内部，有一个检查，查看该作业是否有控制器可以帮助监听的约束。如果是，则将作业附加到跟踪作业状态列表中，否则忽略它。</p><pre class="kg kh ki kj gt om nq on oo aw op bi"><span id="1ca8" class="oa ml iq nq b gy oq or l os ot">@Override<br/>public void maybeStartTrackingJobLocked(JobStatus taskStatus, JobStatus lastJob) {<br/>   <strong class="nq ir"> if (taskStatus.hasPowerConstraint()) { // use job status API <br/>        mTrackedTasks.add(taskStatus);</strong><br/>        taskStatus.setTrackingController(JobStatus.<em class="nz">TRACKING_BATTERY</em>);<br/>        taskStatus.setChargingConstraintSatisfied(mChargeTracker.isOnStablePower());<br/>        taskStatus.setBatteryNotLowConstraintSatisfied(mChargeTracker.isBatteryNotLow());<br/>    }<br/>}</span></pre><p id="faae" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">现在的问题是，它如何监听系统状态？</p><p id="fd37" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">大多数Android开发人员都知道这些用例可以通过广播接收器来实现。所以你的猜测也是正确的。每个控制器都建立在广播接收机之上。因此，它提供了基于拉或推的支持。</p><p id="c6d7" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">之所以需要拉，是因为作业调度器服务有时会想知道在运行作业之前是否满足特定的约束条件(通常是在提交作业并需要立即运行时)。需要基于推的API来更新<code class="fe nn no np nq b">jobStatus</code>对象，以获得满足的约束的实时状态。</p><p id="5c0e" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">基于推的通信通过称为状态改变监听器的契约发生。<code class="fe nn no np nq b">JobSchedulerService</code>实现这个接口，当每个控制器改变状态时，它使用下面的回调方法通知JS服务:</p><pre class="kg kh ki kj gt om nq on oo aw op bi"><span id="ff88" class="oa ml iq nq b gy oq or l os ot">public interface StateChangedListener {<br/>    <em class="nz">/**<br/>     * Called by the controller to notify the JobManager that it should check on the state of a<br/>     * task.<br/>     */<br/>    </em>public void onControllerStateChanged();<br/><br/>    <em class="nz">/**<br/>     * Called by the controller to notify the JobManager that regardless of the state of the task,<br/>     * it must be run immediately.<br/>     * @param jobStatus The state of the task which is to be run immediately. &lt;strong&gt;null<br/>     *                  indicates to the scheduler that any ready jobs should be flushed.&lt;/strong&gt;<br/>     */<br/>    </em>public void onRunJobNow(JobStatus jobStatus);<br/><br/>    public void onDeviceIdleStateChanged(boolean deviceIdle);<br/>}</span></pre><p id="da6c" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">以下是数据的总体流向:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi pa"><img src="../Images/7273368ad0ad4fd7ffcc8b373ef03d7f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*mCtSzaoX6fnBoDbwZ6UEkQ.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">作者图片</p></figure><h2 id="3757" class="oa ml iq bd mm ob oc dn mq od oe dp mu lf of og mw lj oh oi my ln oj ok na ol bi translated">作业服务上下文</h2><p id="49fb" class="pw-post-body-paragraph kw kx iq ky b kz ne jr lb lc nf ju le lf nw lh li lj nx ll lm ln ny lp lq lr ij bi translated">该框架将可以一起运行的最大作业数限制为16个。这个限制不是应用范围的限制，而是跨不同用户的系统范围的限制。</p><pre class="kg kh ki kj gt om nq on oo aw op bi"><span id="1d99" class="oa ml iq nq b gy oq or l os ot"><em class="nz">/** The maximum number of concurrent jobs we run at one time. */<br/></em>static final int <em class="nz">MAX_JOB_CONTEXTS_COUNT </em>= 16;<br/><br/><em class="nz">/** The maximum number of jobs that we allow an unprivileged app to schedule */<br/></em>private static final int <em class="nz">MAX_JOBS_PER_APP </em>= 100;</span></pre><p id="631a" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">为了运行16个作业，框架创建了16个shells，作业在其中执行。这些炮弹被称为<code class="fe nn no np nq b">JobServiceContext</code>。它们在系统启动时被初始化，并且用phase == <code class="fe nn no np nq b">THIRD_PARTY_APPS_CAN_START</code>调用<code class="fe nn no np nq b">onBootPhase(int phase)</code>。下面是剥离的启动代码:</p><pre class="kg kh ki kj gt om nq on oo aw op bi"><span id="daf1" class="oa ml iq nq b gy oq or l os ot">else if (phase == PHASE_THIRD_PARTY_APPS_CAN_START) {<br/>    synchronized (mLock) {<br/>        <em class="nz">// Let's go!<br/>        </em>mReadyToRock = true;<br/>       <br/>        <strong class="nq ir"><em class="nz">// Create the "runners".</em></strong><em class="nz"><br/>        </em>for (int i = 0; i &lt; <em class="nz">MAX_JOB_CONTEXTS_COUNT</em>; i++) {<br/>            mActiveServices.add(<br/>                    new JobServiceContext(this, mBatteryStats, mJobPackageTracker,<br/>                            getContext().getMainLooper()));<br/>        }<br/>       <strong class="nq ir"> <em class="nz">// Attach jobs to their controllers.</em></strong><em class="nz"><br/>        </em>mJobs.forEachJob((job) -&gt; {<br/>            for (int controller = 0; controller &lt; mControllers.size(); controller++) {<br/>                final StateController sc = mControllers.get(controller);<br/>                <strong class="nq ir">sc.maybeStartTrackingJobLocked</strong>(job, null);<br/>            }<br/>        });<br/>       <strong class="nq ir"> <em class="nz">// GO GO GO! Fire the jobs if they are ready</em></strong><em class="nz"><br/>        </em>mHandler.obtainMessage(<em class="nz">MSG_CHECK_JOB</em>).sendToTarget();<br/>    }</span></pre><p id="d7ff" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">所有这16个shell都是可重用的shell，这意味着当一个作业被抢占时，它可以用来运行另一个作业。所以，现在问题来了，app的<code class="fe nn no np nq b">JobService</code>运行在app的进程中，而<code class="fe nn no np nq b">JobServiceContext</code>运行在系统进程中——但是它们如何能够协同工作呢？</p><p id="d9b0" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">正如你已经猜到的，AIDL出现了。</p><p id="ec52" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><code class="fe nn no np nq b">JobServiceContext</code>是托管流程的主机，交互通过AIDL接口完成。互动是双向的。在<code class="fe nn no np nq b">JobServiceContext</code>里面有一个<code class="fe nn no np nq b">IJobService</code>接口引用，指向用户的<code class="fe nn no np nq b">JobService</code>，当回调被给予<code class="fe nn no np nq b">JobService</code>时，比如<code class="fe nn no np nq b">onStartJob(JobParameters)</code>、<code class="fe nn no np nq b">onStopJob(JobParameters)</code>、<strong class="ky ir">、</strong>这个<code class="fe nn no np nq b">JobParameter</code>包含了一个叫做<code class="fe nn no np nq b">JobCallback</code>、<strong class="ky ir">、</strong>的东西，它是一小组方法的绑定实现，这些方法可以从app进程中调用。它看起来像下面这样:</p><pre class="kg kh ki kj gt om nq on oo aw op bi"><span id="42ba" class="oa ml iq nq b gy oq or l os ot">final class JobCallback extends IJobCallback.Stub {<br/>    public String mStoppedReason;<br/>    public long mStoppedTime;<br/><br/>    @Override<br/>    public void acknowledgeStartMessage(int jobId, boolean ongoing) {<br/>        doAcknowledgeStartMessage(this, jobId, ongoing);<br/>    }<br/><br/>    @Override<br/>    public void acknowledgeStopMessage(int jobId, boolean reschedule) {<br/>        doAcknowledgeStopMessage(this, jobId, reschedule);<br/>    }<br/><br/>    @Override<br/>    public JobWorkItem dequeueWork(int jobId) {<br/>        return doDequeueWork(this, jobId);<br/>    }<br/><br/>    @Override<br/>    public boolean completeWork(int jobId, int workId) {<br/>        return doCompleteWork(this, jobId, workId);<br/>    }<br/><br/>    @Override<br/>    public void jobFinished(int jobId, boolean reschedule) {<br/>        doJobFinished(this, jobId, reschedule);<br/>    }<br/>}</span></pre><p id="cb19" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">作业回调中的方法与从<code class="fe nn no np nq b">JobService</code>调用的方法相同。你可能只使用<code class="fe nn no np nq b">completeWork</code>和<code class="fe nn no np nq b">jobFinished</code>，但是，如果我们看到<code class="fe nn no np nq b">JobService.java</code>类的实现，我们也会看到所有这些方法的用法。</p><p id="94cc" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">现在，我们知道存在双向通信的机制，<code class="fe nn no np nq b">IJobService</code>绑定器实现用于<code class="fe nn no np nq b">JobServiceContext</code> - &gt; <code class="fe nn no np nq b">User</code> <code class="fe nn no np nq b">JobService</code>，而<code class="fe nn no np nq b">JobCallback</code>内部的<code class="fe nn no np nq b">JobParameters</code>则相反。</p><p id="25e3" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">下图展示了我们之前讨论的内容:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi pb"><img src="../Images/4392605551e82ce2a27d47b1185d8bb4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*9AlqvYfkPqFXu3xylWhMZg.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">JobServiceContext流程图</p></figure><p id="f15e" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">需要记住的一点是<code class="fe nn no np nq b">JobServiceContext</code>是<code class="fe nn no np nq b">ServiceConnection</code>的一个实现，所以当上下文绑定到你的作业服务时，它会收到一个回调<code class="fe nn no np nq b">onServiceConnected()</code>，在这个回调里面，会收到指向你的作业服务的AIDL绑定器，这里也是创建<code class="fe nn no np nq b">JobParameter</code>实例的地方。让我们看看一些剥离的代码:</p><pre class="kg kh ki kj gt om nq on oo aw op bi"><span id="b8f6" class="oa ml iq nq b gy oq or l os ot">boolean executeRunnableJob(JobStatus job) {<br/>    synchronized (mLock) {<br/>       <br/>        mRunningJob = job;<br/>        mRunningCallback = new JobCallback();<br/> <br/>        mParams = <strong class="nq ir">new JobParameters</strong>(mRunningCallback, job.getJobId(), ji.getExtras(),<br/>                ji.getTransientExtras(), ji.getClipData(), ji.getClipGrantFlags(),<br/>                isDeadlineExpired, triggeredUris, triggeredAuthorities, job.network);<br/><br/><br/>        <strong class="nq ir">final Intent intent = new Intent().setComponent(job.getServiceComponent());</strong></span><span id="f9f8" class="oa ml iq nq b gy pc or l os ot">        boolean binding = false;<br/>        try {<br/>            binding = <strong class="nq ir">mContext.bindServiceAsUser(intent, this,<br/>                    Context.<em class="nz">BIND_AUTO_CREATE</em></strong><em class="nz"> </em>| Context.<em class="nz">BIND_NOT_FOREGROUND<br/>                    </em>| Context.<em class="nz">BIND_NOT_PERCEPTIBLE</em>,<br/>                    new UserHandle(job.getUserId()));<br/>        } catch (SecurityException e) {<br/>         //. some code<br/>        }<br/>        return true;<br/>    }<br/>}</span></pre><p id="a587" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这里我们看到开始一个作业绑定到服务，现在当你的服务被创建时，这个类接收<code class="fe nn no np nq b">onServiceConnected()</code> <strong class="ky ir">，</strong>这是你的作业服务绑定到这个类的地方，它触发<code class="fe nn no np nq b">IJobService.startJob(params)</code> <strong class="ky ir">。</strong></p><p id="caa1" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><code class="fe nn no np nq b">JobServiceContext</code>负责与用户<code class="fe nn no np nq b">JobService</code>的各种沟通。任何需要在服务中触发回调的组件都必须请求这个组件。</p><h1 id="b87b" class="mk ml iq bd mm mn mo mp mq mr ms mt mu jw mv jx mw jz mx ka my kc mz kd na nb bi translated">JobConcurrencyManager</h1><p id="b0a7" class="pw-post-body-paragraph kw kx iq ky b kz ne jr lb lc nf ju le lf nw lh li lj nx ll lm ln ny lp lq lr ij bi translated">正如我们已经看到的，在框架中只能有16个服务同时运行，但是可以有数百个作业。所以就带来了什么时候运行什么的问题。这个问题由并发管理器解决。</p><blockquote class="ou ov ow"><p id="b159" class="kw kx nz ky b kz la jr lb lc ld ju le ox lg lh li oy lk ll lm oz lo lp lq lr ij bi translated">因此，它公开了一个由JobSchedulerService使用的API<em class="iq">assignobstocontextslocked</em>。JS服务从不直接启动作业，因为它永远不知道哪些作业已经在运行，而且还需要进行大量的抢占。所以，你将总是看到它将调用<em class="iq">assignjobstocontexts locked always。</em></p></blockquote><p id="cc37" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我将尝试用非常简单的术语来解释这一点。</p><p id="d257" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">该组件跟踪所有16个正在运行的作业，如果有新作业，它将扫描所有插槽，并查看插槽是否可用。如果可用，它会使用我们刚刚研究过的<code class="fe nn no np nq b">JobServiceContext</code>将作业分配到服务的插槽和kicks。</p><p id="71ba" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">如果插槽不可用，它将运行所有插槽，并查看正在运行的服务的优先级是否低于被请求运行的服务的优先级，如果正在运行的服务优先级较低，则在该插槽上请求<code class="fe nn no np nq b">onStopJob()</code>,它被抢占，新服务被分配到该插槽。如果所有的服务都很重要，那么所请求的服务会一直等待，直到一个槽为空。</p><p id="bff9" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">总的来说，流程如下所示:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi pd"><img src="../Images/255e809e15aa0f816487593314524fcd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Qi5ukgwBcnGT_u1rwVimVw.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">JobConcurrencyManager流程</p></figure><h1 id="5016" class="mk ml iq bd mm mn mo mp mq mr ms mt mu jw mv jx mw jz mx ka my kc mz kd na nb bi translated">作业调度服务(续..如约而至)</h1><p id="b3de" class="pw-post-body-paragraph kw kx iq ky b kz ne jr lb lc nf ju le lf nw lh li lj nx ll lm ln ny lp lq lr ij bi translated">我们知道到目前为止JS服务是主协调器，这里我们将看到当使用<code class="fe nn no np nq b">schedule(JobInfo)</code>和<code class="fe nn no np nq b">enqueue(JobInfo, JobWorkItem)</code>调度一个作业时会发生什么。这两个调用都被路由到一个内部方法，</p><pre class="kg kh ki kj gt om nq on oo aw op bi"><span id="2ee8" class="oa ml iq nq b gy oq or l os ot">public int scheduleAsPackage(JobInfo job, JobWorkItem work, int uId, String packageName, int userId, String tag)</span></pre><p id="cadd" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">里面发生了什么？</p><p id="6918" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">最好用流程图来演示:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi pe"><img src="../Images/b1ef1eba769c59ace19029e73a32afdd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*q294zmgcf2lQIBdUw8njYw.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">schedule() API工作</p></figure><ol class=""><li id="517d" class="nc nd iq ky b kz la lc ld lf pf lj pg ln ph lr nj nk nl nm bi translated">当一个作业进入时，系统会查看是否有一个已经计划好的具有相同ID的作业，如果没有，则创建一个JobStatus对象。如果已经存在具有该ID的作业，那么它检查作业是否相同(<code class="fe nn no np nq b">JobInfo</code>改变了吗？).如果是同一个作业，则它将传入的工作排队到现有作业，否则它请求取消现有作业并将所有工作转移到新作业。</li></ol><p id="a121" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">2.一旦<code class="fe nn no np nq b">JobStatus</code>在不存在的情况下被创建，或者为调度的作业获取了现有的作业状态，这个类使用我们讨论过的<code class="fe nn no np nq b">maybeStartTracking(JobStatus)</code> API启动跟踪请求，相关的控制器开始跟踪作业。</p><p id="f53d" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">3.现在，它调用<code class="fe nn no np nq b">isReady()</code>来查看它现在是否可以运行。如果<code class="fe nn no np nq b">NO</code>，那么它被保存在未决列表中(当控制器通知满足约束时，它被触发)。如果<code class="fe nn no np nq b">isReady()</code>返回<code class="fe nn no np nq b">YES</code>，它使用<code class="fe nn no np nq b">assignJobsToContextsLocked()</code> <em class="nz">向<code class="fe nn no np nq b">JobConcurrencyManager</code>发出请求。</em></p><p id="8876" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">4.<code class="fe nn no np nq b">JobConcurrencyManager</code>找到一个可用的插槽，并使用<code class="fe nn no np nq b">executeRunnableJob</code> API请求<code class="fe nn no np nq b">JobServiceContext</code>启动应用程序的<code class="fe nn no np nq b">JobService</code>。它绑定服务，然后调用<code class="fe nn no np nq b">onServiceConnected()</code>。从那里用作业参数触发<code class="fe nn no np nq b">onStartJob</code>回调。</p><p id="b4df" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这是作业调度框架内部发生的事情的鸟瞰图。虽然我没有涵盖所有内容，但我希望它在某种程度上是有用的，可以帮助您自己浏览代码库。</p></div></div>    
</body>
</html>