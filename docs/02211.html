<html>
<head>
<title>The Little-Known Key to Optimized React Loader Components</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">优化React装载机组件的鲜为人知的关键</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/implementing-a-loader-react-component-e5535dc66738?source=collection_archive---------11-----------------------#2019-11-13">https://betterprogramming.pub/implementing-a-loader-react-component-e5535dc66738?source=collection_archive---------11-----------------------#2019-11-13</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="2d79" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">了解一些有经验的开发人员忽略的细节</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/754193b4fb059bd822c078bf5c111631.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*VBYfSl4w5TsrI09QRFvipg.jpeg"/></div></div></figure><p id="c27b" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">有人可能认为实现一个<a class="ae lq" href="https://reactjs.org/" rel="noopener ugc nofollow" target="_blank"> React </a> loader组件非常简单——事实也确实如此。然而，有一个细节，即使是一些有经验的开发人员也会忽略，这个细节将使代码更有效，更不容易出错。</p><p id="017b" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">让我们从最简单的实现开始:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="lr ls l"/></div></figure><p id="beeb" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">我们会这样使用它:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="lr ls l"/></div></figure><p id="4c6e" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">在我们查看提议的改进之前，让我们后退一步，确保我们理解了代码评估顺序。</p><p id="7295" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">假设我们有以下代码:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="lr ls l"/></div></figure><p id="3cb2" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">我希望大家都同意，上述功能的执行顺序是:<code class="fe lt lu lv lw b">function3</code>、<code class="fe lt lu lv lw b">function2</code>、<code class="fe lt lu lv lw b">function1</code>。基本的东西。</p><p id="b2d2" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">现在，这与React组件有什么关系？</p><p id="a82f" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">为了编写呈现组件的代码，我们大多数人依赖一种类似XML的语法，称为<a class="ae lq" href="https://reactjs.org/docs/introducing-jsx.html" rel="noopener ugc nofollow" target="_blank"> JSX </a>(在呈现<code class="fe lt lu lv lw b">Loader</code>时使用)。</p><p id="596d" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">但是当这些代码通过编译器时(最常见的是<a class="ae lq" href="https://babeljs.io/" rel="noopener ugc nofollow" target="_blank"> Babel </a>，它被转换成原始的JS，来自:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="lr ls l"/></div></figure><p id="da26" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">收件人:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="lr ls l"/></div></figure><p id="b756" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated"><a class="ae lq" href="https://babeljs.io/repl/#?babili=false&amp;browsers=&amp;build=&amp;builtIns=false&amp;spec=false&amp;loose=false&amp;code_lz=FAMwrgdgxgLglgewgAgLYE8DCDUAckCmEMAFAJTIDewyyUSAzjMgNoAmAhjBwDJxMAaZAwIwAIl178YAXWQBeZGBEBlbjALkA3MgD0u5J27J-SiGwIg4EAmxp1GzFvx4IObawHMhImAEkGV3cvOUVlAjUuTTItYHtwaHgkZAAbNzYJbnIqe1o9AygUuCgAay9kGAALAmQAIzAYGGTUDhKCBgrqw0lkDgA3DjgUjlqUglzhUUypJhIWAHIMAFojDgBGeaFF9BXJJYAmeZkYid8AoI8ITxIQDhSRE9oAXzjaACdRMDeUEgmAHg8fQAfBNaH96o1kkhMEVSvJKGl3NMnkCLshpn9dBCmhAQXk8n8LgQ3iZAukvPCXOSrijQXlKKs-EwAHQtXAkVYKIHIAAGABVKqYACQMyRPUloawEZk8sgvfFg3REt54gm6QGqk5PIA&amp;debug=false&amp;forceAllTransforms=false&amp;shippedProposals=false&amp;circleciRepo=&amp;evaluate=false&amp;fileSize=false&amp;timeTravel=false&amp;sourceType=module&amp;lineWrap=true&amp;presets=react&amp;prettier=false&amp;targets=&amp;version=7.7.3&amp;externalPlugins=" rel="noopener ugc nofollow" target="_blank">试试看</a>。</p><p id="524c" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated"><code class="fe lt lu lv lw b">Loader</code>的另一种写法用法是:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="lr ls l"/></div></figure><p id="d191" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">很酷吧。</p><p id="5d3a" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">通过使用我们在文章开始时建立的关于代码求值顺序的知识，我们应该理解不管<code class="fe lt lu lv lw b">isLoading</code>的值或<code class="fe lt lu lv lw b">dataList</code>的值如何，都会对<code class="fe lt lu lv lw b">dataList.map(…)</code>求值。</p><p id="133c" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">我们假设只有当<code class="fe lt lu lv lw b">isLoading</code>变为假时<code class="fe lt lu lv lw b">dataList</code>才会被填充。但是现在我们知道它甚至会在那之前被使用。因此，当这种情况发生时，我们需要有防御性代码，以防止<code class="fe lt lu lv lw b">dataList</code>未定义的情况。</p><p id="432b" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">编写防御性代码是解决这个问题的一种方法，但是效率呢？如果不需要的话，例如当<code class="fe lt lu lv lw b">isLoading</code>为真时，难道我们不想完全避免执行<code class="fe lt lu lv lw b">dataList.map(…)</code>吗？</p><p id="6d41" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">我们可以使用的模式如下:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="lr ls l"/></div></figure><p id="b81d" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">因此，我们不是发送已经计算好的内容来呈现，而是发送一个将返回该内容的函数。那个函数实际上是一个<a class="ae lq" href="https://en.wikipedia.org/wiki/Thunk" rel="noopener ugc nofollow" target="_blank"> thunk </a>。您可能已经从<a class="ae lq" href="https://github.com/reduxjs/redux-thunk#whats-a-thunk" rel="noopener ugc nofollow" target="_blank"> redux-thunk </a>中了解了thunks。为此，我们需要如下修改<code class="fe lt lu lv lw b">Loader</code>组件:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="lr ls l"/></div></figure><p id="3bc6" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">在这个场景中，<code class="fe lt lu lv lw b">children</code>是返回内容的函数。</p><p id="fcba" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">这种模式很有效，因为它延迟了计算代码来呈现<code class="fe lt lu lv lw b">children</code>，直到真正需要它的时候。当可能不需要渲染子对象时，这很有用。</p><p id="cea8" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">如果我们试图在获得渲染内容所依赖的数据之前计算渲染内容，我们可以避免出现错误。</p><p id="f582" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">这使我们能够编写更短的代码，不需要太多的防御(因为我们只有在拥有所有需要的数据时才进行计算)。</p><p id="9b04" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">这种模式也可以用于其他组件(想想任何有条件地呈现其子组件的组件；例如，基于用户的许可)。</p></div><div class="ab cl lx ly hx lz" role="separator"><span class="ma bw bk mb mc md"/><span class="ma bw bk mb mc md"/><span class="ma bw bk mb mc"/></div><div class="im in io ip iq"><p id="beaf" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">感谢阅读！我希望这有助于您理解在render上如何计算代码。</p></div></div>    
</body>
</html>