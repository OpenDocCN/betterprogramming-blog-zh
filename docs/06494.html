<html>
<head>
<title>Let’s Build a Circular Loading Indicator in Swift 5</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">让我们在Swift 5中构建一个循环加载指示器</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/lets-build-a-circular-loading-indicator-in-swift-5-b06fcdf1260d?source=collection_archive---------2-----------------------#2020-10-07">https://betterprogramming.pub/lets-build-a-circular-loading-indicator-in-swift-5-b06fcdf1260d?source=collection_archive---------2-----------------------#2020-10-07</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="6c4b" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">你不需要一个第三方库</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/8fd219c7e2bf37ca90b5bb04784cf190.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*rue3iyd6wBOgUFaK"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated"><a class="ae ky" href="https://unsplash.com/@filmprint?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">梁金森</a>在<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的照片</p></figure><p id="0d6a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在本教程中，我们将学习如何在Swift中实现循环加载指示器。最终，您将拥有一个可重用的UI元素，可以在您的应用程序中使用，以满足您的需求。</p><p id="6221" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">简而言之，这就是我们将在本文中掌握的内容:</p><ul class=""><li id="4f23" class="lv lw it lb b lc ld lf lg li lx lm ly lq lz lu ma mb mc md bi translated">使用<code class="fe me mf mg mh b">CAShapeLayer</code>和<code class="fe me mf mg mh b">UIBezierPath</code>创建一个圆形和路径</li><li id="19fe" class="lv lw it lb b lc mi lf mj li mk lm ml lq mm lu ma mb mc md bi translated">使用<code class="fe me mf mg mh b">CABasicAnimation</code>和<code class="fe me mf mg mh b">CAKeyframeAnimation</code>制作圆形动画</li><li id="27c3" class="lv lw it lb b lc mi lf mj li mk lm ml lq mm lu ma mb mc md bi translated">使用<code class="fe me mf mg mh b">CAAnimationGroup</code>合并几个动画</li></ul><p id="ba64" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这是我们要达到的结果:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi mn"><img src="../Images/f5f9b0ed005fdbd499f2e7e7406f2806.png" data-original-src="https://miro.medium.com/v2/resize:fit:1180/1*kF9oJqhu7x60pqtXTxAJYA.gif"/></div></figure><p id="798b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">完成的项目的源代码可以在文章的底部找到。</p><p id="306e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">事不宜迟，我们开始吧。</p></div><div class="ab cl mo mp hx mq" role="separator"><span class="mr bw bk ms mt mu"/><span class="mr bw bk ms mt mu"/><span class="mr bw bk ms mt"/></div><div class="im in io ip iq"><h1 id="87e2" class="mv mw it bd mx my mz na nb nc nd ne nf jz ng ka nh kc ni kd nj kf nk kg nl nm bi translated">我们开始吧</h1><p id="b243" class="pw-post-body-paragraph kz la it lb b lc nn ju le lf no jx lh li np lk ll lm nq lo lp lq nr ls lt lu im bi translated">首先，我们首先创建一个名为<code class="fe me mf mg mh b">ProgressView</code>的<code class="fe me mf mg mh b">UIView</code>子类:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ns nt l"/></div></figure><p id="788e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">目前，这是一个简单的圆形视图。在我们开始画一个圆之前，我们需要为它创建一个路径。</p><p id="fbd3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们创建一个新的<code class="fe me mf mg mh b">ProgressShapeLayer.swift</code>文件，如下所示:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ns nt l"/></div></figure><p id="ae9e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们将很快使用上面的<code class="fe me mf mg mh b">CAShapeLayer</code>绘制一个圆形指示器。下面是上面使用的每个属性的含义:</p><ul class=""><li id="3fa1" class="lv lw it lb b lc ld lf lg li lx lm ly lq lz lu ma mb mc md bi translated"><code class="fe me mf mg mh b">strokeColor</code>定义路径的颜色</li><li id="1f77" class="lv lw it lb b lc mi lf mj li mk lm ml lq mm lu ma mb mc md bi translated"><code class="fe me mf mg mh b">lineWidth</code>决定了路径的宽度</li><li id="6fcc" class="lv lw it lb b lc mi lf mj li mk lm ml lq mm lu ma mb mc md bi translated"><code class="fe me mf mg mh b">fillColor</code>定义圆形路径包围的区域的颜色</li><li id="5d79" class="lv lw it lb b lc mi lf mj li mk lm ml lq mm lu ma mb mc md bi translated"><code class="fe me mf mg mh b">lineCap</code>设置为<code class="fe me mf mg mh b">.round</code>,使路径两边变圆</li></ul><p id="f4e0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们完成了形状的图层。现在，让我们按如下方式更新<code class="fe me mf mg mh b">ProgressView</code>类:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ns nt l"/></div></figure><p id="da1a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">变化如下:</p><ol class=""><li id="9c06" class="lv lw it lb b lc ld lf lg li lx lm ly lq lz lu nu mb mc md bi translated">我们改变初始化器来包含一个<code class="fe me mf mg mh b">UIColor</code>的数组和一个<code class="fe me mf mg mh b">lineWidth</code>属性。我们指定了一个颜色数组，因为我们希望指示器随着动画反复改变颜色。</li><li id="a990" class="lv lw it lb b lc mi lf mj li mk lm ml lq mm lu nu mb mc md bi translated">一个方便的初始化器帮助我们实例化<code class="fe me mf mg mh b">ProgressView</code>而不用指定<code class="fe me mf mg mh b">frame</code>属性。</li><li id="0859" class="lv lw it lb b lc mi lf mj li mk lm ml lq mm lu nu mb mc md bi translated">在<code class="fe me mf mg mh b">layoutSubviews()</code>方法中，我们创建一个循环<code class="fe me mf mg mh b">UIBezierPath</code>并将其分配给<code class="fe me mf mg mh b">ProgressShapeLayer</code>。</li><li id="8baf" class="lv lw it lb b lc mi lf mj li mk lm ml lq mm lu nu mb mc md bi translated">正如在第一步中提到的，我们添加了两个属性来帮助我们创建一个具有可变厚度的多色路径。</li><li id="c128" class="lv lw it lb b lc mi lf mj li mk lm ml lq mm lu nu mb mc md bi translated">我们获得了<code class="fe me mf mg mh b">ProgressShapeLayer</code>，并使用<code class="fe me mf mg mh b">colors</code>和<code class="fe me mf mg mh b">lineWidth</code>属性惰性地实例化了它。初始的<code class="fe me mf mg mh b">strokeColor</code>被设置为<code class="fe me mf mg mh b">colors</code>数组的第一个颜色。</li></ol><p id="5a83" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">最后，我们准备开始创建笔画动画。</p></div><div class="ab cl mo mp hx mq" role="separator"><span class="mr bw bk ms mt mu"/><span class="mr bw bk ms mt mu"/><span class="mr bw bk ms mt"/></div><div class="im in io ip iq"><h1 id="b209" class="mv mw it bd mx my mz na nb nc nd ne nf jz ng ka nh kc ni kd nj kf nk kg nl nm bi translated">设置笔划动画</h1><p id="0393" class="pw-post-body-paragraph kz la it lb b lc nn ju le lf no jx lh li np lk ll lm nq lo lp lq nr ls lt lu im bi translated">创建一个新的<code class="fe me mf mg mh b">StrokeAnimation.swift</code>文件:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ns nt l"/></div></figure><p id="ced1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们是这样做的:</p><ol class=""><li id="b0c1" class="lv lw it lb b lc ld lf lg li lx lm ly lq lz lu nu mb mc md bi translated">用表示路径边缘的<code class="fe me mf mg mh b">start</code>和<code class="fe me mf mg mh b">end</code>事例创建一个枚举<code class="fe me mf mg mh b">StrokeType</code>。</li><li id="2fb8" class="lv lw it lb b lc mi lf mj li mk lm ml lq mm lu nu mb mc md bi translated">添加一个<code class="fe me mf mg mh b">init()</code>方法的空实现。这背后的原因将在本文后面解释。</li><li id="9a68" class="lv lw it lb b lc mi lf mj li mk lm ml lq mm lu nu mb mc md bi translated">创建一个以<code class="fe me mf mg mh b">StrokeType</code>、<code class="fe me mf mg mh b">beginTime</code>、<code class="fe me mf mg mh b">fromValue</code>、<code class="fe me mf mg mh b">toValue</code>和<code class="fe me mf mg mh b">duration</code>为参数的初始化器。根据<code class="fe me mf mg mh b">StrokeType</code>，我们将动画显示路径的起点或终点。如上所述，<code class="fe me mf mg mh b">keyPath</code>属性是基于<code class="fe me mf mg mh b">StrokeType</code>确定的。</li></ol><p id="aa47" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">注意，在初始化器中，我们还指定了<code class="fe me mf mg mh b">timingFunction</code>来使动画缓慢地开始和结束。</p><p id="e12d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">太好了！现在让我们在<code class="fe me mf mg mh b">ProgressView.swift</code>文件中的<code class="fe me mf mg mh b">ProgressShapeLayer</code>上使用这个动画:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ns nt l"/></div></figure><p id="6e14" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">正如我们所看到的，我们添加了一个名为<code class="fe me mf mg mh b">animateStroke()</code>的新方法，它执行以下操作:</p><ol class=""><li id="09a0" class="lv lw it lb b lc ld lf lg li lx lm ly lq lz lu nu mb mc md bi translated">用<code class="fe me mf mg mh b">.start</code> StrokeType初始化<code class="fe me mf mg mh b">StrokeAnimation</code>。我们希望路径的开始边缘比结束边缘慢，所以我们将<code class="fe me mf mg mh b">beginTime</code>指定为0.25。这个属性在使用<code class="fe me mf mg mh b">CAAnimationGroup</code>时很有用，它允许我们组合几个动画。值0.25意味着这个特定的动画将在总动画时间的四分之一过去后开始。</li><li id="e668" class="lv lw it lb b lc mi lf mj li mk lm ml lq mm lu nu mb mc md bi translated">初始化另一个<code class="fe me mf mg mh b">StrokeAnimation</code>，但这次我们指定了<code class="fe me mf mg mh b">.end</code> <code class="fe me mf mg mh b">StrokeType</code>。这个动画马上开始，所以<code class="fe me mf mg mh b">beginTime</code>推断为0。</li><li id="3725" class="lv lw it lb b lc mi lf mj li mk lm ml lq mm lu nu mb mc md bi translated">创建一个总持续时间为一秒且重复次数无限的<code class="fe me mf mg mh b">CAAnimationGroup</code>。注意，我们需要将上面两个动画的数组设置为<code class="fe me mf mg mh b">animations</code>属性。</li><li id="1d29" class="lv lw it lb b lc mi lf mj li mk lm ml lq mm lu nu mb mc md bi translated">将<code class="fe me mf mg mh b">strokeAnimationGroup</code>加到<code class="fe me mf mg mh b">ProgressShapeLayer</code>上。</li></ol><p id="63e7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">5.最后，添加<code class="fe me mf mg mh b">ProgressShapeLayer</code>到<code class="fe me mf mg mh b">ProgressView</code>层。</p><p id="2e12" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们测试一下我们取得了什么成果。将<code class="fe me mf mg mh b">ProgressView</code>添加到<code class="fe me mf mg mh b">UIViewController</code>中，如下所示:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ns nt l"/></div></figure><p id="536d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在，如果我们构建并运行该应用程序，我们将看到以下结果:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi mn"><img src="../Images/e27a266102855406ccb6c3188822ce7a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1180/1*4Wyqxs3S8fXS2vZUULakOg.gif"/></div></figure><p id="4889" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">路径的颜色没有改变，因为我们还没有创建一个彩色动画。但是我们看到画圆动画正在按照需要执行。</p><p id="2d4e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们还有几件事要做:</p><ul class=""><li id="0562" class="lv lw it lb b lc ld lf lg li lx lm ly lq lz lu ma mb mc md bi translated">向圆形路径添加旋转动画</li><li id="9489" class="lv lw it lb b lc mi lf mj li mk lm ml lq mm lu ma mb mc md bi translated">动画显示路径颜色的变化</li></ul></div><div class="ab cl mo mp hx mq" role="separator"><span class="mr bw bk ms mt mu"/><span class="mr bw bk ms mt mu"/><span class="mr bw bk ms mt"/></div><div class="im in io ip iq"><h1 id="39bb" class="mv mw it bd mx my mz na nb nc nd ne nf jz ng ka nh kc ni kd nj kf nk kg nl nm bi translated">制作旋转动画</h1><p id="c1f0" class="pw-post-body-paragraph kz la it lb b lc nn ju le lf no jx lh li np lk ll lm nq lo lp lq nr ls lt lu im bi translated">创建一个<code class="fe me mf mg mh b">RotationAnimation</code>类，如下所示:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ns nt l"/></div></figure><p id="0a5f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">类似于我们用<code class="fe me mf mg mh b">StrokeAnimation</code>所做的，这里我们提供了<code class="fe me mf mg mh b">Direction</code>枚举来决定我们应该在什么方向旋转一个UI元素。</p><p id="a45f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在让我们在<code class="fe me mf mg mh b">ProgressView.swift</code>文件中使用它:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ns nt l"/></div></figure><p id="1629" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如上所述，我们添加了<code class="fe me mf mg mh b">animateRotation()</code>方法，在该方法中，我们执行以下操作:</p><ul class=""><li id="f813" class="lv lw it lb b lc ld lf lg li lx lm ly lq lz lu ma mb mc md bi translated">指定<code class="fe me mf mg mh b">z</code>旋转方向</li><li id="030a" class="lv lw it lb b lc mi lf mj li mk lm ml lq mm lu ma mb mc md bi translated">从0弧度开始旋转</li><li id="baf8" class="lv lw it lb b lc mi lf mj li mk lm ml lq mm lu ma mb mc md bi translated">在两个pi弧度处结束旋转</li><li id="52b7" class="lv lw it lb b lc mi lf mj li mk lm ml lq mm lu ma mb mc md bi translated">给动画两秒钟时间来完成</li><li id="10fc" class="lv lw it lb b lc mi lf mj li mk lm ml lq mm lu ma mb mc md bi translated">无限重复动画</li><li id="afa1" class="lv lw it lb b lc mi lf mj li mk lm ml lq mm lu ma mb mc md bi translated">将完成的<code class="fe me mf mg mh b">RotationAnimation</code>添加到<code class="fe me mf mg mh b">ProgressView</code>层</li></ul><p id="6e04" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这就是我们之前必须添加一个空的<code class="fe me mf mg mh b">init()</code>方法实现的原因:<code class="fe me mf mg mh b">self.layer.add()</code>命令调用<code class="fe me mf mg mh b">CABasicAnimation</code>的标准初始化器。这就是为什么它需要实现它；否则，我们会得到一个“使用未实现的初始化器”的错误。</p><p id="0bfa" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在，让我们在<code class="fe me mf mg mh b">ViewController</code>内部调用这个方法:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ns nt l"/></div></figure><p id="8068" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们会注意到现在动画看起来更好了:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi mn"><img src="../Images/c374b1814b63b8822b1f2ee48f2adb22.png" data-original-src="https://miro.medium.com/v2/resize:fit:1180/1*Pnno_TkCz73gxcwF-Cy9hA.gif"/></div></figure><p id="be53" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在，到最后一步:动画路径的颜色。</p></div><div class="ab cl mo mp hx mq" role="separator"><span class="mr bw bk ms mt mu"/><span class="mr bw bk ms mt mu"/><span class="mr bw bk ms mt"/></div><div class="im in io ip iq"><h1 id="6db2" class="mv mw it bd mx my mz na nb nc nd ne nf jz ng ka nh kc ni kd nj kf nk kg nl nm bi translated">动画颜色</h1><p id="9672" class="pw-post-body-paragraph kz la it lb b lc nn ju le lf no jx lh li np lk ll lm nq lo lp lq nr ls lt lu im bi translated">就像我们之前做的一样，让我们创建一个新的<code class="fe me mf mg mh b">StrokeColorAnimation.swift</code>文件:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ns nt l"/></div></figure><p id="c0a9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在初始化器中，我们期望一个<code class="fe me mf mg mh b">CGColor</code>的数组和一个<code class="fe me mf mg mh b">Double</code>的持续时间值。</p><p id="c1dd" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们在<code class="fe me mf mg mh b">ProgressView.swift</code>文件中使用它。按如下方式更新<code class="fe me mf mg mh b">animateStroke()</code>方法:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ns nt l"/></div></figure><p id="14a2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如上所示，我们在<code class="fe me mf mg mh b">self.layer.addSublayer</code>行之前添加了以下内容:</p><ul class=""><li id="474f" class="lv lw it lb b lc ld lf lg li lx lm ly lq lz lu ma mb mc md bi translated">实例化<code class="fe me mf mg mh b">StrokeColorAnimation</code>。因为<code class="fe me mf mg mh b">ProgressView</code>的<code class="fe me mf mg mh b">colors</code>属性属于<code class="fe me mf mg mh b">[UIColor]</code>类型，而我们需要提供给<code class="fe me mf mg mh b">StrokeColorAnimation</code>的属性是<code class="fe me mf mg mh b">[CGColor]</code>，我们需要将每个<code class="fe me mf mg mh b">UIColor</code>转换为<code class="fe me mf mg mh b">CGColor</code>。我们还以这样的方式计算持续时间，以确保随着每个笔画动画，我们改变路径的颜色。</li><li id="6e6a" class="lv lw it lb b lc mi lf mj li mk lm ml lq mm lu ma mb mc md bi translated">将<code class="fe me mf mg mh b">colorAnimation</code>加到<code class="fe me mf mg mh b">ProgressShapeLayer</code>上。</li></ul><p id="cd77" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">不错！我们现在可以构建并运行应用程序来查看结果:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi mn"><img src="../Images/0cd87d82b4e05113dc6c926f9a8107e3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1180/1*RXQRB5WnnOhCmrvKwJTFPg.gif"/></div></figure></div><div class="ab cl mo mp hx mq" role="separator"><span class="mr bw bk ms mt mu"/><span class="mr bw bk ms mt mu"/><span class="mr bw bk ms mt"/></div><div class="im in io ip iq"><h1 id="8f16" class="mv mw it bd mx my mz na nb nc nd ne nf jz ng ka nh kc ni kd nj kf nk kg nl nm bi translated">最终重构</h1><p id="c2be" class="pw-post-body-paragraph kz la it lb b lc nn ju le lf no jx lh li np lk ll lm nq lo lp lq nr ls lt lu im bi translated">如果我们简单地使用一个<code class="fe me mf mg mh b">isAnimating</code>属性(就像在<code class="fe me mf mg mh b">UIActivityIndicator</code>中一样)而不是直接调用动画方法，那就太好了。</p><p id="bdfd" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">所以让我们将它添加到<code class="fe me mf mg mh b">ProgressView</code>中:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ns nt l"/></div></figure><p id="c298" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在，如果我们将它设置为<code class="fe me mf mg mh b">true</code>，所有的动画都将开始。一旦我们将它设置为<code class="fe me mf mg mh b">false</code>，所有的动画都将从图层中移除。</p><p id="f921" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">考虑从后端加载一个<code class="fe me mf mg mh b">String</code>并希望在请求过程中显示加载指示器的情况。下面是<code class="fe me mf mg mh b">ViewController.swift</code>文件的样子:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ns nt l"/></div></figure><p id="3cc8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">以下是上述文件的概述:</p><ul class=""><li id="a8e1" class="lv lw it lb b lc ld lf lg li lx lm ly lq lz lu ma mb mc md bi translated"><code class="fe me mf mg mh b">setupUI()</code>方法简单地将<code class="fe me mf mg mh b">helloLabel</code>和<code class="fe me mf mg mh b">loadingIndicator</code>放在屏幕中央。<code class="fe me mf mg mh b">helloLabel</code>最初是隐藏的。</li><li id="91cd" class="lv lw it lb b lc mi lf mj li mk lm ml lq mm lu ma mb mc md bi translated">在<code class="fe me mf mg mh b">viewDidLoad()</code>中，我们通过将其<code class="fe me mf mg mh b">isAnimating</code>属性设置为<code class="fe me mf mg mh b">true</code>来启动加载指示器。为了模拟从后端加载数据的真实情况，三秒钟后，我们将<code class="fe me mf mg mh b">isAnimating</code>属性设置为<code class="fe me mf mg mh b">false</code>，并在屏幕上显示<code class="fe me mf mg mh b">helloLabel</code>。</li></ul><p id="769c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">下面是上述实现的结果:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi mn"><img src="../Images/49fdef68da8490a32fa4b5514dc76e16.png" data-original-src="https://miro.medium.com/v2/resize:fit:1180/1*NWkngn2s79umpB8idOdfwA.gif"/></div></figure><p id="6544" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们最终实现了一个循环负载指示器，并展示了如何在现实生活中使用它。</p></div><div class="ab cl mo mp hx mq" role="separator"><span class="mr bw bk ms mt mu"/><span class="mr bw bk ms mt mu"/><span class="mr bw bk ms mt"/></div><div class="im in io ip iq"><h1 id="85d2" class="mv mw it bd mx my mz na nb nc nd ne nf jz ng ka nh kc ni kd nj kf nk kg nl nm bi translated">资源</h1><p id="d613" class="pw-post-body-paragraph kz la it lb b lc nn ju le lf no jx lh li np lk ll lm nq lo lp lq nr ls lt lu im bi translated">该项目的源代码可以在GitHub上找到:</p><div class="nv nw gp gr nx ny"><a href="https://github.com/zafarivaev/CircularLoadingIndicator" rel="noopener  ugc nofollow" target="_blank"><div class="nz ab fo"><div class="oa ab ob cl cj oc"><h2 class="bd iu gy z fp od fr fs oe fu fw is bi translated">zafarivaev/循环加载指示器</h2><div class="of l"><h3 class="bd b gy z fp od fr fs oe fu fw dk translated">这个项目展示了如何使用UIBezierPath，CABasicAnimation，CAKeyframeAnimation创建一个循环加载指示器…</h3></div><div class="og l"><p class="bd b dl z fp od fr fs oe fu fw dk translated">github.com</p></div></div><div class="oh l"><div class="oi l oj ok ol oh om ks ny"/></div></div></a></div><p id="eb40" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">感谢阅读！</p></div></div>    
</body>
</html>