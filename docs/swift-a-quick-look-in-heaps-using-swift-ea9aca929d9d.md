# 让我们了解一下 Swift 中的堆

> 原文：<https://betterprogramming.pub/swift-a-quick-look-in-heaps-using-swift-ea9aca929d9d>

## 实现我们自己的堆泛型类

![](img/22b1e234ec88e26c51f245f4a5d65d45.png)

一般来说，对于计算机科学来说，堆是有趣的结构。它们听起来和看起来都像树。通常，这些家伙的实现是使用一个带有一些辅助函数的数组来完成的。

我正在研究这些结构，并决定使用 Swift 来实现它们。我将使用托马斯·科尔曼的 [*算法介绍*作为指南。这本书使用索引 *1* 作为一个列表的第一个索引。为了使我们的实现工作顺利，我将用 *0* 替换它。我们去实现吧。](https://www.amazon.com/Introduction-Algorithms-3rd-MIT-Press/dp/0262033844/ref=sr_1_2?keywords=Introduction+to+Algorithms&qid=1581888679&sr=8-2)

所以基本上，正如在*算法简介*中提到的，这种结构的实现可以很容易地通过使用数组和一些方法来帮助我们识别一个索引的父索引和左+右子索引。我从 [HackerRank](https://www.youtube.com/watch?v=t0Cq6tVNRBA) 得到了几个助手函数，并把它们翻译到了 Swift 上。

基本上，要找出位于数组索引 *i* 上的节点的父节点，我们只需执行 *i* /2。正如我们的参考书第 6.1 章所解释的，做 *i* : *i*2* 找到左边的节点，做 *i*2 + 1* 找到右边的节点。因为我们将索引移动了一个负值，所以我们必须对算法进行必要的修改。上面其余的函数都很简单。将所有这些助手函数添加到我们的堆类中。

# 实现堆类

为了实现 heap 类，我们需要一些变量来使列表的控制更容易。首先，我为我的列表伪造了一个 *C* 实现。出于这个原因，在堆的 init 中，我将用 nil 对象填充 items 列表，重复它 *capacity* 次。没有它，这个实现也可以很容易地完成，但是要使它工作，我们需要在算法中做一些改变。我将在最后留下另一个实现，它不需要用 nil 对象填充这个列表——我认为这对 Swift 来说更明智。此外，我还编写了一个计数变量和一个助手来了解堆是否为空。

关于条目列表的大小，我们需要一些东西来确保这个列表总是包含适合我们的元素的最小大小。为了实现这一点，我们需要创建一个函数，在每次列表达到最大容量时将列表的大小翻倍。在向列表中添加新元素之前，我们总是会调用它。

# 向堆中添加元素

说到 add 函数，我想我们已经准备好实现它了。在这里，我们称`ensureExtraCapacity` *。*要添加新元素 *X* ，我们将把它放在第一个添加的节点上，这个节点仍然没有左右节点。这很简单。我们只需要把元素放在数组的末尾，我们的需求就会因为之前给出的公式而得到匹配。现在，由于我们正在实现一个最小堆，我们必须确保 *X* 占据了正确的位置。在我们的例子中， *X* 必须大于 *parentOf(X)* 。

为了确保 *X* 被正确放置，我们将实现一个名为`heapifyUp`的函数。这个函数基本上会访问 *X* 的父节点。然后我们调用 *Y* 检查*Y*<*如果是，我们就切换 *X* 和 *Y* 。现在将访问 *Y* 的父节点，同样的计算将在 *Y* 和它的父节点之间执行。这种模式不断重复，直到到达堆的根(*items【0】*)。实现可以在下面找到:*

*这样，我们就完成了堆的最基本的实现。我将在我的 [GitHub](https://github.com/alcivanio/dataStructuresInSwift/blob/master/Heap/Heap.playground/Contents.swift) 上保留可用的实现以及函数轮询，以移除堆的根并在之后修复堆。在这个文件中，您还会发现实现更加快捷——不需要用 nil 对象填充项目数组。*

# *堆的分析*

*现在快速分析一下堆函数。基本上，添加一个新元素需要花费 *O(log n)* 的时间，其中 *n* 是堆中已经存在的元素的数量。 *n* 的 log 基本代表堆/树的高度。*

*你喜欢读这篇文章吗？请在下方留言评论。*