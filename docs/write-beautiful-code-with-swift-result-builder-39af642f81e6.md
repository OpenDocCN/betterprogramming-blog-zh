# 使用 Swift 结果生成器编写漂亮的代码

> 原文：<https://betterprogramming.pub/write-beautiful-code-with-swift-result-builder-39af642f81e6>

## 让你的 UIKit 代码看起来像 SwiftUI 一样干净

![](img/ed979ac59e4036e0a7eba623271364d5.png)

SwiftUI 最值得注意的一点就是看起来不可思议。它采用了相对较大的代码块，并将其压缩成漂亮而简单的东西，这样即使是非程序员也能理解发生了什么。

但是您知道吗，从 Swift 5.4 开始，您可以将这种体验复制到任何您想要的东西上。

您可以像在 SwiftUI 中一样，在 UIKit 中构建 URL 请求、复杂的数据结构，甚至整个屏幕。

换句话说，您可以非常容易地在您的应用程序中实现 DSL。

# 等等……DSL？

如果你还没有听说过“DSL”这个术语，那就该说说了。

DSL 代表**特定领域语言**。

但这意味着什么呢？

当我们看一种“常规”编程语言时，例如 Swift，我们可以看到，理论上，我们可以构建任何我们想要的东西。

这一切都依赖于我们下面的框架。

例如，只要我们有合适的框架，我们就可以构建服务器端应用程序、web 和 Android。

类、结构和枚举不是 iOS 特有的特性。

另一方面，DSL 是为处理特定领域或问题而编写的语言。

HTML 就是一个很好的例子。

HTML 的主要目标是描述网页上显示的文档。

HTML 非常适合这个目的，非程序员也能轻松阅读。

另一个例子是 XML 或 JSON，它们非常适合保存通用数据结构。

回到 Swift——Swift ui 是一个 DSL。它的主要目的是描述一个动态屏幕，它也是建立在 Swift 之上的，Swift 是一种 GPL(通用语言)。

为了创建更多 DSL 风格的代码，我们需要使用一种叫做 Result Builder 的东西，它是 Swift 语言的一部分，可以帮助我们创建漂亮的代码。

# 结果生成器

让我们通过一个例子来理解结果生成器是如何工作的，我们将从一个简单的例子开始——数据结构。

假设我们想要描述一个从团队和玩家构建的数据结构。

我们的数据结构可能看起来像这样:

这是结构的标准代码片段。

你看到所有的括号了吗？那是代码的味道。我们可以使用结果生成器来使我们的代码更加清晰。

我们要做的第一件事是获取一个包含玩家列表的块(类似于我们在 SwiftUI 中看到的),并从中构建一个数组:

这是我们的第一个结果生成器！

结果构建器只是一个顶部标有`@resultBuilder`的结构。

我们需要为所有结果构建器添加的基本方法是`buildBlock`，它接受可变对象并返回一个数组。就是这样！

要创建一个新的结果生成器，我们可以创建一个前缀为`@TeamBuilder`的新变量:

很酷吧。

我们去掉了括号和逗号，我们的代码看起来很像 SwiftUI 和 HTML！

# 让我们添加修饰语

下一个技巧与结果生成器无关，但是如果我们在这里处理一个简单的代码，为什么不讨论它呢？

我们可以使用修饰符来提高代码的可读性。

如果你以前写过 SwiftUI 代码，你大概知道什么是修饰符。

现在，修饰符不是一个“特性”,而是一个简单的设计模式，当你有很多属性时，它可以帮助你的代码变得更加易读。

使用修饰符，您可以将属性链接在一起，而不考虑它们的顺序，也可以将它们彼此分开。

我们通过复制结构、设置新值并返回更新副本来实现这一点:

# 让我们添加 if-then-else 条件

提供球员名单有点无聊。

我们希望我们的 DSL 更加复杂。为此，让我们尝试实现一些逻辑:

看起来很简单，哈？

没那么快。尝试构建上面的代码会导致错误(但是，至少结果构建器会产生一些结果):

**"** 包含控制流语句的闭包不能与结果生成器“TeamBuilder”一起使用"

原因是静态函数`buildBlock`期望接收可变的对象列表。If-then-else 不是其预期的一部分。

为了增加对 If-then-else 的支持，我们需要实现另外三个方法

`buildOptional`和`buildEither`(两种变化)。

关于`resultBuilder`你需要记住的一个重要规则是，如果你想让它支持额外的方法而不是`buildBlock`，组件和结果必须是相同的类型。大概是这样的:

```
**static** **func** buildBlock(_ components: **[Player]…)** -> **[Player]** {
```

但是这将迫使我们创建一个`Player`的数组列表，而不仅仅是一个`Player`的列表。

为了同时支持`Player`和【播放器】，我们可以使用协议:

`PlayerGroup`可以是单个`Player`也可以是一个`Player`的数组。

现在让我们看看如何添加额外的方法:

重新编译代码，它就工作了！

注意，我已经改变了`buildBlock`方法，用`PlayerGroup`代替了 Player。

# 在初始化式中实现

一旦有了结果生成器，就可以将其作为 init 方法的一部分来实现:

我在 Team struct 中添加了修饰符，但这是可选的，只是为了让代码更具 SwiftUI 风格。

# 受够了体育。还有什么？

有了 Result Builder，你可以做一些令人惊奇的事情，尽管受到你的想象力和技能的限制。

这里只是一些想法:

-在 UIKit 中渲染屏幕

-构建 HTTP 请求。

-用核心图形绘制形状。

-创建数据结构。

-生成属性化字符串。

-创建关键帧动画。

所有这些都用你自己的易读易懂的“语言”来表达。

例如，以下代码是路径内置结果生成器:

你能想出更多的例子吗？