<html>
<head>
<title>Build a Set of Blockchains Using Java</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">用Java建立一套区块链</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/build-a-set-of-blockchains-using-java-d99cd866931b?source=collection_archive---------7-----------------------#2021-07-05">https://betterprogramming.pub/build-a-set-of-blockchains-using-java-d99cd866931b?source=collection_archive---------7-----------------------#2021-07-05</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="e266" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">通过对等网络建立信任</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/08204e42c42d2f592253635f3061853e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*hMflXMP45VCXU71WqXGupw.jpeg"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">图片由来自<a class="ae ky" href="https://pixabay.com/?utm_source=link-attribution&amp;utm_medium=referral&amp;utm_campaign=image&amp;utm_content=921039" rel="noopener ugc nofollow" target="_blank"> Pixabay </a>的<a class="ae ky" href="https://pixabay.com/users/claudiawollesen-887962/?utm_source=link-attribution&amp;utm_medium=referral&amp;utm_campaign=image&amp;utm_content=921039" rel="noopener ugc nofollow" target="_blank"> ClaudiaWollesen </a></p></figure><p id="ed77" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在这个系列的第一部分，我们制作了一个区块链。现在我们要做一组，让他们互相交流。区块链的真正意义在于分布式验证系统。您可以从任何节点添加数据块，最终它会到达对等节点，因此每个人都同意区块链的样子。这很重要，因为你不希望在一个分布式系统中只有一个真实的来源。</p><p id="7dbe" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">马上就出现了一个问题:每个节点都是两个服务，外加一个MongoDB和一个Kafka消息总线，它们都需要相互通信。但是我想在一台主机(我的笔记本电脑)上测试和演示多个节点。我一直在用Docker compose运行，所以我必须为每个节点创建一个Docker compose文件，以帮助保持端口的直线性。</p><p id="4768" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们将致力于一个节点服务，它将允许节点相互协作。这将从两个地方获得输入，一个是restful接口，允许您添加和列出连接的节点，另一个是Kafka提供的消息总线，通知节点服务本地区块链中需要广播到对等节点的更改。</p><p id="14a8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">为了将服务作为图像使用，我将使用Google Jib maven插件。这是从maven构建中创建映像的最简单的方法。我们将以下内容添加到需要图像的每个模块的pom文件中:</p><pre class="kj kk kl km gt lv lw lx ly aw lz bi"><span id="4a6d" class="ma mb it lw b gy mc md l me mf">&lt;build&gt;<br/>    &lt;plugins&gt;<br/>        &lt;plugin&gt;<br/>            &lt;groupId&gt;com.google.cloud.tools&lt;/groupId&gt;<br/>            &lt;artifactId&gt;jib-maven-plugin&lt;/artifactId&gt;<br/>            &lt;version&gt;2.7.1&lt;/version&gt;<br/>        &lt;/plugin&gt;<br/>    &lt;/plugins&gt;<br/>&lt;/build&gt;</span></pre><p id="f40c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在我们的例子中，我们可以使用配置的默认值。接下来，您可以运行<code class="fe mg mh mi lw b">mvn clean install jib:build</code>，它将创建一个您可以在Docker合成文件中使用的图像。</p><p id="7cc4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们利用到目前为止所拥有的，从一个名为<code class="fe mg mh mi lw b">docker-compose-node1</code>的全包Docker compose文件开始:</p><pre class="kj kk kl km gt lv lw lx ly aw lz bi"><span id="3251" class="ma mb it lw b gy mc md l me mf">version: '3.1'<br/>services:<br/>  mongo:<br/>    image: mongo<br/>    restart: always<br/>    ports:<br/>      - 27017<br/>    environment:<br/>      MONGO_INITDB_ROOT_USERNAME: root<br/>      MONGO_INITDB_ROOT_PASSWORD: example<br/>  mongo-express:<br/>    image: mongo-express<br/>    restart: always<br/>    ports:<br/>      - 8081:8081<br/>    environment:<br/>      ME_CONFIG_MONGODB_ADMINUSERNAME: root<br/>      ME_CONFIG_MONGODB_ADMINPASSWORD: example<br/>  zookeeper:<br/>    image: confluentinc/cp-zookeeper:latest<br/>    ports:<br/>      - 2181<br/>    environment:<br/>      ZOOKEEPER_CLIENT_PORT: 2181<br/>  kafka:<br/>    image: confluentinc/cp-kafka:latest<br/>    ports:<br/>      - 9092<br/>      - 29092<br/>    links:<br/>      - zookeeper<br/>    environment:<br/>      KAFKA_BROKER_ID: 1<br/>      KAFKA_ZOOKEEPER_CONNECT: zookeeper:2181<br/>      KAFKA_ADVERTISED_LISTENERS: PLAINTEXT://kafka:29092<br/>      KAFKA_LISTENER_SECURITY_PROTOCOL_MAP: PLAINTEXT:PLAINTEXT<br/>      KAFKA_INTER_BROKER_LISTENER_NAME: PLAINTEXT<br/>      KAFKA_OFFSETS_TOPIC_REPLICATION_FACTOR: 1<br/>  blockchain:<br/>    image: rlkamradt/blockchain:1.0-SNAPSHOT<br/>    ports:<br/>      - 8080:8080<br/>    environment:<br/>      MONGO_HOST: mongo<br/>      SPRING_KAFKA_BOOTSTRAP-SERVERS: kafka:29092</span></pre><p id="2ac8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">你会注意到一些事情发生了变化。首先，我删除了Kafka的外部端口，这样它只能在compose网络内部访问。然后，我添加了区块链应用程序，其中包含了构建过程中创建的图像。最后，我用环境变量覆盖了一些spring属性，这样它就可以从compose网络内部访问mongo和Kafka。合成将创建DNS条目，以便从同一个合成文件运行的服务可以相互访问。用这个命令<code class="fe mg mh mi lw b">docker compose -f docker-compose-node1.yaml up -d</code>运行它，并确保您仍然可以访问基本的区块链API:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi mj"><img src="../Images/04ce63d893b45259a16d429ddf3b5a5a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*LNS4pVh3jCPqK_A5bSvKdA.png"/></div></div></figure><p id="39c2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在，我们的应用程序已经启动并运行，并且已经创建了genesis块。</p><p id="915f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">区块链服务中已经有代码，每当我们添加一个块或添加一个事务时，它就向Kafka发送一条消息。我们需要创建一个新的服务来读取这些事件，并将它们广播给一组对等点。让我们把现在正在运行的东西放下来，添加一个简单的节点服务，它将在收到消息时记录消息。我们将在项目中需要一个新的模块-这将是另一个Spring Boot服务，它将能够与外部节点交谈。</p><p id="2f57" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">首先，我们需要定义一个节点，它只是一个URL。下面是<code class="fe mg mh mi lw b">Node</code>:</p><pre class="kj kk kl km gt lv lw lx ly aw lz bi"><span id="f317" class="ma mb it lw b gy mc md l me mf">@Data<br/>@Builder<br/>@AllArgsConstructor<br/>@NoArgsConstructor<br/>@JsonIgnoreProperties(ignoreUnknown = true)<br/>@Document<br/>public class Node {<br/>    @Id<br/>    private String id;<br/>    private String url;<br/>}</span></pre><p id="9ae4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们将它存储在MongoDB的集合中，因此我们需要一个存储库接口:</p><pre class="kj kk kl km gt lv lw lx ly aw lz bi"><span id="e84e" class="ma mb it lw b gy mc md l me mf">@Repository<br/>public interface NodeRepository extends<br/>                 ReactiveMongoRepository&lt;Node, String&gt; {<br/>    Mono&lt;Node&gt; findByUrl(String url);<br/>}</span></pre><p id="7ad8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">接下来，我们需要一个控制器来查看和添加<code class="fe mg mh mi lw b">Node</code>对象:</p><pre class="kj kk kl km gt lv lw lx ly aw lz bi"><span id="d505" class="ma mb it lw b gy mc md l me mf">@Slf4j<br/>@RestController<br/>@RequestMapping("/node")<br/>public class SimpleNodeController {<br/>    private final Blockchain blockchain;<br/>    private final SimpleNodeService simpleNodeService;<br/><br/>    public SimpleNodeController(Blockchain blockchain,<br/>                     SimpleNodeService simpleNodeService) {<br/>        this.simpleNodeService = simpleNodeService;<br/>        this.blockchain = blockchain;<br/>    }<br/><br/>    @GetMapping(path = "peers", produces =<br/>                    MediaType.<em class="mk">TEXT_EVENT_STREAM_VALUE</em>)<br/>    Flux&lt;Node&gt; getNodes() {<br/>        return simpleNodeService.getPeers();<br/>    }<br/><br/>    @PostMapping(path = "peers", produces =<br/>                   MediaType.<em class="mk">APPLICATION_JSON_VALUE</em>)<br/>    Mono&lt;Node&gt; addNode(@RequestBody Node node) {<br/>        return simpleNodeService.connectToPeer(node);<br/>    }<br/><br/>}</span></pre><p id="2bda" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">然后，我们需要一个与MongoDB和Kafka交互的简单服务类:</p><pre class="kj kk kl km gt lv lw lx ly aw lz bi"><span id="5f61" class="ma mb it lw b gy mc md l me mf">@Component<br/>@Slf4j<br/>public class SimpleNodeService {<br/>    private static Node <em class="mk">myself</em>;<br/>    final private String host;<br/>    final private int port;<br/>    final private NodeRepository peers;<br/>    final private Blockchain blockchain;<br/>    final private ReactiveKafkaConsumerTemplate&lt;String, <br/>                                      Message&gt; emitter;<br/><br/>    public SimpleNodeService(@Value("${server.host}") String host,<br/>           @Value("${server.port}") String port,<br/>           Blockchain blockchain,<br/>           NodeRepository peers,<br/>           ReactiveKafkaConsumerTemplate&lt;String, Message&gt; emitter) {<br/>        this.host = host;<br/>        this.port = Integer.<em class="mk">parseInt</em>(port);<br/>        this.blockchain = blockchain;<br/>        this.emitter = emitter;<br/>        this.peers = peers;<br/>        <em class="mk">myself </em>= Node.<em class="mk">builder</em>()<br/>                .url("http://" + host + ":" + port)<br/>                .build();<br/>        emitter<br/>           .receiveAutoAck()<br/>           .doOnNext(consumerRecord -&gt; <em class="mk">log</em>.info(<br/>               "received key={}, value={} from topic={}, offset={}",<br/>               consumerRecord.key(),<br/>               consumerRecord.value(),<br/>               consumerRecord.topic(),<br/>               consumerRecord.offset())<br/>                )<br/>                .map(ConsumerRecord::value)<br/>                .subscribe(<br/>                    m -&gt; <em class="mk">log</em>.info("received message {}", m), <br/>                    e -&gt; <em class="mk">log</em>.error("error receiving Message", e));<br/>    }<br/><br/>    public Flux&lt;Node&gt; getPeers() {<br/>        return peers.findAll();<br/>    }<br/><br/>    public Mono&lt;Node&gt; connectToPeer(Node node) {<br/>        return peers.save(node);<br/>    }<br/>}</span></pre><p id="2053" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">从Kafka收到的任何消息都将被简单地记录下来，除了存储和列出它们之外，我们实际上不会对节点做任何事情。</p><p id="cd39" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">最后，我们需要告诉Spring Boot在哪里可以找到共享组件和库。我们可以注释主类:</p><pre class="kj kk kl km gt lv lw lx ly aw lz bi"><span id="6068" class="ma mb it lw b gy mc md l me mf"><a class="ae ky" href="http://twitter.com/Slf4j" rel="noopener ugc nofollow" target="_blank">@Slf4j</a><br/><a class="ae ky" href="http://twitter.com/SpringBootApplicatio" rel="noopener ugc nofollow" target="_blank">@SpringBootApplicatio</a>n<br/><a class="ae ky" href="http://twitter.com/ComponentScan" rel="noopener ugc nofollow" target="_blank">@ComponentScan</a>(basePackageClasses = {<br/>        net.kamradtfamily.blockchain.api.Blockchain.class,<br/>        net.kamradtfamily.blockchainnode.Application.class})<br/><a class="ae ky" href="http://twitter.com/EnableReactiveMongoR" rel="noopener ugc nofollow" target="_blank">@EnableReactiveMongoR</a>epositories(basePackageClasses = {<br/>        net.kamradtfamily.blockchain.api.BlockRepository.class,<br/>        net.kamradtfamily.blockchainnode.NodeRepository.class})<br/>public class Application {<br/>    public static void main(String [] args) {<br/>        SpringApplication.run(Application.class, args);<br/>        try {<br/>            Properties gitProps = new Properties();<br/>            gitProps.load(<br/>                Application<br/>                   .class<br/>                   .getResourceAsStream("/git.properties"));<br/>            log.info("Git Properties:");<br/>            gitProps.entrySet().stream()<br/>                    .forEach(es -&gt; <br/>                          log.info("{}: {}",<br/>                          es.getKey(),<br/>                          es.getValue()));<br/>        } catch (Exception e) {<br/>            log.error("Error reading Git Properties");<br/>        }<br/>    }<br/>}</span></pre><p id="1056" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">需要告诉Spring在哪里扫描组件和存储库。它通常在主类所在的包中出现，但是在我们的例子中，我们想要共享来自<code class="fe mg mh mi lw b">net.kamradtfamily.blockchain.api</code>的组件。所以我添加了<code class="fe mg mh mi lw b">ComponentScan</code>和<code class="fe mg mh mi lw b">EnableReactiveMongoRepositories</code>注解。我还添加了一些日志记录，这样每当它启动时，我们就会知道我们正在运行什么Git commit hash。</p><p id="e725" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">为了运行所有这些，我们需要移动一些端口。为了拥有新的服务和现有的服务，我们必须给每个服务提供唯一的外部端口。让我们把它加入到我们的<code class="fe mg mh mi lw b">docker-compose-node1.yaml</code>中:</p><pre class="kj kk kl km gt lv lw lx ly aw lz bi"><span id="9af4" class="ma mb it lw b gy mc md l me mf">blockchainnode:<br/>  image: rlkamradt/blockchainnode:1.0-SNAPSHOT<br/>  ports:<br/>    - 8080:8082<br/>  environment:<br/>    MONGO_HOST: mongo<br/>    SPRING_KAFKA_BOOTSTRAP-SERVERS: kafka:29092</span></pre><p id="e2ae" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">MongoExpress服务已经占用了端口8081，所以我们将它公开为8082。现在构建新的映像，提取并运行它们:</p><pre class="kj kk kl km gt lv lw lx ly aw lz bi"><span id="7072" class="ma mb it lw b gy mc md l me mf">mvn clean install jib:build<br/>docker compose -f docker-compose-node1.yaml pull<br/>docker compose -f docker-compose-node1.yaml up</span></pre><p id="b687" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">然后，当您用区块链服务创建一个事务时，您将在<code class="fe mg mh mi lw b">blockchainnode</code>服务的日志中看到收到了一条消息。您还可以点击端点<a class="ae ky" href="http://localhost:8082/node/peers" rel="noopener ugc nofollow" target="_blank">http://localhost:8082/node/peers</a>并创建和列出对等点。</p><p id="a432" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这就是事情变得复杂的地方。我们需要一个以上的节点运行，我们需要节点在事务或块添加后响应消息。我们还需要节点在启动或添加节点时相互通信。我要把<code class="fe mg mh mi lw b">SimpleNodeService</code>和<code class="fe mg mh mi lw b">SimpleNodeController</code>复制到<code class="fe mg mh mi lw b">NodeService</code>和<code class="fe mg mh mi lw b">NodeController</code>。如果你正在GitHub上看代码并想跟随，我将留下旧的类，但是我将注释掉<code class="fe mg mh mi lw b">Component</code>和<code class="fe mg mh mi lw b">RestController</code>注释，这样它们就不会在运行时启动。</p><p id="2c7c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我将向<code class="fe mg mh mi lw b">NodeController</code>添加一个额外的端点，以允许确认一个事务已经进入所有节点中的一个块:</p><pre class="kj kk kl km gt lv lw lx ly aw lz bi"><span id="1a29" class="ma mb it lw b gy mc md l me mf">@GetMapping(path = "transactions/:transactionId/confirmations",<br/>                        produces = MediaType.<em class="mk">ALL_VALUE</em>)<br/>Mono&lt;String&gt; getTransactionFromNode(<br/>             @RequestParam("transactionId") String transactionId) {<br/>    return nodeService<br/>            .getConfirmations(Long.<em class="mk">valueOf</em>(transactionId))<br/>            .map(b -&gt; b.toString());<br/>}</span></pre><p id="7818" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这意味着我需要在<code class="fe mg mh mi lw b">NodeService</code>中使用一组新方法来从所有节点获得确认:</p><pre class="kj kk kl km gt lv lw lx ly aw lz bi"><span id="0b63" class="ma mb it lw b gy mc md l me mf">public Mono&lt;Block&gt; getConfirmation(Node peer, long transactionId) {<br/>    String URL = peer.getUrl() <br/>          + "/block/blocks/transactions/" <br/>          + transactionId;<br/>    <em class="mk">log</em>.info("Getting transactions from: {}", URL);<br/>    return client<br/>            .get()<br/>            .uri(URL)<br/>            .retrieve().bodyToMono(Block.class);<br/>            .onErrorContinue((t, o) -&gt; Mono.<em class="mk">empty</em>());<br/>}<br/><br/>Mono&lt;Long&gt; getConfirmations(long transactionId) {<br/>// Get count of peers with confirmations that the transaction exists<br/>    return blockchain<br/>          .findTransactionInChain(transactionId, blockchain<br/>               .getAllBlocks())<br/>          .zipWith(peers.findAll()<br/>               .flatMap(peer -&gt; getConfirmation(peer,<br/>                               transactionId)))<br/>          .count();<br/>}</span></pre><p id="8430" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这将返回一个块中有此事务的节点的计数。但是首先，我需要在<code class="fe mg mh mi lw b">BlockController</code>中创建一个新的端点，它将报告事务是否在区块链的一个块中。</p><pre class="kj kk kl km gt lv lw lx ly aw lz bi"><span id="47bf" class="ma mb it lw b gy mc md l me mf">@GetMapping(path = "blocks/transaction/{transactionId}", <br/>                produces = MediaType.<em class="mk">APPLICATION_JSON_VALUE</em>)<br/>public Mono&lt;Block&gt; getTransaction(<br/>            @PathVariable("transactionId") Long transactionId) {<br/>    return blockchain<br/>            .findTransactionInChain(transactionId,<br/>                              blockchain.getAllBlocks())<br/>            .last() // assume there's only one<br/>            .switchIfEmpty(Mono.<em class="mk">error</em>(new ResponseStatusException(<br/>                    HttpStatus.<em class="mk">NOT_FOUND</em>, <br/>                    "Transaction Not Found in Blockchain")));</span></pre><p id="bdd6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">幸运的是，我们已经有了一个方法<code class="fe mg mh mi lw b">findTransactionInChain</code>，它将返回发现事务的块。</p><p id="3871" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">接下来，我们要回应来自卡夫卡的信息。我们将添加一个<code class="fe mg mh mi lw b">messageHandler</code>方法，它将向所有对等节点广播消息:</p><pre class="kj kk kl km gt lv lw lx ly aw lz bi"><span id="1304" class="ma mb it lw b gy mc md l me mf">public Mono&lt;? extends Object&gt; messageHandler(Message m) {<br/>  if("addedBlock".equals(m.getMessage())) {<br/>    return peers.findAll()<br/>            .flatMap(p -&gt; sendLatestBlock(p, m.getBlock()))<br/>            .switchIfEmpty(Mono.just(m.getBlock()))<br/>            .last();<br/>  } else if("addedTransaction".equals(m.getMessage())) {<br/>    return peers.findAll()<br/>            .flatMap(p -&gt; sendTransaction(p, m.getTransaction()))<br/>            .switchIfEmpty(Mono.just(m.getTransaction()))<br/>            .last();<br/>  } else if("getBlocks".equals(m.getMessage())) {<br/>    return peers.findAll()<br/>            .flatMap(p -&gt; getBlocks(p))<br/>            .switchIfEmpty(blockchain.getLastBlock())<br/>            .last();<br/>  } else {<br/>    log.error("unknown message {}", m);<br/>    return Mono.empty();<br/>  }<br/>}</span></pre><p id="a700" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这需要两种新方法向其他节点发出请求:</p><pre class="kj kk kl km gt lv lw lx ly aw lz bi"><span id="e260" class="ma mb it lw b gy mc md l me mf">public Mono&lt;ClientResponse&gt; sendLatestBlock(Node peer, <br/>                             Block block) {<br/>    String URL = peer.getUrl() + "/block/blocks/latest";<br/>    <em class="mk">log</em>.info("Posting latest block to: {}", URL);<br/>    return client<br/>            .put()<br/>            .uri(URL)<br/>            .body(block, Block.class)<br/>            .exchange();<br/>}<br/><br/>public Mono&lt;ClientResponse&gt; sendTransaction(Node peer, <br/>                             Transaction transaction) {<br/>    String URL = peer.getUrl() + "/transaction";<br/>    <em class="mk">log</em>.info("Sending transaction '{}' to: {}", transaction, URL);<br/>    return client<br/>            .post()<br/>            .uri(URL)<br/>            .body(transaction, Transaction.class)<br/>            .exchange();<br/>}</span></pre><p id="e6f4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们已经有了到<code class="fe mg mh mi lw b">/transaction</code>端点的POST，但是我们需要添加到<code class="fe mg mh mi lw b">/block/blocks/latest</code>端点的PUT。</p><pre class="kj kk kl km gt lv lw lx ly aw lz bi"><span id="6d3c" class="ma mb it lw b gy mc md l me mf">@PutMapping(path = "/block/blocks/latest", <br/>             produces =  MediaType.<em class="mk">APPLICATION_JSON_VALUE</em>)<br/>public Mono&lt;Block&gt; checkReceivedBlock(<br/>                    @RequestBody Block receivedBlock) {<br/>    return blockchain.checkReceivedBlock(receivedBlock);<br/>}</span></pre><p id="d968" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这需要在<code class="fe mg mh mi lw b">Blockchain</code>服务中使用新的方法。</p><pre class="kj kk kl km gt lv lw lx ly aw lz bi"><span id="8fd5" class="ma mb it lw b gy mc md l me mf">public Mono&lt;Block&gt; checkReceivedBlock(Block receivedBlock) {<br/>  return getLastBlock()<br/>      .filter(b -&gt; b.getIndex() &lt; receivedBlock.getIndex())<br/>      .flatMap(b -&gt; {<br/>         log.info(<br/>            "Blockchain possibly behind. We got: {}, Peer got: {}",<br/>            b.getIndex(),<br/>            receivedBlock.getIndex());<br/>         if (b.getHash().equals(receivedBlock.getPreviousHash())) { <br/>            log.info("Appending received block to our chain");<br/>            return addBlock(receivedBlock, true);<br/>         } else {<br/>            log.info("Querying chain from our peers");<br/>            emitter.send(TOPIC, Message.builder()<br/>               .type("empty")<br/>               .message("getBlocks")<br/>               .build())<br/>               .subscribe();<br/>            return Mono.empty();<br/>          }<br/>        });</span><span id="2f3a" class="ma mb it lw b gy ml md l me mf">}</span></pre><p id="3d73" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">您可以看到节点层如何通过公共API与其他节点对话。但是有一个问题。每个节点都由一个URL表示，但是我们必须与两个独立的服务对话:块服务和节点服务。我将使用Nginx实例做一个简单的入口。这样，我们就可以用一个URL与两个服务(以及更多服务)进行对话。您可以查看GitHub上的代码，了解关于Nginx配置和向<code class="fe mg mh mi lw b">docker-compose-node1.yaml</code>添加所有服务的详细信息。</p><p id="e717" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">启动一切，所有的端点仍然工作，我可以在日志中看到区块链服务和Kafka总线上的节点服务之间的通信。现在是时候制作第二个节点了。将<code class="fe mg mh mi lw b">docker-compose-node1.yaml</code>复制到<code class="fe mg mh mi lw b">docker-compose-node2.yaml</code>，将Nginx服务的外部端口从8080切换到8081，以便在端口8080到达节点1，在端口8081到达节点2。我还将创建一个名为<code class="fe mg mh mi lw b">startnode1</code>的小脚本来按顺序启动每个服务，并从节点服务输出日志:</p><pre class="kj kk kl km gt lv lw lx ly aw lz bi"><span id="2f80" class="ma mb it lw b gy mc md l me mf">docker compose -p node1 -f docker-compose-node1.yaml up -d mongo<br/>docker compose -p node1 -f docker-compose-node1.yaml up -d zookeeper<br/>docker compose -p node1 -f docker-compose-node1.yaml up -d mongo-express<br/>docker compose -p node1 -f docker-compose-node1.yaml up -d kafka<br/>docker compose -p node1 -f docker-compose-node1.yaml up -d blockchain<br/>docker compose -p node1 -f docker-compose-node1.yaml up blockchainnode</span></pre><p id="29ff" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">因为最后一行没有<code class="fe mg mh mi lw b">-d</code>标志，所以它显示日志，直到Ctrl-C停止它。我使用了<code class="fe mg mh mi lw b">-p node1</code>标志，这样我就可以创建单独的服务实例。接下来，复制到一个名为<code class="fe mg mh mi lw b">startnode2</code>的文件，但是替换Docker compose文件来启动node2，并将<code class="fe mg mh mi lw b">-p</code>标志替换为node 2。不要忘记在每个上设置可执行标志:</p><pre class="kj kk kl km gt lv lw lx ly aw lz bi"><span id="50c8" class="ma mb it lw b gy mc md l me mf">chmod +x startnode1<br/>chmod +x startnode2</span></pre><p id="4579" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">还有最后一个变化。节点服务的“我自己”成员需要有其他服务可以看到的URL，所以使用本地主机是不行的。我在应用程序中设置了一个Spring属性。</p><pre class="kj kk kl km gt lv lw lx ly aw lz bi"><span id="9efa" class="ma mb it lw b gy mc md l me mf">server.myself: http://localhost:8080</span></pre><p id="d724" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">然后我在docker-compose-node1.yaml中覆盖它，现在看起来像这样:</p><pre class="kj kk kl km gt lv lw lx ly aw lz bi"><span id="ae58" class="ma mb it lw b gy mc md l me mf">version: '3.1'<br/>services:<br/>  mongo:<br/>    image: mongo<br/>    restart: always<br/>    ports:<br/>      - 27017<br/>    environment:<br/>      MONGO_INITDB_ROOT_USERNAME: root<br/>      MONGO_INITDB_ROOT_PASSWORD: example<br/>  zookeeper:<br/>    image: confluentinc/cp-zookeeper:latest<br/>    ports:<br/>      - 2181<br/>    environment:<br/>      ZOOKEEPER_CLIENT_PORT: 2181<br/>  kafka:<br/>    image: confluentinc/cp-kafka:latest<br/>    ports:<br/>      - 9092<br/>      - 29092<br/>    links:<br/>      - zookeeper<br/>    environment:<br/>      KAFKA_BROKER_ID: 1<br/>      KAFKA_ZOOKEEPER_CONNECT: zookeeper:2181<br/>      KAFKA_ADVERTISED_LISTENERS: PLAINTEXT://kafka:29092<br/>      KAFKA_LISTENER_SECURITY_PROTOCOL_MAP: PLAINTEXT:PLAINTEXT<br/>      KAFKA_INTER_BROKER_LISTENER_NAME: PLAINTEXT<br/>      KAFKA_OFFSETS_TOPIC_REPLICATION_FACTOR: 1<br/>  blockchain:<br/>    image: rlkamradt/blockchain:1.0-SNAPSHOT<br/>    ports:<br/>      - 8080<br/>    environment:<br/>      SERVER_MYSELF: http://192.168.0.174:8080<br/>      MONGO_HOST: mongo<br/>      SPRING_KAFKA_BOOTSTRAP-SERVERS: kafka:29092<br/>  blockchainnode:<br/>    image: rlkamradt/blockchainnode:1.0-SNAPSHOT<br/>    ports:<br/>      - 8080<br/>    environment:<br/>      SERVER_MYSELF: http://192.168.0.174:8080<br/>      MONGO_HOST: mongo<br/>      SPRING_KAFKA_BOOTSTRAP-SERVERS: kafka:29092<br/>  nginx:<br/>    image: nginx:latest<br/>    volumes:<br/>      - ./nginx.conf:/etc/nginx/nginx.conf<br/>    ports:<br/>      - 8080:80</span></pre><p id="0635" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">对于<code class="fe mg mh mi lw b">SERVER_MYSELF</code>和<code class="fe mg mh mi lw b">nginx.ports</code>值，<code class="fe mg mh mi lw b">docker-compose-node2.yaml</code>也将端口更改为8081。</p><p id="a257" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">启动两个实例。当它们都运行时，您可以将其中一个连接到另一个:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi mm"><img src="../Images/9a03721951c8d848501fa9f5f04c02f2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*cYtAdSm0d5FjTRp_tNnfzw.png"/></div></div></figure><p id="1d8a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在，您可以创建事务和挖掘块，如前一篇文章中的<a class="ae ky" rel="noopener ugc nofollow" target="_blank" href="/the-blockchain-explained-with-a-java-implementation-27b74d478223">所示，但是您可以列出两个节点中的事务和块。对等协议确保两个节点拥有相同的数据。</a></p><p id="eaa8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在这一点上我不会说它是完美的。有许多不同的序列需要测试，以确保无论事情如何完成，不同实例中的区块链保持不变。但是这篇文章已经够长了，我敢肯定你不想看到我调试这个网站！</p><p id="b806" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">感谢你阅读这篇相当长的文章，我已经试图压缩它，使它尽可能简洁，但它是一个非常复杂的主题。</p><p id="41a9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我认为本系列的下一篇文章会简单一点。我们将讨论谜题的最后一部分:矿工和使用者。</p><p id="9a18" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">本文的所有代码都可以在这里找到:</p><div class="mn mo gp gr mp mq"><a href="https://github.com/rkamradt/blockchain/tree/v0.2" rel="noopener  ugc nofollow" target="_blank"><div class="mr ab fo"><div class="ms ab mt cl cj mu"><h2 class="bd iu gy z fp mv fr fs mw fu fw is bi translated">rkamradt/区块链</h2><div class="mx l"><h3 class="bd b gy z fp mv fr fs mw fu fw dk translated">yabc。在GitHub上创建一个帐户，为rkamradt/区块链的发展做出贡献。</h3></div><div class="my l"><p class="bd b dl z fp mv fr fs mw fu fw dk translated">github.com</p></div></div><div class="mz l"><div class="na l nb nc nd mz ne ks mq"/></div></div></a></div><p id="88d6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">本系列的前一篇文章:</p><div class="mn mo gp gr mp mq"><a rel="noopener  ugc nofollow" target="_blank" href="/the-blockchain-explained-with-a-java-implementation-27b74d478223"><div class="mr ab fo"><div class="ms ab mt cl cj mu"><h2 class="bd iu gy z fp mv fr fs mw fu fw is bi translated">如果你想了解区块链，请看这个Java实现</h2><div class="mx l"><h3 class="bd b gy z fp mv fr fs mw fu fw dk translated">解放区块链</h3></div><div class="my l"><p class="bd b dl z fp mv fr fs mw fu fw dk translated">better编程. pub</p></div></div><div class="mz l"><div class="nf l nb nc nd mz ne ks mq"/></div></div></a></div></div></div>    
</body>
</html>