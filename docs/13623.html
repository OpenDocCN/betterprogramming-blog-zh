<html>
<head>
<title>Using Heaps to Speed Up Code Performance in Go</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">在Go中使用堆来提高代码性能</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/using-heaps-to-speed-up-code-performance-in-go-b17ab07d2d5f?source=collection_archive---------18-----------------------#2022-09-12">https://betterprogramming.pub/using-heaps-to-speed-up-code-performance-in-go-b17ab07d2d5f?source=collection_archive---------18-----------------------#2022-09-12</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="87d5" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">快速示例引导介绍</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/b433b8bf27cf6a2c3d5c8b1451f9fb8c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*lVFrDfQZbVnJ9Fln"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">照片由<a class="ae kv" href="https://unsplash.com/@cant89?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">大卫·坎特利</a>在<a class="ae kv" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</p></figure><p id="67fc" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">二进制堆是一种特殊的基于树的数据结构，在某些情况下被证明是有用的，比如使用一组数字中的最低/最高值进行重复计算。在本文中，我们将通过一个(我希望)易于理解的例子来更深入地了解堆。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi ls"><img src="../Images/cecea0a8f8f3623ce635a88a8c20b836.png" data-original-src="https://miro.medium.com/v2/resize:fit:1000/format:webp/1*scf2_Nb98AZ5iEJ5RzDstA.jpeg"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">最小二进制堆示例。每个节点的值应该低于其子节点的值。</p></figure><h1 id="16b9" class="lt lu iq bd lv lw lx ly lz ma mb mc md jw me jx mf jz mg ka mh kc mi kd mj mk bi translated">背景故事</h1><p id="7d67" class="pw-post-body-paragraph kw kx iq ky b kz ml jr lb lc mm ju le lf mn lh li lj mo ll lm ln mp lp lq lr ij bi translated">我经常尝试解决一些编程练习，以保持我的编程技能，并学习可以添加到我的开发人员工具包中的新东西。几周前，我发现<a class="ae kv" href="https://www.hackerrank.com/challenges/jesse-and-cookies/problem" rel="noopener ugc nofollow" target="_blank">这个有趣的挑战</a>是在HackerRank平台上提出的。这个问题，简单地描述没有隐喻，可以陈述如下:</p><blockquote class="mq mr ms"><p id="6a36" class="kw kx mt ky b kz la jr lb lc ld ju le mu lg lh li mv lk ll lm mw lo lp lq lr ij bi translated">给定一个由<code class="fe mx my mz na b"><em class="iq">N</em></code>个整数组成的集合和一个整数<code class="fe mx my mz na b"><em class="iq">K</em></code>，计算直到集合中的每个整数都≥ K需要执行的迭代次数，在每次迭代中，集合由于应用以下运算而收缩:取两个最低的整数，计算它们的替换为<code class="fe mx my mz na b"><em class="iq">minInteger + 2*secondMinInteger</em></code>。如果条件永远不能满足，那么结果应该是<code class="fe mx my mz na b"><em class="iq">-1</em></code>。</p></blockquote><p id="946a" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我尝试了第一种定制方法，它似乎工作正常，但是由于性能问题而失败了。通常，该平台提出的测试用例不仅检查您的代码是否适用于特定的输入集，还确保它在提供大量输入时满足特定的执行时间限制。我的解决方案对所有的情况都是正确的，但是花了很长时间来完成其中的一些。</p><p id="ebab" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我在我的解决方案中尝试了一些自定义优化，得到了一个可接受的最终版本，但也不起作用。放弃后，我去了评论区，发现大多数dev都建议使用堆数据结构。我采用了堆方法并进行了尝试，100%成功地通过了所有的测试用例。不满足于此，我研究了为什么基于堆的方法如此优越。</p><p id="e716" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在整篇文章中，我将分享我的方法和基于堆的方法，比较它们以突出性能差异，并展示一些我自己做的帮助我理解堆的力量的实验。</p><h1 id="6e2c" class="lt lu iq bd lv lw lx ly lz ma mb mc md jw me jx mf jz mg ka mh kc mi kd mj mk bi translated">第一种方法:没有堆的定制解决方案</h1><p id="9c9e" class="pw-post-body-paragraph kw kx iq ky b kz ml jr lb lc mm ju le lf mn lh li lj mo ll lm ln mp lp lq lr ij bi translated">在这里，我分享了我第一个不使用堆的解决方案。我写的算法差不多是这样的:</p><ol class=""><li id="369d" class="nb nc iq ky b kz la lc ld lf nd lj ne ln nf lr ng nh ni nj bi translated">按升序对所有整数进行排序</li><li id="0b42" class="nb nc iq ky b kz nk lc nl lf nm lj nn ln no lr ng nh ni nj bi translated">取出最低和第二低的整数，计算新的整数</li><li id="fe08" class="nb nc iq ky b kz nk lc nl lf nm lj nn ln no lr ng nh ni nj bi translated">在集合中找到最适合插入新整数的位置(记住它已经排序了)，然后插入</li><li id="3a85" class="nb nc iq ky b kz nk lc nl lf nm lj nn ln no lr ng nh ni nj bi translated">从2到3重复，直到集合中的第一个整数≥ <em class="mt"> K </em>(这意味着所有项目都满足这个条件，因为它总是被排序)</li></ol><p id="3408" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我在Go编程语言中的实现如下:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="np nq l"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">没有堆的定制解决方案方法</p></figure><h1 id="4474" class="lt lu iq bd lv lw lx ly lz ma mb mc md jw me jx mf jz mg ka mh kc mi kd mj mk bi translated">使用最小堆是更好的解决方案</h1><p id="7965" class="pw-post-body-paragraph kw kx iq ky b kz ml jr lb lc mm ju le lf mn lh li lj mo ll lm ln mp lp lq lr ij bi translated">首先，如果您不熟悉术语堆或二进制堆，这里的<a class="ae kv" href="https://www.geeksforgeeks.org/heap-data-structure/" rel="noopener ugc nofollow" target="_blank">是一个简单的资源，您可以在同一个页面上查看所有内容。现在，通过使用堆，算法变得更加简单:</a></p><ol class=""><li id="cc87" class="nb nc iq ky b kz la lc ld lf nd lj ne ln nf lr ng nh ni nj bi translated">初始化堆</li><li id="b076" class="nb nc iq ky b kz nk lc nl lf nm lj nn ln no lr ng nh ni nj bi translated">从堆中取出最低和第二低的整数，然后将新的整数压入堆中</li><li id="1aaa" class="nb nc iq ky b kz nk lc nl lf nm lj nn ln no lr ng nh ni nj bi translated">重复步骤2，直到最小整数≥ <em class="mt"> K </em></li></ol><p id="84ea" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">同样，这是我为此编写的Go代码:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="np nq l"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">基于堆的问题解决方案</p></figure><p id="02ac" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这段代码使用了<code class="fe mx my mz na b">pro_heap.MinHeap</code>数据类型，这是Go中的一个<code class="fe mx my mz na b">heap.Interface</code>实现，定义如下:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="np nq l"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">围棋堆。Go的堆包函数所需的接口实现</p></figure><h1 id="cc30" class="lt lu iq bd lv lw lx ly lz ma mb mc md jw me jx mf jz mg ka mh kc mi kd mj mk bi translated">算法比较:时间复杂度和执行结果</h1><p id="ceeb" class="pw-post-body-paragraph kw kx iq ky b kz ml jr lb lc mm ju le lf mn lh li lj mo ll lm ln mp lp lq lr ij bi translated">为了检查为什么基于堆的解决方案似乎比我的快得多，我做了一些性能实验来比较两者。</p><h2 id="76f6" class="nr lu iq bd lv ns nt dn lz nu nv dp md lf nw nx mf lj ny nz mh ln oa ob mj oc bi translated">实验时间！</h2><p id="018c" class="pw-post-body-paragraph kw kx iq ky b kz ml jr lb lc mm ju le lf mn lh li lj mo ll lm ln mp lp lq lr ij bi translated">首先，我生成了一堆样本(这里是整数集合)，作为每个算法的输入。我尝试了不同的<code class="fe mx my mz na b">N</code>值(这里是整数集合的大小)，包括1k、10k、100k和1M，但是使用了相同的<code class="fe mx my mz na b">K</code>值700。属于集合的每个整数都是在(0，1000)范围内随机生成的数字。</p><p id="2673" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">创建示例后，我对每个版本的解决方案运行了五次，并记录了它的总执行时间。以下是我得到的结果:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="np nq l"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">算法执行时间比较</p></figure><p id="7420" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">如您所见，集合越大，我们的执行时间就越长，两种解决方案之间的执行时间差就越大。但是是什么造成了如此显著的差异呢？</p><h1 id="6161" class="lt lu iq bd lv lw lx ly lz ma mb mc md jw me jx mf jz mg ka mh kc mi kd mj mk bi translated">基于堆的方法:低级分析</h1><p id="c933" class="pw-post-body-paragraph kw kx iq ky b kz ml jr lb lc mm ju le lf mn lh li lj mo ll lm ln mp lp lq lr ij bi translated">我在上面分享的片段显示了两种方法的时间复杂度计算，在每一行相关的代码上都使用了big-O符号。因此，您可以看到我的定制解决方案的时间复杂度为O(n)，而基于堆的解决方案的时间复杂度为O(n)。</p><p id="517d" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">更何况O(n)的时间复杂度大多由堆初始化指令决定:<code class="fe mx my mz na b">heap.Init(h)</code>。O(n)来自堆包文档，但我很确定在幕后，它是一个完全优化的函数，很难达到O(n)行为。此外，查看实验样本，每个整数都在(0，1000)范围内，所以当<code class="fe mx my mz na b">N ≥ 1000</code>时，我们将有重复的值。</p><p id="129f" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">当然，Go在其堆函数中实现了某些优化，以高效地处理重复值的集合，正如它在<code class="fe mx my mz na b">sort.Slice</code>函数中通过<a class="ae kv" href="https://itnext.io/gos-new-sorting-algorithm-pdqsort-822053d7801b" rel="noopener ugc nofollow" target="_blank"> pdqsort </a>策略所做的那样。</p><p id="eb6b" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">如果忽略<code class="fe mx my mz na b">heap.Init(h)</code>语句，我们看到基于堆的算法的时间复杂度变成O(log n)，比O(n)快很多。这与堆如何工作以及如何使用普通数组实现它们有很大关系。让我们来看看下图:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi od"><img src="../Images/777547fa2dea979101e0596b7ae68895.png" data-original-src="https://miro.medium.com/v2/resize:fit:938/1*USy0js5aw7q3OpnCdLDOnQ.gif"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">因为有一个公式可以很容易地确定每个节点的父节点、左子节点和右子节点，所以堆可以在一个数组中表示，而不需要链表或指针。</p></figure><p id="a147" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">假设我们需要检索集合中最高的整数，我们知道在0索引中是一个直接访问操作。现在，假设我们需要将数字12添加到这个最大堆中。我们将开始向8追加一个孩子。然后我们会把8和12，9和12，最后是11和12对调。我们只需要三次比较和切换操作就可以添加新的条目。如果我们根据要在数组中遍历的索引来查看这些操作，我们会得到这样的结果:</p><pre class="kg kh ki kj gt oe na of og aw oh bi"><span id="d360" class="nr lu iq na b gy oi oj l ok ol">-&gt; Added new item in index 10 (added number 12 as child of 8)<br/>-&gt; Compare and switch with index 4 (switch 8 with 12)<br/>-&gt; Compare and switch with index 1(switch 9 with 12)<br/>-&gt; Compare and switch with index 0(switch 11 with 12)</span></pre><p id="39c3" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们从索引1到索引4跳过了两个索引，从索引4到索引10，我们跳过了五个索引。这就是堆的神奇之处:由于跳过索引进行比较和切换，遍历集合的速度总是快得多。此外，集合越大，要遍历的索引之间的间隔就越大。</p><h1 id="4b53" class="lt lu iq bd lv lw lx ly lz ma mb mc md jw me jx mf jz mg ka mh kc mi kd mj mk bi translated">最后的想法</h1><p id="3f6e" class="pw-post-body-paragraph kw kx iq ky b kz ml jr lb lc mm ju le lf mn lh li lj mo ll lm ln mp lp lq lr ij bi translated">毫无疑问，对于需要遍历集合的最高或最低值的特定场景，堆非常方便。然而，它们可能不适合许多其他人。始终要特别注意您的环境和需求，并问问自己，使用基于堆的方法是否更好。</p><p id="9ef2" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">Go的堆实现看起来更快，性能更好，但是对于其他技术和提供者来说可能不是这样。仔细浏览该库的文档，并做一些概念验证来评估它们的性能。</p><p id="5bb3" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">希望本文不仅让您对堆及其常见的用例场景有了一个很好的了解。我希望它也鼓励你学习和研究编程中存在的不同的数据结构，这些数据结构是为解决类似这样的特定问题而设计的。</p><p id="6a6a" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">数组和集合是好的，但是了解高级数据结构和它们的用法可以帮助你在工作中有所作为，并且肯定会改进你公司的产品。</p><p id="181d" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">目前就这些。非常感谢您的阅读。</p><p id="a2f6" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">保持联系，进行更多类似的实验！</p></div></div>    
</body>
</html>