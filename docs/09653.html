<html>
<head>
<title>A Complete Guide to Node.js Logging</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Node.js日志记录的完整指南</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/a-complete-guide-to-node-js-logging-1ba70a4a346d?source=collection_archive---------3-----------------------#2021-09-22">https://betterprogramming.pub/a-complete-guide-to-node-js-logging-1ba70a4a346d?source=collection_archive---------3-----------------------#2021-09-22</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="e164" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">记录日志的最佳实践</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/5c5fee8b6ed2a2de9784abb6031e42b0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*WCgPFlPc508Fr2eWh1Ancg.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">背景由<a class="ae ky" href="https://unsplash.com/@markusspiske?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">马库斯·斯皮斯克</a>于<a class="ae ky" href="https://unsplash.com/?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a> |作者创作</p></figure><p id="15f4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果我问你一个问题，哪个JavaScript函数对发现错误最有用，你明显的答案是<code class="fe lv lw lx ly b">console.log</code>。</p><p id="57eb" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在开发阶段，无论是日志记录还是调试，都很容易检测到错误。但是当涉及到生产时，您应该考虑更多关于日志记录的内容，因为它对于应用程序的监控和故障排除至关重要。</p><p id="f67c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">本文将通过解释核心概念和最佳实践，指导您实现完全灵活的日志框架。在进入实现之前，让我们从基础开始。</p><h1 id="d697" class="lz ma it bd mb mc md me mf mg mh mi mj jz mk ka ml kc mm kd mn kf mo kg mp mq bi translated">什么是日志记录，为什么它很重要？</h1><p id="7c28" class="pw-post-body-paragraph kz la it lb b lc mr ju le lf ms jx lh li mt lk ll lm mu lo lp lq mv ls lt lu im bi translated">日志记录是将应用程序活动生成的信息记录到日志文件中的过程。保存在日志文件中的记录称为日志。日志是保存应用程序信息的一种简单方式。</p><p id="cc28" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">对于程序员来说，日志是追踪错误和事件流的第一个地方，尤其是来自服务器的。</p><p id="a7c6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在开发过程中跟踪错误时，您通常会使用<code class="fe lv lw lx ly b">console.log</code>或运行调试器。</p><p id="0d1b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">但是当应用程序进入生产阶段，用户开始与之交互时，你就再也不能<code class="fe lv lw lx ly b">console.log</code>了。如果出现问题，应用程序崩溃，你不能用控制台检查。</p><p id="276b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这就是为什么我们需要一个简洁、干净、高质量的日志框架。</p><p id="8c11" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">相反，通过提供实时日志事件流，这些日志可用于实时诊断异常、恶意软件活动或未经授权的资源访问。这是对系统的额外保护。</p><p id="8b8c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">因此，最终，这些日志将使开发人员、开发人员、系统管理员或SecOps更容易获得洞察力，并确定应用程序和基础架构问题的根本原因。</p><h1 id="5b2f" class="lz ma it bd mb mc md me mf mg mh mi mj jz mk ka ml kc mm kd mn kf mo kg mp mq bi translated">日志记录级别</h1><p id="3283" class="pw-post-body-paragraph kz la it lb b lc mr ju le lf ms jx lh li mt lk ll lm mu lo lp lq mv ls lt lu im bi translated">这是任何日志系统中最重要的部分。日志级别是日志的元数据。该级别定义了记录事件的严重性。</p><p id="16a7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">将日志级别放在第一位的原因是为了让您可以快速看到哪些日志需要更多的关注。</p><p id="85b1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">日志记录有五个主要级别。根据优先级，它可以进行如下排序:</p><ul class=""><li id="0b2f" class="mx my it lb b lc ld lf lg li mz lm na lq nb lu nc nd ne nf bi translated"><code class="fe lv lw lx ly b">ERROR</code> <strong class="lb iu"> : </strong>处理当前操作时出现严重问题/故障。系统操作员应尽快处理此事。</li><li id="ed3a" class="mx my it lb b lc ng lf nh li ni lm nj lq nk lu nc nd ne nf bi translated"><code class="fe lv lw lx ly b">WARN</code> <strong class="lb iu"> : </strong>这些日志是警告，不会阻止应用程序继续运行，它们在检测到意外的应用程序问题时提供警报。对于管理员来说，检查以决定是否应该解决这个问题是很有用的。</li><li id="1522" class="mx my it lb b lc ng lf nh li ni lm nj lq nk lu nc nd ne nf bi translated"><code class="fe lv lw lx ly b">INFO</code> <strong class="lb iu"> : </strong>应用程序的正常行为，说明发生了什么。不一定要求你跟进。</li><li id="2202" class="mx my it lb b lc ng lf nh li ni lm nj lq nk lu nc nd ne nf bi translated"><code class="fe lv lw lx ly b">DEBUG</code> <strong class="lb iu"> : </strong>这个级别是给开发者的。它以详细的方式给出诊断信息。这用于获取诊断、故障排除或测试应用程序所需的信息。</li><li id="d6bc" class="mx my it lb b lc ng lf nh li ni lm nj lq nk lu nc nd ne nf bi translated"><code class="fe lv lw lx ly b">TRACE</code> <strong class="lb iu"> : </strong>这个级别捕获关于应用程序行为的所有细节。它主要用于跟踪应用程序逻辑的全部细节。</li></ul><p id="399e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu">注意</strong>:任何日志记录器的正常行为都是只跟踪当前级别和以上级别的日志。因此，如果您将日志级别设置为<code class="fe lv lw lx ly b">INFO</code>，您将只获得具有<code class="fe lv lw lx ly b">INFO</code>、<code class="fe lv lw lx ly b">WARN</code>和<code class="fe lv lw lx ly b">ERROR</code>级别的日志事件。</p><h1 id="8d3b" class="lz ma it bd mb mc md me mf mg mh mi mj jz mk ka ml kc mm kd mn kf mo kg mp mq bi translated">日志记录的最佳实践</h1><p id="ba6f" class="pw-post-body-paragraph kz la it lb b lc mr ju le lf ms jx lh li mt lk ll lm mu lo lp lq mv ls lt lu im bi translated">在实现日志记录系统之前，您一定要了解最佳实践，例如:</p><h2 id="fb7a" class="nl ma it bd mb nm nn dn mf no np dp mj li nq nr ml lm ns nt mn lq nu nv mp nw bi translated">1)日志记录应该有意义并且有目的</h2><p id="c3e6" class="pw-post-body-paragraph kz la it lb b lc mr ju le lf ms jx lh li mt lk ll lm mu lo lp lq mv ls lt lu im bi translated">不要添加不必要的日志，因为它们会很快变成噪音。此外，如果应用程序写日志的频率很高，它会直接影响应用程序的性能。</p><p id="2cf7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu">注意</strong>:除非代码库出现问题，否则我们不应在生产中启用<code class="fe lv lw lx ly b">DEBUG</code>或<code class="fe lv lw lx ly b">TRACE</code>级别。(解决问题后，确保将其切换回<code class="fe lv lw lx ly b">INFO</code>或<code class="fe lv lw lx ly b">ERROR</code>电平。<strong class="lb iu"> ) </strong></p><h2 id="c0db" class="nl ma it bd mb nm nn dn mf no np dp mj li nq nr ml lm ns nt mn lq nu nv mp nw bi translated">2.将日志分成几个日志文件，以防应用程序流量过大</h2><p id="9b08" class="pw-post-body-paragraph kz la it lb b lc mr ju le lf ms jx lh li mt lk ll lm mu lo lp lq mv ls lt lu im bi translated">在这种情况下，您的日志文件将会非常冗长，并且在分析时会遇到困难。您可以为不同的日志级别创建不同的日志文件，或者尝试使用大多数日志记录框架中都提供的滚动日志文件功能。</p><p id="1a10" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">它会根据时间或大小压缩你的日志文件。大多数企业级应用程序都使用这种每日滚动日志文件功能。</p><h2 id="4da1" class="nl ma it bd mb nm nn dn mf no np dp mj li nq nr ml lm ns nt mn lq nu nv mp nw bi translated">3.日志记录应该分层次进行</h2><p id="2428" class="pw-post-body-paragraph kz la it lb b lc mr ju le lf ms jx lh li mt lk ll lm mu lo lp lq mv ls lt lu im bi translated">正如我们在上面看到的，日志应该基于优先级来处理。这将有助于分析日志并在很短的时间内发现问题。</p><p id="1ac4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">此外，使用日志名称空间保持整洁。作为最佳实践，您应该在日志记录时添加时间戳。</p><h2 id="c008" class="nl ma it bd mb nm nn dn mf no np dp mj li nq nr ml lm ns nt mn lq nu nv mp nw bi translated">4.日志记录不应该导致错误或异常</h2><p id="a687" class="pw-post-body-paragraph kz la it lb b lc mr ju le lf ms jx lh li mt lk ll lm mu lo lp lq mv ls lt lu im bi translated">有时日志会导致严重的错误。请看这个例子。假设有一个定义为→ <code class="fe lv lw lx ly b">getUser(id)</code>的用户服务方法，如果我们想找到一个用户，我们需要传递他们的id。假设您希望在处理时记录用户名。</p><pre class="kj kk kl km gt nx ly ny nz aw oa bi"><span id="5092" class="nl ma it ly b gy ob oc l od oe">logger.info(`Processing user: ${userService.getUser().getName()}`);</span></pre><p id="e34a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果您忘记像这样传递id，<code class="fe lv lw lx ly b">getUser()</code>将返回null，<code class="fe lv lw lx ly b">getName()</code>将抛出一个异常。所以确保你不要犯这样愚蠢的错误。</p><h2 id="eaec" class="nl ma it bd mb nm nn dn mf no np dp mj li nq nr ml lm ns nt mn lq nu nv mp nw bi translated">5)记录器不应记录任何敏感信息</h2><p id="1b2c" class="pw-post-body-paragraph kz la it lb b lc mr ju le lf ms jx lh li mt lk ll lm mu lo lp lq mv ls lt lu im bi translated">在登录时，我们必须确保不记录任何敏感信息，如用户名和密码，金融信息，如卡号，CVV号码等。</p></div><div class="ab cl of og hx oh" role="separator"><span class="oi bw bk oj ok ol"/><span class="oi bw bk oj ok ol"/><span class="oi bw bk oj ok"/></div><div class="im in io ip iq"><p id="bdc7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">好吧！我相信现在你已经完全了解了日志记录时应该使用的实践。让我们深入研究一下实现。</p><p id="2d2d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们有哪些用于日志记录的库/框架？有许多库可以轻松地为您完成这项工作。</p><p id="77db" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">以下是NPM上最流行的Node.js日志库:</p><ul class=""><li id="e868" class="mx my it lb b lc ld lf lg li mz lm na lq nb lu nc nd ne nf bi translated">Winston——完全灵活的通用日志库。</li><li id="5733" class="mx my it lb b lc ng lf nh li ni lm nj lq nk lu nc nd ne nf bi translated">mor gan——HTTP请求记录器中间件。</li><li id="2ea7" class="mx my it lb b lc ng lf nh li ni lm nj lq nk lu nc nd ne nf bi translated">Pino —超快(开销非常低)，全天然JSON记录器。</li><li id="a328" class="mx my it lb b lc ng lf nh li ni lm nj lq nk lu nc nd ne nf bi translated"><code class="fe lv lw lx ly b">Loglevel</code> —用于JavaScript的最小轻量级简单日志记录。</li><li id="8a1b" class="mx my it lb b lc ng lf nh li ni lm nj lq nk lu nc nd ne nf bi translated"><code class="fe lv lw lx ly b">log4js</code>—一个没有运行时依赖的框架。</li></ul><p id="7b4f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在本文中，我们将使用Winston库。</p><h1 id="6ae7" class="lz ma it bd mb mc md me mf mg mh mi mj jz mk ka ml kc mm kd mn kf mo kg mp mq bi translated">为什么是温斯顿·洛奇？</h1><p id="df3f" class="pw-post-body-paragraph kz la it lb b lc mr ju le lf ms jx lh li mt lk ll lm mu lo lp lq mv ls lt lu im bi translated">Winston是Node.js最强大、最灵活的开源日志库之一。</p><p id="336f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这是一个非常直观的工具，易于定制。您可以通过修改几行代码来调整其背后的逻辑。它使得对数据库或文件等持久存储位置的日志记录变得更加容易和简单。</p><p id="3786" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们用NPM趋势来看看这个温斯顿图书馆的受欢迎程度。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi om"><img src="../Images/581103bf174cb8ca936c1bf5ec6d0bce.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*GuvnZTvzAN6CHNEJxXbNNA.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">来源:<a class="ae ky" href="https://www.npmtrends.com/log4js-vs-morgan-vs-pino-vs-winston" rel="noopener ugc nofollow" target="_blank">https://www . NPM trends . com/log4js-vs-mor gan-vs-Pino-vs-Winston</a></p></figure><p id="ef33" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">正如你从分析中看到的，你可能会意识到温斯顿的受欢迎程度。但是是什么原因让它获得了这么多的观众呢？</p><p id="aab1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">原因是→温斯顿提供如下:</p><ul class=""><li id="9c21" class="mx my it lb b lc ld lf lg li mz lm na lq nb lu nc nd ne nf bi translated">集中控制如何以及何时记录日志—在单一位置更改您的代码。</li><li id="bd84" class="mx my it lb b lc ng lf nh li ni lm nj lq nk lu nc nd ne nf bi translated">控制你的日志发送到哪里——保存你的日志到多个目的地(如AWS S3，Elasticsearch，MongoDB等。).</li><li id="9206" class="mx my it lb b lc ng lf nh li ni lm nj lq nk lu nc nd ne nf bi translated">自定义日志记录格式——以时间戳为前缀、丰富多彩的日志记录级别、JSON格式等等。</li></ul><p id="1ed7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">好吧！我们选择了一个最好的日志框架。现在让我们来实施这些事情。</p><h1 id="0caa" class="lz ma it bd mb mc md me mf mg mh mi mj jz mk ka ml kc mm kd mn kf mo kg mp mq bi translated">Node.js中的Winston实现</h1><p id="a72c" class="pw-post-body-paragraph kz la it lb b lc mr ju le lf ms jx lh li mt lk ll lm mu lo lp lq mv ls lt lu im bi translated">我制作了一个简单的REST服务器来演示日志场景。为了简单起见，它目前只有两个API。文件夹结构如下所示:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi on"><img src="../Images/21f2e2ed1aa9e71cae0da21d43d2ddfb.png" data-original-src="https://miro.medium.com/v2/resize:fit:582/format:webp/1*Nt7wm1WWvCPknhwkqPQQpA.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">项目结构(图片由作者提供)</p></figure><ul class=""><li id="5af7" class="mx my it lb b lc ld lf lg li mz lm na lq nb lu nc nd ne nf bi translated"><code class="fe lv lw lx ly b">app.js </code> —主入口</li><li id="38a1" class="mx my it lb b lc ng lf nh li ni lm nj lq nk lu nc nd ne nf bi translated"><code class="fe lv lw lx ly b">routes</code> —处理路由</li><li id="a17f" class="mx my it lb b lc ng lf nh li ni lm nj lq nk lu nc nd ne nf bi translated"><code class="fe lv lw lx ly b">middleware</code> —处理认证</li><li id="c9de" class="mx my it lb b lc ng lf nh li ni lm nj lq nk lu nc nd ne nf bi translated"><code class="fe lv lw lx ly b">controllers</code> —处理REST API请求</li><li id="3a25" class="mx my it lb b lc ng lf nh li ni lm nj lq nk lu nc nd ne nf bi translated"><code class="fe lv lw lx ly b">logs</code> —存储日志文件</li><li id="e593" class="mx my it lb b lc ng lf nh li ni lm nj lq nk lu nc nd ne nf bi translated"><code class="fe lv lw lx ly b">utils</code>—实现记录器</li></ul><p id="6047" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">首先，我们需要使用以下命令添加Winston日志库:</p><pre class="kj kk kl km gt nx ly ny nz aw oa bi"><span id="da02" class="nl ma it ly b gy ob oc l od oe">npm i winston</span></pre><p id="741c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">任何使用<code class="fe lv lw lx ly b">yarn</code>的人都可以在<code class="fe lv lw lx ly b">yarn add winston</code>之前安装它，然后我们需要初始化记录器。为此，我已经在<code class="fe lv lw lx ly b">utils</code>中创建了一个名为<code class="fe lv lw lx ly b">logger.js </code>的文件，让我们看看它是如何用下面的代码初始化的:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oo op l"/></div></figure><p id="d7e9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们可以通过调用Winston库中的<code class="fe lv lw lx ly b">createLogger</code>函数来初始化logger。然后我们必须定义传输。这些<strong class="lb iu"> </strong>运输工具是什么？</p><p id="d090" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><em class="mw">日志需要放在某个地方。传输是保存日志的地方。</em></p><p id="b747" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">有30多个传输选项，包括退出到一个文件、控制台或第三方系统，如AWS的S3、Elasticsearch、MongoDB等等。<strong class="lb iu"> </strong>您可以向<code class="fe lv lw lx ly b">transports:</code>阵列添加任意数量的运输工具。</p><p id="74ad" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果你想了解更多关于这些交通工具的信息，你可以访问这个官方的Winston GitHub页面。</p><div class="oq or gp gr os ot"><a href="https://github.com/winstonjs/winston/blob/master/docs/transports.md" rel="noopener  ugc nofollow" target="_blank"><div class="ou ab fo"><div class="ov ab ow cl cj ox"><h2 class="bd iu gy z fp oy fr fs oz fu fw is bi translated">Winston js/Winston master上的winston/transports.md</h2><div class="pa l"><h3 class="bd b gy z fp oy fr fs oz fu fw dk translated">在winston中，传输本质上是日志的存储设备。winston记录器的每个实例都可以有…</h3></div><div class="pb l"><p class="bd b dl z fp oy fr fs oz fu fw dk translated">github.com</p></div></div><div class="pc l"><div class="pd l pe pf pg pc ph ks ot"/></div></div></a></div><p id="fda1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在transporter对象中，我们可以给出一个文件名来存储我们的日志。接下来是有趣的部分。我们可以根据需要设置日志消息的格式。</p><p id="7a18" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">默认情况下，日志记录没有被格式化，而是打印为带有两个参数的JSON字符串，即日志消息和级别。</p><p id="1009" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">然而，覆盖它并添加诸如预定义标记、时间戳、颜色等参数。如上所示，非常简单。</p><p id="0eba" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">好吧！现在我们可以将记录器添加到我们的函数中。让我们在服务器启动时添加一个日志记录器。首先，我们需要导入记录器，然后我们可以调用它的功能。</p><pre class="kj kk kl km gt nx ly ny nz aw oa bi"><span id="573b" class="nl ma it ly b gy ob oc l od oe">const logger = require("./utils/logger");</span><span id="7ca7" class="nl ma it ly b gy pi oc l od oe">app.listen(port, () =&gt; {<br/>  logger.info(`Server Started in port : ${port}!`);<br/>});</span></pre><p id="9896" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">看看这有多简单。我们可以在<code class="fe lv lw lx ly b">logs/server.log</code>文件中看到如下输出。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi pj"><img src="../Images/7e94437834114caf85f34166ae729b4d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*uqp_YQzD-niP7nUZY7BvEg.png"/></div></div></figure><p id="12b6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们还可以更改日志级别。让我们看看它是如何工作的。我将这个日志记录器添加到我的身份验证处理程序中。</p><pre class="kj kk kl km gt nx ly ny nz aw oa bi"><span id="2c3f" class="nl ma it ly b gy ob oc l od oe">if (!req.get("Authorization")) {<br/>    logger.error("Not Authenticated!");<br/>    return res.status(401).json({ message: "User Not Authenticated!" });</span></pre><p id="b3e8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">然后我们可以尝试在没有授权头的情况下触发这个API，然后您可以在日志文件中看到错误日志。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi pk"><img src="../Images/f184cf91914ac852a1d57fa38558e5df.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*DOl2t0QaH1DxvUYyic5Dcw.png"/></div></div></figure><p id="f359" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这些API端点在我的自述文件中有明确的定义。你可以试试。在参考资料部分可以看到完整代码实现的链接。</p><p id="8604" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu">注意</strong>:这仅用于演示目的。正如我前面提到的，日志应该是有意义的，也不应该到处使用，因为在添加这些日志时会有性能开销。</p><h1 id="c1d2" class="lz ma it bd mb mc md me mf mg mh mi mj jz mk ka ml kc mm kd mn kf mo kg mp mq bi translated">多重运输</h1><p id="0dc5" class="pw-post-body-paragraph kz la it lb b lc mr ju le lf ms jx lh li mt lk ll lm mu lo lp lq mv ls lt lu im bi translated">我们可以有多种运输方式。将<code class="fe lv lw lx ly b">logger.js</code>中的<code class="fe lv lw lx ly b">createLogger</code>功能更改如下:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oo op l"/></div></figure><p id="6440" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在日志文件夹中，您会看到在运行服务器后创建了新文件。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi pl"><img src="../Images/5b2e50af01571a250a205ef0efa13865.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*AVMqG3CTMp-P9QTB7mSODw.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">作者图片</p></figure><p id="cc18" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu">注意</strong> : Winston还没有开发出将传输限制在一个级别的功能。因此，我们需要实现自定义逻辑来做到这一点。您可以通过此链接探索更多可能的解决方案。</p><div class="oq or gp gr os ot"><a href="https://github.com/winstonjs/winston/issues/614" rel="noopener  ugc nofollow" target="_blank"><div class="ou ab fo"><div class="ov ab ow cl cj ox"><h2 class="bd iu gy z fp oy fr fs oz fu fw is bi translated">Winston记录所有文件。(或者:将运输限制在一层)问题#614 …</h2><div class="pa l"><h3 class="bd b gy z fp oy fr fs oz fu fw dk translated">此时您不能执行该操作。您已使用另一个标签页或窗口登录。您已在另一个选项卡中注销，或者…</h3></div><div class="pb l"><p class="bd b dl z fp oy fr fs oz fu fw dk translated">github.com</p></div></div><div class="pc l"><div class="pm l pe pf pg pc ph ks ot"/></div></div></a></div><h1 id="2d8b" class="lz ma it bd mb mc md me mf mg mh mi mj jz mk ka ml kc mm kd mn kf mo kg mp mq bi translated">多个记录器</h1><p id="b1b9" class="pw-post-body-paragraph kz la it lb b lc mr ju le lf ms jx lh li mt lk ll lm mu lo lp lq mv ls lt lu im bi translated">Winston允许您创建自定义记录器。这使您能够根据您的应用程序服务来控制和定制特定的记录器。</p><p id="5b79" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">例如，对于用户服务和身份验证服务，我们可以有两个单独的记录器。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oo op l"/></div></figure><p id="e92e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在，我们可以在任何地方访问特定的日志表单，并添加日志。</p><p id="86c6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在用户服务中，我们可以使用以下代码:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oo op l"/></div></figure><p id="0f28" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在认证服务中，将使用此代码:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oo op l"/></div></figure><p id="fded" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如你所见，我们的日志将被分开显示。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi pn"><img src="../Images/9745e504f427a6a47e8534162ae11c5c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*XHvjz3-XM0w97V9XDpZaTA.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">作者图片</p></figure><p id="eddd" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这使得管理日志变得更加容易，因为针对特定问题有单独的日志，并且提供了用户和事务属性来帮助将日志范围缩小到特定用户或事务。</p><h1 id="355c" class="lz ma it bd mb mc md me mf mg mh mi mj jz mk ka ml kc mm kd mn kf mo kg mp mq bi translated">每日滚动日志文件</h1><p id="05b3" class="pw-post-body-paragraph kz la it lb b lc mr ju le lf ms jx lh li mt lk ll lm mu lo lp lq mv ls lt lu im bi translated">正如我在最佳实践中提到的，这个特性允许根据条件轮换日志文件。</p><p id="1930" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">日志可以根据日期、大小限制进行轮换，旧日志可以根据计数或经过的天数进行删除。</p><p id="f1ee" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">但是为此，您需要有一个额外的Winston库。</p><pre class="kj kk kl km gt nx ly ny nz aw oa bi"><span id="0a97" class="nl ma it ly b gy ob oc l od oe">npm install winston-daily-rotate-file</span></pre><p id="a07e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在我们可以用下面的代码将新的运输工具添加到<code class="fe lv lw lx ly b">logger.js</code>文件中:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oo op l"/></div></figure><p id="1c99" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在这段代码中，我们说我们希望我们的日志每天都被推出。我们也定义了，</p><ul class=""><li id="b071" class="mx my it lb b lc ld lf lg li mz lm na lq nb lu nc nd ne nf bi translated"><code class="fe lv lw lx ly b">maxSize</code>:文件的最大尺寸，超过该尺寸后文件将旋转。这可以是字节数，也可以是KB、MB和GB为单位。如果使用单位，添加“k”、“m”或“g”作为后缀。</li><li id="0580" class="mx my it lb b lc ng lf nh li ni lm nj lq nk lu nc nd ne nf bi translated"><code class="fe lv lw lx ly b">maxFiles</code>:保存日志的最大文件数/天数。过了这段时间后，最旧的日志文件将被删除。这可以是许多文件或许多天。如果使用天数，添加“d”作为后缀。</li></ul><p id="5d8d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">你会在第二天看到，日志会被写到另一个文件中。如果日志文件大小超过定义的限制，将会实现您的日志。此外，旧日志将在您定义的日期周期后自动删除。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi po"><img src="../Images/c533a699b072f0bd94526795f438f136.png" data-original-src="https://miro.medium.com/v2/resize:fit:1154/format:webp/1*g7nOr1TDVjCugDLqy_jOYQ.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">每日滚动日志文件(图片由作者提供)</p></figure><p id="7900" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">本教程到此为止。我希望我已经涵盖了日志记录中最重要的领域。</p><h1 id="f71a" class="lz ma it bd mb mc md me mf mg mh mi mj jz mk ka ml kc mm kd mn kf mo kg mp mq bi translated">结论</h1><p id="b90e" class="pw-post-body-paragraph kz la it lb b lc mr ju le lf ms jx lh li mt lk ll lm mu lo lp lq mv ls lt lu im bi translated">在您的应用程序中设置一个适当的日志系统将是一个很好的救星，所以要明智地使用它。</p><p id="b25d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">简单回顾一下，我们了解到:</p><ul class=""><li id="5955" class="mx my it lb b lc ld lf lg li mz lm na lq nb lu nc nd ne nf bi translated">什么是日志记录，为什么它很重要？</li><li id="4961" class="mx my it lb b lc ng lf nh li ni lm nj lq nk lu nc nd ne nf bi translated">什么是日志记录级别？</li><li id="cedf" class="mx my it lb b lc ng lf nh li ni lm nj lq nk lu nc nd ne nf bi translated">日志记录的最佳实践</li><li id="8e85" class="mx my it lb b lc ng lf nh li ni lm nj lq nk lu nc nd ne nf bi translated">Winston日志框架</li><li id="840b" class="mx my it lb b lc ng lf nh li ni lm nj lq nk lu nc nd ne nf bi translated">用node.js实现</li><li id="8d7f" class="mx my it lb b lc ng lf nh li ni lm nj lq nk lu nc nd ne nf bi translated">温斯顿的更多功能</li></ul><p id="c52c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在，您完全可以在下一个应用程序中实现日志记录了。</p><p id="7dee" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">感谢阅读。伐木快乐！</p><h1 id="9939" class="lz ma it bd mb mc md me mf mg mh mi mj jz mk ka ml kc mm kd mn kf mo kg mp mq bi translated">资源</h1><ul class=""><li id="578e" class="mx my it lb b lc mr lf ms li pp lm pq lq pr lu nc nd ne nf bi translated"><a class="ae ky" href="https://github.com/Yasas4D/logger-demo" rel="noopener ugc nofollow" target="_blank">完整代码实现</a></li><li id="2a18" class="mx my it lb b lc ng lf nh li ni lm nj lq nk lu nc nd ne nf bi translated"><a class="ae ky" href="https://github.com/winstonjs/winston" rel="noopener ugc nofollow" target="_blank">温斯顿图书馆</a>和<a class="ae ky" href="https://github.com/winstonjs/winston-daily-rotate-file" rel="noopener ugc nofollow" target="_blank">每日轮换文件图书馆</a></li></ul></div></div>    
</body>
</html>