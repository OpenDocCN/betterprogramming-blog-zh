<html>
<head>
<title>Everything You Need to Know About React Component Lifecycles</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">关于React组件生命周期，您需要了解的一切</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/everything-you-need-to-know-about-react-component-life-cycle-e04fbd4811f4?source=collection_archive---------13-----------------------#2021-03-01">https://betterprogramming.pub/everything-you-need-to-know-about-react-component-life-cycle-e04fbd4811f4?source=collection_archive---------13-----------------------#2021-03-01</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="d8e9" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">理解React组件生命周期方法的工作原理</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/8b17f267988b7109ec154456c2c58b4f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*T1msy3FcnhonzVsBoNWAOw.jpeg"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated"><a class="ae kv" href="https://unsplash.com/@filmprint?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">梁金生</a>在<a class="ae kv" href="https://unsplash.com/s/photos/carnival?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的照片</p></figure><p id="f2bb" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们都知道，这个世界上存在的一切都有其生命周期。作为人类，我们出生，成长，最后死亡。类似地，React组件被初始化、更新，然后消亡。这个过程被称为React组件生命周期。每个组件都有一个周期，从生成并安装到DOM到卸载并销毁。</p><p id="c100" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">React提供了在生命周期的每个阶段自动调用的<em class="ls">钩子和</em>方法。它们提供了对被调用阶段发生的事情的控制。对这些钩子的强烈意识将会给我们自由，在组件的整个生命周期中轻松地操纵组件中发生的事情。</p><p id="b61a" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">组件的生命周期通常分为三个部分:</p><pre class="kg kh ki kj gt lt lu lv lw aw lx bi"><span id="a788" class="ly lz iq lu b gy ma mb l mc md">1. <a class="ae kv" href="#ca2e" rel="noopener ugc nofollow">Mounting Phase</a><br/>2. <a class="ae kv" href="#46f0" rel="noopener ugc nofollow">Updating Update</a><br/>3. <a class="ae kv" href="#c05a" rel="noopener ugc nofollow">Unmounting Phase</a></span></pre><p id="9d88" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">让我们来探索在这些不同阶段适用的各种生命周期方法。</p></div><div class="ab cl me mf hu mg" role="separator"><span class="mh bw bk mi mj mk"/><span class="mh bw bk mi mj mk"/><span class="mh bw bk mi mj"/></div><div class="ij ik il im in"><h1 id="ca2e" class="ml lz iq bd mm mn mo mp mq mr ms mt mu jw mv jx mw jz mx ka my kc mz kd na nb bi translated">安装阶段</h1><p id="5707" class="pw-post-body-paragraph kw kx iq ky b kz nc jr lb lc nd ju le lf ne lh li lj nf ll lm ln ng lp lq lr ij bi translated">当一个组件被创建在一个初始化了属性和状态的构造函数中时，它就被挂载了。这是它第一次被放入DOM的时候，也就是第一次被渲染的时候。在此阶段，这些方法应适用于:</p><ul class=""><li id="bdb8" class="nh ni iq ky b kz la lc ld lf nj lj nk ln nl lr nm nn no np bi translated"><code class="fe nq nr ns lu b">constructor()</code></li><li id="21a0" class="nh ni iq ky b kz nt lc nu lf nv lj nw ln nx lr nm nn no np bi translated"><code class="fe nq nr ns lu b">getDerivedStateFromProps()</code></li><li id="e1ef" class="nh ni iq ky b kz nt lc nu lf nv lj nw ln nx lr nm nn no np bi translated"><code class="fe nq nr ns lu b">componentWillMount()</code></li><li id="2b15" class="nh ni iq ky b kz nt lc nu lf nv lj nw ln nx lr nm nn no np bi translated"><code class="fe nq nr ns lu b">render()</code></li><li id="18d9" class="nh ni iq ky b kz nt lc nu lf nv lj nw ln nx lr nm nn no np bi translated"><code class="fe nq nr ns lu b">componentDidMount()</code></li></ul><h2 id="ff44" class="ly lz iq bd mm ny nz dn mq oa ob dp mu lf oc od mw lj oe of my ln og oh na oi bi translated">构造函数()</h2><p id="66f8" class="pw-post-body-paragraph kw kx iq ky b kz nc jr lb lc nd ju le lf ne lh li lj nf ll lm ln ng lp lq lr ij bi translated">这是每个项目命名的第一个方法。初始化属性和状态是构造函数的主要目标。</p><p id="3e7d" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">此外，它还将事件链接到<code class="fe nq nr ns lu b">this</code>。对<code class="fe nq nr ns lu b">super()</code>的调用与<code class="fe nq nr ns lu b">this.state</code>的初始化一起包含在构造函数中。需要记住的另一点是，状态初始化也可以在没有<code class="fe nq nr ns lu b">constructor()</code>的情况下执行，其行为是相同的。</p><pre class="kg kh ki kj gt lt lu lv lw aw lx bi"><span id="f51a" class="ly lz iq lu b gy ma mb l mc md">import React from ‘react’; </span><span id="6b95" class="ly lz iq lu b gy oj mb l mc md">class FriendsComponent extends React.Component {<br/> constructor(props) {<br/>    super(props);<br/>    this.state = {<br/>    title : ‘F.R.I.E.N.D.S’<br/>   }<br/>    console.log(‘Saying Hi from the Constructor’);<br/>  }<br/>}</span></pre><h2 id="bda1" class="ly lz iq bd mm ny nz dn mq oa ob dp mu lf oc od mw lj oe of my ln og oh na oi bi translated">getDerivedStateFromProps()方法</h2><p id="6632" class="pw-post-body-paragraph kw kx iq ky b kz nc jr lb lc nd ju le lf ne lh li lj nf ll lm ln ng lp lq lr ij bi translated">在DOM上呈现组件之前，调用<code class="fe nq nr ns lu b">GetDerivedStateFromProps</code>方法。当组件的状态依赖于道具时，调用此方法。通常，当道具发生变化时，这种方法可以使组件调整其状态。</p><p id="dbbf" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这种方法很少使用，但是执行的顺序是非常重要的，因为这个方法在挂载阶段和更新阶段都被命名。</p><p id="1238" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">继续上面的代码片段:</p><pre class="kg kh ki kj gt lt lu lv lw aw lx bi"><span id="c212" class="ly lz iq lu b gy ma mb l mc md">import React from ‘react’;</span><span id="3e49" class="ly lz iq lu b gy oj mb l mc md">class FriendsComponent extends React.Component {<br/> constructor(props) {<br/>   super(props);<br/>   this.state = {<br/>   title : ‘F.R.I.E.N.D.S.’<br/>  }<br/>   console.log(‘Saying Hi from the Constructor’);<br/> } </span><span id="62a6" class="ly lz iq lu b gy oj mb l mc md">static getDerivedStateFromProps(props, state) {<br/>   console.log(‘Saying Hi in the React Component<br/>   getDerivedStateFromProps’);<br/>  }<br/>}</span></pre><h2 id="dd29" class="ly lz iq bd mm ny nz dn mq oa ob dp mu lf oc od mw lj oe of my ln og oh na oi bi translated">componentWillMount()方法</h2><p id="cd36" class="pw-post-body-paragraph kw kx iq ky b kz nc jr lb lc nd ju le lf ne lh li lj nf ll lm ln ng lp lq lr ij bi translated">在组件挂载或调用<code class="fe nq nr ns lu b">render()</code> <strong class="ky ir"> </strong>方法之前，会调用<code class="fe nq nr ns lu b">componentWillMount()</code>方法。事实是，在React应用程序中，您几乎无法使用这种方法。让我告诉你为什么。</p><p id="1895" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><code class="fe nq nr ns lu b">componentWillMount()</code>位于构造函数和<code class="fe nq nr ns lu b">render()</code>之间，这使它处于一个相当奇怪的位置。对于组件，它可以用来设置默认配置，因为它在render方法之前，但这通常是使用构造函数来完成的。虽然这两种方法之间没有什么不同，但是不需要再次建立配置。</p><p id="f65c" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">现在，您可能会认为这是进行客户端呈现API调用的最佳位置，但是不能在这里进行。</p><p id="f632" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">API调用是异步的，在<code class="fe nq nr ns lu b">render()</code>被调用之前，数据可能还没有被返回。所以对于DOM(也就是用API响应更新数据)，什么都不能做，因为它还没有被挂载。这意味着组件至少可以用空数据呈现一次。</p><p id="c779" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">使用这种方法的一个好方法是执行任何可以在运行时完成的设置，比如连接到像Firebase这样的外部API。与根组件一样，这种配置通常可以在组件的顶层执行，因此大多数组件可能不会使用这种方法。</p><pre class="kg kh ki kj gt lt lu lv lw aw lx bi"><span id="dba7" class="ly lz iq lu b gy ma mb l mc md">class FriendsComponent extends React.Component {<br/> componentWillMount() {<br/>   console.log(‘Hello I am Chandler Bing’);<br/>  }</span><span id="fd3e" class="ly lz iq lu b gy oj mb l mc md">render() {<br/>  return &lt;h1&gt;Hello Friends&lt;/h1&gt;;<br/>  }<br/>}</span></pre><h2 id="a558" class="ly lz iq bd mm ny nz dn mq oa ob dp mu lf oc od mw lj oe of my ln og oh na oi bi translated">render()方法</h2><p id="56f3" class="pw-post-body-paragraph kw kx iq ky b kz nc jr lb lc nd ju le lf ne lh li lj nf ll lm ln ng lp lq lr ij bi translated">最常用的生命周期方法是<code class="fe nq nr ns lu b">render()</code>方法。在所有的React组中，你都会看到它。这是因为<code class="fe nq nr ns lu b">render()</code>是类组件中唯一需要的方法。</p><p id="46d3" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">顾名思义，它管理组件在用户界面上的呈现。这发生在组件安装和升级阶段。</p><p id="3254" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这个方法不改变状态；每次调用它，它都会返回相同的结果。<code class="fe nq nr ns lu b">render()</code>方法监控属性和状态的值，并返回以下任何一项:</p><ul class=""><li id="2778" class="nh ni iq ky b kz la lc ld lf nj lj nk ln nl lr nm nn no np bi translated">反应元素</li><li id="002b" class="nh ni iq ky b kz nt lc nu lf nv lj nw ln nx lr nm nn no np bi translated">排列</li><li id="5a80" class="nh ni iq ky b kz nt lc nu lf nv lj nw ln nx lr nm nn no np bi translated">碎片</li><li id="5a2e" class="nh ni iq ky b kz nt lc nu lf nv lj nw ln nx lr nm nn no np bi translated">字符串、数字、布尔值或空值</li></ul><pre class="kg kh ki kj gt lt lu lv lw aw lx bi"><span id="78c8" class="ly lz iq lu b gy ma mb l mc md">class FriendsComponent extends Component{<br/> render(){<br/>   return &lt;div&gt;Hi Chandler {this.props.name}&lt;/div&gt;<br/> }<br/>}</span></pre><h2 id="d13c" class="ly lz iq bd mm ny nz dn mq oa ob dp mu lf oc od mw lj oe of my ln og oh na oi bi translated">componentDidMount()方法</h2><p id="59a8" class="pw-post-body-paragraph kw kx iq ky b kz nc jr lb lc nd ju le lf ne lh li lj nf ll lm ln ng lp lq lr ij bi translated">就在组件安装之后，这个方法是可访问的。那是在呈现的HTML完成加载之后。在组件生命周期中，它被调用一次，这意味着组件及其所有子组件都已被正确呈现。</p><p id="275d" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在这个方法中，您还可以调用<code class="fe nq nr ns lu b">setState()</code>方法来改变状态，并最终调用<code class="fe nq nr ns lu b">render()</code>方法来更新DOM。即使调用了两次<code class="fe nq nr ns lu b">render()</code>函数，这个方法也保证了用户不会看到任何中间状态。</p><p id="f503" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">所以这确实是进行API调用的最安全的地方，因为组件已经被挂载，并且在这个阶段可以被DOM访问。</p><p id="ae9f" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">一般来说，如果没有DOM，这是一个完成所有配置工作的好地方，因为你无法完成这些工作。用这种方法可以做很多事情:</p><ul class=""><li id="3591" class="nh ni iq ky b kz la lc ld lf nj lj nk ln nl lr nm nn no np bi translated">将React应用程序链接到外部应用程序，如JavaScript框架或web APIs</li><li id="3065" class="nh ni iq ky b kz nt lc nu lf nv lj nw ln nx lr nm nn no np bi translated">使用<code class="fe nq nr ns lu b">SetTimeout </code>或<code class="fe nq nr ns lu b">SetInterval </code>设置定时器</li><li id="c4df" class="nh ni iq ky b kz nt lc nu lf nv lj nw ln nx lr nm nn no np bi translated">为事件添加侦听器</li><li id="01b6" class="nh ni iq ky b kz nt lc nu lf nv lj nw ln nx lr nm nn no np bi translated">在刚刚渲染的元素上绘图</li></ul><pre class="kg kh ki kj gt lt lu lv lw aw lx bi"><span id="1af1" class="ly lz iq lu b gy ma mb l mc md">import React from ‘react’;</span><span id="008b" class="ly lz iq lu b gy oj mb l mc md">class FriendsComponent extends React.Component {<br/> constructor(props) {<br/>   super(props);<br/>   this.state = {<br/>   title : ‘F.R.I.E.N.D.S’<br/>  }<br/>   console.log(‘Saying Hi from the Constructor’);<br/> }</span><span id="55fb" class="ly lz iq lu b gy oj mb l mc md">static getDerivedStateFromProps(props, state) {<br/>  console.log(‘Saying Hi in the React Component getDerivedStateFromProps’);<br/> }</span><span id="f757" class="ly lz iq lu b gy oj mb l mc md">componentDidMount(){ <br/> console.log(“Hi Friends componentDidMount”);<br/> }</span><span id="8293" class="ly lz iq lu b gy oj mb l mc md">render() {<br/> console.log(‘Hi Friends I am in the render method’);<br/> return &lt;div&gt; This is the FriendsComponent &lt;/div&gt;<br/> } <br/>}</span></pre></div><div class="ab cl me mf hu mg" role="separator"><span class="mh bw bk mi mj mk"/><span class="mh bw bk mi mj mk"/><span class="mh bw bk mi mj"/></div><div class="ij ik il im in"><h1 id="46f0" class="ml lz iq bd mm mn mo mp mq mr ms mt mu jw mv jx mw jz mx ka my kc mz kd na nb bi translated">更新阶段</h1><p id="edde" class="pw-post-body-paragraph kw kx iq ky b kz nc jr lb lc nd ju le lf ne lh li lj nf ll lm ln ng lp lq lr ij bi translated">安装后，组件并不总是保持相同的状态。基础属性可能经常改变，重新呈现组件是合适的。</p><p id="83ab" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">更新的生命周期方法使您有权决定更新实际发生的时间和方式。</p><p id="8756" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">更新阶段共有五种方法，包括以下方法:</p><ul class=""><li id="b73e" class="nh ni iq ky b kz la lc ld lf nj lj nk ln nl lr nm nn no np bi translated"><code class="fe nq nr ns lu b">componentWillReceiveProps()</code></li><li id="8000" class="nh ni iq ky b kz nt lc nu lf nv lj nw ln nx lr nm nn no np bi translated"><code class="fe nq nr ns lu b">shouldComponentUpdate()</code></li><li id="1701" class="nh ni iq ky b kz nt lc nu lf nv lj nw ln nx lr nm nn no np bi translated"><code class="fe nq nr ns lu b">componentWillUpdate()</code></li><li id="042e" class="nh ni iq ky b kz nt lc nu lf nv lj nw ln nx lr nm nn no np bi translated"><code class="fe nq nr ns lu b">render()</code></li><li id="87df" class="nh ni iq ky b kz nt lc nu lf nv lj nw ln nx lr nm nn no np bi translated"><code class="fe nq nr ns lu b">componentDidUpdate()</code></li></ul><h2 id="e360" class="ly lz iq bd mm ny nz dn mq oa ob dp mu lf oc od mw lj oe of my ln og oh na oi bi translated">componentWillReceiveProps()方法</h2><p id="9711" class="pw-post-body-paragraph kw kx iq ky b kz nc jr lb lc nd ju le lf ne lh li lj nf ll lm ln ng lp lq lr ij bi translated">属性从父组件外部传递给组件。这些道具通常与父组件的状态挂钩。</p><p id="b5cd" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">因此，如果父组件的状态发生变化，那么属性也将随之改变，需要进行修改。如果这些属性与组件状态相关联，那么一个变化就意味着组件状态的变化。</p><p id="7cd7" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><code class="fe nq nr ns lu b">ComponentWillReceiveProps</code>是在新道具为一个组件做某事之前命名的一种方法。这个方法叫做使用新的道具作为参数。在这里，下一组道具和当前的道具可供我们访问。因此，我们可以使用这种方法将当前道具与新道具进行比较，并评估某些东西是否真的发生了变化。</p><pre class="kg kh ki kj gt lt lu lv lw aw lx bi"><span id="92c4" class="ly lz iq lu b gy ma mb l mc md">class FriendsComponent extends React.Component {<br/> constructor(props) {<br/>   super(props);<br/>   this.state = {name: this.props.name};<br/>  }</span><span id="6868" class="ly lz iq lu b gy oj mb l mc md">componentWillReceiveProps(nextProps) {<br/>   if (this.props.name !== nextProps.name) {<br/>   this.setState({name: nextProps.name});<br/>  }<br/> }</span><span id="0030" class="ly lz iq lu b gy oj mb l mc md">render() {<br/> return (<br/>   &lt;h1&gt;{this.state.name}&lt;/h1&gt;<br/>  )<br/> }<br/>}</span></pre><p id="73a2" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">只有当前名称与先前名称不同时，上图中的<code class="fe nq nr ns lu b">this.state.name</code> <strong class="ky ir"> </strong>才会改变。但是如果没有区别，状态就不会改变。</p><h2 id="bcca" class="ly lz iq bd mm ny nz dn mq oa ob dp mu lf oc od mw lj oe of my ln og oh na oi bi translated">shouldComponentUpdate()方法</h2><p id="969e" class="pw-post-body-paragraph kw kx iq ky b kz nc jr lb lc nd ju le lf ne lh li lj nf ll lm ln ng lp lq lr ij bi translated">在组件重新呈现之前，在获得一组新的道具之后，或者在有一个新的状态之前，这个方法将被调用。</p><p id="4669" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们可以看到收到两个论点，下一个道具，下一个状态。通常的行为是，一旦属性的状态改变，组件就重新呈现。</p><p id="0491" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><code class="fe nq nr ns lu b">shouldComponentUpdate()</code> <strong class="ky ir"> </strong>可用于让React知道组件的性能不受组件属性或状态修改的影响，因此不应重新渲染。如果返回了一个<code class="fe nq nr ns lu b">true</code>或者一个<code class="fe nq nr ns lu b">false</code>值，组件将继续前进并做它总是做的事情:如果它返回了<code class="fe nq nr ns lu b">true</code>，则重新呈现组件。如果它返回<code class="fe nq nr ns lu b">false</code>，那么它不会更新组件。请注意，当子组件的状态改变时，它不会阻止子组件重新渲染。</p><p id="2efd" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">使用这个方法最简单的方法就是让它返回<code class="fe nq nr ns lu b">false</code>，然后在某些情况下，组件就不会更新了。如果情况满足，它不会更新组件。</p><p id="a91a" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">只有当新的输入不同于先前的输入时，组件才能更新。</p><pre class="kg kh ki kj gt lt lu lv lw aw lx bi"><span id="dbe2" class="ly lz iq lu b gy ma mb l mc md">class FriendsComponent extends React.Component {<br/> […]</span><span id="6c3e" class="ly lz iq lu b gy oj mb l mc md">shouldComponentUpdate(nextProps, nextState) {<br/> if (this.state.name == nextState.name) {<br/> console.log(“Inside shouldComponentUpdate”);</span><span id="9f1a" class="ly lz iq lu b gy oj mb l mc md">return false;<br/>  }<br/> }<br/>  […]<br/>}</span></pre><h2 id="d87a" class="ly lz iq bd mm ny nz dn mq oa ob dp mu lf oc od mw lj oe of my ln og oh na oi bi translated">componentWillUpdate()方法</h2><p id="8deb" class="pw-post-body-paragraph kw kx iq ky b kz nc jr lb lc nd ju le lf ne lh li lj nf ll lm ln ng lp lq lr ij bi translated"><code class="fe nq nr ns lu b">ComponentWillUpdate </code>是可以在重新渲染之前使用的准备方法。这个方法不允许你调用<code class="fe nq nr ns lu b">this.setState</code>。</p><p id="f886" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">使用这种方法，要做的一件重要的事情是与React架构之外的东西进行通信。<code class="fe nq nr ns lu b">ComponentWillUpdate</code>如果您需要在组件渲染之前执行一些非反应设置，也可以使用。</p><p id="fffe" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">如果你正在使用<code class="fe nq nr ns lu b">shouldComponentUpdate</code>，另一个使用这种方法的时候是当你需要做道具改变的时候。在这种情况下，最好使用它而不是<code class="fe nq nr ns lu b">ComponentWillReceiveProps</code>,因为它只有在组件真正被重新呈现时才会被调用。但是，如果您需要改变与道具变化相关的状态，请始终使用<code class="fe nq nr ns lu b">ComponentWillReceiveProps</code>。</p><p id="5078" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><strong class="ky ir">注意:</strong>虽然可以用它来实现动画和其他效果，但是不应该这样做，因为在组件被重新渲染之前，这个方法可能会被调用多次。</p><p id="e2bb" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">语法如下:</p><pre class="kg kh ki kj gt lt lu lv lw aw lx bi"><span id="9394" class="ly lz iq lu b gy ma mb l mc md">class FriendsComponent extends React.Component {<br/> […]</span><span id="43ba" class="ly lz iq lu b gy oj mb l mc md">componentWillUpdate(nextProps, nextState) {<br/> // Do something here<br/> }<br/> […]<br/>}</span></pre><h2 id="7b7b" class="ly lz iq bd mm ny nz dn mq oa ob dp mu lf oc od mw lj oe of my ln og oh na oi bi translated">componentDidUpdate()方法</h2><p id="9991" class="pw-post-body-paragraph kw kx iq ky b kz nc jr lb lc nd ju le lf ne lh li lj nf ll lm ln ng lp lq lr ij bi translated">在渲染的HTML完成加载后，调用<code class="fe nq nr ns lu b">componentDidUpdate</code>。在当前更新过程开始之前，它获得两个参数:组件的属性和状态。</p><p id="2e95" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">与非React环境(如浏览器)通信或在中发出HTTP请求的最佳位置是<code class="fe nq nr ns lu b">componentDidUpdate</code>。要阻止不需要的网络请求，只要你把新道具和以前的道具对比一下就应该可以实现了。</p><p id="a298" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">使用<code class="fe nq nr ns lu b">componentDidUpdate</code>的图示如下。</p><pre class="kg kh ki kj gt lt lu lv lw aw lx bi"><span id="3471" class="ly lz iq lu b gy ma mb l mc md">class FriendsComponent extends React.Component {<br/> […]</span><span id="af57" class="ly lz iq lu b gy oj mb l mc md">componentDidUpdate(prevProps, prevState) {<br/> if (this.props.name == prevProps.name) {<br/> // make ajax calls<br/> // Perform any other function<br/>  }<br/> }<br/> […]<br/>}</span></pre><p id="5b20" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">更新阶段的示例如下。</p><p id="7d4b" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><code class="fe nq nr ns lu b"><strong class="ky ir">Child.js</strong></code></p><pre class="kg kh ki kj gt lt lu lv lw aw lx bi"><span id="b1f8" class="ly lz iq lu b gy ma mb l mc md">import React, { Component } from ‘react’; </span><span id="611d" class="ly lz iq lu b gy oj mb l mc md">class ChildFriendsComponent extends Component{ <br/> constructor(props){ <br/>   super(props); <br/>   this.state={ <br/>   value:’FRIENDS’ <br/>  } <br/>   console.log(“Hi you’re in the child constructor”); <br/> } </span><span id="dfd2" class="ly lz iq lu b gy oj mb l mc md">static getDerivedStateFromProps(props,state){ <br/>  console.log(“Hi you’re in the child getDerivedStateFromProps”); <br/>  return null; <br/> } </span><span id="ca1e" class="ly lz iq lu b gy oj mb l mc md">componentDidMount(){ <br/> console.log(“Hi you’re in the child componentDidMount”); <br/> } </span><span id="429d" class="ly lz iq lu b gy oj mb l mc md">shouldComponentUpdate(){ <br/> console.log(“Hi you’re in the child shouldComponentUpdate”); <br/> return true; <br/> }</span><span id="7df3" class="ly lz iq lu b gy oj mb l mc md">getSnapshotBeforeUpdate(prevProps,prevState){  <br/> console.log("Hi you're in the child getSnapshotBeforeUpdate");  <br/> return null;  <br/> }  <br/><br/>componentDidUpdate(){  <br/>  console.log("Hi you're in the child componentDidUpdate");  <br/> }  <br/><br/>render(){  <br/>  console.log("Hi you're in the Friends Child Component render");  <br/>  return &lt;div/&gt;  <br/> }  <br/>}  <br/><br/>export default ChildFriendsComponent ;</span></pre><p id="6db8" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><code class="fe nq nr ns lu b"><strong class="ky ir">App.js</strong></code></p><pre class="kg kh ki kj gt lt lu lv lw aw lx bi"><span id="6ad1" class="ly lz iq lu b gy ma mb l mc md">import React,{Component} from ‘react’; <br/>import ChildFriendsComponent from ‘./Child’; </span><span id="0a65" class="ly lz iq lu b gy oj mb l mc md">class FriendsComponent extends Component{ <br/> constructor(props){ <br/>   super(props); <br/>   this.state={ <br/>   value:FRIENDS’ <br/> } <br/>   this.changeState = this.changeState.bind(this); <br/>   console.log(“Hi you’re in the constructor”); <br/> } </span><span id="aef7" class="ly lz iq lu b gy oj mb l mc md">static getDerivedStateFromProps(props,state){ <br/>   console.log(“Hi you’re in the getDerivedStateFromProps”); <br/>   return null; <br/> } </span><span id="e322" class="ly lz iq lu b gy oj mb l mc md">componentDidMount(){ <br/>   console.log(“Hi you’re in the componentDidMount”); <br/> } </span><span id="834d" class="ly lz iq lu b gy oj mb l mc md">shouldComponentUpdate(){ <br/>   console.log(“Hi you’re in the shouldComponentUpdate”); <br/>   return true; <br/> } </span><span id="e58b" class="ly lz iq lu b gy oj mb l mc md">getSnapshotBeforeUpdate(prevProps,prevState){ <br/>   console.log(“Hi you’re in the getSnapshotBeforeUpdate”); <br/>   return null; <br/> } </span><span id="110f" class="ly lz iq lu b gy oj mb l mc md">componentDidUpdate(){ <br/>   console.log(“Hi you’re in the componentDidUpdate”); <br/> } </span><span id="9fba" class="ly lz iq lu b gy oj mb l mc md">changeState = () =&gt; { <br/>   this.setState({ <br/>   value : “FRIENDS started” <br/>  }) <br/> } </span><span id="89f7" class="ly lz iq lu b gy oj mb l mc md">render(){ <br/> console.log(“Hi you’re in the render”); <br/> return( <br/>   &lt;div&gt; <br/>   &lt;div&gt;Friends Parent Component&lt;/div&gt; <br/>   &lt;button onClick={this.changeState}&gt;Say Hi&lt;/button&gt; <br/>   &lt;ChildFriendsComponent/&gt;<br/>   &lt;/div&gt; <br/>  ); <br/> } <br/>} </span><span id="72c3" class="ly lz iq lu b gy oj mb l mc md">export default FriendsComponent ;</span></pre></div><div class="ab cl me mf hu mg" role="separator"><span class="mh bw bk mi mj mk"/><span class="mh bw bk mi mj mk"/><span class="mh bw bk mi mj"/></div><div class="ij ik il im in"><h1 id="c05a" class="ml lz iq bd mm mn mo mp mq mr ms mt mu jw mv jx mw jz mx ka my kc mz kd na nb bi translated">卸载阶段</h1><p id="2e73" class="pw-post-body-paragraph kw kx iq ky b kz nc jr lb lc nd ju le lf ne lh li lj nf ll lm ln ng lp lq lr ij bi translated">组件不会一直存在于DOM中。也许，由于状态变化或其他原因，它们必须被丢弃。这种卸载方法将帮助我们管理组件的卸载。我们说方法是因为在React 16中，卸载只有一种方法。</p><h2 id="150b" class="ly lz iq bd mm ny nz dn mq oa ob dp mu lf oc od mw lj oe of my ln og oh na oi bi translated">componentWillUnmount()方法</h2><p id="1e76" class="pw-post-body-paragraph kw kx iq ky b kz nc jr lb lc nd ju le lf ne lh li lj nf ll lm ln ng lp lq lr ij bi translated">这是唯一的卸载技术。在从DOM中移除组件之前，立即调用<code class="fe nq nr ns lu b">ComponentWillUnmount</code>。这是应该执行任何清理的地方，比如使计时器失效、暂停网络请求、删除事件监听器或暂停任何<code class="fe nq nr ns lu b">componentDidMount</code>订阅。</p><p id="4569" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><code class="fe nq nr ns lu b">componentWillUnmount()</code>是任何React组件生命周期的最后一个阶段，卸载后就不能再挂载了。而<code class="fe nq nr ns lu b">setState()</code>方法会重新呈现DOM内容，所以不可能这样做。</p><pre class="kg kh ki kj gt lt lu lv lw aw lx bi"><span id="1bbe" class="ly lz iq lu b gy ma mb l mc md">class FriendsComponent extends React.Component { <br/> […] </span><span id="d2bb" class="ly lz iq lu b gy oj mb l mc md">componentWillUnmount() {<br/> document.removeEventListener(“click”, SomeFunction);<br/>  }<br/>  […]<br/>}</span></pre></div><div class="ab cl me mf hu mg" role="separator"><span class="mh bw bk mi mj mk"/><span class="mh bw bk mi mj mk"/><span class="mh bw bk mi mj"/></div><div class="ij ik il im in"><h1 id="b16b" class="ml lz iq bd mm mn mo mp mq mr ms mt mu jw mv jx mw jz mx ka my kc mz kd na nb bi translated">功能组件中的生命周期方法或生命周期挂钩</h1><p id="faff" class="pw-post-body-paragraph kw kx iq ky b kz nc jr lb lc nd ju le lf ne lh li lj nf ll lm ln ng lp lq lr ij bi translated">功能组件中没有组件生命周期方法。由于功能组件只是一个JavaScript函数，所以我们不能在组件中使用<code class="fe nq nr ns lu b">setState()</code>方法。这就是为什么它们经常被称为<em class="ls">无状态功能组件。</em></p><p id="1c16" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在功能组件中，我们可以使用React钩子。<code class="fe nq nr ns lu b">useEffect()</code>钩子可以用来复制生命周期动作，而<code class="fe nq nr ns lu b">useState</code>可以在功能组件中用来存储状态。</p></div><div class="ab cl me mf hu mg" role="separator"><span class="mh bw bk mi mj mk"/><span class="mh bw bk mi mj mk"/><span class="mh bw bk mi mj"/></div><div class="ij ik il im in"><h1 id="fa50" class="ml lz iq bd mm mn mo mp mq mr ms mt mu jw mv jx mw jz mx ka my kc mz kd na nb bi translated">结论</h1><p id="50f9" class="pw-post-body-paragraph kw kx iq ky b kz nc jr lb lc nd ju le lf ne lh li lj nf ll lm ln ng lp lq lr ij bi translated">再深入一点，每当有趣的事情发生时，我们发现React会持续观察并通知我们的组件。这大部分是通过我们在本文中关注的生命周期方法实现的。</p><p id="1f0f" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们在这里讨论的生命周期方法是你几乎总是会用到的。对于一些不寻常和复杂的情况，您将需要一些不寻常的生命周期方法。</p><p id="5b25" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">感谢您的阅读！</p></div></div>    
</body>
</html>