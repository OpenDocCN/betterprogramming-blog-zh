<html>
<head>
<title>How to Build Comparable Classes in Python</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何在Python中构建可比较的类</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/how-to-use-comparable-classes-in-python-a897f9bccf25?source=collection_archive---------7-----------------------#2022-04-01">https://betterprogramming.pub/how-to-use-comparable-classes-in-python-a897f9bccf25?source=collection_archive---------7-----------------------#2022-04-01</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="5d91" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">关于如何使类实例具有可比性和可排序性的基础教程</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/effe9ddef672e8cbbfbda9a29cbecd10.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*W9GiAZ9ECidCjPpefpjhLQ.png"/></div></div></figure><p id="b6a6" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">通常，您会希望让用户定义的类的实例具有可比性。</p><p id="35a3" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">假设您需要测试您的函数是否返回正确的值。如果该值恰好是某个类的对象，您可能会大吃一惊:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="lq lr l"/></div></figure><p id="7455" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">但是</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="lq lr l"/></div></figure><p id="50bb" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">当<code class="fe ls lt lu lv b">==</code>操作符没有重载时，Python使用<code class="fe ls lt lu lv b">is</code>操作符作为后备。它检查两个参数是否是内存中的同一个对象，显然在第一个例子中是这样，但在第二个例子中不是。</p><p id="a20c" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">要使实例“通过值”而不是“通过引用”进行比较，您需要重载比较运算符。</p><h1 id="6886" class="lw lx it bd ly lz ma mb mc md me mf mg jz mh ka mi kc mj kd mk kf ml kg mm mn bi translated">支持==</h1><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="lq lr l"/></div></figure><p id="b383" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">通过定义<code class="fe ls lt lu lv b">__eq__</code> <a class="ae mo" href="https://docs.python.org/3.9/reference/datamodel.html?highlight=__lt__#object.__eq__" rel="noopener ugc nofollow" target="_blank">方法</a>重载相等运算符后，不等运算符“免费”到来，因此不需要实现<code class="fe ls lt lu lv b">__ne__</code>方法:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="lq lr l"/></div></figure><p id="74f3" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">现在假设你需要订购一个物品列表(或者找到其中的一个<code class="fe ls lt lu lv b">min</code>或者<code class="fe ls lt lu lv b">max</code>):</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="lq lr l"/></div></figure><p id="a379" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">一种选择是使用“key”参数:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="lq lr l"/></div></figure><p id="956d" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">它可以工作，但是很难判断它是否正确工作，除非我们重载<code class="fe ls lt lu lv b">__repr__</code>方法:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="lq lr l"/></div></figure><p id="81bb" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">这是一个可行的选择，但是如果键总是相同的，一个可读性更好且不易出错的方法是将键合并到类定义中。</p></div><div class="ab cl mp mq hx mr" role="separator"><span class="ms bw bk mt mu mv"/><span class="ms bw bk mt mu mv"/><span class="ms bw bk mt mu"/></div><div class="im in io ip iq"><h1 id="e531" class="lw lx it bd ly lz mw mb mc md mx mf mg jz my ka mi kc mz kd mk kf na kg mm mn bi translated">支持&lt; and &gt;</h1><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="lq lr l"/></div></figure><p id="822d" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">既然已经定义了严格的比较运算符</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="lq lr l"/></div></figure><p id="7794" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">排序将“开箱即用”:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="lq lr l"/></div></figure><p id="7b26" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">请注意，这里有更多的函数调用，所以如果您的<code class="fe ls lt lu lv b">__lt__</code>函数做了一些重要的事情，那么“key”方法可能会工作得更快。</p><p id="3fb1" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">以类似于<code class="fe ls lt lu lv b">==</code>和<code class="fe ls lt lu lv b">!=</code>操作符的方式，Python足够聪明，可以减轻为一个类同时实现&lt;和&gt;的负担。如果您要求进行“大于”比较，并且只提供了“小于”运算符，它将交换参数以获得结果，因此没有必要严格实现<code class="fe ls lt lu lv b">__gt__</code>方法:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="lq lr l"/></div></figure><p id="0565" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">在这一点上，假设Python能够从我们提供的<code class="fe ls lt lu lv b">&lt;</code>和<code class="fe ls lt lu lv b">==</code>构造<code class="fe ls lt lu lv b">&lt;=</code>操作符似乎是合乎逻辑的，但事实并非如此:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="lq lr l"/></div></figure><p id="04a4" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">在这种情况下，Python依赖于“显式优于隐式”的规则。</p></div><div class="ab cl mp mq hx mr" role="separator"><span class="ms bw bk mt mu mv"/><span class="ms bw bk mt mu mv"/><span class="ms bw bk mt mu"/></div><div class="im in io ip iq"><h1 id="3d96" class="lw lx it bd ly lz mw mb mc md mx mf mg jz my ka mi kc mz kd mk kf na kg mm mn bi translated">支持&lt;= and &gt; =</h1><p id="6ad2" class="pw-post-body-paragraph ku kv it kw b kx nb ju kz la nc jx lc ld nd lf lg lh ne lj lk ll nf ln lo lp im bi translated">一种选择是显式定义操作:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="lq lr l"/></div></figure><p id="b2fc" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">就像严格的比较一样，Python猜测所谓的“反射”操作的含义:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="lq lr l"/></div></figure><p id="a86b" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">另一个选择是使用标准库中的<code class="fe ls lt lu lv b"><a class="ae mo" href="https://docs.python.org/3/library/functools.html#functools.total_ordering" rel="noopener ugc nofollow" target="_blank">total_ordering</a></code>装饰器。如果你给它两个基本操作:<code class="fe ls lt lu lv b">==</code>和一个<code class="fe ls lt lu lv b">&gt;, &lt;, &lt;=, &gt;=</code>，它将构建剩下的四个:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="lq lr l"/></div></figure><p id="ce42" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">以下是这两种方法的基本视图:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ng"><img src="../Images/ec7bf16992617e4c0bf946dc0e237e04.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*PQ2ZXKG2f4axvTdFwG7uPA.png"/></div></div></figure><p id="e5fc" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">依赖隐式反射可能会开一个糟糕的玩笑的一种情况是继承。</p></div><div class="ab cl mp mq hx mr" role="separator"><span class="ms bw bk mt mu mv"/><span class="ms bw bk mt mu mv"/><span class="ms bw bk mt mu"/></div><div class="im in io ip iq"><h1 id="f9a2" class="lw lx it bd ly lz mw mb mc md mx mf mg jz my ka mi kc mz kd mk kf na kg mm mn bi translated">反思与继承</h1><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="lq lr l"/></div></figure><p id="789a" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">同样，为了让它像预期的那样工作，您要么需要显式地实现所有的操作符，要么使用<code class="fe ls lt lu lv b">total_ordering</code>装饰器:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="lq lr l"/></div></figure><p id="fac0" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">不过值得注意的是，由于Python的动态特性，反射操作和<code class="fe ls lt lu lv b">total_ordering</code>的魔力都发生在“运行时”(即调用操作符时，而不是定义类时)，所以代价是速度稍微慢了一点。</p><p id="cee0" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">一个更快的替代方法是使用一个已经可以比较的类作为起点。</p></div><div class="ab cl mp mq hx mr" role="separator"><span class="ms bw bk mt mu mv"/><span class="ms bw bk mt mu mv"/><span class="ms bw bk mt mu"/></div><div class="im in io ip iq"><h1 id="8b3c" class="lw lx it bd ly lz mw mb mc md mx mf mg jz my ka mi kc mz kd mk kf na kg mm mn bi translated">基于现有的可比类</h1><p id="aaca" class="pw-post-body-paragraph ku kv it kw b kx nb ju kz la nc jx lc ld nd lf lg lh ne lj lk ll nf ln lo lp im bi translated">例如，<code class="fe ls lt lu lv b"><a class="ae mo" href="https://docs.python.org/3/library/collections.html#collections.namedtuple" rel="noopener ugc nofollow" target="_blank">namedtuple</a></code>实现了所有六个操作符，用于从左到右比较其元素:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="lq lr l"/></div></figure><p id="5519" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">如果你需要进一步扩展类的功能(添加不需要参与比较的字段或者一些额外的方法)，你可以直接从一个<code class="fe ls lt lu lv b">list</code>继承</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="lq lr l"/></div></figure><p id="0fbb" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">或者来自一个<code class="fe ls lt lu lv b">tuple</code>(有些人为，因为它必须是不可变的):</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="lq lr l"/></div></figure></div><div class="ab cl mp mq hx mr" role="separator"><span class="ms bw bk mt mu mv"/><span class="ms bw bk mt mu mv"/><span class="ms bw bk mt mu"/></div><div class="im in io ip iq"><h1 id="0fdd" class="lw lx it bd ly lz mw mb mc md mx mf mg jz my ka mi kc mz kd mk kf na kg mm mn bi translated">结论</h1><p id="38f3" class="pw-post-body-paragraph ku kv it kw b kx nb ju kz la nc jx lc ld nd lf lg lh ne lj lk ll nf ln lo lp im bi translated">实现实例比较的正确方法是</p><ol class=""><li id="cfa3" class="nh ni it kw b kx ky la lb ld nj lh nk ll nl lp nm nn no np bi translated">过载所有六个操作符。<br/> <br/>为了减少代码中的冗余，使其更具可读性，更少出错，可以:</li><li id="2e82" class="nh ni it kw b kx nq la nr ld ns lh nt ll nu lp nm nn no np bi translated">只实现操作的一个子集，让Python通过使用操作符(也称为反射操作)的对称性来处理剩下的部分(例如<code class="fe ls lt lu lv b">a &lt; b</code>，也就是<code class="fe ls lt lu lv b">b &gt; a</code>)</li><li id="ed19" class="nh ni it kw b kx nq la nr ld ns lh nt ll nu lp nm nn no np bi translated">进一步减少比较操作的数量，并指示Python通过<code class="fe ls lt lu lv b">functools.total_ordering</code>装饰器构建余数(例如<code class="fe ls lt lu lv b">a &lt; b</code>或<code class="fe ls lt lu lv b">a==b</code>从而<code class="fe ls lt lu lv b">a &lt;= b</code></li><li id="dbcd" class="nh ni it kw b kx nq la nr ld ns lh nt ll nu lp nm nn no np bi translated">通过依赖来自<code class="fe ls lt lu lv b">collections.namedtuple</code>类的代码(没有自定义字段或方法)，完全避免操作符的显式实现。</li><li id="0c40" class="nh ni it kw b kx nq la nr ld ns lh nt ll nu lp nm nn no np bi translated">通过继承列表或元组实现中的操作符来重用它们(自定义字段和方法，但是代码要多一点)。</li></ol><p id="54ad" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">对于快速实验,( 2)和(3)是可以的，但是对于时间关键的应用,( 1)、(4)或(5)是更好的。</p><p id="11f3" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">另外，Python 2.x中的<code class="fe ls lt lu lv b"> __cmp__</code>丰富的比较方法(返回一个有符号的数字，作为定义所有6个操作的替代方法)启发了C++20中的<code class="fe ls lt lu lv b"><a class="ae mo" href="https://en.cppreference.com/w/cpp/language/operators" rel="noopener ugc nofollow" target="_blank">operator&lt;=&gt;</a></code>，但是没有找到进入Python3的方法，因为<code class="fe ls lt lu lv b">total_ordering</code>是官方的迁移路径。</p></div></div>    
</body>
</html>