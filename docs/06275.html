<html>
<head>
<title>Drag and Drop With Linear Interpolation in JavaScript</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">JavaScript中的线性插值拖放</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/drag-and-drop-with-linear-interpolation-in-javascript-9e5dc779bc23?source=collection_archive---------7-----------------------#2020-09-16">https://betterprogramming.pub/drag-and-drop-with-linear-interpolation-in-javascript-9e5dc779bc23?source=collection_archive---------7-----------------------#2020-09-16</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="6763" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">使用普通JavaScript利用线性插值实现平滑和高性能的拖放UX</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/33c6828ec7cd685dc0f4fb141911c4a7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*YtfrvVNm34dOTU55"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">在<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上<a class="ae ky" href="https://unsplash.com/@ahmadreza_sajadi?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">艾哈迈德扎·萨贾迪</a>拍摄的照片。</p></figure><p id="a26a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">最近，我写了一篇关于使用普通JavaScript实现拖放功能的文章。这一次，我想对拖动逻辑应用线性插值，以便可拖动对象平滑地“赶上”用户的光标/触摸点，而不是紧随其后:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi lv"><img src="../Images/1b4265548b9852c75901d55d2d2e07d6.png" data-original-src="https://miro.medium.com/v2/resize:fit:600/1*qe-pVV64Z2Z2S74l2hNgqA.gif"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">没有线性插值。</p></figure><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi lv"><img src="../Images/f5283f3f4505be457f69ecec76487c11.png" data-original-src="https://miro.medium.com/v2/resize:fit:600/1*xq1mvcJKs1X_qEosUHyHMA.gif"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">使用线性插值。</p></figure></div><div class="ab cl lw lx hx ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="im in io ip iq"><h1 id="c82e" class="md me it bd mf mg mh mi mj mk ml mm mn jz mo ka mp kc mq kd mr kf ms kg mt mu bi translated">基础知识</h1><p id="3c12" class="pw-post-body-paragraph kz la it lb b lc mv ju le lf mw jx lh li mx lk ll lm my lo lp lq mz ls lt lu im bi translated"><a class="ae ky" href="https://en.wikipedia.org/wiki/Linear_interpolation" rel="noopener ugc nofollow" target="_blank">线性插值</a>是一种在已知状态之间投影数据的方法。在拖放功能的情况下，它可以用来创建可拖动元素的当前和未来位置之间的坐标，以便我们可以创建这两种状态之间的平滑过渡。我们将要使用的基本功能是:</p><pre class="kj kk kl km gt na nb nc nd aw ne bi"><span id="9f38" class="nf me it nb b gy ng nh l ni nj">function lerp(start, end, amt) {<br/>  return (1-amt)*start+amt*end<br/>};</span></pre><ul class=""><li id="9ed6" class="nk nl it lb b lc ld lf lg li nm lm nn lq no lu np nq nr ns bi translated"><code class="fe nt nu nv nb b">start</code> —代表起始状态(数字)</li><li id="24c7" class="nk nl it lb b lc nw lf nx li ny lm nz lq oa lu np nq nr ns bi translated"><code class="fe nt nu nv nb b">end</code> —结束状态(数字)</li><li id="7559" class="nk nl it lb b lc nw lf nx li ny lm nz lq oa lu np nq nr ns bi translated"><code class="fe nt nu nv nb b">amt</code> —介于两者之间的插值量(0.0到1.0)</li></ul><p id="abd3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">因此，如果我们的起始坐标是100，结束状态坐标是200，并且我们要为每个重绘循环(~frame)插值的量是0.1，则:</p><pre class="kj kk kl km gt na nb nc nd aw ne bi"><span id="946f" class="nf me it nb b gy ng nh l ni nj">Frame 1 = (1-0.1)*100 + 0.1*200 = 110;<br/>Frame 2 = (1-0.1)*110 + 0.1*200 = 119;<br/>Frame 2 = (1-0.1)*119 + 0.1*200 = 127.1;<br/>...<br/>Frame N = (1-0.1)*199 + 0.1*200 = 199.1;</span></pre><p id="8667" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在，如果我们考虑一个拖放用例，上面的函数会创建一系列坐标，被拖动的元素需要通过这些坐标进行转换。</p></div><div class="ab cl lw lx hx ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="im in io ip iq"><h1 id="b2cb" class="md me it bd mf mg mh mi mj mk ml mm mn jz mo ka mp kc mq kd mr kf ms kg mt mu bi translated">初始设置</h1><p id="88de" class="pw-post-body-paragraph kz la it lb b lc mv ju le lf mw jx lh li mx lk ll lm my lo lp lq mz ls lt lu im bi translated">下面是附加基本拖放功能所需的侦听器的初始代码:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ob oc l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">初始HTML</p></figure><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ob oc l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">初始CSS</p></figure><p id="2d61" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">上面的代码呈现了一个容器，这个容器将有事件监听器附加到它上面，还有一些框将在以后变得可拖动。现在，我们将添加JavaScript，它可以在不移动任何东西的情况下进行拖放操作:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ob oc l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">JS的基本设置</p></figure><h2 id="3c17" class="nf me it bd mf od oe dn mj of og dp mn li oh oi mp lm oj ok mr lq ol om mt on bi translated">几个音符</h2><ul class=""><li id="362e" class="nk nl it lb b lc mv lf mw li oo lm op lq oq lu np nq nr ns bi translated">我们正在使用<a class="ae ky" href="https://developer.mozilla.org/en-US/docs/Web/API/Pointer_events" rel="noopener ugc nofollow" target="_blank">指针事件</a>，它提供了触摸和鼠标输入的混合，以支持现代设备和交叉输入。</li><li id="a468" class="nk nl it lb b lc nw lf nx li ny lm nz lq oa lu np nq nr ns bi translated">我们附加了被动侦听器，并且动态地这样做以防止事件污染，所以每次只有必需的侦听器是主动的。</li><li id="eab9" class="nk nl it lb b lc nw lf nx li ny lm nz lq oa lu np nq nr ns bi translated">我们的CSS使用了<code class="fe nt nu nv nb b">touch-action</code>和<code class="fe nt nu nv nb b">user-select</code>规则来确保我们不会触发任何默认的浏览器行为(滚动、本地拖放等)。</li><li id="6e8d" class="nk nl it lb b lc nw lf nx li ny lm nz lq oa lu np nq nr ns bi translated">我们还使用<code class="fe nt nu nv nb b"><a class="ae ky" href="https://developer.mozilla.org/en-US/docs/Web/API/Element/touchcancel_event" rel="noopener ugc nofollow" target="_blank">pointercancel</a></code>监听器处理中断的触摸事件，并像对待<code class="fe nt nu nv nb b">pointerup</code>一样对待它。</li></ul></div><div class="ab cl lw lx hx ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="im in io ip iq"><h1 id="1238" class="md me it bd mf mg mh mi mj mk ml mm mn jz mo ka mp kc mq kd mr kf ms kg mt mu bi translated">添加线性插值</h1><p id="42e0" class="pw-post-body-paragraph kz la it lb b lc mv ju le lf mw jx lh li mx lk ll lm my lo lp lq mz ls lt lu im bi translated">考虑到用户体验，我们需要假设插值应该在用户按下指针后变为“活动”，然后在用户释放指针后变为“非活动”。所以需要在<code class="fe nt nu nv nb b">pointerdown</code>和<strong class="lb iu"> </strong> <code class="fe nt nu nv nb b">pointerup/pointercancel</code>事件之间不断调用我们的LERP(=线性插值)函数。</p><p id="1f43" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">当然，我们可以利用<code class="fe nt nu nv nb b"><a class="ae ky" href="https://developer.mozilla.org/en-US/docs/Web/API/WindowOrWorkerGlobalScope/setInterval" rel="noopener ugc nofollow" target="_blank">setInterval</a></code>，但是更好的选择是<a class="ae ky" href="https://developer.mozilla.org/en-US/docs/Web/API/window/requestAnimationFrame" rel="noopener ugc nofollow" target="_blank">RequestAnimationFrame API</a>，因为它为我们提供了精确的60fps (1000ms/60=~16.7ms)渲染帧计时器。</p><p id="38db" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们实现这一部分:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ob oc l"/></div></figure><p id="49e6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在，我们所有的方法都被正确调用，我们可以实现允许我们使用插值坐标重新绘制盒子的逻辑:</p><ul class=""><li id="5863" class="nk nl it lb b lc ld lf lg li nm lm nn lq no lu np nq nr ns bi translated">首先，我们需要确保在<strong class="lb iu"> </strong> <code class="fe nt nu nv nb b">pointerdown</code> <strong class="lb iu"> </strong>和<strong class="lb iu"> </strong> <code class="fe nt nu nv nb b">pointermove</code> <strong class="lb iu"> </strong>事件上，我们开始获取输入坐标(<code class="fe nt nu nv nb b">inputX</code>，<code class="fe nt nu nv nb b">inputY</code>)，这些坐标将由我们的LERP函数在每个动画帧中使用。</li><li id="7350" class="nk nl it lb b lc nw lf nx li ny lm nz lq oa lu np nq nr ns bi translated">接下来，我们需要确保我们还捕获了一个<a class="ae ky" href="https://developer.mozilla.org/en-US/docs/Web/API/Element/getBoundingClientRect" rel="noopener ugc nofollow" target="_blank">客户端边界矩形</a>，我们将使用它来计算我们的可拖动框的中心点，确保框的中心“赶上”用户的指针，而不仅仅是左上角。</li></ul><p id="1d57" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">完整的实现如下:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ob oc l"/></div></figure></div><div class="ab cl lw lx hx ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="im in io ip iq"><h1 id="9874" class="md me it bd mf mg mh mi mj mk ml mm mn jz mo ka mp kc mq kd mr kf ms kg mt mu bi translated">结论</h1><p id="7a97" class="pw-post-body-paragraph kz la it lb b lc mv ju le lf mw jx lh li mx lk ll lm my lo lp lq mz ls lt lu im bi translated">我们刚刚利用基本的线性插值在纯普通JavaScript中实现了一种不同的拖放体验:</p><ul class=""><li id="ab35" class="nk nl it lb b lc ld lf lg li nm lm nn lq no lu np nq nr ns bi translated">我们使用了现代指针事件API。</li><li id="f063" class="nk nl it lb b lc nw lf nx li ny lm nz lq oa lu np nq nr ns bi translated">代替<code class="fe nt nu nv nb b">setInterval</code>，我们利用了RequestAnimationFrame API。</li></ul><p id="6106" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">线性插值是为用户创建平滑拖动体验的好方法，尤其是在需要确保用户的光标/触摸输入点不总是被可拖动元素阻挡的情况下。</p><p id="aab2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">完整演示可通过codepen.io获得:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="or oc l"/></div></figure><p id="ec1b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">感谢您的阅读！</p></div></div>    
</body>
</html>