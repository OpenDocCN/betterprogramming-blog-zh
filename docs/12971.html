<html>
<head>
<title>Jetpack Compose Navigation in a Multi-module Project</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Jetpack在多模块项目中组合导航</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/jetpack-compose-navigation-in-a-multi-module-project-8d3947e6e2a4?source=collection_archive---------1-----------------------#2022-07-16">https://betterprogramming.pub/jetpack-compose-navigation-in-a-multi-module-project-8d3947e6e2a4?source=collection_archive---------1-----------------------#2022-07-16</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="ff50" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">使用撰写导航组织您的Android代码库</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/4440db04424ce8b238e3e8d1ee006052.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*doZ40djBjtW21f29"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">照片由<a class="ae kv" href="https://unsplash.com/@williambout?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">威廉·布特</a>在<a class="ae kv" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>拍摄</p></figure><p id="62c5" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">当我开始开发一个新的应用程序时，我利用这个机会在Jetpack Compose上制作UI。和往常一样，我必须解决选择多模块架构和导航机制的问题。一方面，解决方案应该非常简洁，对于新开发人员来说容易理解。另一方面，它应该是可伸缩的，以便模块大小和数量的增长不会带来麻烦，比如烦人的构建时间或频繁的合并冲突。</p><p id="d855" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在研究了Google Compose 的文档、<a class="ae kv" href="https://github.com/android/compose-samples" rel="noopener ugc nofollow" target="_blank">示例并在网上搜索解决方案后，决定使用</a><a class="ae kv" href="https://developer.android.com/jetpack/compose/navigation" rel="noopener ugc nofollow" target="_blank">Jetpack Compose Navigation</a>库，因为，首先，它是由Google开发的。其次，它是一个相当灵活的工具，满足现代需求:灵活的工作与后台堆栈，简单的集成与底部导航条，过渡动画，一个机制，集成与深层链接。再次，在我们看来，图书馆直观，入门门槛低。</p><p id="d41d" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在这里，我想用一个简单的例子来分享如何开始用Jetpack编写导航的多模块应用程序。</p><p id="774c" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">让我们考虑这个库中的主要实体。这里将会复述文档，所以那些已经使用过这个工具的人可以转到下一节。</p><p id="2eee" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><code class="fe ls lt lu lv b"><strong class="ky ir">Destination</strong></code>是导航屏幕的一般名称(在我们的例子中，是可组合功能)。</p><p id="1854" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><code class="fe ls lt lu lv b"><strong class="ky ir">Route</strong></code>字符串是指向屏幕的链接。这里，与片段的Jetpack导航不同，导航只通过链接进行。与web类似，传递的参数也写在同一个字符串中(另一种方法是将包保存在后台堆栈中)。将进一步讨论该示例。</p><p id="99a3" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><code class="fe ls lt lu lv b"><strong class="ky ir">NavController</strong></code>是一个类，导航通过它进行。在“根”可组合组件中创建一个实例，该实例必须传递给所有“子”目的地。</p><p id="6c11" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><code class="fe ls lt lu lv b"><strong class="ky ir">NavHost</strong></code>是一个可组合函数，将路线与目的地或嵌套图绑定在一起。这是对片段的Jetpack导航中xml图形描述的替换。</p><p id="0167" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><strong class="ky ir"> NavOptions </strong>是在<code class="fe ls lt lu lv b">NavController.navigate(..)</code>方法的参数中找到的。它允许您设置过渡动画，在后台堆栈中保存和读取束类型状态屏幕，选择要清除后台堆栈的屏幕，或将导航行为设置为已经在后台堆栈中的屏幕。您可以在文档中找到更多详细信息。在我们的例子中，不会使用这个参数。</p><p id="b2d2" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><code class="fe ls lt lu lv b"><strong class="ky ir">Navigator.Extras</strong></code>也见于<code class="fe ls lt lu lv b">NavController.navigate(..)</code>方法的参数中。这是一个<a class="ae kv" href="https://developer.android.com/reference/androidx/navigation/Navigator.Extras" rel="noopener ugc nofollow" target="_blank">有三个继承人</a>的界面，例如，允许您配置活动选项或动态功能导航。这里我们也不考虑这个。</p><p id="632f" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这就足够开始了！所以让我们来看看代码。</p><h1 id="c26f" class="lw lx iq bd ly lz ma mb mc md me mf mg jw mh jx mi jz mj ka mk kc ml kd mm mn bi translated"><strong class="ak">第一步。创建项目</strong></h1><p id="a9f3" class="pw-post-body-paragraph kw kx iq ky b kz mo jr lb lc mp ju le lf mq lh li lj mr ll lm ln ms lp lq lr ij bi translated">要使用Compose，您需要安装Android Studio北极狐和更高版本。创建一个模板项目“空合成活动”。</p><p id="2a08" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">很可能，IDE会提示您更新库版本；这最初可能会导致合并冲突。在示例<a class="ae kv" href="https://github.com/mmarashan/JetComposeNavMultimodule" rel="noopener ugc nofollow" target="_blank"> Github repository </a>中，您可以检查构建中使用的源代码和库版本。</p><p id="b3c9" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">继续前进…</p><h1 id="5bbf" class="lw lx iq bd ly lz ma mb mc md me mf mg jw mh jx mi jz mj ka mk kc ml kd mm mn bi translated"><strong class="ak">第二步。底部导航条</strong></h1><p id="3c91" class="pw-post-body-paragraph kw kx iq ky b kz mo jr lb lc mp ju le lf mq lh li lj mr ll lm ln ms lp lq lr ij bi translated">让我们考虑一下创建Scaffold (Material design layout)的代码，其中我们声明了一个Bottom Bar——带有底部导航栏渲染的可组合函数，以及一个<code class="fe ls lt lu lv b">AppNavGraph</code> —带有导航图的屏幕渲染的可组合函数。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mt mu l"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">应用程序内容的根目录</p></figure><p id="b2bb" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">总的来说，一切都和Google示例中的一样，我们不需要添加任何新的东西。让我们分开来看每件事。BottomTabs是一个包含底部导航栏内容的枚举类。注意route参数——选项卡将通过它连接到可组合屏幕:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mt mu l"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">底部导航栏的组织数据结构示例</p></figure><p id="7da8" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们来考虑一下<code class="fe ls lt lu lv b">BottomBar</code>。</p><p id="ed0a" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">第一行是最有趣的——多亏了它，在改变后台堆栈时发生了重组。</p><p id="fd0f" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">接下来是<code class="fe ls lt lu lv b">BottomNavigation</code>的渲染，但前提是当前目的地与底部标签中描述的路线相关联。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mt mu l"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">底部导航条代码</p></figure><p id="58c9" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">现在是与导航相关的主要代码——<code class="fe ls lt lu lv b">NavHost</code>声明。</p><p id="3efc" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">对于初始化，它需要上面创建的<code class="fe ls lt lu lv b">NavController</code>和起始目的地。</p><p id="702e" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这是导航图初始化的地方——将路线链接到屏幕。为路线“home”和“settings”声明了可组合的函数，这些函数将在导航期间被调用。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mt mu l"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">NavHost声明</p></figure><p id="149a" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">然而，多模块化怎么办？无休止地在一个文件中注册每一个新屏幕是荒谬的，会使它膨胀到无穷大。因此，一个统一的添加功能的方法将对我们有很大的帮助。下一步我们会考虑。</p><h1 id="95ac" class="lw lx iq bd ly lz ma mb mc md me mf mg jw mh jx mi jz mj ka mk kc ml kd mm mn bi translated"><strong class="ak">第三步。功能-API </strong></h1><p id="52a8" class="pw-post-body-paragraph kw kx iq ky b kz mo jr lb lc mp ju le lf mq lh li lj mr ll lm ln ms lp lq lr ij bi translated">这里我们就不争论特性语句了，哪里是一个特性的结束，哪里是另一个特性的开始。在这个例子中，我们将一个特性称为带屏幕的独立模块，它与它的API模块成对出现。</p><p id="a061" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">让我们创建一个核心模块，并将其命名为<code class="fe ls lt lu lv b">feature-api</code>。</p><p id="308a" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">下面的接口是主要的API特性契约。所有的API特性也是接口，必须从它们继承。</p><p id="198e" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">考虑到导航参数，API特性补充了将路线返回到屏幕的方法。</p><p id="5df3" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><code class="fe ls lt lu lv b">register Graph(…)</code>功能通过<code class="fe ls lt lu lv b">navGraphBuilder.composable(…)</code>将特征导航图注册为单独的屏幕，或通过<code class="fe ls lt lu lv b">navGraphBuilder.navigation(..)</code>注册为嵌套图。</p><p id="b485" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><code class="fe ls lt lu lv b">NavController</code>用于在功能中调用的导航。修饰符包含底部导航栏的缩进边距。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mt mu l"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">功能API的接口</p></figure><p id="c8fd" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">每个功能由两个模块组成:<code class="fe ls lt lu lv b">feature-name-api</code>和<code class="fe ls lt lu lv b">feature-name-impl</code>。</p><p id="1699" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><code class="fe ls lt lu lv b">api</code>模块应尽可能轻便，因为它可以被其他功能导入以导航到<code class="fe ls lt lu lv b">feature-name</code>屏幕。</p><p id="e1d1" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><code class="fe ls lt lu lv b">impl</code>模块包含特性的整个实现，只有app模块知道它，并通过DI将实现提供给其他特性。</p><p id="4a6a" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">为了清楚起见，我们将在图中显示模块的层次结构:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi mv"><img src="../Images/05d71fa698f3f9d4a3f25d8f34b97d13.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Nb-g4q09e6rSp5Tk7BBgqw.png"/></div></div></figure><p id="5941" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">为什么我们允许特性知道彼此的API？为什么我们把它们分成两个模块？</p><p id="9cc0" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">Jetpack组合导航中的导航基于链接。其API中的每个特性都回答了哪些链接打开其屏幕的问题。可能存在这样的情况，当特征A导航到特征B的屏幕时，反之亦然。在“单模”特征的情况下，会出现循环依赖的情况。</p><p id="7290" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们还特意决定放弃“功能是孤立的，所有导航都在应用程序或一些核心导航模块中”的方法，我们在类似主题的帖子中遇到过这种方法。我们正在制作一个可能包含大量模块的大型应用程序。这种方法会导致这样一个事实，即会有某个神级/对象/模块负责导航。这可能会导致单独模块的膨胀，并对构建时间产生负面影响，以及随着开发人员数量的增加而导致频繁的合并冲突。</p><p id="1168" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">让我们考虑一个实现<code class="fe ls lt lu lv b">home-api</code>特性的例子。这里增加了一个返回路线到单一功能屏幕的方法。一般来说，在路由包含可以通过方法参数传递的参数的情况下，接口提供方法，而不是常数。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mt mu l"/></div></figure><p id="38fb" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们来考虑一下<code class="fe ls lt lu lv b">home-impl</code>。在本例中，只有一个屏幕被“注册”,但是随着模块的增长，可能会有许多屏幕。同时，添加新屏幕只会导致一个隔离模块内的变化。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mt mu l"/></div></figure><p id="fea7" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">使用<code class="fe ls lt lu lv b">NavGraphBuilder.register</code>扩展在<code class="fe ls lt lu lv b">NavHost</code> lambda主体的app模块中注册该功能:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mt mu l"/></div></figure><p id="4a24" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这里你可以注意到另一个新的实体——<code class="fe ls lt lu lv b">DependencyProvider</code>。它是一个对象，像<code class="fe ls lt lu lv b">service-locator</code>一样，在我们简化的例子中模拟目标DI。假设API特性可以从DI图中访问。</p><p id="9a6a" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">请注意，这种方法没有在库导航机制上提供自己的附加组件，因此开发人员不必研究内部的“自行车”。添加了一个有助于跨模块扩展功能屏幕的接口和一个为简明起见的可选扩展。</p><h1 id="a902" class="lw lx iq bd ly lz ma mb mc md me mf mg jw mh jx mi jz mj ka mk kc ml kd mm mn bi translated"><strong class="ak">第四步。导航至其他功能屏幕</strong></h1><p id="a633" class="pw-post-body-paragraph kw kx iq ky b kz mo jr lb lc mp ju le lf mq lh li lj mr ll lm ln ms lp lq lr ij bi translated">现在让我们看一下从一个特性到另一个特性导航的例子。我们以onboarding功能为例，它允许您导航到主页功能屏幕。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mt mu l"/></div></figure><p id="d182" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这里OnboardingScreen是通过route = "onboarding "打开的功能屏幕。在按钮单击处理程序中，使用NavController从后台堆栈中移除当前屏幕，并通过伪DI DependencyProvider获得所需功能的API，该API提供了到其屏幕的路径。</p><h1 id="bf0e" class="lw lx iq bd ly lz ma mb mc md me mf mg jw mh jx mi jz mj ka mk kc ml kd mm mn bi translated"><strong class="ak">第五步。功能内部导航</strong></h1><p id="84b6" class="pw-post-body-paragraph kw kx iq ky b kz mo jr lb lc mp ju le lf mq lh li lj mr ll lm ln ms lp lq lr ij bi translated">在上一步中，我们执行了从onboarding功能到主页的导航。</p><p id="4b71" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">实际上，在一个特性中会有许多屏幕，逻辑上只在模块中可用，而不在特性的API中公开它们的存在。让我们看看如何组织特性内部的导航，同时与嵌套图和传递参数主题相关。</p><p id="fa8c" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">由于特性的“公共”和“私有”API之间的区别仅在于范围，我们可以在特性内部重用FeatureApi方法。</p><p id="412e" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在我们的例子中，home特性的“私人”屏幕是<code class="fe ls lt lu lv b">ScreenA</code>和ScreenB。导航到第二个需要一个参数。这里我们将使私有API成为简化的对象。</p><p id="1ee6" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在实践中，您可以观察依赖反转的原理，并通过DI交付它的实现。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mt mu l"/></div></figure><p id="47b8" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">请注意，在<code class="fe ls lt lu lv b">registerGraph()</code>方法中，注册了一个嵌套图— <code class="fe ls lt lu lv b">navGraphBuilder.navigation(..)</code>。嵌套图是根据某种原则将屏幕组合到一个单独的组中的方法，例如，一个单独的用户脚本。</p><p id="cfde" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">它们允许您运行脚本-知道路线，但不知道将打开哪个屏幕-这是通过<code class="fe ls lt lu lv b">startDestination</code>参数配置的。同时，图表不是孤立的，因此如果您知道它的路线，就可以导航到任何嵌套的屏幕。</p><p id="0bb6" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们还可以看到如何导航到带有参数的屏幕。<code class="fe ls lt lu lv b">screenB(parameter: String)</code>方法返回正确的路线，将参数考虑在内。下面注册了带有参数的相同路线。</p><p id="8015" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">让我们在外部API的实现中注册内部API的图形:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mt mu l"/></div></figure><p id="5a3c" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">现在让我们给<code class="fe ls lt lu lv b">ScreenB</code>添加到<code class="fe ls lt lu lv b">ScreenA</code>的导航。通过点击按钮，我们开始沿着在<code class="fe ls lt lu lv b">InternalHomeFeatureApi.screenB(…)</code>中收集的路线导航，文本通过<code class="fe ls lt lu lv b">OutlinedTextField</code>作为参数传递给它。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mt mu l"/></div></figure><p id="e2ee" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">因此，我们开发了一种统一的方法来构建功能之间以及同一功能内的私人屏幕之间的导航。</p></div><div class="ab cl mw mx hu my" role="separator"><span class="mz bw bk na nb nc"/><span class="mz bw bk na nb nc"/><span class="mz bw bk na nb"/></div><div class="ij ik il im in"><h1 id="f24d" class="lw lx iq bd ly lz nd mb mc md ne mf mg jw nf jx mi jz ng ka mk kc nh kd mm mn bi translated"><strong class="ak">结论</strong></h1><p id="21ed" class="pw-post-body-paragraph kw kx iq ky b kz mo jr lb lc mp ju le lf mq lh li lj mr ll lm ln ms lp lq lr ij bi translated">在这里，我分享了我用Compose Navigation组织多模块项目的愿景。我知道这个解决方案和其他方案一样有缺点。在我们的例子中，是特性的相对连接性(通过API)和创建额外API模块的必要性。</p><p id="48ee" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我期望，从长远来看，一个添加功能和新屏幕的“框架”将会积极地影响项目的开发速度——并且还可以防止突然的代码崩溃。</p><p id="732c" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我将很高兴听到您在使用Compose构建应用程序的架构和导航方面的经验！</p></div></div>    
</body>
</html>