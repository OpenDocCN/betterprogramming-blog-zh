<html>
<head>
<title>Implement a Golang Generic Function to Handle Any HTTP Request</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">实现一个Golang通用函数来处理任何HTTP请求</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/golang-a-powerful-generic-function-to-make-any-http-request-b4d660834c10?source=collection_archive---------0-----------------------#2022-11-11">https://betterprogramming.pub/golang-a-powerful-generic-function-to-make-any-http-request-b4d660834c10?source=collection_archive---------0-----------------------#2022-11-11</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="1c2e" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">这个强大的函数可以处理任何HTTP请求！</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/2bcbd0caddcb7aba45abeeb15ab548be.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ZFbLM6iknluU3cLiVptpDw.jpeg"/></div></div></figure><p id="77b2" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">在我在<a class="ae ln" href="https://inclub-app.com/" rel="noopener ugc nofollow" target="_blank"> InClub </a>工作期间，我构建了一个通用的HTTP请求助手函数，我们可以在后台使用它。到目前为止，这个函数对我们抛出的每种类型的HTTP调用都有效。一些例子:</p><ul class=""><li id="5e30" class="lo lp iq kt b ku kv kx ky la lq le lr li ls lm lt lu lv lw bi translated"><code class="fe lx ly lz ma b">POST</code> ing to <a class="ae ln" href="https://www.deepl.com/docs-api/translate-text/" rel="noopener ugc nofollow" target="_blank"> DeepL的翻译文本API </a></li><li id="b2e8" class="lo lp iq kt b ku mb kx mc la md le me li mf lm lt lu lv lw bi translated"><code class="fe lx ly lz ma b">GET</code> / <code class="fe lx ly lz ma b">POST</code>到<a class="ae ln" href="https://developers.facebook.com/docs/instagram-api/" rel="noopener ugc nofollow" target="_blank"> Instagram的图形API </a></li><li id="560e" class="lo lp iq kt b ku mb kx mc la md le me li mf lm lt lu lv lw bi translated"><code class="fe lx ly lz ma b">GET</code> / <code class="fe lx ly lz ma b">POST</code> / <code class="fe lx ly lz ma b">DELETE</code>至<a class="ae ln" href="https://sendbird.com/docs/chat/v3/platform-api/overview" rel="noopener ugc nofollow" target="_blank">仙鸟聊天平台API </a></li></ul><p id="60eb" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">我想我应该与世界分享这个函数，因为它是如何使用Go的通用功能的一个很好的真实例子。我将对如何构建这个函数做一个完整的演示，但是如果您只是想要这个函数，请跳到“完整代码片段”部分。</p><p id="34d0" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">在这篇文章的其余部分，我将假设我们在一个名为<code class="fe lx ly lz ma b">http_helper</code>的包中编写通用函数。这是在示例存储库中使用的名称。</p><h1 id="80ad" class="mg mh iq bd mi mj mk ml mm mn mo mp mq jw mr jx ms jz mt ka mu kc mv kd mw mx bi translated">入门-函数签名</h1><p id="52be" class="pw-post-body-paragraph kr ks iq kt b ku my jr kw kx mz ju kz la na lc ld le nb lg lh li nc lk ll lm ij bi translated">让我们从函数的签名开始。我们把函数命名为<code class="fe lx ly lz ma b">MakeHTTPRequest</code>；这很简单。这是一个非常灵活的函数，但是我们有一系列参数要接受:</p><ul class=""><li id="a2f2" class="lo lp iq kt b ku kv kx ky la lq le lr li ls lm lt lu lv lw bi translated">我们需要期望的端点，我们称之为<code class="fe lx ly lz ma b">fullUrl</code>，类型<code class="fe lx ly lz ma b">string</code></li><li id="c7c6" class="lo lp iq kt b ku mb kx mc la md le me li mf lm lt lu lv lw bi translated">我声称我们可以处理<code class="fe lx ly lz ma b">GET</code> s、<code class="fe lx ly lz ma b">POST</code> s和任何其他HTTP方法，我们还需要接受一个HTTP方法作为参数——我们称它为<code class="fe lx ly lz ma b">httpMethod</code>，类型<code class="fe lx ly lz ma b">string</code>(参见下面我们为什么选择使用<code class="fe lx ly lz ma b">string</code>)</li><li id="acb2" class="lo lp iq kt b ku mb kx mc la md le me li mf lm lt lu lv lw bi translated"><code class="fe lx ly lz ma b">headers</code>，键入<code class="fe lx ly lz ma b">map[string]string</code>以应用于HTTP调用</li><li id="0cb3" class="lo lp iq kt b ku mb kx mc la md le me li mf lm lt lu lv lw bi translated">查询参数(在<code class="fe lx ly lz ma b">GET</code>的情况下)，称为<code class="fe lx ly lz ma b">queryParameters</code>，类型为<code class="fe lx ly lz ma b">url.Values</code>，</li><li id="5c5f" class="lo lp iq kt b ku mb kx mc la md le me li mf lm lt lu lv lw bi translated">一个主体(在<code class="fe lx ly lz ma b">POST</code>或<code class="fe lx ly lz ma b">PUT</code>的情况下)，称为<code class="fe lx ly lz ma b">body</code>，类型为<code class="fe lx ly lz ma b">io.Reader</code></li><li id="52df" class="lo lp iq kt b ku mb kx mc la md le me li mf lm lt lu lv lw bi translated">最后，泛型开始为我们期望得到的类型服务——我们称之为<code class="fe lx ly lz ma b">T</code></li><li id="d16c" class="lo lp iq kt b ku mb kx mc la md le me li mf lm lt lu lv lw bi translated">对于返回类型，我们必须处理任何可能发生的错误，所以我们将使用经典的go模式，返回一个<code class="fe lx ly lz ma b">error</code>作为最后的返回值</li></ul><p id="77ef" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">总之，这个强大函数的签名如下所示:</p><pre class="kg kh ki kj gt nd ma ne bn nf ng bi"><span id="5d73" class="nh mh iq ma b be ni nj l nk nl">func MakeHTTPRequest[T any](fullUrl string, httpMethod string, headers map[string]string, queryParameters url.Values, body io.Reader, responseType T) (T, error)</span></pre><h1 id="9f4b" class="mg mh iq bd mi mj mk ml mm mn mo mp mq jw mr jx ms jz mt ka mu kc mv kd mw mx bi translated">编写函数体</h1><p id="d485" class="pw-post-body-paragraph kr ks iq kt b ku my jr kw kx mz ju kz la na lc ld le nb lg lh li nc lk ll lm ij bi translated">让我们进入函数体。为了构建HTTP客户端，我们将使用Go的内置<code class="fe lx ly lz ma b">net/http</code>包:</p><pre class="kg kh ki kj gt nd ma ne bn nf ng bi"><span id="e409" class="nh mh iq ma b be ni nj l nk nl">client := http.Client{}</span></pre><p id="0c62" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">然后我们需要解析URL以确保它是有效的:</p><pre class="kg kh ki kj gt nd ma ne bn nf ng bi"><span id="a4e3" class="nh mh iq ma b be ni nj l nk nl">u, err := url.Parse(fullUrl)<br/>if err != nil {<br/>  return responseType, err<br/>}</span></pre><p id="b750" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">现在我们可以处理GET情况，使用这个URL变量<code class="fe lx ly lz ma b"><strong class="kt ir">u</strong></code>来添加查询参数:</p><pre class="kg kh ki kj gt nd ma ne bn nf ng bi"><span id="7c1b" class="nh mh iq ma b be ni nj l nk nl">// if it's a GET, we need to append the query parameters.<br/>if httpMethod == "GET" {<br/>    q := u.Query()<br/><br/>    for k, v := range queryParameters {<br/>        // this depends on the type of api, you may need to do it for each of v<br/>        q.Set(k, strings.Join(v, ","))<br/>    }<br/>    // set the query to the encoded parameters<br/>    u.RawQuery = q.Encode()<br/>}</span></pre><p id="41e8" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">我们可以通过传入参数<code class="fe lx ly lz ma b">body</code>来创建请求:</p><pre class="kg kh ki kj gt nd ma ne bn nf ng bi"><span id="22c9" class="nh mh iq ma b be ni nj l nk nl">// regardless of GET or POST, we can safely add the body<br/>req, err := http.NewRequest(httpMethod, u.String(), body)<br/>if err != nil {<br/>    return responseType, err<br/>}</span></pre><p id="fbf1" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">现在我们可以添加标题了:</p><pre class="kg kh ki kj gt nd ma ne bn nf ng bi"><span id="10c0" class="nh mh iq ma b be ni nj l nk nl">// for each header passed, add the header value to the request<br/>for k, v := range headers {<br/>  req.Header.Set(k, v)<br/>}</span></pre><p id="8a00" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">使用<code class="fe lx ly lz ma b">net/http</code>的<code class="fe lx ly lz ma b">Do</code>函数，我们可以发出请求:</p><pre class="kg kh ki kj gt nd ma ne bn nf ng bi"><span id="91f3" class="nh mh iq ma b be ni nj l nk nl">// finally, do the request<br/>res, err := client.Do(req)</span></pre><p id="841c" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">然后，我们进行各种检查来验证请求是否成功:</p><pre class="kg kh ki kj gt nd ma ne bn nf ng bi"><span id="d762" class="nh mh iq ma b be ni nj l nk nl">if err != nil {<br/>  return responseType, err<br/>}<br/>if res == nil {<br/>  return responseType, fmt.Errorf("error: calling %s returned empty response", u.String())<br/>}<br/>responseData, err := io.ReadAll(res.Body)<br/>if err != nil {<br/>  return responseType, err<br/>}<br/>defer res.Body.Close()<br/>if res.StatusCode != http.StatusOK {<br/>  return responseType, fmt.Errorf("error calling %s:\nstatus: %s\nresponseData: %s", u.String(), res.Status, responseData)<br/>}</span></pre><p id="d4ea" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">我们终于到了这个函数强大的通用部分。我们使用<code class="fe lx ly lz ma b">encoding/json</code>包将响应数据解组成我们期望的类型。如果<code class="fe lx ly lz ma b">encoding/json</code>包无法解组到指定的类型，我们会抛出一个错误:</p><pre class="kg kh ki kj gt nd ma ne bn nf ng bi"><span id="97a3" class="nh mh iq ma b be ni nj l nk nl">var responseObject T<br/>err = json.Unmarshal(responseData, &amp;responseObject)<br/>if err != nil {<br/>  log.Printf("error unmarshaling response: %+v", err)<br/>  return responseType, err<br/>}</span></pre><p id="5194" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">如果解组成功，我们可以返回响应对象和一个<code class="fe lx ly lz ma b"><strong class="kt ir">nil</strong></code>错误:</p><pre class="kg kh ki kj gt nd ma ne bn nf ng bi"><span id="aed8" class="nh mh iq ma b be ni nj l nk nl">return responseObject, nil</span></pre><h1 id="4567" class="mg mh iq bd mi mj mk ml mm mn mo mp mq jw mr jx ms jz mt ka mu kc mv kd mw mx bi translated">完整的代码片段</h1><p id="a63e" class="pw-post-body-paragraph kr ks iq kt b ku my jr kw kx mz ju kz la na lc ld le nb lg lh li nc lk ll lm ij bi translated">就是这样！我们构建了一个通用函数，可以处理任何类型的HTTP调用。以下是完整的代码:</p><pre class="kg kh ki kj gt nd ma ne bn nf ng bi"><span id="c556" class="nh mh iq ma b be ni nj l nk nl">package http_helper<br/><br/>import (<br/> "encoding/json"<br/> "fmt"<br/> "io"<br/> "log"<br/> "net/http"<br/> "net/url"<br/> "strings"<br/>)<br/><br/>// in the case of GET, the parameter queryParameters is transferred to the URL as query parameters<br/>// in the case of POST, the parameter body, an io.Reader, is used<br/>func MakeHTTPRequest[T any](fullUrl string, httpMethod string, headers map[string]string, queryParameters url.Values, body io.Reader, responseType T) (T, error) {<br/> client := http.Client{}<br/> u, err := url.Parse(fullUrl)<br/> if err != nil {<br/>  return responseType, err<br/> }<br/><br/> // if it's a GET, we need to append the query parameters.<br/> if httpMethod == "GET" {<br/>  q := u.Query()<br/><br/>  for k, v := range queryParameters {<br/>   // this depends on the type of api, you may need to do it for each of v<br/>   q.Set(k, strings.Join(v, ","))<br/>  }<br/>  // set the query to the encoded parameters<br/>  u.RawQuery = q.Encode()<br/> }<br/><br/>    // regardless of GET or POST, we can safely add the body<br/> req, err := http.NewRequest(httpMethod, u.String(), body)<br/> if err != nil {<br/>  return responseType, err<br/> }<br/><br/> // for each header passed, add the header value to the request<br/> for k, v := range headers {<br/>  req.Header.Set(k, v)<br/> }<br/><br/>    // optional: log the request for easier stack tracing<br/> log.Printf("%s %s\n", httpMethod, req.URL.String())<br/><br/> // finally, do the request<br/> res, err := client.Do(req)<br/> if err != nil {<br/>  return responseType, err<br/> }<br/><br/> if res == nil {<br/>  return responseType, fmt.Errorf("error: calling %s returned empty response", u.String())<br/> }<br/><br/> responseData, err := io.ReadAll(res.Body)<br/> if err != nil {<br/>  return responseType, err<br/> }<br/><br/> defer res.Body.Close()<br/><br/> if res.StatusCode != http.StatusOK {<br/>  return responseType, fmt.Errorf("error calling %s:\nstatus: %s\nresponseData: %s", u.String(), res.Status, responseData)<br/> }<br/><br/> var responseObject T<br/> err = json.Unmarshal(responseData, &amp;responseObject)<br/><br/> if err != nil {<br/>  log.Printf("error unmarshaling response: %+v", err)<br/>  return responseType, err<br/> }<br/><br/> return responseObject, nil<br/>}</span></pre><h1 id="17c1" class="mg mh iq bd mi mj mk ml mm mn mo mp mq jw mr jx ms jz mt ka mu kc mv kd mw mx bi translated">用法示例</h1><h2 id="35ac" class="nm mh iq bd mi nn no dn mm np nq dp mq la nr ns ms le nt nu mu li nv nw mw nx bi translated">获取请求</h2><pre class="kg kh ki kj gt nd ma ne bn nf ng bi"><span id="b5f0" class="nh mh iq ma b be ni nj l nk nl">package main<br/><br/>import (<br/>    "net/url"<br/>    "http_helper/http_helper"<br/>)<br/><br/>func main() {<br/>    // the url to call<br/>    url := "https://api.github.com/users/alexellis"<br/><br/>    // the headers to pass<br/>    headers := map[string]string{<br/>        "Accept": "application/vnd.github.v3+json",<br/>    }<br/><br/>    // the query parameters to pass<br/>    queryParameters := url.Values{}<br/>    queryParameters.Add("per_page", "1")<br/><br/>    // the type to unmarshal the response into<br/>    var response map[string]interface{}<br/><br/>    // call the function<br/>    response, err := http_helper.MakeHTTPRequest(url, "GET", headers, queryParameters, nil, response)<br/>    if err != nil {<br/>        panic(err)<br/>    }<br/><br/>    // do something with the response<br/>    fmt.Printf("response: %+v", response)<br/>}</span></pre><h2 id="495a" class="nm mh iq bd mi nn no dn mm np nq dp mq la nr ns ms le nt nu mu li nv nw mw nx bi translated">发布请求</h2><pre class="kg kh ki kj gt nd ma ne bn nf ng bi"><span id="0dfe" class="nh mh iq ma b be ni nj l nk nl">package main<br/><br/>import (<br/>    "bytes"<br/>    "net/url"<br/>    "http_helper/http_helper"<br/>)<br/><br/>func main() {<br/>    // the url to call<br/>    url := "https://api.github.com/users/alexellis"<br/><br/>    // the headers to pass<br/>    headers := map[string]string{<br/>        "Accept": "application/vnd.github.v3+json",<br/>    }<br/><br/>    // the query parameters to pass<br/>    queryParameters := url.Values{}<br/>    queryParameters.Add("per_page", "1")<br/><br/>    // the body to pass<br/>    body := bytes.NewBufferString(`{"name": "test"}`)<br/><br/>    // the type to unmarshal the response into<br/>    var response map[string]interface{}<br/><br/>    // call the function<br/>    response, err := http_helper.MakeHTTPRequest(url, "POST", headers, queryParameters, body, response)<br/>    if err != nil {<br/>        panic(err)<br/>    }<br/><br/>    // do something with the response<br/>    fmt.Printf("response: %+v", response)<br/>}</span></pre><h1 id="37e5" class="mg mh iq bd mi mj mk ml mm mn mo mp mq jw mr jx ms jz mt ka mu kc mv kd mw mx bi translated">示例存储库</h1><p id="05b6" class="pw-post-body-paragraph kr ks iq kt b ku my jr kw kx mz ju kz la na lc ld le nb lg lh li nc lk ll lm ij bi translated">通用函数以及上面的用例可以在范例库中找到<a class="ae ln" href="https://github.com/princefishthrower/golang-generic-http-helper-function.git" rel="noopener ugc nofollow" target="_blank">。关于运行代码的最新说明可以在自述文件中找到。</a></p><h1 id="034c" class="mg mh iq bd mi mj mk ml mm mn mo mp mq jw mr jx ms jz mt ka mu kc mv kd mw mx bi translated">额外收获:正确检查或键入<code class="fe lx ly lz ma b">httpMethod</code>参数</h1><p id="8648" class="pw-post-body-paragraph kr ks iq kt b ku my jr kw kx mz ju kz la na lc ld le nb lg lh li nc lk ll lm ij bi translated">正如我们在最初的实现中看到的，即使在官方的go类型化中，HTTP方法也只是简单的类型化。我们决定不执行任何检查的原因是，只有五种方法- <code class="fe lx ly lz ma b">GET</code>、<code class="fe lx ly lz ma b">POST</code>、<code class="fe lx ly lz ma b">PUT</code>、<code class="fe lx ly lz ma b">PATCH</code>和<code class="fe lx ly lz ma b">DELETE</code>，而且它们不太可能在短期内改变！然而，它<em class="ny">是</em>当然，当调用这个函数(即<code class="fe lx ly lz ma b">GET</code>)时，仍然有可能在方法字段上出现拼写错误，所以你和你的团队可能会决定使类型更严格一点。你有两个选择:</p><h2 id="2afa" class="nm mh iq bd mi nn no dn mm np nq dp mq la nr ns ms le nt nu mu li nv nw mw nx bi translated">备选方案1。简单的选择——正则表达式</h2><p id="1887" class="pw-post-body-paragraph kr ks iq kt b ku my jr kw kx mz ju kz la na lc ld le nb lg lh li nc lk ll lm ij bi translated">将传递的字符串与所有五个HTTP方法的正则表达式进行匹配。这是一个不太复杂的选项，但是它不是类型安全的。我们可以使用下面的正则表达式:</p><pre class="kg kh ki kj gt nd ma ne bn nf ng bi"><span id="bf25" class="nh mh iq ma b be ni nj l nk nl">// compile regex to test httpMethod<br/>regex := regexp.MustCompile(`^(GET|POST|PUT|PATCH|DELETE)$`)<br/><br/>// check if httpMethod is valid<br/>if !regex.MatchString(httpMethod) {<br/>    return responseType, fmt.Errorf("invalid HTTP method: %s", httpMethod)<br/>}</span></pre><h2 id="7aa0" class="nm mh iq bd mi nn no dn mm np nq dp mq la nr ns ms le nt nu mu li nv nw mw nx bi translated"><strong class="ak">选项2。更复杂的选项-枚举</strong></h2><p id="6caf" class="pw-post-body-paragraph kr ks iq kt b ku my jr kw kx mz ju kz la na lc ld le nb lg lh li nc lk ll lm ij bi translated">我们可以像这样创建一个enum和<code class="fe lx ly lz ma b">String</code>方法:</p><pre class="kg kh ki kj gt nd ma ne bn nf ng bi"><span id="c22c" class="nh mh iq ma b be ni nj l nk nl">type HTTPMethod int<br/><br/>const (<br/> GET HTTPMethod = iota<br/> POST<br/> PUT<br/> PATCH<br/> DELETE<br/>)<br/><br/>func (s HTTPMethod) String() string {<br/> switch s {<br/> case GET:<br/>  return "GET"<br/> case POST:<br/>  return "POST"<br/> case PUT:<br/>  return "PUT"<br/> case PATCH:<br/>  return "PATCH"<br/> case DELETE:<br/>  return "DELETE"<br/> }<br/> return "unknown"<br/>}</span></pre><p id="cd62" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">然后，将<code class="fe lx ly lz ma b">httpMethod</code>的类型从<code class="fe lx ly lz ma b">string</code>更改为<code class="fe lx ly lz ma b">HTTPMethod</code>:</p><pre class="kg kh ki kj gt nd ma ne bn nf ng bi"><span id="6c1c" class="nh mh iq ma b be ni nj l nk nl">func MakeHTTPRequest[T any](fullUrl string, httpMethod HTTPMethod, headers map[string]string, queryParameters url.Values, body io.Reader, responseType T) (T, error) {</span></pre><p id="98a4" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">我们必须修改<code class="fe lx ly lz ma b">if</code>语句来比较新的<code class="fe lx ly lz ma b">GET</code>类型，而不是字符串<code class="fe lx ly lz ma b">"GET"</code>:</p><pre class="kg kh ki kj gt nd ma ne bn nf ng bi"><span id="831e" class="nh mh iq ma b be ni nj l nk nl">if httpMethod == GET {<br/>  // ...code here...<br/>}</span></pre><p id="645c" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">当我们调用<code class="fe lx ly lz ma b">http.NewRequest</code>时，我们需要将<code class="fe lx ly lz ma b">httpMethod</code>转换成一个字符串:</p><pre class="kg kh ki kj gt nd ma ne bn nf ng bi"><span id="f4e0" class="nh mh iq ma b be ni nj l nk nl">req, err := http.NewRequest(string(httpMethod), u.String(), body)</span></pre><p id="4dea" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">选项#2可能有点过度设计，但它也是最类型安全的。你想用哪个由你自己决定。如上所述，我们的团队已经决定放弃对<code class="fe lx ly lz ma b">httpMethod</code>参数的任何检查，因为我们在我们的后端进行了广泛的<a class="ae ln" href="http://localhost:8000/blog/one-year-as-chief-technology-officer-at-inclub-insights-from-startup-land/" rel="noopener ugc nofollow" target="_blank">单元和集成测试</a>，通过请求错误的方式，可以捕捉到传递给<code class="fe lx ly lz ma b">MakeHTTPRequest</code>的HTTP方法中的任何打字错误。</p></div><div class="ab cl nz oa hu ob" role="separator"><span class="oc bw bk od oe of"/><span class="oc bw bk od oe of"/><span class="oc bw bk od oe"/></div><div class="ij ik il im in"><p id="4add" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">我希望你喜欢这篇文章！我真的很喜欢用Go构建后端基础设施是如此的简单。我期待着在未来发布更多的Go内容。</p></div><div class="ab cl nz oa hu ob" role="separator"><span class="oc bw bk od oe of"/><span class="oc bw bk od oe of"/><span class="oc bw bk od oe"/></div><div class="ij ik il im in"><p id="7f7d" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">想用本文中使用的通用软件技能来提升你的游戏吗？</p><p id="7f54" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">查看我的课程《高级打字稿:通用搜索、排序和过滤》，可以在<a class="ae ln" href="https://www.udemy.com/course/advanced-typescript-generic-search-sorting-and-filtering/?referralCode=22441D8B6B06045473D2" rel="noopener ugc nofollow" target="_blank"> Udemy </a>和<a class="ae ln" href="https://skl.sh/3EqkUTz" rel="noopener ugc nofollow" target="_blank"> Skillshare </a>上找到。</p></div></div>    
</body>
</html>