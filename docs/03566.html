<html>
<head>
<title>React Router: What’s the Difference Between Components and Routes?</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">React路由器:组件和路由有什么区别？</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/react-router-whats-the-difference-between-components-and-routes-d242f41b111d?source=collection_archive---------5-----------------------#2020-02-18">https://betterprogramming.pub/react-router-whats-the-difference-between-components-and-routes-d242f41b111d?source=collection_archive---------5-----------------------#2020-02-18</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="2957" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">无忧无虑，像专业人士一样享受React路由器</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/a622ee10a0b0f5d9bf004c0eba593872.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*b2RNPsqB0oPgHqyXn8cYAg.jpeg"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated"><a class="ae ky" href="https://www.pexels.com/photo/drive-empty-highway-lane-210112/" rel="noopener ugc nofollow" target="_blank">66号公路印在从<a class="ae ky" href="http://Pexels.com" rel="noopener ugc nofollow" target="_blank">Pexels.com</a>出发的</a>公路上</p></figure><p id="b9f4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><a class="ae ky" href="https://reacttraining.com/react-router/web/guides/primary-components" rel="noopener ugc nofollow" target="_blank"> React路由器(DOM </a>)是一个令人惊叹的NPM包，让你逃离SPA的地狱。根据我的教学经验，我发现人们并不经常钻研文档。相反，他们会看到一些代码示例，并通过创建他们的应用程序来进行模式匹配。这完全没问题…直到它不是。</p><p id="70ff" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我注意到新程序员对<code class="fe lv lw lx ly b">render={this.renderComponent}</code>或<code class="fe lv lw lx ly b">component={ComponentName}</code>有强烈的习惯和偏好。随后，他们遇到了麻烦。虽然两者都起作用，但它们的行为不同。我来解释一下原因。</p></div><div class="ab cl lz ma hx mb" role="separator"><span class="mc bw bk md me mf"/><span class="mc bw bk md me mf"/><span class="mc bw bk md me"/></div><div class="im in io ip iq"><h1 id="4e38" class="mg mh it bd mi mj mk ml mm mn mo mp mq jz mr ka ms kc mt kd mu kf mv kg mw mx bi translated">设置</h1><p id="774d" class="pw-post-body-paragraph kz la it lb b lc my ju le lf mz jx lh li na lk ll lm nb lo lp lq nc ls lt lu im bi translated">首先，让我们看一些代码。让我们假设我们有一个类组件，它从它的父组件获得一个用户数组。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nd ne l"/></div></figure><p id="64d4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如你所见，我们在第20行渲染了<code class="fe lv lw lx ly b">homepage</code>组件，然后在下一行渲染了<code class="fe lv lw lx ly b">Profile</code>组件。我们将用户对象的附加属性传递给<code class="fe lv lw lx ly b">Profile</code>组件。您可以使用<code class="fe lv lw lx ly b">render</code> <em class="nf">或</em> <code class="fe lv lw lx ly b">component</code>将一个给定的React组件与一个路径相关联——但是您应该使用哪个<em class="nf"/>？</p></div><div class="ab cl lz ma hx mb" role="separator"><span class="mc bw bk md me mf"/><span class="mc bw bk md me mf"/><span class="mc bw bk md me"/></div><div class="im in io ip iq"><h1 id="6253" class="mg mh it bd mi mj mk ml mm mn mo mp mq jz mr ka ms kc mt kd mu kf mv kg mw mx bi translated">组件还是渲染？</h1><p id="6cef" class="pw-post-body-paragraph kz la it lb b lc my ju le lf mz jx lh li na lk ll lm nb lo lp lq nc ls lt lu im bi translated">现在，想象你首先访问你的个人资料，然后你去主页，然后你再次访问你的个人资料。在这种情况下:</p><ul class=""><li id="2e00" class="ng nh it lb b lc ld lf lg li ni lm nj lq nk lu nl nm nn no bi translated"><code class="fe lv lw lx ly b">render</code>使组件只挂载一次，然后在需要时重新渲染。组件留在后台——这意味着您放入<code class="fe lv lw lx ly b">componentDidMount</code>、<code class="fe lv lw lx ly b">constructor</code>或<code class="fe lv lw lx ly b">shouldComponentUpdate</code>的任何内容都将只运行一次！此外，由于组件没有卸载，您可能会遇到数据泄漏。您可以强制组件重新呈现，但是这种果汁值得压榨吗？</li><li id="1d25" class="ng nh it lb b lc np lf nq li nr lm ns lq nt lu nl nm nn no bi translated">另一方面，<code class="fe lv lw lx ly b">component</code>会在每次访问时重新实例化该组件(该组件会被装载、卸载，如果您进行了访问，还会再次装载)。这个语法是对<code class="fe lv lw lx ly b">React.createElement</code> — <strong class="lb iu">的抽象，因此在性能方面效率较低，但在某些情况下更有必要。</strong></li></ul><p id="359f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><em class="nf">一般来说，</em> <code class="fe lv lw lx ly b"><em class="nf">render</em></code> <em class="nf">最适合功能组件，因为它们默认没有生命周期方法，而</em> <code class="fe lv lw lx ly b"><em class="nf">component</em></code> <em class="nf">最适合类组件。</em></p></div><div class="ab cl lz ma hx mb" role="separator"><span class="mc bw bk md me mf"/><span class="mc bw bk md me mf"/><span class="mc bw bk md me"/></div><div class="im in io ip iq"><h1 id="5e74" class="mg mh it bd mi mj mk ml mm mn mo mp mq jz mr ka ms kc mt kd mu kf mv kg mw mx bi translated">获取路线道具和道具</h1><p id="0d1f" class="pw-post-body-paragraph kz la it lb b lc my ju le lf mz jx lh li na lk ll lm nb lo lp lq nc ls lt lu im bi translated">当涉及到访问<a class="ae ky" href="https://reacttraining.com/react-router/web/api/Route/route-props" rel="noopener ugc nofollow" target="_blank">路由道具</a>，即<code class="fe lv lw lx ly b">history</code>、<code class="fe lv lw lx ly b">location</code>和<code class="fe lv lw lx ly b">match</code>时，你可以用React Router在两个选项中默认免费获得它们，即使你没有明确地通过它们。传递道具也是一样——使用<code class="fe lv lw lx ly b">render</code>或<code class="fe lv lw lx ly b">component</code>不会影响你传递道具的能力。</p></div></div>    
</body>
</html>