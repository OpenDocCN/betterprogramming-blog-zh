<html>
<head>
<title>NestJS Controllers Deep Dive</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">NestJS控制器深潜</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/nestjs-controllers-deep-dive-5c49e19d0941?source=collection_archive---------8-----------------------#2020-01-06">https://betterprogramming.pub/nestjs-controllers-deep-dive-5c49e19d0941?source=collection_archive---------8-----------------------#2020-01-06</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="3552" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">探索控制器；NestJS最重要的部分</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/7cf9e0edba27d336d9bcbce2e39b71bf.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*oTbTuBA4_RtKoXCsZ-ybKQ.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">NestJS标志</p></figure><p id="b265" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">在这篇博文中，我们将探讨控制器，它是NestJS最重要的部分。</p></div><div class="ab cl lr ls hu lt" role="separator"><span class="lu bw bk lv lw lx"/><span class="lu bw bk lv lw lx"/><span class="lu bw bk lv lw"/></div><div class="ij ik il im in"><h1 id="b2f0" class="ly lz iq bd ma mb mc md me mf mg mh mi jw mj jx mk jz ml ka mm kc mn kd mo mp bi translated">为什么我们需要控制器</h1><p id="1417" class="pw-post-body-paragraph kv kw iq kx b ky mq jr la lb mr ju ld le ms lg lh li mt lk ll lm mu lo lp lq ij bi translated">控制器负责处理发送到服务器的请求，控制器公开多个端点，客户端可以在这些端点发送请求。每个端点都由一个HTTP方法标识，也称为HTTP verb。</p><h2 id="5dee" class="mv lz iq bd ma mw mx dn me my mz dp mi le na nb mk li nc nd mm lm ne nf mo ng bi translated">HTTP动词</h2><ul class=""><li id="2691" class="nh ni iq kx b ky mq lb mr le nj li nk lm nl lq nm nn no np bi translated">GET:GET方法是从服务器获取数据，可以是单个记录，也可以是多个记录。我们也可以传递一些参数来过滤记录。</li><li id="6d98" class="nh ni iq kx b ky nq lb nr le ns li nt lm nu lq nm nn no np bi translated">POST:当我们想要在数据库中创建一些记录时，使用POST方法。在我们希望根据发送到服务器的信息过滤一些记录的情况下，我们也可以使用POST请求，例如，提供一个高级过滤器。</li><li id="0db3" class="nh ni iq kx b ky nq lb nr le ns li nt lm nu lq nm nn no np bi translated">PUT:PUT方法用于更新数据库中的记录。在<code class="fe nv nw nx ny b">Put</code>方法中，我们期望我们发送的任何数据都将被更新。</li><li id="cb83" class="nh ni iq kx b ky nq lb nr le ns li nt lm nu lq nm nn no np bi translated">PATCH:当我们只想修改而不是替换数据库中的所有值时，使用PATCH方法。</li><li id="083a" class="nh ni iq kx b ky nq lb nr le ns li nt lm nu lq nm nn no np bi translated">DELETE:<strong class="kx ir"/><strong class="kx ir"/>DELETE方法在我们想从服务器上删除一些记录的时候使用。</li></ul><h2 id="5a94" class="mv lz iq bd ma mw mx dn me my mz dp mi le na nb mk li nc nd mm lm ne nf mo ng bi translated">HTTP状态代码</h2><p id="82bb" class="pw-post-body-paragraph kv kw iq kx b ky mq jr la lb mr ju ld le ms lg lh li mt lk ll lm mu lo lp lq ij bi translated">另一件你必须知道的事情是HTTP状态码。您可以参考<a class="ae nz" href="https://developer.mozilla.org/en-US/docs/Web/HTTP/Status" rel="noopener ugc nofollow" target="_blank"> Mozilla文档</a>获取状态代码列表。POST方法返回<code class="fe nv nw nx ny b">201</code>作为成功的状态码，其他方法返回<code class="fe nv nw nx ny b">200</code>作为状态码。</p></div><div class="ab cl lr ls hu lt" role="separator"><span class="lu bw bk lv lw lx"/><span class="lu bw bk lv lw lx"/><span class="lu bw bk lv lw"/></div><div class="ij ik il im in"><h1 id="1cfc" class="ly lz iq bd ma mb mc md me mf mg mh mi jw mj jx mk jz ml ka mm kc mn kd mo mp bi translated">创造我们的第一个控制器</h1><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi oa"><img src="../Images/4b454260e63391bdb5eaa4eac22db8dc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1256/format:webp/1*5nTOOPVIzQlND1s02IMX-A.jpeg"/></div></figure><p id="0d7a" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">上图显示了一个<code class="fe nv nw nx ny b">ProductController</code>，它将接受来自客户端的请求，请求由一个已定义的端点/方法处理。HTTP方法可以接收HTTP请求，并以JSON、XML、文件或文本的形式返回HTTP响应。</p><p id="8594" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">要创建一个控制器，我们可以使用<a class="ae nz" href="https://docs.nestjs.com/cli/overview" rel="noopener ugc nofollow" target="_blank">嵌套CLI </a>，在我们的应用程序中，我们已经有一个可用的控制器，我们将创建一个名为<code class="fe nv nw nx ny b">product</code>的新控制器，运行下面的命令来创建。</p><pre class="kg kh ki kj gt ob ny oc od aw oe bi"><span id="6cac" class="mv lz iq ny b gy of og l oh oi">nest generate controller product -p default</span></pre><p id="aed1" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated"><code class="fe nv nw nx ny b">-p</code>标志将确保控制器是在默认应用程序中创建的，否则，您可以传递您想要创建控制器的产品名称。</p><p id="8cb7" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">一旦命令被执行，您将会注意到两个新文件。</p><ul class=""><li id="2587" class="nh ni iq kx b ky kz lb lc le oj li ok lm ol lq nm nn no np bi translated">产品.控制器. ts</li><li id="ffed" class="nh ni iq kx b ky nq lb nr le ns li nt lm nu lq nm nn no np bi translated">产品.控制器.规格(用于单元测试)</li></ul><p id="03cf" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">我们需要在<code class="fe nv nw nx ny b">product.controller.ts</code>中编写代码。如果你现在打开这个文件，你会发现下面的代码。</p><pre class="kg kh ki kj gt ob ny oc od aw oe bi"><span id="64ca" class="mv lz iq ny b gy of og l oh oi">import { Controller } from '@nestjs/common';</span><span id="11a7" class="mv lz iq ny b gy om og l oh oi">@Controller('product')<br/>export class ProductController {}</span></pre><ul class=""><li id="dadd" class="nh ni iq kx b ky kz lb lc le oj li ok lm ol lq nm nn no np bi translated"><code class="fe nv nw nx ny b">@Controller</code> : <strong class="kx ir"> </strong>控制器装饰器追加在<code class="fe nv nw nx ny b">ProductController</code>类之上。如果您来自. Net或Java背景，那么您在创建web APIs时已经使用过了。它接受一个参数，您可以将请求发送到这个端点。</li></ul></div><div class="ab cl lr ls hu lt" role="separator"><span class="lu bw bk lv lw lx"/><span class="lu bw bk lv lw lx"/><span class="lu bw bk lv lw"/></div><div class="ij ik il im in"><h1 id="9877" class="ly lz iq bd ma mb mc md me mf mg mh mi jw mj jx mk jz ml ka mm kc mn kd mo mp bi translated">添加我们的第一个方法</h1><p id="48e1" class="pw-post-body-paragraph kv kw iq kx b ky mq jr la lb mr ju ld le ms lg lh li mt lk ll lm mu lo lp lq ij bi translated">让我们添加我们的第一个<code class="fe nv nw nx ny b">Get</code>方法，它将返回一个产品列表。我们将创建一个虚拟的产品列表，我们将在下一篇文章中看到数据库集成。</p><p id="19dc" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">打开<code class="fe nv nw nx ny b">product.controller.ts</code>并添加以下代码:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="on oo l"/></div></figure><p id="5e05" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">突出显示的代码是我们为创建<code class="fe nv nw nx ny b">Get</code>方法而添加的代码。</p><ul class=""><li id="00cc" class="nh ni iq kx b ky kz lb lc le oj li ok lm ol lq nm nn no np bi translated"><code class="fe nv nw nx ny b">@Get</code> : <strong class="kx ir"> </strong>这里的Get decorator指定当客户端在<code class="fe nv nw nx ny b"><a class="ae nz" href="https://endpoint" rel="noopener ugc nofollow" target="_blank">https://endpoint</a>/product</code>用<code class="fe nv nw nx ny b">Get</code> HTTP方法发送请求时，将调用<code class="fe nv nw nx ny b">GetProducts</code>。</li></ul><p id="152e" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">继续测试它。使用<code class="fe nv nw nx ny b">npm run start:dev</code>命令启动服务器，它将在监视模式下运行我们的服务器，并在我们对代码进行任何修改时检测到变化。</p><p id="d568" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">在浏览器中输入<code class="fe nv nw nx ny b"><a class="ae nz" href="http://localhost:3000/product" rel="noopener ugc nofollow" target="_blank">http://localhost:3000/product</a></code>，可以通过浏览器触发get调用。</p></div><div class="ab cl lr ls hu lt" role="separator"><span class="lu bw bk lv lw lx"/><span class="lu bw bk lv lw lx"/><span class="lu bw bk lv lw"/></div><div class="ij ik il im in"><h1 id="b276" class="ly lz iq bd ma mb mc md me mf mg mh mi jw mj jx mk jz ml ka mm kc mn kd mo mp bi translated">添加帖子方法</h1><p id="d28e" class="pw-post-body-paragraph kv kw iq kx b ky mq jr la lb mr ju ld le ms lg lh li mt lk ll lm mu lo lp lq ij bi translated">突出显示的代码是为<code class="fe nv nw nx ny b">Post</code>方法添加的，其余代码保持不变。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="on oo l"/></div></figure><ul class=""><li id="7603" class="nh ni iq kx b ky kz lb lc le oj li ok lm ol lq nm nn no np bi translated"><code class="fe nv nw nx ny b">@Post</code>:Post decorator要定义方法<code class="fe nv nw nx ny b">AddProduct</code>。当通过Post方法向<code class="fe nv nw nx ny b"><a class="ae nz" href="https://endpoint" rel="noopener ugc nofollow" target="_blank">https://endpoint</a>/product</code>发出请求时，它将由客户端发起。Post方法不能通过使用浏览器启动，我们需要一个客户端，我使用<a class="ae nz" href="https://www.getpostman.com/" rel="noopener ugc nofollow" target="_blank"> Postman </a>进行测试。</li><li id="a91d" class="nh ni iq kx b ky nq lb nr le ns li nt lm nu lq nm nn no np bi translated"><code class="fe nv nw nx ny b">@Req</code> : <strong class="kx ir"> </strong>我们可以访问HTTP <code class="fe nv nw nx ny b">Request</code>对象。您可以访问主体、头和其他请求参数。</li></ul><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi op"><img src="../Images/c7e11d13b03c459f17e58811a23d595a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*GdautOk_00wjphass9d6gg.gif"/></div></div></figure><p id="f35d" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">您可以看到我们是如何提供端点的，方法是<code class="fe nv nw nx ny b">post</code>，我们在主体中发送了一些数据，并收到了作为响应的<code class="fe nv nw nx ny b">id</code>值。</p></div><div class="ab cl lr ls hu lt" role="separator"><span class="lu bw bk lv lw lx"/><span class="lu bw bk lv lw lx"/><span class="lu bw bk lv lw"/></div><div class="ij ik il im in"><h1 id="85a7" class="ly lz iq bd ma mb mc md me mf mg mh mi jw mj jx mk jz ml ka mm kc mn kd mo mp bi translated">其他装修工</h1><p id="212a" class="pw-post-body-paragraph kv kw iq kx b ky mq jr la lb mr ju ld le ms lg lh li mt lk ll lm mu lo lp lq ij bi translated">对于上传、修补和删除，我们有<code class="fe nv nw nx ny b">@Put</code>、<code class="fe nv nw nx ny b">@Patch</code>和<code class="fe nv nw nx ny b">@Delete</code>装饰器可用。当我们集成数据库时，我们将看到每个示例。</p><pre class="kg kh ki kj gt ob ny oc od aw oe bi"><span id="24cb" class="mv lz iq ny b gy of og l oh oi">@Put()<br/>EditProduct(){}</span><span id="636a" class="mv lz iq ny b gy om og l oh oi">@Patch()<br/>UpdateProductPrice(){}</span><span id="effc" class="mv lz iq ny b gy om og l oh oi">@Delete()<br/>DeleteProduct(){}</span></pre></div><div class="ab cl lr ls hu lt" role="separator"><span class="lu bw bk lv lw lx"/><span class="lu bw bk lv lw lx"/><span class="lu bw bk lv lw"/></div><div class="ij ik il im in"><h1 id="d133" class="ly lz iq bd ma mb mc md me mf mg mh mi jw mj jx mk jz ml ka mm kc mn kd mo mp bi translated">覆盖响应和标题</h1><p id="cb36" class="pw-post-body-paragraph kv kw iq kx b ky mq jr la lb mr ju ld le ms lg lh li mt lk ll lm mu lo lp lq ij bi translated">我们可能需要覆盖状态代码或者以JSON的形式创建响应数据，我们可以使用<code class="fe nv nw nx ny b">@Res()</code>装饰器来实现，让我们修改<code class="fe nv nw nx ny b">AddProduct</code>方法来使用它。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="on oo l"/></div></figure><p id="cb03" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">如果我们只想覆盖状态代码，可以使用<code class="fe nv nw nx ny b">@HttpCode</code>装饰器。</p><pre class="kg kh ki kj gt ob ny oc od aw oe bi"><span id="de1f" class="mv lz iq ny b gy of og l oh oi">@Put()<br/><strong class="ny ir">@HttpCode(204)<br/></strong>EditProduct() {}</span></pre><p id="9867" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">为了给响应添加定制的头，我们可以使用<code class="fe nv nw nx ny b">@Header</code> decorator。</p><pre class="kg kh ki kj gt ob ny oc od aw oe bi"><span id="81a7" class="mv lz iq ny b gy of og l oh oi">@Put()<br/><strong class="ny ir">@Header('header-key','value')</strong><br/>EditProduct() {}</span></pre></div><div class="ab cl lr ls hu lt" role="separator"><span class="lu bw bk lv lw lx"/><span class="lu bw bk lv lw lx"/><span class="lu bw bk lv lw"/></div><div class="ij ik il im in"><h1 id="8362" class="ly lz iq bd ma mb mc md me mf mg mh mi jw mj jx mk jz ml ka mm kc mn kd mo mp bi translated">覆盖路由名称并创建动态路由</h1><p id="c447" class="pw-post-body-paragraph kv kw iq kx b ky mq jr la lb mr ju ld le ms lg lh li mt lk ll lm mu lo lp lq ij bi translated">我们可以为路由提供友好的名称，甚至可以为每个请求生成一个动态URL。</p><pre class="kg kh ki kj gt ob ny oc od aw oe bi"><span id="de45" class="mv lz iq ny b gy of og l oh oi"><strong class="ny ir">@Put('editProduct')</strong><br/>EditProduct() {}</span></pre><p id="8ac8" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">进行更改后，端点将是<code class="fe nv nw nx ny b"><a class="ae nz" href="https://endpoint" rel="noopener ugc nofollow" target="_blank">https://endpoint</a>/product/editProduct</code>。</p><pre class="kg kh ki kj gt ob ny oc od aw oe bi"><span id="fd8f" class="mv lz iq ny b gy of og l oh oi"><strong class="ny ir">@Put('editProduct/:id')</strong><br/>EditProduct() {}</span><span id="b58a" class="mv lz iq ny b gy om og l oh oi"><strong class="ny ir">@Get(':id')</strong><br/>GetProducts() {}</span></pre><p id="c4d1" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">在上面的场景中，<code class="fe nv nw nx ny b">:id</code>是URL可以接受的动态值。例如，<code class="fe nv nw nx ny b"><a class="ae nz" href="https://endpoint" rel="noopener ugc nofollow" target="_blank">https://endpoint</a>/product/editProduct/1</code>，其中1是<code class="fe nv nw nx ny b">:id</code>的值</p></div><div class="ab cl lr ls hu lt" role="separator"><span class="lu bw bk lv lw lx"/><span class="lu bw bk lv lw lx"/><span class="lu bw bk lv lw"/></div><div class="ij ik il im in"><h1 id="9c31" class="ly lz iq bd ma mb mc md me mf mg mh mi jw mj jx mk jz ml ka mm kc mn kd mo mp bi translated">访问路由器参数</h1><p id="a559" class="pw-post-body-paragraph kv kw iq kx b ky mq jr la lb mr ju ld le ms lg lh li mt lk ll lm mu lo lp lq ij bi translated">我们还可以使用<code class="fe nv nw nx ny b">@Param</code>装饰器访问传递给动态路由的参数。在下面的例子中，我们有一个新方法，<code class="fe nv nw nx ny b">GetProductById</code>，我们通过<code class="fe nv nw nx ny b">id</code>参数从数组中获取乘积。</p><pre class="kg kh ki kj gt ob ny oc od aw oe bi"><span id="2b33" class="mv lz iq ny b gy of og l oh oi">@Get(':id')<br/>GetProductById(@Param() param: number) {<br/>    return this.products.find(p =&gt; p.id === +param.id);<br/>}</span></pre></div><div class="ab cl lr ls hu lt" role="separator"><span class="lu bw bk lv lw lx"/><span class="lu bw bk lv lw lx"/><span class="lu bw bk lv lw"/></div><div class="ij ik il im in"><h1 id="7c37" class="ly lz iq bd ma mb mc md me mf mg mh mi jw mj jx mk jz ml ka mm kc mn kd mo mp bi translated">在我们的操作中使用异步</h1><p id="8380" class="pw-post-body-paragraph kv kw iq kx b ky mq jr la lb mr ju ld le ms lg lh li mt lk ll lm mu lo lp lq ij bi translated">有时候你可能想使用异步动作，主要是在使用<code class="fe nv nw nx ny b">promise</code>或<code class="fe nv nw nx ny b">observables</code>的时候。您可以通过使用下面的语法达到同样的目的。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="on oo l"/></div></figure><p id="21b4" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">在接下来的文章中，我们将会看到更多异步操作的例子。</p></div><div class="ab cl lr ls hu lt" role="separator"><span class="lu bw bk lv lw lx"/><span class="lu bw bk lv lw lx"/><span class="lu bw bk lv lw"/></div><div class="ij ik il im in"><h1 id="2175" class="ly lz iq bd ma mb mc md me mf mg mh mi jw mj jx mk jz ml ka mm kc mn kd mo mp bi translated">注册控制器</h1><p id="7302" class="pw-post-body-paragraph kv kw iq kx b ky mq jr la lb mr ju ld le ms lg lh li mt lk ll lm mu lo lp lq ij bi translated">控制器需要向NestJS模块注册，如果您使用NextJS CLI，这将由CLI管理，您不需要手动操作。</p><p id="db0a" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">如果你打开<code class="fe nv nw nx ny b">app.module.ts</code>，你会看到下面的代码。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="on oo l"/></div></figure></div><div class="ab cl lr ls hu lt" role="separator"><span class="lu bw bk lv lw lx"/><span class="lu bw bk lv lw lx"/><span class="lu bw bk lv lw"/></div><div class="ij ik il im in"><h1 id="427a" class="ly lz iq bd ma mb mc md me mf mg mh mi jw mj jx mk jz ml ka mm kc mn kd mo mp bi translated">结论</h1><p id="5951" class="pw-post-body-paragraph kv kw iq kx b ky mq jr la lb mr ju ld le ms lg lh li mt lk ll lm mu lo lp lq ij bi translated">在这篇文章中，我们学习了控制器以及为什么和如何使用它们，还学习了不同的装饰者。</p></div></div>    
</body>
</html>