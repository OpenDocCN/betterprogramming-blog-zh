<html>
<head>
<title>Building Upgradeable Solidity Smart Contracts With Openzeppelin and Truffle</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">利用Openzeppelin和Truffle构建可升级的可靠性智能合约</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/building-upgradeable-solidity-smart-contracts-using-openzeppelin-and-truffle-44219ea6684f?source=collection_archive---------5-----------------------#2022-01-09">https://betterprogramming.pub/building-upgradeable-solidity-smart-contracts-using-openzeppelin-and-truffle-44219ea6684f?source=collection_archive---------5-----------------------#2022-01-09</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="4fcf" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">端到端可靠性教程</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/e3203d089cbba63576a960b000aa99af.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ATYvFWEGj-_S1ekgcF2wmA.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">Openzeppelin和块菌图像</p></figure><p id="dbd0" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">默认情况下，智能合约是不可变的，也就是说，在部署智能合约时，您不能更改智能合约的代码。如果您重新部署智能合约，它会生成一个新地址，您将会丢失以前的智能合约数据。</p><p id="b57d" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">如果您不打算在任何时候更改智能合约代码，这完全没问题。</p><p id="2646" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">但是，如果您将来某个时候要更改您的智能合约代码，您必须想出一种有效的方法来迁移您的智能合约，而不会丢失合约数据和地址。</p><p id="7f3c" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">有一些手动方法可以迁移智能合同数据，并通过禁用旧地址来强制用户使用新生成的地址，但这是一项繁琐的任务。</p><p id="76d3" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">在本文中，我们将学习如何使用OpenZeppelin可升级库和Truffle编写可升级智能合约。</p><p id="561d" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">让我们用一个Kickstarter合同作为用例。<a class="ae lr" href="https://www.kickstarter.com/" rel="noopener ugc nofollow" target="_blank"> Kickstarter </a>是一个平台，允许用户为特定目的创建活动，其他用户也可以为活动做出贡献。</p><h1 id="a0bf" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated"><strong class="ak">先决条件</strong></h1><ul class=""><li id="4769" class="mk ml iq kx b ky mm lb mn le mo li mp lm mq lq mr ms mt mu bi translated">对坚实度和块菌的合理理解</li><li id="6394" class="mk ml iq kx b ky mv lb mw le mx li my lm mz lq mr ms mt mu bi translated">Nodejs和npm</li><li id="d97c" class="mk ml iq kx b ky mv lb mw le mx li my lm mz lq mr ms mt mu bi translated"><code class="fe na nb nc nd b">ganache-cli</code>或<a class="ae lr" href="https://truffleframework.com/ganache" rel="noopener ugc nofollow" target="_blank"> Ganache </a>桌面应用</li><li id="af43" class="mk ml iq kx b ky mv lb mw le mx li my lm mz lq mr ms mt mu bi translated">松露</li></ul><p id="d8a9" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">如果你没有安装Node.js或npm，你将不得不安装<a class="ae lr" href="https://nodejs.org/en/download/" rel="noopener ugc nofollow" target="_blank">它们</a>，还要安装<code class="fe na nb nc nd b">ganache-cli</code>或桌面。</p><p id="e166" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">我更喜欢在全球范围内用<code class="fe na nb nc nd b">npm install -g truffle</code>安装松露，但是如果你决定在本地安装，也没关系。</p><p id="bb41" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">安装后，使用您选择的名称创建一个项目目录，在终端中打开该目录并运行以下命令:</p><pre class="kg kh ki kj gt ne nd nf ng aw nh bi"><span id="ff07" class="ni lt iq nd b gy nj nk l nl nm">truffle init</span></pre><p id="a8bd" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated"><code class="fe na nb nc nd b">truffle init</code>将为你创建合同和迁移目录，以及一个<code class="fe na nb nc nd b">truffle-config.js</code>文件。接下来，更新你的<code class="fe na nb nc nd b">truffle-config</code>:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nn no l"/></div></figure><p id="ecba" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">如果您想使用<code class="fe na nb nc nd b">ropsten</code>网络，创建一个<code class="fe na nb nc nd b">.env</code>文件并添加您的<code class="fe na nb nc nd b">ropsten</code>网络变量。</p><p id="33db" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">更新truffle配置文件后，安装所需的npm依赖项:</p><pre class="kg kh ki kj gt ne nd nf ng aw nh bi"><span id="17dd" class="ni lt iq nd b gy nj nk l nl nm">npm install @openzeppelin/contracts-upgradeable @openzeppelin/truffle-upgrades @truffle/hdwallet-provider dotenv</span></pre><p id="3495" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">然后在contracts文件夹中创建两个文件<code class="fe na nb nc nd b">Kickstart.sol</code>和<code class="fe na nb nc nd b">KickstartFactory.sol</code>。</p><p id="0ee1" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated"><code class="fe na nb nc nd b">Migration.sol</code>是你跑<code class="fe na nb nc nd b">truffle init</code> <strong class="kx ir">的时候创建的。你</strong>用下面这个更新<code class="fe na nb nc nd b">Migration</code>合同。借用了<a class="ae lr" href="https://trufflesuite.com/docs/truffle/getting-started/running-migrations.html" rel="noopener ugc nofollow" target="_blank">松露官方文档</a>中提到的例子。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nn no l"/></div></figure><p id="4b85" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">将以下代码粘贴到<code class="fe na nb nc nd b">Kickstart.sol</code>文件中:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nn no l"/></div></figure><p id="96f6" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">如果你已经注意到，我使用getters和setter<strong class="kx ir"/>来访问和改变契约的变量。</p><p id="3223" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">这是<code class="fe na nb nc nd b">OpenZepplin</code>对可升级智能合约变量变异的规范。也没有构造函数，而是使用了初始化函数。</p><p id="9b7c" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">你可以在这里阅读更多关于契约初始化器的内容。</p><p id="14f9" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">将以下代码粘贴到<code class="fe na nb nc nd b">KickstartFactory.sol</code>文件中:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nn no l"/></div></figure><p id="1e56" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">在<code class="fe na nb nc nd b">migrations</code>文件夹中:</p><pre class="kg kh ki kj gt ne nd nf ng aw nh bi"><span id="a125" class="ni lt iq nd b gy nj nk l nl nm">// 1_initial_migration.js</span><span id="3c44" class="ni lt iq nd b gy np nk l nl nm">const Migrations = artifacts.require("Migrations");</span><span id="6231" class="ni lt iq nd b gy np nk l nl nm">module.exports = function (deployer) {<br/>  deployer.deploy(Migrations);<br/>};</span></pre><p id="99a7" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">当您运行<code class="fe na nb nc nd b">truffle init</code>命令时，Truffle将为您生成第一个初始迁移(<code class="fe na nb nc nd b">1_initial_migration.js</code>)。</p><p id="7c77" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">在迁移目录<code class="fe na nb nc nd b">2_deploy_contracts.js</code>中创建新的迁移文件:</p><pre class="kg kh ki kj gt ne nd nf ng aw nh bi"><span id="b7d1" class="ni lt iq nd b gy nj nk l nl nm">// 2_deploy_contracts.js</span><span id="360d" class="ni lt iq nd b gy np nk l nl nm">const { deployProxy } = require('@openzeppelin/truffle-upgrades');</span><span id="6618" class="ni lt iq nd b gy np nk l nl nm">const Kickstart = artifacts.require("Kickstart");const KickstartFactory = artifacts.require("KickstartFactory");</span><span id="163c" class="ni lt iq nd b gy np nk l nl nm">/** Deploy contract using openzeppelin deployProxy, which will create a proxy address for you */</span><span id="cec9" class="ni lt iq nd b gy np nk l nl nm">module.exports = async (deployer) =&gt; {<br/>  const factory = await deployProxy(KickstartFactory, { deployer });<br/>  const kickstart = await deployProxy(Kickstart, <br/>    [100,  '0x0000000000000000000000000000000000000000'], <br/>  { deployer   });<br/>};</span></pre><p id="b2c3" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">粘贴上述代码后，运行以下命令:</p><pre class="kg kh ki kj gt ne nd nf ng aw nh bi"><span id="cd1a" class="ni lt iq nd b gy nj nk l nl nm"><strong class="nd ir">truffle compile<br/>truffle migrate<br/>// Or<br/>truffle deploy </strong>// truffle deploy is an alias for truffle mograte</span></pre><p id="dcda" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">迁移成功后用<code class="fe na nb nc nd b">truffle migrate</code> <strong class="kx ir"> </strong>运行:</p><pre class="kg kh ki kj gt ne nd nf ng aw nh bi"><span id="0e73" class="ni lt iq nd b gy nj nk l nl nm">truffle console</span></pre><p id="22e8" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">在合同控制台中，运行以下命令:</p><pre class="kg kh ki kj gt ne nd nf ng aw nh bi"><span id="7375" class="ni lt iq nd b gy nj nk l nl nm">// This will create KicstartFactory contract instance<br/><strong class="nd ir">let factory = await KickstartFactory.deployed()</strong></span><span id="29a4" class="ni lt iq nd b gy np nk l nl nm">// Create a new kickstart campaign<strong class="nd ir"><br/>factory.createCampaign(100)</strong></span><span id="b295" class="ni lt iq nd b gy np nk l nl nm">// Get the created campaign<br/><strong class="nd ir">factory.getDeployedCampaigns()</strong></span><span id="9cd1" class="ni lt iq nd b gy np nk l nl nm">// Copy the address in the campaign list</span><span id="7b90" class="ni lt iq nd b gy np nk l nl nm">// Create a kickstart instance by running this command<br/><strong class="nd ir">let kickstart = await Kickstart.deployed('0x11924C6967680124814fe7bFE0EB4a352CEB9Ef6')<br/></strong>// Replace the address with the address copied from the campaign list</span></pre><p id="abcb" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">要升级<code class="fe na nb nc nd b">KicstartFactory</code>合同并添加新的<code class="fe na nb nc nd b">function get DeployedCampaignsLength()</code>，在<code class="fe na nb nc nd b">contracts</code>目录下创建一个新文件并命名为<code class="fe na nb nc nd b">KickstartFactoryV2.sol</code>。</p><p id="881d" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">此函数将获取已部署活动的总数:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nn no l"/></div></figure><p id="c63d" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">在<code class="fe na nb nc nd b">migration</code>目录下创建一个新的迁移文件<code class="fe na nb nc nd b">3_upgrade_contracts.js</code> <strong class="kx ir"> </strong>，将以下代码粘贴到该文件中。</p><pre class="kg kh ki kj gt ne nd nf ng aw nh bi"><span id="bebf" class="ni lt iq nd b gy nj nk l nl nm">// 3_upgrade_contracts.js</span><span id="359d" class="ni lt iq nd b gy np nk l nl nm">const { upgradeProxy } = require('@openzeppelin/truffle-upgrades');</span><span id="e773" class="ni lt iq nd b gy np nk l nl nm">const KickstartFactory = artifacts.require("KickstartFactory");<br/>const KickstartFactoryV2 = artifacts.require("KickstartFactoryV2");</span><span id="a9e9" class="ni lt iq nd b gy np nk l nl nm">module.exports = async (deployer) =&gt; {<br/>  const existing = await KickstartFactory.deployed();<br/>  console.log('Existing Address ===', existing.address); <br/>  <br/>  const instance = await upgradeProxy(<br/>    existing.address,  KickstartFactoryV2, { deployer });<br/>  console.log("Upgraded Address ===", instance.address);<br/>};</span></pre><p id="3c75" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">如果你注意到了，我们这次没有部署<code class="fe na nb nc nd b">KickstartFactory</code> <strong class="kx ir"> </strong>合同。</p><p id="7f1f" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">相反，我们得到一个已经部署的版本的实例，并使用<code class="fe na nb nc nd b">existing.address</code> <strong class="kx ir"> </strong>作为<code class="fe na nb nc nd b">updateProxy</code>函数的第一个参数，将地址传递给新版本</p><p id="00cf" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">粘贴前面的代码后，运行以下命令:</p><pre class="kg kh ki kj gt ne nd nf ng aw nh bi"><span id="9543" class="ni lt iq nd b gy nj nk l nl nm">truffle compile<br/>truffle migrate <br/>// Or<br/>truffle deploy</span></pre><h1 id="c3f8" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">笔记</h1><p id="09f1" class="pw-post-body-paragraph kv kw iq kx b ky mm jr la lb mn ju ld le nq lg lh li nr lk ll lm ns lo lp lq ij bi translated">当使用truffle建立可升级的合同时，不要试图使用<code class="fe na nb nc nd b">reset flag (truffle migrate — reset)</code> <strong class="kx ir">，</strong>迁移您的合同，使用reset部署将删除您现有的所有合同状态和数据，重新开始迁移，这也将改变您的合同地址。</p><p id="22f5" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">如果你想在一个开发环境中重置你的契约，你是自由的，但是在生产环境中使用<code class="fe na nb nc nd b">reset</code>是不明智的。</p><p id="f4d8" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">我希望你已经学会了如何用松露和<code class="fe na nb nc nd b">openzeppelin</code>可升级库建立一个可升级的智能契约。你也可以用<code class="fe na nb nc nd b">openzeppelin</code>和<code class="fe na nb nc nd b">hardhat</code>建立可升级的智能合约。</p></div><div class="ab cl nt nu hu nv" role="separator"><span class="nw bw bk nx ny nz"/><span class="nw bw bk nx ny nz"/><span class="nw bw bk nx ny"/></div><div class="ij ik il im in"><p id="5525" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">在<a class="ae lr" href="https://github.com/elraphty/upgreadeablesmartcontract.git" rel="noopener ugc nofollow" target="_blank"> GitHub </a>上克隆完整的代码，也检查一下我的<a class="ae lr" href="https://github.com/elraphty/soliditykickstart.git" rel="noopener ugc nofollow" target="_blank"> Solidity kickstart GitHub项目</a>，这是这个项目的不可升级版本，带有测试用例，也有一个前端与智能合约ABIS交互。</p><p id="cb73" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">谢了。</p></div></div>    
</body>
</html>