<html>
<head>
<title>Get Slack Build Notifications From CircleCI for Your Android Builds</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">从CircleCI获取Android版本的松弛版本通知</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/slack-build-notifications-from-circleci-for-android-builds-b39be7f480bf?source=collection_archive---------13-----------------------#2019-12-04">https://betterprogramming.pub/slack-build-notifications-from-circleci-for-android-builds-b39be7f480bf?source=collection_archive---------13-----------------------#2019-12-04</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="3888" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">为你的应用建立一个有用的通知渠道</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/416d6db9c505e2293bb61c75112aaa3c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*pRFj1dHBYeweFEo74CTMzA.png"/></div></div></figure><p id="e3af" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">CircleCI是一个众所周知的Android应用程序持续集成和分发平台。这篇文章讨论了您的Android项目如何利用<a class="ae ln" href="https://circleci.com/" rel="noopener ugc nofollow" target="_blank"> CircleCI </a>和<a class="ae ln" href="https://slack.com" rel="noopener ugc nofollow" target="_blank"> Slack </a>集成来为Android应用程序创建一个出色的构建通知通道。</p><p id="d09e" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">我们将探索CircleCI为Slack通知提供的开箱即用集成，并研究它的不足之处。我们还将了解用于手动触发Slack通知的<a class="ae ln" href="https://github.com/CircleCI-Public/slack-orb" rel="noopener ugc nofollow" target="_blank"> CircleCI Slack orb </a>。</p><p id="11ca" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">本文将带您了解将Slack逐步集成到您的Android项目中的过程。</p><ul class=""><li id="d634" class="lo lp iq kt b ku kv kx ky la lq le lr li ls lm lt lu lv lw bi translated">构建项目。</li><li id="f2de" class="lo lp iq kt b ku lx kx ly la lz le ma li mb lm lt lu lv lw bi translated">集成Slack Webhook。</li><li id="a9eb" class="lo lp iq kt b ku lx kx ly la lz le ma li mb lm lt lu lv lw bi translated">整合松弛球体。</li></ul></div><div class="ab cl mc md hu me" role="separator"><span class="mf bw bk mg mh mi"/><span class="mf bw bk mg mh mi"/><span class="mf bw bk mg mh"/></div><div class="ij ik il im in"><h1 id="f889" class="mj mk iq bd ml mm mn mo mp mq mr ms mt jw mu jx mv jz mw ka mx kc my kd mz na bi translated">构建项目</h1><p id="5209" class="pw-post-body-paragraph kr ks iq kt b ku nb jr kw kx nc ju kz la nd lc ld le ne lg lh li nf lk ll lm ij bi translated">我们将逐步开始，编写一个简单的CI脚本来组装项目并运行单元测试。</p><p id="247a" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated"><em class="ng"> CircleCI构建脚本(第一次迭代):</em></p><pre class="kg kh ki kj gt nh ni nj nk aw nl bi"><span id="d224" class="nm mk iq ni b gy nn no l np nq">version: 2.1<br/><br/>executors:<br/>  android-executor:<br/>    docker:<br/>      - image: circleci/android:api-29<br/>    environment:<br/>      - JAVA_OPTIONS: "-Xmx3072m -XX:+HeapDumpOnOutOfMemoryError"<br/><br/>aliases:<br/>  - &amp;assemble<br/>    run:<br/>      name: Assemble Project<br/>      command: ./gradlew assembleDebug<br/>  - &amp;unit_tests<br/>    run:<br/>      name: Run Unit Tests<br/>      command: ./gradlew :app:testDebugUnitTest<br/><br/>jobs:<br/><br/>  build:<br/>    executor: android-executor<br/>    steps:<br/>      - checkout<br/>      - *assemble<br/>      - *unit_tests<br/><br/>workflows:<br/>  version: 2.1<br/><br/>  build-workflow:<br/>    jobs:<br/>      - build</span></pre><p id="63da" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">上述脚本由以下组件组成:</p><h2 id="a775" class="nm mk iq bd ml nr ns dn mp nt nu dp mt la nv nw mv le nx ny mx li nz oa mz ob bi translated">安卓执行器</h2><p id="9d5d" class="pw-post-body-paragraph kr ks iq kt b ku nb jr kw kx nc ju kz la nd lc ld le ne lg lh li nf lk ll lm ij bi translated">CircleCI执行器封装了运行作业所需的底层环境。在我们的例子中，我们选择了<strong class="kt ir">circle ci/Android:API-29</strong>。这是一个Docker映像，针对构建面向API级别29的Android应用程序进行了优化。你可以在这里找到其他安卓图片<a class="ae ln" href="https://circleci.com/docs/2.0/circleci-images/#android" rel="noopener ugc nofollow" target="_blank">。</a></p><h2 id="4e89" class="nm mk iq bd ml nr ns dn mp nt nu dp mt la nv nw mv le nx ny mx li nz oa mz ob bi translated">别名</h2><p id="e166" class="pw-post-body-paragraph kr ks iq kt b ku nb jr kw kx nc ju kz la nd lc ld le ne lg lh li nf lk ll lm ij bi translated">YAML <a class="ae ln" href="https://medium.com/@kinghuang/docker-compose-anchors-aliases-extensions-a1e4105d70bd" rel="noopener">别名</a>让您在YAML文档中用锚点标识一个<em class="ng">项目</em>，然后在同一文档中用<em class="ng">别名</em>引用那个<em class="ng">项目</em>。我们已经定义了两个别名，这两个别名指的是组装项目然后运行单元测试的任务。</p><p id="b243" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated"><code class="fe oc od oe ni b">assemble</code> <strong class="kt ir"> </strong>别名使用标准的<code class="fe oc od oe ni b">gradle</code>命令<code class="fe oc od oe ni b">./gradlew assembleDebug</code> <em class="ng"> </em>来编译项目。另一个别名，<code class="fe oc od oe ni b">unit_tests</code> <strong class="kt ir"> </strong>使用<code class="fe oc od oe ni b">gradle</code>来执行项目的单元测试。</p><h2 id="2ef0" class="nm mk iq bd ml nr ns dn mp nt nu dp mt la nv nw mv le nx ny mx li nz oa mz ob bi translated">乔布斯</h2><p id="59de" class="pw-post-body-paragraph kr ks iq kt b ku nb jr kw kx nc ju kz la nd lc ld le ne lg lh li nf lk ll lm ij bi translated">现在我们已经定义了脚本的基础，我们将开始定义CircleCI作业。现在，我们将宣布一项名为<code class="fe oc od oe ni b">build</code>的工作，它(<em class="ng"> surprise surprise！</em>)构建我们的项目。它使用了<code class="fe oc od oe ni b">assemble</code>和<code class="fe oc od oe ni b">unit_tests</code> <strong class="kt ir"> </strong>的别名。</p><h2 id="c145" class="nm mk iq bd ml nr ns dn mp nt nu dp mt la nv nw mv le nx ny mx li nz oa mz ob bi translated">工作流程</h2><p id="728d" class="pw-post-body-paragraph kr ks iq kt b ku nb jr kw kx nc ju kz la nd lc ld le ne lg lh li nf lk ll lm ij bi translated">CircleCI 2.0引入了<a class="ae ln" href="https://circleci.com/docs/2.0/workflows/" rel="noopener ugc nofollow" target="_blank">工作流</a>——确定其执行顺序的作业和规则的集合。因为我们只定义了一个作业，所以我们的<code class="fe oc od oe ni b">build-workflow </code>很简单。每当有提交，CircleCI就会运行名为<code class="fe oc od oe ni b">build</code>的作业。</p><p id="bdd3" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">在定义了构建作业和构建工作流之后，一旦您在CircleCI中跟踪您的Android项目并向其提交一个新的commit，您将会看到以下内容。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi of"><img src="../Images/66f098be8755a0babb41dba24bb049c6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*VRUtqCvC-O2KaD7xPaHgIA.png"/></div></div></figure><p id="9572" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">构建作业成功(如绿色所示)，工作流也成功。</p></div><div class="ab cl mc md hu me" role="separator"><span class="mf bw bk mg mh mi"/><span class="mf bw bk mg mh mi"/><span class="mf bw bk mg mh"/></div><div class="ij ik il im in"><h1 id="806b" class="mj mk iq bd ml mm mn mo mp mq mr ms mt jw mu jx mv jz mw ka mx kc my kd mz na bi translated">集成Slack Webhook</h1><p id="b0c4" class="pw-post-body-paragraph kr ks iq kt b ku nb jr kw kx nc ju kz la nd lc ld le ne lg lh li nf lk ll lm ij bi translated">CircleCI通过为Slack <a class="ae ln" href="https://api.slack.com/messaging/webhooks" rel="noopener ugc nofollow" target="_blank"> Webhooks </a>提供开箱即用的集成，方便了发送Slack通知。您需要在项目设置中提供一个指向Slack通道的Webhook url。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi og"><img src="../Images/0e6516849020503d49487e86ba386cec.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*JRd5msHX4X3pAle6-Nvzbg.png"/></div></div></figure><p id="c372" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">添加Webhook URL后，点击<strong class="kt ir">测试挂钩</strong>按钮。如果集成成功，您应该会在您的通道中看到类似下面的消息。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi oh"><img src="../Images/92ef6d747468961b3137be388ea0c324.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*hxqc9CqAn5IyBeMrweAWrg.png"/></div></div></figure><p id="974c" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">点击<strong class="kt ir">保存</strong>按钮，将Webhook URL保存在项目设置中。</p><p id="6f39" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">当您完成上述操作后，将另一个提交推送到您的存储库。有两种可能性，要么构建成功，要么失败并出现错误。如果构建工作中有错误，CircleCI会向您的通道推送一条消息。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi oi"><img src="../Images/d5b1c9cfbc0b43ae99aa380a5226db03.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*pPAKbuutFQCYMZo9yIQB6w.png"/></div></div></figure><p id="0e05" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">该消息指示失败的提交消息及其哈希、失败的工作流以及启动此工作流的用户。相当酷！</p><p id="0361" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">让我们尝试一个成功的构建。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi oj"><img src="../Images/068a249184a2198f70f3faf660d9a30b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*qVmMMZ0PEmiTwgoBuhw4Zg.png"/></div></div></figure><p id="5b01" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">类似的消息将被发送到通道以传递生成。</p></div><div class="ab cl mc md hu me" role="separator"><span class="mf bw bk mg mh mi"/><span class="mf bw bk mg mh mi"/><span class="mf bw bk mg mh"/></div><div class="ij ik il im in"><h1 id="ff42" class="mj mk iq bd ml mm mn mo mp mq mr ms mt jw mu jx mv jz mw ka mx kc my kd mz na bi translated">集成松弛球体</h1><p id="4952" class="pw-post-body-paragraph kr ks iq kt b ku nb jr kw kx nc ju kz la nd lc ld le ne lg lh li nf lk ll lm ij bi translated">在上一节中，我们探讨了开箱即用的Slack集成如何与CircleCI一起工作。虽然很方便，但它仅限于发布构建状态。有些情况下，我们可能希望对发送到Slack通道的消息以及触发这些消息的事件有更多的控制。看哪，圆形球体！</p><h2 id="d79c" class="nm mk iq bd ml nr ns dn mp nt nu dp mt la nv nw mv le nx ny mx li nz oa mz ob bi translated">CircleCI松弛球</h2><p id="4f97" class="pw-post-body-paragraph kr ks iq kt b ku nb jr kw kx nc ju kz la nd lc ld le ne lg lh li nf lk ll lm ij bi translated"><a class="ae ln" href="https://circleci.com/docs/2.0/using-orbs/" rel="noopener ugc nofollow" target="_blank"> CircleCI orbs </a>是在YAML脚本中可重用的预建命令、作业和执行器的集合。这是一个强大的概念，因为它允许脚本编写者在编写脚本和重用现有脚本时避免重复。</p><p id="f463" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">CircleCI Slack orb是一个元素集合，允许用户通过构建脚本向Slack通道发送消息。该脚本可以在被认为是用户感兴趣的任何事件上触发频道的通知。要在您的构建脚本中使用这个orb，请添加以下几行。</p><pre class="kg kh ki kj gt nh ni nj nk aw nl bi"><span id="4322" class="nm mk iq ni b gy nn no l np nq">orbs:<br/>  slack: circleci/slack@3.4.1</span></pre><h2 id="ece1" class="nm mk iq bd ml nr ns dn mp nt nu dp mt la nv nw mv le nx ny mx li nz oa mz ob bi translated">部署</h2><p id="5f6e" class="pw-post-body-paragraph kr ks iq kt b ku nb jr kw kx nc ju kz la nd lc ld le ne lg lh li nf lk ll lm ij bi translated">让我们来看一个实际的、真实的例子，看看如何使用Slack orb。</p><p id="87d5" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">我们已经有了一个可以构建项目的脚本。一旦单元测试通过，我们想要部署发布工件，以分发给测试人员和其他合作者。为此，我们修改我们的脚本以包含一个名为<code class="fe oc od oe ni b">deploy_apk</code> <strong class="kt ir"> </strong>的新的<em class="ng">别名</em>，然后在一个名为<code class="fe oc od oe ni b">deploy</code>的作业中使用它。</p><pre class="kg kh ki kj gt nh ni nj nk aw nl bi"><span id="cf0e" class="nm mk iq ni b gy nn no l np nq">version: 2.1<br/><br/>executors:<br/>  android-executor:<br/>    docker:<br/>      - image: circleci/android:api-29<br/>    environment:<br/>      - JAVA_OPTIONS: "-Xmx3072m -XX:+HeapDumpOnOutOfMemoryError"<br/><br/>aliases:<br/>  - &amp;assemble<br/>    run:<br/>      name: Assemble Project<br/>      command: ./gradlew assembleDebug<br/>  - &amp;unit_tests<br/>    run:<br/>      name: Run Unit Tests<br/>      command: ./gradlew :app:testDebugUnitTest<br/>  #  Placeholder deployment task<br/>  - &amp;deploy_apk<br/>    run:<br/>      name: Deploy Release Artifact<br/>      command: echo "Deploy release for distribution"<br/><br/>jobs:<br/><br/>  build:<br/>    executor: android-executor<br/>    steps:<br/>      - checkout<br/>      - *assemble<br/>      - *unit_tests<br/><br/>  deploy:<br/>    executor: android-executor<br/>    steps:<br/>      - checkout<br/>      - *assemble<br/>      - *deploy_apk<br/><br/>workflows:<br/>  version: 2.1<br/><br/>  build-workflow:<br/>    jobs:<br/>      - build<br/><br/>      - pending-deployment:<br/>          type: approval<br/>          requires:<br/>            - build<br/><br/>      - deploy:<br/>          requires:<br/>            - pending-deployment</span></pre><p id="8ed4" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">我们的YAML脚本现在能够构建和部署项目了。然而，部署是有条件的。我们不想部署每个版本。因此，该脚本利用了CircleCI的另一个特性:<a class="ae ln" href="https://circleci.com/blog/manual-job-approval-and-scheduled-workflow-runs/" rel="noopener ugc nofollow" target="_blank">批准作业</a>。</p><p id="22e8" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">在我们的构建工作流中，我们用类型<code class="fe oc od oe ni b">approval</code>定义了一个名为<code class="fe oc od oe ni b">pending-deployment</code>的作业。该作业在<code class="fe oc od oe ni b">build</code>作业成功完成后执行。一旦工作流到达一个<code class="fe oc od oe ni b">approval</code>任务，它就会被暂停。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi ok"><img src="../Images/da90250671f8135ae03fee13e1a6438c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*nq93HRwP0MV5bBe_02UR4A.png"/></div></div></figure><p id="6258" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">为了进一步执行该工作流，用户需要<em class="ng">批准</em>该<code class="fe oc od oe ni b">pending-deployment</code>作业。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi ol"><img src="../Images/c68fcb45d66cfca870ac41b7c61b3def.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*3Q6DuyMRVPQWEs-n42EjoQ.png"/></div></div></figure><p id="cf53" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">一旦获得批准，工作流将继续，并执行<code class="fe oc od oe ni b">deploy</code>作业，部署发布工件。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi om"><img src="../Images/e11ca8d112532646411d154be8218199.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*w7n_N-vU5uApRm0tAr45Ag.png"/></div></div></figure><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi on"><img src="../Images/afc4092247708f0799c27cc5854076a9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*FBR1QwhHe33OiZUKb_mwLw.png"/></div></div></figure><h2 id="e9cf" class="nm mk iq bd ml nr ns dn mp nt nu dp mt la nv nw mv le nx ny mx li nz oa mz ob bi translated">延期批准通知</h2><p id="fcb1" class="pw-post-body-paragraph kr ks iq kt b ku nb jr kw kx nc ju kz la nd lc ld le ne lg lh li nf lk ll lm ij bi translated">既然我们已经有了一个用于构建和部署的工作条件工作流，那么当工作流等待批准时，在构建通道中获得一个通知将会非常棒。为了实现这一点，我们使用CircleCI Slack orb在构建作业完成时在Slack通道上发送一条消息。为此，我们在构建脚本中添加了以下别名:</p><pre class="kg kh ki kj gt nh ni nj nk aw nl bi"><span id="04ca" class="nm mk iq ni b gy nn no l np nq">slack-aliases:<br/>  - &amp;slack_channel_webhook<br/>      ${CIRCLE_SLACK_WEBHOOK}<br/>  - &amp;notify_slack_for_approval<br/>    slack/notify:<br/>      color: '#400080'<br/>      message: |<br/>        [${CIRCLE_USERNAME}] Please check and approve Jobs to manually deploy the releases.<br/>        https://circleci.com/workflow-run/${CIRCLE_WORKFLOW_ID}<br/>      webhook: *slack_channel_webhook</span></pre><p id="9411" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">注意我们使用了三个环境变量。</p><p id="dd9e" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">变量<code class="fe oc od oe ni b">CIRCLE_SLACK_WEBHOOK</code> <strong class="kt ir"> </strong>保存webhook的值，该值指向将发布消息的Slack通道。实际上，这与我们在上一节中使用的方法相同，同时为CircleCI启用了现成的Slack通知功能。这个变量可以添加到CircleCI上的项目设置中。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi oo"><img src="../Images/e892a9045d98f0c6f4bea41d9c72bbaf.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*MI9dmI4GVM7bu8GySbt1GQ.png"/></div></div></figure><p id="38b7" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated"><code class="fe oc od oe ni b">CIRCLE_USERNAME</code> <strong class="kt ir"> </strong>和<code class="fe oc od oe ni b">CIRCLE_WORKFLOW_ID</code>是<a class="ae ln" href="https://circleci.com/docs/2.0/env-vars/#built-in-environment-variables" rel="noopener ugc nofollow" target="_blank">内置环境变量</a>，包含触发构建的用户名和当前工作流的唯一工作流id。</p><p id="aba5" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">CircleCI Slack orb提供了一个名为<strong class="kt ir"> slack/notify </strong>的任务。它需要两个参数。第一个参数是<code class="fe oc od oe ni b">message</code> <strong class="kt ir"> </strong>，这是我们将发布到频道的自定义消息。第二个参数是<code class="fe oc od oe ni b">Webhook</code>，它指向松弛通道的webhook。</p><p id="6abf" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">下一步是添加一个作业，该作业将使用上面的设置在部署作业准备好被触发时向我们的构建通道发送通知。</p><pre class="kg kh ki kj gt nh ni nj nk aw nl bi"><span id="33e8" class="nm mk iq ni b gy nn no l np nq">slack-approval-link:<br/>    executor: general-executor<br/>    steps:<br/>      - *notify_slack_for_approval</span></pre><p id="9769" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">请注意，我们已经为此作业指定了一个<code class="fe oc od oe ni b">general-executor</code>，而不是使用<code class="fe oc od oe ni b">android-executor</code>。</p><pre class="kg kh ki kj gt nh ni nj nk aw nl bi"><span id="9ad8" class="nm mk iq ni b gy nn no l np nq">general-executor:<br/>    docker:<br/>      - environment:<br/>          TERM: dumb<br/>        image: 'cibuilds/base:latest'<br/>    resource_class: small</span></pre><p id="9e27" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">这样做的原因是我们不希望CircleCI为Slack orb旋转整个Android构建环境。这个orb需要一个相当基本的bash shell来操作，而<a class="ae ln" href="https://github.com/cibuilds/base" rel="noopener ugc nofollow" target="_blank">基础执行器</a>对于我们的需求来说已经足够了。</p><p id="9e35" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">将延迟批准通知作业添加到我们的工作流后，CI脚本如下所示:</p><pre class="kg kh ki kj gt nh ni nj nk aw nl bi"><span id="7067" class="nm mk iq ni b gy nn no l np nq">version: 2.1<br/><br/>executors:<br/>  android-executor:<br/>    docker:<br/>      - image: circleci/android:api-29<br/>    environment:<br/>      - JAVA_OPTIONS: "-Xmx3072m -XX:+HeapDumpOnOutOfMemoryError"<br/><br/>  general-executor:<br/>    docker:<br/>      - environment:<br/>          TERM: dumb<br/>        image: 'cibuilds/base:latest'<br/>    resource_class: small<br/><br/>aliases:<br/>  - &amp;assemble<br/>    run:<br/>      name: Assemble Project<br/>      command: ./gradlew assembleDebug<br/>  - &amp;unit_tests<br/>    run:<br/>      name: Run Unit Tests<br/>      command: ./gradlew :app:testDebugUnitTest<br/>  #  Placeholder deployment task<br/>  - &amp;deploy_apk<br/>    run:<br/>      name: Deploy Release Artifact<br/>      command: echo "Deploy release for distribution"<br/><br/>slack-aliases:<br/>  - &amp;slack_channel_webhook<br/>      ${CIRCLE_SLACK_WEBHOOK}<br/>  - &amp;notify_slack_for_approval<br/>    slack/notify:<br/>      color: '#400080'<br/>      message: |<br/>        [${CIRCLE_USERNAME}] Please check and approve Jobs to manually deploy the releases.<br/>        https://circleci.com/workflow-run/${CIRCLE_WORKFLOW_ID}<br/>      webhook: *slack_channel_webhook<br/><br/>jobs:<br/><br/>  build:<br/>    executor: android-executor<br/>    steps:<br/>      - checkout<br/>      - *assemble<br/>      - *unit_tests<br/><br/>  slack-approval-link:<br/>    executor: general-executor<br/>    steps:<br/>      - *notify_slack_for_approval<br/><br/>  deploy:<br/>    executor: android-executor<br/>    steps:<br/>      - checkout<br/>      - *assemble<br/>      - *deploy_apk<br/><br/>orbs:<br/>  slack: circleci/slack@3.4.1<br/><br/>workflows:<br/>  version: 2.1<br/><br/>  build-workflow:<br/>    jobs:<br/>      - build<br/><br/>      - slack-approval-link:<br/>          requires:<br/>            - build<br/><br/>      - pending-deployment:<br/>          type: approval<br/>          requires:<br/>            - build<br/><br/>      - deploy:<br/>          requires:<br/>            - pending-deployment</span></pre><p id="ab23" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">将提交推送到存储库，以查看工作流的运行情况。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi op"><img src="../Images/bbb1c08e37771fe919339211ed8e4180.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*HtUmpjJeIFrmETV-n5NDpg.png"/></div></div></figure><p id="03fc" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">看，在构建通道中有一个slack消息，通知我们我们的部署工作正在等待批准！</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi oq"><img src="../Images/8a08c62cc8cc090623b4b574446f2a57.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*k0uKgtUT3GWnVmRTZJbqqA.png"/></div></div></figure><p id="f098" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">请注意用户名和工作流URL是如何成为此消息的一部分的。单击工作流URL会将用户带到您的工作流。</p></div><div class="ab cl mc md hu me" role="separator"><span class="mf bw bk mg mh mi"/><span class="mf bw bk mg mh mi"/><span class="mf bw bk mg mh"/></div><div class="ij ik il im in"><p id="1d40" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">在这篇文章中，我们探讨了CircleCI和Slack之间的集成。我们已经介绍了CircleCI通过Slack集成提供的现成功能。我们还讨论了CircleCI orbs，特别是CircleCI Slack orb，它允许脚本基于手动识别的触发器发送定制的Slack通知。</p><p id="482e" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">如需完整参考，代码可从<a class="ae ln" href="https://github.com/farhanjk/slack.circleci.notications" rel="noopener ugc nofollow" target="_blank">这里</a>获得。</p><p id="11b2" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">感谢您花时间阅读这篇文章！</p></div></div>    
</body>
</html>