<html>
<head>
<title>How to Test Android Activities</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何测试Android活动</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/how-to-test-android-activities-7c5b660d9412?source=collection_archive---------8-----------------------#2020-06-19">https://betterprogramming.pub/how-to-test-android-activities-7c5b660d9412?source=collection_archive---------8-----------------------#2020-06-19</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="cbd8" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">在测试环境中，Android是不存在的。这意味着测试即使是最简单的活动也会很棘手</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/c6648145587c8acecf061107864b3544.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*QgdvybL5PtdItSkUzJ2aNQ.jpeg"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated"><a class="ae kv" href="https://unsplash.com/photos/dWzWo22F0mA" rel="noopener ugc nofollow" target="_blank"> Pim Chu </a>在<a class="ae kv" href="https://unsplash.com/" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍照。</p></figure><p id="1351" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">当我开始开发Android应用程序时，我没有编写任何测试。当然不是——我只是在混日子，做些自己喜欢的东西。然后，我决定成为一名专业人士。我从小处着手，用最简单的应用程序和最简单的测试，很快就被难住了。对于任何同病相怜的人来说，这篇文章是给你的！</p><p id="d769" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">假设您有一个带按钮的活动。当您按下按钮时，您想要打开不同的活动。</p><p id="7a80" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">您的源代码可能如下所示:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ls lt l"/></div></figure><p id="b8a0" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在布局文件的某个地方，你将一个按钮的<code class="fe lu lv lw lx b">onClick</code> <em class="ly"> </em>设置为<code class="fe lu lv lw lx b">openOtherActivity</code>。但让我们只关注科特林代码。没必要把目标定得太高，对吧？</p><p id="d6ee" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">然后(或者最好是在此之前，如果你正在努力应用TDD ),你试着写一个测试。首先，您可能甚至没有检查它是否如您所期望的那样运行。最简单的测试就是“当你调用函数时，没有任何东西爆炸。”</p><p id="5e02" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">它可能看起来像这样:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ls lt l"/></div></figure><p id="fb8d" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">然而，即使这个非常简单的测试也会导致错误:</p><pre class="kg kh ki kj gt lz lx ma mb aw mc bi"><span id="e653" class="md me iq lx b gy mf mg l mh mi">java.lang.RuntimeException: Method startActivity in android.app.Activity not mocked.</span></pre><p id="2c86" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这是因为在测试环境中，Android特有的东西并不存在。这是Android深思熟虑的设计选择，有利也有弊。这个单元测试决定的一个结果是我们必须模仿Android特有的组件。</p><p id="59d0" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">Kotlin的一个模仿库是<a class="ae kv" href="https://mockk.io/" rel="noopener ugc nofollow" target="_blank">mock</a>，我将在这个例子中使用它。任何其他类似的模仿库应该可以做到这一点。</p><p id="3b1f" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">所以，回到我们的测试。我们可以使用来自MockK的<code class="fe lu lv lw lx b">spyk</code> <em class="ly"> </em>来模仿<code class="fe lu lv lw lx b">startActivity</code>方法(并保留其他所有真实的东西):</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ls lt l"/></div></figure><p id="dc76" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">现在测试通过了！</p><p id="294c" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">从那里，我们可以扩展测试来更彻底地检查函数的实际行为。例如，它是否以正确的意图调用<code class="fe lu lv lw lx b">startActivity</code> <em class="ly"> </em>。</p><p id="d6cd" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在下一个例子中，假设我们想在开始活动之前添加一些额外的内容:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ls lt l"/></div></figure><p id="8871" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们尝试运行一个类似的简单测试，只是检查没有任何东西爆炸:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ls lt l"/></div></figure><p id="3a51" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们已经使用了与上次相同的嘲讽技巧，但是现在我们得到了另一个错误:</p><pre class="kg kh ki kj gt lz lx ma mb aw mc bi"><span id="788d" class="md me iq lx b gy mf mg l mh mi">java.lang.RuntimeException: Method putExtra in android.content.Intent not mocked.</span></pre><p id="1f2f" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这看起来与上一个错误非常相似。然而，我们不能用同样的方法修复它。</p><p id="d93e" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们无法访问意图，因为它是在活动内部创建的。这意味着嘲笑意图是很棘手的。</p><p id="e859" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">解决这个问题的一个方法是注入一个工厂对象，我们可以<strong class="ky ir"> </strong>模仿它。</p><p id="05e4" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">工厂对象需要一个函数，我们可以用它来创建意图，而不用直接调用构造函数。它可能看起来像这样:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ls lt l"/></div></figure><p id="b6b8" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">然后，我们需要将该工厂注入到活动中，这样我们就可以在测试中覆盖它。</p><p id="98fe" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">依赖注入可以在Android中通过使用类似<a class="ae kv" href="https://dagger.dev/" rel="noopener ugc nofollow" target="_blank"> Dagger </a>的框架来实现。但是我们不需要这样做——从一个简单的实现开始就很好。我们可以将依赖项作为可选参数传递给活动，就像这样:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ls lt l"/></div></figure><p id="a45c" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">运行时，<code class="fe lu lv lw lx b">ExampleActivity</code> <em class="ly"> </em>将用默认值创建，这将创建一个新的真实意图。不过，现在我们可以在测试中将它覆盖为一个模拟对象:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ls lt l"/></div></figure><p id="3f1a" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">注意，放置<code class="fe lu lv lw lx b">relaxed=true</code> <em class="ly"> </em>给出了一个mock，它默认为每个方法调用返回mock。</p><p id="4dd6" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">瞧啊。一个Android活动的单元测试，但是所有Android特有的东西都被安全地嘲笑了。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi mj"><img src="../Images/2d92a2c61ad16b95fc57eb71410de301.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*KIcml0gMQWMV9X9qxU_fwg.jpeg"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated"><a class="ae kv" href="https://unsplash.com/@schmidy?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">奥斯汀·施密德</a>在<a class="ae kv" href="/s/photos/happy-woman-silhouette?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的照片。</p></figure></div></div>    
</body>
</html>