<html>
<head>
<title>Understand reflect in Go</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">理解围棋中的反映</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/understand-reflect-in-go-24a68fcf1011?source=collection_archive---------0-----------------------#2019-10-12">https://betterprogramming.pub/understand-reflect-in-go-24a68fcf1011?source=collection_archive---------0-----------------------#2019-10-12</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="1b1e" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">这种有帮助的方法有什么利弊？</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/e99064d03e39cc50af0886523b93d9d6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1278/format:webp/1*THkRAS-pTocinQLV7whqlQ.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">理解围棋中的反映</p></figure><p id="afea" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">Go是一种强静态类型的编程语言。然而，Go中的一些特性使它看起来像是动态类型的。例如，如果您不确定您将接收什么类型，您可以为一个开放类型实现<code class="fe lu lv lw lx b">interface</code>类型。</p><p id="33df" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">记住只有<code class="fe lu lv lw lx b">interface</code>才有<code class="fe lu lv lw lx b">reflect</code>。</p><p id="2d5c" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">注意<code class="fe lu lv lw lx b">interface</code>允许Go中的多态性。不强制实施任何特定的实现。可以是<code class="fe lu lv lw lx b">string</code>、<code class="fe lu lv lw lx b">int64</code>、<code class="fe lu lv lw lx b">float32</code>，甚至是一个集合(<code class="fe lu lv lw lx b">array</code> / <code class="fe lu lv lw lx b">map</code>)。当计算机运行代码(运行时)，<code class="fe lu lv lw lx b">reflect</code>帮助检查、自省和修改它自己的结构和行为。这个过程允许我们在运行时知道一个对象的类型和内存结构。</p></div><div class="ab cl ly lz hx ma" role="separator"><span class="mb bw bk mc md me"/><span class="mb bw bk mc md me"/><span class="mb bw bk mc md"/></div><div class="im in io ip iq"><h1 id="1d38" class="mf mg it bd mh mi mj mk ml mm mn mo mp jz mq ka mr kc ms kd mt kf mu kg mv mw bi translated">我们为什么需要<code class="fe lu lv lw lx b"><em class="mx">reflect</em></code>？</h1><ol class=""><li id="7db7" class="my mz it la b lb na le nb lh nc ll nd lp ne lt nf ng nh ni bi translated">无法预定义参数类型。(通常发生在公开开放API时)</li><li id="29bc" class="my mz it la b lb nj le nk lh nl ll nm lp nn lt nf ng nh ni bi translated">函数根据参数输入动态执行。</li></ol></div><div class="ab cl ly lz hx ma" role="separator"><span class="mb bw bk mc md me"/><span class="mb bw bk mc md me"/><span class="mb bw bk mc md"/></div><div class="im in io ip iq"><h1 id="3430" class="mf mg it bd mh mi mj mk ml mm mn mo mp jz mq ka mr kc ms kd mt kf mu kg mv mw bi translated"><code class="fe lu lv lw lx b">reflect</code>的缺点</h1><ol class=""><li id="b47e" class="my mz it la b lb na le nb lh nc ll nd lp ne lt nf ng nh ni bi translated">影响代码可读性。</li><li id="164b" class="my mz it la b lb nj le nk lh nl ll nm lp nn lt nf ng nh ni bi translated">在代码编译期间无法检测到错误。<strong class="la iu"> </strong>作为一种静态类型语言，Go编译器在编译时会预先检查一些类型的错误。当在<code class="fe lu lv lw lx b">interface</code>中没有明确定义类型时，服务器在运行代码后有死机的风险。</li><li id="a8ee" class="my mz it la b lb nj le nk lh nl ll nm lp nn lt nf ng nh ni bi translated">降低整体性能。使用<code class="fe lu lv lw lx b">reflect</code>需要服务器做额外的工作来找到参数背后的类型。因此，重要参数尽量避免<code class="fe lu lv lw lx b">interface</code>。</li></ol></div><div class="ab cl ly lz hx ma" role="separator"><span class="mb bw bk mc md me"/><span class="mb bw bk mc md me"/><span class="mb bw bk mc md"/></div><div class="im in io ip iq"><h1 id="8103" class="mf mg it bd mh mi mj mk ml mm mn mo mp jz mq ka mr kc ms kd mt kf mu kg mv mw bi translated">反射的两个基本功能</h1><p id="a88c" class="pw-post-body-paragraph ky kz it la b lb na ju ld le nb jx lg lh no lj lk ll np ln lo lp nq lr ls lt im bi translated"><code class="fe lu lv lw lx b">reflect</code>的两个主要功能是<code class="fe lu lv lw lx b">reflect.Type</code>和<code class="fe lu lv lw lx b">reflect.Value</code>。</p><p id="769d" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">简而言之，<code class="fe lu lv lw lx b">reflect.Type</code>提供了参数类型的信息，而<code class="fe lu lv lw lx b">reflect.Value</code>结合了<code class="fe lu lv lw lx b">_type</code>和<code class="fe lu lv lw lx b">data</code>，允许开发者读取或编辑参数的值。</p><pre class="kj kk kl km gt nr lx ns nt aw nu bi"><span id="786a" class="nv mg it lx b gy nw nx l ny nz">func TypeOf(i interface{}) Type<br/>func ValueOf(i interface{}) Value</span></pre><p id="6bce" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">然后，您可以使用<code class="fe lu lv lw lx b">fmt.Printf()</code>和<code class="fe lu lv lw lx b">%T</code>作为格式化参数来得到<code class="fe lu lv lw lx b">reflect.TypeOf</code>的结果，如下所示:</p><p id="4049" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated"><code class="fe lu lv lw lx b">fmt.Printf("%T", 3) //int</code></p><p id="96dc" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">在<code class="fe lu lv lw lx b">reflect.Type</code>下，<code class="fe lu lv lw lx b">toType</code>是改变类型的方法。</p><pre class="kj kk kl km gt nr lx ns nt aw nu bi"><span id="7f59" class="nv mg it lx b gy nw nx l ny nz">func toType(t * rtype) Type {<br/> if t == nil {<br/> return nil<br/> }<br/> return t<br/>}</span></pre><p id="1db4" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">另一方面，<code class="fe lu lv lw lx b">reflect.Value</code>返回存储在<code class="fe lu lv lw lx b">interface{}</code>中的变量。它有很多方法，包括<code class="fe lu lv lw lx b">SetLen(n int)</code>(设置变量长度)、<code class="fe lu lv lw lx b">SetMapIndex(key, val Value</code>(设置map中的kv)、<code class="fe lu lv lw lx b">Int()</code>(用<code class="fe lu lv lw lx b">int</code>类型获取值)、<code class="fe lu lv lw lx b">TrySend(x reflect.Value)</code>(发送数据到一个通道)等。有关完整文档，请参考<code class="fe lu lv lw lx b">src/reflect/value.go</code>。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi oa"><img src="../Images/fdafd13a9fdb62a5b7b064d9dff4dc7c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*tZXqiv5wQq_F-2Arsxlong.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">Go中反射的类型和值</p></figure></div><div class="ab cl ly lz hx ma" role="separator"><span class="mb bw bk mc md me"/><span class="mb bw bk mc md me"/><span class="mb bw bk mc md"/></div><div class="im in io ip iq"><h1 id="a9a7" class="mf mg it bd mh mi mj mk ml mm mn mo mp jz mq ka mr kc ms kd mt kf mu kg mv mw bi translated">反射中的三个规则</h1><p id="9316" class="pw-post-body-paragraph ky kz it la b lb na ju ld le nb jx lg lh no lj lk ll np ln lo lp nq lr ls lt im bi translated">从Go官方网站:</p><p id="1f02" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">1.反射从接口值到反射对象。<br/> 2。反射从反射对象到接口值。<br/> 3。若要修改反射对象，该值必须是可设置的。</p><p id="52dc" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">典型的例子如下:</p><pre class="kj kk kl km gt nr lx ns nt aw nu bi"><span id="5295" class="nv mg it lx b gy nw nx l ny nz">var x float64 = 3.4<br/>v := reflect.ValueOf(x)<br/>v.SetFloat(7.1) // Error: will panic</span></pre><p id="8f61" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">如果您运行上面的代码，服务器将会死机，因为<code class="fe lu lv lw lx b">v</code>不是<code class="fe lu lv lw lx b">x</code>本身，而仅仅是<code class="fe lu lv lw lx b">x</code>的副本。因此，禁止对<code class="fe lu lv lw lx b">v</code>进行任何修改。</p><p id="5011" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">所以，我们需要一个指针来解决这个问题:</p><pre class="kj kk kl km gt nr lx ns nt aw nu bi"><span id="7249" class="nv mg it lx b gy nw nx l ny nz">var x float64 = 3.4<br/>y := reflect.ValueOf(&amp;x)<br/>fmt.Println(“type of y”, y.Type()) // *float64<br/>fmt.Println(“settability of y:”, y.CanSet()) // false</span></pre><p id="c8a9" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated"><code class="fe lu lv lw lx b">y</code>仍不代表<code class="fe lu lv lw lx b">x</code>。您需要<code class="fe lu lv lw lx b">y.Elem()</code>对其进行修改:</p><pre class="kj kk kl km gt nr lx ns nt aw nu bi"><span id="330b" class="nv mg it lx b gy nw nx l ny nz">z := y.Elem()<br/>z.SetFloat(7.1)<br/>fmt.Println(z.Interface()) // 7.1<br/>fmt.Println(x) // 7.1</span></pre><p id="6af1" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">请注意，指针也会改变所指向的变量；在我们的上下文中，<code class="fe lu lv lw lx b">x</code>。</p></div><div class="ab cl ly lz hx ma" role="separator"><span class="mb bw bk mc md me"/><span class="mb bw bk mc md me"/><span class="mb bw bk mc md"/></div><div class="im in io ip iq"><h1 id="9e8d" class="mf mg it bd mh mi mj mk ml mm mn mo mp jz mq ka mr kc ms kd mt kf mu kg mv mw bi translated">反射的应用</h1><p id="089e" class="pw-post-body-paragraph ky kz it la b lb na ju ld le nb jx lg lh no lj lk ll np ln lo lp nq lr ls lt im bi translated"><code class="fe lu lv lw lx b">reflect</code>广泛应用于对象序列化、<code class="fe lu lv lw lx b">fmt</code>相关函数、ORM(对象关系映射)等。</p><h2 id="cf9c" class="nv mg it bd mh ob oc dn ml od oe dp mp lh of og mr ll oh oi mt lp oj ok mv ol bi translated">1.JSON序列化</h2><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi om"><img src="../Images/ef156684306373ef2614e42af1ad4403.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*KeYIVBWU_o5Qai5N8x9u_g.png"/></div></div></figure><p id="c25a" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">在Go中，有两个函数可以序列化和反序列化:</p><pre class="kj kk kl km gt nr lx ns nt aw nu bi"><span id="b350" class="nv mg it lx b gy nw nx l ny nz">func Marshal(v interface{})([]byte, error)<br/>func Unmarshal(data []byte, v interface{}) error</span></pre><p id="b26e" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">两个函数在参数中都有<code class="fe lu lv lw lx b">interface{}</code>类型，所以当我们调用这些函数时需要<code class="fe lu lv lw lx b">reflect</code>，这样我们就可以知道参数的所有值和类型，从而应用<code class="fe lu lv lw lx b">get</code>或<code class="fe lu lv lw lx b">set</code>方法。</p><h2 id="1ad9" class="nv mg it bd mh ob oc dn ml od oe dp mp lh of og mr ll oh oi mt lp oj ok mv ol bi translated">2.深度相等函数</h2><p id="a015" class="pw-post-body-paragraph ky kz it la b lb na ju ld le nb jx lg lh no lj lk ll np ln lo lp nq lr ls lt im bi translated">在调试函数时，我们经常需要判断两个变量是否完全相同。例如，确定切片中的所有元素是否都相同，或者检查映射的键和值是否相等。这可以通过<code class="fe lu lv lw lx b">DeepEqual</code>功能实现。</p><p id="2ca5" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated"><code class="fe lu lv lw lx b">func DeepEqual(x, y interface{}) bool</code></p><p id="5b7f" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated"><code class="fe lu lv lw lx b">DeepEqual()</code>有两个接口参数。你可以在其中输入任意值，检查两个变量<em class="on">是否与</em>完全相等后，它将返回<code class="fe lu lv lw lx b">true</code>或<code class="fe lu lv lw lx b">false</code>。</p><p id="f518" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">等等，<em class="on">深</em>等于什么？让我们来看一个例子:</p><pre class="kj kk kl km gt nr lx ns nt aw nu bi"><span id="23b6" class="nv mg it lx b gy nw nx l ny nz">type FirstInt int<br/>type SecondInt int</span><span id="2a36" class="nv mg it lx b gy oo nx l ny nz">func main() {<br/> m := FirstInt(1)<br/> n := SecondInt(1)</span><span id="b971" class="nv mg it lx b gy oo nx l ny nz">fmt.Println(reflect.DeepEqual(m, n)) // false<br/>}</span></pre><p id="fe83" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">在上面的例子中，<code class="fe lu lv lw lx b">m</code>和<code class="fe lu lv lw lx b">n</code>都是<code class="fe lu lv lw lx b">int</code>，值都是1。然而，这两个变量的动态类型是不同的。第一个变量<code class="fe lu lv lw lx b">m</code>的类型为<code class="fe lu lv lw lx b">FirstInt</code>，第二个变量<code class="fe lu lv lw lx b">n</code>的类型为<code class="fe lu lv lw lx b">SecondInt</code>。因此，他们并不完全平等。</p></div><div class="ab cl ly lz hx ma" role="separator"><span class="mb bw bk mc md me"/><span class="mb bw bk mc md me"/><span class="mb bw bk mc md"/></div><div class="im in io ip iq"><h1 id="af58" class="mf mg it bd mh mi mj mk ml mm mn mo mp jz mq ka mr kc ms kd mt kf mu kg mv mw bi translated">结论</h1><p id="d3de" class="pw-post-body-paragraph ky kz it la b lb na ju ld le nb jx lg lh no lj lk ll np ln lo lp nq lr ls lt im bi translated">Go作为一种静态语言，与Python这样的动态语言相比，在灵活性上有一定的局限性。但是，通过使用<code class="fe lu lv lw lx b">reflect</code>赋予类似于动态语言的能力，您可以在用Go编写时流畅地获得参数的类型或值。</p></div></div>    
</body>
</html>