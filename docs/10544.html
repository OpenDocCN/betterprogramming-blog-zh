<html>
<head>
<title>How to Implement Multi-file Downloads in Ruby Web Apps</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何在Ruby Web Apps中实现多文件下载</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/how-to-implement-multi-file-downloads-in-ruby-web-apps-a7a6090f3ab5?source=collection_archive---------16-----------------------#2022-01-13">https://betterprogramming.pub/how-to-implement-multi-file-downloads-in-ruby-web-apps-a7a6090f3ab5?source=collection_archive---------16-----------------------#2022-01-13</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="14e5" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">实时流式下载tar和zip文件</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/b047031649f7353eacd39bf6b3c84864.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*RUHRyXhVe-tuE6eFoBrZKw.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">图片来源:作者</p></figure><p id="0165" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">我在威尔康奈尔医学院的第一个挑战是开发一个文件分发门户，允许基因组测序实验室通过网络向合作者分发大数据文件。一个核心需求是一个选择列表功能，这样用户可以创建文件集，从浏览器上一次性下载。</p><p id="7340" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">HTTP很久以前就不具备从一次浏览器点击中下载多个文件的能力，但这是大多数基于web的文件服务的必备功能。更具体地说，这种限制是由于底层TCP将所有传输视为单个文件或流，导致<a class="ae lr" href="https://abhishekvrshny.medium.com/head-of-line-hol-blocking-in-http-1-and-http-2-50b24e9e3372" rel="noopener"> <em class="ls">行首阻塞</em> </a> <em class="ls">。</em> HTTP/3 <a class="ae lr" href="https://www.smashingmagazine.com/2021/08/http3-core-concepts-part1" rel="noopener ugc nofollow" target="_blank">承诺在多路复用和多文件下载方面有更大的灵活性</a>，因为它位于QUIC协议之上，但浏览器文件下载的广泛采用和新标准仍需一段时间。</p><p id="2a3d" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">向浏览器扩展和下载管理器软件提供文件URL列表始终是一个选项，但这是一个硬推销，尤其是对于一次性访问者来说不方便，他们不想安装新软件只是为了下载一组数据。我们最好的解决方法是将文件存档(如tar或zip)到一个文件中供下载，这仍然是Google Drive、MS SharePoint和所有大公司使用的方法。</p><p id="ad39" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">问题就变成了:先存档后下载，还是通过流式下载即时存档？归档到一个临时文件，然后从磁盘提供静态文件，这很有吸引力，因为它实现起来既熟悉又简单。然而，真正的挑战是在归档文件创建之后实现所有的东西，例如:用户要等多久，当下载准备好了，你如何通知他们？您将文件保留多长时间以供下载？如果文件在归档文件创建后、下载完成前发生了变化，该怎么办？只有在考虑了所有这些因素之后，流式传输才成为明显的赢家。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi lt"><img src="../Images/883332af5367eb1c5e420d71469ab5b1.png" data-original-src="https://miro.medium.com/v2/resize:fit:300/format:webp/1*tcG7gLzxsyAkib0csmLc7A.png"/></div></figure><h1 id="225b" class="lu lv iq bd lw lx ly lz ma mb mc md me jw mf jx mg jz mh ka mi kc mj kd mk ml bi translated">使用Ruby Rack套接字劫持流式传输Tar文件</h1><p id="2f7a" class="pw-post-body-paragraph kv kw iq kx b ky mm jr la lb mn ju ld le mo lg lh li mp lk ll lm mq lo lp lq ij bi translated">与zip文件相比，下载tar文件对用户的技术能力要求稍高一些——tar文件提取已经被OSX本地支持了一段时间，但直到最近才被Windows支持，对于普通网络用户来说，tar文件不像zip文件那样普遍或熟悉。如果您的用户更专业，就像我的生物信息学数据分发门户一样，tar通常是首选格式。</p><p id="c4a2" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">tar和zip格式的主要区别在于tar没有被压缩，这使得tar文件的结构相对简单，如下所述。tar文件中的每个<em class="ls">条目</em>都有一个包含元数据和一个或多个文件数据内容块的头。这种未压缩的顺序结构简化了流式传输，因为每个文件都可以从磁盘上读取并作为新条目附加，无需任何特殊处理。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi mr"><img src="../Images/fc99c76b17f4dc4c8bb04806d8047e61.png" data-original-src="https://miro.medium.com/v2/resize:fit:824/format:webp/1*JmL03xgeeijlJn3VoWYEZA.png"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">来自<a class="ae lr" href="https://jackrabbit.apache.org/oak/docs/index.html" rel="noopener ugc nofollow" target="_blank"> Jackrabbit Oak docs </a>的Apache软件基金会</p></figure><p id="d1d7" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">例如，当在生物信息学中处理大数据时，任何可以通过压缩显著减小大小的(基于文本的)文件(例如gzip)通常已经被压缩，并作为压缩文件四处传播。因此，提取大型未压缩tar文件在速度上的提升远远超过压缩已压缩文件在大小上的任何微小提升。</p><p id="99a9" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">当谈到选择堆栈时，Ruby是我的第一选择，只是因为其他遗留集成应用程序是用Rails编写的，并且由于tar文件的这种未压缩的顺序结构，流式传输变得非常简单。</p><p id="ea73" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">Rack 是Rails背后的底层接口，提供基本的、最基本的HTTP交互。Rack的一个鲜为人知的特性是<a class="ae lr" href="https://old.blog.phusion.nl/2013/01/23/the-new-rack-socket-hijacking-api" rel="noopener ugc nofollow" target="_blank">套接字劫持API </a>，它允许从Ruby IO流直接写入套接字。现在，通过将下面几行代码添加到<code class="fe ms mt mu mv b">config.ru</code>中，我们有了一个tar流解决方案。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mw mx l"/></div></figure><p id="1e38" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">根据您的用例，如果您使用反向代理，您可能需要花一些时间来微调应用服务器工作内存和Nginx/Apache缓冲区。在我们的例子中，我们正在传输非常大的文件(100GB以上),并成功地使用Linux <a class="ae lr" href="http://www.ivarch.com/programs/pv.shtml" rel="noopener ugc nofollow" target="_blank"> Pipe Viewer </a>实用程序来限制tar输出速度并为并发下载提供更多带宽。我们的tar命令看起来更像这样:</p><pre class="kg kh ki kj gt my mv mz na aw nb bi"><span id="fa2c" class="nc lv iq mv b gy nd ne l nf ng">tar --to-stdout -c #{env['tar_path']} | pv -q -L #{env['pv_limit']}</span></pre><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi nh"><img src="../Images/4c38c2c0c894164d373551aae450f7dc.png" data-original-src="https://miro.medium.com/v2/resize:fit:312/format:webp/1*01KK7fJQSkdgFOPHWzCigw.png"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">来源:<a class="ae lr" href="http://sinatrarb.com/" rel="noopener ugc nofollow" target="_blank">辛纳特拉</a></p></figure><h1 id="8557" class="lu lv iq bd lw lx ly lz ma mb mc md me jw mf jx mg jz mh ka mi kc mj kd mk ml bi translated">使用Ruby Sinatra流式传输Zip文件</h1><p id="ce98" class="pw-post-body-paragraph kv kw iq kx b ky mm jr la lb mn ju ld le mo lg lh li mp lk ll lm mq lo lp lq ij bi translated"><em class="ls">TL；DR: Zip streaming只是稍微有些棘手，请查看</em><a class="ae lr" href="https://github.com/WeTransfer/zip_tricks" rel="noopener ugc nofollow" target="_blank"><em class="ls">Zip _ tricks</em></a><em class="ls">库示例或我们的</em><a class="ae lr" href="https://github.com/whitebrick/fileslide-streamer" rel="noopener ugc nofollow" target="_blank"><em class="ls">FileSlide Streamer</em></a><em class="ls">微服务。</em></p><p id="5c48" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">最近，我正在开发一个更通用、更大规模的数据分发SaaS，我们再次需要一个多文件下载功能，但这一次，因为我们的用户不太懂技术，我们必须交付zip文件，而不是tar文件。</p><p id="41ba" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">我的第一个想法是，肯定有某种服务可以为我们处理这个问题，我们传递几个URIs，然后它会返回一个zip。整整一个上午在网上搜索没有结果——我发现了许多文件上传和转换/转码服务，如FileStack，它们可以在文件上传后压缩文件，但它们按带宽收费，所以这就像用大锤砸坚果一样。</p><p id="c0b9" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">我还想也许有某种方法可以使用云备份服务，如Backblaze，将选择的文件备份到zip文件中并提取链接，但从我收集的信息来看，只能压缩整个图像，而不是任意选择的文件。</p><p id="9974" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">放弃寻找一个插入式服务，我的下一个攻击计划是尝试找出大玩家使用的栈和库，并希望其中一个是开源的。没有特别搜索Ruby，我很快看到了一个精彩的演示，作者是Julik塔哈诺夫，他为T21 we transfer提供了一个压缩流解决方案，每天压缩数百万个文件。</p><p id="38b4" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">WeTransfer有一个整洁的开源库，名为<a class="ae lr" href="https://github.com/WeTransfer/zip_tricks" rel="noopener ugc nofollow" target="_blank"> zip_tricks </a>，可以处理他们所有的动态压缩，对我来说很方便，它是用Ruby编写的。</p><p id="2ab3" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">凭借Julik的演示、<code class="fe ms mt mu mv b">zip_tricks</code>库以及我在Rack tar流方面的经验，我着手构建一个zip流微服务。我计划了一个有限的功能集——解析请求、验证参数、返回有用的错误、获取文件和调用web hooks——足以让我不想在Rack中做所有的事情，但还不足以证明一个成熟的Rails应用程序的合理性。这是鲁比·辛纳特拉作为一个很好的中间者插话(或演唱)的地方。</p><p id="eb87" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">在使用Sinatra示例和zip_tricks文档几天之后，我就是无法让我的代码交付压缩的字节流——它总是返回空文件或无休止的响应。截止日期很快就要到了，所以我求助于<a class="ae lr" href="https://github.com/WJWH" rel="noopener ugc nofollow" target="_blank">旺达·希伦</a>的专家，他最终为我们的<a class="ae lr" href="https://github.com/whitebrick/fileslide-streamer" rel="noopener ugc nofollow" target="_blank"> FileSlide Streamer </a>应用做了所有繁重的工作。</p><p id="d598" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">在查看代码之前，有必要了解一下zip文件的基本结构。同样，我们有一组连续的条目，每个条目都有一个标题和内容数据，但此外，我们在文件的末尾有一个<em class="ls">中央目录</em>，应用程序可以扫描该目录以快速显示归档的内容，而不必读取整个文件。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi mr"><img src="../Images/d3cd2688abd020f2f27dbda52c8ada4e.png" data-original-src="https://miro.medium.com/v2/resize:fit:824/format:webp/1*4l2Gpi2mnUP0z9EEh5l-7w.png"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">来自<a class="ae lr" href="https://commons.wikimedia.org/wiki/File:ZIP_File_Format.png" rel="noopener ugc nofollow" target="_blank">维基共享资源</a>的约翰·亚米奇</p></figure><p id="0976" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">因为中央目录位于文件的末尾，所以我们仍然可以按顺序传输数据，只需跟踪每个文件的元数据，最后写入中央目录。然而，与tar的另一个主要区别是，这种格式需要几个<a class="ae lr" href="https://users.cs.jmu.edu/buchhofp/forensics/formats/pkzip.html" rel="noopener ugc nofollow" target="_blank">本地头</a>，它们需要按顺序编写，但是预先计算起来有点复杂。首先,<code class="fe ms mt mu mv b">CRC-32</code>字段是未压缩文件的校验和，所以这里唯一的问题是，对于大文件，这可能需要一些时间来计算，我们不希望流在开始之前等待太久。其次，<code class="fe ms mt mu mv b">Compressed size</code>字段用于记录压缩文件的大小，这里的挑战是我们需要在写zip流之前知道这个<em class="ls">。</em></p><p id="c627" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">在典型的zip创建场景中，库将在关闭文件之前写入压缩文件、计算大小、倒带并更新文件头。任何形式的倒带显然都不适用于流应用程序，这就是zip_tricks做一些非常聪明的处理的地方，它写出一个假的归档文件来估计大小，并在不倒带的情况下组装流。</p><p id="ae1d" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">因此，有了<code class="fe ms mt mu mv b">zip_tricks</code>和下面列出的几行代码，我们就可以在Sinatra上运行一个基本的zip流媒体应用程序。</p><p id="9e7b" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">关于库如何与Rack交互的更深入的解释，请看Wander的<a class="ae lr" href="https://wjwh.eu/posts/2020-11-01-ruby-streaming-http.html" rel="noopener ugc nofollow" target="_blank">帖子</a>。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mw mx l"/></div></figure></div><div class="ab cl ni nj hu nk" role="separator"><span class="nl bw bk nm nn no"/><span class="nl bw bk nm nn no"/><span class="nl bw bk nm nn"/></div><div class="ij ik il im in"><h1 id="d7ce" class="lu lv iq bd lw lx np lz ma mb nq md me jw nr jx mg jz ns ka mi kc nt kd mk ml bi translated">范围请求和恢复压缩流</h1><p id="e5b7" class="pw-post-body-paragraph kv kw iq kx b ky mm jr la lb mn ju ld le mo lg lh li mp lk ll lm mq lo lp lq ij bi translated">大多数现代浏览器通过在头部发出<a class="ae lr" href="https://developer.mozilla.org/en-US/docs/Web/HTTP/Range_requests" rel="noopener ugc nofollow" target="_blank"> HTTP范围请求</a>来支持下载恢复，例如<code class="fe ms mt mu mv b">Range: bytes=256–1023</code>。当从磁盘提供静态文件时，只需打开文件并读取相应的字节范围。然而，当流式传输文件时，我们需要从头开始传输，丢弃到范围的开始处(同时保持客户端等待)，然后处理剩余的长度。</p><p id="79c0" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">随着高速互联网的普及，恢复流的唯一真实的使用情况是如果zip非常大(千兆字节),因此由几个大文件或大量较小文件组成。无论哪种方式，重新构建一个大的zip文件只是为了丢弃它的一部分是低效的，并且会导致浏览器在等待特定范围时超时。除此之外，我们的微服务没有将文件放在磁盘上，而是必须从远程服务器获取它们，这使得等待时间问题变得更加严重。</p><p id="fc7c" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">为了解决这个问题，Wander实现了一个<a class="ae lr" href="https://github.com/whitebrick/fileslide-streamer/blob/3a99c4ff7de5783bf0f81f1ac7735c557567dfbd/lib/zip_streamer.rb#L225" rel="noopener ugc nofollow" target="_blank">方法</a>,用占位符对象模拟文件，以使流尽可能快地移动，这个例子突出了Sinatra的优点——您可以直接访问请求和响应，以处理和调整到您自己的用例。</p><p id="901c" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">无论是压缩还是去皮，文件存档仍然是允许用户一次点击下载多个文件的最佳选择，目前看来，它将继续存在。Ruby Rack为直接从操作系统流式传输做了很好的设置，像<a class="ae lr" href="https://github.com/WeTransfer/zip_tricks" rel="noopener ugc nofollow" target="_blank"> zip_tricks </a>这样的开源库让流式传输zip文件变得轻而易举。要在野外看到它，请查看我们在GitHub上的<a class="ae lr" href="http://github.com/whitebrick/fileslide-streamer" rel="noopener ugc nofollow" target="_blank"> FileSlide Streamer </a>微服务。</p></div></div>    
</body>
</html>