<html>
<head>
<title>Learn Dynamic Programming: A Beginner’s Guide to the Coin Change Problem</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">学习动态编程:硬币兑换问题初学者指南</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/learn-dynamic-programming-the-coin-change-problem-22a104478f50?source=collection_archive---------2-----------------------#2022-03-22">https://betterprogramming.pub/learn-dynamic-programming-the-coin-change-problem-22a104478f50?source=collection_archive---------2-----------------------#2022-03-22</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="a5d3" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">通过学习动态编程的基础知识，提高你的面试技巧，成为一名更好的开发人员</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/99edc0dabcbfc61498e14137f5e1d77c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*zSh5v9qABH8qSl-CKYqOJw.jpeg"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">米歇尔的照片||视觉故事在<a class="ae kv" href="https://unsplash.com/?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a></p></figure><p id="4f93" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">动态编程是一种解决复杂问题的方法，它包括将问题分解成更简单的问题并解决这些问题。如果你被要求乘21 * 5，你可能会选择乘(20 * 5)加(1 * 5)。你没有解决一个复杂的问题，而是把它分解成三个简单的问题并解决它们。</p><ul class=""><li id="2d14" class="ls lt iq ky b kz la lc ld lf lu lj lv ln lw lr lx ly lz ma bi">20 * 5 = 100</li><li id="b1ec" class="ls lt iq ky b kz mb lc mc lf md lj me ln mf lr lx ly lz ma bi">1 * 5 = 5</li><li id="6a16" class="ls lt iq ky b kz mb lc mc lf md lj me ln mf lr lx ly lz ma bi">100 + 5 = 105</li></ul><p id="b7df" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">正如我们将会看到的，这与动态编程中发生的事情并不<em class="mg">完全</em>相同，但它确实说明了通过将复杂问题分解成多个更简单的问题来解决它的基本思想。</p><h1 id="74a8" class="mh mi iq bd mj mk ml mm mn mo mp mq mr jw ms jx mt jz mu ka mv kc mw kd mx my bi translated">硬币兑换问题</h1><p id="4cb0" class="pw-post-body-paragraph kw kx iq ky b kz mz jr lb lc na ju le lf nb lh li lj nc ll lm ln nd lp lq lr ij bi translated">解释动态编程最常用的问题之一是硬币兑换问题。问题如下。</p><blockquote class="ne nf ng"><p id="f18b" class="kw kx mg ky b kz la jr lb lc ld ju le nh lg lh li ni lk ll lm nj lo lp lq lr ij bi translated">给你一个整数数组"<strong class="ky ir"><em class="iq">" coins "</em></strong>"代表不同面额的硬币和一个整数"<strong class="ky ir"> amount" </strong>"代表钱的总数。</p><p id="167b" class="kw kx mg ky b kz la jr lb lc ld ju le nh lg lh li ni lk ll lm nj lo lp lq lr ij bi translated">归还你需要的最少数量的硬币来补足这个数目。如果任何硬币的组合都无法补足该金额，则返回-1。</p><p id="5dcb" class="kw kx mg ky b kz la jr lb lc ld ju le nh lg lh li ni lk ll lm nj lo lp lq lr ij bi translated">你可以假设每种硬币都有无限个。</p></blockquote><p id="d339" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">例如，假设我们正在处理普通的美国硬币(便士、镍币、一角硬币、两角五分硬币),需要返回87美分的零钱。在这种情况下，我们将获得两个输入:</p><pre class="kg kh ki kj gt nk nl nm nn aw no bi"><span id="af2a" class="np mi iq nl b gy nq nr l ns nt">amount = 87<br/>coins = [ 1, 5, 10, 25 ]</span></pre><p id="57ba" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们可以用来返还87美分零钱的最少硬币数量是6枚硬币:3枚25美分硬币、1枚10美分硬币和2枚1美分硬币。所以我们的函数应该返回6。</p><p id="1010" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">首先，让我们考虑一下在不使用动态编程的情况下，我们将如何处理这个问题。最简单的解决方案是暴力方法。简单地确定组成87的所有可能的硬币组合，然后返回最小集合的大小。这是可行的，但效率极低，尤其是对于较大的问题。</p><p id="cc30" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">另一种方法是使用<a class="ae kv" href="https://en.m.wikipedia.org/wiki/Greedy_algorithm" rel="noopener ugc nofollow" target="_blank">贪婪算法</a>。贪婪算法是在每一步做出最佳选择的算法，称为“局部最优”选择。在这种情况下，这意味着总是选择最大的硬币。让我们一步一步来看看这是如何工作的。</p><ol class=""><li id="4f6c" class="ls lt iq ky b kz la lc ld lf lu lj lv ln lw lr nu ly lz ma bi translated">剩余:87。选择:季度(25)。</li><li id="b105" class="ls lt iq ky b kz mb lc mc lf md lj me ln mf lr nu ly lz ma bi translated">剩余:62。选择:季度(25)。</li><li id="5af1" class="ls lt iq ky b kz mb lc mc lf md lj me ln mf lr nu ly lz ma bi translated">剩余:37。选择:季度(25)。</li><li id="f150" class="ls lt iq ky b kz mb lc mc lf md lj me ln mf lr nu ly lz ma bi translated">剩余:12。选择:一角(10)。</li><li id="386d" class="ls lt iq ky b kz mb lc mc lf md lj me ln mf lr nu ly lz ma bi translated">剩余:2。选择:便士(1)。</li><li id="74bd" class="ls lt iq ky b kz mb lc mc lf md lj me ln mf lr nu ly lz ma bi translated">剩余:1。选择:便士(1)。</li></ol><p id="a5fe" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">解决方案:6</p><p id="9746" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">使用贪婪算法，我们很快发现所需的最少硬币数是6枚硬币(3枚25美分硬币、1枚1角硬币和2枚1分硬币)。</p><p id="fea9" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">贪婪的解决方案对于这个特定的例子来说很好。实际上，它适用于任何使用美国硬币的例子，因为美国硬币使用特定的面额。但是在某些情况下，它无法找到更普遍的硬币兑换问题的正确解决方案。考虑以下问题。</p><pre class="kg kh ki kj gt nk nl nm nn aw no bi"><span id="9d30" class="np mi iq nl b gy nq nr l ns nt">amount = 20<br/>coins = [ 3, 8, 11 ]</span></pre><p id="b2a2" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">贪婪算法将进行以下尝试。</p><ol class=""><li id="57ef" class="ls lt iq ky b kz la lc ld lf lu lj lv ln lw lr nu ly lz ma bi translated">剩余:20。选:11。</li><li id="266b" class="ls lt iq ky b kz mb lc mc lf md lj me ln mf lr nu ly lz ma bi translated">剩余:9。选择:8。</li><li id="944c" class="ls lt iq ky b kz mb lc mc lf md lj me ln mf lr nu ly lz ma bi translated">剩余:1。没有有效的选择。</li></ol><p id="198c" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">解:-1(不可解)</p><p id="c3d1" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">但这是不正确的。在第一次选择11个之后，我们还剩9个。展望未来，我们可以看到这可以通过选择3三次来实现。但是我们贪婪的算法不知道这一点。它旨在使<em class="mg">成为本地</em>的最佳选择——选择当前可用的<em class="mg">最高面额。在这种情况下，由于8(在剩余的9个中)是合适的，所以选择8。我们需要的是一种算法，它可以“向前看”，看到虽然8是局部的<em class="mg"/>最优选择，但它不是长期的最优选择。这正是动态编程所做的。正如动态编程的一个定义所解释的，动态编程被设计成“整体问题的最优解依赖于其子问题的最优解。”</em></p><p id="f600" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">动态规划的关键是识别给主问题“最优子结构性质”的子问题。这只是一种正式的说法，关键是识别子问题，让我们通过反复解决子问题来解决主问题。</p><p id="5025" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">举个简单的例子，假设我们生活在一个世界里，把任何两个大于1的数a相加都太复杂了，我们被赋予了求解3 + 2的不可能任务。事实证明，我们很幸运！我们的问题具有最优子结构性质。我们知道2就是1 + 1。所以我们可以把我们的问题简化为</p><pre class="kg kh ki kj gt nk nl nm nn aw no bi"><span id="d735" class="np mi iq nl b gy nq nr l ns nt">3 + (1 + 1)</span></pre><p id="4fe9" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们知道3是2 + 1，所以我们可以进一步简化为</p><pre class="kg kh ki kj gt nk nl nm nn aw no bi"><span id="d956" class="np mi iq nl b gy nq nr l ns nt">(2 + 1) + (1 + 1)</span></pre><p id="2451" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们已经解决了2的子问题。是1 + 1。因此，我们的原始问题可以被改写为只是我们的子问题的重复解决。</p><pre class="kg kh ki kj gt nk nl nm nn aw no bi"><span id="c42d" class="np mi iq nl b gy nq nr l ns nt">1 + 1 + 1 + 1 + 1</span></pre><p id="964f" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这是一个我们可以解决的问题。(任何读到这里的数学家都会对我的插图不满意，这是理所当然的。别想太多。不是数学证明，只是举例说明。)</p><p id="52bc" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">回到我们的硬币兑换问题，我们的任务是识别子问题(“1 + 1”)，为了解决我们的主要问题，我们可以重复解决这个子问题。这是一项艰巨的任务，但实际上比听起来简单得多。事实上你已经知道答案了，只是你没有意识到而已。</p><p id="f8b6" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">以下是我们的解决方法。如果一个给定的硬币兑换问题是可解的，那么在某一点上，我们将得到最后一个硬币，它的面额正好等于剩余的金额。想象一下，我们使用标准的美国硬币，剩下5美分可以兑换。一枚镍币正好等于这个数量，所以我们的最后一枚硬币就是这枚镍币。这意味着返回的硬币总数将是我们之前<em class="mg">和</em>返回的硬币数(为了只剩下5美分我们需要的硬币数)再加上一个:我们最后的镍币。</p><p id="7018" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们可以用下面的形式描述来表示我们刚才所说的。</p><blockquote class="nv"><p id="3c66" class="nw nx iq bd ny nz oa ob oc od oe lr dk translated">F(a) = F(a - c) + 1</p></blockquote><p id="af8f" class="pw-post-body-paragraph kw kx iq ky b kz of jr lb lc og ju le lf oh lh li lj oi ll lm ln oj lp lq lr ij bi translated">在哪里</p><ul class=""><li id="6154" class="ls lt iq ky b kz la lc ld lf lu lj lv ln lw lr lx ly lz ma bi translated">F =我们求解硬币数量的函数</li><li id="9808" class="ls lt iq ky b kz mb lc mc lf md lj me ln mf lr lx ly lz ma bi translated">a =要找零的金额</li><li id="a858" class="ls lt iq ky b kz mb lc mc lf md lj me ln mf lr lx ly lz ma bi translated">c =我们将归还的最后一枚硬币的面额</li></ul><p id="271c" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这将是这样的，“为某一金额<code class="fe ok ol om nl b">a</code>找零所需的最小硬币数等于1加上为<code class="fe ok ol om nl b">a</code>找零所需的最小硬币数减去<code class="fe ok ol om nl b">c</code>，其中<code class="fe ok ol om nl b">c</code>是用于找零的最后一枚硬币。”</p><p id="7745" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">因此，将这一点应用到我们的镍的例子中，让我们假设我们要找的零钱是40美分。这意味着a = 40。既然我们已经说过五分硬币将是我们返回的最后一枚硬币，这意味着c = 5。所以把这些值代入a和c，我们得到</p><pre class="kg kh ki kj gt nk nl nm nn aw no bi"><span id="26bc" class="np mi iq nl b gy nq nr l ns nt">F(40) = F(40 - 5) + 1</span></pre><p id="528b" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这简化为</p><pre class="kg kh ki kj gt nk nl nm nn aw no bi"><span id="3933" class="np mi iq nl b gy nq nr l ns nt">F(40) = F(35) + 1</span></pre><p id="9a93" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">换句话说，兑换40美分所需的硬币数量等于兑换35美分所需的硬币数量，再加上一枚硬币(我们最后的镍币)。</p><p id="dda6" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这是关键的一步——现在我们将为35解决这个同样的子问题(姑且称之为“最终硬币子问题”)。</p><pre class="kg kh ki kj gt nk nl nm nn aw no bi"><span id="36df" class="np mi iq nl b gy nq nr l ns nt">F(35) = F(35 - c) + 1</span></pre><p id="60ea" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们将使用一角硬币作为这里的最后一个硬币面额(我们将在一分钟内了解如何做出这一选择，但现在让我们假设它是一角硬币)。所以用一角硬币(10)代替c，我们得到</p><pre class="kg kh ki kj gt nk nl nm nn aw no bi"><span id="8cae" class="np mi iq nl b gy nq nr l ns nt">F(35) = F(35 - 10) + 1</span></pre><p id="a3d1" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这简化为</p><pre class="kg kh ki kj gt nk nl nm nn aw no bi"><span id="348a" class="np mi iq nl b gy nq nr l ns nt">F(35) = F(25) + 1</span></pre><p id="1280" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">所以，35美分找零需要的硬币数等于25美分找零需要的硬币数，再加上一个硬币(我们用的一角硬币)。记得我们之前的等式是</p><pre class="kg kh ki kj gt nk nl nm nn aw no bi"><span id="f2f0" class="np mi iq nl b gy nq nr l ns nt">F(40) = F(35) + 1</span></pre><p id="97d8" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们可以代入新发现的F(35 ),得到</p><pre class="kg kh ki kj gt nk nl nm nn aw no bi"><span id="643a" class="np mi iq nl b gy nq nr l ns nt">F(40) = (F(25) + 1) + 1</span></pre><p id="f60e" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">或者</p><pre class="kg kh ki kj gt nk nl nm nn aw no bi"><span id="6d2a" class="np mi iq nl b gy nq nr l ns nt">F(40) = F(25) + 2</span></pre><p id="1b8c" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">因此，找零40美分所需的硬币数量等于找零25美分所需的硬币数量，再加上2个硬币(我们在前面两个子问题中使用的一角硬币和五分硬币)。从这里很容易看出我们对这个问题的解决方案是3。通过反复解决最后一个硬币子问题，我们已经解决了最初的问题。</p><p id="a455" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">现在，我们需要知道的最后一件事是，对于给定的最终硬币子问题，如何确定哪个硬币应该是最终硬币。本质上，我们将重复试错，以确定哪个硬币为给定子问题提供了最佳解决方案。对每个子问题都这样做将会给我们主要问题的最优解。</p><p id="168f" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">有两种编码方法可供我们选择:“自顶向下”方法或“自底向上”方法。本文将介绍自顶向下的方法。</p><h1 id="3574" class="mh mi iq bd mj mk ml mm mn mo mp mq mr jw ms jx mt jz mu ka mv kc mw kd mx my bi translated">自顶向下(递归)方法</h1><p id="f7b3" class="pw-post-body-paragraph kw kx iq ky b kz mz jr lb lc na ju le lf nb lh li lj nc ll lm ln nd lp lq lr ij bi translated">在自上而下的方法中，我们将从起始金额开始，并使用每个可能的硬币面额作为子问题中的“最终硬币”，递归地尝试解决我们的子问题。所以用上面的标准美国硬币的例子，我们的问题是</p><pre class="kg kh ki kj gt nk nl nm nn aw no bi"><span id="f004" class="np mi iq nl b gy nq nr l ns nt">amount = 40<br/>coins = [ 1, 5, 10, 25 ]</span></pre><p id="d2c2" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们将把我们的子问题表示为</p><pre class="kg kh ki kj gt nk nl nm nn aw no bi"><span id="0b0c" class="np mi iq nl b gy nq nr l ns nt">min_coins(40) = min_coins(40 — c) + 1</span></pre><p id="a63e" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">并求解<code class="fe ok ol om nl b">c (using standard US coins 1, 5, 10, 25)</code>的每个可能值，使用最优结果(即所需硬币的最小数量)。</p><p id="5a10" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">所以我们会检查</p><ul class=""><li id="c2e4" class="ls lt iq ky b kz la lc ld lf lu lj lv ln lw lr lx ly lz ma bi translated"><code class="fe ok ol om nl b">min_coins(40 — 25) + 1</code></li><li id="d3bf" class="ls lt iq ky b kz mb lc mc lf md lj me ln mf lr lx ly lz ma bi translated"><code class="fe ok ol om nl b">min_coins(40 — 10) + 1</code></li><li id="adfa" class="ls lt iq ky b kz mb lc mc lf md lj me ln mf lr lx ly lz ma bi translated"><code class="fe ok ol om nl b">min_coins(40 — 5) + 1</code></li><li id="9116" class="ls lt iq ky b kz mb lc mc lf md lj me ln mf lr lx ly lz ma bi translated"><code class="fe ok ol om nl b">min_coins(40 — 1) + 1</code></li></ul><p id="cc86" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">对于每一个可能的硬币，我们递归地检查这些子问题。因此</p><p id="50cd" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><code class="fe ok ol om nl b">min_coins(40 — 25) + 1</code></p><p id="270e" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">简化为</p><p id="4673" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><code class="fe ok ol om nl b">min_coins(15) + 1</code></p><p id="b322" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">然后我们为每个可能的硬币解决这个子问题</p><ul class=""><li id="a4a6" class="ls lt iq ky b kz la lc ld lf lu lj lv ln lw lr lx ly lz ma bi translated"><code class="fe ok ol om nl b">min_coins(15 — 25) + 1 =&gt; -1</code></li><li id="af4f" class="ls lt iq ky b kz mb lc mc lf md lj me ln mf lr lx ly lz ma bi translated"><code class="fe ok ol om nl b">min_coins(15 — 10) + 1</code></li><li id="a624" class="ls lt iq ky b kz mb lc mc lf md lj me ln mf lr lx ly lz ma bi translated"><code class="fe ok ol om nl b">min_coins(15 — 5) + 1</code></li><li id="4658" class="ls lt iq ky b kz mb lc mc lf md lj me ln mf lr lx ly lz ma bi translated"><code class="fe ok ol om nl b">min_coins(15 — 1) + 1</code></li></ul><p id="128f" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">注意，在这种情况下，我们的第一次尝试产生了-1，代表一个不可解的解。这表明我们的动态规划算法已经决定，当我们返回40美分的零钱时，我们不能从选择两个25美分开始。</p><p id="dcc0" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在我们看一些代码之前，我们需要理解的最后一个概念是<a class="ae kv" href="http://wikipedia.org/wiki/Memoization" rel="noopener ugc nofollow" target="_blank">记忆化</a>。记忆化只是指缓存昂贵的函数调用的结果，这样我们就不必再次调用函数。例如，一旦我们计算出兑换11美分所需的最小硬币数，我们将缓存该结果，并将其用于所有未来的呼叫，这样我们就不必每次都重新计算。</p><p id="01c3" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">好了，让我们来看看一些代码。为了尽可能降低门槛，我将用Javascript、Python、Kotlin和Swift提供解决方案。请随意使用您最熟悉的语言，因为所有四个代码片段都包含完全相同的算法。在完成下面的代码后，我们将在文章的剩余部分一步一步地浏览代码。</p><h2 id="95c6" class="np mi iq bd mj on oo dn mn op oq dp mr lf or os mt lj ot ou mv ln ov ow mx ox bi translated">java描述语言</h2><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="oy oz l"/></div></figure><h2 id="1a8d" class="np mi iq bd mj on oo dn mn op oq dp mr lf or os mt lj ot ou mv ln ov ow mx ox bi translated">计算机编程语言</h2><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="oy oz l"/></div></figure><h2 id="7e5b" class="np mi iq bd mj on oo dn mn op oq dp mr lf or os mt lj ot ou mv ln ov ow mx ox bi translated">科特林</h2><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="oy oz l"/></div></figure><h2 id="9e44" class="np mi iq bd mj on oo dn mn op oq dp mr lf or os mt lj ot ou mv ln ov ow mx ox bi translated">迅速发生的</h2><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="oy oz l"/></div></figure><p id="5572" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">让我们浏览一下代码。(提前向Python读者道歉，使用camel case引用变量名，但其他3种语言都使用camel case)。我们有两个函数，都叫做<code class="fe ok ol om nl b">coinChange</code>。第一个将我们的两个输入<code class="fe ok ol om nl b">coins</code>和<code class="fe ok ol om nl b">amount</code>作为参数。第二个函数添加了一个名为<code class="fe ok ol om nl b">solutions</code>的附加参数。这个参数是我们的记忆表。例如，当我们找到一个8的子问题的解时，我们将把它存储在记忆表数组的第8个索引中。在我们的初始函数中，我们将创建一个大小为amount的空数组，足够容纳所有可能的子问题的解决方案。</p><p id="3e41" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">第二个<code class="fe ok ol om nl b">coinChange</code>函数将作为我们的递归函数。它最初由第一个<code class="fe ok ol om nl b"> coinChang</code> e函数调用，然后继续调用自己，每次调用都将剩余的量用于下一个子问题。这就是将第二个参数命名为<code class="fe ok ol om nl b"> amountRemainin</code> g而不是像我们在第一个函数中那样命名为<code class="fe ok ol om nl b"> amoun</code> t的原因。所以让我们一步一步来看这个递归函数。</p><p id="92e6" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">前两行涵盖了递归函数的基本条件。如果我们的剩余量小于0，那么我们就达到了一个不可能的解，并返回-1，如问题说明中所指定的。如果余额正好是0，那么我们返回0，因为它需要0个硬币来兑换0。</p><p id="efd6" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">下一步利用我们的记忆表<code class="fe ok ol om nl b">solutions</code>。在我们计算如何为<code class="fe ok ol om nl b">amountRemaining</code>做出改变之前，我们需要检查我们是否已经计算了如何最好地为<code class="fe ok ol om nl b">amountRemaining</code>做出改变(这将存储在<code class="fe ok ol om nl b">solutions</code>中的索引<code class="fe ok ol om nl b">amountRemaining — 1</code>)。如果是这样，返回我们已经计算过的缓存值。</p><p id="68d5" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">如果我们通过了这三个步骤，那么我们就有了一个有效的<code class="fe ok ol om nl b">amountRemaining</code>，我们还没有确定它的最优解。所以现在我们需要确定<code class="fe ok ol om nl b">amountRemaining</code>的最优解。我们将通过探索如果我们使用现有的每一枚硬币会发生什么来做到这一点。这就是递归的由来。</p><p id="468b" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">假设我们试图找72美分的零钱，在我们的假设场景中还剩47美分。我们将通过递归调用我们的<code class="fe ok ol om nl b">coinChange</code>函数<em class="mg">为每一种可能的硬币面额确定找零47美分的最佳解决方案。</em>我们实际上是在说，“假设此时我们选择下一个季度。需要多少硬币才能换成零钱？如果我们选择了一角硬币呢？一枚镍币怎么样？一分钱呢？”</p><p id="45d4" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">关键步骤如下(语法可能因语言不同而略有不同)</p><pre class="kg kh ki kj gt nk nl nm nn aw no bi"><span id="bdaf" class="np mi iq nl b gy nq nr l ns nt">solutionUsingThisCoin = coinChange(coins, amountRemaining - coin, solutions)</span></pre><p id="acd6" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这个呢</p><pre class="kg kh ki kj gt nk nl nm nn aw no bi"><span id="9e7e" class="np mi iq nl b gy nq nr l ns nt"><em class="mg">if </em>solutionUsingThisCoin &gt;= 0 &amp;&amp; solutionUsingThisCoin &lt; optimalSolution {<br/>    optimalSolution = solutionUsingThisCoin + 1<br/>}</span></pre><p id="4c9c" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">如果我们接下来使用coin <code class="fe ok ol om nl b">coin</code>，第一行递归调用<code class="fe ok ol om nl b">coinChange</code>来确定子问题的最佳可能解决方案。通过在每个硬币的循环中调用这个函数并取最低的结果，我们计算出这个子问题<em class="mg">的最佳可能解，而不管我们选择哪个硬币。例如，我们现在将知道<code class="fe ok ol om nl b">amountRemaining = 47</code>子问题的最佳可能解决方案是5(恰好是1个25美分、2个10美分和2个1美分，但是对于我们的实际问题，我们不关心具体的硬币是什么)。我们用<code class="fe ok ol om nl b">solutionUsingThisCoin + 1</code>更新<code class="fe ok ol om nl b">optimalSolution</code>，其中1代表测试硬币本身。这是我们在上面正式描述为<code class="fe ok ol om nl b">F(a) = F(a — c) + 1</code>的子问题的代码实现。最后，我们在记忆表中缓存新找到的子问题解(如果不可能，则为-1)并返回值。</em></p><h1 id="091a" class="mh mi iq bd mj mk ml mm mn mo mp mq mr jw ms jx mt jz mu ka mv kc mw kd mx my bi translated">结论</h1><p id="cf53" class="pw-post-body-paragraph kw kx iq ky b kz mz jr lb lc na ju le lf nb lh li lj nc ll lm ln nd lp lq lr ij bi translated">动态规划被用于<a class="ae kv" href="https://leetcode.com/tag/dynamic-programming/" rel="noopener ugc nofollow" target="_blank">多个问题</a>，包括<a class="ae kv" href="https://leetcode.com/problems/coin-change/" rel="noopener ugc nofollow" target="_blank">硬币兑换问题</a>，背包问题，以及<a class="ae kv" href="https://leetcode.com/problems/fibonacci-number/" rel="noopener ugc nofollow" target="_blank">求解斐波那契数列</a>。这些都是你在面试中可能会遇到的问题，所以对于大多数软件开发人员来说，仅仅因为这个原因，理解动态编程是值得的。但是，即使你不期望在采访中回答这些问题，软件开发也是一个我们一直在寻求增长理解和发现解决问题的新方法的领域。动态编程是这方面的一个很好的例子，我希望它对您有所帮助。</p></div></div>    
</body>
</html>