# 为什么在 Git 中存储秘密和密码是个坏主意

> 原文：<https://betterprogramming.pub/why-storing-secrets-and-passwords-in-git-is-a-bad-idea-7ecd4664b475>

## 你应该如何处理应用程序的敏感数据

![](img/6808a0c41d76bd64fa4d795a3b1ec46d.png)

[Zan](https://unsplash.com/photos/oANfa-d9vr8) 在 [Unsplash](https://unsplash.com/) 上的照片。

今天，我和一些开发人员交谈，我们开始讨论应用程序需要的秘密的适当存储。这些东西包括数据库密码、API 密钥、授权令牌、加密密钥、证书等。我们可以统称它们为*秘密*。

顾名思义，应该非常小心地保护它们，如果它们最终落入坏人之手，它们可能会导致你的应用程序的安全性受到严重损害，甚至更糟。

当你构建和部署一个应用时，你应该如何管理秘密？你应该把它们存放在哪里？

首先，我想说有多种正确的方法来处理这个问题。在这篇文章中，我们将看到三个(外加一个奖金)。然而，有一种管理秘密的方式肯定是错误的。

# 在源代码控制中存储机密的问题是

许多程序员(即使是有经验的程序员)犯的错误是将秘密和代码存储在一起，将它们签入源代码控制(如 Git)。这当然是处理这个问题最简单、最方便的方法，但这是一个相当糟糕的主意。

简而言之，不要将你的秘密存储在 Git 中！

这既适用于硬编码到您的应用程序中的秘密(例如将数据库密码直接放在源代码中，无论如何都要避免)，也适用于将带有秘密的配置文件放在您的源代码旁边(例如`.env`或`config.json`文件)。

最直接的原因与安全性有关。源代码库应该是共享的——与你的队友、你的公司，或者可能与整个世界共享(开源软件就是如此)。

在较大的组织中，通常有不同的开发和操作团队，开发人员通常不能访问生产系统。即使在较小的团队中，开发人员和运营人员之间的分离较少，但通常会有不同的角色和个人职责，因此不是每个人都需要访问所有的秘密。

您可能认为，如果您是目前项目中唯一的开发人员，这可能不适用于您，但这并不意味着将来其他人不会加入您的代码库，甚至可能是暂时的(例如，承包商或朋友帮助您解决一个特定的问题)。此外，你永远不知道你的代码会发生什么，它很有可能在未来的某一天成为开源代码。

在 Git 之外保守秘密对于未来保护尤其重要。Git 被设计为保存所有代码变更的持久历史，因此一旦秘密被签入源代码控制，移除它就需要重写历史。如果不是不可能的话，这真的很难做到。因为 Git 是分布式的，所以其他开发人员可能会将您的秘密保存在他们自己的本地回购副本中。

当然，也有你的源代码被泄露的风险。在许多情况下，这本身就是一件坏事，如果您的存储库包含任何密码或秘密，情况只会变得更糟。大多数从事项目工作的开发人员在他们的笔记本电脑上维护存储库的本地副本，这放大了代码由于黑客、恶意软件或意外泄露而泄漏的风险(例如，如果有人不知道代码库包含秘密，他们可能会以不安全的方式传输它)。

如果安全风险本身还不足以成为理由，那么还有一些实际的理由。大多数应用程序在投入生产之前都部署在多个开发或测试环境中，每个环境都连接到不同的资源或数据库。例如，在您的笔记本电脑上进行开发时，您希望使用本地数据库服务器，而不是连接到生产服务器。这同样适用于您的试运行(或生产前)环境。

在源代码控制中维护秘密使得拥有多个环境并为每个环境设置正确的配置变得更加困难。

因此，如果将秘密存储在 Git repo 中是不允许的，那么有什么更好的选择呢？

# 好:使用外部配置文件

我们考虑的第一个好的选择是使用外部配置文件。这里的关键词是*外部*，因为这些文件没有被签入到源代码控制中。

相反，这些文件被分别部署到您的服务器上，然后由您的应用程序在运行时加载。因为它们与您的代码分开处理，所以您也可以安全地将机密存储在这些文件中——除了您的应用程序可能需要的任何其他非机密配置值(只要确保您没有将这些文件的副本放在可能被窃取的地方！).

例如，在 Linux 服务器上，你可以创建一个配置文件(如`config.json`、`config.yaml`、`config.toml`等)。)在`/etc/myapp/`(或`~/.config`或其他路径)。在运行时，您的应用程序将尝试在这些文件夹中查找配置文件并加载它们。

除了配置文件之外，您还可以在相同的文件夹中存储其他机密，例如 TLS 证书。

需要注意的重要一点是，这些配置文件是特定于环境的，它们的生命周期独立于应用程序的生命周期。

例如，如果您的应用程序运行在服务器上(如虚拟机)，这些配置文件是由管理员在部署应用程序之前部署的，它们与应用程序的代码或二进制文件分开管理。这些文件不会与您的应用程序一起部署，可以随时更新，甚至不需要重新部署您的应用程序(但如果您更改了配置文件，您的应用程序可能需要重新启动)。

如果您的应用程序在 Docker 容器中运行，这些配置文件通常不包含在容器映像中，而是存储在本地卷中，并在运行时挂载到容器中。

您可以找到处理每种编程语言或堆栈的配置文件的库。

如果你正在用 Node.js 构建一个应用，有很多库可以用来管理你的应用的外部配置。来自 npm 的一些流行的例子是[配置](https://www.npmjs.com/package/config)、[配置](https://www.npmjs.com/package/conf)或[定罪](https://www.npmjs.com/package/convict)(最后一个是由 Mozilla 开发的，但由于功能丰富也更复杂)。甚至有一个由你真正为一些老项目建立的库，但我不会链接到它，因为它不再被积极维护了。

# 好:使用环境变量

利用环境变量与前一个选项一样好(它实际上经常与前一个选项一起使用)。

这些是在应用程序运行环境中设置的配置选项(包括密码)。例如，在 Node.js 中，您可以在启动应用程序时设置 env 变量`DB_PASSWORD`,该应用程序具有:

```
DB_PASSWORD="P@ssw0rd" node index.js
```

然后，您的代码可以用`process.env.DB_PASSWORD`读取它。事实上，`process.env`包含了应用运行环境中的每一个变量，包括操作系统设置的默认变量。

其他编程语言有读取环境变量的方法。

许多配置库，包括前一节中链接的一些配置库(对于 Node.js ),也支持环境变量，并且通常允许 env 变量覆盖配置文件中设置的值。

当然，在您的生产服务器中，您不打算手动启动您的应用程序，所以在启动应用程序之前，您不能在 shell 中传递 env 变量。因此，使用 env 变量的方式取决于应用程序的部署方式，甚至可能取决于您运行的平台。

例如，如果您的应用程序的进程是由 systemd 管理的，您可以使用您的单元文件中的`Environment=`选项(在`[Service]`部分)来定义一个或多个 env 变量。例如，这设置了两个变量(`DB_PASSWORD`和`FOO`):

```
[Service]
Environment="DB_PASSWORD=ssw0rd" "FOO=bar"
```

你也可以在一个文件(通常称为`.env`或 dotenv)中定义你的变量，其中每行包含一个变量。例如，您可以用以下值创建文件`/etc/myapp/config`:

```
FOO=bar
HELLO=world
```

然后在 systemd 单元中，用`EnvironmentFile=`键加载所有变量:

```
[Service]
EnvironmentFile=/etc/myapp/config
```

使用环境文件(或 dotenv 文件)通常更方便，因为它允许在一个地方看到整个应用程序的配置，并且它与 systemd 单元的其余部分是分开的。当然，像对待任何其他外部配置文件一样对待 dotenv 文件并将其与应用程序的源 repo 分开是很重要的！

如果你的应用运行在 Docker 容器中，你可以为`docker run`命令设置带有`--env`标志的 env 变量(例如`--env FOO=bar`)。您还可以使用`--env-file`从环境文件中加载变量，就像上面的例子一样。查看`[docker run](https://docs.docker.com/engine/reference/commandline/run/#set-environment-variables--e---env---env-file)` [命令](https://docs.docker.com/engine/reference/commandline/run/#set-environment-variables--e---env---env-file)的完整参考，了解更多信息。

最后，如果您的应用程序运行在平台服务上，您通常可以利用他们自己的解决方案来注入环境变量。

例如，Azure Web Apps 允许你直接从平台上[设置环境变量](https://docs.microsoft.com/en-us/azure/app-service/configure-common?WT.mc_id=devcloud-00000-cxa)，你的应用可以像任何其他环境变量一样访问这些环境变量。其他应用程序或无服务器平台也有类似的功能。请务必检查他们的文档！

# 更好的方法:使用密钥库

管理机密的更好方法是利用密钥库。这些是特殊的应用程序或云服务，有时由硬件安全模块(芯片)支持，存储应用程序需要的所有秘密。在启动时，您的应用程序可以直接从密钥库中请求所需的秘密。

例如，您可以存储您的应用程序需要的所有秘密(数据库密码、API 密钥、TLS 证书等。)在钥匙库里。然后，您只需要传递一个秘密来启动您的应用程序:访问密钥库的密码，您可以将它作为环境变量传递。一旦启动，你的应用程序向密钥库发出请求，并检索所有的秘密。

HashiCorp 的 [Vault](https://www.vaultproject.io/) 是一个流行的用于密钥和秘密的开源 Vault 应用程序。所有最流行的堆栈和编程语言都有与 Vault 交互的库。

也有提供密钥库的托管服务，如 [Azure Key Vault](https://docs.microsoft.com/en-us/azure/key-vault/general/overview?WT.mc_id=devcloud-00000-cxa) ，以及来自 AWS 和 Google Cloud 的类似服务。HashiCorp 提供了基于开源产品的 Vault too 托管云版本。你可以在[文档](https://docs.microsoft.com/en-us/azure/key-vault/secrets/quick-create-node?WT.mc_id=devcloud-00000-cxa)中找到一个使用 Node.js 的 Azure Key Vault 的快速入门。

如上所述，使用密钥库并不能完全消除管理秘密的需要，因为您仍然需要向您的应用程序传递一个密码:连接到密钥库本身的密码。

但是，使用密钥存储库有很多好处，包括:

*   所有机密都存储在一个集中的地方，因此不需要管理、部署和保护配置或 env 文件。
*   门禁更容易。您可以将访问密钥库的权限仅授予需要能够管理密钥的团队(或个人)。
*   它简化了一个或多个应用程序的密码更新。例如，如果您的数据库密码发生更改，您只需要在密钥库中集中更新它，而不必修改所有生产服务器上每个应用程序的配置文件。
*   因为不需要管理配置或环境文件，所以在平台服务上运行应用程序更容易，创建动态环境来横向扩展应用程序也更容易(即，如果您需要在另一台服务器上部署应用程序，您无需担心确保所有配置文件都已准备就绪，您只需部署应用程序)。
*   许多关键的 vault 解决方案还包括审计功能，因此您可以拥有访问 vault 中机密的每个人和应用程序的日志，这对于调查安全事件非常有帮助。

另外，许多密钥库提供了额外的功能，例如使用 HSM(硬件安全模块)将密钥存储在无法检索的地方，以及使用存储在库中的密钥加密或解密数据的 API，因此您的应用程序永远不需要直接管理密钥(并且您不必自己实现加密功能)。保管库可以自动为您管理密钥和某些其他机密，以提高安全性。最后，一些保险库可以存储 TLS 证书，甚至完全透明地为您更新它们！如果你曾经忘记更新生产 TLS 证书，请举手。

# 最好:完全放弃秘密(奖金)

到目前为止，保护秘密的最好方法是…首先不要有秘密！当然，这并不适用于每一个应用程序和每一个场景，所以把这当作一个奖励。但是你可以把这个看作是黄金标准。

当你的应用运行在云中或像 Kubernetes 这样的平台上时，这是一件更容易做到的事情。在这种情况下，您的应用程序可以访问资源，并让底层基础架构或平台管理访问控制。

例如，在 Azure 上，你可以利用[托管身份](https://docs.microsoft.com/en-us/azure/active-directory/managed-identities-azure-resources/overview?WT.mc_id=devcloud-00000-cxa)，允许你将一个“身份”附加到虚拟机、网络应用、功能、Azure Kubernetes 服务等。(AWS 和谷歌等其他云提供商也有类似的解决方案)。当你将你的应用程序部署到其中一个已分配身份的服务时，你的应用程序可以自动访问你允许它访问的任何 Azure 资源，而无需进行身份验证。Azure fabric 仅通过在特定服务器或服务上运行来为您的应用程序分配身份，该身份授予对 Azure Storage、Azure SQL 和 Azure Key Vault 等服务的访问权限。这意味着您可以在受支持的服务(如 Azure 存储或 SQL)上访问您的数据，而无需提供任何凭据。

更好的是，你可以访问 Azure Key Vault 而无需提供任何凭据，并自动获取你的应用程序有权获得的每个秘密。这解决了上一节中出现的问题，当时您仍然需要向您的应用程序传递单个密钥，以便它可以访问密钥库。现在它可以工作了。

如果您有多个环境，如生产和暂存环境，您可以为每个环境分配不同的托管身份，以便您的应用程序自动获得正确的密码来访问正确的数据库等。

类似的解决方案也可以在像 Kubernetes 这样的平台上实现，不管它们部署在哪里(例如通过[与 Vault](https://www.vaultproject.io/docs/platform/k8s) 集成)。

# 结论

我希望这篇文章能帮助你理解一些管理应用程序秘密的最佳实践，而不要把它们存储在源代码控制中，这样会有相关的风险。随着复杂性的增加，我们已经考虑使用配置文件、env 变量和 env 文件、密钥库以及托管身份来完全跳过管理机密。

正如我在开始时提到的，这篇文章并不全面，还有其他方法可以解决管理和分发应用程序秘密的问题。欢迎在下面的评论区分享你的最佳实践。

*原载于 2021 年 5 月 7 日*[*https://with blue . ink*](https://withblue.ink/2021/05/07/storing-secrets-and-passwords-in-git-is-bad.html)*。*