<html>
<head>
<title>Don’t Use Boolean Arguments, Use Enums</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">不要使用布尔参数，使用枚举</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/dont-use-boolean-arguments-use-enums-c7cd7ab1876a?source=collection_archive---------0-----------------------#2020-04-28">https://betterprogramming.pub/dont-use-boolean-arguments-use-enums-c7cd7ab1876a?source=collection_archive---------0-----------------------#2020-04-28</a></blockquote><div><div class="fc ii ij ik il im"/><div class="in io ip iq ir"><div class=""/><div class=""><h2 id="8c8a" class="pw-subtitle-paragraph jr it iu bd b js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki dk translated">在代码中避免标志参数的情况</h2></div><figure class="kk kl km kn gu ko gi gj paragraph-image"><div role="button" tabindex="0" class="kp kq di kr bf ks"><div class="gi gj kj"><img src="../Images/74fc42e0ef2245c2a444808dd0c75403.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*a90EXlgwmEMBYyco"/></div></div><p class="kv kw gk gi gj kx ky bd b be z dk translated">由<a class="ae kz" href="https://unsplash.com/@farzadme?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Farzad Mohsenvand </a>在<a class="ae kz" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片。</p></figure><p id="e5e3" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">布尔是任何程序员学习的第一种数据类型。为什么不呢？它们是最简单的，只有两种状态:一个<code class="fe lw lx ly lz b">true</code>和一个<code class="fe lw lx ly lz b">false</code>。</p><p id="e59c" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">虽然在代码库中使用布尔标志值来管理状态机很有吸引力，但随着代码的发展，这很容易导致代码的复杂性、可读性和可伸缩性问题。</p><p id="75d5" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">一般来说，标志参数划分了函数的逻辑，迫使它根据值做不止一件事。这可能导致业务逻辑中复杂的实现。您的代码库很容易以下面的树形结构结束:</p><figure class="kk kl km kn gu ko gi gj paragraph-image"><div class="gi gj ma"><img src="../Images/096c09c4ec2a4614425edb08b9e1f964.png" data-original-src="https://miro.medium.com/v2/resize:fit:1132/format:webp/1*bwiAiq6C8UOVgImOTt6YKQ.png"/></div></figure></div><div class="ab cl mb mc hy md" role="separator"><span class="me bw bk mf mg mh"/><span class="me bw bk mf mg mh"/><span class="me bw bk mf mg"/></div><div class="in io ip iq ir"><h1 id="2403" class="mi mj iu bd mk ml mm mn mo mp mq mr ms ka mt kb mu kd mv ke mw kg mx kh my mz bi translated">背景</h1><p id="6a39" class="pw-post-body-paragraph la lb iu lc b ld na jv lf lg nb jy li lj nc ll lm ln nd lp lq lr ne lt lu lv in bi translated">让我通过一个故事来突出状态机和函数参数中布尔参数的弱点。</p><p id="f8be" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">一组软件开发人员曾经构建了一个管理用户状态的模块。其中一个坚持使用布尔值，因为需求只有两种状态:<code class="fe lw lx ly lz b">ONLINE</code>和<code class="fe lw lx ly lz b">OFFLINE</code>。尽管大多数人不完全同意这个提议，他们还是继续进行下去，因为它看起来又快又简单。</p><p id="9938" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">最终，像下面这样的函数开始出现在它们的代码库中:</p><pre class="kk kl km kn gu nf lz ng nh aw ni bi"><span id="6ae6" class="nj mj iu lz b gz nk nl l nm nn">func setUserState(isUserOnline : Bool)</span></pre><p id="6aa2" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">很快，一个新的开发人员加入了这个团队，他想知道下面这句话到底是什么意思:</p><pre class="kk kl km kn gu nf lz ng nh aw ni bi"><span id="341d" class="nj mj iu lz b gz nk nl l nm nn">setUserState(true) //The new guy just kept staring at this.</span></pre><p id="2a10" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">虽然其他人提出了一个更好的函数名(<code class="fe lw lx ly lz b">setUserOnline</code>)，而且一开始看起来很好，但是一旦出现新的业务需求，要求包含另一个用户状态:<code class="fe lw lx ly lz b">BLOCKED</code>，事情就变成了一场噩梦。他们有几种可能的方法将新状态包含到代码库中。让我们探索它们，看看它们如何影响代码，以及如何最终克服这个问题。</p></div><div class="ab cl mb mc hy md" role="separator"><span class="me bw bk mf mg mh"/><span class="me bw bk mf mg mh"/><span class="me bw bk mf mg"/></div><div class="in io ip iq ir"><h1 id="7afe" class="mi mj iu bd mk ml mm mn mo mp mq mr ms ka mt kb mu kd mv ke mw kg mx kh my mz bi translated">三态布尔问题</h1><p id="6028" class="pw-post-body-paragraph la lb iu lc b ld na jv lf lg nb jy li lj nc ll lm ln nd lp lq lr ne lt lu lv in bi translated">布尔通常表示两种状态。但是在一些语言中(比如Java，通过使用<code class="fe lw lx ly lz b">Boolean</code>对象)，我们可以使用<code class="fe lw lx ly lz b">null</code>来分配第三种状态。所以在我们的上下文中，<code class="fe lw lx ly lz b">BLOCKED</code>将被设置为<code class="fe lw lx ly lz b">null</code>。虽然这似乎适应了新的用户状态而不需要额外的布尔值，但我们可以很容易地以<code class="fe lw lx ly lz b">NullPointerExceptions</code>结束。</p><p id="eb8b" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">此外，在不同的场景中，区分<code class="fe lw lx ly lz b">false</code>和<code class="fe lw lx ly lz b">null</code>可能会变得棘手。例如，当<code class="fe lw lx ly lz b">true</code>清楚地表明游戏处于播放模式时，布尔属性<code class="fe lw lx ly lz b">game.isPlaying</code>。但是当它是<code class="fe lw lx ly lz b">false</code>或者<code class="fe lw lx ly lz b">null</code>的时候会发生什么呢？<code class="fe lw lx ly lz b">false</code>是否表示游戏暂停或停止？</p><p id="8315" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">正如你所看到的，<code class="fe lw lx ly lz b">false</code>没有足够的信息让我们容易地识别和回忆它所绑定的状态。三态布尔值只会使我们的逻辑变得复杂。</p><p id="28df" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">此外，当我们被要求包含另一个叫做<code class="fe lw lx ly lz b">EXPIRED</code>的状态时会发生什么？显然，我们不能采用这种方法，因为我们现在有四个国家。所以让我们看看开发人员应用的另一种方法。</p></div><div class="ab cl mb mc hy md" role="separator"><span class="me bw bk mf mg mh"/><span class="me bw bk mf mg mh"/><span class="me bw bk mf mg"/></div><div class="in io ip iq ir"><h1 id="4c4b" class="mi mj iu bd mk ml mm mn mo mp mq mr ms ka mt kb mu kd mv ke mw kg mx kh my mz bi translated">多个布尔带来隐藏的依赖</h1><p id="6787" class="pw-post-body-paragraph la lb iu lc b ld na jv lf lg nb jy li lj nc ll lm ln nd lp lq lr ne lt lu lv in bi translated">开发人员最终通过为新状态添加两个布尔参数扩展了先前函数的签名:</p><pre class="kk kl km kn gu nf lz ng nh aw ni bi"><span id="bcb5" class="nj mj iu lz b gz nk nl l nm nn">func setUserState( <br/>isUserOnline : Bool, <br/>isUserBlocked : Bool,<br/>isUserExpired : Bool)</span></pre><p id="1e5c" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">看起来像是满足业务需求的简单扩展，却不情愿地在代码库中引入了隐藏的依赖和许多新的组合。</p><p id="820b" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">创建的两个隐藏依赖项是<code class="fe lw lx ly lz b">isUserOnline</code> — <code class="fe lw lx ly lz b">isUserExpired</code>和<code class="fe lw lx ly lz b">isUserOnline</code> — <code class="fe lw lx ly lz b">isUserBlocked</code>。这迫使我们明确地管理额外的条件以避免冲突状态。例如，被阻止/过期的用户不能在线。以下是您需要处理的两种冲突状态的示例:</p><pre class="kk kl km kn gu nf lz ng nh aw ni bi"><span id="4090" class="nj mj iu lz b gz nk nl l nm nn">#Condition 1: isUserOnline: false and <!-- -->isUserExpired<!-- -->: true<br/>#Condition 2: isUserOnline: false and <!-- -->isUserBlocked<!-- -->: true</span></pre><p id="23fd" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">随着您添加更多的状态，函数很容易变成一长串参数。事情变得不可持续，因为你会以大量的<code class="fe lw lx ly lz b">&amp;&amp;</code>、<code class="fe lw lx ly lz b">||</code>和其他复杂的分支逻辑来处理互斥和依赖的布尔。</p></div><div class="ab cl mb mc hy md" role="separator"><span class="me bw bk mf mg mh"/><span class="me bw bk mf mg mh"/><span class="me bw bk mf mg"/></div><div class="in io ip iq ir"><h1 id="6321" class="mi mj iu bd mk ml mm mn mo mp mq mr ms ka mt kb mu kd mv ke mw kg mx kh my mz bi translated">布尔有类型安全和可读性问题</h1><p id="fdcf" class="pw-post-body-paragraph la lb iu lc b ld na jv lf lg nb jy li lj nc ll lm ln nd lp lq lr ne lt lu lv in bi translated">通过使用多个布尔值，也很有可能将它们混淆。您可能会传递一个错误的值(可能来自不同的对象),编译器甚至不会抱怨。在重构和进行代码审查时，这可能是一场噩梦，因为您需要编写大量的单元测试来捕捉这些问题。</p><p id="66c6" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">此外，很容易忘记<code class="fe lw lx ly lz b">false</code>或<code class="fe lw lx ly lz b">true</code>值实际上对布尔变量意味着什么。理解充满布尔值的函数调用(如下所示)只会变得困难:</p><pre class="kk kl km kn gu nf lz ng nh aw ni bi"><span id="f233" class="nj mj iu lz b gz nk nl l nm nn">setUserState(true, false, false)</span></pre><p id="26f5" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">有人可能会说，今天许多编程语言都支持命名参数，这提高了函数的可读性。但是话又说回来，您可能会意外地传递一个相反的或不正确的布尔值，而函数签名仍然会匹配。</p><p id="bbd2" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">如果故事中的软件开发人员使用枚举而不是布尔，他们就可以避免这些麻烦。</p></div><div class="ab cl mb mc hy md" role="separator"><span class="me bw bk mf mg mh"/><span class="me bw bk mf mg mh"/><span class="me bw bk mf mg"/></div><div class="in io ip iq ir"><h1 id="3e13" class="mi mj iu bd mk ml mm mn mo mp mq mr ms ka mt kb mu kd mv ke mw kg mx kh my mz bi translated">偏好枚举，避免布尔</h1><p id="0e8c" class="pw-post-body-paragraph la lb iu lc b ld na jv lf lg nb jy li lj nc ll lm ln nd lp lq lr ne lt lu lv in bi translated">枚举数是一种数据类型，由一组命名值组成，可以以类型安全的方式使用。虽然它可能看起来不像boolean那么简单，但是使用enum或其他用户定义的类型可以帮助我们避免设置具有多个分支的复杂if语句。</p><pre class="kk kl km kn gu nf lz ng nh aw ni bi"><span id="dfbf" class="nj mj iu lz b gz nk nl l nm nn">enum UserStates{</span><span id="e817" class="nj mj iu lz b gz no nl l nm nn">case active<br/>case inactive<br/>case blocked<br/>case expired</span><span id="49c1" class="nj mj iu lz b gz no nl l nm nn">}</span></pre><p id="a803" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">让我们看看在管理有限状态和函数签名时enum给表带来的好处。</p><h2 id="1de0" class="nj mj iu bd mk np nq dn mo nr ns dp ms lj nt nu mu ln nv nw mw lr nx ny my nz bi translated">1.枚举是清晰的和描述性的</h2><p id="65d7" class="pw-post-body-paragraph la lb iu lc b ld na jv lf lg nb jy li lj nc ll lm ln nd lp lq lr ne lt lu lv in bi translated">枚举迫使您命名所有的状态，这使得理解它们的意思变得容易——从而创建一个自文档化的代码。此外，枚举清楚地表明这些值是互斥的，从而消除了冲突状态的疑虑。在函数中将枚举作为参数传递更加清晰，有助于我们避免神秘的布尔值。只需比较下面两行:</p><pre class="kk kl km kn gu nf lz ng nh aw ni bi"><span id="898b" class="nj mj iu lz b gz nk nl l nm nn">setUserState(true, false, false)</span><span id="bd2b" class="nj mj iu lz b gz no nl l nm nn">//The version below is more concise and clearer.</span><span id="97c1" class="nj mj iu lz b gz no nl l nm nn">setUserState(UserStates.active)</span></pre><h2 id="8af6" class="nj mj iu bd mk np nq dn mo nr ns dp ms lj nt nu mu ln nv nw mw lr nx ny my nz bi translated">2.枚举使缩放和重构更容易</h2><p id="6b24" class="pw-post-body-paragraph la lb iu lc b ld na jv lf lg nb jy li lj nc ll lm ln nd lp lq lr ne lt lu lv in bi translated">扩展枚举器中的值集更容易，因为与布尔值不同，可能的状态组合的数量不会随着每个新的情况而加倍。此外，许多编译器足够聪明，能够指出您需要进行哪些更改来适应新的enum情况。例如，Swift会引发一个错误。同时，在其他语言中，很容易查找enum中出现的所有情况。</p><p id="6a0e" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">用一个额外的新case扩展一个已经存在的enum只需要很少的工作，因为数据类型保持不变。这使得重构变得更加容易。</p><h2 id="7fbe" class="nj mj iu bd mk np nq dn mo nr ns dp ms lj nt nu mu ln nv nw mw lr nx ny my nz bi translated">3.枚举是类型安全的</h2><p id="3f60" class="pw-post-body-paragraph la lb iu lc b ld na jv lf lg nb jy li lj nc ll lm ln nd lp lq lr ne lt lu lv in bi translated">使用枚举，除了指定的值之外，不能分配任何值，因为它们是类型安全的。这使得意外交换值或传递无效状态变得不可能，因为编译器会发现它。</p><p id="7d22" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">并非所有语言都支持本机枚举，在这种情况下，您可以创建自定义类型。例如，在JavaScript中，我们可以通过“冻结”对象中的常量来解决这个问题:</p><figure class="kk kl km kn gu ko"><div class="bz fq l di"><div class="oa ob l"/></div></figure></div><div class="ab cl mb mc hy md" role="separator"><span class="me bw bk mf mg mh"/><span class="me bw bk mf mg mh"/><span class="me bw bk mf mg"/></div><div class="in io ip iq ir"><h1 id="7688" class="mi mj iu bd mk ml mm mn mo mp mq mr ms ka mt kb mu kd mv ke mw kg mx kh my mz bi translated">结束语</h1><p id="f0a6" class="pw-post-body-paragraph la lb iu lc b ld na jv lf lg nb jy li lj nc ll lm ln nd lp lq lr ne lt lu lv in bi translated">记住，布尔并不坏。如果你确定状态是二元且互斥的，或者当方法名已经描述了它时，在函数参数中使用它们是完全可以的(就像用<code class="fe lw lx ly lz b">setEnabled(true)</code>)。但是通常情况下，需求会发生变化，并且会添加新的状态。</p><p id="3c22" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">两个元素的枚举值得努力，并且比布尔标志更安全。枚举有助于使您的代码经得起未来考验，并消除跟踪布尔字段的需要。</p><p id="674f" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">布尔是最简单的，但是它们很容易被误用——或者说被滥用。</p><p id="568c" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">这一次到此为止。感谢阅读。</p></div></div>    
</body>
</html>