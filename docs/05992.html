<html>
<head>
<title>Dynamic Value Arrays in Solidity</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Solidity中的动态值数组</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/dynamic-value-arrays-in-solidity-8e9b44015833?source=collection_archive---------9-----------------------#2020-08-24">https://betterprogramming.pub/dynamic-value-arrays-in-solidity-8e9b44015833?source=collection_archive---------9-----------------------#2020-08-24</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="e1cd" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">动态值数组在坚固性上比引用数组更高效吗？</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/dcb805aec1fe965e526787047712350f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*m7pac5GTN3ze6Y0Ksdq6ZA.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">照片由<a class="ae ky" href="https://unsplash.com/@snick_kwan?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">尼克·关</a>在<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>拍摄</p></figure></div><div class="ab cl kz la hx lb" role="separator"><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le"/></div><div class="im in io ip iq"><h1 id="aff1" class="lg lh it bd li lj lk ll lm ln lo lp lq jz lr ka ls kc lt kd lu kf lv kg lw lx bi translated">背景</h1><p id="fe42" class="pw-post-body-paragraph ly lz it ma b mb mc ju md me mf jx mg mh mi mj mk ml mm mn mo mp mq mr ms mt im bi translated">在开发和测试Datona Labs的<a class="ae ky" href="https://solidity.readthedocs.io/en/v0.7.0/" rel="noopener ugc nofollow" target="_blank">Solidity</a>smart data access contract(S-DAC)模板的过程中，我们经常需要处理数量较少但未知的数据，比如用户id。理想情况下，它们存储在小值的小型动态数组中。</p><p id="0bd4" class="pw-post-body-paragraph ly lz it ma b mb mu ju md me mv jx mg mh mw mj mk ml mx mn mo mp my mr ms mt im bi translated">在本文的例子中，我们研究了使用动态值数组是否比使用引用数组或Solidity中的类似解决方案更有效。</p></div><div class="ab cl kz la hx lb" role="separator"><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le"/></div><div class="im in io ip iq"><h1 id="c234" class="lg lh it bd li lj lk ll lm ln lo lp lq jz lr ka ls kc lt kd lu kf lv kg lw lx bi translated">讨论</h1><p id="6d91" class="pw-post-body-paragraph ly lz it ma b mb mc ju md me mf jx mg mh mi mj mk ml mm mn mo mp mq mr ms mt im bi translated">如果我们有由已知的少量小数字组成的数据，我们可以在Solidity中使用一个值数组，如作者的文章“<a class="ae ky" href="https://medium.com/coinmonks/value-arrays-in-solidity-32ca65135d5b" rel="noopener"> Value Arrays in Solidity </a>”中所述，其中我们提供并测量了Solidity值数组。我们的结论是，在许多情况下，我们可以使用值数组来减少我的存储空间和气体消耗。</p><p id="af29" class="pw-post-body-paragraph ly lz it ma b mb mu ju md me mv jx mg mh mw mj mk ml mx mn mo mp my mr ms mt im bi translated">之所以得出这个结论，是因为Solidity运行在以太坊虚拟机(EVM)上，它有一个非常大的256位(32字节)的<a class="ae ky" href="https://en.wikipedia.org/wiki/Word_(computer_architecture)" rel="noopener ugc nofollow" target="_blank">机器字</a>。这一特性，加上处理参考数组的高气体消耗，促使我们考虑使用值数组。</p><p id="9b01" class="pw-post-body-paragraph ly lz it ma b mb mu ju md me mv jx mg mh mw mj mk ml mx mn mo mp my mr ms mt im bi translated">然而，如果我们为固定值数组操作提供了自己的库，那么让我们来确定提供动态值数组是否可行。</p><p id="3002" class="pw-post-body-paragraph ly lz it ma b mb mu ju md me mv jx mg mh mw mj mk ml mx mn mo mp my mr ms mt im bi translated">让我们比较一下动态值数组和固定值数组，以及Solidity自己的固定和动态数组。</p><p id="318f" class="pw-post-body-paragraph ly lz it ma b mb mu ju md me mv jx mg mh mw mj mk ml mx mn mo mp my mr ms mt im bi translated">我们还将比较包含长度和固定数组的结构，以及包含值数组的结构。</p></div><div class="ab cl kz la hx lb" role="separator"><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le"/></div><div class="im in io ip iq"><h1 id="3b34" class="lg lh it bd li lj lk ll lm ln lo lp lq jz lr ka ls kc lt kd lu kf lv kg lw lx bi translated">可能的动态值数组</h1><p id="b5c8" class="pw-post-body-paragraph ly lz it ma b mb mc ju md me mf jx mg mh mi mj mk ml mm mn mo mp mq mr ms mt im bi translated">在Solidity中，只可能有动态存储数组。存储器阵列具有固定的大小，并且不允许使用<code class="fe mz na nb nc b">push()</code>来附加额外的元素。</p><p id="7ee9" class="pw-post-body-paragraph ly lz it ma b mb mu ju md me mv jx mg mh mw mj mk ml mx mn mo mp my mr ms mt im bi translated">既然我们在Solidity库中为动态值数组提供了自己的代码，我们也可以提供在存储和内存数组上使用的<code class="fe mz na nb nc b">push()</code> <em class="nd"> </em>(和<code class="fe mz na nb nc b">pop()</code>)。</p><p id="c707" class="pw-post-body-paragraph ly lz it ma b mb mu ju md me mv jx mg mh mw mj mk ml mx mn mo mp my mr ms mt im bi translated">动态值数组将需要记录和操作数组的当前长度。在下面的代码中，我们选择将长度存储在256位32字节机器字值的高位。</p><h2 id="42a2" class="ne lh it bd li nf ng dn lm nh ni dp lq mh nj nk ls ml nl nm lu mp nn no lw np bi translated">动态值数组</h2><p id="3ce3" class="pw-post-body-paragraph ly lz it ma b mb mc ju md me mf jx mg mh mi mj mk ml mm mn mo mp mq mr ms mt im bi translated">这些是动态值数组，与一些可用的实度类型相匹配:</p><pre class="kj kk kl km gt nq nc nr ns aw nt bi"><span id="35a1" class="ne lh it nc b gy nu nv l nw nx"><strong class="nc iu">Dynamic Value Arrays</strong></span><span id="a57d" class="ne lh it nc b gy ny nv l nw nx">Type           Type Name   Description</span><span id="70ed" class="ne lh it nc b gy ny nv l nw nx">uint128[](1)   uint128d1   one 128bit element value<br/>uint64[](3)    uint64d3    three 64bit element values<br/>uint32[](7)    uint32d7    seven 32bit element values<br/>uint16[](15)   uint16d15   fifteen 16bit element values<br/>uint8[](31)    <strong class="nc iu">uint8d31</strong>    thirty-one 8bit element values</span></pre><p id="09e4" class="pw-post-body-paragraph ly lz it ma b mb mu ju md me mv jx mg mh mw mj mk ml mx mn mo mp my mr ms mt im bi translated">我们建议使用如上所示的类型名，它贯穿于本文，但是您可能会发现一个更好的命名约定。</p><p id="441b" class="pw-post-body-paragraph ly lz it ma b mb mu ju md me mv jx mg mh mw mj mk ml mx mn mo mp my mr ms mt im bi translated">以下是<strong class="ma iu"> uint8d31 </strong>值数组类型的数据组织:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nz"><img src="../Images/e1b478e1fa03d8bb44d47b12122aa102.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*P0VKvrvwg_bUs0PEIsVk_w.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">uint8d31值数组类型的数据组织</p></figure><p id="3792" class="pw-post-body-paragraph ly lz it ma b mb mu ju md me mv jx mg mh mw mj mk ml mx mn mo mp my mr ms mt im bi translated">我们将在下面更详细地查看<strong class="ma iu"> uint8d31 </strong>。</p><h2 id="7c96" class="ne lh it bd li nf ng dn lm nh ni dp lq mh nj nk ls ml nl nm lu mp nn no lw np bi translated">更多动态值数组</h2><p id="6dd0" class="pw-post-body-paragraph ly lz it ma b mb mc ju md me mf jx mg mh mi mj mk ml mm mn mo mp mq mr ms mt im bi translated">显然，有更多可能的值数组。假设我们保留256位值的最高位来保存最大动态数组长度，X值中的位数乘以Y元素的数量必须小于或等于256减去足够保存数组长度的位数L:</p><pre class="kj kk kl km gt nq nc nr ns aw nt bi"><span id="c46d" class="ne lh it nc b gy nu nv l nw nx"><strong class="nc iu">More Dynamic Value Arrays</strong></span><span id="d77a" class="ne lh it nc b gy ny nv l nw nx">Type           Type Name  Len  Description</span><span id="65d5" class="ne lh it nc b gy ny nv l nw nx">uint<strong class="nc iu">X</strong>[](<strong class="nc iu">Y</strong>)     uint<strong class="nc iu">X</strong>d<strong class="nc iu">Y</strong>     <strong class="nc iu">L</strong>   <strong class="nc iu">X</strong> * <strong class="nc iu">Y</strong> &lt;= 256 - <strong class="nc iu">L</strong></span><span id="51d3" class="ne lh it nc b gy ny nv l nw nx">uint255[](1)   uint255d1   1   one 248bit element value<br/>uint126[](2)   uint126a2   2   two 124bit element values<br/>uint84[](3)    uint84d3    2   three 82bit element values<br/>uint63[](4)    uint63d4    3   four 62bit element values<br/>uint50[](5)    uint50d5    3   five 51bit element values<br/>uint42[](6)    <em class="nd">uint42d6</em>    3   six 42bit element values<br/>uint36[](7)    uint36d7    3   seven 36bit element values<br/>uint31[](8)    uint31d8    4   eight 31bit element values<br/>uint28[](9)    uint28d9    4   nine 28bit element values<br/>uint25[](10)   uint25d10   4   ten 25bit element values<br/>uint22[](11)   uint22d11   4   eleven 22bit element values<br/>uint21[](12)   uint21d12   4   twelve 21bit element values<br/>uint19[](13)   uint19d13   4   thirteen 19bit element values<br/>uint18[](14)   uint18d14   4   fourteen 18bit element values<br/>uint16[](15)   uint16d15   4   as above<br/>uint15[](16)   uint15d16   5   sixteen 15bit element values<br/>uint14[](17)   uint14d17   5   seventeen 14bit element values<br/>uint13[](19)   uint13d19   5   nineteen 13bit element values<br/>uint12[](20)   uint12d20   5   twenty 12bit element values<br/>uint11[](22)   uint11d22   5   twenty-two 11bit element values<br/>uint10[](25)   uint10d25   5   twenty-five 10bit element values<br/>uint9[](27)    uint9d27    5   twenty-seven 9bit element values<br/>uint8[](31)    <strong class="nc iu">uint8d31</strong>    5   as above<br/>uint7[](35)    uint7d35    6   thirty-five 7bit element values<br/>uint6[](41)    uint6d41    6   forty-one 6bit element values<br/>uint5[](50)    uint5d50    6   fifty 5bit element values<br/>uint4[](62)    uint4d62    6   sixty-two 4bit element values<br/>uint3[](83)    uint3d83    7   eighty-three 3bit element values<br/>uint2[](124)   uint2d124   7   one-hundred &amp; twenty-four 2bit EVs<br/>uint1[](248)   <em class="nd">uint1d248</em>   8   two-hundred &amp; forty-eight 1bit EVs</span></pre><p id="c926" class="pw-post-body-paragraph ly lz it ma b mb mu ju md me mv jx mg mh mw mj mk ml mx mn mo mp my mr ms mt im bi translated">所需的数组类型是特定于项目的。此外，可能需要多个数组类型，例如，用户id使用uint8d31，角色使用uint5d50。</p><p id="d8e4" class="pw-post-body-paragraph ly lz it ma b mb mu ju md me mv jx mg mh mw mj mk ml mx mn mo mp my mr ms mt im bi translated">以下是所选值数组类型的数据组织:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi oa"><img src="../Images/e7e5e17f7b7d8be946df39088c9d43bc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*0dOU4jYYfdS6ouAMWVMNcA.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated"><em class="ob"> uint42d6 </em>值数组类型的数据组织</p></figure><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi oc"><img src="../Images/db5c2fe4bab17f06cb661c550c785f65.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*6CJdWUslXdawp1Do4rgSWA.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated"><em class="ob"> uint1d248 </em>值数组类型的数据组织</p></figure><p id="05d9" class="pw-post-body-paragraph ly lz it ma b mb mu ju md me mv jx mg mh mw mj mk ml mx mn mo mp my mr ms mt im bi translated">注意<em class="nd"> uint1d248 </em>值数组。这使我们能够有效地将多达248个表示布尔值的一位元素值编码成一个EVM字。相比之下，Solidity的bool[248]占用了248倍的内存空间，甚至8倍的存储空间。</p><h2 id="8df4" class="ne lh it bd li nf ng dn lm nh ni dp lq mh nj nk ls ml nl nm lu mp nn no lw np bi translated">动态值数组实现</h2><p id="6c6e" class="pw-post-body-paragraph ly lz it ma b mb mc ju md me mf jx mg mh mi mj mk ml mm mn mo mp mq mr ms mt im bi translated">下面是一个有用的导入文件，它为动态值数组类型uint8d31提供了get和set函数:</p><pre class="kj kk kl km gt nq nc nr ns aw nt bi"><span id="0a7d" class="ne lh it nc b gy nu nv l nw nx">// uint8d31.sol</span><span id="7252" class="ne lh it nc b gy ny nv l nw nx">library uint8d31 { // provides the equivalent of uint8[](31)<br/>    uint constant <strong class="nc iu">wordBits</strong> = 256;<br/>    uint constant <strong class="nc iu">bits</strong> = 8;<br/>    uint constant <strong class="nc iu">elements</strong> = 31;<br/>    uint constant <strong class="nc iu">lenBits</strong> = 5;<br/>    // ensure that (<strong class="nc iu">bits</strong> * <strong class="nc iu">elements)</strong> &lt;= (<strong class="nc iu">wordBits</strong> - <strong class="nc iu">lenBits)</strong><br/>    <br/>    uint constant range = 1 &lt;&lt; bits;<br/>    uint constant max = range - 1;<br/>    uint constant lenPos = wordBits - lenBits;<br/>    <br/>    function <em class="nd">length</em>(uint va) internal pure returns (uint) {<br/>        return va &gt;&gt; lenPos;<br/>    }</span><span id="355b" class="ne lh it nc b gy ny nv l nw nx">    function <em class="nd">setLength</em>(uint va, uint len) internal pure returns<br/>    (uint) {<br/>        require(len &lt;= elements);<br/>        return (va &amp; (uint(~0x0) &gt;&gt; lenBits)) | (len &lt;&lt; lenPos);<br/>    }</span><span id="a7de" class="ne lh it nc b gy ny nv l nw nx">    function <em class="nd">get</em>(uint va, uint index) internal pure returns (uint) {<br/>        require(index &lt; (va &gt;&gt; lenPos));<br/>        return (va &gt;&gt; (bits * index)) &amp; max;<br/>    }</span><span id="0605" class="ne lh it nc b gy ny nv l nw nx">    function <em class="nd">set</em>(uint va, uint index, uint value) internal pure <br/>    returns (uint) {<br/>        require((index &lt; (va &gt;&gt; lenPos)) &amp;&amp; (value &lt; range));<br/>        index *= bits;<br/>        return (va &amp; ~(max &lt;&lt; index)) | (value &lt;&lt; index);<br/>    }</span><span id="7c63" class="ne lh it nc b gy ny nv l nw nx">    function <em class="nd">push</em>(uint va, uint value) internal pure returns (uint){<br/>        uint len = va &gt;&gt; lenPos;<br/>        require((len &lt; elements) &amp;&amp; (value &lt; range));<br/>        uint posBits = len * bits;<br/>        va = (va &amp; ~(max &lt;&lt; posBits)) | (value &lt;&lt; posBits);<br/>        return (va &amp; (uint(~0) &gt;&gt; lenBits)) | ((len + 1) &lt;&lt; lenPos);<br/>    }<br/>}</span></pre><p id="bac7" class="pw-post-body-paragraph ly lz it ma b mb mu ju md me mv jx mg mh mw mj mk ml mx mn mo mp my mr ms mt im bi translated"><code class="fe mz na nb nc b">length()</code> <em class="nd"> </em>函数返回动态值数组的当前大小。您可以使用<code class="fe mz na nb nc b">setLength()</code>或<code class="fe mz na nb nc b">push()</code>或<em class="nd">改变数组中元素的数量。</em></p><p id="ecd8" class="pw-post-body-paragraph ly lz it ma b mb mu ju md me mv jx mg mh mw mj mk ml mx mn mo mp my mr ms mt im bi translated"><code class="fe mz na nb nc b">get()</code>和<code class="fe mz na nb nc b">set()</code>函数按照固定值数组获取和设置特定的元素，除了只有在数组的当前大小内的元素才可以被访问。</p><p id="2670" class="pw-post-body-paragraph ly lz it ma b mb mu ju md me mv jx mg mh mw mj mk ml mx mn mo mp my mr ms mt im bi translated"><code class="fe mz na nb nc b">push()</code>函数将值追加到动态值数组的最大大小。简单地定义<code class="fe mz na nb nc b">pop()</code> <em class="nd"> </em>也可以提供一个高效的小值堆栈。</p><p id="afe8" class="pw-post-body-paragraph ly lz it ma b mb mu ju md me mv jx mg mh mw mj mk ml mx mn mo mp my mr ms mt im bi translated">让我们看几个简单的、阳光明媚的测试，测试uint8d31示例库代码:</p><pre class="kj kk kl km gt nq nc nr ns aw nt bi"><span id="8371" class="ne lh it nc b gy nu nv l nw nx">import "uint8d31.sol";</span><span id="cc7d" class="ne lh it nc b gy ny nv l nw nx">contract TestUint8d31 {<br/>    using uint8d31 for uint;<br/>    <br/>    function test1() public pure {<br/>        uint va;<br/>        require(va.length() == 0, "length not 0");</span><span id="dc8e" class="ne lh it nc b gy ny nv l nw nx">        va = va.setLength(10);<br/>        require(va.length() == 10, "length not 10");<br/>    }<br/>  <br/>    function test2() public {<br/>        uint va;<br/>        va = va.push(0x12);<br/>        require(va.get(0) == 0x12, "va[0] not 0x12");<br/>        require(va.length() == 1, "length not 1");<br/>        <br/>        va = va.push(0x34);<br/>        require(va.get(1) == 0x34, "va[1] not 0x34");<br/>        require(va.length() == 2, "length not 2");<br/>        <br/>        va = va.setLength(31);<br/>        require(va.length() == 31, "length not 31");</span><span id="240c" class="ne lh it nc b gy ny nv l nw nx">        va = va.set(30, 0x78);<br/>        require(va.get(30) == 0x78, "va[30] not 0x78");<br/>        require(va.length() == 31, "length not 31");<br/>    }<br/>}</span></pre><h2 id="41b5" class="ne lh it bd li nf ng dn lm nh ni dp lq mh nj nk ls ml nl nm lu mp nn no lw np bi translated">结构动态数组</h2><p id="b6fb" class="pw-post-body-paragraph ly lz it ma b mb mc ju md me mf jx mg mh mi mj mk ml mm mn mo mp mq mr ms mt im bi translated">使用结构的优点是它们是通过引用内部(而不是外部)库函数来传递的，不需要从<code class="fe mz na nb nc b">setLength()</code>、<code class="fe mz na nb nc b">set()</code>和<code class="fe mz na nb nc b">push()</code>分配函数返回值。</p><p id="889a" class="pw-post-body-paragraph ly lz it ma b mb mu ju md me mv jx mg mh mw mj mk ml mx mn mo mp my mr ms mt im bi translated">下面是一个包含固定数组和长度的31字节数据的结构，以及相关的库函数:</p><pre class="kj kk kl km gt nq nc nr ns aw nt bi"><span id="cff5" class="ne lh it nc b gy nu nv l nw nx">struct Suint8u31 { // struct representing uint8[](31)<br/>    uint8[31] data;<br/>    uint8 length;<br/>}</span><span id="9475" class="ne lh it nc b gy ny nv l nw nx">// ------------</span><span id="06c7" class="ne lh it nc b gy ny nv l nw nx">library Suint8u31lib {<br/>    // constant declarations as per uint8d31<br/>    <br/>    function length(Suint8d31 memory s) internal pure returns (uint)<br/>    {<br/>        return s.length;<br/>    }</span><span id="c0d4" class="ne lh it nc b gy ny nv l nw nx">    function setLength(Suint8d31 memory s, uint len) ...</span><span id="88bf" class="ne lh it nc b gy ny nv l nw nx">    // other function definitions similar to uint8d31<br/>}</span></pre><p id="1132" class="pw-post-body-paragraph ly lz it ma b mb mu ju md me mv jx mg mh mw mj mk ml mx mn mo mp my mr ms mt im bi translated">这段代码类似于uint8d31，只是在需要的地方替换了<code class="fe mz na nb nc b">s.length</code>和<code class="fe mz na nb nc b">s.data[index]</code>，并且没有从<code class="fe mz na nb nc b">setLength()</code>、<code class="fe mz na nb nc b">set()</code>或<code class="fe mz na nb nc b">push()</code>返回值。</p><p id="cded" class="pw-post-body-paragraph ly lz it ma b mb mu ju md me mv jx mg mh mw mj mk ml mx mn mo mp my mr ms mt im bi translated">上面定义的Suint8u31结构似乎消耗了256位的地址空间。但在可靠性方面，每个数组都包含一个额外的256位数组长度值，即使它是一个固定的数组，因此我们预计该解决方案的气体消耗将高于预期。</p><h2 id="e77c" class="ne lh it bd li nf ng dn lm nh ni dp lq mh nj nk ls ml nl nm lu mp nn no lw np bi translated">结构动态值数组</h2><p id="5608" class="pw-post-body-paragraph ly lz it ma b mb mc ju md me mf jx mg mh mi mj mk ml mm mn mo mp mq mr ms mt im bi translated">下面是一个包含动态值数组和相关库函数的结构:</p><pre class="kj kk kl km gt nq nc nr ns aw nt bi"><span id="96bb" class="ne lh it nc b gy nu nv l nw nx">struct Suint8d31 { // struct representing uint8[](31)<br/>    uint va; // uint8d31 value array<br/>}</span><span id="1062" class="ne lh it nc b gy ny nv l nw nx">// ------------</span><span id="fa32" class="ne lh it nc b gy ny nv l nw nx">library Suint8d31lib {<br/>    // as per uint8d31<br/>    <br/>    function length(Suint8d31 memory s) internal pure returns (uint)<br/>    {<br/>        return s.va &gt;&gt; lenPos;<br/>    }</span><span id="f04d" class="ne lh it nc b gy ny nv l nw nx">    function setLength(Suint8u31 memory s, uint len) ...</span><span id="d043" class="ne lh it nc b gy ny nv l nw nx">    // other function definitions similar to uint8d31<br/>}</span></pre><p id="d59d" class="pw-post-body-paragraph ly lz it ma b mb mu ju md me mv jx mg mh mw mj mk ml mx mn mo mp my mr ms mt im bi translated">这段代码与uint8d31非常相似，只是用<code class="fe mz na nb nc b">s.va</code>代替每次出现的<code class="fe mz na nb nc b">va</code>，并且不从<em class="nd"> </em> <code class="fe mz na nb nc b">setLength(</code>)、<code class="fe mz na nb nc b">set()</code>或<code class="fe mz na nb nc b">push()</code>返回值。</p><p id="06c1" class="pw-post-body-paragraph ly lz it ma b mb mu ju md me mv jx mg mh mw mj mk ml mx mn mo mp my mr ms mt im bi translated">让我们测量一下这个神秘的舒适休息后的油耗。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi od"><img src="../Images/500930df7bfa3abe5c9bb18b23a8a02d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*-q4gLDhAU8uAeqkmlz-s9A.jpeg"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">作者的神秘照片</p></figure></div><div class="ab cl kz la hx lb" role="separator"><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le"/></div><div class="im in io ip iq"><h1 id="4c70" class="lg lh it bd li lj lk ll lm ln lo lp lq jz lr ka ls kc lt kd lu kf lv kg lw lx bi translated">燃气流量</h1><p id="f783" class="pw-post-body-paragraph ly lz it ma b mb mc ju md me mf jx mg mh mi mj mk ml mm mn mo mp mq mr ms mt im bi translated">在编写了库和合同之后，我们使用作者在文章<a class="ae ky" href="https://medium.com/coinmonks/gas-cost-of-solidity-library-functions-dbe0cedd4678" rel="noopener">固体功能的气体成本</a>中描述的技术来测量气体消耗。</p><p id="27a6" class="pw-post-body-paragraph ly lz it ma b mb mu ju md me mv jx mg mh mw mj mk ml mx mn mo mp my mr ms mt im bi translated">以下是图表的图例:</p><pre class="kj kk kl km gt nq nc nr ns aw nt bi"><span id="5156" class="ne lh it nc b gy nu nv l nw nx"><strong class="nc iu">Legend         Meaning</strong></span><span id="01c8" class="ne lh it nc b gy ny nv l nw nx">uint8[](32)    Solidity dynamic array of 32 uint8<br/>uint8[32]      Solidity fixed array of 32 uint8<br/>uint8a32       Fixed Value Array of 32 uint8 (<a class="ae ky" href="https://medium.com/@plaxion/value-arrays-in-solidity-32ca65135d5b" rel="noopener">other</a> article)<br/>uint8d31       Dynamic Value Array of &lt;= 31 uint8 (this article)<br/>suint8d31      Struct containing Dynamic Value Array of &lt;= 31 uint8<br/>suint8u31      Struct containing Solidity fixed array of &lt;= 31 uint8</span></pre><h2 id="7f66" class="ne lh it bd li nf ng dn lm nh ni dp lq mh nj nk ls ml nl nm lu mp nn no lw np bi translated">EVM内存空间中的uint8阵列</h2><p id="00f6" class="pw-post-body-paragraph ly lz it ma b mb mc ju md me mf jx mg mh mi mj mk ml mm mn mo mp mq mr ms mt im bi translated">这里，我们比较了在EVM内存空间中使用动态uint8数组的情况:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi oe"><img src="../Images/9662f85d695c4761a7966b896498cdf8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*cYsTY8dDikbLgxrUlU3fnQ.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">获取和设置uint8内存变量的气体消耗</p></figure><p id="1034" class="pw-post-body-paragraph ly lz it ma b mb mu ju md me mv jx mg mh mw mj mk ml mx mn mo mp my mr ms mt im bi translated">此图表显示，动态值数组(uint8d31)上一些常见操作的气体消耗仅比固定值数组(uint8a32)多一点。</p><p id="c621" class="pw-post-body-paragraph ly lz it ma b mb mu ju md me mv jx mg mh mw mj mk ml mx mn mo mp my mr ms mt im bi translated">所有其他选项消耗的气体都要多得多，尤其是包含Solidity固定数组的结构(最后一列)。</p><p id="22e2" class="pw-post-body-paragraph ly lz it ma b mb mu ju md me mv jx mg mh mw mj mk ml mx mn mo mp my mr ms mt im bi translated">以下是各项操作的气体消耗量对比:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi of"><img src="../Images/12e937dfecfdf006db62c3585385c307.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*j5FHD9UP8izLWVi2nZxkFQ.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">uint8内存变量的push、get和set的气体消耗</p></figure><p id="b5f6" class="pw-post-body-paragraph ly lz it ma b mb mu ju md me mv jx mg mh mw mj mk ml mx mn mo mp my mr ms mt im bi translated">注意，<code class="fe mz na nb nc b">push()</code>在Solidity内存数组上是不允许的，即使是动态内存数组(每种类型的金色列)，但是我们确实为本文中测量的动态数据结构实现了它。</p><p id="bc34" class="pw-post-body-paragraph ly lz it ma b mb mu ju md me mv jx mg mh mw mj mk ml mx mn mo mp my mr ms mt im bi translated">由此得出的结论是，动态值数组(uint8d31)只比固定值数组(uint8a32)消耗多一点点的数据，而所有其他选项消耗的数据(有时会多很多)更多。</p><h2 id="f8fd" class="ne lh it bd li nf ng dn lm nh ni dp lq mh nj nk ls ml nl nm lu mp nn no lw np bi translated">EVM存储空间中的uint8阵列</h2><p id="0f2e" class="pw-post-body-paragraph ly lz it ma b mb mc ju md me mf jx mg mh mi mj mk ml mm mn mo mp mq mr ms mt im bi translated">这里，我们比较了在EVM存储空间中使用动态uint8阵列的情况:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi og"><img src="../Images/103433ad2f4caf494042e42399dc44bb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*dzcy5Ov6XFSX-NuMqrS-4Q.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">推送/设置和获取uint8存储变量的气体消耗</p></figure><p id="b85e" class="pw-post-body-paragraph ly lz it ma b mb mu ju md me mv jx mg mh mw mj mk ml mx mn mo mp my mr ms mt im bi translated">在这里，除了第一列和最后一列的高气体消耗之外，画面是清楚的，选择不太明确。</p><p id="4a12" class="pw-post-body-paragraph ly lz it ma b mb mu ju md me mv jx mg mh mw mj mk ml mx mn mo mp my mr ms mt im bi translated">以下是各项操作的气体消耗量对比:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi oh"><img src="../Images/a09b865a330c33691035ffd53fee6636.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*O8Y3eZnk6wF7iFR3MnuDbA.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">uint8存储变量的推送、获取和设置的气体消耗</p></figure><p id="6ef3" class="pw-post-body-paragraph ly lz it ma b mb mu ju md me mv jx mg mh mw mj mk ml mx mn mo mp my mr ms mt im bi translated">要关注的列可能是rust列(每种类型的最右侧)，它倾向于显示分配存储空间后的典型使用情况，而第一个<code class="fe mz na nb nc b">push()</code>或<code class="fe mz na nb nc b">set()</code>会导致存储空间被分配，这会消耗EVM上的大量汽油。</p><p id="d32c" class="pw-post-body-paragraph ly lz it ma b mb mu ju md me mv jx mg mh mw mj mk ml mx mn mo mp my mr ms mt im bi translated">以上，动态值数组(uint8d31)比固定值数组(uint8a32)消耗的气体多一点，其他所有选项消耗的气体都多一点。</p><h1 id="bf6d" class="lg lh it bd li lj oi ll lm ln oj lp lq jz ok ka ls kc ol kd lu kf om kg lw lx bi translated">分包合同和库的参数</h1><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi on"><img src="../Images/37e0d50f477728fd1d3754093e40e436.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*V15ZyblSM09cNCiUb5aU3g.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">将uint8参数传递给分包或库的气体消耗</p></figure><p id="a3bb" class="pw-post-body-paragraph ly lz it ma b mb mu ju md me mv jx mg mh mw mj mk ml mx mn mo mp my mr ms mt im bi translated">不足为奇的是，最大的气体消耗是向一个分包函数或库函数提供一个数组参数，然后再次获取该值。</p><p id="5868" class="pw-post-body-paragraph ly lz it ma b mb mu ju md me mv jx mg mh mw mj mk ml mx mn mo mp my mr ms mt im bi translated">相反，使用一个值显然会消耗更少的汽油。</p></div><div class="ab cl kz la hx lb" role="separator"><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le"/></div><div class="im in io ip iq"><h1 id="47bc" class="lg lh it bd li lj lk ll lm ln lo lp lq jz lr ka ls kc lt kd lu kf lv kg lw lx bi translated">其他可能性</h1><p id="20aa" class="pw-post-body-paragraph ly lz it ma b mb mc ju md me mf jx mg mh mi mj mk ml mm mn mo mp mq mr ms mt im bi translated">如果您发现动态值数组很有用，您可能还想考虑固定值数组、固定多值数组、值队列、值堆栈等等。如果你的算法(比如<code class="fe mz na nb nc b">Sort</code>)使用值数组而不是引用数组，它们会有怎样的表现？</p></div><div class="ab cl kz la hx lb" role="separator"><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le"/></div><div class="im in io ip iq"><h1 id="5c19" class="lg lh it bd li lj lk ll lm ln lo lp lq jz lr ka ls kc lt kd lu kf lv kg lw lx bi translated">结论</h1><p id="e345" class="pw-post-body-paragraph ly lz it ma b mb mc ju md me mf jx mg mh mi mj mk ml mm mn mo mp mq mr ms mt im bi translated">我们已经为uintX[](Y)小型动态值数组的通用库代码提供并测量了代码。</p><p id="b499" class="pw-post-body-paragraph ly lz it ma b mb mu ju md me mv jx mg mh mw mj mk ml mx mn mo mp my mr ms mt im bi translated">与Solidity的动态数组相比，我们可以使用动态值数组来减少存储空间和气体消耗。</p><p id="dfe7" class="pw-post-body-paragraph ly lz it ma b mb mu ju md me mv jx mg mh mw mj mk ml mx mn mo mp my mr ms mt im bi translated">如果您的Solidity智能契约使用小值的小型动态数组(用于用户id、角色等)，那么使用动态值数组可能会消耗更少的汽油。</p><p id="baff" class="pw-post-body-paragraph ly lz it ma b mb mu ju md me mv jx mg mh mw mj mk ml mx mn mo mp my mr ms mt im bi translated">在复制数组的情况下，例如，对于分包合同或库，动态值数组将总是消耗少得多的气体。</p><p id="463e" class="pw-post-body-paragraph ly lz it ma b mb mu ju md me mv jx mg mh mw mj mk ml mx mn mo mp my mr ms mt im bi translated">在其他情况下，继续使用动态引用数组。</p></div><div class="ab cl kz la hx lb" role="separator"><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le"/></div><div class="im in io ip iq"><p id="d83e" class="pw-post-body-paragraph ly lz it ma b mb mu ju md me mv jx mg mh mw mj mk ml mx mn mo mp my mr ms mt im bi translated">感谢阅读！</p></div></div>    
</body>
</html>