<html>
<head>
<title>A Step-by-Step Guide to Training a Model on Google Cloud’s Vertex AI</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">在谷歌云的顶点人工智能上训练模型的分步指南</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/a-step-by-step-guide-to-train-a-model-on-google-clouds-vertex-ai-47faafae1330?source=collection_archive---------5-----------------------#2021-06-07">https://betterprogramming.pub/a-step-by-step-guide-to-train-a-model-on-google-clouds-vertex-ai-47faafae1330?source=collection_archive---------5-----------------------#2021-06-07</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="4e49" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">从零开始，到达在顶点人工智能上训练的第一个模型</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi ki"><img src="../Images/7f24184c590a836fd8c2242d7b8f420d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1026/format:webp/1*aeXlwnOS3DvVHiMVgBZbpQ.png"/></div><p class="kq kr gj gh gi ks kt bd b be z dk translated">顶点AI(来源:<a class="ae ku" href="https://cloud.google.com/vertex-ai" rel="noopener ugc nofollow" target="_blank">谷歌云</a>)</p></figure><h1 id="8a50" class="kv kw it bd kx ky kz la lb lc ld le lf jz lg ka lh kc li kd lj kf lk kg ll lm bi translated">顶点AI教程系列</h1><ol class=""><li id="12c3" class="ln lo it lp b lq lr ls lt lu lv lw lx ly lz ma mb mc md me bi translated">在Google Cloud的Vertex AI上训练模型的分步指南(本文)</li><li id="1255" class="ln lo it lp b lq mf ls mg lu mh lw mi ly mj ma mb mc md me bi translated"><a class="ae ku" rel="noopener ugc nofollow" target="_blank" href="/a-step-by-step-guide-to-tune-a-model-on-google-clouds-vertex-ai-afd2e72af595">在谷歌云的顶点人工智能上调整模型的逐步指南</a></li><li id="9145" class="ln lo it lp b lq mf ls mg lu mh lw mi ly mj ma mb mc md me bi translated"><a class="ae ku" rel="noopener ugc nofollow" target="_blank" href="/how-to-operationalize-a-model-on-google-clouds-vertex-ai-53298b530703">如何在谷歌云的顶点人工智能上操作一个模型</a></li><li id="bb63" class="ln lo it lp b lq mf ls mg lu mh lw mi ly mj ma mb mc md me bi translated"><a class="ae ku" rel="noopener ugc nofollow" target="_blank" href="/how-to-use-automl-on-google-clouds-vertex-ai-27f8778239ea">如何在Google Cloud的Vertex AI上使用AutoML</a></li><li id="546b" class="ln lo it lp b lq mf ls mg lu mh lw mi ly mj ma mb mc md me bi translated"><a class="ae ku" rel="noopener ugc nofollow" target="_blank" href="/how-to-use-bigquery-ml-on-google-clouds-vertex-ai-23b1ca0b635">如何在Google Cloud的Vertex AI上使用big query ML</a></li><li id="2023" class="ln lo it lp b lq mf ls mg lu mh lw mi ly mj ma mb mc md me bi translated"><a class="ae ku" rel="noopener ugc nofollow" target="_blank" href="/how-to-use-pipeline-on-google-clouds-vertex-ai-863b429c811f">如何在Google Cloud的Vertex AI上使用Pipeline</a></li></ol><h1 id="cd75" class="kv kw it bd kx ky kz la lb lc ld le lf jz lg ka lh kc li kd lj kf lk kg ll lm bi translated"><strong class="ak">背景和动机</strong></h1><p id="ee63" class="pw-post-body-paragraph mk ml it lp b lq lr ju mm ls lt jx mn lu mo mp mq lw mr ms mt ly mu mv mw ma im bi translated">谷歌最近宣布其用于机器学习的云平台——<a class="ae ku" href="https://cloud.google.com/vertex-ai" rel="noopener ugc nofollow" target="_blank">Vertex AI</a>正式上市。我对此感到非常兴奋。我一直想在Google Cloud上看到一个连贯的、端到端的ML工作流故事。多年来，Google Cloud已经有了许多与ML相关的服务和工具。希望这次他们能把它们统一到一个集成的平台上。</p><p id="e96d" class="pw-post-body-paragraph mk ml it lp b lq mx ju mm ls my jx mn lu mz mp mq lw na ms mt ly nb mv mw ma im bi translated">怀着很高的期望，我去查阅了<a class="ae ku" href="https://cloud.google.com/vertex-ai" rel="noopener ugc nofollow" target="_blank">文档</a>。我不得不说，它需要一点改进。内容很多，大部分都很好，但是组织混乱。感觉就像是一大堆文章，由最后几页“索引式”的单页纸链接而成。很难找到从哪里开始。最重要的是，你不知道哪些链接是关键的，所以你最终会分心去访问所有的链接。</p><p id="841f" class="pw-post-body-paragraph mk ml it lp b lq mx ju mm ls my jx mn lu mz mp mq lw na ms mt ly nb mv mw ma im bi translated">我真的很喜欢底层服务，我想学习更好地使用它们，我想为它们布道。这就是为什么我决定创建一系列文章来演示Vertex AI的端到端教程。它假设没有谷歌云的ML服务的经验。我也尽力包含文章中的所有内容，这样你就不需要在链接之间跳来跳去。显然，如果需要的话，我会为感兴趣的读者提供适当的链接，让他们找到更多的细节。</p><p id="5323" class="pw-post-body-paragraph mk ml it lp b lq mx ju mm ls my jx mn lu mz mp mq lw na ms mt ly nb mv mw ma im bi translated">这是这个系列的第一集。我们从头开始，到本文结束时，我们将创建第一个在Vertex AI上训练的模型。</p><h1 id="9064" class="kv kw it bd kx ky kz la lb lc ld le lf jz lg ka lh kc li kd lj kf lk kg ll lm bi translated"><strong class="ak">先决条件</strong></h1><p id="798f" class="pw-post-body-paragraph mk ml it lp b lq lr ju mm ls lt jx mn lu mo mp mq lw mr ms mt ly mu mv mw ma im bi translated">本系列假设对Google云平台有基本的了解。你需要一个谷歌云项目。您还需要设置常见的命令行实用程序，如<code class="fe nc nd ne nf b">gcloud</code> ( <a class="ae ku" href="https://cloud.google.com/sdk/docs/install" rel="noopener ugc nofollow" target="_blank"> Google Cloud SDK </a>)和<code class="fe nc nd ne nf b">gsutil</code>(<a class="ae ku" href="https://cloud.google.com/storage/docs/gsutil" rel="noopener ugc nofollow" target="_blank">Google Cloud Storage utils</a>)。</p><p id="db53" class="pw-post-body-paragraph mk ml it lp b lq mx ju mm ls my jx mn lu mz mp mq lw na ms mt ly nb mv mw ma im bi translated">作者插曲:我们将在后面的代码和命令中使用一些谷歌云存储路径占位符，如<code class="fe nc nd ne nf b">GCS_PATH_FOR_*</code>。您需要以<code class="fe nc nd ne nf b">gs://bucket/[folder]/[sub_folder]/</code>的形式指定您自己的。此外，本系列假设对<a class="ae ku" href="https://www.tensorflow.org/" rel="noopener ugc nofollow" target="_blank"> Tensorflow </a>有基本的了解。我们只使用Tensorflow中的高级API，所有这些API都是不言自明的，所以如果你不是Tensorflow大师，也不用担心。</p><p id="562a" class="pw-post-body-paragraph mk ml it lp b lq mx ju mm ls my jx mn lu mz mp mq lw na ms mt ly nb mv mw ma im bi translated">检查您是否满足先决条件的一个方法是遵循第一篇文章。如果你觉得它跳过太多，这可能是一个信号，让你在继续下一步之前加强对前提材料的理解。</p><h1 id="85e7" class="kv kw it bd kx ky kz la lb lc ld le lf jz lg ka lh kc li kd lj kf lk kg ll lm bi translated"><strong class="ak">问题设置</strong></h1><p id="951c" class="pw-post-body-paragraph mk ml it lp b lq lr ju mm ls lt jx mn lu mo mp mq lw mr ms mt ly mu mv mw ma im bi translated">我们在这个系列中处理一个非常基本的图像分类问题。人们喜欢使用MNIST数据集。但是我们想变得更加丰富多彩(MNIST是灰度)。因此，我们将致力于<a class="ae ku" href="https://www.tensorflow.org/datasets/catalog/cifar10" rel="noopener ugc nofollow" target="_blank"> CIFAR10 </a>。它包含10类60，000张32x32的彩色图像，每类6，000张图像——我们将在这篇博文的后面展示图像示例。</p><h1 id="61a6" class="kv kw it bd kx ky kz la lb lc ld le lf jz lg ka lh kc li kd lj kf lk kg ll lm bi translated"><strong class="ak">开发环境设置</strong></h1><p id="f3ae" class="pw-post-body-paragraph mk ml it lp b lq lr ju mm ls lt jx mn lu mo mp mq lw mr ms mt ly mu mv mw ma im bi translated">我们与之交互的主要开发环境是<a class="ae ku" href="https://jupyter.org/" rel="noopener ugc nofollow" target="_blank"> JupyterLab </a>，从这里我们可以编写交互式Python代码并轻松访问命令行终端。你可以在本地建立自己的JupyterLab。如果你以前做过ML，你可能已经有了。</p><p id="d2b4" class="pw-post-body-paragraph mk ml it lp b lq mx ju mm ls my jx mn lu mz mp mq lw na ms mt ly nb mv mw ma im bi translated">我推荐在Vertex AI(JupyterLab的管理版本)中使用<a class="ae ku" href="https://cloud.google.com/vertex-ai/docs/general/notebooks" rel="noopener ugc nofollow" target="_blank">笔记本</a>。这是首选的原因有几个。首先，它内置了所有典型的ML包。其次，它已经被配置为连接其他谷歌云服务，所以你不需要为那些烦人的认证/连接设置而烦恼。最后，它允许您超越本地工作站的限制进行扩展。例如，如果您需要更多的CPU/RAM/GPU，只需创建一个由适当的机器类型支持的笔记本。如果你需要更多的磁盘空间，只需创建一个谷歌云盘，并将其附加到笔记本的虚拟机上。因为它的设置很简单——只需点击几下——而且本教程并不要求这样做，所以我在这里不包括说明。如果你有兴趣，可以看看笔记本<a class="ae ku" href="https://cloud.google.com/notebooks/docs" rel="noopener ugc nofollow" target="_blank">文档</a>。</p><p id="a0c3" class="pw-post-body-paragraph mk ml it lp b lq mx ju mm ls my jx mn lu mz mp mq lw na ms mt ly nb mv mw ma im bi translated">默认情况下，所有Python代码和命令行执行都在JupyterLab中，除非另外调用。</p><h1 id="9381" class="kv kw it bd kx ky kz la lb lc ld le lf jz lg ka lh kc li kd lj kf lk kg ll lm bi translated"><strong class="ak">数据准备</strong></h1><p id="495b" class="pw-post-body-paragraph mk ml it lp b lq lr ju mm ls lt jx mn lu mo mp mq lw mr ms mt ly mu mv mw ma im bi translated">数据准备是任何ML项目中的关键任务。在我们的示例中，CIFAR10已经包含在Tensorflow数据集目录中。但是为了模拟真实的ML项目开发，我们将处理数据集并将其上传到Google云存储(GCS)供下游使用。许多Tensorflow函数都内置了对GCS的支持。我们只需要做一次，结果将被重新用于后续的模型训练和验证。</p><p id="121a" class="pw-post-body-paragraph mk ml it lp b lq mx ju mm ls my jx mn lu mz mp mq lw na ms mt ly nb mv mw ma im bi translated">只需几行Tensorflow代码，我们就可以下载数据集，对其进行预处理，并为训练、验证和测试集创建Tensorflow示例。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ng nh l"/></div><p class="kq kr gj gh gi ks kt bd b be z dk translated">数据预处理代码</p></figure><p id="abdc" class="pw-post-body-paragraph mk ml it lp b lq mx ju mm ls my jx mn lu mz mp mq lw na ms mt ly nb mv mw ma im bi translated">然后，我们将文件复制到GCS存储桶中，供下游使用。强烈建议将Vertex AI Notebook(如果你正在使用的话)、GCS bucket以及后续的Vertex AI服务放在同一地区。这不仅提高了性能，还有助于避免您可能遇到的一些奇怪的跨区域问题。</p><pre class="kj kk kl km gt ni nf nj nk aw nl bi"><span id="77ae" class="nm kw it nf b gy nn no l np nq">gsutil -m cp *.tfrecord GCS_PATH_FOR_DATA</span></pre><p id="9066" class="pw-post-body-paragraph mk ml it lp b lq mx ju mm ls my jx mn lu mz mp mq lw na ms mt ly nb mv mw ma im bi translated">我们应该验证GCS中的数据是可访问的并且编码正确。我们从Tensorflow示例文件中获取、解码并显示一些图像:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ng nh l"/></div><p class="kq kr gj gh gi ks kt bd b be z dk translated">数据验证代码</p></figure><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ns nt di nu bf nv"><div class="gh gi nr"><img src="../Images/32fff38b3275eb9d164309fa7b98efea.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*vX11NzUZunzFonOkeO0spw.png"/></div></div><p class="kq kr gj gh gi ks kt bd b be z dk translated">已处理数据集中的样本图像</p></figure><h1 id="1e4c" class="kv kw it bd kx ky kz la lb lc ld le lf jz lg ka lh kc li kd lj kf lk kg ll lm bi translated"><strong class="ak">本地训练一个模型</strong></h1><p id="3464" class="pw-post-body-paragraph mk ml it lp b lq lr ju mm ls lt jx mn lu mo mp mq lw mr ms mt ly mu mv mw ma im bi translated">在我们对Vertex AI做任何事情之前，让我们在本地训练一个模型，以确保一切正常。我们首先准备好输入数据集:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ng nh l"/></div><p class="kq kr gj gh gi ks kt bd b be z dk translated">张量流数据集创建代码</p></figure><p id="adfb" class="pw-post-body-paragraph mk ml it lp b lq mx ju mm ls my jx mn lu mz mp mq lw na ms mt ly nb mv mw ma im bi translated">然后我们构建模型。模型架构包含几个卷积层，后面是扁平化全连接层，最后输出十类的概率。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ng nh l"/></div><p class="kq kr gj gh gi ks kt bd b be z dk translated">模型构造代码</p></figure><p id="6c8a" class="pw-post-body-paragraph mk ml it lp b lq mx ju mm ls my jx mn lu mz mp mq lw na ms mt ly nb mv mw ma im bi translated">最后，我们来训练模型。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ns nt di nu bf nv"><div class="gh gi nw"><img src="../Images/78bd9f041b5fb698df3033cf44ebe2c4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*NQWP1UansFPBI4RegN3LDA.png"/></div></div><p class="kq kr gj gh gi ks kt bd b be z dk translated">本地培训准确性指标</p></figure><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ng nh l"/></div><p class="kq kr gj gh gi ks kt bd b be z dk translated">模型训练代码</p></figure><p id="fe91" class="pw-post-body-paragraph mk ml it lp b lq mx ju mm ls my jx mn lu mz mp mq lw na ms mt ly nb mv mw ma im bi translated">在测试数据集上，该模型的准确率只有60%，不是很高。我们将在以后的文章中改进它。但是，就目前而言，至少本地培训是端到端的。</p><h1 id="3f3b" class="kv kw it bd kx ky kz la lb lc ld le lf jz lg ka lh kc li kd lj kf lk kg ll lm bi translated"><strong class="ak">在顶点AI上训练一个模型</strong></h1><p id="daec" class="pw-post-body-paragraph mk ml it lp b lq lr ju mm ls lt jx mn lu mo mp mq lw mr ms mt ly mu mv mw ma im bi translated">是时候转向云计算了。我们需要为模型更新一些东西:</p><ul class=""><li id="e200" class="ln lo it lp b lq mx ls my lu nx lw ny ly nz ma oa mc md me bi translated">我们希望将它包装在一个分布式培训策略下，以便它可以利用硬件(如果可用的话)。</li><li id="f797" class="ln lo it lp b lq mf ls mg lu mh lw mi ly mj ma oa mc md me bi translated">我们还想保存训练检查点，因为云上的机器可能会被抢占。</li><li id="3637" class="ln lo it lp b lq mf ls mg lu mh lw mi ly mj ma oa mc md me bi translated">在训练结束时，我们希望导出训练好的模型以供使用。</li></ul><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ng nh l"/></div><p class="kq kr gj gh gi ks kt bd b be z dk translated">最终模型构造代码</p></figure><p id="e57f" class="pw-post-body-paragraph mk ml it lp b lq mx ju mm ls my jx mn lu mz mp mq lw na ms mt ly nb mv mw ma im bi translated">现在，我们准备在Vertex AI上训练模型。概括地说，它包括以下步骤:</p><ul class=""><li id="19ef" class="ln lo it lp b lq mx ls my lu nx lw ny ly nz ma oa mc md me bi translated">稍微重组一下代码，让它可以被Vertex AI使用。</li><li id="35ef" class="ln lo it lp b lq mf ls mg lu mh lw mi ly mj ma oa mc md me bi translated">捆绑一个Python发行版，上传到GCS，这样Vertex AI就可以访问了。</li><li id="91eb" class="ln lo it lp b lq mf ls mg lu mh lw mi ly mj ma oa mc md me bi translated">通过调用<code class="fe nc nd ne nf b">gcloud</code>命令行工具启动培训任务，并提供适当的参数。</li><li id="ec00" class="ln lo it lp b lq mf ls mg lu mh lw mi ly mj ma oa mc md me bi translated">轮询作业状态，直到完成。</li></ul><h1 id="971e" class="kv kw it bd kx ky kz la lb lc ld le lf jz lg ka lh kc li kd lj kf lk kg ll lm bi translated"><strong class="ak">重组代码</strong></h1><p id="4742" class="pw-post-body-paragraph mk ml it lp b lq lr ju mm ls lt jx mn lu mo mp mq lw mr ms mt ly mu mv mw ma im bi translated">我们可以认为Vertex AI上的训练环境类似于我们的JupyterLab环境。培训工作的启动类似于在本地启动Python程序。我们已经有了Python程序——只需将“在本地训练一个模型”部分的所有代码片段放在一个<code class="fe nc nd ne nf b">.py</code>文件中(按照惯例是<code class="fe nc nd ne nf b">task.py</code>)。不要忘记为上面提到的分布式策略、检查点和模型导出修改它。</p><p id="1038" class="pw-post-body-paragraph mk ml it lp b lq mx ju mm ls my jx mn lu mz mp mq lw na ms mt ly nb mv mw ma im bi translated">此外，让我们将历元数作为参数添加到程序中。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ng nh l"/></div><p class="kq kr gj gh gi ks kt bd b be z dk translated">模型参数代码</p></figure><p id="1222" class="pw-post-body-paragraph mk ml it lp b lq mx ju mm ls my jx mn lu mz mp mq lw na ms mt ly nb mv mw ma im bi translated">尝试在本地启动培训以确保其有效。当在Vertex AI上训练时，我们需要等待我们的训练任务被安排，这可能需要一些时间。我们不想因为一些愚蠢的打字错误而发现一项工作失败了！</p><pre class="kj kk kl km gt ni nf nj nk aw nl bi"><span id="2bd7" class="nm kw it nf b gy nn no l np nq">python task.py --epochs=1</span></pre><h1 id="8684" class="kv kw it bd kx ky kz la lb lc ld le lf jz lg ka lh kc li kd lj kf lk kg ll lm bi translated"><strong class="ak">捆绑并上传Python发行版</strong></h1><p id="968d" class="pw-post-body-paragraph mk ml it lp b lq lr ju mm ls lt jx mn lu mo mp mq lw mr ms mt ly mu mv mw ma im bi translated">现在，我们需要捆绑一个Python发行版。按如下方式构建文件夹:</p><pre class="kj kk kl km gt ni nf nj nk aw nl bi"><span id="a049" class="nm kw it nf b gy nn no l np nq">|-- setup.py<br/>|-- trainer<br/>    |-- task.py<br/>    |-- __init__.py</span></pre><p id="50d9" class="pw-post-body-paragraph mk ml it lp b lq mx ju mm ls my jx mn lu mz mp mq lw na ms mt ly nb mv mw ma im bi translated"><code class="fe nc nd ne nf b">task.py</code>文件是我们刚刚放在一起并在本地测试的Python程序。把它放在一个<code class="fe nc nd ne nf b">trainer</code>文件夹里作为惯例。<code class="fe nc nd ne nf b">__init__.py</code>文件是一个空的Python文件，用来划分模块。查看以下<code class="fe nc nd ne nf b">setup.py</code>文件的基本内容:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ng nh l"/></div><p class="kq kr gj gh gi ks kt bd b be z dk translated">setup.py</p></figure><p id="197c" class="pw-post-body-paragraph mk ml it lp b lq mx ju mm ls my jx mn lu mz mp mq lw na ms mt ly nb mv mw ma im bi translated">如果需要安装其他标准Python包依赖项，可以在<code class="fe nc nd ne nf b">setup.py</code>文件中声明。出于演示目的，我们在这里保持一切简单。</p><p id="db39" class="pw-post-body-paragraph mk ml it lp b lq mx ju mm ls my jx mn lu mz mp mq lw na ms mt ly nb mv mw ma im bi translated">现在，让我们打包Python发行版。以下命令在新创建的<code class="fe nc nd ne nf b">dist</code>文件夹下生成一个<code class="fe nc nd ne nf b">trainer-0.1.tar.gz</code>文件。</p><pre class="kj kk kl km gt ni nf nj nk aw nl bi"><span id="7f4e" class="nm kw it nf b gy nn no l np nq">python setup.py sdist --formats=gztar</span></pre><p id="5320" class="pw-post-body-paragraph mk ml it lp b lq mx ju mm ls my jx mn lu mz mp mq lw na ms mt ly nb mv mw ma im bi translated">将Python发行版复制到GCS位置，以便顶点AI可以访问它。</p><pre class="kj kk kl km gt ni nf nj nk aw nl bi"><span id="4542" class="nm kw it nf b gy nn no l np nq">gsutil cp dist/trainer-0.1.tar.gz GCS_PATH_FOR_PYTHON_CODE</span></pre><h1 id="5bdf" class="kv kw it bd kx ky kz la lb lc ld le lf jz lg ka lh kc li kd lj kf lk kg ll lm bi translated"><strong class="ak">启动培训工作</strong></h1><p id="5d9c" class="pw-post-body-paragraph mk ml it lp b lq lr ju mm ls lt jx mn lu mo mp mq lw mr ms mt ly mu mv mw ma im bi translated">最后，我们准备启动Vertex AI的培训工作。这部分的文档有点不透明。让我们浏览一下说明。</p><p id="f0a8" class="pw-post-body-paragraph mk ml it lp b lq mx ju mm ls my jx mn lu mz mp mq lw na ms mt ly nb mv mw ma im bi translated">在继续下一步之前澄清一下:我们将使用一个预构建的容器启动一个定制的培训任务。这是一项定制培训工作，因为我们正在从头开始构建模型。在未来的文章中，我们将探索如何利用Vertex AI的预建模型。我们正在使用一个预构建的容器。容器是执行训练代码的环境。您可以使用您的自定义容器进行训练，其中包含您的专用工具和依赖项。但是，让我们把这个高级用例放在一边，关注这里简单的端到端工作流。</p><p id="d957" class="pw-post-body-paragraph mk ml it lp b lq mx ju mm ls my jx mn lu mz mp mq lw na ms mt ly nb mv mw ma im bi translated">我们将使用<code class="fe nc nd ne nf b">gcloud</code>命令行工具启动培训。Vertex AI内置了一个子命令，<code class="fe nc nd ne nf b">gcloud</code>(目前还在beta阶段)。</p><pre class="kj kk kl km gt ni nf nj nk aw nl bi"><span id="b94a" class="nm kw it nf b gy nn no l np nq">gcloud beta ai custom-jobs create --region=us-central1 --display-name=e2e-tutorial --config=config.yaml</span></pre><p id="3b5a" class="pw-post-body-paragraph mk ml it lp b lq mx ju mm ls my jx mn lu mz mp mq lw na ms mt ly nb mv mw ma im bi translated">该命令的核心在<code class="fe nc nd ne nf b">config.yaml</code>文件中。我们也可以在命令行中指定单独的参数，但是我建议使用配置文件，因为我们需要指定相当多的参数。配置的模式也没有很好地记录。您必须知道它实际上是API方法的参数(<a class="ae ku" href="https://cloud.google.com/vertex-ai/docs/reference/rest/v1/CustomJobSpec" rel="noopener ugc nofollow" target="_blank"> link </a>)。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ng nh l"/></div><p class="kq kr gj gh gi ks kt bd b be z dk translated">config.yaml</p></figure><h1 id="59d4" class="kv kw it bd kx ky kz la lb lc ld le lf jz lg ka lh kc li kd lj kf lk kg ll lm bi translated"><strong class="ak">轮询作业状态</strong></h1><p id="eae7" class="pw-post-body-paragraph mk ml it lp b lq lr ju mm ls lt jx mn lu mo mp mq lw mr ms mt ly mu mv mw ma im bi translated"><code class="fe nc nd ne nf b">custom-jobs create</code>命令将返回一个任务ID，以便我们检查状态。只需调用以下命令来轮询作业的状态。</p><pre class="kj kk kl km gt ni nf nj nk aw nl bi"><span id="51a2" class="nm kw it nf b gy nn no l np nq">gcloud beta ai custom-jobs describe JOB_ID --region=us-central1</span></pre><p id="8506" class="pw-post-body-paragraph mk ml it lp b lq mx ju mm ls my jx mn lu mz mp mq lw na ms mt ly nb mv mw ma im bi translated">如果一切顺利，几分钟后您将看到作业状态为<code class="fe nc nd ne nf b">JOB_STATE_SUCCEEDED</code>。我们还可以在云控制台上查看作业状态。进入顶点AI - &gt;培训- &gt;定制作业，点击“e2e-教程”查看作业详情。我们还可以通过查看日志链接来检查培训作业的控制台输出。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ns nt di nu bf nv"><div class="gh gi ob"><img src="../Images/3404452d25f4aa8dba433b3456bcae7f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*DFLlFrk-KMeEDMTN9JehWg.png"/></div></div><p class="kq kr gj gh gi ks kt bd b be z dk translated">自定义作业页面</p></figure><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ns nt di nu bf nv"><div class="gh gi oc"><img src="../Images/79efe8abf63bcca83d3b15998bf813a3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*xBtGCMrGQWDZ7lfJzoWwSQ.png"/></div></div><p class="kq kr gj gh gi ks kt bd b be z dk translated">职务详细信息页面</p></figure><h1 id="fa74" class="kv kw it bd kx ky kz la lb lc ld le lf jz lg ka lh kc li kd lj kf lk kg ll lm bi translated"><strong class="ak">验证型号</strong></h1><p id="15a0" class="pw-post-body-paragraph mk ml it lp b lq lr ju mm ls lt jx mn lu mo mp mq lw mr ms mt ly mu mv mw ma im bi translated">此时，我们已经在Vertex AI上训练了一个模型，并将其保存到Google云存储中。在结束本文之前，还有最后一件事——让我们评估一下JupyterLab中的模式。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ng nh l"/></div><p class="kq kr gj gh gi ks kt bd b be z dk translated">最终模型评估</p></figure><p id="63cd" class="pw-post-body-paragraph mk ml it lp b lq mx ju mm ls my jx mn lu mz mp mq lw na ms mt ly nb mv mw ma im bi translated">我们可以看到，准确率从60%(在本地用5个历元训练)提高到66%(在Vertex AI上用15个历元训练)。</p><h1 id="0c20" class="kv kw it bd kx ky kz la lb lc ld le lf jz lg ka lh kc li kd lj kf lk kg ll lm bi translated"><strong class="ak">包装</strong></h1><p id="0a8f" class="pw-post-body-paragraph mk ml it lp b lq lr ju mm ls lt jx mn lu mo mp mq lw mr ms mt ly mu mv mw ma im bi translated">这是一个端到端顶点AI教程系列的第一篇文章的结尾。如果你创建了Vertex AI笔记本，记得清理你的谷歌云资源。庞大的虚拟机可能非常昂贵。我将在未来发布更多内容来演示该平台的其他方面。再见，下次见。</p></div></div>    
</body>
</html>