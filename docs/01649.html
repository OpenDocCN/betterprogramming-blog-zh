<html>
<head>
<title>Understanding Big-O Notation With JavaScript</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">用JavaScript理解Big-O符号</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/understanding-big-o-notation-c3245b8112dc?source=collection_archive---------9-----------------------#2019-10-01">https://betterprogramming.pub/understanding-big-o-notation-c3245b8112dc?source=collection_archive---------9-----------------------#2019-10-01</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="7cc5" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">衡量算法最坏情况的复杂性</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/3a980395cc79113555da9f5ef99c35d1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Wbb8NxbZgqwGAHvviyKozg.jpeg"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">艾莉娜·格鲁布尼亚克在<a class="ae ky" href="https://unsplash.com/s/photos/network?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的照片</p></figure><p id="09ab" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">Big-O符号衡量算法的最坏情况复杂度。在Big-O符号中，<em class="lv"> n </em>代表输入的数量。用Big-O问的问题是这样的:“当n接近无穷大时会发生什么？”</p><p id="0470" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">下图显示了一些常见的Big-O符号:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi lw"><img src="../Images/b0dbe110505aec19563a8965454b2ba7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*iQkFjNn02oogc2Yv27-pyQ.png"/></div></div></figure><p id="2b2d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">O(1)相对于输入空间不变。因此，O(1)被称为常数时间。一个O(1)的例子:</p><pre class="kj kk kl km gt lx ly lz ma aw mb bi"><span id="877c" class="mc md it ly b gy me mf l mg mh">function exampleConstantFunc(n) {<br/>    return n*n;<br/>}</span></pre><p id="b0a2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">O(n)是<em class="lv">线性</em>时间，适用于在最坏情况下必须进行<em class="lv"> n </em>运算的算法。这是一个简单的基本循环，在这个循环中，我们执行恒定时间的操作。O(n)的一个例子:</p><pre class="kj kk kl km gt lx ly lz ma aw mb bi"><span id="6bb5" class="mc md it ly b gy me mf l mg mh">function exampleLinear(n) {<br/>    for (var i = 0 ; i &lt; n; i++ ) {<br/>        console.log(i)<br/>    }<br/>}</span></pre><p id="60ed" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">对数时间函数是指执行时间与输入大小的对数成正比的函数。考虑下面的例子:</p><pre class="kj kk kl km gt lx ly lz ma aw mb bi"><span id="dbe5" class="mc md it ly b gy me mf l mg mh">function log(n) {<br/>    for (let i = 1; i &gt; n; i*=2) {<br/>        const result = i;<br/>        console.log(result);  <br/>    }<br/>}</span></pre><p id="fd2f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们可以看到，在任何给定的迭代中，I的值= 2i，所以在第n次迭代中，I的值= 2n。同样，我们知道I的值总是小于循环本身的大小(N)。由此，我们可以推出以下结果:2[^n]&lt; n log(2[^n])&lt; log(n)n &lt; log(n)</p><p id="38bf" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">从前面的代码中，我们可以看到迭代次数总是小于输入大小的对数。因此，这种算法的最坏情况时间复杂度是O(log(n))。对数时间复杂性的效率在大量输入(如一百万项)的情况下是显而易见的。</p><p id="4be5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">对于二次时间算法，我们已经进入了时间复杂性的黑暗面。顾名思义，输入的大小直接影响算法的运行时间。一个常见的例子是嵌套循环:</p><pre class="kj kk kl km gt lx ly lz ma aw mb bi"><span id="3369" class="mc md it ly b gy me mf l mg mh">for (int i = 0; i &lt;n; i += c) {<br/>    for (int j = 0; j &lt; n; j += c) {<br/>    // some O(1) expressions<br/>    }<br/>}</span></pre><p id="a3a0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">从前面的例子中可以看出，对于i = 0，内部循环运行n次，对于i = 1和i = 2也是如此，依此类推。内部循环总是运行n次，并且不依赖于n的值，因此使得算法的时间复杂度为O(n 2)。</p></div><div class="ab cl mi mj hx mk" role="separator"><span class="ml bw bk mm mn mo"/><span class="ml bw bk mm mn mo"/><span class="ml bw bk mm mn"/></div><div class="im in io ip iq"><h1 id="0557" class="mp md it bd mq mr ms mt mu mv mw mx my jz mz ka na kc nb kd nc kf nd kg ne nf bi translated">多项式时间(O(n^n))</h1><p id="5f18" class="pw-post-body-paragraph kz la it lb b lc ng ju le lf nh jx lh li ni lk ll lm nj lo lp lq nk ls lt lu im bi translated">多项式时间复杂度是算法的运行时间复杂度，运行到n ^ k的量级，二次时间算法是某些类型的多项式时间算法，其中k = 2。下面是这种算法的一个简单例子:</p><pre class="kj kk kl km gt lx ly lz ma aw mb bi"><span id="3570" class="mc md it ly b gy me mf l mg mh">for (int i = 0; i &lt;n; i += c) {<br/>    for (int j = 0; j &lt; n; j += c) {<br/>        for (int k = 0; k &lt; n; k += c) {<br/>            // some O(1) expressions<br/>        }<br/>    }<br/>}</span></pre><p id="1993" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">正如您所看到的，这个例子只是二次时间部分中的例子的扩展。这个案子最复杂的是O(n^3).</p><p id="5cde" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们把一个算法的复杂度表示为f(n)。n表示输入的数量，f(n)time表示需要的时间，f(n)space表示算法需要的空间(额外的内存)。算法分析的目标是通过计算f(n)来了解算法的效率。然而，计算f(n)可能具有挑战性。Big-O符号提供了帮助开发人员计算f(n)的基本规则。</p></div><div class="ab cl mi mj hx mk" role="separator"><span class="ml bw bk mm mn mo"/><span class="ml bw bk mm mn mo"/><span class="ml bw bk mm mn"/></div><div class="im in io ip iq"><h1 id="cfa6" class="mp md it bd mq mr ms mt mu mv mw mx my jz mz ka na kc nb kd nc kf nd kg ne nf bi translated">系数法则:去掉常数</h1><p id="8c2f" class="pw-post-body-paragraph kz la it lb b lc ng ju le lf nh jx lh li ni lk ll lm nj lo lp lq nk ls lt lu im bi translated">我们先来回顾一下系数法则——最容易理解的法则。它只需要您忽略任何与输入大小无关的常量。输入大时，Big-O中的系数可以忽略不计。因此，这是Big-O记数法最重要的规则。</p><p id="f685" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><em class="lv">若f(n)为O(g(n))，则kf(n)为O(g(n))，对于任意常数k &gt; 0。</em></p><p id="02ed" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这意味着5f(n)和f(n)都有相同的O(f(n))的大O符号。以下是一个时间复杂度为O(n)的代码块示例:</p><pre class="kj kk kl km gt lx ly lz ma aw mb bi"><span id="1020" class="mc md it ly b gy me mf l mg mh">function a(n){<br/>    var count =0;<br/>    for (var i=0;i&lt;n;i++){<br/>        count+=1;<br/>    }<br/>    return count;<br/>}</span></pre><p id="aa82" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这段代码的f(n) = n。这是因为它增加了n次计数。因此，该函数的时间复杂度为O(n ):</p><pre class="kj kk kl km gt lx ly lz ma aw mb bi"><span id="bf64" class="mc md it ly b gy me mf l mg mh">function a(n){<br/>    var count =0;<br/>    for (var i=0;i&lt;5*n;i++){<br/>        count+=1;<br/>    }<br/>    return count;<br/>}</span></pre><p id="c96c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这个块有f(n) = 5n。这是因为它从0运行到5n。然而，前两个例子都有O(n)的大O符号。简单来说，这是因为如果n接近无穷大或者另一个大数，那四个额外的运算就没有意义了。它会执行n次。任何常数在Big-O符号中都是可以忽略的。</p></div><div class="ab cl mi mj hx mk" role="separator"><span class="ml bw bk mm mn mo"/><span class="ml bw bk mm mn mo"/><span class="ml bw bk mm mn"/></div><div class="im in io ip iq"><h1 id="f59e" class="mp md it bd mq mr ms mt mu mv mw mx my jz mz ka na kc nb kd nc kf nd kg ne nf bi translated">求和规则:将大0相加</h1><p id="bf58" class="pw-post-body-paragraph kz la it lb b lc ng ju le lf nh jx lh li ni lk ll lm nj lo lp lq nk ls lt lu im bi translated">求和规则很容易理解——可以增加时间复杂度。想象一个包含两个其他算法的主算法——该主算法的Big-O符号就是其他两个Big-O符号的总和。</p><p id="8557" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><em class="lv">若f(n)为O(h(n))，g(n)为O(p(n))，则f(n)+g(n)为O(h(n)+p(n))。</em></p><p id="7460" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在应用了这个规则之后，记住应用系数规则是很重要的。下面的代码块演示了一个带有两个主循环的函数，这两个循环的时间复杂度必须单独考虑，然后求和:</p><pre class="kj kk kl km gt lx ly lz ma aw mb bi"><span id="3a4e" class="mc md it ly b gy me mf l mg mh">function a(n){<br/>    var count =0;<br/>    for (var i=0; i&lt;n; i++){<br/>        count+=1;<br/>    }<br/>    for (var i=0; i&lt;5*n; i++){<br/>        count+=1;<br/>    }<br/>    return count;<br/>}</span></pre><p id="8b60" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在本例中，第4行的f(n) = n，第7行的f(n) = 5n。这导致6n。但是，当应用系数规则时，最终结果是O(n) = n。</p></div><div class="ab cl mi mj hx mk" role="separator"><span class="ml bw bk mm mn mo"/><span class="ml bw bk mm mn mo"/><span class="ml bw bk mm mn"/></div><div class="im in io ip iq"><h1 id="834a" class="mp md it bd mq mr ms mt mu mv mw mx my jz mz ka na kc nb kd nc kf nd kg ne nf bi translated">产品规则:乘以大操作系统</h1><p id="020b" class="pw-post-body-paragraph kz la it lb b lc ng ju le lf nh jx lh li ni lk ll lm nj lo lp lq nk ls lt lu im bi translated">乘积法则简单地说明了Big-Os可以相乘到什么程度。</p><p id="c5d7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><em class="lv">若f(n)为O(h(n))，g(n)为O(p(n))，则f(n)g(n)为O(h(n)p(n))。</em></p><p id="200b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">下面的代码块演示了一个具有两个嵌套for循环的函数，对这两个循环应用了乘积规则:</p><pre class="kj kk kl km gt lx ly lz ma aw mb bi"><span id="72c4" class="mc md it ly b gy me mf l mg mh">function (n){<br/>    var count =0;<br/>    for (var i=0; i&lt;n; i++){<br/>        count+=1;<br/>        for (var i=0; i&lt;5*n; i++){<br/>            count+=1;<br/>        }<br/>    }<br/>    return count;<br/>}</span></pre><p id="9143" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在这个例子中，f(n) = 5n*n，因为第7行运行5n次，总共n次迭代。因此，这导致了5n^2操作的总数。应用系数法则，结果是O(n)=n^2</p></div><div class="ab cl mi mj hx mk" role="separator"><span class="ml bw bk mm mn mo"/><span class="ml bw bk mm mn mo"/><span class="ml bw bk mm mn"/></div><div class="im in io ip iq"><h1 id="b1a2" class="mp md it bd mq mr ms mt mu mv mw mx my jz mz ka na kc nb kd nc kf nd kg ne nf bi translated">多项式法则:大到k的幂</h1><p id="d5dc" class="pw-post-body-paragraph kz la it lb b lc ng ju le lf nh jx lh li ni lk ll lm nj lo lp lq nk ls lt lu im bi translated">多项式规则表明，多项式时间复杂性具有相同多项式次数的Big-O符号。数学上，它如下:</p><p id="eb65" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果f(n)是k次多项式，那么f(n)是O(n^k).下面的代码块只有一个二次时间复杂度的for循环:</p><pre class="kj kk kl km gt lx ly lz ma aw mb bi"><span id="574a" class="mc md it ly b gy me mf l mg mh">function a(n){<br/><br/>    var count =0;<br/><br/>    for (var i=0; i&lt;n*n; i++){<br/>        count+=1;<br/>    }<br/>    return count;<br/>}</span></pre><p id="faba" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在这个例子中，f(n) = n^2，因为第4行运行n*n次迭代。</p><p id="9519" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">既然我们已经开始了这个对话，到目前为止，我们在这里讨论的大多数时间复杂性类型都是O(n^k类型的。例如，对于n = 1，它是恒定的时间复杂度，而对于k = 2，它是二次复杂度。多项式时间复杂性的概念将我们引入一类问题，这类问题是根据其解的复杂性来定义的。</p><p id="d0c6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这些是类的类型:</p><ul class=""><li id="2041" class="nl nm it lb b lc ld lf lg li nn lm no lq np lu nq nr ns nt bi translated"><strong class="lb iu"> P </strong>:多项式时间O(n^k).可以解决的任何问题</li><li id="0787" class="nl nm it lb b lc nu lf nv li nw lm nx lq ny lu nq nr ns nt bi translated"><strong class="lb iu"> NP </strong>:任何可以在多项式时间内验证的问题。可能存在可以在非确定性多项式时间内解决的问题(例如数独求解)。如果这些问题的解可以在多项式时间内得到验证，那么这个问题就被归为NP类问题。NP类问题是P类问题的超集。</li><li id="22c1" class="nl nm it lb b lc nu lf nv li nw lm nx lq ny lu nq nr ns nt bi translated"><strong class="lb iu">NP-完全</strong>:任何一个NP问题，只要能在多项式时间内化简为另一个NP问题的函数，都可以归为NP-完全问题。这意味着，如果我们知道某个NP问题的解，那么可以在多项式时间内导出另一个NP问题的解。</li><li id="4438" class="nl nm it lb b lc nu lf nv li nw lm nx lq ny lu nq nr ns nt bi translated"><strong class="lb iu"> NP-Hard </strong>:如果存在一个NP-完全问题，可以在多项式时间内化简为H，那么这个问题可以归为NP-Hard问题(H)。</li></ul><p id="9747" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><em class="lv">在大多数现实世界场景中，我们会遇到很多P和NP问题，NP类问题的一个经典例子是旅行推销员，其中一名推销员想访问n个城市，从他的房子开始和结束他的旅行。在汽油量有限且总行驶里程有上限的情况下，销售人员能在不耗尽汽油的情况下走遍所有城市吗？</em></p><p id="d535" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">到目前为止，我们已经看到了一些非常简单的例子:它们都有一个单独的循环或者嵌套循环。然而，经常会有这样的情况，我们必须处理来自同一个算法的多个循环/函数调用/分支。让我们看一个例子，在这种情况下，我们如何计算复杂性。</p><p id="0267" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这种代码的总体复杂性是这两部分复杂性的总和。因此，在这种情况下，总的复杂性将是O(n + log n)，它渐近地将是O(n)。</p><p id="ef69" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这里，最坏情况的复杂度将由两个分支中最差的一个决定，即O(n)，但是最好情况的复杂度将是O(log(n))。</p><p id="8a4f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">虽然我们的方法只执行一些O(1)运算，但它不断地改变输入并调用自己，直到输入数组的大小为零。因此，我们的方法最终执行了n次，总时间复杂度为O(n)。</p></div></div>    
</body>
</html>