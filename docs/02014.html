<html>
<head>
<title>Building HIPAA Compliant End-to-End Encrypted Chat</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">构建符合HIPAA的端到端加密聊天</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/building-hipaa-compliant-end-to-end-encrypted-chat-with-stream-react-chat-and-virgil-security-6c3c35f0664d?source=collection_archive---------14-----------------------#2019-10-30">https://betterprogramming.pub/building-hipaa-compliant-end-to-end-encrypted-chat-with-stream-react-chat-and-virgil-security-6c3c35f0664d?source=collection_archive---------14-----------------------#2019-10-30</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="ac1a" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">与Stream React聊天和维吉尔安全</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/74b9c428051309d34e5ba78d763a2279.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*PlmhSRVENS2h2e6LEBl6Ew.png"/></div></div></figure><p id="bc5d" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">随着医疗保健技术的进步，安全的实时通信对任何现代医疗保健应用都变得至关重要。在保护患者隐私和医疗保健数据的同时，提供患者期望的技术体验至关重要。聊天消息通常包含受保护的健康信息(PHI)，因此在构建聊天时，您必须考虑端到端加密。</p><p id="a496" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">在本教程中，我们将介绍如何使用<a class="ae lq" href="https://getstream.io/chat/" rel="noopener ugc nofollow" target="_blank"> Stream Chat </a>结合<a class="ae lq" href="https://virgilsecurity.com/end-to-end-encrypted-chat" rel="noopener ugc nofollow" target="_blank"> Virgil Security </a>创建完整的端到端加密聊天解决方案。这两项服务允许开发人员通过保护PHI和患者通信来集成符合HIPAA的聊天。该应用嵌入了Virgil Security的<a class="ae lq" href="https://github.com/VirgilSecurity/virgil-e3kit-js" rel="noopener ugc nofollow" target="_blank"> eThree Kit </a>和<a class="ae lq" href="https://github.com/GetStream/stream-chat-react" rel="noopener ugc nofollow" target="_blank"> Stream Chat React </a>的组件。该应用的所有源代码都可以在<a class="ae lq" href="https://github.com/psylinse/stream-encrypted-chat" rel="noopener ugc nofollow" target="_blank"> GitHub </a>上获得。</p><p id="58f9" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">Stream Chat和Virgil可以轻松构建一个具有出色安全性和所有预期功能的解决方案。</p></div><div class="ab cl lr ls hx lt" role="separator"><span class="lu bw bk lv lw lx"/><span class="lu bw bk lv lw lx"/><span class="lu bw bk lv lw"/></div><div class="im in io ip iq"><h1 id="0a52" class="ly lz it bd ma mb mc md me mf mg mh mi jz mj ka mk kc ml kd mm kf mn kg mo mp bi translated">什么是端到端加密？</h1><p id="313a" class="pw-post-body-paragraph ku kv it kw b kx mq ju kz la mr jx lc ld ms lf lg lh mt lj lk ll mu ln lo lp im bi translated">端到端加密意味着两个人之间发送的消息只能被那两个人读取。为此，消息在离开用户设备之前被加密，并且只能由预定的接收者解密。</p><p id="40b4" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">Virgil Security是一家供应商，它使我们能够使用公钥/私钥技术创建端到端加密。Virgil提供了一个平台和一个JavaScript SDK，使我们能够创建、存储和提供健壮的端到端安全加密。</p><p id="bc28" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">在本教程中，我们将创建一个流聊天应用程序，它使用Virgil的加密技术来防止除预定方之外的任何人阅读消息。您公司中的任何人，或者您使用的任何云提供商，都无法阅读这些消息。即使一个恶意的人获得了包含消息的数据库的访问权，他们所看到的也只是加密的文本，即所谓的密文。</p></div><div class="ab cl lr ls hx lt" role="separator"><span class="lu bw bk lv lw lx"/><span class="lu bw bk lv lw lx"/><span class="lu bw bk lv lw"/></div><div class="im in io ip iq"><h1 id="fad0" class="ly lz it bd ma mb mc md me mf mg mh mi jz mj ka mk kc ml kd mm kf mn kg mo mp bi translated">让我们使用React构建一个符合HIPAA的聊天应用程序！</h1><p id="454c" class="pw-post-body-paragraph ku kv it kw b kx mq ju kz la mr jx lc ld ms lf lg lh mt lj lk ll mu ln lo lp im bi translated">为了构建这个应用程序，我们将依赖三个库，<br/> <a class="ae lq" href="https://www.npmjs.com/package/stream-chat-react" rel="noopener ugc nofollow" target="_blank"> Stream React Chat </a>，<a class="ae lq" href="https://www.npmjs.com/package/virgil-sdk" rel="noopener ugc nofollow" target="_blank"> Virgil SDK </a>和<a class="ae lq" href="https://www.npmjs.com/package/virgil-crypto" rel="noopener ugc nofollow" target="_blank"> Virgil Crypto </a>。我们的最终产品将在发送消息之前在浏览器中加密文本。解密和验证都将在接收者的浏览器中进行。</p><p id="9e74" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">为此，该应用程序执行以下步骤:</p><ul class=""><li id="7409" class="mv mw it kw b kx ky la lb ld mx lh my ll mz lp na nb nc nd bi translated">用户通过您的后端进行身份验证。</li><li id="a21b" class="mv mw it kw b kx ne la nf ld ng lh nh ll ni lp na nb nc nd bi translated">用户的应用程序从后端请求流身份验证令牌和API密钥。浏览器为该用户创建一个<a class="ae lq" href="https://getstream.io/chat/docs/#init_and_users" rel="noopener ugc nofollow" target="_blank">流聊天客户端</a>。</li></ul><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/74b9c428051309d34e5ba78d763a2279.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*PlmhSRVENS2h2e6LEBl6Ew.png"/></div></div></figure><ul class=""><li id="b59d" class="mv mw it kw b kx ky la lb ld mx lh my ll mz lp na nb nc nd bi translated">用户的应用程序从后端请求一个Virgil身份验证令牌，并向Virgil注册。这将生成他们的私钥和公钥。私钥存储在本地，公钥存储在Virgil中。</li><li id="fb9c" class="mv mw it kw b kx ne la nf ld ng lh nh ll ni lp na nb nc nd bi translated">一旦用户决定了他们想和谁聊天，应用程序就会创建并加入一个<a class="ae lq" href="https://getstream.io/chat/docs/#initialize_channel" rel="noopener ugc nofollow" target="_blank">流聊天频道</a>。</li><li id="cf7c" class="mv mw it kw b kx ne la nf ld ng lh nh ll ni lp na nb nc nd bi translated">该应用程序向Virgil索要接收者的公钥。</li><li id="1095" class="mv mw it kw b kx ne la nf ld ng lh nh ll ni lp na nb nc nd bi translated">用户键入一条消息并将其发送到stream。在发送之前，该应用程序将接收者的公钥传递给Virgil以加密消息。消息通过Stream Chat传递给接收者。流接收密文，这意味着他们永远看不到原始消息。</li><li id="bd2e" class="mv mw it kw b kx ne la nf ld ng lh nh ll ni lp na nb nc nd bi translated">接收用户使用Virgil解密发送的消息。当收到消息时，应用程序用Virgil解密消息，并将它传递给Stream的React组件。Virgil使用发送者的公钥验证消息的真实性。</li></ul><p id="a8d0" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">这看起来令人生畏，但幸运的是Stream和Virgil为我们做了繁重的工作。作为使用这些服务的开发人员，我们的责任只是将它们正确地连接在一起。</p><p id="d160" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">代码在包含在<code class="fe nj nk nl nm b">frontend</code>文件夹中的React前端和位于<code class="fe nj nk nl nm b">backend</code>文件夹中的Express (Node.js)后端之间进行分割。查看每个文件夹中的<code class="fe nj nk nl nm b">README.md</code>，查看安装和运行说明。如果您想继续运行代码，请确保在继续之前让<code class="fe nj nk nl nm b">backend</code>和<code class="fe nj nk nl nm b">frontend</code>都运行起来。</p><p id="ab9e" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">让我们走一遍，看看每个步骤所需的重要代码。</p></div><div class="ab cl lr ls hx lt" role="separator"><span class="lu bw bk lv lw lx"/><span class="lu bw bk lv lw lx"/><span class="lu bw bk lv lw"/></div><div class="im in io ip iq"><h1 id="e367" class="ly lz it bd ma mb mc md me mf mg mh mi jz mj ka mk kc ml kd mm kf mn kg mo mp bi translated">先决条件</h1><p id="d9fc" class="pw-post-body-paragraph ku kv it kw b kx mq ju kz la mr jx lc ld ms lf lg lh mt lj lk ll mu ln lo lp im bi translated">遵循本教程需要React和Node.js的基础知识。此代码旨在在您的计算机上本地运行。</p><p id="a473" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">你需要一个<a class="ae lq" href="https://getstream.io/accounts/signup/" rel="noopener ugc nofollow" target="_blank">流</a>和<a class="ae lq" href="https://dashboard.virgilsecurity.com/signup" rel="noopener ugc nofollow" target="_blank">维吉尔</a>的账户。创建您的帐户，然后将您的凭证放入<code class="fe nj nk nl nm b">backend/.env</code>。使用<code class="fe nj nk nl nm b">backend/.env.example</code>作为需要凭证的参考。</p><p id="e4dd" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">本教程使用以下软件包版本:</p><ul class=""><li id="f417" class="mv mw it kw b kx ky la lb ld mx lh my ll mz lp na nb nc nd bi translated">节点11.14.0</li><li id="1b9c" class="mv mw it kw b kx ne la nf ld ng lh nh ll ni lp na nb nc nd bi translated">纱线1.17.0</li><li id="1055" class="mv mw it kw b kx ne la nf ld ng lh nh ll ni lp na nb nc nd bi translated">流聊天0.13.3</li><li id="5327" class="mv mw it kw b kx ne la nf ld ng lh nh ll ni lp na nb nc nd bi translated">流聊天反应0.6.26</li><li id="380a" class="mv mw it kw b kx ne la nf ld ng lh nh ll ni lp na nb nc nd bi translated">维吉尔加密3.2.0</li><li id="85b4" class="mv mw it kw b kx ne la nf ld ng lh nh ll ni lp na nb nc nd bi translated">Virgil SDK 5.3.0</li><li id="faf1" class="mv mw it kw b kx ne la nf ld ng lh nh ll ni lp na nb nc nd bi translated">Virgil e3Kit 0.5.3</li><li id="839d" class="mv mw it kw b kx ne la nf ld ng lh nh ll ni lp na nb nc nd bi translated">快递4.17.1</li></ul><p id="9ca2" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">除了<code class="fe nj nk nl nm b">node</code>和<code class="fe nj nk nl nm b">yarn</code>之外，所有这些依赖项都在<code class="fe nj nk nl nm b">backend/package.json</code>和<code class="fe nj nk nl nm b">frontend/package.json</code>中声明。</p></div><div class="ab cl lr ls hx lt" role="separator"><span class="lu bw bk lv lw lx"/><span class="lu bw bk lv lw lx"/><span class="lu bw bk lv lw"/></div><div class="im in io ip iq"><h1 id="1494" class="ly lz it bd ma mb mc md me mf mg mh mi jz mj ka mk kc ml kd mm kf mn kg mo mp bi translated">第一步。设置后端</h1><p id="1480" class="pw-post-body-paragraph ku kv it kw b kx mq ju kz la mr jx lc ld ms lf lg lh mt lj lk ll mu ln lo lp im bi translated">为了让React前端与Stream和Virgil交互，<br/>应用程序提供了三个端点:</p><ul class=""><li id="1e1b" class="mv mw it kw b kx ky la lb ld mx lh my ll mz lp na nb nc nd bi translated"><code class="fe nj nk nl nm b">POST /v1/authenticate</code>:这个端点生成一个auth令牌，允许React前端与<code class="fe nj nk nl nm b">/v1/stream-credentials</code>和<code class="fe nj nk nl nm b">/v1/virgil-credentials</code>通信。为了简单起见，这个端点允许客户机是任何用户。前端告诉后端它想要认证谁。在您的应用程序中，这应该替换为您的API的身份验证端点。</li><li id="bf49" class="mv mw it kw b kx ne la nf ld ng lh nh ll ni lp na nb nc nd bi translated"><code class="fe nj nk nl nm b">POST /v1/stream-credentials</code>:返回React应用程序与Stream建立会话所需的数据。要返回此信息，我们需要告诉Stream此用户存在，并要求他们创建一个有效的auth令牌:</li></ul><pre class="kj kk kl km gt nn nm no np aw nq bi"><span id="b26b" class="nr lz it nm b gy ns nt l nu nv">exports.streamCredentials = async (req, res) =&gt; {<br/>    const data = req.body;<br/>    const apiKey = process.env.STREAM_API_KEY;<br/>    const apiSecret = process.env.STREAM_API_SECRET;<br/><br/>    const client = new StreamChat(apiKey, apiSecret);<br/><br/>    const user = Object.assign({}, data, {<br/>      id: `${req.user.sender}`,<br/>      role: "admin",<br/>      image: `https://robohash.org/${req.user.sender}`<br/>    });<br/>    const token = client.createToken(user.id);<br/>    await client.updateUsers([user]);<br/>    res.status(200).json({ user, token, apiKey });<br/>  };</span></pre><p id="3c25" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">响应负载的形状如下:</p><pre class="kj kk kl km gt nn nm no np aw nq bi"><span id="bdc2" class="nr lz it nm b gy ns nt l nu nv">{<br/>    "apiKey": "&lt;string&gt;",<br/>    "token": "&lt;string&gt;",<br/>    "user": {<br/>      "id": "&lt;string&gt;",<br/>      "role": "&lt;string&gt;",<br/>      "image": "&lt;string&gt;"<br/>    }<br/>  }</span></pre><ul class=""><li id="c1e3" class="mv mw it kw b kx ky la lb ld mx lh my ll mz lp na nb nc nd bi translated"><code class="fe nj nk nl nm b">apiKey</code>是您的流实例的流帐户标识符。需要它来识别您的前端试图连接的帐户。</li><li id="4dd7" class="mv mw it kw b kx ne la nf ld ng lh nh ll ni lp na nb nc nd bi translated"><code class="fe nj nk nl nm b">token</code> : JWT令牌，授权前端使用流。</li><li id="73e6" class="mv mw it kw b kx ne la nf ld ng lh nh ll ni lp na nb nc nd bi translated"><code class="fe nj nk nl nm b">user</code>:这个对象包含了前端需要连接和渲染用户视图的数据。</li></ul><pre class="kj kk kl km gt nn nm no np aw nq bi"><span id="7c44" class="nr lz it nm b gy ns nt l nu nv">const virgilCrypto = new VirgilCrypto();<br/><br/>const generator = new JwtGenerator({<br/>  appId: process.env.VIRGIL_APP_ID,<br/>  apiKeyId: process.env.VIRGIL_KEY_ID,<br/>  apiKey: virgilCrypto.importPrivateKey(process.env.VIRGIL_PRIVATE_KEY),<br/>  accessTokenSigner: new VirgilAccessTokenSigner(virgilCrypto)<br/>});<br/><br/>exports.virgilCredentials = async (req, res) =&gt; {<br/>  const virgilJwtToken = generator.generateToken(req.user.sender);<br/><br/>  res.json({ token: virgilJwtToken.toString() });<br/>};</span></pre><p id="46f3" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">在这种情况下，前端只需要auth令牌。</p></div><div class="ab cl lr ls hx lt" role="separator"><span class="lu bw bk lv lw lx"/><span class="lu bw bk lv lw lx"/><span class="lu bw bk lv lw"/></div><div class="im in io ip iq"><h1 id="5275" class="ly lz it bd ma mb mc md me mf mg mh mi jz mj ka mk kc ml kd mm kf mn kg mo mp bi translated">第二步。用户通过后端验证</h1><p id="d04b" class="pw-post-body-paragraph ku kv it kw b kx mq ju kz la mr jx lc ld ms lf lg lh mt lj lk ll mu ln lo lp im bi translated">既然我们已经设置并运行了我们的后端，是时候对后端进行认证了。如果您正在运行该应用程序，您将看到以下屏幕:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nw"><img src="../Images/c17833fb0b746ef14e87ee2a172bea59.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*fmJ56Bw_7iijZigb"/></div></div></figure><p id="c40e" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">这是一个简单的React表单，它接受所提供的输入，将其存储在状态中作为<code class="fe nj nk nl nm b">sender</code>，并使用该信息对后端进行身份验证:</p><pre class="kj kk kl km gt nn nm no np aw nq bi"><span id="b24b" class="nr lz it nm b gy ns nt l nu nv">exports.streamCredentials = async (req, res) =&gt; {<br/>    const data = req.body;<br/>    const apiKey = process.env.STREAM_API_KEY;<br/>    const apiSecret = process.env.STREAM_API_SECRET;<br/><br/>    const client = new StreamChat(apiKey, apiSecret);<br/><br/>    const user = Object.assign({}, data, {<br/>      id: `${req.user.sender}`,<br/>      role: "admin",<br/>      image: `https://robohash.org/${req.user.sender}`<br/>    });<br/>    const token = client.createToken(user.id);<br/>    await client.updateUsers([user]);<br/>    res.status(200).json({ user, token, apiKey });<br/>  };</span></pre><p id="f2b1" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">一旦我们用auth令牌创建了发送者身份，我们就可以连接到Stream和Virgil。</p></div><div class="ab cl lr ls hx lt" role="separator"><span class="lu bw bk lv lw lx"/><span class="lu bw bk lv lw lx"/><span class="lu bw bk lv lw"/></div><div class="im in io ip iq"><h1 id="c8fc" class="ly lz it bd ma mb mc md me mf mg mh mi jz mj ka mk kc ml kd mm kf mn kg mo mp bi translated">第二步。用户连接到流</h1><p id="27db" class="pw-post-body-paragraph ku kv it kw b kx mq ju kz la mr jx lc ld ms lf lg lh mt lj lk ll mu ln lo lp im bi translated">使用来自<a class="ae lq" href="https://getstream.io/blog/hipaa-chat/#step-1-user-authenticates-with-backend" rel="noopener ugc nofollow" target="_blank">步骤1 </a>的凭证，我们可以从后端请求流凭证。使用这些，我们将前端客户端连接到流:</p><pre class="kj kk kl km gt nn nm no np aw nq bi"><span id="c1b3" class="nr lz it nm b gy ns nt l nu nv">{<br/>    "apiKey": "&lt;string&gt;",<br/>    "token": "&lt;string&gt;",<br/>    "user": {<br/>      "id": "&lt;string&gt;",<br/>      "role": "&lt;string&gt;",<br/>      "image": "&lt;string&gt;"<br/>    }<br/>  }</span></pre><p id="d0d8" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">这将从<code class="fe nj nk nl nm b">Stream Chat React</code>库中初始化<code class="fe nj nk nl nm b">StreamChat</code>对象，并使用后端生成的令牌对用户进行身份验证。</p></div><div class="ab cl lr ls hx lt" role="separator"><span class="lu bw bk lv lw lx"/><span class="lu bw bk lv lw lx"/><span class="lu bw bk lv lw"/></div><div class="im in io ip iq"><h1 id="476f" class="ly lz it bd ma mb mc md me mf mg mh mi jz mj ka mk kc ml kd mm kf mn kg mo mp bi translated">第三步。用户连接到Virgil</h1><p id="35e7" class="pw-post-body-paragraph ku kv it kw b kx mq ju kz la mr jx lc ld ms lf lg lh mt lj lk ll mu ln lo lp im bi translated">再次使用在<a class="ae lq" href="https://getstream.io/blog/hipaa-chat/#step-1-user-authenticates-with-backend" rel="noopener ugc nofollow" target="_blank">步骤1 </a>中获得的凭证，我们请求后端生成一个Virgil auth令牌。使用这个令牌，我们从维吉尔的<code class="fe nj nk nl nm b">e3kit</code>库中初始化了<code class="fe nj nk nl nm b">EThree</code>对象:</p><h1 id="2a53" class="ly lz it bd ma mb nx md me mf ny mh mi jz nz ka mk kc oa kd mm kf ob kg mo mp bi translated">第四步。创建流聊天频道</h1><p id="fbb0" class="pw-post-body-paragraph ku kv it kw b kx mq ju kz la mr jx lc ld ms lf lg lh mt lj lk ll mu ln lo lp im bi translated">一旦我们同时连接到Stream和Virgil，我们就可以开始和某人聊天了。点击教程应用程序中的“注册”后，您将看到以下屏幕:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nw"><img src="../Images/0d40b981a4b1d9b67b6d2f116d3231b1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*Ui4yO4LiRaQ5SH5e"/></div></div></figure><p id="be17" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">该表单询问您想与之聊天的用户的身份。如果他们已经在另一个浏览器窗口注册，我们可以创建一个针对这两个成员的流聊天<code class="fe nj nk nl nm b">Channel</code>:</p><pre class="kj kk kl km gt nn nm no np aw nq bi"><span id="a2bf" class="nr lz it nm b gy ns nt l nu nv">let members = [this.state.sender, this.state.receiver];<br/>members.sort();<br/><br/>const channel = this.state.stream.client.channel("messaging", {<br/>  image: `https://getstream.io/random_svg/?id=rapid-recipe-0&amp;name=${members.join(<br/>    "+"<br/>  )}`,<br/>  name: members.join(", "),<br/>  members: members<br/>});</span></pre><p id="2549" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">我们在状态下访问的客户端是在<br/> <a class="ae lq" href="https://getstream.io/blog/hipaa-chat/#step-2-user-connects-to-stream" rel="noopener ugc nofollow" target="_blank">步骤2 </a>中创建的客户端。呼叫<code class="fe nj nk nl nm b">.channel</code>将基于成员的身份创建或加入一个独特的频道。只有那两个成员可以进去。然而，这不足以保护Stream或其他人查看这些用户的消息。</p></div><div class="ab cl lr ls hx lt" role="separator"><span class="lu bw bk lv lw lx"/><span class="lu bw bk lv lw lx"/><span class="lu bw bk lv lw"/></div><div class="im in io ip iq"><h1 id="b7e3" class="ly lz it bd ma mb mc md me mf mg mh mi jz mj ka mk kc ml kd mm kf mn kg mo mp bi translated">第五步。查找Virgil公钥</h1><p id="d4a1" class="pw-post-body-paragraph ku kv it kw b kx mq ju kz la mr jx lc ld ms lf lg lh mt lj lk ll mu ln lo lp im bi translated">为了在通过流通道发送消息之前对其进行加密，我们需要查找接收者的公钥:</p><pre class="kj kk kl km gt nn nm no np aw nq bi"><span id="6c71" class="nr lz it nm b gy ns nt l nu nv">const publicKeys = await this.state.virgil.eThree.lookupPublicKeys([<br/>  this.state.sender,<br/>  this.state.receiver<br/>]);</span></pre><p id="7cc5" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">我们状态中的<code class="fe nj nk nl nm b">eThree</code>实例来自<a class="ae lq" href="https://getstream.io/blog/hipaa-chat/#step-3-user-connects-to-virgil" rel="noopener ugc nofollow" target="_blank">步骤3 </a>。假设发送方的身份是<code class="fe nj nk nl nm b">will</code>，接收方的身份是<code class="fe nj nk nl nm b">sara</code>，这将返回一个如下所示的对象:</p><pre class="kj kk kl km gt nn nm no np aw nq bi"><span id="72b1" class="nr lz it nm b gy ns nt l nu nv">{<br/>  will: {/* Public Key Info */},<br/>  sara: {/* Public Key Info */}<br/>}</span></pre><p id="3095" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">因为我们需要解密收到的我们自己的消息，为了显示和方便，我们同时要求两个公钥。</p></div><div class="ab cl lr ls hx lt" role="separator"><span class="lu bw bk lv lw lx"/><span class="lu bw bk lv lw lx"/><span class="lu bw bk lv lw"/></div><div class="im in io ip iq"><h1 id="0288" class="ly lz it bd ma mb mc md me mf mg mh mi jz mj ka mk kc ml kd mm kf mn kg mo mp bi translated">第六步。发送方加密消息并通过流发送</h1><p id="6bcb" class="pw-post-body-paragraph ku kv it kw b kx mq ju kz la mr jx lc ld ms lf lg lh mt lj lk ll mu ln lo lp im bi translated">我们已经具备了通过Stream发送安全、端到端的加密消息所需的一切，现在是聊天的时候了！</p><p id="c88e" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">首先，我们需要向用户展示聊天室:</p><pre class="kj kk kl km gt nn nm no np aw nq bi"><span id="dc3c" class="nr lz it nm b gy ns nt l nu nv">&lt;Chat client={this.state.stream.client} theme={"messaging light"}&gt;<br/>  &lt;Channel channel={this.state.stream.channel}&gt;<br/>    &lt;Window&gt;<br/>      &lt;ChannelHeader /&gt;<br/>      &lt;MessageList Message={this._buildMessageEncrypted} /&gt;<br/>      &lt;MessageInputEncrypted<br/>        virgil={this.state.virgil}<br/>        channel={this.state.stream.channel}<br/>      /&gt;<br/>    &lt;/Window&gt;<br/>    &lt;Thread /&gt;<br/>  &lt;/Channel&gt;<br/>&lt;/Chat&gt;</span></pre><p id="4d32" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">这呈现了Stream React聊天组件，为我们的用户创建了出色的开箱即用体验。如果你继续看下去，你会看到这个:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nw"><img src="../Images/2603c57ca5dff5b90ee6904d64651c90.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*KWuhakfH0SaoC4t7"/></div></div></figure><p id="d8d0" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">注意我们包含自定义类<code class="fe nj nk nl nm b">MessageInputEncrypted</code>的那一行。该组件使用来自Virgil的发送者公钥来加密，然后在通过流通道发送消息之前包装流React <code class="fe nj nk nl nm b">MessageInput</code>组件:</p><pre class="kj kk kl km gt nn nm no np aw nq bi"><span id="4e5d" class="nr lz it nm b gy ns nt l nu nv">export class MessageInputEncrypted extends PureComponent {<br/>  sendMessageEncrypted = async data =&gt; {<br/>    const encryptedText = await this.props.virgil.eThree.encrypt(<br/>      data.text,<br/>      this.props.virgil.publicKeys<br/>    );<br/>    await this.props.channel.sendMessage({<br/>      ...data,<br/>      text: encryptedText<br/>    });<br/>  };<br/><br/>  render = () =&gt; {<br/>    const newProps = {<br/>      ...this.props,<br/>      sendMessage: this.sendMessageEncrypted<br/>    };<br/><br/>    return &lt;MessageInput {...newProps} /&gt;;<br/>  };<br/>}</span></pre><p id="b15a" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">现在所有流将看到的是密文！</p></div><div class="ab cl lr ls hx lt" role="separator"><span class="lu bw bk lv lw lx"/><span class="lu bw bk lv lw lx"/><span class="lu bw bk lv lw"/></div><div class="im in io ip iq"><h1 id="84de" class="ly lz it bd ma mb mc md me mf mg mh mi jz mj ka mk kc ml kd mm kf mn kg mo mp bi translated">第七步。接收者解密并读取消息</h1><p id="646a" class="pw-post-body-paragraph ku kv it kw b kx mq ju kz la mr jx lc ld ms lf lg lh mt lj lk ll mu ln lo lp im bi translated">最后要做的事情是在接收方解密发送方的消息。假设您已经完成了聊天室设置，您将看到以下内容:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nw"><img src="../Images/2f47198bcff7ad217cc0554907206f25.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*cvFNfNRSrQF-Yv72"/></div></div></figure><p id="06fc" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">为了解密消息，我们遵循与第6步中<a class="ae lq" href="https://getstream.io/blog/hipaa-chat/#step-6-sender-encrypts-message-and-sends-it-via-stream" rel="noopener ugc nofollow" target="_blank">相似的模式。如果你看看我们是如何创建<code class="fe nj nk nl nm b">MessageList</code>的，你会看到一个名为<code class="fe nj nk nl nm b">MessageEncrypted</code>的定制<code class="fe nj nk nl nm b">Message</code>组件:</a></p><pre class="kj kk kl km gt nn nm no np aw nq bi"><span id="52e9" class="nr lz it nm b gy ns nt l nu nv">&lt;MessageList Message={this._buildMessageEncrypted} /&gt;</span></pre><p id="b514" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">由于我们需要提供解密道具来将用于解密的道具添加到我们的自定义<code class="fe nj nk nl nm b">Message</code>组件中，所以我们将它们添加到React流传递的道具中:</p><pre class="kj kk kl km gt nn nm no np aw nq bi"><span id="cc40" class="nr lz it nm b gy ns nt l nu nv">_buildMessageEncrypted = props =&gt; {<br/>  const newProps = {<br/>    ...props,<br/>    sender: this.state.sender,<br/>    receiver: this.state.receiver,<br/>    virgil: this.state.virgil<br/>  };<br/>  return &lt;MessageEncrypted {...newProps} /&gt;;<br/>};</span></pre><p id="7290" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">一旦我们有了我们需要的道具，我们就可以解密每条信息:</p><pre class="kj kk kl km gt nn nm no np aw nq bi"><span id="75a4" class="nr lz it nm b gy ns nt l nu nv">export class MessageEncrypted extends PureComponent {<br/>  _isMounted = false;<br/><br/>  constructor(props) {<br/>    super(props);<br/>    this.state = { decryptedText: null };<br/>  }<br/><br/>  componentDidMount = () =&gt; {<br/>    this._isMounted = true;<br/>    this._decryptText().then(decryptedText =&gt; {<br/>      if (this._isMounted) {<br/>        this.setState({ decryptedText });<br/>      }<br/>    });<br/>  };<br/><br/>  componentWillUnmount = () =&gt; {<br/>    this._isMounted = false;<br/>  };<br/><br/>  _decryptText = async () =&gt; {<br/>    const messageCreator = this.props.isMyMessage(this.props.message)<br/>      ? this.props.sender<br/>      : this.props.receiver;<br/>    return this.props.virgil.eThree.decrypt(<br/>      this.props.message.text,<br/>      this.props.virgil.publicKeys[messageCreator]<br/>    );<br/>  };<br/><br/>  render = () =&gt; {<br/>    const newProps = {<br/>      ...this.props,<br/>      message: {<br/>        ...this.props.message,<br/>        text: this.state.decryptedText || ""<br/>      }<br/>    };<br/><br/>    return &lt;MessageSimple {...newProps} /&gt;;<br/>  };<br/>}</span></pre><p id="a6c6" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">这个类在呈现来自Stream Chat React的<code class="fe nj nk nl nm b">MessageSimple</code>组件之前解密消息。为此，我们首先使用Stream的<code class="fe nj nk nl nm b">.isMyMessage</code>确定消息是否确实是我们的消息。然后我们找到正确的公钥，并要求维吉尔解密。一旦完成，我们就可以将密钥和其余的道具一起传递给流的<code class="fe nj nk nl nm b">MessageSimple</code>组件。</p><p id="0c1a" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated"><code class="fe nj nk nl nm b">_isMounted</code>标志防止在消息被解密后更新组件。如果你滚动得很快，或者页面加载时有很多消息，就会发生这种情况。</p></div><div class="ab cl lr ls hx lt" role="separator"><span class="lu bw bk lv lw lx"/><span class="lu bw bk lv lw lx"/><span class="lu bw bk lv lw"/></div><div class="im in io ip iq"><h1 id="5e08" class="ly lz it bd ma mb mc md me mf mg mh mi jz mj ka mk kc ml kd mm kf mn kg mo mp bi translated">从这里去哪里</h1><p id="3fdd" class="pw-post-body-paragraph ku kv it kw b kx mq ju kz la mr jx lc ld ms lf lg lh mt lj lk ll mu ln lo lp im bi translated">本教程旨在让您尽快上手并运行。因此，您的应用程序可能会缺少一些关键功能。以下是关于如何使用你的应用程序的一些提示:</p><ul class=""><li id="5c97" class="mv mw it kw b kx ky la lb ld mx lh my ll mz lp na nb nc nd bi translated">建立真实用户注册，保护身份注册。本教程简化了注册和检索有效令牌，以便与Stream和Virgil进行交互。</li><li id="d65e" class="mv mw it kw b kx ne la nf ld ng lh nh ll ni lp na nb nc nd bi translated">备份用户的私钥以恢复会话并用于多个设备。使用维吉尔的<code class="fe nj nk nl nm b">eThree.backupPrivateKey(pwd)</code>将安全地存储私钥，以便在任何设备上恢复。</li><li id="ccb6" class="mv mw it kw b kx ne la nf ld ng lh nh ll ni lp na nb nc nd bi translated">集成用户图像和文件上传。这个功能通过CSS隐藏在这个应用程序中。你可以看看如何连接到Stream React Chat的<a class="ae lq" href="https://getstream.github.io/stream-chat-react/#messageinput" rel="noopener ugc nofollow" target="_blank"> MessageInput </a>或者作为一个起点来构建你自己的聊天小部件。</li></ul><h1 id="3683" class="ly lz it bd ma mb nx md me mf ny mh mi jz nz ka mk kc oa kd mm kf ob kg mo mp bi translated">这是一个总结！</h1><p id="2a28" class="pw-post-body-paragraph ku kv it kw b kx mq ju kz la mr jx lc ld ms lf lg lh mt lj lk ll mu ln lo lp im bi translated">我希望你喜欢这个教程。有关流聊天的更多信息，请访问<a class="ae lq" href="https://getstream.io/chat" rel="noopener ugc nofollow" target="_blank">https://getstream.io/chat</a>。关于维吉尔的信息，请访问https://virgilsecurity.com/的<a class="ae lq" href="https://virgilsecurity.com/" rel="noopener ugc nofollow" target="_blank">。</a></p><p id="09d5" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">编码快乐！</p></div></div>    
</body>
</html>