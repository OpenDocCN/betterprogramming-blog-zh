<html>
<head>
<title>A Guide to GitOps Compatible Production-like Kubernetes Cluster</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">GitOps兼容生产类Kubernetes集群指南</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/a-guide-to-gitops-compatible-production-like-kubernetes-cluster-f87404391d8a?source=collection_archive---------10-----------------------#2021-06-09">https://betterprogramming.pub/a-guide-to-gitops-compatible-production-like-kubernetes-cluster-f87404391d8a?source=collection_archive---------10-----------------------#2021-06-09</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="7cfd" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">使用Terraform、Ansible和Kubeadm在AWS上构建自由层Kubernetes集群</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/a0077eb5b04bbdfec5927eea211ede74.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*OxFqPENuVfWAhJpITRi62g.jpeg"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">照片由埃里克·麦克莱恩在<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</p></figure><p id="8304" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在寻找一种简单、廉价、大胆(就像我们图中的朋友)的方式来创建一个类似Kubernetes集群的产品时，我遇到了许多选择。但是没有一个完全符合我的要求。所以，我决定自己来。由于结果相当不错，我正在写它！</p><p id="5bcf" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在本文中，我们将讨论所使用的Terraform和Ansible代码以及先决条件。这是目录结构和文件:</p><pre class="kj kk kl km gt lv lw lx ly aw lz bi"><span id="3dde" class="ma mb it lw b gy mc md l me mf">/<br/>├── terraform<br/>│   ├── main.tf<br/>├── ansible<br/>│   ├── master-playbook.yml<br/>│   ├── node-playbook-yml</span></pre><p id="cc02" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们不会深入讨论Terraform或Ansible，但会保持简单明了。我希望你喜欢它。</p><h1 id="f536" class="mg mb it bd mh mi mj mk ml mm mn mo mp jz mq ka mr kc ms kd mt kf mu kg mv mw bi translated">先决条件</h1><ul class=""><li id="2910" class="mx my it lb b lc mz lf na li nb lm nc lq nd lu ne nf ng nh bi translated">安装了Terraform和Ansible:对于windows用户，我推荐WSL。在我的例子中，我将在Ubuntu中使用WSL。</li><li id="8ad4" class="mx my it lb b lc ni lf nj li nk lm nl lq nm lu ne nf ng nh bi translated">AWS访问具有管理EC2实例权限的密钥。</li><li id="aa70" class="mx my it lb b lc ni lf nj li nk lm nl lq nm lu ne nf ng nh bi translated"><a class="ae ky" href="https://registry.terraform.io/providers/hashicorp/aws/latest/docs#authentication" rel="noopener ugc nofollow" target="_blank">使用AWS Terraform provider </a>配置认证(我将使用环境变量)。</li><li id="324f" class="mx my it lb b lc ni lf nj li nk lm nl lq nm lu ne nf ng nh bi translated">EC2密钥对:为了连接到实例并运行Ansible代码，需要一个预先生成的密钥对。</li><li id="a296" class="mx my it lb b lc ni lf nj li nk lm nl lq nm lu ne nf ng nh bi translated">VPC、子网和安全组:对于本文，我们将使用默认设置，只在安全组上添加一个入站规则，以允许来自VPC之外的连接。</li></ul><h1 id="2ac1" class="mg mb it bd mh mi mj mk ml mm mn mo mp jz mq ka mr kc ms kd mt kf mu kg mv mw bi translated">将（行星）地球化（以适合人类居住）</h1><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nn no l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">地形代码</p></figure><p id="530d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们通过定义后端和声明提供者来开始我们的Terraform代码。在这里，我们将使用一个本地后端，以保持尽可能简单。如果您已经过了初始配置和试验阶段，建议使用远程后端，如AWS S3或Azure blob存储。</p><p id="8a7e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">接下来，我们配置AWS提供程序。这里我们将使用带有<code class="fe np nq nr lw b">AWS_ACCESS_KEY_ID</code>、<code class="fe np nq nr lw b">AWS_SECRET_ACCESS_KEY</code>和<code class="fe np nq nr lw b">AWS_DEFAULT_REGION</code>环境变量的基本AWS提供者配置。</p><p id="6112" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">接下来，对于主节点和工作节点的初始配置，我们声明相关的ec2资源:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nn no l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">地形代码</p></figure><p id="d1da" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这是我们集群的基本设置。我们将旋转两个工作节点，因此有count参数。尽管这些是相似的资源，并且有可能被一起声明，但是我们将使用分离来添加Ansible配置。</p><h2 id="a614" class="ma mb it bd mh ns nt dn ml nu nv dp mp li nw nx mr lm ny nz mt lq oa ob mv oc bi translated">集成Ansible</h2><p id="1cc4" class="pw-post-body-paragraph kz la it lb b lc mz ju le lf na jx lh li od lk ll lm oe lo lp lq of ls lt lu im bi translated">受<a class="ae ky" href="https://www.youtube.com/watch?v=-gKTeT3BgHE" rel="noopener ugc nofollow" target="_blank"> <em class="og"> Ansible和HashiCorp: Better together </em>视频</a>的启发，我决定使用Terraform来管理使用Ansible的集群的配置部分。</p><p id="a6ca" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">为了实现这一点，我们将通过添加以下代码来使用在我们的<code class="fe np nq nr lw b">aws_instance</code>资源中声明的<code class="fe np nq nr lw b">remote-exec</code>和<code class="fe np nq nr lw b">local-exec</code> provisioners:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nn no l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">地形代码</p></figure><p id="59c5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe np nq nr lw b">remote-exec</code>参数试图连接到由<code class="fe np nq nr lw b">self.public_ip</code>属性指定的主机，该属性将是正在创建的<code class="fe np nq nr lw b">aws_instance</code>资源的<code class="fe np nq nr lw b">public_ip</code>属性。一旦连接，它将执行由inline参数指定的命令。我们需要这样做，因为Terraform将实例解释为在实际准备好接收连接和命令之前创建的。这样,<code class="fe np nq nr lw b">remote-exec</code>保证正在创建的ec2实例准备好接收ansible-playbook。</p><p id="de39" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">一旦<code class="fe np nq nr lw b">remote-exec</code> provisioner完成，Terraform就会执行<em class="og"> </em> <code class="fe np nq nr lw b">local-exec</code> provisioner，运行我们的ansible-playbook来配置节点。这就是主节点和工作节点分离派上用场的地方。以下是分别用于主节点和工作节点的命令:</p><pre class="kj kk kl km gt lv lw lx ly aw lz bi"><span id="fc5c" class="ma mb it lw b gy mc md l me mf">ANSIBLE_HOST_KEY_CHECKING=False \<br/>    ansible-playbook \<br/>    -T 300 \<br/>    -i '${self.public_ip},' \<br/>    --extra-vars <br/>      'private_ip=${self.private_ip} \<br/>       hostname=${split(".", self.private_dns)[0]}' \<br/>       public_ip=${self.public_ip} \<br/>    --private-key ~/.ssh/k8s-lab.pem ../ansible/master-playbook.yml</span><span id="f817" class="ma mb it lw b gy oh md l me mf">ANSIBLE_HOST_KEY_CHECKING=False \<br/>    ansible-playbook -T 300 \<br/>    -i '${self.public_ip},' \<br/>    --private-key ~/.ssh/k8s-lab.pem ../ansible/node-playbook.yml</span></pre><p id="986f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">除了我们将为主节点和工作节点使用不同的剧本之外，我们还需要向工作节点资源添加一个<code class="fe np nq nr lw b">depends_on</code>子句。因为我们的剧本将执行join命令，所以我们需要完全完成主节点资源。以下是完整的terraform代码:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nn no l"/></div></figure><h1 id="cf3f" class="mg mb it bd mh mi mj mk ml mm mn mo mp jz mq ka mr kc ms kd mt kf mu kg mv mw bi translated">Ansible</h1><p id="f1d3" class="pw-post-body-paragraph kz la it lb b lc mz ju le lf na jx lh li od lk ll lm oe lo lp lq of ls lt lu im bi translated">Ansible代码基于<a class="ae ky" href="https://kubernetes.io/blog/2019/03/15/kubernetes-setup-using-ansible-and-vagrant/" rel="noopener ugc nofollow" target="_blank">这篇文章</a>做了一些修改——我将介绍最重要的修改。</p><p id="20f8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">第一个是标准化cgroup驱动程序和存储驱动程序配置，根据这个问题的<a class="ae ky" href="https://github.com/kubernetes/kubeadm/issues/1394" rel="noopener ugc nofollow" target="_blank">，通过将以下代码添加到master-playbook.yml和node-playbook.yml:</a></p><pre class="kj kk kl km gt lv lw lx ly aw lz bi"><span id="d670" class="ma mb it lw b gy mc md l me mf">- name: Creating /etc/docker/daemon.json file with optimal configs<br/>  copy:<br/>    dest: "/etc/docker/daemon.json"<br/>    content: |<br/>      {<br/>        "exec-opts": ["native.cgroupdriver=systemd"],<br/>        "log-driver": "json-file",<br/>        "log-opts": {<br/>          "max-size": "100m"<br/>        },<br/>        "storage-driver": "overlay2"<br/>      }</span><span id="35bc" class="ma mb it lw b gy oh md l me mf">- name: Restart docker<br/>  service:<br/>    name: docker<br/>    daemon_reload: yes<br/>    state: restarted</span></pre><p id="6bd5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">第二个是更改<code class="fe np nq nr lw b">kubeadm init</code>命令，这样我们可以使用运行时变量并忽略CPU和内存警告:</p><pre class="kj kk kl km gt lv lw lx ly aw lz bi"><span id="848a" class="ma mb it lw b gy mc md l me mf"># Initialize the cluster with kubeadm<br/>  - name: Initialize the Kubernetes cluster using kubeadm<br/>    command: "{{ item }}"<br/>    with_items:<br/>     - systemctl stop kubelet<br/>     - kubeadm init --apiserver-advertise-address {{ private_ip }} <br/>                    --apiserver-cert-extra-sans {{ public_ip }} <br/>                    --node-name {{ hostname }} <br/>                    --pod-network-cidr=10.244.0.0/16 <br/>                    --ignore-preflight-errors="NumCPU,Mem"</span></pre><p id="c880" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">请注意，我们在主公共ip地址中使用了<code class="fe np nq nr lw b">apiserver-cert-extra-sans</code> <em class="og"> </em>参数，以允许我们从本地机器中使用<code class="fe np nq nr lw b">kubectl</code>。另一个调整是关于<code class="fe np nq nr lw b">pod-network-cidr</code>参数，因为法兰绒是我们选择的网络提供商，它必须被改变(我不能在这个设置上部署Calico)。</p><p id="98cc" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">因此，为了部署法兰绒网络解决方案，我们添加以下代码:</p><pre class="kj kk kl km gt lv lw lx ly aw lz bi"><span id="6f24" class="ma mb it lw b gy mc md l me mf"># Setup networking provider<br/>  - name: Install flannel pod network<br/>    become: false<br/>    command: kubectl apply -f <a class="ae ky" href="https://raw.githubusercontent.com/coreos/flannel/master/Documentation/kube-flannel.yml" rel="noopener ugc nofollow" target="_blank">https://raw.githubusercontent.com/coreos/flannel/master/Documentation/kube-flannel.yml</a></span></pre><p id="3d4b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这是最重要的变化，其他的是用户相关的和apt库相关的，因为操作系统的不同。</p><h2 id="76cf" class="ma mb it bd mh ns nt dn ml nu nv dp mp li nw nx mr lm ny nz mt lq oa ob mv oc bi translated">完全可变码</h2><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nn no l"/></div></figure><h1 id="6e00" class="mg mb it bd mh mi mj mk ml mm mn mo mp jz mq ka mr kc ms kd mt kf mu kg mv mw bi translated">将它投入使用…</h1><p id="ace6" class="pw-post-body-paragraph kz la it lb b lc mz ju le lf na jx lh li od lk ll lm oe lo lp lq of ls lt lu im bi translated">因此，有了代码，我们只需要几个命令来启动我们的集群。在Terraform目录上运行:</p><pre class="kj kk kl km gt lv lw lx ly aw lz bi"><span id="a78e" class="ma mb it lw b gy mc md l me mf">terraform init &amp;&amp; terraform apply</span></pre><p id="167c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">init命令将初始化目录，安装AWS提供程序并设置后端。apply命令将向您显示将要调配的内容并要求确认。</p><p id="44cc" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这样，大约7分钟后(可能会根据您的互联网连接和离您选择的AWS区域服务器的距离而有所不同)，您将拥有一个包含一个主节点和两个工作节点的集群。如果您添加更多的工作节点，它们将被并行配置，因此时间将大致保持不变。</p><p id="4fe8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在您只需要从集群中导出一个<code class="fe np nq nr lw b">kubeconfig</code>到您的本地机器和kubectl away！将下面的代码添加到main.tf中就可以做到这一点。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nn no l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">从集群中获取kubeconfig</p></figure><h1 id="1362" class="mg mb it bd mh mi mj mk ml mm mn mo mp jz mq ka mr kc ms kd mt kf mu kg mv mw bi translated">包扎</h1><p id="c839" class="pw-post-body-paragraph kz la it lb b lc mz ju le lf na jx lh li od lk ll lm oe lo lp lq of ls lt lu im bi translated">本文介绍了使用Terraform、Ansible和Kubeadm构建免费(或非常便宜)的AWS Kubernetes集群的任务。通过这种设置，可以很容易地水平扩展集群，通过使用<code class="fe np nq nr lw b">count</code> <em class="og"> </em>参数添加更多的工作节点，或者垂直扩展集群，选择更健壮的ec2实例类型。肯定有改进的空间，欢迎留下任何意见或建议。</p><p id="2ce9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">你可以在<a class="ae ky" href="https://github.com/rdalbuquerque/declarative-k8s-lab" rel="noopener ugc nofollow" target="_blank"> my GitHub </a>上找到代码。</p><h1 id="d9d8" class="mg mb it bd mh mi mj mk ml mm mn mo mp jz mq ka mr kc ms kd mt kf mu kg mv mw bi translated">放弃</h1><p id="703e" class="pw-post-body-paragraph kz la it lb b lc mz ju le lf na jx lh li od lk ll lm oe lo lp lq of ls lt lu im bi translated">您应该知道，如果您正在处理一个更有意义的项目，无论是哪种形式，用于这个项目的AWS安全组和网络配置都不理想。</p></div></div>    
</body>
</html>