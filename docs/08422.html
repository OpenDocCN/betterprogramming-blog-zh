<html>
<head>
<title>How To Handle Configuration Changes in Android</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何处理Android中的配置更改</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/how-to-handle-configuration-changes-in-android-d8d32430d83e?source=collection_archive---------6-----------------------#2021-04-28">https://betterprogramming.pub/how-to-handle-configuration-changes-in-android-d8d32430d83e?source=collection_archive---------6-----------------------#2021-04-28</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="79fe" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">screenOrientation、onSaveInstanceState、setRetainInstance和ViewModel</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/9058a20fa76cfc660c4e60f4fe7e7031.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*Hej8Ae5s27LJQF0x"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">照片由<a class="ae ky" href="https://unsplash.com/@luferlex?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">卢肯·萨贝拉诺</a>在<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄。</p></figure><p id="7996" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在本文中，您将学习如何处理配置更改，如Android应用程序中的屏幕方向。您将了解五种最常用的解决方案。根据您的需求选择您需要的产品。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="b68d" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">介绍</h1><p id="a55e" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">在Android应用中，用户每次旋转屏幕，键盘可用性等。这就是所谓的配置变更。配置更改基于用户操作在运行时发生。</p><p id="c790" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">当这种变化发生时，像<code class="fe mz na nb nc b">Activities</code>这样的Android组件会被重新创建或重启。Android应用程序中的这种行为是为了适应新的配置变化而实现的。正确处理重启只不过是处理配置更改。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="12e2" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">屏幕方向</h1><p id="e697" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">有些情况下，我们不需要应用程序的某些<code class="fe mz na nb nc b">Activities</code>来采用配置更改，这意味着我们将<code class="fe mz na nb nc b">Activity</code>限制为固定方向(例如，仅使用横向方向播放视频)。</p><p id="8f1b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这是Android中处理配置更改最简单的任务。这里，我们可以使用清单文件中的<code class="fe mz na nb nc b">screenOrientation</code> <em class="nd"> </em>标志，并指定所需的方向类型。开箱即用，Android框架提供了一堆选项，如<code class="fe mz na nb nc b">landscape</code>、<code class="fe mz na nb nc b">portrait</code>、<code class="fe mz na nb nc b">reverseLandscape</code>等等。</p><pre class="kj kk kl km gt ne nc nf ng aw nh bi"><span id="9a4c" class="ni md it nc b gy nj nk l nl nm">&lt;activity android:name=".screens.HomeActivity"<br/>    <strong class="nc iu">android:screenOrientation="portrait"</strong><br/>    android:theme="@style/AppThemeHomeScren"/&gt;</span></pre><p id="1d88" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">要了解更多关于方向类型的信息，请阅读<a class="ae ky" href="https://developer.android.com/guide/topics/manifest/activity-element" rel="noopener ugc nofollow" target="_blank">文档</a>中的<code class="fe mz na nb nc b">screenOrientation</code>部分。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="6f41" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">onSaveInstanceState和<em class="nn"> onRestoreInstanceState </em></h1><p id="e51d" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">如果您的<code class="fe mz na nb nc b">Activity</code>需要重启以适应配置更改，该怎么办？这是我们面临真正挑战的地方。当一个<code class="fe mz na nb nc b">Activity</code>被重新创建时，我们在其中维护的所有状态都将消失。</p><p id="6b59" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这就是<code class="fe mz na nb nc b">onSaveInstanceState</code>和<code class="fe mz na nb nc b">onRestoreInstanceState</code>发挥作用的地方。基于Android版本，<code class="fe mz na nb nc b">onSaveInstanceState</code>在<code class="fe mz na nb nc b">onStop</code> <em class="nd"> </em>方法之前或之后被调用。在这种方法中，我们可以将重要数据以bundle的形式保存。看一下函数语法:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="no np l"/></div></figure><p id="4f61" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果有东西保存在<code class="fe mz na nb nc b">onSaveInstanceState</code>方法中，那么<code class="fe mz na nb nc b">onRestoreInstanceState</code>在<code class="fe mz na nb nc b">onStart</code>方法之后被调用。从<code class="fe mz na nb nc b">onRestoreInstanceState</code>函数中，我们可以通过bundle接收保存的数据:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="no np l"/></div></figure><p id="d05a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这就是我们如何使用<code class="fe mz na nb nc b">onSaveInstanceState</code>和<code class="fe mz na nb nc b">onRestoreInstanceState</code> <strong class="lb iu"> </strong>函数来保存配置变更中的重要数据。当我们使用这个包时，我们也可以使用<code class="fe mz na nb nc b">serialization</code>或<code class="fe mz na nb nc b">Parcelable</code>传递自定义对象。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="4abe" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">setRetainInstance</h1><p id="1e4f" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">使用<code class="fe mz na nb nc b">onSaveInstanceState</code>和<code class="fe mz na nb nc b">onRestoreInstanceState</code> <strong class="lb iu"> </strong>的方法在数据有限的情况下非常有效。但是不建议保存像网络响应这样的大数据集。</p><p id="792c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在现代Android开发中，我们使用<code class="fe mz na nb nc b">Fragments</code>比<code class="fe mz na nb nc b">Activities</code>更频繁。因此，我们需要一种可以在<code class="fe mz na nb nc b">Fragments</code>中保存状态或数据的方法。这就是<code class="fe mz na nb nc b">setRetainInstance</code> <em class="nd"> </em>的用武之地。</p><p id="ec0b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">以下是今天Android面试中一些最重要的问题:</p><ul class=""><li id="049e" class="nq nr it lb b lc ld lf lg li ns lm nt lq nu lu nv nw nx ny bi translated">为什么我们需要使用<code class="fe mz na nb nc b">setRetainInstance</code>？</li><li id="82ec" class="nq nr it lb b lc nz lf oa li ob lm oc lq od lu nv nw nx ny bi translated">如何阻止<code class="fe mz na nb nc b">Fragments</code>重新创建配置变更？</li></ul><p id="ea85" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">通常，当父<code class="fe mz na nb nc b">Activity</code>被重新创建时，嵌套的<code class="fe mz na nb nc b">Fragments</code>也被重新创建。如果我们将<code class="fe mz na nb nc b">setRetainInstance</code> <em class="nd"> </em>设置为<code class="fe mz na nb nc b">true</code>，即使父<code class="fe mz na nb nc b">Activity</code>在配置更改时被重新创建，嵌套的<code class="fe mz na nb nc b">Fragments</code>却没有。</p><p id="8821" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这将保存保存在<code class="fe mz na nb nc b">Fragments</code>中的状态和数据。由于<code class="fe mz na nb nc b">Fragments</code>没有重新创建，我们可以保存<code class="fe mz na nb nc b">DataObjects</code>并在<code class="fe mz na nb nc b">Activity</code>重新启动时使用<code class="fe mz na nb nc b">FragmentManager</code>取回<code class="fe mz na nb nc b">Fragment</code>。在我看来，这种方法是保存大型数据对象的最佳解决方案。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="no np l"/></div></figure></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="0190" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">视图模型</h1><p id="84a4" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">使用<code class="fe mz na nb nc b">Fragments</code>保存数据对象解决了配置更改时管理大型数据集的问题。但是随着<code class="fe mz na nb nc b">ViewModels</code>的引入，它在API 28中被弃用了。</p><p id="560d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe mz na nb nc b">ViewModels</code>专门设计用于跨配置变更和在不同UI组件之间持久化和共享数据。因此，我们在<code class="fe mz na nb nc b">ViewModel</code>中管理数据对象，而不是在<code class="fe mz na nb nc b">Fragments</code>中。</p><p id="efd5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">将数据保存在<code class="fe mz na nb nc b">ViewModel</code>中使其更容易被所有组件访问。我们还可以维护数据的单一真实来源。这里，是<code class="fe mz na nb nc b">ViewModel</code>。</p><p id="f137" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">要了解更多关于<code class="fe mz na nb nc b">ViewModels</code>及其最佳实践的信息，我强烈推荐阅读以下文章:</p><div class="oe of gp gr og oh"><a rel="noopener  ugc nofollow" target="_blank" href="/best-practices-for-using-viewmodels-in-android-e986b25dc78f"><div class="oi ab fo"><div class="oj ab ok cl cj ol"><h2 class="bd iu gy z fp om fr fs on fu fw is bi translated">在Android中使用视图模型的最佳实践</h2><div class="oo l"><h3 class="bd b gy z fp om fr fs on fu fw dk translated">如何正确设置和使用Java和Kotlin视图模型</h3></div><div class="op l"><p class="bd b dl z fp om fr fs on fu fw dk translated">better编程. pub</p></div></div><div class="oq l"><div class="or l os ot ou oq ov ks oh"/></div></div></a></div></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="e121" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">奖金</h1><p id="58fc" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">要了解有关Android高级开发的更多信息，请阅读以下文章:</p><ul class=""><li id="589e" class="nq nr it lb b lc ld lf lg li ns lm nt lq nu lu nv nw nx ny bi translated"><a class="ae ky" href="https://medium.com/better-programming/8-common-mistakes-in-android-development-2edcf5179ec0" rel="noopener">《Android开发中的8个常见错误》</a></li><li id="a824" class="nq nr it lb b lc nz lf oa li ob lm oc lq od lu nv nw nx ny bi translated"><a class="ae ky" href="https://levelup.gitconnected.com/vector-asserts-in-android-f0774ba8bf92" rel="noopener ugc nofollow" target="_blank">“了解如何在Android中创建矢量资产”</a></li><li id="0e4e" class="nq nr it lb b lc nz lf oa li ob lm oc lq od lu nv nw nx ny bi translated"><a class="ae ky" href="https://medium.com/better-programming/how-to-integrate-google-pay-into-your-existing-android-app-d75b269cd623" rel="noopener">“如何将Google Pay集成到您现有的Android应用中”</a></li><li id="c730" class="nq nr it lb b lc nz lf oa li ob lm oc lq od lu nv nw nx ny bi translated"><a class="ae ky" href="https://medium.com/@sgkantamani/android-product-flavors-eb526e35f9f1" rel="noopener">【安卓产品口味】</a></li><li id="c8ff" class="nq nr it lb b lc nz lf oa li ob lm oc lq od lu nv nw nx ny bi translated"><a class="ae ky" href="https://medium.com/android-dev-hacks/implementing-ads-in-your-android-application-28ac676024aa" rel="noopener">“在您的Android应用中实现广告”</a></li></ul><p id="100c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">目前就这些。希望你学到了有用的东西。感谢阅读。</p></div></div>    
</body>
</html>