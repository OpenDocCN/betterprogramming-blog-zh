<html>
<head>
<title>Object Pooling in Unity</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Unity中的对象池</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/object-pooling-in-unity-aac9ccbc5dbd?source=collection_archive---------11-----------------------#2022-08-03">https://betterprogramming.pub/object-pooling-in-unity-aac9ccbc5dbd?source=collection_archive---------11-----------------------#2022-08-03</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="c1e9" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">使用新的Unity Pooling API优化性能</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/44c293da620368964064a5d1ba77c97b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*9GA-fGN6Sq5poOsUULNvMQ.jpeg"/></div></div></figure><p id="abc1" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">在Unity中，我们知道我们可以通过调用<em class="ln"> </em> <code class="fe lo lp lq lr b">Instantiate()</code>从预置创建一个游戏对象的新实例，并在稍后通过调用【惊喜】<code class="fe lo lp lq lr b">Destroy()</code> <em class="ln">销毁它。很好，没什么问题。<em class="ln">这是方法</em>。</em></p><p id="a3a6" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">但是，如果我们需要分配大量的对象并在短时间内销毁它们，这将对性能产生影响。于是<a class="ae ls" href="https://gameprogrammingpatterns.com/object-pool.html" rel="noopener ugc nofollow" target="_blank"> <em class="ln">对象池</em> </a>就来了，化险为夷。</p><blockquote class="lt lu lv"><p id="4b09" class="kr ks ln kt b ku kv jr kw kx ky ju kz lw lb lc ld lx lf lg lh ly lj lk ll lm ij bi translated">对象池是一种创造性的模式，它允许我们预先实例化一组对象并重用它们，而不是按需分配和销毁它们</p></blockquote><p id="159b" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">我们将使用新的Unity Pooling API，特别是<a class="ae ls" href="https://docs.unity3d.com/ScriptReference/Pool.ObjectPool_1.html" rel="noopener ugc nofollow" target="_blank"> <em class="ln"> ObjectPool </em> </a>类，它使用一个堆栈来保存对象实例的集合。因为它是一个泛型类，所以我们的目标也是创建一个可以重用的类来管理它。</p><p id="a9aa" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">问题是我们要使用的类型需要一个对池的引用，这样我们就可以通过调用ObjectPool的<code class="fe lo lp lq lr b">Release()</code>方法来释放这个对象。</p><p id="2efc" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">我们不希望每个类都重新定义同一个方法。取而代之的想法是创建一个基类，这个基类从<code class="fe lo lp lq lr b">MonoBehaviour</code>派生，包含一个对池的引用，并且有一个我们将要用来释放对象的方法的基本实现。</p><p id="54f9" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">由于<code class="fe lo lp lq lr b">ObjectPool</code>是<code class="fe lo lp lq lr b"><a class="ae ls" href="https://docs.unity3d.com/ScriptReference/Pool.IObjectPool_1.html" rel="noopener ugc nofollow" target="_blank">IObjectPool</a></code> <em class="ln"> </em>接口的一个实现，我们将使用这个类型来保存引用。</p><blockquote class="lz"><p id="945b" class="ma mb iq bd mc md me mf mg mh mi lm dk translated">编程到接口，而不是实现</p></blockquote><figure class="mj mk ml mm mn kk"><div class="bz fp l di"><div class="mo mp l"/></div></figure><p id="dc44" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">接下来，我们将创建一个类来管理池。</p><p id="5d3d" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">我们将使用<code class="fe lo lp lq lr b">GameObject</code>类型，因为它是所有实体的基类，但是我们的类将保存一个对从我们之前定义的Poolable类继承的预置的引用。</p><p id="a6b2" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">为了创建一个新的<code class="fe lo lp lq lr b">ObjectPool</code>实例，我们需要定义一些回调来传递给它的<a class="ae ls" href="https://docs.unity3d.com/ScriptReference/Pool.ObjectPool_1-ctor.html" rel="noopener ugc nofollow" target="_blank">构造函数</a>:</p><ul class=""><li id="31be" class="mq mr iq kt b ku kv kx ky la ms le mt li mu lm mv mw mx my bi translated"><code class="fe lo lp lq lr b">CreatePooledItem</code>，用于在池为空时创建一个新实例</li><li id="b374" class="mq mr iq kt b ku mz kx na la nb le nc li nd lm mv mw mx my bi translated"><code class="fe lo lp lq lr b">OnTakeFromPool</code>，从池中取出实例时调用</li><li id="e5c6" class="mq mr iq kt b ku mz kx na la nb le nc li nd lm mv mw mx my bi translated"><code class="fe lo lp lq lr b">OnReturnedToPool</code>，当实例返回到池中时调用</li><li id="0d10" class="mq mr iq kt b ku mz kx na la nb le nc li nd lm mv mw mx my bi translated"><code class="fe lo lp lq lr b">OnDestroyPoolObject</code>，当元素由于池达到最大值而无法返回池时调用</li></ul><p id="0c1e" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">我们还需要为池定义默认容量和最大大小。布尔值用于启用集合检查。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mo mp l"/></div></figure><p id="e02b" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">这里没什么需要注意的。当对象被创建时，我们通过获取其<code class="fe lo lp lq lr b">Poolable</code>组件将引用分配给池。当对象从池中取出或返回池中时，在<code class="fe lo lp lq lr b"><a class="ae ls" href="https://docs.unity3d.com/ScriptReference/MonoBehaviour.OnEnable.html" rel="noopener ugc nofollow" target="_blank">OnEnable()</a></code>或<code class="fe lo lp lq lr b"><a class="ae ls" href="https://docs.unity3d.com/ScriptReference/MonoBehaviour.OnDisable.html" rel="noopener ugc nofollow" target="_blank">OnDisable()</a></code>内的对象生命周期中，我们可能会执行一些清理和状态重置，或者将任务委托给负责生成对象的类。</p><p id="6910" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">现在，让我们创建一个从<code class="fe lo lp lq lr b">Poolable</code>派生的类，并定义一个弹丸。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mo mp l"/></div></figure><p id="b526" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">让我们创建一个预置来附加这个脚本，以及一个触发碰撞器。</p><p id="7fa0" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">在<code class="fe lo lp lq lr b">Update</code>中，我们通过调用从Poolable类继承的函数来释放相机外的对象(Boundaries只是我创建的一个保存这一点的枚举)。当投射物击中另一个标记为“敌人”的<code class="fe lo lp lq lr b">GameObject</code>时，情况也是如此。</p><p id="3ab1" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">现在我们要实现一个简单的spawner来发射炮弹。首先，我们需要一个对我们的池的引用，然后我们定义一个空的<code class="fe lo lp lq lr b">GameObject</code>作为父转换来保存我们将触发的所有实例，保持层次结构的整洁。我们在Spawn函数中设置初始位置和旋转。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mo mp l"/></div></figure><p id="a67e" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">我们现在剩下的就是获取一个对<code class="fe lo lp lq lr b">SimpleSpawner</code>组件的引用，并在每次我们想用我们的播放器开火时调用<code class="fe lo lp lq lr b">Spawn()</code>函数。</p><p id="e65f" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated"><em class="ln">随意玩</em></p></div></div>    
</body>
</html>