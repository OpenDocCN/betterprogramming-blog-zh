<html>
<head>
<title>Meet Mockative – A Framework For Mocking Dependencies in Kotlin</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">meet mock ative——一个在Kotlin中模仿依赖关系的框架</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/introducing-mockative-mocking-for-kotlin-native-kotlin-multiplatform-31f5b076257b?source=collection_archive---------2-----------------------#2021-12-18">https://betterprogramming.pub/introducing-mockative-mocking-for-kotlin-native-kotlin-multiplatform-31f5b076257b?source=collection_archive---------2-----------------------#2021-12-18</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="168f" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">介绍Kotlin/Native和Kotlin多平台的模拟框架</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/198f5247fe1ffcd5a8485069d7fee6d0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*LlANEqfcbMBKZq7ZngK33Q.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">作者图片</p></figure><p id="f7f7" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">而大多数Kotlin的模仿框架使用运行时代理来拦截方法调用。Kotlin/Native不支持运行时代理，因此需要不同的模拟方法。</p><p id="ece4" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">在我的Cardlay团队中，我们在移动应用中使用Kotlin Multiplatform，但非常缺乏一个模拟外部依赖的好解决方案，它不仅适用于Android或JVM，也适用于使用Kotlin/Native的iOS，因为我们觉得在所有支持的平台上运行测试套件非常重要，尤其是iOS，因为Kotlin/Native的当前主线内存模型冻结了线程之间共享的对象。</p><p id="9758" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">有一天，我想了一会儿，决定接受挑战，使用Kotlin符号处理(KSP) API开发一个模仿框架，通过在编译时而不是运行时生成模仿代理来克服Kotlin/Native的限制，从而实现对任何接口的模仿。这个新框架的名字是<a class="ae lr" href="https://github.com/mockative/mockative" rel="noopener ugc nofollow" target="_blank"> Mockative </a>，在本文中，我将介绍如何使用它。</p><p id="04e3" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">首先，您需要将依赖项添加到项目中。Mockative发布为两个库:一个是名为<code class="fe ls lt lu lv b">mockative</code>的运行时库，另一个是名为<code class="fe ls lt lu lv b">mockative-processor</code>的符号处理器，这两个库都必须添加到您的项目的<code class="fe ls lt lu lv b">build.gradle.kts</code>文件中:</p><pre class="kg kh ki kj gt lw lv lx ly aw lz bi"><span id="949e" class="ma mb iq lv b gy mc md l me mf">plugins {<br/>    id("com.google.devtools.ksp")<br/>}</span><span id="7402" class="ma mb iq lv b gy mg md l me mf">kotlin {<br/>    sourceSets {<br/>        val commonTest by getting {<br/>            dependencies {<br/>                implementation("io.mockative:mockative:1.1.2")<br/>            }<br/>        }<br/>    }<br/>}<br/><br/>dependencies {<br/>    ksp("io.mockative:mockative-processor:1.1.2")<br/>}</span></pre><p id="67f0" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">一旦添加到您的项目中，使用mock进行测试就变得轻而易举，因为您可能已经习惯了流行的mock框架，如Mockito和mock。要在测试中模拟一个依赖项，您所要做的就是:</p><pre class="kg kh ki kj gt lw lv lx ly aw lz bi"><span id="b107" class="ma mb iq lv b gy mc md l me mf">class GitHubServiceTests {<br/>    @Mock val api = mock(classOf&lt;GitHubAPI&gt;())<br/>}</span></pre><p id="6c12" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">mockative将负责为<code class="fe ls lt lu lv b">GitHubAPI</code>接口生成一个Mock，并将它的一个新实例分配给用Mock注释标注的属性。</p><h1 id="768b" class="mh mb iq bd mi mj mk ml mm mn mo mp mq jw mr jx ms jz mt ka mu kc mv kd mw mx bi translated">嘲笑会员</h1><p id="32ad" class="pw-post-body-paragraph kv kw iq kx b ky my jr la lb mz ju ld le na lg lh li nb lk ll lm nc lo lp lq ij bi translated">模仿模仿既可以用于存根，也可以用于验证调用。要在类型上存根一个成员，只需使用<code class="fe ls lt lu lv b">given(mock)</code>函数:</p><pre class="kg kh ki kj gt lw lv lx ly aw lz bi"><span id="81ed" class="ma mb iq lv b gy mc md l me mf">class GitHubServiceTests {<br/>    @Mock val api = mock(classOf&lt;GitHubAPI&gt;())</span><span id="e290" class="ma mb iq lv b gy mg md l me mf">    val service = GitHubService(api)</span><span id="b220" class="ma mb iq lv b gy mg md l me mf">    @Test fun givenRepositoryExists_thenRepositoryIsReturend() {<br/>        // given<br/>        val id = "mockative/mockative" <br/><br/>        val repository = Repository(<br/>            id = "mockative/mockative",<br/>            name = "Mockative"<br/>        )</span><span id="c141" class="ma mb iq lv b gy mg md l me mf">        given(api).invocation { getRepository(id) }<br/>            .thenReturn(repository)</span><span id="9626" class="ma mb iq lv b gy mg md l me mf">        // when<br/>        val actual = service.getRepository(id)</span><span id="90c7" class="ma mb iq lv b gy mg md l me mf">        // then<br/>        assertEquals(repository, actual)<br/>    }<br/>}</span></pre><p id="0a2c" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated"><em class="nd"> given </em> builder支持多种不同的方法来存根函数和属性，你可以在<a class="ae lr" href="https://github.com/mockative/mockative" rel="noopener ugc nofollow" target="_blank"> Mockative </a>的GitHub页面上了解更多。</p><h1 id="2e60" class="mh mb iq bd mi mj mk ml mm mn mo mp mq jw mr jx ms jz mt ka mu kc mv kd mw mx bi translated">验证模拟调用</h1><p id="c56d" class="pw-post-body-paragraph kv kw iq kx b ky my jr la lb mz ju ld le na lg lh li nb lk ll lm nc lo lp lq ij bi translated">Mockative还支持通过使用<code class="fe ls lt lu lv b">verify(mock)</code>函数来验证对mocks的调用:</p><pre class="kg kh ki kj gt lw lv lx ly aw lz bi"><span id="1f5b" class="ma mb iq lv b gy mc md l me mf">class GitHubServiceTests {<br/>    @Mock val api = configure(mock(classOf&lt;GitHubAPI&gt;())) {<br/>        // Enables the experimental feature where functions<br/>        // returning Unit don't have to be explicitly stubbed.<br/>        stubsUnitByDefault = true<br/>    }</span><span id="1aaf" class="ma mb iq lv b gy mg md l me mf">    val service = GitHubService(api)</span><span id="ae03" class="ma mb iq lv b gy mg md l me mf">    @Test fun repositoryIsCreated() {<br/>        // given<br/>        val repository = Repository(<br/>            id = "mockative/mockative",<br/>            name = "Mockative"<br/>        )</span><span id="0f64" class="ma mb iq lv b gy mg md l me mf">        // when<br/>        service.createRepository(repository)</span><span id="a6ec" class="ma mb iq lv b gy mg md l me mf">        // then<br/>        verify(api).invocation { createRepository(repository) }<br/>            .wasInvoked(exactly = once)<br/>    }<br/>}</span></pre><h1 id="d007" class="mh mb iq bd mi mj mk ml mm mn mo mp mq jw mr jx ms jz mt ka mu kc mv kd mw mx bi translated">最后的话</h1><p id="6968" class="pw-post-body-paragraph kv kw iq kx b ky my jr la lb mz ju ld le na lg lh li nb lk ll lm nc lo lp lq ij bi translated">Mockative旨在成为一个不折不扣的解决方案，用于模仿Kotlin/Native和Kotlin多平台中的依赖关系。使其区别于竞争对手的是其简洁的API和跨多线程工作的事实，例如当使用协程时。它既支持本文中展示的基于表达式的存根和验证，也支持基于匹配器的存根和验证。</p><p id="b837" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">这篇文章旨在对这个框架做一个简短的介绍，所以如果你想了解更多，通读一下文档并尝试一下<a class="ae lr" href="https://github.com/mockative/mockative" rel="noopener ugc nofollow" target="_blank"> Mockative </a>。</p></div></div>    
</body>
</html>