<html>
<head>
<title>Design for Services; Not Microservices</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">服务设计；不是微服务</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/design-for-services-not-microservices-e339883946d7?source=collection_archive---------2-----------------------#2022-01-08">https://betterprogramming.pub/design-for-services-not-microservices-e339883946d7?source=collection_archive---------2-----------------------#2022-01-08</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="e274" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">开始一个新项目，思考微服务架构？有现存的独石吗？请继续阅读架构策略</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/8d978618868ef2f30586657f9177ed80.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*qcpYwUNFdrBR83Ay8rF8iQ.jpeg"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">作者图片</p></figure><p id="212f" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">如果您正在启动一个新项目并考虑微服务架构，或者您已经有了一个整体架构，希望将其分解为不同的服务，那么请继续阅读，寻找一种策略，使您能够在需要时采用该架构。</p><p id="75fb" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">构建微服务很流行，而且已经流行了几年了。</p><p id="b0c2" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">一方面，它让人们重新关注内聚力和松散耦合。另一方面，它带来了很多复杂性，尤其是如果您想要一个健壮的企业解决方案。</p><h1 id="ce3b" class="lr ls iq bd lt lu lv lw lx ly lz ma mb jw mc jx md jz me ka mf kc mg kd mh mi bi translated">需要微服务吗？</h1><p id="e0df" class="pw-post-body-paragraph kv kw iq kx b ky mj jr la lb mk ju ld le ml lg lh li mm lk ll lm mn lo lp lq ij bi translated">几十年来，在广泛的项目中，我不得不致力于分布式计算<em class="mo">问题</em>。</p><p id="36a3" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">这是我喜欢的东西，微服务是几年前一些计算模式的更现代的旋转，但这些天有了更好的工具:-)</p><p id="8be3" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">如果你用微服务开始一个新项目，但没有明确的需求在单独的实例中运行你的服务，你可能会在应用程序“基础设施”上花费比结果更大的努力。</p><p id="6049" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">但是有一个更好的起点。</p><h1 id="c925" class="lr ls iq bd lt lu lv lw lx ly lz ma mb jw mc jx md jz me ka mf kc mg kd mh mi bi translated">首先构建服务，而不是微服务</h1><p id="42d5" class="pw-post-body-paragraph kv kw iq kx b ky mj jr la lb mk ju ld le ml lg lh li mm lk ll lm mn lo lp lq ij bi translated">在这个上下文中，我所说的“服务”是什么意思？</p><p id="af40" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">嗯，它是一组内聚的代码或功能(也就是说，它的职责只集中在一个领域)，与代码库的其余部分是松散耦合的。</p><p id="2ba2" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">你会发现这就像一个微服务。</p><p id="bb31" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">然而，这里的不同之处在于，我们没有指定该服务在专用的执行环境中运行。相反，该服务在应用程序的实例中运行。</p><p id="3815" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">在这种情况下，您不会遇到跨执行边界的可观察性或进行远程调用时的延迟(和重试)等问题。</p><p id="660a" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">从这个意义上说，服务是应用程序中的一个组件。</p><h1 id="5296" class="lr ls iq bd lt lu lv lw lx ly lz ma mb jw mc jx md jz me ka mf kc mg kd mh mi bi translated">设计模式来帮助</h1><p id="7afd" class="pw-post-body-paragraph kv kw iq kx b ky mj jr la lb mk ju ld le ml lg lh li mm lk ll lm mn lo lp lq ij bi translated">如果您已经正确定义了您的服务，一些设计模式将使您能够从基于组件的服务模型过渡到微服务模型，而无需进行大量的重新编码工作。</p><p id="b755" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">这些是<a class="ae mp" href="https://en.wikipedia.org/wiki/Factory_method_pattern" rel="noopener ugc nofollow" target="_blank">工厂方法</a>和<a class="ae mp" href="https://en.wikipedia.org/wiki/Proxy_pattern" rel="noopener ugc nofollow" target="_blank">代理</a>设计模式。</p><p id="5eac" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">让我们用一个简单的服务作为例子:a <code class="fe mq mr ms mt b">mail service</code>。</p><p id="60c2" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated"><code class="fe mq mr ms mt b">MailService</code>是一项封装发送电子邮件领域的技术服务。</p><p id="616d" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">这个例子很简单，但是概念同样适用于任何服务类型，包括封装业务域的服务类型。</p><p id="c408" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">我们的服务有一个单一的<code class="fe mq mr ms mt b">send</code>方法。</p><p id="f073" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">假设您有一个现有的monolith应用程序，并将<code class="fe mq mr ms mt b">MailService</code>部署为微服务。在这种情况下，它可能如下所示，应用程序逻辑通过HTTPS调用新服务。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi mu"><img src="../Images/30652c866f12c148cabad21edd8654d3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1342/format:webp/1*c0aCL9eqryXJdDA9Eapypg.jpeg"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">一个简单的“微服务”沿着一个整体运行</p></figure><p id="dfe3" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">或者，如果我们将<code class="fe mq mr ms mt b">Mail Service</code>部署为在您的主应用程序代码中运行的组件，它可能如下所示:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi mv"><img src="../Images/f261722dfa16aad15cf96b8bb420aa4c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*dsZ3a4Y-Q9SIS_GDUIXfxA.jpeg"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">与monolith的执行上下文中的组件相同的服务。</p></figure><p id="01c7" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">注意:根据你使用的编程语言，你仍然可以独立开发你的服务，然后使用一个依赖管理器(比如NPM，Composer等。)在构建过程中获取所需的服务版本。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi mw"><img src="../Images/5bc9fb4bb60c20e48e9e565e3a26995b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1302/format:webp/1*BMno2eLo7OERFs846hlf9g.jpeg"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">使用依赖项管理器来保持服务代码的独立性，但允许组装到最终产品中。具有版本控制的依赖管理器将使您能够创建一个模块化的整体，具有微服务所具有的一些相同的开发生命周期独立性。</p></figure><h1 id="28c4" class="lr ls iq bd lt lu lv lw lx ly lz ma mb jw mc jx md jz me ka mf kc mg kd mh mi bi translated">创建服务工厂</h1><p id="26ea" class="pw-post-body-paragraph kv kw iq kx b ky mj jr la lb mk ju ld le ml lg lh li mm lk ll lm mn lo lp lq ij bi translated">首先，邮件服务可能是一个简单的类。</p><pre class="kg kh ki kj gt mx mt my mz aw na bi"><span id="ef4a" class="nb ls iq mt b gy nc nd l ne nf"><strong class="mt ir">class </strong>MailService {<br/><br/>    <strong class="mt ir">public function </strong>send(<strong class="mt ir">string </strong>$recipient, <strong class="mt ir">string </strong>$title, <strong class="mt ir">string </strong>$message) : <strong class="mt ir">bool </strong>{<br/>        <em class="mo">// to do<br/>        </em><strong class="mt ir">return false</strong>;<br/>    }<br/>}</span></pre><p id="d64d" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">但是，我们需要定义一个<em class="mo">抽象类</em>或<em class="mo">接口</em>来采用服务工厂。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi ng"><img src="../Images/b97992c209aee34a4f75291bf3eec56d.png" data-original-src="https://miro.medium.com/v2/resize:fit:442/format:webp/1*0ZZi_bLhrS8_LpB29iS-xA.jpeg"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">将服务的公共接口提取到一个<em class="nh">接口或抽象类中。</em></p></figure><p id="61f9" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">可能是这样的:</p><pre class="kg kh ki kj gt mx mt my mz aw na bi"><span id="3604" class="nb ls iq mt b gy nc nd l ne nf"><strong class="mt ir">interface </strong>IMailService {<br/>    <strong class="mt ir">public function </strong>send(<strong class="mt ir">string </strong>$recipient, <strong class="mt ir">string </strong>$title, <strong class="mt ir">string </strong>$message) : <strong class="mt ir">bool</strong>;<br/>}<br/><br/><strong class="mt ir">class </strong>MailService <strong class="mt ir">implements </strong>IMailService {<br/><br/>    <strong class="mt ir">public function </strong>send(<strong class="mt ir">string </strong>$recipient, <strong class="mt ir">string </strong>$title, <strong class="mt ir">string </strong>$message) : <strong class="mt ir">bool </strong>{<br/>        <em class="mo">// to do<br/>        </em><strong class="mt ir">return false</strong>;<br/>    }<br/>}</span></pre><p id="f010" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">服务工厂是一个新类，您的代码现在调用它来获取服务的实例。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi ni"><img src="../Images/60c37b8d9e6be6746ca8c30ee88750e9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*r9D-4nMkJFBur1Jrva-Zxg.jpeg"/></div></div></figure><ol class=""><li id="a4c1" class="nj nk iq kx b ky kz lb lc le nl li nm lm nn lq no np nq nr bi translated">您的应用程序调用服务工厂，为其提供一个邮件服务实例。</li><li id="9bab" class="nj nk iq kx b ky ns lb nt le nu li nv lm nw lq no np nq nr bi translated"><code class="fe mq mr ms mt b">Service Factory</code>可以读取一个配置文件来查看要实例化什么类。它可以是任何类，只要它实现了IMailService接口。</li><li id="83f8" class="nj nk iq kx b ky ns lb nt le nu li nv lm nw lq no np nq nr bi translated"><code class="fe mq mr ms mt b">Service Factory</code>实例化该类，将其返回到您的应用程序。</li><li id="3970" class="nj nk iq kx b ky ns lb nt le nu li nv lm nw lq no np nq nr bi translated">然后你的应用程序在实例化的类上调用<code class="fe mq mr ms mt b">send</code>。</li></ol><p id="104a" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">这个序列看起来像是调用一个类的函数的大量代码。的确如此。</p><p id="654e" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">稍后，我将向您展示这如何帮助您实施微服务战略。但是首先，让我们看看这对您的测试有什么帮助。</p><h1 id="1134" class="lr ls iq bd lt lu lv lw lx ly lz ma mb jw mc jx md jz me ka mf kc mg kd mh mi bi translated">改进的测试</h1><p id="e826" class="pw-post-body-paragraph kv kw iq kx b ky mj jr la lb mk ju ld le ml lg lh li mm lk ll lm mn lo lp lq ij bi translated">使用一个<em class="mo">接口</em>和一种间接的方法来实例化类，您可以通过提供一个<em class="mo">模拟</em>邮件服务来改进单元测试。</p><p id="bc3a" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">模拟服务将模拟邮件服务，支持测试您的代码处理对send方法的成功和不成功(别忘了，慢)调用。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi ni"><img src="../Images/368fda61effac3d6719cfbd06d6f5e88.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*PNZeegy2M-mL2X5TBGCwQw.jpeg"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">服务对象的间接创建有助于创建用于测试的模拟服务对象。</p></figure><p id="dbfd" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">注意:根据您使用的编程语言和单元测试框架，从接口创建一个mock可能很简单。</p><h1 id="25df" class="lr ls iq bd lt lu lv lw lx ly lz ma mb jw mc jx md jz me ka mf kc mg kd mh mi bi translated">将服务发展为微服务(如果需要的话)</h1><p id="f5f0" class="pw-post-body-paragraph kv kw iq kx b ky mj jr la lb mk ju ld le ml lg lh li mm lk ll lm mn lo lp lq ij bi translated">在这个阶段，您将所有的电子邮件发送逻辑都放在一个服务中，并有一个测试它的机制。</p><p id="7884" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">我们将引入<em class="mo">代理模式</em>，使您能够将这项服务发展成为微服务。</p><p id="ac0f" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated"><code class="fe mq mr ms mt b">Proxy</code>是另一个实现服务接口的类。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi nx"><img src="../Images/945abe722b076620fad6d448c93168e9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1102/format:webp/1*19VQ-W7iYII1Bp5Jv2VNwA.jpeg"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">代理公开相同的服务接口。通过代码调用它，它将看起来与实际的邮件服务一样。</p></figure><pre class="kg kh ki kj gt mx mt my mz aw na bi"><span id="bf50" class="nb ls iq mt b gy nc nd l ne nf"><strong class="mt ir">interface </strong>IMailService {<br/>    <strong class="mt ir">public function </strong>send(<strong class="mt ir">string </strong>$recipient, <strong class="mt ir">string </strong>$title, <strong class="mt ir">string </strong>$message) : <strong class="mt ir">bool</strong>;<br/>}<br/><br/><strong class="mt ir">class </strong>MailServiceProxy <strong class="mt ir">implements </strong>IMailService {<br/><br/>    <strong class="mt ir">public function </strong>send(<strong class="mt ir">string </strong>$recipient, <strong class="mt ir">string </strong>$title, <strong class="mt ir">string </strong>$message) : <strong class="mt ir">bool </strong>{<br/>        <em class="mo">// to do: Call the MailService microservice<br/>        </em><strong class="mt ir">return false</strong>;<br/>    }<br/>}</span></pre><p id="a9f0" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">然而，这个新类不是发送电子邮件，而是调用邮件服务，该服务运行在一个单独的容器中，具有HTTPS API接口。换句话说，这个新类是实际服务类的<em class="mo">代理</em>。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi ny"><img src="../Images/15d9c1d6bb7437a4f1fa82982e710a6b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*xBgZWBdnlVWPfBQoT7qI6w.jpeg"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">服务代理运行在monolith的执行环境中，并调用运行在单独的执行环境中的实际服务。没有对monolith进行代码更改；只有对依赖程序集和服务工厂配置的更改。</p></figure><p id="cc81" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">上图中的主应用程序代码没有任何变化，除了实例化代理而不是服务类的服务工厂配置。</p><p id="b59c" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">注意:<strong class="kx ir"> </strong>依赖管理器对您的代码的打包可以被更新以交付代理代码而不是实际的服务代码。所有这些都使您的应用程序保持最小的变化。</p><h1 id="7b38" class="lr ls iq bd lt lu lv lw lx ly lz ma mb jw mc jx md jz me ka mf kc mg kd mh mi bi translated">微服务支持</h1><p id="a13f" class="pw-post-body-paragraph kv kw iq kx b ky mj jr la lb mk ju ld le ml lg lh li mm lk ll lm mn lo lp lq ij bi translated">您的代理类可以变得更加智能，而不仅仅是调用远程服务。</p><p id="441f" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">例如，它可以处理网络调用超时、执行日志记录和跟踪，以及处理远程服务的身份验证。</p><h1 id="62d0" class="lr ls iq bd lt lu lv lw lx ly lz ma mb jw mc jx md jz me ka mf kc mg kd mh mi bi translated">发展微服务</h1><p id="177a" class="pw-post-body-paragraph kv kw iq kx b ky mj jr la lb mk ju ld le ml lg lh li mm lk ll lm mn lo lp lq ij bi translated">直接调用远程邮件服务可能不是最实际的，我们可以在分离服务方面做得更好。</p><p id="ce20" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">在下图中，异步消息队列取代了同步HTTPS调用。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nz"><img src="../Images/26c4d080a7d3b26b0f7ab854963c139a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*N_rL6l3S63iuzBGfgiJA3Q.jpeg"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">服务的通信机制可以在不重新编码的情况下改变。</p></figure><p id="1fa3" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">重要提示:<strong class="kx ir"> </strong>要更改架构以支持与服务的异步通信，不需要对主要应用程序代码进行编码更改。</p><p id="a637" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">代理封装了与远程服务通信的所有逻辑。</p><p id="16c7" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">处理主应用程序逻辑的开发人员将代理作为本地类调用。</p><p id="8bf7" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">如果你想用商业服务来代替它，你可以。新版本的服务代理可以调用远程邮件产品，而无需对您的主应用程序逻辑重新编码。</p><p id="8876" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">或者，你可能已经开发了许多微服务，并决定采用一个网格，比如DAPR提供的网格。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nz"><img src="../Images/bc411cb6ce67956dedc4c6af280e64d0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*icBGasyA7KX62nZsI3Trdg.jpeg"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">该策略还支持在适当的时候引入<a class="ae mp" href="https://www.infoq.com/articles/service-mesh-ultimate-guide-2021/" rel="noopener ugc nofollow" target="_blank">服务网格</a>。</p></figure><h1 id="a94a" class="lr ls iq bd lt lu lv lw lx ly lz ma mb jw mc jx md jz me ka mf kc mg kd mh mi bi translated">分解整块石头</h1><p id="6709" class="pw-post-body-paragraph kv kw iq kx b ky mj jr la lb mk ju ld le ml lg lh li mm lk ll lm mn lo lp lq ij bi translated">本文概述的解决方案中，服务作为进程内组件运行，这是交付一个<a class="ae mp" href="https://youtu.be/5OjqD-ow8GE" rel="noopener ugc nofollow" target="_blank"><em class="mo"/></a>模块化整体的绝佳方式。</p><p id="40a2" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">巨石柱并不邪恶。它们是许多解决方案的良好模式。</p><p id="098a" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">当它们是一个<a class="ae mp" href="https://en.wikipedia.org/wiki/Big_ball_of_mud" rel="noopener ugc nofollow" target="_blank"><em class="mo"/></a>的大泥球，没有考虑到一致性、信息隐藏和封装以及松散耦合时，它们就会失败。</p><p id="4d10" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">本文概述的方法将帮助您创建一个模块化的整体，提供开发和架构灵活性，以便在需要时将一些服务转变为微服务。</p><h1 id="1f58" class="lr ls iq bd lt lu lv lw lx ly lz ma mb jw mc jx md jz me ka mf kc mg kd mh mi bi translated">改进大球泥块</h1><p id="e937" class="pw-post-body-paragraph kv kw iq kx b ky mj jr la lb mk ju ld le ml lg lh li mm lk ll lm mn lo lp lq ij bi translated">如果您有一个现有的急需重构的monolith，您可以使用这些技术来帮助控制它。</p><p id="262a" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">例如，如果您正在调用函数从代码内的几个地方发送电子邮件，为什么不首先将所有的电子邮件发送逻辑放入一个<code class="fe mq mr ms mt b">MailService</code>；-)</p><h1 id="bab9" class="lr ls iq bd lt lu lv lw lx ly lz ma mb jw mc jx md jz me ka mf kc mg kd mh mi bi translated">总结</h1><p id="2dd2" class="pw-post-body-paragraph kv kw iq kx b ky mj jr la lb mk ju ld le ml lg lh li mm lk ll lm mn lo lp lq ij bi translated">希望您已经了解了这个简单的示例，并且现在已经有了从可以扩展到微服务的模块化整体开始的策略。</p><p id="49fe" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">或者，如果你已经有一个整体，你有一个战略来模块化和发展它。</p><h1 id="2989" class="lr ls iq bd lt lu lv lw lx ly lz ma mb jw mc jx md jz me ka mf kc mg kd mh mi bi translated">更进一步</h1><p id="dc60" class="pw-post-body-paragraph kv kw iq kx b ky mj jr la lb mk ju ld le ml lg lh li mm lk ll lm mn lo lp lq ij bi translated">在大多数编程语言中，您可以创建工厂方法和代理设计模式，而不需要任何特定的框架。</p><p id="96d5" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">如果你想更进一步，看看<a class="ae mp" href="https://martinfowler.com/articles/injection.html" rel="noopener ugc nofollow" target="_blank">依赖注入模式</a>。</p><p id="c544" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">框架广泛使用这种模式来实现“幕后”服务工厂。如果您正在使用一个框架，在它的文档中搜索依赖注入，看看它是否能让您用更少的代码获得与本文相同的结果。</p><p id="4426" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">请记住，您希望使它尽可能可配置，在您的代码之外，就像服务工厂有一个配置文件来找出要实例化的类一样。</p><p id="cdd7" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">一个<a class="ae mp" href="https://en.wikipedia.org/wiki/CI/CD" rel="noopener ugc nofollow" target="_blank"> CI/CD管道</a>可以向不同的环境交付不同的配置。另外，配置技术提供了一个简单的<a class="ae mp" href="https://www.martinfowler.com/articles/feature-toggles.html" rel="noopener ugc nofollow" target="_blank"> <em class="mo">特性切换</em> </a>机制，用于快速部署(和退出)新特性。</p><p id="b8ca" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">然而，一些框架依赖于代码注释之类的技术，这些技术将配置硬编码在您的源代码中，这不是一个好主意。</p><p id="fb03" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">框架可能导致问题的另一个例子是，如果你现有的整体框架不支持它。理想情况下，您希望创建与框架无关的工厂或依赖注入，这样它就可以与您现有的monolith和您的新服务一起工作。</p></div></div>    
</body>
</html>