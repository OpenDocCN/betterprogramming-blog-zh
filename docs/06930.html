<html>
<head>
<title>The 4 Types of Memory Leaks in Node.js and How to Avoid Them (Part 1)</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Node.js中的4种内存泄漏类型以及如何避免它们(第1部分)</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/the-4-types-of-memory-leaks-in-node-js-and-how-to-avoid-them-with-the-help-of-clinic-js-part-1-3f0c0afda268?source=collection_archive---------1-----------------------#2020-11-18">https://betterprogramming.pub/the-4-types-of-memory-leaks-in-node-js-and-how-to-avoid-them-with-the-help-of-clinic-js-part-1-3f0c0afda268?source=collection_archive---------1-----------------------#2020-11-18</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="aacf" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">在Clinic.js的帮助下</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/38e03dbc46e8668770b950bdaf5bfe46.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*DNjzZTdMdfuY2e-A"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">由<a class="ae kv" href="https://unsplash.com/@daanmooij?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">金奎大·穆伊杰</a>在<a class="ae kv" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>拍摄的照片。</p></figure><p id="7961" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">第2部分—<a class="ae kv" href="https://medium.com/better-programming/the-4-types-of-memory-leaks-in-node-js-and-how-to-avoid-them-part-2-f21fbda5c33b" rel="noopener">node . js中的4种内存泄漏以及如何避免它们</a></p><p id="6134" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">软件引入bug是很常见的。我们如何管理它们才是真正的问题。生产环境中最常见的错误之一是内存泄漏，Node.js因容易发生这种情况而臭名昭著。因此，如果您是一名在生产环境中构建节点应用程序的软件开发人员，理解内存泄漏是如何发生的以及如何解决它们是一项不可思议的技能。</p><p id="1d59" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">节点应用程序是一个长时间运行的进程，在该进程被终止或服务器重新启动之前，它会被引导一次。它处理所有传入的请求并消耗资源，直到这些被V8垃圾收集。泄漏是一种将它们的引用保存在内存中并且不会被垃圾收集的资源。我不会详细介绍V8的垃圾收集是如何工作的，但是可以随意查看<a class="ae kv" href="https://www.dynatrace.com/news/blog/understanding-garbage-collection-and-hunting-memory-leaks-in-node-js/" rel="noopener ugc nofollow" target="_blank">主题</a>上的<a class="ae kv" href="https://blog.bitsrc.io/memory-leaks-in-nodejs-54ac7bbd4173" rel="noopener ugc nofollow" target="_blank">文章</a>。</p><p id="fb0d" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">相反，我将重点介绍非常常见的四种类型的泄漏以及如何避免它们。</p></div><div class="ab cl ls lt hu lu" role="separator"><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx"/></div><div class="ij ik il im in"><h1 id="dd97" class="lz ma iq bd mb mc md me mf mg mh mi mj jw mk jx ml jz mm ka mn kc mo kd mp mq bi translated">4种类型的内存泄漏</h1><ul class=""><li id="e453" class="mr ms iq ky b kz mt lc mu lf mv lj mw ln mx lr my mz na nb bi translated">全球资源</li><li id="d67a" class="mr ms iq ky b kz nc lc nd lf ne lj nf ln ng lr my mz na nb bi translated">关闭</li><li id="4107" class="mr ms iq ky b kz nc lc nd lf ne lj nf ln ng lr my mz na nb bi translated">贮藏</li><li id="a6dc" class="mr ms iq ky b kz nc lc nd lf ne lj nf ln ng lr my mz na nb bi translated">承诺</li></ul><p id="98d4" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">对于第1部分，我们将探索前两种类型:全局资源和闭包。在第2部分中，我们将看到缓存和未处理的承诺是如何导致泄漏的。</p></div><div class="ab cl ls lt hu lu" role="separator"><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx"/></div><div class="ij ik il im in"><h1 id="a24b" class="lz ma iq bd mb mc md me mf mg mh mi mj jw mk jx ml jz mm ka mn kc mo kd mp mq bi translated">准备</h1><p id="8cf1" class="pw-post-body-paragraph kw kx iq ky b kz mt jr lb lc mu ju le lf nh lh li lj ni ll lm ln nj lp lq lr ij bi translated">我们将需要优秀的<a class="ae kv" href="https://clinicjs.org/" rel="noopener ugc nofollow" target="_blank"> Clinic.js </a>和<code class="fe nk nl nm nn b">autocannon</code>来调试这些漏洞。您可以使用您想要的任何其他负载测试工具。几乎所有的方法都会产生相同的结果。Clinic.js是由<a class="ae kv" href="https://www.nearform.com/" rel="noopener ugc nofollow" target="_blank"> NearForm </a>开发的一个很棒的工具。这将有助于我们对内存泄漏甚至循环延迟等性能问题进行初步诊断。所以，让我们先安装这些工具:</p><pre class="kg kh ki kj gt no nn np nq aw nr bi"><span id="e272" class="ns ma iq nn b gy nt nu l nv nw">npm i autocannon -g<br/>npm i clinic -g</span></pre><p id="6bc4" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">现在我们准备捕捉一些漏洞！</p></div><div class="ab cl ls lt hu lu" role="separator"><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx"/></div><div class="ij ik il im in"><h1 id="6238" class="lz ma iq bd mb mc md me mf mg mh mi mj jw mk jx ml jz mm ka mn kc mo kd mp mq bi translated">全球资源</h1><p id="265f" class="pw-post-body-paragraph kw kx iq ky b kz mt jr lb lc mu ju le lf nh lh li lj ni ll lm ln nj lp lq lr ij bi translated">这是节点泄漏的最常见原因之一。由于JavaScript作为一种语言的本质，它非常容易添加到全局变量和资源中。如果这些问题没有随着时间的推移得到清理，它们会不断累积，最终导致应用程序崩溃。让我们看一个非常简单的例子。假设这是应用程序的<code class="fe nk nl nm nn b">server.js</code>:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nx ny l"/></div></figure><p id="8a5b" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">现在，如果我们跑:</p><pre class="kg kh ki kj gt no nn np nq aw nr bi"><span id="6aa7" class="ns ma iq nn b gy nt nu l nv nw">clinic doctor --on-port 'autocannon -w 300 -c 100 -d 20 localhost:3000' -- node server.js</span></pre><p id="622f" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们正在同时做两件事:用<code class="fe nk nl nm nn b">autocannon</code>对服务器进行负载测试，并捕捉跟踪数据，以便用Clinic进行分析。脚本运行20秒后，将会打开一个浏览器窗口，显示如下内容:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nz"><img src="../Images/090ff782b385fcca54cb0ce7a0f96698.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*oecZ0b1kQ7tTw11dr_hcyw.png"/></div></div></figure><p id="7f50" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们看到的是内存的稳定增长和事件循环中服务请求的延迟。这不仅增加了堆的使用量，还会影响请求的性能。分析代码可以发现，我们在每个请求中增加了<code class="fe nk nl nm nn b">requestLogs</code>全局变量，而且我们从来没有释放它。所以它一直在增长和泄漏。</p><p id="d05b" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们可以使用Chrome的节点检查器跟踪泄漏，方法是在应用程序第一次运行时获取一个堆转储，在30秒的负载测试后获取另一个堆转储，然后比较这两个堆之间分配的对象。我不会详细介绍如何进行堆转储。通过阅读这<a class="ae kv" href="https://nodesource.com/blog/memory-leaks-demystified" rel="noopener ugc nofollow" target="_blank">两篇文章</a>可以学习技法<a class="ae kv" href="https://marmelab.com/blog/2018/04/03/how-to-track-and-fix-memory-leak-with-nodejs.html" rel="noopener ugc nofollow" target="_blank">。但是当我们遵循这个过程时，我们会看到:</a></p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi oa"><img src="../Images/0a88588742a2475617d7778dc1063465.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*kECnjRZwBIBuado-7mbSUw.png"/></div></div></figure><p id="9cf7" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">是全局变量<code class="fe nk nl nm nn b">requestLogs</code>导致了泄漏。快照2的内存使用率明显高于快照1。让我们来解决这个问题:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nx ny l"/></div></figure><p id="7ba7" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这是一种解决方案。如果您确实需要持久化这些数据，您可以添加外部存储，如数据库来存储日志。如果我们再次运行诊所负载测试，我们会发现现在一切正常:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi ob"><img src="../Images/be6b183580a9bdd7641ae82e5c283d3b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*X9BkudqM0k4zCg8-XGVDxQ.png"/></div></div></figure></div><div class="ab cl ls lt hu lu" role="separator"><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx"/></div><div class="ij ik il im in"><h1 id="e20a" class="lz ma iq bd mb mc md me mf mg mh mi mj jw mk jx ml jz mm ka mn kc mo kd mp mq bi translated">关闭</h1><p id="75c6" class="pw-post-body-paragraph kw kx iq ky b kz mt jr lb lc mu ju le lf nh lh li lj ni ll lm ln nj lp lq lr ij bi translated">闭包在JavaScript中很常见，它们会导致本质上难以捉摸的内存泄漏。阅读<a class="ae kv" href="https://blog.meteor.com/an-interesting-kind-of-javascript-memory-leak-8b47d2e7f156" rel="noopener ugc nofollow" target="_blank"> meteor的博客</a>关于他们如何追踪一个闭包基内存泄漏。我们在这里探讨这种情况:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nx ny l"/></div></figure><p id="e34c" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">如果我们用<code class="fe nk nl nm nn b">autocannon</code>和诊所加载测试这段代码，我们会看到:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi oc"><img src="../Images/bf4103ebfbddfc18f45c55454bb02d5b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*QNZxIBAYclVs3GZ9TEP1SA.png"/></div></div></figure><p id="f540" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">内存增长很快，如果我们想知道脚本出了什么问题，很明显<code class="fe nk nl nm nn b">theThing</code>会被每个API调用覆盖。让我们来看看堆转储的结果:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi od"><img src="../Images/e0fc0ae2b208f968e1a4576bd790cb5d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*N7L2R168iFF83Y3S8bHQVQ.png"/></div></div></figure><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi od"><img src="../Images/dee755bc2e55d7c9f550900dada83ae0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ccpPtwZrPClKKdHSge9WeQ.png"/></div></div></figure><p id="6c83" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">当我们比较两个堆转储时，我们看到<code class="fe nk nl nm nn b">someMethod</code>在所有调用中都保存在内存中，并且它持有<code class="fe nk nl nm nn b">longStr</code>，这增加了内存的快速增长。在上面的代码中，<code class="fe nk nl nm nn b">someMethod</code>闭包正在创建一个封闭范围，它持有<code class="fe nk nl nm nn b">unused</code>变量，尽管它从未被调用过。这阻止了垃圾收集器释放<code class="fe nk nl nm nn b">originalThing</code>。解决方案就是取消结尾的<code class="fe nk nl nm nn b">originalThing</code>。我们正在释放该对象，以便不再保留闭包作用域:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nx ny l"/></div></figure><p id="a6e5" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">现在，如果我们与Clinic一起运行负载测试，我们会看到:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi oc"><img src="../Images/f2872f9a470e47af2725dd6ab2f297f1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*yE4yHWZTGl14GeMsIqKsxA.png"/></div></div></figure><p id="99d7" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">封口无泄漏！很好。我们必须关注闭包，因为它们创建自己的作用域并保留对外部作用域变量的引用。</p></div><div class="ab cl ls lt hu lu" role="separator"><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx"/></div><div class="ij ik il im in"><h1 id="1f8b" class="lz ma iq bd mb mc md me mf mg mh mi mj jw mk jx ml jz mm ka mn kc mo kd mp mq bi translated">结论</h1><p id="fac7" class="pw-post-body-paragraph kw kx iq ky b kz mt jr lb lc mu ju le lf nh lh li lj ni ll lm ln nj lp lq lr ij bi translated">我们已经探讨了Node中两种主要类型的内存泄漏，以及如何在Clinic.js和Chrome的Node调试器的帮助下检测它们。在下一篇文章<a class="ae kv" href="https://medium.com/better-programming/the-4-types-of-memory-leaks-in-node-js-and-how-to-avoid-them-part-2-f21fbda5c33b" rel="noopener">中，</a>我们将探讨另外两种类型。</p><p id="4c02" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><a class="ae kv" href="https://github.com/Joker666/nodejs-memory-leak" rel="noopener ugc nofollow" target="_blank">项目描述</a>有关于如何运行应用程序和负载测试的资源。它还包括解决方案。</p></div><div class="ab cl ls lt hu lu" role="separator"><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx"/></div><div class="ij ik il im in"><h1 id="12e2" class="lz ma iq bd mb mc md me mf mg mh mi mj jw mk jx ml jz mm ka mn kc mo kd mp mq bi translated">资源</h1><ul class=""><li id="d45e" class="mr ms iq ky b kz mt lc mu lf mv lj mw ln mx lr my mz na nb bi translated"><a class="ae kv" href="https://blog.meteor.com/an-interesting-kind-of-javascript-memory-leak-8b47d2e7f156" rel="noopener ugc nofollow" target="_blank">https://blog . meteor . com/an-interest-kind-of-JavaScript-memory-leak-8b 47d 2e 7 f 156</a></li><li id="8ca9" class="mr ms iq ky b kz nc lc nd lf ne lj nf ln ng lr my mz na nb bi translated"><a class="ae kv" href="https://www.dynatrace.com/news/blog/understanding-garbage-collection-and-hunting-memory-leaks-in-node-js/" rel="noopener ugc nofollow" target="_blank">https://www . dyna trace . com/news/blog/understanding-garbage-collection-and-hunting-memory-leaks-in-node-js/</a></li><li id="c108" class="mr ms iq ky b kz nc lc nd lf ne lj nf ln ng lr my mz na nb bi translated"><a class="ae kv" href="https://blog.bitsrc.io/memory-leaks-in-nodejs-54ac7bbd4173" rel="noopener ugc nofollow" target="_blank">https://blog.bitsrc.io/memory-leaks-in-nodejs-54ac7bbd4173</a></li><li id="ed56" class="mr ms iq ky b kz nc lc nd lf ne lj nf ln ng lr my mz na nb bi translated"><a class="ae kv" href="https://nodesource.com/blog/memory-leaks-demystified" rel="noopener ugc nofollow" target="_blank">https://nodesource.com/blog/memory-leaks-demystified</a></li><li id="c3a0" class="mr ms iq ky b kz nc lc nd lf ne lj nf ln ng lr my mz na nb bi translated"><a class="ae kv" href="https://marmelab.com/blog/2018/04/03/how-to-track-and-fix-memory-leak-with-nodejs.html" rel="noopener ugc nofollow" target="_blank">https://marmelab . com/blog/2018/04/03/how-to-track-and-fix-memory-leak-with-nodejs . html</a></li></ul></div></div>    
</body>
</html>