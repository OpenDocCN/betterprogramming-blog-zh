<html>
<head>
<title>4 Very Useful Built-In Node.js Modules</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">4个非常有用的内置Node.js模块</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/4-very-useful-built-in-node-js-modules-b734e140174c?source=collection_archive---------10-----------------------#2020-03-30">https://betterprogramming.pub/4-very-useful-built-in-node-js-modules-b734e140174c?source=collection_archive---------10-----------------------#2020-03-30</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="c9d7" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">深入了解perf_hooks、fs、os和URL</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/851a479535d7e4300e385ee7babb5827.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*TFQbb-YhHM7XI7pPss3I-Q.jpeg"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">来源:<a class="ae ky" href="https://unsplash.com/photos/XTblNijO9IE" rel="noopener ugc nofollow" target="_blank"> Unsplash </a></p></figure></div><div class="ab cl kz la hx lb" role="separator"><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le"/></div><div class="im in io ip iq"><h2 id="00ca" class="lg lh it bd li lj lk dn ll lm ln dp lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">第二部分:</h2><div class="mc md gp gr me mf"><a href="https://medium.com/javascript-in-plain-english/3-pretty-cool-built-in-node-js-modules-c2c3283276e6" rel="noopener follow" target="_blank"><div class="mg ab fo"><div class="mh ab mi cl cj mj"><h2 class="bd iu gy z fp mk fr fs ml fu fw is bi translated">3个非常酷的内置Node.js模块</h2><div class="mm l"><h3 class="bd b gy z fp mk fr fs ml fu fw dk translated">让我们使用Node.js读取用户输入，执行终端命令并运行一个JS虚拟机！</h3></div><div class="mn l"><p class="bd b dl z fp mk fr fs ml fu fw dk translated">medium.com</p></div></div><div class="mo l"><div class="mp l mq mr ms mo mt ks mf"/></div></div></a></div><h1 id="ba26" class="mu lh it bd li mv mw mx ll my mz na lo jz nb ka ls kc nc kd lw kf nd kg ma ne bi translated">什么是内置模块？</h1><p id="7966" class="pw-post-body-paragraph nf ng it nh b ni nj ju nk nl nm jx nn lp no np nq lt nr ns nt lx nu nv nw nx im bi translated">Node.js有一些所谓的<em class="ny">内置模块</em>。这意味着，尽管这些模块像我们可以安装的其他模块一样工作，例如，通过npm，然后包括使用<code class="fe nz oa ob oc b">require</code>或<code class="fe nz oa ob oc b">import</code>语法，顾名思义，内置模块已经安装，因此总是可用的。</p><p id="a441" class="pw-post-body-paragraph nf ng it nh b ni od ju nk nl oe jx nn lp of np nq lt og ns nt lx oh nv nw nx im bi translated">当然，它们是由Node.js背后的开发团队维护的，所以一切都是最新的，我们可以放心地使用这些模块。<br/> <br/>不推荐使用的模块特性可以在官方文档中识别出来。</p><p id="419c" class="pw-post-body-paragraph nf ng it nh b ni od ju nk nl oe jx nn lp of np nq lt og ns nt lx oh nv nw nx im bi translated">所以，有充分的理由来看看这些模块，并在我们的下一个项目中使用它们。</p></div><div class="ab cl kz la hx lb" role="separator"><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le"/></div><div class="im in io ip iq"><h1 id="a91d" class="mu lh it bd li mv oi mx ll my oj na lo jz ok ka ls kc ol kd lw kf om kg ma ne bi translated">1.性能计时API (perf_hooks)</h1><p id="3f81" class="pw-post-body-paragraph nf ng it nh b ni nj ju nk nl nm jx nn lp no np nq lt nr ns nt lx nu nv nw nx im bi translated">在本模块中，我们提供了各种功能来检查Node.js应用程序的性能。</p><p id="7011" class="pw-post-body-paragraph nf ng it nh b ni od ju nk nl oe jx nn lp of np nq lt og ns nt lx oh nv nw nx im bi translated">该API也在现代浏览器中实现，提供非常精确的结果，因此非常适合作为分析您自己的应用程序的首选。</p><p id="50bc" class="pw-post-body-paragraph nf ng it nh b ni od ju nk nl oe jx nn lp of np nq lt og ns nt lx oh nv nw nx im bi translated">让我们看一个例子，在这个例子中，我们检查了读取一个大文件所需的时间，并将其与读取一个小文件进行了比较。这个大文件包含大约3000行Lorem Ipsum <em class="ny">，</em>这个小文件只有20行Lorem Ipsum。</p><p id="2b7f" class="pw-post-body-paragraph nf ng it nh b ni od ju nk nl oe jx nn lp of np nq lt og ns nt lx oh nv nw nx im bi translated">如果你运行几次Node应用程序，你会发现用<code class="fe nz oa ob oc b">readFileSync</code>函数读取大文件平均要花更长的时间。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="on oo l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">我们的节点应用程序测量阅读持续时间</p></figure><p id="109a" class="pw-post-body-paragraph nf ng it nh b ni od ju nk nl oe jx nn lp of np nq lt og ns nt lx oh nv nw nx im bi translated">为此，我们使用<code class="fe nz oa ob oc b">performance.mark</code>函数，用这些标记包围我们想要检查其执行的实际代码。</p><p id="9c4d" class="pw-post-body-paragraph nf ng it nh b ni od ju nk nl oe jx nn lp of np nq lt og ns nt lx oh nv nw nx im bi translated">因此，我们总是设置一个<em class="ny">开始点</em>和一个<em class="ny">结束点</em>，然后通过<code class="fe nz oa ob oc b">performance.measure</code>函数，我们可以将整个事情存储在性能时间线中，这样我们就可以通过<code class="fe nz oa ob oc b">PerformanceObserver</code>给出结果。</p><p id="07f1" class="pw-post-body-paragraph nf ng it nh b ni od ju nk nl oe jx nn lp of np nq lt og ns nt lx oh nv nw nx im bi translated">measure函数的第一个参数是名称，另外两个是起点和终点的名称。</p><p id="abae" class="pw-post-body-paragraph nf ng it nh b ni od ju nk nl oe jx nn lp of np nq lt og ns nt lx oh nv nw nx im bi translated">结果应该是这样的:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="on oo l"/></div></figure><p id="af29" class="pw-post-body-paragraph nf ng it nh b ni od ju nk nl oe jx nn lp of np nq lt og ns nt lx oh nv nw nx im bi translated">当然，时代将取决于你的机器。</p></div><div class="ab cl kz la hx lb" role="separator"><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le"/></div><div class="im in io ip iq"><h1 id="6ccc" class="mu lh it bd li mv oi mx ll my oj na lo jz ok ka ls kc ol kd lw kf om kg ma ne bi translated">2.文件系统模块(fs)</h1><p id="e7f6" class="pw-post-body-paragraph nf ng it nh b ni nj ju nk nl nm jx nn lp no np nq lt nr ns nt lx nu nv nw nx im bi translated">我想大家都已经知道了<code class="fe nz oa ob oc b">fs</code>模块，代表<em class="ny">文件系统，</em>并允许访问文件系统。顾名思义。</p><p id="26c0" class="pw-post-body-paragraph nf ng it nh b ni od ju nk nl oe jx nn lp of np nq lt og ns nt lx oh nv nw nx im bi translated">你们大多数人应该从第一次使用Node.js时就已经知道了，而且<code class="fe nz oa ob oc b">fs</code>模块的基本功能在几乎所有的编程语言中都是类似的。</p><p id="0af6" class="pw-post-body-paragraph nf ng it nh b ni od ju nk nl oe jx nn lp of np nq lt og ns nt lx oh nv nw nx im bi translated">但是有一些不那么为人所知的很酷的功能，我现在就给大家介绍一下。</p><h2 id="47d9" class="lg lh it bd li lj lk dn ll lm ln dp lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated"><strong class="ak">检查是否是文件夹</strong></h2><pre class="kj kk kl km gt op oc oq or aw os bi"><span id="5b4d" class="lg lh it oc b gy ot ou l ov ow">const fs = require(‘fs’)</span><span id="e11b" class="lg lh it oc b gy ox ou l ov ow"><em class="ny">// will return false, no directory<br/></em>fs.statSync(‘./index.html’).isDirectory()</span></pre><h2 id="b725" class="lg lh it bd li lj lk dn ll lm ln dp lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated"><strong class="ak">打印一个目录下的所有文件</strong></h2><pre class="kj kk kl km gt op oc oq or aw os bi"><span id="00cb" class="lg lh it oc b gy ot ou l ov ow">fs.readdir(‘./test-dir’, (err, files) =&gt; {<br/>  files.forEach(file =&gt; {<br/>    console.log(file)<br/>  })<br/>})</span></pre><h2 id="ea7d" class="lg lh it bd li lj lk dn ll lm ln dp lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated"><strong class="ak">观察目录变化并给出变化类型</strong></h2><pre class="kj kk kl km gt op oc oq or aw os bi"><span id="61db" class="lg lh it oc b gy ot ou l ov ow">fs.watch(‘./test-dir’, (eventType, filename) =&gt; {<br/>  if (filename) console.log(filename, eventType)<br/>})</span></pre><h2 id="abe9" class="lg lh it bd li lj lk dn ll lm ln dp lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">fs模块的基本功能</h2><p id="3ae2" class="pw-post-body-paragraph nf ng it nh b ni nj ju nk nl nm jx nn lp no np nq lt nr ns nt lx nu nv nw nx im bi translated"><strong class="nh iu">读取文件并打印出文件内容</strong></p><pre class="kj kk kl km gt op oc oq or aw os bi"><span id="c35e" class="lg lh it oc b gy ot ou l ov ow">fs.readFile(‘./note.txt’, ‘utf8’, (err, data) =&gt; {<br/>  console.log(data)<br/>})</span></pre><p id="d5ba" class="pw-post-body-paragraph nf ng it nh b ni od ju nk nl oe jx nn lp of np nq lt og ns nt lx oh nv nw nx im bi translated">如果您省略了解码的参数，在我们的示例中，“T1”，默认情况下，内容将作为缓冲区给出。</p><p id="f630" class="pw-post-body-paragraph nf ng it nh b ni od ju nk nl oe jx nn lp of np nq lt og ns nt lx oh nv nw nx im bi translated"><strong class="nh iu">向文件中添加内容</strong></p><pre class="kj kk kl km gt op oc oq or aw os bi"><span id="758f" class="lg lh it oc b gy ot ou l ov ow">fs.appendFile(‘./note.txt’, ‘This is new!’, err =&gt; {<br/>  if (err) throw err<br/>  console.log(‘file changed’)<br/>})</span></pre><p id="39cc" class="pw-post-body-paragraph nf ng it nh b ni od ju nk nl oe jx nn lp of np nq lt og ns nt lx oh nv nw nx im bi translated"><strong class="nh iu">创建一个新文件，向其中写入内容/清除文件</strong></p><pre class="kj kk kl km gt op oc oq or aw os bi"><span id="edca" class="lg lh it oc b gy ot ou l ov ow">fs.writeFile(‘./note.txt’, ‘’, err =&gt; {<br/>  if (err) throw err<br/>  console.log(‘file cleared’)<br/>})</span></pre><p id="05b9" class="pw-post-body-paragraph nf ng it nh b ni od ju nk nl oe jx nn lp of np nq lt og ns nt lx oh nv nw nx im bi translated">这个函数的第二个参数是应该写入文件的内容。在我们的例子中，我们让它为空，这样如果给定的文件存在，它将完全为空。</p><p id="4bfd" class="pw-post-body-paragraph nf ng it nh b ni od ju nk nl oe jx nn lp of np nq lt og ns nt lx oh nv nw nx im bi translated">如果它不存在，它将被创建，但也将保持为空。因此，这个函数不适合向文件中添加内容，因为它会覆盖以前添加的所有内容。</p></div><div class="ab cl kz la hx lb" role="separator"><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le"/></div><div class="im in io ip iq"><h1 id="2bbe" class="mu lh it bd li mv oi mx ll my oj na lo jz ok ka ls kc ol kd lw kf om kg ma ne bi translated">3.操作系统模块(os)</h1><p id="afbc" class="pw-post-body-paragraph nf ng it nh b ni nj ju nk nl nm jx nn lp no np nq lt nr ns nt lx nu nv nw nx im bi translated">这个模块可以输出Node.js当前运行的系统的各种信息。例如，它可以用来监控服务器的性能。</p><p id="1e1f" class="pw-post-body-paragraph nf ng it nh b ni od ju nk nl oe jx nn lp of np nq lt og ns nt lx oh nv nw nx im bi translated">这里有几个有用的函数，我直接转换了它们的输出，这样它们对我们来说更容易理解。</p><p id="0285" class="pw-post-body-paragraph nf ng it nh b ni od ju nk nl oe jx nn lp of np nq lt og ns nt lx oh nv nw nx im bi translated">通过将<code class="fe nz oa ob oc b">os.totalmem()</code>的值除以三次，这给出了RAM的确切大小，应该会输出一个非常平滑的数字。在我的MacBook Pro上，正好是“16”，因为它有16g的内存。</p><p id="dc26" class="pw-post-body-paragraph nf ng it nh b ni od ju nk nl oe jx nn lp of np nq lt og ns nt lx oh nv nw nx im bi translated">为了确认<code class="fe nz oa ob oc b">os.freemem()</code>工作正常，你可以打开几个Chrome标签，运行脚本，然后再次关闭它们，然后再次运行脚本。你会看到不同之处。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="on oo l"/></div></figure></div><div class="ab cl kz la hx lb" role="separator"><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le"/></div><div class="im in io ip iq"><h1 id="ac61" class="mu lh it bd li mv oi mx ll my oj na lo jz ok ka ls kc ol kd lw kf om kg ma ne bi translated">4.url模块(URL)</h1><p id="ba97" class="pw-post-body-paragraph nf ng it nh b ni nj ju nk nl nm jx nn lp no np nq lt nr ns nt lx nu nv nw nx im bi translated">由于Node.js通常用于web应用程序的后端，使用URL实际上是不可避免的。</p><p id="d6bd" class="pw-post-body-paragraph nf ng it nh b ni od ju nk nl oe jx nn lp of np nq lt og ns nt lx oh nv nw nx im bi translated">这里介绍的内置模块可以通过提供处理URL的标准函数来简化我们的工作。</p><h2 id="cdf2" class="lg lh it bd li lj lk dn ll lm ln dp lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated"><strong class="ak">将URL拆分成所有重要信息，如主机、协议和端口</strong></h2><pre class="kj kk kl km gt op oc oq or aw os bi"><span id="00a9" class="lg lh it oc b gy ot ou l ov ow">const url = require("url")</span><span id="b0f1" class="lg lh it oc b gy ox ou l ov ow">url.parse(‘https://medium.com/@louispetrik')</span></pre><p id="5c0c" class="pw-post-body-paragraph nf ng it nh b ni od ju nk nl oe jx nn lp of np nq lt og ns nt lx oh nv nw nx im bi translated">结果:</p><pre class="kj kk kl km gt op oc oq or aw os bi"><span id="5855" class="lg lh it oc b gy ot ou l ov ow">Url {<br/> protocol: ‘https:’,<br/> slashes: true,<br/> auth: null,<br/> host: ‘medium.com’,<br/> port: null,<br/> hostname: ‘medium.com’,<br/> hash: null,<br/> search: null,<br/> query: null,<br/> pathname: ‘/@louispetrik’,<br/> path: ‘/@louispetrik’,<br/> href: ‘<a class="ae ky" href="https://medium.com/@louispetrik'" rel="noopener">https://medium.com/@louispetrik'</a><br/>}</span></pre><h2 id="fccf" class="lg lh it bd li lj lk dn ll lm ln dp lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated"><strong class="ak">将基本网址和精确路径合并成一个正确的网址</strong></h2><pre class="kj kk kl km gt op oc oq or aw os bi"><span id="2be4" class="lg lh it oc b gy ot ou l ov ow">url.resolve(‘https://medium.com/', ‘/@louispetrik’)</span></pre><p id="8e5f" class="pw-post-body-paragraph nf ng it nh b ni od ju nk nl oe jx nn lp of np nq lt og ns nt lx oh nv nw nx im bi translated">结果:<code class="fe nz oa ob oc b"><a class="ae ky" href="https://medium.com/@louispetrik" rel="noopener">https://medium.com/@louispetrik</a></code></p><h2 id="96cc" class="lg lh it bd li lj lk dn ll lm ln dp lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated"><strong class="ak">输出URL的搜索参数值</strong></h2><pre class="kj kk kl km gt op oc oq or aw os bi"><span id="db1e" class="lg lh it oc b gy ot ou l ov ow">let SearchURL = new URL(‘https://example.org/?product=car')<br/>console.log(SearchURL.searchParams.get(‘product’))</span></pre><p id="1d35" class="pw-post-body-paragraph nf ng it nh b ni od ju nk nl oe jx nn lp of np nq lt og ns nt lx oh nv nw nx im bi translated">结果:<code class="fe nz oa ob oc b">car</code></p></div><div class="ab cl kz la hx lb" role="separator"><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le"/></div><div class="im in io ip iq"><h1 id="487f" class="mu lh it bd li mv oi mx ll my oj na lo jz ok ka ls kc ol kd lw kf om kg ma ne bi translated">结论</h1><p id="701b" class="pw-post-body-paragraph nf ng it nh b ni nj ju nk nl nm jx nn lp no np nq lt nr ns nt lx nu nv nw nx im bi translated">今天就到这里，希望你学到了新的有用的东西。感谢阅读！</p></div></div>    
</body>
</html>