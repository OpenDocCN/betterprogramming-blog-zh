<html>
<head>
<title>Python: A Snake That Loves Objects</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">蟒蛇:一种喜爱物体的蛇</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/python-a-snake-that-loves-objects-e3c566a45cf5?source=collection_archive---------4-----------------------#2019-05-30">https://betterprogramming.pub/python-a-snake-that-loves-objects-e3c566a45cf5?source=collection_archive---------4-----------------------#2019-05-30</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="f839" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">面向对象编程中对象的解释</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/d3d9e2ff63a7e10d7236c97a564fec28.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*TjqNKaFojBVFvfx6HgpMJA.jpeg"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">照片由<a class="ae ky" href="https://unsplash.com/@sharonmccutcheon?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">莎伦·麦卡琴</a>在<a class="ae ky" href="https://unsplash.com/search/photos/python?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>拍摄</p></figure><p id="b14b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在Python中几乎所有的东西都是对象！在这篇文章中，我们将讨论这些物体。</p><p id="8db7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">第一，什么是对象？根据webopedia的说法，对象是“一个自包含的实体，由数据和操作数据的过程组成”。为了与现实世界的对象进行比较，以咖啡机为例:它有代表数据的材料(即咖啡豆)，它有代表处理数据的程序的功能(即研磨咖啡豆)。变量、类实例、函数、方法和许多其他东西都是Python中的对象。</p><p id="0b09" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在让我们深入了解一下Python语言是如何将一切都视为对象的。</p><h1 id="6dce" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">id和类型</h1><p id="2e1e" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">Python中的每个对象都有一个<strong class="lb iu"> id </strong>、一个<strong class="lb iu">类型</strong>和一个<strong class="lb iu">值</strong>。</p><p id="3acf" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">一个对象的id就是它的身份——它在内存中的地址。根据<a class="ae ky" href="https://www.geeksforgeeks.org/id-function-python/" rel="noopener ugc nofollow" target="_blank"> geeksforgeeks </a>，“这个身份在这个对象的生命周期中必须是唯一的和不变的”<em class="ms">。</em>换句话说，当一个对象被创建时，它得到一个标识，或者内存中的一个地址，而当该对象被删除时，它就失去了这个标识。<strong class="lb iu"> </strong>对于从来没有和低级语言打过交道的程序员来说，这个概念可能很新，但事实是，电脑里的一切都存储在机器内存的某个地方。可以使用函数<em class="ms"> id() </em>检索对象的id。</p><p id="b955" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们以一个值为9的整数<em class="ms"> a </em>为例。</p><pre class="kj kk kl km gt mt mu mv mw aw mx bi"><span id="71d6" class="my lw it mu b gy mz na l nb nc">&gt;&gt;&gt; a = 9<br/>&gt;&gt;&gt; id(a)<br/>10105344</span></pre><p id="eb56" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在这种情况下，变量<code class="fe nd ne nf mu b">a</code>的id是<code class="fe nd ne nf mu b">10105344</code>。当然，这取决于您的机器和Python解释器保存变量的位置。</p><p id="7976" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">一个对象的类型是，嗯…它的类型。要检查一个对象的类型，我们可以将它传递给<code class="fe nd ne nf mu b"><em class="ms"> type()</em></code>函数。让我们看看我们的<code class="fe nd ne nf mu b">a</code>变量:</p><pre class="kj kk kl km gt mt mu mv mw aw mx bi"><span id="7a00" class="my lw it mu b gy mz na l nb nc">&gt;&gt;&gt; type(a)<br/>&lt;class 'int'&gt;</span></pre><p id="bf2d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这里我们看到函数并没有像预期的那样只是返回<em class="ms"> </em> <code class="fe nd ne nf mu b">int</code>，而是<code class="fe nd ne nf mu b">class ‘int’</code>。在Python中，不像C或其他编程语言那样有内置的数据类型。类型实际上是类，每个变量都是相应类的一个实例。所以在我们的例子中，<code class="fe nd ne nf mu b">a </code>是<code class="fe nd ne nf mu b">int</code>类的一个实例。</p><h1 id="e016" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">可变对象</h1><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ng"><img src="../Images/bf7f6602910818aed93ee8b4a0c6f1bf.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*X3GmUh7dqAMJLM5KwGBKYQ.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">Python中有两种主要类型的对象:可变的和不可变的</p></figure><p id="4f1c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">Python中的可变对象是可以修改的对象。例如，列表、集合和字典是可变的。让我们看看这意味着什么:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nh ni l"/></div></figure><p id="b0a6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们创建了第一个int列表<code class="fe nd ne nf mu b">l1</code>，然后将<em class="ms"> </em> <code class="fe nd ne nf mu b">l1</code>分配给新列表<code class="fe nd ne nf mu b">l2</code>。然后我们给<code class="fe nd ne nf mu b">l1</code>添加了一个元素。现在<code class="fe nd ne nf mu b">l1</code>应该看起来像<code class="fe nd ne nf mu b">[1, 2, 3, 4]</code>。但是<em class="ms"> </em> <code class="fe nd ne nf mu b">l2</code>呢？当我们打印它时，我们看到它也被更新了，尽管我们在修改<code class="fe nd ne nf mu b">l1</code>之前将<code class="fe nd ne nf mu b">l1</code> <em class="ms"> </em>赋给了<em class="ms"> </em> <code class="fe nd ne nf mu b">l2</code>。我们在第二行做的叫做<strong class="lb iu">混叠</strong>。我们创建了一个名为<code class="fe nd ne nf mu b">l2</code>的<code class="fe nd ne nf mu b">l1</code>别名，但是这两个名称指向同一个对象。我们可以通过使用前面提到的<code class="fe nd ne nf mu b">id()</code>函数或者<code class="fe nd ne nf mu b">is</code>操作符来验证这一点:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nh ni l"/></div></figure><p id="b986" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe nd ne nf mu b">l1</code>和<code class="fe nd ne nf mu b">l2</code>具有相同的身份——它们指向同一个对象。</p><blockquote class="nj nk nl"><p id="5e40" class="kz la ms lb b lc ld ju le lf lg jx lh nm lj lk ll nn ln lo lp no lr ls lt lu im bi translated"><strong class="lb iu">注意:</strong><strong class="lb iu"/><code class="fe nd ne nf mu b">is</code>运算符与<code class="fe nd ne nf mu b">==</code>运算符不同。前者评估两个名字是否指向内存中的<strong class="lb iu">相同对象</strong>，后者评估它们是否具有<strong class="lb iu">相同值</strong>。</p></blockquote><p id="3fe6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果我们想在不修改原始列表的情况下复制一个列表，我们需要<strong class="lb iu">克隆</strong>它。这可以通过切片方法来实现:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nh ni l"/></div></figure><p id="c506" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">克隆成功了，现在<code class="fe nd ne nf mu b">l2</code>引用了不同于<code class="fe nd ne nf mu b">l1</code>的对象，因为它们的id不同。</p><h1 id="e959" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">不可变对象</h1><p id="baa0" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">数字、字符串和元组是Python中不可变的对象。这意味着它们不能就地修改。让我们以int为例:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nh ni l"/></div></figure><p id="a2ea" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们现在看到，如果<code class="fe nd ne nf mu b">a</code>等于<code class="fe nd ne nf mu b">b</code>并且我们修改了<code class="fe nd ne nf mu b">a</code>，<code class="fe nd ne nf mu b">b</code>将保持不变。这就是不可改变的意义。</p><h1 id="7bb0" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">Python如何区别对待可变和不可变对象</h1><p id="e0f4" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">我们已经看到，在赋值之后，你不能修改不可变的对象，但是你<em class="ms">可以</em>对可变的对象这样做。</p><p id="bd4c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">那么引擎盖下发生了什么呢？以我们的列表<code class="fe nd ne nf mu b">l1</code>和<code class="fe nd ne nf mu b">l2</code>为例，Python将重新分配列表中的所有元素，向其中添加一个新元素。这在内存和时间方面效率不高。另一方面，不可变对象更快，因为每次我们试图修改它时，整个对象不会被重新分配——Python只会用更新后的值创建一个新对象。</p><h1 id="4e40" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">参数如何传递给函数，这对可变和不可变对象意味着什么</h1><p id="13fd" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">Python在内存中存储变量的方式很有趣。对于熟悉C编程语言的人来说，它的工作方式有点像<strong class="lb iu">指针</strong>。Python中的变量存储它们引用的对象的地址(或者id)。</p><p id="c186" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">也就是说，一个<strong class="lb iu">参数</strong>通过<strong class="lb iu">引用</strong>传递给一个函数。这意味着我们实际上并没有将<em class="ms">对象</em>传递给函数，而是将<em class="ms">引用</em>传递给它们。一般来说，函数是这样工作的:它有一个名字，要么带参数，要么不带，执行一组语句，然后退出。因此，当我们向它传递参数时，它会根据参数所引用的对象的可变性显示不同的行为。</p><p id="3b54" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果我们将一个可变对象传递给一个函数，并在函数块内部修改它的值，那么这个对象的新值就可以从函数的作用域之外访问。举例说明:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nh ni l"/></div></figure><p id="c152" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在将它传递给我们的函数<code class="fe nd ne nf mu b">foo(),</code>之后，我们打印出<code class="fe nd ne nf mu b"><em class="ms">l1 </em></code>，函数<code class="fe nd ne nf mu b">foo(),</code>在它后面附加了一个数字，然后我们看到更新后的列表。</p><p id="80ec" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在，如果我们用一个不可变的对象来尝试，对函数内部参数的修改将不能从其作用域之外访问</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nh ni l"/></div></figure><p id="e3bd" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们可以看到字符串<code class="fe nd ne nf mu b">s1</code>在函数内部被修改了，但是在<code class="fe nd ne nf mu b">foo()</code>的作用域之外仍然保存旧值。</p><h1 id="c4bd" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">其他棘手的对象魔术和异常</h1><h2 id="5f00" class="my lw it bd lx np nq dn mb nr ns dp mf li nt nu mh lm nv nw mj lq nx ny ml nz bi translated">预先分配的整数范围</h2><p id="3f7a" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">我们说过字符串是不可变的，两个值相同的变量指向同一个对象。事实上，情况并不总是如此。让我们来看一个例子:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nh ni l"/></div></figure><p id="06a7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">等等……什么？在两种情况下<code class="fe nd ne nf mu b">a</code>和<em class="ms"> </em> <code class="fe nd ne nf mu b">b</code>具有相同的值——为什么在第二种情况下它们不是同一个对象？原因很简单:当一条指令运行时，已经有一个分配的int数组，范围从-5(由Python源代码中的宏<code class="fe nd ne nf mu b">NSMALLNEGINTS</code>定义)到257 ( <code class="fe nd ne nf mu b">NSMALLPOSINTS</code>)。Python中最常用的int就在这个范围内，所以解释器已经在一开始就分配了它们。在这些范围内创建对象不需要实际创建对象。这就是为什么该范围内的所有整数和字符(字符只是数字)实际上是同一个对象，并且条件<code class="fe nd ne nf mu b">a</code> <em class="ms">为</em> <code class="fe nd ne nf mu b">b</code>评估为真。空格字符的ASCII值不在该范围内，为<code class="fe nd ne nf mu b">a</code>和<code class="fe nd ne nf mu b">b</code>创建新对象，它们不指向同一个对象。让我们用int值来看看这个:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nh ni l"/></div></figure><p id="2d59" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这里的<code class="fe nd ne nf mu b">a</code>和<code class="fe nd ne nf mu b">b</code>具有相同的值，但是它们不是同一个对象，因为它们不在Python提供的int数组中——真有趣！</p><h2 id="4fe1" class="my lw it bd lx np nq dn mb nr ns dp mf li nt nu mh lm nv nw mj lq nx ny ml nz bi translated">a += b和a = a + b的区别</h2><p id="94a4" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">从编程的角度来看，我们可以认为使用操作<code class="fe nd ne nf mu b">a += b</code>和<code class="fe nd ne nf mu b">a = a + b</code>是相同的。但是在引擎盖下，它们是非常不同的操作。+=符号被称为<strong class="lb iu">复合赋值运算符</strong>。它既对变量赋值又对变量进行操作，所以它做我们称之为<strong class="lb iu">的原地加法</strong>。因为Python中的一切都是对象，都源于一个类，所以这些操作符实际上是它们所使用的数据的类的方法。+=依次调用方法<code class="fe nd ne nf mu b">__iadd__</code>，如果不起作用，它将尝试使用<code class="fe nd ne nf mu b">__add__</code>来代替。这可能导致依赖于实现的意外行为。+运算符只调用<code class="fe nd ne nf mu b">__add__</code>。在这两种情况下，根据它们操作的对象，我们可以看到新对象的创建或现有对象的修改。</p><h2 id="6f0d" class="my lw it bd lx np nq dn mb nr ns dp mf li nt nu mh lm nv nw mj lq nx ny ml nz bi translated">元组突变</h2><p id="4c83" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">还记得我们说过元组是不可变的吗？这是真的，但是如果它们包含可变对象，我们可以改变这些对象的值。让我们举个例子:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nh ni l"/></div></figure><p id="26eb" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们成功修改了元组！我们通过修改它的一个可变值来做到这一点，这个可变值也在其别名中进行了更新。但是我们需要小心——始终确保放入集合和字典中的元组只包含不可变类型。</p></div><div class="ab cl oa ob hx oc" role="separator"><span class="od bw bk oe of og"/><span class="od bw bk oe of og"/><span class="od bw bk oe of"/></div><div class="im in io ip iq"><h1 id="82c9" class="lv lw it bd lx ly oh ma mb mc oi me mf jz oj ka mh kc ok kd mj kf ol kg ml mm bi translated">来源</h1><div class="om on gp gr oo op"><a href="https://www.webopedia.com/TERM/O/object_oriented_programming_OOP.html" rel="noopener  ugc nofollow" target="_blank"><div class="oq ab fo"><div class="or ab os cl cj ot"><h2 class="bd iu gy z fp ou fr fs ov fu fw is bi translated">什么是面向对象编程？网络百科定义</h2><div class="ow l"><h3 class="bd b gy z fp ou fr fs ov fu fw dk translated">一种程序设计类型，其中程序员不仅定义数据结构的数据类型，而且定义数据结构的类型</h3></div><div class="ox l"><p class="bd b dl z fp ou fr fs ov fu fw dk translated">www.webopedia.com</p></div></div></div></a></div><div class="om on gp gr oo op"><a href="https://www.geeksforgeeks.org/id-function-python/" rel="noopener  ugc nofollow" target="_blank"><div class="oq ab fo"><div class="or ab os cl cj ot"><h2 class="bd iu gy z fp ou fr fs ov fu fw is bi translated">Python - GeeksforGeeks中的id()函数</h2><div class="ow l"><h3 class="bd b gy z fp ou fr fs ov fu fw dk translated">简介id()是Python中的一个内置函数。语法:id(object)正如我们所看到的，该函数接受单个…</h3></div><div class="ox l"><p class="bd b dl z fp ou fr fs ov fu fw dk translated">www.geeksforgeeks.org</p></div></div><div class="oy l"><div class="oz l pa pb pc oy pd ks op"/></div></div></a></div><div class="om on gp gr oo op"><a href="https://www.geeksforgeeks.org/python-type-function/" rel="noopener  ugc nofollow" target="_blank"><div class="oq ab fo"><div class="or ab os cl cj ot"><h2 class="bd iu gy z fp ou fr fs ov fu fw is bi translated">Python | type()函数- GeeksforGeeks</h2><div class="ow l"><h3 class="bd b gy z fp ou fr fs ov fu fw dk translated">type()方法返回作为参数传递的变量(对象)的类类型。type()函数主要用于…</h3></div><div class="ox l"><p class="bd b dl z fp ou fr fs ov fu fw dk translated">www.geeksforgeeks.org</p></div></div><div class="oy l"><div class="pe l pa pb pc oy pd ks op"/></div></div></a></div><div class="om on gp gr oo op"><a href="http://radar.oreilly.com/2014/10/python-tuples-immutable-but-potentially-changing.html" rel="noopener  ugc nofollow" target="_blank"><div class="oq ab fo"><div class="or ab os cl cj ot"><h2 class="bd iu gy z fp ou fr fs ov fu fw is bi translated">Python元组:不可变但可能变化</h2><div class="ow l"><h3 class="bd b gy z fp ou fr fs ov fu fw dk translated">Python元组有一个令人惊讶的特性:它们是不可变的，但是它们的值可能会改变。这可能发生在元组…</h3></div><div class="ox l"><p class="bd b dl z fp ou fr fs ov fu fw dk translated">radar.oreilly.com</p></div></div><div class="oy l"><div class="pf l pa pb pc oy pd ks op"/></div></div></a></div><div class="om on gp gr oo op"><a href="http://composingprograms.com/pages/24-mutable-data.html#sequence-objects" rel="noopener  ugc nofollow" target="_blank"><div class="oq ab fo"><div class="or ab os cl cj ot"><h2 class="bd iu gy z fp ou fr fs ov fu fw is bi translated">2.4可变数据</h2><div class="ow l"><h3 class="bd b gy z fp ou fr fs ov fu fw dk translated">创建模块化程序的一个强有力的技术是合并可能随时间改变状态的数据。在这个…</h3></div><div class="ox l"><p class="bd b dl z fp ou fr fs ov fu fw dk translated">composingprograms.com</p></div></div></div></a></div><div class="om on gp gr oo op"><a href="http://www.openbookproject.net/thinkcs/python/english2e/ch09.html#objects-and-values" rel="noopener  ugc nofollow" target="_blank"><div class="oq ab fo"><div class="or ab os cl cj ot"><h2 class="bd iu gy z fp ou fr fs ov fu fw is bi translated">9.列表——如何像计算机科学家一样思考:学习Python第二版文档</h2><div class="ow l"><h3 class="bd b gy z fp ou fr fs ov fu fw dk translated">列表是一组有序的值，每个值由一个索引标识。组成列表的值是…</h3></div><div class="ox l"><p class="bd b dl z fp ou fr fs ov fu fw dk translated">www.openbookproject.net</p></div></div><div class="oy l"><div class="pg l pa pb pc oy pd ks op"/></div></div></a></div><div class="om on gp gr oo op"><a href="https://docs.python.org/2/reference/datamodel.html" rel="noopener  ugc nofollow" target="_blank"><div class="oq ab fo"><div class="or ab os cl cj ot"><h2 class="bd iu gy z fp ou fr fs ov fu fw is bi translated">3.数据模型- Python 2.7.16文档</h2><div class="ow l"><h3 class="bd b gy z fp ou fr fs ov fu fw dk translated">这些表示机器级别的双精度浮点数。你受底层机器的支配…</h3></div><div class="ox l"><p class="bd b dl z fp ou fr fs ov fu fw dk translated">docs.python.org</p></div></div></div></a></div><div class="om on gp gr oo op"><a href="http://www.deephobbying.com/basicsofpython/tuple%20and%20list/" rel="noopener  ugc nofollow" target="_blank"><div class="oq ab fo"><div class="or ab os cl cj ot"><h2 class="bd iu gy z fp ou fr fs ov fu fw is bi translated">深蹲</h2><div class="ow l"><h3 class="bd b gy z fp ou fr fs ov fu fw dk translated">内置类型的对象，如(数字、字符串和元组等。)都是不可变的。内置类型的对象，如(列表、集合和…</h3></div><div class="ox l"><p class="bd b dl z fp ou fr fs ov fu fw dk translated">www.deephobbying.com</p></div></div></div></a></div><div class="om on gp gr oo op"><a href="https://learnandlearn.com/python-programming/python-how-to/python-function-arguments-mutable-and-immutable" rel="noopener  ugc nofollow" target="_blank"><div class="oq ab fo"><div class="or ab os cl cj ot"><h2 class="bd iu gy z fp ou fr fs ov fu fw is bi translated">Python可变和不可变函数参数</h2><div class="ow l"><h3 class="bd b gy z fp ou fr fs ov fu fw dk translated">Python编译器处理函数参数的方式与其他流行的编程语言略有不同，如C、C++和…</h3></div><div class="ox l"><p class="bd b dl z fp ou fr fs ov fu fw dk translated">learnandlearn.com</p></div></div><div class="oy l"><div class="ph l pa pb pc oy pd ks op"/></div></div></a></div><div class="om on gp gr oo op"><a href="https://stackoverflow.com/questions/2347265/why-does-behave-unexpectedly-on-lists?noredirect=1&amp;lq=1" rel="noopener  ugc nofollow" target="_blank"><div class="oq ab fo"><div class="or ab os cl cj ot"><h2 class="bd iu gy z fp ou fr fs ov fu fw is bi translated">为什么+=在列表中表现异常？</h2><div class="ow l"><h3 class="bd b gy z fp ou fr fs ov fu fw dk translated">python中的+=操作符似乎意外地在列表上操作。有人能告诉我这是怎么回事吗？</h3></div><div class="ox l"><p class="bd b dl z fp ou fr fs ov fu fw dk translated">stackoverflow.com</p></div></div><div class="oy l"><div class="pi l pa pb pc oy pd ks op"/></div></div></a></div></div></div>    
</body>
</html>