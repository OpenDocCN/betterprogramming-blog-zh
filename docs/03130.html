<html>
<head>
<title>What Goes Into a Dockerfile?</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">docker文件包含哪些内容？</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/what-goes-into-a-dockerfile-ff0ace591060?source=collection_archive---------3-----------------------#2020-01-22">https://betterprogramming.pub/what-goes-into-a-dockerfile-ff0ace591060?source=collection_archive---------3-----------------------#2020-01-22</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="fb0f" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">从头开始构建Dockerfile文件，不需要任何经验</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/33a12ef295a400862a635133e6119393.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*yiMsX1C4fVaWxEYW"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">贾斯汀·贝克在<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的照片</p></figure></div><div class="ab cl kz la hx lb" role="separator"><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le"/></div><div class="im in io ip iq"><h1 id="88bd" class="lg lh it bd li lj lk ll lm ln lo lp lq jz lr ka ls kc lt kd lu kf lv kg lw lx bi translated">Docker是什么？</h1><p id="b497" class="pw-post-body-paragraph ly lz it ma b mb mc ju md me mf jx mg mh mi mj mk ml mm mn mo mp mq mr ms mt im bi translated">你们中的一些人可能已经熟悉Docker是什么，可以跳过这个小的介绍部分。不过，我会简单介绍一下这个问题以及Docker试图解决的问题。</p><p id="5777" class="pw-post-body-paragraph ly lz it ma b mb mu ju md me mv jx mg mh mw mj mk ml mx mn mo mp my mr ms mt im bi translated">我们先来看看维基百科给出的定义:</p><blockquote class="mz na nb"><p id="f1da" class="ly lz nc ma b mb mu ju md me mv jx mg nd mw mj mk ne mx mn mo nf my mr ms mt im bi translated">Docker是一组平台即服务(PaaS)产品，使用操作系统级虚拟化来交付称为容器的软件包中的软件。</p><p id="f2ae" class="ly lz nc ma b mb mu ju md me mv jx mg nd mw mj mk ne mx mn mo nf my mr ms mt im bi translated">容器是相互隔离的，捆绑了它们自己的软件、库和配置文件；他们可以通过明确定义的渠道相互交流。</p><p id="8a22" class="ly lz nc ma b mb mu ju md me mv jx mg nd mw mj mk ne mx mn mo nf my mr ms mt im bi translated">所有容器都由单一操作系统内核运行，因此比虚拟机更轻量级。— <a class="ae ky" href="https://en.wikipedia.org/wiki/Docker_(software)" rel="noopener ugc nofollow" target="_blank">维基百科</a></p></blockquote><p id="86d7" class="pw-post-body-paragraph ly lz it ma b mb mu ju md me mv jx mg mh mw mj mk ml mx mn mo mp my mr ms mt im bi translated">这听起来像一个伟大的销售谈话，但它使用了很多昂贵的话。Docker只是一个工具，通过使用所谓的<em class="nc">容器</em>，使应用程序的创建、部署和运行更加容易。</p><p id="44ca" class="pw-post-body-paragraph ly lz it ma b mb mu ju md me mv jx mg mh mw mj mk ml mx mn mo mp my mr ms mt im bi translated">这些容器允许我们开发人员将应用程序所需的一切打包(例如，库、依赖项)。然后，我们可以将包裹作为一个整体运输。</p><p id="8a07" class="pw-post-body-paragraph ly lz it ma b mb mu ju md me mv jx mg mh mw mj mk ml mx mn mo mp my mr ms mt im bi translated">现在，我将向您展示的是您可以在docker文件中找到的所有关键指令。这将允许你理解和创建基本的Docker文件，而不需要那么多的理论。</p><p id="8f8c" class="pw-post-body-paragraph ly lz it ma b mb mu ju md me mv jx mg mh mw mj mk ml mx mn mo mp my mr ms mt im bi translated">如果你想尝试这些例子，你必须安装Docker。我将在这里讨论的所有指令的概述:</p><ul class=""><li id="e22a" class="ng nh it ma b mb mu me mv mh ni ml nj mp nk mt nl nm nn no bi translated"><code class="fe np nq nr ns b">FROM</code></li><li id="47ad" class="ng nh it ma b mb nt me nu mh nv ml nw mp nx mt nl nm nn no bi translated"><code class="fe np nq nr ns b">RUN</code></li><li id="2d65" class="ng nh it ma b mb nt me nu mh nv ml nw mp nx mt nl nm nn no bi translated"><code class="fe np nq nr ns b">CMD</code></li><li id="1851" class="ng nh it ma b mb nt me nu mh nv ml nw mp nx mt nl nm nn no bi translated"><code class="fe np nq nr ns b">COPY</code></li><li id="329b" class="ng nh it ma b mb nt me nu mh nv ml nw mp nx mt nl nm nn no bi translated"><code class="fe np nq nr ns b">ADD</code></li><li id="3279" class="ng nh it ma b mb nt me nu mh nv ml nw mp nx mt nl nm nn no bi translated"><code class="fe np nq nr ns b">WORKDIR</code></li><li id="ee00" class="ng nh it ma b mb nt me nu mh nv ml nw mp nx mt nl nm nn no bi translated"><code class="fe np nq nr ns b">ENTRYPOINT</code></li><li id="041c" class="ng nh it ma b mb nt me nu mh nv ml nw mp nx mt nl nm nn no bi translated"><code class="fe np nq nr ns b">ENV</code></li><li id="5480" class="ng nh it ma b mb nt me nu mh nv ml nw mp nx mt nl nm nn no bi translated"><code class="fe np nq nr ns b">LABEL</code></li><li id="c113" class="ng nh it ma b mb nt me nu mh nv ml nw mp nx mt nl nm nn no bi translated"><code class="fe np nq nr ns b">HEALTHCHECK</code></li><li id="84d3" class="ng nh it ma b mb nt me nu mh nv ml nw mp nx mt nl nm nn no bi translated"><code class="fe np nq nr ns b">STOPSIGNAL</code></li><li id="b1ca" class="ng nh it ma b mb nt me nu mh nv ml nw mp nx mt nl nm nn no bi translated"><code class="fe np nq nr ns b">VOLUME</code></li><li id="c301" class="ng nh it ma b mb nt me nu mh nv ml nw mp nx mt nl nm nn no bi translated"><code class="fe np nq nr ns b">EXPOSE</code></li></ul></div><div class="ab cl kz la hx lb" role="separator"><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le"/></div><div class="im in io ip iq"><h1 id="5918" class="lg lh it bd li lj lk ll lm ln lo lp lq jz lr ka ls kc lt kd lu kf lv kg lw lx bi translated">从</h1><p id="1888" class="pw-post-body-paragraph ly lz it ma b mb mc ju md me mf jx mg mh mi mj mk ml mm mn mo mp mq mr ms mt im bi translated">几乎你遇到的每一个docker文件都会以下面形式的<code class="fe np nq nr ns b">FROM</code>指令开始:</p><pre class="kj kk kl km gt ny ns nz oa aw ob bi"><span id="86a0" class="oc lh it ns b gy od oe l of og">FROM &lt;image&gt;[:tag]</span></pre><p id="16d4" class="pw-post-body-paragraph ly lz it ma b mb mu ju md me mv jx mg mh mw mj mk ml mx mn mo mp my mr ms mt im bi translated">这条指令将为Dockerfile设置基础映像，这意味着后面的每条指令都适用于这个基础映像。</p><p id="95a4" class="pw-post-body-paragraph ly lz it ma b mb mu ju md me mv jx mg mh mw mj mk ml mx mn mo mp my mr ms mt im bi translated">您可以选择指定Docker在执行<code class="fe np nq nr ns b">docker build</code>命令期间需要使用或提取的特定<code class="fe np nq nr ns b">tag</code>，默认为最新的标签。</p><p id="2a21" class="pw-post-body-paragraph ly lz it ma b mb mu ju md me mv jx mg mh mw mj mk ml mx mn mo mp my mr ms mt im bi translated">您也可以指定多个<code class="fe np nq nr ns b">FROM</code>指令，这被称为多阶段构建，但是我想让事情简单一些，并为那些有兴趣深入研究这个主题的人提供一个到Docker 的<a class="ae ky" href="https://docs.docker.com/develop/develop-images/multistage-build/" rel="noopener ugc nofollow" target="_blank">链接。</a></p><p id="410d" class="pw-post-body-paragraph ly lz it ma b mb mu ju md me mv jx mg mh mw mj mk ml mx mn mo mp my mr ms mt im bi translated">所以，我们先来一个实际的例子！在您的操作系统中的某个位置创建一个文件夹。添加一个空Dockerfile文件(不带扩展名)并添加以下内容:</p><pre class="kj kk kl km gt ny ns nz oa aw ob bi"><span id="2d1f" class="oc lh it ns b gy od oe l of og">FROM ubuntu</span></pre><p id="f198" class="pw-post-body-paragraph ly lz it ma b mb mu ju md me mv jx mg mh mw mj mk ml mx mn mo mp my mr ms mt im bi translated">如前所述，这将从Ubuntu获取最新的基础映像。让我们建立我们的第一个docker文件！为此，我们将使用下面的<code class="fe np nq nr ns b">docker build</code>命令:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi oh"><img src="../Images/6074fa33c13bef3f0400ec133ce8a61d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*-0YDcImqV-DmCp1IdtFEDg.png"/></div></div></figure><p id="3e2d" class="pw-post-body-paragraph ly lz it ma b mb mu ju md me mv jx mg mh mw mj mk ml mx mn mo mp my mr ms mt im bi translated">我们现在已经创建了一个名为<code class="fe np nq nr ns b">demo_docker</code>的Docker图像。<code class="fe np nq nr ns b">-t</code>命令行选项是<code class="fe np nq nr ns b">-tag</code>的简写，并为您的Docker容器命名。</p><p id="8867" class="pw-post-body-paragraph ly lz it ma b mb mu ju md me mv jx mg mh mw mj mk ml mx mn mo mp my mr ms mt im bi translated">我们还指定了<code class="fe np nq nr ns b">.</code>，它只是我们当前文件夹的简写。现在我们有了Docker容器，让我们运行它，看看会发生什么:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi oi"><img src="../Images/ffc756420f01955c1c262bbe7032a707.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*gE0DDblKP8YJ7oJEMc8b7A.png"/></div></div></figure><p id="20c0" class="pw-post-body-paragraph ly lz it ma b mb mu ju md me mv jx mg mh mw mj mk ml mx mn mo mp my mr ms mt im bi translated">这个命令运行Docker容器，并在容器中创建一个交互式的<a class="ae ky" href="https://www.gnu.org/software/bash/manual/html_node/What-is-Bash_003f.html" rel="noopener ugc nofollow" target="_blank">Bash</a>shell(<code class="fe np nq nr ns b">-it</code>)。它还会在退出时自动移除容器(<code class="fe np nq nr ns b">--rm</code>)。</p><p id="e279" class="pw-post-body-paragraph ly lz it ma b mb mu ju md me mv jx mg mh mw mj mk ml mx mn mo mp my mr ms mt im bi translated">要退出Docker容器，我们可以使用简单的<code class="fe np nq nr ns b">exit</code>命令。这就是你如何构建和运行你的第一个Docker容器。我们的命令现在只有一个建造阶段。到目前为止没那么复杂，对吧？</p></div><div class="ab cl kz la hx lb" role="separator"><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le"/></div><div class="im in io ip iq"><h1 id="1b56" class="lg lh it bd li lj lk ll lm ln lo lp lq jz lr ka ls kc lt kd lu kf lv kg lw lx bi translated">奔跑</h1><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi oj"><img src="../Images/40608f9c5dc835bac038e3ed57bd8c76.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*LBG1o1pX1B1uLOQw"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">照片由<a class="ae ky" href="https://unsplash.com/@bruno_nascimento?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">布鲁诺·纳西门托</a>在<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</p></figure><p id="4c87" class="pw-post-body-paragraph ly lz it ma b mb mu ju md me mv jx mg mh mw mj mk ml mx mn mo mp my mr ms mt im bi translated">这个指令做它所说的，它运行命令。或者更具体地说，它执行特定的命令。使用多行<code class="fe np nq nr ns b">RUN</code>来执行多个命令是可能的，但是我建议在一行中合并尽可能多的命令。</p><p id="e1c2" class="pw-post-body-paragraph ly lz it ma b mb mu ju md me mv jx mg mh mw mj mk ml mx mn mo mp my mr ms mt im bi translated">这里有一个重要的原因:层缓存。如果一个图层被缓存，而另一个没有，您可能会处于与预期不同的状态。这会导致一片混乱。阅读更多关于Dockerfile的Dockerfile最佳实践<a class="ae ky" href="https://docs.docker.com/develop/develop-images/dockerfile_best-practices/" rel="noopener ugc nofollow" target="_blank">。</a></p><p id="ab3f" class="pw-post-body-paragraph ly lz it ma b mb mu ju md me mv jx mg mh mw mj mk ml mx mn mo mp my mr ms mt im bi translated">现在，让我们举个例子，把下面几行放到你的docker文件里。<code class="fe np nq nr ns b">apt-get update</code>命令从存储库中下载包列表，并更新它们以获得关于最新版本的包及其依赖项的信息。</p><p id="0ac7" class="pw-post-body-paragraph ly lz it ma b mb mu ju md me mv jx mg mh mw mj mk ml mx mn mo mp my mr ms mt im bi translated">之后，我们安装了我当前操作系统中没有安装的tree命令。即使在构建并运行Docker容器之后，也不会。只影响Docker形象。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ok"><img src="../Images/7ad5ab5f7d75d4ad4ac6310d906f74c5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*kO38-z2L2GGe8fkUNjs0RA.png"/></div></div></figure><p id="936d" class="pw-post-body-paragraph ly lz it ma b mb mu ju md me mv jx mg mh mw mj mk ml mx mn mo mp my mr ms mt im bi translated">现在让我们像前面一样运行<code class="fe np nq nr ns b">build</code>命令:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ol"><img src="../Images/9e6d7c31abd910e2c19680a8c83b20b0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*JrpM_acMKUYZ0spScMBWIQ.png"/></div></div></figure><p id="ab62" class="pw-post-body-paragraph ly lz it ma b mb mu ju md me mv jx mg mh mw mj mk ml mx mn mo mp my mr ms mt im bi translated">然后，我们像前面一样运行Docker容器:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ol"><img src="../Images/38082efabca108e60d1ed4dfd4d8f03b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*1riIczXrGalgiZvLmPJIvA.png"/></div></div></figure><p id="2cac" class="pw-post-body-paragraph ly lz it ma b mb mu ju md me mv jx mg mh mw mj mk ml mx mn mo mp my mr ms mt im bi translated">我们转到主文件夹，创建一个包含四个文件夹的目录结构，然后我们在目录<code class="fe np nq nr ns b">d</code>中创建一个文件。如果我们现在运行tree命令，我们将得到目录结构的概述，看起来有点像下图。</p><p id="6314" class="pw-post-body-paragraph ly lz it ma b mb mu ju md me mv jx mg mh mw mj mk ml mx mn mo mp my mr ms mt im bi translated">之后，我们退出Docker容器，它又消失了。这就是我如何断定<code class="fe np nq nr ns b">RUN</code>指令非常容易使用的原因。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi om"><img src="../Images/e0419a2f5aae4817f650cf38bc28004e.png" data-original-src="https://miro.medium.com/v2/resize:fit:772/format:webp/1*gmOjakj6nXrzT4l1iPp3HQ.png"/></div></figure></div><div class="ab cl kz la hx lb" role="separator"><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le"/></div><div class="im in io ip iq"><h1 id="4662" class="lg lh it bd li lj lk ll lm ln lo lp lq jz lr ka ls kc lt kd lu kf lv kg lw lx bi translated">煤矿管理局</h1><p id="a23b" class="pw-post-body-paragraph ly lz it ma b mb mc ju md me mf jx mg mh mi mj mk ml mm mn mo mp mq mr ms mt im bi translated"><code class="fe np nq nr ns b">CMD</code>指令设置了一个默认命令，当您运行Docker镜像而没有指定命令时，该命令将被执行。这允许您执行以下操作，例如:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi on"><img src="../Images/162fcc8826d8c58cfc639de062f880e5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*OCmd2AyeNa0uR-NJODqo_Q.png"/></div></div></figure><p id="97cf" class="pw-post-body-paragraph ly lz it ma b mb mu ju md me mv jx mg mh mw mj mk ml mx mn mo mp my mr ms mt im bi translated">构建并再次运行Docker。您可能已经注意到，也可以依次运行不同的命令。我带你去看。</p><p id="8805" class="pw-post-body-paragraph ly lz it ma b mb mu ju md me mv jx mg mh mw mj mk ml mx mn mo mp my mr ms mt im bi translated">如果您通过在不同的行上指定每个指令来做同样的事情，那么只有最后一条指令会被执行。如果你想看实际操作，你可以自己尝试一下。</p><p id="e645" class="pw-post-body-paragraph ly lz it ma b mb mu ju md me mv jx mg mh mw mj mk ml mx mn mo mp my mr ms mt im bi translated">还可以向Docker映像提供不同的命令，该命令将被执行，而不是Docker文件中的指令中指定的命令。我举两个例子:</p><ul class=""><li id="7a3c" class="ng nh it ma b mb mu me mv mh ni ml nj mp nk mt nl nm nn no bi translated">第一个命令通过指定<code class="fe np nq nr ns b">/bin/bash</code>来启动Bash解释器。</li><li id="e150" class="ng nh it ma b mb nt me nu mh nv ml nw mp nx mt nl nm nn no bi translated">第二个命令告诉你“嗨”。</li></ul><p id="2462" class="pw-post-body-paragraph ly lz it ma b mb mu ju md me mv jx mg mh mw mj mk ml mx mn mo mp my mr ms mt im bi translated">这涵盖了<code class="fe np nq nr ns b">CMD</code>指令的基础知识。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi oo"><img src="../Images/c5fc681a9c1d342ec5d5b7e09db998a6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*DdzmP0TMSaYcFmxSc9RN2Q.png"/></div></div></figure></div><div class="ab cl kz la hx lb" role="separator"><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le"/></div><div class="im in io ip iq"><h1 id="b2b6" class="lg lh it bd li lj lk ll lm ln lo lp lq jz lr ka ls kc lt kd lu kf lv kg lw lx bi translated">复制</h1><p id="a4b2" class="pw-post-body-paragraph ly lz it ma b mb mc ju md me mf jx mg mh mi mj mk ml mm mn mo mp mq mr ms mt im bi translated"><code class="fe np nq nr ns b">COPY</code>指令将本地机器上的一个文件夹复制到Docker映像中。当Docker映像启动并运行时，您也会在映像中看到该文件夹。让我们通过一个例子来看看我们是如何做到这一点的:</p><p id="1678" class="pw-post-body-paragraph ly lz it ma b mb mu ju md me mv jx mg mh mw mj mk ml mx mn mo mp my mr ms mt im bi translated">首先，我们需要创建一个Dockerfile文件:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi op"><img src="../Images/1b9b6f575938dab9dd799e45aa2fd780.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ruw0H7zByhtD3_X8_CH7Hg.png"/></div></div></figure><p id="9b97" class="pw-post-body-paragraph ly lz it ma b mb mu ju md me mv jx mg mh mw mj mk ml mx mn mo mp my mr ms mt im bi translated">我来解释一下<code class="fe np nq nr ns b">COPY</code>指令。这里我们说我们将把awesome文件夹的内容(里面有一个文件<code class="fe np nq nr ns b">wow.html</code>)复制到Docker容器的根文件夹里面的awesome文件夹中。</p><p id="f517" class="pw-post-body-paragraph ly lz it ma b mb mu ju md me mv jx mg mh mw mj mk ml mx mn mo mp my mr ms mt im bi translated">如果我们指定了一些子文件夹，这个命令也会自动复制子文件夹。为了防止一些文件夹或文件被复制，你可以在一个<a class="ae ky" href="https://docs.docker.com/engine/reference/builder/" rel="noopener ugc nofollow" target="_blank"> docker忽略文件</a>中指定它们。我将创建一个<code class="fe np nq nr ns b">docker_copy</code>容器，向您展示它的样子:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi oq"><img src="../Images/cc16b6a889526f823aaad604f8e3fd1a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*M2LiSepxRlJkTFQ-5LIxxg.png"/></div></div></figure><p id="b383" class="pw-post-body-paragraph ly lz it ma b mb mu ju md me mv jx mg mh mw mj mk ml mx mn mo mp my mr ms mt im bi translated">请记住:<strong class="ma iu"> </strong>源路径必须在构建的上下文中。<strong class="ma iu"> </strong>你不能写<code class="fe np nq nr ns b">COPY ../folder2</code>，因为在<code class="fe np nq nr ns b">docker build</code>的第一步，上下文目录和子目录被发送到Docker守护进程。</p></div><div class="ab cl kz la hx lb" role="separator"><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le"/></div><div class="im in io ip iq"><h1 id="bb6b" class="lg lh it bd li lj lk ll lm ln lo lp lq jz lr ka ls kc lt kd lu kf lv kg lw lx bi translated">注意缺陷障碍 (Attention Deficit Disorder)</h1><p id="361b" class="pw-post-body-paragraph ly lz it ma b mb mc ju md me mf jx mg mh mi mj mk ml mm mn mo mp mq mr ms mt im bi translated"><code class="fe np nq nr ns b">COPY</code>和<code class="fe np nq nr ns b">ADD</code>的作用类似。它们都允许您将文件从特定位置复制到Docker映像中。<code class="fe np nq nr ns b">ADD</code>指令允许您执行与<code class="fe np nq nr ns b">COPY</code>指令相同的操作，但是除此之外，它还支持另外两个源:</p><ul class=""><li id="8ffe" class="ng nh it ma b mb mu me mv mh ni ml nj mp nk mt nl nm nn no bi translated">您可以直接从源代码中提取TAR文件。</li><li id="5d87" class="ng nh it ma b mb nt me nu mh nv ml nw mp nx mt nl nm nn no bi translated">您可以使用URL代替本地文件目录。</li></ul><h2 id="eda5" class="oc lh it bd li or os dn lm ot ou dp lq mh ov ow ls ml ox oy lu mp oz pa lw pb bi translated">提取一个TAR文件</h2><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi pc"><img src="../Images/a73164eef08ea680b28b99e7b71b09cc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*QewfSKE8s64ssaMc-V6c9Q.png"/></div></div></figure><p id="88ed" class="pw-post-body-paragraph ly lz it ma b mb mu ju md me mv jx mg mh mw mj mk ml mx mn mo mp my mr ms mt im bi translated">让我们运行<code class="fe np nq nr ns b">build</code>和<code class="fe np nq nr ns b">run</code>命令来检查发生了什么:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi pd"><img src="../Images/9bfe4a226a490faf839a96c84c6027aa.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*MzOg8dodiI-w-vOHkLUvgQ.png"/></div></div></figure><p id="ed65" class="pw-post-body-paragraph ly lz it ma b mb mu ju md me mv jx mg mh mw mj mk ml mx mn mo mp my mr ms mt im bi translated"><code class="fe np nq nr ns b">ADD</code>指令允许你指定你想要它的位置，所以你可以说把它复制到根文件夹里面。它与常规的<code class="fe np nq nr ns b">ADD</code>或<code class="fe np nq nr ns b">COMMAND</code>指令略有不同，因为您没有指定结果文件夹的名称。</p><h2 id="3ea2" class="oc lh it bd li or os dn lm ot ou dp lq mh ov ow ls ml ox oy lu mp oz pa lw pb bi translated">使用URL</h2><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi pe"><img src="../Images/bd1f1f849346c665cfe676404df65c59.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*upqk8Stj3KrhywV2n8IhdQ.png"/></div></div></figure><p id="d83c" class="pw-post-body-paragraph ly lz it ma b mb mu ju md me mv jx mg mh mw mj mk ml mx mn mo mp my mr ms mt im bi translated">现在让我们构建并再次运行它:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi pf"><img src="../Images/00e746b0db5051e5ea125d0e2eb72868.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*aHYiCO8H7_0F_QDqTdpwbQ.png"/></div></div></figure><p id="b395" class="pw-post-body-paragraph ly lz it ma b mb mu ju md me mv jx mg mh mw mj mk ml mx mn mo mp my mr ms mt im bi translated">我第一次想到的是“这太出乎意料了”。但是它做了它应该做的事情。</p><p id="0628" class="pw-post-body-paragraph ly lz it ma b mb mu ju md me mv jx mg mh mw mj mk ml mx mn mo mp my mr ms mt im bi translated">根据<a class="ae ky" href="https://docs.docker.com/engine/reference/builder/" rel="noopener ugc nofollow" target="_blank">文档</a>，当<code class="fe np nq nr ns b">&lt;src&gt;</code>是一个URL并且<code class="fe np nq nr ns b">&lt;dest&gt;</code>确实以一个结尾斜杠结束时，那么从URL中推断出文件名并且文件被下载到<code class="fe np nq nr ns b">&lt;dest&gt;/&lt;filename&gt;</code>。</p><p id="766a" class="pw-post-body-paragraph ly lz it ma b mb mu ju md me mv jx mg mh mw mj mk ml mx mn mo mp my mr ms mt im bi translated">使用<code class="fe np nq nr ns b">ADD</code>指令时，请记住这一点。如果你想下载不止一个文件，我推荐你使用curl下载。</p></div><div class="ab cl kz la hx lb" role="separator"><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le"/></div><div class="im in io ip iq"><h1 id="f41d" class="lg lh it bd li lj lk ll lm ln lo lp lq jz lr ka ls kc lt kd lu kf lv kg lw lx bi translated">工作方向</h1><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi pg"><img src="../Images/70d18c4af194c23922f5f13b5fd37c34.png" data-original-src="https://miro.medium.com/v2/resize:fit:1346/format:webp/1*_lGB0GnNtDKkG1qVeZ3mjg.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated"><a class="ae ky" href="https://www.educative.io/edpresso/what-is-the-workdir-command-in-docker" rel="noopener ugc nofollow" target="_blank">工作指令</a>指令的受影响指令</p></figure><p id="e1cc" class="pw-post-body-paragraph ly lz it ma b mb mu ju md me mv jx mg mh mw mj mk ml mx mn mo mp my mr ms mt im bi translated"><code class="fe np nq nr ns b">WORKDIR</code>指令用于在任何给定时间定义Docker容器的工作目录。该命令在Dockerfile文件中指定。</p><p id="6666" class="pw-post-body-paragraph ly lz it ma b mb mu ju md me mv jx mg mh mw mj mk ml mx mn mo mp my mr ms mt im bi translated">任何连续的<code class="fe np nq nr ns b">RUN</code>、<code class="fe np nq nr ns b">CMD</code>、<code class="fe np nq nr ns b">ADD</code>、<code class="fe np nq nr ns b">COPY</code>或<code class="fe np nq nr ns b">ENTRYPOINT</code>指令都将在指定的工作目录中执行。我首先给你一个没有<code class="fe np nq nr ns b">WORKDIR</code>指令的例子:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ph"><img src="../Images/7e62a6fa0676e8dade1bff86ba42b316.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*AMTVeKAXGIUOQbJPZGGtMw.png"/></div></div></figure><p id="c212" class="pw-post-body-paragraph ly lz it ma b mb mu ju md me mv jx mg mh mw mj mk ml mx mn mo mp my mr ms mt im bi translated">这个Dockerfile文件的问题在于重复的数量。在每条指令中，我们都明确指定了根文件夹。在最后两个命令中，我们甚至需要在根文件夹中指定一个子文件夹。</p><p id="5008" class="pw-post-body-paragraph ly lz it ma b mb mu ju md me mv jx mg mh mw mj mk ml mx mn mo mp my mr ms mt im bi translated">这只是一个小例子，但是只要指定一次当前工作文件夹就很好了。<code class="fe np nq nr ns b">WORKDIR</code>指令正是为我们做的。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi oq"><img src="../Images/24d8b1eee7250a53321c8a3fd892992d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*dR-YggxMTZQWJ8aN32jBxw.png"/></div></div></figure><p id="2dfe" class="pw-post-body-paragraph ly lz it ma b mb mu ju md me mv jx mg mh mw mj mk ml mx mn mo mp my mr ms mt im bi translated">Docker构建和运行步骤完全按照我们的要求去做。然而，我们希望避免重复，所以在下一个docker文件中，我们指定我们的根文件夹是我们当前的工作目录。</p><p id="d63e" class="pw-post-body-paragraph ly lz it ma b mb mu ju md me mv jx mg mh mw mj mk ml mx mn mo mp my mr ms mt im bi translated">我们甚至在稍后指定另一个工作目录，这是通过指定<code class="fe np nq nr ns b">/root/a</code>文件夹来实现的。<code class="fe np nq nr ns b">WORKDIR</code>指令提高了Dockerfile文件的可读性，并避免了重复。</p><p id="2abb" class="pw-post-body-paragraph ly lz it ma b mb mu ju md me mv jx mg mh mw mj mk ml mx mn mo mp my mr ms mt im bi translated">当工作目录的位置在开发过程中改变时，改变每一条指令会变得有点困难。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi pi"><img src="../Images/c25b211ee081f171c4b87d855ea29f23.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*LFI4Q84X3da-7R96pdGfqQ.png"/></div></div></figure><p id="ded7" class="pw-post-body-paragraph ly lz it ma b mb mu ju md me mv jx mg mh mw mj mk ml mx mn mo mp my mr ms mt im bi translated">上面的Dockerfile文件现在将导致构建过程中的九个步骤。结果和前面的例子一样，所以我把它省略了。但是你可以自己尝试一下！</p><p id="9ba9" class="pw-post-body-paragraph ly lz it ma b mb mu ju md me mv jx mg mh mw mj mk ml mx mn mo mp my mr ms mt im bi translated">这里我们唯一的不同是，当我们开始运行Docker容器时，我们将在<code class="fe np nq nr ns b">/root/a</code>文件夹中。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi pj"><img src="../Images/498eed6bc9dd82df6cdb67179366977c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*0u0d6CH_DrOKntlnz2syfw.png"/></div></div></figure><p id="110f" class="pw-post-body-paragraph ly lz it ma b mb mu ju md me mv jx mg mh mw mj mk ml mx mn mo mp my mr ms mt im bi translated">这就结束了<code class="fe np nq nr ns b">WORKDIR</code>指令。大多数情况下，您将使用它来指定执行<code class="fe np nq nr ns b">build</code>或<code class="fe np nq nr ns b">test</code>命令的文件夹。</p></div><div class="ab cl kz la hx lb" role="separator"><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le"/></div><div class="im in io ip iq"><h1 id="695c" class="lg lh it bd li lj lk ll lm ln lo lp lq jz lr ka ls kc lt kd lu kf lv kg lw lx bi translated">入口点</h1><p id="9947" class="pw-post-body-paragraph ly lz it ma b mb mc ju md me mf jx mg mh mi mj mk ml mm mn mo mp mq mr ms mt im bi translated">docker文件的<code class="fe np nq nr ns b">ENTRYPOINT</code>指令乍一看与<code class="fe np nq nr ns b">CMD</code>指令相似。它指定了运行时要执行的默认命令，并且您不能覆盖它。</p><p id="443b" class="pw-post-body-paragraph ly lz it ma b mb mu ju md me mv jx mg mh mw mj mk ml mx mn mo mp my mr ms mt im bi translated">所以，我的建议是，如果你想指定一个在容器启动后运行的命令，并且不希望用户覆盖它，那么使用<code class="fe np nq nr ns b">ENTRYPOINT</code>。</p><pre class="kj kk kl km gt ny ns nz oa aw ob bi"><span id="31a8" class="oc lh it ns b gy od oe l of og">FROM ubuntu<br/>ENTRYPOINT ls</span></pre><p id="8a50" class="pw-post-body-paragraph ly lz it ma b mb mu ju md me mv jx mg mh mw mj mk ml mx mn mo mp my mr ms mt im bi translated">上面的Dockerfile文件导致下面的构建和运行。如您所见，<code class="fe np nq nr ns b">pwd</code>命令没有覆盖does文件中的<code class="fe np nq nr ns b">ls</code>命令。这与<code class="fe np nq nr ns b">CMD</code>指令不同。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi pk"><img src="../Images/398ab10b201c6853b2de8c9f78d4d236.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*2jEAb0C410ZbkFqk8R-YZg.png"/></div></div></figure></div><div class="ab cl kz la hx lb" role="separator"><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le"/></div><div class="im in io ip iq"><h1 id="52d4" class="lg lh it bd li lj lk ll lm ln lo lp lq jz lr ka ls kc lt kd lu kf lv kg lw lx bi translated">包封/包围（动词envelop的简写）</h1><p id="a20b" class="pw-post-body-paragraph ly lz it ma b mb mc ju md me mf jx mg mh mi mj mk ml mm mn mo mp mq mr ms mt im bi translated"><code class="fe np nq nr ns b">ENV</code>指令允许您为Docker容器设置环境变量。</p><blockquote class="mz na nb"><p id="db90" class="ly lz nc ma b mb mu ju md me mv jx mg nd mw mj mk ne mx mn mo nf my mr ms mt im bi translated">环境变量是一个动态命名的值，它可以影响计算机上正在运行的进程的行为方式。它们是流程运行环境的一部分。— <a class="ae ky" href="https://en.wikipedia.org/wiki/Environment_variable" rel="noopener ugc nofollow" target="_blank">维基百科</a></p></blockquote><p id="77a6" class="pw-post-body-paragraph ly lz it ma b mb mu ju md me mv jx mg mh mw mj mk ml mx mn mo mp my mr ms mt im bi translated">大多数程序员都很熟悉环境变量，所以我在这里就不赘述了。我只举一个Dockerfile的例子，我会讨论发生了什么。</p><pre class="kj kk kl km gt ny ns nz oa aw ob bi"><span id="0321" class="oc lh it ns b gy od oe l of og">FROM ubuntu<br/>ENV workdir=/root/<br/>CMD echo $workdir</span></pre><p id="b8ac" class="pw-post-body-paragraph ly lz it ma b mb mu ju md me mv jx mg mh mw mj mk ml mx mn mo mp my mr ms mt im bi translated">所以，我在这里做的是使用<code class="fe np nq nr ns b">ENV</code>指令创建一个环境变量<code class="fe np nq nr ns b">workdir</code>。这允许我在容器运行的任何时候使用它。</p><p id="d3d3" class="pw-post-body-paragraph ly lz it ma b mb mu ju md me mv jx mg mh mw mj mk ml mx mn mo mp my mr ms mt im bi translated">在本例中，我将使用美元符号前缀输出环境变量。当构建和运行容器时，您会看到<code class="fe np nq nr ns b">root</code>目录被打印到控制台。这是一个非常有用的指令。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi pd"><img src="../Images/eb417bfea0bf9dc87e80f9f2bf07bdd5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*C7hH7M87JnqvmRVIFcMxzg.png"/></div></div></figure></div><div class="ab cl kz la hx lb" role="separator"><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le"/></div><div class="im in io ip iq"><h1 id="7596" class="lg lh it bd li lj lk ll lm ln lo lp lq jz lr ka ls kc lt kd lu kf lv kg lw lx bi translated">标签</h1><p id="f2b2" class="pw-post-body-paragraph ly lz it ma b mb mc ju md me mf jx mg mh mi mj mk ml mm mn mo mp mq mr ms mt im bi translated"><code class="fe np nq nr ns b">LABEL</code>指令允许您向图像添加元数据。它总是一个键值对，建议将标签值放在引号中。</p><p id="acd6" class="pw-post-body-paragraph ly lz it ma b mb mu ju md me mv jx mg mh mw mj mk ml mx mn mo mp my mr ms mt im bi translated">我将给出一个使用<code class="fe np nq nr ns b">LABEL</code>指令的Dockerfile文件的简单例子:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi pl"><img src="../Images/3aba8ae0ed926eb49915a84665720605.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*yAGWcnGH5rJoljwDszjv4g.png"/></div></div></figure><p id="fab9" class="pw-post-body-paragraph ly lz it ma b mb mu ju md me mv jx mg mh mw mj mk ml mx mn mo mp my mr ms mt im bi translated">当您运行常用的<code class="fe np nq nr ns b">build</code>和<code class="fe np nq nr ns b">run</code>命令时，此Docker会变为活动状态:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi pm"><img src="../Images/c1944b95fcd122131bac40daa70a254d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*uOzgqIyS-zSJj0H-sMHpWA.png"/></div></div></figure><p id="442b" class="pw-post-body-paragraph ly lz it ma b mb mu ju md me mv jx mg mh mw mj mk ml mx mn mo mp my mr ms mt im bi translated">当使用命令行运行容器时，也可以指定一个<code class="fe np nq nr ns b">LABEL</code>指令。当有很多正在运行的容器时，<code class="fe np nq nr ns b">LABEL</code>指令允许你搜索特定的键。</p><p id="42b1" class="pw-post-body-paragraph ly lz it ma b mb mu ju md me mv jx mg mh mw mj mk ml mx mn mo mp my mr ms mt im bi translated">它还可以给你更多的关于Docker图像、作者或更多东西的信息。我同意这不是最令人兴奋的功能。例如，您还可以在标签上过滤活动容器:</p><pre class="kj kk kl km gt ny ns nz oa aw ob bi"><span id="d8ad" class="oc lh it ns b gy od oe l of og"><strong class="ns iu">docker images --filter label=description="Baby don't hurt me."</strong><br/>ID: 2de9f0eddcfd</span></pre></div><div class="ab cl kz la hx lb" role="separator"><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le"/></div><div class="im in io ip iq"><h1 id="ada3" class="lg lh it bd li lj lk ll lm ln lo lp lq jz lr ka ls kc lt kd lu kf lv kg lw lx bi translated">健康检查</h1><p id="2924" class="pw-post-body-paragraph ly lz it ma b mb mc ju md me mf jx mg mh mi mj mk ml mm mn mo mp mq mr ms mt im bi translated"><code class="fe np nq nr ns b">HEALTHCHECK</code>指令告诉Docker如何测试一个容器来检查它是否还在工作。为了解释<code class="fe np nq nr ns b">HEALTHCHECK</code>指令，我将首先创建一个Dockerfile:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi pn"><img src="../Images/122803287554807a76295c7f8923929c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*KPLZfRgvnpemD17t1-5HbA.png"/></div></div></figure><p id="c0ff" class="pw-post-body-paragraph ly lz it ma b mb mu ju md me mv jx mg mh mw mj mk ml mx mn mo mp my mr ms mt im bi translated">让我解释一下不同的<a class="ae ky" href="https://docs.docker.com/engine/reference/builder/#healthcheck" rel="noopener ugc nofollow" target="_blank">参数</a>:</p><ul class=""><li id="6ad2" class="ng nh it ma b mb mu me mv mh ni ml nj mp nk mt nl nm nn no bi translated"><code class="fe np nq nr ns b">interval</code>(默认为30秒):健康检查将在容器启动后首先运行5秒钟，然后在每次检查完成后5秒钟再次运行。</li><li id="c11c" class="ng nh it ma b mb nt me nu mh nv ml nw mp nx mt nl nm nn no bi translated"><code class="fe np nq nr ns b">timeout</code>(默认为30秒):如果一次检查耗时超过3秒，则认为检查失败。</li><li id="20ee" class="ng nh it ma b mb nt me nu mh nv ml nw mp nx mt nl nm nn no bi translated"><code class="fe np nq nr ns b">retries</code>(默认为三次):容器的健康检查连续两次失败才被视为不健康。</li><li id="a5db" class="ng nh it ma b mb nt me nu mh nv ml nw mp nx mt nl nm nn no bi translated">命令:检查<code class="fe np nq nr ns b">nope</code>目录是否存在，否则<code class="fe np nq nr ns b">exit</code>出错。</li></ul><p id="6b8b" class="pw-post-body-paragraph ly lz it ma b mb mu ju md me mv jx mg mh mw mj mk ml mx mn mo mp my mr ms mt im bi translated">让我们开始构建我们的Docker容器:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi po"><img src="../Images/d0ddb07113f4fee933c38a348e902a01.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*W-Fsc76xqVw6orwh9wWBFw.png"/></div></div></figure><p id="8847" class="pw-post-body-paragraph ly lz it ma b mb mu ju md me mv jx mg mh mw mj mk ml mx mn mo mp my mr ms mt im bi translated">当我们打开一个不同的码头，我们可以检查运行码头集装箱。前十秒，容器无法意识到是不健康还是健康。</p><p id="9980" class="pw-post-body-paragraph ly lz it ma b mb mu ju md me mv jx mg mh mw mj mk ml mx mn mo mp my mr ms mt im bi translated">两次重试后，这成为可能，我们看到11秒后<code class="fe np nq nr ns b">HEALTHCHECK</code>得出结论，它不是不健康的。事实的确如此，因为文件夹<code class="fe np nq nr ns b">nope</code>从不存在于Ubuntu的基础映像中。</p><pre class="kj kk kl km gt ny ns nz oa aw ob bi"><span id="3ac3" class="oc lh it ns b gy od oe l of og"><strong class="ns iu">docker ps</strong><br/>Status: Up 5 seconds (health: starting)<br/><strong class="ns iu">docker ps</strong><br/>Status: Up 9 seconds (health: starting)<br/><strong class="ns iu">docker ps</strong><br/>Status: Up 11 seconds (unhealthy)</span></pre><p id="168c" class="pw-post-body-paragraph ly lz it ma b mb mu ju md me mv jx mg mh mw mj mk ml mx mn mo mp my mr ms mt im bi translated">当我在Docker容器中运行<code class="fe np nq nr ns b">mkdir nope</code>时，状态将变得健康。在等待一会儿直到第一次健康检查成功之后，我现在再次运行Docker <code class="fe np nq nr ns b">ps</code>命令。</p><p id="fbb8" class="pw-post-body-paragraph ly lz it ma b mb mu ju md me mv jx mg mh mw mj mk ml mx mn mo mp my mr ms mt im bi translated">您会注意到，当Docker容器之间存在依赖关系时(例如，在执行数据库查询之前等待数据库启动)，这个命令非常有用。</p><pre class="kj kk kl km gt ny ns nz oa aw ob bi"><span id="4550" class="oc lh it ns b gy od oe l of og"><strong class="ns iu">docker ps</strong><br/>Status: Up About a minute (healthy)</span></pre></div><div class="ab cl kz la hx lb" role="separator"><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le"/></div><div class="im in io ip iq"><h1 id="d831" class="lg lh it bd li lj lk ll lm ln lo lp lq jz lr ka ls kc lt kd lu kf lv kg lw lx bi translated">停止信号</h1><p id="5d77" class="pw-post-body-paragraph ly lz it ma b mb mc ju md me mf jx mg mh mi mj mk ml mm mn mo mp mq mr ms mt im bi translated">如果你曾经试图用<code class="fe np nq nr ns b">docker stop</code>命令杀死一个Docker容器，你可能会注意到Docker会首先友好地请求进程停止，如果它在10秒内不同意，它将强行杀死它。这是因为Docker容器的默认<code class="fe np nq nr ns b">STOPSIGNAL</code>是一个<code class="fe np nq nr ns b">SIGTERM</code>信号。</p><p id="2ac3" class="pw-post-body-paragraph ly lz it ma b mb mu ju md me mv jx mg mh mw mj mk ml mx mn mo mp my mr ms mt im bi translated">您可以通过将<code class="fe np nq nr ns b">STOPSIGNAL</code>指令指定为<code class="fe np nq nr ns b">SIGKILL</code>来改变这一点。当您在容器上运行<code class="fe np nq nr ns b">docker stop</code>时，Docker容器将立即关闭。</p><p id="34c9" class="pw-post-body-paragraph ly lz it ma b mb mu ju md me mv jx mg mh mw mj mk ml mx mn mo mp my mr ms mt im bi translated">该过程立即终止。要自己检查这一点，请使用下面的Dockerfile文件。</p><pre class="kj kk kl km gt ny ns nz oa aw ob bi"><span id="f603" class="oc lh it ns b gy od oe l of og">FROM ubuntu<br/>STOPSIGNAL SIGKILL</span></pre><p id="2273" class="pw-post-body-paragraph ly lz it ma b mb mu ju md me mv jx mg mh mw mj mk ml mx mn mo mp my mr ms mt im bi translated">让我们构建并启动容器:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi pj"><img src="../Images/011f1f8318fae5041e742a78c36caf88.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*g-ST7ecAy1b7Pzyk7yooVg.png"/></div></div></figure><p id="ca21" class="pw-post-body-paragraph ly lz it ma b mb mu ju md me mv jx mg mh mw mj mk ml mx mn mo mp my mr ms mt im bi translated">现在打开一个新的终端并执行以下步骤:</p><pre class="kj kk kl km gt ny ns nz oa aw ob bi"><span id="c605" class="oc lh it ns b gy od oe l of og">docker ps</span></pre><p id="9f87" class="pw-post-body-paragraph ly lz it ma b mb mu ju md me mv jx mg mh mw mj mk ml mx mn mo mp my mr ms mt im bi translated">有一个标识符为<code class="fe np nq nr ns b">50b3f43b5588</code>的运行容器。</p><pre class="kj kk kl km gt ny ns nz oa aw ob bi"><span id="ad1c" class="oc lh it ns b gy od oe l of og">docker stop 50b3f43b5588</span></pre><p id="002e" class="pw-post-body-paragraph ly lz it ma b mb mu ju md me mv jx mg mh mw mj mk ml mx mn mo mp my mr ms mt im bi translated">现在没有容器在运行，因为目标Docker容器立即退出。</p></div><div class="ab cl kz la hx lb" role="separator"><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le"/></div><div class="im in io ip iq"><h1 id="d6b5" class="lg lh it bd li lj lk ll lm ln lo lp lq jz lr ka ls kc lt kd lu kf lv kg lw lx bi translated">卷</h1><p id="841f" class="pw-post-body-paragraph ly lz it ma b mb mc ju md me mf jx mg mh mi mj mk ml mm mn mo mp mq mr ms mt im bi translated">让我们创建一个Dockerfile，将根文件夹指定为一个卷。在我们最初的图像中，根文件夹中会有一个<code class="fe np nq nr ns b">hello.txt</code>。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi pp"><img src="../Images/b930d65457bc0c351ad051ee8677f311.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*UNLjdbANFeKhbdSNEJ8DiA.png"/></div></div></figure><p id="834b" class="pw-post-body-paragraph ly lz it ma b mb mu ju md me mv jx mg mh mw mj mk ml mx mn mo mp my mr ms mt im bi translated">现在让我们通过创建一个Docker映像，添加一个新的<code class="fe np nq nr ns b">answer.txt</code>文件来增加趣味。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi pq"><img src="../Images/40f6ea01e355b20cc0276a0c8108a534.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*0zbB5BVxy4SXAue0DpEdlw.png"/></div></div></figure><p id="1c38" class="pw-post-body-paragraph ly lz it ma b mb mu ju md me mv jx mg mh mw mj mk ml mx mn mo mp my mr ms mt im bi translated"><code class="fe np nq nr ns b">--volumes-from</code>参数允许我们使用不同容器的容量，因此允许我们在容器之间保存数据。</p></div><div class="ab cl kz la hx lb" role="separator"><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le"/></div><div class="im in io ip iq"><h1 id="dd7a" class="lg lh it bd li lj lk ll lm ln lo lp lq jz lr ka ls kc lt kd lu kf lv kg lw lx bi translated">揭露</h1><p id="cdc3" class="pw-post-body-paragraph ly lz it ma b mb mc ju md me mf jx mg mh mi mj mk ml mm mn mo mp mq mr ms mt im bi translated"><code class="fe np nq nr ns b">EXPOSE</code>指令通知Docker容器在运行时监听特定的网络端口。您还可以指定端口是侦听TCP还是UDP(默认为TCP)。</p><p id="41a3" class="pw-post-body-paragraph ly lz it ma b mb mu ju md me mv jx mg mh mw mj mk ml mx mn mo mp my mr ms mt im bi translated">公开端口是记录使用了哪些端口的一种方式，但不映射或打开任何端口。暴露端口是可选的。默认情况下，当您创建一个容器时，它不会向外界发布它的任何端口。</p><p id="1b3e" class="pw-post-body-paragraph ly lz it ma b mb mu ju md me mv jx mg mh mw mj mk ml mx mn mo mp my mr ms mt im bi translated">要使一个端口对Docker之外的服务可用，或者对没有连接到容器网络的Docker容器可用，使用<code class="fe np nq nr ns b">--publish</code>或<code class="fe np nq nr ns b">-p</code>标志。这将容器端口映射到Docker主机上的一个端口。</p></div><div class="ab cl kz la hx lb" role="separator"><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le"/></div><div class="im in io ip iq"><h1 id="f679" class="lg lh it bd li lj lk ll lm ln lo lp lq jz lr ka ls kc lt kd lu kf lv kg lw lx bi translated">结论</h1><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi pr"><img src="../Images/cfe4ce56d3068ba3c156ba68fe481b07.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*bAWuOo9SowtCJtpC"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated"><a class="ae ky" href="https://unsplash.com/@jpvalery?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Jp瓦列里</a>在<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的照片</p></figure><p id="c024" class="pw-post-body-paragraph ly lz it ma b mb mu ju md me mv jx mg mh mw mj mk ml mx mn mo mp my mr ms mt im bi translated">原来如此。我已经介绍了最重要的Docker指令。</p><p id="55db" class="pw-post-body-paragraph ly lz it ma b mb mu ju md me mv jx mg mh mw mj mk ml mx mn mo mp my mr ms mt im bi translated">如果你错过了什么，请看看Docker <a class="ae ky" href="https://docs.docker.com/engine/reference/builder/#onbuild" rel="noopener ugc nofollow" target="_blank">文档</a>。我相信你会在这里找到你想要的一切。你应该知道足够开始。我会说:“去创造吧！”</p></div></div>    
</body>
</html>