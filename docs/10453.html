<html>
<head>
<title>6 Java 17 Features I Didn’t Know About</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">我不知道的6个Java 17特性</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/6-things-i-didnt-know-about-java-17-dccd36abaa06?source=collection_archive---------8-----------------------#2022-01-08">https://betterprogramming.pub/6-things-i-didnt-know-about-java-17-dccd36abaa06?source=collection_archive---------8-----------------------#2022-01-08</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="19b2" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">文本块、记录类等等</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/3fa890c3cd6c1cf060040a6670867659.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*qhzTAg0X405kt_Q0"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">克里斯托夫·高尔在<a class="ae kv" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>拍摄的照片</p></figure><p id="da42" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我清楚的记得2014年Java 8发布的时候。这是一个巨大的进步，是使Java成为函数式编程语言的一个进步，方法引用、函数接口、默认方法、流、空安全选项等等。</p><p id="bfe5" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">但是Java已经落后于任何其他现代语言，所以添加这些特性只是追赶，而不是创造一个突破性的特性…</p><p id="73f6" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">然而，我喜欢新的语言特性，我的同事也是如此！而且，说实话，从那以后我就没有太关注后续版本的新特性了。</p><p id="c13d" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">不仅公司不愿意升级到JDK 9或10，而且在下一个LTS(长期支持)发布之前(2018年9月)，我更专注于使用Scala和数据处理。</p><p id="a1f3" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">但是在将近8年之后，我决定是时候确保我跟上新的语言特性了！在浏览所有更新的过程中，有几个引起了我的注意，它们将像Java 8一样改变我的编程方式。</p><p id="4a84" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我不会涵盖所有的功能，它们实在是太多了。如题，我选了6个我觉得最有趣的，我不知道的！还有一个我还在等待，我们将会看到多久…</p><p id="6066" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这个列表决不是按照任何特定的顺序创建的，但是，每个特性都提到了它所发布的JDK版本！</p><h1 id="0bad" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">局部变量类型推理又名var</h1><p id="fb1e" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">作为Java开发人员，我们习惯于显式地指定我们创建的所有变量类型。</p><p id="4459" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们这些知道如何使用IDE来简化过程的人节省了大量的时间，但是我们所有人产生的代码仍然是相当笨重的，并且由于这些不必要的类型而不可读。</p><p id="1194" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">一个简单的例子是:</p><pre class="kg kh ki kj gt mp mq mr ms aw mt bi"><span id="4046" class="mu lt iq mq b gy mv mw l mx my">List&lt;String&gt; names = List.of(“Bob”, “Jack”, “Meg”);</span></pre><p id="ca56" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我真的需要左边的类型声明吗？就像我没有想到一个字符串列表会创建<em class="mz"> </em> <code class="fe na nb nc mq b">List&lt;String&gt;</code>一样，对吗？当类型变得更复杂时，就更令人讨厌了</p><pre class="kg kh ki kj gt mp mq mr ms aw mt bi"><span id="4f91" class="mu lt iq mq b gy mv mw l mx my">List&lt;String&gt; names = List.of(“Bob”, “Jack”, “Meg”);</span><span id="7c6d" class="mu lt iq mq b gy nd mw l mx my">Map&lt;String, Long&gt; namesFrequency = names.stream().collect(Collectors.groupingBy(Function.identity(), Collectors.counting()));</span></pre><p id="f50c" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">随着行越来越长，我们可能想要为<code class="fe na nb nc mq b">groupingBy</code>引入一个变量。通过这样做，我们创造了一个怪物:</p><pre class="kg kh ki kj gt mp mq mr ms aw mt bi"><span id="b447" class="mu lt iq mq b gy mv mw l mx my">List&lt;String&gt; names = List.of(“Bob”, “Jack”, “Meg”);</span><span id="2c94" class="mu lt iq mq b gy nd mw l mx my">Collector&lt;String, ?, Map&lt;String, Long&gt;&gt; byOccurrence = Collectors.groupingBy(Function.identity(), Collectors.counting()</span><span id="972b" class="mu lt iq mq b gy nd mw l mx my">Map&lt;String, Long&gt; namesFrequency = names.stream().collect(byOccurrence);</span></pre><p id="cab1" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">所以现在我们处于进退两难的境地。这个简单的例子当然可以通过断线来解决，但是事情并不总是那么简单。</p><p id="32da" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">借助于<em class="mz"> var </em>和静态导入我们可以大大简化上面的例子:</p><pre class="kg kh ki kj gt mp mq mr ms aw mt bi"><span id="f67a" class="mu lt iq mq b gy mv mw l mx my">var names = List.of(“Bob”, “Jack”, “Meg”);</span><span id="04d2" class="mu lt iq mq b gy nd mw l mx my">var byOccurrence = groupingBy(identity(), counting());</span><span id="89fa" class="mu lt iq mq b gy nd mw l mx my">var namesFrequency = names.stream().collect(byOccurrence);</span></pre><p id="b439" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我可能应该在这里结束，但我不得不提到类型转换到<code class="fe na nb nc mq b">var</code>的一个非常重要的后果。</p><p id="b038" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们<em class="mz">【失去】</em>类型。</p><p id="41c5" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">你知道<code class="fe na nb nc mq b">names</code><strong class="ky ir"/><code class="fe na nb nc mq b">byOccurrence</code>或者<code class="fe na nb nc mq b">namesFrequency</code>是什么类型吗？人们可能会猜测这些类型与示例中的类型相同，但事实并非如此！既然类型是推断出来的我们<code class="fe na nb nc mq b">String</code>就输在了<code class="fe na nb nc mq b">byOccurrence</code>(编译器怎么会知道<code class="fe na nb nc mq b">identity()</code>是<code class="fe na nb nc mq b">String</code>？)，于是<code class="fe na nb nc mq b">namesFrequency</code>变成了<code class="fe na nb nc mq b">Map&lt;Object, Long&gt;</code>！这可以通过显式键入<code class="fe na nb nc mq b">Function.identity()</code>来轻松修复:</p><pre class="kg kh ki kj gt mp mq mr ms aw mt bi"><span id="b646" class="mu lt iq mq b gy mv mw l mx my">var names = List.of(“Bob”, “Jack”, “Meg”);</span><span id="2965" class="mu lt iq mq b gy nd mw l mx my">var byOccurrence = groupingBy(Function.&lt;String&gt;identity(), counting());</span><span id="0abe" class="mu lt iq mq b gy nd mw l mx my">var namesFrequency = names.stream().collect(byOccurrence);</span></pre><p id="dfad" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">但是为了得到一个永久的解决方案，我们需要IDE的良好支持！</p><p id="b132" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">值得庆幸的是，我使用了一个IDE来显示推断的类型，这对我来说很容易。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi ne"><img src="../Images/c9768ceb9c9f01adc9d0f15f7da1354e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*DorWjz_nVNm7OelRsGCVjw.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">IntelliJ显示类型的例子！</p></figure><h1 id="f4a8" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">文本块</h1><p id="d84a" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">我不知道我能不能数清有多少次我在Java里因为断长串而差点失去理智。为什么现代语言会支持多行字符串？</p><p id="bfdb" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">最后，从2020年开始，Java 15支持文本块！让我兴奋的是，我再也不用打几十个<em class="mz"> "+" </em>符号了，但我可以简单地做到:</p><pre class="kg kh ki kj gt mp mq mr ms aw mt bi"><span id="ac71" class="mu lt iq mq b gy mv mw l mx my">String myMessage = “””</span><span id="a290" class="mu lt iq mq b gy nd mw l mx my">“Hello, Java!”</span><span id="c2bc" class="mu lt iq mq b gy nd mw l mx my">“””;</span></pre><p id="7d61" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">但是有一个问题(以及其他多个问题，我将在另一篇文章中详细阐述)。文本块仅仅是<em class="mz">块，你不能像这样在一行中使用它们:</em></p><pre class="kg kh ki kj gt mp mq mr ms aw mt bi"><span id="c953" class="mu lt iq mq b gy mv mw l mx my">String myMessage = “”” “Hello, Java!” “””;</span></pre><p id="af2e" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这将导致编译错误，任何现代IDE都应该告诉您:</p><pre class="kg kh ki kj gt mp mq mr ms aw mt bi"><span id="0eb6" class="mu lt iq mq b gy mv mw l mx my">Illegal text block start: missing new line after opening quotes</span></pre><p id="86b3" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这让我很难过，这意味着我们仍然必须避开引号:</p><pre class="kg kh ki kj gt mp mq mr ms aw mt bi"><span id="4967" class="mu lt iq mq b gy mv mw l mx my">String myMessage = “\”Hello, Java!\””;</span></pre><p id="0745" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><strong class="ky ir">switch现在是一个表达式。</strong></p><p id="4074" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">老实说，多年来switch表达式有太多的改进，无法在这一小段中解释它们。我将只关注最重要的一点。</p><p id="7e98" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">您是否曾经在Java面试中遇到过一个棘手的问题:下面的代码块会打印出什么？</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nf ng l"/></div></figure><p id="2215" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">答案应该永远是“今天是周末，我拒绝工作。”因为没有指定<code class="fe na nb nc mq b">break<em class="mz">;</em></code>。</p><p id="2ada" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">Java 14将<code class="fe na nb nc mq b">switch</code>带到了下一个层次。它不再是一个简单的语句，而是一个表达式，所以它可以返回值！通过这种改进，我们不再需要考虑<code class="fe na nb nc mq b">break;</code> :-)。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nf ng l"/></div></figure><p id="403c" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">你有没有注意到<code class="fe na nb nc mq b">switch</code>产生了一个可以赋给变量的值？多酷啊。</p><p id="d1cf" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">请继续关注关于开关表达式的更深入的文章！</p><h1 id="71c1" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">模式匹配</h1><p id="ce64" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">我个人是模式匹配的爱好者。当我可以键入一个简单的switch/match-case语句并获得我期望的值时，我喜欢这种灵活的编程方式。Scala以我所期望的每一种现代语言的方式来做这件事。</p><p id="13af" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">Java仍然远远落后于Scala，但是最近引入了一些增强，不幸的是,“真正的”<code class="fe na nb nc mq b">switch-case</code>模式匹配仍然处于预览阶段(从Java 17开始)。</p><p id="b3f5" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">自从Java 16发布以来，现在唯一存在的模式匹配是<code class="fe na nb nc mq b">instanceof</code>模式匹配。模式匹配的instanceof是什么意思？让我们看一个Java 16之前的“典型”例子:</p><pre class="kg kh ki kj gt mp mq mr ms aw mt bi"><span id="5134" class="mu lt iq mq b gy mv mw l mx my">if (obj instanceof String ) {</span><span id="cf7e" class="mu lt iq mq b gy nd mw l mx my">    String s = (String)obj;</span><span id="1c20" class="mu lt iq mq b gy nd mw l mx my">}</span></pre><p id="44bc" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">有了这项新功能，它就变成了:</p><pre class="kg kh ki kj gt mp mq mr ms aw mt bi"><span id="d99e" class="mu lt iq mq b gy mv mw l mx my">if (obj instanceof String s) {<br/>    // your code here</span><span id="406d" class="mu lt iq mq b gy nd mw l mx my">}</span></pre><h1 id="f628" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">密封类</h1><p id="3849" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">密封类在某种意义上非常类似于final类。差别非常微妙——final类根本不能扩展(不能有子类),只有类可以是final，接口不能成为final——这没有意义。</p><p id="0808" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><code class="fe na nb nc mq b">sealed</code>关键字加上<code class="fe na nb nc mq b">permits</code>关键字允许一个类或一个接口只能由一组指定的类或接口来扩展或实现。下面举个例子:</p><pre class="kg kh ki kj gt mp mq mr ms aw mt bi"><span id="732c" class="mu lt iq mq b gy mv mw l mx my">sealed interface Animal permits Reptile, Bird, Mammal, Fish {</span><span id="7ff1" class="mu lt iq mq b gy nd mw l mx my">}</span></pre><p id="2029" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">要记住的一件非常重要的事情是，扩展一个密封的类或接口需要使用<code class="fe na nb nc mq b">sealed</code>或<code class="fe na nb nc mq b">non-sealed</code>关键字！简单地解封它并允许它被子类化:-)。</p><p id="0008" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">类是枚举的完美替代品，但是要充分利用它们的能力，我们需要等到switch的模式匹配可以生产时。</p><h1 id="304b" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">记录类别</h1><p id="9edb" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">我把最好的留到了最后。尽管这看起来不是一个巨大的改进，但它极大地提高了开发人员的工作效率。对于那些有Scala背景的记录类来说，非常类似于case类。</p><p id="a544" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">有了Java 16中引入的记录类，我们可以避免所有不必要的样板代码，突然之间:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nf ng l"/></div></figure><p id="ccc3" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">变成了这样:</p><pre class="kg kh ki kj gt mp mq mr ms aw mt bi"><span id="92d2" class="mu lt iq mq b gy mv mw l mx my">record Person (int age, int height) {}</span></pre><p id="6039" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">是不是很酷？！是的，花括号必须在那里——真扫兴。准确地说，record类甚至比我之前提供的例子还要好。我们不再需要考虑添加<code class="fe na nb nc mq b">hashCode()</code>、<code class="fe na nb nc mq b">equals()</code>、<code class="fe na nb nc mq b">toString()</code>——它们通常很容易由喜爱的IDE生成，但仍然需要每次添加新字段时进行手动干预。对我来说，这是一个期待已久的功能！</p><p id="8ddc" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这绝不是一个详尽的特性和增强列表，我只列出了我最喜欢的和我将尽快开始使用的。</p><p id="adb1" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">关于记录的深入描述，请查看我的另一篇文章<a class="ae kv" href="https://konradtendera.medium.com/java-16-introduces-a-new-language-feature-called-records-267f7ccd3778" rel="noopener"> Java记录深度</a></p><p id="1dfe" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我错过了什么重要的改进吗？你最喜欢的功能是什么？让我知道。</p></div></div>    
</body>
</html>