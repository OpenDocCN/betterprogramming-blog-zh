# Swift:用等价的正确方式比较对象

> 原文：<https://betterprogramming.pub/swift-comparing-objects-the-right-way-with-equatable-cf484d07dfaf>

## 如何实现等价协议来定制您的比较结果和行为

![](img/69515e3470c7c88ceaeabcaf0c0fd904.png)

[在](https://unsplash.com/@creativeexchange?utm_source=medium&utm_medium=referral) [Unsplash](https://unsplash.com?utm_source=medium&utm_medium=referral) 上创意交流的照片。

与任何 OOP 语言一样，有一种正确的方法来比较对象，并消除关于`*==*`和`===`操作符的任何混淆。在这篇简短的指南中，我将解释那些操作符语义以及如何实现`Equatable`协议来定制您的比较结果和行为。

# ==运算符

在 Swift 中，*等于*操作符的目标几乎和它在其他面向对象编程语言中的目标一样:它通过引用来比较对象。首先，请记住，预期的布尔值取决于您要比较的是什么类型的东西。在 Swift 中，变量可以是值类型，也可以是引用类型。第一个变量“家族”保存值，而第二个保存内存引用。因此，如果使用由类模式实例化的对象，`==`操作符比较的是引用而不是值。这就是为什么`==`操作符不能进行“深度比较”,你也不应该假设或假装它会比较每个对象属性中的所有值。事实并非如此。这里有一小段代码来说明我的观点:

注意`NSObject`类型指示。如果省略类型，LLVM 甚至不会编译这段代码，因为它没有关于如何比较对象的指示。虽然包含了`NSObject`类型，但是我们使用了默认的`==`方法行为。这就是为什么两个打印给你`false`和`true`。

1.  `print(a == b)`之所以是`false`是因为`a`和`b`是指向内存中不同位置的两个截然不同的对象。
2.  `print(c == a)`之所以是`true`是因为当你把`c`赋给`a`的时候，`c`并不会成为`a`的深度副本。它变成了指向内存中相同位置的指针。这就是为什么改变`a`实例值会改变`c`中的镜像属性。只是同一个对象！

==操作符的语义与 Java、C#和其他 OOP 语言中的差别并不大，所以您应该对此充满信心，不要感到惊讶。

# ===运算符

许多其他编程语言都提供了`===`操作符的实现。但这是什么呢？它被称为身份算符。这个操作符只是假装两个对象是相同的，但是它们没有相同的值。`===`操作符使用反射来比较和分析所提供的两个对象的类型，而不是值。它不会只比较价值。即使有…一个物体的“价值”是什么？你可能会认为一个对象的值就是其内部的内容，这对于整数或字符串来说很容易理解，但是汽车呢？看看这个例子:

和以前一样，但是现在我们知道为什么会这样了。最后一条语句给出了`true`，因为`c`和`a`指向相同的内存分配值。让我们看看简单值会发生什么:

```
let x : Int = 3
let y : Int8 = 3
print(x == y)     // <---- true
print(x === y)    // <---- won't compile
```

这里你会看到一个*二元运算符' === '不能应用于' Int '类型的操作数和' Int8'* 错误。基本上，由于他们的类型不匹配，比较这两个家伙没有意义，编译器会说它不知道如何做。显然，第一次比较给出了`true`，因为 3 的值等于存储在一个八位整数中的 3 的值。如果你试图比较`Int`和`Float`、`Int`和`Double`等等，Swift 也会给你一个编译器错误。编译器将要求强制转换来证明值比较行为，而不是类型。

# 那么我如何用我的方式比较对象呢？使用等价协议！

当您需要比较两个定制对象时，您必须通过`Equatable`协议提供比较操作符的定制实现。在 Java 中，您应该重写`equals`方法。让你的类符合`Equatable`协议是通过值来比较两个对象的唯一方法。如果你只需要通过引用来比较它们，现在很明显你不需要编码协议实现…但是谁只需要通过引用来比较呢？

幸运的是，让您的类符合`Equatable`非常容易:

关于`Equatable`协议有趣的事情是，它强制类实现一个名为`==`的方法。我只在 Swift 里见过这种诡异的命名约定，从发现开始就一直很喜欢。简单地将方法命名为`==`而不是`equals`,这使得您仍然能够使用标准符号而不是通过调用特定的方法来比较对象。应该听起来很暧昧吧？当我使用`==`时，我是使用定制的`Equatable`实现还是默认的参考实现？不要担心，Xcode 会以两种不同的方式突出显示操作符，你可以随时用键盘上的 alt 键检查操作符，或者跳到实现，看看后面有什么。

# 结论

比较对象几乎是开发人员的一项基本任务，如果您对这些运算符没有清晰的理解，它总是会给出意想不到的结果。更重要的是，使用`Equatable`协议让您能够确定两个对象是否应该被视为相同或相等。在上面的例子中，我决定两辆车是一样的，只是因为它们有相同的车牌，忽略了引擎马力属性。`Equatable`方法只是 Swift 中对象知识的基础。现在您可以无忧无虑地编写代码了。