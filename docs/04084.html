<html>
<head>
<title>Understand Python Custom Class Instantiation, Beyond __init__()</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">了解Python自定义类实例化，超越__init__()</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/understand-python-custom-class-instantiation-beyond-init-85ad1cbe90d?source=collection_archive---------5-----------------------#2020-03-23">https://betterprogramming.pub/understand-python-custom-class-instantiation-beyond-init-85ad1cbe90d?source=collection_archive---------5-----------------------#2020-03-23</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="981b" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">Python如何实例化自定义类对象</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/f7e2ee71a3813be3b67417b323602679.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*lbzqymwnImpkQ-fDsUWoOA.jpeg"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated"><a class="ae ky" href="https://unsplash.com/@andrenoboa?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">安德烈·诺沃亚</a>在<a class="ae ky" href="https://unsplash.com/s/photos/modernism?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的照片</p></figure><h1 id="ada2" class="kz la it bd lb lc ld le lf lg lh li lj jz lk ka ll kc lm kd ln kf lo kg lp lq bi translated">介绍</h1><p id="08b8" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">创建自定义类允许我们定义新类型的对象，这些对象具有特定于我们工作需要的特定属性和功能。在大多数情况下，我们在自定义类中覆盖<code class="fe mn mo mp mq b">__init__()</code>方法，为我们正在创建的实例对象设置所需的初始属性。这里有一个简单的例子:</p><pre class="kj kk kl km gt mr mq ms mt aw mu bi"><span id="a906" class="mv la it mq b gy mw mx l my mz">&gt;&gt;&gt; class Person:<br/>...     def __init__(self, name, age):<br/>...         self.name = name<br/>...         self.age = age</span><span id="435f" class="mv la it mq b gy na mx l my mz">...     def greet(self, other):<br/>...         print(f'{self.name} says hello to {other}.')<br/>...</span></pre><p id="3720" class="pw-post-body-paragraph lr ls it lt b lu nb ju lw lx nc jx lz ma nd mc md me ne mg mh mi nf mk ml mm im bi translated">在上面的代码片段中，<code class="fe mn mo mp mq b">__init__()</code>方法作为构造函数方法，是为新创建的<code class="fe mn mo mp mq b">Person</code>实例对象设置<code class="fe mn mo mp mq b">name</code>和<code class="fe mn mo mp mq b">age</code>。</p><p id="a545" class="pw-post-body-paragraph lr ls it lt b lu nb ju lw lx nc jx lz ma nd mc md me ne mg mh mi nf mk ml mm im bi translated">下面是一个如何创建<code class="fe mn mo mp mq b">Person</code>实例对象的例子——使用类名形式的构造函数，后跟括起初始化变量的括号:</p><pre class="kj kk kl km gt mr mq ms mt aw mu bi"><span id="ab68" class="mv la it mq b gy mw mx l my mz">&gt;&gt;&gt; person = Person('John Smith', 25)<br/>&gt;&gt;&gt; print(person.__dict__)<br/>{'name': 'John Smith', 'age': 25}</span></pre><p id="3c43" class="pw-post-body-paragraph lr ls it lt b lu nb ju lw lx nc jx lz ma nd mc md me ne mg mh mi nf mk ml mm im bi translated">通过调用内置的<code class="fe mn mo mp mq b">__dict__</code>属性，我们看到这个实例对象<code class="fe mn mo mp mq b">person</code>确实按照预期设置了其<code class="fe mn mo mp mq b">name</code>和<code class="fe mn mo mp mq b">age</code>属性。</p></div><div class="ab cl ng nh hx ni" role="separator"><span class="nj bw bk nk nl nm"/><span class="nj bw bk nk nl nm"/><span class="nj bw bk nk nl"/></div><div class="im in io ip iq"><h1 id="9200" class="kz la it bd lb lc nn le lf lg no li lj jz np ka ll kc nq kd ln kf nr kg lp lq bi translated">获取人员。__init__(自己，姓名，年龄)上班</h1><h2 id="d77c" class="mv la it bd lb ns nt dn lf nu nv dp lj ma nw nx ll me ny nz ln mi oa ob lp oc bi translated">__init__()方法中的self是什么？</h2><p id="244c" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">然而，如果我们仔细观察示例中的<code class="fe mn mo mp mq b">__init__()</code>方法，这个方法将<code class="fe mn mo mp mq b">self</code>作为它的第一个参数。self参数指的是调用函数的实例对象(关于函数中的<code class="fe mn mo mp mq b">self</code>参数的更多信息，参见我的<a class="ae ky" href="https://medium.com/better-programming/unlock-the-4-mysteries-of-self-in-python-d1913fbb8e16" rel="noopener">上一篇文章</a>)。</p><p id="16fe" class="pw-post-body-paragraph lr ls it lt b lu nb ju lw lx nc jx lz ma nd mc md me ne mg mh mi nf mk ml mm im bi translated">下面的代码显示了它的主要用法。具体来说，当我们使用实例对象<code class="fe mn mo mp mq b">person</code>调用方法<code class="fe mn mo mp mq b">greet()</code>时，我们只需设置<code class="fe mn mo mp mq b">other</code>参数。通过将实例对象<code class="fe mn mo mp mq b">person</code>和<code class="fe mn mo mp mq b">‘Mary’</code>分别设置为<code class="fe mn mo mp mq b">self</code>和<code class="fe mn mo mp mq b">other</code>参数，使用调用函数的类<code class="fe mn mo mp mq b">Person</code>来处理该函数调用。它们会产生您可能期望的输出:</p><pre class="kj kk kl km gt mr mq ms mt aw mu bi"><span id="7548" class="mv la it mq b gy mw mx l my mz">&gt;&gt;&gt; person.greet('Mary')<br/>John Smith says hello to Mary.<br/>&gt;&gt;&gt; # The above function is essentially operates as below<br/>&gt;&gt;&gt; Person.greet(person, 'Mary')<br/>John Smith says hello to Mary.</span></pre><p id="7b16" class="pw-post-body-paragraph lr ls it lt b lu nb ju lw lx nc jx lz ma nd mc md me ne mg mh mi nf mk ml mm im bi translated"><em class="od">这也适用于</em> <code class="fe mn mo mp mq b"><em class="od">__init__()</em></code> <em class="od">法吗？</em></p><p id="c587" class="pw-post-body-paragraph lr ls it lt b lu nb ju lw lx nc jx lz ma nd mc md me ne mg mh mi nf mk ml mm im bi translated">让我们做一个实验:</p><pre class="kj kk kl km gt mr mq ms mt aw mu bi"><span id="ce99" class="mv la it mq b gy mw mx l my mz">&gt;&gt;&gt; another_person = Person.__init__(another_person, 'Jeff Green', 24)<br/>Traceback (most recent call last):<br/>  File "&lt;stdin&gt;", line 1, in &lt;module&gt;<br/>NameError: name 'another_person' is not defined</span></pre><p id="60e6" class="pw-post-body-paragraph lr ls it lt b lu nb ju lw lx nc jx lz ma nd mc md me ne mg mh mi nf mk ml mm im bi translated">对于任何有经验的程序员来说，写这行代码都是一种罪过。我们知道会发生什么，但我们还没有定义变量！此外，我们知道<code class="fe mn mo mp mq b">__init__()</code>方法没有返回任何东西。如果我们在自定义类中查看该方法声明中的代码(从技术上讲，在这种情况下会返回一个隐式的<code class="fe mn mo mp mq b">None</code>)。</p><p id="48cd" class="pw-post-body-paragraph lr ls it lt b lu nb ju lw lx nc jx lz ma nd mc md me ne mg mh mi nf mk ml mm im bi translated">这个问题困扰着我和其他一些Python学习者，尤其是那些知道这些方法中的<code class="fe mn mo mp mq b">self</code>参数是什么的人。要解决上面的问题，我们可以问一个相关的问题。</p><p id="900c" class="pw-post-body-paragraph lr ls it lt b lu nb ju lw lx nc jx lz ma nd mc md me ne mg mh mi nf mk ml mm im bi translated"><em class="od">我们可以通过什么作为</em> <code class="fe mn mo mp mq b"><em class="od">self</em></code> <em class="od">论证到</em> <code class="fe mn mo mp mq b"><em class="od">__init__()</em></code> <em class="od">的方法呢？</em></p><p id="1ff4" class="pw-post-body-paragraph lr ls it lt b lu nb ju lw lx nc jx lz ma nd mc md me ne mg mh mi nf mk ml mm im bi translated">为了让<code class="fe mn mo mp mq b">Person.__init__(self, name, age)</code>工作，我们首先需要找到一个实例对象作为<code class="fe mn mo mp mq b">self</code>参数。换句话说，其他东西已经创建了实例对象，它可以在这个构造函数方法中使用。但是什么？</p><h2 id="ec3d" class="mv la it bd lb ns nt dn lf nu nv dp lj ma nw nx ll me ny nz ln mi oa ob lp oc bi translated">__new__()方法</h2><p id="b6f8" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated"><code class="fe mn mo mp mq b">__new__()</code>方法来拯救。该方法实际上创建了自定义类的实例对象。我们使用构造函数来声明一个新的实例:</p><pre class="kj kk kl km gt mr mq ms mt aw mu bi"><span id="265f" class="mv la it mq b gy mw mx l my mz">&gt;&gt;&gt; another_person = object.__new__(Person)<br/>&gt;&gt;&gt; another_person.__dict__<br/>{}<br/>&gt;&gt;&gt; Person.__init__(another_person, 'Ruby Green', 5)<br/>__init__ is called<br/>&gt;&gt;&gt; another_person.__dict__<br/>{'name': 'Ruby Green', 'age': 5}</span></pre><p id="4dac" class="pw-post-body-paragraph lr ls it lt b lu nb ju lw lx nc jx lz ma nd mc md me ne mg mh mi nf mk ml mm im bi translated">如上所示，我们通过传递类<code class="fe mn mo mp mq b">Person</code>作为所需的参数来调用<code class="fe mn mo mp mq b">__new__()</code>方法。初始创建后，实例对象没有按预期设置属性。</p><p id="ceaf" class="pw-post-body-paragraph lr ls it lt b lu nb ju lw lx nc jx lz ma nd mc md me ne mg mh mi nf mk ml mm im bi translated">使用这个实例对象作为<code class="fe mn mo mp mq b">self</code>参数，我们最终能够使用类<code class="fe mn mo mp mq b">Person</code>调用<code class="fe mn mo mp mq b">__init__()</code>方法来完全初始化实例，该实例具有<code class="fe mn mo mp mq b">name</code>和<code class="fe mn mo mp mq b">age</code>属性。</p><p id="b5e4" class="pw-post-body-paragraph lr ls it lt b lu nb ju lw lx nc jx lz ma nd mc md me ne mg mh mi nf mk ml mm im bi translated">所以，上面问题的答案是这样的:我们应该使用<code class="fe mn mo mp mq b">__new__()</code>方法创建一个空实例，可以进一步设置为<code class="fe mn mo mp mq b">__init__()</code>方法中的<code class="fe mn mo mp mq b">self</code>参数。</p></div><div class="ab cl ng nh hx ni" role="separator"><span class="nj bw bk nk nl nm"/><span class="nj bw bk nk nl nm"/><span class="nj bw bk nk nl"/></div><div class="im in io ip iq"><h1 id="1008" class="kz la it bd lb lc nn le lf lg no li lj jz np ka ll kc nq kd ln kf nr kg lp lq bi translated">深入分析:__new__() &amp; __init__()</h1><p id="678c" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">我们现在知道，当构造一个实例时，<code class="fe mn mo mp mq b">__new__()</code>方法负责创建实例，<code class="fe mn mo mp mq b">__init__()</code>方法负责完成初始化过程。现在，让我们通过一些相关的例子来更仔细地看看每种方法都做了什么。</p><h2 id="d489" class="mv la it bd lb ns nt dn lf nu nv dp lj ma nw nx ll me ny nz ln mi oa ob lp oc bi translated">使用__new__()方法创建实例</h2><p id="7855" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">如上所述，我们使用<code class="fe mn mo mp mq b">__new__()</code>方法来创建实例。换句话说，<code class="fe mn mo mp mq b">__new__()</code>方法的返回值是实例。</p><p id="9698" class="pw-post-body-paragraph lr ls it lt b lu nb ju lw lx nc jx lz ma nd mc md me ne mg mh mi nf mk ml mm im bi translated">如果我们不让<code class="fe mn mo mp mq b">__new__()</code>方法返回任何东西，会发生什么？</p><pre class="kj kk kl km gt mr mq ms mt aw mu bi"><span id="fa65" class="mv la it mq b gy mw mx l my mz">&gt;&gt;&gt; class Student:<br/>...     def __new__(cls):<br/>...         print('__new__ gets called.')<br/>...     def __init__(self):<br/>...         print('__init__ gets called.')<br/>... <br/>&gt;&gt;&gt; student = Student()<br/>__new__ gets called.<br/>&gt;&gt;&gt; type(student)<br/>&lt;class 'NoneType'&gt;</span></pre><p id="7e55" class="pw-post-body-paragraph lr ls it lt b lu nb ju lw lx nc jx lz ma nd mc md me ne mg mh mi nf mk ml mm im bi translated">在上面的例子中，<code class="fe mn mo mp mq b">__new__()</code>方法没有返回任何东西。当我们调用构造函数(即<code class="fe mn mo mp mq b">Student()</code>)时，只有<code class="fe mn mo mp mq b">__new__()</code>方法被调用，而不是<code class="fe mn mo mp mq b">__init__()</code>方法。当我们检查创建的实例的类型时，它是<code class="fe mn mo mp mq b">NoneType</code>。</p><p id="5ceb" class="pw-post-body-paragraph lr ls it lt b lu nb ju lw lx nc jx lz ma nd mc md me ne mg mh mi nf mk ml mm im bi translated">顺便提一下，需要提到的一点是，<code class="fe mn mo mp mq b">__new__()</code>方法采用了一个名为<code class="fe mn mo mp mq b">cls</code>的参数，这是我们想要为其创建实例对象的类。这个参数被命名为<code class="fe mn mo mp mq b">cls</code>，这只是Python中的一个约定，与实例方法中名为<code class="fe mn mo mp mq b">self</code>的参数(即上面例子中的<code class="fe mn mo mp mq b">greet()</code>方法)相同。</p><p id="8c93" class="pw-post-body-paragraph lr ls it lt b lu nb ju lw lx nc jx lz ma nd mc md me ne mg mh mi nf mk ml mm im bi translated">为了实例化一个<code class="fe mn mo mp mq b">Student</code>对象，<code class="fe mn mo mp mq b">__new__()</code>方法应该返回一个新创建的<code class="fe mn mo mp mq b">Student</code>实例。</p><pre class="kj kk kl km gt mr mq ms mt aw mu bi"><span id="1e96" class="mv la it mq b gy mw mx l my mz">&gt;&gt;&gt; class Student:<br/>...     def __new__(cls):<br/>...         print('__new__ gets called.')<br/>...         student = object.__new__(cls)<br/>...         return student<br/>...     def __init__(self):<br/>...         print('__init__ is called')<br/>... <br/>&gt;&gt;&gt; student = Student()<br/>__new__ gets called.<br/>__init__ is called<br/>&gt;&gt;&gt; type(student)<br/>&lt;class '__main__.Student'&gt;</span></pre><p id="f3fd" class="pw-post-body-paragraph lr ls it lt b lu nb ju lw lx nc jx lz ma nd mc md me ne mg mh mi nf mk ml mm im bi translated">在上面的例子中，更新后的<code class="fe mn mo mp mq b">__new__()</code>方法返回了<code class="fe mn mo mp mq b">Student</code>类的一个新实例。通过这样做，我们注意到<code class="fe mn mo mp mq b">__init__()</code>方法被调用。正如所料，创建的对象属于类型<code class="fe mn mo mp mq b">Student</code>。</p><h2 id="8ba0" class="mv la it bd lb ns nt dn lf nu nv dp lj ma nw nx ll me ny nz ln mi oa ob lp oc bi translated">__init__有其他参数怎么办？</h2><p id="7a21" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">在上面的例子中，<code class="fe mn mo mp mq b">__init__()</code>方法只有<code class="fe mn mo mp mq b">self</code>参数。但是在很多情况下，我们希望为新的实例对象设置其他初始化属性。例如，<code class="fe mn mo mp mq b">Student</code>实例对象可以有他/她的名字和学号。</p><pre class="kj kk kl km gt mr mq ms mt aw mu bi"><span id="588e" class="mv la it mq b gy mw mx l my mz">&gt;&gt;&gt; class Student:<br/>...     def __new__(cls, *args):<br/>...         print('__new__ gets called.')<br/>...         student = object.__new__(cls)<br/>...         return student<br/>...     def __init__(self, name, id_number):<br/>...         self.name = name<br/>...         self.id_number = id_number<br/>...         print('__init__ is called')<br/>... <br/>&gt;&gt;&gt; student = Student('John Smith', 983044)<br/>__new__ gets called.<br/>__init__ is called<br/>&gt;&gt;&gt; type(student)<br/>&lt;class '__main__.Student'&gt;<br/>&gt;&gt;&gt; print(student.__dict__)<br/>{'name': 'John Smith', 'id_number': 983044}</span></pre><p id="4fad" class="pw-post-body-paragraph lr ls it lt b lu nb ju lw lx nc jx lz ma nd mc md me ne mg mh mi nf mk ml mm im bi translated">除了默认的<code class="fe mn mo mp mq b">cls</code>参数，我们还有<code class="fe mn mo mp mq b">*args</code>，它表示可变数量的参数。通过设置，我们现在可以为构造函数设置额外的参数，如上所示。</p><p id="6546" class="pw-post-body-paragraph lr ls it lt b lu nb ju lw lx nc jx lz ma nd mc md me ne mg mh mi nf mk ml mm im bi translated">如果我们不把<code class="fe mn mo mp mq b">*args</code>包含在<code class="fe mn mo mp mq b">__new__()</code>方法中呢？</p><pre class="kj kk kl km gt mr mq ms mt aw mu bi"><span id="8789" class="mv la it mq b gy mw mx l my mz">&gt;&gt;&gt; class Student:<br/>...     def __new__(cls):<br/>...         print('__new__ gets called.')<br/>...         student = object.__new__(cls)<br/>...         return student<br/>...     def __init__(self, name, id_number):<br/>...         self.name = name<br/>...         self.id_number = id_number<br/>...         print('__init__ is called')<br/>... <br/>&gt;&gt;&gt; student = Student('John Smith', 983044)<br/>Traceback (most recent call last):<br/>  File "&lt;stdin&gt;", line 1, in &lt;module&gt;<br/>TypeError: __new__() takes 1 positional argument but 3 were given</span></pre><p id="5566" class="pw-post-body-paragraph lr ls it lt b lu nb ju lw lx nc jx lz ma nd mc md me ne mg mh mi nf mk ml mm im bi translated">显然，构造函数正在将<code class="fe mn mo mp mq b">Student</code>、<code class="fe mn mo mp mq b">‘John Smith’</code>和<code class="fe mn mo mp mq b">983044</code>这些参数发送给<code class="fe mn mo mp mq b">__new__()</code>方法，该方法被定义为只接受一个参数(即类)，导致出现错误。</p></div><div class="ab cl ng nh hx ni" role="separator"><span class="nj bw bk nk nl nm"/><span class="nj bw bk nk nl nm"/><span class="nj bw bk nk nl"/></div><div class="im in io ip iq"><h1 id="fa17" class="kz la it bd lb lc nn le lf lg no li lj jz np ka ll kc nq kd ln kf nr kg lp lq bi translated">外卖食品</h1><p id="3105" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">在本文中，我们通过研究<code class="fe mn mo mp mq b">__new__()</code>和<code class="fe mn mo mp mq b">__init__()</code>方法，回顾了Python中实例化的工作原理。以下是一些关键要点:</p><ul class=""><li id="aacc" class="oe of it lt b lu nb lx nc ma og me oh mi oi mm oj ok ol om bi translated">实例化或构造涉及到<code class="fe mn mo mp mq b">__new__()</code>和<code class="fe mn mo mp mq b">__init__()</code>两种方法。</li><li id="99bc" class="oe of it lt b lu on lx oo ma op me oq mi or mm oj ok ol om bi translated"><code class="fe mn mo mp mq b">__new__()</code>方法是创建一个“空的”实例对象作为其类的返回值。</li><li id="86a0" class="oe of it lt b lu on lx oo ma op me oq mi or mm oj ok ol om bi translated"><code class="fe mn mo mp mq b">__init__()</code>方法是设置其他属性来完成初始化过程。此方法不返回任何内容(即<code class="fe mn mo mp mq b">None</code>)。</li><li id="8228" class="oe of it lt b lu on lx oo ma op me oq mi or mm oj ok ol om bi translated">如果初始化涉及到设置额外的属性，那么定制的<code class="fe mn mo mp mq b">__new__()</code>方法需要支持获取这些参数。通常，这是通过将<code class="fe mn mo mp mq b">*args</code>作为方法的一部分来完成的。</li></ul></div></div>    
</body>
</html>