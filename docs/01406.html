<html>
<head>
<title>RxSwiftWidgets: Declarative Development for UIKit</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">RxSwiftWidgets:ui kit的声明式开发</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/introducing-rxswiftwidgets-f7a81bc54fe1?source=collection_archive---------8-----------------------#2019-09-06">https://betterprogramming.pub/introducing-rxswiftwidgets-f7a81bc54fe1?source=collection_archive---------8-----------------------#2019-09-06</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="bdcd" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">当您现在就可以在应用中获得声明式开发的好处时，为什么还要等待SwiftUI呢？</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/a6805c346458744fd91f5ae912723525.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*H4LKaORC7Yz_nF_LQCzmTg.jpeg"/></div></div></figure><p id="1b24" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">RxSwiftWidgets允许您使用类似于SwiftUI和Flutter使用的简单声明格式来定义基于UIKit的用户界面。RxSwiftWidgets也是基于RxSwift的，这意味着您拥有这种结合所期望的所有反应式数据绑定、用户界面控制和功能。</p><p id="d6d1" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">使用RxSwiftWidgets，在构建器模式中使用<em class="lq">小部件</em>和<em class="lq">修饰符</em>来组合和描述接口。</p><pre class="kj kk kl km gt lr ls lt lu aw lv bi"><span id="482c" class="lw lx it ls b gy ly lz l ma mb">LabelWidget($title)<br/>   .color(.red)<br/>   .font(.title1)</span></pre><p id="c881" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">呈现时，给定类型的每个小部件构建一个相应的UIView，然后根据需要用所需的属性和行为对其进行修改。</p><p id="bd3d" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">只需组合几个小部件，您就可以快速轻松地实现一些动态用户界面:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi mc"><img src="../Images/554aa59b0f34adf05a4a41a15ffb3729.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*bfrirG2hnZjIHXzwOCY8NQ.png"/></div></div></figure><p id="7aa5" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">使用RxSwiftWidgets的声明式编程消除了对界面构建器故事板、Segues、nib甚至自定义UIViewControllers的需要。当然，所有这些东西都还在，等待着真正需要定制功能的时候。</p><p id="29cc" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">像SwiftUI一样，RxSwiftWidgets背后的目标是消除创建和开发用户界面背后的许多麻烦。</p><p id="605e" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">但与SwiftUI不同的是，使用RxSwiftWidgets，您还可以在任何时间点深入底层，直接处理生成的视图和界面元素，并根据您的需要调整它们。</p><p id="1d04" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated"><a class="ae md" href="https://github.com/hmlongco/RxSwiftWidgets" rel="noopener ugc nofollow" target="_blank"> RxSwiftWidgets在GitHub </a>上有售。</p></div><div class="ab cl me mf hx mg" role="separator"><span class="mh bw bk mi mj mk"/><span class="mh bw bk mi mj mk"/><span class="mh bw bk mi mj"/></div><div class="im in io ip iq"><h1 id="e106" class="ml lx it bd mm mn mo mp mq mr ms mt mu jz mv ka mw kc mx kd my kf mz kg na nb bi translated">为什么选择RxSwiftWidgets？</h1><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi nc"><img src="../Images/08a4d49c88824ef2173b99a5f2b0cf5e.png" data-original-src="https://miro.medium.com/v2/resize:fit:384/format:webp/1*VKxaLEMhp7OKOQEvovTVxQ.png"/></div></figure><h2 id="b262" class="lw lx it bd mm nd ne dn mq nf ng dp mu ld nh ni mw lh nj nk my ll nl nm na nn bi translated">为什么不是SwiftUI？</h2><p id="5839" class="pw-post-body-paragraph ku kv it kw b kx no ju kz la np jx lc ld nq lf lg lh nr lj lk ll ns ln lo lp im bi translated">SwiftUI和Combine即将推出，为什么还要使用RxSwiftWidgets和RxSwift？答案就在问题本身中:“SwiftUI和Combine即将问世…”</p><p id="06df" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">SwiftUI即将推出，但尚未发布。联合收割机也是如此。</p><p id="ffc4" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">也许更确切地说，SwiftUI和Combine都至少需要iOS 13。不支持iOS 12或iOS 11。</p><p id="ca4a" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">没有太多的开发者可以在他们的应用程序中放弃对早期版本iOS的支持，而只使用iOS 13。这反过来意味着，我们大多数人在接下来的几年<strong class="kw iu"/>内看不到进行声明式、反应式编程的任何好处。</p><p id="34d6" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">这实在是太长了，这也是我决定让开发社区能够访问RxSwiftWidgets的原因之一。</p><p id="54af" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">请注意，我在我的文章<a class="ae md" href="https://medium.com/better-programming/swiftui-and-the-uistackview-problem-34381ffaa71f" rel="noopener"> SwiftUI和UIStackView问题</a>中对此进行了更深入的探讨。</p><h2 id="6841" class="lw lx it bd mm nd ne dn mq nf ng dp mu ld nh ni mw lh nj nk my ll nl nm na nn bi translated">cwl视图</h2><p id="1698" class="pw-post-body-paragraph ku kv it kw b kx no ju kz la np jx lc ld nq lf lg lh nr lj lk ll ns ln lo lp im bi translated">还有一些其他的声明性框架，其中最著名的是马特·加拉格尔的<a class="ae md" href="https://www.cocoawithlove.com/blog/introducing-cwlviews.html" rel="noopener ugc nofollow" target="_blank"> CwlViews </a>。</p><p id="832e" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">虽然CwlViews有一些很酷很有趣的特性，但是它最大的缺点在于它的反应式框架的实现。我坚信RxSwift，也许更重要的是，RxSwift拥有大量忠实的用户，以及大量关于它的可用资源、书籍和文章。</p><p id="6fd6" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">我想要声明式开发，我想要我的RxSwift。我能说什么呢？我很贪婪。</p><h2 id="ccf1" class="lw lx it bd mm nd ne dn mq nf ng dp mu ld nh ni mw lh nj nk my ll nl nm na nn bi translated">颤动，自然反应，等等。</h2><p id="f005" class="pw-post-body-paragraph ku kv it kw b kx no ju kz la np jx lc ld nq lf lg lh nr lj lk ll ns ln lo lp im bi translated">还有其他“跨平台”框架，但我本质上是一名iOS Swift开发人员。用Dart或者JavaScript做iOS开发，目前根本引不起我的兴趣。</p><p id="4331" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">本文的其余部分是对核心概念的简要解释和足够的示例代码，让您对在RxSwiftWidgets中设计声明性接口有所了解。</p><p id="9955" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">如前所述，如果您想查看项目并运行以下示例，可以在GitHub 上找到<a class="ae md" href="https://github.com/hmlongco/RxSwiftWidgets" rel="noopener ugc nofollow" target="_blank"> RxSwiftWidgets。</a></p><p id="673c" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">足够的序言…让我们开始吧！</p></div><div class="ab cl me mf hx mg" role="separator"><span class="mh bw bk mi mj mk"/><span class="mh bw bk mi mj mk"/><span class="mh bw bk mi mj"/></div><div class="im in io ip iq"><h1 id="5d27" class="ml lx it bd mm mn mo mp mq mr ms mt mu jz mv ka mw kc mx kd my kf mz kg na nb bi translated">RxSwiftWidgets</h1><p id="1a22" class="pw-post-body-paragraph ku kv it kw b kx no ju kz la np jx lc ld nq lf lg lh nr lj lk ll ns ln lo lp im bi translated">在RxSwiftWidgets中，屏幕由Widgets组成，widgets由widgets组成…</p><p id="264e" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">让我们来看一个在RxSwiftWidgets中实现的简单表格视图，它链接到一个细节视图。您知道，您的基本主列表或详细视图场景。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi nt"><img src="../Images/275df2361aef5fbfb18f6192762be1b3.png" data-original-src="https://miro.medium.com/v2/resize:fit:974/format:webp/1*ls8-itzcEq3s1_7WZyIBkg.png"/></div></figure><h2 id="dada" class="lw lx it bd mm nd ne dn mq nf ng dp mu ld nh ni mw lh nj nk my ll nl nm na nn bi translated">示例代码</h2><p id="aaf3" class="pw-post-body-paragraph ku kv it kw b kx no ju kz la np jx lc ld nq lf lg lh nr lj lk ll ns ln lo lp im bi translated">让我们浏览一下生成上面显示的数据驱动用户列表所需的<em class="lq">表视图</em>代码。</p><pre class="kj kk kl km gt lr ls lt lu aw lv bi"><span id="e2f8" class="lw lx it ls b gy ly lz l ma mb">struct UserListWidget: WidgetView {</span><span id="dda3" class="lw lx it ls b gy nu lz l ma mb">    var viewModel = UserListViewModel()</span><span id="378b" class="lw lx it ls b gy nu lz l ma mb">    func widget(_ context: WidgetContext) -&gt; Widget {          <br/>        TableWidget([<br/>            DynamicTableSectionWidget(viewModel.$users) {<br/>                TableCellWidget(<br/>                    HStackWidget([<br/>                        UserPhotoWidget(<br/>                            initials: $0.initials, <br/>                            size: 35<br/>                        ),<br/>                        LabelWidget($0.name)<br/>                    ])<br/>                    )<br/>                    .accessoryType(.disclosureIndicator)<br/>                }<br/>                .onSelect { (context, path, user) in<br/>                    let details = UserDetailsWidget(user: user) <br/>                    context.navigator?.push(widget: details)<br/>                    let table = context.tableView<br/>                    table?.deselectRow(at: path, animated: true)<br/>                }<br/>            ])<br/>            .onRefresh(initialRefresh: true, handler: { _ in<br/>                self.viewModel.reload()<br/>            })<br/>            .navigationBar(title: "User List", hidden: false)<br/>            .safeArea(false)<br/>    }<br/>}</span></pre><p id="b616" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">我们的<code class="fe nv nw nx ls b">UserListWidget</code>是一个<code class="fe nv nw nx ls b">WidgetView</code>，它的工作是返回一个小部件容器，该容器定义了视图的接口。</p><pre class="kj kk kl km gt lr ls lt lu aw lv bi"><span id="d440" class="lw lx it ls b gy ly lz l ma mb">struct UserListWidget: WidgetView {<br/>    func widget(_ context: WidgetContext) -&gt; Widget {          <br/>        ...<br/>    }<br/>}</span></pre><p id="8b9f" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated"><code class="fe nv nw nx ls b">WidgetView</code> s可以代表整个屏幕，如下图所示；或者它们可以用来渲染屏幕的一部分，如下面的<code class="fe nv nw nx ls b">UserPhotoWidget</code>所示。</p><p id="ff8a" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">几乎我们使用RxSwiftWidgets在应用程序中创建的每个屏幕和自定义视图都将是某种形式的<code class="fe nv nw nx ls b">WidgetView</code>。</p><h2 id="b9d1" class="lw lx it bd mm nd ne dn mq nf ng dp mu ld nh ni mw lh nj nk my ll nl nm na nn bi translated">WidgetContext</h2><p id="21dc" class="pw-post-body-paragraph ku kv it kw b kx no ju kz la np jx lc ld nq lf lg lh nr lj lk ll ns ln lo lp im bi translated">您会注意到widget函数是用<code class="fe nv nw nx ls b">WidgetContext</code>调用的。上下文是在构建小部件时提供给它们的，它包含关于视图层次结构的当前状态的信息，以及对当前视图控制器、当前视图和父视图的引用。</p><p id="128f" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">它们还提供对系统服务(如导航器)、主题、样式信息和其他属性的访问。您还可以将自己的信息或对象添加到当前上下文中，该信息将对该小部件的任何子部件可见。</p><p id="49e5" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">最后，每个上下文都包含一个RxSwift <code class="fe nv nw nx ls b">DisposeBag</code>,用于管理该小部件或其子部件所做的任何订阅或绑定。</p><h2 id="25e3" class="lw lx it bd mm nd ne dn mq nf ng dp mu ld nh ni mw lh nj nk my ll nl nm na nn bi translated">表格小部件</h2><p id="059e" class="pw-post-body-paragraph ku kv it kw b kx no ju kz la np jx lc ld nq lf lg lh nr lj lk ll ns ln lo lp im bi translated">继续，你会注意到我们的WidgetView的<code class="fe nv nw nx ls b">widget</code>函数返回了一个<code class="fe nv nw nx ls b">TableWidget</code>，正如你从名字中所料，它将最终生成我们的<code class="fe nv nw nx ls b">UITableView</code>。</p><pre class="kj kk kl km gt lr ls lt lu aw lv bi"><span id="1fe8" class="lw lx it ls b gy ly lz l ma mb">TableWidget([ … ])</span></pre><p id="7487" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated"><code class="fe nv nw nx ls b">TableWidget</code>反过来，可以包含多个静态和动态部分小部件。这里我们只有一个传入小部件初始化器的数组，一个<code class="fe nv nw nx ls b">DynamicTableSectionWidget</code>。</p><h2 id="546f" class="lw lx it bd mm nd ne dn mq nf ng dp mu ld nh ni mw lh nj nk my ll nl nm na nn bi translated">DynamicTableSectionWidget</h2><p id="05ac" class="pw-post-body-paragraph ku kv it kw b kx no ju kz la np jx lc ld nq lf lg lh nr lj lk ll ns ln lo lp im bi translated">动态表格部分只是:d <em class="lq">动态</em>。在我们的视图模型中，这个小部件被绑定到一个基于RxSwift的可观察用户数组。</p><pre class="kj kk kl km gt lr ls lt lu aw lv bi"><span id="4ccc" class="lw lx it ls b gy ly lz l ma mb">DynamicTableSectionWidget(viewModel.$users) { … }</span></pre><p id="0de2" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">每当RxSwift observable发送一个包含新用户数组的事件时，都会动态地重新生成表行，列表中的每个用户对应一行。根据需要调用尾随闭包，将每个用户映射到用于显示该用户信息的小部件(或多个小部件)。</p><p id="94e7" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">闭包基本上回答了这个问题:我们如何显示这个用户？</p><h2 id="b7e5" class="lw lx it bd mm nd ne dn mq nf ng dp mu ld nh ni mw lh nj nk my ll nl nm na nn bi translated">TableCellWidget</h2><p id="0b8c" class="pw-post-body-paragraph ku kv it kw b kx no ju kz la np jx lc ld nq lf lg lh nr lj lk ll ns ln lo lp im bi translated">在这种情况下，返回的小部件是一个简单的<code class="fe nv nw nx ls b">TableCellWidget</code>，它在<code class="fe nv nw nx ls b">HStackWidget</code>中显示用户的照片和姓名。</p><pre class="kj kk kl km gt lr ls lt lu aw lv bi"><span id="a58a" class="lw lx it ls b gy ly lz l ma mb">TableCellWidget(<br/>    HStackWidget([<br/>         UserPhotoWidget(initials: $0.initials, size: 35),<br/>         LabelWidget($0.name)<br/>         ])<br/>    )<br/>    .accessoryType(.disclosureIndicator)</span></pre><p id="f6d0" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">请注意，虽然您可以在RxSwiftWidgets中使用标准的基于文本的表格单元格，但是这些单元格的内容也是使用小部件定义和构建的！</p><h2 id="cc04" class="lw lx it bd mm nd ne dn mq nf ng dp mu ld nh ni mw lh nj nk my ll nl nm na nn bi translated">容器</h2><p id="5f22" class="pw-post-body-paragraph ku kv it kw b kx no ju kz la np jx lc ld nq lf lg lh nr lj lk ll ns ln lo lp im bi translated">上面显示的<code class="fe nv nw nx ls b">TableWidget</code>、<code class="fe nv nw nx ls b">TableCellWidget</code>和<code class="fe nv nw nx ls b">HStackWidget</code>都是<em class="lq">容器</em>小部件的例子。<code class="fe nv nw nx ls b">TableCellWidget</code> <em class="lq"> </em>包装单个小部件，而<code class="fe nv nw nx ls b">TableWidget</code> <em class="lq"> </em>和<em class="lq"> </em> <code class="fe nv nw nx ls b">HStackWidget</code>包装小部件数组。</p><p id="67fd" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">另一方面，<code class="fe nv nw nx ls b">LabelWidget</code>直接产生单个<code class="fe nv nw nx ls b">UILabel</code>。</p><p id="b9ca" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">容器是RxSwiftWidgets背后的基本架构构建块。</p><h2 id="ff4a" class="lw lx it bd mm nd ne dn mq nf ng dp mu ld nh ni mw lh nj nk my ll nl nm na nn bi translated">修饰语</h2><p id="1710" class="pw-post-body-paragraph ku kv it kw b kx no ju kz la np jx lc ld nq lf lg lh nr lj lk ll ns ln lo lp im bi translated">小部件的属性和行为可以使用小部件修改器来设置和修改。这里，我们的动态部分小部件有一个<code class="fe nv nw nx ls b">onSelect</code>修饰符，每当用户点击一个单元格时就会调用这个修饰符。</p><pre class="kj kk kl km gt lr ls lt lu aw lv bi"><span id="b66c" class="lw lx it ls b gy ly lz l ma mb">.onSelect { (context, path, user) in<br/>    let details = UserDetailsWidget(user: user) <br/>    context.navigator?.push(widget: details)<br/>    let table = context.tableView<br/>    table?.deselectRow(at: path, animated: true)<br/>}</span></pre><p id="2d26" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">如图所示，它使用一个<code class="fe nv nw nx ls b">navigatior</code>实例来构造一个新的<code class="fe nv nw nx ls b">UserDetailsWidget</code>并将其推送到导航堆栈上。</p><p id="f2da" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated"><code class="fe nv nw nx ls b">TableWidget</code>本身有一个<code class="fe nv nw nx ls b">onRefresh</code>修改器。</p><pre class="kj kk kl km gt lr ls lt lu aw lv bi"><span id="e9bc" class="lw lx it ls b gy ly lz l ma mb">.onRefresh(initialRefresh: true, handler: { _ in<br/>    self.viewModel.reload()<br/>})</span></pre><p id="f8fa" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">在这里，当最初创建视图时，以及每当用户执行拉式刷新时，我们都会重新加载数据。像RxSwiftWidgets中的许多东西一样，只需使用修饰符就可以自动嵌入并启用拉至刷新功能。</p><p id="eb1e" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">除了通知约束系统我们希望表格视图填满整个屏幕并忽略安全区域之外，表格小部件还有一些控制导航栏标题和外观的修饰符。</p><pre class="kj kk kl km gt lr ls lt lu aw lv bi"><span id="4749" class="lw lx it ls b gy ly lz l ma mb">.navigationBar(title: “User List”, hidden: false)<br/>.safeArea(false)</span></pre><p id="f1ef" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">与SwiftUI一样，修改者可以直接修改他们所附加的小部件的属性(即字体、颜色、安全区域)，或者他们可以修改和/或观察当前状态。</p><h2 id="c15b" class="lw lx it bd mm nd ne dn mq nf ng dp mu ld nh ni mw lh nj nk my ll nl nm na nn bi translated">完成的</h2><p id="ed64" class="pw-post-body-paragraph ku kv it kw b kx no ju kz la np jx lc ld nq lf lg lh nr lj lk ll ns ln lo lp im bi translated">就是这样。返回并再次查看完整的代码示例，您将看到定义用户表视图所需的所有代码(不包括视图模型中的数据加载代码)。您没有手动创建和配置一个<code class="fe nv nw nx ls b">UITableViewController</code>。没有代表。没有数据源。没有故事板。</p><p id="ccfc" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">一个完整的表格视图，包含导航、自定义表格视图单元格、动态数据和拉式刷新，大约30行代码。感兴趣吗？</p></div><div class="ab cl me mf hx mg" role="separator"><span class="mh bw bk mi mj mk"/><span class="mh bw bk mi mj mk"/><span class="mh bw bk mi mj"/></div><div class="im in io ip iq"><h1 id="4181" class="ml lx it bd mm mn mo mp mq mr ms mt mu jz mv ka mw kc mx kd my kf mz kg na nb bi translated">想要更多细节？</h1><p id="562b" class="pw-post-body-paragraph ku kv it kw b kx no ju kz la np jx lc ld nq lf lg lh nr lj lk ll ns ln lo lp im bi translated">为了更好的测量，这里是<code class="fe nv nw nx ls b">UserDetailsWidget</code> <em class="lq"> </em>屏幕的代码。</p><pre class="kj kk kl km gt lr ls lt lu aw lv bi"><span id="6b01" class="lw lx it ls b gy ly lz l ma mb">struct UserDetailsWidget: WidgetView {</span><span id="656d" class="lw lx it ls b gy nu lz l ma mb">    var user: User</span><span id="3a2b" class="lw lx it ls b gy nu lz l ma mb">    func widget(_ context: WidgetContext) -&gt; Widget {<br/>        ScrollWidget(<br/>            VStackWidget([<br/>                ContainerWidget(<br/>                    HStackWidget([<br/>                        UserPhotoWidget(<br/>                           initials: user.initials, <br/>                           size: 80<br/>                        ),<br/>                        LabelWidget(user.name)<br/>                            .font(.title1)<br/>                            .color(.red)<br/>                        ])<br/>                        .position(.centerHorizontally)<br/>                    ), <br/>                DetailsSectionWidget(widgets: [<br/>                    DetailsNameValueWidget(<br/>                        name: "Address", <br/>                        value: user.address<br/>                    ),<br/>                    DetailsNameValueWidget(<br/>                        name: "City",<br/>                        value: user.city<br/>                    ),<br/>                    DetailsNameValueWidget(<br/>                        name: "State", <br/>                        value: user.state<br/>                    ),<br/>                    DetailsNameValueWidget(<br/>                        name: "Zip", <br/>                        value: user.zip<br/>                    ),<br/>                    ]),<br/>                DetailsSectionWidget(widgets: [<br/>                    DetailsNameValueWidget(<br/>                        name: "Email", <br/>                        value: user.email<br/>                    )<br/>                    ]),<br/>                ])<br/>                .spacing(20)<br/>            ) <br/>            .backgroundColor(.systemBackground)<br/>            .safeArea(false)<br/>            .padding(20)<br/>            .navigationBar(title: "User Information", hidden: false)<br/>    }<br/>}</span></pre><p id="78aa" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">在我们的第一次演练之后，这段代码应该同样容易理解。一辆<code class="fe nv nw nx ls b">ScrollWidget</code>造一辆<code class="fe nv nw nx ls b">UIScrollView</code>。一个<code class="fe nv nw nx ls b">HStackWidget</code>造一个横<code class="fe nv nw nx ls b">UIStackView</code>，以此类推。</p><p id="089d" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">但是，可能有一些小部件看起来不太明显…</p></div><div class="ab cl me mf hx mg" role="separator"><span class="mh bw bk mi mj mk"/><span class="mh bw bk mi mj mk"/><span class="mh bw bk mi mj"/></div><div class="im in io ip iq"><h1 id="15ee" class="ml lx it bd mm mn mo mp mq mr ms mt mu jz mv ka mw kc mx kd my kf mz kg na nb bi translated">作文</h1><p id="a98f" class="pw-post-body-paragraph ku kv it kw b kx no ju kz la np jx lc ld nq lf lg lh nr lj lk ll ns ln lo lp im bi translated">像SwiftUI和Flutter一样，RxSwiftWidgets鼓励合成。您可能已经注意到，我们的细节示例使用了一个<code class="fe nv nw nx ls b">DetailsSectionWidget</code>和一个<code class="fe nv nw nx ls b">DetailsNameValueWidget</code>，并且列表和细节屏幕都使用了一个<code class="fe nv nw nx ls b">UserPhotoWidget</code>。</p><p id="2eac" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">那么它们是什么呢？干脆更<code class="fe nv nw nx ls b">WidgetView</code> s。</p><p id="1cff" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">这里是<code class="fe nv nw nx ls b">UserPhotoWidget</code>。</p><pre class="kj kk kl km gt lr ls lt lu aw lv bi"><span id="0dfc" class="lw lx it ls b gy ly lz l ma mb">struct UserPhotoWidget: WidgetView {</span><span id="1a9c" class="lw lx it ls b gy nu lz l ma mb">    var initials: String?<br/>    var size: CGFloat</span><span id="af91" class="lw lx it ls b gy nu lz l ma mb">    func widget(_ context: WidgetContext) -&gt; Widget {<br/>        ZStackWidget([<br/>            LabelWidget(initials)<br/>                .font(size &gt; 40 ? .title1 : .body)<br/>                .alignment(.center)<br/>                .backgroundColor(.gray)<br/>                .color(.white),<br/>            ImageWidget(named: "User-\(initials ?? "")")<br/>            ])<br/>            .height(size)<br/>            .width(size)<br/>            .cornerRadius(size/2)<br/>    }</span><span id="e517" class="lw lx it ls b gy nu lz l ma mb">}</span></pre><p id="45c8" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">同样，事情应该看起来很熟悉。我们的photo小部件由一个image小部件组成，直接放置在z-stack中的label小部件上，用于让您可视化地将元素堆叠在另一个之上。</p><p id="4ddc" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">使用<code class="fe nv nw nx ls b">height</code>和<code class="fe nv nw nx ls b">width</code>修改器将z堆栈限制为所需的大小，并使用<code class="fe nv nw nx ls b">cornerRadius</code>修改器将其变成一个圆。</p><p id="0ecb" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">注意，label小部件根据字体本身的大小来调整所用字体的大小。这让我们可以在列表和细节屏幕上使用相同的用户定义的小部件，以及我们可能希望使用它的任何其他地方。</p><p id="065f" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">那就是界面构成。</p><p id="ff34" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">界面构成的坏处？实际上，一个都没有。</p><p id="3ce4" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">RxSwiftWidgets是高性能和非资源密集型的。与SwiftUI一样，小部件/视图“定义”通常是基于结构的值类型，许多修饰符只不过是基于键路径的赋值。</p><p id="1e90" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">生成实际对应的UIViews <strong class="kw iu">确实比</strong>更耗费资源，但是无论如何都需要创建这些视图，不管您是否使用RxSwiftWidgets，手动构建它们，或者从故事板生成它们。</p><p id="d935" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">好的一面？不像使用故事板和笔尖，用几十个IBOUtlets把它们绑定到<code class="fe nv nw nx ls b">UIViewControllers</code>和<code class="fe nv nw nx ls b">UIViews</code>上，这种方法积极地鼓励把你的界面分解成小的、独立的、容易理解的、容易测试的界面元素。</p></div><div class="ab cl me mf hx mg" role="separator"><span class="mh bw bk mi mj mk"/><span class="mh bw bk mi mj mk"/><span class="mh bw bk mi mj"/></div><div class="im in io ip iq"><h1 id="e343" class="ml lx it bd mm mn mo mp mq mr ms mt mu jz mv ka mw kc mx kd my kf mz kg na nb bi translated">RxSwift属性包装器和Observables</h1><p id="c4c8" class="pw-post-body-paragraph ku kv it kw b kx no ju kz la np jx lc ld nq lf lg lh nr lj lk ll ns ln lo lp im bi translated">像SwiftUI一样，RxSwiftWidgets定义了状态和绑定属性包装器。</p><pre class="kj kk kl km gt lr ls lt lu aw lv bi"><span id="bfec" class="lw lx it ls b gy ly lz l ma mb"> @State var username: String = "Michael Long"<br/> @State var password: String = ""<br/> @State var authenticated: Bool = false<br/> @State var error: String = ""</span></pre><p id="16cc" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">这些属性包装器包装RxSwift observables，这样，当绑定到特定小部件的属性时，任何状态更改都会自动更新小部件生成的UIView。</p><p id="b56c" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">在某些情况下，绑定是双向的，比如上面的密码字符串被绑定到一个<code class="fe nv nw nx ls b">TextFieldWidget</code> …</p><pre class="kj kk kl km gt lr ls lt lu aw lv bi"><span id="50d3" class="lw lx it ls b gy ly lz l ma mb">TextFieldWidget($password)</span></pre><p id="86c7" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">您还可以使用<code class="fe nv nw nx ls b">onEvent</code>修饰符“监听”状态变化。</p><pre class="kj kk kl km gt lr ls lt lu aw lv bi"><span id="1fe3" class="lw lx it ls b gy ly lz l ma mb">.onEvent($authenticated.filter { $0 }) { (_, context) in<br/>    context.navigator?.dismiss()<br/>}</span></pre><p id="5bdb" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">上面的例子直接取自RxSwiftWidgets的<a class="ae md" href="https://github.com/hmlongco/RxSwiftWidgets/blob/master/RxSwiftWidgetsDemo/Application/Login/LoginFormWidget.swift" rel="noopener ugc nofollow" target="_blank">登录表单演示</a>。</p></div><div class="ab cl me mf hx mg" role="separator"><span class="mh bw bk mi mj mk"/><span class="mh bw bk mi mj mk"/><span class="mh bw bk mi mj"/></div><div class="im in io ip iq"><h1 id="afcc" class="ml lx it bd mm mn mo mp mq mr ms mt mu jz mv ka mw kc mx kd my kf mz kg na nb bi translated">综合</h1><p id="6a8f" class="pw-post-body-paragraph ku kv it kw b kx no ju kz la np jx lc ld nq lf lg lh nr lj lk ll ns ln lo lp im bi translated">由于RxSwiftWidgets是基于UIKit的，因此很容易将RxSwiftWidgets集成到现有的应用程序中。</p><p id="1410" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">只需将一个RxSwiftWidget包装在一个<code class="fe nv nw nx ls b">UIWidgetHostController</code>中，并将其推送到导航堆栈上。RxSwiftWidgets将从那里接管。</p><pre class="kj kk kl km gt lr ls lt lu aw lv bi"><span id="7b12" class="lw lx it ls b gy ly lz l ma mb">let vc = UIWidgetHostController(MyWidget())<br/>navigationController?.pushViewController(vc, animated: true)</span></pre><p id="6a92" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">也可以在现有的布局中使用小部件，您还可以在RxSwiftWidget布局中翻转和使用您自己的自定义UIViews和控件。</p><p id="de53" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">只需实例化视图，将其包装在一个<code class="fe nv nw nx ls b">UIViewWidget</code>中，并将其插入到布局中所需的位置。</p><pre class="kj kk kl km gt lr ls lt lu aw lv bi"><span id="5e3c" class="lw lx it ls b gy ly lz l ma mb">VStackWidget([<br/>   …<br/>   UIViewWidget(MyCustomUIView())<br/>       .hidden(viewModel.customViewIsHidden),<br/>   …<br/>])</span></pre><p id="d097" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">如图所示，您还可以使用标准的RxSwiftWidget修饰符来操作自定义视图上的属性。毕竟你的观点是<code class="fe nv nw nx ls b">UIView</code>。</p><p id="848d" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">使用RxSwiftWidgets，还可以使用<code class="fe nv nw nx ls b">with</code>修饰符直接操作视图的属性。这里我们设置UITextField的<code class="fe nv nw nx ls b">keyboardAppearance</code>,因为该属性还不能作为RxSwiftWidget修饰符直接使用。</p><pre class="kj kk kl km gt lr ls lt lu aw lv bi"><span id="6b43" class="lw lx it ls b gy ly lz l ma mb">TextFieldWidget($username)<br/>    .placeholder("Username / Email Address")<br/>    .with { textField, _ in<br/>       textField.keyboardAppearance = .dark<br/>    }</span></pre><p id="8805" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">创建自己的完全集成的小部件类型也很容易。你的选择。</p></div><div class="ab cl me mf hx mg" role="separator"><span class="mh bw bk mi mj mk"/><span class="mh bw bk mi mj mk"/><span class="mh bw bk mi mj"/></div><div class="im in io ip iq"><h1 id="ecce" class="ml lx it bd mm mn mo mp mq mr ms mt mu jz mv ka mw kc mx kd my kf mz kg na nb bi translated">正在进行的工作</h1><p id="b4ab" class="pw-post-body-paragraph ku kv it kw b kx no ju kz la np jx lc ld nq lf lg lh nr lj lk ll ns ln lo lp im bi translated">RxSwiftWidgets是一个测试版。</p><p id="c181" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">当前版本相当稳定，大部分内部核心功能都已就绪。</p><p id="7b00" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">这意味着，到目前为止，重点是内部稳定性和架构，而不是简单地添加尽可能多的开关、滑块和其他相对容易实现的控件和视图。</p><p id="9826" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">别担心，他们马上就来了。</p><p id="7edd" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">不过，如果您对实现一两个小部件感兴趣，请告诉我。</p></div><div class="ab cl me mf hx mg" role="separator"><span class="mh bw bk mi mj mk"/><span class="mh bw bk mi mj mk"/><span class="mh bw bk mi mj"/></div><div class="im in io ip iq"><h1 id="9549" class="ml lx it bd mm mn mo mp mq mr ms mt mu jz mv ka mw kc mx kd my kf mz kg na nb bi translated">要求</h1><p id="f714" class="pw-post-body-paragraph ku kv it kw b kx no ju kz la np jx lc ld nq lf lg lh nr lj lk ll ns ln lo lp im bi translated">RxSwiftWidgets需要Xcode 11，因为它使用了Swift 5.1的几个功能。</p><p id="02e2" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">还要看RxSwift和RxCocoa的当前版本。</p><p id="08f2" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">也就是说，如上所述，RxSwiftWidgets目前运行在iOS 11、12和13上。(很可能会更低，但我在这里和那里使用了几个iOS 11和up UIKit依赖项。)</p></div><div class="ab cl me mf hx mg" role="separator"><span class="mh bw bk mi mj mk"/><span class="mh bw bk mi mj mk"/><span class="mh bw bk mi mj"/></div><div class="im in io ip iq"><h1 id="748d" class="ml lx it bd mm mn mo mp mq mr ms mt mu jz mv ka mw kc mx kd my kf mz kg na nb bi translated">完成块</h1><p id="f172" class="pw-post-body-paragraph ku kv it kw b kx no ju kz la np jx lc ld nq lf lg lh nr lj lk ll ns ln lo lp im bi translated">从今年年初开始，我就一直在开发RxSwiftWidgets，后来WWDC来了，苹果发布了SwiftUI，我就停下了工作。</p><p id="2bd6" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">我再次选择它有三个原因，其中一个我已经详细讨论过了:SwiftUI只支持iOS 13。</p><p id="f420" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">第二个动机是观察SwiftUI的发展和演变，并意识到SwiftUI在很大程度上仍处于alpha阶段。</p><p id="59c9" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">当每个Xcode版本都通过更改和废弃的API破坏现有代码时，人们开始质疑SwiftUI多久才能稳定到足以用于生产应用程序。事实上，有几个关键领域(比如导航)我很确定我不能在SwiftUI中实现我当前的商业应用。</p><p id="4a69" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">我只是不确定它是否会在黄金时间准备好。</p><p id="8df0" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">第三个也是最后一个原因只是为了好玩。人们通过编码和扩展自己的思维来改进自己的代码，RxSwiftWidgets的很大一部分是使用从苹果SwiftUI实现中学到的概念重建的。</p><p id="c23c" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">这是一次很棒的经历。</p></div></div>    
</body>
</html>