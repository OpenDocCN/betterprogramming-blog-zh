<html>
<head>
<title>Two Tips to Better Handle Go Concurrency</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">更好地处理Go并发的两个技巧</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/two-tips-to-better-handle-go-concurrency-d369b86a32f4?source=collection_archive---------7-----------------------#2022-02-28">https://betterprogramming.pub/two-tips-to-better-handle-go-concurrency-d369b86a32f4?source=collection_archive---------7-----------------------#2022-02-28</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="982e" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">以下是我在goroutines上犯的两个错误，以及如何避免它们。</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/4d264aac66dee08674c90631a199415a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*qdT44yZ1dGFJ13ocV4AqqQ.jpeg"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated"><a class="ae ky" href="https://unsplash.com/@steve_j?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">斯蒂夫·约翰森</a>在<a class="ae ky" href="https://unsplash.com/s/photos/parallel?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍照</p></figure><p id="38ad" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">大多数Go开发者可能会同意，Go使得实现并发变得<strong class="lb iu">毫不费力</strong>。通过goroutines和channels，我们可以轻松地一起运行独立的功能，安排后台任务，等等。</p><p id="3cf4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">当我在Go中处理大型系统时，拥有Go优雅而丰富的并发支持是一件幸事。它帮助我加快了数据处理速度，最大限度地利用了硬件资源。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi lv"><img src="../Images/954a4a1cd075b465c4993ed9f7832323.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*3q92-XNCHoIH7LFfI_njkg.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">来源:<a class="ae ky" href="https://talks.golang.org/2012/waza.slide#1" rel="noopener ugc nofollow" target="_blank"> Go Talks </a></p></figure><p id="9e32" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">但是，正如本·帕克曾经说过的，</p><blockquote class="lw lx ly"><p id="5ae7" class="kz la lz lb b lc ld ju le lf lg jx lh ma lj lk ll mb ln lo lp mc lr ls lt lu im bi translated">强大的🕸 ️伴随着巨大的责任…</p></blockquote><p id="8ea3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">没有比这更真实的话了。尽管它们功能强大，但很容易被滥用。我目睹并犯了几个错误。他们中的一些人已经造成了生活，生产问题！</p><p id="e73a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在本文中，我将与您分享两个有用的技巧，它们可以帮助您更智能地使用goroutines。这些建议来自实际事件，所以系好安全带，让我们开始吧！🏃</p></div><div class="ab cl md me hx mf" role="separator"><span class="mg bw bk mh mi mj"/><span class="mg bw bk mh mi mj"/><span class="mg bw bk mh mi"/></div><div class="im in io ip iq"><h1 id="0c1e" class="mk ml it bd mm mn mo mp mq mr ms mt mu jz mv ka mw kc mx kd my kf mz kg na nb bi translated">使用并发限制</h1><p id="6239" class="pw-post-body-paragraph kz la it lb b lc nc ju le lf nd jx lh li ne lk ll lm nf lo lp lq ng ls lt lu im bi translated">并发的一个用例是在后台执行昂贵的任务，而不阻塞主逻辑流。这样，我们的代码可以(几乎)一起处理许多这样的任务，而不是让它们等待轮到自己。</p><p id="577b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">高开销任务的一个例子是在数据存储中批量插入或更新数据。</p><p id="0f9b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们看一个简单的系统。每当有数据更改时，服务器都会向队列发送消息。然后，工作人员将使用这些消息，将它们分组，并将其发送到存储器进行更新。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nh"><img src="../Images/e6c3ba1231391f4655788a3e39142f98.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*E1finbiBIb5DV-44bj6FSw.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">异步更新的经典例子</p></figure><p id="46ef" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">工人的代码可能如下所示。这是非常简单的，但它的要点是存在的。</p><pre class="kj kk kl km gt ni nj nk bn nl nm bi"><span id="587d" class="nn ml it nj b be no np l nq nr">type Message struct {<br/>  // Contain data updates<br/>}<br/><br/>type Worker struct {<br/>  msgChan          chan *Message // channel to receive messages from queue<br/>  batch            []*Message    // a batch of messages<br/>  maxBatchSize     uint32        // the maximum size of the batch<br/>}<br/><br/>func newWorker() *Worker {<br/>  return &amp;Worker {<br/>    msgChan:      make(chan *Message, 10000), // an internal queue size of 10000<br/>    maxBatchSize: 5000,<br/>  }<br/>}<br/><br/>// Start the worker<br/>func (w *Worker) start() {<br/>  go w.consume()   // a goroutine to consume<br/>  go w.process()   // a goroutine to process<br/>  <br/>  // Do something else...<br/>}<br/><br/>// Runs in a loop to consume from queue<br/>func (w *Worker) consume() {<br/>  for {<br/>    // blocks until there is a message<br/>    msg := consumeFromQueue()<br/>    w.msgChan &lt;- msg <br/>  }<br/>}<br/><br/>// Runs in a loop to process messages<br/>func (w *Worker) process() {<br/>  var batch []*Message<br/>  <br/>  for {<br/>    // blocks until there is a message<br/>    msg := &lt;- w.msgChan<br/>    <br/>    batch = w.batch<br/>    if batch == nil {<br/>      batch = make([]*Message, 0, w.maxBatchSize)<br/>    }<br/>    batch = append(batch, msg)<br/>    <br/>    // only commit when batch is full<br/>    if len(batch) &lt; w.maxBatchSize {<br/>      continue<br/>    }<br/>    <br/>    // batch update<br/>    go func(batch *[]Message) {<br/>      updateDataByBatch(batch)<br/>    }(batch)<br/>    <br/>    w.batch = nil // start new batch<br/>  }<br/>}</span></pre><p id="38fd" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">注意每批数据是如何在其goroutine中处理的。通过这种设计，大量涌入的消息将不会被阻塞，工作人员可以以非常快的速度处理它们。</p><p id="ac92" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">你能看出这个设计中的缺陷吗？</p><p id="a406" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">每批消息都会占用worker中的内存。只有在goroutine完成其批次后，即<code class="fe ns nt nu nj b">updateDataByBatch</code>返回后，内存才会被释放。</p><p id="e855" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果在大量消息涌入期间<code class="fe ns nt nu nj b">updateDataByBatch</code>有延迟，那么goroutines将开始堆积。由于它们每个都保存一批数据，这可能会导致内存消耗溢出。</p><p id="c5d2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">下面是我为我的员工设置的内存监控。在高延迟事件中，您可以看到内存使用的持续峰值。它甚至接近100%的使用率，导致内存不足和服务器崩溃。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nv"><img src="../Images/d26df34642c1052614e2aff425d2b33a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*hlXfJiZFzaX1W_3IrbgRdQ.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">三个工作实例内存溢出</p></figure><p id="1a63" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这是一个经典的性能bug，解决方法非常简单。我们只需要应用并发限制。</p><p id="a2e7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">并发限制限制了一个程序在执行任务时可以拥有的线程数。在上面的例子中，我们需要限制调用<code class="fe ns nt nu nj b">updateDataByBatch</code>时可以存在的goroutines的数量。</p><p id="503f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这种限制可以通过使用空结构<code class="fe ns nt nu nj b">struct{}</code>类型的通道来实现。</p><pre class="kj kk kl km gt ni nj nk bn nl nm bi"><span id="a0ad" class="nn ml it nj b be no np l nq nr">const concurrencyLimit = 300<br/><br/>type Worker struct {<br/>  // ...<br/>  wgChan chan struct{} // a channel to limit concurrency<br/>}<br/><br/>func newWorker() *Worker {<br/>  return &amp;Worker{<br/>    // ...<br/>    wgChan: make(chan struct{}, concurrencyLimit), // a max of 300 goroutines<br/>  }<br/>}<br/><br/>func (w *Worker) process() {<br/>  var batch []*Message<br/>  <br/>  for {<br/>    // ...<br/>    <br/>    // blocks unless there is space to start a new goroutine<br/>    w.wgChan &lt;- struct{}{}<br/>    <br/>    go func(batch *[]Message) {<br/>      defer func() {<br/>        &lt;- w.wgChan // goroutine is done!<br/>      }()<br/>      <br/>      updateDataByBatch(batch)<br/>    }(batch)<br/>    <br/>    // ...<br/>  }<br/>}</span></pre><p id="5472" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在上面的改进版本中，<code class="fe ns nt nu nj b">wg</code>代表<strong class="lb iu">等待组</strong>。<code class="fe ns nt nu nj b">w.wgChan &lt;- struct{}{}</code>要开创一个新的辉煌，就必须成功。如果它阻塞，这意味着goroutines的数量已经达到极限。</p><p id="f8cd" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">当一个goroutine完成时，它通过一个延迟函数清空<code class="fe ns nt nu nj b">wgChan</code>通道中的一个空间。这允许其他被阻塞的goroutines继续执行它们的任务。</p><p id="6d19" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">通过限制goroutines的数量，我们还可以限制worker中可以存在的挂起数据批的数量。这样就不太可能发生内存溢出。</p></div><div class="ab cl md me hx mf" role="separator"><span class="mg bw bk mh mi mj"/><span class="mg bw bk mh mi mj"/><span class="mg bw bk mh mi"/></div><div class="im in io ip iq"><h1 id="adf0" class="mk ml it bd mm mn mo mp mq mr ms mt mu jz mv ka mw kc mx kd my kf mz kg na nb bi translated">优雅地终止Goroutines</h1><p id="8602" class="pw-post-body-paragraph kz la it lb b lc nc ju le lf nd jx lh li ne lk ll lm nf lo lp lq ng ls lt lu im bi translated">除了批量更新数据之外，过滤大量数据也是一项昂贵的任务。</p><p id="7b85" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">特别是，给定一部分惟一的id，我想检查它们是否都存在于数据存储中。如果是，我想检索它们对应的值，并将它们放在一个新的片上，与它们的id在同一索引处。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nw"><img src="../Images/b41b698cc60f771f91dc066c309e77df.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*_MNSyKjcHbP58VejqtSeaQ.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">将结果存储在与id相同的索引中</p></figure><p id="f736" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">最简单的方法是遍历每个ID并在存储中搜索它们。但是，我们是Go开发者，所以让我们旋转几个goroutines并同时搜索每个ID！</p><pre class="kj kk kl km gt ni nj nk bn nl nm bi"><span id="9ea4" class="nn ml it nj b be no np l nq nr">type Item struct {<br/>  id    int<br/>  value string<br/>}<br/><br/>func getItems(itemIDs []int) ([]*Item, error) {<br/>  var (<br/>    concurencyLimit = 100 // set the limit!<br/>    wgChan          = make(chan struct{}, concurencyLimit)<br/>  )<br/>  <br/>  ctx := context.Background()<br/>  ctx, cancel := context.WithTimeout(ctx, 5*time.Second) // set timeout<br/>  defer cancel()<br/>  <br/>  items := make([]*Item, len(itemIDs))<br/>  <br/>  for i := range itemIDs {<br/>    select {<br/>      case &lt;- ctx.Done():<br/>        return nil, errors.New("timeout!") // return error if timeout<br/>      case wgChan &lt;- struct{}{}:<br/>    }<br/>    <br/>    go func(i int, itemID int) {<br/>      defer func() {<br/>        &lt;- wgChan // goroutine done!<br/>      }()<br/>      <br/>      //get item by ID, returns nil if not found<br/>      item := getItem(itemID)<br/>      <br/>      // place at the same index as itemID<br/>      items[i] = item<br/>    }(i, itemIDs[i])<br/>  }<br/>  <br/>  // wait for all goroutines to finish<br/>  for c := 0; c &lt; concurrencyLimit; c++ {<br/>    wgChan &lt;- struct{}{}<br/>  }<br/>  <br/>  return items, nil<br/>}</span></pre><p id="b79a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">对于每个<code class="fe ns nt nu nj b">itemID</code>，我们将启动一个新的goroutine，在数据存储中搜索相应的项目。在函数退出之前，我们必须确保所有正在运行的goroutines都已退出。</p><p id="732b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这就是所谓的优雅终止。可以用下面的循环来实现。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi nx"><img src="../Images/93d06d806fdc6481e7b1f463eed58187.png" data-original-src="https://miro.medium.com/v2/resize:fit:1240/format:webp/1*bYEKz7jffiXPUXJmkAOu2g.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">优雅的终结</p></figure><p id="6db7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在任何时间点，我们最多只能有<code class="fe ns nt nu nj b">concurrencyLimit</code>个goroutines。当循环无阻塞地完成时，它保证所有goroutines都已退出。然后，该函数可以安全退出。</p><p id="d2c0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果没有优雅的终止会怎么样？除了返回不完整的结果之外，该函数很可能会因索引超出范围错误而死机。</p><p id="2e44" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这是因为任何运行中的goroutine将尝试在位置<code class="fe ns nt nu nj b">i</code>索引<code class="fe ns nt nu nj b">items</code>切片。但是，因为功能已经退出，<code class="fe ns nt nu nj b">items</code>片不再存在！</p><p id="d549" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这是给你的一个测试。我已经删除了一些代码，使功能出错。如果你想找出问题所在，请在此暂停。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ny"><img src="../Images/a1350242a225f0007ca3dc9f7b973a6c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Mx90GdWLiWhJk1Pp-9COMQ.jpeg"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">照片由<a class="ae ky" href="https://unsplash.com/@arianassphotography?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">阿丽亚娜·苏亚雷斯</a>在<a class="ae ky" href="https://unsplash.com/s/photos/cookie?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>拍摄</p></figure><p id="bc96" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">当<strong class="lb iu">上下文在5秒钟后</strong>超时时，<code class="fe ns nt nu nj b">getItems</code>功能没有正常终止！如果任何goroutines在从存储中获取数据时出现延迟，它将会死机。</p><p id="edf5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这表明从头到尾完全理解每个goroutine在程序中的行为是多么重要。</p></div><div class="ab cl md me hx mf" role="separator"><span class="mg bw bk mh mi mj"/><span class="mg bw bk mh mi mj"/><span class="mg bw bk mh mi"/></div><div class="im in io ip iq"><h1 id="47a3" class="mk ml it bd mm mn mo mp mq mr ms mt mu jz mv ka mw kc mx kd my kf mz kg na nb bi translated">最后的想法</h1><p id="d33b" class="pw-post-body-paragraph kz la it lb b lc nc ju le lf nd jx lh li ne lk ll lm nf lo lp lq ng ls lt lu im bi translated">并发编程之所以具有挑战性，是因为我们的大脑更善于理解顺序流动的事物。当小程序在一个程序中运行时，很难预料到意想不到的事情！</p><p id="7d58" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">通过严格遵守我提供的两个建议，你就可以避免一些新手在使用goroutines时可能犯的错误。提高并发编程的唯一方法是练习和阅读更复杂的代码。</p><p id="3e0c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">你对goroutines的体验如何？你有什么建议想分享吗？让我知道！</p></div></div>    
</body>
</html>