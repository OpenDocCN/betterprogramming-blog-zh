<html>
<head>
<title>How To Avoid Blocking in Reactive Java</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何在反应式Java中避免阻塞</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/how-to-avoid-blocking-in-reactive-java-757ec7024676?source=collection_archive---------1-----------------------#2021-06-09">https://betterprogramming.pub/how-to-avoid-blocking-in-reactive-java-757ec7024676?source=collection_archive---------1-----------------------#2021-06-09</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="5abb" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">异步编程的良好实践</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/01702a2c596c549698caa5ff69d028b2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*JAtiw9HI_AMK3HlA1FeYoA.jpeg"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">图片来自<a class="ae ky" href="https://pixabay.com/users/jonbonsilver-236141/?utm_source=link-attribution&amp;utm_medium=referral&amp;utm_campaign=image&amp;utm_content=332857" rel="noopener ugc nofollow" target="_blank">约翰·霍华德</a>来自<a class="ae ky" href="https://pixabay.com/?utm_source=link-attribution&amp;utm_medium=referral&amp;utm_campaign=image&amp;utm_content=332857" rel="noopener ugc nofollow" target="_blank"> Pixabay </a></p></figure><p id="c865" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">反应式编程的关键是做出反应。你不要说“现在做”，你要说“什么时候做”“什么时候”适用于你有工作要做的时候。工作以事件的形式出现:消息总线上的消息或HTTP请求。</p><p id="0942" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">首先，我应该解释为什么反应式编程很重要。Java的好处之一是线程相对容易。这使得线程成为处理事件的主要模型。当你得到一个事件时，你分派一个线程来处理它。问题是当你得到很多事件时，你最终会创建很多线程。线程可能很昂贵；每个线程都有堆栈内存，切换线程需要系统调用和上下文切换。</p><p id="76df" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><a class="ae ky" href="https://nodejs.org/en/" rel="noopener ugc nofollow" target="_blank"> Node.js </a>系统在创建时只有一个线程。(它在v10.5.0中引入了工作线程)。然而，它成为一个非常受欢迎的系统，用于构建可以处理成千上万个请求的服务器。它通过使用事件驱动的习语来处理请求。因为它只有一个单线程，所以大多数实现HTTP服务器或客户机、数据库客户机或其他I/O密集型库的库都必须使用单线程的单事件循环。</p><p id="03f3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">但是Java使用的是请求线程数，这已经成为伸缩的瓶颈。像<a class="ae ky" href="https://www.scala-lang.org/" rel="noopener ugc nofollow" target="_blank"> Scala </a>这样的语言，之所以这样命名是因为它更具可伸缩性，是用广泛的框架创建的，以支持事件驱动或异步I/O。Java 9引入了带有<code class="fe lv lw lx ly b">Publisher</code>和<code class="fe lv lw lx ly b">Subscriber</code>的<code class="fe lv lw lx ly b">Flow</code>类。这些被用作两个完全反应式框架<a class="ae ky" href="https://github.com/ReactiveX/RxJava" rel="noopener ugc nofollow" target="_blank"> RxJava </a>和<a class="ae ky" href="https://projectreactor.io/" rel="noopener ugc nofollow" target="_blank"> Project Reactor </a>的基础。</p><p id="d6c1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">因为Java使用每请求线程模型已经很久了，大多数处理I/O的库都会阻塞。他们可以阻塞，因为他们期望拥有正在运行的线程，并且不会阻塞其他请求。但是现在我们可以使用异步模型，它们就成了一个问题。因为Java现在有一个混合模型，所以很难判断在一个几乎异步的系统中何时以及如何使用线程。</p><p id="5643" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们举一个常见的例子。您有一个接受HTTP GET并查询另一个服务的服务。在这种情况下，为了简单起见，上游服务只是http://www.google.com。下面是Spring Boot的<a class="ae ky" href="https://spring.io/projects/spring-boot" rel="noopener ugc nofollow" target="_blank">实现:</a></p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="lz ma l"/></div></figure><p id="dae6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">运行这个，curl得到页面，查看日志:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="lz ma l"/></div></figure><p id="35e5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">请注意，返回线程与调用线程相同。线程在这段时间内被阻塞，必须等待，直到请求完成。</p><p id="fc4c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">那么我们如何疏通呢？在这个特殊的例子中有两种方法:正确的方法和错误的方法。我们先来看错误的方式。这包括创建一个新线程来调用阻塞调用。起初这似乎弄巧成拙，但是它释放了请求线程(在上面的例子中是<code class="fe lv lw lx ly b">reactor-http-nio-3</code>)来处理更多的请求，这些请求可能不会阻塞或者阻塞的时间更短。</p><p id="88f1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">为了实现这一点，我们使用<code class="fe lv lw lx ly b">Mono.fromCallable</code>而不是<code class="fe lv lw lx ly b">Mono.just</code>。然后我们使用<code class="fe lv lw lx ly b">subscribeOn</code>来改变线程:</p><pre class="kj kk kl km gt mb ly mc md aw me bi"><span id="7cbb" class="mf mg it ly b gy mh mi l mj mk">return Mono.<em class="ml">fromCallable</em>(() -&gt;<br/>    getHttpBlocking("https://www.google.com"))<br/>        .subscribeOn(Schedulers.<em class="ml">boundedElastic</em>())</span></pre><p id="e16c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">以下是使用此方法时的日志:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="lz ma l"/></div></figure><p id="866d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如您所见，输入请求仍然由<code class="fe lv lw lx ly b">reactor-http-nio-x</code>线程处理，但是阻塞调用和原始请求的后续返回由一个名为<code class="fe lv lw lx ly b">boundedElastic-x</code>的工作池线程处理。<code class="fe lv lw lx ly b">boundedElastic</code>调度程序将创建一个线程池，然后将使用它们的任务排队。有关更多信息，请参见:</p><div class="mm mn gp gr mo mp"><a href="https://projectreactor.io/docs/core/release/api/reactor/core/scheduler/Schedulers.html#boundedElastic--" rel="noopener  ugc nofollow" target="_blank"><div class="mq ab fo"><div class="mr ab ms cl cj mt"><h2 class="bd iu gy z fp mu fr fs mv fu fw is bi translated">调度程序(反应堆堆芯3.4.6)</h2><div class="mw l"><h3 class="bd b gy z fp mu fr fs mv fu fw dk translated">以new为前缀的工厂(例如newBoundedElastic(int，int，String)返回其风格的新实例，而…</h3></div><div class="mx l"><p class="bd b dl z fp mu fr fs mv fu fw dk translated">projectreactor.io</p></div></div></div></a></div><p id="7ca9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们什么时候会用这种“错误”的方式？当我们别无选择时。如果库提供了异步选项，我们应该使用它。幸运的是，Spring Boot为我们提供了<code class="fe lv lw lx ly b">WebClient</code>类型:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="lz ma l"/></div></figure><p id="6b7d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在我们可以在控制器类中直接返回它，因为返回类型<code class="fe lv lw lx ly b">Mono&lt;String&gt;</code>是相同的。运行并执行一个查询，您应该在日志中看到:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="lz ma l"/></div></figure><p id="2917" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在您可以看到请求本身的开始是由线程<code class="fe lv lw lx ly b">reactor-http-nio-3</code>处理的。但是来自上游请求的返回和原始请求的后续返回是由线程<code class="fe lv lw lx ly b">reactor-http-nio-5</code>处理的。在等待处理上游请求的过程中，不会浪费任何线程。</p><p id="fc19" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果你使用的是Spring Boot的WebFlux版本，你应该放弃使用<code class="fe lv lw lx ly b">RestTemplate</code>，转而使用<code class="fe lv lw lx ly b">WebClient</code>。否则，你仍然在阻塞，你将不会从WebFlux中获得任何优势。注意，如果你正在使用WebFlux，但是想使用RxJava库:我还没有找到<code class="fe lv lw lx ly b">WebClient</code>的RxJava版本，所以你必须转换。Project Reactor有一个专用的适配器:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="lz ma l"/></div></figure><p id="43b9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">其他库可能不提供异步方法，所以您将坚持使用“错误的”方法来处理阻塞方法，将其作为分配给工作池的任务。如果您正在处理一个新项目，这可能会影响您在数据库和消息队列等方面的决策，如果它们提供异步库的话。</p><p id="18a3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我希望这篇文章能帮助您让您的服务平稳高效地运行。您可以在这里找到本文中使用的所有代码:</p><div class="mm mn gp gr mo mp"><a href="https://github.com/rkamradt/blockingnono/tree/v0.1" rel="noopener  ugc nofollow" target="_blank"><div class="mq ab fo"><div class="mr ab ms cl cj mt"><h2 class="bd iu gy z fp mu fr fs mv fu fw is bi translated">rkamradt/blockingnono</h2><div class="mw l"><h3 class="bd b gy z fp mu fr fs mv fu fw dk translated">与我关于反应式Java的文章配套的代码。通过在…上创建帐户，为rkamradt/blockingnono开发做出贡献</h3></div><div class="mx l"><p class="bd b dl z fp mu fr fs mv fu fw dk translated">github.com</p></div></div><div class="my l"><div class="mz l na nb nc my nd ks mp"/></div></div></a></div></div></div>    
</body>
</html>