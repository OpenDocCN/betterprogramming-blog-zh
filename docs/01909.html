<html>
<head>
<title>Fighting State Redundancy in Model-View-View-Model in iOS</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">在iOS的模型-视图-视图-模型中对抗状态冗余</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/mvvm-state-redundancy-c9e079ff02f3?source=collection_archive---------18-----------------------#2019-10-21">https://betterprogramming.pub/mvvm-state-redundancy-c9e079ff02f3?source=collection_archive---------18-----------------------#2019-10-21</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="b259" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">使用MVVM和RxSwift加载并显示播客列表</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/42befaf160b03ba2f77d2f1cd36c5e10.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*8-yKRv74Xfsk_zqz"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">照片由<a class="ae kv" href="https://unsplash.com/@estherrj?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Esther Jiao </a>在<a class="ae kv" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</p></figure><p id="f18f" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">移动应用程序中最常见的实际问题之一是从服务器加载可显示的数据，这些数据可以是任何东西，从用户的提要或播客列表到个人资料图片或流媒体视频。</p><p id="a682" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">应用程序显示各种微调器和滚动条来指示加载过程，这一切都是为了诱导用户的耐心并改善他们的体验。</p><p id="a8dc" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">然而，这个看似微不足道的问题对程序员来说隐藏着隐患，天真的实现可能导致编写过多的代码和修复突发的错误。</p><p id="974d" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">让我们举一个简单的例子，我们需要使用<a class="ae kv" href="https://en.wikipedia.org/wiki/Model-view-viewmodel" rel="noopener ugc nofollow" target="_blank"> Model-View-ViewModel </a>模式为屏幕结构加载并显示播客列表，使用<a class="ae kv" href="https://github.com/ReactiveX/RxSwift" rel="noopener ugc nofollow" target="_blank"> RxSwift </a>进行UI绑定。</p><h1 id="3b88" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">模型</h1><p id="0a4a" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">用于保存播客记录基本信息的不可变结构:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mp mq l"/></div></figure><p id="9615" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">网络层用这个微小的协议来表示；为了简化示例，我将省略实际的网络代码:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mp mq l"/></div></figure><h1 id="9ff1" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">视图模型</h1><p id="0ee3" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">对于播客列表，我们需要一个可观察的<code class="fe mr ms mt mu b">Podcast</code>结构数组。为此，我们将<code class="fe mr ms mt mu b">[Podcast]</code>包装在来自<code class="fe mr ms mt mu b">RxSwift</code>的<code class="fe mr ms mt mu b">BehaviorRelay</code>类中，这基本上是一个<strong class="ky ir">可观察属性</strong>，它总是保存一个值:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mp mq l"/></div></figure><p id="2ccf" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">如您所见，我们通过引用<code class="fe mr ms mt mu b">PodcastsService</code>为ViewModel提供了对网络层的访问。</p><p id="44f5" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><code class="fe mr ms mt mu b">Podcast</code>记录的数组最初是空的，但是<code class="fe mr ms mt mu b">loadPodcasts()</code>函数允许ViewModel的用户在适当的时候查询播客，并且当请求完成时，它更新播客的列表。</p><h1 id="7014" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">视角</h1><p id="d68f" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">用于显示播客信息的简单TableViewCell:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mp mq l"/></div></figure><p id="a74f" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">最后是显示播客列表的ViewController:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mp mq l"/></div></figure><p id="f4bf" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">考虑到<code class="fe mr ms mt mu b">viewModel</code>是从外部实例化并注入到<code class="fe mr ms mt mu b">ViewController</code>中的，现在我们有了一个全功能的<code class="fe mr ms mt mu b">MVVM</code>模块，它可以自动加载并显示播客列表。</p><p id="5431" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">唯一的问题是该应用程序目前不是用户友好的。它没有装载过程的指示器；它也没有显示网络层可能出现的错误。</p><p id="7e0e" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">让我们更新视图模型来应对挑战:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mp mq l"/></div></figure><p id="9987" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们添加了用于跟踪加载状态的<code class="fe mr ms mt mu b">isLoading</code>布尔属性，以及用于报告错误的<code class="fe mr ms mt mu b">onError</code> PublishRelay。</p><p id="edbd" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">现在我们需要更新UI并将其与状态更新绑定在一起:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mp mq l"/></div></figure><p id="2da2" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">好了，现在我们显示<code class="fe mr ms mt mu b">viewModel.isLoading</code>报告播客正在加载时的<code class="fe mr ms mt mu b">UIActivityIndicatorView</code>，还有一个<code class="fe mr ms mt mu b">UILabel</code>用于显示<code class="fe mr ms mt mu b">viewModel.onError</code>发出的错误</p><p id="9240" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">请注意，在第16–17行中，当<code class="fe mr ms mt mu b">podcasts</code>有任何记录时，我们还必须显式隐藏<code class="fe mr ms mt mu b">errorMessageLabel</code>，因为否则，即使播客请求在最初出错后成功，错误消息也会留在屏幕上。</p><p id="61a1" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">你已经能感觉到代码的味道了。对于这样一个简单的用例，我们已经开始对抗状态不一致性。</p><p id="7253" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">让我们深吸一口气，然后思考一分钟。我们的屏幕实际上可能有哪些状态？</p><ol class=""><li id="d1c2" class="mv mw iq ky b kz la lc ld lf mx lj my ln mz lr na nb nc nd bi translated">播客尚未被查询</li><li id="baf7" class="mv mw iq ky b kz ne lc nf lf ng lj nh ln ni lr na nb nc nd bi translated">正在加载播客</li><li id="a853" class="mv mw iq ky b kz ne lc nf lf ng lj nh ln ni lr na nb nc nd bi translated">播客加载失败</li><li id="8200" class="mv mw iq ky b kz ne lc nf lf ng lj nh ln ni lr na nb nc nd bi translated">播客已成功载入</li></ol><p id="297d" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">没错，就四箱！我们现在拥有的状态值的叠加(<code class="fe mr ms mt mu b">podcasts</code>是否为空，<code class="fe mr ms mt mu b">isLoading</code>和<code class="fe mr ms mt mu b">onError</code>)给了我们<code class="fe mr ms mt mu b">2*2*2 = 8</code>种可能的情况。这种状态冗余是我们必须对<code class="fe mr ms mt mu b">podcasts</code>和<code class="fe mr ms mt mu b">onError</code>的冲突值进行修复的原因。事实上，这意味着还有其他我们没有考虑到的组合，它们会导致不必要的影响，例如同时显示<em class="nj">错误信息</em>和<em class="nj">装载指示器</em>。</p><p id="980d" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">当我们发现问题时，我们可以重构当前的实现，通过引入带有这四种情况的<code class="fe mr ms mt mu b">enum</code>来清除状态冗余:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mp mq l"/></div></figure><p id="a594" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这个整洁的<code class="fe mr ms mt mu b">enum</code>允许我们以下面的方式返工<code class="fe mr ms mt mu b">ViewModel</code>:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mp mq l"/></div></figure><p id="9090" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">只用一个变量，我们就能代表所有的状态，但是现在——没有了状态冗余。</p><p id="7f00" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">重构ViewController:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mp mq l"/></div></figure><p id="23ef" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">为了方便映射上面代码中的<code class="fe mr ms mt mu b">Loadable&lt;[Podcast]&gt;</code>，我们可以对<code class="fe mr ms mt mu b">Loadable</code>使用扩展:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mp mq l"/></div></figure><p id="4ca1" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">太好了！现在我们的状态-UI绑定更加清晰，并且不需要过多的代码来修复视觉缺陷。</p><p id="3733" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">如果我们想在执行列表刷新时显示先前加载的列表，我们可以用一个保存值的参数来扩展<code class="fe mr ms mt mu b">isLoading</code>案例。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mp mq l"/></div></figure><p id="712e" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在Github 上的<a class="ae kv" href="https://gist.github.com/nalexn/df65131de76301130c8e179d02cec939" rel="noopener ugc nofollow" target="_blank">要点中可以找到<code class="fe mr ms mt mu b">Loadable</code>的最终实现，以及它的一些额外好处；然而，这只是一个如何通过消除视图模型中的状态冗余来提高反应式代码的清晰性和稳定性的例子。</a></p><p id="32eb" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在<a class="ae kv" href="https://twitter.com/nallexn" rel="noopener ugc nofollow" target="_blank">推特</a>上关注我，关注即将发布的帖子！</p></div><div class="ab cl nk nl hu nm" role="separator"><span class="nn bw bk no np nq"/><span class="nn bw bk no np nq"/><span class="nn bw bk no np"/></div><div class="ij ik il im in"><pre class="kg kh ki kj gt nr mu ns nt aw nu bi"><span id="e036" class="nv lt iq mu b gy nw nx l ny nz"><strong class="mu ir">Want to Stay Updated With My Latest Articles?<br/></strong>Here’s the <a class="ae kv" href="https://nalexn.github.io/feed.xml" rel="noopener ugc nofollow" target="_blank">RSS</a> link of my blog.</span></pre></div></div>    
</body>
</html>