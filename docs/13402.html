<html>
<head>
<title>Terraformer: Converting Infrastructure Into Reusable Terraform Code</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Terraformer:将基础设施转换成可重用的Terraform代码</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/terraformer-converting-infrastructure-into-reusable-terraform-code-afe543ad0b15?source=collection_archive---------2-----------------------#2022-08-24">https://betterprogramming.pub/terraformer-converting-infrastructure-into-reusable-terraform-code-afe543ad0b15?source=collection_archive---------2-----------------------#2022-08-24</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="416f" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">关于如何使用Terraformer从现有基础设施构建可重用Terraform代码的分步指南</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/068da22863901451f54d63cdcfae5f78.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*WjuRkFzEuvHSfMIp35d2Mw.jpeg"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">作者照片</p></figure><pre class="kj kk kl km gt ky kz la lb aw lc bi"><span id="088a" class="ld le it kz b gy lf lg l lh li">Table of Contents</span><span id="5ebf" class="ld le it kz b gy lj lg l lh li">· <a class="ae lk" href="#00bb" rel="noopener ugc nofollow">What is Terraformer?</a><br/>· <a class="ae lk" href="#5116" rel="noopener ugc nofollow">Why Terraformer?</a><br/>· <a class="ae lk" href="#5c31" rel="noopener ugc nofollow">How to Use Terraformer?</a><br/>  ∘ <a class="ae lk" href="#1323" rel="noopener ugc nofollow">Step 1: Installation</a><br/>  ∘ <a class="ae lk" href="#1916" rel="noopener ugc nofollow">Step 2: Terraformer import</a><br/>  ∘ <a class="ae lk" href="#7c58" rel="noopener ugc nofollow">Step 3: Templatize the Generated Code for Reusability</a><br/>  ∘ <a class="ae lk" href="#da83" rel="noopener ugc nofollow">Step 4: Standardize Terraform Modular Structure</a><br/>  ∘ <a class="ae lk" href="#58b8" rel="noopener ugc nofollow">Step 5: Add a GitHub Actions Workflow</a><br/>· <a class="ae lk" href="#aee9" rel="noopener ugc nofollow">Summary</a></span></pre><p id="9149" class="pw-post-body-paragraph ll lm it ln b lo lp ju lq lr ls jx lt lu lv lw lx ly lz ma mb mc md me mf mg im bi translated">“全栈”的新概念不再只是UI加后端。云原生应用程序开发需要将基础架构即代码(IaC)添加到您的“完整堆栈”列表中。Terraformer可以极大地帮助您扩展整个堆栈，以包括IaC。</p><h1 id="00bb" class="mh le it bd mi mj mk ml mm mn mo mp mq jz mr ka ms kc mt kd mu kf mv kg mw mx bi translated">什么是Terraformer？</h1><p id="cce8" class="pw-post-body-paragraph ll lm it ln b lo my ju lq lr mz jx lt lu na lw lx ly nb ma mb mc nc me mf mg im bi translated">我们中的许多人已经知道Terraform，它是主流的基础设施代码(IaC)语言。Terraformer就像是Terraform不太为人所知的孪生兄弟。它与Terraform完全相反——将基础设施逆向工程为代码。简单来说，Terraformer是一个CLI工具，它基于您现有的基础设施生成<code class="fe nd ne nf kz b">tf</code> / <code class="fe nd ne nf kz b">json</code>和<code class="fe nd ne nf kz b">tfstate</code>文件。</p><p id="5de9" class="pw-post-body-paragraph ll lm it ln b lo lp ju lq lr ls jx lt lu lv lw lx ly lz ma mb mc md me mf mg im bi translated">Terraformer在其<a class="ae lk" href="https://github.com/GoogleCloudPlatform/terraformer" rel="noopener ugc nofollow" target="_blank"> GitHub repo </a>中拥有超过9k颗星星，150多名贡献者，自2019年5月首次公开发布以来，已经赢得了巨大的人气，引领了将现有基础设施转换为Terraform代码的努力。</p><h1 id="5116" class="mh le it bd mi mj mk ml mm mn mo mp mq jz mr ka ms kc mt kd mu kf mv kg mw mx bi translated">为什么是Terraformer？</h1><p id="755b" class="pw-post-body-paragraph ll lm it ln b lo my ju lq lr mz jx lt lu na lw lx ly nb ma mb mc nc me mf mg im bi translated">让我们面对现实吧，我们中的许多人都没有奢侈的机会在一流的IaC公司找到工作。我们发现自己经常在继承的IaC混乱中挣扎，有一些合适的Terraform代码(如果你幸运的话)。但通常，许多开发人员带着多年来手工构建的基础架构来来去去。要将您现有的基础设施转换成Terraform代码，并开始向最先进的IaC目标前进，您需要使用Terraformer。</p><p id="a606" class="pw-post-body-paragraph ll lm it ln b lo lp ju lq lr ls jx lt lu lv lw lx ly lz ma mb mc md me mf mg im bi translated">此外，如果您想为您的生产资源开发一个Terraform模板，以便您可以轻松地将其复制到多个地区并用于灾难恢复，Terraformer是您的合适工具。</p><p id="4eef" class="pw-post-body-paragraph ll lm it ln b lo lp ju lq lr ls jx lt lu lv lw lx ly lz ma mb mc md me mf mg im bi translated">Terraformer可以提供重要帮助的另一个原因是，当您的架构师或技术负责人在您的云提供商中完成POC并手动构建一系列服务时。更好的是，当你最终让它们无缝地一起工作时，你就有了这个杰作。</p><p id="d159" class="pw-post-body-paragraph ll lm it ln b lo lp ju lq lr ls jx lt lu lv lw lx ly lz ma mb mc md me mf mg im bi translated">此时，您的工作开始了，您如何将所有出色的工作复制到另一个环境/客户中？好吧，和地球人交朋友！您可以用几个命令将所有堆栈转换成漂亮的Terraform代码！通过一些调整，您可以将生成的代码模板化，并在不同的环境/帐户中重复使用。</p><p id="fb4f" class="pw-post-body-paragraph ll lm it ln b lo lp ju lq lr ls jx lt lu lv lw lx ly lz ma mb mc md me mf mg im bi translated">让我们深入了解一下这是如何实现的。</p><h1 id="5c31" class="mh le it bd mi mj mk ml mm mn mo mp mq jz mr ka ms kc mt kd mu kf mv kg mw mx bi translated">如何使用Terraformer？</h1><h1 id="1323" class="mh le it bd mi mj mk ml mm mn mo mp mq jz mr ka ms kc mt kd mu kf mv kg mw mx bi translated"><strong class="ak">第一步:安装</strong></h1><p id="ccfe" class="pw-post-body-paragraph ll lm it ln b lo my ju lq lr mz jx lt lu na lw lx ly nb ma mb mc nc me mf mg im bi translated"><a class="ae lk" href="https://github.com/GoogleCloudPlatform/terraformer#installation" rel="noopener ugc nofollow" target="_blank"> Terraformer的GitHub页面</a>有安装Terraformer的详细说明。我们将遵循版本中的安装说明。</p><p id="31ef" class="pw-post-body-paragraph ll lm it ln b lo lp ju lq lr ls jx lt lu lv lw lx ly lz ma mb mc md me mf mg im bi translated"><strong class="ln iu">对于Windows: </strong></p><ul class=""><li id="d5ee" class="ng nh it ln b lo lp lr ls lu ni ly nj mc nk mg nl nm nn no bi translated">假设你已经安装了terra form:<a class="ae lk" href="https://www.terraform.io/downloads" rel="noopener ugc nofollow" target="_blank">https://www.terraform.io/downloads</a></li><li id="31a7" class="ng nh it ln b lo np lr nq lu nr ly ns mc nt mg nl nm nn no bi translated">导航到Terraformer发布页面，<a class="ae lk" href="https://github.com/GoogleCloudPlatform/terraformer/releases" rel="noopener ugc nofollow" target="_blank">https://github.com/GoogleCloudPlatform/terraformer/releases</a>，找到您想要的云提供商和操作系统的exe文件，例如，<code class="fe nd ne nf kz b"><a class="ae lk" href="https://github.com/GoogleCloudPlatform/terraformer/releases/download/0.8.21/terraformer-aws-windows-amd64.exe" rel="noopener ugc nofollow" target="_blank">terraformer-aws-windows-amd64.exe</a></code>是针对AWS作为提供商，针对Windows平台。</li><li id="4fb1" class="ng nh it ln b lo np lr nq lu nr ly ns mc nt mg nl nm nn no bi translated">将exe文件路径添加到path变量中，并将exe文件重命名为<code class="fe nd ne nf kz b">terraformer.exe</code>。</li><li id="5e67" class="ng nh it ln b lo np lr nq lu nr ly ns mc nt mg nl nm nn no bi translated">运行<code class="fe nd ne nf kz b">terraformer version</code>来检查你是否正确安装了它。在撰写本文时，最新的发布版本是<code class="fe nd ne nf kz b">v0.8.21</code>。</li></ul><p id="7f7b" class="pw-post-body-paragraph ll lm it ln b lo lp ju lq lr ls jx lt lu lv lw lx ly lz ma mb mc md me mf mg im bi translated"><strong class="ln iu">对于Mac: </strong></p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nu nv l"/></div></figure><h2 id="1916" class="ld le it bd mi nw nx dn mm ny nz dp mq lu oa ob ms ly oc od mu mc oe of mw og bi translated"><strong class="ak">步骤2:导入Terraformer】</strong></h2><p id="3654" class="pw-post-body-paragraph ll lm it ln b lo my ju lq lr mz jx lt lu na lw lx ly nb ma mb mc nc me mf mg im bi translated">让我们从名为<code class="fe nd ne nf kz b">terraformer-demo</code>的目录下的一个简单的<code class="fe nd ne nf kz b">main.tf</code>文件开始。对于这个演示项目，我们将使用AWS作为我们的提供商。<code class="fe nd ne nf kz b">main.tf</code>只有以下简单的提供者配置:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nu nv l"/></div></figure><p id="857b" class="pw-post-body-paragraph ll lm it ln b lo lp ju lq lr ls jx lt lu lv lw lx ly lz ma mb mc md me mf mg im bi translated">这是我们开始使用Terraformer所需的唯一文件。</p><p id="91d0" class="pw-post-body-paragraph ll lm it ln b lo lp ju lq lr ls jx lt lu lv lw lx ly lz ma mb mc md me mf mg im bi translated">Terraformer使用<a class="ae lk" href="https://www.terraform.io/docs/providers/index.html" rel="noopener ugc nofollow" target="_blank"> terraform providers </a>，其中已经包含了与云提供商的API协同工作的所有资源和逻辑。一个工具通过RPC调用与这些提供者一起工作，因此它允许他们使用新版本的提供者而无需修改代码。</p><p id="90b2" class="pw-post-body-paragraph ll lm it ln b lo lp ju lq lr ls jx lt lu lv lw lx ly lz ma mb mc md me mf mg im bi translated">现在让我们运行<code class="fe nd ne nf kz b">terraform init</code>来安装我们的AWS提供者所需的插件。如果一切顺利，您应该会在控制台上看到这样的输出，这表明Terraform已经成功初始化。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi oh"><img src="../Images/a6bd606189b3dfe5ce7ec91e18454138.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Gg5h2J5NzTBBYQ8ToJw4vQ.png"/></div></div></figure><p id="8b57" class="pw-post-body-paragraph ll lm it ln b lo lp ju lq lr ls jx lt lu lv lw lx ly lz ma mb mc md me mf mg im bi translated">出于演示目的，我正在使用我的AWS个人试用帐户，我已经在我的<code class="fe nd ne nf kz b">.aws\config</code>文件中配置了访问密钥和秘密密钥，见下面的截图，密钥在这里被屏蔽，用您自己的密钥替换它们。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi oi"><img src="../Images/85873a0d88710b56a870241598ca2947.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*NElqJdOzSs1h7K-PXcsQ5A.png"/></div></div></figure><p id="7082" class="pw-post-body-paragraph ll lm it ln b lo lp ju lq lr ls jx lt lu lv lw lx ly lz ma mb mc md me mf mg im bi translated">到目前为止，所有的准备工作已经完成。现在让我们进入有趣的部分，通过尝试<code class="fe nd ne nf kz b">terraformer import</code>来做一些Terraform的逆向工程！</p><h2 id="86ff" class="ld le it bd mi nw nx dn mm ny nz dp mq lu oa ob ms ly oc od mu mc oe of mw og bi translated"><strong class="ak">进口一种资源</strong></h2><p id="b5ed" class="pw-post-body-paragraph ll lm it ln b lo my ju lq lr mz jx lt lu na lw lx ly nb ma mb mc nc me mf mg im bi translated">让我们从简单的开始。在AWS控制台中手动创建一个EC2实例，一旦完成，记下它的实例id，在我的演示中，实例id是<code class="fe nd ne nf kz b">i-0e5b351eb8d11dd68</code>，现在让我们执行这个命令:</p><pre class="kj kk kl km gt ky kz la lb aw lc bi"><span id="5d43" class="ld le it kz b gy lf lg l lh li">terraformer import aws --resources=ec2_instance --filter=”Name=id;Value=<!-- -->i-0e5b351eb8d11dd68"</span></pre><p id="bf3b" class="pw-post-body-paragraph ll lm it ln b lo lp ju lq lr ls jx lt lu lv lw lx ly lz ma mb mc md me mf mg im bi translated">在上面的命令中，<code class="fe nd ne nf kz b">aws</code>是提供者。<code class="fe nd ne nf kz b">--resources</code>传入我们要从中生成Terraform代码的资源类型。<code class="fe nd ne nf kz b">--filter</code>用于根据特定的标准过滤资源，在我们的例子中，我们通过id <code class="fe nd ne nf kz b">i-0e5b351eb8d11dd68</code>过滤EC2实例。</p><p id="69d5" class="pw-post-body-paragraph ll lm it ln b lo lp ju lq lr ls jx lt lu lv lw lx ly lz ma mb mc md me mf mg im bi translated">运行该命令后，我们看到控制台输出如下:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi oj"><img src="../Images/4d9b7e2c959f18fd416d4282aea5e035.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*a92k5jiDEIYgpCGRQmc8ew.png"/></div></div></figure><p id="ae15" class="pw-post-body-paragraph ll lm it ln b lo lp ju lq lr ls jx lt lu lv lw lx ly lz ma mb mc md me mf mg im bi translated">现在让我们检查一下项目结构中发生了什么。注意一个名为<code class="fe nd ne nf kz b">generated</code>的新文件夹被创建了，请看下面截图中突出显示的部分。在<code class="fe nd ne nf kz b">generated</code>下，有我们提供者的<code class="fe nd ne nf kz b">aws</code>文件夹，下面是<code class="fe nd ne nf kz b">ec2_instance</code>文件夹，包含所有生成的terraform代码。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi ok"><img src="../Images/5f1d6a688bd31fffc97dab7db1fa4d62.png" data-original-src="https://miro.medium.com/v2/resize:fit:868/format:webp/1*40y5a1rvZyFG_cro3xIdlw.png"/></div></figure><p id="0c98" class="pw-post-body-paragraph ll lm it ln b lo lp ju lq lr ls jx lt lu lv lw lx ly lz ma mb mc md me mf mg im bi translated">打开<code class="fe nd ne nf kz b">instance.tf</code>，我们看看Terraformer刚刚表演了什么魔术！</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nu nv l"/></div></figure><p id="8720" class="pw-post-body-paragraph ll lm it ln b lo lp ju lq lr ls jx lt lu lv lw lx ly lz ma mb mc md me mf mg im bi translated">我们如何知道这个生成的代码确实是正确的呢？好吧，让我们来看看。让我们导航到目录<code class="fe nd ne nf kz b">ec2_instance</code>，然后运行<code class="fe nd ne nf kz b">terraform init</code>来初始化这个目录中的Terraform。然后运行<code class="fe nd ne nf kz b">terraform plan</code>，看看发生了什么？</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ol"><img src="../Images/8b1b4676ecee3c91282481a702e70abf.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*5tVB2Il_pNOvhJ2Pwm8D5Q.png"/></div></div></figure><p id="dfb2" class="pw-post-body-paragraph ll lm it ln b lo lp ju lq lr ls jx lt lu lv lw lx ly lz ma mb mc md me mf mg im bi translated">没有变化！它显示了Terraformer生成的代码与基础设施的实际状态相匹配。干得好Terraformer！</p><p id="3702" class="pw-post-body-paragraph ll lm it ln b lo lp ju lq lr ls jx lt lu lv lw lx ly lz ma mb mc md me mf mg im bi translated">默认情况下，Terraformer生成的代码适用于Terraform 0.12。当我们在生成的<code class="fe nd ne nf kz b">ec2_instance</code>文件夹中运行<code class="fe nd ne nf kz b">terraform init</code>时，会遇到以下错误:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi om"><img src="../Images/b9fa8ef34974fb5dbf15af0efa19b3de.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*6RszWB0We51yz9QW0dZ00Q.png"/></div></div></figure><p id="4033" class="pw-post-body-paragraph ll lm it ln b lo lp ju lq lr ls jx lt lu lv lw lx ly lz ma mb mc md me mf mg im bi translated">请确保运行此命令来更新状态文件中的提供程序。一旦完成，再次运行<code class="fe nd ne nf kz b">terraform init</code>，然后运行<code class="fe nd ne nf kz b">terraform plan</code>。</p><pre class="kj kk kl km gt ky kz la lb aw lc bi"><span id="de8b" class="ld le it kz b gy lf lg l lh li">terraform state replace-provider -auto-approve "registry.terraform.io/-/aws" "hashicorp/aws"</span></pre><h2 id="2d74" class="ld le it bd mi nw nx dn mm ny nz dp mq lu oa ob ms ly oc od mu mc oe of mw og bi translated"><strong class="ak">导入一种资源</strong></h2><p id="54dd" class="pw-post-body-paragraph ll lm it ln b lo my ju lq lr mz jx lt lu na lw lx ly nb ma mb mc nc me mf mg im bi translated">如果我们想要导入一种特定类型的资源，比如我们所有的Lambda函数，我们可以运行下面的命令:</p><pre class="kj kk kl km gt ky kz la lb aw lc bi"><span id="8267" class="ld le it kz b gy lf lg l lh li">terraformer import aws --resources=lambda</span></pre><p id="21cb" class="pw-post-body-paragraph ll lm it ln b lo lp ju lq lr ls jx lt lu lv lw lx ly lz ma mb mc md me mf mg im bi translated">这个命令将为我们配置的特定帐户和地区的所有Lambda函数生成Terraform代码。</p><h2 id="0a18" class="ld le it bd mi nw nx dn mm ny nz dp mq lu oa ob ms ly oc od mu mc oe of mw og bi translated"><strong class="ak">进口多种资源</strong></h2><p id="d5c1" class="pw-post-body-paragraph ll lm it ln b lo my ju lq lr mz jx lt lu na lw lx ly nb ma mb mc nc me mf mg im bi translated">如果我们想要导入多种类型的资源，只需用逗号分隔资源，例如下面的命令，它为我们所有的Lambda函数以及DynamoDB表导入:</p><pre class="kj kk kl km gt ky kz la lb aw lc bi"><span id="731d" class="ld le it kz b gy lf lg l lh li">terraformer import aws --resources=lambda,dynamodb</span></pre><h2 id="0e75" class="ld le it bd mi nw nx dn mm ny nz dp mq lu oa ob ms ly oc od mu mc oe of mw og bi translated"><strong class="ak">在同一资源类型内导入多个资源</strong></h2><p id="d67c" class="pw-post-body-paragraph ll lm it ln b lo my ju lq lr mz jx lt lu na lw lx ly nb ma mb mc nc me mf mg im bi translated">如果我们需要导入多个资源，我们也可以使用<code class="fe nd ne nf kz b">terraformer import</code>来完成。例如，如果我们需要导入两个Lambda函数，<code class="fe nd ne nf kz b">lambda-test1</code>和<code class="fe nd ne nf kz b">lambda-test2</code>，让我们试试这个命令:</p><pre class="kj kk kl km gt ky kz la lb aw lc bi"><span id="6013" class="ld le it kz b gy lf lg l lh li">terraformer import aws --resources=lambda --filter="Name=function_name;Value=lambda-test1:lambda-test2"</span></pre><p id="266b" class="pw-post-body-paragraph ll lm it ln b lo lp ju lq lr ls jx lt lu lv lw lx ly lz ma mb mc md me mf mg im bi translated">注意过滤器<code class="fe nd ne nf kz b">Name</code>是<code class="fe nd ne nf kz b">function_name</code>，<code class="fe nd ne nf kz b">Value</code>有两个函数名，用冒号分隔，<code class="fe nd ne nf kz b">:</code>。确保在这里使用正确的语法。一旦导入，<code class="fe nd ne nf kz b">generated/aws/lambda</code>下的<code class="fe nd ne nf kz b">lambda_function.tf</code>看起来如下:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nu nv l"/></div></figure><h2 id="97e9" class="ld le it bd mi nw nx dn mm ny nz dp mq lu oa ob ms ly oc od mu mc oe of mw og bi translated"><strong class="ak">通过标签使用过滤器导入资源</strong></h2><p id="a007" class="pw-post-body-paragraph ll lm it ln b lo my ju lq lr mz jx lt lu na lw lx ly nb ma mb mc nc me mf mg im bi translated">我们在上面的“导入一个资源”一节中简要地提到了过滤器。让我们在这里更深入地探讨如何最好地使用过滤器来为我们想要的资源导入代码。我们可以通过标签来过滤资源，例如，下面的命令通过标签<code class="fe nd ne nf kz b">name</code>和值<code class="fe nd ne nf kz b">test-table</code>来过滤DynamoDB资源。</p><p id="5a71" class="pw-post-body-paragraph ll lm it ln b lo lp ju lq lr ls jx lt lu lv lw lx ly lz ma mb mc md me mf mg im bi translated">请注意过滤器名称<code class="fe nd ne nf kz b">tags.name</code>，这是区分大小写的，如果您输入大写字母<code class="fe nd ne nf kz b">tags.Name</code>，如果您没有另一个定义了标签<code class="fe nd ne nf kz b">Name</code>的DynamoDB表，则过滤的服务数量可能为0。</p><pre class="kj kk kl km gt ky kz la lb aw lc bi"><span id="af20" class="ld le it kz b gy lf lg l lh li">terraformer import aws --resources=dynamodb --filter="Name=tags.name;Value=test-table"</span></pre><h2 id="589c" class="ld le it bd mi nw nx dn mm ny nz dp mq lu oa ob ms ly oc od mu mc oe of mw og bi translated"><strong class="ak">导入带有特定标记关键字的资源</strong></h2><p id="1a71" class="pw-post-body-paragraph ll lm it ln b lo my ju lq lr mz jx lt lu na lw lx ly nb ma mb mc nc me mf mg im bi translated">要使用特定的标签键过滤资源，假设我们想要使用定义了标签键<code class="fe nd ne nf kz b">name</code>的标签过滤DynamoDB，我们可以像这样运行命令，注意我们不需要指定<code class="fe nd ne nf kz b">Value</code>:</p><pre class="kj kk kl km gt ky kz la lb aw lc bi"><span id="b8e4" class="ld le it kz b gy lf lg l lh li">terraformer import aws --resources=dynamodb --filter="Name=tags.name"</span></pre><h2 id="98b3" class="ld le it bd mi nw nx dn mm ny nz dp mq lu oa ob ms ly oc od mu mc oe of mw og bi translated"><strong class="ak">导入所有资源</strong></h2><p id="8dfe" class="pw-post-body-paragraph ll lm it ln b lo my ju lq lr mz jx lt lu na lw lx ly nb ma mb mc nc me mf mg im bi translated">如果您想为整个基础架构堆栈生成Terraform代码，该怎么办？这个命令实际上非常简单:</p><pre class="kj kk kl km gt ky kz la lb aw lc bi"><span id="47e5" class="ld le it kz b gy lf lg l lh li">terraformer import aws --resources=*</span></pre><p id="da6d" class="pw-post-body-paragraph ll lm it ln b lo lp ju lq lr ls jx lt lu lv lw lx ly lz ma mb mc md me mf mg im bi translated">是的，使用通配符传入资源就可以了。然而，根据您的基础设施规模，这可能需要一些时间，并且在<code class="fe nd ne nf kz b">generated\aws</code>下创建的目录数量可能会令人震惊。</p><h2 id="8406" class="ld le it bd mi nw nx dn mm ny nz dp mq lu oa ob ms ly oc od mu mc oe of mw og bi translated"><strong class="ak">用excludes关键字</strong>导入资源</h2><p id="7737" class="pw-post-body-paragraph ll lm it ln b lo my ju lq lr mz jx lt lu na lw lx ly nb ma mb mc nc me mf mg im bi translated">如果需要排除某个资源的导入，可以使用<code class="fe nd ne nf kz b">--excludes</code>关键字，示例命令:</p><pre class="kj kk kl km gt ky kz la lb aw lc bi"><span id="2d7c" class="ld le it kz b gy lf lg l lh li">terraformer import aws --resources=* --excludes="dynamodb" </span></pre><h1 id="7c58" class="mh le it bd mi mj mk ml mm mn mo mp mq jz mr ka ms kc mt kd mu kf mv kg mw mx bi translated"><strong class="ak">第三步:将生成的代码模板化，以实现可重用性</strong></h1><p id="e95e" class="pw-post-body-paragraph ll lm it ln b lo my ju lq lr mz jx lt lu na lw lx ly nb ma mb mc nc me mf mg im bi translated">Terraformer从您现有的基础设施中生成的原始Terraform代码看起来很棒，但它的可重用性不是很好，因为它为您导入到代码中的特定资源提供了硬编码值。为了使代码可重用，我们需要稍微调整一下。例如，在上面为Lambda函数生成的代码中，它具有硬编码的Lambda函数名称、角色、处理程序等。</p><p id="b1d6" class="pw-post-body-paragraph ll lm it ln b lo lp ju lq lr ls jx lt lu lv lw lx ly lz ma mb mc md me mf mg im bi translated">如果我们想要重用这段代码，我们需要参数化这些变量来模板化这个特定的资源。这是Lambda函数Terraform代码模板化后的样子。注意这些参数以<code class="fe nd ne nf kz b">var</code>开始，引用它们的变量。对于这个例子，我们只选择了几个参数来具体化，也欢迎您参数化可选字段，以便在配置Lambda函数时实现最大的灵活性。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nu nv l"/></div></figure><p id="c25f" class="pw-post-body-paragraph ll lm it ln b lo lp ju lq lr ls jx lt lu lv lw lx ly lz ma mb mc md me mf mg im bi translated">对应的<code class="fe nd ne nf kz b">variables.tf</code>应该是这样的:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nu nv l"/></div></figure><p id="5906" class="pw-post-body-paragraph ll lm it ln b lo lp ju lq lr ls jx lt lu lv lw lx ly lz ma mb mc md me mf mg im bi translated">将生成的代码模板化后，一个自然的问题出现了:如何最好地组织我们生成的Terraform代码？让我们进入下一步。</p><h1 id="da83" class="mh le it bd mi mj mk ml mm mn mo mp mq jz mr ka ms kc mt kd mu kf mv kg mw mx bi translated">步骤4:标准化Terraform模块化结构</h1><p id="260a" class="pw-post-body-paragraph ll lm it ln b lo my ju lq lr mz jx lt lu na lw lx ly nb ma mb mc nc me mf mg im bi translated">一个Terraform模块只是一个定义了多个相关资源的<code class="fe nd ne nf kz b">.tf</code>配置文件的集合，以一种代码可以被重用的方式进行编码。使用模块的好处是，当在多个项目中做同样的事情时，编码工作会大大减少。</p><h2 id="4b3c" class="ld le it bd mi nw nx dn mm ny nz dp mq lu oa ob ms ly oc od mu mc oe of mw og bi translated">地形模块化结构的最佳实践</h2><ul class=""><li id="10d2" class="ng nh it ln b lo my lr mz lu on ly oo mc op mg nl nm nn no bi translated"><code class="fe nd ne nf kz b">main.tf</code>、<code class="fe nd ne nf kz b">variables.tf</code>、<code class="fe nd ne nf kz b">outputs.tf</code>。这些是最小模块的推荐文件名，即使它们是空的。<code class="fe nd ne nf kz b">main.tf</code>应该是主入口点。</li><li id="edbd" class="ng nh it ln b lo np lr nq lu nr ly ns mc nt mg nl nm nn no bi translated">项目的根目录可以称为“根模块”。嵌套模块，又名“子模块”，应该存在于<code class="fe nd ne nf kz b">modules/</code>子目录下。根模块中的代码通常根据需要调用子模块。</li><li id="e035" class="ng nh it ln b lo np lr nq lu nr ly ns mc nt mg nl nm nn no bi translated">这些模块可以嵌套，尽管建议深度不要超过3/4层，并尽可能避免这种情况，以降低复杂性。</li><li id="8322" class="ng nh it ln b lo np lr nq lu nr ly ns mc nt mg nl nm nn no bi translated">根模块和任何嵌套模块应该有<code class="fe nd ne nf kz b">README</code>文件。</li></ul><p id="d191" class="pw-post-body-paragraph ll lm it ln b lo lp ju lq lr ls jx lt lu lv lw lx ly lz ma mb mc md me mf mg im bi translated">模块化Terraform项目结构示例如下所示:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi oq"><img src="../Images/614cae7413674e4d5925d3ed45204b61.png" data-original-src="https://miro.medium.com/v2/resize:fit:854/format:webp/1*L8H9LuUcrlIjLh1ZeXubvg.png"/></div></figure><p id="b717" class="pw-post-body-paragraph ll lm it ln b lo lp ju lq lr ls jx lt lu lv lw lx ly lz ma mb mc md me mf mg im bi translated">注意<code class="fe nd ne nf kz b">modules</code>目录下的多个模块。推荐的方法是将这个<code class="fe nd ne nf kz b">modules</code>目录移动到一个共享的存储库中，这样组织中的所有项目都可以从它们各自的项目中调用那些集中的模板化的可重用模块。</p><p id="a59d" class="pw-post-body-paragraph ll lm it ln b lo lp ju lq lr ls jx lt lu lv lw lx ly lz ma mb mc md me mf mg im bi translated">还要注意位于环境相关目录下的<code class="fe nd ne nf kz b">.tfvars</code>文件，如<code class="fe nd ne nf kz b">.env</code>下的<code class="fe nd ne nf kz b">dev</code>和<code class="fe nd ne nf kz b">prod</code>。这些文件包含变量的环境特定值。</p><p id="4b61" class="pw-post-body-paragraph ll lm it ln b lo lp ju lq lr ls jx lt lu lv lw lx ly lz ma mb mc md me mf mg im bi translated">为了继续我们上面关于模板化Lambda模块的讨论，我们现在可以让根<code class="fe nd ne nf kz b">main.tf</code>调用Lambda可重用模块来创建两个新的Lambda函数<code class="fe nd ne nf kz b">lambda_demo1</code>和<code class="fe nd ne nf kz b">lambda_demo2</code>，参见下面来自我们根<code class="fe nd ne nf kz b">main.tf</code>的片段:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nu nv l"/></div></figure><p id="792b" class="pw-post-body-paragraph ll lm it ln b lo lp ju lq lr ls jx lt lu lv lw lx ly lz ma mb mc md me mf mg im bi translated">注意，我们在这里用根级别的<code class="fe nd ne nf kz b">variables.tf</code>文件中定义的变量参数化了<code class="fe nd ne nf kz b">role</code>。我们也可以参数化其他变量，但出于演示的目的，我们现在只展示一个。<code class="fe nd ne nf kz b">lambda_iam_role_arn</code>的实际值在<code class="fe nd ne nf kz b">.env/dev</code>文件夹下的<code class="fe nd ne nf kz b">terraform.tfvars</code>文件中定义。</p><pre class="kj kk kl km gt ky kz la lb aw lc bi"><span id="8e07" class="ld le it kz b gy lf lg l lh li">lambda_iam_role_arn = "arn:aws:iam::##########:role/service-role/lambda-test-role-#####"</span></pre><p id="c177" class="pw-post-body-paragraph ll lm it ln b lo lp ju lq lr ls jx lt lu lv lw lx ly lz ma mb mc md me mf mg im bi translated">更好的方法是使用Terraformer为IAM角色导入代码，并模块化那个<code class="fe nd ne nf kz b">iam</code>模块，然后在root <code class="fe nd ne nf kz b">main.tf</code>中创建一个新的Lambda IAM角色，然后使用Lambda块<code class="fe nd ne nf kz b">role = module.iam.iam_role_arn</code>中调用<code class="fe nd ne nf kz b">iam</code>模块的输出，而不是使用来自<code class="fe nd ne nf kz b">terraform.tfvars</code>的硬编码变量。好吧，欢迎读者使用这个场景作为练习。</p><h1 id="58b8" class="mh le it bd mi mj mk ml mm mn mo mp mq jz mr ka ms kc mt kd mu kf mv kg mw mx bi translated">步骤5:添加GitHub操作工作流</h1><p id="3ff5" class="pw-post-body-paragraph ll lm it ln b lo my ju lq lr mz jx lt lu na lw lx ly nb ma mb mc nc me mf mg im bi translated">现在有了Terraform项目结构，让我们探索如何使用GitHub Actions工作流将我们的Terraform代码部署到AWS。参见下面运行一系列Terraform命令的示例工作流:<code class="fe nd ne nf kz b">terraform init</code>、<code class="fe nd ne nf kz b">terraform plan</code>、<code class="fe nd ne nf kz b">terraform apply</code>，最后，如果需要，我们可以切换到名为<code class="fe nd ne nf kz b">destroy</code>的分支，运行<code class="fe nd ne nf kz b">terraform destroy</code>来删除我们刚刚在AWS中创建的资源。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nu nv l"/></div></figure><p id="a1eb" class="pw-post-body-paragraph ll lm it ln b lo lp ju lq lr ls jx lt lu lv lw lx ly lz ma mb mc md me mf mg im bi translated">请注意，我们将<code class="fe nd ne nf kz b">terraform.tfvars</code>和<code class="fe nd ne nf kz b">-var-file</code>传递给Terraform命令。根据从<code class="fe nd ne nf kz b">workflow_dispatch</code>手动触发器传入的环境，Terraform工作流在<code class="fe nd ne nf kz b">.env</code>下的环境文件夹中进行检查，并使用传入的相应<code class="fe nd ne nf kz b">.tfvars</code>文件为所选环境运行。</p><h1 id="aee9" class="mh le it bd mi mj mk ml mm mn mo mp mq jz mr ka ms kc mt kd mu kf mv kg mw mx bi translated">摘要</h1><p id="dc8e" class="pw-post-body-paragraph ll lm it ln b lo my ju lq lr mz jx lt lu na lw lx ly nb ma mb mc nc me mf mg im bi translated">我们探讨了什么是Terraformer，为什么我们需要它，以及如何使用它将现有的基础设施导入Terraform代码。然后，我们进一步研究了如何将生成的Terraform代码模板化，并使其可重用。我们还研究了Terraform模块化结构的一些最佳实践。最后但同样重要的是，我们探索了使用GitHub Actions工作流来自动化Terraform代码部署。</p><p id="e54d" class="pw-post-body-paragraph ll lm it ln b lo lp ju lq lr ls jx lt lu lv lw lx ly lz ma mb mc md me mf mg im bi translated">编码快乐！</p><h1 id="1592" class="mh le it bd mi mj mk ml mm mn mo mp mq jz mr ka ms kc mt kd mu kf mv kg mw mx bi translated"><strong class="ak">参考文献</strong></h1><div class="or os gp gr ot ou"><a href="https://github.com/GoogleCloudPlatform/terraformer" rel="noopener  ugc nofollow" target="_blank"><div class="ov ab fo"><div class="ow ab ox cl cj oy"><h2 class="bd iu gy z fp oz fr fs pa fu fw is bi translated">GitHub-GoogleCloudPlatform/terra former:CLI工具，用于从现有的…</h2><div class="pb l"><h3 class="bd b gy z fp oz fr fs pa fu fw dk translated">基于现有基础设施生成tf/ json和tfstate文件的CLI工具(反向地形)。免责声明…</h3></div><div class="pc l"><p class="bd b dl z fp oz fr fs pa fu fw dk translated">github.com</p></div></div><div class="pd l"><div class="pe l pf pg ph pd pi ks ou"/></div></div></a></div><p id="8877" class="pw-post-body-paragraph ll lm it ln b lo lp ju lq lr ls jx lt lu lv lw lx ly lz ma mb mc md me mf mg im bi translated"><a class="ae lk" href="https://www.terraform.io/language/modules/develop/structure" rel="noopener ugc nofollow" target="_blank">标准模块结构|哈希公司的terra form</a></p></div></div>    
</body>
</html>