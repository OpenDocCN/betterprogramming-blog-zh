<html>
<head>
<title>Implement Coordinator Design Pattern Using Combine</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用Combine实现协调器设计模式</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/implement-coordinator-design-pattern-using-combine-eed5008dafb1?source=collection_archive---------2-----------------------#2022-05-25">https://betterprogramming.pub/implement-coordinator-design-pattern-using-combine-eed5008dafb1?source=collection_archive---------2-----------------------#2022-05-25</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="9e4d" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">被动地在屏幕间导航和传递数据</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/4dcf8be48402da319f971940ccaba684.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*Sa3YvqjyGuTh5gfh"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">照片由<a class="ae ky" href="https://unsplash.com/@linusmimietz?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Linus Mimietz </a>在<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</p></figure><p id="bbb8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">本文将学习如何创建一个可重用的<code class="fe lv lw lx ly b">Coordinator</code>库，它将负责你的iOS应用程序内部的导航。</p><p id="1cac" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">简而言之，在本教程结束时，您将会学到以下内容:</p><ul class=""><li id="8f83" class="lz ma it lb b lc ld lf lg li mb lm mc lq md lu me mf mg mh bi translated">什么是<code class="fe lv lw lx ly b">Coordinator</code>设计模式</li><li id="b17c" class="lz ma it lb b lc mi lf mj li mk lm ml lq mm lu me mf mg mh bi translated">如何使用<code class="fe lv lw lx ly b">Combine</code>让<code class="fe lv lw lx ly b">Coordinator</code>无功而返？</li></ul><p id="c575" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">完成的包及其示例应用程序可以在文章的底部找到。</p><h1 id="72f9" class="mn mo it bd mp mq mr ms mt mu mv mw mx jz my ka mz kc na kd nb kf nc kg nd ne bi translated">我们开始吧</h1><p id="5d8c" class="pw-post-body-paragraph kz la it lb b lc nf ju le lf ng jx lh li nh lk ll lm ni lo lp lq nj ls lt lu im bi translated">在我们开始开发框架之前，你应该知道<code class="fe lv lw lx ly b">Coordinator</code>设计模式帮助我们将导航相关的逻辑从视图控制器中移出。因此，视图控制器对协调器有很强的依赖性，而协调器对视图控制器的依赖性很弱。<code class="fe lv lw lx ly b">View</code>当一个动作发生时，控制器触发必要的导航方法，例如，如果用户点击一个按钮。</p><p id="25b6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">不同的团队更喜欢<code class="fe lv lw lx ly b">view</code>控制器和<code class="fe lv lw lx ly b">coordinator</code>之间的不同关系。有些将<code class="fe lv lw lx ly b">Coordinator</code>属性放在视图模型或演示者中，而有些则放在视图控制器中。在本教程中，我们将遵循后一种方法，因为示例应用程序不会复杂到包含其他实体，如视图模型或演示者。</p><p id="297f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">事不宜迟，让我们深入研究代码。</p><h1 id="9caf" class="mn mo it bd mp mq mr ms mt mu mv mw mx jz my ka mz kc na kd nb kf nc kg nd ne bi translated">创建库</h1><p id="51a6" class="pw-post-body-paragraph kz la it lb b lc nf ju le lf ng jx lh li nh lk ll lm ni lo lp lq nj ls lt lu im bi translated">首先，我们创建一个<code class="fe lv lw lx ly b">Coordinator.swift</code>文件并添加一个通用的<code class="fe lv lw lx ly b">Coordinator</code>类:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nk nl l"/></div></figure><p id="ec34" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe lv lw lx ly b">CoordinationResult</code>是将在两个特定协调器之间传递的类型的占位符。当不需要传递值时，我们将使用<code class="fe lv lw lx ly b">Void</code>作为类型。在本教程的后面，我们将看到如何在屏幕之间传递自定义对象。</p><p id="f72b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在，让我们添加两个方法，这两个方法将是启动协调器工作和导航到其他协调器的核心:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nk nl l"/></div></figure><p id="2cee" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这里我们添加了<code class="fe lv lw lx ly b">coordinate&lt;T&gt;(to coordinator: Coordinator&lt;T&gt;)</code>方法，它将简单地调用我们想要导航到的协调器的<code class="fe lv lw lx ly b">start()</code>方法。</p><p id="838b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe lv lw lx ly b">start()</code>方法包含了一个<code class="fe lv lw lx ly b">fatalError()</code>，因为我们设计了这个<code class="fe lv lw lx ly b">Coordinator</code>类作为子类而不是原样使用。换句话说，每一个具体的<code class="fe lv lw lx ly b">Coordinator</code>都必须提供自己的<code class="fe lv lw lx ly b">start()</code>方法的实现。</p><p id="6748" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在这两种方法中，我们都返回<code class="fe lv lw lx ly b">AnyPublisher&lt;T, Never&gt;</code>，它表示被导航到的协调器的输出。稍后我们将看到如何使用它来传递数据。</p><p id="2999" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">框架完成后，现在让我们使用我们在示例应用程序中创建的内容。</p><h1 id="7d98" class="mn mo it bd mp mq mr ms mt mu mv mw mx jz my ka mz kc na kd nb kf nc kg nd ne bi translated">利用图书馆</h1><p id="b4ea" class="pw-post-body-paragraph kz la it lb b lc nf ju le lf ng jx lh li nh lk ll lm ni lo lp lq nj ls lt lu im bi translated">我们的目标是涵盖这些用例:</p><ul class=""><li id="f54c" class="lz ma it lb b lc ld lf lg li mb lm mc lq md lu me mf mg mh bi translated">显示一个欢迎页面，然后点击按钮，用标签栏显示主流程。</li><li id="ec6c" class="lz ma it lb b lc mi lf mj li mk lm ml lq mm lu me mf mg mh bi translated">在主流程中呈现一个<code class="fe lv lw lx ly b">view</code>控制器，然后将数据传递回呈现视图控制器。</li></ul><p id="b791" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">首先我们需要创建一个<code class="fe lv lw lx ly b">AppCoordinator</code>，它将负责为<code class="fe lv lw lx ly b">UIWindow</code>设置<code class="fe lv lw lx ly b">rootViewController</code>。下面是实现这一点的代码:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nk nl l"/></div></figure><p id="5864" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">以下是我们在这里取得的成果:</p><ol class=""><li id="0ec4" class="lz ma it lb b lc ld lf lg li mb lm mc lq md lu nm mf mg mh bi translated">在应用程序的<code class="fe lv lw lx ly b">UIWindow</code>上添加一个<code class="fe lv lw lx ly b">unowned</code>依赖项。</li><li id="aca9" class="lz ma it lb b lc mi lf mj li mk lm ml lq mm lu nm mf mg mh bi translated">提供一个初始化器。</li><li id="59e4" class="lz ma it lb b lc mi lf mj li mk lm ml lq mm lu nm mf mg mh bi translated">通过创建一个<code class="fe lv lw lx ly b">UINavigationController</code>并将其设置为窗口的<code class="fe lv lw lx ly b">rootViewController</code>来实现<code class="fe lv lw lx ly b">start()</code>方法。然后，坐标到我们接下来要实现的<code class="fe lv lw lx ly b">WelcomeCoordinator</code>。</li></ol><p id="2463" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在，让我们使用<code class="fe lv lw lx ly b">SceneDelegate</code>中的<code class="fe lv lw lx ly b">AppCoordinator</code>来启动我们的应用程序流程，如下所示:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nk nl l"/></div></figure><ol class=""><li id="052e" class="lz ma it lb b lc ld lf lg li mb lm mc lq md lu nm mf mg mh bi translated">我们在<code class="fe lv lw lx ly b">SceneDelegate</code>中添加了对<code class="fe lv lw lx ly b">AppCoordinator</code>的强烈依赖。</li><li id="70cc" class="lz ma it lb b lc mi lf mj li mk lm ml lq mm lu nm mf mg mh bi translated">在<code class="fe lv lw lx ly b">scene(_scene:willConnectTo:...)</code>方法中，用<code class="fe lv lw lx ly b">UIWindow</code>初始化<code class="fe lv lw lx ly b">AppCoordinator</code>。最后，开始协调员的工作。</li></ol><p id="b58b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在设置已经完成，让我们继续欢迎页面。我们有一个简单的<code class="fe lv lw lx ly b">WelcomeViewController</code>，它在屏幕中央显示一个按钮。代码如下:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nk nl l"/></div></figure><ol class=""><li id="87c4" class="lz ma it lb b lc ld lf lg li mb lm mc lq md lu nm mf mg mh bi translated">我们添加了对尚未实现的<code class="fe lv lw lx ly b">WelcomeCoordinator</code>的依赖。</li><li id="778a" class="lz ma it lb b lc mi lf mj li mk lm ml lq mm lu nm mf mg mh bi translated">在<code class="fe lv lw lx ly b">viewDidLoad()</code>中，我们启动了绑定和UI设置方法。</li><li id="5476" class="lz ma it lb b lc mi lf mj li mk lm ml lq mm lu nm mf mg mh bi translated">在<code class="fe lv lw lx ly b">bindButtonToCoordinator()</code>方法中，我们为按钮点击创建一个发布者，在每个发布者上我们触发协调者的<code class="fe lv lw lx ly b">navigateToMain()</code>方法。</li><li id="29b0" class="lz ma it lb b lc mi lf mj li mk lm ml lq mm lu nm mf mg mh bi translated">我们以标准的方式创建和布局一个<code class="fe lv lw lx ly b">UIButton</code>。</li></ol><p id="2d3c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在让我们实施<code class="fe lv lw lx ly b">WelcomeCoordinator</code>:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nk nl l"/></div></figure><ol class=""><li id="f415" class="lz ma it lb b lc ld lf lg li mb lm mc lq md lu nm mf mg mh bi translated">我们在<code class="fe lv lw lx ly b">UINavigationController</code>上创建了一个<code class="fe lv lw lx ly b">unowned</code>依赖。</li><li id="7305" class="lz ma it lb b lc mi lf mj li mk lm ml lq mm lu nm mf mg mh bi translated">在<code class="fe lv lw lx ly b">start()</code>方法中，我们创建了<code class="fe lv lw lx ly b">WelcomeViewController</code>并将其推送到之前创建的<code class="fe lv lw lx ly b">navigationController</code>的堆栈中。因为我们不传递数据，所以我们返回一个<code class="fe lv lw lx ly b">Empty</code> publisher。</li><li id="8fee" class="lz ma it lb b lc mi lf mj li mk lm ml lq mm lu nm mf mg mh bi translated"><code class="fe lv lw lx ly b">navigateToMain()</code>方法由<code class="fe lv lw lx ly b">WelcomeViewController</code>用来启动主流程。在这里，我们创建一个<code class="fe lv lw lx ly b">MainCoordinator</code>并对其进行协调。我们现在将实现<code class="fe lv lw lx ly b">MainCoordinator</code>。</li></ol><p id="09ba" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">欢迎页面完成后，让我们用选项卡栏实现主流程。首先，让我们创建一个名为<code class="fe lv lw lx ly b">MainTabBarController</code>的<code class="fe lv lw lx ly b">UITabBarController</code>子类:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nk nl l"/></div></figure><p id="bc54" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">因为它还没有任何逻辑，所以它唯一的责任就是让<code class="fe lv lw lx ly b">MainCoordinator</code>继续运行。你在上面看到的<code class="fe lv lw lx ly b">AppTabBarController</code>继承只是一个简单的类，它提供了选项卡栏控制器的基本外观。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nk nl l"/></div></figure><p id="9f90" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">接下来，让我们创建实际的<code class="fe lv lw lx ly b">MainCoordinator</code>:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nk nl l"/></div></figure><ol class=""><li id="6c7b" class="lz ma it lb b lc ld lf lg li mb lm mc lq md lu nm mf mg mh bi translated">像以前一样，我们创建一个属性<code class="fe lv lw lx ly b">navigationController</code>。</li><li id="87be" class="lz ma it lb b lc mi lf mj li mk lm ml lq mm lu nm mf mg mh bi translated">在<code class="fe lv lw lx ly b">start()</code>方法中，我们创建两个<code class="fe lv lw lx ly b">UINavigationController</code>并赋予它们一个<code class="fe lv lw lx ly b">UITabBarItem</code>。</li><li id="9d49" class="lz ma it lb b lc mi lf mj li mk lm ml lq mm lu nm mf mg mh bi translated">接下来，我们初始化<code class="fe lv lw lx ly b">MainTabBarController</code>并设置它的<code class="fe lv lw lx ly b">modalPresentationStyle</code>和<code class="fe lv lw lx ly b">viewControllers</code>属性。</li><li id="a20f" class="lz ma it lb b lc mi lf mj li mk lm ml lq mm lu nm mf mg mh bi translated">我们将初始化的<code class="fe lv lw lx ly b">MainTabBarController</code>呈现在<code class="fe lv lw lx ly b">navigationController</code>上。因此，在用户点击欢迎屏幕内的按钮后，会出现<code class="fe lv lw lx ly b">MainTabBarController</code>。</li><li id="37bd" class="lz ma it lb b lc mi lf mj li mk lm ml lq mm lu nm mf mg mh bi translated">初始化两个协调器<code class="fe lv lw lx ly b">FirstCoordinator</code>和<code class="fe lv lw lx ly b">SecondCoordinator</code>。</li><li id="ce60" class="lz ma it lb b lc mi lf mj li mk lm ml lq mm lu nm mf mg mh bi translated">与每个协调者协调，因为他们都代表标签栏控制器的屏幕。</li><li id="6ba2" class="lz ma it lb b lc mi lf mj li mk lm ml lq mm lu nm mf mg mh bi translated">最后，返回一个<code class="fe lv lw lx ly b">Empty</code>发布者，因为我们还没有传递数据。</li></ol><p id="eef0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这是上述步骤的结果:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nn"><img src="../Images/e942c5a1a9acb5eec39b4b6baf22a5cf.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*u10F_kbJHh6HZWmoL91ufw.png"/></div></div></figure><p id="00dd" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">既然显示了主流程，让我们来处理数据传递逻辑。为此，我们有了<code class="fe lv lw lx ly b">FirstCoordinator</code>和<code class="fe lv lw lx ly b">ItemsCoordinator</code>。我们的目标是当用户点击“选择项目”按钮时呈现一个项目列表。一旦物品被选中，<code class="fe lv lw lx ly b">ItemsViewController</code>将解散，物品将被<code class="fe lv lw lx ly b">FirstViewController</code>接收。</p><p id="8d4c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在我们创建<code class="fe lv lw lx ly b">ItemsCoordinator</code>之前，让我们看看<code class="fe lv lw lx ly b">FirstCoordinator</code>是如何实现的:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nk nl l"/></div></figure><ol class=""><li id="b8e0" class="lz ma it lb b lc ld lf lg li mb lm mc lq md lu nm mf mg mh bi translated">就像以前一样，我们依靠<code class="fe lv lw lx ly b">UINavigationController</code>。</li><li id="0179" class="lz ma it lb b lc mi lf mj li mk lm ml lq mm lu nm mf mg mh bi translated"><code class="fe lv lw lx ly b">start()</code>方法负责在屏幕上显示<code class="fe lv lw lx ly b">FirstViewController</code>。由于我们没有将数据从<code class="fe lv lw lx ly b">FirstViewController</code>传递到任何其他地方，这又导致了<code class="fe lv lw lx ly b">Empty</code> publisher。</li><li id="38a9" class="lz ma it lb b lc mi lf mj li mk lm ml lq mm lu nm mf mg mh bi translated"><code class="fe lv lw lx ly b">presentItems()</code>负责导航至项目屏幕。正如我们所见，该方法返回一个包含一个<code class="fe lv lw lx ly b">ItemsCoordinationResult</code>的<code class="fe lv lw lx ly b">Publisher</code>。简而言之，这意味着当我们在项目屏幕上选择一个项目时，<code class="fe lv lw lx ly b">FirstCoordinator</code>将通过这个发布者获得一个值。一旦收到该值，Items屏幕将被关闭。</li></ol><p id="1019" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在<code class="fe lv lw lx ly b">FirstViewController</code>中，我们在点击一个按钮后触发这个方法。然后，我们观察并处理Items屏幕关闭后的结果:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nk nl l"/></div></figure><p id="37a7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">为了看看这个<code class="fe lv lw lx ly b">ItemsCoordinationResult</code>是什么样子，我们继续看<code class="fe lv lw lx ly b">ItemsCoordinator</code>的实现:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nk nl l"/></div></figure><ol class=""><li id="8c6e" class="lz ma it lb b lc ld lf lg li mb lm mc lq md lu nm mf mg mh bi translated"><code class="fe lv lw lx ly b">ItemsCoordinationResult</code>是一个包含<code class="fe lv lw lx ly b">item(String)</code>事例的枚举。简而言之，这个枚举表示项目屏幕的可能输出。如果除了条目选择之外还有更多选项，我们要做的就是在枚举中添加另一个case。</li><li id="7475" class="lz ma it lb b lc mi lf mj li mk lm ml lq mm lu nm mf mg mh bi translated">现在，因为我们确实在传递数据，所以我们指定<code class="fe lv lw lx ly b">ItemsCoordinationResult</code>作为协调器的数据类型。</li><li id="5a0a" class="lz ma it lb b lc mi lf mj li mk lm ml lq mm lu nm mf mg mh bi translated">我们像以前一样依靠<code class="fe lv lw lx ly b">UINavigationController</code>。此外，我们还提供了一个<code class="fe lv lw lx ly b">PassthroughSubject</code>和<code class="fe lv lw lx ly b">view</code>控制器，一旦选择了一个项目，控制器就会启动。</li><li id="a646" class="lz ma it lb b lc mi lf mj li mk lm ml lq mm lu nm mf mg mh bi translated">在<code class="fe lv lw lx ly b">start()</code>方法中，我们显示了ItemsViewController。我们还返回先前创建的<code class="fe lv lw lx ly b">PassthroughSubject</code>，因为这是向呈现协调器发送事件流的方式。</li></ol><p id="d5aa" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这就是整个示例应用程序的工作方式(为简单起见，所选项目将打印在控制台中):</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi no"><img src="../Images/082274daf2c037da3ce732c708162e60.png" data-original-src="https://miro.medium.com/v2/resize:fit:1080/1*h6P0jywhM8Lddol6ucbSUg.gif"/></div></figure><h1 id="59b5" class="mn mo it bd mp mq mr ms mt mu mv mw mx jz my ka mz kc na kd nb kf nc kg nd ne bi translated">资源</h1><p id="d1cb" class="pw-post-body-paragraph kz la it lb b lc nf ju le lf ng jx lh li nh lk ll lm ni lo lp lq nj ls lt lu im bi translated">可以在<a class="ae ky" href="https://github.com/zafarivaev/ReactiveCoordinator-Combine" rel="noopener ugc nofollow" target="_blank"> GitHub </a>上访问现成的Swift包。</p><h1 id="7958" class="mn mo it bd mp mq mr ms mt mu mv mw mx jz my ka mz kc na kd nb kf nc kg nd ne bi translated">包扎</h1><p id="94b8" class="pw-post-body-paragraph kz la it lb b lc nf ju le lf ng jx lh li nh lk ll lm ni lo lp lq nj ls lt lu im bi translated">我们已经看到了<code class="fe lv lw lx ly b">Coordinator</code>设计模式如何使应用程序内部的导航更加结构化。如果您想了解更多关于该模式的标准实现，我建议您看看这篇文章:</p><div class="np nq gp gr nr ns"><a rel="noopener  ugc nofollow" target="_blank" href="/leverage-the-coordinator-design-pattern-in-swift-5-cd5bb9e78e12"><div class="nt ab fo"><div class="nu ab nv cl cj nw"><h2 class="bd iu gy z fp nx fr fs ny fu fw is bi translated">利用Swift 5中的协调器设计模式</h2><div class="nz l"><h3 class="bd b gy z fp nx fr fs ny fu fw dk translated">隔离您的视图控制器，使它们更易于测试和重用</h3></div><div class="oa l"><p class="bd b dl z fp nx fr fs ny fu fw dk translated">better编程. pub</p></div></div><div class="ob l"><div class="oc l od oe of ob og ks ns"/></div></div></a></div><p id="bbef" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">感谢阅读！</p></div></div>    
</body>
</html>