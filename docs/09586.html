<html>
<head>
<title>How to Deliver a Personalised User Experience In Your Android Apps</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何在您的Android应用中提供个性化的用户体验</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/deliver-a-personalised-user-experience-in-your-android-apps-2960d6a8d7c4?source=collection_archive---------15-----------------------#2021-09-13">https://betterprogramming.pub/deliver-a-personalised-user-experience-in-your-android-apps-2960d6a8d7c4?source=collection_archive---------15-----------------------#2021-09-13</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="5088" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">了解如何在您的Android代码库中使用WebEngage</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/ea3e44a0e7f17e3b08d7b05de05bdeb4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*Kk9QDrEPUF_R5O1Q"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">斯蒂芬·菲利普斯-Hostreviews.co.uk在<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</p></figure><p id="1f28" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">WebEngage是指用户通过移动推送、应用内消息、短信、网络叠加、网络推送、电子邮件、WhatsApp和脸书等渠道参与相关对话。</p><p id="a478" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们将探索Android应用中WebEngage功能的一部分。我们将从集成开始，然后转到分析部分，可以记录事件和属性来跟踪用户行为，最后以WebEngage的通知设置结束。</p><p id="23b5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">另一方面，WebEngage在控制台中提供了方便易用的营销策略。这有助于公司营销团队在几分钟内创建直观的露营。WebEngage可以在几乎所有平台上使用，如Android、Web、IOS等。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="3e74" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">综合</h1><p id="bf10" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">WebEngage通过托管在<code class="fe mz na nb nc b">jcenter</code> Maven仓库上的<code class="fe mz na nb nc b">WebEngage</code> android SDK提供了在Android项目中的快速集成。我们只需要在应用级<code class="fe mz na nb nc b">build.gradle</code>文件的依赖标签下添加以下几行:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nd ne l"/></div></figure></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="eb52" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">初始化</h1><p id="eebf" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">下一步是启动或初始化<code class="fe mz na nb nc b">WebEngage</code>库，就像在android开发中使用Firebase一样。这里我们需要从WebEngage控制台获得的WebEngage许可证代码，通常以(<code class="fe mz na nb nc b">~</code>)开头。</p><p id="8259" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">为了避免多个inits并保持全局实现，我们在应用程序类的<code class="fe mz na nb nc b">onCreate</code>函数中这样做。看一看:</p><pre class="kj kk kl km gt nf nc ng nh aw ni bi"><span id="1aa2" class="nj md it nc b gy nk nl l nm nn">class SampleApplication : Application{</span><span id="a2ff" class="nj md it nc b gy no nl l nm nn">    override fun onCreate() {<br/>        super.onCreate()</span><span id="f0d9" class="nj md it nc b gy no nl l nm nn">        val webEngageConfig = WebEngageConfig.Builder()<br/>            .setWebEngageKey(WEBENGAGE_LICENSE_CODE)<br/>            .setDebugMode(true) <br/>            .build()<br/>        registerActivityLifecycleCallbacks(<br/>            WebEngageActivityLifeCycleCallbacks(<br/>                this,<br/>                webEngageConfig<br/>            )<br/>        )</span><span id="fead" class="nj md it nc b gy no nl l nm nn">    }</span><span id="8f8c" class="nj md it nc b gy no nl l nm nn">}</span></pre><p id="ae0d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><em class="np">注意:确保用WebEngage控制台中的实际许可证代码替换</em> <code class="fe mz na nb nc b"><em class="np">WEBENGAGE_LICENSE_CODE</em></code> <em class="np">。</em></p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="6c92" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">分析学</h1><p id="2c08" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">我们通常在android应用程序中使用Firebase进行分析，当我在寻找替代品时，<code class="fe mz na nb nc b">WebEngage</code>似乎是完美的替代品，如果不是比Firebase更强大的工具的话。记录事件和跟踪属性就像使用Firebase库一样简单。</p><h2 id="eb4a" class="nj md it bd me nq nr dn mi ns nt dp mm li nu nv mo lm nw nx mq lq ny nz ms oa bi translated">用户识别</h2><p id="4c80" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">让我们从识别<code class="fe mz na nb nc b">WebEngage</code>中的用户开始。我们可以获得如下所示的WebEngage:</p><pre class="kj kk kl km gt nf nc ng nh aw ni bi"><span id="7a2e" class="nj md it nc b gy nk nl l nm nn">val weUser: User = WebEngage.get().user()</span></pre><p id="fed1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">一旦用户成功完成登录或注册，您可以通过分配一个唯一的用户id在<code class="fe mz na nb nc b">WebEnagage</code>中识别它。我更喜欢使用存储在公司服务器中的相同用户id。看一看:</p><pre class="kj kk kl km gt nf nc ng nh aw ni bi"><span id="7f04" class="nj md it nc b gy nk nl l nm nn">weUser.login("9SBOkLVMWvPX")</span></pre><p id="d64b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">一旦注册了Webengage用户，我们就可以在控制台中跟踪他的一系列详细信息。看一看:</p><pre class="kj kk kl km gt nf nc ng nh aw ni bi"><span id="d68c" class="nj md it nc b gy nk nl l nm nn">weUser.setFirstName("John")<br/>weUser.setEmail("john@doe.com")<br/>weUser.setBirthDate("1998-02-23") <em class="np"><br/></em>weUser.setPhoneNumber("+123456789")<br/>weUser.setGender(Gender.FEMALE)</span></pre><p id="56e6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果您的应用程序具有用户注销功能，请确保在成功注销时调用WebEngage用户上的注销。看一看:</p><pre class="kj kk kl km gt nf nc ng nh aw ni bi"><span id="7243" class="nj md it nc b gy nk nl l nm nn">weUser.logout()</span></pre><h2 id="c4af" class="nj md it bd me nq nr dn mi ns nt dp mm li nu nv mo lm nw nx mq lq ny nz ms oa bi translated">分析学</h2><p id="eb19" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">为了跟踪事件，<code class="fe mz na nb nc b">WebEngage</code>提供了一个分析类。首先，我们需要获得WebEngage分析类实例，如下所示:</p><pre class="kj kk kl km gt nf nc ng nh aw ni bi"><span id="1411" class="nj md it nc b gy nk nl l nm nn">val weAnalytics: Analytics = WebEngage.get().analytics()</span></pre><p id="4eb5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在我们需要在分析实例上使用<code class="fe mz na nb nc b">track</code>函数来跟踪任何事件。看一看:</p><pre class="kj kk kl km gt nf nc ng nh aw ni bi"><span id="3d12" class="nj md it nc b gy nk nl l nm nn">weAnalytics.track("Event name goes here")</span></pre><p id="1485" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们还可以添加一系列属性，您可以通过事件跟踪这些属性，如下所示:</p><pre class="kj kk kl km gt nf nc ng nh aw ni bi"><span id="9618" class="nj md it nc b gy nk nl l nm nn">val orderDetails :  HashMap&lt;String, Any&gt; = HashMap()<br/>orderDetails.put("Amount" , 1000)<br/>orderDetails.put("id" , orderId)<br/>weAnalytics.track("Order Placed", orderDetails);</span></pre></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="f0e7" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">WebEngage通知</h1><p id="6431" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">WebEngage通知只不过是Firebase通知。首先，我们需要集成Firebase消息库，然后在<code class="fe mz na nb nc b">WebEnagage</code>中注册Firebase令牌。然后我们需要在WebEngage控制台中添加Firebase服务器密钥。就这些，现在你可以通过WebEngage发送通知了。</p><h2 id="b81d" class="nj md it bd me nq nr dn mi ns nt dp mm li nu nv mo lm nw nx mq lq ny nz ms oa bi translated">Firebase令牌注册</h2><p id="04a0" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">通过在应用程序级Gradle文件下添加以下行，开始在应用程序中添加Firebase消息库。</p><pre class="kj kk kl km gt nf nc ng nh aw ni bi"><span id="a031" class="nj md it nc b gy nk nl l nm nn">implementation 'com.google.firebase:firebase-messaging:22.0.0'</span></pre><p id="1227" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">然后我们可以通过应用程序类的<code class="fe mz na nb nc b">onCreate</code>函数中的<code class="fe mz na nb nc b">setRegistrationID</code>函数在WebEngage中注册Firebase令牌。看一看:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nd ne l"/></div></figure><p id="d6b1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们都知道Firebase令牌会不时更新，所以最好将更新的令牌注册到来自<code class="fe mz na nb nc b">FirebaseMessagingService</code>类的<code class="fe mz na nb nc b">onNewToken</code>函数内部的WebEngage:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nd ne l"/></div></figure><p id="2502" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">不要忘记在清单文件中注册服务:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nd ne l"/></div></figure><p id="c84d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在<code class="fe mz na nb nc b">onMessageReceived</code>函数中，我们需要识别通知源，如果它来自WebEngage，那么我们需要处理WebEngage的通知有效负载，如下所示:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nd ne l"/></div></figure><p id="e583" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们可以通过<code class="fe mz na nb nc b">WebEngageConfig</code>定制小图标和大图标以及通知的强调色:</p><pre class="kj kk kl km gt nf nc ng nh aw ni bi"><span id="b78b" class="nj md it nc b gy nk nl l nm nn">WebEngageConfig webEngageConfig = new WebEngageConfig.Builder()     .setPushSmallIcon(R.drawable.YOUR_SMALL_ICON)     .setPushLargeIcon(R.drawable.YOUR_LARGE_ICON)     .setPushAccentColor(Color.parseColor("#ff0000"))     <br/>.build();</span></pre></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><p id="19fc" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">目前就这些。希望你学到了有用的东西。感谢阅读！</p></div></div>    
</body>
</html>