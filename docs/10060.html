<html>
<head>
<title>Dependencies Injection in a Modularized SwiftUI App With MVVM</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">MVVM在模块化SwiftUI应用中的依赖注入</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/dependencies-injection-in-a-modularized-swiftui-app-with-mvvm-e72ae6d898ef?source=collection_archive---------1-----------------------#2021-11-22">https://betterprogramming.pub/dependencies-injection-in-a-modularized-swiftui-app-with-mvvm-e72ae6d898ef?source=collection_archive---------1-----------------------#2021-11-22</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="0c2c" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">如何在干净的MVVM架构中注入依赖关系和传递数据</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/84c820979784637cc8e29b22735e4c33.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*rCJBaAbeNasKg89s"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated"><a class="ae ky" href="https://unsplash.com/@z734923105?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Jerry Zhang </a>在<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的照片</p></figure><p id="bbbb" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">写完<a class="ae ky" rel="noopener ugc nofollow" target="_blank" href="/composing-swiftui-navigation-3d67198b6acb">作曲SwiftUI导航</a>的文章后，有人用非常亲切的话语和几个问题联系我。困扰他们的主要问题是如何将数据和依赖关系从一个模块传递到另一个模块。</p><p id="de5d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">有两个棘手的问题让这变得更加困难:</p><ol class=""><li id="8cee" class="lv lw it lb b lc ld lf lg li lx lm ly lq lz lu ma mb mc md bi translated">我们希望保持所有模块的模块化。传递数据和依赖关系可能会将一个模块与另一个模块耦合起来。</li><li id="490b" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated">导航可以很深。我们可能不得不将依赖关系从主视图传递到一个非常嵌套的视图。这可能导致嵌套闭包和难以阅读的代码。</li></ol><p id="76af" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">今天，我想探讨我们如何在一个高度模块化的应用程序中设计依赖注入，保持它的简单和可读性。</p><h1 id="736b" class="mj mk it bd ml mm mn mo mp mq mr ms mt jz mu ka mv kc mw kd mx kf my kg mz na bi translated">该应用程序</h1><p id="0848" class="pw-post-body-paragraph kz la it lb b lc nb ju le lf nc jx lh li nd lk ll lm ne lo lp lq nf ls lt lu im bi translated">我们今天使用的应用程序是一个简单的<a class="ae ky" href="https://pokemon.fandom.com/wiki/Pok%C3%A9dex" rel="noopener ugc nofollow" target="_blank"> Pokedex </a>应用程序:</p><ol class=""><li id="04bc" class="lv lw it lb b lc ld lf lg li lx lm ly lq lz lu ma mb mc md bi translated">第一个屏幕包含各种口袋妖怪游戏的Pokedex列表。</li><li id="824b" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated">第二个屏幕显示该游戏的口袋妖怪列表。</li><li id="3456" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated">第三个屏幕呈现特定口袋妖怪的细节。</li></ol><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi ng"><img src="../Images/906b5b7966b09d9b3384297de787b86d.png" data-original-src="https://miro.medium.com/v2/resize:fit:592/1*lfuSuKfrzzyfRhZZLW7_-A.gif"/></div></figure><p id="87f3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">多亏了Pokemon PokeAPI，pokemon的数据和API可以公开获得。</p><p id="1ed3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">所有屏幕必须隔离在各自的模块中，它们将在<code class="fe nh ni nj nk b">CompositionRoot</code>中组合。</p><h1 id="c584" class="mj mk it bd ml mm mn mo mp mq mr ms mt jz mu ka mv kc mw kd mx kf my kg mz na bi translated">构建模块</h1><p id="0caf" class="pw-post-body-paragraph kz la it lb b lc nb ju le lf nc jx lh li nd lk ll lm ne lo lp lq nf ls lt lu im bi translated">我们将在一个Swift包中编写我们所有的代码:我们称之为<code class="fe nh ni nj nk b">PokedexKit</code>。它被组织成不同的<code class="fe nh ni nj nk b">Targets</code>:每一个都代表一个独立的模块，有自己的公共接口。</p><p id="8bf0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这些<code class="fe nh ni nj nk b">Target</code>是:</p><ul class=""><li id="fb3b" class="lv lw it lb b lc ld lf lg li lx lm ly lq lz lu nl mb mc md bi translated"><code class="fe nh ni nj nk b">CompositionRoot</code>:唯一依赖于所有其他模块的模块，因为它是将它们结合在一起的粘合剂。</li><li id="fd57" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu nl mb mc md bi translated"><code class="fe nh ni nj nk b">PokedexPkg</code>:实现第一屏。我们需要添加<code class="fe nh ni nj nk b">Pkg</code>后缀，以避免与应用程序名称冲突。</li><li id="448a" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu nl mb mc md bi translated">实现了口袋妖怪的列表。</li><li id="d99a" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu nl mb mc md bi translated"><code class="fe nh ni nj nk b">PokemonDetails</code>:实现细节画面。</li></ul><p id="0a30" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这个包的<code class="fe nh ni nj nk b">Package.swift</code>文件如下所示。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nm nn l"/></div></figure><p id="9cf5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在文件的第一部分，我们定义了一些常量和<code class="fe nh ni nj nk b">enum</code>以使包描述不容易出错并且更具可重用性。我们可以定义一个<code class="fe nh ni nj nk b">allButRoot</code>属性来获取所有可用目标的列表，不包括<code class="fe nh ni nj nk b">CompositionRoot</code>。该属性用于创建<code class="fe nh ni nj nk b">Root</code>模块的依赖关系，该模块需要知道应用程序的所有其他模块。</p><p id="c3cf" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">swift包强调了我们想要实施的需求:所有不是<code class="fe nh ni nj nk b">CompositionRoot</code>的<code class="fe nh ni nj nk b">.target</code>的<code class="fe nh ni nj nk b">dependencies</code>数组都是空的。这意味着他们是独立的，他们不依赖于其他任何东西。</p><h2 id="a052" class="no mk it bd ml np nq dn mp nr ns dp mt li nt nu mv lm nv nw mx lq nx ny mz nz bi translated">PokedexPkg</h2><p id="9f74" class="pw-post-body-paragraph kz la it lb b lc nb ju le lf nc jx lh li nd lk ll lm ne lo lp lq nf ls lt lu im bi translated">对于第一个模块，我们将逐步实现所有部分并定义所有接口。其他屏幕与此非常相似:我们将加快它们的速度，只突出不同之处。</p><h2 id="90d5" class="no mk it bd ml np nq dn mp nr ns dp mt li nt nu mv lm nv nw mx lq nx ny mz nz bi translated"><strong class="ak">创建脚手架</strong></h2><p id="c61a" class="pw-post-body-paragraph kz la it lb b lc nb ju le lf nc jx lh li nd lk ll lm ne lo lp lq nf ls lt lu im bi translated">让我们从创建SwiftUI视图的支架开始，遵循MVVM模式。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nm nn l"/></div></figure><p id="1c72" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们有默认的SwiftUI视图，它拥有一个作为<code class="fe nh ni nj nk b">ViewModel</code>的<code class="fe nh ni nj nk b">@StateObject</code>。为了避免污染模块名称空间，在SwiftUI视图的扩展中定义了<code class="fe nh ni nj nk b">ViewModel</code>。</p><h2 id="4169" class="no mk it bd ml np nq dn mp nr ns dp mt li nt nu mv lm nv nw mx lq nx ny mz nz bi translated"><strong class="ak">创建数据模型</strong></h2><p id="d09c" class="pw-post-body-paragraph kz la it lb b lc nb ju le lf nc jx lh li nd lk ll lm ne lo lp lq nf ls lt lu im bi translated">我们要展示的数据是Pokedex名称和其中包含的口袋妖怪数量。让我们从定义数据结构开始:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nm nn l"/></div></figure><p id="f964" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">模型是<code class="fe nh ni nj nk b">Identifiable</code>，因为我们将在<code class="fe nh ni nj nk b">List</code>中渲染它。<code class="fe nh ni nj nk b">id</code>是一个简单的<code class="fe nh ni nj nk b">Int</code>，因为PokeAPI使用整数来标识Pokedexes。</p><h2 id="71dd" class="no mk it bd ml np nq dn mp nr ns dp mt li nt nu mv lm nv nw mx lq nx ny mz nz bi translated"><strong class="ak">添加PokedexService </strong></h2><p id="f0fb" class="pw-post-body-paragraph kz la it lb b lc nb ju le lf nc jx lh li nd lk ll lm ne lo lp lq nf ls lt lu im bi translated">然后，我们需要一种方法来检索Pokedexes列表。这个模块的职责是只呈现Pokedex数据:我们不关心检索是如何实现的。因此，我们只需要为服务指定我们想要的接口。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nm nn l"/></div></figure><p id="5e7b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">对于第一个模块，我们决定使用标准回调模型。但是，没有必要强制使用单一的方法来检索某些数据。为了加强这种模块独立性的思想，我们可以对三个不同模块中的服务使用三种不同的方法。</p><p id="8687" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在，我们可以将服务注入到<code class="fe nh ni nj nk b">ViewModel</code>中。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nm nn l"/></div></figure><p id="52aa" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe nh ni nj nk b">ViewModel</code>的<code class="fe nh ni nj nk b">init</code>请求一个符合<code class="fe nh ni nj nk b">PokedexService</code>协议的组件，利用<a class="ae ky" href="https://freecontent.manning.com/understanding-constructor-injection/" rel="noopener ugc nofollow" target="_blank">构造器注入</a>技术。我们将<code class="fe nh ni nj nk b">pokedexes</code>数组声明为一个<code class="fe nh ni nj nk b">@Published</code>变量，这样SwiftUI就可以对它做出反应。<code class="fe nh ni nj nk b">ViewModel</code>的最后一部分是使用服务的<code class="fe nh ni nj nk b">loadPokedex</code>方法。当服务完成检索时，我们更新<code class="fe nh ni nj nk b">pokedexes</code>属性。</p><p id="4db8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">之前的更改更新了<code class="fe nh ni nj nk b">ViewModel.init</code>方法。SwiftUI <code class="fe nh ni nj nk b">View </code>需要使用那个<code class="fe nh ni nj nk b">init</code>创建<code class="fe nh ni nj nk b">ViewModel</code>，所以模块停止构建。为了让它重新构建，我们还需要更新它:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nm nn l"/></div></figure><p id="60a9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">MVVM模式的<code class="fe nh ni nj nk b">public</code> init可能看起来太复杂了，但是我们必须这样写的原因是因为<code class="fe nh ni nj nk b">@StateObject</code>属性包装器。我们不能将<code class="fe nh ni nj nk b">ViewModel</code>的实例直接分配给<code class="fe nh ni nj nk b">viewModel</code>属性，因为属性包装器使该属性成为get-only属性。为了解决这个问题，我们可以使用<code class="fe nh ni nj nk b">_viewModel</code>:这个属性由编译器合成，让我们设置实际的属性包装器类型，将初始包装值注入其中。</p><h2 id="d05c" class="no mk it bd ml np nq dn mp nr ns dp mt li nt nu mv lm nv nw mx lq nx ny mz nz bi translated"><strong class="ak">添加导航提供商</strong></h2><p id="fa59" class="pw-post-body-paragraph kz la it lb b lc nb ju le lf nc jx lh li nd lk ll lm ne lo lp lq nf ls lt lu im bi translated">最后，当用户点击Pokedex时，我们希望导航到口袋妖怪列表。为了实现这一点，我们利用了<a class="ae ky" rel="noopener ugc nofollow" target="_blank" href="/composing-swiftui-navigation-3d67198b6acb">撰写SwiftUI导航</a>文章中描述的原则。</p><p id="71e5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">首先，我们定义一个接受一些参数并返回SwiftUI <code class="fe nh ni nj nk b">View</code>的闭包。多亏了泛型，我们不在乎实际返回的是哪个视图。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nm nn l"/></div></figure><p id="e0e9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">闭包将Pokedex标识符及其名称作为参数传递给<code class="fe nh ni nj nk b">Details</code>视图。<code class="fe nh ni nj nk b">typealias</code>关键字支持通用语法:<code class="fe nh ni nj nk b">Details</code>类型的唯一要求是符合<code class="fe nh ni nj nk b">View</code>协议。</p><p id="0b89" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在，我们可以用这个新的提供者更新<code class="fe nh ni nj nk b">ViewModel</code>:它在<code class="fe nh ni nj nk b">DetailsView</code>中变成通用的，并在<code class="fe nh ni nj nk b">init</code>中接受提供者。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nm nn l"/></div></figure><p id="c23e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe nh ni nj nk b">ViewModel</code>初始化又改变了，所以我们也必须更新<code class="fe nh ni nj nk b">PokedexList</code>初始化。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nm nn l"/></div></figure><p id="1439" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们还需要将<code class="fe nh ni nj nk b">PokedexList</code>更新为泛型，以适应新的泛型类型。</p><h2 id="b3d7" class="no mk it bd ml np nq dn mp nr ns dp mt li nt nu mv lm nv nw mx lq nx ny mz nz bi translated"><strong class="ak">实现视图体</strong></h2><p id="efd3" class="pw-post-body-paragraph kz la it lb b lc nb ju le lf nc jx lh li nd lk ll lm ne lo lp lq nf ls lt lu im bi translated">为了完成这个模块，我们需要实现<code class="fe nh ni nj nk b">body</code>属性。这是标准的SwiftUI代码，看起来像这样:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nm nn l"/></div></figure><p id="3693" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们探索一下视图是如何使用<code class="fe nh ni nj nk b">ViewModel</code>的。在<code class="fe nh ni nj nk b">destination</code>闭包中，我们使用<code class="fe nh ni nj nk b">detailsProvider</code>闭包来检索<code class="fe nh ni nj nk b">Details</code>视图，独立于其实际类型。在<code class="fe nh ni nj nk b">onAppear</code>视图修改器中，我们要求<code class="fe nh ni nj nk b">viewModel</code>加载Pokedex数据。</p><p id="b11d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这就完成了Pokedex模块。所有的特性都实现了，尽管视图不知道逻辑将如何实际实现。</p><h2 id="543f" class="no mk it bd ml np nq dn mp nr ns dp mt li nt nu mv lm nv nw mx lq nx ny mz nz bi translated">口袋妖怪列表</h2><p id="953d" class="pw-post-body-paragraph kz la it lb b lc nb ju le lf nc jx lh li nd lk ll lm ne lo lp lq nf ls lt lu im bi translated">其他模块与Pokedex非常相似。它们的变化主要是因为:</p><ul class=""><li id="7f46" class="lv lw it lb b lc ld lf lg li lx lm ly lq lz lu nl mb mc md bi translated">数据模型</li><li id="1b51" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu nl mb mc md bi translated">一些实体的名称。</li></ul><p id="27b3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们看一下代码的完整性，但让我们把重点放在差异上。</p><h2 id="0002" class="no mk it bd ml np nq dn mp nr ns dp mt li nt nu mv lm nv nw mx lq nx ny mz nz bi translated"><strong class="ak">数据模型</strong></h2><p id="a394" class="pw-post-body-paragraph kz la it lb b lc nb ju le lf nc jx lh li nd lk ll lm ne lo lp lq nf ls lt lu im bi translated">第一个区别依赖于数据模型。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nm nn l"/></div></figure><p id="1d54" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">一个口袋妖怪是<code class="fe nh ni nj nk b">Identifiable</code>，这样我们就可以渲染成一个<code class="fe nh ni nj nk b">List</code>。<code class="fe nh ni nj nk b">id</code>也是一个<code class="fe nh ni nj nk b">Int</code>。然后，每个口袋妖怪都有一个名字和一个精灵。</p><h2 id="3766" class="no mk it bd ml np nq dn mp nr ns dp mt li nt nu mv lm nv nw mx lq nx ny mz nz bi translated"><strong class="ak">依赖签名</strong></h2><p id="bce7" class="pw-post-body-paragraph kz la it lb b lc nb ju le lf nc jx lh li nd lk ll lm ne lo lp lq nf ls lt lu im bi translated">为了取回口袋妖怪，我们需要一个<code class="fe nh ni nj nk b">PokemonService</code>。该服务需要Pokedex id来只检索属于它的口袋妖怪。另一个依赖项是口袋妖怪细节的提供者。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nm nn l"/></div></figure><p id="8797" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们决定使用<code class="fe nh ni nj nk b">Combine</code>来实现口袋妖怪列表的检索:<code class="fe nh ni nj nk b">PokemonService.getPokemons</code>方法返回一个<code class="fe nh ni nj nk b">[Pokemon]</code>的<code class="fe nh ni nj nk b">AnyPublisher</code>。</p><p id="e266" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe nh ni nj nk b">PokemonList</code>的<code class="fe nh ni nj nk b">ViewModel</code>是这样实现的:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nm nn l"/></div></figure><p id="ccc0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">大部分代码都非常类似于Pokedex' <code class="fe nh ni nj nk b">ViewModel</code>。主要区别在于<code class="fe nh ni nj nk b">loadPokemons</code>的实现。它订阅<code class="fe nh ni nj nk b">service</code>的<code class="fe nh ni nj nk b">publisher</code>来检索所需的数据。因此，<code class="fe nh ni nj nk b">ViewModel</code>需要一个<code class="fe nh ni nj nk b">cancellables</code>属性来存储订阅。</p><h2 id="f338" class="no mk it bd ml np nq dn mp nr ns dp mt li nt nu mv lm nv nw mx lq nx ny mz nz bi translated"><strong class="ak">视图</strong></h2><p id="7dba" class="pw-post-body-paragraph kz la it lb b lc nb ju le lf nc jx lh li nd lk ll lm ne lo lp lq nf ls lt lu im bi translated">最后，视图与Pokedex非常相似。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nm nn l"/></div></figure><p id="4648" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这个<code class="fe nh ni nj nk b">View</code>的<code class="fe nh ni nj nk b">init</code>比上一个略大。它需要接受更多的参数传递给<code class="fe nh ni nj nk b">ViewModel</code>。</p><p id="fb0d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在这个例子中，我们还使用了一个新的SwiftUI视图:<code class="fe nh ni nj nk b">AsyncImage</code>。该组件已随iOS 15发布，它让我们可以从远程<code class="fe nh ni nj nk b">URL</code>自动加载图像。它还让我们定制加载和失败状态。</p><p id="46bd" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">就这样，我们完成了小应用程序的第二个模块。</p><h1 id="0b44" class="mj mk it bd ml mm mn mo mp mq mr ms mt jz mu ka mv kc mw kd mx kf my kg mz na bi translated">口袋妖怪的细节</h1><p id="ebe6" class="pw-post-body-paragraph kz la it lb b lc nb ju le lf nc jx lh li nd lk ll lm ne lo lp lq nf ls lt lu im bi translated">最后一个模块是详细信息屏幕。用户不能从这里导航到任何其他地方，所以这个模块比其他模块稍微简单一些。</p><h2 id="ef37" class="no mk it bd ml np nq dn mp nr ns dp mt li nt nu mv lm nv nw mx lq nx ny mz nz bi translated"><strong class="ak">数据模型</strong></h2><p id="161c" class="pw-post-body-paragraph kz la it lb b lc nb ju le lf nc jx lh li nd lk ll lm ne lo lp lq nf ls lt lu im bi translated">数据模型描述了一个口袋妖怪。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nm nn l"/></div></figure><p id="5606" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">与其他型号不同的是，这款型号不是<code class="fe nh ni nj nk b">Identifiable</code>。我们就不放入<code class="fe nh ni nj nk b">List</code>了。我们仍然在追踪口袋妖怪的<code class="fe nh ni nj nk b">id</code>，它的名字，艺术作品和味道文本。</p><h2 id="85b3" class="no mk it bd ml np nq dn mp nr ns dp mt li nt nu mv lm nv nw mx lq nx ny mz nz bi translated"><strong class="ak">依赖关系</strong></h2><p id="e1e1" class="pw-post-body-paragraph kz la it lb b lc nb ju le lf nc jx lh li nd lk ll lm ne lo lp lq nf ls lt lu im bi translated">唯一的模块依赖是一个检索口袋妖怪细节的服务。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nm nn l"/></div></figure><p id="3aba" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">对于这种依赖性，我们决定使用新的<code class="fe nh ni nj nk b">async-await</code>语法。</p><h2 id="1ad4" class="no mk it bd ml np nq dn mp nr ns dp mt li nt nu mv lm nv nw mx lq nx ny mz nz bi translated"><strong class="ak">ViewModel</strong></h2><p id="db1b" class="pw-post-body-paragraph kz la it lb b lc nb ju le lf nc jx lh li nd lk ll lm ne lo lp lq nf ls lt lu im bi translated"><code class="fe nh ni nj nk b">PokemonDetails</code>的<code class="fe nh ni nj nk b">ViewModel</code>如下:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nm nn l"/></div></figure><p id="8ff5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在第一部分中，我们定义了所有属性和带有参数的<code class="fe nh ni nj nk b">init</code>。这个<code class="fe nh ni nj nk b">ViewModel</code>不是通用的:我们不必导航到任何其他视图。</p><p id="22b8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">使用<code class="fe nh ni nj nk b">async-await</code>实现<code class="fe nh ni nj nk b">loadPokemon</code>方法。该方法将在接受非异步闭包的<code class="fe nh ni nj nk b">onAppear</code>视图修饰符中使用。为了在not <code class="fe nh ni nj nk b">async</code>方法中使用<code class="fe nh ni nj nk b">async</code>函数，我们可以创建一个在后台线程中移动上下文的<code class="fe nh ni nj nk b">Task</code>。该任务调用服务来检索口袋妖怪的详细信息。</p><p id="d359" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">然后它调用一个<code class="fe nh ni nj nk b">setPokemon</code>方法，用<code class="fe nh ni nj nk b">@MainActor</code>注释进行注释。<code class="fe nh ni nj nk b">@MainActor</code>注释确保函数将在主线程中执行。我们需要这样做，因为我们要更新一个触发UI更新的<code class="fe nh ni nj nk b">@Published</code>属性。UI更新必须发生在主线程中。</p><p id="9a21" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu">视图</strong></p><p id="7f63" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">最后，我们可以将<code class="fe nh ni nj nk b">PokemonDetails</code>视图中的<code class="fe nh ni nj nk b">ViewModel</code>连接起来:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nm nn l"/></div></figure><p id="9038" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe nh ni nj nk b">init</code>接收所有的参数来构建<code class="fe nh ni nj nk b">ViewModel</code>。</p><p id="b616" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe nh ni nj nk b">body</code>创建一个带有<code class="fe nh ni nj nk b">AsyncImage</code>和描述的<code class="fe nh ni nj nk b">VStack</code>，而口袋妖怪的名字被用作导航标题。</p><p id="ba26" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在<code class="fe nh ni nj nk b">onAppear</code>视图修改器中，我们检索口袋妖怪细节来更新视图。</p><h1 id="d1f7" class="mj mk it bd ml mm mn mo mp mq mr ms mt jz mu ka mv kc mw kd mx kf my kg mz na bi translated">组合根</h1><p id="0787" class="pw-post-body-paragraph kz la it lb b lc nb ju le lf nc jx lh li nd lk ll lm ne lo lp lq nf ls lt lu im bi translated">我们独立地实现了三个屏幕。现在，我们可以把它们放在一起，形成我们的应用程序。<code class="fe nh ni nj nk b">CompositionRoot</code>是将所有东西粘合在一起的组件，它依赖于所有其他模块。</p><h2 id="a6c0" class="no mk it bd ml np nq dn mp nr ns dp mt li nt nu mv lm nv nw mx lq nx ny mz nz bi translated"><strong class="ak">调整依赖关系</strong></h2><p id="fb3c" class="pw-post-body-paragraph kz la it lb b lc nb ju le lf nc jx lh li nd lk ll lm ne lo lp lq nf ls lt lu im bi translated">在每个模块的<code class="fe nh ni nj nk b"><strong class="lb iu">Dependencies</strong></code>部分，我们定义了服务的接口。在实际的应用程序中，我们会有一个<code class="fe nh ni nj nk b">Networking</code>模块，它实现一个组件来执行一般的网络请求。然后，在<code class="fe nh ni nj nk b">Composition Root</code>中，我们使这个组件适应特定于模块的接口。</p><p id="baa0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在这个例子中，我们将实现一些服务的假版本。这篇文章的重点不是如何创建，而是如何用复杂的依赖关系构建我们的应用程序。</p><p id="fcbf" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">因此，让我们创建三个假服务:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nm nn l"/></div></figure><p id="e46f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe nh ni nj nk b">MockedPokedexService</code>立即调用带有前两个口袋妖怪游戏区域的pokedexes数据的回调。</p><p id="4456" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe nh ni nj nk b">MockedPokemonService</code>返回一个<code class="fe nh ni nj nk b">Just</code>发布者，该发布者在收到订阅时立即完成。它返回pokedex的前三个口袋妖怪:妙蛙种子，妙蛙草和Venusaur。注意<code class="fe nh ni nj nk b">Just</code>发布者有一个<code class="fe nh ni nj nk b">Never</code>的<code class="fe nh ni nj nk b">FailureType</code>:我们需要将其设置为正确的<code class="fe nh ni nj nk b">Error</code>类型，然后才能用<code class="fe nh ni nj nk b">eraseToAnyPublisher()</code>删除其特定类型。</p><p id="8644" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">最后，使用async await的<code class="fe nh ni nj nk b">MockedPokemonDetailsService</code>直接返回妙蛙种子的数据。</p><h2 id="766d" class="no mk it bd ml np nq dn mp nr ns dp mt li nt nu mv lm nv nw mx lq nx ny mz nz bi translated"><strong class="ak">将所有内容组合在一起</strong></h2><p id="c185" class="pw-post-body-paragraph kz la it lb b lc nb ju le lf nc jx lh li nd lk ll lm ne lo lp lq nf ls lt lu im bi translated">有了所有的要素，我们现在可以为<code class="fe nh ni nj nk b">CompositionRoot</code>编写最终代码了。代码将位于一个名为<code class="fe nh ni nj nk b">CompositionRoot</code>的<code class="fe nh ni nj nk b">enum</code>中，作为模块属性和功能的名称空间。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nm nn l"/></div></figure><p id="df3b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">唯一的<code class="fe nh ni nj nk b">public</code>房产是<code class="fe nh ni nj nk b">composeApp</code>房产。这将返回整个应用程序的入口点。该属性将<code class="fe nh ni nj nk b">PokedexList</code>封装成一个<code class="fe nh ni nj nk b">NavigationView</code>。<code class="fe nh ni nj nk b">PokedexList</code>在<code class="fe nh ni nj nk b">PokemonList</code>中是通用的，这意味着我们可以从<code class="fe nh ni nj nk b">PokedexList</code>导航到<code class="fe nh ni nj nk b">PokemonList</code>。传递参数有:</p><ul class=""><li id="f383" class="lv lw it lb b lc ld lf lg li lx lm ly lq lz lu nl mb mc md bi translated">如上所述的<code class="fe nh ni nj nk b">PokedexService</code>；</li><li id="10dc" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu nl mb mc md bi translated"><code class="fe nh ni nj nk b">detailsProvider</code>关闭。这由共享闭包的相同签名的<code class="fe nh ni nj nk b">goToPokemonList</code>函数填充。</li></ul><p id="fdab" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe nh ni nj nk b">goToPokemonList</code>的主体与<code class="fe nh ni nj nk b">composeApp</code>属性非常相似。它返回<code class="fe nh ni nj nk b">PokemonList</code>视图，将<code class="fe nh ni nj nk b">pokedexId</code>和<code class="fe nh ni nj nk b">pokedexName</code>作为参数传递。其他参数是<code class="fe nh ni nj nk b">PokemonService</code>和最后一个功能:<code class="fe nh ni nj nk b">goToPokemonDetails</code>。</p><p id="e63b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">最后，<code class="fe nh ni nj nk b">goToPokemonDetails</code>函数通过<code class="fe nh ni nj nk b">pokemonId</code>、<code class="fe nh ni nj nk b">pokemonName</code>和<code class="fe nh ni nj nk b">PokemonDetailsService</code>参数返回<code class="fe nh ni nj nk b">PokemonDetails</code>视图。</p><h1 id="4ddf" class="mj mk it bd ml mm mn mo mp mq mr ms mt jz mu ka mv kc mw kd mx kf my kg mz na bi translated">将包与应用程序连接</h1><p id="6976" class="pw-post-body-paragraph kz la it lb b lc nb ju le lf nc jx lh li nd lk ll lm ne lo lp lq nf ls lt lu im bi translated">到目前为止，我们只在<code class="fe nh ni nj nk b">PokedexKit</code>包中写了代码，但还不能运行应用程序。我们仍然需要在<code class="fe nh ni nj nk b">PokedexApp</code>中导入包并连接它。</p><p id="c43d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">幸运的是，我们需要编写的代码只有几行:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nm nn l"/></div></figure><p id="5581" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这是整个应用程序代码。我们只在<code class="fe nh ni nj nk b">WindowGroup</code>组件中导入<code class="fe nh ni nj nk b">Root</code>模块并调用<code class="fe nh ni nj nk b">CompositionRoot.composeApp</code>属性。</p><h1 id="4670" class="mj mk it bd ml mm mn mo mp mq mr ms mt jz mu ka mv kc mw kd mx kf my kg mz na bi translated">结论</h1><p id="5f4a" class="pw-post-body-paragraph kz la it lb b lc nb ju le lf nc jx lh li nd lk ll lm ne lo lp lq nf ls lt lu im bi translated">在本文中，我们在Swift中创建了一个非常小的模块化应用程序。我们将所有代码打包在一个Swift包中:这有助于我们保持模块的分离和隔离。</p><p id="9d26" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们探索了三种不同的方法来定义网络依赖，而不实际实现它。</p><p id="4163" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">最后，我们在<code class="fe nh ni nj nk b">CompositionRoot</code>中编写了整个应用程序。这种方法非常灵活:</p><ul class=""><li id="ed5c" class="lv lw it lb b lc ld lf lg li lx lm ly lq lz lu nl mb mc md bi translated">我们可以通过交换实现来改变模块的行为。</li><li id="1c04" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu nl mb mc md bi translated">我们可以通过提供不同的视图来改变导航。</li><li id="bda2" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu nl mb mc md bi translated">我们可以注入其他功能来修饰闭包或服务实现。例如，在加载视图或执行网络调用之前，我们可以轻松地添加一些分析跟踪代码。</li></ul><p id="77b8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们在本文中开发的全部代码可以在<a class="ae ky" href="https://github.com/cipolleschi/PokedexApp" rel="noopener ugc nofollow" target="_blank">这个库</a>中找到。</p><p id="2b1c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">预先设计和思考你的应用程序的结构可以帮助分离关注点，提高可测试性，并且它使得更新、维护和改变你的应用程序的行为变得非常容易。</p></div></div>    
</body>
</html>