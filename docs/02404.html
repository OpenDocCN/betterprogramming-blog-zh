<html>
<head>
<title>Introduction to APScheduler</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">APScheduler简介</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/introduction-to-apscheduler-86337f3bb4a6?source=collection_archive---------1-----------------------#2019-11-28">https://betterprogramming.pub/introduction-to-apscheduler-86337f3bb4a6?source=collection_archive---------1-----------------------#2019-11-28</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="e94f" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">具有类似Cron功能的进程内任务调度程序</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/973df0955f8684320af1f264c614c67b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*puVQ95wUN8mXlCrBwQJ8rQ.jpeg"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">照片由<a class="ae ky" href="https://unsplash.com/@nooryounis?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">努尔·尤尼斯</a>在<a class="ae ky" href="https://unsplash.com/s/photos/clock?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</p></figure><p id="b4d0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">本教程重点介绍如何通过一个流行的Python库APScheduler来执行任务调度。来自<a class="ae ky" href="https://apscheduler.readthedocs.io/en/stable/" rel="noopener ugc nofollow" target="_blank">官方文档</a>:</p><blockquote class="lv lw lx"><p id="bb4b" class="kz la ly lb b lc ld ju le lf lg jx lh lz lj lk ll ma ln lo lp mb lr ls lt lu im bi translated">高级Python调度器(APScheduler)是一个Python库，允许您调度Python代码稍后执行，可以只执行一次，也可以定期执行。你可以随心所欲地添加新工作或删除旧工作。如果您将作业存储在数据库中，它们也将在排定程序重新启动后继续存在并保持其状态。当调度程序重新启动时，它将运行它在脱机时应该运行的所有作业。</p></blockquote><p id="9a06" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">APScheduler的主要优势之一是它可以跨不同平台使用，或者作为cron守护进程或Windows任务调度程序的替代。此外，在撰写本文时，它也在积极开发中。</p><p id="4eae" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">APScheduler提供了三种基本的调度系统:</p><ul class=""><li id="fe62" class="mc md it lb b lc ld lf lg li me lm mf lq mg lu mh mi mj mk bi translated">Cron风格的调度(具有可选的开始/结束时间)</li><li id="73f1" class="mc md it lb b lc ml lf mm li mn lm mo lq mp lu mh mi mj mk bi translated">基于间隔的执行(以均匀的间隔运行作业，可选择开始/结束时间)</li><li id="66d2" class="mc md it lb b lc ml lf mm li mn lm mo lq mp lu mh mi mj mk bi translated">一次性延迟执行(在设定的日期/时间运行一次作业)</li></ul><p id="bd76" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们将尝试在Flask服务器中创建一个简单的任务调度器作业。本教程分为五个部分:</p><ol class=""><li id="3727" class="mc md it lb b lc ld lf lg li me lm mf lq mg lu mq mi mj mk bi translated">设置</li><li id="ce9e" class="mc md it lb b lc ml lf mm li mn lm mo lq mp lu mq mi mj mk bi translated">基本API</li><li id="7967" class="mc md it lb b lc ml lf mm li mn lm mo lq mp lu mq mi mj mk bi translated">与烧瓶整合</li><li id="671c" class="mc md it lb b lc ml lf mm li mn lm mo lq mp lu mq mi mj mk bi translated">触发配置</li><li id="1b17" class="mc md it lb b lc ml lf mm li mn lm mo lq mp lu mq mi mj mk bi translated">结论</li></ol><p id="531a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果您只想检查这四行代码，请跳转到基本API <strong class="lb iu"> </strong>部分。</p></div><div class="ab cl mr ms hx mt" role="separator"><span class="mu bw bk mv mw mx"/><span class="mu bw bk mv mw mx"/><span class="mu bw bk mv mw"/></div><div class="im in io ip iq"><h1 id="8fe2" class="my mz it bd na nb nc nd ne nf ng nh ni jz nj ka nk kc nl kd nm kf nn kg no np bi translated">1.设置</h1><p id="07e8" class="pw-post-body-paragraph kz la it lb b lc nq ju le lf nr jx lh li ns lk ll lm nt lo lp lq nu ls lt lu im bi translated">安装过程非常简单明了。默认情况下，你应该有这个库，因为<code class="fe nv nw nx ny b">apscheduler</code>是作为一个内置包出现的。让我们测试一下，如果软件包没有安装，就安装它。激活您的虚拟环境，并运行以下命令:</p><pre class="kj kk kl km gt nz ny oa ob aw oc bi"><span id="6301" class="od mz it ny b gy oe of l og oh">pip show apscheduler</span></pre><p id="3b8d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果系统中已经安装了<code class="fe nv nw nx ny b">apscheduler</code>，您应该会看到下面的输出。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi oi"><img src="../Images/93638f62c6d318989ea0ec819807aa55.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*rEhYfNCRUaw2jkSry7GT6g.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">作者图片</p></figure><p id="64d0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果没有输出，不要惊慌——这仅仅意味着软件包没有安装。我们可以通过运行以下命令轻松安装它:</p><pre class="kj kk kl km gt nz ny oa ob aw oc bi"><span id="fcae" class="od mz it ny b gy oe of l og oh">pip install apscheduler</span></pre><p id="5560" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们继续下一节，我将解释基本概念和一些可用的API。</p></div><div class="ab cl mr ms hx mt" role="separator"><span class="mu bw bk mv mw mx"/><span class="mu bw bk mv mw mx"/><span class="mu bw bk mv mw"/></div><div class="im in io ip iq"><h1 id="9a0c" class="my mz it bd na nb nc nd ne nf ng nh ni jz nj ka nk kc nl kd nm kf nn kg no np bi translated">2.基本API</h1><p id="626d" class="pw-post-body-paragraph kz la it lb b lc nq ju le lf nr jx lh li ns lk ll lm nt lo lp lq nu ls lt lu im bi translated">APScheduler有四个主要组件，为了简洁起见，我在本教程中只解释其中的两个:</p><ul class=""><li id="25aa" class="mc md it lb b lc ld lf lg li me lm mf lq mg lu mh mi mj mk bi translated">调度程序</li><li id="5637" class="mc md it lb b lc ml lf mm li mn lm mo lq mp lu mh mi mj mk bi translated">引发</li></ul><p id="da0e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">Scheduler是用来添加或删除作业的主要组件。大多数用例只需要一个调度器。这些模块内置了不同类型的调度程序，具体取决于编程环境。</p><p id="64e9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">该列表如下:</p><ul class=""><li id="599e" class="mc md it lb b lc ld lf lg li me lm mf lq mg lu mh mi mj mk bi translated">当调度程序是你的进程中唯一运行的东西时使用</li><li id="cfc6" class="mc md it lb b lc ml lf mm li mn lm mo lq mp lu mh mi mj mk bi translated"><code class="fe nv nw nx ny b"><a class="ae ky" href="https://apscheduler.readthedocs.io/en/stable/modules/schedulers/background.html#apscheduler.schedulers.background.BackgroundScheduler" rel="noopener ugc nofollow" target="_blank">BackgroundScheduler</a></code>:当您没有使用下面的任何框架，并且希望调度程序在您的应用程序中后台运行时使用</li><li id="223a" class="mc md it lb b lc ml lf mm li mn lm mo lq mp lu mh mi mj mk bi translated"><code class="fe nv nw nx ny b"><a class="ae ky" href="https://apscheduler.readthedocs.io/en/stable/modules/schedulers/asyncio.html#apscheduler.schedulers.asyncio.AsyncIOScheduler" rel="noopener ugc nofollow" target="_blank">AsyncIOScheduler</a></code>:如果您的应用程序使用asyncio模块，请使用</li><li id="9dd8" class="mc md it lb b lc ml lf mm li mn lm mo lq mp lu mh mi mj mk bi translated"><code class="fe nv nw nx ny b"><a class="ae ky" href="https://apscheduler.readthedocs.io/en/stable/modules/schedulers/gevent.html#apscheduler.schedulers.gevent.GeventScheduler" rel="noopener ugc nofollow" target="_blank">GeventScheduler</a></code>:如果您的应用程序使用gevent，则使用</li><li id="d40c" class="mc md it lb b lc ml lf mm li mn lm mo lq mp lu mh mi mj mk bi translated"><code class="fe nv nw nx ny b"><a class="ae ky" href="https://apscheduler.readthedocs.io/en/stable/modules/schedulers/tornado.html#apscheduler.schedulers.tornado.TornadoScheduler" rel="noopener ugc nofollow" target="_blank">TornadoScheduler</a></code>:如果你正在构建一个Tornado应用程序，就使用它</li><li id="b46a" class="mc md it lb b lc ml lf mm li mn lm mo lq mp lu mh mi mj mk bi translated"><code class="fe nv nw nx ny b"><a class="ae ky" href="https://apscheduler.readthedocs.io/en/stable/modules/schedulers/twisted.html#apscheduler.schedulers.twisted.TwistedScheduler" rel="noopener ugc nofollow" target="_blank">TwistedScheduler</a></code>:如果您正在构建一个扭曲的应用程序，请使用它</li><li id="0d34" class="mc md it lb b lc ml lf mm li mn lm mo lq mp lu mh mi mj mk bi translated"><code class="fe nv nw nx ny b">QtScheduler</code>:在构建Qt应用程序时使用</li></ul><p id="99e6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在本教程中，我将使用<code class="fe nv nw nx ny b">BackgroundScheduler</code><strong class="lb iu"/>——因为我希望任务在Flask服务器中作为后台进程运行。</p><p id="78cc" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">接下来是触发器组件，它包含调度逻辑。每次向调度程序添加作业时，都需要指定触发器来确定作业下次运行的时间。APScheduler有三个内置触发器:</p><ul class=""><li id="e065" class="mc md it lb b lc ld lf lg li me lm mf lq mg lu mh mi mj mk bi translated"><code class="fe nv nw nx ny b"><a class="ae ky" href="https://apscheduler.readthedocs.io/en/stable/modules/triggers/date.html#module-apscheduler.triggers.date" rel="noopener ugc nofollow" target="_blank">date</a></code>:当您想在某个时间点只运行一次作业时使用</li><li id="e650" class="mc md it lb b lc ml lf mm li mn lm mo lq mp lu mh mi mj mk bi translated"><code class="fe nv nw nx ny b"><a class="ae ky" href="https://apscheduler.readthedocs.io/en/stable/modules/triggers/interval.html#module-apscheduler.triggers.interval" rel="noopener ugc nofollow" target="_blank">interval</a></code>:当您想要以固定的时间间隔运行作业时使用</li><li id="3837" class="mc md it lb b lc ml lf mm li mn lm mo lq mp lu mh mi mj mk bi translated"><code class="fe nv nw nx ny b"><a class="ae ky" href="https://apscheduler.readthedocs.io/en/stable/modules/triggers/cron.html#module-apscheduler.triggers.cron" rel="noopener ugc nofollow" target="_blank">cron</a></code>:当您希望在一天的特定时间定期运行作业时使用</li></ul><p id="61d7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">稍后我将使用<code class="fe nv nw nx ny b">interval</code> <strong class="lb iu"> </strong>和<code class="fe nv nw nx ny b">cron</code> <strong class="lb iu"> </strong>触发器来演示它们之间的区别。让我们探索如何用三行代码创建我们自己的任务调度作业。</p><h2 id="071b" class="od mz it bd na oj ok dn ne ol om dp ni li on oo nk lm op oq nm lq or os no ot bi translated">第1行:导入</h2><p id="4329" class="pw-post-body-paragraph kz la it lb b lc nq ju le lf nr jx lh li ns lk ll lm nt lo lp lq nu ls lt lu im bi translated">我们需要根据我们打算使用的调度程序导入必要的组件。在这种情况下，我将导入<code class="fe nv nw nx ny b">BackgroundScheduler</code>。</p><pre class="kj kk kl km gt nz ny oa ob aw oc bi"><span id="30d8" class="od mz it ny b gy oe of l og oh">from apscheduler.schedulers.background import BackgroundScheduler</span></pre><h2 id="57cc" class="od mz it bd na oj ok dn ne ol om dp ni li on oo nk lm op oq nm lq or os no ot bi translated">第2行:调度程序</h2><p id="6428" class="pw-post-body-paragraph kz la it lb b lc nq ju le lf nr jx lh li ns lk ll lm nt lo lp lq nu ls lt lu im bi translated">创建一个<code class="fe nv nw nx ny b">BackgroundScheduler</code>、<strong class="lb iu">、</strong>并将守护进程参数设置为<code class="fe nv nw nx ny b">True</code>。这允许我们在退出Flask应用程序时杀死线程。</p><pre class="kj kk kl km gt nz ny oa ob aw oc bi"><span id="8b04" class="od mz it ny b gy oe of l og oh">sched = BackgroundScheduler(daemon=True)</span></pre><h2 id="ccc6" class="od mz it bd na oj ok dn ne ol om dp ni li on oo nk lm op oq nm lq or os no ot bi translated">第3行:添加一个作业</h2><p id="24b2" class="pw-post-body-paragraph kz la it lb b lc nq ju le lf nr jx lh li ns lk ll lm nt lo lp lq nu ls lt lu im bi translated">我们将使用<code class="fe nv nw nx ny b">add_job</code>函数向调度程序添加一个任务。有三个主要参数可以配置。</p><ul class=""><li id="749d" class="mc md it lb b lc ld lf lg li me lm mf lq mg lu mh mi mj mk bi translated"><strong class="lb iu">函数</strong>:调度程序要调用的函数的名称。你也可以传递一个匿名函数</li><li id="90ce" class="mc md it lb b lc ml lf mm li mn lm mo lq mp lu mh mi mj mk bi translated"><strong class="lb iu">触发器</strong>:您正在使用的触发器</li><li id="d81d" class="mc md it lb b lc ml lf mm li mn lm mo lq mp lu mh mi mj mk bi translated"><strong class="lb iu">参数</strong>:触发的配置。不同的触发器有自己的参数。</li></ul><p id="a316" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们看一下下面的代码行，它每五秒钟显示一次调度程序中的可用作业。</p><pre class="kj kk kl km gt nz ny oa ob aw oc bi"><span id="de5f" class="od mz it ny b gy oe of l og oh">sched.add_job(lambda : sched.print_jobs(),'interval',seconds=5)</span></pre><h2 id="2ddf" class="od mz it bd na oj ok dn ne ol om dp ni li on oo nk lm op oq nm lq or os no ot bi translated">第4行:启动调度程序</h2><p id="ddd4" class="pw-post-body-paragraph kz la it lb b lc nq ju le lf nr jx lh li ns lk ll lm nt lo lp lq nu ls lt lu im bi translated">完成配置后，您可以使用以下代码行启动调度程序:</p><pre class="kj kk kl km gt nz ny oa ob aw oc bi"><span id="7a66" class="od mz it ny b gy oe of l og oh">sched.start()</span></pre><p id="f96b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">就是这样。如果您在Python shell中运行代码，您应该能够看到以下输出:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ou"><img src="../Images/6125e20934644d774914d616dbec8985.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*T21kEkXZ_X9Ej6fen4nMoA.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">作者图片</p></figure><p id="b51a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果您对<code class="fe nv nw nx ny b">KeyboardInterrupt</code>使用Ctrl-C，调度程序将继续照常运行，直到您使用Ctrl-Z退出Python Shell或运行<code class="fe nv nw nx ny b">shutdown</code> <strong class="lb iu"> </strong>函数</p><pre class="kj kk kl km gt nz ny oa ob aw oc bi"><span id="aee5" class="od mz it ny b gy oe of l og oh">sched.shutdown()</span></pre><p id="b268" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们进入下一节，讨论如何将它与Flask服务器集成。</p></div><div class="ab cl mr ms hx mt" role="separator"><span class="mu bw bk mv mw mx"/><span class="mu bw bk mv mw mx"/><span class="mu bw bk mv mw"/></div><div class="im in io ip iq"><h1 id="72ac" class="my mz it bd na nb nc nd ne nf ng nh ni jz nj ka nk kc nl kd nm kf nn kg no np bi translated">3.与烧瓶整合</h1><p id="b72b" class="pw-post-body-paragraph kz la it lb b lc nq ju le lf nr jx lh li ns lk ll lm nt lo lp lq nu ls lt lu im bi translated">你可以很容易地将日程表整合到烧瓶中，没有任何问题。让我们通过创建一个名为<code class="fe nv nw nx ny b">test.py</code>的新Python文件来尝试一下。</p><h2 id="d26d" class="od mz it bd na oj ok dn ne ol om dp ni li on oo nk lm op oq nm lq or os no ot bi translated">导入</h2><p id="8212" class="pw-post-body-paragraph kz la it lb b lc nq ju le lf nr jx lh li ns lk ll lm nt lo lp lq nu ls lt lu im bi translated">添加以下导入。</p><pre class="kj kk kl km gt nz ny oa ob aw oc bi"><span id="4794" class="od mz it ny b gy oe of l og oh">from flask import Flask<br/>from apscheduler.schedulers.background import BackgroundScheduler</span></pre><h2 id="fb91" class="od mz it bd na oj ok dn ne ol om dp ni li on oo nk lm op oq nm lq or os no ot bi translated">工作职能</h2><p id="cc48" class="pw-post-body-paragraph kz la it lb b lc nq ju le lf nr jx lh li ns lk ll lm nt lo lp lq nu ls lt lu im bi translated">这次我们将使用一个实际的函数，而不是匿名函数。创建一个名为<code class="fe nv nw nx ny b">sensor</code>，<strong class="lb iu"> </strong>的新函数，并在其中编写以下代码。count变量只是用于演示目的，以确定到目前为止我们已经调度了多少个作业。</p><pre class="kj kk kl km gt nz ny oa ob aw oc bi"><span id="c4f3" class="od mz it ny b gy oe of l og oh">count = 0</span><span id="eb71" class="od mz it ny b gy ov of l og oh">def sensor():<br/>    global count<br/>    sched.print_jobs()<br/>    print('Count: ' , count)<br/>    count += 1</span></pre><h2 id="08ee" class="od mz it bd na oj ok dn ne ol om dp ni li on oo nk lm op oq nm lq or os no ot bi translated">调度程序</h2><p id="189a" class="pw-post-body-paragraph kz la it lb b lc nq ju le lf nr jx lh li ns lk ll lm nt lo lp lq nu ls lt lu im bi translated">我们将像上面的步骤一样定义调度器，除了我们使用cron触发器而不是interval。</p><p id="5c06" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们将设置minute参数，改为每分钟触发一次作业。在这种情况下，使用星号标记。如果您将它指定为<code class="fe nv nw nx ny b">5</code>，这意味着它将在五分钟标记期间每小时被调用一次。</p><pre class="kj kk kl km gt nz ny oa ob aw oc bi"><span id="ce5b" class="od mz it ny b gy oe of l og oh">sched = BackgroundScheduler(daemon=True)<br/>sched.add_job(sensor,'cron',minute='*')<br/>sched.start()</span></pre><p id="c566" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果你添加一个带参数的函数，你可以通过<code class="fe nv nw nx ny b">args</code>参数传递参数。它接受列表或元组。假设我们之前的函数有两个参数。您可以如下调用<code class="fe nv nw nx ny b">add_job</code>函数:</p><pre class="kj kk kl km gt nz ny oa ob aw oc bi"><span id="fbea" class="od mz it ny b gy oe of l og oh">sched.add_job(sensor, args=['param1', param2], 'cron', minute='*')</span></pre><h2 id="31b4" class="od mz it bd na oj ok dn ne ol om dp ni li on oo nk lm op oq nm lq or os no ot bi translated">瓶</h2><p id="e310" class="pw-post-body-paragraph kz la it lb b lc nq ju le lf nr jx lh li ns lk ll lm nt lo lp lq nu ls lt lu im bi translated">剩下的任务是定义运行Flask服务器所需的函数。</p><pre class="kj kk kl km gt nz ny oa ob aw oc bi"><span id="1999" class="od mz it ny b gy oe of l og oh">app = Flask(__name__)</span><span id="43e4" class="od mz it ny b gy ov of l og oh">if __name__ == "__main__":<br/>    app.run('0.0.0.0',port=5000)</span></pre><p id="348b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">打开终端，将目录移动到<code class="fe nv nw nx ny b">test.py </code>文件的位置。运行以下命令:</p><pre class="kj kk kl km gt nz ny oa ob aw oc bi"><span id="601f" class="od mz it ny b gy oe of l og oh">python test.py</span></pre><p id="d51b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">只需等待几分钟，您应该会在终端中看到以下输出。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ow"><img src="../Images/6855f68d2cf1c9ee3fccae1ca506d405.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*yf_lkakM9DnsQoJtvygmQQ.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">作者图片</p></figure><p id="34e4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">您可以轻松修改传感器功能来执行您喜欢的任务。例子包括:</p><ul class=""><li id="209f" class="mc md it lb b lc ld lf lg li me lm mf lq mg lu mh mi mj mk bi translated">自动从数据库中提取数据</li><li id="e629" class="mc md it lb b lc ml lf mm li mn lm mo lq mp lu mh mi mj mk bi translated">每天在服务器上运行分析</li><li id="4332" class="mc md it lb b lc ml lf mm li mn lm mo lq mp lu mh mi mj mk bi translated">设定训练和更新模型的具体时间</li></ul><p id="7c07" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">只需几行代码就可以执行很多用例。</p></div><div class="ab cl mr ms hx mt" role="separator"><span class="mu bw bk mv mw mx"/><span class="mu bw bk mv mw mx"/><span class="mu bw bk mv mw"/></div><div class="im in io ip iq"><h1 id="ad27" class="my mz it bd na nb nc nd ne nf ng nh ni jz nj ka nk kc nl kd nm kf nn kg no np bi translated">4.触发示例</h1><p id="ff8d" class="pw-post-body-paragraph kz la it lb b lc nq ju le lf nr jx lh li ns lk ll lm nt lo lp lq nu ls lt lu im bi translated">本节将提供几个例子来展示如何根据需要配置触发器。</p><h2 id="eff5" class="od mz it bd na oj ok dn ne ol om dp ni li on oo nk lm op oq nm lq or os no ot bi translated">间隔</h2><p id="72f1" class="pw-post-body-paragraph kz la it lb b lc nq ju le lf nr jx lh li ns lk ll lm nt lo lp lq nu ls lt lu im bi translated">可以配置的一些最有用的参数如下:</p><ul class=""><li id="8a72" class="mc md it lb b lc ld lf lg li me lm mf lq mg lu mh mi mj mk bi translated"><code class="fe nv nw nx ny b">weeks</code> —等待的周数</li><li id="c601" class="mc md it lb b lc ml lf mm li mn lm mo lq mp lu mh mi mj mk bi translated"><code class="fe nv nw nx ny b">days</code> —等待的天数</li><li id="fa94" class="mc md it lb b lc ml lf mm li mn lm mo lq mp lu mh mi mj mk bi translated"><code class="fe nv nw nx ny b">hours </code> —等待的小时数</li><li id="0522" class="mc md it lb b lc ml lf mm li mn lm mo lq mp lu mh mi mj mk bi translated"><code class="fe nv nw nx ny b">minutes </code> —等待的分钟数</li><li id="70c2" class="mc md it lb b lc ml lf mm li mn lm mo lq mp lu mh mi mj mk bi translated"><code class="fe nv nw nx ny b">seconds</code> —等待的秒数</li><li id="923b" class="mc md it lb b lc ml lf mm li mn lm mo lq mp lu mh mi mj mk bi translated"><code class="fe nv nw nx ny b">start_date</code> —区间计算的起点</li><li id="5e4f" class="mc md it lb b lc ml lf mm li mn lm mo lq mp lu mh mi mj mk bi translated"><code class="fe nv nw nx ny b">end_date</code> —触发的最晚可能日期/时间</li></ul><p id="43cb" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">您可以使用以下代码将其设置为每两小时运行一次:</p><pre class="kj kk kl km gt nz ny oa ob aw oc bi"><span id="d44d" class="od mz it ny b gy oe of l og oh">sched.add_job(job_function, 'interval', hours=2)</span></pre><p id="26a7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">您可以添加开始和结束参数，以确保任务只在开始和结束时间戳之间运行。</p><pre class="kj kk kl km gt nz ny oa ob aw oc bi"><span id="a9bf" class="od mz it ny b gy oe of l og oh">sched.add_job(job_function, 'interval', hours=2, start_date='2019-11-11 09:00:00', end_date='2019-12-25 11:00:00')</span></pre><h2 id="65f2" class="od mz it bd na oj ok dn ne ol om dp ni li on oo nk lm op oq nm lq or os no ot bi translated">时间单位</h2><p id="21a8" class="pw-post-body-paragraph kz la it lb b lc nq ju le lf nr jx lh li ns lk ll lm nt lo lp lq nu ls lt lu im bi translated"><code class="fe nv nw nx ny b">cron</code> <strong class="lb iu"> </strong>触发器要复杂得多，因为它允许配置一些额外的参数。</p><ul class=""><li id="577b" class="mc md it lb b lc ld lf lg li me lm mf lq mg lu mh mi mj mk bi translated"><code class="fe nv nw nx ny b">year</code> —四位数年份</li><li id="641e" class="mc md it lb b lc ml lf mm li mn lm mo lq mp lu mh mi mj mk bi translated"><code class="fe nv nw nx ny b">month</code> —月份(1–12)</li><li id="6fc7" class="mc md it lb b lc ml lf mm li mn lm mo lq mp lu mh mi mj mk bi translated"><code class="fe nv nw nx ny b">day</code> —一个月中的某一天(1–31)</li><li id="5a6b" class="mc md it lb b lc ml lf mm li mn lm mo lq mp lu mh mi mj mk bi translated"><code class="fe nv nw nx ny b">week</code> —国际标准化组织周(1–53)</li><li id="f5fe" class="mc md it lb b lc ml lf mm li mn lm mo lq mp lu mh mi mj mk bi translated"><code class="fe nv nw nx ny b">day_of_week</code> —工作日的编号或名称(0-6或<code class="fe nv nw nx ny b">mon</code>、<code class="fe nv nw nx ny b">tue</code>、<code class="fe nv nw nx ny b">wed</code>、<code class="fe nv nw nx ny b">thu</code>、<code class="fe nv nw nx ny b">fri</code>、<code class="fe nv nw nx ny b">sat</code>、<code class="fe nv nw nx ny b">sun</code>)。第一个工作日总是星期一。</li><li id="a5f5" class="mc md it lb b lc ml lf mm li mn lm mo lq mp lu mh mi mj mk bi translated"><code class="fe nv nw nx ny b">hour </code> —小时(0–23)</li><li id="f819" class="mc md it lb b lc ml lf mm li mn lm mo lq mp lu mh mi mj mk bi translated"><code class="fe nv nw nx ny b">minute</code> —分钟(0–59)</li><li id="16cf" class="mc md it lb b lc ml lf mm li mn lm mo lq mp lu mh mi mj mk bi translated"><code class="fe nv nw nx ny b">second </code> —秒(0–59)</li><li id="3c6e" class="mc md it lb b lc ml lf mm li mn lm mo lq mp lu mh mi mj mk bi translated"><code class="fe nv nw nx ny b">start_date</code> —触发的最早可能日期/时间(含)</li><li id="d8e6" class="mc md it lb b lc ml lf mm li mn lm mo lq mp lu mh mi mj mk bi translated"><code class="fe nv nw nx ny b">end_date</code> —触发的最晚可能日期/时间(含)</li></ul><p id="e7d9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">与<code class="fe nv nw nx ny b">interval</code> <strong class="lb iu"> </strong>触发器不同，该参数末尾没有<code class="fe nv nw nx ny b">s</code>，同时接受<code class="fe nv nw nx ny b">int</code> <strong class="lb iu"> </strong>或<code class="fe nv nw nx ny b">string</code> <strong class="lb iu"> </strong>作为输入。对于<code class="fe nv nw nx ny b">string</code>输入，允许以下可用的<a class="ae ky" href="https://apscheduler.readthedocs.io/en/stable/modules/triggers/cron.html#expression-types" rel="noopener ugc nofollow" target="_blank">表达式</a>用于从年到秒的字段。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ox"><img src="../Images/556697e501b0620ccb185f97ad0fefae.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*1ngFjNdhIdY02WtLk2UrQw.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">作者图片</p></figure><p id="b31e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">计划在二月、三月、四月、十一月和十二月的第三个星期五的凌晨2点、3点、4点和5点运行任务；</p><pre class="kj kk kl km gt nz ny oa ob aw oc bi"><span id="6666" class="od mz it ny b gy oe of l og oh">sched.add_job(job_function, 'cron', month='2-4,11-12', day='3rd fri', hour='2-5')</span></pre><p id="9b4d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">计划在每月的最后一个星期日运行任务:</p><pre class="kj kk kl km gt nz ny oa ob aw oc bi"><span id="f27b" class="od mz it ny b gy oe of l og oh">sched.add_job(job_function, 'cron', day='last sun')</span></pre><p id="b367" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">计划每小时运行任务:</p><pre class="kj kk kl km gt nz ny oa ob aw oc bi"><span id="2215" class="od mz it ny b gy oe of l og oh">sched.add_job(job_function, 'cron', hour='*')</span></pre><h2 id="898d" class="od mz it bd na oj ok dn ne ol om dp ni li on oo nk lm op oq nm lq or os no ot bi translated">组合触发器</h2><p id="b35d" class="pw-post-body-paragraph kz la it lb b lc nq ju le lf nr jx lh li ns lk ll lm nt lo lp lq nu ls lt lu im bi translated">如果存在您想要组合触发器的情况，您可以根据您的使用情况通过<code class="fe nv nw nx ny b">AndTrigger</code> <strong class="lb iu"> </strong>和<code class="fe nv nw nx ny b">OrTrigger</code>、<strong class="lb iu"> </strong>来实现。</p><p id="edea" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">计划每三小时运行一次任务(仅适用于星期一和星期二):</p><pre class="kj kk kl km gt nz ny oa ob aw oc bi"><span id="35f6" class="od mz it ny b gy oe of l og oh">from apscheduler.triggers.combining import AndTrigger<br/>from apscheduler.triggers.interval import IntervalTrigger<br/>from apscheduler.triggers.cron import CronTrigger<br/><br/><br/>trigger = AndTrigger([IntervalTrigger(hours=3),<br/>                      CronTrigger(day_of_week='mon,tue')])<br/>scheduler.add_job(job_function, trigger)</span></pre><p id="2314" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">计划在每周六上午10点以及每周二上午3点、4点和5点运行任务</p><pre class="kj kk kl km gt nz ny oa ob aw oc bi"><span id="a654" class="od mz it ny b gy oe of l og oh">from apscheduler.triggers.combining import OrTrigger<br/>from apscheduler.triggers.cron import CronTrigger</span><span id="6ee3" class="od mz it ny b gy ov of l og oh">trigger = OrTrigger([CronTrigger(day_of_week='sat', hour=10),<br/>                     CronTrigger(day_of_week='tue', hour='3-5')])<br/>scheduler.add_job(job_function, trigger)</span></pre></div><div class="ab cl mr ms hx mt" role="separator"><span class="mu bw bk mv mw mx"/><span class="mu bw bk mv mw mx"/><span class="mu bw bk mv mw"/></div><div class="im in io ip iq"><h1 id="cc6b" class="my mz it bd na nb nc nd ne nf ng nh ni jz nj ka nk kc nl kd nm kf nn kg no np bi translated">5.结论</h1><p id="6fac" class="pw-post-body-paragraph kz la it lb b lc nq ju le lf nr jx lh li ns lk ll lm nt lo lp lq nu ls lt lu im bi translated">让我们回顾一下今天所学的内容。首先，我们从安装APScheduler模块开始。</p><p id="f493" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">然后，我们详细探讨了模块中的基本组件，即调度器和触发器。我们还测试了如何在Python Shell中仅用四行代码运行调度程序。</p><p id="032a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">下一步是将它集成到一个简单的Flask服务器中。我们使用了一个实际的函数，而不是匿名函数。</p><p id="87df" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">之后，我们学习了一些配置触发器组件参数的例子。我们也可以使用<code class="fe nv nw nx ny b">AndTrigger</code> <strong class="lb iu"> </strong>和<code class="fe nv nw nx ny b">OrTrigger</code>来组合<code class="fe nv nw nx ny b">cron</code> <strong class="lb iu"> </strong>触发器和<code class="fe nv nw nx ny b">interval</code> <strong class="lb iu"> </strong>触发器。</p><p id="ee2f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">感谢阅读，希望你喜欢这篇教程。下篇再见！</p></div><div class="ab cl mr ms hx mt" role="separator"><span class="mu bw bk mv mw mx"/><span class="mu bw bk mv mw mx"/><span class="mu bw bk mv mw"/></div><div class="im in io ip iq"><h1 id="6d85" class="my mz it bd na nb nc nd ne nf ng nh ni jz nj ka nk kc nl kd nm kf nn kg no np bi translated">参考</h1><ol class=""><li id="620a" class="mc md it lb b lc nq lf nr li oy lm oz lq pa lu mq mi mj mk bi translated"><a class="ae ky" href="https://github.com/agronholm/apscheduler" rel="noopener ugc nofollow" target="_blank">https://github.com/agronholm/apscheduler</a></li><li id="5606" class="mc md it lb b lc ml lf mm li mn lm mo lq mp lu mq mi mj mk bi translated"><a class="ae ky" href="https://github.com/agronholm/apscheduler/tree/master/examples" rel="noopener ugc nofollow" target="_blank">https://github . com/agronholm/apscheduler/tree/master/examples</a></li><li id="1819" class="mc md it lb b lc ml lf mm li mn lm mo lq mp lu mq mi mj mk bi translated"><a class="ae ky" href="https://apscheduler.readthedocs.io/en/stable/userguide.html" rel="noopener ugc nofollow" target="_blank">https://apscheduler.readthedocs.io/en/stable/userguide.html</a></li></ol></div></div>    
</body>
</html>