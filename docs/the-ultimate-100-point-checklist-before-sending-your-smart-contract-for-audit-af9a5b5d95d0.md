# 发送智能合同进行审核之前的最终 100 多点清单

> 原文：<https://betterprogramming.pub/the-ultimate-100-point-checklist-before-sending-your-smart-contract-for-audit-af9a5b5d95d0>

## 一长串的安全问题、最佳实践和省油技巧

![](img/9ee57b257cda5b85b36d76be187ac56f.png)

照片由[马库斯·温克勒](https://unsplash.com/@markuswinkler?utm_source=medium&utm_medium=referral)在 [Unsplash](https://unsplash.com?utm_source=medium&utm_medium=referral) 上拍摄

# 简介和动机

虽然没有清单可以涵盖 solidity 代码审查中出现的所有问题，但这些问题是我在代码审查中经常看到的，或者是 Solidity 或区块链环境中意想不到的问题。

为了表扬应该表扬的地方，我从 code4rena reports 和 the Solidity Underhanded 竞赛中借用了一些反复出现的主题。该列表还详尽地涵盖了智能合同弱点注册表，但在底部注明，由于 Solidity 更新，弱点不再适用。

此列表仅用于总结每个问题，并让读者意识到问题的存在。为了简洁起见，这里不能详细描述每个问题。如果不熟悉这个问题，鼓励读者去研究。

# 基础知识

## 100%的线和分支覆盖率

如果前端代码中有一个小错误，动画可能会稍微偏离。如果智能合同中存在漏洞，结果可能会导致公司破产。100%的覆盖率很烦人，但这是值得付出的代价。

## 突变试验

一个代码被 100%覆盖并不意味着极限情况被测试。如果你用一个`≤`替换一个`<`，这将导致你的测试中断，如果他们真的在测试你的代码的话。变异测试将自动变异您的代码，并重新运行您的测试，以告知您测试的有效性。

## 代码格式化

使用更漂亮来保持一致的代码格式。这样更容易阅读。

## 使用 solhint、slither 和 mythX 进行静态分析

这些工具将自动标记列表中的问题。虽然它们可能会有误报和遗漏关键错误，但是在您的开发管道中包含这些工具是一种低投入、高回报的投资。不要花数千美元让审计员注意到这些工具可以自动捕捉的东西。

## 访问控制是有意义的(SWC-105，SWC-106)

这涉及到忘记在函数上加上像`onlyOwner`这样的修饰语。这就是导致平价钱包冻结的原因。仔细检查每个函数，考虑允许谁调用它，应该允许谁调用它。

## 正确验证输入

输入整数的合理最小值或最大值是多少？(请注意，require `x >= 0`是一项必要的检查，将在后面讨论。)数组或字节是否有一定的长度？

## 管理员权力过大

我看到的最常见的方式是使用独立的可暂停令牌。如果管理地址遭到破坏，令牌将停止传输。如果令牌不是生态系统的一部分，那么从这个特性中什么也得不到。管理员需要特权，但理想情况下，特权应该是短暂的。

## 应该记录管理活动

这使得在与应用程序交互之前验证管理员没有滥用特权变得更加容易。

## 合理的部署策略到位

许多部署工具要求将私钥不加密地加载到硬盘上。如果必须这样做，必须采取措施隔离计算机或在部署后立即转移合同的所有权。用硬件钱包进行扁平化和部署也是一个不错的策略。

# 可读性

## 固定杂注(SWC-103)

自己设置编译器版本的时候不要做`pragma solidity ^0.8.7`。这使得验证者很难确定使用了哪个版本的 solidity。只有在您不能编译库代码时，才使用这种模式。改为做`pragma solidity 0.8.7`。

## 没有神奇的数字

代码中不要有无法解释的常数。最好有描述该值的常量变量，例如:

`public uint256 constant MAXIMUM_QUORUM_SIZE = 1_000;`

## 正确使用可读性关键字(小时、天、乙醚、1_000_000 等。)

在坚固度上，`1 days`会自动换算成可读性强得多的 86400 秒。类似地，为了可读性，我更喜欢`1_000_000`而不是`1000000`，并且在以太量的上下文中处理`10**18`的幂时使用 ether 关键字。更多[见此](https://docs.soliditylang.org/en/v0.8.14/units-and-global-variables.html)。

## 缺少必需的消息

Require 语句应该有解释。而不是`require(numTokens < MAX_TOKENS_TO_STAKE)`做`require(numTokens < MAX_TOKENS_TO_STAKE, “numTokens exceeds stake limit”)`。

## 从左向右字符(SWC-130)

unicode 字符`U+202E`应该不存在，因为这会改变文本呈现的顺序。这通常用于混淆目的。

## 不描述或误导的变量名、函数名或注释

避免使用像`mapping3`或`data`这样的名字，因为它们非常模糊。确保变量名是精确的、准确的和描述性的。不准确或过时的评论也应标记出来。

## 未使用的变量(SWC-131)

上面的工具会捕捉到这一点，但是未使用的变量会影响可读性。

## 没有效果的代码(SWC-135)

下面的函数不做任何事情，即使它是有效的。

```
function setPoolAddress(address _address) external onlyOwner {
    poolAddress == _address;
}
```

## 在命名中使用包容性语言

我并不主张成为政治上正确的语言警察，但是要意识到你的代码会被永久保存，并且可以被世界上的任何人阅读:保持得体、礼貌和尊重。

# 安全要素

## 德克萨斯州起源(SWC-115)

唯一真正的用例是检查智能契约是否调用你的代码。使用它进行验证可能会导致网络钓鱼攻击。

## encodePacked 会导致可变长度变量的哈希冲突(SWC-133)

这两个值将具有相同的哈希。在这种情况下使用`abi.encode`而不是`abi.encodePacked`:

`keccack256(abi.encodePacked(“HelloW”, “orld”);`

`keccack256(abi.encodePacked(“Hello”, “World”);`

## 在一个实度函数中调用多个函数的顺序未定义

在这种情况下，Solidity 并不指定首先调用哪个函数:

`myFunction(Interface(0x5cb…).method1(), method2());`

`method1`可能在`method2`之前被调用，或者在`method1`之前被调用`method2`，这取决于实体版本。如果它们可能导致状态改变或引用内存中的相同位置，这就很成问题。

仔细检查代码是否允许函数以任意顺序被调用。

## 精确的以太平衡或假设智能合约平衡不变(SWC-132)

任何人都可以通过直接发送以太网来改变智能合约的余额。即使您通过恢复它来覆盖接收和回退功能，如果`msg.value`不为零，另一个智能合约可以`selfdestruct`将以太网强制发送到另一个地址，绕过这些检查。

因此，如果您的逻辑期望一个地址的余额有一个精确的值或者保持静态，那么这个假设可能会被违反。

## 不安全的委托呼叫(SWC 112)

委托调用赋予委托地址无限的权力。这应仅用于您控制的合同，确保未授权用户无法更改委托地址至关重要。

## 升级不使用可信工具

智能合约升级可能会出现很多问题，在此列出它们没有意义。99%的情况下，你应该使用 OpenZeppelin 为 hardhat 或 truffle 升级的插件工具。但是如果你想要一个预览，这个可以帮助你:

*   存储插槽可能会发生冲突
*   通过构造函数或不可变变量存储的信息在下一个契约中不可用
*   初始化器需要被保护
*   `selfdestruct` 可以阻止升级

## 不检查合同的返回值(SWC-104)

如果函数返回值，应该在变量中捕获并检查它。solidity 编译器不会强制这样做，所以要注意没有返回值的函数，例如

```
function parent() external {
    doSomething(); // does this return something?
}
```

## 不检查来自不可信合同的回复(SWC-113)

如果这个函数不考虑外部函数调用可以恢复的可能性，它可能会经历拒绝服务。

```
function dos() external {
    IOtherContract(addr).makeCall(); // does this revert?
    payable(addr).call{value: 1 ether}(); // this can revert too doMyStuff(); // this will never happen
}
```

如果调用外部协定，该函数可能会恢复。如果这是故意的，你的合同将无法完成交易。最常见的弹出方式是自动退款到各种地址。这些地址可能是在接收以太网时回复的智能合同。这意味着循环中的每个人都无法获得退款。

## 无保护的商店和货架(SWC-124)

过去的情况是，你可以下溢一个数组长度变量并访问数组上方的存储，但在 solidity 0.8.0 中这不再是一个问题。然而，如果使用 Yul 代码`sstore`或`sload`，并且它们访问的存储不受限制，这种攻击仍然会发生。

## 无保护控制流(SWC-127)

虽然 jump 语句不是 yul 规范的一部分，但是您应该知道，仍然有可能使用逐字关键字或者通过编辑跳转目标来进行任意跳转。如果攻击者可以操纵控制流将跳转到哪里，他们就可以完全控制智能合约。

## 显式变量和函数可见性(SWC-100)

这个函数是公共的，任何人都可以调用。

```
function claimReward(uint256 rewardId) {
    // …
}
```

它应该显式地标记为 public(或者设置为 internal 或 private，如果这不是目的的话)。

## 一些 solidity 编译器版本有安全漏洞(SWC-102)

在使用某个版本的 solidity 编译器之前，检查 soliditylang.org，看看它是否有已知的错误。在这里通读发布公告是有建设性的:【https://blog.soliditylang.org/category/releases/】T2 看看什么样的错误出现了，什么得到了修复。(并了解语言中的细微特征)。

## SWC-122

这是一个难以理解的漏洞，但它被 Consensys 的 0x 审计发现了。归根结底，如果不受信任的用户可以改变他们的状态，你就不应该盲目地相信你自己的合同。根据合同逻辑，有人可能能够操纵“受信任的”智能合同。对于像 relayers 这样转发任意函数调用的契约来说尤其如此。本质上，当用户使用具有特殊权限的合同时，要注意权限提升。

## 确保信息来源不会被操纵

该漏洞最常见的表现是闪贷攻击。如果您的合同检查池中资产的价格，有人可以使用快速贷款来操纵资产价格，并在您的合同中导致意外行为。列举合同如何依赖外部信息，并询问这些信息来源如何被篡改。

# 基于时间的安全问题

## 时间戳的使用过于精细

阻塞时间在 12 到 20 秒之间(合并前)。应用程序不应测量小于该时间的时间间隔。如果您的应用程序需要在这种规模上测量时间，您需要一个不同于以太坊智能合约的解决方案。

## 使用块号作为时间戳(SWC-116)

闭塞时间随难度变化，合并后会有较大变化。时间戳是更精确的时间度量(几分钟，而不是几秒钟)。块号应该用于提交-揭示方案，而不是用于测量时间。

# 重新进入

## 重返(SWC-107)

在这里，我们无法公正地对待重返这个话题。可以说，这是数十亿美元被盗资金的幕后黑手，但这仍然是一个常见的错误。当心函数调用或以太转移到你没有创建的契约。此外，请注意`safeMint`和`safeTransfer`虽然不是外部调用，但会激活接收契约上的功能，这可能会导致重入。

不要相信 ERC20 中看似无害的函数，比如 transfer。恶意令牌可能会偏离 ERC 20 规范。

# 与签名相关的漏洞

## 恢复到零地址

在这里见文档[。](https://docs.openzeppelin.com/contracts/2.x/api/cryptography#ECDSA)

支票

```
bytes32(data).toEthSignedMessageHash().recover(signature) == verifyingAccount;
```

如果`verfyingAccount`还没定就能“成功”。确保在执行这行代码之前设置了`verifyingAccount`(比如在构造函数或初始化器中)

## 验证者不散列消息，可延展签名攻击(SWC-117)

`bytes32(data).recover(signature) == verifyingAccount`

易受攻击，因为攻击者可以创建数据和签名的组合，从而产生`verifyingAccount`。如果在签名恢复之前对数据进行哈希处理，那么攻击者将无法完成这种攻击。见[此处](https://docs.openzeppelin.com/contracts/2.x/api/cryptography#ECDSA)

## 缺少对重放攻击的保护(SWC-121)

该函数易受攻击，因为攻击者可以再次发送事务。

```
function transferToVulnerable(address _from, address _to, uint256 _amount, bytes calldata signature) external { require(abi.encodePacked(_from, _to, _amount).toEthSignedMessageHash().recover(signature) == _from);}
```

这是固定的。代码如下:

```
function transferToFixed(address _from, address _to, uint256 _amount, uint256 _nonce, bytes calldata signature) external { require(usedNonces[_nonce] == false, “nonce used”); usedNonces[_nonce] = true; require(abi.encodePacked(_from, _to, _amount, _nonce).toEthSignedMessageHash().recover(signature) == _from);}
```

# 算术错误

## 先乘后除

## 这将导致实度为零，而不是 30:

`10 / 100 * 300`

## 逐个误差

这是一般编程中非常常见的错误。这种情况经常发生，因为作者不知道应该使用比较还是严格比较(例如`<`还是`≤`)。在维基百科[页面](https://en.wikipedia.org/wiki/Off-by-one_error)查看更多信息:

# 合同外漏洞

## 不使用提交-显示

所有事务在内存池中挂起时都是可见的。在提交展示方案中，有人提交他们的行为(投票或出价)的散列，当所有投票和出价都在时，每个人都展示散列的前像。这可以防止人们根据被认为是秘密的信息采取行动。

## 使用区块链数据的随机性(SWC-120)

区块链上的所有数据都可以被矿工在一定程度上操纵(例如，通过将时间戳更改几秒钟)，因此如果矿工想要操纵彩票的结果，他们就可以。即使使用了 commit-reveal，如果矿工是可以提交值的参与者，他们仍然可以影响它。以下是解决方案:

*   如果一个矿工正在参加抽奖，使用链环
*   如果奖金少于总奖金，矿工就没有操纵奖金的动机
*   如果你知道矿工不能参与或者不会被贿赂，那就不是问题。

## 允许用户存储任意字符串会导致 XSS

如果你的网站显示存储在智能合约上的字符串，而智能合约允许用户设置任意字符串(比如给 NFTs 起昵称)，那么他们就可以通过一个

## 法规可能需要批准地址的能力

如果研究一下 USDC 的实现，您会发现它允许管理员阻止某些地址发送令牌。如果执法部门认定罪犯正在使用它，您的应用程序可能需要这样做。如果你的应用程序是完全去中心化的，你可能不需要它，但是不要考虑这个法律建议。

## 矿工提取值，兆电子伏(SWC-114)

矿工提取的价值是一个大话题，我们不能在这里涵盖。根据您的系统的令牌组学，矿工可以以对他们有利的方式重新排序事务。理想情况下，系统的设计应该使这样做的利润最小化。

## 未加密的私有数据(SWC-136)

区块链上没有什么是私有的，包括私有变量。

# 好的设计

## 在切换时使用幂等

虽然您可以通过用一个函数切换变量来节省契约大小，但如果区块链拥塞，事务可能会被丢弃，也可能不会被丢弃，这会导致不明确的情况。智能合约状态最好有单独的开启和关闭功能。

## 过于严格的验证(SWC-123)

你可以在这里阅读一个关于因为不必要的`require`声明[而损失 3400 万美元的真实故事。不能正确验证输入的另一面是，有太多的 require 语句会无意中锁定契约。](https://decrypt.co/98530/aku-ethereum-nft-launch-ends-with-34m-locked-in-flawed-smart-contract)

## 没有充分的理由不要阻止智能合同

你可以通过要求`msg.sender == tx.origin`让一个契约很难用`extcodesize`调用你的契约的函数，或者根本不可能。然而，这阻止了多签名钱包，所以除非有非常好的理由，否则不要这样做。

## 不要使用不推荐的可靠性函数(SWC-111)

一个好的编辑器会在你使用一个被否决的实度函数时警告你。例子包括`throw`、`suicide`、`msg.gas`、`block.blockhash`等等。

## 更喜欢 EIP-712

如果您的 dapp 要求用户签名，让他们知道他们正在签名什么，而不是显示一个神秘的十六进制字符串，这是很有帮助的。更多细节见这篇博客[帖子](https://medium.com/metamask/eip712-is-coming-what-to-expect-and-how-to-use-it-bb92fd1a7a26)。

## 自毁前检查令牌余额

如果合同打算持有 ERC20、NFTs 等代币。，它可以`selfdestruct`，那么它应该确保这些代币首先被移除，否则它们将在没有被烧毁的情况下从流通中移除，从而导致总供应量的误导计数。

## 嵌套映射需要显式的 getter 函数

Solidity 自动为公共变量创建 getter 函数，嵌套映射就是这种情况，但是当前的 javascript 库不能很好地与它们接口。建议将它们设为私有，并添加一个公共 getter 函数。

## 断言的使用(SWC-110)

Assert 用于测试目的，或者在契约以非法状态结束时结束事务。它不应该用于验证输入，因为它消耗了所有的气体，没有退款。

# 坚固的惊喜

## 嵌套数组的行为很奇怪

嵌套数组的读取方向与声明方向相反。

## 结构总是存在的

Solidity 没有 null，所以这段代码会返回零地址；它不会失败。

```
contract ExampleContract {
    struct Foo {
        address owner;
        uint256 amount;
    } mapping(uint256 => Foo) mapz; function get() public view returns(address) {
        return mapz[1].owner;
    }}
```

## 不要隐藏状态变量(SWC-119)

给在函数内部和存储级声明的变量取相同的名字会引起混淆。至少，在函数变量前面加上下划线。

## 使用多重继承时避免函数和变量同名(SWC-125)

当父类有容易混淆的匹配名称时，Solidity 使用 C3 继承解析。如果可能的话，最好完全避免匹配姓名。

## 意外覆盖回退功能

如果您创建一个函数选择器全为零的函数，则根据该函数的作用，您可能无法将以太直接发送到协定。在以太坊发送一个正常的交易会导致智能合约将其解释为调用一个全零的函数选择器。

# 致命气体错误

*关于固和气的完整解释，可以查看我的* [*Udemy 课程*](https://www.udemy.com/course/advanced-solidity-understanding-and-optimizing-gas-costs/?referralCode=C4684D6872713525E349) *。*

## 删除任意长的数组

在伦敦 Hardfork 之前，删除数组会导致退款。现在它有一个净成本，所以如果阵列足够长，天然气成本可能会非常高，可能超过单个区块的天然气限制。您不是在删除数组，而是一个接一个地删除数组中的每一项。

## 无界循环

当 gas 需求大于块限制时，在用户可以将任意数量的条目推入的数组上循环会导致某个函数无法再执行。

## 无限内存分配

坚固性内存开销在超过某个点后以二次方增长，所以内存中非常长的数组可能会达到气体块限制。

## 循环中的状态变化

即使循环是有界的，循环也会导致昂贵的操作变得极其昂贵。如果协定在循环内传输以太网、创建其他智能协定、设置存储变量或其他开销较大的操作，请小心。

## 不可信的合同可能有不确定的天然气成本

您的合同应该能够处理旨在耗尽天然气资源的合同调用。例如，恶意的 ERC20 令牌可以将传递函数设置为消耗非常大量的汽油。这与作为拒绝服务的一种形式的契约回复有关。

## 硬编码气体(SWC-134)

随着以太坊通过硬分叉升级，汽油费用会发生变化。函数调用中的硬编码 gas 开销会导致前向兼容性的破坏。

## 不要用。转学还是。发送，除非收件人肯定是 EOA 人(SWC-134)

更多见此:[https://consensys . net/diligence/blog/2019/09/stop-using-soliditys-transfer-now/](https://consensys.net/diligence/blog/2019/09/stop-using-soliditys-transfer-now/)

## 气体净化 SWC-126

令人悲伤的攻击不会给攻击者带来经济上的好处，但是因为他们有一些其他的动机来引起人们的悲伤，他们还是开始了攻击。SWC-126 中提到的具体攻击是交易转发器限制其转发的交易的 gas 量，导致交易恢复。这里的抱怨者仍然在被还原的交易的交易费用上损失金钱，但是发送交易的人感到难过，因为他们的交易被审查。

一个更普遍的抱怨例子是当合同将钱分配给地址时的回复，因此没有一个地址(包括抱怨者)可以收到钱。

## 数据结构无限制或大量增长(SWC-128)

最好首先避免创建大型数据结构。如果一个数组(或队列或堆栈)可以无限制地增长，这可能会导致令人头痛的问题。

# 有意义的气体改进

## 将优化器设置得尽可能高

大多数工具将优化器预设为 200，但是在大多数应用中，gas 可以通过增加它来继续改进。Uniswap 将优化器设置为 100 万，我认为这是一个更好的默认值。只有当合同太大而无法部署时，才降低优化器的级别。

## 如果链上不需要该值，则首选日志记录而不是存储

日志仅花费几千个气体，但是设置一个新的存储变量会花费超过 20，000 个气体。如果链上不需要这些信息，就使用日志。

## 避免非正交状态

非正交状态意味着存储可以从现有来源获得的信息。例如，如果存储一笔贷款的本金和利息，那么还存储欠款总额是多余的。

这并不意味着应该总是避免非正交状态。如果链上需要该信息，缓存整数数组的和可能比重新计算它更容易。运用良好的判断力。

## 包装相关变量

如果两个变量在同一个事务中受到影响，将它们放在同一个槽中会提高 gas。例如，如果你检查是否公开销售，然后增加代币的数量；如果他们住在同一个位置，交易会更便宜。

## 出于打包目的，在地址下放置布尔值或 uint96 或更小的值

我们稍后将讨论使用小于 256 的整数会消耗更多的汽油，但是如果您的应用程序无论如何都需要更小的数字，请将它们放在一起。

## 不必要的重入保护

在不转移以太或进行外部调用的函数上使用 OpenZeppelin 的不可重入修饰符是浪费时间。

## 在多次部署中使用克隆

如果您的合同部署了同一个合同的许多副本，使用克隆模式([eips.ethereum.org/EIPS/eip-1167](https://eips.ethereum.org/EIPS/eip-1167))而不是一遍又一遍地部署相同的字节码。

## 首选多呼叫

如果你的用户需要进行一系列的事务，给他们一个多调用的机制可以节省很多汽油。

## 一次读写存储

不要在一个事务中两次读取同一个存储变量。将其缓存在一个局部变量中。这方面的一个例子是获取存储中数组的长度(稍后讨论)。例外情况是，如果你在处理不可信的合同时记账。

# 适度的气体改进

## 缓存数组.长度

当遍历一个数组时，不要每次迭代都检查数组长度，因为这是一个额外消耗内存的存储读取。代码如下:

```
// less efficientfor (uint256 x = 0; x < array.length; i++) {
    // do stuff
}// efficientarrayLength = array.length;
for (uint256 x = 0; x < arrayLength; ) {
    // do stuff
    unchecked {
        ++i;
    }
}
```

## 廉价 require 语句应该放在昂贵的语句之前

存储读取开销更大，所以在检查存储变量(代价很高)之前，先检查函数参数(代价很低)。如果用户提供了错误的参数，他们不会为存储读取付费。仅恢复到恢复前的成本气体，而不是交易的假设成本。

## 不要在 solidity 0.8.0 或更高版本上使用 safemath

Solidity 0.8.0 内置了溢出保护。也就是说，如果两个数之和小于其中一项，它将返回，并对其他类型的数学进行类似的检查。使用 SafeMath 库只会浪费更多的汽油。

## 呼叫数据优先于内存

函数参数中的 memory 关键字会导致基础代码将参数复制到内存中。Calldata 使代码读取事务，而不直接复制它。

## 用散列来比较字符串，而不是逐个字符地比较

这个技巧可能取决于字符串的长度，但是在您的应用程序中对这两种方法进行基准测试是值得的。

## 如果错误是可参数化的，则使用自定义错误

如果自定义错误比要求的语句更好，这是有点争议的。但是如果错误消息是可参数化的，那么它们显然是赢家。

## 如果可能，优先选择字节 32 而不是字节

如果存储的是短字符串，那么 bytes32 将是一种更有效的存储方式。

## 公共变量上不必要的 getter 函数

除了嵌套映射，公共变量上的 getter 函数是多余的。Solidity 为公共变量创建了一个 getter 函数，您的 IDE 将生成一个显示该函数的 ABI。

## 短路布尔以避免昂贵的检查

避免在 require 语句中使用布尔表达式，并使用单独的`require`语句会更便宜，这将在后面讨论。但是如果你需要一个布尔表达式，使用[短路](https://en.wikipedia.org/wiki/Short-circuit_evaluation)来节省时间。

## 不必要的保险箱或保险箱转移

如果你确定你将铸造或转移到 EOA，而不是智能合同。那么这些函数将是一种浪费，因为在与它们交互之前，它们会检查地址是否是一个智能契约。

如果你不确定，那么是的，使用它们，但是要安全地做，因为它们可以像前面提到的那样重新进入。

## 设置一次的变量应该是不可变的，除非合同是可升级的

不可变变量存储在字节码中，而不是存储中，从 gas 的角度来看，这要便宜得多。

## 应取消选中增量

如果一个变量从 0，1，2，…递增，并且每个事务递增一次，那么在宇宙热寂之前，它不可能递增到 2 ⁵⁶-1。取消选中此项将节省汽油。

# 轻微的气体改进

## Uint256 比布尔型和小型 Uint 更有效

boolean 是一个 uint256，其中 255 位被屏蔽。额外的掩蔽会消耗气体。只有在通过打包变量来节省空间的情况下，才减小大小。很少有好的理由对非存储变量使用小于 uint256 的值。

## 除非溢出是可能的，否则移位而不是除以或乘以 2

移位要花三个油钱，但乘除要花五个油钱。

## 如果合同有许多布尔变量，请使用位图

一个 boolean 实际上和一个 uint8 是一样的。这意味着一个`uint256`可以容纳多达 32 个布尔变量。如果您有超过 32 个布尔变量，最好将它们作为一个单位存储在 uint256 中。

## 优化气敏函数的函数名

带有前导零的函数以两种方式节省汽油。首先，它们被排序到字节码的顶部，从而减少了查看该函数是否被调用的检查。第二，前导零节省了交易数据中的汽油。这可能导致愚蠢的函数名，所以只有在节省成本的情况下才这样做。

## 气敏函数的包装函数参数

将两个 128 位的数字表示为一个 256 位的数字，并将它们分成两个数字可以节省能源。这适用于较小的数字。因为这会降低函数的可读性，所以只推荐用于对气体敏感的函数。

## 应避免对单位使用 require(x >= 0，“…”)

无符号整数不能是负数，所以这种检查只是浪费时间。

## Split require 语句，而不是使用布尔运算符

`require(a && b, “message”);`不如`require(a, “message a”); require(b, “message b”);`有效率

## 比较布尔文字

当`condition`为布尔变量时，`if(condition)`与`if(condition == true)`相同，但前者更节能。

## 更喜欢 x = x + y 而不是 x += y

虽然这些操作在数学上是相同的，但是编译器不会以同样的方式处理它们。

## 比起 x++，更喜欢++x

如果一个变量是独立递增的，那么前缀递增是首选，这也是因为编译器的古怪。

## 使用循环时使用未选中的{ ++x }

如果一个循环使用 uint256(它应该这样)，那么它就不会溢出。所以可以用`unchecked`递增。取消前面讨论的溢流检查将节省汽油。

## 不要将存储变量初始化为默认值

将存储变量初始化为零、假、零地址等等只是浪费气体。默认情况下，它们为零。坚固性没有空值。

## 交换单行中的变量

如果需要交换变量，不需要显式的临时变量也能有效地完成，如下所示:

`(x, y) = (y, x);`

## 如果可能的话，使用>或

在引擎盖下，坚固代表`≥`是`not <`。额外的不操作花费三个汽油。

## 对固定长度的参数使用 encodePacked over encode

编码消耗更多的气体，因为它填充输入。对于固定长度的输入，这是一个无用的额外成本。

## 管理功能可以付费

可支付函数节省了汽油，因为不可支付函数显式检查`msg.value`是否为非零，如果是，则返回。额外的检查花费汽油。对于一般公众使用的功能，可能仍然希望使它们不付费，以防止意外的状态转换。但是，当管理员可以对合同进行危险的更改时，将乙醚作为交易的一部分是一个小威胁。

## 在函数签名中声明返回变量

这样做可以节省一点汽油:

```
function plusOne(uint256 x) external returns (uint256 y) {
    y = x + 1;
}
```

# 过时的 SWC

## SWC-101

从 solidity 0.8.0 开始，除非使用`unchecked`关键字，否则整数不会溢出或下溢。

## SWC-109

Solidity 0.4.0 允许你声明不确定大小的变量，而不用指定它们是在内存中还是存储中。从 0.5.0 开始，情况不再是这样了。

## SWC-118

过去的情况是，构造函数由与契约同名的构造函数来确定，但是如果函数名拼写错误，就会出现问题。从 solidity 0.4.22 开始，构造函数必须被函数名 constructor 引用。

## SWC-129

语句`x =+ 1`曾经是有效的，但是后来版本的 solidity 使得这个语法无效。在过去，这可能会被误解为增量。

感谢阅读！

```
**Want to Connect?**Join my 4 month solidity bootcamp: [rareskills.io/curriculum](https://www.rareskills.io/curriculum)Follow me on twitter: [twitter.com/jeyffre](https://twitter.com/jeyffre)Check out my Udemy courses: [https://www.udemy.com/user/jeffrey-scholz/](https://www.udemy.com/user/jeffrey-scholz/)
```