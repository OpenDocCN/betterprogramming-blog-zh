<html>
<head>
<title>What’s New? Java 14 Features</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">有什么新鲜事？Java 14特性</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/whats-new-java-14-features-6b5856c94aa4?source=collection_archive---------6-----------------------#2020-03-17">https://betterprogramming.pub/whats-new-java-14-features-6b5856c94aa4?source=collection_archive---------6-----------------------#2020-03-17</a></blockquote><div><div class="fc ii ij ik il im"/><div class="in io ip iq ir"><h2 id="5fcc" class="is it iu bd b dl iv iw ix iy iz ja dk jb translated" aria-label="kicker paragraph">入门指南</h2><div class=""/><div class=""><h2 id="ff86" class="pw-subtitle-paragraph ka jd iu bd b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr dk translated">记录、文本块、有用的npe等等</h2></div><figure class="kt ku kv kw gu kx gi gj paragraph-image"><div role="button" tabindex="0" class="ky kz di la bf lb"><div class="gi gj ks"><img src="../Images/4481551ad9f886a13316830098d75ca5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*SrdInNEVcu6IJ-Bo"/></div></div><p class="le lf gk gi gj lg lh bd b be z dk translated">照片由<a class="ae li" href="https://unsplash.com/@karlchor?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">卡尔·乔</a>在<a class="ae li" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</p></figure><p id="8e7e" class="pw-post-body-paragraph lj lk iu ll b lm ln ke lo lp lq kh lr ls lt lu lv lw lx ly lz ma mb mc md me in bi translated">紧跟2019年9月17日<a class="ae li" href="https://www.journaldev.com/33204/java-13-features" rel="noopener ugc nofollow" target="_blank"> Java 13 </a>发布后六个月的周期传统，Java 14，另一个非LTS版本计划于2020年3月17日发布。</p><p id="ce8d" class="pw-post-body-paragraph lj lk iu ll b lm ln ke lo lp lq kh lr ls lt lu lv lw lx ly lz ma mb mc md me in bi translated">以下是Java 14的特性列表:</p><ul class=""><li id="36cd" class="mf mg iu ll b lm ln lp lq ls mh lw mi ma mj me mk ml mm mn bi translated">开关表达式(标准)— JEP 361</li><li id="ff00" class="mf mg iu ll b lm mo lp mp ls mq lw mr ma ms me mk ml mm mn bi translated">实例的模式匹配(预览)— JEP 305</li><li id="8edb" class="mf mg iu ll b lm mo lp mp ls mq lw mr ma ms me mk ml mm mn bi translated">有用的空指针异常— JEP 358</li><li id="67c4" class="mf mg iu ll b lm mo lp mp ls mq lw mr ma ms me mk ml mm mn bi translated">记录(预览)— JEP 359</li><li id="2144" class="mf mg iu ll b lm mo lp mp ls mq lw mr ma ms me mk ml mm mn bi translated">文本块(第二次预览)— JEP 368</li><li id="7ec3" class="mf mg iu ll b lm mo lp mp ls mq lw mr ma ms me mk ml mm mn bi translated">包装工具(孵化器)— JEP 343</li><li id="0d3e" class="mf mg iu ll b lm mo lp mp ls mq lw mr ma ms me mk ml mm mn bi translated">G1 — JEP 345的NUMA感知内存分配</li><li id="a3ab" class="mf mg iu ll b lm mo lp mp ls mq lw mr ma ms me mk ml mm mn bi translated">JFR活动流— JEP 349</li><li id="d0bc" class="mf mg iu ll b lm mo lp mp ls mq lw mr ma ms me mk ml mm mn bi translated">非易失性映射字节缓冲区— JEP 352</li><li id="6dc5" class="mf mg iu ll b lm mo lp mp ls mq lw mr ma ms me mk ml mm mn bi translated">苹果电脑上的ZGC—JEP 364</li><li id="e6b5" class="mf mg iu ll b lm mo lp mp ls mq lw mr ma ms me mk ml mm mn bi translated">Windows上的ZGC—JEP 365</li><li id="e323" class="mf mg iu ll b lm mo lp mp ls mq lw mr ma ms me mk ml mm mn bi translated">外部内存访问API(孵化器)— JEP 370</li></ul></div><div class="ab cl mt mu hy mv" role="separator"><span class="mw bw bk mx my mz"/><span class="mw bw bk mx my mz"/><span class="mw bw bk mx my"/></div><div class="in io ip iq ir"><h1 id="754e" class="na nb iu bd nc nd ne nf ng nh ni nj nk kj nl kk nm km nn kn no kp np kq nq nr bi translated">Mac OS上的Java 14安装设置</h1><ul class=""><li id="ecb7" class="mf mg iu ll b lm ns lp nt ls nu lw nv ma nw me mk ml mm mn bi translated">要开始使用Java 14，请在这里下载JDK<a class="ae li" href="http://jdk.java.net/14/" rel="noopener ugc nofollow" target="_blank"/>。</li><li id="f260" class="mf mg iu ll b lm mo lp mp ls mq lw mr ma ms me mk ml mm mn bi translated">复制并解压<code class="fe nx ny nz oa b">/Library/Java/JavaVirtualMachines</code>中的tar文件，如下图所示:</li></ul><pre class="kt ku kv kw gu ob oa oc od aw oe bi"><span id="fc27" class="of nb iu oa b gz og oh l oi oj">$ cd<!-- --> <!-- -->/Library/Java/JavaVirtualMachines</span><span id="df69" class="of nb iu oa b gz ok oh l oi oj">$ sudo<!-- --> <!-- -->cp<!-- --> <!-- -->~/Downloads/openjdk-14_osx-x64_bin.tar.gz /Library/Java/JavaVirtualMachines</span><span id="8b2f" class="of nb iu oa b gz ok oh l oi oj">$ sudo<!-- --> <!-- -->tar<!-- --> <!-- -->xzf openjdk-14_osx-x64_bin.tar.gz</span><span id="5e57" class="of nb iu oa b gz ok oh l oi oj">$ sudo<!-- --> <!-- -->rm<!-- --> <!-- -->openjdk-14_osx-x64_bin.tar.gz</span></pre><p id="8c11" class="pw-post-body-paragraph lj lk iu ll b lm ln ke lo lp lq kh lr ls lt lu lv lw lx ly lz ma mb mc md me in bi translated">一旦完成，使用任何文本编辑器创建/编辑<code class="fe nx ny nz oa b">bash_profile</code>。我用的是<code class="fe nx ny nz oa b">vim ~/.bash_profile</code>。将Java14的路径设置为<code class="fe nx ny nz oa b">JAVA_HOME</code>，保存更改，并做一个<code class="fe nx ny nz oa b">source ~/.bash_profile</code>来反映更改。</p><pre class="kt ku kv kw gu ob oa oc od aw oe bi"><span id="9e26" class="of nb iu oa b gz og oh l oi oj">export JAVA_HOME=/Library/Java/JavaVirtualMachines/jdk-14.jdk/Contents/Home</span></pre><p id="b18d" class="pw-post-body-paragraph lj lk iu ll b lm ln ke lo lp lq kh lr ls lt lu lv lw lx ly lz ma mb mc md me in bi translated">最后，您已经准备好使用Java 14编译和运行程序了。我们将使用JShell，一个交互式REPL命令行工具，用于快速测试Java 14的新特性。</p><p id="a17e" class="pw-post-body-paragraph lj lk iu ll b lm ln ke lo lp lq kh lr ls lt lu lv lw lx ly lz ma mb mc md me in bi translated">值得注意的是，Java 14中发布的许多特性都在预览版中。这意味着，虽然他们现在正在全力工作，但未来可能会有所改变。有些可以成为标准，或者在下一个发布周期中简单地删除。为了测试预览功能，您需要在运行JShell或Java程序时显式设置<code class="fe nx ny nz oa b">--enable-preview</code>，如下所示:</p><pre class="kt ku kv kw gu ob oa oc od aw oe bi"><span id="154a" class="of nb iu oa b gz og oh l oi oj">jshell --enable-preview</span><span id="9f68" class="of nb iu oa b gz ok oh l oi oj">javac --release 14 --enable-preview &lt;FileName&gt;.java</span></pre><p id="da71" class="pw-post-body-paragraph lj lk iu ll b lm ln ke lo lp lq kh lr ls lt lu lv lw lx ly lz ma mb mc md me in bi translated">在接下来的几节中，让我们讨论一些语言和JVM特性。</p></div><div class="ab cl mt mu hy mv" role="separator"><span class="mw bw bk mx my mz"/><span class="mw bw bk mx my mz"/><span class="mw bw bk mx my"/></div><div class="in io ip iq ir"><h1 id="3376" class="na nb iu bd nc nd ne nf ng nh ni nj nk kj nl kk nm km nn kn no kp np kq nq nr bi translated">1.切换表达式</h1><p id="6c66" class="pw-post-body-paragraph lj lk iu ll b lm ns ke lo lp nt kh lr ls ol lu lv lw om ly lz ma on mc md me in bi translated">在Java 12和Java 13的最后两个版本中保留了预览特性之后，Switch表达式终于在Java 14中获得了永久的地位。</p><ul class=""><li id="5e3b" class="mf mg iu ll b lm ln lp lq ls mh lw mi ma mj me mk ml mm mn bi translated"><a class="ae li" href="https://www.journaldev.com/28666/java-12-features" rel="noopener ugc nofollow" target="_blank"> Java 12 </a>为switch表达式引入了lambda语法，从而允许多个case标签用于模式匹配，并防止导致冗长代码的失败。它还强制执行了穷举的情况，如果没有覆盖所有的输入情况，就会抛出编译错误。</li><li id="f255" class="mf mg iu ll b lm mo lp mp ls mq lw mr ma ms me mk ml mm mn bi translated"><a class="ae li" href="https://www.journaldev.com/33204/java-13-features" rel="noopener ugc nofollow" target="_blank"> Java 13 </a>，第二个预览版引入了<code class="fe nx ny nz oa b">yield</code>语句而不是<code class="fe nx ny nz oa b">break</code>来从表达式返回值。</li></ul><p id="217f" class="pw-post-body-paragraph lj lk iu ll b lm ln ke lo lp lq kh lr ls lt lu lv lw lx ly lz ma mb mc md me in bi translated">Java 14现在终于让这些特性成为了标准。</p><pre class="kt ku kv kw gu ob oa oc od aw oe bi"><span id="0fea" class="of nb iu oa b gz og oh l oi oj">String result = switch (day) {<br/>            case "M", "W", "F" -&gt; "MWF";<br/>            case "T", "TH", "S" -&gt; "TTS";<br/>            default -&gt; {<br/>                if(day.isEmpty())<br/>                    yield "Please insert a valid day.";<br/>                else<br/>                    yield "Looks like a Sunday.";<br/>            }<br/>        };<br/>System.out.println(result);</span></pre><figure class="kt ku kv kw gu kx gi gj paragraph-image"><div class="gi gj oo"><img src="../Images/ec35b7c8250263ed10cca6820cf5d165.png" data-original-src="https://miro.medium.com/v2/resize:fit:1032/format:webp/0*EoBmHqQoeke06WTy.png"/></div></figure><p id="080e" class="pw-post-body-paragraph lj lk iu ll b lm ln ke lo lp lq kh lr ls lt lu lv lw lx ly lz ma mb mc md me in bi translated">注意:Yield不是Java中的新关键字。它只是用在开关表达式中。</p></div><div class="ab cl mt mu hy mv" role="separator"><span class="mw bw bk mx my mz"/><span class="mw bw bk mx my mz"/><span class="mw bw bk mx my"/></div><div class="in io ip iq ir"><h1 id="0712" class="na nb iu bd nc nd ne nf ng nh ni nj nk kj nl kk nm km nn kn no kp np kq nq nr bi translated">2.实例的模式匹配(预览)</h1><p id="2c79" class="pw-post-body-paragraph lj lk iu ll b lm ns ke lo lp nt kh lr ls ol lu lv lw om ly lz ma on mc md me in bi translated">请任何Java开发人员展示他们的代码库，你会在整个代码中很好地利用<code class="fe nx ny nz oa b">instanceof</code>条件。具体来说，<code class="fe nx ny nz oa b">instanceof</code>条件检查之后通常是显式类型转换。</p><p id="2e65" class="pw-post-body-paragraph lj lk iu ll b lm ln ke lo lp lq kh lr ls lt lu lv lw lx ly lz ma mb mc md me in bi translated">Java 14通过使条件提取更加简洁来消除这种冗长。</p><h2 id="f846" class="of nb iu bd nc op oq dn ng or os dp nk ls ot ou nm lw ov ow no ma ox oy nq ja bi translated">Java 14之前:</h2><pre class="kt ku kv kw gu ob oa oc od aw oe bi"><span id="daa3" class="of nb iu oa b gz og oh l oi oj">if (obj instanceof Article) {<br/>  Article a= (Article) obj;<br/>  System.out.println(a.getAuthor());<br/>}</span></pre><h2 id="40d3" class="of nb iu bd nc op oq dn ng or os dp nk ls ot ou nm lw ov ow no ma ox oy nq ja bi translated">Java 14以上版本:</h2><pre class="kt ku kv kw gu ob oa oc od aw oe bi"><span id="1ed4" class="of nb iu oa b gz og oh l oi oj">if (obj instanceof Article a) {<br/>  System.out.println(a.getAuthor());<br/>}</span></pre><p id="7a1f" class="pw-post-body-paragraph lj lk iu ll b lm ln ke lo lp lq kh lr ls lt lu lv lw lx ly lz ma mb mc md me in bi translated">在上面的代码中，只有当<code class="fe nx ny nz oa b">obj</code>的类型为<code class="fe nx ny nz oa b">Article</code>时，实例<code class="fe nx ny nz oa b">a</code>才会被赋值。变量的范围仅限于条件块。</p></div><div class="ab cl mt mu hy mv" role="separator"><span class="mw bw bk mx my mz"/><span class="mw bw bk mx my mz"/><span class="mw bw bk mx my"/></div><div class="in io ip iq ir"><h1 id="9e0d" class="na nb iu bd nc nd ne nf ng nh ni nj nk kj nl kk nm km nn kn no kp np kq nq nr bi translated">3.有用的NullPointerExceptions</h1><p id="3c5c" class="pw-post-body-paragraph lj lk iu ll b lm ns ke lo lp nt kh lr ls ol lu lv lw om ly lz ma on mc md me in bi translated">空指针异常对于任何开发人员来说都是一场噩梦。以前，直到Java 13，调试声名狼藉的npe都很棘手。</p><p id="9592" class="pw-post-body-paragraph lj lk iu ll b lm ln ke lo lp lq kh lr ls lt lu lv lw lx ly lz ma mb mc md me in bi translated">开发人员不得不求助于其他调试工具，或者手动确定为空的变量/方法，因为堆栈跟踪只会显示行号。</p><h2 id="061f" class="of nb iu bd nc op oq dn ng or os dp nk ls ot ou nm lw ov ow no ma ox oy nq ja bi translated">Java 14之前:</h2><pre class="kt ku kv kw gu ob oa oc od aw oe bi"><span id="b684" class="of nb iu oa b gz og oh l oi oj">String name = a.getBlog().getAuthor()</span><span id="05e6" class="of nb iu oa b gz ok oh l oi oj">//Stacktrace <br/>Exception in thread "main" <!-- -->java.lang.NullPointerException<!-- --> at NullPointerExample.main(NullPointerExample.java:5)</span></pre><p id="ac95" class="pw-post-body-paragraph lj lk iu ll b lm ln ke lo lp lq kh lr ls lt lu lv lw lx ly lz ma mb mc md me in bi translated">Java 14引入了一个新的JVM特性，它通过一个更具描述性的堆栈提供了更好的洞察力，如下所示:</p><pre class="kt ku kv kw gu ob oa oc od aw oe bi"><span id="6e77" class="of nb iu oa b gz og oh l oi oj">Exception in thread "main" <br/>java.lang.NullPointerException: Cannot invoke "Blog.getAuthor()" because the return value of "Article.getBlog()" is null at NullPointerExample.main(NullPointerExample.java:4)</span></pre><p id="c4d8" class="pw-post-body-paragraph lj lk iu ll b lm ln ke lo lp lq kh lr ls lt lu lv lw lx ly lz ma mb mc md me in bi translated"><strong class="ll je">注意</strong>:以上特征不是语言特征。这是运行时环境的增强。</p></div><div class="ab cl mt mu hy mv" role="separator"><span class="mw bw bk mx my mz"/><span class="mw bw bk mx my mz"/><span class="mw bw bk mx my"/></div><div class="in io ip iq ir"><h1 id="3239" class="na nb iu bd nc nd ne nf ng nh ni nj nk kj nl kk nm km nn kn no kp np kq nq nr bi translated">4.记录(预览)</h1><p id="f7ab" class="pw-post-body-paragraph lj lk iu ll b lm ns ke lo lp nt kh lr ls ol lu lv lw om ly lz ma on mc md me in bi translated">记录是存储纯数据的数据类。引入记录背后的想法是快速创建没有样板代码的简单明了的类。</p><p id="2ac4" class="pw-post-body-paragraph lj lk iu ll b lm ln ke lo lp lq kh lr ls lt lu lv lw lx ly lz ma mb mc md me in bi translated">通常Java中的类需要你实现<code class="fe nx ny nz oa b">equals()</code>、<code class="fe nx ny nz oa b">hashCode()</code>、getters和setters方法。虽然有些ide支持自动生成这样的类，但是代码仍然很冗长。对于一个<code class="fe nx ny nz oa b">record</code>，你需要简单地用下面的方法定义一个类。</p><pre class="kt ku kv kw gu ob oa oc od aw oe bi"><span id="b069" class="of nb iu oa b gz og oh l oi oj">record Author(){}</span><span id="cd37" class="of nb iu oa b gz ok oh l oi oj">//or</span><span id="5787" class="of nb iu oa b gz ok oh l oi oj">record Author (String name, String topic) {}</span></pre><p id="faea" class="pw-post-body-paragraph lj lk iu ll b lm ln ke lo lp lq kh lr ls lt lu lv lw lx ly lz ma mb mc md me in bi translated">Java编译器会自动生成一个构造函数、私有final字段、访问器、<code class="fe nx ny nz oa b">equals</code> / <code class="fe nx ny nz oa b">hashCode</code>和<code class="fe nx ny nz oa b">toString</code>方法。上面类的自动生成的getter方法是<code class="fe nx ny nz oa b">name()</code>和<code class="fe nx ny nz oa b">topic()</code>。</p><p id="ad8f" class="pw-post-body-paragraph lj lk iu ll b lm ln ke lo lp lq kh lr ls lt lu lv lw lx ly lz ma mb mc md me in bi translated">要查看生成的代码，在使用<code class="fe nx ny nz oa b">javac</code>编译完程序后，使用<code class="fe nx ny nz oa b">javap Author</code>。下图显示了为<code class="fe nx ny nz oa b">record Author (String name, String topic) {}</code>生成的类:</p><figure class="kt ku kv kw gu kx gi gj paragraph-image"><div class="gi gj oz"><img src="../Images/f59126ea266704cb025c56d68efbf36c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1098/format:webp/0*H_GRj4TWhBmSJZLd.png"/></div></figure><p id="de59" class="pw-post-body-paragraph lj lk iu ll b lm ln ke lo lp lq kh lr ls lt lu lv lw lx ly lz ma mb mc md me in bi translated">记录的语义类似于Kotlin 中的<a class="ae li" href="https://www.journaldev.com/18594/kotlin-data-class" rel="noopener ugc nofollow" target="_blank">数据类。</a></p><p id="5768" class="pw-post-body-paragraph lj lk iu ll b lm ln ke lo lp lq kh lr ls lt lu lv lw lx ly lz ma mb mc md me in bi translated">此外，我们可以通过以下方式向记录添加额外的字段、方法和构造函数:</p><figure class="kt ku kv kw gu kx"><div class="bz fq l di"><div class="pa pb l"/></div></figure><p id="82b0" class="pw-post-body-paragraph lj lk iu ll b lm ln ke lo lp lq kh lr ls lt lu lv lw lx ly lz ma mb mc md me in bi translated">记录中定义的额外构造函数称为<em class="pc">紧凑构造函数</em>。它不包含任何参数，只是规范构造函数的扩展。</p><p id="07bb" class="pw-post-body-paragraph lj lk iu ll b lm ln ke lo lp lq kh lr ls lt lu lv lw lx ly lz ma mb mc md me in bi translated">编译器不会将紧凑构造函数生成为单独的构造函数。相反，它用于验证案例，并将在主构造函数开始时被调用。</p><p id="6790" class="pw-post-body-paragraph lj lk iu ll b lm ln ke lo lp lq kh lr ls lt lu lv lw lx ly lz ma mb mc md me in bi translated">关于记录，需要注意一些重要的事情:</p><ul class=""><li id="49be" class="mf mg iu ll b lm ln lp lq ls mh lw mi ma mj me mk ml mm mn bi translated">一个记录既不能扩展一个类，也不能被另一个类扩展。这是最后一门课。</li><li id="1fd6" class="mf mg iu ll b lm mo lp mp ls mq lw mr ma ms me mk ml mm mn bi translated">记录不能是抽象的。</li><li id="f0dc" class="mf mg iu ll b lm mo lp mp ls mq lw mr ma ms me mk ml mm mn bi translated">记录不能扩展任何其他类，也不能在主体内定义实例字段。实例字段只能在状态描述中定义。</li><li id="0f77" class="mf mg iu ll b lm mo lp mp ls mq lw mr ma ms me mk ml mm mn bi translated">声明的字段是私有的和最终的。</li><li id="acda" class="mf mg iu ll b lm mo lp mp ls mq lw mr ma ms me mk ml mm mn bi translated">记录的主体允许静态字段和方法。</li></ul></div><div class="ab cl mt mu hy mv" role="separator"><span class="mw bw bk mx my mz"/><span class="mw bw bk mx my mz"/><span class="mw bw bk mx my"/></div><div class="in io ip iq ir"><h2 id="4a1d" class="of nb iu bd nc op oq dn ng or os dp nk ls ot ou nm lw ov ow no ma ox oy nq ja bi translated">4.1记录的引用字段内的值可以变异</h2><p id="e81e" class="pw-post-body-paragraph lj lk iu ll b lm ns ke lo lp nt kh lr ls ol lu lv lw om ly lz ma on mc md me in bi translated">值得注意的是，对于定义为对象的字段，只有引用是不可变的。基础值可以修改。下图显示了ArrayList被修改的记录。如您所见，每当ArrayList发生变化时，该值都会被修改。</p><figure class="kt ku kv kw gu kx gi gj paragraph-image"><div class="gi gj pd"><img src="../Images/023690789fba6288d61cb6cfbc67d999.png" data-original-src="https://miro.medium.com/v2/resize:fit:1314/format:webp/0*RbRIBWzcAJ1lvzlf.png"/></div></figure></div><div class="ab cl mt mu hy mv" role="separator"><span class="mw bw bk mx my mz"/><span class="mw bw bk mx my mz"/><span class="mw bw bk mx my"/></div><div class="in io ip iq ir"><h2 id="654a" class="of nb iu bd nc op oq dn ng or os dp nk ls ot ou nm lw ov ow no ma ox oy nq ja bi translated">4.2记录可以实现接口</h2><p id="6787" class="pw-post-body-paragraph lj lk iu ll b lm ns ke lo lp nt kh lr ls ol lu lv lw om ly lz ma on mc md me in bi translated">以下代码显示了一个用记录实现<a class="ae li" href="https://www.journaldev.com/1601/interface-in-java" rel="noopener ugc nofollow" target="_blank">接口</a>的示例:</p><pre class="kt ku kv kw gu ob oa oc od aw oe bi"><span id="8216" class="of nb iu oa b gz og oh l oi oj">record Author(String name, String topic) implements Information {<br/>  public String getFullName() {<br/>    return "Author "+ name + " writes on " + topic;<br/>  }<br/>}<br/> <br/>interface Information {<br/>  String getFullName();<br/>}</span></pre><p id="0746" class="pw-post-body-paragraph lj lk iu ll b lm ln ke lo lp lq kh lr ls lt lu lv lw lx ly lz ma mb mc md me in bi translated">下面是上述代码在JShell中的输出:</p><figure class="kt ku kv kw gu kx gi gj paragraph-image"><div role="button" tabindex="0" class="ky kz di la bf lb"><div class="gi gj pe"><img src="../Images/10342aa2e04dbe92b4ee0424da90e641.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*W8ny3xc6lCR9ggdA.png"/></div></div></figure></div><div class="ab cl mt mu hy mv" role="separator"><span class="mw bw bk mx my mz"/><span class="mw bw bk mx my mz"/><span class="mw bw bk mx my"/></div><div class="in io ip iq ir"><h2 id="af4b" class="of nb iu bd nc op oq dn ng or os dp nk ls ot ou nm lw ov ow no ma ox oy nq ja bi translated">4.3记录支持多个构造函数</h2><p id="2902" class="pw-post-body-paragraph lj lk iu ll b lm ns ke lo lp nt kh lr ls ol lu lv lw om ly lz ma on mc md me in bi translated">记录允许声明多个带参数或不带参数的构造函数，如下所示:</p><pre class="kt ku kv kw gu ob oa oc od aw oe bi"><span id="bf94" class="of nb iu oa b gz og oh l oi oj">record Author(String name, String topic) {<br/>  public Author() {<br/> <br/>    this("NA", "NA");<br/>  }<br/> <br/>  public Author(String name) {<br/> <br/>    this(name, "NA");<br/>  }<br/>}</span></pre></div><div class="ab cl mt mu hy mv" role="separator"><span class="mw bw bk mx my mz"/><span class="mw bw bk mx my mz"/><span class="mw bw bk mx my"/></div><div class="in io ip iq ir"><h2 id="af08" class="of nb iu bd nc op oq dn ng or os dp nk ls ot ou nm lw ov ow no ma ox oy nq ja bi translated">4.4记录允许修改访问器方法</h2><p id="8302" class="pw-post-body-paragraph lj lk iu ll b lm ns ke lo lp nt kh lr ls ol lu lv lw om ly lz ma on mc md me in bi translated">尽管记录确实为状态描述中定义的字段生成公共访问器方法，但它们也允许您在主体中重新定义访问器方法，如下所示:</p><pre class="kt ku kv kw gu ob oa oc od aw oe bi"><span id="ab73" class="of nb iu oa b gz og oh l oi oj">record Author(String name, String topic) {<br/>  public String name() {<br/>        return "This article was written by " + this.name;<br/>    }<br/>}</span></pre></div><div class="ab cl mt mu hy mv" role="separator"><span class="mw bw bk mx my mz"/><span class="mw bw bk mx my mz"/><span class="mw bw bk mx my"/></div><div class="in io ip iq ir"><h2 id="d667" class="of nb iu bd nc op oq dn ng or os dp nk ls ot ou nm lw ov ow no ma ox oy nq ja bi translated">4.5运行时检查记录及其组件</h2><p id="20b8" class="pw-post-body-paragraph lj lk iu ll b lm ns ke lo lp nt kh lr ls ol lu lv lw om ly lz ma on mc md me in bi translated">记录为我们提供了<code class="fe nx ny nz oa b">isRecord()</code>和<code class="fe nx ny nz oa b">getRecordComponents()</code>来检查这个类是否是一个记录，并查看它的字段和类型。下图显示了这是如何做到的:</p><figure class="kt ku kv kw gu kx gi gj paragraph-image"><div class="gi gj pf"><img src="../Images/3e6642e4b30ddaad4b356b4263f8ac62.png" data-original-src="https://miro.medium.com/v2/resize:fit:1260/format:webp/0*tKlnk2ounUgzR02Z.png"/></div></figure><p id="8297" class="pw-post-body-paragraph lj lk iu ll b lm ln ke lo lp lq kh lr ls lt lu lv lw lx ly lz ma mb mc md me in bi translated">虽然我们在上面的代码示例中向记录添加了额外的字段和方法，但是请确保不要做得太多。记录被设计成普通的数据载体，如果你想实现更多的方法，最好回到普通的类。</p></div><div class="ab cl mt mu hy mv" role="separator"><span class="mw bw bk mx my mz"/><span class="mw bw bk mx my mz"/><span class="mw bw bk mx my"/></div><div class="in io ip iq ir"><h1 id="2065" class="na nb iu bd nc nd ne nf ng nh ni nj nk kj nl kk nm km nn kn no kp np kq nq nr bi translated">5.文本块(预览)</h1><p id="9a12" class="pw-post-body-paragraph lj lk iu ll b lm ns ke lo lp nt kh lr ls ol lu lv lw om ly lz ma on mc md me in bi translated">文本块是作为Java 13中的一个预览特性引入的，目的是允许轻松创建多行字符串文字。它有助于轻松创建HTML和JSON或SQL查询字符串。</p><p id="8292" class="pw-post-body-paragraph lj lk iu ll b lm ln ke lo lp lq kh lr ls lt lu lv lw lx ly lz ma mb mc md me in bi translated">在Java 14中，文本块仍然在预览中，只是增加了一些新的内容。我们现在可以使用:</p><ul class=""><li id="e64c" class="mf mg iu ll b lm ln lp lq ls mh lw mi ma mj me mk ml mm mn bi translated">反斜杠用于显示好看的多行字符串块。</li><li id="a88e" class="mf mg iu ll b lm mo lp mp ls mq lw mr ma ms me mk ml mm mn bi translated"><code class="fe nx ny nz oa b">\s</code>用于考虑尾随空格，默认情况下编译器会忽略这些空格。它保留了它前面的所有空间。</li></ul><pre class="kt ku kv kw gu ob oa oc od aw oe bi"><span id="0732" class="of nb iu oa b gz og oh l oi oj">String text = """<br/>                Did you know \<br/>                Java 14 \<br/>                has the most features among\<br/>                all non-LTS versions so far\<br/>                """;<br/> <br/>String text2 = """<br/>                line1<br/>                line2 \s<br/>                line3<br/>                """;<br/> <br/> <br/>String text3 = "line1\nline2 \nline3\n"<br/> <br/>//text2 and text3 are equal.</span></pre></div><div class="ab cl mt mu hy mv" role="separator"><span class="mw bw bk mx my mz"/><span class="mw bw bk mx my mz"/><span class="mw bw bk mx my"/></div><div class="in io ip iq ir"><h1 id="36ec" class="na nb iu bd nc nd ne nf ng nh ni nj nk kj nl kk nm km nn kn no kp np kq nq nr bi translated">结论</h1><p id="6cbe" class="pw-post-body-paragraph lj lk iu ll b lm ns ke lo lp nt kh lr ls ol lu lv lw om ly lz ma on mc md me in bi translated">Java 14主要关注减少样板代码和改进模式匹配——通过增强开关表达式和<code class="fe nx ny nz oa b">instanceof</code>操作符。</p><p id="721d" class="pw-post-body-paragraph lj lk iu ll b lm ln ke lo lp lq kh lr ls lt lu lv lw lx ly lz ma mb mc md me in bi translated">尽管preview中有许多语言特性，但Java开发人员可以希望从这里开始，在可读性、冗长性和开发速度方面，事情只会变得更容易。</p><p id="466e" class="pw-post-body-paragraph lj lk iu ll b lm ln ke lo lp lq kh lr ls lt lu lv lw lx ly lz ma mb mc md me in bi translated">这一篇就到此为止——感谢阅读。</p></div><div class="ab cl mt mu hy mv" role="separator"><span class="mw bw bk mx my mz"/><span class="mw bw bk mx my mz"/><span class="mw bw bk mx my"/></div><div class="in io ip iq ir"><p id="8d15" class="pw-post-body-paragraph lj lk iu ll b lm ln ke lo lp lq kh lr ls lt lu lv lw lx ly lz ma mb mc md me in bi translated">【https://www.journaldev.com】最初发表于<a class="ae li" href="https://www.journaldev.com/37273/java-14-features" rel="noopener ugc nofollow" target="_blank"><em class="pc"/></a><em class="pc">。</em></p></div></div>    
</body>
</html>