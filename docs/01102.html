<html>
<head>
<title>How to Get Data From Telegram Using Python</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何使用Python从电报中获取数据</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/how-to-get-data-from-telegram-82af55268a4b?source=collection_archive---------0-----------------------#2019-08-14">https://betterprogramming.pub/how-to-get-data-from-telegram-82af55268a4b?source=collection_archive---------0-----------------------#2019-08-14</a></blockquote><div><div class="fc ii ij ik il im"/><div class="in io ip iq ir"><div class=""/><div class=""><h2 id="b391" class="pw-subtitle-paragraph jr it iu bd b js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki dk translated">关于获取电报通道消息和成员列表的Python教程</h2></div><figure class="kk kl km kn gu ko gi gj paragraph-image"><div role="button" tabindex="0" class="kp kq di kr bf ks"><div class="gi gj kj"><img src="../Images/493711b800ef91cb585a5eb8ad8acdab.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*38Jr_V7SkhYeT1uyLgEwWw.jpeg"/></div></div></figure><blockquote class="kv kw kx"><p id="253c" class="ky kz la lb b lc ld jv le lf lg jy lh li lj lk ll lm ln lo lp lq lr ls lt lu in bi translated">2021年10月更新:<br/>确保从GitHub repositry获得最新的源代码。<br/>你也可以观看如何使用这个脚本的视频教程。</p></blockquote><figure class="kk kl km kn gu ko"><div class="bz fq l di"><div class="lv lw l"/></div></figure><p id="9bbc" class="pw-post-body-paragraph ky kz iu lb b lc ld jv le lf lg jy lh lx lj lk ll ly ln lo lp lz lr ls lt lu in bi translated">出于研究目的，以及为了分析电报通道的内容，您可能需要一个干净的JSON格式的通道数据。</p><p id="6b2b" class="pw-post-body-paragraph ky kz iu lb b lc ld jv le lf lg jy lh lx lj lk ll ly ln lo lp lz lr ls lt lu in bi translated">我创建了一个Python脚本来从电报通道获取数据。它有两个主要文件:一个用于从通道获取成员数据，另一个用于获取通道的消息。</p><p id="b0e0" class="pw-post-body-paragraph ky kz iu lb b lc ld jv le lf lg jy lh lx lj lk ll ly ln lo lp lz lr ls lt lu in bi translated">这个脚本将这些数据保存到JSON文件中；您可以使用它们进行分析或导入到您的数据库中。</p><h1 id="06fc" class="ma mb iu bd mc md me mf mg mh mi mj mk ka ml kb mm kd mn ke mo kg mp kh mq mr bi translated">要求</h1><p id="14ba" class="pw-post-body-paragraph ky kz iu lb b lc ms jv le lf mt jy lh lx mu lk ll ly mv lo lp lz mw ls lt lu in bi translated">您需要安装Python 3。还有，我用了<code class="fe mx my mz na b">telethon</code>，一个Python包来处理Telegram。</p><p id="080a" class="pw-post-body-paragraph ky kz iu lb b lc ld jv le lf lg jy lh lx lj lk ll ly ln lo lp lz lr ls lt lu in bi translated">要安装<code class="fe mx my mz na b">telethon</code>，你需要使用一个<code class="fe mx my mz na b">pip</code>命令:</p><pre class="kk kl km kn gu nb na nc nd aw ne bi"><span id="9d77" class="nf mb iu na b gz ng nh l ni nj">pip3 install telethon</span></pre><p id="39b0" class="pw-post-body-paragraph ky kz iu lb b lc ld jv le lf lg jy lh lx lj lk ll ly ln lo lp lz lr ls lt lu in bi translated">你可以阅读<a class="ae nk" href="https://docs.telethon.dev/en/latest/" rel="noopener ugc nofollow" target="_blank"> Telethon的文档</a>来了解这个包的全部功能。</p><h1 id="1039" class="ma mb iu bd mc md me mf mg mh mi mj mk ka ml kb mm kd mn ke mo kg mp kh mq mr bi translated">获取您的Telegram API证书</h1><p id="312f" class="pw-post-body-paragraph ky kz iu lb b lc ms jv le lf mt jy lh lx mu lk ll ly mv lo lp lz mw ls lt lu in bi translated">为了连接电报，我们需要一个<code class="fe mx my mz na b">api_id</code>和一个<code class="fe mx my mz na b">api_hash</code>。要获得这些参数，您需要登录到您的<a class="ae nk" href="https://my.telegram.org" rel="noopener ugc nofollow" target="_blank">电报核心</a>并进入<a class="ae nk" href="https://my.telegram.org/apps" rel="noopener ugc nofollow" target="_blank"> API开发工具</a>区域。有一个表格你需要填，填完之后你就可以领取你的<code class="fe mx my mz na b">api_id</code>和<code class="fe mx my mz na b">api_hash</code>。</p><p id="c06e" class="pw-post-body-paragraph ky kz iu lb b lc ld jv le lf lg jy lh lx lj lk ll ly ln lo lp lz lr ls lt lu in bi translated">这是Telegram的帮助文档，关于如何获得你的API证书。</p><h1 id="5b52" class="ma mb iu bd mc md me mf mg mh mi mj mk ka ml kb mm kd mn ke mo kg mp kh mq mr bi translated">在Python脚本中创建一个电报客户端</h1><p id="e518" class="pw-post-body-paragraph ky kz iu lb b lc ms jv le lf mt jy lh lx mu lk ll ly mv lo lp lz mw ls lt lu in bi translated">这一部分对于获取渠道成员和渠道消息来说是非常相似的。首先，我们需要基本的进口商品:</p><figure class="kk kl km kn gu ko"><div class="bz fq l di"><div class="nl lw l"/></div></figure><p id="2b59" class="pw-post-body-paragraph ky kz iu lb b lc ld jv le lf lg jy lh lx lj lk ll ly ln lo lp lz lr ls lt lu in bi translated">我使用<code class="fe mx my mz na b">configparser</code>从配置文件中读取API凭证，使用<code class="fe mx my mz na b">package.json</code>将数据转储到JSON格式的文件中。</p><p id="8b4c" class="pw-post-body-paragraph ky kz iu lb b lc ld jv le lf lg jy lh lx lj lk ll ly ln lo lp lz lr ls lt lu in bi translated">我们从Telethon导入我们需要的东西，在我们的脚本中创建一个电报客户端。</p><p id="19fb" class="pw-post-body-paragraph ky kz iu lb b lc ld jv le lf lg jy lh lx lj lk ll ly ln lo lp lz lr ls lt lu in bi translated">如您所知，将您的Telegram API凭证存储在您的源代码中是不安全的。如果您将任何类型的凭证直接放入您的源代码，您就在拿您自己的安全和使用该代码的任何人的安全冒险，因为您误导了任何想要使用您的代码的人。</p><p id="c737" class="pw-post-body-paragraph ky kz iu lb b lc ld jv le lf lg jy lh lx lj lk ll ly ln lo lp lz lr ls lt lu in bi translated">因此，为了避免安全问题，我们将API凭证放在另一个名为<code class="fe mx my mz na b">config.ini</code>的文件中。它有这样一个简单的结构:</p><figure class="kk kl km kn gu ko"><div class="bz fq l di"><div class="nl lw l"/></div></figure><p id="15c8" class="pw-post-body-paragraph ky kz iu lb b lc ld jv le lf lg jy lh lx lj lk ll ly ln lo lp lz lr ls lt lu in bi translated">现在，为了在我们的Python脚本中创建一个电报客户端，首先，我们在代码中读取这些凭证:</p><figure class="kk kl km kn gu ko"><div class="bz fq l di"><div class="nl lw l"/></div></figure><p id="9457" class="pw-post-body-paragraph ky kz iu lb b lc ld jv le lf lg jy lh lx lj lk ll ly ln lo lp lz lr ls lt lu in bi translated">现在我们已经拥有了所需的一切，我们尝试登录Telegram并创建一个客户端对象来获取数据:</p><figure class="kk kl km kn gu ko"><div class="bz fq l di"><div class="nl lw l"/></div></figure><p id="6146" class="pw-post-body-paragraph ky kz iu lb b lc ld jv le lf lg jy lh lx lj lk ll ly ln lo lp lz lr ls lt lu in bi translated">Telegram会授权您的凭证，然后要求您提供验证码和密码(如果您为电报设置了任何验证码和密码的话)。这就像你在应用程序或在线登录你的Telegram帐户一样。</p><p id="2895" class="pw-post-body-paragraph ky kz iu lb b lc ld jv le lf lg jy lh lx lj lk ll ly ln lo lp lz lr ls lt lu in bi translated">请注意，当这个脚本运行时，它可以访问您的电报帐户。确保在安全的环境中运行脚本。</p><p id="91aa" class="pw-post-body-paragraph ky kz iu lb b lc ld jv le lf lg jy lh lx lj lk ll ly ln lo lp lz lr ls lt lu in bi translated">我们现在已经准备好了<code class="fe mx my mz na b">client</code>对象，我们可以使用这个对象来连接和与Telegram对话。</p><h1 id="100c" class="ma mb iu bd mc md me mf mg mh mi mj mk ka ml kb mm kd mn ke mo kg mp kh mq mr bi translated">获取渠道成员</h1><p id="5e87" class="pw-post-body-paragraph ky kz iu lb b lc ms jv le lf mt jy lh lx mu lk ll ly mv lo lp lz mw ls lt lu in bi translated">我们将分两步进行。首先，我们从Telegram获取所有渠道成员数据，然后将这些数据保存到一个JSON文件中。</p><p id="d971" class="pw-post-body-paragraph ky kz iu lb b lc ld jv le lf lg jy lh lx lj lk ll ly ln lo lp lz lr ls lt lu in bi translated">在这些步骤之前，记得在脚本头中再添加三个导入:</p><pre class="kk kl km kn gu nb na nc nd aw ne bi"><span id="e91c" class="nf mb iu na b gz ng nh l ni nj">from telethon.tl.functions.channels import GetParticipantsRequest<br/>from telethon.tl.types import ChannelParticipantsSearch<br/>from telethon.tl.types import (<br/>PeerChannel<br/>)</span></pre><h2 id="c0f9" class="nf mb iu bd mc nm nn dn mg no np dp mk lx nq nr mm ly ns nt mo lz nu nv mq nw bi translated">从电报请求频道成员</h2><p id="8c19" class="pw-post-body-paragraph ky kz iu lb b lc ms jv le lf mt jy lh lx mu lk ll ly mv lo lp lz mw ls lt lu in bi translated">首先，我们向用户请求一个电报通道。您可以给脚本一个频道的URL，或者频道的唯一ID。</p><p id="d3a4" class="pw-post-body-paragraph ky kz iu lb b lc ld jv le lf lg jy lh lx lj lk ll ly ln lo lp lz lr ls lt lu in bi translated">因此，<a class="ae nk" href="https://github.com/amiryousefi/telegram-analysis/blob/d682a38d3a264cfd11dfaeccebef3f58c1450401/ChannelUsers.py#L39" rel="noopener ugc nofollow" target="_blank">我们获取用户输入</a>并将其转换为电报通道:</p><figure class="kk kl km kn gu ko"><div class="bz fq l di"><div class="nl lw l"/></div></figure><p id="da02" class="pw-post-body-paragraph ky kz iu lb b lc ld jv le lf lg jy lh lx lj lk ll ly ln lo lp lz lr ls lt lu in bi translated">如果用户给我们一个通道ID，我们可以将其转换为PeerChannel对象。如果用户给我们一个电报频道网址(如https://t.me/channel)，我们可以直接使用。</p><p id="a3cf" class="pw-post-body-paragraph ky kz iu lb b lc ld jv le lf lg jy lh lx lj lk ll ly ln lo lp lz lr ls lt lu in bi translated">下一步是<a class="ae nk" href="https://github.com/amiryousefi/telegram-analysis/blob/d682a38d3a264cfd11dfaeccebef3f58c1450401/ChannelUsers.py#L52" rel="noopener ugc nofollow" target="_blank">获取渠道成员</a>。首先，你需要知道Telegram并不回应你所请求的全部数据，而是分批给出数据。我们可以在每个请求中获得100个成员。</p><figure class="kk kl km kn gu ko"><div class="bz fq l di"><div class="nl lw l"/></div></figure><p id="0f08" class="pw-post-body-paragraph ky kz iu lb b lc ld jv le lf lg jy lh lx lj lk ll ly ln lo lp lz lr ls lt lu in bi translated">我们从偏移量0开始设置一个100的限制，并创建一个包含通道成员的列表。在一个无限循环中，我们创建了一个对象<code class="fe mx my mz na b">GetParticipantsRequest</code>，它在通道的成员列表中搜索空字符串，并为我们带来所有用户。正如我提到的，我们只能在每个请求中获得100个成员。获得成员后，我们检查<code class="fe mx my mz na b">participants</code>对象是否有<code class="fe mx my mz na b">users</code>属性。如果它没有<code class="fe mx my mz na b">users</code>，那就意味着我们得到了所有用户，所以我们打破了无限循环。如果它有<code class="fe mx my mz na b">users</code>，我们向所有成员列表添加新成员，并向偏移量添加收到的成员列表长度，因此下一个请求要求用户从这个偏移量开始。</p><p id="aa68" class="pw-post-body-paragraph ky kz iu lb b lc ld jv le lf lg jy lh lx lj lk ll ly ln lo lp lz lr ls lt lu in bi translated">这个循环继续下去，直到它获得通道的所有成员。</p><h2 id="edb0" class="nf mb iu bd mc nm nn dn mg no np dp mk lx nq nr mm ly ns nt mo lz nu nv mq nw bi translated">将数据存储在JSON文件中</h2><p id="1686" class="pw-post-body-paragraph ky kz iu lb b lc ms jv le lf mt jy lh lx mu lk ll ly mv lo lp lz mw ls lt lu in bi translated">这是容易的部分。虽然可以把数据保存到任何数据库，比如MySQL，MongoDB等。，最简单的方法是将数据存储在一个JSON文件中。但是，如果您有大量数据，最好考虑将其存储在数据库中。</p><p id="34ba" class="pw-post-body-paragraph ky kz iu lb b lc ld jv le lf lg jy lh lx lj lk ll ly ln lo lp lz lr ls lt lu in bi translated">您可以将成员的整个对象存储在JSON文件中，但是我更喜欢只存储我需要的内容。因此，我创建了一个列表来添加成员数据，然后将这个列表的JSON转储写到一个文件中</p><figure class="kk kl km kn gu ko"><div class="bz fq l di"><div class="nl lw l"/></div></figure><p id="702b" class="pw-post-body-paragraph ky kz iu lb b lc ld jv le lf lg jy lh lx lj lk ll ly ln lo lp lz lr ls lt lu in bi translated">简单易行:我创建了一个成员数据的字典，并将它添加到列表中。之后，我将JSON转储写到文件中。</p><p id="e812" class="pw-post-body-paragraph ky kz iu lb b lc ld jv le lf lg jy lh lx lj lk ll ly ln lo lp lz lr ls lt lu in bi translated">下面是获取电报通道成员的完整代码:</p><div class="nx ny gq gs nz oa"><a href="https://github.com/amiryousefi/telegram-analysis/blob/master/ChannelUsers.py" rel="noopener  ugc nofollow" target="_blank"><div class="ob ab fp"><div class="oc ab od cl cj oe"><h2 class="bd iv gz z fq of fs ft og fv fx it bi translated">amiryusefi/电报分析</h2><div class="oh l"><h3 class="bd b gz z fq of fs ft og fv fx dk translated">此时您不能执行该操作。您已使用另一个标签页或窗口登录。您已在另一个选项卡中注销，或者…</h3></div><div class="oi l"><p class="bd b dl z fq of fs ft og fv fx dk translated">github.com</p></div></div></div></a></div></div><div class="ab cl oj ok hy ol" role="separator"><span class="om bw bk on oo op"/><span class="om bw bk on oo op"/><span class="om bw bk on oo"/></div><div class="in io ip iq ir"><h1 id="b961" class="ma mb iu bd mc md oq mf mg mh or mj mk ka os kb mm kd ot ke mo kg ou kh mq mr bi translated">获取频道消息</h1><p id="e58d" class="pw-post-body-paragraph ky kz iu lb b lc ms jv le lf mt jy lh lx mu lk ll ly mv lo lp lz mw ls lt lu in bi translated">在开始这一步之前，您需要将这些导入添加到脚本的头部:</p><pre class="kk kl km kn gu nb na nc nd aw ne bi"><span id="822e" class="nf mb iu na b gz ng nh l ni nj">from telethon.tl.functions.messages import (GetHistoryRequest)<br/>from telethon.tl.types import (<br/>PeerChannel<br/>)</span></pre><p id="f536" class="pw-post-body-paragraph ky kz iu lb b lc ld jv le lf lg jy lh lx lj lk ll ly ln lo lp lz lr ls lt lu in bi translated">编辑完导入后，在Python代码中创建一个电报客户端与上一节完全相同。此外，从用户处获取频道ID或URL与上一节中解释的相同。所以，我假设您已经准备好了一份电报<code class="fe mx my mz na b">client</code>，并且已经创建了一个通道对象，我称之为<code class="fe mx my mz na b">my_channel</code>:</p><figure class="kk kl km kn gu ko"><div class="bz fq l di"><div class="nl lw l"/></div></figure><p id="06c1" class="pw-post-body-paragraph ky kz iu lb b lc ld jv le lf lg jy lh lx lj lk ll ly ln lo lp lz lr ls lt lu in bi translated">向电报客户端发送一个<code class="fe mx my mz na b">GetHistoryRequest</code>对象将返回一个包含消息列表的历史对象。同样，我们对每个请求有100条消息的限制。因此，我们在一个无限循环中循环这个请求。在每个请求之后，我们检查历史对象是否有messages属性。如果没有，那么我们已经到达了通道中消息的末尾，因此我们可以跳出循环。</p><p id="49f6" class="pw-post-body-paragraph ky kz iu lb b lc ld jv le lf lg jy lh lx lj lk ll ly ln lo lp lz lr ls lt lu in bi translated">我还加了一个<code class="fe mx my mz na b">total_count_limit</code>变量。您可能不想要所有消息，或者获取所有消息可能需要太多时间，因此您可以设置想要从频道获取多少消息。如果将此项设置为0，脚本将从通道中获取所有消息。</p><p id="61d8" class="pw-post-body-paragraph ky kz iu lb b lc ld jv le lf lg jy lh lx lj lk ll ly ln lo lp lz lr ls lt lu in bi translated">这次设置偏移有点棘手。<code class="fe mx my mz na b">GetHistoryRequest</code>接收到一个<code class="fe mx my mz na b">offset_id</code>，这意味着它应该从什么消息开始获取历史。您需要在每次收到邮件列表时将偏移量设置为最后一个邮件ID:</p><pre class="kk kl km kn gu nb na nc nd aw ne bi"><span id="c37c" class="nf mb iu na b gz ng nh l ni nj">offset_id = messages[len(messages) - 1].id</span></pre><p id="14bf" class="pw-post-body-paragraph ky kz iu lb b lc ld jv le lf lg jy lh lx lj lk ll ly ln lo lp lz lr ls lt lu in bi translated">要将消息保存为JSON数据，您需要将消息对象转换为字典。您可以使用<code class="fe mx my mz na b">to_dict</code>函数获取字典格式的消息对象:</p><pre class="kk kl km kn gu nb na nc nd aw ne bi"><span id="45e0" class="nf mb iu na b gz ng nh l ni nj">for message in messages:<br/>    all_messages.append(message.to_dict())</span></pre><p id="2bde" class="pw-post-body-paragraph ky kz iu lb b lc ld jv le lf lg jy lh lx lj lk ll ly ln lo lp lz lr ls lt lu in bi translated">代码的最后两行，检查<code class="fe mx my mz na b">total_count_limit</code>是否设置为大于0。如果total messages received是我们需要的邮件总数，并且如果这两个条件都为真，则从循环中断开。</p><p id="faa0" class="pw-post-body-paragraph ky kz iu lb b lc ld jv le lf lg jy lh lx lj lk ll ly ln lo lp lz lr ls lt lu in bi translated">现在您已经有了所有的消息数据，您可以将这个列表存储到一个JSON文件中。正如我在上一节中解释的那样，这很简单。</p><p id="8db7" class="pw-post-body-paragraph ky kz iu lb b lc ld jv le lf lg jy lh lx lj lk ll ly ln lo lp lz lr ls lt lu in bi translated">在这里你可以看到完整的代码:</p><div class="nx ny gq gs nz oa"><a href="https://github.com/amiryousefi/telegram-analysis/blob/master/ChannelMessages.py" rel="noopener  ugc nofollow" target="_blank"><div class="ob ab fp"><div class="oc ab od cl cj oe"><h2 class="bd iv gz z fq of fs ft og fv fx it bi translated">amiryusefi/电报分析</h2><div class="oh l"><h3 class="bd b gz z fq of fs ft og fv fx dk translated">此时您不能执行该操作。您已使用另一个标签页或窗口登录。您已在另一个选项卡中注销，或者…</h3></div><div class="oi l"><p class="bd b dl z fq of fs ft og fv fx dk translated">github.com</p></div></div></div></a></div></div><div class="ab cl oj ok hy ol" role="separator"><span class="om bw bk on oo op"/><span class="om bw bk on oo op"/><span class="om bw bk on oo"/></div><div class="in io ip iq ir"><p id="c46b" class="pw-post-body-paragraph ky kz iu lb b lc ld jv le lf lg jy lh lx lj lk ll ly ln lo lp lz lr ls lt lu in bi translated">我分享了这个脚本的完整存储库。你可以看到完整的代码，并且可以自己修改这个库。此外，如果您发现我的源代码有任何改进，我将很乐意接受拉请求。</p><div class="nx ny gq gs nz oa"><a href="https://github.com/amiryousefi/telegram-analysis" rel="noopener  ugc nofollow" target="_blank"><div class="ob ab fp"><div class="oc ab od cl cj oe"><h2 class="bd iv gz z fq of fs ft og fv fx it bi translated">amiryusefi/电报分析</h2><div class="oh l"><h3 class="bd b gz z fq of fs ft og fv fx dk translated">此时您不能执行该操作。您已使用另一个标签页或窗口登录。您已在另一个选项卡中注销，或者…</h3></div><div class="oi l"><p class="bd b dl z fq of fs ft og fv fx dk translated">github.com</p></div></div><div class="ov l"><div class="ow l ox oy oz ov pa kt oa"/></div></div></a></div></div></div>    
</body>
</html>