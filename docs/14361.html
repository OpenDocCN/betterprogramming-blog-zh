<html>
<head>
<title>Building a Wrapping HStack With the SwiftUI Layout Protocol</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用SwiftUI布局协议构建包装HStack</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/building-a-wrapping-hstack-with-the-swiftui-layout-protocol-1e718239bf57?source=collection_archive---------2-----------------------#2022-12-03">https://betterprogramming.pub/building-a-wrapping-hstack-with-the-swiftui-layout-protocol-1e718239bf57?source=collection_archive---------2-----------------------#2022-12-03</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="0752" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">如何创建一个通用的SwiftUI容器，它允许显示一组标记，这些标记可以换行到后续的行中。</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi kf"><img src="../Images/36feeebc4f206b087c34955a93c4978e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1280/0*guVObhqCy__T55Ah.gif"/></div></figure><p id="eea3" class="pw-post-body-paragraph kn ko iq kp b kq kr jr ks kt ku ju kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">我们即将制作的组件以<a class="ae lj" href="https://github.com/ksemianov/WrappingHStack" rel="noopener ugc nofollow" target="_blank"> Swift包</a>的形式提供。</p><h1 id="9ca3" class="lk ll iq bd lm ln lo lp lq lr ls lt lu jw lv jx lw jz lx ka ly kc lz kd ma mb bi translated">介绍</h1><p id="6f2d" class="pw-post-body-paragraph kn ko iq kp b kq mc jr ks kt md ju kv kw me ky kz la mf lc ld le mg lg lh li ij bi translated">周一早上，您的项目经理给了您一项任务，向产品详细信息页面添加标签列表。你说“容易”,然后在10分钟内做出以下内容。</p><pre class="kg kh ki kj gt mh mi mj bn mk ml bi"><span id="a568" class="mm ll iq mi b be mn mo l mp mq">HStack {<br/>    ForEach(tags) {<br/>        TagView(text: $0.text)<br/>    }<br/><br/>    Spacer(minLength: .zero)<br/>}.padding(.horizontal)</span></pre><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="ms mt di mu bf mv"><div class="gh gi mr"><img src="../Images/6520006e2fca3478d10fb84af8dc3241.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*mHhwhH3jFU3m6FdP.png"/></div></div></figure><p id="9b92" class="pw-post-body-paragraph kn ko iq kp b kq kr jr ks kt ku ju kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">在QA团队查看之后，当有许多标签时，他们报告了一个bug。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="ms mt di mu bf mv"><div class="gh gi mr"><img src="../Images/383cd6bd2bc85c7edb7c26d9c5ad4c92.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*6zqm7jpPJlSIPgwZ.png"/></div></div></figure><p id="6477" class="pw-post-body-paragraph kn ko iq kp b kq kr jr ks kt ku ju kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">你可以让它水平滚动。</p><pre class="kg kh ki kj gt mh mi mj bn mk ml bi"><span id="9128" class="mm ll iq mi b be mn mo l mp mq">ScrollView(.horizontal, showsIndicators: false) {<br/>    LazyHStack {<br/>        ForEach(tags) {<br/>            TagView(text: $0.text)<br/>        }<br/>    }.padding(.horizontal)<br/>}.frame(height: 56)</span></pre><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="ms mt di mu bf mv"><div class="gh gi mr"><img src="../Images/6ded6c55a13e647cfdef9b556c536f3f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*wJQyj6CfVcZC15Na.png"/></div></div></figure><p id="56ab" class="pw-post-body-paragraph kn ko iq kp b kq kr jr ks kt ku ju kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">缺点是你必须事先知道标签视图的高度。</p><p id="d9c1" class="pw-post-body-paragraph kn ko iq kp b kq kr jr ks kt ku ju kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">当标签不适合视图宽度时，设计团队要求在后续行上换行。而现在你的“容易”变成了“难”。你的一位同事建议用一个<code class="fe mw mx my mi b">UIViewRepresentable</code>包装一个自定义的<code class="fe mw mx my mi b">UICollectionView</code>。另一个尝试新的<code class="fe mw mx my mi b">Layout</code>协议。你决定用<code class="fe mw mx my mi b">Layout</code>...</p><h1 id="6730" class="lk ll iq bd lm ln lo lp lq lr ls lt lu jw lv jx lw jz lx ka ly kc lz kd ma mb bi translated">布局协议</h1><p id="b783" class="pw-post-body-paragraph kn ko iq kp b kq mc jr ks kt md ju kv kw me ky kz la mf lc ld le mg lg lh li ij bi translated">该协议有两个要求:</p><ul class=""><li id="8326" class="mz na iq kp b kq kr kt ku kw nb la nc le nd li ne nf ng nh bi translated"><code class="fe mw mx my mi b">sizeThatFits</code>控制视图需要多少空间</li><li id="af13" class="mz na iq kp b kq ni kt nj kw nk la nl le nm li ne nf ng nh bi translated"><code class="fe mw mx my mi b">placeSubviews</code>控制可用空间中子视图的位置</li></ul><p id="cc1d" class="pw-post-body-paragraph kn ko iq kp b kq kr jr ks kt ku ju kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">注意，在布局过程中可能会多次调用<code class="fe mw mx my mi b">sizeThatFits</code>。它将尝试不同大小的建议。在编写本文时，在iOS上，它通常会尝试传递所有可用空间。在macOS上，它还会尝试一个<code class="fe mw mx my mi b">.zero</code>大小的建议，以便可以计算最小窗口大小。因此，为了支持macOS，我们需要计算视图的最小尺寸。</p><h1 id="ac2b" class="lk ll iq bd lm ln lo lp lq lr ls lt lu jw lv jx lw jz lx ka ly kc lz kd ma mb bi translated">进场大纲</h1><p id="148e" class="pw-post-body-paragraph kn ko iq kp b kq mc jr ks kt md ju kv kw me ky kz la mf lc ld le mg lg lh li ij bi translated">给定一个<code class="fe mw mx my mi b">.zero</code>提议，我们将最小尺寸作为子视图的最大尺寸。每当提案小于最小尺寸时，我们将提前返回最小尺寸。</p><pre class="kg kh ki kj gt mh mi mj bn mk ml bi"><span id="3cba" class="mm ll iq mi b be mn mo l mp mq">func minSize(subviews: Subviews) -&gt; CGSize {<br/>    subviews<br/>        .map { $0.sizeThatFits(.zero) }<br/>        .reduce(CGSize.zero) { CGSize(width: max($0.width, $1.width), height: max($0.height, $1.height)) }<br/>}</span></pre><p id="0f50" class="pw-post-body-paragraph kn ko iq kp b kq kr jr ks kt ku ju kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">为了计算尺寸和位置，我们需要首先将子视图排列成行。</p><p id="858c" class="pw-post-body-paragraph kn ko iq kp b kq kr jr ks kt ku ju kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">主要思想是迭代子视图，如果子视图的宽度+水平间距仍然适合容器的宽度，则增加X坐标，否则转到下一行。</p><p id="94b5" class="pw-post-body-paragraph kn ko iq kp b kq kr jr ks kt ku ju kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">这将允许我们获得所有子视图的X偏移量。然后，我们将迭代行，并通过最大高度子视图的高度+垂直间距来增加Y坐标。这将允许我们获得所有行的Y偏移量。</p><p id="c48b" class="pw-post-body-paragraph kn ko iq kp b kq kr jr ks kt ku ju kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">一旦我们有了行的排列，宽度将填满所有可用的空间。</p><pre class="kg kh ki kj gt mh mi mj bn mk ml bi"><span id="2f13" class="mm ll iq mi b be mn mo l mp mq">let width = proposal.width ?? rows.map { $0.width }.reduce(.zero) { max($0, $1) }</span></pre><p id="bc01" class="pw-post-body-paragraph kn ko iq kp b kq kr jr ks kt ku ju kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">高度将是最后一行的垂直偏移量+它的高度。</p><pre class="kg kh ki kj gt mh mi mj bn mk ml bi"><span id="1829" class="mm ll iq mi b be mn mo l mp mq">var height: CGFloat = .zero<br/>if let lastRow = rows.last {<br/>    height = lastRow.yOffset + lastRow.height<br/>}</span></pre><p id="667f" class="pw-post-body-paragraph kn ko iq kp b kq kr jr ks kt ku ju kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">子视图将被放置在它们相应的偏移+边界最小点上。</p><pre class="kg kh ki kj gt mh mi mj bn mk ml bi"><span id="d261" class="mm ll iq mi b be mn mo l mp mq">for row in rows {<br/>    for element in row.elements {<br/>        let x: CGFloat = element.xOffset<br/>        let y: CGFloat = row.yOffset<br/>        let point = CGPoint(x: x + bounds.minX, y: y + bounds.minY)<br/><br/>        subviews[element.index].place(at: point, anchor: .topLeading, proposal: proposal)<br/>    }<br/>}</span></pre><h1 id="eeac" class="lk ll iq bd lm ln lo lp lq lr ls lt lu jw lv jx lw jz lx ka ly kc lz kd ma mb bi translated">行排列</h1><p id="8b59" class="pw-post-body-paragraph kn ko iq kp b kq mc jr ks kt md ju kv kw me ky kz la mf lc ld le mg lg lh li ij bi translated">对于每一行，我们需要知道子视图的索引、大小和X偏移量。此外，整体行Y偏移，行宽度和高度。</p><pre class="kg kh ki kj gt mh mi mj bn mk ml bi"><span id="bbfd" class="mm ll iq mi b be mn mo l mp mq">struct Row {<br/>    var elements: [(index: Int, size: CGSize, xOffset: CGFloat)] = []<br/>    var yOffset: CGFloat = .zero<br/>    var width: CGFloat = .zero<br/>    var height: CGFloat = .zero<br/>}<br/><br/>func arrangeRows(proposal: ProposedViewSize,<br/>                 subviews: Subviews,<br/>                 cache: inout ()) -&gt; [Row] {<br/>    let minSize = minSize(subviews: subviews)<br/>    if minSize.width &gt; proposal.width ?? .infinity,<br/>       minSize.height &gt; proposal.height ?? .infinity {<br/>        return []<br/>    }<br/><br/>    let sizes = subviews.map { $0.sizeThatFits(proposal) }<br/><br/>    var currentX = CGFloat.zero<br/>    var currentRow = Row()<br/>    var rows = [Row]()<br/><br/>    for index in subviews.indices {<br/>        var spacing = CGFloat.zero<br/>        if let previousIndex = currentRow.elements.last?.index {<br/>            spacing = horizontalSpacing(subviews[previousIndex], subviews[index])<br/>        }<br/><br/>        let size = sizes[index]<br/><br/>        if currentX + size.width + spacing &gt; proposal.width ?? .infinity,<br/>           !currentRow.elements.isEmpty {<br/>            currentRow.width = currentX<br/>            rows.append(currentRow)<br/>            currentRow = Row()<br/>            spacing = .zero<br/>            currentX = .zero<br/>        }<br/><br/>        currentRow.elements.append((index, sizes[index], currentX + spacing))<br/>        currentX += size.width + spacing<br/>    }<br/><br/>    currentRow.width = currentX<br/>    rows.append(currentRow)<br/><br/>    var currentY = CGFloat.zero<br/>    var previousMaxHeightIndex: Int?<br/><br/>    for index in rows.indices {<br/>        let maxHeightIndex = rows[index].elements<br/>            .max { $0.size.height &lt; $1.size.height }!<br/>            .index<br/><br/>        let size = sizes[maxHeightIndex]<br/><br/>        var spacing = CGFloat.zero<br/>        if let previousMaxHeightIndex {<br/>            spacing = verticalSpacing(subviews[previousMaxHeightIndex], subviews[maxHeightIndex])<br/>        }<br/><br/>        rows[index].yOffset = currentY + spacing<br/>        currentY += size.height + spacing<br/>        rows[index].height = size.height<br/>        previousMaxHeightIndex = maxHeightIndex<br/>    }<br/><br/>    return rows<br/>}</span></pre><h1 id="3732" class="lk ll iq bd lm ln lo lp lq lr ls lt lu jw lv jx lw jz lx ka ly kc lz kd ma mb bi translated">间隔</h1><p id="8be1" class="pw-post-body-paragraph kn ko iq kp b kq mc jr ks kt md ju kv kw me ky kz la mf lc ld le mg lg lh li ij bi translated">如果<code class="fe mw mx my mi b">nil</code>，我们将允许水平和垂直间距覆盖或使用系统提供的间距。<code class="fe mw mx my mi b">LayoutSubview</code>代理允许获取一对子视图的系统间距。</p><pre class="kg kh ki kj gt mh mi mj bn mk ml bi"><span id="6208" class="mm ll iq mi b be mn mo l mp mq">func horizontalSpacing(_ lhs: LayoutSubview, _ rhs: LayoutSubview) -&gt; CGFloat {<br/>    if let horizontalSpacing { return horizontalSpacing }<br/><br/>    return lhs.spacing.distance(to: rhs.spacing, along: .horizontal)<br/>}<br/><br/>func verticalSpacing(_ lhs: LayoutSubview, _ rhs: LayoutSubview) -&gt; CGFloat {<br/>    if let verticalSpacing { return verticalSpacing }<br/><br/>    return lhs.spacing.distance(to: rhs.spacing, along: .vertical)<br/>}</span></pre><h1 id="dc72" class="lk ll iq bd lm ln lo lp lq lr ls lt lu jw lv jx lw jz lx ka ly kc lz kd ma mb bi translated">布局属性</h1><p id="2a6b" class="pw-post-body-paragraph kn ko iq kp b kq mc jr ks kt md ju kv kw me ky kz la mf lc ld le mg lg lh li ij bi translated"><code class="fe mw mx my mi b">Layout</code>协议有一个可选的<code class="fe mw mx my mi b">layoutProperties</code>参数，允许控制<code class="fe mw mx my mi b">StackOrientation</code>。它会影响<code class="fe mw mx my mi b">Spacer</code>和<code class="fe mw mx my mi b">Divider</code>的处理方式。</p><p id="955e" class="pw-post-body-paragraph kn ko iq kp b kq kr jr ks kt ku ju kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">例如，使用<code class="fe mw mx my mi b">stackOrientation = .horizontal</code>时，<code class="fe mw mx my mi b">Spacer</code>只会水平扩展。因此，它将允许在容器中强制换行。</p><p id="4353" class="pw-post-body-paragraph kn ko iq kp b kq kr jr ks kt ku ju kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">它有一个警告，在分割的行之间将有两倍的间距，默认的系统间距为零。</p><pre class="kg kh ki kj gt mh mi mj bn mk ml bi"><span id="5553" class="mm ll iq mi b be mn mo l mp mq">static var layoutProperties: LayoutProperties {<br/>    var properties = LayoutProperties()<br/>    properties.stackOrientation = .horizontal<br/><br/>    return properties<br/>}</span></pre><h1 id="b818" class="lk ll iq bd lm ln lo lp lq lr ls lt lu jw lv jx lw jz lx ka ly kc lz kd ma mb bi translated">对齐</h1><p id="d791" class="pw-post-body-paragraph kn ko iq kp b kq mc jr ks kt md ju kv kw me ky kz la mf lc ld le mg lg lh li ij bi translated">我们将允许控制容器内部的对齐值。除了<code class="fe mw mx my mi b">Layout</code>协议没有提供实现各种文本基线对齐值的简单方法:<code class="fe mw mx my mi b">.leadingFirstTextBaseline</code>、<code class="fe mw mx my mi b">.centerLastTextBaseline</code>等。其余值对应于<code class="fe mw mx my mi b">UnitPoint</code>值。</p><pre class="kg kh ki kj gt mh mi mj bn mk ml bi"><span id="2135" class="mm ll iq mi b be mn mo l mp mq">extension UnitPoint {<br/>    init(_ alignment: Alignment) {<br/>        switch alignment {<br/>        case .leading:<br/>            self = .leading<br/>        case .topLeading:<br/>            self = .topLeading<br/>        case .top:<br/>            self = .top<br/>        case .topTrailing:<br/>            self = .topTrailing<br/>        case .trailing:<br/>            self = .trailing<br/>        case .bottomTrailing:<br/>            self = .bottomTrailing<br/>        case .bottom:<br/>            self = .bottom<br/>        case .bottomLeading:<br/>            self = .bottomLeading<br/>        default:<br/>            self = .center<br/>        }<br/>    }<br/>}<br/><br/>let anchor = UnitPoint(alignment)</span></pre><p id="1417" class="pw-post-body-paragraph kn ko iq kp b kq kr jr ks kt ku ju kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">我们需要在<code class="fe mw mx my mi b">placeSubviews</code>中用锚值进行修正。</p><pre class="kg kh ki kj gt mh mi mj bn mk ml bi"><span id="5a88" class="mm ll iq mi b be mn mo l mp mq">let xCorrection = anchor.x * (bounds.width - row.width)<br/>let yCorrection = anchor.y * (row.height - element.size.height)</span></pre><h1 id="7b9f" class="lk ll iq bd lm ln lo lp lq lr ls lt lu jw lv jx lw jz lx ka ly kc lz kd ma mb bi translated">贮藏</h1><p id="ffe4" class="pw-post-body-paragraph kn ko iq kp b kq mc jr ks kt md ju kv kw me ky kz la mf lc ld le mg lg lh li ij bi translated">我们将缓存容器的最小大小和行排列以提高性能。</p><p id="122a" class="pw-post-body-paragraph kn ko iq kp b kq kr jr ks kt ku ju kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">行的排列取决于建议和子视图的大小。只要这些发生变化，就应该重新计算行的排列</p><pre class="kg kh ki kj gt mh mi mj bn mk ml bi"><span id="a534" class="mm ll iq mi b be mn mo l mp mq">struct Cache {<br/>    var minSize: CGSize<br/>    var rows: (Int, [Row])?<br/>}<br/><br/>func makeCache(subviews: Subviews) -&gt; Cache {<br/>    Cache(minSize: minSize(subviews: subviews))<br/>}<br/><br/>func updateCache(_ cache: inout Cache, subviews: Subviews) {<br/>    cache.minSize = minSize(subviews: subviews)<br/>}<br/><br/>func computeHash(proposal: ProposedViewSize, sizes: [CGSize]) -&gt; Int {<br/>    let proposal = proposal.replacingUnspecifiedDimensions(by: .infinity)<br/><br/>    var hasher = Hasher()<br/><br/>    for size in [proposal] + sizes {<br/>        hasher.combine(size.width)<br/>        hasher.combine(size.height)<br/>    }<br/><br/>    return hasher.finalize()<br/>}<br/><br/>// In `arrangeRows` beginning<br/>let hash = computeHash(proposal: proposal, sizes: sizes)<br/>if let (oldHash, oldRows) = cache.rows,<br/>   oldHash == hash {<br/>    return oldRows<br/>}<br/><br/>// In `arrangeRows` end<br/>cache.rows = (hash, rows)</span></pre><h1 id="b196" class="lk ll iq bd lm ln lo lp lq lr ls lt lu jw lv jx lw jz lx ka ly kc lz kd ma mb bi translated">使用</h1><p id="fad8" class="pw-post-body-paragraph kn ko iq kp b kq mc jr ks kt md ju kv kw me ky kz la mf lc ld le mg lg lh li ij bi translated">做完这些工作后，我们终于可以重新定义我们的标签列表了。</p><pre class="kg kh ki kj gt mh mi mj bn mk ml bi"><span id="cf56" class="mm ll iq mi b be mn mo l mp mq">WrappingHStack(alignment: .leading) {<br/>    ForEach(tags) {<br/>        TagView(text: $0.text)<br/>    }<br/>}.padding()</span></pre><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="ms mt di mu bf mv"><div class="gh gi mr"><img src="../Images/c6b255bbc88a4da2c3ecdcd1f87899b4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*D2leuF3ZbobRQVoT.png"/></div></div></figure><h1 id="f80d" class="lk ll iq bd lm ln lo lp lq lr ls lt lu jw lv jx lw jz lx ka ly kc lz kd ma mb bi translated">限制</h1><p id="c437" class="pw-post-body-paragraph kn ko iq kp b kq mc jr ks kt md ju kv kw me ky kz la mf lc ld le mg lg lh li ij bi translated">按照设计，容器不支持在垂直轴上无限增长的子视图。在这种情况下，你怎么定义身高呢？</p><h1 id="65d7" class="lk ll iq bd lm ln lo lp lq lr ls lt lu jw lv jx lw jz lx ka ly kc lz kd ma mb bi translated">最后的想法</h1><p id="6ea7" class="pw-post-body-paragraph kn ko iq kp b kq mc jr ks kt md ju kv kw me ky kz la mf lc ld le mg lg lh li ij bi translated">我们已经以一种通用的方式编写了包装hstack(有时也称为流布局)容器，可以处理各种各样的子视图。这绝对不容易，我们现在可以欣赏我们使用标准<code class="fe mw mx my mi b">HStack</code>和<code class="fe mw mx my mi b">VStack</code>的简单性。</p><p id="634b" class="pw-post-body-paragraph kn ko iq kp b kq kr jr ks kt ku ju kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">在<a class="ae lj" href="https://github.com/ksemianov/WrappingHStack" rel="noopener ugc nofollow" target="_blank">https://github.com/ksemianov/WrappingHStack</a>查看完整代码。</p></div><div class="ab cl nn no hu np" role="separator"><span class="nq bw bk nr ns nt"/><span class="nq bw bk nr ns nt"/><span class="nq bw bk nr ns"/></div><div class="ij ik il im in"><p id="136e" class="pw-post-body-paragraph kn ko iq kp b kq kr jr ks kt ku ju kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated"><em class="nu">原载于</em><a class="ae lj" href="https://ksemianov.github.io/articles/wrapping-hstack/" rel="noopener ugc nofollow" target="_blank"><em class="nu">https://ksemianov . github . io</em></a></p></div></div>    
</body>
</html>