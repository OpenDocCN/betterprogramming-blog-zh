<html>
<head>
<title>Implementing Facade Design Pattern in C#</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">在C#中实现外观设计模式</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/facade-design-pattern-39a87c4cfa14?source=collection_archive---------2-----------------------#2022-02-20">https://betterprogramming.pub/facade-design-pattern-39a87c4cfa14?source=collection_archive---------2-----------------------#2022-02-20</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="47e6" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">流行设计模式的实际实现</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/e397b012788780054352607293afbc71.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*5rTFmONFFxyz4_b3"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">照片由<a class="ae kv" href="https://unsplash.com/@ffstop?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">摄影师</a>在<a class="ae kv" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</p></figure><h2 id="c288" class="kw kx iq bd ky kz la dn lb lc ld dp le lf lg lh li lj lk ll lm ln lo lp lq lr bi translated">为什么我们需要一个门面设计模式？</h2><p id="f941" class="pw-post-body-paragraph ls lt iq lu b lv lw jr lx ly lz ju ma lf mb mc md lj me mf mg ln mh mi mj mk ij bi translated">偷偷看一下下图。右边的类需要属于最左边的类的4个方法。但是为了确定我们需要访问哪四个方法，我们可能需要挖掘最左边的<code class="fe ml mm mn mo b">ClassA</code>的内部。或者有更好的解决办法！</p><p id="cc4f" class="pw-post-body-paragraph ls lt iq lu b lv mp jr lx ly mq ju ma lf mr mc md lj ms mf mg ln mt mi mj mk ij bi translated">我可以在我的类之间放置一个facade，现在这个facade有一个对<code class="fe ml mm mn mo b">ClassA</code>的内部引用，并代表我们的程序类编排调用。我们使用了一个facade类，它包含了<code class="fe ml mm mn mo b">classA</code>，并且只公开了我们程序需要的方法。我们可以使用更有意义的方法名，而且我们的程序只与外观对话，根本不知道<code class="fe ml mm mn mo b">classA</code>。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi mu"><img src="../Images/f2974df0282e12eca0281873ba5d46d5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*2GRTf66b29mnrBegQ63cKQ.png"/></div></div></figure><p id="ff17" class="pw-post-body-paragraph ls lt iq lu b lv mp jr lx ly mq ju ma lf mr mc md lj ms mf mg ln mt mi mj mk ij bi translated">这个可扩展的复杂项目显然有数百个类。这种模式通过关注我们所需要的东西来帮助我们的调用类，而不是遍历所有东西，(抽象——哎呀)。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi mu"><img src="../Images/db7972bc290cb9a6322f6077cbaf5d2f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*rO1BmJV4awfLyqr_L0Kpfw.png"/></div></div></figure><p id="24f8" class="pw-post-body-paragraph ls lt iq lu b lv mp jr lx ly mq ju ma lf mr mc md lj ms mf mg ln mt mi mj mk ij bi translated">假设我们想要实现一个智能手机类，它有3个规格:处理器、内存(RAM、ROM)和显示器。我们的实现可能如下所示:</p><p id="e187" class="pw-post-body-paragraph ls lt iq lu b lv mp jr lx ly mq ju ma lf mr mc md lj ms mf mg ln mt mi mj mk ij bi translated">清单1:类<code class="fe ml mm mn mo b">Processor </code></p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mv mw l"/></div></figure><p id="018c" class="pw-post-body-paragraph ls lt iq lu b lv mp jr lx ly mq ju ma lf mr mc md lj ms mf mg ln mt mi mj mk ij bi translated">清单2:类<code class="fe ml mm mn mo b">Memory</code> —</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mv mw l"/></div></figure><p id="33d2" class="pw-post-body-paragraph ls lt iq lu b lv mp jr lx ly mq ju ma lf mr mc md lj ms mf mg ln mt mi mj mk ij bi translated">清单3:类<code class="fe ml mm mn mo b">Display</code>:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mv mw l"/></div></figure><p id="6849" class="pw-post-body-paragraph ls lt iq lu b lv mp jr lx ly mq ju ma lf mr mc md lj ms mf mg ln mt mi mj mk ij bi translated">清单4:调用类，类<code class="fe ml mm mn mo b">SmartPhone</code>:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mv mw l"/></div></figure><p id="d407" class="pw-post-body-paragraph ls lt iq lu b lv mp jr lx ly mq ju ma lf mr mc md lj ms mf mg ln mt mi mj mk ij bi translated">让我们首先理解，这是一个简单的问题，但由于智能手机需要跟随最新的趋势和创新，你需要为每个功能添加更多的类。</p><p id="9f9d" class="pw-post-body-paragraph ls lt iq lu b lv mp jr lx ly mq ju ma lf mr mc md lj ms mf mg ln mt mi mj mk ij bi translated">你将不得不经历所有的课程来重新实现<code class="fe ml mm mn mo b">smartPhone</code>。这里我们只有3个类(<code class="fe ml mm mn mo b">Display</code>、<code class="fe ml mm mn mo b">Memory</code>、<code class="fe ml mm mn mo b">Processor</code>)，但是在实际项目中，正如我所说的，会有数百个类，这使得很难找到实现新智能手机所需的类。</p><p id="65c4" class="pw-post-body-paragraph ls lt iq lu b lv mp jr lx ly mq ju ma lf mr mc md lj ms mf mg ln mt mi mj mk ij bi translated">我们可以添加一个中间层，作为我们智能手机的门面，它将负责制作智能手机所需的所有功能。为了使我们的模式更高级，我们可以添加一个接口，通过它我们的<code class="fe ml mm mn mo b">smartPhone</code>类将进行交互。</p><h2 id="2a37" class="kw kx iq bd ky kz la dn lb lc ld dp le lf lg lh li lj lk ll lm ln lo lp lq lr bi translated"><strong class="ak"> <em class="mx">为什么接口？</em> </strong>好问题。</h2><p id="2f44" class="pw-post-body-paragraph ls lt iq lu b lv lw jr lx ly lz ju ma lf mb mc md lj me mf mg ln mh mi mj mk ij bi translated">这种抽象允许一个调用程序(在我们的例子中是<code class="fe ml mm mn mo b">smartPhone</code>)单独处理外观并简化代码。在这里引入一个接口确实为调用者整理了一些东西，并允许在将来的底层服务类(更多的特性，更多的类)变化(将来更高级的智能手机类)中轻松地添加新的外观类。</p><p id="adf2" class="pw-post-body-paragraph ls lt iq lu b lv mp jr lx ly mq ju ma lf mr mc md lj ms mf mg ln mt mi mj mk ij bi translated">如果明天，我想为Android 10发布一款新的高端规格的智能手机，那可以通过与一个界面进行交互来实现。</p><p id="ac81" class="pw-post-body-paragraph ls lt iq lu b lv mp jr lx ly mq ju ma lf mr mc md lj ms mf mg ln mt mi mj mk ij bi translated">说到这里，让我们从门面设计模式开始。</p><p id="f9d6" class="pw-post-body-paragraph ls lt iq lu b lv mp jr lx ly mq ju ma lf mr mc md lj ms mf mg ln mt mi mj mk ij bi translated">如果我们将处理器、内存和显示器放在门面后面，那么智能手机就不必担心上述复杂性了。</p><p id="7230" class="pw-post-body-paragraph ls lt iq lu b lv mp jr lx ly mq ju ma lf mr mc md lj ms mf mg ln mt mi mj mk ij bi translated"><strong class="lu ir">第一步</strong></p><p id="7b4a" class="pw-post-body-paragraph ls lt iq lu b lv mp jr lx ly mq ju ma lf mr mc md lj ms mf mg ln mt mi mj mk ij bi translated">清单5:让我们添加接口<code class="fe ml mm mn mo b">ISmartPhoneFacade</code>:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mv mw l"/></div></figure><p id="8d9f" class="pw-post-body-paragraph ls lt iq lu b lv mp jr lx ly mq ju ma lf mr mc md lj ms mf mg ln mt mi mj mk ij bi translated"><strong class="lu ir">第二步</strong></p><p id="77fe" class="pw-post-body-paragraph ls lt iq lu b lv mp jr lx ly mq ju ma lf mr mc md lj ms mf mg ln mt mi mj mk ij bi translated">清单6:现在让我们添加类<code class="fe ml mm mn mo b">SmartPhoneFacade</code>:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mv mw l"/></div></figure><p id="0a91" class="pw-post-body-paragraph ls lt iq lu b lv mp jr lx ly mq ju ma lf mr mc md lj ms mf mg ln mt mi mj mk ij bi translated">清单7:现在简单看一下我们的<code class="fe ml mm mn mo b">smartPhone</code>类:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mv mw l"/></div></figure><p id="4751" class="pw-post-body-paragraph ls lt iq lu b lv mp jr lx ly mq ju ma lf mr mc md lj ms mf mg ln mt mi mj mk ij bi translated">如果明天，新的<code class="fe ml mm mn mo b">smartPhone</code>设备来了，我所要做的就是创建一个新的门面，具体到智能手机的功能，并继承界面<code class="fe ml mm mn mo b">ISmartPhoneFacade</code>。这就是oops中抽象的力量。</p><p id="23fa" class="pw-post-body-paragraph ls lt iq lu b lv mp jr lx ly mq ju ma lf mr mc md lj ms mf mg ln mt mi mj mk ij bi translated"><strong class="lu ir">注意:</strong>增加一个额外的类可能会让人感到头疼，但是从更大的角度来看这是有帮助的，这是你可以设计松散耦合的类的地方。</p><p id="09ee" class="pw-post-body-paragraph ls lt iq lu b lv mp jr lx ly mq ju ma lf mr mc md lj ms mf mg ln mt mi mj mk ij bi translated">我真诚地希望你喜欢这个博客，并希望你受到启发，将你所学到的东西应用到自己的应用中。</p><p id="0771" class="pw-post-body-paragraph ls lt iq lu b lv mp jr lx ly mq ju ma lf mr mc md lj ms mf mg ln mt mi mj mk ij bi translated">在Linkedin上找到我！！</p><div class="my mz gp gr na nb"><a href="https://www.linkedin.com/in/rikampalkar/" rel="noopener  ugc nofollow" target="_blank"><div class="nc ab fo"><div class="nd ab ne cl cj nf"><h2 class="bd ir gy z fp ng fr fs nh fu fw ip bi translated">Rikam Palkar -软件工程师-小天鹅-威德福| LinkedIn</h2><div class="ni l"><h3 class="bd b gy z fp ng fr fs nh fu fw dk translated">通过编写可伸缩的代码让世界变得更美好。我从来没有在大学里发现我对编码的热情，也没有在…</h3></div><div class="nj l"><p class="bd b dl z fp ng fr fs nh fu fw dk translated">www.linkedin.com</p></div></div><div class="nk l"><div class="nl l nm nn no nk np kp nb"/></div></div></a></div></div></div>    
</body>
</html>