<html>
<head>
<title>Improve Code Readability With the Fluent Builder Pattern in C#</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用C#中的Fluent Builder模式提高代码可读性</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/improve-code-readability-with-fluent-builder-pattern-in-c-4cfbf57159df?source=collection_archive---------3-----------------------#2022-02-05">https://betterprogramming.pub/improve-code-readability-with-fluent-builder-pattern-in-c-4cfbf57159df?source=collection_archive---------3-----------------------#2022-02-05</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="cf3e" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">fluent builder模式如何使您的代码更具可读性和可维护性</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/f0d3cca148160820d1c965da780da354.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*MHuMbAcZ1JZdK4of"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">由<a class="ae kv" href="https://unsplash.com/@dianamia?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> C达斯汀</a>在<a class="ae kv" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>拍摄的照片</p></figure><p id="32e1" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在现实世界的项目中，对象可能会变得非常大和复杂。初始化它们会变得乏味且不透明。你通常会调用构造函数或者使用对象初始化器和/或一个接一个地传入每个字段。传递许多参数会增加放错位置的风险，这可能会导致实现的组件出现意外行为。使用隐式创建方法，例如依赖注入、反射等。让我们更难看到幕后发生的事情和实际创造的东西。</p><p id="5a87" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">让我们看看问题的实际情况。假设我们有下面的类，我们想创建它的一个实例。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ls lt l"/></div></figure><p id="acbd" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们现在有不同的选项来实例化这个类，即构造函数、对象初始化器或分段创建。</p><h2 id="7d19" class="lu lv iq bd lw lx ly dn lz ma mb dp mc lf md me mf lj mg mh mi ln mj mk ml mm bi translated"><strong class="ak">通过构造器初始化</strong></h2><p id="8aa3" class="pw-post-body-paragraph kw kx iq ky b kz mn jr lb lc mo ju le lf mp lh li lj mq ll lm ln mr lp lq lr ij bi translated">所有参数都以正确的顺序传递到构造函数中。在这个例子中，哪个字段传入了什么不是很明显。可以假设这个例子很简单。然而，对于具有类似参数的更大的对象，可能更难理解发生了什么。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ls lt l"/></div></figure><h2 id="ef6b" class="lu lv iq bd lw lx ly dn lz ma mb dp mc lf md me mf lj mg mh mi ln mj mk ml mm bi translated"><strong class="ak">通过对象初始化器进行初始化</strong></h2><p id="ae22" class="pw-post-body-paragraph kw kx iq ky b kz mn jr lb lc mo ju le lf mp lh li lj mq ll lm ln mr lp lq lr ij bi translated">与构造函数相比，对象初始化器显式声明字段名和传递的参数值。这使得正在发生的事情更加清楚。如果您的所有字段都有公共setters，这意味着您的对象不是不可变的，那么这种方法完全没问题。C# 9.0引入了<code class="fe ms mt mu mv b">init</code>关键字，这是一个专门的设置器，允许用对象初始化器设置字段的值。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ls lt l"/></div></figure><h2 id="4980" class="lu lv iq bd lw lx ly dn lz ma mb dp mc lf md me mf lj mg mh mi ln mj mk ml mm bi translated">分段对象创建</h2><p id="4ec7" class="pw-post-body-paragraph kw kx iq ky b kz mn jr lb lc mo ju le lf mp lh li lj mq ll lm ln mr lp lq lr ij bi translated">另一种方法是分段创建对象。这意味着您首先创建一个空对象，然后逐个设置字段的值。这可能非常重复，并且需要一个不带任何参数的构造函数方法。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ls lt l"/></div></figure><h1 id="2540" class="mw lv iq bd lw mx my mz lz na nb nc mc jw nd jx mf jz ne ka mi kc nf kd ml ng bi translated">建设者</h1><p id="a567" class="pw-post-body-paragraph kw kx iq ky b kz mn jr lb lc mo ju le lf mp lh li lj mq ll lm ln mr lp lq lr ij bi translated">构建器是一个单独负责对象创建的组件。引入构建器组件清楚地将您的逻辑和模型类与创建和初始化所需的实例分开。</p><p id="d4c4" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这种创造性模式的主要好处是它使代码库更具可读性和可维护性。创建对象变得更加明确，因为它在创建时清楚地陈述了这个特定实例的内容和数据。</p><p id="9d05" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">此外，它允许您重载构建器方法，这使得创建具有不同配置的实例变得非常容易。最后，它支持在某些情况下可能需要的不可变对象。</p><h2 id="317c" class="lu lv iq bd lw lx ly dn lz ma mb dp mc lf md me mf lj mg mh mi ln mj mk ml mm bi translated">例子</h2><p id="1ec0" class="pw-post-body-paragraph kw kx iq ky b kz mn jr lb lc mo ju le lf mp lh li lj mq ll lm ln mr lp lq lr ij bi translated">下面的类阐释了生成器模式的一个示例。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ls lt l"/></div></figure><p id="ae0b" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">对象初始化将如下所示。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ls lt l"/></div></figure><h1 id="f9de" class="mw lv iq bd lw mx my mz lz na nb nc mc jw nd jx mf jz ne ka mi kc nf kd ml ng bi translated">流畅的建设者</h1><p id="eed8" class="pw-post-body-paragraph kw kx iq ky b kz mn jr lb lc mo ju le lf mp lh li lj mq ll lm ln mr lp lq lr ij bi translated">用一个流畅的API扩展构建器模式，可以更容易地阅读语句，并使您能够将语句链接起来，以您想要的对象配置结束。不再需要在每个语句中都指定builder对象。</p><h2 id="aea3" class="lu lv iq bd lw lx ly dn lz ma mb dp mc lf md me mf lj mg mh mi ln mj mk ml mm bi translated">例子</h2><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ls lt l"/></div></figure><p id="eb83" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">下面的代码片段展示了如何使用它。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ls lt l"/></div></figure><h1 id="4c74" class="mw lv iq bd lw mx my mz lz na nb nc mc jw nd jx mf jz ne ka mi kc nf kd ml ng bi translated">要点和限制</h1><p id="6f75" class="pw-post-body-paragraph kw kx iq ky b kz mn jr lb lc mo ju le lf mp lh li lj mq ll lm ln mr lp lq lr ij bi translated">构建器模式是实例化类的好方法。就我个人而言，我主要使用这种模式进行测试。这是一种创建模拟对象的简单方法，可以清楚地说明特定场景的测试设置。另一个实际的例子是将它用于定制的HttpClients，可以用不同的(预)配置来创建。</p><p id="015f" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">尽管它带来了优势，但fluent builder使继承变得非常困难。你需要使用递归泛型。这种方法是可行的，但是会使构建器代码更加复杂。</p></div></div>    
</body>
</html>