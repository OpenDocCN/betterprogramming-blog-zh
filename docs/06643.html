<html>
<head>
<title>The Technical Interview Guide to Backtracking</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">回溯技术面试指南</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/the-technical-interview-guide-to-backtracking-e1a03ca4abad?source=collection_archive---------4-----------------------#2020-10-21">https://betterprogramming.pub/the-technical-interview-guide-to-backtracking-e1a03ca4abad?source=collection_archive---------4-----------------------#2020-10-21</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="e8aa" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">关于<strong class="ak">回溯</strong>的JavaScript指南，用于面试准备和日常编码</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/6b1c3bb74624b6dd7677a871b0d10843.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*iGb5SRFKJLbJZf3G3bUJmA.jpeg"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">图片来源:作者</p></figure><p id="8807" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">在之前的文章中，我们讨论了动态编程，这是一种通过构建解决较小子问题的解决方案来解决较大问题的方法。它使用最优子结构。</p><p id="46e8" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">在本文中，我们将关注另一个热门话题:回溯。</p><p id="03f2" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated"><a class="ae lu" href="https://en.wikipedia.org/wiki/Backtracking" rel="noopener ugc nofollow" target="_blank">回溯</a>是一种通用算法，用于寻找一个计算问题的全部或部分解决方案，该算法在放弃每个部分候选方案的同时，逐步构建候选方案(回溯)。部分候选被放弃，要么是因为它不可能完成有效的解决方案，要么是因为问题需要找到所有有效的解决方案。</p><p id="742c" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">动态编程和回溯有什么区别？</p><ul class=""><li id="5dbc" class="lv lw it la b lb lc le lf lh lx ll ly lp lz lt ma mb mc md bi translated">动态规划强调重叠子问题，而回溯则关注全部或部分解。</li><li id="0220" class="lv lw it la b lb me le mf lh mg ll mh lp mi lt ma mb mc md bi translated">动态编程依赖于最优性原则，而回溯使用强力方法。</li><li id="2623" class="lv lw it la b lb me le mf lh mg ll mh lp mi lt ma mb mc md bi translated">动态编程更像广度优先搜索(BFS)，一次建立一层，而回溯更像深度优先搜索(DFS)，首先建立一个解决方案。</li><li id="5c2f" class="lv lw it la b lb me le mf lh mg ll mh lp mi lt ma mb mc md bi translated">动态编程通常比回溯占用更多的空间，通过记忆所有的最优子<strong class="la iu"> - </strong>解供以后使用。</li><li id="23cc" class="lv lw it la b lb me le mf lh mg ll mh lp mi lt ma mb mc md bi translated">回溯通常需要更多的时间来执行，通过迭代全部或部分解决方案。</li></ul><p id="054b" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">有些问题可以用动态规划优化，有些问题更容易回溯。它根据具体情况适用于不同的情况。</p><p id="d83e" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">在本文中，我们将讨论一些回溯问题。</p></div><div class="ab cl mj mk hx ml" role="separator"><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo"/></div><div class="im in io ip iq"><h1 id="fe46" class="mq mr it bd ms mt mu mv mw mx my mz na jz nb ka nc kc nd kd ne kf nf kg ng nh bi translated">典型的回溯结构</h1><p id="cbeb" class="pw-post-body-paragraph ky kz it la b lb ni ju ld le nj jx lg lh nk lj lk ll nl ln lo lp nm lr ls lt im bi translated">我们尝试标准化回溯解决方案:</p><ul class=""><li id="012d" class="lv lw it la b lb lc le lf lh lx ll ly lp lz lt ma mb mc md bi translated">将回溯函数命名为<code class="fe nn no np nq b">backtrack</code>。</li><li id="a31e" class="lv lw it la b lb me le mf lh mg ll mh lp mi lt ma mb mc md bi translated">将回溯放入函数中，以利用<a class="ae lu" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Closures" rel="noopener ugc nofollow" target="_blank">闭包</a>。</li><li id="ff70" class="lv lw it la b lb me le mf lh mg ll mh lp mi lt ma mb mc md bi translated">以下是典型回溯算法的结构:</li></ul><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nr ns l"/></div></figure></div><div class="ab cl mj mk hx ml" role="separator"><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo"/></div><div class="im in io ip iq"><h1 id="6271" class="mq mr it bd ms mt mu mv mw mx my mz na jz nb ka nc kc nd kd ne kf nf kg ng nh bi translated">排列、组合、子集和变化</h1><h2 id="65d1" class="nt mr it bd ms nu nv dn mw nw nx dp na lh ny nz nc ll oa ob ne lp oc od ng oe bi translated">排列</h2><p id="0eed" class="pw-post-body-paragraph ky kz it la b lb ni ju ld le nj jx lg lh nk lj lk ll nl ln lo lp nm lr ls lt im bi translated">集合的排列是其成员排列成一个序列。选择的顺序很重要。以<code class="fe nn no np nq b">[1, 2, 3]</code>为例，它的排列是<code class="fe nn no np nq b">[[1,2,3],[1,3,2],[2,1,3],[2,3,1],[3,1,2],[3,2,1]]</code>。</p><p id="5090" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">下面是回溯算法，用于打印数字选择的排列:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nr ns l"/></div></figure><p id="140a" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">在第28行，我们使用原始的<code class="fe nn no np nq b">start</code>值尝试下一个候选，这将使用每个候选。为了防止同一个选项被多次使用，第23行确保该号码还没有被使用。</p><p id="2213" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">这些是验证测试:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nr ns l"/></div></figure><h2 id="1b5c" class="nt mr it bd ms nu nv dn mw nw nx dp na lh ny nz nc ll oa ob ne lp oc od ng oe bi translated">排列计数</h2><p id="ac2b" class="pw-post-body-paragraph ky kz it la b lb ni ju ld le nj jx lg lh nk lj lk ll nl ln lo lp nm lr ls lt im bi translated">显然，如果问题只要求排列计数，我们可以使用动态规划来获得最优解。</p><p id="5a97" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">下面是从数字选择中打印出排列计数的动态编程算法:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nr ns l"/></div></figure><p id="bbfd" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">这些是验证测试:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nr ns l"/></div></figure><p id="5d12" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">毫不奇怪，排列计数是阶乘数。</p><h2 id="d1c7" class="nt mr it bd ms nu nv dn mw nw nx dp na lh ny nz nc ll oa ob ne lp oc od ng oe bi translated">组合</h2><p id="00a6" class="pw-post-body-paragraph ky kz it la b lb ni ju ld le nj jx lg lh nk lj lk ll nl ln lo lp nm lr ls lt im bi translated">组合是从集合中选择的项目。选择的顺序并不重要。我们可以用类似的程序来计算组合。<code class="fe nn no np nq b">[1, 2, 3]</code>的组合是<code class="fe nn no np nq b">[[1, 2, 3]]</code>。</p><p id="a315" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">下面是从数字选择中打印出组合的回溯算法:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nr ns l"/></div></figure><p id="dffd" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">在第26行，我们使用<em class="of"> i </em> + 1尝试下一个候选，这将从一个未使用的候选开始。</p><p id="7f3e" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">这些是验证测试:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nr ns l"/></div></figure><p id="c853" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">打印出和结果一样的选择，似乎没有意义。然而，该算法是许多组合变化的基础。外卖是下一个候选索引。如果候选人不能被重用，使用索引，<em class="of"> i </em> + 1。否则，使用索引，<em class="of"> i </em>。</p><h2 id="daa2" class="nt mr it bd ms nu nv dn mw nw nx dp na lh ny nz nc ll oa ob ne lp oc od ng oe bi translated">子集</h2><p id="7560" class="pw-post-body-paragraph ky kz it la b lb ni ju ld le nj jx lg lh nk lj lk ll nl ln lo lp nm lr ls lt im bi translated">如果集合A的所有元素也是B的元素，则集合A是集合B的子集。A和B有可能相等。<code class="fe nn no np nq b">[1, 2, 3]</code>有子集<code class="fe nn no np nq b">[[],[1],[1,2],[1,2,3],[1,3],[2],[2,3],[3]]</code>。</p><p id="cccf" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">下面是从数字选择中打印出子集的回溯算法:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nr ns l"/></div></figure><p id="2aca" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">这些是验证测试:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nr ns l"/></div></figure><h2 id="0003" class="nt mr it bd ms nu nv dn mw nw nx dp na lh ny nz nc ll oa ob ne lp oc od ng oe bi translated">置换子集</h2><p id="ddc5" class="pw-post-body-paragraph ky kz it la b lb ni ju ld le nj jx lg lh nk lj lk ll nl ln lo lp nm lr ls lt im bi translated">子集是组合。区别对待子集排列怎么样？以<code class="fe nn no np nq b">[1, 2]</code>为例:</p><ul class=""><li id="689c" class="lv lw it la b lb lc le lf lh lx ll ly lp lz lt ma mb mc md bi translated">它的子集是<code class="fe nn no np nq b">[[],[1],[1,2],[2]]</code>。</li><li id="fd12" class="lv lw it la b lb me le mf lh mg ll mh lp mi lt ma mb mc md bi translated">它的排列子集是<code class="fe nn no np nq b">[[],[1],[1,2],[2],[2,1]]</code>。</li></ul><p id="ca81" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">要生成置换子集，每个回溯调用都需要从第一个选择开始。而且，用过的选择不能重复使用。</p><p id="056d" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">置换子集的算法如下:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nr ns l"/></div></figure><p id="ce0f" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">第24 - 26行从未使用的选项回溯。</p><p id="a551" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">这些是验证测试:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nr ns l"/></div></figure><h2 id="3a21" class="nt mr it bd ms nu nv dn mw nw nx dp na lh ny nz nc ll oa ob ne lp oc od ng oe bi translated">置换子集不唯一</h2><p id="7250" class="pw-post-body-paragraph ky kz it la b lb ni ju ld le nj jx lg lh nk lj lk ll nl ln lo lp nm lr ls lt im bi translated">我们假设每个数字选择都是一个唯一的自然数。如果数字选择不是唯一的呢？</p><p id="1636" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">比如<code class="fe nn no np nq b">[1,2,1]</code>的排列子集是<code class="fe nn no np nq b">[[],[1],[1,1],[1,1,2],[1,2],[1,2,1],[2],[2,1],[2,1,1]]</code>。</p><p id="9484" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">在这种情况下，我们需要对选项进行排序，以确保相同的数字相邻。所以可以避免多次把同一个数字放在同一个位置。</p><p id="1df8" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">以下是编号不唯一的置换子集的算法:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nr ns l"/></div></figure><p id="4a36" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">第46行对选项进行排序。</p><p id="1bfe" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">第32 - 37行跳过了与前面相同的选项。</p><p id="3380" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">这些是验证测试:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nr ns l"/></div></figure><h2 id="40a8" class="nt mr it bd ms nu nv dn mw nw nx dp na lh ny nz nc ll oa ob ne lp oc od ng oe bi translated">无重复的组合和</h2><p id="8f4f" class="pw-post-body-paragraph ky kz it la b lb ni ju ld le nj jx lg lh nk lj lk ll nl ln lo lp nm lr ls lt im bi translated">有了一组不同的自然数选项和一个目标值，我们就可以使用组合算法来查找总和达到目标值的唯一组合。每个数字选项最多只能使用一次。比如选项是<code class="fe nn no np nq b">[1, 2, 3, 4]</code>，目标是5。独特的组合是<code class="fe nn no np nq b">[[1, 4], [2, 3]]</code>。</p><p id="bc19" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">无重复组合的回溯算法编写如下:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nr ns l"/></div></figure><p id="971b" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">这些是验证测试:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nr ns l"/></div></figure><h2 id="b502" class="nt mr it bd ms nu nv dn mw nw nx dp na lh ny nz nc ll oa ob ne lp oc od ng oe bi translated">重复组合和</h2><p id="cb30" class="pw-post-body-paragraph ky kz it la b lb ni ju ld le nj jx lg lh nk lj lk ll nl ln lo lp nm lr ls lt im bi translated">我们改变条件以允许每个数字选择尽可能多地被使用。举同样的例子选择<code class="fe nn no np nq b">[1, 2, 3, 4]</code>和目标5。允许重复的组合是<code class="fe nn no np nq b">[[1, 1, 1, 1, 1], [1, 1, 1, 2], [1, 1, 3], [1, 2, 2], [1, 4], [2, 3]]</code>。</p><p id="a54f" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">允许重复组合的回溯算法编写如下:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nr ns l"/></div></figure><p id="8822" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">允许重复的组合代码几乎与不重复的组合相同，除了在第31行，下一个候选使用相同的索引，<em class="of"> i </em>。</p><p id="c40c" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">通过这个小小的调整，验证测试输出允许重复的组合:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nr ns l"/></div></figure></div><div class="ab cl mj mk hx ml" role="separator"><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo"/></div><div class="im in io ip iq"><h1 id="96b4" class="mq mr it bd ms mt mu mv mw mx my mz na jz nb ka nc kc nd kd ne kf nf kg ng nh bi translated">将电话号码转换成字符串</h1><p id="d74c" class="pw-post-body-paragraph ky kz it la b lb ni ju ld le nj jx lg lh nk lj lk ll nl ln lo lp nm lr ls lt im bi translated">以下是典型的电话本。一个数字，除了1和0，可以转换成三个或四个字符。给定一串数字，我们编写一个回溯算法，基于phone pad转换器将其转换为一个可能的字符串数组。例如，9可以转换为<code class="fe nn no np nq b">W</code>、<code class="fe nn no np nq b">X</code>、<code class="fe nn no np nq b">Y</code>或<code class="fe nn no np nq b">Z</code>。输出是<code class="fe nn no np nq b">[“W”, “X”, “Y”, “Z”]</code>。同样的，<code class="fe nn no np nq b">915</code>的输出是<code class="fe nn no np nq b">[“WJ”, ”WK”, ”WL”, ”XJ”, ”XK”, ”XL”, ”YJ”, ”YK”, ”YL”, ”ZJ”, ”ZK”, ”ZL”]</code>。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi og"><img src="../Images/6cbbe5b30ce54cd3f8a3851357479cf3.png" data-original-src="https://miro.medium.com/v2/resize:fit:932/format:webp/1*iNfYFWPtrB_DX4IMeQlXUA.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">图片来自维基百科</p></figure><p id="c1b7" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">下面是转换一串数字的回溯算法:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nr ns l"/></div></figure><p id="9993" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">在第45行，它立即返回空数字。或者，您可以将逻辑放入回溯本身:在第17行之前添加一个检查<code class="fe nn no np nq b">if (list.length &gt; 0)</code>。两种方式都可行；这是个人喜好的问题。</p><p id="20e7" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">这些是验证测试:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nr ns l"/></div></figure></div><div class="ab cl mj mk hx ml" role="separator"><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo"/></div><div class="im in io ip iq"><h1 id="4434" class="mq mr it bd ms mt mu mv mw mx my mz na jz nb ka nc kc nd kd ne kf nf kg ng nh bi translated">格式良好的括号</h1><p id="f96f" class="pw-post-body-paragraph ky kz it la b lb ni ju ld le nj jx lg lh nk lj lk ll nl ln lo lp nm lr ls lt im bi translated">一个格式良好的括号有相同数量的左括号和右括号。比如<code class="fe nn no np nq b">“(())()”</code>是良构的，而<code class="fe nn no np nq b">“(((())”</code>不是。</p><p id="f536" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">此外，从左向右阅读时，右括号数不能超过左括号数。因此，<code class="fe nn no np nq b">“(()))(”</code>不是良构的。</p><p id="59c7" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">下面是构建目标格式良好的括号对的算法:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nr ns l"/></div></figure><p id="0ecb" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">这些是验证测试:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nr ns l"/></div></figure></div><div class="ab cl mj mk hx ml" role="separator"><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo"/></div><div class="im in io ip iq"><h1 id="b8a8" class="mq mr it bd ms mt mu mv mw mx my mz na jz nb ka nc kc nd kd ne kf nf kg ng nh bi translated"><strong class="ak">文字搜索</strong></h1><p id="7310" class="pw-post-body-paragraph ky kz it la b lb ni ju ld le nj jx lg lh nk lj lk ll nl ln lo lp nm lr ls lt im bi translated">单词搜索谜题是一种单词游戏，由一块矩形板上的字母组成。目标是找到藏在棋盘里的一个单词。一个单词可以向左、向右、向上或向下延伸到一个连续的单元格。每个单元格最多只能被访问一次。一个单词也可以是一个句子，例如，它可以包括空格和标点符号。</p><p id="f0ca" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">比如我们可以在下面的板子上找到<code class="fe nn no np nq b">“it is good!”</code>。</p><pre class="kj kk kl km gt oh nq oi oj aw ok bi"><span id="8da0" class="nt mr it nq b gy ol om l on oo">[['i', 't', ' ', '!'],<br/> ['a', 'b', 'i', '!'],<br/> ['g', ' ', 's', '!'],<br/> ['o', 'o', 'd', '!']]</span></pre><p id="dd2a" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">下面是搜索单词的回溯算法:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nr ns l"/></div></figure><p id="bfe9" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">如果打标后不需要回收板子，如果结果为<code class="fe nn no np nq b">true</code>，39行可以立即返回。</p><p id="9707" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">这些是验证测试:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nr ns l"/></div></figure></div><div class="ab cl mj mk hx ml" role="separator"><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo"/></div><div class="im in io ip iq"><h1 id="9367" class="mq mr it bd ms mt mu mv mw mx my mz na jz nb ka nc kc nd kd ne kf nf kg ng nh bi translated"><strong class="ak">数独</strong></h1><p id="5684" class="pw-post-body-paragraph ky kz it la b lb ni ju ld le nj jx lg lh nk lj lk ll nl ln lo lp nm lr ls lt im bi translated">数独是一种基于逻辑的组合数字布局游戏。目标是用数字填充一个9×9的网格，使每一列、每一行以及组成网格的九个3×3子网格都包含从1到9的所有数字。</p><p id="a730" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">以下是来自<a class="ae lu" href="https://en.wikipedia.org/wiki/Sudoku" rel="noopener ugc nofollow" target="_blank">维基百科</a>的一个例子。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi op"><img src="../Images/12826ed52956a81ceed7166a6df5bc6b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*VaWVty-qqcVqsXyMlSuCPg.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">图片来自维基百科</p></figure><p id="3694" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">下面是填充数独的回溯算法:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nr ns l"/></div></figure><p id="ea35" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">这些是验证测试:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nr ns l"/></div></figure></div><div class="ab cl mj mk hx ml" role="separator"><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo"/></div><div class="im in io ip iq"><h1 id="5c2e" class="mq mr it bd ms mt mu mv mw mx my mz na jz nb ka nc kc nd kd ne kf nf kg ng nh bi translated">结论</h1><p id="f931" class="pw-post-body-paragraph ky kz it la b lb ni ju ld le nj jx lg lh nk lj lk ll nl ln lo lp nm lr ls lt im bi translated">回溯问题有许多变种。熟能生巧。享受编码。</p><p id="6347" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">感谢阅读。我希望这有所帮助。你可以在这里看到我的其他媒体出版物<a class="ae lu" href="https://medium.com/@jenniferfubook/jennifer-fus-web-development-publications-1a887e4454af" rel="noopener"/>。</p></div></div>    
</body>
</html>