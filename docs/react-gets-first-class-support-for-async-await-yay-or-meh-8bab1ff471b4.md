# React 获得了对 Async/Await 的一流支持——Yay 还是 Meh？

> 原文：<https://betterprogramming.pub/react-gets-first-class-support-for-async-await-yay-or-meh-8bab1ff471b4>

## React RFC 草案提案对数据加载的支持

![](img/76020e85a719460c07a22abda3308d32.png)

作者图片

当团队在 React `16.6`上引入`Suspense`时，React 对 Async/Await 的一流支持的第一个基石就开始了。当时，还没有并发模式，其功能也很有限。挂起的组件会呈现出来，只是隐藏在 DOM 上。它被称为`Legacy Suspense`。

`Suspense`将成为所有其他 API 依赖的重要机制。

当并发模式登陆后，`Suspense` API 得到了增强:

*   React 组件的执行被“暂停”。在`ComponentThatSuspends`解决之前`Element`不会安装。
*   效果/生命周期被正确触发。

到目前为止，延迟加载组件是唯一受`Suspense`支持的用例。React 团队已经花了很长时间来弄清楚如何将数据加载与`Suspense`融合在一起。在这份公布的 RFC 草案中，我们终于可以看到他们计划如何构建它。

# 数据提取暂停

React 团队采用的方法非常传统，但有所改变。

他们选择以两种方式实现这一特性:

*   React 客户端:通过引入一个`use`钩子
*   React 服务器组件:支持本机`async/await` Es7 语法。

## 使用挂钩

这个钩子就像它的名字一样充满争议。他们选择了这个特别的名字，试图将其与其他名字区分开来。为什么？因为这个钩子不一样:**它可以有条件的运行**。

仅仅这一点就打破了我们在过去几年中学到的整个钩子概念。React 团队是如何将这个想法灌输到我们的头脑中的，这是非常了不起的。丹·阿布拉莫夫甚至在一篇著名的文章中详细解释了原因。

如何有条件地调用`use`钩子？因为简化了，它只是抛出一个被最近的`Suspense`父级捕获的`Promise`。

这种方法的警告是什么？与`async/await`不同，React 组件不会从停止的地方恢复。相反，挂起的组件将被重新呈现。这是 React 组件幂等的副作用，多么讽刺。

让我们举一个新的`use`钩子的例子:

上面的代码看起来简单且容易推理。只有一个条件。`<Test />`组件会无休止地重新渲染。

为什么？如前所述，通过抛出类似承诺的异常来“暂停”渲染。当承诺被解决时，整个组件将被重新呈现。这意味着将再次调用`fetchData`方法，这将导致另一次重新渲染，依此类推。

可能的解决方法是什么？

*   为已解析的承诺创建缓存机制。
*   等待并使用 React 团队正在开发的`cache` API。人体工程学将会像`use(cache(fetchData))`一样增加组合的复杂性。

T4 的 API 还没有看到草案。该功能最有可能在`use`功能发布后登陆。

## 服务器组件上的异步/等待

在服务器组件中实现数据获取的方式略有不同。React 团队声称，这可能会产生积极的影响，因为它迫使开发人员更加小心。他们为什么这么说？因为服务器组件有一些必须牢记的限制。

服务器组件将能够使用标准的`async/await`语法。这里，他们没有违反服务器组件不能访问钩子的规则。他们已经用`useId`钩弯过一次了。

让我们看一个例子:

摘自 RFC 提案的 React 代码示例

以上似乎更自然，也更容易推理。为什么 React 客户端不使用该解决方案？有一些陷阱需要解决。简而言之，它与`async`方法如何工作有关，而且它们将在每次执行时返回一个新的承诺。

这可能会导致任意属性挂起用户界面。更多详情[此处](https://github.com/acdlite/rfcs/blob/first-class-promises/text/0000-first-class-support-for-promises.md#reading-the-result-of-a-promise-during-an-unrelated-update)。

# 怎么可能有戏？

React 有三个释放通道:

*   `**latest**`:针对稳定的反应释放。这是所有 production React 应用程序使用的通道。
*   `**Next**`:你可以把这个当做发布候选通道。第三方项目大多使用。
*   `**Experimental**`:稳定版本中没有的 API 和特性。这是为了试用新版本，因为它们已经发布。你可以把它看作是一个早期的预览。

N *注:只有* `*latest*` *通道使用语义版本化。* `*next*` *和* `*experimental*` *根据其内容的散列和提交日期进行标记。*

所以我们可以继续安装最新的`experimental`版本来快速预览一下`use`钩子。请注意，独家发布的`experimental`改动可能与最终的 React 有所不同。因此，期待突破性的变化，它不应该在面向用户的应用程序中使用。

安装非常简单:

```
yarn upgrade react@**experimental** react-dom@**experimental**
```

完成后，您可以通过使用以下命令开始使用新的草案 API

```
import {**experimental_use as use**} from 'react';
```

# 我的两分钱

我知道 React 团队正朝着设计接口的方向努力，这样我们就可以摆脱加载旋转器的困境。

这是通过将数据获取与所有现有的`Suspense`API(如`useTransition` / `useDeferred`)相结合来实现的……用户将真正受益于不会到处持续显示无关加载状态的界面。他们的浏览器也将受益于不执行组件代码，这些代码会在片刻之后被丢弃。

最令人担忧的是 React 的学习曲线变得更加陡峭。开发人员越来越难以理解和记住每个钩子是如何工作的。更糟糕的是，他们不仅在规则中增加了更多的例外，还根据执行环境改变了语法。理解 React 代码变得非常具有挑战性。

令人惊讶的是，这一切都隐藏在这个简化的界面后面，我们有一种错觉，认为我们在构建纯粹的功能。

这个谜题之所以有效，是因为我们遵守了一些很久以前就开始变得毫无意义的规则。我们如何到达这里？一切都是逐渐发生的。它让我想起了青蛙和沸水的故事。我们现在必须意识到实现细节，而不是消耗声明性 API。当谈到勾手时，我们的大脑必须做大量的体操。

那么解决办法是什么呢？对我来说，React 编译器似乎是唯一的解决方案。让我们以他们基于性能的优化 API 为例。`useCallback` / `useMemo`挂钩应该有助于提高性能。然而，仍然不确定我们希望在哪里使用它们，以及它们何时会增加一些开销。

你能想象没有备忘录 API 的 React 吗？构建`React Forget`编译器是为了将开发者从记忆 API 中抽象出来。在`React Conf 2021`预演过。它仍处于初始阶段，但有望很快着陆。在我看来，这是朝着正确方向迈出的一大步。

有希望的是，React 团队发布并开始扩展编译器的想法。看起来客户端`async/await`的特性和更多的特性可以通过编译器实现。一种想法是编译`async/await`，将组件数据加载到类似生成器的运行时中。这将通过保持一些良好的开发人员工效学来解决问题。

与此同时，继续积累生态系统的逻辑和细微差别变得更加困难。这确实挫败了他们的座右铭，让曾经简单的 UI 库变得令人头疼。

*RFC 建议书原文可以在* [*这里找到*](https://github.com/acdlite/rfcs/blob/first-class-promises/text/0000-first-class-support-for-promises.md#why-cant-client-components-be-async-functions)