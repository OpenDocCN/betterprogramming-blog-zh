<html>
<head>
<title>Bézier Path and Curves Using Core Graphics</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用核心图形的贝塞尔路径和曲线</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/b%C3%A9zier-path-and-curves-using-core-graphics-268fbb77dd80?source=collection_archive---------8-----------------------#2022-01-19">https://betterprogramming.pub/b%C3%A9zier-path-and-curves-using-core-graphics-268fbb77dd80?source=collection_archive---------8-----------------------#2022-01-19</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="8ab1" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">提供优秀的界面</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/45a85c786127453f23e652088ef935a8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*jIcJbDLH7w9aToq9"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated"><a class="ae ky" href="https://unsplash.com/@chrisjoelcampbell?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">克里斯托弗·坎贝尔</a>在<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的照片</p></figure><p id="8e29" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">难度:初级|简单<strong class="lb iu"> </strong> | <strong class="lb iu">普通</strong> |挑战</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="e057" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">先决条件:</h1><ul class=""><li id="4269" class="mu mv it lb b lc mw lf mx li my lm mz lq na lu nb nc nd ne bi translated">能够<a class="ae ky" href="https://medium.com/swlh/your-first-ios-application-using-xcode-9983cf6efb71" rel="noopener">创建一个单视图应用</a>，并且本教程期望你能够适应<a class="ae ky" href="https://medium.com/@stevenpcurtis.sc/subclassing-uiview-d372c67b7f3" rel="noopener">子类化UIView </a></li></ul></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="44b1" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">术语</h1><p id="540f" class="pw-post-body-paragraph kz la it lb b lc mw ju le lf mx jx lh li nf lk ll lm ng lo lp lq nh ls lt lu im bi translated">贝塞尔曲线:用于创建矢量图形的线或路径</p><p id="1adc" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">CGContext:一个图形上下文，包含在目标上绘制所需的绘制参数</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><p id="76f1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">示例应用程序展示了几种创建贝塞尔路径和贝塞尔曲线的方法，显示在<a class="ae ky" href="https://medium.com/@stevenpcurtis.sc/create-a-uistackview-in-a-uiscrollview-e2a959fa061" rel="noopener">可滚动stackview </a>中。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ni nj l"/></div></figure><h1 id="9d54" class="mc md it bd me mf nk mh mi mj nl ml mm jz nm ka mo kc nn kd mq kf no kg ms mt bi translated">核心显卡？</h1><p id="34c0" class="pw-post-body-paragraph kz la it lb b lc mw ju le lf mx jx lh li nf lk ll lm ng lo lp lq nh ls lt lu im bi translated">在Swift中绘制贝塞尔路径有三种方法</p><ul class=""><li id="a2e5" class="mu mv it lb b lc ld lf lg li np lm nq lq nr lu nb nc nd ne bi translated">在<code class="fe ns nt nu nv b">UIView</code>子视图上下文中使用<code class="fe ns nt nu nv b">draw(_:)</code>方法</li><li id="1eb5" class="mu mv it lb b lc nw lf nx li ny lm nz lq oa lu nb nc nd ne bi translated">创造和使用<code class="fe ns nt nu nv b">CAShapeLayer</code></li><li id="3cc6" class="mu mv it lb b lc nw lf nx li ny lm nz lq oa lu nb nc nd ne bi translated">创建并使用一个<code class="fe ns nt nu nv b">CGContext</code>上下文</li></ul><h1 id="a499" class="mc md it bd me mf nk mh mi mj nl ml mm jz nm ka mo kc nn kd mq kf no kg ms mt bi translated">循序渐进的例子— <code class="fe ns nt nu nv b">draw(_:)</code></h1><p id="5898" class="pw-post-body-paragraph kz la it lb b lc mw ju le lf mx jx lh li nf lk ll lm ng lo lp lq nh ls lt lu im bi translated">使用<code class="fe ns nt nu nv b">draw(_:)</code>的简单行相对简单，因为<code class="fe ns nt nu nv b">UIBezierPath()</code>直接写在根层上，因此使用当前上下文，因此不需要显式传递。<code class="fe ns nt nu nv b">stroke()</code>使用当前贝塞尔路径的属性将UIBezierPath添加到当前上下文中。太好了！</p><p id="2f51" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">以下示例使用此方法在屏幕上生成一行:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi ob"><img src="../Images/ebacce719290902271aaa1642d9396c8.png" data-original-src="https://miro.medium.com/v2/resize:fit:800/format:webp/1*8Wjy8uRsGOhXunexgxwu5w.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated"><a class="ae ky" href="https://gist.github.com/stevencurtis/12ca659d6d2d3ca99a30f4f2b7229e24" rel="noopener ugc nofollow" target="_blank">点击查看要点</a></p></figure><p id="226b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这样做的结果是一条简单的蓝线(从屏幕的左上角开始)。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi oc"><img src="../Images/568237260309b71d6b4c063d2d58970f.png" data-original-src="https://miro.medium.com/v2/resize:fit:164/format:webp/1*9CarvcBW27Lzqq51zXJS7g.png"/></div></figure><p id="fc17" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">虽然<code class="fe ns nt nu nv b">draw(_:)</code>是一种很好的方式，因为它提供了上下文，但是重写<code class="fe ns nt nu nv b">draw(_:)</code>也会有性能损失，因为<code class="fe ns nt nu nv b">draw(_:)</code>可以被多次调用。不要害怕，还有其他的方法！</p><h1 id="a7d5" class="mc md it bd me mf nk mh mi mj nl ml mm jz nm ka mo kc nn kd mq kf no kg ms mt bi translated">循序渐进示例— <code class="fe ns nt nu nv b">CAShapeLayer</code></h1><p id="4065" class="pw-post-body-paragraph kz la it lb b lc mw ju le lf mx jx lh li nf lk ll lm ng lo lp lq nh ls lt lu im bi translated">常见的方法是创建一个<code class="fe ns nt nu nv b">UIBezierPath()</code>，然后将其分配给一个<code class="fe ns nt nu nv b">CAShapeLayer()</code>。将成形层创建为子层(而不是遮罩，稍后将详细介绍)。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ob"><img src="../Images/5ef403b8714c485aaee6034eb944ea1a.png" data-original-src="https://miro.medium.com/v2/resize:fit:800/format:webp/1*-sXsFOAhX7mp9Sf5-WbHuw.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated"><a class="ae ky" href="https://gist.github.com/stevencurtis/317bd4b318aec468aaf5e7532ea7e055" rel="noopener ugc nofollow" target="_blank">点击查看要点</a></p></figure><p id="69f4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">由于<code class="fe ns nt nu nv b">CAShapeLayer</code>是一个<code class="fe ns nt nu nv b">CALayerSubclass</code>，我们有机会制作一些有趣的动画。</p><p id="c09f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果我们想从初始化器中调用这个函数，我们可以。这里的第一个将从编程实例化中调用drawLine，第二个从故事板中调用它。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="od nj l"/></div></figure><h1 id="4a5f" class="mc md it bd me mf nk mh mi mj nl ml mm jz nm ka mo kc nn kd mq kf no kg ms mt bi translated">循序渐进的例子— <code class="fe ns nt nu nv b">CGContext</code></h1><p id="66ca" class="pw-post-body-paragraph kz la it lb b lc mw ju le lf mx jx lh li nf lk ll lm ng lo lp lq nh ls lt lu im bi translated">这实际上是第一个例子的扩展，因为<code class="fe ns nt nu nv b">draw(_:)</code>有一个内置的上下文(<code class="fe ns nt nu nv b">UIView</code>图形上下文！)我们可以只要求那个。这就允许我们把<code class="fe ns nt nu nv b">setStrokeColor(_:)</code>和<code class="fe ns nt nu nv b">setLineWidth(_:)</code>放在上下文中。我们可以注意到，我们使用的是<code class="fe ns nt nu nv b">UIColor</code>的<code class="fe ns nt nu nv b">cgColor</code>变体，同样我们添加了一个<code class="fe ns nt nu nv b">CGMutablePath</code>，它(重要的是)被添加到上下文中，尽管这仍然需要通过<code class="fe ns nt nu nv b">strokePath()</code>方法来绘制。</p><p id="07e0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">请注意，这里我们使用了一个<code class="fe ns nt nu nv b">CGMutablePath()</code>来创建我们的行，并完全避免使用<code class="fe ns nt nu nv b">UIBezierPath()</code>！</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi oe"><img src="../Images/e5ae1f8c54aadc5124f1b4756d1ef5d6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*x9ICsK8ISvHf6erWY6_h_A.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated"><a class="ae ky" href="https://gist.github.com/stevencurtis/5b683bc0fb88f1bdde54f975504450cd" rel="noopener ugc nofollow" target="_blank">点击查看要点</a></p></figure><p id="63a3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">因为<code class="fe ns nt nu nv b">CGPath</code>是核心图形的一部分，它比单独使用<code class="fe ns nt nu nv b">UIBezierPath()</code>更加灵活。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="929c" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">考虑</h1><h2 id="c2ea" class="of md it bd me og oh dn mi oi oj dp mm li ok ol mo lm om on mq lq oo op ms oq bi translated">坐标系统</h2><p id="8ec3" class="pw-post-body-paragraph kz la it lb b lc mw ju le lf mx jx lh li nf lk ll lm ng lo lp lq nh ls lt lu im bi translated">在iOS中，与我们从通常的数学中所了解的相比，许多事情都是颠倒的。以坐标系为例:当在iOS(垂直轴)中向底部移动时，Y值增加，而在笛卡尔坐标系(数学)中Y值减少。</p><p id="b460" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">顺便说一下，原点将在设备方向的左上角。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi ob"><img src="../Images/3ac1cd24255c5dca4f88c0bc77474af9.png" data-original-src="https://miro.medium.com/v2/resize:fit:800/format:webp/1*p_-aAfYOpL9gYYZa-tWDCA.png"/></div></figure><p id="34aa" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这很重要，因为如果你在<code class="fe ns nt nu nv b">UIView</code>中操作，你需要使用<code class="fe ns nt nu nv b">func move(to point: CGPoint)</code>(同样的文档提到我们必须在当前坐标系中)。所以那个画线函数？</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="od nj l"/></div></figure><p id="e846" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">将<code class="fe ns nt nu nv b">UIBezierPath</code>移动到原点，然后移动到(50，100)。所以我们期待在这个视图的左上角有一些动作(当然取决于主机<code class="fe ns nt nu nv b">UIView</code>的大小)。</p><h2 id="559f" class="of md it bd me og oh dn mi oi oj dp mm li ok ol mo lm om on mq lq oo op ms oq bi translated">旋转</h2><p id="bb18" class="pw-post-body-paragraph kz la it lb b lc mw ju le lf mx jx lh li nf lk ll lm ng lo lp lq nh ls lt lu im bi translated">贝塞尔路径弧以顺时针方向创建。这实际上是核心图形世界中的弧度(这总是有用的，因为它将长度和角度结合成一种度量，但那是另一种情况)。</p><p id="9c67" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这意味着零度真的面向“左边”。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi ob"><img src="../Images/bd388a885de7232d268f63cff0b97ee0.png" data-original-src="https://miro.medium.com/v2/resize:fit:800/format:webp/1*JG20Npko0JBW2jjR9s2w5A.png"/></div></figure><p id="6f2b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果我们想画一条弧线</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="od nj l"/></div></figure><p id="0914" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">它在应用程序上给出的结果(如repo<a class="ae ky" href="https://github.com/stevencurtis/SwiftCoding/tree/master/BezierPathShapeLayers" rel="noopener ugc nofollow" target="_blank">https://github . com/stevencurtis/swift coding/tree/master/BezierPathShapeLayers</a>)在屏幕上显示如下模式:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi or"><img src="../Images/213484e0b0a1b365af5176ff295841fe.png" data-original-src="https://miro.medium.com/v2/resize:fit:202/format:webp/1*fRwWtGTvFVdb69dCS6Ip-w.png"/></div></figure><p id="8a96" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">也就是说，圆弧从右侧0 <strong class="lb iu"> </strong>处开始，并旋转180°。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="0da9" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">理论—核心图形与贝塞尔路径</h1><h2 id="5cb5" class="of md it bd me og oh dn mi oi oj dp mm li ok ol mo lm om on mq lq oo op ms oq bi translated">贝塞尔路径</h2><p id="ccc9" class="pw-post-body-paragraph kz la it lb b lc mw ju le lf mx jx lh li nf lk ll lm ng lo lp lq nh ls lt lu im bi translated"><code class="fe ns nt nu nv b">UIBezierPath()</code>是一种基于矢量的路径，可用于矢量形状(如矩形)或更复杂的路径。这些可以使用路径本身的绘图属性来填充。包含属性包括<code class="fe ns nt nu nv b">lineWidth</code>、<code class="fe ns nt nu nv b">lineJoinStyle</code>、<code class="fe ns nt nu nv b">lineCapStyle</code>、<code class="fe ns nt nu nv b">miterLimit</code>和<code class="fe ns nt nu nv b">flatness</code>。<code class="fe ns nt nu nv b">UIBezierPath()</code>是<code class="fe ns nt nu nv b">UIKit</code>的一部分而不是核心图形。</p><h2 id="34dd" class="of md it bd me og oh dn mi oi oj dp mm li ok ol mo lm om on mq lq oo op ms oq bi translated">CG上下文</h2><p id="4d4b" class="pw-post-body-paragraph kz la it lb b lc mw ju le lf mx jx lh li nf lk ll lm ng lo lp lq nh ls lt lu im bi translated">因为一个<code class="fe ns nt nu nv b">CGContext</code>表示应该在哪里画点什么，并且上下文可以被告知具体要画什么。绘制位图图像、PDF文件和(本文的重点)绘制到一个<code class="fe ns nt nu nv b">UIView</code>有特定的上下文。当您设置填充颜色或线条宽度时，该设置在整个上下文中保持不变(当然，直到它被更改)。</p><h2 id="33d4" class="of md it bd me og oh dn mi oi oj dp mm li ok ol mo lm om on mq lq oo op ms oq bi translated">CGMutablePath</h2><p id="0d40" class="pw-post-body-paragraph kz la it lb b lc mw ju le lf mx jx lh li nf lk ll lm ng lo lp lq nh ls lt lu im bi translated">这是(obvs。)CGPath的可变版本，它是可以在特定上下文中绘制的形状的数学描述。绘图属性是CGContext的一部分，而不是CGPath的一部分；也就是说，CGPath没有任何线条粗细或颜色属性。</p><h2 id="11f6" class="of md it bd me og oh dn mi oi oj dp mm li ok ol mo lm om on mq lq oo op ms oq bi translated">核心图形</h2><p id="d726" class="pw-post-body-paragraph kz la it lb b lc mw ju le lf mx jx lh li nf lk ll lm ng lo lp lq nh ls lt lu im bi translated">Core graphics是一个有趣的框架，可以用来定制你的UI，甚至可以在你使用的时候添加很棒的动画效果。这当然是一个伟大的方式来绘制形状和创造形状与梯度和…等等…</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="46ca" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">结论</h1><p id="4caf" class="pw-post-body-paragraph kz la it lb b lc mw ju le lf mx jx lh li nf lk ll lm ng lo lp lq nh ls lt lu im bi translated">像编程中的许多事情一样，这很容易或很难，就像你希望的那样。换句话说，当你做对了，你就做了一次。换句话说，复杂性让事情变得更简单。换句话说，按你的方式去做。换句话说:您需要在您的特定项目中选择最后两个实现中的哪一个。你决定！</p><p id="c58e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果你有任何问题，我很乐意在Twitter上听到你的声音。</p><p id="48d1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">使用<a class="ae ky" href="https://stevenpcurtis.medium.com/membership" rel="noopener">订阅媒体这个链接</a>与我分享一些收入。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="33de" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">扩展你的知识</h1><ul class=""><li id="70dc" class="mu mv it lb b lc mw lf mx li my lm mz lq na lu nb nc nd ne bi translated"><a class="ae ky" href="https://developer.apple.com/library/archive/documentation/2DDrawing/Conceptual/DrawingPrintingiOS/GraphicsDrawingOverview/GraphicsDrawingOverview.html#//apple_ref/doc/uid/TP40010156-CH14-SW5" rel="noopener ugc nofollow" target="_blank">苹果公司已经在概念上创建了关于在iOS中绘制</a>的文档</li></ul></div></div>    
</body>
</html>