<html>
<head>
<title>The Beginner’s Guide to View Modifiers in SwiftUI</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">在SwiftUI中查看修改器的初学者指南</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/a-beginners-guide-to-view-modifiers-in-swiftui-8782c3e44d75?source=collection_archive---------3-----------------------#2020-05-08">https://betterprogramming.pub/a-beginners-guide-to-view-modifiers-in-swiftui-8782c3e44d75?source=collection_archive---------3-----------------------#2020-05-08</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="3728" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">创建包含其他元素的自定义SwiftUI元素</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/9fd66b41f4ef2eff9d45b6935cb7160e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*SABnYfT-DtAuwGOgkqs79g.jpeg"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">照片由<a class="ae kv" href="https://unsplash.com/@sortino?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">约书亚·索蒂诺</a>在<a class="ae kv" href="https://unsplash.com/s/photos/abstract?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</p></figure><p id="5abe" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">保持UI的一致性，同时保持代码库的整洁是必须的。但是我们如何在SwiftUI中实现这一点呢？</p><p id="3310" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">开发一个喜爱的/严肃的项目是学习一个新框架或范例的完美方式。SwiftUI也不例外。</p><p id="1fae" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在这样做的时候，我偶然发现必须在几个屏幕上使用相同的组件:标题、副标题和按钮。在项目中为不同的UI构建块提供迷你UI库非常有帮助。</p></div><div class="ab cl ls lt hu lu" role="separator"><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx"/></div><div class="ij ik il im in"><h1 id="1b36" class="lz ma iq bd mb mc md me mf mg mh mi mj jw mk jx ml jz mm ka mn kc mo kd mp mq bi translated">什么是视图修改器？</h1><p id="0ad7" class="pw-post-body-paragraph kw kx iq ky b kz mr jr lb lc ms ju le lf mt lh li lj mu ll lm ln mv lp lq lr ij bi translated">在SwiftUI中，我们可以通过视图修改器将现有的UI组件(如<code class="fe mw mx my mz b">Text</code>、<code class="fe mw mx my mz b">TextField</code>和<code class="fe mw mx my mz b">Button</code>)与我们自己的共享样式一起使用。</p><p id="4b15" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">一个<em class="na">视图修饰符</em>是视图实例的一个方法。它的作用是:</p><ul class=""><li id="1ea2" class="nb nc iq ky b kz la lc ld lf nd lj ne ln nf lr ng nh ni nj bi translated">采用视图(或另一个修改器)</li><li id="4530" class="nb nc iq ky b kz nk lc nl lf nm lj nn ln no lr ng nh ni nj bi translated">制作视图的副本</li><li id="1e2a" class="nb nc iq ky b kz nk lc nl lf nm lj nn ln no lr ng nh ni nj bi translated">在对其样式进行一些更改后，返回修改后的视图。</li></ul><p id="b462" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">如果您已经尝试过使用SwiftUI构建UI，那么您有99%的可能使用过视图修改器。有一些内置的修改器可以帮助你改变屏幕的形状。要获得完整的列表，您可以浏览文档。</p><p id="aa1c" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在Xcode中，在源代码编辑器中“按住Option键点按视图”，然后点按“在开发人员文稿中打开”</p><p id="f8ec" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">最简单的例子是对<code class="fe mw mx my mz b">Text</code>视图应用填充或字体:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="np nq l"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">向文本组件添加字体、颜色和填充</p></figure><p id="12f1" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这是我们应用这些修改器后的结果:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nr"><img src="../Images/c4b14f5f15385775e2434dc32b72de93.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*fEBZEH4Bkx8enFbr.png"/></div></div></figure></div><div class="ab cl ls lt hu lu" role="separator"><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx"/></div><div class="ij ik il im in"><h1 id="eb52" class="lz ma iq bd mb mc md me mf mg mh mi mj jw mk jx ml jz mm ka mn kc mo kd mp mq bi translated">排序视图修改器</h1><p id="72eb" class="pw-post-body-paragraph kw kx iq ky b kz mr jr lb lc ms ju le lf mt lh li lj mu ll lm ln mv lp lq lr ij bi translated">要记住的一点是，有时应用视图修饰符的顺序会影响UI的结果。有时并不是这样。</p><p id="d721" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在我们的示例中，以下内容具有相同的结果(如最后一幅图所示)。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="np nq l"/></div></figure><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="np nq l"/></div></figure><p id="27c1" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">"使用标题字体并使其为紫色" = "使其为紫色并使用标题字体。"</p><p id="a64a" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">但是如果你想添加背景色，那就另当别论了。下面你添加一个橙色背景，然后一些填充。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="np nq l"/></div></figure><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi ns"><img src="../Images/0ffb65c8299fe839ff93e5263425fce7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*LxE9Z8-zGY-h7FeA.png"/></div></div></figure><p id="3359" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这里你添加填充，然后一个橙色背景。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="np nq l"/></div></figure><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nt"><img src="../Images/c548c48e6bcd0a8266bba38c8d14ac57.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*yxHLGygNUBrCjqjE.png"/></div></div></figure><h2 id="e690" class="nu ma iq bd mb nv nw dn mf nx ny dp mj lf nz oa ml lj ob oc mn ln od oe mp of bi translated">解释时间</h2><p id="3d3f" class="pw-post-body-paragraph kw kx iq ky b kz mr jr lb lc ms ju le lf mt lh li lj mu ll lm ln mv lp lq lr ij bi translated"><code class="fe mw mx my mz b">.padding()</code>是一个增加视图周围间距的修饰符。这里调用它时没有参数，所以SwiftUI在顶部、左侧、底部和右侧添加了默认填充。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="np nq l"/></div></figure><p id="0861" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">如果没有参数，SwiftUI会在所有四个方向添加默认填充，但您可以自己配置该填充。示例:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="np nq l"/></div></figure><p id="453f" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在第一个示例中，首先应用背景色，然后应用间距。</p><p id="6cd8" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在第二个例子中，当您首先应用<code class="fe mw mx my mz b">padding</code>时，背景颜色被应用到不同的放大视图。</p><p id="6b08" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">为了更好地说明问题，请尝试在填充前后添加背景色。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="np nq l"/></div></figure><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi og"><img src="../Images/c7439fa65f52bd09937f80c6639de8e5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*gKt-0qnP6fDa7JtA.png"/></div></div></figure><p id="1520" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">填充在文本和视图边缘之间增加了一些空间。红色背景色应用于仅包含文本的视图。填充修改器产生一个新视图，橙色背景应用于该视图。</p><p id="3820" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">有时，您可以使用这种方法来直观地调试更复杂的预览(例如，检查填充、边框、定位等)。).就像来自React原生世界的<code class="fe mw mx my mz b">{ borderWidth: 1 }</code>。</p></div><div class="ab cl ls lt hu lu" role="separator"><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx"/></div><div class="ij ik il im in"><h1 id="b9e3" class="lz ma iq bd mb mc md me mf mg mh mi mj jw mk jx ml jz mm ka mn kc mo kd mp mq bi translated">自定义视图修改器</h1><p id="a40c" class="pw-post-body-paragraph kw kx iq ky b kz mr jr lb lc ms ju le lf mt lh li lj mu ll lm ln mv lp lq lr ij bi translated">这太好了。但是如果你在整个应用程序中有几个紫色的标题呢？每次都告诉短信“做一个带填充的紫色标题”并不是一个好的解决方案，不是吗？</p><p id="62de" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">你可能会说，“我希望能够写出这样的东西”:</p><p id="56f6" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><code class="fe mw mx my mz b">Text("Cool headline").purpleHeadline()</code></p><p id="1301" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">幸运的是，我们可以在内置修改器的基础上创建自己的修改器。我们可以给它们起相应的名字。</p><p id="d0de" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我知道你很忙，所以代码如下:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="np nq l"/></div></figure><p id="7edd" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">首先，创建一个实现<code class="fe mw mx my mz b">ViewModifier</code>协议的<code class="fe mw mx my mz b">struct</code>。</p><p id="247a" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">然后，实现<code class="fe mw mx my mz b">func body(content: Content)</code>函数，在这里你将应用所有你需要的修改器。</p><h2 id="876c" class="nu ma iq bd mb nv nw dn mf nx ny dp mj lf nz oa ml lj ob oc mn ln od oe mp of bi translated">解释时间</h2><p id="0bee" class="pw-post-body-paragraph kw kx iq ky b kz mr jr lb lc ms ju le lf mt lh li lj mu ll lm ln mv lp lq lr ij bi translated">它所做的是获取视图(内容)并使用应用的修饰符返回它。因为我们将这个自定义修改器应用到一个视图，所以我们可以向它添加一个扩展:</p><ul class=""><li id="d096" class="nb nc iq ky b kz la lc ld lf nd lj ne ln nf lr ng nh ni nj bi translated">您可以随意命名该函数</li><li id="51d4" class="nb nc iq ky b kz nk lc nl lf nm lj nn ln no lr ng nh ni nj bi translated">确保它返回<code class="fe mw mx my mz b">some View</code></li></ul><p id="f6ad" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在创建的方法中，指定要应用的内容和自定义修饰符。</p><p id="84c1" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><code class="fe mw mx my mz b">ModifiedContent</code>表示应用了视图修饰符的包装器值。</p><p id="af6a" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">现在写<code class="fe mw mx my mz b">Text("Cool headline").purpleHeadline()</code>就有意义了。</p></div><div class="ab cl ls lt hu lu" role="separator"><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx"/></div><div class="ij ik il im in"><h1 id="1aca" class="lz ma iq bd mb mc md me mf mg mh mi mj jw mk jx ml jz mm ka mn kc mo kd mp mq bi translated">带参数的修饰符</h1><p id="498a" class="pw-post-body-paragraph kw kx iq ky b kz mr jr lb lc ms ju le lf mt lh li lj mu ll lm ln mv lp lq lr ij bi translated">什么？定制你的自定义修改器？也许用一些值作为参数？</p><p id="966e" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我还以为你不会问呢！</p><p id="d53b" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">当然，我们的自定义视图修改器可以带参数。我们要做的是在结构中或者在<code class="fe mw mx my mz b">init</code>方法中指定它们，如果你需要更多的定制(基于那些值)。</p><p id="9b57" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">例如，让我们创建另一个向视图添加边框的自定义修改器。除此之外，我们将指定边框宽度和半径。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="np nq l"/></div></figure><p id="f05f" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">归根结底，视图修饰符只是一个<code class="fe mw mx my mz b">struct</code>，所以我们可以利用存储的属性。在这个例子中，我们使用<code class="fe mw mx my mz b">borderRadius</code>和<code class="fe mw mx my mz b">borderWidth</code>来定制覆盖。</p><p id="0674" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">用法:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="np nq l"/></div></figure><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi oh"><img src="../Images/ba3e00a1d0015de3fa74290f08f34565.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*4UmSWdMQ0uXXECci.png"/></div></div></figure></div><div class="ab cl ls lt hu lu" role="separator"><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx"/></div><div class="ij ik il im in"><h1 id="4048" class="lz ma iq bd mb mc md me mf mg mh mi mj jw mk jx ml jz mm ka mn kc mo kd mp mq bi translated">从这里去哪里</h1><p id="addf" class="pw-post-body-paragraph kw kx iq ky b kz mr jr lb lc ms ju le lf mt lh li lj mu ll lm ln mv lp lq lr ij bi translated">你不应该不使用任何你需要的修饰语。有很多选项可以用来修改UI控件在屏幕上的外观，比如大小、粗细、覆盖、圆角半径。</p><p id="744b" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">大多数时候，你不会记得修饰语和他们的签名。这就是为什么你应该使用文档。</p><p id="dccb" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">总是使用Apple Docs，所以我再写一遍:在Xcode中，在源代码编辑器中的任何视图上“按住Option键点按”，然后点按“在开发者文档中打开”</p><p id="3c56" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在下一篇文章中，我将讨论在按钮上应用视图修改器，以及我们如何开始拥有一个适合SwiftUI项目的迷你UI库。跟紧了。</p></div></div>    
</body>
</html>