<html>
<head>
<title>Everything You Wanted to Know About Closures in Swift</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">关于Swift中的闭包，你想知道的一切</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/everything-you-wanted-to-know-about-closures-in-swift-e7d3a6ff5a74?source=collection_archive---------11-----------------------#2020-02-04">https://betterprogramming.pub/everything-you-wanted-to-know-about-closures-in-swift-e7d3a6ff5a74?source=collection_archive---------11-----------------------#2020-02-04</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="5d86" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">深入探究Swift中的闭包，包括语法和基础知识</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/b3ed7ec280c708b296c7b29acc417639.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*E8dtcW7fEoJc7qw20_rTKg.jpeg"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">照片由<a class="ae ky" href="https://unsplash.com/@seanlimm?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">肖恩·林</a>在<a class="ae ky" href="https://unsplash.com/s/photos/programming?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>拍摄</p></figure><h1 id="198f" class="kz la it bd lb lc ld le lf lg lh li lj jz lk ka ll kc lm kd ln kf lo kg lp lq bi translated">介绍</h1><p id="ca39" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">许多编程语言都有一个特性，涉及到匿名函数的使用，该函数包含执行定义任务的代码块——就像C#和Python中的lambdas。</p><p id="31e2" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">例如，在下面的Python代码片段中，我们在<code class="fe ms mt mu mv b">sorted()</code>函数中使用了一个lambda，以粗体突出显示，使用指定的键对字典列表进行排序(如之前的<a class="ae ky" href="https://medium.com/better-programming/how-to-use-for-loops-better-in-python-1dfbc3d9e91f" rel="noopener">文章</a>所示)。</p><pre class="kj kk kl km gt mw mv mx my aw mz bi"><span id="f1d9" class="na la it mv b gy nb nc l nd ne">&gt;&gt;&gt; for student in sorted(students, key = <strong class="mv iu">lambda i: i["id"]</strong>, reverse=True):<br/>...     print(student)<br/>... <br/>{'name': 'Jennifer', 'id': 3}<br/>{'name': 'Sandra', 'id': 2}<br/>{'name': 'John', 'id': 1}</span></pre><h2 id="a175" class="na la it bd lb nf ng dn lf nh ni dp lj ma nj nk ll me nl nm ln mi nn no lp np bi translated">闭包的定义</h2><p id="19fb" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">作为一种现代语言，Swift有一个类似的匿名函数概念——称为<em class="nq">闭包</em>——服务于这个目的。<a class="ae ky" href="https://swift.org/documentation/" rel="noopener ugc nofollow" target="_blank">官方文件</a>对关闭的定义如下:</p><blockquote class="nr ns nt"><p id="c868" class="lr ls nq lt b lu mn ju lw lx mo jx lz nu mp mc md nv mq mg mh nw mr mk ml mm im bi translated">"闭包是自包含的功能块，可以在代码中传递和使用."</p></blockquote><p id="9c3b" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">有几个关键短语值得强调。如果这些要点对您来说不简单，也不用担心，因为我们将在下一节看到Swift中的一些常见示例。</p><ul class=""><li id="a3f7" class="nx ny it lt b lu mn lx mo ma nz me oa mi ob mm oc od oe of bi translated"><strong class="lt iu">“独立的功能块”</strong>意味着一个闭包，从整体上来说，意味着在其范围内执行完全定义的任务或功能。</li><li id="9e4d" class="nx ny it lt b lu og lx oh ma oi me oj mi ok mm oc od oe of bi translated"><strong class="lt iu">“被传递和使用”</strong>意味着闭包可以被用作函数中的参数，我们可以在调用该函数时指定它。</li></ul><p id="f854" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">与其他编程语言相比，Swift中的闭包更广泛，因为它们不仅仅是作为函数调用一部分的匿名函数。以下是Swift中可用闭包类型的快速总结。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ol om l"/></div></figure><p id="46ec" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">如上表所示，Swift中有三种类型的闭包，分别是全局函数、嵌套函数和闭包表达式。它们在几个方面有所不同，包括它们的使用范围、它们的名称以及它们是否捕获值，这些将在后面的部分中详细讨论。</p><p id="3749" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">由于全局函数和嵌套函数或多或少类似于常规函数，这不是本文的重点，所以其余部分将只关注闭包表达式(除非另有说明)。</p><h2 id="d261" class="na la it bd lb nf ng dn lf nh ni dp lj ma nj nk ll me nl nm ln mi nn no lp np bi translated">内置闭合</h2><p id="d031" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">在很多情况下，我们不需要在自己的项目中编写闭包。但是标准库中相当多的函数——以及一些常见的框架(例如<code class="fe ms mt mu mv b">UIKit</code>)都使用闭包。下面的代码片段向您展示了在数组上使用<code class="fe ms mt mu mv b">map(_:)</code>方法和在<code class="fe ms mt mu mv b">UIViewController</code>上使用<code class="fe ms mt mu mv b">present(_:animated:completion:)</code>方法。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ol om l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">Swift中的内置闭包</p></figure><p id="905e" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">您可能注意到，第3行和第10-12行的花括号中包含的代码是闭包。对于不熟悉Swift关闭的人来说，可能会产生几个问题。</p><ul class=""><li id="b6dc" class="nx ny it lt b lu mn lx mo ma nz me oa mi ob mm oc od oe of bi translated">当我们调用<code class="fe ms mt mu mv b">map(_:)</code>方法时，为什么没有括号？</li><li id="0b5d" class="nx ny it lt b lu og lx oh ma oi me oj mi ok mm oc od oe of bi translated">美元符号(<code class="fe ms mt mu mv b">$</code>)是什么意思？</li><li id="55ff" class="nx ny it lt b lu og lx oh ma oi me oj mi ok mm oc od oe of bi translated">为什么闭包在<code class="fe ms mt mu mv b">present(_:animated:completion:)</code>方法的括号之外？</li></ul></div><div class="ab cl on oo hx op" role="separator"><span class="oq bw bk or os ot"/><span class="oq bw bk or os ot"/><span class="oq bw bk or os"/></div><div class="im in io ip iq"><h1 id="f544" class="kz la it bd lb lc ou le lf lg ov li lj jz ow ka ll kc ox kd ln kf oy kg lp lq bi translated">语法概述</h1><h2 id="d596" class="na la it bd lb nf ng dn lf nh ni dp lj ma nj nk ll me nl nm ln mi nn no lp np bi translated">一般形式</h2><p id="f40f" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">闭包的一般形式如下面的代码片段所示。具体来说，有四个关键组成部分。</p><pre class="kj kk kl km gt mw mv mx my aw mz bi"><span id="6b43" class="na la it mv b gy nb nc l nd ne">{ (parameters) -&gt; <!-- -->returned<!-- --> in<br/>    statements<br/>}</span></pre><ul class=""><li id="7788" class="nx ny it lt b lu mn lx mo ma nz me oa mi ob mm oc od oe of bi translated"><strong class="lt iu">参数:</strong>闭包中的参数(称为<code class="fe ms mt mu mv b">parameters</code>，如上所述)就像函数中的参数一样。一个闭包可以有零个或多个参数，它们可以是标准的数据类型，比如整数、字符串、定制的结构和类，以及元组。</li><li id="5c19" class="nx ny it lt b lu og lx oh ma oi me oj mi ok mm oc od oe of bi translated"><strong class="lt iu">返回数据类型:</strong>我们需要为给定的闭包指定返回数据类型(称为<code class="fe ms mt mu mv b">returned</code>，如上所述)。像参数一样，闭包返回的数据类型也是灵活的——标准或定制数据类型都是可以接受的。此外，<code class="fe ms mt mu mv b">Void</code>也是一个有效的返回数据类型，这意味着本质上闭包体不需要返回任何东西。</li><li id="aeb6" class="nx ny it lt b lu og lx oh ma oi me oj mi ok mm oc od oe of bi translated"><strong class="lt iu">关键字</strong><code class="fe ms mt mu mv b"><strong class="lt iu">in:</strong></code><strong class="lt iu"/><code class="fe ms mt mu mv b">in</code>关键字用在定义参数和返回数据类型之后，闭包体之前。</li><li id="c147" class="nx ny it lt b lu og lx oh ma oi me oj mi ok mm oc od oe of bi translated"><strong class="lt iu">封体。</strong>在闭包体内(如上所述，称为<code class="fe ms mt mu mv b">statements</code>，我们编写使用<code class="fe ms mt mu mv b">parameters</code>并生成<code class="fe ms mt mu mv b">returned</code>数据的代码。</li></ul><h2 id="615c" class="na la it bd lb nf ng dn lf nh ni dp lj ma nj nk ll me nl nm ln mi nn no lp np bi translated">缩写形式</h2><p id="f4c7" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">无论您是否在“Swift内置闭包”片段中注意到了这一点，无论是<code class="fe ms mt mu mv b">map(_:)</code>还是<code class="fe ms mt mu mv b">present(_:animated:completion:)</code>方法都没有使用通用形式。</p><p id="65f1" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">例如，两者都没有<code class="fe ms mt mu mv b">in</code>关键字，也不返回任何数据。但是为什么它们仍然是没有语法错误的有效闭包呢？</p><p id="6f7b" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">这个问题把我们带到了闭包的简化形式。实际上，有几种方法可以缩短闭包的一般形式。出于演示的目的，使用上面的<code class="fe ms mt mu mv b">map(_:)</code>方法作为例子，让我们首先以通用的形式编写这个方法。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ol om l"/></div></figure><p id="763a" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">如您所料，我们在一个完整的闭包中包含了所有四个元素。参数有一个，就是<code class="fe ms mt mu mv b">String</code>数据类型。返回的数据类型也是<code class="fe ms mt mu mv b">String</code>。我们使用<code class="fe ms mt mu mv b">in</code>关键字来引入闭包体，它以大写形式返回<code class="fe ms mt mu mv b">String</code>。</p><p id="1eab" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated"><strong class="lt iu">场景1:隐式返回数据类型</strong></p><p id="3425" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">因为闭包体内的语句在其返回数据方面是显式的，所以我们可以省略闭包中的返回数据类型。换句话说，编译器将从闭包体中推断返回类型。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ol om l"/></div></figure><p id="8021" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated"><strong class="lt iu">场景2:隐式参数数据类型</strong></p><p id="ef34" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">由于数组是<code class="fe ms mt mu mv b">String</code>类型，因此可以推断数组的元素是<code class="fe ms mt mu mv b">String</code>。因此，我们可以更进一步，省略参数的类型，如下所示:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ol om l"/></div></figure><p id="e0cd" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">由于参数没有指定类型，我们实际上可以省略括号。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ol om l"/></div></figure><p id="8996" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated"><strong class="lt iu">场景三:省略</strong> <code class="fe ms mt mu mv b"><strong class="lt iu">return</strong></code> <strong class="lt iu">关键词</strong></p><p id="cb10" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">另一种特殊情况是闭包体只是一个表达式。您实际上可以省略<code class="fe ms mt mu mv b">return</code>关键字，并将闭包体放在<code class="fe ms mt mu mv b">in</code>关键字之后。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ol om l"/></div></figure><p id="0da4" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated"><strong class="lt iu">场景</strong> <strong class="lt iu"> 4:人手不足的论点mames </strong></p><p id="0ff5" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">在Swift中使用闭包的一个很酷的特性是，会为内联的<strong class="lt iu"> </strong>闭包自动创建一组简写的参数名。具体来说，您使用一个带有美元符号前缀的数字，如<code class="fe ms mt mu mv b">$0</code>、<code class="fe ms mt mu mv b">$1</code>和<code class="fe ms mt mu mv b">$2</code>，分别指代第一个、第二个和第三个参数。</p><p id="30bd" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">当使用这些简写的参数名时，我们可以省略闭包的参数以及它们的数据类型，因为它们都可以从预期的函数类型中推断出来。此外，我们可以省略<code class="fe ms mt mu mv b">in</code>关键字，这样闭包将完全由它的主体组成，如下所示:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ol om l"/></div></figure><p id="8b2b" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated"><strong class="lt iu">场景5:尾随闭包</strong></p><p id="9d0f" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">您可能已经注意到，经过上述步骤后，闭包几乎与本文开头给出的例子中的闭包相同。唯一的区别是一对括号。为什么允许他们遗漏？</p><p id="41a1" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">同样，这是Swift中闭包的另一个便利特性。当闭包要作为函数的最终参数传递时，我们可以省略括号，将闭包写成一个<em class="nq">结尾的闭包</em>。</p><p id="bcf4" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">基本上，尾随闭包由直接跟在函数括号后面的闭包体组成。此外，如果闭包是函数中唯一的参数，我们可以进一步省略括号，就像我们在开始时对<code class="fe ms mt mu mv b">map(_:)</code>方法所做的那样。此外，当我们使用尾随闭包语法时，我们还会省略闭包的参数标签。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ol om l"/></div></figure></div><div class="ab cl on oo hx op" role="separator"><span class="oq bw bk or os ot"/><span class="oq bw bk or os ot"/><span class="oq bw bk or os"/></div><div class="im in io ip iq"><h1 id="96ae" class="kz la it bd lb lc ou le lf lg ov li lj jz ow ka ll kc ox kd ln kf oy kg lp lq bi translated">关键概念</h1><p id="3d27" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">前一节回顾了闭包的语法。在项目中正确使用闭包之前，我们需要理解几个关键概念。</p><h2 id="357b" class="na la it bd lb nf ng dn lf nh ni dp lj ma nj nk ll me nl nm ln mi nn no lp np bi translated">1.价值捕捉</h2><p id="2785" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">第一个概念叫做<em class="nq">价值捕捉。</em>它指的是使用闭包时的实例，它从定义它的周围上下文中捕获所用常量和变量的值。</p><p id="ccb5" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">这意味着，即使闭包周围环境中的常量和变量变得不可用或发生了变化，闭包仍然可以在其作用域内对这些参数的值进行操作。</p><p id="8992" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">为了向您展示一个关于值捕获的快速示例，让我们首先创建一个名为<code class="fe ms mt mu mv b">visitCountry()</code>的函数，它返回一个闭包。我们可以将返回的闭包赋给一个名为<code class="fe ms mt mu mv b">helloWorld</code>的变量。当我们迭代<code class="fe ms mt mu mv b">countries</code>数组时，我们可以将每个元素传递给<code class="fe ms mt mu mv b">helloWorld</code>闭包，它将在闭包体内打印指定的语句。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ol om l"/></div></figure><p id="60df" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">如果我们想记录去过的国家的数量呢？让我们稍微修改一下代码来实现这一点。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ol om l"/></div></figure><p id="f7d2" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">有些人可能会错误地认为计数器变量<code class="fe ms mt mu mv b">numberOfCountriesVisited</code>的值总是为<code class="fe ms mt mu mv b">1</code>。然而，由于闭包的值捕获，每次我们调用闭包时，它的值都会增加1。换句话说，<code class="fe ms mt mu mv b">helloWorld</code>闭包捕获了<code class="fe ms mt mu mv b">numberOfCountriesVisited</code>变量的值。</p><p id="56cb" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">为了进一步说明这种情况，我们可以从<code class="fe ms mt mu mv b">visitCountry()</code>函数中创建另一个名为<code class="fe ms mt mu mv b">helloAsia</code>的闭包。下面的代码片段向您展示了相同的值捕获现象。值得注意的是，由于<code class="fe ms mt mu mv b">helloAsia</code>与<code class="fe ms mt mu mv b">helloWorld</code>不同，它有自己的计数器来跟踪访问过的国家的数量。这解释了为什么新闭包的计数器变量<code class="fe ms mt mu mv b">numberOfCountriesVisited</code>在<code class="fe ms mt mu mv b">1</code>开始。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ol om l"/></div></figure><h2 id="d56a" class="na la it bd lb nf ng dn lf nh ni dp lj ma nj nk ll me nl nm ln mi nn no lp np bi translated">2.参考类型</h2><p id="9bbc" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">正确使用闭包的另一个关键概念是闭包是引用类型，就像函数一样。这实际上是调用<code class="fe ms mt mu mv b">helloWorld</code>闭包会导致计数器变量递增的根本原因。因为<code class="fe ms mt mu mv b">helloWorld</code>闭包是一个引用类型，多次调用它会增加闭包捕获的相同计数器。</p><p id="add7" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">为了向您展示闭包是一个引用，我们可以按照上面关于亚洲国家的代码片段尝试下面的代码。简单地说，我们将<code class="fe ms mt mu mv b">helloAsia</code>赋给另一个名为<code class="fe ms mt mu mv b">visitAsia</code>的变量。毫不奇怪，当我们调用<code class="fe ms mt mu mv b">visitAsia</code>闭包时，它会将计数器改为<code class="fe ms mt mu mv b">4</code>。<code class="fe ms mt mu mv b">helloAsia</code>和<code class="fe ms mt mu mv b">visitAsia</code>都是相同的闭包，它们捕获相同的计数器，其值为<code class="fe ms mt mu mv b">3</code>。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ol om l"/></div></figure><h2 id="80f3" class="na la it bd lb nf ng dn lf nh ni dp lj ma nj nk ll me nl nm ln mi nn no lp np bi translated">3.逃避</h2><p id="224a" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">Swift闭包的另一个重要特性是支持在闭包作为参数传递时对函数进行转义。为了声明一个可以转义的闭包，我们在闭包之前使用了<code class="fe ms mt mu mv b">@escaping</code>关键字。这里有一个涉及转义闭包的函数的简单例子。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ol om l"/></div></figure><p id="1b66" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">上面的代码片段向您展示了转义闭包的一个非常常见的用例。具体来说，该代码用于在后台线程中获取一些数据。完成后，我们可以相应地更新用户界面。</p><p id="ae8b" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">当您查看打印的语句时，有趣的是注意到<code class="fe ms mt mu mv b">“just a log statement”</code>在<code class="fe ms mt mu mv b">“data fetched”</code>语句之前打印。这实际上是预期的行为。只是因为<code class="fe ms mt mu mv b">fetchDataRemotely(_:)</code>函数在开始闭包的操作之前先返回隐式的<code class="fe ms mt mu mv b">Void</code>数据。换句话说，在完成<code class="fe ms mt mu mv b">fetchDataRemotely(_:)</code>函数之前，不会调用<code class="fe ms mt mu mv b">completionHandler</code>闭包。</p></div><div class="ab cl on oo hx op" role="separator"><span class="oq bw bk or os ot"/><span class="oq bw bk or os ot"/><span class="oq bw bk or os"/></div><div class="im in io ip iq"><h1 id="9b0e" class="kz la it bd lb lc ou le lf lg ov li lj jz ow ka ll kc ox kd ln kf oy kg lp lq bi translated">结论</h1><p id="0637" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">在本教程中，我们学习了Swift中的闭包。</p><p id="a885" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">具体来说，我们回顾了闭包的语法，并讨论了一些重要的概念，这些概念对于理解闭包在项目中的正确使用是必要的。</p></div></div>    
</body>
</html>