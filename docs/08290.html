<html>
<head>
<title>7 Common JavaScript Bugs You Can Now Avoid</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">您现在可以避免的7个常见JavaScript错误</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/7-common-javascript-bugs-you-can-now-avoid-27d41c8d81c2?source=collection_archive---------4-----------------------#2021-04-14">https://betterprogramming.pub/7-common-javascript-bugs-you-can-now-avoid-27d41c8d81c2?source=collection_archive---------4-----------------------#2021-04-14</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="14d4" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">同名函数、不精确的十进制算术、在循环中创建回调、丢失上下文等等</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/6a5c3aa241cb91d4bb48b910e44287ed.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*F1OxkWtS9ZMXxEykt03EUg.jpeg"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">尼古拉斯·皮卡德在<a class="ae ky" href="https://unsplash.com/s/photos/vintage-tools?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</p></figure><p id="6624" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在本文中，我们将看看JavaScript中可能遇到的一些常见错误，理解它们为什么会发生，并学习如何避免它们。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="1347" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">1.定义两个同名的函数</h1><p id="3e73" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">如果你来自Java或。在. NET中，方法可以被重载，你可以试着创建两个名字相同但签名不同的函数<a class="ae ky" rel="noopener ugc nofollow" target="_blank" href="/10-fundamentals-you-need-to-know-about-functions-in-javascript-8e74579b7a9a">并期望语言根据提供的参数选择正确的函数。</a></p><p id="af5a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">考虑下面的例子，我们有两个同名但参数数量不同的函数:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mz na l"/></div></figure><p id="38fe" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">调用<code class="fe nb nc nd ne b">sum(1, 2)</code>的结果是<code class="fe nb nc nd ne b">NaN</code>。我们来了解一下原因。</p><p id="254b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">首先，JavaScript中的函数不一定是方法。在这个例子中，它们只是独立的函数。第二，语言中不支持重载函数。</p><p id="6d56" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">当我们用相同的名字定义几个函数时，最后一个覆盖了所有其他的定义。调用函数时，会调用最后定义的函数。在我们的例子中，这意味着调用<code class="fe nb nc nd ne b">sum</code>函数，期望三个参数中只有两个。在这种情况下，最后一个参数被设置为<code class="fe nb nc nd ne b">undefined</code>。与<code class="fe nb nc nd ne b">undefined</code>的算术运算产生<code class="fe nb nc nd ne b">NaN</code>。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="31c2" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">2.做连接而不是加法</h1><p id="bbac" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">您可能希望从UI中读取一些数字，然后将它们相加。</p><p id="ed51" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">考虑下面的HTML表单，它有两个输入，代码从这些输入中读取数据并将它们的值相加:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mz na l"/></div></figure><p id="a955" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">为了简化，示例可能如下所示:</p><pre class="kj kk kl km gt nf ne ng nh aw ni bi"><span id="67b6" class="nj md it ne b gy nk nl l nm nn">const no1 = '1';<br/>const no2 = '2';<br/>const sum = no1 + no2;<br/>//'12'</span></pre><p id="0c95" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在许多情况下，从UI中读取的值是字符串，加号(<code class="fe nb nc nd ne b">+</code>)操作符既是加法操作符，也是连接操作符。当其中一个操作数是字符串时，另一个操作数被转换为字符串并执行连接:</p><pre class="kj kk kl km gt nf ne ng nh aw ni bi"><span id="39ff" class="nj md it ne b gy nk nl l nm nn">const no1 = 1;<br/>const no2 = '2';<br/>const sum = no1 + no2;<br/>//'12'</span></pre><p id="22f7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">为了避免这个问题，我们需要确保所有的值都是数字。内置的<code class="fe nb nc nd ne b">Number</code>函数可以用来将字符串转换成数字:</p><pre class="kj kk kl km gt nf ne ng nh aw ni bi"><span id="e9c9" class="nj md it ne b gy nk nl l nm nn">const no1 = Number('1');<br/>const no2 = Number('2');<br/>const sum = no1 + no2;<br/>//3</span></pre></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="0653" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">3.忘记了十进制算术是不精确的</h1><p id="519d" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">有时我们可能会忘记十进制算术在JavaScript中是不精确的。你需要意识到这一点，并避免相关的问题。</p><p id="d315" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">考虑下面的等式，即<code class="fe nb nc nd ne b">false</code>:</p><pre class="kj kk kl km gt nf ne ng nh aw ni bi"><span id="b168" class="nj md it ne b gy nk nl l nm nn">console.log(0.1 + 0.2 === 0.3);<br/>//false</span></pre><p id="3516" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">那是因为<code class="fe nb nc nd ne b">0.1 + 0.2</code>制造类似<code class="fe nb nc nd ne b">0.30000000000000004</code>的东西。再比如，<code class="fe nb nc nd ne b">0.3 — 0.1</code>造就<code class="fe nb nc nd ne b">0.19999999999999998</code>。</p><p id="6782" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">整数运算是精确的，所以我们可以用它来避免前面的问题。在我们的例子中，我们乘以然后除以<code class="fe nb nc nd ne b">10</code>:</p><pre class="kj kk kl km gt nf ne ng nh aw ni bi"><span id="d732" class="nj md it ne b gy nk nl l nm nn">console.log( (0.1*10 + 0.2*10)/10  === (0.3*10)/10 );<br/>//true</span></pre></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="41e2" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">4.允许在返回后自动插入分号</h1><p id="c0eb" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">JavaScript有一个自动分号插入机制，试图纠正程序。请注意在<code class="fe nb nc nd ne b">return</code>语句末尾添加分号的后果。</p><p id="9ee7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">考虑这个例子:</p><pre class="kj kk kl km gt nf ne ng nh aw ni bi"><span id="4aac" class="nj md it ne b gy nk nl l nm nn">function getGameObject(){<br/>  return <br/>    { name: 'Fornite'};<br/>}</span></pre><p id="46fd" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">你可能认为这个函数返回的是一个<a class="ae ky" href="https://medium.com/programming-essentials/7-things-you-should-know-about-objects-in-javascript-c0b2f251e160" rel="noopener">对象</a>，其实不是。它返回<code class="fe nb nc nd ne b">undefined</code>:</p><pre class="kj kk kl km gt nf ne ng nh aw ni bi"><span id="290e" class="nj md it ne b gy nk nl l nm nn">console.log(getGameObject());</span></pre><p id="6c9c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">自动分号机制试图将分号放在<code class="fe nb nc nd ne b">return</code>行的末尾，发现这是一个有效的代码，并将其放在。前面的代码相当于:</p><pre class="kj kk kl km gt nf ne ng nh aw ni bi"><span id="e925" class="nj md it ne b gy nk nl l nm nn">function getGameObject(){<br/>  return;<br/>    { name: 'Fornite'};<br/>}</span></pre><p id="c12a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">为了避免这个问题，将<code class="fe nb nc nd ne b">{</code>放在与<code class="fe nb nc nd ne b">return</code>语句相同的行上:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mz na l"/></div></figure></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="d807" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">5.读取空的或未定义的属性</h1><p id="9f04" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">访问<code class="fe nb nc nd ne b">null</code>和<code class="fe nb nc nd ne b">undefined</code>上的属性是一个常见的场景，这会导致一个错误:</p><pre class="kj kk kl km gt nf ne ng nh aw ni bi"><span id="4c47" class="nj md it ne b gy nk nl l nm nn">const book = null;</span><span id="a576" class="nj md it ne b gy no nl l nm nn">console.log(book.title);<br/>//Uncaught TypeError: Cannot read property 'title' of null</span></pre><p id="2cf7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">为了避免这样的异常，我们可以使用可选的链接操作符<code class="fe nb nc nd ne b">?.</code>。</p><p id="578e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果一个引用为null(<a class="ae ky" href="https://medium.com/programming-essentials/things-on-null-and-undefined-that-you-should-know-6fda81f24745" rel="noopener">null或未定义</a>)，则<code class="fe nb nc nd ne b">?.</code>操作符不会导致错误。相反，它返回<code class="fe nb nc nd ne b">undefined</code>:</p><pre class="kj kk kl km gt nf ne ng nh aw ni bi"><span id="98af" class="nj md it ne b gy nk nl l nm nn">const book = null;</span><span id="fcd6" class="nj md it ne b gy no nl l nm nn">console.log(book?.title);<br/>//undefined</span></pre><p id="f05a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">当标题存在且不为空时，以下代码返回<code class="fe nb nc nd ne b">true</code>。当书是<code class="fe nb nc nd ne b">null</code>或<code class="fe nb nc nd ne b">undefined</code>时，它不会抛出错误:</p><pre class="kj kk kl km gt nf ne ng nh aw ni bi"><span id="b498" class="nj md it ne b gy nk nl l nm nn">if(book?.title){<br/>  return true;<br/>}</span></pre><p id="0fb9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">下面是我们如何检查书和书名的值是否不是虚假值(<code class="fe nb nc nd ne b">null</code>、<code class="fe nb nc nd ne b">undefined</code>、<code class="fe nb nc nd ne b">''</code>、<code class="fe nb nc nd ne b">0</code>或<code class="fe nb nc nd ne b">NaN</code>):</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mz na l"/></div></figure></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="9374" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">6.在循环中创建回调</h1><p id="f551" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">在循环中使用同一个变量并创建回调时，您可能会遇到以下问题。考虑下面的代码:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mz na l"/></div></figure><p id="7b15" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在循环内部，我们创建了三个回调函数，它们都引用同一个变量:<code class="fe nb nc nd ne b">i</code>。当稍后调用这些回调函数时，它们都显示变量<code class="fe nb nc nd ne b"> i</code>的最后一个值，即<code class="fe nb nc nd ne b">3</code>。</p><p id="5873" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们可能期望看到<code class="fe nb nc nd ne b">0 1 2</code>，但事实并非如此，因为所有的回调都引用同一个变量，这个变量会随着时间的推移而改变，它的最后一个值在循环执行100毫秒后显示。</p><p id="4576" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们可以通过使用<code class="fe nb nc nd ne b">for</code>循环并用<code class="fe nb nc nd ne b">let</code>声明循环变量来避免这个问题。它将用不同的变量为每次迭代创建一个块范围。所以这一次，每个回调指向不同的变量:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mz na l"/></div></figure><p id="fa18" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">更好的选择是检查是否可以使用数组方法编写代码。在这种情况下，每次迭代都将有新的功能范围:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mz na l"/></div></figure></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="d43a" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">7.失去这个背景</h1><p id="d213" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">函数可以用作方法。在这种情况下，函数中的关键字<code class="fe nb nc nd ne b">this</code>引用相关的对象。</p><p id="ace2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这个伪参数可能会变得令人困惑，因为它取决于函数是如何被调用的，而不是函数是在哪里定义的。对于来自其他语言的开发人员来说，这尤其令人沮丧，因为<code class="fe nb nc nd ne b">this</code>总是指向当前对象。在JavaScript中，它反映了如何调用函数。</p><p id="1f4e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">考虑下面的例子。<code class="fe nb nc nd ne b">setTimeout</code>函数的回调中的<code class="fe nb nc nd ne b">this</code>关键字没有引用与<code class="fe nb nc nd ne b">showMessage</code>函数相同的对象:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mz na l"/></div></figure><p id="c2aa" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">解决这个问题的简单方法是使用arrow函数在方法中定义回调。这将确保回调中的<code class="fe nb nc nd ne b">this</code>参数指向与<code class="fe nb nc nd ne b">showMessage</code>方法中相同的对象:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mz na l"/></div></figure><p id="432b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这将解决大多数情况下的问题，但不是所有问题。当<code class="fe nb nc nd ne b">this</code>可以指向一些其他对象时，仍然会有边缘情况，因为正如已经说过的，这取决于函数是如何被调用的。</p><p id="8a37" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">考虑下面的例子。在第一个例子中，<code class="fe nb nc nd ne b">showMessage</code>作为一个函数被调用，所以<code class="fe nb nc nd ne b">this</code>在函数内部是<code class="fe nb nc nd ne b">window</code> / <code class="fe nb nc nd ne b">undefined</code>:</p><pre class="kj kk kl km gt nf ne ng nh aw ni bi"><span id="550e" class="nj md it ne b gy nk nl l nm nn">setTimeout(obj.showMessage, 100);<br/>//undefined</span></pre><p id="a848" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">解决方案是调用<code class="fe nb nc nd ne b">showMessage</code>作为对象上的方法:</p><pre class="kj kk kl km gt nf ne ng nh aw ni bi"><span id="7296" class="nj md it ne b gy nk nl l nm nn">setTimeout(() =&gt; obj.showMessage(), 100);<br/>//'Hi'</span></pre><p id="d31b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">例如，如果我们使用析构语法从对象中提取方法，然后调用它，也会发生同样的问题。同样，它作为一个函数被调用，<code class="fe nb nc nd ne b">this</code>关键字是<code class="fe nb nc nd ne b">window</code> / <code class="fe nb nc nd ne b">undefined</code>:</p><pre class="kj kk kl km gt nf ne ng nh aw ni bi"><span id="7691" class="nj md it ne b gy nk nl l nm nn">const { showMessage } = obj;<br/>showMessage();<br/>//undefined</span></pre><p id="6d72" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我认为避免<code class="fe nb nc nd ne b">this</code>参数问题的最佳选择是根本不使用<code class="fe nb nc nd ne b">this</code>。下面，使用<a class="ae ky" href="https://medium.com/programming-essentials/you-will-finally-understand-what-closure-is-13ba11825319" rel="noopener">闭合</a>完成相同的示例:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mz na l"/></div></figure><p id="52d8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这一次，<code class="fe nb nc nd ne b">obj</code>对象是使用定义后自动执行的<code class="fe nb nc nd ne b">create</code>函数创建的。</p><p id="f613" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe nb nc nd ne b">create</code>用一个方法<code class="fe nb nc nd ne b">showMessage</code>返回一个对象。</p><p id="396c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe nb nc nd ne b">showMessage</code>是访问<code class="fe nb nc nd ne b">msg</code>变量的闭包。返回的闭包函数可以访问这个变量，即使在它的父变量<code class="fe nb nc nd ne b">create</code>已经执行之后。</p><p id="91d9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">关于如何在构建对象时避免使用<code class="fe nb nc nd ne b">this</code>关键字的更多信息，你可以阅读不带“this”的<a class="ae ky" href="https://medium.com/programming-essentials/removing-javascripts-this-keyword-makes-it-a-better-language-here-s-why-db28060cc086" rel="noopener"> JavaScript，它看起来像是一种更好的函数式编程语言</a>。</p><p id="123e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">感谢阅读。</p></div></div>    
</body>
</html>