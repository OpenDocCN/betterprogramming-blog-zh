<html>
<head>
<title>How to use Debounce and Throttle With React Hooks</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何使用反作用钩子去抖和节流</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/how-to-use-debounce-and-throttle-the-right-way-with-react-hooks-bf2c174728e?source=collection_archive---------1-----------------------#2021-04-15">https://betterprogramming.pub/how-to-use-debounce-and-throttle-the-right-way-with-react-hooks-bf2c174728e?source=collection_archive---------1-----------------------#2021-04-15</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="b432" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">小心点！你可能做错了</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/cdc34a778703fdc3898dfa341038ee15.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*CVUEITT9edsry_u_"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">由<a class="ae ky" href="https://unsplash.com/@framemily?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">画框Harirak </a>在<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍照。</p></figure><p id="df8d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">去抖动<strong class="lb iu"> </strong>和节流<strong class="lb iu"> </strong>是我们在试图优化函数调用时遇到的两个非常常见的术语。它们对于提高用户交互的性能非常有用。</p><p id="5329" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在进入主实现之前，让我们了解一下<code class="fe lv lw lx ly b">debounce</code>和<code class="fe lv lw lx ly b">throttle</code>的基本概念以及它们的真实用例(如果您已经熟悉这些概念，请跳过)。</p></div><div class="ab cl lz ma hx mb" role="separator"><span class="mc bw bk md me mf"/><span class="mc bw bk md me mf"/><span class="mc bw bk md me"/></div><div class="im in io ip iq"><h1 id="9281" class="mg mh it bd mi mj mk ml mm mn mo mp mq jz mr ka ms kc mt kd mu kf mv kg mw mx bi translated"><strong class="ak">什么是去抖？</strong></h1><p id="e43f" class="pw-post-body-paragraph kz la it lb b lc my ju le lf mz jx lh li na lk ll lm nb lo lp lq nc ls lt lu im bi translated">去抖动强制在函数调用的两次连续调用之间存在最小时间间隔。</p><p id="4582" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">例如，500毫秒的<code class="fe lv lw lx ly b">debounce</code>间隔意味着如果从上一次调用尝试到现在还没有过500毫秒，我们就取消上一次调用，并安排在500毫秒后进行下一次调用。</p><p id="4ad5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe lv lw lx ly b">debounce</code>的一个常见应用是<code class="fe lv lw lx ly b">Typeahead</code>。</p></div><div class="ab cl lz ma hx mb" role="separator"><span class="mc bw bk md me mf"/><span class="mc bw bk md me mf"/><span class="mc bw bk md me"/></div><div class="im in io ip iq"><h1 id="e991" class="mg mh it bd mi mj mk ml mm mn mo mp mq jz mr ka ms kc mt kd mu kf mv kg mw mx bi translated"><strong class="ak">什么是节流？</strong></h1><p id="ff43" class="pw-post-body-paragraph kz la it lb b lc my ju le lf mz jx lh li na lk ll lm nb lo lp lq nc ls lt lu im bi translated">节流是一种技术，无论用户尝试调用多少次，函数在给定的时间范围内最多被调用一次。</p><p id="dca2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">例如，给定一个500ms的<code class="fe lv lw lx ly b">throttle</code>间隔，如果我们试图在500ms内调用一个函数<em class="nd"> n次</em>，当从开始算起已经过去500ms时，这个函数只被调用一次。</p><p id="5803" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe lv lw lx ly b">Throttle</code>常用于<code class="fe lv lw lx ly b">resize</code>或<code class="fe lv lw lx ly b">scroll</code>事件。</p></div><div class="ab cl lz ma hx mb" role="separator"><span class="mc bw bk md me mf"/><span class="mc bw bk md me mf"/><span class="mc bw bk md me"/></div><div class="im in io ip iq"><h1 id="5132" class="mg mh it bd mi mj mk ml mm mn mo mp mq jz mr ka ms kc mt kd mu kf mv kg mw mx bi translated">对类组件使用去抖和节流</h1><p id="4088" class="pw-post-body-paragraph kz la it lb b lc my ju le lf mz jx lh li na lk ll lm nb lo lp lq nc ls lt lu im bi translated">在我们深入研究如何在带有钩子的功能组件中使用<code class="fe lv lw lx ly b">throttle</code> / <code class="fe lv lw lx ly b">debounce</code>之前，让我们快速地看一下如何在类组件中使用。</p><p id="d9b6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们在构造函数中定义了函数的去抖/节流版本，这就是我们需要做的。</p><p id="b3e5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><em class="nd">注:我在本文中使用的是lodash </em> <code class="fe lv lw lx ly b"><em class="nd">debounce</em></code> <em class="nd">和</em> <code class="fe lv lw lx ly b"><em class="nd">throttle</em></code> <em class="nd">函数。</em></p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ne nf l"/></div></figure><p id="dde9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">请查看下面StackBlitz中的示例演示:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ng nf l"/></div></figure></div><div class="ab cl lz ma hx mb" role="separator"><span class="mc bw bk md me mf"/><span class="mc bw bk md me mf"/><span class="mc bw bk md me"/></div><div class="im in io ip iq"><h1 id="53ff" class="mg mh it bd mi mj mk ml mm mn mo mp mq jz mr ka ms kc mt kd mu kf mv kg mw mx bi translated">在功能组件中使用去抖和节流</h1><p id="9d7b" class="pw-post-body-paragraph kz la it lb b lc my ju le lf mz jx lh li na lk ll lm nb lo lp lq nc ls lt lu im bi translated">我们将尝试把基于类的实现转换成基于函数的方法。</p><p id="f4a2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">首先想到的是在功能元件中直接定义去抖和节流功能。所以让我们先试试:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ne nf l"/></div></figure><p id="a346" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">当我们这样做时，在组件的每个渲染周期，创建一个去抖动/节流功能的新实例。基本上我们不会在每次重新渲染后调用相同的函数，它不会像预期的那样工作，你可以在下面的StackBlitz演示中看到这一点:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ng nf l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">在功能组件中直接定义去抖/节流</p></figure><p id="83e4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">所以这绝对不是功能组件中使用<code class="fe lv lw lx ly b">debounce</code> / <code class="fe lv lw lx ly b">throttle</code>的正确方式。</p></div><div class="ab cl lz ma hx mb" role="separator"><span class="mc bw bk md me mf"/><span class="mc bw bk md me mf"/><span class="mc bw bk md me"/></div><div class="im in io ip iq"><h1 id="4577" class="mg mh it bd mi mj mk ml mm mn mo mp mq jz mr ka ms kc mt kd mu kf mv kg mw mx bi translated"><strong class="ak">根据我们的学习改进我们的实施</strong></h1><p id="1864" class="pw-post-body-paragraph kz la it lb b lc my ju le lf mz jx lh li na lk ll lm nb lo lp lq nc ls lt lu im bi translated">既然我们知道我们不希望在每个渲染周期后都创建多个去抖或节流函数的实例，我们将尝试优化它。我们可以这样做的一个方法是使用<code class="fe lv lw lx ly b">useCallback</code>钩。</p><p id="0723" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">根据上的<a class="ae ky" href="https://reactjs.org/docs/hooks-reference.html#usecallback" rel="noopener ugc nofollow" target="_blank">反应文件<code class="fe lv lw lx ly b"><a class="ae ky" href="https://reactjs.org/docs/hooks-reference.html#usecallback" rel="noopener ugc nofollow" target="_blank">useCallback</a></code>:</a></p><blockquote class="nh ni nj"><p id="b028" class="kz la nd lb b lc ld ju le lf lg jx lh nk lj lk ll nl ln lo lp nm lr ls lt lu im bi translated">"传递一个内联回调和一组依赖项。<code class="fe lv lw lx ly b">useCallback</code>将返回回调的记忆化版本，只有当其中一个依赖关系发生变化时，该版本才会发生变化</p></blockquote><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ne nf l"/></div></figure><p id="c43c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在上面的代码片段中，我们看到<code class="fe lv lw lx ly b">onChange</code>处理程序利用了封闭状态<code class="fe lv lw lx ly b">inputValue</code>。所以当我们用<code class="fe lv lw lx ly b">useCallback</code>创建记忆去抖函数时，我们在<code class="fe lv lw lx ly b">useCallback</code>的依赖数组中传递<code class="fe lv lw lx ly b">inputValue</code>。否则，由于闭包，在函数调用中获得的值将是陈旧的值，而不是更新的值。</p><p id="7981" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">但是，我们有一个问题:只有当<code class="fe lv lw lx ly b">inputValue</code>改变时，我们的函数的新引用才会被创建。然而，每次我们想调用函数时，输入值都会改变，所以我们仍然会面临创建新引用的问题。最终的结果是我们的函数仍然不能像预期的那样工作。</p><p id="6f90" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">throttled函数本身不使用任何状态或封闭变量，因此可以很好地处理空的依赖数组。</p><p id="9868" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">下面的StackBlitz显示了相同的行为:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ng nf l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">将useCallback和state作为依赖项的去抖</p></figure></div><div class="ab cl lz ma hx mb" role="separator"><span class="mc bw bk md me mf"/><span class="mc bw bk md me mf"/><span class="mc bw bk md me"/></div><div class="im in io ip iq"><h1 id="4513" class="mg mh it bd mi mj mk ml mm mn mo mp mq jz mr ka ms kc mt kd mu kf mv kg mw mx bi translated">进一步优化方法</h1><p id="4424" class="pw-post-body-paragraph kz la it lb b lc my ju le lf mz jx lh li na lk ll lm nb lo lp lq nc ls lt lu im bi translated">我们现在知道，如果我们能够仅在初始渲染时创建去抖动或节流函数的实例，那么<code class="fe lv lw lx ly b">useCallback</code>会有所帮助，那么我们是否可以在不添加对<code class="fe lv lw lx ly b">useCallback</code>的依赖的情况下解决陈旧闭包的问题呢？</p><p id="61c1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">嗯，你很幸运。答案是肯定的。</p><p id="e457" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们至少有两种方法可以解决这个问题。</p><ul class=""><li id="3a60" class="nn no it lb b lc ld lf lg li np lm nq lq nr lu ns nt nu nv bi translated">在<code class="fe lv lw lx ly b">ref</code>中保存我们状态的副本:由于<code class="fe lv lw lx ly b">refs</code>发生了变异，它们并没有真正受到闭包的影响，即使引用是旧的，我们仍然可以看到更新的值。所以每当我们更新状态时，我们也更新了<code class="fe lv lw lx ly b">ref</code>。除非万不得已，否则我们不会走这条路，因为这有点麻烦，而且涉及大量的状态重复，这并不理想。</li><li id="a823" class="nn no it lb b lc nw lf nx li ny lm nz lq oa lu ns nt nu nv bi translated">将值作为参数传递:我们可以将函数需要的所有必要值作为参数传递，而不是依赖闭包来使用值。</li></ul><p id="2b2c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们的代码如下所示:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ne nf l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">正确使用带挂钩的油门和去抖</p></figure><p id="8661" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在上面的代码中，我们将<code class="fe lv lw lx ly b">inputValue</code>作为一个参数传递给去抖函数，从而确保它拥有所需的所有最新值，并且能够顺利工作。</p><p id="f677" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><em class="nd">注意:使用功能状态更新也有助于避免传递每个属性——尤其是如果它只需要更新状态的话。</em></p><p id="2bcc" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">查看下面StackBlitz中的完整工作代码:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ng nf l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">正确的方法来使用反作用钩去抖和油门</p></figure><p id="17e7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">所以我们有它。我们的去抖和节流功能现在也可以很好地与功能组件一起工作，并且没有我们想象的那么复杂。</p><p id="9e35" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><em class="nd">注意:代替</em> <code class="fe lv lw lx ly b"><em class="nd">useCallback</em></code> <em class="nd">，我们也可以使用</em> <code class="fe lv lw lx ly b"><em class="nd">useMemo</em></code> <em class="nd">，但是主要的方法逻辑将保持不变。</em></p></div><div class="ab cl lz ma hx mb" role="separator"><span class="mc bw bk md me mf"/><span class="mc bw bk md me mf"/><span class="mc bw bk md me"/></div><div class="im in io ip iq"><h1 id="8903" class="mg mh it bd mi mj mk ml mm mn mo mp mq jz mr ka ms kc mt kd mu kf mv kg mw mx bi translated">摘要</h1><p id="1ae4" class="pw-post-body-paragraph kz la it lb b lc my ju le lf mz jx lh li na lk ll lm nb lo lp lq nc ls lt lu im bi translated">我们使用带有React钩子的<code class="fe lv lw lx ly b">debounce</code>一步一步地将类组件转换成功能组件。这些是关键要点:</p><ul class=""><li id="77a0" class="nn no it lb b lc ld lf lg li np lm nq lq nr lu ns nt nu nv bi translated">我们需要尽可能多地使用创建的函数的同一个实例。</li><li id="bc8a" class="nn no it lb b lc nw lf nx li ny lm nz lq oa lu ns nt nu nv bi translated">使用<code class="fe lv lw lx ly b">useCallback/useMemo</code>钩子来记忆我们创建的函数。</li><li id="03e3" class="nn no it lb b lc nw lf nx li ny lm nz lq oa lu ns nt nu nv bi translated">为了避免闭包问题并防止函数被重新创建，我们可以将函数所需的值作为参数传递。</li><li id="2957" class="nn no it lb b lc nw lf nx li ny lm nz lq oa lu ns nt nu nv bi translated">需要先前值的状态更新可以使用<code class="fe lv lw lx ly b">setState</code>的函数形式实现。</li></ul></div></div>    
</body>
</html>