<html>
<head>
<title>Writing Testable Views in SwiftUI</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">在SwiftUI中编写可测试视图</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/writing-testable-views-in-swiftui-ba28baec6a32?source=collection_archive---------12-----------------------#2020-02-06">https://betterprogramming.pub/writing-testable-views-in-swiftui-ba28baec6a32?source=collection_archive---------12-----------------------#2020-02-06</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="ae1e" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">视图分解是一件美妙的事情，但是我们需要聪明地知道如何去做</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/e88784ae8594e52aa1e9d6359bb412bb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*fWAD7ujhLP9hs5RPPkE-2w.jpeg"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">照片由<a class="ae ky" href="https://unsplash.com/@oowgnuj?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Jungwoo Hong </a>在<a class="ae ky" href="https://unsplash.com/s/photos/modern-classroom?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</p></figure><p id="0262" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在SwiftUI 中的<a class="ae ky" href="https://medium.com/swlh/structural-decomposition-in-swiftui-8892e512b18e" rel="noopener">视图组合中，我讨论了SwiftUI如何鼓励我们将应用程序分解成小的、容易理解的组件和视图。</a></p><p id="2854" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">但是我们可以做得更多。</p><p id="4f7a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们可以——同时，而且只需很少的额外工作——创建易于测试和验证的组件。</p><h2 id="a55d" class="lv lw it bd lx ly lz dn ma mb mc dp md li me mf mg lm mh mi mj lq mk ml mm mn bi translated">一个例子</h2><p id="a435" class="pw-post-body-paragraph kz la it lb b lc mo ju le lf mp jx lh li mq lk ll lm mr lo lp lq ms ls lt lu im bi translated">考虑订单接收应用程序中的以下屏幕片段，它显示订购商品的列表:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi mt"><img src="../Images/351ad0fb7f6fe6f5da483b0f1314669e.png" data-original-src="https://miro.medium.com/v2/resize:fit:826/format:webp/1*GcHVdLTwx_Sfm24dJNlDsg.png"/></div></figure><p id="d28b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在SwiftUI中，我们可以使用以下代码生成一个列表版本:</p><pre class="kj kk kl km gt mu mv mw mx aw my bi"><span id="ef89" class="lv lw it mv b gy mz na l nb nc">struct OrderDetailsView: View {<br/>    var order: Order<br/>    var body: some View {<br/>        Form {<br/>            ForEach(order.items) { item in<br/>                 HStack {<br/>                     if item.quantity == 1 {<br/>                         Text(item.name)<br/>                     } else {<br/>                         Text("\(item.name) $(\(item.quantity, specifier: "%.2f") @ $\(item.price, specifier: "%.2f")")<br/>                     }<br/>                     Spacer()<br/>                     Text("$(\(item.total, specifier: "%.2f")")<br/>                 }<br/>            }<br/>        }<br/>    }<br/>}</span></pre><p id="c429" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这很好，但是我们在循环中嵌入了相当多的逻辑。我们正在检查数量以控制我们的行如何出现，我们也做了相当多的行内格式化(并且做得不正确，我可能会补充。)</p><p id="8b08" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">那么，如何才能做得更好呢？我如何确保我的代码是正确的？</p><h2 id="98a5" class="lv lw it bd lx ly lz dn ma mb mc dp md li me mf mg lm mh mi mj lq mk ml mm mn bi translated">分解</h2><p id="2c54" class="pw-post-body-paragraph kz la it lb b lc mo ju le lf mp jx lh li mq lk ll lm mr lo lp lq ms ls lt lu im bi translated">一种方法是简化<code class="fe nd ne nf mv b">list</code>代码。</p><pre class="kj kk kl km gt mu mv mw mx aw my bi"><span id="cd0a" class="lv lw it mv b gy mz na l nb nc">Form {<br/>    ForEach(order.items) { item in<br/>        OrderDetailsRowView(item: item)<br/>    }<br/>}</span></pre><p id="6558" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在的<code class="fe nd ne nf mv b">list</code>简直脑残简单。它遍历<code class="fe nd ne nf mv b">out</code>项，并将列表中的每一项传递给一个专门处理每一行的视图。</p><p id="b467" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">只要<code class="fe nd ne nf mv b">OrderDetailsRowView</code> <em class="ng"> </em>工作正常，这段代码基本不会出错。</p><blockquote class="nh ni nj"><p id="fd86" class="kz la ng lb b lc ld ju le lf lg jx lh nk lj lk ll nl ln lo lp nm lr ls lt lu im bi translated">请记住，当一个视图开始变得过于复杂时，可能是时候考虑分解它了。</p></blockquote></div><div class="ab cl nn no hx np" role="separator"><span class="nq bw bk nr ns nt"/><span class="nq bw bk nr ns nt"/><span class="nq bw bk nr ns"/></div><div class="im in io ip iq"><h1 id="f9b1" class="nu lw it bd lx nv nw nx ma ny nz oa md jz ob ka mg kc oc kd mj kf od kg mm oe bi translated">行视图</h1><p id="8666" class="pw-post-body-paragraph kz la it lb b lc mo ju le lf mp jx lh li mq lk ll lm mr lo lp lq ms ls lt lu im bi translated">现在让我们来看看<code class="fe nd ne nf mv b">OrderDetailsRowView</code>。我们已经摆脱了形式和循环，因此这些代码更容易理解。毕竟，它只是返回一个包含单行所需文本的<code class="fe nd ne nf mv b">HStack</code>:</p><pre class="kj kk kl km gt mu mv mw mx aw my bi"><span id="d406" class="lv lw it mv b gy mz na l nb nc">struct OrderDetailsRowView: View {<br/>    var item: OrderItem<br/>    var body: some View {<br/>        HStack {<br/>            if item.quantity == 1 {<br/>                Text(item.name)<br/>            } else {<br/>                Text("\(item.name) $(\(item.quantity, specifier: "%.2f") @ $\(item.price, specifier: "%.2f")")<br/>            }<br/>            Spacer()<br/>            Text("$(\(item.total, specifier: "%.2f")")<br/>        }<br/>    }<br/>}</span></pre><p id="3119" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">但是我们仍然有一个类似的问题。我如何<em class="ng">知道</em>这个<em class="ng">代码是正确的？似乎我们所做的一切都是在拖延时间。</em></p><p id="f372" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这是真的——但是现在我们可以做得更多。</p></div><div class="ab cl nn no hx np" role="separator"><span class="nq bw bk nr ns nt"/><span class="nq bw bk nr ns nt"/><span class="nq bw bk nr ns"/></div><div class="im in io ip iq"><h1 id="987c" class="nu lw it bd lx nv nw nx ma ny nz oa md jz ob ka mg kc oc kd mj kf od kg mm oe bi translated">导出逻辑</h1><p id="1ef8" class="pw-post-body-paragraph kz la it lb b lc mo ju le lf mp jx lh li mq lk ll lm mr lo lp lq ms ls lt lu im bi translated">例如，如果我把我的数字格式移出循环会怎样？我们将通过使我们的<code class="fe nd ne nf mv b">OrderItem</code> <em class="ng">模型</em>更加智能来做到这一点，因为我们可能会在应用程序的其他地方显示一些相同格式的值:</p><pre class="kj kk kl km gt mu mv mw mx aw my bi"><span id="0cf4" class="lv lw it mv b gy mz na l nb nc">extension OrderItem {<br/>    var formattedQuantity: String {<br/>        NumberFormatter.localizedString(from: NSNumber(value: quantity), number: .decimal)<br/>    }<br/>    var formattedPrice: String {<br/>        NumberFormatter.localizedString(from: NSNumber(value: price), number: .currency)<br/>    }<br/>    var formattedTotal: String {<br/>        NumberFormatter.localizedString(from: NSNumber(value: total), number: .currency)<br/>    }<br/>}</span></pre><p id="38a8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">留给我们的是:</p><pre class="kj kk kl km gt mu mv mw mx aw my bi"><span id="9c40" class="lv lw it mv b gy mz na l nb nc">struct OrderDetailsRowView: View {<br/>    var item: OrderItem<br/>    var body: some View {<br/>        HStack {<br/>            if item.quantity == 1 {<br/>                Text(item.name)<br/>            } else {<br/>                Text("\(item.name) (\(item.formattedQuantity) @ \(item.formattedPrice))")<br/>            }<br/>            Spacer()<br/>            Text(item.formattedTotal)<br/>        }<br/>    }<br/>}</span></pre><p id="ded5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这让事情变得简单多了。但是在我的循环中仍然有逻辑代码。它<em class="ng">看起来</em>正确，但我仍然无法<em class="ng">测试</em>它是否正确。</p></div><div class="ab cl nn no hx np" role="separator"><span class="nq bw bk nr ns nt"/><span class="nq bw bk nr ns nt"/><span class="nq bw bk nr ns"/></div><div class="im in io ip iq"><h1 id="c431" class="nu lw it bd lx nv nw nx ma ny nz oa md jz ob ka mg kc oc kd mj kf od kg mm oe bi translated">最终重构</h1><p id="d6f9" class="pw-post-body-paragraph kz la it lb b lc mo ju le lf mp jx lh li mq lk ll lm mr lo lp lq ms ls lt lu im bi translated">让我们完成代码重构，并将我们的自定义描述逻辑移到我们可以看到的地方。</p><p id="f44a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">与格式化的总计不同，我们不打算将它添加到<code class="fe nd ne nf mv b">OrderItem</code>中，因为目前，这似乎是我们将使用该特定格式的唯一地方。</p><p id="3c31" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们还将导出最终的良好度量总请求，这为我们提供了最终的<code class="fe nd ne nf mv b">OrderDetailsRowView</code>:</p><pre class="kj kk kl km gt mu mv mw mx aw my bi"><span id="c96f" class="lv lw it mv b gy mz na l nb nc">struct OrderDetailsRowView: View {</span><span id="9c36" class="lv lw it mv b gy of na l nb nc">    var item: OrderItem</span><span id="4f33" class="lv lw it mv b gy of na l nb nc">    var body: some View {<br/>        HStack {<br/>            Text(itemDescription)<br/>            Spacer()<br/>            Text(itemTotal)<br/>        }<br/>    }</span><span id="3579" class="lv lw it mv b gy of na l nb nc">    var itemDescription: String {<br/>        if item.quantity == 1 {<br/>            return item.name<br/>        } else {<br/>            return "\(item.name) (\(item.formattedQuantity) @ \(item.formattedPrice))"<br/>        }<br/>    }</span><span id="849f" class="lv lw it mv b gy of na l nb nc">    var itemTotal: String {<br/>        item.formattedTotal<br/>    }<br/>}</span></pre><p id="27c1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">请再次注意，我们的行视图的主体又一次变得非常简单。</p><pre class="kj kk kl km gt mu mv mw mx aw my bi"><span id="1605" class="lv lw it mv b gy mz na l nb nc">var body: some View {<br/>    HStack {<br/>      Text(itemDescription)<br/>      Spacer()<br/>      Text(itemTotal)<br/>   }<br/>}</span></pre><p id="6525" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们现在可以非常有把握地说，如果我们的两个输入是正确的，那么我们视图的最终输出<em class="ng">一定也是正确的。</em></p><p id="2e74" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">那么我们如何确定呢？</p></div><div class="ab cl nn no hx np" role="separator"><span class="nq bw bk nr ns nt"/><span class="nq bw bk nr ns nt"/><span class="nq bw bk nr ns"/></div><div class="im in io ip iq"><h1 id="77a3" class="nu lw it bd lx nv nw nx ma ny nz oa md jz ob ka mg kc oc kd mj kf od kg mm oe bi translated">这是重击时间！</h1><p id="25be" class="pw-post-body-paragraph kz la it lb b lc mo ju le lf mp jx lh li mq lk ll lm mr lo lp lq ms ls lt lu im bi translated">唯一确定的方法就是用力踩。(或者从轨道上用核武器攻击这个地方。)</p><p id="d0d6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">因为我手边没有核武器，所以让我们为我们的详细行视图编写一些测试:</p><pre class="kj kk kl km gt mu mv mw mx aw my bi"><span id="af76" class="lv lw it mv b gy mz na l nb nc">func testOrderDetailsRowView() {</span><span id="dcf2" class="lv lw it mv b gy of na l nb nc">    let view1 = OrderDetailsRowView(item: OrderItem.mock1)<br/>    XCTAssert(view1.itemDescription == "Soft Drink")<br/>    XCTAssert(view1.itemTotal == "$1.99")</span><span id="9c50" class="lv lw it mv b gy of na l nb nc">    let view2 = OrderDetailsRowView(item: OrderItem.mock2)<br/>    XCTAssert(view2.itemDescription == "Cheeseburger (2 @ $4.99)")<br/>    XCTAssert(view2.itemTotal == "$9.98")</span><span id="f468" class="lv lw it mv b gy of na l nb nc">}</span></pre><p id="06da" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">首先，我们实例化一个数量为1的模拟订单项对象，将其传递给视图，并检查视图变量的结果。如果他们给我们<code class="fe nd ne nf mv b">Soft Drink</code>和<code class="fe nd ne nf mv b">$1.99</code>，我们就通过了。</p><p id="2214" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">然后，我们给它一个数量大于1的模拟项，并再次使用我们的可见变量来验证结果。</p><p id="7a3e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果描述与总数为<code class="fe nd ne nf mv b">$9.98</code>的<code class="fe nd ne nf mv b">Cheeseburger (2 @ $4.99)</code>相匹配，那么我们已经根据我们的格式要求验证了我们的输出，我们可以开始了。</p><p id="1a24" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">更重要的是，我们可以以99.99%的信心说我们的视图表示代码是正确的，并且——只要我们继续运行我们的测试——它将保持正确。</p></div><div class="ab cl nn no hx np" role="separator"><span class="nq bw bk nr ns nt"/><span class="nq bw bk nr ns nt"/><span class="nq bw bk nr ns"/></div><div class="im in io ip iq"><h1 id="8753" class="nu lw it bd lx nv nw nx ma ny nz oa md jz ob ka mg kc oc kd mj kf od kg mm oe bi translated">斯威夫图伊的MVVM</h1><p id="6c87" class="pw-post-body-paragraph kz la it lb b lc mo ju le lf mp jx lh li mq lk ll lm mr lo lp lq ms ls lt lu im bi translated">实际上，我们刚才所做的就是在SwiftUI中创建一个模型-视图-视图模型版本。</p><p id="ee9a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在经典的基于UIKit ViewController的应用程序中，我们创建<code class="fe nd ne nf mv b">ViewModel</code>来驱动我们的<code class="fe nd ne nf mv b">ViewController</code>。我们构建这些视图模型来分解我们的逻辑和功能，因此，我们可以<em class="ng">测试</em>该逻辑和功能。</p><p id="270a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">给视图模型一个特定的输入，我们可以期望看到一个特定的输出。</p><p id="c67c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果我们测试我们的视图模型，如果我们看到期望的输出，如果<em class="ng">我们的视图控制器正确地绑定到我们的视图模型，那么我们可以相当有把握地说我们的屏幕——和我们的代码——是正确的。</em></p><p id="8ff5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">为了在SwiftUI中获得同样的效果，我们只需将尽可能多的逻辑从视图主体的<em class="ng">中取出</em>，并将其放入视图外部的<em class="ng">中的变量和函数中。</em></p><p id="3dc5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">因为，套用一句军事格言:如果我们能看到它，我们就能测试它。</p></div><div class="ab cl nn no hx np" role="separator"><span class="nq bw bk nr ns nt"/><span class="nq bw bk nr ns nt"/><span class="nq bw bk nr ns"/></div><div class="im in io ip iq"><h1 id="be04" class="nu lw it bd lx nv nw nx ma ny nz oa md jz ob ka mg kc oc kd mj kf od kg mm oe bi translated">独立和独特的视图模型</h1><p id="1d66" class="pw-post-body-paragraph kz la it lb b lc mo ju le lf mp jx lh li mq lk ll lm mr lo lp lq ms ls lt lu im bi translated">在经典的MVVM中，我们通常创建单独的<code class="fe nd ne nf mv b">ViewModel</code>类，我们也可以在SwiftUI中这样做，使我们的视图模型成为一个<code class="fe nd ne nf mv b">ObservableObject</code>，并将其作为一个<code class="fe nd ne nf mv b">ObservedObject</code> <em class="ng">附加到我们的视图上。</em></p><p id="027b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">但是在很多情况下，这种方法可能有些矫枉过正，尤其是像这样的情况。</p><p id="7c74" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我的<code class="fe nd ne nf mv b">OrderDetailsRowView</code>相对较小，自成一体，易于理解，所有重要的部分都在可以看到和测试的地方。</p><p id="7c2b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">只有当我们开始扩大我们的视图以及相关的复杂性时，单独的视图模型才开始有意义。</p><p id="b21e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">考虑下面的视图，该视图根据相应的<code class="fe nd ne nf mv b">OrderDetailsViewModel</code>生成的信息显示了我们的订单详情屏幕的更全功能版本:</p><pre class="kj kk kl km gt mu mv mw mx aw my bi"><span id="00c0" class="lv lw it mv b gy mz na l nb nc">struct OrderDetailsView: View {</span><span id="1fae" class="lv lw it mv b gy of na l nb nc">@ObservedObject var model: OrderDetailsViewModel</span><span id="df83" class="lv lw it mv b gy of na l nb nc">var body: some View {<br/>    Form {<br/>        if model.message.hasMessage {<br/>            StatusMessageView(type: model.message)<br/>        }</span><span id="9006" class="lv lw it mv b gy of na l nb nc">        LabelValueRowView(label: "Order", value: model.dateValue)</span><span id="0814" class="lv lw it mv b gy of na l nb nc">        ForEach(model.items) { item in<br/>            OrderDetailsRowView(item: item)<br/>        }</span><span id="ec99" class="lv lw it mv b gy of na l nb nc">        if model.hasDiscount {<br/>            LabelValueRowView(label: "Subtotal", value: model.subtotalValue)<br/>            OrderDetailsDiscountView(value: model.discountValue)<br/>        }</span><span id="1f70" class="lv lw it mv b gy of na l nb nc">        LabelValueRowView(label: model.totalLabel, value: model.totalValue)</span><span id="1381" class="lv lw it mv b gy of na l nb nc">        Button("Order Again") {<br/>            self.model.reorder()<br/>        }<br/>    }<br/>}</span><span id="0022" class="lv lw it mv b gy of na l nb nc">}</span></pre><p id="a4fe" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">注意，我们视图中的所有东西都是由视图模型驱动的。</p><p id="c0af" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">所有条件值和计算值都来自视图模型。有几个<code class="fe nd ne nf mv b">if</code>语句控制某些元素的可见性，但是同样，那些<em class="ng">决策</em>背后的逻辑是在模型中做出的。视图只是执行它们。</p><p id="7220" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">当状态改变时，比如说点击“Order Again”按钮，我的视图再次根据我的视图模型重新生成</p><p id="5028" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果我的<code class="fe nd ne nf mv b">OrderDetailsViewModel</code>的输出是正确的，那么，再一次，我的观点可能是正确的。</p><p id="79e0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我只需要测试视图模型来确保。</p><p id="92ed" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">还要注意，将视图和视图模型分成两个独立的部分有助于确保视图不会“作弊”毕竟，视图只能看到视图模型允许它看到的东西。</p></div><div class="ab cl nn no hx np" role="separator"><span class="nq bw bk nr ns nt"/><span class="nq bw bk nr ns nt"/><span class="nq bw bk nr ns"/></div><div class="im in io ip iq"><h1 id="d6a4" class="nu lw it bd lx nv nw nx ma ny nz oa md jz ob ka mg kc oc kd mj kf od kg mm oe bi translated">完成块</h1><p id="975e" class="pw-post-body-paragraph kz la it lb b lc mo ju le lf mp jx lh li mq lk ll lm mr lo lp lq ms ls lt lu im bi translated">正如我之前关于SwiftUI 中的<a class="ae ky" href="https://medium.com/swlh/structural-decomposition-in-swiftui-8892e512b18e" rel="noopener">视图合成的文章一样，有人可能会说这仅仅是对方法和类重构的又一次长篇大论，我同意这一点。</a></p><p id="27a1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">但是这种特定的重构练习是SwiftUI中成功的应用程序架构的关键之一——如果不是关键的话。如果做得好，您最终会得到一个干净的、结构良好的SwiftUI应用程序。一个可测试的，可以证明是正确的。</p><p id="e655" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">下次见！</p></div></div>    
</body>
</html>