<html>
<head>
<title>Write Better JavaScript by Separating Side Effects From Logic</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">通过将副作用与逻辑分离，写出更好的JavaScript</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/write-better-javascript-by-separating-side-effects-from-logic-b6f3f1d3ef4d?source=collection_archive---------1-----------------------#2020-10-13">https://betterprogramming.pub/write-better-javascript-by-separating-side-effects-from-logic-b6f3f1d3ef4d?source=collection_archive---------1-----------------------#2020-10-13</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="b985" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">当逻辑是纯粹的，它更容易理解和测试</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/018e4bd1f3aaaced0f4e33b70f7796aa.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*IfN1QGeoRoOhYMiz-mlFUQ.jpeg"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">图片来源:作者</p></figure><p id="2c38" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">我们每天编写的软件系统中的代码会产生副作用。</p><p id="a1eb" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">它产生的一些副作用是永久性的，比如在数据库中创建记录和修改文件系统。其他的是暂时的，比如更新用户界面，打印到控制台，或者在内存中缓存信息。点亮智能灯或向太空发射火箭也是副作用。</p><p id="8def" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">一个没有副作用的软件系统可能没有价值。即使它计算出了生命的意义，也无法在不产生副作用的情况下进行交流。这样的系统将是一个黑匣子，没有人知道里面发生了什么。</p><p id="efc8" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">但是副作用也使得代码更难推理。函数式编程(FP)旨在尽可能减少副作用。</p><p id="b387" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">我们如何在JavaScript代码中创建副作用？</p><p id="65f3" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">本文将向您展示一个带有副作用的简单验证函数到一个更纯粹、更实用的版本的转换。我会尽可能推迟副作用的出现来达到这个目的。通过这个例子，我旨在向您展示在日常代码中使用的模式。</p><p id="2c0d" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">我们开始吧。</p></div><div class="ab cl lr ls hu lt" role="separator"><span class="lu bw bk lv lw lx"/><span class="lu bw bk lv lw lx"/><span class="lu bw bk lv lw"/></div><div class="ij ik il im in"><h1 id="f1a6" class="ly lz iq bd ma mb mc md me mf mg mh mi jw mj jx mk jz ml ka mm kc mn kd mo mp bi translated">任务:验证用户名</h1><p id="f846" class="pw-post-body-paragraph kv kw iq kx b ky mq jr la lb mr ju ld le ms lg lh li mt lk ll lm mu lo lp lq ij bi translated">这是一个验证用户名的简单而老派的函数。业务逻辑要求我们验证三件事:</p><ul class=""><li id="c899" class="mv mw iq kx b ky kz lb lc le mx li my lm mz lq na nb nc nd bi translated">用户名必须是非空字符串。</li><li id="d8b7" class="mv mw iq kx b ky ne lb nf le ng li nh lm ni lq na nb nc nd bi translated">用户名必须包含字母数字字符。</li><li id="342f" class="mv mw iq kx b ky ne lb nf le ng li nh lm ni lq na nb nc nd bi translated">用户名必须是唯一的。</li></ul><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nj nk l"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">简单的验证实现</p></figure><p id="c79f" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">这个版本验证了这三种情况，并在遇到问题时在用户界面上显示错误。它有什么问题？</p><p id="3409" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">有几件事:</p><ul class=""><li id="4ebd" class="mv mw iq kx b ky kz lb lc le mx li my lm mz lq na nb nc nd bi translated">这段代码不仅仅是验证，还将业务逻辑和副作用混合在一起。它知道如何以一种非常神奇的方式将错误可视化。从这个角度来看，它违反了<em class="nl">年代</em>年的坚实原则。尽管SOLID传统上适用于面向对象编程，但它的许多价值也适用于函数式编程。具有单一职责的功能通常更可取，也更容易组合。</li><li id="a2d9" class="mv mw iq kx b ky ne lb nf le ng li nh lm ni lq na nb nc nd bi translated">因为它访问文档对象模型(DOM)，所以它的成功依赖于id为<code class="fe nm nn no np b">error-text</code>的DOM元素的存在。</li><li id="283e" class="mv mw iq kx b ky ne lb nf le ng li nh lm ni lq na nb nc nd bi translated">它依赖于特定的服务器API来工作。这种依赖性不能从逻辑的其余部分中提取出来。如果您将这段代码复制粘贴到其他项目中，您也需要复制API。</li><li id="4bd7" class="mv mw iq kx b ky ne lb nf le ng li nh lm ni lq na nb nc nd bi translated">它不是一个纯粹的功能，因为它会产生副作用。当您运行它时，它会发出一个网络请求并修改DOM。</li><li id="1a68" class="mv mw iq kx b ky ne lb nf le ng li nh lm ni lq na nb nc nd bi translated">为这个函数编写单元测试既烦人又困难。您需要模拟fetch和DOM来验证用户名验证的业务逻辑是否写得正确。</li></ul></div><div class="ab cl lr ls hu lt" role="separator"><span class="lu bw bk lv lw lx"/><span class="lu bw bk lv lw lx"/><span class="lu bw bk lv lw"/></div><div class="ij ik il im in"><h1 id="8b1a" class="ly lz iq bd ma mb mc md me mf mg mh mi jw mj jx mk jz ml ka mm kc mn kd mo mp bi translated">第一次尝试</h1><p id="82ed" class="pw-post-body-paragraph kv kw iq kx b ky mq jr la lb mr ju ld le ms lg lh li mt lk ll lm mu lo lp lq ij bi translated">让我们开始从中分离副作用。我们首先可以分离的是对DOM的副作用。为此，我们重构了<code class="fe nm nn no np b">validateUsername</code>函数，返回一个具有<code class="fe nm nn no np b">valid</code>和<code class="fe nm nn no np b">reason</code>属性的对象，并在<code class="fe nm nn no np b">showError</code>函数中更新其外部的<code class="fe nm nn no np b">error-text</code>。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nj nk l"/></div></figure><p id="458b" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">这个版本稍微好一点，因为它把对<code class="fe nm nn no np b">error-text</code>元素的副作用从<code class="fe nm nn no np b">validateUsername</code>函数中分离出来。副作用被转移到<code class="fe nm nn no np b">showError</code>函数中，该函数除了创建副作用之外什么也不做。单元测试现在也更加简单，因为不需要DOM来测试它。</p><p id="fc79" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">但它仍然是一个不纯的函数，因为它执行网络调用。因为这个网络调用是一个可观察到的效果，我们也需要移除它。</p></div><div class="ab cl lr ls hu lt" role="separator"><span class="lu bw bk lv lw lx"/><span class="lu bw bk lv lw lx"/><span class="lu bw bk lv lw"/></div><div class="ij ik il im in"><h1 id="360a" class="ly lz iq bd ma mb mc md me mf mg mh mi jw mj jx mk jz ml ka mm kc mn kd mo mp bi translated">第二次尝试</h1><p id="c66b" class="pw-post-body-paragraph kv kw iq kx b ky mq jr la lb mr ju ld le ms lg lh li mt lk ll lm mu lo lp lq ij bi translated">消除网络副作用的一种方法是将其作为参数传递给<code class="fe nm nn no np b">validateUsername</code>函数。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nj nk l"/></div></figure><p id="2da5" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">当我们将<code class="fe nm nn no np b">isUsernameAvailable</code>函数作为参数传递给<code class="fe nm nn no np b">validateUsername</code>时，我们在技术上使<code class="fe nm nn no np b">validateUsername</code>没有副作用。现在您可以对它进行单元测试，而不需要模拟网络。</p><p id="05a5" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">但是它仍然有两个问题:</p><ol class=""><li id="3c38" class="mv mw iq kx b ky kz lb lc le mx li my lm mz lq nq nb nc nd bi translated">唯一性检查与错误消息分开。任何人都可以通过一个任意的检查函数，该函数除了检查惟一性之外，还会得到相同的错误消息。</li><li id="a755" class="mv mw iq kx b ky ne lb nf le ng li nh lm ni lq nq nb nc nd bi translated"><code class="fe nm nn no np b">validateUsername</code>执行三种不同的检查。理想情况下，我们可以将它们分成独立的功能。这样，代码将更具可读性和可测试性。</li></ol></div><div class="ab cl lr ls hu lt" role="separator"><span class="lu bw bk lv lw lx"/><span class="lu bw bk lv lw lx"/><span class="lu bw bk lv lw"/></div><div class="ij ik il im in"><h1 id="4e0e" class="ly lz iq bd ma mb mc md me mf mg mh mi jw mj jx mk jz ml ka mm kc mn kd mo mp bi translated">第三次尝试</h1><p id="e4df" class="pw-post-body-paragraph kv kw iq kx b ky mq jr la lb mr ju ld le ms lg lh li mt lk ll lm mu lo lp lq ij bi translated">让我们试着将每个检查分开，并从它们中组成一个验证函数。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nj nk l"/></div></figure><p id="77a8" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">在这个版本中，<code class="fe nm nn no np b">validateUsername</code>是复合的，而不是直接定义的。这个版本的优点是:</p><ul class=""><li id="8b85" class="mv mw iq kx b ky kz lb lc le mx li my lm mz lq na nb nc nd bi translated">验证逻辑与实际的验证是分离的。<code class="fe nm nn no np b">defineValidator</code>和<code class="fe nm nn no np b">createRule</code>函数对用户名一无所知。您可以用任意的测试值分别测试这些函数。另一方面，<code class="fe nm nn no np b">validNonEmptyString</code>、<code class="fe nm nn no np b">validUsername</code>和<code class="fe nm nn no np b">isUniqueUsername</code>函数不知道它们是如何组成的。这意味着您可以单独测试它们中的每一个。</li><li id="0ba4" class="mv mw iq kx b ky ne lb nf le ng li nh lm ni lq na nb nc nd bi translated">您可以重用<code class="fe nm nn no np b">defineValidator</code>和<code class="fe nm nn no np b">createRule</code>函数来组成不同的验证函数。</li><li id="ba5e" class="mv mw iq kx b ky ne lb nf le ng li nh lm ni lq na nb nc nd bi translated">每个功能都可以移动到不同的模块中。</li><li id="b3a3" class="mv mw iq kx b ky ne lb nf le ng li nh lm ni lq na nb nc nd bi translated">与每个检查相关的错误消息与逻辑相分离。这允许我们重用一个带有不同错误消息的验证函数。例如，您可以使用<code class="fe nm nn no np b">validNonEmptyString</code>函数来验证带有不同错误消息的电子邮件字段。</li><li id="0875" class="mv mw iq kx b ky ne lb nf le ng li nh lm ni lq na nb nc nd bi translated">执行实际验证的函数很简单，更容易阅读和理解。</li><li id="5554" class="mv mw iq kx b ky ne lb nf le ng li nh lm ni lq na nb nc nd bi translated">您可以通过添加新规则来轻松扩展验证。例如，如果您想防止用户使用众所周知的用户名，如<code class="fe nm nn no np b">admin</code>或<code class="fe nm nn no np b">moderator</code>，您可以定义一个新的验证函数并扩展<code class="fe nm nn no np b">validateUsername</code>。</li></ul></div><div class="ab cl lr ls hu lt" role="separator"><span class="lu bw bk lv lw lx"/><span class="lu bw bk lv lw lx"/><span class="lu bw bk lv lw"/></div><div class="ij ik il im in"><h1 id="5fee" class="ly lz iq bd ma mb mc md me mf mg mh mi jw mj jx mk jz ml ka mm kc mn kd mo mp bi translated">外卖食品</h1><p id="bb5c" class="pw-post-body-paragraph kv kw iq kx b ky mq jr la lb mr ju ld le ms lg lh li mt lk ll lm mu lo lp lq ij bi translated">当您将业务逻辑与副作用混合在一起时，代码变得难以理解、推理、分割和单元测试。但是由于副作用是不可避免的，一种方法是在业务逻辑代码之外单独执行它们。</p><p id="4567" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">这样，副作用会在代码中的显式位置执行。当逻辑是纯粹的时候，更容易理解和测试。你也可以将纯粹的功能拆分成更小的功能，或者毫无顾虑地将它们组合起来。</p><p id="1675" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">编码快乐！</p></div></div>    
</body>
</html>