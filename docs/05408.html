<html>
<head>
<title>Designing Configuration Frameworks for a Cloud-Native App</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">为云原生应用设计配置框架</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/designing-cloud-native-configuration-framework-eefb0b3793cb?source=collection_archive---------18-----------------------#2020-07-06">https://betterprogramming.pub/designing-cloud-native-configuration-framework-eefb0b3793cb?source=collection_archive---------18-----------------------#2020-07-06</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="1d90" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">经历为现代云原生应用定义配置加载框架的思考过程</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/3405edde21e74d7ca7cd836256c11ad7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*9M6NTR5DX4vRfXkqviwF1Q.jpeg"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">图片来源:作者</p></figure><h1 id="6fc9" class="ky kz it bd la lb lc ld le lf lg lh li jz lj ka lk kc ll kd lm kf ln kg lo lp bi translated">介绍</h1><p id="710a" class="pw-post-body-paragraph lq lr it ls b lt lu ju lv lw lx jx ly lz ma mb mc md me mf mg mh mi mj mk ml im bi translated">将配置加载到应用程序中通常是应用程序启动时做的第一件事。硬编码的值、配置文件、环境变量或标志——这些都是您可以使用的不同来源。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi mm"><img src="../Images/9e92190d65aece86b2669f2588a09558.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*1FC2f-if4L4ESAMskh-R8w.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">将配置从YAML文件映射到本机Go结构</p></figure><p id="73e5" class="pw-post-body-paragraph lq lr it ls b lt mn ju lv lw mo jx ly lz mp mb mc md mq mf mg mh mr mj mk ml im bi translated">每个应用程序最终都会构建自己的框架来加载应用程序内部的配置，通常是在第三方库的帮助下。</p><p id="4feb" class="pw-post-body-paragraph lq lr it ls b lt mn ju lv lw mo jx ly lz mp mb mc md mq mf mg mh mr mj mk ml im bi translated">在本文中，我们将使用<strong class="ls iu"> </strong>定义的方法设计一个框架，允许最多只使用一两行代码加载配置，并抽象出框架本身内部的所有观点，使其适合云原生应用。</p><h2 id="32d2" class="ms kz it bd la mt mu dn le mv mw dp li lz mx my lk md mz na lm mh nb nc lo nd bi translated">需要第三方库/框架吗？</h2><p id="e498" class="pw-post-body-paragraph lq lr it ls b lt lu ju lv lw lx jx ly lz ma mb mc md me mf mg mh mi mj mk ml im bi translated">是也不是<a class="ae ne" href="https://golang.org/pkg/" rel="noopener ugc nofollow" target="_blank"> Go </a>标准库足以构建你的配置加载框架。然而，你要么使用第三方包来读取<code class="fe nf ng nh ni b">stdlib</code>中不支持的格式，比如YAML，要么只是为了它们的抽象。</p><h2 id="68e2" class="ms kz it bd la mt mu dn le mv mw dp li lz mx my lk md mz na lm mh nb nc lo nd bi translated">第三方库中的问题</h2><p id="54b3" class="pw-post-body-paragraph lq lr it ls b lt lu ju lv lw lx jx ly lz ma mb mc md me mf mg mh mi mj mk ml im bi translated">第三方库中总是有太多的选项需要配置，因为他们试图提供绝对的灵活性。此外，我经常需要将多个库缝合在一起，以获得想要的结果。</p><h2 id="e49d" class="ms kz it bd la mt mu dn le mv mw dp li lz mx my lk md mz na lm mh nb nc lo nd bi translated">趋同；聚集</h2><p id="52c6" class="pw-post-body-paragraph lq lr it ls b lt lu ju lv lw lx jx ly lz ma mb mc md me mf mg mh mi mj mk ml im bi translated">过了一段时间，我用于配置加载的代码在大多数应用程序中趋于一致。这是我自以为是的配置加载方式，受到新兴的云原生标准、<a class="ae ne" href="https://en.wikipedia.org/wiki/Twelve-Factor_App_methodology" rel="noopener ugc nofollow" target="_blank">十二因素应用</a>和我使用的成熟工具的影响。将这种方式抽象到一个包中是下一个直观的事情。</p></div><div class="ab cl nj nk hx nl" role="separator"><span class="nm bw bk nn no np"/><span class="nm bw bk nn no np"/><span class="nm bw bk nn no"/></div><div class="im in io ip iq"><h1 id="8665" class="ky kz it bd la lb nq ld le lf nr lh li jz ns ka lk kc nt kd lm kf nu kg lo lp bi translated">设计我自己的包/框架</h1><p id="9681" class="pw-post-body-paragraph lq lr it ls b lt lu ju lv lw lx jx ly lz ma mb mc md me mf mg mh mi mj mk ml im bi translated">有许多事情需要决定。从文件加载？支持什么格式？从环境变量加载？从标志加载？混合所有这些？如何将原生Go结构的键映射到不同的格式？哪些方法更适合新兴的云原生应用？</p></div><div class="ab cl nj nk hx nl" role="separator"><span class="nm bw bk nn no np"/><span class="nm bw bk nn no np"/><span class="nm bw bk nn no"/></div><div class="im in io ip iq"><h1 id="5973" class="ky kz it bd la lb nq ld le lf nr lh li jz ns ka lk kc nt kd lm kf nu kg lo lp bi translated">云原生方式</h1><p id="6c6b" class="pw-post-body-paragraph lq lr it ls b lt lu ju lv lw lx jx ly lz ma mb mc md me mf mg mh mi mj mk ml im bi translated">Cloud native有一些特定的特征，这些特征会影响到我们想要设计的已定义方法的决定。</p><p id="7ce6" class="pw-post-body-paragraph lq lr it ls b lt mn ju lv lw mo jx ly lz mp mb mc md mq mf mg mh mr mj mk ml im bi translated">云原生应用的主要特征之一是配置应该被外部化。这意味着没有硬编码的值。</p><p id="56df" class="pw-post-body-paragraph lq lr it ls b lt mn ju lv lw mo jx ly lz mp mb mc md mq mf mg mh mr mj mk ml im bi translated">将配置外部化到配置文件是不够的。您不能将包含您的机密和凭证的配置文件提交给VCS。那么我们仍然需要某种方式来为我们的生产应用程序提供秘密，而不需要在源代码中包含它。环境变量通常用于此。</p><blockquote class="nv nw nx"><p id="4d89" class="lq lr ny ls b lt mn ju lv lw mo jx ly nz mp mb mc oa mq mf mg ob mr mj mk ml im bi translated">“检验您是否已经正确地外部化了您的凭证和配置的试金石是想象您的应用程序的源代码被推送到GitHub的后果。”<br/> —凯文·霍夫曼，超越十二因素应用</p></blockquote><p id="5e2b" class="pw-post-body-paragraph lq lr it ls b lt mn ju lv lw mo jx ly lz mp mb mc md mq mf mg mh mr mj mk ml im bi translated">通过查看所有不同的配置加载方法，我总结了以下几点。</p><h2 id="c72d" class="ms kz it bd la mt mu dn le mv mw dp li lz mx my lk md mz na lm mh nb nc lo nd bi translated">我们可能需要的东西</h2><ol class=""><li id="5dd0" class="oc od it ls b lt lu lw lx lz oe md of mh og ml oh oi oj ok bi translated"><strong class="ls iu">从配置文件加载。</strong>这是最流行的方法。尽管十二因素应用程序不鼓励这样做，因为它很容易将秘密错误地提交给VCS，但它仍然是一种非常直观的方法，像Kubernetes的<code class="fe nf ng nh ni b">ConfigMaps</code>这样的功能可以很容易地将配置作为秘密加载到应用程序中。</li><li id="ed7b" class="oc od it ls b lt ol lw om lz on md oo mh op ml oh oi oj ok bi translated"><strong class="ls iu">从环境变量加载。</strong>环境变量通常包含应用程序的秘密(例如，数据库连接字符串)。</li><li id="1e85" class="oc od it ls b lt ol lw om lz on md oo mh op ml oh oi oj ok bi translated"><strong class="ls iu">在配置文件中替换环境变量值的方法。</strong>这可以让我们将我们的配置文件跟踪到VCS，以便进行通用的非机密配置，同时替换来自en vars的特定于环境的值或机密，有效地结合了两者的优点。</li></ol><h2 id="02f3" class="ms kz it bd la mt mu dn le mv mw dp li lz mx my lk md mz na lm mh nb nc lo nd bi translated">我们不需要的东西</h2><ol class=""><li id="598e" class="oc od it ls b lt lu lw lx lz oe md of mh og ml oh oi oj ok bi translated"><strong class="ls iu">从远程源加载。</strong>如果配置在远程源中，则获取该配置的责任应委托给操作员。</li><li id="0290" class="oc od it ls b lt ol lw om lz on md oo mh op ml oh oi oj ok bi translated"><strong class="ls iu">配置改变时热重装</strong>。云原生应用程序应该是一次性的，要更改配置，只需重启应用程序。</li></ol></div><div class="ab cl nj nk hx nl" role="separator"><span class="nm bw bk nn no np"/><span class="nm bw bk nn no np"/><span class="nm bw bk nn no"/></div><div class="im in io ip iq"><h1 id="2970" class="ky kz it bd la lb nq ld le lf nr lh li jz ns ka lk kc nt kd lm kf nu kg lo lp bi translated">支持这些想法</h1><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi oq"><img src="../Images/e7be648a9d295d458cc4184aa168ef99.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*evA3dJXhnRZdzXlO"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">马克·弗莱彻·布朗在<a class="ae ne" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的照片</p></figure><h2 id="2cea" class="ms kz it bd la mt mu dn le mv mw dp li lz mx my lk md mz na lm mh nb nc lo nd bi translated">1.看十二因素，三。配置</h2><p id="a309" class="pw-post-body-paragraph lq lr it ls b lt lu ju lv lw lx jx ly lz ma mb mc md me mf mg mh mi mj mk ml im bi translated">十二要素应用程序定义了在云原生和容器化世界中现代应用程序的一些原则:</p><blockquote class="nv nw nx"><p id="f426" class="lq lr ny ls b lt mn ju lv lw mo jx ly nz mp mb mc oa mq mf mg ob mr mj mk ml im bi translated"><strong class="ls iu">"十二因素应用程序将配置存储在<em class="it">环境变量中。<br/> </em> </strong> Env变量很容易在部署之间改变，不需要改变任何代码；与配置文件不同，它们被意外签入代码仓库的可能性很小；与定制配置文件或其他配置机制(如Java系统属性)不同，它们是与语言和操作系统无关的标准。”——<a class="ae ne" href="https://12factor.net/config" rel="noopener ugc nofollow" target="_blank">十二因子，三。配置</a></p></blockquote><p id="c654" class="pw-post-body-paragraph lq lr it ls b lt mn ju lv lw mo jx ly lz mp mb mc md mq mf mg mh mr mj mk ml im bi translated">对所有事情都使用环境变量？但是等等，为什么许多应用程序(现代的也是)仍然使用配置文件？环境变量对于机密和特定于环境的配置有意义，但是我们仍然可以在配置文件中使用通用配置。事实上，跟踪这个文件及其在VCS的历史可以让我们更好地了解我们的应用程序。</p><h2 id="9e1e" class="ms kz it bd la mt mu dn le mv mw dp li lz mx my lk md mz na lm mh nb nc lo nd bi translated">2.着眼于成熟的、广泛使用的项目</h2><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi or"><img src="../Images/bedbaba7cdbf144a9e2c11dc3c89cc8a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*oa33fil3tRG3s6h7NSVT-w.jpeg"/></div></div></figure><p id="2017" class="pw-post-body-paragraph lq lr it ls b lt mn ju lv lw mo jx ly lz mp mb mc md mq mf mg mh mr mj mk ml im bi translated">查看我使用过的工具，我发现管理配置对一些人来说是一种乐趣和灵活性，但对另一些人来说却非常令人沮丧。我们将看看<a class="ae ne" href="https://www.elastic.co/" rel="noopener ugc nofollow" target="_blank"> Elasticsearch </a>和<a class="ae ne" href="https://neo4j.com/" rel="noopener ugc nofollow" target="_blank"> Neo4J </a>。两者都是可以有许多配置的数据库，并且同样频繁地部署在裸机和集装箱化环境中。</p><p id="e18b" class="pw-post-body-paragraph lq lr it ls b lt mn ju lv lw mo jx ly lz mp mb mc md mq mf mg mh mr mj mk ml im bi translated"><strong class="ls iu">弹性搜索</strong></p><ul class=""><li id="8e6c" class="oc od it ls b lt mn lw mo lz os md ot mh ou ml ov oi oj ok bi translated">Elasticsearch使用单个<code class="fe nf ng nh ni b"><a class="ae ne" href="https://www.elastic.co/guide/en/elasticsearch/reference/current/settings.html#config-files-location" rel="noopener ugc nofollow" target="_blank">elasticsearch.yml</a></code>文件保存大多数配置。</li><li id="5339" class="oc od it ls b lt ol lw om lz on md oo mh op ml ov oi oj ok bi translated">它支持扩展的<a class="ae ne" href="https://www.elastic.co/guide/en/elasticsearch/reference/current/settings.html#_environment_variable_substitution" rel="noopener ugc nofollow" target="_blank">环境变量，这允许您在一个(否则是静态的)<code class="fe nf ng nh ni b">elasticsearch.yml</code>文件中引用环境变量，并在运行时替换值。</a></li></ul><pre class="kj kk kl km gt ow ni ox oy aw oz bi"><span id="7957" class="ms kz it ni b gy pa pb l pc pd">node.name: ${HOSTNAME}_node     ==&gt;     node.name: elastic1_node<br/>                    WHERE $HOSTNAME=elastic1</span></pre><ul class=""><li id="58cb" class="oc od it ls b lt mn lw mo lz os md ot mh ou ml ov oi oj ok bi translated">Elasticsearch Docker image通过传递具有相同键名的环境变量<strong class="ls iu"> </strong>支持<a class="ae ne" href="https://www.elastic.co/guide/en/elasticsearch/reference/current/docker.html#docker-compose-file" rel="noopener ugc nofollow" target="_blank">覆盖</a> <code class="fe nf ng nh ni b"><a class="ae ne" href="https://www.elastic.co/guide/en/elasticsearch/reference/current/docker.html#docker-compose-file" rel="noopener ugc nofollow" target="_blank">elasticsearch.yml</a></code> <a class="ae ne" href="https://www.elastic.co/guide/en/elasticsearch/reference/current/docker.html#docker-compose-file" rel="noopener ugc nofollow" target="_blank">配置</a>。因此，设置ENV <code class="fe nf ng nh ni b">cluster.name=es-docker-cluster</code>将覆盖<code class="fe nf ng nh ni b">elasticsearch.yml</code>中设置的<code class="fe nf ng nh ni b">cluster.name</code>。</li><li id="8d96" class="oc od it ls b lt ol lw om lz on md oo mh op ml ov oi oj ok bi translated">其他弹性产品支持<a class="ae ne" href="https://www.elastic.co/guide/en/beats/libbeat/current/config-file-format-env-vars.html#_specify_complex_objects_in_environment_variables" rel="noopener ugc nofollow" target="_blank">在环境变量</a>中表达复杂的嵌套配置。</li></ul><p id="e4ae" class="pw-post-body-paragraph lq lr it ls b lt mn ju lv lw mo jx ly lz mp mb mc md mq mf mg mh mr mj mk ml im bi translated">总之，<code class="fe nf ng nh ni b">elasticsearch.yml</code>用于设置公共配置，而机密和特定于实例的配置是使用环境变量设置的。</p><p id="d6ab" class="pw-post-body-paragraph lq lr it ls b lt mn ju lv lw mo jx ly lz mp mb mc md mq mf mg mh mr mj mk ml im bi translated"><strong class="ls iu"> Neo4j </strong></p><p id="e296" class="pw-post-body-paragraph lq lr it ls b lt mn ju lv lw mo jx ly lz mp mb mc md mq mf mg mh mr mj mk ml im bi translated">Neo4j使用类似的设置，只有一个<code class="fe nf ng nh ni b">neo4j.conf</code>文件，并且能够使用环境变量替换值，其中键是大写的，前缀为<code class="fe nf ng nh ni b">NEO4J_</code>，下划线写成<code class="fe nf ng nh ni b">__</code>，而<code class="fe nf ng nh ni b">.</code>写成<code class="fe nf ng nh ni b">_</code>。</p><pre class="kj kk kl km gt ow ni ox oy aw oz bi"><span id="e299" class="ms kz it ni b gy pa pb l pc pd">neo4j.conf:<br/>node.name: local_node<br/>                                &gt;&gt;&gt;     Loaded Value = prod_node<br/>Enviroment Variable:<br/>NEO4J_NODE_NAME=prod_node</span></pre><h2 id="55de" class="ms kz it bd la mt mu dn le mv mw dp li lz mx my lk md mz na lm mh nb nc lo nd bi translated">结论</h2><p id="dd19" class="pw-post-body-paragraph lq lr it ls b lt lu ju lv lw lx jx ly lz ma mb mc md me mf mg mh mi mj mk ml im bi translated">流行的工具结合了两者的优点，既允许你拥有配置文件，又允许你完全依赖环境变量，并与12个因素的应用程序兼容。</p><p id="947e" class="pw-post-body-paragraph lq lr it ls b lt mn ju lv lw mo jx ly lz mp mb mc md mq mf mg mh mr mj mk ml im bi translated">配置文件可用于设置应用程序的公共和默认配置文件，在VCS使用环境变量进行机密或特定于主机的配置时，这种方式是安全的。</p></div><div class="ab cl nj nk hx nl" role="separator"><span class="nm bw bk nn no np"/><span class="nm bw bk nn no np"/><span class="nm bw bk nn no"/></div><div class="im in io ip iq"><h1 id="f571" class="ky kz it bd la lb nq ld le lf nr lh li jz ns ka lk kc nt kd lm kf nu kg lo lp bi translated">定义框架</h1><p id="f535" class="pw-post-body-paragraph lq lr it ls b lt lu ju lv lw lx jx ly lz ma mb mc md me mf mg mh mi mj mk ml im bi translated">尝试结合十二因子App和Elasticsearch、Neo4j等热门项目的不同方法，得出了这个定义。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi pe"><img src="../Images/e3c1337501047a54ea4850893c48d912.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*74hN9U_zCBuFu0qNRuDk6g.png"/></div></div></figure><ol class=""><li id="954b" class="oc od it ls b lt mn lw mo lz os md ot mh ou ml oh oi oj ok bi translated">代码中的应用程序配置是将在应用程序启动时填充的单个结构(具有嵌套结构)。</li><li id="1c80" class="oc od it ls b lt ol lw om lz on md oo mh op ml oh oi oj ok bi translated">该配置将被写入一个单独的配置文件(如<code class="fe nf ng nh ni b">config.yml</code> ) <br/>，并支持<code class="fe nf ng nh ni b">.json</code>和<code class="fe nf ng nh ni b">.toml</code>格式。(包将从文件扩展名推断格式。)</li><li id="10fb" class="oc od it ls b lt ol lw om lz on md oo mh op ml oh oi oj ok bi translated">配置应支持使用<code class="fe nf ng nh ni b">${ENV|default}</code>表达式扩展/替换环境变量。<br/>示例:<code class="fe nf ng nh ni b">host: www.example.com:<strong class="ls iu">%{PORT|3306}</strong></code>，如果未设置包络<code class="fe nf ng nh ni b">${PORT}</code>(受弹性启发)，则<code class="fe nf ng nh ni b">3306</code>为默认值。</li><li id="a6f2" class="oc od it ls b lt ol lw om lz on md oo mh op ml oh oi oj ok bi translated">前缀为<code class="fe nf ng nh ni b">CONFIG_</code>的环境变量，后跟大写的配置键路径，<code class="fe nf ng nh ni b">_</code>替换为<code class="fe nf ng nh ni b">__</code>，而<code class="fe nf ng nh ni b">.</code>替换为<code class="fe nf ng nh ni b">_</code>将替换并覆盖配置文件中的配置(受Neo4j启发)。<br/>示例:可以通过设置<code class="fe nf ng nh ni b">CONFIG_DATABASE_PASSWORD<strong class="ls iu"><br/></strong></code>来设置键<code class="fe nf ng nh ni b">database.password</code>的值*前缀应该是可配置的。</li><li id="3c7b" class="oc od it ls b lt ol lw om lz on md oo mh op ml oh oi oj ok bi translated">这个包应该是<code class="fe nf ng nh ni b">.env</code>感知的，加载<code class="fe nf ng nh ni b">.env</code>文件，如果它存在的话，这对本地开发非常方便。</li><li id="f8d1" class="oc od it ls b lt ol lw om lz on md oo mh op ml oh oi oj ok bi translated">这个包应该能够在本质上是单行的环境变量中表达复杂/嵌套的结构。这是通过JSON将这些结构编码到一个字符串中来实现的，这个包负责解码和解组。</li><li id="fb94" class="oc od it ls b lt ol lw om lz on md oo mh op ml oh oi oj ok bi translated">使用快速验证标签(我使用了<a class="ae ne" href="https://github.com/go-playground/validator" rel="noopener ugc nofollow" target="_blank"> go-playground/validator </a>标签)和<code class="fe nf ng nh ni b">Validatable</code>接口提供验证方法来验证加载时的值，包将在每个兼容类型上使用这些接口来调用<code class="fe nf ng nh ni b">Validate()</code>方法。</li></ol></div><div class="ab cl nj nk hx nl" role="separator"><span class="nm bw bk nn no np"/><span class="nm bw bk nn no np"/><span class="nm bw bk nn no"/></div><div class="im in io ip iq"><h1 id="9922" class="ky kz it bd la lb nq ld le lf nr lh li jz ns ka lk kc nt kd lm kf nu kg lo lp bi translated">瞧啊。</h1><pre class="kj kk kl km gt ow ni ox oy aw oz bi"><span id="b658" class="ms kz it ni b gy pa pb l pc pd">config := &amp;Config{}</span><span id="54e4" class="ms kz it ni b gy pf pb l pc pd">// Create Loader and Load Config<br/>Loader, err := configuro.NewConfig()<br/>err = Loader.Load(config)</span></pre><p id="50fe" class="pw-post-body-paragraph lq lr it ls b lt mn ju lv lw mo jx ly lz mp mb mc md mq mf mg mh mr mj mk ml im bi translated">这将根据上面定义的方式加载配置，只需要两行代码。</p><p id="c746" class="pw-post-body-paragraph lq lr it ls b lt mn ju lv lw mo jx ly lz mp mb mc md mq mf mg mh mr mj mk ml im bi translated">但在某种意义上，它仍然应该是可定制的。这可以通过将选项传递给<code class="fe nf ng nh ni b">NewConfig(...ConfigOptions)</code>构造函数来实现:</p><pre class="kj kk kl km gt ow ni ox oy aw oz bi"><span id="7699" class="ms kz it ni b gy pa pb l pc pd">func WithLoadFromConfigFile(Filepath string, ErrIfFileNotFound bool)<br/>func WithoutLoadFromConfigFile()</span><span id="fe25" class="ms kz it ni b gy pf pb l pc pd">func WithLoadFromEnvVars(EnvPrefix string)<br/>func WithoutLoadFromEnvVars()</span><span id="bea0" class="ms kz it ni b gy pf pb l pc pd">func WithLoadDotEnv(envDotFilePath string)<br/>func WithoutExpandEnvVars()</span><span id="ece7" class="ms kz it ni b gy pf pb l pc pd">func WithExpandEnvVars()<br/>func WithoutLoadDotEnv()</span><span id="c730" class="ms kz it ni b gy pf pb l pc pd">func WithLoadDotEnv(envDotFilePath string)<br/>func WithoutLoadDotEnv()</span><span id="e589" class="ms kz it ni b gy pf pb l pc pd">func WithValidateByFunc(stopOnFirstErr bool, recursive bool)<br/>func WithoutValidateByFunc()</span><span id="0ac9" class="ms kz it ni b gy pf pb l pc pd">func WithValidateByTags()<br/>func WithoutValidateByTags()</span></pre></div><div class="ab cl nj nk hx nl" role="separator"><span class="nm bw bk nn no np"/><span class="nm bw bk nn no np"/><span class="nm bw bk nn no"/></div><div class="im in io ip iq"><h1 id="bcb3" class="ky kz it bd la lb nq ld le lf nr lh li jz ns ka lk kc nt kd lm kf nu kg lo lp bi translated">结论</h1><p id="3f3d" class="pw-post-body-paragraph lq lr it ls b lt lu ju lv lw lx jx ly lz ma mb mc md me mf mg mh mi mj mk ml im bi translated">有一个框架来定义您的应用程序配置是必须的。在配置文件中具体化配置是不够的。它应该用于保存公共值，但是我们必须支持在配置文件中替换机密和特定于环境的值的方法。我们可以通过替换配置文件中的环境变量值来实现，或者通过使用环境变量用匹配特定模式的键完全覆盖特定的键来实现。这使我们能够轻松地将我们的应用程序部署到具有不同配置的不同环境中。</p><p id="8ba6" class="pw-post-body-paragraph lq lr it ls b lt mn ju lv lw mo jx ly lz mp mb mc md mq mf mg mh mr mj mk ml im bi translated">你可以在你的下一个项目中使用这个框架。</p><p id="8847" class="pw-post-body-paragraph lq lr it ls b lt mn ju lv lw mo jx ly lz mp mb mc md mq mf mg mh mr mj mk ml im bi translated">谢谢大家！</p></div></div>    
</body>
</html>