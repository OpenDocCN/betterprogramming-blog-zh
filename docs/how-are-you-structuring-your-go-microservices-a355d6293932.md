# 您如何构建您的 Go 微服务？

> 原文：<https://betterprogramming.pub/how-are-you-structuring-your-go-microservices-a355d6293932>

## 以下是我基于真实项目提出的解决方案

![](img/a4765262089b10012350b12ad4748d35.png)

微服务这个术语无疑是这些天来唯一飞速发展的趋势。许多公司已经将他们难以改变的大块转化为许多名为微服务的更小的移动部件。为此，Golang 无疑是目前最可行的选择之一。它可以帮助开发者快速构建微小但强大的服务。

过去，我们常常关注如何用许多抽象层来构建一个管理良好的应用程序。现在，我们可以把它们分成许多小的可部署单元。许多团队可以从事许多较小的项目，任何个人都可以通过开发较小规模的项目来做出贡献和成长。他们所有人都将相互交流以解决更大的问题。

因此，现在的问题已经从如何创建和设计一个大项目转移到创建和保持设计良好的小项目，并且对于开发和扩展足够灵活。

最近，我参加了一个公司的小任务，要求我实现一个 API 服务器。我必须提出一个易于理解、可组织和可维护的合适的架构。

经过一段时间对我在当前公司所做的一切进行操作后，我起草了一个基于样板 gRPC 服务的解决方案，它可以部署在任何平台上。它可能有许多地方需要改进，但我很乐意分享这个项目。

[](https://github.com/vchitai/togo) [## GitHub-vchi tai/多哥

### 如何在本地运行你的代码？要运行服务器，使用一个简单的命令:$ make run 一个示例“curl”命令来调用…

github.com](https://github.com/vchitai/togo) 

项目结构受到项目标准 Go 项目布局的启发。我也加入了我自己基于干净架构原则的创新。

# 项目结构

总的来说，在 Golang 项目中，我们有许多服务于许多用例的包。只有少数几个存储 Go 代码实现，如`cmd`、`configs`、`internal`、`pkg`，其他的用于测试`mocks`、`test`、记录`docs`和集成:`proto`、`pb`、本地开发:`local`

*   `cmd`:包含应用程序的所有入口点
*   `configs`:存储应用的所有配置
*   `docs`:申请的所有可用文件
*   `internal`:项目私人包
*   `pkg`:项目公共包
*   允许每个人在本地环境中运行你的代码的所有额外的东西。
*   `mocks`:模拟对你的应用程序进行单元测试的东西
*   `proto` : `protobuf` 为您的微服务定义(我与 gRPC 通信方法一起用于我公司的内部服务通信，您可以像`jsonschema, graphQL or SOAP contract)`一样存储另一个合同)
*   `pb` **(可能是** `api` **)** :由 protobuf 生成的代码
*   `test`:为您的微服务集成

**生产就绪型微服务的额外灵丹妙药**

对于准备在生产环境中发布的微服务，我们工程师不能仅仅构建一些可运行的二进制文件。生产环境是混沌环境，数据变化速度远远高于实验环境，到处都是坑坑洼洼的障碍物。这些事情可能会彻底破坏你的应用程序。

为了处理这些问题，我们需要一种方法来监控我们的服务，并迅速采取行动进行故障排除。源代码必须是可维护的、可扩展的，并且满足大量的非功能性需求。

*   对于版本控制选项，我建议使用 git，因为它是这个领域最明显的选择之一。你不能独自开发这个项目。迟早，你会需要更多的人加入你。为了转移目的和新成员的加入，保持项目的良好文档记录，命令行缩写程序的 Makefile(也是如何安装和运行项目的好指南)是一个好的选择，ReadmeMD 是必须的。
*   对于任何项目来说，单元测试都应该集中在保持道路畅通和降低风险上。实现良好的单元测试可以降低修改源代码的风险，尤其是当项目规模以指数速度增长时。我一直在使用 linter 的`golang-ci-lint`工具(检查源代码是实现该语言的最佳实践，这将有助于我们更容易地关注其他方面)。`Go test` 是一个完美的工具，在 go 1.18 中引入模糊时会更好，现在你只需要一个 mock 工具来更容易地实现项目包层分离，实现干净的架构师。
*   对于构建和部署您的微服务，目前最简单的解决方案是通过集装箱技术运输。您的应用程序将被保存在一个非常小的、隔离的环境中，这样当一个服务失败时，您的另一个服务不会受到影响。目前最常用的堆栈是 via Docker 和 k8s 技术。保持部署流程的精益是最大限度地降低推广和替换服务的风险的关键。此外，最小化的流程有助于您的应用程序以更高的速度启动修补程序，从而减少事件的规模。

所以我把所有这些东西都放在了项目中:

*   `Dockerfile` & `.dockerignore`:将你的应用程序容器化，使其可以在任何现有的基础设施上运行。
*   `.git` & `.gitignore` : git 版本控制是目前管理你的项目的最佳选择。
*   `.golangci.yaml`:T5 的指导方针，是目前可用于 Go 的最好的棉绒之一。
*   为了单元测试的目的，生成你的模拟材料。
*   创建一个非常方便的快捷命令。
*   `README.md`:绝对是你项目的灵魂。
*   `buf.gen.yaml` & `buf.work.yaml`:使用 buf.build 进行原型代码生成。
*   `tools.go`:添加您的`go build` 工具依赖。
*   `go.mod` & `go.sum` : go 模块文件

## 通用架构

在 work Clean Architecture 中，我们已经了解了软件应该如何设计。在最典型的用例中，我们将需要实体、用例以及许多支持的实用程序包。在微服务生态系统中，我们仍然使用具有扩展上下文的相同术语。领域实体和用例不仅包含在一个服务中，而且可以跨服务共享。但是每个微服务内部的层的设计仍然是相同的。

在最常见的用例中，我通常会实现:

*   实体:服务的核心域对象。没有业务实体，服务就没有存在的意义。
*   用例:涵盖交互的业务方面和每个实体的行为。
*   框架和驱动程序:服务于一般情况的实用程序，不仅仅是提到的服务
*   存储库:包装存储和管理实体状态的行为。通常，我看到许多服务是用错误的视点实现的。存储库可以是另一个外部微服务或 DB 引擎。在存储库中处理的事务应该被视为全局分布式事务。
*   API:其他外部服务为了熟悉服务而需要知道的唯一接口。
*   入口点:将所有组件集成到一个可运行的二进制服务特性中的地方，比如服务器监听和处理或者

我设计并实现了许多微服务，从商业模式相关的服务到技术服务。我设计的任何东西都不会使用除了这些层分类之外的任何东西，并且遵循 Clean Architecture 中陈述的依赖规则真正使它们以一种可爱的方式合作。

微服务生态系统让我从在任何微小的微服务内部设计如此复杂和复杂的架构师中解放出来，而是更加专注于如何从更高的角度解决问题，许多可替换的移动部件形成更大的管道。

## **集成水平**

一般来说，每个微服务代表一个有意从更大的画面中分离出来的模块。那个模块必须有自己的业务领域(它存在的目的)，必须有相应的层和架构(足够的灵活性可以修改)。

考虑到需要一种方法来灵活地插入和播放模块，在最方便的情况下，我们可以假装它是本机插入的部件。gRPC 目前为我们提供了许多最大的优势。

*   处理向后和向前兼容性的解决方案。
*   您可以用许多不同的语言生成 gRPC 客户端，并且可以在您的代码库中将它作为本机插件使用。(较低的网络协议已悄悄完成)
*   HTTP/2 是一个很好的面向未来的协议。
*   精心设计的原则和广泛开放的社区支持资源。

在过去，我经历了许多关于服务沟通的问题。大部分来自于通信合同中的不匹配。JSON schema(或 GraphQL)的发展历史表明了解决问题的努力。另一个是试图编写提供稳定通信方法(带有重试、网络池等)的最佳 HTTP 客户端的工作成本。在那里,`gRPC` 和`protobuf` 继续以一种极其简单的方式解决这些问题。对于任何不需要立即处理请求的用例，您也可以将它们`protobuf` 作为一种在排队、轮询或流系统中序列化的方式。

有了清晰的沟通方式，生态系统中的活动部分现在只剩下:

*   API 服务器:提供与服务域对象的交互。
*   Cron jobs:在一天中的某个时刻完成工作的人。
*   轮询作业:用于处理应用程序产生的数据的消费者或循环到世界尽头的作业。

# 结论

通过一次招聘挑战，我有机会在多年后总结我对后端软件设计的观点。我喜欢与每个使用 Go 后端服务的人分享我的想法。希望我能从其他人那里听到并改进它。