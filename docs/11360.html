<html>
<head>
<title>From Hours to Seconds: A Tale of SQL Query Optimization</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">从数小时到数秒:SQL查询优化的故事</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/from-hours-to-seconds-a-tale-of-sql-query-optimization-e0d38066e043?source=collection_archive---------1-----------------------#2022-03-13">https://betterprogramming.pub/from-hours-to-seconds-a-tale-of-sql-query-optimization-e0d38066e043?source=collection_archive---------1-----------------------#2022-03-13</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="0864" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">查询优化技术的一个例子</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/3ea852b2e73171d619775b5a35f9079f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*cGzAhzrpH_tx7FmNE0lWUw.jpeg"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">upklyak创作的卡通城堡矢量—<a class="ae kv" href="http://www.freepik.com" rel="noopener ugc nofollow" target="_blank">www.freepik.com</a></p></figure><p id="4aef" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">那是星期一中午。当一个新特性发布到产品中时，我知道它会导致大量新记录被添加到表中:<code class="fe ls lt lu lv b">movies</code>。但是我不知道接下来会发生什么。</p><h1 id="b03b" class="lw lx iq bd ly lz ma mb mc md me mf mg jw mh jx mi jz mj ka mk kc ml kd mm mn bi translated">问题是</h1><p id="901c" class="pw-post-body-paragraph kw kx iq ky b kz mo jr lb lc mp ju le lf mq lh li lj mr ll lm ln ms lp lq lr ij bi translated">我监控了一个客户的日志，等待一个主要流程完成，然后确认发布没有破坏任何东西。随着时间的推移，流程未能完成，我意识到有些地方出错了。</p><p id="5b75" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">因为这是一个关键的过程，而一个客户在另一边等着，所以我必须马上修复它。在一次调试过程中，我发现我们的一个数据库查询变得非常慢。手术花了几个小时才完成。</p><h2 id="15b0" class="mt lx iq bd ly mu mv dn mc mw mx dp mg lf my mz mi lj na nb mk ln nc nd mm ne bi translated">“淘气”的查询</h2><pre class="kg kh ki kj gt nf lv ng nh aw ni bi"><span id="3329" class="mt lx iq lv b gy nj nk l nl nm">SELECT   <br/>  title,   <br/>  director,  <br/>  time <br/>FROM movies <br/>WHERE  <br/>  idStudio= 10 AND   <br/>  genre IN ('Crime Thriller', 'Spy Thriller', 'Legal Thriller') AND   <br/>  time &gt; '1970-01-01' <br/>ORDER BY time ASC <br/>LIMIT 10000</span></pre><p id="19f9" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">关于<code class="fe ls lt lu lv b">movies</code>表，值得注意以下几点:</p><ol class=""><li id="894d" class="nn no iq ky b kz la lc ld lf np lj nq ln nr lr ns nt nu nv bi translated">这是一个InnoDB表。</li><li id="4612" class="nn no iq ky b kz nw lc nx lf ny lj nz ln oa lr ns nt nu nv bi translated">表的主键是<code class="fe ls lt lu lv b">id</code>，这是一个自动递增的列，用于给每一行一个惟一的标识。</li><li id="b948" class="nn no iq ky b kz nw lc nx lf ny lj nz ln oa lr ns nt nu nv bi translated">该表的两个索引是:<br/>a .<code class="fe ls lt lu lv b">KEY `idx_time` (`time`)</code>T17】b .<code class="fe ls lt lu lv b">KEY `idx_idStudio_genre_time` (`idStudio`,`genre `,`time`)</code></li></ol><p id="9de7" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">请注意:</p><ul class=""><li id="25b6" class="nn no iq ky b kz la lc ld lf np lj nq ln nr lr ob nt nu nv bi translated">索引<code class="fe ls lt lu lv b">idx_idStudio_genre_time</code>涵盖了“淘气”查询的<code class="fe ls lt lu lv b">WHERE</code>子句中使用的列。</li><li id="2c1a" class="nn no iq ky b kz nw lc nx lf ny lj nz ln oa lr ob nt nu nv bi translated">在<code class="fe ls lt lu lv b">SELECT</code>子句中有两列(<code class="fe ls lt lu lv b">title</code>、<code class="fe ls lt lu lv b">director</code>)没有被表的任何索引覆盖。</li></ul><h2 id="b70b" class="mt lx iq bd ly mu mv dn mc mw mx dp mg lf my mz mi lj na nb mk ln nc nd mm ne bi translated">放弃</h2><p id="1eb9" class="pw-post-body-paragraph kw kx iq ky b kz mo jr lb lc mp ju le lf mq lh li lj mr ll lm ln ms lp lq lr ij bi translated">您可能已经猜到，我不从事电影行业，因此电影表是虚构的，但是表索引和查询结构是基于原始查询的。</p><h1 id="75dc" class="lw lx iq bd ly lz ma mb mc md me mf mg jw mh jx mi jz mj ka mk kc ml kd mm mn bi translated">没有选择的路——改变桌子</h1><p id="5364" class="pw-post-body-paragraph kw kx iq ky b kz mo jr lb lc mp ju le lf mq lh li lj mr ll lm ln ms lp lq lr ij bi translated">最初，我的方法是改变<code class="fe ls lt lu lv b">movies</code>表的结构(从而修改查询)。</p><p id="8792" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我使用了<code class="fe ls lt lu lv b">explain</code>语句来收集关于MySQL优化器如何执行查询的信息，看起来MySQL优化器并没有选择我期望的索引。我预计会选择<code class="fe ls lt lu lv b">idx_idStudio_genre_time</code>索引，但结果却是选择了<code class="fe ls lt lu lv b">idx_time</code>索引。</p><p id="b3d5" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">此外，我们在查询的<code class="fe ls lt lu lv b">SELECT</code>子句中选择了两列(<code class="fe ls lt lu lv b">title</code>和<code class="fe ls lt lu lv b">director</code>，它们没有被任何索引覆盖。在这种情况下，MySQL遍历整个表来检索不在索引中的列的值。这可能会导致性能问题。</p><p id="81a0" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">而且，查询有两个范围条件:<code class="fe ls lt lu lv b">genre IN (...) AND time &gt; '1970-01-01'</code>。一旦满足第一个范围条件，查询中的任何后续条件都不会使用任何进一步的索引。索引中同时包含<code class="fe ls lt lu lv b">genre</code>和<code class="fe ls lt lu lv b">time</code>不会影响查询性能。索引只是占用了额外的存储空间。</p><p id="3b6c" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我打算改进表索引并向表中添加列，以解决这些问题和其他问题。例如，“犯罪惊悚片”、“间谍惊悚片”和“法律惊悚片”都属于同一类别:“惊悚片”。通过向表中添加一个<code class="fe ls lt lu lv b">category</code>列并用<code class="fe ls lt lu lv b">INDEX(`idStudio`,`category`,`time`)</code>对其进行索引，我们可以更新查询以使用<code class="fe ls lt lu lv b">category</code>而不是<code class="fe ls lt lu lv b">genre</code>，从而避免使用第二个范围条件。</p><p id="ab31" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我的目标是提高查询性能，但是，我提出的方法有两个主要缺点:</p><ul class=""><li id="5c6a" class="nn no iq ky b kz la lc ld lf np lj nq ln nr lr ob nt nu nv bi translated">首先，索引有很大的开销。添加更多索引时，索引表上的写入速度会变慢。</li><li id="753b" class="nn no iq ky b kz nw lc nx lf ny lj nz ln oa lr ob nt nu nv bi translated">第二，桌子太大了，所以要花几个小时来改变它。为了测试我的理论，我复制了我们的数据库(模拟生产尺寸表)并在测试数据库的<code class="fe ls lt lu lv b">movies</code>表中添加了<strong class="ky ir">一个</strong>列。因为这个表太大了，所以迁移花了7个小时。</li></ul><p id="fa5b" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">此时，很明显这不是我们想要走的路。更改<code class="fe ls lt lu lv b">movies</code>表有更广泛的影响，需要很长时间，我们面临着一个紧迫的问题。</p><h1 id="df63" class="lw lx iq bd ly lz ma mb mc md me mf mg jw mh jx mi jz mj ka mk kc ml kd mm mn bi translated">选择的道路—重写查询</h1><p id="1785" class="pw-post-body-paragraph kw kx iq ky b kz mo jr lb lc mp ju le lf mq lh li lj mr ll lm ln ms lp lq lr ij bi translated">“唯一代码”解决方案是最快的策略。我们可以在数据库上手动运行它，以立即了解查询的性能，然后将其合并到产品中，并为我们所有的客户进行测试。如果不起作用，我们可以通过单击回滚到之前的查询。</p><p id="d08c" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">尽管看起来希望渺茫，但我们选择更新查询以利用表的现有索引<code class="fe ls lt lu lv b">idx_idStudio_genre_time</code>，并减少查询从中选择<code class="fe ls lt lu lv b">title</code>、<code class="fe ls lt lu lv b">director</code>和<code class="fe ls lt lu lv b">time</code>列的数据集。</p><p id="9023" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">重写查询以产生与原始查询相同的结果的效果令人惊讶。查询不再在<strong class="ky ir">小时</strong>内执行，而是在<strong class="ky ir">秒</strong>内执行。</p><h2 id="ee77" class="mt lx iq bd ly mu mv dn mc mw mx dp mg lf my mz mi lj na nb mk ln nc nd mm ne bi translated">重写的查询</h2><pre class="kg kh ki kj gt nf lv ng nh aw ni bi"><span id="5791" class="mt lx iq lv b gy nj nk l nl nm">SELECT   <br/>  title,   <br/>  director,  <br/>  time <br/>FROM movies<br/>JOIN (<br/>  <strong class="lv ir">SELECT   <br/>    id<br/>  FROM movies<br/>  WHERE  <br/>    idStudio= 10 AND   <br/>    genre IN ('Crime Thriller', 'Spy Thriller', 'Legal Thriller')AND <br/>    time &gt; '1970-01-01' <br/>  ORDER BY time ASC <br/>  LIMIT 10000</strong><br/>) innerTable  <br/>ON movies.id = innerTable.id</span></pre><p id="ebda" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">请注意以下几点:</p><ul class=""><li id="956b" class="nn no iq ky b kz la lc ld lf np lj nq ln nr lr ob nt nu nv bi translated"><code class="fe ls lt lu lv b">JOIN</code>子句查询(“子查询”)与“淘气”查询相同。除了选择了作为<code class="fe ls lt lu lv b">movies</code>表主键的<code class="fe ls lt lu lv b">id</code>列。</li><li id="22db" class="nn no iq ky b kz nw lc nx lf ny lj nz ln oa lr ob nt nu nv bi translated">“子查询”产生的表称为<code class="fe ls lt lu lv b">innerTable</code>。</li><li id="a18c" class="nn no iq ky b kz nw lc nx lf ny lj nz ln oa lr ob nt nu nv bi translated">工作台<code class="fe ls lt lu lv b">movies</code>与工作台<code class="fe ls lt lu lv b">innerTable</code>连接。在“淘气”查询中选择的列是从重写的查询中的连接表中选择的。</li></ul><h1 id="4628" class="lw lx iq bd ly lz ma mb mc md me mf mg jw mh jx mi jz mj ka mk kc ml kd mm mn bi translated">有什么魔力？</h1><p id="a56e" class="pw-post-body-paragraph kw kx iq ky b kz mo jr lb lc mp ju le lf mq lh li lj mr ll lm ln ms lp lq lr ij bi translated">万岁！问题已经解决。现在，查询在几秒钟内返回结果，流程对我们的客户来说是有效的，每个人都很高兴。</p><p id="e983" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">但是这让我很困扰…为什么这个查询的性能要好得多呢？这两个查询提供了相同的输出，但是它们在大型数据集上的性能却大不相同…有什么诀窍吗？</p><p id="899a" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">你可能会惊讶地发现<a class="ae kv" href="https://dev.mysql.com/doc/refman/5.7/en/innodb-index-types.html" rel="noopener ugc nofollow" target="_blank"> MySQL会自动索引主键</a>。这意味着所有的<code class="fe ls lt lu lv b">movies</code>表索引都包括表的<code class="fe ls lt lu lv b">id</code>列。</p><p id="0bde" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><code class="fe ls lt lu lv b">idx_idStudio_genre_time</code>现在是“子查询”的<strong class="ky ir">覆盖索引</strong>。这是一个为查询提供所有必要结果的索引。因为“子查询”只使用属于该索引的列，所以可以快速地从索引树中提取所选的值(<code class="fe ls lt lu lv b">id</code>)。不像“淘气”查询，它需要额外的表查找来检索所有需要的列。</p><p id="54fe" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><code class="fe ls lt lu lv b">PRIMARY KEY</code>索引用于连接<code class="fe ls lt lu lv b">movies</code>和<code class="fe ls lt lu lv b">innerTable</code>表。使用<code class="fe ls lt lu lv b">eq_ref</code>连接类型连接表，如<code class="fe ls lt lu lv b">explain</code>输出中所述。这是可能的最佳连接类型之一。当索引的所有部分都被join使用并且索引是一个 <code class="fe ls lt lu lv b"><a class="ae kv" href="https://dev.mysql.com/doc/refman/5.7/en/explain-output.html" rel="noopener ugc nofollow" target="_blank">PRIMARY KEY</a></code>"时使用。</p><p id="88f8" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在查询中使用<code class="fe ls lt lu lv b">(INNER) JOIN</code>导致我们从中选择值的数据集的大小显著减小。当数据集较小时，选择<code class="fe ls lt lu lv b">title</code>、<code class="fe ls lt lu lv b">director</code>和<code class="fe ls lt lu lv b">time</code>列相对较快。</p><h1 id="3de2" class="lw lx iq bd ly lz ma mb mc md me mf mg jw mh jx mi jz mj ka mk kc ml kd mm mn bi translated">外卖食品</h1><ol class=""><li id="489b" class="nn no iq ky b kz mo lc mp lf oc lj od ln oe lr ns nt nu nv bi translated"><strong class="ky ir">做出“最小可行的改变”。</strong>当我们发现一个问题时，我们可能会试图解决所有有问题的方面，但是专注于最小的可测试解决方案，为我们的客户提供价值，让我们能够更快地行动并提供快速的解决方案。</li><li id="d6ab" class="nn no iq ky b kz nw lc nx lf ny lj nz ln oa lr ns nt nu nv bi translated">减少查询的FROM子句中的记录数量。如果您在查询大型表时遇到问题，请尝试使您从中选择值的数据集变小。例如，使用我在这篇博客中提到的技巧。</li><li id="d981" class="nn no iq ky b kz nw lc nx lf ny lj nz ln oa lr ns nt nu nv bi translated">充分利用你所拥有的。利用当前的表索引，了解数据库的“免费”功能，并创造性地使用它们。</li><li id="7b78" class="nn no iq ky b kz nw lc nx lf ny lj nz ln oa lr ns nt nu nv bi translated"><strong class="ky ir">与你的队友合作提出解决方案。</strong>头脑风暴是创造新想法的宝贵工具。当你和你的团队需要考虑一个新的解决方案时，尤其如此。</li><li id="30aa" class="nn no iq ky b kz nw lc nx lf ny lj nz ln oa lr ns nt nu nv bi translated"><strong class="ky ir">分享你学到的东西。与他人交流你的新知识和见解，这样他们也能从中受益。</strong></li></ol></div><div class="ab cl of og hu oh" role="separator"><span class="oi bw bk oj ok ol"/><span class="oi bw bk oj ok ol"/><span class="oi bw bk oj ok"/></div><div class="ij ik il im in"><p id="e641" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">感谢阅读。我希望这有所帮助！</p><p id="af2c" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">特别感谢我在鸟居的同事Lital Weiss和Tal Bereznitskey，感谢你们对这个问题的深思熟虑和集思广益。</p></div></div>    
</body>
</html>