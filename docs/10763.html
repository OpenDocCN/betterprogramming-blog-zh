<html>
<head>
<title>Create and Deploy Token on Ethereum</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">在以太坊上创建和部署令牌</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/creating-erc20-token-on-ethereum-35e109dd96e0?source=collection_archive---------8-----------------------#2022-01-26">https://betterprogramming.pub/creating-erc20-token-on-ethereum-35e109dd96e0?source=collection_archive---------8-----------------------#2022-01-26</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="276d" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">通过创建一个ERC20令牌来深入了解它</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/7095f709a6d3bba5808e380b2ed7f13c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1328/format:webp/1*FhxeUTY3vrk3oECG3-hC2w.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">资料来源:Undraw.co</p></figure><h1 id="13f4" class="kv kw iq bd kx ky kz la lb lc ld le lf jw lg jx lh jz li ka lj kc lk kd ll lm bi translated">erc20令牌标准</h1><p id="f961" class="pw-post-body-paragraph ln lo iq lp b lq lr jr ls lt lu ju lv lw lx ly lz ma mb mc md me mf mg mh mi ij bi translated">第一个标准由Fabian Vogelsteller于2015年11月作为以太坊征求意见稿(ERC)推出。它被自动分配到GitHub发行号20，由此得名“ERC20令牌”。目前绝大多数令牌都基于ERC20标准。ERC20征求意见稿最终成为以太坊改进提案20 (EIP-20)，但它大部分仍被称为原始名称ERC20。</p><p id="890d" class="pw-post-body-paragraph ln lo iq lp b lq mj jr ls lt mk ju lv lw ml ly lz ma mm mc md me mn mg mh mi ij bi translated">ERC20是可替换令牌的标准，这意味着ERC20令牌的不同单元是可互换的，并且没有唯一的属性。</p><p id="f31c" class="pw-post-body-paragraph ln lo iq lp b lq mj jr ls lt mk ju lv lw ml ly lz ma mm mc md me mn mg mh mi ij bi translated"><a class="ae mp" href="https://github.com/ethereum/EIPs/blob/master/EIPS/eip-20.md" rel="noopener ugc nofollow" target="_blank">ERC 20标准</a>为实现令牌的合同定义了一个公共接口，因此任何兼容的令牌都可以以相同的方式访问和使用。该接口由许多函数组成，这些函数必须出现在标准的每个实现中，还包括一些可选的函数和属性，这些函数和属性可以由开发人员添加。</p><h1 id="c09e" class="kv kw iq bd kx ky kz la lb lc ld le lf jw lg jx lh jz li ka lj kc lk kd ll lm bi translated">ERC20所需的功能和事件</h1><p id="3f1e" class="pw-post-body-paragraph ln lo iq lp b lq lr jr ls lt lu ju lv lw lx ly lz ma mb mc md me mf mg mh mi ij bi translated">符合ERC20的令牌合约必须至少提供以下功能和事件:</p><p id="425c" class="pw-post-body-paragraph ln lo iq lp b lq mj jr ls lt mk ju lv lw ml ly lz ma mm mc md me mn mg mh mi ij bi translated"><code class="fe mq mr ms mt b">totalSupply</code> : <strong class="lp ir"> <em class="mo"> </em> </strong>返回当前存在的该令牌的总单位。ERC20令牌可以有固定或可变的供应。</p><p id="ef3d" class="pw-post-body-paragraph ln lo iq lp b lq mj jr ls lt mk ju lv lw ml ly lz ma mm mc md me mn mg mh mi ij bi translated"><code class="fe mq mr ms mt b">balanceOf</code><em class="mo">:</em><strong class="lp ir"><em class="mo"/></strong>给定一个地址，返回该地址的令牌余额。</p><p id="2466" class="pw-post-body-paragraph ln lo iq lp b lq mj jr ls lt mk ju lv lw ml ly lz ma mm mc md me mn mg mh mi ij bi translated"><code class="fe mq mr ms mt b">transfer</code> : <strong class="lp ir"> <em class="mo"> </em> </strong>给定一个地址和金额，将该金额的代币从执行转账的地址的余额中转账到该地址。</p><p id="d0cb" class="pw-post-body-paragraph ln lo iq lp b lq mj jr ls lt mk ju lv lw ml ly lz ma mm mc md me mn mg mh mi ij bi translated"><code class="fe mq mr ms mt b">transferFrom</code> : <strong class="lp ir"> <em class="mo"> </em> </strong>给定汇款人、收款人、金额将代币从一个账户转账到另一个账户。与approve结合使用。</p><p id="3649" class="pw-post-body-paragraph ln lo iq lp b lq mj jr ls lt mk ju lv lw ml ly lz ma mm mc md me mn mg mh mi ij bi translated"><code class="fe mq mr ms mt b">approve</code> : <strong class="lp ir"> <em class="mo"> </em> </strong>给定收款人地址和金额，授权该地址从发出批准的账户执行不超过该金额的多次转账。</p><p id="a270" class="pw-post-body-paragraph ln lo iq lp b lq mj jr ls lt mk ju lv lw ml ly lz ma mm mc md me mn mg mh mi ij bi translated"><code class="fe mq mr ms mt b">allowance</code> : <strong class="lp ir"> <em class="mo"> </em> </strong>给定一个拥有者地址和一个支出者地址，返回支出者被批准从拥有者处提取的剩余金额。</p><p id="1c21" class="pw-post-body-paragraph ln lo iq lp b lq mj jr ls lt mk ju lv lw ml ly lz ma mm mc md me mn mg mh mi ij bi translated">转账:<strong class="lp ir"> <em class="mo"> </em> </strong>事件——转账成功时触发(调用to transfer或transferFrom)(即使是零值转账)。</p><p id="7003" class="pw-post-body-paragraph ln lo iq lp b lq mj jr ls lt mk ju lv lw ml ly lz ma mm mc md me mn mg mh mi ij bi translated">审批:<strong class="lp ir"> <em class="mo"> </em> </strong>成功调用审批时记录的事件。</p><h1 id="c383" class="kv kw iq bd kx ky kz la lb lc ld le lf jw lg jx lh jz li ka lj kc lk kd ll lm bi translated">ERC20可选功能</h1><p id="037b" class="pw-post-body-paragraph ln lo iq lp b lq lr jr ls lt lu ju lv lw lx ly lz ma mb mc md me mf mg mh mi ij bi translated"><code class="fe mq mr ms mt b">name</code> : <strong class="lp ir"> <em class="mo"> </em> </strong>返回令牌的可读名称(如“美元”)。</p><p id="354c" class="pw-post-body-paragraph ln lo iq lp b lq mj jr ls lt mk ju lv lw ml ly lz ma mm mc md me mn mg mh mi ij bi translated"><code class="fe mq mr ms mt b">symbol</code> : <strong class="lp ir"> <em class="mo"> </em> </strong>返回令牌的可读符号(如“USD”)。</p><p id="edf2" class="pw-post-body-paragraph ln lo iq lp b lq mj jr ls lt mk ju lv lw ml ly lz ma mm mc md me mn mg mh mi ij bi translated"><code class="fe mq mr ms mt b">decimals</code> : <strong class="lp ir"> <em class="mo"> </em> </strong>返回用于划分代币金额的小数位数。例如，如果decimals是2，那么令牌数量除以100就得到它的用户表示。</p><p id="a283" class="pw-post-body-paragraph ln lo iq lp b lq mj jr ls lt mk ju lv lw ml ly lz ma mm mc md me mn mg mh mi ij bi translated">Solidity中定义的ERC20接口</p><p id="578f" class="pw-post-body-paragraph ln lo iq lp b lq mj jr ls lt mk ju lv lw ml ly lz ma mm mc md me mn mg mh mi ij bi translated">下面是ERC20接口规范在Solidity中的样子:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mu mv l"/></div></figure><h1 id="a1e3" class="kv kw iq bd kx ky kz la lb lc ld le lf jw lg jx lh jz li ka lj kc lk kd ll lm bi translated">ERC20数据结构</h1><p id="b4c6" class="pw-post-body-paragraph ln lo iq lp b lq lr jr ls lt lu ju lv lw lx ly lz ma mb mc md me mf mg mh mi ij bi translated">如果您检查任何ERC20实现，您将看到它包含两个数据结构，一个用于跟踪余额，另一个用于跟踪津贴。实际上，它们是通过<em class="mo">数据映射</em>实现的。</p><p id="bda6" class="pw-post-body-paragraph ln lo iq lp b lq mj jr ls lt mk ju lv lw ml ly lz ma mm mc md me mn mg mh mi ij bi translated">第一个数据映射允许令牌契约跟踪谁拥有令牌。每次转帐都是从一个余额中扣除，并增加到另一个余额中:</p><pre class="kg kh ki kj gt mw mt mx my aw mz bi"><span id="e795" class="na kw iq mt b gy nb nc l nd ne">mapping(address =&gt; uint256) balances;</span></pre><p id="2b9d" class="pw-post-body-paragraph ln lo iq lp b lq mj jr ls lt mk ju lv lw ml ly lz ma mm mc md me mn mg mh mi ij bi translated">第二数据结构是津贴的数据映射。正如我们将在下一节中看到的，使用ERC20代币，代币的所有者可以将权力委托给支出者，允许他们从所有者的余额中支出特定的金额(津贴)。</p><p id="654e" class="pw-post-body-paragraph ln lo iq lp b lq mj jr ls lt mk ju lv lw ml ly lz ma mm mc md me mn mg mh mi ij bi translated">ERC20契约通过二维映射跟踪津贴，主键是代币所有者的地址，映射到支出者地址和津贴金额:</p><pre class="kg kh ki kj gt mw mt mx my aw mz bi"><span id="4e55" class="na kw iq mt b gy nb nc l nd ne">mapping (address =&gt; mapping (address =&gt; uint256)) public allowed;</span></pre><h1 id="eb12" class="kv kw iq bd kx ky kz la lb lc ld le lf jw lg jx lh jz li ka lj kc lk kd ll lm bi translated">ERC20工作流程:“转移”和“批准和转移自”</h1><p id="5100" class="pw-post-body-paragraph ln lo iq lp b lq lr jr ls lt lu ju lv lw lx ly lz ma mb mc md me mf mg mh mi ij bi translated">ERC20令牌标准有两个传递函数。你可能想知道为什么。</p><p id="62f5" class="pw-post-body-paragraph ln lo iq lp b lq mj jr ls lt mk ju lv lw ml ly lz ma mm mc md me mn mg mh mi ij bi translated">ERC20允许两种不同的工作流程。第一种是使用转移函数的单一事务、简单的工作流。钱包使用此工作流向其他钱包发送令牌。</p><p id="a4b3" class="pw-post-body-paragraph ln lo iq lp b lq mj jr ls lt mk ju lv lw ml ly lz ma mm mc md me mn mg mh mi ij bi translated">执行转让合同非常简单。如果Alice想要发送10个令牌给Bob，她的钱包发送一个交易到令牌契约的地址，调用<code class="fe mq mr ms mt b"><em class="mo">transfer</em></code>函数，以Bob的地址和10作为参数。令牌契约调整Alice的余额(–10)和Bob的余额(+10)，并发出一个转移事件。</p><p id="6fb0" class="pw-post-body-paragraph ln lo iq lp b lq mj jr ls lt mk ju lv lw ml ly lz ma mm mc md me mn mg mh mi ij bi translated">第二个工作流是一个双事务工作流，使用approve后跟<code class="fe mq mr ms mt b">transferFrom</code>。此工作流允许令牌所有者将其控制权委托给另一个地址。它最常用于将控制权委托给令牌分发合同，但也可用于交易所。</p><p id="044f" class="pw-post-body-paragraph ln lo iq lp b lq mj jr ls lt mk ju lv lw ml ly lz ma mm mc md me mn mg mh mi ij bi translated">例如，如果一家公司正在为ICO销售令牌，他们可以批准一个众筹合同地址来分发一定数量的令牌。然后，众卖合同可以将代币合同所有者的余额<code class="fe mq mr ms mt b">transferFrom</code>给代币的每个购买者，如图所示。</p><blockquote class="nf ng nh"><p id="c560" class="ln lo mo lp b lq mj jr ls lt mk ju lv ni ml ly lz nj mm mc md nk mn mg mh mi ij bi translated"><strong class="lp ir">注:</strong>An<em class="iq">Initial Coin Offering</em>(ICO)是公司和组织用来通过出售代币筹集资金的众筹机制。该术语源于首次公开发行(IPO)，即上市公司在证券交易所向投资者出售股票的过程。与高度监管的IPO市场不同，ico是开放的、全球化的、混乱的。本书中关于ico的例子和解释并不是对这种筹款方式的认可。</p></blockquote><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nl"><img src="../Images/37d3e1f3d0d2784ef37660862c4edeaf.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*eLTjPYZzUpalJTbsVDyZZw.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">ERC20工作流程</p></figure><h1 id="831c" class="kv kw iq bd kx ky kz la lb lc ld le lf jw lg jx lh jz li ka lj kc lk kd ll lm bi translated">ERC20实施</h1><p id="c052" class="pw-post-body-paragraph ln lo iq lp b lq lr jr ls lt lu ju lv lw lx ly lz ma mb mc md me mf mg mh mi ij bi translated">虽然可以用大约30行Solidity代码实现一个ERC20兼容的令牌，但大多数实现要复杂得多。这是为了说明潜在的安全漏洞。EIP-20标准中提到了两种实现方式:</p><p id="8912" class="pw-post-body-paragraph ln lo iq lp b lq mj jr ls lt mk ju lv lw ml ly lz ma mm mc md me mn mg mh mi ij bi translated"><a class="ae mp" href="https://github.com/ConsenSys/Tokens/blob/master/contracts/eip20/EIP20.sol" rel="noopener ugc nofollow" target="_blank"><strong class="lp ir">Consensys EIP 20</strong></a><strong class="lp ir">—</strong>ERC 20兼容令牌的简单易读的实现。</p><p id="4b67" class="pw-post-body-paragraph ln lo iq lp b lq mj jr ls lt mk ju lv lw ml ly lz ma mm mc md me mn mg mh mi ij bi translated"><a class="ae mp" href="https://github.com/OpenZeppelin/openzeppelin-contracts/blob/v1.12.0/contracts/token/ERC20/StandardToken.sol" rel="noopener ugc nofollow" target="_blank"><strong class="lp ir">OpenZeppelin standard token</strong></a><strong class="lp ir">—</strong>该实现与ERC20兼容，并具有额外的安全防范措施。它构成了OpenZeppelin库实现更复杂的ERC20兼容令牌的基础，这些令牌具有筹款上限、拍卖、授权时间表和其他功能。</p><h1 id="51ff" class="kv kw iq bd kx ky kz la lb lc ld le lf jw lg jx lh jz li ka lj kc lk kd ll lm bi translated">🚀推出我们自己的ERC20令牌</h1><p id="3dca" class="pw-post-body-paragraph ln lo iq lp b lq lr jr ls lt lu ju lv lw lx ly lz ma mb mc md me mf mg mh mi ij bi translated">让我们创建并发布我们自己的令牌。对于这个例子，我们将使用Truffle框架。该示例假设您已经安装了truffle，如果没有使用npm安装它。</p><pre class="kg kh ki kj gt mw mt mx my aw mz bi"><span id="924f" class="na kw iq mt b gy nb nc l nd ne">npm i truffle</span></pre><p id="e8fb" class="pw-post-body-paragraph ln lo iq lp b lq mj jr ls lt mk ju lv lw ml ly lz ma mm mc md me mn mg mh mi ij bi translated">我们将称我们的令牌为“掌握以太坊令牌”，符号为“MET”</p><blockquote class="nf ng nh"><p id="90f3" class="ln lo mo lp b lq mj jr ls lt mk ju lv ni ml ly lz nj mm mc md nk mn mg mh mi ij bi translated"><strong class="lp ir">注</strong>:你可以在本书的GitHub资源库中找到这个例子<a class="ae mp" href="https://github.com/ac12644/METoken.git" rel="noopener ugc nofollow" target="_blank">。</a></p></blockquote><p id="d762" class="pw-post-body-paragraph ln lo iq lp b lq mj jr ls lt mk ju lv lw ml ly lz ma mm mc md me mn mg mh mi ij bi translated">首先，让我们创建并初始化一个Truffle项目目录。运行这四个命令，并接受任何问题的默认答案:</p><pre class="kg kh ki kj gt mw mt mx my aw mz bi"><span id="53f5" class="na kw iq mt b gy nb nc l nd ne">$ mkdir METoken<br/>$ cd METoken<br/>METoken $ truffle init<br/>METoken $ npm init</span></pre><p id="391b" class="pw-post-body-paragraph ln lo iq lp b lq mj jr ls lt mk ju lv lw ml ly lz ma mm mc md me mn mg mh mi ij bi translated">现在，您应该拥有以下目录结构:</p><pre class="kg kh ki kj gt mw mt mx my aw mz bi"><span id="d81d" class="na kw iq mt b gy nb nc l nd ne">METoken/<br/>+---- contracts<br/>|   `---- Migrations.sol<br/>+---- migrations<br/>|   `---- 1_initial_migration.js<br/>+---- package.json<br/>+---- test<br/>`---- truffle-config.js</span></pre><p id="bb76" class="pw-post-body-paragraph ln lo iq lp b lq mj jr ls lt mk ju lv lw ml ly lz ma mm mc md me mn mg mh mi ij bi translated">编辑<code class="fe mq mr ms mt b">truffle-config.js</code>配置文件来设置您的Truffle环境，或者从<a class="ae mp" href="https://github.com/ac12644/METoken/blob/main/truffle-config.js" rel="noopener ugc nofollow" target="_blank">库</a>中复制后者。</p><p id="503e" class="pw-post-body-paragraph ln lo iq lp b lq mj jr ls lt mk ju lv lw ml ly lz ma mm mc md me mn mg mh mi ij bi translated">如果使用示例<code class="fe mq mr ms mt b">truffle-config.js</code>，记得创建一个文件<em class="mo">。在<code class="fe mq mr ms mt b">METoken</code>文件夹中的env </em>包含您的测试私钥，用于在公共以太坊测试网络上进行测试和部署，比如Ropsten或Kovan。您可以从MetaMask导出您的测试网络私钥。</p><p id="c8ec" class="pw-post-body-paragraph ln lo iq lp b lq mj jr ls lt mk ju lv lw ml ly lz ma mm mc md me mn mg mh mi ij bi translated">之后，您的目录应该如下所示:</p><pre class="kg kh ki kj gt mw mt mx my aw mz bi"><span id="0fac" class="na kw iq mt b gy nb nc l nd ne">METoken/<br/>+---- contracts<br/>|   `---- Migrations.sol<br/>+---- migrations<br/>|   `---- 1_initial_migration.js<br/>+---- package.json<br/>+---- test<br/>+---- truffle-config.js<br/>`---- .env *new file*</span></pre><h2 id="d2ae" class="na kw iq bd kx nm nn dn lb no np dp lf lw nq nr lh ma ns nt lj me nu nv ll nw bi translated">⚠️ <strong class="ak">警告</strong></h2><p id="a128" class="pw-post-body-paragraph ln lo iq lp b lq lr jr ls lt lu ju lv lw lx ly lz ma mb mc md me mf mg mh mi ij bi translated">仅使用<em class="mo">而非</em>用于在主以太网上保存资金的测试密钥或测试助记符。<em class="mo">千万不要</em>使用装有真钱的钥匙进行测试。</p><p id="e0f4" class="pw-post-body-paragraph ln lo iq lp b lq mj jr ls lt mk ju lv lw ml ly lz ma mm mc md me mn mg mh mi ij bi translated">对于我们的示例，我们将导入OpenZeppelin库，它实现了一些重要的安全检查，并且易于扩展:</p><pre class="kg kh ki kj gt mw mt mx my aw mz bi"><span id="d623" class="na kw iq mt b gy nb nc l nd ne">$ npm install openzeppelin-solidity@1.12.0</span><span id="d28f" class="na kw iq mt b gy nx nc l nd ne">+ openzeppelin-solidity@1.12.0<br/>added 1 package from 1 contributor and audited 2381 packages in 4.074s</span></pre><p id="152a" class="pw-post-body-paragraph ln lo iq lp b lq mj jr ls lt mk ju lv lw ml ly lz ma mm mc md me mn mg mh mi ij bi translated"><code class="fe mq mr ms mt b">openzeppelin-solidity</code>包将在<code class="fe mq mr ms mt b">node_modules</code>目录下添加大约250个文件。OpenZeppelin库包含的远不止ERC20令牌，但我们将只使用其中的一小部分。</p><p id="0a69" class="pw-post-body-paragraph ln lo iq lp b lq mj jr ls lt mk ju lv lw ml ly lz ma mm mc md me mn mg mh mi ij bi translated">接下来，让我们编写我们的令牌契约。创建一个新文件<em class="mo"> METoken.sol </em>，并从<a class="ae mp" href="https://github.com/ac12644/METoken/blob/main/contracts/METoken.sol" rel="noopener ugc nofollow" target="_blank"> GitHub </a>中复制示例代码。</p><p id="4d1c" class="pw-post-body-paragraph ln lo iq lp b lq mj jr ls lt mk ju lv lw ml ly lz ma mm mc md me mn mg mh mi ij bi translated">我们的契约，如<code class="fe mq mr ms mt b"><a class="ae mp" href="https://github.com/ac12644/METoken/blob/main/contracts/METoken.sol" rel="noopener ugc nofollow" target="_blank">METoken.sol</a></code> <a class="ae mp" href="https://github.com/ac12644/METoken/blob/main/contracts/METoken.sol" rel="noopener ugc nofollow" target="_blank">所示:一个实现ERC20令牌</a>的Solidity契约，非常简单，因为它继承了OpenZeppelin库的所有功能。</p><p id="5e4b" class="pw-post-body-paragraph ln lo iq lp b lq mj jr ls lt mk ju lv lw ml ly lz ma mm mc md me mn mg mh mi ij bi translated"><strong class="lp ir">例一</strong>。<code class="fe mq mr ms mt b">METoken.sol</code>:实现ERC20令牌的可靠性合同</p><p id="8572" class="pw-post-body-paragraph ln lo iq lp b lq mj jr ls lt mk ju lv lw ml ly lz ma mm mc md me mn mg mh mi ij bi translated">这里，我们定义可选变量名称、符号和小数。我们还定义了一个<code class="fe mq mr ms mt b">_initial_supply</code>变量，设置为2100万令牌；两位小数的细分给出了21亿个单位。在契约的初始化(构造函数)函数中，我们将<code class="fe mq mr ms mt b">totalSupply</code>设置为等于<code class="fe mq mr ms mt b">_initial_supply</code>，并将所有的<code class="fe mq mr ms mt b">_initial_supply</code>分配给创建<code class="fe mq mr ms mt b">METoken</code>契约的账户(<code class="fe mq mr ms mt b">msg.sender</code>)的余额。</p><p id="ddb2" class="pw-post-body-paragraph ln lo iq lp b lq mj jr ls lt mk ju lv lw ml ly lz ma mm mc md me mn mg mh mi ij bi translated">我们现在使用truffle来编译METoken代码:</p><pre class="kg kh ki kj gt mw mt mx my aw mz bi"><span id="aa76" class="na kw iq mt b gy nb nc l nd ne">$ truffle compile<br/>Compiling ./contracts/METoken.sol...<br/>Compiling ./contracts/Migrations.sol...<br/>Compiling openzeppelin-solidity/contracts/math/SafeMath.sol...<br/>Compiling openzeppelin-solidity/contracts/token/ERC20/BasicToken.sol...<br/>Compiling openzeppelin-solidity/contracts/token/ERC20/ERC20.sol...<br/>Compiling openzeppelin-solidity/contracts/token/ERC20/ERC20Basic.sol...<br/>Compiling openzeppelin-solidity/contracts/token/ERC20/StandardToken.sol...</span></pre><p id="bfab" class="pw-post-body-paragraph ln lo iq lp b lq mj jr ls lt mk ju lv lw ml ly lz ma mm mc md me mn mg mh mi ij bi translated">如您所见，truffle包含了来自OpenZeppelin库的必要依赖项，并且也编译了这些契约。</p><p id="3060" class="pw-post-body-paragraph ln lo iq lp b lq mj jr ls lt mk ju lv lw ml ly lz ma mm mc md me mn mg mh mi ij bi translated">让我们设置一个迁移脚本来部署<code class="fe mq mr ms mt b">METoken</code>契约。在<code class="fe mq mr ms mt b">METoken/migrations</code>文件夹中创建一个名为<code class="fe mq mr ms mt b">2_deploy_contracts.js</code>的新文件。将示例<a class="ae mp" href="https://github.com/ac12644/METoken/blob/main/migrations/2_deploy_contracts.js" rel="noopener ugc nofollow" target="_blank">中的内容复制到GitHub库</a>中:</p><p id="4ac8" class="pw-post-body-paragraph ln lo iq lp b lq mj jr ls lt mk ju lv lw ml ly lz ma mm mc md me mn mg mh mi ij bi translated">在我们部署以太坊测试网络之前，让我们启动一个本地区块链来测试一切。使用<code class="fe mq mr ms mt b">ganache-cli</code>从命令行或图形用户界面启动ganache区块链。</p><p id="5a60" class="pw-post-body-paragraph ln lo iq lp b lq mj jr ls lt mk ju lv lw ml ly lz ma mm mc md me mn mg mh mi ij bi translated">一旦ganache启动，我们就可以部署我们的METoken合同，并查看一切是否按预期运行:</p><pre class="kg kh ki kj gt mw mt mx my aw mz bi"><span id="4d92" class="na kw iq mt b gy nb nc l nd ne">$ truffle migrate --network ganache<br/>Using network 'ganache'.</span><span id="9e77" class="na kw iq mt b gy nx nc l nd ne">Running migration: 1_initial_migration.js<br/>  Deploying Migrations...<br/>  ... 0xb2e90a056dc6ad8e654683921fc613c796a03b89df6760ec1db1084ea4a084eb<br/>  Migrations: 0x8cdaf0cd259887258bc13a92c0a6da92698644c0<br/>Saving successful migration to network...<br/>  ... 0xd7bc86d31bee32fa3988f1c1eabce403a1b5d570340a3a9cdba53a472ee8c956<br/>Saving artifacts...<br/>Running migration: 2_deploy_contracts.js<br/>  Deploying METoken...<br/>  ... 0xbe9290d59678b412e60ed6aefedb17364f4ad2977cfb2076b9b8ad415c5dc9f0<br/>  METoken: 0x345ca3e014aaf5dca488057592ee47305d9b3e10<br/>Saving successful migration to network...<br/>  ... 0xf36163615f41ef7ed8f4a8f192149a0bf633fe1a2398ce001bf44c43dc7bdda0<br/>Saving artifacts...</span></pre><p id="585a" class="pw-post-body-paragraph ln lo iq lp b lq mj jr ls lt mk ju lv lw ml ly lz ma mm mc md me mn mg mh mi ij bi translated">在ganache控制台上，我们应该看到我们的部署已经创建了四个新事务。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi ny"><img src="../Images/0663512b342a0642ec07ec5c3c94c4a4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*HMf2Ba_xvS8Oj1fkQ1wp3g.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">掼奶油</p></figure><h2 id="ff2b" class="na kw iq bd kx nm nn dn lb no np dp lf lw nq nr lh ma ns nt lj me nu nv ll nw bi translated">🖥️使用松露控制台与梅托肯互动</h2><p id="9865" class="pw-post-body-paragraph ln lo iq lp b lq lr jr ls lt lu ju lv lw lx ly lz ma mb mc md me mf mg mh mi ij bi translated">我们可以使用松露控制台与加纳切区块链上的合同进行交互。这是一个交互式JavaScript环境，提供对Truffle环境的访问，并通过web3访问区块链。在这种情况下，我们将松露控制台连接到ganache区块链:</p><pre class="kg kh ki kj gt mw mt mx my aw mz bi"><span id="4297" class="na kw iq mt b gy nb nc l nd ne">$ truffle console --network ganache<br/>truffle(ganache)&gt;</span></pre><p id="ac77" class="pw-post-body-paragraph ln lo iq lp b lq mj jr ls lt mk ju lv lw ml ly lz ma mm mc md me mn mg mh mi ij bi translated">truffle(ganache)&gt;提示符显示我们已连接到ganache区块链，并准备好键入我们的命令。truffle控制台支持所有的Truffle命令，所以我们可以从控制台编译和迁移。</p><p id="b57c" class="pw-post-body-paragraph ln lo iq lp b lq mj jr ls lt mk ju lv lw ml ly lz ma mm mc md me mn mg mh mi ij bi translated">我们已经运行了这些命令，所以让我们直接进入契约本身。<code class="fe mq mr ms mt b">METoken</code>契约作为一个JavaScript对象存在于Truffle环境中。在提示符下键入**METoken**，它将转储整个合同定义:</p><pre class="kg kh ki kj gt mw mt mx my aw mz bi"><span id="a5ee" class="na kw iq mt b gy nb nc l nd ne">truffle(ganache)&gt; METoken<br/>{ [Function: TruffleContract]<br/>  _static_methods:</span><span id="cdfe" class="na kw iq mt b gy nx nc l nd ne">[...]</span><span id="0660" class="na kw iq mt b gy nx nc l nd ne">currentProvider:<br/> HttpProvider {<br/>   host: 'http://localhost:7545',<br/>   timeout: 0,<br/>   user: undefined,<br/>   password: undefined,<br/>   headers: undefined,<br/>   send: [Function],<br/>   sendAsync: [Function],<br/>   _alreadyWrapped: true },<br/>network_id: '5777' }</span></pre><p id="9b2b" class="pw-post-body-paragraph ln lo iq lp b lq mj jr ls lt mk ju lv lw ml ly lz ma mm mc md me mn mg mh mi ij bi translated"><code class="fe mq mr ms mt b">METoken</code>对象还公开了几个属性，比如契约的地址(由migrate命令部署):</p><pre class="kg kh ki kj gt mw mt mx my aw mz bi"><span id="b19b" class="na kw iq mt b gy nb nc l nd ne">truffle(ganache)&gt; METoken.address<br/>'0x345ca3e014aaf5dca488057592ee47305d9b3e10'</span></pre><p id="0d8e" class="pw-post-body-paragraph ln lo iq lp b lq mj jr ls lt mk ju lv lw ml ly lz ma mm mc md me mn mg mh mi ij bi translated">如果我们想要与部署的契约进行交互，我们必须使用一个异步调用，以JavaScript“promise”的形式。我们使用已部署的函数来获取契约实例，然后调用<code class="fe mq mr ms mt b">totalSupply</code>函数:</p><pre class="kg kh ki kj gt mw mt mx my aw mz bi"><span id="728d" class="na kw iq mt b gy nb nc l nd ne">truffle(ganache)&gt; METoken.deployed().then(instance =&gt; instance.totalSupply())<br/>BigNumber { s: 1, e: 9, c: [ 2100000000 ] }</span></pre><p id="3ea1" class="pw-post-body-paragraph ln lo iq lp b lq mj jr ls lt mk ju lv lw ml ly lz ma mm mc md me mn mg mh mi ij bi translated">接下来，让我们使用ganache创建的帐户来检查我们的METoken余额，并将一些METoken发送到另一个地址。首先，让我们获得客户地址:</p><pre class="kg kh ki kj gt mw mt mx my aw mz bi"><span id="20d9" class="na kw iq mt b gy nb nc l nd ne">truffle(ganache)&gt; let accounts<br/>undefined<br/>truffle(ganache)&gt; web3.eth.getAccounts((err,res) =&gt; { accounts = res })<br/>undefined<br/>truffle(ganache)&gt; accounts[0]<br/>'0x627306090abab3a6e1400e9345bc60c78a8bef57'</span></pre><p id="1756" class="pw-post-body-paragraph ln lo iq lp b lq mj jr ls lt mk ju lv lw ml ly lz ma mm mc md me mn mg mh mi ij bi translated">帐户列表现在包含了由加纳切创建的所有帐户，而<code class="fe mq mr ms mt b">accounts[0]</code>是部署了<code class="fe mq mr ms mt b">METoken</code>合同的帐户。它应该有一个余额<code class="fe mq mr ms mt b">METoken</code>，因为我们的METoken构造函数将整个令牌提供给创建它的地址。让我们检查一下:</p><pre class="kg kh ki kj gt mw mt mx my aw mz bi"><span id="9e6e" class="na kw iq mt b gy nb nc l nd ne">truffle(ganache)&gt; METoken.deployed().then(instance =&gt;<br/>                  { instance.balanceOf(accounts[0]).then(console.log) })<br/>undefined<br/>truffle(ganache)&gt; BigNumber { s: 1, e: 9, c: [ 2100000000 ] }</span></pre><p id="a719" class="pw-post-body-paragraph ln lo iq lp b lq mj jr ls lt mk ju lv lw ml ly lz ma mm mc md me mn mg mh mi ij bi translated">最后，让我们通过调用合同的转移函数将1000.00 METoken从<code class="fe mq mr ms mt b">accounts[0]</code>转移到<code class="fe mq mr ms mt b">accounts[1]</code>:</p><pre class="kg kh ki kj gt mw mt mx my aw mz bi"><span id="f033" class="na kw iq mt b gy nb nc l nd ne">truffle(ganache)&gt; METoken.deployed().then(instance =&gt;<br/>                  { instance.transfer(accounts[1], 100000) })<br/>undefined<br/>truffle(ganache)&gt; METoken.deployed().then(instance =&gt;<br/>                  { instance.balanceOf(accounts[0]).then(console.log) })<br/>undefined<br/>truffle(ganache)&gt; BigNumber { s: 1, e: 9, c: [ 2099900000 ] }<br/>undefined<br/>truffle(ganache)&gt; METoken.deployed().then(instance =&gt;<br/>                  { instance.balanceOf(accounts[1]).then(console.log) })<br/>undefined<br/>truffle(ganache)&gt; BigNumber { s: 1, e: 5, c: [ 100000 ] }</span></pre><blockquote class="nf ng nh"><p id="7e91" class="ln lo mo lp b lq mj jr ls lt mk ju lv ni ml ly lz nj mm mc md nk mn mg mh mi ij bi translated"><strong class="lp ir">提示</strong> : METoken的精度有2位小数，表示1 METoken在合同中是100个单位。当我们传输1，000 METoken时，我们在对传输函数的调用中将该值指定为100000。</p></blockquote><p id="0310" class="pw-post-body-paragraph ln lo iq lp b lq mj jr ls lt mk ju lv lw ml ly lz ma mm mc md me mn mg mh mi ij bi translated">如你所见，在控制台中，帐户[0]现在有20，999，000 MET，<code class="fe mq mr ms mt b">accounts[1]</code>有1，000 MET。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi ny"><img src="../Images/8eaa63ff6372f52fe6bae3c4aa3e0ca0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*z7tDVitXZ_XTytKu3bBU8Q.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">掼奶油</p></figure><h1 id="1b5d" class="kv kw iq bd kx ky kz la lb lc ld le lf jw lg jx lh jz li ka lj kc lk kd ll lm bi translated">✉️向合同地址发送ERC20令牌</h1><p id="257b" class="pw-post-body-paragraph ln lo iq lp b lq lr jr ls lt lu ju lv lw lx ly lz ma mb mc md me mf mg mh mi ij bi translated">到目前为止，我们已经设置了一个ERC20令牌，并将一些令牌从一个帐户转移到另一个帐户。我们在这些演示中使用的所有帐户都是外部拥有的帐户，这意味着它们由私钥控制，而不是由合同控制。如果我们将MET发送到合同地址会发生什么？让我们来了解一下！</p><p id="f03f" class="pw-post-body-paragraph ln lo iq lp b lq mj jr ls lt mk ju lv lw ml ly lz ma mm mc md me mn mg mh mi ij bi translated">首先，让我们在测试环境中部署另一个契约。对于这个例子，我们将使用我们的第一个合同，<code class="fe mq mr ms mt b">Faucet.sol</code>。让我们通过将它复制到<code class="fe mq mr ms mt b">contracts</code>目录来将其添加到METoken项目中。我们的目录应该如下所示:</p><pre class="kg kh ki kj gt mw mt mx my aw mz bi"><span id="8a9c" class="na kw iq mt b gy nb nc l nd ne">METoken/<br/>+---- contracts<br/>|   +---- Faucet.sol<br/>|   +---- METoken.sol<br/>|   `---- Migrations.sol</span></pre><p id="9c4c" class="pw-post-body-paragraph ln lo iq lp b lq mj jr ls lt mk ju lv lw ml ly lz ma mm mc md me mn mg mh mi ij bi translated">我们还将添加一个迁移，以便与METoken分开部署水龙头:</p><pre class="kg kh ki kj gt mw mt mx my aw mz bi"><span id="15f8" class="na kw iq mt b gy nb nc l nd ne">var Faucet = artifacts.require("Faucet");</span><span id="f4c1" class="na kw iq mt b gy nx nc l nd ne">module.exports = function(deployer) {<br/>  // Deploy the Faucet contract as our only task<br/>  deployer.deploy(Faucet);<br/>};</span></pre><p id="3cfe" class="pw-post-body-paragraph ln lo iq lp b lq mj jr ls lt mk ju lv lw ml ly lz ma mm mc md me mn mg mh mi ij bi translated">让我们从Truffle控制台编译和迁移合同:</p><pre class="kg kh ki kj gt mw mt mx my aw mz bi"><span id="1270" class="na kw iq mt b gy nb nc l nd ne">$ truffle console --network ganache<br/>truffle(ganache)&gt; compile<br/>Compiling ./contracts/Faucet.sol...<br/>Writing artifacts to ./build/contracts</span><span id="b12e" class="na kw iq mt b gy nx nc l nd ne">truffle(ganache)&gt; migrate<br/>Using network 'ganache'.</span><span id="0b07" class="na kw iq mt b gy nx nc l nd ne">Running migration: 1_initial_migration.js<br/>  Deploying Migrations...<br/>  ... 0x89f6a7bd2a596829c60a483ec99665c7af71e68c77a417fab503c394fcd7a0c9<br/>  Migrations: 0xa1ccce36fb823810e729dce293b75f40fb6ea9c9<br/>Saving artifacts...<br/>Running migration: 2_deploy_contracts.js<br/>  Replacing METoken...<br/>  ... 0x28d0da26f48765f67e133e99dd275fac6a25fdfec6594060fd1a0e09a99b44ba<br/>  METoken: 0x7d6bf9d5914d37bcba9d46df7107e71c59f3791f<br/>Saving artifacts...<br/>Running migration: 3_deploy_faucet.js<br/>  Deploying Faucet...<br/>  ... 0x6fbf283bcc97d7c52d92fd91f6ac02d565f5fded483a6a0f824f66edc6fa90c3<br/>  Faucet: 0xb18a42e9468f7f1342fa3c329ec339f254bc7524<br/>Saving artifacts...</span></pre><p id="d2e9" class="pw-post-body-paragraph ln lo iq lp b lq mj jr ls lt mk ju lv lw ml ly lz ma mm mc md me mn mg mh mi ij bi translated">太好了。现在让我们把一些遇见的合同送到水龙头:</p><pre class="kg kh ki kj gt mw mt mx my aw mz bi"><span id="ae75" class="na kw iq mt b gy nb nc l nd ne">truffle(ganache)&gt; METoken.deployed().then(instance =&gt;<br/>                  { instance.transfer(Faucet.address, 100000) })<br/>truffle(ganache)&gt; METoken.deployed().then(instance =&gt;<br/>                  { instance.balanceOf(Faucet.address).then(console.log)})<br/>truffle(ganache)&gt; BigNumber { s: 1, e: 5, c: [ 100000 ] }</span></pre><p id="35ce" class="pw-post-body-paragraph ln lo iq lp b lq mj jr ls lt mk ju lv lw ml ly lz ma mm mc md me mn mg mh mi ij bi translated">好的，我们已经把1000公吨转到水龙头合同上了。现在，我们如何收回那些代币？</p><p id="ff4b" class="pw-post-body-paragraph ln lo iq lp b lq mj jr ls lt mk ju lv lw ml ly lz ma mm mc md me mn mg mh mi ij bi translated">记住，<code class="fe mq mr ms mt b">Faucet.sol</code>是一个相当简单的契约。它只有一个功能，<code class="fe mq mr ms mt b">withdraw</code>就是吸乙醚。它没有提取MET或任何其他ERC20令牌的功能。如果我们使用<code class="fe mq mr ms mt b">withdraw</code>，它将尝试发送乙醚，但由于水龙头没有平衡乙醚，它将失败。</p><p id="920d" class="pw-post-body-paragraph ln lo iq lp b lq mj jr ls lt mk ju lv lw ml ly lz ma mm mc md me mn mg mh mi ij bi translated">METoken合同知道水龙头有余额，但是它转移余额的唯一方法是从合同地址接收转移调用。我们需要让水龙头契约调用<code class="fe mq mr ms mt b">METoken</code>中的传递函数。</p><p id="ba91" class="pw-post-body-paragraph ln lo iq lp b lq mj jr ls lt mk ju lv lw ml ly lz ma mm mc md me mn mg mh mi ij bi translated">如果你不知道下一步该做什么，不要。这个问题没有解决办法。送到水龙头的水表永远卡死了。只有水龙头合约可以调用它，水龙头合约没有代码调用一个ERC20令牌合约的调用函数。</p><p id="2bc2" class="pw-post-body-paragraph ln lo iq lp b lq mj jr ls lt mk ju lv lw ml ly lz ma mm mc md me mn mg mh mi ij bi translated">也许你预料到了这个问题。很可能，你没有。事实上，数百名以太坊用户也没有，他们意外地将各种代币转移到没有任何ERC20功能的合同中。根据一些估计，价值超过大约250万美元的代币(在撰写本文时)已经像这样被“卡住”并永远丢失了。</p><p id="12c1" class="pw-post-body-paragraph ln lo iq lp b lq mj jr ls lt mk ju lv lw ml ly lz ma mm mc md me mn mg mh mi ij bi translated">ERC20令牌的用户在转账过程中可能会无意中丢失令牌，其中一个原因是他们试图转账到交易所或其他服务。他们从一个交易所的网站上复制了一个以太坊地址，认为他们可以简单地向它发送代币。但是很多交易所公布的收货地址其实是合同！这些合同只意味着接受乙醚，而不是ERC20代币，最常见的是将发送给他们的所有资金转移到“冷库”或另一个中央钱包。尽管有许多警告说“不要发送代币到这个地址”，但许多代币还是这样丢失了。</p><h1 id="f588" class="kv kw iq bd kx ky kz la lb lc ld le lf jw lg jx lh jz li ka lj kc lk kd ll lm bi translated">🚩ERC20令牌的问题</h1><p id="ba10" class="pw-post-body-paragraph ln lo iq lp b lq lr jr ls lt lu ju lv lw lx ly lz ma mb mc md me mf mg mh mi ij bi translated">ERC20令牌标准的采用确实具有爆炸性。数以千计的代币已经推出，既用于试验新功能，也用于在各种“众筹”拍卖和ico中筹集资金。然而，有一些潜在的陷阱，正如我们在将令牌转移到契约地址的问题上看到的那样。</p><p id="9094" class="pw-post-body-paragraph ln lo iq lp b lq mj jr ls lt mk ju lv lw ml ly lz ma mm mc md me mn mg mh mi ij bi translated">ERC20令牌的一个不太明显的问题是，它们暴露了令牌和以太本身之间的细微差别。当以太网由以接收者地址为目的地的交易传输时，令牌传输发生在<em class="mo">特定令牌契约状态</em>内，并且以令牌契约为目的地，而不是接收者的地址。令牌契约跟踪余额并发布事件。在令牌传输中，实际上没有事务被发送给令牌的接收者。取而代之的是，接收者的地址被添加到令牌契约本身内的地图中。向地址发送以太网的事务改变了地址的状态。将令牌传输到某个地址的事务仅会更改令牌协定的状态，而不会更改接收方地址的状态。即使支持ERC20令牌的钱包也不会知道令牌余额，除非用户明确地将特定的令牌合约添加到“watch”一些钱包观察最受欢迎的令牌合同，以检测他们控制的地址持有的余额，但这仅限于现有ERC20合同的一小部分。</p><p id="75c2" class="pw-post-body-paragraph ln lo iq lp b lq mj jr ls lt mk ju lv lw ml ly lz ma mm mc md me mn mg mh mi ij bi translated">事实上，用户不太可能<em class="mo">希望</em>跟踪所有可能的ERC20代币合约中的所有余额。许多ERC20令牌更像垃圾邮件，而不是可用的令牌。为了吸引用户，他们会自动为有交易活动的账户创建余额。如果你有一个活动历史很长的以太坊地址，特别是如果它是在预售中创建的，你会发现它充满了不知从哪里冒出来的“垃圾”令牌。当然，这个地址并不是真的充满了令牌；代币合同上有你的地址。只有当您用来查看地址的block explorer或wallet正在监视这些令牌合同时，您才能看到这些余额。</p><p id="0cd9" class="pw-post-body-paragraph ln lo iq lp b lq mj jr ls lt mk ju lv lw ml ly lz ma mm mc md me mn mg mh mi ij bi translated">令牌的行为方式与以太不同。以太网由send函数发送，并由合同中的任何应付款函数或任何外部拥有的地址接受。令牌使用仅在ERC20合同中存在的<code class="fe mq mr ms mt b"><em class="mo">transfer</em></code>或<code class="fe mq mr ms mt b"><em class="mo">approve</em></code> &amp; <em class="mo"> </em> <code class="fe mq mr ms mt b"><em class="mo">transferFrom</em></code>函数发送，并且不会(至少在ERC20中)触发接收方合同中的任何应付函数。代币的功能就像以太等加密货币一样，但它们有一些不同之处，打破了这种错觉。</p><p id="42fa" class="pw-post-body-paragraph ln lo iq lp b lq mj jr ls lt mk ju lv lw ml ly lz ma mm mc md me mn mg mh mi ij bi translated">考虑另一个问题。要发送以太或使用任何以太坊合同，您需要以太支付汽油费用。要发送代币，你<em class="mo">还需要以太</em>。你不能用代币支付交易的汽油费，代币合同也不能为你支付汽油费。在遥远的将来，这种情况可能会发生变化，但与此同时，这会导致一些非常奇怪的用户体验。</p></div></div>    
</body>
</html>