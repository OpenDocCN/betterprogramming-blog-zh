<html>
<head>
<title>10 Things Every Developer Should Learn</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">每个开发人员都应该学习的10件事</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/10-things-every-developer-should-learn-72697ed5d94a?source=collection_archive---------1-----------------------#2019-08-23">https://betterprogramming.pub/10-things-every-developer-should-learn-72697ed5d94a?source=collection_archive---------1-----------------------#2019-08-23</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="c2c5" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">或者，“网上有人告诉你如何成为更好的开发人员”</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/452326cf483a2aced7a0725286caa958.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Wh-5SfUGI3hLJo-JbaGuXg.jpeg"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">约书亚·阿拉贡在Unsplash 上拍摄的照片。</p></figure><p id="0d6b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我是一名Python+ Go开发人员，在过去的几年里，我一直在操作全球规模的应用程序。我和我的团队每天接待大约200万名客户；这种规模并不容易。我想分享几个我多年来学到的小技巧。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="4afc" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated"><strong class="ak">安全永远不应该是事后的想法</strong></h1><p id="d8f5" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">应用程序安全性永远不应该是事后才想到的，或者被归为“我们将在以后添加安全性”强大的应用程序安全性要求它从第一天起就成为对话和开发管道的一部分，而不是第300天。将安全性留到最后一分钟实际上会增加您的开发时间，因为您不得不返回并重构以适应它。或者更糟，你有更少的时间来解决任何漏洞，你最终会发布易受攻击的代码。问问像T4雅虎T5这样的公司，他们是如何做到的。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="315a" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated"><strong class="ak">每个应用都是不同的，有不同的需求，根据应用需求选择，而不是政治压力或市场人气</strong></h1><p id="2660" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">这个真的不用说，但是每个应用都不一样。没有一套适用于所有应用程序的神圣规则(包括这些规则)。当启动一个新的应用程序时，应该由应用程序及其架构来决定使用什么技术或标准化什么平台。在问“我的应用程序需要什么？”这个问题之前，决定使用gRPC还是Kubernetes它只做一件事:在你写一行代码之前，它就在你的道路上设置了路障。这就是我们如何陷入可笑的境地，像<a class="ae ky" href="https://microk8s.io/" rel="noopener ugc nofollow" target="_blank"> Canonical这样的公司正在为物联网设备提供Kubernetes</a>。引用杰夫·高布伦的话，“你们的科学家太专注于他们能不能做到，而没有停下来想一想他们是否应该做到。”</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="356f" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated"><strong class="ak">你大概不需要“做微服务”</strong></h1><p id="2c72" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">微服务很性感。我明白了。能够独立扩展应用程序中的各个部分的想法是令人兴奋的，这也证明了您继续在特定代码库上工作的合理性。但是，让我们诚实地面对自己——你可能不需要“做微服务”。像“我希望能够将特性X代码从特性Y代码中分离出来”、“防止不良代码渗入应用程序的其他部分”或“如果应用程序受到损害，将爆炸半径最小化”这样的原因都不是迁移到微服务的理由；它们分别是糟糕的开发实践(呆在自己的领域，只接触必要的东西)、需要更加严格的代码审查标准(糟糕的代码不应该被合并，句号)和缺乏细粒度的安全控制的症状。</p><p id="ae5d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">您是否需要独立扩展应用程序的各个部分，并且当前一个或多个组件(如登录流)存在容量问题？然后，如果可能的话，您可能应该探索将那些需要扩展的组件分解成单独的服务。</p><p id="0fdc" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">您是否正在运行基于虚拟服务器的体系结构，并希望削减成本？那你就不要探索微服务了。充其量你会达到收支平衡。在最坏的情况下，您将最终需要启动额外的实例。比方说，你有一个包含五个服务的整体，然后你把它分成几个微服务。现在，您有五个应用程序，要么a)您为其旋转专用实例，将您的初始占用空间乘以五，要么b)您使用现有的占用空间，现在只需花费更多的运营成本来管理它。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="f1dc" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated"><strong class="ak">拥有标准化的开发环境</strong></h1><p id="8b30" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">当与多个开发人员一起工作时，您可以做的最有益的事情之一是在整个团队中标准化您的开发环境。现在，这并不意味着您必须拼凑一些基于容器的虚拟开发环境向导魔法。如果您愿意，您可以这样做，但是像使用相同语言版本这样简单的事情可以在您的团队的健全性上创造奇迹。当你的同事在Go 1.11上写代码的时候，试图在Go 1.12上诊断bug只会让你哭。协调何时升级版本可能会很困难，但是如果你做对了，事情就会顺利进行。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="5723" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">配置比看起来更难；相应地计划</h1><p id="0007" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">与<a class="ae ky" href="https://12factor.net/config" rel="noopener ugc nofollow" target="_blank">一些流行网站所说的</a>相反，配置比“将一切放入环境变量中”要复杂一些我认为配置一个应用程序至少应该有四种方式:代码内默认值、本地配置文件、命令行标志、环境变量、远程配置源(比如Hashicorp的Consul)。我认为远程配置是可选的；然而，其他四个是必要的。对于开发来说，至少可以说，仅仅依靠将27个不同的配置值放入环境变量来本地运行应用程序是令人沮丧的。此外，也许你需要更好的自动化和Makefile？提供一个本地配置源的方法，比如一个<code class="fe mz na nb nc b">application.yaml</code>，允许你设置一个默认的“开发”配置。此外，拥有代码内默认值意味着您只需要设置想要更改的默认值。当通过像<code class="fe mz na nb nc b">systemd</code>这样的init系统运行应用程序时，命令行标志非常有用，因为它使得在跟踪进程时更容易看到配置。环境变量在容器中运行时非常有用，是的，但是有些东西它们不适合，比如秘密。</p><p id="1408" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">您不应该将秘密(如密码、身份验证令牌、证书以及通常您不希望泄露给公众的任何东西)放入环境变量中，因为它们不安全，几乎可以被主机上的任何进程读取。你应该为你的秘密使用某种秘密管理器。我个人的选择是哈希公司的<a class="ae ky" href="https://www.vaultproject.io/" rel="noopener ugc nofollow" target="_blank">跳马</a>，但使用最适合你的应用程序。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="1a39" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">在你需要的时候使用软件包，不仅仅是因为你可以</h1><p id="cc70" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">我们都知道<code class="fe mz na nb nc b">left-pad</code> <a class="ae ky" href="https://www.theregister.co.uk/2016/03/23/npm_left_pad_chaos/" rel="noopener ugc nofollow" target="_blank">天启</a>对吧？一个包含11行代码的NPM软件包是如何从存储库中删除的，嗯，破坏了互联网上的一切？不要那样做。当需要导入一个包时，应该使用包，比如特定于供应商的SDK(例如AWS的SDK)，一组高度冗长的标准库的抽象(这就是为什么人们喜欢使用<a class="ae ky" href="https://2.python-requests.org/en/master/" rel="noopener ugc nofollow" target="_blank"> Python的请求</a>而不是<code class="fe mz na nb nc b">urllib</code>，或者广泛使用的框架，如<a class="ae ky" href="https://echo.labstack.com/" rel="noopener ugc nofollow" target="_blank"> Go的Echo HTTP server </a>或<a class="ae ky" href="https://flask.palletsprojects.com/en/1.1.x/" rel="noopener ugc nofollow" target="_blank"> Python的Flask WSGI server </a>。一些便利的库也不错，比如<a class="ae ky" href="https://lodash.com/" rel="noopener ugc nofollow" target="_blank"> JavaScript的Lodash </a>提供了一些标准库中没有的通用功能和额外功能。这些外部依赖应该使开发更容易，并且不需要您手工编写样板文件或集成代码——这就是包系统的好处。但是，就像<code class="fe mz na nb nc b">left-pad</code>一样，很容易陷入“哦，这有一个库，我就用那个吧”的陷阱对于您导入的每一个依赖项，您都增加了依赖项带来不稳定、不安全或者仅仅是无法维持的风险。</p><p id="c6c8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">随着新依赖项本身导入的每个包，风险也会增加—也称为传递性依赖项。如果您导入一个包，而这个包又导入了五个包，那么您现在已经继承了这五个依赖项以及随之而来的所有风险和危害。我和这个行业的许多其他人会认为包不应该引入传递性依赖。这并不总是可能的，但至少包应该尽可能的精简，如果需要更强大的功能，为用户提供一种显式扩展的方式。</p><p id="fb33" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我在导入库时尝试遵循的一个简单规则是，如果我能在大约10-15分钟内自己编写好，那么我会这样做。否则，如果有可用的外部库，我将使用它。牢记这一规则进行开发将使您免于将不必要的cruft导入到您的应用程序中，但也足够宽松，因为您不需要在每次想要为API提供服务时从头开始编写新的HTTP服务器。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="6f04" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">在这样做之前，您不需要抽象这部分代码</h1><p id="1acb" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">一个非常容易陷入的大陷阱是“抽象一切”的漏洞。“哦，但是我以后可能需要重用它”的想法会导致一些黑暗和可怕的面向对象的道路。我知道为什么。枯燥的原则(不要重复自己)被灌输到我们的头脑中，并且有充分的理由。但是花太多时间抽象而没有足够时间写逻辑是有限度的。只要写你的代码！如果你发现你需要实现一个方法或者一个函数，这个方法或者函数与你已经完成的其他东西相似，那么你可以回过头来抽象它——但是还是有限制的。我个人倾向于遵循的一条规则是，如果在抽象之前它是一个简单的三行函数，那么也许让它保持原样并重复它就可以了。而如果是<strong class="lb iu"> <em class="nd"> </em> </strong>只是3行，也许要问一下到底需不需要函数。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="6cd0" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">你应该不时地“凤凰”你的项目</h1><p id="73e6" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">这是最可怕的。这让经理们紧张，让产品负责人暴躁，让开发人员愤怒，但是你绝对需要这么做。偶尔从头开始是件好事。它允许你删除代码中的垃圾，实现新的想法而不用改造现有代码库的一半，并迫使每个人重新评估项目。</p><p id="1226" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">把你的项目想象成一片森林，每一行代码都是绵延数英里的大森林中一棵高大的松树。随着森林年龄的增长，它变得到处都是矮树丛、脱落的松针、松果、枯枝和许多其他碎片。这是你的脚；你的技术债务。它越积越多，永远不会停止，直到一些激进的变化受到影响。对于森林来说，这种变化以野火的形式出现。大火席卷了整个森林，烧掉了堆积起来的多余的赃物。树皮足够厚的树保留下来，不成熟或发育不良的树在火中被烧毁。虽然这看起来像是森林的末日，但它隐藏着一个巨大的秘密:它在等待火。多年来，森林一直耐心地希望一场火来净化它，带来变化，因为当火在树冠下肆虐时，下一代参天大树正在它们的松果中发芽。当火势蔓延到森林地面时，脆弱的树苗就会冒出来，站在被火熏黑的幸存者旁边。你的应用程序必须是这样的:有弹性的、写得好的部分在清洗中幸存下来，而其余部分为新思想和新代码从烧焦的残骸中出现让路——就像凤凰从灰烬中重生一样。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="ed2b" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">你不是谷歌</h1><p id="17b2" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">除非你是。但如果是这样的话，你为什么要读这个？关键是你很可能不是谷歌、微软、亚马逊、推特或脸书。您不需要在全球17个不同数据中心的10，000台裸机服务器上协调150，000个容器。你的问题通常不会影响到世界上的每个人。我们为什么要谈这个？因为你的规模要决定你的运营平台。如果你有几百个集装箱，你真的需要Kubernetes吗？你真的需要自己运行它吗，或者你只是想把它添加到你的简历中？类似于<a class="ae ky" href="https://www.nomadproject.io/" rel="noopener ugc nofollow" target="_blank"> HashiCorp Nomad </a>的东西对于那些中小规模的问题来说是完美的:它很容易设置，几乎不需要维护，有很好的文档记录，并且非常容易将您的应用程序转移到，因为它可以与容器以及系统进程和JVM应用程序一起工作。如果你真的想经营Kubernetes，为什么不在类似于牧场主的<a class="ae ky" href="https://rancher.com/" rel="noopener ugc nofollow" target="_blank">的管理下进行呢？它会把所有的乱七八糟的东西都提取出来。运行像Kubernetes这样的复杂系统的头痛和开销，对于一个团队来说太多了，无法管理，Kubernetes是为Google这样的公司设计的。我甚至会直截了当地说，创业公司应该不惜一切代价避免它，除非他们的产品是专门针对Kubernetes的。一个警告是使用托管服务，如谷歌、亚马逊和微软在各自的云产品中提供的服务。因为他们管理所有丑陋的东西，很多开销不是你自己承担的。但是永远不要让我抓到你在物联网设备上使用Kubernetes。请不要。</a></p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="c4ea" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">不要完全从网上的陌生人那里形成你的发展理念</h1><p id="3d47" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">您应该自己决定什么规则适用于您的应用程序和您的开发风格。就连这十件事也有争议。我只是网上的一个人。</p></div></div>    
</body>
</html>