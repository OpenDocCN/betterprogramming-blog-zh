<html>
<head>
<title>Why to and How To Use Strict Mode in Angular Applications</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">为什么以及如何在角度应用中使用严格模式</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/why-to-and-how-to-use-strict-mode-in-angular-applications-1e6f6ffc0595?source=collection_archive---------0-----------------------#2022-03-10">https://betterprogramming.pub/why-to-and-how-to-use-strict-mode-in-angular-applications-1e6f6ffc0595?source=collection_archive---------0-----------------------#2022-03-10</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="96d5" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">优势是值得努力的</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/80d6ce413cebc30b3192c42297f0719b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*tOzl5OusIjsxfNOk"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">由<a class="ae kv" href="https://unsplash.com/@tyler_milligan_visuals?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">泰勒·米利根</a>在<a class="ae kv" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</p></figure><p id="a593" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">最近，我加入了一个中型代码库的新项目。像往常一样，我会偷偷摸摸地查看代码，修复一些错误，以熟悉代码、底层业务和潜规则。</p><p id="fd64" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我首先注意到的是Angular API的一些误用以及由于缺乏类型安全性而导致的许多问题。然而关键字<code class="fe ls lt lu lv b">any</code>压倒性地出现在代码库中。</p><p id="d2de" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">当然，我看了一下<code class="fe ls lt lu lv b">tsconfig.json</code>，找到了这些问题的原因——严格模式没有启用。不适用于打字稿和角度模板。于是我激活了它们，旅程开始了…</p><h1 id="8c4c" class="lw lx iq bd ly lz ma mb mc md me mf mg jw mh jx mi jz mj ka mk kc ml kd mm mn bi translated">为什么是严格模式？</h1><p id="5cf6" class="pw-post-body-paragraph kw kx iq ky b kz mo jr lb lc mp ju le lf mq lh li lj mr ll lm ln ms lp lq lr ij bi translated">但首先，让我们总结一下为什么启用严格模式很重要:</p><ul class=""><li id="9ac3" class="mt mu iq ky b kz la lc ld lf mv lj mw ln mx lr my mz na nb bi translated">编译器是你的朋友——但你应该确保它能为你做得最好。如果它不能推断事物的类型，它就不能阻止你犯错。</li><li id="923a" class="mt mu iq ky b kz nc lc nd lf ne lj nf ln ng lr my mz na nb bi translated">将运行时错误转化为编译时错误。在代码在生产中运行之前可以发现的每个错误都是永远不会向用户显示的错误。</li><li id="a028" class="mt mu iq ky b kz nc lc nd lf ne lj nf ln ng lr my mz na nb bi translated">如果你需要重构你的代码，单元测试是很棒的。您将需要这样做——否则，您已经编写了可能从未使用过的代码。但是，如果不使用严格的类型检查，更改一些非预期内容的可能性就更大了。</li><li id="4450" class="mt mu iq ky b kz nc lc nd lf ne lj nf ln ng lr my mz na nb bi translated">你会提高你的生产力。因为每样东西都有一个合适的类型，所以您永远不需要分析完整的代码流来确定它是什么类型，或者它是否可以为空或未定义。</li><li id="17ec" class="mt mu iq ky b kz nc lc nd lf ne lj nf ln ng lr my mz na nb bi translated">您解决的另一个问题是，可以检查从组件的HTML模板生成的代码，以匹配输入类型要求。如果你不使用模板严格的选项，你可以做一些奇怪的事情。</li></ul><h1 id="26d3" class="lw lx iq bd ly lz ma mb mc md me mf mg jw mh jx mi jz mj ka mk kc ml kd mm mn bi translated">如何启用严格模式？</h1><p id="0ad2" class="pw-post-body-paragraph kw kx iq ky b kz mo jr lb lc mp ju le lf mq lh li lj mr ll lm ln ms lp lq lr ij bi translated">如果你正在使用一个新的Angular应用程序，你可以使用Angular CLI的<code class="fe ls lt lu lv b">--strict</code>选项。这将启用您的<code class="fe ls lt lu lv b">tsconfig.json</code>文件中所有可用的严格选项。我在下面的代码块中突出显示了负责的选项:</p><pre class="kg kh ki kj gt nh lv ni nj aw nk bi"><span id="9c8a" class="nl lx iq lv b gy nm nn l no np">{<br/>  "compileOnSave": false,<br/>  "compilerOptions": {<br/>    "baseUrl": "./",<br/>    "outDir": "./dist/out-tsc",<br/>    "forceConsistentCasingInFileNames": true,<br/>    <strong class="lv ir">"strict": true,<br/>    "noImplicitOverride": true,<br/>    "noPropertyAccessFromIndexSignature": true,<br/>    "noImplicitReturns": true,<br/>    "noFallthroughCasesInSwitch": true,</strong><br/>    "sourceMap": true,<br/>    "declaration": false,<br/>    "downlevelIteration": true,<br/>    "experimentalDecorators": true,<br/>    "moduleResolution": "node",<br/>    "importHelpers": true,<br/>    "target": "es2017",<br/>    "module": "es2020",<br/>    "lib": [<br/>      "es2020",<br/>      "dom"<br/>    ]<br/>  },<br/>  "angularCompilerOptions": {<br/>    "enableI18nLegacyMessageIdFormat": false,<br/>    <strong class="lv ir">"strictInjectionParameters": true,<br/>    "strictInputAccessModifiers": true,<br/>    "strictTemplates": true</strong><br/>  }<br/>}</span></pre><p id="6685" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">你可以在这里找到更多关于Angular编译器选项的信息:<a class="ae kv" href="https://angular.io/guide/template-typecheck" rel="noopener ugc nofollow" target="_blank">https://angular.io/guide/template-typecheck</a>。关于TypeScript编译器严格选项的描述可以在这里找到:<a class="ae kv" href="https://www.typescriptlang.org/tsconfig#strict" rel="noopener ugc nofollow" target="_blank">https://www.typescriptlang.org/tsconfig#strict</a>。</p><h1 id="bd7e" class="lw lx iq bd ly lz ma mb mc md me mf mg jw mh jx mi jz mj ka mk kc ml kd mm mn bi translated">现有应用的严格模式</h1><p id="f035" class="pw-post-body-paragraph kw kx iq ky b kz mo jr lb lc mp ju le lf mq lh li lj mr ll lm ln ms lp lq lr ij bi translated">对于现有的应用程序，您也可以打开这些选项。但是——取决于代码库的大小和现有的代码质量——您将面临大量的编译器错误，并且您将立即关闭这些选项。一步到位解决所有问题可能是不可能的。</p><p id="6f93" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">如果你已经在一个核心的、共享的和多特性的库中构建了你的代码，你是幸运的。在这种情况下，您可以逐个启用严格模式库并修复编译器错误。您拉取请求的审核者也会对此非常感激。</p><p id="601f" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">另一个策略是逐个启用严格选项。另外，你需要知道<code class="fe ls lt lu lv b">strict</code>选项是不同选项的组合。大部分都可以独立开启。</p><p id="0142" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我的情况是从<code class="fe ls lt lu lv b">strictBindCallApply</code>、<code class="fe ls lt lu lv b">strictFunctionTypes</code>、<code class="fe ls lt lu lv b">noImplicitReturn </code>和<code class="fe ls lt lu lv b">noImplicitAny</code>开始。如果您已经修复了所有编译错误，那么您应该有一个代码库，其中所有内容都有一个合适的类型。这将使下面的重构变得容易得多。</p><p id="9d91" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">最后一步是开启<code class="fe ls lt lu lv b">strictNullChecks</code>和<code class="fe ls lt lu lv b">strictPropertyInitialization</code>最后一个选项需要开启<code class="fe ls lt lu lv b">strictNullChecks</code>。尤其是最后一个选项会改变你写代码的方式。</p><h1 id="d6b3" class="lw lx iq bd ly lz ma mb mc md me mf mg jw mh jx mi jz mj ka mk kc ml kd mm mn bi translated">StrictNullChecks</h1><p id="f01b" class="pw-post-body-paragraph kw kx iq ky b kz mo jr lb lc mp ju le lf mq lh li lj mr ll lm ln ms lp lq lr ij bi translated">不过先来看看<code class="fe ls lt lu lv b">strictNullChecks</code>。在大多数情况下，您所要做的就是使用可选的链接操作符来避免访问可能是<code class="fe ls lt lu lv b">null </code>或<code class="fe ls lt lu lv b">undefined</code>的值。</p><p id="01ae" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">但是可选的链会破坏你的代码。请记住，选项是语法糖，并被编译成JavaScript。它们是<code class="fe ls lt lu lv b">if</code>语句或三元运算符。例如，在您的TypeScript代码中，使用可选链接运算符的一个非常简单的情况很简单:</p><pre class="kg kh ki kj gt nh lv ni nj aw nk bi"><span id="b3eb" class="nl lx iq lv b gy nm nn l no np"><strong class="lv ir"><em class="nq">console</em></strong>.log(this.address?.street)</span></pre><p id="7307" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">但是它被编译成JavaScript，可能看起来像这样:</p><pre class="kg kh ki kj gt nh lv ni nj aw nk bi"><span id="a535" class="nl lx iq lv b gy nm nn l no np"><strong class="lv ir"><em class="nq">var n;<br/>console</em></strong>.log(null===(n=this.address)||void 0===n?void 0:n.street)</span></pre><p id="553f" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">不幸的是，即使你的<code class="fe ls lt lu lv b">address</code>永远不可能是<code class="fe ls lt lu lv b">null</code>或<code class="fe ls lt lu lv b">undefined</code>，情况也是如此。所以请记住:不检查<code class="fe ls lt lu lv b">address</code>是否存在是错误的，但是如果您毫无理由地使用可选的链接操作符，编译器不会警告您。</p><p id="a592" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">另一个绊脚石是可选的链接操作符阻止您访问<code class="fe ls lt lu lv b">null</code>或<code class="fe ls lt lu lv b">undefined</code>值。但是你不能给可以被<code class="fe ls lt lu lv b">undefined</code>的东西赋值。以下情况是不可能的:</p><pre class="kg kh ki kj gt nh lv ni nj aw nk bi"><span id="026b" class="nl lx iq lv b gy nm nn l no np">this.address?.street = 'any street';  (compile error)</span></pre><p id="32f5" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">不幸的是，这些并不是唯一有问题的案例。想象一个可能是<code class="fe ls lt lu lv b">null</code>的数组，你想检查它的大小:</p><pre class="kg kh ki kj gt nh lv ni nj aw nk bi"><span id="7cf6" class="nl lx iq lv b gy nm nn l no np">if (countries?.length &gt; 2) {...}  (compile error)</span></pre><p id="06d1" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">因为<code class="fe ls lt lu lv b">countries?.length</code>有可能是<code class="fe ls lt lu lv b">undefined</code>，所以不能用一个数字来比较。在这些情况下，你需要检查<code class="fe ls lt lu lv b">countries</code>是否以旧的方式存在。但正如我们马上会看到的，这也是可以解决的。</p><h1 id="d414" class="lw lx iq bd ly lz ma mb mc md me mf mg jw mh jx mi jz mj ka mk kc ml kd mm mn bi translated">StrictPropertyInitialization</h1><p id="5e10" class="pw-post-body-paragraph kw kx iq ky b kz mo jr lb lc mp ju le lf mq lh li lj mr ll lm ln ms lp lq lr ij bi translated">如果您启用了<code class="fe ls lt lu lv b">strictPropertyInitialization</code>选项，编译器将强制在对象创建后，每个类成员都有一个与其类型匹配的初始值。如果你不能提供一个合适的值，你需要告诉编译器这个成员可能是<code class="fe ls lt lu lv b">undefined</code>。</p><p id="38da" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">之后，您几乎不可能访问一个可能是<code class="fe ls lt lu lv b">undefined</code>的值并导致运行时错误。不仅如此，你将开始重新思考你的代码的设计。让我们来看一些例子，看看如何提供一个合适的初始值:</p><ul class=""><li id="2fe4" class="mt mu iq ky b kz la lc ld lf mv lj mw ln mx lr my mz na nb bi translated">最简单的:用<code class="fe ls lt lu lv b">false</code>初始化一个布尔值，用空字符串初始化一个字符串，或者用0初始化一个数字。如果数字表示数组的索引，则-1也可以是合适的初始值。</li><li id="431c" class="mt mu iq ky b kz nc lc nd lf ne lj nf ln ng lr my mz na nb bi translated">我见过很多角应用的形式。在大多数情况下，它们是用<code class="fe ls lt lu lv b">FormBuilder</code>创建的，但是你不需要使用这个对象，你可以用<code class="fe ls lt lu lv b">name = new FormControl()</code>创建一个<code class="fe ls lt lu lv b">FormControl</code>，然后用一个<code class="fe ls lt lu lv b">FormGroup</code>组合它们。这都可以在成员初始化期间完成。好的副作用:在你的模板中不再需要<code class="fe ls lt lu lv b">form.get('name')</code>。你只要写:<code class="fe ls lt lu lv b">&lt;input [formControl]="name"/&gt;</code>模板里的一个函数调用就没了。</li><li id="03eb" class="mt mu iq ky b kz nc lc nd lf ne lj nf ln ng lr my mz na nb bi translated">如果您有更高级别的对象，您可以提供一个“空对象”。并不意味着值为空；这意味着该值表示没有有意义行为的值。这种模式也可以应用于稍后设置的回调函数。角度应用的一个典型案例是<code class="fe ls lt lu lv b">ControlValueAccessor</code>实现中的<code class="fe ls lt lu lv b">onChange</code>和<code class="fe ls lt lu lv b">onTouch</code>回调。只要用一个空函数<code class="fe ls lt lu lv b">()=&gt;{}</code>初始化这些函数，你就永远不必处理这些函数没有被设置的情况。</li><li id="341c" class="mt mu iq ky b kz nc lc nd lf ne lj nf ln ng lr my mz na nb bi translated">如果您有一个<code class="fe ls lt lu lv b">enum</code>来代表不同的州，您可以创建一个附加选项<code class="fe ls lt lu lv b">UNKNOWN</code>。</li><li id="36ba" class="mt mu iq ky b kz nc lc nd lf ne lj nf ln ng lr my mz na nb bi translated">经常会有类似配置对象的东西。您可以用默认配置初始化成员，并将默认值与具体值合并。</li><li id="206d" class="mt mu iq ky b kz nc lc nd lf ne lj nf ln ng lr my mz na nb bi translated">一个简单但影响巨大的变化:确保所有数组都用空数组初始化。在这种情况下，您永远不会遇到长度检查必须处理我们在上面看到的<code class="fe ls lt lu lv b">undefined</code>情况(<code class="fe ls lt lu lv b">array.length &gt; 0</code>)。同样，像<code class="fe ls lt lu lv b">map</code>、<code class="fe ls lt lu lv b">filter</code>或<code class="fe ls lt lu lv b">reduce</code>这样受人喜爱的数组函数也将受益于这个初始值。</li><li id="5a34" class="mt mu iq ky b kz nc lc nd lf ne lj nf ln ng lr my mz na nb bi translated">不要忘记在构造函数中设置初始值是可能的。但是要小心:Angular注入的值可能还没有运行过它的<code class="fe ls lt lu lv b">ngOnInit</code>函数，输入属性可能还没有设置。</li><li id="1484" class="mt mu iq ky b kz nc lc nd lf ne lj nf ln ng lr my mz na nb bi translated">如果您使用<code class="fe ls lt lu lv b">ngrx</code>，您可以在构造器中初始化您的选择:<code class="fe ls lt lu lv b">this.myObservable$ = store.select(selector())</code>。如果你这样做，你的模板中的<code class="fe ls lt lu lv b">async</code>管道将像一个魔咒一样工作，因为可观察的永远不会是<code class="fe ls lt lu lv b">null</code>或<code class="fe ls lt lu lv b">undefined</code>。</li><li id="56d2" class="mt mu iq ky b kz nc lc nd lf ne lj nf ln ng lr my mz na nb bi translated">如果您使用OpenApi并生成您的模型，不要忘记指定必填字段，否则它们会作为可选属性生成，您需要处理它们。我比较经常看到的:指定了模型，没有设置必填字段。现在每个使用这个API的人都必须处理属性可能是<code class="fe ls lt lu lv b">undefined</code>的情况——在前端和后端代码中。但是在大多数情况下，这些属性总是有一个合适的值。不要忘记集合类型。如果没有可用的集合项目，请确保它们始终作为空集合传输。</li></ul><p id="a585" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">一个警告。角度应用的严格模式从版本10开始可用。仍然存在框架没有为其API提供正确类型的情况。例如，反应式表单API。但是团队正在解决这些问题。</p><p id="0d37" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">看看<a class="ae kv" href="https://github.com/angular/angular/issues/13721" rel="noopener ugc nofollow" target="_blank">https://github.com/angular/angular/issues/13721</a>看看表单的类型化API的状态。</p><h1 id="0a0d" class="lw lx iq bd ly lz ma mb mc md me mf mg jw mh jx mi jz mj ka mk kc ml kd mm mn bi translated">结论</h1><p id="c1e2" class="pw-post-body-paragraph kw kx iq ky b kz mo jr lb lc mp ju le lf mq lh li lj mr ll lm ln ms lp lq lr ij bi translated">有时候，我在想为什么人们会用TypeScript和Angular。您有合适的工具来编写高质量、干净、可维护和可读的代码，而不必使用低级浏览器API和DOM，这可以提高您的工作效率。</p><p id="c6d0" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">此外，您可以将运行时错误转化为构建时错误。但我看到的是，所有帮助你实现这些目标的东西都没有被激活或有意去激活。</p><p id="3b4f" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">不要这样。使用<code class="fe ls lt lu lv b">strict</code>选项生成您的新应用。如果您还没有，现在激活严格编译器选项。优点值得努力！</p><p id="a2a9" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">下一个大任务是告诉您的同事，如果您不在每次提交时自动格式化代码，为什么会浪费时间和资源:)</p></div></div>    
</body>
</html>