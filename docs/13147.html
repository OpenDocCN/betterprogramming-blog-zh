<html>
<head>
<title>Investigate Functional Programming Concepts in Go</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">研究Go中的函数式编程概念</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/investigate-functional-programming-concepts-in-go-1dada09bc913?source=collection_archive---------3-----------------------#2022-08-02">https://betterprogramming.pub/investigate-functional-programming-concepts-in-go-1dada09bc913?source=collection_archive---------3-----------------------#2022-08-02</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="40b1" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">应用概念</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/f59903cde36a814d94e134ac9fb9b5dc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*_STl7GwECRmAhRGS"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated"><a class="ae kv" href="https://unsplash.com/@vinomamba24?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Vino Li </a>在<a class="ae kv" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍照</p></figure><p id="50d5" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在本文中，我们将研究如何在<a class="ae kv" href="https://go.dev/" rel="noopener ugc nofollow" target="_blank"> Go </a>中利用函数式编程概念。</p><p id="e6f6" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们将触及go 1.18 中<a class="ae kv" href="https://tip.golang.org/doc/go1.18#generics" rel="noopener ugc nofollow" target="_blank">泛型的引入所带来的可能性和一些限制。函数式编程风格帮助我们编写易于理解、可维护和可测试的代码。</a></p><p id="7c12" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">许多底层概念已经在广泛使用的语言的最新版本中找到了自己的方式，特别是<a class="ae kv" href="https://docs.oracle.com/javase/tutorial/collections/streams/reduction.html" rel="noopener ugc nofollow" target="_blank"> map/reduce </a>模式或<a class="ae kv" href="https://doc.rust-lang.org/std/option/enum.Option.html" rel="noopener ugc nofollow" target="_blank">可选</a>值的概念。</p><h1 id="858a" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">指导原则</h1><p id="adfa" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">我想强调以下原则，它们是函数式编程风格的基础:</p><h2 id="1617" class="mp lt iq bd lu mq mr dn ly ms mt dp mc lf mu mv me lj mw mx mg ln my mz mi na bi translated">纯函数</h2><p id="dd11" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">顾名思义，函数式编程就是写函数。如果一个函数的输出只依赖于它的输入，并且没有任何副作用<a class="ae kv" href="https://en.wikipedia.org/wiki/Side_effect_(computer_science)" rel="noopener ugc nofollow" target="_blank">的话，这个函数被认为是</a><a class="ae kv" href="https://en.wikipedia.org/wiki/Pure_function" rel="noopener ugc nofollow" target="_blank">纯</a>。这种功能有几个好处:</p><ul class=""><li id="d681" class="nb nc iq ky b kz la lc ld lf nd lj ne ln nf lr ng nh ni nj bi translated">通常很容易理解这个函数在做什么，因为根据定义，您知道它没有任何副作用</li><li id="21a6" class="nb nc iq ky b kz nk lc nl lf nm lj nn ln no lr ng nh ni nj bi translated">该功能可以进行单元测试，而不必设置复杂的模拟</li><li id="55fc" class="nb nc iq ky b kz nk lc nl lf nm lj nn ln no lr ng nh ni nj bi translated">纯函数很容易在多线程环境中使用。因为它们没有副作用，所以也不需要外部数据结构的同步</li></ul><p id="941d" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">有副作用的函数被认为是不纯的。这种意义上的副作用是非本地状态的任何修改(即改变全局变量、改变输入参数)或任何形式的I/O(从流或文件中读取/写入、打印到控制台等)。).</p><p id="8a76" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">另一方面，副作用是程序的一个关键特征，因此函数式编程提供了将它们与纯函数结合的机制，例如<a class="ae kv" href="https://en.wikipedia.org/wiki/Monad_(functional_programming)#IO_monad" rel="noopener ugc nofollow" target="_blank"> I/O Monad </a>。在这篇文章中，我们将不再赘述。</p><h2 id="e0da" class="mp lt iq bd lu mq mr dn ly ms mt dp mc lf mu mv me lj mw mx mg ln my mz mi na bi translated">不变</h2><p id="7c53" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">不可变数据结构背后的关键思想是，如果一个函数不能改变任何数据，那么这个函数的行为更容易预测。这与纯函数的概念密切相关，纯函数意味着一个纯函数不能改变它的任何输入。我们不是更改数据，而是制作稍微修改过的数据拷贝。</p><h2 id="bfdf" class="mp lt iq bd lu mq mr dn ly ms mt dp mc lf mu mv me lj mw mx mg ln my mz mi na bi translated">作文</h2><p id="f746" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">拥有纯函数的一个好处是，我们可以使用这些函数，并将它们组合成更复杂(纯)的函数。由于这种组合的每一个构件都可以作为一个单元来测试，所以我们可以满怀信心地派生出更高级的功能，直到我们最终达到所需程序的水平。</p><p id="b7de" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">事实证明，有可能提出一组对许多情况都有用的组合函数，因此我们可以一般地实现它们。这反过来又提高了可读性，因为同一组复合函数反复出现，并且总是具有相同的语义。</p></div><div class="ab cl np nq hu nr" role="separator"><span class="ns bw bk nt nu nv"/><span class="ns bw bk nt nu nv"/><span class="ns bw bk nt nu"/></div><div class="ij ik il im in"><h1 id="cc59" class="ls lt iq bd lu lv nw lx ly lz nx mb mc jw ny jx me jz nz ka mg kc oa kd mi mj bi translated">申请外带</h1><p id="ab45" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">让我们研究一下前面提到的概念是如何应用于Go语言的。我们用一个简单的例子来说明。编写一个执行以下操作的函数:</p><ul class=""><li id="bb91" class="nb nc iq ky b kz la lc ld lf nd lj ne ln nf lr ng nh ni nj bi translated">取一个未知物体的<code class="fe ob oc od oe b">map</code>作为输入</li><li id="8905" class="nb nc iq ky b kz nk lc nl lf nm lj nn ln no lr ng nh ni nj bi translated">阅读这张地图的一个条目</li><li id="976f" class="nb nc iq ky b kz nk lc nl lf nm lj nn ln no lr ng nh ni nj bi translated">如果条目是一个字符串，尝试将其转换成一个<code class="fe ob oc od oe b">int</code></li><li id="cce8" class="nb nc iq ky b kz nk lc nl lf nm lj nn ln no lr ng nh ni nj bi translated">如果任何一项失败，则返回默认值</li></ul><p id="f2c1" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在惯用的Go中，这段代码可能如下所示:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="of og l"/></div></figure><p id="0c80" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在Go中，可能失败的操作将其返回值建模为一个元组，在第一个元素中有实际值，在第二个元素中有一个标志或错误。然而，这个元组在Go中并不表示为顶级类型，也就是说，我们只能将其析构为两个变量，但我们不能编写一个接受元组作为输入的函数来将各个步骤组合在一起。</p><p id="cdcb" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">让我们引入一个<code class="fe ob oc od oe b">Option</code>的概念来解决这个问题。<code class="fe ob oc od oe b">Option</code>是一种数据类型，它携带一个值或<strong class="ky ir"> </strong>无值的概念:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="of og l"/></div></figure><p id="822a" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">使用这种数据类型，我们可以编写表示原始操作的可组合函数:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="of og l"/></div></figure><p id="5ee7" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">注意助手函数中泛型的使用。<code class="fe ob oc od oe b">Lookup</code>方法是完全通用的，它适用于任何类型的<code class="fe ob oc od oe b">map</code>，因此它是实用程序库的一个很好的候选。<code class="fe ob oc od oe b">ToString</code>和<code class="fe ob oc od oe b">ParseToInt</code>方法为它们的用例专门化了一般的<code class="fe ob oc od oe b">Options</code>类型。</p><p id="ea9e" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">将原语操作分离到它们自己的函数中的第一个好处是，我们现在可以为这些函数编写单元测试，包括完整的边界检查。当我们将这些结合在一起时，真正的优势就体现出来了。为此，我们定义了可重用的组合操作:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="of og l"/></div></figure><p id="44b7" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">请特别注意<code class="fe ob oc od oe b">Chain</code>方法。它将可能包装一种类型<code class="fe ob oc od oe b">A</code>的<code class="fe ob oc od oe b">Option</code>转换成可能包装另一种类型<code class="fe ob oc od oe b">B</code>的<code class="fe ob oc od oe b">Option</code>。类型之间的关系由转换函数给出。我们所有的帮助函数都是这种特殊的数据类型，它们接受一个普通类型作为输入，返回另一种类型的<code class="fe ob oc od oe b">Option</code>作为输出。因此，他们立即与我们新的<code class="fe ob oc od oe b">Chain</code>运营部门合作。让我们看看如何将它应用到我们最初的问题中:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="of og l"/></div></figure><p id="ee66" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这个例子比惯用的例子有优势，因为它避免了重复使用<code class="fe ob oc od oe b">if</code>子句进行错误处理。它显示了操作的逻辑顺序流，并将错误处理转移到组合功能的实现中。尽管如此，代码看起来还是有点复杂。</p><p id="331a" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们注意到这段代码中的两个方面:</p><ul class=""><li id="4e67" class="nb nc iq ky b kz la lc ld lf nd lj ne ln nf lr ng nh ni nj bi translated">每一行都有相同的结构。首先，我们创建一个描述期望操作的函数，例如<code class="fe ob oc od oe b">Chain(ToString)</code>，然后我们将这个函数应用于一个值</li><li id="a3ee" class="nb nc iq ky b kz nk lc nl lf nm lj nn ln no lr ng nh ni nj bi translated">每个函数的参数是前一个函数的返回值，形式上我们不需要任何中间值</li></ul><p id="77eb" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">那么，我们如何以一种更易读、更紧凑的方式将这些函数组合在一起呢？</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="of og l"/></div></figure><p id="0ef4" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在第一次尝试中，我们可以简单地尝试将函数链接在一起作为嵌套函数。这是可行的，但是严重缺乏可读性，主要是因为函数的读取顺序与执行顺序不匹配。我们首先读取<code class="fe ob oc od oe b">O.GetOrElse</code>，但它实际上是最后一个被调用的函数。此外，我们添加的步骤越多，阅读体验就越差。</p><p id="8359" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">让我们通过引入另一个效用函数<code class="fe ob oc od oe b">Pipe</code>来解决这个问题，该函数接受初始值，然后接受一系列连续应用于前一个函数输出的函数:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="of og l"/></div></figure><p id="38c2" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这段代码看起来干净多了，它按照逻辑顺序显示了操作，易于理解，并且没有因为显式的错误处理而使代码混乱。我们还可以做得更好一点，因为我们注意到除了作为第一个函数的种子之外，输入变量<code class="fe ob oc od oe b">data</code>并不是显式需要的。</p><p id="1de1" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">因此，我们不使用<code class="fe ob oc od oe b">Pipe</code>辅助函数，而是引入一个带有这个签名<code class="fe ob oc od oe b">func Flow(f1, f2, ...) func(T)R</code>的<code class="fe ob oc od oe b">Flow</code>输入函数，也就是说，它创建一个新函数，其输入与作为第一个参数接收的函数相同，返回值与上一个函数的返回值相同。然后我们的例子最终看起来像这样:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="of og l"/></div></figure></div><div class="ab cl np nq hu nr" role="separator"><span class="ns bw bk nt nu nv"/><span class="ns bw bk nt nu nv"/><span class="ns bw bk nt nu"/></div><div class="ij ik il im in"><h2 id="cb0b" class="mp lt iq bd lu mq mr dn ly ms mt dp mc lf mu mv me lj mw mx mg ln my mz mi na bi translated">单子</h2><p id="21ef" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">在开发最后一个函数的过程中，我们发现了<code class="fe ob oc od oe b">Options</code>类型及其关键操作<code class="fe ob oc od oe b">Of</code>和<code class="fe ob oc od oe b">Chain</code>的用处。在函数式编程中，这就是我们所说的<a class="ae kv" href="https://en.wikipedia.org/wiki/Monad_(functional_programming)" rel="noopener ugc nofollow" target="_blank">单子</a>，事实证明底层模式可以应用于更多的用例。</p><p id="27f1" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在我们的实现中，<code class="fe ob oc od oe b">Of</code>方法有时被称为<code class="fe ob oc od oe b">unit</code>、<code class="fe ob oc od oe b">return</code>或<code class="fe ob oc od oe b">just</code>，它的意思是将一个值包装到一个装箱的值中，这个装箱能够实现通用的操作。<code class="fe ob oc od oe b">Chain</code>方法也被称为<code class="fe ob oc od oe b">bind</code>、<code class="fe ob oc od oe b">flatMap</code>或<code class="fe ob oc od oe b">mergeMap</code>，它允许将函数应用于包装的值，同时让通用代码在结果上运行。</p><h1 id="ce10" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">Golang特征</h1><p id="8372" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">Go 1.18中<a class="ae kv" href="https://tip.golang.org/doc/go1.18#generics" rel="noopener ugc nofollow" target="_blank">泛型</a>的引入，使得为多种数据类型编写代码成为可能。使用语法<code class="fe ob oc od oe b">type Option[A any] interface</code>我们告诉大家，我们打算为任何类型的数据表示一个包装器，而无需在编码时指定这种类型。</p><p id="4dab" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">函数式编程方法的另一个关键方面是将函数组合在一起的能力。事实证明，定义只有一个输入参数和一个输出的函数是有帮助的，因为这样我们就可以轻松地将一个函数的输出作为下一个函数的输入进行传递，并创建管道。为了使用这个特性，我们利用go的能力来创建<a class="ae kv" href="https://www.golangprograms.com/higher-order-functions-in-golang.html" rel="noopener ugc nofollow" target="_blank">高阶函数</a>。</p><p id="1e60" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们的<code class="fe ob oc od oe b">Chain</code>方法被声明为<code class="fe ob oc od oe b">func Chain[A, B any](f func(A)Option[B])func(Option[A])Option[B]</code>，即它是一个接受一个输入的函数，一个转换函数<code class="fe ob oc od oe b">f</code>，它返回另一个函数作为输出。这个函数依次接受一个输入，一个<code class="fe ob oc od oe b">Option[A]</code>并返回一个输出，一个<code class="fe ob oc od oe b">Option[B]</code>。这种结构允许高效的功能组合。</p><p id="fe78" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">纯函数的函数式编程概念很好地匹配了Go语言的特性。尽管Go并不强制执行这种模式，但它允许实现这种模式。</p><p id="9fd3" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">加上对高阶函数的良好支持，编写纯函数是程序员的准则。</p><h1 id="d03e" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">限制</h1><p id="ce2e" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">虽然可以用函数式风格实现程序，但存在一些语言限制:</p><h2 id="dc68" class="mp lt iq bd lu mq mr dn ly ms mt dp mc lf mu mv me lj mw mx mg ln my mz mi na bi translated">类型差异</h2><p id="1973" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">Go不支持不可变数据结构的概念。如果需要，程序员可以确保数据结构在函数调用过程中保持不变。</p><p id="07b5" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">然而，这种缺乏概念的结果是所有的数据类型，尤其是容器类型，都被认为是<a class="ae kv" href="https://en.wikipedia.org/wiki/Covariance_and_contravariance_(computer_science)" rel="noopener ugc nofollow" target="_blank">不变的</a>。如果语言支持不可变类型，我们更喜欢纯函数的协变类型的概念。</p><p id="fb11" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">考虑下面的例子:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="of og l"/></div></figure><p id="995b" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们可以很容易地用一个<code class="fe ob oc od oe b">int</code>作为输入来调用<code class="fe ob oc od oe b">TakeAny</code>函数，尽管它接受一个<code class="fe ob oc od oe b">any</code>。</p><p id="7893" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">但是我们不能进行第二次调用，在第二次调用中，<code class="fe ob oc od oe b">TakeAnyArray</code>接受了一个<code class="fe ob oc od oe b">[]any</code>，我们试图用一个<code class="fe ob oc od oe b">[]int</code>调用它。</p><p id="91f6" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这完全有意义，因为<code class="fe ob oc od oe b">[]int</code>是可修改的，如果我们允许它被传递到一个带<code class="fe ob oc od oe b">[]any</code>的函数中，那么这个函数可能会尝试将一个<code class="fe ob oc od oe b">float</code>或任何其他数据类型添加到数组中，这当然是行不通的。如果我们有办法告诉我们只打算从数组中读取，那么传入<code class="fe ob oc od oe b">int</code>数组是可以接受的，但这是<a class="ae kv" href="https://go.googlesource.com/proposal/+/refs/heads/master/design/43651-type-parameters.md#no-way-to-express-convertibility" rel="noopener ugc nofollow" target="_blank">而不是</a>的情况。</p><p id="72fa" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">注意，原语<code class="fe ob oc od oe b">int</code>本质上是不可变的，这是我们可以毫无问题地调用<code class="fe ob oc od oe b">TakeAny</code>的原因。</p><p id="08a7" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">该问题适用于所有容器类型，包括我们的<code class="fe ob oc od oe b">Option[A]</code>。我们知道<code class="fe ob oc od oe b">Option</code>本质上是不可变的，但是没有办法告诉编译器。</p><p id="fd3f" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">因此，如果我们有一个函数返回一个<code class="fe ob oc od oe b">Option[*File]</code>(例如<a class="ae kv" href="https://pkg.go.dev/os#Open" rel="noopener ugc nofollow" target="_blank">打开</a>)，我们不能在没有显式类型转换的情况下将它直接链接到一个接受<code class="fe ob oc od oe b">Reader</code>的函数。</p><h2 id="99f8" class="mp lt iq bd lu mq mr dn ly ms mt dp mc lf mu mv me lj mw mx mg ln my mz mi na bi translated">函数重载</h2><p id="0b48" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">Go不支持重载函数，即定义一个同名但参数不同的函数。</p><p id="f0ef" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">最接近重载的是<a class="ae kv" href="https://gobyexample.com/variadic-functions" rel="noopener ugc nofollow" target="_blank">变量函数</a>，但是这些函数要求变量函数的参数是相同类型的。</p><p id="c24f" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这个限制直接适用于我们的<code class="fe ob oc od oe b">Pipe</code>函数。理想情况下，我们希望为任意数量的输入定义该函数，同时保持类型安全。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="of og l"/></div></figure><p id="1a7d" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">但是，由于缺少函数重载，我们需要为每个参数明确定义不同的函数。我们需要记住在添加和删除管道步骤时使用正确的数字后缀。但至少这给了我们类型安全，如果我们用错误数量的参数调用函数，编译器会让我们知道。</p><h2 id="2d79" class="mp lt iq bd lu mq mr dn ly ms mt dp mc lf mu mv me lj mw mx mg ln my mz mi na bi translated">方法的类型参数</h2><p id="8eb1" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">在前面的例子中，您可能想知道为什么我们要编写复杂的<code class="fe ob oc od oe b">Pipe</code>函数，而不是使用链接方法。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="of og l"/></div></figure><p id="71fe" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在上面虚构的例子中，如果<code class="fe ob oc od oe b">Optional</code>类型包含<code class="fe ob oc od oe b">Chain</code>和其他操作作为实例方法，我们就不需要<code class="fe ob oc od oe b">Pipe</code>。</p><p id="3b53" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">然而，这是不可能的，因为<code class="fe ob oc od oe b">Chain</code>需要两个类型参数，一个用于它所操作的<code class="fe ob oc od oe b">Option</code>，另一个用于返回值的类型，因为我们使用转换函数来改变类型。这需要<code class="fe ob oc od oe b">Chain</code>携带自己的类型参数，这是<a class="ae kv" href="https://github.com/golang/go/issues/49085" rel="noopener ugc nofollow" target="_blank">泛型规范</a>所禁止的。</p><h1 id="3c2c" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">结论</h1><p id="8338" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">函数式编程风格提供了一个非常吸引人的编程模型，但同时，它与Go语言一起使用也暴露了一些缺点，特别是因为(临时？)语言限制和对惯用编码风格的偏离。还值得用吗？</p><p id="22f8" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">对我来说，答案是肯定的。纯函数、不可变的数据结构和函数组合几乎会自动产生可测试的干净代码。如果编写测试很容易，那么同时编写测试代码和函数就成了第二天性，而且随着时间的推移，这是值得的。</p><p id="41fc" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">函数组合允许将大量样板代码转移到实用程序库中。这些只需编写和测试一次，就可以在许多项目中重用。</p><p id="bfef" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">由于相同的组合函数<code class="fe ob oc od oe b">Chain</code>、<code class="fe ob oc od oe b">Map</code>、<code class="fe ob oc od oe b">Reduce</code>……反复出现，即使在<code class="fe ob oc od oe b">Monads</code>中，代码也易于阅读，尽管它偏离了惯用的编码风格。这是一个习惯的问题，但这只是我经验中很浅的学习曲线。</p><p id="2166" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">但是为什么不使用一种对函数模式有更好内置支持的语言，比如<a class="ae kv" href="https://www.rust-lang.org/" rel="noopener ugc nofollow" target="_blank"> Rust </a>？语言的选择不仅取决于语法和语言特性，还取决于生态系统。今天，Go是基于云的应用程序的通用语言，所以如果你想与图书馆的庞大生态系统集成，Go是一个不错的选择。工具和IDE支持也非常好，所以我们可以轻松地跨平台编译。</p><p id="83cb" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">因此，让我们结合两个世界的优点来编写令人敬畏的代码！</p></div></div>    
</body>
</html>