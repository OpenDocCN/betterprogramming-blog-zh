<html>
<head>
<title>Using Lambda Authorizers with AWS Websockets</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">将Lambda授权器与AWS Websockets一起使用</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/using-authoriser-for-aws-websockets-caf7a0441c8e?source=collection_archive---------25-----------------------#2022-01-27">https://betterprogramming.pub/using-authoriser-for-aws-websockets-caf7a0441c8e?source=collection_archive---------25-----------------------#2022-01-27</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="bef0" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">了解Auth如何工作以及如何部署它</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/b2fccd01f70bc2bfce54b798813cb272.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*iQI86uayRajVRNTZHKWfKw.jpeg"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated"><a class="ae ky" href="https://unsplash.com/@ninjason?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">梁杰森</a>在<a class="ae ky" href="https://unsplash.com/s/photos/chat?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的照片</p></figure><p id="d9ff" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在我的上一篇文章中，我们学习了如何在AWS中创建一个WebSocket API。我们建立了一个功能API，我们可以连接到它并从中发送消息。但这只是谜题的一部分。</p><p id="36a2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在我们从WebSockets开始，我们必须谈谈安全性。真的，我们应该从安全问题开始，但是事情已经过去了。我们不希望恶意用户连接到我们的API，并试图通过<a class="ae ky" href="https://www.cloudflare.com/learning/ddos/what-is-a-ddos-attack/" rel="noopener ugc nofollow" target="_blank"> DDoS </a>或注入攻击来搞垮我们。</p><p id="8b3f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">今天，我们将利用上周创建的内容，为其添加一个<a class="ae ky" href="https://docs.aws.amazon.com/apigateway/latest/developerguide/apigateway-use-lambda-authorizer.html" rel="noopener ugc nofollow" target="_blank"> lambda授权器</a>，以确保每个连接的人都是系统的有效用户。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="a259" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">了解WebSocket身份验证</h1><p id="d7fd" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">你可能会想，“为什么这篇文章会成为一件事？我知道如何<a class="ae ky" href="https://levelup.gitconnected.com/build-auth-once-with-a-shared-lambda-authorizer-9936dc7e7897" rel="noopener ugc nofollow" target="_blank">给API添加lambda授权器</a>。”</p><p id="bda2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">虽然这可能是真的，但是您需要知道一些特定于WebSockets的问题。大多数连接到WebSockets的前端JavaScript库并不真正支持标准头文件。</p><p id="3f6c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">WebSocket API <a class="ae ky" href="https://html.spec.whatwg.org/multipage/web-sockets.html#network" rel="noopener ugc nofollow" target="_blank">在建立连接时只支持Sec-WebSocket-Protocol头</a>。像<a class="ae ky" href="https://www.postman.com" rel="noopener ugc nofollow" target="_blank"> Postman </a>这样的工具允许你在建立连接时传入其他头(这是好事！)，但当你开始在你的应用程序中编写前端代码时，你会立即停下来。</p><p id="4534" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">要解决这一问题，同时仍然为我们提供安全连接的方法，我们有两种选择:</p><ul class=""><li id="b512" class="ne nf it lb b lc ld lf lg li ng lm nh lq ni lu nj nk nl nm bi translated">在<code class="fe na nb nc nd b">Sec-WebSocket-Protocol</code>标题中提供分隔值</li><li id="dad7" class="ne nf it lb b lc nn lf no li np lm nq lq nr lu nj nk nl nm bi translated">在一个<code class="fe na nb nc nd b">access_token</code>查询字符串参数中提供身份验证令牌</li></ul><p id="c53c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这两种方法各有利弊，最终决定权在你。我们在AWS客户中部署的解决方案支持这两种方法。我推荐使用<a class="ae ky" href="https://faqs.ably.com/is-it-secure-to-send-the-access_token-as-part-of-the-websocket-url-query-params" rel="noopener ugc nofollow" target="_blank">查询字符串参数方法</a>，因为它简单明了，不会改变<code class="fe na nb nc nd b">Sec-WebSocket-Protocol</code>头的用途。</p><p id="734c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">因此，在建立新连接时，我们将传入一个名为<code class="fe na nb nc nd b">access_token</code>的查询字符串参数，其中包含我们的<a class="ae ky" href="https://jwt.io/" rel="noopener ugc nofollow" target="_blank"> jwt </a>，而不是标准的<code class="fe na nb nc nd b">Authorization</code>头。</p><p id="59a8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">关于WebSocket auth还有一点需要注意——您只需要在<em class="mz"> $connect </em>上进行身份验证。每个后续调用都使用同一个经过身份验证的连接。那就简单了！</p><p id="7932" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果您按照本系列的第一部分进行了操作，那么您已经在AWS帐户中部署了一个基本的WebSocket。它能够添加和删除连接，以及添加和删除对特定实体的订阅。今天，我们将在回购中使用一个分支来增强我们所拥有的。</p><p id="6fb7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果您不熟悉检查存储库中的非主分支，您可以在<a class="ae ky" href="https://code.visualstudio.com/" rel="noopener ugc nofollow" target="_blank"> VS Code </a>的终端中运行下面的命令来本地检查它。</p><pre class="kj kk kl km gt ns nd nt nu aw nv bi"><span id="c157" class="nw md it nd b gy nx ny l nz oa">git fetch git <br/>checkout part-two</span></pre><p id="5264" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">一旦本地有了源代码，就可以像以前一样进行部署:使用<code class="fe na nb nc nd b">sam deploy</code>命令。在运行之前，还需要对<code class="fe na nb nc nd b">samconfig.toml</code>文件进行一次更新。</p><p id="c79d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在我们的lambda authorizer中，我们验证所提供的jwt(也称为auth token)来自可信来源。为了做到这一点，我们验证jwt是用我们的<em class="mz">密钥</em>签名的。秘钥可以是您喜欢的任何东西，只是在生产场景中这样做时，请确保不要与其他人共享它。</p><p id="83cb" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我推荐使用<code class="fe na nb nc nd b">sam deploy --guided</code>命令来重新实例化这个栈的参数。完成后，立即部署！</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="1a82" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">我刚刚部署了什么？</h1><p id="b210" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">首先感谢大家的信任。其次，您部署了与上次相同的设置，并添加了一些新特性。</p><ul class=""><li id="e510" class="ne nf it lb b lc ld lf lg li ng lm nh lq ni lu nj nk nl nm bi translated">一个新的lambda授权器</li><li id="a6b7" class="ne nf it lb b lc nn lf no li np lm nq lq nr lu nj nk nl nm bi translated">更新了存储用户信息的<em class="mz"> $connect </em> lambda(稍后将详细介绍)</li><li id="7af3" class="ne nf it lb b lc nn lf no li np lm nq lq nr lu nj nk nl nm bi translated">使用您在部署时提供的秘密测试生成jwt的lambda</li><li id="0b4e" class="ne nf it lb b lc nn lf no li np lm nq lq nr lu nj nk nl nm bi translated"><a class="ae ky" href="https://aws.amazon.com/secrets-manager/" rel="noopener ugc nofollow" target="_blank"> Secrets Manager </a> secret安全存储jwt秘密</li></ul><p id="0e52" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">存储库中包含从<code class="fe na nb nc nd b">template.yaml</code>文件生成的完整基础设施图。如果你还没有把它作为一个惯例，我<a class="ae ky" rel="noopener ugc nofollow" target="_blank" href="/how-and-why-you-should-start-generating-your-serverless-infrastructure-diagrams-49cfd4568935">强烈推荐生成图</a>。他们不费吹灰之力就提供了巨大的价值。下面是部署到AWS中用于构建安全WebSocket API的全套资源。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ob"><img src="../Images/7d782d0578ae10496c2b1429442a8d10.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*3FQ3kQzxSg1pZwwd.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated"><em class="oc">安全WebSocket架构的基础架构图</em></p></figure></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="e308" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">连接到安全的WebSocket</h1><p id="3d29" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">部署好一切之后，是时候连接到我们的WebSocket了！首先，我们需要验证连接是否安全。因此，我们将像在本系列的第一部分中所做的那样尝试连接到它。</p><ol class=""><li id="e9f1" class="ne nf it lb b lc ld lf lg li ng lm nh lq ni lu od nk nl nm bi translated">打开<a class="ae ky" href="https://www.postman.com/downloads/" rel="noopener ugc nofollow" target="_blank">桌面应用</a></li><li id="2fd2" class="ne nf it lb b lc nn lf no li np lm nq lq nr lu od nk nl nm bi translated">选择新建-&gt; WebSocket请求</li><li id="5891" class="ne nf it lb b lc nn lf no li np lm nq lq nr lu od nk nl nm bi translated">在地址栏中输入SAM部署输出的路由(使用<code class="fe na nb nc nd b">WebsocketUri</code>输出值)</li><li id="b9b5" class="ne nf it lb b lc nn lf no li np lm nq lq nr lu od nk nl nm bi translated">点击<code class="fe na nb nc nd b">Headers</code>选项卡，添加值为<code class="fe na nb nc nd b">websocket</code>的<code class="fe na nb nc nd b">Sec-WebSocket-Protocol</code>标题</li><li id="f646" class="ne nf it lb b lc nn lf no li np lm nq lq nr lu od nk nl nm bi translated">点击<strong class="lb iu">连接</strong></li></ol><p id="39e6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果一切按计划进行，我们应该会收到一个<strong class="lb iu"> 401 </strong>，因为我们没有提供auth令牌。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi oe"><img src="../Images/6dc6c4007e98e524cfddad3e1d5b2285.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*bFQggxc6on55Un7g.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated"><em class="oc"> 401无认证令牌连接时的响应</em></p></figure><p id="fa94" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在让我们得到一个令牌并建立一个连接。</p><pre class="kj kk kl km gt ns nd nt nu aw nv bi"><span id="999d" class="nw md it nd b gy nx ny l nz oa">aws lambda invoke --function-name CreateTestJwt response.json</span></pre><ol class=""><li id="a087" class="ne nf it lb b lc ld lf lg li ng lm nh lq ni lu od nk nl nm bi translated">打开生成的<code class="fe na nb nc nd b">response.json</code>文件，复制<em class="mz"> authToken </em>属性中的值</li><li id="63e0" class="ne nf it lb b lc nn lf no li np lm nq lq nr lu od nk nl nm bi translated">在Postman中，向名为<code class="fe na nb nc nd b">access_token</code>的url添加一个查询字符串参数，并粘贴<em class="mz"> authToken </em>值</li><li id="1c3d" class="ne nf it lb b lc nn lf no li np lm nq lq nr lu od nk nl nm bi translated">点击<strong class="lb iu">连接</strong></li></ol><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi oe"><img src="../Images/13f76e385b9ab3359e29c358575e811a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*uv5DjNTsHGDkGBoO.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated"><em class="oc">连接成功！！</em></p></figure><p id="1aef" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在我们已经连接好了，我们可以向WebSocket发送和接收消息，而不需要额外的auth。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="2e82" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">我们现在能做什么？</h1><p id="a9fa" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">既然我们的WebSocket是安全的，我们就不必担心恶意用户会破坏我们的系统。所以我们能做的第一件事就是<em class="mz">放松</em>。</p><p id="767c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">第二，我们能够在特定于用户的级别上发送通知。Lambda授权器返回一个包含数据丰富的<code class="fe na nb nc nd b">context</code>对象，供您在代码中使用。在我们的示例授权器中，我们已经解码了jwt中的<code class="fe na nb nc nd b">userId</code>、<code class="fe na nb nc nd b">firstName</code>、<code class="fe na nb nc nd b">lastName</code>和<code class="fe na nb nc nd b">sub</code>，并将其传递给<em class="mz"> $connect </em>函数。</p><p id="0deb" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这些信息存储在Dynamo的连接记录中，因此我们可以用它向用户发送推送通知。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi of"><img src="../Images/aa4db0027c427ce2677759024d56b166.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*kBU9UxU93Fmdy5G0.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated"><em class="oc">来自lambda授权者的用户信息</em></p></figure><p id="4794" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">用户id存储为<code class="fe na nb nc nd b">GSI1PK</code>，因此我们可以查找用户的连接信息，并在需要时向他们发送推送消息。这个功能没有在本演练中实现，但是我们将在本系列的下一篇文章中对此进行扩展。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="cd03" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">下一步是什么？</h1><p id="fe65" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">在异步的<a class="ae ky" rel="noopener ugc nofollow" target="_blank" href="/and-the-2022-word-of-the-year-for-programmers-is-3605dc1bd698">年</a>，我们一头扎进了WebSocket池。该系列中即将发布的帖子是关于如何使用<a class="ae ky" href="https://www.asyncapi.com/" rel="noopener ugc nofollow" target="_blank">异步API规范</a>记录WebSocket API，添加基于用户的推送通知，以及从同步端点迁移到异步端点而不遗漏任何一个节拍。</p><p id="b1f7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">尝试本教程中的堆栈，熟悉组件，并进行一些更改！编码快乐！</p></div></div>    
</body>
</html>