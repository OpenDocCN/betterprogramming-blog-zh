<html>
<head>
<title>Swift — PAT or Generics?</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Swift — PAT还是Generics？</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/swift-pat-or-generics-f2f01d788de9?source=collection_archive---------2-----------------------#2019-06-21">https://betterprogramming.pub/swift-pat-or-generics-f2f01d788de9?source=collection_archive---------2-----------------------#2019-06-21</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><figure class="is it gp gr iu iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi ir"><img src="../Images/d2b52d09c442c1c9d1ffe7d47ae966fc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*aXlkAYSD5T48g6KWBS63cg.png"/></div></div></figure><div class=""/><div class=""><h2 id="6be0" class="pw-subtitle-paragraph kb jd je bd b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks dk translated">两者都做同样的工作，那么，用哪一个呢？</h2></div><h1 id="2dbc" class="kt ku je bd kv kw kx ky kz la lb lc ld kk le kl lf kn lg ko lh kq li kr lj lk bi translated">帕特？</h1><p id="2488" class="pw-post-body-paragraph ll lm je ln b lo lp kf lq lr ls ki lt lu lv lw lx ly lz ma mb mc md me mf mg im bi translated">在我们开始之前，让我解释一下这里的术语。PAT表示具有相关类型的协议。pat可以是通用的，这意味着您可以使用任何类型(<a class="ae mh" href="https://shawonashraf.github.io/blog/swift-associated-type-generic/" rel="noopener ugc nofollow" target="_blank">您可以参考我之前写的这篇关于Swift中的协议如何用作通用类型的文章</a>，添加类型约束等等。让我们看一个例子:</p><figure class="mi mj mk ml gt iv"><div class="bz fp l di"><div class="mm mn l"/></div></figure><p id="d561" class="pw-post-body-paragraph ll lm je ln b lo mo kf lq lr mp ki lt lu mq lw lx ly mr ma mb mc ms me mf mg im bi translated">这里我们有一个名为<code class="fe mt mu mv mw b">PlayerDescriptorProtocol</code>的协议，它有一个名为<code class="fe mt mu mv mw b">getSpeciality</code>的函数。符合此协议的类型必须提供此函数的实现，以描述播放器的特性。这在某种程度上是好的，但是我们应该问，什么类型的<code class="fe mt mu mv mw b">Player</code>应该符合这个协议？是足球运动员还是网球运动员？还是板球运动员？你可以这样想:不同类型的玩家会有不同的特长，不是吗？</p><p id="b723" class="pw-post-body-paragraph ll lm je ln b lo mo kf lq lr mp ki lt lu mq lw lx ly mr ma mb mc ms me mf mg im bi translated">所以让我们把这个弄得不那么模糊。我们将在这里添加一个关联类型。</p><figure class="mi mj mk ml gt iv"><div class="bz fp l di"><div class="mm mn l"/></div></figure><p id="3131" class="pw-post-body-paragraph ll lm je ln b lo mo kf lq lr mp ki lt lu mq lw lx ly mr ma mb mc ms me mf mg im bi translated">让我们检查一下符合的类型。在此之前，我们先做一个玩家类型。</p><figure class="mi mj mk ml gt iv"><div class="bz fp l di"><div class="mm mn l"/></div></figure><p id="0e4e" class="pw-post-body-paragraph ll lm je ln b lo mo kf lq lr mp ki lt lu mq lw lx ly mr ma mb mc ms me mf mg im bi translated">现在让我们为我们的协议获取一个符合类型。</p><figure class="mi mj mk ml gt iv"><div class="bz fp l di"><div class="mm mn l"/></div></figure><p id="b822" class="pw-post-body-paragraph ll lm je ln b lo mo kf lq lr mp ki lt lu mq lw lx ly mr ma mb mc ms me mf mg im bi translated">我们应该期待下面的输出— <code class="fe mt mu mv mw b"> All-Rounder</code></p><p id="2339" class="pw-post-body-paragraph ll lm je ln b lo mo kf lq lr mp ki lt lu mq lw lx ly mr ma mb mc ms me mf mg im bi translated">一切都好了，对吧？我的意思是，现在扔一个<code class="fe mt mu mv mw b">FootballPlayer</code>或者<code class="fe mt mu mv mw b">TennisPlayer</code>也没什么坏处。但是等一下，亲爱的华生，我们有事情要讨论。</p></div><div class="ab cl mx my hx mz" role="separator"><span class="na bw bk nb nc nd"/><span class="na bw bk nb nc nd"/><span class="na bw bk nb nc"/></div><div class="im in io ip iq"><h1 id="11b2" class="kt ku je bd kv kw ne ky kz la nf lc ld kk ng kl lf kn nh ko lh kq ni kr lj lk bi translated">这里会出什么问题呢？</h1><p id="6337" class="pw-post-body-paragraph ll lm je ln b lo lp kf lq lr ls ki lt lu lv lw lx ly lz ma mb mc md me mf mg im bi translated">实际上没有什么，除非你真的关心你的应用程序的低级性能。你认为编译器是如何计算出PAT使用什么类型的？当然，泛型是这样工作的，编译器会想办法解决，但问题是什么时候。</p><h2 id="267f" class="nj ku je bd kv nk nl dn kz nm nn dp ld lu no np lf ly nq nr lh mc ns nt lj nu bi translated">输入动态调度</h2><p id="953b" class="pw-post-body-paragraph ll lm je ln b lo lp kf lq lr ls ki lt lu lv lw lx ly lz ma mb mc md me mf mg im bi translated">对于pat，编译器必须在运行时计算出类型，这意味着它必须通过动态调度来完成。这个东西到底是什么？更简单地说，动态调度意味着将事情推迟到运行时再做决定，而不是在编译时将事情具体化。动态调度对于多态类型是必要的，因为编译器不知道在编译时使用哪种类型，所以它在运行时做出决定。</p><h2 id="e2c0" class="nj ku je bd kv nk nl dn kz nm nn dp ld lu no np lf ly nq nr lh mc ns nt lj nu bi translated">静态调度</h2><p id="6cd4" class="pw-post-body-paragraph ll lm je ln b lo lp kf lq lr ls ki lt lu lv lw lx ly lz ma mb mc md me mf mg im bi translated">静态调度正好相反。编译器已经知道该做什么，对正在使用的类型有一个清晰的概念，并且在编译时做所有的事情。</p><h2 id="3d14" class="nj ku je bd kv nk nl dn kz nm nn dp ld lu no np lf ly nq nr lh mc ns nt lj nu bi translated">静态调度更快吗？</h2><p id="0f2d" class="pw-post-body-paragraph ll lm je ln b lo lp kf lq lr ls ki lt lu lv lw lx ly lz ma mb mc md me mf mg im bi translated">相比较而言，是的。但是比动态调度好吗？你必须明白这两者是针对不同的任务的，你的编译器已经被设计成让它们非常有效地工作。如果你有机会从两者中选择一个呢？</p></div><div class="ab cl mx my hx mz" role="separator"><span class="na bw bk nb nc nd"/><span class="na bw bk nb nc nd"/><span class="na bw bk nb nc"/></div><div class="im in io ip iq"><h1 id="b400" class="kt ku je bd kv kw ne ky kz la nf lc ld kk ng kl lf kn nh ko lh kq ni kr lj lk bi translated">泛型和静态分派</h1><p id="19c7" class="pw-post-body-paragraph ll lm je ln b lo lp kf lq lr ls ki lt lu lv lw lx ly lz ma mb mc md me mf mg im bi translated">让我们使用泛型重写相同的代码。</p><figure class="mi mj mk ml gt iv"><div class="bz fp l di"><div class="mm mn l"/></div></figure><p id="4e65" class="pw-post-body-paragraph ll lm je ln b lo mo kf lq lr mp ki lt lu mq lw lx ly mr ma mb mc ms me mf mg im bi translated">是时候测试一下了！</p><pre class="mi mj mk ml gt nv mw nw nx aw ny bi"><span id="20f4" class="nj ku je mw b gy nz oa l ob oc">describePlayer(of: shaks)<br/><br/>// output : All-Rounder</span></pre></div><div class="ab cl mx my hx mz" role="separator"><span class="na bw bk nb nc nd"/><span class="na bw bk nb nc nd"/><span class="na bw bk nb nc"/></div><div class="im in io ip iq"><h1 id="55ff" class="kt ku je bd kv kw ne ky kz la nf lc ld kk ng kl lf kn nh ko lh kq ni kr lj lk bi translated">两人做着同样的工作…</h1><p id="3c49" class="pw-post-body-paragraph ll lm je ln b lo lp kf lq lr ls ki lt lu lv lw lx ly lz ma mb mc md me mf mg im bi translated">是的，他们做到了。那么，选择哪一个呢？动态还是静态？为了做出决定，我们必须考虑以下事实:</p><ol class=""><li id="eff3" class="od oe je ln b lo mo lr mp lu of ly og mc oh mg oi oj ok ol bi translated">虽然由于静态调度，泛型会更快，但与动态类型的pat相比，它也会占用更多内存。为什么？因为对于每种类型，编译器会将新函数压入堆栈，而对于PAT，由于动态调度，只会创建所需的函数。</li><li id="cc3f" class="od oe je ln b lo om lr on lu oo ly op mc oq mg oi oj ok ol bi translated">如果您不希望<code class="fe mt mu mv mw b">Player</code>类符合协议，并且还希望为每个描述符类保留单独的定义，该怎么办？你最终会写出更多的代码！</li></ol><p id="ee0d" class="pw-post-body-paragraph ll lm je ln b lo mo kf lq lr mp ki lt lu mq lw lx ly mr ma mb mc ms me mf mg im bi translated">在我看来，挑一个你需要的。如果你不介意牺牲一点内存来获得编译器的额外性能，那么就选择泛型，否则就选择PATs的便利性。这更像是在<code class="fe mt mu mv mw b">struct</code>和<code class="fe mt mu mv mw b">class</code>之间做出选择，因为没有绝对的赢家，所以选择一个能做好你的工作的。</p></div><div class="ab cl mx my hx mz" role="separator"><span class="na bw bk nb nc nd"/><span class="na bw bk nb nc nd"/><span class="na bw bk nb nc"/></div><div class="im in io ip iq"><h1 id="66f4" class="kt ku je bd kv kw ne ky kz la nf lc ld kk ng kl lf kn nh ko lh kq ni kr lj lk bi translated">闲聊够了</h1><p id="97f0" class="pw-post-body-paragraph ll lm je ln b lo lp kf lq lr ls ki lt lu lv lw lx ly lz ma mb mc md me mf mg im bi translated">让我们唱首歌凉快一下。</p><figure class="mi mj mk ml gt iv"><div class="bz fp l di"><div class="or mn l"/></div></figure><p id="eb9d" class="pw-post-body-paragraph ll lm je ln b lo mo kf lq lr mp ki lt lu mq lw lx ly mr ma mb mc ms me mf mg im bi translated">你也可以在我的博客上看到同样的文章。T8<em class="os">)</em></p></div></div>    
</body>
</html>