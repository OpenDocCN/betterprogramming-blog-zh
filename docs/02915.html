<html>
<head>
<title>JavaScript: What’s the Difference Between Normal and Arrow Functions?</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">JavaScript:普通函数和箭头函数有什么区别？</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/javascript-whats-the-difference-between-normal-and-arrow-functions-74c367324ae1?source=collection_archive---------11-----------------------#2020-01-08">https://betterprogramming.pub/javascript-whats-the-difference-between-normal-and-arrow-functions-74c367324ae1?source=collection_archive---------11-----------------------#2020-01-08</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="515d" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">提示:“这”是不一样的</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/36dc5a24be8552ce3548630d72740261.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*k3z_N6-C52AadRqP"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">由<a class="ae ky" href="https://unsplash.com/@emilep?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">émile Perron</a>在<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>拍摄的照片</p></figure><p id="a427" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">从ECMAScript 2015开始采用了箭头函数。它非常强大和简单。</p><p id="4517" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">许多基于ES5的项目采用这个特性来重构代码；然而，箭头函数和你所知道的普通函数不是一回事。那么，有什么不同呢？</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="0bc2" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">这个关键字</h1><p id="93f2" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">普通函数的<code class="fe mz na nb nc b">thisBinding</code>由调用函数的人决定。</p><pre class="kj kk kl km gt nd nc ne nf aw ng bi"><span id="2ca0" class="nh md it nc b gy ni nj l nk nl">var x = 10;<br/>var obj = { <br/>  sayHi,<br/>  x: 20<br/>};</span><span id="e9a0" class="nh md it nc b gy nm nj l nk nl">function sayHi() {<br/>  console.log(this.x);<br/>}</span><span id="7b8f" class="nh md it nc b gy nm nj l nk nl">sayHi(); // 10<br/>obj.sayHi(); // 20</span></pre><p id="0fde" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe mz na nb nc b">sayHi</code>给你一个不同的结果。这是因为普通函数的<code class="fe mz na nb nc b">this</code>被绑定到调用该函数的对象。</p><p id="e16b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">与普通函数相比，箭头函数的<code class="fe mz na nb nc b">this</code>总是绑定到内部函数周围的外部函数。</p><pre class="kj kk kl km gt nd nc ne nf aw ng bi"><span id="3bad" class="nh md it nc b gy ni nj l nk nl">var x = 10;<br/>var sayHi = () =&gt; {<br/>  console.log(this.x);<br/>}</span><span id="b4a9" class="nh md it nc b gy nm nj l nk nl">var obj = { <br/>  sayHi,<br/>  x: 20<br/>};</span><span id="eedf" class="nh md it nc b gy nm nj l nk nl">sayHi(); // 10<br/>obj.sayHi(); // 10</span></pre><p id="c40b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在这个例子中，<code class="fe mz na nb nc b">sayHi</code>是一个箭头函数。这是<code class="fe mz na nb nc b">obj</code>的属性。即使<code class="fe mz na nb nc b">obj</code>调用<code class="fe mz na nb nc b">sayHi</code>，它仍然打印<code class="fe mz na nb nc b">10</code>，因为函数的<code class="fe mz na nb nc b">this</code>总是引用外部环境的<code class="fe mz na nb nc b">this</code>。而全局<code class="fe mz na nb nc b">this</code>是<code class="fe mz na nb nc b">window</code>，所以指出<code class="fe mz na nb nc b">window.x</code>。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="d58d" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">争论</h1><p id="cfbe" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">一个普通的函数在被调用时有一个特殊的属性:参数。它包含许多有用的信息——传递给函数的参数、调用者等。当您不能保证将有多少个参数传递给函数时，这些参数非常有用。</p><pre class="kj kk kl km gt nd nc ne nf aw ng bi"><span id="4801" class="nh md it nc b gy ni nj l nk nl">function classroom() {<br/>  console.log(`We have ${arguments.length} student(s) today`);<br/>}</span><span id="4478" class="nh md it nc b gy nm nj l nk nl">// We have 3 student(s) today<br/>classroom('Jane', 'Mark', 'James');</span><span id="de0f" class="nh md it nc b gy nm nj l nk nl">// We have 1 student(s) today<br/>classroom('Miller');</span></pre><p id="a058" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">但是箭头函数没有arguments属性。</p><pre class="kj kk kl km gt nd nc ne nf aw ng bi"><span id="2d0e" class="nh md it nc b gy ni nj l nk nl">var classroom = () =&gt; {<br/>  console.log(`We have ${arguments.length} student(s) today`);<br/>}</span><span id="aba5" class="nh md it nc b gy nm nj l nk nl">classroom('Jane', 'Mark', 'James');<br/>// Uncaught ReferenceError:<br/>// arguments is not defined</span></pre><p id="5b23" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">计算arrow函数时，ECMAScript不会创建arguments属性。(参见<a class="ae ky" href="https://www.ecma-international.org/ecma-262/6.0/#sec-arrow-function-definitions-runtime-semantics-evaluation" rel="noopener ugc nofollow" target="_blank">规格文件</a>。)</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="4112" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">约束</h1><p id="8b8d" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated"><code class="fe mz na nb nc b">Function.prototype.bind</code>是一种可以用来改变函数<code class="fe mz na nb nc b">this</code>的方法。</p><pre class="kj kk kl km gt nd nc ne nf aw ng bi"><span id="0392" class="nh md it nc b gy ni nj l nk nl">var name = 'Jane';</span><span id="7831" class="nh md it nc b gy nm nj l nk nl">function sayName() {<br/>  console.log(this.name);<br/>}</span><span id="e244" class="nh md it nc b gy nm nj l nk nl">sayName(); // Jane<br/>sayName.bind({ name: 'James' })(); // James</span></pre><p id="2522" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe mz na nb nc b">sayName</code>根据分配的<code class="fe mz na nb nc b">this</code>打印<code class="fe mz na nb nc b">Jane</code>和<code class="fe mz na nb nc b"> James</code>。</p><p id="c18f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe mz na nb nc b">Function.prototype.bind</code>返回一个新函数，所以你应该再次运行它来得到结果。</p><pre class="kj kk kl km gt nd nc ne nf aw ng bi"><span id="9b04" class="nh md it nc b gy ni nj l nk nl">var name = 'Jane';</span><span id="e412" class="nh md it nc b gy nm nj l nk nl">var sayName = () =&gt; {<br/>  console.log(this.name);<br/>}</span><span id="050a" class="nh md it nc b gy nm nj l nk nl">sayName(); // Jane<br/>sayName.bind({ name: 'James' })(); // <strong class="nc iu">Jane</strong></span></pre><p id="df93" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">但是箭头函数对<code class="fe mz na nb nc b">Function.prototype.bind</code>不起作用，因为它没有本地<code class="fe mz na nb nc b">thisBinding</code>。所以它的<code class="fe mz na nb nc b">this</code>只是看着外部环境的<code class="fe mz na nb nc b">this</code>。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="2254" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">构造器</h1><p id="1250" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">当一个函数被调用时，这个函数是由一个内部核心方法用<code class="fe mz na nb nc b">kind</code>参数创建的，这个参数指的是它是一个什么样的函数。<code class="fe mz na nb nc b">kind</code>参数为<code class="fe mz na nb nc b">Normal</code>或<code class="fe mz na nb nc b">Arrow</code>。当一个箭头函数被调用时，<code class="fe mz na nb nc b">kind</code>是<code class="fe mz na nb nc b">Arrow</code>，所以它被归类为一个<em class="nn">非构造函数</em> <em class="nn">。</em></p><pre class="kj kk kl km gt nd nc ne nf aw ng bi"><span id="779e" class="nh md it nc b gy ni nj l nk nl">function constructable() {}<br/>var nonConstructable = () =&gt; {};</span><span id="cc29" class="nh md it nc b gy nm nj l nk nl">new constructable(); // it works<br/>new nonConstructable();<br/>    ~~~~~~~~~~~~~~~~<br/>// Uncaught TypeError<br/>// nonConstructable is not a constructor</span></pre></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="64ed" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">结论</h1><p id="35ab" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">箭头功能是一个方便的功能，并且更时尚，但是在普通功能和箭头功能之间存在差异。</p><p id="8b16" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我想告诉你，一个箭头函数并不总是你的最佳选择。你应该为每种情况选择合适的函数。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="3c31" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">资源</h1><ul class=""><li id="aef7" class="no np it lb b lc mu lf mv li nq lm nr lq ns lu nt nu nv nw bi translated"><a class="ae ky" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Functions/Arrow_functions" rel="noopener ugc nofollow" target="_blank">箭头函数表达式— MDN </a></li><li id="b910" class="no np it lb b lc nx lf ny li nz lm oa lq ob lu nt nu nv nw bi translated"><a class="ae ky" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Functions/arguments" rel="noopener ugc nofollow" target="_blank">arguments对象— MDN </a></li><li id="73ba" class="no np it lb b lc nx lf ny li nz lm oa lq ob lu nt nu nv nw bi translated"><a class="ae ky" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_objects/Function/bind" rel="noopener ugc nofollow" target="_blank">function . prototype . bind—MDN</a></li><li id="6fb3" class="no np it lb b lc nx lf ny li nz lm oa lq ob lu nt nu nv nw bi translated"><a class="ae ky" href="https://www.ecma-international.org/ecma-262/6.0/#sec-arrow-function-definitions" rel="noopener ugc nofollow" target="_blank">箭头功能— ECMAScript规范</a></li><li id="6b06" class="no np it lb b lc nx lf ny li nz lm oa lq ob lu nt nu nv nw bi translated"><a class="ae ky" href="https://www.ecma-international.org/ecma-262/6.0/#sec-function-environment-records" rel="noopener ugc nofollow" target="_blank">函数环境记录— ECMAScript规范</a></li><li id="566b" class="no np it lb b lc nx lf ny li nz lm oa lq ob lu nt nu nv nw bi translated"><a class="ae ky" href="https://www.ecma-international.org/ecma-262/6.0/#sec-arrow-function-definitions-runtime-semantics-evaluation" rel="noopener ugc nofollow" target="_blank">箭头函数定义和运行时语义评估</a></li><li id="3885" class="no np it lb b lc nx lf ny li nz lm oa lq ob lu nt nu nv nw bi translated"><a class="ae ky" href="https://www.ecma-international.org/ecma-262/6.0/#sec-functioncreate" rel="noopener ugc nofollow" target="_blank">函数创建— ECMAScript规范</a></li></ul></div></div>    
</body>
</html>