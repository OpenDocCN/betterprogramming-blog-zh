<html>
<head>
<title>Functional Programming: How to Send and Validate API Requests in TypeScript</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">函数式编程:如何在TypeScript中发送和验证API请求</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/functional-programming-how-to-send-and-validate-api-requests-in-typescript-5954e99f9418?source=collection_archive---------13-----------------------#2020-04-20">https://betterprogramming.pub/functional-programming-how-to-send-and-validate-api-requests-in-typescript-5954e99f9418?source=collection_archive---------13-----------------------#2020-04-20</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="ac01" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">以函数式编程风格发送和验证请求</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/e8f268b1786a75963de5afc710d79792.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*pyGM9COkHPScZOcvNKoukA.jpeg"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">在<a class="ae kv" href="https://unsplash.com/s/photos/programming?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上由<a class="ae kv" href="https://unsplash.com/@m47h4r?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Mazhar Zandsalimi </a>拍摄的照片</p></figure><p id="505d" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">最近，我开始深入研究函数式编程。我开始学习<a class="ae kv" href="https://www.haskell.org/" rel="noopener ugc nofollow" target="_blank"> Haskell </a>，但是过了一段时间，我就被那些新概念和抽象概念淹没了。所以我决定先用一种我非常熟悉的编程语言来熟悉这些概念:JavaScript。</p><p id="a33d" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这就是为什么我在GitHub上启动了一个<a class="ae kv" href="https://github.com/Cedomic/functional-js" rel="noopener ugc nofollow" target="_blank"> functional-js </a> repo。你也可以在本教程的中找到<a class="ae kv" href="https://github.com/Cedomic/functional-js/blob/master/src/real-life-example.ts" rel="noopener ugc nofollow" target="_blank">代码。</a></p></div><div class="ab cl ls lt hu lu" role="separator"><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx"/></div><div class="ij ik il im in"><h1 id="353c" class="lz ma iq bd mb mc md me mf mg mh mi mj jw mk jx ml jz mm ka mn kc mo kd mp mq bi translated">我们将做什么</h1><p id="7748" class="pw-post-body-paragraph kw kx iq ky b kz mr jr lb lc ms ju le lf mt lh li lj mu ll lm ln mv lp lq lr ij bi translated">我们将采用一个基本函数，它向https://api.exchangeratesapi.io/latest?base={CountryCode}.发送一个GET请求</p><p id="46a0" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">代码如下:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mw mx l"/></div></figure><p id="e9c0" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">通常我们可以使用这个函数，并对它感到满意。也许如果我们是有远见的开发者，我们会发现可能的错误。</p><p id="5d51" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">但是我们将以一种更实用的方式重新编写，这种方式还可以验证响应并处理可能发生的所有错误。所有这些都可以通过几行代码实现:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mw mx l"/></div></figure><p id="d612" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">如果你还不知道上面发生了什么，不要担心！让我试着给你解释一下。</p></div><div class="ab cl ls lt hu lu" role="separator"><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx"/></div><div class="ij ik il im in"><h1 id="84b4" class="lz ma iq bd mb mc md me mf mg mh mi mj jw mk jx ml jz mm ka mn kc mo kd mp mq bi translated">让我们发挥作用，发挥作用！</h1><p id="df0a" class="pw-post-body-paragraph kw kx iq ky b kz mr jr lb lc ms ju le lf mt lh li lj mu ll lm ln mv lp lq lr ij bi translated">我们将使用一个名为<a class="ae kv" href="https://github.com/gcanti/fp-ts" rel="noopener ugc nofollow" target="_blank"> fp-ts </a>的出色的函数式编程库。引用GitHub上的自述文件:</p><blockquote class="my mz na"><p id="738b" class="kw kx nb ky b kz la jr lb lc ld ju le nc lg lh li nd lk ll lm ne lo lp lq lr ij bi translated">“fp-ts旨在允许开发者使用大多数函数式语言中都有的流行模式和抽象。为此，它包括最流行的数据类型、类型类和抽象，如Option、要么、IO、Task、Functor、Applicative、Monad，以使用户能够编写基于更高阶抽象的纯FP应用和库。”</p></blockquote><p id="a6bb" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们不会真正涵盖这些抽象是什么，但你会发现函子，应用函子，单子等大量的教程。，在线。</p></div><div class="ab cl ls lt hu lu" role="separator"><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx"/></div><div class="ij ik il im in"><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nf"><img src="../Images/cf2f4506291fae9c04ea12e87c4c966b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*vFZcXbRf9_OB-cjDs7hkZA.png"/></div></div></figure><h1 id="3d52" class="lz ma iq bd mb mc ng me mf mg nh mi mj jw ni jx ml jz nj ka mn kc nk kd mp mq bi translated">函子、适用函子和单子</h1><p id="b196" class="pw-post-body-paragraph kw kx iq ky b kz mr jr lb lc ms ju le lf mt lh li lj mu ll lm ln mv lp lq lr ij bi translated">注意:如果你对函子和单子有一点了解，你可以跳过这一节，继续下一节。否则，你可以阅读这一部分来了解我们正在谈论的内容。或者你可以在网上阅读其他教程，然后再回到这个话题。</p><p id="4a9d" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">为了这个教程，我会给你一个什么是函子，适用函子，单子的简单解释。</p><p id="d5c9" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">下面的解释在技术上并不正确，但它让你知道它们是什么和它们做什么，所以你可以理解发生了什么，即使你从未听说过它们。</p><p id="a2ff" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">对于本教程，您可以将它们视为存储值的对象。该值可以是任何值(数组、对象、字符串、数字、函数等。).它们还定义了一些方法，因此您可以使用存储的值。</p><p id="e010" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">为了让某个东西成为函子，它必须实现一个<code class="fe nl nm nn no b">.map()</code>方法。这种<code class="fe nl nm nn no b">.map()</code>方法的工作原理类似于<code class="fe nl nm nn no b">Array.prototype.map()</code>。它采用一元函数(接受单个参数的函数)并将它应用于存储在对象内部的值。</p><p id="f8b4" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">适用函子是普通函子的扩展，所以它也有<code class="fe nl nm nn no b">.map()</code>方法。除此之外，它还定义了一个<code class="fe nl nm nn no b">.of()</code>方法，该方法只获取一个值并将其存储在对象中。</p><p id="6c80" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">除了<code class="fe nl nm nn no b">.of()</code>，它还有一个<code class="fe nl nm nn no b">.ap()</code>的方法。<code class="fe nl nm nn no b">.ap()</code>取另一个函子(或一个适用的函子或单子；它只需要定义一个<code class="fe nl nm nn no b">.map()</code>方法)作为参数，并将其中的内容(通常是一个函数)应用到我们传递给<code class="fe nl nm nn no b">.ap()</code>的仿函数中。</p><p id="5e6c" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">当我们在一个仿函数中有一个函数，并且想要用一个也在仿函数中的值来调用这个函数时，我们使用<code class="fe nl nm nn no b">.ap()</code>。</p><p id="b266" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">单子是普通函子和适用函子的另一种扩展，所以它也有<code class="fe nl nm nn no b">.map()</code>、<code class="fe nl nm nn no b">.of()</code>、&amp;、<strong class="ky ir">、<code class="fe nl nm nn no b">.ap()</code>、<strong class="ky ir">、</strong>的方法。它还有两个附加方法:<code class="fe nl nm nn no b">.join()</code> &amp; <code class="fe nl nm nn no b">.chain()</code>。</strong></p><p id="6e5a" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><code class="fe nl nm nn no b">.join()</code>用于函子内部有函子的情况。它展平了函子，所以我们只有函子内部的值，而没有函子内部的值。</p><p id="e3f9" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><code class="fe nl nm nn no b">.chain()</code> <strong class="ky ir"> </strong>是对<code class="fe nl nm nn no b">.map(x =&gt; Functor(x)).join()</code>的抽象。它结合了以下操作:将返回另一个仿函数的函数映射到一个仿函数上，然后连接或展平该仿函数以仅包含该值，而不包含另一个包含该值的仿函数。</p><p id="e364" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这不是一个正确的定义，但它给你一个概念，什么函子，适用函子，单子等。，是。对于本教程，您可以简单地将它们视为必须定义了某些方法的对象。可以说，他们必须遵守一些规则或法律。(顺便说一句，它们确实必须遵守一些定律，才能被称为函子、适用函子或单子)。如果你对这些和更多代数结构的确切定义感兴趣，你可以查阅<a class="ae kv" href="https://github.com/fantasyland/fantasy-land" rel="noopener ugc nofollow" target="_blank">幻想世界规范</a>。你也可以阅读大量的单子教程。</p></div><div class="ab cl ls lt hu lu" role="separator"><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx"/></div><div class="ij ik il im in"><h1 id="ccd9" class="lz ma iq bd mb mc md me mf mg mh mi mj jw mk jx ml jz mm ka mn kc mo kd mp mq bi translated">现在说点好的</h1><p id="b69f" class="pw-post-body-paragraph kw kx iq ky b kz mr jr lb lc ms ju le lf mt lh li lj mu ll lm ln mv lp lq lr ij bi translated">我们已经定义了从API获取数据的函数；在这种情况下，我们希望获得所选基础货币的汇率。</p><p id="7b78" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">让我们定义一个函数来验证我们的响应:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mw mx l"/></div></figure><p id="44d3" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">该函数接收一个国家代码，然后检查基础货币是否与该国家代码匹配。</p><p id="e3c3" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">你可能已经看到这是一个curried函数。我们传入一个国家代码，并返回一个将响应作为参数的函数(国家代码在函数的闭包中仍然可用)。</p><p id="834f" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这个函数返回一个类型为<code class="fe nl nm nn no b">either.Either&lt;Error, ExchangeRates&gt;</code>的东西。</p><p id="fdc9" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">都是可以存储两个值的单子，一个在左边，一个在右边。在左边，你通常存储任何可能发生的错误信息。在右边，您存储了一次成功操作的值。<br/><code class="fe nl nm nn no b">Either</code>单子对于错误处理非常有用。</p><p id="5fd4" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">正如你在上面的函数中看到的，当验证成功时我们执行<code class="fe nl nm nn no b">either.right</code>，当验证失败时执行<code class="fe nl nm nn no b">either.left</code>。</p><p id="a9bf" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">现在让我们将我们的功能付诸行动吧！</p><p id="42b4" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们将通过管道把我们的函数和fp-ts的<code class="fe nl nm nn no b">pipe()</code>函数连接在一起。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mw mx l"/></div></figure><p id="604e" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">首先，我们将传入我们的<code class="fe nl nm nn no b">fetchExchangeRatesForCountry()</code>函数，它返回一个承诺。</p><p id="f979" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">为了让我们的普通函数与<code class="fe nl nm nn no b">pipe()</code>函数一起工作，我们必须将它包装在<code class="fe nl nm nn no b">taskEither.tryCatch()</code>中，它接受一个返回类型<code class="fe nl nm nn no b">Lazy&lt;Promise&lt;any&gt;&gt;</code>的函数和一个处理任何潜在错误的函数。</p><p id="0312" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在我们的例子中，我们将任何潜在的错误包装在一个<code class="fe nl nm nn no b">Either</code>单子中。<br/> <code class="fe nl nm nn no b">taskEither.tryCatch()</code> <strong class="ky ir"> </strong>返回一个<code class="fe nl nm nn no b">TaskEither</code>单子，这个单子可以处理承诺之类的事情。名字中的“要么”意味着我们也有左侧和右侧来存储我们的值和可能的错误消息。</p><p id="67db" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在我们的<code class="fe nl nm nn no b">pipe()</code>函数的下一步中，我们使用<code class="fe nl nm nn no b">.chain()</code>方法，这听起来应该很熟悉。</p><p id="ecc7" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><code class="fe nl nm nn no b">.chain()</code>接受一个返回另一个仿函数的函数，将其应用于该仿函数内部的值，然后展平该仿函数。这里我们使用fp-ts中的<code class="fe nl nm nn no b">flow()</code>函数。<code class="fe nl nm nn no b">flow()</code>是从左到右进行函数合成的函数。这里我们编写<code class="fe nl nm nn no b">validateExchangeRates(countryCode)</code>，它返回<strong class="ky ir"> </strong> <code class="fe nl nm nn no b">either.Either&lt;Error, ExchangeRates&gt;</code>和<code class="fe nl nm nn no b">taskEither.fromEither()</code>。</p><p id="cfb8" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">也可以这样写:<code class="fe nl nm nn no b">taskEither.fromEither(validateExchangeRates(countryCode))</code>。</p><p id="dc5c" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们的<code class="fe nl nm nn no b">.chain()</code> <strong class="ky ir"> </strong>然后返回另一个<code class="fe nl nm nn no b">TaskEither</code>单子。这一次，它或者包含响应，或者包含来自验证的错误，分别位于右侧或左侧。</p><p id="57d9" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">现在我们可以调用我们的<code class="fe nl nm nn no b">getExchangeRatesForCountry()</code>函数:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mw mx l"/></div></figure><p id="141d" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">如您所见，它以一个<code class="fe nl nm nn no b">TaskEither</code>单子的形式返回API的响应。我们的结果在单子的右边。</p><p id="0d27" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">失败的响应如下所示:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mw mx l"/></div></figure><p id="fd27" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这里我们将错误很好地包装在我们的<code class="fe nl nm nn no b">TaskEither</code>单子中，但是现在它在左边。</p><p id="6960" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">以下是教程中的完整代码:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mw mx l"/></div></figure><p id="4a08" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">对于一个简单的API请求来说，我们今天所做的似乎有点太复杂了，我不得不同意。如果您只想发送一个请求并返回任何返回的内容，而不太关心数据或错误，那么保持简单可能更好。但是，如果您想验证数据、处理错误，并可能将它与其他函数和操作结合起来，函数式方法使这变得更容易和更可测试。</p><p id="8613" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我喜欢函数式方法的一点是，我们将传递的数据包装在单子中。通过这种方式，我们可以完全专注于数据流，而不必编写大量if-else语句来处理任何丢失的数据，如果处理不当，这些语句可能会引发错误。</p><p id="c10c" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">通过将我们的值包装在单子中，我们还可以确保在抛出错误时不会继续我们的管道。我们继续管道，但是我们不映射左边的任何值——记住，我们想要的值总是在右边；左边是错误。</p></div><div class="ab cl ls lt hu lu" role="separator"><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx"/></div><div class="ij ik il im in"><h1 id="d3a9" class="lz ma iq bd mb mc md me mf mg mh mi mj jw mk jx ml jz mm ka mn kc mo kd mp mq bi translated">看得更远</h1><p id="4c84" class="pw-post-body-paragraph kw kx iq ky b kz mr jr lb lc ms ju le lf mt lh li lj mu ll lm ln mv lp lq lr ij bi translated">我才刚刚开始真正进入函数式编程，当然甚至还没有触及表面，但我很兴奋地看到函数式编程还能做些什么。</p><p id="1d64" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">您可以将我们今天所做的做得更进一步，构建一个接受验证器函数和所有请求参数的函数。现在您有了一个函数，它可以向您想要的任何URL发送请求，验证返回的任何内容，还可以处理任何错误。</p><p id="94ff" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">所有这些都在短短的五行中。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mw mx l"/></div></figure><p id="208e" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">漂亮！</p><p id="ac91" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">非常感谢您的阅读！</p></div><div class="ab cl ls lt hu lu" role="separator"><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx"/></div><div class="ij ik il im in"><h1 id="5571" class="lz ma iq bd mb mc md me mf mg mh mi mj jw mk jx ml jz mm ka mn kc mo kd mp mq bi translated">参考</h1><ul class=""><li id="586e" class="np nq iq ky b kz mr lc ms lf nr lj ns ln nt lr nu nv nw nx bi translated">功能性JS—<a class="ae kv" href="https://github.com/Cedomic/functional-js" rel="noopener ugc nofollow" target="_blank">https://github.com/Cedomic/functional-js</a></li><li id="6698" class="np nq iq ky b kz ny lc nz lf oa lj ob ln oc lr nu nv nw nx bi translated">code—<a class="ae kv" href="https://github.com/Cedomic/functional-js/blob/master/src/real-life-example.ts" rel="noopener ugc nofollow" target="_blank">https://github . com/Cedomic/functional-js/blob/master/src/real-life-example . ts</a></li><li id="26a3" class="np nq iq ky b kz ny lc nz lf oa lj ob ln oc lr nu nv nw nx bi translated">幻想世界规格—【https://github.com/fantasyland/fantasy-land T4】</li><li id="4ce0" class="np nq iq ky b kz ny lc nz lf oa lj ob ln oc lr nu nv nw nx bi translated">FP-ts—<a class="ae kv" href="https://github.com/gcanti/fp-ts" rel="noopener ugc nofollow" target="_blank">https://github.com/gcanti/fp-ts</a></li></ul></div></div>    
</body>
</html>