<html>
<head>
<title>RxJS Best Practices</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">RxJS最佳实践</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/rxjs-best-practices-7f559d811514?source=collection_archive---------0-----------------------#2020-03-28">https://betterprogramming.pub/rxjs-best-practices-7f559d811514?source=collection_archive---------0-----------------------#2020-03-28</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="e114" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">我每天在代码中使用的一系列实践</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/2c8f410db0da2685b34b7db6b2ea4ef9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*CetCSD0NRUV3nj7dx8hc8A.png"/></div></div></figure><p id="5a6a" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">RxJS是JavaScript中最流行的函数式反应式编程(FRP)框架。这意味着很多人每天都在他们的项目中使用RxJS。大多数开发人员都知道常见的干净代码实践，但是RxJS最佳实践呢？你知道玻璃钢的注意事项吗？你在代码中应用它们了吗？</p><p id="b179" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">本教程将重点介绍我在编写代码时日常使用的几个最佳实践，并附有实际例子。我们将讨论以下几点:</p><p id="6341" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">我们将讨论这些技术:</p><p id="0ba7" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">1.避免subscribe函数中的逻辑</p><p id="8f98" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">2.使用主题来强制完成</p><p id="016c" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">3.<strong class="kw iu"> </strong>避免重复的逻辑</p><p id="1e1b" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">4.避免嵌套—使用链代替</p><p id="74d6" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">5.共享以避免流重复</p><p id="7969" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">6.不要暴露主题</p><p id="0cc3" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">7.使用大理石图进行测试</p><p id="9e90" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">事不宜迟，我们开始吧。</p><p id="a624" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">大家好，欢迎来到多泰。在这个视频中，我们将讨论RxJS，它是JavaScript中最流行的函数式反应式编程框架。更具体地说，我们将讨论RxJS最佳实践。我们将讨论函数式反应式编程的注意事项。所以，事不宜迟，让我们开始吧</p></div><div class="ab cl lq lr hx ls" role="separator"><span class="lt bw bk lu lv lw"/><span class="lt bw bk lu lv lw"/><span class="lt bw bk lu lv"/></div><div class="im in io ip iq"><h1 id="fc26" class="lx ly it bd lz ma mb mc md me mf mg mh jz mi ka mj kc mk kd ml kf mm kg mn mo bi translated">1.避免Subscribe函数中的逻辑</h1><p id="c4c1" class="pw-post-body-paragraph ku kv it kw b kx mp ju kz la mq jx lc ld mr lf lg lh ms lj lk ll mt ln lo lp im bi translated">对于你们中的一些人来说，这种说法似乎很明显，但是对于RxJS初学者来说，这是一个常见的陷阱。在你学会如何<em class="mu">功能性+反应性地思考之前，</em>你可能会尝试这样做:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mv mw l"/></div><p class="mx my gj gh gi mz na bd b be z dk translated">订阅功能中的逻辑</p></figure><p id="7c19" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">我们的<code class="fe nb nc nd ne b">pokemon$</code> Observable发出<code class="fe nb nc nd ne b">Pokemon</code>对象，并且，以一种<em class="mu">非常</em> <em class="mu">非反应的方式，</em>我们订阅它是为了访问这些对象并执行一些动作，比如如果<code class="fe nb nc nd ne b">Pokemon</code>类型是<code class="fe nb nc nd ne b">Water</code>就提前返回，调用<code class="fe nb nc nd ne b">getStats()</code>函数，记录该函数返回的统计数据，最后，将数据保存到<code class="fe nb nc nd ne b">Pokedex</code>。我们所有的逻辑都在<code class="fe nb nc nd ne b">subscribe</code>函数中。</p><p id="c349" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">然而，这段代码不正是我们在传统的<em class="mu">命令式</em>编程范例中看到的吗？既然RxJS是一个函数式反应式编程库，我们就要告别我们传统的思维方式，开始函数式反应式的思考(Streams！纯函数！).</p><p id="964f" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">那么，我们如何使我们的代码功能反应？通过使用RxJS为我们提供的可管道化操作符:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mv mw l"/></div><p class="mx my gj gh gi mz na bd b be z dk translated">使用管道运算符</p></figure><p id="45cd" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">瞧，我们的代码通过一些简单的改变，已经从命令式变成了功能反应式。它甚至看起来更干净，不是吗？</p><p id="3c6c" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated"><strong class="kw iu">注意:</strong>我完全知道一部分逻辑(<code class="fe nb nc nd ne b">saveToPokedex()</code> <em class="mu"> </em>函数)仍然保留在<code class="fe nb nc nd ne b">subscribe</code>中。我发现将最后一部分逻辑放在<code class="fe nb nc nd ne b">subscribe</code>中让我更容易阅读代码。你们都可以自由选择是否让<code class="fe nb nc nd ne b">subscribe</code>完全空着。</p><p id="a761" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">我们使用的操作符非常简单:<code class="fe nb nc nd ne b"><a class="ae nf" href="https://www.learnrxjs.io/learn-rxjs/operators/filtering/filter" rel="noopener ugc nofollow" target="_blank">filter</a></code>和<code class="fe nb nc nd ne b"><a class="ae nf" href="https://rxjs-dev.firebaseapp.com/api/operators/map" rel="noopener ugc nofollow" target="_blank">map</a></code>的工作方式与它们同名的数组操作符完全相同，<code class="fe nb nc nd ne b"><a class="ae nf" href="https://rxjs-dev.firebaseapp.com/api/operators/tap" rel="noopener ugc nofollow" target="_blank">tap</a></code>用于执行<em class="mu">副作用</em>(定义如下)。</p><blockquote class="ng nh ni"><p id="c574" class="ku kv mu kw b kx ky ju kz la lb jx lc nj le lf lg nk li lj lk nl lm ln lo lp im bi translated">“如果一个操作、函数或表达式修改了其本地环境之外的某个状态变量值，则称其具有<em class="it">副作用</em>—通过<a class="ae nf" href="https://en.wikipedia.org/wiki/Side_effect_(computer_science)" rel="noopener ugc nofollow" target="_blank">维基百科</a></p></blockquote></div><div class="ab cl lq lr hx ls" role="separator"><span class="lt bw bk lu lv lw"/><span class="lt bw bk lu lv lw"/><span class="lt bw bk lu lv"/></div><div class="im in io ip iq"><h1 id="1661" class="lx ly it bd lz ma mb mc md me mf mg mh jz mi ka mj kc mk kd ml kf mm kg mn mo bi translated">2.使用主题来强制完成</h1><p id="058c" class="pw-post-body-paragraph ku kv it kw b kx mp ju kz la mq jx lc ld mr lf lg lh ms lj lk ll mt ln lo lp im bi translated">当使用Observables时，内存泄漏是一个真正的危险。为什么？因为，一旦我们订阅了一个可观测值，它就会无限期地不断发出值<strong class="kw iu"> </strong>，直到满足以下两个条件之一:</p><ol class=""><li id="05c7" class="nm nn it kw b kx ky la lb ld no lh np ll nq lp nr ns nt nu bi translated">我们手动取消订阅可观察的</li><li id="c2a0" class="nm nn it kw b kx nv la nw ld nx lh ny ll nz lp nr ns nt nu bi translated">它完成了</li></ol><p id="626f" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">看起来很简单，对吧？让我们来看看如何取消订阅可观察的:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mv mw l"/></div><p class="mx my gj gh gi mz na bd b be z dk translated">手动取消订阅可观察的</p></figure><p id="1d5b" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">正如你在上面的例子中看到的，我们必须将我们的<code class="fe nb nc nd ne b">pokemon$</code>可观察对象的订阅<strong class="kw iu"> </strong>存储在一个变量中，然后在那个存储的订阅上手动调用<code class="fe nb nc nd ne b">unsubscribe</code>。目前看来并不太难。</p><p id="6121" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">但是，如果我们有更多需要订阅的可观测量，会发生什么呢？</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mv mw l"/></div><p class="mx my gj gh gi mz na bd b be z dk translated">手动取消订阅几个观察项目</p></figure><p id="cd71" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">如您所见，随着我们向代码中添加更多的可观察对象，我们需要跟踪越来越多的订阅，我们的代码开始看起来有点拥挤。难道没有更好的方法让我们告诉我们的可观测量停止发射值吗？幸运的是，我们有，而且非常非常简单:</p><p id="bd21" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">我们可以使用Subject和<code class="fe nb nc nd ne b">takeUntil()</code>操作符来强制完成我们的观察。怎么会？这里有一个例子:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mv mw l"/></div><p class="mx my gj gh gi mz na bd b be z dk translated">使用“takeUntil”完成可观测量</p></figure><p id="5168" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">我们来了解一下上面是怎么回事。我们已经创建了一个<code class="fe nb nc nd ne b">stop$</code>主题，并用<code class="fe nb nc nd ne b">takeUntil</code>操作符将我们的三个可观察对象管道化。这个操作符用于告诉一个可观察对象，一旦一个不同的通知可观察对象发出，就停止发出值。这意味着当<code class="fe nb nc nd ne b">stop$</code>主体发射时，我们的三个可观察对象将停止发射值。</p><p id="1c10" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">那么我们如何让我们的<code class="fe nb nc nd ne b">stop$</code>主体发出呢？通过调用它的<code class="fe nb nc nd ne b">next()</code>函数，这正是我们在<code class="fe nb nc nd ne b">stopObservables()</code>函数中所做的。所以，每当我们调用我们的<code class="fe nb nc nd ne b">stopObservables()</code>函数，我们的<code class="fe nb nc nd ne b">stop$</code> Subject就会发出，我们所有的可观测性就会自动完成。听起来很酷，不是吗？</p><p id="3b8a" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">不再需要存储任何订阅和取消订阅？向<code class="fe nb nc nd ne b">takeUntil</code>操作员致敬！</p></div><div class="ab cl lq lr hx ls" role="separator"><span class="lt bw bk lu lv lw"/><span class="lt bw bk lu lv lw"/><span class="lt bw bk lu lv"/></div><div class="im in io ip iq"><h1 id="795d" class="lx ly it bd lz ma mb mc md me mf mg mh jz mi ka mj kc mk kd ml kf mm kg mn mo bi translated">3.避免重复的逻辑</h1><p id="0d4c" class="pw-post-body-paragraph ku kv it kw b kx mp ju kz la mq jx lc ld mr lf lg lh ms lj lk ll mt ln lo lp im bi translated">我们都知道重复代码是一个不好的信号，应该避免。(如果你不知道，我建议你去读完这本再回来。)您可能想知道哪些场景会导致重复的RxJS逻辑。让我们看看下面的例子:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mv mw l"/></div><p class="mx my gj gh gi mz na bd b be z dk translated">重复的“takeUntil”逻辑</p></figure><p id="617b" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">如您所见，我们有一个<code class="fe nb nc nd ne b">number$</code>可观察值，我们订阅了两次:一次用<code class="fe nb nc nd ne b">reduce()</code> <em class="mu"> </em>计算总值，一次用<code class="fe nb nc nd ne b">filter()</code>去掉所有奇数。</p><p id="844c" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">然而，我们的<code class="fe nb nc nd ne b">number$</code>可观测，尽管它的名字，并不仅仅包含数字。如您所见，它还包含一些危险的falsy值，这会导致我们的代码失败。这就是为什么我们需要过滤掉这些虚假的值，这就是我们正在用<code class="fe nb nc nd ne b">filter(Boolean)</code>做的事情。</p><p id="7cc1" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated"><em class="mu">注意:当使用</em> <code class="fe nb nc nd ne b"><em class="mu">filter(Boolean)</em></code> <em class="mu">时我们失去了类型推断。我们可以通过显式键入</em> <code class="fe nb nc nd ne b"><em class="mu">filter</em></code> <em class="mu">来避免这种情况，像这样:</em> <code class="fe nb nc nd ne b"><em class="mu">filter&lt;number&gt;(Boolean)</em></code>。</p><p id="d16d" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">看起来很简单，但是…</p><p id="25ff" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">注意我们是如何在两个可观测量中复制了<code class="fe nb nc nd ne b">filter(Boolean)</code>逻辑的？只要我们的代码允许，就应该避免这种情况。怎么会？通过将此逻辑附加到源可观察对象，如下所示:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mv mw l"/></div><p class="mx my gj gh gi mz na bd b be z dk translated">将takeUntil逻辑移动到源可观察对象</p></figure><p id="2a99" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">更少的代码+没有重复=更干净的代码。厉害！</p></div><div class="ab cl lq lr hx ls" role="separator"><span class="lt bw bk lu lv lw"/><span class="lt bw bk lu lv lw"/><span class="lt bw bk lu lv"/></div><div class="im in io ip iq"><h1 id="b3b3" class="lx ly it bd lz ma mb mc md me mf mg mh jz mi ka mj kc mk kd ml kf mm kg mn mo bi translated">4.避免嵌套—使用链代替</h1><p id="dc5f" class="pw-post-body-paragraph ku kv it kw b kx mp ju kz la mq jx lc ld mr lf lg lh ms lj lk ll mt ln lo lp im bi translated">应该不惜一切代价避免嵌套订阅。它们使我们的代码变得复杂、肮脏、难以测试，并可能导致一些非常严重的错误。</p><p id="2057" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">"什么是嵌套订阅？"你可能会问。当我们在一个可观察对象的订阅块中订阅另一个可观察对象时。让我们来看看下面的代码:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mv mw l"/></div><p class="mx my gj gh gi mz na bd b be z dk translated">嵌套订阅</p></figure><p id="3d7a" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">看起来不太整洁，是吗？上面的代码令人困惑、复杂，如果我们需要调用更多返回Observables的函数，我们将不得不继续添加越来越多的订阅。这听起来有点像订阅地狱。那么我们能做些什么来避免嵌套订阅呢？</p><p id="71a0" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">答案是使用高阶映射运算符。这些运算符中有些是<code class="fe nb nc nd ne b"><a class="ae nf" href="https://www.learnrxjs.io/learn-rxjs/operators/transformation/switchmap" rel="noopener ugc nofollow" target="_blank">switchMap</a></code>、<code class="fe nb nc nd ne b"><a class="ae nf" href="https://www.learnrxjs.io/learn-rxjs/operators/transformation/mergemap" rel="noopener ugc nofollow" target="_blank">mergeMap</a></code>等。</p><p id="dbb3" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">为了修正我们的例子，我们将使用<code class="fe nb nc nd ne b">switchMap</code>操作符。为什么？因为<code class="fe nb nc nd ne b">switchMap</code>退订之前的可观察和切换(好记吧？)到内在可观察的，在我们的情况下，这是完美的解决方案。但是，请注意，根据您需要的行为，您可能需要使用不同的高阶映射操作符。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mv mw l"/></div><p class="mx my gj gh gi mz na bd b be z dk translated">使用高阶映射运算符</p></figure><p id="7897" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">看看我们的代码现在看起来有多可爱。</p></div><div class="ab cl lq lr hx ls" role="separator"><span class="lt bw bk lu lv lw"/><span class="lt bw bk lu lv lw"/><span class="lt bw bk lu lv"/></div><div class="im in io ip iq"><h1 id="c7c1" class="lx ly it bd lz ma mb mc md me mf mg mh jz mi ka mj kc mk kd ml kf mm kg mn mo bi translated">5.共享以避免流重复</h1><p id="5796" class="pw-post-body-paragraph ku kv it kw b kx mp ju kz la mq jx lc ld mr lf lg lh ms lj lk ll mt ln lo lp im bi translated">您的Angular代码是否有过重复的HTTP请求，并想知道为什么？继续读下去，你会发现这一普遍错误背后的原因。</p><p id="43ed" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">大多数可观察的东西都是冷的。这意味着当我们订阅它们时，它们的生产者被创建和激活。这听起来可能有点令人困惑，但是很容易理解。有了冷观察，每次我们订阅它们，一个新的生产者就产生了。因此，如果我们订阅一个冷可观的五倍，五个生产者将被创建。</p><p id="ef38" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">那么到底什么是制片人呢？它基本上是我们的可观察值的来源(例如，一个DOM事件、一个HTTP请求、一个数组等)。)这对我们这些反应式程序员意味着什么？例如，如果我们两次订阅一个发出HTTP请求的可观察对象，就会发出两个HTTP请求。</p><p id="b805" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">听起来像是麻烦。</p><p id="a3d3" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">下面的例子(借用Angular的<code class="fe nb nc nd ne b">HttpClient</code>)将触发两个不同的HTTP请求，因为<code class="fe nb nc nd ne b">pokemon$</code>是一个冷可观察对象，我们订阅了它两次:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mv mw l"/></div><p class="mx my gj gh gi mz na bd b be z dk translated">重复的HTTP请求</p></figure><p id="110b" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">可以想象，这种行为只能导致讨厌的bug，那么如何才能避免呢？有没有一种方法可以多次订阅一个可观察对象，而不会触发重复的逻辑，因为它的源是一遍又一遍创建的？当然有。请允许我介绍一下<code class="fe nb nc nd ne b">share()</code>操作员。</p><p id="74b7" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">该操作符用于允许对一个可观察对象的多个订阅，而无需重新创建其源。换句话说，它把一个可观察的物体从冷变热。让我们看看它是如何使用的:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mv mw l"/></div><p class="mx my gj gh gi mz na bd b be z dk translated">使用“share()”来避免重复的源</p></figure><p id="0569" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">是的，这就是我们需要做的，我们的问题就神奇地解决了。通过添加<code class="fe nb nc nd ne b">share()</code>操作符，我们以前冰冷的<code class="fe nb nc nd ne b">pokemon$</code>可观察对象现在的行为就像它是热的一样，即使我们订阅了两次，也只会发出一个HTTP请求。</p><p id="b2f2" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated"><strong class="kw iu">一个警告:</strong>由于热观测值不复制源，如果我们订阅了一个流，我们将不能访问以前发出的值。<code class="fe nb nc nd ne b"><a class="ae nf" href="https://www.learnrxjs.io/learn-rxjs/operators/multicasting/sharereplay" rel="noopener ugc nofollow" target="_blank">shareReplay()</a></code> <em class="mu"> </em>运算符可以解决这个问题。</p></div><div class="ab cl lq lr hx ls" role="separator"><span class="lt bw bk lu lv lw"/><span class="lt bw bk lu lv lw"/><span class="lt bw bk lu lv"/></div><div class="im in io ip iq"><h1 id="3ed7" class="lx ly it bd lz ma mb mc md me mf mg mh jz mi ka mj kc mk kd ml kf mm kg mn mo bi translated">6.不要暴露主题</h1><p id="1b33" class="pw-post-body-paragraph ku kv it kw b kx mp ju kz la mq jx lc ld mr lf lg lh ms lj lk ll mt ln lo lp im bi translated">使用服务来包含我们在应用程序中重用的可观察对象是一种常见的做法。在这种服务中包含主题也很常见。许多开发人员犯的一个常见错误是通过如下方式将这些主题直接暴露给外部世界:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mv mw l"/></div><p class="mx my gj gh gi mz na bd b be z dk translated">暴露的对象</p></figure><p id="9c76" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">不要这样。通过公开一个主题，我们允许任何人将数据放入其中——更不用说我们完全打破了<code class="fe nb nc nd ne b">DataService</code>类的封装。与其暴露我们的主体，不如暴露我们主体的数据。</p><p id="7deb" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">“不是一回事吗？”你可能想知道。答案是否定的。如果我们公开一个Subject，我们将使它的所有方法可用，包括用于使Subject发出新值的<code class="fe nb nc nd ne b">next()</code>函数。另一方面，如果我们只是公开它的数据，我们不会让我们的主题的方法可用，只是它发出的值可用。</p><p id="fc3f" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">那么，我们如何公开我们主题的数据而不公开它的方法呢？通过调用<code class="fe nb nc nd ne b">asObservable()</code>方法——它基本上将一个主题转化为一个可观察的对象。由于Observables没有<code class="fe nb nc nd ne b">next()</code>功能，我们的对象的数据将不会被篡改:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mv mw l"/></div><p class="mx my gj gh gi mz na bd b be z dk translated">维护封装的私有主题</p></figure><p id="92d3" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">在上面的代码中，我们做了四件不同的事情:</p><ul class=""><li id="8281" class="nm nn it kw b kx ky la lb ld no lh np ll nq lp oa ns nt nu bi translated">我们的<code class="fe nb nc nd ne b">pokemonLevel </code>和<code class="fe nb nc nd ne b">stop$</code>主题现在都是私有的，因此不能从我们的<code class="fe nb nc nd ne b">DataService</code>类外部访问。</li><li id="0d91" class="nm nn it kw b kx nv la nw ld nx lh ny ll nz lp oa ns nt nu bi translated">我们现在有了一个通过调用我们的<code class="fe nb nc nd ne b">pokemonLevel</code>主题上的<code class="fe nb nc nd ne b">asObservable()</code>方法创建的<code class="fe nb nc nd ne b">pokemonLevel$</code>可观察对象。通过这种方式，我们可以从类外部访问<code class="fe nb nc nd ne b">pokemonLevel</code>数据，同时保证主题不会被操纵。</li><li id="eb76" class="nm nn it kw b kx nv la nw ld nx lh ny ll nz lp oa ns nt nu bi translated">你可能已经注意到，对于<code class="fe nb nc nd ne b">stop$</code>主题，我们没有创建一个可观察的。这是因为我们不需要从类外访问<code class="fe nb nc nd ne b">stop$</code>的数据。</li><li id="10dc" class="nm nn it kw b kx nv la nw ld nx lh ny ll nz lp oa ns nt nu bi translated">我们现在有两个名为<code class="fe nb nc nd ne b">increaseLevel()</code>和<code class="fe nb nc nd ne b">stop()</code>的公共方法。后者足够简单易懂。它允许我们让私有的<code class="fe nb nc nd ne b">stop$</code>主题从类的外部发出——这样就完成了所有已经管道化<code class="fe nb nc nd ne b">takeUntil(stop$)</code>的可观察对象。</li><li id="9150" class="nm nn it kw b kx nv la nw ld nx lh ny ll nz lp oa ns nt nu bi translated"><code class="fe nb nc nd ne b">increaseLevel()</code>作为一个过滤器，只允许我们将某些值传递给<code class="fe nb nc nd ne b">pokemonLevel()</code>主题。</li></ul><p id="434e" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">这样，任何任意的数据都无法进入我们的主题，我们的主题在类中得到了很好的保护。</p><p id="befd" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated"><strong class="kw iu">注意</strong>:请记住Observables有<code class="fe nb nc nd ne b">complete()</code>和<code class="fe nb nc nd ne b">error()</code>方法，仍然可以用来搞乱主体。</p><p id="e7dd" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">大家记住，封装是关键。</p></div><div class="ab cl lq lr hx ls" role="separator"><span class="lt bw bk lu lv lw"/><span class="lt bw bk lu lv lw"/><span class="lt bw bk lu lv"/></div><div class="im in io ip iq"><h1 id="100c" class="lx ly it bd lz ma mb mc md me mf mg mh jz mi ka mj kc mk kd ml kf mm kg mn mo bi translated">使用大理石图进行测试</h1><p id="3c63" class="pw-post-body-paragraph ku kv it kw b kx mp ju kz la mq jx lc ld mr lf lg lh ms lj lk ll mt ln lo lp im bi translated">众所周知，编写测试和编写代码一样重要。然而，如果编写RxJS测试的想法对您来说听起来有点令人畏惧…不要害怕。从RxJS 6+开始，RxJS大理石测试实用程序将使我们的生活变得非常非常容易。你熟悉大理石图吗？如果没有，这里有一个例子:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ob"><img src="../Images/1da3a5430475b54a08e892eed210ae44.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*2uN5I_Qj68MF3Ofd.png"/></div></div><p class="mx my gj gh gi mz na bd b be z dk translated">过滤器-大理石图</p></figure><p id="08c1" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">即使你是RxJS的新手，你也应该或多或少地理解这些图表。它们无处不在，非常直观，并且它们使得理解一些更复杂的RxJS操作符是如何工作的变得非常容易。RxJS测试实用程序允许我们使用这些大理石图来编写简单、直观和可视化的测试。您所要做的就是从<code class="fe nb nc nd ne b">rxjs/testing</code>模块导入<code class="fe nb nc nd ne b">TestScheduler</code>并开始编写测试！</p><p id="79b2" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">让我们通过测试我们的<code class="fe nb nc nd ne b">number$</code>可观察值来看看它是如何做到的:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mv mw l"/></div><p class="mx my gj gh gi mz na bd b be z dk translated">使用“TestScheduler”进行大理石测试</p></figure><p id="b1fd" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">因为深入研究marble测试不是本教程的目标，所以我将只简要介绍上面代码中出现的关键概念，以便我们对正在发生的事情有一个基本的了解:</p><ul class=""><li id="89c9" class="nm nn it kw b kx ky la lb ld no lh np ll nq lp oa ns nt nu bi translated"><code class="fe nb nc nd ne b">TestScheduler</code>:用于虚拟时间。它接收一个回调，可以用助手对象调用这个回调(在我们的例子中，是<code class="fe nb nc nd ne b">cold()</code>和<code class="fe nb nc nd ne b">expectObservable()</code>助手)。</li><li id="6604" class="nm nn it kw b kx nv la nw ld nx lh ny ll nz lp oa ns nt nu bi translated"><code class="fe nb nc nd ne b">Run()</code>:回调返回时自动调用<code class="fe nb nc nd ne b">flush()</code>。</li><li id="6d04" class="nm nn it kw b kx nv la nw ld nx lh ny ll nz lp oa ns nt nu bi translated"><code class="fe nb nc nd ne b">- </code>:每个<code class="fe nb nc nd ne b">-</code>代表1毫秒的虚拟时间。</li><li id="fcb0" class="nm nn it kw b kx nv la nw ld nx lh ny ll nz lp oa ns nt nu bi translated"><code class="fe nb nc nd ne b">Cold()</code>:创建一个cold Observable，它的订阅在测试开始时开始。在我们的例子中，我们正在创建一个冷的可观测值，它将每1毫秒发出一个值并完成。</li><li id="6408" class="nm nn it kw b kx nv la nw ld nx lh ny ll nz lp oa ns nt nu bi translated"><code class="fe nb nc nd ne b">|</code>:表示可观察的完成。</li><li id="0f05" class="nm nn it kw b kx nv la nw ld nx lh ny ll nz lp oa ns nt nu bi translated">因此，我们的<code class="fe nb nc nd ne b">expectedMarbleDiagram</code>期望<em class="mu"> a </em>在20 ms发射。</li><li id="8cbe" class="nm nn it kw b kx nv la nw ld nx lh ny ll nz lp oa ns nt nu bi translated"><code class="fe nb nc nd ne b">expectedValues</code>变量包含我们的可观察对象发出的每一项的期望值。在我们的例子中，<em class="mu"> a </em>是唯一会发出的值，它等于10。</li><li id="9d8f" class="nm nn it kw b kx nv la nw ld nx lh ny ll nz lp oa ns nt nu bi translated"><code class="fe nb nc nd ne b">ExpectObservable()</code>:调度一个断言，当<code class="fe nb nc nd ne b">testScheduler</code>刷新时执行。在我们的例子中，我们的断言期望<code class="fe nb nc nd ne b">number$</code>可观察值类似于<code class="fe nb nc nd ne b">expectedMarbleDiagram</code>，其值包含在<code class="fe nb nc nd ne b">expectedValues</code>变量中。</li></ul><p id="e8ad" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">你可以在<a class="ae nf" href="https://rxjs-dev.firebaseapp.com/guide/testing/marble-testing" rel="noopener ugc nofollow" target="_blank">官方RxJS文档</a>中找到更多关于帮手的信息。</p><p id="3ebe" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">使用RxJS大理石测试工具的优势:</p><ul class=""><li id="c9a0" class="nm nn it kw b kx ky la lb ld no lh np ll nq lp oa ns nt nu bi translated">您避免了许多样板代码。(茉莉弹珠用户将能够欣赏这一点。)</li><li id="08d1" class="nm nn it kw b kx nv la nw ld nx lh ny ll nz lp oa ns nt nu bi translated">使用起来非常简单直观。</li><li id="878f" class="nm nn it kw b kx nv la nw ld nx lh ny ll nz lp oa ns nt nu bi translated">很好玩！即使你不热衷于编写测试，我也可以保证你会喜欢大理石测试。</li></ul><p id="a097" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">因为我喜欢让我所有的代码示例都以口袋妖怪为主题，所以我会加入另一个规范，这次是一个<code class="fe nb nc nd ne b">pokemon$</code>可观察的测试:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mv mw l"/></div><p class="mx my gj gh gi mz na bd b be z dk translated">另一个大理石测试示例</p></figure></div><div class="ab cl lq lr hx ls" role="separator"><span class="lt bw bk lu lv lw"/><span class="lt bw bk lu lv lw"/><span class="lt bw bk lu lv"/></div><div class="im in io ip iq"><h1 id="cf8f" class="lx ly it bd lz ma mb mc md me mf mg mh jz mi ka mj kc mk kd ml kf mm kg mn mo bi translated">结论</h1><p id="68af" class="pw-post-body-paragraph ku kv it kw b kx mp ju kz la mq jx lc ld mr lf lg lh ms lj lk ll mt ln lo lp im bi translated">那都是乡亲们！今天我们讨论了几个RxJS最佳实践，我总是小心翼翼地在我的代码中应用。如果您还不了解它们，我希望您会发现它们很有用。</p><p id="5dbc" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">你知道更多RxJS最佳实践吗？如果你有，请在下面的评论中告诉我。这样，我们都可以为编写更好、更干净的反应式代码做出贡献。</p></div></div>    
</body>
</html>