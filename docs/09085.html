<html>
<head>
<title>The SwiftUI Equivalents to UICollectionView</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">与UICollectionView等效的SwiftUI</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/the-swiftui-equivalents-to-uicollectionview-60415e3c1bbe?source=collection_archive---------2-----------------------#2021-07-14">https://betterprogramming.pub/the-swiftui-equivalents-to-uicollectionview-60415e3c1bbe?source=collection_archive---------2-----------------------#2021-07-14</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="e84c" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">了解如何在iOS13和iOS14中实现网格布局</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/334b7cce921fd353941ee722f7433007.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*XjCaDaMhdPYJ-1efgbvh-g.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">图片由作者提供。</p></figure><p id="667b" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">SwiftUI首次在WWDC 2019上推出，该API在过去两年中得到了快速改进。苹果确实对SwiftUI进行了重大改进，包括UI组件、布局和动画。</p><p id="6d14" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">在WWDC21之前，SwiftUI还没有包含专用的<code class="fe lr ls lt lu b">CollectionView</code>或复合布局来取代UIKit中的<code class="fe lr ls lt lu b">UICollectionView</code>。因此，开发人员目前可以实现的变通解决方案是将<code class="fe lr ls lt lu b">UICollectionView</code>与<code class="fe lr ls lt lu b">UIViewRepresentable</code>结合使用。</p><p id="1718" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">在本文中，我们将讨论在SwiftUI中不使用<code class="fe lr ls lt lu b">UIViewRepresentable</code>模仿<code class="fe lr ls lt lu b">CollectionView</code>的可用解决方案。</p></div><div class="ab cl lv lw hu lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="ij ik il im in"><h1 id="0624" class="mc md iq bd me mf mg mh mi mj mk ml mm jw mn jx mo jz mp ka mq kc mr kd ms mt bi translated">解决办法</h1><p id="f0a0" class="pw-post-body-paragraph kv kw iq kx b ky mu jr la lb mv ju ld le mw lg lh li mx lk ll lm my lo lp lq ij bi translated">我们可以使用纯粹的SwiftUI API在我们的项目中实现几种方法，但我们应该考虑基于支持的iOS版本的那些替代解决方案。</p><h2 id="4c37" class="mz md iq bd me na nb dn mi nc nd dp mm le ne nf mo li ng nh mq lm ni nj ms nk bi translated">1.将ScrollView与VStack和HStack配合使用(iOS13+)</h2><p id="9506" class="pw-post-body-paragraph kv kw iq kx b ky mu jr la lb mv ju ld le mw lg lh li mx lk ll lm my lo lp lq ij bi translated">通过实现这一点，我们能够支持目前市场上的大多数应用程序(iOS 13)。</p><h2 id="d398" class="mz md iq bd me na nb dn mi nc nd dp mm le ne nf mo li ng nh mq lm ni nj ms nk bi translated">2.将ScrollView与lazy grid或lazy grid一起使用(iOS14+)</h2><p id="47c4" class="pw-post-body-paragraph kv kw iq kx b ky mu jr la lb mv ju ld le mw lg lh li mx lk ll lm my lo lp lq ij bi translated">这是最新的SwiftUI API，更灵活，有内存优化，但只适用于iOS14及更高版本。</p></div><div class="ab cl lv lw hu lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="ij ik il im in"><h1 id="a323" class="mc md iq bd me mf mg mh mi mj mk ml mm jw mn jx mo jz mp ka mq kc mr kd ms mt bi translated">1.带VStack和HStack的scroll view(IOs 13+)</h1><p id="aa69" class="pw-post-body-paragraph kv kw iq kx b ky mu jr la lb mv ju ld le mw lg lh li mx lk ll lm my lo lp lq ij bi translated">在这一节中，我们将创建一个卡片集合，其中包含带有垂直滚动条的两列中的<code class="fe lr ls lt lu b">RoundedRectangle</code>和<code class="fe lr ls lt lu b">Text</code>。</p><p id="a4de" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">1.在iOS13中创建一个具有最低部署支持的新SwiftUI项目。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nl"><img src="../Images/d26746d718e378bfc4a197d311890e4a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*gCZKNPPYZmc2Xt58ISCahQ.png"/></div></div></figure><p id="6a1f" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">2.创建一个新的SwiftUI视图(<code class="fe lr ls lt lu b">CardView</code>)来创建一个简单的卡片视图。此外，我们添加了一个<code class="fe lr ls lt lu b">Color</code>扩展来为<code class="fe lr ls lt lu b">RoundedRectangle</code>获得随机颜色。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nm nn l"/></div></figure><p id="3d2c" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">3.现在添加<code class="fe lr ls lt lu b">Card</code>模型和<code class="fe lr ls lt lu b">RowView</code>作为<code class="fe lr ls lt lu b">CardView</code>容器。<code class="fe lr ls lt lu b">RowView</code>将根据给定的数组创建许多卡片，并将它们插入<code class="fe lr ls lt lu b">HStack</code>。还要求<code class="fe lr ls lt lu b">spacing</code>、<code class="fe lr ls lt lu b">width</code>和<code class="fe lr ls lt lu b">height</code>正确放置<code class="fe lr ls lt lu b">CardView</code>并调整其大小。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nm nn l"/></div></figure><p id="81af" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">4.添加<code class="fe lr ls lt lu b">MockStore.swift</code>进给一些样卡数据。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nm nn l"/></div></figure><p id="0a7e" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">5.最后，完成我们的<code class="fe lr ls lt lu b">ContentView</code>文件。</p><p id="ecf8" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">我们将使用示例数据来显示两列中的卡片。请注意，这段代码每行只支持两个项目。为了在每一行中有更多的条目，我们需要修改<code class="fe lr ls lt lu b">itemPerRow</code>常量。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nm nn l"/></div></figure><p id="f9e3" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">下面是我们将得到的结果。厉害！</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi no"><img src="../Images/bd1d687972bc76fa0602309e055ab2d9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*_2Y2oII4qZVVfn25t1XRUg.gif"/></div></div></figure></div><div class="ab cl lv lw hu lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="ij ik il im in"><h1 id="28dc" class="mc md iq bd me mf mg mh mi mj mk ml mm jw mn jx mo jz mp ka mq kc mr kd ms mt bi translated">2.使用lazy grid或lazy grid滚动查看(iOS14+)</h1><p id="cf12" class="pw-post-body-paragraph kv kw iq kx b ky mu jr la lb mv ju ld le mw lg lh li mx lk ll lm my lo lp lq ij bi translated"><code class="fe lr ls lt lu b">LazyHGrid</code>和<code class="fe lr ls lt lu b">LazyVGrid</code>是在WWDC20上推出的。这两个API<a class="ae np" href="https://developer.apple.com/documentation/swiftui/lazyvgrid" rel="noopener ugc nofollow" target="_blank">只能在最低部署iOS14及以上的</a>上使用。</p><p id="3bb3" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">使用这两个API的优点是，它们只在内容显示在<code class="fe lr ls lt lu b">ScrollView</code>时填充内容。</p><blockquote class="nq"><p id="febb" class="nr ns iq bd nt nu nv nw nx ny nz lq dk translated">"网格是“懒惰的”，因为网格视图直到需要时才创建项目."— <a class="ae np" href="https://developer.apple.com/documentation/swiftui/lazyvgrid" rel="noopener ugc nofollow" target="_blank">苹果开发者</a></p></blockquote><p id="e91a" class="pw-post-body-paragraph kv kw iq kx b ky oa jr la lb ob ju ld le oc lg lh li od lk ll lm oe lo lp lq ij bi translated">太好了。让我们开始编码。</p><p id="e661" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">在这个例子中，我们使用带有<code class="fe lr ls lt lu b">.flexible</code> <code class="fe lr ls lt lu b">GridItem</code>的<code class="fe lr ls lt lu b">LazyVGrid</code>来演示尺寸灵活的<code class="fe lr ls lt lu b">CardView</code>的垂直滚动。<code class="fe lr ls lt lu b">GridItem</code>有三种不同的尺寸状态，包括<code class="fe lr ls lt lu b">.flexible</code>、<code class="fe lr ls lt lu b">.fixed</code>和<code class="fe lr ls lt lu b">.adaptive</code>。</p><ol class=""><li id="ef96" class="of og iq kx b ky kz lb lc le oh li oi lm oj lq ok ol om on bi translated">首先，创建一个新的SwiftUI项目。默认情况下，它应该将最低部署目标设置为iOS14+。</li><li id="3363" class="of og iq kx b ky oo lb op le oq li or lm os lq ok ol om on bi translated">如下面的代码所示更新<code class="fe lr ls lt lu b">ContentView</code>。我们将重用上一节中显示的相同的<code class="fe lr ls lt lu b">CardView</code>。</li></ol><p id="ad62" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">每行显示的项目由<code class="fe lr ls lt lu b">GridItem</code>数组中的总项目决定。在下面的例子中，我们只定义了三个项目。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nm nn l"/></div></figure><p id="c8ca" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">从上面的代码中我们可以看到，它比前面的实现要干净和简单得多。那是因为<code class="fe lr ls lt lu b">LazyVGrid</code> API现在处理我们需要的一切。</p><p id="55c6" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">下面是我们用三列得到的结果。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi no"><img src="../Images/e6bacd18eae620e36433d5b6ef58e833.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*zTWTT0oUnPP4iKeWl9qdjw.gif"/></div></div></figure></div><div class="ab cl lv lw hu lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="ij ik il im in"><h1 id="669a" class="mc md iq bd me mf mg mh mi mj mk ml mm jw mn jx mo jz mp ka mq kc mr kd ms mt bi translated">有用的GitHub库</h1><p id="fb1d" class="pw-post-body-paragraph kv kw iq kx b ky mu jr la lb mv ju ld le mw lg lh li mx lk ll lm my lo lp lq ij bi translated">除了上面列出的解决方案，还有两个优秀的库可以用来更灵活地完成相同的目标，并且都支持iOS 13及更高版本。</p><h2 id="2827" class="mz md iq bd me na nb dn mi nc nd dp mm le ne nf mo li ng nh mq lm ni nj ms nk bi translated">1.QGrid</h2><p id="9d67" class="pw-post-body-paragraph kv kw iq kx b ky mu jr la lb mv ju ld le mw lg lh li mx lk ll lm my lo lp lq ij bi translated">这基本上是一个使用<code class="fe lr ls lt lu b">ScrollView</code>、<code class="fe lr ls lt lu b">GeometryReader</code>、<code class="fe lr ls lt lu b">HStack</code>或<code class="fe lr ls lt lu b">VStack</code>创建网格布局的<a class="ae np" href="https://github.com/Q-Mobile/QGrid" rel="noopener ugc nofollow" target="_blank">包装器库</a>(类似于我们的第一种方法)。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi no"><img src="../Images/23f55b61ee6d384bdc96eb2b5a2cbe7a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*RNvrB7oXx5PTbDAUGgIR8w.gif"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">图片来自<a class="ae np" href="https://github.com/Q-Mobile/QGrid" rel="noopener ugc nofollow" target="_blank"> QGrid </a></p></figure><h2 id="fcae" class="mz md iq bd me na nb dn mi nc nd dp mm le ne nf mo li ng nh mq lm ni nj ms nk bi translated">2.瀑布网格</h2><p id="232d" class="pw-post-body-paragraph kv kw iq kx b ky mu jr la lb mv ju ld le mw lg lh li mx lk ll lm my lo lp lq ij bi translated"><a class="ae np" href="https://github.com/paololeonardi/WaterfallGrid" rel="noopener ugc nofollow" target="_blank">这个库</a>通过使用<code class="fe lr ls lt lu b">ScrollView</code>、<code class="fe lr ls lt lu b">ZStack</code>等等，在每个网格项目上提供了更高级的动态高度布局。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi no"><img src="../Images/7644a912a673e3126dd6377cc53010c6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*MDIT1ePR0fya3xnMbqszbQ.gif"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">图片来自<a class="ae np" href="https://github.com/paololeonardi/WaterfallGrid" rel="noopener ugc nofollow" target="_blank">瀑布网格</a></p></figure></div><div class="ab cl lv lw hu lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="ij ik il im in"><h1 id="e078" class="mc md iq bd me mf mg mh mi mj mk ml mm jw mn jx mo jz mp ka mq kc mr kd ms mt bi translated">结论</h1><p id="242c" class="pw-post-body-paragraph kv kw iq kx b ky mu jr la lb mv ju ld le mw lg lh li mx lk ll lm my lo lp lq ij bi translated"><code class="fe lr ls lt lu b">LazyVGrid</code>和<code class="fe lr ls lt lu b">LazyHGrid</code>在功能和灵活性方面有很多优势——尤其是延迟加载特性。但是，我们应该记住，大多数iOS项目仍然支持iOS13用户。因此，在所有用户都迁移到iOS14之前，我们应该保留<code class="fe lr ls lt lu b">ScrollView</code>、<code class="fe lr ls lt lu b">VStack</code>和<code class="fe lr ls lt lu b">HStack</code>作为我们当前的首选。你可以参考我的GitHub <a class="ae np" href="https://github.com/xmhafiz/GridLayoutSwiftUI" rel="noopener ugc nofollow" target="_blank">资源库</a>中的完整项目。</p><p id="1aec" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">希望本文提高了您对使用网格布局的SwiftUI的理解。感谢阅读。编码快乐！</p></div><div class="ab cl lv lw hu lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="ij ik il im in"><h1 id="3b81" class="mc md iq bd me mf mg mh mi mj mk ml mm jw mn jx mo jz mp ka mq kc mr kd ms mt bi translated">资源</h1><h2 id="1fce" class="mz md iq bd me na nb dn mi nc nd dp mm le ne nf mo li ng nh mq lm ni nj ms nk bi translated">开源代码库</h2><ul class=""><li id="f9ca" class="of og iq kx b ky mu lb mv le ot li ou lm ov lq ow ol om on bi translated"><a class="ae np" href="https://github.com/paololeonardi/WaterfallGrid" rel="noopener ugc nofollow" target="_blank">https://github.com/paololeonardi/WaterfallGrid</a></li><li id="a200" class="of og iq kx b ky oo lb op le oq li or lm os lq ow ol om on bi translated"><a class="ae np" href="https://github.com/Q-Mobile/QGrid" rel="noopener ugc nofollow" target="_blank">https://github.com/Q-Mobile/QGrid</a></li><li id="845f" class="of og iq kx b ky oo lb op le oq li or lm os lq ow ol om on bi translated"><a class="ae np" href="https://github.com/xmhafiz/GridLayoutSwiftUI" rel="noopener ugc nofollow" target="_blank">https://github.com/xmhafiz/GridLayoutSwiftUI</a></li></ul><h2 id="955e" class="mz md iq bd me na nb dn mi nc nd dp mm le ne nf mo li ng nh mq lm ni nj ms nk bi translated">了解网格布局</h2><ul class=""><li id="497b" class="of og iq kx b ky mu lb mv le ot li ou lm ov lq ow ol om on bi translated">【https://developer.apple.com/documentation/swiftui/lazyvgrid】</li><li id="6d9b" class="of og iq kx b ky oo lb op le oq li or lm os lq ow ol om on bi translated"><a class="ae np" href="https://swiftwithmajid.com/2020/07/08/mastering-grids-in-swiftui/" rel="noopener ugc nofollow" target="_blank">https://swiftwithmajid . com/2020/07/08/mastering-grids-in-swift ui/</a></li><li id="e12b" class="of og iq kx b ky oo lb op le oq li or lm os lq ow ol om on bi translated"><a class="ae np" href="https://www.appcoda.com/learnswiftui/swiftui-gridlayout.html" rel="noopener ugc nofollow" target="_blank">https://www . app coda . com/learnswiftui/swift ui-gridlayout . html</a></li></ul></div></div>    
</body>
</html>