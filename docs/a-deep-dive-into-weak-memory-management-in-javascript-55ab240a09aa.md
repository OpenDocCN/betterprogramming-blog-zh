# 深入探讨 JavaScript 中薄弱的内存管理

> 原文：<https://betterprogramming.pub/a-deep-dive-into-weak-memory-management-in-javascript-55ab240a09aa>

## 探索 JavaScript 的薄弱 API

![](img/b0ce647f201e8deb4c8e4233ddcc9353.png)

[附身摄影](https://unsplash.com/@possessedphotography?utm_source=medium&utm_medium=referral)在 [Unsplash](https://unsplash.com/?utm_source=medium&utm_medium=referral) 上拍照。

JavaScript 内存管理过程起初看起来很简单。JavaScript VM 通过垃圾收集内存回收过程来管理内存。

然而，我们不能强迫垃圾收集以编程方式运行。浏览器会决定何时执行它。由于没有共同的规格，它将因供应商而异。这是一个不可预测和不确定的过程。

这并不意味着我们可以无忧无虑。我们需要了解记忆在钩子下是如何工作的。否则，我们可能会出现一些内存泄漏。为了有资格进行垃圾回收，该对象不能在其他地方被引用。肯定是够不着的。相反，当保存对对象的引用时，该资源被阻止分配。

当我们从一个不受我们管理的对象获取引用时会发生什么？我们应该保留引用吗？我们应该只是复制对象吗？怎么才能知道什么时候不再被引用？

JavaScript 弱 API 就是基于这一动机而创建的。它使我们能够在不阻止垃圾收集过程的情况下保存对对象的引用。目标对象可以随时回收。这些不会添加强引用。当我们想在一个对象还活着的时候保存它的信息时，它是合适的。

在本文中，我们将检查我们拥有的所有工具以及如何最好地使用它们。

# WeakRef API - ES2021

那个`WeakRef` API 是最新的弱 API 之一。它让我们保存对一个对象的弱引用，并在需要时提取它。

怎么用？这是一个分两步走的过程。

**1。** **创建弱引用:**目标参数必须是对象。只有那些是垃圾收集的。例如，您不能为字符串或数字创建 WeakRef。

```
// creating a weak object reference
const ElmentRef = new **WeakRef(**element**)**;
```

**2。** **拉引用:**要使用被引用的目标，我们必须使用`deref()`。第一步只是生成一个普通的 JavaScript 对象，它包含对我们的目标的弱引用。我们对此无能为力。

```
// pulling stored weak object
const element = ElmentRef**.deref()**;
```

一旦我们使用了那个`deref()`方法，我们就创建了一个新的对对象的强引用。这意味着在引用未被使用之前，该对象不再有资格进行垃圾收集。这个物体会变成`undefined`是没有意义的。这会使该特征不可靠且无用。

让我们看一个完整的例子:

注意在上面的代码中，我们总是需要检查从`deref`返回的不是`undefined`。如果从`DOM`中删除了`DOM`元素，那么资源可以在任何时候被回收。

让我们看另一个例子。让我们做一个元素记忆跟踪器:

在上面的代码中，我们将继续获取控制台`Element is still on memory`语句，直到元素在 GC 中从内存中被清除。

# WeakSet 和 WeakMap API - ES2015

这些是最古老的脆弱的 Javascript APIs。它们从`ES6`开始就存在了。尽管它们可以保存弱引用的集合，但是它们是不可迭代的。我们只能添加值、查询它们的存在或删除它。

我们总是通过目标对象与它们互动。

我们来看一个`WeakSet`的例子。它很简单，只是作为一个弱字典。

而`WeakMap`更为复杂。我们可以用它来存储目标对象的附加信息。可以是对象或者只是原语。当目标引用被垃圾回收时，它们将被回收。

让我们看一个例子:

正如我们在上面的例子中看到的，当通过`set()`添加一个值时，可以通过执行具有相同目标的`get()`方法来检索它。

# 终结器 API - ES2021

在最新的`ES2021`中，有一种方法可以知道一个对象是否已经被 GC 回收。这个特性叫做`Finalizers`。

然而:

*   不能保证回调会被执行。
*   目标对象已被清除，将无法访问。
*   回调将执行多长时间是不确定的。可以是一分钟，也可以是一个小时。
*   行为可能因供应商而异

为什么`register`方法采用两个值？当`FinalizationRegistry`被调用时,`x`值可能已经被垃圾收集了。所以没有办法找回那个值。相反，我们可以传递任何我们认为合适的目标提示。

如果我们用相同的`x`值调用`register`，它将不会被垃圾收集，因为该参数是强持有的。

```
// ❌ x would never be reclaimed as it is strongly held in the second parameter
cleanup.**register(x, x)**;
```

有一种方法可以注销回调的执行。该方法可以接受第三个参数，这个参数不是很强。

```
// ✅ x is not strongly held so it can be garbage collected
cleanup.**register(**x, 'cleaning up x'**, x)**;// ✅ will remove callback
cleanup.**unregister(x);**
```

*不建议在关键区域使用此功能。这只是为了执行一些额外的清理，以进一步减少我们的 web 应用程序的内存占用。*

# 用例

在查看用例之前，请注意这是一个高级特性，应该小心使用。成功地使用它需要一些仔细的思考和计划。

## 1.附加数据

有时候我们只是想增强一些不属于自己的对象。我们不控制他们的引用或他们的流程。

或者，我们可以改变对象实例，打破函数式编程范式。创建另一个有一些变化的对象会增加我们的内存占用。

一个例子可能是 DOM 元素或来自库的对象。如果我们需要增强它们，我们可以简单地创建一个`WeakRef`或`WeakMap`并将我们自己的值存储在那里。这样，当不使用该对象时，我们就不必考虑增强的属性。

## 2.贮藏

我们可以利用这些 API 来创建一些缓存机制。我们可以创建临时缓存，当这个大对象不再被引用并被清除时，可以回收这些缓存。

另一个例子是将不变性与`WeakMap`结合起来，创建一个缓存来存储计算开销很大的操作的结果:

这意味着我们在 JavaScript 引擎中内置了一个自动清除缓存。这会变得非常有用。

## 3.额外清理

通过选择进入`FinalizationRegistry`，我们可以在对象不再存在时执行一些清理。它不应该用于执行某些业务逻辑。

这是我们的代码第一次可以更接近垃圾收集过程并利用它。

# 概述

我们已经看到 JavaScript 最近是如何增强其弱引用特性的。我们突然对应用程序有了更多的控制权，并且离引擎更近了。

如前所述，重要的是不要严重依赖任何脆弱的引擎 API。它们有非常具体的用例。垃圾收集过程很复杂，并且会因浏览器而异。这是一个很难的课题，需要不断改进和变化。

您有兴趣了解更多关于 JavaScript 内存泄漏的知识吗？查看我下面的文章:

[](/5-common-javascript-memory-mistakes-c8553972e4c2) [## 5 个常见的 JavaScript 内存错误

### 避免应用程序内存泄漏的技巧

better 编程. pub](/5-common-javascript-memory-mistakes-c8553972e4c2)