<html>
<head>
<title>Why You Might Not Need Vuex With Vue 3</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">为什么Vue 3不需要Vuex</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/why-you-might-not-need-vuex-with-vue-3-61ad09e62334?source=collection_archive---------2-----------------------#2020-07-13">https://betterprogramming.pub/why-you-might-not-need-vuex-with-vue-3-61ad09e62334?source=collection_archive---------2-----------------------#2020-07-13</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="2b7f" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">Vue 3中的反应引入了构建应用程序的新方法</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/805144e547e0faa50b87cfbdb07cf6a6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*qJjVRoUhZmOCBVBl.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">作者照片。</p></figure><p id="9f6d" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">Vuex是一个非常棒的状态管理库。它很简单，并且与<a class="ae lu" href="https://vuejs.org/" rel="noopener ugc nofollow" target="_blank"> Vue </a>集成得很好。为什么会有人离开Vuex？原因可能是即将发布的Vue 3暴露了底层的反应系统，并引入了构建应用程序的新方法。新的反应性系统非常强大，可以用于集中的状态管理。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="2ccb" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">需要共享状态吗？</h1><p id="ed12" class="pw-post-body-paragraph ky kz it la b lb mu ju ld le mv jx lg lh mw lj lk ll mx ln lo lp my lr ls lt im bi translated">在某些情况下，多个组件之间的数据流变得非常困难，以至于您需要集中的状态管理。这些情况包括:</p><ul class=""><li id="e8a5" class="mz na it la b lb lc le lf lh nb ll nc lp nd lt ne nf ng nh bi translated">使用相同数据的多个组件。</li><li id="4609" class="mz na it la b lb ni le nj lh nk ll nl lp nm lt ne nf ng nh bi translated">具有数据访问的多个根。</li><li id="9dd3" class="mz na it la b lb ni le nj lh nk ll nl lp nm lt ne nf ng nh bi translated">组件的深度嵌套。</li></ul><p id="6fd8" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">如果以上情况都不成立，那么就很容易确定自己是否需要。你不知道。</p><p id="1ef3" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">但是如果你有这样的情况呢？最直接的答案是使用Vuex。这是一个久经考验的解决方案，做得相当不错。</p><p id="4a25" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">但是，如果您不想添加另一个依赖项或者发现设置过于复杂，该怎么办呢？与Composition API一起，新的Vue 3版本可以用其内置的方法解决这些问题。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="20c2" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">新的解决方案</h1><p id="6c7d" class="pw-post-body-paragraph ky kz it la b lb mu ju ld le mv jx lg lh mw lj lk ll mx ln lo lp my lr ls lt im bi translated">共享状态必须符合两个标准:</p><ul class=""><li id="1b76" class="mz na it la b lb lc le lf lh nb ll nc lp nd lt ne nf ng nh bi translated">反应性:当状态改变时，使用它们的组件也应该更新。</li><li id="662c" class="mz na it la b lb ni le nj lh nk ll nl lp nm lt ne nf ng nh bi translated">可用性:可以在任何组件中访问状态。</li></ul></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="8082" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">反应</h1><p id="27df" class="pw-post-body-paragraph ky kz it la b lb mu ju ld le mv jx lg lh mw lj lk ll mx ln lo lp my lr ls lt im bi translated">Vue 3通过多种功能暴露其反应系统。您可以用<code class="fe nn no np nq b">reactive</code>函数创建一个反应变量(另一个选择是<code class="fe nn no np nq b">ref</code>函数):</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nr ns l"/></div></figure><p id="da54" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">从<code class="fe nn no np nq b">reactive</code>函数返回的对象是一个能够跟踪其属性变化的<code class="fe nn no np nq b">Proxy</code>对象。在组件的模板中使用时，每当反应值发生变化时，组件都会重新呈现自身:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nr ns l"/></div></figure></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="37ce" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">有效性</h1><p id="b9c7" class="pw-post-body-paragraph ky kz it la b lb mu ju ld le mv jx lg lh mw lj lk ll mx ln lo lp my lr ls lt im bi translated">上面的例子对于单个组件来说是极好的，但是其他组件不能访问状态。为了克服这一点，您可以使用<code class="fe nn no np nq b">provide</code>和<code class="fe nn no np nq b">inject</code>方法使任何值在Vue 3应用程序中可用:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nr ns l"/></div></figure><p id="29ca" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">当您将一个<code class="fe nn no np nq b">Symbol</code>作为键和值传递给<code class="fe nn no np nq b">provide</code>方法时，该值将通过<code class="fe nn no np nq b">inject</code>方法对任何子组件可用。关键是在提供和检索值时使用相同的<code class="fe nn no np nq b">Symbol</code>名称。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi nt"><img src="../Images/a3b6e5b0220d6bd114963acbf4b5bfbc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1156/format:webp/1*SMOlZtPQDFVBEoPbH3DBMg.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">作者照片。</p></figure><p id="dc72" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">这样，如果您在最上面的组件上提供值，它将在所有组件中可用。或者，您也可以在主应用程序实例上调用<code class="fe nn no np nq b">provide</code>:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nr ns l"/></div></figure><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nr ns l"/></div></figure></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="c516" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">使其坚固耐用</h1><p id="e616" class="pw-post-body-paragraph ky kz it la b lb mu ju ld le mv jx lg lh mw lj lk ll mx ln lo lp my lr ls lt im bi translated">上面的解决方案是可行的，但是有一个缺点:你不知道谁修改了什么。状态可以直接改变，没有限制。</p><p id="bada" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">您可以通过用<code class="fe nn no np nq b">readonly</code>函数包装它来保护您的状态。它将传递的变量包含在一个<code class="fe nn no np nq b">Proxy</code>对象中，防止任何修改(当您尝试修改时会发出警告)。突变可以由访问可写存储器的独立函数来处理。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nr ns l"/></div></figure><p id="4d3e" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">外界只能访问只读状态，只有导出的函数可以修改可写状态。</p><p id="b069" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">通过保护状态免受不必要的修改，新的解决方案相对接近Vuex。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="070b" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">摘要</h1><p id="fc14" class="pw-post-body-paragraph ky kz it la b lb mu ju ld le mv jx lg lh mw lj lk ll mx ln lo lp my lr ls lt im bi translated">通过使用Vue 3的反应系统和依赖注入机制，我们已经从本地状态转变为集中式状态管理，可以在较小的应用程序中取代Vuex。</p><p id="e745" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">我们有一个状态对象，它是只读的，可以对模板中的变化做出反应。状态只能通过特定方法修改，如Vuex中的动作/突变。您可以用<code class="fe nn no np nq b">computed</code>函数定义额外的getters。</p><p id="a05b" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">Vuex有更多像模块处理这样的特性，但是有时候我们不需要。</p><p id="d195" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">如果你想探索Vue 3并尝试这种状态管理方法，看看<a class="ae lu" href="https://github.com/blacksonic/vue-3-playground" rel="noopener ugc nofollow" target="_blank">我的Vue 3游乐场</a>。</p></div></div>    
</body>
</html>