<html>
<head>
<title>Benchmarking in Go: Substrings vs. Regular Expressions</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Go中的基准测试:子字符串与正则表达式</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/benchmarking-in-go-substrings-vs-regular-expressions-a84de7f0eb02?source=collection_archive---------2-----------------------#2022-08-19">https://betterprogramming.pub/benchmarking-in-go-substrings-vs-regular-expressions-a84de7f0eb02?source=collection_archive---------2-----------------------#2022-08-19</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="9cbe" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">讨论这些文本过滤策略的利弊</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/3ae04489d464c2f95f250d24f00a77d1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*2uogrQv6IDZ9xS4ED3QyqQ.png"/></div></div></figure><p id="0803" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">在这个四部分系列的第三部分中，我们将使用我们的文本过滤工具作为测试主题来讨论Go中的基准测试。您可以在下面找到其他部分:</p><ul class=""><li id="9b76" class="ln lo iq kt b ku kv kx ky la lp le lq li lr lm ls lt lu lv bi translated"><a class="ae lw" rel="noopener ugc nofollow" target="_blank" href="/how-to-build-a-text-filtering-log-simplifying-tool-in-go-b29d3067e092">第1部分:在Go中构建一个文本过滤工具</a></li><li id="3dc9" class="ln lo iq kt b ku lx kx ly la lz le ma li mb lm ls lt lu lv bi translated"><a class="ae lw" href="https://medium.com/@gourikabang1996/part-2-how-to-prepare-for-your-next-coding-interview-d048b188301e" rel="noopener">第2部分:添加正则表达式支持</a></li><li id="eabc" class="ln lo iq kt b ku lx kx ly la lz le ma li mb lm ls lt lu lv bi translated"><a class="ae lw" rel="noopener ugc nofollow" target="_blank" href="/benchmarking-command-line-tools-7d00ed4813cc">第4部分:针对grep的命令行基准测试</a></li></ul></div><div class="ab cl mc md hu me" role="separator"><span class="mf bw bk mg mh mi"/><span class="mf bw bk mg mh mi"/><span class="mf bw bk mg mh"/></div><div class="ij ik il im in"><p id="55fa" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">之前，我们<a class="ae lw" rel="noopener ugc nofollow" target="_blank" href="/how-to-build-a-text-filtering-log-simplifying-tool-in-go-b29d3067e092">构建了一个Go程序来删除不想要的文本</a>，我们<a class="ae lw" href="https://medium.com/@gourikabang1996/part-2-how-to-prepare-for-your-next-coding-interview-d048b188301e" rel="noopener">用正则表达式支持</a>扩展了它。现在，我们将通过比较最初的子串搜索方法和增加的正则表达式模式匹配来了解Go中的基准测试。请注意，这里使用的方法很简单，旨在促进基准测试讨论，而不是客观地证明一种方法严格地比另一种方法快。</p><p id="c8b5" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">Go的标准库<a class="ae lw" href="https://pkg.go.dev/testing" rel="noopener ugc nofollow" target="_blank">测试包</a>提供了广泛的测试支持(你可能已经见过表单<code class="fe mj mk ml mm b">TestXxx(t *testing.T)</code>的函数)，以及通过<a class="ae lw" href="https://pkg.go.dev/testing#B" rel="noopener ugc nofollow" target="_blank">类型B </a>的基准测试支持。<code class="fe mj mk ml mm b">B</code>便于管理基准计时、迭代等。，以及清除、记录或测试失败的典型实用函数。</p><p id="719e" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">使用这些工具，我们可以了解使用子串或模式匹配工具是否运行得更快(在这些场景下)。</p><h1 id="1294" class="mn mo iq bd mp mq mr ms mt mu mv mw mx jw my jx mz jz na ka nb kc nc kd nd ne bi translated">设定基准</h1><p id="a2ab" class="pw-post-body-paragraph kr ks iq kt b ku nf jr kw kx ng ju kz la nh lc ld le ni lg lh li nj lk ll lm ij bi translated">Go基准是位于<code class="fe mj mk ml mm b">&lt;filename&gt;_test.go</code>文件中的函数，其中<code class="fe mj mk ml mm b">&lt;filename&gt;</code>通常是包含要测试的函数的文件名。这两个文件通常在同一个包中，基准函数采用以下形式:</p><pre class="kg kh ki kj gt nk mm nl nm aw nn bi"><span id="f873" class="no mo iq mm b gy np nq l nr ns">func BenchmarkXxx(b *testing.B) { // benchmark code }</span></pre><p id="770a" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">在编写基准测试时，我们通常需要一些特定于代码的初始设置，然后进入一个循环，该循环将多次运行被测代码(由测试包确定<a class="ae lw" href="https://pkg.go.dev/testing#hdr-Benchmarks" rel="noopener ugc nofollow" target="_blank">)。最后，我们被告知运行了多少个循环，以及运行每个循环花费了(平均)多长时间。从那里，我们可以分析代码性能。</a></p><p id="642e" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">我们将从设置一个带有几行文本的<code class="fe mj mk ml mm b">[]string</code>开始——这对于子串和模式匹配搜索来说很常见。然后我们将构建一个包含一组<code class="fe mj mk ml mm b">keys</code>或<code class="fe mj mk ml mm b">pattern</code>的<code class="fe mj mk ml mm b">config</code>，然后我们将针对输入文本运行<code class="fe mj mk ml mm b">lineMatches()</code>(在基准循环中)，并查看每次迭代需要多长时间。我们将使用不同数量的关键短语和模式复杂性(每个都是为匹配相同的文本而构建的)来做这件事，并比较结果。</p><h1 id="3769" class="mn mo iq bd mp mq mr ms mt mu mv mw mx jw my jx mz jz na ka nb kc nc kd nd ne bi translated">建立基准</h1><p id="09cd" class="pw-post-body-paragraph kr ks iq kt b ku nf jr kw kx ng ju kz la nh lc ld le ni lg lh li nj lk ll lm ij bi translated">我们的基准将非常简单:它们都将使用相同的输入文本，并生成一个带有<code class="fe mj mk ml mm b">keys</code>或<code class="fe mj mk ml mm b">pattern</code>的<code class="fe mj mk ml mm b">config</code>。我们将为每种查询类型制定一致的子串搜索和模式匹配基准。然后，我们只需要运行测试并比较结果。</p><p id="6511" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">我们将使用以下内容作为输入测试(与<code class="fe mj mk ml mm b">example/input.txt</code>中相同):</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nt nu l"/></div></figure><h2 id="45b4" class="no mo iq bd mp nv nw dn mt nx ny dp mx la nz oa mz le ob oc nb li od oe nd of bi translated">基准匹配“hello”—这将匹配我们输入中的所有行</h2><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nt nu l"/></div></figure><h2 id="3581" class="no mo iq bd mp nv nw dn mt nx ny dp mx la nz oa mz le ob oc nb li od oe nd of bi translated">基准匹配“大”——这将匹配两个输入行</h2><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nt nu l"/></div></figure><h2 id="f47b" class="no mo iq bd mp nv nw dn mt nx ny dp mx la nz oa mz le ob oc nb li od oe nd of bi translated">基准匹配“大”、“亮”、“弯”和“亮”——这将匹配三条输入线</h2><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nt nu l"/></div></figure><h1 id="5793" class="mn mo iq bd mp mq mr ms mt mu mv mw mx jw my jx mz jz na ka nb kc nc kd nd ne bi translated">运行基准测试</h1><p id="6eb8" class="pw-post-body-paragraph kr ks iq kt b ku nf jr kw kx ng ju kz la nh lc ld le ni lg lh li nj lk ll lm ij bi translated">最后，我们可以通过运行以下命令来运行我们的所有基准:</p><p id="33cf" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated"><code class="fe mj mk ml mm b">go test -bench=.</code></p><p id="2666" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">在项目repo的根目录中，这会产生以下结果:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nt nu l"/></div></figure><p id="d394" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">第一列是基准的名称。第二列是使用了多少个循环(想想:<code class="fe mj mk ml mm b">b.N</code>的值)，第三列是运行一个循环所用的平均时间。在我们的例子中，每个循环在所有的<code class="fe mj mk ml mm b">inputText</code>中搜索子串或模式匹配。</p><p id="77ac" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">请注意，附加到每个测试名称的<code class="fe mj mk ml mm b">-10</code>表示用于测试的CPU内核数量(在我的例子中是10)。</p><p id="4093" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">我们可以看到，在Apple Silicon Mac上的上述测试中，子串搜索比实现的模式匹配快3.55倍到83.74倍。</p><h1 id="1d15" class="mn mo iq bd mp mq mr ms mt mu mv mw mx jw my jx mz jz na ka nb kc nc kd nd ne bi translated">包扎</h1><p id="f0dc" class="pw-post-body-paragraph kr ks iq kt b ku nf jr kw kx ng ju kz la nh lc ld le ni lg lh li nj lk ll lm ij bi translated">这是否意味着我们应该总是选择子串搜索？不一定。</p><p id="5d54" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">在软件方面，我们必须为正确的工作选择正确的工具。你能用锤子把螺丝拧进去吗？从技术上来说是的，但它远非理想。如果您可以用一个或几个子字符串匹配您关心的文本，这个工具可能会更快。</p><p id="c96e" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">但是，使用正则表达式有很多好处。它们通常可以在工具之间很好地转换，并且可以回答比子字符串更复杂的查询(没有明显的重复)。人们可能还会考虑这种性能差异转化为多少真实时间。正如我们所看到的，这将取决于查询复杂性和输入大小。</p><p id="afc7" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">在许多情况下，性能差异可能并不显著(几分之一秒到不到一分钟)。</p><p id="93e1" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">此外，请注意，上述测试并不全面，但可能代表了各种常见的查询。例如，很高兴看到性能如何随输入大小而扩展——这可以留给读者作为练习。如果初始设置需要很长时间，我们也可以选择在<code class="fe mj mk ml mm b">b.N</code>循环之前调用<code class="fe mj mk ml mm b">b.ResetTimer()</code>，但是这里没有必要这样做。和往常一样，测试包中的<a class="ae lw" href="https://pkg.go.dev/testing#hdr-Benchmarks" rel="noopener ugc nofollow" target="_blank">基准测试部分还有更多的内容需要深入研究！</a></p><p id="7ca7" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">如果您想查看基准测试的其他用例，请在评论中告诉我！在下一篇文章(四篇系列文章的最后一篇)中，我们将针对grep等工具对该工具进行一些命令行基准测试(感谢您的想法，Aaron！).</p></div></div>    
</body>
</html>