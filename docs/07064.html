<html>
<head>
<title>Single-Threaded and Asynchronous — How Does Node Do It?</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">单线程和异步Node是如何做到的？</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/single-threaded-and-asynchronous-how-does-node-do-it-d964100766a?source=collection_archive---------2-----------------------#2020-12-03">https://betterprogramming.pub/single-threaded-and-asynchronous-how-does-node-do-it-d964100766a?source=collection_archive---------2-----------------------#2020-12-03</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="6581" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">简单解释Node.js如何在幕后处理异步操作</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/b66cb172114159d5a106b819a71bf22a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*Y67nGQHG8P8AqXjj"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">Zachariah Aussi 在<a class="ae kv" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片。</p></figure><p id="32ac" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">JavaScript是单线程的，这一点你们很多人肯定已经听说过了。这仅仅意味着它一次只能执行一个任务。JavaScript中执行的所有任务都运行在一个叫做主线程<em class="ls">的线程上。</em></p><p id="72af" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">Node.js是一个JavaScript运行时环境，允许您解析、编译和执行JavaScript代码。Node在V8引擎的帮助下做到了这一点，V8引擎是谷歌用C++编写的开源JavaScript引擎。</p><p id="5e20" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">借助V8引擎，Node能够在用户看不到的情况下执行JavaScript和C++。这允许您在单线程环境中编写同步和异步JavaScript代码，而不必担心线程或并发性。</p></div><div class="ab cl lt lu hu lv" role="separator"><span class="lw bw bk lx ly lz"/><span class="lw bw bk lx ly lz"/><span class="lw bw bk lx ly"/></div><div class="ij ik il im in"><h1 id="3dc1" class="ma mb iq bd mc md me mf mg mh mi mj mk jw ml jx mm jz mn ka mo kc mp kd mq mr bi translated">事件循环</h1><p id="4799" class="pw-post-body-paragraph kw kx iq ky b kz ms jr lb lc mt ju le lf mu lh li lj mv ll lm ln mw lp lq lr ij bi translated"><em class="ls">事件循环</em>使节点应用程序能够在单线程上运行，但支持异步操作并具有非阻塞I/O。要理解事件循环的功能，我们必须知道<em class="ls">调用堆栈</em>、<em class="ls">消息队列</em>、<em class="ls"> </em>和c++ API<strong class="ky ir"><em class="ls"/></strong>是什么。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi mx"><img src="../Images/67255b8c825b4d7af916a6c131b10e68.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*MHCnvDUMSLTpHwA_Pm8YEQ.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">用于处理并发性的组件</p></figure><p id="e1ad" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">调用栈<strong class="ky ir"> </strong>基本上是一个LIFO(后进先出)栈，它跟踪下一个要在主线程上执行的任务。当您的代码被执行时，您在JavaScript代码中定义的任务被推入这个堆栈。让我们看看下面的代码是如何使用调用堆栈执行的:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="my mz l"/></div></figure><p id="8ce9" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">上面的代码是一个简单的同步程序，因此不需要c++ API或消息队列的参与。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi na"><img src="../Images/1b54cc28ed0dce317853798b2206878f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1082/format:webp/1*SuaGBC-ntcFLi2yN6lfB_w.png"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">来源:<a class="ae kv" href="https://nodejs.dev/learn/the-nodejs-event-loop" rel="noopener ugc nofollow" target="_blank">节点单据</a></p></figure><p id="91a8" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">程序中的每个任务都被推入调用栈<strong class="ky ir"> </strong>并以LIFO方式执行。控制台上的输出如下所示:</p><pre class="kg kh ki kj gt nb nc nd ne aw nf bi"><span id="e4f3" class="ng mb iq nc b gy nh ni l nj nk">foo<br/>bar<br/>baz</span></pre><p id="931e" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">当执行异步任务时，这个过程变得稍微复杂一点，这就是消息队列<strong class="ky ir"> </strong>和c++ API<strong class="ky ir"/>发挥作用的地方。假设您正在运行下面的代码片段:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="my mz l"/></div></figure><p id="c4fa" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">控制台上的输出如下所示:</p><pre class="kg kh ki kj gt nb nc nd ne aw nf bi"><span id="fa08" class="ng mb iq nc b gy nh ni l nj nk">foo<br/>baz<br/>bar</span></pre><p id="6206" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><code class="fe nl nm nn nc b">console.logs</code>的奇怪顺序背后的原因是，尽管<code class="fe nl nm nn nc b">setTimeout</code>的最小等待时间是零毫秒，节点还是将<code class="fe nl nm nn nc b">setTimeout</code>作为异步操作执行。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi no"><img src="../Images/d246f55b0ac305f42bc897477d5d0e90.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*HNAnYUieiLT3W_EqFA1aQw.gif"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">执行上面的代码片段</p></figure><p id="2a7d" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">Node将异步任务从调用堆栈卸载到c++ API，并使用系统内核执行它们。大多数系统内核都是多线程的，可以在后台同时执行多个任务。</p><p id="57eb" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">一旦一个异步任务完成，相关的回调函数被放入消息队列<em class="ls">。</em>它是一个FIFO(先进先出)队列，保持回调函数运行的正确顺序。</p><p id="3c6d" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><em class="ls"> </em>事件循环总是检查调用栈和消息队列<em class="ls">，</em>，如果调用栈<em class="ls"> </em>为空，它从消息队列中取出第一个任务并将其推送到调用栈。等待调用堆栈为空的事件循环解释了为什么前面代码片段的输出以奇怪的顺序记录。</p></div><div class="ab cl lt lu hu lv" role="separator"><span class="lw bw bk lx ly lz"/><span class="lw bw bk lx ly lz"/><span class="lw bw bk lx ly"/></div><div class="ij ik il im in"><h1 id="7d68" class="ma mb iq bd mc md me mf mg mh mi mj mk jw ml jx mm jz mn ka mo kc mp kd mq mr bi translated">作业队列</h1><p id="16ce" class="pw-post-body-paragraph kw kx iq ky b kz ms jr lb lc mt ju le lf mu lh li lj mv ll lm ln mw lp lq lr ij bi translated">Javascript ES6版本引入了<em class="ls">作业队列</em>。这有点类似于消息队列，但是有了作业队列，异步任务就不必等到调用堆栈上的所有任务都执行完了。这允许异步任务的结果在调用堆栈上的当前任务完成执行后立即执行。JavaScript promises的功能是基于作业队列的。</p></div><div class="ab cl lt lu hu lv" role="separator"><span class="lw bw bk lx ly lz"/><span class="lw bw bk lx ly lz"/><span class="lw bw bk lx ly"/></div><div class="ij ik il im in"><h1 id="8d93" class="ma mb iq bd mc md me mf mg mh mi mj mk jw ml jx mm jz mn ka mo kc mp kd mq mr bi translated">结论</h1><p id="6412" class="pw-post-body-paragraph kw kx iq ky b kz ms jr lb lc mt ju le lf mu lh li lj mv ll lm ln mw lp lq lr ij bi translated">Node允许用户创建能够执行异步操作的单线程应用程序，并在事件循环的帮助下拥有非阻塞I/O。由于Node是单线程的，用户不必担心线程或并发性，这是Node非常受欢迎的部分原因。</p><p id="b9dc" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">感谢阅读！</p></div></div>    
</body>
</html>