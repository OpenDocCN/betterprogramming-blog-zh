<html>
<head>
<title>How-to Use Custom View @decorators in Django</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何在Django中使用定制视图@decorators</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/custom-view-decorators-in-django-af50ea9b3994?source=collection_archive---------3-----------------------#2020-03-15">https://betterprogramming.pub/custom-view-decorators-in-django-af50ea9b3994?source=collection_archive---------3-----------------------#2020-03-15</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="eaf2" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">防止未经授权的用户访问视图，并使用@decorator方法提供反馈，例如RECAPTCHA受保护的表单提交</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/7e82cb831c416ca70c2a8b5fffa392d3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*OgYU5G5wxHWYepaP0CKUTw.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">图片来源:作者</p></figure><p id="b303" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">在本文中，我将尝试概述如何使用Django的<code class="fe lu lv lw lx b">user_passes_test</code>函数在Django中编写自己的定制装饰器。装饰器是一种基于请求方法或控制缓存行为来限制对视图的访问的方式。当您希望将登录用户与未经身份验证的用户分开，或者创建只有特权用户才能访问的管理页面时，这尤其有用。</p><p id="2e3b" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">Django有几个内置的装饰器，但是它们的主要问题是不提供用户反馈。Django还有一个内置的messages框架，它使用<code class="fe lu lv lw lx b">SESSION_COOKIE</code>来存储消息，并在提交或重新加载网页后显示这些消息，作为用户反馈的一种方式。我们将把这一点纳入我们的自定义装饰。我们还将使用谷歌的<code class="fe lu lv lw lx b">RECAPTCHA</code>来保护我们的表单提交免受垃圾邮件和滥用，并将它包含在一个装饰器中。</p><p id="72eb" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">总之，本文中我们要做的是:</p><ul class=""><li id="1b85" class="ly lz it la b lb lc le lf lh ma ll mb lp mc lt md me mf mg bi translated">调整Django的<code class="fe lu lv lw lx b">user_passes_test</code>,以便它使用Django的消息框架提供用户反馈</li><li id="0a83" class="ly lz it la b lb mh le mi lh mj ll mk lp ml lt md me mf mg bi translated">写三个自定义装饰:<code class="fe lu lv lw lx b">@superuser_required</code>、<code class="fe lu lv lw lx b">@staff_required</code>和<code class="fe lu lv lw lx b">@unauthenticated_required</code></li><li id="fbd1" class="ly lz it la b lb mh le mi lh mj ll mk lp ml lt md me mf mg bi translated">使用Google的<code class="fe lu lv lw lx b">RECAPTCHA</code>提供一个<code class="fe lu lv lw lx b">@check_recaptcha</code>装饰器来保护表单提交不被滥用</li></ul></div><div class="ab cl mm mn hx mo" role="separator"><span class="mp bw bk mq mr ms"/><span class="mp bw bk mq mr ms"/><span class="mp bw bk mq mr"/></div><div class="im in io ip iq"><h1 id="79b4" class="mt mu it bd mv mw mx my mz na nb nc nd jz ne ka nf kc ng kd nh kf ni kg nj nk bi translated">为什么是装修工？</h1><p id="cd5f" class="pw-post-body-paragraph ky kz it la b lb nl ju ld le nm jx lg lh nn lj lk ll no ln lo lp np lr ls lt im bi translated">装饰器是清理代码并将视图认证过程与视图功能分离的一种简单方法。Django有几个有用的内置装饰器，比如用于用户权限的<code class="fe lu lv lw lx b">@login_required</code>、<code class="fe lu lv lw lx b">@permission_required</code>和用于限制请求方法的<code class="fe lu lv lw lx b">@require_http_methods</code>(<code class="fe lu lv lw lx b">GET|POST</code>)。</p><p id="7cb4" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">当您想要执行某种定制视图认证时，您可以在视图本身中执行，如下所示。但是，当您将此身份验证应用于多个路由时，在每个路由中复制粘贴此示例会变得冗长。那时我开始编写定制装饰器，因为只需要一行代码<code class="fe lu lv lw lx b">@custom_decorator(args*)</code>来认证和保护视图。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nq nr l"/></div></figure><p id="5051" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">我们将在主应用程序文件夹的<code class="fe lu lv lw lx b">decorators.py</code>文件中编写这些自定义装饰器，这样我们就可以在所有应用程序中导入它们:</p><pre class="kj kk kl km gt ns lx nt nu aw nv bi"><span id="c84d" class="nw mu it lx b gy nx ny l nz oa">[projectname]/<br/>├── [projectname]/<br/>│   ├── __init__.py<br/>│   ├── <strong class="lx iu">decorators.py</strong><br/>│   ├── forms.py<br/>│   ├── models.py<br/>│   ├── settings.py<br/>│   ├── urls.py<br/>│   ├── views.py<br/>│   ├── wsgi.py<br/>└── manage.py</span></pre></div><div class="ab cl mm mn hx mo" role="separator"><span class="mp bw bk mq mr ms"/><span class="mp bw bk mq mr ms"/><span class="mp bw bk mq mr"/></div><div class="im in io ip iq"><h1 id="a9cd" class="mt mu it bd mv mw mx my mz na nb nc nd jz ne ka nf kc ng kd nh kf ni kg nj nk bi translated">有用户反馈的装饰者</h1><p id="9f66" class="pw-post-body-paragraph ky kz it la b lb nl ju ld le nm jx lg lh nn lj lk ll no ln lo lp np lr ls lt im bi translated">首先，我们将调整Django的<code class="fe lu lv lw lx b">user_passes_test</code>，这样它也可以通过<a class="ae ob" href="https://docs.djangoproject.com/en/3.0/ref/contrib/messages/" rel="noopener ugc nofollow" target="_blank">消息框架</a>提供用户反馈。我们将在检查用户认证的装饰器中使用这个自定义函数。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nq nr l"/></div></figure><p id="5819" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">为此我们需要做的就是添加行<code class="fe lu lv lw lx b">26-27</code>，提示如果我们的<code class="fe lu lv lw lx b">test_function</code>不成立，我们通过带有<code class="fe lu lv lw lx b">messages.add_message</code>的消息框架返回参数<code class="fe lu lv lw lx b">message</code>。<code class="fe lu lv lw lx b">redirect_field_name</code>是一个有用的参数，用于指示用户在登录后应该被重定向到哪里(例如，如果您正在访问一个<code class="fe lu lv lw lx b">login_required</code>路由&gt;登录页面&gt;回到相同的路由)，而<code class="fe lu lv lw lx b">login_url</code>是如果<code class="fe lu lv lw lx b">test_function</code>未被通过，您将被重定向到的路由。</p><p id="3e29" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated"><strong class="la iu">注意:</strong>我在一个<code class="fe lu lv lw lx b">config</code>对象中保存了我的配置，其中存储了我的Django项目的密钥，也存储了诸如Google <code class="fe lu lv lw lx b">RECAPTCHA</code>或电子邮件客户端等第三方的密钥。源代码来自<a class="ae ob" href="https://docs.djangoproject.com/en/2.2/_modules/django/contrib/auth/decorators/" rel="noopener ugc nofollow" target="_blank"> Django项目</a>。我设置了两个全局默认消息，在调用函数<code class="fe lu lv lw lx b">user_passes_test</code>时可以覆盖它们。</p></div><div class="ab cl mm mn hx mo" role="separator"><span class="mp bw bk mq mr ms"/><span class="mp bw bk mq mr ms"/><span class="mp bw bk mq mr"/></div><div class="im in io ip iq"><h1 id="20ef" class="mt mu it bd mv mw mx my mz na nb nc nd jz ne ka nf kc ng kd nh kf ni kg nj nk bi translated">用户认证装饰者</h1><p id="9902" class="pw-post-body-paragraph ky kz it la b lb nl ju ld le nm jx lg lh nn lj lk ll no ln lo lp np lr ls lt im bi translated">现在我们将使用我们的自定义<code class="fe lu lv lw lx b">user_passes_test</code>来编写我们的三个自定义装饰器。使用<code class="fe lu lv lw lx b">lambda</code>符号，我们可以创建一个无名函数来检查用户<code class="fe lu lv lw lx b">u</code>是否是<code class="fe lu lv lw lx b">active</code>，是否具有<code class="fe lu lv lw lx b">superuser</code>属性、<code class="fe lu lv lw lx b">is_staff</code>或<code class="fe lu lv lw lx b">is_authenticated</code>。这些用户属性都来自Django包含的<a class="ae ob" href="https://docs.djangoproject.com/en/3.0/topics/auth/default/" rel="noopener ugc nofollow" target="_blank">认证系统</a>。如果这些属性不成立，则返回错误消息。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nq nr l"/></div></figure><p id="cb47" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">然后我们可以在我们的视图中使用这些<code class="fe lu lv lw lx b">@decorators</code>。注意，您可以自顶向下链接多个decorators，如下所示。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nq nr l"/></div></figure></div><div class="ab cl mm mn hx mo" role="separator"><span class="mp bw bk mq mr ms"/><span class="mp bw bk mq mr ms"/><span class="mp bw bk mq mr"/></div><div class="im in io ip iq"><h1 id="e4a9" class="mt mu it bd mv mw mx my mz na nb nc nd jz ne ka nf kc ng kd nh kf ni kg nj nk bi translated">RECAPTCHA受保护视图</h1><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi oc"><img src="../Images/a4d4ff7c632a0502f0dbd5275285783c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1056/1*hSdvBDkQP-AwOcLnQiJemg.gif"/></div></figure><p id="b0ec" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">感谢<a class="ae ob" href="https://simpleisbetterthancomplex.com/tutorial/2017/02/21/how-to-add-recaptcha-to-django-site.html" rel="noopener ugc nofollow" target="_blank">熊伟·弗雷塔斯</a>为这个<code class="fe lu lv lw lx b">@check_recaptcha</code>装饰器提供代码。按照他的指南设置谷歌的<code class="fe lu lv lw lx b">RECAPTCHA</code>和设置<code class="fe lu lv lw lx b">@check_recaptcha</code>，这是超级简单的。你可以选择<code class="fe lu lv lw lx b">RECAPATCHA v2</code>或<code class="fe lu lv lw lx b">RECAPTCHA v3</code>。如果你想了解更多关于两者的区别和利弊，请阅读这篇文章。在RECAPTCHAs的HTML中包含元素，如下所示:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nq nr l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">Django Jinja2模板中带有RECAPTCHA的HTML表单</p></figure><p id="2b8d" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">这个装饰器所做的是通过发送请求并从Google获得响应来检查<code class="fe lu lv lw lx b">RECAPTCHA</code>。然后它用布尔值<code class="fe lu lv lw lx b">True|False</code>设置一个键<code class="fe lu lv lw lx b">recaptcha_is_valid</code>。然后，我们通过调用请求中的键来检查这个值:</p><pre class="kj kk kl km gt ns lx nt nu aw nv bi"><span id="d8d6" class="nw mu it lx b gy nx ny l nz oa"><strong class="lx iu">@check_recaptcha</strong><br/>@require_http_methods(["GET", "POST"])<br/>def register(request):<br/>    if request.method == 'POST':<br/>        form = LoginForm(request.POST)<br/>        if form.is_valid() and <strong class="lx iu">request.recaptcha_is_valid</strong>:<br/>            form.save()</span></pre><p id="e9f5" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">自定义装饰器的完整代码可以在GitHub上找到。在下一篇文章中，我们将通过<code class="fe lu lv lw lx b">@check_recaptcha</code>装饰器和电子邮件验证来介绍完整的用户注册路线。享受编码吧！</p></div></div>    
</body>
</html>