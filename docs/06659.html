<html>
<head>
<title>What Are NPM’s Optional Dependencies and When Should We Use Them?</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">NPM的可选依赖项是什么？我们应该在什么时候使用它们？</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/what-are-npms-optional-dependencies-and-when-should-we-use-them-796a6a964e73?source=collection_archive---------2-----------------------#2020-10-22">https://betterprogramming.pub/what-are-npms-optional-dependencies-and-when-should-we-use-them-796a6a964e73?source=collection_archive---------2-----------------------#2020-10-22</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="d301" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">加速构建并减少使用的磁盘空间</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/b92da152c0da3f761ecd7220baaf6a29.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*5xDOWEa6kzY2lWS3"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">克里斯·利维拉尼在<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的照片。</p></figure><p id="756e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">许多JavaScript项目依赖于许多第三方包。其中一些是必需的(例如像<a class="ae ky" href="https://getbootstrap.com/" rel="noopener ugc nofollow" target="_blank"> Bootstrap </a>这样的组件库)，而另一些只对开发有用(例如像<a class="ae ky" href="https://eslint.org/" rel="noopener ugc nofollow" target="_blank"> ESLint </a>这样的工具)。许多包依赖于其他库，这些库经常在著名的关于<code class="fe lv lw lx ly b">node_modules</code>文件夹有时太大的迷因中被引用。毕竟，有些项目包含了很少使用的依赖项(例如，对于一个定制的NPM脚本)，但是它们仍然每次都被安装。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi lz"><img src="../Images/bcf5b92589f51c45932119440f7907ea.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*21zgZSfQVefPsfyR.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">来自Reddit 的Meme。</p></figure><p id="1e57" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">较大的项目不仅会消耗大量磁盘空间，其结果是安装时间会更长。一些流行的包，如Puppeteer或Cypress，可能会下载大的二进制文件来运行。只要您不是每天都重置开发环境，并且有足够的磁盘空间，这可能根本不是问题。</p><p id="9265" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">然而，在像GitLab CI或GitHub Actions这样的持续集成工具上，这可能是一个更紧迫的问题:</p><ul class=""><li id="beec" class="ma mb it lb b lc ld lf lg li mc lm md lq me lu mf mg mh mi bi translated">如果您有许多开发人员和自动化程序(例如，为依赖关系更新创建pull请求的Dependabot)推送代码，您可能会超出您的使用配额。许多CI/CD工具都有使用配额(例如每月2000分钟)，如果超过配额，您需要支付额外的使用费用或等到下个月。</li><li id="7aae" class="ma mb it lb b lc mj lf mk li ml lm mm lq mn lu mf mg mh mi bi translated">安装项目的依赖项通常是执行一系列任务(如构建、林挺和测试应用程序)的先决条件。花费的时间越长，就需要等待越长的时间来发现代码中的潜在问题。</li></ul><p id="0a80" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">要安装或更新一个依赖项，您可以使用<code class="fe lv lw lx ly b">npm install</code>命令，而理想情况下，您可以使用<code class="fe lv lw lx ly b">npm ci</code>(从NPM版本6开始提供)来安装项目的所有依赖项。我在<a class="ae ky" href="https://medium.com/better-programming/npm-ci-vs-npm-install-which-should-you-use-in-your-node-js-projects-51e07cb71e26" rel="noopener">之前写过</a>关于<code class="fe lv lw lx ly b">npm ci</code>和<code class="fe lv lw lx ly b">npm install</code>的区别。</p></div><div class="ab cl mo mp hx mq" role="separator"><span class="mr bw bk ms mt mu"/><span class="mr bw bk ms mt mu"/><span class="mr bw bk ms mt"/></div><div class="im in io ip iq"><h1 id="8416" class="mv mw it bd mx my mz na nb nc nd ne nf jz ng ka nh kc ni kd nj kf nk kg nl nm bi translated">存在哪种依赖关系？</h1><p id="f214" class="pw-post-body-paragraph kz la it lb b lc nn ju le lf no jx lh li np lk ll lm nq lo lp lq nr ls lt lu im bi translated">JavaScript项目有一个<code class="fe lv lw lx ly b">package.json</code>，您可以在这里定义项目中使用的包。有不同种类的依赖关系:</p><ul class=""><li id="43c2" class="ma mb it lb b lc ld lf lg li mc lm md lq me lu mf mg mh mi bi translated"><code class="fe lv lw lx ly b"><a class="ae ky" href="https://docs.npmjs.com/files/package.json#dependencies" rel="noopener ugc nofollow" target="_blank">dependencies</a></code>始终安装。通常，如果缺少依赖项，就会出现问题。例如:像Bootstrap这样的UI库或者像React这样的框架。NPM建议不要在你的<code class="fe lv lw lx ly b">dependencies</code>物品中放置测试装具或运输工具。</li><li id="cdc9" class="ma mb it lb b lc mj lf mk li ml lm mm lq mn lu mf mg mh mi bi translated"><code class="fe lv lw lx ly b"><a class="ae ky" href="https://docs.npmjs.com/files/package.json#devdependencies" rel="noopener ugc nofollow" target="_blank">devDependencies</a></code>通常是在开发中使用的包，但对于项目的实际功能不是强制性的。例如:像ESLint这样的linters和Jest这样的测试框架。</li><li id="21ea" class="ma mb it lb b lc mj lf mk li ml lm mm lq mn lu mf mg mh mi bi translated"><code class="fe lv lw lx ly b"><a class="ae ky" href="https://docs.npmjs.com/files/package.json#peerdependencies" rel="noopener ugc nofollow" target="_blank">peerDependencies</a></code>是通常不会自动安装的软件包。在某些情况下，您希望表达您的包与另一个包的兼容性，而不包括您自己。当你错过<code class="fe lv lw lx ly b">peerDependencies</code>时，NPM会提醒你。示例:react-router包依赖于react的安装。</li><li id="e041" class="ma mb it lb b lc mj lf mk li ml lm mm lq mn lu mf mg mh mi bi translated"><code class="fe lv lw lx ly b"><a class="ae ky" href="https://docs.npmjs.com/files/package.json#bundleddependencies" rel="noopener ugc nofollow" target="_blank">bundledDependencies</a></code>是在发布包时将被捆绑的包。</li><li id="d500" class="ma mb it lb b lc mj lf mk li ml lm mm lq mn lu mf mg mh mi bi translated">最后，<code class="fe lv lw lx ly b"><a class="ae ky" href="https://docs.npmjs.com/files/package.json#optionaldependencies" rel="noopener ugc nofollow" target="_blank">optionalDependencies</a></code>是不一定需要安装的依赖项。如果可以使用一个依赖项，但是如果找不到或者安装失败，您希望npm继续，那么您可以将它放在<code class="fe lv lw lx ly b">optionalDependencies</code>对象中。</li></ul><p id="29d6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们假设您有一个web应用程序，持续集成和部署，以及一套使用Cypress的端到端测试。看一下下面的CI管道。它由四个不同的并行工作(构建、林挺、单元测试和端到端测试)组成，所有这些工作的第一步都需要安装项目依赖关系。然而，其中只有一个真正需要Cypress，然而我们总是为每个任务安装所有的包。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ns"><img src="../Images/2f3582302f59020692af8aeb66064b27.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*TDViSkpX9M0YMFY0A0A8eQ.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">作者照片。</p></figure><p id="e4ad" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">因为运行应用程序不需要Cypress，所以我们可以将它作为一个dev依赖项来安装。这已经是很好的一步，但我们可以更进一步。通过安装Cypress作为一个可选的依赖项，我们声明它是一个不一定需要安装的可选依赖项。</p><p id="fb97" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">请注意，处理可选依赖项的缺乏仍然是您的程序的责任。因此，您需要评估一个依赖项是否真的是可选的，并且您可能需要在运行时检查一个可选的依赖项是否真的被安装了。你也应该把这些知识传播给你的同事。否则，经验较少的开发人员可能不理解为什么在他们建立项目或引入新的依赖项时会缺少某些依赖项。</p></div><div class="ab cl mo mp hx mq" role="separator"><span class="mr bw bk ms mt mu"/><span class="mr bw bk ms mt mu"/><span class="mr bw bk ms mt"/></div><div class="im in io ip iq"><h1 id="fd2d" class="mv mw it bd mx my mz na nb nc nd ne nf jz ng ka nh kc ni kd nj kf nk kg nl nm bi translated">如何使用可选的依赖项来加速安装</h1><ul class=""><li id="1611" class="ma mb it lb b lc nn lf no li nt lm nu lq nv lu mf mg mh mi bi translated">执行<code class="fe lv lw lx ly b">npm install someDependency --save-optional</code>安装一个软件包作为可选的依赖项。安装包将被放入<code class="fe lv lw lx ly b">optionalDependencies</code>。</li><li id="391e" class="ma mb it lb b lc mj lf mk li ml lm mm lq mn lu mf mg mh mi bi translated">当你想避免安装可选的依赖项时，你可以执行<code class="fe lv lw lx ly b">npm ci --no-optional</code>(比如在像GitLab CI这样的CI工具上)。</li><li id="1168" class="ma mb it lb b lc mj lf mk li ml lm mm lq mn lu mf mg mh mi bi translated">使用<code class="fe lv lw lx ly b">npm ci</code>安装所有的依赖项，包括可选的依赖项(例如在您的开发环境中)。</li></ul><p id="0dae" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我在我的本地机器(一台iMac 4K)和GitLab CI上测量了差异。该项目是一个中等规模的Angular项目，使用Cypress进行端到端测试。我做的唯一一件事是将Cypress从一个开发依赖项变成一个可选依赖项。您可以看到，与使用<code class="fe lv lw lx ly b">npm ci</code>相比，执行<code class="fe lv lw lx ly b">npm ci --no-optional</code>时安装软件包的时间和数量都大大减少了:</p><ul class=""><li id="d868" class="ma mb it lb b lc ld lf lg li mc lm md lq me lu mf mg mh mi bi translated">之前:使用<code class="fe lv lw lx ly b">npm ci</code>在大约67-72秒内添加了1，637个包，以及存储在任何项目之外的大约550 MB缓存(在Mac上:<code class="fe lv lw lx ly b">/Users/myusername/Library/Caches/Cypress</code>)。</li><li id="801c" class="ma mb it lb b lc mj lf mk li ml lm mm lq mn lu mf mg mh mi bi translated">之后:使用<code class="fe lv lw lx ly b">npm ci --no-optional</code>在大约27-38秒内添加了1，514个包，没有任何由Cypress创建的缓存，因为这个包根本没有安装。</li></ul></div><div class="ab cl mo mp hx mq" role="separator"><span class="mr bw bk ms mt mu"/><span class="mr bw bk ms mt mu"/><span class="mr bw bk ms mt"/></div><div class="im in io ip iq"><h1 id="9b44" class="mv mw it bd mx my mz na nb nc nd ne nf jz ng ka nh kc ni kd nj kf nk kg nl nm bi translated">结论</h1><p id="1fc3" class="pw-post-body-paragraph kz la it lb b lc nn ju le lf no jx lh li np lk ll lm nq lo lp lq nr ls lt lu im bi translated">感谢您阅读这篇短文。如您所见，NPM允许我们指定在节点项目中如何使用依赖关系。可选地安装一个依赖项是加快节点项目安装过程的好选择。但是这也不是什么灵丹妙药，因为没有多少依赖项是真正可选的。</p><p id="04b6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">你如何使用可选的依赖关系？请在评论中告诉我。</p></div></div>    
</body>
</html>