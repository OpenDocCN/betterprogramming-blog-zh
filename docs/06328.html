<html>
<head>
<title>Building Chrome Extensions: Communicating Between Scripts</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">构建Chrome扩展:脚本间的通信</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/building-chrome-extensions-communicating-between-scripts-75e1dbf12bb7?source=collection_archive---------1-----------------------#2020-09-22">https://betterprogramming.pub/building-chrome-extensions-communicating-between-scripts-75e1dbf12bb7?source=collection_archive---------1-----------------------#2020-09-22</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="1334" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">扩展领域的事情与你可能习惯的有些不同</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/6fd1f119754c12b0caf30fe1b667aebd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*fZSOHJkCM5zcxMVlijfU9Q.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">改编自<a class="ae ky" href="https://www.freepik.com/rawpixel-com" rel="noopener ugc nofollow" target="_blank">rawpixel.com</a>在<a class="ae ky" href="https://www.freepik.com/free-vector/communication-information-website-graphic_2922422.htm" rel="noopener ugc nofollow" target="_blank"> freepik </a>和<a class="ae ky" href="https://pixabay.com/users/WikimediaImages-1185597/?utm_source=link-attribution&amp;amp;utm_medium=referral&amp;amp;utm_campaign=image&amp;amp;utm_content=1326908" rel="noopener ugc nofollow" target="_blank"> WikimediaImages </a>在<a class="ae ky" href="https://pixabay.com/?utm_source=link-attribution&amp;amp;utm_medium=referral&amp;amp;utm_campaign=image&amp;amp;utm_content=1326908" rel="noopener ugc nofollow" target="_blank"> Pixabay </a>的资产。</p></figure><p id="f04b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">不久前，我开始构建我的第一个Chrome扩展。最近，我进入了web开发的世界，并通过构建一个React项目进行了尝试，我觉得我拥有了迎接这一新挑战所必需的工具。</p><p id="c46a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">虽然我这样想并没有完全错，但如果说我不必重新思考我设计项目的方式，这并不是全部事实。</p><p id="86de" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我在开发的早期就意识到了这一点。你看，当开发任何种类的应用程序时，随着我们的项目变得越来越大，我们将不可避免地将它分成单独的类、函数，最终是脚本。没有什么迫使我们这样做，但除非你想以翻拍1958年的<a class="ae ky" href="https://sourcemaking.com/antipatterns/the-blob" rel="noopener ugc nofollow" target="_blank"> The Blob </a>结束，否则这样做是明智的。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="8ffe" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">脚本互操作性的简单方法</h1><p id="6450" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">在我的例子中，扩展需要做以下事情:每当用户在文本字段中进行任何更改时，其内容都需要被解析，并相应地显示为其右侧表格中的条目。然后，只要“日志条目！”按钮，这些解析后的条目将用于调用网页上的更改。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi mz"><img src="../Images/7a6012783f18bf2de9d579fc3c4c4a74.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*BeBbPbDHWIVcr_2f3UxUlA.gif"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">扩展弹出窗口演示(未显示网页操作)</p></figure><p id="51ad" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">为此，我将代码的功能分解为以下脚本:</p><ul class=""><li id="394f" class="na nb it lb b lc ld lf lg li nc lm nd lq ne lu nf ng nh ni bi translated"><code class="fe nj nk nl nm b">popup.js</code>:包含弹出框及其组件的行为。例如，当文本被插入文本字段或按下按钮时会发生什么。</li><li id="17a9" class="na nb it lb b lc nn lf no li np lm nq lq nr lu nf ng nh ni bi translated"><code class="fe nj nk nl nm b">parser.js</code>:包含按照特定规则解析文本并以特定格式返回解析结果的功能。</li><li id="8b6e" class="na nb it lb b lc nn lf no li np lm nq lq nr lu nf ng nh ni bi translated"><code class="fe nj nk nl nm b">crawler.js</code>:包含利用数据抓取网页以搜索特定元素并进行某些修改的功能。</li></ul><p id="9e6b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这里有一个明显的相互依存关系。<code class="fe nj nk nl nm b">crawler.js</code> <em class="ns"> </em>需要以某种格式呈现给它的数据，以便能够成功地抓取和修改网页。这些数据由<code class="fe nj nk nl nm b">parser.js</code>提供，它从弹出窗口的文本字段接收输入，由<code class="fe nj nk nl nm b">popup.js</code>管理。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nt"><img src="../Images/d26bd2b14cd1182af960bafd5d4da0a9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*0buz74XLTttIEe3VppnMPw.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">交互图—蚂蚁资产由<a class="ae ky" href="https://www.freepik.com/vectors/nature" rel="noopener ugc nofollow" target="_blank"> freepik </a>提供。</p></figure><p id="4f5b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果你像我一样，被React中使用<a class="ae ky" href="https://exploringjs.com/es6/ch_overviews.html#overview-entry-modules" rel="noopener ugc nofollow" target="_blank"> ES6模块</a>的简单性宠坏了，你的第一个想法可能是说，“好吧，没问题。我就把<code class="fe nj nk nl nm b">parser.js</code> <em class="ns"> </em>和<code class="fe nj nk nl nm b">crawler.js</code> <em class="ns"> </em>中的相关函数导出来，在<code class="fe nj nk nl nm b">popup.js</code>中导入。”</p><p id="a512" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">然而，我当时的普通ES5 JavaScript代码库有其他想法，当我试图将ES6特性集成到我的项目中时，我已经发现了让我的扩展脚本相互对话的正确方法。</p><p id="b508" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><em class="ns">有趣的事实:在ES6集成的道路上，我最终确实实现了向</em><a class="ae ky" href="https://parceljs.org/" rel="noopener ugc nofollow" target="_blank"><em class="ns">package</em></a><em class="ns">的飞跃(在</em><a class="ae ky" href="https://webpack.js.org/" rel="noopener ugc nofollow" target="_blank"><em class="ns">web pack</em></a><em class="ns">让我质疑自己的人生选择之后，我可以向任何开始使用bundlers的人强烈推荐这款产品)。使用bundler的部分动机是需要</em> <a class="ae ky" href="https://forum.freecodecamp.org/t/referencing-external-libraries-and-ui-components-in-vanilla-js-project/415730/7" rel="noopener ugc nofollow" target="_blank"> <em class="ns">轻松引用外部库</em> </a> <em class="ns">。</em></p><p id="f958" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><em class="ns">由于软件包预配置了</em> <a class="ae ky" href="https://babeljs.io/" rel="noopener ugc nofollow" target="_blank"> <em class="ns">巴别塔</em> </a> <em class="ns">，所以我也能够使用ES6的特性，比如导入/导出，这使得我能够以更熟悉的方式处理不同的文件。然而，这并不是Chrome extensions的通信方式，我们很快就会看到这一点。</em></p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="026b" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">内容和背景脚本</h1><p id="9448" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">Chrome扩展通常由各种内聚的部分或组件组成，每一个都有不同的职责。为了让所有这些组件一起工作，它们通过<a class="ae ky" href="https://developer.chrome.com/extensions/messaging" rel="noopener ugc nofollow" target="_blank">消息传递</a>进行通信。</p><p id="142a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在我们的例子中，<code class="fe nj nk nl nm b">crawler.js</code> <em class="ns"> </em>需要与网页交互，因此被声明为所谓的<a class="ae ky" href="https://developer.chrome.com/extensions/content_scripts" rel="noopener ugc nofollow" target="_blank">内容脚本</a>。内容脚本是那些需要能够在网页上执行操作的脚本，比如DOM操作。</p><p id="219b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">另一方面，<code class="fe nj nk nl nm b">parser.js</code>不需要这样，但它仍然需要从<code class="fe nj nk nl nm b">popup.js</code> <em class="ns"> </em>接收数据并发回。因此，我们将它声明为一个背景脚本。</p><p id="39d6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">顾名思义，后台脚本在后台运行。它的作用包括监听和响应浏览器事件(例如，关闭标签页，在扩展被安装(卸载)时执行操作)，以及发送和接收消息。</p><p id="e2f7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">内容和后台脚本的声明在扩展的<code class="fe nj nk nl nm b">manifest.json</code>中完成。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nu nv l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">扩展的一部分<a class="ae ky" href="https://developer.chrome.com/extensions/manifest" rel="noopener ugc nofollow" target="_blank"> manifest.json </a>显示了背景和内容脚本声明</p></figure></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="bd69" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">消息传递101</h1><p id="a39f" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">现在我们已经知道了足够多的信息，最终可以了解事情的本质。</p><p id="6c86" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe nj nk nl nm b">popup.js</code>作为这里的沟通发起者，需要发出两个信息。一个是当文本字段改变时，另一个是当按钮被点击时。根据接收者是谁，它使用两种方法之一来完成。如果接收方是内容脚本，则使用<code class="fe nj nk nl nm b"><a class="ae ky" href="https://developer.chrome.com/extensions/tabs#method-sendMessage" rel="noopener ugc nofollow" target="_blank">chrome.tabs.sendMessage()</a></code>。否则就是<code class="fe nj nk nl nm b"><a class="ae ky" href="https://developer.chrome.com/extensions/runtime#method-sendMessage" rel="noopener ugc nofollow" target="_blank">chrome.runtime.sendMessage()</a></code>。</p><h2 id="c895" class="nw md it bd me nx ny dn mi nz oa dp mm li ob oc mo lm od oe mq lq of og ms oh bi translated">非内容脚本通信</h2><p id="ff47" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">先说第二种情况。下面是一个在<code class="fe nj nk nl nm b">popup.js</code>中可能会出现的例子:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nu nv l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">从popup.js发送到parser.js的消息示例</p></figure><p id="1d19" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这里，我们假设这段代码在文本字段发生变化时在<code class="fe nj nk nl nm b">popup.js</code> <em class="ns"> </em>中执行。如您所见，我们已经传递了两个参数<code class="fe nj nk nl nm b">runtime.sendMessage()</code>:一个必需的对象和一个可选的回调。对象应该包含什么完全由您决定，但是在我的例子中，我已经包含了两个属性。第一个是<code class="fe nj nk nl nm b">msg</code>，包含一个字符串标识符，接收端检查该标识符以确定如何处理请求。第二个属性<code class="fe nj nk nl nm b">data</code>，仅仅包含了修改后文本字段的新内容。</p><p id="2486" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">作为第二个参数传递给<code class="fe nj nk nl nm b">runtime.sendMessage()</code>的回调函数必须只有一个参数。此函数处理此消息的收件人发送的响应。</p><p id="e262" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><em class="ns">注:该消息的预期接收人为</em> <code class="fe nj nk nl nm b"><em class="ns">parser.js</em></code> <em class="ns">。然而，我们很快就会看到，任何监听</em> <code class="fe nj nk nl nm b"><em class="ns">onMessage</em></code> <em class="ns">事件的后台脚本都会收到它。这也是为什么在传递的对象中有一个像</em> <code class="fe nj nk nl nm b"><em class="ns">msg</em></code> <em class="ns">这样的属性很有用的另一个原因。它充当标识符，以便收件人可以确定邮件是否是给他们的。</em></p><h2 id="1122" class="nw md it bd me nx ny dn mi nz oa dp mm li ob oc mo lm od oe mq lq of og ms oh bi translated">内容脚本通信</h2><p id="75fe" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">如前所述，当接收者是内容脚本时，我们使用<code class="fe nj nk nl nm b">tabs.sendMessage()</code>。下面是在<code class="fe nj nk nl nm b">popup.js</code>中可能出现的情况:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nu nv l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">从popup.js发送到crawler.js的消息示例</p></figure><p id="9922" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">你会注意到这一次我们没有直接发送信息。使用<code class="fe nj nk nl nm b">tabs.sendMessage()</code>，我们需要知道将消息发送到哪个选项卡。为此，我们首先调用<code class="fe nj nk nl nm b"><a class="ae ky" href="https://developer.chrome.com/extensions/tabs#method-query" rel="noopener ugc nofollow" target="_blank">tabs.query</a>()</code>，它检索所有匹配第一个参数中指定的属性的选项卡。因为我的扩展弹出窗口只有在我在一个特定的URL上时才会激活，所以我可以简单地在当前窗口中获取活动标签，并确保它就是我需要的那个。</p><p id="c611" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><em class="ns">提示:要检索所有标签，传递一个空对象作为第一个参数。</em></p><p id="cc5b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">检索到的选项卡被传递给第二个参数中指定的回调。这是我们发送实际消息的地方，现在看起来应该很熟悉了。唯一不同的是，对于<code class="fe nj nk nl nm b">tabs.sendMessage()</code>，我们需要传递相关选项卡的ID。其余部分遵循与之前相同的结构。</p><h2 id="548b" class="nw md it bd me nx ny dn mi nz oa dp mm li ob oc mo lm od oe mq lq of og ms oh bi translated">接收和回复消息</h2><p id="cf2d" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">在接收端，这很简单。在那里，我们使用<code class="fe nj nk nl nm b"><a class="ae ky" href="https://developer.chrome.com/extensions/runtime#event-onMessage" rel="noopener ugc nofollow" target="_blank">chrome.runtime.onMessage.addListener()</a></code>。本质上，它所做的是向<code class="fe nj nk nl nm b">onMessage</code>事件添加一个监听器，每当使用我们见过的任何一种<code class="fe nj nk nl nm b">sendMessage()</code>变体发送消息时，这个监听器就会被触发。</p><p id="8ff4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">该方法将一个回调函数作为它的单个参数，当事件被触发时(即收到一条消息)调用该函数。这个回调又接受三个参数:消息的内容、发送者和一个函数，如果要发回响应，就调用这个函数。此函数接受object类型的单个参数。那是冗长的。让我们看一些代码。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nu nv l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">如何在parser.js中接收消息的示例。注意请求中的msg字段如何被用作消息的标识符</p></figure></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="663e" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">好处:内容脚本之间的通信</h1><p id="0523" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">到目前为止，一切顺利。但是如果我们不只是有一个内容脚本，就像这里的<code class="fe nj nk nl nm b">crawler.js</code>一样，而是有两个想要交流的脚本，那会怎么样呢？继续我们正在运行的例子，假设我们将<code class="fe nj nk nl nm b">crawler.js</code>分成两个独立的内容脚本:<code class="fe nj nk nl nm b">finder.js</code>和<code class="fe nj nk nl nm b">filler.js</code>。顾名思义，前者搜索网页上的某些元素，而后者用内容填充这些元素。</p><p id="cb7a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe nj nk nl nm b">finder.js</code> <em class="ns"> </em>希望能够将找到的元素发送给<code class="fe nj nk nl nm b">filler.js</code>。“嗯，没什么大不了的，”我听到你说。我们就像之前一样用<code class="fe nj nk nl nm b">tabs.sendMessage()</code>和<code class="fe nj nk nl nm b">onMessage.addListener()</code>。虽然我不想带来坏消息，但也不尽然。事实证明，内容脚本不能直接通信。这实际上让我挠头了一段时间。幸运的是，解决方法很简单。</p><p id="f9f4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><em class="ns">有趣的事实:如果你想知道我为什么会遇到这个问题，因为我只有一个内容脚本，在某些时候，我不必要地将</em> <code class="fe nj nk nl nm b"><em class="ns">popup.js</em></code> <em class="ns">也注册为内容脚本，因此它的消息没有使用直接通信路径到达</em> <code class="fe nj nk nl nm b"><em class="ns">crawler.js</em></code> <em class="ns">。我已经改正了这个错误，但是学到的教训仍然存在。</em></p><p id="70c5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们需要做的就是让一个后台脚本在这个交换中充当中间人。这看起来如下。不要被大小吓倒。出于显示的目的，我已经将三个脚本中的代码压缩成一个要点。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nu nv l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">展示两个内容脚本之间通信的示例。请注意，每个代码片段都包含在各自的演员脚本中</p></figure><p id="7637" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">本质上，除了一点逻辑上的变化，这里没有什么新的东西。我们使用后台脚本在通信方之间传递消息，而不是直接的点对点通信(即内容脚本)。</p><p id="d628" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这里需要注意的一点是，我们在后台脚本的<code class="fe nj nk nl nm b">addListener()</code>中返回了<code class="fe nj nk nl nm b">true</code>。无需过多赘述，这将保持后台脚本的通信通道打开，以允许<code class="fe nj nk nl nm b">filler.js</code>的响应到达<code class="fe nj nk nl nm b">finder.js</code>。关于这方面的更多信息，请看一下<a class="ae ky" href="https://developer.chrome.com/extensions/runtime#event-onMessage" rel="noopener ugc nofollow" target="_blank"> Chrome的文档</a>中对<code class="fe nj nk nl nm b">runtime.onMessage.addListener()</code>的<code class="fe nj nk nl nm b">sendResponse</code>参数的描述。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="ab64" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">结论</h1><p id="dfba" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">谢谢你留下来！Chrome扩展可能非常特殊，当你陷入困境时，互联网上通常没有太多内容。所以我希望你能从中找到一些有用的东西。</p><p id="f21b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">一如既往，我很高兴听到你的想法，并回答你可能有的任何问题。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="2cbf" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">资源</h1><ul class=""><li id="c389" class="na nb it lb b lc mu lf mv li oi lm oj lq ok lu nf ng nh ni bi translated"><a class="ae ky" href="https://github.com/osharaki/sparkpeople-logger" rel="noopener ugc nofollow" target="_blank">项目回购</a></li><li id="e315" class="na nb it lb b lc nn lf no li np lm nq lq nr lu nf ng nh ni bi translated"><a class="ae ky" href="https://developer.chrome.com/extensions" rel="noopener ugc nofollow" target="_blank"> Chrome扩展:链接到更多资源的绝佳起点</a></li><li id="8412" class="na nb it lb b lc nn lf no li np lm nq lq nr lu nf ng nh ni bi translated"><a class="ae ky" href="https://medium.com/@crohacz_86666/basics-of-modular-javascript-2395c82dd93a" rel="noopener">Javascript模块的精彩介绍</a></li><li id="e33a" class="na nb it lb b lc nn lf no li np lm nq lq nr lu nf ng nh ni bi translated"><a class="ae ky" href="https://exploringjs.com/es6/ch_modules.html" rel="noopener ugc nofollow" target="_blank">深度Javascript模块</a></li><li id="d1bc" class="na nb it lb b lc nn lf no li np lm nq lq nr lu nf ng nh ni bi translated"><a class="ae ky" href="https://exploringjs.com/es6/ch_overviews.html" rel="noopener ugc nofollow" target="_blank">ES6特性概述</a></li><li id="4831" class="na nb it lb b lc nn lf no li np lm nq lq nr lu nf ng nh ni bi translated"><a class="ae ky" href="https://sourcemaking.com/antipatterns/the-blob" rel="noopener ugc nofollow" target="_blank">斑点反模式</a></li></ul></div></div>    
</body>
</html>