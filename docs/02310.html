<html>
<head>
<title>The 5 Principles of Dependency Injection</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">依赖注入的5个原则</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/five-principles-of-dependency-injection-5bd0cca9cb04?source=collection_archive---------2-----------------------#2019-11-21">https://betterprogramming.pub/five-principles-of-dependency-injection-5bd0cca9cb04?source=collection_archive---------2-----------------------#2019-11-21</a></blockquote><div><div class="fc ii ij ik il im"/><div class="in io ip iq ir"><div class=""/><div class=""><h2 id="4f55" class="pw-subtitle-paragraph jr it iu bd b js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki dk translated">这很容易做到，而且非常值得努力</h2></div><figure class="kk kl km kn gu ko gi gj paragraph-image"><div role="button" tabindex="0" class="kp kq di kr bf ks"><div class="gi gj kj"><img src="../Images/6f6abc13335e534fe9e157c5c96a45b4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*dL6_wyHG-txfR51STNrBIA.jpeg"/></div></div><p class="kv kw gk gi gj kx ky bd b be z dk translated">照片由<a class="ae kz" href="https://unsplash.com/@siora18?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Siora摄影</a>在<a class="ae kz" href="https://unsplash.com/s/photos/five?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</p></figure><p id="d18b" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated"><a class="ae kz" href="https://medium.com/better-programming/what-is-dependency-injection-b2671b1ea90a" rel="noopener">在我之前的文章</a>中，我讨论了<em class="lw">什么是依赖注入(DI)以及DI如何通过利用抽象和解耦来帮助你的代码更易维护。</em></p><p id="ba92" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">这篇文章更加实用，提供了你可以着手进行DI的五种方法——描述了如何进行。遵循这五个基本思想，你将会做DI，而不需要比你现在如何编码更多的额外努力。</p></div><div class="ab cl lx ly hy lz" role="separator"><span class="ma bw bk mb mc md"/><span class="ma bw bk mb mc md"/><span class="ma bw bk mb mc"/></div><div class="in io ip iq ir"><h1 id="d74e" class="me mf iu bd mg mh mi mj mk ml mm mn mo ka mp kb mq kd mr ke ms kg mt kh mu mv bi translated">要遵循的五个基本原则</h1><h2 id="9e28" class="mw mf iu bd mg mx my dn mk mz na dp mo lj nb nc mq ln nd ne ms lr nf ng mu nh bi translated">针对抽象而非实现进行编码</h2><p id="a795" class="pw-post-body-paragraph la lb iu lc b ld ni jv lf lg nj jy li lj nk ll lm ln nl lp lq lr nm lt lu lv in bi translated">“四人帮”(“设计模式”一书的作者)的Erich Gamma被认为是创造了这个短语，这是一个强大而基本的想法。如果你只教新开发人员一件事，那应该是这句格言。</p><p id="6c83" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">抽象——通常是接口，但并不总是如此(见下文)——是灵活的。接口(或抽象类)可以通过多种方式实现。甚至在实现完成之前，就可以对接口进行编码。如果你为一个实现编码，你正在创建一个紧密耦合且不灵活的系统。不要把自己局限在一个单一的实现中。相反，使用抽象，让你的代码变得柔软、可重用和灵活。</p><h2 id="2611" class="mw mf iu bd mg mx my dn mk mz na dp mo lj nb nc mq ln nd ne ms lr nf ng mu nh bi translated">永远不要创造不该创造的东西</h2><p id="0387" class="pw-post-body-paragraph la lb iu lc b ld ni jv lf lg nj jy li lj nk ll lm ln nl lp lq lr nm lt lu lv in bi translated">你的类应该遵循<a class="ae kz" href="https://en.wikipedia.org/wiki/Single_responsibility_principle" rel="noopener ugc nofollow" target="_blank">单一责任原则</a>——即一个类应该只做一件事。</p><p id="b4b9" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">如果他们这样做了，那么他们就不应该创造东西，因为这就构成了他们正在做的两件事。相反，他们应该要求他们需要的功能，并让其他人来创建和提供这些功能。</p><p id="567f" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated"><strong class="lc iv">可创造与可注入</strong></p><p id="5b94" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">那么应该创造什么呢？嗯，我们应该关心两种不同的对象:可创建的和可注入的。</p><p id="655d" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">可创建类是您应该继续创建的类。它们是常见且众所周知的运行时库或实用程序类。</p><p id="1896" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">通常，运行库中的类应该被认为是可创建的。像这样的类不应该被注入，而应该由你的类创建。它们的寿命通常很短，通常不会超过一种方法的寿命。如果类整体需要它们，可以在构造函数中创建它们。应该只将其他可创建对象传递给可创建对象的构造函数。</p><p id="7549" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">另一方面，可注入类是我们从来不想直接创建的类。它们是我们不想硬编码依赖的类类型，应该总是通过DI传递。</p><p id="e21b" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">它们通常会作为构造函数中的依赖项被请求。遵循上面的规则，应该通过接口引用可注入对象，而不是直接引用实例。</p><p id="bafd" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">可注入类通常是您作为业务逻辑的一部分编写的类。它们应该总是隐藏在抽象背后，通常是接口。还要注意，可注入对象可以在其构造函数中请求其他可注入对象。</p><h2 id="7051" class="mw mf iu bd mg mx my dn mk mz na dp mo lj nb nc mq ln nd ne ms lr nf ng mu nh bi translated">保持构造函数简单</h2><p id="2771" class="pw-post-body-paragraph la lb iu lc b ld ni jv lf lg nj jy li lj nk ll lm ln nl lp lq lr nm lt lu lv in bi translated">构造函数应该保持简单。一个类的构造函数不应该做任何工作——也就是说，它们不应该做任何事情，除了检查<code class="fe nn no np nq b">null</code>，创建可创建的对象，以及存储依赖关系以备后用。它们不应该包含任何编码逻辑。一个类的构造函数中没有检查<code class="fe nn no np nq b">null</code>的<code class="fe nn no np nq b">if</code>子句要求将该类分成两个类。(有一些方法可以检查不涉及<code class="fe nn no np nq b">if</code>语句的空值参数。)</p><p id="47da" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">复杂的构造函数是你的类做得太多的明显标志。保持构造函数简短，没有任何逻辑。</p><h2 id="233a" class="mw mf iu bd mg mx my dn mk mz na dp mo lj nb nc mq ln nd ne ms lr nf ng mu nh bi translated">不要对实现做任何假设</h2><p id="4607" class="pw-post-body-paragraph la lb iu lc b ld ni jv lf lg nj jy li lj nk ll lm ln nl lp lq lr nm lt lu lv in bi translated">当然，没有实现，接口是没有用的。然而，作为开发人员，您永远不应该对该实现做任何假设。</p><p id="42bf" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">您应该只根据接口达成的约定进行编码。您可能已经编写了实现，但是您不应该在编写接口代码时考虑到该实现。换句话说，针对您的接口进行编码，就好像一个全新的、更好的接口实现即将出现一样。</p><p id="1969" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">一个设计良好的界面会告诉你需要做什么以及如何使用。该接口的实现对于您使用该接口应该是无关紧要的。</p><h2 id="022f" class="mw mf iu bd mg mx my dn mk mz na dp mo lj nb nc mq ln nd ne ms lr nf ng mu nh bi translated">不要假设接口是抽象的</h2><p id="888e" class="pw-post-body-paragraph la lb iu lc b ld ni jv lf lg nj jy li lj nk ll lm ln nl lp lq lr nm lt lu lv in bi translated">界面很好，我当然会一直赞美它们。然而，重要的是要认识到不是每个接口都是抽象的。</p><p id="c8fd" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">例如，如果你的接口是你的类的公共部分的精确表示，你真的没有抽象任何东西，对吗？(这样的接口被称为<em class="lw">头文件接口</em>，因为它们类似于C++头文件)。从类中提取的接口可以很容易地与那个类紧密耦合，这使得接口作为一个抽象变得毫无用处。</p><p id="3456" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">最后，抽象可能是有漏洞的——也就是说，它们可能揭示关于其实现的特定实现细节。泄漏的抽象通常也与特定的实现相关联。(你可以在马克·西曼的一篇优秀的<a class="ae kz" href="http://bit.ly/2awOhmn" rel="noopener ugc nofollow" target="_blank">博客文章</a>中读到更多关于这个观点的内容。)</p></div><div class="ab cl lx ly hy lz" role="separator"><span class="ma bw bk mb mc md"/><span class="ma bw bk mb mc md"/><span class="ma bw bk mb mc"/></div><div class="in io ip iq ir"><h1 id="0c2a" class="me mf iu bd mg mh mi mj mk ml mm mn mo ka mp kb mq kd mr ke ms kg mt kh mu mv bi translated">结论</h1><p id="3838" class="pw-post-body-paragraph la lb iu lc b ld ni jv lf lg nj jy li lj nk ll lm ln nl lp lq lr nm lt lu lv in bi translated">使用适当的DI可以使你的代码产生巨大的变化。正确地做这件事并不十分困难，但是它确实需要一些深谋远虑、计划和设计。</p><p id="931c" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">然而，当需要维护代码时，这些最少的工作将会带来巨大的回报。修复松散耦合的代码是维护人员的梦想，您应该努力编写这样的代码。</p></div></div>    
</body>
</html>