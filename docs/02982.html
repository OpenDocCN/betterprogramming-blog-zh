<html>
<head>
<title>Create a Follow/Following Graph in Rails</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">在Rails中创建跟随/跟随图形</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/create-a-follow-following-graph-in-rails-a6ec77139dff?source=collection_archive---------11-----------------------#2020-01-13">https://betterprogramming.pub/create-a-follow-following-graph-in-rails-a6ec77139dff?source=collection_archive---------11-----------------------#2020-01-13</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="ec00" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">构建一个样本社交图，这样用户就可以互相关注</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/538b4ff2c2de5564d892efcdc27dad8d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*TNKSlcVHe25Gj_U45-0b9w.jpeg"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">照片由<a class="ae ky" href="https://unsplash.com/@ifbdesign?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">本杰明·史密斯</a>在<a class="ae ky" href="https://unsplash.com/s/photos/graph?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</p></figure><p id="b775" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在很长一段时间里，我避免在我的项目中实现自我关系。</p><p id="251d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我一直都知道这个概念，也知道它的应用(最著名的是，一个用户可以跟踪某个用户，但是那个用户不一定需要跟踪那个用户)，但是尽管我读了很多博客，我从来没有完全理解或者想象它是如何工作的。</p><p id="3b26" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">最大的障碍是我从来没有真正编码过它…直到现在。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="367b" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">模型</h1><p id="43b3" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">我们将使用下面的模型，一个<code class="fe mz na nb nc b">User</code>和<strong class="lb iu"> </strong>一个<code class="fe mz na nb nc b">Follow</code>模型，作为例子。</p><p id="8b9d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">自引用关系的设置涉及两个表，一个是用户表，另一个是joiner (follow)表，该表将自引用关系连接回用户表。听起来很困惑？别担心，这是给你的一个小视频。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nd"><img src="../Images/b05af4887e5b60bc25eb0629485cf936.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*HZJrzngy9LnUeJzaXwiZzA.jpeg"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">用户关注其他用户</p></figure><p id="87c7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">有了这种关系，我们就可以说一个用户可以通过<code class="fe mz na nb nc b">Follow</code>模型“追随”许多用户，同时，一个用户也可以通过<code class="fe mz na nb nc b">Follow</code>模型被许多用户“追随”。</p><p id="85b1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">理想情况下，有一个<code class="fe mz na nb nc b">User</code>模型而不是两个被拉长的模型是有意义的。简单来说，我们真正拥有的是，</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ne"><img src="../Images/bdb61d099d257ac8225ce6531b70d190.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*qd0YYD8U20xc1tpHxMc0lQ.jpeg"/></div></div></figure><p id="66d5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这是一种多对多的关系，但设置会略有不同。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="c1df" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">设置</h1><p id="9161" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">但是首先，让我们用我们的模型创建一个快速Rails应用程序。</p><pre class="kj kk kl km gt nf nc ng nh aw ni bi"><span id="2e93" class="nj md it nc b gy nk nl l nm nn">rails new self_ref_practice</span></pre><p id="4640" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们也生成一个带有<code class="fe mz na nb nc b">username</code>属性的<code class="fe mz na nb nc b">User</code>模型。</p><pre class="kj kk kl km gt nf nc ng nh aw ni bi"><span id="1dbf" class="nj md it nc b gy nk nl l nm nn">rails g model User username</span></pre><p id="7138" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">最后，让我们生成一个<code class="fe mz na nb nc b">Follow</code>模型来跟踪谁是追随者，谁是被追随者。我们来提供以下属性，<code class="fe mz na nb nc b">follower_id</code>和<code class="fe mz na nb nc b">followee_id</code>。</p><pre class="kj kk kl km gt nf nc ng nh aw ni bi"><span id="57f0" class="nj md it nc b gy nk nl l nm nn">rails g model Follow follower_id:integer followee_id:integer</span></pre><p id="6725" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在<code class="fe mz na nb nc b">Follow</code>模型中，我们将创建关联:</p><pre class="kj kk kl km gt nf nc ng nh aw ni bi"><span id="1147" class="nj md it nc b gy nk nl l nm nn">class Follow &lt; ApplicationRecord</span><span id="bdb9" class="nj md it nc b gy no nl l nm nn">   belongs_to :follower, class_name: “User”</span><span id="b83b" class="nj md it nc b gy no nl l nm nn">   belongs_to :followee, class_name: “User”</span><span id="977a" class="nj md it nc b gy no nl l nm nn">end</span></pre><p id="beff" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">据说<code class="fe mz na nb nc b">Follow</code>的一个实例将属于两个实例，一个追随者和一个被追随者。</p><p id="dfd2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">然而，这两个实例都来自于<code class="fe mz na nb nc b">User</code>模型。换句话说，即使我们期待一个<code class="fe mz na nb nc b">follower_id</code>和<code class="fe mz na nb nc b">followee_id</code>，我们实际上在寻找一个<code class="fe mz na nb nc b">user_id</code>。</p><p id="9eb9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">设置好<code class="fe mz na nb nc b">Follow</code>之后，现在让我们来设置<code class="fe mz na nb nc b">User</code>模型。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="np nq l"/></div></figure><p id="dd33" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">乍一看，理解这种措辞可能有点棘手。但是让我们来分解一下。</p><h2 id="afcb" class="nj md it bd me nr ns dn mi nt nu dp mm li nv nw mo lm nx ny mq lq nz oa ms ob bi translated">您关注的用户</h2><p id="c605" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">让我们从<code class="fe mz na nb nc b">has_many :followed_users</code>开始。简单来说，<code class="fe mz na nb nc b">followed_users</code>就是你关注的<em class="oc">的用户。</em></p><p id="121e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">关于<code class="fe mz na nb nc b">Follow</code>模型，哪个属性决定了是否有人在追随？<code class="fe mz na nb nc b">follower_id</code>！</p><p id="6f16" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在，第一行<code class="fe mz na nb nc b">has_many :followed_users</code>只返回<code class="fe mz na nb nc b">Follow</code>的实例。我们真的想要我们正在跟随的用户的实例。由此，我们定义<code class="fe mz na nb nc b">has_many :followees</code>。</p><h2 id="acd1" class="nj md it bd me nr ns dn mi nt nu dp mm li nv nw mo lm nx ny mq lq nz oa ms ob bi translated">关注您的用户</h2><p id="c296" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">相反，使用<code class="fe mz na nb nc b">has_many :following_users</code>，意味着这些用户关注<em class="oc">你</em>。</p><p id="b65e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">关于<code class="fe mz na nb nc b">Follow</code>模型，决定某人是否被跟踪的属性是<code class="fe mz na nb nc b">followee_id</code>。同样，我们想要的是<code class="fe mz na nb nc b">User</code>的实例，而不是follow。</p><p id="42c1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">于是，我们成立了这个协会，<code class="fe mz na nb nc b">has_many :followers</code>。</p><h2 id="7cd6" class="nj md it bd me nr ns dn mi nt nu dp mm li nv nw mo lm nx ny mq lq nz oa ms ob bi translated">混叠的替代方法</h2><p id="6060" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">我们可以采用另一种方法来创建<code class="fe mz na nb nc b">User</code>和<code class="fe mz na nb nc b">Follow</code>之间的关联，这涉及到别名，我们在<code class="fe mz na nb nc b">Follow</code>模型中提供外键。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="np nq l"/></div></figure><p id="63cc" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们将第一个宏定义为<code class="fe mz na nb nc b">belongs_to :person_doing_the_following</code>，带有<code class="fe mz na nb nc b">follower_id</code>的<code class="fe mz na nb nc b">foreign_key</code>。</p><p id="b924" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">换句话说，执行以下操作的人必须是<code class="fe mz na nb nc b">Follow</code>实例上的<code class="fe mz na nb nc b">follower_id</code>。反之，<code class="fe mz na nb nc b">person_being_followed</code>必须是<code class="fe mz na nb nc b">followee_id</code>。</p><p id="11be" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在<code class="fe mz na nb nc b">User</code>型号中，</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="np nq l"/></div></figure><p id="6914" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">与前面类似，<code class="fe mz na nb nc b">has_many :followed_users</code>将返回<code class="fe mz na nb nc b">Follow</code>的实例。分解一下，<code class="fe mz na nb nc b">Follow</code>实例指向两个用户，一个执行下面的操作，另一个被跟随。</p><p id="976f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">通过<code class="fe mz na nb nc b">has_many :followees</code>的关联，我们只想要<code class="fe mz na nb nc b">followee_id</code>的<code class="fe mz na nb nc b">User</code>实例。</p><p id="e1d0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">因此，我们设置源指向<code class="fe mz na nb nc b">:person_being_followed</code> ( <code class="fe mz na nb nc b">foreign_key: followee_id</code>)，这是在<code class="fe mz na nb nc b">Follow</code>模型中定义的。</p><p id="bc6d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">反之，<code class="fe mz na nb nc b">has_many :following_users</code>也会返回<code class="fe mz na nb nc b">Follow</code>实例。为了确定跟随者的<code class="fe mz na nb nc b">User</code>实例，源被设置为<code class="fe mz na nb nc b">:person_doing_the_following</code> ( <code class="fe mz na nb nc b">foreign_key: follower_id</code>)。</p><h2 id="dc22" class="nj md it bd me nr ns dn mi nt nu dp mm li nv nw mo lm nx ny mq lq nz oa ms ob bi translated">为数据库植入用户</h2><p id="c32a" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">在设置中要做的最后一件事是，为数据库植入一些用户。在<code class="fe mz na nb nc b">db/seeds.rb</code>中:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="np nq l"/></div></figure><p id="5694" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe mz na nb nc b">seeds.rb</code>中的<code class="fe mz na nb nc b">byebug</code>的目的是在终端中创建<code class="fe mz na nb nc b">Follows</code>。</p><p id="7275" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">最后一件事，快跑:</p><pre class="kj kk kl km gt nf nc ng nh aw ni bi"><span id="6893" class="nj md it nc b gy nk nl l nm nn">rails db:migrate</span></pre><p id="e76f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">最后，运行:</p><pre class="kj kk kl km gt nf nc ng nh aw ni bi"><span id="76b5" class="nj md it nc b gy nk nl l nm nn">rails db:seed</span></pre></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="a67d" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">创建关注并检查用户关注者/关注</h1><p id="816c" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">现在，在<code class="fe mz na nb nc b">seeds.rb</code>文件的<code class="fe mz na nb nc b">byebug</code>中，我们可以访问已经创建的用户实例。目标是创造追随者，但确定谁在追随谁。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi od"><img src="../Images/6002ca59a8fa629f106d2fc10d01c5a8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Z7GTf2OBThPKUWmWGnO-DQ.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">seeds.rb的byebug内</p></figure><p id="c61c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">为了检查关联是否有效，我们在不同的用户实例上调用followers和follower ees方法。正如所料，它应该是一个空数组，因为我们还没有创建follows。</p><p id="998e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们实际创建一些<code class="fe mz na nb nc b">Follow</code>实例。但是，让我们小心地定义谁是追随者，谁是被追随者，以避免任何混淆。</p><p id="bb5b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我希望<code class="fe mz na nb nc b">blah</code>到<em class="oc">的实例跟随</em>到<code class="fe mz na nb nc b">who</code>到<em class="oc">的实例。</em>从follow实例的角度来看，跟随者是<code class="fe mz na nb nc b">blah</code>，被跟随者是<code class="fe mz na nb nc b">who</code>。让我们创建<code class="fe mz na nb nc b">Follow</code>实例。</p><pre class="kj kk kl km gt nf nc ng nh aw ni bi"><span id="cda4" class="nj md it nc b gy nk nl l nm nn">Follow.create(follower_id: blah.id, followee_id: who.id)</span></pre><p id="f0df" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">创建了<code class="fe mz na nb nc b">Follow</code>的实例。同样，我们不需要知道下面的实例。我们使用实例来确定用户实例。</p><p id="63da" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们从用户实例<code class="fe mz na nb nc b">who</code>开始。这个实例应该有一个追随者。我们跑吧:</p><pre class="kj kk kl km gt nf nc ng nh aw ni bi"><span id="0ef0" class="nj md it nc b gy nk nl l nm nn">who.followers</span></pre><p id="3079" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们应该回去:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi oe"><img src="../Images/e0487443b16f0ac4d9f6bccd262b7d58.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*aVTMVNBvw5bmNoGsn0kdeA.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">谁.关注者</p></figure><p id="93ce" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们走吧！<code class="fe mz na nb nc b">who</code>的实例有一个<code class="fe mz na nb nc b">blah</code>的跟随者。相反，让我们运行:</p><pre class="kj kk kl km gt nf nc ng nh aw ni bi"><span id="d40f" class="nj md it nc b gy nk nl l nm nn">blah.followees</span></pre><p id="9bb9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们应该得到一个<code class="fe mz na nb nc b">blah</code>正在跟踪的数组:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi oe"><img src="../Images/bf6bd8fa58e2794c565b8b425b77dd94.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*VeVUjsUEOgBVIuGtVVmIDg.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">废话追随者</p></figure><p id="7088" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们在<code class="fe mz na nb nc b">User</code>和<code class="fe mz na nb nc b">Follow</code>之间建立了自指关系。让我们再创建几个<code class="fe mz na nb nc b">Follow</code>的实例，其中其他用户实例跟随<code class="fe mz na nb nc b">who</code> <em class="oc">。</em></p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi of"><img src="../Images/0df49fc9226eb63ab4d0eb95664070e3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ZOQjBS9LXWeo3yUym1OAJw.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">跟随实例</p></figure><p id="4c56" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在，让我们检查一下<code class="fe mz na nb nc b">who</code> <em class="oc">的追随者和追随者。</em></p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi og"><img src="../Images/e3885517e5ccee25190ebb0c4db5c6f0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*zDIMGWOWYKGd-zeW6aZhVA.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">世卫组织的追随者和追随者</p></figure><p id="b722" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">正如我们所见，<code class="fe mz na nb nc b">who</code>有许多追随者，但没有追随任何人(流行实例)。既然你在这里，我们来发奖金吧。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="1b2c" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">向其他用户发送消息</h1><p id="6f14" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">首先，让我们做一个快速设置。让我们生成一个<code class="fe mz na nb nc b">Message</code>模型。</p><pre class="kj kk kl km gt nf nc ng nh aw ni bi"><span id="1d6e" class="nj md it nc b gy nk nl l nm nn">rails generate model Message sender_id:integer receiver_id:integer message</span></pre><p id="f931" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">然后运行:</p><pre class="kj kk kl km gt nf nc ng nh aw ni bi"><span id="9085" class="nj md it nc b gy nk nl l nm nn">rails db:migrate</span></pre><p id="53a4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们在<code class="fe mz na nb nc b">User</code> <strong class="lb iu"> </strong>和<code class="fe mz na nb nc b">Message</code> <strong class="lb iu"> </strong>之间的关联将类似于<code class="fe mz na nb nc b">User</code>和<code class="fe mz na nb nc b">Follow</code>型号之间的关系。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ne"><img src="../Images/d09c77c1b44a6c4fa30661003275542b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*mwLfppMV0sf1mSNVCkWXdg.jpeg"/></div></div></figure><p id="bbb2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在<code class="fe mz na nb nc b">Message</code> <strong class="lb iu"> </strong>模型中，我们来添加以下关联:</p><pre class="kj kk kl km gt nf nc ng nh aw ni bi"><span id="966d" class="nj md it nc b gy nk nl l nm nn">class Message &lt; ApplicationRecord</span><span id="1da9" class="nj md it nc b gy no nl l nm nn">   belongs_to :sender, class_name: "User"</span><span id="87b7" class="nj md it nc b gy no nl l nm nn">   belongs_to :receiver, class_name: "User"</span><span id="1f86" class="nj md it nc b gy no nl l nm nn">end</span></pre><p id="a63e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在在<code class="fe mz na nb nc b">User</code>模型中，让我们添加一些方法。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="np nq l"/></div></figure><p id="1afd" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">语言没有<code class="fe mz na nb nc b">Follow</code>那么混乱。用户<code class="fe mz na nb nc b">has_many :sent_messages</code>由<code class="fe mz na nb nc b">Message</code>模型的<code class="fe mz na nb nc b">sender_id</code>属性决定，它将返回一个消息数组。</p><p id="9a5b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">类似地，设置<code class="fe mz na nb nc b">has_many :receivers</code>将返回您发送消息(即从您那里接收消息)的<code class="fe mz na nb nc b">User</code>实例的数组。</p><p id="30e0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">反之，一个<code class="fe mz na nb nc b">User</code> <code class="fe mz na nb nc b">has_many :received_messages</code>，由<code class="fe mz na nb nc b">Message</code>模型的<code class="fe mz na nb nc b">receiver_id</code>属性决定。</p><p id="8f7c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">使用<code class="fe mz na nb nc b">has_many :senders</code>，返回一个向您发送消息的<code class="fe mz na nb nc b">User</code>实例数组(即您收到的消息)。</p><h2 id="ebbb" class="nj md it bd me nr ns dn mi nt nu dp mm li nv nw mo lm nx ny mq lq nz oa ms ob bi translated">混叠的替代方法</h2><p id="111a" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">类似于<code class="fe mz na nb nc b">User</code>和<code class="fe mz na nb nc b">Follow</code>之间的替代方法，让我们在消息模型中定义以下内容:</p><pre class="kj kk kl km gt nf nc ng nh aw ni bi"><span id="f596" class="nj md it nc b gy nk nl l nm nn">class Message &lt; ApplicationRecord</span><span id="2678" class="nj md it nc b gy no nl l nm nn">    belongs_to :person_sending_the_message, class_name: "User", <br/>    foreign_key: "sender_id"</span><span id="f2e5" class="nj md it nc b gy no nl l nm nn">    belongs_to :person_receving_the_message, class_name: "User", <br/>    foreign_key: "receiver_id"</span><span id="523f" class="nj md it nc b gy no nl l nm nn">end</span></pre><p id="0498" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在<code class="fe mz na nb nc b">User</code>模型中，让我们定义:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="np nq l"/></div></figure><h2 id="8648" class="nj md it bd me nr ns dn mi nt nu dp mm li nv nw mo lm nx ny mq lq nz oa ms ob bi translated">测试用户消息关联</h2><p id="84f4" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">现在让我们通过在<code class="fe mz na nb nc b">seeds.rb</code>中创建一些<code class="fe mz na nb nc b">Message</code>实例来测试这种关联。这将通过<code class="fe mz na nb nc b">byebug</code>完成。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi oh"><img src="../Images/9b3630ad43a6bd92949a2a4cb20cf92c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*TohWAFVmfxxPf1_ifRv-Pg.gif"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">消息创建</p></figure><p id="2406" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">您现在可能会问:“哦，好吧，但是我怎样才能显示消息和与之相关的用户呢？”这是你必须应对的挑战！</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="487d" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">结束语</h1><p id="5cc5" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">就这样，自我参照关系！让我难以接受这些概念的是措辞。这(令人尴尬)让我很困惑，我仍然需要一些时间来思考。</p><p id="dc7e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">此外，我仍然很难完全想象它是如何工作的。但是画出模型并在控制台上测试确实有助于提高我的理解。感谢您的阅读。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="900e" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">资源</h1><ul class=""><li id="8d71" class="oi oj it lb b lc mu lf mv li ok lm ol lq om lu on oo op oq bi translated">请参考我的<a class="ae ky" href="https://github.com/reireynoso/self_ref_practice" rel="noopener ugc nofollow" target="_blank"> GitHub回购实例</a>。</li><li id="2ad7" class="oi oj it lb b lc or lf os li ot lm ou lq ov lu on oo op oq bi translated">也要感谢<a class="ae ky" href="https://medium.com/@TheDickWard/self-referential-relationships-aka-self-joins-in-rails-64f8f36ac311" rel="noopener">这篇文章</a>对我的帮助。</li></ul></div></div>    
</body>
</html>