<html>
<head>
<title>Using Kotlin Flow in Swift</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">在Swift中使用Kotlin流</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/using-kotlin-flow-in-swift-3e7b53f559b6?source=collection_archive---------2-----------------------#2021-05-28">https://betterprogramming.pub/using-kotlin-flow-in-swift-3e7b53f559b6?source=collection_archive---------2-----------------------#2021-05-28</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="a80c" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated"><em class="kf">使用来自Kotlin多平台的异步流作为Swift中的组合发布器</em></h2></div><figure class="kh ki kj kk gt kl gh gi paragraph-image"><div role="button" tabindex="0" class="km kn di ko bf kp"><div class="gh gi kg"><img src="../Images/a78baf8a5d093cd25d61cee55b554cbd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*BRG-hSV2Gdh0cP3vdsqaug.png"/></div></div><p class="ks kt gj gh gi ku kv bd b be z dk translated">作者照片。</p></figure><p id="ee16" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我的团队最近开始使用Kotlin Multiplatform Mobile为我们的移动应用程序开发组件，在Android上使用Jetpack Compose，在iOS上使用SwiftUI。</p><p id="e945" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">如果您已经熟悉Kotlin，您可能知道Kotlin中协程的概念，它极大地简化了线程和异步编程。Kotlin中协程的关键组件之一是<code class="fe ls lt lu lv b">Flow&lt;T&gt;</code>类型，它是Kotlin中所有异步流实现的接口。虽然<code class="fe ls lt lu lv b">Flow&lt;T&gt;</code>在Android(以及一般的JVM目标)中很容易使用，但是在Objective-C/Swift中表示接口带来了<code class="fe ls lt lu lv b">protocols</code>的局限性，包括缺少泛型类型参数。</p><p id="9c91" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在探索Android和iOS之间代码共享的限制时，我们面临的挑战是必须在Swift中使用这些来自Kotlin的异步流，同时又不影响Android的易用性。在研究问题解决方案的过程中，我们经历了几个选项，我将在本文中介绍它们。</p><p id="dcc9" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><em class="lw">TL；DR:通过为返回</em> <code class="fe ls lt lu lv b"><em class="lw">Flow&lt;T&gt;</em></code> <em class="lw">的方法引入重载来适应Swift中的使用，这调用回调，同时在Swift中可取消的专用协程范围中收集异步流。</em></p></div><div class="ab cl lx ly hu lz" role="separator"><span class="ma bw bk mb mc md"/><span class="ma bw bk mb mc md"/><span class="ma bw bk mb mc"/></div><div class="ij ik il im in"><h1 id="ece0" class="me mf iq bd mg mh mi mj mk ml mm mn mo jw mp jx mq jz mr ka ms kc mt kd mu mv bi translated">第一轮:AnyFlow <t>类</t></h1><p id="49ea" class="pw-post-body-paragraph kw kx iq ky b kz mw jr lb lc mx ju le lf my lh li lj mz ll lm ln na lp lq lr ij bi translated">当使用Kotlin多平台将iOS作为目标时，接口的泛型类型参数<em class="lw">在转换中丢失，而类</em>的泛型类型参数<em class="lw">被保留(因为这些参数可以很容易地被转换为对象<strong class="ky ir"/>C/Swift)，所以我们的第一个想法是创建一个名为<code class="fe ls lt lu lv b">AnyFlow&lt;T&gt;</code>的<code class="fe ls lt lu lv b">Flow&lt;T&gt;</code>的实现。我们采用了Swift中常见的协议擦除模式的命名方案(如Combine中的<code class="fe ls lt lu lv b">AnyPublisher&lt;Output, Failure&gt;</code>):</em></p><figure class="kh ki kj kk gt kl"><div class="bz fp l di"><div class="nb nc l"/></div></figure><p id="c22e" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">虽然这允许我们在Swift中使用时保留一定程度的通用类型参数，但这并不完美，因为以有意义的方式使用类型为<code class="fe ls lt lu lv b">Flow&lt;T&gt;</code>的值最终需要调用一个挂起的函数(如<code class="fe ls lt lu lv b">suspend collect(collector: FlowCollector&lt;T&gt;)</code>)或将协程作用域传递给一个函数。在这两种情况下，都需要一个协程范围，这在Swift中是不容易实现的。虽然我们可以通过引入额外的Kotlin代码在Swift中创建和管理协程范围，但我们宁愿不这样做。</p><p id="322a" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">为了解决这个问题，我们在<code class="fe ls lt lu lv b">AnyFlow&lt;T&gt;</code>类中引入了<code class="fe ls lt lu lv b">collect</code>函数的非挂起实现:</p><figure class="kh ki kj kk gt kl"><div class="bz fp l di"><div class="nb nc l"/></div><p class="ks kt gj gh gi ku kv bd b be z dk translated">具有基于回调的收集功能的AnyFlow <t/></p></figure><p id="78dc" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在寻找这个问题的解决方案时，这个解决方案是你经常会偶然发现的。它有时被称为CFlow或ClassFlow。</p><p id="65ac" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">您会注意到返回类型是<code class="fe ls lt lu lv b">Cancellable</code>，看起来像这样:</p><figure class="kh ki kj kk gt kl"><div class="bz fp l di"><div class="nb nc l"/></div></figure><p id="192d" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">通过使用回调来发出元素和完成/失败，我们可以在Kotlin中保留所有的协程用法，使得从Swift使用该方法变得简单，在Swift中它将具有以下签名:</p><pre class="kh ki kj kk gt nd lv ne nf aw ng bi"><span id="b4de" class="nh mf iq lv b gy ni nj l nk nl">func collect(onEach: @escaping (T) -&gt; Void, onCompletion: @escaping (KotlinThrowable?) -&gt; Void) -&gt; Cancellable</span></pre><p id="5eba" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这可以包装在一个<code class="fe ls lt lu lv b">Publisher</code>中，该T3订阅Swift中的<code class="fe ls lt lu lv b">AnyFlow&lt;T&gt;</code>类的实例。</p><p id="1bb1" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">然而，虽然Kotlin Multiplatform在Swift(和其他原语)中将Kotlin类型如<code class="fe ls lt lu lv b">Int</code>转换为<code class="fe ls lt lu lv b">In32</code>，但它不会对泛型类型参数这样做(除了少数常见类型——参见<a class="ae nm" href="https://kotlinlang.org/docs/native-objc-interop.html" rel="noopener ugc nofollow" target="_blank">与Swift/Objective-C的互操作性</a>),这意味着Kotlin返回的<code class="fe ls lt lu lv b">AnyFlow&lt;Int&gt;</code>中的方法或属性被有效地转换为Swift的<code class="fe ls lt lu lv b">AnyFlow&lt;NSNumber?&gt;</code>。您会注意到不仅类型参数不是<code class="fe ls lt lu lv b">Int32</code>，而且可空性在转换中也丢失了，使得每个泛型类型参数都是可空的。现在我不知道你怎么想，但是我和我的团队更喜欢我们的可空性和类型被正确地翻译，以及拥有让<em class="lw">感觉</em>本地的数据类型，所以我们坚持……</p></div><div class="ab cl lx ly hu lz" role="separator"><span class="ma bw bk mb mc md"/><span class="ma bw bk mb mc md"/><span class="ma bw bk mb mc"/></div><div class="ij ik il im in"><h1 id="86c7" class="me mf iq bd mg mh mi mj mk ml mm mn mo jw mp jx mq jz mr ka ms kc mt kd mu mv bi translated">第2轮:流包装函数</h1><p id="b8d3" class="pw-post-body-paragraph kw kx iq ky b kz mw jr lb lc mx ju le lf my lh li lj mz ll lm ln na lp lq lr ij bi translated">虽然Kotlin多平台在泛型参数中保留类型信息的能力仍然有限，但对于作为参数传递的函数，它可以正确地保留类型信息。这导致我们对所有的<code class="fe ls lt lu lv b">Flow&lt;T&gt;</code>返回函数采用一种模式，本质上是复制每个返回异步流的方法签名——我们称之为流包装函数的函数。</p><p id="777e" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">假设我们有一个返回<code class="fe ls lt lu lv b">Task</code>对象流的方法:</p><figure class="kh ki kj kk gt kl"><div class="bz fp l di"><div class="nb nc l"/></div><p class="ks kt gj gh gi ku kv bd b be z dk translated">具有流和流包装器功能的TaskService</p></figure><p id="8ffb" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">正如您所看到的，有一个任务属性返回一个<code class="fe ls lt lu lv b">Flow&lt;T&gt;</code>(在我们的Android应用程序中使用它是微不足道的)，同时有一个重载作为接口上的默认方法实现，使用类似于我们之前添加到<code class="fe ls lt lu lv b">AnyFlow&lt;T&gt;</code>的<code class="fe ls lt lu lv b">collect</code>方法的扩展方法收集属性流:</p><figure class="kh ki kj kk gt kl"><div class="bz fp l di"><div class="nb nc l"/></div><p class="ks kt gj gh gi ku kv bd b be z dk translated">基于回调的流程收款扩展功能<t/></p></figure><p id="41c9" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">为了完成这个模式，我们在Swift代码中引入了一些函数，将这些函数作为Combine <code class="fe ls lt lu lv b">Publishers</code>:</p><figure class="kh ki kj kk gt kl"><div class="bz fp l di"><div class="nb nc l"/></div><p class="ks kt gj gh gi ku kv bd b be z dk translated">函数来收集Swift中的流包装函数(<a class="ae nm" href="https://gist.github.com/Nillerr/dc437c02485da661b4f285cee01069a1" rel="noopener ugc nofollow" target="_blank">Flow+publisher . Swift的完整源代码</a>)</p></figure><p id="ca74" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">它们可用于将流包装函数<em class="lw">引用</em>转换为<code class="fe ls lt lu lv b">Publisher</code>:</p><figure class="kh ki kj kk gt kl"><div class="bz fp l di"><div class="nb nc l"/></div><p class="ks kt gj gh gi ku kv bd b be z dk translated">在Swift中收集流包装函数的示例(<a class="ae nm" href="https://gist.github.com/Nillerr/1a1669da5aef0463877e3f06b51a3c3a" rel="noopener ugc nofollow" target="_blank">source</a>for completeOnFailure())</p></figure><p id="cf6c" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">采用这种模式保留了所有的类型信息，虽然涉及到一些样板文件，但我们希望将其保持在绝对最小的程度。</p><p id="5d0a" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们可能会考虑引入一个Kotlin编译器插件，以便在将来的编译时自动生成这些包装器，但现在，我们决定使用Android Studio中的几个<a class="ae nm" href="https://gist.github.com/Nillerr/920f10a35da225cca7a04c06fcf73a44" rel="noopener ugc nofollow" target="_blank">实时模板</a>。</p><p id="f511" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">请务必通过标题中的链接查看完整的相关源代码。</p></div><div class="ab cl lx ly hu lz" role="separator"><span class="ma bw bk mb mc md"/><span class="ma bw bk mb mc md"/><span class="ma bw bk mb mc"/></div><div class="ij ik il im in"><h1 id="6fa1" class="me mf iq bd mg mh mi mj mk ml mm mn mo jw mp jx mq jz mr ka ms kc mt kd mu mv bi translated">结论</h1><p id="c117" class="pw-post-body-paragraph kw kx iq ky b kz mw jr lb lc mx ju le lf my lh li lj mz ll lm ln na lp lq lr ij bi translated">虽然复制方法签名<em class="lw">感觉不对</em>，但它<em class="lw">感觉</em>比没有将类型信息正确翻译到Swift的选择要好，这就是为什么它是我们团队最终选定的方法。Android不使用基于回调的方法，就像Swift不使用基于<code class="fe ls lt lu lv b">Flow&lt;T&gt;</code>的方法一样，但是我们通过遵循这种模式来确保实现的一致性，并支持Swift的干净互操作。</p><p id="6ba5" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">虽然<code class="fe ls lt lu lv b">suspend</code>函数确实翻译了类型信息，但是它们失去了可空性和取消运行<code class="fe ls lt lu lv b">suspend</code>函数的协程作用域的能力，导致我们采用相同的模式来挂起函数。我将在下一篇文章中讨论这个问题。</p><p id="275b" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">请继续关注未来的文章，我将继续介绍我们在现实世界的应用程序开发中使用Kotlin多平台Mobile的旅程，包括我们探索过但最终暂时搁置的一些想法。</p><p id="29ae" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><em class="lw">注意:本文引用的所有代码和GitHub gists都是在MIT许可下发布的。</em></p></div><div class="ab cl lx ly hu lz" role="separator"><span class="ma bw bk mb mc md"/><span class="ma bw bk mb mc md"/><span class="ma bw bk mb mc"/></div><div class="ij ik il im in"><p id="ed73" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">如果您对更多的Kotlin多平台感兴趣，请随意查看我的另一篇关于模仿Kotlin/Native和Kotlin多平台中的依赖关系的文章:</p><ul class=""><li id="e6fd" class="nn no iq ky b kz la lc ld lf np lj nq ln nr lr ns nt nu nv bi translated"><a class="ae nm" rel="noopener ugc nofollow" target="_blank" href="/introducing-mockative-mocking-for-kotlin-native-kotlin-multiplatform-31f5b076257b">认识mock ative——一个在Kotlin中模仿依赖关系的框架</a></li></ul></div></div>    
</body>
</html>