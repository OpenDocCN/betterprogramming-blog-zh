# 为什么今天每个人都应该学习函数式编程

> 原文：<https://betterprogramming.pub/why-everyone-should-learn-functional-programming-today-c96a5b10d27d>

## 编程趋势来来去去，但函数式编程是一个基础

![](img/ab1fd3ddd58871e1dc5ab17bae4a91e7.png)

丹尼尔·里卡洛斯在 [Unsplash](https://unsplash.com/) 上的照片

在编程语言的世界里，趋势来来去去。一个值得考虑的趋势是本世纪初开始的对**函数式编程**的兴趣。函数式编程是一种强调不可变数据、函数原语和状态避免的风格。

我知道你在想什么。你在大学里写了一些口齿不清的东西，并且害怕它。或者，你在上一份工作中不得不管理一些糟糕的 Scala 代码，而你不想再处理这些。

我知道，我知道。但是听我说完。

函数式编程不仅仅是一种趋势。理解它的概念和吸引力有助于理解软件工程师在 2019 年以及未来十年面临的问题。

事实上，随着数据挖掘和机器学习算法成为公众关注的问题，它有助于了解世界的现状。

即使你不使用函数式语言，函数式思维方式提供的解决方案也能帮助你解决难题，理解计算世界。

# 命令式风格

今天广泛使用的大多数编程语言是冯·诺依曼语言。这些语言反映了冯·诺依曼计算机架构，其中内存、存储、控制流指令和 I/O 是语言的一部分。程序员在内存中创建一个变量，设置它的值，删除它，并控制下一个命令是什么。

每个写过程序的人都熟悉这些概念。事实上，所有最流行的语言都是冯·诺依曼家族的语言:Java、C++、Python、Ruby、Go。

# 输入功能样式

1978 年 8 月，计算机科学家约翰·巴科斯在《美国计算机学会通讯》上发表了一篇文章。巴克斯指责传统的冯·诺依曼风格的语言是“肥胖和松弛的”他哀叹新一代语言的复杂性，需要大量的手册才能理解。每一代都增加了更多看似增强的特性，但由于增加了复杂性，大大降低了语言的质量。

此外，用这些语言编写的程序不能组合成新的程序，因为它们的组件不是以通用形式创建的。

确实是一种令人遗憾的事态。

巴克斯问为什么我们不能创建结构更像数学公式的程序。在这种语言中，数据可以像在代数中一样被操作。他提出这种“函数式编程风格”会更正确、更简单、更可组合。巴克斯还强调了程序“清晰和概念有用”的重要性。

这篇论文已经写了 40 年了，但我想我们都有同感！

像 Java、Python 和 JavaScript 这样的语言增加了旨在阐明语法的新特性，但是这些语言的总体趋势是越来越复杂。面向对象编程(OOP)至少给了我们模块化，但是继承层次导致了众所周知的设计问题。

# 计算模型

巴克斯认为，所有这些复杂性都要归咎于冯·诺依曼计算机体系结构本身。它在 20 世纪 40 年代和 50 年代为我们提供了很好的服务，但到了 1978 年，它开始显示出它的年龄。他定义了几个概念模型来证明冯·诺依曼的普适模型的局限性。

## 图灵机和自动机

这些是计算机科学家使用的计算机概念模型。它们满足计算的所有要求，但是对于负责设计软件程序的人来说，它们太笨重了。

## 可怕的冯·诺依曼模型

巴克斯把我们今天使用的大多数传统语言所代表的冯·诺依曼模型称为“复杂、庞大、无用”。

巴克斯承认冯·诺依曼语言可以“相当清晰”，但他指出它们缺乏概念上的实用性。

事实上，我们当中有多少人斜眼盯着一千行的 Python 或 Java 代码，试图弄清楚所有这些循环和条件语句到底想干什么？对于多个参与者来说，理解高度程序化的代码可能是一场噩梦。

巴克斯还指出，冯·诺依曼模型是为单 CPU 机器设计的。一次执行一条指令。

## 功能模型

在这里，Backus 将 lambda 演算、Lisp 语言和他自己的“函数式编程”概念归为第三类。

用这种模型编写的程序没有状态。我们没有直接设置变量，而是将值绑定到符号上。我们转换集合，而不是循环。结果是程序简洁明了，而且**在概念上很有用**。

换句话说，功能风格是**明显的**。

的确，用函数式语言编写的程序通常很短，但是它简洁的定义比非函数式语言更容易理解。

# 我为什么要在乎？

好吧，如果我们都放弃 Python 和 Java，开始写 Haskell，也许我们能写出更好的程序。嗯哼。好的。当然可以。

但是谁来做呢？为什么呢？我们如何用这些他们不懂的语言来培训刚从大学毕业的开发人员呢？更重要的是，为什么？当然，已经有很多用现有语言编写的高质量软件，正如 C++的创造者比雅尼·斯特劳斯特鲁普曾经说过的:

> "世界上只有两种语言:人们抱怨的语言和没人使用的语言。"

除了学术练习之外，我们应该关心所有这些的原因是,**当前向“大数据”驱动的产品的发展已经导致了功能模型唯一擅长解决的计算问题。**

# 并发

正如巴克斯在 1978 年指出的，冯·诺依曼模型实际上是面向一次执行一条指令的简单计算机的。冯·诺依曼式的程序流程将每条指令的控制权交给了程序员。

不幸的是，没过多久我们的计算机就变得更加复杂了。现在，我们的计算机有许多中央处理器，同时执行许多指令。像 Python 和 Java 这样的流行语言并不是为了利用这一点而从头开始构建的。这些语言附加了线程 API，允许程序员利用多个处理器。其他的依赖于进程分叉，本质上是把问题推到操作系统。

多线程程序很难正确编写，即使是非常有经验的程序员也会犯严重的错误。编写多线程程序是如此复杂，以至于有[整本书致力于正确地完成它](https://www.amazon.com/Java-Concurrency-Practice-Brian-Goetz/dp/0321349601/ref=sr_1_3?keywords=java+concurrency&qid=1574700159&sr=8-3)。

如果在 20 世纪 40 年代，拥有许多 CPU 的计算机很常见，我们的编程语言会是什么样子？我们是选择单独为每个线程编程，还是想出不同的概念来实现相同的目标？

# 分布式系统

10 年前，大多数软件都是在用户电脑的操作系统上运行的。软件需要执行的任何操作都是使用客户的 CPU、内存和本地磁盘来处理的。

但是 Gmail 和其他网络工具的早期成功证明了一个复杂的软件系统可以在互联网上运行。

今天的商业软件不仅仅运行在客户的个人电脑上。它运行在云中，可能跨越数百台机器。软件即服务(Saas)产品现在很常见，被个人和企业使用。

随着数据从客户的电脑中取出并通过网络发送到我们的云中数据中心，我们现在可以查看所有*客户的汇总数据。这些数据可以识别数据中的趋势，例如，检测银行交易中的欺诈行为。*

但是这些系统很难写。我们的程序现在不得不运行在可能有数百个 CPU 的机器上，而不是像冯·诺依曼模型预先假定的那样运行在具有本地内存和磁盘访问的单线程计算机上。更糟糕的是，我们现在处理的数据远远超过了我们希望在一台机器上存储的数据。我们需要研究这些数据。它不能只是被铲进一个数据仓库，然后再被查询。

# 天真的解决方案

一种方法是继续使用我们得到的线程或进程分叉模型来编写代码，然后构建一个机器舰队来扩展它。这些机器将处理数据，并将数据推送到某个地方(数据库？)以防止它填满本地磁盘。

正如你可能猜到的，这个解决方案在操作上非常复杂*。我们必须以某种方式手动分割数据——也就是说，将我们的数据集平均分割到我们的 n 台处理机器上——并为所有这些机器编写胶水代码，使它们能够相互对话，并执行某种[领导人选举](https://en.wikipedia.org/wiki/Leader_election)来确定谁负责协调所有这些工作。*

用实际的程序员术语来说，这也意味着我们必须用代码编写、维护和版本化以下内容:

*   比如用 Java 写的复杂多线程代码。
*   一堆 bash 脚本，用于在云中的 n 台机器上部署和更新这些代码。
*   随着数据量的增加或减少，代码可以将我们的解决方案扩展到更多的机器。
*   某种调度和协调系统，使所有这些操作一起工作，并在某个地方加入它们的结果。

现在想象一下调试和维护这个系统。听起来不好玩，是吧？当然，代码中产生的解决方案不会是**明显的**。

# 优雅的解决方案

2013 年，伯克利的 AMPLab 向开源世界捐赠了 Spark 项目。多年来，Spark 已经成为最受欢迎的“大数据”集群编程平台之一，取代了 Twitter 和 Google 工程师构建的各种系统。

Spark 是用 Scala 语言编写的，Scala 语言是一种运行在 Java 虚拟机(JVM)上的函数式编程语言。我不会深入 Spark 如何工作的血淋淋的细节，也不会在这里写任何代码。你可以在网上找到很多这样的例子。

相反，我将展示 Spark **概念框架**，并展示**计算的功能模型如何对其优雅的解决方案**至关重要。

## 什么是“程序？”

问自己这个问题。在我们上面描述的假设的分布式系统中，什么是“程序？”

是我们写的并发 Java 代码吗？或者是 bash 脚本将代码部署到我们“集群”中的各种机器上是调度算法的问题吗？

我认为所有这些组件放在一起包含了“程序”的一部分程序是转换数据的指令。像线程管理和管理资源这样的细节对于这个目标来说是附带的。

这么想吧。假设我们在云中有十几台机器，有 4 个 CPU 和 16 GB 的内存。将所有这些机器放到一个大的计算资源“集群”中。现在我们有了一台大“计算机”，它有 4 * 12 = 48 个 CPU，16 * 12 = 192 GB 内存，还有一定的磁盘存储空间。

现在，假设我们用 Backus 描述的函数式风格编写数据转换。每个变换都像数学函数一样书写。有输入和输出。没有国家。所有数据都是不可变的，分阶段存储在每台机器的磁盘上，当不再需要时就会删除。

我们现在可以有一个知道集群结构的调度程序。换句话说，它知道它有 12 台带有 4 个 CPU 和 16 GB 内存的机器。调度程序将一部分数据和我们定义的数据转换函数一起发送出去。

事实上，如果我们以一种纯粹的函数式风格编写我们的数据转换“程序”，那么调度程序可以同时调度许多这样的转换，其数量可以在资源有限的集群中容纳。这使我们能够以高效的方式处理数据。

# 以函数方式对集群进行编程

我不打算将 Spark 作为集群计算的终极目标。也许我们将来会想出更好的东西，Spark 并不适合每一个分布式系统。例如，它针对数据处理和流式传输进行了优化，而不是为实时请求提供服务。

但是我想强调的是允许这种类型的系统被构建的观点的转变，即**函数式编程风格**。事实上，当我们进入“大数据”领域时，我们往往会发现大多数解决方案都依赖于计算的功能模型。

Spark 提供了 Scala、Java 和 Python API。无论您选择哪种语言，您都将使用函数式风格编写您的 Spark 程序。

我们也倾向于发现转换代码与资源管理的分离是一个主题。Apache Spark 的解决方案将我们分布式系统的资源管理方面分离出来，让我们处理数据。数据转换规则清晰，要求**没有复杂的多线程代码**。

似乎分布式系统最终将我们从冯·诺依曼模型的限制中解放出来。

# 结论

作为 Java 或 Python 等语言的流行替代品，函数式编程语言可能正在失宠。作为简单用例(如小型 web 应用程序)的替代，Scala 或 Haskell 可能有些过头了。

但是计算的功能模型还远没有消失。如果说有什么不同的话，那就是它比以往任何时候都更有优势。它隐藏在幕后，为机器学习算法、商业智能和分析引擎提供动力，为现代组织提供见解。

软件工程师和经理最好学习这些概念，并理解为什么在最大的技术公司的核心运行的这么多项目依赖于像 Apache Spark 这样的函数式项目。

函数式风格允许我们将计算资源管理的“如何”与程序的“什么”分开。它将我们从繁琐复杂的多线程 API 中解放出来，这些 API 附加在基于 20 世纪 40 年代构想的简单计算机模型的语言上。

功能模型非常适合我们正在进入的数据丰富的世界。它是当今任何软件工程师不可或缺的工具。