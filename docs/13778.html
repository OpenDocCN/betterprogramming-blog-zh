<html>
<head>
<title>Cleaner Python Code in Tiny Increments</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">以微小的增量清理Python代码</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/cleaner-code-in-tiny-increments-9fd0a35bae58?source=collection_archive---------14-----------------------#2022-09-26">https://betterprogramming.pub/cleaner-code-in-tiny-increments-9fd0a35bae58?source=collection_archive---------14-----------------------#2022-09-26</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="e6fb" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">任何时候都是添加格式和林挺的好时机</h2></div><p id="a508" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">对拉请求中的普通错误进行评论并不是任何开发人员一天中的高潮。工具的存在是为了捕捉并无声地纠正错误，这种知识使得花费在工具上的时间更加痛苦。</p><p id="5ca7" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在这里，您将看到如何轻松地将它们集成到Python项目中，以实现渐进式改进，而不会出现人们担心的中断。是的，即使是在现有的大型代码库上。</p><p id="2a3f" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我将向您展示如何将<a class="ae lb" href="https://black.readthedocs.io/en/stable/" rel="noopener ugc nofollow" target="_blank">黑色</a>格式化程序和<a class="ae lb" href="https://flake8.pycqa.org/en/latest/" rel="noopener ugc nofollow" target="_blank">薄片8 </a>林挺添加到您的项目中，并在新的和修改过的文件上运行它们。</p><ul class=""><li id="98b8" class="lc ld iq kh b ki kj kl km ko le ks lf kw lg la lh li lj lk bi translated"><strong class="kh ir"> Black </strong>是一个PEP 8兼容的格式化程序，不需要配置就可以使用。</li><li id="3d2a" class="lc ld iq kh b ki ll kl lm ko ln ks lo kw lp la lh li lj lk bi translated">Flake8 是一款流行的linter，可以标记未使用的进口商品、未定义的名称等等。</li></ul><p id="0750" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">第一步是将它们添加到您的项目中，就像您添加任何其他pip包一样。</p><p id="f0b3" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">您可以创建新的Python脚本或添加到现有脚本中。我更喜欢使用现有的单元测试命令(你有一个单元测试任务要在本地和CI中运行，对吗？).开发人员完全有可能回避这一点，所以预提交挂钩是一个更严格的选择，但我会假设您的团队是由好公民组成的，并留给您去探索。</p><p id="3075" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们将依靠<code class="fe lq lr ls lt b">git ls-files</code>来提供添加和修改的文件列表:</p><pre class="lu lv lw lx gt ly lt lz ma aw mb bi"><span id="875c" class="mc md iq lt b gy me mf l mg mh">python_files = subprocess.check_output(<br/>  [<br/>    "git",<br/>    "ls-files",<br/>    "--exclude-standard",<br/>    "--modified",<br/>    "--others",<br/>    "--",<br/>    "*.py",<br/>  ],<br/>  encoding="UTF-8",<br/>).splitlines()</span></pre><h1 id="a687" class="mi md iq bd mj mk ml mm mn mo mp mq mr jw ms jx mt jz mu ka mv kc mw kd mx my bi translated">这个策略的关键是增量部分</h1><p id="7298" class="pw-post-body-paragraph kf kg iq kh b ki mz jr kk kl na ju kn ko nb kq kr ks nc ku kv kw nd ky kz la ij bi translated">也许你正在看一个现有的数百个文件的回购协议，并认为没有办法让一个故事进入任何sprint来修复你将会有的数千个林挺错误。或者您可能在想，在运行格式化程序后，您不想成为每一行代码的罪魁祸首。所以我们不会那样做。</p><p id="00d0" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">将这些检查应用到新文件是极低的摩擦。对于格式化程序来说，没有影响也没有责备。任何林挺错误都很容易解决，特别是因为它是由代码的作者解决的。</p><p id="5cdd" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">应用于修改过的文件的想法听起来可能很烦人，但实际上很少如此。任何给定的故事都可能包含需要由开发人员解决的错误，这些错误与他们现在的更改没有直接关系。平均来说，这笔债务将在故事和开发者之间平均分配。</p><p id="3ade" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这使得它成为一项小税收，在公共关系评估中返还。没必要在规划中正式考虑。在这种策略下，最有价值的工作首先完成:人们正在积极处理的文件。有些文件可能完全逃脱了这种处理，但这些文件无论如何都没有人在看。</p><p id="c218" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">现在，我们将首先添加黑色以在林挺之前自动格式化Python文件:</p><pre class="lu lv lw lx gt ly lt lz ma aw mb bi"><span id="c1f0" class="mc md iq lt b gy me mf l mg mh">if python_files:<br/>  subprocess.check_call(["black"] + python_files)</span></pre><p id="600e" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">最后，我们添加了薄片8:</p><pre class="lu lv lw lx gt ly lt lz ma aw mb bi"><span id="431f" class="mc md iq lt b gy me mf l mg mh"><br/>  # Disabling E501 Line too long (accept the wrapping that Black does)<br/>  subprocess.check_call(["flake8", "--ignore=E501"] + python_files)</span></pre><p id="5a4f" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">仅此而已。少数几行代码可以节省宝贵的时间，避免每次拉取请求的麻烦。</p></div></div>    
</body>
</html>