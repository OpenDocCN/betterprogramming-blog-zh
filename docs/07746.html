<html>
<head>
<title>Kata Container And GVisor With K0s</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">带K0s的Kata容器和GVisor</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/kata-container-and-gvisor-with-k0s-82efbbcc240b?source=collection_archive---------9-----------------------#2021-02-15">https://betterprogramming.pub/kata-container-and-gvisor-with-k0s-82efbbcc240b?source=collection_archive---------9-----------------------#2021-02-15</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="7a27" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">使用另一个容器运行时来获得更好的隔离和安全性</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/d5ef5b303f5db5c0d5aad6ceb1416330.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Cl45YAbWEYljeITf8b_rYQ.jpeg"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">由<a class="ae ky" href="https://unsplash.com/@roxannedesgagnes?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">罗克珊·德斯加涅斯</a>在<a class="ae ky" href="https://unsplash.com/s/photos/isolated?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</p></figure><p id="f3f0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">因为不是所有的pods都是可信的，所以本文将展示通过使用容器运行时而不是默认运行时(runc)来增强进程隔离的不同选项。我们将使用Kubernetes <a class="ae ky" href="https://k0sproject.io" rel="noopener ugc nofollow" target="_blank"> k0s </a>分布来说明这一切。如果你不知道k0s，你可以在<a class="ae ky" href="https://medium.com/better-programming/k0s-kubernetes-in-a-single-binary-224bb43f4520" rel="noopener">这篇文章</a>中找到快速介绍。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="32d7" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">创建K0s集群</h1><p id="5175" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">在介绍文章中，我们详细介绍了轻松设置k0s集群所需的步骤。最近<a class="mz na ep" href="https://medium.com/u/fedcaa2e9074?source=post_page-----82efbbcc240b--------------------------------" rel="noopener" target="_blank"> Mirantis </a>推出了一个更简单的解决方案，引入了<a class="ae ky" href="https://github.com/k0sproject/k0sctl" rel="noopener ugc nofollow" target="_blank"> k0sctl </a>配套二进制文件，它只请求ssh访问某些Linux服务器，以便在这些服务器上自动安装集群。</p><p id="77db" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">从<a class="ae ky" href="https://github.com/k0sproject/k0sctl" rel="noopener ugc nofollow" target="_blank"> GitHub </a>抓取最新版本后，我们可以生成一个默认的配置文件。</p><pre class="kj kk kl km gt nb nc nd ne aw nf bi"><span id="ee46" class="ng md it nc b gy nh ni l nj nk">$ k0sctl init &gt; k0sctl.yaml</span></pre><p id="e585" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这个包含以下属性:</p><pre class="kj kk kl km gt nb nc nd ne aw nf bi"><span id="ac38" class="ng md it nc b gy nh ni l nj nk">apiVersion: k0sctl.k0sproject.io/v1beta1<br/>kind: Cluster<br/>metadata:<br/>  name: k0s-cluster<br/>spec:<br/>  hosts:<br/>  - ssh:<br/>      address: 10.0.0.1<br/>      user: root<br/>      port: 22<br/>      keyPath: /Users/luc/.ssh/id_rsa<br/>    role: server<br/>  - ssh:<br/>      address: 10.0.0.2<br/>      user: root<br/>      port: 22<br/>      keyPath: /Users/luc/.ssh/id_rsa<br/>    role: worker<br/>  k0s:<br/>    version: 0.10.0</span></pre><p id="180d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们可以修改这个文件，为控制计划的流程(API服务器、kube-controller、kube-proxy)、网络插件(默认为Calico)和其他组件添加额外的配置选项。在当前示例中，我们只保留了默认配置，并更改了IP地址以匹配预先调配的主机:</p><ul class=""><li id="d1a1" class="nl nm it lb b lc ld lf lg li nn lm no lq np lu nq nr ns nt bi translated">主节点:163.172.190.5</li><li id="57b3" class="nl nm it lb b lc nu lf nv li nw lm nx lq ny lu nq nr ns nt bi translated">工人节点:163.172.190.5</li></ul><p id="2508" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们用一个简单的命令启动集群创建(<em class="nz"> k0sctl.yaml </em>是默认使用的配置文件):</p><pre class="kj kk kl km gt nb nc nd ne aw nf bi"><span id="e32b" class="ng md it nc b gy nh ni l nj nk">$ k0sctl apply</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi oa"><img src="../Images/2c688d33ec18d96243bb0fee6e1a5faa.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*d53o_a__MMdsVQZKulzDCQ.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">k0sctl二进制文件使k0s集群创建变得轻而易举</p></figure><p id="2714" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们检索生成的<code class="fe ob oc od nc b">kubeconfig</code>文件，并配置我们的本地<code class="fe ob oc od nc b">kubectl</code>:</p><pre class="kj kk kl km gt nb nc nd ne aw nf bi"><span id="bb28" class="ng md it nc b gy nh ni l nj nk">$ k0sctl kubeconfig -c k0sctl.yaml &gt; kubeconfig<br/>$ export KUBECONFIG=$PWD/kubeconfig</span></pre><p id="fb16" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">检查群集的节点，我们可以看到只列出了一个。主设备专用于管理控制平面，不允许调度应用程序单元:</p><pre class="kj kk kl km gt nb nc nd ne aw nf bi"><span id="cbd8" class="ng md it nc b gy nh ni l nj nk"><strong class="nc iu">$ kubectl get no<br/></strong>NAME     STATUS   ROLES    AGE   VERSION<br/>worker   Ready    &lt;none&gt;   5m  v1.20.2-k0s1</span></pre><p id="f2c4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">注意:控制平面的隔离是创建k0s背后的主要原因之一(正如<a class="mz na ep" href="https://medium.com/u/198a67da8854?source=post_page-----82efbbcc240b--------------------------------" rel="noopener" target="_blank"> Jussi Nummelin </a>在<a class="ae ky" href="https://www.youtube.com/watch?v=W71I1JpsvjY" rel="noopener ugc nofollow" target="_blank">他在CNCF Ismalabad meetup </a>关于k0s的演讲中所解释的)。</p><p id="9c3e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">kubelet是运行在每个节点上的代理，它需要与容器运行时进行通信，以便创建容器。为此，K0s发布了<code class="fe ob oc od nc b"><a class="ae ky" href="https://containerd.io" rel="noopener ugc nofollow" target="_blank">containerd</a></code>，但是也可以使用其他容器运行时，例如:</p><ul class=""><li id="2e0b" class="nl nm it lb b lc ld lf lg li nn lm no lq np lu nq nr ns nt bi translated">码头工人</li><li id="8649" class="nl nm it lb b lc nu lf nv li nw lm nx lq ny lu nq nr ns nt bi translated"><a class="ae ky" href="https://cri-o.io/" rel="noopener ugc nofollow" target="_blank"> CRI-O </a></li></ul><p id="c85b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">注意:由于Docker与CRI不兼容，所以在<code class="fe ob oc od nc b">kubelet</code>内部实现了一个<code class="fe ob oc od nc b">dockershim</code>进程，这样它就可以与Docker建立链接。您可能在新闻中听说过，这个<code class="fe ob oc od nc b">dockershim</code>在Kubernetes 1.20中已被弃用，并将在未来的版本中被删除。但是在Kubernetes中使用Docker作为高级容器运行时仍然是可能的(真的需要吗？)作为新的独立<code class="fe ob oc od nc b">dockershim</code>正在开发中。更多信息请查看Docker博客上的这篇文章。</p><p id="9ffe" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">从官方文档来看，<code class="fe ob oc od nc b"><a class="ae ky" href="https://containerd.io" rel="noopener ugc nofollow" target="_blank">containerd</a></code>被定义为“管理其主机系统的完整容器生命周期的过程，从映像传输和存储到容器执行和监督，到低级存储，到网络附件等等。”</p><p id="b1ae" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这是许多容器平台中使用的核心部分，如下图所示:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi oe"><img src="../Images/967069ca91bbf69647db765e024b31cd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*5FxzkGddVGtYsCPxgvIBDQ.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">containerd，负责管理容器生命周期的核心部分(credit: <a class="ae ky" href="https://containerd.io" rel="noopener ugc nofollow" target="_blank"> containerd.io </a>)</p></figure><p id="e8e8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe ob oc od nc b">containerd</code>被认为是高级别的容器运行时，它可以与<strong class="lb iu"> </strong>列在模式最底层的低级运行时交互。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi of"><img src="../Images/dc1aae8aa94fe5b70a57f31c0eaaecae.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*hj9ZC8V1nDytugcTWMij7Q.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">低级容器运行时</p></figure><p id="4534" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">其中<code class="fe ob oc od nc b">containerd</code>管理容器的整个生命周期，低级容器运行时负责从容器映像清单和根文件系统(由<code class="fe ob oc od nc b">containerd</code>提供)运行容器。<code class="fe ob oc od nc b"><a class="ae ky" href="https://github.com/opencontainers/runc" rel="noopener ugc nofollow" target="_blank">runc</a></code>是由<a class="ae ky" href="https://opencontainers.org/" rel="noopener ugc nofollow" target="_blank">开放容器倡议(OCI) </a>指定的容器运行时的参考实现——这是在许多Kubernetes发行版(包括k0s)中默认安装和使用的，但是，正如我们将在下面看到的，安装和使用其他低级容器运行时非常容易。为了通过工作负载隔离提高安全性，这甚至是必需的。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="fcef" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">默认运行时</h1><p id="139c" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">当在标准Kubernetes集群上运行一个简单的pod时，底层运行时容器是runc。让我们检查一下，创建一个具有以下规范的pod:</p><pre class="kj kk kl km gt nb nc nd ne aw nf bi"><span id="3444" class="ng md it nc b gy nh ni l nj nk"><strong class="nc iu">$ cat &lt;&lt;EOF | kubectl apply -f -<br/></strong>apiVersion: v1<br/>kind: Pod<br/>metadata:<br/>  name: www-runc<br/>spec:<br/>  containers:<br/>  - image: nginx:1.18<br/>    name: www<br/>    ports:<br/>    - containerPort: 80<br/><strong class="nc iu">EOF</strong></span></pre><p id="2d07" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果我们看一下当前在我们的worker节点上运行的进程，我们会发现7个名为<code class="fe ob oc od nc b">containerd-shim-runc-v2</code> : <em class="nz"> </em>的进程，一个用于新创建的pod，一个用于为我们启动的每个pod k0s。七个pod当前正在运行，这通过下面的命令得到了确认:</p><pre class="kj kk kl km gt nb nc nd ne aw nf bi"><span id="71c1" class="ng md it nc b gy nh ni l nj nk"><strong class="nc iu">$ kubectl get po -A | awk '{print $1" "$2}'<br/></strong>default www-runc<br/>kube-system calico-kube-controllers-5f6546844f-tw8t6<br/>kube-system calico-node-4p98g<br/>kube-system coredns-5c98d7d4d8-9z425<br/>kube-system konnectivity-agent-m4gst<br/>kube-system kube-proxy-jq6qd<br/>kube-system metrics-server-6fbcd86f7b-m8cnd</span></pre><p id="113f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">简单来说，我们可以说流程是以链的形式调用的，就像这样:</p><blockquote class="og"><p id="0f4a" class="oh oi it bd oj ok ol om on oo op lu dk translated">kube let→container d→container d-shim-runc-v2→runc</p></blockquote><p id="aea2" class="pw-post-body-paragraph kz la it lb b lc oq ju le lf or jx lh li os lk ll lm ot lo lp lq ou ls lt lu im bi translated">在接下来的部分中，我们将说明如何在集群中使用其他低级容器运行时。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="6a54" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">GVisor</h1><p id="89c3" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">简而言之，gVisor使用一种新的Linux内核实现来运行容器，这种实现是用Go编写的，在用户空间中运行。这个内核实现了<a class="ae ky" href="https://en.wikipedia.org/wiki/Linux_kernel_interfaces" rel="noopener ugc nofollow" target="_blank"> Linux系统调用接口</a>的一个重要部分，并拦截应用程序的系统调用，从而为主机内核漏洞提供额外的保护。它侧重于安全性、效率和易用性。gVisor还包括一个名为<code class="fe ob oc od nc b">runsc</code>的<a class="ae ky" href="https://www.opencontainers.org/" rel="noopener ugc nofollow" target="_blank">开放容器倡议(OCI) </a>运行时。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ov"><img src="../Images/83a7d9b507a2dfdc5892a13e2cc84a51.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*GgMF6pZyUG-mPpUqQrwDlA.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">gVisor添加了一个用户内核，限制对主机内核的系统调用</p></figure><blockquote class="ow ox oy"><p id="a159" class="kz la nz lb b lc ld ju le lf lg jx lh oz lj lk ll pa ln lo lp pb lr ls lt lu im bi translated">然而，gVisor并没有引入大量的固定开销，并且在资源利用方面仍然保留了类似流程的模型</p><p id="0439" class="kz la nz lb b lc ld ju le lf lg jx lh oz lj lk ll pa ln lo lp pb lr ls lt lu im bi translated">— gVisor文档</p></blockquote><p id="e15d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">下面，我们将配置<code class="fe ob oc od nc b">containerd</code>通过<code class="fe ob oc od nc b">runsc</code>运行一个容器。</p><p id="51ad" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">首先，我们使用下面的命令(详见k0s官方文档)来安装所有的gVisor包:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="pc pd l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">安装gVisor包</p></figure><p id="3204" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">接下来，我们在<code class="fe ob oc od nc b">containerd</code>配置文件中添加一个条目，这样它就可以使用gVisor作为额外的运行时:</p><pre class="kj kk kl km gt nb nc nd ne aw nf bi"><span id="02a6" class="ng md it nc b gy nh ni l nj nk"><strong class="nc iu">$ cat&lt;&lt;EOF | sudo tee /etc/k0s/containerd.toml<br/></strong>disabled_plugins = ["restart"]<br/>[plugins.linux]<br/>  shim_debug = true<br/>[plugins.cri.containerd.runtimes.runsc]<br/>  runtime_type = "io.containerd.runsc.v1"<br/><strong class="nc iu">EOF</strong></span></pre><p id="b1d9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">接下来，我们强制<code class="fe ob oc od nc b">containerd</code>在您的单个worker节点上重新加载它的配置:</p><pre class="kj kk kl km gt nb nc nd ne aw nf bi"><span id="9377" class="ng md it nc b gy nh ni l nj nk">$ kill -s SIGHUP CONTAINER_PID</span></pre><p id="d82d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">注意:改变<code class="fe ob oc od nc b">containerd</code>的配置很容易，因为我们只有一个工作节点。在多节点集群中，这应该使用自动化流程在全局范围内完成。</p><p id="24be" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">接下来，我们定义一个与gVisor的<code class="fe ob oc od nc b">runsc</code>运行时相关的新的<code class="fe ob oc od nc b">RuntimeClass</code>:</p><pre class="kj kk kl km gt nb nc nd ne aw nf bi"><span id="26c6" class="ng md it nc b gy nh ni l nj nk"><strong class="nc iu">$ cat&lt;&lt;EOF | kubectl apply -f -<br/></strong>apiVersion: node.k8s.io/v1beta1<br/>kind: RuntimeClass<br/>metadata:<br/>  name: gvisor<br/>handler: runsc<br/><strong class="nc iu">EOF</strong></span></pre><p id="cd46" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">然后我们使用这个新的<code class="fe ob oc od nc b">RuntimeClass</code>运行一个Pod:</p><pre class="kj kk kl km gt nb nc nd ne aw nf bi"><span id="b113" class="ng md it nc b gy nh ni l nj nk"><strong class="nc iu">$ cat&lt;&lt;EOF | kubectl apply -f -<br/></strong>apiVersion: v1<br/>kind: Pod<br/>metadata:<br/>  labels:<br/>    app: untrusted<br/>  name: www-gvisor<br/>spec:<br/>  runtimeClassName: gvisor<br/>  containers:<br/>  - image: nginx:1.18<br/>    name: www<br/>    ports:<br/>    - containerPort: 80<br/><strong class="nc iu">EOF</strong></span></pre><p id="1c21" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">列出带有<code class="fe ob oc od nc b"> app=untrusted</code>标签的Pod，我们可以看到pod <code class="fe ob oc od nc b">www-gvisor</code>运行良好:</p><pre class="kj kk kl km gt nb nc nd ne aw nf bi"><span id="30f0" class="ng md it nc b gy nh ni l nj nk"><strong class="nc iu">$ kubectl get po -l app=untrusted<br/></strong>NAME         READY   STATUS    RESTARTS   AGE<br/>www-gvisor   1/1     Running   0          9s</span></pre><p id="b852" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">它使用gVisor/runsc，增加了一个额外的保护层，因为系统调用首先由用户内核处理。这些流程在以下链中被调用:</p><blockquote class="og"><p id="9e84" class="oh oi it bd oj ok ol om on oo op lu dk translated">kube let→container d→container d-shim-runsc-v1→runsc</p></blockquote><p id="9be7" class="pw-post-body-paragraph kz la it lb b lc oq ju le lf or jx lh li os lk ll lm ot lo lp lq ou ls lt lu im bi translated">在下一节中，我们将说明另一个低级运行时的用法——在微型虚拟机中运行容器。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="b756" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">Kata容器</h1><blockquote class="ow ox oy"><p id="e7c1" class="kz la nz lb b lc ld ju le lf lg jx lh oz lj lk ll pa ln lo lp pb lr ls lt lu im bi translated">Kata Containers是一个开源社区，致力于使用轻量级虚拟机构建安全的容器运行时，这些虚拟机感觉和执行起来像容器，但使用硬件虚拟化技术作为第二层防御来提供更强的工作负载隔离。</p><p id="1ce6" class="kz la nz lb b lc ld ju le lf lg jx lh oz lj lk ll pa ln lo lp pb lr ls lt lu im bi translated"><a class="ae ky" href="https://katacontainers.io/" rel="noopener ugc nofollow" target="_blank"> — Katacontainer.io </a></p></blockquote><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi pe"><img src="../Images/585ce104ce5bb4ff7676f6886ac20b22.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*UW2J69ETGwpI2B327dj5Nw.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">Kata容器的整体架构</p></figure><p id="55cf" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">虽然以前的版本使用了几个垫片过程(<code class="fe ob oc od nc b">containerd-shim</code>、<code class="fe ob oc od nc b">kata-shim</code>、<code class="fe ob oc od nc b">kata-runtime</code>、<code class="fe ob oc od nc b">kata-proxy</code>)，但当前版本简化了这种方法，因为它只使用了一个过程(<code class="fe ob oc od nc b">container-shim-kata-v2</code>)。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi pf"><img src="../Images/b96973095cef8371b0935d674510d815.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*PDmbPZKMFSuwbR9YWy6Drg.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">Kubernetes与shimv2的集成</p></figure><p id="f47b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">作为先决条件，我们需要确保嵌套虚拟化被激活，因为将为我们的worker节点上的每个容器创建一个新的VM。在当前示例中，集群是在<a class="ae ky" href="https://scaleway.com" rel="noopener ugc nofollow" target="_blank"> Scaleway </a>虚拟机上创建的。这些虚拟机基于AMD，支持嵌套虚拟化，如以下命令所示:</p><pre class="kj kk kl km gt nb nc nd ne aw nf bi"><span id="7aa1" class="ng md it nc b gy nh ni l nj nk">$ cat /sys/module/kvm_amd/parameters/nested<br/>1</span></pre><p id="9aab" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">首先，我们安装Kata容器包:</p><pre class="kj kk kl km gt nb nc nd ne aw nf bi"><span id="1686" class="ng md it nc b gy nh ni l nj nk">$ bash -c "$(curl -fsSL https://raw.githubusercontent.com/kata-containers/tests/master/cmd/kata-manager/kata-manager.sh) install-packages"</span></pre><p id="189d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">接下来，我们修改<code class="fe ob oc od nc b">containerd</code>配置文件，使其使用kata作为额外的运行时(在前面步骤中添加的<code class="fe ob oc od nc b">runc</code>和<code class="fe ob oc od nc b">gVisor</code> <em class="nz"> / </em> <code class="fe ob oc od nc b">runsc</code>之上)。</p><pre class="kj kk kl km gt nb nc nd ne aw nf bi"><span id="3dc8" class="ng md it nc b gy nh ni l nj nk"><strong class="nc iu">$ cat&lt;&lt;EOF | sudo tee -a /etc/k0s/containerd.toml<br/></strong>[plugins.cri.containerd.runtimes.kata]<br/>  runtime_type = "io.containerd.kata.v2"<br/><strong class="nc iu">EOF</strong></span></pre><p id="a61e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">接下来，我们强制<code class="fe ob oc od nc b">containerd</code>在您的单个工作节点上重新加载它的配置:</p><pre class="kj kk kl km gt nb nc nd ne aw nf bi"><span id="a278" class="ng md it nc b gy nh ni l nj nk">$ kill -s SIGHUP CONTAINER_PID</span></pre><p id="6ba9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">接下来，我们定义一个与kata运行时相关的新的<code class="fe ob oc od nc b">RuntimeClass</code>:</p><pre class="kj kk kl km gt nb nc nd ne aw nf bi"><span id="c73a" class="ng md it nc b gy nh ni l nj nk"><strong class="nc iu">$ cat&lt;&lt;EOF | kubectl apply -f -</strong><br/>kind: RuntimeClass<br/>apiVersion: node.k8s.io/v1beta1<br/>metadata:<br/>    name: kata<br/>handler: kata<br/><strong class="nc iu">EOF</strong></span></pre><p id="91d8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">然后我们使用这个新的<code class="fe ob oc od nc b">RuntimeClass</code>运行一个<code class="fe ob oc od nc b">Pod</code>:</p><pre class="kj kk kl km gt nb nc nd ne aw nf bi"><span id="c3ef" class="ng md it nc b gy nh ni l nj nk"><strong class="nc iu">$ cat&lt;&lt;EOF | kubectl apply -f -<br/></strong>apiVersion: v1<br/>kind: Pod<br/>metadata:<br/>  labels:<br/>    app: untrusted<br/>  name: www-kata<br/>spec:<br/>  runtimeClassName: kata<br/>  containers:<br/>  - image: nginx:1.18<br/>    name: www<br/>    ports:<br/>    - containerPort: 80<br/><strong class="nc iu">EOF</strong></span></pre><p id="7dd1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">列出带有<code class="fe ob oc od nc b">app=untrusted</code>标签的<code class="fe ob oc od nc b">Pod</code>，我们可以看到pod <code class="fe ob oc od nc b">www-kata</code>运行良好(与之前的pod <code class="fe ob oc od nc b">www-gvisor</code>并排):</p><pre class="kj kk kl km gt nb nc nd ne aw nf bi"><span id="37e8" class="ng md it nc b gy nh ni l nj nk"><strong class="nc iu">$ kubectl get po -l app=untrusted<br/></strong>NAME         READY   STATUS    RESTARTS   AGE<br/>www-gvisor   1/1     Running   0          8m1s<br/>www-kata     1/1     Running   0          3h25m</span></pre><p id="cc71" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在幕后，它运行到一个专门为该容器创建的虚拟机(通常定义为<code class="fe ob oc od nc b">microVM</code>)中。我们还可以看到一个<code class="fe ob oc od nc b">qemu</code>进程正在运行:</p><pre class="kj kk kl km gt nb nc nd ne aw nf bi"><span id="68a5" class="ng md it nc b gy nh ni l nj nk"><strong class="nc iu">root@worker:~# ps -ef | grep qemu | awk '{print $11}'<br/></strong>/usr/bin/qemu-vanilla-system-x86_64</span></pre><p id="1930" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这表明<code class="fe ob oc od nc b">qemu</code>在worker节点上创建了一个新的虚拟机。这些流程在以下链中被调用:</p><blockquote class="og"><p id="c102" class="oh oi it bd oj ok ol om on oo op lu dk translated">kube let→container d→container d-shim-kata-v2→kata</p></blockquote></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="9b89" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">关键要点</h1><p id="9758" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">正如我们所见，使用额外的容器运行时并不复杂。gVisor和Kata容器是两种已经广泛使用的技术，但也存在其他解决方案。所有这些<code class="fe ob oc od nc b">runc</code>备选方案的主要目标是更好地隔离箱/集装箱，增强安全性。</p></div></div>    
</body>
</html>