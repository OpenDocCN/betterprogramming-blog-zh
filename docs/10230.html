<html>
<head>
<title>Breaking Up a Monolithic Database With Kong</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">用孔破解了一个庞大的数据库</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/breaking-up-a-monolithic-database-with-kong-4a70f55d4f63?source=collection_archive---------3-----------------------#2021-12-15">https://betterprogramming.pub/breaking-up-a-monolithic-database-with-kong-4a70f55d4f63?source=collection_archive---------3-----------------------#2021-12-15</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="64b5" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">如果您的微服务设计导致非常大的API或多个服务访问单个数据库，请查看Kong Gateway</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/e040c272fd70840dcb01d8f766266a9c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*9D6QonkdweTjLiv5"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">罗汉·古普塔在<a class="ae kv" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的照片</p></figure><p id="cf42" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在我们的生活中，有些事情似乎只是例行公事，但却出乎意料地对我们的旅程产生了深远的影响。对我来说，一个事件是参加在佛罗里达州奥兰多举行的2008年Gartner会议。</p><p id="4140" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">那次活动不仅让我第一次接触到了Salesforce生态系统，还让我了解了以下概念:</p><ul class=""><li id="ebbe" class="ls lt iq ky b kz la lc ld lf lu lj lv ln lw lr lx ly lz ma bi translated"><a class="ae kv" href="https://en.wikipedia.org/wiki/Service-oriented_architecture" rel="noopener ugc nofollow" target="_blank">面向服务的架构</a>(通过罗伊·舒尔特令人印象深刻的会议)</li><li id="3468" class="ls lt iq ky b kz mb lc mc lf md lj me ln mf lr lx ly lz ma bi translated"><a class="ae kv" href="https://en.wikipedia.org/wiki/Web_2.0" rel="noopener ugc nofollow" target="_blank"> Web 2.0 </a>和<a class="ae kv" href="https://en.wikipedia.org/wiki/Mashup_(web_application_hybrid)" rel="noopener ugc nofollow" target="_blank">混搭</a></li><li id="1584" class="ls lt iq ky b kz mb lc mc lf md lj me ln mf lr lx ly lz ma bi translated"><a class="ae kv" href="https://en.wikipedia.org/wiki/Representational_state_transfer" rel="noopener ugc nofollow" target="_blank"> RESTful API设计</a></li></ul><p id="5d95" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">虽然我对这一事件的期望不高，但在佛罗里达州中部的那几天成了我未来13年职业生涯中关注的一个重要方面，远远超出了我的任何预期。</p><p id="cb56" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">一路走来，我从专注于这些概念的项目和倡议中学到了很多经验。在本文中，我将深入探讨从将RESTful APIs置于应用程序设计核心的项目中获得的一些经验。</p><h1 id="5992" class="mg mh iq bd mi mj mk ml mm mn mo mp mq jw mr jx ms jz mt ka mu kc mv kd mw mx bi translated">RESTful API的缺陷</h1><p id="d7b7" class="pw-post-body-paragraph kw kx iq ky b kz my jr lb lc mz ju le lf na lh li lj nb ll lm ln nc lp lq lr ij bi translated">RESTful API软件风格为客户端应用程序提供了一种简单的方式来访问满足业务需求所需的资源(数据)。事实上，用不了多久，Angular、React和Vue等基于Javascript的框架就依赖RESTful APIs，引领了基于web的应用程序市场。</p><p id="feae" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这种RESTful服务API和前端Javascript框架的模式激发了许多组织对从单一或过时的应用程序中迁移出来的项目进行投资的愿望。RESTful API模式也为仍在从大衰退影响中恢复的技术经济提供了急需的推动力。</p><p id="88b3" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">将几个敏捷迭代快进到这个新的开发范例中，有两个陷阱被反复遇到而不是被避免:</p><ol class=""><li id="6cac" class="ls lt iq ky b kz la lc ld lf lu lj lv ln lw lr nd ly lz ma bi translated">一个过时的应用程序设计最终被一个非常大的RESTful API和一个同样大的Javascript框架所取代。这给协调未来的功能和增强带来了挑战；基本上，一块巨石被另一块所取代。</li><li id="7b31" class="ls lt iq ky b kz mb lc mc lf md lj me ln mf lr nd ly lz ma bi translated">遗留应用程序设计采用了多个RESTful APIs和利用Javascript框架的组件化客户端，但是只使用了一个数据库。这种设计的结果导致了数据所有权冲突、高于预期的数据库连接数，以及支持/维护大型数据库的更高成本。</li></ol><p id="3f4e" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">下面的例子说明了第二个陷阱是如何发生的，几个服务从一个数据库中竞争资源:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi ne"><img src="../Images/69fa0ca1f90fcf976deadf0674d8868c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*MzGkGVoyKSZ_-9fLwwdJQQ.png"/></div></div></figure><p id="ff36" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">不幸的是，我也在绿地开发机会中看到过这些相同的场景，在这些场景中，人们倾向于为整个微服务集合使用单个数据库。</p><h1 id="ae0b" class="mg mh iq bd mi mj mk ml mm mn mo mp mq jw mr jx ms jz mt ka mu kc mv kd mw mx bi translated">微服务应该从数据库开始</h1><p id="10ac" class="pw-post-body-paragraph kw kx iq ky b kz my jr lb lc mz ju le lf na lh li lj nb ll lm ln nc lp lq lr ij bi translated">在大多数编程语言中，使用一个文件就可以创建一个全功能的应用程序。在Java中，所有东西都可以在同一个类文件中，只需调用<code class="fe nf ng nh ni b">main()</code>方法即可:</p><pre class="kg kh ki kj gt nj ni nk nl aw nm bi"><span id="8253" class="nn mh iq ni b gy no np l nq nr">public class SingleClassApplication {<br/>    public static void main(String[] args) {<br/>        // Start doing something really cool here<br/>    }<br/>}</span></pre><p id="9b63" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">然而，这种方法不太受支持，也不便于多个开发人员的轻松贡献。</p><p id="c2ca" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">当涉及到应用程序的各个方面时，还有“所有权”(或记录系统)的概念。在不止一个服务或功能声称拥有某样东西(比如客户)的情况下，当业务规则不同时，挑战就出现了。当多个RESTful APIs声明某个给定对象的所有权时，也会出现同样的情况。</p><p id="8f47" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">当采用RESTful API设计时，这些相同的概念会转化到数据库层。请考虑以下准则:</p><blockquote class="ns nt nu"><p id="982e" class="kw kx nv ky b kz la jr lb lc ld ju le nw lg lh li nx lk ll lm ny lo lp lq lr ij bi translated">单个RESTful API应该被视为应用程序特定方面的记录系统。因此，相应的数据层应该利用只关注应用程序这一方面的数据存储。</p></blockquote><p id="45b7" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">下图提供了一个遵循该准则的微服务设计:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi ne"><img src="../Images/37b9e95775e020f5fe621d2431272b79.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*MKJM1qiqohaVDQCb_8Nqzg.png"/></div></div></figure><p id="bb61" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">成功的微服务设计始于数据库。一旦就位，为满足客户对给定服务的需求而进行的扩展不会对任何其他服务产生影响。</p><h2 id="b5bb" class="nn mh iq bd mi nz oa dn mm ob oc dp mq lf od oe ms lj of og mu ln oh oi mw oj bi translated">反驳:数据库约束呢？</h2><p id="d283" class="pw-post-body-paragraph kw kx iq ky b kz my jr lb lc mz ju le lf na lh li lj nb ll lm ln nc lp lq lr ij bi translated">我推荐的方法是用专用数据库隔离给定的微服务。这使得相关组件的数量和大小与用户需求相匹配，同时避免了不具有相同需求水平的元素的额外成本。</p><p id="f84d" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">当应用程序的所有元素都驻留在单个数据库中时，数据库管理员会很快注意到约束和关系可以带来的好处，从而为单数据库设计辩护。例如，如果有与客户关联的订单排队等待删除，单个数据库设计可以阻止删除客户的请求。</p><p id="4e14" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">虽然这无疑是拥有单个数据库的一个好处，但在选择将单个数据库用于所有微服务之前，请考虑以下几点:</p><ul class=""><li id="49e4" class="ls lt iq ky b kz la lc ld lf lu lj lv ln lw lr lx ly lz ma bi translated">将使用单个数据库获得的长期价值与扩展单个大型数据库的相关成本进行比较。未来扩展和支持单一数据库设计的预期成本是多少？</li><li id="9324" class="ls lt iq ky b kz mb lc mc lf md lj me ln mf lr lx ly lz ma bi translated">改为在API层实施这些约束的风险和价值是什么？请记住，单个微服务将被视为给定数据库的所有者，因此业务逻辑不允许删除有活动订单的客户。</li><li id="18a8" class="ls lt iq ky b kz mb lc mc lf md lj me ln mf lr lx ly lz ma bi translated">考虑使用事件驱动(或基于消息)的设计来处理一个微服务如何处理请求取决于另一个微服务的响应的情况的好处。虽然这类似于单个应用程序/单个数据库设计，但是可以隔离和控制在需要时扩展和分配专用处理能力的能力。</li></ul><p id="fa6f" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">当然，即使数据库只支持一个专用的服务实例，也应该实现和加强约束和关系。</p><h1 id="aa85" class="mg mh iq bd mi mj mk ml mm mn mo mp mq jw mr jx ms jz mt ka mu kc mv kd mw mx bi translated">应该抽象出公共元素</h1><p id="6f5c" class="pw-post-body-paragraph kw kx iq ky b kz my jr lb lc mz ju le lf na lh li lj nb ll lm ln nc lp lq lr ij bi translated">如果规划不当，采用真正的微服务设计可能会产生副作用。我继续看到的最大挑战是通用组件和服务层的复制。</p><p id="3991" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">下表提供了每个微服务中经常重复的元素示例:</p><ul class=""><li id="ddb7" class="ls lt iq ky b kz la lc ld lf lu lj lv ln lw lr lx ly lz ma bi translated">证明</li><li id="53f7" class="ls lt iq ky b kz mb lc mc lf md lj me ln mf lr lx ly lz ma bi translated">贮藏</li><li id="e87c" class="ls lt iq ky b kz mb lc mc lf md lj me ln mf lr lx ly lz ma bi translated">记录</li><li id="243b" class="ls lt iq ky b kz mb lc mc lf md lj me ln mf lr lx ly lz ma bi translated">监视</li><li id="8db8" class="ls lt iq ky b kz mb lc mc lf md lj me ln mf lr lx ly lz ma bi translated">安全</li></ul><p id="e840" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">事实上，考虑一下这个例子，我在今年早些时候的“<a class="ae kv" href="https://medium.com/nerd-for-tech/how-i-stopped-coding-repetitive-service-components-with-kong-1308be4000e3" rel="noopener">我是如何用Kong </a>停止编写重复的服务组件的”文章中介绍了这个例子。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi ok"><img src="../Images/95c316b39087b33e3989bf730546cd66.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Z73NJEGyRD_1CJ-DtMJhAA.png"/></div></div></figure><p id="2656" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">像开发生命周期的所有方面一样，我们应该始终关注尽可能保持事情<a class="ae kv" href="https://en.wikipedia.org/wiki/Don%27t_repeat_yourself" rel="noopener ugc nofollow" target="_blank">干燥</a>(不要重复自己)。这包括可以在应用程序堆栈的公共级别或不同级别进行抽象和处理的元素。</p><p id="d4f7" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我经常推荐的一种方法是由<a class="ae kv" href="https://konghq.com/" rel="noopener ugc nofollow" target="_blank">孔</a>提供的分布式微服务抽象层方法。</p><h1 id="5f5e" class="mg mh iq bd mi mj mk ml mm mn mo mp mq jw mr jx ms jz mt ka mu kc mv kd mw mx bi translated">将孔置于理想设计的中心</h1><p id="6dc6" class="pw-post-body-paragraph kw kx iq ky b kz my jr lb lc mz ju le lf na lh li lj nb ll lm ln nc lp lq lr ij bi translated"><a class="ae kv" href="https://github.com/Kong/kong" rel="noopener ugc nofollow" target="_blank"> Kong Gateway </a>允许将服务层API的复杂性减少到一组端点(或URIs ),集中满足一组业务需求和功能。经常重复的组件(如身份验证、日志记录和安全性)由网关处理，可以从服务层设计中删除。</p><p id="603b" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">每个RESTful微服务都维护一个专用的数据库实例，并抽象出重复的组件，一组目的驱动的微服务将如下图所示:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi ol"><img src="../Images/4572568a7d5e23a5695d4462838ff853.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*t572m4pHogPsby3nZv0mcw.png"/></div></div></figure><p id="30f9" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">服务间通信是通过消息传递层利用通用的<a class="ae kv" href="https://en.wikipedia.org/wiki/Enterprise_Integration_Patterns" rel="noopener ugc nofollow" target="_blank">企业集成模式</a>来处理的，例如:</p><ul class=""><li id="190c" class="ls lt iq ky b kz la lc ld lf lu lj lv ln lw lr lx ly lz ma bi translated"><a class="ae kv" href="https://docs.wso2.com/display/EIP/Command+Message" rel="noopener ugc nofollow" target="_blank">命令消息</a> —调用另一个服务执行后台动作</li><li id="7d70" class="ls lt iq ky b kz mb lc mc lf md lj me ln mf lr lx ly lz ma bi translated"><a class="ae kv" href="https://docs.wso2.com/display/EIP/Document+Message" rel="noopener ugc nofollow" target="_blank">文档消息</a> —从另一个服务请求信息</li><li id="183f" class="ls lt iq ky b kz mb lc mc lf md lj me ln mf lr lx ly lz ma bi translated"><a class="ae kv" href="https://docs.wso2.com/display/EIP/Event+Message" rel="noopener ugc nofollow" target="_blank">事件消息</a> —向任何收听给定主题的人广播信息</li><li id="5a8b" class="ls lt iq ky b kz mb lc mc lf md lj me ln mf lr lx ly lz ma bi translated"><a class="ae kv" href="https://docs.wso2.com/display/EIP/Request-Reply" rel="noopener ugc nofollow" target="_blank">请求-回复</a> —向另一个服务发出请求并监听响应</li></ul><p id="dda3" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">有了这种设计，考虑一些现实生活中的好处:</p><ul class=""><li id="ddeb" class="ls lt iq ky b kz la lc ld lf lu lj lv ln lw lr lx ly lz ma bi translated">如果Node.js服务的使用量高于预期，则扩展以满足需求的成本将由服务和专用数据库承担。</li><li id="ea85" class="ls lt iq ky b kz mb lc mc lf md lj me ln mf lr lx ly lz ma bi translated">如果任何单个服务意识到数据存储改变是优选的(例如SQL到NoSQL)，新的设计可以在对任何其他服务影响很小(如果有的话)的情况下部署——假设RESTful API URIs没有改变。</li><li id="b663" class="ls lt iq ky b kz mb lc mc lf md lj me ln mf lr lx ly lz ma bi translated">任何抽象层组件的更改(例如，使用新的日志记录方法)都可以在Kong网关层进行，不会对底层服务产生影响。</li></ul><h1 id="308f" class="mg mh iq bd mi mj mk ml mm mn mo mp mq jw mr jx ms jz mt ka mu kc mv kd mw mx bi translated">结论</h1><p id="04e3" class="pw-post-body-paragraph kw kx iq ky b kz my jr lb lc mz ju le lf na lh li lj nb ll lm ln nc lp lq lr ij bi translated">从2021年开始，我一直努力按照以下使命宣言生活，我觉得这可以适用于任何IT专业人士:</p><blockquote class="ns nt nu"><p id="2ebc" class="kw kx nv ky b kz la jr lb lc ld ju le nw lg lh li nx lk ll lm ny lo lp lq lr ij bi translated">“将您的时间集中在提供扩展您知识产权价值的特性/功能上。将框架、产品和服务用于其他一切。”<br/>——j·维斯特</p></blockquote><p id="7c1f" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">虽然本文的主要目标是实现包含专用数据库的真正的微服务设计，但Kong为真正的微服务设计提供了可伸缩且易于采用的核心方面。事实上，Kong Gateway允许开发人员保持干燥，引入通用组件驻留在分布式微服务抽象层中。</p><p id="e985" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">请记住，“微服务”包括“微”这个词，它通常被定义为“极小”在任何微服务实施过程中，牢记这一基本前提非常重要。</p><p id="057b" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">特性开发人员利用包和类对他们的程序代码进行分组，以获得可支持性和可维护性。在这些类中，定义了方法和函数——通常采用这样的规则，即每个代码块都很小并且易于理解。对我来说，一个理想的函数或方法是我不需要触摸鼠标就可以查看的。</p><p id="b0d6" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">微服务应该是程序员几十年来一直遵循的规则的延伸:保持事情小、有目的、高效……保持事情“微”</p><p id="a660" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">为了达到这个目标，设计必须包括数据库。</p></div></div>    
</body>
</html>