<html>
<head>
<title>6 Advanced Ruby Loops</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">6个高级Ruby循环</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/6-advanced-ruby-loops-13695c20d012?source=collection_archive---------12-----------------------#2020-01-21">https://betterprogramming.pub/6-advanced-ruby-loops-13695c20d012?source=collection_archive---------12-----------------------#2020-01-21</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="5528" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">Ruby的工具箱里有你需要的一切</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/0d2e1520946c1b8554114b366b798a31.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*zvdhq7lFPXkXwYuW"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">克莱尔·萨特拉在<a class="ae kv" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</p></figure><p id="2b0d" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在过去的几年里，我写了很多Ruby。由于其“<a class="ae kv" href="https://www.artima.com/intv/ruby.html" rel="noopener ugc nofollow" target="_blank">为开发人员的快乐而优化</a>”的原则，这种语言在我心中赢得了特殊的位置。</p><p id="9292" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这是一种易于阅读、编写、板载、模板和原型的语言，还有其他好处。</p><p id="84e2" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">它最好的特性之一是为许多常用的过程提供帮助方法。迭代、排序、过滤、转换等都有语言内置的多个<strong class="ky ir"> </strong> helper方法(在<a class="ae kv" href="https://ruby-doc.org/core-2.7.0/Enumerable.html" rel="noopener ugc nofollow" target="_blank">可枚举模块</a>中)。</p><p id="43b9" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">您可以更多地关注您的逻辑，而不是编写遍历可枚举数的助手方法。</p><p id="04af" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这不仅让代码写起来更有趣，也让代码更易读。</p><p id="6885" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这些助手方法抽象了迭代如何发生的细节，并为逻辑本身提供了舞台。由于代码被读取的次数比被编写的次数多得多，这也有助于提高编码效率。</p><p id="34cb" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">为了分享一些“开发人员的快乐”，我想回顾几个不太为人所知的Ruby循环。这些将使您的代码不那么冗长，更容易阅读，更快编写:</p><ol class=""><li id="cbfa" class="ls lt iq ky b kz la lc ld lf lu lj lv ln lw lr lx ly lz ma bi translated"><code class="fe mb mc md me b">map</code></li><li id="47bd" class="ls lt iq ky b kz mf lc mg lf mh lj mi ln mj lr lx ly lz ma bi translated"><code class="fe mb mc md me b">each_with_object</code></li><li id="0207" class="ls lt iq ky b kz mf lc mg lf mh lj mi ln mj lr lx ly lz ma bi translated"><code class="fe mb mc md me b">each_with_index</code></li><li id="3dab" class="ls lt iq ky b kz mf lc mg lf mh lj mi ln mj lr lx ly lz ma bi translated"><code class="fe mb mc md me b">partition</code></li><li id="88c2" class="ls lt iq ky b kz mf lc mg lf mh lj mi ln mj lr lx ly lz ma bi translated"><code class="fe mb mc md me b">select/reject</code></li><li id="17b1" class="ls lt iq ky b kz mf lc mg lf mh lj mi ln mj lr lx ly lz ma bi translated"><code class="fe mb mc md me b">any?/all?</code></li><li id="f9e6" class="ls lt iq ky b kz mf lc mg lf mh lj mi ln mj lr lx ly lz ma bi translated">奖金:<code class="fe mb mc md me b">find_index</code></li></ol><p id="0443" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">请注意:为了简单起见，我在这里的大多数例子中使用了一个数字数组。但是所有这些方法都适用于数组和散列。两者都被认为是可枚举的。</p></div><div class="ab cl mk ml hu mm" role="separator"><span class="mn bw bk mo mp mq"/><span class="mn bw bk mo mp mq"/><span class="mn bw bk mo mp"/></div><div class="ij ik il im in"><h1 id="ae55" class="mr ms iq bd mt mu mv mw mx my mz na nb jw nc jx nd jz ne ka nf kc ng kd nh ni bi translated"><a class="ae kv" href="https://ruby-doc.org/core-2.7.0/Enumerable.html#method-i-map" rel="noopener ugc nofollow" target="_blank">地图</a></h1><p id="c475" class="pw-post-body-paragraph kw kx iq ky b kz nj jr lb lc nk ju le lf nl lh li lj nm ll lm ln nn lp lq lr ij bi translated">用于从可枚举类型创建数组，并为每个元素应用特定的逻辑。</p><p id="e64f" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">例如，对数字数组中的每个值求平方。因此，不用使用<code class="fe mb mc md me b">each</code>来迭代并将结果插入到另一个数组中，您可以只使用<code class="fe mb mc md me b">map</code>。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="no np l"/></div></figure></div><div class="ab cl mk ml hu mm" role="separator"><span class="mn bw bk mo mp mq"/><span class="mn bw bk mo mp mq"/><span class="mn bw bk mo mp"/></div><div class="ij ik il im in"><h1 id="6eca" class="mr ms iq bd mt mu mv mw mx my mz na nb jw nc jx nd jz ne ka nf kc ng kd nh ni bi translated"><a class="ae kv" href="https://ruby-doc.org/core-2.7.0/Enumerable.html#method-i-each_with_object" rel="noopener ugc nofollow" target="_blank">每个_带_对象</a></h1><p id="4e42" class="pw-post-body-paragraph kw kx iq ky b kz nj jr lb lc nk ju le lf nl lh li lj nm ll lm ln nn lp lq lr ij bi translated">对于通过迭代可枚举对象来创建对象很有用。</p><p id="ecc7" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">例如，如果我们想从一个数组中产生一个散列值呢？还是来自给定散列的一个<code class="fe mb mc md me b">Person</code>对象？</p><p id="20c2" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">您也可以使用<code class="fe mb mc md me b"><a class="ae kv" href="https://ruby-doc.org/core-2.7.0/Enumerable.html#method-i-reduce" rel="noopener ugc nofollow" target="_blank">reduce</a></code>方法，但是我发现它的语法令人困惑，所以我更喜欢<code class="fe mb mc md me b">each_with_object</code>。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="no np l"/></div></figure><p id="ab31" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">专业提示:与<code class="fe mb mc md me b">map</code>不同，您可以将<code class="fe mb mc md me b">if</code>添加到块中，并挑选运行逻辑的元素。</p></div><div class="ab cl mk ml hu mm" role="separator"><span class="mn bw bk mo mp mq"/><span class="mn bw bk mo mp mq"/><span class="mn bw bk mo mp"/></div><div class="ij ik il im in"><h1 id="f053" class="mr ms iq bd mt mu mv mw mx my mz na nb jw nc jx nd jz ne ka nf kc ng kd nh ni bi translated"><a class="ae kv" href="https://ruby-doc.org/core-2.7.0/Enumerable.html#method-i-each_with_index" rel="noopener ugc nofollow" target="_blank"> each_with_index </a></h1><p id="5e9e" class="pw-post-body-paragraph kw kx iq ky b kz nj jr lb lc nk ju le lf nl lh li lj nm ll lm ln nn lp lq lr ij bi translated">当除了迭代可枚举对象之外，还需要使用索引时，这很有用。例如，如果我们需要记录正在处理的当前索引，该怎么办？</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="no np l"/></div></figure></div><div class="ab cl mk ml hu mm" role="separator"><span class="mn bw bk mo mp mq"/><span class="mn bw bk mo mp mq"/><span class="mn bw bk mo mp"/></div><div class="ij ik il im in"><h1 id="5785" class="mr ms iq bd mt mu mv mw mx my mz na nb jw nc jx nd jz ne ka nf kc ng kd nh ni bi translated"><a class="ae kv" href="https://ruby-doc.org/core-2.7.0/Enumerable.html#method-i-partition" rel="noopener ugc nofollow" target="_blank">分区</a></h1><p id="a40c" class="pw-post-body-paragraph kw kx iq ky b kz nj jr lb lc nk ju le lf nl lh li lj nm ll lm ln nn lp lq lr ij bi translated">想象一下，你可以在一行中，根据一个条件，把一个数组分成两个数组。现在停止想象，你可以用<code class="fe mb mc md me b">partition</code>做到这一点:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="no np l"/></div></figure></div><div class="ab cl mk ml hu mm" role="separator"><span class="mn bw bk mo mp mq"/><span class="mn bw bk mo mp mq"/><span class="mn bw bk mo mp"/></div><div class="ij ik il im in"><h1 id="4bb3" class="mr ms iq bd mt mu mv mw mx my mz na nb jw nc jx nd jz ne ka nf kc ng kd nh ni bi translated"><a class="ae kv" href="https://ruby-doc.org/core-2.7.0/Enumerable.html#method-i-select" rel="noopener ugc nofollow" target="_blank">选择/拒绝</a></h1><p id="902c" class="pw-post-body-paragraph kw kx iq ky b kz nj jr lb lc nk ju le lf nl lh li lj nm ll lm ln nn lp lq lr ij bi translated"><code class="fe mb mc md me b">select</code>遍历一个可枚举数，只返回回答给定块的元素。<code class="fe mb mc md me b">rejects</code>行为相同但相反，它返回不符合条件的:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="no np l"/></div></figure><p id="737b" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">对于数组来说，<code class="fe mb mc md me b">select</code>和<code class="fe mb mc md me b">reject</code>也有<code class="fe mb mc md me b">!</code> (bang)风格:<code class="fe mb mc md me b">select!</code>和<code class="fe mb mc md me b">reject!</code>。这些将修改给定的可枚举值(<code class="fe mb mc md me b">!</code>通常用于表示破坏性操作)，所以使用时要小心。</p></div><div class="ab cl mk ml hu mm" role="separator"><span class="mn bw bk mo mp mq"/><span class="mn bw bk mo mp mq"/><span class="mn bw bk mo mp"/></div><div class="ij ik il im in"><h1 id="f3d4" class="mr ms iq bd mt mu mv mw mx my mz na nb jw nc jx nd jz ne ka nf kc ng kd nh ni bi translated"><a class="ae kv" href="https://ruby-doc.org/core-2.7.0/Enumerable.html#method-i-any-3F" rel="noopener ugc nofollow" target="_blank">任何？/全部？</a></h1><p id="2ca7" class="pw-post-body-paragraph kw kx iq ky b kz nj jr lb lc nk ju le lf nl lh li lj nm ll lm ln nn lp lq lr ij bi translated"><code class="fe mb mc md me b">any?</code>检查可枚举中至少有一个元素对应于一个条件。<code class="fe mb mc md me b">all?</code>验证所有元素是否符合清单。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="no np l"/></div></figure></div><div class="ab cl mk ml hu mm" role="separator"><span class="mn bw bk mo mp mq"/><span class="mn bw bk mo mp mq"/><span class="mn bw bk mo mp"/></div><div class="ij ik il im in"><h1 id="6113" class="mr ms iq bd mt mu mv mw mx my mz na nb jw nc jx nd jz ne ka nf kc ng kd nh ni bi translated">奖金:<a class="ae kv" href="https://ruby-doc.org/core-2.7.0/Enumerable.html#method-i-find_index" rel="noopener ugc nofollow" target="_blank"> find_index </a></h1><p id="2c2d" class="pw-post-body-paragraph kw kx iq ky b kz nj jr lb lc nk ju le lf nl lh li lj nm ll lm ln nn lp lq lr ij bi translated">有时，您只需要找到与条件匹配的元素的索引:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="no np l"/></div></figure></div><div class="ab cl mk ml hu mm" role="separator"><span class="mn bw bk mo mp mq"/><span class="mn bw bk mo mp mq"/><span class="mn bw bk mo mp"/></div><div class="ij ik il im in"><h1 id="3d6e" class="mr ms iq bd mt mu mv mw mx my mz na nb jw nc jx nd jz ne ka nf kc ng kd nh ni bi translated">最后一次重复这个话题</h1><ol class=""><li id="0192" class="ls lt iq ky b kz nj lc nk lf nq lj nr ln ns lr lx ly lz ma bi translated">如果您需要一种特殊的方法来迭代Ruby中的可枚举数，很有可能它已经存在了。如果你使用一个框架(比如Rails)，你可能会有<a class="ae kv" href="https://apidock.com/rails/Enumerable" rel="noopener ugc nofollow" target="_blank">甚至更多的方法</a>，因为它们包含了在基本集合上扩展的gem。</li><li id="bca1" class="ls lt iq ky b kz mf lc mg lf mh lj mi ln mj lr lx ly lz ma bi translated">上面的助手方法帮助你编写更简洁和更集中的代码，从而使人们更容易阅读。</li></ol><p id="d50d" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">感谢阅读！</p></div></div>    
</body>
</html>