<html>
<head>
<title>Advanced Asynchronous Operations Using Generics in Swift</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Swift中使用泛型的高级异步操作</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/advanced-asynchronous-operations-using-generics-in-swift-b55932a15f6a?source=collection_archive---------9-----------------------#2019-12-10">https://betterprogramming.pub/advanced-asynchronous-operations-using-generics-in-swift-b55932a15f6a?source=collection_archive---------9-----------------------#2019-12-10</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="c752" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">让您的异步操作更上一层楼</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/85143d23647616812ca00b1e85e19b50.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*oJ6-SZXqS_BAAb8691MJ7Q.jpeg"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">照片由<a class="ae ky" href="https://unsplash.com/@maxcodes?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Max Nelson </a>在<a class="ae ky" href="https://unsplash.com/s/photos/swift?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</p></figure><p id="3659" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">异步操作允许您以不同的方式编写长时间运行的任务，同时在几个任务之间添加依赖关系。通过使用<code class="fe lv lw lx ly b">OperationQueue</code>，可以跟踪进度并简化调度。通过添加泛型和Swift结果类型，我们可以从异步操作中获得更多。</p><p id="22eb" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在<a class="ae ky" href="https://www.avanderlee.com/swift/operations/" rel="noopener ugc nofollow" target="_blank">开始操作</a>和<a class="ae ky" href="https://www.avanderlee.com/swift/asynchronous-operations/" rel="noopener ugc nofollow" target="_blank">使用异步操作</a>编写并发解决方案之后，现在是时候看看我们如何为我们的代码库创建一个更高级的解决方案了。这完全基于我们在<a class="ae ky" href="https://collect.bywetransfer.com/" rel="noopener ugc nofollow" target="_blank"> Collect by WeTransfer </a>应用中使用的实现，其中我们使用了50多种不同的操作。</p></div><div class="ab cl lz ma hx mb" role="separator"><span class="mc bw bk md me mf"/><span class="mc bw bk md me mf"/><span class="mc bw bk md me"/></div><div class="im in io ip iq"><h1 id="5ce3" class="mg mh it bd mi mj mk ml mm mn mo mp mq jz mr ka ms kc mt kd mu kf mv kg mw mx bi translated">创建结果驱动的异步操作</h1><p id="e691" class="pw-post-body-paragraph kz la it lb b lc my ju le lf mz jx lh li na lk ll lm nb lo lp lq nc ls lt lu im bi translated">通常情况下，运算会产生一个特定的值。至少有一种方法来捕捉发生的错误是有价值的。在Swift的<code class="fe lv lw lx ly b">Result&lt;Success, Failure&gt;</code>类型中，值和误差一起出现。</p><h2 id="9b97" class="nd mh it bd mi ne nf dn mm ng nh dp mq li ni nj ms lm nk nl mu lq nm nn mw no bi translated">向异步操作添加泛型</h2><p id="48ea" class="pw-post-body-paragraph kz la it lb b lc my ju le lf mz jx lh li na lk ll lm nb lo lp lq nc ls lt lu im bi translated">通过利用博客文章<a class="ae ky" href="https://www.avanderlee.com/swift/asynchronous-operations/" rel="noopener ugc nofollow" target="_blank">中创建的<code class="fe lv lw lx ly b">AsyncOperation</code>来编写并发解决方案</a>，我们给了自己一个kickstart。我们将相同的泛型作为结果类型添加到它的上面，这导致了下面的基础:</p><pre class="kj kk kl km gt np ly nq nr aw ns bi"><span id="29da" class="nd mh it ly b gy nt nu l nv nw">class AsyncResultOperation&lt;Success, Failure&gt;: AsyncOperation where Failure: Error {<br/><br/>    private(set) var result: Result&lt;Success, Failure&gt;?<br/><br/>}</span></pre><p id="a2a8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这为异步任务提供了一个链接的结果类型，对于值和错误都有一个泛型。</p><h2 id="4c39" class="nd mh it bd mi ne nf dn mm ng nh dp mq li ni nj ms lm nk nl mu lq nm nn mw no bi translated">确保完工后的结果</h2><p id="6164" class="pw-post-body-paragraph kz la it lb b lc my ju le lf mz jx lh li na lk ll lm nb lo lp lq nc ls lt lu im bi translated">为了确保结果的更新，我们在finish方法中添加了一个检查来帮助实现者，并在开发时给他们反馈:</p><pre class="kj kk kl km gt np ly nq nr aw ns bi"><span id="cdf4" class="nd mh it ly b gy nt nu l nv nw">final override func finish() {<br/>    guard !isCancelled else { return super.finish() }<br/>    fatalError("Make use of finish(with:) instead to ensure a result")<br/>}<br/><br/>func finish(with result: Result&lt;Success, Failure&gt;) {<br/>    self.result = result<br/>    super.finish()<br/>}</span></pre><p id="c363" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">首先，我们确保默认的<code class="fe lv lw lx ly b">finish()</code>方法不再有用。当它的一个实现者使用它时，它抛出一个致命的异常:</p><pre class="kj kk kl km gt np ly nq nr aw ns bi"><span id="7e35" class="nd mh it ly b gy nt nu l nv nw">Fatal error: Make use of finish(with:) instead to ensure a result: file UnfurlURLOperation.swift, line 44</span></pre><p id="1ee5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">其次，我们添加了一个新的<code class="fe lv lw lx ly b">finish(with:)</code>方法，强制实现者设置结果。</p><h2 id="7e2b" class="nd mh it bd mi ne nf dn mm ng nh dp mq li ni nj ms lm nk nl mu lq nm nn mw no bi translated">确保取消的结果</h2><p id="484f" class="pw-post-body-paragraph kz la it lb b lc my ju le lf mz jx lh li na lk ll lm nb lo lp lq nc ls lt lu im bi translated">最后一部分确保我们有一个关于取消的结果集。因为我们喜欢有一种类型的错误，我们被迫在类中创建另一个覆盖:</p><pre class="kj kk kl km gt np ly nq nr aw ns bi"><span id="fbb3" class="nd mh it ly b gy nt nu l nv nw">override func cancel() {<br/>    fatalError("Make use of cancel(with:) instead to ensure a result")<br/>}<br/><br/>func cancel(with error: Failure) {<br/>    self.result = .failure(error)<br/>    super.cancel()<br/>}</span></pre><p id="fcfb" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们必须在错误枚举中为取消定义一个case。这样做给了我们强类型错误的好处，同时仍然能够在取消时得到结果。</p><h2 id="ed0f" class="nd mh it bd mi ne nf dn mm ng nh dp mq li ni nj ms lm nk nl mu lq nm nn mw no bi translated">将所有这些放在一个示例操作中</h2><p id="a651" class="pw-post-body-paragraph kz la it lb b lc my ju le lf mz jx lh li na lk ll lm nb lo lp lq nc ls lt lu im bi translated">最后的<code class="fe lv lw lx ly b">AsyncResultOperation</code>是这样的:</p><pre class="kj kk kl km gt np ly nq nr aw ns bi"><span id="c498" class="nd mh it ly b gy nt nu l nv nw">open class AsyncResultOperation&lt;Success, Failure&gt;: AsyncOperation where Failure: Error {<br/><br/>    private(set) public var result: Result&lt;Success, Failure&gt;?<br/><br/>    final override public func finish() {<br/>        guard !isCancelled else { return super.finish() }<br/>        fatalError("Make use of finish(with:) instead to ensure a result")<br/>    }<br/><br/>    public func finish(with result: Result&lt;Success, Failure&gt;) {<br/>        self.result = result<br/>        super.finish()<br/>    }<br/><br/>    override open func cancel() {<br/>        fatalError("Make use of cancel(with:) instead to ensure a result")<br/>    }<br/><br/>    public func cancel(with error: Failure) {<br/>        self.result = .failure(error)<br/>        super.cancel()<br/>    }<br/>}</span></pre><p id="8f88" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们可以通过创建一个自定义操作来利用这个类，比如展开短url的任务。</p><pre class="kj kk kl km gt np ly nq nr aw ns bi"><span id="d7af" class="nd mh it ly b gy nt nu l nv nw">final class UnfurlURLOperation: AsyncResultOperation&lt;URL, UnfurlURLOperation.Error&gt; {<br/>    enum Error: Swift.Error {<br/>        case canceled<br/>        case missingRedirectURL<br/>        case underlying(error: Swift.Error)<br/>    }<br/><br/>    private let shortURL: URL<br/>    private var dataTask: URLSessionTask?<br/><br/>    init(shortURL: URL) {<br/>        self.shortURL = shortURL<br/>    }<br/><br/>    override func main() {<br/>        var request = URLRequest(url: shortURL)<br/>        request.httpMethod = "HEAD"<br/><br/>        dataTask = URLSession.shared.dataTask(with: request, completionHandler: { [weak self] (_, response, error) in<br/>            if let error = error {<br/>                self?.finish(with: .failure(Error.underlying(error: error)))<br/>                return<br/>            }<br/><br/>            guard let longURL = response?.url else {<br/>                self?.finish(with: .failure(Error.missingRedirectURL))<br/>                return<br/>            }<br/><br/>            self?.finish(with: .success(longURL))<br/>        })<br/>        dataTask?.resume()<br/>    }<br/><br/>    override func cancel() {<br/>        dataTask?.cancel()<br/>        cancel(with: .canceled)<br/>    }<br/>}</span></pre><p id="4462" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这个类获取一个短URL，执行一个<code class="fe lv lw lx ly b">HEAD</code>请求来获取长URL，并返回结果。如果出现任何错误，那都是操作的结果。最后，我们确保在取消时取消数据任务，并使用我们的<code class="fe lv lw lx ly b">canceled</code>错误案例调用<code class="fe lv lw lx ly b">cancel(with:)</code>方法。</p><p id="6d9a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">执行这个方法最终得到的结果是<code class="fe lv lw lx ly b">www.avanderlee.com</code>作为展开的URL:</p><pre class="kj kk kl km gt np ly nq nr aw ns bi"><span id="0c58" class="nd mh it ly b gy nt nu l nv nw">let queue = OperationQueue()<br/>let unfurlOperation = UnfurlURLOperation(shortURL: URL(string: "https://bit.ly/33UDb5L")!)<br/>queue.addOperations([unfurlOperation], waitUntilFinished: true)<br/>print("Operation finished with: \(unfurlOperation.result!)")<br/><br/>// Prints: Operation finished with: success(https://www.avanderlee.com/)</span></pre></div><div class="ab cl lz ma hx mb" role="separator"><span class="mc bw bk md me mf"/><span class="mc bw bk md me mf"/><span class="mc bw bk md me"/></div><div class="im in io ip iq"><h1 id="a410" class="mg mh it bd mi mj mk ml mm mn mo mp mq jz mr ka ms kc mt kd mu kf mv kg mw mx bi translated">任务的强类型链接</h1><p id="3882" class="pw-post-body-paragraph kz la it lb b lc my ju le lf mz jx lh li na lk ll lm nb lo lp lq nc ls lt lu im bi translated">虽然上面的操作已经很有价值了，但是我们可以再走一步，让操作更加灵活。我们可以通过创建一个链式异步操作来做到这一点。</p><p id="219c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">该操作考虑了依赖性，并使用其依赖性的结果作为输入。我们首先创建一个新的<code class="fe lv lw lx ly b">ChainedAsyncOperation</code>类，它将输入和输出作为通用参数:</p><pre class="kj kk kl km gt np ly nq nr aw ns bi"><span id="0c7a" class="nd mh it ly b gy nt nu l nv nw">open class ChainedAsyncResultOperation&lt;Input, Output, Failure&gt;: AsyncResultOperation&lt;Output, Failure&gt; where Failure: Swift.Error {<br/><br/>    private(set) public var input: Input?<br/><br/>    public init(input: Input? = nil) {<br/>        self.input = input<br/>    }<br/>}</span></pre><p id="1991" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们创建一个带有可选输入的初始化器。由于这个链必须从某个地方开始，我们需要有一个选项来手动设置输入，而不是从依赖项中推迟它。</p><h2 id="6ca0" class="nd mh it bd mi ne nf dn mm ng nh dp mq li ni nj ms lm nk nl mu lq nm nn mw no bi translated">从依赖项更新输入</h2><p id="6882" class="pw-post-body-paragraph kz la it lb b lc my ju le lf mz jx lh li na lk ll lm nb lo lp lq nc ls lt lu im bi translated">下一步是更新依赖项的输入。我们希望在任务开始时就这样做，这可以通过覆盖<code class="fe lv lw lx ly b">start()</code>方法来实现。</p><pre class="kj kk kl km gt np ly nq nr aw ns bi"><span id="8353" class="nd mh it ly b gy nt nu l nv nw">override public final func start() {<br/>    updateInputFromDependencies()<br/>    super.start()<br/>}<br/><br/>/// Updates the input by fetching the output of its dependencies.<br/>/// Will always get the first output matching dependency.<br/>/// If `input` is already set, the input from dependencies will be ignored.<br/>private func updateInputFromDependencies() {<br/>    guard input == nil else { return }<br/>    input = dependencies.compactMap { dependency in<br/>        return (dependency as? ChainedOperationOutputProviding)?.output as? Input<br/>    }.first<br/>}</span></pre><p id="ec7c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如你所见，我们已经创建了一个新的<code class="fe lv lw lx ly b">ChainedOperationOutputProviding</code>协议。这个协议允许我们从链中的另一个操作获取输出。协议本身看起来如下:</p><pre class="kj kk kl km gt np ly nq nr aw ns bi"><span id="eb54" class="nd mh it ly b gy nt nu l nv nw">protocol ChainedOperationOutputProviding {<br/>    var output: Any? { get }<br/>}<br/><br/>extension ChainedAsyncResultOperation: ChainedOperationOutputProviding {<br/>    var output: Any? {<br/>        return try? result?.get()<br/>    }<br/>}</span></pre><h2 id="24bb" class="nd mh it bd mi ne nf dn mm ng nh dp mq li ni nj ms lm nk nl mu lq nm nn mw no bi translated">通过链接两个操作将它们放在一起</h2><p id="368d" class="pw-post-body-paragraph kz la it lb b lc my ju le lf mz jx lh li na lk ll lm nb lo lp lq nc ls lt lu im bi translated">最后一个链接的操作类如下所示:</p><pre class="kj kk kl km gt np ly nq nr aw ns bi"><span id="1827" class="nd mh it ly b gy nt nu l nv nw">open class ChainedAsyncResultOperation&lt;Input, Output, Failure&gt;: AsyncResultOperation&lt;Output, Failure&gt; where Failure: Swift.Error {<br/><br/>    private(set) public var input: Input?<br/><br/>    public init(input: Input? = nil) {<br/>        self.input = input<br/>    }<br/><br/>    override public final func start() {<br/>        updateInputFromDependencies()<br/>        super.start()<br/>    }<br/><br/>    /// Updates the input by fetching the output of its dependencies.<br/>    /// Will always get the first output matching dependency.<br/>    /// If `input` is already set, the input from dependencies will be ignored.<br/>    private func updateInputFromDependencies() {<br/>        guard input == nil else { return }<br/>        input = dependencies.compactMap { dependency in<br/>            return (dependency as? ChainedOperationOutputProviding)?.output as? Input<br/>        }.first<br/>    }<br/>}</span></pre><p id="2807" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们可以使用这个类来创建一个操作链。例如，通过添加另一个获取展开的url的标题的操作来获取前面的展开操作。为此，我们必须创建一个新的<code class="fe lv lw lx ly b">FetchTitleChainedOperation</code>:</p><pre class="kj kk kl km gt np ly nq nr aw ns bi"><span id="e3b1" class="nd mh it ly b gy nt nu l nv nw">public final class FetchTitleChainedOperation: ChainedAsyncResultOperation&lt;URL, String, FetchTitleChainedOperation.Error&gt; {<br/>    public enum Error: Swift.Error {<br/>        case canceled<br/>        case dataParsingFailed<br/>        case missingInputURL<br/>        case missingPageTitle<br/>        case underlying(error: Swift.Error)<br/>    }<br/><br/>    private var dataTask: URLSessionTask?<br/><br/>    override final public func main() {<br/>        guard let input = input else { return finish(with: .failure(.missingInputURL)) }<br/><br/>        var request = URLRequest(url: input)<br/>        request.httpMethod = "GET"<br/><br/>        dataTask = URLSession.shared.dataTask(with: request, completionHandler: { [weak self] (data, response, error) in<br/>            do {<br/>                if let error = error {<br/>                    throw error<br/>                }<br/><br/>                guard let data = data, let html = String(data: data, encoding: .utf8) else {<br/>                    throw Error.dataParsingFailed<br/>                }<br/><br/>                guard let pageTitle = self?.pageTitle(for: html) else {<br/>                    throw Error.missingPageTitle<br/>                }<br/><br/>                self?.finish(with: .success(pageTitle))<br/>            } catch {<br/>                if let error = error as? Error {<br/>                    self?.finish(with: .failure(error))<br/>                }<br/>                self?.finish(with: .failure(.underlying(error: error)))<br/>            }<br/>        })<br/>        dataTask?.resume()<br/>    }<br/><br/>    private func pageTitle(for html: String) -&gt; String? {<br/>        guard let rangeFrom = html.range(of: "&lt;title&gt;")?.upperBound else { return nil }<br/>        guard let rangeTo = html[rangeFrom...].range(of: "&lt;/title&gt;")?.lowerBound else { return nil }<br/>        return String(html[rangeFrom..&lt;rangeTo])<br/>    }<br/><br/>    override final public func cancel() {<br/>        dataTask?.cancel()<br/>        cancel(with: .canceled)<br/>    }<br/>}</span></pre><p id="a7d5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">该操作获取输入URL，执行GET请求，并从最终的HTML结果中获取标题。</p><p id="96f3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">两者一起执行看起来像这样:</p><pre class="kj kk kl km gt np ly nq nr aw ns bi"><span id="4f69" class="nd mh it ly b gy nt nu l nv nw">let queue = OperationQueue()<br/>let unfurlOperation = UnfurlURLChainedOperation(shortURL: URL(string: "https://bit.ly/33UDb5L")!)<br/>let fetchTitleOperation = FetchTitleChainedOperation()<br/>fetchTitleOperation.addDependency(unfurlOperation)<br/><br/>queue.addOperations([unfurlOperation, fetchTitleOperation], waitUntilFinished: true)<br/><br/>print("Operation finished with: \(fetchTitleOperation.result!)")<br/>// Prints: Operation finished with: success("A weekly Swift Blog on Xcode and iOS Development - SwiftLee")</span></pre><p id="1bd9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">该代码演示了在设置好操作之后将它们链接在一起是多么容易。在操作之间添加一个依赖关系，这一切都解决了。</p><p id="1a60" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果您必须执行多个重要的任务，并且希望将代码分开，那么组合任务尤其有用。它允许您确保关注点的分离和隔离的可测试代码。</p></div><div class="ab cl lz ma hx mb" role="separator"><span class="mc bw bk md me mf"/><span class="mc bw bk md me mf"/><span class="mc bw bk md me"/></div><div class="im in io ip iq"><h1 id="9d50" class="mg mh it bd mi mj mk ml mm mn mo mp mq jz mr ka ms kc mt kd mu kf mv kg mw mx bi translated">结论</h1><p id="044f" class="pw-post-body-paragraph kz la it lb b lc my ju le lf mz jx lh li na lk ll lm nb lo lp lq nc ls lt lu im bi translated">就是这样！我们利用Swift中的泛型创建了高级操作。通过将它们链接在一起，我们可以在保持代码分离的同时创建任务之间的关系。</p><p id="605c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这件作品是一个系列的一部分:</p><ul class=""><li id="ae00" class="nx ny it lb b lc ld lf lg li nz lm oa lq ob lu oc od oe of bi translated"><a class="ae ky" href="https://www.avanderlee.com/swift/operations/" rel="noopener ugc nofollow" target="_blank">Swift中的操作和操作队列入门</a></li><li id="8efc" class="nx ny it lb b lc og lf oh li oi lm oj lq ok lu oc od oe of bi translated"><a class="ae ky" href="https://www.avanderlee.com/swift/asynchronous-operations/" rel="noopener ugc nofollow" target="_blank">Swift中编写并发解决方案的异步操作</a></li><li id="d933" class="nx ny it lb b lc og lf oh li oi lm oj lq ok lu oc od oe of bi translated"><a class="ae ky" href="https://www.avanderlee.com/swift/advanced-asynchronous-operations/" rel="noopener ugc nofollow" target="_blank">利用泛型实现高级异步操作</a></li></ul><p id="28ab" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果您想进一步提高您的Swift知识，请查看<a class="ae ky" href="https://www.avanderlee.com/category/swift/" rel="noopener ugc nofollow" target="_blank"> Swift类别页面</a>。</p><p id="aed1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">谢谢！</p></div></div>    
</body>
</html>