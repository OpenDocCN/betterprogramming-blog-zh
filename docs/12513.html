<html>
<head>
<title>New in iOS 16 — Self-resizing UICollectionView Cells</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">iOS 16中的新功能—自动调整UICollectionView单元格的大小</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/new-in-ios-16-self-resizing-uicollectionview-cells-f02fbb7b45b1?source=collection_archive---------1-----------------------#2022-06-10">https://betterprogramming.pub/new-in-ios-16-self-resizing-uicollectionview-cells-f02fbb7b45b1?source=collection_archive---------1-----------------------#2022-06-10</a></blockquote><div><div class="fc ii ij ik il im"/><div class="in io ip iq ir"><div class=""/><div class=""><h2 id="3d30" class="pw-subtitle-paragraph jr it iu bd b js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki dk translated">在iOS 16中使用复合布局和不同的数据源构建可扩展的UICollectionView</h2></div><figure class="kk kl km kn gu ko gi gj paragraph-image"><div role="button" tabindex="0" class="kp kq di kr bf ks"><div class="gi gj kj"><img src="../Images/19432d22c579e607dccada9113a562e8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*fPaVA9-uI2QcSYQB"/></div></div><p class="kv kw gk gi gj kx ky bd b be z dk translated">由<a class="ae kz" href="https://unsplash.com/@markusspiske?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Markus Spiske </a>在<a class="ae kz" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</p></figure><p id="daee" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">创建动态表格视图或集合视图单元格是一个挑战，大多数iOS开发人员都曾在某个时候遇到过这个问题。从使用<code class="fe lw lx ly lz b">estimatedRowHeight</code>到创建定制的<code class="fe lw lx ly lz b">UICollectionViewLayout</code>——为<code class="fe lw lx ly lz b">UICollectionViewCell</code>设置动态大小需要实现一堆方法——尽管引入了组合布局，但我总是求助于菜谱代码</p><p id="c7ec" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">令人高兴的是，在2022年WWDC奥运会上，苹果公司对其UIKit框架进行了重大改进。在iOS 16中，表格视图和集合视图单元格现在可以通过默认启用的<code class="fe lw lx ly lz b">selfSizingInvalidation</code>属性根据内容自动调整大小。</p><p id="be5e" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">要手动/编程调整单元格的大小，我们可以调用<code class="fe lw lx ly lz b">invalidateIntrinsicContentSize()</code>。如果你想在没有动画的情况下调整单元格的大小——调用<code class="fe lw lx ly lz b">UIView.performWithoutAnimation</code>函数中的<code class="fe lw lx ly lz b">invalidateIntrinsicContentSize()</code>。</p><p id="27cb" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">现在我们已经了解了这个不错的升级，让我们来构建我们的现代收藏视图iOS应用程序。</p><p id="7cb7" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">在接下来的几节中，我们将使用iOS 16功能构建一个可扩展的收藏视图，而不依赖于重新加载项目或创建自定义单元格。</p><p id="785c" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">对于门外汉来说，在iOS 15中，不同的数据源引入了一种新的方法来就地更新单元格，而无需替换现有的单元格。这是通过<code class="fe lw lx ly lz b"><a class="ae kz" href="https://developer.apple.com/documentation/uikit/nsdiffabledatasourcesnapshot/3804468-reconfigureitems" rel="noopener ugc nofollow" target="_blank">reconfigureItems</a></code>功能实现的。</p><h1 id="470a" class="ma mb iu bd mc md me mf mg mh mi mj mk ka ml kb mm kd mn ke mo kg mp kh mq mr bi translated">积木</h1><ul class=""><li id="9486" class="ms mt iu lc b ld mu lg mv lj mw ln mx lr my lv mz na nb nc bi translated">使用复合布局创建收藏视图</li><li id="dc94" class="ms mt iu lc b ld nd lg ne lj nf ln ng lr nh lv mz na nb nc bi translated">添加虚拟数据。在我们的例子中，我们将通过不同的数据源向集合视图提供一系列电影(带有描述细节)。</li><li id="a962" class="ms mt iu lc b ld nd lg ne lj nf ln ng lr nh lv mz na nb nc bi translated">选择时展开和折叠集合视图单元格。对于我们的用例，我们将显示和隐藏电影细节。</li></ul><p id="9ce6" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">让我们开始吧。</p></div><div class="ab cl ni nj hy nk" role="separator"><span class="nl bw bk nm nn no"/><span class="nl bw bk nm nn no"/><span class="nl bw bk nm nn"/></div><div class="in io ip iq ir"><h1 id="6cb6" class="ma mb iu bd mc md np mf mg mh nq mj mk ka nr kb mm kd ns ke mo kg nt kh mq mr bi translated">设置我们的数据模型</h1><p id="627f" class="pw-post-body-paragraph la lb iu lc b ld mu jv lf lg mv jy li lj nu ll lm ln nv lp lq lr nw lt lu lv in bi translated">我们将数据保存在一个<code class="fe lw lx ly lz b">Movie</code>类中，如下所示:</p><figure class="kk kl km kn gu ko"><div class="bz fq l di"><div class="nx ny l"/></div></figure><p id="91e7" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">为了简化这个例子，我们将电影<code class="fe lw lx ly lz b">name</code>设置为唯一标识符。<code class="fe lw lx ly lz b">showDetails</code>标志将用于展开和折叠集合视图。</p><p id="f03b" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">上面代码中的<code class="fe lw lx ly lz b">Section</code>是一个隐式符合<code class="fe lw lx ly lz b">Hashable</code>的enum。它包含两个值——表示集合视图中的两个部分。</p></div><div class="ab cl ni nj hy nk" role="separator"><span class="nl bw bk nm nn no"/><span class="nl bw bk nm nn no"/><span class="nl bw bk nm nn"/></div><div class="in io ip iq ir"><h1 id="fb07" class="ma mb iu bd mc md np mf mg mh nq mj mk ka nr kb mm kd ns ke mo kg nt kh mq mr bi translated">设置我们的收藏视图</h1><p id="3211" class="pw-post-body-paragraph la lb iu lc b ld mu jv lf lg mv jy li lj nu ll lm ln nv lp lq lr nw lt lu lv in bi translated">下面是设置您的<code class="fe lw lx ly lz b">UICollectionView</code>布局和配置的代码:</p><figure class="kk kl km kn gu ko"><div class="bz fq l di"><div class="nx ny l"/></div></figure><p id="5e65" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">抛开<code class="fe lw lx ly lz b">//1</code>和<code class="fe lw lx ly lz b">//2</code>(这意味着配置不同的数据源)，其余的代码配置我们的集合视图。</p><p id="1cbe" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">首先，<code class="fe lw lx ly lz b">List</code>布局是在iOS 14中引入的，建立在组合布局之上，以提供类似于TableView的设计体验。在上面的代码中，我们利用它来设置我们的配置风格，然后传递给组合布局——最终传递给<code class="fe lw lx ly lz b">UICollectionView</code>初始化器。</p><p id="c04f" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">现在来看看我们的<code class="fe lw lx ly lz b">dataSource</code>。</p></div><div class="ab cl ni nj hy nk" role="separator"><span class="nl bw bk nm nn no"/><span class="nl bw bk nm nn no"/><span class="nl bw bk nm nn"/></div><div class="in io ip iq ir"><h1 id="9f0f" class="ma mb iu bd mc md np mf mg mh nq mj mk ka nr kb mm kd ns ke mo kg nt kh mq mr bi translated">配置不同的数据源</h1><p id="2b28" class="pw-post-body-paragraph la lb iu lc b ld mu jv lf lg mv jy li lj nu ll lm ln nv lp lq lr nw lt lu lv in bi translated">下面是我们的<code class="fe lw lx ly lz b">makeDataSource()</code>函数的代码:</p><figure class="kk kl km kn gu ko"><div class="bz fq l di"><div class="nx ny l"/></div></figure><p id="9b74" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">上面的代码中发生了很多事情，如果构建现代集合视图对您来说是新的，这里有一些您应该关注的推论:</p><ul class=""><li id="119d" class="ms mt iu lc b ld le lg lh lj nz ln oa lr ob lv mz na nb nc bi translated"><code class="fe lw lx ly lz b">UICollectionView.CellRegistration</code> struct是iOS 14推出的。当在<code class="fe lw lx ly lz b">dequeueConfiguredReusableCell</code>内部传递时，它隐式地处理单元注册。所以，和使用标识符注册细胞说再见吧。</li><li id="25c2" class="ms mt iu lc b ld nd lg ne lj nf ln ng lr nh lv mz na nb nc bi translated"><code class="fe lw lx ly lz b">UICollectionViewListCell</code>是带来类似<code class="fe lw lx ly lz b">UITableView</code>的单元格样式的具体类。我们已经在该单元格上调用了<code class="fe lw lx ly lz b">defaultContentConfiguration</code>函数。获取该配置后，我们基于布尔标志逻辑设置单元标签文本和描述。</li><li id="51d8" class="ms mt iu lc b ld nd lg ne lj nf ln ng lr nh lv mz na nb nc bi translated"><code class="fe lw lx ly lz b">UICollectionViewDiffableDataSource</code>内的<code class="fe lw lx ly lz b">cellProvider</code>闭合类似于<code class="fe lw lx ly lz b">to collectionView(_:cellForItemAt:)</code></li></ul><p id="518d" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">现在，我们已经配置了数据源，下面是我们的虚拟数据:</p><figure class="kk kl km kn gu ko"><div class="bz fq l di"><div class="nx ny l"/></div></figure></div><div class="ab cl ni nj hy nk" role="separator"><span class="nl bw bk nm nn no"/><span class="nl bw bk nm nn no"/><span class="nl bw bk nm nn"/></div><div class="in io ip iq ir"><h1 id="15f6" class="ma mb iu bd mc md np mf mg mh nq mj mk ka nr kb mm kd ns ke mo kg nt kh mq mr bi translated">重新配置集合视图项目</h1><p id="a12c" class="pw-post-body-paragraph la lb iu lc b ld mu jv lf lg mv jy li lj nu ll lm ln nv lp lq lr nw lt lu lv in bi translated">要创建一个可扩展的集合视图单元格，我们只需反转<code class="fe lw lx ly lz b">didSelectItem</code>委托方法中的<code class="fe lw lx ly lz b">showDetails</code>值:</p><figure class="kk kl km kn gu ko"><div class="bz fq l di"><div class="nx ny l"/></div></figure><p id="7224" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">其余的逻辑不言自明。</p></div><div class="ab cl ni nj hy nk" role="separator"><span class="nl bw bk nm nn no"/><span class="nl bw bk nm nn no"/><span class="nl bw bk nm nn"/></div><div class="in io ip iq ir"><h1 id="cdb6" class="ma mb iu bd mc md np mf mg mh nq mj mk ka nr kb mm kd ns ke mo kg nt kh mq mr bi translated">输出</h1><p id="e477" class="pw-post-body-paragraph la lb iu lc b ld mu jv lf lg mv jy li lj nu ll lm ln nv lp lq lr nw lt lu lv in bi translated">这是最后一个应用程序:</p><figure class="kk kl km kn gu ko gi gj paragraph-image"><div class="gi gj oc"><img src="../Images/5c3a18e209a38e71219f2529957c3de2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1252/1*PfElnFUMfBcsUScB6lXgFA.gif"/></div></figure></div><div class="ab cl ni nj hy nk" role="separator"><span class="nl bw bk nm nn no"/><span class="nl bw bk nm nn no"/><span class="nl bw bk nm nn"/></div><div class="in io ip iq ir"><p id="e57e" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">另一个例子可能是—在集合视图单元格中添加一个文本字段，并查看它如何随着类型自动扩展。</p><p id="f915" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">你可以在这个<a class="ae kz" href="https://github.com/anupamchugh/ios16ExpandableCollectionView" rel="noopener ugc nofollow" target="_blank"> GitHub库</a>上找到完整的源代码。</p><p id="ffba" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">感谢阅读。</p></div></div>    
</body>
</html>