<html>
<head>
<title>Save Your Linux Machine From Certain Death</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">从死亡中拯救你的Linux机器</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/save-your-linux-machine-from-certain-death-24ced335d969?source=collection_archive---------5-----------------------#2020-04-30">https://betterprogramming.pub/save-your-linux-machine-from-certain-death-24ced335d969?source=collection_archive---------5-----------------------#2020-04-30</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="48dc" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">恢复您的根密码和更多</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/c6781d1ca3d29daf121ffabdd58b87c6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*-n0CXnUZRT0eQy_wyk1XuQ.jpeg"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">照片由<a class="ae ky" href="https://unsplash.com/@designbytholen?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">雷金·索伦</a>在<a class="ae ky" href="https://unsplash.com/?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</p></figure><p id="7238" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">排除损坏系统的故障是每个系统管理员、SRE或DevOps工程师的基本技能。我们每个人都会时不时地遇到与操作系统相关的问题，当事情变得非常糟糕时，最好做好准备。</p><p id="0b36" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">能够快速识别问题并采取行动以防止任何重大损害尤其有益。为了在本文中有所帮助，我们将回顾一些您可能遇到的常见问题，以及收集信息、故障诊断和解决这些问题的方法。</p><p id="02eb" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">注:本文使用<a class="ae ky" href="https://www.redhat.com/en/enterprise-linux-8" rel="noopener ugc nofollow" target="_blank"> RHEL 8 </a> / <a class="ae ky" href="https://www.centos.org/" rel="noopener ugc nofollow" target="_blank">百分位</a>。但是，下面的例子/概念可以应用于任何Linux发行版。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="5fd9" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">恢复R <code class="fe mu mv mw mx b">oot</code>密码</h1><p id="db91" class="pw-post-body-paragraph kz la it lb b lc my ju le lf mz jx lh li na lk ll lm nb lo lp lq nc ls lt lu im bi translated">如果您丢失了<code class="fe mu mv mw mx b">root</code>密码，并且无法访问特权用户，该怎么办？如果您仍然可以访问机器，那么有一种方法可以解决这种不方便的情况。</p><p id="4d64" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">首先，从重启机器开始。当机器启动时，按任意键进入启动菜单:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nd"><img src="../Images/3250c12d682fe45851c7e61da555727c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Ox6XVwo58JN6m4pFWoln3g.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">启动菜单截图</p></figure><p id="9592" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在启动菜单中，点击<code class="fe mu mv mw mx b">e</code>编辑启动选项。使用箭头，移动到以<code class="fe mu mv mw mx b">linux</code>开始并添加<code class="fe mu mv mw mx b">rd.break</code>的行。这<em class="ne">在早期中断了</em>引导过程。</p><p id="2365" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">可选地，您也可以添加<code class="fe mu mv mw mx b">enforcing=0</code>，暂停SELinux的执行。接下来，点击<code class="fe mu mv mw mx b">CTRL+X</code>让机器启动。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nf"><img src="../Images/e724ca5f43aa37de729124947b718f9c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*cUhptEHuERdvGJYpqD8E-A.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">已编辑的启动菜单截图</p></figure><p id="cc9c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">启动几秒钟后，您应该会得到外壳。此时，您可以以只读模式访问系统。</p><p id="4cac" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">因此，要改变系统中的任何东西——比如<code class="fe mu mv mw mx b">root</code>密码——我们需要使文件系统<em class="ne">读写</em>。我们可以通过运行<code class="fe mu mv mw mx b">mount -o remount,rw /sysroot</code>来实现。</p><p id="9e35" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们需要做的下一件事是使用<code class="fe mu mv mw mx b">chroot /sysroot</code>进入根监狱——这将文件系统的根改为<code class="fe mu mv mw mx b">/sysroot</code>,而不是<code class="fe mu mv mw mx b">/</code>。这是必需的，这样我们运行的任何进一步的命令都将与<code class="fe mu mv mw mx b">/sysroot</code>目录有关。现在我们可以使用<code class="fe mu mv mw mx b">passwd</code>更改<code class="fe mu mv mw mx b">root</code>密码。</p><p id="839e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果您在启动选项中添加了<code class="fe mu mv mw mx b">enforcing=0</code>，现在您可以点击<code class="fe mu mv mw mx b">CTRL+D</code>(或键入<code class="fe mu mv mw mx b">exit</code>)让系统完全启动。如果没有，运行<code class="fe mu mv mw mx b">touch /.autorelabel</code>来触发SELinux系统重新标记。</p><p id="823a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这是必要的，因为更改密码会导致<code class="fe mu mv mw mx b">/etc/password</code>具有不正确的SELinux安全上下文。因此，我们需要在下一次引导时重新标记整个文件系统(这可能需要一些时间，取决于文件系统的大小)。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nf"><img src="../Images/eedc5d9b126677d396e48aaea6e07fc7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*MRu3Iz3OgiLgxUPQZAST3Q.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">密码更改命令</p></figure><p id="258d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">作为替代方案，您也可以访问Linux的<code class="fe mu mv mw mx b">debug-shell</code>。这也可以通过在引导期间访问GRUB并附加<code class="fe mu mv mw mx b">systemd.debug-shell</code>而不是<code class="fe mu mv mw mx b">rd.break</code>来实现。</p><p id="2967" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">当您让系统用这个选项启动时，您将在一个正常的shell会话中结束，这不是很有帮助。但是，如果您尝试使用<code class="fe mu mv mw mx b">CTRL+ALT+F9</code>访问终端9，您将使用完全<code class="fe mu mv mw mx b">root</code>权限打开<code class="fe mu mv mw mx b">debug-shell</code>。</p><p id="b8e5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在这里，您可以正常更改密码。此时，您可以切换回正常的shell ( <code class="fe mu mv mw mx b">CTRL+ALT+F1</code>)并登录。</p><p id="a47f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">但是你不应该忘记停止<code class="fe mu mv mw mx b">debug-shell</code>，因为它是系统的一个巨大漏洞。你可以通过运行<code class="fe mu mv mw mx b">systemctl stop debug-shell.service</code>来做到这一点(你仍然可以切换回<code class="fe mu mv mw mx b">debug-shell</code>，但是它将没有响应；被杀死的)。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nd"><img src="../Images/2b8b78bd50dd548077f83cde201a4770.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*S569DsUv63DF9r_-uY4rmg.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">调试外壳</p></figure></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="94c1" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">修复不可挂载的文件系统</h1><p id="f1ef" class="pw-post-body-paragraph kz la it lb b lc my ju le lf mz jx lh li na lk ll lm nb lo lp lq nc ls lt lu im bi translated">创建新分区、创建文件系统、挂载文件系统等。是大多数系统管理员的常见任务。</p><p id="67c1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">但是，即使这些是基本任务，也很容易出错，导致系统无法启动。让我们看看如何解决与不可挂载的文件系统相关的问题。</p><p id="46fe" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">和以前的解决方案一样，我们从重启机器开始，访问启动菜单并编辑它，这次添加了<code class="fe mu mv mw mx b">systemd.unit=emergency.target</code>。这告诉您的系统启动到一个紧急目标，而不是默认目标(多用户或图形)。</p><p id="e213" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">当系统启动并获得shell时，我们以root用户身份登录，并再次使用<code class="fe mu mv mw mx b">mount -o remount,rw /</code>重新挂载文件系统。现在我们可以通过运行<code class="fe mu mv mw mx b">mount -a</code>来尝试挂载所有的文件系统。</p><p id="8d07" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果挂载特定的文件系统有问题，您可能会看到类似于<code class="fe mu mv mw mx b">mount: /wrong-mount: mount point does not exist.</code>或<code class="fe mu mv mw mx b">mount /wrong-mount: special device /dev/sdb1 does not exist.</code>的错误消息。这些问题需要在<code class="fe mu mv mw mx b">/etc/fstab</code>内部解决:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ng nh l"/></div></figure><p id="a62a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在<code class="fe mu mv mw mx b">/etc/fstab</code>中解决问题后，运行<code class="fe mu mv mw mx b">systemctl daemon-reload</code>，这样<code class="fe mu mv mw mx b">systemd</code>就会得到改变。现在，再次运行<code class="fe mu mv mw mx b">mount -a</code>。如果问题确实得到了解决，您应该看不到任何错误(没有消息，就是好消息)。您现在可以使用<code class="fe mu mv mw mx b">CTRL+D</code>退出，让系统正常启动。</p><p id="e58b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">除了键入错误的设备或装载点名称，您还可能遇到VDO(虚拟数据优化器)或Stratis的问题，这需要额外的装载参数。</p><p id="193d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">例如<code class="fe mu mv mw mx b">x-systemd.requires=vdo.service</code>或<code class="fe mu mv mw mx b">x-systemd.requires=stratisd.service</code>，否则系统无法正常启动。</p><p id="57a7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">另一个常见且容易修复的错误可能是在使用<code class="fe mu mv mw mx b">UUID="...</code>指定设备时缺少引号(使用<code class="fe mu mv mw mx b">/etc/fstab</code>语法突出显示，这可以为您省去许多问题)。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="668a" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">SELinux问题疑难解答</h1><p id="cfeb" class="pw-post-body-paragraph kz la it lb b lc my ju le lf mz jx lh li na lk ll lm nb lo lp lq nc ls lt lu im bi translated">这不是生死攸关的情况，但它会导致很多问题，所以当它发生时能够快速识别它是有益的。</p><p id="7648" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">重要的是要认识到，大多数时候，SELinux都在正确地完成它的工作。但是有可能你正在尝试实现SELinux没有预料到的事情。</p><p id="a70d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">您可能遇到的一些问题可能包括文件上下文不正确的问题，例如，将文件从一个位置移动到另一个位置后。有时，问题可能出在过于严格的策略(SELinux布尔值)或阻塞的服务端口上。</p><p id="e843" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">首先使用<code class="fe mu mv mw mx b">setenforce 0</code>暂时将SELinux更改为非强制模式，然后重试之前不起作用的操作，就可以解决所有这些问题。</p><p id="3ae1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果问题是通过将SELinux切换到非强制模式解决的，那么我们知道问题是由SELinux违规引起的。</p><p id="4416" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在，如果我们使用<code class="fe mu mv mw mx b">setenforce 1</code>重新打开SELinux，我们可以尝试分析并修复违规。</p><p id="7df1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">首先，使用<code class="fe mu mv mw mx b">yum -y install setroubleshoot-server</code>安装<code class="fe mu mv mw mx b">setroubleshoot-server</code>。该故障排除服务器将监听<code class="fe mu mv mw mx b">/var/log/audit/audit.log</code>并向<code class="fe mu mv mw mx b">/var/log/messages</code>发送总结消息。</p><p id="cf80" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">接下来，要分析这些消息，运行<code class="fe mu mv mw mx b">grep sealert /var/log/messages</code>应该会给出如下消息:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ng nh l"/></div></figure><p id="ff2e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">作为一个例子，我将<code class="fe mu mv mw mx b">httpd</code>配置为在端口<code class="fe mu mv mw mx b">8012</code>上运行，该端口由于SELinux服务允许的端口而被阻塞。如果我们没有意识到这一点，那么就很难找到这个问题的根源。</p><p id="c50c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">上面的输出有助于解决这个问题。我们可以看到对SELinux违规的描述，以及可以帮助我们进一步排除故障的命令，所以让我们试一试:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ng nh l"/></div></figure><p id="d272" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这将生成一份关于违规原因的完整报告。包括建议的(不一定是最合适的)修复。</p><p id="06ce" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果您对SELinux有一些经验，您可能会意识到解决这个问题的最合适的方法是向SELinux服务添加相关的端口(<code class="fe mu mv mw mx b">http_port_t</code>)。这可以通过运行<code class="fe mu mv mw mx b">semanage port -a -t http_port_t -p tcp 8012</code>来完成。</p><p id="4a13" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这种复制违规、在<code class="fe mu mv mw mx b">var/log/messages</code>中寻找<code class="fe mu mv mw mx b">sealert</code>消息、查看报告以及分析报告的模式可以应用于任何SELinux违规/问题，而不仅仅是上面的例子。</p><p id="ed86" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">或者，您也可以使用<code class="fe mu mv mw mx b">ausearch</code>直接在<code class="fe mu mv mw mx b">/var/log/audit/audit.log</code>中搜索。您想要运行的特定命令:<code class="fe mu mv mw mx b">ausearch -m AVC -ts recent</code>。这显示了所有最近的否认。</p><p id="11eb" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">输出应该是这样的(同样的信息，但是不太用户友好):</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ng nh l"/></div></figure></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="5f62" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">从崩溃的系统中获取日志</h1><p id="b5e0" class="pw-post-body-paragraph kz la it lb b lc my ju le lf mz jx lh li na lk ll lm nb lo lp lq nc ls lt lu im bi translated">默认情况下，存储在<code class="fe mu mv mw mx b">/run/log/journal</code>中的日志不会在系统重新启动后保存。如果您需要在崩溃的系统上调试日志，这可能会成为一个问题。</p><p id="9991" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">为了保存日志，我们需要修改<code class="fe mu mv mw mx b">/etc/systemd/journald.conf</code>。更具体地说，<code class="fe mu mv mw mx b">Storage</code>参数:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ng nh l"/></div></figure><p id="6523" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">通过取消注释并将<code class="fe mu mv mw mx b">Storage</code>改为<code class="fe mu mv mw mx b">persistent</code>，我们告诉<code class="fe mu mv mw mx b">systemd</code>将所有日志存储在<code class="fe mu mv mw mx b">var/log/journal</code>中。除了这个变更，我们还需要运行<code class="fe mu mv mw mx b">systemctl reload systemd-journald</code>来确保变更生效。</p><p id="ec12" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">尽管此更改会将日志保留在您的系统中，但它不会永远保留所有日志。默认情况下，<code class="fe mu mv mw mx b">journald</code>被配置为不超过文件系统的10%,或者给系统留下少于15%的可用空间。</p><p id="27e4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在，实际检查之前存储的日志。首先切换到<code class="fe mu mv mw mx b">root</code>用户。跑<code class="fe mu mv mw mx b">journalctl --list-boots</code>。这会给你一个类似这样的列表:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ng nh l"/></div></figure><p id="6439" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">根据日期和时间，选择要查看日志的引导。例如，要查看日志级别为<code class="fe mu mv mw mx b">err</code>或更高的id为<code class="fe mu mv mw mx b">-2</code>的引导的日志:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ng nh l"/></div></figure><p id="1ea5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果以上日志不足以解决您的问题，那么还有其他日志文件可供检查:</p><ul class=""><li id="8bd8" class="ni nj it lb b lc ld lf lg li nk lm nl lq nm lu nn no np nq bi translated"><code class="fe mu mv mw mx b">/var/log/messages</code> —大多数系统日志消息应该在这里。</li><li id="b096" class="ni nj it lb b lc nr lf ns li nt lm nu lq nv lu nn no np nq bi translated"><code class="fe mu mv mw mx b">/var/log/boot.log</code> —系统启动消息(与系统日志无关)。</li></ul><p id="5049" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">或者，如果您不能正常启动您的机器，那么您可以访问如上所示的<code class="fe mu mv mw mx b">emergency.target</code>，一个视图以同样的方式记录在那里。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="43b6" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">结论</h1><p id="6019" class="pw-post-body-paragraph kz la it lb b lc my ju le lf mz jx lh li na lk ll lm nb lo lp lq nc ls lt lu im bi translated">在Linux机器上，除了我在上面几节中展示的以外，还有很多地方可能出错。然而，这些示例/方法可以应用于您可能遇到的各种其他问题。</p><p id="f223" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">此外，并不是所有这些都是生死攸关的情况，但是能够快速解决它们总是更好的，特别是如果这个有问题的机器是一个生产系统。</p><p id="3fdf" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">大多数问题的解决取决于获得正确的信息并能够恢复以前的配置，因此，在修改日志之前，务必在系统上存储日志并备份关键文件</p><p id="5407" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><em class="ne">本文最初发布于</em><a class="ae ky" href="https://martinheinz.dev/blog/22" rel="noopener ugc nofollow" target="_blank"><em class="ne">martinheinz . dev</em></a></p></div></div>    
</body>
</html>