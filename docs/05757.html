<html>
<head>
<title>Passing Functions to React Components</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">将函数传递给反应组件</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/passing-functions-to-react-components-2a02d1b2b806?source=collection_archive---------3-----------------------#2020-08-04">https://betterprogramming.pub/passing-functions-to-react-components-2a02d1b2b806?source=collection_archive---------3-----------------------#2020-08-04</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="7e9d" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">如何将事件处理程序传递给组件？</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/0f5d314c5610c0efab2ff40af205bc5e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*ekrrgim45HMF2LBz"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">Simone Hutsch 在<a class="ae kv" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的照片。</p></figure><pre class="kg kh ki kj gt kw kx ky kz aw la bi"><span id="c06e" class="lb lc iq kx b gy ld le l lf lg">&lt;MyComponent onClick={this.handleClick}&gt;</span></pre><p id="14cd" class="pw-post-body-paragraph lh li iq lj b lk ll jr lm ln lo ju lp lq lr ls lt lu lv lw lx ly lz ma mb mc ij bi translated">在React中，有几种情况下，您可能希望将一个函数(如<code class="fe md me mf kx b">onClick</code>)作为道具从容器传递到子组件——通常是为了让子组件通知父组件一些事件。</p><p id="c4d5" class="pw-post-body-paragraph lh li iq lj b lk ll jr lm ln lo ju lp lq lr ls lt lu lv lw lx ly lz ma mb mc ij bi translated">例如:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mg mh l"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">一个场景，其中有一个CustomButton组件需要更改其父容器组件的计数器状态。</p></figure><p id="947e" class="pw-post-body-paragraph lh li iq lj b lk ll jr lm ln lo ju lp lq lr ls lt lu lv lw lx ly lz ma mb mc ij bi translated">假设您可能需要从子组件访问父组件的<code class="fe md me mf kx b">state</code>或<code class="fe md me mf kx b">props</code>，您将需要以某种方式将函数绑定到父组件实例。</p><p id="6d18" class="pw-post-body-paragraph lh li iq lj b lk ll jr lm ln lo ju lp lq lr ls lt lu lv lw lx ly lz ma mb mc ij bi translated">虽然有几种方法可以做到这一点，但有些是更好的解决方案。</p></div><div class="ab cl mi mj hu mk" role="separator"><span class="ml bw bk mm mn mo"/><span class="ml bw bk mm mn mo"/><span class="ml bw bk mm mn"/></div><div class="ij ik il im in"><h1 id="8f8f" class="mp lc iq bd mq mr ms mt mu mv mw mx my jw mz jx na jz nb ka nc kc nd kd ne nf bi translated">如何将一个函数绑定到一个组件实例？</h1><p id="2f1e" class="pw-post-body-paragraph lh li iq lj b lk ng jr lm ln nh ju lp lq ni ls lt lu nj lw lx ly nk ma mb mc ij bi translated">根据所涉及的语法和构建步骤，有许多方法可以确保函数能够访问组件属性，比如<code class="fe md me mf kx b">props</code>和<code class="fe md me mf kx b">state</code>。</p><h2 id="13c6" class="lb lc iq bd mq nl nm dn mu nn no dp my lq np nq na lu nr ns nc ly nt nu ne nv bi translated">1.在构造函数中绑定</h2><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nw mh l"/></div></figure><p id="19a4" class="pw-post-body-paragraph lh li iq lj b lk ll jr lm ln lo ju lp lq lr ls lt lu lv lw lx ly lz ma mb mc ij bi translated">虽然这是一种广泛使用的方法，但有点奇怪，因为它使用了晦涩的单词<code class="fe md me mf kx b">bind</code>，并且需要一行不必要的代码(我们将在后面讨论)。</p><p id="4fd0" class="pw-post-body-paragraph lh li iq lj b lk ll jr lm ln lo ju lp lq lr ls lt lu lv lw lx ly lz ma mb mc ij bi translated">在我看来，这不是最好的方法。</p><h2 id="74a5" class="lb lc iq bd mq nl nm dn mu nn no dp my lq np nq na lu nr ns nc ly nt nu ne nv bi translated">2.渲染时绑定</h2><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nw mh l"/></div></figure><p id="33d8" class="pw-post-body-paragraph lh li iq lj b lk ll jr lm ln lo ju lp lq lr ls lt lu lv lw lx ly lz ma mb mc ij bi translated">虽然与之前的方法<strong class="lj ir">，</strong>相比，我们用这种方法节省了一行代码，但是这种方法仍然有些不清楚，我不推荐使用它。</p><p id="71a9" class="pw-post-body-paragraph lh li iq lj b lk ll jr lm ln lo ju lp lq lr ls lt lu lv lw lx ly lz ma mb mc ij bi translated">此外，也许更重要的是:</p><blockquote class="nx"><p id="d3d7" class="ny nz iq bd oa ob oc od oe of og mc dk translated"><em class="oh">"在渲染中使用</em> <code class="fe md me mf kx b"><em class="oh">.bind(this)</em></code> <em class="oh">，每次组件渲染时创建一个新函数，这可能会影响性能。"— </em> <a class="ae kv" href="https://reactjs.org/docs/faq-functions.html" rel="noopener ugc nofollow" target="_blank"> React的文档</a></p></blockquote><h2 id="6412" class="lb lc iq bd mq nl oi dn mu nn oj dp my lq ok nq na lu ol ns nc ly om nu ne nv bi translated">3.箭头功能</h2><p id="837a" class="pw-post-body-paragraph lh li iq lj b lk ng jr lm ln nh ju lp lq ni ls lt lu nj lw lx ly nk ma mb mc ij bi translated">箭头函数表达式的语法比函数表达式短，并且没有自己的<code class="fe md me mf kx b">this</code>。出于这个原因，您可以将它传递给子组件，并且仍然可以访问父组件的<code class="fe md me mf kx b">props</code>和<code class="fe md me mf kx b">state</code>。</p><p id="6295" class="pw-post-body-paragraph lh li iq lj b lk ll jr lm ln lo ju lp lq lr ls lt lu lv lw lx ly lz ma mb mc ij bi translated">在我看来，这是最好的办法:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nw mh l"/></div></figure><p id="5756" class="pw-post-body-paragraph lh li iq lj b lk ll jr lm ln lo ju lp lq lr ls lt lu lv lw lx ly lz ma mb mc ij bi translated"><em class="on">注:根据</em> <a class="ae kv" href="https://reactjs.org/docs/faq-functions.html" rel="noopener ugc nofollow" target="_blank"> <em class="on"> React的文档</em> </a> <em class="on">，“这个语法是实验性的，还没有标准化。”</em></p></div><div class="ab cl mi mj hu mk" role="separator"><span class="ml bw bk mm mn mo"/><span class="ml bw bk mm mn mo"/><span class="ml bw bk mm mn"/></div><div class="ij ik il im in"><h1 id="3776" class="mp lc iq bd mq mr ms mt mu mv mw mx my jw mz jx na jz nb ka nc kc nd kd ne nf bi translated">将参数传递给事件处理程序</h1><p id="041b" class="pw-post-body-paragraph lh li iq lj b lk ng jr lm ln nh ju lp lq ni ls lt lu nj lw lx ly nk ma mb mc ij bi translated">如果您真的需要通过函数prop将参数传递给子对象，请仔细检查。</p><p id="58dd" class="pw-post-body-paragraph lh li iq lj b lk ll jr lm ln lo ju lp lq lr ls lt lu lv lw lx ly lz ma mb mc ij bi translated">检查您是否有其他选择，比如将参数作为一个属性传递，或者发现您在子组件中并不真正需要该参数。</p><h2 id="5851" class="lb lc iq bd mq nl nm dn mu nn no dp my lq np nq na lu nr ns nc ly nt nu ne nv bi translated">我为什么要说这个？</h2><p id="3405" class="pw-post-body-paragraph lh li iq lj b lk ng jr lm ln nh ju lp lq ni ls lt lu nj lw lx ly nk ma mb mc ij bi translated">如前所述，在render中使用bind之类的语法或匿名函数(如下例所示)将导致子组件在父组件的每次呈现后重新呈现，而不管是否与其子组件相关。这意味着表现不佳。</p><p id="be6a" class="pw-post-body-paragraph lh li iq lj b lk ll jr lm ln lo ju lp lq lr ls lt lu lv lw lx ly lz ma mb mc ij bi translated">由于子组件接收一个匿名函数作为道具，所以它不能与前面的匿名函数进行比较(因为两者都是匿名的)。然而，传递对类似于<br/> <code class="fe md me mf kx b">onClick={this.handleClick}</code>的方法的引用让React知道什么都没有改变，所以它不会不必要地重新呈现。</p><p id="fbd2" class="pw-post-body-paragraph lh li iq lj b lk ll jr lm ln lo ju lp lq lr ls lt lu lv lw lx ly lz ma mb mc ij bi translated">如果没有必要，你不应该做什么的例子:</p><pre class="kg kh ki kj gt kw kx ky kz aw la bi"><span id="7e7b" class="lb lc iq kx b gy ld le l lf lg">&lt;button onClick={() =&gt; this.handleClick(id)} /&gt;</span></pre><p id="8f1d" class="pw-post-body-paragraph lh li iq lj b lk ll jr lm ln lo ju lp lq lr ls lt lu lv lw lx ly lz ma mb mc ij bi translated">但是，请注意，匿名函数有时是不可避免的(例如，当我们只需要在上下文中传递一个参数时)。</p><h2 id="fbef" class="lb lc iq bd mq nl nm dn mu nn no dp my lq np nq na lu nr ns nc ly nt nu ne nv bi translated">活生生的证据</h2><p id="a440" class="pw-post-body-paragraph lh li iq lj b lk ng jr lm ln nh ju lp lq ni ls lt lu nj lw lx ly nk ma mb mc ij bi translated">查看下一个CodeSandbox示例。它演示了将函数作为道具传递给组件的两种方式。第一个通过引用传递函数，第二个传递匿名函数。</p><p id="9273" class="pw-post-body-paragraph lh li iq lj b lk ll jr lm ln lo ju lp lq lr ls lt lu lv lw lx ly lz ma mb mc ij bi translated">单击该按钮时，每个组件旁边的数字表示该组件被渲染的次数。</p><p id="3433" class="pw-post-body-paragraph lh li iq lj b lk ll jr lm ln lo ju lp lq lr ls lt lu lv lw lx ly lz ma mb mc ij bi translated">你能猜出哪一个会不必要地渲染更多次吗？</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mg mh l"/></div></figure></div><div class="ab cl mi mj hu mk" role="separator"><span class="ml bw bk mm mn mo"/><span class="ml bw bk mm mn mo"/><span class="ml bw bk mm mn"/></div><div class="ij ik il im in"><h1 id="7611" class="mp lc iq bd mq mr ms mt mu mv mw mx my jw mz jx na jz nb ka nc kc nd kd ne nf bi translated">最后，确保在将函数传递给组件时没有调用它</h1><p id="1c33" class="pw-post-body-paragraph lh li iq lj b lk ng jr lm ln nh ju lp lq ni ls lt lu nj lw lx ly nk ma mb mc ij bi translated">不要这样做:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nw mh l"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">代码片段由<a class="ae kv" href="https://reactjs.org/docs/faq-functions.html" rel="noopener ugc nofollow" target="_blank">反应</a>。</p></figure><p id="7cc6" class="pw-post-body-paragraph lh li iq lj b lk ll jr lm ln lo ju lp lq lr ls lt lu lv lw lx ly lz ma mb mc ij bi translated">相反，传递函数本身(不带括号):</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nw mh l"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated"><a class="ae kv" href="https://reactjs.org/docs/faq-functions.html" rel="noopener ugc nofollow" target="_blank"> React </a>的代码片段。</p></figure></div><div class="ab cl mi mj hu mk" role="separator"><span class="ml bw bk mm mn mo"/><span class="ml bw bk mm mn mo"/><span class="ml bw bk mm mn"/></div><div class="ij ik il im in"><h1 id="a3e0" class="mp lc iq bd mq mr ms mt mu mv mw mx my jw mz jx na jz nb ka nc kc nd kd ne nf bi translated">结论</h1><p id="ecde" class="pw-post-body-paragraph lh li iq lj b lk ng jr lm ln nh ju lp lq ni ls lt lu nj lw lx ly nk ma mb mc ij bi translated">我希望这篇文章能够帮助您理解如何能够——并且应该——以简单有效的方式在组件之间传递函数。</p><p id="61a1" class="pw-post-body-paragraph lh li iq lj b lk ll jr lm ln lo ju lp lq lr ls lt lu lv lw lx ly lz ma mb mc ij bi translated">祝您愉快！感谢阅读！</p></div></div>    
</body>
</html>