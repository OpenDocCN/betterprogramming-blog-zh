<html>
<head>
<title>Futures: Promises in Dart</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">期货:镖中的承诺</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/futures-in-dart-582186ee75da?source=collection_archive---------5-----------------------#2019-10-24">https://betterprogramming.pub/futures-in-dart-582186ee75da?source=collection_archive---------5-----------------------#2019-10-24</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="87b8" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">Dart中使用期货的异步编程</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/2f7eb205f5ff639050051f5e53061210.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*A2jdz-vV_feJbbmev56ktA.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">背景图像—无飞溅</p></figure><p id="e789" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">Dart是一种语言，当Google决定把它扔给Flutter时，它被赋予了生命。</p><p id="bd96" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">Dart <strong class="la iu"> </strong>是<strong class="la iu"> </strong>很快<strong class="la iu"> </strong>成为<strong class="la iu"> </strong>初学者更喜欢学习的<strong class="la iu"> </strong>语言之一，因为它支持三大平台的开发:iOS、Android和Web。JavaScript还有很多工作要做，但common JS已经存在了二十多年——将它与一种仍在成熟的语言相比较是不公平的。</p><p id="c446" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">也就是说，它已经拥有了现代语言几乎所有的基本特性，在本文中，我们将讨论一种非常基本的编程模式。<em class="lu">异步编程</em> <strong class="la iu"> </strong>(或<em class="lu">并行编程</em>)是一种不能立即执行的特定任务在后台继续执行而不阻塞整个程序的编程技术。一个典型的日常例子是HTTP API调用。</p><p id="e731" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">现在，如果您来自JS背景，您将熟悉async-await、promises甚至订阅。在本文中，我们将讨论Dart中的异步编程。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="c653" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">达特的未来</h1><p id="1877" class="pw-post-body-paragraph ky kz it la b lb mu ju ld le mv jx lg lh mw lj lk ll mx ln lo lp my lr ls lt im bi translated">Futures是Dart为异步提供的最简单和最基本的API之一。</p><p id="60c2" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">未来就像承诺一样，只是在飞镖里。就像任何基本承诺一样，它有三种状态:执行状态(完成状态，可以分为“成功完成”和“有错完成”<em class="lu"> ) </em>。</p><p id="b191" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">Dart futures还在管理事件队列的<em class="lu">事件循环</em>上运行。由于Dart和JS一样是单线程程序，所以您编写的所有任务都在事件循环中结束执行。</p><p id="f552" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">把事件循环想象成一个摆渡轮——但是任务是人。</p><p id="e041" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">当新来的人乘坐时，他们被加到一个船舱里，他们呆在轮子里直到他们的时间结束。类似地，任务进入并停留在事件循环中，直到其执行完成。但是就像轮子不会停下来等待一个用户完成骑行一样，事件循环不会停止某个特定任务的执行——即使每个任务可能需要不同的时间来完成执行。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mz na l"/></div></figure><p id="abc0" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">让我们考虑一个例子来说明问题。下面的代码演示了一个非常简单的场景，其中有一个下载按钮。点击它将导致一个图像被下载并显示在应用程序中。我们来分解一下。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nb na l"/></div></figure><p id="88a6" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">第1–2行:当用户点击<code class="fe nc nd ne nf b">RaisedButton</code>时，一个点击事件被注册到调用点击处理程序的事件循环中。现在执行状态已经开始，这将是未完成的。</p><p id="6ae0" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">第3行:tap处理程序使用HTTP库从URL发出对图像的<code class="fe nc nd ne nf b">get</code>请求。这返回一个未来成<code class="fe nc nd ne nf b">myFuture</code> <strong class="la iu"> <em class="lu">。</em> </strong></p><p id="560c" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">第4行:当请求完成时，我们使用<code class="fe nc nd ne nf b">then</code> <strong class="la iu"> <em class="lu"> </em> </strong>注册一个回调。</p><p id="c5c3" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">现在，事件循环不会等到请求完成，但在此期间，它会继续执行事件队列中的其他任务，而不会等待HTTP请求的执行完成。</p><p id="e66e" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">第5行:最终，一旦HTTP请求成功地将数据返回给未来，该数据将被传递给<code class="fe nc nd ne nf b">response</code>对象中的回调，回调将被触发以在应用程序中显示图像。</p><p id="66d5" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">如果你是这个承诺的新手，你可能没有注意到的一件事是，我们从来没有直接管理事件循环，如果没有未来的<strong class="la iu"> <em class="lu"> </em> </strong> API，就不会出现这种情况。</p><p id="e28f" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">Future负责事件循环中的所有处理，我们所要做的就是从HTTP请求中创建一个future对象，并告诉它future完成后需要做什么。</p><p id="92dd" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">但是就像我上面提到的，未来也可以有第三种状态，没有错误地完成，在编写有效的代码时，你必须覆盖错误，以确保你的程序不会崩溃。</p><p id="9026" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">第6行:如果future完成时出现错误，执行将转到这一行，在这一行，我们已经使用<code class="fe nc nd ne nf b">catchError() </code>方法<strong class="la iu"> <em class="lu">为错误定义了回调。</em> </strong>这个方法将接受一个错误对象而不是一个值，并在未来完成时执行里面的语句。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="1741" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">创建未来的实例</h1><p id="f9aa" class="pw-post-body-paragraph ky kz it la b lb mu ju ld le mv jx lg lh mw lj lk ll mx ln lo lp my lr ls lt im bi translated">在上面的例子中，我们并没有完全靠自己创造未来。如果您已经注意到了，HTTP库为我们做了这项工作——我们所要做的就是调用HTTP <code class="fe nc nd ne nf b">get</code>方法，并将其分配给创建的未来对象<code class="fe nc nd ne nf b">myFuture</code> <strong class="la iu"> <em class="lu">。</em> </strong></p><pre class="kj kk kl km gt ng nf nh ni aw nj bi"><span id="595d" class="nk md it nf b gy nl nm l nn no">final myFuture = http.get(‘http://example.com');</span></pre><p id="0b1e" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">同样，还有许多其他的图书馆为你创造未来。假设你正在将一些数据存储到应用程序的共享偏好设置中。获取共享首选项的实例也将返回一个future。</p><pre class="kj kk kl km gt ng nf nh ni aw nj bi"><span id="087c" class="nk md it nf b gy nl nm l nn no">final myFuture = SharedPreferences.getInstance();</span></pre><p id="d9d8" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">所有这些都很好，但是没有图书馆，我们如何创造未来？这就是未来构造函数的用途。</p><p id="8b9e" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated"><em class="lu">未来构造函数</em>是接受一个函数并返回与该函数的返回类型相匹配的未来值的构造函数。该函数异步运行，一旦函数返回值，未来就用该值来完成。让我们考虑一个例子:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nb na l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">使用构造函数创造未来</p></figure><p id="9c05" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">就像我们上一个例子一样，我们正在创建一个未来，但是这次使用了Future() <strong class="la iu"> <em class="lu"> </em> </strong>构造函数。未来构造函数将在第一次执行时返回一个未完成的未来。但是事件循环不会等到未来完成，它会立即在<code class="fe nc nd ne nf b">line 6</code>上执行print语句。因此，上述代码的输出将是:</p><pre class="kj kk kl km gt ng nf nh ni aw nj bi"><span id="4003" class="nk md it nf b gy nl nm l nn no">Printing....<br/>Future Complete</span></pre><p id="9553" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">Future.value() <strong class="la iu">这在已经获得所需值的情况下非常有用，比如构建使用缓存的服务。但是这里要记住的一点是，未来仍然是异步完成的。这是你如何分配它:</strong></p><pre class="kj kk kl km gt ng nf nh ni aw nj bi"><span id="1e5a" class="nk md it nf b gy nl nm l nn no">final myFuture = Future.value(10);</span></pre><p id="ac8e" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">还有另一个构造函数，它执行与<code class="fe nc nd ne nf b">Future.value()</code>完全相反的操作，并以一个错误完成。<code class="fe nc nd ne nf b"><a class="ae np" href="https://api.dartlang.org/stable/dart-async/Future/Future.error.html" rel="noopener ugc nofollow" target="_blank">Future.error()</a> </code>构造函数接受一个错误对象和一个可选的堆栈跟踪。示例:</p><pre class="kj kk kl km gt ng nf nh ni aw nj bi"><span id="4d92" class="nk md it nf b gy nl nm l nn no">final myFuture = Future.error(Exception());</span></pre><p id="dd14" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">最后我们有<code class="fe nc nd ne nf b">Future.delayed()</code>，它的工作方式与future非常相似，但是顾名思义，它在执行函数和完成Future之前会等待一段特定的时间。</p><p id="3f6f" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">当您需要模拟一些异步的东西，而您还没有完成代码的编写时，这可以派上用场。</p><p id="13be" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">典型的用例是，当你试图模拟一个可能需要几秒钟才能完成的API调用时，你已经编写了一些代码，让用户知道后台正在发生一些事情，比如加载器动画。创建一个最简单的方法是:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nb na l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">Future.delayed()示例。</p></figure></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="e2fe" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">结论</h1><p id="27dc" class="pw-post-body-paragraph ky kz it la b lb mu ju ld le mv jx lg lh mw lj lk ll mx ln lo lp my lr ls lt im bi translated">就这样，我们已经在Dart中介绍了期货的基础知识。</p><p id="8c55" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">现在，我们需要更深入地研究它在实时应用程序(如Flutter应用程序)中的使用和实现，但我们将在另一篇文章中讨论，因为这应该是一个开始。</p></div></div>    
</body>
</html>