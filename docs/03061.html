<html>
<head>
<title>Introduction to TypeScript Generics</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">类型脚本泛型介绍</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/introduction-to-typescript-generics-functions-8ebfe688fd61?source=collection_archive---------10-----------------------#2020-01-17">https://betterprogramming.pub/introduction-to-typescript-generics-functions-8ebfe688fd61?source=collection_archive---------10-----------------------#2020-01-17</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="edb3" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">创建可以跨类型使用的泛型函数</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/a7afdeb8621dbad24f12f060a9410bf4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*HNaGdjAf1R-7LgW9"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">由<a class="ae ky" href="https://unsplash.com/@kellysikkema?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Kelly Sikkema </a>在<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</p></figure><p id="4f75" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">创建可重用代码的一种方法是创建这样的代码，它允许我们根据自己的需要使用不同的数据类型。<a class="ae ky" href="https://www.typescriptlang.org/" rel="noopener ugc nofollow" target="_blank"> TypeScript </a>提供了创建可重用组件的泛型结构，我们可以在一段代码中处理各种类型。这允许用户通过放入他们自己的类型来使用这些组件。</p><p id="8657" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在本文中，我们将研究定义泛型函数的许多方法，在这些方法中，我们可以设置参数类型和返回值，以避免重新定义具有相同逻辑但不同参数和返回值类型的函数。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="6f18" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">定义通用函数</h1><p id="8ca4" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">泛型的一个基本用途是创建逻辑相同但参数类型和返回类型不同的函数。例如，如果我们想创建一个identity函数，只返回传入的相同内容，我们可以编写如下代码:</p><pre class="kj kk kl km gt mz na nb nc aw nd bi"><span id="20a2" class="ne md it na b gy nf ng l nh ni">function echo(arg: number): number {<br/>  return arg;<br/>}</span></pre><p id="d85c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果我们希望这个函数接受多个类型作为参数，并返回传入的相同类型，那么我们可以通过放入一个泛型类型标记，而不是放入用于<code class="fe nj nk nl na b">arg</code>参数和返回类型的<code class="fe nj nk nl na b">number</code>类型，将它变成一个泛型函数。我们用<code class="fe nj nk nl na b">T</code>关键字来表示一个类型变量。<code class="fe nj nk nl na b">T</code>关键字允许我们稍后为通用函数捕获组。我们可以为<code class="fe nj nk nl na b">T</code>切换出<code class="fe nj nk nl na b">number</code>，如下面的代码所示:</p><pre class="kj kk kl km gt mz na nb nc aw nd bi"><span id="60f6" class="ne md it na b gy nf ng l nh ni">function echo&lt;T&gt;(arg: T): T {<br/>  return arg;<br/>}</span></pre><p id="b66b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">当我们调用该函数时，我们可以编写如下代码:</p><pre class="kj kk kl km gt mz na nb nc aw nd bi"><span id="e8c7" class="ne md it na b gy nf ng l nh ni">console.log(echo&lt;number&gt;(1));<br/>console.log(echo&lt;string&gt;('string'));<br/>console.log(echo&lt;boolean&gt;(true));</span></pre><p id="c753" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们得出以下结论:</p><pre class="kj kk kl km gt mz na nb nc aw nd bi"><span id="547a" class="ne md it na b gy nf ng l nh ni">1<br/>string<br/>true</span></pre><p id="a2a7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">使用上面的代码，我们可以在每个函数调用中对传入的参数和返回类型进行类型检查。<code class="fe nj nk nl na b">&lt;&gt;</code>中的代码表示我们希望参数成为的类型，以及函数将接受的参数和返回类型的返回类型。我们不必像上面那样显式地输入类型。只要我们定义了泛型函数，TypeScript就足够智能来识别类型。例如，假设我们编写以下代码来调用<code class="fe nj nk nl na b">echo</code>函数:</p><pre class="kj kk kl km gt mz na nb nc aw nd bi"><span id="382a" class="ne md it na b gy nf ng l nh ni">console.log(echo(1));<br/>console.log(echo('string'));<br/>console.log(echo(true));</span></pre><p id="ef0e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">代码仍将编译、运行和输出与上面相同的内容。这使代码更短，但显式设置类型对开发人员来说更清晰。此外，编译器有时可能无法识别类型，尤其是当代码更复杂时。在这种情况下，必须提供类型。</p><p id="9ddf" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果我们想要访问对象的特定属性，那么我们必须更加具体地使用泛型类型。例如，如果我们假设参数的类型和返回类型总是某种数组，那么我们可以用下面的代码来指定:</p><pre class="kj kk kl km gt mz na nb nc aw nd bi"><span id="8734" class="ne md it na b gy nf ng l nh ni">function echo&lt;T&gt;(arg: T[]): T[] {<br/>  console.log(arg.length);<br/>  return arg;<br/>}</span></pre><p id="f47c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">同样，我们可以用<code class="fe nj nk nl na b">Array&lt;T&gt;</code>泛型类型来代替，如下面的代码所示:</p><pre class="kj kk kl km gt mz na nb nc aw nd bi"><span id="07b4" class="ne md it na b gy nf ng l nh ni">function echo&lt;T&gt;(arg: Array&lt;T&gt;): Array&lt;T&gt; {<br/>  console.log(arg.length);<br/>  return arg;<br/>}</span></pre><p id="45af" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在这两段代码中，我们可以记录作为参数传递给函数的数组的<code class="fe nj nk nl na b">length</code>属性，因为它保证了我们传递和返回的总是数组。例如，我们可以在下面的代码中调用新的<code class="fe nj nk nl na b">echo</code>函数:</p><pre class="kj kk kl km gt mz na nb nc aw nd bi"><span id="f0c8" class="ne md it na b gy nf ng l nh ni">echo([1, 2, 3]);<br/>echo(['a', 'b', 'c']);</span></pre><p id="23c2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在上述情况下，类型推断仍然有效。</p><p id="71c7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在上面的例子中，我们有一个参数和一个返回值。但是如果我们想传入多个不同类型的参数并返回其中的一个或多个呢？我们可以这样写:</p><pre class="kj kk kl km gt mz na nb nc aw nd bi"><span id="4463" class="ne md it na b gy nf ng l nh ni">function echo&lt;T, U&gt;(arg: T, arg2: U): [T, U] {  <br/>  return [arg, arg2];<br/>}</span></pre><p id="517b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在上面的代码中，我们有两个泛型类型，<code class="fe nj nk nl na b">T</code>和<code class="fe nj nk nl na b">U</code>，它们代表相同或不同的类型。例如，我们可以在下面的代码中使用它们:</p><pre class="kj kk kl km gt mz na nb nc aw nd bi"><span id="022e" class="ne md it na b gy nf ng l nh ni">console.log(echo(1, 'a'));</span></pre><p id="105b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在上面的代码中，第一个参数是一个数字，第二个是一个字符串。我们也可以将两者设为相同的类型，如下面的代码所示:</p><pre class="kj kk kl km gt mz na nb nc aw nd bi"><span id="335d" class="ne md it na b gy nf ng l nh ni">console.log(echo(1, 2));</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nm"><img src="../Images/c8fdd7f340f62936d70de73991b73c22.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*WhHUuWTGPuLK7CDY"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">由<a class="ae ky" href="https://unsplash.com/@kellysikkema?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">凯利·西克玛</a>在<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</p></figure></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="9858" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">类型标记的变化</h1><p id="4385" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">我们最终会遇到的另一个问题是，我们希望参数的数据类型不同于返回类型。解决这个问题的一种方法是将泛型类型和常规类型与接口混合，就像我们在下面的代码中所做的那样:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nn no l"/></div></figure><p id="416c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们从<code class="fe nj nk nl na b">console.log</code>中得到以下内容:</p><pre class="kj kk kl km gt mz na nb nc aw nd bi"><span id="dc38" class="ne md it na b gy nf ng l nh ni">{a: 1, b: "a", c: false, d: {}}</span></pre><p id="b6e1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们也可以省略返回类型，就像我们在下面的代码中所做的那样:</p><pre class="kj kk kl km gt mz na nb nc aw nd bi"><span id="7137" class="ne md it na b gy nf ng l nh ni">function echo&lt;T, U, V, W, X&gt;(a: T, b: U, c: V, d: W) {  <br/>  return { a, b, c, d };  <br/>}</span><span id="2148" class="ne md it na b gy np ng l nh ni">console.log(echo(1, 'a', false, {}));</span></pre><p id="f60b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们得到与上面相同的输出。注意，在上面的两个例子中，我们可以指定任意多的字母作为泛型类型标记。泛型类型标记不一定是一个字母。它只是一个单个字母的惯例。我们可以这样写:</p><pre class="kj kk kl km gt mz na nb nc aw nd bi"><span id="9243" class="ne md it na b gy nf ng l nh ni">function echo&lt;T, U, V, W, AA&gt;(a: T, b: U, c: V, d: AA) {  <br/>  return { a, b, c, d };  <br/>}</span></pre><p id="091e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">定义泛型函数的另一种方法是将签名和泛型类型标记一起放在接口中。当我们通过将函数赋给变量来声明函数时，我们可以用接口设置变量的类型，然后将泛型函数赋给变量，并在函数中添加通常的泛型类型标记。例如，我们可以编写类似下面的代码:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nn no l"/></div></figure><p id="e470" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们也可以将<code class="fe nj nk nl na b">&lt;&gt;</code>中的泛型类型标记添加到<code class="fe nj nk nl na b">interface</code>声明中，如下所示:</p><pre class="kj kk kl km gt mz na nb nc aw nd bi"><span id="3415" class="ne md it na b gy nf ng l nh ni">interface EchoFn&lt;T&gt; {<br/>  &lt;T&gt;(a: T): T;<br/>};</span></pre><p id="d486" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">然后，当我们声明将函数赋给的变量时，我们必须显式指定接口的类型，如下所示:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nn no l"/></div></figure><p id="8505" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在上面的代码中，我们必须在最后一行显式添加<code class="fe nj nk nl na b">number</code>类型声明，而不是让TypeScript自动推断。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="e850" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">摘要</h1><p id="3d31" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">为了避免重新定义具有相同逻辑但不同参数类型和返回类型的函数，我们可以定义泛型函数。为了做到这一点，我们在函数和用于对函数进行类型化的接口中添加了泛型类型标记。</p><p id="c570" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们通过在函数名后面的<code class="fe nj nk nl na b">&lt;&gt;</code>中插入通用类型标记来定义函数，每个标记用逗号分隔。我们还将它们添加到参数中的冒号之后、冒号之后和左花括号之前。</p><p id="3634" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">返回类型的泛型类型标记是可选的。如果我们想返回一个和我们传递给参数的类型不同的东西，我们可以忽略它。同样，在接口中，我们将函数的签名放在接口中，也可以放在接口定义中，以便在我们定义的函数中强制使用泛型类型标记。</p></div></div>    
</body>
</html>