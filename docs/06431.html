<html>
<head>
<title>Private Serverless REST APIs With AWS Lambda Using SAM</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用SAM的AWS Lambda私有无服务器REST APIs</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/private-serverless-rest-api-with-lambda-using-sam-2eb31864b243?source=collection_archive---------4-----------------------#2020-10-01">https://betterprogramming.pub/private-serverless-rest-api-with-lambda-using-sam-2eb31864b243?source=collection_archive---------4-----------------------#2020-10-01</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="dfb2" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">使用Lambdas快速创建无服务器微服务</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/7ef8063308dc3775816e5de19d6a2e8e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*EiNWRHB1mxbhN205"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">菲利普·莱曼在<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</p></figure><p id="756b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">通过使用<a class="ae ky" href="https://aws.amazon.com/api-gateway/" rel="noopener ugc nofollow" target="_blank"> Amazon API Gateway，</a>有可能快速创建由<a class="ae ky" href="https://aws.amazon.com/lambda/" rel="noopener ugc nofollow" target="_blank"> Lambda </a>支持的无服务器微服务。我们将回顾一个这样的部署，并使用AWS无服务器应用程序模型(SAM)来部署它。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="cf49" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">介绍</h1><p id="6b38" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">随着云系统的不断增长，许多公司已经选择从单片系统转移到由微服务组成的分布式架构。AWS允许开发这样的服务，而不需要管理底层的服务器基础设施。</p><p id="fcdc" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们将讨论使用SAM部署一个这样的服务的基础设施即代码(IaC)方法。部署将假设<a class="ae ky" href="https://aws.amazon.com/vpc/" rel="noopener ugc nofollow" target="_blank">虚拟专用集群(VPC) </a>已经就绪，并且只有集群内特定子网上的虚拟机能够访问专用服务。我们还假设开发者已经在本地安装了必要的<a class="ae ky" href="https://docs.aws.amazon.com/serverless-application-model/latest/developerguide/serverless-sam-cli-install.html" rel="noopener ugc nofollow" target="_blank"> AWS SAM工具</a>。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="3bb6" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">1.文件和文件夹</h1><pre class="kj kk kl km gt mz na nb nc aw nd bi"><span id="8d27" class="ne md it na b gy nf ng l nh ni">my-microservice/<br/>├── cmd/<br/>│   ├── debug.sh<br/>│   └── deploy.sh<br/>├── src/<br/>│   ├── index.js<br/>│   └── package.js<br/>├── .gitignore <br/>├── test-event.json<br/>└── template.yaml</span></pre><p id="891c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe nj nk nl na b">cmd</code>文件夹将包含我们的助手脚本，用于部署和本地调试我们的函数，如下所示:</p><p id="2761" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe nj nk nl na b">debug.sh</code>:使用<code class="fe nj nk nl na b">test-event.json</code>作为输入，在本地计算机上运行该功能。</p><pre class="kj kk kl km gt mz na nb nc aw nd bi"><span id="8121" class="ne md it na b gy nf ng l nh ni">#!/bin/bash</span><span id="a056" class="ne md it na b gy nm ng l nh ni">script_path=$(cd "$(dirname "${BASH_SOURCE[0]}")" ; pwd -P)</span><span id="1689" class="ne md it na b gy nm ng l nh ni">sam local invoke \  <br/>  --event ${script_path}/../test-event.json \  <br/>  --template-file ${script_path}/../template.yaml</span></pre><p id="396b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe nj nk nl na b">deploy.sh</code>:将服务部署到AWS。</p><pre class="kj kk kl km gt mz na nb nc aw nd bi"><span id="0dad" class="ne md it na b gy nf ng l nh ni">#!/bin/bash</span><span id="1ac7" class="ne md it na b gy nm ng l nh ni"># exit when any command fails<br/>set -e</span><span id="ed4e" class="ne md it na b gy nm ng l nh ni">script_path=$(cd "$(dirname "${BASH_SOURCE[0]}")" ; pwd -P)</span><span id="068a" class="ne md it na b gy nm ng l nh ni">sam deploy \  <br/>  --template-file ${script_path}/../template.yaml \  <br/>  --stack-name my-microservice \  <br/>  --capabilities CAPABILITY_IAM \  <br/>  --guided</span></pre><p id="251b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe nj nk nl na b">src</code>文件夹将包含Lambda的源代码。在这种情况下，它由节点<code class="fe nj nk nl na b">index.js</code>和<code class="fe nj nk nl na b">package.json</code>文件组成。然而，这里将要展示的技术同样适用于任何其他受支持的Lambda语言。</p><h2 id="b91b" class="ne md it bd me nn no dn mi np nq dp mm li nr ns mo lm nt nu mq lq nv nw ms nx bi translated"><em class="ny"> package.json </em></h2><pre class="kj kk kl km gt mz na nb nc aw nd bi"><span id="dbd4" class="ne md it na b gy nf ng l nh ni">{  <br/>  "name": "my-lambda-code",  <br/>  "version": "1.0.0",  <br/>  "description": "AWS Lambda function for microservice",  <br/>  "main": "index.js",  <br/>  "scripts": {    <br/>    "test": "echo \"Error: no test specified\" &amp;&amp; exit 1"  <br/>  },  <br/>  "author": "",  <br/>  "license": "ISC",  <br/>  "dependencies": {},  <br/>  "devDependencies": {}<br/>}</span></pre><h2 id="d687" class="ne md it bd me nn no dn mi np nq dp mm li nr ns mo lm nt nu mq lq nv nw ms nx bi translated"><em class="ny"> index.json </em></h2><p id="127e" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">一个简单的函数，要求在请求体中有一个<code class="fe nj nk nl na b">callerName</code>键。该函数将<code class="fe nj nk nl na b">“Hello, ”</code>添加到接收到的<code class="fe nj nk nl na b">callerName</code>字符串的前面，并将其作为响应返回。</p><pre class="kj kk kl km gt mz na nb nc aw nd bi"><span id="97e5" class="ne md it na b gy nf ng l nh ni">exports.handler = async (eventObject, context, callback) =&gt; {<br/><br/>  const name = JSON.parse(eventObject.body).callerName;<br/><br/>  var response = {<br/>    "statusCode": 200,<br/>    "headers": {<br/>      "Content-Type": "application/json"<br/>    },<br/>    "isBase64Encoded": false,<br/>    "body": JSON.stringify({message: "Hello, " + name})<br/>  }<br/><br/>  return response<br/>};</span></pre><h2 id="7b4c" class="ne md it bd me nn no dn mi np nq dp mm li nr ns mo lm nt nu mq lq nv nw ms nx bi translated"><em class="ny"> test-event.json </em></h2><p id="ac4b" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">包含将由API网关代理给函数的请求对象的示例。这是我们的<code class="fe nj nk nl na b">debug.sh</code>在本地测试功能时使用的，通过消除每次更改后部署的需求，可以节省大量时间。</p><pre class="kj kk kl km gt mz na nb nc aw nd bi"><span id="158c" class="ne md it na b gy nf ng l nh ni">{<br/>  "resource": "/",<br/>  "path": "/",<br/>  "httpMethod": "POST",<br/>  "requestContext": {<br/>      "resourcePath": "/",<br/>      "httpMethod": "POST",<br/>      "path": "/"<br/>  },<br/>  "headers": {<br/>      "accept": "text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3;q=0.9",<br/>      "accept-encoding": "gzip, deflate, br",<br/>      "Host": "70ixmpl4fl.execute-api.us-east-2.amazonaws.com",<br/>      "User-Agent": "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/80.0.3987.132 Safari/537.36",<br/>      "X-Amzn-Trace-Id": "Root=1-5e66d96f-7491f09xmpl79d18acf3d050"<br/>  },<br/>  "multiValueHeaders": {<br/>      "accept": [<br/>          "text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3;q=0.9"<br/>      ],<br/>      "accept-encoding": [<br/>          "gzip, deflate, br"<br/>      ]<br/>  },<br/>  "queryStringParameters": null,<br/>  "multiValueQueryStringParameters": null,<br/>  "pathParameters": null,<br/>  "stageVariables": null,<br/>  "body": "{\"callerName\":\"Luis Hamilton\"}",<br/>  "isBase64Encoded": false<br/>}</span></pre><p id="5dee" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe nj nk nl na b">template.yaml</code>文件描述了我们的部署，将在第2部分中详细介绍。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="2cd0" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">2.基础设施作为代码</h1><p id="f715" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">事不宜迟，<code class="fe nj nk nl na b">template.yaml</code>文件可以在下面找到，它概述了我们的Lambda函数的部署，该函数由一个API网关调用，只能从一个已经存在的VPC中访问。以下部分将介绍部署的不同组件。</p><pre class="kj kk kl km gt mz na nb nc aw nd bi"><span id="39f8" class="ne md it na b gy nf ng l nh ni">AWSTemplateFormatVersion: '2010-09-09'<br/>Transform: AWS::Serverless-2016-10-31<br/>Description: My serverless hello world API<br/><br/>Resources:<br/>  MyServelessLambdaFunction:<br/>    Type: AWS::Serverless::Function<br/>    Properties:<br/>      CodeUri: src/<br/>      Handler: index.handler<br/>      Runtime: nodejs12.x<br/>      MemorySize: 1024<br/>      Timeout: 20<br/>      Policies:<br/>        - AWSLambdaBasicExecutionRole<br/>        - AWSLambdaVPCAccessExecutionRole<br/>      Events:<br/>        APIRoot:<br/>          Type: Api<br/>          Properties:<br/>            Path: /<br/>            Method: ANY<br/>            RestApiId: !Ref MyPrivateApi<br/>  <br/>  MyApiSecurityGroup:<br/>    Type: AWS::EC2::SecurityGroup<br/>    Properties:<br/>      VpcId: MyVpcIdShouldBeHardcodedHere<br/>      GroupDescription: Allows access over 443<br/>      SecurityGroupIngress:<br/>        -<br/>          IpProtocol: "tcp"<br/>          FromPort: 443<br/>          ToPort: 443<br/>          CidrIp: 0.0.0.0/0<br/><br/>  MyApiAccessEndpoint:<br/>    Type: AWS::EC2::VPCEndpoint<br/>    Properties:<br/>      VpcId: MyVpcIdShouldBeHardcodedHere<br/>      ServiceName: !Sub "com.amazonaws.${AWS::Region}.execute-api"<br/>      VpcEndpointType: Interface<br/>      PrivateDnsEnabled: true<br/>      SubnetIds:<br/>        - MySubnetId1ShouldBeHardcodedHere<br/>        - MySubnetId2ShouldBeHardcodedHere      <br/>      SecurityGroupIds:<br/>        - !Ref MyApiSecurityGroup<br/><br/>  MyPrivateApi:<br/>    Type: AWS::Serverless::Api<br/>    Properties:<br/>      StageName: Prod<br/>      MethodSettings:<br/>        - HttpMethod: POST<br/>          ResourcePath: /<br/>      EndpointConfiguration: PRIVATE<br/>      DefinitionBody:<br/>        swagger: 2.0<br/>        info:<br/>          title: MyPrivateApi<br/>        basePath: /Prod<br/>        schemes:<br/>          - https<br/>        x-amazon-apigateway-policy:<br/>          Version: "2012-10-17"<br/>          Statement:<br/>            -<br/>              Effect: "Allow"<br/>              Principal: "*"<br/>              Action:<br/>                - "execute-api:Invoke"<br/>              Resource: "execute-api:/*"<br/>              Condition:<br/>                StringEquals:<br/>                  aws:sourceVpce: !Ref MyApiAccessEndpoint<br/>        paths:<br/>          /:<br/>            x-amazon-apigateway-any-method:<br/>              produces:<br/>              - application/json<br/>              x-amazon-apigateway-integration:<br/>                responses:<br/>                  default:<br/>                    statusCode: 200<br/>                uri: !Join [ "", [ !Sub "arn:aws:apigateway:${AWS::Region}:lambda:path/2015-03-31/functions/arn:aws:lambda:${AWS::Region}:${AWS::AccountId}:function:", !Ref MyServelessLambdaFunction, "/invocations"] ]<br/>                passthroughBehavior: when_no_match<br/>                httpMethod: POST<br/>                type: AWS_PROXY<br/><br/>Outputs:<br/>  MyPrivateApi:<br/>    Description: "API Gateway endpoint URL for Prod stage"<br/>    Value: !Sub "https://${MyPrivateApi}.execute-api.${AWS::Region}.amazonaws.com/Prod/"<br/>  MyServelessLambdaFunction:<br/>    Description: "Lambda Function ARN"<br/>    Value: !GetAtt MyServelessLambdaFunction.Arn</span></pre><h2 id="208a" class="ne md it bd me nn no dn mi np nq dp mm li nr ns mo lm nt nu mq lq nv nw ms nx bi translated">MyServelessLambdaFunction</h2><p id="f149" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">下面的代码块指定了Lambda函数。一些重要的属性包括:</p><ol class=""><li id="ad70" class="nz oa it lb b lc ld lf lg li ob lm oc lq od lu oe of og oh bi translated">运行时:指定我们脚本的语言。</li><li id="cc84" class="nz oa it lb b lc oi lf oj li ok lm ol lq om lu oe of og oh bi translated">Events:描述触发此Lambda的资源的对象。在这种情况下，Lambda由API网关<code class="fe nj nk nl na b">MyPrivateApi</code>触发。从Lambda控制台拍摄的下图中可以看到生成的网关。</li></ol><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi on"><img src="../Images/0c9fc52759baec858b70ac0651a3dbd5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*2FkLLK_6kp9GAdMkIxQzkQ.png"/></div></div></figure><pre class="kj kk kl km gt mz na nb nc aw nd bi"><span id="9e67" class="ne md it na b gy nf ng l nh ni">  MyServelessLambdaFunction:<br/>    Type: AWS::Serverless::Function<br/>    Properties:<br/>      CodeUri: src/<br/>      Handler: index.handler<br/>      Runtime: nodejs12.x<br/>      MemorySize: 1024<br/>      Timeout: 20<br/>      Policies:<br/>        - AWSLambdaBasicExecutionRole<br/>        - AWSLambdaVPCAccessExecutionRole<br/>      Events:<br/>        APIRoot:<br/>          Type: Api<br/>          Properties:<br/>            Path: /<br/>            Method: ANY<br/>            RestApiId: !Ref MyPrivateApi</span></pre><h2 id="9346" class="ne md it bd me nn no dn mi np nq dp mm li nr ns mo lm nt nu mq lq nv nw ms nx bi translated">我的安全组</h2><p id="5f1c" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">下面的代码块创建了一个安全块，我们将把它分配给API，它允许来自任何原始IP地址的HTTP访问(端口443)。注意，由于API是私有类型的，所以不能从VPC外部访问它。</p><pre class="kj kk kl km gt mz na nb nc aw nd bi"><span id="67b8" class="ne md it na b gy nf ng l nh ni">  MyApiSecurityGroup:<br/>    Type: AWS::EC2::SecurityGroup<br/>    Properties:<br/>      VpcId: MyVpcIdShouldBeHardcodedHere<br/>      GroupDescription: Allows access over 443<br/>      SecurityGroupIngress:<br/>        -<br/>          IpProtocol: "tcp"<br/>          FromPort: 443<br/>          ToPort: 443<br/>          CidrIp: 0.0.0.0/0</span></pre><h2 id="1cc1" class="ne md it bd me nn no dn mi np nq dp mm li nr ns mo lm nt nu mq lq nv nw ms nx bi translated">我的观点</h2><p id="21e3" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">下面，我们创建一个<a class="ae ky" href="https://docs.aws.amazon.com/vpc/latest/userguide/vpc-endpoints.html" rel="noopener ugc nofollow" target="_blank"> VPC端点，</a>它是一个AWS构造，允许将API网关等资源连接到VPC，而不会将流量暴露给互联网。需要考虑的几个关键属性:</p><ol class=""><li id="9353" class="nz oa it lb b lc ld lf lg li ob lm oc lq od lu oe of og oh bi translated"><code class="fe nj nk nl na b">ServiceName</code>:端点将连接的AWS资源类型。<code class="fe nj nk nl na b">${AWS:Region}</code>将被脚本部署到的地区所替代。</li><li id="4d0c" class="nz oa it lb b lc oi lf oj li ok lm ol lq om lu oe of og oh bi translated"><code class="fe nj nk nl na b">VpcEndpointType</code>:我们应该将其设置为<code class="fe nj nk nl na b">interface</code>，这是一个<a class="ae ky" href="https://aws.amazon.com/privatelink/?privatelink-blogs.sort-by=item.additionalFields.createdDate&amp;privatelink-blogs.sort-order=desc" rel="noopener ugc nofollow" target="_blank"> AWS私有链接</a>——连接到内部资源的powered端点。</li><li id="3ac4" class="nz oa it lb b lc oi lf oj li ok lm ol lq om lu oe of og oh bi translated"><code class="fe nj nk nl na b">PrivateDnsEnabled</code>:应该设置为<code class="fe nj nk nl na b">true</code>来创建允许VPC中的实例访问API的DNS记录。</li></ol><pre class="kj kk kl km gt mz na nb nc aw nd bi"><span id="2a45" class="ne md it na b gy nf ng l nh ni">MyApiAccessEndpoint:<br/>    Type: AWS::EC2::VPCEndpoint<br/>    Properties:<br/>      VpcId: MyVpcIdShouldBeHardcodedHere<br/>      ServiceName: !Sub "com.amazonaws.${AWS::Region}.execute-api"<br/>      VpcEndpointType: Interface<br/>      PrivateDnsEnabled: true<br/>      SubnetIds:<br/>        - MySubnetId1ShouldBeHardcodedHere<br/>        - MySubnetId2ShouldBeHardcodedHere      <br/>      SecurityGroupIds:<br/>        - !Ref MyApiSecurityGroup</span></pre><h2 id="3260" class="ne md it bd me nn no dn mi np nq dp mm li nr ns mo lm nt nu mq lq nv nw ms nx bi translated">MyPrivateApi</h2><p id="263a" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">最后，下面的代码块使用前面块中概述的资源创建API网关。需要记住的一些重要属性:</p><ol class=""><li id="17e4" class="nz oa it lb b lc ld lf lg li ob lm oc lq od lu oe of og oh bi translated"><code class="fe nj nk nl na b">EndpointConfiguration</code>:定义端点的类型。在我们的例子中，我们有一个只能从VPC访问的<code class="fe nj nk nl na b">private</code>端点。</li><li id="7c16" class="nz oa it lb b lc oi lf oj li ok lm ol lq om lu oe of og oh bi translated"><code class="fe nj nk nl na b">x-amazon-apigateway-policy</code>:为API定义一个资源策略，授权先前创建的端点访问它。</li><li id="db0f" class="nz oa it lb b lc oi lf oj li ok lm ol lq om lu oe of og oh bi translated"><code class="fe nj nk nl na b">paths</code>:应该创建的路径列表以及它们应该如何表现。在我们的例子中，我们创建了一个根路径，<code class="fe nj nk nl na b">/</code>。</li><li id="5355" class="nz oa it lb b lc oi lf oj li ok lm ol lq om lu oe of og oh bi translated"><code class="fe nj nk nl na b">x-amazon-apigateway-integration</code>:该属性定义了API网关和Lambda函数之间的集成。关于其他属性的信息可在<a class="ae ky" href="https://docs.aws.amazon.com/apigateway/latest/developerguide/api-gateway-swagger-extensions-integration.html" rel="noopener ugc nofollow" target="_blank">这里</a>找到。</li><li id="40e1" class="nz oa it lb b lc oi lf oj li ok lm ol lq om lu oe of og oh bi translated"><code class="fe nj nk nl na b">uri</code>:这个冗长的表达式将Lambda函数与集成相关联。</li><li id="ecde" class="nz oa it lb b lc oi lf oj li ok lm ol lq om lu oe of og oh bi translated"><code class="fe nj nk nl na b">httpMethod</code>:λ函数的<code class="fe nj nk nl na b">x-amazon-apigateway-integration</code>的<code class="fe nj nk nl na b">httpMethod</code>应始终设置为<code class="fe nj nk nl na b">POST</code>；否则，整合是行不通的。注意，这与公开API的HTTP方法不同，后者可以是任何类型。</li></ol><pre class="kj kk kl km gt mz na nb nc aw nd bi"><span id="ec64" class="ne md it na b gy nf ng l nh ni">MyPrivateApi:<br/>    Type: AWS::Serverless::Api<br/>    Properties:<br/>      StageName: Prod<br/>      MethodSettings:<br/>        - HttpMethod: POST<br/>          ResourcePath: /<br/>      EndpointConfiguration: PRIVATE<br/>      DefinitionBody:<br/>        swagger: 2.0<br/>        info:<br/>          title: MyPrivateApi<br/>        basePath: /Prod<br/>        schemes:<br/>          - https<br/>        x-amazon-apigateway-policy:<br/>          Version: "2012-10-17"<br/>          Statement:<br/>            -<br/>              Effect: "Allow"<br/>              Principal: "*"<br/>              Action:<br/>                - "execute-api:Invoke"<br/>              Resource: "execute-api:/*"<br/>              Condition:<br/>                StringEquals:<br/>                  aws:sourceVpce: !Ref MyApiAccessEndpoint<br/>        paths:<br/>          /:<br/>            x-amazon-apigateway-any-method:<br/>              produces:<br/>              - application/json<br/>              x-amazon-apigateway-integration:<br/>                responses:<br/>                  default:<br/>                    statusCode: 200<br/>                uri: !Join [ "", [ !Sub "arn:aws:apigateway:${AWS::Region}:lambda:path/2015-03-31/functions/arn:aws:lambda:${AWS::Region}:${AWS::AccountId}:function:", !Ref MyServelessLambdaFunction, "/invocations"] ]<br/>                passthroughBehavior: when_no_match<br/>                httpMethod: POST<br/>                type: AWS_PROXY</span></pre></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="ba4f" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">3.部署</h1><p id="cf3f" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">要部署我们的服务堆栈，只需运行<code class="fe nj nk nl na b">deploy.sh</code>脚本；同样，您可以运行<code class="fe nj nk nl na b">./cmd/deploy.sh</code>。</p><p id="9be7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在部署过程中，会提示您一条消息:“<code class="fe nj nk nl na b">MyServelessLambdaFunction</code>可能没有定义授权。这样可以吗？”这是意料之中的，因为我们没有实现授权。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="cf9b" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">结论</h1><p id="e9cc" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">我们已经看到了如何使用Amazon API Gateway和Lambda创建无服务器API微服务。完整的服务在单个模板文件中描述，并且可以通过编程方式部署。</p><h2 id="e6b6" class="ne md it bd me nn no dn mi np nq dp mm li nr ns mo lm nt nu mq lq nv nw ms nx bi translated">额外资源</h2><div class="oo op gp gr oq or"><a href="https://github.com/3pillarlabs/aws-sam-express-sample" rel="noopener  ugc nofollow" target="_blank"><div class="os ab fo"><div class="ot ab ou cl cj ov"><h2 class="bd iu gy z fp ow fr fs ox fu fw is bi translated">3 pillar labs/AWS-Sam-express-样品</h2><div class="oy l"><h3 class="bd b gy z fp ow fr fs ox fu fw dk translated">一个简单的演示展示了AWS无服务器应用程序模型(SAM)和NodeJS Express应用程序的集成，它…</h3></div><div class="oz l"><p class="bd b dl z fp ow fr fs ox fu fw dk translated">github.com</p></div></div><div class="pa l"><div class="pb l pc pd pe pa pf ks or"/></div></div></a></div><div class="oo op gp gr oq or"><a href="https://github.com/awsdocs/aws-lambda-developer-guide/tree/master/sample-apps/nodejs-apig" rel="noopener  ugc nofollow" target="_blank"><div class="os ab fo"><div class="ot ab ou cl cj ov"><h2 class="bd iu gy z fp ow fr fs ox fu fw is bi translated">AWS docs/AWS-lambda-开发者指南</h2><div class="oy l"><h3 class="bd b gy z fp ow fr fs ox fu fw dk translated">这个示例应用程序是一个Lambda函数，它处理来自API Gateway REST API的事件。该API提供了一个…</h3></div><div class="oz l"><p class="bd b dl z fp ow fr fs ox fu fw dk translated">github.com</p></div></div><div class="pa l"><div class="pg l pc pd pe pa pf ks or"/></div></div></a></div></div></div>    
</body>
</html>