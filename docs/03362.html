<html>
<head>
<title>How to Handle Docker Secrets in Node.js</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何在Node.js中处理Docker秘密</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/how-to-handle-docker-secrets-in-node-js-3aa04d5bf46e?source=collection_archive---------4-----------------------#2020-02-05">https://betterprogramming.pub/how-to-handle-docker-secrets-in-node-js-3aa04d5bf46e?source=collection_archive---------4-----------------------#2020-02-05</a></blockquote><div><div class="fc ii ij ik il im"/><div class="in io ip iq ir"><div class=""/><div class=""><h2 id="57c5" class="pw-subtitle-paragraph jr it iu bd b js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki dk translated">不要在生产环境中暴露敏感信息</h2></div><figure class="kk kl km kn gu ko gi gj paragraph-image"><div role="button" tabindex="0" class="kp kq di kr bf ks"><div class="gi gj kj"><img src="../Images/54006b7bb5af5cdead321d38e4f00048.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*COTvnupOY0t6kBjJPnmMkA.jpeg"/></div></div><p class="kv kw gk gi gj kx ky bd b be z dk translated"><a class="ae kz" href="https://unsplash.com/@flohmaier?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Floh Maier </a>在<a class="ae kz" href="https://unsplash.com/?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍照</p></figure><p id="27fe" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">在我的<a class="ae kz" href="https://medium.com/better-programming/how-to-add-authentication-to-your-fastify-rest-api-using-auth0-cddc7eacc90" rel="noopener">上一篇文章</a>中，我告诉你<em class="lw">而不是</em>将敏感信息放入源代码控制中。我展示了如何使用一个<code class="fe lx ly lz ma b">.env</code>文件来存储这些信息并将其从源代码控制中排除。</p><p id="47f9" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">我还展示了如何使用<code class="fe lx ly lz ma b"><a class="ae kz" href="https://www.npmjs.com/package/dotenv" rel="noopener ugc nofollow" target="_blank">dotenv</a></code>在环境中加载这些设置，以便Node.js应用程序可以读取它们。</p><p id="87b0" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">虽然使用环境变量是本地开发的正确方法，但不建议在生产环境中使用。</p><p id="3ce8" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">命令行中的一个简单的<code class="fe lx ly lz ma b">printenv</code>会列出所有的环境变量。在生产中管理您的敏感设置的一个更安全的方法是使用<a class="ae kz" href="https://docs.docker.com/engine/swarm/secrets/" rel="noopener ugc nofollow" target="_blank"> Docker secrets </a>。</p></div><div class="ab cl mb mc hy md" role="separator"><span class="me bw bk mf mg mh"/><span class="me bw bk mf mg mh"/><span class="me bw bk mf mg"/></div><div class="in io ip iq ir"><h1 id="6fee" class="mi mj iu bd mk ml mm mn mo mp mq mr ms ka mt kb mu kd mv ke mw kg mx kh my mz bi translated">码头工人的秘密</h1><p id="524e" class="pw-post-body-paragraph la lb iu lc b ld na jv lf lg nb jy li lj nc ll lm ln nd lp lq lr ne lt lu lv in bi translated">Docker秘密有助于管理容器在运行时需要的敏感数据。例如，用户名、密码和证书。单个秘密的最大大小是500KB。</p><p id="cd73" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">当你的容器在集群中运行时，比如Docker Swarm，你可以使用Docker secrets。从Docker版本17.06开始，Docker支持所有类型的容器上的Docker秘密。</p><h2 id="d5a2" class="nf mj iu bd mk ng nh dn mo ni nj dp ms lj nk nl mu ln nm nn mw lr no np my nq bi translated">创建Docker机密</h2><p id="0953" class="pw-post-body-paragraph la lb iu lc b ld na jv lf lg nb jy li lj nc ll lm ln nd lp lq lr ne lt lu lv in bi translated">我更喜欢使用命令行创建Docker秘密。</p><p id="bbb8" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">有两个选择:使用<code class="fe lx ly lz ma b">echo</code>或使用包含您的秘密的文件。下面的命令创建了一个名为<code class="fe lx ly lz ma b">DB_PASSWORD</code>的Docker secret，它使用<code class="fe lx ly lz ma b">echo</code>保存字符串<code class="fe lx ly lz ma b">“secretpassword”</code>。</p><pre class="kk kl km kn gu nr ma ns nt aw nu bi"><span id="720a" class="nf mj iu ma b gz nv nw l nx ny">echo "secretpassword" | docker secret create DB_PASSWORD -</span></pre><p id="d569" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">另一种方法是使用包含秘密值的文本文件。</p><pre class="kk kl km kn gu nr ma ns nt aw nu bi"><span id="125e" class="nf mj iu ma b gz nv nw l nx ny">docker secret create DB_PASSWORD db_password.txt</span></pre><p id="095a" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">这两个命令具有相同的结果。创建一个Docker秘密<code class="fe lx ly lz ma b">DB_PASSWORD</code>,其中包含秘密和密码。与任何Docker资源一样，您可以使用<code class="fe lx ly lz ma b">inspect</code>命令来获取秘密的细节。</p><pre class="kk kl km kn gu nr ma ns nt aw nu bi"><span id="83f5" class="nf mj iu ma b gz nv nw l nx ny">Docker secret inspect [secretid or name]</span></pre><p id="004c" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">如果您成功地创建了这个秘密，它将返回一个JSON对象及其详细信息。细节不包括价值。</p><figure class="kk kl km kn gu ko"><div class="bz fq l di"><div class="nz oa l"/></div><p class="kv kw gk gi gj kx ky bd b be z dk translated">执行docker secret inspect时Docker Secret的详细信息</p></figure><h2 id="e4a4" class="nf mj iu bd mk ng nh dn mo ni nj dp ms lj nk nl mu ln nm nn mw lr no np my nq bi translated">在Node.js中读取和使用Docker机密</h2><p id="b6e5" class="pw-post-body-paragraph la lb iu lc b ld na jv lf lg nb jy li lj nc ll lm ln nd lp lq lr ne lt lu lv in bi translated">Docker使用内存文件系统来存储机密。Docker秘密看起来像你的容器中的常规文件。</p><p id="18c6" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">Docker将每个秘密作为一个文件存储在<code class="fe lx ly lz ma b">/run/secrets/</code>中。文件名是机密的名称。当Node.js应用程序在容器中运行时，它可以像读取常规文件一样读取秘密。</p><p id="9364" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">我开发了<a class="ae kz" href="https://github.com/PatrickKalkman/MiniVideoEncoder" rel="noopener ugc nofollow" target="_blank">一个Node.js模块</a>，它从<code class="fe lx ly lz ma b">/run/secrets</code>读取一个文件并返回文件的内容。</p><figure class="kk kl km kn gu ko"><div class="bz fq l di"><div class="nz oa l"/></div><p class="kv kw gk gi gj kx ky bd b be z dk translated">secrets.js，一个读取Docker秘密的Node.js模块</p></figure><p id="490e" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">对于本地开发，我想使用前面描述的<code class="fe lx ly lz ma b">.env</code>文件。</p><p id="fa91" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">但一旦应用程序在生产中运行，它应该从Docker secrets中读取设置。通过将<code class="fe lx ly lz ma b">secrets.js</code>与我的标准配置对象相结合，我获得了两方面的优势。</p><figure class="kk kl km kn gu ko"><div class="bz fq l di"><div class="nz oa l"/></div><p class="kv kw gk gi gj kx ky bd b be z dk translated">组合了Docker秘密和环境变量的配置对象</p></figure><p id="c0a7" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">例如，在第19行，我把阅读秘密和环境设定<code class="fe lx ly lz ma b">secrets.read(‘STORAGE_HOST’) || process.env.STORAGE_HOST</code>结合在一起。秘密比环境更重要。</p><p id="c92d" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">代替开发你自己的，有现存的npm库帮助阅读Docker秘密。</p><p id="4adf" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">比如<a class="ae kz" href="https://www.npmjs.com/package/docker-swarm-secrets" rel="noopener ugc nofollow" target="_blank"> docker-swarm-secrets </a>、<a class="ae kz" href="https://www.npmjs.com/package/docker-secret" rel="noopener ugc nofollow" target="_blank"> docker-secret </a>、<a class="ae kz" href="https://www.npmjs.com/package/@cloudreach/docker-secrets" rel="noopener ugc nofollow" target="_blank">@ cloud reach/docker-secret</a>。这些模块读取所有Docker秘密，并通过一个JavaScript对象公开它们。</p><h2 id="9989" class="nf mj iu bd mk ng nh dn mo ni nj dp ms lj nk nl mu ln nm nn mw lr no np my nq bi translated">将Docker机密分配给服务</h2><p id="c108" class="pw-post-body-paragraph la lb iu lc b ld na jv lf lg nb jy li lj nc ll lm ln nd lp lq lr ne lt lu lv in bi translated">在容器可以访问秘密之前，我们必须给予容器明确的许可。有两个选项可以赋予权限，在创建服务时添加或者添加到您的<code class="fe lx ly lz ma b">docker-compose.yml</code>文件中。</p><pre class="kk kl km kn gu nr ma ns nt aw nu bi"><span id="fb81" class="nf mj iu ma b gz nv nw l nx ny">docker service create --name myservice --secret STORAGE_HOST myimage </span></pre><p id="0b9b" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">服务<code class="fe lx ly lz ma b">myservice</code>可以使用命令行访问主机上定义的秘密<code class="fe lx ly lz ma b">STORAGE_HOST</code>。</p><p id="87ee" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">另一种不同的方式也是我喜欢的方式是使用合成文件，如下所示。</p><p id="aa7d" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">合成文件在单独块中命名每个秘密，参见第13行。这些秘密让<code class="fe lx ly lz ma b">external: true</code>定义这些秘密已经存在，并且是使用命令行在外部创建的。</p><figure class="kk kl km kn gu ko"><div class="bz fq l di"><div class="nz oa l"/></div><p class="kv kw gk gi gj kx ky bd b be z dk translated">定义和使用docker秘密的docker-compose.yml</p></figure></div><div class="ab cl mb mc hy md" role="separator"><span class="me bw bk mf mg mh"/><span class="me bw bk mf mg mh"/><span class="me bw bk mf mg"/></div><div class="in io ip iq ir"><h1 id="4ef8" class="mi mj iu bd mk ml mm mn mo mp mq mr ms ka mt kb mu kd mv ke mw kg mx kh my mz bi translated">官方码头工人形象中的码头工人秘密</h1><p id="427d" class="pw-post-body-paragraph la lb iu lc b ld na jv lf lg nb jy li lj nc ll lm ln nd lp lq lr ne lt lu lv in bi translated">如果你想知道官方Docker图片是如何处理Docker秘密的，似乎有一个典型的模式。大多数使用环境设置的官方图像也包含带有<code class="fe lx ly lz ma b">_FILE</code>后缀的相同环境设置。</p><p id="e5e0" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">例如，<a class="ae kz" href="https://www.mongodb.com/" rel="noopener ugc nofollow" target="_blank"> MongoDB </a>图像使用了<code class="fe lx ly lz ma b">MONGO_INITDB_ROOT_USERNAME</code>和<code class="fe lx ly lz ma b">MONGO_INITDB_ROOT_PASSWORD</code>环境变量。</p><p id="1b25" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">它还接受<code class="fe lx ly lz ma b">MONGO_INITDB_ROOT_USERNAME_FILE</code>和<code class="fe lx ly lz ma b">MONGO_INITDB_ROOT_PASSWORD_FILE</code>环境变量。如果您将后者设置为<code class="fe lx ly lz ma b">/run/secrets/[secret name]</code>，图像将读取并使用该秘密。</p><p id="ceae" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">如果我们看看官方<a class="ae kz" href="https://hub.docker.com/_/postgres" rel="noopener ugc nofollow" target="_blank"> Postgres </a>图片的<a class="ae kz" href="https://hub.docker.com/_/postgres" rel="noopener ugc nofollow" target="_blank">文档</a>，它提到了以下内容:</p><blockquote class="ob oc od"><p id="0c81" class="la lb lw lc b ld le jv lf lg lh jy li oe lk ll lm of lo lp lq og ls lt lu lv in bi translated">作为通过环境变量传递敏感信息的替代方案，<code class="fe lx ly lz ma b">_FILE</code>可被附加到一些先前列出的环境变量，使得初始化脚本从容器中存在的文件加载那些变量的值。</p><p id="871a" class="la lb lw lc b ld le jv lf lg lh jy li oe lk ll lm of lo lp lq og ls lt lu lv in bi translated">特别是，这可以用来从存储在<code class="fe lx ly lz ma b">/run/secrets/&lt;secret_name&gt;</code>文件中的Docker秘密中加载密码。"</p></blockquote><p id="f158" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">所以，官方的Postgres图像也使用了同样的<code class="fe lx ly lz ma b">_FILE</code>图案。</p></div><div class="ab cl mb mc hy md" role="separator"><span class="me bw bk mf mg mh"/><span class="me bw bk mf mg mh"/><span class="me bw bk mf mg"/></div><div class="in io ip iq ir"><h1 id="924c" class="mi mj iu bd mk ml mm mn mo mp mq mr ms ka mt kb mu kd mv ke mw kg mx kh my mz bi translated">在Node.js中使用_FILE模式</h1><p id="3aaa" class="pw-post-body-paragraph la lb iu lc b ld na jv lf lg nb jy li lj nc ll lm ln nd lp lq lr ne lt lu lv in bi translated">虽然早期的读取秘密的模块工作良好，但最好使用与官方图像相同的模式。我们只需要对secrets模块和config对象做一点小小的修改。</p><figure class="kk kl km kn gu ko"><div class="bz fq l di"><div class="nz oa l"/></div><p class="kv kw gk gi gj kx ky bd b be z dk translated">通过指定完整路径读取Docker机密</p></figure><p id="c0d9" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">我们接收完整的路径，而不是接受秘密的名称和预先考虑秘密的路径。<code class="fe lx ly lz ma b">Config</code>对象首先读取<code class="fe lx ly lz ma b">_FILE</code>设置的值，如果不可用，则使用环境设置。</p><figure class="kk kl km kn gu ko"><div class="bz fq l di"><div class="nz oa l"/></div><p class="kv kw gk gi gj kx ky bd b be z dk translated">配置对象，它使用与官方Docker图像相同的模式</p></figure><p id="cc0c" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">例如，第27行上的<code class="fe lx ly lz ma b">domain: secrets.read(‘AUTH_DOMAIN_FILE’) || process.env.AUTH_DOMAIN</code>首先尝试读取秘密文件，如果不成功，则使用<code class="fe lx ly lz ma b">AUTH_DOMAIN</code>环境设置。</p></div><div class="ab cl mb mc hy md" role="separator"><span class="me bw bk mf mg mh"/><span class="me bw bk mf mg mh"/><span class="me bw bk mf mg"/></div><div class="in io ip iq ir"><h1 id="4dcc" class="mi mj iu bd mk ml mm mn mo mp mq mr ms ka mt kb mu kd mv ke mw kg mx kh my mz bi translated">开始使用Docker机密</h1><p id="e243" class="pw-post-body-paragraph la lb iu lc b ld na jv lf lg nb jy li lj nc ll lm ln nd lp lq lr ne lt lu lv in bi translated">我希望我已经说服您开始使用Docker秘密来存储生产中的敏感信息。感谢您的阅读，如果您有任何问题或意见，请随时回复。</p></div></div>    
</body>
</html>