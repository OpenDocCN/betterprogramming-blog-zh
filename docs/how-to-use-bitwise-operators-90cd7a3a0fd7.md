# 如何使用按位运算符

> 原文：<https://betterprogramming.pub/how-to-use-bitwise-operators-90cd7a3a0fd7>

## 学习位操作

![](img/ed46893462509917983fef0c5c242e0f.png)

照片由[马库斯·斯皮斯克](https://unsplash.com/@markusspiske?utm_source=medium&utm_medium=referral)在 [Unsplash](https://unsplash.com?utm_source=medium&utm_medium=referral) 拍摄

# 计算机是如何表示数据的？

如果您以前曾经编程过，那么您几乎肯定使用过某种数值数据类型，比如整数。

但是你有没有想过你的电脑实际上是怎么储存这些数字的？

与我们通常使用 10 的幂来表示数字不同，计算机使用 2 的幂来存储值。

## 二进制表示法

这意味着数字只能用 0 和 1 的字符串来表示，这是一个二进制系统。二进制串中的每个数字称为一位，每组八位是一个字节。

通常，我们从右到左以 2 的幂递增的方式读取这些二进制字符串。这就像我们正常阅读数字一样，1 的位置是最右边的数字，然后是左边的 10 的位置，依此类推。

所以，如果我们想用二进制来表示([无符号](https://www.tutorialspoint.com/unsigned-and-signed-binary-numbers))数 10，那就是 1010，因为 1(2⁰) + 0(2 ) + 1(2 ) + 0(2 ) = 10。

# 我们能用二进制数据做什么？

既然我们已经了解了这些数字是如何存储的，我们就可以利用这些知识，使用直接作用于数字的二进制表示的操作。

首先，想想你已经知道的运算——这可能包括加法(+)、减法(-)、乘法(*)和除法(/)。这些都是可以用在任何基数的数字上的运算符——所以我们认为数字是二进制的还是基数为 10 的并不重要。

然而，也有操作符专门作用于二进制形式的数字位，恰当地命名为[位操作符](https://en.wikipedia.org/wiki/Bitwise_operation)。

在我解释为什么这些有用之前，让我们先来看一下主要的，并解释它们是如何工作的，它们看起来像什么。

## 否定(~)

求反运算符只是反转一个数中的所有位。所以，如果`x == 0101`，那么`~x == 1010`。

## 左移(<

The left shift operator moves all of the bits to the left by a specified number of bits. Any bits that go past the leftmost position are ignored. So, if 【 , then 【 .

## Right shift (>>)

类似地，右移位运算符将所有位向右移动指定的位数。所以，如果`x == 101010`，那么`x >> 2 == 001010`。

## 和(&)

与两个二进制数一起使用的 AND 运算符返回一个新的二进制数，其中*和*每隔一个位置都有 1 和 0。

所以，如果`x == 1100`和`y == 1011`，那么`x & y == 1000`，因为这两个数字的最左边都只有 1。

## 或者(|)

与两个二进制数一起使用的 OR 运算符返回一个新的二进制数，其中任何一个*或*的位置为 1，其他位置为 0。

所以，如果`x == 1100`和`y == 1011`，那么`x | y == 1111`，因为*两个数字中至少有一个*在每个位置上都有 1。

## 异或(^)

XOR(或 exclusive OR)运算符用于两个二进制数，返回一个新的二进制数，其中两个数不一致的每个位置都是 1，因此一个位置是 1，另一个位置是 0，其他位置是 0。

因此，如果`x == 1100`和`y == 1011`，那么`x ^ y == 0111`，因为这两个数字除了最左边的位之外都不一致。

# 这为什么有用？

如果你不明白为什么要使用这些操作符，你并不孤单。当我第一次了解它们时，它们似乎并不那么有用。

但是，在许多领域，如嵌入式编程、系统编程和网络，它们可以在许多不同问题的解决方案中看到。

现在，让我们回顾一下按位运算符的一些用例，希望你能开始对它们有更多的了解。

## 数据表示法

在表示数据时，按位运算符是非常有效地利用空间的好方法。

想象以下情况:

> 你是一个电脑游戏的游戏开发人员，你想在玩家玩游戏时定期存储他们的鼠标位置。为此，您每分钟都要将玩家的光标位置发送到游戏服务器。游戏在 1000 x 1000 大小的固定窗口中运行。

最简单的方法是为每个快照向服务器发送两个整数数据(一个用于 x 坐标，一个用于 y 坐标)。通常，整数是 32 位，所以这意味着发送回 64 位数据。

然而，我们可以通过使用按位操作符来提高空间效率。

由于每个坐标最多是 1000，这意味着我们只需要 10 位来存储每个数字，因为二进制 1111111111 是 1023，大于 1000。这意味着我们实际上总共只需要 20 位。

我们可以将这 20 位存储在一个 32 位整数中，最右边的 10 位表示 x 坐标，接下来的 10 位表示 y 坐标，剩下的 12 位为零。

一旦数据到达后端服务器，我们就可以用正确的 shift 和 OR 操作符提取每个数字。

## base-2 的有用属性

以 2 为基数有一些便利的属性，使得一些常见的问题很容易回答。

例如，我们可以很容易地确定一个数是否是 2 的幂。

任何 2 的幂的数字只有最左边的位被设置为 1，其他的位都是 0。

我们可以通过检查`(x & (x — 1)) == 0`来快速确定一个数字`x`是否遵循这个模式。这是因为如果`x`是 2 的幂，那么`x-1`将使除之外的每个位*的最左边的位设置为 1，所以当我们使用 AND 运算符时，它们在任何位置都没有一致的位。*

## 算法/面试问题

最后，在技术面试中可能遇到的算法问题中，可以零星地找到按位运算符。这些例子常常利用了`x ^ x == 0`这个事实。

**交换两个没有临时变量的数字**

为了交换两个整数`x`和`y`，而不使用第三个临时值，我们可以使用 XOR 三次。

如果追溯一下，下面的赋值将导致两个变量的值最终交换:`x = x ^ y`、`y = x ^ y`和`x = x ^ y`。

[**查找数组中不出现两次的单个整数**](https://leetcode.com/problems/single-number/)

我们对数组中的每个元素进行异或运算。由于一个数字与自身进行 XOR 运算的结果是 0，所以当我们遍历整个数组时，该累计值将是一个不会出现两次的整数。