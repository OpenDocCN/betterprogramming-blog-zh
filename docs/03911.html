<html>
<head>
<title>Befriend Objective-C as a Swift Developer</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">作为Swift开发人员与Objective-C友好相处</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/befriend-objective-c-as-a-swift-developer-7d529c685299?source=collection_archive---------17-----------------------#2020-03-11">https://betterprogramming.pub/befriend-objective-c-as-a-swift-developer-7d529c685299?source=collection_archive---------17-----------------------#2020-03-11</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="8dd5" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">学会驯服野兽</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/c5abe0011d34372ad2d9c974760ba853.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*WF5fYwqyoZkfM9FhHJYUZw.jpeg"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">照片由<a class="ae ky" href="https://unsplash.com/@epmallmann?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">爱德华多·马尔曼</a>在<a class="ae ky" href="https://unsplash.com/s/photos/evil?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</p></figure><p id="2646" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果你精通Swift，并且熟悉JavaScript等其他一些语言，那么第一次使用<a class="ae ky" href="https://developer.apple.com/library/archive/documentation/Cocoa/Conceptual/ProgrammingWithObjectiveC/Introduction/Introduction.html" rel="noopener ugc nofollow" target="_blank"> Objective-C </a>代码可能会相当震惊。</p><p id="17b1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果我看一些我不常使用的其他语言的代码，比如Python，如果代码写得很好，我通常会立刻知道发生了什么。</p><p id="978a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果我看到写得很好的Objective-C代码，我的直觉反应是“这到底是什么？这是真正的代码还是随机生成的胡言乱语？”</p><p id="426d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">或者至少，过去是这样的。</p><p id="6ef1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如你所见，我并不是最大的目标C迷。然而事实是，这并不重要。</p><p id="46f8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">许多大型项目仍然至少有一部分代码是用Objective-C编写的，所以事实是，为了能够使用它们，你必须能够理解它。</p><p id="f72d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在本文中，我们将通过将代码翻译成Swift来学习该语言的基础知识。</p><p id="8dc7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们将要使用的代码来自于本文，这是对MVVM设计模式的一个很好的简短介绍。唉！是用Objective-C写的！</p><p id="1f3a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果您不熟悉这个重要的设计模式，那么接下来的几分钟您可能会一举两得:在一篇文章中学习MVVM和Objective-C的基础知识。听起来很酷，不是吗？</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="6e5f" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">什么是MVVM？</h1><p id="e11f" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">MVVM代表<em class="mz">模型-视图-视图模型</em>，它是一种<a class="ae ky" href="https://en.wikipedia.org/wiki/Structural_pattern" rel="noopener ugc nofollow" target="_blank">结构化设计模式</a>(它处理对象之间的关系是如何结构化的<em class="mz"/>)将对象分成三个不同的组。</p><h2 id="30f0" class="na md it bd me nb nc dn mi nd ne dp mm li nf ng mo lm nh ni mq lq nj nk ms nl bi translated">模型</h2><ul class=""><li id="f0ba" class="nm nn it lb b lc mu lf mv li no lm np lq nq lu nr ns nt nu bi translated">模型保存应用程序数据。</li><li id="16d4" class="nm nn it lb b lc nv lf nw li nx lm ny lq nz lu nr ns nt nu bi translated">通常是结构或简单的类。</li><li id="1b97" class="nm nn it lb b lc nv lf nw li nx lm ny lq nz lu nr ns nt nu bi translated">数据应该是最简单的格式，这样它就可以重用。</li></ul><h2 id="199a" class="na md it bd me nb nc dn mi nd ne dp mm li nf ng mo lm nh ni mq lq nj nk ms nl bi translated">视角</h2><ul class=""><li id="edc3" class="nm nn it lb b lc mu lf mv li no lm np lq nq lu nr ns nt nu bi translated">在屏幕上显示视觉元素。</li><li id="d872" class="nm nn it lb b lc nv lf nw li nx lm ny lq nz lu nr ns nt nu bi translated">几乎都是<code class="fe oa ob oc od b">UIView</code>的子类。</li><li id="7a90" class="nm nn it lb b lc nv lf nw li nx lm ny lq nz lu nr ns nt nu bi translated">他们应该只处理视图生命周期事件。</li></ul><h2 id="750c" class="na md it bd me nb nc dn mi nd ne dp mm li nf ng mo lm nh ni mq lq nj nk ms nl bi translated">视图模型</h2><ul class=""><li id="85bd" class="nm nn it lb b lc mu lf mv li no lm np lq nq lu nr ns nt nu bi translated">将数据从模型转换为视图可以显示的对象。</li><li id="9e6c" class="nm nn it lb b lc nv lf nw li nx lm ny lq nz lu nr ns nt nu bi translated">一个<strong class="lb iu"> </strong>唯一的网守，通过它数据从<code class="fe oa ob oc od b">Model</code>流向<code class="fe oa ob oc od b">View</code>，反之亦然。</li><li id="91ad" class="nm nn it lb b lc nv lf nw li nx lm ny lq nz lu nr ns nt nu bi translated">典型的例子是在<em class="mz"> </em>呈现给用户之前，将<code class="fe oa ob oc od b">Date</code>对象转换成<code class="fe oa ob oc od b">String</code> <em class="mz"> </em>。</li></ul><blockquote class="oe"><p id="6992" class="of og it bd oh oi oj ok ol om on lu dk translated">“[MVVM是MVC的一个增强版本，其中我们正式连接视图和控制器，并将表示逻辑从控制器中移出，移入一个新的对象，即视图模型。”—灰沟</p></blockquote><p id="75b5" class="pw-post-body-paragraph kz la it lb b lc oo ju le lf op jx lh li oq lk ll lm or lo lp lq os ls lt lu im bi translated">重要的是要明白，<code class="fe oa ob oc od b">View</code>指的是<code class="fe oa ob oc od b">View Model</code>，而<code class="fe oa ob oc od b">View Model</code>指的是<code class="fe oa ob oc od b">Model</code>，而不是相反。<code class="fe oa ob oc od b">View</code>和<code class="fe oa ob oc od b">Model</code>没有相互引用。</p><p id="630f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">那么，<code class="fe oa ob oc od b">View</code>是如何更新的呢？通过<a class="ae ky" href="https://en.wikipedia.org/wiki/Data_binding" rel="noopener ugc nofollow" target="_blank">数据绑定</a>，这是MVVM的一个核心理念。这就是为什么反应式编程经常与MVVM成对出现的原因。</p><p id="1ca4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这篇介绍只是触及了这种设计模式的表面，足以让您开始。如果您想了解更多，我会在本文末尾的参考资料部分提供一些有用文章的链接。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="0b04" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">目标-C与Swift</h1><p id="11f0" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">既然我们已经介绍了MVVM的基础知识，是时候使用Objective-C和Swift来实现它了。我们会写一个<code class="fe oa ob oc od b">Model</code>，一个<code class="fe oa ob oc od b">View Model</code>，一个<code class="fe oa ob oc od b">View</code>。</p><p id="c56f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们将使用的文章包括为我们的架构编写测试，我将在这篇文章中省略。如果你第一次见到MVVM和Objective-C，它们足以让你头晕目眩。</p><p id="4674" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们开始吧！</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="7941" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">入门指南</h1><p id="40b4" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">我们从一个简单的<code class="fe oa ob oc od b">Person</code>模型开始:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ot ou l"/></div></figure><p id="e17b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们把这段代码拆开。</p><h2 id="55d8" class="na md it bd me nb nc dn mi nd ne dp mm li nf ng mo lm nh ni mq lq nj nk ms nl bi translated">接口和实现</h2><p id="eb1d" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">我们首先看到的是<code class="fe oa ob oc od b">@interface</code>注释。要创建一个Objective-C类，我们必须提供两段代码，分别叫做<em class="mz">接口</em>和<em class="mz">实现</em>。</p><p id="a326" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">它们被存储在单独的文件中:头具有<code class="fe oa ob oc od b">.h</code>扩展名，实现具有<code class="fe oa ob oc od b">.m</code>扩展名(要知道为什么，请阅读这个精彩的<a class="ae ky" href="https://stackoverflow.com/a/652266/10706839" rel="noopener ugc nofollow" target="_blank">堆栈溢出答案</a>)。</p><p id="bc4a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe oa ob oc od b">@interface</code>用于<em class="mz">声明</em>一个类。我们声明类中将包含哪些变量和方法。<em class="mz">接口</em>描述了我们的类将会是什么样子。</p><p id="16ef" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">实现部分将是构造实际方法的地方。实现描述了我们的类将做什么。</p><h2 id="bd2a" class="na md it bd me nb nc dn mi nd ne dp mm li nf ng mo lm nh ni mq lq nj nk ms nl bi translated">n对象</h2><p id="0ec1" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">在这之后，我们写一个冒号(<code class="fe oa ob oc od b">:</code>)后面跟着<code class="fe oa ob oc od b">NSObject</code>。这类似于Swift，我们简单地声明我们的类继承自<code class="fe oa ob oc od b">NSObject</code>。</p><blockquote class="oe"><p id="818a" class="of og it bd oh oi ov ow ox oy oz lu dk translated">大多数Objective-C类层次结构的根类，子类从该类继承运行时系统的基本接口以及作为Objective-C对象的能力— <a class="ae ky" href="https://developer.apple.com/documentation/objectivec/nsobject" rel="noopener ugc nofollow" target="_blank">文档</a></p></blockquote></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="18db" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">实例和类方法</h1><p id="3dda" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">现在，这段文字是怎么回事？</p><pre class="kj kk kl km gt pa od pb pc aw pd bi"><span id="aeae" class="na md it od b gy pe pf l pg ph">- (instancetype)initwithSalutation:(NSString *)salutation firstName:(NSString *)firstName lastName:(NSString *)lastName birthdate:(NSDate *)birthdate;</span></pre><p id="c7a1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe oa ob oc od b">-</code>符号意味着我们正在编写一个<em class="mz">实例方法</em>，而不是一个<em class="mz">类方法</em>(类方法由<code class="fe oa ob oc od b">+</code>符号表示)。</p><ul class=""><li id="46d1" class="nm nn it lb b lc ld lf lg li pi lm pj lq pk lu nr ns nt nu bi translated">实例方法是一种只在类的特定实例上可用的方法，只有在类的所述实例已经被创建之后。</li><li id="be15" class="nm nn it lb b lc nv lf nw li nx lm ny lq nz lu nr ns nt nu bi translated">类方法是可以在类本身上调用的方法，不需要实例。</li></ul><p id="4338" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">参见<a class="ae ky" href="https://teamtreehouse.com/community/in-objective-c-whats-the-difference-between-instance-and-class-methods-and-how-do-you-switch-between-the-two" rel="noopener ugc nofollow" target="_blank">这篇文章</a>了解更多关于实例和类方法的信息。现在，知道我们通常使用<em class="mz">实例</em>方法就足够了。</p><p id="ae75" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe oa ob oc od b">(instancetype)</code>部分是函数将返回的内容。你可以把你的方法返回的变量的类型放在这里，或者简单的说<code class="fe oa ob oc od b">(void)</code>如果它不返回任何东西。</p><p id="98cf" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们返回一个所谓的<code class="fe oa ob oc od b">instancetype</code> <em class="mz"> </em>，其中<em class="mz"> </em>基本上意味着我们正在返回一个调用该方法的类的实例。</p><p id="a1c3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">然后是我们函数的名字<code class="fe oa ob oc od b">initWithSalutation</code>。</p><p id="b26e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">之后，我们初始化变量。<code class="fe oa ob oc od b">NSString</code>是<code class="fe oa ob oc od b">String</code>的Objective-C版本。<code class="fe oa ob oc od b">*</code>标志是做什么的？这是一个指针，指示一个<em class="mz">引用类型</em>。这不像Swift，在Swift中字符串有<em class="mz">值语义</em>。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="d96f" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">性能</h1><pre class="kj kk kl km gt pa od pb pc aw pd bi"><span id="b67b" class="na md it od b gy pe pf l pg ph">@property (nonatomic, readonly) NSString *salutation;<br/>@property (nonatomic, readonly) NSString *firstName;<br/>@property (nonatomic, readonly) NSString *lastName;<br/>@property (nonatomic, readonly) NSDate *birthdate;</span></pre><p id="5f58" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">标签提供了一种方法来定义一个类想要封装的信息。导入我们类的其他类也可以访问这个属性。</p><p id="cd40" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">您可以在属性上定义各种属性。这里的第一个是<code class="fe oa ob oc od b">nonatomic</code>,它是我们大多数时候在属性上定义的。</p><p id="d421" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这意味着多个线程可以同时访问这个变量，所以它不是线程安全的。我们几乎总是使用它的原因是它在性能上更快，而且大多数时候<code class="fe oa ob oc od b">atomic</code>并没有真正提供实质性的额外好处。在Swift中，变量默认为<code class="fe oa ob oc od b">nonatomic</code>。</p><p id="e9ea" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们用<code class="fe oa ob oc od b">readonly</code>来表示一个设定后不想改变的值。</p><p id="17ec" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们用<code class="fe oa ob oc od b">@end</code>标签标记我们接口的结尾。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="3c9c" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">履行</h1><p id="3b11" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">这是我们的<code class="fe oa ob oc od b">Person</code>模型的接口，我们仍然需要创建实现。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ot ou l"/></div></figure><p id="98a6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们从导入我们的<code class="fe oa ob oc od b">Person</code>头文件开始。</p><p id="fc50" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在那之后，唯一新的是<code class="fe oa ob oc od b">[super init]</code>部分，它代表了你如何在Objective-C中调用一个函数。</p><p id="b519" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这段代码调用了我们继承的类<code class="fe oa ob oc od b">NSObject</code>的<code class="fe oa ob oc od b">init</code>方法。然后，我们检查<code class="fe oa ob oc od b">self</code>是否被正确初始化，然后我们才给变量赋值。</p><p id="8e86" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们在Swift中的模型如下所示:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ot ou l"/></div></figure><p id="dd38" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">又短又甜，对吧？</p><p id="c513" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们的模型对象准备好了！如果你还在读这封信，那真是太棒了。我们已经谈了这么多了！</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="5012" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">构建视图模型</h1><p id="13ba" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">现在是时候创建我们的视图模型了。我们已经完成了基础部分，所以从现在开始会更容易。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ot ou l"/></div></figure><p id="98eb" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这里没有什么新东西，这是一个简单的接口，有一个<code class="fe oa ob oc od b">Person</code>对象和两个字符串。</p><p id="f188" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们的视图模型的实现看起来有点复杂。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ot ou l"/></div></figure><p id="8c05" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们导入<code class="fe oa ob oc od b">Person</code>和<code class="fe oa ob oc od b">PersonViewModel</code>头文件。</p><p id="2d8c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">就像之前一样，我们调用<code class="fe oa ob oc od b">NSObject</code>的<code class="fe oa ob oc od b">init</code>方法，检查<code class="fe oa ob oc od b">self</code>是否被正确初始化。</p><p id="0655" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们初始化我们的<code class="fe oa ob oc od b">person</code>对象，然后调用<code class="fe oa ob oc od b"><a class="ae ky" href="https://developer.apple.com/documentation/foundation/nsstring/1497275-stringwithformat?language=objc" rel="noopener ugc nofollow" target="_blank">stringWithFormat:</a></code>函数，该函数接受一个格式字符串和一个逗号分隔的参数列表，并将其代入输出字符串。</p><p id="abb2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在我们的<code class="fe oa ob oc od b">nameText</code>被设置后，我们创建一个<code class="fe oa ob oc od b"><a class="ae ky" href="https://developer.apple.com/documentation/foundation/nsdateformatter" rel="noopener ugc nofollow" target="_blank">NSDateFormatter</a></code>实例，它是<code class="fe oa ob oc od b"><a class="ae ky" href="https://developer.apple.com/documentation/foundation/dateformatter" rel="noopener ugc nofollow" target="_blank">DateFormatter</a></code>的Objective-C版本。</p><pre class="kj kk kl km gt pa od pb pc aw pd bi"><span id="a243" class="na md it od b gy pe pf l pg ph">NSDateFormatter *dateFormatter = [[NSDateFormatter alloc] init];</span></pre><p id="eb12" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们的对象被称为<em class="mz"> dateFormatter </em>，它是一个<em class="mz">引用类型</em>，它的类型是<em class="mz"> NSDateFormatter </em>。我们用<code class="fe oa ob oc od b">alloc</code>告诉<code class="fe oa ob oc od b">NSDateFormatter</code>类为这个实例分配一块内存。然后我们用<code class="fe oa ob oc od b">init</code>初始化它。</p><p id="ece9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们在<code class="fe oa ob oc od b">dateFormatter</code>上调用<code class="fe oa ob oc od b">setDateFormat</code>函数。然后我们使用<code class="fe oa ob oc od b">stringFromDate</code>方法为我们的<code class="fe oa ob oc od b">birthdateText</code>属性设置文本。</p><p id="cf52" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">哼！我们已经完成了视图模型。让我们看看这在Swift中会是什么样子。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ot ou l"/></div></figure><p id="63e8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">以下是我们迄今为止所做的工作:</p><ul class=""><li id="9445" class="nm nn it lb b lc ld lf lg li pi lm pj lq pk lu nr ns nt nu bi translated">创建了一个人的模型，带有自定义的称呼、名字、姓氏和生日。</li><li id="5da2" class="nm nn it lb b lc nv lf nw li nx lm ny lq nz lu nr ns nt nu bi translated">我们为此人创建了一个视图模型。这将是视图和模型之间的唯一中介。</li><li id="bad1" class="nm nn it lb b lc nv lf nw li nx lm ny lq nz lu nr ns nt nu bi translated">视图模型用于将数据从我们的模型转换成可以呈现给用户的格式。我们将出生日期从<code class="fe oa ob oc od b">Date</code>转换为<code class="fe oa ob oc od b">String</code>。</li><li id="9165" class="nm nn it lb b lc nv lf nw li nx lm ny lq nz lu nr ns nt nu bi translated">我们正在熟悉Objective-C的基础知识。</li></ul></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="2172" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">景色</h1><p id="32d6" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">在现实世界的项目中，我们需要使用类似于Objective-C的<a class="ae ky" href="https://github.com/ReactiveCocoa/ReactiveObjC" rel="noopener ugc nofollow" target="_blank"> ReactiveObjC </a>或Swift的<a class="ae ky" href="https://github.com/ReactiveX/RxSwift" rel="noopener ugc nofollow" target="_blank"> RxSwift </a>或类似于<a class="ae ky" href="https://www.appcoda.com/understanding-key-value-observing-coding/" rel="noopener ugc nofollow" target="_blank">键值观察</a>的框架来绑定我们的数据。</p><p id="5f1d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">对于本文来说，深入研究这些细节就有些多余了，所以，现在，我们只是假设数据绑定的问题已经解决了。</p><p id="e7f0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果我们的视图控制器中有一个<code class="fe oa ob oc od b">nameLabel</code>和一个<code class="fe oa ob oc od b">birthdateLabel</code>,我们就应该这样做，这应该很清楚:</p><pre class="kj kk kl km gt pa od pb pc aw pd bi"><span id="ec8f" class="na md it od b gy pe pf l pg ph">- (void)viewDidLoad {</span><span id="b43f" class="na md it od b gy pl pf l pg ph">    [super viewDidLoad];</span><span id="a5f0" class="na md it od b gy pl pf l pg ph">    self.nameLabel.text = self.viewModel.nameText;           <br/>    self.birthdateLabel.text = self.viewModel.birthdateText;<br/>}</span></pre></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="9dec" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">最后的想法</h1><p id="dfec" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">我们在这篇文章中讨论了很多。如果你已经做到了这一步，那么现在你应该已经很好的理解了MVVM和Objective-C</p><p id="5c48" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果还没有完全理解，不要担心，这些都是很难的话题。您可能想重读这篇文章，或者看看下面的一些参考资料。</p><p id="0169" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">另外，不要忘记MVVM和Objective-C还有很多内容，本文只是一个介绍。</p><p id="c71c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在这篇文章中，我们开玩笑说我最初不喜欢Objective-C，一方面是因为我想让阅读变得更有趣。另一方面，我知道学习Objective-C可能会令人沮丧。你并不孤单。</p><p id="334d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">与往常一样，情况比这更复杂，这种语言有积极的方面，但可读性不是其中之一。</p><p id="821e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">感谢您花时间阅读我的文章。如果你有任何想法、问题或建议，请在下面的评论中留下。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="1181" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">资源</h1><ul class=""><li id="a9c2" class="nm nn it lb b lc mu lf mv li no lm np lq nq lu nr ns nt nu bi translated"><a class="ae ky" href="https://www.objc.io/issues/13-architecture/mvvm/" rel="noopener ugc nofollow" target="_blank">MVVM简介</a></li><li id="76e2" class="nm nn it lb b lc nv lf nw li nx lm ny lq nz lu nr ns nt nu bi translated"><a class="ae ky" href="https://www.appcoda.com/mvvm-vs-mvc/" rel="noopener ugc nofollow" target="_blank">MVVM简介:使用MVVM设计模式重构MVC应用</a></li><li id="8c52" class="nm nn it lb b lc nv lf nw li nx lm ny lq nz lu nr ns nt nu bi translated"><a class="ae ky" href="https://www.raywenderlich.com/34-design-patterns-by-tutorials-mvvm" rel="noopener ugc nofollow" target="_blank">通过教程设计模式:MVVM </a></li><li id="0956" class="nm nn it lb b lc nv lf nw li nx lm ny lq nz lu nr ns nt nu bi translated">【Swift开发人员的目标-C</li><li id="0b7e" class="nm nn it lb b lc nv lf nw li nx lm ny lq nz lu nr ns nt nu bi translated"><a class="ae ky" href="https://stackoverflow.com/questions/652186/why-do-objective-c-files-use-the-m-extension/652266#652266" rel="noopener ugc nofollow" target="_blank">为什么Objective-C文件使用。m分机？</a></li><li id="fcfe" class="nm nn it lb b lc nv lf nw li nx lm ny lq nz lu nr ns nt nu bi translated"><a class="ae ky" href="https://www.oreilly.com/library/view/programming-ios-6/9781449365783/ch04s02.html" rel="noopener ugc nofollow" target="_blank">接口和实现</a></li><li id="dc0f" class="nm nn it lb b lc nv lf nw li nx lm ny lq nz lu nr ns nt nu bi translated"><a class="ae ky" href="https://teamtreehouse.com/community/in-objective-c-whats-the-difference-between-instance-and-class-methods-and-how-do-you-switch-between-the-two" rel="noopener ugc nofollow" target="_blank">实例和类方法的区别</a></li></ul></div></div>    
</body>
</html>