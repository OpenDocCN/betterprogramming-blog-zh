# 在 Rust 中实现多线程共享内存

> 原文：<https://betterprogramming.pub/easy-multi-threaded-shared-memory-in-rust-57344e9e8b97>

## 让共享数据设计模式发挥作用

![](img/9cc21a040df851b9ba698df14789fe3a.png)

本文是与在 Raspberry Pi 上运行的 Rust 中构建无线恒温器相关的系列文章中的第三篇——尽管这篇文章与 Raspberry Pi 关系不大，而与任何多线程应用程序更相关。在创建我的应用程序时，我实现了一个简单而有效的设计来控制对共享内存的多线程访问。您可以在这里找到以前的文章:

*   第一篇，[树莓皮无线温控器在生锈](https://medium.com/p/45a5d35196cf)
*   第二个，[横编立易](https://medium.com/p/e30fcb233fef)。

下面我也有一些代码片段，但是你可以在 [GitHub](https://github.com/mikehentges/thermostat-pi) 上找到完整的代码库。

# 首先，背景故事

设计多线程应用程序时，一个核心考虑因素是不同的线程如何共享数据。总有一些东西是线程共享的——毕竟，您正在剥离线程来处理一个共享的问题。如果没有别的，配置数据或数据库连接池必须共享。解决这个问题有两种主要方法:

1.  消息传递——线程之间的通道允许在它们之间发送和接收数据。消息传递是 Golang 更喜欢的机制，正如 Golang 文档所述:“不要通过共享内存进行通信；而是通过交流来分享记忆。”Rust 支持创建通道；你可以在 Rust Book 关于[消息传递](https://doc.rust-lang.org/book/ch16-02-message-passing.html)的章节中找到更多信息。
2.  共享状态—标识为共享状态的一组数据。每个线程通过线程安全保护机制访问一个共享数据区——通常是一个`Mutex`。数据上的锁允许您安全地访问数据，根据需要读取或更新数据，然后锁被释放。一次只有一个线程可以读取或写入数据。Rust Book 的[共享状态](https://doc.rust-lang.org/book/ch16-03-shared-state.html)部分描述了这些机制。

这两种方法都有效，Rust 在标准库中对这两种机制都有很好的支持。要在它们之间进行选择，请考虑以下因素:

1.  访问模式是什么？线程会主要读数据，主要写数据，还是两者都有？
2.  如何避免死锁？避免死锁是多线程应用程序的主要关注点——没有什么比有一堆线程可用来工作更糟糕的了，它们都被困在等待其他线程离开。
3.  性能。虽然为了性能而过度设计是一种常见的错误，但是对您的解决方案的性能需求有一些了解是非常重要的。我是这条规则的忠实粉丝:让解决方案尽可能简单，但不要再简单了。

我决定为我正在创建的应用程序使用共享状态方法。这个决定还意味着我的工作线程将通过轮询工作——定期检查，而不是接收外部消息。这是让我得出这个结论的原因:

1.  我有三条主线。一个是 web 界面，允许读/写共享状态(获取温度、获取恒温器设置、设置恒温器设置)。根据定义，web 界面是计划外活动的创建者——事情的发生基于外部客户端的动作，不受应用程序的控制。第二，一对后台工作线程对应用程序的环境做出反应。第一个读取温度传感器，第二个计算恒温器是否应该打开或关闭，并控制物理继电器来实现这一点。恒温器在一个单独的线程中，因为当温度超过阈值或者我们从 web 界面接收到新的恒温器设置时，它可以打开/关闭。
2.  我不必担心只有三个线程的争用(假设 web 界面上只有一个外部客户机)。简单的共享状态方法不会遇到太多线程试图同时访问锁的问题。
3.  用于确定恒温器状态的逻辑具有时间成分。我们不希望频繁、短暂的开关，这将冲击熔炉。在切换到另一个状态之前，我们强制规定恒温器打开或关闭的最短时间。准确地对一个信息(温度读数或恒温器数值的变化)做出反应需要知道恒温器变化后有多长时间了。

基于这些需求，共享状态是有意义的。我的设计强制执行低线程数，所以争用不是问题(共享状态方法的常见问题)。我需要记录时间，所以总是需要一些状态数据。在同一应用程序中实现两种不同的状态数据机制会增加复杂性。由于每个线程都做自己的事情，并独立地获取/设置共享状态，我们将每个线程与其他线程隔离开来。这一选择导致了更简单的整体应用程序设计。

但是，当我在[共享状态](https://doc.rust-lang.org/book/ch16-03-shared-state.html)、
上查看 Rust Book 的内容时，管理每个线程的访问的复杂性似乎令人生畏。另外，在应用程序中散布线程锁定代码使它变得一团糟——我的好的单一用途函数现在有了互斥锁定逻辑。此外，当通过`Mutex`锁访问数据时，跨线程处理 Rust 的借用检查器被证明是具有挑战性的。

# 更简单的方法

为了便于管理，我使用了以前在 C++项目中使用过的方法——将共享数据封装到一个单独的类中，并将所有的`Mutex`逻辑推送到该类中。Rust 没有类，但是一些结构做到了。

我创建了一个结构，将所有共享的状态数据保存在一个地方。然后我可以处理对这个结构的单个引用，而不是单独管理每个数据元素。

然后我们定义一个包含一个`Arc`指针的结构，这个指针是一个指向保护我们共享数据结构的`Mutex`的原子引用计数指针。我们使用这个结构来控制对共享数据的访问。

我们将制作这个指针的许多副本——它们都指向我们的互斥体，这是我们获得共享内存空间的方法。我们通过为`AccessSharedData` 定制`Clone()`方法来做到这一点——看起来如下:

为了使用它，我们首先创建我们的`SharedData`结构的一个实例(上面没有显示简单的`.new()`方法，但是很简单)。

然后，我们初始化一个`AccessSharedData`的实例。

然后我们给每个线程一个`spawn()`结构的克隆副本。克隆调用创建了一个`Arc`指针的副本，然后我们将它移动到新线程中。一个类似的方法将一个`AccessSharedData`结构的克隆传递给 actix_web `HttpServer::new()`方法，因此它在 HTTP 客户端处理程序中也是可用的。

现在每个人都有了一个`Arc`指针的副本，我们需要创建一个方法来使用它读/写我们的共享数据结构。我们的结构的每个成员都有一组简单的 getter/setter 来处理获取锁、获取/设置数据以及自动释放锁的任务。通过将这个逻辑放在 get/set 周围，并利用方法的结尾作为范围边界来强制释放锁，我们获得了对数据访问的控制。

当每个 get/set 函数返回时，锁被释放。这种方法还意味着对结构的访问不可能出现死锁——所有东西都被锁定并立即释放，并禁止任何其他东西挡路。有了所有的锁定机制，在应用程序的其余部分使用共享数据就变得简单了。

# 概括起来

这种策略是封装的最好体现。应用程序代码使用对方法的直接调用，在需要时获取/设置共享数据元素。在幕后，我们管理互斥体的锁定，使该访问是线程安全的，并且不会出现死锁。Rust 的借用检查器非常高兴我们不允许对共享数据的直接共享可变引用。您可以很容易地扩展这种设计模式来实现更健壮的访问模式。

将锁定逻辑放在 getter/setter 中使我们的共享数据结构能够隐藏多线程访问的复杂性——就像标准库对线程安全集合所做的那样。使用 Arc 的克隆使得在每个线程中获得共享内存结构的句柄成为可能。这两个概念是使我们的易共享数据设计模式工作的核心思想。