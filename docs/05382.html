<html>
<head>
<title>Functional Patterns in Java</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Java中的函数模式</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/functional-patterns-in-java-b2b781f84124?source=collection_archive---------0-----------------------#2020-07-05">https://betterprogramming.pub/functional-patterns-in-java-b2b781f84124?source=collection_archive---------0-----------------------#2020-07-05</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="4b76" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">如何在Java函数式编程中使用不同的设计模式</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/882c5a2bcd2ee4ea1c08b993bd5df467.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*9dWmOZwtgpTCM0tVVA9BUQ.jpeg"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">阿德里安·斯旺卡在<a class="ae ky" href="https://unsplash.com/?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</p></figure><p id="72f5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">最近，我们通过我的文章“<a class="ae ky" href="https://medium.com/swlh/a-new-java-functional-style-f522dad40d32" rel="noopener">一种新的函数式Java风格</a>”和“<a class="ae ky" href="https://codeburst.io/mastering-the-new-functional-java-2eb2f7472079" rel="noopener" target="_blank">掌握新的函数式Java </a>”开始了Java函数式编程之旅</p><p id="a1d1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">既然我们对函数式编程和Java带给我们的东西有了基本的了解，我想是时候看看我们如何应用它来改进我们现有的代码了。</p><p id="aaec" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">Java中函数式编程的引入为我们编写代码的方式带来了新的可能性。我们现在有了更大的灵活性。我们将浏览不同的常见设计模式，并展示函数式编程如何帮助改进它们——使它们更简洁、更易读、更易维护。</p><p id="a445" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">那我们开始吧！</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="4ba0" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">介绍</h1><p id="a26d" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">一个<a class="ae ky" href="https://en.wikipedia.org/wiki/Software_design_pattern" rel="noopener ugc nofollow" target="_blank"> <em class="mz">设计模式</em> </a>是我们通常用来解决一个常见问题的解决方案，遵循一些最佳实践指南。</p><p id="79c1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">它们的主要目的通常是提高代码的可维护性和可读性，保证如果我们遵循给定的模式，一些已知的问题将被避免。</p><p id="e4e4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">有多种设计模式，通常它们被分成不同的组:</p><h2 id="449e" class="na md it bd me nb nc dn mi nd ne dp mm li nf ng mo lm nh ni mq lq nj nk ms nl bi translated"><strong class="ak">行为模式</strong></h2><p id="b789" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">这些标识了对象之间的通用通信模式。一些最流行的行为模式是<em class="mz">策略、访问者、责任链、模板方法、观察者、迭代器、</em>等等。</p><h2 id="92ef" class="na md it bd me nb nc dn mi nd ne dp mm li nf ng mo lm nh ni mq lq nj nk ms nl bi translated"><strong class="ak">创作模式</strong></h2><p id="8896" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">这些涉及不同的对象创建机制。最流行的有<em class="mz">工厂、建造者、原型、工厂方法、</em>等。</p><h2 id="9d57" class="na md it bd me nb nc dn mi nd ne dp mm li nf ng mo lm nh ni mq lq nj nk ms nl bi translated"><strong class="ak">结构模式</strong></h2><p id="f35f" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">这些方法确定了组合对象的方式，以使增强的对象服务于某个目的。其中一些是<em class="mz">适配器、桥、代理、装饰器、</em>等。</p><p id="8596" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们不打算详细讨论所有的问题，因为这需要很长时间；相反，我们将挑选一些最重要的模式，看看我们过去实现它们的方式，以及我们现在如何通过使用函数式编程来改进它们。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="480d" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">工厂方法模式</h1><p id="d8ab" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">在<a class="ae ky" href="https://en.wikipedia.org/wiki/Factory_method_pattern#:~:text=In%20class%2Dbased%20programming%2C%20the,object%20that%20will%20be%20created." rel="noopener ugc nofollow" target="_blank"> <em class="mz">工厂方法模式</em> </a>中，我们为客户端提供了一个创建对象实例的接口，隐藏了如何创建对象的实现细节。</p><p id="8c61" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在Java引入函数式编程之前，这种模式可以通过使用<code class="fe nm nn no np b">if</code>条件、<code class="fe nm nn no np b">switch</code>用例甚至<code class="fe nm nn no np b">.</code>来实现(顺便说一下，请避免使用<code class="fe nm nn no np b">switch</code>语句)。我最喜欢的实现是使用Java的<code class="fe nm nn no np b"><a class="ae ky" href="https://docs.oracle.com/javase/8/docs/api/java/lang/Enum.html" rel="noopener ugc nofollow" target="_blank">enum</a></code>；然而，如果我们需要将一个依赖注入到我们正在创建的组件中，这并不总是可能的。</p><p id="a29b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们以一种非功能的方式来看看这种模式的实现:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi nq"><img src="../Images/8300969877ca466848c90a20da99ed44.png" data-original-src="https://miro.medium.com/v2/resize:fit:1014/0*iscF4iPNFey2lqZO"/></div></figure><p id="85e1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">正如我们所看到的，我们的工厂方法接受了我们想要实例化的类型和一个<code class="fe nm nn no np b">VehicleColor</code>，它将被用来实例化一辆颜色的汽车。<br/>我们将如何从一个假设的客户端使用我们的实现？</p><pre class="kj kk kl km gt nr np ns nt aw nu bi"><span id="c098" class="na md it np b gy nv nw l nx ny">Vehicle redCar = VehicleFactory.instanceOfType(VehicleType.CAR, VehicleColor.RED);</span></pre><p id="ec2e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">看起来没那么糟糕，但是这个实现有什么问题呢？</p><ul class=""><li id="43f4" class="nz oa it lb b lc ld lf lg li ob lm oc lq od lu oe of og oh bi translated">使用<code class="fe nm nn no np b">if</code>条件检查类型通常会导致代码重复</li><li id="34d2" class="nz oa it lb b lc oi lf oj li ok lm ol lq om lu oe of og oh bi translated">添加新类型意味着必须记住我们必须添加一个新的<code class="fe nm nn no np b">if</code>条件</li><li id="e96d" class="nz oa it lb b lc oi lf oj li ok lm ol lq om lu oe of og oh bi translated">我们必须抛出<code class="fe nm nn no np b">IllegalArgumentException</code>，因为我们可能会忘记处理一个新类型</li><li id="1d15" class="nz oa it lb b lc oi lf oj li ok lm ol lq om lu oe of og oh bi translated">它比函数方法更难理解，我们很快就会看到</li><li id="21e8" class="nz oa it lb b lc oi lf oj li ok lm ol lq om lu oe of og oh bi translated">它比函数式方法略显冗长</li></ul><p id="267c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">那么，我们如何利用Java函数，以更简洁的方式实现这一点呢？让我们来看看这个:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi on"><img src="../Images/db0bac0c96c5377ebdcefb97fc7ed004.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*0P37v3HwShybRiZo"/></div></div></figure><p id="577c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">您会注意到，我们重用了现有的<code class="fe nm nn no np b">VehicleType</code>枚举，并为其添加了一个<code class="fe nm nn no np b">factory</code>函数；在我们的例子中。我们为实现的每个构造函数传递方法引用。乍一看，我们可以很快注意到这个类更干净、更易读，减少了创建给定类型的实例所需的混乱。</p><p id="5346" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">此外，enum中的每个元素都被强制实现其工厂方法，所以我们不可能忘记为最近添加的类型添加工厂！Java编译器在这里帮助我们，指导我们在添加新类型时编写所需的更改；我们这边不需要做额外的脑力劳动。</p><p id="6451" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在让我们看看如何从客户端使用这个实现:</p><pre class="kj kk kl km gt nr np ns nt aw nu bi"><span id="ee9b" class="na md it np b gy nv nw l nx ny">Vehicle redCar = VehicleType.CAR.factory.apply(VehicleColor.RED);</span></pre><p id="4dba" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">很简单，对吧？正如我们所看到的，这种实现比非功能方法有一些优势。我真的希望你喜欢它，并开始经常使用它。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="0a14" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">模板方法模式</h1><p id="e958" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated"><em class="mz">模板方法</em>是一种模式，它允许我们为算法定义一些公共步骤。然后，子类用特定步骤的特定行为覆盖其中的一些步骤。</p><p id="da65" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">那么我们之前是如何用Java编写这个模式的呢？嗯，大多数时候，我们不得不使用一个<a class="ae ky" href="https://docs.oracle.com/javase/tutorial/java/IandI/abstract.html" rel="noopener ugc nofollow" target="_blank">抽象</a>类，并且不得不为每个可能被覆盖的子步骤定义抽象方法。我不得不承认，我过去常常这样做，可能是因为这是唯一的办法，但现在我认为这是一种非常糟糕的做法。</p><p id="48bd" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们来看一个过去的例子:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi oo"><img src="../Images/c9a7ba6f1023926b7bf4e574b429e7ca.png" data-original-src="https://miro.medium.com/v2/resize:fit:1312/0*xlS4UECUkJIKdz-v"/></div></figure><p id="2369" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这是一个非常简单的例子，但基本上每辆车都会打印出在启动前需要做的初始检查；为了做到这一点，每个子类都必须覆盖<code class="fe nm nn no np b">preStartCheck</code>抽象方法。例如，如果我修改类来扩展<code class="fe nm nn no np b">AbstractVehicle</code>，它将迫使我覆盖<code class="fe nm nn no np b">preStartCheck</code>方法。</p><p id="7b3f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">例如，总线的这些步骤可以是:</p><pre class="kj kk kl km gt nr np ns nt aw nu bi"><span id="879c" class="na md it np b gy nv nw l nx ny">@Override <br/>void preStartCheck() { <br/>  System.out.println("Check if every new passenger has paid for their tickets"); <br/>  System.out.println("Check if every passenger is seated"); <br/>}</span></pre><p id="c4c3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这种方式并不理想，因为我们必须创建一个抽象类，并且我们的每个子类都必须扩展这个抽象类。它很乱，很难理解，并且添加了大量与它实际做的不相称的混乱。根据经验，我建议避免在Java中扩展类——从长远来看，这会让你的生活更轻松。</p><p id="2d9e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">那么还有什么选择呢？让我们将我们的<code class="fe nm nn no np b">start</code>方法移动到接口，我们将利用<code class="fe nm nn no np b">default</code>修饰符在接口中提供我们方法的默认实现。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi op"><img src="../Images/18a69c33ce1676bf399f5b9ac1b35974.png" data-original-src="https://miro.medium.com/v2/resize:fit:1316/0*Lu7D7HaYB5uo9UdW"/></div></figure><p id="22a7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如你所见，我们现在接受一个<code class="fe nm nn no np b"><a class="ae ky" href="https://docs.oracle.com/javase/8/docs/api/java/util/function/Consumer.html" rel="noopener ugc nofollow" target="_blank">Consumer</a></code>来为我们的类提供<code class="fe nm nn no np b">preStartChecks</code>。这是一个很傻的例子，所以有些东西看起来会有点奇怪，比如<code class="fe nm nn no np b"><a class="ae ky" href="https://docs.oracle.com/javase/8/docs/api/java/lang/Void.html" rel="noopener ugc nofollow" target="_blank">Void</a></code>的一个<code class="fe nm nn no np b">Consumer</code>的使用。现在不要太担心它——这只是举例说明如何使用Java函数注入行为。</p><p id="3562" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">那么一旦我们有了这些，我们如何注入我们的逻辑呢？让我们来看看:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi oq"><img src="../Images/c15c65582079a020e354e4733568fe53.png" data-original-src="https://miro.medium.com/v2/resize:fit:1176/0*IZlrevGqdIoEgfTI"/></div></figure><p id="572c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果我们运行我们的代码，它会打印出我们期望的结果:</p><pre class="kj kk kl km gt nr np ns nt aw nu bi"><span id="dc88" class="na md it np b gy nv nw l nx ny">Check if every new passenger has paid for their tickets <br/>Check if every passenger is seated <br/>Bus starting...</span></pre><p id="1ddf" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">基本上就是这样，我们已经通过在我们的接口中写两行代码实现了完全相同的行为。以前，我们需要一个抽象类和一个抽象方法，我们的每个类都被迫实现抽象方法。这个解决方案更简单、更干净、更易读——你同意吗？我希望你能！</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="63af" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">构建器模式</h1><p id="302c" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated"><a class="ae ky" href="https://en.wikipedia.org/wiki/Builder_pattern#:~:text=The%20builder%20pattern%20is%20a,Gang%20of%20Four%20design%20patterns." rel="noopener ugc nofollow" target="_blank"> <em class="mz">构建器模式</em> </a>的主要目的是提供一种分步构建对象的方法，将构建逻辑与其表示分离开来。</p><p id="be01" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">创建构建器的非功能性方法——虽然非常健壮并且非常容易被客户端使用——有一个问题:它非常冗长。</p><p id="bf9c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">那么在这种情况下，函数式方法如何帮助我们呢？通过使用函数式方法，我们将看到如何大幅减少实现构建器所需的代码量。</p><p id="e094" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们首先来看看它以前是什么样子的；从客户的角度来看，你可能会喜欢它的表现力，但你不会喜欢它的冗长。我们要恢复我的文章“<a class="ae ky" href="https://medium.com/dev-genius/please-stop-the-java-optional-mess-2889dc4f5f27" rel="noopener">请停止Java可选乱七八糟的例子！</a>“看看我们如何将它转变成实用的风格。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="or os l"/></div></figure><p id="61ac" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果您还记得那篇文章，从客户端使用那个类是非常容易的；例如，我们可以这样做:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="or os l"/></div></figure><p id="f5b9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">那很好，不是吗？因此，在这种情况下，我们唯一的问题是类的冗长——让我们看看函数式Java能有什么帮助。</p><p id="d35b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">首先，嵌入在我们的<code class="fe nm nn no np b">Customer</code>类中的构建器将被转换成这样:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ot"><img src="../Images/da345d0997558f7640a4d54da2644bd9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*iay-KNrNjHUDxEAF"/></div></div></figure><p id="d2e2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如您所见，现在我们接受了一个<code class="fe nm nn no np b">Consumer</code>——并且我们只提供了一个方法，而不是多个方法！如果我们的对象有许多字段，这是非常有益的。</p><p id="ae5c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在让我们从客户的角度来看一下如何使用这种实现:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ou"><img src="../Images/a05119b96d772ae8ae17804e9459ea89.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*53FAW-vUsAAH7AJn"/></div></div></figure><p id="a0bb" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">太棒了，对吧？相反，我们可以在一个<code class="fe nm nn no np b">Consumer</code>中指定我们所有的字段，使我们的代码更加简洁。</p><p id="5107" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在让我们来看一个不同的模式:策略！</p><h1 id="a6ac" class="mc md it bd me mf ov mh mi mj ow ml mm jz ox ka mo kc oy kd mq kf oz kg ms mt bi translated">战略模式</h1><p id="2072" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated"><a class="ae ky" href="https://en.wikipedia.org/wiki/Strategy_pattern" rel="noopener ugc nofollow" target="_blank"><em class="mz">策略模式</em> </a>可能是应用最广泛的设计模式之一；它通常用在我们必须根据一些属性或输入选择不同行为的每种情况下。</p><p id="f7dd" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">用老方法编写策略模式的唯一问题是，在许多情况下，我们必须创建大量的类和样板代码；当这些类包含复杂的逻辑时，这可能是有意义的，但是在许多情况下，它们太简单了，甚至不能成为一个类！</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ou"><img src="../Images/74ec04e8300e502af2fa18c393670738.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*Q-SKvth6Uvxetatz"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">由<a class="ae ky" href="https://unsplash.com/@kaleidico?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">万花筒</a>在<a class="ae ky" href="https://unsplash.com/s/photos/whiteboard?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</p></figure><p id="996a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">通过一个例子可以更容易地理解这一点；在这个例子中，我们将构建一个<code class="fe nm nn no np b">DeliveryPriceCalculator</code>，它将取决于客户已经支付的计划。</p><p id="a28c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">首先，这些是现有的计划:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi pa"><img src="../Images/c1642fbe18b8f603ee15983dac91811e.png" data-original-src="https://miro.medium.com/v2/resize:fit:612/0*Yo8mVeMZnDimUGqM"/></div></figure><p id="d10d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">基于现有的计划，我们必须为每个计划创建一个实现；所以我们需要一个<code class="fe nm nn no np b">DeliveryPriceCalculator</code>接口和这个接口的三个实现:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi pb"><img src="../Images/ed5bde5e281986cde6515f337ded64ad.png" data-original-src="https://miro.medium.com/v2/resize:fit:1256/0*kxM5hwTzL8tBV9bo"/></div></figure><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ou"><img src="../Images/b2b2fbfeccd5e74942acfdb77760df62.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*6lqY4qiZwpXyOkKP"/></div></div></figure><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ou"><img src="../Images/e130b46c5fb94fd4256377967e01d330.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*J7uwejeAinQNuz99"/></div></div></figure><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ou"><img src="../Images/53e6608432c742705866b93c1b95b90b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*XHRd0-T3BYv45LMi"/></div></div></figure><p id="b054" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">实现非常简单。在某些情况下，顾客将被收取商品价格的一小部分，外加一美元；对于那些为商业计划付费的客户，交付价格仅为1美元。</p><p id="dca8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">那么我们需要什么来实例化我们需要的类呢？我们需要一个工厂，它已经以我们之前在查看构建器模式时展示的相同的旧式方式实现了；因此，我们将省略它的实现。这个例子的代码可以在我的GitHub账户中找到<a class="ae ky" href="https://github.com/theboreddev/functional-patterns" rel="noopener ugc nofollow" target="_blank">这里</a>，如果你需要的话。</p><p id="5625" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们看看客户将如何使用它:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="or os l"/></div></figure><p id="57c1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">所以我们可以再次看到，这种模式的主要问题是它的冗长——我们为如此简单的东西制造了不必要的混乱。我们真的需要那些课程吗？我们不能把这个说得更简单、更简洁吗？<br/>让我们看看函数式编程是如何拯救我们的！</p><p id="4384" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们将使用Java函数嵌入所有这些逻辑，而不是为每个实现创建一个新的类。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ou"><img src="../Images/1c3ed19716b32766f3af314240aa034d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*miu3GjcrQfsFET6m"/></div></div></figure><p id="05cd" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">请注意，在这种情况下，我们只需要一个enum来实现整个策略模式。通过提供一个函数，每个计划都必须实现自己的交货价格计算器。这在我看来非常简单明了，你不同意吗？</p><p id="8123" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">此外，客户端使用这种模式的方式变得更加简单:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="or os l"/></div></figure><p id="96fa" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">只有一句台词——现在它真的很有表现力！真的希望你喜欢这个图案；在我看来，这显然有助于减少Java代码中的混乱和样板代码。</p><p id="3e84" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在让我们看看最后一个例子:责任链模式！</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="be65" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">责任链模式</h1><p id="d7ba" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">当我们必须按照给定的顺序对一个对象进行不同的操作时，这种模式非常有用，就像我们在连锁工厂中所做的一样。</p><p id="a80b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">实现这种模式的非功能性方法需要创建不同的类，与策略模式类似。这曾经有点冗长，并且给我们的代码增加了不必要的复杂性。</p><p id="0be7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">使用非功能性编程看起来怎么样？</p><p id="029c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我必须事先声明，使用非功能方法很难获得正确的责任链模式；我们的例子非常非常简单，但仍然很容易出错，很难做对。为了实现这个模式，我们需要什么？</p><p id="85d8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们将实现我认为是这种模式的一个好例子:一台洗车机。首先，我们需要一个抽象类。是的，对不起…我们需要一个抽象类，所有的子类都需要扩展它。记得以后在Java里要避免这种情况——没带来什么好处！</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi pc"><img src="../Images/b2ef3c77a280d49867b9ba876bc85a20.png" data-original-src="https://miro.medium.com/v2/resize:fit:784/0*lnXoxUjyHyxtklIS"/></div></figure><p id="a437" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在，为了简洁起见，我将只包括其中的一个实现来展示它们的样子:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi pd"><img src="../Images/cc04776ddc632ed7ee490170b958f7f2.png" data-original-src="https://miro.medium.com/v2/resize:fit:850/0*Z1sjltndl-brPDKY"/></div></figure><p id="9a2a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如你所见，在我们链条的每一步，如果有下一步，我们会打电话；当它到达链条的末端时，它会停在那里。我们将如何从我们的客户那里使用它？</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="or os l"/></div></figure><p id="20d9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果我们执行这段代码，我们将看到正在执行的每个步骤:</p><pre class="kj kk kl km gt nr np ns nt aw nu bi"><span id="dcd0" class="na md it np b gy nv nw l nx ny">Car state transitioned to INITIAL <br/>Car state transitioned to INITIAL_WASH <br/>Car state transitioned to SOAP <br/>Car state transitioned to RINSED <br/>Car state transitioned to POLISHED <br/>Car state transitioned to DRIED <br/>Final car state is DRIED</span></pre><p id="b083" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">所以这个实现是可行的，但是它非常复杂和冗长。让我们看看函数式编程在这里能有什么帮助！</p><p id="cc1e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">使用这种方法我们可以节省多少代码，您会对此印象深刻。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi pe"><img src="../Images/00a920f4334c90bd629e375d630dd416.png" data-original-src="https://miro.medium.com/v2/resize:fit:948/0*pE_r2j3-keSGFsOi"/></div></figure><p id="4464" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">就是这样！印象深刻吧。在这个例子中，我们可以利用Java <code class="fe nm nn no np b"><a class="ae ky" href="https://docs.oracle.com/javase/8/docs/api/java/util/function/Function.html" rel="noopener ugc nofollow" target="_blank">Function</a></code>中的<code class="fe nm nn no np b"><a class="ae ky" href="https://docs.oracle.com/javase/8/docs/api/java/util/function/Function.html#andThen-java.util.function.Function-" rel="noopener ugc nofollow" target="_blank">andThen</a></code>方法，只使用Java内置函数创建一个函数链。实际上，不需要任何定制类。我们已经将我们的模式减少到几行，现在也更难出错了。</p><p id="47c5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们应该做的一个改进是将这些函数提取到一个方法中——这样，您就可以表达该函数负责什么。例如，我们可以用一个<code class="fe nm nn no np b">soapStep</code>方法来创建这个函数。</p><p id="b6fa" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">因此，在应用了重构之后，我们的函数链将如下所示:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi pf"><img src="../Images/3ee0eb1290ec172e5f6065f0f670d89b.png" data-original-src="https://miro.medium.com/v2/resize:fit:710/0*d1kiDquPyM7pxtJG"/></div></figure><p id="6686" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这样好多了吧？现在，我们的函数链更容易阅读，更有意义，并且在那些函数具有复杂逻辑的情况下，它们可以很容易地进行单元测试。</p><p id="4c6c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">原来如此！我希望您喜欢我们的例子，并且喜欢应用函数式编程来获得更简洁、可读性更好的代码。</p><p id="755b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果你仍然难以理解Java Lambdas和函数式编程，我建议你阅读“<strong class="lb iu"><em class="mz">Java中的函数式编程:利用Java 8 Lambda表达式的力量</em></strong>”；可以在下面的<a class="ae ky" href="https://geni.us/Bdoyif8" rel="noopener ugc nofollow" target="_blank">链接</a>在亚马逊上购买。</p><p id="d5f3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">另外，请记住你可以在GitHub <a class="ae ky" href="https://github.com/theboreddev/functional-patterns" rel="noopener ugc nofollow" target="_blank">这里</a>找到所有这些例子。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="8c2d" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">结论</h1><p id="a831" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">函数式编程是命令式方法的一大飞跃。我以前也去过那里，我知道吸收概念并使我们的编码技能适应这种新方法需要时间；然而，一旦你很好地掌握了它，你就会看到它能给你的代码带来的所有好处，以及它是如何提高你的生产率的。</p><p id="b065" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">Java过去的许多批评者指出了该语言的冗长和所有需要生成的样板代码和混乱；事实上，我认为他们在很多方面都是对的，但我也认为Java最近的变化正在缩小这个差距，正如我们在这些例子中所看到的。</p><p id="dc52" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">就我个人而言，如果Java继续带来这些变化，让我们的代码适应这些新时代，我认为Java的前景是光明的。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ou"><img src="../Images/f5714817325d34d4455ef1646eae4667.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*_AS-0es1eloZ-O65"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">由<a class="ae ky" href="https://unsplash.com/@grakozy?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">格雷格·拉科齐</a>在<a class="ae ky" href="https://unsplash.com/s/photos/hope?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</p></figure><p id="d6b8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">所以这些都是我写的！我真的希望你喜欢读这篇文章。我希望很快能再见到你。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><div class="kj kk kl km gt pg"><a href="https://medium.com/swlh/grouping-elements-with-java-streams-32c967309d94" rel="noopener follow" target="_blank"><div class="ph ab fo"><div class="pi ab pj cl cj pk"><h2 class="bd iu gy z fp pl fr fs pm fu fw is bi translated">用Java流对元素进行分组</h2><div class="pn l"><h3 class="bd b gy z fp pl fr fs pm fu fw dk translated">Java Streams引入的最有趣的特性之一是能够通过……</h3></div><div class="po l"><p class="bd b dl z fp pl fr fs pm fu fw dk translated">medium.com</p></div></div><div class="pp l"><div class="pq l pr ps pt pp pu ks pg"/></div></div></a></div><div class="pv pw gp gr px pg"><a href="https://medium.com/swlh/a-new-java-functional-style-f522dad40d32" rel="noopener follow" target="_blank"><div class="ph ab fo"><div class="pi ab pj cl cj pk"><h2 class="bd iu gy z fp pl fr fs pm fu fw is bi translated">一种新的Java函数风格</h2><div class="pn l"><h3 class="bd b gy z fp pl fr fs pm fu fw dk translated">JDK 8发布已经有一段时间了，它为Java语言带来了许多新特性；其中最…</h3></div><div class="po l"><p class="bd b dl z fp pl fr fs pm fu fw dk translated">medium.com</p></div></div><div class="pp l"><div class="py l pr ps pt pp pu ks pg"/></div></div></a></div><div class="pv pw gp gr px pg"><a href="https://codeburst.io/mastering-the-new-functional-java-2eb2f7472079" rel="noopener follow" target="_blank"><div class="ph ab fo"><div class="pi ab pj cl cj pk"><h2 class="bd iu gy z fp pl fr fs pm fu fw is bi translated">掌握新的函数式Java</h2><div class="pn l"><h3 class="bd b gy z fp pl fr fs pm fu fw dk translated">介绍</h3></div><div class="po l"><p class="bd b dl z fp pl fr fs pm fu fw dk translated">codeburst.io</p></div></div><div class="pp l"><div class="pz l pr ps pt pp pu ks pg"/></div></div></a></div></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><p id="a968" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">非常感谢您的阅读！</p></div></div>    
</body>
</html>