# 单元测试应该超越接口

> 原文：<https://betterprogramming.pub/unit-tests-should-go-beyond-interfaces-1bab0d9503fb>

## “测试您的接口”是不完整的。以下是如何安全地超越它

![](img/41cdb0b5deb1fe03af43db71f2965aae.png)

照片由[迈克尔·罗斯纳-海曼](https://unsplash.com/@michaelrosnerhyman?utm_source=unsplash&utm_medium=referral&utm_content=creditCopyText)在 [Unsplash](https://unsplash.com/s/photos/obstacle?utm_source=unsplash&utm_medium=referral&utm_content=creditCopyText) 拍摄

有一个软件工程的真理，你应该测试你的接口。该规则分为几个组成部分，规定您应该:

*   尽可能地限制对一个类、方法或例程的访问——如果可能，将访问控制设置为`private`,需要时设置为`internal`,尽可能少地设置为`public`。
*   避免仅仅为了满足单元测试的愿望而放松访问控制。

虽然可靠的访问控制确实很重要，但是“测试您的接口”这一老生常谈是不完整的，以至于弊大于利。它迫使我们编写集成测试，而不是单元测试。为了理解其中的原因，我们将着眼于它试图达成的妥协，看到其方法的缺陷，并评估其他可能的权衡。

我们必须想办法安全地将你的内部功能公开为带有接口的助手，并对它们进行单元测试。

TL；DR:随意使用非私有、纯、`static`功能。

# 编程语言差异

这里描述的问题是具有严格访问控制语义的语言所特有的。不具备这一点的语言或者允许运行时反射来改变字段的访问控制语义的语言允许您以不同的方式进行单元测试。

然而，这里描述的基本概念是语言不可知的。(即使在不太严格的环境中，测试您的内部实现而不是它们的行为也是一个非常糟糕的想法。)

在这里，我们将使用[一段 Swift 代码，作为用户注册系统](https://gist.github.com/zethraeus/34d2aa882c106d8f44ecda6a976361db)中的一个组件，来浏览这些概念。最重要的代码部分是内联的，但是[的完整实现](https://gist.github.com/zethraeus/34d2aa882c106d8f44ecda6a976361db)可能会很有趣。

该代码具有以下行为:

1.启动实现用户名、电话号码、电子邮件和密码收集的代码子单元。

2.验证密码是否符合一些复杂性规则，(包括不包含用户名、电子邮件或电话号码)。

3.重新请求密码，直到满足验证规则。

4.使用侦听器接口调用一些自己的代码来报告成功。

# 问题:集成测试和组合爆炸

*随着 API 规模的增长，集成测试中会出现组合爆炸*。它是指随着 API 的扩展，系统内部状态的潜在复杂性会急剧增加。

这种状态复杂性的增加导致为了在期望的状态下进行测试所需的设置工作的增加。

我们代码中的主要逻辑是我们的`validatePassword`函数。这是我们最想进行的单元测试。然而，由于它是接触状态的内部助手，我们谨慎地将其设为`private`。

这意味着，为了测试负责确定用户密码是否有问题的代码单元，我们必须使用[重要的测试基础设施](https://gist.github.com/zethraeus/34d2aa882c106d8f44ecda6a976361db#file-testmocks-swift)构建一个完整的模拟环境来托管`BadOnboardingManager`，并通过其公共方法检查其输出。这很快就会变得很烦人。

由此产生的测试不仅仅是耗时的编写，它也不符合单元测试的基本原则:一次只测试一件事。这意味着当测试失败时，开发人员将不得不确定测试失败的确切部分。如果失败是由于正确的设置过程中的变化，这也意味着他们必须修改大量的测试！

它不符合单元测试的基本规则，因为它是一个集成测试。

人们可以设想通过检查程序 API 提供的输入和输出来全面测试整个程序的逻辑。但是在任何一个测试之前所需要的设置可能会变得非常庞大——并且它将会被复制用于每个几乎相同的测试变体。

单元测试是这种设置状态依赖组合爆炸的答案。但是我们如何使用它们而不牺牲我们的`private`函数和变量的安全呢？

## 保持你的隐私

避免将功能暴露在程序之外是很好的软件工程实践。一个合理的经验法则是，尽可能地使用私有访问控制，只在程序的功能需要时才允许更自由的访问。当另一个类必须触发你的类的函数时，它不能是私有的。

“测试你的接口”方法断言，合理的单元测试通过只测试不需要私有的功能来进行——外部代码必须访问你的代码的级别是验证它的合理级别。

只有当你没有在代码的私有部分执行大量的逻辑时，这种方法才有效。如果你是*，*，你会遇到组合爆炸，得到不可读的、脆弱的测试，就像上面的`test_PasswordCanNotContainUsername`。

更深入地看一看已经让我们走到这一步的经验法则，提供了一种走出困境的潜在方法:您应该限制对您的助手方法的访问的断言是建立在那些助手方法操纵状态的假设之上的。

不是公共函数不好。任何改变私人状态的公开手段都是危险的！

在示例代码中，密码的验证状态存储在`validatePassword`函数所属的`BadOnboardingManager`中的`var`中。简单来说，它大致是这样的:

```
private func validatePassword() {
    if /* `self.password` fails validation */ {
        self.passwordIsValid = false
    } else {
        self.passwordIsValid = true
    }
}
```

这是在应用程序中传递状态的一种非常拙劣的方式。

相反，如果您的 helper 方法是无状态的，那么公开暴露它是安全的。有一点小小的改变，外部代码可以调用 helper 方法的事实不会使代码变得更脆弱，因为它不会让外部代码操纵类的内部状态。

```
public func isValidPassword(_ password: String) -> Bool {
    if /* local `password` fails validation */ {
         return false
    } else {
         return true
    }
}
```

然而，这在生产代码中并不是一个真正的解决方案。有何不可？

## 以开发人员的规模编写长寿软件

虽然这些代码没有直接的问题，但它使代码库处于更脆弱的状态。一旦有一个公开的助手函数，其安全性依赖于它没有副作用，那么代码库与修改公开助手的状态之间就差一个简单的错误。

```
public func isValidPassword(_ password: String) -> Bool {
self.potentialPassword = password
    if /* local `password` fails validation */ {
         return false
    } else {
         return true
    }
}
```

毕竟，另一个作者或代码审查者怎么会知道你对你的公共函数的意图是让它成为公共的，但前提是它不改变为修改状态？当然，你可以在函数中加入一些注释来吸引你的合作者(或者未来的自己)注意，但是人类总是搞砸。

你知道什么不会搞砸吗？编译器不会出错。相信你的编译器。

为了让其他人可以安全地修改这些代码，我们想找到一种方法让编译器知道——并强制执行——这个函数不在我们私有状态的范围内。有几种不同的方法可以做到这一点，它们各有利弊:

1.  我们可以让助手函数成为它自己类的一部分(也许是`PasswordValidator`)。然后，该类将实现一个类似于`PasswordValidating`的接口，而`OnboardingManager`类将需要一个符合该接口的实例。这是最糟糕的答案。
2.  我们可以让助手函数成为一个自由浮动的全局函数(也许在某个助手包中)。这是安全的，因为我们知道它是纯函数(无副作用)。我们可以在`OnboardingManager`中调用这个函数，或者接受它作为一个有或者没有`typealias`的参数(函数签名/类型的别名)。这是最有功能的回答。
3.  中间的东西

1.第二。是最好的答案(对于它们各自的语言范例来说),在这种情况下，你可以把代码分解出来，成为你可以合理重用的东西。然而，如果功能本身是类的一个成员(例如`OnboardingManager`)，不太可能在其他地方重用，那么将代码分解成一个助手构造可能意味着将它从最容易理解的上下文中抽离出来。

如果代码不太可能在其他地方使用，并且在类的上下文中最容易理解，那么您应该将它留在那里。

为了安全地做到这一点，通过让您的助手函数`static`阻止它触及类作用域状态来依赖您的编译器。

```
public **static** func isValidPassword(_ password: String) -> Bool {
   /* Any attempt to touch self here fails compilation */
   if /* local `password` fails validation */ {
         return false
    } else {
         return true
    }
}
```

以这种方式，我们可以使用编译器来防止帮助器函数访问其类的私有状态，同时保持我们简洁而直接地测试其行为的能力。

只要您的代码库还没有通过存储重要的全局状态来滥用静态状态，静态函数本质上就不在状态流中，这是一种很好的方法，可以确保帮助函数明确地知道它们可以更改的状态(只有您传入的状态)，因此不会意外地损害您的程序逻辑流。

然后，代码审查应该将任何方法的非静态化视为潜在的危险行为——当然，这应该是真的，因为它给了方法对所有实例状态的潜在破坏性访问！

当然，您可以继续使用您现有的集成测试，但是现在它们可以被细化到它们预期的目的——测试单元之间的集成。