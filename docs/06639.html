<html>
<head>
<title>Message Queue Using Bull, Redis, and MongoDB in Node.js</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Node.js中使用Bull、Redis和MongoDB的消息队列</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/message-queue-using-bull-redis-and-mongodb-in-node-js-d7dedaa426ea?source=collection_archive---------0-----------------------#2020-10-21">https://betterprogramming.pub/message-queue-using-bull-redis-and-mongodb-in-node-js-d7dedaa426ea?source=collection_archive---------0-----------------------#2020-10-21</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="86ad" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">排队是Node.js中的一项重要技术，用于有效处理异步操作</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/efcf85f2f53425d567ef6085e920e33c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*6amJS3SoSPSAa-PL"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">照片由<a class="ae kv" href="https://unsplash.com/@paulius005?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Paulius Dragunas </a>在<a class="ae kv" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</p></figure><p id="b9e5" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">有很多排队系统:亚马逊简单队列服务(SQS)，Apache Kafka，Kue，RabbitMQ，Sidekiq，Bull等。每一个都是不同的，都是为了解决某些问题而产生的。</p><p id="fb98" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在本教程中，我们将创建一个命中API计数器来计算用户命中特定URL的次数。此外，我们将研究如何创建一个队列，将一个作业放入其中，并处理该作业。</p><p id="5928" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们将使用基于Redis的<a class="ae kv" href="https://github.com/OptimalBits/bull" rel="noopener ugc nofollow" target="_blank"> Bull </a>消息队列包来处理Node中的作业和消息。为了保存URL命中的总数，我们将使用MongoDB。</p></div><div class="ab cl ls lt hu lu" role="separator"><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx"/></div><div class="ij ik il im in"><h1 id="9ec7" class="lz ma iq bd mb mc md me mf mg mh mi mj jw mk jx ml jz mm ka mn kc mo kd mp mq bi translated">项目设置</h1><p id="561b" class="pw-post-body-paragraph kw kx iq ky b kz mr jr lb lc ms ju le lf mt lh li lj mu ll lm ln mv lp lq lr ij bi translated">如果你只是想快速进入代码，<a class="ae kv" href="https://github.com/miladr0/bull-mongo" rel="noopener ugc nofollow" target="_blank">这里是项目回购</a>。</p><p id="80ed" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">让我们初始化项目并安装我们需要的所有包。</p><pre class="kg kh ki kj gt mw mx my mz aw na bi"><span id="8fc0" class="nb ma iq mx b gy nc nd l ne nf">yarn init -y</span></pre><p id="58f9" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">以下是我们项目需要的一些包:</p><ul class=""><li id="5591" class="ng nh iq ky b kz la lc ld lf ni lj nj ln nk lr nl nm nn no bi translated"><strong class="ky ir"> Bull </strong>:基于Redis的节点队列</li><li id="b49f" class="ng nh iq ky b kz np lc nq lf nr lj ns ln nt lr nl nm nn no bi translated"><strong class="ky ir"> dotenv-safe: </strong>从<code class="fe nu nv nw mx b">.env</code>文件中读取<strong class="ky ir"> </strong>环境变量</li><li id="19ae" class="ng nh iq ky b kz np lc nq lf nr lj ns ln nt lr nl nm nn no bi translated"><strong class="ky ir"> esm </strong>:支持节点模块的导入/导出</li><li id="175d" class="ng nh iq ky b kz np lc nq lf nr lj ns ln nt lr nl nm nn no bi translated"><strong class="ky ir"> ioredis </strong>:用于连接redis</li></ul><pre class="kg kh ki kj gt mw mx my mz aw na bi"><span id="a358" class="nb ma iq mx b gy nc nd l ne nf">yarn add bull, dotenv-safe, esm, express, ioredis, mongoose</span></pre><p id="3763" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">对于自动格式化代码以及在开发中自动重启Express.js web服务器，我们将使用Prettier、ESLint和nodemon。</p><pre class="kg kh ki kj gt mw mx my mz aw na bi"><span id="e64f" class="nb ma iq mx b gy nc nd l ne nf">yarn add -D eslint eslint-config-prettier eslint-plugin-prettier prettier</span></pre></div><div class="ab cl ls lt hu lu" role="separator"><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx"/></div><div class="ij ik il im in"><h1 id="172c" class="lz ma iq bd mb mc md me mf mg mh mi mj jw mk jx ml jz mm ka mn kc mo kd mp mq bi translated">快速设置</h1><p id="80b1" class="pw-post-body-paragraph kw kx iq ky b kz mr jr lb lc ms ju le lf mt lh li lj mu ll lm ln mv lp lq lr ij bi translated">让我们通过将下面的代码片段添加到路径:<code class="fe nu nv nw mx b">./src/server.js</code>中的<code class="fe nu nv nw mx b">server.js</code> <strong class="ky ir"> </strong>来建立一个简单的Express web服务器。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nx ny l"/></div></figure><p id="1c6e" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">如果你看一下<code class="fe nu nv nw mx b">server.js</code>代码的第一行，我们在添加模块时使用了<code class="fe nu nv nw mx b">import</code>而不是<code class="fe nu nv nw mx b">require</code> <strong class="ky ir"> </strong>。由于我们已经添加了esm <strong class="ky ir"> </strong>模块来支持Node上的这种行为，为了运行这个简单的web服务器，我们只需要将下面的代码添加到我们的<code class="fe nu nv nw mx b">package.json</code>文件的<code class="fe nu nv nw mx b">scripts</code>部分:</p><pre class="kg kh ki kj gt mw mx my mz aw na bi"><span id="c406" class="nb ma iq mx b gy nc nd l ne nf">"start": "nodemon -r dotenv-safe/config -r esm ./src/server.js"</span></pre><p id="3bd6" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">就这样——现在，如果我们在终端上运行<code class="fe nu nv nw mx b">yarn start</code> <strong class="ky ir"> </strong>，web服务器就准备好为我们的请求提供服务了。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nz"><img src="../Images/64ecd8f39c9c557f6594b8d905a28b75.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Klu2fV_buKschJEj57YMKQ.png"/></div></div></figure></div><div class="ab cl ls lt hu lu" role="separator"><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx"/></div><div class="ij ik il im in"><h1 id="b2ff" class="lz ma iq bd mb mc md me mf mg mh mi mj jw mk jx ml jz mm ka mn kc mo kd mp mq bi translated">设置MongoDB</h1><p id="4530" class="pw-post-body-paragraph kw kx iq ky b kz mr jr lb lc ms ju le lf mt lh li lj mu ll lm ln mv lp lq lr ij bi translated">接下来，我们将使用Docker Compose，而不是手动安装Redis和MongoDB尽管这取决于您是否愿意。如果您已经在本地安装了它们，应该没问题。让我们在项目的根目录下创建一个<code class="fe nu nv nw mx b">docker-compose.yml</code> <strong class="ky ir"> </strong>文件:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nx ny l"/></div></figure><p id="541a" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">并定义一个MongoDB schema模型，用于保存这个路径中命中一个API的总计数:<code class="fe nu nv nw mx b">./src/models/hitApi.model.js</code>。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nx ny l"/></div></figure><p id="aac6" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">现在让我们通过在这个路径中定义<code class="fe nu nv nw mx b">mongoose.js</code> <strong class="ky ir"> </strong>来使用Mongoose连接到MongoDB:<code class="fe nu nv nw mx b">./src/mongoose.js</code>。此外，将<code class="fe nu nv nw mx b">hitApi.model.js</code>添加到我们之前定义的文件中，这样我们就可以从任何地方访问该模型:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nx ny l"/></div></figure><p id="019e" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在我们调用<code class="fe nu nv nw mx b">connectToMongo</code>函数来连接MongoDB之前，我们需要确保MongoDB正在运行，因此我们将在<code class="fe nu nv nw mx b">package.json</code>的<code class="fe nu nv nw mx b">scripts</code>部分添加下面一行来运行我们的Docker容器:</p><pre class="kg kh ki kj gt mw mx my mz aw na bi"><span id="f605" class="nb ma iq mx b gy nc nd l ne nf">"docker:dev": "docker-compose -f docker-compose.yml up"</span></pre><p id="04b3" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">通过在另一个终端上运行<code class="fe nu nv nw mx b">yarn docker:dev</code>命令，我们的容器将启动。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nz"><img src="../Images/1089f4da0ecea424889f7b8590f94ccf.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*93oLcegT7AS_nJklqyfAoA.png"/></div></div></figure><p id="d260" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">现在，我们实际上可以通过将下面一行添加到<code class="fe nu nv nw mx b">server.js</code>来连接到我们的MongoDB——这意味着当我们的web服务器启动时，我们就连接到了我们的MongoDB。</p><pre class="kg kh ki kj gt mw mx my mz aw na bi"><span id="0100" class="nb ma iq mx b gy nc nd l ne nf">connectToMongo();</span></pre><p id="6f8b" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">太好了！到目前为止，我们已经设置了项目，运行了容器，并将web服务器连接到MongoDB。最后一步是创建并运行我们的作业。</p></div><div class="ab cl ls lt hu lu" role="separator"><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx"/></div><div class="ij ik il im in"><h1 id="3d11" class="lz ma iq bd mb mc md me mf mg mh mi mj jw mk jx ml jz mm ka mn kc mo kd mp mq bi translated">创造一份工作</h1><p id="909b" class="pw-post-body-paragraph kw kx iq ky b kz mr jr lb lc ms ju le lf mt lh li lj mu ll lm ln mv lp lq lr ij bi translated">Bull消息队列使用Redis来保存和检索作业，因此首先我们需要创建一个到Redis的连接，并将该连接传递给Bull实例。</p><p id="d338" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">创建<code class="fe nu nv nw mx b">redisConnection.js</code>，并将下面的代码片段添加到这个路径中:<code class="fe nu nv nw mx b">./src/lib/redisConnection.js</code>。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nx ny l"/></div></figure><p id="15df" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">现在我们可以在我们的作业中使用这个Redis连接—例如，让我们定义一个作业来处理当前的URL并将结果保存在MongoDB中。为此，在这个路径中创建<code class="fe nu nv nw mx b">hitApi.redisJob.js</code>:<code class="fe nu nv nw mx b">./src/jobs/hitApi.redisJob.js</code>。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nx ny l"/></div></figure><p id="7783" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">最后，让我们将这个作业作为中间件添加到文件<code class="fe nu nv nw mx b">server.js</code>中的Express routes之前。通过这种方式，当用户点击一个URL时，该作业将会运行，并会更新特定URL的总计数。</p><pre class="kg kh ki kj gt mw mx my mz aw na bi"><span id="1303" class="nb ma iq mx b gy nc nd l ne nf">...</span><span id="1c07" class="nb ma iq mx b gy oa nd l ne nf">const app = express();</span><span id="ea65" class="nb ma iq mx b gy oa nd l ne nf">connectToMongo();</span><span id="6783" class="nb ma iq mx b gy oa nd l ne nf">app.get('/', (req, res) =&gt; {</span><span id="8547" class="nb ma iq mx b gy oa nd l ne nf">res.send('hello world');</span><span id="c63d" class="nb ma iq mx b gy oa nd l ne nf">});</span><span id="3839" class="nb ma iq mx b gy oa nd l ne nf"><strong class="mx ir">app.use(hitApi);</strong></span><span id="9481" class="nb ma iq mx b gy oa nd l ne nf">app.get('/api-1', (req, res) =&gt; {</span><span id="d098" class="nb ma iq mx b gy oa nd l ne nf">res.send('you hit api-1');</span><span id="6253" class="nb ma iq mx b gy oa nd l ne nf">});</span><span id="8e5d" class="nb ma iq mx b gy oa nd l ne nf">app.get('/api-2', (req, res) =&gt; {</span><span id="bd86" class="nb ma iq mx b gy oa nd l ne nf">res.send('you hit api-2');</span><span id="cd8e" class="nb ma iq mx b gy oa nd l ne nf">});</span><span id="ae89" class="nb ma iq mx b gy oa nd l ne nf">...</span></pre><p id="b8e5" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><strong class="ky ir">注意</strong>:不要忘记在项目的根目录下创建一个<code class="fe nu nv nw mx b">.env</code>文件来定义MongoDB和Redis的连接URL和user/pass，如下图所示:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nx ny l"/></div></figure></div><div class="ab cl ls lt hu lu" role="separator"><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx"/></div><div class="ij ik il im in"><h1 id="4acf" class="lz ma iq bd mb mc md me mf mg mh mi mj jw mk jx ml jz mm ka mn kc mo kd mp mq bi translated"><strong class="ak">开始工作</strong></h1><p id="db9f" class="pw-post-body-paragraph kw kx iq ky b kz mr jr lb lc ms ju le lf mt lh li lj mu ll lm ln mv lp lq lr ij bi translated">在你喜欢的浏览器中打开<code class="fe nu nv nw mx b">http://localhost:3000/api-1</code>或<code class="fe nu nv nw mx b">http://localhost:3000/api-2</code>网址，在检查你的DB时，你可以看到每次你打开那些网址，那些网址的总数都会更新。</p><p id="a3d1" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">就是这样。希望这个快速概述可以帮助您开始使用Bull in Node。感谢您的阅读！</p><p id="ef80" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><a class="ae kv" href="https://github.com/miladr0/bull-mongo" rel="noopener ugc nofollow" target="_blank">这是GitHub上完整资源库的链接</a>。</p></div></div>    
</body>
</html>