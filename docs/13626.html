<html>
<head>
<title>Sanitization of Rust Executables</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Rust可执行文件的清理</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/sanitization-of-rust-executables-dac2744340c?source=collection_archive---------21-----------------------#2022-09-12">https://betterprogramming.pub/sanitization-of-rust-executables-dac2744340c?source=collection_archive---------21-----------------------#2022-09-12</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="ee80" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">简要介绍在没有事先清理的情况下发布Rust可执行文件的危险</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/8f627280a67b3386bee915a1c82a6f80.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*1DthyaCcHAyG7cf_"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">照片由<a class="ae kv" href="https://unsplash.com/@kelvinhan?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Kelvin Han </a>在<a class="ae kv" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</p></figure><p id="fb4b" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">你有没有停下来想一想当你生成一个可执行文件时会发生什么？许多系统路径都存储在里面，包括使用过的库，这些库可以提供关于构建可执行文件的系统的信息。不仅包括路线，还包括关于可能发生的错误的信息或控制台要打印的结构名称。</p><h1 id="605f" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">调试信息</h1><p id="3c96" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">在这种情况下，我将展示当您在Rust结构中实现Debug特性时会发生什么。</p><p id="23d2" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">注意:所有的编译都使用了<code class="fe mp mq mr ms b">--release</code>标志。</p><pre class="kg kh ki kj gt mt ms mu mv aw mw bi"><span id="9392" class="mx lt iq ms b gy my mz l na nb">struct PrivacyExample1Struct {<br/>    pub name : String,<br/>    pub content : String,<br/>    pub version : u64<br/>}<br/>#[derive(Debug)]<br/>struct PrivacyExample2Struct {<br/>    pub name : String,<br/>    pub content : String,<br/>    pub version : u64<br/>}<br/>fn main() {<br/>    let obj = PrivacyExample1Struct {<br/>        name : "001".to_string(),<br/>        content : "content1".to_string(),<br/>        version : 123<br/>    };<br/>    println!("PrivacyExample1: {}",obj.name);<br/>    let obj = PrivacyExample2Struct {<br/>        name : "002".to_string(),<br/>        content : "content2".to_string(),<br/>        version : 234<br/>    };<br/>    println!("PrivacyExample2: {:?}",obj);<br/>}</span></pre><p id="dd2c" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">无需执行，只需提取文件的字符串:</p><pre class="kg kh ki kj gt mt ms mu mv aw mw bi"><span id="cb09" class="mx lt iq ms b gy my mz l na nb">strings -n 12 target/release/privacy.exe  | grep Privacy<br/>001content1PrivacyExample1: <br/>002content2PrivacyExample2:<br/>PrivacyExample2Structname</span></pre><p id="454a" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">因此，对于第二个结构体，即实现Debug特征的结构体，我们可以看到存储在文件中的结构体的名称。</p><p id="19e2" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">现在，如果我们用另一个结构来改进我们的例子:</p><pre class="kg kh ki kj gt mt ms mu mv aw mw bi"><span id="26d6" class="mx lt iq ms b gy my mz l na nb">#[derive(Debug)]<br/>struct PrivacyExample2_1Struct {<br/>    pub name : String,<br/>    pub content : String,<br/>    pub version : u64<br/>}<br/>let obj = PrivacyExample2_1Struct {<br/>    name : "002.1".to_string(),<br/>    content : "content2.1".to_string(),<br/>    version : 234<br/>};<br/>println!("PrivacyExample2.1: {:?}",obj.name);</span></pre><p id="7165" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们正在使用<code class="fe mp mq mr ms b">PrivacyExample2_1Struct</code>但没有打印它。所以提取字符串会给我们:</p><pre class="kg kh ki kj gt mt ms mu mv aw mw bi"><span id="e464" class="mx lt iq ms b gy my mz l na nb">strings -n 12 target/release/privacy.exe  | grep Privacy<br/>001content1PrivacyExample1: <br/>002content2PrivacyExample2:<br/>002.1content2.1PrivacyExample2.1:<br/>PrivacyExample2Structname</span></pre><p id="2f10" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们可以看到，编译器知道我们没有使用<code class="fe mp mq mr ms b">PrivacyExample2_1Struct</code>的调试特性，所以它从编译后的代码中删除了它。</p><h2 id="88f4" class="mx lt iq bd lu nc nd dn ly ne nf dp mc lf ng nh me lj ni nj mg ln nk nl mi nm bi translated">主机路由</h2><p id="9db4" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">正如我们提到的，编译后的代码中存储了与编译所在的主机相关的路由:</p><pre class="kg kh ki kj gt mt ms mu mv aw mw bi"><span id="42ab" class="mx lt iq ms b gy my mz l na nb">strings -n 12 target/release/privacy.exe | grep ':\\' <br/>C:\Users\runneradmin\.cargo\registry\src\github.com-1ecc6299db9ec823\rustc-demangle-0.1.21\src\legacy.rs8<br/>C:\Users\runneradmin\.cargo\registry\src\github.com-1ecc6299db9ec823\rustc-demangle-0.1.21\src\v0.rs<br/>.llvm.C:\Users\runneradmin\.cargo\registry\src\github.com-1ecc6299db9ec823\rustc-demangle-0.1.21\src\lib.rs<br/>Z:\privacy\target\release\deps\privacy.pdb</span></pre><p id="703e" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在这种情况下，没有对我的用户<code class="fe mp mq mr ms b">secsamdev</code>的引用，因为我们没有使用库(存储在<code class="fe mp mq mr ms b">C:\\Users\\secsamdev\\.cargo</code>)。唯一需要注意的是“Z:\”共享文件夹。</p><h2 id="0f78" class="mx lt iq bd lu nc nd dn ly ne nf dp mc lf ng nh me lj ni nj mg ln nk nl mi nm bi translated">序列化信息</h2><p id="3d2e" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">我们现在将使用Serde库，因此我们现在将在代码中包含与主机相关的路由。</p><pre class="kg kh ki kj gt mt ms mu mv aw mw bi"><span id="d64b" class="mx lt iq ms b gy my mz l na nb">[dependencies]<br/>serde_json = "1.0"<br/>serde = { version = "1.0", features = ["derive"] }</span></pre><p id="4286" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">现在该结构必须实现<em class="nn">序列化</em>和<em class="nn">反序列化</em>特征:</p><pre class="kg kh ki kj gt mt ms mu mv aw mw bi"><span id="d591" class="mx lt iq ms b gy my mz l na nb">#[derive(Serialize, Deserialize, Debug)]<br/>struct PrivacyExample3Struct {<br/>    pub name : String,<br/>    pub content : String,<br/>    pub version : u64<br/>}<br/>let obj = PrivacyExample3Struct {<br/>    name : "002".to_string(),<br/>    content : "content2".to_string(),<br/>    version : 234<br/>};<br/>let j = serde_json::to_string(&amp;obj).unwrap();</span><span id="10a3" class="mx lt iq ms b gy no mz l na nb">println!("PrivacyExample3: {}", j);</span></pre><p id="45ac" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">和以前一样，<em class="nn">字符串</em>:</p><pre class="kg kh ki kj gt mt ms mu mv aw mw bi"><span id="c16d" class="mx lt iq ms b gy my mz l na nb">strings -n 12 target/release/privacy.exe | grep 'Privacy'<br/>001contenido1PrivacyExample1: <br/>002contenido2PrivacyExample2: <br/>002.1contenido2.1PrivacyExample2.1: <br/>PrivacyExample3: <br/>PrivacyExample2Structname</span></pre><p id="b150" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">和寻找系统路线相同:</p><pre class="kg kh ki kj gt mt ms mu mv aw mw bi"><span id="42b3" class="mx lt iq ms b gy my mz l na nb">strings -n 12 target/release/privacy.exe | grep ':\\'            <br/>internal error: entered unreachable codeC:\Users\secsamdev\.cargo\registry\src\github.com-1ecc6299db9ec823\serde_json-1.0.81\src\ser.rs<br/>C:\Users\runneradmin\.cargo\registry\src\github.com-1ecc6299db9ec823\rustc-demangle-0.1.21\src\legacy.rs<br/>C:\Users\runneradmin\.cargo\registry\src\github.com-1ecc6299db9ec823\rustc-demangle-0.1.21\src\v0.rs<br/>.llvm.C:\Users\runneradmin\.cargo\registry\src\github.com-1ecc6299db9ec823\rustc-demangle-0.1.21\src\lib.rs<br/>Z:\privacy\target\release\deps\privacy.pdb</span></pre><p id="5b18" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">要从代码中删除这一行，我们必须编辑“config.toml”。</p><div class="np nq gp gr nr ns"><a href="https://github.com/rust-lang/rust/issues/40552" rel="noopener  ugc nofollow" target="_blank"><div class="nt ab fo"><div class="nu ab nv cl cj nw"><h2 class="bd ir gy z fp nx fr fs ny fu fw ip bi translated">默认情况下，为绝对路径启用- remap-path-prefix问题#40552 rust-lang/rust</h2><div class="nz l"><h3 class="bd b gy z fp nx fr fs ny fu fw dk translated">根据#40374，一部分隐私信息被驻留在编译后的二进制文件中的路径字符串泄露。至…</h3></div><div class="oa l"><p class="bd b dl z fp nx fr fs ny fu fw dk translated">github.com</p></div></div><div class="ob l"><div class="oc l od oe of ob og kp ns"/></div></div></a></div><pre class="kg kh ki kj gt mt ms mu mv aw mw bi"><span id="2758" class="mx lt iq ms b gy my mz l na nb">[build]<br/>rustflags = ["--remap-path-prefix=C:\\Users\\secsamdev\\.cargo=cargo", "--remap-path-prefix=C:\\Users\\secsamdev=home", "--remap-path-prefix=C:\\Users\\secsamdev\\.rustup=rustup", "--remap-path-prefix=Z:\\privacy=workspace"]</span></pre><p id="ffdb" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">重新编译代码将为我们提供:</p><pre class="kg kh ki kj gt mt ms mu mv aw mw bi"><span id="9ebd" class="mx lt iq ms b gy my mz l na nb">strings -n 12 target/release/privacy.exe | grep 'cargo'<br/>internal error: entered unreachable codehome\.cargo\registry\src\github.com-1ecc6299db9ec823\serde_json-1.0.81\src\ser.rs<br/>C:\Users\runneradmin\.cargo\registry\src\github.com-1ecc6299db9ec823\rustc-demangle-0.1.21\src\legacy.rsx<br/>C:\Users\runneradmin\.cargo\registry\src\github.com-1ecc6299db9ec823\rustc-demangle-0.1.21\src\v0.rs<br/>.llvm.C:\Users\runneradmin\.cargo\registry\src\github.com-1ecc6299db9ec823\rustc-demangle-0.1.21\src\lib.rs</span></pre><p id="59ea" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">考虑到仍然会有对库的引用:</p><pre class="kg kh ki kj gt mt ms mu mv aw mw bi"><span id="c9cb" class="mx lt iq ms b gy my mz l na nb">strings -n 12 target/release/privacy.exe | grep '\\src'<br/>AccessErrorcannot access a Thread Local Storage value during or after destructionlibrary\std\src\thread\local.rs<br/>use of std::thread::current() is not possible after the thread's local data has been destroyedlibrary\std\src\thread\mod.rs<br/>library\std\src\io\buffered\linewritershim.rs<br/>library\std\src\io\stdio.rs<br/>stdoutlibrary\std\src\io\mod.rs<br/>/rustc/7737e0b5c4103216d6fd8cf941b7ab9bdbaace7c\library\core\src\char\methods.rsP<br/>:.assertion failed: self.is_char_boundary(new_len)/rustc/7737e0b5c4103216d6fd8cf941b7ab9bdbaace7c\library\alloc\src\string.rs<br/>library\std\src\panic.rs<br/>library\std\src\path.rs<br/>...</span></pre><h2 id="fa89" class="mx lt iq bd lu nc nd dn ly ne nf dp mc lf ng nh me lj ni nj mg ln nk nl mi nm bi translated">反序列化信息</h2><p id="f181" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">我们已经检查了序列化发生了什么，现在是反序列化:</p><pre class="kg kh ki kj gt mt ms mu mv aw mw bi"><span id="fea8" class="mx lt iq ms b gy my mz l na nb">let obj2 : PrivacyExample3Struct = serde_json::from_str(&amp;j).unwrap();</span></pre><p id="e93a" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><code class="fe mp mq mr ms b">strings</code>命令将为我们提供:</p><pre class="kg kh ki kj gt mt ms mu mv aw mw bi"><span id="db5e" class="mx lt iq ms b gy my mz l na nb">strings -n 12 target/release/privacy.exe | grep 'Privacy'<br/>struct PrivacyExample3Struct with 3 elements<br/>001contenido1PrivacyExample1: <br/>002contenido2PrivacyExample2: <br/>002.1contenido2.1PrivacyExample2.1: <br/>PrivacyExample3: <br/>PrivacyExample2Structname<br/>struct PrivacyExample3Structcalled `Result::unwrap()` on an `Err` value</span></pre><p id="574d" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">注意，我们可以看到“struct privacy example 3 struct with 3 elements ”,它提供了关于我们的代码如何在内部工作的信息。</p><h1 id="d26b" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">结论</h1><p id="f766" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">正如我们所看到的，许多引用隐藏在可执行文件中:我们编译代码的机器，我们使用的库，它甚至可以给出我们的代码如何工作的线索。</p><p id="572c" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">出于这个原因，有必要时刻牢记我们正在使用的工具，并深入了解围绕生锈的所有工具的来龙去脉。</p></div></div>    
</body>
</html>