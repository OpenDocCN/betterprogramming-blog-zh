<html>
<head>
<title>2 Common Ways to Handle Errors In Swift Task Groups</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Swift任务组中处理错误的两种常用方法</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/2-common-ways-to-handle-errors-in-swift-task-groups-4bc9f231e2eb?source=collection_archive---------3-----------------------#2021-11-18">https://betterprogramming.pub/2-common-ways-to-handle-errors-in-swift-task-groups-4bc9f231e2eb?source=collection_archive---------3-----------------------#2021-11-18</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="290a" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">任务组中的错误处理</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/5d57ada3a719bcfb8b830d4ea6a8abc5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*4aN-YHnfhP8lBz43"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">由<a class="ae ky" href="https://unsplash.com/@kellysikkema?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">凯利·西克玛</a>在<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</p></figure><p id="123b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果您已经阅读了我的<a class="ae ky" rel="noopener ugc nofollow" target="_blank" href="/understanding-swift-5-5-task-groups-f49fe7c5f873">上一篇文章</a>，那么您现在应该知道如何创建一个任务组，如何向任务组添加子任务，以及如何从所有子任务中收集结果。然而，有一个与任务组相关的重要主题我还没有谈到，那就是“错误处理”。</p><p id="7898" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">众所周知，任务组由多个并发运行的子任务组成。当其中一个子任务遇到错误时，任务组应该如何处理该错误？那些还在运行的子任务会怎么样？</p><p id="0cfe" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在本文中，我们将探讨在任务组中处理错误的两种最常见的方法:</p><ol class=""><li id="52d2" class="lv lw it lb b lc ld lf lg li lx lm ly lq lz lu ma mb mc md bi translated">使用抛出任务组抛出错误</li><li id="9db9" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated">返回所有已完成子任务的结果</li></ol><p id="85cd" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">像往常一样，我将使用一些易于理解的示例代码来帮助您了解这两种方法是如何工作的，所以让我们开始吧！</p><blockquote class="mj mk ml"><p id="be39" class="kz la mm lb b lc ld ju le lf lg jx lh mn lj lk ll mo ln lo lp mp lr ls lt lu im bi translated"><strong class="lb iu">注:</strong></p><p id="f17d" class="kz la mm lb b lc ld ju le lf lg jx lh mn lj lk ll mo ln lo lp mp lr ls lt lu im bi translated">本文要求您对Swift任务组有一个基本的了解。如果您不熟悉任务组的基础知识，我强烈建议您首先阅读我以前的文章“<a class="ae ky" href="https://swiftsenpai.com/swift/understanding-task-groups/" rel="noopener ugc nofollow" target="_blank">通过示例</a>了解Swift任务组”。</p></blockquote></div><div class="ab cl mq mr hx ms" role="separator"><span class="mt bw bk mu mv mw"/><span class="mt bw bk mu mv mw"/><span class="mt bw bk mu mv"/></div><div class="im in io ip iq"><h1 id="5050" class="mx my it bd mz na nb nc nd ne nf ng nh jz ni ka nj kc nk kd nl kf nm kg nn no bi translated">定义抛出子任务</h1><p id="22f8" class="pw-post-body-paragraph kz la it lb b lc np ju le lf nq jx lh li nr lk ll lm ns lo lp lq nt ls lt lu im bi translated">为了演示任务组中的错误处理，我们必须首先有一个可以抛出错误的子任务。让我们修改我们之前创建的<a class="ae ky" href="https://swiftsenpai.com/swift/understanding-task-groups/" rel="noopener ugc nofollow" target="_blank">的<code class="fe nu nv nw nx b">SlowDivideOperation</code></a>，这样当除数为零时它将抛出一个错误:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ny nz l"/></div></figure><p id="9a3c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如你所见，<code class="fe nu nv nw nx b">execute()</code>函数现在用<code class="fe nu nv nw nx b">throws</code>关键字标记，表明它现在是一个抛出函数。除此之外，我还添加了2个打印语句来帮助我们可视化执行操作时实际发生的情况。</p><p id="804c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">有了这些，我们现在可以开始研究第一种方法了。</p></div><div class="ab cl mq mr hx ms" role="separator"><span class="mt bw bk mu mv mw"/><span class="mt bw bk mu mv mw"/><span class="mt bw bk mu mv"/></div><div class="im in io ip iq"><h1 id="0172" class="mx my it bd mz na nb nc nd ne nf ng nh jz ni ka nj kc nk kd nl kf nm kg nn no bi translated">方法1:使用抛出任务组抛出错误</h1><p id="4b9c" class="pw-post-body-paragraph kz la it lb b lc np ju le lf nq jx lh li nr lk ll lm ns lo lp lq nt ls lt lu im bi translated">出于演示的目的，我们将创建一个任务组，它产生多个子任务，这些子任务执行一个<code class="fe nu nv nw nx b">SlowDivideOperation</code>并返回它的名称和结果。当所有的<code class="fe nu nv nw nx b">SlowDivideOperation</code>完成后，任务组将收集它所有的子任务结果，并返回一个包含所有<code class="fe nu nv nw nx b">SlowDivideOperation</code>名字和结果的字典。</p><p id="8d78" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果任何子任务遇到错误，它将抛出错误并将错误传播到任务组，任务组将抛出错误。下面是示例代码:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ny nz l"/></div></figure><p id="62a9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们看一下上面代码的一些重要细节:</p><ol class=""><li id="7ad6" class="lv lw it lb b lc ld lf lg li lx lm ly lq lz lu ma mb mc md bi translated"><code class="fe nu nv nw nx b">operations</code>数组定义了任务组要产生的子任务。请注意，当我们执行示例代码时，<em class="mm"> "operation-2" </em>会抛出一个错误。</li><li id="576d" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated">我们将使用<code class="fe nu nv nw nx b">withThrowingTaskGroup(of:returning:body:)</code>功能创建一个投掷任务组。它的工作方式类似于<code class="fe nu nv nw nx b">withTaskGroup(of:returning:body:)</code>函数，但是我们需要使用<code class="fe nu nv nw nx b">try</code>关键字来调用它，因为它可能会抛出一个错误。</li><li id="0cce" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated">我们必须用<code class="fe nu nv nw nx b">try</code>关键字调用<code class="fe nu nv nw nx b">SlowDivideOperation</code>的<code class="fe nu nv nw nx b">execute()</code>函数。这允许由<code class="fe nu nv nw nx b">execute()</code>函数抛出的错误传播到任务组。</li><li id="fc42" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated">因为我们现在使用一个抛出任务组，所以当从每个子任务收集结果时，我们必须使用<code class="fe nu nv nw nx b">try</code>关键字。</li></ol><p id="366f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在，如果我们尝试执行示例代码，我们将得到以下输出:</p><pre class="kj kk kl km gt oa nx ob oc aw od bi"><span id="7bcd" class="oe my it nx b gy of og l oh oi">✅ operation-1 completed: 2.0<br/>⛔️ operation-2 throw error<br/>✅ operation-3 completed: 4.0<br/>✅ operation-0 completed: 5.0<br/>👎🏻 Task group throws error: divideByZero</span></pre><p id="50d7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">上面的输出显示了我们所期望的结果—<em class="mm">“operation-2”</em>抛出一个错误，并且该错误正在传播到任务组，从而导致任务组抛出<code class="fe nu nv nw nx b">divideByZero</code>错误。</p><p id="9449" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">尽管我们的示例代码正在做我们想要的事情，但它并没有被优化。从输出中可以看到，<em class="mm">“操作-3”</em>和<em class="mm">“操作-0”</em>仍然会继续执行，直到完成，即使<em class="mm">“操作-2”</em>已经抛出错误。我们能做些什么来避免这种情况吗？</p><h2 id="1774" class="oe my it bd mz oj ok dn nd ol om dp nh li on oo nj lm op oq nl lq or os nn ot bi translated">理解投掷任务组的行为</h2><p id="1c09" class="pw-post-body-paragraph kz la it lb b lc np ju le lf nq jx lh li nr lk ll lm ns lo lp lq nt ls lt lu im bi translated">为了优化我们的示例代码，我们必须首先了解当抛出任务的子任务抛出错误时，抛出任务组将如何表现。这里有一些你应该知道的重要行为:</p><ol class=""><li id="dfb1" class="lv lw it lb b lc ld lf lg li lx lm ly lq lz lu ma mb mc md bi translated">任务组只会抛出其子任务抛出的第一个错误。来自其他子任务的所有后续错误都将被忽略。</li><li id="7b10" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated">当子任务抛出错误时，所有剩余的子任务(仍在运行的子任务)将被标记为取消。</li><li id="da24" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated"><strong class="lb iu">标记为取消的子任务将继续执行，直到我们显式停止它。</strong></li><li id="d3a3" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated">标记为canceled的子任务不会触发从任务组收集结果的for循环，即使该子任务已完成其执行。</li></ol><p id="a0ed" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">上述列表中的第三种行为是导致<em class="mm">“操作-3”</em>和<em class="mm">“操作-0”</em>继续执行的原因，即使<em class="mm">“操作-2”</em>已经抛出错误。要显式停止一个被取消的任务，我们可以使用<code class="fe nu nv nw nx b">Task.checkCancellation()</code>方法。这个方法将检查当前正在执行代码的任务，如果任务被取消，它将抛出一个<code class="fe nu nv nw nx b">CancellationError</code>。</p><p id="dae7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">考虑到这一点，让我们将焦点转回<code class="fe nu nv nw nx b">SlowDivideOperation.execute()</code>方法。对于我们的情况，检查取消的最佳位置是在<code class="fe nu nv nw nx b">Task.sleep()</code>方法之后。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ny nz l"/></div></figure><p id="4e56" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这就是我们需要做的。现在，如果我们再次执行示例代码，我们将得到以下输出:</p><pre class="kj kk kl km gt oa nx ob oc aw od bi"><span id="cc54" class="oe my it nx b gy of og l oh oi">✅ operation-1 completed: 2.0<br/>⛔️ operation-2 throw error<br/>👎🏻 Task group throws error: divideByZero</span></pre><p id="f341" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这样，我们成功地提高了示例代码的效率。一旦一个子任务抛出错误，任务组中所有剩余的子任务都将停止执行。</p></div><div class="ab cl mq mr hx ms" role="separator"><span class="mt bw bk mu mv mw"/><span class="mt bw bk mu mv mw"/><span class="mt bw bk mu mv"/></div><div class="im in io ip iq"><h1 id="74b4" class="mx my it bd mz na nb nc nd ne nf ng nh jz ni ka nj kc nk kd nl kf nm kg nn no bi translated">方法2:返回所有已完成子任务的结果</h1><p id="0c5e" class="pw-post-body-paragraph kz la it lb b lc np ju le lf nq jx lh li nr lk ll lm ns lo lp lq nt ls lt lu im bi translated">现在，如果我们想要一个与方法1完全相反的结果呢？我们希望我们的任务组忽略所有有错误的子任务，并返回所有已完成子任务的结果。</p><p id="1800" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">使用的概念与方法1非常相似，但是这次我们将创建一个普通的(非投掷)任务组，并使用<code class="fe nu nv nw nx b">try?</code>忽略所有错误:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ny nz l"/></div></figure><p id="3d07" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">上面的示例代码与方法1的示例代码几乎相同，但是有一些重要的区别您应该知道。让我们详细看一下:</p><ol class=""><li id="3a44" class="lv lw it lb b lc ld lf lg li lx lm ly lq lz lu ma mb mc md bi translated">我们使用<code class="fe nu nv nw nx b">withTaskGroup(of:returning:body:)</code>函数创建一个任务组，因为我们的任务组将不再抛出错误。最重要的是，我们必须将子任务结果类型更改为optional，这样当错误发生时，我们的子任务可以返回<code class="fe nu nv nw nx b">nil</code>。</li><li id="1dcf" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated">调用<code class="fe nu nv nw nx b">execute()</code>时使用可选的try ( <code class="fe nu nv nw nx b">try?</code>，当<code class="fe nu nv nw nx b">execute()</code>函数抛出错误时返回<code class="fe nu nv nw nx b">nil</code>。</li><li id="feeb" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated">由于我们的子任务不再抛出错误，我们可以从for循环中删除关键字<code class="fe nu nv nw nx b">try</code>。此外，我们必须将<code class="fe nu nv nw nx b">compactMap</code>应用到<code class="fe nu nv nw nx b">taskGroup</code>，以便过滤掉子任务返回的所有<code class="fe nu nv nw nx b">nil</code>结果。</li></ol><p id="37f2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">下面是我们从上面的代码中得到的输出:</p><pre class="kj kk kl km gt oa nx ob oc aw od bi"><span id="ab21" class="oe my it nx b gy of og l oh oi">✅ operation-1 completed: 2.0<br/>⛔️ operation-2 throw error<br/>✅ operation-3 completed: 4.0<br/>✅ operation-0 completed: 5.0<br/>👍🏻 Task group completed with result: ["operation-0": 5.0, "operation-1": 2.0, "operation-3": 4.0]</span></pre><p id="b174" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">很简单，不是吗？</p></div><div class="ab cl mq mr hx ms" role="separator"><span class="mt bw bk mu mv mw"/><span class="mt bw bk mu mv mw"/><span class="mt bw bk mu mv"/></div><div class="im in io ip iq"><h1 id="5a9f" class="mx my it bd mz na nb nc nd ne nf ng nh jz ni ka nj kc nk kd nl kf nm kg nn no bi translated">包扎</h1><p id="178e" class="pw-post-body-paragraph kz la it lb b lc np ju le lf nq jx lh li nr lk ll lm ns lo lp lq nt ls lt lu im bi translated">我在本文中向您展示的两种方法只是在任务组中处理错误的两种最基本的方法。您肯定可以扩展这些方法中使用的概念来处理更复杂的情况，以满足您的需求。</p><p id="a210" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">像往常一样，您可以在<a class="ae ky" href="https://github.com/LeeKahSeng/SwiftSenpai-Swift-Concurrency" rel="noopener ugc nofollow" target="_blank"> GitHub </a>上获得本文中的示例代码。</p><p id="1e8b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我希望这篇文章能给你一个在使用任务组时如何处理错误的好主意。如果您有任何问题或意见，请随时通过<a class="ae ky" href="https://twitter.com/Lee_Kah_Seng" rel="noopener ugc nofollow" target="_blank"> Twitter </a>联系我。</p><p id="8a72" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">感谢阅读。</p></div><div class="ab cl mq mr hx ms" role="separator"><span class="mt bw bk mu mv mw"/><span class="mt bw bk mu mv mw"/><span class="mt bw bk mu mv"/></div><div class="im in io ip iq"><h1 id="ad86" class="mx my it bd mz na nb nc nd ne nf ng nh jz ni ka nj kc nk kd nl kf nm kg nn no bi translated">进一步阅读</h1><ul class=""><li id="bb9f" class="lv lw it lb b lc np lf nq li ou lm ov lq ow lu ox mb mc md bi translated"><a class="ae ky" href="https://swiftsenpai.com/swift/async-await-network-requests/" rel="noopener ugc nofollow" target="_blank">通过Swift中的Async/await发出网络请求</a></li><li id="48f0" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ox mb mc md bi translated"><a class="ae ky" href="https://swiftsenpai.com/swift/actor-prevent-data-race/" rel="noopener ugc nofollow" target="_blank">在Swift中使用Actors防止数据竞争</a></li><li id="9cb5" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ox mb mc md bi translated"><a class="ae ky" href="https://swiftsenpai.com/swift/actor-reentrancy-problem/" rel="noopener ugc nofollow" target="_blank">Swift中的演员重入问题</a></li><li id="609f" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ox mb mc md bi translated"><a class="ae ky" href="https://swiftsenpai.com/swift/sendable-prevent-data-races/" rel="noopener ugc nofollow" target="_blank">Sendable如何帮助防止数据竞争</a></li></ul></div></div>    
</body>
</html>