<html>
<head>
<title>How I Would Design… YouTube or Netflix!</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">我会如何设计… YouTube或网飞！</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/how-i-would-design-youtube-or-netflix-42a513b712fb?source=collection_archive---------4-----------------------#2021-11-05">https://betterprogramming.pub/how-i-would-design-youtube-or-netflix-42a513b712fb?source=collection_archive---------4-----------------------#2021-11-05</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="5163" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">系统设计演示</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/08e1bcaa74e49bc3f5270dff52b9e79d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*50s_sfOPOryAgNiF"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">在<a class="ae kv" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上由<a class="ae kv" href="https://unsplash.com/@thibaultpenin?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Thibault Penin </a>拍摄的照片</p></figure><h1 id="ebc8" class="kw kx iq bd ky kz la lb lc ld le lf lg jw lh jx li jz lj ka lk kc ll kd lm ln bi translated">观众</h1><p id="2680" class="pw-post-body-paragraph lo lp iq lq b lr ls jr lt lu lv ju lw lx ly lz ma mb mc md me mf mg mh mi mj ij bi translated">这篇文章是我如何设计流行应用程序系列的下一篇。推荐(尽管不是完全必要)阅读我已经整理成列表<a class="ae kv" href="https://jc1175.medium.com/list/how-i-would-design-7c3a2267386b" rel="noopener">的前几篇文章。</a></p><p id="683f" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">我们希望对架构原则和AWS有一个基本的了解，但是希望这篇文章对大多数工程师来说是容易理解的。</p><h1 id="59a5" class="kw kx iq bd ky kz la lb lc ld le lf lg jw lh jx li jz lj ka lk kc ll kd lm ln bi translated">争吵</h1><p id="f07b" class="pw-post-body-paragraph lo lp iq lq b lr ls jr lt lu lv ju lw lx ly lz ma mb mc md me mf mg mh mi mj ij bi translated">首先，让我们看看我们的问题陈述。</p><h2 id="53bd" class="mp kx iq bd ky mq mr dn lc ms mt dp lg lx mu mv li mb mw mx lk mf my mz lm na bi translated">要设计的系统</h2><p id="f8d0" class="pw-post-body-paragraph lo lp iq lq b lr ls jr lt lu lv ju lw lx ly lz ma mb mc md me mf mg mh mi mj ij bi translated">我们希望设计一个视频点播平台，如<a class="ae kv" href="https://www.youtube.com/" rel="noopener ugc nofollow" target="_blank"> YouTube </a>或<a class="ae kv" href="https://www.netflix.com/gb/" rel="noopener ugc nofollow" target="_blank">网飞</a>。你不可能没有遇到过它们，但如果你没有遇到过，前提是用户可以在线上传或观看视频。确切的要求是:</p><ol class=""><li id="e809" class="nb nc iq lq b lr mk lu ml lx nd mb ne mf nf mj ng nh ni nj bi translated">我们应该可以上传视频。</li><li id="080a" class="nb nc iq lq b lr nk lu nl lx nm mb nn mf no mj ng nh ni nj bi translated">我们应该可以观看视频。</li><li id="295b" class="nb nc iq lq b lr nk lu nl lx nm mb nn mf no mj ng nh ni nj bi translated">我们应该能够根据视频标题进行搜索。</li></ol><p id="bf1b" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">我们会忽略一个事实，即你不能上传视频到网飞，除非你是一个制作工作室。假设你是昆汀·塔伦蒂诺。</p><h2 id="e3bf" class="mp kx iq bd ky mq mr dn lc ms mt dp lg lx mu mv li mb mw mx lk mf my mz lm na bi translated">方法</h2><p id="166d" class="pw-post-body-paragraph lo lp iq lq b lr ls jr lt lu lv ju lw lx ly lz ma mb mc md me mf mg mh mi mj ij bi translated">我们有一个标准的系统设计方法，在本文<a class="ae kv" href="https://jc1175.medium.com/how-i-would-design-a-url-shortener-a4c8d4ec8889" rel="noopener">中有更详细的解释。但是，这些步骤总结如下:</a></p><ol class=""><li id="89ea" class="nb nc iq lq b lr mk lu ml lx nd mb ne mf nf mj ng nh ni nj bi translated"><strong class="lq ir">需求澄清:</strong>确保我们在开始之前有所有的信息。这可能包括我们预期有多少请求或用户。</li><li id="9d3b" class="nb nc iq lq b lr nk lu nl lx nm mb nn mf no mj ng nh ni nj bi translated"><strong class="lq ir">包络估计的背面:</strong>进行一些快速计算，以评估必要的系统性能。例如，我们需要多少存储或带宽？</li><li id="2405" class="nb nc iq lq b lr nk lu nl lx nm mb nn mf no mj ng nh ni nj bi translated"><strong class="lq ir">系统界面设计:</strong>我们的系统从外面看会是什么样子，人们会如何与之交互？通常这是API合同。</li><li id="b6d3" class="nb nc iq lq b lr nk lu nl lx nm mb nn mf no mj ng nh ni nj bi translated"><strong class="lq ir">数据模型设计:</strong>我们的数据存储起来会是什么样子。在这一点上，我们可以考虑关系模型和非关系模型。</li><li id="0b61" class="nb nc iq lq b lr nk lu nl lx nm mb nn mf no mj ng nh ni nj bi translated">逻辑设计:把它组合成一个粗略的系统！在这一点上，我在思考“我该如何向一个对技术一无所知的人解释我的想法？”</li><li id="578e" class="nb nc iq lq b lr nk lu nl lx nm mb nn mf no mj ng nh ni nj bi translated">物理设计:现在我们开始担心服务器、编程语言和实现细节。我们可以将这些叠加在逻辑设计之上。</li><li id="5a43" class="nb nc iq lq b lr nk lu nl lx nm mb nn mf no mj ng nh ni nj bi translated"><strong class="lq ir">识别并解决瓶颈:</strong>在这个阶段，我们将拥有一个可运行的系统！我们现在改进设计。</li></ol><p id="7d12" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">说完了，我们开始吧！</p><h2 id="454e" class="mp kx iq bd ky mq mr dn lc ms mt dp lg lx mu mv li mb mw mx lk mf my mz lm na bi translated">需求澄清</h2><p id="8e3e" class="pw-post-body-paragraph lo lp iq lq b lr ls jr lt lu lv ju lw lx ly lz ma mb mc md me mf mg mh mi mj ij bi translated">我们来想一些初始问题。最初，我想知道一个视频的最大和平均大小是多少。然后我会考虑用户数量和他们的读/写/搜索比率。</p><p id="f5aa" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">此外，客户端使用什么设备/连接速度？基于此，我们可能需要优化我们的文件格式和大小。</p><h2 id="62ed" class="mp kx iq bd ky mq mr dn lc ms mt dp lg lx mu mv li mb mw mx lk mf my mz lm na bi translated">包络估计的背面</h2><p id="ee82" class="pw-post-body-paragraph lo lp iq lq b lr ls jr lt lu lv ju lw lx ly lz ma mb mc md me mf mg mh mi mj ij bi translated">假设我们有1亿用户(实际上可能更多！)，阅读和写作达到每天100:1的比例。对于HD，平均文件大小为1GB，最大文件大小为50GB(不管这些大小有多精确)。</p><p id="8045" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">这意味着我们将有大约<code class="fe np nq nr ns b">100,000,000 * 1GB = 100PB/d</code>的上传容量！在给定平均视频长度的情况下，我们可以用每秒请求数来计算，但可以肯定地说，我们正在处理大量数据！</p><p id="b73c" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">这也是一个全球系统，因此我们可以假设我们将在一系列网络上使用许多不同的设备，从移动设备到嵌入式设备，因此我们需要为此进行防御性设计。</p><h2 id="e2c7" class="mp kx iq bd ky mq mr dn lc ms mt dp lg lx mu mv li mb mw mx lk mf my mz lm na bi translated">系统界面设计</h2><p id="2f08" class="pw-post-body-paragraph lo lp iq lq b lr ls jr lt lu lv ju lw lx ly lz ma mb mc md me mf mg mh mi mj ij bi translated">对我们的系统有了更多的了解后，我们可以决定如何与它互动。交互主要有三点。</p><ol class=""><li id="aa71" class="nb nc iq lq b lr mk lu ml lx nd mb ne mf nf mj ng nh ni nj bi translated">上传视频</li><li id="2710" class="nb nc iq lq b lr nk lu nl lx nm mb nn mf no mj ng nh ni nj bi translated">下载视频</li><li id="dd5c" class="nb nc iq lq b lr nk lu nl lx nm mb nn mf no mj ng nh ni nj bi translated">搜索</li></ol><p id="5f0a" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">上传视频将通过HTTP完成。我们需要注意的一件事是文件的大小。在不同的场景中，我们可能会使用<a class="ae kv" href="https://en.wikipedia.org/wiki/File_Transfer_Protocol" rel="noopener ugc nofollow" target="_blank"> FTP </a>，但是考虑到我们在互联网上有随机的用户，这在这里并没有什么意义。</p><p id="5c07" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">我建议创建一个初始表单来提交与文件相关的元数据(标题、标签、任何不是视频本身的东西)，它将返回一个与文件相关联的GGUID。</p><p id="7c38" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">从那里，我们可以使用JavaScript <a class="ae kv" href="https://developer.mozilla.org/en-US/docs/Web/API/File" rel="noopener ugc nofollow" target="_blank">文件</a>和<a class="ae kv" href="https://developer.mozilla.org/en-US/docs/Web/API/Blob" rel="noopener ugc nofollow" target="_blank">Blob</a>API来<a class="ae kv" href="https://api.video/blog/tutorials/uploading-large-files-with-javascript" rel="noopener ugc nofollow" target="_blank">剪切视频文件并发送部分请求</a>，其中<a class="ae kv" href="https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Content-Range" rel="noopener ugc nofollow" target="_blank"> Content-Range </a>头表示该请求所代表的字节范围。我们的内容类型是<code class="fe np nq nr ns b">application/octet-stream</code>,服务器负责重组这些部分。</p><p id="d807" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">这意味着我们需要一个端点来创建一个文件，在端点<code class="fe np nq nr ns b">/file</code>处的<code class="fe np nq nr ns b">POST</code>用元数据创建一个新的文件对象，然后在<code class="fe np nq nr ns b">POST</code>处的另一个端点<code class="fe np nq nr ns b">file/{id}/chunk</code>允许用户发布一个块。</p><p id="94f1" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">我们还可以考虑在客户机上对文件进行散列，然后在服务器上重组文件后比较散列，以确保它匹配。</p><p id="fea4" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">下载可以利用<a class="ae kv" href="https://developer.mozilla.org/en-US/docs/Web/HTTP/Range_requests" rel="noopener ugc nofollow" target="_blank"> HTTP范围请求</a>。这允许我们一次请求视频的一部分(返回一个<code class="fe np nq nr ns b">206</code>)，这意味着我们可以在需要时动态地请求视频片段。使用带有内容范围标题的<code class="fe np nq nr ns b">GET file/{id}/chunk</code>可能是一种解决方案。</p><p id="6867" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">幸运的是，搜索稍微简单一些，我们可以<code class="fe np nq nr ns b">GET</code>到<code class="fe np nq nr ns b">/search?title=&lt;search title&gt;</code>并接收通常的响应代码。</p><h2 id="c17c" class="mp kx iq bd ky mq mr dn lc ms mt dp lg lx mu mv li mb mw mx lk mf my mz lm na bi translated">数据模型设计</h2><p id="deed" class="pw-post-body-paragraph lo lp iq lq b lr ls jr lt lu lv ju lw lx ly lz ma mb mc md me mf mg mh mi mj ij bi translated">现在我们有了如何与系统交互的想法，让我们考虑一下我们想要存储的数据类型。其中一些将基于视频字节，一些将基于元数据。</p><p id="1434" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">最初，让我们考虑一个文件。一个文件可以存储一系列信息:标题、创建日期、上传者、点击次数等等。</p><p id="4912" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated"><strong class="lq ir">文件</strong></p><pre class="kg kh ki kj gt nt ns nu nv aw nw bi"><span id="1a00" class="mp kx iq ns b gy nx ny l nz oa">id               BIGINT    PRIMARY KEY <br/>title            VARCHAR</span></pre><p id="486d" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">我们现在需要考虑我们的文件块。请记住，我们需要为大量网络和设备提供服务！这意味着我们希望以多种不同的质量和文件格式来存储数据块。随着像AWS S3这样的对象存储的出现，我们可以引用我们的文件在S3的位置。</p><p id="141b" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated"><strong class="lq ir">组块</strong></p><pre class="kg kh ki kj gt nt ns nu nv aw nw bi"><span id="4ad0" class="mp kx iq ns b gy nx ny l nz oa">id           BIGINT    PRIMARY KEY <br/>file_id      BIGINT    FOREIGN KEY REFERENCES file(id)<br/>format       VARCHAR<br/>quality      BIGINT<br/>order        BIGINT    <br/>location     VARCHAR</span></pre><p id="b818" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">使用上面的内容，我们可以识别块属于哪个文件，块的格式，块的大小以及它代表文件的哪个位。</p><p id="58d3" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">这构成了我们数据模型的核心。让我们进入逻辑设计！</p><h2 id="a1d2" class="mp kx iq bd ky mq mr dn lc ms mt dp lg lx mu mv li mb mw mx lk mf my mz lm na bi translated">逻辑设计</h2><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi ob"><img src="../Images/218ec73fef8a53d86c0f9a40d4dea3eb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*kZIcukeiIQmjSVnRt6twLw.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">基本的逻辑设计</p></figure><p id="c5c4" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">我们可以通过逻辑设计将各种组件组合在一起。当用户想要上传文件时，他们向文件服务发送请求以创建新的文件元数据。然后，他们的浏览器将文件分成块，并上传到文件块写服务。</p><p id="494d" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">该文件分块服务负责将来自客户端的分块组装成单个文件，对其进行验证，并将其拆分成媒体播放器更容易使用的不同分块。</p><p id="2fe9" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">从这里开始，我们坚持使用一个队列，以便在文件编码服务关闭的情况下为我们提供一个弹性层。现在可以向用户返回接受消息，我们已经有了文件，只需要处理它。</p><p id="e18f" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">文件编码服务获取文件的块，并将其转换为不同的格式和质量以用于不同的服务。值得注意的一点是，编码和代码转换是有区别的。</p><ul class=""><li id="8ccf" class="nb nc iq lq b lr mk lu ml lx nd mb ne mf nf mj oc nh ni nj bi translated"><strong class="lq ir">转码</strong>:创建不同大小的文件。</li><li id="13f8" class="nb nc iq lq b lr nk lu nl lx nm mb nn mf no mj oc nh ni nj bi translated"><strong class="lq ir">编码</strong>:将文件重新编码成不同的格式。</li></ul><p id="9a34" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">编码包括代码转换，这就是我们在这里使用这个术语的原因。</p><p id="61e0" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">该服务负责将我们的块写入存储，并使用它们的位置更新我们的文件元数据。</p><p id="961b" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">读取请求也通过API网关，但如果他们请求视频流，则被重定向到我们的文件块读取服务，如果他们寻找元数据，则被重定向到我们的文件服务。</p><p id="5466" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">客户端将负责确定他们需要文件的哪些块，并发出必要的请求以加载下一部分。</p><p id="2ab7" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">搜索功能应该相当简单。文件服务会将文件元数据添加到搜索引擎中，因此搜索服务负责将URL查询转换为搜索引擎可以使用的内容，然后编组响应。</p><h2 id="2b5c" class="mp kx iq bd ky mq mr dn lc ms mt dp lg lx mu mv li mb mw mx lk mf my mz lm na bi translated">结构设计</h2><p id="604e" class="pw-post-body-paragraph lo lp iq lq b lr ls jr lt lu lv ju lw lx ly lz ma mb mc md me mf mg mh mi mj ij bi translated">现在我们已经讨论了如何构建我们的平台的大致想法，让我们在现实世界中将其具体化。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi od"><img src="../Images/344b7ba81623bcb807b68700fc03799d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Fp3CqmzZ-9iKLQAzvuxXPg.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">幼稚的物理设计</p></figure><p id="6c90" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">甚至在我写这篇文章的时候，我就发现了这个设计的一些问题。但是，让我们探索一下，我们可以在下一节中对其进行改进。</p><p id="a8f0" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">最初，我们所有的静态服务都使用<a class="ae kv" href="https://aws.amazon.com/ecs/" rel="noopener ugc nofollow" target="_blank"> AWS ECS </a>。有一种观点认为我们可以完全没有服务器，但我的感觉是我们不想担心冷启动时间。我们的网关是一个<a class="ae kv" href="https://aws.amazon.com/api-gateway/" rel="noopener ugc nofollow" target="_blank"> AWS API网关</a>，我们的队列使用<a class="ae kv" href="https://aws.amazon.com/sqs/" rel="noopener ugc nofollow" target="_blank"> SQS </a>。</p><p id="19e9" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">我们将块存储在<a class="ae kv" href="https://aws.amazon.com/s3/" rel="noopener ugc nofollow" target="_blank"> S3 </a>中，并使用<a class="ae kv" href="https://aws.amazon.com/mediaconvert/" rel="noopener ugc nofollow" target="_blank">AWS Elemental media convert</a>进行编码。搜索引擎本身就是<a class="ae kv" href="https://aws.amazon.com/pm/opensearch/" rel="noopener ugc nofollow" target="_blank">亚马逊OpenSearch </a>。</p><h2 id="7e6c" class="mp kx iq bd ky mq mr dn lc ms mt dp lg lx mu mv li mb mw mx lk mf my mz lm na bi translated">识别和解决瓶颈</h2><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi oe"><img src="../Images/8dea6fe9bcf712171f91c38a294cd23f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*0Zbvm1na_X7Lv7DiygQO_A.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">修改后的图表</p></figure><p id="51a9" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">我们提到我们可以进行一些性能改进。最初，我专注于我们接收的数据量。我们需要一个能够实时处理大量信息的弹性系统。这听起来像是流媒体的工作。</p><p id="f060" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">从图中你可以看到我们的API网关现在写入到一个<a class="ae kv" href="https://aws.amazon.com/kinesis/data-streams/" rel="noopener ugc nofollow" target="_blank"> Kinesis流</a>，它反过来推送到<a class="ae kv" href="https://aws.amazon.com/emr/" rel="noopener ugc nofollow" target="_blank"> AWS EMR </a>(可能有Spark流)来处理和重新分块我们的文件。</p><p id="c858" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">因为我们的文件元数据很少会改变，所以我们还可以向我们的读取服务添加一个缓存层。</p><p id="c087" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">我们还可以实现<a class="ae kv" href="https://bitmovin.com/adaptive-streaming/" rel="noopener ugc nofollow" target="_blank">自适应比特率流</a>，这在链接文章中有很好的介绍。在我们的编码器中，我们制作了不同质量的相同文件的块。使用这种技术，我们可以根据streamer连接的当前状态被动地发送不同质量的数据块。</p><p id="0d89" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">优化的最后一部分是添加CDN。由于我们的用户遍布世界各地，我们不希望他们都试图从英国的服务器上访问他们的视频。尝试将我们的内容分发到离它们更近的地方是有意义的。注意，网飞其实对这个问题有自己的解决方案叫做<a class="ae kv" href="https://openconnect.netflix.com/en_gb/" rel="noopener ugc nofollow" target="_blank"> Open Connect </a>，值得一看！</p><h1 id="9871" class="kw kx iq bd ky kz la lb lc ld le lf lg jw lh jx li jz lj ka lk kc ll kd lm ln bi translated">结论</h1><p id="f8f8" class="pw-post-body-paragraph lo lp iq lq b lr ls jr lt lu lv ju lw lx ly lz ma mb mc md me mf mg mh mi mj ij bi translated">总之，我们已经讨论了如何设计一个YouTube或网飞风格的平台。值得注意的是，网飞为这个问题专门开发了<a class="ae kv" href="https://spring.io/projects/spring-cloud-netflix" rel="noopener ugc nofollow" target="_blank">多种工具。</a></p><p id="2102" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">一些例子包括:</p><ul class=""><li id="2f45" class="nb nc iq lq b lr mk lu ml lx nd mb ne mf nf mj oc nh ni nj bi translated"><a class="ae kv" href="https://github.com/Netflix/zuul" rel="noopener ugc nofollow" target="_blank"> Zuul </a>:一个应用网关。</li><li id="12ee" class="nb nc iq lq b lr nk lu nl lx nm mb nn mf no mj oc nh ni nj bi translated"><a class="ae kv" href="https://github.com/Netflix/Hystrix" rel="noopener ugc nofollow" target="_blank"> Hystrix </a>(已弃用):一个断路器。</li><li id="360e" class="nb nc iq lq b lr nk lu nl lx nm mb nn mf no mj oc nh ni nj bi translated"><a class="ae kv" href="https://github.com/Netflix/eureka" rel="noopener ugc nofollow" target="_blank">尤里卡</a>:服务发现。</li><li id="781c" class="nb nc iq lq b lr nk lu nl lx nm mb nn mf no mj oc nh ni nj bi translated"><a class="ae kv" href="https://github.com/OpenFeign/feign" rel="noopener ugc nofollow" target="_blank">假装</a> : HTTP客户端绑定器。</li></ul><p id="0afd" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">看看他们！</p></div></div>    
</body>
</html>