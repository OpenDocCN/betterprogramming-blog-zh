<html>
<head>
<title>10 Things Every Angular Developer Should Know About Zone.js</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">每个Angular开发人员都应该知道的关于Zone.js的10件事</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/zone-js-for-angular-devs-573d89bbb890?source=collection_archive---------1-----------------------#2019-10-08">https://betterprogramming.pub/zone-js-for-angular-devs-573d89bbb890?source=collection_archive---------1-----------------------#2019-10-08</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="9e77" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">每个开发人员都应该了解Zone.js的基础知识</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/11b2dcfc593bd6d96e9fb72473822df9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*25FxPamWikrbQMr4Inu7oA.jpeg"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">Anton Scherbakov 在<a class="ae ky" href="https://unsplash.com/s/photos/meerkat?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</p></figure></div><div class="ab cl kz la hx lb" role="separator"><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le"/></div><div class="im in io ip iq"><h1 id="2347" class="lg lh it bd li lj lk ll lm ln lo lp lq jz lr ka ls kc lt kd lu kf lv kg lw lx bi translated">1.我为什么要关心Zone.js？</h1><p id="b08f" class="pw-post-body-paragraph ly lz it ma b mb mc ju md me mf jx mg mh mi mj mk ml mm mn mo mp mq mr ms mt im bi translated">Angular引入了<a class="ae ky" href="https://github.com/angular/zone.js/" rel="noopener ugc nofollow" target="_blank"> Zone.js </a>来处理变化检测。这允许Angular决定何时刷新UI。通常情况下，你不必关心这些，因为Zone.js就可以工作。</p><p id="e6e9" class="pw-post-body-paragraph ly lz it ma b mb mu ju md me mv jx mg mh mw mj mk ml mx mn mo mp my mr ms mt im bi translated">然而，如果Zone.js出了问题，分析和理解起来会非常令人沮丧。这就是为什么每个开发人员都应该了解一些关于Zone.js的基础知识。</p></div><div class="ab cl kz la hx lb" role="separator"><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le"/></div><div class="im in io ip iq"><h1 id="0c76" class="lg lh it bd li lj lk ll lm ln lo lp lq jz lr ka ls kc lt kd lu kf lv kg lw lx bi translated">2.一言以蔽之:Zone.js是如何工作的？</h1><p id="f1a0" class="pw-post-body-paragraph ly lz it ma b mb mc ju md me mf jx mg mh mi mj mk ml mm mn mo mp mq mr ms mt im bi translated">Zone.js修补了所有常见的异步API，如<code class="fe mz na nb nc b">setTimeout</code>、<code class="fe mz na nb nc b">setInterval</code>、promise API等。跟踪所有异步操作。</p><p id="ee73" class="pw-post-body-paragraph ly lz it ma b mb mu ju md me mv jx mg mh mw mj mk ml mx mn mo mp my mr ms mt im bi translated">以下是您应该了解的基本概念:</p><h2 id="1e18" class="nd lh it bd li ne nf dn lm ng nh dp lq mh ni nj ls ml nk nl lu mp nm nn lw no bi translated"><strong class="ak">区域</strong></h2><p id="0f88" class="pw-post-body-paragraph ly lz it ma b mb mc ju md me mf jx mg mh mi mj mk ml mm mn mo mp mq mr ms mt im bi translated">区域是一种拦截和跟踪异步工作的机制。</p><h2 id="ea63" class="nd lh it bd li ne nf dn lm ng nh dp lq mh ni nj ls ml nk nl lu mp nm nn lw no bi translated"><strong class="ak">任务</strong></h2><p id="6e29" class="pw-post-body-paragraph ly lz it ma b mb mc ju md me mf jx mg mh mi mj mk ml mm mn mo mp mq mr ms mt im bi translated">对于每个异步操作，Zone.js都会创建一个任务。任务在一个区域中运行。</p><h2 id="9f8d" class="nd lh it bd li ne nf dn lm ng nh dp lq mh ni nj ls ml nk nl lu mp nm nn lw no bi translated"><strong class="ak"> NgZone </strong></h2><p id="07a0" class="pw-post-body-paragraph ly lz it ma b mb mc ju md me mf jx mg mh mi mj mk ml mm mn mo mp mq mr ms mt im bi translated">默认情况下，在Angular应用程序中，每个任务都在“Angular”区域运行，这被称为<code class="fe mz na nb nc b">NgZone</code>。只有一个角度区域，变化检测仅针对在<code class="fe mz na nb nc b">NgZone</code>中运行的异步操作触发。</p><h2 id="a91d" class="nd lh it bd li ne nf dn lm ng nh dp lq mh ni nj ls ml nk nl lu mp nm nn lw no bi translated"><strong class="ak">根区域/分支</strong></h2><p id="ea28" class="pw-post-body-paragraph ly lz it ma b mb mc ju md me mf jx mg mh mi mj mk ml mm mn mo mp mq mr ms mt im bi translated">Zone.js区域是分层的，这意味着您总是从顶级区域开始，即“根”区域。可以通过分叉根区域来创建新区域。NgZone也是根区域的一个分支。</p><h2 id="1bde" class="nd lh it bd li ne nf dn lm ng nh dp lq mh ni nj ls ml nk nl lu mp nm nn lw no bi translated"><strong class="ak">区域规格</strong></h2><p id="7ca3" class="pw-post-body-paragraph ly lz it ma b mb mc ju md me mf jx mg mh mi mj mk ml mm mn mo mp mq mr ms mt im bi translated">派生一个区域时，将基于一个<code class="fe mz na nb nc b">ZoneSpec</code>创建一个新的区域。一个<code class="fe mz na nb nc b">ZoneSpec</code>可以只包含一个新的子区域的名称，或者可以包含各种钩子方法，这些方法可以用来拦截某些区域/任务事件。</p><p id="d2f0" class="pw-post-body-paragraph ly lz it ma b mb mu ju md me mv jx mg mh mw mj mk ml mx mn mo mp my mr ms mt im bi translated">还有更多概念，如果您想了解更多关于Zone.js如何工作的信息，您可以在这里找到更多信息:</p><div class="np nq gp gr nr ns"><a href="https://blog.thoughtram.io/angular/2016/01/22/understanding-zones.html" rel="noopener  ugc nofollow" target="_blank"><div class="nt ab fo"><div class="nu ab nv cl cj nw"><h2 class="bd iu gy z fp nx fr fs ny fu fw is bi translated">了解区域</h2><div class="nz l"><h3 class="bd b gy z fp nx fr fs ny fu fw dk translated">加入我们即将到来的公开培训！获得入场券→在NG-Conf 2014上，Brian就区域以及它们如何……</h3></div><div class="oa l"><p class="bd b dl z fp nx fr fs ny fu fw dk translated">blog.thoughtram.io</p></div></div><div class="ob l"><div class="oc l od oe of ob og ks ns"/></div></div></a></div></div><div class="ab cl kz la hx lb" role="separator"><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le"/></div><div class="im in io ip iq"><h1 id="080d" class="lg lh it bd li lj lk ll lm ln lo lp lq jz lr ka ls kc lt kd lu kf lv kg lw lx bi translated">3.您不必将Zone.js与Angular一起使用(但您可能应该这样做)</h1><p id="430e" class="pw-post-body-paragraph ly lz it ma b mb mc ju md me mf jx mg mh mi mj mk ml mm mn mo mp mq mr ms mt im bi translated">通过传递一个<code class="fe mz na nb nc b">noop</code> Zone，Zone.js可以在Angular应用程序的引导过程中很容易地被停用。然而，您放弃了变化检测，这意味着您必须自己决定UI何时刷新(例如，通过<code class="fe mz na nb nc b">ChangeDetectorRef.detectChanges()</code>)。</p><p id="b16a" class="pw-post-body-paragraph ly lz it ma b mb mu ju md me mv jx mg mh mw mj mk ml mx mn mo mp my mr ms mt im bi translated">一般来说，不建议这样做，因为你放弃了自动变化检测的便利，但是，对于自定义元素(角元素)来说，这可能是有意义的。</p><p id="905e" class="pw-post-body-paragraph ly lz it ma b mb mu ju md me mv jx mg mh mw mj mk ml mx mn mo mp my mr ms mt im bi translated">关于如何禁用Zone.js的更多细节可以在<a class="ae ky" href="https://www.softwarearchitekt.at/aktuelles/angular-elements-part-iii/" rel="noopener ugc nofollow" target="_blank"> Software Architect </a>找到。</p></div><div class="ab cl kz la hx lb" role="separator"><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le"/></div><div class="im in io ip iq"><h1 id="f9a9" class="lg lh it bd li lj lk ll lm ln lo lp lq jz lr ka ls kc lt kd lu kf lv kg lw lx bi translated">4.自动变更检测很好，但是如果我想要控制呢？</h1><p id="1c1a" class="pw-post-body-paragraph ly lz it ma b mb mc ju md me mf jx mg mh mi mj mk ml mm mn mo mp mq mr ms mt im bi translated">在某些情况下，您可能会因为频繁触发变更检测而遇到问题，这可能会导致性能问题。</p><p id="c3b6" class="pw-post-body-paragraph ly lz it ma b mb mu ju md me mv jx mg mh mw mj mk ml mx mn mo mp my mr ms mt im bi translated">如果您仍然想要Zone.js的好处，但是想要控制什么触发更改检测，什么不触发，您仍然可以这样做。</p><p id="d3cd" class="pw-post-body-paragraph ly lz it ma b mb mu ju md me mv jx mg mh mw mj mk ml mx mn mo mp my mr ms mt im bi translated">通过注入<code class="fe mz na nb nc b">NgZone</code>，您可以获得一个API来决定异步操作是在<code class="fe mz na nb nc b">NgZone</code>内部还是外部运行。方法<code class="fe mz na nb nc b"><a class="ae ky" href="https://angular.io/api/core/NgZone#runOutsideAngular" rel="noopener ugc nofollow" target="_blank">runOutsideAngular</a></code>可用于在<code class="fe mz na nb nc b">NgZone</code>之外运行代码，因此不会触发变更检测。</p><p id="be65" class="pw-post-body-paragraph ly lz it ma b mb mu ju md me mv jx mg mh mw mj mk ml mx mn mo mp my mr ms mt im bi translated">这里有一个例子:</p><pre class="kj kk kl km gt oh nc oi oj aw ok bi"><span id="0015" class="nd lh it nc b gy ol om l on oo">constructor(private ngZone: NgZone) {</span><span id="6ae4" class="nd lh it nc b gy op om l on oo">  this.ngZone.runOutsideAngular(() =&gt; {<br/>    // this will not trigger change detection<br/>    setInterval(() =&gt; doSomething(), 100)<br/>  });<br/>}</span></pre></div><div class="ab cl kz la hx lb" role="separator"><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le"/></div><div class="im in io ip iq"><h1 id="0953" class="lg lh it bd li lj lk ll lm ln lo lp lq jz lr ka ls kc lt kd lu kf lv kg lw lx bi translated">5.Zone.js如何影响量角器测试？</h1><p id="aee9" class="pw-post-body-paragraph ly lz it ma b mb mc ju md me mf jx mg mh mi mj mk ml mm mn mo mp mq mr ms mt im bi translated">一旦不再运行异步操作，区域就稳定了。“健康”区域开始时稳定，然后运行一些任务，这意味着该区域变得“不稳定”，在某个时间点，任务完成，这意味着该区域再次变得稳定。</p><p id="a1cd" class="pw-post-body-paragraph ly lz it ma b mb mu ju md me mv jx mg mh mw mj mk ml mx mn mo mp my mr ms mt im bi translated">这和量角器有什么关系？如果你在E2E测试中使用<code class="fe mz na nb nc b">browser.waitForAngular</code>，量角器会检查<code class="fe mz na nb nc b">NgZone</code>来决定测试是否可以继续。</p><p id="a6ab" class="pw-post-body-paragraph ly lz it ma b mb mu ju md me mv jx mg mh mw mj mk ml mx mn mo mp my mr ms mt im bi translated">所以，在你发送给浏览器的每一个命令之后，量角器会一直等到区域稳定下来，然后才继续。例如，如果您使用的<code class="fe mz na nb nc b">setInterval</code>间隔时间很短，这将意味着<code class="fe mz na nb nc b">NgZone</code>永远不会稳定，您的测试将会冻结和超时。</p><p id="f777" class="pw-post-body-paragraph ly lz it ma b mb mu ju md me mv jx mg mh mw mj mk ml mx mn mo mp my mr ms mt im bi translated">这类问题可以通过在角度区域之外长时间运行或重复运行任务来解决。</p></div><div class="ab cl kz la hx lb" role="separator"><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le"/></div><div class="im in io ip iq"><h1 id="55f7" class="lg lh it bd li lj lk ll lm ln lo lp lq jz lr ka ls kc lt kd lu kf lv kg lw lx bi translated">6.RxJS如何与Zone.js配合使用？</h1><p id="2e9d" class="pw-post-body-paragraph ly lz it ma b mb mc ju md me mf jx mg mh mi mj mk ml mm mn mo mp mq mr ms mt im bi translated">默认情况下，Zone.js和<a class="ae ky" href="https://rxjs-dev.firebaseapp.com/" rel="noopener ugc nofollow" target="_blank"> RxJS </a>可能不会像您预期的那样运行。例如，您可能将您的可观察代码包装在一个函数中，并将其传递给<code class="fe mz na nb nc b">NgZone.runOutsideAngular</code>，并且仍然以运行在<code class="fe mz na nb nc b">NgZone</code>中的任务结束。</p><p id="3f33" class="pw-post-body-paragraph ly lz it ma b mb mu ju md me mv jx mg mh mw mj mk ml mx mn mo mp my mr ms mt im bi translated">当使用RxJS时，您应该总是从Zone.js导入补丁，这提供了更合理的行为。在订阅、操作或观察的构建时间，它将记住当前区域，并且将总是在记住的区域中运行，而不管您在哪里订阅。</p><p id="adaa" class="pw-post-body-paragraph ly lz it ma b mb mu ju md me mv jx mg mh mw mj mk ml mx mn mo mp my mr ms mt im bi translated">您可以在导入Zone.js(通常在<code class="fe mz na nb nc b">polyfill.ts</code>)后导入补丁:</p><pre class="kj kk kl km gt oh nc oi oj aw ok bi"><span id="8c9a" class="nd lh it nc b gy ol om l on oo">import ‘zone.js/dist/zone-patch-rxjs’;</span></pre><p id="9230" class="pw-post-body-paragraph ly lz it ma b mb mu ju md me mv jx mg mh mw mj mk ml mx mn mo mp my mr ms mt im bi translated">在<a class="ae ky" href="https://github.com/angular/zone.js/blob/master/NON-STANDARD-APIS.md" rel="noopener ugc nofollow" target="_blank">文档</a>中可以找到一个很好的例子。</p></div><div class="ab cl kz la hx lb" role="separator"><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le"/></div><div class="im in io ip iq"><h1 id="6277" class="lg lh it bd li lj lk ll lm ln lo lp lq jz lr ka ls kc lt kd lu kf lv kg lw lx bi translated">7.如何从Zone.js中排除某些事件</h1><p id="858e" class="pw-post-body-paragraph ly lz it ma b mb mc ju md me mf jx mg mh mi mj mk ml mm mn mo mp mq mr ms mt im bi translated">如果出于某种原因，您不希望对某些事件类型(<code class="fe mz na nb nc b">Scroll-Events</code>，…)进行更改检测，您可以将这些事件类型全局列入黑名单。</p><p id="bd55" class="pw-post-body-paragraph ly lz it ma b mb mu ju md me mv jx mg mh mw mj mk ml mx mn mo mp my mr ms mt im bi translated">但是，请记住，在这些情况下，您必须手动触发变更检测。如何做到这一点的例子可以在<code class="fe mz na nb nc b"><a class="ae ky" href="https://github.com/angular/zone.js/blob/master/STANDARD-APIS.md" rel="noopener ugc nofollow" target="_blank">BlackListEvents</a></code>下的文档中找到。</p></div><div class="ab cl kz la hx lb" role="separator"><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le"/></div><div class="im in io ip iq"><h1 id="198e" class="lg lh it bd li lj lk ll lm ln lo lp lq jz lr ka ls kc lt kd lu kf lv kg lw lx bi translated">8.用Zone.js怎么分析问题？</h1><p id="2329" class="pw-post-body-paragraph ly lz it ma b mb mc ju md me mf jx mg mh mi mj mk ml mm mn mo mp mq mr ms mt im bi translated">第一次调试Zone.js问题时，这可能是一项艰巨的任务。</p><p id="56f8" class="pw-post-body-paragraph ly lz it ma b mb mu ju md me mv jx mg mh mw mj mk ml mx mn mo mp my mr ms mt im bi translated">区域不提供用于检查计划的/当前运行的任务的API。此外，有时很难确定任务实际上来自哪里，因为在堆栈跟踪中，您只能看到与区域相关的条目。</p><p id="1a3c" class="pw-post-body-paragraph ly lz it ma b mb mu ju md me mv jx mg mh mw mj mk ml mx mn mo mp my mr ms mt im bi translated">幸运的是，Zone.js提供了一些工具，可以帮助理解正在发生的事情。</p><p id="4840" class="pw-post-body-paragraph ly lz it ma b mb mu ju md me mv jx mg mh mw mj mk ml mx mn mo mp my mr ms mt im bi translated">Zone.js包含一些区域规范，可以用来构建区域，从中我们可以派生出我们想要研究的区域。有两个<code class="fe mz na nb nc b">ZoneSpecs</code>非常有用:</p><ul class=""><li id="e420" class="oq or it ma b mb mu me mv mh os ml ot mp ou mt ov ow ox oy bi translated"><code class="fe mz na nb nc b">TaskTrackingZoneSpec</code> : <strong class="ma iu"> </strong>可以用来跟踪所有当前的任务，并提供一个API来检查它们。</li><li id="5d00" class="oq or it ma b mb oz me pa mh pb ml pc mp pd mt ov ow ox oy bi translated"><code class="fe mz na nb nc b">LongStackTrace</code> : <strong class="ma iu"> </strong>为每个任务记住所有前置任务的所有堆栈跟踪。所以，你基本上有一个大的堆栈跟踪，覆盖所有异步步骤，导致你想要检查的任务的创建。</li></ul><p id="ec10" class="pw-post-body-paragraph ly lz it ma b mb mu ju md me mv jx mg mh mw mj mk ml mx mn mo mp my mr ms mt im bi translated">这里有一小段关于如何使用这些技术来检查角度区域的内容:</p><pre class="kj kk kl km gt oh nc oi oj aw ok bi"><span id="a9fa" class="nd lh it nc b gy ol om l on oo">// increase stack trace length (optional)<br/>Error.stackTraceLimit = 100;<br/>const longStackTraceZoneSpec = Zone.longStackTraceZoneSpec;</span><span id="9b3f" class="nd lh it nc b gy op om l on oo">// increase stack trace limit (optional)<br/>longStackTraceZoneSpec.longStackTraceLimit = 1000;</span><span id="b62e" class="nd lh it nc b gy op om l on oo">Zone.current<br/>.fork(new Zone.TaskTrackingZoneSpec())<br/>.fork(longStackTraceZoneSpec)<br/>.run(() =&gt; {<br/>   // NgZone forks currentZone, which is here longStackTraceZone<br/>   const ngZone = new NgZone({enableLongStackTrace: true});<br/>   platformBrowserDynamic()<br/>      .bootstrapModule(AppModule, {ngZone: ngZone});<br/>});</span></pre><p id="10b5" class="pw-post-body-paragraph ly lz it ma b mb mu ju md me mv jx mg mh mw mj mk ml mx mn mo mp my mr ms mt im bi translated">然后，您可以访问<code class="fe mz na nb nc b">macroTask</code>类型的任务，如下所示:</p><pre class="kj kk kl km gt oh nc oi oj aw ok bi"><span id="7605" class="nd lh it nc b gy ol om l on oo">let macroTasks = Zone.current<br/> // get the TaskTrackingZone via it's name<br/> .get(‘TaskTrackingZone’)<br/> .getTasksFor(‘macroTask')</span></pre></div><div class="ab cl kz la hx lb" role="separator"><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le"/></div><div class="im in io ip iq"><h1 id="449d" class="lg lh it bd li lj lk ll lm ln lo lp lq jz lr ka ls kc lt kd lu kf lv kg lw lx bi translated">9.什么是微观和宏观任务？</h1><p id="611b" class="pw-post-body-paragraph ly lz it ma b mb mc ju md me mf jx mg mh mi mj mk ml mm mn mo mp mq mr ms mt im bi translated">调试区域时，您会看到有不同类型的任务:微任务和宏任务。一般来说，最好先从宏观任务开始看，因为大多数问题都与宏观任务有关。</p><p id="6b74" class="pw-post-body-paragraph ly lz it ma b mb mu ju md me mv jx mg mh mw mj mk ml mx mn mo mp my mr ms mt im bi translated">但是这些类型之间的区别是什么&gt;</p><p id="b5a8" class="pw-post-body-paragraph ly lz it ma b mb mu ju md me mv jx mg mh mw mj mk ml mx mn mo mp my mr ms mt im bi translated">简而言之，微任务在当前任务之后立即被调度(在当前VM回合中)，而宏任务仅在下一个VM回合中被调度。详细的解释可以在杰克·阿奇博尔德的这篇优秀文章中找到:</p><div class="np nq gp gr nr ns"><a href="https://jakearchibald.com/2015/tasks-microtasks-queues-and-schedules/" rel="noopener  ugc nofollow" target="_blank"><div class="nt ab fo"><div class="nu ab nv cl cj nw"><h2 class="bd iu gy z fp nx fr fs ny fu fw is bi translated">任务、微任务、队列和时间表</h2><div class="nz l"><h3 class="bd b gy z fp nx fr fs ny fu fw dk translated">当我告诉我的同事Matt Gaunt，我正在考虑写一篇关于微任务排队和执行的文章…</h3></div><div class="oa l"><p class="bd b dl z fp nx fr fs ny fu fw dk translated">jakearchibald.com</p></div></div><div class="ob l"><div class="pg l od oe of ob og ks ns"/></div></div></a></div></div><div class="ab cl kz la hx lb" role="separator"><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le"/></div><div class="im in io ip iq"><h1 id="c1b8" class="lg lh it bd li lj lk ll lm ln lo lp lq jz lr ka ls kc lt kd lu kf lv kg lw lx bi translated">10.Zone.js如何与Ng-Upgrade配合使用？</h1><p id="f3c2" class="pw-post-body-paragraph ly lz it ma b mb mc ju md me mf jx mg mh mi mj mk ml mm mn mo mp mq mr ms mt im bi translated">当您使用<code class="fe mz na nb nc b">ng-upgrade</code>从Angular.js应用程序迁移到混合应用程序时，这可能会导致难以调试的问题。</p><p id="9d2f" class="pw-post-body-paragraph ly lz it ma b mb mu ju md me mv jx mg mh mw mj mk ml mx mn mo mp my mr ms mt im bi translated">使用<code class="fe mz na nb nc b">ng-upgrade</code>时，您会注意到的第一件事是所有异步操作也在<code class="fe mz na nb nc b">NgZone</code>中执行。这很有意义，因为Zone.js会自动修补所有异步API。</p><p id="3e7d" class="pw-post-body-paragraph ly lz it ma b mb mu ju md me mv jx mg mh mw mj mk ml mx mn mo mp my mr ms mt im bi translated">您可能会注意到，在某些情况下，性能越来越差。这可能是查看Zone.js和Angular.js的摘要周期之间发生了什么的一个指标。</p><p id="6c81" class="pw-post-body-paragraph ly lz it ma b mb mu ju md me mv jx mg mh mw mj mk ml mx mn mo mp my mr ms mt im bi translated">每当所有的微任务在NgZone中完成，<code class="fe mz na nb nc b">ng-upgrade</code>触发<code class="fe mz na nb nc b">rootScope</code>上的<code class="fe mz na nb nc b">$digest</code>。</p><p id="1426" class="pw-post-body-paragraph ly lz it ma b mb mu ju md me mv jx mg mh mw mj mk ml mx mn mo mp my mr ms mt im bi translated">如果一个摘要触发了任何类似于<code class="fe mz na nb nc b">setTimeout</code>的异步代码，这将在<code class="fe mz na nb nc b">NgZone</code>中创建另一个任务。一旦完成，将会一次又一次地触发<code class="fe mz na nb nc b">$digest</code>。</p></div></div>    
</body>
</html>