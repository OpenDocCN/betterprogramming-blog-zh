<html>
<head>
<title>Maintainability in the Face of API Complexity</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">面对API复杂性的可维护性</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/maintainability-in-the-face-of-api-complexity-e23531e2d322?source=collection_archive---------0-----------------------#2021-07-29">https://betterprogramming.pub/maintainability-in-the-face-of-api-complexity-e23531e2d322?source=collection_archive---------0-----------------------#2021-07-29</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="2f01" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">API网关的内容、原因和方式</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/bf226d015712acb5b9d775653459545b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*29Ro9i6PCvnid5o3ZZiKpA.jpeg"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">Denys Nevozhai 在<a class="ae kv" href="https://unsplash.com/s/photos/highway-los-angeles?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</p></figure><p id="1967" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">API网关是一个组件，它将流量路由到后端，并将客户端从API契约中分离出来。它通过一个内聚的API接口封装了一个复杂的应用架构。除了封装和反向代理之外，它们还可以从单个服务中卸载横切关注点，比如身份验证、速率限制和请求日志。</p><h2 id="0c48" class="ls lt iq bd lu lv lw dn lx ly lz dp ma lf mb mc md lj me mf mg ln mh mi mj mk bi translated">身份危机</h2><p id="e4df" class="pw-post-body-paragraph kw kx iq ky b kz ml jr lb lc mm ju le lf mn lh li lj mo ll lm ln mp lp lq lr ij bi translated">近年来出现了许多用于请求管理和处理的工具。与数据系统一样，数据存储被用作消息队列，消息队列具有类似数据库的持久性保证，代理、网格和网关之间的界限正在变得模糊。</p><p id="dd65" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">为了避免混淆，本文假设每个解决方案都有以下主要职责:</p><ul class=""><li id="59a9" class="mq mr iq ky b kz la lc ld lf ms lj mt ln mu lr mv mw mx my bi translated"><strong class="ky ir">服务网状。</strong>一个专用的网络基础设施，覆盖在您的服务之上，卸载<em class="mz">服务间的通信功能</em>，例如加密、可观察性和弹性机制。</li><li id="a4b4" class="mq mr iq ky b kz na lc nb lf nc lj nd ln ne lr mv mw mx my bi translated"><strong class="ky ir"> API网关。</strong>提供跨应用架构的内聚抽象的组件，同时代表单个服务卸载<em class="mz">边缘功能</em>。</li></ul><p id="96b9" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们现在来看看API网关的“为什么”,稍后再看一个代码示例。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nf ng l"/></div></figure></div><div class="ab cl nh ni hu nj" role="separator"><span class="nk bw bk nl nm nn"/><span class="nk bw bk nl nm nn"/><span class="nk bw bk nl nm"/></div><div class="ij ik il im in"><h1 id="a5c1" class="no lt iq bd lu np nq nr lx ns nt nu ma jw nv jx md jz nw ka mg kc nx kd mj ny bi translated">发展就是维护</h1><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nz"><img src="../Images/38079a9d82a19a05ed90aefc95f633b4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*CVSThjAXg8Vx1mnpkiX_NA.jpeg"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">照片由<a class="ae kv" href="https://unsplash.com/@guiccunha?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">古伊列梅·崔林</a>在<a class="ae kv" href="https://unsplash.com/?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</p></figure><p id="9e92" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">众所周知，软件的大部分成本都花在日常维护上。交付后的所有增强和修复都被视为“维护工作”——保持系统运行、分析故障、适应不同的平台、修复bug，以及偿还<a class="ae kv" href="https://en.wikipedia.org/wiki/Technical_debt#:~:text=Technical%20debt%20(also%20known%20as,approach%20that%20would%20take%20longer." rel="noopener ugc nofollow" target="_blank">技术债务</a>。我们应该设计能够轻松适应不断变化的需求的系统，使维护模式不那么痛苦。</p><blockquote class="oa"><p id="4d97" class="ob oc iq bd od oe of og oh oi oj lr dk translated">总是这样编码，就好像最终维护你的代码的人会是一个知道你住在哪里的暴力精神病患者――约翰·伍兹</p></blockquote><h1 id="8d8c" class="no lt iq bd lu np ok nr lx ns ol nu ma jw om jx md jz on ka mg kc oo kd mj ny bi translated">变化是不可避免的</h1><p id="67e7" class="pw-post-body-paragraph kw kx iq ky b kz ml jr lb lc mm ju le lf mn lh li lj mo ll lm ln mp lp lq lr ij bi translated">业务优先级变化、底层平台变化、法律法规要求变化、您的用户变化！绝大多数设计原则都专注于让事情“更容易改变”，这并不是巧合无论是隔离模块间的关注点(<a class="ae kv" href="https://en.wikipedia.org/wiki/Coupling_%28computer_programming%29" rel="noopener ugc nofollow" target="_blank">解耦</a>)，屏蔽简单<a class="ae kv" href="https://en.wikipedia.org/wiki/Facade_pattern" rel="noopener ugc nofollow" target="_blank">表象</a>背后的复杂交互，还是干脆不重复自己(<a class="ae kv" href="https://en.wikipedia.org/wiki/Don%27t_repeat_yourself" rel="noopener ugc nofollow" target="_blank">干</a>)；我们的目标应该是能够进化的系统，以便于将来的适应。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi op"><img src="../Images/479421304783a712bb066fa0d118e265.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*eLeHG0cczNplv4UmEcHMyw.jpeg"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">泰勒·拉斯托维奇在<a class="ae kv" href="https://unsplash.com/?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的照片</p></figure><blockquote class="oa"><p id="18f8" class="ob oc iq bd od oe oq or os ot ou lr dk translated">对于每一个关键的决策，项目团队都致力于选择更少的现实版本。</p></blockquote><h1 id="5be5" class="no lt iq bd lu np ok nr lx ns ol nu ma jw om jx md jz on ka mg kc oo kd mj ny bi translated">API维护</h1><p id="908d" class="pw-post-body-paragraph kw kx iq ky b kz ml jr lb lc mm ju le lf mn lh li lj mo ll lm ln mp lp lq lr ij bi translated">随着组织从单一架构过渡到更加分布式或"<a class="ae kv" href="https://en.wikipedia.org/wiki/Shared-nothing_architecture#:~:text=A%20shared%2Dnothing%20architecture%20%28SN,to%20eliminate%20contention%20among%20nodes.&amp;text=A%20SN%20system%20can%20scale,central%20resource%20bottlenecks%20the%20system." rel="noopener ugc nofollow" target="_blank">无共享</a>"架构，其中服务是自我管理的，<a class="ae kv" href="https://en.wikipedia.org/wiki/Mobile_backend_as_a_service" rel="noopener ugc nofollow" target="_blank">云管理的</a>或"<a class="ae kv" href="https://en.wikipedia.org/wiki/Serverless_computing" rel="noopener ugc nofollow" target="_blank">无服务器功能</a>"，操作复杂性增加，提供可靠的API体验变得具有挑战性。这种复杂性降低了项目团队的速度，进一步增加了维护成本。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi ov"><img src="../Images/59bb074ab2f413c6edeadcbfae7b44f8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*XsHDeVWZHgNvV9Kz5912Mg.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">直接的客户端到服务的通信(由<a class="ae kv" href="https://portfolio.fabijanbajo.com/" rel="noopener ugc nofollow" target="_blank">本人</a>绘制)</p></figure><p id="7ed7" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在API管理中，直接的客户端到服务的通信往往会增加API的复杂性，并可能带来意想不到的后果:</p><ul class=""><li id="2823" class="mq mr iq ky b kz la lc ld lf ms lj mt ln mu lr mv mw mx my bi translated"><strong class="ky ir">紧耦合。</strong>客户端应用直接依赖于后端服务不断变化的API契约。</li><li id="4f2c" class="mq mr iq ky b kz na lc nb lf nc lj nd ln ne lr mv mw mx my bi translated"><strong class="ky ir">知识重复。</strong>每个公开的服务实现它自己的边缘功能，比如SSL终止和速率限制。</li><li id="9c3c" class="mq mr iq ky b kz na lc nb lf nc lj nd ln ne lr mv mw mx my bi translated"><strong class="ky ir">多次往返。</strong>由于复杂的API组合流，过多的网络往返可能会降低性能。</li><li id="6756" class="mq mr iq ky b kz na lc nb lf nc lj nd ln ne lr mv mw mx my bi translated"><strong class="ky ir">增加了攻击面。</strong>现在开放了更多的端口，公开了更多的服务，身份验证也变成了一个分布式问题。</li></ul><blockquote class="oa"><p id="377b" class="ob oc iq bd od oe oq or os ot ou lr dk translated">提高可维护性并不一定意味着减少功能；这也意味着降低复杂性。</p></blockquote><h1 id="9bb7" class="no lt iq bd lu np ok nr lx ns ol nu ma jw om jx md jz on ka mg kc oo kd mj ny bi translated">后端的外观</h1><p id="93f5" class="pw-post-body-paragraph kw kx iq ky b kz ml jr lb lc mm ju le lf mn lh li lj mo ll lm ln mp lp lq lr ij bi translated">正确设计的抽象可以在简单的外观后面隐藏大量的实现细节。API网关通过封装复杂的后端架构来提供这种抽象，同时公开一个一致的、客户端友好的API接口。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi ow"><img src="../Images/ae501438f85c44c2365ebe9c8a014810.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*17EbCAaySFw_PR907Si9UA.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">通过API网关进行通信(由<a class="ae kv" href="https://portfolio.fabijanbajo.com/" rel="noopener ugc nofollow" target="_blank">本人</a>绘制)</p></figure><p id="c8be" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">为了将(分布式)系统的API复杂性保持在可管理的水平，API网关通过以下方式提供帮助:</p><ul class=""><li id="850e" class="mq mr iq ky b kz la lc ld lf ms lj mt ln mu lr mv mw mx my bi translated"><strong class="ky ir">将客户与后端合同分离。</strong> API路由通过单独的请求路由配置进行管理，保持客户端接口的一致性。</li><li id="b8c2" class="mq mr iq ky b kz na lc nb lf nc lj nd ln ne lr mv mw mx my bi translated"><strong class="ky ir">将跨领域问题整合到一个层级。</strong>网关通过集中关键边缘功能的职责来减少重复并简化每项服务。</li><li id="269d" class="mq mr iq ky b kz na lc nb lf nc lj nd ln ne lr mv mw mx my bi translated"><strong class="ky ir">跨服务聚合数据。</strong>我们现在可以通过将单个客户端请求分派给几个内部服务并使用聚合的有效负载进行响应来应用“服务器端”API组合。</li><li id="82b7" class="mq mr iq ky b kz na lc nb lf nc lj nd ln ne lr mv mw mx my bi translated"><strong class="ky ir">对外界隐藏内部服务。</strong>仅暴露网关减少了网络攻击面，并允许集中式API安全管理。</li></ul></div><div class="ab cl nh ni hu nj" role="separator"><span class="nk bw bk nl nm nn"/><span class="nk bw bk nl nm nn"/><span class="nk bw bk nl nm"/></div><div class="ij ik il im in"><h1 id="8f20" class="no lt iq bd lu np nq nr lx ns nt nu ma jw nv jx md jz nw ka mg kc nx kd mj ny bi translated">带有KrakenD的声明式API网关</h1><p id="0a78" class="pw-post-body-paragraph kw kx iq ky b kz ml jr lb lc mm ju le lf mn lh li lj mo ll lm ln mp lp lq lr ij bi translated">本文的剩余部分通过一个示例项目演示了API网关执行的一些常见任务。</p><p id="7fd9" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">目前一些流行的(开源)API网关包括:</p><ul class=""><li id="6340" class="mq mr iq ky b kz la lc ld lf ms lj mt ln mu lr mv mw mx my bi translated"><a class="ae kv" href="https://github.com/Kong/kong" rel="noopener ugc nofollow" target="_blank">孔</a></li><li id="7d1a" class="mq mr iq ky b kz na lc nb lf nc lj nd ln ne lr mv mw mx my bi translated"><a class="ae kv" href="https://github.com/TykTechnologies/tyk" rel="noopener ugc nofollow" target="_blank"> Tyk </a></li><li id="0c67" class="mq mr iq ky b kz na lc nb lf nc lj nd ln ne lr mv mw mx my bi translated">克拉肯德</li></ul><p id="f2b1" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我选择KrakenD是因为它:</p><ul class=""><li id="871c" class="mq mr iq ky b kz la lc ld lf ms lj mt ln mu lr mv mw mx my bi translated"><strong class="ky ir">简约。</strong>一个<a class="ae kv" href="https://hub.docker.com/r/devopsfaith/krakend/" rel="noopener ugc nofollow" target="_blank"> docker映像</a>和一个配置文件就足够了。</li><li id="a94b" class="mq mr iq ky b kz na lc nb lf nc lj nd ln ne lr mv mw mx my bi translated"><strong class="ky ir">无国籍和不变性。无状态、不可变和独立于周围的工作负载简化了维护并减少了耦合。</strong></li><li id="d982" class="mq mr iq ky b kz na lc nb lf nc lj nd ln ne lr mv mw mx my bi translated"><strong class="ky ir">性能。</strong>带<strong class="ky ir"> </strong>一个<strong class="ky ir"> </strong>附加网络跳，每个请求都必须经过，你希望它快。KrakenD的构建考虑到了性能(<a class="ae kv" href="https://www.krakend.io/docs/benchmarks/overview/" rel="noopener ugc nofollow" target="_blank"> ~每秒18，000个请求</a>)。</li></ul><p id="ffb9" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">它遵循大多数<a class="ae kv" href="https://12factor.net/" rel="noopener ugc nofollow" target="_blank">十二因素应用实践</a>，是容器环境的理想候选。</p><h1 id="ce1f" class="no lt iq bd lu np ok nr lx ns ol nu ma jw ox jx md jz oy ka mg kc oz kd mj ny bi translated">该项目</h1><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi pa"><img src="../Images/bc95f64029bb6b1f55b0fbd650f5ae70.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*E5pu2bcuOl7LfMV-wWI9YQ.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">项目工艺流程示例(由<a class="ae kv" href="https://portfolio.fabijanbajo.com/" rel="noopener ugc nofollow" target="_blank">本人</a>绘制)</p></figure><p id="71e7" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">示例应用程序代表了一个大型电子商务微服务项目的一部分，我正在试验一个iOS前端。我们将只使用以下部分:</p><p id="d384" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">应用:</p><ul class=""><li id="a8f3" class="mq mr iq ky b kz la lc ld lf ms lj mt ln mu lr mv mw mx my bi translated"><strong class="ky ir">推车服务。</strong>用GO写的REST服务，为注册客户管理购物车。</li><li id="8721" class="mq mr iq ky b kz na lc nb lf nc lj nd ln ne lr mv mw mx my bi translated"><strong class="ky ir">身份服务。</strong>用Typescript编写的REST服务，管理客户账户并发布JSON Web令牌(jwt)。</li><li id="14f0" class="mq mr iq ky b kz na lc nb lf nc lj nd ln ne lr mv mw mx my bi translated"><strong class="ky ir">网关</strong>。一个KrakenD(社区版)API网关，处理请求路由、授权、有效负载验证和速率限制。</li></ul><p id="be31" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我为本文扩展了存储层，使其不依赖于Postgres和Redis，并保持简洁。</p><p id="11a5" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">基础设施:</p><ul class=""><li id="98e6" class="mq mr iq ky b kz la lc ld lf ms lj mt ln mu lr mv mw mx my bi translated">库伯内特，赫尔姆&amp;斯卡福德。所有工作负载都通过Kubernetes Helm charts打包。Skaffold处理<em class="mz">工作流</em>来构建整个项目并将其部署到集群中。</li><li id="34dc" class="mq mr iq ky b kz na lc nb lf nc lj nd ln ne lr mv mw mx my bi translated"><strong class="ky ir">码头工人作曲。代替Kubernetes，这个项目也可以通过Docker Compose来构建和部署。</strong></li></ul><p id="6028" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">为了简单起见，我们将在下面几节中使用Docker Compose来构建我们的网关清单，尽管存储库中提供了一个完全可用的Kubernetes配置。</p><pre class="kg kh ki kj gt pb pc pd pe aw pf bi"><span id="d084" class="ls lt iq pc b gy pg ph l pi pj">Project:</span><span id="9a6d" class="ls lt iq pc b gy pk ph l pi pj">.<br/>├── <a class="ae kv" href="https://github.com/Bajocode/article-apigateways/tree/master/identity-service" rel="noopener ugc nofollow" target="_blank">identity-service/ (nodejs microservice)</a><br/>│ ├── src/<br/>│ ├── Dockerfile<br/>│ └── Makefile<br/>├── <a class="ae kv" href="https://github.com/Bajocode/article-apigateways/tree/master/cart-service" rel="noopener ugc nofollow" target="_blank">cart-service/ (golang microservice)</a><br/>│ ├── src/<br/>│ ├── Dockerfile<br/>│ └── Makefile<br/>├── <a class="ae kv" href="https://github.com/Bajocode/article-apigateways/tree/master/kubernetes-helmcharts" rel="noopener ugc nofollow" target="_blank">kubernetes-helmcharts/</a><br/>│ ├── identity-service/<br/>│ ├── cart-service/<br/>│ └── gateway/<br/>├── krakend.yaml<br/>├── docker-compose.yaml<br/>└── skaffold.yaml</span><span id="d9b8" class="ls lt iq pc b gy pk ph l pi pj"><br/>Versions:</span><span id="631d" class="ls lt iq pc b gy pk ph l pi pj">Kubernetes:  1.21.2<br/>Helm:        3.3.3<br/>Skaffold:    1.27.0<br/>Docker:      20.10.5<br/>Go:          1.15.2<br/>NodeJS:      12.19.0<br/>KrakenD:     1.2</span></pre><blockquote class="pl pm pn"><p id="0e38" class="kw kx mz ky b kz la jr lb lc ld ju le po lg lh li pp lk ll lm pq lo lp lq lr ij bi translated">示例应用程序的完整源代码可以在<a class="ae kv" href="https://github.com/Bajocode/article-apigateways" rel="noopener ugc nofollow" target="_blank"> GitHub </a>上找到。</p></blockquote><h2 id="c7fc" class="ls lt iq bd lu lv lw dn lx ly lz dp ma lf mb mc md lj me mf mg ln mh mi mj mk bi translated">使用<a class="ae kv" href="https://docs.docker.com/compose/install/" rel="noopener ugc nofollow" target="_blank"> Docker Compose </a>构建和部署</h2><p id="c873" class="pw-post-body-paragraph kw kx iq ky b kz ml jr lb lc mm ju le lf mn lh li lj mo ll lm ln mp lp lq lr ij bi translated">安装<a class="ae kv" href="https://docs.docker.com/get-docker/" rel="noopener ugc nofollow" target="_blank">对接器</a>并运行:</p><pre class="kg kh ki kj gt pb pc pd pe aw pf bi"><span id="867d" class="ls lt iq pc b gy pg ph l pi pj">$ docker compose up<br/>...<br/>[+] Running 3/3<br/> ⠿ Container cart-service      Started  4.0s<br/> ⠿ Container identity-service  Started  5.8s<br/> ⠿ Container gateway           Started  7.0s</span></pre><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nf ng l"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">docker——构建和运行容器的配置</p></figure><h2 id="b2d1" class="ls lt iq bd lu lv lw dn lx ly lz dp ma lf mb mc md lj me mf mg ln mh mi mj mk bi translated">用<a class="ae kv" href="https://docs.docker.com/desktop/kubernetes/#:~:text=The%20Kubernetes%20server%20runs%20within,not%20affect%20your%20other%20workloads." rel="noopener ugc nofollow" target="_blank">库伯内特</a>、<a class="ae kv" href="https://helm.sh/" rel="noopener ugc nofollow" target="_blank">赫尔姆</a>和<a class="ae kv" href="https://skaffold.dev/" rel="noopener ugc nofollow" target="_blank">斯卡福德</a>建造和部署</h2><p id="219b" class="pw-post-body-paragraph kw kx iq ky b kz ml jr lb lc mm ju le lf mn lh li lj mo ll lm ln mp lp lq lr ij bi translated">在本地或云中创建一个Kubernetes集群。</p><blockquote class="pl pm pn"><p id="1a65" class="kw kx mz ky b kz la jr lb lc ld ju le po lg lh li pp lk ll lm pq lo lp lq lr ij bi translated">Docker桌面包括一个独立的Kubernetes服务器和运行在您机器上的客户端。要启用Kubernetes，请转到<strong class="ky ir"> Docker </strong> &gt; <strong class="ky ir">首选项</strong> &gt; <strong class="ky ir"> Kubernetes </strong>，然后点击<strong class="ky ir">启用Kubernetes </strong>。</p></blockquote><p id="6abc" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><a class="ae kv" href="https://skaffold.dev/docs/install/" rel="noopener ugc nofollow" target="_blank">安装Skaffold </a>和<a class="ae kv" href="https://helm.sh/docs/intro/install/" rel="noopener ugc nofollow" target="_blank">舵</a>，展开所有舵图:</p><pre class="kg kh ki kj gt pb pc pd pe aw pf bi"><span id="1bc2" class="ls lt iq pc b gy pg ph l pi pj">$ skaffold run --port-forward=user --tail<br/>...<br/>Waiting for deployments to stabilize...<br/> - deployment/cart-service is ready.<br/> - deployment/gateway is ready.<br/> - deployment/identity-service is ready.<br/>Deployments stabilized in 19.0525727s</span></pre><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nf ng l"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">Skaffold配置用于构建容器并通过舵图部署它们</p></figure><h2 id="2da7" class="ls lt iq bd lu lv lw dn lx ly lz dp ma lf mb mc md lj me mf mg ln mh mi mj mk bi translated">作为代码的API配置</h2><p id="f483" class="pw-post-body-paragraph kw kx iq ky b kz ml jr lb lc mm ju le lf mn lh li lj mo ll lm ln mp lp lq lr ij bi translated">在<code class="fe pr ps pt pc b">project-root/krakend.yaml</code>创建一个新的KrakenD清单，内容如下:</p><pre class="kg kh ki kj gt pb pc pd pe aw pf bi"><span id="fba2" class="ls lt iq pc b gy pg ph l pi pj">krakend.yaml<br/>---<br/>version: 2<br/>endpoints: []</span></pre><p id="240c" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我在这里做的只是指定文件格式的版本。</p><h2 id="eae3" class="ls lt iq bd lu lv lw dn lx ly lz dp ma lf mb mc md lj me mf mg ln mh mi mj mk bi translated">按指定路线发送</h2><p id="eaf5" class="pw-post-body-paragraph kw kx iq ky b kz ml jr lb lc mm ju le lf mn lh li lj mo ll lm ln mp lp lq lr ij bi translated">在<code class="fe pr ps pt pc b">endpoints</code>数组下添加一个端点对象，并公开<code class="fe pr ps pt pc b">GET /users</code>身份服务端点:</p><pre class="kg kh ki kj gt pb pc pd pe aw pf bi"><span id="f298" class="ls lt iq pc b gy pg ph l pi pj">krakend.yaml<br/>---<br/>...<br/>endpoints:</span><span id="6a6a" class="ls lt iq pc b gy pk ph l pi pj">- endpoint: /users<br/>  method: GET<br/>  output_encoding: no-op<br/>  backend:<br/>  - url_pattern: /users<br/>    encoding: no-op<br/>    sd: static<br/>    method: GET<br/>    host:<br/>    - <a class="ae kv" href="http://identity-service:9005" rel="noopener ugc nofollow" target="_blank">http://identity-service:9005</a></span></pre><ul class=""><li id="4024" class="mq mr iq ky b kz la lc ld lf ms lj mt ln mu lr mv mw mx my bi translated"><code class="fe pr ps pt pc b">no-op</code>(无操作)编码确保客户端请求像一样被转发到后端<em class="mz">，反之亦然。</em></li><li id="0828" class="mq mr iq ky b kz na lc nb lf nc lj nd ln ne lr mv mw mx my bi translated"><code class="fe pr ps pt pc b">static</code> resolution是默认的服务发现设置，也是我们将用于Docker Compose网络的设置。</li></ul><p id="5634" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">对于Kubernetes部署，将<code class="fe pr ps pt pc b"><em class="mz">sd</em></code>设置为<code class="fe pr ps pt pc b"><em class="mz">dns</em></code>(启用<a class="ae kv" href="https://kubernetes.io/docs/concepts/services-networking/dns-pod-service/" rel="noopener ugc nofollow" target="_blank"> DNS SRV </a>模式)</p><p id="3d26" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">重启网关并执行一个<code class="fe pr ps pt pc b">GET /users</code>请求:</p><pre class="kg kh ki kj gt pb pc pd pe aw pf bi"><span id="777a" class="ls lt iq pc b gy pg ph l pi pj">$ docker compose restart gateway</span><span id="4c1a" class="ls lt iq pc b gy pk ph l pi pj">$ curl '<a class="ae kv" href="http://0.0.0.0:8000/users'" rel="noopener ugc nofollow" target="_blank">http://0.0.0.0:8080/users'</a> \<br/>  --request GET \<br/>  --include</span><span id="aeb7" class="ls lt iq pc b gy pk ph l pi pj">HTTP/1.1 401 Unauthorized<br/>...<br/>{<br/>  "status": 401,<br/>  "message": "No Authorization header"<br/>}</span></pre><p id="753c" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我已经为身份服务编写了<a class="ae kv" href="https://github.com/Bajocode/article-apigateways/blob/master/identity-service/src/middleware/authMiddleware.ts" rel="noopener ugc nofollow" target="_blank">自定义JWT授权中间件</a>，用于解码和验证<a class="ae kv" href="https://en.wikipedia.org/wiki/JSON_Web_Token" rel="noopener ugc nofollow" target="_blank"> JWT </a>有效负载，可通过以下方式配置:</p><pre class="kg kh ki kj gt pb pc pd pe aw pf bi"><span id="ee87" class="ls lt iq pc b gy pg ph l pi pj">docker-compose.yaml<br/>---<br/>...<br/>identity-service:<br/>    environment:<br/>    - JWT_VALIDATION_ENABLED=true<br/>    - JWT_PATHS_WHITELIST=/auth/register,/auth/login,/jwks.json</span></pre><p id="5e54" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">保持上面的原样，用<code class="fe pr ps pt pc b">register</code>和<code class="fe pr ps pt pc b">login</code>路由扩展<code class="fe pr ps pt pc b">krakend.yaml</code>,以从身份服务发布JWT令牌:</p><pre class="kg kh ki kj gt pb pc pd pe aw pf bi"><span id="1d8b" class="ls lt iq pc b gy pg ph l pi pj">krakend.yaml<br/>---<br/>...<br/>endpoints:</span><span id="ad83" class="ls lt iq pc b gy pk ph l pi pj">- endpoint: /users<br/>  ...</span><span id="690f" class="ls lt iq pc b gy pk ph l pi pj">- endpoint: /auth/register<br/>  method: POST<br/>  output_encoding: no-op<br/>  backend:<br/>  - url_pattern: /auth/register<br/>    encoding: no-op<br/>    sd: static<br/>    method: POST<br/>    host:<br/>    - <a class="ae kv" href="http://identity-service:9005" rel="noopener ugc nofollow" target="_blank">http://identity-service:9005</a></span><span id="02eb" class="ls lt iq pc b gy pk ph l pi pj">- endpoint: /auth/login<br/>  method: POST<br/>  output_encoding: no-op<br/>  backend:<br/>  - url_pattern: /auth/login<br/>    encoding: no-op<br/>    sd: static<br/>    method: POST<br/>    host:<br/>    - <a class="ae kv" href="http://identity-service:9005" rel="noopener ugc nofollow" target="_blank">http://identity-service:9005</a></span></pre><p id="935f" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">通过注册新用户来颁发JWT令牌，并将其导出到您的shell环境中供以后使用:</p><pre class="kg kh ki kj gt pb pc pd pe aw pf bi"><span id="5d1a" class="ls lt iq pc b gy pg ph l pi pj">$ docker compose restart gateway</span><span id="8bc3" class="ls lt iq pc b gy pk ph l pi pj">$ curl '<a class="ae kv" href="http://0.0.0.0:8000/auth/register'" rel="noopener ugc nofollow" target="_blank">http://0.0.0.0:</a><a class="ae kv" href="http://0.0.0.0:8000/users'" rel="noopener ugc nofollow" target="_blank">8080</a><a class="ae kv" href="http://0.0.0.0:8000/auth/register'" rel="noopener ugc nofollow" target="_blank">/auth/register'</a> \<br/>  --request POST \<br/>  --header "Content-type: application/json" \<br/>  --include \<br/>  --data '{<br/>    "email": "som@ebo.dy",<br/>    "password": "pass"<br/>  }'</span><span id="67a6" class="ls lt iq pc b gy pk ph l pi pj">HTTP/1.1 201 Created<br/>...<br/>{<br/>  "token": "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCIsImtpZCI6InVzZX...",<br/>  "expiry": 1623536812<br/>}</span><span id="8f01" class="ls lt iq pc b gy pk ph l pi pj">$ export TOKEN=eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCIsImtpZCI6InVzZX...</span></pre><p id="640a" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">将您的令牌插入到<code class="fe pr ps pt pc b">Authorization</code>头中，并再次尝试获取所有用户:</p><pre class="kg kh ki kj gt pb pc pd pe aw pf bi"><span id="5a9f" class="ls lt iq pc b gy pg ph l pi pj">$ curl '<a class="ae kv" href="http://0.0.0.0:8000/users'" rel="noopener ugc nofollow" target="_blank">http://0.0.0.0:</a><a class="ae kv" href="http://0.0.0.0:8000/users'" rel="noopener ugc nofollow" target="_blank">8080</a><a class="ae kv" href="http://0.0.0.0:8000/users'" rel="noopener ugc nofollow" target="_blank">/users'</a> \<br/>    --request "GET" \<br/>    --header "Authorization: Bearer ${TOKEN}" \<br/>    --include</span><span id="fb88" class="ls lt iq pc b gy pk ph l pi pj">HTTP/1.1 401 Unauthorized<br/>...<br/>{<br/>  "status": 401,<br/>  "message": "No Authorization header"<br/>}</span></pre><p id="e08b" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">默认情况下，KrakenD不会将客户端头发送到后端。</p><p id="3886" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在<code class="fe pr ps pt pc b">/users</code>端点对象下添加一个<code class="fe pr ps pt pc b">headers_to_pass</code>属性，将<code class="fe pr ps pt pc b">Authorization</code>请求头转发到后端:</p><pre class="kg kh ki kj gt pb pc pd pe aw pf bi"><span id="bde8" class="ls lt iq pc b gy pg ph l pi pj">krakend.yaml<br/>---<br/>...<br/>endpoints:</span><span id="e690" class="ls lt iq pc b gy pk ph l pi pj">- endpoint: /users<br/>  ...<br/>  headers_to_pass:<br/>  - Authorization<br/>  backend:<br/>  ...</span></pre><p id="9bf5" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">随着<code class="fe pr ps pt pc b">Authorization</code>头的转发，我们现在可以检索所有用户:</p><pre class="kg kh ki kj gt pb pc pd pe aw pf bi"><span id="f6d8" class="ls lt iq pc b gy pg ph l pi pj">$ docker compose restart gateway</span><span id="9134" class="ls lt iq pc b gy pk ph l pi pj">curl '<a class="ae kv" href="http://0.0.0.0:8000/users'" rel="noopener ugc nofollow" target="_blank">http://0.0.0.0:</a><a class="ae kv" href="http://0.0.0.0:8000/users'" rel="noopener ugc nofollow" target="_blank">8080</a><a class="ae kv" href="http://0.0.0.0:8000/users'" rel="noopener ugc nofollow" target="_blank">/users'</a> \<br/>    --request "GET" \<br/>    --header "Authorization: Bearer ${TOKEN}" \<br/>    --include</span><span id="6c0d" class="ls lt iq pc b gy pk ph l pi pj">HTTP/1.1 200 OK </span><span id="d13f" class="ls lt iq pc b gy pk ph l pi pj">[{<br/>   "id":"f06b084b-9d67-4b01-926b-f90c6246eed9",<br/>   "email":"<a class="ae kv" href="mailto:somebody@nobody.com" rel="noopener ugc nofollow" target="_blank">som@ebo.dy</a>"<br/>}]</span></pre><p id="10ed" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">目前为止我们的克拉肯清单:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nf ng l"/></div></figure><h2 id="920d" class="ls lt iq bd lu lv lw dn lx ly lz dp ma lf mb mc md lj me mf mg ln mh mi mj mk bi translated">卸载授权</h2><p id="36c4" class="pw-post-body-paragraph kw kx iq ky b kz ml jr lb lc mm ju le lf mn lh li lj mo ll lm ln mp lp lq lr ij bi translated">我们不要为cart服务编写定制的GO授权中间件，而是通过将这个横切关注点卸载到网关来屏蔽它的端点。</p><p id="36e8" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><a class="ae kv" href="https://datatracker.ietf.org/doc/html/rfc7517#section-4.1" rel="noopener ugc nofollow" target="_blank"> JSON Web密钥集</a>格式用于向网关公开我们的令牌完整性验证密钥。为了简单起见，在编写身份服务(我们的<a class="ae kv" href="https://en.wikipedia.org/wiki/Identity_provider" rel="noopener ugc nofollow" target="_blank">身份提供者</a>)时，我使用了HS256算法(HMAC-SHA256)生成对称签名:</p><pre class="kg kh ki kj gt pb pc pd pe aw pf bi"><span id="5e0f" class="ls lt iq pc b gy pg ph l pi pj">$ echo -n 'secret' | openssl base64<br/>c2VjcmV0</span></pre><p id="813f" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi">🤫</p><p id="e952" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们的JWKS包含相同的对称密钥，静态托管在<code class="fe pr ps pt pc b">identity-service/jwks.json</code>:</p><pre class="kg kh ki kj gt pb pc pd pe aw pf bi"><span id="9218" class="ls lt iq pc b gy pg ph l pi pj"># identity-service/jwks.json</span><span id="01e6" class="ls lt iq pc b gy pk ph l pi pj">{<br/>  "keys": [<br/>    {<br/>      "kty": "oct",     # key type (octet string)<br/>      "kid": "userid",  # key id (identify the key in the set)<br/>      "k": "c2VjcmV0",  # key<br/>      "alg": "HS256".   # algorithm<br/>    }<br/>  ]<br/>}</span></pre><blockquote class="pl pm pn"><p id="a6c6" class="kw kx mz ky b kz la jr lb lc ld ju le po lg lh li pp lk ll lm pq lo lp lq lr ij bi translated">有关JWK标准的更多信息，请参考<a class="ae kv" href="https://datatracker.ietf.org/doc/html/rfc7517" rel="noopener ugc nofollow" target="_blank"> RFC文件</a>。</p></blockquote><p id="2798" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">将一个<code class="fe pr ps pt pc b">PUT /cart</code>端点附加到清单上，并通过<code class="fe pr ps pt pc b">krakend-jose</code>验证器插件屏蔽掉未注册的客户:</p><pre class="kg kh ki kj gt pb pc pd pe aw pf bi"><span id="7d5c" class="ls lt iq pc b gy pg ph l pi pj">krakend.yaml<br/>---<br/>...<br/>- endpoint: /cart<br/>  method: PUT<br/>  output_encoding: no-op<br/>  extra_config:<br/>    github.com/devopsfaith/krakend-jose/validator:<br/>      alg: HS256<br/>      jwk-url: <a class="ae kv" href="http://identity-service:9005/jwks.json" rel="noopener ugc nofollow" target="_blank">http://identity-service:9005/jwks.json</a><br/>      disable_jwk_security: true<br/>      kid: userid<br/>  backend:<br/>  - url_pattern: /cart                   <br/>    encoding: no-op<br/>    sd: static<br/>    method: PUT<br/>    host:<br/>    - <a class="ae kv" href="http://cart-service:9002" rel="noopener ugc nofollow" target="_blank">http://cart-service:9002</a></span></pre><p id="2d9d" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这里我们指定“密钥ID”，并通过将<code class="fe pr ps pt pc b">disable_jwk_security</code>设置为<code class="fe pr ps pt pc b">false</code>来允许HTTP访问我们私有的jwk。</p><blockquote class="pl pm pn"><p id="1fb6" class="kw kx mz ky b kz la jr lb lc ld ju le po lg lh li pp lk ll lm pq lo lp lq lr ij bi translated">如果您关闭了您的shell会话，执行一个<code class="fe pr ps pt pc b">/login</code>请求并将您的令牌重新导出到shell的环境中:<br/> <code class="fe pr ps pt pc b">curl ‘<a class="ae kv" href="http://0.0.0.0:8080/auth/login'" rel="noopener ugc nofollow" target="_blank">http://0.0.0.0:8080/auth/login'</a> -H “Content-type: application/json” -d ‘{“email”: “<a class="ae kv" href="mailto:som@ebo.dy" rel="noopener ugc nofollow" target="_blank">som@ebo.dy</a>”,”password”: “pass”}’</code></p></blockquote><p id="5f30" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">使用有效令牌执行<code class="fe pr ps pt pc b">PUT /cart</code>请求，以更新用户的购物车:</p><pre class="kg kh ki kj gt pb pc pd pe aw pf bi"><span id="aa3a" class="ls lt iq pc b gy pg ph l pi pj">$ docker compose restart gateway</span><span id="9ff1" class="ls lt iq pc b gy pk ph l pi pj">$ curl '<a class="ae kv" href="http://0.0.0.0:8000/cart'" rel="noopener ugc nofollow" target="_blank">http://0.0.0.0:</a><a class="ae kv" href="http://0.0.0.0:8000/users'" rel="noopener ugc nofollow" target="_blank">8080</a><a class="ae kv" href="http://0.0.0.0:8000/cart'" rel="noopener ugc nofollow" target="_blank">/cart'</a> \<br/>  --request "PUT" \<br/>  --header "Content-type: application/json" \<br/>  --header "Authorization: Bearer ${TOKEN}" \<br/>  --include \<br/>  --data '{<br/>    "items": [{<br/>      "productid": "94e8d5de-2192-4419-b824-ccbe7b21fa6f",<br/>      "quantity": 2,<br/>      "price": 200<br/>    }]<br/>  }'</span><span id="d5ad" class="ls lt iq pc b gy pk ph l pi pj">HTTP/1.1 400 Bad Request<br/>...<br/>{<br/>  "message": "Bad request: no userID"<br/>}</span></pre><p id="72c2" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">cart服务希望将客户端的用户ID添加到所有路径的前面。用户ID可以手动从JWT有效载荷中提取，因为我自己将它嵌入在用户id JWT声明下。</p><p id="dc29" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">幸运的是，我们可以通过KrakenD <code class="fe pr ps pt pc b">JWT</code>变量访问经过验证的JWT有效负载，并将其传递给购物车端点的后端对象:</p><pre class="kg kh ki kj gt pb pc pd pe aw pf bi"><span id="a3d2" class="ls lt iq pc b gy pg ph l pi pj">krakend.yaml<br/>---<br/>...<br/>- endpoint: /cart<br/>  ...<br/>  backend:<br/>  - url_pattern: /{JWT.userid}/cart                   <br/>    ...</span></pre><p id="a098" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">如果我们再次执行<code class="fe pr ps pt pc b">PUT /cart</code>请求，它应该会成功地创建或更新<code class="fe pr ps pt pc b">cart</code>:</p><pre class="kg kh ki kj gt pb pc pd pe aw pf bi"><span id="3e9a" class="ls lt iq pc b gy pg ph l pi pj">$ docker compose restart gateway</span><span id="201a" class="ls lt iq pc b gy pk ph l pi pj">$ curl '<a class="ae kv" href="http://0.0.0.0:8000/cart'" rel="noopener ugc nofollow" target="_blank">http://0.0.0.0:</a><a class="ae kv" href="http://0.0.0.0:8000/users'" rel="noopener ugc nofollow" target="_blank">8080</a><a class="ae kv" href="http://0.0.0.0:8000/cart'" rel="noopener ugc nofollow" target="_blank">/cart'</a> \<br/>  --request "PUT" \<br/>  --header "Content-type: application/json" \<br/>  --header "Authorization: Bearer ${TOKEN}" \<br/>  --include \<br/>  --data '{<br/>    "items": [{<br/>      "productid": "94e8d5de-2192-4419-b824-ccbe7b21fa6f",<br/>      "quantity": 2,<br/>      "price": 200<br/>    }]<br/>  }'</span><span id="4caa" class="ls lt iq pc b gy pk ph l pi pj">HTTP/1.1 201 Created<br/>...<br/>{<br/>  "items": [<br/>    {<br/>      "productid": "94e8d5de-2192-4419...",<br/>      "quantity": 2,<br/>      "price":200<br/>    }<br/>  ]<br/>}</span></pre><p id="d7ac" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">下一步将是重构<code class="fe pr ps pt pc b">GET /users</code>，将JWT验证也从<code class="fe pr ps pt pc b">identity-service</code>中卸载。</p><p id="4e26" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我将把这作为一个练习。不过，在开始之前，请确保在身份服务中禁用服务级别JWT验证:</p><pre class="kg kh ki kj gt pb pc pd pe aw pf bi"><span id="8063" class="ls lt iq pc b gy pg ph l pi pj">docker-compose.yaml<br/>---<br/>identity-service:<br/>  ...<br/>  - JWT_VALIDATION_ENABLED=false    # offloaded to the gateway!<br/>  ...</span><span id="ca8b" class="ls lt iq pc b gy pk ph l pi pj">$ docker compose down &amp;&amp; docker compose up</span></pre><h2 id="5464" class="ls lt iq bd lu lv lw dn lx ly lz dp ma lf mb mc md lj me mf mg ln mh mi mj mk bi translated">确认</h2><p id="5c43" class="pw-post-body-paragraph kw kx iq ky b kz ml jr lb lc mm ju le lf mn lh li lj mo ll lm ln mp lp lq lr ij bi translated">下面的例子纯粹是为了说明，展示了KrakenD如何执行基于<a class="ae kv" href="https://json-schema.org/" rel="noopener ugc nofollow" target="_blank">模式</a>的JSON验证。明智的做法可能是不要将网关与业务逻辑耦合在一起(不像这个例子)，确保服务保持在它们的边界内。</p><p id="440b" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">出于说明的目的，让我们指定<code class="fe pr ps pt pc b">/register</code>端点的<code class="fe pr ps pt pc b">email</code>和<code class="fe pr ps pt pc b">password</code>字段是<code class="fe pr ps pt pc b">required</code>，并且必须是类型<code class="fe pr ps pt pc b">string</code>:</p><pre class="kg kh ki kj gt pb pc pd pe aw pf bi"><span id="8b82" class="ls lt iq pc b gy pg ph l pi pj">krakend.yaml<br/>---<br/>...<br/>- endpoint: /auth/register<br/>  method: POST<br/>  output_encoding: no-op<br/>  extra_config:<br/>    github.com/devopsfaith/krakend-jsonschema:<br/>      type: object<br/>      required:<br/>      - email<br/>      - password<br/>      properties:<br/>        email:<br/>          type: string<br/>        password:<br/>          type: string<br/>  backend:<br/>  ...<br/>...</span></pre><p id="a963" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">首先，更改<code class="fe pr ps pt pc b">email</code>键以发送无效有效载荷:</p><pre class="kg kh ki kj gt pb pc pd pe aw pf bi"><span id="586b" class="ls lt iq pc b gy pg ph l pi pj">$ docker compose restart gateway</span><span id="a36e" class="ls lt iq pc b gy pk ph l pi pj">$ curl '<a class="ae kv" href="http://0.0.0.0:8000/auth/register'" rel="noopener ugc nofollow" target="_blank">http://0.0.0.0:</a><a class="ae kv" href="http://0.0.0.0:8000/users'" rel="noopener ugc nofollow" target="_blank">8080</a><a class="ae kv" href="http://0.0.0.0:8000/auth/register'" rel="noopener ugc nofollow" target="_blank">/auth/register'</a> \<br/>    --request POST \<br/>    --header "Content-type: application/json" \<br/>    --include \<br/>    --data '{<br/>      "emai": "<a class="ae kv" href="mailto:no@ebo.dy" rel="noopener ugc nofollow" target="_blank">no@ebo.dy</a>",<br/>      "password": "pass"<br/>    }'</span><span id="5a0a" class="ls lt iq pc b gy pk ph l pi pj">HTTP/1.1 400 Bad Request</span></pre><p id="dd61" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">更正您的有效负载并验证请求是否成功:</p><pre class="kg kh ki kj gt pb pc pd pe aw pf bi"><span id="415a" class="ls lt iq pc b gy pg ph l pi pj">$ curl '<a class="ae kv" href="http://0.0.0.0:8000/auth/register'" rel="noopener ugc nofollow" target="_blank">http://0.0.0.0:</a><a class="ae kv" href="http://0.0.0.0:8000/users'" rel="noopener ugc nofollow" target="_blank">8080</a><a class="ae kv" href="http://0.0.0.0:8000/auth/register'" rel="noopener ugc nofollow" target="_blank">/auth/register'</a> \<br/>    --request POST \<br/>    --header "Content-type: application/json" \<br/>    --include \<br/>    --data '{<br/>      "email": "<a class="ae kv" href="mailto:no@ebo.dy" rel="noopener ugc nofollow" target="_blank">no@ebo.dy</a>2",<br/>      "password": "pass"<br/>    }'</span><span id="494c" class="ls lt iq pc b gy pk ph l pi pj">HTTP/1.1 201 Created</span><span id="3188" class="ls lt iq pc b gy pk ph l pi pj">{<br/>  "token":"eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCIsImtpZCI6InVzZXJ...",<br/>  "expiry":1625254416<br/>}</span></pre><h2 id="d8ea" class="ls lt iq bd lu lv lw dn lx ly lz dp ma lf mb mc md lj me mf mg ln mh mi mj mk bi translated">限速</h2><p id="9a23" class="pw-post-body-paragraph kw kx iq ky b kz ml jr lb lc mm ju le lf mn lh li lj mo ll lm ln mp lp lq lr ij bi translated">最后，我们将关注交通管理。为了保护我们的服务不被过度使用——无论是有意还是无意，我们可以对关键路径或未屏蔽路径进行速率限制，并为我们的客户建立使用配额。</p><p id="49e2" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">首先，用100个请求轰炸我们的<code class="fe pr ps pt pc b">/register</code>端点，看看会发生什么:</p><pre class="kg kh ki kj gt pb pc pd pe aw pf bi"><span id="046e" class="ls lt iq pc b gy pg ph l pi pj">for i in {1..100}; do curl '<a class="ae kv" href="http://0.0.0.0:8000/auth/login'" rel="noopener ugc nofollow" target="_blank">http://0.0.0.0:</a><a class="ae kv" href="http://0.0.0.0:8000/users'" rel="noopener ugc nofollow" target="_blank">8080</a><a class="ae kv" href="http://0.0.0.0:8000/auth/login'" rel="noopener ugc nofollow" target="_blank">/auth/register'</a> \<br/>  --request POST \<br/>  --header "Content-type: application/json" \<br/>  --include \<br/>  --data '{<br/>    "email": "d<a class="ae kv" href="mailto:somebody@nobody.com" rel="noopener ugc nofollow" target="_blank">@d.</a>os",<br/>    "password": "pass"<br/>  }';<br/>done</span><span id="dbc8" class="ls lt iq pc b gy pk ph l pi pj">HTTP/1.1 201 Created<br/>HTTP/1.1 409 Conflict<br/>HTTP/1.1 409 Conflict<br/>...<br/>HTTP/1.1 409 Conflict # 100</span></pre><p id="6236" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">每个请求都由身份服务处理，导致过多的处理和数据库通信。</p><p id="bec3" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">现在为<code class="fe pr ps pt pc b">/register</code>端点添加每秒5个请求的限制(每个IP地址)和每秒100个请求的上限:</p><pre class="kg kh ki kj gt pb pc pd pe aw pf bi"><span id="9f57" class="ls lt iq pc b gy pg ph l pi pj">krakend.yaml<br/>---<br/>...<br/>- endpoint: /auth/register<br/>    ...<br/>    github.com/devopsfaith/krakend-jsonschema:<br/>    ...<br/>    github.com/devopsfaith/krakend-ratelimit/juju/router:<br/>      maxRate: 100<br/>      clientMaxRate: 5<br/>      strategy: ip<br/>    ...<br/>...</span></pre><p id="cefd" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">注意网关是如何短路所有超过我们配额的请求的:</p><pre class="kg kh ki kj gt pb pc pd pe aw pf bi"><span id="5e66" class="ls lt iq pc b gy pg ph l pi pj">$ docker compose restart gateway</span><span id="f8cd" class="ls lt iq pc b gy pk ph l pi pj">for i in {1..100}; do curl '<a class="ae kv" href="http://0.0.0.0:8000/auth/login'" rel="noopener ugc nofollow" target="_blank">http://0.0.0.0:</a><a class="ae kv" href="http://0.0.0.0:8000/users'" rel="noopener ugc nofollow" target="_blank">8080</a><a class="ae kv" href="http://0.0.0.0:8000/auth/login'" rel="noopener ugc nofollow" target="_blank">/auth/register'</a> \<br/>  --request POST \<br/>  --header "Content-type: application/json" \<br/>  --include \<br/>  --data '{<br/>    "email": "d<a class="ae kv" href="mailto:somebody@nobody.com" rel="noopener ugc nofollow" target="_blank">@d.</a>os",<br/>    "password": "pass"<br/>  }';<br/>done</span><span id="1038" class="ls lt iq pc b gy pk ph l pi pj">HTTP/1.1 201 Created<br/>HTTP/1.1 409 Conflict<br/>...<br/>HTTP/1.1 429 Too Many Requests<br/>...<br/>HTTP/1.1 429 Too Many Requests</span></pre><h2 id="14ef" class="ls lt iq bd lu lv lw dn lx ly lz dp ma lf mb mc md lj me mf mg ln mh mi mj mk bi translated">知道什么时候停下来</h2><p id="4603" class="pw-post-body-paragraph kw kx iq ky b kz ml jr lb lc mm ju le lf mn lh li lj mo ll lm ln mp lp lq lr ij bi translated">随着API市场中的供应商不断添加特性来区分他们的产品，知道何时停止将责任推卸到边缘很重要。臃肿和过于雄心勃勃的网关很难测试和部署。</p><p id="7695" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">除了责任过多之外，其他可能的顾虑包括:</p><ul class=""><li id="b17a" class="mq mr iq ky b kz la lc ld lf ms lj mt ln mu lr mv mw mx my bi translated"><strong class="ky ir">单点故障。</strong>作为后端层的单一入口点，我们必须确保网关具有弹性。通过<a class="ae kv" href="https://en.wikipedia.org/wiki/Redundancy_(engineering)" rel="noopener ugc nofollow" target="_blank">冗余</a>、<a class="ae kv" href="https://en.wikipedia.org/wiki/Elasticity_(cloud_computing)" rel="noopener ugc nofollow" target="_blank">弹性</a>和<a class="ae kv" href="https://en.wikipedia.org/wiki/Recovery-oriented_computing" rel="noopener ugc nofollow" target="_blank">故障恢复机制</a>避免单点故障。</li><li id="a928" class="mq mr iq ky b kz na lc nb lf nc lj nd ln ne lr mv mw mx my bi translated"><strong class="ky ir">需要维护的额外服务。维护网关的工作会招致技术债务吗？这对开发团队的职责意味着什么？</strong></li><li id="cd80" class="mq mr iq ky b kz na lc nb lf nc lj nd ln ne lr mv mw mx my bi translated"><strong class="ky ir">一个额外的网络跳。</strong>由于到后端的额外网络跳跃，网关可能会增加响应时间。虽然这比直接的客户端到后端的请求影响要小，但是持续地对系统进行负载测试仍然是至关重要的，这可以确保我们满怀信心地满足我们的SLO。</li></ul><h2 id="2a64" class="ls lt iq bd lu lv lw dn lx ly lz dp ma lf mb mc md lj me mf mg ln mh mi mj mk bi translated">最终的克拉肯清单</h2><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nf ng l"/></div></figure></div><div class="ab cl nh ni hu nj" role="separator"><span class="nk bw bk nl nm nn"/><span class="nk bw bk nl nm nn"/><span class="nk bw bk nl nm"/></div><div class="ij ik il im in"><h1 id="d2f6" class="no lt iq bd lu np nq nr lx ns nt nu ma jw nv jx md jz nw ka mg kc nx kd mj ny bi translated">包扎</h1><p id="e350" class="pw-post-body-paragraph kw kx iq ky b kz ml jr lb lc mm ju le lf mn lh li lj mo ll lm ln mp lp lq lr ij bi translated">API网关为客户端提供了一个可靠的接口，也是管理请求和响应的中心点。</p><p id="9c6a" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在分布式架构中，它们可以用来卸载那些原本必须复制的横切功能。API网关有很多优点，但是它也增加了另一个组件来维护和优化性能和可靠性。</p><p id="bc3b" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">感谢阅读。</p></div><div class="ab cl nh ni hu nj" role="separator"><span class="nk bw bk nl nm nn"/><span class="nk bw bk nl nm nn"/><span class="nk bw bk nl nm"/></div><div class="ij ik il im in"><p id="04e3" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><em class="mz">本文最初发布于:</em><a class="ae kv" href="https://portfolio.fabijanbajo.com/api-gateways" rel="noopener ugc nofollow" target="_blank">https://portfo lio.fabijanbajo.com/api-gateways</a></p></div></div>    
</body>
</html>