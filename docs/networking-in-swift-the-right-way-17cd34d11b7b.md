# 以正确的方式快速联网

> 原文：<https://betterprogramming.pub/networking-in-swift-the-right-way-17cd34d11b7b>

## 正确检索资源的分步指南

![](img/e8d985d321b211088588fe980539c745.png)

照片由 [rawpixel](https://unsplash.com/@rawpixel?utm_source=medium&utm_medium=referral) 在 [Unsplash](https://unsplash.com?utm_source=medium&utm_medium=referral) 上拍摄

这篇文章是关于网络的初级读本，讲述了检索资源的正确方法。

我想把资源分成三组，从离你的应用最近的资源开始，这将为你接下来的文章提供参考点。

1.  应用程序资源-应用程序项目中包含的资源。它们可能位于一个`.xcassets`文件夹或一个通常命名的 resources 文件夹中。
2.  本地资源-运行应用程序的设备上的资源。在 iOS 中，这将是应用程序的沙箱；在 macOS 上，这将是应用程序在电脑上可以到达的所有允许的位置。
3.  远程资源—存在于其他地方的资源，如网站或您家中的另一台计算机。

在那些讨厌我说网站而不是 URL 或 API 的人来找我之前，我想提一下 URL 代表“统一资源定位器”,它甚至存在于本地文件和路径中。API，“应用程序编程接口”也不一定是远程资源。广告拦截器可能会使用 Safari 的 API 来拦截广告。

定义说够了，让我们从一个我经常看到的例子开始:

好的，所有这些看起来都不错。我们首先使用 URL 字符串创建我们的`imageURL`。因为`Data:contentsOf`可以抛出一个错误，所以我们用`try/catch`语句将它括起来。

假设我们没有抛出错误，我们可以在屏幕上显示图像。否则，我们会向控制台显示一条错误消息。

这实际上是可行的，但是，这被认为是执行网络调用的错误方式。为什么？让我们参考文档。

 [## init(contents of:options:)—ns data | Apple 开发者文档

### 不要使用这种同步方法来请求基于网络的 URL。对于基于网络的网址，这种方法可以阻止…

developer.apple.com](https://developer.apple.com/documentation/foundation/nsdata/1407864-init) 

> 不要使用这种同步方法来请求基于网络的 URL。对于基于网络的 URL，这种方法在慢速网络上可以阻塞当前线程数十秒，导致用户体验不佳，而在 iOS 中，可能会导致你的 app 被终止。

这听起来不吉利。因为它是一个同步方法，意味着它使用主队列，所以它可以阻塞你的主线程。现在你可能会说，“但是我的图像只有几 KB 大小，应该没什么大不了的。”让我问一下，如果你试图在一个非常慢的网络上下载那个文件呢？如果你的手机信号不好怎么办？

你的用户界面可能会有一秒钟无法使用，如果这种情况经常发生，这足以让你得到差评。

另一方面，如果你只知道怎么做，那么当你通过同样糟糕的连接下载一个 50 MB 的文件时，你会怎么做呢？如果你需要 50 MB 来向用户展示你的游戏的新水平呢？`Data:contentsOf:`还不够，因为一旦用户结束应用程序，数据就会丢失。它不会存储部分数据，并在您的应用程序恢复时神奇地恢复。

这一重任正是 Swift 网络库的用武之地。

不允许我轻描淡写`Data:contentsOf:`，它有它的位置，而且很精彩。此方法仅适用于本地和应用程序资源。

> **注意:**如果你想在你的应用之外获取本地系统资源，你需要关闭沙盒。

如果您想尝试上面的例子，只需创建一个新的 playground，并在 playground 的 resources 文件夹中放置一个名为 wishlist.txt 的文件，其中包含您的愿望列表。

所以我们讨论了本地文件，T2 是处理远程资源的错误方式，但是什么是正确的方式呢？

正确的做法是使用`URLSession`。`URLSession`提供了一个很好的实用程序库来帮助你下载文件和跟踪请求。让我们从上面看一个使用亚瑟猫的简单实现。

这里有新的内容要介绍。首先，我们创建一个会话，而不是使用默认的实现。虽然我可以直接使用`URLSession.shared.dataTask`键，但我选择了创建会话。这样，我就可以随时选择在以后定制连接属性。这是我个人的喜好。

有关共享会话的更多信息，请参阅 Apple 的文稿。

 [## 共享— URLSession | Apple 开发者文档

### 通常，在使用共享会话时，应该避免自定义缓存、cookie 存储或凭据…

developer.apple.com](https://developer.apple.com/documentation/foundation/urlsession/1409000-shared) 

接下来，我们必须创建一个任务。该任务负责下载文件和处理响应。任务本身是一个闭包，但是我们使用尾随闭包语法并将`(data, response, error)`传递给闭包。这些都是可选值，如果您使用 Xcode，自动完成功能会指出这些是可选的。`data`是我们期望从远程位置接收的数据，`response`是我们接收的响应头信息，`error`仅在发生错误时填充。

在闭包内部，我们首先检查是否收到了错误。该错误与客户端或服务器错误无关，而是设备通信错误，例如设备处于飞行模式。

> 如果我们从服务器收到 404-Page Not found 消息，即使数据检索不成功,`*URLSession*`仍会认为呼叫成功。这就是错误与响应分开的原因。

如果我们没有收到错误，那么我们可以继续，首先检查以确保我们收到了状态代码 200。`URLResponse`类型不包含状态代码属性，但是`HTTPURLResponse`包含。更好的是`URLResponse`可以被转换成`HTTPURLResponse`，这样我们就可以访问状态代码了。

200 — OK 不是我们可以检查的唯一好的响应代码，但它是最受欢迎的。要获得完整的参考资料，可以参考以下资源。这个很不错。

 [## HTTP 状态代码

### HTTP 状态代码以及如何在 RESTful API 或 Web 服务中使用它们。

www.restapitutorial.com](https://www.restapitutorial.com/httpstatuscodes.html) 

在我们的例子中，我们期望得到一个状态码 200，所以这是我们唯一需要检查的。如果我们想要检查更多，我们可以创建一个我们想要检查的所有状态代码的数组，例如:

```
let acceptableCodes = [200, 201, 202, 203, 304]
```

然后使用以下内容检查状态:

```
if acceptableCodes.contains(httpResponse.statusCode) { ... }
```

这允许我们根据需要向数组中添加更多可接受的代码，从而简化我们未来的更改。

最后，因为`data`是可选的，我们需要将`data?`展开成我们可以立即使用的东西。我将`data`解包到`receivedData`中，这给了我们非可选的数据，万一`data`仍然为零，我们不会让程序崩溃。

利用我们展开的数据，我们可以将`imageView`的`image`属性设置为`receivedData`的一个`UIImage`表示。因为这是 UI 工作，所以我们需要在主队列上完成:

```
DispatchQueue.main.async {
    imageView.image = UIImage(data: receivedData)
}
```

很简单。

在下载文件之前，还需要做一件事。

还记得我们创建一个负责下载文件的任务吗？这个任务有一个与之相关联的方法叫做`resume()`。`resume()`告知任务执行本次下载任务。我们需要调用这个方法来真正开始下载过程。

如果这样做似乎很麻烦，请考虑一下这为您的应用程序提供了多大的灵活性。您可以创建您的下载任务，然后在合适的时间调用它们，或者您可以创建一个通用的下载任务，并将其用于多个调用，对多个远程资源重用同一个下载任务。

# 摘要

当谈到`URLSession`时，我们可以展开更多的讨论，但这只是对下载文件的正确方法的简单介绍，而不是认为`data:contentsOf:`就是这样做的。

`URLSession`还提供代理，这样你就可以允许你的用户暂停、继续和停止下载，就像用户在使用 Apple Music、App Store 甚至观看视频时一样。

甚至还有一个后台任务选项，允许你继续下载文件，即使应用程序已经被推到后台(而不是当用户强制退出应用程序)。

对于开发中的快速一次性测试(例如，弄清楚收到的 JSON 的格式)，使用`Data:contentsOf:`就可以了，但是对于生产环境，对于远程数据，您应该总是使用`URLSession`。