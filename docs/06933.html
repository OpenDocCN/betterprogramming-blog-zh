<html>
<head>
<title>How to Implement Your Distributed Filesystem With GlusterFS And Kubernetes</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何用GlusterFS和Kubernetes实现分布式文件系统</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/how-to-implement-your-distributed-filesystem-with-glusterfs-and-kubernetes-83ee7f5f834f?source=collection_archive---------4-----------------------#2020-11-18">https://betterprogramming.pub/how-to-implement-your-distributed-filesystem-with-glusterfs-and-kubernetes-83ee7f5f834f?source=collection_archive---------4-----------------------#2020-11-18</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="7314" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">了解使用GlusterFS的优势，以及它如何帮助实现高度可伸缩的分布式文件系统</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/d8ca87401b2a67bf4d80c5c881c00227.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*zC90xjz2HcV69Lio"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated"><a class="ae ky" href="https://unsplash.com/@live_for_photo?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">滕玉红</a>在<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的照片</p></figure><h1 id="a7e4" class="kz la it bd lb lc ld le lf lg lh li lj jz lk ka ll kc lm kd ln kf lo kg lp lq bi translated">介绍</h1><p id="cf06" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">对于任何遇到过任何类型的容器编排平台(最常见的是Kubernetes)的人来说，众所周知，管理存储是一件非常痛苦的事情。不是因为底层组件的复杂性或数量，而是因为这种平台架构的动态特性。</p><p id="d5a8" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">在分布式集群中运行时，Kubernetes可以以各种方式操作容器和pods创建、销毁、复制、自动缩放等。作为维护人员，您通常不知道它们将放在哪个物理(或虚拟)机器上。因此，要访问持久性存储，必须使用某种外部数据供应服务。</p><p id="4cac" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">Kubernetes有持久卷的概念，可以用<a class="ae ky" href="https://kubernetes.io/docs/concepts/storage/volumes/#types-of-volumes" rel="noopener ugc nofollow" target="_blank">多种方式</a>实现。现在最简单常用的当然是<a class="ae ky" href="https://kubernetes.io/docs/concepts/storage/volumes/#nfs" rel="noopener ugc nofollow" target="_blank"><strong class="lt iu"/></a><strong class="lt iu">。</strong>您需要做的就是安装<a class="ae ky" href="https://github.com/helm/charts/tree/master/stable/nfs-server-provisioner" rel="noopener ugc nofollow" target="_blank">舵图</a>并在任何卷声明中使用创建的<a class="ae ky" href="https://kubernetes.io/docs/concepts/storage/storage-classes/#:~:text=A%20StorageClass%20provides,other%20storage%20systems" rel="noopener ugc nofollow" target="_blank">存储类</a>。但是尽管如此简单和容易上手，不幸的是，这种实践并不像有时需要的那样有效和灵活。</p><p id="3aa5" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">我面临的关键限制是无法为不同名称空间中的pod提供共享存储。尽管我可以忽略逻辑分离并合并名称空间，但这个问题加上糟糕的伸缩效率是找到替代物的决定性因素。</p></div><div class="ab cl ms mt hx mu" role="separator"><span class="mv bw bk mw mx my"/><span class="mv bw bk mw mx my"/><span class="mv bw bk mw mx"/></div><div class="im in io ip iq"><p id="ff70" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">当搜索一个<a class="ae ky" href="https://yourserveradmin.com/network-file-systems/" rel="noopener ugc nofollow" target="_blank">分布式或集群式文件系统</a>时，选择最终归结为几个选项。今天，最出色的当然是<a class="ae ky" href="https://www.gluster.org/" rel="noopener ugc nofollow" target="_blank"> GlusterFS </a>和<a class="ae ky" href="https://ceph.io/" rel="noopener ugc nofollow" target="_blank"> CephFS </a>。但是，我不建议仅仅根据这篇文章做出选择。自己做研究。因为除了这些，还有很多其他选项如<a class="ae ky" href="https://access.redhat.com/documentation/en-us/red_hat_enterprise_linux/6/html-single/global_file_system_2/index" rel="noopener ugc nofollow" target="_blank"> GFS 2 </a>，<a class="ae ky" href="https://www.lustre.org" rel="noopener ugc nofollow" target="_blank"> Lustre </a>，<a class="ae ky" href="https://min.io" rel="noopener ugc nofollow" target="_blank"> MinIO </a> <strong class="lt iu">，</strong> <a class="ae ky" href="https://moosefs.com" rel="noopener ugc nofollow" target="_blank"> MooseFS </a>，以及<a class="ae ky" href="https://en.wikipedia.org/wiki/Comparison_of_distributed_file_systems" rel="noopener ugc nofollow" target="_blank"> more </a>等。我还推荐看看<a class="ae ky" href="https://rook.io/" rel="noopener ugc nofollow" target="_blank"> Rook </a>，它本身实际上并不是一个DFS，而是旨在扩展Kubernetes存储管理潜力的<a class="ae ky" href="https://www.cncf.io/announcements/2020/10/07/cloud-native-computing-foundation-announces-rook-graduation/" rel="noopener ugc nofollow" target="_blank">云原生</a>存储协调器。</p><p id="f141" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">GlusterFS和CephFS都是开源的软件定义存储(SDN)系统，分别提供分布式、高度可扩展和高度可用的块和对象存储。与专有解决方案相比，两者都有一定的优势。随着存储大小的增加，它们之间的真正区别开始显现出来。Gluster在更高的规模上表现良好，可以在短时间内从TB级增长到Pb级。另一方面，由于其存储格式，Ceph提供了用户更频繁访问的更有效的短期存储。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi mz"><img src="../Images/33c2aeac029ba5c976656e89110ba8ca.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*lj-jL78DzHSmgNXRhRD_Vw.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">GlusterFS新旧标志</p></figure></div><div class="ab cl ms mt hx mu" role="separator"><span class="mv bw bk mw mx my"/><span class="mv bw bk mw mx my"/><span class="mv bw bk mw mx"/></div><div class="im in io ip iq"><h1 id="3c9b" class="kz la it bd lb lc na le lf lg nb li lj jz nc ka ll kc nd kd ln kf ne kg lp lq bi translated">挖掘建筑</h1><p id="7ea9" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">Gluster文件系统解决方案在更高的抽象层次上由三个主要组件组成:</p><ul class=""><li id="0e09" class="nf ng it lt b lu mn lx mo ma nh me ni mi nj mm nk nl nm nn bi translated">Gluster <em class="no">服务器</em>由<a class="ae ky" href="https://kubernetes.io/docs/concepts/workloads/controllers/daemonset/" rel="noopener ugc nofollow" target="_blank"> DaemonSet </a>作为存储块安装在K8s节点上</li><li id="a6ad" class="nf ng it lt b lu np lx nq ma nr me ns mi nt mm nk nl nm nn bi translated">Gluster <em class="no">客户端</em>直接安装在物理机器上，并通过TCP/IP和socket direct等协议连接到服务器</li><li id="58f0" class="nf ng it lt b lu np lx nq ma nr me ns mi nt mm nk nl nm nn bi translated"><em class="no">管理API </em>用于抽象出低级卷操作</li></ul><p id="261f" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">公平地说，最后一个(API)不是必需的，因为您可以创建专用的端点，并使用它们自己手动创建持久卷。</p><p id="9e57" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">但是，我觉得这样会让使用的过程更加复杂。相比之下，management API提供了一个自动化的界面，可以在K8s StorageClass的帮助下创建、调整和删除PV。因此，您只需要关心一次部署和配置。如果你问我，我说这是一个更有吸引力和优雅的方式。</p><p id="1454" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">这就是为什么在本教程中我们将使用<a class="ae ky" href="https://github.com/heketi/heketi" rel="noopener ugc nofollow" target="_blank"><strong class="lt iu">heke ti</strong></a><strong class="lt iu"/>——基于RESTful的卷管理框架主要用Go编写，这使得使用GlusterFS变得轻而易举。</p><h1 id="7b20" class="kz la it bd lb lc ld le lf lg lh li lj jz lk ka ll kc lm kd ln kf lo kg lp lq bi translated">指令</h1><p id="72e0" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">在我们开始之前，值得一提的是，我将以一种更具体的方式来描述数字海洋的托管Kubernetes，因为它是我选择的云基础设施提供商。当然，有些部分是所有提供者共有的——事实上，大多数都是如此。因此，如果你正在使用某些东西，比如GKE的<a class="ae ky" href="https://cloud.google.com/kubernetes-engine" rel="noopener ugc nofollow" target="_blank">或亚马逊EKS的</a><a class="ae ky" href="https://aws.amazon.com/eks/?whats-new-cards.sort-by=item.additionalFields.postDateTime&amp;whats-new-cards.sort-order=desc&amp;eks-blogs.sort-by=item.additionalFields.createdDate&amp;eks-blogs.sort-order=desc" rel="noopener ugc nofollow" target="_blank">，我们完全欢迎你留下来。<br/>好了，如果所有这些都解决了，让我们最终开始吧！</a></p></div><div class="ab cl ms mt hx mu" role="separator"><span class="mv bw bk mw mx my"/><span class="mv bw bk mw mx my"/><span class="mv bw bk mw mx"/></div><div class="im in io ip iq"><h1 id="9e06" class="kz la it bd lb lc na le lf lg nb li lj jz nc ka ll kc nd kd ln kf ne kg lp lq bi translated">访问节点的地面操作系统</h1><p id="c384" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">为了首先部署GlusterFS，您需要创建一个磁盘设备分区，因为它的低级性质使Gluster不能在预先存在的文件系统上工作，需要一个完全原始的磁盘设备或其分区。</p><p id="b665" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">DigitalOcean K8s节点运行在Debian 10 (Buster)操作系统之上，在此之前，您需要访问它。由于K8s节点也是DO的<a class="ae ky" href="https://www.digitalocean.com/products/droplets/" rel="noopener ugc nofollow" target="_blank">droplet</a>(管理的VPS的代号)你可以从droplet管理控制台的专用选项卡中完成。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nu"><img src="../Images/c5d381640767b118e1a10deae2fc317c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*YPJFWSNa6nhlKdc7ZDgFpQ.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">获取液滴访问程序—作者插图</p></figure><p id="4fe5" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">一旦你进入，准备复制和粘贴(或者手动输入，如果你真的想的话)大量的命令，因为考虑到DO web控制台的极端用户友好性，这有时会相当令人沮丧。</p></div><div class="ab cl ms mt hx mu" role="separator"><span class="mv bw bk mw mx my"/><span class="mv bw bk mw mx my"/><span class="mv bw bk mw mx"/></div><div class="im in io ip iq"><h1 id="b021" class="kz la it bd lb lc na le lf lg nb li lj jz nc ka ll kc nd kd ln kf ne kg lp lq bi translated">创建一个全新的磁盘分区</h1><p id="3acb" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">我们将使用<a class="ae ky" href="https://grml.org/" rel="noopener ugc nofollow" target="_blank"> GRML </a>可引导实时系统来缩小现有的磁盘分区。通过<code class="fe nv nw nx ny b">apt-get</code>实用程序安装:</p><pre class="kj kk kl km gt nz ny oa ob aw oc bi"><span id="a0a3" class="od la it ny b gy oe of l og oh">$ apt-get install grml-rescueboot</span></pre><p id="9961" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">以及将引导映像从官方来源下载到引导目录中。我使用了当时最新的版本。然后设置它:</p><pre class="kj kk kl km gt nz ny oa ob aw oc bi"><span id="5d6e" class="od la it ny b gy oe of l og oh">$ cd /boot/grml</span><span id="b7aa" class="od la it ny b gy oi of l og oh">$ wget <a class="ae ky" href="http://download.grml.org/grml64-small_2020.06.iso" rel="noopener ugc nofollow" target="_blank">http://download.grml.org/grml64-small_2020.06.iso</a></span><span id="9f89" class="od la it ny b gy oi of l og oh">$ update-grub</span></pre><p id="51b9" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">现在，在重启系统之前，我建议使用<code class="fe nv nw nx ny b"><a class="ae ky" href="https://linux.die.net/man/8/lsblk" rel="noopener ugc nofollow" target="_blank">lsblk</a></code>工具检查可用的磁盘设备。您的输出可能与此相同，但仍然值得检查:</p><pre class="kj kk kl km gt nz ny oa ob aw oc bi"><span id="e1af" class="od la it ny b gy oe of l og oh">$ lsblk</span><span id="6627" class="od la it ny b gy oi of l og oh"><strong class="ny iu">NAME   MAJ:MIN RM   SIZE RO TYPE MOUNTPOINT</strong><br/>vda    254:0    0    80G  0 disk <br/>├─vda1 254:1    0  79.9G  0 part /<br/>└─vda2 254:2    0     2M  0 part <br/>vdb    254:16   0   446K  0 disk</span></pre><p id="c1b8" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">这意味着你有一个主磁盘设备(<code class="fe nv nw nx ny b">vda</code> <strong class="lt iu"> ) </strong>，它已经被分成了两个分区。当然，你会对更大的(<code class="fe nv nw nx ny b">vda1</code>)感兴趣，因为<code class="fe nv nw nx ny b">vda2</code>的大小只够存储BIOS。在接下来的步骤中，您将首先收缩<code class="fe nv nw nx ny b">vda1</code>以从<code class="fe nv nw nx ny b">vda</code>设备中安全地切割一个新的分区。</p><p id="f250" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">一旦你得到了一个分区图，通过键入<code class="fe nv nw nx ny b">reboot</code>重启你的系统。快速启动时，选择以下选项:</p><ul class=""><li id="f299" class="nf ng it lt b lu mn lx mo ma nh me ni mi nj mm nk nl nm nn bi translated"><code class="fe nv nw nx ny b">Grml Rescue System</code></li><li id="d564" class="nf ng it lt b lu np lx nq ma nr me ns mi nt mm nk nl nm nn bi translated"><code class="fe nv nw nx ny b">grml64-small — advance options</code></li><li id="27e8" class="nf ng it lt b lu np lx nq ma nr me ns mi nt mm nk nl nm nn bi translated"><code class="fe nv nw nx ny b">grml64-small — copy Grml to RAM</code></li></ul><p id="07e9" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">然后，您将出现在Grml控制台中，在这里您可以选择更改键盘布局。如果默认用户对您来说没问题，只需点击<code class="fe nv nw nx ny b">Return</code> <em class="no">。</em></p><p id="ca61" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">使用<code class="fe nv nw nx ny b"><a class="ae ky" href="https://manpages.debian.org/buster/e2fsprogs/resize2fs.8.en.html" rel="noopener ugc nofollow" target="_blank">resize2fs</a></code>缩小现有文件系统:</p><pre class="kj kk kl km gt nz ny oa ob aw oc bi"><span id="4a18" class="od la it ny b gy oe of l og oh">$ fsck.ext4 -f /dev/vda1</span><span id="459e" class="od la it ny b gy oi of l og oh">$ resize2fs -M /dev/vda1</span></pre><p id="8266" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">然后使用<code class="fe nv nw nx ny b"><a class="ae ky" href="http://manpages.debian.org/cgi-bin/man.cgi?query=parted&amp;apropos=0&amp;sektion=0&amp;manpath=Debian+8+jessie&amp;format=html&amp;locale=en" rel="noopener ugc nofollow" target="_blank">parted</a></code>调整其大小并创建一个新的:</p><pre class="kj kk kl km gt nz ny oa ob aw oc bi"><span id="1550" class="od la it ny b gy oe of l og oh">$ parted /dev/vda</span><span id="b04b" class="od la it ny b gy oi of l og oh">$ resizepart 1 30G <em class="no"># shrink </em><strong class="ny iu"><em class="no">vda1</em></strong><em class="no"> to </em><strong class="ny iu"><em class="no">30 Gb</em></strong></span><span id="cce7" class="od la it ny b gy oi of l og oh">$ mkpart gluster 30001 100% <em class="no"># create </em><strong class="ny iu"><em class="no">vda3</em></strong><em class="no"> where </em><strong class="ny iu"><em class="no">vda1 </em></strong><em class="no">ends</em></span><span id="304a" class="od la it ny b gy oi of l og oh">$ set 3 lvm on <em class="no"># optionally setup logical volumes</em></span><span id="0441" class="od la it ny b gy oi of l og oh">$ print <em class="no"># verify results</em></span><span id="6838" class="od la it ny b gy oi of l og oh">$ quit</span></pre><p id="d4c7" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">在我的例子中，我创建了一个大小为50Gb的新分区，因此我将现有部分的大小调整为30 Gb。如果你想要不同的东西，自己算算。您可以随时使用<code class="fe nv nw nx ny b"><a class="ae ky" href="https://manpages.debian.org/buster/fdisk/fdisk.8.en.html" rel="noopener ugc nofollow" target="_blank">fdisk</a></code>实用程序再次检查:</p><pre class="kj kk kl km gt nz ny oa ob aw oc bi"><span id="ffc2" class="od la it ny b gy oe of l og oh">$ fdisk -l /dev/vda</span><span id="ff30" class="od la it ny b gy oi of l og oh">Device      Start    End        Sectors   Size  Type       <br/>/dev/vda1   6144     62920671   62914528  50G   Linux filesystem       /dev/vda2   2048     6143       4096      2M    BIOS boot       <br/>/dev/vda3   62920672 1667770111 104857546 30G   Linux filesystem</span></pre><p id="3ae0" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">完成后，通过键入<code class="fe nv nw nx ny b">reboot</code> <em class="no">重新启动系统。</em></p></div><div class="ab cl ms mt hx mu" role="separator"><span class="mv bw bk mw mx my"/><span class="mv bw bk mw mx my"/><span class="mv bw bk mw mx"/></div><div class="im in io ip iq"><h1 id="123b" class="kz la it bd lb lc na le lf lg nb li lj jz nc ka ll kc nd kd ln kf ne kg lp lq bi translated">通过符号链接链接存储设备</h1><p id="2587" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">下一个重要步骤是设置一个符号链接(<code class="fe nv nw nx ny b">symlink</code>)来将新创建的分区标识为GlusterFS存储设备。不建议使用设备名，如<code class="fe nv nw nx ny b">/dev/vda3</code>，因为该名称可能会在系统重新启动时改变。为此，您可以选择使用系统生成的符号链接或手动创建自己的符号链接。</p><p id="7606" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">要获得预先存在的符号链接，只需使用:</p><pre class="kj kk kl km gt nz ny oa ob aw oc bi"><span id="9ac5" class="od la it ny b gy oe of l og oh">$ ls -altr /dev/disk/* | grep &lt;device&gt;</span></pre><p id="e61a" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">对<code class="fe nv nw nx ny b">/dev/vda3</code>来说，那将是<code class="fe nv nw nx ny b">/dev/disk/by-path/pci-0000:00:06.0-part3</code>。</p><p id="aff5" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">手动方式有点困难，但是您可以指定任何自定义名称。对我来说是<code class="fe nv nw nx ny b">/dev/disk/gluster-disk</code>。为了实现这一点，您需要首先使用指定源设备的<code class="fe nv nw nx ny b"><a class="ae ky" href="https://linux.die.net/man/8/udevadm" rel="noopener ugc nofollow" target="_blank">udevadm</a></code>实用程序获得一些设备的属性:</p><pre class="kj kk kl km gt nz ny oa ob aw oc bi"><span id="d4a3" class="od la it ny b gy oe of l og oh">$ udevadm info --root --name=/dev/vda3</span><span id="e08f" class="od la it ny b gy oi of l og oh"><strong class="ny iu">P: /devices/pci0000:00/0000:00:06.0/virtio3/block/vda/vda3</strong><br/>N: vda3<br/>E: DEVNAME=/dev/vda3<br/>E: DEVPATH=/devices/pci0000:00/0000:00:06.0/virtio3/block/vda/vda3<br/><strong class="ny iu">E: DEVTYPE=partition</strong><br/>E: MAJOR=254<br/>E: MINOR=3<br/><strong class="ny iu">E: SUBSYSTEM=block</strong><br/>E: TAGS=:systemd:<br/>E: USEC_INITIALIZED=1942797<br/>...</span></pre><p id="414c" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">需要突出显示的属性来形成符号链接规则，如下所示:</p><pre class="kj kk kl km gt nz ny oa ob aw oc bi"><span id="c52e" class="od la it ny b gy oe of l og oh">ENV{DEVTYPE}=="<strong class="ny iu">partition</strong>", ENV{SUBSYSTEM}=="<strong class="ny iu">block</strong>", ENV{DEVPATH}=="<strong class="ny iu">/devices/pci0000:00/0000:00:06.0/virtio3/block/vda/vda3</strong>" SYMLINK+="<em class="no">disk/gluster-disk</em>"</span></pre><p id="60ff" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">然后必须在<code class="fe nv nw nx ny b"><a class="ae ky" href="https://manpages.debian.org/stretch/nano/nano.1.en.html" rel="noopener ugc nofollow" target="_blank">nano</a></code>或<code class="fe nv nw nx ny b"><a class="ae ky" href="https://man7.org/linux/man-pages/man1/vi.1p.html" rel="noopener ugc nofollow" target="_blank">vi</a></code>实用程序的帮助下将其写入自定义规则文件:</p><pre class="kj kk kl km gt nz ny oa ob aw oc bi"><span id="1ba3" class="od la it ny b gy oe of l og oh">$ nano /lib/udev/rules.d/10-custom-icp.rules</span></pre><p id="5c58" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">最后，重新加载<code class="fe nv nw nx ny b">udev</code>规则来创建符号链接并验证结果:</p><pre class="kj kk kl km gt nz ny oa ob aw oc bi"><span id="a4f1" class="od la it ny b gy oe of l og oh">$ udevadm control --reload-rules<br/>$ udevadm trigger --type=devices --action=change</span><span id="a75c" class="od la it ny b gy oi of l og oh">$ ls -ltr /dev/disk/gluster-*</span><span id="a65c" class="od la it ny b gy oi of l og oh">lrwxrwxrwx 1 root root 7 Oct 21 16:20 /dev/disk/gluster-disk -&gt; ../vda3</span></pre></div><div class="ab cl ms mt hx mu" role="separator"><span class="mv bw bk mw mx my"/><span class="mv bw bk mw mx my"/><span class="mv bw bk mw mx"/></div><div class="im in io ip iq"><h1 id="2a13" class="kz la it bd lb lc na le lf lg nb li lj jz nc ka ll kc nd kd ln kf ne kg lp lq bi translated">设置Gluster客户端</h1><p id="2908" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">最后，您可以安装到目前为止整个游戏中最重要的部分，当然是— <a class="ae ky" href="https://docs.gluster.org/en/latest/Administrator%20Guide/Setting%20Up%20Clients/" rel="noopener ugc nofollow" target="_blank"> Gluster Native Client </a>。就在你配置好<code class="fe nv nw nx ny b"><a class="ae ky" href="https://access.redhat.com/documentation/en-us/red_hat_gluster_storage/3.3/html/container-native_storage_for_openshift_container_platform/ch06s02" rel="noopener ugc nofollow" target="_blank">dm_thin_pool</a></code>内核模块之后。没有什么可烦恼的，因为它实际上很简单:</p><pre class="kj kk kl km gt nz ny oa ob aw oc bi"><span id="65bc" class="od la it ny b gy oe of l og oh">$ modprobe dm_thin_pool</span><span id="94fa" class="od la it ny b gy oi of l og oh">$ echo dm_thin_pool | tee -a /etc/modules</span><span id="36e5" class="od la it ny b gy oi of l og oh">dm_thin_pool # verify output</span></pre><p id="de6b" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">现在，我们可以开始安装客户端了。但是在您继续之前，我必须警告您，强烈建议Gluster客户端版本尽可能接近服务器版本<em class="no">。在这篇文章发表的时候，最新的基于容器的版本是7.1。因此，我将继续设置一个完全相同版本的客户端。</em></p><p id="80a5" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">首先，给<code class="fe nv nw nx ny b">apt</code>添加GPG键:</p><pre class="kj kk kl km gt nz ny oa ob aw oc bi"><span id="030b" class="od la it ny b gy oe of l og oh">$ wget -O - <a class="ae ky" href="https://download.gluster.org/pub/gluster/glusterfs/" rel="noopener ugc nofollow" target="_blank"><em class="no">https://download.gluster.org/pub/gluster/glusterfs</em></a><em class="no">/7/rsa.pub</em> | apt-key add - # install certificate</span></pre><p id="3707" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">然后根据需要添加<a class="ae ky" href="https://download.gluster.org/pub/gluster/glusterfs/7/LATEST/Debian/" rel="noopener ugc nofollow" target="_blank">信号源</a>:</p><pre class="kj kk kl km gt nz ny oa ob aw oc bi"><span id="39a6" class="od la it ny b gy oe of l og oh">$ echo deb [arch=amd64] <a class="ae ky" href="https://download.gluster.org/pub/gluster/glusterfs/" rel="noopener ugc nofollow" target="_blank">https://download.gluster.org/pub/gluster/glusterfs</a>/7/7.1/Debian/buster/amd64/apt buster main &gt; /etc/apt/sources.list.d/gluster.list</span></pre><p id="6d6f" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">更新软件包列表并安装<code class="fe nv nw nx ny b">glusterfs-client</code>:</p><pre class="kj kk kl km gt nz ny oa ob aw oc bi"><span id="0aba" class="od la it ny b gy oe of l og oh">$ apt-get update</span><span id="f81d" class="od la it ny b gy oi of l og oh">$ apt-get install glusterfs-client</span><span id="8085" class="od la it ny b gy oi of l og oh">$ /usr/sbin/glusterfs --version</span><span id="a27d" class="od la it ny b gy oi of l og oh">glusterfs 7.1</span></pre><p id="5bbc" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">最后一个命令输出将验证结果。</p><p id="a040" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated"><em class="no">就这样！</em>你现在可以关闭这个笨拙的控制台，最终回到你那令人敬畏的终端。当然，这是指一个存储节点是否足以满足您所需的基础架构，但这是值得怀疑的。否则，您应该对每个其他节点重复同样的操作，直到您满意或厌倦为止。我做了三次后两者都得到了。</p></div><div class="ab cl ms mt hx mu" role="separator"><span class="mv bw bk mw mx my"/><span class="mv bw bk mw mx my"/><span class="mv bw bk mw mx"/></div><div class="im in io ip iq"><h1 id="dd3a" class="kz la it bd lb lc na le lf lg nb li lj jz nc ka ll kc nd kd ln kf ne kg lp lq bi translated">部署Gluster服务器和Heketi API</h1><p id="bb00" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">至此，最难的部分结束了。剩下的工作就是配置和部署最后两个组件——g luster服务器和Heketi API。显然，在前面的步骤中完成了所有的工作之后，你应该得到某种简单、直接的方式来完成工作。还有什么比使用预配置的<a class="ae ky" href="https://helm.sh/" rel="noopener ugc nofollow" target="_blank">舵图</a>更简单的呢？</p><p id="2deb" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">这甚至有一些选项:</p><ul class=""><li id="1d14" class="nf ng it lt b lu mn lx mo ma nh me ni mi nj mm nk nl nm nn bi translated"><a class="ae ky" href="https://artifacthub.io/packages/helm/ibm-charts/ibm-glusterfs" rel="noopener ugc nofollow" target="_blank"> IBM官方图表</a>直接来自<a class="ae ky" href="https://helm.sh/blog/helm-hub-moving-to-artifact-hub/" rel="noopener ugc nofollow" target="_blank"> ArtifactHub </a></li><li id="2651" class="nf ng it lt b lu np lx nq ma nr me ns mi nt mm nk nl nm nn bi translated"><a class="ae ky" href="https://github.com/AcalephStorage/charts/tree/glusterfs/incubator/glusterfs" rel="noopener ugc nofollow" target="_blank">曾经存在的<a class="ae ky" href="https://github.com/helm/charts" rel="noopener ugc nofollow" target="_blank"> Helm孵化器</a>图的AcalephStorage完成叉</a></li></ul><p id="d189" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">虽然这看起来是一个显而易见的选择，但是值得注意的是，第二个解决方案实际上对于理解和部署都要简单得多。所以我再次强烈建议你自己做研究。或者，你也可以看看我自己的组合解决方案，这是我做的开源项目的一部分。</p><p id="fbcc" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">所有这些解决方案的共同点是，它们都使用Heketi作为管理API，因此它们都需要使用预定义的存储节点<a class="ae ky" href="https://docs.openshift.com/container-platform/3.5/install_config/storage_examples/containerized_heketi_with_dedicated_gluster.html" rel="noopener ugc nofollow" target="_blank">拓扑配置</a>进行处理。虽然这听起来有点难以置信，但这个过程实际上就是执行一个命令并记下几个IP地址。它看起来是这样的:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oj ok l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">Heketi API的存储集群拓扑示例配置</p></figure><p id="24d4" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">基本上，您需要的只是每个节点的内部IP、名称和您在上一步中创建的存储设备名称。如果您严格按照说明操作，那么设备名称将是<code class="fe nv nw nx ny b">/dev/disk/gluster-disk</code>。</p><p id="0de8" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">要得到拼图的剩余部分，只需键入以下命令:</p><pre class="kj kk kl km gt nz ny oa ob aw oc bi"><span id="5cb5" class="od la it ny b gy oe of l og oh">$ kubectl get nodes -o wide</span><span id="7f7a" class="od la it ny b gy oi of l og oh">NAME                  STATUS   AGE   VERSION   INTERNAL-IP kicksware-k8s-3pkt4   Ready    38h   v1.18.8   10.114.0.5    kicksware-k8s-3pkt8   Ready    38h   v1.18.8   10.114.0.3    kicksware-k8s-3pktw   Ready    38h   v1.18.8   10.114.0.4</span></pre><p id="42dd" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">节点的名称是<code class="fe nv nw nx ny b">node.hostname.manage</code>，内部IP对应于<code class="fe nv nw nx ny b">node.hostname.storage</code>。只需将它放入<code class="fe nv nw nx ny b">values.yaml</code>文件，并在执行您选择的舵表部署时使用它。</p><p id="c937" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">此外，根据所选择的方法(除IBM之外的所有方法)，您可能需要将Heketi服务的cluster-IP手动输入到存储类配置和升级图表中:</p><pre class="kj kk kl km gt nz ny oa ob aw oc bi"><span id="6629" class="od la it ny b gy oe of l og oh">$ kubectl get services -lrelease=<em class="no">&lt;RELEASE_NAME&gt;</em></span><span id="1865" class="od la it ny b gy oi of l og oh">NAME             TYPE        CLUSTER-IP       PORT(S)    AGE<br/>gluster-heketi   ClusterIP   10.245.189.193   8080/TCP   1m</span></pre><p id="7b81" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">一旦有了存储类，只要在需要存储配置时将它放入每个<code class="fe nv nw nx ny b">PersistentVolumeClaim</code>，就像这样:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oj ok l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">GlusterFS PersistentVolumeClaim示例配置</p></figure><p id="dced" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">我不是告诉过你，到最后，那会是小菜一碟！现在终于到了。干得好！</p><p id="a76e" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">还有一件事，如果你运行<a class="ae ky" href="https://kubernetes.io/docs/reference/access-authn-authz/rbac/" rel="noopener ugc nofollow" target="_blank"> RBAC的</a> Kubernetes，请确保为Heketi应用程序提供一个正确的<a class="ae ky" href="https://kubernetes.io/docs/reference/access-authn-authz/rbac/#rolebinding-and-clusterrolebinding" rel="noopener ugc nofollow" target="_blank">角色绑定</a>。否则，它将无法加载拓扑，您将会得到这个奇怪的错误消息:</p><pre class="kj kk kl km gt nz ny oa ob aw oc bi"><span id="b1fc" class="od la it ny b gy oe of l og oh">Unable to create node: New Node doesn't have glusterd running</span></pre><p id="543e" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">虽然这可能是由某种Gluster客户端安装问题引起的，但很可能Heketi没有足够的权限访问节点和pods K8s本机API。</p></div><div class="ab cl ms mt hx mu" role="separator"><span class="mv bw bk mw mx my"/><span class="mv bw bk mw mx my"/><span class="mv bw bk mw mx"/></div><div class="im in io ip iq"><h1 id="83b4" class="kz la it bd lb lc na le lf lg nb li lj jz nc ka ll kc nd kd ln kf ne kg lp lq bi translated">最后的想法</h1><p id="b29f" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">由于其高度动态、几乎短暂的性质，Kubernetes存储管理范例有时会令人困惑甚至不知所措。默认情况下，大多数部署的服务都是无状态的。然而，现实世界的生产场景通常要求它们是<a class="ae ky" href="https://www.xenonstack.com/insights/stateful-and-stateless-applications/#:~:text=Stateful%20application%20remembers,the%20checkout%20page" rel="noopener ugc nofollow" target="_blank">有状态的</a>，即拥有某种外部存储。对此，Kubernetes本身提供了一些解决方案:<a class="ae ky" href="https://kubernetes.io/docs/concepts/storage/ephemeral-volumes/#types-of-ephemeral-volumes" rel="noopener ugc nofollow" target="_blank">临时选项</a>、<a class="ae ky" href="https://kubernetesbyexample.com/pv/#:~:text=A%20persistent%20volume%20(PV)%20is,a%20distributed%20filesystem%20like%20Ceph." rel="noopener ugc nofollow" target="_blank">持久卷</a>、持久卷声明、<a class="ae ky" href="https://kubernetes.io/docs/concepts/storage/storage-classes/#:~:text=A%20StorageClass%20provides,other%20storage%20systems" rel="noopener ugc nofollow" target="_blank">存储类</a>或<a class="ae ky" href="https://kubernetes.io/docs/concepts/workloads/controllers/statefulset/" rel="noopener ugc nofollow" target="_blank">状态集</a>。</p><p id="a09e" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">此外，存储资源调配因静态和动态方式而异。静态模式要求管理员提前考虑和配置PV，这与Kubernetes将资源(CPU、内存和存储)视为动态授权的思维方式有些冲突。因此，一种被认为更合适、更优雅的动态方式是将存储管理职责委托给K8s引擎，这是通过<code class="fe nv nw nx ny b">StorageClass</code> es完成的。</p><p id="bd6a" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated"><code class="fe nv nw nx ny b">StorageClass</code>将管理分布式存储的复杂流程抽象化，使之变得像在YAML配置上写几行字一样简单。然而，<code class="fe nv nw nx ny b">StorageClass</code>范式最初必须使用一些外部服务来实现。虽然其中一些也很容易上手，但有些选项需要先完成复杂的部署过程。</p><p id="b191" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">本文致力于揭示GlusterFS部署的细节和缺陷，提供了一套完整的说明，说明如何在Kubernetes托管环境上使用预期的规范进行部署。</p><p id="cff2" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">作为作者，真的希望对你有用。因为在我探索这个伟大的工具的时候，没有这样的资源，我不得不花费大量的时间来解决一些当地的问题。</p><p id="4f0d" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">不过，作为一名开发人员，我为我们的社区以任何人都可以遵循的方式提供如此多的帮助和支持而感到非常自豪。所以，这是我为这一运动所做的努力。</p></div><div class="ab cl ms mt hx mu" role="separator"><span class="mv bw bk mw mx my"/><span class="mv bw bk mw mx my"/><span class="mv bw bk mw mx"/></div><div class="im in io ip iq"><p id="32ee" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">感谢你的关注。快乐的离婚！</p></div></div>    
</body>
</html>