<html>
<head>
<title>9 Practical GitHub Tips To Help Streamline Development</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">帮助简化开发的9个实用GitHub技巧</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/8-practical-github-tips-to-help-streamline-development-bf394079d554?source=collection_archive---------11-----------------------#2022-01-24">https://betterprogramming.pub/8-practical-github-tips-to-help-streamline-development-bf394079d554?source=collection_archive---------11-----------------------#2022-01-24</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="0498" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">依赖性升级、漏洞警报等</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/95dcc48715dbf1120286f6c5cd4c0e47.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*KE_pybGhq3RYTnzHsnqZpQ.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">作者的图像背景</p></figure><p id="7667" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated"><strong class="la iu">作为一名工程师，自动化是我们的昵称。</strong> GitHub是我们日常使用的工具之一。让我们探索一下GitHub提供的一些特性，这些特性有助于简化我们的日常开发。</p><pre class="kj kk kl km gt lu lv lw lx aw ly bi"><span id="6067" class="lz ma it lv b gy mb mc l md me"><a class="ae mf" href="#2aca" rel="noopener ugc nofollow">#1 Dependabot</a><br/><a class="ae mf" href="#79a7" rel="noopener ugc nofollow">#2 GitHub Actions</a><br/><a class="ae mf" href="#f265" rel="noopener ugc nofollow">#3 Enable Alerts for Vulnerabilities</a><br/><a class="ae mf" href="#3ee8" rel="noopener ugc nofollow">#4 Auto Merge</a><br/><a class="ae mf" href="#ac69" rel="noopener ugc nofollow">#5 Auto Assign</a><br/><a class="ae mf" href="#aa61" rel="noopener ugc nofollow">#6 Auto Release</a><br/><a class="ae mf" href="#e11e" rel="noopener ugc nofollow">#7 Release Notes Automation</a><br/>#8 Enable Branch Protection<br/>#9 Automating JIRA Ticket Number in Git Commit Messages</span></pre><h1 id="2aca" class="mg ma it bd mh mi mj mk ml mm mn mo mp jz mq ka mr kc ms kd mt kf mu kg mv mw bi translated">排名第一的依赖机器人</h1><p id="d308" class="pw-post-body-paragraph ky kz it la b lb mx ju ld le my jx lg lh mz lj lk ll na ln lo lp nb lr ls lt im bi translated">去年12月震惊网络的Log4j漏洞问题<a class="ae mf" href="https://nvd.nist.gov/vuln/detail/CVE-2021-44228" rel="noopener ugc nofollow" target="_blank">CVE-2021–44228</a>给我们所有人上了一课，让我们的依赖库保持最新是多么重要。</p><p id="fedf" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">Dependabot是技术栈的<strong class="la iu">依赖性监控</strong>类别中的一个工具。它可以与GitHub无缝协作。它会检查我们的依赖文件中是否有过时的需求，并为找到的需求打开单独的PRs。我们只是审查、合并并着手开发最新、最安全的版本。</p><p id="32e1" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">要启用dependent bot，请在我们的项目存储库标题下导航，单击Insights→Dependency graph→dependent bot→创建配置文件。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nc"><img src="../Images/8dc6ae4d01bf770aa5900cb2df75e4d1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*AUhCFuPjf97NQz3qZyvxgw.png"/></div></div></figure><p id="3930" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">“创建配置文件”窗口打开，在这里我们指定几个参数:</p><ul class=""><li id="92c8" class="nd ne it la b lb lc le lf lh nf ll ng lp nh lt ni nj nk nl bi translated"><strong class="la iu">包-生态系统:“maven”</strong>，如果Maven是你的构建工具</li><li id="d586" class="nd ne it la b lb nm le nn lh no ll np lp nq lt ni nj nk nl bi translated"><strong class="la iu">目录:“/”</strong>，指定根目录</li><li id="d805" class="nd ne it la b lb nm le nn lh no ll np lp nq lt ni nj nk nl bi translated"><strong class="la iu">interval:“daily”</strong>，告诉Dependabot多久检查一次更新，在本例中是每天。其他值可以是“每周”(在星期一)或“每月”(每个月的第一天)。</li><li id="6f9d" class="nd ne it la b lb nm le nn lh no ll np lp nq lt ni nj nk nl bi translated"><strong class="la iu">打开-拉动-请求-限制:10 </strong>，指定请购单限制。对于更新，默认值为5。</li></ul><p id="abf8" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">有关其他配置选项和值的示例，请参考GitHub的<a class="ae mf" href="https://docs.github.com/en/code-security/supply-chain-security/keeping-your-dependencies-updated-automatically/configuration-options-for-dependency-updates" rel="noopener ugc nofollow" target="_blank">依赖性更新配置选项</a>页面。</p><p id="0f9a" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">让我们提交这个配置文件。现在我们在项目根目录下有了一个名为<code class="fe nr ns nt lv b">.github</code>的附加文件夹，其中有<code class="fe nr ns nt lv b">dependabot.yml</code>。这是一次性的，一旦这个<code class="fe nr ns nt lv b">yml</code>文件存在，就不需要重复这个步骤。</p><p id="cabc" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">就在我们提交<code class="fe nr ns nt lv b">dependabot.yml</code>之后，依赖机器人正在努力工作！给它几分钟时间，如果您第一次在您的项目上运行Dependabot，您将惊讶地看到提交了多少包含依赖关系升级的pull请求(PRs )!</p><p id="3f17" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">每个依赖关系升级一个PR。如果您已经有一个CI管道，您的管道将准确地告诉您哪些pr可以安全合并，这将引入突破性的更改。如果您没有CI渠道，请继续阅读。</p></div><div class="ab cl nu nv hx nw" role="separator"><span class="nx bw bk ny nz oa"/><span class="nx bw bk ny nz oa"/><span class="nx bw bk ny nz"/></div><div class="im in io ip iq"><h1 id="79a7" class="mg ma it bd mh mi ob mk ml mm oc mo mp jz od ka mr kc oe kd mt kf of kg mv mw bi translated">#2 GitHub操作</h1><p id="a201" class="pw-post-body-paragraph ky kz it la b lb mx ju ld le my jx lg lh mz lj lk ll na ln lo lp nb lr ls lt im bi translated">GitHub Actions是一个CI/CD平台，允许我们自动化我们的构建、测试和部署管道。GitHub Actions online上有大量的文章/指南来探索它丰富的特性。对于这个故事，我们将只关注如何利用它的CI来帮助Dependabot依赖关系的升级。</p><p id="3045" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">为CI创建工作流非常简单。点击Actions →按关键字搜索，例如您的构建工具“Maven”→点击“Java with Maven”工作流模板中的“Configure”。GitHub Actions提供了许多模板，我们可以根据您的项目所使用的编程语言和构建工具进行选择。</p><p id="3381" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">点击“Configure ”,编辑器将打开一个文件，如位于<code class="fe nr ns nt lv b">.github/workflows</code>目录下的<code class="fe nr ns nt lv b">maven.yml</code>,默认为模板内容。让我们根据我们的需要来定制它，在下面的示例中，我正在指导CI对<code class="fe nr ns nt lv b">main</code>的任何推送以及对<code class="fe nr ns nt lv b">main</code>的任何PR。我们有一个<code class="fe nr ns nt lv b">build</code>工作，在我们的项目上设置Java 17和运行<code class="fe nr ns nt lv b">mvn clean install</code>的步骤。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="og oh l"/></div></figure><p id="d75d" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">简单的CI就是这样！现在提交文件，并单击“Actions”选项卡，查看我们的新CI管道是如何工作的。今后，所有的Dependabot PRs将自动通过我们的CI管道，这样我们就可以准确地知道哪个升级可以安全地合并到main(如果它的版本是绿色的)，哪个升级会进行重大更改(如果它的版本是红色的)。</p><h2 id="7822" class="lz ma it bd mh oi oj dn ml ok ol dp mp lh om on mr ll oo op mt lp oq or mv os bi translated"><strong class="ak">如何排除包含重大变更的升级</strong></h2><p id="b7d0" class="pw-post-body-paragraph ky kz it la b lb mx ju ld le my jx lg lh mz lj lk ll na ln lo lp nb lr ls lt im bi translated">对于失败的依赖机器人PRs，我们知道升级后的库引入了突破性的变化。我们可以采取两项行动:</p><ul class=""><li id="161b" class="nd ne it la b lb lc le lf lh nf ll ng lp nh lt ni nj nk nl bi translated"><strong class="la iu">修复我们的代码或创建技术债务JIRA票证</strong></li></ul><p id="ccbb" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">如果修复很简单，就修复代码。如果解决问题很复杂，那就创建一张科技债JIRA券，以后再解决。在大多数情况下，升级后的库必须删除我们代码中正在使用的某些类，我们需要找到解决方案并更新我们的代码，然后才能升级到库的新版本。</p><ul class=""><li id="8144" class="nd ne it la b lb lc le lf lh nf ll ng lp nh lt ni nj nk nl bi translated"><strong class="la iu">告诉dependent bot不要一直烦我们升级这样的库</strong></li></ul><p id="efb0" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">我们可以通过在Dependabot打开的pull请求上留下评论来与它进行交互。像<code class="fe nr ns nt lv b">@dependabot ignore this dependency</code>这样的注释将关闭这个PR，并阻止Dependabot为这个依赖关系创建更多的PR。一旦代码被修复，我们就可以重新打开相同的PR或者手动升级库。</p></div><div class="ab cl nu nv hx nw" role="separator"><span class="nx bw bk ny nz oa"/><span class="nx bw bk ny nz oa"/><span class="nx bw bk ny nz"/></div><div class="im in io ip iq"><h1 id="f265" class="mg ma it bd mh mi ob mk ml mm oc mo mp jz od ka mr kc oe kd mt kf of kg mv mw bi translated">#3启用漏洞警报</h1><p id="4c16" class="pw-post-body-paragraph ky kz it la b lb mx ju ld le my jx lg lh mz lj lk ll na ln lo lp nb lr ls lt im bi translated">dependent bot执行扫描以检测易受攻击的依赖项，并在以下情况下发送dependent bot警报:</p><ul class=""><li id="f432" class="nd ne it la b lb lc le lf lh nf ll ng lp nh lt ni nj nk nl bi translated">GitHub咨询数据库中增加了一个新漏洞。</li><li id="0b98" class="nd ne it la b lb nm le nn lh no ll np lp nq lt ni nj nk nl bi translated">存储库的依赖关系图发生了变化。例如，当贡献者提交一个commit来改变它所依赖的包或版本时，或者当一个依赖项的代码改变时。</li></ul><p id="a86a" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">GitHub检测<em class="ot">公共</em>仓库中易受攻击的依赖项，并默认生成依赖机器人警报。对于私有存储库，具有管理员访问权限的用户可以通过为其存储库启用依赖关系图和依赖机器人警报来启用依赖机器人警报。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ou"><img src="../Images/234a770cefae30a90ab802b8ff651c20.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*VLVHtq7B89FMdne1JBAR_Q.png"/></div></div></figure><p id="95da" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">启用警报后，如果检测到新的漏洞，您将在存储库的主页上看到一个黄色的大横幅。此外，根据通知设置，还会发送一封电子邮件通知您该漏洞。</p></div><div class="ab cl nu nv hx nw" role="separator"><span class="nx bw bk ny nz oa"/><span class="nx bw bk ny nz oa"/><span class="nx bw bk ny nz"/></div><div class="im in io ip iq"><h1 id="3ee8" class="mg ma it bd mh mi ob mk ml mm oc mo mp jz od ka mr kc oe kd mt kf of kg mv mw bi translated">#4自动合并</h1><p id="c0fa" class="pw-post-body-paragraph ky kz it la b lb mx ju ld le my jx lg lh mz lj lk ll na ln lo lp nb lr ls lt im bi translated">您可以通过为一个拉请求启用自动合并来提高开发速度，这样当所有的合并需求都被满足时，拉请求就会自动合并。由Dependabot提交的已通过CI管道的pr是自动合并的完美候选。</p><p id="220c" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">首先，您需要为存储库启用自动合并。在存储库名称下，单击设置→在“合并按钮”下，选择“允许自动合并”。</p><p id="a5e9" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">然后深入到PR，选择合并方法，选择“启用自动合并”下拉菜单，然后单击合并方法，如“通过自动合并合并”。单击“启用自动合并”，然后单击“确认自动合并”。</p><p id="a697" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">一旦您为提取请求启用自动合并，当满足所有必需的审核且状态检查已通过时，提取请求将自动合并。</p><p id="850d" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">详细的逐屏说明可以在GitHub的<a class="ae mf" href="https://docs.github.com/en/pull-requests/collaborating-with-pull-requests/incorporating-changes-from-a-pull-request/automatically-merging-a-pull-request" rel="noopener ugc nofollow" target="_blank">自动合并拉取请求</a>页面上找到。</p></div><div class="ab cl nu nv hx nw" role="separator"><span class="nx bw bk ny nz oa"/><span class="nx bw bk ny nz oa"/><span class="nx bw bk ny nz"/></div><div class="im in io ip iq"><p id="a425" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">就我个人而言，我对GitHub提供的这种开箱即用的自动合并功能没有太多印象，它仍然需要导航到每个PR来启用和确认自动合并，太手动了。我强烈推荐一个动作，比如<a class="ae mf" href="https://github.com/marketplace/actions/github-action-merge-dependabot" rel="noopener ugc nofollow" target="_blank">GitHub Action Merge dependent bot</a>。用法非常简单，我们可以将一个“自动合并”作业附加到我们现有的CI工作流yml中，例如<code class="fe nr ns nt lv b">maven.yml</code>，参见下面的片段:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="og oh l"/></div></figure><p id="98a5" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">我们正在通过扩展现有工作流来创建新的工作流作业<code class="fe nr ns nt lv b">automerge </code>:</p><ul class=""><li id="1838" class="nd ne it la b lb lc le lf lh nf ll ng lp nh lt ni nj nk nl bi translated">它等待<code class="fe nr ns nt lv b">build </code>任务完成(使用<a class="ae mf" href="https://docs.github.com/en/actions/reference/workflow-syntax-for-github-actions#jobsjob_idneeds" rel="noopener ugc nofollow" target="_blank">需要</a>)。这个顺序很重要，因为它延迟了这个<code class="fe nr ns nt lv b">automerge </code>作业的执行，直到指定的作业成功完成。如果你有不止一个等待的任务，你可以把它们作为一个数组传递，就像<code class="fe nr ns nt lv b">needs: [build, test].</code></li><li id="b338" class="nd ne it la b lb nm le nn lh no ll np lp nq lt ni nj nk nl bi translated">它有一个使用<code class="fe nr ns nt lv b">fastify/github-action-merge-dependabot@v1</code>动作的步骤</li><li id="183b" class="nd ne it la b lb nm le nn lh no ll np lp nq lt ni nj nk nl bi translated">它有一个有条件的<code class="fe nr ns nt lv b">if</code>语句，只允许这个作业为Dependabot提交的PRs运行。</li><li id="f21e" class="nd ne it la b lb nm le nn lh no ll np lp nq lt ni nj nk nl bi translated"><code class="fe nr ns nt lv b">GITHUB_TOKEN</code>秘密是GitHub App安装访问令牌。您可以使用这个令牌代表安装在您的存储库上的GitHub应用程序进行身份验证。在每个作业开始之前，GitHub会为该作业获取一个安装访问令牌。该令牌在作业完成后过期。</li></ul><p id="32af" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">完整的<code class="fe nr ns nt lv b">maven.yml</code>可以在我的<a class="ae mf" href="https://github.com/wenqiglantz/customer-service/blob/main/.github/workflows/maven.yml" rel="noopener ugc nofollow" target="_blank">GitHub repo for customer-service微服务</a>中找到。请随意查看。</p></div><div class="ab cl nu nv hx nw" role="separator"><span class="nx bw bk ny nz oa"/><span class="nx bw bk ny nz oa"/><span class="nx bw bk ny nz"/></div><div class="im in io ip iq"><h1 id="ac69" class="mg ma it bd mh mi ob mk ml mm oc mo mp jz od ka mr kc oe kd mt kf of kg mv mw bi translated">#5自动分配</h1><p id="a0cc" class="pw-post-body-paragraph ky kz it la b lb mx ju ld le my jx lg lh mz lj lk ll na ln lo lp nb lr ls lt im bi translated">Auto Assign是一个Probot应用程序，它在打开拉式请求时向拉式请求添加审阅者。安装步骤:</p><ol class=""><li id="1e25" class="nd ne it la b lb lc le lf lh nf ll ng lp nh lt ov nj nk nl bi translated">转到<a class="ae mf" href="https://probot.github.io/apps/auto-assign/" rel="noopener ugc nofollow" target="_blank">自动分配应用程序页面</a></li><li id="8d38" class="nd ne it la b lb nm le nn lh no ll np lp nq lt ov nj nk nl bi translated">添加到GitHub</li><li id="4a1d" class="nd ne it la b lb nm le nn lh no ll np lp nq lt ov nj nk nl bi translated">选择存储库</li><li id="85d0" class="nd ne it la b lb nm le nn lh no ll np lp nq lt ov nj nk nl bi translated">在您的存储库中创建<code class="fe nr ns nt lv b">.github/auto_assign.yml</code></li></ol><pre class="kj kk kl km gt lu lv lw lx aw ly bi"><span id="7a49" class="lz ma it lv b gy mb mc l md me"># Set to true to add reviewers to pull requests<br/>addReviewers: true</span><span id="5147" class="lz ma it lv b gy ow mc l md me"># Set to true to add assignees to pull requests<br/>addAssignees: true</span><span id="2ba7" class="lz ma it lv b gy ow mc l md me"># A list of reviewers to be added to pull requests (GitHub user name)<br/>reviewers: <br/>  - reviewerA<br/>  - reviewerB<br/>  - reviewerC</span><span id="2645" class="lz ma it lv b gy ow mc l md me"># A list of keywords to be skipped the process that add reviewers if pull requests include it <br/>skipKeywords:<br/>  - wip</span><span id="da3d" class="lz ma it lv b gy ow mc l md me"># A number of reviewers added to the pull request<br/># Set 0 to add all the reviewers (default: 0)<br/>numberOfReviewers: 0</span></pre></div><div class="ab cl nu nv hx nw" role="separator"><span class="nx bw bk ny nz oa"/><span class="nx bw bk ny nz oa"/><span class="nx bw bk ny nz"/></div><div class="im in io ip iq"><h1 id="aa61" class="mg ma it bd mh mi ob mk ml mm oc mo mp jz od ka mr kc oe kd mt kf of kg mv mw bi translated">#6自动发布</h1><p id="9e42" class="pw-post-body-paragraph ky kz it la b lb mx ju ld le my jx lg lh mz lj lk ll na ln lo lp nb lr ls lt im bi translated">GitHub Marketplace中有相当多的自动发布动作。我们将探索<a class="ae mf" href="https://github.com/marketplace/actions/automatic-releases" rel="noopener ugc nofollow" target="_blank"> GitHub自动发布</a>。该操作通过自动上传资产、生成变更日志、处理预发布等方式简化了GitHub发布过程。典型的使用场景包括当标签被推送到存储库时，这个动作触发一个自动的GitHub发布。<strong class="la iu"> </strong>构建&amp;测试您的项目后:</p><ol class=""><li id="8cc0" class="nd ne it la b lb lc le lf lh nf ll ng lp nh lt ov nj nk nl bi translated">从这个和前一个<a class="ae mf" href="https://semver.org/" rel="noopener ugc nofollow" target="_blank">永远看起来像</a>的标签之间的所有提交生成一个changelog。</li><li id="1f09" class="nd ne it la b lb nm le nn lh no ll np lp nq lt ov nj nk nl bi translated">生成一个新的版本，并将其与该标签相关联。</li><li id="1c14" class="nd ne it la b lb nm le nn lh no ll np lp nq lt ov nj nk nl bi translated">上传<code class="fe nr ns nt lv b">LICENSE.txt</code>和任何<code class="fe nr ns nt lv b">jar</code>文件作为发布资产。</li></ol><p id="b0be" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">样本<code class="fe nr ns nt lv b">tagged-relrease.yml</code>:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="og oh l"/></div></figure></div><div class="ab cl nu nv hx nw" role="separator"><span class="nx bw bk ny nz oa"/><span class="nx bw bk ny nz oa"/><span class="nx bw bk ny nz"/></div><div class="im in io ip iq"><h1 id="e11e" class="mg ma it bd mh mi ob mk ml mm oc mo mp jz od ka mr kc oe kd mt kf of kg mv mw bi translated">#7发行说明自动化</h1><p id="5bea" class="pw-post-body-paragraph ky kz it la b lb mx ju ld le my jx lg lh mz lj lk ll na ln lo lp nb lr ls lt im bi translated">自动生成的发行说明为您的GitHub版本提供了手动编写发行说明的自动化替代方法。使用自动生成的发行说明，您可以快速生成一个版本内容的概述。您还可以自定义您的自动化发行说明，使用标签创建自定义类别来组织您想要包括的拉式请求，并从输出中排除某些标签和用户。</p><p id="3ec1" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">在GitHub的<a class="ae mf" href="https://docs.github.com/en/repositories/releasing-projects-on-github/automatically-generated-release-notes" rel="noopener ugc nofollow" target="_blank">自动生成的发布说明</a>页面可以找到关于如何自动化发布说明的详细分步指南。</p></div><div class="ab cl nu nv hx nw" role="separator"><span class="nx bw bk ny nz oa"/><span class="nx bw bk ny nz oa"/><span class="nx bw bk ny nz"/></div><div class="im in io ip iq"><h1 id="6e20" class="mg ma it bd mh mi ob mk ml mm oc mo mp jz od ka mr kc oe kd mt kf of kg mv mw bi translated">#8启用分支保护</h1><p id="7730" class="pw-post-body-paragraph ky kz it la b lb mx ju ld le my jx lg lh mz lj lk ll na ln lo lp nb lr ls lt im bi translated">您可以创建一个分支保护规则，以对一个或多个分支强制执行某些工作流，例如要求对合并到受保护分支的所有提取请求进行批准审查或通过状态检查。</p><p id="2306" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">要添加分支规则，请导航至设置→分支→添加规则。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ox"><img src="../Images/945b2b9060f37d98d539ee06bbbcacf9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*qYnpkVr0GCeB4G_FDPUujw.png"/></div></div></figure><p id="a146" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">您可以在存储库中为特定分支、所有分支或与您指定的名称模式匹配的任何分支创建分支保护规则。例如，为了保护任何包含单词<code class="fe nr ns nt lv b">release</code>的分支，您可以为<code class="fe nr ns nt lv b">*release*</code>创建一个分支规则。您可以使用通配符语法<code class="fe nr ns nt lv b">*</code>为存储库中所有当前和未来的分支创建一个规则。帮助我们自动化分支/合并的典型保护规则包括:</p><ul class=""><li id="b615" class="nd ne it la b lb lc le lf lh nf ll ng lp nh lt ni nj nk nl bi translated">合并前需要一个拉请求。</li><li id="74a9" class="nd ne it la b lb nm le nn lh no ll np lp nq lt ni nj nk nl bi translated">合并前需要通过状态检查。</li><li id="154f" class="nd ne it la b lb nm le nn lh no ll np lp nq lt ni nj nk nl bi translated">合并前指定所需的批准数量</li><li id="a35d" class="nd ne it la b lb nm le nn lh no ll np lp nq lt ni nj nk nl bi translated">推送新的提交时，取消陈旧的拉请求批准。</li><li id="5e1b" class="nd ne it la b lb nm le nn lh no ll np lp nq lt ni nj nk nl bi translated">要求分支在合并前是最新的。</li></ul><p id="96b6" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">如果存储库有多个影响相同分支的受保护分支规则，则包含特定分支名称的规则具有最高优先级。</p><p id="8a0c" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated"><em class="ot">注意:只有对存储库具有管理员权限的人才能管理分支保护规则。</em></p></div><div class="ab cl nu nv hx nw" role="separator"><span class="nx bw bk ny nz oa"/><span class="nx bw bk ny nz oa"/><span class="nx bw bk ny nz"/></div><div class="im in io ip iq"><h1 id="eea4" class="mg ma it bd mh mi ob mk ml mm oc mo mp jz od ka mr kc oe kd mt kf of kg mv mw bi translated">#9自动生成Git提交消息中的JIRA票号</h1><p id="388a" class="pw-post-body-paragraph ky kz it la b lb mx ju ld le my jx lg lh mz lj lk ll na ln lo lp nb lr ls lt im bi translated">在git提交消息中包含吉拉票证编号，可以通过查看相应的吉拉票证来轻松跟踪代码提交历史。然而，像任何手动过程一样，很难强迫开发人员将吉拉票号添加到他们的每一条git提交消息中。我们能自动化它吗？当然可以！我们来探索一下。</p><p id="36ff" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">我们假设我们的特征分支以它们相应的吉拉票号命名。比如:</p><ul class=""><li id="2ab0" class="nd ne it la b lb lc le lf lh nf ll ng lp nh lt ni nj nk nl bi translated">门票-100英镑</li><li id="f52c" class="nd ne it la b lb nm le nn lh no ll np lp nq lt ni nj nk nl bi translated">特写/门票-100</li><li id="18ce" class="nd ne it la b lb nm le nn lh no ll np lp nq lt ni nj nk nl bi translated">门票-100-固定</li></ul><p id="8833" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">我们需要确保我们的特性分支包含它们的吉拉票号，这是我们如何利用Git hook来自动化这个过程的关键。如果您的分支机构名称不包含您的吉拉机票号码，我们将要探讨的这一技术将不起作用。请注意，即使包括吉拉机票号码，我们对分支机构的命名也可能有所不同，请参见上面的分支机构名称示例。只要吉拉票号出现在分行名称中，我们就是好的！</p><h2 id="da5a" class="lz ma it bd mh oi oj dn ml ok ol dp mp lh om on mr ll oo op mt lp oq or mv os bi translated">Git挂钩</h2><p id="e1ac" class="pw-post-body-paragraph ky kz it la b lb mx ju ld le my jx lg lh mz lj lk ll na ln lo lp nb lr ls lt im bi translated">Git挂钩是每当Git存储库中发生特定事件时自动运行的脚本。它们允许您定制Git的内部行为，并在开发生命周期的关键点触发可定制的操作。</p><p id="ba75" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">钩子驻留在每个Git存储库的<code class="fe nr ns nt lv b">.git/hooks</code>目录中。当您初始化存储库时，Git会自动用示例脚本填充这个目录。如果您在<code class="fe nr ns nt lv b">.git/hooks</code>中查看您的任何Git存储库，您会发现以下文件:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi oy"><img src="../Images/704c50f43bb0b1bc5137926030d1888d.png" data-original-src="https://miro.medium.com/v2/resize:fit:696/format:webp/1*lvLrPIR6QotSXNTcvn_96w.png"/></div></figure><p id="2f47" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">注意我突出显示了<code class="fe nr ns nt lv b">prepare-commit-msg.sample</code>，是的，这就是我们要定制的文件。</p><h2 id="36e4" class="lz ma it bd mh oi oj dn ml ok ol dp mp lh om on mr ll oo op mt lp oq or mv os bi translated">自定义<code class="fe nr ns nt lv b">prepare-commit-msg</code>挂钩</h2><p id="d8d6" class="pw-post-body-paragraph ky kz it la b lb mx ju ld le my jx lg lh mz lj lk ll na ln lo lp nb lr ls lt im bi translated">按照以下步骤定制<code class="fe nr ns nt lv b">prepare-commit-msg</code>挂钩。</p><ul class=""><li id="478c" class="nd ne it la b lb lc le lf lh nf ll ng lp nh lt ni nj nk nl bi translated">打开项目根目录下的<code class="fe nr ns nt lv b">.git/hooks</code>目录。</li><li id="b995" class="nd ne it la b lb nm le nn lh no ll np lp nq lt ni nj nk nl bi translated">用你喜欢的编辑器打开<code class="fe nr ns nt lv b">prepare-commit-message.sample</code>文件。</li><li id="a853" class="nd ne it la b lb nm le nn lh no ll np lp nq lt ni nj nk nl bi translated">删除样本样板代码。</li><li id="7ca8" class="nd ne it la b lb nm le nn lh no ll np lp nq lt ni nj nk nl bi translated">如果在Windows上运行，将以下脚本复制并粘贴到该文件中(归功于<a class="ae mf" href="https://gist.github.com/johncmunson/ca02a8027a923a7f4b2f662c67d6528c" rel="noopener ugc nofollow" target="_blank"> johncmunson </a>)。如果您使用Mac，请确保将第一行替换为<code class="fe nr ns nt lv b">#!/bin/bash</code></li><li id="9ed7" class="nd ne it la b lb nm le nn lh no ll np lp nq lt ni nj nk nl bi translated">将文件重命名并另存为<code class="fe nr ns nt lv b">prepare-commit-message</code>(删除<code class="fe nr ns nt lv b">.sample</code>文件扩展名)。</li><li id="e20a" class="nd ne it la b lb nm le nn lh no ll np lp nq lt ni nj nk nl bi translated">提交测试提交消息以进行验证。</li></ul><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="og oh l"/></div></figure><p id="a0f2" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">就是这样！现在，您应该看到您的提交消息前面添加了从您的分支机构名称中提取的吉拉票号。</p><p id="4528" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated"><strong class="la iu"> <em class="ot">注意:这个解决方案一次只能用于一个存储库。如果您有多个需要处理的存储库，请确保对每个存储库重复上述步骤。</em>T15】</strong></p><p id="5926" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">上面提到的一些技巧的示例代码可以在我的<a class="ae mf" href="https://github.com/wenqiglantz/customer-service/tree/main/.github" rel="noopener ugc nofollow" target="_blank"> GitHub客户服务微服务库</a>中找到。</p></div><div class="ab cl nu nv hx nw" role="separator"><span class="nx bw bk ny nz oa"/><span class="nx bw bk ny nz oa"/><span class="nx bw bk ny nz"/></div><div class="im in io ip iq"><h1 id="1cbb" class="mg ma it bd mh mi ob mk ml mm oc mo mp jz od ka mr kc oe kd mt kf of kg mv mw bi translated">参考</h1><p id="c993" class="pw-post-body-paragraph ky kz it la b lb mx ju ld le my jx lg lh mz lj lk ll na ln lo lp nb lr ls lt im bi translated"><a class="ae mf" href="https://docs.github.com/en/code-security/supply-chain-security/keeping-your-dependencies-updated-automatically/configuration-options-for-dependency-updates" rel="noopener ugc nofollow" target="_blank">https://docs . github . com/en/code-security/supply-chain-security/keeping-your-dependencies-updated-automatically/configuration-options-for-dependency-updates</a></p><p id="0da2" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated"><a class="ae mf" href="https://docs.github.com/en/pull-requests/collaborating-with-pull-requests/incorporating-changes-from-a-pull-request/automatically-merging-a-pull-request" rel="noopener ugc nofollow" target="_blank">https://docs . github . com/en/pull-requests/collaboration-with-pull-requests/incorporated-changes-from-a-pull-request/automatically-merging-a-pull-request</a></p><p id="e78f" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated"><a class="ae mf" href="https://docs.github.com/en/code-security/supply-chain-security/managing-vulnerabilities-in-your-projects-dependencies/about-alerts-for-vulnerable-dependencies" rel="noopener ugc nofollow" target="_blank">https://docs . github . com/en/code-security/supply-chain-security/managing-vulnerability-in-your-projects-dependencies/about-alerts-for-vulnerable-dependencies</a></p><p id="6fdb" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated"><a class="ae mf" href="https://docs.github.com/en/repositories/configuring-branches-and-merges-in-your-repository/defining-the-mergeability-of-pull-requests/managing-a-branch-protection-rule" rel="noopener ugc nofollow" target="_blank">https://docs . github . com/en/repositories/configuring-branches-and-merges-in-your-repository/defining-the-merge ability-of-pull-requests/managing-a-branch-protection-rule</a></p><p id="97d8" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated"><a class="ae mf" href="https://github.com/marketplace/actions/github-action-merge-dependabot" rel="noopener ugc nofollow" target="_blank">https://github . com/market place/actions/github-action-merge-dependent bot</a></p><p id="e1c1" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated"><a class="ae mf" href="https://probot.github.io/apps/auto-assign/" rel="noopener ugc nofollow" target="_blank">https://probot.github.io/apps/auto-assign/</a></p><p id="06bf" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated"><a class="ae mf" href="https://github.com/marketplace/actions/automatic-releases" rel="noopener ugc nofollow" target="_blank">https://github.com/marketplace/actions/automatic-releases</a></p><p id="7554" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated"><a class="ae mf" href="https://docs.github.com/en/repositories/releasing-projects-on-github/automatically-generated-release-notes" rel="noopener ugc nofollow" target="_blank">https://docs . github . com/en/repositories/releasing-projects-on-github/automatically-generated-release-notes</a></p><p id="0ea0" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated"><a class="ae mf" href="https://www.atlassian.com/git/tutorials/git-hooks#:~:text=Git%20hooks%20are%20scripts%20that,in%20the%20development%20life%20cycle." rel="noopener ugc nofollow" target="_blank"> Git钩子| Atlassian Git教程</a></p><p id="3b85" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated"><a class="ae mf" href="https://gist.github.com/johncmunson/ca02a8027a923a7f4b2f662c67d6528c" rel="noopener ugc nofollow" target="_blank">准备-提交-消息. sh(github.com)</a></p></div></div>    
</body>
</html>