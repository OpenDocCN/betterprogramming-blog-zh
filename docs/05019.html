<html>
<head>
<title>Locality-Based Load Balancing in Kubernetes Using Istio</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用Istio在Kubernetes中实现基于位置的负载平衡</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/locality-based-load-balancing-in-kubernetes-using-istio-a4a9defa05d3?source=collection_archive---------6-----------------------#2020-06-01">https://betterprogramming.pub/locality-based-load-balancing-in-kubernetes-using-istio-a4a9defa05d3?source=collection_archive---------6-----------------------#2020-06-01</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="2ff9" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">使用地理位置在您的服务网格内路由请求，以提高性能并节省资金</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/e500c3c104e73b68bb1f8b0071b56743.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*-cDFcKrvzEu2E4u1"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">克日什托夫·赫普纳在<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>拍摄的照片。</p></figure><p id="a17d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><a class="ae ky" href="https://istio.io/" rel="noopener ugc nofollow" target="_blank"> Istio </a>是市场上功能最丰富、最强大的Kubernetes服务网之一。它是由Google、Lyft和IBM开发的开源工具，并且正在迅速流行起来。</p><p id="184e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">它的一个显著特点是交通管理。Istio提供了一个第7层代理，帮助您在多个因素上路由流量，如HTTP头、源IP、URL路径和主机名。</p><p id="1bd5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">拥有全球业务的组织通常运行一个大规模的全球服务网络，其中包括遍布全球的微服务。微服务需要相互交互才能为客户提供完整的功能。为了确保客户获得最佳性能，有必要将流量路由到最近的微服务，而不是以循环方式进行负载平衡，这是Kubernetes默认提供的。</p><p id="3690" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">成本是另一个因素，因为如果流量在区域和地区之间移动，大多数云提供商都会收取出口费。同一区域内的流量被视为内部流量，因此不收费。</p><p id="63c0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果使用Istio构建网格，将流量路由到同一区域内的服务将为您节省大量出口费用。</p><p id="4d8c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">Istio提供基于位置的路由，这有助于您将流量路由到离始发pod最近的pod。这可确保您的客户体验到低延迟，您也能从节省的出口费用中获益。大家双赢！</p><p id="afdf" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">本文是使用Istio 在Kubernetes中进行<a class="ae ky" href="https://medium.com/better-programming/traffic-mirroring-in-kubernetes-using-istio-dad0976b4e1" rel="noopener">流量镜像的后续文章。今天，我们来讨论一下Istio中基于位置的路由。</a></p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="a20d" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">先决条件</h1><p id="4c15" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">确保您有一个区域性或多区域性的Kubernetes集群。在这个演示中，我使用了一个区域性的Google Kubernetes引擎，在<code class="fe mz na nb nc b">us-central</code>区域中每个区域有一个节点。您还需要对Istio有所了解。查看<a class="ae ky" href="https://medium.com/better-programming/how-to-manage-microservices-on-kubernetes-with-istio-c25e97a60a59" rel="noopener">如何使用Istio </a>管理Kubernetes上的微服务，了解简要介绍。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="a9bc" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">安装Istio</h1><p id="4e88" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">按照<a class="ae ky" href="https://medium.com/better-programming/getting-started-with-istio-on-kubernetes-e582800121ea" rel="noopener">Kubernetes上的Istio入门指南</a>在您的Kubernetes集群中安装Istio。对于此演示，您不需要安装图书信息应用程序。</p><p id="83cf" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">Istio使用节点标签来了解源流量的区域。如果您在云上使用托管的Kubernetes集群，您的云提供商会负责标记节点。</p><p id="e517" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果您运行的是内部部署或自定义设置，请用区域和分区适当标记您的节点。详见<a class="ae ky" href="https://kubernetes.io/docs/reference/kubernetes-api/labels-annotations-taints/#failure-domainbetakubernetesioregion" rel="noopener ugc nofollow" target="_blank">区域知名标签</a>。</p><p id="a879" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">因为我们正在云上运行一个托管的Kubernetes服务，所以让我们从列出节点和标签开始。我们需要这个来了解哪个节点属于哪个区域。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nd ne l"/></div></figure><p id="8c05" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们看到:</p><ul class=""><li id="51b4" class="nf ng it lb b lc ld lf lg li nh lm ni lq nj lu nk nl nm nn bi translated">节点<code class="fe mz na nb nc b">gke-cluster-1-default-pool-527dc04e-kzgp</code>属于<code class="fe mz na nb nc b">us-central1-f</code>。</li><li id="9d93" class="nf ng it lb b lc no lf np li nq lm nr lq ns lu nk nl nm nn bi translated">节点<code class="fe mz na nb nc b">gke-cluster-1-default-pool-5cfcdb08–282p</code>属于<code class="fe mz na nb nc b">us-central1-a</code>。</li><li id="0232" class="nf ng it lb b lc no lf np li nq lm nr lq ns lu nk nl nm nn bi translated">节点<code class="fe mz na nb nc b">gke-cluster-1-default-pool-97820a63-mfmq</code>属于<code class="fe mz na nb nc b">us-central1-c</code>。</li></ul><p id="39ac" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">创建两个名称空间，<code class="fe mz na nb nc b">frontend</code>和<code class="fe mz na nb nc b">backend</code>:</p><pre class="kj kk kl km gt nt nc nu nv aw nw bi"><span id="0c56" class="nx md it nc b gy ny nz l oa ob">$ kubectl create ns frontend<br/>namespace/frontend created<br/>$ kubectl create ns backend<br/>namespace/backend created</span></pre><p id="2be5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">标记名称空间以启用Istio的自动边车注入:</p><pre class="kj kk kl km gt nt nc nu nv aw nw bi"><span id="7de2" class="nx md it nc b gy ny nz l oa ob">$ kubectl label namespace frontend istio-injection=enabled<br/>namespace/frontend labeled<br/>$ kubectl label namespace backend istio-injection=enabled<br/>namespace/backend labeled</span></pre></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="4ce0" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">部署后端Nginx服务</h1><p id="c3c8" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">在Kubernetes上部署<a class="ae ky" href="https://www.nginx.com/" rel="noopener ugc nofollow" target="_blank"> NGINX </a>的两个版本(<code class="fe mz na nb nc b">v1</code>和<code class="fe mz na nb nc b">v2</code>)。在<code class="fe mz na nb nc b">nginx-v1</code>上为<code class="fe mz na nb nc b">us-central1-a</code>和<code class="fe mz na nb nc b">nginx-v2</code>添加一个节点选择器。</p><p id="b9ae" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">展开<code class="fe mz na nb nc b">nginx-v1</code>:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nd ne l"/></div></figure><p id="dd5e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">展开<code class="fe mz na nb nc b">nginx-v2</code>:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nd ne l"/></div></figure><p id="8928" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">创建一个NGINX服务来公开pod:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nd ne l"/></div></figure><p id="3f78" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">列出窗格以检查它们是否在正确的区域中运行:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nd ne l"/></div></figure></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="9a8f" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">部署前端睡眠微服务</h1><p id="9e8e" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">在每个节点上创建一个带有副本的<code class="fe mz na nb nc b">sleep</code>部署。我们用它来生成到后端NGINX pods的流量:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nd ne l"/></div></figure><p id="cf80" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们还需要为睡眠舱创建一个服务。这是Istio的服务发现允许基于位置的负载平衡所必需的:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nd ne l"/></div></figure><p id="11ca" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">列出窗格，查看它们是否在所有节点上运行:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nd ne l"/></div></figure><p id="2378" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">他们就是！让我们导出一些变量:</p><pre class="kj kk kl km gt nt nc nu nv aw nw bi"><span id="eddf" class="nx md it nc b gy ny nz l oa ob">$ export SLEEP_ZONE_1=sleep-bb596f69d-85s6d<br/>$ export SLEEP_ZONE_2=sleep-bb596f69d-c7gxr</span></pre><p id="5570" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在让我们在<code class="fe mz na nb nc b">us-central1-a</code>上执行一个<code class="fe mz na nb nc b">sleep</code> pod，并调用NGINX服务:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nd ne l"/></div></figure><p id="f83d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">它们现在完全以循环方式进行负载平衡。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="bb7f" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">基于位置优先级的负载平衡</h1><p id="0443" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">基于位置的负载平衡的默认行为称为位置优先负载平衡。</p><p id="f5ec" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">基于位置优先级的负载平衡使用以下算法:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi oc"><img src="../Images/632212c692925ae8e5337fab23ef924f.png" data-original-src="https://miro.medium.com/v2/resize:fit:562/format:webp/1*KIBHRTHyNmIqkAzclpRtIw.png"/></div></figure><p id="cd24" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">为了实现基于位置的负载平衡，我们需要一个虚拟服务和一个带有异常策略的目标规则。异常策略检查pod是否正常，并做出路由决策:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nd ne l"/></div></figure><p id="f0fe" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">运行从<code class="fe mz na nb nc b">us-central1-a</code>上的<code class="fe mz na nb nc b">sleep</code>盒到NGINX服务的测试:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nd ne l"/></div></figure><p id="171c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">正如我们所看到的，所有的请求都将发往<code class="fe mz na nb nc b">nginx-v1</code>。</p><p id="e45a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">从<code class="fe mz na nb nc b">us-central1-f</code>上的<code class="fe mz na nb nc b">sleep</code>盒对NGINX服务进行测试:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nd ne l"/></div></figure><p id="120f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们看到所有的请求都发送到<code class="fe mz na nb nc b">nginx-v2</code>。这表明基于位置优先级的负载平衡工作正常！</p><p id="b0e5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们尝试一些不同的东西。打开一个重复的终端并运行以下命令:</p><pre class="kj kk kl km gt nt nc nu nv aw nw bi"><span id="9188" class="nx md it nc b gy ny nz l oa ob">$ for i in {1..100}; do   kubectl exec -it $SLEEP_ZONE_2 -c sleep -n frontend -- sh -c 'curl  <a class="ae ky" href="http://nginx.backend:8000'" rel="noopener ugc nofollow" target="_blank">http://nginx.backend:8000'</a>; done</span></pre><p id="d654" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">当上面的命令运行时，删除另一个终端中的<code class="fe mz na nb nc b">nginx-v2</code>部署:</p><pre class="kj kk kl km gt nt nc nu nv aw nw bi"><span id="ea03" class="nx md it nc b gy ny nz l oa ob">$ kubectl delete deployment nginx-v2 -n backend<br/>deployment.apps "nginx-v2" deleted</span></pre><p id="ab9d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">切换回第一个终端，在我们删除了<code class="fe mz na nb nc b">nginx-v2</code>部署后，您应该会看到流向<code class="fe mz na nb nc b">nginx-v1</code>的流量:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nd ne l"/></div></figure></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="3111" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">局部加权负载平衡</h1><p id="7391" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">大多数用例都能很好地处理基于位置的负载平衡。但是，在某些情况下，您可能希望将流量分成多个区域。如果所有请求都来自单个区域，您可能不想让一个区域过载。一个典型的用例可以是位于特定城市的重要用户群。对于这样的用例，您可以使用本地加权负载平衡。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi oc"><img src="../Images/30a521836d940066a2034a25fb43a05d.png" data-original-src="https://miro.medium.com/v2/resize:fit:562/format:webp/1*e2mrQcSo_zym379j8PBO0g.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">局部加权负载平衡</p></figure><p id="25ed" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">通过应用相关的YAML，重新创建我们在上一节中删除的<code class="fe mz na nb nc b">nginx-v2</code>部署。</p><p id="2c3d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">然后将下面的YAML应用于:</p><ul class=""><li id="5d6f" class="nf ng it lb b lc ld lf lg li nh lm ni lq nj lu nk nl nm nn bi translated">将80%的流量从<code class="fe mz na nb nc b">us-central1-a</code>路由到<code class="fe mz na nb nc b">us-central1-a</code>，将20%的流量路由到<code class="fe mz na nb nc b">us-central1-f</code>。</li><li id="e5c2" class="nf ng it lb b lc no lf np li nq lm nr lq ns lu nk nl nm nn bi translated">将20%的流量从<code class="fe mz na nb nc b">us-central1-f</code>发送到<code class="fe mz na nb nc b">us-central1-a</code>，将80%的流量发送到<code class="fe mz na nb nc b">us-central1-f</code>。</li></ul><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nd ne l"/></div></figure><p id="0d04" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">运行从<code class="fe mz na nb nc b">us-central1-a</code>上的<code class="fe mz na nb nc b">sleep</code>盒到NGINX服务的测试:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nd ne l"/></div></figure><p id="ff74" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们看到20%的流量流向<code class="fe mz na nb nc b">nginx-v2</code>，80%流向<code class="fe mz na nb nc b">nginx-v1</code>。</p><p id="f742" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在让我们反过来。运行从<code class="fe mz na nb nc b">us-central1-f</code>上的<code class="fe mz na nb nc b">sleep</code>盒到NGINX服务的测试:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nd ne l"/></div></figure><p id="ec14" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">十次中有两次，我们得到来自<code class="fe mz na nb nc b">nginx-v1</code>的响应。</p><p id="474f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果我们在运行测试时删除了<code class="fe mz na nb nc b">nginx-v2</code>部署，会发生什么？让我们找出答案。</p><p id="e172" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">打开一个重复的终端窗口，并运行以下命令:</p><pre class="kj kk kl km gt nt nc nu nv aw nw bi"><span id="7e07" class="nx md it nc b gy ny nz l oa ob">$ for i in {1..100}; do   kubectl exec -it $SLEEP_ZONE_2 -c sleep -n frontend -- sh -c 'curl  <a class="ae ky" href="http://nginx.backend:8000'" rel="noopener ugc nofollow" target="_blank">http://nginx.backend:8000'</a>; done</span></pre><p id="4136" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">当上面的命令运行时，在另一个窗口中删除<code class="fe mz na nb nc b">nginx-v2</code>部署:</p><pre class="kj kk kl km gt nt nc nu nv aw nw bi"><span id="0d27" class="nx md it nc b gy ny nz l oa ob">$ kubectl delete deployment nginx-v2 -n backend<br/>deployment.apps "nginx-v2" deleted</span></pre><p id="bc4e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">切换回终端，您会看到在我们删除了<code class="fe mz na nb nc b">nginx-v2</code>部署后，所有流量现在都流向了<code class="fe mz na nb nc b">nginx-v1</code>:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nd ne l"/></div></figure></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="fa4f" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">结论</h1><p id="9445" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">感谢阅读！我希望你喜欢这篇文章。</p><p id="6545" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果运行多区域Kubernetes集群，Istio还提供了故障转移设置。但是，这不在本文的讨论范围之内。</p><p id="23c8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">Istio彻底改变了我们看待微服务的方式，它为您提供了组织对传统基础架构的强大控制。</p><p id="5c87" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">接下来的故事是“<a class="ae ky" href="https://medium.com/better-programming/how-to-use-istio-to-inject-faults-to-troubleshoot-microservices-in-kubernetes-108250a85abc" rel="noopener">如何在Kubernetes </a>中使用Istio注入故障排查微服务”，所以到时见！</p></div></div>    
</body>
</html>