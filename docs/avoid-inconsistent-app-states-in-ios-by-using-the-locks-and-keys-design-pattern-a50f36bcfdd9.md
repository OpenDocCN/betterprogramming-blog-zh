# 使用“锁和钥匙”设计模式避免 iOS 中不一致的应用程序状态

> 原文：<https://betterprogramming.pub/avoid-inconsistent-app-states-in-ios-by-using-the-locks-and-keys-design-pattern-a50f36bcfdd9>

## 锁和钥匙设计模式的实际实现

![](img/1e3b7a7ab467058da0151f4f3fb9c904.png)

[马库斯·温克勒](https://unsplash.com/@markuswinkler?utm_source=medium&utm_medium=referral)在 [Unsplash](https://unsplash.com?utm_source=medium&utm_medium=referral) 上拍摄的照片。

当 iOS 应用开始增长时，我们需要处理某种全局状态。全局状态通常包含两种信息:

*   用户数据:用户名、体重、身高或任何其他与用户相关的信息，供应用程序使用。
*   元数据:应用程序用来执行一些计算和独立于用户数据做出决策的信息。

用户是否登录是元数据。该应用程序可以使用这些信息来显示个人资料页面(当用户登录时)或登录页面(如果用户需要登录)。

这类信息的另一个例子是入职。在入职流程中，我们可以在不同的屏幕上向用户询问不同的信息。只有当用户填写了所有必需的数据后，入职培训才算完成。

如果用户正在执行 onboarding，而应用程序在中途崩溃了，会发生什么？为了不丢失已经插入的信息，我们如何恢复用户的状态呢？

我们可以通过适当的状态建模和正确设计模式的应用来解决这些问题。让我们看看如何解决这个问题。

# 问题是

我们已经在高抽象层次上描述了这个问题，但是它在实践中意味着什么呢？

让我们考虑一个例子:用户是否登录。处理这个问题的第一步是对状态建模。我们可以从以下模型开始:

这是最简单的方法:我们有一个`UserState`结构来定义用户对于我们的应用程序是什么，我们有一个`Bool`变量来告诉我们用户是否登录。

如果`isLoggedIn`属性是`true`，但是`UserState`变量是`nil`会怎么样？状态是不一致的，原因是我们有两个变量告诉我们有一个登录的用户意味着什么。

另一种模型可以将`isLoggedIn`布尔转换成计算变量:

我们再也没有多余的信息了。如果`userState`不是`nil`，我们就登录了，并且我们知道有一些(希望)对用户有效的数据。如果`userState`为`nil`，则表示用户没有登录。

但是现在，用户第一次登录时会发生什么呢？在这个模型中，我们会有一个`UserState`也就是`nil`，因为我们没有关于用户的任何信息，而且应用程序仍然可以显示登录页面，因为我们无法创建一个有效的`UserState`值。

# 理论上的解决方案:锁和钥匙

解决这类问题的正确方法是为我们的问题使用一个合适的模型。该模型应该表示一组状态，只有在某些特定信息可用时才能访问这些状态。

有条件访问的一组状态是*锁*。只有当你拥有正确的*钥匙*时，你才能进入这些状态:正确的信息可以打开锁。

# 履行

正如工程中经常发生的那样，同一个解决方案可以用不同的方式实现。在我们的例子中，我想谈谈两种可能的选择。

## **工厂进场**

在写这篇文章之前，我在网上搜索了一些可能会被我忽略的方法。我只找到一篇关于这个话题的文章，作者是约翰·桑德尔。

他描述了一个基于[抽象工厂](https://en.wikipedia.org/wiki/Abstract_factory_pattern)模式的解决方案。我们使用一个可以创建其他工厂的`RootFactory`对象。为了创建第二个工厂，`Root`工厂必须使用正确的数据(我们模式中的`keys`)。这些工厂实现需要关键数据的 API，并可以从关键数据开始创建其他对象(如`ViewControllers`)。

例如，`RootFactory`不能创建`UserFactory`，除非它有正确的`UserState`信息。因此，我们甚至不能创建一个`UserDetailsViewController`，同时我们缺少`userState`信息，因为我们没有可以创建 VC 的工厂。

## 枚举方法

虽然这种方法有效，并且基于可靠的设计模式，但我个人不喜欢它。

它非常冗长，需要大量的基础设施和样板文件才能正确完成，而且在创建工厂时，它混合了数据和依赖关系。

我宁愿使用一种使用`enums`和`associatedValues`对应用程序状态建模的方法。我们可以将应用程序视为一个[有限状态机(FSM)](https://en.wikipedia.org/wiki/Finite-state_machine) 。FSM 的每个状态都是 enum 的一种情况。只有当用户或应用程序中的其他进程提供了某些特定信息时，应用程序才能从一种状态转移到另一种状态。例如，我们可以对登录流程建模如下:

在这个例子中，我们不仅将第一次登录与其他登录区分开来，而且还为所有的州取了有意义的名称。

为了从一个状态转移到另一个状态，我们可以实现一些函数，这些函数在接收到正确的数据后可以返回正确的下一个状态。

在这个例子中，我们有一个名为`retrieveUserState`的函数，它试图从一些真实的来源中检索`userState`。如果失败，它返回`nil`。

然后，在`LoginState`枚举中，我们有一个`logIn()`函数和一个`logOut()`函数。这些方法的结构是相同的。首先，我们`assert`我们是否在正确的状态下执行那个功能。然后，根据某些条件，我们返回一个新的状态。

一旦我们有了状态和在它们之间移动的方法，我们就可以实现一些有趣的功能。例如，我们可以根据当前状态显示适当的屏幕:

在这个文件的第一部分，我们有三个`UIViewControllers`——每个州一个。特别是，注意`UserProfileViewController`不需要处理任何`nil`值。我们需要传递实际的数据来创建它。

然后，我们对`LoginState`进行了扩展，实现了登录特性的协调逻辑。

有了这个解决方案，我们就不必与各种各样的工厂打交道，我们可以保持导航逻辑、状态建模和依赖性管理完全分离。

# 关于可组合性的一个注记

您可能想知道工厂方法是否比这种方法更具可组合性。但是，如果你深入思考这一点，它们是完全等同的。

首先，在模块化的应用程序中，我们总是需要某种胶水将所有不同的模块粘在一起。假设登录功能和入职功能位于两个不同的模块中。登录功能不知道关于 Onboarding 的任何事情，Onboarding 功能也不知道关于登录功能的任何事情。

在这两个实现中，创建适当的视图控制器的逻辑都不能驻留在这两个模块中。如果我们将它放入登录模块，登录必须知道必须呈现哪个 Onboarding 的`ViewController`。这在两个模块之间创建了一个从登录开始指向入职的依赖关系。同时，如果我们想要在 Onboarding 模块中实现该逻辑，这意味着该功能必须推理登录功能的状态。这在另一个方向上产生了依赖性。

在这两种情况下，最好的解决方案是将决策和逻辑推到已经知道所有特性的更高层次。那是一个[协调器](https://www.raywenderlich.com/books/design-patterns-by-tutorials/v3.0/chapters/23-coordinator-pattern)。在这一点上，逻辑可以是一个工厂或一个简单的函数。

其次，我们可以像任何其他实体一样组合`enums`。我们可以有一个外部的`AppState` `enum`，它由内部的、更具体的`enums`组成，其相关值甚至更具体`enums`。比如说:

在这段代码中，我将`LoginState`重命名为`AppState`，以更好地反映该枚举的实际功能。

`AppState`跟踪用户的当前状态。他们可以注销，他们可以在入职时(当他们第一次执行登录时)，或者他们可以使用所有信息登录。

在入职培训中，他们可以在提供任何真实数据之前出现在简介页面上。或者他们可以出现在屏幕上，提示他们输入姓名。一旦用户提供了他们，我们可以转到一个屏幕，在那里我们要求他们的出生日期。

最后，当用户完成入职培训后，他们可以进入两个选项卡之一:锻炼选项卡或个人资料选项卡。在“健身程序”选项卡中，他们可以无所事事，在健身程序列表中搜索，或者他们可能已经选择了一个精确的健身程序。

我们可以将任何子状态实现为更小的 FSM。较小的 FSM 可以从外部枚举中提取，并传递给只需要该状态而不需要其他信息的功能。

# 结论

在今天的文章中，我们探讨了所有应用程序中反复出现的一个问题:如何处理应用程序状态以避免不一致。

在描述了问题之后，我们定义了基于*锁和钥匙*模式的理论解决方案。在这种模式中，锁是一种只能用正确的数据解锁的状态，即*键。*

我们简要讨论了功能强大但冗长的工厂模式。然后，我们探索了一种更快捷和更简单的方式来使用`enums`和`associatedValues`实现锁和钥匙。

我们讨论了如何从一种状态转移到另一种状态，以及如何实际使用 FSM 来实现在结构上避免`nil`值和不一致性的逻辑。

最后，我们讨论了如何使用协调器将所有东西粘在一起，以及如何在模块化的应用程序中组合多个较小的 FSM 来创建复杂的状态。

这种方法应该可以防止一整类的错误。我们的应用程序中不再有不一致的状态。