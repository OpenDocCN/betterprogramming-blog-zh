<html>
<head>
<title>Static Dispatch Over Dynamic Dispatch</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">静态调度优于动态调度</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/static-dispatch-over-dynamic-dispatch-a-performance-analysis-47f9fee3803a?source=collection_archive---------6-----------------------#2019-07-16">https://betterprogramming.pub/static-dispatch-over-dynamic-dispatch-a-performance-analysis-47f9fee3803a?source=collection_archive---------6-----------------------#2019-07-16</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="fa0f" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">性能分析</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/493c722eb0ceabfcef4bdfee6ae8fdf2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*Dt9GXaS83Pknk13b"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">照片由<a class="ae kv" href="https://unsplash.com/@robinpierre?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">罗宾·皮尔</a>在<a class="ae kv" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</p></figure><p id="18e8" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在我的<a class="ae kv" href="https://medium.com/@bakshioye/static-vs-dynamic-dispatch-in-swift-a-decisive-choice-cece1e872d?source=friends_link&amp;sk=d31cc5924ef21455b0c12b1fcdd6c1d5" rel="noopener">上一篇文章</a>中，我解释了Swift编程语言中可用的各种<em class="ls">分派技术</em>。每当我们听到术语<em class="ls">调度技术</em>时，脑海中浮现的两个是<em class="ls">静态</em>和<em class="ls">动态</em>。</p><p id="1621" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">如果您还没有阅读我的<a class="ae kv" href="https://medium.com/@bakshioye/static-vs-dynamic-dispatch-in-swift-a-decisive-choice-cece1e872d" rel="noopener">上一篇文章</a>，我强烈推荐您阅读，这样您可以获得一些调度技术的知识。</p><p id="8ca6" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">但是如果你认为你知道它们是什么，那么让我们继续！</p></div><div class="ab cl lt lu hu lv" role="separator"><span class="lw bw bk lx ly lz"/><span class="lw bw bk lx ly lz"/><span class="lw bw bk lx ly"/></div><div class="ij ik il im in"><h1 id="6325" class="ma mb iq bd mc md me mf mg mh mi mj mk jw ml jx mm jz mn ka mo kc mp kd mq mr bi translated">这一切是如何开始的</h1><p id="a8d2" class="pw-post-body-paragraph kw kx iq ky b kz ms jr lb lc mt ju le lf mu lh li lj mv ll lm ln mw lp lq lr ij bi translated">很久以前有<a class="ae kv" href="https://developer.apple.com/swift/blog/?id=27" rel="noopener ugc nofollow" target="_blank">一篇<em class="ls">苹果</em>的文章</a>，说静态调度胜过动态调度。因此，您应该始终默认使用静态调度，只有在必要时才切换到动态调度。</p><p id="f7f5" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">当我们选择静态分派而不是动态分派时，我们获得性能提升的核心原因是，在静态分派的情况下，编译器知道，在编译时，<strong class="ky ir"> </strong>某个类的哪个方法实现将被调用。通过这种方式，编译器可以调整一些优化技术，比如设置一些标志，或者可能的话，将调用转换为<em class="ls">内联分派</em>(这是最快的)！</p><p id="7479" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">然而，在动态分派的情况下，编译器只能在运行时计算出某个类要调用哪个方法实现，即基类方法还是子类方法。</p><p id="b1da" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这使得静态调度的性能优于动态调度。</p></div><div class="ab cl lt lu hu lv" role="separator"><span class="lw bw bk lx ly lz"/><span class="lw bw bk lx ly lz"/><span class="lw bw bk lx ly"/></div><div class="ij ik il im in"><h1 id="dc9c" class="ma mb iq bd mc md me mf mg mh mi mj mk jw ml jx mm jz mn ka mo kc mp kd mq mr bi translated">如何实现静态调度</h1><p id="35e6" class="pw-post-body-paragraph kw kx iq ky b kz ms jr lb lc mt ju le lf mu lh li lj mv ll lm ln mw lp lq lr ij bi translated">现在，根据本文，有三种方法可以实现静态调度或减少动态调度:</p><ul class=""><li id="6f63" class="mx my iq ky b kz la lc ld lf mz lj na ln nb lr nc nd ne nf bi translated">关键字:这确保了特定的类永远不会被子类化，特定的方法永远不会被覆盖，因此永远不会有动态调度。</li><li id="8138" class="mx my iq ky b kz nk lc nl lf nm lj nn ln no lr nc nd ne nf bi translated">关键字:这限制了方法或变量对类本身的可见性。根据文章:</li></ul><blockquote class="np"><p id="a37a" class="nq nr iq bd ns nt nu nv nw nx ny lr dk translated">这允许编译器找到所有潜在的重写声明。没有任何这样的重写声明，使得编译器能够自动推断出final关键字，并移除对方法和属性访问的间接调用。</p></blockquote><p id="581f" class="pw-post-body-paragraph kw kx iq ky b kz nz jr lb lc oa ju le lf ob lh li lj oc ll lm ln od lp lq lr ij bi translated">这意味着，无论何时我们将方法或变量标记为<code class="fe ng nh ni nj b">private</code>，如果该方法或变量在任何地方被覆盖，编译器都会执行搜索。如果是，它将产生一个<em class="ls">编译时错误</em>。如果它没有发现任何被覆盖的行为，它将隐式地用<code class="fe ng nh ni nj b">final</code>标记它。</p><ul class=""><li id="313c" class="mx my iq ky b kz la lc ld lf mz lj na ln nb lr nc nd ne nf bi translated">整体模块优化技术:这是一个编译器标志，<code class="fe ng nh ni nj b">-whole-module-optimization</code>，它现在默认为Xcode 8的新项目启用。总而言之，当我们不使用这个标志(<code class="fe ng nh ni nj b">-wmo</code>)时，Swift编译器会单独编译属于一个模块的所有<code class="fe ng nh ni nj b">.swift</code>文件。这限制了编译器添加某些优化，如内联，因为它将单独编译所有文件，因此编译器不知道不同的类及其方法是如何相关的。每当我们使用<code class="fe ng nh ni nj b">-wmo</code>时，Swift编译器将所有这些<code class="fe ng nh ni nj b">.swift</code>文件编译在一起，因此可以添加优化。如果你想了解更多关于<code class="fe ng nh ni nj b">-wmo</code>的内容，这里有很好的详细文档<a class="ae kv" href="https://swift.org/blog/whole-module-optimizations/" rel="noopener ugc nofollow" target="_blank"/>。</li></ul></div><div class="ab cl lt lu hu lv" role="separator"><span class="lw bw bk lx ly lz"/><span class="lw bw bk lx ly lz"/><span class="lw bw bk lx ly"/></div><div class="ij ik il im in"><h1 id="a9ff" class="ma mb iq bd mc md me mf mg mh mi mj mk jw ml jx mm jz mn ka mo kc mp kd mq mr bi translated">最后</h1><p id="1b94" class="pw-post-body-paragraph kw kx iq ky b kz ms jr lb lc mt ju le lf mu lh li lj mv ll lm ln mw lp lq lr ij bi translated">在我读完这篇文章后，我脑子里只有一件事——证据在哪里？</p><p id="2ef8" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我知道我们到现在为止已经经历了很多理论概念，但是我们是程序员。我们热爱代码。还有什么比证明所有这些概念的代码更好的证明呢！</p><h2 id="a659" class="oe mb iq bd mc of og dn mg oh oi dp mk lf oj ok mm lj ol om mo ln on oo mq op bi translated">小测验</h2><p id="78db" class="pw-post-body-paragraph kw kx iq ky b kz ms jr lb lc mt ju le lf mu lh li lj mv ll lm ln mw lp lq lr ij bi translated">我创建了一个小的<a class="ae kv" href="https://github.com/bakshioye/PerformanceTester.git" rel="noopener ugc nofollow" target="_blank"> <strong class="ky ir">性能测试器</strong>项目</a>，无非就是一堆Swift类和一些单元测试。这是我能找到的测试代码性能/速度的唯一方法。您可以克隆存储库并亲自查看。</p><p id="bbed" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我只使用了<code class="fe ng nh ni nj b">final</code>关键字，但是您也可以使用其他两种方法。我将简要地告诉你项目组件是什么，以及如何运行测试用例。</p><p id="24e8" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在这个项目中，只有两个文件对我们很重要:</p><ol class=""><li id="9dbd" class="mx my iq ky b kz la lc ld lf mz lj na ln nb lr oq nd ne nf bi translated">这包含了我们将用于测试用例的所有类。</li><li id="1c79" class="mx my iq ky b kz nk lc nl lf nm lj nn ln no lr oq nd ne nf bi translated"><code class="fe ng nh ni nj b">PerformanceTesterTests.swift</code> —它出现在<code class="fe ng nh ni nj b">PerformanceTesterTests</code>组下，这是我们的单元测试组，包含我们的测试用例。</li></ol><p id="b043" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我在这两个文件中都添加了注释，使其更加不言自明。</p><p id="411a" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">来运行一个测试案例—</p><ul class=""><li id="6c11" class="mx my iq ky b kz la lc ld lf mz lj na ln nb lr nc nd ne nf bi translated">取消<code class="fe ng nh ni nj b">PerformanceTesterTests.swift</code>文件中第36行的注释，它属于我们的静态分派。</li><li id="728d" class="mx my iq ky b kz nk lc nl lf nm lj nn ln no lr nc nd ne nf bi translated">点击第33行的菱形图标来运行测试用例。</li></ul><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi or"><img src="../Images/483978fdc605083c6dd965ef8a3a427a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*_7rI7vDZQnIGL6RJqymh1w.png"/></div></div></figure><p id="7f9e" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这将启动iPhone模拟器。模拟器一上线，就会运行测试用例。</p><ul class=""><li id="cb7f" class="mx my iq ky b kz la lc ld lf mz lj na ln nb lr nc nd ne nf bi translated">在测试用例完成之后，您将在右边看到运行该测试用例所花费的时间。</li></ul><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi os"><img src="../Images/cb624a080c831de0efb185d007416891.png" data-original-src="https://miro.medium.com/v2/resize:fit:548/format:webp/1*IoWYissLHK0RnW53RsTAHQ.png"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">最后一节课</p></figure><ul class=""><li id="93be" class="mx my iq ky b kz la lc ld lf mz lj na ln nb lr nc nd ne nf bi translated">它可能会说“没有固定的基线”或类似的话，但你需要<strong class="ky ir">点击像图中的灰色勾号</strong>(你可能需要在第一个勾号后再点击一次)，<strong class="ky ir"> </strong>，这将打开一个弹出窗口，如下所示:</li></ul><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi ot"><img src="../Images/2ab3e8f509349ef537d6deb554fcaf9d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1242/format:webp/1*hsWovnjT7jXWEnZ4s2vM4Q.png"/></div></figure><ul class=""><li id="f59a" class="mx my iq ky b kz la lc ld lf mz lj na ln nb lr nc nd ne nf bi translated">现在点击<code class="fe ng nh ni nj b">Edit -&gt; Accept -&gt; Save</code>。这将以此时间为基准，所有比较都将基于我们保存的基准时间进行。</li><li id="4d02" class="mx my iq ky b kz nk lc nl lf nm lj nn ln no lr nc nd ne nf bi translated">就是这样！注释当前行(第36行)，取消下一行的注释(记住，一次只取消一行的注释)，使用第33行再次运行测试用例，并亲自查看性能差异。它将向您显示我们设置的基线(我们的静态调度基线)和我们当前的测试用例之间的%差异。</li></ul></div><div class="ab cl lt lu hu lv" role="separator"><span class="lw bw bk lx ly lz"/><span class="lw bw bk lx ly lz"/><span class="lw bw bk lx ly"/></div><div class="ij ik il im in"><h1 id="888b" class="ma mb iq bd mc md me mf mg mh mi mj mk jw ml jx mm jz mn ka mo kc mp kd mq mr bi translated">一些观察</h1><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi ou"><img src="../Images/bcf459e770107f15ee6e5fd8e72efc72.png" data-original-src="https://miro.medium.com/v2/resize:fit:522/format:webp/1*JEdfxzjvTrWNtPNKlbhapg.png"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">类既不是最终类也不是子类</p></figure><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi ov"><img src="../Images/5f9328e50809de0c8b2ae7a4f59d28e7.png" data-original-src="https://miro.medium.com/v2/resize:fit:524/format:webp/1*2kEmw8AYWX4UTQoqNzoKbA.png"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">类别不是最终类别，但已被子类化</p></figure><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi ow"><img src="../Images/0ceb22947ffd061e3c4cff918de4c587.png" data-original-src="https://miro.medium.com/v2/resize:fit:534/format:webp/1*lhkCP8qlj_y6rM2j1sm1qQ.png"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">派生类(或子类)</p></figure><p id="05ee" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">所以，总而言之，作为一个好的实践，你应该首先将你的类标记为<code class="fe ng nh ni nj b">final</code>，如果需要继承，就去掉<code class="fe ng nh ni nj b">final</code>关键字。这确保了编译器的优化，从而提高了代码的性能。</p></div></div>    
</body>
</html>