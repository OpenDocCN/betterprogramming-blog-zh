<html>
<head>
<title>Understanding Layered Architecture in KMM, Part 4 — The Data Layer</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">了解KMM的分层架构，第4部分—数据层</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/understanding-layered-architecture-in-kmm-part-4-the-data-layer-6fc0e153fffb?source=collection_archive---------13-----------------------#2022-08-18">https://betterprogramming.pub/understanding-layered-architecture-in-kmm-part-4-the-data-layer-6fc0e153fffb?source=collection_archive---------13-----------------------#2022-08-18</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="0b85" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">第4部分，共5部分</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi kf"><img src="../Images/0d5f297f0cfff80249221fd8a33f0f20.png" data-original-src="https://miro.medium.com/v2/resize:fit:1380/format:webp/1*DqpOyFM5N59EbAWwIPCCag.png"/></div><p class="kn ko gj gh gi kp kq bd b be z dk translated">我们项目的架构。</p></figure><p id="8f52" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">现在我们来看看数据层。为此，有必要记住我们在本系列第二部分所做的架构设计，<a class="ae ln" href="https://medium.com/@jflavio11/understanding-layered-architecture-in-kmm-part-2-designing-the-solution-957e2b1fb536" rel="noopener">你可以在这里阅读</a>。</p><p id="3576" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">如你所见，我们有三个主要模块:<code class="fe lo lp lq lr b">android</code>、<code class="fe lo lp lq lr b">iOS</code>和<code class="fe lo lp lq lr b">core</code>(在Gradle中称为<code class="fe lo lp lq lr b">shared</code>)。</p><p id="2a05" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">我们的<code class="fe lo lp lq lr b">shared</code>模块中的<code class="fe lo lp lq lr b">xMain</code>包，是为你能想到的任何平台准备的，那就是web、终端、Mac等等。</p><p id="5d9c" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">但是现在让我们来看看对这第四部分最重要的:</p><ul class=""><li id="3d04" class="ls lt iq kt b ku kv kx ky la lu le lv li lw lm lx ly lz ma bi translated">这是我们项目的数据层实现。所有与数据访问相关的代码都将在这里定义，除了平台实现，如<em class="mb">数据库引擎</em>。即:存储库接口实现、本地和远程数据源、平台数据提供者(这些是将要在平台模块中实现的<em class="mb"> expect类</em>)等。</li><li id="2eb2" class="ls lt iq kt b ku mc kx md la me le mf li mg lm lx ly lz ma bi translated"><code class="fe lo lp lq lr b">androidMain</code>:包含与android平台相关的代码，它在<code class="fe lo lp lq lr b"><em class="mb">shared</em></code>里面，因为可以被项目中的任何<em class="mb"> android应用模块</em>重用。这里，我们将在<code class="fe lo lp lq lr b"><em class="mb">commonMain</em></code>模块中定义<em class="mb"> expect类</em>的实现。</li><li id="70c6" class="ls lt iq kt b ku mc kx md la me le mf li mg lm lx ly lz ma bi translated"><code class="fe lo lp lq lr b">iosMain</code>:与<code class="fe lo lp lq lr b"><em class="mb">androidMain</em></code>类似，但用于iOS。</li></ul></div><div class="ab cl mh mi hu mj" role="separator"><span class="mk bw bk ml mm mn"/><span class="mk bw bk ml mm mn"/><span class="mk bw bk ml mm"/></div><div class="ij ik il im in"><p id="eb0c" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated"><strong class="kt ir">重要提示<br/> </strong>共享模块中的<code class="fe lo lp lq lr b">androidMain</code>和<code class="fe lo lp lq lr b">iosMain</code>模块不实现数据访问层(存储库或数据源，因为它们必须可被任何其他模块重用)，它们实现expect类。例如:</p><ul class=""><li id="2910" class="ls lt iq kt b ku kv kx ky la lu le lv li lw lm lx ly lz ma bi translated">Android和iOS获取当前<em class="mb">时间戳</em>的方式是不同的。我们必须创建一个expect类来定义获取时间戳的契约，并且每个平台模块都实现它。行为类似于接口。</li></ul><pre class="kg kh ki kj gt mo lr mp mq aw mr bi"><span id="cff8" class="ms mt iq lr b gy mu mv l mw mx">// inside the shared/commonMain module<br/>expect class TimeProvider {<br/>    var timestamp: Long<br/>}</span><span id="194b" class="ms mt iq lr b gy my mv l mw mx">// implementation in shared/androidMain module<br/>actual class TimeProvider {<br/>    actual var timestamp: Long = System.currentTimeMillis()<br/>}</span><span id="cb31" class="ms mt iq lr b gy my mv l mw mx">// implementation in shared/iosMain module<br/>actual class TimeProvider {<br/>    actual var timestamp = NSDate().<em class="mb">timeIntervalSince1970</em>.toLong()<br/>}</span></pre><p id="7aff" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">这同样适用于每个平台创建数据库引擎实例的方式。我们只定义了获取数据库驱动程序的“契约”:</p><pre class="kg kh ki kj gt mo lr mp mq aw mr bi"><span id="c8f9" class="ms mt iq lr b gy mu mv l mw mx">expect class DatabaseDriverFactory {<br/>    fun createDriver(): SqlDriver<br/>}</span></pre><p id="5be1" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">而且每个平台都实现了<em class="mb"> expect类</em>，比如Android需要一个<code class="fe lo lp lq lr b">context</code> <em class="mb"> : </em></p><pre class="kg kh ki kj gt mo lr mp mq aw mr bi"><span id="c83d" class="ms mt iq lr b gy mu mv l mw mx">// implementation inside shared/androidMain module<br/>actual class DatabaseDriverFactory(private val context: Context) {<br/>    actual fun createDriver(): SqlDriver {<br/>        return AndroidSqliteDriver(<br/>            schema = MoviesDb.Schema,<br/>            context = context,<br/>            name = "movies.db"<br/>        )<br/>    }<br/>}</span></pre></div><div class="ab cl mh mi hu mj" role="separator"><span class="mk bw bk ml mm mn"/><span class="mk bw bk ml mm mn"/><span class="mk bw bk ml mm"/></div><div class="ij ik il im in"><p id="8f77" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">这就是我们项目中数据层的样子(正如您所见，<code class="fe lo lp lq lr b">data</code>包在<code class="fe lo lp lq lr b">shared/commonMain</code>模块中):</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi mz"><img src="../Images/ab7b1fc3fb42ca3615a9604443f4b893.png" data-original-src="https://miro.medium.com/v2/resize:fit:466/format:webp/1*A36T0Gb98PfEOppjDNkEww.png"/></div><p class="kn ko gj gh gi kp kq bd b be z dk translated">commonMain模块中的数据层。</p></figure><p id="a2f2" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">我们有域层的域包<em class="mb"> </em>，正如我在上一篇文章中解释的<a class="ae ln" href="https://medium.com/@jflavio11/understanding-the-layered-architecture-with-kmm-part-3-the-domain-layer-3df5e1fa3e6a" rel="noopener">，还有外部的<code class="fe lo lp lq lr b">sqldelight</code>包(就在Kotlin包下面)，以及实现所有数据层的数据包。</a></p><p id="b045" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">在我们的数据层中，我们有:</p><ul class=""><li id="971b" class="ls lt iq kt b ku kv kx ky la lu le lv li lw lm lx ly lz ma bi translated"><code class="fe lo lp lq lr b">local</code> package: local data access，这里我们可以定义一个<em class="mb"> expect类</em>用于平台数据访问的实现(就像Android中的<code class="fe lo lp lq lr b">SharedPreferences</code>，或者作为我们的项目，定义<em class="mb"> expect类</em>用于创建数据库驱动(<code class="fe lo lp lq lr b">DatabaseDriverFactory.kt</code>)。<br/><code class="fe lo lp lq lr b">MovieLocalDataSource</code>负责与本地数据源(内部数据库、系统偏好等)相关的CRUD操作。它将在存储库实现中使用(<code class="fe lo lp lq lr b">MovieRepositoryImpl</code>)。</li><li id="2019" class="ls lt iq kt b ku mc kx md la me le mf li mg lm lx ly lz ma bi translated"><code class="fe lo lp lq lr b">remote</code>包:顾名思义，这里我们有所有与远程数据访问相关的代码，即:REST APIs、GraphQL、Firebase等。我们只使用了MovieDB服务中的REST API。此外，我们可以定义响应和请求，这些对于任何平台都必须是相同的，这就是这里定义的原因。</li><li id="fa74" class="ls lt iq kt b ku mc kx md la me le mf li mg lm lx ly lz ma bi translated"><code class="fe lo lp lq lr b">TimeProvider</code>和<code class="fe lo lp lq lr b">PropertiesProvider</code> : <em class="mb"> expect类</em>返回平台特定数据，<code class="fe lo lp lq lr b">TimeProvider</code>返回当前时间戳，<code class="fe lo lp lq lr b">PropertiesProvider</code><em class="mb"/><em class="mb"/><code class="fe lo lp lq lr b">API KEY</code><em class="mb"/>用于消费REST API。</li><li id="32ba" class="ls lt iq kt b ku mc kx md la me le mf li mg lm lx ly lz ma bi translated"><code class="fe lo lp lq lr b">MovieRepositoryImpl</code>:域层内部<code class="fe lo lp lq lr b">MovieRepository</code>接口的实现。很容易注意到，这是任何平台都共享的:我们请求电影列表，我们在本地数据源中询问数据是否过时，如果是，那么我们请求REST API，我们在本地数据源中保存结果(也就是说，我们更新它)并返回更新的数据。这将由我们的域层内部的<code class="fe lo lp lq lr b">GetMoviesInteractor</code>调用，并且<code class="fe lo lp lq lr b">GetMoviesInteractor</code>应该被注入到<code class="fe lo lp lq lr b">ViewModel</code>、<code class="fe lo lp lq lr b">Presenter</code>等中。</li></ul><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="nb nc di nd bf ne"><div class="gh gi na"><img src="../Images/19faaacb5e138fefb148b5fd39498d08.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*pnhyitIK9sQ-Yra0S8A2rg.png"/></div></div><p class="kn ko gj gh gi kp kq bd b be z dk translated">数据层内部的MovieRepository实现。</p></figure><blockquote class="nf ng nh"><p id="138b" class="kr ks mb kt b ku kv jr kw kx ky ju kz ni lb lc ld nj lf lg lh nk lj lk ll lm ij bi translated">注意:我推荐你阅读<a class="ae ln" href="https://cashapp.github.io/sqldelight/multiplatform_sqlite/" rel="noopener ugc nofollow" target="_blank"> SQDelight库文档</a>来理解它是如何工作的，它很容易实现，但是需要知道一些细节，比如为定义数据库模式设置相同的包结构。</p></blockquote></div><div class="ab cl mh mi hu mj" role="separator"><span class="mk bw bk ml mm mn"/><span class="mk bw bk ml mm mn"/><span class="mk bw bk ml mm"/></div><div class="ij ik il im in"><h1 id="cd7d" class="nl mt iq bd nm nn no np nq nr ns nt nu jw nv jx nw jz nx ka ny kc nz kd oa ob bi translated">概括起来</h1><p id="206b" class="pw-post-body-paragraph kr ks iq kt b ku oc jr kw kx od ju kz la oe lc ld le of lg lh li og lk ll lm ij bi translated">我们已经在这个Kotlin多平台项目中介绍了我们的数据层的实现，最重要的细节是:</p><ul class=""><li id="33a7" class="ls lt iq kt b ku kv kx ky la lu le lv li lw lm lx ly lz ma bi translated">我们在<em class="mb"> </em> <code class="fe lo lp lq lr b"><em class="mb">shared</em></code>模块内的<code class="fe lo lp lq lr b"><em class="mb">commonMain</em></code> <em class="mb">模块</em>中实现了数据层，因为它将被任何平台重用。</li><li id="69aa" class="ls lt iq kt b ku mc kx md la me le mf li mg lm lx ly lz ma bi translated">更具体地说，数据层中的类被注入到领域层类中(就像在用例/交互器内部)。然而，在我们需要注入它们的每个平台上。</li><li id="d32b" class="ls lt iq kt b ku mc kx md la me le mf li mg lm lx ly lz ma bi translated">如果我们在数据层的类需要特定的平台数据，比如<code class="fe lo lp lq lr b">timestamp</code>值或API键，我们将需要定义<em class="mb">期望类</em>并在<code class="fe lo lp lq lr b">shared</code>模块内的每个平台模块中实现它们。</li><li id="bf67" class="ls lt iq kt b ku mc kx md la me le mf li mg lm lx ly lz ma bi translated">尽量将所有数据层逻辑放在<em class="mb">数据包中。</em>存储库内部的工作方式(比如调用哪些数据源或如何执行CRUD操作)可能因平台而异。</li></ul></div><div class="ab cl mh mi hu mj" role="separator"><span class="mk bw bk ml mm mn"/><span class="mk bw bk ml mm mn"/><span class="mk bw bk ml mm"/></div><div class="ij ik il im in"><p id="38e1" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">您可以在Github上关注项目的进展:</p><div class="oh oi gp gr oj ok"><a href="https://github.com/jflavio11/LayeredKMM" rel="noopener  ugc nofollow" target="_blank"><div class="ol ab fo"><div class="om ab on cl cj oo"><h2 class="bd ir gy z fp op fr fs oq fu fw ip bi translated">GitHub—jflavio 11/LayeredKotlinMultiplatform:展示分层的示例KMM应用程序…</h2><div class="or l"><h3 class="bd b gy z fp op fr fs oq fu fw dk translated">这个项目是由一系列的职位，你可以在我的博客https://jflavio.com领域和数据层…</h3></div><div class="os l"><p class="bd b dl z fp op fr fs oq fu fw dk translated">github.com</p></div></div><div class="ot l"><div class="ou l ov ow ox ot oy kl ok"/></div></div></a></div><h1 id="fdec" class="nl mt iq bd nm nn oz np nq nr pa nt nu jw pb jx nw jz pc ka ny kc pd kd oa ob bi translated">此帖子系列的拆分</h1><p id="007f" class="pw-post-body-paragraph kr ks iq kt b ku oc jr kw kx od ju kz la oe lc ld le of lg lh li og lk ll lm ij bi translated">这是我们讨论领域层的第二篇文章。下面，我们将讨论数据层。本指南分为以下帖子:</p><ol class=""><li id="4b33" class="ls lt iq kt b ku kv kx ky la lu le lv li lw lm pe ly lz ma bi translated"><a class="ae ln" href="https://medium.com/better-programming/understanding-layered-architecture-in-a-kotlin-multiplatform-project-part-1-a7488f478978" rel="noopener">简介</a></li><li id="0a65" class="ls lt iq kt b ku mc kx md la me le mf li mg lm pe ly lz ma bi translated"><a class="ae ln" href="https://jflavio11.medium.com/understanding-layered-architecture-in-kmm-part-2-designing-the-solution-957e2b1fb536" rel="noopener">设计解决方案</a></li><li id="15b3" class="ls lt iq kt b ku mc kx md la me le mf li mg lm pe ly lz ma bi translated"><a class="ae ln" href="https://jflavio11.medium.com/understanding-the-layered-architecture-with-kmm-part-3-the-domain-layer-3df5e1fa3e6a" rel="noopener">创建域层</a></li><li id="6f37" class="ls lt iq kt b ku mc kx md la me le mf li mg lm pe ly lz ma bi translated"><a class="ae ln" href="https://jflavio11.medium.com/understanding-layered-architecture-in-kmm-part-4-the-data-layer-6fc0e153fffb" rel="noopener">创建图层数据</a>(本帖)</li><li id="4eb5" class="ls lt iq kt b ku mc kx md la me le mf li mg lm pe ly lz ma bi translated">实现表示层</li></ol></div></div>    
</body>
</html>