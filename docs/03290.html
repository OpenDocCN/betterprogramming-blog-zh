<html>
<head>
<title>Algorithms: Check if a String Is a Palindrome in 4 Different Ways</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">算法:用4种不同的方法检查一个字符串是否是回文</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/algorithms-101-palindromes-8a06ea97af86?source=collection_archive---------0-----------------------#2020-02-02">https://betterprogramming.pub/algorithms-101-palindromes-8a06ea97af86?source=collection_archive---------0-----------------------#2020-02-02</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="6d1b" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">“一个人，一个计划，一条运河——巴拿马！”回文//真</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/94ed5195e883a71a4300310447d144ed.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*mCsos-p1uJpmkzM-E6grMw.jpeg"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">照片由<a class="ae ky" href="https://www.pexels.com/@evgeny-tchebotarev-1058775?utm_content=attributionCopyText&amp;utm_medium=referral&amp;utm_source=pexels" rel="noopener ugc nofollow" target="_blank">叶夫根尼·切博塔列夫</a>从<a class="ae ky" href="https://www.pexels.com/photo/white-lantern-lot-2541310/?utm_content=attributionCopyText&amp;utm_medium=referral&amp;utm_source=pexels" rel="noopener ugc nofollow" target="_blank">佩克斯</a>拍摄</p></figure><p id="5427" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">今天，我很满意地醒来，因为我意识到这是一个回文日期:02-02-2020。</p><p id="f77f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">回文是一个单词、数字或短语，向前和向后读都一样，例如“kayak”、“1001”、“我看到的是一辆车还是一只猫？”，或者“阿爸”。</p><p id="8284" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我喜欢回文——在维基百科页面上阅读更多关于它们为什么有趣的内容。你知道最长的回文有58，795个字母吗？</p><p id="9ade" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">另外，你可以用这首美妙的诗来测试:<a class="ae ky" href="https://genius.com/Demetri-martin-dammit-im-mad-annotated" rel="noopener ugc nofollow" target="_blank"> <em class="lv">该死的我疯了</em> </a>作者<a class="ae ky" href="https://en.wikipedia.org/wiki/Demetri_Martin" rel="noopener ugc nofollow" target="_blank">迪米特利·马丁</a>，其中每一行都是一个回文，就像一首诗本身一样！</p></div><div class="ab cl lw lx hx ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="im in io ip iq"><h1 id="8709" class="md me it bd mf mg mh mi mj mk ml mm mn jz mo ka mp kc mq kd mr kf ms kg mt mu bi translated">回文算法</h1><p id="90ab" class="pw-post-body-paragraph kz la it lb b lc mv ju le lf mw jx lh li mx lk ll lm my lo lp lq mz ls lt lu im bi translated">欢迎来到我的算法系列，在这里我将解释如何解决常见的算法问题。</p><p id="bbdf" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">今天，我们将创建一个算法来检查给定的单词是否是回文。我提出了三种解决方案，按照性能最低到最高的顺序排列。</p></div><div class="ab cl lw lx hx ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="im in io ip iq"><h1 id="8ea8" class="md me it bd mf mg mh mi mj mk ml mm mn jz mo ka mp kc mq kd mr kf ms kg mt mu bi translated">设置:正则表达式</h1><p id="fedf" class="pw-post-body-paragraph kz la it lb b lc mv ju le lf mw jx lh li mx lk ll lm my lo lp lq mz ls lt lu im bi translated">如果你想变得更奇特，你可以从思考边缘案例开始。如果你的例子包括空格，不同大小写的字母，或者函数符号呢？</p><p id="f4d5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这不是必需的，因为可能测试中给出的唯一例子是一个单词的字符串。否则，您可能希望在代码中添加一些保护措施。将这一行粘贴到函数定义中:</p><pre class="kj kk kl km gt na nb nc nd aw ne bi"><span id="c4a8" class="nf me it nb b gy ng nh l ni nj">let str = str.toLowerCase().<!-- -->replace(/[\W_]/g, '')</span></pre><p id="2be9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这一行首先接受下面例子中作为参数传入的字符串，小写所有字母，并取出非字母数字字符。</p></div><div class="ab cl lw lx hx ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="im in io ip iq"><h1 id="f629" class="md me it bd mf mg mh mi mj mk ml mm mn jz mo ka mp kc mq kd mr kf ms kg mt mu bi translated">解决方案1:将字符串与其反向版本进行比较</h1><p id="adf6" class="pw-post-body-paragraph kz la it lb b lc mv ju le lf mw jx lh li mx lk ll lm my lo lp lq mz ls lt lu im bi translated">因为在JS中，<code class="fe nk nl nm nb b">.reverse()</code>函数只对数组有效，所以我们需要:</p><ol class=""><li id="5e34" class="nn no it lb b lc ld lf lg li np lm nq lq nr lu ns nt nu nv bi translated">将单词拆分成数组，保存到变量中。</li><li id="4dd6" class="nn no it lb b lc nw lf nx li ny lm nz lq oa lu ns nt nu nv bi translated">反转数组。</li><li id="fac3" class="nn no it lb b lc nw lf nx li ny lm nz lq oa lu ns nt nu nv bi translated">把它放回去。</li><li id="86de" class="nn no it lb b lc nw lf nx li ny lm nz lq oa lu ns nt nu nv bi translated">将初始字符串与反转的字符串进行比较。</li></ol><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ob oc l"/></div></figure><p id="5c28" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">您可以通过使用ES6扩展功能使它变得更简单，如下所示:</p><pre class="kj kk kl km gt na nb nc nd aw ne bi"><span id="83cc" class="nf me it nb b gy ng nh l ni nj">function checkPalindrome(str){<br/>  let reversed = [...str].reverse().join("")<br/>  return str === reversed<br/>}</span></pre><p id="34b0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在，这可能是最直观和直接的解决方案，但遗憾的是，它不是最有效的。</p></div><div class="ab cl lw lx hx ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="im in io ip iq"><h1 id="0025" class="md me it bd mf mg mh mi mj mk ml mm mn jz mo ka mp kc mq kd mr kf ms kg mt mu bi translated">解决方案2:递归</h1><p id="d233" class="pw-post-body-paragraph kz la it lb b lc mv ju le lf mw jx lh li mx lk ll lm my lo lp lq mz ls lt lu im bi translated">在这个解决方案中，我们将使用递归(一个函数调用自己来查看是否)。以下是步骤:</p><ol class=""><li id="5ce0" class="nn no it lb b lc ld lf lg li np lm nq lq nr lu ns nt nu nv bi translated">声明一个接受一个参数(字符串)的函数。</li><li id="16f6" class="nn no it lb b lc nw lf nx li ny lm nz lq oa lu ns nt nu nv bi translated">将字符串长度保存到变量中。</li><li id="1360" class="nn no it lb b lc nw lf nx li ny lm nz lq oa lu ns nt nu nv bi translated">检查是否有更多的字母，如果有，继续，否则，你有一个回文。</li><li id="f756" class="nn no it lb b lc nw lf nx li ny lm nz lq oa lu ns nt nu nv bi translated">现在，如果第一个和最后一个字母相同，再次调用该函数，传递第一个和最后一个字母被切片的字符串。否则，返回false。</li></ol><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ob oc l"/></div></figure><p id="7874" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这不是一个完美的解决方案，因为如果传递的字符串是一个空字符串或者只有一个字母呢？</p></div><div class="ab cl lw lx hx ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="im in io ip iq"><h1 id="a1ad" class="md me it bd mf mg mh mi mj mk ml mm mn jz mo ka mp kc mq kd mr kf ms kg mt mu bi translated">解决方案3: for循环</h1><p id="cd12" class="pw-post-body-paragraph kz la it lb b lc mv ju le lf mw jx lh li mx lk ll lm my lo lp lq mz ls lt lu im bi translated">在这个解决方案中，我们将再次反转一个字符串，这次使用一个<code class="fe nk nl nm nb b">for</code>循环来检查两边的字母是否完全相同。</p><ol class=""><li id="7458" class="nn no it lb b lc ld lf lg li np lm nq lq nr lu ns nt nu nv bi translated">用字符串的长度声明一个变量。</li><li id="dc29" class="nn no it lb b lc nw lf nx li ny lm nz lq oa lu ns nt nu nv bi translated">使用字符串长度的一半作为参考点，声明一个<code class="fe nk nl nm nb b">for</code>循环。</li><li id="77d7" class="nn no it lb b lc nw lf nx li ny lm nz lq oa lu ns nt nu nv bi translated">检查每个字母是否与其对应的镜像字符相同，或者另一面的字符是否相同(用index-1测量)。</li></ol><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ob oc l"/></div></figure><p id="df94" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这种解决方案效率更高，因为我们只检查一半的字母，其计算时间大约是第一种解决方案的两倍。</p></div><div class="ab cl lw lx hx ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="im in io ip iq"><h1 id="ff7f" class="md me it bd mf mg mh mi mj mk ml mm mn jz mo ka mp kc mq kd mr kf ms kg mt mu bi translated">4.好处:递归+控制流</h1><p id="0a21" class="pw-post-body-paragraph kz la it lb b lc mv ju le lf mw jx lh li mx lk ll lm my lo lp lq mz ls lt lu im bi translated">下面是Jason Sebring在<a class="ae ky" href="https://stackoverflow.com/a/25091111" rel="noopener ugc nofollow" target="_blank"> Stack Overflow </a>上提出的一个答案，我对此很好奇:</p><pre class="kj kk kl km gt na nb nc nd aw ne bi"><span id="e051" class="nf me it nb b gy ng nh l ni nj">function checkPalindrome(str,i) {<br/>  return (i=i||0)&lt;0 || i&gt;=str.length&gt;&gt;1 || str[i]==str[str.length-1-i] &amp;&amp; checkPalindrome(str,++i);<br/>}</span></pre><p id="2faf" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在JavaScript中，控制流操作符(<code class="fe nk nl nm nb b">&amp;&amp;</code>和<code class="fe nk nl nm nb b">||</code>)是<code class="fe nk nl nm nb b">if/else</code>的替代物。在本解决方案中，我们在三个地方使用它们。以下是一步一步的解释:</p><ol class=""><li id="589d" class="nn no it lb b lc ld lf lg li np lm nq lq nr lu ns nt nu nv bi translated">用两个参数声明函数，字符串和索引:<code class="fe nk nl nm nb b">function checkPalindrome(str,i)</code>。</li><li id="d7c4" class="nn no it lb b lc nw lf nx li ny lm nz lq oa lu ns nt nu nv bi translated">通过组成一个将始终计算为false的表达式来初始化索引，这样它将进行到下一个参数:<code class="fe nk nl nm nb b">(i=i||0)&lt;0</code>。</li><li id="a8bf" class="nn no it lb b lc nw lf nx li ny lm nz lq oa lu ns nt nu nv bi translated">检查索引是否已经到一半，但跳过检查中间的奇数字符。我们使用按位运算符<code class="fe nk nl nm nb b">&gt;&gt;</code>除以2。如果该表达式为真，则检查完成，如果不是，则前进到下一个条件:<code class="fe nk nl nm nb b">i&gt;=str.length&gt;&gt;1</code>。</li><li id="b900" class="nn no it lb b lc nw lf nx li ny lm nz lq oa lu ns nt nu nv bi translated">比较镜像字符(两边相同的地方)是否相同。如果不是，退出并假设这个表达式不是回文。如果为真，继续:<code class="fe nk nl nm nb b">str[i]==str[str.length-1-i]</code>。</li><li id="22df" class="nn no it lb b lc nw lf nx li ny lm nz lq oa lu ns nt nu nv bi translated">递归调用函数重复整个过程:<code class="fe nk nl nm nb b">checkPalindrome(str,++i)</code>。</li></ol></div><div class="ab cl lw lx hx ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="im in io ip iq"><h1 id="f1dc" class="md me it bd mf mg mh mi mj mk ml mm mn jz mo ka mp kc mq kd mr kf ms kg mt mu bi translated">结论</h1><p id="9920" class="pw-post-body-paragraph kz la it lb b lc mv ju le lf mw jx lh li mx lk ll lm my lo lp lq mz ls lt lu im bi translated">和JavaScript中的所有东西一样，有许多方法可以解决这个问题。</p><p id="3a05" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我考虑过使用<code class="fe nk nl nm nb b">.reduce()</code>或<code class="fe nk nl nm nb b">.every()</code>，但是考虑到你不能中断迭代，这会导致低性能，这看起来有点大材小用。我很好奇你对这个普遍问题的看法！</p></div></div>    
</body>
</html>