# C++ constexpr:它到底是什么？

> 原文：<https://betterprogramming.pub/c-constexpr-what-it-really-is-d6ca81023dcd>

## 通过理解什么是 constexpr 以及它与 C++中的 const 有何不同来避免初学者的错误

![](img/173a356fd5563946c4f99a4b071eba60.png)

由[卢卡·布拉沃](https://unsplash.com/@lucabravo?utm_source=medium&utm_medium=referral)在 [Unsplash](https://unsplash.com?utm_source=medium&utm_medium=referral) 拍摄的照片

# 概观

`constexpr`说明符是在`C++11`中引入的，对于初学者来说很容易混淆，因为它类似于`const`限定符。

`constexpr`代表常量表达式，用于指定一个变量或函数可以用在常量表达式中，一个可以在编译时求值的表达式。

`constexpr`的关键点在于它可以在编译时执行。您的代码可能在运行之前就已经被执行了。这才是重点。

我们可以在变量、函数——包括构造函数和 if 语句上使用`constexpr`。我们将在下面的章节中看到细节。

# 变量

我已经在另一篇文章中写了关于`const`限定符的所有细节:

[](/understanding-all-the-details-of-c-const-4d2a4b714b63) [## 理解 C++ Const 的所有细节

### 理解 const 限定符的细节非常重要，有助于提高您的代码质量和代码质量。

better 编程. pub](/understanding-all-the-details-of-c-const-4d2a4b714b63) 

我们使用`const`限定符向编译器和其他程序员表达我们的意图，我们希望变量是只读的，任何修改它的尝试都会导致编译错误。

现在，`constexpr`类似于`const`，因为它暗示了一个`const`。这也是无法改变的。不同之处在于，`const`可以在编译时和运行时进行计算，这取决于我们如何初始化它。

在这个例子中,`val`是在编译时计算的。当我们执行代码时，`val`总是等于`3`。然而，在下面的例子中，`val`是在运行时计算的，因为它涉及到调用一个函数。

由于第一个例子是在编译时计算的，我们可以用`constexpr`替换它，没有任何区别。

但这并不适用于第二个例子。我们将得到一个编译错误，因为它在编译时不能再被计算。

```
error: call to non-‘constexpr’ function ‘int Sum(int, int)’
```

对于这个例子，我们可以将我们的函数转换成一个`constexpr`函数来解决这个问题。

代码看起来是一样的，但是现在是在编译时执行的。在运行时，编译器将我们的代码修改为:

我没有在那里写`const`或`constexpr`,因为一旦程序运行，它们就不再被使用。`const`和`constexpr`都只在编译时使用。

# 函数和构造函数

`constexpr`也可以用在函数和构造函数上。就像上面的例子一样，我们可以指定一个函数或构造函数为`constexpr`函数。

`constexpr`功能灵活。相同的函数可以在编译时或运行时计算。取决于他们是如何称呼的。

在这个例子中，我们有一个名为`Sum`的`constexpr`函数，我们在第`6`和`8`行调用它。第`6`行在编译时求值，与上一节中的例子相同，但是第`8`行在运行时求值，因为它涉及一个名为`var`的非`const`变量。

你可以看到一个`constexpr`函数非常有用，我们可以让编译器决定是在编译时还是运行时评估我们的函数。为了在编译时对其进行评估，必须满足许多条件。详见此[链接](https://en.cppreference.com/w/cpp/language/constexpr)。

# If 语句

既然`C++17`我们也可以指定`constexpr` if 语句。如果日常工作中不处理泛型代码，可能不会经常使用。为了理解为什么这是必要的，我们需要理解 C++模板元编程中 SFINAE(替换失败不是错误)的概念。

## SFINAE 和 std::enable_if

当你在代码中调用一个函数时，编译器必须执行一些检查来知道调用哪个函数，记住你可以写多个同名的函数——函数重载。概括地说，这些步骤是:

*   名称查找
*   模板参数演绎
*   模板参数替换
*   过载分辨率

前三个步骤将生成一组将在重载决策过程中使用的重载函数。重载决策将选择一个参数最匹配的函数。

SFINAE 发生在步骤 3，模板参数替换中，它表示当一个候选函数没有通过替换测试时，不会产生编译错误，它只是从候选列表中删除。让我们看看下面的例子。

我们想写一个名为`Square()`的通用函数，它接受算术类型和用户定义的类型。用户定义的类型是如下所示的类模板。

如果不是为了支持这个类模板，我们可以很容易地如下实现我们的函数模板。

但是当我们传递给这个函数模板一个类型为`Number<int>`的对象时，它就不起作用了。

第`9`行将无法编译，因为`Number<int>`没有实现`operator*`。

解决方案是，我们需要知道传递给我们的函数模板`Square()`的类型，并让 if-else 检查它，这个 if-else 应该在编译时计算，如下面的代码所示。

但是这种解决方案不起作用，因为当我们用一个`int`调用这个函数时，它会试图寻找不存在的`int.value`。为了看得更清楚，这是模板实例化的结果。

现在很清楚为什么它不起作用了，因为 else 部分没有从函数中删除。这是我们得到的编译错误。

```
error: request for member ‘value’ in ‘t’, which is of non-class type ‘const int’
```

解决方案是用两个函数模板来检查我们传入的类型是否是算术类型。

现在我们有两个函数模板，一个用于算术类型，另一个用于非算术类型。如果我们将值`true`传递给它，那么`std::enable_if`有一个公共成员 typedef `::type`，否则它没有公共成员 typedef。

当我们将`Number<int>`传递到`Square()`时，第一个函数模板替换失败，第二个成功。第一个函数没有抛出错误，只是从*函数候选列表*中移除了**。然后编译器选择第二个函数。这就是它起作用的原因。**

通过使用两个或更多带有`std::enable_if`的函数模板，我们在模拟编译时 if-else。

## constexpr if 语句如何改进 SFINAE

虽然很管用，应用也很广泛，但是 SFINAE 和`std::enable_if`的组合不是很直观。代码很冗长，如果你不熟悉它，语法可能很难读懂。

从`C++17`开始，我们可以使用`constexpr` if 语句使其更具可读性。我们可以在单个函数中拥有真正的编译时 if-else，而不是用`std::enable_if`使用多个函数来模拟它。下面是我们如何用`constexpr` if 语句实现的。

我们不仅只有一个函数模板，而且它非常接近我们熟悉的 if-else 语句。这是可行的，因为编译器只接受带有`true`条件的分支，而丢弃其他分支。

# 关键要点

*   `constexpr`用于变量时隐含着`const`，但这不是重点，重点是`constexpr`变量在编译时被求值
*   `constexpr`说明符也可用于函数和构造函数，与返回`const`的函数不同，`constexpr`在此上下文中用于允许函数和构造函数在编译时被评估(如果可能的话)
*   最后一部分是，`constexpr`可以用于编译时 if-else 来提高我们代码的可读性，我们通常使用 SFINAE 和`std::enable_if`来模拟它