<html>
<head>
<title>A Look at Javascript Closures</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">看看Javascript闭包</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/a-look-at-javascript-closures-6de9b9ac4f8b?source=collection_archive---------17-----------------------#2022-01-25">https://betterprogramming.pub/a-look-at-javascript-closures-6de9b9ac4f8b?source=collection_archive---------17-----------------------#2022-01-25</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="3d23" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">理解闭包在其生命周期中是如何工作的</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/73d3c746a32f443252de6c939bc7e100.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*QHaO2Ggad-UsTUWFxw35bQ.jpeg"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">关闭</p></figure><p id="0c19" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">在我们之前的博客文章中，我们已经看到使用块范围的变量而不是函数范围的变量是维护代码的更准确的方法。</p><p id="86d5" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">我们可能会无意中改变用函数作用域定义的变量的值，而没有意识到这一点。所以我们不应该在外部函数中改变内部函数中定义的变量。</p><p id="496c" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">这就是终结发挥作用的地方。闭包用于防止变量被外部函数访问。</p><p id="2593" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">为了更好地理解闭包在Javascript中是如何工作的，我推荐查看博客<a class="ae lr" rel="noopener ugc nofollow" target="_blank" href="/a-look-at-javascript-scopes-acb0f5e9cd77"><strong class="kx ir"><em class="ls">【Javascript作用域一览】</em> </strong> </a>和<a class="ae lr" rel="noopener ugc nofollow" target="_blank" href="/scope-closure-lexical-scope-9a18d0579d66"><strong class="kx ir"><em class="ls">【Javascript作用域和闭包——词法作用域一览】</em> </strong> </a></p><h1 id="4249" class="lt lu iq bd lv lw lx ly lz ma mb mc md jw me jx mf jz mg ka mh kc mi kd mj mk bi translated">内容</h1><ul class=""><li id="b95d" class="ml mm iq kx b ky mn lb mo le mp li mq lm mr lq ms mt mu mv bi translated">什么是闭包？</li><li id="8ea0" class="ml mm iq kx b ky mw lb mx le my li mz lm na lq ms mt mu mv bi translated">闭包生命周期</li><li id="a1f8" class="ml mm iq kx b ky mw lb mx le my li mz lm na lq ms mt mu mv bi translated">为什么关闭</li></ul><h1 id="095f" class="lt lu iq bd lv lw lx ly lz ma mb mc md jw me jx mf jz mg ka mh kc mi kd mj mk bi translated">什么是闭包？</h1><p id="55de" class="pw-post-body-paragraph kv kw iq kx b ky mn jr la lb mo ju ld le nb lg lh li nc lk ll lm nd lo lp lq ij bi translated">闭包是函数的行为。无论是在对象上还是在类上，都没有任何形式的闭包。简而言之，只有函数有闭包。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ne nf l"/></div></figure><p id="5868" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">让我们继续上面的代码示例，以便更好地理解闭包。简单看一下上面的例子。</p><p id="2e01" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">每次调用<code class="fe ng nh ni nj b">employeeCreator</code>函数时，不应该期望<code class="fe ng nh ni nj b">id</code>变量为0吗？但是每次调用<code class="fe ng nh ni nj b">employeeCreator</code>函数时，它返回的值都比前一个值多1。那为什么呢？答案:闭包。</p><p id="549f" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">每次调用函数时，垃圾收集器都必须移除该变量。在这里，垃圾收集器不会删除该值，引用仍然存在。因此，变量I是从引用中读取的，而不是在每次调用函数时被重新定义。</p><p id="573f" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">如果引用被垃圾收集器删除了会怎么样？如果没有闭包并且引用被垃圾收集器删除，那么由<code class="fe ng nh ni nj b">employee</code>、<code class="fe ng nh ni nj b">employee2</code>、<code class="fe ng nh ni nj b">employee3</code>变量调用的<code class="fe ng nh ni nj b">employeeCreator</code>函数的引用将被删除，因此这三个变量的值将是未定义的。</p><h1 id="11d5" class="lt lu iq bd lv lw lx ly lz ma mb mc md jw me jx mf jz mg ka mh kc mi kd mj mk bi translated">闭包生命周期</h1><p id="9f0c" class="pw-post-body-paragraph kv kw iq kx b ky mn jr la lb mo ju ld le nb lg lh li nc lk ll lm nd lo lp lq ij bi translated">当且仅当对函数的引用被删除时，绑定到该函数的作用域才会被破坏。</p><p id="dd74" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">没有被GC清除的闭包会累积并导致内存使用失控。</p><p id="1ebf" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">不使用的闭包必须从应用程序中清除。</p><p id="b5de" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">闭包的清理是影响应用程序性能的一个重要标准。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ne nf l"/></div></figure><p id="d373" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated"><code class="fe ng nh ni nj b">changeInputEvents</code>函数是以输入元素为参数，返回函数的函数。它在返回的函数中接受一个参数，这个参数就是一个函数。</p><p id="1c64" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">如果在调用此函数时将方法作为参数给出，它会将此方法添加到已定义输入的change事件中。</p><p id="bd88" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">如果在没有给定任何参数的情况下触发该函数，它将清除输入的change事件中的所有方法。</p><p id="de3e" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">如果在上面代码片段的第34行中没有用空参数触发函数，那么我们程序中的垃圾收集器就不会清除这两个函数的引用，所以它会占用不必要的内存。</p><h1 id="8b98" class="lt lu iq bd lv lw lx ly lz ma mb mc md jw me jx mf jz mg ka mh kc mi kd mj mk bi translated">为什么要关闭？</h1><p id="5e07" class="pw-post-body-paragraph kv kw iq kx b ky mn jr la lb mo ju ld le nb lg lh li nc lk ll lm nd lo lp lq ij bi translated">到目前为止，我们已经了解了闭包是什么以及它们是如何工作的。</p><p id="71e2" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">那么我们为什么需要闭包呢？闭包给了我们什么？</p><p id="3283" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">让我们快速看一个例子。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ne nf l"/></div></figure><p id="34a1" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">这里，第1行到第9行和第10行到第20行这两个方法执行相同的操作。</p><p id="fa46" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">首先，我们从第一部分开始。在<code class="fe ng nh ni nj b">DisplayText</code>函数中选择一个<code class="fe ng nh ni nj b">id</code>为<code class="fe ng nh ni nj b">displayArea</code>的元素，然后打印出<code class="fe ng nh ni nj b">innerText</code>值在函数参数中的文本值。</p><p id="e961" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">如该函数所示，执行了两个操作。让我们在DOM中找到一个元素，然后改变元素的<code class="fe ng nh ni nj b">innerText</code>。每次触发该功能时，都会发生这两个步骤。</p><p id="fa9c" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">那么我们真的需要每次都选择相同的元素吗？反正每次不都是选同一个元素吗？而且，如果我阻止删除这个值的引用(如果我不需要再次选择它)，我不会在性能方面加强程序吗？</p><p id="a8c3" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">第二部分，有一个函数叫做<code class="fe ng nh ni nj b">manageDisplayText</code>，它首先在DOM中选择一个元素，然后返回一个函数。这里找到的函数接受文本参数，并将参数中的值打印到DOM中所选元素的<code class="fe ng nh ni nj b">innerText</code>中。</p><p id="9713" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">虽然其功能相同，但第二部分中的功能更有效。因为第一次触发<code class="fe ng nh ni nj b">showText</code>功能的时候，heading变量是被创建的，并没有被删除。第二次触发<code class="fe ng nh ni nj b">showText</code>时，航向值已经存在，只有方法的<code class="fe ng nh ni nj b">innerText</code>变化起作用。</p></div><div class="ab cl nk nl hu nm" role="separator"><span class="nn bw bk no np nq"/><span class="nn bw bk no np nq"/><span class="nn bw bk no np"/></div><div class="ij ik il im in"><p id="d64f" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">感谢阅读。</p></div></div>    
</body>
</html>