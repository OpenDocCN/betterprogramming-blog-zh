<html>
<head>
<title>Android Data Binding With MVVM: Using LiveData and ViewModel</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">与MVVM的Android数据绑定:使用LiveData和ViewModel</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/android-data-binding-with-mvvm-using-livedata-and-viewmodel-71028901e3bb?source=collection_archive---------2-----------------------#2021-03-02">https://betterprogramming.pub/android-data-binding-with-mvvm-using-livedata-and-viewmodel-71028901e3bb?source=collection_archive---------2-----------------------#2021-03-02</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="0cc6" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">构建基于MVVM架构的应用程序指南</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/16a46a57c421d16f84fbbc6877b61ff9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*AK6Jhj7aZ8GtPWAF"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">照片由<a class="ae ky" href="https://unsplash.com/@firmbee?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">威廉·艾文</a>在<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄。</p></figure><p id="10d7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这是系列文章的第二部分<a class="ae ky" rel="noopener ugc nofollow" target="_blank" href="/android-2-way-data-binding-with-mvvm-c13022a2f04a">，在这个系列文章中，您将学习数据绑定基础知识，以及如何将数据绑定用于像<code class="fe lv lw lx ly b">LiveData</code>和<code class="fe lv lw lx ly b">ViewModel</code>这样的架构组件。在今天的文章中，您将学习如何使用<code class="fe lv lw lx ly b">LiveData</code>通过数据绑定更新UI，将<code class="fe lv lw lx ly b">ViewModel</code>作为数据源。</a></p></div><div class="ab cl lz ma hx mb" role="separator"><span class="mc bw bk md me mf"/><span class="mc bw bk md me mf"/><span class="mc bw bk md me"/></div><div class="im in io ip iq"><h1 id="96b0" class="mg mh it bd mi mj mk ml mm mn mo mp mq jz mr ka ms kc mt kd mu kf mv kg mw mx bi translated">介绍</h1><h2 id="42cd" class="my mh it bd mi mz na dn mm nb nc dp mq li nd ne ms lm nf ng mu lq nh ni mw nj bi translated">数据绑定</h2><p id="601b" class="pw-post-body-paragraph kz la it lb b lc nk ju le lf nl jx lh li nm lk ll lm nn lo lp lq no ls lt lu im bi translated">数据绑定是一个框架，它通过减少开发人员需要编写的样板代码来充当布局和数据源之间的桥梁。这将提高开发人员的生产力，让他们有时间专注于重要的事情。</p><p id="6f3a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果您是数据绑定的新手，我建议您阅读下面的文章和本系列的第一部分。今天的文章是关于如何在架构中使用数据绑定。要理解这一点，你应该做好基础工作。</p><div class="np nq gp gr nr ns"><a href="https://sgkantamani.medium.com/data-binding-in-android-4ff7bba93a2c" rel="noopener follow" target="_blank"><div class="nt ab fo"><div class="nu ab nv cl cj nw"><h2 class="bd iu gy z fp nx fr fs ny fu fw is bi translated">Android中的数据绑定</h2><div class="nz l"><h3 class="bd b gy z fp nx fr fs ny fu fw dk translated">不再需要编程来更新UI并将事件链接到视图</h3></div><div class="oa l"><p class="bd b dl z fp nx fr fs ny fu fw dk translated">sgkantamani.medium.com</p></div></div><div class="ob l"><div class="oc l od oe of ob og ks ns"/></div></div></a></div><h2 id="de5b" class="my mh it bd mi mz na dn mm nb nc dp mq li nd ne ms lm nf ng mu lq nh ni mw nj bi translated">LiveData</h2><p id="aaa5" class="pw-post-body-paragraph kz la it lb b lc nk ju le lf nl jx lh li nm lk ll lm nn lo lp lq no ls lt lu im bi translated">简单来说，<code class="fe lv lw lx ly b">LiveData</code>是一个可观测的数据持有者类。这意味着它可以保存一组可以从其他Android组件(如<code class="fe lv lw lx ly b">Activities</code>、<code class="fe lv lw lx ly b">Fragments</code>和<code class="fe lv lw lx ly b">Services</code>)中观察到的数据。它是生命周期感知的，主要用于更新MVVM建筑项目中<code class="fe lv lw lx ly b">ViewModel</code>的UI。要了解更多关于<code class="fe lv lw lx ly b">LiveData</code>的信息，请阅读以下文章:</p><div class="np nq gp gr nr ns"><a href="https://medium.com/android-dev-hacks/exploring-livedata-and-kotlin-flow-7c8d8e706324" rel="noopener follow" target="_blank"><div class="nt ab fo"><div class="nu ab nv cl cj nw"><h2 class="bd iu gy z fp nx fr fs ny fu fw is bi translated">探索LiveData和Kotlin流</h2><div class="nz l"><h3 class="bd b gy z fp nx fr fs ny fu fw dk translated">何时何地使用LiveData和Kotlin Flow</h3></div><div class="oa l"><p class="bd b dl z fp nx fr fs ny fu fw dk translated">medium.com</p></div></div><div class="ob l"><div class="oh l od oe of ob og ks ns"/></div></div></a></div><h2 id="df3e" class="my mh it bd mi mz na dn mm nb nc dp mq li nd ne ms lm nf ng mu lq nh ni mw nj bi translated">视图模型</h2><p id="b7ed" class="pw-post-body-paragraph kz la it lb b lc nk ju le lf nl jx lh li nm lk ll lm nn lo lp lq no ls lt lu im bi translated"><code class="fe lv lw lx ly b">ViewModel</code>是一个架构组件，用于使用MVVM实现Android应用。组件<code class="fe lv lw lx ly b">ViewModel</code>在Android开发中至关重要，因为它是生命周期感知的，并用于实现<em class="oi">关注点分离</em>原则。要了解更多信息，请阅读以下文章:</p><div class="np nq gp gr nr ns"><a href="https://medium.com/better-programming/best-practices-for-using-viewmodels-in-android-e986b25dc78f" rel="noopener follow" target="_blank"><div class="nt ab fo"><div class="nu ab nv cl cj nw"><h2 class="bd iu gy z fp nx fr fs ny fu fw is bi translated">在Android中使用视图模型的最佳实践</h2><div class="nz l"><h3 class="bd b gy z fp nx fr fs ny fu fw dk translated">如何正确设置和使用Java和Kotlin视图模型</h3></div><div class="oa l"><p class="bd b dl z fp nx fr fs ny fu fw dk translated">medium.com</p></div></div><div class="ob l"><div class="oj l od oe of ob og ks ns"/></div></div></a></div></div><div class="ab cl lz ma hx mb" role="separator"><span class="mc bw bk md me mf"/><span class="mc bw bk md me mf"/><span class="mc bw bk md me"/></div><div class="im in io ip iq"><h1 id="5ad2" class="mg mh it bd mi mj mk ml mm mn mo mp mq jz mr ka ms kc mt kd mu kf mv kg mw mx bi translated">履行</h1><p id="4d89" class="pw-post-body-paragraph kz la it lb b lc nk ju le lf nl jx lh li nm lk ll lm nn lo lp lq no ls lt lu im bi translated">让我们继续本系列前一部分中使用的例子。在第1部分中，我们直接将<code class="fe lv lw lx ly b">Activity</code>中的<code class="fe lv lw lx ly b">UserModel</code>作为数据源导入绑定。在这一部分，我们将创建一个<code class="fe lv lw lx ly b">ViewModel</code>，并从<code class="fe lv lw lx ly b">ViewModel</code>实例中访问<code class="fe lv lw lx ly b">UserModel</code>。</p><p id="ff9f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">首先，让我们创建一个<code class="fe lv lw lx ly b">ViewModel</code>并在其中包含一个<code class="fe lv lw lx ly b">UserModel</code>实例作为变量。看一看:</p><pre class="kj kk kl km gt ok ly ol om aw on bi"><span id="f45c" class="my mh it ly b gy oo op l oq or">class <strong class="ly iu">UserViewModel </strong>: ViewModel() {<br/><br/>    <strong class="ly iu">var userModel : UserModel = UserModel()</strong><br/>    <br/>}</span></pre><p id="d62f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">接下来，我们需要在布局中将数据源从<code class="fe lv lw lx ly b">UserModel</code>更改为<code class="fe lv lw lx ly b">ViewModel</code>。然后访问<code class="fe lv lw lx ly b">ViewModel</code>中的<code class="fe lv lw lx ly b">usermodel</code>实例:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="os ot l"/></div></figure><p id="ca20" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">此时，代码工作正常。就可以毫无疑问的推向生产了吧？</p><p id="a920" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">或者有什么我们可以做得更好的吗？</p><p id="d2c2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">答案是肯定的——我们可以做得更好。还记得我们在本系列第一部分中用来优化代码的<code class="fe lv lw lx ly b">ObservableFields</code>吗？让我们来看看:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="os ot l"/></div></figure><p id="d9ce" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">每次创建一个数据类的工作量非常大。Kotlin数据类应该让我们的生活变得更好，所以不要把它们复杂化。我们只是将变量的数据类型改为<code class="fe lv lw lx ly b">String</code>而不是<code class="fe lv lw lx ly b">ObservableField&lt;String&gt;</code>:</p><pre class="kj kk kl km gt ok ly ol om aw on bi"><span id="8f7c" class="my mh it ly b gy oo op l oq or">data class UserModel (var name: <strong class="ly iu">String </strong>="" ,<br/>                 var email: <strong class="ly iu">String </strong>= "")</span></pre><p id="46bb" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">通过将数据类型从<code class="fe lv lw lx ly b">ObservableField&lt;String&gt;</code>更改为<code class="fe lv lw lx ly b">String</code>，我们消除了变量的可见性。为了恢复能力，我们将使用<code class="fe lv lw lx ly b">LiveData</code>。</p><p id="07f0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们需要将<code class="fe lv lw lx ly b">usermodel</code>变量转换成<code class="fe lv lw lx ly b">UserModel</code>类型的<code class="fe lv lw lx ly b">LiveData</code>，如下所示:</p><pre class="kj kk kl km gt ok ly ol om aw on bi"><span id="59d9" class="my mh it ly b gy oo op l oq or">class UserViewModel : ViewModel() {<br/><br/>    var userModel  = <strong class="ly iu">MutableLiveData&lt;UserModel&gt;()</strong><br/><br/>}</span></pre><p id="6217" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">仅此而已。您不需要在布局文件中做任何事情。一切都将由幕后的数据绑定框架来处理。现在有了<code class="fe lv lw lx ly b">LiveData</code>功能，当应用程序在后台运行时，用户界面更新将是生命周期感知的，无需使用系统资源。</p></div><div class="ab cl lz ma hx mb" role="separator"><span class="mc bw bk md me mf"/><span class="mc bw bk md me mf"/><span class="mc bw bk md me"/></div><div class="im in io ip iq"><h1 id="3274" class="mg mh it bd mi mj mk ml mm mn mo mp mq jz mr ka ms kc mt kd mu kf mv kg mw mx bi translated">将数据分配给绑定</h1><p id="d356" class="pw-post-body-paragraph kz la it lb b lc nk ju le lf nl jx lh li nm lk ll lm nn lo lp lq no ls lt lu im bi translated">现在我们需要根据您的选择创建一个<code class="fe lv lw lx ly b">Activity</code> / <code class="fe lv lw lx ly b">Fragment</code>，然后通过生成的数据绑定布局类来扩展布局。看一看:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="os ot l"/></div></figure><p id="0fc5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">接下来，我们需要创建一个<code class="fe lv lw lx ly b">ViewModel</code>的实例，并将其添加到绑定变量，这样<code class="fe lv lw lx ly b">ViewModel</code>中的数据将绑定到布局:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="os ot l"/></div></figure><p id="03dc" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在你有了一个使用<code class="fe lv lw lx ly b">ViewModel</code>、<code class="fe lv lw lx ly b">LiveData</code>和数据绑定的应用程序。只要看看遵循这种模式，您需要编写的样板代码会减少多少。活动中没有<code class="fe lv lw lx ly b">LiveData</code>可观察项，我们不再需要手动给视图赋值，也不需要编写点击监听器，等等。</p></div><div class="ab cl lz ma hx mb" role="separator"><span class="mc bw bk md me mf"/><span class="mc bw bk md me mf"/><span class="mc bw bk md me"/></div><div class="im in io ip iq"><h1 id="ac1e" class="mg mh it bd mi mj mk ml mm mn mo mp mq jz mr ka ms kc mt kd mu kf mv kg mw mx bi translated">奖金</h1><p id="ef31" class="pw-post-body-paragraph kz la it lb b lc nk ju le lf nl jx lh li nm lk ll lm nn lo lp lq no ls lt lu im bi translated">要了解有关Android高级开发的更多信息，请阅读以下文章:</p><ul class=""><li id="57bc" class="ou ov it lb b lc ld lf lg li ow lm ox lq oy lu oz pa pb pc bi translated"><a class="ae ky" href="https://medium.com/better-programming/android-recyclerview-with-kotlin-sealed-classes-6d2985aac3e5" rel="noopener">“Android recycler view With kot Lin密封类”</a></li><li id="3a4d" class="ou ov it lb b lc pd lf pe li pf lm pg lq ph lu oz pa pb pc bi translated"><a class="ae ky" href="https://medium.com/better-programming/use-android-build-variants-to-manage-server-environments-146125ae31d2" rel="noopener">“使用Android构建变体管理服务器环境”</a></li><li id="9825" class="ou ov it lb b lc pd lf pe li pf lm pg lq ph lu oz pa pb pc bi translated"><a class="ae ky" href="https://medium.com/better-programming/gradle-dependency-management-with-buildsrc-and-kotlin-dsl-1de958eab166" rel="noopener">“使用BuildSrc和Kotlin DSL进行梯度依赖管理”</a></li><li id="e55b" class="ou ov it lb b lc pd lf pe li pf lm pg lq ph lu oz pa pb pc bi translated"><a class="ae ky" href="https://medium.com/better-programming/the-evolution-of-view-linking-in-android-d6219678740d" rel="noopener">“Android中视图链接的演变”</a></li></ul><p id="8191" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">目前就这些。希望你学到了有用的东西。感谢阅读。</p></div></div>    
</body>
</html>