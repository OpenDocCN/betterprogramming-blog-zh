<html>
<head>
<title>Build a Tetris Game Using SwiftUI</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用SwiftUI构建一个俄罗斯方块游戏</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/build-a-tetris-game-using-swiftui-c8c9b1722259?source=collection_archive---------3-----------------------#2022-09-16">https://betterprogramming.pub/build-a-tetris-game-using-swiftui-c8c9b1722259?source=collection_archive---------3-----------------------#2022-09-16</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="3ec6" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">用代码创建你自己版本的经典游戏</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/4e1bdd872d602468da69b13886fc6d36.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*YibtraPpMnxijjkkhLYf_g.gif"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">标准俄罗斯方块的动画</p></figure><p id="5c73" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">1979年，阿莱克西·帕杰诺夫创造了一个游戏，他称之为俄罗斯方块。这款游戏将成为2D的经典之作，拥有庞大的追随者，至今仍活跃在人们的视野中。一个有着巨大编码挑战的游戏。请和我一起尝试使用SwiftUI构建俄罗斯方块。</p><h1 id="416f" class="lu lv it bd lw lx ly lz ma mb mc md me jz mf ka mg kc mh kd mi kf mj kg mk ml bi translated">游戏部分</h1><p id="c52f" class="pw-post-body-paragraph ky kz it la b lb mm ju ld le mn jx lg lh mo lj lk ll mp ln lo lp mq lr ls lt im bi translated">bon——那么这个游戏的规则是什么——这是最基本的；不同形状的方块出现在屏幕的顶部，然后慢慢落到底部。玩家可以旋转并向左或向右移动砖块，这样当他们到达那里时，他们将会组合在一起。</p><p id="dac4" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">当玩家完成一行时，它会消失，降低它上面的所有方块。游戏的目标是确保方块线永远不会到达屏幕顶部。官方的[维基百科]方块形状是这样的。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi mr"><img src="../Images/934c11a05c29c783ba9c2b9af9a90bdf.png" data-original-src="https://miro.medium.com/v2/resize:fit:440/format:webp/1*BaE_rd9d8xkGJF4gqzRvvg.png"/></div></figure><h1 id="e46f" class="lu lv it bd lw lx ly lz ma mb mc md me jz mf ka mg kc mh kd mi kf mj kg mk ml bi translated">旅行</h1><p id="22be" class="pw-post-body-paragraph ky kz it la b lb mm ju ld le mn jx lg lh mo lj lk ll mp ln lo lp mq lr ls lt im bi translated">当你阅读这篇文章时，请注意；解决方案需要几经周折；在你复制任何东西之前，阅读所有的东西。</p><h1 id="7422" class="lu lv it bd lw lx ly lz ma mb mc md me jz mf ka mg kc mh kd mi kf mj kg mk ml bi translated">细胞</h1><p id="63a0" class="pw-post-body-paragraph ky kz it la b lb mm ju ld le mn jx lg lh mo lj lk ll mp ln lo lp mq lr ls lt im bi translated">我从一个简单的SwiftUI网格开始，网格有128个单元——横向8个单元，纵向16个单元。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ms"><img src="../Images/5445fcf60572d70c96971e86b7c09df0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*F5auqptsWwTzQqWXhuPNbQ.gif"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">几乎是SwiftUI下运行的connect-4的游戏</p></figure><p id="6e60" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">细胞的颜色是通过一条信息来管理的，这条信息表示细胞变成了红色。</p><p id="e4df" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">单元本身将在半秒钟后变回原样，除非在消息中明确告知不要这样做。</p><p id="f0d5" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">一个计时器管理消息的触发，一个数组跟踪每行的最后一个单元格。</p><p id="174c" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">除了自动操作之外，我还在代码中添加了一个拖动手势，我在这里使用它来更改激活的单元格传递下来的列。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mt mu l"/></div></figure><h2 id="ff1f" class="mv lv it bd lw mw mx dn ma my mz dp me lh na nb mg ll nc nd mi lp ne nf mk ng bi translated">线</h2><p id="be99" class="pw-post-body-paragraph ky kz it la b lb mm ju ld le mn jx lg lh mo lj lk ll mp ln lo lp mq lr ls lt im bi translated">粘合-下一阶段是检测和移除完成线。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/6c52b1336ccaba3db0b7f9663811d4c6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*GWQBr0YA-x_GsM5gXKiS4A.gif"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">一个动画GIF展示了俄罗斯方块的取消</p></figure><p id="a163" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">我放大了一点，并改变了输出，以使发生的事情更加明显。现在，每个块都有一个显示其索引和值的标签。一旦不再是基本单元格，黑色单元格编号线就会变为蓝色。</p><p id="fd33" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">将所有盒子下移一格并改变黑/蓝市场的代码如下所示。</p><pre class="kj kk kl km gt nh ni nj nk aw nl bi"><span id="8255" class="mv lv it ni b gy nm nn l no np">for i in stride(from: 119, through: 0, by: -1) {<br/>  blocks[i + 8] = blocks[i]<br/>}</span><span id="91da" class="mv lv it ni b gy nq nn l no np">for i in 0...7 {<br/>  if lastLine[i] &lt; 120 {<br/>    lastLine[i] += 8<br/>  }<br/>}<br/>c2hanger.send()</span></pre><p id="fc56" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">这里的最后一条指令是<code class="fe nr ns nt ni b">passthroughSubject</code>，它触发了单元结构中的这一行简单的代码。</p><pre class="kj kk kl km gt nh ni nj nk aw nl bi"><span id="f155" class="mv lv it ni b gy nm nn l no np">.onReceive(c2hanger, perform: { _ in<br/>  color = blocks[item]<br/>}</span></pre><p id="57a9" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">我改变了我如何管理瓷砖，因为我把第二阶段在一起。在最初的构建中，我使用了一个passthrough主题来改变磁贴的颜色，用消息来寻址各个磁贴。这是一个扩展性不好的解决方案，如果我试图在一个紧凑的循环中改变所有128个图块，就会丢失图块。在第二版中，我使由组合消息触发的动作尽可能短，首先改变数据库，然后改变显示。</p><h1 id="87c6" class="lu lv it bd lw lx ly lz ma mb mc md me jz mf ka mg kc mh kd mi kf mj kg mk ml bi translated">重新启动</h1><p id="1a98" class="pw-post-body-paragraph ky kz it la b lb mm ju ld le mn jx lg lh mo lj lk ll mp ln lo lp mq lr ls lt im bi translated">整个事情感觉就像我在用汇编语言写它；当然，我可以使用SwiftUI原语，如rotate。</p><p id="9d52" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">我回到绘图板，从不同的角度来看解决这个问题。请注意，正如我所做的，“官方设置”都是由四个正方形组成的，这不是巧合；我敢说——也许是我建造它所需要的代码的线索。</p><h2 id="e2fc" class="mv lv it bd lw mw mx dn ma my mz dp me lh na nb mg ll nc nd mi lp ne nf mk ng bi translated">结构</h2><p id="d5bb" class="pw-post-body-paragraph ky kz it la b lb mm ju ld le mn jx lg lh mo lj lk ll mp ln lo lp mq lr ls lt im bi translated">我使用几何阅读器重新起草了一个新项目，在其中添加了一组俄罗斯方块形状。<br/>这是第一稿的动画GIF。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/52b68e8b5bf87fa119467739a1906c10.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*NotSumQWOoR-SafRfDJsow.gif"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">重新启动显示俄罗斯方块的形状，一项工作正在进行中</p></figure><p id="0d5c" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">我使用网格作为我的形状动画点的数据库。既然我现在有了形状，我就可以用SwiftUI <code class="fe nr ns nt ni b">rotateEffect</code>来做这件事。它解决了我在第一次实现时面临的一个主要难题。</p><p id="1811" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">现在有了一系列新的问题——排列和堆叠。最明显的问题看起来像对齐。没有一个形状相互对齐；真是一团糟。在开始这段代码之前，我就应该看到这一点。</p><h2 id="1d06" class="mv lv it bd lw mw mx dn ma my mz dp me lh na nb mg ll nc nd mi lp ne nf mk ng bi translated">对齐形状</h2><p id="ff77" class="pw-post-body-paragraph ky kz it la b lb mm ju ld le mn jx lg lh mo lj lk ll mp ln lo lp mq lr ls lt im bi translated">我写了一整篇文章来介绍我在这里使用的解决方案:SwiftUI中的对齐参考线和框架。我首先关注的是<code class="fe nr ns nt ni b">ZStack</code>，以及一个支架。</p><p id="5597" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">然后我给每个形状添加了一条边。这里用红色显示了一个结构。效果很好。现在所有的形状都一样大，并且在网格的底部互相对齐。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/e8f85712a1d682c2126e17528408995d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*kMEvFUndZwZsGYr3K6HwJQ.gif"/></div></div></figure><p id="7775" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">但是，一如既往，细节决定成败。正如你从这一系列图像中看到的，旋转图形产生了新的挑战。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi nu"><img src="../Images/b04c2ba7ac94ec4cc5993d6880e6cf4a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1364/format:webp/1*W2i6atm2J5_dfFMZMqG6aA.png"/></div></figure><p id="5302" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">青色块是最有问题的。当我旋转青色方块时，它们无法在底部排成一行。</p><p id="1126" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">第二张图片显示了最糟糕的违规者，它与其他物体发生了碰撞。</p><p id="cb1e" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">在这个特殊形状的例子中，在一次旋转中也有大量的运动，这是第二个问题，当你从左向右旋转它时，有效地穿过两个街区。</p><p id="f9ea" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">作为一个坚忍不拔的人，我一直保持低调，用更多的SwiftUI对齐方式解决了这个挑战，将形状从左边移到中间，从高到低。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/a2789d854202e06db8e53d52f30a16bd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*Fbfww-HZ7Cgc7S3SZxQUkA.gif"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">添加SwiftUI对齐后的青色形状。</p></figure><p id="7ff7" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">看起来好像我赢了，直到我试着排列下一个形状，紫色的。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/0c37c97bc8408ea5e323d521b5a276cc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*9xIFfIK0YqRsyxxLrkg6dQ.gif"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">紫色的形状(在我使用任何代码尝试对齐它之前)。</p></figure><p id="4e5c" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">这是相当具有挑战性的，因为不像我在一条边上对齐图像的那条线，将所有形状对齐到一个边界是行不通的，因为它改变了正方形的排列。我必须在两个水平和垂直平面上对齐它——这是一项定制对齐的工作。</p><h2 id="9ccb" class="mv lv it bd lw mw mx dn ma my mz dp me lh na nb mg ll nc nd mi lp ne nf mk ng bi translated">变化</h2><p id="1e14" class="pw-post-body-paragraph ky kz it la b lb mm ju ld le mn jx lg lh mo lj lk ll mp ln lo lp mq lr ls lt im bi translated">当我想出如何对我的紫色形状进行更复杂的对齐时，我突然意识到，改变我一直小心对齐的形状的要求是我没有足够仔细考虑的下一个挑战。我需要把青色的形状变短，所以我有三个版本。紫色的形状可能会失去一个方块，一个双方块，甚至所有三个方块。他们都不一样。呀！</p><p id="f82d" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">我需要设计一种方法，使每个形状中的单个方块可消耗，而不仅仅是不可见。这样做无疑意味着我将不得不重新审视我刚刚实施的校准解决方案——我已经向前迈了一步，又向后退了两步。</p><p id="0a09" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">这个版本变成了一个大白象，是吗？</p><h2 id="5915" class="mv lv it bd lw mw mx dn ma my mz dp me lh na nb mg ll nc nd mi lp ne nf mk ng bi translated">重新想象</h2><p id="58f2" class="pw-post-body-paragraph ky kz it la b lb mm ju ld le mn jx lg lh mo lj lk ll mp ln lo lp mq lr ls lt im bi translated">考虑到这个问题和解决方案，我决定在更大范围内使用自定义对齐。正如我对第一个版本所做的那样，我将把整个东西建立在正方形的基础上，而不是形状。广场，我会使用自定义对齐定位，所以第一个和第二个版本的混合。</p><h1 id="5afe" class="lu lv it bd lw lx ly lz ma mb mc md me jz mf ka mg kc mh kd mi kf mj kg mk ml bi translated">最终实施</h1><p id="889b" class="pw-post-body-paragraph ky kz it la b lb mm ju ld le mn jx lg lh mo lj lk ll mp ln lo lp mq lr ls lt im bi translated">我从定制代码开始对齐形状，这一次，集中在用一个正方形和一个形状完成所有需求；仅此而已——所有要求。</p><ul class=""><li id="eca5" class="nv nw it la b lb lc le lf lh nx ll ny lp nz lt oa ob oc od bi translated">为了能够在屏幕上缓慢移动一个或多个方格</li><li id="8565" class="nv nw it la b lb oe le of lh og ll oh lp oi lt oa ob oc od bi translated">为了能够根据命令向左或向右移动所述方块</li><li id="b231" class="nv nw it la b lb oe le of lh og ll oh lp oi lt oa ob oc od bi translated">能够创建一个可寻址的方块集合来组成不同的形状</li><li id="c27f" class="nv nw it la b lb oe le of lh og ll oh lp oi lt oa ob oc od bi translated">以四种不同的配置旋转所述形状，而不重建所述形状。</li><li id="c58f" class="nv nw it la b lb oe le of lh og ll oh lp oi lt oa ob oc od bi translated">能够找到一个正方形或直线并让它消失</li><li id="744b" class="nv nw it la b lb oe le of lh og ll oh lp oi lt oa ob oc od bi translated">重新排列剩下的积木，没有太多的痛苦。</li></ul><p id="3719" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">我怀疑我可以用大量的代码和调整来完成第一个版本的需求——我希望我可以用更少的代码使用alignment来完成这些需求。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/0192b0eb1185d740f080c0afb3faa7a5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*RDzj_5b4kiY6BptiCVQTKw.gif"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">旋转形状的示例</p></figure><p id="970b" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">我画了一个正方形，在这个正方形内我会排列几十个小得多的正方形。我创造的每个形状都是由四个小方块组成的；一组自定义对齐控制着它们的位置。</p><p id="3a76" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">我为每个形状编写了自定义布局，就像我在第一个版本中一样。然后，我需要改变多达四个额外的设置时，所说的形状旋转布局。这是我在代码中的做法。</p><p id="e872" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">我通过给方块编号使工作变得更容易；如GIF所示，这些图形反映了它们在数组块中的位置。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mt mu l"/></div></figure><p id="2eef" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">当然，当我旋转图形时，我需要担心与其他方块冲突的方块也发生了变化。因此，我必须在代码中添加额外的规则来考虑这一点。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/11986191756470ab7e725e0a37dd2850.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*H2EEcNHrbAjFCEaKl2NQ7A.gif"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">正在进行的最后一场比赛</p></figure><p id="6af5" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">我用高亮显示的瓷砖标出我编码的形状，使这项工作变得更容易，这里用浅红色显示。</p><p id="8596" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">最后，我组装了一个各种各样的“机器人”来查看我的数据库中已完成的线条，添加代码将它们更改为空容器(我第一次使用它们时)，并更改其余形状的对齐规则。</p><p id="0d71" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">我对最终的解决方案很满意。它可以在纵向或横向模式下[动态]与您的设备配合使用，并且可以轻松更新以适应不同大小的设备。在我结束之前，这里有一个SwiftUI中单个俄罗斯方块的截图。以及那些自定义的对齐方式，以使其处于受控状态。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mt mu l"/></div></figure><h1 id="a572" class="lu lv it bd lw lx ly lz ma mb mc md me jz mf ka mg kc mh kd mi kf mj kg mk ml bi translated">结论</h1><p id="e97b" class="pw-post-body-paragraph ky kz it la b lb mm ju ld le mn jx lg lh mo lj lk ll mp ln lo lp mq lr ls lt im bi translated">这是一个漫长而艰难的旅程，最终我设法制作了我自己的俄罗斯方块。事实上，在这个过程中，我甚至有了一些关于如何更新游戏来创造新挑战的想法。</p></div></div>    
</body>
</html>