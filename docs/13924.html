<html>
<head>
<title>Creating Custom Higher-Order Functions Can Help You Write More Abstract Swift Code</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">创建定制的高阶函数可以帮助你编写更抽象的Swift代码</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/creating-custom-higher-order-functions-can-help-you-write-more-abstract-swift-code-b0158793300e?source=collection_archive---------5-----------------------#2022-10-14">https://betterprogramming.pub/creating-custom-higher-order-functions-can-help-you-write-more-abstract-swift-code-b0158793300e?source=collection_archive---------5-----------------------#2022-10-14</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="b62f" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">通过发明基于标准基础库的新的数组转换方法来改进您的SDK</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/84a6fefd850a9035d084e3c6ffd4ba6b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*pxFerRimRO1khStCWOTGsw.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">作者图片</p></figure><p id="d157" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">假设我们的一个应用程序屏幕上有一个普通的表格视图。这个表视图的单元格包含两个标签:一个反映用户名，另一个反映这个用户拥有的手机型号。由于将域模型与视图模型分离被认为是一个好的实践，我们已经创建了两个实体来满足我们的需求。下面是它们的样子:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="lr ls l"/></div></figure><p id="5ab7" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">因此，<code class="fe lt lu lv lw b">User</code>结构拥有我们需要的所有信息(是的，在现实生活中，它会有更多的属性，我知道)，而<code class="fe lt lu lv lw b">ViewModel</code>结构拥有细胞构建所需的属性。为了构建一个表格视图，我们需要一组<code class="fe lt lu lv lw b">ViewModel</code>对象。</p><p id="13f4" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">客户端的要求是只显示年龄超过21岁的用户。因此，我们需要根据年龄过滤用户，然后从每个剩余的<code class="fe lt lu lv lw b">User</code>中初始化一个<code class="fe lt lu lv lw b">ViewModel </code>。你会如何处理这种情况？让我猜猜，您将创建一个单独的函数，用于过滤一组用户并将其转换为一组视图模型，大致如下所示(方法可能有所不同):</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="lr ls l"/></div></figure><p id="a09b" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">看起来很安全。您正在传递一个以年龄作为谓词的用户数组，并且可以确保不显示小于21岁的用户。如果与此屏幕相关的业务需求保持不变，这种逻辑是完美的，但老实说，业务需求保持不变的频率有多高？</p><p id="0cc1" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">如果您的客户不仅要求按年龄过滤用户，还要求按他们拥有的手机型号过滤用户，该怎么办？或者，如果新的要求是只显示30岁以下的用户呢？</p><p id="e961" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">在我们的例子中，可能的谓词数量相对较少，所以向函数中添加一些参数可以解决这个问题。但是想象一下会有多乱。</p><p id="32da" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">为了保持功能的整洁和美观，您可以为每种情况指定一个单独的函数，并有一个方法列表来处理每个过滤选项，但是想象一下这些方法会有多少重复的代码。</p><p id="1625" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">如果重复代码被分离到一个函数中，第二种方法很好，但是如果我们有不止一个需要使用这种功能的类呢？在每个类中创建一个函数列表是正确的吗？不，不会的。抽象是这里的一个线索。</p><blockquote class="lx ly lz"><p id="8a19" class="kv kw ma kx b ky kz jr la lb lc ju ld mb lf lg lh mc lj lk ll md ln lo lp lq ij bi translated">关于抽象的几句话:</p><p id="04fd" class="kv kw ma kx b ky kz jr la lb lc ju ld mb lf lg lh mc lj lk ll md ln lo lp lq ij bi translated">“抽象是通过减少概念或可观察现象的信息内容进行概括的过程，通常是为了只保留与特定目的相关的信息。— <a class="ae me" href="https://www.newworldencyclopedia.org/entry/abstraction" rel="noopener ugc nofollow" target="_blank">新世界百科</a></p></blockquote><p id="8228" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">因此，为了使上面例子中的功能对多个类可用，我们需要将其抽象化。要做到这一点，我们需要“减少特定类别的信息内容”，并“只保留与特定目的相关的信息”。这种情况下的信息是一个方法实现，所以我们需要创建一个“与特定目的相关”的函数，也就是说，将返回一个排序和映射元素的数组。</p><p id="a149" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">如果我们想让任何类扩展一些与数组相关的功能，在Swift中我们做一种反转wy，提供一个具有这种功能的数组。</p><p id="a526" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">在我们的例子中，我们需要根据一些谓词从用户那里构建一个视图模型。因此，如果用户不满足某些要求，我们跳过它们。这意味着我们需要使用一个<code class="fe lt lu lv lw b">map()</code>函数来将<code class="fe lt lu lv lw b">User</code>转换成<code class="fe lt lu lv lw b">ViewModel</code>，但是我们如何进行过滤呢？编写一个定制的高阶<code class="fe lt lu lv lw b">mapif</code>函数会有所帮助:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="lr ls l"/></div></figure><p id="c5c5" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">现在，我们有了一个通用方法，它可以在任何可能的上下文中的任何数组上启动。它接受两个闭包，对数组的每个元素运行它们，并返回一个转换后的序列。看起来是这样的:</p><ul class=""><li id="0bfa" class="mf mg iq kx b ky kz lb lc le mh li mi lm mj lq mk ml mm mn bi translated"><code class="fe lt lu lv lw b">condition</code>类型“Element - &gt; Bool”的闭包接受某个元素，用该元素编译给定代码并返回一个布尔值</li><li id="036d" class="mf mg iq kx b ky mo lb mp le mq li mr lm ms lq mk ml mm mn bi translated"><code class="fe lt lu lv lw b">mappingAction</code>类型“Element - &gt; T”的闭包使用输入元素运行其代码，并返回另一个泛型类型的值<code class="fe lt lu lv lw b">T</code>。</li></ul><p id="15ac" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">函数内部的逻辑和SomeClass的'<code class="fe lt lu lv lw b">getViewModel</code>'函数的逻辑是一样的，只是所有的类型和实体都是抽象的。</p><p id="a8ed" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">我们的'<code class="fe lt lu lv lw b">mapif</code>'函数的当前用例是在[<code class="fe lt lu lv lw b">User</code>]数组上运行它，将用户转换为表视图数据源的[<code class="fe lt lu lv lw b">ViewModel</code>:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="lr ls l"/></div></figure><p id="c8a6" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">从现在开始，如果我们需要使用更多的谓词进行过滤，我们可以用更多的参数修改“条件”闭包。看起来是这样的:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="lr ls l"/></div></figure><p id="ff72" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">编写抽象代码可以使您的开发过程更容易、更快，因为您不必重复做同样的操作。但是重要的是要记住，在某些情况下可能不需要抽象，最好将功能封装在某个类中。</p><p id="51e6" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">基本上由你决定。经验法则是，如果你在两个不同的地方做同样的操作，并且这个操作的逻辑有同样的潜在变化的原因，那么最好把这样的逻辑抽象出来。</p></div></div>    
</body>
</html>