<html>
<head>
<title>Build Event Listeners in Swift</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">在Swift中构建事件监听器</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/event-listeners-on-swift-867a239bb23b?source=collection_archive---------5-----------------------#2020-02-20">https://betterprogramming.pub/event-listeners-on-swift-867a239bb23b?source=collection_archive---------5-----------------------#2020-02-20</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="92af" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">如何在不增加保留周期的情况下在iOS上设计事件监听器</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/f8bb211d6c3af283099a03e43adb32cd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*pknmv8-N1vPDD9tx"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">李·坎贝尔在<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的照片。</p></figure><p id="a67c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">今天，我们将讨论如何创建一个基于事件监听器的实现。这种实现将是无保留周期的。我还将简要描述事件监听器是如何工作的，以及为什么我们在实现它们时必须关注保留周期。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="1733" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">事件侦听器概述</h1><p id="e4a0" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">有时，您希望通知一个或多个对象某个事件已经发生。例如，可能是用户注销或登录了应用程序。这种事情可以通过使用委托轻松完成。一个对象实现一个协议，并成为用户身份验证状态的“监听器”。但是当不止一个对象想要监听用户auth状态时会发生什么呢？一个代表已经不够了。</p><p id="1c0d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">每当我们想要传播一个事件已经发生在每个人身上的信息时，我们可以使用几种方法。其中之一是通知。工作起来就像一个广播，通知所有的类关于你的事件，你可能只需要实现一个函数来接收通知。它们的问题是，操作系统会通知基本上所有的类关于你的事件。有时候，我们不想这样，因为额外的努力根本没有被利用。</p><p id="4044" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">除了其他可能性之外，每当我必须将一个事件通知给多个类并且使用通知没有意义时，我会考虑一个折中的办法:通知多个委托，并将这些委托称为侦听器。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="ec77" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">认证改变通知器</h1><p id="843b" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">假设我有一个名为<code class="fe mz na nb nc b">AuthManager</code>的类。我会说这个类是单例的，这样我们的例子就不那么复杂了。<code class="fe mz na nb nc b">AuthManager</code>有几个功能，包括<code class="fe mz na nb nc b">logIn(username: String, password: String)</code>和<code class="fe mz na nb nc b">logout()</code>。这是使这些事件发生的大部分逻辑所涉及的地方。听起来<code class="fe mz na nb nc b">AuthManager</code>不太适合通知其他对象用户的auth状态已经改变。</p><p id="32cb" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们可以想象我们可以要求<code class="fe mz na nb nc b">AuthManager</code>通知注册对象的授权状态的变化。要注册一个新对象，我们可以在<code class="fe mz na nb nc b">AuthManager</code>上调用一个函数，比如<code class="fe mz na nb nc b">addListener(_ listener: AuthChangeListener)</code>。什么是<code class="fe mz na nb nc b">AuthChangeListener</code>？这部分将像一个删除按钮。我们创建了一个协议，其中包含一些对监听者有用的方法。在这个简单的例子中，我们只有一个名为<code class="fe mz na nb nc b">authStateDidChange(isLogged: Bool)</code>的方法，我们将接收一个标志作为参数。此标志将指示用户是注销还是登录。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nd ne l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">授权更改侦听器的协议。无论是谁实现这个协议，都可以注册为授权更改的监听器。</p></figure><p id="f973" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在我们知道了我们的协议，让我们看看<code class="fe mz na nb nc b">addListener</code>的实现会是什么样子。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nd ne l"/></div></figure><p id="3e0a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">正如你在上面看到的，每当调用<code class="fe mz na nb nc b">addListener</code>时，我们就把那个监听器添加到我们保存在<code class="fe mz na nb nc b">AuthManager.</code> <strong class="lb iu"> <em class="nf"> </em> </strong>中的监听器私有列表中，这很简单。每当auth状态发生变化时，我们只需迭代侦听器列表，调用<code class="fe mz na nb nc b">authStateDidChange</code>函数。</p><p id="71ab" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果数组没有为它存储的对象保留一个强引用，这种方法将非常有效。我们正在创造一个保留周期。我们必须找到一种方法来保存一个引用，但是是一个弱引用。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="0af8" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">WeakReference类</h1><p id="2eaf" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">我在kot Lin<a class="ae ky" href="https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.native.ref/-weak-reference/index.html" rel="noopener ugc nofollow" target="_blank">的<code class="fe mz na nb nc b">WeakReference</code>中寻找灵感来创建一些东西，这些东西将保持我们对象的弱引用。我们也称它为<code class="fe mz na nb nc b">WeakReference</code>。它将在初始化器中接收一个值，这个值就是我们的对象。我们将把这个对象存储在一个弱变量中，如果它死了，就释放这个对象。这将完美地解决我们的问题。</a></p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nd ne l"/></div></figure><p id="31e7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们的解决方案简单易行，就像编码一样。现在就应用到我们的<code class="fe mz na nb nc b">AuthManager</code>上吧。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nd ne l"/></div></figure><p id="ee7d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在我们有了一个<code class="fe mz na nb nc b">AuthChangeListener</code>类型的<code class="fe mz na nb nc b">WeakReference</code>列表。当我们比较这个侦听器是否已经注册时，情况发生了变化:现在我们比较value，它是由<code class="fe mz na nb nc b">WeakReference</code>类保存的实际侦听器。为了添加到列表中，我们创建了一个新的<code class="fe mz na nb nc b">WeakReference</code>，在初始化器中传递监听器。最后，当通知我们的auth状态发生变化时，我们只需检查对象，调用它的value <strong class="lb iu"> </strong>属性。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="40f8" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">僵尸</h1><p id="237b" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">正如你所想象的，数组现在保留了一个对<code class="fe mz na nb nc b">WeakReference</code>的强引用，而不是我们的监听器对象。这是可以的，因为如果它们还活着，它不会对我们的记忆或者程序的行为产生大的影响。我喜欢做的一件事就是清理这些最终出现的僵尸<code class="fe mz na nb nc b">WeakReferences</code>。当通知更改或添加新的侦听器时，我会这样做。要移除所有僵尸，你只需从列表中移除所有值为<code class="fe mz na nb nc b">nil</code>的<code class="fe mz na nb nc b">WeakReferences</code>。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="f6e9" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">结论</h1><p id="7923" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">我希望你喜欢这首曲子。如果您有任何问题或发现实现中的错误，请留下评论。</p></div></div>    
</body>
</html>