<html>
<head>
<title>An Introduction to Writing Automated UI Tests With Selenium and C#</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">用Selenium和C#编写自动化UI测试的介绍</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/an-introduction-to-writing-automated-ui-tests-with-selenium-and-c-a58227000a8d?source=collection_archive---------10-----------------------#2022-11-17">https://betterprogramming.pub/an-introduction-to-writing-automated-ui-tests-with-selenium-and-c-a58227000a8d?source=collection_archive---------10-----------------------#2022-11-17</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="f812" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">一套精心制作的UI测试可以为您的应用程序提供额外的信任，所以我们将看看如何让您启动并运行</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/ff1105b5c9648925041fc8f5b97e4513.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*GKh2wnUqaEY1sgL7CORwcg.jpeg"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">在<a class="ae ky" href="https://unsplash.com/s/photos/robot?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的<a class="ae ky" href="https://unsplash.com/@thisisengineering?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> ThisisEngineering RAEng </a></p></figure><p id="5cd7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">测试你的软件是任何开发过程中至关重要的一部分，有无数种方法可以检查你的应用程序是否完全按照它们应该的那样运行。这些测试包括从小单元测试到长期运行的集成测试。</p><p id="43a7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">自动化用户界面(UI)测试只是一个例子，只要使用得当，它可以在特定的情况下帮助你。给定一套编写良好且经过深思熟虑的UI测试，您可以极大地增加开发生命周期中的信心，以确保一切按预期运行。</p><h2 id="00cc" class="lv lw it bd lx ly lz dn ma mb mc dp md li me mf mg lm mh mi mj lq mk ml mm mn bi translated">什么是自动化UI测试？</h2><p id="e3de" class="pw-post-body-paragraph kz la it lb b lc mo ju le lf mp jx lh li mq lk ll lm mr lo lp lq ms ls lt lu im bi translated">自动化UI测试是用代码编写的，这些代码使用您的用户会使用的相同界面来执行几个步骤。它使用实际的浏览器，行为方式与用户非常相似。想象一下，有一个机器人坐在浏览器前，你告诉它应该采取什么步骤，并报告它看到的任何不期望的事情。但是这个机器人超级快，100%专心，从来不会觉得无聊。</p><p id="44f3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">引入自动化UI测试的一个常见需求是减轻手动测试的负担。您可能有一个专门的测试团队，或者测试可能是开发人员职责的一部分——无论哪种方式，在某些时候，执行您想要(或需要)做的所有手动测试可能会变得太耗时。</p><p id="dc76" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">或者您可能想要加快发布新版本代码的速度，并且您发现您的手动测试时间是最大的瓶颈。在这种情况下，经常会听到“我们能自动化这些基本测试吗？”。通过这篇文章，我们将帮助您回答这个问题，并希望让您开始运行一些测试。</p><p id="f342" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">可以编写这些自动化的UI测试来做你想做的任何事情。如果你可以在浏览器中手动操作，你就可以自动操作并在测试中运行它。点击按钮并输入数据？没错。下载和检查文件？没错。与地图等复杂控件进行交互？没错。通过验证码？嗯……没有。但是你明白了。</p><p id="90a8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">然而，从更基本的测试开始你的自动化UI测试套件通常是一个好主意，这样你就可以对它们有所了解，并找到适合你、你的团队和你的应用程序的合适的覆盖率。</p><p id="9185" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">自动化UI测试有多种风格，可以用不同的语言和技术编写。我们将重点关注用C#和Selenium WebDriver编写的基于web的应用程序的测试，但是我们将讨论的很多内容将适用于不同的框架。</p><h1 id="684a" class="mt lw it bd lx mu mv mw ma mx my mz md jz na ka mg kc nb kd mj kf nc kg mm nd bi translated">测试用例和自动化UI测试</h1><p id="4a90" class="pw-post-body-paragraph kz la it lb b lc mo ju le lf mp jx lh li mq lk ll lm mr lo lp lq ms ls lt lu im bi translated">在陷入一些代码之前，测试用例是值得一提的。测试用例本质上是测试的定义。如果你有一个测试团队，你很可能会看到用于手工测试的测试用例。编写它们是为了定义需要测试的东西，并解释运行测试需要采取的步骤以及预期的结果。这些测试用例可以用来跟踪测试工作。任何失败的测试用例都将被标记出来，并且通常会提示开发人员创建一个bug，然后开发人员将对其进行处理。</p><p id="bf56" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">出于同样的原因，为你的自动化UI测试编写测试用例是非常有帮助的。虽然根据测试用例代码本身应该清楚测试的是什么，但如果不是每个人都能看到(并理解)代码，这是没有帮助的。随着自动化UI测试套件的数量和复杂性的增加，正确记录测试变得至关重要。因此，虽然在编写最初的几个测试时，您肯定不需要使用测试用例，但是当您想要将它们提升到下一个级别时，这是需要记住的。</p><p id="b33a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">理想情况下，您应该编写一个测试用例，然后编写自动化UI测试，并将两者联系在一起。在大多数情况下，您希望每个测试用例都有一个单独的测试，这样您就可以从这个测试用例中获得一个清晰的通过/失败结果。</p><h1 id="e998" class="mt lw it bd lx mu mv mw ma mx my mz md jz na ka mg kc nb kd mj kf nc kg mm nd bi translated">设置自动化UI测试项目</h1><p id="4045" class="pw-post-body-paragraph kz la it lb b lc mo ju le lf mp jx lh li mq lk ll lm mr lo lp lq ms ls lt lu im bi translated">好了，我们开始吧。</p><p id="b04a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们将使用C#和Selenium WedDriver，因此打开Visual Studio(或您的IDE)。</p><p id="3941" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">自动化UI测试是用与单元测试相同的技术编写的，所以如果你熟悉编写它们，很多看起来会非常相似。</p><p id="e9d2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">因此，创建一个新的单元测试项目。我用xUnit，你也可以用MSTest或者NUnit。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ne"><img src="../Images/081f5f4187ab2098973e59d1e5cf3faf.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*AnjKsmMN1ZqFZr-EC5aaOQ.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">在Visual Studio中创建新的xUnit项目</p></figure><p id="41be" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">然后，您需要添加几个NuGet包来获得Selenium WebDriver，包括以下内容:</p><p id="adae" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe nf ng nh ni b"><a class="ae ky" href="https://www.nuget.org/packages/Selenium.Support" rel="noopener ugc nofollow" target="_blank">Selenium.Support</a></code></p><p id="eaaa" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe nf ng nh ni b"><a class="ae ky" href="https://www.nuget.org/packages/Selenium.WebDriver.ChromeDriver/" rel="noopener ugc nofollow" target="_blank">Selenium.WebDriver.ChromeDriver</a></code></p><p id="86db" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">安装这些软件时，要注意你使用的是什么版本。ChromeDriver包尤其重要，因为它与运行测试的Chrome版本相关。幸运的是，你从Selenium得到的错误消息在这一点上非常清楚——如果你试图运行一个你的代码不是为之编写的Chrome版本，它会告诉你，通常你必须将NuGet包更新到最新版本。</p><p id="ca2c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">希望到现在为止，您已经有了一个空的单元测试。它可能如下所示:</p><pre class="kj kk kl km gt nj ni nk bn nl nm bi"><span id="f9ea" class="nn lw it ni b be no np l nq nr">namespace AutoTestDemo;<br/><br/>public class UnitTest1<br/>{<br/>    [Fact]<br/>    public void Test1()<br/>    {<br/>    }<br/>}</span></pre><p id="f947" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">太好了。现在，回到测试本身。</p><h1 id="7871" class="mt lw it bd lx mu mv mw ma mx my mz md jz na ka mg kc nb kd mj kf nc kg mm nd bi translated">规划自动化UI测试</h1><p id="e373" class="pw-post-body-paragraph kz la it lb b lc mo ju le lf mp jx lh li mq lk ll lm mr lo lp lq ms ls lt lu im bi translated">在开始编写代码之前，仔细考虑测试要做什么总是很有帮助的。</p><p id="e616" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在这个例子中，我们将通过检查注册过程在medium.com上运行一个测试。</p><p id="5910" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果我们使用测试用例，我们应该现在就写一个，并把测试需要的所有细节放在里面(足够让一个手工测试人员执行相同的测试)。然而，我们现在将列出我们需要采取的步骤，并指出我们需要做出什么样的断言。</p><blockquote class="ns nt nu"><p id="d69e" class="kz la nv lb b lc ld ju le lf lg jx lh nw lj lk ll nx ln lo lp ny lr ls lt lu im bi translated">测试用例名称:假设一个用户试图注册medium.com，当一个无效的电子邮件地址被使用时，会显示一条警告消息</p></blockquote><p id="620e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu">步骤:</strong></p><ul class=""><li id="df3f" class="nz oa it lb b lc ld lf lg li ob lm oc lq od lu oe of og oh bi translated">打开medium.com</li><li id="9191" class="nz oa it lb b lc oi lf oj li ok lm ol lq om lu oe of og oh bi translated">点击“开始”按钮</li><li id="dc13" class="nz oa it lb b lc oi lf oj li ok lm ol lq om lu oe of og oh bi translated">点击“用电子邮件注册”按钮</li><li id="e22c" class="nz oa it lb b lc oi lf oj li ok lm ol lq om lu oe of og oh bi translated">输入无效的电子邮件地址(如“123456”)</li><li id="abd7" class="nz oa it lb b lc oi lf oj li ok lm ol lq om lu oe of og oh bi translated">点击“继续”按钮</li><li id="5d4e" class="nz oa it lb b lc oi lf oj li ok lm ol lq om lu oe of og oh bi translated">验证是否显示警告(如“请输入有效的电子邮件地址。”)</li></ul><p id="9ce9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这就是我们的测试。我们希望得到这个警告信息，以确保用户不能用无效的电子邮件地址注册。</p><p id="c8b6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我有时发现将这些步骤复制到测试中很有帮助，这样我就可以用代码来填补空白。对于更复杂的测试，将这些注释留在代码中可能是个好主意，这样其他人就可以确切地看到发生了什么。</p><pre class="kj kk kl km gt nj ni nk bn nl nm bi"><span id="131a" class="nn lw it ni b be no np l nq nr">namespace AutoTestDemo;<br/><br/>public class UnitTest1<br/>{<br/>    [Fact]<br/>    public void Test1()<br/>    {<br/>        //Open medium.com<br/><br/>        //Click the 'Get started' button<br/><br/>        //Click the 'Sign up with email' button<br/><br/>        //Enter an invalid email address(such as '123456')<br/><br/>        //Click the 'Continue' button<br/><br/>        //Verify that a warning is shown(such as 'Please enter a valid email address.')<br/>    }<br/>}</span></pre><h1 id="3bc0" class="mt lw it bd lx mu mv mw ma mx my mz md jz na ka mg kc nb kd mj kf nc kg mm nd bi translated">打开浏览器窗口</h1><p id="b768" class="pw-post-body-paragraph kz la it lb b lc mo ju le lf mp jx lh li mq lk ll lm mr lo lp lq ms ls lt lu im bi translated">我们的第一步需要打开浏览器本身。</p><p id="5aec" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">由于我们只使用Chrome，我们可以直接使用<code class="fe nf ng nh ni b">ChromeDriver</code>。如果你支持其他浏览器，你可能想把它抽象出来，这样你的测试就可以在多种浏览器上运行，但是现在，我们还是坚持使用Chrome。</p><p id="7f52" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">打开新窗口最简单快捷的方法是实例化一个新的<code class="fe nf ng nh ni b">ChromeDriver</code>对象(来自<code class="fe nf ng nh ni b">OpenQA.Selenium.Chrome</code>，设置<code class="fe nf ng nh ni b">Url</code>属性并调用<code class="fe nf ng nh ni b">Navigate()</code>方法:</p><pre class="kj kk kl km gt nj ni nk bn nl nm bi"><span id="fea8" class="nn lw it ni b be no np l nq nr">using var driver = new ChromeDriver();<br/>driver.Url = "https://medium.com";<br/>driver.Navigate();</span></pre><p id="a9c8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">注意我们是如何得到一个<code class="fe nf ng nh ni b">using</code>关键字的。这只是为了在测试结束时正确处理<code class="fe nf ng nh ni b">ChromeDriver</code>对象。如果您没有这样做，您会注意到在测试期间打开的浏览器窗口在测试结束时没有关闭，并且当您运行多个测试时，您肯定希望测试结束后整理好！</p><p id="43ea" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这就是我们目前所得到的:</p><pre class="kj kk kl km gt nj ni nk bn nl nm bi"><span id="d18b" class="nn lw it ni b be no np l nq nr">using OpenQA.Selenium.Chrome;<br/><br/>namespace AutoTestDemo;<br/><br/>public class UnitTest1<br/>{<br/>    [Fact]<br/>    public void Test1()<br/>    {<br/>        //Open medium.com<br/>        using var driver = new ChromeDriver();<br/>        driver.Url = "https://medium.com";<br/>        driver.Navigate();<br/><br/>        //Click the 'Get started' button<br/><br/>        //Click the 'Sign up with email' button<br/><br/>        //Enter an invalid email address(such as '123456')<br/><br/>        //Click the 'Continue' button<br/><br/>        //Verify that a warning is shown(such as 'Please enter a valid email address.')<br/>    }<br/>}</span></pre><p id="edb3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">试一试，Chrome在medium.com打开，然后马上关闭。到目前为止，这就是我们在测试中所做的一切，你会很高兴看到测试通过！</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi on"><img src="../Images/6f841d37ba176290761b3831bbd12107.png" data-original-src="https://miro.medium.com/v2/resize:fit:678/format:webp/1*31Mc-N0KlTGb3rqaUJa6Jg.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">测试通过！</p></figure><h1 id="c424" class="mt lw it bd lx mu mv mw ma mx my mz md jz na ka mg kc nb kd mj kf nc kg mm nd bi translated">与页面上的元素交互</h1><p id="01b3" class="pw-post-body-paragraph kz la it lb b lc mo ju le lf mp jx lh li mq lk ll lm mr lo lp lq ms ls lt lu im bi translated">既然我们可以打开页面开始测试，我们需要与它进行交互。我们的下一步是单击“开始”按钮。那么，让我们深入探讨一下我们将如何做到这一点。</p><p id="49cb" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">Selenium WebDriver直接与浏览器进行交互，因此我们可以告诉它要查找什么，以及一旦找到它要做什么。</p><p id="2bb8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">有不同的方法来识别页面上的元素:</p><ul class=""><li id="ed02" class="nz oa it lb b lc ld lf lg li ob lm oc lq od lu oe of og oh bi translated">按id</li><li id="cdc0" class="nz oa it lb b lc oi lf oj li ok lm ol lq om lu oe of og oh bi translated">名叫</li><li id="9b2b" class="nz oa it lb b lc oi lf oj li ok lm ol lq om lu oe of og oh bi translated">按类别</li><li id="f81b" class="nz oa it lb b lc oi lf oj li ok lm ol lq om lu oe of og oh bi translated">按标签名称</li><li id="6413" class="nz oa it lb b lc oi lf oj li ok lm ol lq om lu oe of og oh bi translated">按链接文本</li><li id="fded" class="nz oa it lb b lc oi lf oj li ok lm ol lq om lu oe of og oh bi translated">通过XPath</li><li id="919f" class="nz oa it lb b lc oi lf oj li ok lm ol lq om lu oe of og oh bi translated">和其他方式</li></ul><p id="49ce" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">你会发现你写自动化UI测试的80%的时间都在研究如何识别页面上的元素，所以现在找出什么是好的，什么不是很重要。</p><p id="c5db" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">Selenium测试名声不好的一个主要原因是它们可能非常脆弱，甚至应用程序中的小变化都可能导致测试失败。这通常取决于你如何识别你的元素。然而，通过确保您的测试不受无关变更的影响，这是可能的。</p><p id="ec9f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我倾向于使用两种不同的方法来识别元素。第一个也是最可靠的是使用id。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi oo"><img src="../Images/b3159b35bbd0690a23e29096eb172b20.png" data-original-src="https://miro.medium.com/v2/resize:fit:652/format:webp/1*STM7N8Eg7HJxUZerRIoFPg.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">DOM中的按钮</p></figure><p id="07a2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果您有一个具有惟一id的元素，那么99%的情况下，我会选择通过id来标识该元素。id不可能改变；它在页面上是独一无二的，不会受到任何其他改变的影响。</p><p id="6af1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">然而，很多时候，你不会有一个好的id来像这样工作。在这种情况下，我通常使用XPath，这是一种定义元素选择规则的强大方法。在XPath中，我们可以查看id、类名、标记名、列表中的位置、其他元素的位置、父元素、子元素等。因此，虽然有这么多的选择，但有时要想出应该如何做可能有点困难。</p><p id="f4a6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我喜欢思考如何向能看到我的屏幕但不能触摸鼠标的人描述这个元素。</p><p id="4a61" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">以medium.com主页上的“开始”按钮为例，我们需要点击它:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi op"><img src="../Images/947b7b58879d46425ed8630ba0a4fbc9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*8gK743HhgzLkWi6W39ZqaQ.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">medium.com主页</p></figure><p id="fa35" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">看到顶部了吗？</p><p id="425a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在Chrome dev tools中查看这个按钮(按下<code class="fe nf ng nh ni b">F12</code>，或者右键单击元素并选择‘Inspect’)，我们可以看到没有id可以使用:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi oq"><img src="../Images/6f9c566c57d65a55450c345b13df8938.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*pDz0id41YvF6s8kkFPsKdg.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">DOM中的按钮</p></figure><p id="59c8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在，如果右键单击此处的按钮，您可能会想使用“复制→复制XPath”选项:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi or"><img src="../Images/30147d5b338dd4cadfa44b6e48749aff.png" data-original-src="https://miro.medium.com/v2/resize:fit:1002/format:webp/1*j_HwRDYOMQA5-lwKntm33w.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">直接从Chrome开发工具复制XPath</p></figure><p id="24e2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在，这很少会产生对自动化UI测试有用的东西。如果我们复制这个值，我们会得到:</p><pre class="kj kk kl km gt nj ni nk bn nl nm bi"><span id="3f2f" class="nn lw it ni b be no np l nq nr">//*[@id="root"]/div/div[3]/div[1]/div/div/div/div[3]/div/span/a/button</span></pre><p id="600a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">呃。这不是一个好的XPath的样子。它从根元素开始，然后经过一系列div，最后到达按钮。因此，虽然这在今天可能行得通，但是如果页面的结构稍微改变一下会怎么样呢？</p><p id="256d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">例如，如果在某个地方插入一个额外的div，会发生什么？您的测试现在将无法找到该按钮，测试将失败，您需要更新您的测试，以便可以再次找到该按钮。这并不好，如果您发现您使用XPaths和一系列这样的div，您将花费相当多的时间来维护您的测试，这不是对您时间的最好利用。</p><p id="0145" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">相反，让我们考虑如何向其他人描述如何找到这个按钮。我们可能会说，在页面顶部找一个写着“开始”的按钮。“我很确定任何人都可以用这种逻辑点击正确的按钮。我们可以把它转换成XPath，然后用它来代替，这样会更可靠一点。在我们的例子中，我们可以使用按钮的文本来查找元素，所以我们将使用:</p><pre class="kj kk kl km gt nj ni nk bn nl nm bi"><span id="588c" class="nn lw it ni b be no np l nq nr">//button[text()='Get started']</span></pre><p id="bc46" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们把这个放到我们的代码中:</p><pre class="kj kk kl km gt nj ni nk bn nl nm bi"><span id="a5bb" class="nn lw it ni b be no np l nq nr">// Click the 'Get started' button<br/>IWebElement getStartedButton = driver<br/>    .FindElement(By.XPath("//button[text()='Get started']"));</span></pre><p id="a92a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">因此，我们使用我们的<code class="fe nf ng nh ni b">driver</code>变量来查找带有XPath的元素。请注意，如果我们想通过id查找某个东西，我们将使用<code class="fe nf ng nh ni b">By.Id</code>而不是<code class="fe nf ng nh ni b">By.XPath</code>。</p><p id="2723" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">一旦我们得到了我们想要的<code class="fe nf ng nh ni b">IWebElement</code>。我们可以用它做一些事情。例如，单击它:</p><pre class="kj kk kl km gt nj ni nk bn nl nm bi"><span id="ed37" class="nn lw it ni b be no np l nq nr">getStartedButton.Click();</span></pre><p id="d1f7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">仅此而已；该按钮被单击。我们可以使用接下来出现的“用电子邮件注册”按钮进行同样的操作:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi os"><img src="../Images/bc3d36bb7574ed6e7c34ebb09123e8ed.png" data-original-src="https://miro.medium.com/v2/resize:fit:578/format:webp/1*DTidKgkUwe9-LX31D6LxsA.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">注册页面</p></figure><p id="f219" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">尽管这一次，DOM有点棘手:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi ot"><img src="../Images/82acd3dd37238e292702c6969cb57ac4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1360/format:webp/1*U1Z6fJs-x1pHyb882f1JSg.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">按钮的DOM</p></figure><p id="a33e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">您将看到按钮的文本并不直接在按钮本身内部，而是在一个嵌套的div中。这里还有一个SVG。为此，您可以使用一个<code class="fe nf ng nh ni b">normalize-space</code>功能，它允许您检查您正在查看的元素下的所有元素的文本。所以我们的XPath可以是:</p><pre class="kj kk kl km gt nj ni nk bn nl nm bi"><span id="641e" class="nn lw it ni b be no np l nq nr">//button[normalize-space() = 'Sign up with email']</span></pre><p id="054e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">接下来，我们需要找到输入的电子邮件地址。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi ou"><img src="../Images/a0c68531c3693daaad650b6b4857d213.png" data-original-src="https://miro.medium.com/v2/resize:fit:576/format:webp/1*KtwxILEjzscYZBesji-bUA.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">注册屏幕允许您输入您的电子邮件地址</p></figure><p id="7d49" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">同样，我们没有id，所以你如何向其他人描述这个元素的位置呢？我们可以说，‘找到显示在‘你的电子邮件’标签后的输入。’这很清楚，所以这就是我们将使用的XPath值，使用<code class="fe nf ng nh ni b">following-sibling</code>查找下一个输入元素:</p><pre class="kj kk kl km gt nj ni nk bn nl nm bi"><span id="4402" class="nn lw it ni b be no np l nq nr">//*[normalize-space() = 'Your email']//following-sibling::*//input</span></pre><p id="2887" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在我们已经有了input元素，我们可以向它发送键:</p><pre class="kj kk kl km gt nj ni nk bn nl nm bi"><span id="90f7" class="nn lw it ni b be no np l nq nr">// Enter an invalid email address(such as '123456')<br/>IWebElement input = driver<br/>    .FindElement(By.XPath("//*[normalize-space() = 'Your email']//following-sibling::*//input"));<br/><br/>input.SendKeys("123456");</span></pre><p id="33fd" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">太好了。接下来，我们需要单击“继续”按钮。这是另一个简单的例子，我们可以通过文本找到:</p><pre class="kj kk kl km gt nj ni nk bn nl nm bi"><span id="7d33" class="nn lw it ni b be no np l nq nr">// Click the 'Continue' button<br/>IWebElement continueButton = driver<br/>    .FindElement(By.XPath("//button[text()='Continue']"));<br/><br/>continueButton.Click();</span></pre><p id="a1ed" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果我们手动输入无效的电子邮件地址，我们可以看到警告出现的位置:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi ov"><img src="../Images/c3c0556269c9d7da53314f385ffe9916.png" data-original-src="https://miro.medium.com/v2/resize:fit:740/format:webp/1*Tu1E7qi4fBrVw11muiv9cw.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">显示的警告</p></figure><p id="499c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">检查这个元素表明我们有一个很好的“error”id可以使用:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ow"><img src="../Images/c6716ff3208b2ee66bfe2b193e7d28d1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*TWZakVqctkMowkIyF-9Iqg.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">警告的DOM</p></figure><p id="5463" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">因此，我们将使用它来获取警告文本，并验证它是否符合我们的预期:</p><pre class="kj kk kl km gt nj ni nk bn nl nm bi"><span id="00e5" class="nn lw it ni b be no np l nq nr">// Verify that a warning is shown(such as 'Please enter a valid email address.')<br/>IWebElement error = driver.FindElement(By.Id("error"));<br/><br/>Assert.Equal("Please enter a valid email address.", error.Text);</span></pre><p id="4bb0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这就是我们的考验！将所有这些放在一起，我们得到以下结果:</p><pre class="kj kk kl km gt nj ni nk bn nl nm bi"><span id="4cdd" class="nn lw it ni b be no np l nq nr">[Fact]<br/>public void Test1()<br/>{<br/>    // Open medium.com<br/>    using var driver = new ChromeDriver();<br/>    driver.Url = "https://medium.com";<br/>    driver.Navigate();<br/><br/>    // Click the 'Get started' button<br/>    IWebElement getStartedButton = driver<br/>        .FindElement(By.XPath("//button[text()='Get started']"));<br/><br/>    getStartedButton.Click();<br/><br/>    // Click the 'Sign up with email' button<br/>    IWebElement signUpButton = driver<br/>        .FindElement(By.XPath("//button[contains(normalize-space(), 'Sign up with email')]"));<br/><br/>    signUpButton.Click();<br/><br/>    // Enter an invalid email address(such as '123456')<br/>    IWebElement input = driver<br/>        .FindElement(By.XPath("//*[normalize-space() = 'Your email']//following-sibling::*//input"));<br/><br/>    input.SendKeys("123456");<br/><br/>    // Click the 'Continue' button<br/>    IWebElement continueButton = driver<br/>        .FindElement(By.XPath("//button[text()='Continue']"));<br/><br/>    continueButton.Click();<br/><br/>    // Verify that a warning is shown(such as 'Please enter a valid email address.')<br/>    IWebElement error = driver.FindElement(By.Id("error"));<br/><br/>    Assert.Equal("Please enter a valid email address.", error.Text);<br/>}</span></pre><p id="4086" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">试一试，它就通过了:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi ox"><img src="../Images/e5eb650fb42449ba95fcbbdf244a6fdc.png" data-original-src="https://miro.medium.com/v2/resize:fit:666/format:webp/1*B8elk_bibkm7LQ4YEBRHVg.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">我们的测试通过了！</p></figure><p id="5df2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这是我们写的第一个测试。干得好。</p><p id="97ec" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果你打算结束编写更多的测试，你会希望注意到这个测试有很大的改进空间。</p><p id="6b2e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们现在来看看一些改进。</p><h1 id="3019" class="mt lw it bd lx mu mv mw ma mx my mz md jz na ka mg kc nb kd mj kf nc kg mm nd bi translated">将IWebDriver移出测试</h1><p id="2399" class="pw-post-body-paragraph kz la it lb b lc mo ju le lf mp jx lh li mq lk ll lm mr lo lp lq ms ls lt lu im bi translated">将<code class="fe nf ng nh ni b">ChromeDriver</code>的实例化和处理移动到一个在每个测试之前和之后运行的公共区域将会很有帮助，所以你不需要为每个测试都这样做。</p><p id="c8d9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">对于xUnit，我们可以使用一个构造函数并实现<code class="fe nf ng nh ni b">IDispose</code>来做到这一点，但是我们可以更进一步，创建一个抽象基类来处理它，这样我们就可以有多个测试类使用同一个基类。</p><p id="911d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们的基类可能是这样的:</p><pre class="kj kk kl km gt nj ni nk bn nl nm bi"><span id="3c95" class="nn lw it ni b be no np l nq nr">using OpenQA.Selenium;<br/>using OpenQA.Selenium.Chrome;<br/><br/>namespace AutoTestDemo;<br/><br/>public abstract class BaseTest : IDisposable<br/>{<br/>    protected readonly IWebDriver Driver;<br/><br/>    protected BaseTest()<br/>    {<br/>        Driver = new ChromeDriver<br/>        {<br/>            Url = "https://medium.com"<br/>        };<br/>        Driver.Navigate();<br/>    }<br/><br/>    public void Dispose()<br/>    {<br/>        Driver.Dispose();<br/>    }<br/>}</span></pre><p id="5d60" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们会以通常的方式继承它:</p><pre class="kj kk kl km gt nj ni nk bn nl nm bi"><span id="1bd3" class="nn lw it ni b be no np l nq nr">public class SignUpTests : BaseTest</span></pre><p id="13f4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">所以，现在我们可以在测试中直接使用<code class="fe nf ng nh ni b">Driver</code>属性，而不需要创建或记住释放它。</p><h1 id="d2b4" class="mt lw it bd lx mu mv mw ma mx my mz md jz na ka mg kc nb kd mj kf nc kg mm nd bi translated">创建页面对象模型</h1><p id="dec5" class="pw-post-body-paragraph kz la it lb b lc mo ju le lf mp jx lh li mq lk ll lm mr lo lp lq ms ls lt lu im bi translated">页面对象模型是一种模式，在这种模式下，我们将所有可以与“页面”进行的交互放入它自己的类中，这样它就包含在同一个地方，可以被不同的测试重用。</p><p id="24be" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们可以为这个“主页”创建一个，如下所示:</p><pre class="kj kk kl km gt nj ni nk bn nl nm bi"><span id="d790" class="nn lw it ni b be no np l nq nr">using OpenQA.Selenium;<br/><br/>namespace AutoTestDemo;<br/><br/>public class Homepage<br/>{<br/>    private readonly IWebDriver _driver;<br/><br/>    private static By GetStartedButtonPath =&gt; <br/>      By.XPath("//button[text()='Get started']");<br/>    private static By SignUpButtonPath =&gt; <br/>      By.XPath("//button[contains(normalize-space(), 'Sign up with email')]");<br/>    private static By ContinueButtonPath =&gt; <br/>      By.XPath("//button[text()='Continue']");<br/>    private static By EmailPath =&gt; <br/>      By.XPath("//*[normalize-space() = 'Your email']//following-sibling::*//input");<br/>    private static By ErrorPath =&gt; <br/>      By.Id("error");<br/><br/>    public Homepage(IWebDriver driver)<br/>    {<br/>        _driver = driver;<br/>    }<br/><br/>    public void ClickGetStartedButton()<br/>    {<br/>        _driver.FindElement(GetStartedButtonPath).Click();<br/>    }<br/><br/>    public void ClickSignUpButton()<br/>    {<br/>        _driver.FindElement(SignUpButtonPath).Click();<br/>    }<br/><br/>    public void EnterEmail(string text)<br/>    {<br/>        _driver.FindElement(EmailPath).SendKeys(text);<br/>    }<br/><br/>    public void ClickContinueButton()<br/>    {<br/>        _driver.FindElement(ContinueButtonPath).Click();<br/>    }<br/><br/>    public void VerifyErrorMessage(string expectedMessage)<br/>    {<br/>        Assert.Equal(expectedMessage, _driver.FindElement(ErrorPath).Text);<br/>    }<br/>}</span></pre><p id="f693" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">看看我们如何传递我们的<code class="fe nf ng nh ni b">IWebDriver</code>对象，这样我们就可以在页面对象模型中查找元素。这意味着我们可以实例化这个模型，并像这样调用它:</p><pre class="kj kk kl km gt nj ni nk bn nl nm bi"><span id="33b1" class="nn lw it ni b be no np l nq nr">namespace AutoTestDemo;<br/><br/>public class SignUpTests : BaseTest<br/>{<br/>    [Fact]<br/>    public void VerifyInvalidEmailMessage()<br/>    {<br/>        Driver.Navigate();<br/><br/>        var homepage = new Homepage(Driver);<br/><br/>        homepage.ClickGetStartedButton();<br/><br/>        homepage.ClickSignUpButton();<br/><br/>        homepage.EnterEmail("123456");<br/><br/>        homepage.ClickContinueButton();<br/><br/>        homepage.VerifyErrorMessage("Please enter a valid email address.");<br/>    }<br/>}</span></pre><p id="bfdc" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">希望你现在能看到这个测试可读性更好了，我们不需要原始的注释，因为每一步都很清楚。</p><p id="bf39" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">另外，由于所有关于“主页”的逻辑现在都在一个类中，如果我们需要更新我们的测试来反映应用程序的变化，我们只需要更新一个地方，而不是更新每个测试。</p><h1 id="b854" class="mt lw it bd lx mu mv mw ma mx my mz md jz na ka mg kc nb kd mj kf nc kg mm nd bi translated">添加等待</h1><p id="8d17" class="pw-post-body-paragraph kz la it lb b lc mo ju le lf mp jx lh li mq lk ll lm mr lo lp lq ms ls lt lu im bi translated">能够智能地等待测试中事件的发生也是测试具有弹性和可靠性的关键。您可能编写了一个可以在您的机器上完美运行的测试，但是一旦您在一个不同的(可能更慢的)测试环境中运行该测试，您可能会遇到错误，因为您的测试在完全加载之前就期望发生一些事情。</p><p id="a6fa" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">例如，您可以编写一个提交表单的测试，并期望显示一个错误。在本地，API调用可能几乎立即返回，因此您的测试可以立即看到错误。在不同的环境中运行它可能会增加API调用的延迟，这意味着当试图找到错误时测试会失败。然而，这不是一个合理的错误，因为如果测试再等一会儿，就会出现错误。</p><p id="b2e9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">对此的下意识反应是添加一个硬编码等待(称为<em class="nv">隐式</em>等待)，类似于<code class="fe nf ng nh ni b">Thread.Sleep</code>。虽然这可能会使失败的测试重新启动并运行，但这很少是理想的解决方案。问题是等待时间是固定的，测试将一直等待这个时间长度。</p><p id="a968" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果它所等待的事件在等待结束之前就准备好了，那么测试仍然会等待整个时间，这不必要地延长了您的测试执行时间。还有一种可能是，一个三秒钟的API调用偶尔会变成一个四秒钟的API调用，在这种情况下，等待会过早结束，您的测试仍然会失败。</p><p id="9af3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">更好的解决方案是使用显式等待。这些等待依赖于一个条件，一旦满足该条件就会结束。您仍然需要设置一个总超时值(等待条件的最长时间)，但是只有在条件不满足时才会达到这个值。采用我们的方法来验证显示的错误消息。让我们假设这个错误来自一个API调用的结果，这个调用有时需要几秒钟才能返回。</p><p id="030f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们将使用一个显式的<code class="fe nf ng nh ni b">wait</code>来代替几秒钟的隐式<code class="fe nf ng nh ni b">wait</code>:</p><pre class="kj kk kl km gt nj ni nk bn nl nm bi"><span id="c9dc" class="nn lw it ni b be no np l nq nr">public void VerifyErrorMessage(string expectedMessage)<br/>{<br/>    WebDriverWait wait = new WebDriverWait(_driver, TimeSpan.FromSeconds(10));<br/><br/>    IWebElement errorElement = wait.Until(d =&gt; d.FindElement(ErrorPath));<br/><br/>    Assert.Equal(expectedMessage, errorElement.Text);<br/>}</span></pre><p id="4cac" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">看看我们如何首先创建一个最大长度为10秒的<code class="fe nf ng nh ni b">WebDriverWait</code>对象，然后使用这个等待来定义一个<code class="fe nf ng nh ni b">Until</code>条件，检查是否可以找到<code class="fe nf ng nh ni b">ErrorPath</code>元素。并且您可以在那个<code class="fe nf ng nh ni b">Until</code>条件中做各种事情(包括检查一个元素是否存在，这是一个相当常见的需求)。接下来，您可能希望存储那个<code class="fe nf ng nh ni b">WebDriverWait</code>对象，并在测试的剩余部分重用它。</p><p id="fa0c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这些等待允许您增加测试的灵活性，这样即使应用程序变得有点慢，它们仍然可以正确运行。</p><h1 id="0ced" class="mt lw it bd lx mu mv mw ma mx my mz md jz na ka mg kc nb kd mj kf nc kg mm nd bi translated">摘要</h1><p id="2973" class="pw-post-body-paragraph kz la it lb b lc mo ju le lf mp jx lh li mq lk ll lm mr lo lp lq ms ls lt lu im bi translated">希望您已经看到了自动化UI测试有多好，以及它们能给您带来的价值。</p><p id="0cf4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">以正确的方式编写，它们可以是对您现有测试工作的一个非常有用的补充，并且让您对您所做的更改是正确的有更高的信心。</p><p id="7807" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们已经深入研究了如何启动和运行单个测试，研究了您可能希望如何构建代码以使其尽可能可维护，并了解了我们如何使用智能等待来允许您的测试通过，即使应用程序中存在不可预测的延迟。</p></div></div>    
</body>
</html>