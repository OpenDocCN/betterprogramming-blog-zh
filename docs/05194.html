<html>
<head>
<title>What Are Duck Typing and Monkey Patching in Python?</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Python中的鸭子打字和猴子打补丁是什么？</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/what-are-duck-typing-and-monkey-patching-in-python-2f8e3d6b864f?source=collection_archive---------2-----------------------#2020-06-19">https://betterprogramming.pub/what-are-duck-typing-and-monkey-patching-in-python-2f8e3d6b864f?source=collection_archive---------2-----------------------#2020-06-19</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="a02c" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">我们说Python灵活的一个原因是</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/74cf5c12790bd63470f4c72aea8e8a6e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*3BUKv9AC0IKs8le-"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">照片由<a class="ae ky" href="https://unsplash.com/@zayyerrn?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">艾哈迈德·扎扬</a>在<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</p></figure><p id="2db6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这不是一篇关于动物的文章，尽管在一个标题中出现三个动物的名字并不常见。今天我想讨论一下Python中的鸭子打字和猴子打补丁。这两个特性对于使Python成为一种灵活的通用语言至关重要。</p><p id="a4e4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">读完这篇文章后，我希望您对Python中的duck类型化和monkey修补是如何工作的有一个直观的想法。我们开始吧！</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="9c69" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">鸭子打字</h1><p id="0a2d" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">对于许多程序员来说，duck typing这个术语并不陌生——尤其是如果你有一些动态编程语言的背景知识。然而，它不是由计算机科学家发明的。我们来看看它的大致定义:</p><blockquote class="mz"><p id="c817" class="na nb it bd nc nd ne nf ng nh ni lu dk translated">“如果它长得像鸭子，游起来像鸭子，叫声像鸭子，那么它很可能就是鸭子。”— <a class="ae ky" href="https://en.wikipedia.org/wiki/Duck_test" rel="noopener ugc nofollow" target="_blank">维基百科</a></p></blockquote><p id="2bca" class="pw-post-body-paragraph kz la it lb b lc nj ju le lf nk jx lh li nl lk ll lm nm lo lp lq nn ls lt lu im bi translated">这是一种溯因推理的形式，它意味着我们只根据一个人的外表和行为而不是他们的实际类型来得出我们的身份结论。在编程语言中，duck typing代表了一种实现模式，它定义了特定对象的行为方式，而不用担心类的类型。这听起来可能太抽象了，但是用一个具体的例子，你会发现一点也不难。</p><p id="7196" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">首先，我们将创建一个“真正的”duck类，作为定义鸭子行为的基准。如下所示，<code class="fe no np nq nr b">Duck</code>类有两个实例方法— <code class="fe no np nq nr b">swim()</code>和<code class="fe no np nq nr b">quack()</code>(这是鸭子的两种行为):</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ns nt l"/></div></figure><p id="687f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">作为<code class="fe no np nq nr b">Duck</code>类的一个实例对象，我们可以验证一只鸭子能够像鸭子一样行动。它会游泳和嘎嘎叫。如下所示，我们首先创建<code class="fe no np nq nr b">duck_testing</code>函数来检查一只假定的鸭子是否会游泳和嘎嘎叫。正如所料，<code class="fe no np nq nr b">duck</code>实例做了它应该做的事情，并通过了duck类型测试:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ns nt l"/></div></figure><p id="9bef" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">您是否注意到我实际上使用内省函数<code class="fe no np nq nr b">isinstance</code>检查了<code class="fe no np nq nr b">duck</code>实例对象的类型？通过验证假定的duck是<code class="fe no np nq nr b">Duck</code>类的一个实例，我们确信它将通过duck类型测试。然而，检查感兴趣的对象的类型以期望其行为是乏味的，这正是duck typing试图避免的。duck typing的关键是我们不关心对象的类型。只要它会游泳，会嘎嘎叫(或者其他任何被定义的行为或方法)，我们就认为它是鸭子(或者任何被关注的类型)。</p><p id="29b1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们看看duck typing如何超越我们一直在谈论的<code class="fe no np nq nr b">Duck</code>类。为了便于对比，我将创建两个自定义类:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ns nt l"/></div></figure><p id="95df" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如上所示，<code class="fe no np nq nr b">ToyDuck</code>类同时实现了<code class="fe no np nq nr b">swim()</code>和<code class="fe no np nq nr b">quack()</code>方法。因此，根据鸭分型，我们应该期待它通过鸭分型测试。另一方面，<code class="fe no np nq nr b">Human</code>类只有<code class="fe no np nq nr b">swim()</code>方法，因此不会通过duck类型测试来获得duck的资格。接下来让我们验证我们的预测:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ns nt l"/></div></figure><p id="c949" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">不出所料，一只玩具鸭会游泳，还会嘎嘎叫，而人类只会游泳。<code class="fe no np nq nr b">human</code>实例对象不被认为是一个类似鸭子的对象。值得注意的是，<code class="fe no np nq nr b">toy_duck</code>和<code class="fe no np nq nr b">human</code>对象都不是原始<code class="fe no np nq nr b">Duck</code>类的实例对象。只是支持的行为(即游泳和呱呱)使得<code class="fe no np nq nr b">toy_duck</code>成为一个类似鸭子的对象，并通过了鸭子类型化测试。这是实现鸭子类型的关键。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="1384" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">猴子补丁</h1><p id="bf7f" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">猴子补丁这个术语有一个非常有趣的名字。根据维基百科的说法，猴子补丁可能与早期的术语“游击补丁”有关，它指的是偷偷摸摸地改变代码。鉴于游击队与大猩猩的同音关系，以及大猩猩与猴子的关系(两者都是灵长类动物)，猴子补丁就产生了。就其在编程世界中的特定概念化而言，它是这样定义的:</p><blockquote class="mz"><p id="966f" class="na nb it bd nc nd ne nf ng nh ni lu dk translated">“猴子补丁是程序在本地扩展或修改支持系统软件的一种方式(只影响程序的运行实例)。”— <a class="ae ky" href="https://en.wikipedia.org/wiki/Monkey_patch" rel="noopener ugc nofollow" target="_blank">维基百科</a></p></blockquote><p id="043f" class="pw-post-body-paragraph kz la it lb b lc nj ju le lf nk jx lh li nl lk ll lm nm lo lp lq nn ls lt lu im bi translated">作为一种动态语言，Python允许我们通过扩展特定的模块或类在编码中使用猴子补丁，而无需修改它们的原始实现。在本节中，我们希望使<code class="fe no np nq nr b">Human</code>类的实例(如上定义)能够像鸭子一样工作。我知道这很奇怪，但是想想唐老鸭作为一个人。</p><p id="ccc2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">为了理解monkey补丁是如何机械地工作的，让我们后退一步，看看Python类是如何工作的。众所周知，Python是一种面向对象的语言，它通过把一切都当作对象来操作，包括模块和类。为了提供一个概念证明，我们将只对一个定制类应用monkey补丁。在深入细节之前，我们先来看一个简化的Python类:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ns nt l"/></div></figure><p id="8e58" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">它绝对不是一个花哨的类，只有一个类属性和一个实例方法(如果你不了解<code class="fe no np nq nr b">self</code>参数，请查看<a class="ae ky" href="https://medium.com/better-programming/unlock-the-4-mysteries-of-self-in-python-d1913fbb8e16" rel="noopener">这篇文章</a>)。需要注意的一点是，我们可以访问<code class="fe no np nq nr b">Foo</code>的<code class="fe no np nq nr b">__dict__</code>属性，它列出了这个类的所有属性，包括<code class="fe no np nq nr b">attr1</code>和<code class="fe no np nq nr b">bar</code>。如前所述，Python类也是对象，这意味着我们甚至可以在运行时动态更新它们的属性。顺便说一下，这正是猴子补丁的意义所在。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ns nt l"/></div></figure><p id="4204" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">正如您在上面的代码片段中看到的，我们直接为类对象设置了一个属性和一个函数。因此，更新后的class' <code class="fe no np nq nr b">__dict__</code>属性揭示了<code class="fe no np nq nr b">attr2</code>和<code class="fe no np nq nr b">bar2</code>确实是“修补”到原始类的。重要的是，我们可以像对待预定义属性一样访问<code class="fe no np nq nr b">attr2</code>(例如<code class="fe no np nq nr b">attr1</code>)。</p><p id="e78a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">既然我们知道了monkey补丁如何与泛型类一起工作，让我们用<code class="fe no np nq nr b">Human</code>类来尝试一下。只是友情提示:想要的特性是让一个人体对象嘎嘎叫，这样它就能通过鸭子分型测试。重要的是，我们不会改变原来的类。如下所示，我们定义了一个名为<code class="fe no np nq nr b">quack</code>的函数，并将该函数设置为<code class="fe no np nq nr b">Human</code>类的<code class="fe no np nq nr b">quack</code>属性:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ns nt l"/></div></figure><p id="0432" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">需要注意的一点是，定义的<code class="fe no np nq nr b">quack</code>函数有一个参数，看似不用，但却是必不可少的。因为<code class="fe no np nq nr b">quack</code>函数是一个实例方法，它总会有一个引用实例对象的参数(我们在这个类中使用了<code class="fe no np nq nr b">self</code>，但是你可以随意调用它)。如果你仍然对<code class="fe no np nq nr b">self</code>争论感到困惑，请<a class="ae ky" href="https://medium.com/better-programming/unlock-the-4-mysteries-of-self-in-python-d1913fbb8e16" rel="noopener">查看</a>我的<a class="ae ky" href="https://medium.com/swlh/declare-your-first-python-class-understand-3-basic-components-15768c8d35b0" rel="noopener">以前的文章</a>。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ns nt l"/></div></figure><p id="9386" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">正如你所看到的，在猴子打补丁之后，<code class="fe no np nq nr b">Human</code>类的实例对象成功地通过了鸭子类型测试。同样，这一步不涉及改变原来的<code class="fe no np nq nr b">Human</code>类的实现。相反，我们在类外“修补”这些特性。这就是这个动态特性的美妙之处。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="0884" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">概述</h1><p id="77be" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">在本文中，我们回顾了Python中duck类型化和monkey修补的工作原理。下面是这两个术语的简要回顾:</p><ul class=""><li id="5fbc" class="nu nv it lb b lc ld lf lg li nw lm nx lq ny lu nz oa ob oc bi translated">Duck typing是一种方法，可以设计一个类，使其具有所需的行为，而无需子类化或实现协议、接口或抽象基类。如果你不知道这些术语也没关系。还是可以用鸭式打字。同样，关键是实现所需行为所需的方法和属性。</li><li id="1da3" class="nu nv it lb b lc od lf oe li of lm og lq oh lu nz oa ob oc bi translated">Monkey patching是一种扩展机制，它允许我们在不修改原始实现的情况下实现现有模块和类的附加特性。但是，请谨慎使用它，因为修补同一模块/类的代码的不同部分会因为相互影响而导致意外的行为。</li></ul></div></div>    
</body>
</html>