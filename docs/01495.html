<html>
<head>
<title>The Power of Higher-Order Functions in JavaScript</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">JavaScript中高阶函数的威力</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/the-power-of-higher-order-functions-in-javascript-91fc8edc3a7a?source=collection_archive---------4-----------------------#2019-09-19">https://betterprogramming.pub/the-power-of-higher-order-functions-in-javascript-91fc8edc3a7a?source=collection_archive---------4-----------------------#2019-09-19</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="6de4" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">带有示例和使用案例</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/723f6f7cad679bb6c63633596f51c621.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*oMFVO_OudoEJLGIxaDZNsg.jpeg"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated"><em class="ky">克里斯托弗·高尔在Unsplash上拍摄的照片</em></p></figure><p id="c516" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">几乎所有现存的JavaScript应用程序都使用JavaScript函数。由于函数，这种语言能够做许多强大的事情，例如在医疗保健中建立人工智能功能。</p><p id="ec86" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我将在这篇文章中谈论的一个强大功能是<em class="lv">高阶函数</em>。这是一个要么接受另一个函数作为参数，要么返回一个函数作为返回值的函数。</p><p id="30c8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">也就是说，如果你一直在玩JavaScript，你可能已经听说过这个术语。高阶函数在JavaScript中被广泛使用，它们存在于常用的函数中，如<code class="fe lw lx ly lz b">.map</code>、<code class="fe lw lx ly lz b">.filter</code>、<code class="fe lw lx ly lz b">.reduce</code>和<code class="fe lw lx ly lz b">.forEach</code>。</p><p id="ac92" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果您是JavaScript新手，您可能会对这些方法中的<em class="lv">和</em>高阶函数感到困惑。</p><p id="c5da" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">当您将函数回调声明为这些数组方法的参数时，您会看到这些:</p><pre class="kj kk kl km gt ma lz mb mc aw md bi"><span id="b16a" class="me mf it lz b gy mg mh l mi mj">const arr = [1, 2, 3, 4, 5, 'six', 'seven', 'eight', 'nine', 'ten']<br/><br/>// Duplicate the array<br/>arr.map(function(value) {<br/>  return value<br/>})<br/><br/>// Return only the number types<br/>arr.filter(function(value) {<br/>  return typeof value === 'number'<br/>})<br/><br/>// Log each value to the console<br/>arr.forEach(function(value) {<br/>  console.log(value)<br/>})<br/><br/>// Add the numbers together, avoiding the string types<br/>arr.reduce(function(acc, value) {<br/>  if (typeof value === 'number') {<br/>    acc += value<br/>  }<br/>  return acc<br/>}, 0)</span></pre><p id="d564" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">但是高阶函数不是你传递给像<code class="fe lw lx ly lz b">.map</code>这样的方法的函数。像<code class="fe lw lx ly lz b">.map</code>这样的方法是高阶函数。</p><p id="b1cb" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">当我们提到高阶函数可以是以另一个函数作为参数的函数时，这正是当你传入一个函数时它所做的。</p><p id="8883" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">下面是一个功能与<code class="fe lw lx ly lz b">.map</code>方法完全一样的实现:</p><pre class="kj kk kl km gt ma lz mb mc aw md bi"><span id="6cdf" class="me mf it lz b gy mg mh l mi mj">function map(callback) {<br/>  const result = []<br/>  <br/>  for (let index = 0; index &lt; this.length; index++) {<br/>    const currentItem = this[index]<br/>    const returnValue = callback(currentItem, index, this)<br/>    result.push(returnValue)<br/>  }<br/>  <br/>  return result<br/>}</span></pre><p id="2852" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">查看代码片段，<code class="fe lw lx ly lz b">callback</code>参数与我们作为参数传递给我之前展示的<code class="fe lw lx ly lz b">.map</code>方法的函数完全相同:</p><pre class="kj kk kl km gt ma lz mb mc aw md bi"><span id="3bc1" class="me mf it lz b gy mg mh l mi mj"><em class="lv">// Duplicate the array</em><br/>arr.map(function(value) {<br/>  return value<br/>})</span></pre><p id="5196" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">更准确地说，让我将这段代码重命名为与我们的<code class="fe lw lx ly lz b">map</code>函数实现相同的名称，这样您可以更清楚地看到它:</p><pre class="kj kk kl km gt ma lz mb mc aw md bi"><span id="6f5a" class="me mf it lz b gy mg mh l mi mj">const callback = function(value) {<br/>  return value<br/>}<br/><br/>// Duplicate the array<br/>arr.map(callback)<br/><br/>// is the same callback used in our .map implementation:<br/>function map(callback) {<br/>  const result = []<br/>  for (let index = 0; index &lt; this.length; index++) {<br/>    const currentItem = this[index]<br/>    const returnValue = callback(currentItem, index, this)<br/>    result.push(returnValue)<br/>  }<br/>  return result<br/>}</span></pre><p id="0395" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">起初，这似乎是用JavaScript编写代码的无用方法。为什么传入一个函数并麻烦返回另一个函数，当你可以避免这一切并在一个函数中一次完成所有事情的时候？</p><p id="2255" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">高阶函数给表带来的最大好处是可重用性和简单性。但是他们也从帮助编写漂亮的代码中受益。是的，JavaScript中有丑陋的代码和美丽的代码这样的东西。</p><p id="d70d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">考虑到可重用性，高阶函数引入了一些非常强大的代码组合。</p></div><div class="ab cl mk ml hx mm" role="separator"><span class="mn bw bk mo mp mq"/><span class="mn bw bk mo mp mq"/><span class="mn bw bk mo mp"/></div><div class="im in io ip iq"><h1 id="855c" class="mr mf it bd ms mt mu mv mw mx my mz na jz nb ka nc kc nd kd ne kf nf kg ng nh bi translated">代码组成和强大的例子</h1><p id="9cdd" class="pw-post-body-paragraph kz la it lb b lc ni ju le lf nj jx lh li nk lk ll lm nl lo lp lq nm ls lt lu im bi translated">现在我们知道了高阶函数在代码中的样子，你可能想知道一些用例是什么，它们从哪里开始发光。</p><p id="278f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">假设我们有一个青蛙列表:</p><pre class="kj kk kl km gt ma lz mb mc aw md bi"><span id="355c" class="me mf it lz b gy mg mh l mi mj">const frogsList = [<br/>  // Yes, these frogs are intelligent. They know how to use email<br/>  {<br/>    name: 'bobTheFrog',<br/>    email: 'froggy@gmail.com',<br/>    age: 2,<br/>    gender: 'Male',<br/>    widthOfTongue: 3,<br/>  },<br/>  {<br/>    name: 'hippoTheFrog',<br/>    email: 'hippo@gmail.com',<br/>    age: 10,<br/>    gender: 'Male',<br/>    widthOfTongue: 11,<br/>  },<br/>  {<br/>    name: 'sally',<br/>    email: 'sallyLipstick@gmail.com',<br/>    age: 5,<br/>    gender: 'Female',<br/>    widthOfTongue: 4,<br/>  },<br/>  {<br/>    name: 'george',<br/>    email: 'georgeRoseBowl@gmail.com',<br/>    age: 11,<br/>    gender: 'Male',<br/>    widthOfTongue: 3,<br/>  },<br/>  {<br/>    name: 'lisa',<br/>    email: 'lisaLovesGeorgeForever@gmail.com',<br/>    age: 19,<br/>    gender: 'Female',<br/>    widthOfTongue: 15,<br/>  },<br/>  {<br/>    name: 'kentucky',<br/>    email: 'frogInKentucky@yahoo.com',<br/>    age: 18,<br/>    gender: 'Male',<br/>    widthOfTongue: 13,<br/>  },<br/>]</span></pre><p id="c87d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">为了在没有高阶函数的情况下将青蛙筛选到特定的性别类型，我们必须做这样的事情:</p><pre class="kj kk kl km gt ma lz mb mc aw md bi"><span id="31f6" class="me mf it lz b gy mg mh l mi mj">function filterGender(gender, frogs) {<br/>  return frogs.filter(function(frog) {<br/>    return frog.gender ==== gender<br/>  })<br/>}<br/><br/>// filterGender in use<br/>const maleFrogs = filterGender('Male', frogsList)</span></pre><p id="e146" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这很好。但是，如果在一个应用程序中多次使用，可能会很麻烦。如果我们有一个关于青蛙的巨大应用程序，<code class="fe lw lx ly lz b">filterGender</code>可能会被多次使用。</p></div><div class="ab cl mk ml hx mm" role="separator"><span class="mn bw bk mo mp mq"/><span class="mn bw bk mo mp mq"/><span class="mn bw bk mo mp"/></div><div class="im in io ip iq"><h1 id="ab82" class="mr mf it bd ms mt mu mv mw mx my mz na jz nb ka nc kc nd kd ne kf nf kg ng nh bi translated">更进一步</h1><p id="4fe7" class="pw-post-body-paragraph kz la it lb b lc ni ju le lf nj jx lh li nk lk ll lm nl lo lp lq nm ls lt lu im bi translated">如果您要获取不同的青蛙列表，您必须再次调用<code class="fe lw lx ly lz b">filterGender</code>,并重新声明您的性别作为过滤新列表的第一个参数:</p><pre class="kj kk kl km gt ma lz mb mc aw md bi"><span id="16a7" class="me mf it lz b gy mg mh l mi mj">function getFrogs() {<br/>  // some logic and returns a new list of frogs<br/>}<br/><br/>const newFrogs = getFrogs()<br/>const moreMaleFrogs = filterGender('Male', newFrogs) // Shucks, I have to write 'Male' again?</span></pre><p id="d079" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果你从未听说过<a class="ae nn" href="https://thevaluable.dev/dry-principle-explained/" rel="noopener ugc nofollow" target="_blank">干</a>原则，我强烈推荐你去了解一下。由于第一个参数，我们的代码片段违反了这条规则。我们可以做得更好。</p><p id="f6bf" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">为了解决这个问题，我们可以使用高阶函数的概念。</p><pre class="kj kk kl km gt ma lz mb mc aw md bi"><span id="2e15" class="me mf it lz b gy mg mh l mi mj">function filterGender(gender) {<br/>  return function(frogs) {<br/>    return frogs.filter(function(frog) {<br/>      return frog.gender === gender<br/>    })<br/>  }<br/>}</span></pre><p id="fe6e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">就像这样，我们可以把这个性别过滤器赋给一个变量，这样我们在过滤青蛙的时候就再也不用声明相同的性别了！</p><pre class="kj kk kl km gt ma lz mb mc aw md bi"><span id="7819" class="me mf it lz b gy mg mh l mi mj">const filterFemaleFrogs = filterGender('Female')<br/>const femaleFrogs = filterFemaleFrogs(frogsList)</span></pre><p id="f0ed" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">但是等等，这还不是全部。通过组合它们，我们获得了一个额外的好处。我们不仅受益于再也不必为雌性青蛙重新编写过滤器，而且我们现在还能够重用返回的函数来从不同的青蛙列表中过滤相同性别的青蛙！</p><p id="54c2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在，我们可以从多个青蛙列表中筛选出雌性，而无需编写太多代码:</p><pre class="kj kk kl km gt ma lz mb mc aw md bi"><span id="dfff" class="me mf it lz b gy mg mh l mi mj">const frogsList = [<br/>  // Yes, these frogs are intelligent. They know how to use email<br/>  {<br/>    name: 'bobTheFrog',<br/>    email: 'froggy@gmail.com',<br/>    age: 2,<br/>    gender: 'Male',<br/>    widthOfTongue: 3,<br/>  },<br/>  {<br/>    name: 'hippoTheFrog',<br/>    email: 'hippo@gmail.com',<br/>    age: 10,<br/>    gender: 'Male',<br/>    widthOfTongue: 11,<br/>  },<br/>  {<br/>    name: 'sally',<br/>    email: 'sallyLipstick@gmail.com',<br/>    age: 5,<br/>    gender: 'Female',<br/>    widthOfTongue: 4,<br/>  },<br/>  {<br/>    name: 'george',<br/>    email: 'georgeRoseBowl@gmail.com',<br/>    age: 11,<br/>    gender: 'Male',<br/>    widthOfTongue: 3,<br/>  },<br/>  {<br/>    name: 'lisa',<br/>    email: 'lisaLovesGeorgeForever@gmail.com',<br/>    age: 19,<br/>    gender: 'Female',<br/>    widthOfTongue: 15,<br/>  },<br/>  {<br/>    name: 'kentucky',<br/>    email: 'frogInKentucky@yahoo.com',<br/>    age: 18,<br/>    gender: 'Male',<br/>    widthOfTongue: 13,<br/>  },<br/>]<br/><br/>const frogsList2 = [<br/>  {<br/>    name: 'abc',<br/>    email: 'froggy@gmail.com',<br/>    age: 2,<br/>    gender: 'Male',<br/>    widthOfTongue: 1,<br/>  },<br/>  {<br/>    name: '123',<br/>    email: 'hippo@gmail.com',<br/>    age: 10,<br/>    gender: 'Male',<br/>    widthOfTongue: 4,<br/>  },<br/>  {<br/>    name: 'joe',<br/>    email: 'sallyLipstick@aol.com',<br/>    age: 5,<br/>    gender: 'Female',<br/>    widthOfTongue: 6,<br/>  },<br/>  {<br/>    name: 'jennifer',<br/>    email: 'georgeRoseBowl@aol.com',<br/>    age: 11,<br/>    gender: 'Female',<br/>    widthOfTongue: 10,<br/>  },<br/>]<br/><br/>const frogsList3 = [<br/>  {<br/>    name: 'professorHammick',<br/>    email: 'froggy@gmail.com',<br/>    age: 2,<br/>    gender: 'Female',<br/>    widthOfTongue: 1,<br/>  },<br/>  {<br/>    name: 'macintosh',<br/>    email: 'hippo@gmail.com',<br/>    age: 10,<br/>    gender: 'Female',<br/>    widthOfTongue: 6,<br/>  },<br/>  {<br/>    name: 'frogger',<br/>    email: 'sallyLipstick@gmail.com',<br/>    age: 5,<br/>    gender: 'Female',<br/>    widthOfTongue: 4,<br/>  },<br/>  {<br/>    name: 'frogNation',<br/>    email: 'georgeRoseBowl@gmail.com',<br/>    age: 11,<br/>    gender: 'Female',<br/>    widthOfTongue: 4,<br/>  },<br/>]<br/><br/>function gatherFemaleFrogsEverywhere(...frogLists) {<br/>  const allFemaleFrogs = []<br/>  const filterFemaleFrogs = filterGender('Female')<br/>  frogLists.forEach(function(list) {<br/>    allFemaleFrogs.push(...filterFemaleFrogs(list))<br/>  })<br/>  return allFemaleFrogs<br/>}<br/><br/>const females = gatherFemaleFrogsEverywhere(frogsList, frogsList2, frogsList3)</span></pre></div><div class="ab cl mk ml hx mm" role="separator"><span class="mn bw bk mo mp mq"/><span class="mn bw bk mo mp mq"/><span class="mn bw bk mo mp"/></div><div class="im in io ip iq"><h1 id="ac14" class="mr mf it bd ms mt mu mv mw mx my mz na jz nb ka nc kc nd kd ne kf nf kg ng nh bi translated">更进一步</h1><p id="3945" class="pw-post-body-paragraph kz la it lb b lc ni ju le lf nj jx lh li nk lk ll lm nl lo lp lq nm ls lt lu im bi translated">如果您<em class="lv">仍然不相信</em>JavaScript语言中的高阶函数有多强大，那么让我们继续这个例子，让<em class="lv">成为一个更通用的函数，</em>创建一个更高级别的可重用性:</p><pre class="kj kk kl km gt ma lz mb mc aw md bi"><span id="1fec" class="me mf it lz b gy mg mh l mi mj">function filterFrogs(filter) {<br/>  return function(frogs) {<br/>    return frogs.filter(filter)<br/>  }<br/>}</span></pre><p id="ae9d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">以前，我们有能力为青蛙的性别创建一个可重复使用的函数。然而，我们可以进一步抽象出<code class="fe lw lx ly lz b">filter</code>函数的逻辑，这样现在我们就可以组合和重用<em class="lv">不同的过滤函数</em>！</p><pre class="kj kk kl km gt ma lz mb mc aw md bi"><span id="d98d" class="me mf it lz b gy mg mh l mi mj">const filterMaleFrogs = filterFrogs(function(frog) {<br/>  return frog.gender === 'Male'<br/>})<br/><br/>const filterAdultFrogs = filterFrogs(function(frog) {<br/>  return frog.age &gt;= 10<br/>})<br/><br/>const filterFrogNamesThatStartWithHippo = filterFrogs(function(frog) {<br/>  return frog.name.toLowerCase().startsWith('hippo')<br/>})<br/><br/>const filterGmailEmails = filterFrogs(function(frog) {<br/>  return /gmail.com/i.test(frog.email)<br/>})</span></pre><p id="ed8a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">哇！</p><p id="914f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">以前，我们有一个惊人的能力，可以重用性别过滤器函数，而不必再次声明相同的性别类型。现在我们有了额外的能力来创建和重用<em class="lv">我们希望如何过滤青蛙的函数— </em>太棒了！</p><p id="eeec" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们甚至可以同时使用它们:</p><pre class="kj kk kl km gt ma lz mb mc aw md bi"><span id="d0ff" class="me mf it lz b gy mg mh l mi mj">function applyAllFilters(...filters) {<br/>  return function(frogs) {<br/>    let newFrogs = [...frogs]<br/>    for (let index = 0; index &lt; filters.length; index++) {<br/>      const filter = filters[index]<br/>      newFrogs = filter(newFrogs)<br/>    }<br/>    return newFrogs<br/>  }<br/>}<br/><br/>const applyFrogFilterers = applyAllFilters(<br/>  filterMaleFrogs,<br/>  filterAdultFrogs,<br/>  filterFrogNamesThatStartWithHippo,<br/>  filterGmailEmails,<br/>)<br/><br/>const combinedFrogsList = [...frogsList, ...frogsList2, ...frogsList3]<br/><br/>const filteredFrogs = applyFrogFilterers(combinedFrogsList)<br/><br/>console.log(filteredFrogs)<br/><br/>/*<br/>      result:<br/>        {<br/>          age: 10,<br/>          email: "hippo@gmail.com",<br/>          gender: "Male",<br/>          name: "hippoTheFrog",<br/>          widthOfTongue: 11<br/>        }<br/>*/</span></pre></div><div class="ab cl mk ml hx mm" role="separator"><span class="mn bw bk mo mp mq"/><span class="mn bw bk mo mp mq"/><span class="mn bw bk mo mp"/></div><div class="im in io ip iq"><h1 id="8bec" class="mr mf it bd ms mt mu mv mw mx my mz na jz nb ka nc kc nd kd ne kf nf kg ng nh bi translated">最后一次更进一步</h1><p id="518d" class="pw-post-body-paragraph kz la it lb b lc ni ju le lf nj jx lh li nk lk ll lm nl lo lp lq nm ls lt lu im bi translated">我们的<code class="fe lw lx ly lz b">applyAllFilters</code>函数做得很好。然而，对于庞大的青蛙列表，这可能会成为一项繁重的任务，因为它要多次运行<code class="fe lw lx ly lz b">filter</code>才能得到最终结果。</p><p id="a398" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们可以再次使用高阶函数的概念来制作一个简单的、可重用的高阶函数，它能够通过同时应用过滤器来使一个<em class="lv">通过整个青蛙列表。</em></p><p id="8346" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">更清楚地说，看一下<em class="lv"> for循环</em>代码，试着看看幕后真正发生了什么:</p><pre class="kj kk kl km gt ma lz mb mc aw md bi"><span id="f255" class="me mf it lz b gy mg mh l mi mj">function applyAllFilters(...filters) {<br/>  return function(frogs) {<br/>    let newFrogs = [...frogs]<br/>    for (let index = 0; index &lt; filters.length; index++) {<br/>      const filter = filters[index]<br/>      newFrogs = filter(newFrogs)<br/>    }<br/>    return newFrogs<br/>  }<br/>}</span></pre><p id="5909" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我想让你看看这条线:</p><pre class="kj kk kl km gt ma lz mb mc aw md bi"><span id="472f" class="me mf it lz b gy mg mh l mi mj">newFrogs = filter(newFrogs)</span></pre><p id="1eac" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">该行代码与该函数中的<code class="fe lw lx ly lz b">return frogs.filter(filter)</code>代码相同:</p><pre class="kj kk kl km gt ma lz mb mc aw md bi"><span id="242a" class="me mf it lz b gy mg mh l mi mj">function filterFrogs(filter) {<br/>  return function(frogs) {<br/>    return frogs.filter(filter)<br/>  }<br/>}</span></pre><p id="97ea" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这是一个问题，因为过滤方法<em class="lv">创建了一个新的数组</em>。当我们写下这些时:</p><pre class="kj kk kl km gt ma lz mb mc aw md bi"><span id="7c1f" class="me mf it lz b gy mg mh l mi mj">const applyFrogFilterers = applyAllFilters(<br/>  filterMaleFrogs,<br/>  filterAdultFrogs,<br/>  filterFrogNamesThatStartWithHippo,<br/>  filterGmailEmails,<br/>)</span></pre><p id="7a35" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们调用filter方法四次。换句话说，我们让JavaScript在内存中创建四个不同的数组，只是为了得到最终结果。</p><p id="bdcf" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">那么，我们如何让JavaScript只创建一个<em class="lv">T4数组，最终得到相同的结果呢？</em></p><p id="f874" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">你猜对了。使用高阶函数！</p><pre class="kj kk kl km gt ma lz mb mc aw md bi"><span id="af4c" class="me mf it lz b gy mg mh l mi mj">// NOTE: The filter functions are now individual functions (not wrapped with filterFrogs)</span><span id="aaf6" class="me mf it lz b gy no mh l mi mj">const filterMaleFrogs = function(frog) {<br/>  return frog.gender === 'Male'<br/>}</span><span id="9e6b" class="me mf it lz b gy no mh l mi mj">const filterAdultFrogs = function(frog) {<br/>  return frog.age &gt;= 10<br/>}</span><span id="1bbd" class="me mf it lz b gy no mh l mi mj">const filterFrogNamesThatStartWithHippo = function(frog) {<br/>  return frog.name.toLowerCase().startsWith('hippo')<br/>}</span><span id="e954" class="me mf it lz b gy no mh l mi mj">const filterGmailEmails = function(frog) {<br/>  return /gmail.com/i.test(frog.email)<br/>}</span><span id="50e9" class="me mf it lz b gy no mh l mi mj">function combineFilters(...fns) {<br/>  return function(val) {<br/>    for (let i = 0; i &lt; fns.length; i++) {<br/>      const filter = fns[i]<br/>      const passes = filter(val)<br/>      if (passes) {<br/>        continue<br/>      } else {<br/>        return false<br/>      }<br/>    }<br/>    return true<br/>  }<br/>}</span><span id="ceb6" class="me mf it lz b gy no mh l mi mj">function composeFrogFilterers(...fns) {<br/>  return function(frogs) {<br/>    return frogs.filter(combineFilters(...fns))<br/>  }<br/>}</span><span id="247f" class="me mf it lz b gy no mh l mi mj">const applyFrogFilterers = composeFrogFilterers(<br/>  filterMaleFrogs,<br/>  filterAdultFrogs,<br/>  filterFrogNamesThatStartWithHippo,<br/>  filterGmailEmails,<br/>)</span><span id="c9c4" class="me mf it lz b gy no mh l mi mj">const combinedFrogsList = [...frogsList, ...frogsList2, ...frogsList3]</span><span id="4312" class="me mf it lz b gy no mh l mi mj">const allFilteredFrogs = applyFrogFilterers(combinedFrogsList)</span><span id="1af4" class="me mf it lz b gy no mh l mi mj">console.log(allFilteredFrogs)</span><span id="e8f6" class="me mf it lz b gy no mh l mi mj">/*<br/>      result:<br/>        {<br/>          age: 10,<br/>          email: "<a class="ae nn" href="mailto:hippo@gmail.com" rel="noopener ugc nofollow" target="_blank">hippo@gmail.com</a>",<br/>          gender: "Male",<br/>          name: "hippoTheFrog",<br/>          widthOfTongue: 11<br/>        }<br/>*/</span></pre></div><div class="ab cl mk ml hx mm" role="separator"><span class="mn bw bk mo mp mq"/><span class="mn bw bk mo mp mq"/><span class="mn bw bk mo mp"/></div><div class="im in io ip iq"><h1 id="4a8b" class="mr mf it bd ms mt mu mv mw mx my mz na jz nb ka nc kc nd kd ne kf nf kg ng nh bi translated">结论</h1><p id="35d7" class="pw-post-body-paragraph kz la it lb b lc ni ju le lf nj jx lh li nk lk ll lm nl lo lp lq nm ls lt lu im bi translated">我希望您相信高阶函数是多么强大，并且通过阅读本文，您已经深入了解了这个概念的用例。</p><p id="076b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">以后多多关照！</p></div></div>    
</body>
</html>