<html>
<head>
<title>Refactoring Fetch to Async/Await</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">重构提取到异步/等待</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/promises-with-async-await-605645a6c0e8?source=collection_archive---------0-----------------------#2020-08-09">https://betterprogramming.pub/promises-with-async-await-605645a6c0e8?source=collection_archive---------0-----------------------#2020-08-09</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="1878" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">清理您的代码，使您的API请求更容易理解和调试</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/5f5eee488e494bbc15995b1a87f6a683.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*O5h71XhA7DuN5Cov"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">戴夫·弗朗西斯在<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片。</p></figure><p id="e0be" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe lv lw lx ly b">Async/await</code>是过去几年中添加到<a class="ae ky" href="https://hackernoon.com/tagged/JavaScript?ref=hackernoon.com" rel="noopener ugc nofollow" target="_blank"> JavaScript </a>中的最具革命性的特性之一。它提供了一个直观的替代品来代替承诺有时会出现的语法混乱。</p><p id="9a02" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">优秀的老式<a class="ae ky" href="https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API" rel="noopener ugc nofollow" target="_blank">获取API </a>没有任何问题，它在默认情况下可用于发出ajax请求等等。</p><blockquote class="lz ma mb"><p id="3a86" class="kz la mc lb b lc ld ju le lf lg jx lh md lj lk ll me ln lo lp mf lr ls lt lu im bi translated">“<a class="ae ky" href="https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API" rel="noopener ugc nofollow" target="_blank"> Fetch API </a>提供了一个JavaScript接口，用于访问和操作HTTP管道的各个部分，比如请求和响应。它还提供了一个全局<code class="fe lv lw lx ly b"><a class="ae ky" href="https://developer.mozilla.org/en-US/docs/Web/API/GlobalFetch/fetch" rel="noopener ugc nofollow" target="_blank">fetch()</a></code>方法，该方法提供了一种简单、逻辑的方式来通过网络异步获取资源。”— <a class="ae ky" href="https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API/Using_Fetch" rel="noopener ugc nofollow" target="_blank"> MDN网络文档</a></p></blockquote><p id="51ab" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">一个基本的<code class="fe lv lw lx ly b">fetch</code>请求很容易建立。看一下下面的代码:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mg mh l"/></div></figure></div><div class="ab cl mi mj hx mk" role="separator"><span class="ml bw bk mm mn mo"/><span class="ml bw bk mm mn mo"/><span class="ml bw bk mm mn"/></div><div class="im in io ip iq"><h1 id="4e47" class="mp mq it bd mr ms mt mu mv mw mx my mz jz na ka nb kc nc kd nd kf ne kg nf ng bi translated">异步/等待101</h1><p id="978d" class="pw-post-body-paragraph kz la it lb b lc nh ju le lf ni jx lh li nj lk ll lm nk lo lp lq nl ls lt lu im bi translated"><code class="fe lv lw lx ly b">Async/await</code>是一种相对较新的(所谓ECMAScript 2017 JavaScript edition的一部分)编写异步代码的方式。以前异步代码的替代方法是回调和承诺。Async/await实际上只是建立在承诺之上的语法糖，它使异步代码看起来和行为更像同步代码。一些人认为这使得发现异步代码更加困难，可能需要一些时间来适应。</p><p id="ed8f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">需要注意的是，<code class="fe lv lw lx ly b">await</code>关键字不能在<code class="fe lv lw lx ly b">async</code>函数之外使用。</p><h2 id="b9e0" class="nm mq it bd mr nn no dn mv np nq dp mz li nr ns nb lm nt nu nd lq nv nw nf nx bi translated">接受异步/等待的理由</h2><ul class=""><li id="0456" class="ny nz it lb b lc nh lf ni li oa lm ob lq oc lu od oe of og bi translated">它使代码简洁明了。</li><li id="85f2" class="ny nz it lb b lc oh lf oi li oj lm ok lq ol lu od oe of og bi translated">它允许我们避免嵌套代码。</li><li id="4e0e" class="ny nz it lb b lc oh lf oi li oj lm ok lq ol lu od oe of og bi translated">使用<code class="fe lv lw lx ly b">try/catch</code>可以处理同步和异步错误。</li><li id="2572" class="ny nz it lb b lc oh lf oi li oj lm ok lq ol lu od oe of og bi translated">调试要容易得多(我确信我不用告诉你去想办法在<code class="fe lv lw lx ly b">fetch</code>函数中把调试器放在哪里)。</li></ul><h2 id="c32e" class="nm mq it bd mr nn no dn mv np nq dp mz li nr ns nb lm nt nu nd lq nv nw nf nx bi translated">通过三个简单的步骤将fetch转换为async/await</h2><p id="62a1" class="pw-post-body-paragraph kz la it lb b lc nh ju le lf ni jx lh li nj lk ll lm nk lo lp lq nl ls lt lu im bi translated">下面是我们将为这个示例转换的函数:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mg mh l"/></div></figure><p id="ed04" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">识别异步函数并将<code class="fe lv lw lx ly b">async</code>放在它的前面:</p><pre class="kj kk kl km gt om ly on oo aw op bi"><span id="0d43" class="nm mq it ly b gy oq or l os ot">async function fetchAlbums() {<br/>...<br/>}</span></pre><p id="f599" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">确定函数中所有不同的承诺，并在每个承诺前添加<code class="fe lv lw lx ly b">await</code>。将它们分配给变量:</p><pre class="kj kk kl km gt om ly on oo aw op bi"><span id="ff01" class="nm mq it ly b gy oq or l os ot">const res = await fetch(apiUrl)<br/>const json = await res.json()</span></pre><p id="c4e1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">重构其余部分，使其看起来同步:</p><pre class="kj kk kl km gt om ly on oo aw op bi"><span id="7ddd" class="nm mq it ly b gy oq or l os ot">async function fetchAlbums() {<br/>    const response =  await fetch(apiUrl)<br/>    const json = await response.json()<br/>    console.log(json)<br/>}</span></pre><p id="c8be" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">使用<code class="fe lv lw lx ly b">async/await</code>不是为使用<code class="fe lv lw lx ly b">function</code>关键字的函数保留的。我们也可以将它用作箭头函数，尽管语法略有不同:</p><pre class="kj kk kl km gt om ly on oo aw op bi"><span id="c022" class="nm mq it ly b gy oq or l os ot">const fetchAlbums = async () =&gt; {<br/>    const response = await fetch(apiUrl)<br/>    const json = response.json()<br/>    console.log(json)<br/>}</span></pre><p id="62d2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">它也可以是一个匿名函数，如下例所示，我们的异步函数是传递给Google auth配置中的<code class="fe lv lw lx ly b">passport.use</code> <em class="mc"> </em>函数的参数之一。此处与<code class="fe lv lw lx ly b">fetch</code>配合使用:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mg mh l"/></div></figure><p id="30ad" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">用<code class="fe lv lw lx ly b">async/await</code>重构后:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mg mh l"/></div></figure></div></div>    
</body>
</html>