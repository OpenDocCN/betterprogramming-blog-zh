<html>
<head>
<title>hybrids.js — Declarative and Functional Web Components</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">hybrids.js —声明性和功能性Web组件</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/hybrids-js-declarative-and-functional-web-components-c0f1c3fbf1c8?source=collection_archive---------5-----------------------#2019-11-03">https://betterprogramming.pub/hybrids-js-declarative-and-functional-web-components-c0f1c3fbf1c8?source=collection_archive---------5-----------------------#2019-11-03</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="d455" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">Hybrids是一个UI库，用于创建基于简单对象和纯函数的强大的声明性和功能性方法的Web组件</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/520d39d752f097d6ca8df148f434ccb6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*tOFLy3UgHgARZCm9"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">照片由<a class="ae ky" href="https://unsplash.com/@clemhlrdt?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">克莱门特H </a>在<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</p></figure><p id="5de9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">Web Components是一套不同的技术，允许您创建可重用的自定义元素(将它们的功能封装在代码的其余部分之外)，并在您的Web应用程序中使用它们。</p><p id="03ea" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果你是web组件的新手，可以看看我以前的文章“Web组件API概述”</p><p id="e0f9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu">混合套件包括以下内容:</strong></p><ul class=""><li id="ef02" class="lv lw it lb b lc ld lf lg li lx lm ly lq lz lu ma mb mc md bi translated">最简单的定义——只有简单的对象和纯函数——没有<code class="fe me mf mg mh b">class</code>和<code class="fe me mf mg mh b">this</code>语法。</li><li id="e4b1" class="lv lw it lb b lc mi lf mj li mk lm ml lq mm lu ma mb mc md bi translated">没有全局生命周期—独立的属性有自己简化的生命周期方法。</li><li id="bef7" class="lv lw it lb b lc mi lf mj li mk lm ml lq mm lu ma mb mc md bi translated">继承之上的组合——易于重用、合并或拆分属性定义。</li><li id="d316" class="lv lw it lb b lc mi lf mj li mk lm ml lq mm lu ma mb mc md bi translated">超快速重新计算—内置智能缓存和更改检测机制。</li><li id="f2c6" class="lv lw it lb b lc mi lf mj li mk lm ml lq mm lu ma mb mc md bi translated">没有外部工具的模板——基于标记模板文字的模板引擎。</li><li id="c314" class="lv lw it lb b lc mi lf mj li mk lm ml lq mm lu ma mb mc md bi translated">包括开发人员工具—热模块更换支持，实现快速愉快的开发。</li></ul><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi mn"><img src="../Images/857c050699a0c371ca87027f55b261a0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*1Q3LqyWnIUIPD73j5IuSjQ.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated"><a class="ae ky" href="https://github.com/hybridsjs/hybrids" rel="noopener ugc nofollow" target="_blank">混血儿Github页面</a></p></figure></div><div class="ab cl mo mp hx mq" role="separator"><span class="mr bw bk ms mt mu"/><span class="mr bw bk ms mt mu"/><span class="mr bw bk ms mt"/></div><div class="im in io ip iq"><h1 id="e876" class="mv mw it bd mx my mz na nb nc nd ne nf jz ng ka nh kc ni kd nj kf nk kg nl nm bi translated">入门指南</h1><p id="62cb" class="pw-post-body-paragraph kz la it lb b lc nn ju le lf no jx lh li np lk ll lm nq lo lp lq nr ls lt lu im bi translated">用npm或纱线安装NPM组件。</p><h2 id="c2e2" class="ns mw it bd mx nt nu dn nb nv nw dp nf li nx ny nh lm nz oa nj lq ob oc nl od bi translated">NPM</h2><pre class="kj kk kl km gt oe mh of og aw oh bi"><span id="1d6d" class="ns mw it mh b gy oi oj l ok ol">npm i hybrids</span></pre><h2 id="86a1" class="ns mw it bd mx nt nu dn nb nv nw dp nf li nx ny nh lm nz oa nj lq ob oc nl od bi translated">故事</h2><pre class="kj kk kl km gt oe mh of og aw oh bi"><span id="b0c1" class="ns mw it mh b gy oi oj l ok ol">yarn add hybrids</span></pre><p id="ac35" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">然后，导入所需的特征并定义一个定制元素。这里有一个计数器的简单例子。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="om on l"/></div></figure><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi oo"><img src="../Images/8d1bd0fb0b9e221576951457817c65c3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*oK-JLKXIW_zltSYv85mQwg.gif"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">在<a class="ae ky" href="https://stackblitz.com/edit/hybrids-simple-counter?file=simple-counter.js" rel="noopener ugc nofollow" target="_blank"> StackBlitz </a>上运行演示。</p></figure><p id="6a31" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">最后，在HTML中使用您的自定义元素:</p><pre class="kj kk kl km gt oe mh of og aw oh bi"><span id="844a" class="ns mw it mh b gy oi oj l ok ol">&lt;simple-counter count="10"&gt;&lt;/simple-counter&gt;</span></pre><p id="04c0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">hybrids库为创建定制元素提供了一种简单的声明式方法。它的名字来源于这样一个想法，即它是功能性和面向对象的体系结构的混合，具有定义定制元素的独特方法，就像这样:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="om on l"/></div></figure><p id="9771" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">尽管上面的代码看起来很简单，但是应用了一些独特的概念，使得它成为可能。这个例子依赖于一起使用的三个与属性相关的概念:<a class="ae ky" href="/core-concepts/descriptors" rel="noopener ugc nofollow" target="_blank">描述符</a>、<a class="ae ky" href="/core-concepts/factories" rel="noopener ugc nofollow" target="_blank">工厂</a>和<a class="ae ky" href="/core-concepts/translation" rel="noopener ugc nofollow" target="_blank">翻译</a>。</p><p id="6aaf" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">此外，该库使用变更检测和缓存机制来简化组件的生命周期。</p><h2 id="b6b5" class="ns mw it bd mx nt nu dn nb nv nw dp nf li nx ny nh lm nz oa nj lq ob oc nl od bi translated">简化的组件生命周期</h2><p id="20e7" class="pw-post-body-paragraph kz la it lb b lc nn ju le lf no jx lh li np lk ll lm nq lo lp lq nr ls lt lu im bi translated">与普通解决方案相比，组件的生命周期是相反的。通常状态计算的结果在这里是该计算的原因。每一个单独的属性(包括<code class="fe me mf mg mh b">render</code>)都是独立的。如果它需要组件的其他属性，它会调用它们。只有这样，才计算这些属性的值。我们可以用下图来说明这一点:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi op"><img src="../Images/0b577e02c6b80793ad2fe947e04f5e6d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*R6X9s-8LfC_7RVKXK_aWyQ.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">具有缓存和变更检测的生命周期</p></figure><p id="756e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">render属性(一个操作DOM的更新函数)需要从其他属性获取当前状态，而不是相反。不需要在某个生命周期回调中设置状态(即使是异步获取的数据)。变化检测机制允许仅当组件属性之一变化时触发更新功能。</p><p id="2071" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">因此，我们可以轻松地创建一个组件结构，作为属性(输入)和纯呈现函数(输出)的列表，将组件的当前状态反映给DOM。</p><p id="5373" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在这个概念中，副作用超出了组件的范围。它们是用户输入或附加到组件内部结构的其他DOM事件的结果。库中使用的呈现模式允许我们将它们实现为普通函数，接受自定义元素实例并更改属性值(输入)。这些变化最终会使属性更新，但只是在需要的时候。</p><h2 id="c463" class="ns mw it bd mx nt nu dn nb nv nw dp nf li nx ny nh lm nz oa nj lq ob oc nl od bi translated">ES模块</h2><p id="4b36" class="pw-post-body-paragraph kz la it lb b lc nn ju le lf no jx lh li np lk ll lm nq lo lp lq nr ls lt lu im bi translated">如果你的目标是现代浏览器，并且不想使用外部工具(像<a class="ae ky" href="https://webpack.js.org/" rel="noopener ugc nofollow" target="_blank"> webpack </a>或<a class="ae ky" href="https://parceljs.org/" rel="noopener ugc nofollow" target="_blank">package</a>，你可以使用ES模块:</p><pre class="kj kk kl km gt oe mh of og aw oh bi"><span id="c66a" class="ns mw it mh b gy oi oj l ok ol">&lt;script type="module"&gt;</span><span id="5a4a" class="ns mw it mh b gy oq oj l ok ol">// We can use "/src" here - browsers, which support modules also support ES2015</span><span id="464b" class="ns mw it mh b gy oq oj l ok ol">import { html, define } from 'https://unpkg.com/hybrids@[PUT_VERSION_HERE:x.x.x]/src';</span><span id="0530" class="ns mw it mh b gy oq oj l ok ol">...</span><span id="84ab" class="ns mw it mh b gy oq oj l ok ol">&lt;/script&gt;</span></pre><p id="d909" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">请考虑这样一个事实，即它不提供代码精简，并且在单独的请求中加载所有需要的文件。</p><h2 id="1f02" class="ns mw it bd mx nt nu dn nb nv nw dp nf li nx ny nh lm nz oa nj lq ob oc nl od bi translated">热模块更换</h2><p id="39b9" class="pw-post-body-paragraph kz la it lb b lc nn ju le lf no jx lh li np lk ll lm nq lo lp lq nr ls lt lu im bi translated">HMR开箱即用，但您的bundler设置可能需要您的入口点支持它的指示。对于<code class="fe me mf mg mh b"><a class="ae ky" href="https://webpack.js.org/" rel="noopener ugc nofollow" target="_blank">webpack</a></code>和<code class="fe me mf mg mh b"><a class="ae ky" href="https://parceljs.org/" rel="noopener ugc nofollow" target="_blank">parcel</a></code>，将以下代码添加到您的入口点:</p><pre class="kj kk kl km gt oe mh of og aw oh bi"><span id="b996" class="ns mw it mh b gy oi oj l ok ol">// Enable HMR for development</span><span id="e416" class="ns mw it mh b gy oq oj l ok ol">if (process.env.NODE_ENV !== 'production') module.hot.accept();</span></pre><p id="d4a0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果您的入口点导入不支持HMR的文件，您可以将上面的代码片段放在一个定义自定义元素的模块中。(此处使用<code class="fe me mf mg mh b">define</code>方法)。</p><h2 id="10d0" class="ns mw it bd mx nt nu dn nb nv nw dp nf li nx ny nh lm nz oa nj lq ob oc nl od bi translated">证明文件</h2><p id="1aca" class="pw-post-body-paragraph kz la it lb b lc nn ju le lf no jx lh li np lk ll lm nq lo lp lq nr ls lt lu im bi translated">混合动力文档可在<a class="ae ky" href="https://hybrids.js.org/" rel="noopener ugc nofollow" target="_blank">hybrids.js.org</a>或存储库的<a class="ae ky" href="https://github.com/hybridsjs/hybrids/tree/16dbbac62905347d9e05deac4e6f86c8232b5ab9/docs/README.md" rel="noopener ugc nofollow" target="_blank">文档</a>路径中获得:</p><ul class=""><li id="866d" class="lv lw it lb b lc ld lf lg li lx lm ly lq lz lu ma mb mc md bi translated"><a class="ae ky" href="https://github.com/hybridsjs/hybrids/tree/16dbbac62905347d9e05deac4e6f86c8232b5ab9/docs/core-concepts/README.md" rel="noopener ugc nofollow" target="_blank">核心概念</a></li><li id="5cff" class="lv lw it lb b lc mi lf mj li mk lm ml lq mm lu ma mb mc md bi translated"><a class="ae ky" href="https://github.com/hybridsjs/hybrids/tree/16dbbac62905347d9e05deac4e6f86c8232b5ab9/docs/built-in-factories/README.md" rel="noopener ugc nofollow" target="_blank">内置工厂</a></li><li id="9182" class="lv lw it lb b lc mi lf mj li mk lm ml lq mm lu ma mb mc md bi translated"><a class="ae ky" href="https://github.com/hybridsjs/hybrids/tree/16dbbac62905347d9e05deac4e6f86c8232b5ab9/docs/template-engine/README.md" rel="noopener ugc nofollow" target="_blank">模板引擎</a></li><li id="97d8" class="lv lw it lb b lc mi lf mj li mk lm ml lq mm lu ma mb mc md bi translated"><a class="ae ky" href="https://github.com/hybridsjs/hybrids/tree/16dbbac62905347d9e05deac4e6f86c8232b5ab9/docs/misc/README.md" rel="noopener ugc nofollow" target="_blank">杂项</a></li></ul></div><div class="ab cl mo mp hx mq" role="separator"><span class="mr bw bk ms mt mu"/><span class="mr bw bk ms mt mu"/><span class="mr bw bk ms mt"/></div><div class="im in io ip iq"><h1 id="d178" class="mv mw it bd mx my mz na nb nc nd ne nf jz ng ka nh kc ni kd nj kf nk kg nl nm bi translated">活生生的例子</h1><p id="e9f2" class="pw-post-body-paragraph kz la it lb b lc nn ju le lf no jx lh li np lk ll lm nq lo lp lq nr ls lt lu im bi translated">这里有几个用hybrids web组件构建的项目的例子。</p><ul class=""><li id="8926" class="lv lw it lb b lc ld lf lg li lx lm ly lq lz lu ma mb mc md bi translated"><a class="ae ky" href="https://stackblitz.com/edit/hybrids-simple-counter?file=simple-counter.js" rel="noopener ugc nofollow" target="_blank"> &lt;简单计数器&gt; </a> —计数器受自身状态控制的按钮</li><li id="bdd0" class="lv lw it lb b lc mi lf mj li mk lm ml lq mm lu ma mb mc md bi translated"><a class="ae ky" href="https://stackblitz.com/edit/hybrids-redux-counter?file=redux-counter.js" rel="noopener ugc nofollow" target="_blank">&lt;-redux-counter&gt;</a>-状态管理的Redux库</li><li id="0902" class="lv lw it lb b lc mi lf mj li mk lm ml lq mm lu ma mb mc md bi translated"><a class="ae ky" href="https://stackblitz.com/edit/hybrids-react-counter?file=react-counter.js" rel="noopener ugc nofollow" target="_blank">&lt;React-counter&gt;</a>—渲染工厂和<a class="ae ky" href="https://reactjs.org/" rel="noopener ugc nofollow" target="_blank"> React </a>库在阴影DOM中进行渲染</li><li id="e81b" class="lv lw it lb b lc mi lf mj li mk lm ml lq mm lu ma mb mc md bi translated"><a class="ae ky" href="https://stackblitz.com/edit/hybrids-lit-html-counter?file=lit-counter.js" rel="noopener ugc nofollow" target="_blank">&lt;lit-counter&gt;</a>—渲染工厂和<a class="ae ky" href="https://lit-html.polymer-project.org/" rel="noopener ugc nofollow" target="_blank"> lit-html </a>用于阴影DOM中的渲染</li><li id="5d61" class="lv lw it lb b lc mi lf mj li mk lm ml lq mm lu ma mb mc md bi translated"><a class="ae ky" href="https://stackblitz.com/edit/hybrids-parent-factory?file=index.js" rel="noopener ugc nofollow" target="_blank"> &lt; app-todos &gt; </a> —利用母厂进行状态管理的待办事项</li><li id="f05a" class="lv lw it lb b lc mi lf mj li mk lm ml lq mm lu ma mb mc md bi translated"><a class="ae ky" href="https://stackblitz.com/edit/hybrids-children-factory?file=index.js" rel="noopener ugc nofollow" target="_blank"> &lt;标签组&gt; </a> —使用子工厂切换标签</li><li id="f6f6" class="lv lw it lb b lc mi lf mj li mk lm ml lq mm lu ma mb mc md bi translated"><a class="ae ky" href="https://stackblitz.com/edit/hybrids-async-user?file=async-user.js" rel="noopener ugc nofollow" target="_blank"> &lt;异步用户&gt; </a> —模板中的异步数据</li></ul></div><div class="ab cl mo mp hx mq" role="separator"><span class="mr bw bk ms mt mu"/><span class="mr bw bk ms mt mu"/><span class="mr bw bk ms mt"/></div><div class="im in io ip iq"><h1 id="5b06" class="mv mw it bd mx my mz na nb nc nd ne nf jz ng ka nh kc ni kd nj kf nk kg nl nm bi translated">浏览器支持</h1><p id="e718" class="pw-post-body-paragraph kz la it lb b lc nn ju le lf no jx lh li np lk ll lm nq lo lp lq nr ls lt lu im bi translated">混合库被大多数浏览器广泛支持。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi or"><img src="../Images/23208ea4911f1c10284abe18e8294fb7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*GMIo5pZ_D_BQBI4LESPWWg.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">混合浏览器支持</p></figure></div><div class="ab cl mo mp hx mq" role="separator"><span class="mr bw bk ms mt mu"/><span class="mr bw bk ms mt mu"/><span class="mr bw bk ms mt"/></div><div class="im in io ip iq"><h1 id="418d" class="mv mw it bd mx my mz na nb nc nd ne nf jz ng ka nh kc ni kd nj kf nk kg nl nm bi translated">结论</h1><p id="2fac" class="pw-post-body-paragraph kz la it lb b lc nn ju le lf no jx lh li np lk ll lm nq lo lp lq nr ls lt lu im bi translated">感谢阅读，我希望你发现了一些新的有用的东西。保持好奇，快乐编码！</p></div></div>    
</body>
</html>