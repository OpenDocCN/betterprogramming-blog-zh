<html>
<head>
<title>Secure Services With Let’s Encrypt SSL/TLS Certificates Using DNS-01 Challenges</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">安全服务让我们使用DNS-01挑战加密SSL/TLS证书</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/ssl-certificates-with-lets-encrypt-and-dns-01-3315a5a9f706?source=collection_archive---------4-----------------------#2022-09-10">https://betterprogramming.pub/ssl-certificates-with-lets-encrypt-and-dns-01-3315a5a9f706?source=collection_archive---------4-----------------------#2022-09-10</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="2b88" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">Go中的一个实现</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/927fb9d632fcc49f3ff28633cd9efc96.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*RGLh2e0eLWSrrBpq"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">照片由<a class="ae kv" href="https://unsplash.com/@flyd2069?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">飞:D </a>在<a class="ae kv" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a></p></figure><p id="0905" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">现在是2022年，不安全的网站已经成为过去。大多数浏览器甚至不允许你连接到一个通过HTTP服务的网站。</p><p id="ff07" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">然而，这并没有改变处理SSL证书可能很麻烦的事实。您有几个选择:</p><ul class=""><li id="65c9" class="ls lt iq ky b kz la lc ld lf lu lj lv ln lw lr lx ly lz ma bi translated">走传统的路，从众多提供商那里购买SSL证书</li><li id="3c81" class="ls lt iq ky b kz mb lc mc lf md lj me ln mf lr lx ly lz ma bi translated">或者从<a class="ae kv" href="https://letsencrypt.org/" rel="noopener ugc nofollow" target="_blank">免费得到一个让我们加密</a></li></ul><blockquote class="mg mh mi"><p id="a9f3" class="kw kx mj ky b kz la jr lb lc ld ju le mk lg lh li ml lk ll lm mm lo lp lq lr ij bi translated">我想指出的是，免费并不总是更好。不同的提供商提供不同级别的安全性和其他功能，这些我们加密可能没有。但是有些安全比没有安全好太多了！</p></blockquote><p id="e83b" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">你可能已经怀疑有一个陷阱。让我们加密发行有效期为<a class="ae kv" href="https://letsencrypt.org/docs/faq/#what-is-the-lifetime-for-let-s-encrypt-certificates-for-how-long-are-they-valid" rel="noopener ugc nofollow" target="_blank"> 90天</a>的证书，而传统提供商的有效期为<a class="ae kv" href="https://blog.mozilla.org/security/2020/07/09/reducing-tls-certificate-lifespans-to-398-days/" rel="noopener ugc nofollow" target="_blank">一年多一点</a>。后者确实使处理证书刷新过程更容易一些(因为您只需每周刷新一次，所以更快地刷新和过期证书实际上更安全，因为如果证书的私钥被第三方窃取，它会减少攻击发生的时间。</p><p id="a3ea" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">然而，这增加了<a class="ae kv" href="https://sre.google/sre-book/eliminating-toil/" rel="noopener ugc nofollow" target="_blank">的工作量</a>，因为下一次刷新总是即将到来。而且，您可能从多台服务器上为您的资产提供服务，增加了每次证书过期时所需的手动工作量，这种情况也不是没有过。</p></div><div class="ab cl mn mo hu mp" role="separator"><span class="mq bw bk mr ms mt"/><span class="mq bw bk mr ms mt"/><span class="mq bw bk mr ms"/></div><div class="ij ik il im in"><p id="98d8" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">到目前为止，应该很清楚，与Let's Encrypt的任何交互都应该是自动化的。幸运的是，他们从一开始就支持这个流程，使用了<a class="ae kv" href="https://en.wikipedia.org/wiki/Automatic_Certificate_Management_Environment" rel="noopener ugc nofollow" target="_blank"> ACME协议</a>(就是为了这个目的而发明的)。</p><p id="2583" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">如果你运行一个标准的基于HTTP的服务，网站等。，你会发现有大量的选项(工具)来解决这个问题:</p><ul class=""><li id="428b" class="ls lt iq ky b kz la lc ld lf lu lj lv ln lw lr lx ly lz ma bi translated"><a class="ae kv" href="https://certbot.eff.org/" rel="noopener ugc nofollow" target="_blank"> certbot </a> —参考ACME实现</li><li id="bdd5" class="ls lt iq ky b kz mb lc mc lf md lj me ln mf lr lx ly lz ma bi translated"><a class="ae kv" href="https://caddyserver.com/" rel="noopener ugc nofollow" target="_blank"> caddy </a> —基于Golang的HTTP服务器</li><li id="e7eb" class="ls lt iq ky b kz mb lc mc lf md lj me ln mf lr lx ly lz ma bi translated">或者用你能想到的任何编程语言编写的数十种其他的实现</li></ul><p id="c945" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">有一个问题— HTTP是关键字。这些实现中的大多数(如果不是全部的话)都假设您正在运行一个web服务器，或者可以通过HTTP以某种方式公开一个服务，以便客户端可以确认它控制着为其颁发证书的域。</p><p id="d58a" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">但是如果不能呢！？如果您只能公开一个端口(并且不是针对HTTP的)，或者如果您在一个有空隙的环境中运行一个服务，该环境只能连接到外部，而不允许传入流量，那该怎么办？</p><h1 id="b6aa" class="mu mv iq bd mw mx my mz na nb nc nd ne jw nf jx ng jz nh ka ni kc nj kd nk nl bi translated">输入DNS-01挑战</h1><p id="bcd1" class="pw-post-body-paragraph kw kx iq ky b kz nm jr lb lc nn ju le lf no lh li lj np ll lm ln nq lp lq lr ij bi translated">根据“让我们加密文档”:</p><blockquote class="mg mh mi"><p id="7716" class="kw kx mj ky b kz la jr lb lc ld ju le mk lg lh li ml lk ll lm mm lo lp lq lr ij bi translated">该挑战要求您通过在该域名下的TXT记录中输入一个特定值来证明您控制了该域名的DNS。</p></blockquote><p id="6c6c" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我无法立即找到支持这一流程的客户端。这部分是因为DNS是一个协议，而不是一个API。在我的例子中，<a class="ae kv" href="https://mihaibojin.medium.com/hosting-my-site-on-vercel-7ea2235c2a78#bbb0" rel="noopener">我使用Cloudflare </a>管理我的所有域，所以我需要<em class="mj">一个能够在Cloudflare上更新TXT记录的ACME客户端— </em>这不是我想到的第一个组合…</p><p id="38fe" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">Cloudflare是众多DNS托管平台中的一个——构建和维护一个涵盖大多数/所有此类平台的库的成本相对较高——我意识到我必须构建自己的库！</p><h1 id="9021" class="mu mv iq bd mw mx my mz na nb nc nd ne jw nf jx ng jz nh ka ni kc nj kd nk nl bi translated">使用Go编写ACME/Cloudflare客户端</h1><p id="875a" class="pw-post-body-paragraph kw kx iq ky b kz nm jr lb lc nn ju le lf no lh li lj np ll lm ln nq lp lq lr ij bi translated">最近，我一直在学习围棋。它是一种非常流行的语言，拥有健康的开发者生态系统。我喜欢的是，通常很容易就能找到各种可以解决大多数问题的库，比如满足以下需求:</p><ul class=""><li id="c491" class="ls lt iq ky b kz la lc ld lf lu lj lv ln lw lr lx ly lz ma bi translated"><a class="ae kv" href="https://pkg.go.dev/github.com/mholt/acmez" rel="noopener ugc nofollow" target="_blank"> acmez </a>:用于Go的ACME客户端库</li><li id="c99b" class="ls lt iq ky b kz mb lc mc lf md lj me ln mf lr lx ly lz ma bi translated"><a class="ae kv" href="https://pkg.go.dev/github.com/libdns/cloudflare" rel="noopener ugc nofollow" target="_blank"> libdns/cloudflare </a>:使用Cloudflare APIs的dns提供商</li></ul><p id="f244" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">让我们从一个简单的结构开始，来保存我们未来的SSL/TLS证书的配置。</p><pre class="kg kh ki kj gt nr ns nt nu aw nv bi"><span id="9bff" class="nw mv iq ns b gy nx ny l nz oa">type Config struct {<br/> CertificatePrivateKeyPath string<br/> CloudflareAPIToken        string<br/>}</span></pre><ul class=""><li id="7486" class="ls lt iq ky b kz la lc ld lf lu lj lv ln lw lr lx ly lz ma bi translated"><code class="fe ob oc od ns b">ACMEAccountPrivateKeyPath</code>:您必须先在Let's Encrypt注册一个账号；我们的代码将生成密钥并存储在这个路径中</li><li id="35b8" class="ls lt iq ky b kz mb lc mc lf md lj me ln mf lr lx ly lz ma bi translated"><code class="fe ob oc od ns b">CertificatePrivateKeyPath</code>:每个证书都需要一个私钥；我们将生成它并存储在这个路径中</li><li id="28e6" class="ls lt iq ky b kz mb lc mc lf md lj me ln mf lr lx ly lz ma bi translated"><code class="fe ob oc od ns b">CertificatePath</code> <em class="mj"> : </em>我们将把从Let's Encrypt获得的证书存储在这个路径下</li><li id="3d26" class="ls lt iq ky b kz mb lc mc lf md lj me ln mf lr lx ly lz ma bi translated"><code class="fe ob oc od ns b">CloudflareAPIToken</code>:一个Cloudflare API令牌，咄！</li></ul><p id="9dc2" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们将通过一个简单的API与库进行交互:</p><pre class="kg kh ki kj gt nr ns nt nu aw nv bi"><span id="419d" class="nw mv iq ns b gy nx ny l nz oa">func RequestCertificate(<br/>  domains []string,<br/>  ownerEmail []string,<br/>  cfg *Config<br/>) error {...}</span><span id="3ac6" class="nw mv iq ns b gy oe ny l nz oa">// called as<br/>domains := []string{"example.com"}<br/>emails := []string{"mailto:info@example.com"}<br/>err := RequestCertificate(domains, emails, c)<br/>if err != nil {<br/>  ...<br/>}</span></pre><p id="e3ea" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">让我们从实现<code class="fe ob oc od ns b">RequestCertificate</code>开始:</p><pre class="kg kh ki kj gt nr ns nt nu aw nv bi"><span id="2873" class="nw mv iq ns b gy nx ny l nz oa">ctx := context.Background()</span><span id="0bcb" class="nw mv iq ns b gy oe ny l nz oa">// We use Uber's Zap logger, as required by acmez<br/>logger, _ := zap.NewProduction()<br/>defer logger.Sync() // flushes buffer, if any</span><span id="cf4f" class="nw mv iq ns b gy oe ny l nz oa">// Initialize a DNS-01 solver, using Cloudflare APIs<br/>solver := &amp;certmagic.DNS01Solver{<br/>  DNSProvider:        &amp;cloudflare.Provider{APIToken: cfg.CloudflareAPIToken},<br/>}</span><span id="666d" class="nw mv iq ns b gy oe ny l nz oa">// The CA endpoint to use (prod or staging)<br/>// switch to Production once fully tested<br/>// otherwise you might get rate-limited in Production<br/>// before you've had a chance to test that your client<br/>// works as expected<br/>caLocation = certmagic.LetsEncryptStagingCA<br/>//caLocation := certmagic.LetsEncryptProductionCA</span><span id="9d25" class="nw mv iq ns b gy oe ny l nz oa">// CONTINUED BELOW ...</span></pre><blockquote class="mg mh mi"><p id="d724" class="kw kx mj ky b kz la jr lb lc ld ju le mk lg lh li ml lk ll lm mm lo lp lq lr ij bi translated">仅供参考，<em class="iq"> acmez </em>图书馆使用优步<a class="ae kv" href="https://pkg.go.dev/go.uber.org/zap" rel="noopener ugc nofollow" target="_blank"> Zap记录器</a>。您可以跳过提供日志记录器，这意味着您不会从ACME客户端获得任何信息，从而错过了潜在的错误。</p></blockquote><pre class="kg kh ki kj gt nr ns nt nu aw nv bi"><span id="2321" class="nw mv iq ns b gy nx ny l nz oa">// Initialize an acmez client<br/>client := acmez.Client{<br/> Client: &amp;acme.Client{<br/>  Directory: caLocation,<br/>  UserAgent: "[SOMETHING TO IDENTIFY YOUR CLIENT]",<br/>  Logger:    logger,<br/> },<br/> ChallengeSolvers: map[string]acmez.Solver{<br/>  acme.ChallengeTypeDNS01: solver,<br/> },<br/>}</span><span id="c3aa" class="nw mv iq ns b gy oe ny l nz oa">// Generate a private key for your Let's Encrypt account<br/>accountPrivateKey, err := ecdsa.GenerateKey(elliptic.P256(), rand.Reader)<br/>if err != nil {<br/> return fmt.Errorf("ecdsa.GenerateKey() could not generate an account key: %v", err)<br/>}</span><span id="6031" class="nw mv iq ns b gy oe ny l nz oa">// Create a Let's Encrypt account<br/>account := acme.Account{<br/> Contact:              ownerEmail,<br/> TermsOfServiceAgreed: true,<br/> PrivateKey:           accountPrivateKey,<br/>}</span><span id="a9af" class="nw mv iq ns b gy oe ny l nz oa">acc, _ := client.NewAccount(ctx, account)<br/>if err != nil {<br/> return fmt.Errorf("client.NewAccount() could not create new account: %w", err)<br/>}</span></pre><p id="366f" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">此时，我们通过了Let's Encrypt的身份验证，并准备好发出证书请求。</p><pre class="kg kh ki kj gt nr ns nt nu aw nv bi"><span id="f3ed" class="nw mv iq ns b gy nx ny l nz oa">// Generate a private key for the certificate<br/>certPrivateKey, err := ecdsa.GenerateKey(elliptic.P256(), rand.Reader)<br/>if err != nil {<br/> return fmt.Errorf("generating certificate key: %w", err)<br/>}</span><span id="5d2e" class="nw mv iq ns b gy oe ny l nz oa">// TODO(left to the reader): store this key to a file// obtain certificates from Let's Encrypt<br/>certs, err := client.ObtainCertificate(ctx, acc, certPrivateKey, domains)<br/>if err != nil {<br/> return fmt.Errorf("client.ObtainCertificate() could not obtain certificate: %w", err)<br/>}</span><span id="c787" class="nw mv iq ns b gy oe ny l nz oa">// since the client returns more than one cert, it is up to you<br/>// to choose the most appropriate one (such as one which contains<br/>// the full chain, including any intermediate certificates)<br/>for _, cert := range certs {<br/> log.Println(string(cert.ChainPEM))<br/> // TODO(left to the reader): store cert.ChainPEM to a file<br/>}</span><span id="23c9" class="nw mv iq ns b gy oe ny l nz oa">return nil</span></pre><p id="4e3c" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我可以给你的一个提示是，要存储一个私钥，你必须首先把它转换成ASN.1 DER格式。这很容易实现；见下文:</p><pre class="kg kh ki kj gt nr ns nt nu aw nv bi"><span id="f5f3" class="nw mv iq ns b gy nx ny l nz oa">func EncodeAndStorePrivateKey(privateKey *ecdsa.PrivateKey, filename string, mode fs.FileMode) error {<br/> x509Encoded, err := x509.MarshalECPrivateKey(privateKey)<br/> if err != nil {<br/>  return err<br/> }</span><span id="a995" class="nw mv iq ns b gy oe ny l nz oa">data := pem.EncodeToMemory(&amp;pem.Block{Type: "PRIVATE KEY", Bytes: x509Encoded})<br/> return os.WriteFile(filename, data, mode)<br/>}</span></pre><p id="d671" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">差不多就是这样了！现在，您可以通过使用DNS-01质询进行加密来发布和刷新SSL/TLS证书(如果您的域的DNS是在<a class="ae kv" href="https://www.cloudflare.com/" rel="noopener ugc nofollow" target="_blank"> Cloudflare </a>上管理的)。</p><p id="c1a1" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">还有一件事；这里有一个要添加的Go导入的完整列表——当您将所有这些放在一起时，这会节省您一点时间！</p><pre class="kg kh ki kj gt nr ns nt nu aw nv bi"><span id="604a" class="nw mv iq ns b gy nx ny l nz oa">import (<br/> "context"<br/> "crypto/ecdsa"<br/> "crypto/elliptic"<br/> "crypto/rand"<br/> "crypto/x509"<br/> "encoding/pem"<br/> "fmt"<br/> "io/fs"<br/> "log"<br/> "os"</span><span id="19ef" class="nw mv iq ns b gy oe ny l nz oa"> "github.com/caddyserver/certmagic"<br/> "github.com/libdns/cloudflare"<br/> "github.com/mholt/acmez"<br/> "github.com/mholt/acmez/acme"<br/> "go.uber.org/zap"<br/>)</span></pre><p id="0132" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">不要忘记<code class="fe ob oc od ns b">go get</code>上面列出的外部模块！</p></div><div class="ab cl mn mo hu mp" role="separator"><span class="mq bw bk mr ms mt"/><span class="mq bw bk mr ms mt"/><span class="mq bw bk mr ms"/></div><div class="ij ik il im in"><p id="e28c" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">感谢阅读。让我知道你的想法，在推特上！</p></div></div>    
</body>
</html>