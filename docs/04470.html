<html>
<head>
<title>The Beginner’s Guide to Building Apps with React Hooks and a Rails API Back-End</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用React挂钩和Rails API后端构建应用程序的初学者指南</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/the-beginners-guide-to-building-apps-with-react-hooks-and-a-rails-api-back-end-a414dade8e28?source=collection_archive---------4-----------------------#2020-04-15">https://betterprogramming.pub/the-beginners-guide-to-building-apps-with-react-hooks-and-a-rails-api-back-end-a414dade8e28?source=collection_archive---------4-----------------------#2020-04-15</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="4773" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">用React挂钩和横杆搭建一个全堆叠工作板</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/564c9e6b04b86a5af4bd3e65370248d8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*wKovUctZXmhj3FktFXpaSA.jpeg"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">康斯坦丁·普拉宁斯基在Unsplash<a class="ae ky" href="https://unsplash.com/s/photos/rails?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">拍摄的照片</a></p></figure><p id="658f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我的第一份软件工作是构建一个完整的Ruby on Rails应用程序。那时我讨厌前端开发，避免任何JavaScript特性。这是在React流行之前。从那时起，我意识到在堆栈上上下下编码的能力是无价的。</p><p id="2c38" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我在后Hooks时代开始有所反应，并且很难找到使用Hooks、功能组件和数据库持久性的完整教程。我写这篇文章是为了给其他人弥合这些差距。希望对你有帮助。</p><p id="1586" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我非常感谢下面的文章，它们对于弄清楚如何将这些碎片组合在一起非常有价值(尽管它们都没有做到)。</p><ul class=""><li id="2ddb" class="lv lw it lb b lc ld lf lg li lx lm ly lq lz lu ma mb mc md bi translated"><a class="ae ky" href="https://medium.com/@christine_tran/create-react-app-rails-api-deployment-to-surge-heroku-4f549f2812e6" rel="noopener">创建React App &amp; Rails API部署激增&amp; Heroku </a></li><li id="f7c8" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated"><a class="ae ky" href="https://www.taniarascia.com/crud-app-in-react-with-hooks/" rel="noopener ugc nofollow" target="_blank">用钩子在React中构建一个CRUD应用</a></li><li id="c20e" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated"><a class="ae ky" href="https://blog.heroku.com/a-rock-solid-modern-web-stack" rel="noopener ugc nofollow" target="_blank">坚如磐石的现代网络堆栈</a></li></ul><p id="5afb" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们正在构建一个带有ReactJS钩子前端和Rails API后端的作业板，后者将数据保存到<code class="fe mj mk ml mm b">Postgres</code>。这个应用程序允许创建，查看，更新和删除工作。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi mn"><img src="../Images/6b5f1573e3c20246263d916dd49c5a37.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*zlSt_aPFsoTyZ_rfdpc0xg.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">这是我们正在建造的</p></figure><h2 id="ddff" class="mo mp it bd mq mr ms dn mt mu mv dp mw li mx my mz lm na nb nc lq nd ne nf ng bi translated"><strong class="ak">目录</strong></h2><ul class=""><li id="c5a5" class="lv lw it lb b lc nh lf ni li nj lm nk lq nl lu ma mb mc md bi translated"><a class="ae ky" href="#c6fd" rel="noopener ugc nofollow">设置App </a></li><li id="c470" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated"><a class="ae ky" href="#347d" rel="noopener ugc nofollow">工作模式</a></li><li id="bd7d" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated"><a class="ae ky" href="#b9e5" rel="noopener ugc nofollow">作业控制器</a></li><li id="c86a" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated"><a class="ae ky" href="#681d" rel="noopener ugc nofollow">铁路路线</a></li><li id="e94e" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated"><a class="ae ky" href="#4620" rel="noopener ugc nofollow">种子数据库</a></li><li id="78fe" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated"><a class="ae ky" href="#f478" rel="noopener ugc nofollow">在前端显示作业</a></li><li id="8454" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated"><a class="ae ky" href="#44f9" rel="noopener ugc nofollow">创建工作岗位</a></li><li id="4dfc" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated"><a class="ae ky" href="https://medium.com/p/a414dade8e28/edit#4200" rel="noopener">删除作业</a></li><li id="b084" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated"><a class="ae ky" href="#1ad9" rel="noopener ugc nofollow">编辑现有作业</a></li><li id="2077" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated"><a class="ae ky" href="#ec1a" rel="noopener ugc nofollow">结论</a></li></ul></div><div class="ab cl nm nn hx no" role="separator"><span class="np bw bk nq nr ns"/><span class="np bw bk nq nr ns"/><span class="np bw bk nq nr"/></div><div class="im in io ip iq"><h1 id="c6fd" class="nt mp it bd mq nu nv nw mt nx ny nz mw jz oa ka mz kc ob kd nc kf oc kg nf od bi translated">设置应用程序</h1><p id="2e1b" class="pw-post-body-paragraph kz la it lb b lc nh ju le lf ni jx lh li oe lk ll lm of lo lp lq og ls lt lu im bi translated">这种前端应用程序/后端API设计模式由同一个项目中的两个独立应用程序组成，尽管它们在部署时作为单个应用程序运行。</p><p id="5d20" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">前端位于Rails应用程序根目录下的文件夹<code class="fe mj mk ml mm b">/client</code>中。</p><p id="1f43" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">初始化Rails应用程序并将<code class="fe mj mk ml mm b">cd</code>放入其中。</p><pre class="kj kk kl km gt oh mm oi oj aw ok bi"><span id="e863" class="mo mp it mm b gy ol om l on oo">$ rails new job-board --api --database=postgresql -T<br/>$ cd job-board/</span></pre><p id="9bac" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们在这里用了一些旗子。<code class="fe mj mk ml mm b">--database=postgresql</code>在<code class="fe mj mk ml mm b">database.yml</code>中将<code class="fe mj mk ml mm b">postgres</code>设置为默认数据库，<code class="fe mj mk ml mm b">-T</code>跳过添加测试文件。</p><p id="b262" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">要基于<code class="fe mj mk ml mm b">database.yml</code>生成数据库，运行:</p><pre class="kj kk kl km gt oh mm oi oj aw ok bi"><span id="017b" class="mo mp it mm b gy ol om l on oo">$ rake db:create</span></pre><p id="1000" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在另一个终端中，创建一个React应用程序，我们将使用它作为前端，并将<code class="fe mj mk ml mm b">cd</code>放入其中。</p><pre class="kj kk kl km gt oh mm oi oj aw ok bi"><span id="90de" class="mo mp it mm b gy ol om l on oo">$ npx create-react-app client<br/>$ cd client</span></pre><p id="201a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">添加代理中间件来连接我们的前端和后端:</p><pre class="kj kk kl km gt oh mm oi oj aw ok bi"><span id="51d1" class="mo mp it mm b gy ol om l on oo">$ yarn add http-proxy-middleware</span></pre><p id="ef42" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在<code class="fe mj mk ml mm b">/src</code>中，创建一个名为<code class="fe mj mk ml mm b">setupProxy.js</code>的文件。如果你感兴趣，文档在这里<a class="ae ky" href="https://create-react-app.dev/docs/proxying-api-requests-in-development/" rel="noopener ugc nofollow" target="_blank"/>。这避免了CORS问题，并允许命中像<code class="fe mj mk ml mm b">/api/posts</code>而不是<code class="fe mj mk ml mm b"><a class="ae ky" href="http://localhost:3001/api/posts." rel="noopener ugc nofollow" target="_blank">http://localhost:3001/api/posts</a></code>这样的端点。它应该是这样的:</p><pre class="kj kk kl km gt oh mm oi oj aw ok bi"><span id="d648" class="mo mp it mm b gy ol om l on oo">const { createProxyMiddleware } = require('http-proxy-middleware');<br/>module.exports = function(app) {<br/>    app.use(<br/>        '/api',<br/>        createProxyMiddleware({<br/>            target: 'http://localhost:3001',<br/>            changeOrigin: true,<br/>        })<br/>    );<br/>};</span></pre><p id="87ca" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们检查一下到目前为止我们所做的一切是否有效。从根目录启动rails服务器:</p><pre class="kj kk kl km gt oh mm oi oj aw ok bi"><span id="5b2a" class="mo mp it mm b gy ol om l on oo">$ rails s -p 3001</span></pre><p id="57c3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">导航到<a class="ae ky" href="http://localhost:3002/" rel="noopener ugc nofollow" target="_blank"> http://localhost:3001/ </a>:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi op"><img src="../Images/a985e6e0f74753bdba0ba7251d5ca512.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*fskQTv8Feu73AD9oJBs-3g.png"/></div></div></figure><p id="b32c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">从<code class="fe mj mk ml mm b">/client</code>启动客户端应用程序:</p><pre class="kj kk kl km gt oh mm oi oj aw ok bi"><span id="b844" class="mo mp it mm b gy ol om l on oo">$ npm run start</span></pre><p id="4f60" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">导航到<a class="ae ky" href="http://localhost:3003/" rel="noopener ugc nofollow" target="_blank"> http://localhost:3000/ </a>:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi oq"><img src="../Images/898b1b4e1e0f3fbd52f05d8ebedc269a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*NmnwkrIR7W3wsS2QZ9U8OA.png"/></div></div></figure><p id="1d42" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果这两种观点你都没有看到，那么回头看看哪里出了问题。</p></div><div class="ab cl nm nn hx no" role="separator"><span class="np bw bk nq nr ns"/><span class="np bw bk nq nr ns"/><span class="np bw bk nq nr"/></div><div class="im in io ip iq"><h1 id="347d" class="nt mp it bd mq nu nv nw mt nx ny nz mw jz oa ka mz kc ob kd nc kf oc kg nf od bi translated">工作模型</h1><p id="4776" class="pw-post-body-paragraph kz la it lb b lc nh ju le lf ni jx lh li oe lk ll lm of lo lp lq og ls lt lu im bi translated">在命令行上从根目录生成迁移文件。</p><p id="03fc" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">迁移文件是Rails告诉数据库要做什么更改而不需要编写SQL的方式。</p><pre class="kj kk kl km gt oh mm oi oj aw ok bi"><span id="ddab" class="mo mp it mm b gy ol om l on oo">$ rails g migration CreateJobs</span></pre><p id="2df3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">该文件将在<code class="fe mj mk ml mm b">/db/migrate</code>中创建。编辑文件，如下所示:</p><pre class="kj kk kl km gt oh mm oi oj aw ok bi"><span id="a06f" class="mo mp it mm b gy ol om l on oo">class <em class="or">CreateJobs </em>&lt; ActiveRecord::Migration[5.0]<br/>  def change<br/>    create_table :jobs do |<em class="or">t</em>|<br/>      <em class="or">t</em>.string :company<br/>      <em class="or">t</em>.string :position<br/>      <em class="or">t</em>.string :description<br/>    end<br/>  end<br/>end</span></pre><p id="edf7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">按照此次迁移迁移数据库:</p><pre class="kj kk kl km gt oh mm oi oj aw ok bi"><span id="df00" class="mo mp it mm b gy ol om l on oo">$ rake db:migrate</span></pre><p id="77ad" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在我们将创建模型本身。创建<code class="fe mj mk ml mm b">/app/models/job.rb</code>并编辑如下:</p><pre class="kj kk kl km gt oh mm oi oj aw ok bi"><span id="0959" class="mo mp it mm b gy ol om l on oo">class <em class="or">Job </em>&lt; ApplicationRecord<br/>end</span></pre></div><div class="ab cl nm nn hx no" role="separator"><span class="np bw bk nq nr ns"/><span class="np bw bk nq nr ns"/><span class="np bw bk nq nr"/></div><div class="im in io ip iq"><h1 id="b9e5" class="nt mp it bd mq nu nv nw mt nx ny nz mw jz oa ka mz kc ob kd nc kf oc kg nf od bi translated">作业控制器</h1><p id="b15f" class="pw-post-body-paragraph kz la it lb b lc nh ju le lf ni jx lh li oe lk ll lm of lo lp lq og ls lt lu im bi translated">在Rails所基于的MVC(模型-视图-控制器)设计模式中，控制器是在模型和视图之间传递信息的看不见的手。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi os"><img src="../Images/98622939192727f91f9722d4b3ff08a8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*RGbNbjT6pJGl73A_BGqUPA.png"/></div></div></figure><p id="4806" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">创建<code class="fe mj mk ml mm b">/app/controllers/api/v1/jobs_controller.rb</code>并更新如下。</p><p id="bfba" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在Rails 101应用程序中，您不会在<code class="fe mj mk ml mm b">/api/v1/</code>中命名控制器，但是在构建API时这样做是最佳实践。<code class="fe mj mk ml mm b">/v1/</code>模式允许为现有用户创建API的新版本，而不破坏旧版本(尽管在这种情况下，React是用户)。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ot ou l"/></div></figure></div><div class="ab cl nm nn hx no" role="separator"><span class="np bw bk nq nr ns"/><span class="np bw bk nq nr ns"/><span class="np bw bk nq nr"/></div><div class="im in io ip iq"><h1 id="681d" class="nt mp it bd mq nu nv nw mt nx ny nz mw jz oa ka mz kc ob kd nc kf oc kg nf od bi translated">铁路路线</h1><p id="8e0b" class="pw-post-body-paragraph kz la it lb b lc nh ju le lf ni jx lh li oe lk ll lm of lo lp lq og ls lt lu im bi translated">路由将URL映射到控制器动作，因此请求由其目标逻辑处理。</p><p id="aa07" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">编辑<code class="fe mj mk ml mm b">/config/routes.rb</code>:</p><pre class="kj kk kl km gt oh mm oi oj aw ok bi"><span id="69a7" class="mo mp it mm b gy ol om l on oo">Rails.application.routes.draw do<br/>  namespace :api do<br/>    namespace :v1 do<br/>      get '/jobs', to: 'jobs#index'<br/>      post '/jobs', to: 'jobs#create'<br/>      get '/jobs/:id', to: 'jobs#show'<br/>      patch '/jobs/:id', to: 'jobs#update'<br/>      delete '/jobs/:id', to: 'jobs#destroy'<br/>    end<br/>  end<br/>end</span></pre><p id="3bd1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">要查看Rails应用程序中当前设置的所有路线，请在命令行上运行<code class="fe mj mk ml mm b">rake routes</code>。</p><p id="03c0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们的基本rails应用程序现在已经设置好了。</p></div><div class="ab cl nm nn hx no" role="separator"><span class="np bw bk nq nr ns"/><span class="np bw bk nq nr ns"/><span class="np bw bk nq nr"/></div><div class="im in io ip iq"><h1 id="4620" class="nt mp it bd mq nu nv nw mt nx ny nz mw jz oa ka mz kc ob kd nc kf oc kg nf od bi translated">为数据库设定种子</h1><p id="b478" class="pw-post-body-paragraph kz la it lb b lc nh ju le lf ni jx lh li oe lk ll lm of lo lp lq og ls lt lu im bi translated">Rails附带了一个叫做Rake的自动化工具。</p><p id="c97b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">通过在带有<code class="fe mj mk ml mm b">.rake</code>扩展名的<code class="fe mj mk ml mm b">/lib/tasks/</code>中定义任务，我们可以通过命令行运行应用程序中定义的脚本。如果我们想安排代码在特定时间运行，或者手动改变数据库的状态，这是非常有用的。</p><p id="14a3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们定义一个rake任务，用一些我们可以在前端查看的作业来播种我们的数据库。</p><p id="54c2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">创建一个名为<code class="fe mj mk ml mm b">/lib/tasks/seed_jobs.rake</code>的文件，并复制以下代码。运行时，这将在数据库中创建两个作业:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ot ou l"/></div></figure><p id="9285" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们将开始在前端UI上工作，它将显示后端中存在的作业。</p><p id="416f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">更新<code class="fe mj mk ml mm b">/client/src/App.js</code>使其看起来如下。别担心，我们将更改“Hello World ”,并很快开始显示jobs:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ot ou l"/></div></figure><p id="b08e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在我们的前端是一个空白页，上面写着“Hello World”:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ov"><img src="../Images/37154616d5f57f88f2bb4c6fecce2be6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*mW5IruXloaFL2RjvpZLWnQ.png"/></div></div></figure><p id="e8ac" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在让我们创建显示作业的组件。</p><p id="1e1d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">首先，安装我们将用来发出API请求的库。在<code class="fe mj mk ml mm b">/client</code>中，安装axios:</p><pre class="kj kk kl km gt oh mm oi oj aw ok bi"><span id="7f32" class="mo mp it mm b gy ol om l on oo">$ yarn add axios</span></pre><p id="2fe4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">创建<code class="fe mj mk ml mm b">/client/src/components/JobsList.js</code>:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ot ou l"/></div></figure><p id="958b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在这一点上，这是非常基本的，但这里已经有一些事情在进行了:</p><ul class=""><li id="cab8" class="lv lw it lb b lc ld lf lg li lx lm ly lq lz lu ma mb mc md bi translated"><code class="fe mj mk ml mm b">const JobsList</code>定义一个功能组件</li><li id="673f" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated"><code class="fe mj mk ml mm b">const [jobs, setJobs] = useState([])</code>为<code class="fe mj mk ml mm b">jobs</code>变量创建一个getter和setter。</li><li id="a66a" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated"><code class="fe mj mk ml mm b">useEffect()</code>该组件初始化后，通过axios向Rails后端发送请求，并将返回的作业添加到<code class="fe mj mk ml mm b">jobs</code>。</li><li id="2575" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated"><code class="fe mj mk ml mm b">return()</code>迭代现有作业并显示它们。</li></ul><p id="c417" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在更新<code class="fe mj mk ml mm b">App.js</code>,让它呈现这个组件。添加导入并编辑返回块。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ot ou l"/></div></figure><p id="5a84" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们的应用程序当然还没有一个伟大的用户界面/UX！但是只要确保前端和后端在通信就可以了。如果您在UI中看不到作业，请停下来，修复您到目前为止已经构建的内容。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ow"><img src="../Images/605b511b3c29000327f8ac38af2e9250.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*VXFUqBMLWoCYuFxAX9UWIA.png"/></div></div></figure></div><div class="ab cl nm nn hx no" role="separator"><span class="np bw bk nq nr ns"/><span class="np bw bk nq nr ns"/><span class="np bw bk nq nr"/></div><div class="im in io ip iq"><h1 id="44f9" class="nt mp it bd mq nu nv nw mt nx ny nz mw jz oa ka mz kc ob kd nc kf oc kg nf od bi translated">创造就业机会</h1><p id="422a" class="pw-post-body-paragraph kz la it lb b lc nh ju le lf ni jx lh li oe lk ll lm of lo lp lq og ls lt lu im bi translated">现在开始变得有趣了。我们将允许创建作业并将作业保存到数据库中。</p><p id="9b6e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">创建一个名为<code class="fe mj mk ml mm b">/client/src/components/NewJobForm.js</code>的新文件:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ot ou l"/></div></figure><p id="9458" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这里发生了很多事情。</p><ul class=""><li id="fe18" class="lv lw it lb b lc ld lf lg li lx lm ly lq lz lu ma mb mc md bi translated"><code class="fe mj mk ml mm b">const NewJobForm</code>是我们的功能组件。</li><li id="f3a0" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated"><code class="fe mj mk ml mm b">const handleInputChange()</code>在我们键入时更新当前作业:</li></ul><pre class="kj kk kl km gt oh mm oi oj aw ok bi"><span id="9bdc" class="mo mp it mm b gy ol om l on oo">const handleInputChange = event =&gt; {<br/>  const { name, value } = event.target<br/>  setJob({ ...job, [name]: value })<br/>};</span></pre><ul class=""><li id="2117" class="lv lw it lb b lc ld lf lg li lx lm ly lq lz lu ma mb mc md bi translated"><code class="fe mj mk ml mm b">const [job, setJob] = useState(props.initialFormState)</code>用空字符串初始化表单字段。</li></ul><p id="b034" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在<code class="fe mj mk ml mm b">&lt;form&gt;</code>标签中，我们有这样的逻辑:</p><ul class=""><li id="6d03" class="lv lw it lb b lc ld lf lg li lx lm ly lq lz lu ma mb mc md bi translated">防止提交时重新呈现默认页面`。</li><li id="1c84" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated">如果任何表单域为空，则提前返回。</li><li id="0d5b" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated">将表格中输入的文本传递给<code class="fe mj mk ml mm b">addJob()</code>。</li><li id="9fd3" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated">将表单域重置为空。</li></ul><p id="ba6e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe mj mk ml mm b">&lt;input&gt;</code>字段接受值并将它们传递给<code class="fe mj mk ml mm b">handleInputChange()</code>。</p><p id="f776" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在<code class="fe mj mk ml mm b">JobsList.js</code>中，我们也需要更新一些东西。增加<code class="fe mj mk ml mm b">initialFormState</code>、<code class="fe mj mk ml mm b">addJob()</code>，更新<code class="fe mj mk ml mm b">return</code>块:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ot ou l"/></div></figure><ul class=""><li id="f8d4" class="lv lw it lb b lc ld lf lg li lx lm ly lq lz lu ma mb mc md bi translated"><code class="fe mj mk ml mm b">initialFormState</code>:作为道具传递给<code class="fe mj mk ml mm b">NewJobForm</code>。</li><li id="aba4" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated"><code class="fe mj mk ml mm b">addJob()</code>:向Rails后端发出post请求，然后更新视图中显示的作业。这将作为道具传递给<code class="fe mj mk ml mm b">NewJobForm</code>。</li></ul><p id="cddf" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">检查用户界面，确保它看起来像这样:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ox"><img src="../Images/ed412adfd98032f59aff5b1444022cd7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*G3kSYpTOQKD3I4oLvtbqwg.png"/></div></div></figure><p id="4eb6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们现在可以创造就业机会了！如果我们刷新页面，它们也不会丢失，因为它们也是在数据库中创建的。</p></div><div class="ab cl nm nn hx no" role="separator"><span class="np bw bk nq nr ns"/><span class="np bw bk nq nr ns"/><span class="np bw bk nq nr"/></div><div class="im in io ip iq"><h1 id="988a" class="nt mp it bd mq nu nv nw mt nx ny nz mw jz oa ka mz kc ob kd nc kf oc kg nf od bi translated">作业组件</h1><p id="4baa" class="pw-post-body-paragraph kz la it lb b lc nh ju le lf ni jx lh li oe lk ll lm of lo lp lq og ls lt lu im bi translated">开始变得有点乱了。让我们将呈现每个作业的逻辑放入它自己的组件<code class="fe mj mk ml mm b">Job</code>。</p><p id="1e37" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">创建<code class="fe mj mk ml mm b">/client/src/components/Job.js</code>:</p><p id="08dd" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">ttps://gist . github . com/better programming/3b 34d 4242511 a0d 7c 5425737024334 ca . js</p><p id="21d2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">更新<code class="fe mj mk ml mm b">JobsList.js</code>中的返回块，为每个作业呈现我们的新组件:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ot ou l"/></div></figure><p id="7552" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">视图现在应该是这样的:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi oy"><img src="../Images/99760b421d738f9489084402500ff990.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*s9ymY5alYHAQsWqBd_aY2w.png"/></div></div></figure></div><div class="ab cl nm nn hx no" role="separator"><span class="np bw bk nq nr ns"/><span class="np bw bk nq nr ns"/><span class="np bw bk nq nr"/></div><div class="im in io ip iq"><h1 id="4200" class="nt mp it bd mq nu nv nw mt nx ny nz mw jz oa ka mz kc ob kd nc kf oc kg nf od bi translated">删除作业</h1><p id="3e20" class="pw-post-body-paragraph kz la it lb b lc nh ju le lf ni jx lh li oe lk ll lm of lo lp lq og ls lt lu im bi translated">现在我们可以创建作业了，让我们添加从数据库中删除它们的功能，并从前端删除它们。</p><p id="977d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在<code class="fe mj mk ml mm b">JobsList</code>中定义一个函数，并将其传递给我们刚刚创建的<code class="fe mj mk ml mm b">Jobs</code>:</p><pre class="kj kk kl km gt oh mm oi oj aw ok bi"><span id="992a" class="mo mp it mm b gy ol om l on oo">const removeJob = id =&gt; {<br/>  axios.delete( '/api/v1/jobs/' + id )<br/>      .then(response =&gt; {<br/>        setJobs(jobs.filter(job =&gt; job.id !== id))<br/>      })<br/>      .catch(error =&gt; console.log(error))<br/>};</span></pre><p id="3369" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">上面使用应该销毁的作业的id向后端发出删除请求。在下面，我将它作为道具传递给了<code class="fe mj mk ml mm b">Job</code>组件:</p><pre class="kj kk kl km gt oh mm oi oj aw ok bi"><span id="1bfb" class="mo mp it mm b gy ol om l on oo">return (<br/>    &lt;div&gt;<br/>      &lt;div className="jobs-list"&gt;<br/>        &lt;div&gt;<br/>          &lt;NewJobForm addJob={addJob} /&gt;<br/>        &lt;/div&gt;<br/>        &lt;br/&gt;<br/>        &lt;hr/&gt;<br/>        {jobs.map((job, _) =&gt; (<br/>            &lt;Job job={job} <strong class="mm iu">removeJob={removeJob}</strong> /&gt;<br/>          ))}<br/>      &lt;/div&gt;<br/>    &lt;/div&gt;<br/>)</span></pre><p id="3e96" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在编辑作业组件。我们将添加一个按钮来触发这个删除逻辑。</p><pre class="kj kk kl km gt oh mm oi oj aw ok bi"><span id="0ce3" class="mo mp it mm b gy ol om l on oo">import React from 'react';<br/><br/>const Job = ({ job, removeJob }) =&gt; (<br/>    &lt;div className="job" key={job.id}&gt;<br/>      &lt;h4&gt;{job.company}&lt;/h4&gt;<br/>      &lt;p&gt;{job.position}&lt;/p&gt;<br/>      &lt;p&gt;{job.description}&lt;/p&gt;<br/><br/>      &lt;button onClick={() =&gt; removeJob(job.id)}&gt;Remove&lt;/button&gt;<br/>    &lt;/div&gt;<br/>);<br/><br/>export default Job;</span></pre><p id="bc5e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果刷新视图，您现在应该能够单击“Remove”并删除作业记录。好吧！</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi oz"><img src="../Images/26eba5780f0454fcec3aa848a9ec8d71.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Z-kz09JTA1Zh446ylhcpdg.png"/></div></div></figure></div><div class="ab cl nm nn hx no" role="separator"><span class="np bw bk nq nr ns"/><span class="np bw bk nq nr ns"/><span class="np bw bk nq nr"/></div><div class="im in io ip iq"><h1 id="1ad9" class="nt mp it bd mq nu nv nw mt nx ny nz mw jz oa ka mz kc ob kd nc kf oc kg nf od bi translated">编辑现有作业</h1><p id="4d3e" class="pw-post-body-paragraph kz la it lb b lc nh ju le lf ni jx lh li oe lk ll lm of lo lp lq og ls lt lu im bi translated">但是如果我们不想删除一个作业，只是想改变它呢？让我们为此添加编辑/更新功能。</p><p id="4646" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">创建一个名为<code class="fe mj mk ml mm b">EditJobForm.js</code>的新文件。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ot ou l"/></div></figure><p id="68e2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这里我们根据从<code class="fe mj mk ml mm b">JobList</code>传来的道具，将<code class="fe mj mk ml mm b">job</code>的初始状态设置为空字符串。</p><p id="3691" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们定义了一个与之前相同的<code class="fe mj mk ml mm b">handleInputChange()</code>函数。</p><p id="b391" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">然后我们有了使用<code class="fe mj mk ml mm b">updateJob()</code>的表单，我们将在<code class="fe mj mk ml mm b">JobList</code>中定义它。</p><p id="5e6d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在<code class="fe mj mk ml mm b">JobsList.js</code>中，我们将添加一些函数和变量:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ot ou l"/></div></figure><p id="8325" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe mj mk ml mm b">editJob()</code>设置编辑作业字段的初始状态。<code class="fe mj mk ml mm b">updateJob()</code>将数据发送给Rails API并更新视图。</p><p id="7417" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">另外，请注意，我们已经向<code class="fe mj mk ml mm b">Job</code>组件传递了更多的道具。</p><p id="d265" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在修改<code class="fe mj mk ml mm b">Job.js</code>:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ot ou l"/></div></figure><p id="f92f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们在这里所做的是，如果当前没有编辑另一个作业，则有条件地显示编辑按钮。</p><p id="9571" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在看一下用户界面:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi pa"><img src="../Images/d83225f87f5d01f5aa19035551b6176c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*I4SIg9Wff7rtelAe39-tcA.png"/></div></div></figure><p id="e81c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">漂亮！(在功能上，而不是外观上)。</p><p id="9516" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">尝试创建、删除、更新作业。一切都应该正常。</p></div><div class="ab cl nm nn hx no" role="separator"><span class="np bw bk nq nr ns"/><span class="np bw bk nq nr ns"/><span class="np bw bk nq nr"/></div><div class="im in io ip iq"><h1 id="ec1a" class="nt mp it bd mq nu nv nw mt nx ny nz mw jz oa ka mz kc ob kd nc kf oc kg nf od bi translated">结论</h1><p id="c7c6" class="pw-post-body-paragraph kz la it lb b lc nh ju le lf ni jx lh li oe lk ll lm of lo lp lq og ls lt lu im bi translated">我们已经构建了一个完整的stack React on Rails应用程序，允许查看、创建、删除和更新作业。它还保存对数据库的更改。</p><p id="577d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">很明显，在这款应用成为产品之前，我们还缺少很多东西。我们当然需要身份验证，以及部署身份验证的devops。</p><p id="f6a5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">但我希望这能让你理解在一个应用中同时运行React和Rails所需的架构。</p></div></div>    
</body>
</html>