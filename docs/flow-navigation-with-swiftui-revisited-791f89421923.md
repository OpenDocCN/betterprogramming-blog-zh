# 使用 SwiftUI 3 进行流程导航

> 原文：<https://betterprogramming.pub/flow-navigation-with-swiftui-revisited-791f89421923>

## 如何在你的代码库中有效地实现屏幕流导航

![](img/0f5d0a35e8589b7cb4fd5740fe6d13a3.png)

【*swift ui 4 和 NavigationStack 实现注意事项参见* [*此处*](/flow-navigation-with-swiftui-4-e006882c5efa)*】*

这是对之前几篇关于创建解耦导航流的文章的回顾([第 1 部分](https://medium.com/swlh/flow-with-swiftui-and-mvvm-7cc394440ab8)和[第 2 部分](https://medium.com/@nicmcconn/flow-with-swiftui-and-mvvm-part-2-viewmodels-905ecc05f1c5))，它们与最初的 SwiftUI 1.0 相关。时代变了，SwiftUI (3.0)、NavigationView 和我自己的视角现在都不同了(也更简单了！)所以觉得值得重新评估。

我最近一直在用 SwiftUI 审查我的多屏幕入职流程。与所有的多屏数据输入流一样，它们通常代表了一个有趣的问题，即如何分离数据、视图和导航逻辑。

那么，是什么造就了一个伟大的多屏数据输入流程呢？这是我想到的。由于缺少一个不那么宏大的术语，我称它为我的“屏幕流动宣言”我在这里使用“屏幕”而不是视图，因为我们明确地指的是全屏导航。

1.  屏幕不应该有“父”知识，也不应该负责导航进出。
2.  每个屏幕都有单独的视图模型。
3.  总体流控制逻辑与 UI 实现相分离，并且可以在没有 UI 的情况下进行测试。
4.  灵活，允许在流程中分支到不同的屏幕。
5.  尽可能简单，但可组合和可扩展。

# 航行

因此，onboarding 可能很简单，可能两三个屏幕询问用户一些简单的个人信息。“下一步”按钮将使用户在流程中向前移动。

![](img/3218fe3e6cd30b6cf7ef2b2265b07de9.png)

简单屏幕流

然而，通常更典型的是带有分支的更复杂的流程。可能用户还没有准备好分享所有这些细节，或者可能需要更多的细节，这取决于之前的回复。所以，也许这更有代表性:

![](img/aaf3e160a92e6b93dc1ce853ef788962.png)

带分支的屏幕流

显然，任何解决方案都需要处理上述内容的任意组合，并且根据宣言第 1 点，要在屏幕本身之外处理这些内容。还应该注意，我们可能希望在每个屏幕条目的末尾进行一些数据查找，因为我们不希望视图本身控制导航(宣言点 3)。

由于我们身处 SwiftUI 的世界，我建议使用`@ViewBuilder`的力量。这是 SwiftUI 视图的`body`里面的“肉”。ViewBuilders 是一种生成复杂泛型类型的强大方法——这是 SwiftUI 声明性本质背后的东西(但超出了本文的范围)。

那会是什么样子呢？好的，一个好的开始是 SwiftUI 相当于`UINavigationController`也就是`NavigationView`。在这里，我们添加了一个 ViewBuilder 树结构的等效物来表示导航节点和边:

好，这真的是伪代码。完全披露——没那么简单😀。

这仍然是“声明性的”，因为它是预定义的，而不是完全编程的，而是动态的，路径由编程逻辑驱动。您仍然需要预先定义每个导航“边缘”。如果你的流程是完全动态的，没有特定的路径，那么这可能不适合你。

也就是说，让我们试着接近这个方法的实现。使用嵌入类型，我们可以从上面创建一个好的分支流程图的声明性定义。它满足了宣言的第一点，也许还有第五点。那么，让我们看看我们是否能实现这样的东西。

`NavigationView`与`NavigationLink`配对，让我们能够进行“传统的”推送导航。有几个不同的用法，但是我专注于完全程序化的用法:

```
NavigationLink(destination: Destination, isActive: Binding<Bool>) { Label }
```

在这里做了一些实验(并对缺乏文档感到沮丧)之后，这里列出了使用`NavigationLink`的注意事项:

1.  需要嵌入到诸如`VStack`的分组中。
2.  如果我们想要一个简单的活动链接来控制导航，那么`Label`通常是`Text`。然而，在我们的例子中，我们不想要导航的外部编程控制的视图，所以我们使用`EmptyView`。
3.  装订很容易出错。如果您想要导航的外部控制(我们也是这样)，为每个导航使用带有标志的较新的`@StateObject`(而不是`@ObservedObject`——见下文)效果很好。
4.  我不喜欢这个命令。对我来说，导航的触发器如果在目的地之前，读起来会更好。

这改进了`NavigationLink`的封装:

这封装了一些`NavigationLink`用法的复杂性。我们可以传入一个绑定标志来允许我们从外部控制导航。需要使用`VStack`和`EmptyView`的管道工作已经为我们完成。它还利用了`@ViewBuilder`来制作一个可读性更好的 NavigationLink 变体。

让我们来看看一个简单的三屏流程的运行情况。我们引入了一个可观察的对象来封装导航标志(更多内容将在后面介绍)。代码如下:

屏幕 1 和 2 都包含三种类型:显示屏幕名称的`Text`，下一个动作的`Button`，以及导航的`Flow`。我们存储每个导航的流状态，内部函数执行实际的导航(`didTapNext1`等)。

这是可行的，但是如果下一个按钮自己直接导航的话，可能会有些过头了。其他形式的`NavigationLink`或许也能扮演这个角色。然而，作为宣言第 3 部分的一部分，我们希望从视图外部控制我们的导航。

应该注意的是，导航应该基于当前活动的屏幕来激活——当用户在屏幕 3 上时将`navigateTo3`设置为`true`将导致一些“奇怪”的结果(它确实导航，但是是即时的，没有动画)。

向后导航到前一个屏幕(包括根屏幕)可以通过将最初将用户从该目的屏幕移开的标志设置为`false`来实现。在上述情况下，通过设置`navigateTo2 = false`从屏幕 2 编程返回屏幕 1。

注:iOS 15 中的一个新功能允许你使用`@Environment(\.dismiss)`。然而，这只是返回一个屏幕，不允许更大的向后跳转(或弹出到根)。使用激活标志允许更完整的控制。

# 查看模型和绑定

继续宣言第 2 点——每个屏幕都有独立的视图模型。在这里，视图模型的使用和实现可能会有所不同，我已经听到了对 SwiftUI 中过度使用 MVVM 设计模式的担忧。这肯定不是苹果官方使用的术语。

我想要的是视图的非 UI 表示，这样我可以干净地封装非 UI 逻辑，在没有视图的情况下对其进行单元测试，当然，也可以轻松地绑定到视图(两种方式)。它还应该是特定于视图的，这样视图就可以四处移动，并且不依赖于任何外部事物(例如，可组合的——声明点 5)。它是视图与应用程序其余部分的接口。我称之为视图模型。

SwiftUI `ObservableObject`(实际上是 Combine 的一部分)是一个很好的视图模型，支持双向视图绑定。然而，在`View`本身中使用`@ObservedObject`可能会有问题，并导致不必要的视图模型重建。使用`@StateObject`的新方法创建了一个稳定的视图模型，仅在需要时才被延迟加载。这是对使用变通方法的旧方法的重大改进。

还要注意，在这个版本的视图模型中，UI 事件也被从视图传递到视图模型中，并且任何特定于视图的逻辑(例如，网络调用)可以从那里被触发(例如，通常向下调用 API 层)。

为了模拟这一点，我们有一个流视图模型(`FlowVM`)来管理屏幕到屏幕的导航。它不知道视图，并且被设计成可测试的。它本身可能需要 API 调用来确定要遵循的路径。这类似于一个“协调器”，但对我来说是导航的模型，因此我使用了“视图模型”这个术语

每个屏幕也有单独的视图模型。这些屏幕视图模型处理 UI 事件和屏幕逻辑。最终(例如，在“下一个”点击之后完成所有屏幕逻辑时)，我们将控制从屏幕视图模型传递回流视图模型，以最终决定导航到哪里。

![](img/057101c480f793e177eb86699d9ffe97.png)

为了完成，从屏幕视图模型返回到流视图模型，我们可以使用各种技术。委托和回调都是有效的实现，但是我喜欢使用 Combine 的`PassthroughSubject`来传递对屏幕视图模型本身的引用。

所以屏幕视图模型和`view`会像这样:

并连接到流程视图模型中，使用`sink`监听如下完成事件，并将其存储在`subscription`中。您会注意到这里处理了创建屏幕视图模型的工厂函数，它还添加了事件监听。该工厂函数由屏幕视图初始化中的流视图调用。

`sink`直接调用一个方法来处理任何逻辑(在这种情况下，它只是简单地设置导航标志)并将订阅存储在附加到`vm`的`Set` 中(它可用于所有订阅)。

# 将它整合在一起

让我们看看，在加入我们的五屏分支流程后，整体看起来如何。您会注意到每个导航边缘都有一个单独的导航标志。您还会注意到，屏幕 3 视图模型需要两个`didTap()`函数和两个`PassthroughSubjects`函数来处理分支逻辑。

查看[回购](https://github.com/nickm01/NavigationFlow)的完整代码。这也包括向后导航的例子(包括回到根目录或屏幕二等)。

# 测试

我们设计的很大一部分是为了提高可测试性，并允许独立于 UI 的导航流的单元测试(宣言点 3)。现在有了视图模型，这很容易做到。这里有一个例子:

我们能够触发“下一步”按钮点击，然后检查导航逻辑是否被触发——所有这些都不需要实际的 UI。

请注意，这显然是一个简单的实现。如果视图模型有 API 调用，我们将不得不考虑一些注入来模拟这些调用。另外，这显然不是 UI 测试。

我们可能还想添加一些 UI 测试(可能使用快照测试)，但这超出了本文的范围。

# 最后…

我希望这有意义！这绝对是一次尝试理解如何使用导航的旅程，我很乐意分享。导航最近有所改进，我真的希望苹果继续改进它。以下是一些建议:

1.  当导航超出简单的情况时，有太多的方法会出错——而文档太少。比如使用`@ObservedObject`，在错误的时间使用错误的激活标志等等。我在大量的帖子和自定义库中看到了这一点。
2.  允许以这样一种方式导航，即不必从正确的屏幕指定和处理每个导航边缘，而只是从任何屏幕声明导航到一个屏幕。
3.  为向后导航创建一个更简单的 API(pop to root，等等)。
4.  而不是 UIKit 更灵活(例如，自定义推送导航动画等。)，使 SwiftUI 导航至少同样灵活…甚至可能更好。

完整的代码可以在 https://github.com/nickm01/NavigationFlow/tree/swiftui3 T2 找到。