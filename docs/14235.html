<html>
<head>
<title>Real-Time Game Server Internals: Basic Theory, Architecture, Optimization, Auto-Scaling</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">实时游戏服务器内部:基本理论，架构，优化，自动缩放</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/real-time-game-server-internals-basic-theory-architecture-optimization-auto-scaling-b2070aa803d9?source=collection_archive---------1-----------------------#2022-11-21">https://betterprogramming.pub/real-time-game-server-internals-basic-theory-architecture-optimization-auto-scaling-b2070aa803d9?source=collection_archive---------1-----------------------#2022-11-21</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="856c" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">了解实时游戏服务器如何在幕后工作——从基本理论到将其部署到AWS云中</h2></div><figure class="kf kg kh ki gt kj gh gi paragraph-image"><div class="ab gu cl kk"><img src="../Images/29076b0a9338abeb908b383191b5fe77.png" data-original-src="https://miro.medium.com/v2/format:webp/1*Xm2GP0VNCE1ctC05qWroEA.png"/></div><p class="kn ko gj gh gi kp kq bd b be z dk translated">作者形象</p></figure><p id="5824" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">这份材料代表了我的文章<a class="ae ln" href="https://habr.com/ru/post/698986/" rel="noopener ugc nofollow" target="_blank">“简单来说就是实时游戏服务器</a>”的英文翻译。</p><h1 id="0d91" class="lo lp iq bd lq lr ls lt lu lv lw lx ly jw lz jx ma jz mb ka mc kc md kd me mf bi translated">这篇文章是给谁的</h1><p id="f4e8" class="pw-post-body-paragraph kr ks iq kt b ku mg jr kw kx mh ju kz la mi lc ld le mj lg lh li mk lk ll lm ij bi translated">下面的文章是为任何对游戏服务器如何工作感兴趣的人准备的，因为，为了简单起见，除了模式和一般的插图之外，不会有大量的代码。我们将讨论您在设计自己的实时服务器时遇到的特殊问题，您有哪些解决方案，以及我们选择了哪一种。欢迎在评论中对我们的选择或材料提出建设性的批评。</p><h1 id="c8d8" class="lo lp iq bd lq lr ls lt lu lv lw lx ly jw lz jx ma jz mb ka mc kc md kd me mf bi translated">为什么它很重要</h1><p id="6553" class="pw-post-body-paragraph kr ks iq kt b ku mg jr kw kx mh ju kz la mi lc ld le mj lg lh li mk lk ll lm ij bi translated">许多程序员心中都有自己制作游戏的秘密。对他们中的一些人来说，这可能是进入it行业的原因之一。但是制作你自己的网络游戏有点复杂，一开始并不明显。然而，和像你这样的真正玩家玩游戏几乎总是比单独玩有趣得多。</p><p id="caed" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">如果你和你的朋友一起玩这个游戏，即使是最无聊的项目也可能会开始发光并产生很多积极的情绪。是许多合作PvE游戏的粉丝，如<em class="ml">深石银河</em>、<em class="ml">残迹:从灰烬中重生</em>、<em class="ml">地狱男爵</em>等。作为一名开发人员，我一直想知道他们的架构是如何构建的:服务器如何管理游戏会话，他们如何同时处理成千上万的玩家，如何使玩家彼此同步，等等。这成了我研究的目的。</p><h1 id="bf59" class="lo lp iq bd lq lr ls lt lu lv lw lx ly jw lz jx ma jz mb ka mc kc md kd me mf bi translated">为什么它值得一读</h1><p id="432e" class="pw-post-body-paragraph kr ks iq kt b ku mg jr kw kx mh ju kz la mi lc ld le mj lg lh li mk lk ll lm ij bi translated">在花了将近一年半的时间开发我们的合作实时游戏后，我们(程序员、平面设计师和声音设计师)终于把它带到了试生产状态。这个项目完全是从热情开始的，以此证明我们可以从头开始创建自己的在线合作游戏(在我的例子中，不需要使用现成的解决方案来组织网络上的多人游戏)。</p><p id="7d6b" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">这个项目本身不会在这里提及，因为它还没有向公众发布(如果这篇文章引起了一些兴趣，那么可能会有一些关于其他开发方面的额外材料，比如声音设计、图形设计、团队合作或者Game Jolt和Itch.io平台的比较)。</p><p id="6901" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">在开发过程中，尤其是项目的后端部分(设计服务器体系结构，优化它，并在云中以容错方式部署它)，我不得不搜索互联网的各个角落，这启发了我写这篇文章，在这篇文章中，我以结构化的方式将我解决问题的所有经验放在了一起，这样，您就拥有了从零开始用任何语言编写自己的游戏服务器所需的一切。</p><h1 id="217d" class="lo lp iq bd lq lr ls lt lu lv lw lx ly jw lz jx ma jz mb ka mc kc md kd me mf bi translated">一点理论:服务器对主机对客户端</h1><figure class="kf kg kh ki gt kj gh gi paragraph-image"><div role="button" tabindex="0" class="mn mo di mp bf mq"><div class="gh gi mm"><img src="../Images/ba27ab9e8c3fac1a5fb786366be13f64.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Vff8q9huqm2sGEwIHLln1w.png"/></div></div></figure><p id="21e1" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">让我们从最基本的开始。假设我们有一个单人游戏，我们扮演一个棍子人。游戏为我们生成敌人，负责提供物体物理。看起来是这样的:</p><figure class="kf kg kh ki gt kj gh gi paragraph-image"><div class="gh gi mr"><img src="../Images/65cd5668bd507b153b751228bb249181.png" data-original-src="https://miro.medium.com/v2/resize:fit:1016/format:webp/0*DN5uqk5hU-oLyTUi.png"/></div></figure><p id="17d4" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">我们想引入双人游戏，因为和某人一起玩游戏总是更有趣，但是我们该怎么做呢？假设我们有了项目的源代码，让我们稍微修改一下。我们将游戏复制到第二台计算机上，复制棍子人，并对我们的计算机进行编程以交换棍子人的坐标，从而使它们在两台计算机上同步:</p><figure class="kf kg kh ki gt kj gh gi paragraph-image"><div role="button" tabindex="0" class="mn mo di mp bf mq"><div class="gh gi ms"><img src="../Images/801e14ab679663ba80630cb9b27c5e1e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*F9s47_XraiSCQ_Ux.png"/></div></div></figure><p id="cc5f" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">糟糕，出现了问题。第一台计算机和第二台计算机产生敌人，所以我们总共有六个敌人，而不是三个。此外，由于它们都是在同一个地方繁殖的，它们根据每台计算机单独计算的物理原理而分散开来。</p><p id="8e2d" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">这里我们有两台计算机的“大脑”之间的冲突每个都生成自己的世界，计算自己的物理量，这就是为什么我们在每台电脑上看到不同的画面。</p><p id="96fc" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">我们怎么解决？我们需要单一的真相来源。只有一台计算机将负责计算物理和生成敌人；这台计算机将在那上面花费它的计算资源，而另一台计算机将在第一台计算机之后重复。这台第二台计算机将只对绘制它们的所有对象的坐标感兴趣:</p><figure class="kf kg kh ki gt kj gh gi paragraph-image"><div role="button" tabindex="0" class="mn mo di mp bf mq"><div class="gh gi mt"><img src="../Images/a9e58c37fa2029898648d97f91ef3dfd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*XCNlt9R8xErgYSGecqY3hg.png"/></div></div></figure><p id="c9de" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">这样，第一台计算机就变成了我们所说的服务器。它为其他玩家(他们的计算机)提供计算资源，并向他们发送游戏状态(所有对象的坐标，可能还有一些其他数据)。其他玩家的计算机，也称为客户端，可以在服务器之后重复(通过绘制相同的游戏状态)并发送用户动作作为回报(例如，键盘或鼠标按下的按钮，如左、右键、右、上等。).</p><p id="6c89" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">因此，我们看到以前完整的游戏现在分成了两部分:服务器端应用程序和客户端应用程序。运行服务器端应用程序的计算机称为主机。</p><p id="42df" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">这是我们玩的在线游戏中使用的通用客户端-服务器架构。</p><h2 id="65cf" class="mu lp iq bd lq mv mw dn lu mx my dp ly la mz na ma le nb nc mc li nd ne me nf bi translated">所以主机和服务器是一回事？</h2><p id="4134" class="pw-post-body-paragraph kr ks iq kt b ku mg jr kw kx mh ju kz la mi lc ld le mj lg lh li mk lk ll lm ij bi translated">不完全是。服务器是应用程序的主要部分，客户端会跟随并重复，而主机是运行服务器的机器。谁将成为该主机是一个问题，根据答案，将为我们提供两种根本不同的体系结构，各有利弊:</p><p id="ac21" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated"><strong class="kt ir"> 1。主机是游戏会话</strong>中一个玩家的计算机</p><p id="d829" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">在这种情况下，其计算机充当主机的玩家拥有游戏的真实实例，因为该玩家的计算机进行所有物理计算并生成对象。</p><figure class="kf kg kh ki gt kj gh gi paragraph-image"><div role="button" tabindex="0" class="mn mo di mp bf mq"><div class="gh gi ng"><img src="../Images/f296ea457be9091b9df9554ab6658b86.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*205BDlxKh2MnFWxgmGkwSA.png"/></div></div></figure><p id="6b23" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">优点:</p><ul class=""><li id="b298" class="nh ni iq kt b ku kv kx ky la nj le nk li nl lm nm nn no np bi translated">游戏开发者不必花很多钱在强大的服务器上，因为玩家的一台计算机将负责所有的计算。通常，开发者的机器只是同步玩家和收集数据，不需要强大的资源。</li></ul><p id="0ed8" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">缺点:</p><ul class=""><li id="ed5e" class="nh ni iq kt b ku kv kx ky la nj le nk li nl lm nm nn no np bi translated">主机玩家将比其他玩家有优势，因为对于主机玩家，ping(延迟)将总是0 ms，所以这种方法对于PvP会话是不公平的，而更适合于合作游戏</li><li id="72e0" class="nh ni iq kt b ku nq kx nr la ns le nt li nu lm nm nn no np bi translated">由于游戏的服务器端部分由其中一个玩家控制，该玩家可以利用它作为作弊的机会</li><li id="034d" class="nh ni iq kt b ku nq kx nr la ns le nt li nu lm nm nn no np bi translated">如果在游戏会话期间，主机玩家机器不再能够处理计算(这对于具有旧硬件的玩家来说是典型的)或者主机在互联网连接上有一些问题，那么它将影响会话中的每个人。它甚至会导致它的终止</li></ul><p id="1fa4" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">正如我们所看到的，这种方法可以为开发人员节省一些资金，但它也有许多风险，因为应用程序的服务器端部分将由主机控制。</p><p id="95d0" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated"><strong class="kt ir"> 2。主机是开发者的电脑(权威服务器)</strong></p><p id="abc4" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">这种架构意味着在线游戏的开发者将自己为玩家提供游戏会话。他们可以通过多种方式实现这一点，他们可以在数据中心租赁/购买一些机器来为游戏会话提供服务，或者他们可以从AWS、Google Cloud、Azure等云提供商那里租赁虚拟机。</p><figure class="kf kg kh ki gt kj gh gi paragraph-image"><div role="button" tabindex="0" class="mn mo di mp bf mq"><div class="gh gi nv"><img src="../Images/6b15e1ec4383a2a292ef86e34b6673d2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ywx42wV6tPYuBUAcdwsFsA.png"/></div></div></figure><p id="bf29" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">优点:</p><ul class=""><li id="7555" class="nh ni iq kt b ku kv kx ky la nj le nk li nl lm nm nn no np bi translated">玩家无法获得服务器端应用程序的代码，这使得作弊和寻找漏洞变得更加困难</li><li id="846a" class="nh ni iq kt b ku nq kx nr la ns le nt li nu lm nm nn no np bi translated">通常，开发者租用稳定的机器来运行他们的服务器，这些服务器具有足够强大的硬件和稳定的网络，以确保所有玩家都能不间断地玩游戏</li><li id="7b01" class="nh ni iq kt b ku nq kx nr la ns le nt li nu lm nm nn no np bi translated">没有一个选手比其他选手有任何优势。每个人都在相同的条件下，每个人都遵循一个权威的服务器，所以这种架构非常适合PvP会话</li></ul><p id="eb20" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">缺点:</p><ul class=""><li id="9308" class="nh ni iq kt b ku kv kx ky la nj le nk li nl lm nm nn no np bi translated">如果一个游戏涉及复杂的世界、物体的生成，以及物理计算，那么即使是处理一个会话，也需要强大的资源(内存、处理器)，因此购买和租用这样的资源对于开发者来说是相当昂贵的</li></ul><h1 id="6401" class="lo lp iq bd lq lr ls lt lu lv lw lx ly jw lz jx ma jz mb ka mc kc md kd me mf bi translated">权威游戏服务器实现</h1><h2 id="1a06" class="mu lp iq bd lq mv mw dn lu mx my dp ly la mz na ma le nb nc mc li nd ne me nf bi translated">为什么选择权威服务器</h2><p id="7b1c" class="pw-post-body-paragraph kr ks iq kt b ku mg jr kw kx mh ju kz la mi lc ld le mj lg lh li mk lk ll lm ij bi translated">有几个原因:</p><ol class=""><li id="3079" class="nh ni iq kt b ku kv kx ky la nj le nk li nl lm nw nn no np bi translated">虽然游戏涉及世界生成和物理计算，但它并不消耗大量的处理器时间(CPU ),因为游戏是2D，所有的动作都发生在一张不大的地图上</li><li id="bee4" class="nh ni iq kt b ku nq kx nr la ns le nt li nu lm nw nn no np bi translated">尽管作弊处理和不间断的游戏会话对PvP游戏来说比合作PvE更重要，但作为一名开发者，当你完全控制你的服务器时，拥有它们还是不错的</li><li id="c5f4" class="nh ni iq kt b ku nq kx nr la ns le nt li nu lm nw nn no np bi translated">服务器是用Python写的。不幸的是，使用Python很难对玩家隐藏服务器的源代码。Python是一种解释型语言，这意味着你的程序不会被编译成机器代码。在Windows的情况下是exe文件),但是表示一些每个人都可以阅读并且Python可以执行的文本文件。<br/>是的，我同意这有一点争议，因为一些技巧使得对Python代码进行逆向工程变得更加困难，实际上，甚至机器代码也没有受到逆向工程的保护，但这一点也使得权威服务器看起来像是我们更好的选择</li></ol><h2 id="53b7" class="mu lp iq bd lq mv mw dn lu mx my dp ly la mz na ma le nb nc mc li nd ne me nf bi translated">Python对于一个有物理的实时游戏有多好</h2><p id="a0e1" class="pw-post-body-paragraph kr ks iq kt b ku mg jr kw kx mh ju kz la mi lc ld le mj lg lh li mk lk ll lm ij bi translated">对于那些知道Python有多慢的人来说，这种语言选择可能看起来很奇怪。但是这里的技巧是，大多数时候，Python并不自己计算公式或物理，相反，它将工作委托给在它的引擎盖下工作的C库。</p><p id="4243" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">例如，对于物理计算，我们使用pymunk库，它建立在2d物理chipmunk库之上，而后者是用C编写的，因此性能很好。</p><p id="2f63" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">Python在服务器上执行以下操作:</p><ul class=""><li id="2c26" class="nh ni iq kt b ku kv kx ky la nj le nk li nl lm nm nn no np bi translated">无限循环(<code class="fe nx ny nz oa b">while True:</code>)，任何游戏的典型代码，所以一个游戏会不断更新，不会停止。重要的是游戏每秒至少更新60次，相当于60 FPS)</li><li id="508e" class="nh ni iq kt b ku nq kx nr la ns le nt li nu lm nm nn no np bi translated">游戏对象创建、事件和玩家连接处理</li></ul><p id="ba2e" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">Python在足够的级别上处理这些任务。</p><h1 id="f09e" class="lo lp iq bd lq lr ls lt lu lv lw lx ly jw lz jx ma jz mb ka mc kc md kd me mf bi translated">游戏会话架构</h1><p id="9acd" class="pw-post-body-paragraph kr ks iq kt b ku mg jr kw kx mh ju kz la mi lc ld le mj lg lh li mk lk ll lm ij bi translated">每个游戏会话在项目中最多可以有三个玩家。但是对于我们这些服务器开发者来说，什么是玩家呢？这是与我们服务器的连接。播放器向我们发送按下的键盘键(左、右、下、空格等)。)，我们回到当前的游戏状态。</p><p id="c13a" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">这是我们需要为所有三个玩家并行执行的算法，这还不是全部。除了我们三个玩家(连接)，我们必须和他们并行处理游戏本身。总的来说，我们有四个“计算线程”(第一个玩家、第二个玩家、第三个玩家和游戏本身)，它们都应该并行运行。</p><p id="35d2" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">我们如何实现这一目标？</p><figure class="kf kg kh ki gt kj gh gi paragraph-image"><div role="button" tabindex="0" class="mn mo di mp bf mq"><div class="gh gi ob"><img src="../Images/f81b9960863481f8a9d39fed7420fa14.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*dUpQm1YoZRksoMcR6cu43Q.png"/></div></div></figure><h2 id="4fca" class="mu lp iq bd lq mv mw dn lu mx my dp ly la mz na ma le nb nc mc li nd ne me nf bi translated">关于并行编程的几句话:进程和线程</h2><p id="b051" class="pw-post-body-paragraph kr ks iq kt b ku mg jr kw kx mh ju kz la mi lc ld le mj lg lh li mk lk ll lm ij bi translated">当您运行一个应用程序(无论是游戏、服务器、浏览器还是任何其他应用程序)时，会在您的计算机上为该应用程序创建一个进程。您可以在任务管理器中看到该过程(在Windows系统上)。每个进程至少包含一个线程。线程是执行在一个处理器内核上运行的进程的一种方式。</p><p id="1338" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">如果您的处理器(CPU)有八个内核，那么一个具有一个线程的进程只能使用该处理器的一个内核(总容量的12.5%)。因此，如果您希望您的应用程序使用所有处理器容量，您需要在该应用程序的进程中创建八个线程，它将利用所有八个可用的CPU内核，这将导致100%地使用处理器容量。因此，通过增加一个进程中的线程数量，我们实现了并行性，这使我们能够同时做几件事情(多任务处理),并提高我们的应用程序的性能。</p><figure class="kf kg kh ki gt kj gh gi paragraph-image"><div class="gh gi oc"><img src="../Images/40b3b4757d62f5b835a1c8054acbd061.png" data-original-src="https://miro.medium.com/v2/resize:fit:1200/format:webp/1*5AUYfyVgkSxMj627HMa0lA.png"/></div></figure><p id="714c" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">在我们的例子中，我们对多任务感兴趣。我们需要并行处理第一个玩家、第二个玩家、第三个玩家以及游戏本身的连接。因此，对于一个游戏进程，我们需要四个线程。但是，仅仅创建四个线程是不够的；我们还应该让他们以某种方式交流，这样他们就可以一起行动，这次有帮助的是一个队列。</p><p id="2809" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">又是一点理论。队列是一个容器，它允许我们安排线程之间的通信。当一些线程将一些信息放入队列时，其他线程可以从该队列中读取这些信息。例如，与第一个玩家连接的线程将该玩家按下的鼠标/键盘键放入一个称为“第一个玩家键队列”的队列中然后，游戏中的一个线程以先进先出(FIFO)的顺序读取该队列，并将该玩家按下的键付诸行动，因此第一个玩家控制的角色开始向该玩家指定的方向移动。</p><h2 id="eb8b" class="mu lp iq bd lq mv mw dn lu mx my dp ly la mz na ma le nb nc mc li nd ne me nf bi translated">游戏会话架构:总体情况</h2><figure class="kf kg kh ki gt kj gh gi paragraph-image"><div role="button" tabindex="0" class="mn mo di mp bf mq"><div class="gh gi od"><img src="../Images/013663378e2c3bff4fca603e4b92cea5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*r744rlg2GpFjNbL7.png"/></div></div></figure><p id="241f" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">如你所见，我们在<code class="fe nx ny nz oa b">Game</code>中有一个线程，它读取(<code class="fe nx ny nz oa b">get</code>操作)三个有用户移动的队列。这个线程成功地并行捕获所有玩家按下的键。在处理这些玩家按下的键(通过移动他们的角色)之后，游戏线程将当前游戏状态(所有对象坐标)放入每个玩家的队列`<code class="fe nx ny nz oa b">Objects</code> ` (` <code class="fe nx ny nz oa b">put</code>`操作)中。</p><p id="5423" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">这使得玩家的线程可以从那里读取当前的游戏状态，并将其发送到玩家的计算机，以更新他们的游戏状态，以响应他们按下的键，所有这些应该每秒发生60次(60 FPS)。</p><p id="7b5a" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">这样，我们得到了一个非常简单但有效的系统，如下所示:</p><ul class=""><li id="416d" class="nh ni iq kt b ku kv kx ky la nj le nk li nl lm nm nn no np bi translated">玩家发送他们按下的鼠标/键盘键，游戏处理它，移动他们的角色，并发送当前游戏状态作为回报(所有对象的坐标)。</li><li id="5d6d" class="nh ni iq kt b ku nq kx nr la ns le nt li nu lm nm nn no np bi translated">当玩家玩在线游戏时，他们可能甚至没有意识到所有这些过程都发生在幕后。对他们来说，似乎他们按了“左”，字符向左移动只是因为计算机让他们向左移动，但实际上，计算机向远程服务器发送了一个按下的键。</li><li id="474b" class="nh ni iq kt b ku nq kx nr la ns le nt li nu lm nm nn no np bi translated">这个服务器有一个与用户连接的线程，这个线程将这个按键放入一个特殊的队列中。</li><li id="dcf0" class="nh ni iq kt b ku nq kx nr la ns le nt li nu lm nm nn no np bi translated">在此之后，线程从队列中读取按键，将其付诸行动(移动玩家的角色)，并将游戏状态(坐标)发送到另一个特殊队列。</li><li id="2edb" class="nh ni iq kt b ku nq kx nr la ns le nt li nu lm nm nn no np bi translated">最后，与用户连接的线程从那里读取游戏状态，将该状态发送到玩家的PC，PC通过新坐标重新绘制所有对象。</li></ul><p id="ae9f" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">这就是全部的魔力。</p><h1 id="e9ae" class="lo lp iq bd lq lr ls lt lu lv lw lx ly jw lz jx ma jz mb ka mc kc md kd me mf bi translated">浅谈Python及其线程问题</h1><p id="0fc9" class="pw-post-body-paragraph kr ks iq kt b ku mg jr kw kx mh ju kz la mi lc ld le mj lg lh li mk lk ll lm ij bi translated">不幸的是，Python不允许所有四个线程同时活动，这已经不是什么秘密了。由于Python程序员中众所周知的<a class="ae ln" href="https://realpython.com/python-gil/" rel="noopener ugc nofollow" target="_blank">全局解释器锁(GIL) </a>，一次只能有一个线程处于活动状态。</p><p id="25a4" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">所以，在Python中，我们没有使用四个线程的四个核心，而是只有一个核心，所以我们没有提高性能，因为这四个线程在Python中不是并行运行的)。</p><p id="96fb" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">尽管如此，我们实现了多任务处理，一个CPU核心的容量已经足够三个连接和游戏本身。</p><h2 id="f8ec" class="mu lp iq bd lq mv mw dn lu mx my dp ly la mz na ma le nb nc mc li nd ne me nf bi translated">如何管理游戏会话</h2><p id="0d13" class="pw-post-body-paragraph kr ks iq kt b ku mg jr kw kx mh ju kz la mi lc ld le mj lg lh li mk lk ll lm ij bi translated">上面描述的架构只涵盖了游戏会话本身，但是我们仍然需要另一个流程来编排这些游戏会话(或者更准确地说，它们的流程)，比如创建、跟踪和删除。</p><p id="cb50" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">这是玩家在进入游戏会话之前将与之互动的过程。让我们称这个进程为主服务器。玩家将要求主服务器给他们一个当前会话列表(以连接到他们)或创建一个新的会话。让我们看看这种交流是什么样子的:</p><figure class="kf kg kh ki gt kj gh gi paragraph-image"><div role="button" tabindex="0" class="mn mo di mp bf mq"><div class="gh gi oe"><img src="../Images/a3d030de298c0542c68d403267bcadbf.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*bbgdMrPYu3LuoNv79jrqKA.png"/></div></div></figure><h1 id="927a" class="lo lp iq bd lq lr ls lt lu lv lw lx ly jw lz jx ma jz mb ka mc kc md kd me mf bi translated">优化:为什么要优化</h1><p id="1a48" class="pw-post-body-paragraph kr ks iq kt b ku mg jr kw kx mh ju kz la mi lc ld le mj lg lh li mk lk ll lm ij bi translated">由于该项目首先是实时的(意味着我们应该尽可能减少玩家按下键盘按键和看到结果之间的时间)，我们必须在服务器和客户端上引入一些优化，以实现最佳的性能和稳定性。</p><h1 id="3bac" class="lo lp iq bd lq lr ls lt lu lv lw lx ly jw lz jx ma jz mb ka mc kc md kd me mf bi translated">服务器优化</h1><h2 id="f61d" class="mu lp iq bd lq mv mw dn lu mx my dp ly la mz na ma le nb nc mc li nd ne me nf bi translated">1.数据是如何发送的</h2><p id="1944" class="pw-post-body-paragraph kr ks iq kt b ku mg jr kw kx mh ju kz la mi lc ld le mj lg lh li mk lk ll lm ij bi translated">服务器和客户端最初都是用Python编写的(客户端在一段时间后用Unity C#重写)，所以我们有机会使用Python发送数据的方式，即“pickle”以下是此类数据流量的一个示例(从服务器到客户端):</p><pre class="kf kg kh ki gt of oa og bn oh oi bi"><span id="6361" class="oj lp iq oa b be ok ol l om on">[&lt;network_classes.border.NetworkBorder object at 0x000001A44EF51070&gt;, <br/>&lt;network_classes.border.NetworkBorder object at 0x000001A44EF51280&gt;, <br/>&lt;network_classes.border.NetworkBorder object at 0x000001A44EF51040&gt;, <br/>&lt;network_classes.border.NetworkBorder object at 0x000001A44EF83550&gt;, <br/>&lt;network_classes.border.NetworkBorder object at 0x000001A44EF83520&gt;, <br/>&lt;network_classes.border.NetworkBorder object at 0x000001A44EF834F0&gt;, <br/>&lt;network_classes.border.NetworkBorder object at 0x000001A44EEAF790&gt;, <br/>&lt;network_classes.player_ball.PlayerNetworkBall object at 0x000001A44EEAF6D0&gt; ……..]</span></pre><p id="d301" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">使用Pickle在服务器和客户机之间交换数据的利与弊:</p><p id="ae1f" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">优点:</p><ul class=""><li id="c675" class="nh ni iq kt b ku kv kx ky la nj le nk li nl lm nm nn no np bi translated">易于在Python上实现</li></ul><p id="c04b" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">缺点:</p><ul class=""><li id="a679" class="nh ni iq kt b ku kv kx ky la nj le nk li nl lm nm nn no np bi translated">实时项目的重物</li><li id="1183" class="nh ni iq kt b ku nq kx nr la ns le nt li nu lm nm nn no np bi translated">不跨平台(服务器和客户端都必须用Python编写)</li><li id="4c53" class="nh ni iq kt b ku nq kx nr la ns le nt li nu lm nm nn no np bi translated">安全问题(<a class="ae ln" href="https://docs.python.org/3/library/pickle.html" rel="noopener ugc nofollow" target="_blank">)恶意pickle数据可能会在拆包过程中执行任意代码。</a>因此，这种方法更适合您可以信任发送者的私有网络)</li></ul><p id="976c" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">对pickle相关问题的认识使我们转向了另一种更通用的数据发送方式——JSON，这种数据流量的一个例子:</p><pre class="kf kg kh ki gt of oa og bn oh oi bi"><span id="16b5" class="oj lp iq oa b be ok ol l om on">[<br/>  {x: 12, y: 10, id: 30, radius: 80, color: “red”, cls: “ball”}, <br/>  {a_x: 22, a_y: 45, b_x: 122, b_y: 145, id: 45, color: “blue”, cls: “border”},<br/>  ...<br/>]</span></pre><p id="f633" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">优点:</p><ul class=""><li id="30da" class="nh ni iq kt b ku kv kx ky la nj le nk li nl lm nm nn no np bi translated">仍然易于实现</li><li id="b290" class="nh ni iq kt b ku nq kx nr la ns le nt li nu lm nm nn no np bi translated">没有安全风险</li><li id="7a84" class="nh ni iq kt b ku nq kx nr la ns le nt li nu lm nm nn no np bi translated">跨平台</li></ul><p id="bd99" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">缺点:</p><ul class=""><li id="f70c" class="nh ni iq kt b ku kv kx ky la nj le nk li nl lm nm nn no np bi translated">对于实时项目来说仍然是沉重的对象(JSON数据由键和值组成。虽然值不断变化，值得在每个游戏帧发送，但密钥保持不变，代表冗余的字节数。另外，我们应该总是在发送时序列化JSON，在接收时反序列化，这会花费一些处理器时间)</li></ul><p id="90b6" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">为了实现最佳优化，已经决定切换到通常的值字符串，并使用值本身的顺序而不是键。以下是此类数据流量的一个示例:</p><pre class="kf kg kh ki gt of oa og bn oh oi bi"><span id="4424" class="oj lp iq oa b be ok ol l om on">1.2.0.0.800.0.10.20.0.5;1.3.1200.0.2000.0.10.20.0.5;1.4.0.1200.2000.1200.10.20.0.5;1.5.0.0.0.640.10.20.0.5;1.6.0.960.0.1200.10.20.0.5;1.7.2000.0.2000.640.10.40.0.5;1.8.2000.960.2000.1200.10.40.0.5;3.11.400.100.90;3.12.1500.1100.90;3.13.1900.1000.120;3.14.300.1100.160;3.15.1200.600.50;3.16.700.1000.80;3.17.1600.700.170;3.18.800.900.170;2.1.832.1130.60.0.5.1.0.0;4.22.1832.1495.140;4.23.288.948.150;5.25.1855.531.60.7;5.26.1290.1130.60.7….</span></pre><p id="0140" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">现在我们没有多余的数据；我们有纯值和分隔符。</p><p id="0bcc" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">我们为客户做同样的事情。例如，以前，它以JSON格式发送按键数据。看起来像这样:</p><pre class="kf kg kh ki gt of oa og bn oh oi bi"><span id="ce20" class="oj lp iq oa b be ok ol l om on">{“up”: true, “right”: true, “left”: false, “down”: false, “attack”: false, “accelerate”: false}</span></pre><p id="23af" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">现在，它只发送一串纯值，其中包含相同的数据，但长度缩短了约10倍:</p><pre class="kf kg kh ki gt of oa og bn oh oi bi"><span id="41f5" class="oj lp iq oa b be ok ol l om on">110000</span></pre><p id="6141" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">优点:</p><ul class=""><li id="5a3a" class="nh ni iq kt b ku kv kx ky la nj le nk li nl lm nm nn no np bi translated">没有安全风险</li><li id="93a3" class="nh ni iq kt b ku nq kx nr la ns le nt li nu lm nm nn no np bi translated">轻质物体</li><li id="759a" class="nh ni iq kt b ku nq kx nr la ns le nt li nu lm nm nn no np bi translated">跨平台(唯一的事情是我们必须在客户机和服务器上实现打包和解包逻辑，这是一对<code class="fe nx ny nz oa b">split</code>操作符)</li></ul><p id="8fec" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">缺点:</p><ul class=""><li id="f85e" class="nh ni iq kt b ku kv kx ky la nj le nk li nl lm nm nn no np bi translated">难以实施和维护</li></ul><p id="a62e" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">但是对我来说利大于弊，所以我坚持这个方法。</p><h2 id="e536" class="mu lp iq bd lq mv mw dn lu mx my dp ly la mz na ma le nb nc mc li nd ne me nf bi translated">2.密切关注阻塞操作</h2><p id="acc9" class="pw-post-body-paragraph kr ks iq kt b ku mg jr kw kx mh ju kz la mi lc ld le mj lg lh li mk lk ll lm ij bi translated">如果你的程序包含几个线程和连接，重要的是要注意不要出现一个线程停止，其他线程也停止的情况，因为它们在等待它的输入。</p><p id="726b" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">例如，在我们处理游戏会话的过程中，我们有一个带有玩家连接的线程，它将玩家按下的键放入一个特殊的队列中，供游戏读取。这里很重要的一点是，如果游戏线程读取了这个队列，却没有得到任何数据(因为队列还是空的，比如某个玩家连接不好，无法发送其数据)，那么游戏线程就更进一步，不会因为这个玩家而停止，不会等待他们。在Python中，您需要明确指定线程不应该等待队列给出信息，因为默认情况下<code class="fe nx ny nz oa b">get</code>操作是阻塞的。</p><p id="a024" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">所以这段代码:</p><pre class="kf kg kh ki gt of oa og bn oh oi bi"><span id="e412" class="oj lp iq oa b be ok ol l om on">player_move = player.move_queue.get()<br/>player.move(player_move)</span></pre><p id="8d98" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">应该这样重构:</p><pre class="kf kg kh ki gt of oa og bn oh oi bi"><span id="588d" class="oj lp iq oa b be ok ol l om on">try:<br/>	player_move = player.move_queue.get(block=False)<br/>except Empty:<br/>	player_move = previous_player_move<br/>player.move(player_move)</span></pre><p id="252f" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">如果我们没有收到玩家按下的按键，我们可能会认为他们仍然在按下之前的按键，所以让我们再次分配这个数据，并进一步。</p><h2 id="edc1" class="mu lp iq bd lq mv mw dn lu mx my dp ly la mz na ma le nb nc mc li nd ne me nf bi translated">3.关闭套接字(连接)的缓冲</h2><p id="a50a" class="pw-post-body-paragraph kr ks iq kt b ku mg jr kw kx mh ju kz la mi lc ld le mj lg lh li mk lk ll lm ij bi translated">默认情况下，套接字在到达某个缓冲区时发送数据(从客户端到服务器，反之亦然)。为了立即发送数据，我们需要在服务器和客户机上都关闭Nagle的算法:</p><pre class="kf kg kh ki gt of oa og bn oh oi bi"><span id="309c" class="oj lp iq oa b be ok ol l om on">s = socket.socket(socket.AF_INET, socket.SOCK_STREAM) <br/>s.setsockopt(socket.IPPROTO_TCP, socket.TCP_NODELAY, 1)</span></pre><h2 id="f849" class="mu lp iq bd lq mv mw dn lu mx my dp ly la mz na ma le nb nc mc li nd ne me nf bi translated">4.使用TCP协议，而不是UDP</h2><p id="1300" class="pw-post-body-paragraph kr ks iq kt b ku mg jr kw kx mh ju kz la mi lc ld le mj lg lh li mk lk ll lm ij bi translated">说到数据流，我们会立即想到UDP，因为它发送数据时不进行任何其他处理。一些网络数据包可能会丢失，一些可能会重复，但它比TCP快得多，确保所有网络数据包有序和完整。</p><p id="a033" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">如果我们有糟糕的网络和连接问题，TCP可能会带来一些延迟，但现在，几乎每个人都有良好的互联网连接，所以TCP不必带着相同的数据包来回运行。如前所述，它保证了数据的顺序。如果我们使用UDP，那么在处理之前，我们应该确保通过一些验证过程获得可靠的未被破坏的数据，这导致实现TCP已经为我们做的一些事情。</p><p id="6845" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated"><strong class="kt ir">注</strong>:这有点争议，因为并不是所有地区都有很好的连接(尤其是移动数据)，所以有时候我们不得不坚持UDP协议，至少对于人物的移动来说是这样。</p><h2 id="ceaf" class="mu lp iq bd lq mv mw dn lu mx my dp ly la mz na ma le nb nc mc li nd ne me nf bi translated">5.在服务器消息之间添加分隔符</h2><p id="919c" class="pw-post-body-paragraph kr ks iq kt b ku mg jr kw kx mh ju kz la mi lc ld le mj lg lh li mk lk ll lm ij bi translated">然而，TCP协议没有解决一个问题。尽管它保证了数据的顺序，但它不保证这些数据会出现在一个数据包中。</p><p id="9234" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">例如，如果我们要发送<code class="fe nx ny nz oa b">Hello world</code>和<code class="fe nx ny nz oa b">Hi all</code>，它们可能会以下列方式出现:<code class="fe nx ny nz oa b">Hell</code>、<code class="fe nx ny nz oa b">o wor</code>、<code class="fe nx ny nz oa b">ldHi all</code>。因此，在消息之间添加一些分隔符非常重要。</p><p id="dfb5" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">假设<code class="fe nx ny nz oa b">?</code>是消息的开始，而<code class="fe nx ny nz oa b">!</code>是消息的结束，那么如果我们发送<code class="fe nx ny nz oa b">?Hello world!</code>和<code class="fe nx ny nz oa b">?Hi all!</code>并获得<code class="fe nx ny nz oa b">?Hell</code>、<code class="fe nx ny nz oa b">o wor</code>、<code class="fe nx ny nz oa b">ld!?Hi all!</code>，我们可以很容易地使用分隔符将这些消息连接起来，并获得我们的原始消息，即<code class="fe nx ny nz oa b">Hello world</code>和<code class="fe nx ny nz oa b">Hi all</code>。</p><h1 id="c3a9" class="lo lp iq bd lq lr ls lt lu lv lw lx ly jw lz jx ma jz mb ka mc kc md kd me mf bi translated">客户端优化</h1><h2 id="7981" class="mu lp iq bd lq mv mw dn lu mx my dp ly la mz na ma le nb nc mc li nd ne me nf bi translated">预测算法</h2><p id="7cd9" class="pw-post-body-paragraph kr ks iq kt b ku mg jr kw kx mh ju kz la mi lc ld le mj lg lh li mk lk ll lm ij bi translated">有时，网络会不稳定0.5-2秒。当它发生时，客户端没有从服务器获得任何数据，所以游戏为客户端而停止。如果经常发生，玩家会看到抽搐的物体，这会破坏游戏体验。</p><p id="875c" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">我们该如何处理？通常，在0.5-2秒内，没有什么特别的事情发生。向特定方向移动的对象仍然在那里移动，所以如果我们没有来自服务器的数据，我们可以根据它们最后的坐标保持所有对象以它们最后计算的速度移动。例如:</p><p id="8d44" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">取以前的坐标:<code class="fe nx ny nz oa b">(500, -403)</code></p><p id="f0c7" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">取当前坐标:<code class="fe nx ny nz oa b">(503, -410)</code></p><p id="da40" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">计算理论速度:</p><p id="541d" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated"><code class="fe nx ny nz oa b">speed_x = 503–500 = 3 pixels</code></p><p id="91f5" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated"><code class="fe nx ny nz oa b">speed_y = -410 + 403 = -7 pixels</code></p><p id="ddb7" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">请注意，这个理论速度应该由服务器计算，而不是由客户端计算，并与其他数据一起发送到客户端。因为客户端可能会因为数据包丢失而误算这个理论速度。</p><p id="1d4b" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">因此，只要我们没有来自服务器的数据，下一个理论坐标将是:<code class="fe nx ny nz oa b">(506, -417)</code>，然后是<code class="fe nx ny nz oa b">(509, -424)</code>，等等。</p><h1 id="124f" class="lo lp iq bd lq lr ls lt lu lv lw lx ly jw lz jx ma jz mb ka mc kc md kd me mf bi translated">部署</h1><p id="fbb2" class="pw-post-body-paragraph kr ks iq kt b ku mg jr kw kx mh ju kz la mi lc ld le mj lg lh li mk lk ll lm ij bi translated">现在我们有了一个可行的优化解决方案，我们可以开始讨论部署它了。</p><h2 id="ab2e" class="mu lp iq bd lq mv mw dn lu mx my dp ly la mz na ma le nb nc mc li nd ne me nf bi translated">什么是动态自动缩放</h2><p id="9862" class="pw-post-body-paragraph kr ks iq kt b ku mg jr kw kx mh ju kz la mi lc ld le mj lg lh li mk lk ll lm ij bi translated">动态自动扩展是一种根据工作负载自动更改多种资源的方式。</p><p id="8c01" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">在我们的例子中，这意味着拥有尽可能多的虚拟机(=运行服务器的主机)来为玩家处理所有游戏会话，并根据玩家的需求自动增加/减少它们的数量。</p><h2 id="c6a5" class="mu lp iq bd lq mv mw dn lu mx my dp ly la mz na ma le nb nc mc li nd ne me nf bi translated">为什么小型独立项目需要具有动态自动扩展功能的基础设施</h2><p id="e519" class="pw-post-body-paragraph kr ks iq kt b ku mg jr kw kx mh ju kz la mi lc ld le mj lg lh li mk lk ll lm ij bi translated">让我们看一个简单的方法来部署我们的权威游戏服务器:</p><figure class="kf kg kh ki gt kj gh gi paragraph-image"><div role="button" tabindex="0" class="mn mo di mp bf mq"><div class="gh gi oo"><img src="../Images/a81c8b811bb0bf9f7a14ee47e6032b82.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*koO5D84TxOAYsoGP.png"/></div></div></figure><p id="d514" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">如果我们想以较低的ping频率覆盖地球上的大部分地区，我们可以租用三台或多或少功能强大的机器，每台机器位于不同的区域。在我的例子中，一台CPU优化的虚拟机可以处理多达30个游戏会话，在DigitalOcean(一家云提供商，允许你租用虚拟机等远程资源来运行你的服务器)中的价格是90美元。</p><p id="80e3" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">这种做法很好理解。三台机器在各自的区域，每台都有自己的游戏时段，你为每台机器支付固定的价格(总共约300美元)。</p><p id="a291" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">虽然这个解决方案对独立开发者来说似乎很简单，但它非常昂贵，例如，我们的项目根本不是商业项目，所以如果可能的话，削减成本会很好。显而易见，我们可以想到的是采用功能较弱的机器，但我们马上就会有很多“如果”:</p><ul class=""><li id="cd99" class="nh ni iq kt b ku kv kx ky la nj le nk li nl lm nm nn no np bi translated">如果游戏引起了兴趣，而服务器无法处理高工作负载，该怎么办？</li><li id="b37a" class="nh ni iq kt b ku nq kx nr la ns le nt li nu lm nm nn no np bi translated">如果服务器出现故障，无法处理任何玩家，除非我们手动重启，怎么办？</li><li id="342b" class="nh ni iq kt b ku nq kx nr la ns le nt li nu lm nm nn no np bi translated">就算我们拿一个强大的服务器，万一它遭遇了DDoS攻击呢？</li><li id="f509" class="nh ni iq kt b ku nq kx nr la ns le nt li nu lm nm nn no np bi translated">如果我们所有的担心都是徒劳的呢？这个项目不会引起任何兴趣，300块钱就没了。</li></ul><p id="ff6c" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">要是有一种方法可以在生产中动态地解决这个问题就好了。如果我们的服务器中有1-2个游戏会话，那么就让一个弱的虚拟机托管服务器并处理它们。我们可以临时增加虚拟机的数量来处理所有的游戏会话，然后在我们不需要它们时释放它们。</p><p id="f7b4" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">在AWS等大型云提供商的帮助下，我们可以实现这一场景:</p><figure class="kf kg kh ki gt kj gh gi paragraph-image"><div role="button" tabindex="0" class="mn mo di mp bf mq"><div class="gh gi op"><img src="../Images/1f4e6eab30fa5f39c0341617c5aee24e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*btMOxt63igks_EXE.png"/></div></div></figure><p id="143f" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">现在，在每个地区，我们有一组资源，而不只是一个大型虚拟机，这些资源总是包含至少一个虚拟机，在我们的情况下，这是AWS中的一个<code class="fe nx ny nz oa b">t2.micro</code>机器，它能够处理三个游戏会话，如果全天候运行，每月费用为10美元。</p><p id="02e3" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">在三个地区部署这种基础设施每个月会产生大约30美元(如果没有人在我们的游戏服务器上玩，这对独立项目来说是很现实的，但在这种情况下，我们只会损失30美元，而不是上面描述的300美元)。</p><h1 id="7ea5" class="lo lp iq bd lq lr ls lt lu lv lw lx ly jw lz jx ma jz mb ka mc kc md kd me mf bi translated">为什么选择AWS</h1><p id="0374" class="pw-post-body-paragraph kr ks iq kt b ku mg jr kw kx mh ju kz la mi lc ld le mj lg lh li mk lk ll lm ij bi translated">AWS拥有该基础设施所需的一切。当然，可以使用其他大型云提供商来构建类似的基础设施，但AWS有大量的文档和大型社区，所以解决每个小问题并不需要花费太多时间。但是，如果我们忽略这种动态扩展，由于其简单的虚拟机配置和定价政策，DigitalOcean看起来是一个更好的选择。</p><h2 id="d89e" class="mu lp iq bd lq mv mw dn lu mx my dp ly la mz na ma le nb nc mc li nd ne me nf bi translated">AWS中的所有外观</h2><p id="ac57" class="pw-post-body-paragraph kr ks iq kt b ku mg jr kw kx mh ju kz la mi lc ld le mj lg lh li mk lk ll lm ij bi translated">对于我们希望部署基础架构的每个地区，我们都有以下图片:</p><figure class="kf kg kh ki gt kj gh gi paragraph-image"><div role="button" tabindex="0" class="mn mo di mp bf mq"><div class="gh gi oq"><img src="../Images/bfb948e2fae49a80676d6aee600b1d61.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*vXu06F3uwozXmBiZ0tND8Q.png"/></div></div></figure><p id="52f7" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">我们这里有什么，为什么:</p><h2 id="b7ef" class="mu lp iq bd lq mv mw dn lu mx my dp ly la mz na ma le nb nc mc li nd ne me nf bi translated">目标群</h2><p id="b61b" class="pw-post-body-paragraph kr ks iq kt b ku mg jr kw kx mh ju kz la mi lc ld le mj lg lh li mk lk ll lm ij bi translated">代表一组托管游戏服务器的虚拟机。这是它在AWS中的样子:</p><figure class="kf kg kh ki gt kj gh gi paragraph-image"><div role="button" tabindex="0" class="mn mo di mp bf mq"><div class="gh gi or"><img src="../Images/ffa949685e7475210b947cbd4f5583f1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*fF6WkIY0j_aL2YGn.png"/></div></div></figure><p id="bf54" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">我们可以看到，目前这个目标组只有一台机器(在注册的目标中)，并且它被标记为健康。AWS如何检查这一点？负载平衡器(如下所述)检查服务器运行的端口，它在几秒钟内检查一次(我们指定这个数字)，如果它得到任何响应，它将我们的机器标记为安全和完好。</p><p id="2914" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">一点理论:我们的服务器在一个与其进程相关联的特定端口上工作(在我们的例子中是T1 );它需要创建一个虚拟点，这样我们就可以开始和结束玩家的连接。</p><h1 id="3db7" class="lo lp iq bd lq lr ls lt lu lv lw lx ly jw lz jx ma jz mb ka mc kc md kd me mf bi translated">弹性负载平衡器</h1><p id="90f4" class="pw-post-body-paragraph kr ks iq kt b ku mg jr kw kx mh ju kz la mi lc ld le mj lg lh li mk lk ll lm ij bi translated">表示一个负载平衡器，它接受来自播放器的连接，并以循环方式(循环顺序)将其重定向到目标组中的一台计算机。不幸的是，弹性负载平衡器(ELB)不跟踪诸如CPU(处理器)利用率之类的虚拟机特征，所以它不考虑哪些虚拟机已加载，哪些未加载。</p><p id="df44" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">在下面的截图中，你可以看到ELB的主要组成部分，那就是<code class="fe nx ny nz oa b">Listener</code>。它定义了等待玩家的端口，以及当玩家尝试连接时将玩家重定向到哪个目标组:</p><figure class="kf kg kh ki gt kj gh gi paragraph-image"><div role="button" tabindex="0" class="mn mo di mp bf mq"><div class="gh gi or"><img src="../Images/ad6b12af5078559875cb4667f4254df4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*7iFWnCLx3t0Rt6kG.png"/></div></div></figure><h1 id="b4b3" class="lo lp iq bd lq lr ls lt lu lv lw lx ly jw lz jx ma jz mb ka mc kc md kd me mf bi translated">自动缩放</h1><p id="237b" class="pw-post-body-paragraph kr ks iq kt b ku mg jr kw kx mh ju kz la mi lc ld le mj lg lh li mk lk ll lm ij bi translated">进行自动缩放。它监控目标组中虚拟机的指标，并设置:</p><ul class=""><li id="d341" class="nh ni iq kt b ku kv kx ky la nj le nk li nl lm nm nn no np bi translated">最小容量—(目标组中虚拟机的最小数量)。这是从一开始就将运行的机器数量</li><li id="2fe5" class="nh ni iq kt b ku nq kx nr la ns le nt li nu lm nm nn no np bi translated">所需容量—(所需的虚拟机数量)。该数值将根据负载自动变化</li><li id="265c" class="nh ni iq kt b ku nq kx nr la ns le nt li nu lm nm nn no np bi translated">最大容量—这是我们允许自动扩展服务运行的最大虚拟机数量(因为每个虚拟机毕竟都要花钱)</li></ul><figure class="kf kg kh ki gt kj gh gi paragraph-image"><div role="button" tabindex="0" class="mn mo di mp bf mq"><div class="gh gi os"><img src="../Images/62838a46ba33f3cf0df64b3c3d6b5a62.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*UKbKbq0nFg7xK0JY.png"/></div></div></figure><p id="c1c0" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">此外，自动缩放包含一个启动模板；它是一个指令，告诉it部门如何运行一个新的虚拟机，选择什么硬件和操作系统，以及运行什么命令:</p><figure class="kf kg kh ki gt kj gh gi paragraph-image"><div role="button" tabindex="0" class="mn mo di mp bf mq"><div class="gh gi ot"><img src="../Images/b500e178dd482c0ecc165ee5c4817b73.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*KvAaTF7u3b37qnDY.png"/></div></div></figure><p id="f0a2" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">此外，自动扩展包含一个动态扩展策略，我们在该策略中告知何时应该添加或删除装有服务器的虚拟机:</p><figure class="kf kg kh ki gt kj gh gi paragraph-image"><div role="button" tabindex="0" class="mn mo di mp bf mq"><div class="gh gi ou"><img src="../Images/9b37ffcaf491f7adf6c61ae42d29c76c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*mKLn3RIvcxDKDfoD.png"/></div></div></figure><p id="e214" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">在我们的例子中，据说，“每台机器上的平均CPU利用率不应该超过70%。根据需要添加/删除虚拟机，并在启动后给每个虚拟机60秒的时间，然后再考虑其指标”。</p><h1 id="e76a" class="lo lp iq bd lq lr ls lt lu lv lw lx ly jw lz jx ma jz mb ka mc kc md kd me mf bi translated">DynamoDB</h1><p id="0a71" class="pw-post-body-paragraph kr ks iq kt b ku mg jr kw kx mh ju kz la mi lc ld le mj lg lh li mk lk ll lm ij bi translated">该服务代表一个NoSQL数据库，并作为游戏会话元数据的临时存储。我们为什么需要它？问题是，我们的目标组中的每个虚拟机都是独立的机器，每个都有自己的游戏会话，并且不知道其他机器。</p><p id="d007" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">让我们设想一种情况，你和你的朋友在一个地区玩游戏，你想连接到他们的会话，但结果是你在该地区内的两个不同的虚拟机上玩游戏，所以你需要连接到你的朋友正在玩游戏的虚拟机。你是怎么做到的？这就是DynamoDB可以帮助你的地方。</p><p id="57f0" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">目标组中的所有虚拟机都将其游戏会话的元数据发送到DynamoDB (IP地址+端口+会话中有多少玩家+任何其他有用的元数据)，无论您连接到什么虚拟机，如果您向该虚拟机请求当前会话的列表，它都会通过从DynamoDB获取所有虚拟机的所有游戏会话的列表。</p><p id="eb31" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">因此，游戏客户端(玩家用来玩游戏的)从服务器接收所有会话，看到它寻找的会话位于不同的IP地址，并连接到该地址，当然它是自动连接的，所以玩家不会注意到这些过程。</p><p id="23c9" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">通过这种方式，一组独立的虚拟机可以作为单个机制工作。</p><p id="4e2f" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">游戏会话在该数据库中的外观:</p><figure class="kf kg kh ki gt kj gh gi paragraph-image"><div role="button" tabindex="0" class="mn mo di mp bf mq"><div class="gh gi ov"><img src="../Images/c0c0d2c7976932a8e7bcb9ddef551188.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*nCFW-_YWm69OwfvU.png"/></div></div></figure><h2 id="92a1" class="mu lp iq bd lq mv mw dn lu mx my dp ly la mz na ma le nb nc mc li nd ne me nf bi translated">游戏的客户端部分现在与谁对话，直接与负载平衡器还是虚拟机对话？</h2><p id="6866" class="pw-post-body-paragraph kr ks iq kt b ku mg jr kw kx mh ju kz la mi lc ld le mj lg lh li mk lk ll lm ij bi translated">都是。我们可以要求自动扩展为它启动的每个虚拟机分配一个公共IP:</p><figure class="kf kg kh ki gt kj gh gi paragraph-image"><div role="button" tabindex="0" class="mn mo di mp bf mq"><div class="gh gi ow"><img src="../Images/9c1ca031abf3f95c0621567a9b1c9625.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*bvFknUJ96GrUB5_F.png"/></div></div></figure><p id="998f" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">这样，我们使用负载平衡器做两件事，我们连接到一个随机的虚拟机，它要么为我们创建一个新的游戏会话，要么给我们一个当前游戏会话的列表。一旦我们有一个会话，我们使用它的元数据(IP +端口)直接连接到它，而不需要负载平衡器的参与。</p><h2 id="1deb" class="mu lp iq bd lq mv mw dn lu mx my dp ly la mz na ma le nb nc mc li nd ne me nf bi translated">这个基础设施有多有效</h2><p id="0c6f" class="pw-post-body-paragraph kr ks iq kt b ku mg jr kw kx mh ju kz la mi lc ld le mj lg lh li mk lk ll lm ij bi translated">AWS为虚拟机提供基本或详细的监控(需额外付费)。基本监控(CPU/磁盘/网络使用情况等。)每五分钟向cloud watch(AWS中的云监控服务)发送其指标。因此，它会影响自动伸缩性能，因为它会根据这些指标做出决策，以五分钟的延迟采取措施。</p><p id="70be" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">这里我们有两个解决方案:启用详细监控以每分钟而不是五分钟发送指标，或者降低阈值以启动新的虚拟机。例如，如果您计划在平均CPU利用率为70%时启动一个新的虚拟机，则将其设为50%，以便自动扩展可以提前做出反应。</p><p id="15d6" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">让我们看一个例子。我们将通过三个游戏会话使目标组中当前虚拟机的CPU过载:</p><figure class="kf kg kh ki gt kj gh gi paragraph-image"><div role="button" tabindex="0" class="mn mo di mp bf mq"><div class="gh gi ox"><img src="../Images/6debec98928d69620852b4887d5cec2a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*N1bre-cmlYihUdbS.png"/></div></div></figure><p id="2cfa" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">自动缩放将所需容量设置为1至2:</p><figure class="kf kg kh ki gt kj gh gi paragraph-image"><div role="button" tabindex="0" class="mn mo di mp bf mq"><div class="gh gi oy"><img src="../Images/18c989e81ef3ae3c063cd4dce72d1e03.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*SqUnceWH_rgEFAoR.png"/></div></div></figure><p id="04e7" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">我们在目标群体中看到了这一点:</p><figure class="kf kg kh ki gt kj gh gi paragraph-image"><div role="button" tabindex="0" class="mn mo di mp bf mq"><div class="gh gi oz"><img src="../Images/4f70fe52e9c56182a2bbdda98853592d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*FeaUhrQqExg0-KQB.png"/></div></div></figure><p id="c8f2" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">等等，现在我们有两个工作的虚拟机:</p><figure class="kf kg kh ki gt kj gh gi paragraph-image"><div role="button" tabindex="0" class="mn mo di mp bf mq"><div class="gh gi pa"><img src="../Images/f085fc99bc983a5e2676bf9ddb561755.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*Tcul_bj2kjUG880o.png"/></div></div></figure><h2 id="340e" class="mu lp iq bd lq mv mw dn lu mx my dp ly la mz na ma le nb nc mc li nd ne me nf bi translated">该基础设施中的容错能力</h2><p id="b85d" class="pw-post-body-paragraph kr ks iq kt b ku mg jr kw kx mh ju kz la mi lc ld le mj lg lh li mk lk ll lm ij bi translated">容错是系统即使在某些组件出现故障时仍能继续工作的能力。</p><p id="49cc" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">如果负载平衡器无法通过指定端口连接到服务器，它会将该虚拟机标记为不健康。自动缩放服务看到它，并用新机器替换该机器:</p><figure class="kf kg kh ki gt kj gh gi paragraph-image"><div role="button" tabindex="0" class="mn mo di mp bf mq"><div class="gh gi pb"><img src="../Images/05ff8055965349729f330d05ceac8370.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*-E4RDxKmetp28SlQ.png"/></div></div></figure><h2 id="3159" class="mu lp iq bd lq mv mw dn lu mx my dp ly la mz na ma le nb nc mc li nd ne me nf bi translated">DDoS保护</h2><p id="bd75" class="pw-post-body-paragraph kr ks iq kt b ku mg jr kw kx mh ju kz la mi lc ld le mj lg lh li mk lk ll lm ij bi translated">正如AWS文档所说，<a class="ae ln" href="https://docs.aws.amazon.com/waf/latest/developerguide/ddos-standard-summary.html" rel="noopener ugc nofollow" target="_blank">它为所有用户提供AWS Shield标准，不收取额外费用。</a>它保护用户免受网络和传输层最常见的DDoS攻击。但问题是，你看不到它是如何工作的。它在后台运行，你无法确定它什么时候保护你。没有报告。</p><p id="c1c8" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">另外，从官方声明<a class="ae ln" href="https://aws.amazon.com/shield/pricing/" rel="noopener ugc nofollow" target="_blank"> AWS Shield标准在你使用弹性负载均衡、应用负载均衡器、CloudFront和Route 53 </a>时自动启用来看，你不能确定这种保护对你的虚拟机(是EC2服务)是否有效。还有另一项服务，AWS Shield Advanced，<a class="ae ln" href="https://aws.amazon.com/shield/pricing/" rel="noopener ugc nofollow" target="_blank">，它明确保护EC2虚拟机</a>，并将其活动发送到CloudWatch，但这是一项付费服务，每月费用为3000美元。</p><p id="ce10" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">尽管如此，即使我们的虚拟机遭受DDoS攻击并失败，负载平衡器也会将它们标记为不健康，并且自动扩展服务会在没有我们参与的情况下在新的IP地址上重新启动它们。所以我们不能说这个系统免受DDoS攻击，但它会在攻击后自动恢复，所以我们不必手动修复服务器。唯一的问题是玩家可能会因为游戏被打断而心烦意乱。</p><h2 id="d8ac" class="mu lp iq bd lq mv mw dn lu mx my dp ly la mz na ma le nb nc mc li nd ne me nf bi translated">这种基础设施的缺陷</h2><p id="7628" class="pw-post-body-paragraph kr ks iq kt b ku mg jr kw kx mh ju kz la mi lc ld le mj lg lh li mk lk ll lm ij bi translated">当Auto Scaling服务开始减少虚拟机的数量时(因为负载已经减少)，则该服务不关心玩家在即将被删除的机器上是否仍有游戏会话。因此，这会导致他们的会话中断并破坏游戏体验。</p><p id="0e97" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">幸运的是，AWS允许我们暂停和恢复一些自动缩放过程。我们对删除虚拟机的终止过程特别感兴趣。我们所做的是，当自动扩展创建虚拟机时，我们授予该虚拟机权限(通过AWS中的角色)以执行自动扩展服务中的命令:</p><figure class="kf kg kh ki gt kj gh gi paragraph-image"><div role="button" tabindex="0" class="mn mo di mp bf mq"><div class="gh gi pc"><img src="../Images/f84f43c673f9f1f7d1199715e20ec9db.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*Y_4kKebBS-u1-Yas.png"/></div></div></figure><p id="ec15" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">目标组中的每台计算机都会定期检查DynamoDB中的会话列表，如果发现至少有一个会话，它会通过暂停来阻止自动扩展终止进程删除虚拟机，如果发现没有会话，它会允许自动扩展终止进程通过恢复来删除虚拟机:</p><pre class="kf kg kh ki gt of oa og bn oh oi bi"><span id="5fc4" class="oj lp iq oa b be ok ol l om on"># block the Auto Scaling Terminate process from deleting the virtual machines<br/>aws autoscaling suspend-processes --auto-scaling-group-name &lt;scaling-group-name&gt; --scaling-processes Terminate<br/># unblock the Auto Scaling Terminate process from deleting the virtual machines<br/>aws autoscaling resume-processes --auto-scaling-group-name &lt;scaling-group-name&gt; --scaling-processes Terminate</span></pre><p id="555b" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">因此，如果我们至少有一个会话，那么对于自动缩放服务，终止进程将被标记为挂起:</p><figure class="kf kg kh ki gt kj gh gi paragraph-image"><div role="button" tabindex="0" class="mn mo di mp bf mq"><div class="gh gi pd"><img src="../Images/8c94d25c1da11dd50679359324dba255.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*THL05w6UIX683Ksy.png"/></div></div></figure><h2 id="7587" class="mu lp iq bd lq mv mw dn lu mx my dp ly la mz na ma le nb nc mc li nd ne me nf bi translated">它值多少钱</h2><p id="3f82" class="pw-post-body-paragraph kr ks iq kt b ku mg jr kw kx mh ju kz la mi lc ld le mj lg lh li mk lk ll lm ij bi translated">价格会根据玩家的消费和你想要部署这个基础设施的地区数量而变化。就我而言，由于游戏还没有发布，我没有可靠的统计数据，只能粗略计算一下:</p><ul class=""><li id="6056" class="nh ni iq kt b ku kv kx ky la nj le nk li nl lm nm nn no np bi translated">虚拟机EC2 —在所有三个区域的目标组中，至少有一台虚拟机正在运行。一个<code class="fe nx ny nz oa b">t2.micro</code>类型的虚拟机每月花费10美元，AWS每月免费给你一个这样的机器，所以我们总共有20美元(如果没有人玩我们的游戏，实际上，这个数字肯定会更大)</li><li id="bc2a" class="nh ni iq kt b ku nq kx nr la ns le nt li nu lm nm nn no np bi translated">DynamoDB——免费的，AWS在免费层中为dynamo db服务提供了25 GB的存储空间，对于我们的用例来说，这已经足够了</li><li id="7cf4" class="nh ni iq kt b ku nq kx nr la ns le nt li nu lm nm nn no np bi translated">弹性负载平衡器——每GB流量每小时收费，但玩家不会使用这项服务直接连接到游戏会话，因此这项服务不太可能收费</li><li id="3fc1" class="nh ni iq kt b ku nq kx nr la ns le nt li nu lm nm nn no np bi translated">自动缩放—免费</li><li id="4720" class="nh ni iq kt b ku nq kx nr la ns le nt li nu lm nm nn no np bi translated">收集指标的CloudWatch和分配给虚拟机的几个公共IP可能会产生一些额外的小额费用</li></ul><p id="bb95" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">总体而言，具有动态自动扩展功能的基础架构使我们能够实现容错，并大幅削减虚拟机租赁成本。我认为这是独立开发者的理想解决方案。</p><h1 id="06c0" class="lo lp iq bd lq lr ls lt lu lv lw lx ly jw lz jx ma jz mb ka mc kc md kd me mf bi translated">结论</h1><p id="954a" class="pw-post-body-paragraph kr ks iq kt b ku mg jr kw kx mh ju kz la mi lc ld le mj lg lh li mk lk ll lm ij bi translated">在过去的一年半时间里，深入游戏服务器的世界，它们的架构，有什么技巧可以优化它们，以及如何在云中部署它们，已经成为我的一大爱好。我很高兴我能够把游戏的服务器端部分带到这种状态，我希望我的经历也能帮助每个对此感兴趣的人。</p><p id="c20e" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">感谢每一个坚持到最后的人！</p></div></div>    
</body>
</html>