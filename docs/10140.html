<html>
<head>
<title>Sharing States Between SwiftUI Views</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">在SwiftUI视图之间共享状态</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/sharing-states-between-swiftui-views-d00d3f41a23b?source=collection_archive---------2-----------------------#2021-12-03">https://betterprogramming.pub/sharing-states-between-swiftui-views-d00d3f41a23b?source=collection_archive---------2-----------------------#2021-12-03</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="2bfd" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">如何通过SwiftUI视图更新您的应用状态</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/ec77ce6502815d80fdbca97fe58d3f8e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*MLV0oY0unF1NyFXM"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated"><a class="ae ky" href="https://unsplash.com/@freegraphictoday?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">绝对视觉</a>在<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</p></figure><p id="a719" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">可变状态是几个应用程序出现问题的根本原因。它会产生不一致的状态，导致错误的显示信息，或者在更糟糕的情况下，导致崩溃。</p><p id="453b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">当两个不同的组件使用具有不同表示的相同信息时，我们会面临这个问题，如果用户在一个地方更新信息，这些变化不会在另一个地方反映出来。然后，如果用户在应用程序的其他部分导航，他们可能会看到旧数据，或者应用程序可能会由于这种不一致而崩溃。</p><p id="0187" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这个问题如此相关和频繁，以至于整个库和体系结构都被开发来管理它。<a class="ae ky" href="https://github.com/pointfreeco/swift-composable-architecture" rel="noopener ugc nofollow" target="_blank">可组合架构(TCA) </a>是一个可以解决这个问题的库和架构的例子。</p><p id="a475" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">通过仔细的设计和实现，我们可以开发一个应用程序，其中相关的状态可以在多个组件之间共享，而不会有状态不一致的风险，也没有额外的库或复杂的架构。</p><p id="4a6c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们只需要记住两个概念:</p><ol class=""><li id="6aa6" class="lv lw it lb b lc ld lf lg li lx lm ly lq lz lu ma mb mc md bi translated">对于每一条信息，我们都需要一个真实的来源。单个对象必须包含当前的真值，所有其他组件从该对象获取信息。</li><li id="d016" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated">对于每条信息，我们需要一个单独的更新位置。所有的状态突变都发生在一个对象中。如果一个组件需要更新一个状态，它必须使用那个对象。</li></ol><p id="dbda" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在今天的文章中，我们将牢记这些原则，实现一个简单的特性。我们将使用普通的SwiftUI来实现它，用UIKit或使用其他UI模式来翻译代码应该很容易。</p><h1 id="9dd7" class="mj mk it bd ml mm mn mo mp mq mr ms mt jz mu ka mv kc mw kd mx kf my kg mz na bi translated">该应用程序</h1><p id="2ab1" class="pw-post-body-paragraph kz la it lb b lc nb ju le lf nc jx lh li nd lk ll lm ne lo lp lq nf ls lt lu im bi translated">我们将实现的功能类似于Medium clap功能。该应用程序呈现不同的图像，用户可以点击按钮来喜欢它们。用户可以多次喜欢一张图片，就像用户可以多次拍击一篇文章一样。</p><p id="55d9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">其次，用户可以点击图片来导航到细节屏幕。在该屏幕上，图片被缩放，用户可以喜欢该图片。两个屏幕之间的赞数必须始终保持同步。</p><p id="7a4c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">下面的GIF展示了我们想要实现的目标:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi ng"><img src="../Images/0b55898d13b9091eca2d8d3b1d33b537.png" data-original-src="https://miro.medium.com/v2/resize:fit:444/1*k27gZnIpUu39WDiN95v9fg.gif"/></div></figure><h1 id="5365" class="mj mk it bd ml mm mn mo mp mq mr ms mt jz mu ka mv kc mw kd mx kf my kg mz na bi translated">模型</h1><p id="871e" class="pw-post-body-paragraph kz la it lb b lc nb ju le lf nc jx lh li nd lk ll lm ne lo lp lq nf ls lt lu im bi translated">首先，我们需要一个模型来存储我们希望在屏幕上显示的信息。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nh ni l"/></div></figure><p id="0d16" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">一个<code class="fe nj nk nl nm b">Picture</code>的模型非常简单:它只有一个<code class="fe nj nk nl nm b">URL</code>,用于标识我们用来获取图像的图像、一个作者和一些赞。</p><h1 id="cb5a" class="mj mk it bd ml mm mn mo mp mq mr ms mt jz mu ka mv kc mw kd mx kf my kg mz na bi translated">图片列表视图</h1><p id="5c57" class="pw-post-body-paragraph kz la it lb b lc nb ju le lf nc jx lh li nd lk ll lm ne lo lp lq nf ls lt lu im bi translated">然后，我们需要<code class="fe nj nk nl nm b">PictureListView</code>来呈现图片列表。让我们在添加行为之前先实现UI。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nh ni l"/></div></figure><p id="298e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">为了提高可读性，<code class="fe nj nk nl nm b">View</code>被组织在不同的函数中。该组件将一个<code class="fe nj nk nl nm b">Picture</code>数组作为参数。</p><p id="9e74" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在它的<code class="fe nj nk nl nm b">body</code>中，我们准备了一个带有<code class="fe nj nk nl nm b">LazyVGrid</code>的<code class="fe nj nk nl nm b">ScrollView</code>来渲染每行两张图片。然后，我们用一个<code class="fe nj nk nl nm b">ForEach</code>组件在<code class="fe nj nk nl nm b">Picture</code>上循环。<code class="fe nj nk nl nm b">ForEach</code>的内容是一个<code class="fe nj nk nl nm b">imageCard</code>:一个包含<code class="fe nj nk nl nm b">Picture</code>信息及其框架和<code class="fe nj nk nl nm b">NavigationLink</code>的组件。</p><p id="28d9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">清单的其他功能返回我们用来组成视图的元素。我们有链接目的地、<code class="fe nj nk nl nm b">AsyncImage</code>和页脚。注意<code class="fe nj nk nl nm b">likeButton</code>函数:它返回负责增加赞数的按钮。</p><p id="bfc9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这就完成了列表视图的UI。正如你所看到的，我们有一个图片列表，但是<code class="fe nj nk nl nm b">ListView</code>没有检索它们，也没有以任何方式管理它们。它唯一的职责是获取数组并呈现它。</p><p id="67f2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">目前，代码没有构建:Xcode不知道什么是<code class="fe nj nk nl nm b">PictureDetailsView</code>。我们来实施吧。</p><h1 id="b0f5" class="mj mk it bd ml mm mn mo mp mq mr ms mt jz mu ka mv kc mw kd mx kf my kg mz na bi translated">图片详细信息视图</h1><p id="6c47" class="pw-post-body-paragraph kz la it lb b lc nb ju le lf nc jx lh li nd lk ll lm ne lo lp lq nf ls lt lu im bi translated">我们需要的第二个元素是一个<code class="fe nj nk nl nm b">PictureDetailView</code>。让我们实现没有任何行为的UI。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nh ni l"/></div></figure><p id="5211" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这个视图非常类似于<code class="fe nj nk nl nm b">PictureListView</code>的单卡。在细节中，我们没有框架，也没有导航链接，但我们仍然呈现图像和页脚。</p><blockquote class="nn no np"><p id="7348" class="kz la nq lb b lc ld ju le lf lg jx lh nr lj lk ll ns ln lo lp nt lr ls lt lu im bi translated"><strong class="lb iu">注:</strong><code class="fe nj nk nl nm b">PictureListView</code>的一些功能和<code class="fe nj nk nl nm b">PictureDetailsView</code>的相应属性之间的代码非常相似，如果不是完全相同的话。我们应该提取特定SwiftUI组件中的代码，以便在两个组件中重用它。为了简单起见，不要创建太多的片段，我们决定容忍一点点重复。</p></blockquote><h1 id="b1ac" class="mj mk it bd ml mm mn mo mp mq mr ms mt jz mu ka mv kc mw kd mx kf my kg mz na bi translated">将组件组装在一起</h1><p id="9b2b" class="pw-post-body-paragraph kz la it lb b lc nb ju le lf nc jx lh li nd lk ll lm ne lo lp lq nf ls lt lu im bi translated">目前，我们可以从列表中导航到详细信息，但我们还没有将列表添加到应用程序中。让我们通过编辑<code class="fe nj nk nl nm b">App.swift</code>文件来完成。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nh ni l"/></div></figure><p id="b815" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在<code class="fe nj nk nl nm b">MyApp</code>结构中，我们声明了一个静态图片列表(我们使用<a class="ae ky" href="https://picsum.photos/" rel="noopener ugc nofollow" target="_blank"> picsum.photos </a>来获取一些免费图片的URL ),我们在<code class="fe nj nk nl nm b">body</code>中使用它来初始化<code class="fe nj nk nl nm b">PictureListView</code>。</p><p id="e971" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果我们现在运行应用程序，我们有一个工作应用程序，它在屏幕上呈现四幅图像，并让我们从缩略图导航到图片细节，然后返回。</p><h1 id="69db" class="mj mk it bd ml mm mn mo mp mq mr ms mt jz mu ka mv kc mw kd mx kf my kg mz na bi translated">实现行为</h1><p id="0cb8" class="pw-post-body-paragraph kz la it lb b lc nb ju le lf nc jx lh li nd lk ll lm ne lo lp lq nf ls lt lu im bi translated">为了避免状态不一致的问题，我们需要单一的真实来源(SST)和单一的更新位置(SUL)。我们已经有了SST:<code class="fe nj nk nl nm b">MyApp</code>结构中的<code class="fe nj nk nl nm b">pictures</code>数组被传递给各个组件，单个的<code class="fe nj nk nl nm b">View</code>不能更新它们。</p><p id="1c68" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们遗漏了SUL:一个可以修改应用程序状态的单一元素。为此使用相同的<code class="fe nj nk nl nm b">MyApp</code>结构感觉很自然。我们要实现的操作是增加赞的计数器。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nh ni l"/></div></figure><p id="feef" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们可以将这个简单的函数添加到<code class="fe nj nk nl nm b">MyApp.swift</code>文件中。该函数使用一个<code class="fe nj nk nl nm b">URL</code>，作为图像的唯一标识符，并检索指向具有该URL的图片的第一个索引。</p><p id="96cb" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">编译器现在抱怨:<code class="fe nj nk nl nm b">MyApp</code>是一个结构，它是不可变的，尽管我们使用了<code class="fe nj nk nl nm b">var</code>来声明图片数组。我们需要能够改变图片:为了实现这个行为，我们可以使用<code class="fe nj nk nl nm b">@State</code>属性包装器。</p><p id="4c30" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让视图修改状态的最后一步是将<code class="fe nj nk nl nm b">increaseLike(for:)</code>函数传递给所有需要它的组件。我们可以通过以下方式修改<code class="fe nj nk nl nm b">PictureListView</code>和<code class="fe nj nk nl nm b">PictureDetailsView</code>:</p><ol class=""><li id="1704" class="lv lw it lb b lc ld lf lg li lx lm ly lq lz lu ma mb mc md bi translated">添加类型为<code class="fe nj nk nl nm b">(URL) -&gt; Void</code>的属性。</li><li id="ee37" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated">点击按钮时调用闭包。</li></ol><p id="c5f6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe nj nk nl nm b">PictureListView</code>代码如下所示:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nh ni l"/></div></figure><p id="9ff5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在第4行，我们添加了<code class="fe nj nk nl nm b">View</code>从组合中接收的闭包。在第20到22行，我们调用闭包传递图片的<code class="fe nj nk nl nm b">URL</code>。</p><p id="2bcd" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们还将闭包传播到<code class="fe nj nk nl nm b">NavigationLink</code>的<code class="fe nj nk nl nm b">destination</code>，以确保<code class="fe nj nk nl nm b">DetailsView</code>可以使用相同的逻辑增加赞数(第13行)。</p><p id="c1b7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">类似地，<code class="fe nj nk nl nm b">PictureDetailsView</code>的代码如下所示:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nh ni l"/></div></figure><p id="fa35" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">正如我们对<code class="fe nj nk nl nm b">ListView</code>所做的一样，我们在第3行声明闭包，并在第14行使用它。</p><p id="8f35" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">所有的部分都准备好了，我们终于可以组成整个解决方案了:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nh ni l"/></div></figure><p id="eed9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们现在可以构建和运行应用程序，它可以工作了。我们可以增加两个屏幕中的相似计数，并且它们是同步的。</p><h1 id="4455" class="mj mk it bd ml mm mn mo mp mq mr ms mt jz mu ka mv kc mw kd mx kf my kg mz na bi translated">用容器重构</h1><p id="30d9" class="pw-post-body-paragraph kz la it lb b lc nb ju le lf nc jx lh li nd lk ll lm ne lo lp lq nf ls lt lu im bi translated">这个<code class="fe nj nk nl nm b">MyApp</code>结构有很多代码，包含一些关于<code class="fe nj nk nl nm b">pictures</code>逻辑应该如何工作的实现细节。在一个复杂的应用程序中，我们会有多种状态，与非常不同的特性相关。我们不能向主结构添加越来越多的函数。这有可能成为将过多职责集中在一个地方的<code class="fe nj nk nl nm b"><a class="ae ky" href="https://en.wikipedia.org/wiki/God_object" rel="noopener ugc nofollow" target="_blank">God Struct</a></code>。</p><p id="0cd1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">因此，我们可以将其封装在一个单独的对象中，该对象可以位于<strong class="lb iu">域逻辑</strong>模块中。我们可以创建一个<code class="fe nj nk nl nm b">PictureStorage</code>类来处理:</p><ol class=""><li id="875b" class="lv lw it lb b lc ld lf lg li lx lm ly lq lz lu ma mb mc md bi translated">跟踪<code class="fe nj nk nl nm b">Picture</code> s状态(<strong class="lb iu"> SST </strong>)。</li><li id="1b18" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated">定义<code class="fe nj nk nl nm b">Picture</code>s(<strong class="lb iu"/>)上所有可能的操作。</li></ol><p id="5524" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe nj nk nl nm b">PictureStorage</code>的代码如下</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nh ni l"/></div></figure><p id="694b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">该类将图片列表存储在内存中。<code class="fe nj nk nl nm b">set</code>是私有的:除了<code class="fe nj nk nl nm b">PictureStorage</code>之外，任何对象都不能修改图片。</p><p id="559b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">存储在其初始化器中需要一个图片列表，并公开了在数组上工作的<code class="fe nj nk nl nm b">increaseLike(for:)</code>方法，因此更新图片的唯一方法是调用这个方法。</p><p id="034e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们已经实现了作为<strong class="lb iu"> SST </strong>和<strong class="lb iu"> SUL </strong>的对象。我们现在可以在作文中使用它。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nh ni l"/></div></figure><p id="3b42" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们用<code class="fe nj nk nl nm b">pictureStorage</code>替换了<code class="fe nj nk nl nm b">pictures</code>数组，并在<code class="fe nj nk nl nm b">body</code>中使用它来获取图片数组和更新赞的函数。</p><p id="4fa3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">应用程序构建并运行，但它已经停止工作。一切都被渲染，我们可以从缩略图导航到图片的细节。但是，如果我们点击喜欢按钮，它不起作用。</p><p id="fa4a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们打破了SwiftUI自动更新机制的束缚。当状态改变时，<code class="fe nj nk nl nm b">@State</code>属性包装器负责重新创建视图层次结构。现在我们还没有任何类似的行为。</p><p id="c483" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">为了重现这种行为，我们需要在<code class="fe nj nk nl nm b">pictureStorage</code>变量之前添加<code class="fe nj nk nl nm b">@StateObject</code>修饰符。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nh ni l"/></div></figure><blockquote class="nn no np"><p id="c625" class="kz la nq lb b lc ld ju le lf lg jx lh nr lj lk ll ns ln lo lp nt lr ls lt lu im bi translated"><strong class="lb iu">注意:</strong>值类型我们用<code class="fe nj nk nl nm b">@State</code>；我们使用<code class="fe nj nk nl nm b">@StateObject</code>作为引用类型。</p></blockquote><p id="4309" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这个属性包装器要求<code class="fe nj nk nl nm b">PictureStorage</code>符合<code class="fe nj nk nl nm b">ObservableObject</code>。让我们添加协议一致性。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nh ni l"/></div></figure><p id="4089" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">即使有这些变化，应用程序也不会工作。没有将更改传播到视图的机制。我们需要发布<code class="fe nj nk nl nm b">pictures</code>数组，我们可以使用<code class="fe nj nk nl nm b">PictureStorage</code>中的<code class="fe nj nk nl nm b">@Published</code>属性包装器来完成。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nh ni l"/></div></figure><p id="0907" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">增加喜欢功能现在工作正常，它在<code class="fe nj nk nl nm b">PictureStorage</code>类中完全隔离。</p><h1 id="3349" class="mj mk it bd ml mm mn mo mp mq mr ms mt jz mu ka mv kc mw kd mx kf my kg mz na bi translated">结论</h1><p id="fe95" class="pw-post-body-paragraph kz la it lb b lc nb ju le lf nc jx lh li nd lk ll lm ne lo lp lq nf ls lt lu im bi translated">在今天的文章中，我们讨论了大型应用程序的一个主要问题:如何保持不同组件之间的状态同步。我们探讨了可以解决这个问题的两个主要支柱:</p><ol class=""><li id="a2e6" class="lv lw it lb b lc ld lf lg li lx lm ly lq lz lu ma mb mc md bi translated">每条信息都有一个真实的来源。</li><li id="3c03" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated">每条信息有一个单独的更新位置(SUL)。</li></ol><p id="8042" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">带着这些想法，我们实现了一个示例特性来展示如何实现这一点。UI组件必须呈现状态并捕获用户输入。逻辑的执行被委托给可以调用SUL的组合根。</p><p id="15bd" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们在基础版本中实现了期望的行为，然后我们重构了代码，将其隔离在一个适当的组件中。我们发现这个过程破坏了SwiftUI自动更新机制，所以我们通过使用<code class="fe nj nk nl nm b">@StateObject</code>和<code class="fe nj nk nl nm b">@Published</code>属性包装器以及<code class="fe nj nk nl nm b">ObservableObject</code>协议来更新它。</p><p id="935d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在进行重构时，我们没有修改视图代码中的任何一行。当设计正确完成时，我们能够只修改<code class="fe nj nk nl nm b">MyApp</code>结构来以最佳方式组合我们的应用程序。这表明app的架构是健全的，模块划分是正确的，解决方案是灵活的。</p><p id="a61a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这从几个方面改进了代码库:可维护性、可读性，并尽可能保持代码的简单性。</p></div></div>    
</body>
</html>