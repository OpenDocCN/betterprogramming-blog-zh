<html>
<head>
<title>How To Implement Two-Factor Authentication Using Node.js and Vue 3</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何使用Node.js和Vue 3实现双因素认证</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/how-to-implement-two-factor-authentication-using-node-js-and-vue-3-1029745e06fd?source=collection_archive---------0-----------------------#2022-01-19">https://betterprogramming.pub/how-to-implement-two-factor-authentication-using-node-js-and-vue-3-1029745e06fd?source=collection_archive---------0-----------------------#2022-01-19</a></blockquote><div><div class="fc ii ij ik il im"/><div class="in io ip iq ir"><div class=""/><div class=""><h2 id="336e" class="pw-subtitle-paragraph jr it iu bd b js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki dk translated">使用基于时间的一次性密码(TOTP)</h2></div><figure class="kk kl km kn gu ko gi gj paragraph-image"><div role="button" tabindex="0" class="kp kq di kr bf ks"><div class="gi gj kj"><img src="../Images/8eceb05d254c7b81cbcc498a95c9d1ce.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*qK8WXoHqZxLk4fwa"/></div></div><p class="kv kw gk gi gj kx ky bd b be z dk translated">摩根·豪斯尔在<a class="ae kz" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的照片</p></figure><p id="da14" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">上周，我们的产品负责人问我们，在我们的系统中添加双因素身份认证需要什么。我们使用Azure Active Directory，这意味着通过Azure门户配置一个额外的策略。这就是我们启用双因素身份认证所需做的全部工作。</p><p id="6fb7" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">由产品负责人的问题引发，我认为也是时候在我的边项目中添加双因素身份验证了。我想使用添加双因素身份验证的常见方式，即基于时间的一次性密码。</p><p id="7eff" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">本文描述了我如何使用Node.js和Vue.js在我的侧项目中实现双因素身份验证。</p><p id="5b35" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">你可以在<a class="ae kz" href="https://github.com/PatrickKalkman/twofactorauth" rel="noopener ugc nofollow" target="_blank">这个GitHub库</a>里找到后端和前端的完整源代码。</p></div><div class="ab cl lw lx hy ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="in io ip iq ir"><h1 id="f5c3" class="md me iu bd mf mg mh mi mj mk ml mm mn ka mo kb mp kd mq ke mr kg ms kh mt mu bi translated">双因素认证</h1><p id="be1a" class="pw-post-body-paragraph la lb iu lc b ld mv jv lf lg mw jy li lj mx ll lm ln my lp lq lr mz lt lu lv in bi translated">双因素或多因素身份认证(MFA)正在成为IT系统事实上的标准。你可能已经使用了几个MFA账户，比如Google，GitHub，或者Apple。如果没有，您应该启用它！</p><p id="859a" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">多因素身份认证是一个过程，在此过程中，用户必须在登录事件期间提供多种形式的身份证明。这可能是手机代码或指纹扫描。</p><p id="53eb" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">通过要求用户提供额外的标识，您可以提高系统的安全性。攻击者获得或复制这种其他标识变得更加困难。</p><p id="5743" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">双因子和多因子的区别在于双因子总是使用两种形式的标识。多因素身份认证可能涉及两个或三个因素。在本文中，我们将实现双因素身份验证。</p></div><div class="ab cl lw lx hy ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="in io ip iq ir"><h1 id="02c1" class="md me iu bd mf mg mh mi mj mk ml mm mn ka mo kb mp kd mq ke mr kg ms kh mt mu bi translated">基于时间的一次性密码(TOTP)</h1><p id="7460" class="pw-post-body-paragraph la lb iu lc b ld mv jv lf lg mw jy li lj mx ll lm ln my lp lq lr mz lt lu lv in bi translated">基于时间的一次性密码(TOTP)是双因素身份验证的常用方式。它使用基于当前时间生成令牌的算法。最近的一项研究表明，TOTP是对用户最友好的双因素认证技术之一。下图显示了TOTP的过程。</p><figure class="kk kl km kn gu ko gi gj paragraph-image"><div role="button" tabindex="0" class="kp kq di kr bf ks"><div class="gi gj na"><img src="../Images/216ad2e551c88c582d5414160a97a90f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*b8zIH0EfQOsdOEITP2-ahg.png"/></div></div><p class="kv kw gk gi gj kx ky bd b be z dk translated">TOTP之流，作者形象</p></figure><p id="8986" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">它从服务器生成一个32个字符的随机密码开始。前端将这个秘密转换成二维码，并显示在网页上。用户使用Authy或Google Authenticator等认证器应用程序，通过扫描二维码来添加帐户。作为响应，服务器存储用户的秘密。</p><p id="e42c" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">用户登录后，网站会显示一个字段，用户必须在其中输入由Authenticator应用程序生成的令牌。authenticator应用程序使用存储的密码和当前时间来创建令牌。在将其发送到服务器之后，服务器使用保存的秘密和当前时间生成令牌。然后，它验证来自用户的令牌和生成的令牌是否匹配。</p></div><div class="ab cl lw lx hy ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="in io ip iq ir"><h1 id="fabd" class="md me iu bd mf mg mh mi mj mk ml mm mn ka mo kb mp kd mq ke mr kg ms kh mt mu bi translated">我的副业</h1><p id="dcb8" class="pw-post-body-paragraph la lb iu lc b ld mv jv lf lg mw jy li lj mx ll lm ln my lp lq lr mz lt lu lv in bi translated">我这边的项目由Node.js后端和Vue 3前端组成。该项目是闭源的，但是本文的演示应用程序实现了相同的解决方案。</p><h2 id="fc7b" class="nb me iu bd mf nc nd dn mj ne nf dp mn lj ng nh mp ln ni nj mr lr nk nl mt nm bi translated">后端REST API</h2><p id="5c9d" class="pw-post-body-paragraph la lb iu lc b ld mv jv lf lg mw jy li lj mx ll lm ln my lp lq lr mz lt lu lv in bi translated">后端包含一个使用Node.js和Fastify实现的REST API。REST API包含两个控制器，一个用户控制器和一个客户控制器。用户控制器可公开访问，负责注册和验证用户。客户控制器受到保护，并包含一个检索客户列表的操作。</p><h2 id="8133" class="nb me iu bd mf nc nd dn mj ne nf dp mn lj ng nh mp ln ni nj mr lr nk nl mt nm bi translated">前端Vue web应用程序</h2><p id="b9f1" class="pw-post-body-paragraph la lb iu lc b ld mv jv lf lg mw jy li lj mx ll lm ln my lp lq lr mz lt lu lv in bi translated">前端由五个不同的屏幕组成。它使用Vuex状态管理库来全局存储应用程序的数据。基于promise的HTTP客户端Axios用于与后端通信。</p><p id="104d" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">在我们深入研究双因素身份验证的实现之前，让我们先看看我是如何实现第一层身份验证的。</p><h2 id="6223" class="nb me iu bd mf nc nd dn mj ne nf dp mn lj ng nh mp ln ni nj mr lr nk nl mt nm bi translated">使用JWT的标准身份验证</h2><p id="5af9" class="pw-post-body-paragraph la lb iu lc b ld mv jv lf lg mw jy li lj mx ll lm ln my lp lq lr mz lt lu lv in bi translated">我使用电子邮件和密码实现了第一层身份验证。当用户登录并成功通过身份验证后，用户控制器会生成一个JSON web令牌(JWT)。后端将JWT返回给前端。前端应该在每个后续HTTP请求的报头中包含JWT令牌。</p><p id="4fd6" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">我们将用户数据后端存储到一个名为<a class="ae kz" href="http://boutglay.com/locallydb/" rel="noopener ugc nofollow" target="_blank"> LocallyDB </a>的基于文件的JSON数据库中。</p><figure class="kk kl km kn gu ko"><div class="bz fq l di"><div class="nn no l"/></div><p class="kv kw gk gi gj kx ky bd b be z dk translated">认证的第一层</p></figure><p id="2538" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">在使用<a class="ae kz" href="https://www.npmjs.com/package/bcryptjs" rel="noopener ugc nofollow" target="_blank"> bcryptjs </a>存储密码之前，后端会对密码进行哈希处理。在第三行，登录操作从数据库中检索用户。然后在第5行，如果用户存在，它使用<code class="fe np nq nr ns b">bcrypt.compareSync</code>将散列与给定的密码进行比较。</p><p id="c459" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">如果成功，登录操作将通过使用配置的密码对用户对象进行签名来创建JWT。然后，它返回一个包含生成的JWT令牌的新用户对象。</p></div><div class="ab cl lw lx hy ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="in io ip iq ir"><h1 id="1a90" class="md me iu bd mf mg mh mi mj mk ml mm mn ka mo kb mp kd mq ke mr kg ms kh mt mu bi translated">添加双因素身份认证，后端</h1><p id="a6c4" class="pw-post-body-paragraph la lb iu lc b ld mv jv lf lg mw jy li lj mx ll lm ln my lp lq lr mz lt lu lv in bi translated">用户通过身份验证后，他们可以启用双因素身份验证。它由两个独立的步骤组成，每个步骤使用不同的控制器动作来实现。</p><h2 id="99c1" class="nb me iu bd mf nc nd dn mj ne nf dp mn lj ng nh mp ln ni nj mr lr nk nl mt nm bi translated">步骤1，生成密码和QR码</h2><p id="e19a" class="pw-post-body-paragraph la lb iu lc b ld mv jv lf lg mw jy li lj mx ll lm ln my lp lq lr mz lt lu lv in bi translated">第一步做两件事。首先，它创建共享的TOTP秘密，其次，它从该秘密生成一个QR码。后端将QR码和秘密返回给前端。</p><figure class="kk kl km kn gu ko"><div class="bz fq l di"><div class="nn no l"/></div><p class="kv kw gk gi gj kx ky bd b be z dk translated">启用双因素身份认证的第1步</p></figure><p id="c1f3" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">我们使用<a class="ae kz" href="https://www.npmjs.com/package/speakeasy" rel="noopener ugc nofollow" target="_blank"> speakeasy </a>来生成共享秘密，如您在第4行所见。它返回一个具有以下四个属性的秘密对象:<code class="fe np nq nr ns b">secret.ascii</code>、<code class="fe np nq nr ns b">secret.hex</code>、<code class="fe np nq nr ns b">secret.base32</code>和<code class="fe np nq nr ns b">secret.otpauth_url</code>。每个属性包含相同的值，但形式不同。</p><p id="3acd" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">最后一个属性<code class="fe np nq nr ns b">secret.otpauth_url</code>用于生成二维码。二维码库生成第5行的二维码。它使用包含QR码的png图像的base64编码字符串。后端将QR码和秘密对象返回给前端。</p><p id="4e2c" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">见下面的例子。</p><figure class="kk kl km kn gu ko"><div class="bz fq l di"><div class="nn no l"/></div><p class="kv kw gk gi gj kx ky bd b be z dk translated">启用双因素身份验证步骤1后，响应返回到前端。</p></figure><h2 id="006c" class="nb me iu bd mf nc nd dn mj ne nf dp mn lj ng nh mp ln ni nj mr lr nk nl mt nm bi translated">步骤2，验证令牌并启用双因素身份认证</h2><p id="26a3" class="pw-post-body-paragraph la lb iu lc b ld mv jv lf lg mw jy li lj mx ll lm ln my lp lq lr mz lt lu lv in bi translated">也许你会问为什么会有步骤2？第1步不足以启用双因素身份认证吗？你是对的。</p><p id="8f20" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">我们使用步骤2来确保验证者应用程序和后端使用相同的秘密。在第2步中，我们让用户输入authenticator应用程序生成的令牌，并用后端生成的令牌对其进行验证。如果两者相同，我们启用双因素身份验证，并将秘密和用户信息一起存储在数据库中。通过这种方式，我们可以肯定双因素身份认证是有效的。</p><p id="1ea2" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">下面您可以看到步骤2的实现。在第9行，我们使用speakeasy库来验证从authenticator应用程序生成的令牌。我们没有将步骤1中生成的秘密存储在后端。前端提供生成的秘密，正如您在第7行中看到的。</p><figure class="kk kl km kn gu ko"><div class="bz fq l di"><div class="nn no l"/></div><p class="kv kw gk gi gj kx ky bd b be z dk translated">启用双因素身份认证的步骤2</p></figure><h2 id="1447" class="nb me iu bd mf nc nd dn mj ne nf dp mn lj ng nh mp ln ni nj mr lr nk nl mt nm bi translated">使用双因素身份验证登录</h2><p id="fc81" class="pw-post-body-paragraph la lb iu lc b ld mv jv lf lg mw jy li lj mx ll lm ln my lp lq lr mz lt lu lv in bi translated">当用户想要登录并启用双因素身份认证时，用户必须在验证用户名和密码后输入TOTP令牌。前端显示一个输入令牌的字段，并在后端调用验证令牌API方法。</p><p id="cdc7" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">首先，<code class="fe np nq nr ns b">validateToken</code>方法验证JWT令牌并提取电子邮件地址。然后，我们使用这个电子邮件地址从数据库中检索用户。这包括TOTP的秘密。</p><p id="1f50" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">然后，给定的令牌和秘密被提供给<code class="fe np nq nr ns b">speakeasy</code>的<code class="fe np nq nr ns b">verify</code>方法以验证令牌。我们将验证的结果返回给前端。</p><figure class="kk kl km kn gu ko"><div class="bz fq l di"><div class="nn no l"/></div><p class="kv kw gk gi gj kx ky bd b be z dk translated">登录时验证TOTP令牌</p></figure><p id="49ca" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">现在让我们看看如何从前端调用这些步骤。</p></div><div class="ab cl lw lx hy ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="in io ip iq ir"><h1 id="7d33" class="md me iu bd mf mg mh mi mj mk ml mm mn ka mo kb mp kd mq ke mr kg ms kh mt mu bi translated">添加双因素身份认证，前端</h1><p id="9a31" class="pw-post-body-paragraph la lb iu lc b ld mv jv lf lg mw jy li lj mx ll lm ln my lp lq lr mz lt lu lv in bi translated">Vue 3前端由以下五个Vue组件组成。我们将研究每个组件，看看它们是如何实现的。</p><ul class=""><li id="6731" class="nt nu iu lc b ld le lg lh lj nv ln nw lr nx lv ny nz oa ob bi translated">主页</li><li id="da01" class="nt nu iu lc b ld oc lg od lj oe ln of lr og lv ny nz oa ob bi translated">注册</li><li id="373f" class="nt nu iu lc b ld oc lg od lj oe ln of lr og lv ny nz oa ob bi translated">注册</li><li id="7967" class="nt nu iu lc b ld oc lg od lj oe ln of lr og lv ny nz oa ob bi translated">启用双因素身份验证</li><li id="daa4" class="nt nu iu lc b ld oc lg od lj oe ln of lr og lv ny nz oa ob bi translated">显示受保护数据的仪表板</li></ul><h2 id="181c" class="nb me iu bd mf nc nd dn mj ne nf dp mn lj ng nh mp ln ni nj mr lr nk nl mt nm bi translated">主页</h2><p id="3650" class="pw-post-body-paragraph la lb iu lc b ld mv jv lf lg mw jy li lj mx ll lm ln my lp lq lr mz lt lu lv in bi translated">这是应用程序的主屏幕。它显示了一个带有登录按钮的导航栏。屏幕中央的消息包含两个链接，一个用于登录屏幕，另一个用于注册新用户屏幕。</p><figure class="kk kl km kn gu ko gi gj paragraph-image"><div role="button" tabindex="0" class="kp kq di kr bf ks"><div class="gi gj oh"><img src="../Images/e42f660a4568100003b2314057ec2649.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*JLce67aGAD6If9jF6I9HGQ.png"/></div></div><p class="kv kw gk gi gj kx ky bd b be z dk translated">应用程序的主屏幕，图片由作者提供</p></figure><h2 id="96b8" class="nb me iu bd mf nc nd dn mj ne nf dp mn lj ng nh mp ln ni nj mr lr nk nl mt nm bi translated">登录用户</h2><p id="a86e" class="pw-post-body-paragraph la lb iu lc b ld mv jv lf lg mw jy li lj mx ll lm ln my lp lq lr mz lt lu lv in bi translated">在此屏幕上，用户可以登录到网站，然后访问受保护的仪表板。</p><figure class="kk kl km kn gu ko gi gj paragraph-image"><div role="button" tabindex="0" class="kp kq di kr bf ks"><div class="gi gj oi"><img src="../Images/c1f6484380d0bdfc016c0454b59d1262.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*3mP10pBUIQWL9u1_XuftVQ.png"/></div></div><p class="kv kw gk gi gj kx ky bd b be z dk translated">应用程序的登录屏幕，图片由作者提供</p></figure><p id="a48f" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">如果应用程序成功地对用户进行了身份验证，并且用户启用了双因素身份验证，则屏幕会显示一个字段来输入TOTP令牌。见下文。</p><figure class="kk kl km kn gu ko gi gj paragraph-image"><div role="button" tabindex="0" class="kp kq di kr bf ks"><div class="gi gj oj"><img src="../Images/4eee4b5386c9c57a669b17c267facc54.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*JmGHmLZIBcqTkPpnA4oHqQ.png"/></div></div><p class="kv kw gk gi gj kx ky bd b be z dk translated">双因素认证屏幕，图片由作者提供</p></figure><p id="463e" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">登录组件处理标准登录和令牌验证。它包含两个表单，一个用于正常登录，另一个用于输入TOTP令牌。见下文。视图模板显示了依赖于<code class="fe np nq nr ns b">showTwoFactorPanel</code>布尔字段的登录表单或验证令牌表单。</p><figure class="kk kl km kn gu ko"><div class="bz fq l di"><div class="nn no l"/></div></figure><p id="f8e5" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">当按钮被按下时，登录表单执行<code class="fe np nq nr ns b">login</code>方法，验证令牌表单执行<code class="fe np nq nr ns b">validateToken</code>方法。这两种方法都向Vuex存储发送消息。Vuex存储然后调用该方法，并与后端进行通信。下面您会看到validateToken方法，它是<code class="fe np nq nr ns b">LoginUser.vue</code>组件的一部分。</p><p id="29a3" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">您可以在第二行看到，它将<code class="fe np nq nr ns b">validateToken</code>消息发送到Vuex商店。我们将API调用的结果保存在存储中。然后<code class="fe np nq nr ns b">validateToken</code>方法从第7行的存储中读取结果。如果令牌正确，应用程序将导航到仪表板。</p><figure class="kk kl km kn gu ko"><div class="bz fq l di"><div class="nn no l"/></div><p class="kv kw gk gi gj kx ky bd b be z dk translated">LoginUser组件的登录方法</p></figure><p id="7f95" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">如果我们考虑在商店中实现<code class="fe np nq nr ns b">validateToken</code>方法，我们使用Axios来调用后端。使用<code class="fe np nq nr ns b">SET_TWOFACTOR_LOGIN</code>变异将验证令牌API调用提交给存储。</p><figure class="kk kl km kn gu ko"><div class="bz fq l di"><div class="nn no l"/></div><p class="kv kw gk gi gj kx ky bd b be z dk translated">存储区中的validateToken方法</p></figure><h2 id="8d06" class="nb me iu bd mf nc nd dn mj ne nf dp mn lj ng nh mp ln ni nj mr lr nk nl mt nm bi translated">仪表盘</h2><p id="a0d8" class="pw-post-body-paragraph la lb iu lc b ld mv jv lf lg mw jy li lj mx ll lm ln my lp lq lr mz lt lu lv in bi translated">一旦用户通过身份验证，应用程序就会显示仪表板。仪表板是显示客户列表的受保护资源。</p><figure class="kk kl km kn gu ko gi gj paragraph-image"><div role="button" tabindex="0" class="kp kq di kr bf ks"><div class="gi gj ok"><img src="../Images/37a797e6cc646b0aeca2f9822c31737d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*UqV3vHniCDsq9yrmVla5wA.png"/></div></div><p class="kv kw gk gi gj kx ky bd b be z dk translated">仪表板，显示客户列表的受保护资源，作者图片</p></figure><p id="a1ea" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">仪表板组件使用Vuex存储来检索和存储客户。在客户从后端返回后，他们被分配到客户的组件阵列。使用<code class="fe np nq nr ns b">CustomerCard</code>组件呈现每个客户。请参见下面的Vue仪表板组件。</p><figure class="kk kl km kn gu ko"><div class="bz fq l di"><div class="nn no l"/></div><p class="kv kw gk gi gj kx ky bd b be z dk translated">仪表板组件</p></figure><h2 id="84be" class="nb me iu bd mf nc nd dn mj ne nf dp mn lj ng nh mp ln ni nj mr lr nk nl mt nm bi translated">注册用户</h2><p id="2dc3" class="pw-post-body-paragraph la lb iu lc b ld mv jv lf lg mw jy li lj mx ll lm ln my lp lq lr mz lt lu lv in bi translated">在<code class="fe np nq nr ns b">RegisterUser</code>屏幕上，用户可以创建一个新帐户来访问网站上的受保护资源。</p><figure class="kk kl km kn gu ko gi gj paragraph-image"><div role="button" tabindex="0" class="kp kq di kr bf ks"><div class="gi gj oh"><img src="../Images/29fa3f54b16c9df97ecdf971c2cade58.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*_hj3qTNE8ZaSINduK6HFQg.png"/></div></div><p class="kv kw gk gi gj kx ky bd b be z dk translated">注册用户屏幕，图片由作者提供</p></figure><h2 id="87ee" class="nb me iu bd mf nc nd dn mj ne nf dp mn lj ng nh mp ln ni nj mr lr nk nl mt nm bi translated">双因素注册</h2><p id="a8dc" class="pw-post-body-paragraph la lb iu lc b ld mv jv lf lg mw jy li lj mx ll lm ln my lp lq lr mz lt lu lv in bi translated">用户登录后，按下导航栏上的<strong class="lc iv">双因素</strong>按钮，即可启用双因素认证。屏幕上显示了一个二维码，可以通过Authy等认证应用程序扫描。</p><p id="a19a" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">当你按下双因素按钮，前端指示后端生成TOTP秘密。后端将秘密转换成二维码，二维码作为图像发回前端。</p><figure class="kk kl km kn gu ko gi gj paragraph-image"><div role="button" tabindex="0" class="kp kq di kr bf ks"><div class="gi gj oh"><img src="../Images/4e4d52c77525487f3ea255d4d1edd259.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*pMNDxAxqv0ucOqbMsE1zHQ.png"/></div></div><p class="kv kw gk gi gj kx ky bd b be z dk translated">启用双因素身份认证屏幕，图片由作者提供</p></figure><p id="6a0f" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated"><code class="fe np nq nr ns b">TwoFactorRegistration</code>组件包含一个显示二维码的Vue模板。这是第4行的图像字段。图像标签被绑定到组件的qr字段。qr字段由后端返回的png图像字符串填充。</p><figure class="kk kl km kn gu ko"><div class="bz fq l di"><div class="nn no l"/></div><p class="kv kw gk gi gj kx ky bd b be z dk translated">显示QR码的验证令牌模板</p></figure></div><div class="ab cl lw lx hy ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="in io ip iq ir"><h1 id="4f2f" class="md me iu bd mf mg mh mi mj mk ml mm mn ka mo kb mp kd mq ke mr kg ms kh mt mu bi translated">关于实现的说明</h1><p id="f9f2" class="pw-post-body-paragraph la lb iu lc b ld mv jv lf lg mw jy li lj mx ll lm ln my lp lq lr mz lt lu lv in bi translated">虽然本文和演示项目展示了使用基于时间的一次性密码的双因素身份验证的完整实现，但是在将它用于生产应用程序之前，有一些事情需要注意。</p><p id="695b" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">该解决方案将未加密的TOTP秘密存储在与用户凭证相同的位置。这不是一个好的做法。您应该加密TOTP机密，并将密钥保存在不同的服务器上。</p><p id="aafa" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">后端不会验证所有传入的请求参数。在后端使用之前，最好在真实的生产环境中验证所有传入的参数。</p></div><div class="ab cl lw lx hy ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="in io ip iq ir"><h1 id="87a1" class="md me iu bd mf mg mh mi mj mk ml mm mn ka mo kb mp kd mq ke mr kg ms kh mt mu bi translated">结论</h1><p id="0127" class="pw-post-body-paragraph la lb iu lc b ld mv jv lf lg mw jy li lj mx ll lm ln my lp lq lr mz lt lu lv in bi translated">本文描述了使用Node.js服务器和Vue.js客户端的双因素身份验证的实现。该解决方案使用基于时间的一次性密码来创建第二层身份验证。</p><p id="16b5" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">Node.js后端使用Fastify创建一个REST API，使用<code class="fe np nq nr ns b">easyspeak</code>作为执行双因素身份验证的库。前端使用Axios与后端通信。它使用Vuex状态管理库存储应用程序的全局状态。</p><p id="b391" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">我希望这表明实现双因素身份验证是可行的，并且可以很容易地扩展。你需要特别小心，以确保你在一个单独的位置存储TOTP的秘密。如果您没有将机密和用户凭证放在同一个地方，这将会有所帮助。</p><p id="c280" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">你可以在<a class="ae kz" href="https://github.com/PatrickKalkman/twofactorauth" rel="noopener ugc nofollow" target="_blank"> GitHub </a>上找到客户端和服务器的实现。</p><p id="69c6" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">感谢阅读，记住永远不要停止学习！</p></div></div>    
</body>
</html>