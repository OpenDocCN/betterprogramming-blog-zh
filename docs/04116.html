<html>
<head>
<title>Recognize Handwriting Using an Artificial Neural Network</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用人工神经网络识别笔迹</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/handwriting-recognition-using-an-artificial-neural-network-78060d2a7963?source=collection_archive---------13-----------------------#2020-03-24">https://betterprogramming.pub/handwriting-recognition-using-an-artificial-neural-network-78060d2a7963?source=collection_archive---------13-----------------------#2020-03-24</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="d607" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">用Julia编写的神经网络识别数字</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/bfc51b6d594245a079f0b022cf58d6ab.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*JEte9rJOvt6vY9NC7PAPmQ.jpeg"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">Artem Bryzgalov 在<a class="ae ky" href="https://unsplash.com/s/photos/future?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</p></figure><p id="09ff" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">一个典型的神经网络入门教程包括使用<a class="ae ky" href="https://en.wikipedia.org/wiki/MNIST_database" rel="noopener ugc nofollow" target="_blank"> MNIST数据库</a>对手写进行从0到9数字的手写识别。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="ab gu cl lv"><img src="../Images/21dc2505206ce3cf64647f5af2766899.png" data-original-src="https://miro.medium.com/v2/format:webp/1*uhNyKIj4hDYTYOsKdHJpgg.png"/></div></figure><p id="f785" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这涉及到对单个数字的识别。你可以想象这样的东西被用来扫描giros或支票，其中账号和需要转账的金额被写在明确定义的框中。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="ab gu cl lv"><img src="../Images/8959fb5c63122b2402aea69cc9d315eb.png" data-original-src="https://miro.medium.com/v2/1*_3KejDo5htt6mudY8ZCaNg.gif"/></div></figure><p id="76a0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在本教程中，我们将介绍如何使用<a class="ae ky" href="https://julialang.org" rel="noopener ugc nofollow" target="_blank"> Julia </a>编程语言和名为<a class="ae ky" href="https://fluxml.ai" rel="noopener ugc nofollow" target="_blank"> Flux </a>的机器学习库来实现这一点。</p></div><div class="ab cl lw lx hx ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="im in io ip iq"><h1 id="b87e" class="md me it bd mf mg mh mi mj mk ml mm mn jz mo ka mp kc mq kd mr kf ms kg mt mu bi translated">为什么是Flux和Julia？</h1><p id="39e7" class="pw-post-body-paragraph kz la it lb b lc mv ju le lf mw jx lh li mx lk ll lm my lo lp lq mz ls lt lu im bi translated">现在，你为什么想要使用<a class="ae ky" href="https://fluxml.ai" rel="noopener ugc nofollow" target="_blank"> Flux </a>和<a class="ae ky" href="https://julialang.org" rel="noopener ugc nofollow" target="_blank"> Julia </a>而不是更知名的库，如Torch、PyTorch、Keras或TensorFlow 2.0？</p><p id="1f27" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">一个很大的原因是，你可以更快地学习Flux它提供更好的性能，并且它有更多的未来潜力。其中一个原因是Flux做了很多事情，但仍然是一个很小的库——它可以这么小是因为它所做的大部分事情都是由Julia编程语言本身提供的。</p><p id="d00e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">例如，如果你查看Go编程语言的<a class="ae ky" href="https://github.com/gorgonia/gorgonia" rel="noopener ugc nofollow" target="_blank">柳珊瑚</a> ML库，你会发现一些线索。它明确显示了其他机器学习库如何需要建立一个需要执行和区分的表达式图。在流动中，这张图就是朱莉娅本身。Julia与LISP非常相似，因为Julia代码可以很容易地表示为数据结构，可以修改和评估。</p></div><div class="ab cl lw lx hx ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="im in io ip iq"><h1 id="79a1" class="md me it bd mf mg mh mi mj mk ml mm mn jz mo ka mp kc mq kd mr kf ms kg mt mu bi translated">机器学习导论</h1><p id="c723" class="pw-post-body-paragraph kz la it lb b lc mv ju le lf mw jx lh li mx lk ll lm my lo lp lq mz ls lt lu im bi translated">如果你完全是机器学习的新手，你可以跟随这个教程，但并不是所有的东西都有意义。在这种情况下，你可以看看我以前写的一些关于媒体的文章，它们可能解释了你的一些绊脚石:</p><ul class=""><li id="d4f2" class="na nb it lb b lc ld lf lg li nc lm nd lq ne lu nf ng nh ni bi translated"><a class="ae ky" href="https://medium.com/@Jernfrost/the-core-idea-of-linear-algebra-7405863d8c1d" rel="noopener"> <strong class="lb iu">线性代数的核心思想</strong> </a>。线性代数基本上是关于向量和矩阵的，这是你在机器学习中经常用到的东西。</li><li id="e986" class="na nb it lb b lc nj lf nk li nl lm nm lq nn lu nf ng nh ni bi translated"><a class="ae ky" href="https://medium.com/@Jernfrost/working-with-and-emulating-references-in-julia-e02c1cae5826" rel="noopener"> <strong class="lb iu">使用参照</strong> </a>。这可能看起来有点外围，但如果你想了解像Flux这样的ML库，了解Julia中的引用是很重要的。</li><li id="3c08" class="na nb it lb b lc nj lf nk li nl lm nm lq nn lu nf ng nh ni bi translated"><a class="ae ky" href="https://medium.com/@Jernfrost/implementation-of-a-modern-machine-learning-library-3596badf3be" rel="noopener"> <strong class="lb iu">实现通量</strong> </a>。如何实现Flux ML库的初学者指南？</li><li id="a67d" class="na nb it lb b lc nj lf nk li nl lm nm lq nn lu nf ng nh ni bi translated"><a class="ae ky" href="https://medium.com/@Jernfrost/machine-learning-for-dummies-in-julia-6cd4d2e71a46" rel="noopener"> <strong class="lb iu">机器学习简介</strong> </a>。机器学习概论和Flux。通量部分有点过时了。</li></ul></div><div class="ab cl lw lx hx ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="im in io ip iq"><h1 id="55c6" class="md me it bd mf mg mh mi mj mk ml mm mn jz mo ka mp kc mq kd mr kf ms kg mt mu bi translated">简单多层感知器</h1><p id="ec07" class="pw-post-body-paragraph kz la it lb b lc mv ju le lf mw jx lh li mx lk ll lm my lo lp lq mz ls lt lu im bi translated">我们要编程的人工神经网络被称为简单的<a class="ae ky" href="https://en.wikipedia.org/wiki/Multilayer_perceptron" rel="noopener ugc nofollow" target="_blank">多层感知器</a>。这是神经网络(ANN)的基本功能，大多数教科书都会从它开始。</p><p id="a3e4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我先展示整个程序，然后我们可以更详细地讨论不同的部分。</p><pre class="kj kk kl km gt no np nq nr aw ns bi"><span id="5688" class="nt me it np b gy nu nv l nw nx">using Flux, Flux.Data.MNIST, Statistics<br/>using Flux: onehotbatch, onecold, crossentropy, throttle<br/>using Base.Iterators: repeated<br/><br/># Load training data. 28x28 grayscale images of digits<br/>imgs = MNIST.images()<br/><br/># Reorder the layout of the data for the ANN<br/>imagestrip(image::Matrix{&lt;:Gray}) = Float32.(reshape(image, :))<br/>X = hcat(imagestrip.(imgs)...)<br/><br/># Target output. What digit each image represents.<br/>labels = MNIST.labels()<br/>Y = onehotbatch(labels, 0:9)<br/><br/># Defining the model (a neural network)<br/>m = Chain(<br/> Dense(28*28, 32, relu),<br/> Dense(32, 10),<br/> softmax)<br/> <br/>loss(x, y) = crossentropy(m(x), y)<br/>dataset = repeated((X, Y), 200)<br/>opt = ADAM()<br/><br/>evalcb = () -&gt; @show(loss(X, Y))<br/><br/># Perform training on data<br/>Flux.train!(loss, params(m), dataset, opt, cb = throttle(evalcb, 10))</span></pre></div><div class="ab cl lw lx hx ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="im in io ip iq"><h1 id="6ffa" class="md me it bd mf mg mh mi mj mk ml mm mn jz mo ka mp kc mq kd mr kf ms kg mt mu bi translated">浏览输入数据</h1><p id="c3bf" class="pw-post-body-paragraph kz la it lb b lc mv ju le lf mw jx lh li mx lk ll lm my lo lp lq mz ls lt lu im bi translated">准备用于处理的数据通常是数据科学中最大的工作之一。通常，数据没有按照您需要输入到算法中的方式进行组织或格式化。</p><p id="5efa" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们首先将MNIST数据集加载为28×28像素的60，000幅灰度图像:</p><pre class="kj kk kl km gt no np nq nr aw ns bi"><span id="fa8d" class="nt me it np b gy nu nv l nw nx">imgs = MNIST.images()</span></pre><p id="f2d4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在，如果你的任务是处理这样的数据，你可能不知道你会得到什么。例如，我怎么知道这些数据是什么样的？我本可以谷歌一下，但我只是让朱莉娅来检查一下:</p><pre class="kj kk kl km gt no np nq nr aw ns bi"><span id="0904" class="nt me it np b gy nu nv l nw nx">julia&gt; size(imgs)<br/>(60000,)</span></pre><p id="ca7d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这告诉我<code class="fe ny nz oa np b">imgs</code>是一个包含60，000个元素的1D数组。但是这些元素是什么呢？：</p><pre class="kj kk kl km gt no np nq nr aw ns bi"><span id="bcd8" class="nt me it np b gy nu nv l nw nx">julia&gt; eltype(imgs)<br/>Array{Gray{FixedPointNumbers.Normed{UInt8,8}},2}</span></pre><p id="ef9a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这可能对您来说可读性不强，但我可以用一种简化的方式向您展示这是什么:</p><pre class="kj kk kl km gt no np nq nr aw ns bi"><span id="140b" class="nt me it np b gy nu nv l nw nx">julia&gt; eltype(imgs) &lt;: Matrix{T} where T &lt;: Gray<br/>true</span></pre><p id="7c18" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这告诉我们<code class="fe ny nz oa np b">imgs</code>中的每个元素都是某种值的矩阵。这些值属于某种类型<code class="fe ny nz oa np b">T</code>，它是类型<code class="fe ny nz oa np b">Gray</code>的一个子类型。<code class="fe ny nz oa np b">Gray</code>是什么类型？</p><p id="807d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们可以在Julia在线文档中查找:</p><pre class="kj kk kl km gt no np nq nr aw ns bi"><span id="d40a" class="nt me it np b gy nu nv l nw nx">help?&gt; Gray<br/>  Gray is a grayscale object. You can extract its value with gray(c).</span></pre><p id="ba16" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">自然，我们想知道这些灰度值矩阵的维数:</p><pre class="kj kk kl km gt no np nq nr aw ns bi"><span id="5067" class="nt me it np b gy nu nv l nw nx">julia&gt; size(imgs[1])<br/>(28, 28)<br/><br/>julia&gt; size(imgs[2])<br/>(28, 28)</span></pre><p id="eddf" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这告诉我们它们有28x28像素大。我们可以通过简单地绘制其中一些来进一步验证。Julia <code class="fe ny nz oa np b">Plots</code>库可以让你绘制函数和图像。</p><pre class="kj kk kl km gt no np nq nr aw ns bi"><span id="b185" class="nt me it np b gy nu nv l nw nx">julia&gt; using Plots<br/>julia&gt; plot(imgs[2])</span></pre><p id="5751" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这给了我下面的图像，它看起来很像一个数字:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi ob"><img src="../Images/8f84f82f144ac678911e5dcddcb3556f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1200/format:webp/1*YpijSnfbzpF2118eYUeNCg.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">一个手写的“五”</p></figure><p id="1669" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">但是，您可能会发现了解更多数据的样子会更有用。我们可以很容易地绘制几幅图像:</p><pre class="kj kk kl km gt no np nq nr aw ns bi"><span id="dc60" class="nt me it np b gy nu nv l nw nx">imgplots = plot.(imgs[1:9])<br/>plot(imgplots...)</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi ob"><img src="../Images/975e08c8b08a0fc2444fd5d32b10d5c2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1200/format:webp/1*d2x45jnq88mc_5s9l_Fq-A.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">训练数据中的前九个手写数字</p></figure><p id="4849" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在我们对数据有了一个大概的了解。</p></div><div class="ab cl lw lx hx ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="im in io ip iq"><h1 id="2697" class="md me it bd mf mg mh mi mj mk ml mm mn jz mo ka mp kc mq kd mr kf ms kg mt mu bi translated">准备输入数据</h1><p id="1f25" class="pw-post-body-paragraph kz la it lb b lc mv ju le lf mw jx lh li mx lk ll lm my lo lp lq mz ls lt lu im bi translated">但是，我们不能像这样将数据输入到我们的神经网络(ANN)中。每个输入必须是列向量，而不是矩阵。</p><p id="6ba9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这是因为神经网络期望矩阵作为输入，其中矩阵中的每一列都是输入。ANN看到的3×10矩阵对应于10个不同的输入，其中每个输入包括三个不同的值，或者更具体地说，包括三个不同的特征。因此，我们将28x28灰度图像转换成像素长的细带或像素条。</p><p id="2d65" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">其次，我们的神经网络将不知道什么是灰度值。它对浮点数据进行操作。因此，我们必须转换数据的维度和元素类型。</p><p id="71bb" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">阵列中的列数和行数称为其形状。许多人谈到张量，因为虽然不完全准确，但它是一个涵盖标量、向量、矩阵、立方体或任何秩的数组(基本上是数组的所有维度)的概念。</p><p id="d149" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在Julia中，我们可以使用<code class="fe ny nz oa np b">reshape</code>函数来改变数组的形状。这里有一些你如何使用它的例子。</p><p id="d258" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这创建了一个包含四个元素的列向量<code class="fe ny nz oa np b">A</code>:</p><pre class="kj kk kl km gt no np nq nr aw ns bi"><span id="b1ea" class="nt me it np b gy nu nv l nw nx">julia&gt; A = collect(1:4)<br/>4-element Array{Int64,1}:<br/> 1<br/> 2<br/> 3<br/> 4</span></pre><p id="3980" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">用<code class="fe ny nz oa np b">reshape</code>我们把它变成一个二乘二的矩阵，<code class="fe ny nz oa np b">B</code>:</p><pre class="kj kk kl km gt no np nq nr aw ns bi"><span id="9f61" class="nt me it np b gy nu nv l nw nx">julia&gt; B = reshape(A, (2, 2))<br/>2×2 Array{Int64,2}:<br/> 1  3<br/> 2  4</span></pre><p id="0fdb" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">矩阵可以再次变成列向量:</p><pre class="kj kk kl km gt no np nq nr aw ns bi"><span id="480a" class="nt me it np b gy nu nv l nw nx">julia&gt; reshape(B, 4)<br/>4-element Array{Int64,1}:<br/> 1<br/> 2<br/> 3<br/> 4</span></pre><p id="a7e6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">准确地找出一个列向量的元素长度通常是不切实际的。你可以让Julia计算出合适的长度，只要写下<code class="fe ny nz oa np b">:</code>而不是长度。</p><pre class="kj kk kl km gt no np nq nr aw ns bi"><span id="2d13" class="nt me it np b gy nu nv l nw nx">julia&gt; reshape(B, :)<br/>4-element Array{Int64,1}:<br/> 1<br/> 2<br/> 3<br/> 4</span></pre><p id="2f4c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">有了这些信息，应该更容易看到我的<code class="fe ny nz oa np b">imagestrip</code>函数实际上做了什么。它将28x28灰度值矩阵转换为784个32位浮点值的列向量。</p><pre class="kj kk kl km gt no np nq nr aw ns bi"><span id="a46d" class="nt me it np b gy nu nv l nw nx">imagestrip(image::Matrix{&lt;:Gray}) = Float32.(reshape(image, :))</span></pre><p id="108f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe ny nz oa np b">.</code>符号用于将函数应用于数组的每个元素。因此<code class="fe ny nz oa np b">Float32.(xs)</code>与<code class="fe ny nz oa np b">map(Float32, xs)</code>相同。</p><p id="e836" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">接下来，我们将<code class="fe ny nz oa np b">imagestrip</code>函数应用于60 000幅灰度图像中的每一幅，从而为我们的模型生成784x60000个输入矩阵<code class="fe ny nz oa np b">X</code>。</p><pre class="kj kk kl km gt no np nq nr aw ns bi"><span id="f4b0" class="nt me it np b gy nu nv l nw nx">X = hcat(imagestrip.(imgs)...)</span></pre><p id="63ec" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这是如何工作的？正如您所想象的，<code class="fe ny nz oa np b">imagestrip.(imgs)</code>将图像转换成单个输入值的数组，就像这个<code class="fe ny nz oa np b">[X₁, X₂, X₃, ..., Xₙ]</code>，其中<code class="fe ny nz oa np b">n</code>是60，000，每个<code class="fe ny nz oa np b">Xᵢ</code>是784个浮点值。</p><p id="f96f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">使用splat操作符<code class="fe ny nz oa np b">...</code>,我们将它转化为所有这些列向量的水平连接，以产生模型输入。</p><pre class="kj kk kl km gt no np nq nr aw ns bi"><span id="3480" class="nt me it np b gy nu nv l nw nx">X = hcat(X₁, X₂, X₃, ..., Xₙ)</span></pre><p id="c0ce" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果您想验证尺寸，只需运行<code class="fe ny nz oa np b">size(X)</code>。接下来，我们加载标签。</p><pre class="kj kk kl km gt no np nq nr aw ns bi"><span id="9e19" class="nt me it np b gy nu nv l nw nx">labels = MNIST.labels()</span></pre><p id="2c6a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe ny nz oa np b">Label</code>就是我们所说的监督学习中观察的答案部分。在这种情况下，标签是从<code class="fe ny nz oa np b">0</code>到<code class="fe ny nz oa np b">9</code>的数字。手绘数字的每个图像应该被分类为十个不同数字中的一个。举例来说，如果iris数据集涵盖了不同花卉品种的花瓣长度和花瓣宽度，那么该品种的名称就是标签。</p><p id="c57b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe ny nz oa np b">Xᵢ</code>，在这种情况下，代表了我们所有的一个特征向量。用机器学习的术语来说，每个像素灰度值都是一个特征。</p><p id="85c5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">你可以将标签与我们绘制的图像进行比较。</p><pre class="kj kk kl km gt no np nq nr aw ns bi"><span id="71cc" class="nt me it np b gy nu nv l nw nx">imgplots = plot.(imgs[1:9])<br/>plot(imgplots...)<br/>labels[1:9]</span></pre></div><div class="ab cl lw lx hx ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="im in io ip iq"><h1 id="5b30" class="md me it bd mf mg mh mi mj mk ml mm mn jz mo ka mp kc mq kd mr kf ms kg mt mu bi translated">一键编码</h1><p id="302c" class="pw-post-body-paragraph kz la it lb b lc mv ju le lf mw jx lh li mx lk ll lm my lo lp lq mz ls lt lu im bi translated">有60，000个标签，每个图像一个。但是，一个神经网络不能直接吐槽标签。想象一下，你试图对猫和狗的图像进行分类——网络不能给出字符串<code class="fe ny nz oa np b">"dog"</code>或<code class="fe ny nz oa np b">"cat"</code>,因为它使用浮点值。</p><p id="be2c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果标签是一个不一定有帮助的数字。例如，如果输出是一系列邮政编码，那么将邮政编码3000视为邮政编码1500的两倍是没有意义的。同样，当使用神经网络从图像中预测数字时，4是2的两倍也不重要。数字也可能是字母，因此它们的值并不重要。</p><p id="2ce9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们在机器学习中处理这个问题的方式是，我们使用所谓的<a class="ae ky" href="https://en.wikipedia.org/wiki/One-hot" rel="noopener ugc nofollow" target="_blank">一个热编码</a>。这意味着，如果我们有标签<code class="fe ny nz oa np b">A</code>、<code class="fe ny nz oa np b">B</code>和<code class="fe ny nz oa np b">C</code>，并且我们想用一键编码来表示它们，那么<code class="fe ny nz oa np b">A</code>就是<code class="fe ny nz oa np b">[1, 0, 0]</code>、<code class="fe ny nz oa np b">B</code>就是<code class="fe ny nz oa np b">[0, 1, 0]</code>并且<code class="fe ny nz oa np b">C</code>就是<code class="fe ny nz oa np b">[0, 0, 1]</code>。</p><p id="beed" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这看起来很浪费，但是在内部，Julia one-hot数组只是跟踪元素的索引。它不会保存所有的零。</p><p id="36be" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">以下是这种编码方式的一些应用示例:</p><pre class="kj kk kl km gt no np nq nr aw ns bi"><span id="bde9" class="nt me it np b gy nu nv l nw nx">julia&gt; Flux.onehot('B', ['A', 'B', 'C'])<br/>3-element Flux.OneHotVector:<br/>0<br/>1<br/>0<br/><br/>julia&gt; Flux.onehot("foo", ["foo", "bar", "baz"])<br/>3-element Flux.OneHotVector:<br/>1<br/>0<br/>0</span></pre><p id="5d63" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">然而，我们不打算使用<code class="fe ny nz oa np b">onehot</code>函数，因为我们正在创建一批独热编码标签。我们将把所有60，000张图片作为一批进行处理。</p><p id="c0cb" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">机器学习批处理是指在我们的模型(神经网络)的权重或参数更新之前必须完成的最少量的工作。</p><pre class="kj kk kl km gt no np nq nr aw ns bi"><span id="ba27" class="nt me it np b gy nu nv l nw nx">Y = onehotbatch(labels, 0:9)</span></pre><p id="6e25" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这将创建目标输出。在理想的情况下<code class="fe ny nz oa np b">model(X) == Y</code>，但是当然，在现实中，即使经过模型的大量训练，也会出现一些偏差。</p><p id="1329" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在我们已经讨论完了数据准备。让我们从人工神经网络构建我们的模型。</p></div><div class="ab cl lw lx hx ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="im in io ip iq"><h1 id="9887" class="md me it bd mf mg mh mi mj mk ml mm mn jz mo ka mp kc mq kd mr kf ms kg mt mu bi translated">构建神经网络模型</h1><p id="24e2" class="pw-post-body-paragraph kz la it lb b lc mv ju le lf mw jx lh li mx lk ll lm my lo lp lq mz ls lt lu im bi translated">模型就像模型船一样，是真实世界的简化表示。正如我们可以建立简化的物理模型一样，我们也可以用数学或代码创建物理世界的模型。存在许多这样的数学模型。</p><p id="871a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">例如，统计模型可以使用统计数据来模拟一天中人们到达商店的方式。一般来说，人们会以一种遵循特定概率分布的方式到达。</p><p id="cc79" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在我们的例子中，我们试图使用神经网络来模拟现实世界中的一些东西。当然，这只是真实世界的近似值。</p><p id="3e21" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在构建神经网络时，我们有许多可以利用的部分。网络由多层连接而成。每一层通常具有激活功能。</p><p id="0d2f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">构建神经网络的部分挑战是选择正确的层和激活函数，并决定每层应该有多少个节点。</p><p id="4769" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们的模型非常简单，定义为:</p><pre class="kj kk kl km gt no np nq nr aw ns bi"><span id="4fb0" class="nt me it np b gy nu nv l nw nx">m = Chain(<br/>  Dense(28^2, 32, relu),<br/>  Dense(32, 10),<br/>  softmax)</span></pre><p id="f9a4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这是一个由三层组成的神经网络。<code class="fe ny nz oa np b">Chain</code>用于将单个层链接在一起。第一层<code class="fe ny nz oa np b">Dense(28^2, 32, relu)</code>有784 (28x28)个输入节点，对应每幅图像的像素数。</p><p id="b9fe" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">它使用整流线性单位(ReLU)功能作为激活功能。在经典的神经网络文献中，通常会向您介绍<code class="fe ny nz oa np b">sigmoid</code>函数或<code class="fe ny nz oa np b">tanh</code>。是这个街区的新成员，很多人都喜欢他。它在大多数情况下都工作得很好，包括图像的分类，这就是我们正在做的。</p><p id="53ed" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">下一层是我们的隐藏层，它有32个输入。它需要32个输入，因为前一层有32个输出。这就是我所遵循的示例代码所使用的。我不认为你想要的隐藏节点的数量有明显的正确或错误的选择。</p><p id="4bf1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">输出的数量更明显，因为我们希望每个数字有一个输出。这就是一次性编码发挥作用的地方。</p></div><div class="ab cl lw lx hx ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="im in io ip iq"><h1 id="b172" class="md me it bd mf mg mh mi mj mk ml mm mn jz mo ka mp kc mq kd mr kf ms kg mt mu bi translated">Softmax函数</h1><p id="ff48" class="pw-post-body-paragraph kz la it lb b lc mv ju le lf mw jx lh li mx lk ll lm my lo lp lq mz ls lt lu im bi translated">如果可以称之为最后一层，那就是<code class="fe ny nz oa np b">softmax</code>函数。它将一个矩阵作为输入，并沿每一列进行归一化。矩阵是前一层的输出。</p><p id="1df7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">标准化将60，000列中的每一列都变成概率分布。那到底是什么意思？</p><p id="9c92" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">概率以0到1之间的值给出。零表示事件永远不会发生。一个意味着它绝对肯定会发生。</p><p id="1282" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">像最小-最大归一化一样，<code class="fe ny nz oa np b">softmax</code>将所有输入归一化为0到1之间的值。然而，与min-max不同，它将确保所有这些值的总和为1。这需要一些例子来阐明。</p><p id="0b17" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">假设我从1到10创建了10个随机值。我们可以输入任意范围和任意数量的值。</p><pre class="kj kk kl km gt no np nq nr aw ns bi"><span id="ddd2" class="nt me it np b gy nu nv l nw nx">julia&gt; ys = rand(1:10, 10)<br/>10-element Array{Int64,1}:<br/>  9<br/>  6<br/> 10<br/>  5<br/> 10<br/>  2<br/>  6<br/>  6<br/>  7<br/>  9</span></pre><p id="25cc" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在让我们使用不同的规范化函数来规范化这个数组。我们将使用来自<code class="fe ny nz oa np b">LinearAlgebra</code>模块的<code class="fe ny nz oa np b">normalize</code>,因为它与Julia捆绑在一起。</p><p id="25a4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">不过首先，<code class="fe ny nz oa np b">softmax</code>:</p><pre class="kj kk kl km gt no np nq nr aw ns bi"><span id="1d1a" class="nt me it np b gy nu nv l nw nx">julia&gt; softmax(ys)<br/>10-element Array{Float64,1}:<br/> 0.12919082661651196   <br/> 0.006432032517257137  <br/> 0.3511770763952676    <br/> 0.002366212528045101  <br/> 0.3511770763952676    <br/> 0.00011780678490667763<br/> 0.006432032517257137  <br/> 0.006432032517257137  <br/> 0.017484077111717768  <br/> 0.12919082661651196</span></pre><p id="e316" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如你所见，所有值都在0和1之间。但是看看如果我们把它们加起来会发生什么:</p><pre class="kj kk kl km gt no np nq nr aw ns bi"><span id="9fae" class="nt me it np b gy nu nv l nw nx">julia&gt; sum(softmax(ys))<br/>0.9999999999999999</span></pre><p id="a930" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">它们基本上变成了一个。现在对比一下<code class="fe ny nz oa np b">normalize</code>所做的:</p><pre class="kj kk kl km gt no np nq nr aw ns bi"><span id="4130" class="nt me it np b gy nu nv l nw nx">julia&gt; using LinearAlgebra<br/><br/>julia&gt; normalize(ys)<br/>10-element Array{Float64,1}:<br/>0.38446094597254243<br/>0.25630729731502827<br/>0.4271788288583805 <br/>0.21358941442919024<br/>0.4271788288583805 <br/>0.0854357657716761 <br/>0.25630729731502827<br/>0.25630729731502827<br/>0.2990251802008663 <br/>0.38446094597254243<br/><br/>julia&gt; sum(normalize(ys))<br/>2.9902518020086633<br/><br/>julia&gt; norm(normalize(ys))<br/>1.0<br/><br/>julia&gt; norm(softmax(ys))<br/>0.52959100847191</span></pre><p id="a44f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果你对用<code class="fe ny nz oa np b">normalize</code>标准化的值求和，它们只是得到一些随机值。然而，如果我们将结果输入到<code class="fe ny nz oa np b">norm</code>中，我们得到的<em class="oc">正好是</em> 1.0。</p><p id="187a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">不同之处在于<code class="fe ny nz oa np b">normalize</code>归一化了向量中的值，因此它们可以表示一个单位向量。长度正好为1的向量。<code class="fe ny nz oa np b">norm</code>给出矢量的大小。</p><p id="cbe9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">相比之下,<code class="fe ny nz oa np b">softmax</code>不把这些值当作一个向量，而是当作一个概率分布。每个元素代表输入图像是该数字的概率。</p><p id="dd2c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">假设我们有图像<code class="fe ny nz oa np b">A</code>、<code class="fe ny nz oa np b">B</code>和<code class="fe ny nz oa np b">C</code>作为输入。如果你从<code class="fe ny nz oa np b">softmax</code>得到一个输出，也就是<code class="fe ny nz oa np b">[0.1, 0.7, 0.2]</code>，那么有10%的可能性输入图像是一幅<code class="fe ny nz oa np b">A</code>的图画。有70%的可能性是一张<code class="fe ny nz oa np b">B</code>的图，最后有20%的可能性是一张<code class="fe ny nz oa np b">C</code>的图。</p><p id="bab8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这就是为什么我们要把<code class="fe ny nz oa np b">softmax</code>作为最后一层。我们不能绝对肯定地知道神经网络的输入图像是什么。然而，我们可以给出一个概率分布，它表明哪些数字更有可能。</p></div><div class="ab cl lw lx hx ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="im in io ip iq"><h1 id="373c" class="md me it bd mf mg mh mi mj mk ml mm mn jz mo ka mp kc mq kd mr kf ms kg mt mu bi translated">定义损失函数</h1><p id="0010" class="pw-post-body-paragraph kz la it lb b lc mv ju le lf mw jx lh li mx lk ll lm my lo lp lq mz ls lt lu im bi translated">当训练我们的神经网络(模型)以给出准确的预测时，我们需要定义我们的人工神经网络(ANN)做得有多好。</p><p id="6075" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">为此，我们使用所谓的损失函数。它有很多名字。20年前我学习神经网络时，我们习惯称之为误差函数。有人称之为成本函数。</p><p id="dba3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">然而，底线是这是一种表达我们的预测与现实相比有多正确的方式。</p><pre class="kj kk kl km gt no np nq nr aw ns bi"><span id="0998" class="nt me it np b gy nu nv l nw nx">loss(x, y) = crossentropy(m(x), y)</span></pre><p id="0cec" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">训练一个神经网络实际上是最小化这个函数的输出，所以这是一个优化问题。训练是反复调整模型中的参数(权重)的过程，直到<code class="fe ny nz oa np b">loss</code>函数的输出变低，或者，换句话说，<em class="oc">，直到我们预测中的误差变得非常低</em>。</p><p id="7b5b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">均方差函数(MSE)是计算预测误差的经典方法。这意味着取差值的平方。然而，<code class="fe ny nz oa np b">MSE</code>更适合线性回归(用一条或多条线拟合一些观察值)。</p><p id="5e7d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在这种情况下，我们使用<code class="fe ny nz oa np b">crossentropy</code>函数来代替。当您的最后一个图层是<code class="fe ny nz oa np b">softmax</code>并且您正在进行分类而不是线性回归时，这是推荐的选择。</p></div><div class="ab cl lw lx hx ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="im in io ip iq"><h1 id="071e" class="md me it bd mf mg mh mi mj mk ml mm mn jz mo ka mp kc mq kd mr kf ms kg mt mu bi translated">指定纪元</h1><p id="ba37" class="pw-post-body-paragraph kz la it lb b lc mv ju le lf mw jx lh li mx lk ll lm my lo lp lq mz ls lt lu im bi translated">在机器学习术语中，历元是训练算法的一次完整迭代。或者，换句话说:一个历元处理一个批次并更新权重</p><p id="ee6a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">因此，如果我们用10个时期运行训练，那么我们的模型的参数/权重将被更新/调整10次。</p><p id="df54" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">为了获得200个历元，我们使用<code class="fe ny nz oa np b">repeat</code>将我们的批次重复200次。它实际上并没有将我们的数据复制200次。它只是用迭代器制造了一个假象。</p><pre class="kj kk kl km gt no np nq nr aw ns bi"><span id="b141" class="nt me it np b gy nu nv l nw nx">dataset = repeated((X, Y), 200)</span></pre><p id="dbd3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这在<code class="fe ny nz oa np b">dataset</code>中给了我们一个类似这样的数组:</p><pre class="kj kk kl km gt no np nq nr aw ns bi"><span id="f8dc" class="nt me it np b gy nu nv l nw nx">dataset = [(X1, Y1), (X2, Y2), ..., (X200, Y200)]</span></pre></div><div class="ab cl lw lx hx ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="im in io ip iq"><h1 id="b38d" class="md me it bd mf mg mh mi mj mk ml mm mn jz mo ka mp kc mq kd mr kf ms kg mt mu bi translated">【计算机】优化程序</h1><p id="401f" class="pw-post-body-paragraph kz la it lb b lc mv ju le lf mw jx lh li mx lk ll lm my lo lp lq mz ls lt lu im bi translated">训练神经网络的最常见和最著名的策略是梯度下降，它是由Julia中的<code class="fe ny nz oa np b">Descent</code>类型提供的。</p><p id="ebaf" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">然而，在我们的例子中，我们正在处理相当多的带有相当多噪音的数据，建议使用<code class="fe ny nz oa np b">ADAM</code>优化器。这就是所谓的随机优化。</p><pre class="kj kk kl km gt no np nq nr aw ns bi"><span id="4d21" class="nt me it np b gy nu nv l nw nx">opt = ADAM()</span></pre></div><div class="ab cl lw lx hx ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="im in io ip iq"><h1 id="2f2c" class="md me it bd mf mg mh mi mj mk ml mm mn jz mo ka mp kc mq kd mr kf ms kg mt mu bi translated">进行培训</h1><p id="2ebd" class="pw-post-body-paragraph kz la it lb b lc mv ju le lf mw jx lh li mx lk ll lm my lo lp lq mz ls lt lu im bi translated">我们终于准备好进行训练了。但是我们想在训练的时候得到一些反馈，因为训练有点慢。我们定义了一个回调函数，它在每次迭代(epoch)时打印出<code class="fe ny nz oa np b">loss</code>函数的值，从而显示错误。我们希望在每次迭代中看到误差下降。</p><pre class="kj kk kl km gt no np nq nr aw ns bi"><span id="64a8" class="nt me it np b gy nu nv l nw nx">evalcb = () -&gt; @show(loss(X, Y))</span></pre><p id="ce4a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">能够观察错误发展的一个有用之处是，您可以看到是否出现振荡。摆弄神经网络这在我身上发生了很多。我的人工神经网络向最低值移动得太快，出现了超调。这导致它向相反的方向移动，但是速度太快——向相反的方向超调。振荡变得更加剧烈，直到误差变得无穷大。</p><p id="eed3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这是一个转换优化算法或降低学习速度的暗示。</p><p id="ea48" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">不管怎样，这就是你训练的方式。请注意，回调是可选的:</p><pre class="kj kk kl km gt no np nq nr aw ns bi"><span id="d101" class="nt me it np b gy nu nv l nw nx">Flux.train!(loss, params(m), dataset, opt, cb = throttle(evalcb, 10))</span></pre></div><div class="ab cl lw lx hx ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="im in io ip iq"><h1 id="c65d" class="md me it bd mf mg mh mi mj mk ml mm mn jz mo ka mp kc mq kd mr kf ms kg mt mu bi translated">评估模型预测准确性</h1><p id="944e" class="pw-post-body-paragraph kz la it lb b lc mv ju le lf mw jx lh li mx lk ll lm my lo lp lq mz ls lt lu im bi translated">训练之后，我们可以测试我们的模型在预测方面有多好。</p><p id="77c4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们为此定义了一个函数:</p><pre class="kj kk kl km gt no np nq nr aw ns bi"><span id="2f6a" class="nt me it np b gy nu nv l nw nx">accuracy(x, y) = mean(onecold((m(x))) .== onecold(y))</span></pre><p id="8cce" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">然后我们用输入和目标来调用它:</p><pre class="kj kk kl km gt no np nq nr aw ns bi"><span id="74fd" class="nt me it np b gy nu nv l nw nx">@show accuracy(X, Y)</span></pre><p id="f073" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">然而，这需要一些解释。<code class="fe ny nz oa np b">onecold</code>到底是什么？某种程度上和<code class="fe ny nz oa np b">onehot</code>正好相反。</p><p id="7490" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">请记住，我们的输出<code class="fe ny nz oa np b">m(X)</code>都是概率分布，我们的目标<code class="fe ny nz oa np b">Y</code>都是热点向量。</p><p id="81c3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">他们不能直接比较。首先，我们必须做出明确的选择。这就是<code class="fe ny nz oa np b">onecold</code>所做的。给定一个概率分布，它挑选最可能的候选者:</p><pre class="kj kk kl km gt no np nq nr aw ns bi"><span id="13ee" class="nt me it np b gy nu nv l nw nx">julia&gt; onecold([0.1, 0.7, 0.2])<br/>2<br/><br/>julia&gt; onecold([0.9, 0.05, 0.05])<br/>1</span></pre><p id="651c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">因此用<code class="fe ny nz oa np b">onecold(m(X))</code>我们得到预测的标签。这可以与实际标签进行比较<code class="fe ny nz oa np b">onecold(y)</code>。</p></div><div class="ab cl lw lx hx ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="im in io ip iq"><h1 id="99b0" class="md me it bd mf mg mh mi mj mk ml mm mn jz mo ka mp kc mq kd mr kf ms kg mt mu bi translated">用测试数据验证模型</h1><p id="b823" class="pw-post-body-paragraph kz la it lb b lc mv ju le lf mw jx lh li mx lk ll lm my lo lp lq mz ls lt lu im bi translated">到目前为止，我们只根据我们使用的训练数据验证了我们的模型。然而，如果这个模型不能处理新的数据，它将是完全无用的。</p><p id="18e0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">因此，在训练网络时，我们通常将数据分为训练数据和测试数据。测试数据不是培训的一部分，仅在培训完成后进行测试。</p><pre class="kj kk kl km gt no np nq nr aw ns bi"><span id="9e56" class="nt me it np b gy nu nv l nw nx">tX = hcat(float.(reshape.(MNIST.images(:test), :))...)<br/>tY = onehotbatch(MNIST.labels(:test), 0:9)<br/><br/>@show accuracy(tX, tY)</span></pre></div><div class="ab cl lw lx hx ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="im in io ip iq"><h1 id="2ea6" class="md me it bd mf mg mh mi mj mk ml mm mn jz mo ka mp kc mq kd mr kf ms kg mt mu bi translated">结束语</h1><p id="21a2" class="pw-post-body-paragraph kz la it lb b lc mv ju le lf mw jx lh li mx lk ll lm my lo lp lq mz ls lt lu im bi translated">我希望这有助于你理解建立神经网络的过程。</p><p id="26a8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">太多的教程倾向于跳过对初学者的解释，所有的新概念会很快变得令人困惑。我希望这给了进一步探索机器学习的一个起点，尤其是和Julia的机器学习，我觉得前景很光明。</p><p id="07e6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">请记住，在这个问题上，我也是一个初学者。这也是我写这篇文章的动机，因为我意识到专家通常认为你已经知道了很多细节。作为初学者，我知道很多绊脚石在哪里！</p><p id="2c10" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">黑客快乐！</p></div></div>    
</body>
</html>