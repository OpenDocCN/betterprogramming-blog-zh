<html>
<head>
<title>Understanding XA Transactions With Practical Examples in Go</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">用Go中的实例理解XA事务</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/understanding-xa-transactions-with-practical-examples-in-go-67e99fd333db?source=collection_archive---------10-----------------------#2022-05-09">https://betterprogramming.pub/understanding-xa-transactions-with-practical-examples-in-go-67e99fd333db?source=collection_archive---------10-----------------------#2022-05-09</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="14a7" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">XA事务处理原理初探</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/be7600f46cd4fcaf5671ddf09637844d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*nR_0qZE7PxZ9YlZg"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">在<a class="ae kv" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上由<a class="ae kv" href="https://unsplash.com/@towfiqu999999?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Towfiqu barb huya</a>拍摄的照片</p></figure><p id="5eec" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">XA是由X/Open组织提出的分布式事务规范。X/Open分布式事务处理(DTP)模型由三个软件组件组成:</p><ul class=""><li id="4305" class="ls lt iq ky b kz la lc ld lf lu lj lv ln lw lr lx ly lz ma bi translated">应用程序(AP)定义事务边界并指定构成事务的动作。</li><li id="0032" class="ls lt iq ky b kz mb lc mc lf md lj me ln mf lr lx ly lz ma bi translated">资源管理器(RM，如数据库或文件访问系统)提供对共享资源的访问。</li><li id="f300" class="ls lt iq ky b kz mb lc mc lf md lj me ln mf lr lx ly lz ma bi translated">一个称为事务管理器(TM)的独立组件为事务分配标识符，监控它们的进程，并负责事务完成和故障恢复。</li></ul><p id="cfe9" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">下图说明了X/Open DTP模型定义的接口。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi mg"><img src="../Images/17b17c87c8bf64882bf84dfb5509022f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1104/format:webp/1*85_Ucc6zY0h59m2YGjO0pg.jpeg"/></div></figure><p id="c977" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">XA分为两个阶段。</p><ul class=""><li id="54d2" class="ls lt iq ky b kz la lc ld lf lu lj lv ln lw lr lx ly lz ma bi translated">阶段1(准备):所有参与的RM准备执行它们的事务并锁定所需的资源。当每个参与者准备好时，它向TM报告。</li><li id="e99b" class="ls lt iq ky b kz mb lc mc lf md lj me ln mf lr lx ly lz ma bi translated">阶段2(提交/回滚):当事务管理器(TM)接收到所有参与者(RM)都准备好了时，它向所有参与者发送提交命令。否则，它会向所有参与者发送回滚命令。</li></ul><p id="6a5a" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">目前，几乎所有流行的数据库都支持XA事务，包括Mysql、Oracle、SqlServer和Postgres。</p><h1 id="8e42" class="mh mi iq bd mj mk ml mm mn mo mp mq mr jw ms jx mt jz mu ka mv kc mw kd mx my bi translated">Mysql中的XA</h1><p id="5016" class="pw-post-body-paragraph kw kx iq ky b kz mz jr lb lc na ju le lf nb lh li lj nc ll lm ln nd lp lq lr ij bi translated">让我们用下面的代码看看数据库Mysql是如何支持XA的:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ne nf l"/></div></figure><h1 id="2744" class="mh mi iq bd mj mk ml mm mn mo mp mq mr jw ms jx mt jz mu ka mv kc mw kd mx my bi translated">业务场景</h1><p id="0582" class="pw-post-body-paragraph kw kx iq ky b kz mz jr lb lc na ju le lf nb lh li lj nc ll lm ln nd lp lq lr ij bi translated">跨行转账是一种典型的分布式交易场景，其中A需要通过银行向B转账。取款和存款都可能成功或失败，并且要求A和B的余额之和在转账完成后不应发生变化，无论发生任何错误。</p><h1 id="9264" class="mh mi iq bd mj mk ml mm mn mo mp mq mr jw ms jx mt jz mu ka mv kc mw kd mx my bi translated">实现分布式XA事务</h1><p id="b17e" class="pw-post-body-paragraph kw kx iq ky b kz mz jr lb lc na ju le lf nb lh li lj nc ll lm ln nd lp lq lr ij bi translated">分布式XA事务可以解决上述业务问题。本文提出了一个基于<a class="ae kv" href="https://github.com/dtm-labs/dtm" rel="noopener ugc nofollow" target="_blank"> dtm-labs/dtm </a>的解决方案。DTM是一个流行的分布式事务框架，支持XA、Saga、OutBox和TCC模式。</p><p id="6a3b" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">下图说明了一个成功的全局事务:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi ng"><img src="../Images/bd86c1e353098f1650abcef12ea2e2ac.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*vswQR6uE5_tMkyWwMvHWCA.jpeg"/></div></div></figure><p id="97e2" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在Go中实现它的代码非常简单:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ne nf l"/></div></figure><p id="7cec" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">上面的代码首先注册一个全局XA事务，然后调用两个子事务:<code class="fe nh ni nj nk b">TransOut</code>、<code class="fe nh ni nj nk b">TransIn</code>。在成功执行子事务之后，全局XA事务被提交给DTM。DTM收到XA全局事务的提交，然后调用所有子事务的<code class="fe nh ni nj nk b">XA commit</code>，最后将全局事务的状态更改为成功。</p><p id="41b0" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">其他语言的代码示例可以在这里找到:<a class="ae kv" href="https://en.dtm.pub/ref/sdk" rel="noopener ugc nofollow" target="_blank">SDK</a></p><h1 id="5e33" class="mh mi iq bd mj mk ml mm mn mo mp mq mr jw ms jx mt jz mu ka mv kc mw kd mx my bi translated">运行它</h1><p id="09b1" class="pw-post-body-paragraph kw kx iq ky b kz mz jr lb lc na ju le lf nb lh li lj nc ll lm ln nd lp lq lr ij bi translated">您可以通过运行以下命令来运行上面的示例。</p><h2 id="44c8" class="nl mi iq bd mj nm nn dn mn no np dp mr lf nq nr mt lj ns nt mv ln nu nv mx nw bi translated">运行DTM</h2><pre class="kg kh ki kj gt nx nk ny nz aw oa bi"><span id="3265" class="nl mi iq nk b gy ob oc l od oe">git clone https://github.com/dtm-labs/dtm &amp;&amp; cd dtm<br/>go run main.go</span></pre><h2 id="14bd" class="nl mi iq bd mj nm nn dn mn no np dp mr lf nq nr mt lj ns nt mv ln nu nv mx nw bi translated">运行示例</h2><pre class="kg kh ki kj gt nx nk ny nz aw oa bi"><span id="09cd" class="nl mi iq nk b gy ob oc l od oe">git clone https://github.com/dtm-labs/dtm-examples &amp;&amp; cd dtm-examples<br/>go run main.go http_xa</span></pre><h1 id="f622" class="mh mi iq bd mj mk ml mm mn mo mp mq mr jw ms jx mt jz mu ka mv kc mw kd mx my bi translated">失败时回滚</h1><p id="68c6" class="pw-post-body-paragraph kw kx iq ky b kz mz jr lb lc na ju le lf nb lh li lj nc ll lm ln nd lp lq lr ij bi translated">如果任何一个<code class="fe nh ni nj nk b">prepare</code>操作失败，DTM将调用每个子事务的<code class="fe nh ni nj nk b">XA rollback</code>进行回滚，最终将全局事务的状态改为失败。</p><p id="509c" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">让我们在XaFireRequest的请求负载中传递<code class="fe nh ni nj nk b">TransInResult="FAILURE"</code>来触发一个失败。</p><pre class="kg kh ki kj gt nx nk ny nz aw oa bi"><span id="95ad" class="nl mi iq nk b gy ob oc l od oe">req := &amp;busi.TransReq{Amount: 30, TransInResult: "FAILURE"}</span></pre><p id="05b5" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">故障时序图如下:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi of"><img src="../Images/9ba0c20a8663196140a6911af1a70ef3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*p4_utGG08OElnAlpc4robg.jpeg"/></div></div></figure><h2 id="f835" class="nl mi iq bd mj nm nn dn mn no np dp mr lf nq nr mt lj ns nt mv ln nu nv mx nw bi translated">注意</h2><ul class=""><li id="f698" class="ls lt iq ky b kz mz lc na lf og lj oh ln oi lr lx ly lz ma bi translated">第二阶段的命令也被发送到API <code class="fe nh ni nj nk b">BusiAPI+"/TransOutXa"</code>，在这个服务内部，<code class="fe nh ni nj nk b">dtmcli.XaLocalTransaction</code>会自动调用<code class="fe nh ni nj nk b">XA commit</code> | <code class="fe nh ni nj nk b">XA rollback</code>。所以请求的主体是nil，解析主体操作，比如前面的<code class="fe nh ni nj nk b">reqFrom</code>，需要放在<code class="fe nh ni nj nk b">XaLocalTransaction</code>里面。否则，主体解析将导致错误。</li></ul><h1 id="2600" class="mh mi iq bd mj mk ml mm mn mo mp mq mr jw ms jx mt jz mu ka mv kc mw kd mx my bi translated">TM故障</h1><p id="c02f" class="pw-post-body-paragraph kw kx iq ky b kz mz jr lb lc na ju le lf nb lh li lj nc ll lm ln nd lp lq lr ij bi translated">两阶段提交的复杂性来自所有可能出现的失败场景。最讨厌的失败发生在参与者已经确认并准备好之后，收到决策之前，比如协调者的失败。</p><p id="4c85" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们对此故障的解决方案非常简单和健壮。由于大多数云供应商提供高可用性数据库，我们可以在这些数据库中存储子事务的进度，并运行多个TMs实例。每个实例将轮询暂停的事务并继续处理它们。</p><p id="f2aa" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">云供应商负责处理数据库故障，并可能使用Paxos/Raft来可靠地选出一个健康的实例。</p><h1 id="dc83" class="mh mi iq bd mj mk ml mm mn mo mp mq mr jw ms jx mt jz mu ka mv kc mw kd mx my bi translated">优点和缺点</h1><p id="7575" class="pw-post-body-paragraph kw kx iq ky b kz mz jr lb lc na ju le lf nb lh li lj nc ll lm ln nd lp lq lr ij bi translated">与SAGA和TCC等其他模式相比，XA全球事务的优势在于:</p><ul class=""><li id="9533" class="ls lt iq ky b kz la lc ld lf lu lj lv ln lw lr lx ly lz ma bi translated">简单易懂</li><li id="8a76" class="ls lt iq ky b kz mb lc mc lf md lj me ln mf lr lx ly lz ma bi translated">业务自动回滚，无需手动写补偿</li></ul><p id="21cf" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">XA的缺点是:</p><ul class=""><li id="40c8" class="ls lt iq ky b kz la lc ld lf lu lj lv ln lw lr lx ly lz ma bi translated">需要来自底层数据库的XA事务</li><li id="6f93" class="ls lt iq ky b kz mb lc mc lf md lj me ln mf lr lx ly lz ma bi translated">从数据修改到提交，数据被锁定，这比其他模式要长得多。不适合高度并发的业务。</li></ul><h1 id="986f" class="mh mi iq bd mj mk ml mm mn mo mp mq mr jw ms jx mt jz mu ka mv kc mw kd mx my bi translated"><strong class="ak">结论</strong></h1><p id="7168" class="pw-post-body-paragraph kw kx iq ky b kz mz jr lb lc na ju le lf nb lh li lj nc ll lm ln nd lp lq lr ij bi translated">本文介绍了XA事务的基本原理，并给出了一个应用实例。读者可以很容易地按照这个例子来处理自己的业务。</p><p id="8631" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">欢迎你来参观github.com/dtm-labs/dtm。这是一个致力于使微服务中的分布式事务更容易的项目。它支持多种语言和模式，如两阶段消息、Saga、TCC和XA。</p></div></div>    
</body>
</html>