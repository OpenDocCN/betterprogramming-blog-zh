<html>
<head>
<title>Understanding async-await in JavaScript</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">理解JavaScript中的异步等待</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/understanding-async-await-in-javascript-1d81bb079b2c?source=collection_archive---------0-----------------------#2018-07-20">https://betterprogramming.pub/understanding-async-await-in-javascript-1d81bb079b2c?source=collection_archive---------0-----------------------#2018-07-20</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="652a" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">何时以及如何使用async和await的经验法则和示例</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/e9b73cfd18cb24558d97b1f26b583f52.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*fz94qwd_gqgWz35Fvl2jVQ.jpeg"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated"><a class="ae ky" href="https://unsplash.com/@qusaiakoud?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">库赛·阿库德</a>在<a class="ae ky" href="https://unsplash.com/search/photos/waiting?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的照片</p></figure><p id="2a59" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe lv lw lx ly b">async</code>和<code class="fe lv lw lx ly b">await</code>是承诺的延伸。如果你对承诺的基础知识感到不舒服，请在进一步阅读之前花些时间<a class="ae ky" href="https://medium.com/better-programming/understanding-promises-in-javascript-13d99df067c1" rel="noopener">理解承诺</a>。</p><p id="76c0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我确信你们中的许多人已经在使用<code class="fe lv lw lx ly b">async</code>和<code class="fe lv lw lx ly b">await</code>。但是，我认为它值得更多的关注。</p><p id="f903" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这里有一个小测试:如果你不能发现下面代码的问题，请继续阅读。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="lz ma l"/></div></figure><p id="b40d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">一旦我们完成了<code class="fe lv lw lx ly b">async-await</code>的基础知识，我们将在后面重新审视这个代码块。一如既往，<a class="ae ky" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/async_function" rel="noopener ugc nofollow" target="_blank"> Mozilla docs </a>是你的朋友。尤其是检查定义。</p><p id="f717" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">来自MDN:</p><blockquote class="mb mc md"><p id="a79a" class="kz la me lb b lc ld ju le lf lg jx lh mf lj lk ll mg ln lo lp mh lr ls lt lu im bi translated">“异步函数是通过事件循环异步操作的函数，使用隐式<code class="fe lv lw lx ly b"><a class="ae ky" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise" rel="noopener ugc nofollow" target="_blank">Promise</a></code>返回其结果。但是使用异步函数的代码的语法和结构更像是使用标准的同步函数。”</p></blockquote><p id="ea45" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我想知道是谁写的这些描述。它们简明扼要，表达清晰。分解一下:</p><ol class=""><li id="f9bc" class="mi mj it lb b lc ld lf lg li mk lm ml lq mm lu mn mo mp mq bi translated">该函数通过事件循环异步运行。</li><li id="aaeb" class="mi mj it lb b lc mr lf ms li mt lm mu lq mv lu mn mo mp mq bi translated">它使用一个隐式的<code class="fe lv lw lx ly b">Promise</code>来返回结果。</li><li id="d84e" class="mi mj it lb b lc mr lf ms li mt lm mu lq mv lu mn mo mp mq bi translated">代码的语法和结构类似于编写同步函数。</li></ol><p id="877c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">MDN继续说道:</p><blockquote class="mb mc md"><p id="33e8" class="kz la me lb b lc ld ju le lf lg jx lh mf lj lk ll mg ln lo lp mh lr ls lt lu im bi translated">一个<code class="fe lv lw lx ly b">async</code>函数可以包含一个<code class="fe lv lw lx ly b"><a class="ae ky" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/await" rel="noopener ugc nofollow" target="_blank">await</a></code>表达式，该表达式暂停异步函数的执行并等待传递的<code class="fe lv lw lx ly b">Promise</code>的解析，然后恢复<code class="fe lv lw lx ly b">async</code>函数的执行并返回解析后的值。记住，<code class="fe lv lw lx ly b">await</code>关键字只在<code class="fe lv lw lx ly b">async</code>函数中有效。"</p></blockquote><p id="b9af" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们跳到代码中来更好地理解这一点。我们也将重用我们在这里用来理解承诺的三个函数。</p><p id="ed60" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">返回一个承诺的函数，该承诺在n秒后解决或拒绝。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="lz ma l"/></div></figure><p id="adf0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">两个更确定的函数。一个在n秒后解决，另一个在n秒后拒绝。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="lz ma l"/></div></figure><p id="760b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">由于这三个函数返回承诺，我们也可以将这些函数称为异步函数。看，我们甚至在知道函数之前就编写了它们。</p><p id="9293" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果我们必须使用标准格式的承诺来使用函数<code class="fe lv lw lx ly b">promiseTRSANSG</code>,我们应该编写如下代码:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="lz ma l"/></div></figure><p id="b247" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这里有许多不必要的代码，例如，仅仅用于分配处理程序的匿名函数。<code class="fe lv lw lx ly b">async-await</code>所做的是改进它的语法，使它看起来更像同步代码。</p><p id="4f28" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果我们不得不与上面的<code class="fe lv lw lx ly b">async await</code>一样，格式应该是这样的:</p><pre class="kj kk kl km gt mw ly mx my aw mz bi"><span id="6d8a" class="na nb it ly b gy nc nd l ne nf">result = await promiseTRSANSG(3);<br/>console.log(result);</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi ng"><img src="../Images/9ef9e5de00c8a2850a434f6162e329c6.png" data-original-src="https://miro.medium.com/v2/resize:fit:504/format:webp/1*EormI9twUDfgHudU95xSlg.png"/></div></figure><p id="cc3c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这看起来比标准的promise语法可读性更好。</p><p id="a7f8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">当我们使用<code class="fe lv lw lx ly b">await</code>时，代码的执行被阻塞了。这就是为什么您在变量<code class="fe lv lw lx ly b">result</code>中有承诺解决方案的值。</p><p id="9399" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">从上面的代码示例中可以看出，当使用<code class="fe lv lw lx ly b">await</code>时，结果被直接赋给变量，而不是<code class="fe lv lw lx ly b">.then</code>部分。</p><p id="98bf" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">你也可以看出<code class="fe lv lw lx ly b">.catch</code>部分不在这里。这是因为这是使用<code class="fe lv lw lx ly b">try catch</code>错误处理来处理的。所以，让我们用<code class="fe lv lw lx ly b">promiseTRRARNOSG</code>代替<code class="fe lv lw lx ly b">promiseTRSANS</code>。</p><p id="908c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">因为这个函数既可以解析也可以拒绝，所以我们需要处理这两种情况。</p><p id="56b9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在上面的代码中，我们写了两行，让您可以轻松比较标准格式和<code class="fe lv lw lx ly b">async await</code>格式。下一节中的例子让您对格式和结构有了更好的了解。</p></div><div class="ab cl nh ni hx nj" role="separator"><span class="nk bw bk nl nm nn"/><span class="nk bw bk nl nm nn"/><span class="nk bw bk nl nm"/></div><div class="im in io ip iq"><h1 id="f7d5" class="no nb it bd np nq nr ns nt nu nv nw nx jz ny ka nz kc oa kd ob kf oc kg od oe bi translated">使用<code class="fe lv lw lx ly b">async-await</code>的一般语法</h1><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="lz ma l"/></div></figure><p id="954a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">从上面的代码示例中，您可以看出，我们没有使用特定于promise的错误处理，而是使用更通用的方法，使用<code class="fe lv lw lx ly b">try</code> <code class="fe lv lw lx ly b">catch</code>进行错误处理。</p><p id="0d59" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这让我们少了一件需要记住的事情，并且也提高了整体的可读性，即使是在考虑了我们代码周围的<code class="fe lv lw lx ly b">try catch</code>块之后。</p><p id="2761" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">因此，根据您需要的错误处理级别，您可以添加任意数量的<code class="fe lv lw lx ly b">catch</code>块，使错误消息更加具体和有意义。</p></div><div class="ab cl nh ni hx nj" role="separator"><span class="nk bw bk nl nm nn"/><span class="nk bw bk nl nm nn"/><span class="nk bw bk nl nm"/></div><div class="im in io ip iq"><h1 id="1b20" class="no nb it bd np nq nr ns nt nu nv nw nx jz ny ka nz kc oa kd ob kf oc kg od oe bi translated"><strong class="ak">使用异步和等待的陷阱</strong></h1><p id="c488" class="pw-post-body-paragraph kz la it lb b lc of ju le lf og jx lh li oh lk ll lm oi lo lp lq oj ls lt lu im bi translated">让使用承诺变得更加容易。来自同步编程背景的开发者在使用<code class="fe lv lw lx ly b">async</code>和<code class="fe lv lw lx ly b">await</code>时会有宾至如归的感觉。</p><p id="57e5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这也应该提醒我们，因为这意味着如果我们不小心的话，我们正在走向一个更加同步的方法。</p><p id="1fe7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">JavaScript/ <a class="ae ky" href="https://nodejs.org/" rel="noopener ugc nofollow" target="_blank"> Node.js </a>的要点在于默认情况下认为是异步的，而不是事后的想法。<code class="fe lv lw lx ly b">async await</code>通常意味着你在按顺序做事。所以，每当你想使用<code class="fe lv lw lx ly b">async await</code>的时候，做一个有意识的决定。</p><p id="9870" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们开始分析我一开始给你们看的代码。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="lz ma l"/></div></figure><p id="f012" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这似乎是一段无害的代码，它获取了三个用户的GitHub详细信息:<code class="fe lv lw lx ly b">“nkgokul”</code>、<code class="fe lv lw lx ly b">“BrendanEich”</code>和<code class="fe lv lw lx ly b">“gaearon”</code>。</p><p id="59c9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">没错。这是真的。这就是这个函数的作用。但它也有一些意想不到的后果。</p><p id="7f7c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在深入研究代码之前，让我们构建一个简单的计时器。</p><pre class="kj kk kl km gt mw ly mx my aw mz bi"><span id="1587" class="na nb it ly b gy nc nd l ne nf">startTime = performance.now();  //Run at the beginning of the code</span><span id="2320" class="na nb it ly b gy ok nd l ne nf">function executingAt() {<br/>  return (performance.now() - startTime) / 1000;<br/>}</span></pre><p id="6efa" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在，我们可以使用<code class="fe lv lw lx ly b">executingAt</code>在任何我们想要的地方打印从开始以来已经超过的秒数。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="lz ma l"/></div></figure><p id="7843" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">查看输出:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ol"><img src="../Images/99dde9f275dba9fdf2d2784fb871c13f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*u9xrSYz0x-8Wozp3fF1rcA.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">异步等待分析</p></figure><p id="ed76" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">从输出中可以发现，每个<code class="fe lv lw lx ly b">await</code>函数都是在前一个函数完成后调用的。我们试图获取三个不同用户的详细信息:<code class="fe lv lw lx ly b">“nkgokul”</code>、<code class="fe lv lw lx ly b">“BrendanEich”</code>和<code class="fe lv lw lx ly b">“gaearon”</code>。</p><p id="c8ca" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">很明显，一个API调用的输出不依赖于其他API调用的输出。</p><p id="e2cf" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们唯一的依赖就是这两行代码。</p><pre class="kj kk kl km gt mw ly mx my aw mz bi"><span id="9b2b" class="na nb it ly b gy nc nd l ne nf">userDetails = await fetch("<a class="ae ky" href="https://api.github.com/users/" rel="noopener ugc nofollow" target="_blank">https://api.github.com/users/</a>" + name);<br/>userDetailsJSON = await userDetails.json();</span></pre><p id="62be" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们只有在得到<code class="fe lv lw lx ly b">userDetails</code>后才能创建<code class="fe lv lw lx ly b">userDetailsJSON</code>对象。</p><p id="7f96" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">因此，在这里使用<code class="fe lv lw lx ly b">await</code>是有意义的，它在获取单个用户的详细信息的范围内。因此，让我们制作一个<code class="fe lv lw lx ly b">async</code>来获取单个用户的详细信息。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="lz ma l"/></div></figure><p id="ba5b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">既然<code class="fe lv lw lx ly b">fetchSingleUsersDetailsWithStats</code>是<code class="fe lv lw lx ly b">async</code>，我们可以使用这个函数并行获取不同用户的详细信息。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="lz ma l"/></div></figure><p id="14f3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">当您想要并行运行时，我遵循的经验法则是:</p><pre class="kj kk kl km gt mw ly mx my aw mz bi"><span id="c4be" class="na nb it ly b gy nc nd l ne nf">Create a promise for each async call. Add all the promises to an array. Then pass the promises array to Promise.all. This, in turn, returns a single promise for which we can use await</span></pre><p id="5c6d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">当我们将所有这些放在一起时，我们得到:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="lz ma l"/></div></figure><p id="b707" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这样的输出是:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi om"><img src="../Images/003f57675209f260991095bb4383c5bb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1068/format:webp/1*Y11uqYrYia0AJmsv2r-kcA.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">承诺与时间戳并行</p></figure><p id="a725" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">从输出中可以看出，承诺的创建几乎是即时的，而API调用需要一些时间。</p><p id="a6de" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们需要强调这一点，因为与IO操作相比，承诺创建和处理所花费的时间是微不足道的。</p><p id="8ab6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">因此，当您选择promise库时，选择功能丰富且具有更好开发体验的库更有意义。当我们使用<code class="fe lv lw lx ly b">Promise.all</code>时，所有的API调用都是并行运行的。</p><p id="c635" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">每个API几乎需要0.88秒。但是，由于它们是并行调用的，我们能够在0.89秒内获得所有API调用的结果。</p><p id="b70b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在大多数情况下，理解这一点对我们有好处。现在，你可以直接跳到经验法则，或者继续阅读，如果你想深入了解的话。</p><p id="40d8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">深入挖掘<code class="fe lv lw lx ly b">await</code>！</p><p id="107b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">为此，让我们把自己限制在<code class="fe lv lw lx ly b">promiseTRSANSG</code>函数上。该函数的结果更具确定性，有助于我们识别差异。</p></div><div class="ab cl nh ni hx nj" role="separator"><span class="nk bw bk nl nm nn"/><span class="nk bw bk nl nm nn"/><span class="nk bw bk nl nm"/></div><div class="im in io ip iq"><h1 id="ef0f" class="no nb it bd np nq nr ns nt nu nv nw nx jz ny ka nz kc oa kd ob kf oc kg od oe bi translated">顺序执行</h1><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="lz ma l"/></div></figure><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi on"><img src="../Images/9bd916400f47de8b0ad7c774b8faa424.png" data-original-src="https://miro.medium.com/v2/resize:fit:810/format:webp/1*RD8rsrqkofT4FEFyhejgdw.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">顺序执行</p></figure></div><div class="ab cl nh ni hx nj" role="separator"><span class="nk bw bk nl nm nn"/><span class="nk bw bk nl nm nn"/><span class="nk bw bk nl nm"/></div><div class="im in io ip iq"><h1 id="0140" class="no nb it bd np nq nr ns nt nu nv nw nx jz ny ka nz kc oa kd ob kf oc kg od oe bi translated">使用Promise.all的并行执行</h1><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="lz ma l"/></div></figure><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi oo"><img src="../Images/9771b7abb04c09ce70b3b519966f763c.png" data-original-src="https://miro.medium.com/v2/resize:fit:630/format:webp/1*-PcJFK8JTt3sHkvWhk3g2Q.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">使用承诺的并行执行</p></figure></div><div class="ab cl nh ni hx nj" role="separator"><span class="nk bw bk nl nm nn"/><span class="nk bw bk nl nm nn"/><span class="nk bw bk nl nm"/></div><div class="im in io ip iq"><h1 id="62f4" class="no nb it bd np nq nr ns nt nu nv nw nx jz ny ka nz kc oa kd ob kf oc kg od oe bi translated">并行开始执行</h1><p id="ec75" class="pw-post-body-paragraph kz la it lb b lc of ju le lf og jx lh li oh lk ll lm oi lo lp lq oj ls lt lu im bi translated">一旦<code class="fe lv lw lx ly b">promise</code>被创建，异步执行就开始了。<code class="fe lv lw lx ly b">await</code>只是阻塞<code class="fe lv lw lx ly b">async</code>函数中的代码，直到承诺被解决。</p><p id="7b98" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们创建一个函数来帮助我们清楚地理解这一点。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="lz ma l"/></div></figure><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi op"><img src="../Images/f9225c4523eafbd9b60cf08e68788102.png" data-original-src="https://miro.medium.com/v2/resize:fit:980/format:webp/1*5V9RDkv9_2uFJQ8LNdx_Qg.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">并发启动，然后等待</p></figure><p id="e68b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">从之前的帖子中，我们知道<code class="fe lv lw lx ly b">.then</code>是事件驱动的。也就是说，一旦解决了承诺，就会执行<code class="fe lv lw lx ly b">.then</code>。</p><p id="eea4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">所以，让我们用<code class="fe lv lw lx ly b">resolveAfter3seconds.then </code>和<code class="fe lv lw lx ly b">resolveAfter4seconds.then</code>来标识我们的承诺何时真正兑现。从输出中我们可以看到，<code class="fe lv lw lx ly b">resolveAfter3seconds</code>在3秒后被解析，<code class="fe lv lw lx ly b">resolveAfter4seconds</code>在4秒后被执行。这是意料之中的。</p><p id="aad1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在，为了检查<code class="fe lv lw lx ly b">await</code>如何影响代码的执行，我们使用了:</p><pre class="kj kk kl km gt mw ly mx my aw mz bi"><span id="2f70" class="na nb it ly b gy nc nd l ne nf">console.log(await resolveAfter4seconds);<br/>console.log(await resolveAfter3seconds);</span></pre><p id="a225" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">从<code class="fe lv lw lx ly b">.then</code>的输出可以看出，<code class="fe lv lw lx ly b">resolveAfter3seconds</code>比<code class="fe lv lw lx ly b">resolveAfter4seconds</code>早一秒解决。但是，我们用<code class="fe lv lw lx ly b">await</code>表示<code class="fe lv lw lx ly b">resolveAfter4seconds</code>，然后用<code class="fe lv lw lx ly b">await</code>表示<code class="fe lv lw lx ly b">resolveAfter3seconds</code>。</p><p id="0fc6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">从输出中，我们可以看到虽然<code class="fe lv lw lx ly b">resolveAfter3seconds</code>已经被解析，但是它是在<code class="fe lv lw lx ly b">console.log(await resolveAfter4seconds);</code>的输出被打印之后才被打印的。</p><p id="0ce4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这重申了我们先前所说的。<code class="fe lv lw lx ly b">await</code>只阻塞<code class="fe lv lw lx ly b">async</code>函数中下一行代码的执行，不影响承诺的执行。</p></div><div class="ab cl nh ni hx nj" role="separator"><span class="nk bw bk nl nm nn"/><span class="nk bw bk nl nm nn"/><span class="nk bw bk nl nm"/></div><div class="im in io ip iq"><h1 id="1173" class="no nb it bd np nq nr ns nt nu nv nw nx jz ny ka nz kc oa kd ob kf oc kg od oe bi translated">放弃</h1><p id="f964" class="pw-post-body-paragraph kz la it lb b lc of ju le lf og jx lh li oh lk ll lm oi lo lp lq oj ls lt lu im bi translated"><a class="ae ky" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/async_function" rel="noopener ugc nofollow" target="_blank"> MDN文档</a>提到<code class="fe lv lw lx ly b">Promise.all</code>仍然是串行的，使用<code class="fe lv lw lx ly b">.then</code>是真正的并行。我无法理解其中的区别，很想听听有没有人知道其中的区别。</p></div><div class="ab cl nh ni hx nj" role="separator"><span class="nk bw bk nl nm nn"/><span class="nk bw bk nl nm nn"/><span class="nk bw bk nl nm"/></div><div class="im in io ip iq"><h1 id="b59e" class="no nb it bd np nq nr ns nt nu nv nw nx jz ny ka nz kc oa kd ob kf oc kg od oe bi translated"><strong class="ak">经验法则</strong></h1><p id="a102" class="pw-post-body-paragraph kz la it lb b lc of ju le lf og jx lh li oh lk ll lm oi lo lp lq oj ls lt lu im bi translated">以下是使用<code class="fe lv lw lx ly b">async</code>和<code class="fe lv lw lx ly b">await</code>的经验法则:</p><ol class=""><li id="adca" class="mi mj it lb b lc ld lf lg li mk lm ml lq mm lu mn mo mp mq bi translated"><code class="fe lv lw lx ly b">async</code>函数返回一个承诺。</li><li id="5714" class="mi mj it lb b lc mr lf ms li mt lm mu lq mv lu mn mo mp mq bi translated"><code class="fe lv lw lx ly b">async</code>函数使用隐式<code class="fe lv lw lx ly b">Promise</code>返回结果。即使你没有明确地返回一个承诺，<code class="fe lv lw lx ly b">async</code>函数也会确保你的代码通过一个承诺。</li><li id="4153" class="mi mj it lb b lc mr lf ms li mt lm mu lq mv lu mn mo mp mq bi translated"><code class="fe lv lw lx ly b">await</code>阻塞<code class="fe lv lw lx ly b">async</code>函数内的代码执行，它(<code class="fe lv lw lx ly b">await statement</code>)是函数的一部分。</li><li id="66fe" class="mi mj it lb b lc mr lf ms li mt lm mu lq mv lu mn mo mp mq bi translated">在一个<code class="fe lv lw lx ly b">async</code>函数中可以有多个<code class="fe lv lw lx ly b">await</code>语句。</li><li id="04dd" class="mi mj it lb b lc mr lf ms li mt lm mu lq mv lu mn mo mp mq bi translated">使用<code class="fe lv lw lx ly b">async await</code>时，确保使用<code class="fe lv lw lx ly b">try catch</code>进行错误处理。</li><li id="7e69" class="mi mj it lb b lc mr lf ms li mt lm mu lq mv lu mn mo mp mq bi translated">如果你的代码包含阻塞代码，最好把它变成一个<code class="fe lv lw lx ly b">async</code>函数。通过这样做，您可以确保其他人可以异步使用您的函数。</li><li id="6b79" class="mi mj it lb b lc mr lf ms li mt lm mu lq mv lu mn mo mp mq bi translated">通过从阻塞代码中生成<code class="fe lv lw lx ly b">async</code>函数，您可以让用户(将调用您的函数)决定他们想要的异步级别。</li><li id="aa52" class="mi mj it lb b lc mr lf ms li mt lm mu lq mv lu mn mo mp mq bi translated">在循环和迭代器中使用<code class="fe lv lw lx ly b">await</code>时要格外小心。您可能会陷入编写顺序执行代码的陷阱，而这本来可以很容易地并行完成。</li><li id="61f6" class="mi mj it lb b lc mr lf ms li mt lm mu lq mv lu mn mo mp mq bi translated"><code class="fe lv lw lx ly b">await</code>永远是为了一个单一的承诺。如果您想要<code class="fe lv lw lx ly b">await</code>多个承诺(并行运行这个承诺),创建一个承诺数组，然后将其传递给<code class="fe lv lw lx ly b">Promise.all</code>函数。</li><li id="8484" class="mi mj it lb b lc mr lf ms li mt lm mu lq mv lu mn mo mp mq bi translated">承诺创建启动异步功能的执行。</li><li id="4f30" class="mi mj it lb b lc mr lf ms li mt lm mu lq mv lu mn mo mp mq bi translated"><code class="fe lv lw lx ly b">await</code>仅阻止<code class="fe lv lw lx ly b">async</code>功能内的代码执行。它只确保当<code class="fe lv lw lx ly b">promise</code>决议时，下一行被执行。因此，如果异步活动已经开始，那么<code class="fe lv lw lx ly b">await</code>将不会对其产生影响。</li><li id="7221" class="mi mj it lb b lc mr lf ms li mt lm mu lq mv lu mn mo mp mq bi translated"><a class="ae ky" href="https://medium.com/better-programming/should-i-use-promises-or-async-await-126ab5c98789" rel="noopener">何时使用承诺，何时使用异步等待？</a></li></ol><p id="774b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">请指出我是否遗漏了什么，或者是否有可以改进的地方。</p><p id="7db4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果你喜欢异步等待的深入分析，并且想了解更多关于Javascript的信息，加入我们的讨论<a class="ae ky" href="https://discord.gg/ENbQbbZy25" rel="noopener ugc nofollow" target="_blank">https://discord.gg/ENbQbbZy25</a>或者在推特上关注我<a class="ae ky" href="https://twitter.com/gokulnk" rel="noopener ugc nofollow" target="_blank">https://twitter.com/gokulnk</a></p><p id="c2a3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">你可以订阅我的时事通讯<a class="ae ky" href="https://understandingx.substack.com/" rel="noopener ugc nofollow" target="_blank">https://understandingx.substack.com/</a>我懒得写，所以你可能暂时不会收到我的来信。</p></div></div>    
</body>
</html>