<html>
<head>
<title>How to Build Both Kinds of AWS Lambda Layers. (Yes, There Are Two)</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何构建这两种AWS Lambda层。(是的，有两个)</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/how-to-build-both-kinds-of-aws-lambda-layers-yes-there-are-two-edb945979f17?source=collection_archive---------5-----------------------#2020-04-02">https://betterprogramming.pub/how-to-build-both-kinds-of-aws-lambda-layers-yes-there-are-two-edb945979f17?source=collection_archive---------5-----------------------#2020-04-02</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="921d" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">你知道兰姆达斯像食人魔吗？他们有层次。了解如何以最简单的方式跨无服务器函数共享代码</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/3cfad879b22c0be71562f1958ca2f102.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*9jd2pVcZiqVFK4fv"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">照片由<a class="ae ky" href="https://unsplash.com/@cdrying?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> C在<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上烘干</a></p></figure><p id="36c7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">大约一年前，我开始了无服务器编程。我来自一个企业软件背景，有着巨大的应用程序和意大利面条一样的代码。如果我更改了一些修改UI的代码，有可能会影响到数据库级别的东西。呀！</p><p id="44ec" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我认为代码应该被重用和共享。只写一次就可以从任何地方调用它，这是有道理的。当我开始用Lambda构建我的第一个概念证明时，我假设我也能做同样的事情。</p><p id="9546" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我在<a class="ae ky" href="https://code.visualstudio.com/" rel="noopener ugc nofollow" target="_blank"> VS代码</a>中构建了我的解决方案，每个Lambda都在它自己的文件夹中，所有基类和可重用函数都在一个共享文件夹中。</p><p id="5cc7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在我的本地机器上运行良好。当我按下部署键时，一切都乱套了。</p><p id="f503" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">什么都没用。到处都有“找不到方法”的异常。我开始认为云开发可能不像大家说的那么容易。</p><p id="0b21" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">当您将Lambda函数部署到云中时，它必须绑定所有的依赖项。如果您使用<a class="ae ky" href="https://aws.amazon.com/serverless/sam/" rel="noopener ugc nofollow" target="_blank"> AWS SAM </a>，它会获取Lambda的根文件夹中包含的所有内容。就这些，没别的了。</p><p id="f925" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">共享依赖项不存在于根文件夹中，它们存在于共享文件夹中，因此所有功能都可以通过相同的路径访问它们。我该怎么解决这个问题？</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="6fee" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">你有选择</h1><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi mu"><img src="../Images/52896a10bac7d68b467bbd94329f0526.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*sUXQzpK9EOmxEFF5"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">由<a class="ae ky" href="https://unsplash.com/@kellysikkema?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Kelly Sikkema </a>在<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</p></figure><p id="a507" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">有三种方法可以解决这个问题:</p><ul class=""><li id="6a94" class="mv mw it lb b lc ld lf lg li mx lm my lq mz lu na nb nc nd bi translated">在每个需要的lambda目录中复制代码</li><li id="3997" class="mv mw it lb b lc ne lf nf li ng lm nh lq ni lu na nb nc nd bi translated">创建一个包(npm、nuget、PyPi)并作为依赖项安装</li><li id="1022" class="mv mw it lb b lc ne lf nf li ng lm nh lq ni lu na nb nc nd bi translated">使用Lambda层</li></ul><p id="cc8b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们不会讨论第一种选择。它之所以在那里，是因为从技术上来说，它是问题的解决方案，但它是不可扩展的。一点也不。</p><p id="d588" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">创建一个包并不是一个坏主意。如果您需要跨微服务共享代码，这实际上是一个非常好的想法。如果你只是在同一个微服务中共享代码，这可能有点过头了。然而，如果你想让你的代码开源并与世界共享，我完全赞成！</p><p id="2bfe" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们今天在这里讨论第三种选择:Lambda层。一个<em class="nj">层</em>仅仅是位于你的主要Lambda函数旁边的另一束代码。它们是可重用的块，可以在任意多的Lambdas上共享，甚至可以跨帐户共享。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="c76c" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">两种类型的层</h1><p id="bc77" class="pw-post-body-paragraph kz la it lb b lc nk ju le lf nl jx lh li nm lk ll lm nn lo lp lq no ls lt lu im bi translated">信不信由你，实际上有两种不同类型的层。从技术上来说，只有一个，如果您查看部署的资源类型。但是在实践中，层有两种非常不同的用例。</p><h2 id="5bed" class="np md it bd me nq nr dn mi ns nt dp mm li nu nv mo lm nw nx mq lq ny nz ms oa bi translated">依赖层</h2><p id="18e3" class="pw-post-body-paragraph kz la it lb b lc nk ju le lf nl jx lh li nm lk ll lm nn lo lp lq no ls lt lu im bi translated">严格来说，依赖层是一个包含Lambda函数的第三方依赖的包。很多软件包都很大，需要一段时间来加载，并且会增加你的函数代码。通过将所有的依赖转移到一个共享的Lambda层，您可以卸载大部分的部署包，保持您的功能代码集中和简洁。</p><h2 id="0454" class="np md it bd me nq nr dn mi ns nt dp mm li nu nv mo lm nw nx mq lq ny nz ms oa bi translated">功能层</h2><p id="ffaa" class="pw-post-body-paragraph kz la it lb b lc nk ju le lf nl jx lh li nm lk ll lm nn lo lp lq no ls lt lu im bi translated">这是我最初的图层用例。如果您想在多个函数之间共享代码，该怎么办？开发人员已经过了编写代码的潮湿(“我们喜欢打字”)时代。如果我们能写一次函数并在所有的Lambdas中访问它，那就太好了。这样，如果我们需要在一段可重用的代码中更改某些东西，我们可以在一个地方更改它，它会在任何地方更新。呜哇！</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="30ba" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">开发商搭车</h1><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ob"><img src="../Images/c18439b66bff49dd8bd39dcab45a0e11.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*nUXE56zFgBf3Jl3U"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">由<a class="ae ky" href="https://unsplash.com/@alvaroreyes?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">阿尔瓦罗·雷耶斯</a>在<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</p></figure><p id="484e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">遵循介质上的指南可能有点抽象。我在GitHub 上提供了一个<a class="ae ky" href="https://github.com/allenheltondev/aws-lambda-layer-types" rel="noopener ugc nofollow" target="_blank">完整的工作解决方案，请大家和我一起看一下。</a></p><p id="7896" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">工作实例总是对我获得解决问题的方法帮助最大。您可能想在这里暂停一下，以遵循<a class="ae ky" href="https://github.com/allenheltondev/aws-lambda-layer-types/blob/master/README.md" rel="noopener ugc nofollow" target="_blank">先决条件</a>并确保您已经设置好了。</p><p id="df99" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我提供的例子是一个小型的、无服务器的API，它管理联系人并允许你通过<a class="ae ky" href="https://www.twilio.com" rel="noopener ugc nofollow" target="_blank"> Twilio </a>给他们发送文本消息。您可以添加、更新和删除联系人，以及发送和查看发送给每个联系人的邮件。</p><h2 id="e24e" class="np md it bd me nq nr dn mi ns nt dp mm li nu nv mo lm nw nx mq lq ny nz ms oa bi translated">构建依赖层</h2><p id="24ad" class="pw-post-body-paragraph kz la it lb b lc nk ju le lf nl jx lh li nm lk ll lm nn lo lp lq no ls lt lu im bi translated">如前所述，依赖层有助于保持您的部署包较小。如果您希望使用AWS控制台进行任何快速故障排除，这将是一个非常有用的情况。</p><p id="46b2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果Lambda部署包大于3 MB，则不能在控制台中编辑代码。</p><p id="e55f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">因此，对于我们的contact <em class="nj"> </em>示例中的依赖层，我们在根处有一个名为<code class="fe oc od oe of b">dependencies</code> <strong class="lb iu"> </strong>的文件夹，以及一个名为<code class="fe oc od oe of b">nodejs.</code> <strong class="lb iu"> </strong>的子文件夹。由于我们在示例中使用了<a class="ae ky" href="https://nodejs.org/en/" rel="noopener ugc nofollow" target="_blank">节点</a>，我们只需添加一个名为<code class="fe oc od oe of b">nodejs</code>的文件夹。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi og"><img src="../Images/de03954c8eb5bfa3713b25277d401cb0.png" data-original-src="https://miro.medium.com/v2/resize:fit:736/format:webp/1*INsr_oDL9Isu1_GTWYteHQ.png"/></div></figure><p id="9497" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">对于基于运行时的所有目录名的完整列表，您可以查看<a class="ae ky" href="https://docs.aws.amazon.com/lambda/latest/dg/configuration-layers.html#configuration-layers-path" rel="noopener ugc nofollow" target="_blank"> AWS文档</a>。</p><p id="3bc3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在<code class="fe oc od oe of b">nodejs</code>文件夹中，我们只有一个<code class="fe oc od oe of b">package.json</code>和一个<code class="fe oc od oe of b">package-lock.json</code>。</p><p id="e107" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe oc od oe of b">package.json</code>将只包含我们想要添加到我们的层中的依赖关系。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oh oi l"/></div></figure><p id="12ec" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在我们的SAM模板中，我们想要添加一个<code class="fe oc od oe of b">LayerVersion</code>并将其指向依赖目录</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oh oi l"/></div></figure><p id="17b9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这就是创建依赖层的方法——非常容易实现，但不一定直观。现在来创建一个功能层。</p><h2 id="c1e5" class="np md it bd me nq nr dn mi ns nt dp mm li nu nv mo lm nw nx mq lq ny nz ms oa bi translated">构建功能层</h2><p id="f019" class="pw-post-body-paragraph kz la it lb b lc nk ju le lf nl jx lh li nm lk ll lm nn lo lp lq no ls lt lu im bi translated">对于这种类型的层，您可能有更多的用例，这种层使您能够在整个解决方案中提供共享代码。这个布局差不多，只是消费略有不同。</p><p id="247e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在根目录下创建一个名为<code class="fe oc od oe of b">layers</code> &gt; <code class="fe oc od oe of b">nodejs</code>的文件夹结构。同样，这个子文件夹是因为我们正在使用的运行时。如果你用的是Python，Ruby等，那就不一样了。</p><p id="9020" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">添加<code class="fe oc od oe of b">package.json</code>和任何将要包含共享代码的文件。对于我们的例子，我们有一个<code class="fe oc od oe of b">database.js</code>和一个<code class="fe oc od oe of b">enums.js</code>文件。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi oj"><img src="../Images/844b9b4ce7190ea67f2428984de63908.png" data-original-src="https://miro.medium.com/v2/resize:fit:674/format:webp/1*NlGfVpA9DqgZ7mBmA5PZhQ.png"/></div></figure><p id="a5a2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">你在这个目录中添加的每个文件在你的Lambdas中都是一个单独的导入。这很好，因为您可以对共享代码的关注点进行合理的分离。这有助于你更有条理。</p><p id="d521" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">模板<code class="fe oc od oe of b">yaml</code>中的资源声明将与依赖层相同，只是这次它将指向layers文件夹。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oh oi l"/></div></figure><p id="45a5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这两种类型的层的实现非常相似，唯一真正的区别是添加到层目录中的文件。这两者之间的主要区别在于它们是如何被您的函数消费的。</p><h2 id="ff3d" class="np md it bd me nq nr dn mi ns nt dp mm li nu nv mo lm nw nx mq lq ny nz ms oa bi translated">使用依赖层</h2><p id="2cfb" class="pw-post-body-paragraph kz la it lb b lc nk ju le lf nl jx lh li nm lk ll lm nn lo lp lq no ls lt lu im bi translated">要让Lambda使用您的层，您需要将它添加到模板<code class="fe oc od oe of b">yaml</code>中。如果您希望您的层可用于您的微服务中的所有功能，您可以方便地将其添加到<code class="fe oc od oe of b">Globals</code> <strong class="lb iu"> </strong>部分。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oh oi l"/></div></figure><p id="ff55" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在您使该层对该功能可用之后，您需要将资产拉进来。有了依赖层，一切如常:只需添加您的<code class="fe oc od oe of b">require</code> <strong class="lb iu"> </strong>语句就可以了。构建函数代码的方式没有变化。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oh oi l"/></div></figure><h2 id="7c14" class="np md it bd me nq nr dn mi ns nt dp mm li nu nv mo lm nw nx mq lq ny nz ms oa bi translated">消费功能层</h2><p id="8923" class="pw-post-body-paragraph kz la it lb b lc nk ju le lf nl jx lh li nm lk ll lm nn lo lp lq no ls lt lu im bi translated">这是你的发展会稍有变化的地方。功能层被部署到一个<code class="fe oc od oe of b">opt</code>目录中，所以要获取代码，必须从<code class="fe oc od oe of b">opt/nodejs/&lt;your filename&gt;</code>中获取。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oh oi l"/></div></figure><p id="e02c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">您想要导入的每个文件都可以是自己的<code class="fe oc od oe of b">require</code>语句。您还可以让文件在功能层中相互引用。您可以在解决方案的<code class="fe oc od oe of b"><a class="ae ky" href="https://github.com/allenheltondev/aws-lambda-layer-types/blob/master/layers/nodejs/database.js" rel="noopener ugc nofollow" target="_blank">database.js</a></code>文件中看到一个例子。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="c2b5" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">需要注意的事项</h1><p id="71ac" class="pw-post-body-paragraph kz la it lb b lc nk ju le lf nl jx lh li nm lk ll lm nn lo lp lq no ls lt lu im bi translated">Lambda层很棒，但是有一些事情需要注意。</p><ul class=""><li id="f704" class="mv mw it lb b lc ld lf lg li mx lm my lq mz lu na nb nc nd bi translated"><strong class="lb iu">您不能在本地从另一个微服务导入层</strong> —如果您在推入云之前在本地进行测试，您不能通过导入下载层并期望它工作。这是目前分层过程中的一个缺口。如果图层位于您正在使用的服务中，则一切正常。</li><li id="39d8" class="mv mw it lb b lc ne lf nf li ng lm nh lq ni lu na nb nc nd bi translated"><strong class="lb iu"> SAM不构建层</strong> —您必须在CI/CD管道中的每个层上手动安装npm。SAM将为您打包并部署一个构建层，但它不进行构建。</li></ul></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="79b7" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">结论</h1><p id="ec4f" class="pw-post-body-paragraph kz la it lb b lc nk ju le lf nl jx lh li nm lk ll lm nn lo lp lq no ls lt lu im bi translated">层对于共享代码和降低部署包大小非常有用。与创建自己的npm包相比，它们的重量更轻，也更容易维护。</p><p id="d237" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">请记住，它们最好与您的Lambdas在同一个微服务中使用，文件夹结构取决于您使用的运行时。</p><p id="7407" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">请随意使用我提供的示例，并将其变成您自己的示例。它使用了<a class="ae ky" href="https://medium.com/better-programming/you-should-open-up-that-api-youve-been-working-on-b0313a4df9bc" rel="noopener"> Open API 3.0 </a>和新的<a class="ae ky" href="https://medium.com/better-programming/how-to-migrate-your-rest-api-to-the-new-http-api-in-aws-2e986c326ce0" rel="noopener"> AWS HTTP API </a>。保持您的技能敏锐，并与AWS无服务器技术堆栈中的最新和最棒的技术保持同步。</p><p id="c15b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">#每天都变聪明</p></div></div>    
</body>
</html>