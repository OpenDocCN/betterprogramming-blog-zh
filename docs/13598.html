<html>
<head>
<title>How to Implement a Library in Golang</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何用Golang实现一个库</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/how-to-implement-a-shared-library-in-golang-eeaf466de9fd?source=collection_archive---------2-----------------------#2022-09-11">https://betterprogramming.pub/how-to-implement-a-shared-library-in-golang-eeaf466de9fd?source=collection_archive---------2-----------------------#2022-09-11</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="638d" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">理解依赖管理和变更控制之间的权衡</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/4136d0be3fe59c6aae418b73b556e5d3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*beuF2KT4m4WQXoos"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">在<a class="ae kv" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上由<a class="ae kv" href="https://unsplash.com/@jareddc?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Jaredd Craig </a>拍照</p></figure><p id="9c30" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">当你踏入软件世界的第一步，几乎不可能不碰到<a class="ae kv" href="https://en.wikipedia.org/wiki/Don%27t_repeat_yourself" rel="noopener ugc nofollow" target="_blank">干</a>这个名词(不要重复自己)。这是因为我们使用了函数、抽象等等。，不要在我们的项目中重复自己。然而，这种想法在每种情况下都有效吗？</p><p id="0426" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">例如，考虑系统的两个不同部分。它们有完全不同的业务逻辑，但是在不同的环境中使用相同的功能来解决不同的问题。这样，我们应该在这些不同的部分使用共享库来防止代码重复吗？如果你的答案是“是”，你需要在阅读这篇文章的时候再想想你的答案。</p><p id="158f" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在这两个部分中使用相同的库增加了依赖性和<a class="ae kv" href="https://en.wikipedia.org/wiki/Coupling_(computer_programming)" rel="noopener ugc nofollow" target="_blank">耦合性</a>。这是因为它们有不同的业务逻辑，它们可以根据业务环境的需要独立进化。太棒了。您减少了代码行，但是增加了耦合和维护成本。</p><blockquote class="ls lt lu"><p id="0c27" class="kw kx lv ky b kz la jr lb lc ld ju le lw lg lh li lx lk ll lm ly lo lp lq lr ij bi translated">耦合是对两个组件相互了解和依赖程度的度量。耦合度越高，依赖性越强。松散耦合指的是不同的组件之间相互了解很少，而组件之间没有耦合，它们完全不知道彼此的存在。<a class="ae kv" href="https://www.amazon.com/Scalability-Startup-Engineers-Artur-Ejsmont/dp/0071843655" rel="noopener ugc nofollow" target="_blank">【1】</a></p></blockquote><p id="56c1" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">由于耦合和依赖问题，在分布式架构中，著名的原则是<a class="ae kv" rel="noopener ugc nofollow" target="_blank" href="/when-dry-doesnt-work-go-wet-6befda0444bf"> WET </a>(每次都写或者所有内容都写两次)。WET的关键点是减少共享代码的数量。然而，完全防止代码重用是不可能的。因此，一些技术被用于管理分布式系统中的代码重用。</p><p id="159e" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">今天，我将基于<a class="ae kv" href="https://www.amazon.com/Software-Architecture-Trade-Off-Distributed-Architectures/dp/1492086894" rel="noopener ugc nofollow" target="_blank">软件架构的《分布式架构的硬部件现代权衡分析》一书来谈论这些技术中的一种——共享库。</a></p><h1 id="f480" class="lz ma iq bd mb mc md me mf mg mh mi mj jw mk jx ml jz mm ka mn kc mo kd mp mq bi translated">共享库</h1><p id="2d8a" class="pw-post-body-paragraph kw kx iq ky b kz mr jr lb lc ms ju le lf mt lh li lj mu ll lm ln mv lp lq lr ij bi translated">尽管共享库有助于我们管理代码重用，但它也有一些缺点。当我们使用共享库时，我们需要考虑<em class="lv">依赖管理</em>和<em class="lv">变更控制</em>。</p><p id="2071" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们通过两个用例来理解依赖管理和变更控制之间的权衡。</p><p id="7bc7" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在第一种情况下，有五个服务使用同一个共享库。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi mw"><img src="../Images/1799be9208808831af0def978ba28010.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*TqSUfA5T8qhB71EXV0zVJw.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">图:一个自定义共享库</p></figure><ul class=""><li id="c4a0" class="mx my iq ky b kz la lc ld lf mz lj na ln nb lr nc nd ne nf bi translated">当共享库发生变化时，每个服务最终都必须采用这种变化，因为库的版本会随着时间的推移而降低。在这种情况下，我们必须在每次更改时重新测试和部署我们的应用程序。我们需要确定是否有任何不推荐使用的功能。应用程序可以使用不同的版本；然而，当这个版本被否决，我们的服务将不再工作。</li><li id="6251" class="mx my iq ky b kz ng lc nh lf ni lj nj ln nk lr nc nd ne nf bi translated">另一个缺点是当由于服务需求而改变库时。结果，我们失去了库的通用性，最终，它包含了其他服务的混乱和不相关的代码块。这不是我们想要的。</li></ul><p id="0ef9" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在第二种情况下，我们有五个服务和四个不同的共享库。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nl"><img src="../Images/1c166f47d9617cf64a3a32a74e6f7db2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*o1A00xAtisVxMVGPe-EPbA.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">图:多个自定义共享库</p></figure><p id="2e61" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这些不同的服务使用不同的库。看起来很乱，对吧？正如您所猜测的，在这种情况下，依赖性管理变得很困难，因为与前面的例子相比，我们的服务依赖于不止一个库:<em class="lv">共享库越多，依赖性就越强。</em></p><p id="66d3" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">另一方面，变更控制和可维护性变得更加易于管理。</p><p id="2514" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">然而，不要忘记，分享总是会增加我们决定分享的东西的耦合度:在这两种情况下，耦合度和依赖性都会增加。</p><p id="e80b" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">尽管对共享库有各种各样的批评，但有时它对技术目的是有益的。例如，如果我们过多地使用RabbitMQ SDK，我们可以编写它的包装器，并将其功能提取到一个库中，我们可以使用这个库来提供服务。</p><p id="0f0d" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">让我们看看如何使用Golang来实现这个功能。</p><h1 id="f8fb" class="lz ma iq bd mb mc md me mf mg mh mi mj jw mk jx ml jz mm ka mn kc mo kd mp mq bi translated">创建库</h1><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nm nn l"/></div></figure><p id="646e" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们需要创建一个带有适当版本的标签来共享这段代码。</p><h1 id="a56b" class="lz ma iq bd mb mc md me mf mg mh mi mj jw mk jx ml jz mm ka mn kc mo kd mp mq bi translated">创建版本和标签</h1><p id="4b70" class="pw-post-body-paragraph kw kx iq ky b kz mr jr lb lc ms ju le lf mt lh li lj mu ll lm ln mv lp lq lr ij bi translated">要创建一个版本，我们需要遵守行业标准。一个流行的版本标准是<a class="ae kv" href="https://semver.org/" rel="noopener ugc nofollow" target="_blank"> <strong class="ky ir">语义版本</strong> </a>。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi no"><img src="../Images/8c4f65061e33a9e1aac64d5372c7c362.png" data-original-src="https://miro.medium.com/v2/resize:fit:1090/format:webp/1*x_ChpjXCLO6HCAa_8s8crg.png"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">图:语义版本化</p></figure><p id="67e1" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">您可以查看文档以了解主要版本、次要版本和补丁以及它们的使用方法。</p><p id="a87b" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在实现阶段，我做到了这一点，如下所示:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi np"><img src="../Images/9bba7599759da7722de2b76093d36088.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*3Y_I0RmboenymGu2P-_h_w.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">图:语义版本化的实现</p></figure><h1 id="bba2" class="lz ma iq bd mb mc md me mf mg mh mi mj jw mk jx ml jz mm ka mn kc mo kd mp mq bi translated">使用库</h1><p id="dfb8" class="pw-post-body-paragraph kw kx iq ky b kz mr jr lb lc ms ju le lf mt lh li lj mu ll lm ln mv lp lq lr ij bi translated">首先，我们需要使用<code class="fe nq nr ns nt b">go get</code>安装这个共享库。之后，我们必须在我们的项目中导入我们的库，如下所示。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nm nn l"/></div></figure><p id="5821" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">ℹ️如果你想测试你的库而不发布它，你可以使用<code class="fe nq nr ns nt b">replace</code>指令。为此，您需要打开服务的go mod文件并编写:</p><pre class="kg kh ki kj gt nu nt nv nw aw nx bi"><span id="f577" class="ny ma iq nt b gy nz oa l ob oc">replace github.com/dilaragorum/calculations v1.3.1 =&gt; directory of your project</span></pre><h1 id="51d2" class="lz ma iq bd mb mc md me mf mg mh mi mj jw mk jx ml jz mm ka mn kc mo kd mp mq bi translated">额外收获:在Github动作中添加lint</h1><p id="840e" class="pw-post-body-paragraph kw kx iq ky b kz mr jr lb lc ms ju le lf mt lh li lj mu ll lm ln mv lp lq lr ij bi translated">如果你在GitHub 中查看我们的库<a class="ae kv" href="https://github.com/dilaragorum/rabbitmq-sdk/blob/master/.github/workflows/golangci-lint.yml" rel="noopener ugc nofollow" target="_blank">，你会看到一个只有一个步骤的管道，叫做lint。要在GitHub的CI中实现lint，可以看</a><a class="ae kv" href="https://golangci-lint.run/usage/install#github-actions" rel="noopener ugc nofollow" target="_blank">文档</a>。</p><h1 id="acb1" class="lz ma iq bd mb mc md me mf mg mh mi mj jw mk jx ml jz mm ka mn kc mo kd mp mq bi translated">源代码</h1><div class="od oe gp gr of og"><a href="https://github.com/dilaragorum/rabbitmq-sdk" rel="noopener  ugc nofollow" target="_blank"><div class="oh ab fo"><div class="oi ab oj cl cj ok"><h2 class="bd ir gy z fp ol fr fs om fu fw ip bi translated">GitHub-dilaragorum/rabbit MQ-SDK</h2><div class="on l"><h3 class="bd b gy z fp ol fr fs om fu fw dk translated">此时您不能执行该操作。您已使用另一个标签页或窗口登录。您已在另一个选项卡中注销，或者…</h3></div><div class="oo l"><p class="bd b dl z fp ol fr fs om fu fw dk translated">github.com</p></div></div><div class="op l"><div class="oq l or os ot op ou kp og"/></div></div></a></div><p id="7541" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">感谢您的阅读。</p></div></div>    
</body>
</html>