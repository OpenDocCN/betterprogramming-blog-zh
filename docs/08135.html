<html>
<head>
<title>2 iOS Tools To Detect Dead and Cloned Code</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">2个iOS工具，用于检测死代码和克隆代码</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/2-ios-tools-to-detect-dead-and-cloned-code-a4401b33d7ec?source=collection_archive---------6-----------------------#2021-03-30">https://betterprogramming.pub/2-ios-tools-to-detect-dead-and-cloned-code-a4401b33d7ec?source=collection_archive---------6-----------------------#2021-03-30</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="2c06" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">消除代码库中的代码味道</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/5cce0a46bf31b2ee9d2a8a800ffad660.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*OskSGdaUazT-GtrI"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">诺贝特·莱瓦西奇斯在<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片。</p></figure><p id="1d54" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在发布一个项目后，我们想要添加新功能，A/B测试一些其他功能，并删除不再有意义的旧功能。</p><p id="0e69" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">所有这些干预都属于一个项目的<a class="ae ky" href="https://en.wikipedia.org/wiki/Software_evolution#Types_of_software_maintenance" rel="noopener ugc nofollow" target="_blank">演进过程</a>。它们属于<em class="lv">适应性维护</em>和<em class="lv">完美维护</em>类别。在其他一些情况下，我们需要干预来修复影响用户的bug。这种干预属于<em class="lv">纠正性维护</em>范围。</p><p id="9db4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">所有这些变化有什么共同点？都是改变代码库的维护干预。他们可以引入新的代码片段，或者禁用我们不再需要的代码片段。</p><p id="6dc9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这些变化的一个潜在影响是引入了两种我们希望尽可能避免的<a class="ae ky" href="https://en.wikipedia.org/wiki/Code_smell" rel="noopener ugc nofollow" target="_blank">代码气味</a>:</p><ul class=""><li id="6af3" class="lw lx it lb b lc ld lf lg li ly lm lz lq ma lu mb mc md me bi translated"><a class="ae ky" href="https://en.wikipedia.org/wiki/Dead_code" rel="noopener ugc nofollow" target="_blank">死代码</a>:无法在我们的代码库中执行的代码片段，因为它们不再可达。</li><li id="a175" class="lw lx it lb b lc mf lf mg li mh lm mi lq mj lu mb mc md me bi translated"><a class="ae ky" href="https://en.wikipedia.org/wiki/Duplicate_code" rel="noopener ugc nofollow" target="_blank">重复代码</a>:多段(几乎)相同的代码在不同的文件或行中重复。它们通常是复制粘贴其他代码行的结果。</li></ul><p id="fb7f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">死代码的主要结果是一个被污染的代码库，我们不确定为什么会有特定的代码片段。我们可能想把代码放在那里，因为可能有东西在使用它。</p><p id="4e4a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">重复代码的味道是一个更严重的问题。这使得代码难以维护。如果重复的代码有一个bug，我们需要在所有使用它的地方修复它。这使得在代码库上工作成为一场噩梦。</p><p id="f879" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">今天，我想向您展示几个工具，我们可以用它们来半自动地检测和消除这些代码气味。</p></div><div class="ab cl mk ml hx mm" role="separator"><span class="mn bw bk mo mp mq"/><span class="mn bw bk mo mp mq"/><span class="mn bw bk mo mp"/></div><div class="im in io ip iq"><h1 id="e0fb" class="mr ms it bd mt mu mv mw mx my mz na nb jz nc ka nd kc ne kd nf kf ng kg nh ni bi translated">边缘</h1><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi nj"><img src="../Images/39d7a7f53b98f81a40648143140bc2af.png" data-original-src="https://miro.medium.com/v2/resize:fit:578/format:webp/1*Jo7KjUPYaBePkf62KI0OQA.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">图片来自<a class="ae ky" href="https://github.com/peripheryapp/periphery" rel="noopener ugc nofollow" target="_blank"> GitHub </a>。</p></figure><p id="90c0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">外围设备是一个识别应用程序中未使用代码的工具。</p><p id="b481" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">它非常智能，不仅能够检测未使用的函数，还能够检测结构、枚举，甚至是函数签名中声明的、在函数体中没有使用的参数！</p><h2 id="ac1c" class="nk ms it bd mt nl nm dn mx nn no dp nb li np nq nd lm nr ns nf lq nt nu nh nv bi translated">配置</h2><p id="5ca4" class="pw-post-body-paragraph kz la it lb b lc nw ju le lf nx jx lh li ny lk ll lm nz lo lp lq oa ls lt lu im bi translated">我们可以利用<code class="fe ob oc od oe b">brew</code>在我们的机器上安装外围设备的二进制文件。运行以下命令:</p><pre class="kj kk kl km gt of oe og oh aw oi bi"><span id="8833" class="nk ms it oe b gy oj ok l ol om">brew tap peripheryapp/periphery<br/>brew install periphery</span></pre><p id="8169" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">第一个命令将<code class="fe ob oc od oe b">peripheryapp/periphery</code> tap添加到我们已知的tap列表中。第二个命令实际上是安装外围设备。</p><p id="ad41" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">安装完成后，我们需要对其进行配置。外围设备附带了一个交互式过程，允许您为项目创建适当的配置。我们可以简单地运行以下命令来初始化该过程:</p><pre class="kj kk kl km gt of oe og oh aw oi bi"><span id="1853" class="nk ms it oe b gy oj ok l ol om">periphery scan --verbose --setup</span></pre><p id="fbd6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe ob oc od oe b">--verbose</code>标志很重要，因为启用该标志后，外围设备将在交互配置之后、开始构建我们的项目之前打印一个<code class="fe ob oc od oe b">yaml</code>文件。一旦这些配置在控制台中打印出来，我们可以将它们复制并粘贴到一个<code class="fe ob oc od oe b">.periphery.yaml</code>配置文件中:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="on oo l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">. periphery.yaml文件的示例。如果您想手动填充它，请随意直接复制它，这样您就可以避免经历引导式设置！</p></figure><p id="d59f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe ob oc od oe b">--setup</code>标志用于启动交互配置。如果我们需要多次运行外围设备<strong class="lb iu"> </strong>并且我们已经有了<code class="fe ob oc od oe b">yaml</code>文件，我们可以省略<code class="fe ob oc od oe b">--setup</code>标志。</p><h2 id="4eac" class="nk ms it bd mt nl nm dn mx nn no dp nb li np nq nd lm nr ns nf lq nt nu nh nv bi translated">使用</h2><p id="6cf5" class="pw-post-body-paragraph kz la it lb b lc nw ju le lf nx jx lh li ny lk ll lm nz lo lp lq oa ls lt lu im bi translated">在第一次配置运行之后，我们可以通过运行以下命令来使用该工具:</p><pre class="kj kk kl km gt of oe og oh aw oi bi"><span id="786b" class="nk ms it oe b gy oj ok l ol om">periphery scan</span></pre><p id="b61b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我准备了一个示例项目，在这个项目上我运行了peripheral<strong class="lb iu"/>来向您展示一个示例输出。我们可以在下图中观察到它:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi op"><img src="../Images/fe25d142a4a04184f5a94aac11376301.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*iAMDGqkOCYiFJbwMY_oE-A.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">外围样本输出</p></figure><p id="25e0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">从工具的输出开始，我们可以探索我们的代码库，并验证已经发现的内容是否实际上没有被代码使用。大多数时候，工具是准确的。外围发现的死代码可以安全删除！</p><p id="fdc9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们很少出现一些假阳性。这是由于一些协议扩展的默认实现，该工具很难检测到使用，或者一些内部函数和对象，我们需要提高可测试性。</p><p id="02a7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">总的来说，拥有这样一个工具对于减少代码大小和确保我们没有一些未使用的代码并且可能潜伏几个月或几年是非常重要的。我们不想在两个月后回到我们的代码库，问自己为什么这个函数没有被调用，对吗？</p></div><div class="ab cl mk ml hx mm" role="separator"><span class="mn bw bk mo mp mq"/><span class="mn bw bk mo mp mq"/><span class="mn bw bk mo mp"/></div><div class="im in io ip iq"><h1 id="eaf9" class="mr ms it bd mt mu mv mw mx my mz na nb jz nc ka nd kc ne kd nf kf ng kg nh ni bi translated">复制粘贴检测器</h1><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi oq"><img src="../Images/100bbe5902360a60082c02a7d48b0216.png" data-original-src="https://miro.medium.com/v2/resize:fit:720/format:webp/1*jELaHRZ6bUher88yYr_Mvw.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">照片来自<a class="ae ky" href="https://pmd.github.io/latest/pmd_userdocs_cpd.html" rel="noopener ugc nofollow" target="_blank"> PMD的文件</a>。</p></figure><p id="0e87" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><a class="ae ky" href="https://pmd.github.io/latest/pmd_userdocs_cpd.html" rel="noopener ugc nofollow" target="_blank">复制粘贴检测器</a> (CPD) <strong class="lb iu"> </strong>是一个可以用来检测我们代码库中复制代码的工具。它属于<a class="ae ky" href="https://en.wikipedia.org/wiki/PMD_(software)" rel="noopener ugc nofollow" target="_blank">编程错误检测器</a> (PMD)套件。</p><h2 id="6c53" class="nk ms it bd mt nl nm dn mx nn no dp nb li np nq nd lm nr ns nf lq nt nu nh nv bi translated">装置</h2><p id="02c0" class="pw-post-body-paragraph kz la it lb b lc nw ju le lf nx jx lh li ny lk ll lm nz lo lp lq oa ls lt lu im bi translated">这个工具是用Java编写的。因此，安装时需要做一些额外的工作:</p><ol class=""><li id="c6e1" class="lw lx it lb b lc ld lf lg li ly lm lz lq ma lu or mc md me bi translated">下载并安装<a class="ae ky" href="https://www.java.com/en/download/" rel="noopener ugc nofollow" target="_blank"> Java 8 for Mac </a>。</li><li id="844d" class="lw lx it lb b lc mf lf mg li mh lm mi lq mj lu or mc md me bi translated">从<a class="ae ky" href="https://github.com/pmd/pmd/releases" rel="noopener ugc nofollow" target="_blank"> GitHub发布页面</a>下载该工具。</li><li id="f5cc" class="lw lx it lb b lc mf lf mg li mh lm mi lq mj lu or mc md me bi translated">解压存档文件。</li><li id="30ad" class="lw lx it lb b lc mf lf mg li mh lm mi lq mj lu or mc md me bi translated">在终端中，运行<code class="fe ob oc od oe b">open /usr/local</code>。</li><li id="ff2a" class="lw lx it lb b lc mf lf mg li mh lm mi lq mj lu or mc md me bi translated">将解压后的档案文件中的<code class="fe ob oc od oe b">lib</code>文件夹复制到<code class="fe ob oc od oe b">/usr/local/</code>路径的<code class="fe ob oc od oe b">lib</code>文件夹中。</li><li id="5d77" class="lw lx it lb b lc mf lf mg li mh lm mi lq mj lu or mc md me bi translated">将解压后的档案中的<code class="fe ob oc od oe b">bin</code>文件夹复制到<code class="fe ob oc od oe b">/usr/local/</code>路径的<code class="fe ob oc od oe b">bin</code>文件夹中。注意:您应该将<code class="fe ob oc od oe b">run.sh</code>文件的名称改为更有意义的名称。</li></ol><p id="ede5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">完成这些步骤后，我们可以在终端的任何位置键入<code class="fe ob oc od oe b">run.sh</code>(或者您在步骤6中选择的名称)来执行我们的工具。</p><h2 id="e6ae" class="nk ms it bd mt nl nm dn mx nn no dp nb li np nq nd lm nr ns nf lq nt nu nh nv bi translated">使用</h2><p id="4b6b" class="pw-post-body-paragraph kz la it lb b lc nw ju le lf nx jx lh li ny lk ll lm nz lo lp lq oa ls lt lu im bi translated">要使用该工具，我们需要导航至Swift项目的根文件夹。</p><p id="b4e2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">然后，我们需要发出以下命令:</p><pre class="kj kk kl km gt of oe og oh aw oi bi"><span id="00dd" class="nk ms it oe b gy oj ok l ol om">run.sh cpd --minimum-tokens &lt;N&gt; --files . --language swift</span></pre><p id="90b9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe ob oc od oe b">--minimum-tokens</code>和<code class="fe ob oc od oe b">--files</code>参数是强制性的。前者要求我们指定一个数字。这是被视为重复代码的两个片段之间需要相等的令牌数。一个<a class="ae ky" href="https://en.wikipedia.org/wiki/Lexical_analysis#Token" rel="noopener ugc nofollow" target="_blank">标记</a>是一种编程语言的单一元素。下面一行:</p><pre class="kj kk kl km gt of oe og oh aw oi bi"><span id="424d" class="nk ms it oe b gy oj ok l ol om">if list.isEmpty {</span></pre><p id="bb24" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">由五个令牌组成:<code class="fe ob oc od oe b">if</code>、<code class="fe ob oc od oe b">list</code>、<code class="fe ob oc od oe b">.</code>、<code class="fe ob oc od oe b">isEmpty</code>和<code class="fe ob oc od oe b">{</code>。</p><p id="e338" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">与外围设备不同，这个工具需要一点调整，然后我们才能有效地使用它。我们需要回答这个问题:我们需要多少个重复的记号才能认为一个片段是重复的？</p><p id="d26d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">令牌数量越少，CPD找到的重复数量就越多。一个好的权衡应该在20到50之间。这允许我们发现可以在函数中提取并重用的代码片段。</p><p id="2e8b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果我们指定一个文件夹作为<code class="fe ob oc od oe b">--files</code>选项的参数，工具会递归运行。因此，通过指定<code class="fe ob oc od oe b">.</code>文件夹，它将在每个子文件夹中运行，分析所有包含指定语言代码的文件。</p><p id="afac" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">CLI工具接受更多的<a class="ae ky" href="https://pmd.github.io/latest/pmd_userdocs_cpd.html#cli-options-reference" rel="noopener ugc nofollow" target="_blank">参数</a>，让我们定制它的行为。探索并使用它们，直到找到最佳配置。</p><p id="7b41" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我在测试项目中运行该工具，向您展示输出结果:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi os"><img src="../Images/d17ccc02751cb6e5106dc0cecd3ea949.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*hO7u_bIoJchUmZq1AaRXXg.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">CPD的示例输出，它能够找到我复制粘贴按钮声明和setTitle调用的位置。</p></figure><p id="47fb" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">一旦我们有了输出，我们就可以导航到适当的位置，并决定在适当的函数中重构代码以重用它。</p></div><div class="ab cl mk ml hx mm" role="separator"><span class="mn bw bk mo mp mq"/><span class="mn bw bk mo mp mq"/><span class="mn bw bk mo mp"/></div><div class="im in io ip iq"><h1 id="2c02" class="mr ms it bd mt mu mv mw mx my mz na nb jz nc ka nd kc ne kd nf kf ng kg nh ni bi translated">结论</h1><p id="f7ff" class="pw-post-body-paragraph kz la it lb b lc nw ju le lf nx jx lh li ny lk ll lm nz lo lp lq oa ls lt lu im bi translated">在今天的文章中，我们探索了一些工具，它们可以从我们的代码库中删除一些死的和重复的代码。这些工具通过减少可能在我们的代码库中变得陈旧的代码片段，并通过提高我们的代码质量，帮助维护我们开发团队的健全。</p><p id="feb6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">幸运的是，我们不会每天都在代码库中引入死代码和重复代码。这些工具可以偶尔运行一次，可能每3-6个月运行一次。一个好的做法可能是计划家务冲刺。团队可以计划一些时间来重构代码，处理积压的一些任务，并运行这些工具来消除这些代码气味。</p></div></div>    
</body>
</html>