<html>
<head>
<title>Injecting Android ViewModels With Dagger2 in a Clean Architecture</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">在干净的架构中注入带有Dagger2的Android视图模型</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/injecting-android-viewmodels-with-dagger2-in-clean-architecture-744c1fe81530?source=collection_archive---------0-----------------------#2021-03-17">https://betterprogramming.pub/injecting-android-viewmodels-with-dagger2-in-clean-architecture-744c1fe81530?source=collection_archive---------0-----------------------#2021-03-17</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="98e4" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">基于Dagger2的视图模型依赖注入框架</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/775867ad525fb9702ed1dabfa2a2d458.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*7WjWrUHnMMyFH4sw"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">Muhammad Rosyid Izzulkhaq 在<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片。</p></figure><p id="ce36" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这是关于使用合适的干净架构构建Android应用程序的系列文章的第三部分。在这一部分，我们将关注<code class="fe lv lw lx ly b">ViewModels</code>和他们的依赖注入框架。</p><p id="05ed" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在继续之前，我强烈推荐阅读本系列的前几部分:</p><ul class=""><li id="3038" class="lz ma it lb b lc ld lf lg li mb lm mc lq md lu me mf mg mh bi translated"><a class="ae ky" rel="noopener ugc nofollow" target="_blank" href="/how-to-set-up-a-dependency-injection-framework-with-dagger2-in-android-aa23ee9299db">《Android的清洁架构教程(上)》:如何用Dagger2建立复杂的DI结构</a>。</li><li id="8e47" class="lz ma it lb b lc mi lf mj li mk lm ml lq mm lu me mf mg mh bi translated"><a class="ae ky" rel="noopener ugc nofollow" target="_blank" href="/creating-a-repository-data-layer-with-kotlin-coroutines-in-android-1375ab79b6f0">“Android的干净架构教程(第2部分)”:使用协程创建存储库和用例</a>。</li><li id="b228" class="lz ma it lb b lc mi lf mj li mk lm ml lq mm lu me mf mg mh bi translated">《Android的干净架构教程(第三部分)》:你来了。</li></ul><p id="54be" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">今天，我们将学习如何在clean architecture中使用<code class="fe lv lw lx ly b">ViewModel</code>，并使用<a class="ae ky" href="https://dagger.dev/" rel="noopener ugc nofollow" target="_blank"> Dagger2 </a>构建一个依赖注入框架，以便我们可以快速将它们注入到像<code class="fe lv lw lx ly b">Activities</code>和<code class="fe lv lw lx ly b">Fragments</code>这样的Android组件中。</p><p id="b8e8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在开始使用<code class="fe lv lw lx ly b">ViewModels</code>之前，我们应该问自己为什么要使用一个<code class="fe lv lw lx ly b">ViewModel</code>。答案很简单:关注点分离(SoC)。这使得应用程序可维护、可扩展和可测试。</p><p id="f562" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">不过，这可以通过演示者来完成。为什么要用<code class="fe lv lw lx ly b">ViewModel</code>？首先，<code class="fe lv lw lx ly b">ViewModel</code>可以经受住配置的变化。仅这一点就可以解决许多由于组件停止而导致的常规错误。如果你有兴趣了解更多关于<code class="fe lv lw lx ly b">ViewModels</code>的信息，我强烈推荐你阅读下面这篇文章:</p><div class="mn mo gp gr mp mq"><a rel="noopener  ugc nofollow" target="_blank" href="/best-practices-for-using-viewmodels-in-android-e986b25dc78f"><div class="mr ab fo"><div class="ms ab mt cl cj mu"><h2 class="bd iu gy z fp mv fr fs mw fu fw is bi translated">在Android中使用视图模型的最佳实践</h2><div class="mx l"><h3 class="bd b gy z fp mv fr fs mw fu fw dk translated">如何正确设置和使用Java和Kotlin视图模型</h3></div><div class="my l"><p class="bd b dl z fp mv fr fs mw fu fw dk translated">better编程. pub</p></div></div><div class="mz l"><div class="na l nb nc nd mz ne ks mq"/></div></div></a></div></div><div class="ab cl nf ng hx nh" role="separator"><span class="ni bw bk nj nk nl"/><span class="ni bw bk nj nk nl"/><span class="ni bw bk nj nk"/></div><div class="im in io ip iq"><h1 id="a8c2" class="nm nn it bd no np nq nr ns nt nu nv nw jz nx ka ny kc nz kd oa kf ob kg oc od bi translated">综合</h1><p id="2a6b" class="pw-post-body-paragraph kz la it lb b lc oe ju le lf of jx lh li og lk ll lm oh lo lp lq oi ls lt lu im bi translated">要将<code class="fe lv lw lx ly b">ViewModel</code>架构组件集成到您的项目中，请在应用程序级<code class="fe lv lw lx ly b">gradle</code>文件中的<code class="fe lv lw lx ly b">dependency</code>标签下添加以下库:</p><pre class="kj kk kl km gt oj ly ok ol aw om bi"><span id="94a9" class="on nn it ly b gy oo op l oq or">/* Viewmodel */<br/>implementation <strong class="ly iu">“androidx.lifecycle:lifecycle-viewmodel-ktx:2.3.0”</strong></span></pre></div><div class="ab cl nf ng hx nh" role="separator"><span class="ni bw bk nj nk nl"/><span class="ni bw bk nj nk nl"/><span class="ni bw bk nj nk"/></div><div class="im in io ip iq"><h1 id="e6dc" class="nm nn it bd no np nq nr ns nt nu nv nw jz nx ka ny kc nz kd oa kf ob kg oc od bi translated">创建视图模型</h1><p id="b823" class="pw-post-body-paragraph kz la it lb b lc oe ju le lf of jx lh li og lk ll lm oh lo lp lq oi ls lt lu im bi translated">既然我们知道了为什么要使用<code class="fe lv lw lx ly b">ViewModel</code>并将其集成到项目中，下一步就是创建一个<code class="fe lv lw lx ly b">ViewModel</code>。这是最简单的任务。我们只需要创建一个名为<code class="fe lv lw lx ly b">SampleViewmodel</code>的Kotlin类(例如)并用<code class="fe lv lw lx ly b">ViewModel</code>扩展它。看一看:</p><pre class="kj kk kl km gt oj ly ok ol aw om bi"><span id="eca1" class="on nn it ly b gy oo op l oq or">class SampleViewmodel : ViewModel() {</span><span id="e3c8" class="on nn it ly b gy os op l oq or">}</span></pre></div><div class="ab cl nf ng hx nh" role="separator"><span class="ni bw bk nj nk nl"/><span class="ni bw bk nj nk nl"/><span class="ni bw bk nj nk"/></div><div class="im in io ip iq"><h1 id="0790" class="nm nn it bd no np nq nr ns nt nu nv nw jz nx ka ny kc nz kd oa kf ob kg oc od bi translated">视图模型注入框架</h1><p id="2c58" class="pw-post-body-paragraph kz la it lb b lc oe ju le lf of jx lh li og lk ll lm oh lo lp lq oi ls lt lu im bi translated">在不使用任何依赖注入逻辑的情况下，我们可以通过向<code class="fe lv lw lx ly b">ViewModelProvider</code>提供<code class="fe lv lw lx ly b">ViewModel</code>类对象，在Android组件中创建一个<code class="fe lv lw lx ly b">ViewModel</code>实例对象。这将生成绑定到在<code class="fe lv lw lx ly b">ViewModelProvider</code>构造函数中传递的上下文的<code class="fe lv lw lx ly b">ViewModel</code>实例。看一看:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ot ou l"/></div></figure><p id="a2ef" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">内部发生的情况是，每次我们请求时，它都会创建一个新的<code class="fe lv lw lx ly b">ViewModelFactory</code>实例，它负责创建我们的<code class="fe lv lw lx ly b">ViewModels</code>实例。</p><p id="861a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这个过程可能看起来不错，但实际上并不奏效。由于<code class="fe lv lw lx ly b">ViewModel</code> API的抽象工厂模式，我们不能在<code class="fe lv lw lx ly b">ViewModel</code>构造函数中传递任何参数。这意味着我们不能有参数化的<code class="fe lv lw lx ly b">ViewModel</code>。然而，这可以通过创建我们的<code class="fe lv lw lx ly b">ViewModelFactory</code>实现来解决。</p><p id="5089" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在<code class="fe lv lw lx ly b">di</code>下创建一个子包，然后创建一个名为<code class="fe lv lw lx ly b">ViewModelFactory</code>的新Kotlin类。然后用<code class="fe lv lw lx ly b">ViewModelProvider.Factory</code>扩展它并导入一个<code class="fe lv lw lx ly b">create</code>方法，我们将在其中比较对象并返回<code class="fe lv lw lx ly b">ViewModel</code>，如下所示:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ot ou l"/></div></figure><p id="f452" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在让我们看看如何用我们的自定义<code class="fe lv lw lx ly b">ViewModelFactory</code>类创建<code class="fe lv lw lx ly b">ViewModel</code>对象:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ot ou l"/></div></figure><p id="1b9e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在，这解决了参数化的<code class="fe lv lw lx ly b">ViewModel</code>构造函数的问题，这意味着我们可以使用Dagger2在<code class="fe lv lw lx ly b">ViewModel</code>构造函数中注入依赖关系。</p></div><div class="ab cl nf ng hx nh" role="separator"><span class="ni bw bk nj nk nl"/><span class="ni bw bk nj nk nl"/><span class="ni bw bk nj nk"/></div><div class="im in io ip iq"><h1 id="a289" class="nm nn it bd no np nq nr ns nt nu nv nw jz nx ka ny kc nz kd oa kf ob kg oc od bi translated">带Dagger的视图模型工厂2</h1><p id="9236" class="pw-post-body-paragraph kz la it lb b lc oe ju le lf of jx lh li og lk ll lm oh lo lp lq oi ls lt lu im bi translated">我们的<code class="fe lv lw lx ly b">ViewModelFactory</code>类实现完美地工作，但是它是一个优化的解决方案吗？可能不是因为我们已经为项目中的每个<code class="fe lv lw lx ly b">ViewModel</code>创建了一个新的<code class="fe lv lw lx ly b">ViewModelFactory</code>类。想象一下，在实时应用程序中，我们可能会有多少额外的类。</p><p id="a828" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">所以<code class="fe lv lw lx ly b">ViewModelFactory</code>类工作得很好，但是它需要一些修正来使它通用。这就是Dagger2库中的<code class="fe lv lw lx ly b">IntoMap</code>发挥作用的地方。</p><p id="6bde" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe lv lw lx ly b">IntoMap</code> API允许我们创建一个可以注入Android组件的对象图。</p><p id="099e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">为了使我们的<code class="fe lv lw lx ly b">ViewModelFactory</code>类通用，我们需要替换构造函数中的<code class="fe lv lw lx ly b">ViewModel</code>，用<code class="fe lv lw lx ly b">MutableMap-Class&lt;? extends ViewModel&gt;</code>作为键，用<code class="fe lv lw lx ly b">ViewModel</code>作为值(<code class="fe lv lw lx ly b">MutableMap&lt;Class&lt;? extends ViewModel&gt;, ViewModel&gt;</code>)。</p><p id="ea8b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在<code class="fe lv lw lx ly b">create</code>函数内部，我们不需要比较<code class="fe lv lw lx ly b">ViewModel</code>对象，而是需要使它成为一个通用的返回类型。看一看:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ot ou l"/></div></figure><p id="d65a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们已经使用了构造函数注入，所以可变映射应该由dagger提供。为此，我们必须创建一个名为<code class="fe lv lw lx ly b">ViewModelModule</code>的Kotlin抽象类，并用<code class="fe lv lw lx ly b">@Module</code>对其进行注释。这是负责提供<code class="fe lv lw lx ly b">mutablemap</code>到<code class="fe lv lw lx ly b">ViewModelFactory</code>的模块。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ot ou l"/></div></figure><p id="9d30" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">此时，如果您重新构建项目，dagger将抛出一个错误(类似于“<code class="fe lv lw lx ly b"><a class="ae ky" href="http://twitter.com/Binds" rel="noopener ugc nofollow" target="_blank">@Binds</a></code>map类型的方法必须声明一个map键”)。为了解决这个问题，我们可以使用匕首中的<code class="fe lv lw lx ly b">MapKey</code>。首先，我们需要创建一个名为<code class="fe lv lw lx ly b">ViewModelKey</code>类型为<code class="fe lv lw lx ly b">KClass&lt;out ViewModel&gt;</code>的Kotlin <code class="fe lv lw lx ly b">annotation</code>类，并添加必要的注释:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ot ou l"/></div></figure><p id="d20d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">然后我们需要在<code class="fe lv lw lx ly b">ViewModelModule</code>内部的函数上使用这个<code class="fe lv lw lx ly b">ViewModelKey</code>来提供映射键。看一看:</p><pre class="kj kk kl km gt oj ly ok ol aw om bi"><span id="e1bd" class="on nn it ly b gy oo op l oq or"><a class="ae ky" href="http://twitter.com/Binds" rel="noopener ugc nofollow" target="_blank">@Binds</a><br/><a class="ae ky" href="http://twitter.com/IntoMap" rel="noopener ugc nofollow" target="_blank">@IntoMap</a><br/><a class="ae ky" href="http://twitter.com/ViewModelKey" rel="noopener ugc nofollow" target="_blank">@ViewModelKey</a>(SampleViewmodel::class)<br/>abstract fun splashViewModel(viewModel: SampleViewmodel): ViewModel</span></pre><p id="42e8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">每次我们创建一个新的<code class="fe lv lw lx ly b">ViewModel</code>，我们都必须将它们包含在<code class="fe lv lw lx ly b">ViewModelModule</code>中，这样它们就可以被注入到Android组件中，并在构造函数中传递必要的依赖关系。</p></div><div class="ab cl nf ng hx nh" role="separator"><span class="ni bw bk nj nk nl"/><span class="ni bw bk nj nk nl"/><span class="ni bw bk nj nk"/></div><div class="im in io ip iq"><h1 id="4207" class="nm nn it bd no np nq nr ns nt nu nv nw jz nx ka ny kc nz kd oa kf ob kg oc od bi translated">视图模型构造函数中的依赖项</h1><p id="e122" class="pw-post-body-paragraph kz la it lb b lc oe ju le lf of jx lh li og lk ll lm oh lo lp lq oi ls lt lu im bi translated">现在我们已经完成了<code class="fe lv lw lx ly b">ViewModel</code>依赖注入框架，让我们看看如何进行构造函数注入，并将<code class="fe lv lw lx ly b">ViewModels</code>注入到类似<code class="fe lv lw lx ly b">Activities</code>和<code class="fe lv lw lx ly b">Fragments</code>的Android组件中。</p><p id="de2c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">首先，我们需要在<code class="fe lv lw lx ly b">ViewModel</code>类构造函数中使用<code class="fe lv lw lx ly b">@Inject</code>来注入所有必要的依赖项。在这种情况下，它是<code class="fe lv lw lx ly b">repository</code>。要了解关于存储库及其注入的更多信息，请参考本系列的第2部分。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ot ou l"/></div></figure><p id="87c0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">然后我们需要注入所需的<code class="fe lv lw lx ly b">ViewModel</code>。为此，我们需要注入我们的<code class="fe lv lw lx ly b">ViewModelFactory</code>类。然后，使用<code class="fe lv lw lx ly b">ViewModelProvider</code>，我们可以创建所需的<code class="fe lv lw lx ly b">ViewModel</code>对象。看一看:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ot ou l"/></div></figure></div><div class="ab cl nf ng hx nh" role="separator"><span class="ni bw bk nj nk nl"/><span class="ni bw bk nj nk nl"/><span class="ni bw bk nj nk"/></div><div class="im in io ip iq"><h1 id="8802" class="nm nn it bd no np nq nr ns nt nu nv nw jz nx ka ny kc nz kd oa kf ob kg oc od bi translated">奖金</h1><h2 id="e347" class="on nn it bd no ov ow dn ns ox oy dp nw li oz pa ny lm pb pc oa lq pd pe oc pf bi translated">GitHub回购</h2><p id="f157" class="pw-post-body-paragraph kz la it lb b lc oe ju le lf of jx lh li og lk ll lm oh lo lp lq oi ls lt lu im bi translated">导入项目并切换到<code class="fe lv lw lx ly b">branch articles/viewmodels</code>以查看与本文相关的代码:</p><div class="mn mo gp gr mp mq"><a href="https://github.com/SG-K/Clean-Architecture-Sample" rel="noopener  ugc nofollow" target="_blank"><div class="mr ab fo"><div class="ms ab mt cl cj mu"><h2 class="bd iu gy z fp mv fr fs mw fu fw is bi translated">SG-K/Clean-架构-示例</h2><div class="mx l"><h3 class="bd b gy z fp mv fr fs mw fu fw dk translated">在GitHub上创建一个帐户，为SG-K/Clean-Architecture-Sample开发做贡献。</h3></div><div class="my l"><p class="bd b dl z fp mv fr fs mw fu fw dk translated">github.com</p></div></div><div class="mz l"><div class="pg l nb nc nd mz ne ks mq"/></div></div></a></div><p id="7142" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">要了解有关高级Android开发和架构组件的更多信息，请阅读以下文章:</p><ul class=""><li id="9f4a" class="lz ma it lb b lc ld lf lg li mb lm mc lq md lu me mf mg mh bi translated"><a class="ae ky" rel="noopener ugc nofollow" target="_blank" href="/best-practices-for-using-viewmodels-in-android-e986b25dc78f">“在Android中使用视图模型的最佳实践”</a></li><li id="e1cc" class="lz ma it lb b lc mi lf mj li mk lm ml lq mm lu me mf mg mh bi translated"><a class="ae ky" rel="noopener ugc nofollow" target="_blank" href="/no-more-livedata-in-repositories-in-kotlin-85f5a234a8fe">“kot Lin的存储库中不再有live data”</a></li><li id="f187" class="lz ma it lb b lc mi lf mj li mk lm ml lq mm lu me mf mg mh bi translated"><a class="ae ky" rel="noopener ugc nofollow" target="_blank" href="/advanced-android-programming-with-kotlin-5e40b1be22bb">“使用Kotlin进行高级编程”</a></li><li id="af57" class="lz ma it lb b lc mi lf mj li mk lm ml lq mm lu me mf mg mh bi translated"><a class="ae ky" href="https://medium.com/android-dev-hacks/detailed-guide-on-android-clean-architecture-9eab262a9011" rel="noopener">《Android Clean架构详细指南》</a></li></ul><p id="8bcc" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">目前就这些。希望你学到了有用的东西。感谢阅读。</p></div></div>    
</body>
</html>