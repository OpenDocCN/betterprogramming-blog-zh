<html>
<head>
<title>9 Ways to Manipulate and Work With Components in React</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">React中操纵和使用组件的9种方式</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/9-ways-to-manipulate-and-work-with-components-in-react-cf0a7a2b194f?source=collection_archive---------12-----------------------#2020-04-02">https://betterprogramming.pub/9-ways-to-manipulate-and-work-with-components-in-react-cf0a7a2b194f?source=collection_archive---------12-----------------------#2020-04-02</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="4756" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">有许多不同的方式来处理您的组件</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/be44ae067ee6dc3737ef4831d2935314.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*gE47qH7sA89XOl3vBiHyog.jpeg"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">图片由PublicDomainPictures.net<a class="ae ky" href="https://www.needpix.com/photo/1469146/2-wooden-dancers-dancing-white-background-isolated-wood-gesture" rel="noopener ugc nofollow" target="_blank">的</a>彼得·席德莱茨基拍摄</p></figure><p id="9551" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这是一个web开发人员的大好时机——因为创新继续快速爆发，尤其是在JavaScript社区。</p><p id="1221" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><a class="ae ky" href="https://reactjs.org/" rel="noopener ugc nofollow" target="_blank"> React </a>是一个构建复杂用户界面的不可思议的库，如果您是React新手，那么这篇文章可能会帮助您了解它对web开发人员来说有多么强大。如果您不是React新手，那么您可能不会在这篇文章中发现任何新东西，但是，希望您可能会发现一些新东西，因为我将尝试展示使用React组件的新旧策略。</p><p id="fab9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在本文中，我们将介绍2020年操作和使用React组件的九种方式。</p><p id="ab7e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">事不宜迟，我们开始吧！</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="f72d" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">道具组件</h1><p id="d0a8" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">让现有组件重用其逻辑并将其传递到其他地方的许多方法之一是提供一种通过使用props将逻辑传递到自定义组件的方法。</p><p id="4c2b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">流行的React组件库如<a class="ae ky" href="https://github.com/mui-org/material-ui" rel="noopener ugc nofollow" target="_blank"> Material-UI </a>在它们提供的每个组件中都经常使用这种策略。</p><p id="7f22" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">有充分的理由说明为什么这是重用逻辑的好方法。</p><p id="df10" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果你想要一个例子，看看这个来自<a class="ae ky" href="https://www.gatsbyjs.org/" rel="noopener ugc nofollow" target="_blank"> Gatsby </a>应用的<code class="fe mz na nb nc b"><a class="ae ky" href="https://github.com/gatsbyjs/gatsby/blob/master/examples/simple-auth/src/components/PrivateRoute.js" rel="noopener ugc nofollow" target="_blank">PrivateRoute</a></code>组件。它是封装认证逻辑的简单组件。如果当前用户没有通过认证，它会将他们重定向到登录屏幕。否则，它将继续呈现从<code class="fe mz na nb nc b">props.component</code>接收的组件。</p><p id="fe6b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">因为它可以呈现从<code class="fe mz na nb nc b">props.component</code>传来的任何东西，所以它可以为您想要的任何组件重用认证逻辑。这使得使用路由逻辑成为一种简单而强大的方法。</p><p id="7adb" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">另外，你也可以传递一个表示HTML DOM元素的字符串，比如<code class="fe mz na nb nc b">div</code>或<code class="fe mz na nb nc b">span</code>，它仍然会将它呈现为一个组件，因为React <a class="ae ky" href="https://github.com/facebook/react/blob/master/packages/react/src/ReactElement.js#L146" rel="noopener ugc nofollow" target="_blank">内部调用</a> <code class="fe mz na nb nc b"><a class="ae ky" href="https://github.com/facebook/react/blob/master/packages/react/src/ReactElement.js#L146" rel="noopener ugc nofollow" target="_blank">React.createElement</a></code> <a class="ae ky" href="https://github.com/facebook/react/blob/master/packages/react/src/ReactElement.js#L146" rel="noopener ugc nofollow" target="_blank">，</a>将其作为元素<code class="fe mz na nb nc b">type</code>传递。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="4cfb" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">在一次调用中呈现元素、类组件或函数组件</h1><p id="e186" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">当描述你的用户界面应该是什么样子时，React dev团队推荐使用JSX。</p><p id="b75a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">但是不要忘记，使用JSX最终只是调用<code class="fe mz na nb nc b">React.createElement</code>的语法糖。因此值得一提的是，您也可以安全地使用<code class="fe mz na nb nc b">React.createElement</code>来创建您的组件。</p><p id="9b8b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在JSX上使用<code class="fe mz na nb nc b">React.createElement</code>有一些好处。</p><p id="f1f9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">其中最让我感兴趣的一个好处是，它让我重新开始编写普通的JavaScript，因为我们将重新使用函数。其他好处包括避免让React处理这个调用，并在一个代码块中访问所有实现细节，这样我们就避免了JavaScript必须执行的额外步骤。</p><p id="beae" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">react-final-form <a class="ae ky" href="https://github.com/final-form/react-final-form/blob/master/src/renderComponent.js" rel="noopener ugc nofollow" target="_blank">背后的团队广泛使用这个模式</a>作为工厂来创建他们的字段组件。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="0f57" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">用高阶组件劫持道具(HOC)</h1><p id="b583" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">高阶组件作为React中重用组件逻辑的一项高级技术，在过去也有过辉煌的一面。它们基本上是将一个React组件作为参数并返回一个全新组件的函数。</p><p id="a8aa" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">使用这种方法，您可以在不可见的中间层中覆盖和劫持组件的道具。这个中间层是更高阶组件的逻辑发生的地方。他们可以选择覆盖包装组件的道具或控制其呈现行为。</p><p id="2e78" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">为了演示这一点，我编写了一个基本的<code class="fe mz na nb nc b">withAuthValidation</code>高阶组件，它将作为输入(<code class="fe mz na nb nc b">DeactivatorInput</code>)传递，只对管理员用户可用。它首先将一个组件作为<code class="fe mz na nb nc b">props</code>，并执行一些认证逻辑。然后，如果用户没有通过认证，它会尝试禁用输入:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nd ne l"/></div></figure><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nf"><img src="../Images/fa92006a2720a34ae9caa9c2481075e8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*F6y-bCZ1Z7Dv_btq.jpg"/></div></div></figure></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="852e" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">使用渲染属性重用组件逻辑</h1><p id="c0c5" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">我仍然记得当<a class="ae ky" href="https://cdb.reacttraining.com/use-a-render-prop-50de598f11ce" rel="noopener ugc nofollow" target="_blank">的渲染道具第一次出现在屏幕上的时候</a>。它们很快在React社区中流行起来，并成为一种广泛采用的模式，通过组件重用代码逻辑。</p><p id="fce8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">使用这种模式可以解决高阶组件试图解决的相同问题。但是很多开发人员喜欢使用render prop模式有一个很好的原因:高阶组件引入了一个问题，你需要<a class="ae ky" href="https://reactjs.org/docs/higher-order-components.html#static-methods-must-be-copied-over" rel="noopener ugc nofollow" target="_blank">复制静态方法</a>。</p><p id="eec4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">render props受到很多人青睐的另一个原因是，你不会像对待高阶组件那样实例化一个新的组件实例。您只需要使用一个组件来实现该模式(这提供了一种更自然的反应方式):</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nd ne l"/></div></figure></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="d7c3" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">将子组件作为功能重用组件逻辑</h1><p id="d1f1" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">这基本上与使用render prop方法相同，只是看起来不同，因为React已经在开始组件标记和结束标记之间放置了子标记，所以逻辑上它将保持在那里:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nd ne l"/></div></figure></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="5724" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">使用多个渲染函数重用组件逻辑</h1><p id="8be0" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">您不限于一个渲染/子功能，您可以有多个:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nd ne l"/></div></figure><p id="104c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">然而，我不太喜欢或推荐这种方法，因为在编写<code class="fe mz na nb nc b">Dashboard</code>的render方法时，这种方法非常有局限性。但是在上面这种情况下，侧边栏或顶栏不会移动到UI中的任何地方，这是很有用的。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="c228" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">使用React挂钩重用组件逻辑</h1><p id="9ba9" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">然后是<a class="ae ky" href="https://reactjs.org/docs/hooks-intro.html" rel="noopener ugc nofollow" target="_blank"> React Hooks </a>，时至今日，它已经风靡了整个社区。</p><p id="ce73" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">钩子允许您解决上面列出的任何问题，并通过使用看起来像函数的东西将您带回到正常的JavaScript:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nd ne l"/></div></figure><p id="dad1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">渲染道具引入的一个问题是，当我们渲染多个相互嵌套的渲染道具组件时，我们会遇到<em class="ng">回调地狱</em>，看起来像这样:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nd ne l"/></div></figure><p id="676f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">当使用钩子时，它可能看起来像这样:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nd ne l"/></div></figure></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="8f94" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">通过使用子组件来重用组件逻辑</h1><p id="b9ec" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">我有时仍然会发现有人质疑一个组件在没有像这样显式传递的情况下如何接收某些属性:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nd ne l"/></div></figure><p id="3254" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">可以理解的是，有人质疑这段代码的有效性，因为我们没有看到任何道具被传递给<code class="fe mz na nb nc b">DeactivatorInput</code>，但是实际上有一种方法。</p><p id="4af9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">能够根据需要注入额外的道具来反应元素而不仅仅是组件，这很好。<code class="fe mz na nb nc b">React.cloneElement</code>能够为您做到这一点:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nd ne l"/></div></figure><p id="b92a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">React还提供了几个其他的处理孩子的工具——比如<code class="fe mz na nb nc b">React.Children.toArray</code>,你可以把它和<code class="fe mz na nb nc b">React.cloneElement</code>一起用于多个孩子:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nd ne l"/></div></figure><p id="7255" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这种策略通常在实现<a class="ae ky" href="https://www.youtube.com/watch?v=hEGg-3pIHlE" rel="noopener ugc nofollow" target="_blank">复合组件</a>时使用——然而，现在实现这种类似功能的更好方法是使用<a class="ae ky" href="https://reactjs.org/docs/context.html" rel="noopener ugc nofollow" target="_blank">React</a>T4 】,因为前一种解决方案的缺点是只有直接子节点可以接收传递给<code class="fe mz na nb nc b">React.cloneElement</code>的道具，除非在每个嵌套子节点中执行递归，这是不必要的。</p><p id="4630" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">有了React <code class="fe mz na nb nc b">Context</code>，你可以把孩子放在任何地方，不管他们有多嵌套，他们仍然能够代表你被同步。</p><p id="5486" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><a class="ae ky" href="https://github.com/rumble-charts/rumble-charts/blob/master/src/helpers/proxyChildren.js" rel="noopener ugc nofollow" target="_blank">隆隆图</a>是大量使用<code class="fe mz na nb nc b">React.Children.map</code>决定孩子行为的成功例子。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="dff2" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">动态创建深度嵌套的组件</h1><p id="45b6" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">在本节中，我们将讨论<a class="ae ky" href="https://www.geeksforgeeks.org/recursion/" rel="noopener ugc nofollow" target="_blank">递归</a>以及它如何帮助简化使用React组件的过程。</p><p id="7508" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">假设我们有一个包含重复元素的组件，比如包含下拉菜单按钮的导航栏。</p><p id="9be2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">一个下拉列表可以有多个项目，每个项目可以有自己的嵌套下拉列表，如下所示:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi nh"><img src="../Images/78e79ae352eccdb400a915df9109d591.png" data-original-src="https://miro.medium.com/v2/resize:fit:1246/0*ut31HfZ2s7wK7gPb.gif"/></div></figure><p id="73d1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们不想自己动手编写这些嵌套菜单。我们应该执行的唯一手工劳动是编写递归:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nd ne l"/></div></figure><p id="759e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">创建这样的组件是使组件可重用和动态的好方法。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="44c8" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">结论</h1><p id="f6c7" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">本文到此结束。我希望你发现这是有价值的，并期待在未来更多！</p></div></div>    
</body>
</html>