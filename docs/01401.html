<html>
<head>
<title>JavaScript Variables: The Difference Between Var, Let, and Const</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">JavaScript变量:Var、Let和Const之间的区别</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/javascript-variables-the-difference-between-var-let-and-const-10efef5d2728?source=collection_archive---------3-----------------------#2019-09-06">https://betterprogramming.pub/javascript-variables-the-difference-between-var-let-and-const-10efef5d2728?source=collection_archive---------3-----------------------#2019-09-06</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="f53e" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">以及何时使用哪个？</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/db1d0ac2b7b10e2b73f36df5ae96580b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*kAomA_Rcpz_cl7waQvj8YA.png"/></div></div></figure><p id="180d" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">随着ES6的引入，也引入了两个重要的新JavaScript关键字:<code class="fe lq lr ls lt b">let</code>和<code class="fe lq lr ls lt b">const</code>。在引入ES6之前，在JavaScript中声明变量的唯一方法是使用<code class="fe lq lr ls lt b">var</code>。但是<code class="fe lq lr ls lt b">var</code>、<code class="fe lq lr ls lt b">let</code>和<code class="fe lq lr ls lt b">const</code>有什么区别呢？我们什么时候使用哪种类型的示波器？</p></div><div class="ab cl lu lv hx lw" role="separator"><span class="lx bw bk ly lz ma"/><span class="lx bw bk ly lz ma"/><span class="lx bw bk ly lz"/></div><div class="im in io ip iq"><h1 id="d354" class="mb mc it bd md me mf mg mh mi mj mk ml jz mm ka mn kc mo kd mp kf mq kg mr ms bi translated">定义变量</h1><p id="8724" class="pw-post-body-paragraph ku kv it kw b kx mt ju kz la mu jx lc ld mv lf lg lh mw lj lk ll mx ln lo lp im bi translated">您可能知道，在JavaScript中声明变量的老式方法是使用<em class="my"> var </em>关键字。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mz na l"/></div></figure><p id="8250" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">当你在控制台中记录变量<code class="fe lq lr ls lt b">name</code>时，输出显然是<em class="my">本杰明</em>。<code class="fe lq lr ls lt b">name</code> <em class="my"> </em>变量具有全局范围。当我们通过添加一个函数来扩展脚本时，事情变得更有趣了。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mz na l"/></div></figure><p id="14c5" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">您认为控制台中的输出会是什么？如果你认为输出会是<em class="my">本杰明</em>，那你就错了。这是因为<code class="fe lq lr ls lt b">name</code>变量是在<code class="fe lq lr ls lt b">setup</code>函数中定义的，并且有一个函数范围。这意味着该变量只能在<code class="fe lq lr ls lt b">setup</code>函数中使用。这个例子的输出将是<em class="my">未定义的</em>。</p><p id="e09f" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">可以在函数中使用全局变量。这意味着<code class="fe lq lr ls lt b">age</code>变量可以在<code class="fe lq lr ls lt b">setup</code>函数中使用。这将输出<em class="my">本杰明26岁</em>到控制台。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mz na l"/></div></figure><p id="7f64" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">您只能访问具有相同范围或更高范围的变量。所以，从函数内部，你可以访问全局范围。但是，从全局来看，你不能访问一个只在函数中创建的变量。</p><p id="7d33" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">知道一个具有全局范围的变量可以在函数内部被改变也是很好的。在下面的例子中，<code class="fe lq lr ls lt b">age</code>变量将被设置为35；因此，35将在控制台中输出。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mz na l"/></div></figure><p id="aa98" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">当<code class="fe lq lr ls lt b">var</code>在<code class="fe lq lr ls lt b">for</code>循环或<code class="fe lq lr ls lt b">if</code>语句中使用时，情况变得更加棘手。一个<code class="fe lq lr ls lt b">for</code>循环或一个<code class="fe lq lr ls lt b">if</code>语句不会创建它们自己的变量。这意味着变量比创建它们的循环或语句更容易被访问。在下面的例子中，变量<em class="my"> i </em>具有全局范围。这将导致控制台输出10。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mz na l"/></div></figure></div><div class="ab cl lu lv hx lw" role="separator"><span class="lx bw bk ly lz ma"/><span class="lx bw bk ly lz ma"/><span class="lx bw bk ly lz"/></div><div class="im in io ip iq"><h1 id="62cb" class="mb mc it bd md me mf mg mh mi mj mk ml jz mm ka mn kc mo kd mp kf mq kg mr ms bi translated">让</h1><p id="6bb1" class="pw-post-body-paragraph ku kv it kw b kx mt ju kz la mu jx lc ld mv lf lg lh mw lj lk ll mx ln lo lp im bi translated">使用块范围而不是词法范围。这意味着<code class="fe lq lr ls lt b">let</code>不关心全局或局部，也不关心你是否在函数内部。相反，<code class="fe lq lr ls lt b">let</code>关心你所在的街区。块基本上是带花括号的任何东西。这可以是一个函数，也可以是一个<code class="fe lq lr ls lt b">for</code>循环或一个<code class="fe lq lr ls lt b">if</code>语句。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mz na l"/></div></figure><p id="54b6" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">这意味着在上面的例子中，变量<em class="my"> i </em>没有在全局范围内更新；因此输出将是5。</p><p id="5bd4" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">当你想让一个变量作用于它的块时,<code class="fe lq lr ls lt b">Let</code>很有用。可以从更高的块中访问变量，就像用<code class="fe lq lr ls lt b">var</code>从更高的作用域中访问变量一样。</p></div><div class="ab cl lu lv hx lw" role="separator"><span class="lx bw bk ly lz ma"/><span class="lx bw bk ly lz ma"/><span class="lx bw bk ly lz"/></div><div class="im in io ip iq"><h1 id="c923" class="mb mc it bd md me mf mg mh mi mj mk ml jz mm ka mn kc mo kd mp kf mq kg mr ms bi translated">常数</h1><p id="abd8" class="pw-post-body-paragraph ku kv it kw b kx mt ju kz la mu jx lc ld mv lf lg lh mw lj lk ll mx ln lo lp im bi translated"><code class="fe lq lr ls lt b">Const</code>的工作原理和<code class="fe lq lr ls lt b">let</code>几乎一样。然而，唯一的区别是一旦你给一个<code class="fe lq lr ls lt b">const</code>变量赋值，你就不能再给它赋值了。就像关键词暗示的那样。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mz na l"/></div></figure><p id="4001" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">上面的例子会给出一个错误，告诉你你正试图给一个<code class="fe lq lr ls lt b">const</code>赋值。</p><p id="2044" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated"><code class="fe lq lr ls lt b">Const</code>当你知道你有一个不会真正改变的变量时，这是很棒的。现在你会想，如果一个值不变，我们为什么要把它存储在变量中呢？</p><p id="7747" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">一部分是真的。另一方面，为了可读性，可以使用if。您可以选择在多个地方对代码中的一些值进行硬编码，但是使用一个<code class="fe lq lr ls lt b">const</code>变量会使您的代码更易于维护。每当硬编码的值改变时，您只需要改变<code class="fe lq lr ls lt b">const</code>变量，而不是遍历整个代码来寻找硬编码的值。</p><p id="8bd1" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">在下面的例子中，用户名是我们从用户输入中得到的一个值，不会改变。一个<code class="fe lq lr ls lt b">const</code>变量使得代码可读性更好。</p><p id="55ff" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated"><code class="fe lq lr ls lt b">const username = document.querySelect(‘input[name=”username”]’).value;</code></p><p id="45f3" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">这同样适用于下一个例子。无论何时处理大型对象，都可以使用<code class="fe lq lr ls lt b">const</code>来提高可读性。</p><p id="ddd5" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated"><code class="fe lq lr ls lt b">const books = api.data.sources[‘library’].books;</code></p><p id="da5b" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">使用<code class="fe lq lr ls lt b">const</code>有助于让你的代码背后的意图更清晰、更有表现力。当你在团队中工作时，这尤其有用。如果有人在代码中看到一个<code class="fe lq lr ls lt b">const</code>，这个人知道这个值可能不应该改变。</p></div><div class="ab cl lu lv hx lw" role="separator"><span class="lx bw bk ly lz ma"/><span class="lx bw bk ly lz ma"/><span class="lx bw bk ly lz"/></div><div class="im in io ip iq"><h1 id="4b79" class="mb mc it bd md me mf mg mh mi mj mk ml jz mm ka mn kc mo kd mp kf mq kg mr ms bi translated">例外:常量和对象的组合</h1><p id="e347" class="pw-post-body-paragraph ku kv it kw b kx mt ju kz la mu jx lc ld mv lf lg lh mw lj lk ll mx ln lo lp im bi translated"><strong class="kw iu"> </strong> <code class="fe lq lr ls lt b">const</code>声明<strong class="kw iu"> </strong>创建一个值的只读引用。这并不意味着它保存的值是不可变的，只是变量标识符不能被重新赋值。</p><p id="7bfe" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">这意味着下面是不可能的，因为我们试图重新分配用户<code class="fe lq lr ls lt b">const</code>。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mz na l"/></div></figure><p id="ddc8" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">但是可以改变这个对象的属性。这是因为一个<code class="fe lq lr ls lt b">const</code>持有的值不是不可变的。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mz na l"/></div></figure></div><div class="ab cl lu lv hx lw" role="separator"><span class="lx bw bk ly lz ma"/><span class="lx bw bk ly lz ma"/><span class="lx bw bk ly lz"/></div><div class="im in io ip iq"><h1 id="8b6f" class="mb mc it bd md me mf mg mh mi mj mk ml jz mm ka mn kc mo kd mp kf mq kg mr ms bi translated">何时使用哪种类型的变量？</h1><p id="115c" class="pw-post-body-paragraph ku kv it kw b kx mt ju kz la mu jx lc ld mv lf lg lh mw lj lk ll mx ln lo lp im bi translated">我认为你应该使用<code class="fe lq lr ls lt b">var</code>的唯一原因是当你在不支持ES6的代码库上工作时。</p><p id="e2b9" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">一般来说，<code class="fe lq lr ls lt b">let</code>比<code class="fe lq lr ls lt b">var</code>更可取，因为它缩小了范围。在大多数情况下，您应该能够将所有的<code class="fe lq lr ls lt b">var</code>语句转换成<code class="fe lq lr ls lt b">let</code>语句，而不做任何语义上的改变。</p><p id="8739" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated"><code class="fe lq lr ls lt b">Const</code>优于<code class="fe lq lr ls lt b">let</code>。从技术角度来说，<code class="fe lq lr ls lt b">const</code>从来都不是必须的。每一个<code class="fe lq lr ls lt b">const</code>都可以用一个<code class="fe lq lr ls lt b">let</code>变量替换，但是使用<code class="fe lq lr ls lt b">const</code>可以产生更干净的代码。除非需要改变值，否则使用<code class="fe lq lr ls lt b">const</code>。这具有<code class="fe lq lr ls lt b">let</code>的所有优点，同时减少了未初始化变量的出现，使代码更具可读性和表现力。如果你不确定是否需要改变一个值，就把它设为常量，直到你需要改变它。</p></div></div>    
</body>
</html>