<html>
<head>
<title>How We Reduced Bugs in Our React Codebase</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">我们如何减少React代码库中的错误</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/how-we-reduced-bugs-in-our-react-code-base-9a7a979b4442?source=collection_archive---------1-----------------------#2022-06-13">https://betterprogramming.pub/how-we-reduced-bugs-in-our-react-code-base-9a7a979b4442?source=collection_archive---------1-----------------------#2022-06-13</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="61f1" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">了解React中的模式和反模式</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/d237083edcde00c45801ce7cf672396c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*nN1IOC3cWeaV-_1H"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">照片由<a class="ae kv" href="https://unsplash.com/@surface?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">表面</a>在<a class="ae kv" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">未溅上</a></p></figure><h1 id="0142" class="kw kx iq bd ky kz la lb lc ld le lf lg jw lh jx li jz lj ka lk kc ll kd lm ln bi translated">介绍</h1><p id="94d2" class="pw-post-body-paragraph lo lp iq lq b lr ls jr lt lu lv ju lw lx ly lz ma mb mc md me mf mg mh mi mj ij bi translated">最近，在使用我们的大型React应用程序代码库时，我们遇到了三类错误，它们不是编译时或运行时错误，而是意外的代码行为。</p><ul class=""><li id="c521" class="mk ml iq lq b lr mm lu mn lx mo mb mp mf mq mj mr ms mt mu bi translated">组件不会因用户事件而更新。</li><li id="0ebb" class="mk ml iq lq b lr mv lu mw lx mx mb my mf mz mj mr ms mt mu bi translated">组件根据用户事件进行部分更新。</li><li id="fd0f" class="mk ml iq lq b lr mv lu mw lx mx mb my mf mz mj mr ms mt mu bi translated">组件意外呈现。</li></ul><p id="8b2d" class="pw-post-body-paragraph lo lp iq lq b lr mm jr lt lu mn ju lw lx na lz ma mb nb md me mf nc mh mi mj ij bi translated">我们的第一本能当然是“在我们能找到邪恶的地方与它战斗。”</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nd"><img src="../Images/4305fd7a425b6fc7818b5a241517d6df.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*M2JXFx0G5hUNIgQE-u2vlw.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">资料来源:imgflip.com</p></figure><p id="d235" class="pw-post-body-paragraph lo lp iq lq b lr mm jr lt lu mn ju lw lx na lz ma mb nb md me mf nc mh mi mj ij bi translated">然而，即使在一连串的打印声明之后，错误仍然很难追踪。就在那时，我们意识到我们代码的某些部分可以被认为是反模式。因此，我们花了很多时间来理解和描述它们，以确保我们在未来避免这些错误。本文试图解释这些发现。</p><h1 id="678e" class="kw kx iq bd ky kz la lb lc ld le lf lg jw lh jx li jz lj ka lk kc ll kd lm ln bi translated">React中的模式和反模式</h1><p id="996b" class="pw-post-body-paragraph lo lp iq lq b lr ls jr lt lu lv ju lw lx ly lz ma mb mc md me mf mg mh mi mj ij bi translated">在本文中，如果满足以下条件，React代码可以被视为一个好的模式:</p><ul class=""><li id="f377" class="mk ml iq lq b lr mm lu mn lx mo mb mp mf mq mj mr ms mt mu bi translated">该组件是可重用的。</li><li id="47c7" class="mk ml iq lq b lr mv lu mw lx mx mb my mf mz mj mr ms mt mu bi translated">代码更容易审查和调试。</li></ul><p id="f518" class="pw-post-body-paragraph lo lp iq lq b lr mm jr lt lu mn ju lw lx na lz ma mb nb md me mf nc mh mi mj ij bi translated">请注意，如果我们编写了更多的代码行，或者我们(预期地)引入了一些额外的渲染来实现上述目标，代码仍然被认为是一种模式。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi ne"><img src="../Images/5bf0c2cee5d899cd767734869d3aa059.png" data-original-src="https://miro.medium.com/v2/resize:fit:960/format:webp/1*_hoOW3NRU8PUB8Y9ye1UKQ.png"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">资料来源:giphy.com</p></figure><h2 id="20b2" class="nf kx iq bd ky ng nh dn lc ni nj dp lg lx nk nl li mb nm nn lk mf no np lm nq bi translated">为什么即使是有经验的开发人员也会陷入反模式的陷阱？</h2><ol class=""><li id="5b69" class="mk ml iq lq b lr ls lu lv lx nr mb ns mf nt mj nu ms mt mu bi translated">React代码在遵循模式时与遵循反模式时看起来惊人地相似。</li><li id="b6fc" class="mk ml iq lq b lr mv lu mw lx mx mb my mf mz mj nu ms mt mu bi translated">这种模式看起来如此明显，以至于被忽略了。</li></ol><h1 id="44e9" class="kw kx iq bd ky kz la lb lc ld le lf lg jw lh jx li jz lj ka lk kc ll kd lm ln bi translated">如何识别反模式？</h1><h2 id="0701" class="nf kx iq bd ky ng nh dn lc ni nj dp lg lx nk nl li mb nm nn lk mf no np lm nq bi translated">提示#1:没有依赖数组的钩子</h2><p id="1c8f" class="pw-post-body-paragraph lo lp iq lq b lr ls jr lt lu lv ju lw lx ly lz ma mb mc md me mf mg mh mi mj ij bi translated">在React中，不同的代码片段通过依赖关系相互链接。这些相互依赖的代码片段共同将应用程序状态保持在所需的形式。因此，如果我们在React中编写一段没有依赖关系的代码，很有可能会导致bug。</p><p id="b302" class="pw-post-body-paragraph lo lp iq lq b lr mm jr lt lu mn ju lw lx na lz ma mb nb md me mf nc mh mi mj ij bi translated">因此，使用<code class="fe nv nw nx ny b">useState</code>、<code class="fe nv nw nx ny b">useRef</code>等钩子时要小心。因为它们不接受依赖数组。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi nz"><img src="../Images/cd563d36365f4b54c9aa290e1c2780fd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1332/format:webp/1*9qPiwlXtd1AAQwhgcQVpvg.jpeg"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">资料来源:imgflip.com</p></figure><h2 id="00fd" class="nf kx iq bd ky ng nh dn lc ni nj dp lg lx nk nl li mb nm nn lk mf no np lm nq bi translated">提示#2:复合嵌套</h2><p id="b165" class="pw-post-body-paragraph lo lp iq lq b lr ls jr lt lu lv ju lw lx ly lz ma mb mc md me mf mg mh mi mj ij bi translated">有两种排列React组件的机制:</p><ol class=""><li id="462b" class="mk ml iq lq b lr mm lu mn lx mo mb mp mf mq mj nu ms mt mu bi translated">构成:所有的孩子都有相同的数据</li><li id="697e" class="mk ml iq lq b lr mv lu mw lx mx mb my mf mz mj nu ms mt mu bi translated">嵌套:每个孩子可以有不同的数据</li></ol><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi oa"><img src="../Images/acac213a7561a585c94b0d653fbf3efd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*oXjeTu8lRkJpkZynA6_ebg.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">作者图片</p></figure><p id="6eb8" class="pw-post-body-paragraph lo lp iq lq b lr mm jr lt lu mn ju lw lx na lz ma mb nb md me mf nc mh mi mj ij bi translated">让我们想象一个场景，我们观察到“孩子3”中有一个bug</p><p id="e2e2" class="pw-post-body-paragraph lo lp iq lq b lr mm jr lt lu mn ju lw lx na lz ma mb nb md me mf nc mh mi mj ij bi translated">如果我们使用composition来安排组件，我们就不必查看“Child 1”和“Child 2”的代码，因为它们都是独立的。因此，调试的时间复杂度将是<code class="fe nv nw nx ny b">O (1)</code>。</p><p id="585c" class="pw-post-body-paragraph lo lp iq lq b lr mm jr lt lu mn ju lw lx na lz ma mb nb md me mf nc mh mi mj ij bi translated">然而，如果我们使用嵌套来安排组件，我们将不得不检查“Child 3”之前的所有孩子，以找出错误的来源。在这种情况下，调试的时间复杂度将是<code class="fe nv nw nx ny b">O (n)</code>，其中<code class="fe nv nw nx ny b">n</code>是“孩子3”之上的孩子的数量</p><p id="ffc4" class="pw-post-body-paragraph lo lp iq lq b lr mm jr lt lu mn ju lw lx na lz ma mb nb md me mf nc mh mi mj ij bi translated">因此，我们可以得出结论，嵌套经常比组合更难调试。</p><h1 id="97b7" class="kw kx iq bd ky kz la lb lc ld le lf lg jw lh jx li jz lj ka lk kc ll kd lm ln bi translated">示例应用程序</h1><p id="2e24" class="pw-post-body-paragraph lo lp iq lq b lr ls jr lt lu lv ju lw lx ly lz ma mb mc md me mf mg mh mi mj ij bi translated">现在，让我们考虑一个演示不同模式和反模式的应用程序。</p><h2 id="e80f" class="nf kx iq bd ky ng nh dn lc ni nj dp lg lx nk nl li mb nm nn lk mf no np lm nq bi translated">应用程序的预期行为</h2><p id="1d84" class="pw-post-body-paragraph lo lp iq lq b lr ls jr lt lu lv ju lw lx ly lz ma mb mc md me mf mg mh mi mj ij bi translated">当在左侧导航菜单中点击一篇文章时，它会在右侧打开。接下来是两个动作:</p><ol class=""><li id="f2a5" class="mk ml iq lq b lr mm lu mn lx mo mb mp mf mq mj nu ms mt mu bi translated"><strong class="lq ir">计算</strong>:文章的总字数计算为<code class="fe nv nw nx ny b">(num_chars(title) + num_chars(text)</code>并显示。</li><li id="517d" class="mk ml iq lq b lr mv lu mw lx mx mb my mf mz mj nu ms mt mu bi translated"><strong class="lq ir">网络请求</strong>:根据文章的总字数，通过网络请求获取表情符号并显示。随着字符数的增加，表情符号会从悲伤变成快乐。</li></ol><h2 id="60f5" class="nf kx iq bd ky ng nh dn lc ni nj dp lg lx nk nl li mb nm nn lk mf no np lm nq bi translated">构建应用程序</h2><p id="e162" class="pw-post-body-paragraph lo lp iq lq b lr ls jr lt lu lv ju lw lx ly lz ma mb mc md me mf mg mh mi mj ij bi translated">我们将通过四个步骤来了解构建这款应用的正确方法:</p><ul class=""><li id="dae6" class="mk ml iq lq b lr mm lu mn lx mo mb mp mf mq mj mr ms mt mu bi translated"><strong class="lq ir">不正确</strong>:应用程序没有按预期运行——当选择一篇新文章时，不会触发计算或网络请求。</li><li id="bbc4" class="mk ml iq lq b lr mv lu mw lx mx mb my mf mz mj mr ms mt mu bi translated"><strong class="lq ir">部分正确</strong>:应用程序工作正常，但选择新文章时会出现闪烁现象。</li><li id="5a09" class="mk ml iq lq b lr mv lu mw lx mx mb my mf mz mj mr ms mt mu bi translated"><strong class="lq ir">正确但次优</strong>:应用程序工作正常，没有DOM闪烁，但发出不必要的网络请求。</li><li id="47cc" class="mk ml iq lq b lr mv lu mw lx mx mb my mf mz mj mr ms mt mu bi translated"><strong class="lq ir">正确和最佳</strong>:应用程序工作正常，没有DOM闪烁和不必要的网络请求。</li></ul><p id="a450" class="pw-post-body-paragraph lo lp iq lq b lr mm jr lt lu mn ju lw lx na lz ma mb nb md me mf nc mh mi mj ij bi translated">下面是这个应用程序的嵌入式沙盒。单击顶部导航栏中的相应选项，查看每种方法。在左侧导航菜单中点击一篇文章时，检查应用程序的执行情况。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ob oc l"/></div></figure><h2 id="4d1b" class="nf kx iq bd ky ng nh dn lc ni nj dp lg lx nk nl li mb nm nn lk mf no np lm nq bi translated">代码结构</h2><p id="2a38" class="pw-post-body-paragraph lo lp iq lq b lr ls jr lt lu lv ju lw lx ly lz ma mb mc md me mf mg mh mi mj ij bi translated">点击右下角的按钮可以打开上面的沙盒。</p><p id="820f" class="pw-post-body-paragraph lo lp iq lq b lr mm jr lt lu mn ju lw lx na lz ma mb nb md me mf nc mh mi mj ij bi translated"><code class="fe nv nw nx ny b">src/pages</code>目录有映射到每个步骤的页面。在<code class="fe nv nw nx ny b">src/pages</code>中每个页面的文件包含一个<code class="fe nv nw nx ny b">ArticleContent</code>组件。讨论中的代码在这个<code class="fe nv nw nx ny b">ArticleContent</code>组件中。要跟进，您可以检查沙箱中的相应文件或参考所附的代码片段。</p></div><div class="ab cl od oe hu of" role="separator"><span class="og bw bk oh oi oj"/><span class="og bw bk oh oi oj"/><span class="og bw bk oh oi"/></div><div class="ij ik il im in"><p id="cfaa" class="pw-post-body-paragraph lo lp iq lq b lr mm jr lt lu mn ju lw lx na lz ma mb nb md me mf nc mh mi mj ij bi translated">现在让我们回顾一下上述四种方法中遵循的反模式和模式。</p><h2 id="bfd4" class="nf kx iq bd ky ng nh dn lc ni nj dp lg lx nk nl li mb nm nn lk mf no np lm nq bi translated">反模式#1:道具或上下文作为初始状态</h2><p id="1cba" class="pw-post-body-paragraph lo lp iq lq b lr ls jr lt lu lv ju lw lx ly lz ma mb mc md me mf mg mh mi mj ij bi translated">在不正确的方法中，<code class="fe nv nw nx ny b">props</code>或<code class="fe nv nw nx ny b">context</code>被用作<code class="fe nv nw nx ny b">useState</code>或<code class="fe nv nw nx ny b">useRef</code>的初始值。在<code class="fe nv nw nx ny b">Incorrect.tsx</code>的第21行，我们可以看到总的字符数已经被计算出来并存储为一个状态。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ok oc l"/></div></figure><p id="74be" class="pw-post-body-paragraph lo lp iq lq b lr mm jr lt lu mn ju lw lx na lz ma mb nb md me mf nc mh mi mj ij bi translated">这种反模式是选择新文章时既不触发计算也不触发网络请求的原因。</p><h2 id="e74b" class="nf kx iq bd ky ng nh dn lc ni nj dp lg lx nk nl li mb nm nn lk mf no np lm nq bi translated">反模式#2:破坏和重建</h2><p id="f95b" class="pw-post-body-paragraph lo lp iq lq b lr ls jr lt lu lv ju lw lx ly lz ma mb mc md me mf mg mh mi mj ij bi translated">让我们通过使用“破坏并重新创建”反模式来弥补我们不正确的方法。</p><p id="fa3e" class="pw-post-body-paragraph lo lp iq lq b lr mm jr lt lu mn ju lw lx na lz ma mb nb md me mf nc mh mi mj ij bi translated">销毁一个功能组件是指销毁第一次函数调用时创建的所有钩子和状态。重新创建是指再次调用该函数，就好像它以前从未被调用过一样。</p><p id="7f51" class="pw-post-body-paragraph lo lp iq lq b lr mm jr lt lu mn ju lw lx na lz ma mb nb md me mf nc mh mi mj ij bi translated">注意，父组件可以使用<code class="fe nv nw nx ny b">key</code>属性来破坏组件，并在每次<code class="fe nv nw nx ny b">key</code>改变时重新创建它。是的，你没看错——你可以在循环之外使用键。</p><p id="2044" class="pw-post-body-paragraph lo lp iq lq b lr mm jr lt lu mn ju lw lx na lz ma mb nb md me mf nc mh mi mj ij bi translated">具体来说，我们通过使用<code class="fe nv nw nx ny b">key</code> prop实现“销毁并重新创建”反模式，同时在<code class="fe nv nw nx ny b">PartiallyCorrect.tsx</code>文件中呈现父组件<code class="fe nv nw nx ny b">PartiallyCorrect</code>的子组件<code class="fe nv nw nx ny b">ArticleContent</code>(第65行)。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ok oc l"/></div></figure><p id="3484" class="pw-post-body-paragraph lo lp iq lq b lr mm jr lt lu mn ju lw lx na lz ma mb nb md me mf nc mh mi mj ij bi translated">该应用程序按预期运行，但当选择一篇新文章时会出现闪烁效果。因此，这种反模式会导致部分正确的输出。</p><h2 id="5b62" class="nf kx iq bd ky ng nh dn lc ni nj dp lg lx nk nl li mb nm nn lk mf no np lm nq bi translated">模式1:JSX的内部状态</h2><p id="b651" class="pw-post-body-paragraph lo lp iq lq b lr ls jr lt lu lv ju lw lx ly lz ma mb mc md me mf mg mh mi mj ij bi translated">在这种“正确但次优”的方法中，我们将使用“重新呈现”，而不是使用“销毁并重新创建”反模式</p><p id="5d0e" class="pw-post-body-paragraph lo lp iq lq b lr mm jr lt lu mn ju lw lx na lz ma mb nb md me mf nc mh mi mj ij bi translated">重新呈现是指再次调用react功能组件，钩子在函数调用中保持不变。请注意，在“销毁并重新创建”中，所有的钩子首先被销毁，然后从头开始重新创建。</p><p id="e9c8" class="pw-post-body-paragraph lo lp iq lq b lr mm jr lt lu mn ju lw lx na lz ma mb nb md me mf nc mh mi mj ij bi translated">为了实现“重新渲染”，将串联使用<code class="fe nv nw nx ny b">useEffect</code>和<code class="fe nv nw nx ny b">useState</code>。可以将<code class="fe nv nw nx ny b">useState</code>的初始值设置为<code class="fe nv nw nx ny b">null</code>或<code class="fe nv nw nx ny b">undefined</code>，一旦<code class="fe nv nw nx ny b">useEffect</code>运行，将计算实际值并分配给它。在这个模式中，我们通过使用<code class="fe nv nw nx ny b">useEffect</code>来避免<code class="fe nv nw nx ny b">useState</code>中缺乏依赖数组的问题。</p><p id="7bc5" class="pw-post-body-paragraph lo lp iq lq b lr mm jr lt lu mn ju lw lx na lz ma mb nb md me mf nc mh mi mj ij bi translated">具体来说，请注意我们是如何将总字符数计算转移到<code class="fe nv nw nx ny b">Suboptimal.tsx</code>中的JSX(第44行)中的，并且我们使用<code class="fe nv nw nx ny b">props</code>(第33行)作为<code class="fe nv nw nx ny b">useEffect</code>(第25行)中的依赖项。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ok oc l"/></div></figure><p id="ee7f" class="pw-post-body-paragraph lo lp iq lq b lr mm jr lt lu mn ju lw lx na lz ma mb nb md me mf nc mh mi mj ij bi translated">使用这种模式，避免了闪烁效果，但是每当道具改变时，网络请求获取表情符号。因此，即使字符数没有变化，也会发出不必要的请求来获取相同的表情符号。</p><h2 id="8b4e" class="nf kx iq bd ky ng nh dn lc ni nj dp lg lx nk nl li mb nm nn lk mf no np lm nq bi translated">模式2:在useMemo中将Props作为依赖项</h2><p id="544b" class="pw-post-body-paragraph lo lp iq lq b lr ls jr lt lu lv ju lw lx ly lz ma mb mc md me mf mg mh mi mj ij bi translated">让我们这次做得既正确又最佳。这一切都始于反模式#1: <code class="fe nv nw nx ny b">props</code>或<code class="fe nv nw nx ny b">context</code>作为初始状态。</p><p id="440b" class="pw-post-body-paragraph lo lp iq lq b lr mm jr lt lu mn ju lw lx na lz ma mb nb md me mf nc mh mi mj ij bi translated">我们可以通过在<code class="fe nv nw nx ny b">useMemo</code>中使用<code class="fe nv nw nx ny b">props</code>作为依赖来解决这个问题。通过将总字符数计算转移到<code class="fe nv nw nx ny b">Optimal.tsx</code>(第22行)中的<code class="fe nv nw nx ny b">useMemo</code>钩子，我们能够阻止网络请求获取表情符号，除非总字符数已经改变。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ok oc l"/></div></figure><h1 id="83b3" class="kw kx iq bd ky kz la lb lc ld le lf lg jw lh jx li jz lj ka lk kc ll kd lm ln bi translated">结论</h1><p id="c6c6" class="pw-post-body-paragraph lo lp iq lq b lr ls jr lt lu lv ju lw lx ly lz ma mb mc md me mf mg mh mi mj ij bi translated">在本文中，我们讨论了使用<code class="fe nv nw nx ny b">props</code>或<code class="fe nv nw nx ny b">context</code>作为初始状态和‘销毁并重新创建’是反模式，而使用JSX中的内部状态和<code class="fe nv nw nx ny b">props</code>作为<code class="fe nv nw nx ny b">useMemo</code>中的依赖是好模式。我们还了解到，在使用没有依赖数组的钩子和嵌套来安排React组件时，我们应该小心。</p></div><div class="ab cl od oe hu of" role="separator"><span class="og bw bk oh oi oj"/><span class="og bw bk oh oi oj"/><span class="og bw bk oh oi"/></div><div class="ij ik il im in"><pre class="kg kh ki kj gt ol ny om on aw oo bi"><span id="ef63" class="nf kx iq ny b gy op oq l or os"><strong class="ny ir">Want to Connect?</strong></span><span id="0129" class="nf kx iq ny b gy ot oq l or os">This article was written in collaboration with <a class="ou ov ep" href="https://medium.com/u/bb565db0c961?source=post_page-----9a7a979b4442--------------------------------" rel="noopener" target="_blank">Shyam Swaroop</a>, Co-Founder &amp; CTO at Atri Labs.</span></pre></div></div>    
</body>
</html>