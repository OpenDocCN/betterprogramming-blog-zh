<html>
<head>
<title>Workspace Inheritance in Rust</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Rust中的工作空间继承</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/workspace-inheritance-in-rust-65d0bb8f9424?source=collection_archive---------2-----------------------#2022-09-22">https://betterprogramming.pub/workspace-inheritance-in-rust-65d0bb8f9424?source=collection_archive---------2-----------------------#2022-09-22</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="0382" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">看看Rust 1.64的新特性</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/b535ade3c80827af4cbddb290a50850d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*TGHUKkhdWciZQhLx"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">照片由<a class="ae ky" href="https://unsplash.com/@rodlong?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">杆长</a>在<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</p></figure><p id="b1a9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">Rust 1.64 今天已经发布，这个版本将会影响数百个各种类型的网络项目。</p><p id="1ade" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这是因为它有一个关键特征，任何项目都可以分成许多不同的箱子。这个特性是<strong class="lb iu">工作空间继承，</strong>它将允许我们在板条箱之间共享像版本号或元数据字段这样的字段。<code class="fe lv lw lx ly b">Cargo.toml</code>文件终于开始遵循干燥原则了。</p><h1 id="e714" class="lz ma it bd mb mc md me mf mg mh mi mj jz mk ka ml kc mm kd mn kf mo kg mp mq bi translated">告别复制粘贴许可证和作者</h1><p id="293b" class="pw-post-body-paragraph kz la it lb b lc mr ju le lf ms jx lh li mt lk ll lm mu lo lp lq mv ls lt lu im bi translated">当他们创建一个新的板条箱时，首先要做的事情之一就是打开上一个板条箱的清单，并复制两者之间的所有公共部分——即使它们在同一个工作区中。</p><p id="0914" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">例如，在我用来展示代码示例的<a class="ae ky" href="https://github.com/kriogenia/medium/tree/9fb321343146aa9c67cf9309565f39c6ab55d77f" rel="noopener ugc nofollow" target="_blank">库</a>中，你可以看到我曾经在每个箱子中都有相同的<code class="fe lv lw lx ly b">authors</code>键。现在我可以去掉所有的重复。怎么会？第一，把根<code class="fe lv lw lx ly b">Cargo.toml</code>做成这样:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mw mx l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">Cargo.toml设置工作区的默认包</p></figure><p id="474d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在这个新版本中，在<code class="fe lv lw lx ly b">[workspace.package]</code>下，您可以定义<a class="ae ky" href="https://doc.rust-lang.org/cargo/reference/workspaces.html#the-package-table" rel="noopener ugc nofollow" target="_blank">包部分的一些键</a>作为工作区默认值。</p><p id="19d8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这将允许工作空间板条箱选择加入并继承那些相同的部分，否则将被复制(在这个例子中，就是您在<code class="fe lv lw lx ly b">workspace.members</code>中看到的存储库的所有板条箱)。</p><p id="b67d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在，为了利用这些缺省值，我们只需要将它们调用到其他清单中。比如现在这是<code class="fe lv lw lx ly b">add_trait/Cargo.toml</code>:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mw mx l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">新的add_trait/Cargo.toml</p></figure><p id="5fbf" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在,<code class="fe lv lw lx ly b">add_trait</code>的清单将继承我们在根中为键设置的值，这些键是我们用<code class="fe lv lw lx ly b">{key}.workspace</code>带来的，比如<code class="fe lv lw lx ly b">edition</code>或<code class="fe lv lw lx ly b">authors</code>。也看看我们如何忽略那些我们不想带的东西，比如<code class="fe lv lw lx ly b">readme</code>，因为这个箱子里不会有；还是<code class="fe lv lw lx ly b">description</code>，不一样的，我们是压倒性的。</p><p id="e4e3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">有了这个新的清单，所有的项目将总是使用相同的版本，像改变许可证这样的更新将不必在每个项目中手动更新。</p><h1 id="17cd" class="lz ma it bd mb mc md me mf mg mh mi mj jz mk ka ml kc mm kd mn kf mo kg mp mq bi translated">保持版本同步</h1><p id="edd3" class="pw-post-body-paragraph kz la it lb b lc mr ju le lf ms jx lh li mt lk ll lm mu lo lp lq mv ls lt lu im bi translated">但是，我们可以用这种新的继承做另一件事，这将是商业项目中的关键。这是使用继承来授予依赖性之间的同步性。为此，我们可以遵循与使用<code class="fe lv lw lx ly b">[package]</code>相同的方法，但是使用<code class="fe lv lw lx ly b">[workspace.dependencies]</code>和典型的依赖声明(<em class="my">但是我们不能在这里使用</em><code class="fe lv lw lx ly b"><em class="my">optional</em></code><em class="my"/>)。</p><p id="6d3a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">例如，将它添加到根<code class="fe lv lw lx ly b">Cargo.toml</code>会将工作区默认版本和特性设置为这三个依赖项:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mw mx l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">在根Cargo.toml中定义依赖关系</p></figure><p id="ec7c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在，在<code class="fe lv lw lx ly b">generify_with_compiler_errors</code>中，我们可以将这些依赖项与工作区版本和特性一起使用，并在声明中声明它们——如下例所示:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mw mx l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">继承工作区依赖项的版本和功能</p></figure><p id="b3f6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">看看我们是如何在工作区中以同样的方式声明<code class="fe lv lw lx ly b">vector2d</code>的，但是我们是如何覆盖<code class="fe lv lw lx ly b">num</code>依赖关系的，因为这个机箱需要使用默认特性，我们只是使用了相同的版本。这个机箱没有使用<code class="fe lv lw lx ly b">rand</code>，但是我添加它是为了展示你如何在那些已声明的特性之上声明特性，并且不仅在<code class="fe lv lw lx ly b">[dependencies]</code>中，而且在<code class="fe lv lw lx ly b">[dev-dependencies]</code>和<code class="fe lv lw lx ly b">[build-dependencies]</code>中带来依赖关系。</p><p id="5eb3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">今天到此为止，如果你能检查整个新的Rust版本，你可以在这里<a class="ae ky" href="https://blog.rust-lang.org/2022/09/22/Rust-1.64.0.html" rel="noopener ugc nofollow" target="_blank">做</a>，并且看到实际工作中的代码，你可以在下面链接的库中找到它。</p><div class="mz na gp gr nb nc"><a href="https://github.com/kriogenia/medium/" rel="noopener  ugc nofollow" target="_blank"><div class="nd ab fo"><div class="ne ab nf cl cj ng"><h2 class="bd iu gy z fp nh fr fs ni fu fw is bi translated">GitHub - kriogenia/medium:存放我在medium帖子上使用的示例的存储库</h2><div class="nj l"><h3 class="bd b gy z fp nh fr fs ni fu fw dk translated">此时您不能执行该操作。您已使用另一个标签页或窗口登录。您已在另一个选项卡中注销，或者…</h3></div><div class="nk l"><p class="bd b dl z fp nh fr fs ni fu fw dk translated">github.com</p></div></div><div class="nl l"><div class="nm l nn no np nl nq ks nc"/></div></div></a></div><p id="7023" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">Rust 1.65再见，我们将会看到那些期待已久的<strong class="lb iu"> GATs </strong>。</p></div></div>    
</body>
</html>