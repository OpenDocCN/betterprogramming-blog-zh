<html>
<head>
<title>Swift: Unit Test a DataTaskPublisher With URLProtocol</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Swift:使用URLProtocol对DataTaskPublisher进行单元测试</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/swift-unit-test-a-datataskpublisher-with-urlprotocol-2fbda186758e?source=collection_archive---------2-----------------------#2019-09-03">https://betterprogramming.pub/swift-unit-test-a-datataskpublisher-with-urlprotocol-2fbda186758e?source=collection_archive---------2-----------------------#2019-09-03</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="cd16" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">如何使用<code class="fe ki kj kk kl b">URLProtocol</code>实现对一个<code class="fe ki kj kk kl b">DataTaskPublisher</code>的单元测试</h2></div><figure class="kn ko kp kq gt kr gh gi paragraph-image"><div role="button" tabindex="0" class="ks kt di ku bf kv"><div class="gh gi km"><img src="../Images/3246f008a8fccaf4bf6b881e6efdc0bc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*hnIGzvz7VDpQFpYa"/></div></div><p class="ky kz gj gh gi la lb bd b be z dk translated">照片由<a class="ae lc" href="https://unsplash.com/@alinnnaaaa?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Alina Grubnyak </a>在<a class="ae lc" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</p></figure><p id="d4a3" class="pw-post-body-paragraph ld le it lf b lg lh ju li lj lk jx ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated">在我上一篇文章的<a class="ae lc" href="https://medium.com/better-programming/upgrade-your-swift-api-client-with-combine-4897d6e408a0" rel="noopener">中，我通过组合API和<code class="fe ki kj kk kl b">URLSession</code>实现了一个数据发布器，以及如何将它用作API客户端。</a></p><p id="9a47" class="pw-post-body-paragraph ld le it lf b lg lh ju li lj lk jx ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated">这一次，我们将为我们的API客户端创建一个Swift包，并为它实现单元测试。</p><p id="68d1" class="pw-post-body-paragraph ld le it lf b lg lh ju li lj lk jx ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated">上一次，我们通过对Docker实例进行集成测试，证明了API客户机的工作原理。</p><p id="6c1a" class="pw-post-body-paragraph ld le it lf b lg lh ju li lj lk jx ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated">这一次，通过实现单元测试，我们完成了我们的代码，因此我们可以在将来维护这个库，并证明我们没有错过相关的用例。</p><p id="457f" class="pw-post-body-paragraph ld le it lf b lg lh ju li lj lk jx ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated">对我们的API客户机进行完整的单元测试将要求我们证明客户机工作正常，不仅是在服务器可用并提供正确的响应和数据时，而且是在响应无效、数据损坏或出现网络故障时。</p><p id="3a76" class="pw-post-body-paragraph ld le it lf b lg lh ju li lj lk jx ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated">注意:您需要Xcode 11来完成本教程。</p></div><div class="ab cl lz ma hx mb" role="separator"><span class="mc bw bk md me mf"/><span class="mc bw bk md me mf"/><span class="mc bw bk md me"/></div><div class="im in io ip iq"><h1 id="d8f8" class="mg mh it bd mi mj mk ml mm mn mo mp mq jz mr ka ms kc mt kd mu kf mv kg mw mx bi translated">快速包裹准备</h1><blockquote class="my mz na"><p id="78ec" class="ld le nb lf b lg lh ju li lj lk jx ll nc ln lo lp nd lr ls lt ne lv lw lx ly im bi translated">" T<!-- -->Swift包管理器是一个管理Swift代码分发的工具。它与Swift构建系统相集成，可自动完成下载、编译和链接依赖关系的过程。”— <a class="ae lc" href="https://swift.org/package-manager/" rel="noopener ugc nofollow" target="_blank"> Swift软件包管理器文档</a></p></blockquote><p id="b38f" class="pw-post-body-paragraph ld le it lf b lg lh ju li lj lk jx ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated">通过Swift Package Manager，我们将创建一个定制库并对其进行单元测试。</p><h2 id="a399" class="nf mh it bd mi ng nh dn mm ni nj dp mq lm nk nl ms lq nm nn mu lu no np mw nq bi translated">创建新的包</h2><p id="4f53" class="pw-post-body-paragraph ld le it lf b lg nr ju li lj ns jx ll lm nt lo lp lq nu ls lt lu nv lw lx ly im bi translated">从命令行创建一个目录，在我们的例子中是<code class="fe ki kj kk kl b">CombineAPIDemo</code>:</p><pre class="kn ko kp kq gt nw kl nx ny aw nz bi"><span id="c57c" class="nf mh it kl b gy oa ob l oc od">mkdir CombineAPIDemo<br/>cd CombineAPIDemo</span></pre><p id="16ff" class="pw-post-body-paragraph ld le it lf b lg lh ju li lj lk jx ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated">初始化您的新包:</p><pre class="kn ko kp kq gt nw kl nx ny aw nz bi"><span id="a188" class="nf mh it kl b gy oa ob l oc od">swift package init</span></pre><p id="a3a8" class="pw-post-body-paragraph ld le it lf b lg lh ju li lj lk jx ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated">包init将为一个库创建项目脚手架:</p><pre class="kn ko kp kq gt nw kl nx ny aw nz bi"><span id="f4f1" class="nf mh it kl b gy oa ob l oc od">Creating library package: CombineAPIDemo</span><span id="e7bf" class="nf mh it kl b gy oe ob l oc od">Creating Package.swift<br/>Creating README.md<br/>Creating .gitignore<br/>Creating Sources/<br/>Creating Sources/CombineAPIDemo/CombineAPIDemo.swift<br/>Creating Tests/<br/>Creating Tests/LinuxMain.swift<br/>Creating Tests/CombineAPIDemoTests/<br/>Creating Tests/CombineAPIDemoTests/CombineAPIDemoTests.swift<br/>Creating Tests/CombineAPIDemoTests/XCTestManifests.swift</span></pre><p id="22bf" class="pw-post-body-paragraph ld le it lf b lg lh ju li lj lk jx ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated">现在，我们生成Xcode项目:</p><pre class="kn ko kp kq gt nw kl nx ny aw nz bi"><span id="e43a" class="nf mh it kl b gy oa ob l oc od">swift package generate-xcodeproj</span></pre><p id="78cd" class="pw-post-body-paragraph ld le it lf b lg lh ju li lj lk jx ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated">我们会打开它:</p><pre class="kn ko kp kq gt nw kl nx ny aw nz bi"><span id="71f8" class="nf mh it kl b gy oa ob l oc od">open CombineAPIDemo.xcodeproj</span></pre><p id="ab06" class="pw-post-body-paragraph ld le it lf b lg lh ju li lj lk jx ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated">太好了！你的第一个包裹准备好了！现在，您需要添加代码。</p><h2 id="f680" class="nf mh it bd mi ng nh dn mm ni nj dp mq lm nk nl ms lq nm nn mu lu no np mw nq bi translated">将代码添加到包中</h2><p id="0bc2" class="pw-post-body-paragraph ld le it lf b lg nr ju li lj ns jx ll lm nt lo lp lq nu ls lt lu nv lw lx ly im bi translated">用下面的代码覆盖<code class="fe ki kj kk kl b">CombineAPIDemo.swift</code>:</p><figure class="kn ko kp kq gt kr"><div class="bz fp l di"><div class="of og l"/></div><p class="ky kz gj gh gi la lb bd b be z dk translated"><a class="ae lc" href="https://gist.github.com/Andrea-Scuderi/a3dcdec30a966da6ad3390c66ad95732" rel="noopener ugc nofollow" target="_blank">https://gist . github . com/Andrea-Scuderi/a3 dcdec 30 a 966 da 6 ad 3390 c 66 ad 95732</a></p></figure><p id="e1bd" class="pw-post-body-paragraph ld le it lf b lg lh ju li lj lk jx ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated">我重构了我们在<a class="ae lc" href="https://medium.com/better-programming/upgrade-your-swift-api-client-with-combine-4897d6e408a0" rel="noopener">上一篇文章</a>中讨论过的一些类，因此有可能构建一个带有自定义会话的<code class="fe ki kj kk kl b">DataTaskPublisher</code>，该会话将在单元测试期间注入。</p><p id="b8c1" class="pw-post-body-paragraph ld le it lf b lg lh ju li lj lk jx ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated">我们的<code class="fe ki kj kk kl b">APIDemo.publisher</code>现在基于<code class="fe ki kj kk kl b">APIDataTaskPublisher</code>协议，由类<code class="fe ki kj kk kl b">APISessionDataTaskPublisher</code>实现。这将允许我们通过对我们的响应使用模拟来改变发布者内部的<code class="fe ki kj kk kl b">URLSession</code>。</p><p id="bce8" class="pw-post-body-paragraph ld le it lf b lg lh ju li lj lk jx ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated">在<code class="fe ki kj kk kl b">APIDemo</code>类中，我们有三种不同类型的静态函数:</p><ul class=""><li id="d17b" class="oh oi it lf b lg lh lj lk lm oj lq ok lu ol ly om on oo op bi translated">Public:我们希望向包消费者显示的函数。</li><li id="87d2" class="oh oi it lf b lg oq lj or lm os lq ot lu ou ly om on oo op bi translated">内部:我们需要单元测试的功能。</li><li id="e090" class="oh oi it lf b lg oq lj or lm os lq ot lu ou ly om on oo op bi translated">Private:作为实用程序使用的函数，由内部函数使用。我们不能直接测试它，因为它们不能被单元测试类访问，但是它们将作为内部函数测试的一部分被测试。</li></ul><p id="3f5f" class="pw-post-body-paragraph ld le it lf b lg lh ju li lj lk jx ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated">太好了！现在我们有了单元测试的代码。尝试构建它，检查它是否构建正确。</p></div><div class="ab cl lz ma hx mb" role="separator"><span class="mc bw bk md me mf"/><span class="mc bw bk md me mf"/><span class="mc bw bk md me"/></div><div class="im in io ip iq"><h1 id="9396" class="mg mh it bd mi mj mk ml mm mn mo mp mq jz mr ka ms kc mt kd mu kf mv kg mw mx bi translated">让我们深入单元测试</h1><h2 id="ff82" class="nf mh it bd mi ng nh dn mm ni nj dp mq lm nk nl ms lq nm nn mu lu no np mw nq bi translated">返回DataTaskPublisher的内部函数</h2><p id="c76e" class="pw-post-body-paragraph ld le it lf b lg nr ju li lj ns jx ll lm nt lo lp lq nu ls lt lu nv lw lx ly im bi translated">返回<code class="fe ki kj kk kl b">DataTaskPublisher</code>的内部函数的单元测试将测试所创建的请求是否正确。</p><pre class="kn ko kp kq gt nw kl nx ny aw nz bi"><span id="1e91" class="nf mh it kl b gy oa ob l oc od"><strong class="kl iu">func</strong> testPostUserDTP() {<br/>   <strong class="kl iu">let</strong> future = <strong class="kl iu">try</strong>? APIDemo.postUserDTP(user: <strong class="kl iu">self</strong>.mocks.user)<br/>   <strong class="kl iu">let</strong> request =  future?.request<br/>   XCTAssertEqual(request?.url?.absoluteString, APIDemo.baseURL + "/users")</span><span id="99bb" class="nf mh it kl b gy oe ob l oc od">...</span><span id="b6de" class="nf mh it kl b gy oe ob l oc od">...</span><span id="138c" class="nf mh it kl b gy oe ob l oc od">}</span></pre><h2 id="12de" class="nf mh it bd mi ng nh dn mm ni nj dp mq lm nk nl ms lq nm nn mu lu no np mw nq bi translated">模仿URLSession</h2><p id="5d4d" class="pw-post-body-paragraph ld le it lf b lg nr ju li lj ns jx ll lm nt lo lp lq nu ls lt lu nv lw lx ly im bi translated">在<code class="fe ki kj kk kl b">Tests\CombineAPIDemoTests</code>文件夹下添加一个新的Swift文件，命名为<code class="fe ki kj kk kl b">URLProtocolMock</code>，内容如下:</p><figure class="kn ko kp kq gt kr"><div class="bz fp l di"><div class="of og l"/></div><p class="ky kz gj gh gi la lb bd b be z dk translated"><a class="ae lc" href="https://gist.github.com/Andrea-Scuderi/15e8e13e31bd562e5c607b63a54d60d5" rel="noopener ugc nofollow" target="_blank">https://gist . github . com/Andrea-Scuderi/15 e8e 13 e 31 BD 562 e5c 607 b 63 a 54d 60d 5</a></p></figure><p id="2fd8" class="pw-post-body-paragraph ld le it lf b lg lh ju li lj lk jx ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated"><code class="fe ki kj kk kl b">URLProtocolMock</code>是用我们定制的响应和数据创建模拟<code class="fe ki kj kk kl b">URLSession</code>的关键。该类允许传递我们的<code class="fe ki kj kk kl b">Data</code>、<code class="fe ki kj kk kl b">URLResponse</code>和<code class="fe ki kj kk kl b">Error</code>来模拟网络请求的行为。</p><p id="7d71" class="pw-post-body-paragraph ld le it lf b lg lh ju li lj lk jx ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated">被嘲笑的<code class="fe ki kj kk kl b">URLSession</code>将这样创建:</p><pre class="kn ko kp kq gt nw kl nx ny aw nz bi"><span id="3d7d" class="nf mh it kl b gy oa ob l oc od"><strong class="kl iu">let</strong> config = URLSessionConfiguration.ephemeral</span><span id="4e56" class="nf mh it kl b gy oe ob l oc od">config.protocolClasses = [URLProtocolMock.<strong class="kl iu">self</strong>]</span><span id="bd1a" class="nf mh it kl b gy oe ob l oc od"><strong class="kl iu">let</strong> session = URLSession(configuration: config)</span></pre><p id="3c71" class="pw-post-body-paragraph ld le it lf b lg lh ju li lj lk jx ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated">因此，我们可以创建一个自定义的<code class="fe ki kj kk kl b">APISessionDataPublisher</code>并将其分配给<code class="fe ki kj kk kl b">APIDemo.publisher</code>来模拟网络调用。</p><pre class="kn ko kp kq gt nw kl nx ny aw nz bi"><span id="ea31" class="nf mh it kl b gy oa ob l oc od">let customPublisher = APISessionDataPublisher(session: session)<br/>APIDemo.publisher = customPublisher</span></pre><p id="1832" class="pw-post-body-paragraph ld le it lf b lg lh ju li lj lk jx ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated">我们可以设置我们的回应:</p><pre class="kn ko kp kq gt nw kl nx ny aw nz bi"><span id="6ac1" class="nf mh it kl b gy oa ob l oc od"><strong class="kl iu">let</strong> usersURL = URL(string: APIDemo.baseURL + "/users")</span><span id="1fb0" class="nf mh it kl b gy oe ob l oc od">URLProtocolMock.testURLs = [usersURL: Data(Fixtures.createUserResponse.utf8)]<br/>URLProtocolMock.response = mocks.validResponse</span></pre><p id="95f0" class="pw-post-body-paragraph ld le it lf b lg lh ju li lj lk jx ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated">并创建我们的模拟API客户端发布程序。</p><pre class="kn ko kp kq gt nw kl nx ny aw nz bi"><span id="8d83" class="nf mh it kl b gy oa ob l oc od"><strong class="kl iu">let</strong> customPublisher = APISessionDataPublisher(session: session)</span></pre><h2 id="77d5" class="nf mh it bd mi ng nh dn mm ni nj dp mq lm nk nl ms lq nm nn mu lu no np mw nq bi translated"><strong class="ak">实现可复用的测试功能</strong></h2><p id="4fd8" class="pw-post-body-paragraph ld le it lf b lg nr ju li lj ns jx ll lm nt lo lp lq nu ls lt lu nv lw lx ly im bi translated">对于每个测试调用，我们需要测试客户端的以下条件:</p><ul class=""><li id="5d9e" class="oh oi it lf b lg lh lj lk lm oj lq ok lu ol ly om on oo op bi translated">有效的回应。</li><li id="5552" class="oh oi it lf b lg oq lj or lm os lq ot lu ou ly om on oo op bi translated">由于无效的<code class="fe ki kj kk kl b">URLResponse</code>导致无效的响应。</li><li id="3725" class="oh oi it lf b lg oq lj or lm os lq ot lu ou ly om on oo op bi translated">由于无效的<code class="fe ki kj kk kl b">Data</code>，响应无效。</li><li id="5956" class="oh oi it lf b lg oq lj or lm os lq ot lu ou ly om on oo op bi translated">由于网络故障，响应无效。</li></ul><p id="f914" class="pw-post-body-paragraph ld le it lf b lg lh ju li lj lk jx ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated">下面的代码将展示测试一个通用发布者所需的两个函数的实现，当它是<code class="fe ki kj kk kl b">Valid</code>或<code class="fe ki kj kk kl b">Invalid</code>时。</p><figure class="kn ko kp kq gt kr"><div class="bz fp l di"><div class="of og l"/></div><p class="ky kz gj gh gi la lb bd b be z dk translated"><a class="ae lc" href="https://gist.github.com/Andrea-Scuderi/985f73a2fa2fa99576fbc8882150af30" rel="noopener ugc nofollow" target="_blank">https://gist . github . com/Andrea-Scuderi/985 f73 a2 fa 2fa 99576 FBC 8882150 af 30</a></p></figure><p id="fe3e" class="pw-post-body-paragraph ld le it lf b lg lh ju li lj lk jx ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated"><code class="fe ki kj kk kl b">sink</code>函数将执行异步网络调用。</p><p id="d017" class="pw-post-body-paragraph ld le it lf b lg lh ju li lj lk jx ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated">我们需要定义我们将返回的所有期望，以便我们可以在测试中等待它们。</p><p id="46a7" class="pw-post-body-paragraph ld le it lf b lg lh ju li lj lk jx ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated">以下是如何配置测试以获得有效响应的示例:</p><pre class="kn ko kp kq gt nw kl nx ny aw nz bi"><span id="4b6c" class="nf mh it kl b gy oa ob l oc od"><strong class="kl iu">//Setup URLSession Mock</strong><br/><strong class="kl iu">let</strong> usersURL = URL(string: APIDemo.baseURL + "/users")</span><span id="ca2b" class="nf mh it kl b gy oe ob l oc od">URLProtocolMock.testURLs = [usersURL:      Data(Fixtures.createUserResponse.utf8)]<br/>URLProtocolMock.response = mocks.validResponse</span><span id="dd72" class="nf mh it kl b gy oe ob l oc od"><strong class="kl iu">let</strong> config = URLSessionConfiguration.ephemeral<br/>config.protocolClasses = [URLProtocolMock.<strong class="kl iu">self</strong>]<br/><strong class="kl iu">let</strong> session = URLSession(configuration: config)</span><span id="2537" class="nf mh it kl b gy oe ob l oc od"><strong class="kl iu">let</strong> customPublisher = APISessionDataPublisher(session: session)</span><span id="897e" class="nf mh it kl b gy oe ob l oc od">APIDemo.publisher = customPublisher</span><span id="9242" class="nf mh it kl b gy oe ob l oc od"><strong class="kl iu">// Create the Publisher<br/>let</strong> publisher = APIDemo.create(user: <strong class="kl iu">self</strong>.mocks.user)</span><span id="d439" class="nf mh it kl b gy oe ob l oc od"><strong class="kl iu">// Test the Publisher</strong><br/><strong class="kl iu">let</strong> validTest = evalValidResponseTest(publisher: publisher)<br/>wait(for: validTest.expectations, timeout:testTimeout)<br/>validTest.cancellable?.cancel()</span></pre><h2 id="bb6b" class="nf mh it bd mi ng nh dn mm ni nj dp mq lm nk nl ms lq nm nn mu lu no np mw nq bi translated">单元测试DataTaskPublisher</h2><p id="be03" class="pw-post-body-paragraph ld le it lf b lg nr ju li lj ns jx ll lm nt lo lp lq nu ls lt lu nv lw lx ly im bi translated">下面是测试<code class="fe ki kj kk kl b">create</code>功能的完整示例:</p><figure class="kn ko kp kq gt kr"><div class="bz fp l di"><div class="of og l"/></div><p class="ky kz gj gh gi la lb bd b be z dk translated"><a class="ae lc" href="https://gist.github.com/Andrea-Scuderi/247522b550d2e0ba89c85d7cb2ce5c81" rel="noopener ugc nofollow" target="_blank">https://gist . github . com/Andrea-Scuderi/247522 b 550d 2 E0 ba 89 c 85d 7 CB 2 ce 5c 81</a></p></figure></div><div class="ab cl lz ma hx mb" role="separator"><span class="mc bw bk md me mf"/><span class="mc bw bk md me mf"/><span class="mc bw bk md me"/></div><div class="im in io ip iq"><h1 id="0b85" class="mg mh it bd mi mj mk ml mm mn mo mp mq jz mr ka ms kc mt kd mu kf mv kg mw mx bi translated">包扎</h1><p id="daff" class="pw-post-body-paragraph ld le it lf b lg nr ju li lj ns jx ll lm nt lo lp lq nu ls lt lu nv lw lx ly im bi translated">用以下内容覆盖<code class="fe ki kj kk kl b">CombineAPIDemoTests.swift</code>:</p><figure class="kn ko kp kq gt kr"><div class="bz fp l di"><div class="of og l"/></div><p class="ky kz gj gh gi la lb bd b be z dk translated"><a class="ae lc" href="https://gist.github.com/Andrea-Scuderi/7c756daa3c9aa1657b72324738583293" rel="noopener ugc nofollow" target="_blank">https://gist . github . com/Andrea-Scuderi/7c 756 da a3 c 9 aa 1657 b 72324738583293</a></p></figure><p id="a4d9" class="pw-post-body-paragraph ld le it lf b lg lh ju li lj lk jx ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated">现在，您已经完成了API客户端的完整测试。</p><p id="63e1" class="pw-post-body-paragraph ld le it lf b lg lh ju li lj lk jx ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated">在Xcode中，使用键盘上的CTRL+U快捷键运行单元测试，或者从菜单中选择<em class="nb"> Product- &gt; Test。</em></p><figure class="kn ko kp kq gt kr gh gi paragraph-image"><div role="button" tabindex="0" class="ks kt di ku bf kv"><div class="gh gi ov"><img src="../Images/9dbebb8aac3cf10210a2a4e8059c430f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*V0AzGBHBxXZ4DOyiAjUkLQ.png"/></div></div></figure><p id="4259" class="pw-post-body-paragraph ld le it lf b lg lh ju li lj lk jx ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated">仅此而已！感谢阅读全文，我希望你喜欢它。</p><p id="548d" class="pw-post-body-paragraph ld le it lf b lg lh ju li lj lk jx ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated">这里是<a class="ae lc" href="https://github.com/Andrea-Scuderi/CombineAPIDemo" rel="noopener ugc nofollow" target="_blank">完整项目</a>。</p></div><div class="ab cl lz ma hx mb" role="separator"><span class="mc bw bk md me mf"/><span class="mc bw bk md me mf"/><span class="mc bw bk md me"/></div><div class="im in io ip iq"><h1 id="edba" class="mg mh it bd mi mj mk ml mm mn mo mp mq jz mr ka ms kc mt kd mu kf mv kg mw mx bi translated">参考</h1><div class="ow ox gp gr oy oz"><a href="https://medium.com/better-programming/upgrade-your-swift-api-client-with-combine-4897d6e408a0" rel="noopener follow" target="_blank"><div class="pa ab fo"><div class="pb ab pc cl cj pd"><h2 class="bd iu gy z fp pe fr fs pf fu fw is bi translated">使用Combine升级您的Swift API客户端</h2><div class="pg l"><h3 class="bd b gy z fp pe fr fs pf fu fw dk translated">用Combine API和URLSession实现一个数据发布器，以及如何将其用作API客户端</h3></div><div class="ph l"><p class="bd b dl z fp pe fr fs pf fu fw dk translated">medium.com</p></div></div><div class="pi l"><div class="pj l pk pl pm pi pn kw oz"/></div></div></a></div><div class="ow ox gp gr oy oz"><a href="https://github.com/apple/swift-package-manager/blob/master/Documentation/Usage.md" rel="noopener  ugc nofollow" target="_blank"><div class="pa ab fo"><div class="pb ab pc cl cj pd"><h2 class="bd iu gy z fp pe fr fs pf fu fw is bi translated">苹果/swift包管理器</h2><div class="pg l"><h3 class="bd b gy z fp pe fr fs pf fu fw dk translated">简单地说:包是一个带有语义版本标记的git存储库，它包含Swift源代码和一个…</h3></div><div class="ph l"><p class="bd b dl z fp pe fr fs pf fu fw dk translated">github.com</p></div></div><div class="pi l"><div class="po l pk pl pm pi pn kw oz"/></div></div></a></div><div class="ow ox gp gr oy oz"><a href="https://www.hackingwithswift.com/articles/153/how-to-test-ios-networking-code-the-easy-way" rel="noopener  ugc nofollow" target="_blank"><div class="pa ab fo"><div class="pb ab pc cl cj pd"><h2 class="bd iu gy z fp pe fr fs pf fu fw is bi translated">如何以最简单的方式测试iOS网络代码</h2><div class="pg l"><h3 class="bd b gy z fp pe fr fs pf fu fw dk translated">普遍认为单元测试应该是第一位的:快速、隔离、可重复、自我验证和及时。可悲的是…</h3></div><div class="ph l"><p class="bd b dl z fp pe fr fs pf fu fw dk translated">www.hackingwithswift.com</p></div></div><div class="pi l"><div class="pp l pk pl pm pi pn kw oz"/></div></div></a></div><div class="ow ox gp gr oy oz"><a href="https://nshipster.com/nsurlprotocol/" rel="noopener  ugc nofollow" target="_blank"><div class="pa ab fo"><div class="pb ab pc cl cj pd"><h2 class="bd iu gy z fp pe fr fs pf fu fw is bi translated">NSURLProtocol</h2><div class="pg l"><h3 class="bd b gy z fp pe fr fs pf fu fw dk translated">iOS完全是关于网络的——无论是从服务器读取状态还是向服务器写入状态，将计算卸载到…</h3></div><div class="ph l"><p class="bd b dl z fp pe fr fs pf fu fw dk translated">nshipster.com</p></div></div><div class="pi l"><div class="pq l pk pl pm pi pn kw oz"/></div></div></a></div></div></div>    
</body>
</html>