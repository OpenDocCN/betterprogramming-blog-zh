<html>
<head>
<title>Let No One Slide Through the Gates</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">不要让任何人溜出大门</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/let-no-one-slide-through-the-gates-77ed57f76455?source=collection_archive---------18-----------------------#2020-06-24">https://betterprogramming.pub/let-no-one-slide-through-the-gates-77ed57f76455?source=collection_archive---------18-----------------------#2020-06-24</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="1969" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">提高Node.js应用程序安全性的详细研究</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/baa08cc04dd938c35f524d5c74ba6f08.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*1kac7LpT_m9o5QYs"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">何塞·丰塔诺在<a class="ae kv" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</p></figure><p id="5bbc" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">网络上的任何东西都容易受到攻击。没有人能在网络中制作完美的应用程序。但是我们可以尽最大努力减少应用程序中的漏洞、弱点和缺陷，从而将安全漏洞的可能性降至最低。</p><p id="0561" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们可以采取一般的抽象安全措施来提高web应用程序的安全性，也可以采取特定于技术的措施来确保安全性。</p><p id="d40d" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">由于Node.js在世界各地的许多web应用程序中使用，所以我想写一些Node.js特有的措施，以及我们可以采取的一般安全措施。</p><p id="ed2b" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><a class="ae kv" href="https://cheatsheetseries.owasp.org/cheatsheets/Nodejs_Security_Cheat_Sheet.html#nodejs-security-cheat-sheet" rel="noopener ugc nofollow" target="_blank">开放网络应用安全项目(OWASP) </a>列出了一些我们可以考虑的措施和建议。他们将这些措施分为四个主要领域。</p><ul class=""><li id="5fc5" class="ls lt iq ky b kz la lc ld lf lu lj lv ln lw lr lx ly lz ma bi translated">应用程序安全性</li><li id="d4f0" class="ls lt iq ky b kz mb lc mc lf md lj me ln mf lr lx ly lz ma bi translated">错误和异常观察</li><li id="d991" class="ls lt iq ky b kz mb lc mc lf md lj me ln mf lr lx ly lz ma bi translated">服务器安全性</li><li id="9492" class="ls lt iq ky b kz mb lc mc lf md lj me ln mf lr lx ly lz ma bi translated">平台安全性</li></ul></div><div class="ab cl mg mh hu mi" role="separator"><span class="mj bw bk mk ml mm"/><span class="mj bw bk mk ml mm"/><span class="mj bw bk mk ml"/></div><div class="ij ik il im in"><h1 id="6485" class="mn mo iq bd mp mq mr ms mt mu mv mw mx jw my jx mz jz na ka nb kc nc kd nd ne bi translated">应用程序安全性</h1><p id="163d" class="pw-post-body-paragraph kw kx iq ky b kz nf jr lb lc ng ju le lf nh lh li lj ni ll lm ln nj lp lq lr ij bi translated">应用程序安全性主要关注如何保护应用程序的运行时免受诸如未经授权的访问、修改等威胁。以下是我们可以用来确保应用程序安全性的一些措施。</p><h2 id="d628" class="nk mo iq bd mp nl nm dn mt nn no dp mx lf np nq mz lj nr ns nb ln nt nu nd nv bi translated"><strong class="ak"> <em class="nw">限制请求尺寸</em> </strong></h2><p id="209c" class="pw-post-body-paragraph kw kx iq ky b kz nf jr lb lc ng ju le lf nh lh li lj ni ll lm ln nj lp lq lr ij bi translated">当我们的应用程序为用户服务时，它总是需要缓冲和解析用户发送的一些数据。</p><p id="965c" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">数据可以是URL、JSON主体或多部分数据。如果对这些请求的大小没有限制，攻击者可以向我们的应用程序发送大量数据，这可能会导致服务器耗尽内存、CPU能力或磁盘空间。</p><p id="6001" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">因此，我们需要对用户发送的请求大小设置一个上限。但是URL数据非常小，以字节或几千字节来衡量。JSON数据大约有几千字节，多部分数据可以达到20-30兆字节。</p><p id="d254" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这些大小取决于应用程序用例、用途和领域。因此，我们需要为不同的请求类型手动指定不同的请求限制。对于Express，我们可以通过以下步骤轻松做到这一点。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nx ny l"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">在Express中限制请求大小—摘自<a class="ae kv" href="https://cheatsheetseries.owasp.org/cheatsheets/Nodejs_Security_Cheat_Sheet.html#set-request-size-limits" rel="noopener ugc nofollow" target="_blank"> OWASP </a></p></figure><p id="c2fa" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">但是这种方法是不够的，因为攻击者可以手动更改请求大小头并绕过这种验证。因此，在处理请求时，我们也需要手动检查这个验证。</p><h2 id="431c" class="nk mo iq bd mp nl nm dn mt nn no dp mx lf np nq mz lj nr ns nb ln nt nu nd nv bi translated"><strong class="ak"> <em class="nw">避免制造影响安全的竞争条件</em> </strong></h2><p id="34c4" class="pw-post-body-paragraph kw kx iq ky b kz nf jr lb lc ng ju le lf nh lh li lj ni ll lm ln nj lp lq lr ij bi translated">对于阻塞事件，Node.js允许分配回调以最大化吞吐量。对于与I/O相关的任务，使用回调将有助于避免阻塞事件循环。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nx ny l"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">一个非常简单但有缺陷的认证脚本</p></figure><p id="a9cf" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">上面显示的代码是一个使用回调读取文件的例子。</p><p id="de2e" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这里，在回调和第7行之间出现了竞争情况。比赛的获胜者将完全改变程序流的输出。因此，如果首先执行第7行，那么在用户通过身份验证之前，文本文件将被取消链接。这可能会导致抛出严重的错误或异常。</p><p id="3a73" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">以下是在没有任何竞争条件的情况下执行上述任务的好方法。我们可以在一个非阻塞函数中编写所有相互依赖的操作。这样，我们可以保证重要的操作以正确的顺序执行。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nx ny l"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">解决上述问题的正确方法</p></figure><h2 id="3450" class="nk mo iq bd mp nl nm dn mt nn no dp mx lf np nq mz lj nr ns nb ln nt nu nd nv bi translated"><strong class="ak"> <em class="nw">执行输入验证</em> </strong></h2><p id="4885" class="pw-post-body-paragraph kw kx iq ky b kz nf jr lb lc ng ju le lf nh lh li lj ni ll lm ln nj lp lq lr ij bi translated">在几乎所有的web应用程序中，从用户那里获取输入是很常见的。因此，验证输入值至关重要。不进行输入验证或部分验证输入可能会导致许多不同类型的应用程序漏洞。</p><p id="908c" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">攻击者可以利用这些漏洞执行SQL注入、跨站点脚本、命令注入、本地/远程文件包含、拒绝服务、目录遍历、LDAP注入和许多其他注入攻击。</p><p id="997c" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">验证输入的最佳方式是将接受的输入列入白名单。白名单验证包括准确定义什么是授权的，并阻止其他一切。</p><p id="d749" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">但是大多数时候，这有点难。因此，我们可以首先检查预期的输入方案，并对危险的输入进行转义。你可以在这里了解更多关于白名单、黑名单和输入验证<a class="ae kv" href="https://cheatsheetseries.owasp.org/cheatsheets/Input_Validation_Cheat_Sheet.html" rel="noopener ugc nofollow" target="_blank">的信息。在Node.js中，有多个模块可以简化验证，比如</a><a class="ae kv" href="https://www.npmjs.com/package/validator" rel="noopener ugc nofollow" target="_blank"> validator.js </a>和<a class="ae kv" href="https://www.npmjs.com/package/mongo-express-sanitize" rel="noopener ugc nofollow" target="_blank"> mongo-express-sanitize </a>。使用验证器的一个例子是:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nx ny l"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">验证电子邮件输入</p></figure><p id="53ba" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">预防SQL注入与此有些不同。攻击者可以将隐藏在用户输入中的SQL查询传递给程序。这些查询可以从数据库中读取我们的敏感信息，并导致我们的数据库被清除。考虑下面的SQL查询。</p><p id="af74" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><code class="fe nz oa ob oc b">select username, password from users where id=$id</code></p><p id="c5ec" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">假设用户输入<code class="fe nz oa ob oc b">2</code>或<code class="fe nz oa ob oc b">1=1?</code> <em class="od"> </em>作为输入的实例。</p><p id="cfd1" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><code class="fe nz oa ob oc b">select username, password from users where id=2 or 1=1</code></p><p id="e394" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这将向用户显示来自<code class="fe nz oa ob oc b">user</code>表的所有数据。为了避免这些情况，我们必须使用参数化查询或准备好的语句。所有可用的数据库模块都提供了避免这些注入的功能。以下来自<a class="ae kv" href="https://www.npmjs.com/package/pg" rel="noopener ugc nofollow" target="_blank">节点-postgres </a>模块。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nx ny l"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">在node-postgres模块中使用参数化查询</p></figure><p id="848b" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">命令注入是另一种可能发生在web应用程序上的攻击。这样，攻击者就可以在我们的web服务器上运行操作系统命令。假设一个实例使用<code class="fe nz oa ob oc b">child_process.exec</code>方法调用<code class="fe nz oa ob oc b">gzip</code>命令，该命令附加一个用户提供的动态文件路径来构造<code class="fe nz oa ob oc b">gzip</code>命令。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nx ny l"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">一个调用“gzip”命令的简单函数</p></figure><p id="456d" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在这里，如果攻击者将<code class="fe nz oa ob oc b">; rm -rf /</code>附加到<code class="fe nz oa ob oc b">file_path</code>输入中，它将脱离<code class="fe nz oa ob oc b">gzip</code>命令并执行删除命令，这将彻底清除服务器。攻击者可以通过使用<code class="fe nz oa ob oc b">;</code>、<code class="fe nz oa ob oc b">&amp;</code>、<code class="fe nz oa ob oc b">&amp;&amp;</code>、<code class="fe nz oa ob oc b">|</code>、<code class="fe nz oa ob oc b">||</code>、<code class="fe nz oa ob oc b">$()</code>、<code class="fe nz oa ob oc b">&lt;</code>、<code class="fe nz oa ob oc b">&gt;</code>、<code class="fe nz oa ob oc b">&gt;&gt;</code>等字符来连锁多个命令。</p><p id="6db3" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">原因是<code class="fe nz oa ob oc b">exec</code>方法产生了一个新的<code class="fe nz oa ob oc b">bin/sh</code>进程，并传递命令在系统外壳中执行。这相当于给攻击者一个Bash解释器，它拥有与我们的应用程序相同的特权。</p><p id="28cd" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">因此，防止这种情况的一种方法是降低我们的应用程序的特权。但是避免这些的一个好方法是使用方法<code class="fe nz oa ob oc b">execFile</code>或<code class="fe nz oa ob oc b">spawn</code>而不是<code class="fe nz oa ob oc b">exec</code>。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nx ny l"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">使用“execFile”方法防止命令注入</p></figure><p id="40e6" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">附加到<code class="fe nz oa ob oc b">file_path</code>输入的命令在<code class="fe nz oa ob oc b">execFile</code>方法的第二个类型为<code class="fe nz oa ob oc b">array</code>的参数中结束。用户输入中的任何恶意命令都会被忽略，或者如果它们与目标命令不相关，就会导致语法错误。但是这些方法也不是100%安全的，我们必须将一些用户输入列入白名单，这是我前面提到的，以保证安全性。</p><h2 id="5489" class="nk mo iq bd mp nl nm dn mt nn no dp mx lf np nq mz lj nr ns nb ln nt nu nd nv bi translated"><strong class="ak"> <em class="nw">执行输出转义</em> </strong></h2><p id="54c6" class="pw-post-body-paragraph kw kx iq ky b kz nf jr lb lc ng ju le lf nh lh li lj ni ll lm ln nj lp lq lr ij bi translated">应该执行此操作以避免另一种类型的注入攻击，即我前面提到的跨站点脚本(XSS)。</p><p id="7999" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在这里，攻击者通过在论坛、留言板和评论中输入恶意脚本，在web应用程序中存储恶意代码。当另一个受害者访问网页时，这些脚本被传送到他们那里。恶意代码在受害者不知情的情况下在受害者的浏览器中执行。</p><p id="5fd7" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这里，除了验证来自用户的输入，我们还必须避开应用程序显示给用户的所有HTML和JavaScript内容。我们可以使用<a class="ae kv" href="https://github.com/component/escape-html" rel="noopener ugc nofollow" target="_blank"> escape-html </a>或<a class="ae kv" href="https://github.com/ESAPI/node-esapi" rel="noopener ugc nofollow" target="_blank"> node-esapi </a>库在Node.js中执行这项任务。</p><h2 id="ca94" class="nk mo iq bd mp nl nm dn mt nn no dp mx lf np nq mz lj nr ns nb ln nt nu nd nv bi translated"><strong class="ak"> <em class="nw">对应用活动进行日志记录</em> </strong></h2><p id="01b7" class="pw-post-body-paragraph kw kx iq ky b kz nf jr lb lc ng ju le lf nh lh li lj ni ll lm ln nj lp lq lr ij bi translated">日志记录不是防止攻击的方法。但是，如果我们的服务器受到攻击，我们可以使用日志来监控发生了什么，并确定攻击者使用的漏洞。Node.js有一些模块，像<a class="ae kv" href="https://www.npmjs.com/package/winston" rel="noopener ugc nofollow" target="_blank"> winston </a>或<a class="ae kv" href="https://www.npmjs.com/package/bunyan" rel="noopener ugc nofollow" target="_blank"> bunyan、</a>来执行应用活动日志记录。</p><h2 id="53e9" class="nk mo iq bd mp nl nm dn mt nn no dp mx lf np nq mz lj nr ns nb ln nt nu nd nv bi translated"><strong class="ak"> <em class="nw">监控事件环路的繁忙交通</em> </strong></h2><p id="fb77" class="pw-post-body-paragraph kw kx iq ky b kz nf jr lb lc ng ju le lf nh lh li lj ni ll lm ln nj lp lq lr ij bi translated">当我们的服务器被流量淹没时，我们的应用程序可能会崩溃。攻击者可以利用这一点来加载我们的服务器流量，使其崩溃。这是一种<em class="od">拒绝服务(DOS) </em>攻击。</p><p id="5dca" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">因此，我们必须监控繁忙的流量，如果它超过了我们的应用程序可以处理的某个阈值，我们必须用<code class="fe nz oa ob oc b">“Server Too Busy”</code>来响应其余的请求。这样，我们的应用程序就不会崩溃，并在极端负载下保持响应，它将继续为尽可能多的请求提供服务。</p><p id="0661" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们不需要手动操作。toobusy-js模块帮助我们轻松做到这一点。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nx ny l"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">toobusy-js的用法</p></figure><h2 id="2815" class="nk mo iq bd mp nl nm dn mt nn no dp mx lf np nq mz lj nr ns nb ln nt nu nd nv bi translated"><strong class="ak"> <em class="nw">防止暴力攻击</em> </strong></h2><p id="ad0e" class="pw-post-body-paragraph kw kx iq ky b kz nf jr lb lc ng ju le lf nh lh li lj ni ll lm ln nj lp lq lr ij bi translated">暴力攻击大多发生在登录端点。攻击者可以输入数千个随机密码来猜测正确的密码。他们可能会成功，并在数千次尝试后登录到我们的服务器。</p><p id="422c" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">为了防止这种情况，我们可以减少某个用户尝试登录的次数(使用<a class="ae kv" href="https://libraries.io/npm/rate-limiter" rel="noopener ugc nofollow" target="_blank">限速器</a>)。或者我们可以在多次尝试后锁定用户的帐户(使用类似于<a class="ae kv" href="https://www.npmjs.com/package/mongoose" rel="noopener ugc nofollow" target="_blank">猫鼬</a>的模块)。或者我们可以逐渐增加来自某个用户的每个登录请求的响应时间(使用<a class="ae kv" href="https://libraries.io/npm/express-bouncer" rel="noopener ugc nofollow" target="_blank"> express-bouncer </a>)。我们也可以使用验证码来阻止这些攻击(使用<a class="ae kv" href="https://www.npmjs.com/package/svg-captcha" rel="noopener ugc nofollow" target="_blank"> svg-captcha </a>)。</p><p id="3bb1" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们可以使用<a class="ae kv" href="https://github.com/vanhauser-thc/thc-hydra" rel="noopener ugc nofollow" target="_blank">hydra</a>——一个概念验证工具来测试我们的应用程序在这些场景中的行为。</p><h2 id="ea19" class="nk mo iq bd mp nl nm dn mt nn no dp mx lf np nq mz lj nr ns nb ln nt nu nd nv bi translated"><strong class="ak"> <em class="nw">防止HTTP参数污染</em> </strong></h2><p id="36e7" class="pw-post-body-paragraph kw kx iq ky b kz nf jr lb lc ng ju le lf nh lh li lj ni ll lm ln nj lp lq lr ij bi translated">提供多个同名的HTTP参数可能会导致应用程序以无法预料的方式解释值。攻击者可以利用这些漏洞进行输入验证、触发应用程序错误或修改内部变量值。</p><p id="12b2" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">有各种模块可用来防止这些类型的攻击。Express有一个中间件，<a class="ae kv" href="https://www.npmjs.com/package/hpp" rel="noopener ugc nofollow" target="_blank"> HPP </a>，当使用它时，它会忽略<code class="fe nz oa ob oc b">req.query</code>和/或<code class="fe nz oa ob oc b">req.body</code>中提交的所有参数值，只选择最后提交的参数值。</p></div><div class="ab cl mg mh hu mi" role="separator"><span class="mj bw bk mk ml mm"/><span class="mj bw bk mk ml mm"/><span class="mj bw bk mk ml"/></div><div class="ij ik il im in"><h1 id="4b82" class="mn mo iq bd mp mq mr ms mt mu mv mw mx jw my jx mz jz na ka nb kc nc kd nd ne bi translated">错误处理</h1><p id="507b" class="pw-post-body-paragraph kw kx iq ky b kz nf jr lb lc ng ju le lf nh lh li lj ni ll lm ln nj lp lq lr ij bi translated">我们都知道错误处理在任何应用程序中都是必须的，我们都知道如何处理错误和异常。</p><p id="0408" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">但是当某些敏感的细节通过堆栈跟踪暴露出来时，问题就来了。堆栈跟踪本身并不被视为漏洞，但是提供调试信息作为产生错误的操作的结果被认为是一种不好的做法。我们应该总是记录错误，但不把它们展示给用户。</p></div><div class="ab cl mg mh hu mi" role="separator"><span class="mj bw bk mk ml mm"/><span class="mj bw bk mk ml mm"/><span class="mj bw bk mk ml"/></div><div class="ij ik il im in"><h1 id="c4fc" class="mn mo iq bd mp mq mr ms mt mu mv mw mx jw my jx mz jz na ka nb kc nc kd nd ne bi translated">服务器安全性</h1><p id="a83b" class="pw-post-body-paragraph kw kx iq ky b kz nf jr lb lc ng ju le lf nh lh li lj ni ll lm ln nj lp lq lr ij bi translated">顾名思义，服务器安全关注的是服务器的安全。它主要侧重于保护服务器上的数据和资源。它包含有助于防止入侵、黑客攻击和其他恶意行为的工具和技术。</p><h2 id="9c04" class="nk mo iq bd mp nl nm dn mt nn no dp mx lf np nq mz lj nr ns nb ln nt nu nd nv bi translated"><strong class="ak"> <em class="nw">适当设置cookie标志</em> </strong></h2><p id="b644" class="pw-post-body-paragraph kw kx iq ky b kz nf jr lb lc ng ju le lf nh lh li lj ni ll lm ln nj lp lq lr ij bi translated">不能低估安全使用cookies的重要性。Cookies用于在web应用程序中传输会话信息。但是不小心使用这些可能最终会向外界泄露敏感信息。我们可以使用内置的cookie标志来防止这些问题。</p><ul class=""><li id="89c9" class="ls lt iq ky b kz la lc ld lf lu lj lv ln lw lr lx ly lz ma bi translated"><code class="fe nz oa ob oc b">httpOnly</code>:防止客户端JavaScript访问cookie。这是防止XSS袭击的一个很好的安全措施。</li><li id="abd6" class="ls lt iq ky b kz mb lc mc lf md lj me ln mf lr lx ly lz ma bi translated"><code class="fe nz oa ob oc b">Secure</code>:仅当通信协议为HTTPS时，才允许发送cookie</li><li id="26eb" class="ls lt iq ky b kz mb lc mc lf md lj me ln mf lr lx ly lz ma bi translated"><code class="fe nz oa ob oc b">SameSite</code>:防止在跨站点请求中发送cookies，这有助于防止跨站点请求伪造(CSRF)攻击</li></ul><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nx ny l"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">Cookie实现—摘自<a class="ae kv" href="https://cheatsheetseries.owasp.org/cheatsheets/Nodejs_Security_Cheat_Sheet.html#monitor-the-event-loop" rel="noopener ugc nofollow" target="_blank"> OWASP </a></p></figure><h2 id="bfec" class="nk mo iq bd mp nl nm dn mt nn no dp mx lf np nq mz lj nr ns nb ln nt nu nd nv bi translated"><strong class="ak"> <em class="nw">使用合适的安全头</em> </strong></h2><p id="4b46" class="pw-post-body-paragraph kw kx iq ky b kz nf jr lb lc ng ju le lf nh lh li lj ni ll lm ln nj lp lq lr ij bi translated">我们可以使用某些HTTP响应头来提高应用程序的安全性。一旦它们被设置，它们就可以限制现代浏览器进入容易预防的漏洞。以下是其中的一些。</p><ul class=""><li id="ea42" class="ls lt iq ky b kz la lc ld lf lu lj lv ln lw lr lx ly lz ma bi translated"><code class="fe nz oa ob oc b">Strict-Transport-Security</code>:强制执行与服务器的安全(HTTP over SSL/TLS)连接</li><li id="a972" class="ls lt iq ky b kz mb lc mc lf md lj me ln mf lr lx ly lz ma bi translated"><code class="fe nz oa ob oc b">X-Frame-Options</code>:提供<a class="ae kv" href="https://www.owasp.org/index.php/Clickjacking" rel="noopener ugc nofollow" target="_blank"/></li><li id="8524" class="ls lt iq ky b kz mb lc mc lf md lj me ln mf lr lx ly lz ma bi translated"><code class="fe nz oa ob oc b">X-XSS-Protection</code>:启用最新网络浏览器内置的XSS过滤器</li><li id="90a9" class="ls lt iq ky b kz mb lc mc lf md lj me ln mf lr lx ly lz ma bi translated"><code class="fe nz oa ob oc b">X-Content-Type-Options</code>:防止浏览器从声明的内容类型中嗅探响应</li><li id="1bb1" class="ls lt iq ky b kz mb lc mc lf md lj me ln mf lr lx ly lz ma bi translated"><code class="fe nz oa ob oc b">Content-Security-Policy</code>:防止大范围的攻击，包括XSS和其他跨站注射</li></ul><p id="e3d1" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">为了实现这些，Node.js有一个我们可以使用的模块，<a class="ae kv" href="https://www.npmjs.com/package/helmet" rel="noopener ugc nofollow" target="_blank">头盔，</a>。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nx ny l"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">头盔的使用</p></figure><p id="2835" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们可以使用<a class="ae kv" href="http://cyh.herokuapp.com/cyh" rel="noopener ugc nofollow" target="_blank">这个</a>在线检查器来检查我们的应用程序是否有所有必要的标题。</p></div><div class="ab cl mg mh hu mi" role="separator"><span class="mj bw bk mk ml mm"/><span class="mj bw bk mk ml mm"/><span class="mj bw bk mk ml"/></div><div class="ij ik il im in"><h1 id="203d" class="mn mo iq bd mp mq mr ms mt mu mv mw mx jw my jx mz jz na ka nb kc nc kd nd ne bi translated">平台安全性</h1><p id="f811" class="pw-post-body-paragraph kw kx iq ky b kz nf jr lb lc ng ju le lf nh lh li lj ni ll lm ln nj lp lq lr ij bi translated"><em class="od">平台安全</em>是指确保整个计算平台安全的安全架构、工具和流程。</p><h2 id="6b1e" class="nk mo iq bd mp nl nm dn mt nn no dp mx lf np nq mz lj nr ns nb ln nt nu nd nv bi translated"><strong class="ak"> <em class="nw">保持软件包最新</em> </strong></h2><p id="a901" class="pw-post-body-paragraph kw kx iq ky b kz nf jr lb lc ng ju le lf nh lh li lj ni ll lm ln nj lp lq lr ij bi translated">我们使用的软件包也有它们的漏洞和弱点。一旦这样的漏洞被发现，攻击者利用它来攻击我们的网站只是时间问题。但是软件包供应商会定期更新这些程序，包括错误修复和安全更新。因此，我们必须确保我们的平台保持最新。</p><p id="129c" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">此外，我们需要确保我们不使用任何有严重安全问题的第三方模块。我们可以使用S <a class="ae kv" href="https://snyk.io/" rel="noopener ugc nofollow" target="_blank"> nyk </a>，一个在开源库和容器中发现并修复安全漏洞的工具。</p><h2 id="e487" class="nk mo iq bd mp nl nm dn mt nn no dp mx lf np nq mz lj nr ns nb ln nt nu nd nv bi translated"><strong class="ak"> <em class="nw">远离邪恶的正则表达式</em> </strong></h2><p id="33a0" class="pw-post-body-paragraph kw kx iq ky b kz nf jr lb lc ng ju le lf nh lh li lj ni ll lm ln nj lp lq lr ij bi translated">邪恶的正则表达式是一些正则表达式实现，可能会达到极端情况，导致它们工作非常缓慢。<code class="fe nz oa ob oc b">([a-zA-Z]+)*</code>、<code class="fe nz oa ob oc b">(a+)+</code>或<code class="fe nz oa ob oc b">(a|a?)+</code>都是易受攻击的正则表达式，因为像<code class="fe nz oa ob oc b">aaaaaaaaaaaaaaaaaaaaaaaa!</code>这样的简单输入会导致繁重的计算。</p><p id="bcfe" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">攻击者可以利用上述知识来寻找使用包含恶意正则表达式的正则表达式的应用程序，并发送一个精心制作的输入，使系统挂起。或者，如果正则表达式本身受到用户输入的影响，攻击者可以注入一个邪恶的正则表达式，使系统易受攻击。您可以在“<a class="ae kv" href="https://owasp.org/www-community/attacks/Regular_expression_Denial_of_Service_-_ReDoS" rel="noopener ugc nofollow" target="_blank">正则表达式拒绝服务— ReDoS </a>”中了解更多信息</p><p id="0573" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">为了防止这种情况，我们可以使用名为<a class="ae kv" href="https://www.npmjs.com/package/safe-regex" rel="noopener ugc nofollow" target="_blank"> safe-regex </a>的Node.js工具。</p><p id="ac9d" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">假设我们有这样一个脚本:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nx ny l"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">safe.js文件—取自<a class="ae kv" href="https://www.npmjs.com/package/safe-regex" rel="noopener ugc nofollow" target="_blank"> npm </a></p></figure><p id="8f51" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们可以在上面的文件中输入各种类型的正则表达式来检查它们是否安全。</p><pre class="kg kh ki kj gt oe oc of og aw oh bi"><span id="91b0" class="nk mo iq oc b gy oi oj l ok ol">$ node safe.js '(x+x+)+y'<br/>false<br/>$ node safe.js '(beep|boop)*'<br/>true<br/>$ node safe.js '(a+){10}'<br/>false<br/>$ node safe.js '\blocation\s*:[^:\n]+\b(Oakland|San Francisco)\b'<br/>true</span></pre><p id="582c" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这有时可能会产生假阳性，所以我们必须小心使用。</p></div><div class="ab cl mg mh hu mi" role="separator"><span class="mj bw bk mk ml mm"/><span class="mj bw bk mk ml mm"/><span class="mj bw bk mk ml"/></div><div class="ij ik il im in"><h1 id="4b52" class="mn mo iq bd mp mq mr ms mt mu mv mw mx jw my jx mz jz na ka nb kc nc kd nd ne bi translated">结论</h1><p id="cfe9" class="pw-post-body-paragraph kw kx iq ky b kz nf jr lb lc ng ju le lf nh lh li lj ni ll lm ln nj lp lq lr ij bi translated">因此，通过实施上述安全措施，我们可以确保我们的应用程序比大多数web应用程序更安全。但是我们不能保证安全，因为每天都有新的攻击web应用程序的方法出现。所以我们必须跟上时代，小心谨慎。</p><p id="9b37" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我的文章快结束了，这是一篇相当长的文章。但是我希望你能从这篇文章中学到一些有价值的东西。感谢您花时间阅读本文。希望以后能给大家带来更多的内容。干杯！</p></div><div class="ab cl mg mh hu mi" role="separator"><span class="mj bw bk mk ml mm"/><span class="mj bw bk mk ml mm"/><span class="mj bw bk mk ml"/></div><div class="ij ik il im in"><h1 id="9f83" class="mn mo iq bd mp mq mr ms mt mu mv mw mx jw my jx mz jz na ka nb kc nc kd nd ne bi translated">资源</h1><ul class=""><li id="bdec" class="ls lt iq ky b kz nf lc ng lf om lj on ln oo lr lx ly lz ma bi translated"><a class="ae kv" href="https://cheatsheetseries.owasp.org/cheatsheets/Nodejs_Security_Cheat_Sheet.html#nodejs-security-cheat-sheet" rel="noopener ugc nofollow" target="_blank"> OWASP的Node.js安全备忘单</a></li><li id="c05a" class="ls lt iq ky b kz mb lc mc lf md lj me ln mf lr lx ly lz ma bi translated"><a class="ae kv" href="https://blog.risingstack.com/node-js-security-checklist/" rel="noopener ugc nofollow" target="_blank"> RisingStack的Node.js安全清单</a></li><li id="9ed5" class="ls lt iq ky b kz mb lc mc lf md lj me ln mf lr lx ly lz ma bi translated"><a class="ae kv" href="https://www.npmjs.com/" rel="noopener ugc nofollow" target="_blank"> npm </a> —包含所有节点包</li><li id="4f26" class="ls lt iq ky b kz mb lc mc lf md lj me ln mf lr lx ly lz ma bi translated"><a class="ae kv" href="https://github.com/vanhauser-thc/thc-hydra" rel="noopener ugc nofollow" target="_blank">hydra</a>——一个POC工具，用于测试我们的应用程序如何响应暴力攻击</li><li id="b2cd" class="ls lt iq ky b kz mb lc mc lf md lj me ln mf lr lx ly lz ma bi translated">Snyk  —一种工具，用于查找和修复开源库和容器中的安全漏洞</li></ul></div></div>    
</body>
</html>