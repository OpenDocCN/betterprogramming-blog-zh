# 为什么要在 Python 中使用属性装饰器呢？

> 原文：<https://betterprogramming.pub/why-bother-using-property-decorators-in-python-935c425f86ed>

## 对@property 有了更深入的了解

![](img/4e35b3d0b817f0b02dbecb924beb1286.png)

Radek Grzybowski 在 [Unsplash](https://unsplash.com?utm_source=medium&utm_medium=referral) 上拍摄的照片

要掌握任何编程语言，你都必须学习样本代码——Python 也不例外。作为一种面向对象的编程语言，Python 允许我们定义自定义类，这一特性允许我们优雅地对相关数据和功能进行分组。

在回顾一些经验丰富的 Python 程序员的代码时，您可能会遇到在自定义类中使用`@property`的情况。此时，您可能已经知道这是 Python decorators 的语法，以及 decorator 是什么。然而，你可能已经学过的教程大多是一般性的讨论——其中一些很可能使用了`@property`作为例子。然而，你不知道在什么场景下使用 decorators 才是正确的。你还在想*为什么我们要在 Python 中使用属性装饰器*。

在本文中，您将简要了解如何使用属性装饰器的语法。从下面的第一部分可以看出，通过采用点符号访问，可以使定义的属性变得简洁，从而增加代码的可读性。您还将了解使用属性装饰器的四个基本好处，以及在您自己的代码中实现这一特性的一些通用指南。

# 基本语法

下面的代码片段向您展示了自定义类中属性装饰器的基本语法。我们将`@property`应用到我们想要装饰的属性中。在本例中，它是`Mask`实例对象的`price`。我们还为`price`属性定义了 setter 和 deleter 方法。通过实现这些方法，我们可以像访问常规属性一样访问、更新和删除属性。

实现属性装饰器

顺便提一下，我们使用下划线作为前缀来创建`_price`属性，这表明该属性是“私有的”众所周知，这不是真正的私有，因为其他模块仍然可以访问它。关于下划线不同含义的更多信息，请参考我以前关于这个主题的文章。

[](https://medium.com/better-programming/not-all-underscores-are-equal-in-python-b50768124092) [## 在 Python 中，并不是所有的下划线都相等

### 了解每个单词的含义

medium.com](https://medium.com/better-programming/not-all-underscores-are-equal-in-python-b50768124092) 

# 原因 1:数据验证

理解了基本语法之后，我们就可以开始有趣的部分了——decorator。使用属性装饰器的第一个好处是允许我们在设置属性时验证数据。

对于我们的例子，需要检查要设置的价格是否是一个有效的正数。此外，我们需要为价格设定一个上限。我们希望防止有人以高得离谱的价格出售口罩，尤其是在冠状病毒爆发期间。

让我们升级上面的代码来实现这些数据验证检查:

更新的 Setter

有了这个更新的 setter，我们可以在定价时验证我们的数据。以下代码片段向您展示了各种可能的场景:

数据有效性

# 原因 2:数据操作(封装)

有时，我们访问一个对象的属性的唯一场合是为了数据显示的目的，这样，如果检索价格的 API 返回一个已经格式化的值，它会更友好。考虑我们示例的以下升级:

更新的 Getter

使用更新的 getter 方法，我们可以直接获得格式化的值:

获取格式化的值

实际上，我们可以通过基于应用程序的语言环境提供额外的定制来使其更加强大。考虑下面的假设示例，我们的应用程序将部署在美国和英国:

Getter 方法:一般示例

除了 getter 方法上的数据操作，如果这是一个合理的特性，我们还可以将一些相关的代码应用到 setter 方法上。我们不会在这个话题上展开太多，但是下面显示了一个简化的例子。

Setter 方法上的数据操作

## 原因三:懒加载

如果您来自不同的编程背景，比如 Swift 或 Kotlin，您应该熟悉惰性加载的概念。本质上，我们可以推迟工作，直到相关数据被实际请求，这样我们就可以在对象被实例化时不预先加载所有属性，从而节省时间和内存。

将这种惰性加载概念应用于属性装饰器，我们还可以创建一些仅支持 getter 的属性，如下面的代码片段所示。换句话说，属性装饰者只实现 getters 函数是可以的。

属性的延迟加载

可以看到，创建实例对象`mask5`后，存储的属性只包括`category`和`_price`，如使用内置`__dict__`函数所示。当我们访问像`promotion_price`和`sales_price`这样的各种属性时，所需的计算是在数据检索时完成的。

如果您还记得，我们可以将 decorators 概念化为接受其他函数的函数包装器。这些属性只是函数，访问这些属性实质上就是调用它们。与此相关的一点是，函数也是 Python 中的一级对象，因此它们可以在调用其他函数时用作参数。

[](https://medium.com/swlh/everything-is-an-object-in-python-learn-to-use-functions-as-objects-ace7f30e283e) [## 在 Python 中，一切都是对象——学习使用函数作为对象

### 就像 str、int、dict 一样，函数也是 Python 中的对象。了解我们如何利用这一特性…

medium.com](https://medium.com/swlh/everything-is-an-object-in-python-learn-to-use-functions-as-objects-ace7f30e283e) 

# 原因 4:调试和监控

当这个项目的范围扩大时，许多其他模块开始使用这个自定义类。项目中的多个地方可能会访问和更新同一个对象，这可能会引入不一致甚至错误。因此，了解对象的特定属性在其生命周期中是如何变化的会很有用。

如果没有 getter 和 setter 方法，就不容易知道到底发生了什么。实现属性装饰器为我们记录这些更新记录创造了机会，这对调试和数据监控非常有用。

调试和监控

在上面的代码中，我们更新了 setter 和 deleter 方法，这将记录相关事件。重要的是，当出现一些异常事件时，例如将价格提高到 10 英镑以上，我们会将它们记录到应急日志中，该日志可以链接到一些警报系统，要求立即关注和调查。

# 结论

在本文中，我们回顾了在 Python 中使用属性装饰器的四个好处。特别是在大型项目中，属性装饰器在获取和设置某些属性方面给了我们更多的灵活性。在适用的情况下，我们可以封装各种操作，而不会将无关的 API 暴露给其他模块。更重要的是，我们可以记录关键事件，以便及时调试和监控数据。