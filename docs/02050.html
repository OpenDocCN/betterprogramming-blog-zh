<html>
<head>
<title>@ngrx/data Will Change Your Life</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">@ngrx/data将改变你的生活</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/ngrx-data-will-change-your-life-8528736e4fc0?source=collection_archive---------1-----------------------#2019-11-03">https://betterprogramming.pub/ngrx-data-will-change-your-life-8528736e4fc0?source=collection_archive---------1-----------------------#2019-11-03</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="0254" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">移除React样板文件并简化您的代码库</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/2f13d36611e66cc6e5fb862a08176c9d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*RKDfRcuWOmvB9vAc"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">由<a class="ae ky" href="https://unsplash.com/@benwhitephotography?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">本·怀特</a>在<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</p></figure><p id="cd06" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我已经使用某种形式的<a class="ae ky" href="https://redux.js.org/" rel="noopener ugc nofollow" target="_blank"> Redux </a>模式好几年了，除了一些小的例外，我每次都在做同样的事情——创建实体、读取它们、更新它们、删除它们。</p><p id="edf7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">CRUD应用程序仍然是我作为前端开发人员的主要工作。我脑海深处的一个小小的声音告诉我，我应该找到一种方法来减少我一直在写的锅炉板，但我脑海中的一个更大的声音却在津津乐道于通过每次连续的实施来调整我的方法。</p><p id="ae36" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我将是第一个承认某些<a class="ae ky" href="https://ngrx.io/" rel="noopener ugc nofollow" target="_blank"> NgRx </a>感觉有些过头了——我很少使用像<code class="fe lv lw lx ly b">createSelector</code>这样的东西，也很少使用副作用。</p><p id="f68c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">大多数时候，我觉得自己做得“不对”，但对我来说已经足够对了。尽管如此，我还是有点希望下一次我可能会灵光一现，引导我去做“正确的”事情。</p><p id="1268" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">然后，我参加了约翰·帕帕和沃德·贝尔在AngularConnect 2019举办的研讨会，当时他们用<a class="ae ky" href="https://ngrx.io/guide/data" rel="noopener ugc nofollow" target="_blank"> @ngrx/data </a>把我的小脑袋轰出了脑壳。</p><p id="a421" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这是我一直在等待的库，但为了确保我们都在同一页上，让我们谈谈我如何用@ngrx/store来做这些事情。</p><p id="156f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">声明:我没有测试就凭记忆写了下面的片段——它们缺少了一些，如果它们真的能工作，我会很惊讶。然而，它们大部分是正确的，并且代表了我试图展示的工作类型。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="lz ma l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">简单客户商店的操作和缩减器</p></figure><p id="08dc" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">上面的代码片段缺少一些明显的部分:它们没有连接到<code class="fe lv lw lx ly b">AppModule</code>并且对持久化数据没有影响。</p><p id="b728" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">但是你可以看到，对于一个相对简单的例子，总共有62行代码。这并不可怕，而且对于采用一种随着应用程序增长而难以置信地扩展的模式来说，这是很小的代价。</p><p id="3628" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">但是当您想要实现另一个实体类型的状态(例如，产品、订单等)时，您将不得不编写同样的62行代码。).</p><p id="5eee" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">除此之外，从API获取数据的效果是另一个很大的时间消耗，需要您考虑数据加载时的信号等问题(通常，您将通过API加载，延迟可能是一个问题)。</p><p id="1090" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">也许更重要的是，这是你必须为之编写测试的所有代码，因为这是你编写并控制的代码。我倾向于发现Redux使编写测试变得更容易，但是如果你要对你存储的每个实体类型做同样的事情，仍然有很多工作要做。</p><p id="8d2b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这就是<code class="fe lv lw lx ly b">@ngrx/data</code>的用武之地。作者已经确定了这些数据之间的共性，并编写了一个库来处理这些数据。您需要做的只是提供一个配置。这里有一个例子:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="lz ma l"/></div></figure><p id="9ae3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这已经减少到22行代码了。还有这个:它包含了一个默认行为，通过一个使用效果的RESTful API持久化数据。它假设您使用正确的HTTP动词与API进行交互。</p><p id="d213" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">例如，如果您有以下端点，<code class="fe lv lw lx ly b">DefaultDataService</code>将通过REST持久化数据，无需配置:</p><ul class=""><li id="0874" class="mb mc it lb b lc ld lf lg li md lm me lq mf lu mg mh mi mj bi translated">/API/客户(后)</li><li id="5491" class="mb mc it lb b lc mk lf ml li mm lm mn lq mo lu mg mh mi mj bi translated">/api/customer/:id(获取、放置或删除)</li><li id="5486" class="mb mc it lb b lc mk lf ml li mm lm mn lq mo lu mg mh mi mj bi translated">/API/客户(GET)</li></ul><p id="ad3f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果你根本不想要任何效果，你可以很容易地配置你的商店不使用任何效果。如果您希望以另一种方式持久化数据，可以通过编写自己的数据服务来实现。</p><p id="f010" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">例如，我想为我正在构建的手机应用程序将实体数据持久化到本地存储，所以我编写了这个服务:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="lz ma l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">LocalStorageDataService示例</p></figure><p id="ee1b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">您可以在自己的工作中随意重用它——它并不完整，但演示了如何连接除默认行为之外的其他行为。</p><p id="ade6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">重要的部分(除了实际的服务)是你注册服务的地方(见<code class="fe lv lw lx ly b">AppModule</code>的构造函数)。美妙之处在于，这个服务可以用于任何类型，尽管它假设存在ID列。</p></div><div class="ab cl mp mq hx mr" role="separator"><span class="ms bw bk mt mu mv"/><span class="ms bw bk mt mu mv"/><span class="ms bw bk mt mu"/></div><div class="im in io ip iq"><h1 id="f680" class="mw mx it bd my mz na nb nc nd ne nf ng jz nh ka ni kc nj kd nk kf nl kg nm nn bi translated">结论</h1><p id="9b65" class="pw-post-body-paragraph kz la it lb b lc no ju le lf np jx lh li nq lk ll lm nr lo lp lq ns ls lt lu im bi translated">对于任何对Redux感兴趣的开发人员来说，学习@ngrx/data都是非常值得的——无论您是否已经在使用ngrx(这种情况下，它将节省您的时间),或者您是否因为它看起来令人生畏而从未迈出这一步(在这种情况下，它将为您打开大门)。</p><p id="ccca" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">您需要测试的东西更少，需要实现的东西更少，需要担心的东西更少。</p><p id="0913" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">该文档是一个福音，您绝对应该用一个简单的应用程序来尝试一下。</p><p id="686a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">它与常规NgRx配合得很好，所以您可以将实体数据与更多定制的状态管理混合和匹配。去https://ngrx.io/guide/data的<a class="ae ky" href="https://ngrx.io/guide/data" rel="noopener ugc nofollow" target="_blank">看看吧。</a></p></div></div>    
</body>
</html>