<html>
<head>
<title>How to Not Fragment Memory When Using C++ STL Containers</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何在使用C++ STL容器时不产生内存碎片</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/how-to-not-fragment-memory-when-using-c-stl-containers-b634adb76dc1?source=collection_archive---------1-----------------------#2021-11-23">https://betterprogramming.pub/how-to-not-fragment-memory-when-using-c-stl-containers-b634adb76dc1?source=collection_archive---------1-----------------------#2021-11-23</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="7386" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">为什么STL容器会造成内存碎片，如何避免</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/02b73639e1add96d7dcc2b1ddf5c9d07.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*7RJSrUwjd9J75rGR"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">杰里米·贝赞格在<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</p></figure><h1 id="1565" class="kz la it bd lb lc ld le lf lg lh li lj jz lk ka ll kc lm kd ln kf lo kg lp lq bi translated">STL容器如何分配内存——块和组块</h1><p id="21bb" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">STL容器提供了各种数据结构，我们在用C++编码时可以方便地使用这些结构。有三种类型的容器:</p><ul class=""><li id="886c" class="mn mo it lt b lu mp lx mq ma mr me ms mi mt mm mu mv mw mx bi translated">序列容器</li><li id="0564" class="mn mo it lt b lu my lx mz ma na me nb mi nc mm mu mv mw mx bi translated">关联容器</li><li id="e6c5" class="mn mo it lt b lu my lx mz ma na me nb mi nc mm mu mv mw mx bi translated">无序关联容器</li></ul><p id="b60b" class="pw-post-body-paragraph lr ls it lt b lu mp ju lw lx mq jx lz ma nd mc md me ne mg mh mi nf mk ml mm im bi translated">序列容器是可以顺序访问的容器，而关联容器是那些以键值对或仅键的形式存在的容器。</p><ul class=""><li id="b4c4" class="mn mo it lt b lu mp lx mq ma mr me ms mi mt mm mu mv mw mx bi translated">有序:实现为自平衡树</li><li id="1000" class="mn mo it lt b lu my lx mz ma na me nb mi nc mm mu mv mw mx bi translated">无序:实现为哈希表</li></ul><p id="5a97" class="pw-post-body-paragraph lr ls it lt b lu mp ju lw lx mq jx lz ma nd mc md me ne mg mh mi nf mk ml mm im bi translated">在内部，除了<code class="fe ng nh ni nj b">std::array</code>之外的所有容器都动态分配内存来存储我们的数据。<code class="fe ng nh ni nj b">std::array</code>只是一个类C数组的包装器，它将我们的数据存储在适当的位置。在本文中，我们关注的是STL容器，而不是动态分配内存的<code class="fe ng nh ni nj b">std::array</code>。</p><h2 id="3d81" class="nk la it bd lb nl nm dn lf nn no dp lj ma np nq ll me nr ns ln mi nt nu lp nv bi translated">分配器类</h2><p id="db8c" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">当我们构造一个像<code class="fe ng nh ni nj b">std::vector</code>这样的容器时，有两个模板参数可以设置。</p><ul class=""><li id="9fc5" class="mn mo it lt b lu mp lx mq ma mr me ms mi mt mm mu mv mw mx bi translated">元素类型</li><li id="260c" class="mn mo it lt b lu my lx mz ma na me nb mi nc mm mu mv mw mx bi translated">用于分配/释放内存和构造/销毁对象的分配器</li></ul><p id="8527" class="pw-post-body-paragraph lr ls it lt b lu mp ju lw lx mq jx lz ma nd mc md me ne mg mh mi nf mk ml mm im bi translated">在大多数情况下，我们省略了第二个参数，默认使用<code class="fe ng nh ni nj b">std::allocator</code>。STL容器为我们提供了使用任何我们想要使用的分配器的灵活性，只要它满足分配器的<a class="ae ky" href="https://en.cppreference.com/w/cpp/named_req/Allocator" rel="noopener ugc nofollow" target="_blank">需求</a>。</p><p id="5aa0" class="pw-post-body-paragraph lr ls it lt b lu mp ju lw lx mq jx lz ma nd mc md me ne mg mh mi nf mk ml mm im bi translated">现在，让我们编写一个分配器，它遵循调试目的的要求(详见链接页面),以理解不同容器的行为。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nw nx l"/></div></figure><h2 id="5e23" class="nk la it bd lb nl nm dn lf nn no dp lj ma np nq ll me nr ns ln mi nt nu lp nv bi translated"><code class="fe ng nh ni nj b">std::vector</code></h2><p id="a14f" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">下面的代码展示了我们如何使用分配器并向我们的<code class="fe ng nh ni nj b">std::vector</code>添加三个元素。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nw nx l"/></div></figure><p id="18be" class="pw-post-body-paragraph lr ls it lt b lu mp ju lw lx mq jx lz ma nd mc md me ne mg mh mi nf mk ml mm im bi translated">引擎盖下发生的事情如下:</p><ul class=""><li id="207f" class="mn mo it lt b lu mp lx mq ma mr me ms mi mt mm mu mv mw mx bi translated">在第5行<code class="fe ng nh ni nj b">std::vector</code>请求分配1个int</li><li id="f421" class="mn mo it lt b lu my lx mz ma na me nb mi nc mm mu mv mw mx bi translated">在第6行<code class="fe ng nh ni nj b">std::vector</code>请求分配2个int和释放1个int <br/>注意，我们在这里分配了一个新块并释放了旧块。</li><li id="00da" class="mn mo it lt b lu my lx mz ma na me nb mi nc mm mu mv mw mx bi translated">在第7行<code class="fe ng nh ni nj b">std::vector</code>请求分配4个整数并解除分配2个整数</li><li id="f742" class="mn mo it lt b lu my lx mz ma na me nb mi nc mm mu mv mw mx bi translated">在第10行<code class="fe ng nh ni nj b">std::vector</code>超出了作用域并释放了4个整数</li></ul><p id="1f5a" class="pw-post-body-paragraph lr ls it lt b lu mp ju lw lx mq jx lz ma nd mc md me ne mg mh mi nf mk ml mm im bi translated">我们的代码将打印以下内容:</p><pre class="kj kk kl km gt ny nj nz oa aw ob bi"><span id="b381" class="nk la it nj b gy oc od l oe of">Allocating: 1 elements<br/>Allocating: 2 elements<br/>Deallocating: 1 elements<br/>Allocating: 4 elements<br/>Deallocating: 2 elements<br/>Deallocating: 4 elements</span></pre><p id="e6de" class="pw-post-body-paragraph lr ls it lt b lu mp ju lw lx mq jx lz ma nd mc md me ne mg mh mi nf mk ml mm im bi translated">我们没有在分配器中打印对象的构造和销毁，因为我们想把重点放在分配和释放上。但是，发生的情况是，对于每个元素，两个函数都将被调用，例如，在为四个元素分配内存之后，构造函数将被调用四次。</p><p id="b964" class="pw-post-body-paragraph lr ls it lt b lu mp ju lw lx mq jx lz ma nd mc md me ne mg mh mi nf mk ml mm im bi translated">现在我们证明<code class="fe ng nh ni nj b">std::vector</code>每次达到它可以存储的最大元素数量时，内存块的大小都会翻倍。这包括将对象从以前的块复制到新的块。</p><p id="b9d3" class="pw-post-body-paragraph lr ls it lt b lu mp ju lw lx mq jx lz ma nd mc md me ne mg mh mi nf mk ml mm im bi translated">这就是为什么它在分配新的块之后，会释放前一个块，也就是把数据复制到新的块。</p><p id="a415" class="pw-post-body-paragraph lr ls it lt b lu mp ju lw lx mq jx lz ma nd mc md me ne mg mh mi nf mk ml mm im bi translated">另一件有趣的事情是，<code class="fe ng nh ni nj b">std::vector</code>中的<code class="fe ng nh ni nj b">reserve()</code>函数会在我们添加数据之前调用我们的<code class="fe ng nh ni nj b">allocate()</code>函数。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nw nx l"/></div></figure><p id="ee3b" class="pw-post-body-paragraph lr ls it lt b lu mp ju lw lx mq jx lz ma nd mc md me ne mg mh mi nf mk ml mm im bi translated">事情是这样的:</p><pre class="kj kk kl km gt ny nj nz oa aw ob bi"><span id="b735" class="nk la it nj b gy oc od l oe of">Allocating: 3 elements<br/>Deallocating: 3 elements</span></pre><p id="e671" class="pw-post-body-paragraph lr ls it lt b lu mp ju lw lx mq jx lz ma nd mc md me ne mg mh mi nf mk ml mm im bi translated">好像比上一个版本好多了。在这种情况下，分配只发生一次。这就是为什么人们说如果你知道确切的尺寸，你应该在建造你的<code class="fe ng nh ni nj b">std::vector</code>时预留空间。</p><h2 id="7a5b" class="nk la it bd lb nl nm dn lf nn no dp lj ma np nq ll me nr ns ln mi nt nu lp nv bi translated">std::deque</h2><p id="1dbb" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">双端队列在内存分配/释放方面表现不同。如果我们简单地用<code class="fe ng nh ni nj b">std::deque</code>替换<code class="fe ng nh ni nj b">std::vector</code>，我们会看到不同的行为。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nw nx l"/></div></figure><p id="f630" class="pw-post-body-paragraph lr ls it lt b lu mp ju lw lx mq jx lz ma nd mc md me ne mg mh mi nf mk ml mm im bi translated">顾名思义，使用双端队列，我们可以将数据添加到存储的前端和后端。现在，让我们看看它是如何分配内存的。</p><pre class="kj kk kl km gt ny nj nz oa aw ob bi"><span id="40e5" class="nk la it nj b gy oc od l oe of">Allocating: 8 elements<br/>Allocating: 128 elements<br/>Allocating: 128 elements<br/>Deallocating: 128 elements<br/>Deallocating: 128 elements<br/>Deallocating: 8 elements</span></pre><p id="270c" class="pw-post-body-paragraph lr ls it lt b lu mp ju lw lx mq jx lz ma nd mc md me ne mg mh mi nf mk ml mm im bi translated">所以，它分配了多余的空间，这是因为在内部，它通过一个<code class="fe ng nh ni nj b">map</code>来存储每个块的起始地址，初始大小为<code class="fe ng nh ni nj b">8</code>，并分配可以存储<code class="fe ng nh ni nj b">128</code>元素的内存块。这是特定于实现的，我使用的是GCC。</p><h2 id="bf0d" class="nk la it bd lb nl nm dn lf nn no dp lj ma np nq ll me nr ns ln mi nt nu lp nv bi translated">有序关联容器</h2><p id="a6ab" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">对于有序关联容器，因为它们是作为自平衡树实现的，所以可以想象分配是针对每个节点的。如果我们检查以下代码的输出，我们会看到代码试图逐个节点地分配。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nw nx l"/></div></figure><pre class="kj kk kl km gt ny nj nz oa aw ob bi"><span id="bd50" class="nk la it nj b gy oc od l oe of">Allocating: 1 elements<br/>Allocating: 1 elements<br/>Allocating: 1 elements<br/>Deallocating: 1 elements<br/>Deallocating: 1 elements<br/>Deallocating: 1 elements</span></pre><h2 id="bc4b" class="nk la it bd lb nl nm dn lf nn no dp lj ma np nq ll me nr ns ln mi nt nu lp nv bi translated">无序关联容器</h2><p id="6acb" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">无序关联容器被实现为哈希表，这意味着它将使用一些内部状态来管理存储桶。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nw nx l"/></div></figure><p id="df89" class="pw-post-body-paragraph lr ls it lt b lu mp ju lw lx mq jx lz ma nd mc md me ne mg mh mi nf mk ml mm im bi translated">它不仅为我们的数据分配内存，还为管理内部状态(桶)分配内存。</p><pre class="kj kk kl km gt ny nj nz oa aw ob bi"><span id="3dbd" class="nk la it nj b gy oc od l oe of">Allocating: 1 elements<br/>Allocating: 13 elements<br/>Allocating: 1 elements<br/>Allocating: 1 elements<br/>Deallocating: 1 elements<br/>Deallocating: 1 elements<br/>Deallocating: 1 elements<br/>Deallocating: 13 elements</span></pre><h2 id="fb8a" class="nk la it bd lb nl nm dn lf nn no dp lj ma np nq ll me nr ns ln mi nt nu lp nv bi translated">为STL容器编写自定义分配器</h2><p id="8da8" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">现在我们知道了STL容器如何使用分配器，我们将讨论为什么在某些情况下我们想要为我们的应用程序编写自定义分配器，并在接下来的章节中看看我们如何实现它们。</p><h1 id="432b" class="kz la it bd lb lc ld le lf lg lh li lj jz lk ka ll kc lm kd ln kf lo kg lp lq bi translated">STL容器如何分割内存</h1><p id="eced" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">如果我们在C++中分配/释放内存时不小心，我们可能会导致内存碎片。这是一种情况，其中<em class="og">小内存块</em>在较大内存块之间分配，导致系统在请求时由于碎片而无法分配大内存块。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi oh"><img src="../Images/98616f850f61d49c2f7eddce99d1bcda.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*lh1VVE3jfbhx81dquDSz1Q.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">内存碎片(作者图片)</p></figure><p id="b4a6" class="pw-post-body-paragraph lr ls it lt b lu mp ju lw lx mq jx lz ma nd mc md me ne mg mh mi nf mk ml mm im bi translated">我已经介绍了像<code class="fe ng nh ni nj b">std::any</code>这样的库在用于分配具有不同生命周期的小对象时是如何分割内存的。细节在下面的文章里。</p><div class="oi oj gp gr ok ol"><a rel="noopener  ugc nofollow" target="_blank" href="/c-memory-pool-and-small-object-allocator-8f27671bd9ee"><div class="om ab fo"><div class="on ab oo cl cj op"><h2 class="bd iu gy z fp oq fr fs or fu fw is bi translated">C++内存池和小对象分配器</h2><div class="os l"><h3 class="bd b gy z fp oq fr fs or fu fw dk translated">理解在C++中如何控制小对象的内存分配/释放以避免内存碎片</h3></div><div class="ot l"><p class="bd b dl z fp oq fr fs or fu fw dk translated">better编程. pub</p></div></div><div class="ou l"><div class="ov l ow ox oy ou oz ks ol"/></div></div></a></div><p id="42e7" class="pw-post-body-paragraph lr ls it lt b lu mp ju lw lx mq jx lz ma nd mc md me ne mg mh mi nf mk ml mm im bi translated">STL容器呢？哪些容器，在什么条件下会造成碎片？</p><h2 id="4da9" class="nk la it bd lb nl nm dn lf nn no dp lj ma np nq ll me nr ns ln mi nt nu lp nv bi translated">STL容器和内存碎片</h2><p id="3e73" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">除了<code class="fe ng nh ni nj b">std::array</code>之外的所有容器都会导致内存碎片。值得一提的是，<code class="fe ng nh ni nj b">std::deque</code>也不太可能出现这种情况，因为它内部管理内存的方式我们在前面的章节中已经介绍过了。</p><p id="96eb" class="pw-post-body-paragraph lr ls it lt b lu mp ju lw lx mq jx lz ma nd mc md me ne mg mh mi nf mk ml mm im bi translated">对于<code class="fe ng nh ni nj b">std::vector</code>来说，当我们用它来存储<em class="og">小对象</em>的少量元素时，就会发生这种情况。当我们用它来存储许多元素时，由于它是如何分配内存的，这就不那么令人担心了(见上一节)。</p><p id="ddb6" class="pw-post-body-paragraph lr ls it lt b lu mp ju lw lx mq jx lz ma nd mc md me ne mg mh mi nf mk ml mm im bi translated">对于另一些，因为它们是按对象/节点分配的，所以不管元素的数量是多少，仍然会导致内存分段。</p><blockquote class="pa pb pc"><p id="00f5" class="lr ls og lt b lu mp ju lw lx mq jx lz pd nd mc md pe ne mg mh pf nf mk ml mm im bi translated">当我们使用STL容器在整个运行期间动态添加新的小对象并保持它们足够长的时间，或者更糟的是从不删除它们时，这很可能发生。</p></blockquote><p id="54e9" class="pw-post-body-paragraph lr ls it lt b lu mp ju lw lx mq jx lz ma nd mc md me ne mg mh mi nf mk ml mm im bi translated">为了进行演示，请考虑下面的代码，它每一到十秒钟添加一个新对象。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nw nx l"/></div></figure><p id="5aea" class="pw-post-body-paragraph lr ls it lt b lu mp ju lw lx mq jx lz ma nd mc md me ne mg mh mi nf mk ml mm im bi translated">在我们应用程序的其他部分，我们分配更大的块，例如<code class="fe ng nh ni nj b">10 MB</code>、<code class="fe ng nh ni nj b">15 MB</code>、<code class="fe ng nh ni nj b">25 MB</code>，临时用于数据处理。这意味着我们分配和释放它们。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi pg"><img src="../Images/8f7ec3987b0a58045df257714b855ab6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*S0YIdozAY3XKUAgwhJlpww.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">内存碎片图解(图片由作者提供)</p></figure><p id="a16d" class="pw-post-body-paragraph lr ls it lt b lu mp ju lw lx mq jx lz ma nd mc md me ne mg mh mi nf mk ml mm im bi translated">上图展示了在这个用例中内存是如何被分割的。这只是为了举例说明，实际上，很难预测内存会是什么样子。重要的是我们知道它可以被分割。</p><p id="a18c" class="pw-post-body-paragraph lr ls it lt b lu mp ju lw lx mq jx lz ma nd mc md me ne mg mh mi nf mk ml mm im bi translated">当您在一个整体应用程序的大型代码库上工作时，尤其如此。您无法控制应用程序的其他部分。</p><h1 id="11c8" class="kz la it bd lb lc ld le lf lg lh li lj jz lk ka ll kc lm kd ln kf lo kg lp lq bi translated">如何避免内存碎片—使用内存池</h1><p id="8755" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">幸运的是，STL容器为我们提供了一种方法，通过我们可以传递给STL容器的构造函数的分配器类来控制我们如何分配内存。</p><p id="69d7" class="pw-post-body-paragraph lr ls it lt b lu mp ju lw lx mq jx lz ma nd mc md me ne mg mh mi nf mk ml mm im bi translated">默认情况下，如果我们不指定它，我们将使用<code class="fe ng nh ni nj b">std::allocator</code>。没有标准规定<code class="fe ng nh ni nj b">std::allocator</code>如何分配内存。它是特定于实现的。GCC默认使用<strong class="lt iu">新分配器</strong>，它使用<code class="fe ng nh ni nj b">::operator new</code>和<code class="fe ng nh ni nj b">::operator delete</code>分配和释放内存。</p><p id="f86b" class="pw-post-body-paragraph lr ls it lt b lu mp ju lw lx mq jx lz ma nd mc md me ne mg mh mi nf mk ml mm im bi translated">GCC也提供了我们可以使用的扩展分配器，详见这个<a class="ae ky" href="https://gcc.gnu.org/onlinedocs/libstdc++/manual/memory.html#std.util.memory.allocator" rel="noopener ugc nofollow" target="_blank">链接</a>。</p><p id="8b91" class="pw-post-body-paragraph lr ls it lt b lu mp ju lw lx mq jx lz ma nd mc md me ne mg mh mi nf mk ml mm im bi translated">你可能已经从我的另一篇<a class="ae ky" rel="noopener ugc nofollow" target="_blank" href="/c-memory-pool-and-small-object-allocator-8f27671bd9ee">文章</a>中知道，要解决这个问题，我们可以使用内存池。我们可以使用GCC提供的内存池分配器，如<code class="fe ng nh ni nj b">__pool_alloc</code>、<code class="fe ng nh ni nj b">__mt_alloc</code>或<code class="fe ng nh ni nj b">bitmap_allocator</code>，如果您愿意，可以通过扩展获得，但它们不是可移植的。比方说，如果你想改变编译器，你的代码将需要重写。</p><p id="7446" class="pw-post-body-paragraph lr ls it lt b lu mp ju lw lx mq jx lz ma nd mc md me ne mg mh mi nf mk ml mm im bi translated">为了使它具有可移植性，我们可以编写我们的分配器或者使用像Boost这样的库。在本文中，我们将使用<code class="fe ng nh ni nj b">Boost.Pool</code>。</p><h2 id="b9d7" class="nk la it bd lb nl nm dn lf nn no dp lj ma np nq ll me nr ns ln mi nt nu lp nv bi translated">使用Boost。我们的分配者池</h2><p id="6b7b" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated"><code class="fe ng nh ni nj b">Boost.Pool</code>提供了两种使用内存池的分配器，<code class="fe ng nh ni nj b">boost::pool_allocator</code>和<code class="fe ng nh ni nj b">boost::fast_pool_allocator</code>。两个类都使用了<code class="fe ng nh ni nj b">boost::singleton_pool</code>，这意味着只有一个相同类型的池实例，这正是我们所需要的。</p><p id="2070" class="pw-post-body-paragraph lr ls it lt b lu mp ju lw lx mq jx lz ma nd mc md me ne mg mh mi nf mk ml mm im bi translated">两者的区别在于它们如何使用底层池— <code class="fe ng nh ni nj b">boost::singleton_pool</code>来分配内存。<code class="fe ng nh ni nj b">boost::pool_allocator</code>将总是调用<code class="fe ng nh ni nj b">ordered_malloc()</code>来分配连续的块，因此它适用于<code class="fe ng nh ni nj b">std::vector</code>。当请求的元素只有一个时,<code class="fe ng nh ni nj b">boost::fast_pool_allocator</code>将调用<code class="fe ng nh ni nj b">malloc()</code>,这是其余容器分配内存的方式。这是一种更快的方法，因此得名。</p><blockquote class="pa pb pc"><p id="a555" class="lr ls og lt b lu mp ju lw lx mq jx lz pd nd mc md pe ne mg mh pf nf mk ml mm im bi translated">需要注意的一点是，我们作为模板参数传递的类型的大小将决定底层池的类型。相同大小的两种类型将共享同一个池。</p></blockquote><p id="31bf" class="pw-post-body-paragraph lr ls it lt b lu mp ju lw lx mq jx lz ma nd mc md me ne mg mh mi nf mk ml mm im bi translated">现在，对于<code class="fe ng nh ni nj b">std::vector</code>，我们的代码将看起来像这样。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nw nx l"/></div></figure><p id="1671" class="pw-post-body-paragraph lr ls it lt b lu mp ju lw lx mq jx lz ma nd mc md me ne mg mh mi nf mk ml mm im bi translated">而下面是针对<code class="fe ng nh ni nj b">std::map</code>，我们用的是快速池。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nw nx l"/></div></figure><p id="1f1b" class="pw-post-body-paragraph lr ls it lt b lu mp ju lw lx mq jx lz ma nd mc md me ne mg mh mi nf mk ml mm im bi translated">默认情况下，两个池都将为<code class="fe ng nh ni nj b">32</code>元素分配一个初始内存块，并在整个内存块被完全使用时保持两倍的大小。</p><h1 id="d218" class="kz la it bd lb lc ld le lf lg lh li lj jz lk ka ll kc lm kd ln kf lo kg lp lq bi translated">关键要点</h1><ul class=""><li id="2a7f" class="mn mo it lt b lu lv lx ly ma ph me pi mi pj mm mu mv mw mx bi translated">C++没有自动垃圾收集，如果我们在使用STL容器时不小心，我们的代码会导致内存碎片</li><li id="ad9f" class="mn mo it lt b lu my lx mz ma na me nb mi nc mm mu mv mw mx bi translated">当我们使用STL容器存储小的、长寿命的对象时，很可能会出现内存碎片</li><li id="e5d0" class="mn mo it lt b lu my lx mz ma na me nb mi nc mm mu mv mw mx bi translated">STL容器允许我们使用分配器类来控制内存分配/释放，只要它满足分配器类的要求</li><li id="9e58" class="mn mo it lt b lu my lx mz ma na me nb mi nc mm mu mv mw mx bi translated"><code class="fe ng nh ni nj b">Boost.Pool</code>提供使用内存池的分配器，可以防止内存碎片</li><li id="0d8b" class="mn mo it lt b lu my lx mz ma na me nb mi nc mm mu mv mw mx bi translated">我们是否需要使用自定义分配器取决于我们的应用程序，理解内存碎片是如何发生的以及如何避免它是很重要的</li></ul></div></div>    
</body>
</html>