<html>
<head>
<title>Write Better Tests With the “Quick” Library in Go</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用Go中的“快速”库编写更好的测试</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/test-better-with-quick-library-in-go-1bc59074b5b?source=collection_archive---------2-----------------------#2022-06-25">https://betterprogramming.pub/test-better-with-quick-library-in-go-1bc59074b5b?source=collection_archive---------2-----------------------#2022-06-25</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="b7c9" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">知道什么是魔快库吗？</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi kf"><img src="../Images/7b295d40b4b760bd21b087b8f4517481.png" data-original-src="https://miro.medium.com/v2/resize:fit:1280/format:webp/1*wJ8mPAoFAWI5iTyTbC5GBw.jpeg"/></div><p class="kn ko gj gh gi kp kq bd b be z dk translated"><em class="kr">“我的单元测试通过了！”—著名遗言</em></p></figure><blockquote class="ks kt ku"><p id="07c5" class="kv kw kx ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">包<code class="fe ls lt lu lv b">quick</code>实现了实用函数来帮助黑盒测试。</p></blockquote><p id="4ac9" class="pw-post-body-paragraph kv kw iq ky b kz la jr lb lc ld ju le lw lg lh li lx lk ll lm ly lo lp lq lr ij bi translated"><a class="ae lz" href="https://pkg.go.dev/testing/quick" rel="noopener ugc nofollow" target="_blank">测试包</a>中的快速库可用于基于属性的测试。如果你熟悉Haskell 的<a class="ae lz" href="https://hackage.haskell.org/package/QuickCheck" rel="noopener ugc nofollow" target="_blank"> QuickCheck，它们非常相似。</a></p><h2 id="fdfa" class="ma mb iq bd mc md me dn mf mg mh dp mi lw mj mk ml lx mm mn mo ly mp mq mr ms bi translated">让我们整理一下其中一些术语的含义…</h2><p id="7aa3" class="pw-post-body-paragraph kv kw iq ky b kz mt jr lb lc mu ju le lw mv lh li lx mw ll lm ly mx lp lq lr ij bi translated"><strong class="ky ir">基于属性的测试</strong>根据一系列自动生成的输入来验证组件或系统的预期行为，并确保其成立。</p><p id="566f" class="pw-post-body-paragraph kv kw iq ky b kz la jr lb lc ld ju le lw lg lh li lx lk ll lm ly lo lp lq lr ij bi translated"><strong class="ky ir">黑盒测试</strong>涉及在没有任何内部工作知识的情况下测试一个组件或系统。</p><p id="f0c1" class="pw-post-body-paragraph kv kw iq ky b kz la jr lb lc ld ju le lw lg lh li lx lk ll lm ly lo lp lq lr ij bi translated">通过将所有这些部分放在一起，这意味着如果我们知道函数的属性是什么，我们可以使用这个神奇的库对它们进行黑盒测试！</p></div><div class="ab cl my mz hu na" role="separator"><span class="nb bw bk nc nd ne"/><span class="nb bw bk nc nd ne"/><span class="nb bw bk nc nd"/></div><div class="ij ik il im in"><p id="4aeb" class="pw-post-body-paragraph kv kw iq ky b kz la jr lb lc ld ju le lw lg lh li lx lk ll lm ly lo lp lq lr ij bi translated">好了，现在我们知道它的功能了。让我们用一个简单的例子来尝试一下。</p><h2 id="c4d0" class="ma mb iq bd mc md me dn mf mg mh dp mi lw mj mk ml lx mm mn mo ly mp mq mr ms bi translated">减法</h2><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nf ng l"/></div></figure><p id="e298" class="pw-post-body-paragraph kv kw iq ky b kz la jr lb lc ld ju le lw lg lh li lx lk ll lm ly lo lp lq lr ij bi translated">让我们使用上面的例子，并想出几个它的属性的例子:</p><ol class=""><li id="8365" class="nh ni iq ky b kz la lc ld lw nj lx nk ly nl lr nm nn no np bi translated">如果<code class="fe ls lt lu lv b">a &gt; b</code>，结果将是<strong class="ky ir">阳性</strong></li><li id="c62f" class="nh ni iq ky b kz nq lc nr lw ns lx nt ly nu lr nm nn no np bi translated">如果<code class="fe ls lt lu lv b">b &gt; a</code>，结果将是<strong class="ky ir">否定</strong></li><li id="1ec1" class="nh ni iq ky b kz nq lc nr lw ns lx nt ly nu lr nm nn no np bi translated">如果<code class="fe ls lt lu lv b">a == b</code>，结果将是<strong class="ky ir">零</strong></li><li id="3943" class="nh ni iq ky b kz nq lc nr lw ns lx nt ly nu lr nm nn no np bi translated">如果<code class="fe ls lt lu lv b">b &lt; 0</code>，结果将大于<code class="fe ls lt lu lv b">a</code></li><li id="35bd" class="nh ni iq ky b kz nq lc nr lw ns lx nt ly nu lr nm nn no np bi translated">这样的例子不胜枚举…</li></ol><p id="8cf6" class="pw-post-body-paragraph kv kw iq ky b kz la jr lb lc ld ju le lw lg lh li lx lk ll lm ly lo lp lq lr ij bi translated">我觉得数字<code class="fe ls lt lu lv b">4</code>是最有趣的例子！让我们利用这一点！</p><p id="f648" class="pw-post-body-paragraph kv kw iq ky b kz la jr lb lc ld ju le lw lg lh li lx lk ll lm ly lo lp lq lr ij bi translated">传统上，我们将使用基于实例的测试，我们预先定义一些输入和它们各自的输出，断言它们并确保它们相符。例如:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nf ng l"/></div></figure><p id="18d9" class="pw-post-body-paragraph kv kw iq ky b kz la jr lb lc ld ju le lw lg lh li lx lk ll lm ly lo lp lq lr ij bi translated">我们现在有了一个简单的基于实例的测试的例子，它测试了属性号<code class="fe ls lt lu lv b">4</code>。</p><p id="539e" class="pw-post-body-paragraph kv kw iq ky b kz la jr lb lc ld ju le lw lg lh li lx lk ll lm ly lo lp lq lr ij bi translated">然而，这真的够了吗？现在，让我们尝试在相同的属性上使用基于属性的测试！🔍</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nf ng l"/></div></figure><p id="066f" class="pw-post-body-paragraph kv kw iq ky b kz la jr lb lc ld ju le lw lg lh li lx lk ll lm ly lo lp lq lr ij bi translated">这似乎是合理的。我们只关心<code class="fe ls lt lu lv b">b</code>小于<code class="fe ls lt lu lv b">0</code>的测试用例。因此，我们忽略所有<code class="fe ls lt lu lv b">b</code>为正的测试用例。</p><p id="0c93" class="pw-post-body-paragraph kv kw iq ky b kz la jr lb lc ld ju le lw lg lh li lx lk ll lm ly lo lp lq lr ij bi translated">好吧，我们的时间到了！让我们运行这个！</p><pre class="kg kh ki kj gt nv lv nw nx aw ny bi"><span id="df1b" class="ma mb iq lv b gy nz oa l ob oc">--- FAIL: TestSubtractPropertyFour (0.00s)<br/>    sub_test.go:19: #1: failed on input 9071749008449132817, -404711346371707334</span></pre><p id="9860" class="pw-post-body-paragraph kv kw iq ky b kz la jr lb lc ld ju le lw lg lh li lx lk ll lm ly lo lp lq lr ij bi translated">让我手动操作…</p><p id="5fbf" class="pw-post-body-paragraph kv kw iq ky b kz la jr lb lc ld ju le lw lg lh li lx lk ll lm ly lo lp lq lr ij bi translated">如果<code class="fe ls lt lu lv b">a</code>是<code class="fe ls lt lu lv b">9071749008449132817</code>，<code class="fe ls lt lu lv b">b</code>是<code class="fe ls lt lu lv b">-404711346371707334</code>，那就意味着从数学上来说，<code class="fe ls lt lu lv b">9071749008449132817 — (-404711346371707334)</code>就是说<code class="fe ls lt lu lv b">9071749008449132817 + 404711346371707334</code>应该是表达式。这显然意味着我们的财产号<code class="fe ls lt lu lv b">4</code>是真实的。</p><p id="70bd" class="pw-post-body-paragraph kv kw iq ky b kz la jr lb lc ld ju le lw lg lh li lx lk ll lm ly lo lp lq lr ij bi translated">好吧…所以一定是哪里出了问题，是时候找出问题了！</p><p id="6c66" class="pw-post-body-paragraph kv kw iq ky b kz la jr lb lc ld ju le lw lg lh li lx lk ll lm ly lo lp lq lr ij bi translated">有很多方法可以调试这个问题，但是我有点大胆地使用编译器，通过声明上述输入的减法常数来告诉我哪里出错了。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nf ng l"/></div></figure><p id="0234" class="pw-post-body-paragraph kv kw iq ky b kz la jr lb lc ld ju le lw lg lh li lx lk ll lm ly lo lp lq lr ij bi translated">这是Go编译器的结果…</p><pre class="kg kh ki kj gt nv lv nw nx aw ny bi"><span id="2dc6" class="ma mb iq lv b gy nz oa l ob oc">cannot use 9071749008449132817 - (-8970283718888711465) (untyped int constant 18042032727337844282) as int value in constant declaration (overflows)</span></pre><blockquote class="od"><p id="cde7" class="oe of iq bd og oh oi oj ok ol om lr dk translated">🌊🌊🌊🌊🌊🌊啊…所以溢出来了！🌊🌊🌊🌊🌊🌊</p></blockquote><p id="486c" class="pw-post-body-paragraph kv kw iq ky b kz on jr lb lc oo ju le lw op lh li lx oq ll lm ly or lp lq lr ij bi translated">这就对了。我们已经找到了一个测试用例，它将炸毁我们看似无辜的<em class="kx">减法函数。</em></p></div><div class="ab cl my mz hu na" role="separator"><span class="nb bw bk nc nd ne"/><span class="nb bw bk nc nd ne"/><span class="nb bw bk nc nd"/></div><div class="ij ik il im in"><h1 id="f490" class="os mb iq bd mc ot ou ov mf ow ox oy mi jw oz jx ml jz pa ka mo kc pb kd mr pc bi translated">结论</h1><p id="3e26" class="pw-post-body-paragraph kv kw iq ky b kz mt jr lb lc mu ju le lw mv lh li lx mw ll lm ly mx lp lq lr ij bi translated">我们已经见证了基于属性的测试是多么不可思议。使用这个库，我们可以轻松地生成成千上万的随机测试用例，而不是使用基于实例的测试。当然，为您正在编写的每个函数找到属性并不总是一件简单的任务。</p><p id="8938" class="pw-post-body-paragraph kv kw iq ky b kz la jr lb lc ld ju le lw lg lh li lx lk ll lm ly lo lp lq lr ij bi translated">即使你现在可能无法应用它，我相信有一天它会派上用场的！</p></div></div>    
</body>
</html>