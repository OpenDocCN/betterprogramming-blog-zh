<html>
<head>
<title>Exchanging Encrypted Data on Blockchain Using MetaMask</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用元掩码在区块链上交换加密数据</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/exchanging-encrypted-data-on-blockchain-using-metamask-a2e65a9a896c?source=collection_archive---------3-----------------------#2022-03-11">https://betterprogramming.pub/exchanging-encrypted-data-on-blockchain-using-metamask-a2e65a9a896c?source=collection_archive---------3-----------------------#2022-03-11</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="b702" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">关于如何使用本机元掩码加密解密函数的教程</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/3ef8459184027d7cb5ec672a21e74ee7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*3tZA51CHxmKuOxme9oHayg.png"/></div></div></figure><p id="38b9" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">每个以太坊帐户都与私钥/公钥对相关联。一个自然的问题是如何使用这些密钥来加密数据？元掩码支持加密吗？本教程将展示一种用户友好的方式来使用元掩码在区块链上交换加密消息。</p><blockquote class="lq lr ls"><p id="c34c" class="ku kv lt kw b kx ky ju kz la lb jx lc lu le lf lg lv li lj lk lw lm ln lo lp im bi translated">在本教程中，我一直使用TypeScript符号，因为我认为它有助于理解正在发生的事情。如果您使用JavaScript，请从代码中删除这些类型。</p></blockquote><p id="034e" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">在开发我们最新的项目<a class="ae lx" href="https://feltlabs.ai/" rel="noopener ugc nofollow" target="_blank">felt oken</a>——一种分散式保护隐私的机器学习工具——时，我们只需要在区块链的具体账户之间交换数据。每个帐户都与密钥对相关联，其主要目的是对交易进行签名。然而，它也可以用于加密。唯一的问题是，用户的钱包通常会处理这些密钥，要求用户复制他们的私钥是非常糟糕的。使用钱包提供的功能是一个更干净的解决方案。</p><h1 id="42d6" class="ly lz it bd ma mb mc md me mf mg mh mi jz mj ka mk kc ml kd mm kf mn kg mo mp bi translated">公钥密码学</h1><p id="9dee" class="pw-post-body-paragraph ku kv it kw b kx mq ju kz la mr jx lc ld ms lf lg lh mt lj lk ll mu ln lo lp im bi translated">这里只是对公钥加密的一个快速回顾。核心思想是你有公钥和私钥，它们通过一些数学属性联系在一起。如果用公钥加密邮件，只有私钥可以解密。这意味着您可以与其他人共享公钥。然后他们可以用它来加密只有你能解密的信息。此外，加密的工作方式正好相反，通常用于签署消息。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi mv"><img src="../Images/7c5ce5ea9be7058ba1816357a586d843.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*cKdm80TH-ARjnwEuPT4XHg.png"/></div></div><p class="mw mx gj gh gi my mz bd b be z dk translated">基本非对称加密方案</p></figure><p id="dbfc" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">对我们来说至关重要的是，如果Alice想要向Bob发送秘密消息，则需要以下步骤:</p><ol class=""><li id="0717" class="na nb it kw b kx ky la lb ld nc lh nd ll ne lp nf ng nh ni bi translated">鲍勃把他的公钥发送给爱丽丝</li><li id="9f70" class="na nb it kw b kx nj la nk ld nl lh nm ll nn lp nf ng nh ni bi translated">Alice使用Bob的公钥对消息进行加密</li><li id="fe53" class="na nb it kw b kx nj la nk ld nl lh nm ll nn lp nf ng nh ni bi translated">爱丽丝将加密的信息发送给鲍勃</li><li id="453e" class="na nb it kw b kx nj la nk ld nl lh nm ll nn lp nf ng nh ni bi translated">鲍勃用他的私钥解密这条消息</li></ol><p id="df6f" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">不管数量多少，加密技术都是网络中至关重要的一部分，在我看来，每个开发人员都应该至少了解加密技术的基础知识。更多实用信息，我推荐以下书籍:</p><div class="no np gp gr nq nr"><a href="https://cryptobook.nakov.com/asymmetric-key-ciphers" rel="noopener  ugc nofollow" target="_blank"><div class="ns ab fo"><div class="nt ab nu cl cj nv"><h2 class="bd iu gy z fp nw fr fs nx fu fw is bi translated">非对称密钥密码</h2><div class="ny l"><h3 class="bd b gy z fp nw fr fs nx fu fw dk translated">密钥对生成(私钥+公钥)、加密算法(非对称密钥密码和加密方案，如…</h3></div><div class="nz l"><p class="bd b dl z fp nw fr fs nx fu fw dk translated">cryptobook.nakov.com</p></div></div><div class="oa l"><div class="ob l oc od oe oa of ks nr"/></div></div></a></div><h1 id="12c8" class="ly lz it bd ma mb mc md me mf mg mh mi jz mj ka mk kc ml kd mm kf mn kg mo mp bi translated">元掩码加密</h1><p id="ce26" class="pw-post-body-paragraph ku kv it kw b kx mq ju kz la mr jx lc ld ms lf lg lh mt lj lk ll mu ln lo lp im bi translated">幸运的是，MetaMask中有一个原生的<strong class="kw iu">解密</strong>函数。另一方面，加密机制不是标准化的，所以这个功能很可能不被其他钱包支持。不管这些，让我们更详细地看看元掩码解密。</p><p id="619f" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">元掩码文档中提供了关于此函数的大多数信息:</p><div class="no np gp gr nq nr"><a href="https://docs.metamask.io/guide/rpc-api.html#eth-decrypt" rel="noopener  ugc nofollow" target="_blank"><div class="ns ab fo"><div class="nt ab nu cl cj nv"><h2 class="bd iu gy z fp nw fr fs nx fu fw is bi translated">RPC API |元掩码文档</h2><div class="ny l"><h3 class="bd b gy z fp nw fr fs nx fu fw dk translated">MetaMask使用ethereum.request(args)方法包装RPC API。该API基于一个由所有…</h3></div><div class="nz l"><p class="bd b dl z fp nw fr fs nx fu fw dk translated">docs.metamask.io</p></div></div></div></a></div><blockquote class="lq lr ls"><p id="edda" class="ku kv lt kw b kx ky ju kz la lb jx lc lu le lf lg lv li lj lk lw lm ln lo lp im bi translated">我稍后也会提到这一点，但是文档忽略了这样一个事实，即只有当明文包含有效的UTF-8时，解密才有效。它对任意字节序列都不起作用！</p></blockquote><h2 id="f913" class="og lz it bd ma oh oi dn me oj ok dp mi ld ol om mk lh on oo mm ll op oq mo or bi translated">1.鲍勃把他的公钥发送给爱丽丝</h2><p id="ad7f" class="pw-post-body-paragraph ku kv it kw b kx mq ju kz la mr jx lc ld ms lf lg lh mt lj lk ll mu ln lo lp im bi translated">第一步是获得Bob的公钥，并将其发送给Alice。这个密钥是加密所必需的，并且可以公开共享。事实上，您发送的每笔区块链交易都共享这个密钥。您可能已经知道帐户地址与公钥不同。地址是作为公钥的散列来计算的，使得仅仅基于用户地址来计算公钥变得不可能(在我看来，这是一个不幸的决定)。</p><p id="42df" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">我们首先需要从MetaMask请求一个公钥。我们可以使用MetaMask提供的函数<code class="fe os ot ou ov b">eth_getEncryptionPublicKey</code>。使用这个函数相对简单；把账户地址传过去就行了。该应用程序必须能够访问指定的帐户；传递随机账号会失败。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ow ox l"/></div></figure><blockquote class="lq lr ls"><p id="7840" class="ku kv lt kw b kx ky ju kz la lb jx lc lu le lf lg lv li lj lk lw lm ln lo lp im bi translated"><strong class="kw iu">注意:</strong> MetaMask自动将<code class="fe os ot ou ov b">window.ethereum</code>对象注入网站。如果您使用某个库与MataMask通信，您可能需要以不同的方式访问这个对象(请求部分将是相同的)。</p></blockquote><p id="3000" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">现在您已经有了公钥，您可以将它发送给Alice，这样她就可以使用它进行加密。好消息是公钥符合<code class="fe os ot ou ov b">bytes32</code>变量；因此，您可以轻松地将其传递给智能合约。或者您可以使用任何其他方式来交换公钥。</p><h2 id="7a7f" class="og lz it bd ma oh oi dn me oj ok dp mi ld ol om mk lh on oo mm ll op oq mo or bi translated">2.Alice使用Bob的公钥对消息进行加密</h2><p id="dadf" class="pw-post-body-paragraph ku kv it kw b kx mq ju kz la mr jx lc ld ms lf lg lh mt lj lk ll mu ln lo lp im bi translated">一旦我们有了公钥，我们就可以继续加密消息了。您需要从MetaMask: <code class="fe os ot ou ov b"><a class="ae lx" href="https://www.npmjs.com/package/@metamask/eth-sig-util" rel="noopener ugc nofollow" target="_blank">@metamask/eth-sig-util</a> </code>安装一个提供加密功能的包。然后，对于作为<code class="fe os ot ou ov b">Buffer</code>提供的加密数据，我们使用以下函数(公钥与上一步获得的相同):</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ow ox l"/></div></figure><p id="6578" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated"><strong class="kw iu">重要提示:</strong> MetaMask只解密有效的UTF-8序列，所以如果你想发送任意字节，你必须首先使用base64之类的东西对它进行编码。我用的是<code class="fe os ot ou ov b"><a class="ae lx" href="https://www.npmjs.com/package/ascii85" rel="noopener ugc nofollow" target="_blank">ascii85</a></code>包提供的base85。我试图尽可能地节省空间，因为我们将加密数据存储在智能合同中。</p><h2 id="693b" class="og lz it bd ma oh oi dn me oj ok dp mi ld ol om mk lh on oo mm ll op oq mo or bi translated">3.爱丽丝将加密的信息发送给鲍勃</h2><p id="7f10" class="pw-post-body-paragraph ku kv it kw b kx mq ju kz la mr jx lc ld ms lf lg lh mt lj lk ll mu ln lo lp im bi translated">加密消息的交换由您决定。我们使用智能合约来存储和交换加密消息。在您的智能契约中，您可能会使用<code class="fe os ot ou ov b">bytes</code>类型来存储加密的消息。我们还使用<code class="fe os ot ou ov b"><a class="ae lx" href="https://www.npmjs.com/package/ethers" rel="noopener ugc nofollow" target="_blank">ethers.js</a></code>包与智能契约交互，这需要在向<code class="fe os ot ou ov b">bytes</code>参数发送数据时使用类型<code class="fe os ot ou ov b">number[]</code>。如果你想做同样的事情，你可以把缓冲区转换成<code class="fe os ot ou ov b">number[]</code>类型为:</p><pre class="kj kk kl km gt oy ov oz pa aw pb bi"><span id="940b" class="og lz it ov b gy pc pd l pe pf">numberArray = buffer.toJSON().data;</span></pre><h2 id="41c7" class="og lz it bd ma oh oi dn me oj ok dp mi ld ol om mk lh on oo mm ll op oq mo or bi translated">4.鲍勃用他的私钥解密这条消息</h2><p id="9218" class="pw-post-body-paragraph ku kv it kw b kx mq ju kz la mr jx lc ld ms lf lg lh mt lj lk ll mu ln lo lp im bi translated">最后，当Bob收到加密的数据时，他可以重建原始对象并请求MetaMask为他解密。所有这些都是使用以下函数完成的(<code class="fe os ot ou ov b">data </code> buffer是加密函数输出的缓冲区):</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ow ox l"/></div></figure><p id="3f04" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">在用户体验方面，MetaMask解密功能相当方便。它对应用程序完全隐藏了私钥。此外，用户不必手动处理私钥。唯一的缺点是弹出窗口总是要求用户批准解密。</p><h1 id="ad32" class="ly lz it bd ma mb mc md me mf mg mh mi jz mj ka mk kc ml kd mm kf mn kg mo mp bi translated">额外收获:用Python实现</h1><p id="0050" class="pw-post-body-paragraph ku kv it kw b kx mq ju kz la mr jx lc ld ms lf lg lh mt lj lk ll mu ln lo lp im bi translated">现在我们的情况是，我们也需要使用Python与智能合约进行交互。在这种情况下，我们需要用Python实现匹配的加密/解密函数。您将需要安装<code class="fe os ot ou ov b"><a class="ae lx" href="https://pypi.org/project/PyNaCl/" rel="noopener ugc nofollow" target="_blank">PyNaCl</a></code>，它提供加密和解密功能。然后，您可以使用以下代码:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ow ox l"/></div></figure><p id="f507" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">加密过程的技术细节我就不多说了。重要的是，这些函数产生的字节序列将与JavaScript实现中的缓冲区相同。如果你想对加密机制有更好的解释，请在评论中提问。</p><h1 id="1878" class="ly lz it bd ma mb mc md me mf mg mh mi jz mj ka mk kc ml kd mm kf mn kg mo mp bi translated">结论</h1><p id="57b8" class="pw-post-body-paragraph ku kv it kw b kx mq ju kz la mr jx lc ld ms lf lg lh mt lj lk ll mu ln lo lp im bi translated">我希望人们开始更多地使用这种加密机制，迫使钱包实现标准化。在整个教程中，我尽量不抱怨太多，但目前的状态确实是一团糟。每当我不得不处理一些设计决策时，它们都会让我大吃一惊。我想我们必须为用户友好的交互做出牺牲。</p><p id="3c3b" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">不管怎样，如果你喜欢这篇文章，考虑关注我和<a class="ae lx" href="https://twitter.com/FELT_labs" rel="noopener ugc nofollow" target="_blank"> @FELT_Labs </a>。会有更多关于Web3开发的文章。</p></div></div>    
</body>
</html>