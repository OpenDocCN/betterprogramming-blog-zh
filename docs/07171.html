<html>
<head>
<title>Updating State From Properties With React Hooks</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">用React挂钩从属性更新状态</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/updating-state-from-properties-with-react-hooks-5d48693a4af8?source=collection_archive---------2-----------------------#2020-12-14">https://betterprogramming.pub/updating-state-from-properties-with-react-hooks-5d48693a4af8?source=collection_archive---------2-----------------------#2020-12-14</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="42c9" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">以及为什么不应该从useEffect依赖关系中改变状态</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/b3dc5913ce97d2fb5ac1bc257a7bbff4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*LBVC9imP4y4GGcsDeTGIIA.jpeg"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">照片由<a class="ae ky" href="https://www.shutterstock.com/image-photo/white-radio-telescope-large-satellite-dish-1686580984" rel="noopener ugc nofollow" target="_blank"> Marko Aliaksandr </a>为<a class="ae ky" href="https://www.shutterstock.com/" rel="noopener ugc nofollow" target="_blank"> Shutterstock </a>拍摄。</p></figure><p id="b1f3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们有多少次想用组件属性中的数据来更新组件的内部状态？有各种各样的方法可以做到这一点，但有些方法也有陷阱。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="d884" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">问题是:道具并不总是管用</h1><p id="faf1" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">React坚持认为<a class="ae ky" href="https://reactjs.org/blog/2018/06/07/you-probably-dont-need-derived-state.html" rel="noopener ugc nofollow" target="_blank">不更新状态以反映适当变化</a>，且有充分的理由。跟踪状态应该反映什么变得更加具有挑战性和复杂。这是受控组件背后的思想，其中受控组件更新父组件的状态，而不是试图同步两个组件。</p><p id="65a3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">完全受控组件的问题在于，有时候，组件内部的状态会变得非常复杂。比如说，父母可能只关心列出服务器数据库搜索的最终结果。理想情况下，我们会让搜索结果出现在一个全局状态存储中，比如Redux或context，状态会简单地渗透到应用程序中需要的地方。但是有时候——特别是对于一个可重用的组件——如果能够封装搜索组件，读取<code class="fe mz na nb nc b">value</code>进行搜索，并通过调用<code class="fe mz na nb nc b">onSearch</code>属性返回结果就更好了。</p><p id="459c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这就是为什么我们中的许多人最终会在需要跟踪接收到的属性变化的组件中使用状态。</p><p id="0bbe" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们看看我们可以从功能组件中的属性更新状态的一些方法，它们的优缺点，然后是我的首选方法。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="f436" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">使用useEffect:请不要</h1><p id="a705" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">我们多久见过这样的事情？</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nd ne l"/></div></figure><p id="b650" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这看起来是一种简单而优雅的方法。每当<code class="fe mz na nb nc b">externalState</code>改变时，效果就会触发，更新<code class="fe mz na nb nc b">internalState</code>。三行，搞定。</p><p id="f8ea" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">除了它非常昂贵。</p><p id="3cb6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">每当<code class="fe mz na nb nc b">externalState</code>发生变化，我们都不会听到，直到<em class="nf">整个应用程序的DOM生成之后。</em>然后我们调用<code class="fe mz na nb nc b">setInternalState</code>，这导致应用程序重新开始渲染阶段，并重新创建一个新的DOM结构。</p><p id="6af8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">为了你的用户，请不要这样做。我特意写下这篇文章，因为我已经看过太多遍了，不想因为把头发从头上扯下来而变得秃顶。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="c355" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">跟踪以前的状态值:有效，不太贵</h1><p id="2d6f" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">React为<a class="ae ky" href="https://reactjs.org/docs/hooks-faq.html#how-do-i-implement-getderivedstatefromprops" rel="noopener ugc nofollow" target="_blank">提供了在新值到来时更新状态</a>的替代方法。这是他们对<code class="fe mz na nb nc b">getDerivedStateFromProps</code>的半官方替代:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nd ne l"/></div></figure><p id="099f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这种方法在DOM协调之前的渲染阶段完成所有工作。这使得它比最初的<code class="fe mz na nb nc b">useEffect</code>例子更有效。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="c5ee" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">最便宜的</h1><p id="8b80" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated"><a class="ae ky" href="https://reactjs.org/docs/hooks-faq.html#how-to-get-the-previous-props-or-state" rel="noopener ugc nofollow" target="_blank">第三种选择</a>也来自React文档。他们把它描述为一个潜在的未来<code class="fe mz na nb nc b">usePrevious</code>钩子，它看起来很有希望。如果我们想用它来更新状态，它应该是这样的:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nd ne l"/></div></figure><p id="2b7d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在这种情况下，我们没有使用<code class="fe mz na nb nc b">useEffect</code>来触发变化。因为我们正在更新一个引用，而不是调用一个<code class="fe mz na nb nc b">setState</code>函数，所以当<code class="fe mz na nb nc b">previousValueRef</code>被更新时，没有重新渲染发生。当组件下一次被调用时，提供的<code class="fe mz na nb nc b">value</code>与存储的<code class="fe mz na nb nc b">previousValueRef.current</code>进行比较，如果它们现在不同，我们更新<code class="fe mz na nb nc b">internalState</code>。</p><p id="6dce" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这种方法奏效的原因有两个:</p><ol class=""><li id="5f1c" class="ng nh it lb b lc ld lf lg li ni lm nj lq nk lu nl nm nn no bi translated"><code class="fe mz na nb nc b">useEffect</code>钩子没有依赖数组。这意味着它将在每次渲染后运行，从而使<code class="fe mz na nb nc b">usePreviousRef</code>始终保持最新。</li><li id="45db" class="ng nh it lb b lc np lf nq li nr lm ns lq nt lu nl nm nn no bi translated">我们只在需要时才设置内部状态，因为以前的值和内部值都与提供的值不匹配。如果我们只检查先前的值，我们会因为每次更新内部状态而陷入无限的渲染循环。</li></ol><p id="a5cd" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><em class="nf">注:老实说，这让我很困惑。尽管文档上说</em> <code class="fe mz na nb nc b"><em class="nf">setState</em></code> <em class="nf">函数如果接收到与它们包含的值相同的值，就不应该强制重新渲染，但我还是陷入了一个无限的渲染循环，即使是在调用像</em> <code class="fe mz na nb nc b"><em class="nf">setState(false)</em></code> <em class="nf">这样简单的函数时，也没有先检查</em> <code class="fe mz na nb nc b"><em class="nf">false</em></code> <em class="nf">。如果有人知道为什么会发生这种情况，我很乐意在回复中听到。</em></p><p id="b14f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">就性能而言，第二种和第三种方案实际上是相同的。主要区别在于，第二种选择在呈现时完成所有工作，而第三种选择在组件呈现在页面上后完成部分工作。只有用新值重新呈现组件，而不是一次更新两个单独的状态元素，才会发生更新。这是次要的，但感觉像一个很好的微优化。</p><p id="3de7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">是的，过早的优化是代码维护的死亡。在这种情况下，我在React dev团队的成员提出的两个建议中进行选择，因此我不会为此失眠。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="2c5b" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">我个人的偏好:useUpdatableState</h1><p id="0305" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">我更喜欢第三种选择，因为从状态改变的角度来看，它对我来说更便宜。但是就代码可读性而言，它有点杂乱，而且没有解决我的一个主要抱怨:我不能选择什么构成了状态的必要改变。当我想更新我的状态时，它基于严格的等式更新，只有当满足某些标准时。</p><p id="4898" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">输入<code class="fe mz na nb nc b"><a class="ae ky" href="https://www.npmjs.com/package/@landisdesign/use-updatable-state" rel="noopener ugc nofollow" target="_blank">useUpdatableState</a></code>:</p><pre class="kj kk kl km gt nu nc nv nw aw nx bi"><span id="9c80" class="ny md it nc b gy nz oa l ob oc">import useUpdatableState from '@landisdesign/use-updatable-state';</span><span id="7994" class="ny md it nc b gy od oa l ob oc">const [state, setState, changed] = useUpdatableState(value);</span></pre><p id="a6ae" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">它本质上是对<code class="fe mz na nb nc b">useState</code>的替代，除了它基于新的输入值进行更新。只要传入的值不变，它的返回状态就基于传递给<code class="fe mz na nb nc b">setState</code>的任何内容。当一个新值出现时，<code class="fe mz na nb nc b">state</code>被更新。<code class="fe mz na nb nc b">changed</code>参数告诉我<code class="fe mz na nb nc b">state</code>何时反映输入值，而不是我一直在修改的值，以防我需要对其他状态进行更改或触发副作用。</p><p id="1817" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">更重要的是，它允许我在第二个参数中提供一个谓词，比如:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nd ne l"/></div></figure><p id="59ff" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在这个例子中，参数<code class="fe mz na nb nc b">(a, b) =&gt; a.id === b.id</code>告诉<code class="fe mz na nb nc b">useUpdatableState</code>如果id相同，我不应该基于那个外部值更新我的内部状态。这与<code class="fe mz na nb nc b">react-redux</code>的<code class="fe mz na nb nc b">useSelector</code>钩子所做的类似，让我们挑选什么值得强制重置我们的状态。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="beb7" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">TL；DR:不要用useEffect依赖关系改变状态</h1><p id="29d7" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">这才是这篇文章真正要讲的。这里至少有两种选择，它们不会强迫你的用户为编写漂亮但低效的代码付出代价。你还有其他的吗？请在下面的评论中留下它们。</p><p id="f26b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">感谢阅读！</p></div></div>    
</body>
</html>