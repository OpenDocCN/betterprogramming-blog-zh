<html>
<head>
<title>How to Implement a Queue Using Two Stacks</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何使用两个堆栈实现队列</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/how-to-implement-a-queue-using-two-stacks-80772242b88c?source=collection_archive---------4-----------------------#2019-09-06">https://betterprogramming.pub/how-to-implement-a-queue-using-two-stacks-80772242b88c?source=collection_archive---------4-----------------------#2019-09-06</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="22b6" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">一个经典编码面试问题的Python解决方案</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/4c191c5c76f060726dc939197c389986.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*AT8r7ri32IgawxnlVuL9gA.jpeg"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated"><a class="ae kv" href="https://unsplash.com/@cowomen?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">女同胞</a>在<a class="ae kv" href="https://unsplash.com/search/photos/interview?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍照</p></figure><p id="d295" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我之前发表了一篇博客(<a class="ae kv" href="https://medium.com/@krbarounis/a-primer-on-stacks-and-queues-f40dda17604d?source=friends_link&amp;sk=08eca33a65e65f973ea11da9d2827d93" rel="noopener">“堆栈和队列入门”</a>)，介绍了两种抽象数据结构:<em class="ls">堆栈</em>和<em class="ls">队列</em>。在准备技术面试时，回顾这些以及其他数据结构是很重要的，因为它们肯定会以某种形式出现。一种形式是通过这样的问题，“如何使用两个堆栈实现一个队列？”</p><p id="ae73" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在找到解决方案之前，我们需要快速回顾一下堆栈和队列(更深入的解释可以阅读我之前的博客)。堆栈是遵循LIFO方法的数组，而队列是遵循FIFO方法的数组。本质上，我们希望我们的算法通过使用两个堆栈来获得队列的能力(入队和出队)。除了正确实现算法，面试官可能会要求你解释你的算法的时间复杂度，所以让我们在回答时记住这一点。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi lt"><img src="../Images/e83c276523086239bc6749497e9bb9ac.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*priDymDAjrUen02IUEJm6g.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">使用单个堆栈不允许我们实现FIFO方法，因为进入堆栈的最后一个元素是现在唯一可以移除的元素</p></figure><p id="70fd" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">为了解决这个问题，我们可以从向堆栈中添加元素开始。但是我们知道，堆栈使用后进先出法；这意味着我们将只能移除添加到堆栈中的最后一个元素。这并没有真正回答问题，因为我们希望删除元素的顺序是FIFO。解决这个问题的基本方法是创建两个堆栈，将元素添加到第一个堆栈，然后移除元素并将其推送到第二个堆栈。这会颠倒元素的顺序，从而形成一个队列。</p><div class="kg kh ki kj gt ab cb"><figure class="lu kk lv lw lx ly lz paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><img src="../Images/7aa7eaf4be4de4e4710c32604034fd39.png" data-original-src="https://miro.medium.com/v2/resize:fit:988/format:webp/1*MXfZ8d-pXl_pAO28dhqOng.png"/></div></figure><figure class="lu kk ma lw lx ly lz paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><img src="../Images/9d57673d7deed6f09d4b8f682e2c23ed.png" data-original-src="https://miro.medium.com/v2/resize:fit:1014/format:webp/1*H2kpsPBMDX_uUuqeH0uFYg.png"/></div><p class="kr ks gj gh gi kt ku bd b be z dk mb di mc md translated">算法过程的可视化</p></figure></div><p id="4743" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">伪代码:</p><pre class="kg kh ki kj gt me mf mg mh aw mi bi"><span id="f09b" class="mj mk iq mf b gy ml mm l mn mo"># create two stacks: stack1, stack2</span><span id="dda7" class="mj mk iq mf b gy mp mm l mn mo"># push elements into stack1<br/># this is the enqueue function (entering the queue)</span><span id="ce49" class="mj mk iq mf b gy mp mm l mn mo"># check if stack1 is empty<br/># if it isn't, pop the last element and push it into stack2<br/># repeat until stack1 is empty<br/># this is the dequeue function (leaving the queue)</span><span id="ed60" class="mj mk iq mf b gy mp mm l mn mo"># once stack1 is empty, check if stack2 is empty<br/># if it isn't, pop the last element and return it<br/># repeat until stack2 is empty</span></pre><p id="cc9a" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">Python代码:</p><pre class="kg kh ki kj gt me mf mg mh aw mi bi"><span id="b427" class="mj mk iq mf b gy ml mm l mn mo">class Queue_Two_Stacks():<br/><br/>    def __init__(self):<br/>        self.stack_1 = []<br/>        self.stack_2 = []<br/><br/>    def enqueue(self, item):<br/>        self.stack_1.append(item)<br/><br/>    def dequeue(self):</span><span id="7f38" class="mj mk iq mf b gy mp mm l mn mo">        if len(self.stack_2) == 0:</span><span id="bb72" class="mj mk iq mf b gy mp mm l mn mo">        # If stack_1 is empty, raise an error<br/>            if len(self.stack_1) == 0:<br/>                raise IndexError("Can't dequeue from empty queue!")<br/>        <br/>        # while stack_1 is not empty, <br/>        # move items from stack_1 to stack_2, reversing order<br/>            while len(self.stack_1) &gt; 0:<br/>                last_stack_1_item = self.stack_1.pop()<br/>                self.stack_2.append(last_stack_1_item)</span><span id="f9a6" class="mj mk iq mf b gy mp mm l mn mo">        # return the last item in stack_2, which is the first<br/>        # item that entered stack_1 (FIFO!)</span><span id="b1a5" class="mj mk iq mf b gy mp mm l mn mo">        return self.stack_2.pop()</span></pre></div><div class="ab cl mq mr hu ms" role="separator"><span class="mt bw bk mu mv mw"/><span class="mt bw bk mu mv mw"/><span class="mt bw bk mu mv"/></div><div class="ij ik il im in"><h1 id="fdd7" class="mx mk iq bd my mz na nb nc nd ne nf ng jw nh jx ni jz nj ka nk kc nl kd nm nn bi translated">时间复杂度/大O</h1><p id="2051" class="pw-post-body-paragraph kw kx iq ky b kz no jr lb lc np ju le lf nq lh li lj nr ll lm ln ns lp lq lr ij bi translated">所以我们有一个完整的解决方案！但是运行时呢？最简单的方法是考虑每个元素的时间成本。就单个项目的成本而言，最坏的情况是它先入队，然后再出队。在这种情况下，物品进入<code class="fe nt nu nv mf b">stack_1</code>(成本为一次推送)，然后移动到<code class="fe nt nu nv mf b">stack_2</code>(成本为一次弹出和一次推送)。稍后，该物品从<code class="fe nt nu nv mf b">stack_2</code>中移除并被退回(花费一次pop)。这四个pushes和pop中的每一个都是<code class="fe nt nu nv mf b">O(1)</code>，这意味着访问堆栈中的单个元素不会根据数据集的大小而改变。我们只需要抓取最后一个元素，不需要遍历数组。所以我们的每项总成本是<code class="fe nt nu nv mf b">O(1)</code> <em class="ls">，</em>，而我们整个算法的运行时间是<code class="fe nt nu nv mf b">O(n)</code>。随着我们添加更多的元素，算法将需要更长的时间来运行，因为运行时间与数据集中的元素数量成正比。</p></div></div>    
</body>
</html>