<html>
<head>
<title>Multi-Threaded Android: Handler, Thread, Looper, and Message Queue</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">多线程Android:处理程序、线程、循环和消息队列</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/a-detailed-story-about-handler-thread-looper-message-queue-ac2cd9be0d78?source=collection_archive---------0-----------------------#2020-01-23">https://betterprogramming.pub/a-detailed-story-about-handler-thread-looper-message-queue-ac2cd9be0d78?source=collection_archive---------0-----------------------#2020-01-23</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="fb5c" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">它们是什么，我们如何正确使用它们？</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/9e02c2d4921126f251ad8df440cd5990.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*sIzPVwpZx0EyNvcIDocArg.jpeg"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">由<a class="ae ky" href="https://unsplash.com/@indiablue?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Stephen Frank </a>在<a class="ae ky" href="https://unsplash.com/s/photos/android?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</p></figure><p id="78be" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">多线程是任何编程语言中最有价值的概念之一。熟练使用Android上的线程可以帮助你提升应用程序的性能。</p><p id="e80b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">当用户打开一个应用程序时，Android会创建自己的Linux进程。除此之外，系统为该应用程序创建一个执行线程，称为<em class="lv">主线程</em>或UI线程。</p><p id="9a4f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">主线程只是一个处理程序线程。主线程负责处理来自整个应用程序的事件，如与生命周期信息相关联的回调、来自输入事件的回调或来自其他应用程序的处理事件等。</p><p id="444b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">任何需要运行的代码块都被推入工作队列，然后由主线程提供服务。由于主线程要做这么多的工作，最好把更长的工作交给其他线程，这样就不会打扰UI线程的渲染工作。</p><p id="444e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">避免使用主线程来执行任何可能导致阻塞的操作是至关重要的。</p><p id="53fe" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">当在主线程上执行网络操作或数据库调用或某些组件的加载时，它们是可能导致主线程阻塞的一些示例。</p><p id="a7b9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">它们是同步执行的，这意味着在任务完成之前，UI将保持完全无响应。</p><p id="46f5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">为了避免这种情况，它们通常在单独的线程中执行，这样可以避免在执行任务时阻塞UI。这意味着它们是从UI异步执行的。</p><p id="6f0b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">Android提供了许多创建和管理线程的方法，并且有许多第三方库使得线程管理更加容易。每个线程类都有特定的用途；然而，选择一个适合我们需求的是非常重要的。</p><p id="ecf3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在本文中，让我们探索线程、处理程序、循环和消息队列。</p></div><div class="ab cl lw lx hx ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="im in io ip iq"><h1 id="9b82" class="md me it bd mf mg mh mi mj mk ml mm mn jz mo ka mp kc mq kd mr kf ms kg mt mu bi translated">线</h1><p id="845e" class="pw-post-body-paragraph kz la it lb b lc mv ju le lf mw jx lh li mx lk ll lm my lo lp lq mz ls lt lu im bi translated">线程可以定义为执行程序时遵循的路径。Java虚拟机允许应用程序同时运行多个执行线程。</p><p id="6d95" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">并发意味着并行运行多个任务，这是我们使用线程的主要原因之一。由于Android是单线程模型，我们需要创建不同的线程来执行我们的任务，并将结果发送到主线程，在那里UI得到更新。</p><p id="b20f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们可以用两种方法创建线程。</p><ol class=""><li id="327b" class="na nb it lb b lc ld lf lg li nc lm nd lq ne lu nf ng nh ni bi translated">通过扩展<code class="fe nj nk nl nm b">Thread</code>类。</li></ol><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nn no l"/></div></figure><p id="732a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">2.通过实现一个<code class="fe nj nk nl nm b">Runnable</code>接口。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nn no l"/></div></figure><p id="91f6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe nj nk nl nm b">Runnable</code>接口应该由任何类实现，这些类的实例应该由线程执行。该类必须定义一个名为<code class="fe nj nk nl nm b">run</code>的无参数方法。</p><p id="0fdd" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">每个线程都是由<code class="fe nj nk nl nm b">java.lang.Thread</code>类创建和控制的。</p><p id="6d03" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们需要在线程上调用start方法来开始执行:</p><pre class="kj kk kl km gt np nm nq nr aw ns bi"><span id="77d2" class="nt me it nm b gy nu nv l nw nx">new Test.start()</span></pre><p id="0066" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">线程具有不同状态的生命周期，如新的、可运行的、运行中的、不可运行的(阻塞的)、终止的。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ny"><img src="../Images/b43111b2516b2f08762c367578a9f560.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*VN7__2PPEKHrELv8be6oxA.png"/></div></div></figure><p id="3ffb" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">除了更新UI元素，我们可以在线程内部执行任何类型的操作。为了从线程中更新UI元素，我们需要使用处理程序或<code class="fe nj nk nl nm b">runOnUIThread</code>方法。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nn no l"/></div></figure><p id="ac3e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe nj nk nl nm b">runOnUiThread()</code>在UI线程上运行指定的动作。</p><p id="6845" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果当前线程是UI线程，则立即执行动作。如果当前线程不是UI线程，则动作被发送到UI线程的事件队列。</p></div><div class="ab cl lw lx hx ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="im in io ip iq"><h1 id="8745" class="md me it bd mf mg mh mi mj mk ml mm mn jz mo ka mp kc mq kd mr kf ms kg mt mu bi translated">消息，消息队列，循环</h1><p id="6f4c" class="pw-post-body-paragraph kz la it lb b lc mv ju le lf mw jx lh li mx lk ll lm my lo lp lq mz ls lt lu im bi translated">MessageQueue是一个队列，它有一个将在某个线程中执行的任务(消息、可运行任务)列表。Android在主线程上维护一个MessageQueue。</p><p id="7863" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">除了looper和handler，MessageQueues是Android中线程构建模块的一部分，它们几乎在系统的任何地方都有使用。</p><p id="98b6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这个类包含了由循环发送的消息列表。您只需调用<code class="fe nj nk nl nm b">Looper.myqueue()</code>即可获得消息列表。</p><p id="1be9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">根据文档，它是一个低级类，保存由一个循环调度的消息列表。消息不是直接添加到MessageQueue，而是通过与looper关联的处理程序对象添加。</p><p id="f7bd" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们可以用<code class="fe nj nk nl nm b">Looper.myQueue()</code>检索当前线程的MessageQueue。</p><p id="72f7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">打环器<strong class="lb iu"> </strong>负责保持线的活性。它是一种为当前线程提供MessageQueue服务的工作线程。Looper遍历消息队列，并将消息发送到相应的线程进行处理。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi nz"><img src="../Images/665eebd863c7a6177a1ba12ef44d844b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1264/format:webp/1*QWYBhnANEabiTHk2zcCRTg.png"/></div></figure><p id="4bab" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">每根线只有一个独特的弯针。这意味着每个线程只有一个MessageQueue。一个线程可以有任意数量的处理程序。因此，looper为线程提供了使用自己的MessageQueue在循环中运行的工具。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi oa"><img src="../Images/51f61ca4704de15b1fcab4aa4e01d92d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*af16-wYsVJwOYzodQ2DhuA.png"/></div></div></figure><p id="1a00" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">消息<strong class="lb iu"> </strong>定义了包含描述和任意数据对象的消息，该消息可以被发送到处理程序。</p><p id="132d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这个对象包含两个额外的<code class="fe nj nk nl nm b">int</code>字段和一个额外的object字段，在许多情况下允许您不进行分配。我们可以简单地说<strong class="lb iu"> </strong>该消息类似于用于数据传输的包。</p><p id="51ea" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">虽然message的构造函数是公共的，但获得其中一个的最好方法是调用<code class="fe nj nk nl nm b">Message.obtain()</code>或<code class="fe nj nk nl nm b">Handler.obtainMessage()</code>方法之一，这将从回收对象池中提取它们。</p><p id="2dca" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">有不同的论点可能是有用的:</p><pre class="kj kk kl km gt np nm nq nr aw ns bi"><span id="407f" class="nt me it nm b gy nu nv l nw nx">public int what</span></pre><p id="b704" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">用户定义的消息代码，以便收件人可以识别此消息的内容。每个处理程序都有自己的消息代码命名空间，所以您不必担心与其他处理程序冲突。</p><pre class="kj kk kl km gt np nm nq nr aw ns bi"><span id="b8ee" class="nt me it nm b gy nu nv l nw nx">public int arg1</span><span id="954d" class="nt me it nm b gy ob nv l nw nx">public int arg2</span></pre><p id="057d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果您只需要存储几个整数值，<code class="fe nj nk nl nm b">arg1</code>和<code class="fe nj nk nl nm b">arg2</code>是使用<code class="fe nj nk nl nm b">setData()</code>的低成本替代方案。</p><pre class="kj kk kl km gt np nm nq nr aw ns bi"><span id="14e9" class="nt me it nm b gy nu nv l nw nx">public Object obj</span></pre><p id="4b63" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">要发送给收件人的任意对象。当使用Messenger跨进程发送消息时，只有当它包含framework类的Parcelable(不是由应用程序实现的Parcelable)时，它才能为非null。对于其他数据传输，使用<code class="fe nj nk nl nm b">setData</code>。</p><p id="0fed" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">你可以在文档中找到更多的论点。</p></div><div class="ab cl lw lx hx ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="im in io ip iq"><h1 id="e8ba" class="md me it bd mf mg mh mi mj mk ml mm mn jz mo ka mp kc mq kd mr kf ms kg mt mu bi translated">处理者</h1><p id="f3ab" class="pw-post-body-paragraph kz la it lb b lc mv ju le lf mw jx lh li mx lk ll lm my lo lp lq mz ls lt lu im bi translated">由于只有一个线程更新UI，即主线程，我们使用不同的其他线程在后台执行多个任务，但最后，为了更新UI，我们需要将结果发送到主线程或UI线程。</p><p id="7612" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果你正在管理一个大的线程组，那么管理与所有这些线程的通信将会很复杂。因此，Android提供了处理程序来简化进程间的通信。</p><p id="b5b0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">处理程序允许您发送和处理与线程的MessageQueue相关联的<code class="fe nj nk nl nm b">Message</code>和<code class="fe nj nk nl nm b">Runnable</code>对象。每个处理程序实例都与一个线程和该线程的消息队列相关联。</p><p id="32dc" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">该类负责将任何任务排入消息队列并进行处理。</p><p id="2a0d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">当您创建一个新的处理程序时，它被绑定到正在创建它的线程的线程/消息队列——从那时起，它将把消息和可运行的消息传递到那个消息队列，并在它们离开消息队列时执行它们。</p><p id="a857" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">简而言之，我们可以说处理程序是一个组件，它可以附加到一个线程上，然后通过简单的消息或<code class="fe nj nk nl nm b">Runnable</code>任务在那个线程上执行一个动作。</p><p id="6caa" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">它与另一个组件looper协同工作，looper负责特定线程中的消息处理。</p><p id="9d00" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">当创建一个处理程序时，它可以在构造函数中获得一个<code class="fe nj nk nl nm b">Looper</code>对象，该对象指示该处理程序附加到哪个线程。如果要使用一个附加到主线程的处理程序，需要通过调用<code class="fe nj nk nl nm b">Looper.getMainLooper()</code>来使用与主线程关联的looper。</p><p id="63c9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">处理程序有两种主要用途:</p><ol class=""><li id="a0e9" class="na nb it lb b lc ld lf lg li nc lm nd lq ne lu nf ng nh ni bi translated">安排消息和可运行的消息在未来的某个时间执行。</li><li id="8042" class="na nb it lb b lc oc lf od li oe lm of lq og lu nf ng nh ni bi translated">将要在不同于您自己的线程上执行的操作排队。</li></ol><h2 id="57dc" class="nt me it bd mf oh oi dn mj oj ok dp mn li ol om mp lm on oo mr lq op oq mt or bi translated"><strong class="ak">如何安排</strong></h2><p id="b502" class="pw-post-body-paragraph kz la it lb b lc mv ju le lf mw jx lh li mx lk ll lm my lo lp lq mz ls lt lu im bi translated">通过<code class="fe nj nk nl nm b">post(Runnable)</code>、<code class="fe nj nk nl nm b">postAtTime(Runnable, long)</code>、<code class="fe nj nk nl nm b">postDelayed(Runnable, long)</code>、<code class="fe nj nk nl nm b">sendEmptyMessage(int)</code>、<code class="fe nj nk nl nm b">sendMessage(Message)</code>、<code class="fe nj nk nl nm b">sendMessageAtTime(Message, long)</code>和<code class="fe nj nk nl nm b">sendMessageDelayed(Message, long)</code>的方式完成对消息的调度。</p><p id="43ee" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">post版本允许您在消息队列接收到对象时将这些对象排入队列。</p><p id="b437" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe nj nk nl nm b">sendMessage</code>版本允许您将包含一组数据的<code class="fe nj nk nl nm b">Message</code>对象入队，这些数据将由处理程序的<code class="fe nj nk nl nm b">handleMessage(Message)</code>方法处理(要求您实现<code class="fe nj nk nl nm b">Handler</code>的子类)。</p><h2 id="59cf" class="nt me it bd mf oh oi dn mj oj ok dp mn li ol om mp lm on oo mr lq op oq mt or bi translated"><strong class="ak">post()和sendMessage()的区别</strong></h2><p id="994d" class="pw-post-body-paragraph kz la it lb b lc mv ju le lf mw jx lh li mx lk ll lm my lo lp lq mz ls lt lu im bi translated">当我们想要在UI线程上执行一些代码而不知道任何关于我们的<code class="fe nj nk nl nm b">Handler</code>对象的信息时，我们使用<code class="fe nj nk nl nm b">post()</code>。在许多需要在UI线程上执行任意代码的情况下，这是有意义的。</p><p id="8c5a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">例如，要从后台线程更新UI并延迟一段时间，这里可以创建一个附加到UI线程的处理程序，然后将动作作为<code class="fe nj nk nl nm b">Runnable</code>提交。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nn no l"/></div></figure><p id="f666" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">但是在某些情况下，如果我们想要组织发送给UI线程的内容，并且有我们想要执行的特定功能，在这种情况下你可以使用<code class="fe nj nk nl nm b">sendMessage()</code>。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nn no l"/></div></figure><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi os"><img src="../Images/1e5524012137af6be26427cc6a790356.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*jmVMq19k7EVXgAHHJK7eEQ.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">流程概述</p></figure></div><div class="ab cl lw lx hx ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="im in io ip iq"><h1 id="f822" class="md me it bd mf mg mh mi mj mk ml mm mn jz mo ka mp kc mq kd mr kf ms kg mt mu bi translated">摘要</h1><p id="d376" class="pw-post-body-paragraph kz la it lb b lc mv ju le lf mw jx lh li mx lk ll lm my lo lp lq mz ls lt lu im bi translated">必须创建线程来执行长时间运行的作业。一个<code class="fe nj nk nl nm b">Handler</code>是两个线程间通信的一个非常方便的对象。</p><p id="c182" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">因此，我们无法在处理程序和线程之间进行选择。使用一个线程来完成繁重的工作，如果你的后台线程将触发另一个线程来完成一项工作，那么使用一个处理程序——大多数情况下是UI线程。</p><p id="60fa" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">通过使用MessageQueue，执行是顺序的，因此在并发线程的情况下，这将避免争用情况。通常，一旦线程的任务完成，它就不能被重用。</p><p id="0d43" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">但是在looper的帮助下，thread一直保持活动状态，直到您调用quit方法，这样您就不需要每次在后台运行作业时都创建一个新的实例。</p><p id="de12" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">请让我知道你的建议和意见。</p><p id="0489" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">感谢阅读。</p></div></div>    
</body>
</html>