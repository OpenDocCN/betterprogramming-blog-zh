<html>
<head>
<title>Crack Coding Interviews by Building These 5 Real-World Features</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">通过构建这5个真实世界的特征来破解编码面试</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/crack-coding-interviews-by-building-these-5-real-world-features-4089058d7b0e?source=collection_archive---------1-----------------------#2021-03-05">https://betterprogramming.pub/crack-coding-interviews-by-building-these-5-real-world-features-4089058d7b0e?source=collection_archive---------1-----------------------#2021-03-05</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="5869" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">今天，我们将以不同的方式准备编码面试，并为网飞和脸书这样的公司构建五个真实世界的功能</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/93ffba57e76facd0d853c003b42745af.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Qo7l9Y_Usi2oREe1N4gXew.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">作者照片。</p></figure><p id="1d17" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">准备编码面试不是一件容易的事情。您需要技能来解决问题并部署正确的工具。教育团队一直致力于让工程师更容易进行编码面试准备。我们从第一手资料中了解到，成功的最佳方式不是记住1500多个LeetCode问题。</p><p id="c133" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">这就是为什么我们今天想通过解决科技公司面临的一些现实问题来改变面试准备的方式。学习如何构建现实世界的功能(例如，如何合并亚马逊上的推荐)更有趣，而且这样更容易记住你学到的东西。如果你能理解一个问题的潜在模式，你就能把它应用到任何问题上。</p><p id="9bd2" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">我们将深入研究一些常见的真实世界编码问题的解决方案，并构建五个特性。我们将用Java提供我们的解决方案。</p><p id="5562" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">本教程一目了然:</p><ul class=""><li id="a862" class="lu lv it la b lb lc le lf lh lw ll lx lp ly lt lz ma mb mc bi translated">网飞功能:相似标题分组(散列表)</li><li id="daf7" class="lu lv it la b lb md le me lh mf ll mg lp mh lt lz ma mb mc bi translated">脸书特色:朋友圈(DFS)</li><li id="14c6" class="lu lv it la b lb md le me lh mf ll mg lp mh lt lz ma mb mc bi translated">谷歌日历功能:查找会议室(堆)</li><li id="d2f4" class="lu lv it la b lb md le me lh mf ll mg lp mh lt lz ma mb mc bi translated">亚马逊特色:价格范围内的产品(BST)</li><li id="b375" class="lu lv it la b lb md le me lh mf ll mg lp mh lt lz ma mb mc bi translated">Twitter功能:添加喜欢(字符串)</li><li id="fcf0" class="lu lv it la b lb md le me lh mf ll mg lp mh lt lz ma mb mc bi translated">从这里去哪里</li></ul></div><div class="ab cl mi mj hx mk" role="separator"><span class="ml bw bk mm mn mo"/><span class="ml bw bk mm mn mo"/><span class="ml bw bk mm mn"/></div><div class="im in io ip iq"><h1 id="e95e" class="mp mq it bd mr ms mt mu mv mw mx my mz jz na ka nb kc nc kd nd kf ne kg nf ng bi translated">1.网飞功能:分组相似的标题(哈希映射)</h1><p id="5c4a" class="pw-post-body-paragraph ky kz it la b lb nh ju ld le ni jx lg lh nj lj lk ll nk ln lo lp nl lr ls lt im bi translated">网飞是最大的视频流媒体平台之一。网飞工程团队一直在寻找显示内容的新方法。对于第一个问题，假设你是这个团队的开发人员。</p><p id="c6c3" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">任务:我们在这里的任务是通过使用户能够看到相关的搜索结果而不受错别字的影响来改善搜索结果。我们称之为“相似标题分组”功能。</p><p id="7cfb" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">首先，我们需要确定如何对给定标题的任意字符组合进行单独分组。让我们假设我们的库有以下标题:<code class="fe nn no np nq b">"duel,"</code> <code class="fe nn no np nq b">"dule,"</code> <code class="fe nn no np nq b">"speed,"</code> <code class="fe nn no np nq b">"speed,"</code> <code class="fe nn no np nq b">"deul,"</code>和<code class="fe nn no np nq b">"cars."</code>你的任务是设计一个功能，以便如果用户拼错一个单词(例如，“速度”作为“spede”)，他们仍然会显示正确的标题。</p><p id="91f8" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">首先，我们需要将我们的标题分成几组单词，这样一组单词中的单词就是变位词。我们有三套:<code class="fe nn no np nq b">{"duel", "dule", "deul"}</code>、<code class="fe nn no np nq b">{"speed", "spede"}</code>和<code class="fe nn no np nq b">{"cars"}</code>。搜索结果应该包括该字符串所在集合的所有成员。当用户搜索时，最好预先计算我们的集合，而不是形成它们。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nr"><img src="../Images/e6e24b3582b25871d7e290308d6413aa.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*wvSOMZZmkJNC9YWG3AGhYQ.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">组合相似的组</p></figure><p id="0122" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">每个集合的成员每个字母的出现频率相同，所以每个字母在同组单词中的出现频率相等。比如，在我们的<code class="fe nn no np nq b">{{"speed", "spede"}}</code>集合中，每个单词中字符的出现频率是相同的:<code class="fe nn no np nq b">s</code>、<code class="fe nn no np nq b">p</code>、<code class="fe nn no np nq b">e</code>、<code class="fe nn no np nq b">d</code>。</p><p id="f452" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">那么，我们如何设计和实现这个功能呢？我们来分解一下。</p><ol class=""><li id="29f4" class="lu lv it la b lb lc le lf lh lw ll lx lp ly lt ns ma mb mc bi translated">对于每个标题，我们需要计算一个26元素的向量。每个向量元素代表一个英文字母在标题中的出现频率。我们可以用一个固定了<code class="fe nn no np nq b">#</code>字符的字符串来表示频率。这个映射过程为字谜字符串生成相同的向量。例如，我们将<code class="fe nn no np nq b">abbccc</code>表示为<code class="fe nn no np nq b">#1#2#3#0#0#0...#0</code>。</li><li id="ae5c" class="lu lv it la b lb md le me lh mf ll mg lp mh lt ns ma mb mc bi translated">然后，我们使用这个向量作为将标题插入散列表的键。我们的字谜都将被映射到同一个条目。当用户搜索一个标题或单词时，它应该根据输入计算26个元素的英文字母频率向量。然后它会搜索hashmap，并使用vector返回所有的map条目。</li><li id="37d2" class="lu lv it la b lb md le me lh mf ll mg lp mh lt ns ma mb mc bi translated">然后，我们将计算出的字符数列表作为一个键存储在hashmap中，并指定一个字符串作为它的值。</li><li id="c6b6" class="lu lv it la b lb md le me lh mf ll mg lp mh lt ns ma mb mc bi translated">每个值都是一个单独的集合，所以我们返回hashmap的值。</li></ol><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nt"><img src="../Images/b4c8941776460e23f317213b0ccd6878.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*FcMFJlwidXUqwLlWiLDNMw.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">将集合存储在键值存储中</p></figure><h2 id="a406" class="nu mq it bd mr nv nw dn mv nx ny dp mz lh nz oa nb ll ob oc nd lp od oe nf of bi translated">Java解决方案</h2><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="og oh l"/></div></figure><p id="1298" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">如果你想看Python中的解决方案，可以查看原始的<a class="ae oi" href="https://www.educative.io/blog/crack-coding-interview-real-world-problems" rel="noopener ugc nofollow" target="_blank">帖子</a>。</p><h2 id="58f7" class="nu mq it bd mr nv nw dn mv nx ny dp mz lh nz oa nb ll ob oc nd lp od oe nf of bi translated">复杂性度量</h2><ul class=""><li id="dc9c" class="lu lv it la b lb nh le ni lh oj ll ok lp ol lt lz ma mb mc bi translated">时间复杂度:<em class="nm">O</em>(<em class="nm">n</em>∫<em class="nm">k</em>)因为我们是对列表中的每个字符串的每个字母进行计数。</li><li id="58be" class="lu lv it la b lb md le me lh mf ll mg lp mh lt lz ma mb mc bi translated">空间复杂度:<em class="nm">O</em>(<em class="nm">n</em>∫<em class="nm">k</em>)由于每个字符串都作为一个值存储在字典中，字符串的大小可以是<em class="nm"> k </em>。</li></ul></div><div class="ab cl mi mj hx mk" role="separator"><span class="ml bw bk mm mn mo"/><span class="ml bw bk mm mn mo"/><span class="ml bw bk mm mn"/></div><div class="im in io ip iq"><h1 id="2259" class="mp mq it bd mr ms mt mu mv mw mx my mz jz na ka nb kc nc kd nd kf ne kg nf ng bi translated">2.脸书特色:朋友圈(DFS)</h1><p id="cb1c" class="pw-post-body-paragraph ky kz it la b lb nh ju ld le ni jx lg lh nj lj lk ll nk ln lo lp nl lr ls lt im bi translated">脸书是世界上最大的社交媒体公司。他们还拥有并运营Instagram。假设你是一个脸书工程师团队，你的任务是改善他们姐妹平台之间的集成。</p><p id="35c1" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">任务:我们的任务是找到脸书上所有在用户朋友圈里的人。我们称之为“朋友圈”功能。</p><p id="86a7" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">我们需要首先确定每个用户的朋友圈里都有哪些人，其中包括与另一个用户直接或间接成为好友的用户。让我们假设脸书上有n个用户。友谊连接是可传递的。</p><p id="ac18" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">例:如果尼克是艾米的直接朋友，艾米是马特的直接朋友，那么尼克是马特的间接朋友。</p><p id="ffd7" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">我们将使用一个<em class="nm"> n*n </em>方阵。例如，如果这些用户是朋友，单元格<code class="fe nn no np nq b">[i,j]</code>将保存值<code class="fe nn no np nq b">1</code>。否则，单元格将保存值<code class="fe nn no np nq b">0</code>。在下图中，有两个来自上例的朋友圈。尼克只是艾米的朋友，但艾米是尼克和马特的朋友。这就形成了朋友圈。马里奥自己又做了一个朋友圈。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi om"><img src="../Images/f7c462503055a3f9dfa565786c37aa4a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*isiPFfkHJj1USJC1qOjPZA.png"/></div></div></figure><p id="2a4a" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">把我们的对称输入矩阵想象成一个无向图。在我们的图中，在一个朋友圈中的间接朋友和直接朋友也存在于一个连通分量中。这意味着连通图组件的数量将给出我们有多少个朋友圈。</p><p id="1f91" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">所以，我们的任务是找出连通分量的个数。我们将输入矩阵视为邻接矩阵。那么，我们如何设计和实现它呢？我们来分解一下。</p><ol class=""><li id="0556" class="lu lv it la b lb lc le lf lh lw ll lx lp ly lt ns ma mb mc bi translated">首先，我们初始化一个名为<code class="fe nn no np nq b">visited</code>的数组。这将使用<code class="fe nn no np nq b">0</code>作为每个索引的值来跟踪访问过的大小为<code class="fe nn no np nq b">n</code>的顶点。</li><li id="1e7c" class="lu lv it la b lb md le me lh mf ll mg lp mh lt ns ma mb mc bi translated">然后，如果<code class="fe nn no np nq b">visited[v]</code>是<code class="fe nn no np nq b">0</code>，我们使用DFS遍历图。如果没有，我们进入下一个<code class="fe nn no np nq b">v</code>。</li><li id="1877" class="lu lv it la b lb md le me lh mf ll mg lp mh lt ns ma mb mc bi translated">然后，为我们的DFS遍历遇到的每个<code class="fe nn no np nq b">v</code>设置<code class="fe nn no np nq b">visited[v]</code>为<code class="fe nn no np nq b">1</code>。</li><li id="bd6e" class="lu lv it la b lb md le me lh mf ll mg lp mh lt ns ma mb mc bi translated">当DFS遍历完成后，我们应该将循环计数器增加<code class="fe nn no np nq b">1</code>。这意味着已完全遍历了一个连通分量。</li></ol><h2 id="2644" class="nu mq it bd mr nv nw dn mv nx ny dp mz lh nz oa nb ll ob oc nd lp od oe nf of bi translated">Java解决方案</h2><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="og oh l"/></div></figure><h2 id="04f0" class="nu mq it bd mr nv nw dn mv nx ny dp mz lh nz oa nb ll ob oc nd lp od oe nf of bi translated">复杂性度量</h2><ul class=""><li id="c059" class="lu lv it la b lb nh le ni lh oj ll ok lp ol lt lz ma mb mc bi translated">时间复杂度:<em class="nm"> O(n 2 ) </em>因为我们遍历的是大小为<em class="nm"> n </em>的完整矩阵。</li><li id="f6df" class="lu lv it la b lb md le me lh mf ll mg lp mh lt lz ma mb mc bi translated">空间复杂度:<em class="nm"> O </em> ( <em class="nm"> n </em>)因为存储我们访问过的用户的<code class="fe nn no np nq b">visited</code>数组的大小是<em class="nm"> n </em>。</li></ul></div><div class="ab cl mi mj hx mk" role="separator"><span class="ml bw bk mm mn mo"/><span class="ml bw bk mm mn mo"/><span class="ml bw bk mm mn"/></div><div class="im in io ip iq"><h1 id="5d3e" class="mp mq it bd mr ms mt mu mv mw mx my mz jz na ka nb kc nc kd nd kf ne kg nf ng bi translated">3.谷歌日历功能:查找会议室(堆)</h1><p id="0e7c" class="pw-post-body-paragraph ky kz it la b lb nh ju ld le ni jx lg lh nj lj lk ll nk ln lo lp nl lr ls lt im bi translated">Google日历工具是用来管理事件和提醒的GSuite的一部分。假设您是Google Calendar应用程序团队的开发人员，您的任务是实现一些提高生产力的特性。</p><p id="eb6a" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">任务:你的目标是创建一个安排会议的功能。您需要确定并锁定这些会议的最小会议室数量。</p><p id="f5b5" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">为此，我们有一些会议时间。我们需要找到一种方法来确定安排所有会议所需的会议室数量。每个会议将包含一个<code class="fe nn no np nq b">startTime</code>和一个<code class="fe nn no np nq b">endTime</code>的正整数。</p><p id="0047" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">我们的会议时间可以列举如下:<code class="fe nn no np nq b">{{2, 8}, {3, 4}, {3, 9}, {5, 11}, {8, 20}, {11, 15}}</code>。我们可以把每次会议安排在一个单独的房间里，但是我们希望使用最少的房间。我们观察到三个会议重叠:<code class="fe nn no np nq b">{2, 8}</code>、<code class="fe nn no np nq b">{3, 4}</code>和<code class="fe nn no np nq b">{3, 9}</code>。因此，至少这三个需要单独的房间。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi on"><img src="../Images/55f2da719f797cd85da2c33f6076f8f6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*1R-ebgllWSkL_lDGeY3ABQ.png"/></div></div></figure><p id="4a89" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">为了解决这个问题，我们使用堆或者优先级队列来存储会议时间，使用每个会议的<code class="fe nn no np nq b">end_time</code>作为一个键。我们顶层的房间会最早空出来。如果从顶部开始的会议室没有空闲，那么没有其他房间是空闲的。</p><p id="95b7" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">那么，我们如何构建这个功能呢？我们来分解一下。</p><ol class=""><li id="e7f6" class="lu lv it la b lb lc le lf lh lw ll lx lp ly lt ns ma mb mc bi translated">按<code class="fe nn no np nq b">startTime</code>对会议进行排序。</li><li id="1732" class="lu lv it la b lb md le me lh mf ll mg lp mh lt ns ma mb mc bi translated">将第一次会议分配到一个房间。将<code class="fe nn no np nq b">endTime</code>作为一个条目添加到堆中。</li><li id="8d56" class="lu lv it la b lb md le me lh mf ll mg lp mh lt ns ma mb mc bi translated">遍历其他会议，检查顶部的会议是否已经结束。</li><li id="c9f0" class="lu lv it la b lb md le me lh mf ll mg lp mh lt ns ma mb mc bi translated">如果房间是空闲的，提取这个元素，并将其与我们想要处理的当前会议的结束时间一起再次添加到堆中。如果它不是免费的，分配一个新的房间，并将其添加到我们的堆中。</li><li id="7b76" class="lu lv it la b lb md le me lh mf ll mg lp mh lt ns ma mb mc bi translated">处理完会议列表后，堆的大小将告诉我们分配了多少个房间。这应该是我们需要的最少房间数。</li></ol><h2 id="53b7" class="nu mq it bd mr nv nw dn mv nx ny dp mz lh nz oa nb ll ob oc nd lp od oe nf of bi translated">Java解决方案</h2><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="og oh l"/></div></figure><p id="7b2a" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">如果你想看Python中的解决方案，请查看原始的<a class="ae oi" href="https://www.educative.io/blog/crack-coding-interview-real-world-problems" rel="noopener ugc nofollow" target="_blank">帖子</a>。</p><h2 id="0f20" class="nu mq it bd mr nv nw dn mv nx ny dp mz lh nz oa nb ll ob oc nd lp od oe nf of bi translated">复杂性度量</h2><ul class=""><li id="b292" class="lu lv it la b lb nh le ni lh oj ll ok lp ol lt lz ma mb mc bi translated">时间复杂度:<em class="nm">O</em>(<em class="nm">n</em>∫<em class="nm">log</em>(<em class="nm">n</em>))</li><li id="f036" class="lu lv it la b lb md le me lh mf ll mg lp mh lt lz ma mb mc bi translated">空间复杂度:<em class="nm"> O </em> ( <em class="nm"> n </em>，其中<em class="nm"> n </em>为会议次数。</li></ul></div><div class="ab cl mi mj hx mk" role="separator"><span class="ml bw bk mm mn mo"/><span class="ml bw bk mm mn mo"/><span class="ml bw bk mm mn"/></div><div class="im in io ip iq"><h1 id="e68c" class="mp mq it bd mr ms mt mu mv mw mx my mz jz na ka nb kc nc kd nd kf ne kg nf ng bi translated">4.亚马逊特色:价格范围内的产品(BST)</h1><p id="4a69" class="pw-post-body-paragraph ky kz it la b lb nh ju ld le ni jx lg lh nj lj lk ll nk ln lo lp nl lr ls lt im bi translated">亚马逊是世界上最大的在线商店，他们总是在寻找更好的方式向客户推荐产品。假设你是亚马逊商店的开发人员。</p><p id="5fab" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">任务:实现一个搜索过滤器来查找给定价格范围内的产品。产品数据是二叉查找树的形式。价值是产品的价格。</p><p id="af38" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">我们正在处理的参数是<code class="fe nn no np nq b">low</code>和<code class="fe nn no np nq b">high</code>，它们代表用户的价格范围。下面的产品列表示例对应于它们的价格。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi oo"><img src="../Images/6b39f65eba3eba024970f6d7fe0d396f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*UN2sdaEad_Ze_atLZi43EA.png"/></div></div></figure><p id="6fec" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">然后，它们被保存在二叉查找树中:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi op"><img src="../Images/4221e9a86f0e69ea4fc0695575b03cab.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*21WZvOUZ8mZCID9FOIjTQA.png"/></div></div></figure><p id="3e51" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">我们可以假设选择的价格范围是<code class="fe nn no np nq b">low = 7</code>和<code class="fe nn no np nq b">high = 20</code>，所以我们的函数解决方案应该只返回价格<code class="fe nn no np nq b">{9, 8, 14, 20, 17}</code>。那么，我们如何实现这一点呢？我们来分解一下。</p><p id="bdba" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">我们将使用二叉树的前序遍历的变体来解决这个问题，但是其他二叉树遍历也可以。</p><ol class=""><li id="b210" class="lu lv it la b lb lc le lf lh lw ll lx lp ly lt ns ma mb mc bi translated">为前序遍历实现一个递归帮助函数。</li><li id="c52e" class="lu lv it la b lb md le me lh mf ll mg lp mh lt ns ma mb mc bi translated">检查当前节点值是否在我们给定的范围内。如果是，将其添加到<code class="fe nn no np nq b">output</code>数组中。</li><li id="7c8a" class="lu lv it la b lb md le me lh mf ll mg lp mh lt ns ma mb mc bi translated">如果当前节点值大于或等于<code class="fe nn no np nq b">low</code>，递归调用节点左边子节点的preorder函数。</li><li id="8c3e" class="lu lv it la b lb md le me lh mf ll mg lp mh lt ns ma mb mc bi translated">如果当前节点值小于或等于<code class="fe nn no np nq b">high</code>，递归遍历该节点的右子节点。</li><li id="22d0" class="lu lv it la b lb md le me lh mf ll mg lp mh lt ns ma mb mc bi translated">遍历完成后，将返回<code class="fe nn no np nq b">output</code>数组。</li></ol><h2 id="a71e" class="nu mq it bd mr nv nw dn mv nx ny dp mz lh nz oa nb ll ob oc nd lp od oe nf of bi translated">Java解决方案</h2><p id="d940" class="pw-post-body-paragraph ky kz it la b lb nh ju ld le ni jx lg lh nj lj lk ll nk ln lo lp nl lr ls lt im bi translated"><code class="fe nn no np nq b">BinarySearchTree.java</code>:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="og oh l"/></div></figure><p id="3d22" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated"><code class="fe nn no np nq b">main.java</code>:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="og oh l"/></div></figure><p id="62b8" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">如果你想看Python中的解决方案，可以查看原始的<a class="ae oi" href="https://www.educative.io/blog/crack-coding-interview-real-world-problems" rel="noopener ugc nofollow" target="_blank">帖子</a>。</p><h2 id="da67" class="nu mq it bd mr nv nw dn mv nx ny dp mz lh nz oa nb ll ob oc nd lp od oe nf of bi translated">复杂性度量</h2><ul class=""><li id="618d" class="lu lv it la b lb nh le ni lh oj ll ok lp ol lt lz ma mb mc bi translated">时间复杂度:<em class="nm"> O(n) </em></li><li id="a4a8" class="lu lv it la b lb md le me lh mf ll mg lp mh lt lz ma mb mc bi translated">空间复杂度:<em class="nm"> O(n) </em></li></ul></div><div class="ab cl mi mj hx mk" role="separator"><span class="ml bw bk mm mn mo"/><span class="ml bw bk mm mn mo"/><span class="ml bw bk mm mn"/></div><div class="im in io ip iq"><h1 id="b091" class="mp mq it bd mr ms mt mu mv mw mx my mz jz na ka nb kc nc kd nd kf ne kg nf ng bi translated">5.Twitter功能:添加喜欢(字符串)</h1><p id="ff80" class="pw-post-body-paragraph ky kz it la b lb nh ju ld le ni jx lg lh nj lj lk ll nk ln lo lp nl lr ls lt im bi translated">Twitter是一个流行的社交媒体平台。假设您是一名Twitter开发人员，您的团队必须创建一个API来计算某个人的推文中的赞数。</p><p id="1ec0" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">任务:创建一个API来计算一个人的推文的总点赞数。创建一个接受两个数并返回这两个数之和的模块。</p><p id="7707" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">数据已经提取出来并存储在一个简单的文本文件中。所有的值都应该是字符串，并且<em class="nm">不能转换成整数</em>。由于这些限制，我们必须一位一位地做加法。那么，我们如何创建这个模块呢？我们来分解一下。</p><ol class=""><li id="10d5" class="lu lv it la b lb lc le lf lh lw ll lx lp ly lt ns ma mb mc bi translated">将一个空的<code class="fe nn no np nq b">res</code>变量和<code class="fe nn no np nq b">carry</code>初始化为<code class="fe nn no np nq b">0</code>。</li><li id="2336" class="lu lv it la b lb md le me lh mf ll mg lp mh lt ns ma mb mc bi translated">然后，设置两个指针(<code class="fe nn no np nq b">p1</code>和<code class="fe nn no np nq b">p2</code>)，指向<code class="fe nn no np nq b">like1</code>和<code class="fe nn no np nq b">like2</code>的末端。</li><li id="94d0" class="lu lv it la b lb md le me lh mf ll mg lp mh lt ns ma mb mc bi translated">使用这些指针从末尾开始遍历字符串。设置它在两个字符串都完成时停止。</li><li id="f3f8" class="lu lv it la b lb md le me lh mf ll mg lp mh lt ns ma mb mc bi translated">在<code class="fe nn no np nq b">index p1</code>将<code class="fe nn no np nq b">x1</code>设置为字符串<code class="fe nn no np nq b">like1</code>中的一个数字。如果<code class="fe nn no np nq b">p1</code>已经到达<code class="fe nn no np nq b">like1</code>的起点，则将<code class="fe nn no np nq b">x1</code>设置为<code class="fe nn no np nq b">0</code>。用<code class="fe nn no np nq b">index p2</code>处的<code class="fe nn no np nq b">like2</code>对<code class="fe nn no np nq b">x2</code>进行同样的操作。</li><li id="ad65" class="lu lv it la b lb md le me lh mf ll mg lp mh lt ns ma mb mc bi translated">使用<code class="fe nn no np nq b">value = (x1 + x2 + carry) % 10</code>计算当前值。然后更新<code class="fe nn no np nq b">carry</code>以便<code class="fe nn no np nq b">carry = (x1 + x2 + carry) / 10</code>。</li><li id="9a87" class="lu lv it la b lb md le me lh mf ll mg lp mh lt ns ma mb mc bi translated">将当前值追加到结果中。</li><li id="6dba" class="lu lv it la b lb md le me lh mf ll mg lp mh lt ns ma mb mc bi translated">如果两个字符串都被遍历，但是<code class="fe nn no np nq b">carry</code>仍然是非零的，则将<code class="fe nn no np nq b">carry</code>附加到<code class="fe nn no np nq b">res</code>。</li><li id="431e" class="lu lv it la b lb md le me lh mf ll mg lp mh lt ns ma mb mc bi translated">最后，反转结果并将其转换为字符串。返回最后一个字符串。</li></ol><h2 id="e33e" class="nu mq it bd mr nv nw dn mv nx ny dp mz lh nz oa nb ll ob oc nd lp od oe nf of bi translated">Java解决方案</h2><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="og oh l"/></div></figure><h2 id="606c" class="nu mq it bd mr nv nw dn mv nx ny dp mz lh nz oa nb ll ob oc nd lp od oe nf of bi translated">复杂性度量</h2><ul class=""><li id="3230" class="lu lv it la b lb nh le ni lh oj ll ok lp ol lt lz ma mb mc bi translated">时间复杂度:<em class="nm"> O </em> ( <em class="nm"> max </em> (n，n))</li><li id="cbb8" class="lu lv it la b lb md le me lh mf ll mg lp mh lt lz ma mb mc bi translated">空间复杂度:<em class="nm"> O </em> ( <em class="nm"> max </em> (n，n))</li></ul></div><div class="ab cl mi mj hx mk" role="separator"><span class="ml bw bk mm mn mo"/><span class="ml bw bk mm mn mo"/><span class="ml bw bk mm mn"/></div><div class="im in io ip iq"><h1 id="9bd5" class="mp mq it bd mr ms mt mu mv mw mx my mz jz na ka nb kc nc kd nd kf ne kg nf ng bi translated">从这里去哪里</h1><p id="230b" class="pw-post-body-paragraph ky kz it la b lb nh ju ld le ni jx lg lh nj lj lk ll nk ln lo lp nl lr ls lt im bi translated">恭喜你坚持到最后！您刚刚使用诸如DFS、BST、heaps等技能构建了五个真实世界的特性。正如你所看到的，这是为编码面试做准备的一个强有力的方法，往往更有效。如果你能理解问题的潜在模式，你就能解决任何问题。这是重新设想的编码面试准备。<strong class="la iu"> </strong>快乐学习！</p><p id="4d54" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">像这样的练习题还有很多，比如:</p><ul class=""><li id="1664" class="lu lv it la b lb lc le lf lh lw ll lx lp ly lt lz ma mb mc bi translated">在Twitter feed中合并推文</li><li id="7164" class="lu lv it la b lb md le me lh mf ll mg lp mh lt lz ma mb mc bi translated">美国电话电报公司确定位置</li><li id="0b9a" class="lu lv it la b lb md le me lh mf ll mg lp mh lt lz ma mb mc bi translated">缩放:显示大厅会议</li><li id="d0f4" class="lu lv it la b lb md le me lh mf ll mg lp mh lt lz ma mb mc bi translated">搜索引擎:获取单词</li><li id="e5a6" class="lu lv it la b lb md le me lh mf ll mg lp mh lt lz ma mb mc bi translated">更多</li></ul></div></div>    
</body>
</html>