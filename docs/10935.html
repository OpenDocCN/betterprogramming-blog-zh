<html>
<head>
<title>AWS WebSockets: Writing Documentation Using Async API Spec</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">AWS WebSockets:使用异步API规范编写文档</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/aws-websockets-writing-documentation-using-async-api-spec-6c4ccc77f20?source=collection_archive---------11-----------------------#2022-02-04">https://betterprogramming.pub/aws-websockets-writing-documentation-using-async-api-spec-6c4ccc77f20?source=collection_archive---------11-----------------------#2022-02-04</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="35c6" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">对于一个优秀的API来说，一个关键但经常被忽视的部分是文档。探索如何用异步API规范正确地记录事件驱动的架构</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/e12f9334b242c447d8384e56ecda816d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*oSfiYfA6p56F7OQVtcGWdg.jpeg"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">由<a class="ae ky" href="https://unsplash.com/@anetakpawlik?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Aneta Pawlik </a>在<a class="ae ky" href="https://unsplash.com/s/photos/bookshelf?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</p></figure><p id="19e8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">还记得你最后一次与第三方API集成吗？你是怎么做到的？容易吗？</p><p id="bb5a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">任何整合的第一步都是<em class="lv">查看文档</em>。如果没有文档，您成功集成该服务的可能性大约为0%。</p><p id="a418" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">开发人员最讨厌的一部分软件，就像编写单元测试一样，是构建API规范文档。不幸的是，如果你想在你的集成商中取得任何成功，这是必须的。</p><p id="7b08" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在使用<a class="ae ky" href="https://www.openapis.org/" rel="noopener ugc nofollow" target="_blank">开放API规范</a>之前，我曾经写过关于REST APIs的<a class="ae ky" rel="noopener ugc nofollow" target="_blank" href="/api-first-development-build-consistent-meaningful-apis-with-postman-db7d1e9e8b5c">文档过程</a>的博文。这是一个了不起的工具，<a class="ae ky" rel="noopener ugc nofollow" target="_blank" href="/how-to-create-an-extension-for-your-open-api-specification-fc5f51c82bb8">允许你轻松地扩展它</a>来满足你的需求。</p><p id="1933" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">但是我们处在一个不同的世界，有了WebSockets。这不是你奶奶以前学校的API。这就是AWS中的<a class="ae ky" href="https://aws.amazon.com/event-driven-architecture/" rel="noopener ugc nofollow" target="_blank">事件驱动架构</a>。这是一个完全不同的游戏。</p><p id="ba4e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们将关注如何使用<a class="ae ky" href="https://www.asyncapi.com/" rel="noopener ugc nofollow" target="_blank">异步API规范</a>来记录API。这个规范允许我们定义描述消费者如何与系统交互的<code class="fe lw lx ly lz b">channels</code>而不是<code class="fe lw lx ly lz b">endpoints</code>。</p><p id="8a8e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果你没有跟上，这是AWS WebSockets 系列介绍的第三部分。我强烈建议你阅读前两部分，因为每篇文章都是建立在前一篇文章的基础上的。</p><ul class=""><li id="4b5b" class="ma mb it lb b lc ld lf lg li mc lm md lq me lu mf mg mh mi bi translated"><a class="ae ky" rel="noopener ugc nofollow" target="_blank" href="/introduction-to-aws-websockets-8b336a92c379">第一部分——构建一个WebSocket </a></li><li id="400c" class="ma mb it lb b lc mj lf mk li ml lm mm lq mn lu mf mg mh mi bi translated"><a class="ae ky" rel="noopener ugc nofollow" target="_blank" href="/using-authoriser-for-aws-websockets-caf7a0441c8e">第二部分—保护您的网络插座</a></li></ul></div><div class="ab cl mo mp hx mq" role="separator"><span class="mr bw bk ms mt mu"/><span class="mr bw bk ms mt mu"/><span class="mr bw bk ms mt"/></div><div class="im in io ip iq"><h1 id="1db4" class="mv mw it bd mx my mz na nb nc nd ne nf jz ng ka nh kc ni kd nj kf nk kg nl nm bi translated">异步API规范</h1><p id="5359" class="pw-post-body-paragraph kz la it lb b lc nn ju le lf no jx lh li np lk ll lm nq lo lp lq nr ls lt lu im bi translated">到目前为止，我们在AWS中构建的API有两个基于事件的交互:</p><ul class=""><li id="7c18" class="ma mb it lb b lc ld lf lg li mc lm md lq me lu mf mg mh mi bi translated">用户可以订阅实体更新的WebSocket</li><li id="eeec" class="ma mb it lb b lc mj lf mk li ml lm mm lq mn lu mf mg mh mi bi translated">在WebSocket中触发推送通知的EventBridge事件</li></ul><p id="0a88" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">对于传统的开放API规范，我们没有任何选项来通知消费者关于模式、连接信息或与事件的可能交互。这不是该规范所要描述的。该规范描述了同步REST API端点。</p><p id="5a74" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">然而，<a class="ae ky" href="https://www.asyncapi.com/docs/specifications/v2.3.0" rel="noopener ugc nofollow" target="_blank"> Async API规范</a>正是为了做到这一点而设计的。它记录了驱动行为的事件，并说明了用户可以在我们的WebSocket上进行的<code class="fe lw lx ly lz b">publish</code>和<code class="fe lw lx ly lz b">subscribe</code>交互。</p><p id="25ae" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">要开始使用我们的WebSocket规范，用下面的命令检查<a class="ae ky" href="https://github.com/allenheltondev/serverless-websockets" rel="noopener ugc nofollow" target="_blank"> GitHub </a>中<code class="fe lw lx ly lz b">serverless-websockets</code> repo的<a class="ae ky" href="https://github.com/allenheltondev/serverless-websockets/tree/part-three" rel="noopener ugc nofollow" target="_blank"> part-three </a>分支:</p><pre class="kj kk kl km gt ns lz nt nu aw nv bi"><span id="aabe" class="nw mw it lz b gy nx ny l nz oa">git fetch <br/>git checkout part-three</span></pre><p id="fbdb" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><em class="lv">注意——这里假设您已经</em> <a class="ae ky" href="https://docs.github.com/en/repositories/creating-and-managing-repositories/cloning-a-repository" rel="noopener ugc nofollow" target="_blank"> <em class="lv">克隆了存储库</em> </a> <em class="lv">并且在您的机器上本地可用</em></p></div><div class="ab cl mo mp hx mq" role="separator"><span class="mr bw bk ms mt mu"/><span class="mr bw bk ms mt mu"/><span class="mr bw bk ms mt"/></div><div class="im in io ip iq"><h1 id="60a2" class="mv mw it bd mx my mz na nb nc nd ne nf jz ng ka nh kc ni kd nj kf nk kg nl nm bi translated">规格组件</h1><p id="1eb4" class="pw-post-body-paragraph kz la it lb b lc nn ju le lf no jx lh li np lk ll lm nq lo lp lq nr ls lt lu im bi translated">异步API规范由几个不同的组件组成。这些组件提供了关于API不同方面的信息。下面我们将讨论为WebSocket提供文档所需的所有相关部分。</p><p id="e7c6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">任何API规范的第一部分都是描述通用目的。告诉消费者API的目标是什么。在我们的例子中，我们提供了一些高级信息，告知用户规范中包含了什么。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi ob"><img src="../Images/63bdacde57861eb0c59c0cad346bc793.png" data-original-src="https://miro.medium.com/v2/resize:fit:1364/format:webp/0*dhZtTGQ-z8iiukP2.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated"><em class="oc">规格版本、标题、API版本、描述和内容类型</em></p></figure><p id="c97e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">该规范支持<code class="fe lw lx ly lz b">description</code>组件中的<a class="ae ky" href="https://spec.commonmark.org/0.30/" rel="noopener ugc nofollow" target="_blank"> Markdown </a>，因此您的文档可以显示丰富的格式化文本。</p></div><div class="ab cl mo mp hx mq" role="separator"><span class="mr bw bk ms mt mu"/><span class="mr bw bk ms mt mu"/><span class="mr bw bk ms mt"/></div><div class="im in io ip iq"><h1 id="99e4" class="mv mw it bd mx my mz na nb nc nd ne nf jz ng ka nh kc ni kd nj kf nk kg nl nm bi translated">连接详细信息</h1><p id="ef1d" class="pw-post-body-paragraph kz la it lb b lc nn ju le lf no jx lh li np lk ll lm nq lo lp lq nr ls lt lu im bi translated">可以说，规范中最重要的部分是连接信息。消费者必须知道如何连接到API，以及每个环境的基本url是什么。</p><p id="3a7f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这包含在规范的<code class="fe lw lx ly lz b">servers</code>部分。因为我们的WebSocket API要求提供一个<code class="fe lw lx ly lz b">access_token</code>，所以我们必须在这里包含它。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi od"><img src="../Images/5002a0dbe7d7918e7a6917d996e7e984.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*bJWIxZukda3Fu4W7.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated"><em class="oc">描述连接url、协议和认证方法</em></p></figure><p id="4e3b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">对于具有安全连接的WebSockets，您将总是使用<a class="ae ky" href="https://portswigger.net/web-security/websockets/what-are-websockets" rel="noopener ugc nofollow" target="_blank"> wss协议</a>。未加密的连接使用<code class="fe lw lx ly lz b">ws</code>协议。因为我们的WebSocket API有一个安全的连接，并且需要一个auth令牌，所以我们在这里使用了<code class="fe lw lx ly lz b">wss</code>。</p></div><div class="ab cl mo mp hx mq" role="separator"><span class="mr bw bk ms mt mu"/><span class="mr bw bk ms mt mu"/><span class="mr bw bk ms mt"/></div><div class="im in io ip iq"><h1 id="85dd" class="mv mw it bd mx my mz na nb nc nd ne nf jz ng ka nh kc ni kd nj kf nk kg nl nm bi translated">列出事件</h1><p id="fcc5" class="pw-post-body-paragraph kz la it lb b lc nn ju le lf no jx lh li np lk ll lm nq lo lp lq nr ls lt lu im bi translated">对于异步API规范，事件包含在<code class="fe lw lx ly lz b">channels</code>中。通道是在事件驱动的API中组织事件的一种简单方式。对于我们的用例，我们希望在一个通道中包含与WebSocket相关的所有事件，在另一个通道中包含触发推送通知的EventBridge事件。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi od"><img src="../Images/6911e4c43601cbbe5a5233f1ca7c44ff.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*gK2K9eLOfudBq7mT.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated"><em class="oc">我们的WebSocket的通道及其相应的事件</em></p></figure><p id="5f16" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">每个<em class="lv">通道</em>中包含<code class="fe lw lx ly lz b">publish</code>和<code class="fe lw lx ly lz b">subscribe</code>的选项。从规范消费者的角度来看，包含在<code class="fe lw lx ly lz b">publish</code>部分下的事件意味着消费者可以将该事件发布到API。包含在<code class="fe lw lx ly lz b">subscribe</code>部分的事件是消费者将从API收到的事件。</p><p id="d16b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在我们的规范中，我们希望让消费者知道他们将使用什么AWS服务来发布或订阅特定事件。这是通过使用<code class="fe lw lx ly lz b">tags</code>完成的。在每个<em class="lv">通道</em>的每个<code class="fe lw lx ly lz b">publish</code>或<code class="fe lw lx ly lz b">subscribe</code>部分下，我们包含一个标签，说明触发事件的系统。</p><h2 id="b7d6" class="nw mw it bd mx oe of dn nb og oh dp nf li oi oj nh lm ok ol nj lq om on nl oo bi translated">用JSON模式描述事件</h2><p id="37fe" class="pw-post-body-paragraph kz la it lb b lc nn ju le lf no jx lh li np lk ll lm nq lo lp lq nr ls lt lu im bi translated">为了给我们规范的消费者提供最佳体验，我们必须描述API消费/产生的事件模式。为此，我们在规范的<code class="fe lw lx ly lz b">messages</code>部分描述了有效载荷。</p><p id="c821" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">正如我们在上面的截图中看到的，每个<em class="lv">频道</em>的<code class="fe lw lx ly lz b">publish</code>和<code class="fe lw lx ly lz b">subscribe</code>部分包含一个消息的引用(<code class="fe lw lx ly lz b">$ref</code>)。引用包含特定于该消息的信息，如标题、<em class="lv">摘要</em>，以及我们想要提供给消费者的任何<em class="lv">示例</em>。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi od"><img src="../Images/aee116f43e98e4c0b84e541cfecc2206.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*5Qq2m6fCnaiandCl.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated"><em class="oc">JSON模式中订阅事件的消息和模式</em></p></figure><p id="1555" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe lw lx ly lz b">payload</code>对象包含对描述事件属性的<a class="ae ky" href="https://json-schema.org/" rel="noopener ugc nofollow" target="_blank"> JSON模式</a>对象的引用。这允许使用者确切地知道如何在发布时定义事件，或者如何编写使用订阅事件的代码。甚至还有在线的<a class="ae ky" href="https://json-schema-faker.js.org/" rel="noopener ugc nofollow" target="_blank">工具</a>从JSON Schema中生成示例(<a class="ae ky" href="https://www.liquid-technologies.com/online-json-to-schema-converter" rel="noopener ugc nofollow" target="_blank">反之亦然</a>)。</p><p id="813e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">对于在<code class="fe lw lx ly lz b">publish</code>或<code class="fe lw lx ly lz b">subscribe</code>部分包含多条消息的通道，可以使用JSON模式<code class="fe lw lx ly lz b">oneOf</code>对象。这向消费者发出信号，通过该通道发布或订阅的消息可能是各种各样的事情之一。</p><p id="49c3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">只要你在<code class="fe lw lx ly lz b">messages</code>和<code class="fe lw lx ly lz b">schema</code>部分明确定义了你的信息，你的消费者就会知道该用什么！</p></div><div class="ab cl mo mp hx mq" role="separator"><span class="mr bw bk ms mt mu"/><span class="mr bw bk ms mt mu"/><span class="mr bw bk ms mt"/></div><div class="im in io ip iq"><h1 id="7014" class="mv mw it bd mx my mz na nb nc nd ne nf jz ng ka nh kc ni kd nj kf nk kg nl nm bi translated">建立你自己的</h1><p id="180a" class="pw-post-body-paragraph kz la it lb b lc nn ju le lf no jx lh li np lk ll lm nq lo lp lq nr ls lt lu im bi translated">有时候，从头开始创建一个新的规范，甚至对现有的规范进行更新，都不是最简单的任务。幸运的是，有一些免费的工具可以让你使用起来更容易。</p><p id="70fe" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">文档是集成商成功的关键，无论是内部还是外部。如果你的事件和联系信息没有在任何地方被记录，你最终会依赖于<a class="ae ky" href="https://www.lucidchart.com/blog/what-is-tribal-knowledge" rel="noopener ugc nofollow" target="_blank">部落知识</a>，这很难在内部维护，也不可能在外部维护。</p><p id="427c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">感谢Async API，我们能够清楚地说明我们的事件模式是什么，各种<em class="lv">通道</em>是什么，消费者可以发布或订阅哪些事件，以及发布或订阅需要什么服务/媒介(EventBridge或WebSocket)。</p><p id="6711" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">既然我们已经有了WebSocket的文档，我们可以合理地假设内部和外部的团队都可以连接并使用它。</p></div><div class="ab cl mo mp hx mq" role="separator"><span class="mr bw bk ms mt mu"/><span class="mr bw bk ms mt mu"/><span class="mr bw bk ms mt"/></div><div class="im in io ip iq"><h1 id="46b5" class="mv mw it bd mx my mz na nb nc nd ne nf jz ng ka nh kc ni kd nj kf nk kg nl nm bi translated">后续步骤</h1><p id="7dd7" class="pw-post-body-paragraph kz la it lb b lc nn ju le lf no jx lh li np lk ll lm nq lo lp lq nr ls lt lu im bi translated">我们的WebSocket之旅还没有结束。接下来，我们将添加特定于用户的通知，并向WebSocket添加一个自定义域。本系列的最后一部分将讨论如何将一个长期运行的同步端点转移到一个带有WebSocket通知的异步工作流中，以告知用户整个过程的进展情况。</p><p id="f058" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">感谢您和我一起探索AWS WebSockets。我希望你继续享受更新，并跟随到底。</p><p id="3b3a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">编码快乐！</p></div></div>    
</body>
</html>