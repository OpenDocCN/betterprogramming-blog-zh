<html>
<head>
<title>Understanding Vertical Pod Autoscaling in Kubernetes</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">了解Kubernetes中的垂直Pod自动缩放</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/understanding-vertical-pod-autoscaling-in-kubernetes-6d53e6d96ef3?source=collection_archive---------0-----------------------#2020-09-21">https://betterprogramming.pub/understanding-vertical-pod-autoscaling-in-kubernetes-6d53e6d96ef3?source=collection_archive---------0-----------------------#2020-09-21</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="df80" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">以及为什么不应该在自动模式下使用它</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/7940099d024e9cd7c0be87a8f09b6d16.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*E5WkrPKmWDyFqYmryYkxMw.jpeg"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">道格拉斯·桑切斯在<a class="ae ky" href="https://unsplash.com/s/photos/future?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的照片</p></figure><p id="975a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">垂直Pod自动伸缩是Kubernetes的一个很酷的特性，但没有被充分利用——这是有原因的。Kubernetes是为水平扩展而构建的，至少在最初，垂直扩展pod似乎不是一个好主意。相反，如果您想处理额外的负载，创建Pod的副本更有意义。</p><p id="0377" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">然而，这需要大量的资源优化，如果您没有通过提供适当的资源请求和限制配置来适当地调整您的Pod，您可能会过于频繁地驱逐您的Pod，或者浪费许多有用的资源。如果您分配给Pod的请求资源太少，您的Pod可能没有足够的资源来启动，如果您分配太多，它将最终浪费可能对其他Pod有用的有用资源。</p><p id="fdb0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">使用Kubernetes的想法是在最少的基础设施中打包尽可能多的容器(显然这也需要您保留一个缓冲区来处理节点故障，但是您明白这一点)。开发人员和系统管理员努力寻找资源请求和限制的最佳值。通过基准测试或通过对生产利用率和流量的一般观察，对它们进行调优需要大量的监控和对二者利用率的了解。</p><p id="9be2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">当交通不稳定和资源利用不理想时，事情开始变得复杂。随着微服务架构中容器的增长，理解资源利用模式变得越来越具有挑战性，因为系统管理员更加关注稳定性，最终使用的资源请求远远超过实际需要。</p><p id="6ad9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">Kubernetes提出了一个解决方案，用垂直Pod自动缩放器来解决这个问题。让我们了解它的作用以及何时应该使用它，然后我们看一个小例子来看看它的实际应用。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="5cc6" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">垂直Pod自动缩放器的工作原理</h1><p id="348f" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">垂直窗格自动缩放使用两个主要组件来实现自动缩放。算法是这样的:</p><ul class=""><li id="22ba" class="mz na it lb b lc ld lf lg li nb lm nc lq nd lu ne nf ng nh bi translated">VPA推荐器检查历史资源利用率和当前使用模式，并推荐理想的资源请求值。</li><li id="1b13" class="mz na it lb b lc ni lf nj li nk lm nl lq nm lu ne nf ng nh bi translated">如果您已经将更新模式定义为自动，VPA自动调整器将收回正在运行的Pod，并基于新的资源请求值创建一个新的Pod。</li><li id="f17e" class="mz na it lb b lc ni lf nj li nk lm nl lq nm lu ne nf ng nh bi translated">VPA自动调节器还将按照最初定义的限值(如果有)的比率来调整限值。然而，它并没有建议限制应该是什么。</li></ul><p id="6d64" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">没有资源限制的含义——自动调整器会一直增加它。但是，如果您想防止内存泄漏，可以在VPA规范中设置最大资源值。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="678a" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">VPA舱单</h1><p id="b925" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">让我们看看下面的VPA清单示例:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nn no l"/></div></figure><p id="c374" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">像任何清单一样，它有一个<code class="fe np nq nr ns b">apiVersion</code>、<code class="fe np nq nr ns b">kind</code>、<code class="fe np nq nr ns b">metadata</code>和<code class="fe np nq nr ns b">spec</code>部分。</p><p id="3fe4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在spec部分中，我们看到一个<code class="fe np nq nr ns b">targetRef</code>部分，它指定了这个VPA应用到的对象。<code class="fe np nq nr ns b">updatePolicy</code>部分定义了这个VPA是推荐还是基于<code class="fe np nq nr ns b">updateMode</code>属性推荐和自动缩放。如果<code class="fe np nq nr ns b">updateMode</code>属性被设置为<code class="fe np nq nr ns b">Auto</code>，它会垂直自动缩放窗格，如果<code class="fe np nq nr ns b">Off</code>，它只会推荐理想的资源请求值。</p><p id="6cb5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe np nq nr ns b">resourcePolicy</code>部分允许我们用<code class="fe np nq nr ns b">minAllowed</code>和<code class="fe np nq nr ns b">maxAllowed</code>资源值为每个容器指定<code class="fe np nq nr ns b">containerPolicies</code>。这对于避免内存泄漏极其重要。您还可以在pod内的特定容器上关闭资源推荐和自动缩放，通常在Istio sidecars或<code class="fe np nq nr ns b">InitContainers</code>中可以看到。</p><p id="ec2e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">哇——这可真难。在下一节中，让我们了解一些限制。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="f23c" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">限制</h1><p id="1e5c" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">垂直Pod自动缩放有局限性。</p><h2 id="c5e4" class="nt md it bd me nu nv dn mi nw nx dp mm li ny nz mo lm oa ob mq lq oc od ms oe bi translated">您不能将它与水平窗格自动缩放一起使用。</h2><p id="255a" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">由于垂直单元自动扩展会自动修改请求和限制，因此您不能将其与水平单元自动扩展一起使用，因为HPA依赖于CPU和内存利用率来水平扩展单元。一个例外是，当您使用依靠自定义和外部指标来扩展单元的HPA时。</p><h2 id="9d6e" class="nt md it bd me nu nv dn mi nw nx dp mm li ny nz mo lm oa ob mq lq oc od ms oe bi translated">它需要至少两个健康的pod副本才能工作</h2><p id="39b1" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">这首先违背了它的目的，也是它没有被广泛使用的原因。当VPA销毁一个pod并重新创建它以垂直自动扩展它时，它需要至少两个健康的pod副本来确保没有服务中断。这给单实例有状态应用程序带来了不必要的设计复杂性，您将不得不考虑复制设计。对于无状态应用程序，使用水平窗格自动缩放比VPA更好。</p><h2 id="ddd9" class="nt md it bd me nu nv dn mi nw nx dp mm li ny nz mo lm oa ob mq lq oc od ms oe bi translated">默认情况下，最小内存分配是250兆字节</h2><p id="8357" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">无论您指定什么，VPA分配的最小内存都是250兆字节。尽管这个缺省值可以在全局级别上修改，但是它对于消耗较少内存的应用程序来说是不切实际的。</p><h2 id="e2a0" class="nt md it bd me nu nv dn mi nw nx dp mm li ny nz mo lm oa ob mq lq oc od ms oe bi translated">它不能与单个pod一起使用</h2><p id="899c" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">VPA只处理部署、状态集、守护集、复制集等。您不能将其用于没有所有者的独立Pod。这不是一个显著的限制，因为我们大多数人都不使用独立的Pod，但它值得一提。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="9470" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">在推荐模式下使用VPA</h1><p id="d974" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">到目前为止，在生产中使用VPA的最佳方式是在推荐模式下使用它。这对理解什么是最佳资源请求值以及它们如何随时间变化非常有帮助。</p><p id="255f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">设置好之后，您可以通过Kubernetes操作器或使用kubectl来收集这些指标，并将其发送到Prometheus和Grafana或ELK stack等监控和可视化工具，以获得有价值的见解。</p><p id="af23" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">然后，您可以根据建议使用这些数据来调整pod的大小，方法是在一天中的安静时段进行适当的停机，这样就不会影响您的用户和业务。这也可以成为你持续改进策略的一部分。</p><p id="61c0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我不建议在生产中以自动模式运行VPA，因为它相对较新，仍在积极开发中。你最不希望的事情就是服务中断，因为VPA太频繁地驱逐你的吊舱。除非你确切地知道你在做什么，否则马上在生产中使用它是没有意义的。</p><p id="269b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">也就是说，您总是可以在您的开发环境中试验这一点，并观察它在负载增加时的表现。通过运行负载测试，您可以很容易地找到Pod可以消耗的最大资源量，我们将在下一节中看到这一点。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="bb8c" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">亲自动手</h1><p id="f7fc" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">在这个练习中，我将使用启用了VPA的GKE。GKE只在地区集团上支持VPA。</p><p id="c2bc" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">请确保您已通过准入控制器(如果使用自我管理的设置)或通过云提供商上的设置(如果使用受管集群)在集群中启用了VPA。</p><p id="7155" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们开始吧。</p><p id="14dc" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">首先，让我们创建一个NGINX部署，默认请求是250兆内存和100兆CPU。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nn no l"/></div></figure><p id="0d0e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们现在需要将这个部署公开为一个<code class="fe np nq nr ns b">LoadBalancer</code>服务。</p><pre class="kj kk kl km gt of ns og oh aw oi bi"><span id="7043" class="nt md it ns b gy oj ok l ol om">kubectl expose deployment nginx --type=LoadBalancer --port 80</span></pre><p id="2726" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们等待云提供商启动负载平衡器，然后获取负载平衡器IP。</p><pre class="kj kk kl km gt of ns og oh aw oi bi"><span id="ce46" class="nt md it ns b gy oj ok l ol om">$ kubectl get svc nginx<br/>NAME    TYPE           CLUSTER-IP   EXTERNAL-IP      PORT(S)        AGE<br/>nginx   LoadBalancer   10.4.1.4     34.121.204.234   80:30750/TCP   46s</span></pre><p id="0f44" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在，让我们用<code class="fe np nq nr ns b">updateMode: "Off"</code>创建一个垂直Pod自动缩放器。这不会纵向扩展部署，而只是提供建议。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nn no l"/></div></figure><p id="5315" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在，让我们运行一些负载测试，看看我们从负载中得到了什么建议。我将在这个测试中使用<code class="fe np nq nr ns b">hey</code>工具:</p><pre class="kj kk kl km gt of ns og oh aw oi bi"><span id="d932" class="nt md it ns b gy oj ok l ol om">hey -z 300s -c 1000 <a class="ae ky" href="http://34.121.204.234" rel="noopener ugc nofollow" target="_blank">http://34.121.204.234</a></span></pre><p id="e5f8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">使用1000个并行线程触发请求300秒——这对服务来说是一个很大的打击。</p><p id="401c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">运行以下程序，获取描述VPA的建议:</p><pre class="kj kk kl km gt of ns og oh aw oi bi"><span id="eb5e" class="nt md it ns b gy oj ok l ol om">kubectl describe vpa nginx-vpa</span></pre><p id="3b42" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果我们观察VPA一段时间，我们会发现它会逐渐建议增加资源请求:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi on"><img src="../Images/d7bdc93eb59228efbf8e608be0958266.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*Asdw5pceAsCUTHgsnWT9mA.gif"/></div></div></figure><p id="2719" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果你看一下推荐部分，你会看到几个推荐。</p><ul class=""><li id="4b52" class="mz na it lb b lc ld lf lg li nb lm nc lq nd lu ne nf ng nh bi translated">目标:这是VPA驱逐当前pod并创建另一个pod时将使用的真实值。如果您正在收集这些指标，您应该始终跟踪目标值。</li><li id="f46a" class="mz na it lb b lc ni lf nj li nk lm nl lq nm lu ne nf ng nh bi translated">下限:这反映了触发调整大小的下限。如果你的吊舱利用率低于这个，VPA将驱逐它，并按比例缩小。</li><li id="bb69" class="mz na it lb b lc ni lf nj li nk lm nl lq nm lu ne nf ng nh bi translated">上限:这表示要触发的下一个调整大小的上限。如果你的豆荚利用率超过这些值，VPA将驱逐它，并扩大规模。</li><li id="ef9b" class="mz na it lb b lc ni lf nj li nk lm nl lq nm lu ne nf ng nh bi translated">无上限目标:如果您没有提供VPA的最小或最大边界，这表示目标利用率。</li></ul><p id="cd67" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在，让我们将它付诸实践，看看如果将<code class="fe np nq nr ns b">updateMode</code>设置为<code class="fe np nq nr ns b">Auto</code>会发生什么。让我们运行下面的:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nn no l"/></div></figure><p id="c4f7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">然后让我们重新运行负载测试。在另一个终端，我们将连续观看吊舱，看它们被驱逐和重建。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi oo"><img src="../Images/b9b870883b5d518cf9297f5c9e28919a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1398/1*gn9-wvmStTc2jdYkEIVe2w.gif"/></div></figure></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="8dd7" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">结论</h1><p id="cb74" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">垂直Pod自动伸缩是Kubernetes中一个相对较新的自动伸缩概念，最适合于有状态工作负载或了解资源利用概况和建议。在目前的情况下，不建议在生产中以自动更新模式使用，但其推荐模式有利于获得见解。</p><p id="d7a5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">感谢阅读！我希望你喜欢这篇文章。</p></div></div>    
</body>
</html>