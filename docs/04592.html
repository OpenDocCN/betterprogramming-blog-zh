<html>
<head>
<title>How to Use Git Subtrees</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何使用Git子树</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/git-subtree-usage-6aaba8b5d947?source=collection_archive---------6-----------------------#2020-04-23">https://betterprogramming.pub/git-subtree-usage-6aaba8b5d947?source=collection_archive---------6-----------------------#2020-04-23</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="c523" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">其他Git存储库中的Git存储库</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/ca5eabd5d16aab3a0adc787095451a26.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*nYumsJ1_ENz1y8RiStEPUA.jpeg"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated"><a class="ae kv" href="https://unsplash.com/@mangofantasy?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">蒂姆·约翰逊</a>在<a class="ae kv" href="https://unsplash.com/s/photos/branching?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的照片</p></figure><p id="a5b2" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">没有本机子树命令，它类似于一种允许将一个存储库嵌套在另一个存储库中作为子目录的方法。这是跟踪软件依赖历史的方法之一。</p><p id="3bad" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">Git子树是Git子模块的主要替代品。然而，子树不应该与子模块混淆。Git子树是一个Git库的副本，它被放入父库。Git子模块是指向另一个存储库中特定提交的指针。与子模块不同，子树不需要存储库中的<code class="fe ls lt lu lv b">.gitmodules</code>文件或<code class="fe ls lt lu lv b">gitlinks</code>。</p></div><div class="ab cl lw lx hu ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="ij ik il im in"><h1 id="c16b" class="md me iq bd mf mg mh mi mj mk ml mm mn jw mo jx mp jz mq ka mr kc ms kd mt mu bi translated"><strong class="ak">利弊</strong></h1><p id="35d6" class="pw-post-body-paragraph kw kx iq ky b kz mv jr lb lc mw ju le lf mx lh li lj my ll lm ln mz lp lq lr ij bi translated">Git subtree有时比子模块更有优势，当您在它们之间进行选择时，应该会遇到很多优势。然而，也有一些缺点。</p><h2 id="8c6a" class="na me iq bd mf nb nc dn mj nd ne dp mn lf nf ng mp lj nh ni mr ln nj nk mt nl bi translated">赞成的意见</h2><ul class=""><li id="b97e" class="nm nn iq ky b kz mv lc mw lf no lj np ln nq lr nr ns nt nu bi translated">由旧版本的Git支持。它甚至可以处理1.5.2之前的版本。</li><li id="2111" class="nm nn iq ky b kz nv lc nw lf nx lj ny ln nz lr nr ns nt nu bi translated">简单的工作流管理</li><li id="acb8" class="nm nn iq ky b kz nv lc nw lf nx lj ny ln nz lr nr ns nt nu bi translated">超级项目完成后可用的子项目代码</li><li id="fdeb" class="nm nn iq ky b kz nv lc nw lf nx lj ny ln nz lr nr ns nt nu bi translated">没有新的Git知识</li><li id="2893" class="nm nn iq ky b kz nv lc nw lf nx lj ny ln nz lr nr ns nt nu bi translated">修改内容，而不创建独立的依赖关系存储库副本</li></ul><h2 id="b512" class="na me iq bd mf nb nc dn mj nd ne dp mn lf nf ng mp lj nh ni mr ln nj nk mt nl bi translated">骗局</h2><ul class=""><li id="6612" class="nm nn iq ky b kz mv lc mw lf no lj np ln nq lr nr ns nt nu bi translated">学习新的合并策略</li><li id="fd43" class="nm nn iq ky b kz nv lc nw lf nx lj ny ln nz lr nr ns nt nu bi translated">复杂的子项目上游贡献代码</li><li id="2cff" class="nm nn iq ky b kz nv lc nw lf nx lj ny ln nz lr nr ns nt nu bi translated">不要混合超级项目和子项目代码</li></ul></div><div class="ab cl lw lx hu ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="ij ik il im in"><h1 id="0d38" class="md me iq bd mf mg mh mi mj mk ml mm mn jw mo jx mp jz mq ka mr kc ms kd mt mu bi translated"><strong class="ak">如何使用Git子树</strong></h1><p id="a6ff" class="pw-post-body-paragraph kw kx iq ky b kz mv jr lb lc mw ju le lf mx lh li lj my ll lm ln mz lp lq lr ij bi translated">让我们讨论一个简短的场景。假设有一个外部项目，您想要将它添加到您的存储库中。例如，要在存储您的<code class="fe ls lt lu lv b">vim</code>设置的存储库中添加一个<code class="fe ls lt lu lv b">vim</code>扩展，您应该这样做:</p><pre class="kg kh ki kj gt oa lv ob oc aw od bi"><span id="543e" class="na me iq lv b gy oe of l og oh">git subtree add — prefix .vim/bundle/example <a class="ae kv" href="https://github.com/Example/vim-example.git" rel="noopener ugc nofollow" target="_blank">https://github.com/Example/vim-example.git</a> master — squash</span></pre><p id="4305" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">所举的例子将把<code class="fe ls lt lu lv b">vim-example</code>项目的全部历史压缩到你的文件夹<code class="fe ls lt lu lv b">.vim/bundle/example</code>中，记录下主人当时的SHA-1，以备将来参考。</p><pre class="kg kh ki kj gt oa lv ob oc aw od bi"><span id="9ad1" class="na me iq lv b gy oe of l og oh">commit 6d7054b3gcea64e2e31f4d6fb2e3be12e5865e87<br/>Merge: 87fa91e ef86deb<br/>Author: Bob Brown&lt;bob@brown.com&gt;<br/>Date: Tue Jun 23 13:37:03 2020 +0200<br/>Merge commit ‘fe67ddf158faccff4082d78a25c45d8cd93e8ba8’ as ‘.vim/bundle/example’<br/>commit fe67ddf158faccff4082d78a25c45d8cd93e8ba8<br/>Author: Bob Brown&lt;ann@brown.com&gt;<br/>Date: Tue May 22 13:37:03 2019 +0200<br/>Squashed ‘.vim/bundle/example/’ content from commit b999b09<br/>git-subtree-dir: .vim/bundle/example<br/>git-subtree-split: b999b09cd9d69f359fa5668e81b09dcfde455cca</span></pre><p id="33b7" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">如果您调用Git status，您将看不到任何东西，因为Git subtree已经为您创建了提交，并留下了干净的工作副本。此外，<code class="fe ls lt lu lv b">vim/bundle/example</code>中没有任何内容表明该文件夹曾经来自另一个存储库。</p></div><div class="ab cl lw lx hu ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="ij ik il im in"><h1 id="b00e" class="md me iq bd mf mg mh mi mj mk ml mm mn jw mo jx mp jz mq ka mr kc ms kd mt mu bi translated"><strong class="ak">拉动</strong></h1><p id="201f" class="pw-post-body-paragraph kw kx iq ky b kz mv jr lb lc mw ju le lf mx lh li lj my ll lm ln mz lp lq lr ij bi translated">要将子文件夹更新到子存储库的最新版本，只需运行:</p><pre class="kg kh ki kj gt oa lv ob oc aw od bi"><span id="b354" class="na me iq lv b gy oe of l og oh">git subtree pull — prefix .vim/bundle/example https://github.com/Example/vim-example.git master — squash</span></pre><p id="1a52" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">请注意，参数保持不变，只是用<code class="fe ls lt lu lv b">git pull</code>命令替换了<code class="fe ls lt lu lv b">git add</code>命令，这将创建一组与前面的add类似的提交。</p><p id="ca66" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">但是请记住，Git subtree存储子项目提交的id，而不是元数据中的引用。查找与提交相关的符号名:</p><p id="f7a4" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><code class="fe ls lt lu lv b">git ls-remote <a class="ae kv" href="https://github.com/Example/vim-example.git" rel="noopener ugc nofollow" target="_blank">https://github.com/Example/vim-example.git</a> | grep &lt;sha-1&gt;</code></p></div><div class="ab cl lw lx hu ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="ij ik il im in"><h1 id="29e7" class="md me iq bd mf mg mh mi mj mk ml mm mn jw mo jx mp jz mq ka mr kc ms kd mt mu bi translated">在Git子树后重置基础</h1><p id="e4ad" class="pw-post-body-paragraph kw kx iq ky b kz mv jr lb lc mw ju le lf mx lh li lj my ll lm ln mz lp lq lr ij bi translated">在这里，您应该手动执行一个交互式rebase并删除<code class="fe ls lt lu lv b">add</code>提交，然后执行rebase。重置过程完成后，继续并重新执行<code class="fe ls lt lu lv b">add</code>命令。</p></div><div class="ab cl lw lx hu ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="ij ik il im in"><p id="c308" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">Git子树对于Git初学者来说比较容易。代码被合并到外部存储库的历史中。只需要<code class="fe ls lt lu lv b">clone</code>、<code class="fe ls lt lu lv b">pull</code>、<code class="fe ls lt lu lv b">push</code>，而且是分散的。Git subtree允许您将另一个存储库集成到您的存储库中，包括历史。这就是为什么在集成之后，您的存储库变得更大了。集成后，没有到其他存储库的连接，除非更新它，否则不需要访问它。虽然它被认为是Git子模块的一个很好的替代品，但是它们都是为不同的工作流设计的。</p></div></div>    
</body>
</html>