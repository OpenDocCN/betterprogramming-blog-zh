<html>
<head>
<title>Android Unit Testing —Choosing Naming Convention and Test Cases</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Android单元测试——选择命名约定和测试用例</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/android-unit-testing-choosing-naming-convention-and-test-cases-d1a3122ac28a?source=collection_archive---------5-----------------------#2022-02-11">https://betterprogramming.pub/android-unit-testing-choosing-naming-convention-and-test-cases-d1a3122ac28a?source=collection_archive---------5-----------------------#2022-02-11</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="9186" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">构建无bug的Android应用</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/de6f1f9f6adbd06cd769a3b22fb0c1ec.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*gtjmqIYigrgtbP5c"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">圭多·科帕在Unsplash<a class="ae kv" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">拍摄的照片</a></p></figure><p id="de42" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">可维护性是我们编码时的目标之一。单元测试的一个好处是让代码更易维护，请查看优点<a class="ae kv" href="https://medium.com/@haythamayyash95/android-unit-testing-basics-78a04a66124a" rel="noopener">这里</a>。</p><p id="21bf" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">然而，当我们在单元测试中有错误的代码，并且需要改变一个现有的特性时，这将需要在产品代码和单元测试中(用错误的代码)进行改变。</p><p id="19d4" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">单元测试就像地狱或陷阱一样，因为我们将花费大量时间阅读并试图理解到底写了什么，而不是通过使代码可维护来帮助我们！</p><p id="51de" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">换句话说，如果我们希望单元测试使代码更易于维护，我们需要使单元测试尽可能的干净。否则，一个小的变化将是一个大问题。</p><blockquote class="ls lt lu"><p id="91d8" class="kw kx lv ky b kz la jr lb lc ld ju le lw lg lh li lx lk ll lm ly lo lp lq lr ij bi translated">测试代码和生产代码一样重要。不是二等公民。它需要思考、设计和细心。它必须像产品代码一样保持干净。</p><p id="c0b9" class="kw kx lv ky b kz la jr lb lc ld ju le lw lg lh li lx lk ll lm ly lo lp lq lr ij bi translated">— Robert C. Martin,《干净的代码:敏捷软件工艺手册》</p></blockquote><h1 id="e595" class="lz ma iq bd mb mc md me mf mg mh mi mj jw mk jx ml jz mm ka mn kc mo kd mp mq bi translated">选择测试方法名称</h1><p id="73e4" class="pw-post-body-paragraph kw kx iq ky b kz mr jr lb lc ms ju le lf mt lh li lj mu ll lm ln mv lp lq lr ij bi translated">使代码干净的最流行的准则之一是为方法和变量选择一个好名字。您可以按照这些提示为您的项目选择一个好的测试方法名称:</p><h2 id="7ad8" class="mw ma iq bd mb mx my dn mf mz na dp mj lf nb nc ml lj nd ne mn ln nf ng mp nh bi translated">可读性</h2><p id="b464" class="pw-post-body-paragraph kw kx iq ky b kz mr jr lb lc ms ju le lf mt lh li lj mu ll lm ln mv lp lq lr ij bi translated">可读性是通过选择一个简单的，有表现力的，有意义的名字来实现的。</p><h2 id="445f" class="mw ma iq bd mb mx my dn mf mz na dp mj lf nb nc ml lj nd ne mn ln nf ng mp nh bi translated">一个命名约定</h2><p id="4c58" class="pw-post-body-paragraph kw kx iq ky b kz mr jr lb lc ms ju le lf mt lh li lj mu ll lm ln mv lp lq lr ij bi translated">在您的项目中最好使用一个命名约定，这使得阅读测试报告更容易理解和一致。</p><p id="620a" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">但是，在某些情况下，如果您在另一个层中，您可以使用另一个约定。</p><p id="2b2d" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">例如，一些开发人员不喜欢这种约定:</p><pre class="kg kh ki kj gt ni nj nk nl aw nm bi"><span id="29bc" class="mw ma iq nj b gy nn no l np nq">MethodName_StateUnderTest_ExpectedBehavior</span></pre><p id="effd" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这是因为它包含了一个方法名，以及他们的论点，即单元测试应该测试行为而不是代码。这意味着测试代码不应该因为改变产品代码而受到影响。这种约定将测试方法与生产代码紧密耦合，这意味着如果您在生产代码中更改了方法名，那么您应该为测试该方法的任何“测试方法”更改它。</p><p id="168a" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">正如我前面提到的，它是紧密耦合的，因为您测试的是行为而不是代码，但是如果您测试的是实用程序类，在这种情况下，您可以使用这种约定，因为它包含方法名，所以更容易跟踪。</p><p id="af56" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">因此，对于业务逻辑，可以有一个不包含方法名的命名约定，例如，这个约定<code class="fe nr ns nt nj b">When_StateUnderTest_Expect_ExpectedBehavior</code>。并使用另一个包含需要测试代码而不是行为的实用方法的方法名。</p><h1 id="78ef" class="lz ma iq bd mb mc md me mf mg mh mi mj jw mk jx ml jz mm ka mn kc mo kd mp mq bi translated">命名约定示例</h1><p id="1b60" class="pw-post-body-paragraph kw kx iq ky b kz mr jr lb lc ms ju le lf mt lh li lj mu ll lm ln mv lp lq lr ij bi translated">有许多命名约定，遵循其中一些约定:</p><ul class=""><li id="54f2" class="nu nv iq ky b kz la lc ld lf nw lj nx ln ny lr nz oa ob oc bi translated"><code class="fe nr ns nt nj b">MethodName_StateUnderTest_ExpectedBehavior </code> —例如:<code class="fe nr ns nt nj b">getPost_success_postShouldCached</code></li><li id="922a" class="nu nv iq ky b kz od lc oe lf of lj og ln oh lr nz oa ob oc bi translated"><code class="fe nr ns nt nj b">MethodName_ExpectedBehavior_StateUnderTest </code> —例如:<code class="fe nr ns nt nj b">getPost_postShouldCached_success</code></li><li id="3923" class="nu nv iq ky b kz od lc oe lf of lj og ln oh lr nz oa ob oc bi translated"><code class="fe nr ns nt nj b">Should_ExpectedBehavior_When_StateUnderTest </code> —例如:<code class="fe nr ns nt nj b">should_throwException_when_NetworkError</code></li><li id="dacb" class="nu nv iq ky b kz od lc oe lf of lj og ln oh lr nz oa ob oc bi translated"><code class="fe nr ns nt nj b">When_StateUnderTest_Expect_ExpectedBehavior </code> —例如:<code class="fe nr ns nt nj b">when_serverError_expect_postNotCached</code></li></ul><p id="6020" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">选择命名约定没有对错，只要它是描述性的。这取决于开发者和他更喜欢什么。</p><h1 id="3f29" class="lz ma iq bd mb mc md me mf mg mh mi mj jw mk jx ml jz mm ka mn kc mo kd mp mq bi translated">可读性更强</h1><p id="be4f" class="pw-post-body-paragraph kw kx iq ky b kz mr jr lb lc ms ju le lf mt lh li lj mu ll lm ln mv lp lq lr ij bi translated">一些现代语言，比如Kotlin，允许编写带空格的测试方法。</p><p id="148b" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">因此，更具可读性！例如，这个约定<code class="fe nr ns nt nj b">When_StateUnderTest_Expect_ExpectedBehavior</code>如下所示</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="oi oj l"/></div></figure><h1 id="a8f5" class="lz ma iq bd mb mc md me mf mg mh mi mj jw mk jx ml jz mm ka mn kc mo kd mp mq bi translated">选择测试用例</h1><p id="5187" class="pw-post-body-paragraph kw kx iq ky b kz mr jr lb lc ms ju le lf mt lh li lj mu ll lm ln mv lp lq lr ij bi translated">我们不能测试所有可能的情况，因为那将是无限的！相反，我们基于我们的情况将被测试函数的输入/参数分成类别和边界，然后从每个类别和边界中选择一个值并测试它们。</p><p id="d489" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">测试用例没有具体的数量，要看每个案例。然而，如果<a class="ae kv" href="https://en.wikipedia.org/wiki/Code_coverage" rel="noopener ugc nofollow" target="_blank">代码覆盖率</a>不是100%,那么我们必须编写更多的测试，但是100%并不意味着我们覆盖了所有可能的情况。接下来的例子会更清楚。</p><h2 id="9bdf" class="mw ma iq bd mb mx my dn mf mz na dp mj lf nb nc ml lj nd ne mn ln nf ng mp nh bi translated">示例1:字符串复制器</h2><p id="4a60" class="pw-post-body-paragraph kw kx iq ky b kz mr jr lb lc ms ju le lf mt lh li lj mu ll lm ln mv lp lq lr ij bi translated">假设我们有一个StringDuplicator类，它有一个如下所示的<code class="fe nr ns nt nj b">duplicateString</code>方法</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="oi oj l"/></div></figure><p id="f6aa" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">当我们想要复制某个字符串时，我们可以将参数/输入(在本例中是字符串)分为三类:空、一个字符和多个字符。首先，让我们添加一个测试用例并运行覆盖</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="oi oj l"/></div></figure><p id="a590" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">要在覆盖范围内运行，您可以选择如下“在覆盖范围内运行<code class="fe nr ns nt nj b">StringDuplicatorTest</code>”</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi ok"><img src="../Images/2bfa2623add72d4f19bc200cfaac6d71.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*lU2RAEJRqLEM6b_Z76cZEQ.png"/></div></div></figure><p id="0d86" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">结果将是100%,因为测试功能已经覆盖了所有行</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi ol"><img src="../Images/c3684d4aba92227ef6547e896738a1e9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*b35MznxM54oUu2rrWks49A.png"/></div></div></figure><p id="8867" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">然而，尽管<code class="fe nr ns nt nj b">StringDuplicator</code>覆盖率是100%,我们仍然没有覆盖所有的测试用例(我之前提到的三个类别)。</p><p id="0589" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">为了覆盖所有的测试用例，我们可以再添加两个测试用例，测试代码如下:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="oi oj l"/></div></figure><h2 id="e7fb" class="mw ma iq bd mb mx my dn mf mz na dp mj lf nb nc ml lj nd ne mn ln nf ng mp nh bi translated">示例2:冲突会议检测器</h2><p id="e43e" class="pw-post-body-paragraph kw kx iq ky b kz mr jr lb lc ms ju le lf mt lh li lj mu ll lm ln mv lp lq lr ij bi translated">假设我们有<code class="fe nr ns nt nj b">ConflictMeetingsDetector</code>，它有如下的<code class="fe nr ns nt nj b">haveMeetingsConflict</code>方法:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="oi oj l"/></div></figure><p id="4de6" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">因此，我们可以将参数(在本例中为<code class="fe nr ns nt nj b">meetingInterval1</code>和<code class="fe nr ns nt nj b">meetingInterval2</code>)分成不同的类别，如下图所示</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi om"><img src="../Images/76cc969d94395ccce9f248eab3ce9eb4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*CBaejIBrG5Ir37nfwl9oKA.png"/></div></div></figure><p id="6ee9" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">测试代码如下所示:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="oi oj l"/></div></figure><p id="8581" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们已经涵盖了所有类别，而且“覆盖范围内运行”会给我们100%。<br/>太好了，我们完成了吗？还没有。对于这个单元测试，我们可以把论点分成类别和界限。<strong class="ky ir"> </strong>我们还没有覆盖边界。</p><p id="e168" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们很容易忘记边界/边缘情况。很多bug都来源于边界。所以我们在划分类别和界限的时候需要小心。</p><p id="aac6" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">为了覆盖边界，我们可以添加两个新的测试用例，如下图所示:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi on"><img src="../Images/07e62f56028be7d2e96de3ab5a35fabf.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*xfoURZ7kob-NXe8iptAaYQ.png"/></div></div></figure><p id="62b1" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">此外，将添加两个新的测试函数，如下所示:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="oi oj l"/></div></figure><p id="f2db" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">你可以在GitHub上从<a class="ae kv" href="https://github.com/haythamayyash/android-unit-testing-course.git" rel="noopener ugc nofollow" target="_blank">这里</a>找到完整的代码。</p><h1 id="34f7" class="lz ma iq bd mb mc md me mf mg mh mi mj jw mk jx ml jz mm ka mn kc mo kd mp mq bi translated">一锤定音</h1><p id="5352" class="pw-post-body-paragraph kw kx iq ky b kz mr jr lb lc ms ju le lf mt lh li lj mu ll lm ln mv lp lq lr ij bi translated">单元测试和产品代码一样重要。您应该尽可能保持测试代码的整洁，以便能够维护它，这样单元测试会对您有所帮助，否则，单元测试会使您的代码变得复杂和难以维护。</p><p id="6744" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">选择正确的测试用例可以通过将参数/输入分成类别和边界来完成。</p><p id="9129" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">同样，小于100%的覆盖率意味着我们必须添加更多的测试用例，但是100%的覆盖率并不意味着我们覆盖了所有可能的情况。</p></div></div>    
</body>
</html>