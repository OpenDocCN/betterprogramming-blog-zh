<html>
<head>
<title>Delegating With Code: Declarative vs. Imperative Approach for K8s Deployments</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">代码委托:K8s部署的声明性与命令性方法</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/delegating-with-code-declarative-vs-imperative-approach-for-k8s-deployments-dfdd3e23d5c7?source=collection_archive---------18-----------------------#2020-01-29">https://betterprogramming.pub/delegating-with-code-declarative-vs-imperative-approach-for-k8s-deployments-dfdd3e23d5c7?source=collection_archive---------18-----------------------#2020-01-29</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="430e" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">声明式和命令式编程方法之间的最大区别是对这个问题的回答:“它为谁服务？”</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/6201c71a611e0d55c685a4d0777f1889.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*EVA4aCT-6dfC_X5Bk7J8CA.jpeg"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">马库斯·斯皮斯克在<a class="ae ky" href="https://unsplash.com/s/photos/code?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的照片</p></figure><p id="4e3c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">声明式和命令式编程方法之间的最大区别是对这个问题的回答:“它为谁服务？”</p><p id="9dd1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">命令式方法概述了机器需要如何做某事，为机器服务。它使自己与机器的操作模型保持一致，并告诉它需要如何做某事。</p><p id="c063" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">例如，假设你正在编写一个程序，从这个句子中挑选出所有的元音字母，计算一个数组中元素的和，你应该这样写:</p><pre class="kj kk kl km gt lv lw lx ly aw lz bi"><span id="51b5" class="ma mb it lw b gy mc md l me mf">int sum=Integer.MIN_VALUE;</span><span id="c18f" class="ma mb it lw b gy mg md l me mf">for(int i=0;i&lt;arr.length;i++) {<br/>    sum += arr[i];<br/>}</span></pre><p id="a0ca" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">声明式方法，声明您想要的东西，为您，开发人员服务。你告诉机器你需要什么，剩下的事情就完成了。</p><p id="149a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在这种情况下，您告诉计算机计算的逻辑，而不详细说明控制流或低级结构，如循环、if语句、赋值等等。像这样:</p><pre class="kj kk kl km gt lv lw lx ly aw lz bi"><span id="63dc" class="ma mb it lw b gy mc md l me mf">int sum = IntStream.of(arr).sum();</span></pre><p id="3371" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">本质上，这是一个“如何”与“什么”范式的问题。但这并不意味着一个比另一个更好。</p><p id="d22f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">声明式编程更容易理解，因为您可以阅读代码并理解它。它简洁、可重用，并支持引用透明性。</p><p id="67b1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">但是声明性的会慢一些，需要更长的时间来完成这个过程。在任务关键的实时应用中，如石油钻塔的监控或雷达处理，这可能为时已晚而无用。</p><p id="b42d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">另一方面，命令式方法给你更多的控制。但是，它不太可重用，因为它与编写它的上下文紧密相关。</p><p id="7d12" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">因此，很难用命令式代码进行伸缩。根据程序员的专注和暗示程度，这种方法也容易出错。</p><p id="057f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">基于需求、编程语言和开发人员的舒适程度，他们可能会选择一个或另一个来完成他们的工作。只有一种方法可以编写您的应用程序——您的方法。</p><p id="cbf7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">但是部署是一个完全不同的游戏。部署到库伯内特，更是如此。</p></div><div class="ab cl mh mi hx mj" role="separator"><span class="mk bw bk ml mm mn"/><span class="mk bw bk ml mm mn"/><span class="mk bw bk ml mm"/></div><div class="im in io ip iq"><h1 id="7112" class="mo mb it bd mp mq mr ms mt mu mv mw mx jz my ka mz kc na kd nb kf nc kg nd ne bi translated">部署自动化的声明式方法</h1><p id="214e" class="pw-post-body-paragraph kz la it lb b lc nf ju le lf ng jx lh li nh lk ll lm ni lo lp lq nj ls lt lu im bi translated">在容器化的世界里，一个开发者需要不仅仅是一个开发者。除了编程之外，他们还需要了解代码将要运行的基础设施，并使其高效运行。</p><p id="6a88" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">部署到Kubernetes迫使开发人员爬上陡峭的学习曲线，爬上复杂的环境。这不是开发人员寻求的学习方式。</p><p id="11ac" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">一个潜在的解决方案是使用以应用程序为中心的模型的部署自动化工具，它让您用自己的行话来声明您的需求，同时它为您生成必要的清单。</p><p id="9f32" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这个工具不是强迫你为K8s的操作模型编写代码，而是必须适应开发人员的心智模型并与之一起工作。</p></div><div class="ab cl mh mi hx mj" role="separator"><span class="mk bw bk ml mm mn"/><span class="mk bw bk ml mm mn"/><span class="mk bw bk ml mm"/></div><div class="im in io ip iq"><h1 id="bb2c" class="mo mb it bd mp mq mr ms mt mu mv mw mx jz my ka mz kc na kd nb kf nc kg nd ne bi translated">Kubernetes的服务部署示例</h1><p id="3d9c" class="pw-post-body-paragraph kz la it lb b lc nf ju le lf ng jx lh li nh lk ll lm ni lo lp lq nj ls lt lu im bi translated">这里是您部署一个简单的服务到K8s所需要的一切，使用声明性的方法，使用自动化工具。</p><h2 id="ce23" class="ma mb it bd mp nk nl dn mt nm nn dp mx li no np mz lm nq nr nb lq ns nt nd nu bi translated">为您的服务命名</h2><p id="14d8" class="pw-post-body-paragraph kz la it lb b lc nf ju le lf ng jx lh li nh lk ll lm ni lo lp lq nj ls lt lu im bi translated">它将作为服务发现和与其他服务通信的DNS名称。</p><h2 id="39cf" class="ma mb it bd mp nk nl dn mt nm nn dp mx li no np mz lm nq nr nb lq ns nt nd nu bi translated">将它指向服务图像</h2><ul class=""><li id="d27a" class="nv nw it lb b lc nf lf ng li nx lm ny lq nz lu oa ob oc od bi translated">从图像注册表中提取。</li><li id="ea37" class="nv nw it lb b lc oe lf of li og lm oh lq oi lu oa ob oc od bi translated">从源/二进制文件中生成和添加图像。</li><li id="218a" class="nv nw it lb b lc oe lf of li og lm oh lq oi lu oa ob oc od bi translated">使用现有的Docker图像，如果有的话。</li></ul><h2 id="f722" class="ma mb it bd mp nk nl dn mt nm nn dp mx li no np mz lm nq nr nb lq ns nt nd nu bi translated">设置其他顶级指令</h2><p id="2fed" class="pw-post-body-paragraph kz la it lb b lc nf ju le lf ng jx lh li nh lk ll lm ni lo lp lq nj ls lt lu im bi translated">端口、卷、环境属性、机密等。</p><h2 id="8054" class="ma mb it bd mp nk nl dn mt nm nn dp mx li no np mz lm nq nr nb lq ns nt nd nu bi translated">部署到Kubernetes</h2><p id="841f" class="pw-post-body-paragraph kz la it lb b lc nf ju le lf ng jx lh li nh lk ll lm ni lo lp lq nj ls lt lu im bi translated">部署您的规范—为您的应用程序名称指定路径、K8s名称空间和标识符。</p><p id="42be" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">然后，该工具将自动创建Kubernetes清单、存储类、守护进程集、副本集、状态集、PVC、配置映射、活性探测、网络策略等。</p><p id="302c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这样，您只需告诉工具您需要什么，它就会负责部署，为您节省大量的时间和精力。</p><p id="ca4f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这就是我们的开源项目HyScale的目标。我们看到开发团队需要以应用为中心的Kubernetes抽象和自动化，以实现开发和运营之间的无缝交接。</p><p id="f27c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们特别关注用户体验，构建了一个只需要开发人员最少努力的工具，同时完成了所有的繁重工作。我们已经为开发团队提供了它——你可以<a class="ae ky" href="https://github.com/hyscale/hyscale" rel="noopener ugc nofollow" target="_blank">在这里</a>试用它。</p></div></div>    
</body>
</html>