<html>
<head>
<title>Clarity Is King When Writing Code</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">写代码时，清晰是王道</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/clarity-is-king-when-writing-code-752b85101484?source=collection_archive---------6-----------------------#2020-04-03">https://betterprogramming.pub/clarity-is-king-when-writing-code-752b85101484?source=collection_archive---------6-----------------------#2020-04-03</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="5775" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">好的代码是清晰的代码，而不是聪明的代码</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/46f6f7002c00a1d42e51dc37899f8c59.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*6yGSPQpdL6T_MyXZifAUmQ.jpeg"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">由<a class="ae ky" href="https://unsplash.com/@dtravisphd?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">大卫·崔维斯</a>在<a class="ae ky" href="https://unsplash.com/s/photos/clarity?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>拍摄的照片</p></figure><p id="2f62" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">许多程序员试图编写干净、智能的代码。不过，有时候沉迷于smart可能会使代码库更难理解，并且可能需要花费更多的时间来阅读和维护它。</p><p id="3b20" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如今在团队合作中，人们开始写<em class="lv">人类代码，</em>这意味着你在写代码时应该尊重他人，而不是炫耀自己的聪明才智。人们尽量不使用<em class="lv"> clean </em>、<em class="lv"> </em>这个词，因为这暗示着代码是脏的，即使你不是故意的。丹尼尔·欧文在他的文章“<a class="ae ky" href="https://dev.to/d_ir/clean-code-dirty-code-human-code-6nm" rel="noopener ugc nofollow" target="_blank">干净的代码，肮脏的代码，人类代码</a>中谈到了这一点</p><p id="2230" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我不是说<em class="lv">干净</em>是坏事。当我在做一个个人项目时，我试图用一种聪明的方式让代码库变得干净。但更重要的是，我使代码库更具可读性和可理解性。</p><p id="b711" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">正如鲍勃大叔在他的<a class="ae ky" href="https://www.goodreads.com/book/show/3735293-clean-code" rel="noopener ugc nofollow" target="_blank">干净代码</a>中所说:</p><blockquote class="lw lx ly"><p id="0c92" class="kz la lv lb b lc ld ju le lf lg jx lh lz lj lk ll ma ln lo lp mb lr ls lt lu im bi translated">“总的来说，程序员是相当聪明的人。聪明人有时喜欢通过展示他们的心理杂耍能力来炫耀他们的聪明。毕竟，如果你能可靠地记住<code class="fe mc md me mf b">r</code>是去掉了主机和模式的URL的小写版本，那么你一定非常聪明。一个聪明的程序员和一个专业的程序员之间的一个区别是<strong class="lb iu">专业的程序员明白清晰才是王道。专业人士善用他们的能力，编写他人能理解的代码。罗伯特·马丁</strong></p></blockquote><p id="f55c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">最重要的是用清晰的方式写出别人能理解的代码。其他人<em class="lv"> </em>不仅是其他人<em class="lv"> </em>也是<em class="lv"> </em>你，你将在几个月后重写代码。</p><p id="a2db" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在这篇文章中，我不是在谈论人类代码<em class="lv"> </em>方面很多。相反，我将通过一些例子来强调如何将这一原则应用到您的代码中，并最大限度地减少人们理解它所需的时间。</p><p id="ed9a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">注意:为了解释一些技巧，我将使用JavaScript或TypeScript。</p><p id="3e3a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">涵盖的示例:</p><ul class=""><li id="306f" class="mg mh it lb b lc ld lf lg li mi lm mj lq mk lu ml mm mn mo bi translated">命名</li><li id="b277" class="mg mh it lb b lc mp lf mq li mr lm ms lq mt lu ml mm mn mo bi translated">评论</li><li id="d7a9" class="mg mh it lb b lc mp lf mq li mr lm ms lq mt lu ml mm mn mo bi translated">条件式</li><li id="b385" class="mg mh it lb b lc mp lf mq li mr lm ms lq mt lu ml mm mn mo bi translated">环</li><li id="63bb" class="mg mh it lb b lc mp lf mq li mr lm ms lq mt lu ml mm mn mo bi translated">功能</li><li id="09da" class="mg mh it lb b lc mp lf mq li mr lm ms lq mt lu ml mm mn mo bi translated">测试</li></ul></div><div class="ab cl mu mv hx mw" role="separator"><span class="mx bw bk my mz na"/><span class="mx bw bk my mz na"/><span class="mx bw bk my mz"/></div><div class="im in io ip iq"><h1 id="aafd" class="nb nc it bd nd ne nf ng nh ni nj nk nl jz nm ka nn kc no kd np kf nq kg nr ns bi translated">命名</h1><p id="aa83" class="pw-post-body-paragraph kz la it lb b lc nt ju le lf nu jx lh li nv lk ll lm nw lo lp lq nx ls lt lu im bi translated">在软件开发中，许多程序员在命名方面有困难。但在我个人看来，重点只是避免歧义，使用具体的词语。</p><p id="030f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">例如:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ny nz l"/></div></figure><p id="45d6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在这段代码中，您可以预期<code class="fe mc md me mf b">fetch</code>将从服务器获得什么。但是如果将<code class="fe mc md me mf b">fetch</code>函数导出并在其他文件中使用呢？</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ny nz l"/></div></figure><p id="5d3b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在其他文件中:</p><pre class="kj kk kl km gt oa mf ob oc aw od bi"><span id="a897" class="oe nc it mf b gy of og l oh oi"><strong class="mf iu">import { fetch } from './utils'</strong></span><span id="14fe" class="oe nc it mf b gy oj og l oh oi">fetch() // fetch ... what?<br/></span></pre><p id="b05a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">相反，您可以更具体地命名它:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ny nz l"/></div></figure><p id="e9e6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这是一个非常简单的例子。如果变量或函数在你的代码库中有更大的作用域，使用具体的名字来清楚地说明它们的用途。</p><p id="5d2d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我说你应该避免模棱两可。注意像这样的一般动词:</p><ul class=""><li id="cd76" class="mg mh it lb b lc ld lf lg li mi lm mj lq mk lu ml mm mn mo bi translated">制造</li><li id="963a" class="mg mh it lb b lc mp lf mq li mr lm ms lq mt lu ml mm mn mo bi translated">得到</li><li id="0c59" class="mg mh it lb b lc mp lf mq li mr lm ms lq mt lu ml mm mn mo bi translated">设置</li><li id="b190" class="mg mh it lb b lc mp lf mq li mr lm ms lq mt lu ml mm mn mo bi translated">开始</li><li id="5f58" class="mg mh it lb b lc mp lf mq li mr lm ms lq mt lu ml mm mn mo bi translated">使生效</li><li id="ddf5" class="mg mh it lb b lc mp lf mq li mr lm ms lq mt lu ml mm mn mo bi translated">支票</li><li id="c621" class="mg mh it lb b lc mp lf mq li mr lm ms lq mt lu ml mm mn mo bi translated">派遣</li></ul><p id="b035" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">另一个例子:</p><pre class="kj kk kl km gt oa mf ob oc aw od bi"><span id="7a8b" class="oe nc it mf b gy of og l oh oi">const xxx = validateForm()</span></pre><p id="7176" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在这段代码中，你可以理解<code class="fe mc md me mf b">validateForm</code>正在验证表单，但是你期望返回什么呢？</p><p id="2736" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">但是假设你这样写:</p><pre class="kj kk kl km gt oa mf ob oc aw od bi"><span id="633b" class="oe nc it mf b gy of og l oh oi">const xxx = isFormValid()</span></pre><p id="9ad2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">很明显，这个方法将返回<code class="fe mc md me mf b">true</code>或<code class="fe mc md me mf b">false</code>。</p><p id="e423" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果你这样写，你可以假设这个方法会返回一个数组或者一个表单错误的映射:</p><pre class="kj kk kl km gt oa mf ob oc aw od bi"><span id="0f55" class="oe nc it mf b gy of og l oh oi">const xxx = getFormErrors()</span></pre><p id="86be" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">另一个例子:</p><pre class="kj kk kl km gt oa mf ob oc aw od bi"><span id="a9aa" class="oe nc it mf b gy of og l oh oi">const token = getToken()</span></pre><p id="75ce" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如你所见，<code class="fe mc md me mf b">getToken</code>很可能得到一个令牌。但是从哪来的？如果是用异步函数从服务器获取令牌呢？</p><pre class="kj kk kl km gt oa mf ob oc aw od bi"><span id="cf5f" class="oe nc it mf b gy of og l oh oi">const token = getToken()</span><span id="9e00" class="oe nc it mf b gy oj og l oh oi">// use token for something<br/>doSomething(token)</span></pre><p id="ad16" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这可能会在<code class="fe mc md me mf b">doSomething</code>函数中导致一个未定义的错误，因为在这种情况下，您需要等到<code class="fe mc md me mf b">getToken</code>完成。</p><pre class="kj kk kl km gt oa mf ob oc aw od bi"><span id="6cb9" class="oe nc it mf b gy of og l oh oi">const token = <strong class="mf iu">await</strong> getToken()</span><span id="cf77" class="oe nc it mf b gy oj og l oh oi">// use token for something<br/>doSomething(token)</span></pre><p id="650e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">它工作正常。但是<code class="fe mc md me mf b">getToken</code>在这种情况下并不合适，所以您可以将其重命名为:</p><pre class="kj kk kl km gt oa mf ob oc aw od bi"><span id="0517" class="oe nc it mf b gy of og l oh oi">const token = <strong class="mf iu">await</strong> <strong class="mf iu">fetchToken</strong>()</span><span id="03cb" class="oe nc it mf b gy oj og l oh oi">// use token for something<br/>doSomething(token)</span></pre><p id="168c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这样，该方法将从某个服务器或其他异步设备获取令牌就更清楚了。</p><p id="a8b1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">为了解决这些问题，许多聪明的人想出了一个好的例子，但重要的是让人们以简单的方式知道它是为了什么。</p></div><div class="ab cl mu mv hx mw" role="separator"><span class="mx bw bk my mz na"/><span class="mx bw bk my mz na"/><span class="mx bw bk my mz"/></div><div class="im in io ip iq"><h1 id="1ed0" class="nb nc it bd nd ne nf ng nh ni nj nk nl jz nm ka nn kc no kd np kf nq kg nr ns bi translated">评论</h1><p id="a59d" class="pw-post-body-paragraph kz la it lb b lc nt ju le lf nu jx lh li nv lk ll lm nw lo lp lq nx ls lt lu im bi translated">一般来说，注释的目的是尽可能地帮助人们了解，注释可以使人们更快地理解代码。但是你不必总是在代码上加注释。你需要知道一个没有价值的评论和一个好的评论之间的界限。</p><h2 id="9e1b" class="oe nc it bd nd ok ol dn nh om on dp nl li oo op nn lm oq or np lq os ot nr ou bi translated">什么不要评论</h2><p id="ce8c" class="pw-post-body-paragraph kz la it lb b lc nt ju le lf nu jx lh li nv lk ll lm nw lo lp lq nx ls lt lu im bi translated">如果人们很容易理解它在做什么，你就不需要对代码进行评论。</p><p id="a2dd" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">例如:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ny nz l"/></div></figure><p id="f9ef" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">你可以理解这个代码很明显是通过查看自身来找到一个学生的，所以不需要放注释。</p><p id="ef01" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">另一个例子:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ny nz l"/></div></figure><p id="5472" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这看起来像是一个很好的解释，但是还可以改进。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ny nz l"/></div></figure><p id="fd07" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">代码块应该被移动到函数中，你应该放入一个解释它在做什么的名字。一个更加简洁和自我记录的函数名比一个好的注释要好。</p><h2 id="df54" class="oe nc it bd nd ok ol dn nh om on dp nl li oo op nn lm oq or np lq os ot nr ou bi translated">评论什么</h2><p id="8d91" class="pw-post-body-paragraph kz la it lb b lc nt ju le lf nu jx lh li nv lk ll lm nw lo lp lq nx ls lt lu im bi translated">我们已经讨论了什么样的代码不应该注释。接下来，我们将看到应该评论什么。</p><p id="0a36" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">当代码:</p><ul class=""><li id="2ef8" class="mg mh it lb b lc ld lf lg li mi lm mj lq mk lu ml mm mn mo bi translated">有缺陷，比如性能问题</li><li id="5415" class="mg mh it lb b lc mp lf mq li mr lm ms lq mt lu ml mm mn mo bi translated">可能会导致人们意想不到的行为</li><li id="e3be" class="mg mh it lb b lc mp lf mq li mr lm ms lq mt lu ml mm mn mo bi translated">需要总结，以便人们可以很容易地抓住细节</li><li id="9bda" class="mg mh it lb b lc mp lf mq li mr lm ms lq mt lu ml mm mn mo bi translated">我需要一个解释，为什么在有更好的方法的情况下还要这样写</li></ul><p id="7f3e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这些是你在编写代码时得到的有价值的见解。如果没有这些评论，人们可能会认为有一个bug或者代码应该被测试或修复，这可能是浪费时间。为了避免这种情况，您应该解释为什么代码以某种方式编写。</p><p id="c50c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">重要的是设身处地为别人着想。未雨绸缪，预测人们可能陷入的陷阱。</p></div><div class="ab cl mu mv hx mw" role="separator"><span class="mx bw bk my mz na"/><span class="mx bw bk my mz na"/><span class="mx bw bk my mz"/></div><div class="im in io ip iq"><h1 id="3705" class="nb nc it bd nd ne nf ng nh ni nj nk nl jz nm ka nn kc no kd np kf nq kg nr ns bi translated">条件式</h1><p id="b474" class="pw-post-body-paragraph kz la it lb b lc nt ju le lf nu jx lh li nv lk ll lm nw lo lp lq nx ls lt lu im bi translated">写代码的时候，我们要处理条件句。大量的if/else语句让你停止阅读代码库，陷入一段时间。我相信条件语句越少，代码越易读。</p><p id="d1be" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">通过使用<a class="ae ky" href="https://en.wikipedia.org/wiki/Cyclomatic_complexity" rel="noopener ugc nofollow" target="_blank">圈复杂度</a>，你可以计算代码的复杂度。如果代码中使用了大量if/else、循环或switch语句，则计数会很高。通常，计数越高，代码越复杂。</p><p id="fcdf" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果您是IntelliJ用户，可以在首选项中检查复杂性:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ov"><img src="../Images/c86d29f91edc0a097e7c576199a2756d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*G0JgldkUmjlJ48LjVuxTTg.png"/></div></div></figure><p id="3a83" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">选中“过于复杂的功能”框。</p><p id="520c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">而当你在函数中写了很多if/else语句时，它会警告你:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi ow"><img src="../Images/76bb3d3c5783e4ac68d0e3a673045d4f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1370/format:webp/1*qNXypcp4rO3t8xI57AILRw.png"/></div></figure><p id="c424" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如您所见，这里的圈复杂度很高。</p><p id="82e3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">注意:在VS代码中，你可以使用一些插件，比如<a class="ae ky" href="https://marketplace.visualstudio.com/items?itemName=kisstkondoros.vscode-codemetrics" rel="noopener ugc nofollow" target="_blank"> CodeMetrics </a>。</p><p id="548e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">关键是尽量减少不必要的条件句，尽量减少理解代码的时间。</p><p id="0230" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">以下是一些简化和提高条件可读性的技巧:</p><ul class=""><li id="bcf0" class="mg mh it lb b lc ld lf lg li mi lm mj lq mk lu ml mm mn mo bi translated">先处理正面案例，而不是负面案例</li><li id="96db" class="mg mh it lb b lc mp lf mq li mr lm ms lq mt lu ml mm mn mo bi translated">早点回来</li><li id="de68" class="mg mh it lb b lc mp lf mq li mr lm ms lq mt lu ml mm mn mo bi translated">使用<code class="fe mc md me mf b">Array.includes</code>处理多个案例</li><li id="21e8" class="mg mh it lb b lc mp lf mq li mr lm ms lq mt lu ml mm mn mo bi translated">使用可选链接处理未定义的检查</li></ul><h2 id="7544" class="oe nc it bd nd ok ol dn nh om on dp nl li oo op nn lm oq or np lq os ot nr ou bi translated">首先处理积极的，而不是消极的</h2><p id="ca7c" class="pw-post-body-paragraph kz la it lb b lc nt ju le lf nu jx lh li nv lk ll lm nw lo lp lq nx ls lt lu im bi translated">哪个对你来说更有可读性？</p><pre class="kj kk kl km gt oa mf ob oc aw od bi"><span id="49f8" class="oe nc it mf b gy of og l oh oi">if (!debug) {<br/>  // do something<br/>} else {<br/>  debugSomething()<br/>}</span></pre><p id="bffc" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">或者</p><pre class="kj kk kl km gt oa mf ob oc aw od bi"><span id="24cd" class="oe nc it mf b gy of og l oh oi">if (debug) {<br/>  debugSomething()<br/>} else {<br/>  // do something<br/>}</span></pre><p id="6bf5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">大多数情况下，优先使用正例。但是如果否定的情况是更简单和更仔细的情况，你可以这样写:</p><pre class="kj kk kl km gt oa mf ob oc aw od bi"><span id="a1f4" class="oe nc it mf b gy of og l oh oi">if (!user) throw new Error('Please sign in first')<br/><br/>// do a lot of things here<br/>// ...</span></pre><h2 id="c0c5" class="oe nc it bd nd ok ol dn nh om on dp nl li oo op nn lm oq or np lq os ot nr ou bi translated">早点回来</h2><p id="52e8" class="pw-post-body-paragraph kz la it lb b lc nt ju le lf nu jx lh li nv lk ll lm nw lo lp lq nx ls lt lu im bi translated">提前返回可以移除嵌套并清理代码，因为您可以在函数的顶部首先处理简单的情况。</p><p id="dab9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">例如:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ny nz l"/></div></figure><p id="071b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">它工作得很好，但是代码有点长而且是嵌套的。如果您添加了if/else语句，就很难找出右括号在哪里，调试代码也更困难。</p><p id="5721" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">为了让它看起来更干净，我们需要做的是:</p><ul class=""><li id="d02e" class="mg mh it lb b lc ld lf lg li mi lm mj lq mk lu ml mm mn mo bi translated">如果没有日期，抛出一个错误</li><li id="d874" class="mg mh it lb b lc mp lf mq li mr lm ms lq mt lu ml mm mn mo bi translated">如果日期是今天，返回“今天”</li><li id="516d" class="mg mh it lb b lc mp lf mq li mr lm ms lq mt lu ml mm mn mo bi translated">如果日期是昨天，返回“昨天”</li><li id="4e5c" class="mg mh it lb b lc mp lf mq li mr lm ms lq mt lu ml mm mn mo bi translated">如果日期不在今年，则返回包含年份的日期</li><li id="e6f5" class="mg mh it lb b lc mp lf mq li mr lm ms lq mt lu ml mm mn mo bi translated">如果与上述不匹配，返回日期和月份</li></ul><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ny nz l"/></div></figure><p id="fa86" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">看起来更好。从一个函数多次返回对于使代码可读来说是非常好的。</p><h2 id="1192" class="oe nc it bd nd ok ol dn nh om on dp nl li oo op nn lm oq or np lq os ot nr ou bi translated">使用数组处理多个案例。包括</h2><p id="7222" class="pw-post-body-paragraph kz la it lb b lc nt ju le lf nu jx lh li nv lk ll lm nw lo lp lq nx ls lt lu im bi translated">如果有多个条件，可以使用<code class="fe mc md me mf b">Array.includes</code>避免扩展语句。</p><p id="5525" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">例如:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ny nz l"/></div></figure><p id="ab01" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">考虑到以后可能会在语句中添加其他条件，我们希望像这样重构代码:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ny nz l"/></div></figure><p id="d80f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">有了类型数组，您可以从代码中单独提取条件。</p><h2 id="e173" class="oe nc it bd nd ok ol dn nh om on dp nl li oo op nn lm oq or np lq os ot nr ou bi translated">使用可选链接处理未定义的检查</h2><p id="98cd" class="pw-post-body-paragraph kz la it lb b lc nt ju le lf nu jx lh li nv lk ll lm nw lo lp lq nx ls lt lu im bi translated"><a class="ae ky" href="https://babeljs.io/docs/en/babel-plugin-proposal-optional-chaining" rel="noopener ugc nofollow" target="_blank">可选链接</a>允许你深入访问嵌套对象，而不用在临时变量中重复赋值结果。通过这样做，您可以减少条件中的多次检查。</p><p id="3c27" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">注意:如果你想在JavaScript中使用一个可选的链接操作符，你需要安装<a class="ae ky" href="https://babeljs.io/docs/en/plugins/" rel="noopener ugc nofollow" target="_blank"> Babel插件</a>。在3.7 以上的<a class="ae ky" href="https://www.typescriptlang.org/docs/handbook/release-notes/typescript-3-7.html" rel="noopener ugc nofollow" target="_blank"> Typescript中，无需任何配置即可使用。</a></p><p id="2dd2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">例如:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ny nz l"/></div></figure><p id="5896" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果您想检查用户是否存在，并避免未定义的错误，您需要编写一个类似上面示例的条件。</p><p id="8b0e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">但是通过使用可选的链接操作符，代码将是:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ny nz l"/></div></figure><p id="0f40" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这样看起来更好，也更容易维护。<code class="fe mc md me mf b">?</code>可以访问内部的嵌套对象，避免未定义的错误。</p><p id="c5df" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">你可以在<a class="ae ky" href="https://www.typescriptlang.org/play/#code/C4TwDgpgBAqgzhATlAvFA3gWAFBT1AQwBMjEI44BJAOwDMB7AfgC4Md8OoAvASzAGN6RCKzjBEPagHN2+AL44F2HIOpioAVwSJW8JKgxLV63gKHQ0WpIwB0xUuSp0mN04OE4V9NfQA2EG196KQAKN3MASiA" rel="noopener ugc nofollow" target="_blank"> TypeScript playground </a>里玩这个很酷的功能。</p></div><div class="ab cl mu mv hx mw" role="separator"><span class="mx bw bk my mz na"/><span class="mx bw bk my mz na"/><span class="mx bw bk my mz"/></div><div class="im in io ip iq"><h1 id="be0d" class="nb nc it bd nd ne nf ng nh ni nj nk nl jz nm ka nn kc no kd np kf nq kg nr ns bi translated">环</h1><p id="7baa" class="pw-post-body-paragraph kz la it lb b lc nt ju le lf nu jx lh li nv lk ll lm nw lo lp lq nx ls lt lu im bi translated">简化循环使你的代码更容易理解。</p><p id="f10f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在实际情况中，您可能会在对象中遇到复杂的嵌套循环。如果你有一个嵌套的对象，并且必须在<code class="fe mc md me mf b">todo3</code>中获得列表名，比如:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ny nz l"/></div></figure><p id="0bd1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">例如，你可以这样写:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ny nz l"/></div></figure><p id="c559" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">你会得到列表:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi ox"><img src="../Images/d95cb97e64a99911f4d00c23c6113d1b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1192/format:webp/1*U9e0w4cbvj0T11vs1RIcsg.png"/></div></figure><p id="6576" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">它工作正常。通过用<code class="fe mc md me mf b">forEach</code>循环数组，您可以进入对象内部，当您到达<code class="fe mc md me mf b">todo3</code>时，您将获得列表名称。</p><p id="daf5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">但这可以通过使用<code class="fe mc md me mf b">reduce</code>功能来改善:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ny nz l"/></div></figure><p id="6004" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这也很好。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi oy"><img src="../Images/2c08bc71a58fe87c07519d913266ac16.png" data-original-src="https://miro.medium.com/v2/resize:fit:1242/format:webp/1*1OkrU9YxUiQWQLIDUdrNeA.png"/></div></figure><p id="b979" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe mc md me mf b">reduce</code>函数允许你通过扩展先前的值来创建一个新的对象或数组。在这种情况下，在第一个reduce中，它得到了<code class="fe mc md me mf b">todo2 </code>数组，接下来是<code class="fe mc md me mf b">todo3</code>数组，最后是<code class="fe mc md me mf b">todo3</code>中的一个列表名。</p><p id="e5c7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">为了避免可读代码的复杂性，移除嵌套循环是必要的。</p></div><div class="ab cl mu mv hx mw" role="separator"><span class="mx bw bk my mz na"/><span class="mx bw bk my mz na"/><span class="mx bw bk my mz"/></div><div class="im in io ip iq"><h1 id="86b2" class="nb nc it bd nd ne nf ng nh ni nj nk nl jz nm ka nn kc no kd np kf nq kg nr ns bi translated">功能</h1><p id="730f" class="pw-post-body-paragraph kz la it lb b lc nt ju le lf nu jx lh li nv lk ll lm nw lo lp lq nx ls lt lu im bi translated">以下是编写函数时要记住的一些提示:</p><ul class=""><li id="efe8" class="mg mh it lb b lc ld lf lg li mi lm mj lq mk lu ml mm mn mo bi translated">使用一个摘要名称来解释它在做什么。</li><li id="b4ac" class="mg mh it lb b lc mp lf mq li mr lm ms lq mt lu ml mm mn mo bi translated">为一个目的创建一个函数。</li><li id="c218" class="mg mh it lb b lc mp lf mq li mr lm ms lq mt lu ml mm mn mo bi translated">函数越小，可读性越强。</li></ul><h2 id="95ab" class="oe nc it bd nd ok ol dn nh om on dp nl li oo op nn lm oq or np lq os ot nr ou bi translated">使用摘要名称来解释它在做什么</h2><p id="f76e" class="pw-post-body-paragraph kz la it lb b lc nt ju le lf nu jx lh li nv lk ll lm nw lo lp lq nx ls lt lu im bi translated">当您第一眼看到下面的代码时，您可能会停止阅读并试图弄清楚它在做什么:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ny nz l"/></div></figure><p id="da9e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">那这个呢？</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ny nz l"/></div></figure><p id="ff2f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">您可能希望有一个函数，通过查看一次就可以删除带有重复代码的对象。</p><p id="677d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">两者都工作得非常好，并且得到相同的结果。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi oz"><img src="../Images/d5ccc222e0528895cd5777d7e61f30c8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*U3sd0CILlq7iANyPFmp84g.png"/></div></div></figure><p id="d47b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">但是第二个更具可读性，有助于解释这个函数在做什么。</p><p id="abbe" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">另一个例子:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ny nz l"/></div></figure><p id="6d64" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果我们为它编写函数，代码将是这样的:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ny nz l"/></div></figure><p id="80e5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">好多了。但就个人而言，我喜欢管道操作符的想法，它用于将几个函数链接在一起，以提高函数式编程的可读性。</p><p id="05c1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果我们在JavaScript中使用管道，代码将如下所示:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ny nz l"/></div></figure><p id="f1c7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这无疑提高了可读性和可维护性。通过将<code class="fe mc md me mf b"><a class="ae ky" href="https://babeljs.io/docs/en/babel-plugin-proposal-pipeline-operator" rel="noopener ugc nofollow" target="_blank">@babel/plugin-proposal-pipeline-operator</a></code>添加到您的<code class="fe mc md me mf b">bebelrc</code>设置中，可以使用管道操作符。这是一个实验性的插件，但是我在我的真实项目中使用它。</p><h2 id="cf50" class="oe nc it bd nd ok ol dn nh om on dp nl li oo op nn lm oq or np lq os ot nr ou bi translated">为一个目的创建一个函数</h2><p id="e451" class="pw-post-body-paragraph kz la it lb b lc nt ju le lf nu jx lh li nv lk ll lm nw lo lp lq nx ls lt lu im bi translated">现在我们明白了摘要名的重要性。但是，如果您不能为您的函数想出一个好名字，该怎么办呢？</p><p id="a6e6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">例如:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ny nz l"/></div></figure><p id="c17d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">你可能想知道它应该是<code class="fe mc md me mf b">updateUserAndProfile</code>、<code class="fe mc md me mf b">updateUserAndProfileAndNotify</code>还是别的什么。当你陷入困境时，就是时候将代码分割成更小的部分，因为当代码同时做多件事情时，人们更难理解代码。</p><p id="197b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">当您编写一个更新用户的函数时，代码应该是这样的:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ny nz l"/></div></figure><p id="8e88" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果您必须同时处理多个任务，请创建一个包装器函数来完成这项工作:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ny nz l"/></div></figure><p id="8013" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这是一个非常简单的例子，但是在实际开发中有很多这样的例子。要记住的关键思想是后退一步，考虑函数应该做什么，并考虑任何问题，以便它一次只做一项任务。</p><h2 id="0233" class="oe nc it bd nd ok ol dn nh om on dp nl li oo op nn lm oq or np lq os ot nr ou bi translated">较小的函数可读性更强</h2><p id="cfe9" class="pw-post-body-paragraph kz la it lb b lc nt ju le lf nu jx lh li nv lk ll lm nw lo lp lq nx ls lt lu im bi translated">当你为一个目的编写一个更小的函数时，代码将更具可读性和可理解性。</p><p id="e9a7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">例如:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ny nz l"/></div></figure><p id="52c4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">该函数的输出如下:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi pa"><img src="../Images/73972103afb78d2a4cf049596b61b920.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*KJq_iYUfFnFKABIzttCGDw.png"/></div></div></figure><p id="4773" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">想象一下，在一个函数中有大量的代码，创建一个查询来搜索一些数据。如果电子邮件查询有问题，您必须检查里面的函数，找到电子邮件的实现，并修复它。在那之后，你必须检查这个改变是否会影响函数中的其他代码。</p><p id="c8d4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">一般来说，人们一次只能考虑几件事。代码的表达式越大，就越难理解和维护。</p><p id="5236" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">所以让我们把代码变得更小:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ny nz l"/></div></figure><p id="0ece" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">将巨大的代码分解成小块会使代码更清晰，可读性更好。更重要的是，每一个关注点都与代码的其余部分分离开来，因此您可以轻松地调试和测试它。</p><p id="e4c2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果您还想使它更通用和更具声明性，您可以这样写:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ny nz l"/></div></figure><p id="947b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">它输出相同的结果。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi pb"><img src="../Images/d7c18685850722456e09c69415b1c3e2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*nztaqEhosdw6CQxHYmkC7w.png"/></div></div></figure><p id="ae8c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">尽管我建议我们应该让代码变得更小更通用，但是在重构之前，你必须首先考虑为什么要以这种方式编写代码。可能是你同事出于某种原因写的。即使是很多改进，你也想和写它的人谈谈，讨论它好不好。</p><p id="dc76" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这都是关于人类代码<em class="lv"> </em>的东西<em class="lv">。</em>你可以在《<a class="ae ky" href="https://overreacted.io/goodbye-clean-code/" rel="noopener ugc nofollow" target="_blank">再见，干净代码</a>》一文中查看更多细节</p></div><div class="ab cl mu mv hx mw" role="separator"><span class="mx bw bk my mz na"/><span class="mx bw bk my mz na"/><span class="mx bw bk my mz"/></div><div class="im in io ip iq"><h1 id="9ae5" class="nb nc it bd nd ne nf ng nh ni nj nk nl jz nm ka nn kc no kd np kf nq kg nr ns bi translated">测试</h1><p id="93ac" class="pw-post-body-paragraph kz la it lb b lc nt ju le lf nu jx lh li nv lk ll lm nw lo lp lq nx ls lt lu im bi translated">我不是在谈论TDD方面，我是在谈论测试在团队开发中的可读性有多重要。</p><p id="4efa" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">编写测试非常重要，因为:</p><ul class=""><li id="5de6" class="mg mh it lb b lc ld lf lg li mi lm mj lq mk lu ml mm mn mo bi translated">当没有文档存在时，您的团队成员可以通过阅读测试描述轻松地了解细节。</li><li id="8fe1" class="mg mh it lb b lc mp lf mq li mr lm ms lq mt lu ml mm mn mo bi translated">你的队友可以理解真正的代码应该如何工作，以及为什么。</li><li id="4365" class="mg mh it lb b lc mp lf mq li mr lm ms lq mt lu ml mm mn mo bi translated">您的队友可以轻松地添加一个新功能，而不必担心破坏代码。</li><li id="c8f7" class="mg mh it lb b lc mp lf mq li mr lm ms lq mt lu ml mm mn mo bi translated">鼓励你的队友添加一个测试。(如果测试代码太大，令人生畏，就会发生破窗！)</li></ul><p id="263e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这些都是我个人在团队发展中的经验教训。一个好的程序员总是写一个可维护性很强的测试。</p><p id="53a3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">以下是编写测试时的一些提示:</p><ul class=""><li id="fdb0" class="mg mh it lb b lc ld lf lg li mi lm mj lq mk lu ml mm mn mo bi translated">用简单的英语描述测试的目的(最好是你的母语)。</li><li id="4cab" class="mg mh it lb b lc mp lf mq li mr lm ms lq mt lu ml mm mn mo bi translated">遵循AAA(安排、行动、断言)模式。</li><li id="7418" class="mg mh it lb b lc mp lf mq li mr lm ms lq mt lu ml mm mn mo bi translated">使添加测试用例变得容易(表格驱动的测试模式)。</li></ul><h2 id="44ba" class="oe nc it bd nd ok ol dn nh om on dp nl li oo op nn lm oq or np lq os ot nr ou bi translated">用简单的英语描述测试的目的</h2><p id="98b8" class="pw-post-body-paragraph kz la it lb b lc nt ju le lf nu jx lh li nv lk ll lm nw lo lp lq nx ls lt lu im bi translated">正如我上面所说的，如果测试是描述性的，人们很容易理解它在做什么。</p><p id="89c5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">假设我们有一个这样的实用函数:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ny nz l"/></div></figure><p id="7b51" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">并编写一个测试:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ny nz l"/></div></figure><p id="428e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这是一个非常简单的例子，所以你大概可以理解它试图做什么。但是如果它变得越来越大，越来越混乱，你就很难理解它。</p><p id="ced0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这对你来说没问题，因为你已经写了这个函数，你知道它的行为。但是测试不仅仅是你的，也是你队友的。</p><p id="639f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们更详细地描述一下:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ny nz l"/></div></figure><p id="d4e3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这看起来有点多余。但这不是重点。通过描述，你让人们知道当代码为1时，正确的行为是得到CATS。</p><p id="f79b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">为了在每个上下文中更加清晰，您可以使用上下文块，如下所示:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ny nz l"/></div></figure><p id="45d0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">注意:如果使用Jest，可以安装<a class="ae ky" href="https://www.npmjs.com/package/jest-plugin-context" rel="noopener ugc nofollow" target="_blank"> jest-plugin-context </a>。</p><p id="ce78" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这样写，可以把每个块中的具体上下文分开。</p><h2 id="b1a7" class="oe nc it bd nd ok ol dn nh om on dp nl li oo op nn lm oq or np lq os ot nr ou bi translated">遵循AAA模式</h2><p id="d14e" class="pw-post-body-paragraph kz la it lb b lc nt ju le lf nu jx lh li nv lk ll lm nw lo lp lq nx ls lt lu im bi translated">AAA模式允许您将测试分成三个部分:安排、执行和断言。</p><p id="99d8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu">安排</strong>部分是你设置数据或者模拟测试中使用的函数的地方。</p><p id="2d78" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu"> act </strong>部分是调用测试方法并在需要时捕获输出值的地方。</p><p id="1b00" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">断言部分是你声明输出的地方。</p><p id="731a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果我们将它应用到上面的例子中，代码将是这样的:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ny nz l"/></div></figure><p id="efef" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这是另一个用酶进行反应测试的例子:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ny nz l"/></div></figure><p id="45ed" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">一旦你习惯了这种模式，你就可以更容易地阅读和理解测试。</p><p id="4c83" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在GitHub上，<a class="ae ky" href="https://github.com/goldbergyoni/javascript-testing-best-practices#-%EF%B8%8F-12-structure-tests-by-the-aaa-pattern" rel="noopener ugc nofollow" target="_blank">javascript-testing-best-practices</a>是解释JavaScript测试的好指南。</p><h2 id="a9d4" class="oe nc it bd nd ok ol dn nh om on dp nl li oo op nn lm oq or np lq os ot nr ou bi translated">使添加测试用例变得容易(表格驱动的测试模式)</h2><p id="47e4" class="pw-post-body-paragraph kz la it lb b lc nt ju le lf nu jx lh li nv lk ll lm nw lo lp lq nx ls lt lu im bi translated">表驱动测试模式在<a class="ae ky" href="https://golang.org/" rel="noopener ugc nofollow" target="_blank"> Go </a>测试中被大量使用。它的优点是能够通过在每个表条目中定义输入和预期结果来覆盖许多测试用例。</p><p id="ed88" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">下面是Go 中<a class="ae ky" href="https://golang.org/pkg/fmt/" rel="noopener ugc nofollow" target="_blank"> fmt包的一个例子:</a></p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ny nz l"/></div></figure><p id="f7eb" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">输入和预期输出在<code class="fe mc md me mf b">flagtests</code>变量中定义。您所要做的就是遍历它，运行测试，并检查结果。</p><p id="d854" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">您可以将此应用于JavaScript测试。</p><p id="5252" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">例如:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ny nz l"/></div></figure><p id="51d9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">并使其适用于:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ny nz l"/></div></figure><p id="d163" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">测试将通过:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi pc"><img src="../Images/033617c37afd81d657944b2337eebe82.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*3skivGgBme97mQYYqW4fdQ.png"/></div></div></figure><p id="263a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果你有很多测试用例，这种技术会很有用。</p></div><div class="ab cl mu mv hx mw" role="separator"><span class="mx bw bk my mz na"/><span class="mx bw bk my mz na"/><span class="mx bw bk my mz"/></div><div class="im in io ip iq"><h1 id="6c2c" class="nb nc it bd nd ne nf ng nh ni nj nk nl jz nm ka nn kc no kd np kf nq kg nr ns bi translated">结论</h1><p id="88f9" class="pw-post-body-paragraph kz la it lb b lc nt ju le lf nu jx lh li nv lk ll lm nw lo lp lq nx ls lt lu im bi translated">我已经通过一些例子介绍了如何使代码易于理解。记住，干净和智能的代码并不总是更好。重要的是退一步问自己，“这已经更干净了，但它是可理解和可读的吗？”或者“对其他队友来说可维护吗？”<em class="lv"> </em>如果是这样<em class="lv">，</em>你可以去争取一下。</p><p id="da30" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">希望这篇文章对你有很大帮助。</p><p id="81d5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果您有任何建议、意见和想法，请告诉我。</p></div><div class="ab cl mu mv hx mw" role="separator"><span class="mx bw bk my mz na"/><span class="mx bw bk my mz na"/><span class="mx bw bk my mz"/></div><div class="im in io ip iq"><h1 id="9d2d" class="nb nc it bd nd ne nf ng nh ni nj nk nl jz nm ka nn kc no kd np kf nq kg nr ns bi translated">资源</h1><ul class=""><li id="a3ca" class="mg mh it lb b lc nt lf nu li pd lm pe lq pf lu ml mm mn mo bi translated"><a class="ae ky" href="https://dev.to/d_ir/clean-code-dirty-code-human-code-6nm" rel="noopener ugc nofollow" target="_blank">干净代码、脏代码、人为代码</a></li><li id="3097" class="mg mh it lb b lc mp lf mq li mr lm ms lq mt lu ml mm mn mo bi translated"><a class="ae ky" href="https://overreacted.io/goodbye-clean-code/" rel="noopener ugc nofollow" target="_blank">再见，干净代码</a></li><li id="74a3" class="mg mh it lb b lc mp lf mq li mr lm ms lq mt lu ml mm mn mo bi translated">罗伯特·c·马丁的《干净的代码:敏捷软件工艺手册》</li><li id="6ca5" class="mg mh it lb b lc mp lf mq li mr lm ms lq mt lu ml mm mn mo bi translated">可读代码的艺术</li><li id="6a7c" class="mg mh it lb b lc mp lf mq li mr lm ms lq mt lu ml mm mn mo bi translated">单元测试的原则、实践和模式</li><li id="a092" class="mg mh it lb b lc mp lf mq li mr lm ms lq mt lu ml mm mn mo bi translated"><a class="ae ky" href="https://github.com/goldbergyoni/javascript-testing-best-practices#-%EF%B8%8F-12-structure-tests-by-the-aaa-pattern" rel="noopener ugc nofollow" target="_blank"> javascript测试最佳实践</a></li><li id="1f58" class="mg mh it lb b lc mp lf mq li mr lm ms lq mt lu ml mm mn mo bi translated"><a class="ae ky" href="https://github.com/golang/go/wiki/TableDrivenTests" rel="noopener ugc nofollow" target="_blank">表格驱动测试</a></li></ul></div></div>    
</body>
</html>