<html>
<head>
<title>Async/Await Errors As Control Flow and Guards in JavaScript: How To Handle Errors in the Next Decade</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">JavaScript中作为控制流和守卫的异步/等待错误:未来十年如何处理错误</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/async-await-errors-as-control-flow-guards-in-javascript-for-the-next-decade-46290deb42c?source=collection_archive---------15-----------------------#2019-10-28">https://betterprogramming.pub/async-await-errors-as-control-flow-guards-in-javascript-for-the-next-decade-46290deb42c?source=collection_archive---------15-----------------------#2019-10-28</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="00b3" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">如何以一种漂亮的方式编写干净的、带错误处理的异步代码</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/0b5f11abeada99186144f8fd85fd9ebd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*k2syRTds2xkTIKevWYmMNg.jpeg"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">照片由<a class="ae ky" href="https://unsplash.com/@yakimadesign?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">乔丹·罗兰</a>在<a class="ae ky" href="https://unsplash.com/s/photos/stadium?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</p></figure><p id="90f0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们可能仍然认为JavaScript是90年代遗留下来的语言，但它是这个街区最酷的孩子。</p><p id="3da4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">一方面，处理错误是很重要的，否则用户会碰壁，他们不能修改他们输入的数据，也不知道发生了什么，因为错误消息非常模糊。</p><p id="4188" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">另一方面，对于开发团队来说，拥有一个像野生动物一样到处都是条件和错误对象的巨大代码库是不可取的。</p><p id="0c35" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">但是说实话，处理每一个可能的错误都很难。</p><p id="25c2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">因此，在这篇博文中，我将向您展示一些在JavaScript中有效处理异步错误的方法。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi lv"><img src="../Images/8b3b4ca162b75097a13deaa30bb2f843.png" data-original-src="https://miro.medium.com/v2/resize:fit:1058/1*NpRHDi7sUiLo8Z7v0SspZA.gif"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">未知错误lol</p></figure><p id="03e1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在这篇文章中，我从现代编程语言中获得灵感，如<a class="ae ky" href="https://golang.org/" rel="noopener ugc nofollow" target="_blank"> Go </a>和<a class="ae ky" href="https://developer.apple.com/swift/" rel="noopener ugc nofollow" target="_blank"> Swift </a>，我将跳过对<code class="fe lw lx ly lz b">async/await</code>、<code class="fe lw lx ly lz b">Promise</code>和<em class="ma">回调</em>的解释。</p></div><div class="ab cl mb mc hx md" role="separator"><span class="me bw bk mf mg mh"/><span class="me bw bk mf mg mh"/><span class="me bw bk mf mg"/></div><div class="im in io ip iq"><h1 id="0788" class="mi mj it bd mk ml mm mn mo mp mq mr ms jz mt ka mu kc mv kd mw kf mx kg my mz bi translated">灵感</h1><p id="7e39" class="pw-post-body-paragraph kz la it lb b lc na ju le lf nb jx lh li nc lk ll lm nd lo lp lq ne ls lt lu im bi translated">像Go这样的语言非常重视错误处理。总有一个名为<code class="fe lw lx ly lz b">err</code>的变量需要检查。这里有一个<a class="ae ky" href="https://blog.golang.org/error-handling-and-go" rel="noopener ugc nofollow" target="_blank">的例子</a>:</p><pre class="kj kk kl km gt nf lz ng nh aw ni bi"><span id="aced" class="nj mj it lz b gy nk nl l nm nn">if data, err := datastore.Get(c, key, record); err != nil {<br/>    http.Error(w, err.Error(), 500)<br/>    return<br/>}</span></pre><p id="8736" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这里是Swift中的一个<a class="ae ky" href="https://stackoverflow.com/a/39263210/3416691" rel="noopener ugc nofollow" target="_blank">示例</a>:</p><pre class="kj kk kl km gt nf lz ng nh aw ni bi"><span id="f44a" class="nj mj it lz b gy nk nl l nm nn">func icon() -&gt; UIImage {<br/>    guard let image = UIImage(named: "Photo") else {<br/>        return UIImage(named: "Default")!<br/>    }<br/>    return image<br/>}</span></pre><p id="61f5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我的目标是用JavaScript写出像前面这些例子一样漂亮、简洁和清晰的东西。</p></div><div class="ab cl mb mc hx md" role="separator"><span class="me bw bk mf mg mh"/><span class="me bw bk mf mg mh"/><span class="me bw bk mf mg"/></div><div class="im in io ip iq"><h1 id="6487" class="mi mj it bd mk ml mm mn mo mp mq mr ms jz mt ka mu kc mv kd mw kf mx kg my mz bi translated">异步方法</h1><p id="a1b2" class="pw-post-body-paragraph kz la it lb b lc na ju le lf nb jx lh li nc lk ll lm nd lo lp lq ne ls lt lu im bi translated">下面是一些<code class="fe lw lx ly lz b">async</code>方法:</p><pre class="kj kk kl km gt nf lz ng nh aw ni bi"><span id="c85e" class="nj mj it lz b gy nk nl l nm nn">async function fetchData() {<br/>  return fetch("...");<br/>}</span><span id="7619" class="nj mj it lz b gy no nl l nm nn">async function sendData(data) {<br/>  return fetch("...", {<br/>    method: "post",<br/>    body: JSON.stringify(data),<br/>  });<br/>}</span><span id="fd9f" class="nj mj it lz b gy no nl l nm nn">async function signData(data) {<br/> // Do something cool with cryptography ;)<br/>}</span></pre><p id="46cf" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们将在下一节中使用这些方法。</p></div><div class="ab cl mb mc hx md" role="separator"><span class="me bw bk mf mg mh"/><span class="me bw bk mf mg mh"/><span class="me bw bk mf mg"/></div><div class="im in io ip iq"><h1 id="b154" class="mi mj it bd mk ml mm mn mo mp mq mr ms jz mt ka mu kc mv kd mw kf mx kg my mz bi translated">完全没有处理</h1><p id="0718" class="pw-post-body-paragraph kz la it lb b lc na ju le lf nb jx lh li nc lk ll lm nd lo lp lq ne ls lt lu im bi translated">快速而肮脏的解决方法是跳过任何<code class="fe lw lx ly lz b">try/catch</code>,并希望最好的。如果您对全球互联网网络、您的服务器和用户(世界上最容易被误解的生物)非常有信心，您可以编写如下代码:</p><pre class="kj kk kl km gt nf lz ng nh aw ni bi"><span id="6dd6" class="nj mj it lz b gy nk nl l nm nn">async function handleClick() {<br/>  const data = await fetchData();<br/>  const signed = await signData(data);<br/>  const saved = await sendData(signed);</span><span id="72f1" class="nj mj it lz b gy no nl l nm nn"><strong class="lz iu">  setState({ status: "ok ✅" });</strong><br/>}</span></pre></div><div class="ab cl mb mc hx md" role="separator"><span class="me bw bk mf mg mh"/><span class="me bw bk mf mg mh"/><span class="me bw bk mf mg"/></div><div class="im in io ip iq"><h1 id="33f4" class="mi mj it bd mk ml mm mn mo mp mq mr ms jz mt ka mu kc mv kd mw kf mx kg my mz bi translated">整体捕获</h1><p id="4679" class="pw-post-body-paragraph kz la it lb b lc na ju le lf nb jx lh li nc lk ll lm nd lo lp lq ne ls lt lu im bi translated">你应该写的最少的附加内容是至少显示一个警告，也许用一个大包装<code class="fe lw lx ly lz b">try/catch</code>来报告错误。</p><pre class="kj kk kl km gt nf lz ng nh aw ni bi"><span id="7afe" class="nj mj it lz b gy nk nl l nm nn">async function handleClick() {<br/>  <strong class="lz iu">try {</strong><br/>    const data = await fetchData();<br/>    const signed = await signData(data);<br/>    const saved = await sendData(signed);<br/>    setState({ status: "ok <strong class="lz iu">✅</strong>" });<br/><strong class="lz iu">  } catch (err) {</strong><br/>    <strong class="lz iu">setState({ status: "Something bad happened 🤷‍♂️" });</strong><br/>  <strong class="lz iu">}</strong><br/>}</span></pre><p id="a5cf" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">使用这种方法，您让用户或系统重试操作，但是他们永远不会知道错误的原因。这真的很令人沮丧。</p></div><div class="ab cl mb mc hx md" role="separator"><span class="me bw bk mf mg mh"/><span class="me bw bk mf mg mh"/><span class="me bw bk mf mg"/></div><div class="im in io ip iq"><h1 id="76d0" class="mi mj it bd mk ml mm mn mo mp mq mr ms jz mt ka mu kc mv kd mw kf mx kg my mz bi translated">一步一步让/试/抓</h1><p id="0ee4" class="pw-post-body-paragraph kz la it lb b lc na ju le lf nb jx lh li nc lk ll lm nd lo lp lq ne ls lt lu im bi translated">这是一个更好控制的流程，您可以实际判断错误是在哪里触发的。</p><pre class="kj kk kl km gt nf lz ng nh aw ni bi"><span id="fee3" class="nj mj it lz b gy nk nl l nm nn">async function handleClick() {<br/><strong class="lz iu">  let data = null;<br/>  try {<br/>    data = await fetchData();<br/>  } catch (err) {<br/>    return setState({ status: "Network error 🔌" });<br/>  }</strong></span><span id="e469" class="nj mj it lz b gy no nl l nm nn"><strong class="lz iu">  let signed = null;<br/>  try {<br/>    signed = await signData(data);<br/>  } catch (err) {<br/>    return setState({ status: "Signature error 🔑" });<br/>  }</strong></span><span id="fb41" class="nj mj it lz b gy no nl l nm nn"><strong class="lz iu">  try {<br/>    const saved = await sendData(signed);<br/>    setState({ status: "ok ✅" });<br/>  } catch (err) {<br/>    return setState({ status: "Could not save data 💾" });<br/>  }</strong><br/>}</span></pre><p id="6261" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">个人来说:“我不是<code class="fe lw lx ly lz b">let</code>的超级粉丝，更不是<code class="fe lw lx ly lz b">var</code>的粉丝。”那么，我们可以用类似于Go或Swift的语法实现同样的结果吗？</p></div><div class="ab cl mb mc hx md" role="separator"><span class="me bw bk mf mg mh"/><span class="me bw bk mf mg mh"/><span class="me bw bk mf mg"/></div><div class="im in io ip iq"><h1 id="117f" class="mi mj it bd mk ml mm mn mo mp mq mr ms jz mt ka mu kc mv kd mw kf mx kg my mz bi translated">我的建议是:作为后卫接球</h1><p id="59f5" class="pw-post-body-paragraph kz la it lb b lc na ju le lf nb jx lh li nc lk ll lm nd lo lp lq ne ls lt lu im bi translated">如果我们捕捉到错误，用任何需要的副作用处理它，然后抛出一个用户友好的错误，我们可以稍后向用户显示，那么在JavaScript中可能有类似于<em class="ma"> guard子句</em>的语法。</p><pre class="kj kk kl km gt nf lz ng nh aw ni bi"><span id="9b8e" class="nj mj it lz b gy nk nl l nm nn">async function handleClick() {<br/>  try {<br/>    const data = await fetchData()<strong class="lz iu">.catch(err =&gt; {<br/>      throw new Error("Network error 🔌");<br/>    });</strong><br/>    const signed = await signData(data)<strong class="lz iu">.catch(err =&gt; {<br/>      throw new Error("Signature error 🔑");<br/>    });</strong><br/>    const saved = await sendData(signed)<strong class="lz iu">.catch(err =&gt; {<br/>  </strong>    // Report error or any side effect.<strong class="lz iu"><br/>      throw new Error("Could not save data 💾");<br/>    });</strong><br/>    setState({ status: "ok <strong class="lz iu">✅</strong>" });<br/>  } catch (err) {<br/>    setState({ status: err.message });<br/>  }<br/>}</span></pre><p id="fda5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">跳过包装<code class="fe lw lx ly lz b">try/catch</code>也是可能的，但是这将使这个承诺无法处理。</p><p id="7ad1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这可能不是问题，因为代码是异步的。此外，这不会中断任何React.js应用程序的呈现，也不会以错误代码退出任何<a class="ae ky" href="https://nodejs.org/" rel="noopener ugc nofollow" target="_blank"> Node.js </a>脚本。</p><p id="1ada" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这里有一个使用<a class="ae ky" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Comma_Operator" rel="noopener ugc nofollow" target="_blank">逗号操作符</a>的例子(它更简单，但是知道它的人不多):</p><pre class="kj kk kl km gt nf lz ng nh aw ni bi"><span id="677f" class="nj mj it lz b gy nk nl l nm nn">async function handleClick() {<br/>  const data = await fetchData().catch(err =&gt; {<br/><strong class="lz iu">    throw (setState({ status: "Network error 🔌" }), err);</strong><br/>  });<br/>  const signed = await signData(data).catch(err =&gt; {<br/><strong class="lz iu">    throw (setState({ status: "Signature error 🔑" }), err);</strong><br/>  });<br/>  const saved = await sendData(signed).catch(err =&gt; {<br/>    // Report error or any side effect.<br/><strong class="lz iu">    throw (setState({ status: "Could not save data 💾" }), err);</strong><br/>  });<br/>  setState({ status: "ok <strong class="lz iu">✅</strong>" });<br/>}</span></pre><p id="2bdc" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">您可能需要禁用ESLint规则,以便在没有警告的情况下使用逗号运算符。</p><p id="2ccf" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">事实上，你可以在JavaScript中抛出任何值、对象，甚至<code class="fe lw lx ly lz b">undefined</code>(见<a class="ae ky" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/throw" rel="noopener ugc nofollow" target="_blank"> MDN </a>)。理论上你甚至可以抛出<code class="fe lw lx ly lz b">setState</code>的结果，也就是<code class="fe lw lx ly lz b">void</code>:</p><pre class="kj kk kl km gt nf lz ng nh aw ni bi"><span id="4ba4" class="nj mj it lz b gy nk nl l nm nn">async function handleClick() {<br/>  const data = await fetchData().catch(err =&gt; {<br/>    throw setState({ status: "Network error <strong class="lz iu">🔌</strong>" }); // <strong class="lz iu">throw void;</strong><br/>  });<br/>  // ...<br/>  setState({ status: "ok <strong class="lz iu">✅</strong>" });<br/>}</span></pre><p id="fe67" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在我看来，就兼容性和标准化而言，最好坚持使用原生的<code class="fe lw lx ly lz b"><a class="ae ky" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Error" rel="noopener ugc nofollow" target="_blank">Error</a></code> <a class="ae ky" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Error" rel="noopener ugc nofollow" target="_blank">对象</a>。</p><p id="9c7f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">不应该抛出空值的另一个原因是，您会丢失关于错误的信息，因此调试变得更加困难。</p><p id="8e39" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在写这篇文章的时候，我也想过像<code class="fe lw lx ly lz b">setState</code>一样返回一个数组，让它看起来更像Go。这里有一个例子:</p><pre class="kj kk kl km gt nf lz ng nh aw ni bi"><span id="19d4" class="nj mj it lz b gy nk nl l nm nn"><strong class="lz iu">async function p(promise) {<br/>  return promise<br/>    .then(result =&gt; [result, null])<br/>    .catch(err =&gt; [null, err]);<br/>}</strong></span><span id="9168" class="nj mj it lz b gy no nl l nm nn">async function handleClick() {<br/>  <strong class="lz iu">const [data, err0] = await p(fetchData());</strong><br/>  <strong class="lz iu">if (err0) {</strong><br/>    return setState({ status: "Network error <strong class="lz iu">🔌</strong>" });<br/>  <strong class="lz iu">}</strong></span><span id="2d6d" class="nj mj it lz b gy no nl l nm nn"><strong class="lz iu">  const [signed, err1] = await p(signData());</strong><br/><strong class="lz iu">  if (err1) {</strong><br/>    return setState({ status: "Signature error <strong class="lz iu">🔑</strong>" });<br/>  <strong class="lz iu">}</strong></span><span id="8d85" class="nj mj it lz b gy no nl l nm nn">  // ...</span><span id="bc9b" class="nj mj it lz b gy no nl l nm nn">  setState({ status: "ok <strong class="lz iu">✅</strong>" });<br/>}</span></pre><p id="f1db" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">最终，有许多方法可以实现相同的结果:一个为用户和工程团队以干净、直观的方式处理错误的编程流程。</p><p id="6c00" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">您可以使用这些选项中的每一个并将它们混合起来，这样您就可以得到适合您的代码库的东西。这也适用于服务器端应用程序，如<a class="ae ky" href="https://expressjs.com/" rel="noopener ugc nofollow" target="_blank"> Express.js </a>或<a class="ae ky" href="https://koajs.com/" rel="noopener ugc nofollow" target="_blank"> Koa.js </a>。</p><p id="51bb" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">与此同时，我将坚持用<em class="ma">接球当后卫</em>的方法。</p></div></div>    
</body>
</html>