<html>
<head>
<title>Python’s Type Hinting: Friend, Foe, or Just a Headache?</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Python的类型暗示:朋友，敌人，还是只是头痛？</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/pythons-type-hinting-friend-foe-or-just-a-headache-73c7849039c7?source=collection_archive---------2-----------------------#2022-09-30">https://betterprogramming.pub/pythons-type-hinting-friend-foe-or-just-a-headache-73c7849039c7?source=collection_archive---------2-----------------------#2022-09-30</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="9cd1" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">类型提示在Python社区越来越受欢迎。这将把我们引向何方？我们能做些什么来正确使用它？</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/ce9475c6e3980a2f5c338f8365159f73.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*vEUXEstvBlWhnm2R"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">Python:使用类型提示进行提示真的有帮助吗？照片由<a class="ae ky" href="https://unsplash.com/@emilymorter?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">艾米丽·莫特</a>在<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>拍摄</p></figure><p id="334e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">所有的Python爱好者都知道，几年来，Python的类型提示迅速流行起来。它始于Python 3.5，从那以后，这个功能有了更多的类型和函数，在Python 3.10中，甚至有了一个新的操作符<code class="fe lv lw lx ly b">|</code>。不管幸运与否，这个运算符与用于集合的同一个运算符有相似的含义。</p><p id="c202" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我听到了关于类型暗示的不同观点，从愤怒和仇恨到爱和奉献。大多数用Python编写类型提示的作者认为它们很有帮助，可以增加代码的可读性，尤其是在代码库很大的情况下。然而，当这样做时，它们通常显示非常简单的类型提示示例。</p><p id="a735" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">尽管类型提示使人们能够使用静态类型检查器，但我们不会在本文中讨论这个主题。我不得不承认，这种静态检查确实是一种有用的工具。在这里，我们将讨论一个更有争议的话题，即类型提示是否有帮助。有些人认为这是理所当然的，但我不这样认为。我想看证据。就像几乎所有事情一样，一件好事做得太多也可能是坏事。Python类型暗示也是如此吗？</p><p id="4caa" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">类型提示有很多拥护者。有些人只说这是一个非常有用的工具。其他人声称您需要使用类型提示，因为没有它们Python代码很难阅读，如果不是不可理解的话。</p><p id="ef10" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">为了便于讨论，我想请你保持开放的心态。目前，不要想当然地认为类型提示有优势。相反，让我们试着分析它们，以便找到它们的利弊。</p><p id="fa89" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在，打开我们的思路，让我们进入关于在Python中使用类型提示的讨论，集中在以下问题上:它们是否像我们一直听到的那样有帮助？或者，事实上，它们会降低代码的可读性吗？如果是这样的话，我们是否可以改进类型提示，使结果代码更具可读性？</p><h1 id="3d79" class="lz ma it bd mb mc md me mf mg mh mi mj jz mk ka ml kc mm kd mn kf mo kg mp mq bi translated">代替对类型提示的介绍</h1><p id="552e" class="pw-post-body-paragraph kz la it lb b lc mr ju le lf ms jx lh li mt lk ll lm mu lo lp lq mv ls lt lu im bi translated">我不会解释类型提示，因为这会使这篇文章太长。此外，它们已经在各种来源中描述过，这里也在介质上描述过(例如，这里的<a class="ae ky" href="https://medium.com/@prozeth/dont-be-afraid-of-python-s-type-hints-c3fcb7cda4d9" rel="noopener"/>、这里的<a class="ae ky" href="https://medium.com/towards-data-science/exploring-python-type-hints-6520f478b6a" rel="noopener"/>或这里的<a class="ae ky" href="https://medium.com/towards-data-science/type-hints-in-python-everything-you-need-to-know-in-5-minutes-24e0bad06d0b" rel="noopener"/>)。在《流畅的Python》第二版中，卢西亚诺·拉马尔霍给出了相当详细的介绍。你可以在许多书中看到类型提示的作用。比如在Steven F. Lott的<em class="mw">函数式Python编程</em>(也是第二版)。</p><p id="30c8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">类型提示有三个主要目的:它使您能够在代码上运行静态检查器；它可以帮助你理解函数签名(参数类型，返回类型)；并且可以增加代码的可读性。让我们考虑几个例子。只分析函数的签名就足够了，这也是包含类型提示的地方。</p><p id="5874" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在继续之前，请阅读下面的代码片段，并尽可能多地从函数的签名中寻找答案。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mx my l"/></div></figure><p id="ce6d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在，让我们来谈谈这些功能:</p><ul class=""><li id="9d24" class="mz na it lb b lc ld lf lg li nb lm nc lq nd lu ne nf ng nh bi translated"><code class="fe lv lw lx ly b">parse_text()</code>:它接受一个文本(作为一个字符串),在以某种方式解析它之后，它返回一个解析过的字符串。当然，我们不知道这个解析在这里意味着什么，但是从函数体来看应该很容易理解。这个签名很容易理解。</li><li id="f53b" class="mz na it lb b lc ni lf nj li nk lm nl lq nm lu ne nf ng nh bi translated"><code class="fe lv lw lx ly b">gdu()</code>:嗯……不知道。这个签名简直是噩梦。</li><li id="be36" class="mz na it lb b lc ni lf nj li nk lm nl lq nm lu ne nf ng nh bi translated"><code class="fe lv lw lx ly b">report_bug()</code>:显然，这个函数的目的是报告一个bug。bug作为字符串传递。<code class="fe lv lw lx ly b">reporter</code>可能是报告错误的人/事，以字符串形式给出，默认值由全局变量<code class="fe lv lw lx ly b">DEFAULT_REPORTER</code>提供。<code class="fe lv lw lx ly b">report_to</code>是要报告bug的位置，也以字符串形式给出，也带有由全局变量(<code class="fe lv lw lx ly b">DEFAULT_REPORT_TO</code>)提供的默认值。<br/>该函数返回一个布尔值；它可能会告知错误是否被成功报告。尽管比<code class="fe lv lw lx ly b">parse_text()</code>类型的提示更复杂，但它们也很简单。</li><li id="0149" class="mz na it lb b lc ni lf nj li nk lm nl lq nm lu ne nf ng nh bi translated"><code class="fe lv lw lx ly b">measure_distance()</code>:我们知道函数测量距离，并以浮点形式返回。然而，我们不知道这个float代表哪个单元。距离是从一个位置到另一个位置，由于它们是以两个浮点数的元组的形式提供的，所以它们很可能是地理坐标。这个签名暗示了这个函数做了什么，但是它可以更具可读性。</li></ul><p id="16de" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">当然，我们很少能仅仅通过阅读函数的签名来了解函数的所有功能。但是如果签名是好的，我们甚至不用查看函数体就可以学到很多东西。但是当情况像<code class="fe lv lw lx ly b">gdu()</code>中这样混乱的时候，打字提示不仅没有帮助，甚至会成为额外的障碍，只会增加我们的麻烦。</p><p id="8800" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">当然，在<code class="fe lv lw lx ly b">gdu()</code>中，问题不仅仅在于复杂的类型提示；它还在于——如果不是主要的话——糟糕的命名，这一点帮助都没有。</p><p id="4a82" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">有一些方法可以提高可读性。再看一眼<code class="fe lv lw lx ly b">measure_distance()</code>。它的签名没有传达两件事:度量单位是什么(公里、米、英里或其他公制单位)；以及这两个元组是否表示地理坐标。为了给用户提供这两条信息，我们能改进类型提示吗？</p><p id="7550" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">事实上，我们可以。这就是类型别名(我有时称之为自定义类型)能有很大帮助的地方:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mx my l"/></div></figure><p id="56e0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这个签名确实说明了我们之前遗漏了什么，这要归功于类型别名<code class="fe lv lw lx ly b">Km</code>和<code class="fe lv lw lx ly b">Coordinates</code>:位置是地理坐标，距离以千米为单位。</p><p id="592d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">通常，使用实际的数据结构比使用类型别名更好:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mx my l"/></div></figure><p id="fd41" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这里，<code class="fe lv lw lx ly b">Coordinates</code>是一个<code class="fe lv lw lx ly b">namedtuple</code>数据结构，不是类型别名。您应该使用哪种方法？看情况。因为两者都很容易理解，所以根据您是否将数据结构用于不同的目的来决定。在这里，它将被用作实际位置的容器；在这种情况下，使用自定义数据结构。否则，使用类型别名。</p><p id="f881" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">请记住:</p><blockquote class="nn no np"><p id="ea68" class="kz la mw lb b lc ld ju le lf lg jx lh nq lj lk ll nr ln lo lp ns lr ls lt lu im bi translated">创建类型别名时，命名至关重要。使用有意义的名称，就像创建自定义数据结构一样。</p></blockquote><h1 id="4f3a" class="lz ma it bd mb mc md me mf mg mh mi mj jz mk ka ml kc mm kd mn kf mo kg mp mq bi translated">那么，键入提示有多大帮助呢？</h1><p id="5d44" class="pw-post-body-paragraph kz la it lb b lc mr ju le lf ms jx lh li mt lk ll lm mu lo lp lq mv ls lt lu im bi translated">类型提示可以帮助增加可读性，正如函数<code class="fe lv lw lx ly b">parse_text()</code>、<code class="fe lv lw lx ly b">report_bug()</code>和<code class="fe lv lw lx ly b">measure_distance()</code>所示。有时，带有信息性类型提示的签名足以让读者理解该函数的作用。</p><p id="6ca0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">抱歉，你说什么？啊，我明白了…我忘了提<code class="fe lv lw lx ly b">gdu()</code>功能，它完全没有任何有意义的东西。你把它作为反例指出来是对的。让我们回忆一下<code class="fe lv lw lx ly b">gdu()</code>的签名，在没有类型提示的情况下重写它:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mx my l"/></div></figure><p id="c8b6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">两个版本都同样不可读，原因只有一个:函数本身及其参数的无意义的名称。这些类型提示无助于解释函数做什么，但是它们会增加麻烦。</p><blockquote class="nn no np"><p id="df4b" class="kz la mw lb b lc ld ju le lf lg jx lh nq lj lk ll nr ln lo lp ns lr ls lt lu im bi translated">在极少数情况下，当命名不好时，类型提示可以增加函数签名的可读性。然而，在考虑使用类型提示来提高可读性之前，请重新考虑命名。使用清晰和信息丰富的名称，然后使用类型提示来进一步增加函数的可读性。</p></blockquote><p id="6c8b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">正如你所看到的，类型本身，没有其他任何东西，通常也是没有意义的。我们知道<code class="fe lv lw lx ly b">zizi</code>是一个接受字符串并返回字符串的可调用函数，但这并不意味着什么。因此，我们的第一个重要结论是:</p><blockquote class="nn no np"><p id="402f" class="kz la mw lb b lc ld ju le lf lg jx lh nq lj lk ll nr ln lo lp ns lr ls lt lu im bi translated">类型提示仅适用于良好的命名。没有好的命名，任何东西都不会有助于提高代码的可读性，包括类型提示。</p></blockquote><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nt"><img src="../Images/3399748bd2063d8f4e86895ff23ea279.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*6xp9_DjDexW3ZtsisvMWRw.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">一些开发人员对Python类型提示着迷。作者图片。</p></figure><p id="5846" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">即使使用了良好的命名，类型提示也会使函数的签名难以阅读和理解。看下面这个例子(<a class="ae ky" href="https://skeptric.com/python-maybe-monad/" rel="noopener ugc nofollow" target="_blank">来源</a>):</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mx my l"/></div></figure><p id="4c4d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">免责声明:这是Python中类型提示的一个例子，它不违反规则。我并不想批评这段代码，而是想说明我不喜欢类型暗示的某些用法。</p><p id="5e68" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在，让我们完全删除类型提示:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mx my l"/></div></figure><p id="ea91" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">因为我们没有<code class="fe lv lw lx ly b">f</code>的类型提示，我把它的名字改成了<code class="fe lv lw lx ly b">func</code>，使它更有意义。<code class="fe lv lw lx ly b">maybe_fmap()</code>是<a class="ae ky" href="https://en.wikibooks.org/wiki/Haskell/Understanding_monads/Maybe" rel="noopener ugc nofollow" target="_blank"/><code class="fe lv lw lx ly b"><a class="ae ky" href="https://en.wikibooks.org/wiki/Haskell/Understanding_monads/Maybe" rel="noopener ugc nofollow" target="_blank">Maybe</a></code><a class="ae ky" href="https://en.wikibooks.org/wiki/Haskell/Understanding_monads/Maybe" rel="noopener ugc nofollow" target="_blank">单子</a>的简单实现。比较带注释和不带注释的代码。你认为前者比后者更容易阅读和理解吗？我没有；我觉得他们的可读性差不多。</p><p id="4d64" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果没有类型提示，很容易看到<code class="fe lv lw lx ly b">maybe_fmap()</code>将一个可调用对象作为参数；有人看不出<code class="fe lv lw lx ly b">func</code>代表一个callable吗？我看到函数返回<code class="fe lv lw lx ly b">lambda</code>，确实是可调用的；很难看到吗？</p><p id="9fab" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我同意初学Python的用户可能很难看到这一切。但是你认为类型提示会帮助他们看到这一切吗？我没有；我认为，尽管理解<code class="fe lv lw lx ly b">maybe_fmap()</code>的上述方面有问题，他们在理解下面的签名方面会有更大的问题:<code class="fe lv lw lx ly b">maybe_fmap(f: Callable[a, b]) -&gt; Callable[Optional[a], Optional[b]]</code>。</p><p id="3e3c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">通过这个例子，我想指出的是，有时类型提示会使代码变得不必要的复杂。因此，大多数时候，我更喜欢一种介于两者之间的解决方案，一种以合理的(可理解的)方式提供类型提示的解决方案。这意味着避免过于复杂的类型提示。</p><p id="76f7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">当然，这是一个偏好的问题，但是我害怕使用充满了长而复杂的类型提示的代码。我使用类型提示，但是我更喜欢简单的，就像上面例子中的那些，比如<code class="fe lv lw lx ly b">parse_text()</code>、<code class="fe lv lw lx ly b">report_bug()</code>，最重要的是<code class="fe lv lw lx ly b">measure_distance()</code>。</p><p id="e8e2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">困难的类型提示不会使代码更容易理解；事实上，他们使它更不可读。这就是为什么我不相信类型提示会增加Python代码的可读性。我同意可理解的类型提示增加了代码的可读性。然而，在实践中，我看到的许多类型提示都很难理解。</p><blockquote class="nn no np"><p id="d4e3" class="kz la mw lb b lc ld ju le lf lg jx lh nq lj lk ll nr ln lo lp ns lr ls lt lu im bi translated">我猜想编写清晰代码的程序员可能会使用类型提示来改进它。同样，那些编写不清楚代码的人手中的类型提示甚至会降低代码的可读性。</p></blockquote><p id="dce8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这表明使用有效类型提示的最佳方式是学习如何编写干净的代码。这些技能将使你有能力使用有效和可读的类型提示。</p><p id="3111" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在我结束之前，我想强调我喜欢静态类型。我在C和Go中用过，在Cython中也用过。在所有这三种情况下，我都喜欢使用静态类型，并且认为它很有用。但是我们不能忘记，类型提示不是静态类型；这是两个完全不同的东西，不应该混淆。</p><h1 id="332f" class="lz ma it bd mb mc md me mf mg mh mi mj jz mk ka ml kc mm kd mn kf mo kg mp mq bi translated"><strong class="ak">结论</strong></h1><p id="5cd1" class="pw-post-body-paragraph kz la it lb b lc mr ju le lf ms jx lh li mt lk ll lm mu lo lp lq mv ls lt lu im bi translated">Python的类型暗示不再是一个新概念，但它仍在发展中。我个人的观点是，虽然不是必须的，但是类型提示是有帮助的，有时非常有帮助。但是我害怕将要发生的事情。恐怕我将不得不写<code class="fe lv lw lx ly b">*args: Any, **kwargs: Any</code>而不是<code class="fe lv lw lx ly b">*args, **kwargs,</code>，尽管根据定义，<code class="fe lv lw lx ly b">*args, **kwargs</code>意味着它们可以是任何东西。而且我很害怕，因为我看到越来越多无法理解的类型提示。</p><p id="2e27" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">多年来，Python因其易于理解的语法而被认为是一门伟大的语言。还配得上这个意见吗？你以为初学者会欣赏Python类型提示的可读性；比如上面一些例子中的那些？我担心人们很快会注意到Python不再那么容易了，这完全是由于类型提示，对于初学者来说，这通常是一种障碍而不是支持。</p><p id="cb6a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">以下是我用来让类型提示变得可理解的一些规则:</p><ol class=""><li id="47f4" class="mz na it lb b lc ld lf lg li nb lm nc lq nd lu nu nf ng nh bi translated">使用原始类型提示——也就是说，在签名中直接定义它们——当它们简单且真正易于理解时。当一个参数有一个非常复杂的类型时，你可以(I)简化它的类型提示(例如，<code class="fe lv lw lx ly b">Callable</code>而不是<code class="fe lv lw lx ly b">Callable[Tuple[str, str, int | float], Tuple[str, str]]</code> ), (ii)使用类型别名提示，或者(iii)创建一个你可以用作类型提示的自定义数据结构。(关于(二)和(三)，见下文第2和第3点。)。)</li><li id="22c2" class="mz na it lb b lc ni lf nj li nk lm nl lq nm lu nu nf ng nh bi translated">当您可以使用数据结构(例如，命名的元组、数据类或类)而不是相应的类型提示时，就这样做。这可以归结为您可以在代码中实际使用这种数据结构的情况。</li><li id="a381" class="mz na it lb b lc ni lf nj li nk lm nl lq nm lu nu nf ng nh bi translated">每当您需要复杂类型提示但不需要相应的数据结构时，请定义相应的类型别名(自定义类型)。在函数/方法签名之外进行，并使用有意义的名称。当一个模块或包包含许多类型别名时，你可以把它们放在一个专用的模块中(例如<code class="fe lv lw lx ly b">custom_types.py</code>)。</li><li id="3475" class="mz na it lb b lc ni lf nj li nk lm nl lq nm lu nu nf ng nh bi translated">遵循以上规则会让<code class="fe lv lw lx ly b">mypy</code>不开心。不管这听起来有多有争议，我都不在乎。对我来说，代码可读性比让<code class="fe lv lw lx ly b">mypy</code>开心更重要。</li></ol></div><div class="ab cl nv nw hx nx" role="separator"><span class="ny bw bk nz oa ob"/><span class="ny bw bk nz oa ob"/><span class="ny bw bk nz oa"/></div><div class="im in io ip iq"><p id="be61" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">一切都在我们的掌握之中。Python的声誉岌岌可危。我们可以让类型提示成为一种有用的功能，使Python代码更具可读性。但是如果我们不够小心，如果我们遵循疯狂的多类型提示！-更多类型提示！概念，Python有可能会缓慢但稳步地恶化。十年后(也许早一点或晚一点)，它将成为一种晦涩的编程语言，由于其笨拙的语法，没有人想使用它。</p><p id="e383" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">不过，现在还不算太晚。我们都可以为此做些什么。我们能做的最简单的事情就是明智地使用类型提示。如果你同意我的观点，从现在开始，仔细检查Python代码中的所有类型提示，并修改所有看起来不清楚或不明确的内容。</p><p id="1c34" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">感谢你和我一起参加这个充满争议的讨论。我相信你们很多人不同意我的观点。同时，我希望你们中的一些人同意我的观点，而且，谁知道呢，也许我已经成功地说服了你们中的一些人，我们在使用类型提示时应该小心？我将很高兴听到你的想法，所以请用评论来分享你的想法，不管你同意还是不同意我的观点。</p><h1 id="b0d2" class="lz ma it bd mb mc md me mf mg mh mi mj jz mk ka ml kc mm kd mn kf mo kg mp mq bi translated"><strong class="ak">资源</strong></h1><ul class=""><li id="aef5" class="mz na it lb b lc mr lf ms li oc lm od lq oe lu ne nf ng nh bi translated">拉马尔霍湖(2022年)。流利的Python。清晰、简洁、有效的编程。第二。版本。奥赖利。</li><li id="f5ef" class="mz na it lb b lc ni lf nj li nk lm nl lq nm lu ne nf ng nh bi translated">洛特，S.F. (2018)。函数式Python编程。第二版。包装出版公司。</li><li id="af1d" class="mz na it lb b lc ni lf nj li nk lm nl lq nm lu ne nf ng nh bi translated"><a class="ae ky" href="https://medium.com/@prozeth/dont-be-afraid-of-python-s-type-hints-c3fcb7cda4d9" rel="noopener">https://medium . com/@ prozeth/don ' t-be-fear-of-python-s-type-hints-C3 fcb 7 CD a4 d 9</a></li><li id="7e01" class="mz na it lb b lc ni lf nj li nk lm nl lq nm lu ne nf ng nh bi translated"><a class="ae ky" href="https://medium.com/towards-data-science/exploring-python-type-hints-6520f478b6a" rel="noopener">https://medium . com/forward-data-science/exploring-python-type-hints-6520 f 478 b6a</a></li><li id="7c5d" class="mz na it lb b lc ni lf nj li nk lm nl lq nm lu ne nf ng nh bi translated"><a class="ae ky" href="https://medium.com/towards-data-science/type-hints-in-python-everything-you-need-to-know-in-5-minutes-24e0bad06d0b" rel="noopener">https://medium . com/forward-data-science/type-hints-in-python-everything-you-need-to-know-in-5分钟-24e0bad06d0b </a></li><li id="b4a3" class="mz na it lb b lc ni lf nj li nk lm nl lq nm lu ne nf ng nh bi translated">【https://skeptric.com/python-maybe-monad/ T4】</li><li id="eb48" class="mz na it lb b lc ni lf nj li nk lm nl lq nm lu ne nf ng nh bi translated"><a class="ae ky" href="https://en.wikibooks.org/wiki/Haskell/Understanding_monads/Maybe" rel="noopener ugc nofollow" target="_blank">https://en . wiki books . org/wiki/Haskell/Understanding _ monads/Maybe</a></li></ul></div><div class="ab cl nv nw hx nx" role="separator"><span class="ny bw bk nz oa ob"/><span class="ny bw bk nz oa ob"/><span class="ny bw bk nz oa"/></div><div class="im in io ip iq"><div class="kj kk kl km gt of"><a href="https://medium.com/@nyggus/membership" rel="noopener follow" target="_blank"><div class="og ab fo"><div class="oh ab oi cl cj oj"><h2 class="bd iu gy z fp ok fr fs ol fu fw is bi translated">加入我的介绍链接媒体-马尔钦科萨克</h2><div class="om l"><h3 class="bd b gy z fp ok fr fs ol fu fw dk translated">阅读马尔钦·科萨克(以及媒体上成千上万的其他作家)的每一个故事。您的会员费直接支持…</h3></div><div class="on l"><p class="bd b dl z fp ok fr fs ol fu fw dk translated">medium.com</p></div></div><div class="oo l"><div class="op l oq or os oo ot ks of"/></div></div></a></div></div></div>    
</body>
</html>