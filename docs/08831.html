<html>
<head>
<title>What’s New in UITableView and UICollectionView for iOS 15?</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">iOS 15的UITableView和UICollectionView有什么新功能？</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/table-and-collection-view-cell-reload-improvements-in-ios-15-52de0b56a76e?source=collection_archive---------8-----------------------#2021-06-16">https://betterprogramming.pub/table-and-collection-view-cell-reload-improvements-in-ios-15-52de0b56a76e?source=collection_archive---------8-----------------------#2021-06-16</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="999e" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">重新加载的改进很有希望，但是在值类型模型对象上使用它们时有一个问题</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/21f26d3d7de80d147efe1689d154bf24.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*yUREteoXXYguGTXm"/></div></div></figure><p id="2b1e" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">2020年10月，我发表了一篇<a class="ae lq" href="https://swiftsenpai.com/development/modern-ways-reload-cells/" rel="noopener ugc nofollow" target="_blank">文章</a>，讨论了在使用不同的数据源时如何重新加载表和集合视图单元格。本文向您展示了在用引用类型和值类型的项重新加载单元格时，如何使用两种完全不同的方法。</p><p id="176f" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">概括地说，对于引用类型的项目，我们可以利用快照的<code class="fe lr ls lt lu b">reloadItems(_:)</code>方法来重新加载指定的项目。对于值类型项目，<code class="fe lr ls lt lu b">reloadItems(_:)</code>不起作用。我们必须手动替换快照中更新的项目。</p><p id="bf8d" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">我一直很困惑为什么苹果会把这么简单的任务变得这么复杂。在WWDC21上，苹果向我们展示了另一种方法，这种方法使得使用单一方式重新加载单元格成为可能。最重要的是，苹果还在iOS 15中引入了新的API，允许我们更有效地重新加载单元格。</p><p id="8ee7" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">这些都是非常有趣的变化和改进，所以让我们开始吧！</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="5804" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">示例应用程序</h1><p id="95c5" class="pw-post-body-paragraph ku kv it kw b kx mu ju kz la mv jx lc ld mw lf lg lh mx lj lk ll my ln lo lp im bi translated">出于演示目的，让我们更新我为上一篇文章创建的示例应用程序。它是一个超级英雄评级应用程序。每当用户点击一个单元格，一个星号(★)就会被附加在英雄的名字后面。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi mz"><img src="../Images/777c5932b326402c54514d778a699b77.png" data-original-src="https://miro.medium.com/v2/resize:fit:1124/0*8aTs7TpXO-8Mverq"/></div><p class="na nb gj gh gi nc nd bd b be z dk translated">示例应用程序</p></figure><p id="64c4" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">以下是集合视图的数据源和模型对象数组的定义:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ne nf l"/></div></figure></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="a4a1" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">重新加载引用类型项目</h1><p id="961e" class="pw-post-body-paragraph ku kv it kw b kx mu ju kz la mv jx lc ld mw lf lg lh mx lj lk ll my ln lo lp im bi translated">在iOS 15之前，我们可以使用快照的<code class="fe lr ls lt lu b">reloadItems(_:)</code>方法来重新加载引用类型项目的单元格，如下所示:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ne nf l"/></div></figure><p id="3bbc" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">在iOS 15中，苹果引入了一种新的<code class="fe lr ls lt lu b"><a class="ae lq" href="https://developer.apple.com/documentation/uikit/nsdiffabledatasourcesnapshot/3804468-reconfigureitems" rel="noopener ugc nofollow" target="_blank">reconfigureItems(_:)</a></code>快照方法，可以帮助开发者更有效地重新加载单元格。要使用它，我们可以简单地用<code class="fe lr ls lt lu b">reconfigureItems(_:)</code>方法替换<code class="fe lr ls lt lu b">reloadItems(_:)</code>方法:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ne nf l"/></div></figure><p id="8e59" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">正如你从下面的动画GIF中看到的，当我试图快速点击同一个单元格时，iOS 15中的单元格(使用<code class="fe lr ls lt lu b">reconfigureItems(_:)</code>)重新加载的速度比iOS 14中的单元格(使用<code class="fe lr ls lt lu b">reloadItems(_:)</code>)快得多:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ng"><img src="../Images/1b90944efb1a035cf6c225ffb8c407eb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1200/0*xyRl2KG24sPoOsKc"/></div></div><p class="na nb gj gh gi nc nd bd b be z dk translated">reload items(_:)vs reconfigure items(_:)</p></figure><p id="04ad" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">这一改进背后的原因是<code class="fe lr ls lt lu b">reconfigureItems(_:)</code>重用了项目的现有单元，而不是退出队列并配置一个新单元。因此，从iOS 15开始，开发者应该总是使用<code class="fe lr ls lt lu b">reconfigureItems(_:)</code>而不是<code class="fe lr ls lt lu b">reloadItems(_:)</code>，除非你明确需要用新单元替换现有单元。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="affb" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">重新加载值类型项目</h1><p id="1f04" class="pw-post-body-paragraph ku kv it kw b kx mu ju kz la mv jx lc ld mw lf lg lh mx lj lk ll my ln lo lp im bi translated">如前所述，<code class="fe lr ls lt lu b">reloadItems(_:)</code>方法不适用于值类型项目。但是<code class="fe lr ls lt lu b">reconfigureItems(_:)</code>怎么样？它对值类型的项目有效吗？不幸的是，答案是否定的。你会得到一个<code class="fe lr ls lt lu b">NSInternalInconsistencyException</code>异常，并显示“为重新加载指定的无效项目标识符”消息，就像在iOS 14中一样。</p><p id="e37e" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">然而，在今年的WWDC上，苹果向我们展示了使用不同数据源的另一种方法，这使得在值类型项目上使用<code class="fe lr ls lt lu b">reconfigureItems(_:)</code>成为可能。关键是使用模型对象的标识符作为数据源项标识符，而不是模型对象本身。</p><blockquote class="nh"><p id="449d" class="ni nj it bd nk nl nm nn no np nq lp dk translated"><em class="nr">“不同的数据源是为了存储模型中的项目标识符而构建的，而不是模型对象本身。”——</em><a class="ae lq" href="https://developer.apple.com/videos/play/wwdc2021/10252/" rel="noopener ugc nofollow" target="_blank"><em class="nr">苹果开发者</em> </a></p></blockquote><p id="f746" class="pw-post-body-paragraph ku kv it kw b kx ns ju kz la nt jx lc ld nu lf lg lh nv lj lk ll nw ln lo lp im bi translated">这与我们对如何使用不同数据源的理解有些冲突。</p><p id="b276" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">但是现在，让我们把它放在一边，探索我们能做些什么来实现它。</p><h2 id="593b" class="nx md it bd me ny nz dn mi oa ob dp mm ld oc od mo lh oe of mq ll og oh ms oi bi translated">使用模型标识符作为不同的数据源项标识符</h2><p id="a858" class="pw-post-body-paragraph ku kv it kw b kx mu ju kz la mv jx lc ld mw lf lg lh mx lj lk ll my ln lo lp im bi translated">我们需要做的第一件事是给我们的<code class="fe lr ls lt lu b">SuperHero</code>结构添加一个惟一的、不可变的标识符。我们将标识符命名为<code class="fe lr ls lt lu b">id</code>，并使用超级英雄的名字作为标识符。</p><p id="eb2f" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">由于我们现在使用<code class="fe lr ls lt lu b">id</code>作为我们的数据源项标识符，我们还需要将我们的数据源项标识符类型从<code class="fe lr ls lt lu b">SuperHero</code>更改为<code class="fe lr ls lt lu b">String</code>。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ne nf l"/></div></figure><p id="ecf4" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">接下来，我们必须声明一个字典，并使用它来保存标识符和它们对应的<code class="fe lr ls lt lu b">SuperHero</code>对象。我们需要这个字典，这样我们就可以使用<code class="fe lr ls lt lu b">id</code>轻松获得<code class="fe lr ls lt lu b">SuperHero</code>对象，而不必遍历<code class="fe lr ls lt lu b">heroArray</code>。</p><pre class="kj kk kl km gt oj lu ok ol aw om bi"><span id="ae8d" class="nx md it lu b gy on oo l op oq">var heroDictionary = [String: Superhero]()</span></pre><p id="4795" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">为了填充<code class="fe lr ls lt lu b">heroDictionary</code>，我们可以利用<code class="fe lr ls lt lu b">Dictionary(uniqueKeysWithValues:)</code>初始化器来帮助我们将<code class="fe lr ls lt lu b">[SuperHero]</code>转换为<code class="fe lr ls lt lu b">[(String, SuperHero)]</code>，然后再转换为<code class="fe lr ls lt lu b">[String: SuperHero]</code>。方法如下:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ne nf l"/></div></figure><p id="c54e" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">在<code class="fe lr ls lt lu b">heroDictionary</code>就位后，我们现在可以将单元注册项目类型从<code class="fe lr ls lt lu b">SuperHero</code>更改为<code class="fe lr ls lt lu b">String</code>。最重要的是，我们还需要对单元注册处理器进行调整，因为它现在提供的是<code class="fe lr ls lt lu b">id</code>而不是模型对象。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ne nf l"/></div></figure><p id="81c7" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">在单元注册处理程序中，注意我如何使用<code class="fe lr ls lt lu b">heroDictionary</code>来获得相应的超级英雄名字。</p><p id="6185" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">难题的最后一部分是更新我们如何填充数据源快照。我们现在需要将模型对象id附加到快照，而不是将模型对象添加到快照。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ne nf l"/></div></figure><p id="ce9b" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">至此，我们已经成功地将示例应用程序转换为使用模型对象的标识符作为数据源项标识符。</p><h2 id="01ca" class="nx md it bd me ny nz dn mi oa ob dp mm ld oc od mo lh oe of mq ll og oh ms oi bi translated">使用reconfigureItems()更新单元</h2><p id="f27e" class="pw-post-body-paragraph ku kv it kw b kx mu ju kz la mv jx lc ld mw lf lg lh mx lj lk ll my ln lo lp im bi translated">有了新的数据源，更新值类型项的单元格的方法与更新引用类型项的方法非常相似。唯一的区别是数据源给了我们<code class="fe lr ls lt lu b">id</code>而不是模型对象。因此，我们必须使用<code class="fe lr ls lt lu b">heroDictionary</code>来获得选中的英雄，并相应地更新它。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ne nf l"/></div></figure><p id="9974" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">就是这样！我们现在可以享受<code class="fe lr ls lt lu b">reconfigureItems()</code>带来的性能提升，即使我们使用的是价值型物品。</p><p id="7adf" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated"><em class="or">注意:ID作为数据源项标识符的方法不仅适用于值类型项。它也适用于引用类型的项目。</em></p><p id="53f1" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">下面是完整的示例代码:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ne nf l"/></div></figure></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="f1a3" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">我们一直以来都用错了吗？</h1><p id="a6ce" class="pw-post-body-paragraph ku kv it kw b kx mu ju kz la mv jx lc ld mw lf lg lh mx lj lk ll my ln lo lp im bi translated">通过使用ID作为数据源项标识符，我们现在能够使用<code class="fe lr ls lt lu b">reconfigureItems(_:)</code>来更新值类型和引用类型的项。这让我想知道我们是否可以应用同样的改变，让<code class="fe lr ls lt lu b">reloadItems(_:)</code>在iOS 14中同时适用于值类型和引用类型的项目？</p><p id="d2e8" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">显然，答案是肯定的！</p><p id="b28c" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">如果是这样，这是否意味着我们一直以来都在错误地使用不同的数据源？</p><p id="32a7" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">嗯，我不确定。</p><p id="721f" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">既然Apple声明我们应该只在diffable数据源中存储标识符，我想我们应该从现在开始停止使用模型对象作为项目标识符。另一方面，我也看不出使用模型对象作为项目标识符有什么问题。事实上，这篇<a class="ae lq" href="https://swiftsenpai.com/development/modern-ways-reload-cells/" rel="noopener ugc nofollow" target="_blank">文章</a>中介绍的旧的单元重载方法在iOS 15中仍然非常好用。</p><p id="e8d5" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">因此，我对此的看法是，让我现有的所有不同数据源保持原样，并开始采用苹果公司为任何未来实现推荐的新方法。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="a37a" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">包扎</h1><p id="51b5" class="pw-post-body-paragraph ku kv it kw b kx mu ju kz la mv jx lc ld mw lf lg lh mx lj lk ll my ln lo lp im bi translated"><code class="fe lr ls lt lu b">reconfigureItems(_:)</code>方法只是苹果对不同数据源所做的许多改进之一。要了解更多信息，我建议查看<a class="ae lq" href="https://developer.apple.com/videos/play/wwdc2021/10252/" rel="noopener ugc nofollow" target="_blank">这个</a> WWDC21视频以及演示文稿附带的<a class="ae lq" href="https://developer.apple.com/documentation/uikit/uiimage/building_high-performance_lists_and_collection_views" rel="noopener ugc nofollow" target="_blank">样本代码</a>。</p><p id="0633" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">如果你喜欢读这篇文章，请随意查看我的其他iOS开发相关的<a class="ae lq" href="https://swiftsenpai.com/tag/ios/" rel="noopener ugc nofollow" target="_blank">文章</a>。</p><p id="8e9b" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">感谢阅读。</p><p id="bb65" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated"><em class="or">本文原载于2021年6月16日https://swiftsenpai.com</em><a class="ae lq" href="https://swiftsenpai.com/development/cells-reload-improvements-ios-15/" rel="noopener ugc nofollow" target="_blank"><em class="or"/></a><em class="or">。</em></p></div></div>    
</body>
</html>