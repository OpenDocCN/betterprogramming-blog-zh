<html>
<head>
<title>10 Easy Steps To Abandon Redux for the Remarkable React Hooks</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">放弃Redux的10个简单步骤</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/10-easy-steps-to-abandon-redux-for-the-remarkable-react-hooks-124916fc634d?source=collection_archive---------3-----------------------#2021-08-03">https://betterprogramming.pub/10-easy-steps-to-abandon-redux-for-the-remarkable-react-hooks-124916fc634d?source=collection_archive---------3-----------------------#2021-08-03</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="fed0" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">使用React钩子进行全局状态管理的简单指南</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/f9b7be93974058b8264341d7a9ea590b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*kVmzvYjSE1sQb6Y5ekncdQ.jpeg"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">作者原创作品。</p></figure><p id="02cb" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">如果您正在开发React应用程序，管理全局状态和访问后端的最简单方法是通过React钩子。</p><p id="920c" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">尽管自从钩子在React 16.8中发布以来，已经有很多关于它们的文章，但实际上很难找到一本指南来很好地解释如何利用它们来构建应用程序。</p><p id="f15c" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">我会给你一个最好的可扩展的方法来管理你的应用程序之间的数据共享，并通过React钩子与你的后端API一起工作，我在我所有的React应用程序中都使用了React钩子。</p><p id="f2a5" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">如果您已经熟悉Redux，那么我的解决方案应该非常相似，只有一些小的不同。我们将为全球范围开发简单的中间件，我们将用<a class="ae lu" href="https://www.npmjs.com/package/axios" rel="noopener ugc nofollow" target="_blank"> axios </a>管理所有API调用。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="lv lw l"/></div></figure><h1 id="adeb" class="lx ly it bd lz ma mb mc md me mf mg mh jz mi ka mj kc mk kd ml kf mm kg mn mo bi translated">最终API:保持组件的干净和简单</h1><p id="c0fa" class="pw-post-body-paragraph ky kz it la b lb mp ju ld le mq jx lg lh mr lj lk ll ms ln lo lp mt lr ls lt im bi translated">我们希望应用程序中的React组件能够触发操作，例如更新数据，并且我们还希望它们能够对这些操作的结果或全局状态的任何其他更改做出反应。</p><p id="b9b5" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">我们将通过使用上下文挂钩来实现这个目标，它将使我们的组件看起来像这样:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mu lw l"/></div></figure><p id="8ded" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">注意，我们正在从上下文钩子<code class="fe mv mw mx my b">useContext</code>加载<code class="fe mv mw mx my b">state</code>和<code class="fe mv mw mx my b">actions</code>。通过这种方式，我们可以全局地访问我们的所有状态和操作，并且我们遵循关注点分离原则，因为数据存储、数据操作和数据表示都是分开处理的。</p><p id="aacd" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">如果任何动作触发了对全局状态的更新，所有组件都会立即知道，而无需添加任何额外的逻辑。</p><p id="6a85" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">别忘了，写聪明的代码，构建聪明的架构，会让你变得聪明伶俐。</p><h1 id="3463" class="lx ly it bd lz ma mb mc md me mf mg mh jz mi ka mj kc mk kd ml kf mm kg mn mo bi translated">示例:报价Web应用程序</h1><p id="d42a" class="pw-post-body-paragraph ky kz it la b lb mp ju ld le mq jx lg lh mr lj lk ll ms ln lo lp mt lr ls lt im bi translated">为了更有趣，我们还将构建一个可部署到<a class="ae lu" href="https://www.netlify.com/" rel="noopener ugc nofollow" target="_blank"> Netlify </a>的完整应用程序。你可以看到<strong class="la iu">最终产品工作</strong>这里:<br/><a class="ae lu" href="https://quotes.meet-martin.com/" rel="noopener ugc nofollow" target="_blank">https://quotes.meet-martin.com/</a>。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi mz"><img src="../Images/3fd117871f780745a9aaf54d70845c51.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*6QXzYD3KJIURCsi2x8pUsA.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated"><a class="ae lu" href="https://quotes.meet-martin.com/" rel="noopener ugc nofollow" target="_blank">https://quotes.meet-martin.com/</a></p></figure><p id="72a6" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">这是一个简单的应用程序，它有一个名人语录列表，并使用全局状态管理来接收和显示语录和背景颜色的随机组合。</p><p id="42ab" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">它甚至引用了华特·迪士尼的一些话，没有哪个糟糕的网站会引用华特·迪士尼的话，所以它一定很神奇。</p><p id="158d" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">你可以在这里找到<strong class="la iu">完整的GitHub库</strong>:https://github.com/MeetMartin/quotes<a class="ae lu" href="https://github.com/MeetMartin/quotes" rel="noopener ugc nofollow" target="_blank"/>。</p><p id="0ec7" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">一旦你完成这篇文章，你就可以自己去发现如何通过在GitHub上创建一个pull请求来添加更多的报价，并将它们添加到网站上。</p><h1 id="ee77" class="lx ly it bd lz ma mb mc md me mf mg mh jz mi ka mj kc mk kd ml kf mm kg mn mo bi translated">为什么是全局状态管理？</h1><p id="ced8" class="pw-post-body-paragraph ky kz it la b lb mp ju ld le mq jx lg lh mr lj lk ll ms ln lo lp mt lr ls lt im bi translated">如果不使用全局状态管理系统，您的应用程序很快就会出现规模问题。如果您的组件想要将信息传递给其他组件，您需要找到自己的方式来构建它。</p><p id="20a4" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">如果不分离关注点，您的组件将直接访问如下API:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mu lw l"/></div></figure><p id="0965" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">这种方法限制了组件的可重用性，因为它依赖于获取数据的特定方式。如果不将代码复制粘贴到其他组件中，您也无法重用获取数据的方式。或者，您需要找到某种方法，与需要它的其他组件共享相同的数据。</p><p id="2f5a" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">只有邪恶的软件架构师才会让你编写这样的代码。</p><h1 id="3a5e" class="lx ly it bd lz ma mb mc md me mf mg mh jz mi ka mj kc mk kd ml kf mm kg mn mo bi translated">应用架构</h1><p id="96cf" class="pw-post-body-paragraph ky kz it la b lb mp ju ld le mq jx lg lh mr lj lk ll ms ln lo lp mt lr ls lt im bi translated">这是全球范围管理的架构，如果你曾经使用过<a class="ae lu" href="https://react-redux.js.org/" rel="noopener ugc nofollow" target="_blank"> Redux </a>的话，应该已经很熟悉了。</p><p id="572c" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">正如您在第一个示例中看到的，React组件可以从所有组件和页面共享的存储中访问全局状态。</p><p id="57f0" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">当您在组件中触发一个动作时，它将通过一个中间件将其传递给reducer，同时触发一个钩子，该钩子可以执行对某个外部API的调用。</p><p id="0f2b" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">然后，Reducers负责更新存储，所有状态更新会立即传播到所有组件。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi na"><img src="../Images/4b90890b7ed6abb4c487b2d5e24aa6aa.png" data-original-src="https://miro.medium.com/v2/resize:fit:1374/format:webp/1*wgRN7VcdPwEfoYVRjq958Q.png"/></div></figure><p id="a563" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">这将在代码中导致该存储目录的文件结构:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nb"><img src="../Images/3450e897bfd8085134c3cdabd4a0b3ad.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*waV0t4KfyCYUZvXn72cJvw.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">全局存储文件</p></figure><p id="046d" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">是不是很美？这么多文件和代码需要我们分析！</p><p id="364c" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">这样做的目的是，您可以在所有应用程序中实际使用这些文件作为模板。我在这里描述了它们，这样你就知道它们是做什么的，它们是如何工作的，以及在哪里插入你自己的创造性代码来使所有的东西都很好地一起工作。</p><h1 id="036f" class="lx ly it bd lz ma mb mc md me mf mg mh jz mi ka mj kc mk kd ml kf mm kg mn mo bi translated">从定义类型开始</h1><p id="dba1" class="pw-post-body-paragraph ky kz it la b lb mp ju ld le mq jx lg lh mr lj lk ll ms ln lo lp mt lr ls lt im bi translated">我们的动作和中间件通过分派类型和数据来更新存储。类型是它们和更新存储的reducer之间的连接。我们想要做的每一个数据操作都需要有一个定义好的类型。</p><p id="f9fb" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">当您想通过添加更多操作来扩展应用程序时，这是您通常要编辑的第一个文件。</p><p id="c3a1" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">在我们的应用程序中，我们只有两种类型:<code class="fe mv mw mx my b">REQUEST_RANDOM_QUOTE</code>和<code class="fe mv mw mx my b">RECEIVE_RANDOM_QUOTE</code>。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mu lw l"/></div></figure><p id="bf3b" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated"><code class="fe mv mw mx my b">REQUEST_RANDOM_QUOTE</code>是我们的页面如何让中间件知道它想要请求一个随机报价，而<code class="fe mv mw mx my b">RECEIVE_RANDOM_QUOTE</code>是中间件如何让reducer知道它有一个新报价。</p><p id="dce7" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">我们使用这种方法是因为当我们将actions和reducers联系在一起时，它可以帮助我们避免输入错误。然而，如果你愿意，你可以忽略它，在你的应用程序中只使用<code class="fe mv mw mx my b">RECEIVE_RANDOM_QUOTE</code>作为一个字符串，而不使用类型文件。反正都是字符串。</p><p id="72c7" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">一个聪明的开发人员会使用类型文件，因为其他人都在使用它，其他人不会错。</p><p id="bca7" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">为您的类型决定一个好的命名约定也是非常重要的。在简单的应用程序中，我通常使用请求/接收，在更复杂的应用程序中，我使用CRUD(创建/读取/读取_全部/更新/删除)。</p><h1 id="1cf3" class="lx ly it bd lz ma mb mc md me mf mg mh jz mi ka mj kc mk kd ml kf mm kg mn mo bi translated">组件可用的操作</h1><p id="d697" class="pw-post-body-paragraph ky kz it la b lb mp ju ld le mq jx lg lh mr lj lk ll ms ln lo lp mt lr ls lt im bi translated">动作是你的组件如何触发变化并将数据传递给中间件和reducer。</p><p id="fd74" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">我们的应用程序将只需要一个动作——<code class="fe mv mw mx my b">requestRandomQuote</code>——它的名称创建了与类型<code class="fe mv mw mx my b">REQUEST_RANDOM_QUOTE</code>的明确连接。</p><p id="02ed" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">我们的主页将触发该操作，让中间件知道它需要一个新的随机报价:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mu lw l"/></div></figure><p id="6518" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">如果没有有效载荷，我们可以稍后通过简单地调用<code class="fe mv mw mx my b">actions.requestRandomQuote();</code>来使用这个动作。</p><p id="db4f" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">如果我们想传递一些数据，我们也可以实现额外的动作来调用<code class="fe mv mw mx my b">actions.requestRandomQuoteFrom('Einstein');</code>。</p><p id="ffd2" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">您提供的任何有效负载对我们的中间件和缩减器都是可用的。</p><p id="add0" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">请注意，我们不需要在actions.js中创建动作<code class="fe mv mw mx my b">receiveRandomQuote</code>，这是因为我们希望类型<code class="fe mv mw mx my b">RECEIVE_RANDOM_QUOTE</code>由中间件分派，而不是由我们的任何组件分派。</p><p id="ff1d" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">我们主要创建抽象的动作，这样组件就不需要直接处理调度调用。</p><h1 id="1a97" class="lx ly it bd lz ma mb mc md me mf mg mh jz mi ka mj kc mk kd ml kf mm kg mn mo bi translated">更新商店的减速器</h1><p id="f441" class="pw-post-body-paragraph ky kz it la b lb mp ju ld le mq jx lg lh mr lj lk ll ms ln lo lp mt lr ls lt im bi translated">我们的系统通过向reducer发送数据来更新存储中的全局状态。reducer使用我们之前在交换机中定义的类型来更新状态。</p><p id="42ff" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">你会发现减压器实际上很容易使用。相信我，我是个工程师。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mu lw l"/></div></figure><p id="f96f" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">常量<code class="fe mv mw mx my b">initialState</code>具有我们的应用程序的开始状态。</p><p id="e8b0" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">我们使用<code class="fe mv mw mx my b">console.debug</code>以便在你的应用程序中，你可以看到每次减速器达到。对于我们在<a class="ae lu" href="https://quotes.meet-martin.com/" rel="noopener ugc nofollow" target="_blank">https://quotes.meet-martin.com/</a>上的实时应用程序也是如此。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nc"><img src="../Images/6e6abe22627b4867f7cd16e4345e643c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*5x_7woSePHUlAvo-h636gw.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">Chrome浏览器中的控制台检查器。</p></figure><p id="5278" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">无论您在中间件中采取什么操作，每次都会到达Reducer。由于<code class="fe mv mw mx my b">switch</code>上的<code class="fe mv mw mx my b">default</code>，如果我们打算只触发中间件，我们不必总是更新状态。这就是为什么我们在<code class="fe mv mw mx my b">RECEIVE_RANDOM_QUOTE</code>上改变状态，但我们不对<code class="fe mv mw mx my b">switch</code>中缺失的<code class="fe mv mw mx my b">REQUEST_RANDOM_QUOTE</code>采取任何行动。</p><p id="6aa6" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">我们也在函数式编程领域，所以你可以注意到我们的开关总是返回一个新的状态，而不是编辑原来的状态。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mu lw l"/></div></figure><p id="b001" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">一旦返回新状态，所有读取任何更改值的组件都会被告知状态的更改。神奇！</p><p id="0338" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">当您添加一点函数式编程的魔力时，每段代码都会变得更好。</p><h1 id="ea55" class="lx ly it bd lz ma mb mc md me mf mg mh jz mi ka mj kc mk kd ml kf mm kg mn mo bi translated">联系您的API的中间件</h1><p id="ba44" class="pw-post-body-paragraph ky kz it la b lb mp ju ld le mq jx lg lh mr lj lk ll ms ln lo lp mt lr ls lt im bi translated">中间件捕捉组件中触发的每一个动作，与reducers类似，它使用动作的类型来触发自己的挂钩，这些挂钩可以联系您的后端API。</p><p id="7d2c" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">为了实现中间件，我们将开始使用函数式编程库<a class="ae lu" href="https://www.7urtle.com/" rel="noopener ugc nofollow" target="_blank">@ 7 urtle/lambda(www.7urtle.com)</a>。在函数式编程中，使用外部API被认为是一种副作用，我们将使用monads来处理这些副作用，同时保持您的函数纯净。</p><p id="a153" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">如果你不理解单子或者不太熟悉函数式编程，也不用担心。代码非常简单，您可以用任何一种方式使用它，或者用您自己的命令式解决方案替换它。然而，如果你想了解更多关于单子的知识，看看JavaScript中的<a class="ae lu" href="https://www.7urtle.com/javascript-applicative-functor-monads" rel="noopener ugc nofollow" target="_blank">用单子管理副作用</a>。</p><p id="327b" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">这才是真正有趣的地方。</p><h1 id="c9b6" class="lx ly it bd lz ma mb mc md me mf mg mh jz mi ka mj kc mk kd ml kf mm kg mn mo bi translated">模拟报价效果以获得随机报价</h1><p id="d47b" class="pw-post-body-paragraph ky kz it la b lb mp ju ld le mq jx lg lh mr lj lk ll ms ln lo lp mt lr ls lt im bi translated">一会儿我们将展示对一个网络函数的真正请求是什么样子的。现在，我们将编写一个简单的代码，模拟执行服务器请求的情况，但实际上，它只是通过使用超时延迟一秒钟来实现异步。</p><p id="05a2" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">我们将需要两个函数:<code class="fe mv mw mx my b">getRandomQuote</code>在它的输入数组中找到一个随机引用，而<code class="fe mv mw mx my b">requestQuote</code>将返回我们的结果。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mu lw l"/></div></figure><p id="d3a7" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">我们的函数<code class="fe mv mw mx my b">requestQuote</code>返回<a class="ae lu" href="https://www.7urtle.com/documentation-7urtle-lambda#lambda-AsyncEffect" rel="noopener ugc nofollow" target="_blank"> AsyncEffect </a>，这是一个具有惰性求值的单子，可以处理异步副作用。它还返回另一个单子<code class="fe mv mw mx my b">Maybe</code>，其中可能包含随机引用的结果。</p><h1 id="bed4" class="lx ly it bd lz ma mb mc md me mf mg mh jz mi ka mj kc mk kd ml kf mm kg mn mo bi translated">真实报价获得随机报价的效果</h1><p id="e8c8" class="pw-post-body-paragraph ky kz it la b lb mp ju ld le mq jx lg lh mr lj lk ll ms ln lo lp mt lr ls lt im bi translated">在我们的场景中，这可能是对一个<a class="ae lu" href="https://www.netlify.com/products/functions/" rel="noopener ugc nofollow" target="_blank"> Netlify函数</a>的请求。Netlify functions是一个处理服务器后端的简化的AWS Lambda。</p><p id="f6b5" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">我们的代码如下所示:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mu lw l"/></div></figure><p id="001b" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">你可以看到我用例子添加了很长的注释，但是代码本身非常短。</p><p id="4b76" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">我们的<code class="fe mv mw mx my b">getQuoteFromNetlify</code>是一般<code class="fe mv mw mx my b">postToFunction</code>的<a class="ae lu" rel="noopener ugc nofollow" target="_blank" href="/5-easy-steps-to-master-currying-and-higher-order-functions-in-javascript-85e2a7e2c268">功能部分应用</a>。<code class="fe mv mw mx my b">postToFunction</code>再次返回<a class="ae lu" href="https://www.7urtle.com/documentation-7urtle-lambda#lambda-AsyncEffect" rel="noopener ugc nofollow" target="_blank"> AsyncEffect </a>持有<a class="ae lu" href="https://www.7urtle.com/documentation-7urtle-lambda#lambda-Maybe" rel="noopener ugc nofollow" target="_blank">可能</a>的结果数据。当我们转到为我们的效果提供逻辑的<code class="fe mv mw mx my b">QuoteHook.js</code>时，我们将会看到这些是如何使用的。</p><p id="aefe" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">关于这两个单子，需要记住的重要一点是,<a class="ae lu" href="https://www.7urtle.com/documentation-7urtle-lambda#lambda-AsyncEffect" rel="noopener ugc nofollow" target="_blank">asynce effect</a>类似于JavaScript Promise，但是在您调用它的方法trigger之前，它不会被求值。因此，作为<code class="fe mv mw mx my b">postToFunction</code>的一部分，实际上还没有执行服务器调用，这保持了我们函数的纯净。</p><p id="4fcb" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated"><a class="ae lu" href="https://www.7urtle.com/documentation-7urtle-lambda#lambda-Maybe" rel="noopener ugc nofollow" target="_blank">也许</a>是一个单子，当你不能确定你实际上收到了一个值时使用。<code class="fe mv mw mx my b">Maybe</code>表示可能有值(是<code class="fe mv mw mx my b">Just</code>)或者没有值(是<code class="fe mv mw mx my b">Nothing</code>)。这允许我们用一种非常健壮和简单的方式来处理可能的错误状态和问题。</p><p id="af0d" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">如果您正在使用Netlify函数，您也可以通过调用<code class="fe mv mw mx my b">postToFunction</code>轻松创建自己的效果。</p><pre class="kj kk kl km gt nd my ne nf aw ng bi"><span id="b055" class="nh ly it my b gy ni nj l nk nl">export const myFunction = callToFunction('/your-function-path');</span></pre><p id="9022" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">如果你使用其他东西，这两个单子在<a class="ae lu" href="https://www.7urtle.com/documentation-7urtle-lambda" rel="noopener ugc nofollow" target="_blank"> @7urtle/lambda文档</a>中都有很好的记录。</p><h1 id="70e0" class="lx ly it bd lz ma mb mc md me mf mg mh jz mi ka mj kc mk kd ml kf mm kg mn mo bi translated">钩子来调用和处理我们的效果</h1><p id="42cc" class="pw-post-body-paragraph ky kz it la b lb mp ju ld le mq jx lg lh mr lj lk ll ms ln lo lp mt lr ls lt im bi translated">下一步是创建一个钩子来调用和处理我们的效果函数。相同的代码将使用mock或Netlify函数来处理这两种方法中的任何一种。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mu lw l"/></div></figure><p id="e96c" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">感谢函数式编程的魔力，我们又只需要几行代码了。我们的<code class="fe mv mw mx my b">getQuote</code>从我们的效果中调用<code class="fe mv mw mx my b">requestQuote</code>或<code class="fe mv mw mx my b">getQuoteFromNetlify</code>。它触发返回的<code class="fe mv mw mx my b">AsyncEffect</code>并记录错误或调用<code class="fe mv mw mx my b">dispatch</code>通过我们之前编写的缩减器将数据传递给全局状态。</p><p id="0b39" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated"><code class="fe mv mw mx my b">AsyncEffect</code>处理与<code class="fe mv mw mx my b">axios</code>调用相关的问题，从随机代码错误到服务器响应500或400个问题。而<code class="fe mv mw mx my b">Maybe</code>是通过<a class="ae lu" href="https://www.7urtle.com/documentation-7urtle-lambda#lambda-maybe" rel="noopener ugc nofollow" target="_blank">可能是</a>函数(小写的‘m’)来处理的，这个函数允许我们处理不返回数据的服务器。</p><p id="6c80" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">这里不需要额外的逻辑。如果你愿意，你也可以通知错误的全局状态，并在你的代码中使用<code class="fe mv mw mx my b">dispatch</code>而不是<code class="fe mv mw mx my b">console.error</code>。</p><h1 id="7322" class="lx ly it bd lz ma mb mc md me mf mg mh jz mi ka mj kc mk kd ml kf mm kg mn mo bi translated">将一切联系在一起的实际中间件</h1><p id="cb69" class="pw-post-body-paragraph ky kz it la b lb mp ju ld le mq jx lg lh mr lj lk ll ms ln lo lp mt lr ls lt im bi translated">实际的中间件文件类似于我们的reducer。它使用一个开关来检查被调用的类型，并在此基础上调用我们之前声明的钩子。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mu lw l"/></div></figure><p id="b7b8" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">中间件总是为每个<code class="fe mv mw mx my b">action</code>(而不是<code class="fe mv mw mx my b">dispatch</code>)调用，如果你不需要调用任何钩子，你可以忽略类型，它会很高兴地继续到缩减器。</p><p id="5c35" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">出于调试目的，我们再次将<code class="fe mv mw mx my b">console.debug</code>添加到代码中，这样您就可以看到应用程序中发生了什么。</p><h1 id="30c2" class="lx ly it bd lz ma mb mc md me mf mg mh jz mi ka mj kc mk kd ml kf mm kg mn mo bi translated">StoreContext为组件提供状态和动作</h1><p id="c8eb" class="pw-post-body-paragraph ky kz it la b lb mp ju ld le mq jx lg lh mr lj lk ll ms ln lo lp mt lr ls lt im bi translated">我们需要创建的最后一个文件是<code class="fe mv mw mx my b">StoreContext.js</code>，它为我们的应用程序提供了全局状态管理。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mu lw l"/></div></figure><p id="320d" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">您实际上并不需要编辑这个文件，所以您可以自由地让它保持原样。</p><p id="6644" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">它还包含另一个<code class="fe mv mw mx my b">console.debug</code>,每次它改变时都会记录一个新的状态，以便于您检查。</p><h1 id="7e2e" class="lx ly it bd lz ma mb mc md me mf mg mh jz mi ka mj kc mk kd ml kf mm kg mn mo bi translated">将全局状态管理添加到App.js</h1><p id="0090" class="pw-post-body-paragraph ky kz it la b lb mp ju ld le mq jx lg lh mr lj lk ll ms ln lo lp mt lr ls lt im bi translated">这就是你的应用。现在你只需要把你的<code class="fe mv mw mx my b">StoreContext</code>加到<code class="fe mv mw mx my b">App.js</code>上。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mu lw l"/></div></figure><p id="dfac" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated"><code class="fe mv mw mx my b">StoreProvider</code>只是作为一个组件添加。这使得里面的任何东西都可以使用它。在我们的简单应用程序中，它只是<code class="fe mv mw mx my b">HomePage</code>，但是在一个更大的解决方案中，您可以将它放在React路由器上。</p><h1 id="7e39" class="lx ly it bd lz ma mb mc md me mf mg mh jz mi ka mj kc mk kd ml kf mm kg mn mo bi translated">主页</h1><p id="2c69" class="pw-post-body-paragraph ky kz it la b lb mp ju ld le mq jx lg lh mr lj lk ll ms ln lo lp mt lr ls lt im bi translated">我们的单页应用程序使用<code class="fe mv mw mx my b">HomePage</code>来读取当前报价，并以十秒钟的间隔调用<code class="fe mv mw mx my b">requestRandomQuote</code>来刷新报价。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mu lw l"/></div></figure><p id="7a4c" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">您需要将这一行添加到您的组件中，使其能够访问全局状态管理:</p><pre class="kj kk kl km gt nd my ne nf aw ng bi"><span id="2ad3" class="nh ly it my b gy ni nj l nk nl">const { state, actions } = useContext(StoreContext);</span></pre><p id="93ad" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">我通常使用页面作为简单的控制器，从组件的表示中提取读取数据。因此<code class="fe mv mw mx my b">QuoteComponent</code>负责显示报价，但不知道数据来自全局状态。</p><p id="9065" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated"><code class="fe mv mw mx my b">useEffect</code> React hook用于在<code class="fe mv mw mx my b">HomePage</code>第一次加载时运行<code class="fe mv mw mx my b">setInterval</code>添加开头。它简单地调用<code class="fe mv mw mx my b">requestRandomQuote</code>，其结果由我们的reducer处理。状态自动更新，我们不需要任何额外的代码来更新<code class="fe mv mw mx my b">QuoteComponent</code>。</p><h1 id="0db4" class="lx ly it bd lz ma mb mc md me mf mg mh jz mi ka mj kc mk kd ml kf mm kg mn mo bi translated">基于报价变化的背景颜色变化</h1><p id="42b1" class="pw-post-body-paragraph ky kz it la b lb mp ju ld le mq jx lg lh mr lj lk ll ms ln lo lp mt lr ls lt im bi translated">为了展示您的组件可以根据全局状态的变化执行额外的更改，我添加了<code class="fe mv mw mx my b">Background</code>组件，它会在每次报价更改时将背景更改为随机颜色。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mu lw l"/></div></figure><p id="6471" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated"><a class="ae lu" href="https://styled-components.com/" rel="noopener ugc nofollow" target="_blank"> React风格的组件</a>被我用来创建实际的背景<code class="fe mv mw mx my b">div</code>。</p><p id="4cf5" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">我们利用<code class="fe mv mw mx my b">useEffect</code> React钩子监视<code class="fe mv mw mx my b">state.quote</code>改变颜色:</p><pre class="kj kk kl km gt nd my ne nf aw ng bi"><span id="2b18" class="nh ly it my b gy ni nj l nk nl">useEffect(<br/>  () =&gt; setBackgroundColors(randomOf(colors))<br/>, [state.quote]);</span></pre><p id="a0d5" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">然后当前的背景颜色被<code class="fe mv mw mx my b">useState</code> React钩子保存在本地状态中，这演示了如何巧妙地将本地和全局状态结合在一起。</p><pre class="kj kk kl km gt nd my ne nf aw ng bi"><span id="483d" class="nh ly it my b gy ni nj l nk nl">const [ backgroundColors, setBackgroundColors ] = useState(randomOf(colors));</span></pre><h1 id="86f1" class="lx ly it bd lz ma mb mc md me mf mg mh jz mi ka mj kc mk kd ml kf mm kg mn mo bi translated">结论</h1><p id="581b" class="pw-post-body-paragraph ky kz it la b lb mp ju ld le mq jx lg lh mr lj lk ll ms ln lo lp mt lr ls lt im bi translated">这就是让整个应用程序正常工作所需要做的全部工作。</p><p id="8ed8" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">现在想象一下，当您向每个人展示使用React钩子、全局状态管理和函数式编程的强大功能可以在React中做些什么时，他们会有怎样的印象。</p><p id="730f" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">如果有什么不工作，看看在https://github.com/MeetMartin/quotes的完整的GitHub项目库。</p><p id="5936" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">如果这不起作用，那么问题出在你的键盘和椅子之间的某个地方，但是请随意发表评论。我很乐意尽我所能帮助或引导你前进。</p><p id="6aca" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">另外，请在评论中告诉我这个解决方案对你的效果如何，你的同事是否喜欢它，或者你是否有什么需要改进的地方。</p></div></div>    
</body>
</html>