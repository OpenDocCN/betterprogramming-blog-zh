<html>
<head>
<title>Redux Style State Management for Android Apps</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Android应用程序的Redux风格状态管理</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/redux-style-state-management-for-android-apps-62da15dc7578?source=collection_archive---------3-----------------------#2022-02-10">https://betterprogramming.pub/redux-style-state-management-for-android-apps-62da15dc7578?source=collection_archive---------3-----------------------#2022-02-10</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="ceaf" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">在您的Android应用中使用最佳架构实践</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/46f2e02b2a8d8bb25ba450e62549a4fa.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*EdEzaDBmB-0Mxwnp"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">丹尼尔·罗梅罗在<a class="ae kv" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的照片</p></figure><p id="8cfd" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这篇文章说的是Redux风格的状态管理，但是说实话，下面的想法不一定是Redux风格的，它们是受它的启发，所以如果你不熟悉Redux也没关系。此外，该上下文中的“特征”用于描述用户与之交互的屏幕或UI。</p><h1 id="e516" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">状态和状态管理</h1><p id="be92" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">状态管理是一种通过集中各种UI控件的所有状态来处理应用程序中的数据流，从而促进组件之间的通信和数据传输的方法。这是单一真值源范例的一种可能的表现形式，也就是说，状态存储在单个对象中，并且该单个对象充当我们的应用程序的唯一真实的状态源。</p><p id="3386" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">用最简单的术语来说，状态就是触发UI变化的任何数据。对于社交媒体应用程序，状态的一个例子是帖子，它强制UI更新。</p><p id="db38" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在这个帖子中，我们可能有图像、标题、时间和喜欢等属性。如果我们假设图像和标题是不可变的，那么在“发布级别”上，这两个不会被认为是一个状态，因为一旦设置，它们就不会真正改变。时间和喜欢将是我们的“后水平”状态，因为它们是可变的和变化的，它们迫使用户界面刷新或更新。因此，在这种感知状态下，不局限于对象或用户定义的数据结构，如社交媒体帖子，而是扩展到原始类型，如帖子的点赞数(整数)。</p><h1 id="0b58" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">状态管理和架构</h1><p id="ae6a" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">状态管理并不独立于应用程序架构。事实上，状态管理是因为app架构。根据坚实的原则，一个异常的体系结构是一个模块关闭修改和开放扩展的体系结构。这意味着当一个新功能被添加到一个应用程序中时，不应该修改模块来适应新功能，而是应该将代码添加到实现新功能的模块中，并且添加的代码应该保持不变，即模块对于修改是封闭的，对于扩展是开放的。</p><p id="6b6f" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">如果用户可以与新功能交互，那么它就是有状态的。拥有集中式状态管理意味着应用程序的其他部分不会被修改以适应新功能的状态，但该状态将被添加为中心状态的一部分，新功能将从该中心状态访问其状态。</p><p id="20c4" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">可视化上面的场景并不容易，但它指出的一点是，随着应用程序复杂性的增长(随着新功能的增加)，状态管理的需求变得显而易见。这就是为什么考虑状态管理以及如何以可伸缩的方式进行状态管理是必要的第一步。在深入任何细节之前，让我们首先考虑状态的属性以及如何在Android中抽象它们。</p><p id="edde" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">如果你的Android应用程序中的每个屏幕都代表一个特性，那么避免不同特性之间的数据共享或通信就是架构上的最佳实践。这可以通过将特性分成独立的模块来进一步加强。与web应用程序中的状态管理不同，在web应用程序中，我们有一个与应用程序中每个组件通信的中央状态存储库，在这里，我们为每个功能都有多个状态存储库。</p><p id="b440" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">以视图模型为例。Ut通常有意义的是为你的应用程序中的所有特性建立单独的视图模型，而不是一个负责你的应用程序中所有特性的中央视图模型。这样，如果状态被定义为某个特性的属性，那么没有两个特性相互依赖，因为每个特性都有自己单独的状态和状态管理。</p><p id="02ef" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">下面的处理假设了上述情况，即每个特性都是独立的，并且有自己的状态管理。</p><p id="f4cb" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">假设我们正在建立一个像脸书这样的社交媒体应用程序，我们的任务是建立用户资料功能，用户可以看到他们的个人资料的细节，如他们的个人资料照片，用户名，简历，朋友和以前的帖子列表。</p><p id="60e1" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在这一点上，我们不关心后端和来自API的信息检索，而是更感兴趣的是如何处理这个特定的配置文件特性，它是如何呈现的，以及它如何响应用户的操作。</p><h1 id="7a06" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">关键组件</h1><p id="9173" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">再次假设独立于所有其他特性，下面是实现这一点所需的4个主要组件。</p><p id="3a21" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们将需要:</p><ul class=""><li id="596e" class="mp mq iq ky b kz la lc ld lf mr lj ms ln mt lr mu mv mw mx bi translated">主配置文件视图—这是配置文件的主屏幕或功能，用于呈现所有与配置文件相关的数据。我们的主要前端组件。</li><li id="ff0e" class="mp mq iq ky b kz my lc mz lf na lj nb ln nc lr mu mv mw mx bi translated">概要视图模型——它从我们的存储库和数据源以及数据存储中获取所有数据[共享首选项],并提供一个将由我们的概要视图使用的状态对象。</li><li id="4c3f" class="mp mq iq ky b kz my lc mz lf na lj nb ln nc lr mu mv mw mx bi translated">剖面视图状态——表示状态的不可变数据类，该数据类映射由视图模型接收的所有数据，并将其转换成单个状态对象，其中该对象的属性是数据。因为它是不可变的，当一个数据改变时，一个新的状态对象和相关的更新被创建并返回，而不是修改现有的状态，这是从REDUX借用的特性。</li><li id="91d3" class="mp mq iq ky b kz my lc mz lf na lj nb ln nc lr mu mv mw mx bi translated">配置文件操作—这包括用户在配置文件视图范围内可以执行的所有可能操作的抽象签名。这些操作可以是，编辑个人资料照片，更新用户名，删除帖子，取消好友，导航到设置，等等。对于登录屏幕，一些操作可能是登录和忘记密码。</li></ul><p id="8a88" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">下面是实现所有这些组件的方法。</p><h1 id="adbf" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">行动</h1><p id="7742" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">首先，定义可以从配置文件特征中进行的所有操作。这些操作将取决于您正在开发的功能的类型。对于这个例子，我们可能有这样的东西:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nd ne l"/></div></figure><p id="1486" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">要编辑个人资料，<code class="fe nf ng nh ni b">EditProfile</code>动作首先需要用户进行编辑，同样，要取消关注，该动作需要用户的id。</p><p id="2503" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们为此使用数据类，对于不需要特殊数据的动作，我们使用对象。<code class="fe nf ng nh ni b">ProfileAction</code>内的所有动作都必须显式地扩展它，原因很快就会变得明显。</p><h1 id="7623" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">纵断面图状态</h1><p id="3078" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">这是保存用户配置文件功能使用的所有状态的对象。它是不可变的，因此对它所保存的任何数据的更改都将强制创建包含已修改数据的视图状态的新实例。这里有一个实现的方法。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nd ne l"/></div></figure><p id="c97d" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们将<code class="fe nf ng nh ni b">ProfileViewState</code>的所有属性初始化为一些默认值，这些默认值本质上代表一个空状态。</p><h1 id="d12e" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">概要视图模型</h1><p id="fa84" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated"><code class="fe nf ng nh ni b">ViewModel</code>仅将状态暴露给视图(配置文件屏幕)。<code class="fe nf ng nh ni b">ProfileViewModel</code>的实现相当复杂，所以让我们先从实现开始，然后简单解释一下。</p><p id="ec31" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">一个好奇的读者会对我将要介绍的一些概念做进一步的阅读，因为我无法在不迷惑您的情况下深入任何细节——假设您不熟悉Kotlin协程和流。</p><p id="b812" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">如果你真的很好奇，那么你一定要看看我的应用程序，GitHub。玩玩它，然后检查代码，这将是非常有用的。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nd ne l"/></div></figure><p id="62d1" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">哇哦。那太多了。这里要理解的关键是<code class="fe nf ng nh ni b">ProfileViewModel</code>负责创建状态并执行从概要视图中分派的任何动作。</p><p id="fd4d" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">它通过使用已经在应用程序的数据层中实现的交互器和观察器来实现这一点。再往前走就不方便了。</p><h1 id="69de" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">剖面图</h1><p id="a784" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">这是使用Jetpack compose实现的配置文件功能的主要UI组件。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nd ne l"/></div></figure><p id="c6bf" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">配置文件视图使用一个状态对象，该对象包含描述它所需的所有数据。使用处理动作的调度员将动作发送回<code class="fe nf ng nh ni b">ProfileViewModel</code>。这样，Profile视图只负责描述数据是如何布局的，动作和状态是如何被<code class="fe nf ng nh ni b">ViewModel</code>处理的。如果你问我，那很酷。</p></div><div class="ab cl nj nk hu nl" role="separator"><span class="nm bw bk nn no np"/><span class="nm bw bk nn no np"/><span class="nm bw bk nn no"/></div><div class="ij ik il im in"><p id="74b3" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">随着应用程序复杂性的增加，状态管理变得非常方便，所以考虑如何在项目开始时处理状态是一个必要的步骤。这是一个方法的例子，你不需要理解这里的一切，只需要核心思想就足够了。</p><p id="50a5" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这是一篇很长的文章，如果你做得这么好。谢谢你能来。保持警惕！</p></div></div>    
</body>
</html>