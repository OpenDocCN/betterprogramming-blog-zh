<html>
<head>
<title>Making API Requests in Python: aiohttp Client vs. Requests</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">在Python中进行API请求:aiohttp客户端与请求</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/making-api-requests-in-python-aiohttp-client-vs-requests-26a7025c39a6?source=collection_archive---------2-----------------------#2021-01-05">https://betterprogramming.pub/making-api-requests-in-python-aiohttp-client-vs-requests-26a7025c39a6?source=collection_archive---------2-----------------------#2021-01-05</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="2d9d" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">探索基本语法并比较性能</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/dd90f24eff8f0d7f8b32149b3d16b5f3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*O1NYNs6lDeHy0uFZZXDp6Q.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">作者图片</p></figure><p id="1f39" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">本教程重点比较Python中调用API请求的两个主要包。</p><p id="b0f5" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">第一个是<a class="ae lu" href="https://requests.readthedocs.io/en/master/" rel="noopener ugc nofollow" target="_blank"> Requests: HTTP for Humans </a>，这是开发人员最常用的包之一。这是一个相当简单明了的Python HTTP库。此外，它为HTTP 1.1和HTTP连接池的完全自动化提供了强大的支持。</p><p id="c5ba" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">另一方面，<a class="ae lu" href="https://github.com/aio-libs/aiohttp" rel="noopener ugc nofollow" target="_blank"> aiohttp </a>，是一个用于客户端和服务器端的异步http框架。它旨在以非阻塞方式充分利用网络操作。此外，现在大多数服务器都是使用ASGI服务器构建的。异步调用API在性能方面具有优势，尤其是当I/O操作构成项目中的大部分进程时。然而，与请求相比，语法要冗长得多，这使得新开发人员很难实现。</p><p id="7578" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">在本教程中，我们将:</p><ol class=""><li id="bedb" class="lv lw it la b lb lc le lf lh lx ll ly lp lz lt ma mb mc md bi translated">实现一个简单的<a class="ae lu" href="https://fastapi.tiangolo.com/" rel="noopener ugc nofollow" target="_blank"> FastAPI </a>服务器，用GET route操作作为获取数据的外部API</li><li id="dbda" class="lv lw it la b lb me le mf lh mg ll mh lp mi lt ma mb mc md bi translated">用两个GET route操作实现另一个FastAPI服务器，这两个操作将使用请求和aiohttp模块调用外部API</li><li id="77b8" class="lv lw it la b lb me le mf lh mg ll mh lp mi lt ma mb mc md bi translated">在第二台服务器上创建一个负载测试脚本，以评估每秒的请求数</li></ol><p id="189d" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">我将使用<a class="ae lu" href="https://k6.io/docs/" rel="noopener ugc nofollow" target="_blank"> k6 </a>包进行负载测试。请随意使用您自己的负载测试工具，例如:</p><ul class=""><li id="a728" class="lv lw it la b lb lc le lf lh lx ll ly lp lz lt mj mb mc md bi translated"><a class="ae lu" href="https://medium.com/better-programming/an-introduction-to-k6-an-api-load-testing-tool-132a0d87827d" rel="noopener">K6介绍:一个API负载测试工具</a></li><li id="54c5" class="lv lw it la b lb me le mf lh mg ll mh lp mi lt mj mb mc md bi translated"><a class="ae lu" href="https://medium.com/better-programming/introduction-to-locust-an-open-source-load-testing-tool-in-python-2b2e89ea1ff" rel="noopener">Locust简介:Python中的一个开源负载测试工具</a></li></ul><p id="ad39" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">让我们继续下一部分，开始安装必要的模块。</p></div><div class="ab cl mk ml hx mm" role="separator"><span class="mn bw bk mo mp mq"/><span class="mn bw bk mo mp mq"/><span class="mn bw bk mo mp"/></div><div class="im in io ip iq"><h1 id="a892" class="mr ms it bd mt mu mv mw mx my mz na nb jz nc ka nd kc ne kd nf kf ng kg nh ni bi translated">Python包</h1><p id="28d1" class="pw-post-body-paragraph ky kz it la b lb nj ju ld le nk jx lg lh nl lj lk ll nm ln lo lp nn lr ls lt im bi translated">强烈建议您在继续安装之前设置一个虚拟环境。</p><h2 id="915f" class="no ms it bd mt np nq dn mx nr ns dp nb lh nt nu nd ll nv nw nf lp nx ny nh nz bi translated">FastAPI</h2><p id="c204" class="pw-post-body-paragraph ky kz it la b lb nj ju ld le nk jx lg lh nl lj lk ll nm ln lo lp nn lr ls lt im bi translated">运行以下命令进行安装。</p><pre class="kj kk kl km gt oa ob oc od aw oe bi"><span id="cc31" class="no ms it ob b gy of og l oh oi">pip install fastapi</span></pre><h2 id="1d4d" class="no ms it bd mt np nq dn mx nr ns dp nb lh nt nu nd ll nv nw nf lp nx ny nh nz bi translated">紫玉米</h2><p id="f03b" class="pw-post-body-paragraph ky kz it la b lb nj ju ld le nk jx lg lh nl lj lk ll nm ln lo lp nn lr ls lt im bi translated">为了运行FastAPI，你需要一个ASGI服务器，比如<a class="ae lu" href="https://www.uvicorn.org/" rel="noopener ugc nofollow" target="_blank">uvicon</a>或者<a class="ae lu" href="https://pypi.org/project/Hypercorn/" rel="noopener ugc nofollow" target="_blank"> Hypercorn </a>。我在这个教程中使用的是Uvicorn。您可以安装最低版本，如下所示:</p><pre class="kj kk kl km gt oa ob oc od aw oe bi"><span id="7849" class="no ms it ob b gy of og l oh oi">pip install uvicorn</span></pre><p id="44f4" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">如果您正在寻找标准版本，您应该运行以下代码。</p><pre class="kj kk kl km gt oa ob oc od aw oe bi"><span id="db3f" class="no ms it ob b gy of og l oh oi">pip install uvicorn[standard]</span></pre></div><div class="ab cl mk ml hx mm" role="separator"><span class="mn bw bk mo mp mq"/><span class="mn bw bk mo mp mq"/><span class="mn bw bk mo mp"/></div><div class="im in io ip iq"><h1 id="c0a2" class="mr ms it bd mt mu mv mw mx my mz na nb jz nc ka nd kc ne kd nf kf ng kg nh ni bi translated">k6</h1><p id="1549" class="pw-post-body-paragraph ky kz it la b lb nj ju ld le nk jx lg lh nl lj lk ll nm ln lo lp nn lr ls lt im bi translated">k6的安装取决于您机器的操作系统。</p><h2 id="daa0" class="no ms it bd mt np nq dn mx nr ns dp nb lh nt nu nd ll nv nw nf lp nx ny nh nz bi translated">Windows操作系统</h2><p id="ed10" class="pw-post-body-paragraph ky kz it la b lb nj ju ld le nk jx lg lh nl lj lk ll nm ln lo lp nn lr ls lt im bi translated">Windows用户应该使用可用的MSI安装程序。前往下面的链接并下载安装程序。然后通过运行它来正常安装。</p><ul class=""><li id="ce08" class="lv lw it la b lb lc le lf lh lx ll ly lp lz lt mj mb mc md bi translated"><a class="ae lu" href="https://dl.bintray.com/loadimpact/windows/k6-v0.29.0-amd64.msi" rel="noopener ugc nofollow" target="_blank"> k6安装器</a></li></ul><h2 id="ec2b" class="no ms it bd mt np nq dn mx nr ns dp nb lh nt nu nd ll nv nw nf lp nx ny nh nz bi translated">苹果个人计算机</h2><p id="b400" class="pw-post-body-paragraph ky kz it la b lb nj ju ld le nk jx lg lh nl lj lk ll nm ln lo lp nn lr ls lt im bi translated"><a class="ae lu" href="https://brew.sh/" rel="noopener ugc nofollow" target="_blank">在Mac中安装时，Brew </a>是首选。运行以下命令来安装k6。</p><pre class="kj kk kl km gt oa ob oc od aw oe bi"><span id="cb2a" class="no ms it ob b gy of og l oh oi">brew install k6</span></pre><h2 id="f167" class="no ms it bd mt np nq dn mx nr ns dp nb lh nt nu nd ll nv nw nf lp nx ny nh nz bi translated">Debian/Ubuntu</h2><p id="c683" class="pw-post-body-paragraph ky kz it la b lb nj ju ld le nk jx lg lh nl lj lk ll nm ln lo lp nn lr ls lt im bi translated">apt-get可以用来在你的Debian或者Ubuntu操作系统中安装k6。</p><pre class="kj kk kl km gt oa ob oc od aw oe bi"><span id="5526" class="no ms it ob b gy of og l oh oi">sudo apt-key adv --keyserver hkp://keyserver.ubuntu.com:80 --recv-keys 379CE192D401AB61echo "deb <a class="ae lu" href="https://dl.bintray.com/loadimpact/deb" rel="noopener ugc nofollow" target="_blank">https://dl.bintray.com/loadimpact/deb</a> stable main" | sudo tee -a /etc/apt/sources.listsudo apt-get updatesudo apt-get install k6</span></pre><p id="4b58" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">可能会出现由于防火墙或代理而无法获得密钥的问题。在这种情况下，请改用以下命令。</p><pre class="kj kk kl km gt oa ob oc od aw oe bi"><span id="4bc3" class="no ms it ob b gy of og l oh oi">wget -q -O - <a class="ae lu" href="https://bintray.com/user/downloadSubjectPublicKey?username=bintray" rel="noopener ugc nofollow" target="_blank">https://bintray.com/user/downloadSubjectPublicKey?username=bintray</a> | sudo apt-key add -</span></pre><h2 id="c0b3" class="no ms it bd mt np nq dn mx nr ns dp nb lh nt nu nd ll nv nw nf lp nx ny nh nz bi translated">红帽/CentOS</h2><p id="454f" class="pw-post-body-paragraph ky kz it la b lb nj ju ld le nk jx lg lh nl lj lk ll nm ln lo lp nn lr ls lt im bi translated">对于CentOS用户，您可以按如下方式轻松安装它:</p><pre class="kj kk kl km gt oa ob oc od aw oe bi"><span id="ac4c" class="no ms it ob b gy of og l oh oi">wget <a class="ae lu" href="https://bintray.com/loadimpact/rpm/rpm" rel="noopener ugc nofollow" target="_blank">https://bintray.com/loadimpact/rpm/rpm</a> -O bintray-loadimpact-rpm.reposudo mv bintray-loadimpact-rpm.repo /etc/yum.repos.d/sudo yum install k6</span></pre></div><div class="ab cl mk ml hx mm" role="separator"><span class="mn bw bk mo mp mq"/><span class="mn bw bk mo mp mq"/><span class="mn bw bk mo mp"/></div><div class="im in io ip iq"><h1 id="bfa9" class="mr ms it bd mt mu mv mw mx my mz na nb jz nc ka nd kc ne kd nf kf ng kg nh ni bi translated">FastAPI服务器作为外部API</h1><p id="d409" class="pw-post-body-paragraph ky kz it la b lb nj ju ld le nk jx lg lh nl lj lk ll nm ln lo lp nn lr ls lt im bi translated">创建一个名为<code class="fe oj ok ol ob b">external_api.py</code>的新Python脚本，并在其中添加以下代码。我们将使用它作为外部API服务器。它包含一个简单的GET route操作，该操作接受一个名为<code class="fe oj ok ol ob b">id</code>的字符串输入并将JSON返回给调用者。</p><pre class="kj kk kl km gt oa ob oc od aw oe bi"><span id="4063" class="no ms it ob b gy of og l oh oi">from fastapi import FastAPI</span><span id="f657" class="no ms it ob b gy om og l oh oi">app = FastAPI()</span><span id="78d2" class="no ms it ob b gy om og l oh oi">@app.get("/user/")<br/>async def user(id: str):<br/>    return {"id": id}</span></pre><p id="5bc4" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">保存文件并在命令行中运行以下命令来启动服务器。默认情况下，它将使用端口8000运行。如果其他程序正在使用该端口，请对其进行相应的修改。</p><pre class="kj kk kl km gt oa ob oc od aw oe bi"><span id="f782" class="no ms it ob b gy of og l oh oi">uvicorn external_api:app</span></pre></div><div class="ab cl mk ml hx mm" role="separator"><span class="mn bw bk mo mp mq"/><span class="mn bw bk mo mp mq"/><span class="mn bw bk mo mp"/></div><div class="im in io ip iq"><h1 id="06db" class="mr ms it bd mt mu mv mw mx my mz na nb jz nc ka nd kc ne kd nf kf ng kg nh ni bi translated">用于测试aiohttp和请求的FastAPI服务器</h1><h2 id="bd33" class="no ms it bd mt np nq dn mx nr ns dp nb lh nt nu nd ll nv nw nf lp nx ny nh nz bi translated">导入</h2><p id="489c" class="pw-post-body-paragraph ky kz it la b lb nj ju ld le nk jx lg lh nl lj lk ll nm ln lo lp nn lr ls lt im bi translated">创建一个名为<code class="fe oj ok ol ob b">myapp.py</code>的新Python文件，并在文件顶部添加以下import语句。</p><pre class="kj kk kl km gt oa ob oc od aw oe bi"><span id="de27" class="no ms it ob b gy of og l oh oi">from fastapi import FastAPI<br/>import requests<br/>import aiohttp</span><span id="4e51" class="no ms it ob b gy om og l oh oi">app = FastAPI()</span></pre><h2 id="9d01" class="no ms it bd mt np nq dn mx nr ns dp nb lh nt nu nd ll nv nw nf lp nx ny nh nz bi translated">启动和关闭事件</h2><p id="18d9" class="pw-post-body-paragraph ky kz it la b lb nj ju ld le nk jx lg lh nl lj lk ll nm ln lo lp nn lr ls lt im bi translated">继续添加以下启动和关闭事件。startup事件负责为请求和aiohttp初始化会话对象。我们将使用会话对象来重用底层的TCP连接。当向同一主机发出请求时，这可以显著提高性能。某些参数将在每个请求中保持不变。</p><p id="370b" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">作为清理过程的一部分，shutdown事件负责调用内置的<code class="fe oj ok ol ob b">close</code>函数来关闭aiohttp客户端会话。</p><pre class="kj kk kl km gt oa ob oc od aw oe bi"><span id="d529" class="no ms it ob b gy of og l oh oi">@app.on_event("startup")<br/>async def startup_event():<br/>    app.requests_session = requests.Session()<br/>    app.aiohttp_session = aiohttp.ClientSession()</span><span id="ee4f" class="no ms it ob b gy om og l oh oi">@app.on_event("shutdown")<br/>async def shutdown_event():<br/>    await app.aiohttp_session.close()</span></pre><h2 id="5dad" class="no ms it bd mt np nq dn mx nr ns dp nb lh nt nu nd ll nv nw nf lp nx ny nh nz bi translated">路线操作</h2><p id="136e" class="pw-post-body-paragraph ky kz it la b lb nj ju ld le nk jx lg lh nl lj lk ll nm ln lo lp nn lr ls lt im bi translated">定义以下路由操作，该操作在被请求时对我们的外部API进行HTTP GET调用。结果将作为JSON直接返回。</p><pre class="kj kk kl km gt oa ob oc od aw oe bi"><span id="33a5" class="no ms it ob b gy of og l oh oi">@app.get("/requests_api")<br/>async def requests_api():<br/>    r = app.session.get('http://localhost:8000/user/?id=001')</span><span id="9fde" class="no ms it ob b gy om og l oh oi">    return r.json()</span></pre><p id="87cb" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">接下来，让我们定义另一个路由操作，但是这次我们将使用aiohttp会话对象。您需要将它包装在上下文管理器中才能正常工作。</p><p id="46c9" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">请注意，我们在启动事件中只创建了一次<code class="fe oj ok ol ob b">aiohttp_session</code>对象。您不应该为每个请求创建一个新的会话，因为这样做的成本非常高。对于调用多个服务器的复杂情况，最佳实践是为每个服务器定义一个会话。</p><pre class="kj kk kl km gt oa ob oc od aw oe bi"><span id="3955" class="no ms it ob b gy of og l oh oi">@app.get("/aiohttp_api")<br/>async def aiohttp_api():<br/>    async with app.aiohttp_session.get('http://localhost:8000/user/?id=001') as response:<br/>        return await response.json()</span></pre><h2 id="19a0" class="no ms it bd mt np nq dn mx nr ns dp nb lh nt nu nd ll nv nw nf lp nx ny nh nz bi translated">正在启动FastAPI服务器</h2><p id="f00a" class="pw-post-body-paragraph ky kz it la b lb nj ju ld le nk jx lg lh nl lj lk ll nm ln lo lp nn lr ls lt im bi translated">完成后，保存文件并打开一个新的终端。激活所需的虚拟环境，并指向您的工作目录。接下来，运行以下命令来启动它。</p><pre class="kj kk kl km gt oa ob oc od aw oe bi"><span id="aab9" class="no ms it ob b gy of og l oh oi">uvicorn myapp:app --port 8001</span></pre><p id="1f86" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">由于我们的外部API运行在默认端口8000上，我们需要为它指定一个新端口。在本教程中，我使用端口8001。请随意相应地修改它。</p></div><div class="ab cl mk ml hx mm" role="separator"><span class="mn bw bk mo mp mq"/><span class="mn bw bk mo mp mq"/><span class="mn bw bk mo mp"/></div><div class="im in io ip iq"><h1 id="8278" class="mr ms it bd mt mu mv mw mx my mz na nb jz nc ka nd kc ne kd nf kf ng kg nh ni bi translated">使用k6加载测试脚本</h1><p id="8050" class="pw-post-body-paragraph ky kz it la b lb nj ju ld le nk jx lg lh nl lj lk ll nm ln lo lp nn lr ls lt im bi translated">在本节中，我们将使用JavaScript创建加载测试脚本。这允许我们评估请求和aiohttp之间的性能。创建一个名为<code class="fe oj ok ol ob b">test_scripts.js</code>的新文件。</p><h2 id="3095" class="no ms it bd mt np nq dn mx nr ns dp nb lh nt nu nd ll nv nw nf lp nx ny nh nz bi translated">导入</h2><p id="4e18" class="pw-post-body-paragraph ky kz it la b lb nj ju ld le nk jx lg lh nl lj lk ll nm ln lo lp nn lr ls lt im bi translated">在文件顶部添加以下import语句。</p><pre class="kj kk kl km gt oa ob oc od aw oe bi"><span id="9469" class="no ms it ob b gy of og l oh oi">import http from 'k6/http';<br/>import { check, sleep } from 'k6';</span></pre><h2 id="0b41" class="no ms it bd mt np nq dn mx nr ns dp nb lh nt nu nd ll nv nw nf lp nx ny nh nz bi translated">选择</h2><p id="17f6" class="pw-post-body-paragraph ky kz it la b lb nj ju ld le nk jx lg lh nl lj lk ll nm ln lo lp nn lr ls lt im bi translated">继续追加下面的代码，它表明了我们测试的选项。</p><pre class="kj kk kl km gt oa ob oc od aw oe bi"><span id="b9f5" class="no ms it ob b gy of og l oh oi">export let options = {<br/>  stages: [<br/>    { duration: '1s', target: 100 },<br/>    { duration: '10s', target: 100 },<br/>  ],<br/>};</span></pre><p id="d95f" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">它会在一秒钟内产生0到100个VUs，并在接下来的十秒钟内保持相同的VUs数量。随意修改阶段或vu的数量。</p><h2 id="ebf9" class="no ms it bd mt np nq dn mx nr ns dp nb lh nt nu nd ll nv nw nf lp nx ny nh nz bi translated">根据请求测试功能</h2><p id="46bd" class="pw-post-body-paragraph ky kz it la b lb nj ju ld le nk jx lg lh nl lj lk ll nm ln lo lp nn lr ls lt im bi translated">之后，定义一个新的函数作为我们测试的默认函数。每个VU都会反复调用这个函数，直到测试结束。我们先调用<code class="fe oj ok ol ob b">requests_api</code>，测试它的性能。</p><pre class="kj kk kl km gt oa ob oc od aw oe bi"><span id="5ab7" class="no ms it ob b gy of og l oh oi">export default function () {<br/>  let res = http.get('http://localhost:8001/requests_api');<br/>  check(res, {<br/>   'is status 200': (r) =&gt; r.status === 200,<br/> });<br/>  sleep(0.1);<br/>}</span></pre><p id="c010" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">在函数内部，我们将进行检查，以确定返回的响应是否为状态200。此外，我已经添加了一个迷你睡眠，以正确模拟我们的用户将如何发送请求。</p><h2 id="5af2" class="no ms it bd mt np nq dn mx nr ns dp nb lh nt nu nd ll nv nw nf lp nx ny nh nz bi translated">运行测试脚本</h2><p id="17d9" class="pw-post-body-paragraph ky kz it la b lb nj ju ld le nk jx lg lh nl lj lk ll nm ln lo lp nn lr ls lt im bi translated">保存文件并打开另一个终端。将它指向您的测试脚本的位置。运行以下命令开始测试。</p><pre class="kj kk kl km gt oa ob oc od aw oe bi"><span id="df07" class="no ms it ob b gy of og l oh oi">k6 run test_scripts.js</span></pre><p id="8382" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">在测试结束时，您应该会得到以下输出。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi on"><img src="../Images/387546d44e9db618115249ded1243cdb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*6aKZQ7Pihy5U71oUXK2DbA.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">作者图片</p></figure><p id="2b98" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">根据上图，我们的测试在整个测试中总共发出了1，775个请求。这导致使用请求模块每秒大约有153个请求。</p><p id="ee9d" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">如果您有疑问，只需重新运行测试来验证您的结果的平均每秒请求数。我第二次运行得到了以下结果。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi oo"><img src="../Images/31323f36b1dc8f6a14dad35a07077b36.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ONmRPSp7e7MVvjbL5zP02w.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">作者图片</p></figure><h2 id="ac9b" class="no ms it bd mt np nq dn mx nr ns dp nb lh nt nu nd ll nv nw nf lp nx ny nh nz bi translated">aiohttp上的测试函数</h2><p id="863c" class="pw-post-body-paragraph ky kz it la b lb nj ju ld le nk jx lg lh nl lj lk ll nm ln lo lp nn lr ls lt im bi translated">完成后，让我们将测试URL修改为<code class="fe oj ok ol ob b">aiohttp_api</code>。只需更改以下内容:</p><pre class="kj kk kl km gt oa ob oc od aw oe bi"><span id="1658" class="no ms it ob b gy of og l oh oi">let res = http.get('http://localhost:8001/requests_api');</span></pre><p id="4f9f" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">对此:</p><pre class="kj kk kl km gt oa ob oc od aw oe bi"><span id="e5b6" class="no ms it ob b gy of og l oh oi">let res = http.get('http://localhost:8001/aiohttp_api');</span></pre><p id="a0f0" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">保存您的测试脚本，并重新运行以下命令。</p><pre class="kj kk kl km gt oa ob oc od aw oe bi"><span id="8097" class="no ms it ob b gy of og l oh oi">k6 run test_scripts.js</span></pre><p id="3ae0" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">测试完成后，您的终端将显示以下结果。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi op"><img src="../Images/2d47f3d814a82ad2a1ef03769c8fc195.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*gSFc1qvn7lrqStchg5zpiQ.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">作者图片</p></figure><p id="984d" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">每次运行的实际结果可能会有很大差异。平均下来，结果应该比我们在<code class="fe oj ok ol ob b">requests_api</code>上的第一次测试要高。这表明，在对ASGI服务器的<code class="fe oj ok ol ob b">async</code>路由操作进行API调用时，aiohttp比Requests稍有优势。</p><p id="7068" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">说到这里，请注意，如果瓶颈不是主要由I/O操作引起的，aiohttp不会提高您的性能。假设你的机器学习API在使用请求的时候，性能大概是每秒十个请求。即使您将其切换到aiohttp，它仍然会或多或少地保持不变。</p></div><div class="ab cl mk ml hx mm" role="separator"><span class="mn bw bk mo mp mq"/><span class="mn bw bk mo mp mq"/><span class="mn bw bk mo mp"/></div><div class="im in io ip iq"><h1 id="01d4" class="mr ms it bd mt mu mv mw mx my mz na nb jz nc ka nd kc ne kd nf kf ng kg nh ni bi translated">结论</h1><p id="265f" class="pw-post-body-paragraph ky kz it la b lb nj ju ld le nk jx lg lh nl lj lk ll nm ln lo lp nn lr ls lt im bi translated">让我们回顾一下今天所学的内容。</p><p id="17b7" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">我们首先详细解释了请求和aiohttp模块之间的区别。</p><p id="0dfb" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">然后我们继续创建一个简单的FastAPI服务器作为外部API，它将被我们的第二个服务器调用。我们实现了第二个服务器，它包含两个路由操作，用于请求和aiohttp。</p><p id="d407" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">我们继续用JavaScript编写k6负载测试脚本。我们在<code class="fe oj ok ol ob b">requests_api</code>开始测试，然后是<code class="fe oj ok ol ob b">aiohttp_api</code>。这使我们能够评估和比较他们的表现。</p><p id="f796" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">感谢你阅读这篇文章。希望在下一篇文章中再见到你！</p></div><div class="ab cl mk ml hx mm" role="separator"><span class="mn bw bk mo mp mq"/><span class="mn bw bk mo mp mq"/><span class="mn bw bk mo mp"/></div><div class="im in io ip iq"><h1 id="5edc" class="mr ms it bd mt mu mv mw mx my mz na nb jz nc ka nd kc ne kd nf kf ng kg nh ni bi translated">参考</h1><ul class=""><li id="51a8" class="lv lw it la b lb nj le nk lh oq ll or lp os lt mj mb mc md bi translated"><a class="ae lu" href="https://docs.aiohttp.org/en/stable/client_quickstart.html" rel="noopener ugc nofollow" target="_blank"> aiohttp客户端快速入门</a></li><li id="cb44" class="lv lw it la b lb me le mf lh mg ll mh lp mi lt mj mb mc md bi translated"><a class="ae lu" href="https://github.com/aio-libs/aiohttp" rel="noopener ugc nofollow" target="_blank"> aiohttp GitHub页面</a></li><li id="737e" class="lv lw it la b lb me le mf lh mg ll mh lp mi lt mj mb mc md bi translated"><a class="ae lu" href="https://requests.readthedocs.io/en/master/user/advanced/#session-objects" rel="noopener ugc nofollow" target="_blank">请求—会话对象</a></li></ul></div></div>    
</body>
</html>