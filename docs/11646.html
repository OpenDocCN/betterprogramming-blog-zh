<html>
<head>
<title>Secrets of ‘unknown’ Types in TypeScript</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">TypeScript中“未知”类型的秘密</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/secrets-of-unknown-types-in-typescript-2987cd1263f0?source=collection_archive---------11-----------------------#2022-04-05">https://betterprogramming.pub/secrets-of-unknown-types-in-typescript-2987cd1263f0?source=collection_archive---------11-----------------------#2022-04-05</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="00a4" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">为什么在TypeScript中“unknown”比“any”更受欢迎？</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/ebbd879e49c451e31dfe8b2e77e3661f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*JBMzfOOB2WB467jitPRcIA.png"/></div></div></figure><p id="a930" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">本帖将介绍TypeScript中的<code class="fe lq lr ls lt b">unknown</code>类型，它是在TypeScript 3.0中引入的，是<code class="fe lq lr ls lt b">any</code>的类型安全对应。</p><p id="9e6c" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">我为什么这么说？接下来我将展示一下<code class="fe lq lr ls lt b">unknown</code>型的特点以及与<code class="fe lq lr ls lt b">any</code>相比的优势，让我们开始吧！</p><h1 id="6993" class="lu lv it bd lw lx ly lz ma mb mc md me jz mf ka mg kc mh kd mi kf mj kg mk ml bi translated">可转让性</h1><p id="d432" class="pw-post-body-paragraph ku kv it kw b kx mm ju kz la mn jx lc ld mo lf lg lh mp lj lk ll mq ln lo lp im bi translated">所有类型都可以分配给<code class="fe lq lr ls lt b">unknown</code>，但是反过来，<code class="fe lq lr ls lt b">unknown</code>只能分配给自身和<code class="fe lq lr ls lt b">any</code>。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mr ms l"/></div></figure><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mt ms l"/></div></figure><h1 id="d028" class="lu lv it bd lw lx ly lz ma mb mc md me jz mf ka mg kc mh kd mi kf mj kg mk ml bi translated">交叉点类型</h1><p id="12cd" class="pw-post-body-paragraph ku kv it kw b kx mm ju kz la mn jx lc ld mo lf lg lh mp lj lk ll mq ln lo lp im bi translated">在交集类型中，所有类型都会吸收<code class="fe lq lr ls lt b">unknown</code>。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mr ms l"/></div></figure><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mt ms l"/></div></figure><p id="0b40" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">这并不难理解，因为交集类型代表了两者的交集，而我们在上一节已经知道所有类型都可以赋给<code class="fe lq lr ls lt b">unknown</code>，所以任何与<code class="fe lq lr ls lt b">unknown</code>的交集都将是自身。</p><h1 id="2b8b" class="lu lv it bd lw lx ly lz ma mb mc md me jz mf ka mg kc mh kd mi kf mj kg mk ml bi translated">工会类型</h1><p id="0ec3" class="pw-post-body-paragraph ku kv it kw b kx mm ju kz la mn jx lc ld mo lf lg lh mp lj lk ll mq ln lo lp im bi translated">在联合类型中，<code class="fe lq lr ls lt b">unknown</code>吸收除<code class="fe lq lr ls lt b">any</code>之外的所有类型。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mr ms l"/></div></figure><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mt ms l"/></div></figure><p id="f1d7" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">联合类型表示两者的组合。如果两者可以合并，那么就返回范围更宽松的那个，所以除了<code class="fe lq lr ls lt b">any</code>就是<code class="fe lq lr ls lt b">unknown</code>。</p><h1 id="ad87" class="lu lv it bd lw lx ly lz ma mb mc md me jz mf ka mg kc mh kd mi kf mj kg mk ml bi translated">关键字' keyof '</h1><p id="90ea" class="pw-post-body-paragraph ku kv it kw b kx mm ju kz la mn jx lc ld mo lf lg lh mp lj lk ll mq ln lo lp im bi translated"><code class="fe lq lr ls lt b">keyof unknown</code>返回类型<code class="fe lq lr ls lt b">never</code>，表示永远不会出现的值的类型。<strong class="kw iu">而</strong> <code class="fe lq lr ls lt b"><strong class="kw iu">keyof any</strong></code> <strong class="kw iu">返回可用作对象索引的任何值的类型</strong>。为什么这么说？</p><p id="5bba" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">这是因为TypeScript编译选项中只有<a class="ae mu" href="https://www.typescriptlang.org/tsconfig#keyofStringsOnly" rel="noopener ugc nofollow" target="_blank"> keyofStringsOnly </a>，默认为false，则<code class="fe lq lr ls lt b">keyof any</code>将返回<code class="fe lq lr ls lt b">string | number | symbol</code>类型，为true时，<code class="fe lq lr ls lt b">keyof any</code>将返回类型<code class="fe lq lr ls lt b">string</code>。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mr ms l"/></div></figure><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mt ms l"/></div></figure><p id="6340" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">值得注意的是，TypeScript中内置的高级类型<code class="fe lq lr ls lt b">Record</code>用这个来限定可以用作对象索引的类型。其源代码如下:</p><pre class="kj kk kl km gt mv lt mw mx aw my bi"><span id="fe2c" class="mz lv it lt b gy na nb l nc nd">type Record&lt;K extends keyof any, T&gt; = {<br/>    [P in K]: T;<br/>};</span></pre><p id="4a74" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">有关TypeScript中内置实用程序类型的更多信息，请查看我以前的文章:</p><div class="ne nf gp gr ng nh"><a href="https://javascript.plainenglish.io/7-typescript-built-in-utility-types-you-must-know-d7a73a489d7" rel="noopener  ugc nofollow" target="_blank"><div class="ni ab fo"><div class="nj ab nk cl cj nl"><h2 class="bd iu gy z fp nm fr fs nn fu fw is bi translated">您必须知道的7种TypeScript内置实用程序类型</h2><div class="no l"><h3 class="bd b gy z fp nm fr fs nn fu fw dk translated">提高对内置类型的理解。</h3></div><div class="np l"><p class="bd b dl z fp nm fr fs nn fu fw dk translated">javascript.plainenglish.io</p></div></div><div class="nq l"><div class="nr l ns nt nu nq nv ks nh"/></div></div></a></div><p id="d170" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">关于TypeScript中<code class="fe lq lr ls lt b">never</code>类型的秘密，请查看我的另一篇文章:</p><div class="ne nf gp gr ng nh"><a href="https://blog.bitsrc.io/secrets-of-never-types-in-typescript-de57795a34da" rel="noopener  ugc nofollow" target="_blank"><div class="ni ab fo"><div class="nj ab nk cl cj nl"><h2 class="bd iu gy z fp nm fr fs nn fu fw is bi translated">TypeScript中“从不”类型的秘密</h2><div class="no l"><h3 class="bd b gy z fp nm fr fs nn fu fw dk translated">如何在TypeScript中获取never类型的值，never vs. void在TypeScript中，never在TypeScript函数声明中。</h3></div><div class="np l"><p class="bd b dl z fp nm fr fs nn fu fw dk translated">blog.bitsrc.io</p></div></div><div class="nq l"><div class="nw l ns nt nu nq nv ks nh"/></div></div></a></div><h1 id="6cbd" class="lu lv it bd lw lx ly lz ma mb mc md me jz mf ka mg kc mh kd mi kf mj kg mk ml bi translated">已初始化的</h1><p id="d5bf" class="pw-post-body-paragraph ku kv it kw b kx mm ju kz la mn jx lc ld mo lf lg lh mp lj lk ll mq ln lo lp im bi translated">没有声明<code class="fe lq lr ls lt b">const</code>的变量总是被认为是初始化的。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mr ms l"/></div></figure><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mt ms l"/></div></figure><h1 id="5315" class="lu lv it bd lw lx ly lz ma mb mc md me jz mf ka mg kc mh kd mi kf mj kg mk ml bi translated">缩小类型前的限制</h1><p id="2d22" class="pw-post-body-paragraph ku kv it kw b kx mm ju kz la mn jx lc ld mo lf lg lh mp lj lk ll mq ln lo lp im bi translated">除了等式运算符，不能使用任何其他运算符，如<code class="fe lq lr ls lt b">+-*/</code>、属性访问、函数调用等。，没有缩小<code class="fe lq lr ls lt b">unknown</code>的类型。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mr ms l"/></div></figure><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mt ms l"/></div></figure><h1 id="d00d" class="lu lv it bd lw lx ly lz ma mb mc md me jz mf ka mg kc mh kd mi kf mj kg mk ml bi translated">窄型</h1><p id="f983" class="pw-post-body-paragraph ku kv it kw b kx mm ju kz la mn jx lc ld mo lf lg lh mp lj lk ll mq ln lo lp im bi translated">从上一节我们知道，如果我们要操作<code class="fe lq lr ls lt b">unknown</code>类型的值，我们必须先缩小类型，这样TypeScript编译器就知道我们在做什么，你的代码也就保证了安全。</p><p id="c6d5" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">缩小类型可以使用<code class="fe lq lr ls lt b">typeof</code>、<code class="fe lq lr ls lt b">instanceof</code>、自定义类型谓词、类型断言等。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mr ms l"/></div></figure><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mt ms l"/></div></figure><p id="3100" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">请注意，在使用类型断言时，TypeScript不会帮助我们执行任何检查，这意味着您必须知道您在做什么，并确保您在做您想要做的事情。</p><h1 id="65ea" class="lu lv it bd lw lx ly lz ma mb mc md me jz mf ka mg kc mh kd mi kf mj kg mk ml bi translated">结论</h1><p id="80b1" class="pw-post-body-paragraph ku kv it kw b kx mm ju kz la mn jx lc ld mo lf lg lh mp lj lk ll mq ln lo lp im bi translated"><code class="fe lq lr ls lt b">any</code>类型导致TypeScript编译器跳过对该变量的类型检查，这可以理解为进入TypeScript类型系统的一个出口，但在大多数情况下，这太宽松了。另一方面，在执行大多数操作之前，类型<code class="fe lq lr ls lt b">unknown</code>的值必须缩小到一个特定的类型，这通常意味着更安全和更健壮。</p></div><div class="ab cl nx ny hx nz" role="separator"><span class="oa bw bk ob oc od"/><span class="oa bw bk ob oc od"/><span class="oa bw bk ob oc"/></div><div class="im in io ip iq"><p id="7f07" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">感谢阅读。我希望这有所帮助。如果你有兴趣，可以看看<a class="ae mu" href="https://medium.com/@islizeqiang/index-of-my-stories-published-in-2022-3c6e3cb94c07" rel="noopener">我的其他媒体文章</a>。</p></div></div>    
</body>
</html>