<html>
<head>
<title>A Simple Way To Make RPCs With Python</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">用Python制作RPC的简单方法</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/a-simple-way-to-make-rpcs-with-python-52ad8e9286c1?source=collection_archive---------4-----------------------#2022-09-15">https://betterprogramming.pub/a-simple-way-to-make-rpcs-with-python-52ad8e9286c1?source=collection_archive---------4-----------------------#2022-09-15</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="9bf7" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">告诉其他系统做什么——简单的方法</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/1e1a0ed3fdfc0d1de0e46b623195bf58.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*cf_nHmZ_YMKWONZYpkYo5w.jpeg"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">照片由<a class="ae ky" href="https://unsplash.com/@theshubhamdhage?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> GuerrillaBuzz Crypto PR </a>在<a class="ae ky" href="https://unsplash.com/s/photos/network?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</p></figure><p id="327e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">远程过程调用(<a class="ae ky" href="https://en.wikipedia.org/wiki/Remote_procedure_call" rel="noopener ugc nofollow" target="_blank"> RPC </a> s)一直存在，并且是跨分布式系统执行功能的最佳方式之一。有很多方法可以让另一个系统运行一些代码，比如使用web API或一些基于套接字的协议，但大多数方法都需要较高的前期开发成本。</p><p id="9306" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">使用web API，您必须提供HTTP接口，而其他基于套接字的解决方案可能需要更多样板代码才能起步。当您尝试从头开始构建自己的界面时，尤其如此。当你可以使用经过战斗考验的远程控制时，为什么要浪费时间呢？</p><p id="6e44" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在本文中，我们将研究用Python实现RPC的一种最简单的方法。我们将使用<a class="ae ky" href="https://rpyc.readthedocs.io/en/latest/" rel="noopener ugc nofollow" target="_blank"> RPyC </a>库，构建一个简单的分布式客户机/服务器系统，看看实现起来有多简单。</p><h2 id="64fb" class="lv lw it bd lx ly lz dn ma mb mc dp md li me mf mg lm mh mi mj lq mk ml mm mn bi translated">构建服务</h2><p id="601a" class="pw-post-body-paragraph kz la it lb b lc mo ju le lf mp jx lh li mq lk ll lm mr lo lp lq ms ls lt lu im bi translated">为了让我们的客户端RPC能够工作，我们需要一个基本的服务器设置来监听传入的连接。现在让我们引入RPyC库并创建一个新的服务来处理这个问题:</p><pre class="kj kk kl km gt mt mu mv mw aw mx bi"><span id="f1df" class="lv lw it mu b gy my mz l na nb"># server.py</span><span id="84b3" class="lv lw it mu b gy nc mz l na nb">import rpyc</span><span id="9070" class="lv lw it mu b gy nc mz l na nb"><a class="ae ky" href="http://twitter.com/rpyc" rel="noopener ugc nofollow" target="_blank">@rpyc</a>.service<br/>class TestService(rpyc.Service):<br/>    <a class="ae ky" href="http://twitter.com/rpyc" rel="noopener ugc nofollow" target="_blank">@rpyc</a>.exposed<br/>    def foo(self):<br/>        return 'foo'<br/>    <br/>    <a class="ae ky" href="http://twitter.com/rpyc" rel="noopener ugc nofollow" target="_blank">@rpyc</a>.exposed<br/>    def bar(self):<br/>        return 'bar'</span></pre><p id="7973" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这是一个简单的RPyC服务，它公开了两个方法<code class="fe nd ne nf mu b">foo</code>和<code class="fe nd ne nf mu b">bar</code>,这两个方法在被调用时都会返回一个简单的字符串消息。有多种方法来定义暴露的方法，我个人喜欢装饰方法，所以这就是我在这里使用的方法。</p><p id="0117" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">每个公开的方法都将出现在RPC连接对象的<code class="fe nd ne nf mu b">root</code>级别，并且可以被任何连接的客户端调用。如果您不希望向客户公开一个方法，只需在您的服务中去掉decorator即可。</p><pre class="kj kk kl km gt mt mu mv mw aw mx bi"><span id="e22b" class="lv lw it mu b gy my mz l na nb">@rpyc.exposed<br/>def my_public_method():<br/>    pass</span><span id="9276" class="lv lw it mu b gy nc mz l na nb">def my_private_method():<br/>    pass</span></pre><p id="323d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">还有其他一些特殊的方法，比如<code class="fe nd ne nf mu b">on_connect</code>和<code class="fe nd ne nf mu b">on_disconnect</code>，允许你在客户端连接到服务器或者从服务器断开时运行代码。查看文档了解更多实施细节。</p><p id="3003" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">既然我们已经定义了服务，我们就可以编写运行服务的实际RPC服务器代码了。</p><h2 id="8f9d" class="lv lw it bd lx ly lz dn ma mb mc dp md li me mf mg lm mh mi mj lq mk ml mm mn bi translated">构建服务器</h2><p id="672d" class="pw-post-body-paragraph kz la it lb b lc mo ju le lf mp jx lh li mq lk ll lm mr lo lp lq ms ls lt lu im bi translated">为了实际使用我们创建的服务，我们需要运行它，然后监听来电。为此，我们将使用RPyC 中的一个简单的<code class="fe nd ne nf mu b">ThreadedServer</code> <a class="ae ky" href="https://rpyc.readthedocs.io/en/latest/api/utils_server.html#rpyc.utils.server.ThreadedServer" rel="noopener ugc nofollow" target="_blank">。这将为每个来电派生出一个新的线程，使它比普通服务器更有效率。它将能够处理稍高的负载，并且实现起来非常简单。</a></p><p id="492e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">但是请记住，这些线程仅用于传入的调用，如果您想要线程化服务器实例，您需要<a class="ae ky" href="https://docs.python.org/3/library/threading.html" rel="noopener ugc nofollow" target="_blank">自己处理</a>。为了这个例子，我们将保持它的简单。</p><p id="92bb" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在，让我们对之前的服务代码做一些补充:</p><pre class="kj kk kl km gt mt mu mv mw aw mx bi"><span id="8cc7" class="lv lw it mu b gy my mz l na nb"># server.py</span><span id="5a06" class="lv lw it mu b gy nc mz l na nb">import rpyc<br/>from rpyc.utils.server import ThreadedServer</span><span id="671d" class="lv lw it mu b gy nc mz l na nb"><a class="ae ky" href="http://twitter.com/rpyc" rel="noopener ugc nofollow" target="_blank">@rpyc</a>.service<br/>class TestService(rpyc.Service):<br/>    <a class="ae ky" href="http://twitter.com/rpyc" rel="noopener ugc nofollow" target="_blank">@rpyc</a>.exposed<br/>    def foo(self):<br/>        return 'foo'<br/>    <br/>    <a class="ae ky" href="http://twitter.com/rpyc" rel="noopener ugc nofollow" target="_blank">@rpyc</a>.exposed<br/>    def bar(self):<br/>        return 'bar'</span><span id="4684" class="lv lw it mu b gy nc mz l na nb">print('starting server')<br/>server = ThreadedServer(TestService, port=18811)<br/>server.start()</span></pre><p id="a6f6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这里我们仍然使用完全相同的服务，但是现在我们将它传递给我们的<code class="fe nd ne nf mu b">ThreadedServer</code>并启动它。它将在端口<code class="fe nd ne nf mu b">18811</code>上监听传入的RPC请求。</p><p id="122a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">您可以使用以下语法执行服务器:</p><pre class="kj kk kl km gt mt mu mv mw aw mx bi"><span id="1fb8" class="lv lw it mu b gy my mz l na nb">python3 server.py</span></pre><p id="7a69" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">接下来，让我们让这个服务器保持运行，并测试我们的客户机，让它开始尝试一些调用。</p><h2 id="5315" class="lv lw it bd lx ly lz dn ma mb mc dp md li me mf mg lm mh mi mj lq mk ml mm mn bi translated">构建客户端</h2><p id="8886" class="pw-post-body-paragraph kz la it lb b lc mo ju le lf mp jx lh li mq lk ll lm mr lo lp lq ms ls lt lu im bi translated">为了让我们制作RPC，我们需要一个主机和端口来连接。因为我们只是在测试我们的服务，所以我们可以通过<code class="fe nd ne nf mu b">localhost</code>完成所有这些工作。在生产中，您可能会连接到远程服务器的IP地址或域名。</p><p id="4ad6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们看看简单的环回客户端是什么样子的:</p><pre class="kj kk kl km gt mt mu mv mw aw mx bi"><span id="bc77" class="lv lw it mu b gy my mz l na nb">import rpyc</span><span id="cc50" class="lv lw it mu b gy nc mz l na nb">connection = rpyc.connect('localhost', 18811)</span><span id="07fc" class="lv lw it mu b gy nc mz l na nb">print(connection.root.foo())<br/>print(connection.root.bar())</span></pre><p id="a1d6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在这个例子中，我们在端口<code class="fe nd ne nf mu b">18811</code>上连接到<code class="fe nd ne nf mu b">localhost</code>，这是我们的服务器(<em class="ng">应该还在运行</em>)监听传入连接的地方。一旦我们连接上，我们就可以开始调用服务中定义的方法。</p><p id="951a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们调用返回预期字符串的<code class="fe nd ne nf mu b">foo</code>和<code class="fe nd ne nf mu b">bar</code>方法。这些方法位于<code class="fe nd ne nf mu b">root</code>层(或<a class="ae ky" href="https://rpyc.readthedocs.io/en/latest/api/core_netref.html" rel="noopener ugc nofollow" target="_blank"> NetRef </a>层)之下，所以我们需要做的就是在那里寻找它们。您还可以创建自定义的NetRefs，但是对于本文来说，这有点复杂。</p><p id="c650" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">祝贺你，你现在已经用Python制作了一些RPC！</p></div><div class="ab cl nh ni hx nj" role="separator"><span class="nk bw bk nl nm nn"/><span class="nk bw bk nl nm nn"/><span class="nk bw bk nl nm"/></div><div class="im in io ip iq"><p id="efbb" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">感谢您的阅读！看看我下面的几个帖子:</p><ul class=""><li id="d3c7" class="no np it lb b lc ld lf lg li nq lm nr lq ns lu nt nu nv nw bi translated"><a class="ae ky" rel="noopener ugc nofollow" target="_blank" href="/python-modules-that-make-handling-json-even-faster-f577d8948a5"> <em class="ng"> Python模块使得处理JSON更快</em> </a></li><li id="86d1" class="no np it lb b lc nx lf ny li nz lm oa lq ob lu nt nu nv nw bi translated"><a class="ae ky" rel="noopener ugc nofollow" target="_blank" href="/7-shell-shortcuts-to-speed-up-development-439943247eea"> <em class="ng">加速开发的7个外壳快捷键</em> </a></li></ul></div></div>    
</body>
</html>