<html>
<head>
<title>Share Swift Code Between Client App and Vapor Server</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">在客户端应用程序和Vapor服务器之间共享Swift代码</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/share-swift-code-between-client-and-vapor-server-94df9cc42543?source=collection_archive---------7-----------------------#2022-08-09">https://betterprogramming.pub/share-swift-code-between-client-and-vapor-server-94df9cc42543?source=collection_archive---------7-----------------------#2022-08-09</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="9ccc" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">设置一个项目，其中Vapor共享大多数代码</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/897e6a6bdcad1f6f2384e53eadcebe99.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*rsEKEwH-835H_5rZ"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">照片由<a class="ae ky" href="https://unsplash.com/@sobhyabdo?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">阿卜杜勒拉赫曼·索比</a>在<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</p></figure><p id="15ce" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">Swift中我还没有研究的一个方面是服务器端开发。最著名的框架之一是Vapor。Vapor是用Swift编写的，它附带了所有标准的服务器端API:路由、请求处理、验证等等。</p><p id="19d3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">Vapor还提供了额外的包来与数据库、缓存、web套接字等公共服务进行交互。它的结构和依赖关系是使用SPM定义的。正是由于SPM，您可以在同一个项目中拥有服务器和客户机，共享主要的应用程序逻辑。</p><p id="04f1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">今天，我想探讨如何建立一个项目，让服务器和客户端代码一起位于同一个Xcode项目中，在这个项目中它们可以共享一些逻辑。</p><h1 id="78b8" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">设置蒸汽</h1><p id="08ed" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">这个项目设置的第一步是安装Vapor。可以按照官方<a class="ae ky" href="https://docs.vapor.codes/install/macos/" rel="noopener ugc nofollow" target="_blank">网站</a>上的说明进行操作。运行此命令以安装brew公式:</p><pre class="kj kk kl km gt ms mt mu mv aw mw bi"><span id="3e4f" class="mx lw it mt b gy my mz l na nb">brew install vapor</span></pre><p id="1316" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">安装后，您可以创建第一个应用程序来探索Vapor的结构。从终端运行以下命令:</p><ol class=""><li id="0ed0" class="nc nd it lb b lc ld lf lg li ne lm nf lq ng lu nh ni nj nk bi translated"><code class="fe nl nm nn mt b">vapor new MyFirstServer -n</code>创建第一个服务器。</li><li id="060d" class="nc nd it lb b lc no lf np li nq lm nr lq ns lu nh ni nj nk bi translated"><code class="fe nl nm nn mt b">cd MyFirstServer</code>。</li><li id="6c46" class="nc nd it lb b lc no lf np li nq lm nr lq ns lu nh ni nj nk bi translated"><code class="fe nl nm nn mt b">open Package.swift</code>。</li></ol><p id="53c9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">最后一个命令打开Xcode，IDE开始解决依赖关系。这可能需要一些时间来完成。完成后，您会在Xcode的顶部栏中看到一个用于MacOS的<code class="fe nl nm nn mt b">MyFirstServer</code>目标:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nt"><img src="../Images/af9b3abf6dc0932ae068b75f00107252.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*0uwJEzLjL-xVT9arA4zkfQ.png"/></div></div></figure><p id="108b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">单击播放按钮启动服务器。一旦加载，服务器使用端口<code class="fe nl nm nn mt b">8080</code>响应<code class="fe nl nm nn mt b">localhost</code>。如果连接到<code class="fe nl nm nn mt b">http://127.0.0.1:8080/</code>，它会输出消息<code class="fe nl nm nn mt b">It works!</code>。</p><p id="dbbc" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">默认情况下，服务器已经响应了另一个端点<code class="fe nl nm nn mt b">hello</code>:当然，完整地址是<code class="fe nl nm nn mt b">http://127.0.0.1:8080/hello</code>，输出消息是<code class="fe nl nm nn mt b">Hello, world!</code>。</p><h2 id="7f2e" class="mx lw it bd lx nu nv dn mb nw nx dp mf li ny nz mh lm oa ob mj lq oc od ml oe bi translated">蒸汽结构</h2><p id="4b2c" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">蒸汽基app的主要结构包括:</p><ul class=""><li id="2f14" class="nc nd it lb b lc ld lf lg li ne lm nf lq ng lu of ni nj nk bi translated">一个<code class="fe nl nm nn mt b">Public</code>文件夹，用于存放静态文件，如图像、图标和脚本。它必须配置为正常工作，如这里的<a class="ae ky" href="https://docs.vapor.codes/getting-started/folder-structure/#public" rel="noopener ugc nofollow" target="_blank">和</a>所述。</li><li id="bc0d" class="nc nd it lb b lc no lf np li nq lm nr lq ns lu of ni nj nk bi translated">一个<code class="fe nl nm nn mt b">App</code>文件夹，其中包含一个<code class="fe nl nm nn mt b">Controllers</code>文件夹，您可以在其中添加所有的逻辑。您可以使用<code class="fe nl nm nn mt b">App</code>文件夹来配置其他逻辑元件。设置路线的<code class="fe nl nm nn mt b">configure</code>功能位于此。</li><li id="1362" class="nc nd it lb b lc no lf np li nq lm nr lq ns lu of ni nj nk bi translated">一个带有<code class="fe nl nm nn mt b">main.swift</code>文件的<code class="fe nl nm nn mt b">Run</code>文件夹。这是服务器应用程序的入口点:它加载环境变量，然后创建、配置和启动应用程序。</li></ul><h2 id="f687" class="mx lw it bd lx nu nv dn mb nw nx dp mf li ny nz mh lm oa ob mj lq oc od ml oe bi translated">Package.swift</h2><p id="aa31" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">服务器应用程序的核心结构由<code class="fe nl nm nn mt b">Package.swift</code>文件定义。模板文件如下所示:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="og oh l"/></div></figure><p id="fe16" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这里需要注意的要点是:</p><ul class=""><li id="2c60" class="nc nd it lb b lc ld lf lg li ne lm nf lq ng lu of ni nj nk bi translated"><code class="fe nl nm nn mt b">Vapor</code>依赖项，从GitHub的<code class="fe nl nm nn mt b">dependency</code>属性中加载。</li><li id="61df" class="nc nd it lb b lc no lf np li nq lm nr lq ns lu of ni nj nk bi translated"><code class="fe nl nm nn mt b">App</code>目标，它依赖于<code class="fe nl nm nn mt b">Vapor</code>产品。</li><li id="cac5" class="nc nd it lb b lc no lf np li nq lm nr lq ns lu of ni nj nk bi translated">名为<code class="fe nl nm nn mt b">Run</code>的<code class="fe nl nm nn mt b">executableTarget</code>依赖于目标<code class="fe nl nm nn mt b">App</code>。</li></ul><p id="5468" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这个结构告诉你除了<code class="fe nl nm nn mt b">executableTarget</code>之外的所有东西都可以被移动到另一个包中，并由<code class="fe nl nm nn mt b">Run</code>目标导入。</p><p id="9caa" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">通过提取它，您将能够在服务器和客户机之间共享模型和逻辑。</p><h1 id="7bca" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">创建可共享的包</h1><p id="aae9" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">为了将<code class="fe nl nm nn mt b">executableTarget</code>与逻辑的其余部分隔离开来，您需要首先创建一个单独的Swift包。</p><ol class=""><li id="d6bb" class="nc nd it lb b lc ld lf lg li ne lm nf lq ng lu nh ni nj nk bi translated">在<code class="fe nl nm nn mt b">MyFirstServer</code>文件夹的同一级，创建一个<code class="fe nl nm nn mt b">MyAppLogic</code>文件夹。</li><li id="485f" class="nc nd it lb b lc no lf np li nq lm nr lq ns lu nh ni nj nk bi translated">将<code class="fe nl nm nn mt b">Package.swift</code>文件从<code class="fe nl nm nn mt b">MyFirstServer</code>复制到<code class="fe nl nm nn mt b">MyAppLogic</code>文件夹。</li><li id="0649" class="nc nd it lb b lc no lf np li nq lm nr lq ns lu nh ni nj nk bi translated">通过拆除<code class="fe nl nm nn mt b">executableTarget</code>更新<code class="fe nl nm nn mt b">MyAppLogic/Package.swift</code>。</li><li id="9176" class="nc nd it lb b lc no lf np li nq lm nr lq ns lu nh ni nj nk bi translated">将<code class="fe nl nm nn mt b">Sources/App</code>文件夹从<code class="fe nl nm nn mt b">MyFirstServer</code>移动到<code class="fe nl nm nn mt b">MyAppLogic</code>。</li><li id="c8f8" class="nc nd it lb b lc no lf np li nq lm nr lq ns lu nh ni nj nk bi translated">将<code class="fe nl nm nn mt b">Tests/AppTests</code>文件夹从<code class="fe nl nm nn mt b">MyFirstServer</code>移动到<code class="fe nl nm nn mt b">MyAppLogic</code>。</li><li id="f4ac" class="nc nd it lb b lc no lf np li nq lm nr lq ns lu nh ni nj nk bi translated">在<code class="fe nl nm nn mt b">Package.swift</code>中，将目标中的<code class="fe nl nm nn mt b">App</code>重命名为<code class="fe nl nm nn mt b">Server</code>，将<code class="fe nl nm nn mt b">AppTests</code>重命名为<code class="fe nl nm nn mt b">ServerTests</code>。您可能还想将封装<code class="fe nl nm nn mt b">name</code>更改为<code class="fe nl nm nn mt b">MyAppLogic</code>。</li><li id="cfb1" class="nc nd it lb b lc no lf np li nq lm nr lq ns lu nh ni nj nk bi translated">将所有文件夹从<code class="fe nl nm nn mt b">App</code>重命名为<code class="fe nl nm nn mt b">Server</code>。</li><li id="91b4" class="nc nd it lb b lc no lf np li nq lm nr lq ns lu nh ni nj nk bi translated">打开<code class="fe nl nm nn mt b">ServerTests.swift</code>，将<code class="fe nl nm nn mt b">@testable import</code>从使用<code class="fe nl nm nn mt b">App</code>改为使用<code class="fe nl nm nn mt b">Server</code>。</li><li id="da98" class="nc nd it lb b lc no lf np li nq lm nr lq ns lu nh ni nj nk bi translated">在<code class="fe nl nm nn mt b">Package.swift</code>文件中，添加一个<code class="fe nl nm nn mt b">products</code>属性来生成一个名为<code class="fe nl nm nn mt b">Server</code>的静态库，它依赖于<code class="fe nl nm nn mt b">Server</code>目标。</li><li id="61af" class="nc nd it lb b lc no lf np li nq lm nr lq ns lu nh ni nj nk bi translated">按下<code class="fe nl nm nn mt b">⌘+b</code>，看到Xcode成功构建包。</li></ol><p id="b05a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">完成所有这些步骤后，<code class="fe nl nm nn mt b">MyAppLogic</code>文件夹的文件树应该如下所示:</p><pre class="kj kk kl km gt ms mt mu mv aw mw bi"><span id="d543" class="mx lw it mt b gy my mz l na nb">MyAppLogic<br/>├── Package.resolved<br/>├── Package.swift<br/>├── Sources<br/>│   └── Server<br/>│       ├── Controllers<br/>│       ├── configure.swift<br/>│       └── routes.swift<br/>└── Tests<br/>    └── ServerTests<br/>        └── ServerTests.swift</span></pre><p id="621f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">而<code class="fe nl nm nn mt b">Package.swift</code>应该是这样的:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="og oh l"/></div></figure><p id="a655" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">接下来，您必须更新<code class="fe nl nm nn mt b">MyFirstServer</code> <code class="fe nl nm nn mt b">Package.swift</code>来消费新创建的包:</p><ol class=""><li id="e990" class="nc nd it lb b lc ld lf lg li ne lm nf lq ng lu nh ni nj nk bi translated">打开<code class="fe nl nm nn mt b">MyFirstServer/Package.swift</code>文件，从Vapor和除<code class="fe nl nm nn mt b">executableTarget</code>之外的所有目标中移除依赖关系。</li><li id="8b1c" class="nc nd it lb b lc no lf np li nq lm nr lq ns lu nh ni nj nk bi translated">使用<code class="fe nl nm nn mt b">.package(name:path:)</code>选项向<code class="fe nl nm nn mt b">MyAppLogic</code>包添加一个依赖项。</li><li id="6302" class="nc nd it lb b lc no lf np li nq lm nr lq ns lu nh ni nj nk bi translated">更新<code class="fe nl nm nn mt b">executableTarget</code>依赖项，从<code class="fe nl nm nn mt b">MyAppLogic</code>包中消费<code class="fe nl nm nn mt b">Server</code>产品。</li><li id="56a2" class="nc nd it lb b lc no lf np li nq lm nr lq ns lu nh ni nj nk bi translated">将<code class="fe nl nm nn mt b">main.swift</code>文件更新为<code class="fe nl nm nn mt b">import Server</code>而不是<code class="fe nl nm nn mt b">import App</code>。</li><li id="efb1" class="nc nd it lb b lc no lf np li nq lm nr lq ns lu nh ni nj nk bi translated">运行服务器以确保一切正常。</li></ol><p id="78b6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">服务器的新<code class="fe nl nm nn mt b">Package.swift</code>文件现在应该是这样的:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="og oh l"/></div></figure><p id="b074" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">此时，您不能同时打开<code class="fe nl nm nn mt b">MyAppLogic</code>项目和<code class="fe nl nm nn mt b">MyFirstServer</code>项目。如果包在Xcode的另一个实例中打开，Xcode就不能读取它。</p><blockquote class="oi oj ok"><p id="bc92" class="kz la ol lb b lc ld ju le lf lg jx lh om lj lk ll on ln lo lp oo lr ls lt lu im bi translated">当运行服务器时，可能会因为某些符号丢失而导致失败。如果发生这种情况，尝试打开<code class="fe nl nm nn mt b">MyAppLogic</code>项目并构建<code class="fe nl nm nn mt b">Server</code>库。现在你应该准备好二进制文件供<code class="fe nl nm nn mt b">MyFirstServer</code>应用程序使用。</p></blockquote><h1 id="cb23" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">添加应用程序</h1><p id="1948" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">最后，您可以通过创建SwiftUI应用程序将所有内容放在一个项目中。首先从Xcode创建一个新项目，我们称之为<code class="fe nl nm nn mt b">MyFirstApp</code>。</p><p id="541f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">创建完成后，右击应用程序并选择<code class="fe nl nm nn mt b">Add Packages</code>选项。在出现的对话框中，点击<code class="fe nl nm nn mt b">Add Local...</code>按钮并选择<code class="fe nl nm nn mt b">MyAppLogic</code>包。重复此操作，添加<code class="fe nl nm nn mt b">MyFirstServer</code>包。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi op"><img src="../Images/3de7d75b41755d9966530cea18140a26.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*H-CbqFxKWTw7IgrXni3Hsg.png"/></div></div></figure><p id="784f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这一步将所有代码放在同一个项目中。文件夹结构现在应该如下所示:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi oq"><img src="../Images/ab07ef662f53bf843dcd090748ae87e7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1032/format:webp/1*fgySuoEuYH4D2OYIuN0Byw.png"/></div></figure><p id="09f9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在，您可以为客户端、服务器或逻辑修改任何Swift文件。</p><h2 id="906f" class="mx lw it bd lx nu nv dn mb nw nx dp mf li ny nz mh lm oa ob mj lq oc od ml oe bi translated">使用应用程序中的逻辑包</h2><p id="73e6" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">要在应用程序中使用<code class="fe nl nm nn mt b">MyAppLogic</code>包，您必须设置另一个库:</p><ol class=""><li id="b07c" class="nc nd it lb b lc ld lf lg li ne lm nf lq ng lu nh ni nj nk bi translated">更新<code class="fe nl nm nn mt b">MyAppLogic/Package.swift</code>以公开另一个库。姑且称之为<code class="fe nl nm nn mt b">Client</code>。</li><li id="c03e" class="nc nd it lb b lc no lf np li nq lm nr lq ns lu nh ni nj nk bi translated">在软件包支持的平台中添加<code class="fe nl nm nn mt b">.iOS</code>平台。</li><li id="e049" class="nc nd it lb b lc no lf np li nq lm nr lq ns lu nh ni nj nk bi translated">创建一个<code class="fe nl nm nn mt b">MyAppLogic/Sources/Client</code>文件夹。</li><li id="5823" class="nc nd it lb b lc no lf np li nq lm nr lq ns lu nh ni nj nk bi translated">将<code class="fe nl nm nn mt b">ContentView</code>从<code class="fe nl nm nn mt b">MyFirstApp</code>处移入。</li></ol><p id="47f8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe nl nm nn mt b">MyAppLogic/Package.swift</code>的最终版本现在应该是这样的:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="og oh l"/></div></figure><h2 id="613e" class="mx lw it bd lx nu nv dn mb nw nx dp mf li ny nz mh lm oa ob mj lq oc od ml oe bi translated">运行应用程序</h2><p id="609a" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">由于这种设置，您现在可以同时运行服务器和客户端。在顶部Xcode的工具条中，<code class="fe nl nm nn mt b">MyFirstApp</code>目标被选中，你可以在一些iOS模拟器上运行它。点击<code class="fe nl nm nn mt b">play</code>可能会失败，因为在上一步之后，您将<code class="fe nl nm nn mt b">ContentView</code>文件从SwiftUI应用程序移动到了<code class="fe nl nm nn mt b">MyAppLogic</code>包中。</p><p id="740f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">要使它重新构建，您可以打开<code class="fe nl nm nn mt b">MyFirstAppApp.swift</code>文件并在顶部添加<code class="fe nl nm nn mt b">import Client</code>语句。</p><p id="d05e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">Xcode应该会告诉你没有<code class="fe nl nm nn mt b">Client</code>这种模块。这是因为您需要将库链接到应用程序:</p><ol class=""><li id="56f7" class="nc nd it lb b lc ld lf lg li ne lm nf lq ng lu nh ni nj nk bi translated">在项目导航器中单击项目。</li><li id="415a" class="nc nd it lb b lc no lf np li nq lm nr lq ns lu nh ni nj nk bi translated">单击常规选项卡。</li><li id="5c81" class="nc nd it lb b lc no lf np li nq lm nr lq ns lu nh ni nj nk bi translated">向下滚动，直到到达框架、库和嵌入式内容部分。</li><li id="fa8a" class="nc nd it lb b lc no lf np li nq lm nr lq ns lu nh ni nj nk bi translated">点击+按钮，从<code class="fe nl nm nn mt b">MyAppLogic</code>包中选择客户端库。</li></ol><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi or"><img src="../Images/da3359d9640ccd8cc6ecb929c699f2f7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*LzIvTnrpxxbRHdnd2lctpA.png"/></div></div></figure><p id="92e6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">另一个可以节省时间的技巧是确保在构建应用程序时重新编译<code class="fe nl nm nn mt b">Client</code>库。如果没有这一步，可能会发生这样的情况:您在没有构建库的情况下运行应用程序，Xcode运行的是它的一个过时版本，因此不会向您显示您最近的更改。</p><p id="a52a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这可以通过制定计划来实现:</p><ol class=""><li id="2ae1" class="nc nd it lb b lc ld lf lg li ne lm nf lq ng lu nh ni nj nk bi translated">点击Xcode顶部栏中的<code class="fe nl nm nn mt b">MyFirstApp</code>。</li><li id="8b46" class="nc nd it lb b lc no lf np li nq lm nr lq ns lu nh ni nj nk bi translated">选择编辑方案...<code class="fe nl nm nn mt b">option</code>。</li><li id="297b" class="nc nd it lb b lc no lf np li nq lm nr lq ns lu nh ni nj nk bi translated">在build选项卡中，单击底部的小+号。</li><li id="4ec4" class="nc nd it lb b lc no lf np li nq lm nr lq ns lu nh ni nj nk bi translated">将<code class="fe nl nm nn mt b">Client</code>库添加到其中。</li></ol><p id="a902" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在，每次运行SwiftUI应用程序时，Xcode也会检查<code class="fe nl nm nn mt b">Client</code>库中的一些文件是否已经更改，并最终重建它们。</p><h2 id="7a3b" class="mx lw it bd lx nu nv dn mb nw nx dp mf li ny nz mh lm oa ob mj lq oc od ml oe bi translated">运行服务器</h2><p id="fecf" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">目前，没有运行服务器的方法。这是因为服务器还没有方案，您需要创建一个。</p><ol class=""><li id="7a35" class="nc nd it lb b lc ld lf lg li ne lm nf lq ng lu nh ni nj nk bi translated">点击顶部栏中的<code class="fe nl nm nn mt b">MyFirstApp</code>。</li><li id="cb6a" class="nc nd it lb b lc no lf np li nq lm nr lq ns lu nh ni nj nk bi translated">选择管理方案...选项。</li><li id="9ed6" class="nc nd it lb b lc no lf np li nq lm nr lq ns lu nh ni nj nk bi translated">点击底部的+按钮。</li><li id="25d6" class="nc nd it lb b lc no lf np li nq lm nr lq ns lu nh ni nj nk bi translated">打开目标，向下滚动，并选择运行目标。</li><li id="d0e7" class="nc nd it lb b lc no lf np li nq lm nr lq ns lu nh ni nj nk bi translated">像以前一样叫它<code class="fe nl nm nn mt b">MyFirstServer</code>。</li></ol><div class="kj kk kl km gt ab cb"><figure class="os kn ot ou ov ow ox paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><img src="../Images/c9657b7325c817c764e187f3d245bea7.png" data-original-src="https://miro.medium.com/v2/resize:fit:722/format:webp/1*XjqhH3C0pG3pPayw4LYcdQ.png"/></div></figure><figure class="os kn oy ou ov ow ox paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><img src="../Images/698563d4b2ef66bd90acbbc47c074a91.png" data-original-src="https://miro.medium.com/v2/resize:fit:1280/format:webp/1*Q2rli7aRxLn3emHj-KFLwg.png"/></div></figure></div><p id="687c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在，您可以编辑该方案，并确保它在您构建服务器应用程序时也构建了<code class="fe nl nm nn mt b">Server</code>库。该流程与您在应用程序中遵循的流程相同:</p><ol class=""><li id="8f67" class="nc nd it lb b lc ld lf lg li ne lm nf lq ng lu nh ni nj nk bi translated">点击Xcode顶部栏中的<code class="fe nl nm nn mt b">MyFirstServer</code></li><li id="719b" class="nc nd it lb b lc no lf np li nq lm nr lq ns lu nh ni nj nk bi translated">选择编辑方案…选项。</li><li id="efbd" class="nc nd it lb b lc no lf np li nq lm nr lq ns lu nh ni nj nk bi translated">在build选项卡中，单击底部的小+号。</li><li id="4dd8" class="nc nd it lb b lc no lf np li nq lm nr lq ns lu nh ni nj nk bi translated">将<code class="fe nl nm nn mt b">Server</code>库添加到其中。</li></ol><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi oz"><img src="../Images/2e26d22eb35037bf410eb3f0a138b20f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*F4edIHICYEFUExbmpqKJLw.png"/></div></div></figure><blockquote class="oi oj ok"><p id="7971" class="kz la ol lb b lc ld ju le lf lg jx lh om lj lk ll on ln lo lp oo lr ls lt lu im bi translated">当运行服务器时，确保可执行目标是我的Mac，而不是任何其他风格的Mac(为iPad设计)。在这种情况下，服务器将无法正确构建。</p></blockquote><p id="a3dd" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">最后，您可以运行服务器，在顶部Xcode栏中切换所需的目标，同时运行客户端应用程序。</p><h1 id="0e95" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">共享代码</h1><p id="f7e0" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">现在，您的所有代码都在同一个XCode项目中。你可以随意修改任何包的任何部分:所以是时候在两个应用程序之间共享一些代码了。</p><h2 id="6d8c" class="mx lw it bd lx nu nv dn mb nw nx dp mf li ny nz mh lm oa ob mj lq oc od ml oe bi translated">设置软件包</h2><p id="2e4e" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">在客户机和服务器之间共享代码有几个好处。当然，最明显的是代码重用。其次，它消除了与数据模型不同步相关的问题，因为服务器更新了它们，但是客户机被留下了。</p><p id="d1fa" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">SPM可以让你非常容易地共享代码，创建一个新的目标作为两个应用程序的依赖。</p><ol class=""><li id="75b0" class="nc nd it lb b lc ld lf lg li ne lm nf lq ng lu nh ni nj nk bi translated">在<code class="fe nl nm nn mt b">MyAppLogic</code>包中创建一个新的目标，并将其命名为<code class="fe nl nm nn mt b">Logic</code>。</li><li id="7f62" class="nc nd it lb b lc no lf np li nq lm nr lq ns lu nh ni nj nk bi translated">使<code class="fe nl nm nn mt b">Client</code>和<code class="fe nl nm nn mt b">Server</code>目标都依赖于它。</li><li id="4b3f" class="nc nd it lb b lc no lf np li nq lm nr lq ns lu nh ni nj nk bi translated">创建一个新文件夹<code class="fe nl nm nn mt b">MyAppLogic/Logic</code>来添加共享代码。</li></ol><p id="2d7b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">记得在需要共享代码的文件中添加<code class="fe nl nm nn mt b">import Logic</code>语句。</p><p id="1365" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">最后的<code class="fe nl nm nn mt b">Package.swift</code>是这样的:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="og oh l"/></div></figure><p id="c20f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">注意第31行，这里定义了<code class="fe nl nm nn mt b">Logic</code>包，第22和32行在<code class="fe nl nm nn mt b">Client</code>和<code class="fe nl nm nn mt b">Server</code>目标中都有新的<code class="fe nl nm nn mt b">dependencies</code>。</p><h2 id="ff2a" class="mx lw it bd lx nu nv dn mb nw nx dp mf li ny nz mh lm oa ob mj lq oc od ml oe bi translated">数据模型</h2><p id="cf30" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">客户机和服务器之间最简单的共享是数据模型。例如，您可以创建一个如下所示的<code class="fe nl nm nn mt b">Profile</code>模型:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="og oh l"/></div></figure><p id="92a6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这个<code class="fe nl nm nn mt b">Profile</code>结构驻留在<code class="fe nl nm nn mt b">Logic</code>目标中。它包含用户的用户名、名字、姓氏和生日。它有一个公共init和一个helper属性来将其转换为Json。</p><blockquote class="oi oj ok"><p id="b7d0" class="kz la ol lb b lc ld ju le lf lg jx lh om lj lk ll on ln lo lp oo lr ls lt lu im bi translated">在这个模块化设置中，可见性修饰符很重要:如果不将init标记为public，就不能在服务器包中创建新的结构。</p></blockquote><h2 id="8814" class="mx lw it bd lx nu nv dn mb nw nx dp mf li ny nz mh lm oa ob mj lq oc od ml oe bi translated">服务器</h2><p id="4137" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">一旦定义了模型，您就可以在服务器和客户机中使用它。</p><p id="61cc" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">要在<code class="fe nl nm nn mt b">Server</code>库中使用它，您可以更新<code class="fe nl nm nn mt b">routes.swift</code>文件以响应另一个端点:<code class="fe nl nm nn mt b">profile</code>。代码可能如下所示:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="og oh l"/></div></figure><p id="cdd7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">该代码片段在第一行导入了<code class="fe nl nm nn mt b">Logic</code>包，以便能够访问<code class="fe nl nm nn mt b">Profile</code>数据结构。然后，它添加一个名为<code class="fe nl nm nn mt b">profile</code>的端点，该端点接受一个路径参数。Vapor允许您将路径参数与可用于检索其值的标签相关联。</p><p id="99cc" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">该逻辑验证请求，并在失败时返回一些错误代码。如果一切正常，它就创建<code class="fe nl nm nn mt b">Profile</code>结构并将其返回给调用者。</p><blockquote class="oi oj ok"><p id="c6d7" class="kz la ol lb b lc ld ju le lf lg jx lh om lj lk ll on ln lo lp oo lr ls lt lu im bi translated">这是一个让客户机和服务器快速交互的例子。<code class="fe nl nm nn mt b">profile</code>逻辑应包含在<code class="fe nl nm nn mt b">ProfileController</code>中，以将端点代码与路由配置隔离开来。</p></blockquote><h1 id="7e7f" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated"><strong class="ak">委托人</strong></h1><p id="a8c0" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">最后一步，您可以在客户端使用相同的结构。这个过程与服务器类似。客户端应用程序中没有路线，但您可以将它们嵌入到SwiftUI视图中。</p><p id="2617" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">打开<code class="fe nl nm nn mt b">ContentView</code>并修改如下:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="og oh l"/></div></figure><p id="28f4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">该视图允许您输入用户名，并在后端进行搜索。一旦搜索完成，它将数据呈现在一个类似表格的结构中，该结构使用一个名为<code class="fe nl nm nn mt b">DataRow</code>的子视图来水平排列键值对。</p><p id="fbef" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe nl nm nn mt b">search()</code>函数使用async-await与后端连接，并使用在<code class="fe nl nm nn mt b">Logic</code>包中定义的<code class="fe nl nm nn mt b">Profile</code>结构解析数据。一旦解码，对象被存储在一个<code class="fe nl nm nn mt b">@State</code>变量中，其值被用来填充视图。</p><p id="734a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">以下视频展示了运行中的客户端和服务器:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi pa"><img src="../Images/3500758e92fef80e455e57d2a7ddea4a.png" data-original-src="https://miro.medium.com/v2/resize:fit:960/1*M9ypNCUiXxyDBrbIswRBcA.gif"/></div></figure><blockquote class="oi oj ok"><p id="d677" class="kz la ol lb b lc ld ju le lf lg jx lh om lj lk ll on ln lo lp oo lr ls lt lu im bi translated">这是一个让客户机和服务器快速交互的例子。与服务器通信的逻辑应该放在适当的网络组件中，SwiftUI子视图应该放在自己的文件中。</p></blockquote><h1 id="e24c" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">结论</h1><p id="62af" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">今天我试图把几个想法浓缩成一篇文章。总结一下:</p><ul class=""><li id="59bc" class="nc nd it lb b lc ld lf lg li ne lm nf lq ng lu of ni nj nk bi translated">如何用Vapor建立一个新项目，描述它的基本结构。</li><li id="a02c" class="nc nd it lb b lc no lf np li nq lm nr lq ns lu of ni nj nk bi translated">如何从代码中分离出Vapor可执行文件？</li><li id="5b3c" class="nc nd it lb b lc no lf np li nq lm nr lq ns lu of ni nj nk bi translated">如何用服务器、逻辑和客户机创建单个项目。</li><li id="ae28" class="nc nd it lb b lc no lf np li nq lm nr lq ns lu of ni nj nk bi translated">如何在服务器和客户端之间共享代码。</li><li id="38ef" class="nc nd it lb b lc no lf np li nq lm nr lq ns lu of ni nj nk bi translated">如何一起运行它们。</li></ul><p id="fdaf" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">除了代码重用之外，这种设置还带来了各种优势:</p><ul class=""><li id="7974" class="nc nd it lb b lc ld lf lg li ne lm nf lq ng lu of ni nj nk bi translated">它推动了更好的模块化和代码结构。</li><li id="25f0" class="nc nd it lb b lc no lf np li nq lm nr lq ns lu of ni nj nk bi translated">它将逻辑隔离在单个SPM包中，使可执行文件保持一行。</li><li id="9823" class="nc nd it lb b lc no lf np li nq lm nr lq ns lu of ni nj nk bi translated">它让您保持客户端和服务器之间的代码同步。</li><li id="fb35" class="nc nd it lb b lc no lf np li nq lm nr lq ns lu of ni nj nk bi translated">编写单元测试和集成测试应该更容易。</li></ul><p id="3de2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">本文中讨论的代码可以在这个<a class="ae ky" href="https://github.com/cipolleschi/MyVaporTest" rel="noopener ugc nofollow" target="_blank">库</a>中找到。</p></div></div>    
</body>
</html>