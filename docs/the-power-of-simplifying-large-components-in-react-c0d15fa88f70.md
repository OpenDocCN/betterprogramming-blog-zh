# React 中简化大型组件的强大功能

> 原文：<https://betterprogramming.pub/the-power-of-simplifying-large-components-in-react-c0d15fa88f70>

## 简化是一种增强

![](img/da5d50bc3f27f755bf320593ee217617.png)

*照片由* [*毛绒设计工作室*](https://unsplash.com/@plushdesignstudio)*[*Unsplash*](https://unsplash.com/)*

*拥有大型组件并不总是一件坏事，但是利用可以进一步简化组件的机会是一个很好的实践——特别是当它提供额外的好处时。*

*当您有一个大的组件时，这可能会变得不利，因为组件越大，随着时间的推移维护和读取就越困难。*

*让我们看看下面的这个组件，看看为什么我们最好简化它。*

*(这是来自生产应用的代码，所以这实际上是一个真实的例子。)*

*下面的组件`SidebarSection`使用了一些道具——其中`props.ids`是一个字符串形式的条目 id 数组，而`props.items`是一个使用每个条目的`id`作为键来映射侧栏条目的对象。它使用这些属性来呈现侧栏项目:*

*组件实际上看起来没那么糟糕。但是如果你想一想，每当我们编辑组件时，我们必须在引入更改之前理解每一行代码，因为我们不知道更改某些东西是否会破坏组件的其他部分。*

*一个例子是在开关盒中创建的`onHoverAction`函数。它不必要地膨胀了我们的组件，并且根据`SidebarItem`的实现，它有可能导致一个无限循环，因为每次组件重新呈现时，对它的引用都会被重新创建。*

*这也使得整个组件对单元测试更加敏感，因为我们委托`SidebarSection`组件负责`onHoverAction`的实现细节。*

*在我们的单元测试中，当我们测试`SidebarSection`组件行为正确时，我们必须知道`onHoverAction`的实现细节。这没有太大意义。(这意味着要注意语法错误之类的事情——因为函数中的一个输入错误可能会破坏`SidebarSection`的呈现，我们会责怪组件做得不好。)*

*我们可以通过简单地将它提取到外部来简化这一点，这样我们就不必再将责任推给组件了:*

*我们所做的只是将该功能转移到另一个地方，几乎不用付出任何额外的努力，它已经给我们带来了巨大的好处:*

1.  *对该函数的引用将保持不变。*
2.  *现在可以过平静的生活了。因为它不再需要担心正确实现`onHoverAction`。它所需要做的就是通过`onHoverAction`所期望的争论。*
3.  *我们现在可以单独对`onHoverAction`进行单元测试，因为它可以作为导出来使用。想看看这是否如预期的那样工作吗？简单地导入它，传入三个参数，看看它返回什么。*
4.  *`SidebarSection`变得更容易阅读和维护。*

*这实际上并不是我们能简化它的全部。我们还有机会进一步简化组件。这两个开关模块中有重复的代码:*

*让它保持原样实际上可能不会成为太大的问题。然而，我确信任何阅读这段代码的开发人员都有义务一行一行地阅读每一个 prop，以便 100%确定它们没有那么不同。*

*毕竟，在理想情况下，我们愿意相信有重要的原因导致看起来相似的代码被分离，那么为什么这些代码会被分离呢？在我们的例子中，没有太多好的理由，所以简化它是一个好主意，这样未来的开发人员在尝试调试这个组件时就不会陷入这种尴尬的场景。*

*我们可以通过简单地这样做来简化它:*

*简单来说，这提供了几个重要的好处:*

1.  *我们消除了重复的代码。*
2.  *现在阅读起来更容易了，因为我们只需要查看代码的一个副本。*
3.  *自文档化代码(它基本上告诉我们类型为`notebook`和`static`的项目几乎完全相同——类型为`notebook`的项目可以点击，而类型为`static`的项目不能点击)。*

# *当简化适得其反*

*现在还有一些我们可以简化的东西。尽管我们的开关盒变短了一点，但看起来还是有点难看。*

*这是我们的`SidebarSection` 组件在应用了简化更改后的样子:*

*我们在这里可能会遇到的一个问题是，我们给了每个项目的渲染块太多的责任，让它负责将正确的道具传递给正确的组件。*

*如果我们是这样想的，那么这样写可能更好:*

*现在，我们进一步将`SidebarSection`简化为只负责调用`getProps`来提供相关的道具，并根据`item.type`分配正确的`Component`。我们现在可以对`getProps`进行单元测试，以确保他们根据`item.type`返回正确的道具。*

*这是简化 React 代码的好尝试吗？让我们来看看获得的好处与引入的缺点:*

*好处:*

1.  *`SidebarSection`减轻了自己的责任。*
2.  *`SidebarSection`变小了。*
3.  *我们可以清楚地看到什么道具被注入到哪个组件中。*
4.  *我们现在不必在`key={key}`中传递四次，而是像`<Component key={key}`一样传递*

*缺点:*

1.  *`SidebarSection`变小，但文件变大。*
2.  *一个实体(所有的东西都在`SidebarSection`里面)变成了三个实体(现在分成了`SidebarSection`、`onHoverAction`和`getProps`)。*
3.  *通过从上到下滚动来完成整个过程，给我们的鼠标施加更多的压力。*

# *这值得吗？*

*在我看来，如果最后一杆花的时间太长，那就不值得。这个故事的寓意是，当不需要太多努力就能提供多种好处时，简化代码绝对是值得的。*

*所以在我们的文章中，我支持前两个简化的尝试，而我对第三个有点犹豫不决。*

*然而，我们现在已经看到了在 React 中简化大型组件的力量。*

# *结论*

*这部分就结束了。我希望你发现这是有价值的，并期待在未来更多。*