<html>
<head>
<title>Stop Throwing Errors Everywhere. You Can Also Consider Result Objects</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">不要到处抛出错误。您还可以考虑结果对象</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/stop-throwing-errors-everywhere-you-can-also-consider-result-objects-4fb5936a9e2d?source=collection_archive---------0-----------------------#2022-06-11">https://betterprogramming.pub/stop-throwing-errors-everywhere-you-can-also-consider-result-objects-4fb5936a9e2d?source=collection_archive---------0-----------------------#2022-06-11</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="6f42" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">抛出错误的替代方法是返回这个</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/a4849f481998de1f4174b6b6efb6908a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*W-P5zuK5QhBuoWo3SZgQdA.png"/></div></div></figure><p id="623d" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated"><em class="lq">事情可能就这么简单。</em>抛出一个错误通知任何人出错。但是错误是例外，你需要像生鸡蛋一样处理它们。</p><p id="5700" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">生鸡蛋的替代品是结果对象。您可以更精确地控制它们的处理。而抛出异常会在代码中形成一条新的路径，这条路径只能用<code class="fe lr ls lt lu b">try-catch</code>语句捕获。</p><h1 id="e259" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">每个程序的3个路径实质路径</h1><p id="9a17" class="pw-post-body-paragraph ku kv it kw b kx mn ju kz la mo jx lc ld mp lf lg lh mq lj lk ll mr ln lo lp im bi translated">你必须考虑任何程序都可能采取的3条一般路径:</p><ol class=""><li id="590d" class="ms mt it kw b kx ky la lb ld mu lh mv ll mw lp mx my mz na bi translated">快乐之路</li><li id="8002" class="ms mt it kw b kx nb la nc ld nd lh ne ll nf lp mx my mz na bi translated">替代路径</li><li id="b0fd" class="ms mt it kw b kx nb la nc ld nd lh ne ll nf lp mx my mz na bi translated">异常路径</li></ol><p id="a300" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">老实说，第三个问题被遗忘的次数远远超过了它应该被遗忘的次数。永远永远。当我们最终使代码工作并完成特性时，你和我总是很高兴。谁在乎第三条路？！</p><p id="7e79" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">除非您是在TDD(测试驱动开发)之后进行开发，否则情节会发生转折。<strong class="kw iu">让它“消失”！🚬</strong></p><h1 id="cd45" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">为什么还要让常规错误消失呢？</h1><p id="21c8" class="pw-post-body-paragraph ku kv it kw b kx mn ju kz la mo jx lc ld mp lf lg lh mq lj lk ll mr ln lo lp im bi translated">例外的代价可能不是很熟悉，但它们是沉重的。</p><p id="b58c" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">后台正在进行大量的计算。抛出异常时，每次都会生成当前程序执行的调用栈。这无疑是一项昂贵的行动。现在，如果调用栈对你或程序流程不重要，<em class="lq">为什么还要抛出一个严重的计算错误呢？</em></p><p id="0b44" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">此外，异常真的是处理<em class="lq">错误的唯一方式吗？</em>需要一点实践来确定什么时候<em class="lq">异常</em>是合适的，什么时候<em class="lq">结果对象</em>适合“错误处理”</p><p id="9b2c" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">仅仅因为理论上有一个程序性错误，并不一定意味着它是一个戏剧性的错误。通常，您只想指出用户输入了错误的内容。尤其是这种输入可能无法处理，导致代码崩溃。</p><p id="3433" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">现在你有了:Result <em class="lq"> Objects </em>应该被任何一个像投手投球一样抛出错误的开发人员所考虑。</p></div><div class="ab cl ng nh hx ni" role="separator"><span class="nj bw bk nk nl nm"/><span class="nj bw bk nk nl nm"/><span class="nj bw bk nk nl"/></div><div class="im in io ip iq"><h1 id="25e7" class="lv lw it bd lx ly nn ma mb mc no me mf jz np ka mh kc nq kd mj kf nr kg ml mm bi translated">如何让例外路径消失</h1><p id="9955" class="pw-post-body-paragraph ku kv it kw b kx mn ju kz la mo jx lc ld mp lf lg lh mq lj lk ll mr ln lo lp im bi translated">如果没有被捕获，您将返回一个<code class="fe lr ls lt lu b">Result&lt;T, E&gt;</code>对象，而不是抛出导致程序崩溃的错误。类似铁锈。</p><p id="9cad" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">在你阅读解释之前，试着理解下面的代码。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ns nt l"/></div></figure><p id="4517" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">方法<code class="fe lr ls lt lu b">AddMusicAlbum</code>的结果被一个<code class="fe lr ls lt lu b">Result</code>类封装。结果是<em class="lq">快乐路径</em>中的实际返回参数或<em class="lq">异常</em>路径<em class="lq">中的错误描述</em>。</p><p id="aa12" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">无论发生什么(成功或错误)，您将总是得到相同的对象，但是写入了不同的属性。</p></div><div class="ab cl ng nh hx ni" role="separator"><span class="nj bw bk nk nl nm"/><span class="nj bw bk nk nl nm"/><span class="nj bw bk nk nl"/></div><div class="im in io ip iq"><h1 id="4afd" class="lv lw it bd lx ly nn ma mb mc no me mf jz np ka mh kc nq kd mj kf nr kg ml mm bi translated"><strong class="ak">如何设置你的结果&lt; T，E &gt;对象</strong></h1><p id="3f92" class="pw-post-body-paragraph ku kv it kw b kx mn ju kz la mo jx lc ld mp lf lg lh mq lj lk ll mr ln lo lp im bi translated">有几种方法来建模一个结果对象，这是一个基本的结构。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ns nt l"/></div></figure><p id="9296" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">所有的变体都有一个共同点，那就是它们都有一些属性可以用来查询操作的<code class="fe lr ls lt lu b">Boolean</code>状态(<code class="fe lr ls lt lu b">hasFailed</code>、<code class="fe lr ls lt lu b">wasSuccesful</code>)，还有一些属性可以用来获取具体的结果(<code class="fe lr ls lt lu b">Value</code>)或发生的错误(<code class="fe lr ls lt lu b">Errors</code>)。</p><p id="6d19" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">我提到<strong class="kw iu">这个词基本结构</strong>是因为<code class="fe lr ls lt lu b">errors</code>只是简单的<code class="fe lr ls lt lu b">strings</code>。这完全取决于您的上下文，但是您也可以自由使用特殊的错误类。一个例子是像这样按位组合错误掩码:<code class="fe lr ls lt lu b">00000010</code>可能意味着在将相册写入存储库时发生了错误。</p></div><div class="ab cl ng nh hx ni" role="separator"><span class="nj bw bk nk nl nm"/><span class="nj bw bk nk nl nm"/><span class="nj bw bk nk nl"/></div><div class="im in io ip iq"><ul class=""><li id="27b2" class="ms mt it kw b kx ky la lb ld mu lh mv ll mw lp nu my mz na bi translated"><strong class="kw iu">如何通过依赖快速实现</strong> — <a class="ae nv" href="https://www.google.com/search?q=result+error+librarires+nuget&amp;rlz=1C5CHFA_enDE911DE911&amp;oq=result+error+librarires+nuget&amp;aqs=chrome..69i57j33i10i160.5008j0j7&amp;sourceid=chrome&amp;ie=UTF-8" rel="noopener ugc nofollow" target="_blank">有一些NuGet包你可以直接使用。由于有了适当的文档，您很快就可以实现它们了。</a></li><li id="8e7b" class="ms mt it kw b kx nb la nc ld nd lh ne ll nf lp nu my mz na bi translated"><strong class="kw iu">自己实现(至少手写复制)</strong> — <a class="ae nv" href="https://jamiewright.dev/2020/06/23/result-pattern/" rel="noopener ugc nofollow" target="_blank">万一你想要的依赖更少，可以自己实现结果对象，不用费多大力气。核心功能用大约100行代码和测试快速编写而成。</a></li></ul></div><div class="ab cl ng nh hx ni" role="separator"><span class="nj bw bk nk nl nm"/><span class="nj bw bk nk nl nm"/><span class="nj bw bk nk nl"/></div><div class="im in io ip iq"><h1 id="2ca8" class="lv lw it bd lx ly nn ma mb mc no me mf jz np ka mh kc nq kd mj kf nr kg ml mm bi translated">比较引发错误的两种方式的异常</h1><p id="bc3a" class="pw-post-body-paragraph ku kv it kw b kx mn ju kz la mo jx lc ld mp lf lg lh mq lj lk ll mr ln lo lp im bi translated">既然我让你相信了结果对象。让我们回顾一下，看看你是否做对了每一件事。</p><p id="9d13" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">作为软件开发中的常规业务，无论是使用异常还是使用结果对象都不是最终的解决方案。这两种概念各有利弊。在某些情况下，传统的错误抛出是最好的。在其他情况下，使用结果对象。</p><h2 id="821a" class="nw lw it bd lx nx ny dn mb nz oa dp mf ld ob oc mh lh od oe mj ll of og ml oh bi translated">例外优势</h2><ul class=""><li id="776e" class="ms mt it kw b kx mn la mo ld oi lh oj ll ok lp nu my mz na bi translated">一旦抛出，它们就会在调用堆栈中向上移动几个调用级别</li><li id="e66a" class="ms mt it kw b kx nb la nc ld nd lh ne ll nf lp nu my mz na bi translated">中间的方法不需要任何处理错误的代码</li><li id="d36a" class="ms mt it kw b kx nb la nc ld nd lh ne ll nf lp nu my mz na bi translated">异常基本上更适合意外错误</li><li id="bb53" class="ms mt it kw b kx nb la nc ld nd lh ne ll nf lp nu my mz na bi translated">处理意外的异常，一个完美的地方是在中间件内部</li><li id="33e0" class="ms mt it kw b kx nb la nc ld nd lh ne ll nf lp nu my mz na bi translated">通过实现所需的尽可能多的细节来找到问题的根源</li><li id="8993" class="ms mt it kw b kx nb la nc ld nd lh ne ll nf lp nu my mz na bi translated">出现异常的最好地方是使用公共库(自己实现处理库对象的结果对象将是一场噩梦)</li></ul><h2 id="d12e" class="nw lw it bd lx nx ny dn mb nz oa dp mf ld ob oc mh lh od oe mj ll of og ml oh bi translated">结果对象优势</h2><ul class=""><li id="017a" class="ms mt it kw b kx mn la mo ld oi lh oj ll ok lp nu my mz na bi translated">验证来自外部系统的用户输入或数据变得更加容易访问(例如，具有用户反馈的前端)</li><li id="608c" class="ms mt it kw b kx nb la nc ld nd lh ne ll nf lp nu my mz na bi translated">预期会出现错误，但不会导致崩溃</li><li id="3d97" class="ms mt it kw b kx nb la nc ld nd lh ne ll nf lp nu my mz na bi translated">如果域模型禁止特定的操作——让用户知道</li><li id="1a84" class="ms mt it kw b kx nb la nc ld nd lh ne ll nf lp nu my mz na bi translated">用result对象调出面向域的代码，以消除与try-catch语句相关的样板代码。</li></ul></div><div class="ab cl ng nh hx ni" role="separator"><span class="nj bw bk nk nl nm"/><span class="nj bw bk nk nl nm"/><span class="nj bw bk nk nl"/></div><div class="im in io ip iq"><h1 id="3263" class="lv lw it bd lx ly nn ma mb mc no me mf jz np ka mh kc nq kd mj kf nr kg ml mm bi translated">不确定结果是对象还是抛出错误？</h1><blockquote class="ol om on"><p id="ce56" class="ku kv lq kw b kx ky ju kz la lb jx lc oo le lf lg op li lj lk oq lm ln lo lp im bi translated">“最小惊讶原则(T1)(<strong class="kw iu">POLA</strong>)，又名<strong class="kw iu">最小惊讶原则</strong>(或者是<strong class="kw iu">法则</strong>或<strong class="kw iu">法则</strong>)，适用于用户界面和软件设计。它建议系统的组件应该以大多数用户期望的方式运行。这种行为不应该让用户感到惊讶。以下是该原则的正式陈述:“如果一个必要的特征具有很高的惊奇因子，则可能需要重新设计该特征。”——<a class="ae nv" href="https://en.wikipedia.org/wiki/Principle_of_least_astonishment" rel="noopener ugc nofollow" target="_blank">来源</a></p></blockquote></div><div class="ab cl ng nh hx ni" role="separator"><span class="nj bw bk nk nl nm"/><span class="nj bw bk nk nl nm"/><span class="nj bw bk nk nl"/></div><div class="im in io ip iq"><h2 id="123b" class="nw lw it bd lx nx ny dn mb nz oa dp mf ld ob oc mh lh od oe mj ll of og ml oh bi translated">老实说…</h2><p id="f8c8" class="pw-post-body-paragraph ku kv it kw b kx mn ju kz la mo jx lc ld mp lf lg lh mq lj lk ll mr ln lo lp im bi translated">…必须指出，调用者必须显式检查返回值。没有其他人真正响应。发生的异常需要特殊处理。否则，应用程序将被运行时终止。这是你最不想发生的情况。</p><p id="3099" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">另一方面，如果返回的Result对象可能没有被计算，错误可能会被忽略。发生这种情况时，应用程序可能会出现不一致的状态。这甚至比运行时崩溃的最坏情况还要糟糕。</p><p id="4bf3" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated"><strong class="kw iu"> <em class="lq">你自己决定，但是你现在已经拥有了决定和发光的所有工具</em> </strong></p></div><div class="ab cl ng nh hx ni" role="separator"><span class="nj bw bk nk nl nm"/><span class="nj bw bk nk nl nm"/><span class="nj bw bk nk nl"/></div><div class="im in io ip iq"><h1 id="c6c4" class="lv lw it bd lx ly nn ma mb mc no me mf jz np ka mh kc nq kd mj kf nr kg ml mm bi translated">为了完整起见</h1><p id="6d4f" class="pw-post-body-paragraph ku kv it kw b kx mn ju kz la mo jx lc ld mp lf lg lh mq lj lk ll mr ln lo lp im bi translated">下面的代码片段处理将相册添加到数据库中的操作，您之前已经发现了结果对象。但是现在使用了异常。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ns nt l"/></div></figure><pre class="kj kk kl km gt or lu os ot aw ou bi"><span id="3cae" class="nw lw it lu b gy ov ow l ox oy"><strong class="lu iu">Want to Connect?</strong></span><span id="c39b" class="nw lw it lu b gy oz ow l ox oy"><a class="ae nv" href="https://arnoldcodeacademy.ck.page/8rulesforsuccessfuldevelopers" rel="noopener ugc nofollow" target="_blank"><strong class="lu iu"><em class="lq">Get 8 long-lasting golden rules for successful developers that are worth several pay raises.</em></strong></a></span></pre></div></div>    
</body>
</html>