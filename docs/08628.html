<html>
<head>
<title>3 Excuses Developers Give To Avoid TypeScript — and the Better Reasons They Should Use It</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">开发人员避免使用TypeScript的3个借口——以及他们应该使用它的更好的理由</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/the-bad-reasons-people-avoid-typescript-and-the-better-reasons-why-they-shouldnt-86f8d98534de?source=collection_archive---------4-----------------------#2021-05-24">https://betterprogramming.pub/the-bad-reasons-people-avoid-typescript-and-the-better-reasons-why-they-shouldnt-86f8d98534de?source=collection_archive---------4-----------------------#2021-05-24</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="fbce" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">在了解TypeScript的好处之前，我们先了解一下为什么有人不喜欢它</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/44fcfda6349feb108de91a4905e8702b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*PrJn8oKDGlg2NCV0"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">在<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上<a class="ae ky" href="https://unsplash.com/@attentieattentie?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">attendee</a>拍照</p></figure><p id="b829" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我最近给<a class="ae ky" rel="noopener ugc nofollow" target="_blank" href="/its-time-we-admit-the-truth-about-javascript-98d197c0f1ec">写了一篇关于JavaScript和Node.js优势的文章</a>，在这篇文章中，我提出了一个明显有争议的观点:由于更大的可伸缩性和改进的开发人员体验，开发人员应该更喜欢TypeScript而不是JavaScript。</p><p id="bff3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">几个小时内，攻击TypeScript(和我的文章)的愤怒回应开始淹没我的收件箱。这些回答中有许多认为类型系统的好处微不足道，这让我怀疑他们还没有在一个大型项目中使用过像样的类型脚本实现。</p><p id="f119" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">不用说，如果你没有使用过TypeScript或者只看到了一个很差的实现，我要求你在批评它之前完全用TypeScript编写一个大型应用程序。当您尝试它时，您可能会像许多TS开发人员一样，发现它的好处远远超过任何成本。</p><p id="e6ae" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我稍后将更详细地讨论其中的一些好处。但是首先，我想解决一些反复提到的避免使用TypeScript的原因。</p><h1 id="cc7b" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">“它使JavaScript更像Java和。净”</h1><p id="74ec" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">首先，我不确定这是真的。当然，Java和TypeScript有类型，而JavaScript没有。除此之外，我不相信TypeScript真的与面向对象编程有任何关系——至少与JavaScript本身没有关系。</p><p id="8f30" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">优秀的JavaScript开发人员会警告你避免使用面向对象的风格。这个建议同样适用于TypeScript，类型系统的使用不应该影响设计模式。</p><p id="3ee8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">但是，当然，让我们承认对于那些来自面向对象背景的人来说，TypeScript感觉更熟悉。那又怎样？除非你蔑视Java开发人员(有些JavaScript开发人员可能如此)，否则更好的可访问性是我们应该欢迎的改进。</p><p id="90c1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我怀疑一些提出这种对TypeScript的批评的人害怕被泛型和其他受面向对象语言启发的高级概念淹没。事实上，TypeScript的开发是由领导C#开发的同一位微软工程师领导的——但是工程师们小心翼翼地只借用那些对TypeScript也有意义的特性。</p><p id="7a27" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">底线是:<strong class="lb iu"> TypeScript没有改变JavaScript，它只是增加了它</strong>。不要因为架构的原因而避免使用TypeScript，因为它对你的软件架构几乎没有影响。</p><h1 id="be21" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">“它使代码变得不必要地冗长/复杂”</h1><p id="9ff8" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">冗长是使用TypeScript的一项重要成本。不可否认的是，TypeScript项目将比其等效的JavaScript代码有更多的行。</p><p id="ed0d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">复杂性是一个完全不同的问题，一个更加主观的问题。是的，TypeScript意味着更多的东西，但这些东西是元数据——它有助于描述你正在操作的数据，这总体上减少了认知负荷。</p><p id="3a15" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我经常用的一个比喻是试管。在JavaScript中，变量有名字(试管上的标签)，但很难洞察名字背后实际存储了什么(试管中的物质)。有了TypeScript，我们不仅有了名字，还可以看到管子(类型)内部的物质。</p><p id="594e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">想象一下，你被要求用不透明的试管进行实验。你必须写下描述性的标签，极其小心地混合正确的化学物质，并记录下你的所有步骤。类似地，开发一个复杂的JavaScript应用程序需要给变量起一个描述性的名字，并且在引用这些变量时需要手动检查(或记忆)类型。</p><p id="5de9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果你忘了试管里有什么呢？你必须原路返回才能弄清楚里面有什么。同样，如果您忘记了一个JavaScript变量的类型，您将不得不挖掘创建它的代码来确定类型。</p><p id="7d02" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">所以你可以说，在某种意义上，使用透明试管让你的实验变得更加复杂。虽然这意味着需要理解和处理更多的信息，但TypeScript通过减少记忆和消除打开不相关文件来手动检查类型的需要，提高了开发速度。</p><h1 id="88d3" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">“这只是用来炒作的”</h1><p id="667b" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">这是一个愚蠢的论点，我甚至不愿意反驳。但是因为数量惊人的回复包含了这种推理的一些变体，所以我决定简要地解决它。</p><p id="25f3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">例如，一个回答是，“太多的开发人员喜欢精英主义和为了能够而过度复杂的东西。”</p><p id="79c9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">除此之外，我没什么可说的了:如果你真的认为我(或任何有能力的软件工程师)使用类型系统来有意增加复杂性，目的是给其他人留下深刻印象，这在我看来，你更关心你作为工程师的外表，而不是你产品的质量。</p><p id="add8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">无论如何，如果我真的想毫无理由地挑战自己，我会尝试编写一个没有 TypeScript的复杂应用<em class="ms">。</em></p><h1 id="39ee" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">脚本不需要类型。应用程序有</h1><p id="d3cc" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">如果你想用鼠标拖动一个div，你可以写一个小的JS脚本。添加类型是没有意义的。在编写大多数脚本时——就我们的目的而言，简单的程序调用内置方法并处理很少的数据——JavaScript通常就足够了，添加类型会不必要地增加冗长性。</p><p id="f90f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">对于较大的应用程序来说并非如此，在这些应用程序中，可伸缩的代码和资源的有效利用依赖于复杂的、定义良好的数据结构。随着应用程序变得越来越复杂，越来越多的开发人员为同一个代码库做出贡献，如果没有精确的定义，这些数据结构将变得难以管理。</p><p id="4056" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">TypeScript允许我们将数据结构写下来，而不必记忆或手动引用数据结构。我们的IDE和编译器将捕捉我们所犯的任何错误，除了确保我们的代码不会在运行时由于意外或不兼容的类型而遇到错误。</p><p id="1987" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这里有两个常见的例子来说明TypeScript是多么有用。</p><h1 id="1c56" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">1.Vue:谜一般的"<code class="fe mt mu mv mw b">payload"</code></h1><p id="67f8" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">Vuex商店为Vue应用程序提供了一个中央状态，帮助开发人员避免在组件之间随意传递道具。</p><p id="19a7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">为了修改存储的状态，我们定义了一个带有两个参数的变异函数:当前的<code class="fe mt mu mv mw b">state</code>和一个<code class="fe mt mu mv mw b">payload</code>，它包含了关于期望的变化的信息。</p><p id="03f2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">假设我们希望保留一个表示为JavaScript对象的待办事项的中央状态。我们可以用一个空数组初始化我们的状态，就像这样:</p><pre class="kj kk kl km gt mx mw my mz aw na bi"><span id="9819" class="nb lw it mw b gy nc nd l ne nf">state = {<br/>  todos: [],<br/>}</span></pre><p id="4488" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在我们可以定义一个变异，允许我们更新这个待办事项列表:</p><pre class="kj kk kl km gt mx mw my mz aw na bi"><span id="2a99" class="nb lw it mw b gy nc nd l ne nf">updateTodos: (state, payload) =&gt; {<br/>  state.todos = payload;<br/>}</span></pre><p id="d887" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">很简单。但是我们必须从另一个模块调用这个突变，比如一个组件。没有显式类型，我们需要猜测(或回忆)一下<code class="fe mt mu mv mw b">updateTodos</code>需要一个<code class="fe mt mu mv mw b">Todo</code>对象的列表。不太好。</p><p id="8999" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">它不止于此。假设另一个开发人员加入了我们的团队，我们要求他们修改<code class="fe mt mu mv mw b">updateTodos</code>变异，这样它也可以更新状态的另一部分，就像一个跟踪完整待办事项数量的变量(由<code class="fe mt mu mv mw b">someTodo.isComplete</code>给出)。</p><p id="b67d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">为此，开发人员必须首先确定<code class="fe mt mu mv mw b">payload</code>的类型，包括以下步骤:</p><ol class=""><li id="4424" class="ng nh it lb b lc ld lf lg li ni lm nj lq nk lu nl nm nn no bi translated">开发者必须假设<code class="fe mt mu mv mw b">updateTodos</code>的当前版本是准确的(即<code class="fe mt mu mv mw b">payload</code>的类型与<code class="fe mt mu mv mw b">state.todos</code>的类型相同)。</li><li id="40f6" class="ng nh it lb b lc np lf nq li nr lm ns lq nt lu nl nm nn no bi translated">开发人员必须一直滚动到初始状态对象，以检查<code class="fe mt mu mv mw b">todos</code>的类型(或者在代码中搜索已经使用了<code class="fe mt mu mv mw b">updateTodos</code>变异的地方，如果是的话)。</li><li id="ec6a" class="ng nh it lb b lc np lf nq li nr lm ns lq nt lu nl nm nn no bi translated">开发人员必须找出每个待办事项的结构，才能知道如何确定它是否完整。</li></ol><p id="1866" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在这一切之后，由于一路上所做的所有假设，开发人员除了测试之外，没有其他方法来检查解决方案的正确性。</p><p id="710c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">通过定义一个<code class="fe mt mu mv mw b">Todo</code>类型并将有效载荷的类型指定为<code class="fe mt mu mv mw b">Todo[]</code>，我们解决了所有这些问题。</p><p id="1cbc" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">毫无疑问，至少在这种情况下，TypeScript为开发团队提供了一个巨大的——也是有价值的——好处，它提高了准确性，减少了麻烦，加快了开发，降低了出错的几率。</p><h1 id="c8ae" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">2.键入JSON响应</h1><p id="9217" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">许多JavaScript应用程序会向远程API发出网络请求来获取数据。通常，当使用这些API时，我们会在开发时知道我们期望收到的响应的结构。</p><p id="9f95" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">例如，假设我们从后端应用程序获取数据。我们的后端团队已经编写了全面的文档，详细描述了每个请求和响应对象的形状。</p><p id="cf9a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">它注意到每个响应具有以下结构:</p><pre class="kj kk kl km gt mx mw my mz aw na bi"><span id="a452" class="nb lw it mw b gy nc nd l ne nf">{<br/>  "status": "success" or "failure",<br/>  "data": {<br/>    ...<br/>  }<br/>}</span></pre><p id="f33f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这会产生以下TypeScript数据定义:</p><pre class="kj kk kl km gt mx mw my mz aw na bi"><span id="26e2" class="nb lw it mw b gy nc nd l ne nf">interface ApiResponse {<br/>  status: "success" | "failure";<br/>  data: any;<br/>}</span></pre><p id="183b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">然后我们可以参数化<code class="fe mt mu mv mw b">ApiResponse</code>来指定它的<code class="fe mt mu mv mw b">data</code>字段的类型:</p><pre class="kj kk kl km gt mx mw my mz aw na bi"><span id="9eb1" class="nb lw it mw b gy nc nd l ne nf">interface ApiResponse&lt;T&gt; {<br/>  status: "success" | "failure";<br/>  data: T;<br/>}</span></pre><p id="d4d3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在，我们的API方法在返回类型上可以更加具体:例如，我们可以返回一个用户列表的<code class="fe mt mu mv mw b">ApiResponse&lt;User[]&gt;</code>，而不是仅仅返回一个<code class="fe mt mu mv mw b">ApiResponse</code>。</p><p id="befd" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们来看看这是如何提高开发速度的。假设您有一些从后端获取用户列表的方法:</p><pre class="kj kk kl km gt mx mw my mz aw na bi"><span id="c6a6" class="nb lw it mw b gy nc nd l ne nf">async function getUsers(): Promise&lt;ApiResponse&lt;User[]&gt;&gt; { <br/>  ... <br/>}</span></pre><p id="4b29" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们在组件中使用它来获取用户:</p><pre class="kj kk kl km gt mx mw my mz aw na bi"><span id="320c" class="nb lw it mw b gy nc nd l ne nf">const users = await getUsers();</span></pre><p id="abe1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">然后我们可以映射用户以获得他们的名字:</p><pre class="kj kk kl km gt mx mw my mz aw na bi"><span id="7167" class="nb lw it mw b gy nc nd l ne nf">const userNames = users.map(u =&gt; u.name);</span></pre><p id="8ece" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">对吗？</p><p id="20fd" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">不对。你发现错误了吗？可能没有，但是静态类型检查有。我们忘记了响应包含我们需要首先处理的<code class="fe mt mu mv mw b">success</code>和<code class="fe mt mu mv mw b">data</code>字段。多亏了TypeScript，我们的IDE将立即捕捉到这个错误。</p><p id="f65a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">对于处理API响应的新JavaScript开发人员来说，这是一个常见的“陷阱”。</p><p id="35af" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">随着您获得JavaScript经验，您将养成每次都手动检查API客户端响应类型的习惯。但是，当TypeScript为您做这些时，为什么还要费心呢？它可以节省时间，防止疏忽。</p><p id="30c3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在想象一下，您正在从一个体育API中提取数据。您使用端点<code class="fe mt mu mv mw b">/upcoming</code>来拉动即将到来的体育比赛。API文档提供了以下响应结构:</p><pre class="kj kk kl km gt mx mw my mz aw na bi"><span id="95dc" class="nb lw it mw b gy nc nd l ne nf">{<br/>  "id": 247283,<br/>  "name": "New York Knicks at Atlanta Hawks",<br/>  "date": "2021-05-23T02:00:00+00:00",<br/>  "competitors": ["New York Knicks", "Atlanta Hawks"],<br/>  "venue": "Madison Square Garden",<br/>  ...<br/>}</span></pre><p id="ab92" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果不使用TypeScript，您将不得不不断地引用这些文档来了解响应中的字段及其类型。如果有多个团队成员在处理这个代码，你必须与你的团队共享这些文档。</p><p id="221c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这意味着更多的时间，更多的努力，以及更大的机会，有人在这个过程中犯错误。糟糕，糟糕，甚至更糟。</p><p id="ba3b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">但是对于TypeScript，只需添加一个类型定义:</p><pre class="kj kk kl km gt mx mw my mz aw na bi"><span id="cc5c" class="nb lw it mw b gy nc nd l ne nf">interface SportsApiResponse {<br/>  id: number;<br/>  name: string;<br/>  date: string;<br/>  competitors: [string, string];<br/>  venue: string;<br/>}</span></pre><p id="222f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在，任何时候您使用<code class="fe mt mu mv mw b">SportsApiResponse</code>时，您都会确切地知道哪些字段是可用的以及它们的类型。您将节省大量的时间，并将拼错字段名或将<code class="fe mt mu mv mw b">string</code>误认为<code class="fe mt mu mv mw b">number</code>的可能性降至最低。</p><p id="33a4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">是不是比较啰嗦？绝对的。但每多一个角色都值得。</p><h2 id="444e" class="nb lw it bd lx nu nv dn mb nw nx dp mf li ny nz mh lm oa ob mj lq oc od ml oe bi translated">…以及更多更多</h2><p id="9fe5" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">TypeScript提供的生活质量改善只会随着应用程序的复杂性和团队规模的增加而增加。即使您在开始一个项目或处理一个小项目时觉得不太需要TypeScript，但是如果您预计到未来的增长，您仍然应该使用它。</p><h1 id="3c03" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">权力带来责任</h1><p id="2c9e" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">像任何技术一样，误用TypeScript会导致代价太大，以至于无法证明其好处。许多对我最近的文章持批评态度的人回忆说，他们从事的项目的TypeScript实现很差，导致了极其冗长和混乱的代码。但是，我们应该把这归因于TypeScript的误用而不是它的缺点。</p><p id="18b0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">TypeScript误用通常是由自信的开发人员编写的晦涩、不清楚或过于抽象的类型造成的，这些开发人员坚持使用“更好”的解决方案，这使不太舒服的TypeScript开发人员感到困惑。因此，这些开发人员需要更多的时间来掌握代码的复杂性，并且——当他们不可避免地被令人困惑的类型所淹没时——放弃他们的工作，回到他们的JavaScript舒适区。这会导致误用或未使用的类型，导致不一致和不准确的代码，并给所有人带来令人沮丧的体验。</p><p id="c032" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">幸运的是，如果你坚持下面的指导方针，你可以避免这些常见的陷阱。</p><h2 id="49ce" class="nb lw it bd lx nu nv dn mb nw nx dp mf li ny nz mh lm oa ob mj lq oc od ml oe bi translated">使用一致且不言自明的类型名</h2><p id="d4cb" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">给你的所有类型起一个有明显含义的名字。避免使用通用的、难以描述的词，如“数据”或“对象”如果你不能为一个类型产生一个简单且不言自明的名字，那么它可能根本就不应该是一个类型。</p><p id="7ced" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">此外，注意确保类型名称之间的一致性。命名的一致性有助于团队中的其他成员(以及您)进行类比，并理解不同类型之间复杂的关系。</p><p id="f0d2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">例如，在我的React项目中，我总是为组件的道具定义一个接口。对于名为<code class="fe mt mu mv mw b">ComponentName</code>的组件，我严格遵守了<code class="fe mt mu mv mw b">ComponentNameProps</code>的命名约定。</p><p id="215b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这样，当我看到一个名为<code class="fe mt mu mv mw b">XYProps</code>的类型时，我——以及我团队中的其他人——可以确定这个类型定义了组件<code class="fe mt mu mv mw b">XY</code>的道具。</p><h2 id="f638" class="nb lw it bd lx nu nv dn mb nw nx dp mf li ny nz mh lm oa ob mj lq oc od ml oe bi translated">不要指定推断类型</h2><p id="c84d" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">TypeScript令人印象深刻的静态类型检查系统的一个基本特性是<strong class="lb iu">类型推断</strong>。TypeScript根据每个变量的初始值以及任何重新分配或条件，推断出可以分配给每个变量的最具体的类型。</p><p id="0aed" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">假设我们有<code class="fe mt mu mv mw b">users</code>，一组<code class="fe mt mu mv mw b">User</code>对象。然后，我们可以提取具有特定ID的用户:</p><pre class="kj kk kl km gt mx mw my mz aw na bi"><span id="f436" class="nb lw it mw b gy nc nd l ne nf">const user = users.find(u =&gt; u.id === 1);</span></pre><p id="34bf" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">因为<code class="fe mt mu mv mw b">users</code>是<code class="fe mt mu mv mw b">User[]</code>类型的——并且基于<code class="fe mt mu mv mw b">Array.find()</code>的签名——TypeScript知道<code class="fe mt mu mv mw b">user</code>将是<code class="fe mt mu mv mw b">User</code>。因此键入它是多余的:</p><pre class="kj kk kl km gt mx mw my mz aw na bi"><span id="542b" class="nb lw it mw b gy nc nd l ne nf">const user: User = users.find(u =&gt; u.id === 1);</span></pre><p id="8b6f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">当它不提供TypeScript任何附加信息时，请避免指定类型。这只会增加冗长，在某些情况下，会导致更多的混乱。</p><p id="d6aa" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">想检查变量的类型？如果您使用的是支持TypeScript的IDE，只需将鼠标悬停在变量上，工具提示就会出现，显示类型。</p><h2 id="4e2a" class="nb lw it bd lx nu nv dn mb nw nx dp mf li ny nz mh lm oa ob mj lq oc od ml oe bi translated">避免不必要的抽象</h2><p id="bab8" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">抽象是可伸缩软件不可或缺的一部分，因为它们简化了模块的组成并减少了代码重复。</p><p id="205b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">然而，许多新的软件工程师错误地认为这意味着抽象越多越好。过多的抽象导致类型和模块没有明确的目的，复杂的代码甚至会让有经验的开发人员感到困惑。</p><p id="cb62" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">尽管抽象有助于保持代码的干爽，但你很少会为了重用代码而使用它们。它们应该服务于一些清晰的逻辑角色，比如表示一个通用的数据结构，或者为逻辑上不同的子任务提供可重用的层。</p><p id="f34b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们回到上面我们对<code class="fe mt mu mv mw b">ApiResponse&lt;T&gt;</code>的定义作为例子。我们可以为<code class="fe mt mu mv mw b">data</code>属性定义一个类型，为<code class="fe mt mu mv mw b">status</code>属性定义一个类型，并使用交集类型来定义<code class="fe mt mu mv mw b">ApiResponse&lt;T&gt;</code>:</p><pre class="kj kk kl km gt mx mw my mz aw na bi"><span id="4edb" class="nb lw it mw b gy nc nd l ne nf">interface ApiResponseData&lt;T&gt; {<br/>  data: T;<br/>}</span><span id="82e3" class="nb lw it mw b gy of nd l ne nf">interface ApiResponseStatus {<br/>  status: "success" | "failure";<br/>}</span><span id="3378" class="nb lw it mw b gy of nd l ne nf">type ApiResponse&lt;T&gt; = ApiResponseData&lt;T&gt; &amp; ApiResponseStatus;</span></pre><p id="3696" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这实现了与上面相同的目的，增加了两种类型，我们现在可以在其他地方重用。这是好事，对吧？</p><p id="7b53" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">不一定。没有对这些较小类型的明确使用，它们的定义只会使我们的类型定义变得复杂，并增加不熟悉代码库的开发人员的困惑。</p><p id="0d8f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">简洁是编程的灵魂。仅定义具有清晰和明显目的的必要类型。也就是说，一般来说，您在应用程序中定义的每个变量都应该有一个特定的类型(除了<code class="fe mt mu mv mw b">any</code>)。</p></div><div class="ab cl og oh hx oi" role="separator"><span class="oj bw bk ok ol om"/><span class="oj bw bk ok ol om"/><span class="oj bw bk ok ol"/></div><div class="im in io ip iq"><p id="3b40" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">不要把我对TypeScript的辩护误认为是对其无处不在的采用的支持。有一些令人信服的理由来避免它，正如任何决定一样，首席工程师应该权衡利弊。</p><p id="810a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">然而，我们应该拒绝这样的观点，即TypeScript毫无理由地增加了冗长性，或者只是为了增加与面向对象语言的相似性。TypeScript建立在JavaScript之上:例如，如果您编写函数式JS代码，您的类型应该补充它。</p><p id="664b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">TypeScript不应该影响架构决策或者任何JavaScript代码。相反，它应该提供帮助开发人员更好地理解代码的目的和结构所必需的最少的元数据。</p><p id="304a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">像任何其他投资一样，随着应用程序和开发团队的增长，实现TypeScript的初始成本(有时令人沮丧)是值得的。如果使用得当，TypeScript会产生提供卓越用户体验的软件，以及同样重要的开发人员实际上想要使用的代码。</p></div></div>    
</body>
</html>