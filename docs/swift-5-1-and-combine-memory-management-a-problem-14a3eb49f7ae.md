# Swift 5.1 和组合内存管理:一个问题？

> 原文：<https://betterprogramming.pub/swift-5-1-and-combine-memory-management-a-problem-14a3eb49f7ae>

![](img/9b95468332d2bcf0ef5a5e6fd436b985.png)

## Combine 到底需要一个 CancelBag 吗？

所以我一直在试验 Swift 5.1 和 Combine，苹果新的反应式框架…我相信我发现了一个问题。

**更新:这个问题存在，但似乎在 Xcode 11 Beta 6 中已经被修复。**

**当 CombineTest 超出范围时，闭包捕获的所有变量都会被释放。有问题的接收器现在返回 AnyCancellable，它自动定义并拆除订阅流**。

# 设置

迄今为止，我看到的大多数代码样本都假设 Combine 自动管理其订阅，并且不需要类似 RxSwift 的 DisposeBag。事实上，这甚至在赫尔曼·班肯关于联合收割机的优秀文章“第一印象”中被提及。

> 首先，在 Rx 订阅结果中有一个 Disposable，它允许你停止订阅，Combine 没有这个。相反，如果您不想接收进一步的更新，您可以取消对发布者链的引用。

联合收割机没有一次性用品是真的。

不过，它确实有苹果公司所说的可取消功能。

## 可取消

当您使用接收器订阅出版商时，您会收到一个用于“管理”订阅的可取消列表:

反过来，可取消是一个非常简单的协议:

根据文件，可取消是一个协议，表明一项活动或行动可能被取消。有点自我指涉，但在意料之中。此外，调用`cancel()`“释放任何分配的资源。”它还会停止诸如计时器、网络访问或磁盘 I/O 等副作用。

然而，苹果倾向于暗示，这是一个方便的功能，人们可以在极少数需要的情况下使用它来管理(即取消)订阅，而不是一直需要它。

**更新:Sink 现在返回 AnyCancellable，当 cancel 被调用或 cancellable 定义时，它会自动取消订阅。**

但事实真的是这样吗？

# 实验

看看下面这个类，它基本上是在发布时发出信号的:

现在来看看下面的合并示例代码:

这里我们创建了一个使用两个定义对象的类对象。第一个， *d1，*由类本身捕获。

现在查看 subscribe 函数内部，您会看到我已经做了一些设置，使得 *d2* 被 sink 闭包捕获。

运行`CombineTest.test()`，您将看到以下输出:

```
0 2
1 2
2 2
deinit - 1
deinit - 2
```

这是意料之中的。我们的初始值 0 打印，随后是 1 和 2，当我们发送它们。

还要注意，我们的 deinit 函数打印两次，一次是在 *t* 超出范围时为 *d1* 打印，一次是在关闭被释放时为 *d2* 打印。

## 问题是

现在删除或注释掉`t.cancellable?.cancel()`语句，重新运行代码，你会发现当 *t* 超出范围时 *d1* 像以前一样释放，但是 *d2* 似乎没有这样做:

```
0 2
1 2
2 2
deinit - 1
```

将测试更改为:

您将看到 *d2* 似乎仍然没有释放，即使流已经完成。

## 扩展示例

让我们扩展我们的例子，加入一个 map 闭包，它捕获另一个名为 *d3:* 的 Deinit 对象

运行它，当调用 cancel 时，您会得到类似的结果:

```
0 3
0 2
1 3
1 2
2 3
2 2
deinit - 3
deinit - 1
deinit - 2
```

而下面的时候就不是了:

```
0 3
0 2
1 3
1 2
2 3
2 2
deinit - 1
```

当 *t* 超出我们测试函数的范围时，sink 闭包和 map 闭包都没有释放。

# 我们有问题吗？

这不是结论性的，但它似乎指向了 Combine 的内存管理代码中的一个 bug，或者强烈表明 Combine 订阅确实需要某种形式的内存管理。

**更新:是一个 bug。由 AnyCancellable 修复。**

再次引用赫尔曼的话:

> 有趣的是，Combine**不**依赖于基础类型，事实上，它位于比基础更低的层次。与苹果工程师交谈，听起来他们真的已经优化了这个框架。引用一位苹果工程师的话:“RxSwift 和 Combine 的内存型号差别很大。联合收割机是专为性能而生的。”

像 SwiftUI 一样，Combine 很大程度上基于结构，并为其大多数操作符使用值语义，尽管主体很大程度上似乎是类。这使得 Combine 和 SwiftUI 都非常轻量级，并且避免了大量的内存分配。

对 Combine 做同样的事情是有意义的，并允许它避免 RxSwift 中固有的许多 Sink/Disposable 链分配。

然而，如果是这样的话，那么 Combine 如何知道何时释放它的闭包和其他捕获的数据呢？毕竟，结构没有告诉我们它们何时被释放的定义函数。

**更新:AnyCancellable 是一个类，它有一个 deinit 函数。**

也就是说，当捕获引用的最后一个值超出范围时，任何被捕获的引用(如闭包)*都应该*释放。

或者说，如果一个 cancellable 有引用语义并在释放时定义了它，那么在上面的例子中，当 Cancellable 超出范围时，上面的链为什么不释放呢？

一句话:Combine 到底需要一个 CancelBag 吗？

# 完成块

这让我很困扰，所以如果你有什么要补充的或者你能帮忙澄清的，请发表评论。

我也会接受提问，但我和苹果以外的其他人一样，仍然在消化他们在 2019 年 WWDC 上放弃的一切。

直到下次。

编辑:Xcode 11 Beta 2 刚刚退出，并演示了同样的问题。

更多关于 Combine 和 SwiftUI 的恶作剧可以在 [SwiftUI 101:如何不初始化可绑定对象](https://medium.com/@michaellong/swiftui-101-how-not-to-initialize-bindable-objects-6e539d1b5344)中找到。