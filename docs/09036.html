<html>
<head>
<title>How To Handle One-to-Many Relationships in NoSQL Databases</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何处理NoSQL数据库中的一对多关系</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/how-to-handle-one-to-many-relationships-in-nosql-databases-23627d404cb0?source=collection_archive---------5-----------------------#2021-07-09">https://betterprogramming.pub/how-to-handle-one-to-many-relationships-in-nosql-databases-23627d404cb0?source=collection_archive---------5-----------------------#2021-07-09</a></blockquote><div><div class="fc ii ij ik il im"/><div class="in io ip iq ir"><div class=""/><div class=""><h2 id="0bfb" class="pw-subtitle-paragraph jr it iu bd b js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki dk translated">3数据建模策略</h2></div><figure class="kk kl km kn gu ko gi gj paragraph-image"><div role="button" tabindex="0" class="kp kq di kr bf ks"><div class="gi gj kj"><img src="../Images/7889ab9842c15cb1b43cafaed0412045.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*PS-PNvXziC1P9EelHGKC7g.jpeg"/></div></div><p class="kv kw gk gi gj kx ky bd b be z dk translated">在<a class="ae kz" href="https://unsplash.com/s/photos/many?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上由<a class="ae kz" href="https://unsplash.com/@zmachacek?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">zdenk Macháek</a>拍摄的照片。</p></figure><p id="d442" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">NoSQL的数据建模比普通的SQL更复杂。有时候，这违背了我们的直觉。尤其是作为一名SQL出身的人，我发现很难理解像AWS DynamoDB或Firebase这样的NoSQL数据库中数据建模背后的各种原因。</p><p id="306d" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">在本文中，我将解释建模一对多关系的三种策略以及可以使用它们的场景。</p></div><div class="ab cl lw lx hy ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="in io ip iq ir"><h1 id="aaee" class="md me iu bd mf mg mh mi mj mk ml mm mn ka mo kb mp kd mq ke mr kg ms kh mt mu bi translated">反规范化+复杂属性</h1><p id="5bd2" class="pw-post-body-paragraph la lb iu lc b ld mv jv lf lg mw jy li lj mx ll lm ln my lp lq lr mz lt lu lv in bi translated">对于SQL开发人员来说，反规范化是一个肮脏的词。但在NoSQL世界，它有自己的使用案例。</p><p id="0afc" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">假设你有一些客户在月底支付一定的费用。他们可以有各种支付选择，费用因客户而异。</p><p id="cc4f" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">你是做什么的？您是否要创建一个单独的表，将客户与付款方式对应起来？</p><p id="81d2" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">不。相反，我们将付款方式作为一个数组存储在customer表中。</p><pre class="kk kl km kn gu na nb nc nd aw ne bi"><span id="054e" class="nf me iu nb b gz ng nh l ni nj">Customer<br/>|<br/>|-- Name<br/>|-- Address<br/>|-- PaymentMethods: ['Cash' , 'Credit Card', 'Debit Card']</span></pre><p id="02a5" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">这里，我们使用了一个名为<code class="fe nk nl nm nb b">PaymentMethods</code>的复合属性，它包含一组可用的支付选项。</p><h2 id="36dc" class="nf me iu bd mf nn no dn mj np nq dp mn lj nr ns mp ln nt nu mr lr nv nw mt nx bi translated">当它工作的时候</h2><ul class=""><li id="12f2" class="ny nz iu lc b ld mv lg mw lj oa ln ob lr oc lv od oe of og bi translated">如果父表发生了变化，但子表没有变化。这意味着用户可以更新他们选择的方式，但支付方式本身保持不变。</li><li id="56a8" class="ny nz iu lc b ld oh lg oi lj oj ln ok lr ol lv od oe of og bi translated">如果我们需要过于频繁地访问子数据。在我们的案例中，如果我们需要了解客户支付账单的可用选项。</li></ul><h2 id="a55c" class="nf me iu bd mf nn no dn mj np nq dp mn lj nr ns mp ln nt nu mr lr nv nw mt nx bi translated">当它不起作用时</h2><ul class=""><li id="3c77" class="ny nz iu lc b ld mv lg mw lj oa ln ob lr oc lv od oe of og bi translated">如果您想查找使用特定付款方式的所有客户。</li><li id="afe7" class="ny nz iu lc b ld oh lg oi lj oj ln ok lr ol lv od oe of og bi translated">如果您的付款方式变更太频繁。</li><li id="cc51" class="ny nz iu lc b ld oh lg oi lj oj ln ok lr ol lv od oe of og bi translated">如果你要询问付款方式。</li></ul></div><div class="ab cl lw lx hy ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="in io ip iq ir"><h1 id="521d" class="md me iu bd mf mg mh mi mj mk ml mm mn ka mo kb mp kd mq ke mr kg ms kh mt mu bi translated">反规格化+复制</h1><p id="a31f" class="pw-post-body-paragraph la lb iu lc b ld mv jv lf lg mw jy li lj mx ll lm ln my lp lq lr mz lt lu lv in bi translated">现在我们要讨论在NoSQL维护一对多关系的另一种方法。</p><p id="de4e" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">假设你正在设计一个订票系统。您有一个表，您想在其中存储客户订购的门票。现在，在您的<code class="fe nk nl nm nb b">Tickets</code>表中，您需要一些关于客户的基本信息。</p><p id="a30a" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">如果您保留客户ID，并在每次需要查看票据详细信息时获取有关用户的信息，那么它将无法扩展。您可以做的是将客户的基本信息存储在<code class="fe nk nl nm nb b">Tickets</code>表中。</p><pre class="kk kl km kn gu na nb nc nd aw ne bi"><span id="632c" class="nf me iu nb b gz ng nh l ni nj">Ticket<br/>|<br/>|-- TicketId<br/>|-- JourneyDate<br/>|-- CustomerName<br/>|-- CustomerBirthDate</span></pre><p id="57f7" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">因此，在您的<code class="fe nk nl nm nb b">Ticket</code>项目中，您有了关于客户的基本详细信息。这样，你可以避免每次想取票时都要回到<code class="fe nk nl nm nb b">Customer</code>桌。</p><p id="ad85" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">是的，您在数据库中复制了客户的姓名和出生日期，但这是为了一个好的理由！</p><h2 id="5d32" class="nf me iu bd mf nn no dn mj np nq dp mn lj nr ns mp ln nt nu mr lr nv nw mt nx bi translated">当它工作的时候</h2><ul class=""><li id="9eff" class="ny nz iu lc b ld mv lg mw lj oa ln ob lr oc lv od oe of og bi translated">您需要经常访问父表的信息。</li><li id="f4cb" class="ny nz iu lc b ld oh lg oi lj oj ln ok lr ol lv od oe of og bi translated">父表信息不会经常改变(客户的出生日期不太可能改变)。</li></ul><h2 id="afd0" class="nf me iu bd mf nn no dn mj np nq dp mn lj nr ns mp ln nt nu mr lr nv nw mt nx bi translated">当它不起作用时</h2><ul class=""><li id="f362" class="ny nz iu lc b ld mv lg mw lj oa ln ob lr oc lv od oe of og bi translated">如果重复的数据经常改变。例如，客户的奖励积分。在这种情况下，用这些信息更新所有孩子的记录是不现实的。</li></ul></div><div class="ab cl lw lx hy ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="in io ip iq ir"><h1 id="f3a0" class="md me iu bd mf mg mh mi mj mk ml mm mn ka mo kb mp kd mq ke mr kg ms kh mt mu bi translated">复合主键+查询</h1><p id="d24f" class="pw-post-body-paragraph la lb iu lc b ld mv jv lf lg mw jy li lj mx ll lm ln my lp lq lr mz lt lu lv in bi translated">如果以上两种方法都不能满足您的需求，那么还有另一种方法。但是理解和设计起来有点棘手。</p><p id="b69b" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">例如，我们正在设计一个组织数据库，其中的雇员属于一个特定的部门。员工也有自己的角色。</p><p id="b8b5" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">现在您想查找一个部门的所有员工。</p><p id="226d" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">您将主键保留为<code class="fe nk nl nm nb b">ORG#1234</code>，将员工记录的排序键保留为<code class="fe nk nl nm nb b">EMP#DEPARTMENT#1234</code>。部门的排序关键字可以是<code class="fe nk nl nm nb b">DEPT#1234</code>。</p><p id="55a8" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated"><em class="om">注:这里的</em> <code class="fe nk nl nm nb b"><em class="om">1234</em></code> <em class="om">只是一个ID。在现实生活中，这是随机的。</em></p><p id="b32d" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">现在，当您想要查询某个部门的所有员工时，您可以:</p><pre class="kk kl km kn gu na nb nc nd aw ne bi"><span id="a072" class="nf me iu nb b gz ng nh l ni nj">where :PK = ORG#{id} and begins_with( EMP#DEPARTMENT, :SK)</span></pre><p id="06f6" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">同样，您可以找到任何组织的所有部门:</p><pre class="kk kl km kn gu na nb nc nd aw ne bi"><span id="7a38" class="nf me iu nb b gz ng nh l ni nj">where :PK = ORG#{id} and begins_with( DEPARTMENT#, :SK)</span></pre><p id="e5fc" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">因此，你可以看到如何利用各种功能，如<code class="fe nk nl nm nb b">begins_with</code>、<code class="fe nk nl nm nb b">contains</code>等。</p></div><div class="ab cl lw lx hy ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="in io ip iq ir"><h1 id="9c31" class="md me iu bd mf mg mh mi mj mk ml mm mn ka mo kb mp kd mq ke mr kg ms kh mt mu bi translated">最后的想法</h1><p id="2d61" class="pw-post-body-paragraph la lb iu lc b ld mv jv lf lg mw jy li lj mx ll lm ln my lp lq lr mz lt lu lv in bi translated">设计一个NoSQL数据库不是开玩笑的事。你必须花很多精力去设计一个，并且事先考虑所有可能的访问策略。否则，您不能很容易地恢复或更改数据建模。</p><p id="b888" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">我希望这篇文章对NoSQL数据库的数据建模思想有所启发。我鼓励你更多地了解这些话题！</p><p id="8d26" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">编码快乐！</p><p id="78ee" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated"><strong class="lc iv">通过</strong><a class="ae kz" href="https://www.linkedin.com/in/56faisal/" rel="noopener ugc nofollow" target="_blank"><strong class="lc iv">LinkedIn</strong></a><strong class="lc iv">或我的</strong> <a class="ae kz" href="https://www.mohammadfaisal.dev/" rel="noopener ugc nofollow" target="_blank"> <strong class="lc iv">个人网站</strong> </a> <strong class="lc iv">与我取得联系。</strong></p><h2 id="aa1b" class="nf me iu bd mf nn no dn mj np nq dp mn lj nr ns mp ln nt nu mr lr nv nw mt nx bi translated">资源</h2><ul class=""><li id="f4a1" class="ny nz iu lc b ld mv lg mw lj oa ln ob lr oc lv od oe of og bi translated">牛逼教程:<a class="ae kz" href="https://www.youtube.com/watch?v=fiP2e-g-r4g" rel="noopener ugc nofollow" target="_blank">https://www.youtube.com/watch?v=fiP2e-g-r4g</a></li></ul></div></div>    
</body>
</html>