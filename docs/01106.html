<html>
<head>
<title>OOP Pattern Matching: Visitor Pattern</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">OOP模式匹配:访问者模式</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/oop-pattern-matching-visitor-pattern-2a26cc559e09?source=collection_archive---------4-----------------------#2019-08-14">https://betterprogramming.pub/oop-pattern-matching-visitor-pattern-2a26cc559e09?source=collection_archive---------4-----------------------#2019-08-14</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="a640" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">使用访问者模式作为路由点(以Kotlin为例)</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/efd555a5a38aa9a33ac0d698cae1607e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*uTA8RSLA87y2DIyL"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">照片由<a class="ae ky" href="https://unsplash.com/@aaronburden?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Aaron Burden </a>在<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</p></figure><p id="670b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">函数式编程在IT领域获得了巨大的发展势头；很多事情来来去去，但FP不在其中。它比OOP更具表现力。</p><p id="56c8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">几年前，在博洛尼亚举行的<a class="ae ky" href="http://lambdaconf.us/" rel="noopener ugc nofollow" target="_blank"> LambdaConf </a>期间，我开始深入研究它，我获得的洞察力越多，我就越喜欢FP。</p><p id="89be" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">6月份，我去了一个应用函数式编程研讨会，老师深入研究了代数数据类型和模式匹配。我也终于明白了什么是单子，不过这是后话了。</p><p id="41c7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我曾经认为模式匹配是一种有趣的解构列表的方式。现在，我知道它是FP软件设计的基础，也是解决领域对象的数据和行为分离需求的有效方法。</p><p id="58a1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们来看一个例子！</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="8cc9" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">按国家本地化的ERP</h1><p id="9c27" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">假设我们想编写ERP软件，在两个不同国家的市场上竞争:意大利和德国。我们将在许多域对象中编写许多CRUD操作。这里没有挑战。</p><p id="c26d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">但是，在相同的功能流中，在不同的数据结构中对特定于国家的业务规则建模又如何呢？</p><p id="7978" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">例如，这两个国家的数据库中都有文章，你肯定想对它们进行搜索。但是，搜索规则和获取的数据可能完全不同。</p><p id="5fb3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">由于数据结构不同，我们不能只有域实体<code class="fe mz na nb nc b">Article</code>——我们至少需要一个<code class="fe mz na nb nc b">ItalianArticle</code>和一个<code class="fe mz na nb nc b">GermanArticle</code>。</p><p id="78d5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">考虑到数据存储也可能因结构而异。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="a8c3" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">FP方式</h1><p id="d331" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">让我们来看一个<a class="ae ky" href="https://www.scala-lang.org/" rel="noopener ugc nofollow" target="_blank"> Scala </a> <strong class="lb iu"> </strong>的实现。</p><p id="4c98" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">写一个求和式<code class="fe mz na nb nc b">Article</code> <strong class="lb iu"> <em class="nd">。</em> </strong></p><p id="484b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">然后，我们将其专门化为产品类型<code class="fe mz na nb nc b">ItalianArticle</code> <strong class="lb iu"> <em class="nd"> </em> </strong>和<code class="fe mz na nb nc b">GermanArticle</code>。</p><p id="b558" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">此外，我们可以预计，当我们寻找一些东西时，有时我们什么也没有找到。所以，我们也要考虑<code class="fe mz na nb nc b">ArticleNotFound</code>。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ne nf l"/></div></figure><p id="1f8c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">每次我们从某个地方收到一个<code class="fe mz na nb nc b">Article</code>返回，我们都会在上面进行模式匹配。在比赛中，我们可以访问它的专门数据。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ne nf l"/></div></figure></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="3239" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">不就是一个开关吗？</h1><p id="00e5" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">乍一看，这看起来像是一个经典的过程性“切换”,随后是向下转换。</p><p id="bede" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">有一个重要的区别:编译器知道我们是否匹配每一种类型的<code class="fe mz na nb nc b">Article</code>。例如，如果我们忘记匹配<code class="fe mz na nb nc b">ArticleNotFound</code>:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ne nf l"/></div></figure><p id="2f41" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">那么，默认情况下，<code class="fe mz na nb nc b">sbt compiler</code> <strong class="lb iu"> </strong>会发出警告。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ng"><img src="../Images/11a30124d846790a0916ff22e84e73b2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*vrCeLMY0TKwoGk-BhiJang.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated"><strong class="bd nh">图1: </strong> sbt编译输出</p></figure><p id="27f4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">由于编译器知道有问题，我们可以让它产生一个错误而不是警告。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="3ab2" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">新要求:西班牙</h1><p id="840a" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">在这一点上，完全意想不到的事情发生了！公司向我们提出了新的要求:我们还需要在西班牙进行分销。</p><p id="2577" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">其实我们是有备而来的，所以让我们把<code class="fe mz na nb nc b">EspArticle</code>添加到我们的<code class="fe mz na nb nc b">Article</code> <strong class="lb iu"> </strong> sum类型中。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ne nf l"/></div></figure><p id="edf4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在，我们需要添加西班牙语的业务逻辑。</p><p id="7dd4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">对于一个普通的交换机来说，搜索我们实施了特定于国家的业务规则的每个地方将是一件痛苦的事情。</p><p id="d056" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">相反，通过模式匹配，编译器会告诉我们应该在哪里进行干预。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="b68f" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">用OOP可能吗？</h1><p id="2515" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">是的，当然，有访客模式！</p><p id="be78" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果你不知道访问者模式，看看这个<a class="ae ky" href="https://en.wikipedia.org/wiki/Visitor_pattern" rel="noopener ugc nofollow" target="_blank">维基百科页面</a>。如果你不知道<a class="ae ky" href="https://en.wikipedia.org/wiki/Design_Patterns" rel="noopener ugc nofollow" target="_blank">四人组</a>(他写了一本书<em class="nd">设计模式:可重用面向对象软件的元素</em>)，<strong class="lb iu"> <em class="nd"> </em> </strong>有一个阅读。</p><p id="e9fe" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">访问者模式长期以来被称为<strong class="lb iu"> </strong>反模式。当您添加一个新的条目类型时，您将向visitor接口添加一个新的方法。</p><p id="e46c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在这种情况下，编译器会中断每个具体的访问者，直到您在每个访问者中实现了新的方法。这是反模式的原因之一。</p><p id="4f31" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">事实上，对于我们的关注，这个“问题”看起来就像我们正在寻找的！</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="268d" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">科特林示例</h1><p id="1795" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">下面是我们的sum类型的一个<a class="ae ky" href="https://kotlinlang.org/" rel="noopener ugc nofollow" target="_blank"> Kotlin </a>实现:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ne nf l"/></div></figure><p id="5d7e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">您会注意到，我没有使用“接受”和“访问者”这两个名称，而是更喜欢考虑“应用于数据消费者的数据”。(我在寻找更好的名字，所以如果你有建议，请告诉我。)</p><p id="8cff" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在这里，我们可以实现特定国家的业务规则。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ne nf l"/></div></figure><p id="dcf9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这个例子的语义与FP模式匹配完全相同。</p><p id="7a5c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">当我们添加新的国家时，编译器将中断一切，直到我们不在每个<code class="fe mz na nb nc b">ArticleConsumer</code>中实现新的<code class="fe mz na nb nc b">fun use(article: SpaArticle)</code>。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="34a1" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">结论</h1><p id="ea6c" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">访问者模式的最初目的是迭代异构对象集合上的操作，这些对象不共享相同的接口和数据类型。</p><p id="3d30" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在本文中，我建议使用它作为路由点。当您结束枚举您的域实体并需要设置本地化的域上下文时，这很有用。</p><p id="7039" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在方法中枚举域实体被认为是一个问题。在这个用例中，它是模式的关键特性。</p><p id="788d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我还演示了这种用法在语义上等同于FP模式匹配。</p><p id="de82" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">感谢您的阅读！</p></div></div>    
</body>
</html>