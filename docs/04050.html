<html>
<head>
<title>How to Deploy a Local Serverless Application With AWS SAM</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何使用AWS SAM部署本地无服务器应用程序</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/how-to-deploy-a-local-serverless-application-with-aws-sam-b7b314c3048c?source=collection_archive---------2-----------------------#2020-03-20">https://betterprogramming.pub/how-to-deploy-a-local-serverless-application-with-aws-sam-b7b314c3048c?source=collection_archive---------2-----------------------#2020-03-20</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="3141" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">开始使用无服务器、Lambda和Docker</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/4b4bcc4ab1adfcca23e71bea42488692.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*okuQG9twoZyMW7EBpKybYA.jpeg"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">Craig Lovelidge 在<a class="ae ky" href="https://unsplash.com/s/photos/lazers?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</p></figure><p id="18f3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">SAM是一个<a class="ae ky" href="https://github.com/awslabs/serverless-application-model" rel="noopener ugc nofollow" target="_blank">开源框架</a>，可以用来在AWS上构建、测试和部署<a class="ae ky" href="https://aws.amazon.com/serverless/" rel="noopener ugc nofollow" target="_blank">无服务器应用</a>。</p><p id="04d2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">本文的主要目标是让您熟悉AWS SAM，这样您就可以在本地机器上测试您的lambdas，而不需要每次都在AWS上(重新)部署它们。我将讨论SAM和lambda的不同集成和示例。</p><p id="f805" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">SAM使用Docker在本地构建和运行lambdas，所以需要有Docker的基础知识。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="80a1" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">体系结构</h1><p id="d7ff" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">假设有一家公司有很多文件。这些文档有一个<code class="fe mz na nb nc b">documentId</code>和一个<code class="fe mz na nb nc b">versionId</code>。一个文档也有多个版本。</p><p id="7d84" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">该公司的员工发现很难找到特定版本的文档。该公司开发了一种解决方案，可以根据文档的<code class="fe mz na nb nc b">documentId</code>和<code class="fe mz na nb nc b">versionId</code>轻松请求文档的存储位置。</p><p id="2aca" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们将用例转化为AWS中的技术架构。我们将使用DynamoDB来存储文档的<code class="fe mz na nb nc b">documentId</code>、<code class="fe mz na nb nc b">versionId</code>和存储位置。我们需要用现有的文档信息填充DynamoDB表，然后在API Gateway中设置lambda代理集成。最终用户将能够通过对API网关端点执行带有正确参数(<code class="fe mz na nb nc b">documentId</code>和<code class="fe mz na nb nc b">versionId</code>)的GET请求来检索文档的正确存储位置。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nd"><img src="../Images/31065dab0d0bd4b9910fb886107bedc1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*u7fLyLPJk9KeCuF7hdH9lg.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">最终用户将使用静态网站执行一个GET请求，看起来像这样:<br/> <a class="ae ky" href="http://127.0.0.1:3000/document?documentId=1044&amp;versionId=v_1" rel="noopener ugc nofollow" target="_blank"> https://xxx/document？documentId = 1044&amp;versionId = v _ 1</a></p></figure><p id="4e86" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们可以使用SAM在AWS中部署这个堆栈，但是SAM的优势之一是它提供了一种直接的方法来本地测试您的集成。</p><p id="dfd3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们将使用SAM local来:</p><ul class=""><li id="0adc" class="ne nf it lb b lc ld lf lg li ng lm nh lq ni lu nj nk nl nm bi translated">使用SAM CLI调用一次lambda来填充DynamoDB。</li><li id="777e" class="ne nf it lb b lc nn lf no li np lm nq lq nr lu nj nk nl nm bi translated">通过lambda代理集成托管我们的本地API网关端点。</li><li id="c4a4" class="ne nf it lb b lc nn lf no li np lm nq lq nr lu nj nk nl nm bi translated">生成一个示例事件，当有人搜索文档时，API Gateway会将该事件发送给我们的lambda函数。</li></ul><p id="39b0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">当本地一切正常时，我们将在AWS中部署整个堆栈。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="4370" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">初始设置</h1><p id="c767" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">要进行此演示，您需要具备以下先决条件:</p><ul class=""><li id="a2f0" class="ne nf it lb b lc ld lf lg li ng lm nh lq ni lu nj nk nl nm bi translated"><a class="ae ky" href="https://docs.docker.com/install/" rel="noopener ugc nofollow" target="_blank">码头工人</a></li><li id="322d" class="ne nf it lb b lc nn lf no li np lm nq lq nr lu nj nk nl nm bi translated"><a class="ae ky" href="https://docs.aws.amazon.com/serverless-application-model/latest/developerguide/serverless-sam-cli-install.html" rel="noopener ugc nofollow" target="_blank"> SAM CLI </a></li><li id="2438" class="ne nf it lb b lc nn lf no li np lm nq lq nr lu nj nk nl nm bi translated"><a class="ae ky" href="https://docs.aws.amazon.com/cli/latest/userguide/cli-chap-install.html" rel="noopener ugc nofollow" target="_blank"> AWS CLI </a></li><li id="c037" class="ne nf it lb b lc nn lf no li np lm nq lq nr lu nj nk nl nm bi translated"><a class="ae ky" href="https://github.com/lvthillo/aws-lambda-sam-demo" rel="noopener ugc nofollow" target="_blank">演示GitHub项目</a></li><li id="662a" class="ne nf it lb b lc nn lf no li np lm nq lq nr lu nj nk nl nm bi translated">AWS帐户(可选)</li></ul><p id="6148" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们将使用Docker来运行本地DynamoDB实例——但不仅仅是这样。</p><p id="81db" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">SAM也高度依赖Docker。当SAM CLI调用本地lambda函数时，SAM将启动一个Docker容器，执行lambda代码并销毁该容器。</p><p id="0b6d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们先创建一个<a class="ae ky" href="https://docs.docker.com/network/bridge/" rel="noopener ugc nofollow" target="_blank"> Docker桥接网络</a>。我们将使用这种类型的Docker网络，这样我们的Docker容器就可以通过解析它们的容器名来相互通信。因此，我们可以从由SAM管理的lambda容器内部与本地DynamoDB Docker容器进行对话。DynamoDB容器被称为“dynamodb”。</p><pre class="kj kk kl km gt ns nc nt nu aw nv bi"><span id="e2c1" class="nw md it nc b gy nx ny l nz oa">$ docker network create sam-demo<br/>$ <!-- -->docker run --network sam-demo --name dynamodb -d -p 8000:8000 amazon/dynamodb-local</span></pre><p id="7aef" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">当容器启动并运行时，我们可以创建DynamoDB表。我们的DynamoDB的主键将由一个分区键(documentId)和一个排序键(versionId)组成。</p><pre class="kj kk kl km gt ns nc nt nu aw nv bi"><span id="2843" class="nw md it nc b gy nx ny l nz oa">$ aws dynamodb create-table --table-name documentTable --attribute-definitions AttributeName=documentId,AttributeType=N AttributeName=versionId,AttributeType=S --key-schema AttributeName=documentId,KeyType=HASH AttributeName=versionId,KeyType=RANGE --provisioned-throughput ReadCapacityUnits=5,WriteCapacityUnits=5 --endpoint-url <a class="ae ky" href="http://localhost:8000" rel="noopener ugc nofollow" target="_blank">http://localhost:8000</a></span></pre></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="c8ec" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">使用SAM构建和调用本地函数</h1><p id="ed92" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">现在从GitHub 克隆<a class="ae ky" href="https://github.com/lvthillo/aws-lambda-sam-demo" rel="noopener ugc nofollow" target="_blank">演示项目。</a></p><p id="2920" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这个项目包含了<code class="fe mz na nb nc b"><a class="ae ky" href="https://github.com/lvthillo/aws-lambda-sam-demo/blob/master/template.yaml" rel="noopener ugc nofollow" target="_blank">template.yaml</a></code>，它完整地描述了堆栈应该是什么样子。它部署了一个名为<code class="fe mz na nb nc b">LoadDataFunction</code>的独立lambda函数，我们手动触发该函数来将数据加载到DynamoDB表中。第二个函数称为GetDocumentFunction，将由API网关事件触发。</p><p id="621e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们可以验证模板是否有效:</p><pre class="kj kk kl km gt ns nc nt nu aw nv bi"><span id="694c" class="nw md it nc b gy nx ny l nz oa">$ cd aws-lambda-sam-demo<br/>$ sam validate -t template.yml<br/>xxx/template.yaml is a valid SAM Template</span></pre><p id="1d30" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><a class="ae ky" href="https://github.com/lvthillo/aws-lambda-sam-demo/blob/master/functions/load_data/app.py" rel="noopener ugc nofollow" target="_blank"> LoadDataFunction </a>将用于填充我们的DynamoDB表。使用SAM CLI构建函数。如果您的本地环境中没有安装Python3.7，您可以使用<code class="fe mz na nb nc b">--use-container</code>参数在Docker容器中构建该函数。</p><pre class="kj kk kl km gt ns nc nt nu aw nv bi"><span id="dabb" class="nw md it nc b gy nx ny l nz oa">$ sam build --use-container</span></pre><p id="ed2a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这构建了我们的lambda函数，如我们的<a class="ae ky" href="https://github.com/lvthillo/aws-lambda-sam-demo/blob/master/template.yaml" rel="noopener ugc nofollow" target="_blank"> template.yaml </a>中所述。<a class="ae ky" href="https://docs.aws.amazon.com/serverless-application-model/latest/developerguide/what-is-sam.html" rel="noopener ugc nofollow" target="_blank"> SAM模板是CloudFormation模板</a>的扩展。构建将下载必要的依赖项，在我们的<code class="fe mz na nb nc b">requirements.txt</code>中描述，并创建存储在<code class="fe mz na nb nc b">.aws-sam/build/functionName</code>中的部署工件。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ob"><img src="../Images/451f547f4ec976b96c95116ed7e52156.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*B14FZOIXeCP6B52ws-SBHA.png"/></div></div></figure><p id="8841" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">只需要执行一次<code class="fe mz na nb nc b">LoadDataFunction</code>就可以将现有文档及其位置放入DynamoDB表中。让我们仔细看看函数本身:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oc od l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">基于env var环境的值，我们将连接到本地或远程DynamoDB</p></figure><p id="228a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们可以使用SAM来调用这个函数。我们用一个参数来表示我们的环境。有效选项为<code class="fe mz na nb nc b">local</code>或<code class="fe mz na nb nc b">aws</code>。lambda函数基于该参数与正确的DynamoDB端点连接。</p><p id="171f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">本地lambda函数将在Docker容器中运行。我们告诉SAM在与我们的DynamoDB容器相同的Docker桥网络中旋转容器。现在，我们的lambda可以使用容器名与DynamoDB容器进行通信。</p><pre class="kj kk kl km gt ns nc nt nu aw nv bi"><span id="d7d8" class="nw md it nc b gy nx ny l nz oa">$ sam local invoke LoadDataFunction --parameter-overrides ParameterKey=Environment,ParameterValue=local ParameterKey=DDBTableName,ParameterValue=documentTable --docker-network sam-demo</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi oe"><img src="../Images/352698457e8099ca41c76b4ca5a0c42a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Y6iPFs2BD_aIrTOcv66QiA.png"/></div></div></figure><p id="b1a8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">当lambda函数成功结束时，我们可以看到DynamoDB表中是否有正确的数据。浏览表格的内容:</p><pre class="kj kk kl km gt ns nc nt nu aw nv bi"><span id="8330" class="nw md it nc b gy nx ny l nz oa">$ aws dynamodb scan --table-name documentTable --endpoint-url <a class="ae ky" href="http://localhost:8000" rel="noopener ugc nofollow" target="_blank">http://localhost:8000</a></span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi of"><img src="../Images/576fd41e60876ac96a995a744e6e8327.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*JbVcQBEvbcpNV4GS9b0W7Q.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">我们在s3://bucket-a/8853806831.doc中看到一个documentId为1044且版本为v_1的文档</p></figure></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="9199" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">使用SAM生成一个示例负载</h1><p id="43e0" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">下一个功能是<code class="fe mz na nb nc b"><a class="ae ky" href="https://github.com/lvthillo/aws-lambda-sam-demo/blob/master/functions/get_document/app.py" rel="noopener ugc nofollow" target="_blank">GetDocumentFunction</a></code>。这是由API网关事件触发的。</p><p id="d2a4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">API网关设置在<code class="fe mz na nb nc b"><a class="ae ky" href="https://github.com/lvthillo/aws-lambda-sam-demo/blob/master/template.yaml" rel="noopener ugc nofollow" target="_blank">template.yaml</a></code>中定义。我们部署了一个<a class="ae ky" href="https://docs.aws.amazon.com/apigateway/latest/developerguide/set-up-lambda-proxy-integrations.html" rel="noopener ugc nofollow" target="_blank"> API Gateway lambda代理集成</a>，当对<code class="fe mz na nb nc b">API-GW-URL/document?documentId=xxx&amp;versionId=xxx</code>发出GET请求时，将会触发<code class="fe mz na nb nc b">GetDocumentFunction</code>。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi og"><img src="../Images/661df87d47a278f14d60c1f460b7b367.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*s1OcDJlGRZDKQtmQh4WR1g.png"/></div></div></figure><p id="05f4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在我们部署这个API网关端点之前，我希望我们测试一下<code class="fe mz na nb nc b">GetDocumentFunction</code>。这里我必须创建一个有效的事件来触发这个函数。下面的命令将创建一个有效的JSON，我们可以用它作为一个假的API网关事件来触发lambda。</p><pre class="kj kk kl km gt ns nc nt nu aw nv bi"><span id="45f8" class="nw md it nc b gy nx ny l nz oa">$ sam local generate-event apigateway aws-proxy --method GET --path document --body "" &gt; local-event.json</span></pre><p id="51dc" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">遗憾的是，SAM CLI还没有支持(还没有？)用于事件生成期间的<code class="fe mz na nb nc b">queryStringParameters</code>。所以我们应该在<code class="fe mz na nb nc b">local-event.json</code>中手动更新这个。记住，我们看到了一个带有<code class="fe mz na nb nc b">documentId 1044</code>和<code class="fe mz na nb nc b">version_id v_1 in DynamoDB</code>的文档，所以我们可以使用它们作为有效的参数值:</p><pre class="kj kk kl km gt ns nc nt nu aw nv bi"><span id="4e97" class="nw md it nc b gy nx ny l nz oa">...<br/>"queryStringParameters": {<br/> "documentId": "1044",<br/> "versionId": "v_1"<br/> },<br/>...</span></pre><p id="dd23" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在使用我们的事件调用<code class="fe mz na nb nc b">GetDocumentFunction</code>来测试它:</p><pre class="kj kk kl km gt ns nc nt nu aw nv bi"><span id="866a" class="nw md it nc b gy nx ny l nz oa">sam local invoke GetDocumentFunction --event local-event.json --parameter-overrides ParameterKey=Environment,ParameterValue=local ParameterKey=DDBTableName,ParameterValue=documentTable --docker-network sam-demo</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi oh"><img src="../Images/56d3e3e3b0ffacc573233d7a0dc00ada.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*lBCm-10jlHi7Bl9RTPjWFQ.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">显示了documentId为1044、versionId为v_1的文档的正确存储位置</p></figure></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="b14b" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">使用Lambda代理集成设置本地API网关端点</h1><p id="1cfb" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">公司的员工将使用静态网站向API网关执行有效的GET请求。员工填写他们需要的文件的<code class="fe mz na nb nc b">documentId</code>和<code class="fe mz na nb nc b">versionId</code>。</p><p id="0aa1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">API网关会将请求转发给我们的<code class="fe mz na nb nc b">GetDocumentFunction</code>。<code class="fe mz na nb nc b">GetDocumentFunction</code>将使用<code class="fe mz na nb nc b">queryStringParameters</code>查询DynamoDB表中的正确位置。</p><p id="1bcc" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">启动我们的本地API网关端点:</p><pre class="kj kk kl km gt ns nc nt nu aw nv bi"><span id="e176" class="nw md it nc b gy nx ny l nz oa">$ sam local start-api --parameter-overrides ParameterKey=Environment,ParameterValue=local ParameterKey=DDBTableName,ParameterValue=documentTable --docker-network sam-demo</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi oi"><img src="../Images/3b015a4cd2fd52b8d438d382819527a6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*6cTiEJrQ9BI3g1b_9LKRLQ.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">它运行在http://127.0.0.1:3000上</p></figure><p id="2959" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">该存储库包含一个基本的静态网页作为可视化。员工将使用它与API网关对话。API网关与后端对话，也就是我们的<code class="fe mz na nb nc b">GetDocumentFunction</code>。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi oj"><img src="../Images/5ba18d893d8b61d20375911d24212c40.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*XbfnL7UqB71zO8CAWVO9Uw.png"/></div></div></figure><p id="bf21" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这将实际执行以下GET调用:</p><pre class="kj kk kl km gt ns nc nt nu aw nv bi"><span id="a81b" class="nw md it nc b gy nx ny l nz oa">$ curl <a class="ae ky" href="http://127.0.0.1:3000/document?documentId=1044&amp;versionId=v_1" rel="noopener ugc nofollow" target="_blank">"http://127.0.0.1:3000/document?documentId=1044&amp;versionId=v_1</a>"</span></pre><p id="273d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在单击提交查询。这会触发我们的λ。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ok"><img src="../Images/b02cb4cbce9d7d33fb2244522431db75.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*d7H9hm1NI9s6JXBKHJf71A.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">lambda在本地DynamoDB中搜索文档的相应位置</p></figure><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ol"><img src="../Images/42078ab9ad0bc1e0710f78146a32696f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*cFd4BAZY_3ATnA6XUUw-Kg.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">将显示文档的位置</p></figure><p id="32e7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在我展示了如何在本地构建和测试我们的堆栈。对模板或lambdas进行更改后，您应该再次运行<code class="fe mz na nb nc b">sam build</code>命令，重新调用或重新部署您的资源。</p><p id="732e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">就是这样！如果您有可用的AWS帐户，您可以进入下一步。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="1842" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">将SAM堆栈部署到AWS(可选)</h1><p id="9a29" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">现在我将向您展示将这个堆栈部署到AWS有多容易。</p><p id="f3c4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们已经运行了<code class="fe mz na nb nc b">sam build </code>命令。这在<code class="fe mz na nb nc b">.aws-sam/build/</code>目录中创建了我们的部署工件。</p><p id="e2ca" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe mz na nb nc b">sam deploy</code>打包并部署我们的堆栈。我们必须指定一个S3存储桶来上传我们的部署工件。注意，我们现在指向AWS作为环境，而不是<code class="fe mz na nb nc b">local</code>。现在我们的lambdas知道他们必须连接到AWS的DynamoDB端点，而不是我们的本地端点。</p><pre class="kj kk kl km gt ns nc nt nu aw nv bi"><span id="7f97" class="nw md it nc b gy nx ny l nz oa">$ sam deploy --template-file .aws-sam/build/template.yaml --s3-bucket lvthillo-sam-upload-bucket --parameter-overrides ParameterKey=Environment,ParameterValue=aws ParameterKey=DDBTableName,ParameterValue=documentTable --stack-name aws-lambda-sam-demo --capabilities CAPABILITY_NAMED_IAM</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi om"><img src="../Images/8595661927fa0b2ea359b392fe2e032b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*3M3-pch30yn3bhPwOcNXBw.png"/></div></div></figure><p id="b8f5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在成功部署之后，我们应该首先运行<code class="fe mz na nb nc b">LoadDataFunction</code>来填充我们的DynamoDB。只需在lambda控制台中创建一个空的测试事件并执行函数:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi on"><img src="../Images/2ebf917ac0c5e96092624fdeb77319c4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*uxLsEqP6X83ITHc4Bnx_EQ.png"/></div></div></figure><p id="5508" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">DynamoDB中提供了正确的数据:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi oo"><img src="../Images/5711476e8ebaf0789746509b4d61b717.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*1kOSFVT4L-PewHNik8tUgw.png"/></div></div></figure><p id="1a39" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在我们可以再次测试我们的API网关lambda代理集成:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi op"><img src="../Images/6c9c84a35c126a7f093db7edc662c873.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*8brrC4I85solyCIIaySP8Q.png"/></div></div></figure><p id="2d89" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">一切正常！最后，我们可以在由堆栈创建的S3桶中重新部署静态网站。在这个演示中，我使用<a class="ae ky" href="https://s3.console.aws.amazon.com/s3/#" rel="noopener ugc nofollow" target="_blank">公共静态站点桶</a>作为桶。该模板将生成一个随机的存储桶名称，配置为静态网站。</p><p id="9b31" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们只需要更新我们的静态应用程序来指向正确的API网关URL。要找到这个网址，你可以去CloudFormation。搜索您的堆栈并检查输出。堆栈被配置为输出我们的API网关端点。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi oq"><img src="../Images/4268437b4cde363678de2e39bc47d466.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*NRfxNGsfrbsy61MqJQpP7g.png"/></div></div></figure><p id="c572" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">为了快速测试，我们可以使用<code class="fe mz na nb nc b">curl</code>和正确(或不正确)的参数。</p><pre class="kj kk kl km gt ns nc nt nu aw nv bi"><span id="d2dc" class="nw md it nc b gy nx ny l nz oa">$ curl "<a class="ae ky" href="https://c8517wsgol.execute-api.eu-west-1.amazonaws.com/v1/document?documentId=1044&amp;versionId=v_1" rel="noopener ugc nofollow" target="_blank">https://c8517wsgol.execute-api.eu-west-1.amazonaws.com/v1/document?documentId=1044&amp;versionId=v_1</a>"</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi or"><img src="../Images/39e7a71f6dcc1cb389a2089040c6f3b7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*b_5Y0bLOb-HaECv2LPR31A.png"/></div></div></figure><p id="42b3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在我们可以用这个URL更新我们的静态应用程序:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi os"><img src="../Images/90fc596a3f70fe8b14768d60d6d5daa1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*cWPdXcAgK93j-NA1m3Bd7A.png"/></div></div></figure><p id="81ff" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在我们已经更新了网址，我们可以上传文件到我们的S3桶。请确保在上传期间或之后公开对象。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ot"><img src="../Images/896137fab3fcc9a3194222a1a110680c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*vaq_9R23iAsO_nk52rBcBQ.png"/></div></div></figure><p id="cde3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">访问您的S3桶作为一个静态网站！</p><p id="3edf" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">CloudFormation控制台中也会输出正确的URL。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ou"><img src="../Images/43f7527ad8ee8aa5b943b985da1c9d94.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ICShlE0_zlPVUW85eYrHRg.png"/></div></div></figure></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="7e43" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">结论</h1><p id="fed7" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">我们发现了AWS无服务器应用程序模型的魔力。</p><p id="7ce9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们经历了你可以用它做的大部分重要的事情。我们使用SAM模板在本地机器上部署和测试lambda函数。我们甚至部署了一个本地API网关！在我们确认一切正常后，我们在AWS上部署了完全相同的堆栈。</p><p id="76fa" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我希望你喜欢它。感谢您的阅读，并随时询问任何问题！</p></div></div>    
</body>
</html>