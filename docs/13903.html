<html>
<head>
<title>How to Create a Serverless Authentication Service With AWS CDK, Cognito, and API Gateway</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何使用AWS CDK、Cognito和API网关创建无服务器认证服务</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/create-a-serverless-authentication-service-with-aws-cdk-cognito-and-api-gateway-ffbd8da6a659?source=collection_archive---------0-----------------------#2022-10-12">https://betterprogramming.pub/create-a-serverless-authentication-service-with-aws-cdk-cognito-and-api-gateway-ffbd8da6a659?source=collection_archive---------0-----------------------#2022-10-12</a></blockquote><div><div class="fc ii ij ik il im"/><div class="in io ip iq ir"><h2 id="cb3b" class="is it iu bd b dl iv iw ix iy iz ja dk jb translated" aria-label="kicker paragraph">AWS解决方案</h2><div class=""/><div class=""><h2 id="0e58" class="pw-subtitle-paragraph ka jd iu bd b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr dk translated">使用TypeScript、JWT和HttpOnly cookies的后端服务</h2></div><figure class="kt ku kv kw gu kx gi gj paragraph-image"><div role="button" tabindex="0" class="ky kz di la bf lb"><div class="gi gj ks"><img src="../Images/35fe9482818359482efd0c518551d4b4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*GOfcH6KpweR3QrGi"/></div></div><p class="le lf gk gi gj lg lh bd b be z dk translated">照片由<a class="ae li" href="https://unsplash.com/@flyd2069?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">飞:D </a>在<a class="ae li" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a></p></figure><p id="cf9d" class="pw-post-body-paragraph lj lk iu ll b lm ln ke lo lp lq kh lr ls lt lu lv lw lx ly lz ma mb mc md me in bi translated">我用过了。你也是。</p><p id="419d" class="pw-post-body-paragraph lj lk iu ll b lm ln ke lo lp lq kh lr ls lt lu lv lw lx ly lz ma mb mc md me in bi translated">它无处不在。到处都是。必不可少。</p><p id="06d5" class="pw-post-body-paragraph lj lk iu ll b lm ln ke lo lp lq kh lr ls lt lu lv lw lx ly lz ma mb mc md me in bi translated">你知道我在说什么:认证。</p><blockquote class="mf"><p id="ecf4" class="mg mh iu bd mi mj mk ml mm mn mo me dk translated">认证描述了证明断言的行为，例如向计算机系统证明你的身份[1]。</p></blockquote><p id="299a" class="pw-post-body-paragraph lj lk iu ll b lm mp ke lo lp mq kh lr ls mr lu lv lw ms ly lz ma mt mc md me in bi translated">或者简单地说——你告诉系统你是谁。</p><p id="47f4" class="pw-post-body-paragraph lj lk iu ll b lm ln ke lo lp lq kh lr ls lt lu lv lw lx ly lz ma mb mc md me in bi translated">由于我们使用的几乎每个现代应用程序都需要身份验证，因此构建一个身份验证服务并一劳永逸地解决这一需求可能是一个好主意。</p><p id="f14b" class="pw-post-body-paragraph lj lk iu ll b lm ln ke lo lp lq kh lr ls lt lu lv lw lx ly lz ma mb mc md me in bi translated">在接下来的部分中，您将使用<a class="ae li" href="https://docs.aws.amazon.com/cognito/index.html" rel="noopener ugc nofollow" target="_blank"> Amazon Cognito </a>、<a class="ae li" href="https://docs.aws.amazon.com/apigateway/" rel="noopener ugc nofollow" target="_blank"> API Gateway </a>和<a class="ae li" href="https://docs.aws.amazon.com/lambda/" rel="noopener ugc nofollow" target="_blank"> AWS Lambda </a>创建一个无服务器的后端服务。</p><p id="44bd" class="pw-post-body-paragraph lj lk iu ll b lm ln ke lo lp lq kh lr ls lt lu lv lw lx ly lz ma mb mc md me in bi translated">通过使用AWS云开发工具包(CDK)，您将能够提供代码形式的基础设施(IaC)——只需一个简单的命令行语句就可以轻松启动或关闭后端服务。</p><p id="7582" class="pw-post-body-paragraph lj lk iu ll b lm ln ke lo lp lq kh lr ls lt lu lv lw lx ly lz ma mb mc md me in bi translated">然而，在深入研究实现细节之前，让我们后退一步，简单地讨论一下高层设计。</p><h1 id="4854" class="mu mv iu bd mw mx my mz na nb nc nd ne kj nf kk ng km nh kn ni kp nj kq nk nl bi translated">高级概述</h1><p id="2d06" class="pw-post-body-paragraph lj lk iu ll b lm nm ke lo lp nn kh lr ls no lu lv lw np ly lz ma nq mc md me in bi translated">在编写任何代码之前，先设想一下完整的图景总是有用的。确保我们确切地知道我们想要达到的目标。</p><figure class="kt ku kv kw gu kx gi gj paragraph-image"><div role="button" tabindex="0" class="ky kz di la bf lb"><div class="gi gj nr"><img src="../Images/decc672ecbb129c0fb3829220c33cc0e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*7ixeijCGt4OX63ECgVs8IA.png"/></div></div><p class="le lf gk gi gj lg lh bd b be z dk translated">AWS无服务器认证流程[图片由作者提供]</p></figure><p id="1759" class="pw-post-body-paragraph lj lk iu ll b lm ln ke lo lp lq kh lr ls lt lu lv lw lx ly lz ma mb mc md me in bi translated">因此，我们的总体目标是创建一个无服务器的后端系统，为我们处理认证。但这实际上意味着什么呢？</p><p id="c65e" class="pw-post-body-paragraph lj lk iu ll b lm ln ke lo lp lq kh lr ls lt lu lv lw lx ly lz ma mb mc md me in bi translated">让我们快速浏览一下上面的流程:</p><ol class=""><li id="f797" class="ns nt iu ll b lm ln lp lq ls nu lw nv ma nw me nx ny nz oa bi translated">用户要么尝试创建新帐户，要么通过提供某种形式的凭证(例如，用户名和密码)来登录</li><li id="5fca" class="ns nt iu ll b lm ob lp oc ls od lw oe ma of me nx ny nz oa bi translated">用户收到一个响应。如果登录成功，它将是一个<a class="ae li" href="https://developer.mozilla.org/en-US/docs/Web/HTTP/Cookies#restrict_access_to_cookies" rel="noopener ugc nofollow" target="_blank"> HttpOnly Cookie </a>，里面有一个<a class="ae li" href="https://jwt.io/introduction" rel="noopener ugc nofollow" target="_blank"> JSON Web令牌</a>。</li><li id="8ea1" class="ns nt iu ll b lm ob lp oc ls od lw oe ma of me nx ny nz oa bi translated">有了cookie，用户试图通过另一个API网关访问受保护的资源。Lambda授权器将解析包含在请求报头中的cookie，并验证JWT。如果验证成功，授权者向用户返回一个策略文档，使得访问受保护的资源成为可能。</li></ol><p id="ecd9" class="pw-post-body-paragraph lj lk iu ll b lm ln ke lo lp lq kh lr ls lt lu lv lw lx ly lz ma mb mc md me in bi translated">这已经是了。</p><p id="69b0" class="pw-post-body-paragraph lj lk iu ll b lm ln ke lo lp lq kh lr ls lt lu lv lw lx ly lz ma mb mc md me in bi translated">现在，让我们从启动我们最喜欢的IDE并创建一个新项目开始。</p><blockquote class="og oh oi"><p id="9c95" class="lj lk oj ll b lm ln ke lo lp lq kh lr ok lt lu lv ol lx ly lz om mb mc md me in bi translated"><strong class="ll je">注意</strong>:所有使用的服务都符合免费等级，因此不会产生额外费用。然而，检查你的AWS帐户并关闭任何未使用的服务仍然是明智的。</p></blockquote><h1 id="dfe3" class="mu mv iu bd mw mx my mz na nb nc nd ne kj nf kk ng km nh kn ni kp nj kq nk nl bi translated">实现无服务器认证服务</h1><p id="0530" class="pw-post-body-paragraph lj lk iu ll b lm nm ke lo lp nn kh lr ls no lu lv lw np ly lz ma nq mc md me in bi translated">首先，确保你已经安装了<a class="ae li" href="https://docs.aws.amazon.com/cdk/v2/guide/getting_started.html" rel="noopener ugc nofollow" target="_blank"> AWS CDK并引导了</a>。以下代码会有所帮助:</p><pre class="kt ku kv kw gu on oo op oq aw or bi"><span id="f22e" class="os mv iu oo b gz ot ou l ov ow">// Install AWS CDK<br/>npm install -g aws-cdk</span><span id="c560" class="os mv iu oo b gz ox ou l ov ow">// Bootstrap AWS CDK<br/>cdk bootstrap aws://ACCOUNT-NUMBER/REGION</span></pre><p id="9842" class="pw-post-body-paragraph lj lk iu ll b lm ln ke lo lp lq kh lr ls lt lu lv lw lx ly lz ma mb mc md me in bi translated">现在我们已经配备了合适的工具，我们可以通过命令行界面创建一个新文件夹并初始化CDK来开始我们的项目。</p><pre class="kt ku kv kw gu on oo op oq aw or bi"><span id="a3fd" class="os mv iu oo b gz ot ou l ov ow">// Create a new folder<br/>mkdir aws-serverless-auth<br/>cd aws-serverless-auth</span><span id="bd17" class="os mv iu oo b gz ox ou l ov ow">// Init CDK<br/>cdk init --language typescript</span></pre><p id="bdca" class="pw-post-body-paragraph lj lk iu ll b lm ln ke lo lp lq kh lr ls lt lu lv lw lx ly lz ma mb mc md me in bi translated">一旦安装过程完成，我们就可以打开代码编辑器开始工作了。</p><h2 id="ba61" class="os mv iu bd mw oy oz dn na pa pb dp ne ls pc pd ng lw pe pf ni ma pg ph nk ja bi translated">创建Amazon Cognito用户池</h2><p id="a474" class="pw-post-body-paragraph lj lk iu ll b lm nm ke lo lp nn kh lr ls no lu lv lw np ly lz ma nq mc md me in bi translated">重要的事情先来。</p><p id="399b" class="pw-post-body-paragraph lj lk iu ll b lm ln ke lo lp lq kh lr ls lt lu lv lw lx ly lz ma mb mc md me in bi translated">为了构建合适的认证服务，我们必须首先创建某种形式的用户数据库。为此，我们使用Amazon Cognito，幸运的是它为我们提供了所有需要的特性。</p><p id="6eaa" class="pw-post-body-paragraph lj lk iu ll b lm ln ke lo lp lq kh lr ls lt lu lv lw lx ly lz ma mb mc md me in bi translated">在<code class="fe pi pj pk oo b">lib</code>文件夹中，创建一个名为<code class="fe pi pj pk oo b">user-pool.ts</code>的新文件。</p><figure class="kt ku kv kw gu kx"><div class="bz fq l di"><div class="pl pm l"/></div></figure><p id="59b6" class="pw-post-body-paragraph lj lk iu ll b lm ln ke lo lp lq kh lr ls lt lu lv lw lx ly lz ma mb mc md me in bi translated">在上面的代码中，我们导出了一个名为<code class="fe pi pj pk oo b">CognitoUserPool</code>的类。</p><p id="75a4" class="pw-post-body-paragraph lj lk iu ll b lm ln ke lo lp lq kh lr ls lt lu lv lw lx ly lz ma mb mc md me in bi translated">在类构造函数中，我们基本上创建了一个新的用户池，并为它附加了一个应用程序客户端。在实例化一个新的用户池时，我们还确保传递所需的配置参数。</p><p id="8ffa" class="pw-post-body-paragraph lj lk iu ll b lm ln ke lo lp lq kh lr ls lt lu lv lw lx ly lz ma mb mc md me in bi translated">注意，我们公开了两个只读类字段以供进一步参考，即<code class="fe pi pj pk oo b">userPoolId</code>和<code class="fe pi pj pk oo b">userPoolClientId</code>。</p><h2 id="5883" class="os mv iu bd mw oy oz dn na pa pb dp ne ls pc pd ng lw pe pf ni ma pg ph nk ja bi translated">构建身份验证API</h2><p id="cc7c" class="pw-post-body-paragraph lj lk iu ll b lm nm ke lo lp nn kh lr ls no lu lv lw np ly lz ma nq mc md me in bi translated">现在，让我们继续讨论具体细节——身份验证API。</p><p id="7e2e" class="pw-post-body-paragraph lj lk iu ll b lm ln ke lo lp lq kh lr ls lt lu lv lw lx ly lz ma mb mc md me in bi translated">再次，在<code class="fe pi pj pk oo b">lib</code>文件夹中创建一个名为<code class="fe pi pj pk oo b">auth-api.ts</code>的新文件。</p><p id="7a17" class="pw-post-body-paragraph lj lk iu ll b lm ln ke lo lp lq kh lr ls lt lu lv lw lx ly lz ma mb mc md me in bi translated">让我们简单明了地开始，首先构造一个RestAPI，并确保我们的类构造函数接收正确的属性。</p><p id="fa47" class="pw-post-body-paragraph lj lk iu ll b lm ln ke lo lp lq kh lr ls lt lu lv lw lx ly lz ma mb mc md me in bi translated">接下来，我们添加一个新资源，并为其附加几个lambda函数。为了让我们的生活更容易，我们将使用一个名为<code class="fe pi pj pk oo b">addRoute()</code>的私有助手方法。</p><blockquote class="og oh oi"><p id="1fec" class="lj lk oj ll b lm ln ke lo lp lq kh lr ok lt lu lv ol lx ly lz om mb mc md me in bi translated"><strong class="ll je">注意</strong>:我们将在下一节创建所有必要的Lambda函数。</p></blockquote><figure class="kt ku kv kw gu kx"><div class="bz fq l di"><div class="pl pm l"/></div></figure><p id="c2c4" class="pw-post-body-paragraph lj lk iu ll b lm ln ke lo lp lq kh lr ls lt lu lv lw lx ly lz ma mb mc md me in bi translated">每个Lambda函数对应一条单独的路线和一个特定的用户操作。</p><p id="b036" class="pw-post-body-paragraph lj lk iu ll b lm ln ke lo lp lq kh lr ls lt lu lv lw lx ly lz ma mb mc md me in bi translated">通过使用helper方法，我们不仅可以减少代码重复，还可以为每个功能提供强制的环境变量以及正确的策略(例如，允许访问Cognito用户池)。</p><h2 id="5203" class="os mv iu bd mw oy oz dn na pa pb dp ne ls pc pd ng lw pe pf ni ma pg ph nk ja bi translated">实现auth Lambda函数</h2><p id="a270" class="pw-post-body-paragraph lj lk iu ll b lm nm ke lo lp nn kh lr ls no lu lv lw np ly lz ma nq mc md me in bi translated">到目前为止，一切顺利。</p><p id="28a5" class="pw-post-body-paragraph lj lk iu ll b lm ln ke lo lp lq kh lr ls lt lu lv lw lx ly lz ma mb mc md me in bi translated">我们已经创建了一个Cognito用户池和一个RestAPI，允许我们向外界公开我们的认证逻辑。</p><p id="26e4" class="pw-post-body-paragraph lj lk iu ll b lm ln ke lo lp lq kh lr ls lt lu lv lw lx ly lz ma mb mc md me in bi translated">然而，我们还没有实现这样的逻辑。</p><p id="4811" class="pw-post-body-paragraph lj lk iu ll b lm ln ke lo lp lq kh lr ls lt lu lv lw lx ly lz ma mb mc md me in bi translated">在根项目文件夹中，我们创建一个名为<code class="fe pi pj pk oo b">lambda</code>的新目录。我们打开新目录并创建一个名为<code class="fe pi pj pk oo b">auth</code>的子文件夹。</p><blockquote class="og oh oi"><p id="5990" class="lj lk oj ll b lm ln ke lo lp lq kh lr ok lt lu lv ol lx ly lz om mb mc md me in bi translated"><strong class="ll je">注意</strong>:为了安装AWS Lambda的类型定义，在您的终端中输入<code class="fe pi pj pk oo b"><em class="iu">npm install @types/aws-lambda</em></code>。</p></blockquote><h2 id="dcd9" class="os mv iu bd mw oy oz dn na pa pb dp ne ls pc pd ng lw pe pf ni ma pg ph nk ja bi translated">注册</h2><p id="d352" class="pw-post-body-paragraph lj lk iu ll b lm nm ke lo lp nn kh lr ls no lu lv lw np ly lz ma nq mc md me in bi translated">让我们从注册功能开始，创建一个新文件<code class="fe pi pj pk oo b">signup.ts</code>。</p><figure class="kt ku kv kw gu kx"><div class="bz fq l di"><div class="pl pm l"/></div></figure><p id="f7dd" class="pw-post-body-paragraph lj lk iu ll b lm ln ke lo lp lq kh lr ls lt lu lv lw lx ly lz ma mb mc md me in bi translated">一旦我们确保收到了正确的事件体(用户的凭证)，我们只需在<code class="fe pi pj pk oo b">CognitoIdentityServiceProvider</code>的实例上调用<code class="fe pi pj pk oo b">signUp()</code>方法，并向用户返回一个响应。</p><p id="99c6" class="pw-post-body-paragraph lj lk iu ll b lm ln ke lo lp lq kh lr ls lt lu lv lw lx ly lz ma mb mc md me in bi translated">如果注册成功，用户将需要验证所提供的电子邮件地址，并通过输入验证码来确认注册。</p><h2 id="2ba9" class="os mv iu bd mw oy oz dn na pa pb dp ne ls pc pd ng lw pe pf ni ma pg ph nk ja bi translated">确认注册</h2><p id="cc52" class="pw-post-body-paragraph lj lk iu ll b lm nm ke lo lp nn kh lr ls no lu lv lw np ly lz ma nq mc md me in bi translated">你知道规矩的。</p><p id="3d69" class="pw-post-body-paragraph lj lk iu ll b lm ln ke lo lp lq kh lr ls lt lu lv lw lx ly lz ma mb mc md me in bi translated">创建一个名为<code class="fe pi pj pk oo b">confirm-signup.ts</code>的新文件。</p><figure class="kt ku kv kw gu kx"><div class="bz fq l di"><div class="pl pm l"/></div></figure><p id="59dd" class="pw-post-body-paragraph lj lk iu ll b lm ln ke lo lp lq kh lr ls lt lu lv lw lx ly lz ma mb mc md me in bi translated">这里没什么特别的。</p><p id="a9c5" class="pw-post-body-paragraph lj lk iu ll b lm ln ke lo lp lq kh lr ls lt lu lv lw lx ly lz ma mb mc md me in bi translated">我们只需接收用户名和确认码，并将其传递给<code class="fe pi pj pk oo b">CognitoIdentityServiceProvider</code>的<code class="fe pi pj pk oo b">confirmSignup()</code>方法。最后，我们向用户返回一个适当的响应。</p><h2 id="360a" class="os mv iu bd mw oy oz dn na pa pb dp ne ls pc pd ng lw pe pf ni ma pg ph nk ja bi translated">签到</h2><p id="45d8" class="pw-post-body-paragraph lj lk iu ll b lm nm ke lo lp nn kh lr ls no lu lv lw np ly lz ma nq mc md me in bi translated">现在，我们能够创建一个新用户，我们可以开始工作在登录功能。仍然在<code class="fe pi pj pk oo b">auth</code>文件夹中，创建一个名为<code class="fe pi pj pk oo b">signin.ts</code>的新文件。</p><figure class="kt ku kv kw gu kx"><div class="bz fq l di"><div class="pl pm l"/></div></figure><p id="d02d" class="pw-post-body-paragraph lj lk iu ll b lm ln ke lo lp lq kh lr ls lt lu lv lw lx ly lz ma mb mc md me in bi translated">在登录函数中，我们收集用户名和密码，以便调用<code class="fe pi pj pk oo b">initiateAuth()</code>方法。如果给定的凭证是正确的，我们从<code class="fe pi pj pk oo b">AuthenticationResult</code>中提取<code class="fe pi pj pk oo b">IdToken</code>，并在响应头中设置一个<code class="fe pi pj pk oo b">Secure </code>和<code class="fe pi pj pk oo b">HttpOnly</code> cookie，并将令牌作为有效负载。</p><h2 id="9233" class="os mv iu bd mw oy oz dn na pa pb dp ne ls pc pd ng lw pe pf ni ma pg ph nk ja bi translated">签名登记离开</h2><p id="bd94" class="pw-post-body-paragraph lj lk iu ll b lm nm ke lo lp nn kh lr ls no lu lv lw np ly lz ma nq mc md me in bi translated">注销功能超级基础。</p><p id="ead3" class="pw-post-body-paragraph lj lk iu ll b lm ln ke lo lp lq kh lr ls lt lu lv lw lx ly lz ma mb mc md me in bi translated">我们只需创建一个新文件<code class="fe pi pj pk oo b">signout.ts</code>，并通过将cookie的到期日期设置为过去来“删除”cookie。</p><figure class="kt ku kv kw gu kx"><div class="bz fq l di"><div class="pl pm l"/></div></figure><h1 id="a61b" class="mu mv iu bd mw mx my mz na nb nc nd ne kj nf kk ng km nh kn ni kp nj kq nk nl bi translated">创建受保护的API和Lamba授权器</h1><p id="0890" class="pw-post-body-paragraph lj lk iu ll b lm nm ke lo lp nn kh lr ls no lu lv lw np ly lz ma nq mc md me in bi translated">我们快到终点线了。</p><p id="aa41" class="pw-post-body-paragraph lj lk iu ll b lm ln ke lo lp lq kh lr ls lt lu lv lw lx ly lz ma mb mc md me in bi translated">现在，我们已经实现了身份验证API和所有必要的Lambda函数，我们可以开始处理最后缺失的部分了:受保护的RestAPI和Lambda授权器。</p><h2 id="2c88" class="os mv iu bd mw oy oz dn na pa pb dp ne ls pc pd ng lw pe pf ni ma pg ph nk ja bi translated">构建受保护的API</h2><p id="9a1c" class="pw-post-body-paragraph lj lk iu ll b lm nm ke lo lp nn kh lr ls no lu lv lw np ly lz ma nq mc md me in bi translated">让我们从最简单的部分开始。</p><p id="a6ad" class="pw-post-body-paragraph lj lk iu ll b lm ln ke lo lp lq kh lr ls lt lu lv lw lx ly lz ma mb mc md me in bi translated">在文件夹<code class="fe pi pj pk oo b">lib</code>中，我们创建一个名为<code class="fe pi pj pk oo b">protected-api.ts</code>的新文件。</p><figure class="kt ku kv kw gu kx"><div class="bz fq l di"><div class="pl pm l"/></div></figure><p id="4495" class="pw-post-body-paragraph lj lk iu ll b lm ln ke lo lp lq kh lr ls lt lu lv lw lx ly lz ma mb mc md me in bi translated">在上面的代码中，我们定义了一个简单的RestAPI、两个lambda函数以及它们的集成。</p><p id="1a4b" class="pw-post-body-paragraph lj lk iu ll b lm ln ke lo lp lq kh lr ls lt lu lv lw lx ly lz ma mb mc md me in bi translated"><code class="fe pi pj pk oo b">protectedFn</code>只返回一条消息，允许我们模拟一些受保护的资源。我们在<code class="fe pi pj pk oo b">lambda</code>文件夹中创建一个名为<code class="fe pi pj pk oo b">protected.ts</code>的新文件。</p><figure class="kt ku kv kw gu kx"><div class="bz fq l di"><div class="pl pm l"/></div></figure><p id="fd71" class="pw-post-body-paragraph lj lk iu ll b lm ln ke lo lp lq kh lr ls lt lu lv lw lx ly lz ma mb mc md me in bi translated">通过提供一个<code class="fe pi pj pk oo b">RequestAuthorizer</code>并将我们的Lambda授权器设置为处理程序，我们确保了路由受到保护。</p><h2 id="c53e" class="os mv iu bd mw oy oz dn na pa pb dp ne ls pc pd ng lw pe pf ni ma pg ph nk ja bi translated">实现Lambda授权器</h2><p id="bca2" class="pw-post-body-paragraph lj lk iu ll b lm nm ke lo lp nn kh lr ls no lu lv lw np ly lz ma nq mc md me in bi translated">Lambda授权器做两件事:</p><ol class=""><li id="9538" class="ns nt iu ll b lm ln lp lq ls nu lw nv ma nw me nx ny nz oa bi translated">它解析请求头中提供的cookie，并验证JWT。</li><li id="816e" class="ns nt iu ll b lm ob lp oc ls od lw oe ma of me nx ny nz oa bi translated">它返回一个策略文档，拒绝或允许对资源的访问。</li></ol><p id="cad3" class="pw-post-body-paragraph lj lk iu ll b lm ln ke lo lp lq kh lr ls lt lu lv lw lx ly lz ma mb mc md me in bi translated">很简单，对吧？</p><p id="d5c9" class="pw-post-body-paragraph lj lk iu ll b lm ln ke lo lp lq kh lr ls lt lu lv lw lx ly lz ma mb mc md me in bi translated">让我们继续在<code class="fe pi pj pk oo b">lambda/auth</code>文件夹中创建一个新文件<code class="fe pi pj pk oo b">authorizer.ts</code>。</p><figure class="kt ku kv kw gu kx"><div class="bz fq l di"><div class="pl pm l"/></div></figure><p id="6a00" class="pw-post-body-paragraph lj lk iu ll b lm ln ke lo lp lq kh lr ls lt lu lv lw lx ly lz ma mb mc md me in bi translated">在授权器内部，我们使用了三个助手函数:<code class="fe pi pj pk oo b">parseCookies(), verifyToken()</code>和<code class="fe pi pj pk oo b">createPolicy()</code>。</p><p id="bd50" class="pw-post-body-paragraph lj lk iu ll b lm ln ke lo lp lq kh lr ls lt lu lv lw lx ly lz ma mb mc md me in bi translated">让我们接下来讨论这些。</p><p id="410e" class="pw-post-body-paragraph lj lk iu ll b lm ln ke lo lp lq kh lr ls lt lu lv lw lx ly lz ma mb mc md me in bi translated">但是首先，在文件夹<code class="fe pi pj pk oo b">lambda</code>中创建一个新文件<code class="fe pi pj pk oo b">utils.ts</code>，它将包含所有这三个助手函数。它看起来是这样的:</p><figure class="kt ku kv kw gu kx"><div class="bz fq l di"><div class="pl pm l"/></div></figure><p id="c8e5" class="pw-post-body-paragraph lj lk iu ll b lm ln ke lo lp lq kh lr ls lt lu lv lw lx ly lz ma mb mc md me in bi translated">我们的第一个助手函数顾名思义就是解析请求头中的cookies。基本上是遍历<code class="fe pi pj pk oo b">headers.Cookie</code>对象，并用cookie名和值创建一个<code class="fe pi pj pk oo b">cookieMap</code>。</p><p id="74ac" class="pw-post-body-paragraph lj lk iu ll b lm ln ke lo lp lq kh lr ls lt lu lv lw lx ly lz ma mb mc md me in bi translated">一旦我们用令牌检索到cookie，我们需要验证它。</p><figure class="kt ku kv kw gu kx"><div class="bz fq l di"><div class="pl pm l"/></div></figure><p id="e4ab" class="pw-post-body-paragraph lj lk iu ll b lm ln ke lo lp lq kh lr ls lt lu lv lw lx ly lz ma mb mc md me in bi translated">下一个助手函数<code class="fe pi pj pk oo b">verifyToken</code>依赖于三个外部库，所以确保<code class="fe pi pj pk oo b">npm install axios jsonwebtoken jwk-to-pem</code>。</p><p id="6374" class="pw-post-body-paragraph lj lk iu ll b lm ln ke lo lp lq kh lr ls lt lu lv lw lx ly lz ma mb mc md me in bi translated">我们通过请求提供的URL来检索Cognito用户池的JSON web key。接下来，我们在外部库<code class="fe pi pj pk oo b">jwk-to-pem</code>的帮助下转换密钥。一旦我们转换了密钥，我们就可以验证令牌并返回结果。</p><p id="d3e1" class="pw-post-body-paragraph lj lk iu ll b lm ln ke lo lp lq kh lr ls lt lu lv lw lx ly lz ma mb mc md me in bi translated">基于这个结果，我们创建一个策略文档，允许或拒绝对受保护资源的访问。为此，我们创建了最后一个助手函数<code class="fe pi pj pk oo b">createPolicy()</code>。</p><figure class="kt ku kv kw gu kx"><div class="bz fq l di"><div class="pl pm l"/></div></figure><h1 id="f10d" class="mu mv iu bd mw mx my mz na nb nc nd ne kj nf kk ng km nh kn ni kp nj kq nk nl bi translated">把所有的放在一起</h1><p id="5e39" class="pw-post-body-paragraph lj lk iu ll b lm nm ke lo lp nn kh lr ls no lu lv lw np ly lz ma nq mc md me in bi translated">唷——那工作量很大。</p><p id="c99b" class="pw-post-body-paragraph lj lk iu ll b lm ln ke lo lp lq kh lr ls lt lu lv lw lx ly lz ma mb mc md me in bi translated">现在，只剩下一件事要做了。我们必须把它们放在最后的堆栈中。</p><p id="1e72" class="pw-post-body-paragraph lj lk iu ll b lm ln ke lo lp lq kh lr ls lt lu lv lw lx ly lz ma mb mc md me in bi translated">在文件夹<code class="fe pi pj pk oo b">lib</code>中，打开名为<code class="fe pi pj pk oo b">aws-serverless-auth-stack.ts</code>的文件。</p><figure class="kt ku kv kw gu kx"><div class="bz fq l di"><div class="pl pm l"/></div></figure><p id="6491" class="pw-post-body-paragraph lj lk iu ll b lm ln ke lo lp lq kh lr ls lt lu lv lw lx ly lz ma mb mc md me in bi translated">这里，我们简单地实例化了之前创建的所有其他类。我们的认知用户群和两个RestAPIs。注意，我们将<code class="fe pi pj pk oo b">userPoolId</code>和<code class="fe pi pj pk oo b">userPoolClientId</code>作为属性传递给两个API。</p><p id="86c4" class="pw-post-body-paragraph lj lk iu ll b lm ln ke lo lp lq kh lr ls lt lu lv lw lx ly lz ma mb mc md me in bi translated">我们把所有的零件都组装好了。干得好。</p><p id="8770" class="pw-post-body-paragraph lj lk iu ll b lm ln ke lo lp lq kh lr ls lt lu lv lw lx ly lz ma mb mc md me in bi translated">现在，是时候通过在终端中键入<code class="fe pi pj pk oo b">cdk deploy</code>来部署堆栈了。</p><h1 id="7453" class="mu mv iu bd mw mx my mz na nb nc nd ne kj nf kk ng km nh kn ni kp nj kq nk nl bi translated">用Postman测试流</h1><p id="fde2" class="pw-post-body-paragraph lj lk iu ll b lm nm ke lo lp nn kh lr ls no lu lv lw np ly lz ma nq mc md me in bi translated">一旦我们的栈被完全部署，我们就可以通过使用<a class="ae li" href="https://www.postman.com/" rel="noopener ugc nofollow" target="_blank">邮递员</a>来最终测试整个通信流。</p><p id="06fa" class="pw-post-body-paragraph lj lk iu ll b lm ln ke lo lp lq kh lr ls lt lu lv lw lx ly lz ma mb mc md me in bi translated">然而，在开始测试之前，我们需要获得我们的身份验证的URL和受保护的API。因此，转到AWS控制台，导航到API Gateway，选择每个API，选择stages，然后复制URL。</p><p id="ed70" class="pw-post-body-paragraph lj lk iu ll b lm ln ke lo lp lq kh lr ls lt lu lv lw lx ly lz ma mb mc md me in bi translated">让我们开始创建一个新用户并注册吧。</p><p id="a8cc" class="pw-post-body-paragraph lj lk iu ll b lm ln ke lo lp lq kh lr ls lt lu lv lw lx ly lz ma mb mc md me in bi translated">在Postman内部，我们用之前复制的身份验证API的URL创建了一个新的POST请求。我们的JSON请求体只包含用户名、电子邮件和密码。</p><figure class="kt ku kv kw gu kx gi gj paragraph-image"><div class="gi gj pn"><img src="../Images/da05741defb92b5cfbc33baec42fde1f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1230/format:webp/1*aDdEyamlgBndImFmM1qwFg.png"/></div><p class="le lf gk gi gj lg lh bd b be z dk translated">认证测试注册[作者截图]</p></figure><blockquote class="og oh oi"><p id="e900" class="lj lk oj ll b lm ln ke lo lp lq kh lr ok lt lu lv ol lx ly lz om mb mc md me in bi translated"><strong class="ll je">注意</strong>:请确保输入有效的电子邮件地址，因为我们将收到确认码以确认我们的注册请求。</p></blockquote><p id="0b6a" class="pw-post-body-paragraph lj lk iu ll b lm ln ke lo lp lq kh lr ls lt lu lv lw lx ly lz ma mb mc md me in bi translated">接下来，我们必须通过输入我们应该通过邮件收到的验证码来确认我们的注册请求。在Postman内部创建一个新的<code class="fe pi pj pk oo b">POST</code>请求，请求体中包含用户名和代码。</p><figure class="kt ku kv kw gu kx gi gj paragraph-image"><div class="gi gj po"><img src="../Images/754c58ee4606dff231eaf3b776fc6bbb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1292/format:webp/1*anEGWlVh6xdAx9kv8rU26A.png"/></div><p class="le lf gk gi gj lg lh bd b be z dk translated">认证测试确认[作者截图]</p></figure><p id="8ad5" class="pw-post-body-paragraph lj lk iu ll b lm ln ke lo lp lq kh lr ls lt lu lv lw lx ly lz ma mb mc md me in bi translated">收到的响应应该表明我们已经成功地确认了用户注册。</p><p id="427c" class="pw-post-body-paragraph lj lk iu ll b lm ln ke lo lp lq kh lr ls lt lu lv lw lx ly lz ma mb mc md me in bi translated">现在，我们可以测试登录功能。</p><p id="ff1c" class="pw-post-body-paragraph lj lk iu ll b lm ln ke lo lp lq kh lr ls lt lu lv lw lx ly lz ma mb mc md me in bi translated">我们创建了另一个POST请求，在主体中提供了用户名和密码。</p><figure class="kt ku kv kw gu kx gi gj paragraph-image"><div class="gi gj pn"><img src="../Images/b6c22ddb456bebbc47a80750d2752dab.png" data-original-src="https://miro.medium.com/v2/resize:fit:1230/format:webp/1*SUubmklgHe_lk_N40WeSTQ.png"/></div><p class="le lf gk gi gj lg lh bd b be z dk translated">认证测试签到[作者截图]</p></figure><p id="bd2d" class="pw-post-body-paragraph lj lk iu ll b lm ln ke lo lp lq kh lr ls lt lu lv lw lx ly lz ma mb mc md me in bi translated">在响应中，我们应该会收到一个内部带有JSON web令牌的cookie。我们可以通过检查Postman内部的cookies来验证这一点。</p><figure class="kt ku kv kw gu kx gi gj paragraph-image"><div role="button" tabindex="0" class="ky kz di la bf lb"><div class="gi gj pp"><img src="../Images/a8fa36eeb8740a97ad3f32259a88574e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*_3tVwbomws5RuD-lBZbNGw.png"/></div></div><p class="le lf gk gi gj lg lh bd b be z dk translated">AWS Lambda设置的HttpOnly cookie作者截图]</p></figure><p id="6277" class="pw-post-body-paragraph lj lk iu ll b lm ln ke lo lp lq kh lr ls lt lu lv lw lx ly lz ma mb mc md me in bi translated">我们已成功登录。太好了。</p><p id="c1c8" class="pw-post-body-paragraph lj lk iu ll b lm ln ke lo lp lq kh lr ls lt lu lv lw lx ly lz ma mb mc md me in bi translated">现在，让我们尝试访问我们的受保护资源。</p><p id="7e23" class="pw-post-body-paragraph lj lk iu ll b lm ln ke lo lp lq kh lr ls lt lu lv lw lx ly lz ma mb mc md me in bi translated">在Postman内部创建一个GET请求，并点击受保护的路由。此外，确保在你的请求中包含一块饼干 <code class="fe pi pj pk oo b">token=&lt;replace-with-jwt&gt;</code>。</p><figure class="kt ku kv kw gu kx gi gj paragraph-image"><div class="gi gj pq"><img src="../Images/76dc4838e2e77d4132f9f3309459c8e5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1188/format:webp/1*ActFhyJY_modjPYDi8gqAw.png"/></div><p class="le lf gk gi gj lg lh bd b be z dk translated">访问受保护的路线[作者截图]</p></figure><p id="1fc7" class="pw-post-body-paragraph lj lk iu ll b lm ln ke lo lp lq kh lr ls lt lu lv lw lx ly lz ma mb mc md me in bi translated">正如我们可以从响应主体中了解到的那样——它起作用了。我们收到了一个超级秘密。</p><p id="1465" class="pw-post-body-paragraph lj lk iu ll b lm ln ke lo lp lq kh lr ls lt lu lv lw lx ly lz ma mb mc md me in bi translated">这是最后一次了。</p><p id="6af7" class="pw-post-body-paragraph lj lk iu ll b lm ln ke lo lp lq kh lr ls lt lu lv lw lx ly lz ma mb mc md me in bi translated">我们完成了无服务器认证服务。</p><blockquote class="og oh oi"><p id="2e5c" class="lj lk oj ll b lm ln ke lo lp lq kh lr ok lt lu lv ol lx ly lz om mb mc md me in bi translated"><strong class="ll je">注意</strong>:在我们完成测试后，我们可以通过在终端中键入<code class="fe pi pj pk oo b"><em class="iu">cdk destroy</em></code>来拆除基础设施。</p></blockquote></div><div class="ab cl pr ps hy pt" role="separator"><span class="pu bw bk pv pw px"/><span class="pu bw bk pv pw px"/><span class="pu bw bk pv pw"/></div><div class="in io ip iq ir"><h1 id="8cab" class="mu mv iu bd mw mx py mz na nb pz nd ne kj qa kk ng km qb kn ni kp qc kq nk nl bi translated">结论</h1><p id="7657" class="pw-post-body-paragraph lj lk iu ll b lm nm ke lo lp nn kh lr ls no lu lv lw np ly lz ma nq mc md me in bi translated">在本文中，我们利用Amazon Cognito和API Gateway创建了一个无服务器认证服务。我们还利用了CDK，将我们的基础设施创建为代码，这允许我们轻松地启动和拆除整个堆栈。</p><p id="f7d1" class="pw-post-body-paragraph lj lk iu ll b lm ln ke lo lp lq kh lr ls lt lu lv lw lx ly lz ma mb mc md me in bi translated">由于几乎每个应用程序中都要使用身份验证，因此在我们的指尖拥有一个后端服务在未来可能会很有用。</p><p id="c5dd" class="pw-post-body-paragraph lj lk iu ll b lm ln ke lo lp lq kh lr ls lt lu lv lw lx ly lz ma mb mc md me in bi translated">然而，仍有一些改进的余地。我们只能用用户名和密码注册。这可以通过集成联合身份提供商(如Google、LinkedIn等)来进一步增强。</p><p id="99fb" class="pw-post-body-paragraph lj lk iu ll b lm ln ke lo lp lq kh lr ls lt lu lv lw lx ly lz ma mb mc md me in bi translated">感谢阅读。</p><p id="c2ca" class="pw-post-body-paragraph lj lk iu ll b lm ln ke lo lp lq kh lr ls lt lu lv lw lx ly lz ma mb mc md me in bi translated">你可以在我的<a class="ae li" href="https://github.com/marvinlanhenke/aws-serverless-auth" rel="noopener ugc nofollow" target="_blank"> GitHub </a>上找到完整的代码。</p><h1 id="9a47" class="mu mv iu bd mw mx my mz na nb nc nd ne kj nf kk ng km nh kn ni kp nj kq nk nl bi translated">参考</h1><ul class=""><li id="5894" class="ns nt iu ll b lm nm lp nn ls qd lw qe ma qf me qg ny nz oa bi translated">[1]https://en.wikipedia.org/wiki/Authentication<a class="ae li" href="https://en.wikipedia.org/wiki/Authentication" rel="noopener ugc nofollow" target="_blank"/></li><li id="1d3d" class="ns nt iu ll b lm ob lp oc ls od lw oe ma of me qg ny nz oa bi translated"><a class="ae li" href="https://dev.to/gkoniaris/how-to-securely-store-jwt-tokens-51cf" rel="noopener ugc nofollow" target="_blank">https://dev . to/gkoniaris/how-to-secure-store-jwt-tokens-51cf</a></li><li id="b008" class="ns nt iu ll b lm ob lp oc ls od lw oe ma of me qg ny nz oa bi translated"><a class="ae li" href="https://stackoverflow.com/questions/27067251/where-to-store-jwt-in-browser-how-to-protect-against-csrf" rel="noopener ugc nofollow" target="_blank">https://stack overflow . com/questions/27067251/where-to-store-jwt-in-browser-how-to-protect-against-csrf</a></li><li id="883d" class="ns nt iu ll b lm ob lp oc ls od lw oe ma of me qg ny nz oa bi translated"><a class="ae li" href="https://docs.aws.amazon.com/cdk/v2/guide/home.html" rel="noopener ugc nofollow" target="_blank">https://docs.aws.amazon.com/cdk/v2/guide/home.html</a></li></ul></div></div>    
</body>
</html>