<html>
<head>
<title>What’s New in SwiftUI 2.0?</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">SwiftUI 2.0有什么新功能？</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/whats-new-in-swiftui-2-0-ed13f2c40ae2?source=collection_archive---------4-----------------------#2020-06-23">https://betterprogramming.pub/whats-new-in-swiftui-2-0-ed13f2c40ae2?source=collection_archive---------4-----------------------#2020-06-23</a></blockquote><div><div class="fc ii ij ik il im"/><div class="in io ip iq ir"><div class=""/><div class=""><h2 id="18d6" class="pw-subtitle-paragraph jr it iu bd b js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki dk translated">iOS 14带来了Lazy Stacks、ProgressView、ColorPickers、标签、网格和更多SwiftUI控件</h2></div><figure class="kk kl km kn gu ko gi gj paragraph-image"><div role="button" tabindex="0" class="kp kq di kr bf ks"><div class="gi gj kj"><img src="../Images/6ae98c380f92d600b07f4f89e2f57235.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*Y9aik8mn-Vho19Q2"/></div></div><p class="kv kw gk gi gj kx ky bd b be z dk translated"><a class="ae kz" href="https://unsplash.com/@lmtrochezz?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Lina Trochez </a>在<a class="ae kz" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</p></figure><p id="262c" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">WWDC 2020于本周开始，开发者社区热切期待SwiftUI 2.0。不出所料，苹果在Keynote结束时放弃了一些针对SwiftUI的全新API更新。</p><p id="be02" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">SwiftUI中的新改进本质上是附加的。这意味着没有会破坏您的旧的13个SwiftUI代码库的不赞成或改变。</p><p id="28e9" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">在接下来的几节中，我们将先睹为快，看看iOS 14发布的新SwiftUI控件。你需要一个Xcode 12测试版(要求macOS最低版本为10.15.4)来运行它们。让我们开始吧。</p></div><div class="ab cl lw lx hy ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="in io ip iq ir"><h1 id="2a51" class="md me iu bd mf mg mh mi mj mk ml mm mn ka mo kb mp kd mq ke mr kg ms kh mt mu bi translated">新的SwiftUI应用起点</h1><p id="6a40" class="pw-post-body-paragraph la lb iu lc b ld mv jv lf lg mw jy li lj mx ll lm ln my lp lq lr mz lt lu lv in bi translated">到目前为止，我们必须使用<code class="fe na nb nc nd b">AppDelegates</code>和<code class="fe na nb nc nd b">SceneDelegates</code>来设置我们的第一个SwiftUI视图。Swift 5.3引入了基于类型的程序入口点，可以使用<code class="fe na nb nc nd b">@main</code>属性进行设置，最新的SwiftUI迭代巧妙地利用了这一点。</p><figure class="kk kl km kn gu ko gi gj paragraph-image"><div role="button" tabindex="0" class="kp kq di kr bf ks"><div class="gi gj ne"><img src="../Images/100ad20202513ba60b81b37c838a51cf.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ACvrmU6GTDxZ8XtwDFzGgQ.png"/></div></div><p class="kv kw gk gi gj kx ky bd b be z dk translated">Xcode 12新项目</p></figure><p id="c7f8" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">SwiftUI现在提供了以下在应用程序启动时调用的结构:</p><figure class="kk kl km kn gu ko"><div class="bz fq l di"><div class="nf ng l"/></div></figure><p id="3c65" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated"><code class="fe na nb nc nd b">WindowGroup</code>是内部的一个场景属性，这样我们可以定义起始视图层次。我们可以在<code class="fe na nb nc nd b">WindowGroup</code>计算属性中设置TabView、NavigationViews或应用程序剪辑。</p></div><div class="ab cl lw lx hy ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="in io ip iq ir"><h1 id="c0d1" class="md me iu bd mf mg mh mi mj mk ml mm mn ka mo kb mp kd mq ke mr kg ms kh mt mu bi translated">SwiftUI LazyVStack和LazyHStack</h1><p id="4d14" class="pw-post-body-paragraph la lb iu lc b ld mv jv lf lg mw jy li lj mx ll lm ln my lp lq lr mz lt lu lv in bi translated">以前，SwiftUI视图通常会立即加载，这在填充大量数据时会导致性能和内存问题。</p><p id="4ede" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">有趣的是，在SwiftUI的第一次迭代中，<code class="fe na nb nc nd b">NavigationLink</code> destination视图也曾提前加载内容。这一次，苹果推出了新的惰性水平和垂直堆栈，在需要时加载内容，从而有助于SwiftUI的性能优化。现在SwiftUI列表中也引入了延迟加载。</p><p id="a5eb" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">下面是SwiftUI <code class="fe na nb nc nd b">LazyHStack</code>的一个实例:</p><figure class="kk kl km kn gu ko"><div class="bz fq l di"><div class="nf ng l"/></div></figure><figure class="kk kl km kn gu ko gi gj paragraph-image"><div role="button" tabindex="0" class="kp kq di kr bf ks"><div class="gi gj nh"><img src="../Images/fdc3548dd158ae34d57e17b59436f468.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*rb3Oip8phBtSq_xSW5MbKw.gif"/></div></div></figure></div><div class="ab cl lw lx hy ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="in io ip iq ir"><h1 id="4165" class="md me iu bd mf mg mh mi mj mk ml mm mn ka mo kb mp kd mq ke mr kg ms kh mt mu bi translated">SwiftUI滚动视图位置</h1><p id="c952" class="pw-post-body-paragraph la lb iu lc b ld mv jv lf lg mw jy li lj mx ll lm ln my lp lq lr mz lt lu lv in bi translated">由于功能有限，SwiftUI的第一个版本在<code class="fe na nb nc nd b">ScrollView</code>前线遭受了很多损失。iOS 14的SwiftUI带来了急需的<code class="fe na nb nc nd b">ScrollViewReader</code>和<code class="fe na nb nc nd b">ScrollViewProxy</code>来捕捉滚动视图偏移位置，并以编程方式移动到它们上面。</p><p id="e316" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">为了做到这一点，我们将视图嵌入到一个<code class="fe na nb nc nd b">ScrollViewReader</code>中，并以下列方式之一使用<code class="fe na nb nc nd b">scrollTo</code>方法:</p><pre class="kk kl km kn gu ni nd nj nk aw nl bi"><span id="207c" class="nm me iu nd b gz nn no l np nq">scrollView.scrollTo(viewId)<br/>//or<br/>scrollView.scrollTo(viewId, anchor: .center)</span></pre><p id="33c3" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">默认情况下，滚动视图位置设置为视图的开头或顶部。我们可以通过使用<code class="fe na nb nc nd b">anchor</code>属性来细化它。例如，在下面这段代码中，当将anchor属性设置为<code class="fe na nb nc nd b">center</code>时，滚动位置看起来比设置为<code class="fe na nb nc nd b">leading</code>时好得多。</p><figure class="kk kl km kn gu ko gi gj paragraph-image"><div role="button" tabindex="0" class="kp kq di kr bf ks"><div class="gi gj nr"><img src="../Images/eb5dc339b1115e1a75f65df920cfa77a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*ntjkdWJMJEY1Q-l5-ATzDw.gif"/></div></div></figure></div><div class="ab cl lw lx hy ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="in io ip iq ir"><h1 id="068e" class="md me iu bd mf mg mh mi mj mk ml mm mn ka mo kb mp kd mq ke mr kg ms kh mt mu bi translated">SwiftUI进度视图</h1><p id="8d77" class="pw-post-body-paragraph la lb iu lc b ld mv jv lf lg mw jy li lj mx ll lm ln my lp lq lr mz lt lu lv in bi translated">以前，我们必须利用SwiftUI形状来复制线性的<code class="fe na nb nc nd b">ProgressView</code>和<code class="fe na nb nc nd b">UIViewRepresentable</code>，以便在SwiftUI中创建<code class="fe na nb nc nd b">ActivityIndicator</code>。现在，在iOS 14的SwiftUI中，<code class="fe na nb nc nd b">ProgressView</code>有了原生支持。</p><p id="7ea6" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">默认的<code class="fe na nb nc nd b">ProgressView()</code>创建一个类似进度加载器的不确定的<code class="fe na nb nc nd b">UIActivityIndicator</code>，而下面的在SwiftUI中创建一个线性的<code class="fe na nb nc nd b">ProgressView</code>:</p><pre class="kk kl km kn gu ni nd nj nk aw nl bi"><span id="4aa2" class="nm me iu nd b gz nn no l np nq">ProgressView("Text", value: 10, total: 100)</span></pre><p id="eaf7" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">我们可以通过使用<code class="fe na nb nc nd b">progressViewStyle</code>来进一步定制<code class="fe na nb nc nd b">ProgressView</code>，它接受内置的<code class="fe na nb nc nd b">CircularProgressViewStyle</code>、<code class="fe na nb nc nd b">DefaultProgressViewStyle</code>，并允许您创建定制的修饰符。</p><figure class="kk kl km kn gu ko gi gj paragraph-image"><div role="button" tabindex="0" class="kp kq di kr bf ks"><div class="gi gj nr"><img src="../Images/feb171cfec0a7a9f400aa870e9cdd59d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*8gT0Px42uOjvgHIxiTEHFA.gif"/></div></div></figure><p id="4ec1" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated"><code class="fe na nb nc nd b">accentColor</code>用于设置<code class="fe na nb nc nd b">ProgressView</code>中的文字颜色，<code class="fe na nb nc nd b">foregroundColor</code>作为<code class="fe na nb nc nd b">tint</code>。</p></div><div class="ab cl lw lx hy ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="in io ip iq ir"><h1 id="5a09" class="md me iu bd mf mg mh mi mj mk ml mm mn ka mo kb mp kd mq ke mr kg ms kh mt mu bi translated">SwiftUI标签、链接和颜色选择器</h1><p id="b6b9" class="pw-post-body-paragraph la lb iu lc b ld mv jv lf lg mw jy li lj mx ll lm ln my lp lq lr mz lt lu lv in bi translated">标签是最新SwiftUI迭代中非常需要的附加功能。它们允许您使用以下代码行在文本旁边设置图标:</p><pre class="kk kl km kn gu ni nd nj nk aw nl bi"><span id="facc" class="nm me iu nd b gz nn no l np nq">Label("SwiftUI 2.0", systemImage: "checkmark.icloud")</span></pre><p id="b3e4" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">在<code class="fe na nb nc nd b">icons</code>属性中，您可以设置SF符号、图像资产或自定义SwiftUI形状。</p><p id="cc81" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated"><em class="ns">注:书写时，图标与文本顶部对齐。希望这个问题能很快得到解决。</em></p><p id="da2d" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">SwiftUI Link是另一个很酷的UI控件，它为导航到URL提供内置支持:</p><pre class="kk kl km kn gu ni nd nj nk aw nl bi"><span id="be71" class="nm me iu nd b gz nn no l np nq">Link("Click me",destination: URL(string: "your_url")!)</span></pre><p id="9a5f" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">如果是通用链接，链接将被重定向到web浏览器或相关应用程序。</p><p id="29c9" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">SwiftUI库的另一个重大改进是包含了一个原生的<code class="fe na nb nc nd b">ColorPicker</code> UI控件。您可以使用一个<code class="fe na nb nc nd b">State</code>属性包装器来更新用户选择的颜色。</p><pre class="kk kl km kn gu ni nd nj nk aw nl bi"><span id="aa2c" class="nm me iu nd b gz nn no l np nq">ColorPicker("Sample Picker", selection: $myColor)</span></pre></div><div class="ab cl lw lx hy ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="in io ip iq ir"><h1 id="1a1a" class="md me iu bd mf mg mh mi mj mk ml mm mn ka mo kb mp kd mq ke mr kg ms kh mt mu bi translated">SwiftUI TextEditor，MapKit，登录Apple</h1><p id="413a" class="pw-post-body-paragraph la lb iu lc b ld mv jv lf lg mw jy li lj mx ll lm ln my lp lq lr mz lt lu lv in bi translated">上次省略的多行可滚动<code class="fe na nb nc nd b">UITextViews</code>现在原生包含在SwiftUI中，称为<code class="fe na nb nc nd b">TextEditor</code>。</p><pre class="kk kl km kn gu ni nd nj nk aw nl bi"><span id="a713" class="nm me iu nd b gz nn no l np nq">TextEditor(text: $stateProperty)</span></pre><p id="71a6" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">MapKit必须通过封装在<code class="fe na nb nc nd b">UIViewRepresentable</code>中才能嵌入SwiftUI，现在可以原生添加了。我们可以通过一个<code class="fe na nb nc nd b">MKCoordinateRegion</code>，显示用户位置，并直接从SwiftUI的视图界面本身做许多其他的<code class="fe na nb nc nd b">MapKit</code>事情。</p><pre class="kk kl km kn gu ni nd nj nk aw nl bi"><span id="835e" class="nm me iu nd b gz nn no l np nq">Map(mapRect:interactionModes:showsUserLocation: userTrackingMode:</span></pre><p id="3425" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated"><code class="fe na nb nc nd b">SignInWithAppleButton</code>现在进入SwiftUI的内置控制。要设置按钮，我们只需实例化<code class="fe na nb nc nd b">struct</code>并将<code class="fe na nb nc nd b">label</code>参数设置为<code class="fe na nb nc nd b">.signUp</code>或<code class="fe na nb nc nd b">.signIn</code>来指示授权的类型。关于其语法的更多细节，请参考<a class="ae kz" href="https://developer.apple.com/documentation/swiftui/signinwithapplebutton?changes=latest_minor" rel="noopener ugc nofollow" target="_blank">官方文档</a>。</p></div><div class="ab cl lw lx hy ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="in io ip iq ir"><h1 id="f845" class="md me iu bd mf mg mh mi mj mk ml mm mn ka mo kb mp kd mq ke mr kg ms kh mt mu bi translated">一个新的onChange修饰符来监听状态变化</h1><p id="aa81" class="pw-post-body-paragraph la lb iu lc b ld mv jv lf lg mw jy li lj mx ll lm ln my lp lq lr mz lt lu lv in bi translated"><code class="fe na nb nc nd b">onChange</code>是一个新的视图修改器，可用于所有SwiftUI视图。它允许您监听状态变化，并相应地对视图执行操作。</p><p id="ba07" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">例如，我们可以切换一个按钮的状态变化，并触发<code class="fe na nb nc nd b">TextEditor</code>清除，因为已经附加了<code class="fe na nb nc nd b">onChanged</code>修改器，如下所示:</p><figure class="kk kl km kn gu ko"><div class="bz fq l di"><div class="nf ng l"/></div></figure><p id="90db" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated"><em class="ns">注:</em> <code class="fe na nb nc nd b"><em class="ns">clearText</em></code> <em class="ns">状态属性在SwiftUI的body被实例化</em>时第一次自动触发 <code class="fe na nb nc nd b"><em class="ns">onChange</em></code> <em class="ns">修改器。</em></p></div><div class="ab cl lw lx hy ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="in io ip iq ir"><h1 id="ec45" class="md me iu bd mf mg mh mi mj mk ml mm mn ka mo kb mp kd mq ke mr kg ms kh mt mu bi translated">SwiftUI TabView为页面控制带来新风格</h1><p id="4bb1" class="pw-post-body-paragraph la lb iu lc b ld mv jv lf lg mw jy li lj mx ll lm ln my lp lq lr mz lt lu lv in bi translated"><code class="fe na nb nc nd b">UIPageViewController</code>上一次确实进入了SwiftUI。在iOS 14迭代中，<code class="fe na nb nc nd b">TabView</code>引入了一种新的风格，让你在SwiftUI视图中嵌入可切换的页面控件。只需在<code class="fe na nb nc nd b">.tabViewStyle()</code>修改器中设置<code class="fe na nb nc nd b">PageTabViewStyle()</code>，如下所示:</p><figure class="kk kl km kn gu ko"><div class="bz fq l di"><div class="nf ng l"/></div></figure><p id="1060" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">下面是上面代码在Xcode 12上运行的截屏:</p><figure class="kk kl km kn gu ko gi gj paragraph-image"><div role="button" tabindex="0" class="kp kq di kr bf ks"><div class="gi gj nr"><img src="../Images/252ccfc9665238e8083ea8a2c8690d20.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*c2j0nQ77J8Q1NxsybVP2rg.gif"/></div></div></figure></div><div class="ab cl lw lx hy ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="in io ip iq ir"><h1 id="0c18" class="md me iu bd mf mg mh mi mj mk ml mm mn ka mo kb mp kd mq ke mr kg ms kh mt mu bi translated">SwiftUI网格</h1><p id="9785" class="pw-post-body-paragraph la lb iu lc b ld mv jv lf lg mw jy li lj mx ll lm ln my lp lq lr mz lt lu lv in bi translated">iOS 14 SwiftUI中再次缺失了CollectionView和Compositional Layouts。但这并没有阻止苹果为基于网格的布局引入新的容器，让你在<code class="fe na nb nc nd b">LazyHGrid</code>或<code class="fe na nb nc nd b">LazyVGrid</code>中设置子视图。</p><p id="db7d" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">SwiftUI网格的每个元素都是一个<code class="fe na nb nc nd b">GridItem</code>。我们可以设置<code class="fe na nb nc nd b">GridItem</code>的对齐、间距和大小。在以下代码中，我们在SwiftUI中创建了由三列组成的垂直网格布局:</p><figure class="kk kl km kn gu ko"><div class="bz fq l di"><div class="nf ng l"/></div></figure><figure class="kk kl km kn gu ko gi gj paragraph-image"><div role="button" tabindex="0" class="kp kq di kr bf ks"><div class="gi gj nt"><img src="../Images/9625341416a971309a5566a0d879bcd9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*-7GtuWVxCoDKYV2IC_0o6w.gif"/></div></div></figure><p id="e616" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">仅用几行代码，我们就在SwiftUI中为iOS 14构建了一个可定制的网格布局。</p></div><div class="ab cl lw lx hy ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="in io ip iq ir"><h1 id="a9ef" class="md me iu bd mf mg mh mi mj mk ml mm mn ka mo kb mp kd mq ke mr kg ms kh mt mu bi translated">结论</h1><p id="88c1" class="pw-post-body-paragraph la lb iu lc b ld mv jv lf lg mw jy li lj mx ll lm ln my lp lq lr mz lt lu lv in bi translated">今年SwiftUI和其他iOS 14框架更新还有很多值得期待的地方。SwiftUI <code class="fe na nb nc nd b">OutlineGroups</code>和<code class="fe na nb nc nd b">VideoPlayer</code>支持是几个有前途的新特性。最重要的是，SwiftUI视图构建器现在支持<code class="fe na nb nc nd b">if let</code>和<code class="fe na nb nc nd b">switch</code>语句。</p><p id="d5aa" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">这一次到此为止。感谢阅读。</p></div></div>    
</body>
</html>