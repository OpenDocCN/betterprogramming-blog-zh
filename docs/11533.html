<html>
<head>
<title>A Concise Guide for Strings and Regular Expressions in R</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">R语言中字符串和正则表达式的简明指南</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/string-manipulation-and-regular-expressions-in-r-6686c09920fe?source=collection_archive---------15-----------------------#2022-03-28">https://betterprogramming.pub/string-manipulation-and-regular-expressions-in-r-6686c09920fe?source=collection_archive---------15-----------------------#2022-03-28</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="19ac" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">轻松驯服你的琴弦</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/3307ca07bd0873c9106e30bd8d454483.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*sUoBIbSxKEukynEy"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">照片由<a class="ae kv" href="https://unsplash.com/@glencarrie?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">格伦·凯莉</a>在<a class="ae kv" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</p></figure><p id="ddaf" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">如今查找数据很容易。找到高质量的数据比以往任何时候都难。低质量数据的一个长期特征是混乱且保存不准确。不管我们数据专家多么喜欢谈论算法和模型验证，我们大部分时间都花在清理和整理数据上。</p><p id="5347" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">从这个意义上来说，处理字符串需要一套与<code class="fe ls lt lu lv b">data.frame</code>或列表稍微不同的技能。您可能已经猜到了，本文的主题是:如何尽可能轻松地操纵和驯服字符串。我们开始吧！</p></div><div class="ab cl lw lx hu ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="ij ik il im in"><h1 id="0926" class="md me iq bd mf mg mh mi mj mk ml mm mn jw mo jx mp jz mq ka mr kc ms kd mt mu bi translated">粘贴和拆分</h1><p id="5816" class="pw-post-body-paragraph kw kx iq ky b kz mv jr lb lc mw ju le lf mx lh li lj my ll lm ln mz lp lq lr ij bi translated">粘贴和拆分字符串是我们经常面临的两个最常见的任务。</p><p id="9b71" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">对于这两个简单任务，我们有两个同样简单的函数:<code class="fe ls lt lu lv b">paste()</code>和<code class="fe ls lt lu lv b">strsplit()</code>。</p><pre class="kg kh ki kj gt na lv nb nc aw nd bi"><span id="43b2" class="ne me iq lv b gy nf ng l nh ni">paste('Ugurcan' , 'Demir' , sep = " ")</span><span id="d023" class="ne me iq lv b gy nj ng l nh ni">## [1] "Ugurcan Demir"</span><span id="1d8b" class="ne me iq lv b gy nj ng l nh ni">## [[1]]<br/>## [1] "Ugurcan" "Demir"</span><span id="a4e5" class="ne me iq lv b gy nj ng l nh ni">strsplit("Ugurcan Demir" , split = " ")</span><span id="1d3b" class="ne me iq lv b gy nj ng l nh ni">paste("The","United" ,"States" ,"of" ,"America" , sep = " ")</span><span id="f59f" class="ne me iq lv b gy nj ng l nh ni">## [1] "The United States of America"</span><span id="efee" class="ne me iq lv b gy nj ng l nh ni">unlist(strsplit("The United States of America" , split = " "))</span><span id="57e2" class="ne me iq lv b gy nj ng l nh ni">## [1] "The"     "United"  "States"  "of"      "America"</span></pre><h1 id="7ed2" class="md me iq bd mf mg nk mi mj mk nl mm mn jw nm jx mp jz nn ka mr kc no kd mt mu bi translated">字符数和切片</h1><p id="82c4" class="pw-post-body-paragraph kw kx iq ky b kz mv jr lb lc mw ju le lf mx lh li lj my ll lm ln mz lp lq lr ij bi translated">r和Python用户往往会有很多交集。这两种语言都很容易掌握，它们的通用库都面向统计学家、机器学习从业者或任何对科学计算感兴趣的人。但是如果你来自Python，我们将要展示的例子可能会有点奇怪。</p><p id="a90e" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">例如，要找到字符的总数，<code class="fe ls lt lu lv b">length()</code>将是一个直观的选择。但与Python不同的是，这不是r中的工作方式。</p><pre class="kg kh ki kj gt na lv nb nc aw nd bi"><span id="36fe" class="ne me iq lv b gy nf ng l nh ni">length("The United States of America")</span><span id="334e" class="ne me iq lv b gy nj ng l nh ni">## [1] 1</span><span id="837f" class="ne me iq lv b gy nj ng l nh ni">nchar("The United States of America")</span><span id="bb11" class="ne me iq lv b gy nj ng l nh ni">## [1] 28</span></pre><p id="2786" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">切片也不是常规切片。为此我们有两个函数:<code class="fe ls lt lu lv b">substr()</code>和<code class="fe ls lt lu lv b">substring()</code>。如果同时指定start和stop参数，这两个同卵双胞胎的工作方式完全相同。然而，<code class="fe ls lt lu lv b">substring()</code>有一个默认的停止值，而<code class="fe ls lt lu lv b">substr()</code>没有。</p><pre class="kg kh ki kj gt na lv nb nc aw nd bi"><span id="ebe5" class="ne me iq lv b gy nf ng l nh ni">substr("The United States of America" , start = 10 , <strong class="lv ir">stop</strong> = 20)</span><span id="dae5" class="ne me iq lv b gy nj ng l nh ni">## [1] "d States of"</span><span id="e5fc" class="ne me iq lv b gy nj ng l nh ni">substring("The United States of America" , first = 10 , last = 20)</span><span id="d2fe" class="ne me iq lv b gy nj ng l nh ni">## [1] "d States of"</span></pre><p id="a78f" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">下面是当我们没有将参数传递给“stop”或“last”参数时会发生的情况。</p><pre class="kg kh ki kj gt na lv nb nc aw nd bi"><span id="3f73" class="ne me iq lv b gy nf ng l nh ni">substring("The United States of America" , first = 10 )</span><span id="6ebb" class="ne me iq lv b gy nj ng l nh ni">## [1] "d States of America"</span><span id="0de6" class="ne me iq lv b gy nj ng l nh ni">substr("The United States of America" , start = 10 )</span><span id="59db" class="ne me iq lv b gy nj ng l nh ni">## Error in substr("The United States of America", start = 10): argument "stop" is missing, with no default</span></pre><h1 id="abf6" class="md me iq bd mf mg nk mi mj mk nl mm mn jw nm jx mp jz nn ka mr kc no kd mt mu bi translated">regexec()、gregexpr()和grep()</h1><p id="c3db" class="pw-post-body-paragraph kw kx iq ky b kz mv jr lb lc mw ju le lf mx lh li lj my ll lm ln mz lp lq lr ij bi translated">我可以听到你大声说“我们首先应该如何知道作为参数传递的索引”。当你有一段字符串时，用手指数很容易，但是当你有几百万甚至几十行数据时，用手指数是非常不切实际的。幸运的是，我们配备了两个漂亮的功能来做到这一点。</p><p id="4811" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们的第一个函数<code class="fe ls lt lu lv b">regexec()</code>用于在一个更大的字符串中查找第一个出现的子字符串。</p><pre class="kg kh ki kj gt na lv nb nc aw nd bi"><span id="b2f7" class="ne me iq lv b gy nf ng l nh ni">regexec(pattern = 'United' , text =  "The United States of America"  )</span><span id="b2f0" class="ne me iq lv b gy nj ng l nh ni">## [[1]]<br/>## [1] 5<br/>## attr(,"match.length")<br/>## [1] 6<br/>## attr(,"index.type")<br/>## [1] "chars"<br/>## attr(,"useBytes")<br/>## [1] TRUE</span><span id="4598" class="ne me iq lv b gy nj ng l nh ni">regexec(pattern = 'U' , text =  "The United States of America"  )</span><span id="eaba" class="ne me iq lv b gy nj ng l nh ni">## [[1]]<br/>## [1] 5<br/>## attr(,"match.length")<br/>## [1] 1<br/>## attr(,"index.type")<br/>## [1] "chars"<br/>## attr(,"useBytes")<br/>## [1] TRUE</span></pre><p id="5984" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">另一方面，<code class="fe ls lt lu lv b">gregexpr()</code>在一个更大的字符串中查找一个子字符串的所有匹配项。</p><pre class="kg kh ki kj gt na lv nb nc aw nd bi"><span id="3130" class="ne me iq lv b gy nf ng l nh ni">gregexpr(pattern = 'e' , text =  "The United States of America"  )</span><span id="a75a" class="ne me iq lv b gy nj ng l nh ni">## [[1]]<br/>## [1]  3  9 16 24<br/>## attr(,"match.length")<br/>## [1] 1 1 1 1<br/>## attr(,"index.type")<br/>## [1] "chars"<br/>## attr(,"useBytes")<br/>## [1] TRUE</span></pre><p id="26c9" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">函数接受第二个参数，不仅仅是一个字符串，而是一个字符串向量，并返回包含子字符串的元素的索引。如果将value参数设置为TRUE，它将返回元素本身。</p><pre class="kg kh ki kj gt na lv nb nc aw nd bi"><span id="0dc0" class="ne me iq lv b gy nf ng l nh ni">grep(pattern = 'wigh' , x = c('Michael' , "Jim" , "Dwight" , "Pam") )</span><span id="8f65" class="ne me iq lv b gy nj ng l nh ni">## [1] 3</span><span id="dff6" class="ne me iq lv b gy nj ng l nh ni">grep(pattern = 'm' , x = c('Michael' , "Jim" , "Dwight" , "Pam") )</span><span id="e7a9" class="ne me iq lv b gy nj ng l nh ni">## [1] 2 4</span><span id="6ea4" class="ne me iq lv b gy nj ng l nh ni">grep(pattern = 'm' , x = c('Michael' , "Jim" , "Dwight" , "Pam") , value = T)</span><span id="e665" class="ne me iq lv b gy nj ng l nh ni">## [1] "Jim" "Pam"</span></pre><h1 id="4455" class="md me iq bd mf mg nk mi mj mk nl mm mn jw nm jx mp jz nn ka mr kc no kd mt mu bi translated">sub()和gsub()</h1><p id="c832" class="pw-post-body-paragraph kw kx iq ky b kz mv jr lb lc mw ju le lf mx lh li lj my ll lm ln mz lp lq lr ij bi translated"><code class="fe ls lt lu lv b">sub()</code>和<code class="fe ls lt lu lv b">gsub()</code>将它带到下一个层次，用作为参数传递的另一个字符串替换一个更大的字符串中与给定子串匹配的部分。</p><pre class="kg kh ki kj gt na lv nb nc aw nd bi"><span id="8fbe" class="ne me iq lv b gy nf ng l nh ni">sub(pattern = 'm' , replacement = "n" , x = c('Michael',"Jim","Dwight","Pam"))</span><span id="d5ff" class="ne me iq lv b gy nj ng l nh ni">## [1] "Michael" "Jin"     "Dwight"  "Pan"</span><span id="5ffc" class="ne me iq lv b gy nj ng l nh ni">sub(pattern = "i" , replacement = "a" , x = "The United States of America")</span><span id="c1eb" class="ne me iq lv b gy nj ng l nh ni">## [1] "The Unated States of America"</span></pre><p id="7ddd" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">如果你注意到“美国”这个词保持不变。这是因为sub()只替换第一次出现的子字符串。为了替换它们，我们应用<code class="fe ls lt lu lv b">gsub()</code>。</p><pre class="kg kh ki kj gt na lv nb nc aw nd bi"><span id="6456" class="ne me iq lv b gy nf ng l nh ni">gsub(pattern = "i" , replacement = "a" , x = "The United States of America")</span><span id="12bc" class="ne me iq lv b gy nj ng l nh ni">## [1] "The Unated States of Ameraca"</span></pre><h1 id="6c73" class="md me iq bd mf mg nk mi mj mk nl mm mn jw nm jx mp jz nn ka mr kc no kd mt mu bi translated">正则表达式(REGEX)</h1><p id="abe6" class="pw-post-body-paragraph kw kx iq ky b kz mv jr lb lc mw ju le lf mx lh li lj my ll lm ln mz lp lq lr ij bi translated">到目前为止，我们一直在其他字符串中搜索简单的子字符串。要搜索的子字符串可能不像我们到目前为止在这些例子中展示的那样简单。我们甚至可能不知道我们需要找到什么特定的子串，而是需要找到任何符合我们给出的蓝图的东西。在这些情况下，我们利用正则表达式:或简称REGEX。</p><p id="256d" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">正则表达式可以在许多编程语言中找到，只是实现略有不同。他们的主要工作是在给定的大字符串中搜索字符串的模式。</p><p id="2f71" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">正则表达式没有给出要查找的确切子串，而是查找与给定子串相似的模式。他们有自己的小语种来做这项工作。我们将详细解释管理正则表达式的所有元字符和规则。</p><h1 id="8426" class="md me iq bd mf mg nk mi mj mk nl mm mn jw nm jx mp jz nn ka mr kc no kd mt mu bi translated">元字符</h1><p id="d95a" class="pw-post-body-paragraph kw kx iq ky b kz mv jr lb lc mw ju le lf mx lh li lj my ll lm ln mz lp lq lr ij bi translated">首先，我们应该声明正则表达式的迷你语言的符号被称为<code class="fe ls lt lu lv b">metacharacters</code>，它们是正则表达式的主干。</p><ul class=""><li id="38c1" class="np nq iq ky b kz la lc ld lf nr lj ns ln nt lr nu nv nw nx bi">“$”</li><li id="1105" class="np nq iq ky b kz ny lc nz lf oa lj ob ln oc lr nu nv nw nx bi">“*”</li><li id="a347" class="np nq iq ky b kz ny lc nz lf oa lj ob ln oc lr nu nv nw nx bi">“+”</li><li id="7b8e" class="np nq iq ky b kz ny lc nz lf oa lj ob ln oc lr nu nv nw nx bi">“.”</li><li id="60bd" class="np nq iq ky b kz ny lc nz lf oa lj ob ln oc lr nu nv nw nx bi">“?”</li><li id="92bc" class="np nq iq ky b kz ny lc nz lf oa lj ob ln oc lr nu nv nw nx bi">“[ ]”</li><li id="539a" class="np nq iq ky b kz ny lc nz lf oa lj ob ln oc lr nu nv nw nx bi">“^”</li><li id="79f4" class="np nq iq ky b kz ny lc nz lf oa lj ob ln oc lr nu nv nw nx bi">“{ }”</li><li id="2e16" class="np nq iq ky b kz ny lc nz lf oa lj ob ln oc lr nu nv nw nx bi">“|”</li><li id="bfcd" class="np nq iq ky b kz ny lc nz lf oa lj ob ln oc lr nu nv nw nx bi">“( )”</li><li id="8b89" class="np nq iq ky b kz ny lc nz lf oa lj ob ln oc lr nu nv nw nx bi">“\ ”</li></ul><p id="4e8b" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">现在我们将解释这些<code class="fe ls lt lu lv b">metacharacters</code>的作用。</p><h1 id="2c5b" class="md me iq bd mf mg nk mi mj mk nl mm mn jw nm jx mp jz nn ka mr kc no kd mt mu bi translated">量词</h1><p id="c766" class="pw-post-body-paragraph kw kx iq ky b kz mv jr lb lc mw ju le lf mx lh li lj my ll lm ln mz lp lq lr ij bi translated">"?"、“*”、“+”和“{ }”在<code class="fe ls lt lu lv b">metacharacters</code>中被称为量词，因为它们表示我们希望看到给定模式多少次。</p><ul class=""><li id="1dd2" class="np nq iq ky b kz la lc ld lf nr lj ns ln nt lr nu nv nw nx bi translated">" * ":如果前面的项目出现0次或更多次，则匹配</li><li id="e50f" class="np nq iq ky b kz ny lc nz lf oa lj ob ln oc lr nu nv nw nx bi translated">"+":如果前面的项目出现1次或多次，则匹配</li><li id="d68d" class="np nq iq ky b kz ny lc nz lf oa lj ob ln oc lr nu nv nw nx bi translated">"?":匹配之前的项目出现0次或1次</li><li id="5469" class="np nq iq ky b kz ny lc nz lf oa lj ob ln oc lr nu nv nw nx bi translated">" {，m} ":如果前面的项目出现m次或更少，则匹配</li><li id="bad0" class="np nq iq ky b kz ny lc nz lf oa lj ob ln oc lr nu nv nw nx bi translated">“{n，}”:如果前面的项目出现n次或更多次，则匹配</li><li id="a40e" class="np nq iq ky b kz ny lc nz lf oa lj ob ln oc lr nu nv nw nx bi translated">“{n，m}”:如果前面的项目出现n到m次，则匹配</li><li id="8d2a" class="np nq iq ky b kz ny lc nz lf oa lj ob ln oc lr nu nv nw nx bi translated">“{m}”:如果前面的项目正好出现m次，则匹配</li></ul><pre class="kg kh ki kj gt na lv nb nc aw nd bi"><span id="eae6" class="ne me iq lv b gy nf ng l nh ni">letter_vector &lt;- c(<br/>  "AACACA","BBCCBC","CCABBB","ABABAA","ACBCAA","BCACBC",<br/>  "BABABA","CACABA","BBABAB","BCCBAB","CAABCC","BCCBCA",<br/>  "CAAABA","BAABCB","CCABBC","ABABBA","CABAAC","CAABCC",<br/>  "CABCAC","AABCAA","CAAACB","BBACCA","BCAAAB","BBACBC",<br/>  "CCCCBC","ACABCA","BCBBBC","AABBCC","CCBBBB","BBABBA","BBCAAC"<br/>)</span><span id="2b12" class="ne me iq lv b gy nj ng l nh ni">grep(pattern = "ABC" , x =  letter_vector , value = T)</span><span id="5633" class="ne me iq lv b gy nj ng l nh ni">## [1] "CAABCC" "BAABCB" "CAABCC" "CABCAC" "AABCAA" "ACABCA"</span><span id="ea1b" class="ne me iq lv b gy nj ng l nh ni">grep(pattern = "AB*C" , x =  letter_vector , value = T)</span><span id="44c7" class="ne me iq lv b gy nj ng l nh ni">##  [1] "AACACA" "ACBCAA" "BCACBC" "CACABA" "CAABCC" "BAABCB" "CCABBC" "CABAAC"<br/>##  [9] "CAABCC" "CABCAC" "AABCAA" "CAAACB" "BBACCA" "BBACBC" "ACABCA" "AABBCC"<br/>## [17] "BBCAAC"</span><span id="e6bd" class="ne me iq lv b gy nj ng l nh ni">grep(pattern = "AB+C" , x =  letter_vector , value = T)</span><span id="8df4" class="ne me iq lv b gy nj ng l nh ni">## [1] "CAABCC" "BAABCB" "CCABBC" "CAABCC" "CABCAC" "AABCAA" "ACABCA" "AABBCC"</span><span id="aa4e" class="ne me iq lv b gy nj ng l nh ni">grep(pattern = "AB?C" , x =  letter_vector , value = T)</span><span id="3490" class="ne me iq lv b gy nj ng l nh ni">##  [1] "AACACA" "ACBCAA" "BCACBC" "CACABA" "CAABCC" "BAABCB" "CABAAC" "CAABCC"<br/>##  [9] "CABCAC" "AABCAA" "CAAACB" "BBACCA" "BBACBC" "ACABCA" "BBCAAC"</span><span id="5855" class="ne me iq lv b gy nj ng l nh ni">grep(pattern = "AB{,2}C" , x =  letter_vector , value = T)</span><span id="d9b5" class="ne me iq lv b gy nj ng l nh ni">##  [1] "AACACA" "ACBCAA" "BCACBC" "CACABA" "CAABCC" "BAABCB" "CCABBC" "CABAAC"<br/>##  [9] "CAABCC" "CABCAC" "AABCAA" "CAAACB" "BBACCA" "BBACBC" "ACABCA" "AABBCC"<br/>## [17] "BBCAAC"</span><span id="ffd7" class="ne me iq lv b gy nj ng l nh ni">grep(pattern = "AB{2,}C" , x =  letter_vector , value = T)</span><span id="4b55" class="ne me iq lv b gy nj ng l nh ni">## [1] "CCABBC" "AABBCC"</span><span id="75a5" class="ne me iq lv b gy nj ng l nh ni">grep(pattern = "AB{1,2}C" , x =  letter_vector , value = T)</span><span id="7a3c" class="ne me iq lv b gy nj ng l nh ni">## [1] "CAABCC" "BAABCB" "CCABBC" "CAABCC" "CABCAC" "AABCAA" "ACABCA" "AABBCC"</span><span id="c73c" class="ne me iq lv b gy nj ng l nh ni">grep(pattern = "AB{2}C" , x =  letter_vector , value = T)</span><span id="a79d" class="ne me iq lv b gy nj ng l nh ni">## [1] "CCABBC" "AABBCC"</span></pre><h1 id="9664" class="md me iq bd mf mg nk mi mj mk nl mm mn jw nm jx mp jz nn ka mr kc no kd mt mu bi translated">开始和结束元字符</h1><p id="76a0" class="pw-post-body-paragraph kw kx iq ky b kz mv jr lb lc mw ju le lf mx lh li lj my ll lm ln mz lp lq lr ij bi translated">“^”和“$”分别代表字符串的开头和结尾。他们在其他资源中也被称为锚。锚点不匹配任何字符。</p><pre class="kg kh ki kj gt na lv nb nc aw nd bi"><span id="efa9" class="ne me iq lv b gy nf ng l nh ni">grep(pattern = "^A" , x =  letter_vector , value = T)</span><span id="d0de" class="ne me iq lv b gy nj ng l nh ni">## [1] "AACACA" "ABABAA" "ACBCAA" "ABABBA" "AABCAA" "ACABCA" "AABBCC"</span><span id="8144" class="ne me iq lv b gy nj ng l nh ni">grep(pattern = "C$" , x =  letter_vector , value = T)</span><span id="c2b8" class="ne me iq lv b gy nj ng l nh ni">##  [1] "BBCCBC" "BCACBC" "CAABCC" "CCABBC" "CABAAC" "CAABCC" "CABCAC" "BBACBC"<br/>##  [9] "CCCCBC" "BCBBBC" "AABBCC" "BBCAAC"</span></pre><h1 id="e17f" class="md me iq bd mf mg nk mi mj mk nl mm mn jw nm jx mp jz nn ka mr kc no kd mt mu bi translated">占位符</h1><p id="bed8" class="pw-post-body-paragraph kw kx iq ky b kz mv jr lb lc mw ju le lf mx lh li lj my ll lm ln mz lp lq lr ij bi translated">"."是我们的下一个元字符，它匹配任何使用它的字符。以下示例搜索以“C”开头、以“A”结尾以及除两个字符之外的任何字符的任何模式。</p><pre class="kg kh ki kj gt na lv nb nc aw nd bi"><span id="a911" class="ne me iq lv b gy nf ng l nh ni">grep(pattern = "C..A" , x =  letter_vector , value = T)</span><span id="888d" class="ne me iq lv b gy nj ng l nh ni">## [1] "AACACA" "ACBCAA" "CACABA" "BCCBAB" "BCCBCA" "CAAABA" "CABAAC" "CAAACB"<br/>## [9] "BCAAAB"</span></pre><h1 id="90c7" class="md me iq bd mf mg nk mi mj mk nl mm mn jw nm jx mp jz nn ka mr kc no kd mt mu bi translated">顺序</h1><p id="c62e" class="pw-post-body-paragraph kw kx iq ky b kz mv jr lb lc mw ju le lf mx lh li lj my ll lm ln mz lp lq lr ij bi translated">元字符“\”，当它与一组序列关键字字母一起使用时，用于定义字符串中的某个字符序列，并且当它与我们的字符串函数一起使用时，它匹配那些字符序列。下面是经常与“\”一起使用的关键字母的详细列表。</p><ul class=""><li id="ba79" class="np nq iq ky b kz la lc ld lf nr lj ns ln nt lr nu nv nw nx bi translated">" \d" =数字</li><li id="3c6f" class="np nq iq ky b kz ny lc nz lf oa lj ob ln oc lr nu nv nw nx bi translated">" \D" =不是数字</li><li id="77dd" class="np nq iq ky b kz ny lc nz lf oa lj ob ln oc lr nu nv nw nx bi translated">" \w" =单词字符(a-z，A-Z，0？？？9)</li><li id="901b" class="np nq iq ky b kz ny lc nz lf oa lj ob ln oc lr nu nv nw nx bi translated">" \W" =不是单词字符</li><li id="8d1e" class="np nq iq ky b kz ny lc nz lf oa lj ob ln oc lr nu nv nw nx bi translated">" \s" =空白</li><li id="7618" class="np nq iq ky b kz ny lc nz lf oa lj ob ln oc lr nu nv nw nx bi translated">" \S" =不是空白</li><li id="bfd5" class="np nq iq ky b kz ny lc nz lf oa lj ob ln oc lr nu nv nw nx bi translated">" \b" =单词边界</li><li id="10c7" class="np nq iq ky b kz ny lc nz lf oa lj ob ln oc lr nu nv nw nx bi translated">" \B" =不是单词边界</li></ul><p id="8cbf" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">让我们看一些例子。</p><pre class="kg kh ki kj gt na lv nb nc aw nd bi"><span id="627c" class="ne me iq lv b gy nf ng l nh ni">string1 &lt;- 'My name is Ugurcan and I am 25.'</span><span id="bf9d" class="ne me iq lv b gy nj ng l nh ni">gsub(pattern = "\\d" , replacement = "-" , x = string1)</span><span id="0136" class="ne me iq lv b gy nj ng l nh ni">## [1] "My name is Ugurcan and I am --."</span><span id="6595" class="ne me iq lv b gy nj ng l nh ni">gsub(pattern = "\\s" , replacement = "-" , x = string1)</span><span id="f8ca" class="ne me iq lv b gy nj ng l nh ni">## [1] "My-name-is-Ugurcan-and-I-am-25."</span><span id="f52a" class="ne me iq lv b gy nj ng l nh ni">gsub(pattern = "\\w" , replacement = "-" , x = string1)</span><span id="c431" class="ne me iq lv b gy nj ng l nh ni">## [1] "-- ---- -- ------- --- - -- --."</span><span id="86cc" class="ne me iq lv b gy nj ng l nh ni">gsub(pattern = "\\b" , replacement = "-" , x = string1)</span><span id="0e5f" class="ne me iq lv b gy nj ng l nh ni">## [1] "-M-y- -n-a-m-e- -i-s- -U-g-u-r-c-a-n- -a-n-d- -I- -a-m- -2-5-.-"</span></pre><h1 id="cf58" class="md me iq bd mf mg nk mi mj mk nl mm mn jw nm jx mp jz nn ka mr kc no kd mt mu bi translated">字符类别</h1><p id="7c11" class="pw-post-body-paragraph kw kx iq ky b kz mv jr lb lc mw ju le lf mx lh li lj my ll lm ln mz lp lq lr ij bi translated">“[ ]”是另一个元字符，它经常用于形成复杂的模式来分析复杂和非结构化的文本数据。我们可以在方括号内传递几个字符，但是它只匹配这些字符，并且只匹配一个字符。顺序无关紧要，我们可以使用连字符来搜索一系列字符或数字。</p><pre class="kg kh ki kj gt na lv nb nc aw nd bi"><span id="7e77" class="ne me iq lv b gy nf ng l nh ni">grep(pattern = "[zp]" , x = state.name , value = T)</span><span id="bff2" class="ne me iq lv b gy nj ng l nh ni">## [1] "Arizona"       "Mississippi"   "New Hampshire"</span><span id="cadc" class="ne me iq lv b gy nj ng l nh ni">grep(pattern = "[b-d]" , x = state.name , value = T)</span><span id="5fc1" class="ne me iq lv b gy nj ng l nh ni">##  [1] "Alabama"       "Colorado"      "Connecticut"   "Florida"      <br/>##  [5] "Idaho"         "Indiana"       "Kentucky"      "Maryland"     <br/>##  [9] "Massachusetts" "Michigan"      "Nebraska"      "Nevada"       <br/>## [13] "New Mexico"    "Rhode Island"  "Wisconsin"</span><span id="43d1" class="ne me iq lv b gy nj ng l nh ni">grep(pattern = "[od]$" , x = state.name , value = T)</span><span id="7d02" class="ne me iq lv b gy nj ng l nh ni">## [1] "Colorado"     "Idaho"        "Maryland"     "New Mexico"   "Ohio"        <br/>## [6] "Rhode Island"</span></pre><p id="91e3" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">对于某些特定类型的场合，你也可以用方括号将类名内建起来。下面我们给出了这些类名的完整列表。</p><ul class=""><li id="5510" class="np nq iq ky b kz la lc ld lf nr lj ns ln nt lr nu nv nw nx bi translated"><code class="fe ls lt lu lv b">[:alnum:]</code> =字母数字字符:[:字母:]和[:数字:]</li><li id="2b7d" class="np nq iq ky b kz ny lc nz lf oa lj ob ln oc lr nu nv nw nx bi translated"><code class="fe ls lt lu lv b">[:alpha:]</code> =字母字符:[:下:]和[:上:]</li><li id="01f1" class="np nq iq ky b kz ny lc nz lf oa lj ob ln oc lr nu nv nw nx bi translated"><code class="fe ls lt lu lv b">[:blank:]</code> =空白字符:空格和制表符，可能还有其他与区域设置相关的字符，如不间断空格</li><li id="4ee1" class="np nq iq ky b kz ny lc nz lf oa lj ob ln oc lr nu nv nw nx bi translated"><code class="fe ls lt lu lv b">[:cntrl:]</code>= ASCII中的控制字符，这些字符有八进制代码000到037，在另一个字符集中有177 (DEL)，这些是等效字符(如果有的话)</li><li id="6976" class="np nq iq ky b kz ny lc nz lf oa lj ob ln oc lr nu nv nw nx bi translated"><code class="fe ls lt lu lv b">[:digit:]</code> =位数:0 1 2 3 4 5 6 7 8 9</li><li id="c37b" class="np nq iq ky b kz ny lc nz lf oa lj ob ln oc lr nu nv nw nx bi translated"><code class="fe ls lt lu lv b">[:graph:]</code> =图形字符:[:alnum:]和[:punct:]</li><li id="58d4" class="np nq iq ky b kz ny lc nz lf oa lj ob ln oc lr nu nv nw nx bi translated"><code class="fe ls lt lu lv b">[:lower:]</code> =当前语言环境中的小写字母</li><li id="7857" class="np nq iq ky b kz ny lc nz lf oa lj ob ln oc lr nu nv nw nx bi translated"><code class="fe ls lt lu lv b">[:print:]</code> =可打印字符:[:alnum:]，[:punct:]和空格</li><li id="7eae" class="np nq iq ky b kz ny lc nz lf oa lj ob ln oc lr nu nv nw nx bi translated"><code class="fe ls lt lu lv b">[:punct:]</code> =标点符号:！" # $ % &amp; ' ( ) * +，—/:；&lt; = &gt;？@ [ ] ^ _ ` { | } ~."</li><li id="57d1" class="np nq iq ky b kz ny lc nz lf oa lj ob ln oc lr nu nv nw nx bi translated"><code class="fe ls lt lu lv b">[:space:]</code> =空格字符:制表符、换行符、垂直制表符、换页符、回车符、空格和其他可能的语言环境相关字符</li><li id="33a9" class="np nq iq ky b kz ny lc nz lf oa lj ob ln oc lr nu nv nw nx bi translated"><code class="fe ls lt lu lv b">[:upper:]</code> =当前语言环境中的大写字母</li><li id="610a" class="np nq iq ky b kz ny lc nz lf oa lj ob ln oc lr nu nv nw nx bi translated"><code class="fe ls lt lu lv b">[:xdigit:]</code> =十六进制数字:0 1 2 3 4 5 6 7 8 9 A B C D E F a b c d e f</li></ul><h1 id="642c" class="md me iq bd mf mg nk mi mj mk nl mm mn jw nm jx mp jz nn ka mr kc no kd mt mu bi translated">分组与或运算符</h1><p id="0044" class="pw-post-body-paragraph kw kx iq ky b kz mv jr lb lc mw ju le lf mx lh li lj my ll lm ln mz lp lq lr ij bi translated">我们的最后两个元字符是“()”和“|”，它们通常一起使用。分组元字符“()”分隔不同的模式集，or运算符的工作方式类似于常规OR运算符。让我们用例子来说明它们。</p><pre class="kg kh ki kj gt na lv nb nc aw nd bi"><span id="8af3" class="ne me iq lv b gy nf ng l nh ni">grep(pattern = "(th|la)" , x = state.name , value = T)</span><span id="01d4" class="ne me iq lv b gy nj ng l nh ni">##  [1] "Alabama"        "Alaska"         "Delaware"       "Maryland"      <br/>##  [5] "North Carolina" "North Dakota"   "Oklahoma"       "Rhode Island"  <br/>##  [9] "South Carolina" "South Dakota"</span><span id="06a8" class="ne me iq lv b gy nj ng l nh ni">grep(pattern = "^New (Y|J)" , x = state.name , value = T)</span><span id="2772" class="ne me iq lv b gy nj ng l nh ni">## [1] "New Jersey" "New York"</span></pre><h1 id="f09e" class="md me iq bd mf mg nk mi mj mk nl mm mn jw nm jx mp jz nn ka mr kc no kd mt mu bi translated">转义元字符</h1><p id="fdda" class="pw-post-body-paragraph kw kx iq ky b kz mv jr lb lc mw ju le lf mx lh li lj my ll lm ln mz lp lq lr ij bi translated">我们已经看到了所有的元字符，但是如果我们的搜索模式包括这些元字符中的一个呢？</p><p id="7250" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这是一个非常欢迎你问的问题。在这种情况下，我们需要告诉R，我们不使用这些字符作为元字符，而是作为常规字符。</p><p id="0b66" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">为了做到这一点，我们在元字符前面添加了一个反斜杠，这样我们就可以对它进行转义。因为反斜杠也是元字符，所以我们也添加了另一个反斜杠来转义它。这里有一些例子。</p><pre class="kg kh ki kj gt na lv nb nc aw nd bi"><span id="9199" class="ne me iq lv b gy nf ng l nh ni">string2 &lt;- c("Lionel Messi\ PSG" , 'file_name$' , "{2022}")</span><span id="a1d4" class="ne me iq lv b gy nj ng l nh ni">grep(pattern = "\\$" , x = string2  , value = T)</span><span id="b9f4" class="ne me iq lv b gy nj ng l nh ni">## [1] "file_name$"</span><span id="9ccf" class="ne me iq lv b gy nj ng l nh ni">grep(pattern = "\\{" , x = string2  , value = T)</span><span id="d915" class="ne me iq lv b gy nj ng l nh ni">## [1] "{2022}"</span></pre><p id="5c3d" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在本文中，我们首先讨论了字符串使用的所有函数。然后我们讨论了11个元字符，用它们我们可以创建复杂的模式。希望这篇文章能成为大家的参考指南。</p></div></div>    
</body>
</html>