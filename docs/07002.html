<html>
<head>
<title>How to Write Tests for Components With OnPush Change Detection in Angular</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何在Angular中为带有OnPush变化检测的组件编写测试</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/how-to-write-tests-for-components-with-onpush-change-detection-in-angular-24f2637a0f40?source=collection_archive---------3-----------------------#2020-11-25">https://betterprogramming.pub/how-to-write-tests-for-components-with-onpush-change-detection-in-angular-24f2637a0f40?source=collection_archive---------3-----------------------#2020-11-25</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="0a5b" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">让Angular意识到组件测试中的变化</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/0d237876bd613d3d71f2cf77784fd71a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*zfwkUVEq4qbpeydg"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">罗斯·芬登在<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片。</p></figure><p id="1ce8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">Angular框架做了大量工作来检测变化并相应地更新UI。与React或Vue.js等其他框架类似，Angular支持数据绑定，总是显示最新的数据。</p><p id="46c9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">虽然Angular已经是一个快速的框架，但我们总是可以改进的。一个改进的想法是减少变更检测的工作量，以保持UI尽可能的平滑。对于角度分量，有两种<a class="ae ky" href="https://angular.io/api/core/ChangeDetectionStrategy" rel="noopener ugc nofollow" target="_blank">变化检测策略</a>可用:</p><ul class=""><li id="8ff5" class="lv lw it lb b lc ld lf lg li lx lm ly lq lz lu ma mb mc md bi translated"><code class="fe me mf mg mh b">Default</code>使用默认的<code class="fe me mf mg mh b">CheckAlways</code>策略，在该策略中，变化检测是自动的，直到被明确取消激活。如果你没有指定一个策略，那么这个将被使用。</li><li id="01eb" class="lv lw it lb b lc mi lf mj li mk lm ml lq mm lu ma mb mc md bi translated"><code class="fe me mf mg mh b">OnPush</code>使用<code class="fe me mf mg mh b">CheckOnce</code>策略，这意味着自动变化检测被禁用，直到通过将策略设置为<code class="fe me mf mg mh b">Default</code>重新激活。仍然可以通过使用<code class="fe me mf mg mh b"><a class="ae ky" href="https://angular.io/api/core/ChangeDetectorRef" rel="noopener ugc nofollow" target="_blank">ChangeDetectorRef</a></code>显式调用变更检测。</li></ul><p id="5a1a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe me mf mg mh b">OnPush</code>变更检测策略是<a class="ae ky" href="https://www.digitalocean.com/community/tutorials/react-smart-dumb-components" rel="noopener ugc nofollow" target="_blank">哑组件</a>的好选择，哑组件通常:</p><ul class=""><li id="510c" class="lv lw it lb b lc ld lf lg li lx lm ly lq lz lu ma mb mc md bi translated">很少或没有内部状态。</li><li id="0ae7" class="lv lw it lb b lc mi lf mj li mk lm ml lq mm lu ma mb mc md bi translated">声明<code class="fe me mf mg mh b"><a class="ae ky" href="https://angular.io/api/core/Input" rel="noopener ugc nofollow" target="_blank">Input</a></code>属性以允许它们的父元素提供数据。</li><li id="6fe2" class="lv lw it lb b lc mi lf mj li mk lm ml lq mm lu ma mb mc md bi translated">借助<code class="fe me mf mg mh b"><a class="ae ky" href="https://angular.io/api/core/Output" rel="noopener ugc nofollow" target="_blank">Output</a></code>属性与其父元素通信。</li></ul><p id="5634" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">可悲的是，使用<code class="fe me mf mg mh b">OnPush</code>变更检测策略的组件在单元测试中更难测试。问题是这样一个组件在第一次调用<code class="fe me mf mg mh b"><a class="ae ky" href="https://angular.io/api/core/testing/ComponentFixture#detectchanges" rel="noopener ugc nofollow" target="_blank">fixture.detectChanges()</a></code>的时候只会运行一次变更检测。GitHub上有一些流行的问题(<a class="ae ky" href="https://github.com/angular/angular/issues/12313" rel="noopener ugc nofollow" target="_blank">例子</a>)凸显了这个问题的严重性。让我们来看看解决这个问题的一些思路:</p><ul class=""><li id="400b" class="lv lw it lb b lc ld lf lg li lx lm ly lq lz lu ma mb mc md bi translated">您可以尝试以这样一种方式编写您的测试代码，即您只需要触发一次变更检测。然而，这可能很麻烦，并且一些测试需要多次变更检测运行。</li><li id="4411" class="lv lw it lb b lc mi lf mj li mk lm ml lq mm lu ma mb mc md bi translated">您可以将您的组件包装在另一个组件中。只要包装器组件提供的组件的<code class="fe me mf mg mh b">Input</code>属性被更改，Angular就会发现这些更改。对于这种方法，您需要创建一个包装器组件，这样就不必处理变更检测问题。</li></ul><p id="5513" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这些方法是可行的，但是在我看来，它们需要付出更多的努力。开源项目的一个优势是，即使没有官方支持的方法，社区通常会找到一种方法。现在，我想和你们分享社区解决这个问题的方法。</p></div><div class="ab cl mn mo hx mp" role="separator"><span class="mq bw bk mr ms mt"/><span class="mq bw bk mr ms mt"/><span class="mq bw bk mr ms"/></div><div class="im in io ip iq"><h1 id="2fc9" class="mu mv it bd mw mx my mz na nb nc nd ne jz nf ka ng kc nh kd ni kf nj kg nk nl bi translated">如何在测试中触发OnPush组件的变更检测</h1><p id="dfd3" class="pw-post-body-paragraph kz la it lb b lc nm ju le lf nn jx lh li no lk ll lm np lo lp lq nq ls lt lu im bi translated">不满足于必须处理这个问题，我尝试了多种方法来触发测试中这类组件的变更检测。在寻找解决方案时，我偶然发现了一个巧妙的功能，我想与您分享一下:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nr ns l"/></div></figure><p id="7be0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">每当您需要使用<code class="fe me mf mg mh b">OnPush</code>变更检测策略对一个组件运行变更检测时，您可以调用这个函数(确保使用<code class="fe me mf mg mh b">await</code>，因为它会返回一个<code class="fe me mf mg mh b">Promise</code>)，您的变更应该会生效。您需要提供的唯一参数是一个<code class="fe me mf mg mh b">ComponentFixture</code>，它通常是在使用<code class="fe me mf mg mh b"><a class="ae ky" href="https://angular.io/api/core/testing/TestBed" rel="noopener ugc nofollow" target="_blank">TestBed</a></code>创建组件时得到的。</p></div><div class="ab cl mn mo hx mp" role="separator"><span class="mq bw bk mr ms mt"/><span class="mq bw bk mr ms mt"/><span class="mq bw bk mr ms"/></div><div class="im in io ip iq"><h1 id="837f" class="mu mv it bd mw mx my mz na nb nc nd ne jz nf ka ng kc nh kd ni kf nj kg nk nl bi translated">结论</h1><p id="ae8d" class="pw-post-body-paragraph kz la it lb b lc nm ju le lf nn jx lh li no lk ll lm np lo lp lq nq ls lt lu im bi translated">感谢阅读这篇文章。使用<code class="fe me mf mg mh b">OnPush</code>变化检测策略是通过减少角度应用中变化检测的数量来提高性能的好方法。通过使用上面概述的一个简单的助手函数，我们可以很容易地在组件测试中随时触发变更检测——甚至对于<code class="fe me mf mg mh b">OnPush</code>组件。我希望Angular团队将来能让<code class="fe me mf mg mh b">OnPush</code>组件的变更检测变得更容易，而不必求助于这种变通方法。</p><p id="73e1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">你知道其他可靠地检测<code class="fe me mf mg mh b">OnPush</code>组件的单元测试变化的方法吗？请在评论中告诉我。</p></div></div>    
</body>
</html>