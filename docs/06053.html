<html>
<head>
<title>5 Ways to Use Typealias in Swift</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">在Swift中使用Typealias的5种方式</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/5-ways-to-use-type-alias-in-swift-45ddce3cc941?source=collection_archive---------1-----------------------#2020-08-29">https://betterprogramming.pub/5-ways-to-use-type-alias-in-swift-45ddce3cc941?source=collection_archive---------1-----------------------#2020-08-29</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><h2 id="2bad" class="ir is it bd b dl iu iv iw ix iy iz dk ja translated" aria-label="kicker paragraph">如何在Swift中使用类型别名</h2><div class=""/><div class=""><h2 id="0fb5" class="pw-subtitle-paragraph jz jc it bd b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq dk translated">使用typealias增加代码的可读性</h2></div><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi kr"><img src="../Images/0f8bdcb1a562e9749e1bd7f99725f358.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*PBRCPwL50MUBmOl9"/></div></div><p class="ld le gj gh gi lf lg bd b be z dk translated">Andy Makely 在<a class="ae lh" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</p></figure><p id="e94d" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">编写代码是可读性和简洁之间的战斗。冗长的代码增加了可读性，最终有助于更好的理解。啰嗦肯定有助于团队中的新成员。另一方面，更少的冗长意味着你有更精确的代码。为了保持这种平衡，我们可以利用Swift提供的一些语言功能，如typealias。我们可以在各种不同的场景中使用类型别名。</p></div><div class="ab cl me mf hx mg" role="separator"><span class="mh bw bk mi mj mk"/><span class="mh bw bk mi mj mk"/><span class="mh bw bk mi mj"/></div><div class="im in io ip iq"><h1 id="1803" class="ml mm it bd mn mo mp mq mr ms mt mu mv ki mw kj mx kl my km mz ko na kp nb nc bi translated">组合协议的类型别名</h1><p id="abdd" class="pw-post-body-paragraph li lj it lk b ll nd kd ln lo ne kg lq lr nf lt lu lv ng lx ly lz nh mb mc md im bi translated">在Swift中开发时，我们大量使用协议。协议是使我们的代码模块化的好方法。以JSON模型解析为例，我相信每个开发人员都遇到过这个问题。当我们在Swift中制作模型时，我们通常最终会制作符合Codable的模型。让我们来看看这个例子:</p><pre class="ks kt ku kv gt ni nj nk nl aw nm bi"><span id="d4cf" class="nn mm it nj b gy no np l nq nr"><strong class="nj jd">struct</strong> Employee:Codable {</span><span id="6226" class="nn mm it nj b gy ns np l nq nr"><strong class="nj jd">var</strong> name:String</span><span id="2f36" class="nn mm it nj b gy ns np l nq nr"><strong class="nj jd">var</strong> age:String</span><span id="f400" class="nn mm it nj b gy ns np l nq nr">}</span></pre><p id="0bb9" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">从上面可以看出，<code class="fe nt nu nv nj b">Employee</code>模型符合Codable。让我们试着检查一下codable的定义。你会发现它是<code class="fe nt nu nv nj b">typealias</code>，它结合了<code class="fe nt nu nv nj b">Encodable</code>和<code class="fe nt nu nv nj b">Decodable</code>两种协议，看起来像这样:</p><pre class="ks kt ku kv gt ni nj nk nl aw nm bi"><span id="66d0" class="nn mm it nj b gy no np l nq nr"><strong class="nj jd">public</strong> <strong class="nj jd">typealias</strong> Codable = Decodable &amp; Encodable</span></pre><p id="04eb" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">这是Swift语言为自己的协议提供的类型别名。我们可以用同样的方式创建我们的自定义类型别名来组合我们自定义的协议。</p><pre class="ks kt ku kv gt ni nj nk nl aw nm bi"><span id="2e9c" class="nn mm it nj b gy no np l nq nr"><strong class="nj jd">protocol</strong> CafeteriaAccess {</span><span id="8926" class="nn mm it nj b gy ns np l nq nr">}</span><span id="5c66" class="nn mm it nj b gy ns np l nq nr"><strong class="nj jd">protocol</strong> LabAccess {</span><span id="1dd6" class="nn mm it nj b gy ns np l nq nr">}</span><span id="3c08" class="nn mm it nj b gy ns np l nq nr"><strong class="nj jd">typealias</strong> BuildingAccess = CafeteriaAccess &amp; LabAccess</span><span id="4e31" class="nn mm it nj b gy ns np l nq nr"><strong class="nj jd">struct</strong> Employee:BuildingAccess {</span><span id="44fc" class="nn mm it nj b gy ns np l nq nr"><strong class="nj jd">var</strong> name:String</span><span id="e7c3" class="nn mm it nj b gy ns np l nq nr"><strong class="nj jd">var</strong> age:String</span><span id="77c5" class="nn mm it nj b gy ns np l nq nr">}</span></pre></div><div class="ab cl me mf hx mg" role="separator"><span class="mh bw bk mi mj mk"/><span class="mh bw bk mi mj mk"/><span class="mh bw bk mi mj"/></div><div class="im in io ip iq"><h1 id="b897" class="ml mm it bd mn mo mp mq mr ms mt mu mv ki mw kj mx kl my km mz ko na kp nb nc bi translated">类型别名语义基元类型</h1><p id="1dbb" class="pw-post-body-paragraph li lj it lk b ll nd kd ln lo ne kg lq lr nf lt lu lv ng lx ly lz nh mb mc md im bi translated">编写代码时，添加语义非常有用。它可以使代码更加清晰，更容易理解。当以平衡的方式完成时，Typealias可以在处理基元类型时产生巨大的差异。我们在许多方法/函数签名中使用了像<code class="fe nt nu nv nj b">String</code>、<code class="fe nt nu nv nj b">Int</code>和<code class="fe nt nu nv nj b">Double</code>这样的原始类型。基本类型根本不支持参数的使用，我们依赖参数名的方法签名来增加清晰度。如果我们的参数类型也能增加一些值就好了。让我们看一个例子:</p><pre class="ks kt ku kv gt ni nj nk nl aw nm bi"><span id="8670" class="nn mm it nj b gy no np l nq nr"><strong class="nj jd">func</strong> heatProduced() -&gt;Double {</span><span id="4cc7" class="nn mm it nj b gy ns np l nq nr"><strong class="nj jd">return</strong> 0</span><span id="16cb" class="nn mm it nj b gy ns np l nq nr">}</span></pre><p id="a0f6" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">上面的方法<code class="fe nt nu nv nj b">headProduced</code>给出了双精度形式的输出。但是假设我们在这个上下文中为<code class="fe nt nu nv nj b">Double</code>创建了一个类型别名<code class="fe nt nu nv nj b">Jules</code>——它看起来像这样:</p><pre class="ks kt ku kv gt ni nj nk nl aw nm bi"><span id="4c40" class="nn mm it nj b gy no np l nq nr"><strong class="nj jd">typealias</strong> Jules = Double</span><span id="fdc9" class="nn mm it nj b gy ns np l nq nr"><strong class="nj jd">func</strong> heatProduced() -&gt;Jules {</span><span id="ed8a" class="nn mm it nj b gy ns np l nq nr"><strong class="nj jd">return</strong> 0</span><span id="0599" class="nn mm it nj b gy ns np l nq nr">}</span></pre><p id="e992" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">通过这一小小的改变，我们有了更多的上下文来增加清晰度。</p></div><div class="ab cl me mf hx mg" role="separator"><span class="mh bw bk mi mj mk"/><span class="mh bw bk mi mj mk"/><span class="mh bw bk mi mj"/></div><div class="im in io ip iq"><h1 id="849a" class="ml mm it bd mn mo mp mq mr ms mt mu mv ki mw kj mx kl my km mz ko na kp nb nc bi translated">类型别名泛型</h1><p id="1e58" class="pw-post-body-paragraph li lj it lk b ll nd kd ln lo ne kg lq lr nf lt lu lv ng lx ly lz nh mb mc md im bi translated">类型别名也可以与泛型参数一起使用。让我们来看一个例子:</p><pre class="ks kt ku kv gt ni nj nk nl aw nm bi"><span id="014f" class="nn mm it nj b gy no np l nq nr"><strong class="nj jd">typealias</strong> EventList&lt;T&gt; = Array&lt;T&gt;</span><span id="d941" class="nn mm it nj b gy ns np l nq nr"><strong class="nj jd">let</strong> array:EventList = EventList(arrayLiteral: 1,2,3)</span></pre><p id="18ea" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">因此，我们声明了一个名为<code class="fe nt nu nv nj b">EventList</code>的typealias数组，它基本上是一个泛型类型的数组。通过使用typelias作为事件列表，你已经使列表的本质非常清楚。我们可以进一步向别名类型的泛型参数添加约束。例如:</p><pre class="ks kt ku kv gt ni nj nk nl aw nm bi"><span id="7faf" class="nn mm it nj b gy no np l nq nr"><strong class="nj jd">typealias</strong> EventList&lt;T&gt; = Array&lt;T&gt; <strong class="nj jd">where</strong> T:StringProtocol</span></pre><p id="1cf6" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">当我们想要定义一个自定义类型的数组，甚至不需要对它们进行子类化时，这是非常有用的。</p></div><div class="ab cl me mf hx mg" role="separator"><span class="mh bw bk mi mj mk"/><span class="mh bw bk mi mj mk"/><span class="mh bw bk mi mj"/></div><div class="im in io ip iq"><h1 id="76cb" class="ml mm it bd mn mo mp mq mr ms mt mu mv ki mw kj mx kl my km mz ko na kp nb nc bi translated">类型别名关联类型协议</h1><p id="c80e" class="pw-post-body-paragraph li lj it lk b ll nd kd ln lo ne kg lq lr nf lt lu lv ng lx ly lz nh mb mc md im bi translated">协议中的关联类型也受益于类型别名。这方面的全部细节超出了本文的范围。让我们来看一个例子:</p><pre class="ks kt ku kv gt ni nj nk nl aw nm bi"><span id="8356" class="nn mm it nj b gy no np l nq nr"><strong class="nj jd">protocol</strong> Example {</span><span id="267a" class="nn mm it nj b gy ns np l nq nr"><strong class="nj jd">associatedtype</strong> load: StringProtocol</span><span id="f8ad" class="nn mm it nj b gy ns np l nq nr">}</span><span id="0975" class="nn mm it nj b gy ns np l nq nr"><strong class="nj jd">struct</strong> Implement: Example {</span><span id="6386" class="nn mm it nj b gy ns np l nq nr"><strong class="nj jd">typealias</strong> load = String</span><span id="ba6d" class="nn mm it nj b gy ns np l nq nr">}</span></pre></div><div class="ab cl me mf hx mg" role="separator"><span class="mh bw bk mi mj mk"/><span class="mh bw bk mi mj mk"/><span class="mh bw bk mi mj"/></div><div class="im in io ip iq"><h1 id="8158" class="ml mm it bd mn mo mp mq mr ms mt mu mv ki mw kj mx kl my km mz ko na kp nb nc bi translated">类型别名闭包</h1><p id="8c6a" class="pw-post-body-paragraph li lj it lk b ll nd kd ln lo ne kg lq lr nf lt lu lv ng lx ly lz nh mb mc md im bi translated">假设我们有一个上传功能，可以产生三种可能的结果。让我们来看一个例子:</p><pre class="ks kt ku kv gt ni nj nk nl aw nm bi"><span id="e822" class="nn mm it nj b gy no np l nq nr"><strong class="nj jd">func</strong> upload(success: ((Int) -&gt; Int)?,</span><span id="ffef" class="nn mm it nj b gy ns np l nq nr">failure: ((Error) -&gt; Void)?,</span><span id="ec4c" class="nn mm it nj b gy ns np l nq nr">progress: ((Double) -&gt; Void)?) {</span><span id="2784" class="nn mm it nj b gy ns np l nq nr">}</span></pre><p id="01cc" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">如果你看到上面的例子，你会看到很多括号，看起来很难看。我们可以如下使用类型别名:</p><pre class="ks kt ku kv gt ni nj nk nl aw nm bi"><span id="6555" class="nn mm it nj b gy no np l nq nr"><strong class="nj jd">typealias</strong> Success = (Int) -&gt; Int</span><span id="fcb2" class="nn mm it nj b gy ns np l nq nr"><strong class="nj jd">typealias</strong> Failure = (Error) -&gt; Void</span><span id="1857" class="nn mm it nj b gy ns np l nq nr"><strong class="nj jd">typealias</strong> Progress = (Double) -&gt; Void</span><span id="6b8a" class="nn mm it nj b gy ns np l nq nr"><strong class="nj jd">func</strong> upload(success: Success?, failure: Failure?, progress: Progress?) {</span><span id="7160" class="nn mm it nj b gy ns np l nq nr">}</span></pre><p id="c4e6" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">现在上传功能看起来好多了！</p></div><div class="ab cl me mf hx mg" role="separator"><span class="mh bw bk mi mj mk"/><span class="mh bw bk mi mj mk"/><span class="mh bw bk mi mj"/></div><div class="im in io ip iq"><h1 id="2d0e" class="ml mm it bd mn mo mp mq mr ms mt mu mv ki mw kj mx kl my km mz ko na kp nb nc bi translated">结论</h1><p id="3594" class="pw-post-body-paragraph li lj it lk b ll nd kd ln lo ne kg lq lr nf lt lu lv ng lx ly lz nh mb mc md im bi translated">TypeAlias看起来真的很有用，但是它也有一定的缺点。尤其是对于那些刚接触你的代码库的人来说，可能需要一点时间来理解。你必须在好的使用和过度使用之间划清界限。我一直在使用typealias，但我尽量保持理智。</p><p id="c98a" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">我很好奇<em class="nw">你们</em>在日常工作中是如何使用typealias的。请在评论中谈谈你的经历和想法。</p><p id="621f" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">感谢阅读！</p></div></div>    
</body>
</html>