<html>
<head>
<title>Implementing Snowflake Algorithm in Golang</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">在Golang中实现雪花算法</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/implementing-snowflake-algorithm-in-golang-c1098fdc73d0?source=collection_archive---------2-----------------------#2022-08-10">https://betterprogramming.pub/implementing-snowflake-algorithm-in-golang-c1098fdc73d0?source=collection_archive---------2-----------------------#2022-08-10</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="d02e" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">雪花在行动</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/4a19b2c264257ac5edb7c7c3361eb082.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*vZYqQo6fp7o2w_Ow"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">照片由<a class="ae kv" href="https://unsplash.com/@aaronburden?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Aaron Burden </a>在<a class="ae kv" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</p></figure><p id="9eae" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">雪花算法的背景当然是Twitter高并发环境下对惟一ID生成的需求。</p><p id="95f2" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">多亏了Twitter的内部技术，雪花算法之所以能流传到今天并被广泛使用，是因为它有几个特点。</p><ul class=""><li id="e94e" class="ls lt iq ky b kz la lc ld lf lu lj lv ln lw lr lx ly lz ma bi translated">它能满足高并发分布式系统环境中的非重复ID。</li><li id="3407" class="ls lt iq ky b kz mb lc mc lf md lj me ln mf lr lx ly lz ma bi translated">生产效率高。</li><li id="49f7" class="ls lt iq ky b kz mb lc mc lf md lj me ln mf lr lx ly lz ma bi translated">基于时间戳，保证了有序的增量。</li><li id="b5a9" class="ls lt iq ky b kz mb lc mc lf md lj me ln mf lr lx ly lz ma bi translated">不依赖第三方库或中间件。</li><li id="955f" class="ls lt iq ky b kz mb lc mc lf md lj me ln mf lr lx ly lz ma bi translated">生成的id是连续且唯一的。</li></ul><h1 id="1d8d" class="mg mh iq bd mi mj mk ml mm mn mo mp mq jw mr jx ms jz mt ka mu kc mv kd mw mx bi translated">雪花算法原理</h1><p id="b6a5" class="pw-post-body-paragraph kw kx iq ky b kz my jr lb lc mz ju le lf na lh li lj nb ll lm ln nc lp lq lr ij bi translated">我们来看一张图。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nd"><img src="../Images/d6d9735dd278ca9d9a90311d26491eef.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*HFWM1EJb21Ax0ceeEh8z1A.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">图片来源:作者</p></figure><p id="4f37" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">从图中我们可以看到，雪花ID结构是一个64bit的int数据。</p><ul class=""><li id="d383" class="ls lt iq ky b kz la lc ld lf lu lj lv ln lw lr lx ly lz ma bi translated">1bt。</li></ul><p id="e419" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在二进制中，最高位是<code class="fe ne nf ng nh b">1</code>。因为我们用的id应该是整数，有负数，所以这里最高位应该是<code class="fe ne nf ng nh b">0</code>。</p><ul class=""><li id="6562" class="ls lt iq ky b kz la lc ld lf lu lj lv ln lw lr lx ly lz ma bi translated">41位:时间戳。</li></ul><p id="abbb" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">41位可以代表⁴ -1数。如果只用来表示正整数，可以表示的值的范围是0 — ( ⁴ -1)。这里减一的原因是因为取值范围是从<code class="fe ne nf ng nh b">0</code>开始计数，而不是从<code class="fe ne nf ng nh b">1</code>开始。</p><p id="46db" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这里的单位是毫秒，所以41位可以表示⁴ -1毫秒，翻译成单位年就是(⁴ -1)/(1000 * 60 * 60 * 24 * 365) = 69。</p><ul class=""><li id="2d81" class="ls lt iq ky b kz la lc ld lf lu lj lv ln lw lr lx ly lz ma bi translated">10位:工作机器ID。</li></ul><p id="6f61" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这里是用来记录工作机的id。⁰=1024意味着当前规则允许分布式节点的最大数量为1024个节点。这包括五位数的<code class="fe ne nf ng nh b">WorkerID</code>和五位数的数据中心，在这里无法区分，但是下面的代码做了区分。</p><ul class=""><li id="afdc" class="ls lt iq ky b kz la lc ld lf lu lj lv ln lw lr lx ly lz ma bi translated">12位:序列号。</li></ul><p id="9ce0" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">用于记录同一毫秒内生成的不同id。12bit能代表的最大正整数是-1=4095，也就是4095个数字<code class="fe ne nf ng nh b">0, 1, 2, 3, … 4094</code>。这可用于指示同一台机器是在同一时间戳(毫秒)内生成的。4095 ID序列号。</p><p id="ced1" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">原理就是上面的。没有什么困难。让我们看看代码是如何实现的。</p><h1 id="5a6e" class="mg mh iq bd mi mj mk ml mm mn mo mp mq jw mr jx ms jz mt ka mu kc mv kd mw mx bi translated">Go实现了雪花算法</h1><h2 id="6739" class="ni mh iq bd mi nj nk dn mm nl nm dp mq lf nn no ms lj np nq mu ln nr ns mw nt bi translated"><strong class="ak"> 1。定义基本常数</strong></h2><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nu nv l"/></div></figure><h2 id="e0f4" class="ni mh iq bd mi nj nk dn mm nl nm dp mq lf nn no ms lj np nq mu ln nr ns mw nt bi translated"><strong class="ak"> <em class="nw"> 2。定义工人节点</em> </strong></h2><p id="3f42" class="pw-post-body-paragraph kw kx iq ky b kz my jr lb lc mz ju le lf na lh li lj nb ll lm ln nc lp lq lr ij bi translated">因为这是一个在分布式环境中使用的ID生成算法，如果我们想要生成多个workers，我们必须抽象节点参数。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nu nv l"/></div></figure><p id="6ad4" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">代码解释:</p><ul class=""><li id="7e22" class="ls lt iq ky b kz la lc ld lf lu lj lv ln lw lr lx ly lz ma bi translated"><code class="fe ne nf ng nh b">mu sync.Mutex</code>:添加互斥，保证并发安全。</li><li id="8981" class="ls lt iq ky b kz mb lc mc lf md lj me ln mf lr lx ly lz ma bi translated"><code class="fe ne nf ng nh b">LastStamp int64</code>:记录上次ID生成的时间戳。</li><li id="107a" class="ls lt iq ky b kz mb lc mc lf md lj me ln mf lr lx ly lz ma bi translated"><code class="fe ne nf ng nh b">WorkerID int64</code>:worker节点的ID，对上图中的5位WorkerID有意义。</li><li id="1cbc" class="ls lt iq ky b kz mb lc mc lf md lj me ln mf lr lx ly lz ma bi translated"><code class="fe ne nf ng nh b">DataCenterID int64</code>:节点的数据中心ID。</li><li id="7e5a" class="ls lt iq ky b kz mb lc mc lf md lj me ln mf lr lx ly lz ma bi translated"><code class="fe ne nf ng nh b">Sequence int64</code>:当前毫秒内已经生成的id序列号(从0开始累加)一毫秒内最多生成4096个id</li></ul><h2 id="7088" class="ni mh iq bd mi nj nk dn mm nl nm dp mq lf nn no ms lj np nq mu ln nr ns mw nt bi translated"><strong class="ak"> 3。创建一个工人对象</strong></h2><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nu nv l"/></div></figure><h2 id="725a" class="ni mh iq bd mi nj nk dn mm nl nm dp mq lf nn no ms lj np nq mu ln nr ns mw nt bi translated"><strong class="ak"> <em class="nw"> 4。生成ID </em> </strong></h2><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nu nv l"/></div></figure><p id="80ce" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">代码有点长，我来依次解释一下:</p><ul class=""><li id="e60e" class="ls lt iq ky b kz la lc ld lf lu lj lv ln lw lr lx ly lz ma bi translated"><code class="fe ne nf ng nh b">getMilliSeconds()</code>:封装得到当前毫秒值的方法。</li><li id="2119" class="ls lt iq ky b kz mb lc mc lf md lj me ln mf lr lx ly lz ma bi translated"><code class="fe ne nf ng nh b">func(w *Worker) NextID() (uint64, error)</code></li></ul><p id="0578" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这段代码的内容没有什么特殊作用，主要是为了解耦。唯一需要注意的是锁定和释放步骤。</p><p id="bfa3" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这里的实现分为几个步骤:</p><ul class=""><li id="85f6" class="ls lt iq ky b kz la lc ld lf lu lj lv ln lw lr lx ly lz ma bi translated">获取当前时间戳并做出判断。确保当前时间戳值大于上次ID生成的时间戳。否则会有重复的。</li><li id="f180" class="ls lt iq ky b kz mb lc mc lf md lj me ln mf lr lx ly lz ma bi translated">如果相等，首先获取当前毫秒生成的id序列号。这里你可能不明白。相当于<code class="fe ne nf ng nh b">if w.sequence++ &gt; maxSequence</code>。</li><li id="f9a5" class="ls lt iq ky b kz mb lc mc lf md lj me ln mf lr lx ly lz ma bi translated">如果当前毫秒中生成的id序列号溢出，则必须等待下一毫秒。如果不等待，会造成很多重复。</li><li id="1600" class="ls lt iq ky b kz mb lc mc lf md lj me ln mf lr lx ly lz ma bi translated">我们在else中设置<code class="fe ne nf ng nh b">w.sequence</code>到<code class="fe ne nf ng nh b">0</code>，这里有一个解释，如果当前时间与worker节点上一次生成ID的时间不一致，那么worker节点的ID生成顺序号需要复位。</li><li id="03e7" class="ls lt iq ky b kz mb lc mc lf md lj me ln mf lr lx ly lz ma bi translated">最后一步，也是更重要的一步，使用了<code class="fe ne nf ng nh b">OR</code>操作。这里的目的是返回各部分的位，通过按位<code class="fe ne nf ng nh b">OR</code>运算(也就是这个<code class="fe ne nf ng nh b">|</code>)进行整合。<code class="fe ne nf ng nh b">&lt;&lt;</code>这是向左移动归位的功能，<code class="fe ne nf ng nh b">|</code>是积分操作。</li></ul><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nx"><img src="../Images/865f55be300e643a6cd761a933fec5f6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*34ycuZ_n5CBJXyS-fZtinw.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">图片来源:作者</p></figure><h2 id="e41e" class="ni mh iq bd mi nj nk dn mm nl nm dp mq lf nn no ms lj np nq mu ln nr ns mw nt bi translated"><strong class="ak"> <em class="nw"> 5。测试</em> </strong></h2><p id="1132" class="pw-post-body-paragraph kw kx iq ky b kz my jr lb lc mz ju le lf na lh li lj nb ll lm ln nc lp lq lr ij bi translated">写完代码，我们来测试一下。在这里，我用10，000个goroutines并发地生成id，将它们存储在map中，并检查是否有重复。让我们看看代码:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nu nv l"/></div></figure><p id="c1e2" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">以下是验证结果:</p><pre class="kg kh ki kj gt ny nh nz oa aw ob bi"><span id="989f" class="ni mh iq nh b gy oc od l oe of">All 10000 snowflake ID Get successed!</span></pre></div><div class="ab cl og oh hu oi" role="separator"><span class="oj bw bk ok ol om"/><span class="oj bw bk ok ol om"/><span class="oj bw bk ok ol"/></div><div class="ij ik il im in"><p id="9d23" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">感谢您阅读这篇文章。</p></div></div>    
</body>
</html>