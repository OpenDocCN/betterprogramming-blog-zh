<html>
<head>
<title>The Fastest Way to Render the DOM</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">呈现DOM的最快方法</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/the-fastest-way-to-render-the-dom-e3b226b15ca3?source=collection_archive---------0-----------------------#2019-05-29">https://betterprogramming.pub/the-fastest-way-to-render-the-dom-e3b226b15ca3?source=collection_archive---------0-----------------------#2019-05-29</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="5b51" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">虚拟DOM、标记的模板文字或细粒度的可观察对象是最快的吗？</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/d2d6594f840fb41bcc76730dc964e602.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*GUzExY_rdzsppKwaA1wcnw.jpeg"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">来自rawpixel.com</p></figure><p id="ba17" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">在撰写<a class="ae lr" href="https://github.com/ryansolid/solid" rel="noopener ugc nofollow" target="_blank"> Solid </a>的时候，我有机会观察了许多不同的库，试图在基准测试中最大化性能。事实是DOM本身通常是最大的瓶颈。这意味着，归根结底，完全不同的方法可能表现相当。我看到每周都有新的库冒出来，每一个都从这里或那里取一点，把它们完美地组合在一起，过一段时间后，就很难理解其中的一些内容了。</p><p id="f74d" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">现在不要误解我，我喜欢看到这些想法走到一起，但它们都有权衡和成本，有时在人体工程学方面，大多数时候在性能方面。人们对这些决定的全部影响还没有完全了解，但我想分享一些我观察到的情况。</p></div><div class="ab cl ls lt hu lu" role="separator"><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx"/></div><div class="ij ik il im in"><h1 id="4662" class="lz ma iq bd mb mc md me mf mg mh mi mj jw mk jx ml jz mm ka mn kc mo kd mp mq bi translated">比较</h1><p id="e7ca" class="pw-post-body-paragraph kv kw iq kx b ky mr jr la lb ms ju ld le mt lg lh li mu lk ll lm mv lo lp lq ij bi translated"><a class="ae lr" href="https://github.com/krausest/js-framework-benchmark" rel="noopener ugc nofollow" target="_blank"> JS框架基准</a>是JavaScript UI框架的最佳通用基准。对于这个测试，因为我在玩变体，所以有必要在本地运行所有东西，而不是使用官方结果。结果因机器而异，因为我运行的是一台功能较弱的机器，所以在我们测试时，性能会下降得更明显。</p><p id="922b" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">我们将采用我认为每种渲染方法中最好的来说明具体决策的开销。我将通过使用Solid支持多种渲染技术的能力来做到这一点，以便在我们改变不同变量时并列不同的成本，并将其与使用类似技术的库的最佳示例进行比较。让我们看看竞争对手。</p><h2 id="7326" class="mw ma iq bd mb mx my dn mf mz na dp mj le nb nc ml li nd ne mn lm nf ng mp nh bi translated">实心变体:</h2><ol class=""><li id="fc3e" class="ni nj iq kx b ky mr lb ms le nk li nl lm nm lq nn no np nq bi translated"><a class="ae lr" href="https://github.com/ryansolid/solid" rel="noopener ugc nofollow" target="_blank"> <strong class="kx ir">实心</strong> </a> <strong class="kx ir"> </strong> —这是股票ES2015代理版本，具有简洁的setter语法，在细粒度变化检测的基础上馈入DOM模板节点克隆。它通过预编译的JSX模板来实现这一点。<strong class="kx ir"> ( </strong> <a class="ae lr" href="https://github.com/ryansolid/js-framework-benchmark/blob/solid-variations/frameworks/keyed/solid/src/main.jsx" rel="noopener ugc nofollow" target="_blank"> <strong class="kx ir">代码</strong> </a> <strong class="kx ir"> ) </strong></li><li id="20aa" class="ni nj iq kx b ky nr lb ns le nt li nu lm nv lq nn no np nq bi translated"><a class="ae lr" href="https://github.com/ryansolid/solid" rel="noopener ugc nofollow" target="_blank"> <strong class="kx ir">固态信号</strong> </a> <strong class="kx ir"> </strong> —这个版本与上面的相同，但是避开了原始信号的代理的便利性。它使实现变得更重，但是它留下了更小的包和更好的性能。<strong class="kx ir"> ( </strong> <a class="ae lr" href="https://github.com/ryansolid/js-framework-benchmark/blob/solid-variations/frameworks/keyed/solid-signals/src/main.jsx" rel="noopener ugc nofollow" target="_blank"> <strong class="kx ir">)代码</strong> </a> <strong class="kx ir"> ) </strong></li><li id="3699" class="ni nj iq kx b ky nr lb ns le nt li nu lm nv lq nn no np nq bi translated"><a class="ae lr" href="https://github.com/ryansolid/solid" rel="noopener ugc nofollow" target="_blank"> <strong class="kx ir"> solid-lit </strong> </a> —该版本避开了JSX预编译，通过及时标记模板文字运行时编译来实现DOM模板节点克隆。<strong class="kx ir"> ( </strong> <a class="ae lr" href="https://github.com/ryansolid/js-framework-benchmark/blob/solid-variations/frameworks/keyed/solid-lit/src/main.js" rel="noopener ugc nofollow" target="_blank"> <strong class="kx ir">)代号</strong> </a> <strong class="kx ir"> ) </strong></li><li id="8924" class="ni nj iq kx b ky nr lb ns le nt li nu lm nv lq nn no np nq bi translated"><a class="ae lr" href="https://github.com/ryansolid/solid" rel="noopener ugc nofollow" target="_blank"> <strong class="kx ir"> solid-h </strong> </a> —该版本使用HyperScript动态翻译为<code class="fe nw nx ny nz b">document.createElement</code>。但是在其他方面使用与其他相同的实体实现。<strong class="kx ir"> ( </strong> <a class="ae lr" href="https://github.com/ryansolid/js-framework-benchmark/blob/solid-variations/frameworks/keyed/solid-h/src/main.js" rel="noopener ugc nofollow" target="_blank"> <strong class="kx ir">代码</strong> </a> <strong class="kx ir"> ) </strong></li></ol><h2 id="bb12" class="mw ma iq bd mb mx my dn mf mz na dp mj le nb nc ml li nd ne mn lm nf ng mp nh bi translated">其他图书馆:</h2><ol class=""><li id="03e2" class="ni nj iq kx b ky mr lb ms le nk li nl lm nm lq nn no np nq bi translated"><a class="ae lr" href="https://github.com/Freak613/domc" rel="noopener ugc nofollow" target="_blank"><strong class="kx ir">【domc</strong></a>—这个微渲染库被设计成在变更管理中做尽可能少的工作，同时在DOM模板节点上最大化地使用从index.html水合的定制运行时HTML字符串DSL。<strong class="kx ir"> ( </strong> <a class="ae lr" href="https://github.com/ryansolid/js-framework-benchmark/tree/solid-variations/frameworks/keyed/domc" rel="noopener ugc nofollow" target="_blank"> <strong class="kx ir">代码</strong> </a> <strong class="kx ir"> ) </strong></li><li id="a273" class="ni nj iq kx b ky nr lb ns le nt li nu lm nv lq nn no np nq bi translated"><a class="ae lr" href="https://github.com/adamhaile/surplus" rel="noopener ugc nofollow" target="_blank"> <strong class="kx ir">盈余</strong> </a> —这个库使用细粒度的变化检测，用预编译的JSX模板创建一系列<code class="fe nw nx ny nz b">document.createElement</code>。Solid使用相同的底层变更管理库。<strong class="kx ir"> ( </strong> <a class="ae lr" href="https://github.com/ryansolid/js-framework-benchmark/tree/solid-variations/frameworks/keyed/surplus/src" rel="noopener ugc nofollow" target="_blank"> <strong class="kx ir">)代码</strong> </a> <strong class="kx ir"> ) </strong></li><li id="a44d" class="ni nj iq kx b ky nr lb ns le nt li nu lm nv lq nn no np nq bi translated"><a class="ae lr" href="https://github.com/localvoid/ivi" rel="noopener ugc nofollow" target="_blank"><strong class="kx ir">IVI</strong></a><strong class="kx ir"/>——你可能听说过Inferno，但这个库是虚拟DOM的真正巅峰。它使用带有钩子的HyperScript Helpers-esque API。<strong class="kx ir"> ( </strong> <a class="ae lr" href="https://github.com/ryansolid/js-framework-benchmark/blob/solid-variations/frameworks/keyed/ivi/src/main.js" rel="noopener ugc nofollow" target="_blank"> <strong class="kx ir">)代号</strong> </a> <strong class="kx ir"> ) </strong></li><li id="7e4f" class="ni nj iq kx b ky nr lb ns le nt li nu lm nv lq nn no np nq bi translated"><a class="ae lr" href="https://github.com/Polymer/lit-html" rel="noopener ugc nofollow" target="_blank"><strong class="kx ir">lit-html</strong></a><strong class="kx ir"/>—不是同类型的第一个库，但却是性能最好的。它在运行时使用带标签的模板文字输入DOM模板节点。<strong class="kx ir"> ( </strong> <a class="ae lr" href="https://github.com/ryansolid/js-framework-benchmark/blob/solid-variations/frameworks/keyed/lit-html/src/index.js" rel="noopener ugc nofollow" target="_blank"> <strong class="kx ir">代码</strong> </a> <strong class="kx ir"> ) </strong></li><li id="db56" class="ni nj iq kx b ky nr lb ns le nt li nu lm nv lq nn no np nq bi translated"><a class="ae lr" href="https://github.com/infernojs/inferno" rel="noopener ugc nofollow" target="_blank"> <strong class="kx ir">魔族</strong></a><strong class="kx ir"/>——最快的React克隆和最快的虚拟DOM库之一。它使用带有特殊指令的JSX来指示如何获得最佳性能。<strong class="kx ir"> ( </strong> <a class="ae lr" href="https://github.com/ryansolid/js-framework-benchmark/tree/solid-variations/frameworks/keyed/inferno/src" rel="noopener ugc nofollow" target="_blank"> <strong class="kx ir">代码</strong> </a> <strong class="kx ir"> ) </strong></li></ol><p id="7c09" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">您最喜欢的一些库可能不在那里，但本质上这种组合反映了您将在这些库中看到的所有技术的高度优化版本。你可以把这看作是今天你的图书馆潜力的最好指标。如果你有兴趣看流行库的比较，我推荐<a class="ae lr" href="https://medium.com/@ajmeyghani/javascript-frameworks-performance-comparison-c566d19ab65b" rel="noopener">这个比较</a>。</p><p id="167d" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">一个值得注意的缺席，我想补充的是一个Web程序集条目。不幸的是，在这一点上，WASM条目本质上是普通的实现，没有更高级的数据驱动的抽象。最快的只能放在中间。因此，可以肯定地说，WASM有一些潜力，但我们还没有达到。</p></div><div class="ab cl ls lt hu lu" role="separator"><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx"/></div><div class="ij ik il im in"><h1 id="5090" class="lz ma iq bd mb mc md me mf mg mh mi mj jw mk jx ml jz mm ka mn kc mo kd mp mq bi translated">结果呢</h1><h2 id="0792" class="mw ma iq bd mb mx my dn mf mz na dp mj le nb nc ml li nd ne mn lm nf ng mp nh bi translated">HyperScript (inferno，ivi，solid-h)</h2><p id="3f68" class="pw-post-body-paragraph kv kw iq kx b ky mr jr la lb ms ju ld le mt lg lh li mu lk ll lm mv lo lp lq ij bi translated">HyperScript是一种将视图表示为函数组合(通常是h或React.createElement)的方式。例如:</p><pre class="kg kh ki kj gt oa nz ob oc aw od bi"><span id="bd2e" class="mw ma iq nz b gy oe of l og oh">h('div', {id: 'my-element'}, [<br/>  h('span', 'Hello'),<br/>  h('span', 'John')<br/>])</span></pre><p id="ec52" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">这是虚拟DOM库拥有的类别。即使他们使用JSX或其他模板DSL，最终也会被转换为每元素呈现方法。这适合在每个渲染周期在JS中构建一个虚拟DOM树，但是正如这里所示，它也可以用于在Solid的情况下构建一个反应依赖图。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi oi"><img src="../Images/0ad72e9af0ce5995840c3ac1c4f04a78.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*QmcWyqfVrlgsK_6cmgSn_g.png"/></div></div></figure><p id="5f37" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">如您所见，虚拟DOM库在这里要快得多。创建反应图的开销在这里很大。请注意基准测试#1、#2、#7、#8和#9的差异。相反，Solid在测量部分更新的其余基准测试中稍快一些。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi oj"><img src="../Images/ea159e657cdcd43999bb70d231dfce35.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*6yDVUECT3cBhRpUHixvi7g.png"/></div></div></figure><p id="47f8" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">记忆不太确定。Inferno和这个版本的Solid几乎不分上下，而更高性能的ivi使用更多的内存。这是Solid最占用内存的版本，但值得注意的是这里的内存使用量有多接近。</p><p id="1173" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">这是经典的VDOM与细粒度的比较。细粒度的预先采取措施，以更好地执行更新。如果这是故事的结尾，那就很容易解释VDOM在过去几年的统治地位了。可以说，如果您使用细粒度的HyperScript，那么使用虚拟DOM可能会更好。</p><h2 id="8d44" class="mw ma iq bd mb mx my dn mf mz na dp mj le nb nc ml li nd ne mn lm nf ng mp nh bi translated">字符串模板(domc，lit-html，solid-lit)</h2><p id="6757" class="pw-post-body-paragraph kv kw iq kx b ky mr jr la lb ms ju ld le mt lg lh li mu lk ll lm mv lo lp lq ij bi translated">这里的每个图书馆都有一些共同点。它们基于克隆模板元素进行渲染，在运行时执行，不使用虚拟DOM。然而，每一个都有不同的做法。DomC和lit-html做自顶向下的区分，类似于虚拟DOM，而Solid使用细粒度的反应图。Lit-html将模板分成几个部分。DomC和Solid just in time将模板编译成单独的代码路径，用于创建和更新。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi ok"><img src="../Images/cb2c29259371ac66e776233f5de1637f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Se35vdDzgiSlHLmPtc-eHA.png"/></div></div></figure><p id="f1d3" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">这个类别的性能范围最广，DomC是最快的库之一，lit-html是最慢的。固体垃圾就在狼群的中间。DomC证明了保持代码简单可以带来令人难以置信的性能。它唯一的缺点是#4，因为它是通过叶节点的差分来工作的，结构越深，开销越大。这已经足够快了，但我们需要验证它如何扩展。Solid Lit比Solid HyperScript性能更好。在运行时，即时编译消除了创建reactive-graph的大部分缺点，让它在ivi(最快的虚拟DOM库)前面偷偷摸摸地运行(参见本文末尾的完整性能结果表)。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi ol"><img src="../Images/79465f468292a64aa2e3fa796de5c386.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*O0hGe-PSi0k-9SPVxhYjew.png"/></div></div></figure><p id="ad6f" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">有了这一堆记忆好多了。在所有竞争对手中，DomC的内存占用最小。通过克隆模板元素进行渲染可以节省大量成本。</p><p id="6f51" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">这一组中最有趣的一点是，运行时代码生成比构建阶段的预编译具有最小的性能成本。从这个意义上说，对lit-html进行比较可能是不公平的，因为它没有利用这种技术，但公平地说，目前的lit-html或类似的库，如hyperHTML或lighterHTML，并不是使用标记模板文字的最佳方式，即使在没有虚拟DOM的情况下，也有可能在运行时获得非常好的性能。</p><h2 id="d90e" class="mw ma iq bd mb mx my dn mf mz na dp mj le nb nc ml li nd ne mn lm nf ng mp nh bi translated">预编译JSX(实心、实心信号、剩余)</h2><p id="11dc" class="pw-post-body-paragraph kv kw iq kx b ky mr jr la lb ms ju ld le mt lg lh li mu lk ll lm mv lo lp lq ij bi translated">现在来看重量级。这些库使用编译时编译的JSX到DOM和反应式图形指令。与后两类细粒度库不同，初始构建的开销几乎完全消除，这使得它成为这种类型库的理想选择。模板可以是任何东西，但是JSX提供了一个清晰的语法树，有助于更好的工具和开发者体验。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi om"><img src="../Images/32cdae0560880c3c406b6424eefd987c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*pOK0LoIVBW6CH3KKUf9BAg.png"/></div></div></figure><p id="7b77" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">这一组具有最接近的性能结果，但是这里的差异非常重要。所有这3个库都在<a class="ae lr" href="https://github.com/adamhaile/S" rel="noopener ugc nofollow" target="_blank"> S.js </a>中使用相同的变更管理库。使用固体信号作为基线，展示了如何使用模板元素克隆来观察函数，从而提供最佳性能。Solid的标准实施增加了使用ES2015代理的开销，这会增加所有基准测试的开销。另一方面，Surplus使用<code class="fe nw nx ny nz b">document.createElement</code>，它在测试创建许多行#1、#2、#7、#8的基准测试中有更多的开销。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi on"><img src="../Images/99fe383181ba34574fa6802add4b31ef.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*H7hQ1HWm7ZrRRx9ncVek7g.png"/></div></div></figure><p id="8688" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">内存也是如此。然而，在这种情况下，代理比模板元素克隆有更多的开销。</p><p id="dd30" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">这里的要点是，代理有真正的性能成本，更多的库应该克隆模板元素。另一方面，您可以将代理带来的性能损失视为一项小投资。Solid的官方实现拥有所有库中最少的实现代码，只有66行，甚至比Svelte少13%的非空白字符，Svelte是一个以编写更少代码而自豪的库。</p><h2 id="9ee0" class="mw ma iq bd mb mx my dn mf mz na dp mj le nb nc ml li nd ne mn lm nf ng mp nh bi translated">同类最佳(domc、ivi、solid-signals、vanillajs)</h2><p id="6bc5" class="pw-post-body-paragraph kv kw iq kx b ky mr jr la lb ms ju ld le mt lg lh li mu lk ll lm mv lo lp lq ij bi translated">接下来，我们将每个类别的获胜者与用普通JavaScript编写的极其高效的手工版本进行比较。这里的好处是，每个类别中的最佳代表了每个流行的变更管理方法。你甚至可以从这些库中找出与big 3的相似之处。实心→ Vue，DomC →角形，ivi →反应。也就是说，如果你把它们剥离到它们的渲染器，去掉60-200 kb的代码。</p><p id="180d" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">那么我们怎么公平呢？</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi oi"><img src="../Images/c59e613c8650f86d41b0f4e9e232b19e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*NCehudMdyE5Q8t7-HksT8w.png"/></div></div></figure><p id="a039" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">DomC和Solid在这里很接近，ivi也不逊色，但DomC通常更快。它比普通版本的开销小得多，但是对于嵌套的部分更新来说效率较低。这个基准本身并不能完全区分这些方法。任何声称虚拟DOM很慢或者有不必要开销的人都应该检查一下自己。大多数图书馆永远不会有这种性能。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi oo"><img src="../Images/1c6a0b80ba83383590957339480b98e8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Ve6YFunf2wuR5JkS7I4T_w.png"/></div></div></figure><p id="801d" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">有了内存，DomC再次显示了它的占地面积有多小。细粒度的Solid在内存使用方面领先虚拟DOM ivi。</p><p id="410f" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">从这些结果中得出的最有趣的结论可能是，不管使用什么方法，这些库的开销都比普通的JavaScript版本小得多。这些库都很快。</p><h2 id="e92e" class="mw ma iq bd mb mx my dn mf mz na dp mj le nb nc ml li nd ne mn lm nf ng mp nh bi translated">捆绑大小</h2><p id="a211" class="pw-post-body-paragraph kv kw iq kx b ky mr jr la lb ms ju ld le mt lg lh li mu lk ll lm mv lo lp lq ij bi translated">最后，我想说一下包的大小，因为我觉得这个领域得到了太多的关注。最近的“真实世界”基准测试几乎把所有的注意力都放在了这些指标上。是的，包的大小很重要，并且与性能有直接关系，但是这有多大的区别呢？我怀疑代码加载开销的变化比大小有更大的影响。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi op"><img src="../Images/cf9f1fcd226e756e264544a24824ffc3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Ea0Ns22xOiBWeSzpNycI_Q.png"/></div></div></figure></div><div class="ab cl ls lt hu lu" role="separator"><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx"/></div><div class="ij ik il im in"><h1 id="e0e9" class="lz ma iq bd mb mc md me mf mg mh mi mj jw mk jx ml jz mm ka mn kc mo kd mp mq bi translated">结论</h1><p id="5891" class="pw-post-body-paragraph kv kw iq kx b ky mr jr la lb ms ju ld le mt lg lh li mu lk ll lm mv lo lp lq ij bi translated">像往常一样，这种比较的结果从来都不是结论性的。重要的是旅程以及我们在旅途中学到的东西。在这种情况下，我们看到DOM本身是最大的性能瓶颈。以至于没有明确的最佳技术。</p><blockquote class="oq"><p id="9ed2" class="or os iq bd ot ou ov ow ox oy oz lq dk translated">但只能有一个。</p></blockquote><figure class="pb pc pd pe pf kk gh gi paragraph-image"><div class="gh gi pa"><img src="../Images/b2585ce9b8dd8b4b56593a630f8eeaee.png" data-original-src="https://miro.medium.com/v2/resize:fit:1290/format:webp/1*RzPQRIy-WqyEbDsflcsfFw.jpeg"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">克里斯托弗·兰伯特饰演高地人</p></figure><p id="97e0" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">不，事情没那么简单。DOM并不慢。虚拟DOM速度不慢。但我想善有善报。我承认，是React对虚拟DOM性能的夸夸其谈首先把我引入了这个领域。对周围意见的无知令人愤怒。</p><p id="42d0" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">类似地，最近“虚拟DOM很慢”的合唱也是不明智的。渲染一个虚拟的DOM树并区分它与不这样做相比会有很大的开销，但是不这样做是不是可以扩展呢？如果您必须处理数据快照呢？</p><p id="4c0d" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">我所看到的是每条规则都有例外。一般来说，预编译是与细粒度反应库配合使用时最快的方法，但是DomC两者都不能匹配性能。原生JavaScript方法，比如用带标签的模板文字克隆模板元素，可能是lit-html中一家大公司(Google)支持的最高效的方法。然而，它是这一批中最慢的，甚至不是使用这些技术的最有效的方法。Svelte可能是围绕“卓越”性能的最响亮的社区，图书馆甚至无法在这个人群中竞争。</p><p id="8feb" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">因此，即使反应式编程占了上风，也不意味着所有的反应式库都很快，或者基准就是一切。考虑到这种比较的深度，我认为真正的收获是有快速库和慢速库。尽管我们很想把这归因于一些先进的技术，但我们仍然受到所有这些技术的物理限制。</p></div><div class="ab cl ls lt hu lu" role="separator"><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx"/></div><div class="ij ik il im in"><p id="a825" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">在单个图表上测试的所有库:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi pg"><img src="../Images/f1fe1b8cc709d98cc8d0f5f2dd5c6cb2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*UTkJYuYKJw9TW2qGyRFY0Q.png"/></div></div></figure></div></div>    
</body>
</html>