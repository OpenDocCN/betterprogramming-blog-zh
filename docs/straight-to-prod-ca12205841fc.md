# 直接戳

> 原文：<https://betterprogramming.pub/straight-to-prod-ca12205841fc>

## 为每个提交产品做好准备的模式和行动手册

![](img/aca8df3f5aa5075862b75bddbda4ad62.png)

所有人登上生产快车！(来源:[菲克里·拉西德](https://unsplash.com/@fikrirasyid?utm_source=medium&utm_medium=referral)在 [Unsplash](https://unsplash.com?utm_source=medium&utm_medium=referral) 上)

# 分枝被认为是有害的？

我小的时候，我们没有分店。嗯——我们有，算是吧，但是你让他们坐在角落里，试图假装他们不存在。它们是沉重的、令人不快的东西。创建成本高，维护困难，无法合并。

当 Git 伴随着它的轻量级分支和分布式出现时，它解决了许多问题——也创造了更多问题。我们塑造我们的工具，然后我们的工具塑造我们。

我们做容易做的事情。一旦分支和——更重要的是——合并变得快速而轻松，我们就开始更频繁地这样做。特征分支和拉式请求进入了通用术语。 [Gitflow](https://www.atlassian.com/git/tutorials/comparing-workflows/gitflow-workflow) 被创建。我看着那些 Gitflow 图表，心想，我可以在那些树枝上建一个树屋！但是对许多人来说，这是一个进步。如果我对自己诚实的话，我就是其中之一。

如果你允许我说一会儿的话，在我们开始写文章之前，让我们先来看看这个故事。当我还是一个热切的年轻软件工程师，还在完成我的学位时，我加入了一个长期运行的项目，正好成为 CVS 到 SVN 大迁移的一部分。这已经是很久以前的事了，我已经不记得任何关于使用 CVS 的事情了，但是我参与了为 SVN 改写的“发布过程”。

这是一个奇怪的野兽，这个释放过程。它标记了每个版本，这很好。但是热修复涉及到回到标签和*提交更多的东西来对抗标签*。这无耻地利用了这样一个事实:在 SVN，标签和分支之间的主要区别是一厢情愿。

如果我们必须挑选一个提交到热修复分支(实际上是一个标签)，我们…我不知道我是否能承认这一点。我们…只是又写了一遍代码。用手。凭记忆。我对改进这个过程的最大贡献是发现了 Eclipse 中的“与主干比较”选项，并教团队如何使用它。

我们也没有单元测试，甚至没有每夜构建，更不用说 CI 服务器了。我们没有特征标志。我们在主干上开发。如果代码没有准备好提交，我们就不会提交。它坐在我们的机器上，日复一日，周复一周。有时我们会将工作目录复制到网络驱动器上，以防硬盘出现故障。其他时候，我们把谨慎抛到了九霄云外，任其自然。

然后，当我们接近承诺时，比赛开始了！其他人也可能接近承诺。挑战在于首先让您的更改生效，然后让其他人进行痛苦的合并。急于推出 first 是否导致了疏忽和愚蠢的错误？是的。是的，确实如此。

树枝比这个好吧？嗯，也许吧。

一切都是有语境的。我不知道你的背景。我不了解你，不了解你的公司，不了解你的同事，也不了解你的工作方式。但我还是要下一个断言。一个大的，大胆的，潜在的可怕的声明。

树枝把你引入歧途。Gitflow 不是你的朋友。

***你应该直截了当地向主人表白。***

这个想法让你害怕吗？为什么？这不是一个修辞或开玩笑的问题。你害怕什么？你的眼睛看到了什么？请认真思考这个问题。

当我建议去掌握时，我经常会遇到阻力。公平地说，根据过去的经验，这通常是合理的。包括我自己的。在我们职业生涯的某个阶段，几乎所有人都见过基于主干的开发出了非常非常糟糕的错误。我收集的许多异议都属于以下类别之一:

1.  它可能会打破什么东西
2.  还没准备好
3.  我们喜欢保持“主人”的干净和稳定
4.  我们怎么能允许“低年级生”不经审查就直接把代码推进去呢？
5.  几个以上的开发人员同时开发同一个代码库将会造成混乱。
6.  “在这里行不通”——我们有一些特殊之处，这意味着 CI/CD 不太合适。

当我和我的工程师同事讨论删除特性分支时，我是在和聪明、理性的人交谈。他们看到分支工作，基于主干的开发失败。如果回到没有树枝的生活是危险和艰难的，我们为什么要烦恼呢？

以我的经验来看，尽管我有初步的经验，但我有三个主要原因值得追求:

1.  持续集成[CI]和持续交付/部署[CD]有着[充分记录的](https://continuousdelivery.com/evidence-case-studies/#research)，也是普遍报道的优势。这些好处中的许多都是基于使**设计- >代码- >测试- >发布- >度量**循环尽可能短。你越延迟推动到主设备，你就越延迟 CI/CD 反馈回路的某些部分。在这一点上，一个常见的反应是断言您可以随时将 master 合并到您的分支中！这是真的，但是*你的*代码还是对别人隐藏的。不要隐藏你的代码。太没礼貌了。推主。
2.  事实证明，当你思考如何在不破坏一切的情况下推动掌握时，你需要锻炼的精神肌肉与你进化分布式系统所需的精神肌肉是相同的。你对基于主干的开发[TBD]越熟练，你就越擅长开发 API 和数据模式。TBD 帮助你赢得微服务。反之亦然。这是一个漂亮的小反馈循环，增强了我们正在构建的代码/发布/度量循环。
3.  用于安全管理 TBD 的特性切换可以将“部署代码”与“发布特性”分离开来。这有一个奇妙的好处，就是让一个功能在“业务准备就绪时”开启。每个人不再需要围绕发布周期保持一致。这反过来可以大大消除“发布危机”,这对士气、效率和质量都有全面的积极影响。

否认你自己的主干，你否认你自己这个生态系统的好处。长寿特征分支不像[盆景小猫](https://www.snopes.com/fact-check/bonsai-kittens/)那么糟糕，但也很接近。

对于上面列出的反对意见，我个人认为它们都可以归结为，“不知道这是如何工作的，所以它可能不工作。”很容易被引上这条路。许多关于实现 CD 和 TBD 的建议可以总结为*“只需使用特征标志！”*说起来容易，掌握起来难。你可以在网上找到一些关于使用功能标志的好的、[甚至更好的](https://medium.com/@thysniu/coding-with-feature-flags-how-to-guide-and-best-practices-3f9637f51265)信息。虽然特征标志很酷，但是特征标志的死亡是一件事。为什么要制造不必要的复杂性？

在这篇文章中，我将更深入地探讨一些使每个提交产品就绪的特定技术。

# 添加是安全的，删除需要思考

当我谈到与 RMI 和 Java 序列化的斗争时，我是在显示我的年龄吗？也许…但是毫无疑问，你们中的一些人会用你们的 CORBA 车祸和 DCOM 灾难来打败我。然后我们有了 pickling 和 WSDL 和 DTD，现在我们有了 REST 和 thrift 和 Avro 和 gRPC 和 protobuf 和 GraphQL，但都是一样的东西。如果你曾经与跨 API、二进制格式或模式版本的向后兼容性搏斗过，你有一个优势。对于基于主干的开发，您需要戴上同样的“思考帽”。

向类/记录/'数据传输对象'[DTO]添加新字段是向后兼容的。除非我们 100%确定它们没有被使用，否则删除它们是不可能的。修改字段是一个“先删除后添加”的操作，这意味着“删除”规则适用。

让每个小的提交都安全生产的一个关键见解是，要意识到担心与你之前保存在磁盘上的东西或旧的 API 的兼容性，与担心与来自一个“不完整”特性的代码的兼容性没有区别。

添加是安全的。就地修改是不安全的。只有在你能保证该对象未被使用时，移除才是安全的。在此基础上，以下基本构造块是安全的:

*   向表中添加未使用的列
*   将未使用的字段添加到 d to
*   向方法中添加未使用的参数
*   向类中添加未使用的方法
*   将未使用的类添加到模块中
*   将未使用的模块添加到存储库中

请注意,“未使用”是指生产代码未使用。单元和集成测试应该给我们信心，增加的代码将会工作。

现在，我们可以使用这些构建模块来设计一些用于添加新功能的通用行动手册。以下场景将假设一个具有静态类型语言的通用堆栈、基于 RPC 的传入端点、域逻辑层、ORM 和关系存储层。选择的所有场景都有一个前端/后端分割。这是因为我期望这个界限为广大读者所熟悉。“重头戏”本身同样适用于任何架构边界，例如微服务架构中的两个后端服务。

# 添加功能

## 颠倒

**场景:**以前捕获名字、姓氏和出生日期的表单现在也需要捕获‘最喜欢的沙拉菜’。

**提交流程:**

*假设在下面的每个要点之后，您都有一个可以安全提交并推送到 master 的代码更改。*

*   将`favouriteSaladGreen`列添加到用户表中(可空)
*   将`favouriteSaladGreen`字段添加到用户“实体”中
*   将`favouriteSaladGreen`字段添加到在域层和持久层之间传递的‘user dto’传输对象中
*   [如果适用]将`favouriteSaladGreen`字段添加到用于在服务端点和域层之间传递数据的传输对象。(您可能正在重用上面的“UserDTO ”)
*   如果提供的话，开始从前端向后端发送`favouriteSaladGreen`字段。
*   将`favouriteSaladGreen`字段添加到用户表单，并将输入绑定到发送到后端的数据。

任务完成。

**优点:**

*   对于简单的更改，您可以避免添加功能标志的复杂性。(不管怎样，你可能需要一个，用于 A/B 测试或受控的推广。)
*   直接开发流程

**缺点:**

*   对于更复杂的变更，有一个风险是，当变更渗透到前端时，UI 所能提供的和后端所期望的不匹配。
*   类似地，如果改变是在前端读取和显示新信息，风险是后端驱动的设计可能不满足前端需求。

# 自上而下

**场景:**最喜欢的绿色太限制了。我们希望从我们的用户那里获得完整的“最受欢迎的沙拉**食谱**”。这样的用户界面会相当复杂，需要多个表单元素和太多的 CSS。可能需要一段时间的发展和完善。但是一旦前端完成，附加数据将被发送到现有的端点。

**提交流程:**

*假设在下面的每个要点之后，您有一个可以安全提交并推送到 master 的代码更改。*

*   为“捕捉沙拉食谱”用户首选项创建功能标志。
*   添加一个存根表单来捕获沙拉食谱，确保如果特性标记为 off，它不会出现。
*   前端 UI 的完整开发[可能需要多次提交，但是这些都安全地隐藏在特性标志后面]。
*   将`saladRecipe`添加到发送到现有后端端点的数据中。额外的数据在这一点上没有被使用。
*   在后端，解析端点接收器中的`saladRecipe`信息(通常是一个 REST 控制器，但针对您的堆栈进行了调整)…并将其丢弃。
*   将`saladRecipe`数据从控制器传递到“域逻辑”层。然后要么添加您可能需要转换或操作它的任何逻辑，确保对它进行单元测试…然后扔掉它。请记住，因为 UI 是有特性标记的，所以您在生产中实际上不会收到这些数据。
*   如上所述，将`saladRecipe`从你的域层传递到你的持久层，扔掉它。(如果您使用类似 JPA 的东西，您可以将字段标记为`transient`来实现这一点)
*   更改数据库以添加您需要的新表结构。
*   停止丢弃`saladRecipe`数据，它现在可以被持久化。

任务完成。该功能是端到端工作的。

**优点:**

*   消除了前端需求与后端实施不一致的风险
*   直接开发流程

**缺点:**

*   需要一个特性标志，这增加了复杂性，所以在建立之前要考虑这个特性是否足够小，可以“自底向上”开发。

# 中间向外

**场景:**在获得“最喜爱的沙拉食谱”后，我们希望建立一个功能，让连接的用户可以看到彼此的食谱，并就他们的饮食中是否有足够的超级食物形成意见。

**开发流程:**尽管描述的场景有许多复杂的因素，我们可以天真地将其归结为前端/后端的分离。就我个人而言，我通常嘲笑这种懒惰的分解，总是更喜欢寻找价值的垂直切片。但是让我们假设我们已经尝试过了，并且我们已经将我们的任务缩减到在服务边界的任何一边都有大量工作的事情。

我们可以使用“自顶向下”的方法来实现这些任务，这样做的好处是可以确保当我们开始构建 API 时，消费者的需求都得到了考虑。

但是如果我们做不到呢？如果想并行工作呢？

在过去，我看到这些任务像“建一座桥”一样被解决。前端工作是“自上而下”进行的它从用模拟数据创建组件或 UI 布局开始，然后驱动 API 设计。与此同时，后端工作开始了，并且在缺乏定义的 API 的情况下，“自下而上”地开始工作。后端工作从*预期的*数据开始——随后的变化，并继续向上暴露 API 中需要的东西。然后你试着在中间相遇。

从来没成功过。有了足够的计划，API *应该*看起来像什么，你可以将损害最小化，但就我个人而言——我从未见过这一切顺利完成的。此时你可能在想，“招摇！GraphQL！策划？只是互相交谈…”而且绝对！我们就这样玩游戏。但是让我们更进一步。不要只是谈论和定义 API。建造它。首先。这就是我所说的‘中出’。

如果没有任何东西调用客户端，前端可以安全地构建(在多次提交的过程中)一个 API 客户端。后端可以安全地实现(通过多次提交)，并且 API 端点知道没有生产代码会调用它。

然后前端从 API 开始构建。在这一点上，我们将引入一个特征标志。后端从 API 向下构建。很可能双方都会发现他们需要对 API 做一些小的调整。如果您使用的是带有 GraphQL 或 protobuf 之类模式的 RPC 协议，您可能会发现这足以让您保持一致。否则，消费者驱动的合同测试，如 [Pact](https://docs.pact.io/) 或 [Spring Cloud Contracts](https://spring.io/projects/spring-cloud-contract) 都是很好的工具。他们比简单地就 API 达成一致更进了一步，将在构建时检查双方是否都遵守了合同。

# 修改现有要素

修改现有功能可能比简单地添加新功能要困难一些。我听说这个过程就像是在喷气式飞机还在空中的时候重新组装引擎。

我们如何修改现有特征取决于行为是否需要改变。

## If/Else

更改功能的行为本质上类似于修改可序列化对象或 API 中的字段。就版本兼容性而言，我们真正做的是在一个原子步骤中“删除”然后“添加”。对于一次提交中的微小变化，这很好。

对于跨越多次提交的长期变更，我们需要将其分为三个步骤。

1.  添加新行为
2.  使用新的行为
3.  去除旧的行为

要实施第一步，请从上一节的行动手册中选择适当的方法。

对于第二步，您可能希望在适当的位置放置一个特性标志。这使您可以逐步推出这些变化。我们的新行为可能会有多个消费者，在他们都被砍掉之前，我们无法打开这个功能。因此，这个剧本的名字是:

```
**if** (flagEnabled)
   newBehaviour()
**else**
   oldBehaviour()
```

根据被归入重载术语“行为”的内容的复杂性，以及你的语言所提供的功能，这可能成为一个开关语句或一个策略模式。不管怎样——我们是在代码中分支，而不是在代码库中分支。在某种程度上，这更简单，更容易理解…在某种程度上。所以第三步，去除旧的行为，真的很重要。

在你实现了“第二步”之后，你可以进行 A/B 测试，你的特性就可以展示给客户了。如果交付的压力很大，在这一点上结束一天的工作是非常诱人的。这个，你千万不要做。直到标志被移除，特征才“完成”。衡量使用情况，宣布成功，移除标志。或者声明失败并删除该功能。根据您所在团队的工作方式，让票证保持开放，将卡留在板上，或者在您开始工作时添加一张新的卡/票证来删除队列底部的分支。不管你怎么做，都要确保完成。

# 替换现有功能

你可能想要接触现有功能的另一个主要原因不是改变行为，而是改善非功能性需求，如性能，或者用另一种选择取代集成技术，例如用[德鲁伊](http://druid.io/)替换[点击屋](https://clickhouse.yandex/)。

## 抽象分支

“抽象分支”并不是一个新概念。这个短语本身可以追溯到 2007 年，而这个技术本身要古老得多。很难说有多老，但是在 Git 和廉价分支出现之前，我们需要这些东西。我想知道，有多少有效的 TBD 真的只是在重新发现一件遗失的艺术品？

许多其他软件工程杰出人士已经通过抽象技术讨论了这个分支，例如[马丁·福勒](https://martinfowler.com/bliki/BranchByAbstraction.html)、[杰兹·亨布尔](https://continuousdelivery.com/2011/05/make-large-scale-changes-incrementally-with-branch-by-abstraction/)和[保罗·哈曼特](https://www.branchbyabstraction.com/)。其中一些报道比其他的更难消化。我推荐马丁·福勒的书，因为它很容易阅读。

该技术归结为在您想要替换的东西前面构建一个[适配器](https://en.wikipedia.org/wiki/Adapter_pattern)或其他合适的抽象层。将所有东西指向你的新抽象层。在抽象层内部放置一个特性开关。当开关被扳动时，新的行为就开始了。瞧啊。当你的喷气式飞机在空中飞行时，你已经改变了它的引擎。

**警告:**不是每个变化都可以通过抽象来分支。有时候你想替换的东西缠绕得太紧，耦合得太深。从过去的经验来看，这方面的一个例子是在复杂的整体代码基础上从 Spring 3 升级到 Spring 4。这两个框架不能同时共存于同一个项目中。使用了一根树枝。没关系。你不可能赢得所有人。

## 科学家

科学家是一个 Ruby 库，用于“仔细重构关键路径”——引用他们自己的 GitHub 页面。它有许多其他语言的端口…和 Perl。与“抽象分支”不同，“科学家”剧本包括同时运行新旧代码路径**并报告结果。**

**该库脱胎于 GitHub 对“合并”功能的重构，我自己任何进一步总结的尝试都将是不公正的。我建议阅读原始文章(链接在本节末尾),以了解什么是库以及它是如何被使用的。**

**我将对他们的文章做些补充，只是想把注意力引回到我自己文章的前半部分。添加未使用的不完整功能是无害的，并且不需要特性分支。新的代码路径可以在 master 上构建。当你认为它已经准备好了，科学家就会建立信任。**

**[](https://github.blog/2015-12-15-move-fast/) [## 快速行动并解决问题 GitHub 博客

### 任何开发过足够大的代码库的人都知道技术债务是不可避免的现实:越快…

github.blog](https://github.blog/2015-12-15-move-fast/)** 

# **关于测试的一句话**

**尽管有剧本，尽管有模式，尽管有特征标志和抽象分支——一些变化本质上比其他变化更有风险。你的特征标志真的有效吗？所有应该在背后的东西实际上都在背后。你的前端风格变化被充分控制了吗？**

**我们需要自信，我们即将推行的变革不会破坏任何东西。*其中的一部分*是知道如何构建变更和代码以降低风险——这是本文的主要焦点。但只是一部分。**

**你剩下的自信可能来自于测试。理想情况下，有适当数量的单元、集成甚至端到端测试在每次提交时执行。希望你在推之前跑完了大部分！仅仅有一个及格的构建应该给我们一个合理的信心水平。**

**对于特别有风险的变更，最好能够尽早在类似生产的环境中执行手动或探索性测试。在一个工作场所，我们的测试环境大约每星期重置一次以跟踪 master 但是我们甚至可以在推送之前进行本地代码的临时部署。对于风险最大的变更，我们担心多个特性标记可能会交互不良，或者想要 110%确定新引入的代码块被标记掉，我们将在本地构建，并在推送之前进行测试。**

**在另一个工作场所，我们有每一个主触发器部署到一个阶段环境，然后是一系列的“冒烟测试”以确保系统基本上正常运行。对于我们相当有信心的变更，我们可以推进到 master，然后在“staging”上测试。我们还对所有服务进行了分类，并设置了 CI 渠道，以便用分支机构名称标记分类图像。我们可以将 docker 服务的任意标签部署到个人测试环境中。尽管不鼓励特性分支，但我们确实保留了使用短命分支来测试我们自己环境中潜在的危险变化的选项，然后再推进到 master。**

**测试基于分支的图像是个好主意吗？这无疑给了我们额外的舒适和自信的选择。或许投资于自动化测试，依靠“阶段化”作为质量关口，并尝试建立一种“推进但如果阶段化失败就恢复”的文化会更好？**

**我不确定…但是我可以自信地说，一个合适的测试策略需要成为任何采用或促进基于主干开发的计划的一部分。**

# **最后**

*   **添加是安全的，删除是不安全的。**
*   **大任务可以分解成小任务。**
*   **小任务可以分成一系列的添加，然后删除。**
*   **可以明智地插入特征标志，以迫使逻辑沿着“旧的”路径流动，同时增加额外的东西。**

**这听起来相当复杂。毕竟，这是一篇很长的文章。更长，如果你包括我采取了短路，只是链接到别人的帖子的位。如果你还在问“为什么不直接分支？”这是一个合理的问题。特别是如果你已经“很好地”处理了一个分支模型。**

**让我们回到开始时提出的三点。基于主干的开发:**

1.  **保持您的代码持续集成，降低风险并改进“编码、测试、部署”反馈循环。**
2.  **提高您推理向后和向前兼容性的能力，从而产生更安全、更健壮的代码库。**
3.  **让您考虑引入特性标志，它将部署从发布中分离出来，并将您的公司从围绕部署日期的一切计划中解放出来。**

**它需要实践和承诺，并且绝对改变你解决工程问题和编写代码的方式。变得更好。**