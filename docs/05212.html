<html>
<head>
<title>How to Make Singletons Testable</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何使单例可测试</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/making-singletons-testable-b3d2176cf165?source=collection_archive---------7-----------------------#2020-06-20">https://betterprogramming.pub/making-singletons-testable-b3d2176cf165?source=collection_archive---------7-----------------------#2020-06-20</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="f85a" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">可测试代码是更好的代码</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi kf"><img src="../Images/ce643be564dc9325f49da787ccdfc697.png" data-original-src="https://miro.medium.com/v2/resize:fit:1280/format:webp/1*XZEVANMxAx6ttqqCS6FHdg.png"/></div><p class="kn ko gj gh gi kp kq bd b be z dk translated">图片出自<a class="ae kr" href="https://refactoring.guru/" rel="noopener ugc nofollow" target="_blank">重构大师</a></p></figure><p id="d3e1" class="pw-post-body-paragraph ks kt iq ku b kv kw jr kx ky kz ju la lb lc ld le lf lg lh li lj lk ll lm ln ij bi translated">因此，单例模式是一种广为人知的模式，但是当涉及到测试它时，我们真的很讨厌它，对吗？</p><p id="60e8" class="pw-post-body-paragraph ks kt iq ku b kv kw jr kx ky kz ju la lb lc ld le lf lg lh li lj lk ll lm ln ij bi translated">我在上一篇文章中试图减少这种仇恨:</p><div class="lo lp gp gr lq lr"><a href="https://medium.com/better-programming/should-we-really-hate-singletons-c75d1fe07111" rel="noopener follow" target="_blank"><div class="ls ab fo"><div class="lt ab lu cl cj lv"><h2 class="bd ir gy z fp lw fr fs lx fu fw ip bi translated">我们真的应该讨厌单身族吗？</h2><div class="ly l"><h3 class="bd b gy z fp lw fr fs lx fu fw dk translated">单身者受到很多讨厌，但这是合理的吗？</h3></div><div class="lz l"><p class="bd b dl z fp lw fr fs lx fu fw dk translated">medium.com</p></div></div><div class="ma l"><div class="mb l mc md me ma mf kl lr"/></div></div></a></div></div><div class="ab cl mg mh hu mi" role="separator"><span class="mj bw bk mk ml mm"/><span class="mj bw bk mk ml mm"/><span class="mj bw bk mk ml"/></div><div class="ij ik il im in"><h1 id="02e2" class="mn mo iq bd mp mq mr ms mt mu mv mw mx jw my jx mz jz na ka nb kc nc kd nd ne bi translated">概述</h1><p id="a00e" class="pw-post-body-paragraph ks kt iq ku b kv nf jr kx ky ng ju la lb nh ld le lf ni lh li lj nj ll lm ln ij bi translated">为了向您简要介绍用例以及我在上一篇文章中所做的事情，让我们倒回去一点(看，现在的作家都有时间机器)。</p><p id="d60f" class="pw-post-body-paragraph ks kt iq ku b kv kw jr kx ky kz ju la lb lc ld le lf lg lh li lj lk ll lm ln ij bi translated">所以我们创建了一个名为<code class="fe nk nl nm nn b">WidgetPersistenceManager</code>的类来跟踪所有的onboarding小部件。它也给了我们一些功能来跟踪它上面的交互——以及告诉我们它是否可以显示的功能。很简单。</p><p id="e5e4" class="pw-post-body-paragraph ks kt iq ku b kv kw jr kx ky kz ju la lb lc ld le lf lg lh li lj lk ll lm ln ij bi translated">我们使用了<em class="no">抽象</em>和<em class="no">依赖注入(DI) </em>的概念来使我们的代码松散耦合和可注入，因此当测试时间到来时，我们已经做好了准备。</p><p id="2441" class="pw-post-body-paragraph ks kt iq ku b kv kw jr kx ky kz ju la lb lc ld le lf lg lh li lj lk ll lm ln ij bi translated">我强烈建议你浏览一遍上面的<a class="ae kr" href="https://medium.com/better-programming/should-we-really-hate-singletons-c75d1fe07111" rel="noopener">文章</a>，但是为了方便起见，我把代码的快照放在这里。</p><ol class=""><li id="0a96" class="np nq iq ku b kv kw ky kz lb nr lf ns lj nt ln nu nv nw nx bi translated"><code class="fe nk nl nm nn b"><strong class="ku ir">Widget</strong></code>:这是一个定义了widget需求的协议。</li></ol><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="nz oa di ob bf oc"><div class="gh gi ny"><img src="../Images/08520e1eb17d3b9c9de64d4dd70ce177.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*jOu4vjwVirWxvrPQlbLACQ.png"/></div></div></figure><p id="4cf0" class="pw-post-body-paragraph ks kt iq ku b kv kw jr kx ky kz ju la lb lc ld le lf lg lh li lj lk ll lm ln ij bi translated">2.<code class="fe nk nl nm nn b"><strong class="ku ir">WidgetPersistenceManageable</strong></code>:规定了对管理者的要求。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="nz oa di ob bf oc"><div class="gh gi od"><img src="../Images/b11c05c99068ae04a9693b2134b6dfec.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*l7YJyc27_emxrtyWy5NSnQ.png"/></div></div></figure><p id="dbc6" class="pw-post-body-paragraph ks kt iq ku b kv kw jr kx ky kz ju la lb lc ld le lf lg lh li lj lk ll lm ln ij bi translated">3.<code class="fe nk nl nm nn b"><strong class="ku ir">PersistentEntity</strong></code>:持久化小部件的计数和交互的实体。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="nz oa di ob bf oc"><div class="gh gi oe"><img src="../Images/91fe8c3e58eb57fbf532bcfdaa9635d8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*RSL7Gc-R7txtQJyJ-aJDAw.png"/></div></div></figure><p id="5e3a" class="pw-post-body-paragraph ks kt iq ku b kv kw jr kx ky kz ju la lb lc ld le lf lg lh li lj lk ll lm ln ij bi translated">4.<strong class="ku ir">具体化</strong>:以上的具体实现。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="nz oa di ob bf oc"><div class="gh gi of"><img src="../Images/0edd66a5eba5337cb7c4a56e0ee4c179.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*zeolhmsGXa1XB2OVtQ1y8w.png"/></div></div></figure><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="nz oa di ob bf oc"><div class="gh gi og"><img src="../Images/04aacb7f727b055bc029174fecbcf465.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*j5fXsipCLGC7RRoVWC4HYA.png"/></div></div></figure></div><div class="ab cl mg mh hu mi" role="separator"><span class="mj bw bk mk ml mm"/><span class="mj bw bk mk ml mm"/><span class="mj bw bk mk ml"/></div><div class="ij ik il im in"><h1 id="b0ca" class="mn mo iq bd mp mq mr ms mt mu mv mw mx jw my jx mz jz na ka nb kc nc kd nd ne bi translated">测试:</h1><p id="7d79" class="pw-post-body-paragraph ks kt iq ku b kv nf jr kx ky ng ju la lb nh ld le lf ni lh li lj nj ll lm ln ij bi translated">如果我们敏锐地看到，我们的经理需要小部件来执行某些事情，而某些事情的逻辑也绑定到小部件本身。</p><p id="46fb" class="pw-post-body-paragraph ks kt iq ku b kv kw jr kx ky kz ju la lb lc ld le lf lg lh li lj lk ll lm ln ij bi translated">因此，如果我们需要测试它，我们需要在我们的世界中有一个模拟部件。所以让我们创建一个。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="oh oi l"/></div></figure><p id="e77e" class="pw-post-body-paragraph ks kt iq ku b kv kw jr kx ky kz ju la lb lc ld le lf lg lh li lj lk ll lm ln ij bi translated">所以我们的模拟小部件只是嵌入了一些<code class="fe nk nl nm nn b">maxValue</code>和一些逻辑，就像真正的小部件一样。</p><p id="aa04" class="pw-post-body-paragraph ks kt iq ku b kv kw jr kx ky kz ju la lb lc ld le lf lg lh li lj lk ll lm ln ij bi translated">下面是我们在实际代码中如何使用小部件:我们初始化了小部件管理器，并在其中实例化了一个<code class="fe nk nl nm nn b">Chevron</code>小部件。简单。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="oh oi l"/></div></figure><p id="0e7d" class="pw-post-body-paragraph ks kt iq ku b kv kw jr kx ky kz ju la lb lc ld le lf lg lh li lj lk ll lm ln ij bi translated">现在我们在测试中会做什么？我们只需将<code class="fe nk nl nm nn b">Chevron</code> <strong class="ku ir"> </strong>小部件改为我们的<code class="fe nk nl nm nn b">MockWidget</code> <strong class="ku ir"> </strong>(记住:抽象的力量)。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="oh oi l"/></div></figure><p id="90d3" class="pw-post-body-paragraph ks kt iq ku b kv kw jr kx ky kz ju la lb lc ld le lf lg lh li lj lk ll lm ln ij bi translated">还有哒哒！我们测试了我们的独生子。但你会说，“所有的辛苦工作就为了这个？”但是没有…我们还有我们的节目主持人。继续前进！</p><p id="e520" class="pw-post-body-paragraph ks kt iq ku b kv kw jr kx ky kz ju la lb lc ld le lf lg lh li lj lk ll lm ln ij bi translated">谈到测试，有两件事很重要:</p><ul class=""><li id="052b" class="np nq iq ku b kv kw ky kz lb nr lf ns lj nt ln oj nv nw nx bi translated">我们的主题应该是可测试的。</li><li id="2636" class="np nq iq ku b kv ok ky ol lb om lf on lj oo ln oj nv nw nx bi translated">我们的主题应该是可以模仿的。</li></ul><p id="24a8" class="pw-post-body-paragraph ks kt iq ku b kv kw jr kx ky kz ju la lb lc ld le lf lg lh li lj lk ll lm ln ij bi translated">你已经很好地理解了第一点，因为这就是我们在本教程中所做的，但是说实话，第二点更有价值。为什么？</p><p id="ce31" class="pw-post-body-paragraph ks kt iq ku b kv kw jr kx ky kz ju la lb lc ld le lf lg lh li lj lk ll lm ln ij bi translated">这是因为测试不仅仅是让一个类或一个主题可测试，而是让整个代码可测试。我们的类只有在被其他学科使用时才有用，对吗？因此，即使我们的类是可测试的，我们也需要确保我们可以创建一个它的模拟，这样它就可以在测试一个更大的主题时使用。</p><p id="da0f" class="pw-post-body-paragraph ks kt iq ku b kv kw jr kx ky kz ju la lb lc ld le lf lg lh li lj lk ll lm ln ij bi translated">例如，我们制作了这个<code class="fe nk nl nm nn b">WidgetPersistenceManager</code>，<strong class="ku ir"> </strong>，但是它并不重要，除非其他实体——比如我们的例子中的<code class="fe nk nl nm nn b">Presenter</code>——使用它来显示和管理小部件。</p><p id="175a" class="pw-post-body-paragraph ks kt iq ku b kv kw jr kx ky kz ju la lb lc ld le lf lg lh li lj lk ll lm ln ij bi translated">为经理创建模拟的时间:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="oh oi l"/></div></figure><p id="a312" class="pw-post-body-paragraph ks kt iq ku b kv kw jr kx ky kz ju la lb lc ld le lf lg lh li lj lk ll lm ln ij bi translated">这里我们有所有的函数，里面有一些模拟代码。就像当我们调用<code class="fe nk nl nm nn b">canShowWidgetFor(rawValue: String)</code>时，我们简单地创建一个模拟部件并将<code class="fe nk nl nm nn b">invokedCanShowWidgetFor</code>设置为<code class="fe nk nl nm nn b">true</code>。这会告诉我们我们的函数被调用了。</p><p id="3846" class="pw-post-body-paragraph ks kt iq ku b kv kw jr kx ky kz ju la lb lc ld le lf lg lh li lj lk ll lm ln ij bi translated">最后，小部件调用它的逻辑<code class="fe nk nl nm nn b">canShowWidget()</code>，它再次调用模拟小部件的功能。所以我们实现了完全的抽象。我们没有触及<code class="fe nk nl nm nn b">WidgetPersistenceManager</code>的任何功能，但仍然能够通过模拟实现相同的功能。因此，我们可以用这个来分别测试我们的主对象(<code class="fe nk nl nm nn b">Presenter</code>)。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="oh oi l"/></div></figure><p id="b62c" class="pw-post-body-paragraph ks kt iq ku b kv kw jr kx ky kz ju la lb lc ld le lf lg lh li lj lk ll lm ln ij bi translated">如果你还记得，在上一篇文章中，我想制作<code class="fe nk nl nm nn b">Chevron</code>的动画。这是它的测试类。在这个用于测试<code class="fe nk nl nm nn b">Presenter</code>的类中，我们基本上注入了一个模拟小部件管理器作为<code class="fe nk nl nm nn b">Presenter</code>的依赖项。我们能够在模拟小部件管理器的帮助下测试<code class="fe nk nl nm nn b">Presenter</code>的功能。</p><p id="b106" class="pw-post-body-paragraph ks kt iq ku b kv kw jr kx ky kz ju la lb lc ld le lf lg lh li lj lk ll lm ln ij bi translated">这就是我们如何使我们的代码完全可测试的，即使是在使用单例的时候。</p></div><div class="ab cl mg mh hu mi" role="separator"><span class="mj bw bk mk ml mm"/><span class="mj bw bk mk ml mm"/><span class="mj bw bk mk ml"/></div><div class="ij ik il im in"><h1 id="8780" class="mn mo iq bd mp mq mr ms mt mu mv mw mx jw my jx mz jz na ka nb kc nc kd nd ne bi translated">结论</h1><p id="b50e" class="pw-post-body-paragraph ks kt iq ku b kv nf jr kx ky ng ju la lb nh ld le lf ni lh li lj nj ll lm ln ij bi translated">所以这里我们到达文章的结尾。我们学习了如何测试我们的单例，更重要的是，如何模拟它们，以实现使用我们的单例的更大类的完全可测试性。</p><p id="3830" class="pw-post-body-paragraph ks kt iq ku b kv kw jr kx ky kz ju la lb lc ld le lf lg lh li lj lk ll lm ln ij bi translated">这篇文章是我之前写的<a class="ae kr" href="https://medium.com/better-programming/should-we-really-hate-singletons-c75d1fe07111" rel="noopener">文章</a>的延续，以一种同样可以测试的方式帮助设计一个单例。我真的希望你能从这篇文章中学到一些新东西。我想引用阿尔伯特·爱因斯坦先生的一句名言来结束我的发言:</p><blockquote class="op oq or"><p id="6268" class="ks kt no ku b kv kw jr kx ky kz ju la os lc ld le ot lg lh li ou lk ll lm ln ij bi translated">“我学得越多，就越意识到自己有多少不知道。”</p></blockquote></div></div>    
</body>
</html>