<html>
<head>
<title>Infinite Scroll With React Hooks</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">带反应钩的无限卷轴</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/infinite-scroll-with-react-hooks-and-context-api-b622b4f9c43f?source=collection_archive---------1-----------------------#2019-07-08">https://betterprogramming.pub/infinite-scroll-with-react-hooks-and-context-api-b622b4f9c43f?source=collection_archive---------1-----------------------#2019-07-08</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/76b79982dafbcc6e4c1c0bde33a332d5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*bEPEZM_fqftW6RK7hZWrAA.jpeg"/></div></div></figure><p id="cc37" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">无限列表(<em class="kw">滚动</em>)功能已经存在一段时间了。这是增强应用程序UX的好方法。</p><p id="348b" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">有许多第三方库可用，但是如果你像我一样喜欢挑战自己，我们将在这篇文章中使用钩子从头开始探索实现。</p><p id="cb7a" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">让我们快速编写一个简单的应用程序组件。我们初始化一个空状态，并将对<code class="fe kx ky kz la b">state</code>和<code class="fe kx ky kz la b">setState</code>的引用传递给我们的<code class="fe kx ky kz la b">InfiniteList</code>组件。</p><figure class="lb lc ld le gt jr"><div class="bz fp l di"><div class="lf lg l"/></div></figure><p id="d906" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><code class="fe kx ky kz la b">InfiniteList</code>组件将返回从<a class="ae lh" href="https://dog.ceo/dog-api/" rel="noopener ugc nofollow" target="_blank">狗API </a>获取的狗图像的无序列表。</p><p id="0a88" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">一旦我们的请求成功，我们就将图像推送到父代的状态。我们将确保不覆盖先前的状态，因为我们将多次使用<code class="fe kx ky kz la b">getData()</code>函数来获取更多的图像。所以，点点点点<code class="fe kx ky kz la b">. . .</code></p><figure class="lb lc ld le gt jr"><div class="bz fp l di"><div class="lf lg l"/></div></figure><p id="3091" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">到目前为止，这显示了前15幅图像。</p><p id="397e" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">现在我们需要在用户向下滚动到视窗的最底部时监听事件，并获取更多图像，再次调用<code class="fe kx ky kz la b">getData()</code>。</p><p id="3ad0" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">但是我们如何确定底部范围呢？我希望这张图片能帮助你理解。</p><figure class="lb lc ld le gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi li"><img src="../Images/2d799641f8c0da93a332b7f4710d9262.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ALYAG-AdW5PRE7Et8qtcpA.jpeg"/></div></div></figure><ol class=""><li id="e7db" class="lj lk iq ka b kb kc kf kg kj ll kn lm kr ln kv lo lp lq lr bi translated"><code class="fe kx ky kz la b">window.innerHeight<strong class="ka ir"> </strong></code> —静态，用户浏览器窗口的高度。</li><li id="04e0" class="lj lk iq ka b kb ls kf lt kj lu kn lv kr lw kv lo lp lq lr bi translated"><code class="fe kx ky kz la b">window.scrollY</code> —动态属性，当前滚动位置。</li><li id="e434" class="lj lk iq ka b kb ls kf lt kj lu kn lv kr lw kv lo lp lq lr bi translated"><code class="fe kx ky kz la b">list.clientHeight </code> —静态，容器的高度(<code class="fe kx ky kz la b">ul</code>元素)。</li><li id="635a" class="lj lk iq ka b kb ls kf lt kj lu kn lv kr lw kv lo lp lq lr bi translated"><code class="fe kx ky kz la b">list.offsetTop</code> —从页面顶部开始的容器缩进(如果有)，静态。</li></ol><p id="c419" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">好的，如果1+2===3+4，我们知道一个用户在页面的底部，我们需要获取。</p><p id="1c31" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">但是如果我们希望<code class="fe kx ky kz la b">ul</code>是一个固定的高度呢？我们需要获得ul的属性:</p><ol class=""><li id="b7b5" class="lj lk iq ka b kb kc kf kg kj ll kn lm kr ln kv lo lp lq lr bi translated"><code class="fe kx ky kz la b">element.scrollHeight </code> —静态值，可滚动的总高度。</li><li id="bbda" class="lj lk iq ka b kb ls kf lt kj lu kn lv kr lw kv lo lp lq lr bi translated"><code class="fe kx ky kz la b">element.scrollTop</code> <strong class="ka ir"> </strong> —动态值，当前滚动顶端位置。</li><li id="f626" class="lj lk iq ka b kb ls kf lt kj lu kn lv kr lw kv lo lp lq lr bi translated"><code class="fe kx ky kz la b">element.clientHeight</code> —静态值，元素的当前高度(不包括溢出)。</li></ol><p id="9372" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">因此，1===2+3将表示用户已经到达容器的底部。现在我们可以通过设置<code class="fe kx ky kz la b">scrollable</code>属性有条件地告诉组件它是否是固定高度的。</p><p id="6252" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">让我们把这些都放到新的<code class="fe kx ky kz la b">useEffect</code>钩子里。</p><p id="30b8" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">还有最后一个解决办法。让我们初始化一个状态，然后，一旦满足上面的条件，我们切换状态，通过使我们的第一个钩子依赖于状态的值，给它一个获取更多的信号。</p><pre class="lb lc ld le gt lx la ly lz aw ma bi"><span id="ff1e" class="mb mc iq la b gy md me l mf mg">const [loadMore, setLoadMore] = useState(false);</span><span id="bd1e" class="mb mc iq la b gy mh me l mf mg">useEffect(() =&gt; {<br/>  setLoadMore(false);<br/>  getData();<br/>}, [loadMore]);</span></pre><p id="b194" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我们还可以在等待API响应时，有条件地在底部呈现一个loading spinner，方法是用某个真值初始化一个新状态，然后在请求完成后重置它。</p><p id="90d9" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">此外，为了避免潜在的错误，我们可以在组件卸载时从窗口对象中移除事件监听器，方法是在<code class="fe kx ky kz la b">useEffect</code>中添加一个返回语句，如下所示:</p><figure class="lb lc ld le gt jr"><div class="bz fp l di"><div class="lf lg l"/></div></figure></div><div class="ab cl mi mj hu mk" role="separator"><span class="ml bw bk mm mn mo"/><span class="ml bw bk mm mn mo"/><span class="ml bw bk mm mn"/></div><div class="ij ik il im in"><h1 id="b99c" class="mp mc iq bd mq mr ms mt mu mv mw mx my mz na nb nc nd ne nf ng nh ni nj nk nl bi translated">资源</h1><p id="0552" class="pw-post-body-paragraph jy jz iq ka b kb nm kd ke kf nn kh ki kj no kl km kn np kp kq kr nq kt ku kv ij bi translated"><a class="ae lh" href="https://infinite-scroll.olegakan5326.now.sh" rel="noopener ugc nofollow" target="_blank">现场演示</a> | <a class="ae lh" href="https://github.com/aleckan53/infinite-scroll" rel="noopener ugc nofollow" target="_blank">回购</a></p><p id="56f8" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">感谢您的阅读和快乐编码！</p></div></div>    
</body>
</html>