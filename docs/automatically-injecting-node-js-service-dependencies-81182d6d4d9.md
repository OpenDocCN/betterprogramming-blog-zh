# 自动注入 Node.js 服务依赖项

> 原文：<https://betterprogramming.pub/automatically-injecting-node-js-service-dependencies-81182d6d4d9>

## 管理服务依赖关系的更好方法

![](img/7aaf60f5ac36aa5cf1d4e509fd8f3fcd.png)

照片由[沙哈达特·拉赫曼](https://unsplash.com/@hishahadat?utm_source=medium&utm_medium=referral)在 [Unsplash](https://unsplash.com?utm_source=medium&utm_medium=referral) 拍摄

我想分享我最近在 Node.js 项目中使用的一种方法。它帮助我以更好的方式管理服务依赖。

我发现，将依赖注入模式和函数式编程的某些方面结合起来，可以获得更易测试、可读性更好、无重复的代码库。

首先，让我们看看在我们的服务中处理依赖性的传统方式。

# `**Require**` **模块直接服务**

声明服务依赖关系的一种常见方法是直接在服务文件中`require`它们。这个简单的例子包含一个服务，它负责将用户保存到数据库中，然后发送一封电子邮件通知它的创建:

在这里，我们需要直接在服务文件中的依赖关系。我个人不喜欢这种方法，原因有二:

*   这有点难以测试，因为我们必须使用像`[proxyquery](https://www.npmjs.com/package/proxyquire)`这样的包来覆盖依赖关系。
*   它可能需要不会在服务的所有功能上使用的依赖项。在理想的情况下，我们应该只导入将在所有函数中使用的依赖项，但有时这是不可能的。

测试这个方法应该是这样的:

如果我们可以通过将依赖项直接注入到函数中来避免覆盖它们，会怎么样呢？

# 注入依赖关系

下面是相同服务的一个示例，但是需要文件顶部的依赖项，我们将做一点更改，以参数形式接收它们:

在这种方法中，函数的依赖项是通过参数传递的。从测试的角度来看，我们可以看到上一种方法的改进。测试这个方法变得容易多了，因为我们不需要一些包来覆盖直接需要的依赖项。我们可以手动模拟我们的依赖关系，或者使用像 [sinon](https://sinonjs.org/) 这样的包来为我们做繁重的工作。另一个优点是，我们只需查看函数声明就可以知道它的所有依赖项。

用我们的新方法测试方法:

这种方法的一个问题是，每次我们调用函数`createUser`时，我们都需要依赖关系来这样做。如果模块经常被其他服务使用，这可能会导致我们的代码库出现大量重复。

如果我们有一个接受服务并自动为我们解决所有依赖关系以避免这种“需要重复”的注射器工具，那不是很好吗？

# 功能 DI 喷射器

在我向您介绍函数 DI Injector 之前，让我们仔细看看我们的`createUser`函数正在接收哪些参数:

```
const createUser = (userRepository, emailService, user) …
```

查看参数，我们可以看到函数依赖项作为第一个参数被传递。通常，我们总是传递相同的实现，不管我们在哪里调用这个函数(除了在测试文件上)。每次我们调用这个函数时，唯一会改变的参数是`user`参数，对吗？每次我们调用这个函数时，都会创建一个新用户，但是依赖关系(`userRepository`、`emailService`)总是有相同的实现。

也就是说，让我们用“元数据”来分离不经常改变的依赖关系，元数据在函数调用之间总是不同的。

我们将`createUser`函数转化为[部分函数应用](https://en.wikipedia.org/wiki/Partial_application)。基本上，我们可以调用`createuser` 函数，首先传递依赖项，这将返回另一个函数，只需要`user` 参数。通过这一改变，我可以向您介绍 DI 喷油器的功能:

> “部分应用(或部分函数应用)是指将一些参数固定到一个函数上，产生另一个具有更少参数的函数的过程。”
> 
> *—维基百科*

乍一看，这可能很复杂，但是`injectFunctionDependencies` 函数将接收一个服务对象和一个函数名，并自动解析它的依赖关系。

让我们讨论一下每段代码的作用。

这里我们集中了解决依赖关系的方法。DependencyInjector 允许我们通过调用`injectUserRepository` 和`injectEmailService` *来注入`userRepository` 和`emailService` 。每次我们调用其中的一些函数，结果将是另一个具有更少参数的函数，从而减少每次调用中剩余的参数数量。我们称这种技术为 currying，这是函数式编程领域的另一个概念。*

> Currying 是一种技术，它将一个接受多个参数的函数转换成一系列接受单个参数的函数
> 
> — *维基百科*

当我们注入完依赖项后，我们调用`getFun`，它将返回原始函数及其所有已解析的依赖项。

这部分代码不言自明。基本上，它得到一个函数的所有参数名。这里很清楚为什么我们改变了原来的`createUser` 函数，只接收它的第一次调用的依赖关系:

```
const createUser = (userRepository, emailService) => user => ....
```

通过这样做，这个函数`getParamNames` 将返回所有依赖项的名称——在本例中是`userRepository` 和`emailService`，对吗？有了所有依赖项的名称，我们现在可以创建一个映射来描述每个依赖项是如何被解析的。这就是我们到达注射器服务的最后一步:

在这里，我们基本上是在告诉依赖关系应该如何解决。`servicesInjectors`映射将使用依赖项的名称作为键，这是我们从`getParamNames`函数和将依赖项本身解析为值的函数中得知的。

为了让这个方法工作，我们的依赖项名称应该与`servicesInjector`映射键相匹配，这没什么大不了的，也有助于我们通过代码库保持某种依赖项的默认命名约定。返回的对象将由服务的所有原始函数加上我们在`funcName` 参数中指定的函数组成，所有的依赖关系都已解析。

让我们看看最后的结果是什么样的:

就是这样！不再需要依赖关系，只需要传递服务和函数名，就可以解决依赖关系。现在,`createUser`函数将需要每次调用都会改变的唯一参数——用户本身。

今天就到这里吧——我希望这篇文章对你有所帮助。

保重，编码愉快！

这里的源代码是。