<html>
<head>
<title>Are You Confused by These Python Functions?</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">你被这些Python函数搞糊涂了吗？</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/are-you-confused-by-these-python-functions-8e9e7f3d7605?source=collection_archive---------8-----------------------#2020-09-10">https://betterprogramming.pub/are-you-confused-by-these-python-functions-8e9e7f3d7605?source=collection_archive---------8-----------------------#2020-09-10</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="48e3" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">排序对排序，反转对反转。理解它们的细微差别以避免意想不到的结果</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/951b517e71c7bd9deef4e949c24b2b08.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*0U6YaPPoe86Bj5oo"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">照片由<a class="ae ky" href="https://unsplash.com/@picoftasty?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">梅姆</a>在<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</p></figure><p id="7746" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">人们常说，编程中最困难的事情之一是给变量命名，这也包括函数。当一些函数执行相似的工作时，自然应该有相似的名字，难免会给初学者带来一些困惑。在本文中，我想回顾一下名称相似但工作方式不同的函数。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="cea8" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">1.sorted()与sort()</h1><p id="6c55" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">这两个函数都可以用来对列表对象进行排序。然而，<code class="fe mz na nb nc b">sorted()</code>函数是一个内置函数，可以处理任何iterable。<code class="fe mz na nb nc b">sort()</code>函数实际上是list的方法，这意味着它只能用于list对象。它们也有不同的语法。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nd ne l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">sorted()与sort()</p></figure><ul class=""><li id="ebee" class="nf ng it lb b lc ld lf lg li nh lm ni lq nj lu nk nl nm nn bi translated">两个函数都有参数<code class="fe mz na nb nc b">reverse</code>和<code class="fe mz na nb nc b">key</code>。<code class="fe mz na nb nc b">reverse</code>参数用于请求逆序排序，而<code class="fe mz na nb nc b">key</code>参数用于指定超出默认顺序的排序算法。它可以设置为lambda函数或常规函数。</li><li id="9fc7" class="nf ng it lb b lc no lf np li nq lm nr lq ns lu nk nl nm nn bi translated"><code class="fe mz na nb nc b">sorted()</code>函数可以处理任何iterable。对于字典(第4行)，字典对象的iterable是键，因此<code class="fe mz na nb nc b">sorted()</code>函数返回键的列表对象。</li><li id="0110" class="nf ng it lb b lc no lf np li nq lm nr lq ns lu nk nl nm nn bi translated">以类似的方式，当您将一个字符串传递给<code class="fe mz na nb nc b">sorted()</code>函数时，它将返回一个字符列表，因为字符串被视为由单个字符组成的iterable。</li><li id="1748" class="nf ng it lb b lc no lf np li nq lm nr lq ns lu nk nl nm nn bi translated"><code class="fe mz na nb nc b">sorted()</code>函数返回一个排序后的列表对象，而<code class="fe mz na nb nc b">sort()</code>函数不返回任何内容(确切地说，是返回<code class="fe mz na nb nc b">None</code>)。换句话说，调用<code class="fe mz na nb nc b">sort()</code>函数的列表对象将被就地排序。</li></ul></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="8930" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">2.反转()与反转()</h1><p id="b733" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">这两者的使用场景类似于<code class="fe mz na nb nc b">sorted()</code> vs. <code class="fe mz na nb nc b">sort()</code>。<code class="fe mz na nb nc b">reversed()</code>函数可以处理任何序列数据，比如列表和字符串，而<code class="fe mz na nb nc b">reverse()</code>函数是列表的方法。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nd ne l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">反转()与反转()</p></figure><ul class=""><li id="cd57" class="nf ng it lb b lc ld lf lg li nh lm ni lq nj lu nk nl nm nn bi translated">与返回列表的<code class="fe mz na nb nc b">sorted()</code>函数不同，<code class="fe mz na nb nc b">reversed()</code>函数返回一个反向迭代器，它本质上是一个可迭代的，但可以直接在<code class="fe mz na nb nc b">for</code>循环中使用。</li><li id="cb6f" class="nf ng it lb b lc no lf np li nq lm nr lq ns lu nk nl nm nn bi translated">要构造一个列表或元组，可以利用返回的迭代器以与原始顺序相反的顺序构造一个序列数据。</li><li id="bfc2" class="nf ng it lb b lc no lf np li nq lm nr lq ns lu nk nl nm nn bi translated">与列表中的<code class="fe mz na nb nc b">sort()</code>方法一样，<code class="fe mz na nb nc b">reverse()</code>方法是颠倒列表元素的顺序，因此它返回<code class="fe mz na nb nc b">None</code>。</li></ul></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="1270" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">3.append()与extend()</h1><p id="4001" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">这两个函数都是列表对象的方法。两者都用于向现有列表对象添加项目。下面的代码向您展示了如何使用它们，后面还有一些解释。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nd ne l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">append()与extend()</p></figure><ul class=""><li id="7599" class="nf ng it lb b lc ld lf lg li nh lm ni lq nj lu nk nl nm nn bi translated">这两个函数就地修改列表对象并返回<code class="fe mz na nb nc b">None</code>。</li><li id="3c82" class="nf ng it lb b lc no lf np li nq lm nr lq ns lu nk nl nm nn bi translated"><code class="fe mz na nb nc b">append()</code>功能是在列表末尾添加一个条目。如果要将一个项目添加到特定位置，应该使用<code class="fe mz na nb nc b">insert()</code>方法。</li><li id="ffce" class="nf ng it lb b lc no lf np li nq lm nr lq ns lu nk nl nm nn bi translated"><code class="fe mz na nb nc b">extend()</code>功能是将iterable中的所有元素追加到list对象的末尾。在字符串的情况下(第12行)，字符被追加。对于set对象，您会注意到插入元素的顺序并不反映我们用来创建set对象的项目，这是保存无序项目的set对象的预期行为。</li></ul></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="30b4" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">4.is vs. ==</h1><p id="be8c" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">这两个函数都用于比较对象。然而，它们有一些细微的差别，你应该知道。我们将<code class="fe mz na nb nc b">is</code>称为<em class="nt">同一性比较</em>，将<code class="fe mz na nb nc b">==</code>称为<em class="nt">值相等比较</em>。需要注意的一点是，当我们说一个对象的身份时，我们可以简单地用<code class="fe mz na nb nc b">id()</code>函数引用一个特定对象的内存地址。让我们看一些例子。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nd ne l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">is vs. ==</p></figure><ul class=""><li id="252b" class="nf ng it lb b lc ld lf lg li nh lm ni lq nj lu nk nl nm nn bi translated">当对象具有相同的内存地址时，它们就是相同的对象，具有相同的标识和值。因此，<code class="fe mz na nb nc b">is</code>和<code class="fe mz na nb nc b">==</code>产生相同的布尔值。</li><li id="f3bf" class="nf ng it lb b lc no lf np li nq lm nr lq ns lu nk nl nm nn bi translated">在大多数情况下，即使对象可以有相同的值，但它们可以是内存中不同的对象。</li><li id="189a" class="nf ng it lb b lc no lf np li nq lm nr lq ns lu nk nl nm nn bi translated">一些特殊的对象，比如<code class="fe mz na nb nc b">None</code>和小整数(比如1，2)总是有相同的身份，因为它们用得太多了，而且在Python加载时就已经被实例化了。我们在不同的模块之间共享这些对象。</li><li id="fd96" class="nf ng it lb b lc no lf np li nq lm nr lq ns lu nk nl nm nn bi translated">在大多数情况下，我们使用<code class="fe mz na nb nc b">==</code>来比较对象，因为我们最感兴趣的是使用对象的值。然而，当我们检查一个对象是否是<code class="fe mz na nb nc b">None</code>时，我们更喜欢使用<code class="fe mz na nb nc b">is</code>(即<code class="fe mz na nb nc b">if obj is None</code>)。</li></ul></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="6514" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">5.移除()，弹出()与清除()</h1><p id="676f" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">这三个函数都是list对象的方法，比较混乱。先看它们的用法，接下来再讨论它们的细微差别。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nd ne l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">移除()与弹出()与清除()</p></figure><ul class=""><li id="d44f" class="nf ng it lb b lc ld lf lg li nh lm ni lq nj lu nk nl nm nn bi translated">要删除特定项目，您可以在<code class="fe mz na nb nc b">remove()</code>功能中指定。但是要谨慎。如果要删除的项目不在列表中，您会遇到一个<code class="fe mz na nb nc b">ValueError</code>异常，如下所示。</li></ul><pre class="kj kk kl km gt nu nc nv nw aw nx bi"><span id="3640" class="ny md it nc b gy nz oa l ob oc">&gt;&gt;&gt; [1, 2, 3, 4].remove(5)<br/>Traceback (most recent call last):<br/>  File "&lt;input&gt;", line 1, in &lt;module&gt;<br/>ValueError: list.remove(x): x not in list</span></pre><ul class=""><li id="4902" class="nf ng it lb b lc ld lf lg li nh lm ni lq nj lu nk nl nm nn bi translated">默认情况下,<code class="fe mz na nb nc b">pop()</code>方法删除最后一项。如果您想删除特定索引处的元素，您可以在函数中指定它，如第14行所示。重要的是，这个方法将返回弹出的项，因此如果您想处理被移除的项，这个方法特别有用。需要注意的一点是，如果列表为空，这个方法将引发一个<code class="fe mz na nb nc b">IndexError</code>。</li></ul><pre class="kj kk kl km gt nu nc nv nw aw nx bi"><span id="32f5" class="ny md it nc b gy nz oa l ob oc">&gt;&gt;&gt; [].pop()<br/>Traceback (most recent call last):<br/>  File "&lt;input&gt;", line 1, in &lt;module&gt;<br/>IndexError: pop from empty list</span></pre><ul class=""><li id="a778" class="nf ng it lb b lc ld lf lg li nh lm ni lq nj lu nk nl nm nn bi translated"><code class="fe mz na nb nc b">clear()</code>方法是删除列表中的所有项目，这应该很简单。</li></ul></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="98e0" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">6.any()与all()</h1><p id="36e7" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">这两个函数都用于使用iterables检查条件。两个函数的返回值都是布尔值— <code class="fe mz na nb nc b">True</code>或<code class="fe mz na nb nc b">False</code>。下面的代码向您展示了一些用法。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nd ne l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">any()与all()</p></figure><ul class=""><li id="1279" class="nf ng it lb b lc ld lf lg li nh lm ni lq nj lu nk nl nm nn bi translated">当iterable中的任一项为<code class="fe mz na nb nc b">True</code>时，<code class="fe mz na nb nc b">any()</code>返回<code class="fe mz na nb nc b">True</code>。否则，返回<code class="fe mz na nb nc b">False</code>。</li><li id="0e21" class="nf ng it lb b lc no lf np li nq lm nr lq ns lu nk nl nm nn bi translated">只有当iterable中的所有项目都是<code class="fe mz na nb nc b">True</code>时，<code class="fe mz na nb nc b">all()</code>才会返回<code class="fe mz na nb nc b">True</code>。否则，返回<code class="fe mz na nb nc b">False</code>。</li><li id="abac" class="nf ng it lb b lc no lf np li nq lm nr lq ns lu nk nl nm nn bi translated">当iterable为空时，需要特别考虑。可以看到，<code class="fe mz na nb nc b">any()</code>返回<code class="fe mz na nb nc b">False</code>，而<code class="fe mz na nb nc b">all()</code>返回<code class="fe mz na nb nc b">True</code>。很多人对这种行为感到困惑。你可以这样记住:默认情况下，<code class="fe mz na nb nc b">any()</code>返回<code class="fe mz na nb nc b">False</code>。只有找到一个非<code class="fe mz na nb nc b">False</code>项，它才会立即返回<code class="fe mz na nb nc b">True</code>——一个短路评估。相比之下，<code class="fe mz na nb nc b">all()</code>默认返回<code class="fe mz na nb nc b">True</code>。只有当它找到一个非<code class="fe mz na nb nc b">True</code>项时，它才会立即返回<code class="fe mz na nb nc b">False</code>——同样是一个短路评估。</li></ul></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="b685" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">7.issuperset()与issubset()</h1><p id="de70" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">我们已经讨论了与列表相关的几种方法。就set对象而言，我发现令人困惑的一对方法是<code class="fe mz na nb nc b">issuperset()</code>和<code class="fe mz na nb nc b">issubset()</code>。让我们先用一些琐碎的例子来看看它们是如何工作的。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nd ne l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">issuperset()与issubset()</p></figure><ul class=""><li id="e4ec" class="nf ng it lb b lc ld lf lg li nh lm ni lq nj lu nk nl nm nn bi translated">这两种方法都用于检查两个set对象之间的关系。</li><li id="45e6" class="nf ng it lb b lc no lf np li nq lm nr lq ns lu nk nl nm nn bi translated">理解这些方法的关键区别在于，要根据输入参数检查方法的调用方。例如，<code class="fe mz na nb nc b">set0.issuperset(set1)</code>是检查<code class="fe mz na nb nc b">set0</code>是否是<code class="fe mz na nb nc b">set1</code>的超集。</li></ul></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="fe01" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">8.zip()与zip_longest()</h1><p id="e95d" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated"><code class="fe mz na nb nc b">zip()</code>函数是一个内置函数，用于创建一个可以在<code class="fe mz na nb nc b">for</code>循环中使用的zip对象。它接受多个iterables并创建一个生成器，每次生成一个tuple对象。每个元组对象由每个iterable中相应位置的元素组成。<code class="fe mz na nb nc b">zip_longest()</code>的工作方式类似，但也有一些不同。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nd ne l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">zip()与zip_longest()</p></figure><ul class=""><li id="cf7c" class="nf ng it lb b lc ld lf lg li nh lm ni lq nj lu nk nl nm nn bi translated">要创建zip对象的列表，您将在list构造函数方法中包含zip对象，如第6行所示。</li><li id="704d" class="nf ng it lb b lc no lf np li nq lm nr lq ns lu nk nl nm nn bi translated"><code class="fe mz na nb nc b">zip()</code>函数将创建与最短可迭代长度相匹配的元组。在我们的例子中，它只创建了三个元组，因为较短的列表(即<code class="fe mz na nb nc b">list0</code>)只有三个条目。</li><li id="8a67" class="nf ng it lb b lc no lf np li nq lm nr lq ns lu nk nl nm nn bi translated">相比之下，使用<code class="fe mz na nb nc b">zip_longest()</code>函数，创建的元组的数量将与最长的可重复项的长度相匹配。对于较短的可重复项，元组将使用<code class="fe mz na nb nc b">None</code>来代替。</li></ul></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="6eae" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">结论</h1><p id="b1fa" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">在本文中，我们回顾了八组功能相似的函数，这些函数可能会让一些Python初学者感到有些困惑。</p><p id="a597" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">感谢你阅读这篇文章。</p></div></div>    
</body>
</html>