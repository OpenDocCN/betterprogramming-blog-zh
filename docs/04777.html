<html>
<head>
<title>How to Use ‘UIViewRepresentable’ With SwiftUI</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何在SwiftUI中使用“UIViewRepresentable”</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/how-to-use-uiviewrepresentable-with-swiftui-7295bfec312b?source=collection_archive---------0-----------------------#2020-05-08">https://betterprogramming.pub/how-to-use-uiviewrepresentable-with-swiftui-7295bfec312b?source=collection_archive---------0-----------------------#2020-05-08</a></blockquote><div><div class="fc ii ij ik il im"/><div class="in io ip iq ir"><div class=""/><div class=""><h2 id="e56e" class="pw-subtitle-paragraph jr it iu bd b js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki dk translated">连接SwiftUI和ui kit——并理解协调器、生命周期方法和通用类型</h2></div><figure class="kk kl km kn gu ko gi gj paragraph-image"><div role="button" tabindex="0" class="kp kq di kr bf ks"><div class="gi gj kj"><img src="../Images/d17d67b03c2d9b729c9de602012d2452.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*zHaydn9vo0VmT-dK"/></div></div><p class="kv kw gk gi gj kx ky bd b be z dk translated">Radek Grzybowski 在<a class="ae kz" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的照片</p></figure><p id="ceb0" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">SwiftUI为我们在应用程序中构建用户界面的方式带来了范式转变，但它目前并不提供对所有UI控件的原生支持。现在，人们可能想知道如何将<code class="fe lw lx ly lz b">UIActivityIndicator</code>、<code class="fe lw lx ly lz b">MKMapView</code>、<code class="fe lw lx ly lz b">WKWebView</code>或<code class="fe lw lx ly lz b">UIPageControl</code>添加到他们基于SwiftUI的应用程序中。</p><p id="85cc" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">很高兴SwiftUI为我们提供了一个<code class="fe lw lx ly lz b">UIViewRepresentable</code>协议，允许我们包装UIKit视图并从SwiftUI视图中使用它们。还有一个<code class="fe lw lx ly lz b">UIViewControllerRepresentable</code>让我们将<code class="fe lw lx ly lz b">UIViewControllers</code>集成到SwiftUI中。</p><h2 id="6f0a" class="ma mb iu bd mc md me dn mf mg mh dp mi lj mj mk ml ln mm mn mo lr mp mq mr ms bi translated">我们的目标</h2><ul class=""><li id="fc7e" class="mt mu iu lc b ld mv lg mw lj mx ln my lr mz lv na nb nc nd bi translated">理解<code class="fe lw lx ly lz b">UIViewRepresentable</code>如何工作并探索它的生命周期</li><li id="1d5e" class="mt mu iu lc b ld ne lg nf lj ng ln nh lr ni lv na nb nc nd bi translated">使用<code class="fe lw lx ly lz b">Coordinator</code>将数据从UIKit视图传递到SwiftUI。我们将从SwiftUI视图中看到如何嵌入一个<code class="fe lw lx ly lz b">UISearchBar</code>并与之交互。</li><li id="c050" class="mt mu iu lc b ld ne lg nf lj ng ln nh lr ni lv na nb nc nd bi translated">创建一个通用的包装器，让我们能够在SwiftUI界面中快速集成任何UIView</li></ul></div><div class="ab cl nk nl hy nm" role="separator"><span class="nn bw bk no np nq"/><span class="nn bw bk no np nq"/><span class="nn bw bk no np"/></div><div class="in io ip iq ir"><h1 id="0662" class="nr mb iu bd mc ns nt nu mf nv nw nx mi ka ny kb ml kd nz ke mo kg oa kh mr ob bi translated">“UIViewRepresentable”协议</h1><p id="70f2" class="pw-post-body-paragraph la lb iu lc b ld mv jv lf lg mw jy li lj oc ll lm ln od lp lq lr oe lt lu lv in bi translated">在我们的定制实例中采用<code class="fe lw lx ly lz b">UIViewRepresentable</code>让我们能够从SwiftUI界面创建和管理UIKit视图。最简单的实现需要您处理两个方法:<code class="fe lw lx ly lz b">makeUIView</code>和<code class="fe lw lx ly lz b">updateUIView</code>。</p><p id="2971" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">以下是在SwiftUI中嵌入<code class="fe lw lx ly lz b">UIActivityIndicator</code>时如何使用它们的示例:</p><figure class="kk kl km kn gu ko"><div class="bz fq l di"><div class="of og l"/></div></figure><ul class=""><li id="711e" class="mt mu iu lc b ld le lg lh lj oh ln oi lr oj lv na nb nc nd bi translated"><code class="fe lw lx ly lz b">makeUIView</code>允许我们建立可表示的视图(在我们的例子中是<code class="fe lw lx ly lz b">UIActivityIndicatorView</code>)。在SwiftUI视图的生命周期中，它只会被调用一次。</li><li id="f991" class="mt mu iu lc b ld ne lg nf lj ng ln nh lr ni lv na nb nc nd bi translated">每当其包含的SwiftUI视图改变其状态时，<code class="fe lw lx ly lz b">updateUIView</code>就会被触发。在这个方法中，您可以对视图信息进行更改。为了从SwiftUI视图中获取数据，我们利用了一个<code class="fe lw lx ly lz b">Binding</code>属性包装器——它可以读取和写入一个真实来源所拥有的值(在我们的例子中是<code class="fe lw lx ly lz b">State</code>)。</li></ul><p id="6e82" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">让我们看一个简单的SwiftUI应用程序，它在点击按钮时显示和隐藏<code class="fe lw lx ly lz b">UIActivityIndicatorView</code>。</p><figure class="kk kl km kn gu ko gi gj paragraph-image"><div role="button" tabindex="0" class="kp kq di kr bf ks"><div class="gi gj ok"><img src="../Images/998327829a04a23525027b6749218ec9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*mMCFLPr2i8Bi4uV-agNC5Q.gif"/></div></div></figure><p id="76cd" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">在<code class="fe lw lx ly lz b">@Binding</code>属性包装器中，让我们定义一个显式依赖项，其初始值来自SwiftUI状态。因此，每当按下按钮时，<code class="fe lw lx ly lz b">@State</code>就会切换，相应地，绑定值也会改变，从而触发<code class="fe lw lx ly lz b">updateUIView</code>。</p></div><div class="ab cl nk nl hy nm" role="separator"><span class="nn bw bk no np nq"/><span class="nn bw bk no np nq"/><span class="nn bw bk no np"/></div><div class="in io ip iq ir"><h1 id="9961" class="nr mb iu bd mc ns nt nu mf nv nw nx mi ka ny kb ml kd nz ke mo kg oa kh mr ob bi translated">与协调员合作</h1><p id="41c2" class="pw-post-body-paragraph la lb iu lc b ld mv jv lf lg mw jy li lj oc ll lm ln od lp lq lr oe lt lu lv in bi translated">虽然<code class="fe lw lx ly lz b">@Binding</code>属性包装器有助于将数据从SwiftUI传递到UIKit视图，但有时我们也需要反过来做。</p><p id="2ae3" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">SwiftUI的协调者充当UIKit和SwiftUI视图之间的桥梁。它们允许我们通过使用委托或目标操作将UIKit视图更改传达给SwiftUI界面。<code class="fe lw lx ly lz b">Coordinator</code>是一个类，我们可以在其中实现UIKit视图协议委托。</p><p id="df76" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">UIKit控件有自己的委托方法，让我们可以给<code class="fe lw lx ly lz b">MKMapView</code>添加注释，或者更新<code class="fe lw lx ly lz b">UIPageViewController</code>中的当前页面索引。我们可以使用协调器实现这些委托方法，并使用绑定值调用<code class="fe lw lx ly lz b">updateUIView</code>方法。</p><p id="6eeb" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">下面是一个定制的<code class="fe lw lx ly lz b">Coordinator</code>类的代码，它实现了<code class="fe lw lx ly lz b">UISearchBarDelegate</code>协议来通知SwiftUI可表示视图的文本更新:</p><figure class="kk kl km kn gu ko"><div class="bz fq l di"><div class="of og l"/></div></figure><p id="1ea4" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">接下来，让我们将<code class="fe lw lx ly lz b">makeCoordinator()</code>方法添加到<code class="fe lw lx ly lz b">UIViewRepresentable</code>包装器结构中。</p><p id="bc5b" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">在<code class="fe lw lx ly lz b">makeUIView</code>方法中，我们将<code class="fe lw lx ly lz b">context</code>参数中的<code class="fe lw lx ly lz b">coordinator</code>属性设置为<code class="fe lw lx ly lz b">UISearchControl</code>的<code class="fe lw lx ly lz b">delegate</code>属性。</p><figure class="kk kl km kn gu ko"><div class="bz fq l di"><div class="of og l"/></div></figure><p id="1104" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">在上面的代码中，每次触发<code class="fe lw lx ly lz b">Coordinator</code>类的<code class="fe lw lx ly lz b">UISearchBarDelegate</code>时，文本都被传递到<code class="fe lw lx ly lz b">updateUIView</code>，最终更新<code class="fe lw lx ly lz b">UISearchBar</code>视图。这是SwiftUI应用程序的屏幕截图，其中UISearchBar被添加到SwiftUI列表中。</p><figure class="kk kl km kn gu ko gi gj paragraph-image"><div role="button" tabindex="0" class="kp kq di kr bf ks"><div class="gi gj ol"><img src="../Images/c3d78e1977da2bb8fe0b1231f4a99b85.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*_0C4YEKyrEA2HMVs-vo_WQ.gif"/></div></div></figure></div><div class="ab cl nk nl hy nm" role="separator"><span class="nn bw bk no np nq"/><span class="nn bw bk no np nq"/><span class="nn bw bk no np"/></div><div class="in io ip iq ir"><h1 id="76d9" class="nr mb iu bd mc ns nt nu mf nv nw nx mi ka ny kb ml kd nz ke mo kg oa kh mr ob bi translated">“UIViewRepresentable”生命周期</h1><p id="67ed" class="pw-post-body-paragraph la lb iu lc b ld mv jv lf lg mw jy li lj oc ll lm ln od lp lq lr oe lt lu lv in bi translated">既然我们已经看到了UIKit视图是如何嵌入SwiftUI的，以及数据流是如何使用绑定和协调器来更新视图的，那么让我们来可视化一个UIKit可表示视图的生命周期:</p><figure class="kk kl km kn gu ko gi gj paragraph-image"><div class="gi gj om"><img src="../Images/80898bd7a0199b65bec0695771bcfd64.png" data-original-src="https://miro.medium.com/v2/resize:fit:1088/format:webp/1*V7xwRE68sADC2cmoTlB_Ig.png"/></div></figure><p id="ea43" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">对于UIKit可表示视图,<code class="fe lw lx ly lz b">dismantleUIView</code>的行为类似于<code class="fe lw lx ly lz b">deinit</code>。您可以进行清理工作——例如删除通知观察器、计时器失效等。—在里面。</p><p id="5b0b" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">SwiftUI视图中的<code class="fe lw lx ly lz b">UIViewController</code>的生命周期以同样的方式工作，并且具有相似的函数签名——用<code class="fe lw lx ly lz b">makeUIViewController</code>替换<code class="fe lw lx ly lz b">makeUIView</code>,以此类推。</p></div><div class="ab cl nk nl hy nm" role="separator"><span class="nn bw bk no np nq"/><span class="nn bw bk no np nq"/><span class="nn bw bk no np"/></div><div class="in io ip iq ir"><h1 id="66b0" class="nr mb iu bd mc ns nt nu mf nv nw nx mi ka ny kb ml kd nz ke mo kg oa kh mr ob bi translated">通用' UIViewRepresentable '</h1><p id="5471" class="pw-post-body-paragraph la lb iu lc b ld mv jv lf lg mw jy li lj oc ll lm ln od lp lq lr oe lt lu lv in bi translated">在前面的章节中，我们看到了添加一个简单的<code class="fe lw lx ly lz b">UIActivityIndicatorView</code>和<code class="fe lw lx ly lz b">UISearchBar</code>是如何需要创建单独的包装器结构的。</p><p id="04b7" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">它不仅增加了样板代码，还拆分了视图逻辑——例如，<code class="fe lw lx ly lz b">UIActivityIndicatorView</code>在SwiftUI中被实例化，而动画切换逻辑驻留在<code class="fe lw lx ly lz b">UIViewRepresentable</code>中。</p><p id="c6cc" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">幸运的是，我们可以通过创建一个通用的<code class="fe lw lx ly lz b">UIViewRepresentable</code>结构来解决这些问题，该结构允许您嵌入任何 UIKit视图。让我们编写一个通用类型，它可以包装<code class="fe lw lx ly lz b">UIViewRepresentable</code>中的任何<code class="fe lw lx ly lz b">UIView</code>:</p><figure class="kk kl km kn gu ko"><div class="bz fq l di"><div class="of og l"/></div></figure><p id="532d" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">应用于上述闭包参数的<code class="fe lw lx ly lz b">@autoclosure</code>属性自动从您传入的表达式中创建一个闭包。它有助于将闭包的执行推迟到真正需要的时候。</p><p id="2b3f" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">使用上面的通用<code class="fe lw lx ly lz b">Anything</code>包装器，我们可以在SwiftUI中嵌入任何UIKit视图。当然，要创建自定义协调器实例，您可以扩展上面的泛型并设置特定于UI控件的委托。</p><p id="a01b" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">下面看一下如何在SwiftUI主体中使用<code class="fe lw lx ly lz b">Anything</code>包装器嵌入<code class="fe lw lx ly lz b">UIActivityIndicatorView</code>:</p><pre class="kk kl km kn gu on lz oo op aw oq bi"><span id="0c11" class="ma mb iu lz b gz or os l ot ou"><strong class="lz iv">Anything</strong>(UIActivityIndicatorView(style: .large)) {<br/>    if self.shouldAnimate {<br/>        $0.startAnimating()<br/>    } else {<br/>        $0.stopAnimating()<br/>    }<br/>}</span></pre><p id="4253" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">在下图中，我们在通用包装器中又包装了四个UIKit控件— <code class="fe lw lx ly lz b">UISearchBar</code>、一个<a class="ae kz" href="https://github.com/i-schuetz/PieCharts" rel="noopener ugc nofollow" target="_blank">自定义图表UI </a>、一个<code class="fe lw lx ly lz b">UITextView</code>和一个<code class="fe lw lx ly lz b">UIPageControl</code>。</p><figure class="kk kl km kn gu ko gi gj paragraph-image"><div role="button" tabindex="0" class="kp kq di kr bf ks"><div class="gi gj ov"><img src="../Images/e88a74f6f922c15f261fdca9921a96b8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*-f9-8716t-Yefu3rtfQ_oA.gif"/></div></div></figure></div><div class="ab cl nk nl hy nm" role="separator"><span class="nn bw bk no np nq"/><span class="nn bw bk no np nq"/><span class="nn bw bk no np"/></div><div class="in io ip iq ir"><h1 id="1b4d" class="nr mb iu bd mc ns nt nu mf nv nw nx mi ka ny kb ml kd nz ke mo kg oa kh mr ob bi translated">结论</h1><p id="9542" class="pw-post-body-paragraph la lb iu lc b ld mv jv lf lg mw jy li lj oc ll lm ln od lp lq lr oe lt lu lv in bi translated">因此，我们看到了<code class="fe lw lx ly lz b">UIViewRepresentable</code>如何使用UIKit包装器结构帮助集成缺失的SwiftUI控件。随后，我们与协调员合作，从UIKit更新SwiftUI视图，并看到了事件的生命周期。最后，我们为<code class="fe lw lx ly lz b">UIViews</code>创建了一个通用的包装器。</p><p id="bf5d" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">完整的源代码可以在这个<a class="ae kz" href="https://github.com/anupamchugh/iowncode/tree/master/SwiftUIViewRepresentable" rel="noopener ugc nofollow" target="_blank"> GitHub库</a>中找到。</p><p id="5ebd" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">感谢阅读。如果您想开始使用Combine框架，这里是一个很好的起点:</p><div class="ow ox gq gs oy oz"><a href="https://medium.com/better-programming/a-deep-dive-into-the-combine-framework-in-swift-cffdfcc6f32c" rel="noopener follow" target="_blank"><div class="pa ab fp"><div class="pb ab pc cl cj pd"><h2 class="bd iv gz z fq pe fs ft pf fv fx it bi translated">深入探究Swift中的联合框架</h2><div class="pg l"><h3 class="bd b gz z fq pe fs ft pf fv fx dk translated">让我们了解一下苹果自己的反应式框架</h3></div><div class="ph l"><p class="bd b dl z fq pe fs ft pf fv fx dk translated">medium.com</p></div></div><div class="pi l"><div class="pj l pk pl pm pi pn kt oz"/></div></div></a></div></div></div>    
</body>
</html>