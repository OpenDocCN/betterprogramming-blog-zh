<html>
<head>
<title>Recoverable and Non-Recoverable Errors in Swift</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Swift中可恢复和不可恢复的错误</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/recoverable-and-non-recoverable-errors-in-swift-e6e4c1de89ba?source=collection_archive---------11-----------------------#2021-03-05">https://betterprogramming.pub/recoverable-and-non-recoverable-errors-in-swift-e6e4c1de89ba?source=collection_archive---------11-----------------------#2021-03-05</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="d12c" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">确保您的iOS代码库正确失败</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/75e33df6d6ec1223874c6bf5107e0568.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*SPn-PGUyzZMxguLR2dDqzg.jpeg"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">照片由<a class="ae ky" href="https://unsplash.com/@theblowup?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">放大</a>上的<a class="ae ky" href="https://unsplash.com/s/photos/failure?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">去飞溅</a></p></figure><p id="0389" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">Swift为开发人员提供了一些处理意外程序流的工具。然而<em class="lv">意料之外的</em>在这里不一定意味着<em class="lv">未定义的</em>。</p><p id="1ddf" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在你能选择一个合适的工具之前，你首先得仔细检查这个问题。区分谁或什么做了意想不到的事情很重要:</p><ol class=""><li id="b372" class="lw lx it lb b lc ld lf lg li ly lm lz lq ma lu mb mc md me bi translated">用户</li><li id="18af" class="lw lx it lb b lc mf lf mg li mh lm mi lq mj lu mb mc md me bi translated">一项服务</li><li id="b674" class="lw lx it lb b lc mf lf mg li mh lm mi lq mj lu mb mc md me bi translated">程序本身</li></ol></div><div class="ab cl mk ml hx mm" role="separator"><span class="mn bw bk mo mp mq"/><span class="mn bw bk mo mp mq"/><span class="mn bw bk mo mp"/></div><div class="im in io ip iq"><h1 id="b87e" class="mr ms it bd mt mu mv mw mx my mz na nb jz nc ka nd kc ne kd nf kf ng kg nh ni bi translated">意外的用户操作</h1><p id="89e0" class="pw-post-body-paragraph kz la it lb b lc nj ju le lf nk jx lh li nl lk ll lm nm lo lp lq nn ls lt lu im bi translated">如果你要求用户输入他们的名字，但是他们只是简单地按下“OK”按钮，那么这不是通常所期望的行为，而是(希望)已经预先定义好的行为。</p><p id="d66e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">理想情况下，用户甚至不可能执行这个动作(例如，因为按钮被去激活)。如果这个动作仍然可行，那么你应该拒绝这个结果，并且告诉用户他们做错了什么。</p><p id="6f7f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">因此，该操作会导致一个定义好的错误，在运行时很容易恢复。通过拒绝进入，app始终处于定义好的状态。</p><p id="c79a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">适用于此类错误的工具有:</p><ul class=""><li id="134c" class="lw lx it lb b lc ld lf lg li ly lm lz lq ma lu no mc md me bi translated"><code class="fe np nq nr ns b">if</code>或<code class="fe np nq nr ns b">switch</code>分支</li><li id="ae1b" class="lw lx it lb b lc mf lf mg li mh lm mi lq mj lu no mc md me bi translated"><code class="fe np nq nr ns b">guard</code>语句</li></ul></div><div class="ab cl mk ml hx mm" role="separator"><span class="mn bw bk mo mp mq"/><span class="mn bw bk mo mp mq"/><span class="mn bw bk mo mp"/></div><div class="im in io ip iq"><h1 id="f6f2" class="mr ms it bd mt mu mv mw mx my mz na nb jz nc ka nd kc ne kd nf kf ng kg nh ni bi translated">意外服务行为</h1><p id="29c0" class="pw-post-body-paragraph kz la it lb b lc nj ju le lf nk jx lh li nl lk ll lm nm lo lp lq nn ls lt lu im bi translated">如果您使用某个服务，比如向服务器发送请求，那么该服务总是会出现意外行为。</p><p id="fc09" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">服务器有时可能不可用，这当然不是服务器的预期行为，但它肯定是一个定义好的行为。或者它可能被错误地编程，并产生无效的、不可处理的结果。</p><p id="f63b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在后一种情况下，不正确的结果没有被定义。一切最终都可能回来，但是预期的行为(某个返回值)和过程(请求的响应)本身是非常好定义的。这使您能够捕获错误，因为您确切地知道错误可能发生在哪里以及错误是什么。</p><p id="e2a4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">因此，您应该始终预期服务不会像您预期的那样工作，并捕捉相应的错误。通过在运行时捕获错误，您可以恢复应用程序以前定义的状态。</p><p id="e60c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">合适的工具有:</p><ul class=""><li id="b09f" class="lw lx it lb b lc ld lf lg li ly lm lz lq ma lu no mc md me bi translated"><code class="fe np nq nr ns b">Result.error</code>或<code class="fe np nq nr ns b">nil</code>为可选返回值</li><li id="216f" class="lw lx it lb b lc mf lf mg li mh lm mi lq mj lu no mc md me bi translated">使用<code class="fe np nq nr ns b">if</code>、<code class="fe np nq nr ns b">switch</code>或<code class="fe np nq nr ns b">guard</code>语句检查返回值。</li><li id="b6bf" class="lw lx it lb b lc mf lf mg li mh lm mi lq mj lu no mc md me bi translated"><code class="fe np nq nr ns b">do try catch</code>块或<code class="fe np nq nr ns b">try?</code>如果错误可以忽略</li></ul></div><div class="ab cl mk ml hx mm" role="separator"><span class="mn bw bk mo mp mq"/><span class="mn bw bk mo mp mq"/><span class="mn bw bk mo mp"/></div><div class="im in io ip iq"><h1 id="2857" class="mr ms it bd mt mu mv mw mx my mz na nb jz nc ka nd kc ne kd nf kf ng kg nh ni bi translated">意外的程序行为</h1><p id="2c6e" class="pw-post-body-paragraph kz la it lb b lc nj ju le lf nk jx lh li nl lk ll lm nm lo lp lq nn ls lt lu im bi translated">我们已经到达有趣的和“有问题的”问题。我们如何处理程序本身的错误？</p><p id="71fd" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">当程序没有做它应该做的事情时，它被称为“bug”错误是由程序员造成的，因为他们通常没有彻底考虑一些事情，或者因为功能没有被清楚地描述，因此没有被正确地使用。</p><p id="7ef4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">与前面的错误不同，这些错误总是未定义的。没有人会告诉开发者友好地在这里添加一个bug。否则，它就不是一个bug，而是一个已定义的行为。从定义上来说，有缺陷的接受标准是矛盾的。</p><p id="8ee1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">程序(mer)错误通常会导致应用程序出现未定义的状态。有些可能不是很严重，但有些是。未定义的状态也会影响应用程序中其他未定义的状态。</p><p id="1e46" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">未定义的应用程序状态是我们肯定要防止的，因为<em class="lv">未定义的</em>意味着应用程序可以一次做所有的事情。这种行为最终不再被定义。该应用程序可能会立即崩溃或继续运行，没有任何明显的问题，只会在很久以后导致一些神秘的副作用，我们永远不会得到重建和修复。</p><p id="46ce" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">错误发现得越晚，就越难定位和修复。这就是为什么我们要编写单元和集成测试(或者至少我们应该这样做)。然而，这些总是只检查封装的代码块，并且只能测试定义的行为，因为单元测试未定义的行为应该是什么样子的呢？如果一个人能做到这一点，那么行为就会被定义。</p><p id="ec6d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">然而，有一种更好的方法，通过健全性检查直接在代码中进行测试。健全性检查类似于<code class="fe np nq nr ns b">assert</code>和<code class="fe np nq nr ns b">precondition</code>。它们有助于检查代码本身的假设和内部状态，从而识别未定义的应用程序状态。</p><p id="aa6e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果健全性检查不成功，那是因为应用程序已经处于未定义的状态——一种应该/不能实际发生的状态。如果这种情况真的发生了，实际上只有一个有效的解决方案:崩溃！</p><p id="959c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">崩溃在这里是一件好事，因为使用崩溃报告:</p><ol class=""><li id="b0a6" class="lw lx it lb b lc ld lf lg li ly lm lz lq ma lu mb mc md me bi translated">你就会知道这个应用程序有错误。</li><li id="0945" class="lw lx it lb b lc mf lf mg li mh lm mi lq mj lu mb mc md me bi translated">你就能确切知道它发生在哪里。</li></ol><p id="df86" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这为您提供了尽快修复错误的可能性。任何恢复尝试都不可避免地导致错误延续，并导致可能永远无法修复的后续错误。</p><p id="a9e8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">因此，未定义的状态是不可恢复的错误，会导致崩溃。</p><p id="14bc" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">合适的工具有:</p><ul class=""><li id="a547" class="lw lx it lb b lc ld lf lg li ly lm lz lq ma lu no mc md me bi translated"><code class="fe np nq nr ns b">assert()</code>或<code class="fe np nq nr ns b">assertionFailure()</code></li><li id="e043" class="lw lx it lb b lc mf lf mg li mh lm mi lq mj lu no mc md me bi translated"><code class="fe np nq nr ns b">precondition()</code>或<code class="fe np nq nr ns b">preconditionFailure()</code></li><li id="60ac" class="lw lx it lb b lc mf lf mg li mh lm mi lq mj lu no mc md me bi translated"><code class="fe np nq nr ns b">fatalError()</code></li></ul><p id="796c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们仔细看看这些工具及其用途。</p></div><div class="ab cl mk ml hx mm" role="separator"><span class="mn bw bk mo mp mq"/><span class="mn bw bk mo mp mq"/><span class="mn bw bk mo mp"/></div><div class="im in io ip iq"><h1 id="e44e" class="mr ms it bd mt mu mv mw mx my mz na nb jz nc ka nd kc ne kd nf kf ng kg nh ni bi translated">代码中的完整性检查</h1><p id="6a15" class="pw-post-body-paragraph kz la it lb b lc nj ju le lf nk jx lh li nl lk ll lm nm lo lp lq nn ls lt lu im bi translated">根据函数和编译器标志，健全性检查方法的行为会有所不同。这些列表示是否执行了函数和测试，如果没有执行，应用程序就会崩溃。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nt nu l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">健全性检查功能</p></figure><p id="75b9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><em class="lv"> *优化器可能认为这个函数永远不会被调用。如果是这样呢？这是未定义的。但是，无论如何都不应该使用unchecked标志。</em></p><p id="508f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">那么什么时候用哪个函数呢？</p><h2 id="7679" class="nv ms it bd mt nw nx dn mx ny nz dp nb li oa ob nd lm oc od nf lq oe of nh og bi translated">致命错误</h2><p id="8b7e" class="pw-post-body-paragraph kz la it lb b lc nj ju le lf nk jx lh li nl lk ll lm nm lo lp lq nn ls lt lu im bi translated">因为这个函数本身不检查任何东西，所以它实际上非常容易使用。每当您在代码中到达一个逻辑上不可到达的状态时，您就使用<code class="fe np nq nr ns b">fatalError()</code>来强制崩溃。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nt nu l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">何时使用fatalError()的示例</p></figure><h2 id="b31c" class="nv ms it bd mt nw nx dn mx ny nz dp nb li oa ob nd lm oc od nf lq oe of nh og bi translated">前提</h2><p id="a0b2" class="pw-post-body-paragraph kz la it lb b lc nj ju le lf nk jx lh li nl lk ll lm nm lo lp lq nn ls lt lu im bi translated">使用<code class="fe np nq nr ns b">precondition()</code>，您可以检查输入参数的有效性。</p><p id="5598" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">例如，如果您编写一个仅对大于零的正值有意义的方法，您可以将这样的值设置为调用该方法的条件。因为没有办法通过编译器来定义它，我们通过方法文档来定义它。为了确保开发人员不会用不正确的值调用该方法，使用<code class="fe np nq nr ns b">precondition()</code>在方法中检查该值。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nt nu l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">何时使用前提条件()的示例</p></figure><p id="179f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">重要的是要知道，无论是在调试还是在发布版本中，这种检查总是要执行的。所以你可以确定，在这一点上，应用程序永远不会在未定义的状态下运行。</p><h2 id="d201" class="nv ms it bd mt nw nx dn mx ny nz dp nb li oa ob nd lm oc od nf lq oe of nh og bi translated">预处理失败</h2><p id="fbfa" class="pw-post-body-paragraph kz la it lb b lc nj ju le lf nk jx lh li nl lk ll lm nm lo lp lq nn ls lt lu im bi translated"><code class="fe np nq nr ns b">preconditionFailure()</code>的语义其实和<code class="fe np nq nr ns b">precondition()</code>的语义是一样的。如果触发，则方法参数不正确。然而，不同之处在于<code class="fe np nq nr ns b">preconditionFailure()</code>本身并不执行检查(也就是说，您必须自己在代码中执行这样的检查，并且在否定的情况下，手动调用<code class="fe np nq nr ns b">preconditionFailure()</code>)。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nt nu l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">何时使用preconditionFailure()的示例</p></figure><p id="c82d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">也可以使用<code class="fe np nq nr ns b">fatalError()</code>来代替<code class="fe np nq nr ns b">preconditionFailure()</code>。但<code class="fe np nq nr ns b">preconditionFailure()</code>明确表示是因为参数，而<code class="fe np nq nr ns b">fatalError()</code>则更笼统。所以唯一的区别是使用的上下文。</p><h2 id="99de" class="nv ms it bd mt nw nx dn mx ny nz dp nb li oa ob nd lm oc od nf lq oe of nh og bi translated">维护</h2><p id="bc75" class="pw-post-body-paragraph kz la it lb b lc nj ju le lf nk jx lh li nl lk ll lm nm lo lp lq nn ls lt lu im bi translated">像<code class="fe np nq nr ns b">precondition()</code>一样，<code class="fe np nq nr ns b">assert()</code>函数检查一个值，并在否定的情况下使应用崩溃。然而，这只会发生在调试版本中，而不会发生在发布版本中。所以如果你传递了一个类似<code class="fe np nq nr ns b">assert(isStateSet())</code>的函数，那么这个函数只在开发过程中执行——而不是在生产应用中。</p><p id="ef4e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果<code class="fe np nq nr ns b">isStateSet()</code>执行一个耗时的计算，那么它不在生产应用程序中运行可能是有意义的。然而，如果<code class="fe np nq nr ns b">isStateSet()</code>确实有副作用，那么这只会发生在开发过程中——而不会发生在生产应用中——然后人们会想为什么完成的应用与开发过程中的行为不同。所以你必须确保<code class="fe np nq nr ns b">assert()</code>没有副作用。</p><p id="5f9b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果函数参数用<code class="fe np nq nr ns b">precondition()</code>，什么时候用<code class="fe np nq nr ns b">assert()</code>？实际上，仅用于在您自己的代码块中进行检查(例如，如果您当前正在自己计算一些东西，并且想要确保您已经正确地计算了一些东西，并且它仍然在值的范围内)。如果以后有人更改了代码，<code class="fe np nq nr ns b">assert()</code>会确保这种更改仍然受原始条件的约束(即防止未来的自己忘记原来的假设)。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nt nu l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">何时使用assert()的示例</p></figure><p id="470e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">但是如果在一个发布版本中<code class="fe np nq nr ns b">aPositiveNumber</code>变成负数会发生什么呢？如果计算使用该类的属性，则可能会发生这种情况。正常情况下，这些值应该总是包含正值，但是如果出现了错误，它们就会突然变成负值。因为<code class="fe np nq nr ns b">assert()</code>不会在发布版本中触发，所以工作会以一个不正确的值继续。结果是不确定的，错误是长期的。</p><p id="912d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这就是为什么我建议不要使用<code class="fe np nq nr ns b">assert()</code>而总是使用<code class="fe np nq nr ns b">guard</code>和<code class="fe np nq nr ns b">fatalError()</code>:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nt nu l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">如何用fatalError()替换assert()的示例</p></figure><p id="9b69" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">但是如果绝对要用<code class="fe np nq nr ns b">assert</code>，要注意以下几点:</p><ol class=""><li id="e2bf" class="lw lx it lb b lc ld lf lg li ly lm lz lq ma lu mb mc md me bi translated">切勿在<code class="fe np nq nr ns b">assert</code>的闭合参数中产生副作用。否则，对于调试版本和发布版本，应用程序的行为可能会有所不同。</li><li id="c942" class="lw lx it lb b lc mf lf mg li mh lm mi lq mj lu mb mc md me bi translated">仅在<code class="fe np nq nr ns b">assert</code>的闭合参数中使用常量。否则，不会捕捉到只发生在发布版本中的错误。</li></ol><p id="3205" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">例如，<code class="fe np nq nr ns b">assert</code>的一个有意义的用例是，如果你想确保所有的资源都捆绑在应用中。资源是在编译时进入应用程序的常量，在运行时不会改变。加载和检查这些文件可能非常耗时。如果您在调试版本的应用程序启动时这样做一次，您可以确定您没有忘记添加资源。然而，在发布版本中，您可以节省时间并跳过这个检查。</p><h2 id="dca3" class="nv ms it bd mt nw nx dn mx ny nz dp nb li oa ob nd lm oc od nf lq oe of nh og bi translated">断言失败</h2><p id="48de" class="pw-post-body-paragraph kz la it lb b lc nj ju le lf nk jx lh li nl lk ll lm nm lo lp lq nn ls lt lu im bi translated">正如<code class="fe np nq nr ns b">preconditionFailure()</code>与<code class="fe np nq nr ns b">precondition()</code>相关一样，<code class="fe np nq nr ns b">assertionFailure()</code>与<code class="fe np nq nr ns b">assert()</code>相关。<code class="fe np nq nr ns b">assertionFailure()</code>不检查任何东西，只在调试版本中崩溃应用程序。与<code class="fe np nq nr ns b">assert()</code>一样，可能会出现未定义状态的问题，这在发布版本中会延长。</p><p id="4e90" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">由于<code class="fe np nq nr ns b">assertionFailure()</code>甚至不检查任何东西(也就是说，无论如何你必须事先执行检查)，你失去了在发布版本中不执行代码的罕见优势。这就引出了<code class="fe np nq nr ns b">assertionFailure()</code>有用性的问题。</p><p id="12f8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">然而，实际上有一个用例:您有一个服务器，并希望从它那里得到错误结果的通知。</p><p id="5a36" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">起初，这听起来更像是一种意外的服务行为。毕竟，我们在这里讨论的是一个服务，一个服务总是能提供意想不到的价值。</p><p id="3353" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">然而，这项服务是你的责任，如果它不能正常工作，你会想知道。单元测试实际上应该在服务器上使用，以确保其API的正确性，并防止此类错误。然而，单元测试可能是不完整的(编程错误)，当然，如果您在应用程序中有第二个安全网，这是很好的。</p><p id="54f3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">因此，使用<code class="fe np nq nr ns b">assertionFailure()</code>调用是合理的，例如，在<code class="fe np nq nr ns b">guard</code>之后，因为它会立即通知您服务器及其单元测试有故障。如果不是你自己的服务器，你可能不会用一个<code class="fe np nq nr ns b">assertionFailure()</code>，但在这里是有道理的。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nt nu l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">何时使用assertionFailure()的示例</p></figure></div><div class="ab cl mk ml hx mm" role="separator"><span class="mn bw bk mo mp mq"/><span class="mn bw bk mo mp mq"/><span class="mn bw bk mo mp"/></div><div class="im in io ip iq"><h1 id="33f4" class="mr ms it bd mt mu mv mw mx my mz na nb jz nc ka nd kc ne kd nf kf ng kg nh ni bi translated">结论</h1><p id="32da" class="pw-post-body-paragraph kz la it lb b lc nj ju le lf nk jx lh li nl lk ll lm nm lo lp lq nn ls lt lu im bi translated">如果可能的话，应用程序应该恢复状态。然而，在编程错误的情况下，这通常是不可能的。那么应用程序应该尽早崩溃，这样错误就不会被延迟，开发者就有更好的机会找到并纠正错误。</p><p id="565b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我已经在上面展示了哪些工具可以在何时以及如何使用。有时候你想稍微弯曲一下。例如，如果您想在崩溃前将错误和应用程序状态发送到跟踪服务，那么崩溃应该延迟一点。但是延期不是取消！</p></div></div>    
</body>
</html>