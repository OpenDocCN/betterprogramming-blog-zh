<html>
<head>
<title>How to Add Compiled Frameworks in Swift Package Manager</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何在Swift包管理器中添加编译的框架</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/how-to-add-compiled-frameworks-in-swift-package-manager-f0cdbde84fc7?source=collection_archive---------4-----------------------#2020-06-03">https://betterprogramming.pub/how-to-add-compiled-frameworks-in-swift-package-manager-f0cdbde84fc7?source=collection_archive---------4-----------------------#2020-06-03</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="3c0c" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">Swift 5.3为SPM带来了二进制依赖或编译框架</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/6e6f8b89dc051d400bbd81f30a7ea00f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*TgepyIhQRpwI2zcsFUQi4A.jpeg"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">在<a class="ae ky" href="https://unsplash.com/s/photos/box?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上<a class="ae ky" href="https://unsplash.com/@erdaest?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Erda Estremera </a>拍摄的照片</p></figure><p id="3f33" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">Swift终于推出了期待已久的功能。Swift 5.3将使您能够在<a class="ae ky" href="https://swift.org/package-manager/" rel="noopener ugc nofollow" target="_blank"> Swift包管理器</a>中添加二进制依赖项。为什么这听起来很棒？因为在Swift 5.3之前，SPM (Swift Package Manager)仅将源代码库作为依赖项启用，这意味着许多企业软件(通常以闭源形式出现)或闭源库不能作为依赖项添加到SPM中，如Firebase或Google Analytics。</p><p id="31ca" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><a class="ae ky" href="https://github.com/apple/swift-evolution/blob/master/proposals/0272-swiftpm-binary-dependencies.md" rel="noopener ugc nofollow" target="_blank">SE-0272</a>by<a class="ae ky" href="https://github.com/bscothern" rel="noopener ugc nofollow" target="_blank">Braden scot hern</a>、<a class="ae ky" href="https://github.com/ddunbar" rel="noopener ugc nofollow" target="_blank"> Daniel Dunbar </a>和<a class="ae ky" href="https://github.com/FranzBusch" rel="noopener ugc nofollow" target="_blank"> Franz Busch </a>为Swift 5.3带来了二进制依赖能力，这意味着您可以将编译后的框架添加到您的SPM中。但是请记住，目前只支持<code class="fe lv lw lx ly b">xcframework</code>格式。(撰写本文时，其他类型的框架仍在讨论中。更多细节见<a class="ae ky" href="https://github.com/apple/swift-evolution/blob/master/proposals/0272-swiftpm-binary-dependencies.md#support-for-non-apple-platforms" rel="noopener ugc nofollow" target="_blank">此处</a>。</p></div><div class="ab cl lz ma hx mb" role="separator"><span class="mc bw bk md me mf"/><span class="mc bw bk md me mf"/><span class="mc bw bk md me"/></div><div class="im in io ip iq"><h1 id="9ead" class="mg mh it bd mi mj mk ml mm mn mo mp mq jz mr ka ms kc mt kd mu kf mv kg mw mx bi translated">xcframework是什么？</h1><p id="c83d" class="pw-post-body-paragraph kz la it lb b lc my ju le lf mz jx lh li na lk ll lm nb lo lp lq nc ls lt lu im bi translated"><code class="fe lv lw lx ly b">xcframework</code>是苹果在2019年WWDC会议上推出的一种格式，在Swift 的“<a class="ae ky" href="https://developer.apple.com/videos/play/wwdc2019/416/" rel="noopener ugc nofollow" target="_blank">二进制框架”中讨论了这种格式</a></p><p id="cf6c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">使用<code class="fe lv lw lx ly b">xcframework</code>有几个好处，像多架构多平台(包括模拟器类型)，上传到AppStore之前不用切片x86_64。</p><p id="cf47" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">你应该知道怎么用<code class="fe lv lw lx ly b">xcframework</code>因为SPM只支持这个。除非你已经编译过了，否则跳过这一节。我建议你观看上面的WWDC 2019会议。</p><p id="0332" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">注意:因为Swift 5.3只允许<code class="fe lv lw lx ly b">xcframework</code>，所以该功能只在苹果OS (iOS、macOS、tvOS等)上有效。我希望未来的Swift版本能在Linux和Windows上增加这一功能。</p></div><div class="ab cl lz ma hx mb" role="separator"><span class="mc bw bk md me mf"/><span class="mc bw bk md me mf"/><span class="mc bw bk md me"/></div><div class="im in io ip iq"><h1 id="e5fc" class="mg mh it bd mi mj mk ml mm mn mo mp mq jz mr ka ms kc mt kd mu kf mv kg mw mx bi translated">如何使用</h1><p id="81a0" class="pw-post-body-paragraph kz la it lb b lc my ju le lf mz jx lh li na lk ll lm nb lo lp lq nc ls lt lu im bi translated">首先在SPM目标中添加一个新的<code class="fe lv lw lx ly b">.binaryTarget</code>。</p><pre class="kj kk kl km gt nd ly ne nf aw ng bi"><span id="070d" class="nh mh it ly b gy ni nj l nk nl">let package = Package(<br/>   name: "AwesomeLibrary",<br/>   ...<br/>   targets: [<br/>      .target(<br/>         name: "AwesomeLibrary",<br/>         dependencies: ["Logging"]<br/>      ),<br/>      .binaryTarget(name: "Logging", path: "artifacts/Logging.xcframework"<br/>      ),<br/>      ...<br/>   ]</span></pre><p id="a779" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">SPM支持二进制依赖的<code class="fe lv lw lx ly b">zip</code>和原始<code class="fe lv lw lx ly b">xcframework</code>文件。如果你使用了<code class="fe lv lw lx ly b">zip</code>，确保<code class="fe lv lw lx ly b">xcframework</code>位于档案的根目录。</p><p id="c593" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">有两种方法可以添加二进制目标。</p></div><div class="ab cl lz ma hx mb" role="separator"><span class="mc bw bk md me mf"/><span class="mc bw bk md me mf"/><span class="mc bw bk md me"/></div><div class="im in io ip iq"><h1 id="6fa3" class="mg mh it bd mi mj mk ml mm mn mo mp mq jz mr ka ms kc mt kd mu kf mv kg mw mx bi translated">带URL</h1><p id="1c19" class="pw-post-body-paragraph kz la it lb b lc my ju le lf mz jx lh li na lk ll lm nb lo lp lq nc ls lt lu im bi translated">您可以从URL添加二进制目标，如GitHub Release、GitHub Packages、GitLab、Bitbucket、Artifactory、Nexus等。</p><pre class="kj kk kl km gt nd ly ne nf aw ng bi"><span id="559d" class="nh mh it ly b gy ni nj l nk nl">.binaryTarget(<br/>   name: "Logging",<br/>   url: "<a class="ae ky" href="https://github.com/wendyliga/compiled-framework-spm/releases/download/0.0.1/Logging.xcframework.zip" rel="noopener ugc nofollow" target="_blank">https://github.com/wendyliga/compiled-framework-spm/releases/download/0.0.1/Logging.xcframework.zip</a>",<br/>   checksum: "c246c715ac7f6fae9ef0a89e758a8514644071a164985b1e95d344a684d84621"<br/>)</span></pre><p id="eb80" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">注意:使用Swift 5.3，可以通过执行<code class="fe lv lw lx ly b">swift package compute-checksum &lt;path-to-zip&gt;</code>来生成校验和。您需要确保首先下载二进制文件，以计算校验和。</p></div><div class="ab cl lz ma hx mb" role="separator"><span class="mc bw bk md me mf"/><span class="mc bw bk md me mf"/><span class="mc bw bk md me"/></div><div class="im in io ip iq"><h1 id="9055" class="mg mh it bd mi mj mk ml mm mn mo mp mq jz mr ka ms kc mt kd mu kf mv kg mw mx bi translated">原始文件</h1><p id="2023" class="pw-post-body-paragraph kz la it lb b lc my ju le lf mz jx lh li na lk ll lm nb lo lp lq nc ls lt lu im bi translated">另一方面，您可以通过将二进制文件放在源代码中来添加它:</p><p id="2baa" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe lv lw lx ly b">.binaryTarget(name: "Crypto", path: "artifacts/Crypto.xcframework")</code></p><p id="9692" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">注意:到<code class="fe lv lw lx ly b">xcframework</code>的路径从项目的根开始(与<code class="fe lv lw lx ly b">Package.swift)</code>相同)。</p></div><div class="ab cl lz ma hx mb" role="separator"><span class="mc bw bk md me mf"/><span class="mc bw bk md me mf"/><span class="mc bw bk md me"/></div><div class="im in io ip iq"><h1 id="934e" class="mg mh it bd mi mj mk ml mm mn mo mp mq jz mr ka ms kc mt kd mu kf mv kg mw mx bi translated">考虑</h1><p id="4211" class="pw-post-body-paragraph kz la it lb b lc my ju le lf mz jx lh li na lk ll lm nb lo lp lq nc ls lt lu im bi translated">Swift不验证工件的格式(二进制依赖)，这意味着您应该确保提供正确有效的工件。</p><p id="89e6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">从安全的角度来看，比较基于源代码的依赖和二进制依赖之间的信任级别，自然地，基于源代码的依赖会更高，因为您可以检查代码。然而，基于源代码的依赖也有其自身的安全问题。</p><p id="a3ec" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">二进制依赖也有它自己的问题，我们应该减轻，例如，托管在网络上的二进制依赖。总会有<code class="fe lv lw lx ly b">tempering</code>的风险。Swift通过将您设置的二进制校验和与网络中的校验和进行比较来减少这种情况。哈希也存储在包中，以避免供应商在没有人注意到的情况下在以后的版本中更改二进制文件。</p></div><div class="ab cl lz ma hx mb" role="separator"><span class="mc bw bk md me mf"/><span class="mc bw bk md me mf"/><span class="mc bw bk md me"/></div><div class="im in io ip iq"><h1 id="48ce" class="mg mh it bd mi mj mk ml mm mn mo mp mq jz mr ka ms kc mt kd mu kf mv kg mw mx bi translated">示例项目</h1><p id="9dd1" class="pw-post-body-paragraph kz la it lb b lc my ju le lf mz jx lh li na lk ll lm nb lo lp lq nc ls lt lu im bi translated">本文中的所有示例都可以在这个示例项目中找到:<a class="ae ky" href="https://github.com/wendyliga/compiled-framework-spm" rel="noopener ugc nofollow" target="_blank">Wendy liga/compiled-framework-SPM</a></p></div><div class="ab cl lz ma hx mb" role="separator"><span class="mc bw bk md me mf"/><span class="mc bw bk md me mf"/><span class="mc bw bk md me"/></div><div class="im in io ip iq"><h1 id="7870" class="mg mh it bd mi mj mk ml mm mn mo mp mq jz mr ka ms kc mt kd mu kf mv kg mw mx bi translated">结束了</h1><p id="2c92" class="pw-post-body-paragraph kz la it lb b lc my ju le lf mz jx lh li na lk ll lm nb lo lp lq nc ls lt lu im bi translated">Swift 5.3支持编译框架作为SPM中的依赖项。这为更广泛的用例开辟了道路。</p><p id="c7ca" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">Swift 5.3还提供了向SPM添加资源文件或非编译文件的功能，例如JSON、mp3或HTML。我在之前的文章“如何在Swift Package Manager 中添加资源<a class="ae ky" href="https://medium.com/better-programming/how-to-add-resources-in-swift-package-manager-c437d44ec593" rel="noopener">中讨论过这个问题</a></p><p id="a445" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我要说的就是感谢您花时间阅读这篇文章。我希望您可以在您的SPM项目中使用这个特性。</p></div></div>    
</body>
</html>