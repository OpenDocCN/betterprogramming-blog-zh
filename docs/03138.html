<html>
<head>
<title>The Power of Bitwise Operations in Swift</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Swift中位运算的威力</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/the-power-of-bitwise-operations-in-swift-ba7724d88648?source=collection_archive---------11-----------------------#2020-01-22">https://betterprogramming.pub/the-power-of-bitwise-operations-in-swift-ba7724d88648?source=collection_archive---------11-----------------------#2020-01-22</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="8ba1" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">降低空间复杂性</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/84cdf8289cd439081b325d22fe4a0f97.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*xrYcAxMayEEwPa_hCCwQbA.jpeg"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">图片来自<a class="ae ky" href="https://unsplash.com/photos/YYUM2sNvnvU" rel="noopener ugc nofollow" target="_blank"> Unsplash </a></p></figure><p id="3bd1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">任何解过数独的人都知道，答案来自于你所拥有的信息，对每一个后续决策都应用三条规则:</p><ol class=""><li id="fe52" class="lv lw it lb b lc ld lf lg li lx lm ly lq lz lu ma mb mc md bi translated">一个数字在每个3x3的方块中只能出现一次</li><li id="332f" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated">一个数字不能在同一行出现两次</li><li id="4ffb" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated">一个数字不能在同一列出现两次</li></ol><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi mj"><img src="../Images/9e926bf1b52913c141baeaa960b921cd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*jrMtAD1AAbDuEHtrnhAAXw.png"/></div></div></figure><p id="6a29" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">遵循这些规则，我们可以断言，在示例数独的第一个方块中，第二行不可能有1，但第二行肯定会包含7。通过排除法，你应该能够找到一个解，其中每个1x1正方形包含1到9之间的数字，每个3x3正方形、每行和每列包含1到9之间的所有数字。</p><p id="44a8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">假设我们想写一个程序来测试数独的当前状态，并断言它是否是一个有效的棋盘，或者是否违反了一些规则。</p><p id="f556" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">要编写一个数独检查器，我们所要做的就是为行填充一个真值表，为列填充一个真值表，为正方形填充一个真值表。这个真值表将告诉我们第I行/列/正方形是否已经包含一个数字。如果是这样，数独就不是处于有效状态。</p><p id="81b3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">以下是使用Swift编程语言的解决方案:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mk ml l"/></div></figure><p id="7191" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">作为输入，我们有一个9x9的字符矩阵。每个字符可以是1到9之间的一个数字，也可以是一个点，表示该位置仍然空闲。</p><p id="b55a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">首先，我们为规则构建真值表，然后我们逐行迭代，每列遍历整个棋盘。如果我们找到一个数字，我们会检查我们是否在同一行、同一列或同一方块中见过它。如果有，那么我们返回false。如果没有，我们更新我们的真值表，指出我们已经在当前访问的<code class="fe mm mn mo mp b">row</code>、<code class="fe mm mn mo mp b">col</code>和<code class="fe mm mn mo mp b">square</code>看到了这个数字。</p><p id="5009" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果我们设法运行到最后，所以程序在循环期间没有返回，那么没有违反规则，数独处于有效状态。因此，我们可以返回true。</p><p id="c401" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这个解决方案非常有效。一个数独游戏有九行九列，算法在固定时间内运行。就空间而言，我们分配了三个大小为81的矩阵。我们也可以有把握地说，空间复杂度是常数。</p><p id="4bf0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果我告诉你，你可以通过简单的三个大小为9的数组来节省更多的内存，那会怎么样？</p></div><div class="ab cl mq mr hx ms" role="separator"><span class="mt bw bk mu mv mw"/><span class="mt bw bk mu mv mw"/><span class="mt bw bk mu mv"/></div><div class="im in io ip iq"><h1 id="b29a" class="mx my it bd mz na nb nc nd ne nf ng nh jz ni ka nj kc nk kd nl kf nm kg nn no bi translated">二进制数</h1><p id="fbbb" class="pw-post-body-paragraph kz la it lb b lc np ju le lf nq jx lh li nr lk ll lm ns lo lp lq nt ls lt lu im bi translated">众所周知，每个数都可以用一个二进制数来表示，也称为以二为基数的数制。</p><p id="0f65" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这个数字系统的每个数字被称为一个<code class="fe mm mn mo mp b">bit</code>。一个位可以是0或1。1和0的位置很重要，因为在这个数字系统中，位置表示第I位代表的2的幂。最右边的位代表幂0。这个想法是，任何数字都可以表示为2的幂的和。</p><p id="ac5d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe mm mn mo mp b">0</code> = 0</p><p id="0e01" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe mm mn mo mp b">1</code> = 2 ^ 0 = 1</p><p id="9340" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe mm mn mo mp b">10</code> = 2 ^ 1 = 2</p><p id="d034" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe mm mn mo mp b">11</code> = 2 ^ 1 + 2 ^ 0 = 2 + 1 = 3</p><p id="3e1f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe mm mn mo mp b">100</code> = 2 ^ 2 = 4</p><p id="d3de" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">等等。</p></div><div class="ab cl mq mr hx ms" role="separator"><span class="mt bw bk mu mv mw"/><span class="mt bw bk mu mv mw"/><span class="mt bw bk mu mv"/></div><div class="im in io ip iq"><h1 id="4ae6" class="mx my it bd mz na nb nc nd ne nf ng nh jz ni ka nj kc nk kd nl kf nm kg nn no bi translated">移位操作</h1><p id="e014" class="pw-post-body-paragraph kz la it lb b lc np ju le lf nq jx lh li nr lk ll lm ns lo lp lq nt ls lt lu im bi translated">一位移位将一个数的二进制表示中的每一位向左或向右移动。</p><p id="0c08" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe mm mn mo mp b">00000010 &lt;&lt; 1</code> = <code class="fe mm mn mo mp b">00000100</code>(左移1位)</p><p id="5300" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe mm mn mo mp b">00000010 &lt;&lt; 2</code> = <code class="fe mm mn mo mp b">00001000</code>(左移2位)</p><p id="2f41" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">通过<code class="fe mm mn mo mp b">n</code>左移一个数将返回一个十进制数，例如原始十进制数乘以2 ^ <code class="fe mm mn mo mp b">n</code>。</p><p id="1d39" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">反之亦然—向右移位将导致原始数除以2 ^ <code class="fe mm mn mo mp b">n</code>。</p></div><div class="ab cl mq mr hx ms" role="separator"><span class="mt bw bk mu mv mw"/><span class="mt bw bk mu mv mw"/><span class="mt bw bk mu mv"/></div><div class="im in io ip iq"><h1 id="599c" class="mx my it bd mz na nb nc nd ne nf ng nh jz ni ka nj kc nk kd nl kf nm kg nn no bi translated">按位运算(&amp;和|)</h1><p id="54f2" class="pw-post-body-paragraph kz la it lb b lc np ju le lf nq jx lh li nr lk ll lm ns lo lp lq nt ls lt lu im bi translated">在本文中，为了解决有效数独问题，我们将重点讨论AND和or布尔运算。</p><p id="590f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">AND:给定两位<code class="fe mm mn mo mp b">x</code>和<code class="fe mm mn mo mp b">y</code>，<code class="fe mm mn mo mp b">x&amp;y</code> = 1当且仅当它们都为1</p><p id="6a04" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">或者:给定两位<code class="fe mm mn mo mp b">x</code>和<code class="fe mm mn mo mp b">y</code>，如果x或y为1，则<code class="fe mm mn mo mp b">x|y</code> = 1</p><p id="81d8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">请注意，这些是按位操作，这意味着它们在单个位的级别上操作位模式。</p><p id="d62f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe mm mn mo mp b">101 &amp; 001</code> = <code class="fe mm mn mo mp b">1&amp;0 0&amp;0 1&amp;1</code> = <code class="fe mm mn mo mp b">001</code></p><p id="ec46" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe mm mn mo mp b">101 | 001</code> = <code class="fe mm mn mo mp b">1|0 0|0 1|1</code> = <code class="fe mm mn mo mp b">101</code></p><p id="46e8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">请注意，<code class="fe mm mn mo mp b">&amp;</code>对于了解位模式中的某个位置是否已经填充了1特别有用，因为如果没有，结果将是0</p><p id="63ff" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe mm mn mo mp b">11011 &amp; 00100</code> = <code class="fe mm mn mo mp b">1&amp;0 1&amp;0 0&amp;1 1&amp;0 1&amp;0</code> = <code class="fe mm mn mo mp b">00000</code> = 0</p><p id="ef43" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">而<code class="fe mm mn mo mp b">|</code>对于用1填充0位特别有用。</p><p id="e8dc" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe mm mn mo mp b">11011 | 00100</code> = <code class="fe mm mn mo mp b">1|0 1|0 0|1 1|0 1|0</code> = <code class="fe mm mn mo mp b">11111</code></p><p id="a793" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">明白我要去哪里了吗？</p></div><div class="ab cl mq mr hx ms" role="separator"><span class="mt bw bk mu mv mw"/><span class="mt bw bk mu mv mw"/><span class="mt bw bk mu mv"/></div><div class="im in io ip iq"><h1 id="483f" class="mx my it bd mz na nb nc nd ne nf ng nh jz ni ka nj kc nk kd nl kf nm kg nn no bi translated">新的解决方案</h1><p id="e6a7" class="pw-post-body-paragraph kz la it lb b lc np ju le lf nq jx lh li nr lk ll lm ns lo lp lq nt ls lt lu im bi translated">我们可以不使用布尔数组的数组，而是使用一个<code class="fe mm mn mo mp b">UInt16</code>作为布尔数组，并使用&amp;操作来检查我们是否已经看到了一个数字，同时使用|操作来更新我们的真值表。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mk ml l"/></div></figure><p id="e628" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">算法是一样的，除了我们使用了一个<code class="fe mm mn mo mp b">UInt16</code>，就像它是一个bool数组一样。变量<code class="fe mm mn mo mp b">value</code>基本上代表我们想要测试的位模式中的“槽”。一个<code class="fe mm mn mo mp b">UInt16</code>将有16个可用位，我们将使用最右边的9个。</p><p id="0878" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们假设在我们的例子中，同一行上有两个5:一个在[0][0]处，一个在[0][2]处(所以我们试图在本文开头的例子的第一个空格中插入5。</p><p id="4c7d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu">第一次迭代</strong> : <em class="nu">行</em> = 0，<em class="nu">列</em> = 0。</p><p id="aa10" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">棋盘上的位置[0][0]的数字是5，值将是<code class="fe mm mn mo mp b">1 &lt;&lt; (5-1)</code> = <code class="fe mm mn mo mp b">1 &lt;&lt; 4</code> = <code class="fe mm mn mo mp b">10000</code></p><p id="a22e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe mm mn mo mp b">rows[0]</code>当前为0，因此检查<code class="fe mm mn mo mp b">value &amp; rows[0]</code> = <code class="fe mm mn mo mp b">10000 &amp; 00000</code> = 0，因此检查成功。对于<code class="fe mm mn mo mp b">cols[0]</code>和<code class="fe mm mn mo mp b">squares[0]</code>也是如此。</p><p id="ebce" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们以前从未见过5，所以我们更新了我们的真值表。</p><p id="9334" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe mm mn mo mp b">rows[0] |= value</code> = <code class="fe mm mn mo mp b">00000 | 10000</code> = <code class="fe mm mn mo mp b">10000</code></p><p id="a3ce" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe mm mn mo mp b">cols[0] |= value</code> = <code class="fe mm mn mo mp b">00000 | 10000</code> = <code class="fe mm mn mo mp b">10000</code></p><p id="5a8d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe mm mn mo mp b">squares[0] |= value</code> = <code class="fe mm mn mo mp b">00000 | 10000</code> = <code class="fe mm mn mo mp b">10000</code></p><p id="f24c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu">第二次迭代</strong> : <em class="nu">行</em> = 0，<em class="nu">列</em> = 1</p><p id="e518" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">[0][1]处的数字是3，因此<code class="fe mm mn mo mp b">value</code>将是<code class="fe mm mn mo mp b">1 &lt;&lt; (3-1)</code> = <code class="fe mm mn mo mp b">1 &lt;&lt; 2</code> = <code class="fe mm mn mo mp b">100</code></p><p id="6b91" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe mm mn mo mp b">rows[0]</code>现在是<code class="fe mm mn mo mp b">10000</code>所以这次也是<code class="fe mm mn mo mp b">rows[0] &amp; 100</code> = <code class="fe mm mn mo mp b">10000 &amp; 100</code> = 0。</p><p id="2090" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">对于<code class="fe mm mn mo mp b">squares[0]</code>和<code class="fe mm mn mo mp b">cols[1]</code>也是如此(仍然是0，因为这是我们第一次访问第1列)。</p><p id="75d0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们以前从未见过3，所以我们更新了我们的真值表。</p><p id="0382" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe mm mn mo mp b">rows[0] |= value</code> = <code class="fe mm mn mo mp b">10000 | 00100</code> = <code class="fe mm mn mo mp b">10100</code></p><p id="a4af" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe mm mn mo mp b">cols[1] |= value</code> = <code class="fe mm mn mo mp b">000 | 100</code> = <code class="fe mm mn mo mp b">100</code></p><p id="1719" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe mm mn mo mp b">squares[0] |= value</code> = <code class="fe mm mn mo mp b">10000 | 00100</code> = <code class="fe mm mn mo mp b">10100</code></p><p id="f371" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu">第三次迭代</strong> : <em class="nu">行</em> = 0，<em class="nu">列</em> = 2</p><p id="fd46" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们试图在棋盘上先前空着的这个位置插入5，所以[0][3]我们假设是5。值将再次变为<code class="fe mm mn mo mp b">1 &lt;&lt; (5-1)</code> = <code class="fe mm mn mo mp b">1 &lt;&lt; 4</code> = <code class="fe mm mn mo mp b">10000</code></p><p id="9079" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe mm mn mo mp b">rows[0]</code>现在是<code class="fe mm mn mo mp b">10100</code>和<code class="fe mm mn mo mp b">rows[0] &amp; 10000</code> = <code class="fe mm mn mo mp b">10100 &amp; 10000</code> = <code class="fe mm mn mo mp b">10000</code>不等于0。这足以说明这个板子是无效的，返回false，但是即使我们继续我们的程序，5也会违反<code class="fe mm mn mo mp b">squares[0]</code>但不会违反<code class="fe mm mn mo mp b">cols[2]</code>，因为这是我们第一次访问这个专栏，而5以前在这个专栏上出现过。</p><p id="d08c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">5违反了行规则和平方规则。</p></div><div class="ab cl mq mr hx ms" role="separator"><span class="mt bw bk mu mv mw"/><span class="mt bw bk mu mv mw"/><span class="mt bw bk mu mv"/></div><div class="im in io ip iq"><h1 id="87d6" class="mx my it bd mz na nb nc nd ne nf ng nh jz ni ka nj kc nk kd nl kf nm kg nn no bi translated"><strong class="ak">结论</strong></h1><p id="2964" class="pw-post-body-paragraph kz la it lb b lc np ju le lf nq jx lh li nr lk ll lm ns lo lp lq nt ls lt lu im bi translated">显然，在这个特定的问题中，增益很小。我们从3个各有81个布尔值的数组传递到3个9 - 16位无符号整数的数组，但是这种技术可以转移到其他问题，在这些问题中，真值表的大小可能不再可以忽略。</p><p id="3efc" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">下一次我们将会看到如何使用更多的位操作符找到任何数独的解。</p></div></div>    
</body>
</html>