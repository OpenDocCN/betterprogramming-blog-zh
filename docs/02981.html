<html>
<head>
<title>Deep Copy in JavaScript — Things You Have Thought It’s Right</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">JavaScript中的深层拷贝——您认为正确的东西</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/sadly-you-cant-deep-copy-an-object-with-native-javascript-methods-f12127809cca?source=collection_archive---------10-----------------------#2020-01-13">https://betterprogramming.pub/sadly-you-cant-deep-copy-an-object-with-native-javascript-methods-f12127809cca?source=collection_archive---------10-----------------------#2020-01-13</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="4327" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">在JavaScript中，没有办法深度复制一个对象。听我说完</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/702beb782a4e93d456d22dadd7e6c7ff.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*BX05xGJBQnCGhRQR52rClQ.jpeg"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">约书亚·科尔曼在<a class="ae ky" href="https://unsplash.com/s/photos/multiples?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</p></figure><p id="4ed0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">抱歉，各位，这不是一个点击诱饵的帖子。不幸的是，到目前为止你所知道的复制数组或对象的方法并不是复制它们的最佳方法。事实上，做这件事没有完美的方法。我知道你们中的一些人已经开始寻找底部的“写回应”按钮来反对我，但我也很震惊。让我们看看这里发生了什么。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="d776" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">放弃</h1><p id="1ce1" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">我将提到复制值的常见方法。如果你像<a class="ae ky" href="https://lodash.com/" rel="noopener ugc nofollow" target="_blank"> Lodash </a>或<a class="ae ky" href="https://ramdajs.com/" rel="noopener ugc nofollow" target="_blank"> Ramda </a>那样编写你的复制方法，也许可以完美地复制它们。另外，在未来，可能会有一个解决方案。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="a8c6" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">让我们创建一个Checker方法</h1><p id="feb9" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">我想比较两个对象之间的内容:原始源和新创建的源。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mz na l"/></div></figure><p id="775d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">它执行起来非常简单。如果对象内部的值不相同，它返回<code class="fe nb nc nd ne b">false</code>。你可以在Ramda文档中<a class="ae ky" href="https://ramdajs.com/docs/#equals" rel="noopener ugc nofollow" target="_blank">了解更多关于</a> <code class="fe nb nc nd ne b"><a class="ae ky" href="https://ramdajs.com/docs/#equals" rel="noopener ugc nofollow" target="_blank">equals</a> </code>的信息。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="61db" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">数组.原型.切片</h1><p id="f811" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">这可能是复制数组最简单的方法之一。<code class="fe nb nc nd ne b">Array.prototype.slice</code>从<em class="nf">开始</em>到<em class="nf">结束</em>位置复制一个数组。如果<em class="nf">开始</em>和<em class="nf">结束</em>没有显示，则从第一个步进执行到最后一个步进。</p><pre class="kj kk kl km gt ng ne nh bn ni nj bi"><span id="4030" class="nk md it ne b be nl nm l nn no">const arr = [1, 2, 3];<br/>const copied = arr.slice();<br/><br/>checker(arr, copied); // true<br/><br/>copied.push(4);<br/>checker(arr, copied); // false</span></pre><p id="554a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">内容好像是抄袭的。但是，<code class="fe nb nc nd ne b">Array.prototype.slice</code>不能复制嵌套的结构化数组。</p><pre class="kj kk kl km gt ng ne nh bn ni nj bi"><span id="471b" class="nk md it ne b be nl nm l nn no">const arr = [1, 2, [3, 4]];<br/>const copied = arr.slice();<br/><br/>checker(arr, copied); // true<br/><br/>copied[2].push(5);<br/>checker(arr, copied); // true<br/>~~~~~~~<br/>// This shouldn't return true anymore</span></pre><p id="0e68" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">虽然<code class="fe nb nc nd ne b">copied</code>必须与<code class="fe nb nc nd ne b">arr</code>截然不同，但他们的价值观是一样的。这是因为<code class="fe nb nc nd ne b">Array.prototype.slice</code>是一个浅拷贝方法，这意味着它不能深拷贝一个对象。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="2494" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">传播算子</h1><p id="36ab" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">JavaScript中的spread操作符在内部执行迭代器循环操作。如果对象是可迭代的，也就是说如果它有<code class="fe nb nc nd ne b">[Symbol.iterator]</code>在里面，它可以被循环。对内，<code class="fe nb nc nd ne b">const b = [ ...a ]</code>如下。</p><pre class="kj kk kl km gt ng ne nh bn ni nj bi"><span id="2b3b" class="nk md it ne b be nl nm l nn no">if (!(Typeof(a) is Iterable)) {<br/>  throw TypeError<br/>}<br/><br/>var b = [];<br/>for (var i = 0; i &lt; a.length; i += 1) {<br/>  b.push(a[i]);<br/>}</span></pre><p id="7101" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">复制的数组和原始数组的比较如下。</p><pre class="kj kk kl km gt ng ne nh bn ni nj bi"><span id="6ecf" class="nk md it ne b be nl nm l nn no">const arr = [1, 2, [3, 4]];<br/>const copied = [ ...arr ];<br/><br/>checker(arr, copied); // true<br/><br/>copied[2].push(5);<br/>checker(arr, copied); // true<br/>~~~~~~~<br/>// It should've been false</span></pre><p id="356f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这意味着您也不能使用spread操作符执行深度复制。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="ab93" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">对象.分配</h1><p id="d63f" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">不幸的是，<code class="fe nb nc nd ne b">Object.assign</code>并没有完美地复制你的对象。</p><pre class="kj kk kl km gt ng ne nh bn ni nj bi"><span id="8fea" class="nk md it ne b be nl nm l nn no">const arr = [1, 2, [3, 4]];<br/>const copied = Object.assign([], arr);<br/><br/>checker(arr, copied); // true<br/><br/>copied[2].push(5);<br/>checker(arr, copied); // true<br/>~~~~~~~<br/>// It should've been false</span></pre><p id="2357" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">MDN文档警告关于深度克隆对象的<code class="fe nb nc nd ne b">Object.assign</code>:</p><blockquote class="np nq nr"><p id="e313" class="kz la nf lb b lc ld ju le lf lg jx lh ns lj lk ll nt ln lo lp nu lr ls lt lu im bi translated">“对于深度克隆，我们需要使用替代方案，因为<code class="fe nb nc nd ne b">Object.assign()</code>复制属性值。如果源值是对对象的引用，它只复制该引用值。</p></blockquote></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="c055" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">JSON.parse w/ JSON.stringify</h1><p id="39dd" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">然而，这种方法可以解决上述方法存在的问题。从一个给定的对象生成一个字符串，将每个值转换成字符串的正确形式。</p><p id="8658" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">然后，您可以将字符串值解析成JSON对象。因为您解析的字符串是由原始对象构成的，并且是一个不可变的原始值，所以转换后的JSON对象也不会侵入原始源的领域。</p><pre class="kj kk kl km gt ng ne nh bn ni nj bi"><span id="9130" class="nk md it ne b be nl nm l nn no">const arr = [1, 2, [3, 4]];<br/>const copied = JSON.parse(JSON.stringify(arr));<br/><br/>checker(arr, copied); // true<br/><br/>copied[2].push(5);<br/>checker(arr, copied); // false</span></pre><p id="4671" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在，<code class="fe nb nc nd ne b">copied</code>终于与<code class="fe nb nc nd ne b">arr</code>截然不同了。嵌套结构似乎复制正确。</p><p id="40b5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">然而不幸的是，这不能复制日期对象。</p><pre class="kj kk kl km gt ng ne nh bn ni nj bi"><span id="7f2d" class="nk md it ne b be nl nm l nn no">const obj = { d: new Date() };<br/>const copied = JSON.parse(JSON.stringify(obj));<br/><br/>checker(obj, copied); // false</span></pre><p id="c560" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">为什么？</p><div class="kj kk kl km gt ab cb"><figure class="nv kn nw nx ny nz oa paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><img src="../Images/2c42c0c9b0da79770272520f4769902b.png" data-original-src="https://miro.medium.com/v2/resize:fit:936/format:webp/1*N6tkLVICFvr48tGnRYgryQ.png"/></div></figure><figure class="nv kn ob nx ny nz oa paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><img src="../Images/c7b147b10392c544ab31ad309f8f7877.png" data-original-src="https://miro.medium.com/v2/resize:fit:1066/format:webp/1*C5LzRTilDYxhPJIhDYd7Gg.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk oc di od oe translated">obj在左边/复制在右边</p></figure></div><p id="044b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">当日期对象值由<code class="fe nb nc nd ne b">JSON.stringify</code>执行时，<code class="fe nb nc nd ne b">JSON.stringify</code>运行其<code class="fe nb nc nd ne b">toString</code>。所以实际的字符串值被改变了，尽管它们的内容是相同的。</p><p id="8ebc" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">问题不在这里。在最新版本的ECMAScript 2020中，<code class="fe nb nc nd ne b">BigInt</code>作为一个新特性被添加进来。有了<code class="fe nb nc nd ne b">BigInt</code> s，你甚至因为错误得不到结果。</p><pre class="kj kk kl km gt ng ne nh bn ni nj bi"><span id="d685" class="nk md it ne b be nl nm l nn no">JSON.stringify(BigInt(1));<br/>~~~~~~~~~~~~~~<br/>// Uncaught TypeError<br/>// Do not know how to serialize a BigInt</span></pre><p id="3e26" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">与本文前面介绍的方法不同，您不能传递非循环的对象<code class="fe nb nc nd ne b">JSON.stringify</code>。</p><pre class="kj kk kl km gt ng ne nh bn ni nj bi"><span id="1df8" class="nk md it ne b be nl nm l nn no">const a = [];<br/>a[0] = a;<br/><br/>JSON.stringify(a);<br/>// Uncaught TypeError<br/>// Converting circular structure to JSON</span></pre><p id="49fd" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">而且函数是不能被<code class="fe nb nc nd ne b">JSON.stringify</code>复制的。</p><pre class="kj kk kl km gt ng ne nh bn ni nj bi"><span id="208c" class="nk md it ne b be nl nm l nn no">const arr = [function(){}, () =&gt;{}];<br/>const copied = JSON.parse(JSON.stringify(arr));<br/><br/>checker(arr, copied); // false</span></pre><div class="kj kk kl km gt ab cb"><figure class="nv kn of nx ny nz oa paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><img src="../Images/1620910c03785087f32689dae1f95984.png" data-original-src="https://miro.medium.com/v2/resize:fit:1018/format:webp/1*WiJjbO1gJXHQZ7qOVwqW_Q.png"/></div></figure><figure class="nv kn og nx ny nz oa paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><img src="../Images/48b676065b8e998623370b28032d7f2c.png" data-original-src="https://miro.medium.com/v2/resize:fit:984/format:webp/1*AYv-LqUV_J9lW9Jf8q5aLQ.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk oh di oi oe translated">左边arr右边copy</p></figure></div><p id="56b7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">ECMAScript的真名是ECMA-262。JSON的另一个ECMA有单独的文档。它的名字是ECMA-404。在ECMA-404的文档中，你可以看到这个图。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi oj"><img src="../Images/fcab89cdaa93a643ed336dc90e35160f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*9VEw8TkONXKd9hnYBRT5wQ.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">图片来自<a class="ae ky" href="https://www.ecma-international.org/publications/files/ECMA-ST/ECMA-404.pdf" rel="noopener ugc nofollow" target="_blank"> ECMA-404文档</a></p></figure><p id="ab60" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">只有表示的数据类型可以作为JSON值。没有功能。</p><p id="1031" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">JavaScript的ECMA-262提到了一些不被认为是JSON值的值:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ok"><img src="../Images/f0c4f38beb6aadf254aa577b7a5fc7cd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*MKvxAOL2d_unGb5gpPyfYw.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">图片来源:ECMA-262</p></figure><pre class="kj kk kl km gt ng ne nh bn ni nj bi"><span id="fb66" class="nk md it ne b be nl nm l nn no">JSON.stringify(function() {})     // undefined<br/>JSON.stringify([function() {}])   // [null]<br/>JSON.stringify({f: function() {}) // {}<br/>JSON.stringify({f: () =&gt; {})      // {}<br/>JSON.stringify({d: undefined})    // {}</span></pre></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="9396" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">定制的深度克隆:洛达什和拉姆达</h1><p id="5d09" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">你可以很容易地在StackOverflow中找到一些文章，在这些文章中人们推荐使用Lodash中的<code class="fe nb nc nd ne b">cloneDeep</code>进行深度克隆。此外，我使用Ramda，所以我也对它进行了测试。让我们看看它们是否正常工作。</p><div class="kj kk kl km gt ab cb"><figure class="nv kn ol nx ny nz oa paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><img src="../Images/1aa7012ea1ab5d62d8311bdcbe20cf2f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1008/format:webp/1*CN_p_yarpJHLL1EW45y9HQ.png"/></div></figure><figure class="nv kn om nx ny nz oa paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><img src="../Images/9c67a4a4912bc1a63f1c4a2efe3091e9.png" data-original-src="https://miro.medium.com/v2/resize:fit:994/format:webp/1*MusI3gebN5sl_iLr3b7vcg.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk on di oo oe translated">洛达什在左边/拉姆达在右边</p></figure></div><p id="06d8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">令人惊讶和有趣的是，他们工作得非常好。你可能会问:“你不是说我们不能复制它们吗？”没错。但是你难道不好奇他们是如何让它运转良好的吗？</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mz na l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">洛达什的克隆方法</p></figure><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mz na l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">Ramda中的克隆方法</p></figure><p id="c887" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">它们的共同点是，它们都通过循环复制对象，检查对象的每个属性的类型，并在需要时通过用另一种方法包装它来将其转换为正确的格式。换句话说，他们为此定制了方法。</p><p id="164d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">是否安装软件包并导入您需要的模块完全取决于您。</p><p id="add5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><a class="op oq ep" href="https://medium.com/u/dcf6de04e0fd?source=post_page-----f12127809cca--------------------------------" rel="noopener" target="_blank">Jordan har band</a><a class="ae ky" href="https://tc39.es/" rel="noopener ugc nofollow" target="_blank">TC39</a>成员，曾评论过为什么不能用<code class="fe nb nc nd ne b">Object.assign</code>做深度复制的问题。他说他宁愿重建这个物体。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi or"><img src="../Images/d73322205b6b191e73c2cf2f1a165b2b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*xjJAPktK_I4kFrnnY8PHRA.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated"><a class="ae ky" href="https://github.com/tc39/ecma262/issues/1319" rel="noopener ugc nofollow" target="_blank">https://github.com/tc39/ecma262/issues/1319</a></p></figure><p id="4069" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">您可能希望在GitHub中查看与该主题相关的问题:</p><ul class=""><li id="d01f" class="os ot it lb b lc ld lf lg li ou lm ov lq ow lu ox oy oz pa bi translated"><a class="ae ky" href="https://github.com/tc39/ecma262/issues/1319" rel="noopener ugc nofollow" target="_blank">https://github.com/tc39/ecma262/issues/1319</a></li><li id="280e" class="os ot it lb b lc pb lf pc li pd lm pe lq pf lu ox oy oz pa bi translated"><a class="ae ky" href="https://github.com/tc39/ecma262/issues/1840" rel="noopener ugc nofollow" target="_blank">https://github.com/tc39/ecma262/issues/1840</a></li></ul></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="0943" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">结论</h1><p id="6594" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">使用JavaScript的本地方法无法深度复制对象。每种方法都有一个或多个条件来制作一个完全不同的复制对象。例如，<code class="fe nb nc nd ne b">Array.prototype.slice</code>只在原始数组内部没有嵌套的结构化值时才有效。</p><p id="3f6e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我建议你做的是，像<a class="op oq ep" href="https://medium.com/u/dcf6de04e0fd?source=post_page-----f12127809cca--------------------------------" rel="noopener" target="_blank">乔丹·哈班德</a>说的那样，通过脆弱的方式克隆一个你不必担心副作用的对象，而不是安装不必要的软件包。然而，如果你的项目一直在使用那种包，那么使用像<code class="fe nb nc nd ne b">_.cloneDeep</code>这样的复制方法就可以了。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="e988" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">资源</h1><ul class=""><li id="d728" class="os ot it lb b lc mu lf mv li pg lm ph lq pi lu ox oy oz pa bi translated"><a class="ae ky" href="https://ramdajs.com/docs/#equals" rel="noopener ugc nofollow" target="_blank">等于— ramda.js </a></li><li id="630a" class="os ot it lb b lc pb lf pc li pd lm pe lq pf lu ox oy oz pa bi translated"><a class="ae ky" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/slice" rel="noopener ugc nofollow" target="_blank">array . prototype . slice—MDN</a></li><li id="a8f3" class="os ot it lb b lc pb lf pc li pd lm pe lq pf lu ox oy oz pa bi translated"><a class="ae ky" href="https://tc39.es/ecma262/#sec-runtime-semantics-arrayaccumulation" rel="noopener ugc nofollow" target="_blank">运行时语义:ArrayAccumulation — ECMAScript规范</a></li><li id="3160" class="os ot it lb b lc pb lf pc li pd lm pe lq pf lu ox oy oz pa bi translated"><a class="ae ky" href="http://ecma-international.org/ecma-262/10.0/index.html#sec-json.stringify" rel="noopener ugc nofollow" target="_blank"> JSON.stringify — ECMAScript规范</a></li><li id="58ab" class="os ot it lb b lc pb lf pc li pd lm pe lq pf lu ox oy oz pa bi translated"><a class="ae ky" href="https://www.ecma-international.org/publications/files/ECMA-ST/ECMA-404.pdf" rel="noopener ugc nofollow" target="_blank"> ECMA-404，JSON </a></li><li id="d031" class="os ot it lb b lc pb lf pc li pd lm pe lq pf lu ox oy oz pa bi translated"><a class="ae ky" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/assign" rel="noopener ugc nofollow" target="_blank"> Object.assign — MDN </a></li><li id="0f6c" class="os ot it lb b lc pb lf pc li pd lm pe lq pf lu ox oy oz pa bi translated"><a class="ae ky" href="https://github.com/lodash/lodash" rel="noopener ugc nofollow" target="_blank"> Lodash — Github </a></li><li id="285a" class="os ot it lb b lc pb lf pc li pd lm pe lq pf lu ox oy oz pa bi translated"><a class="ae ky" href="https://github.com/ramda/ramda" rel="noopener ugc nofollow" target="_blank">拉姆达— Github </a></li></ul></div></div>    
</body>
</html>