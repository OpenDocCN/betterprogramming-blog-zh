<html>
<head>
<title>Go API Design With Protocol Buffers and gRPC</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用协议缓冲区和gRPC的Go API设计</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/go-api-design-with-protocol-buffers-and-grpc-991838e4852b?source=collection_archive---------2-----------------------#2022-05-19">https://betterprogramming.pub/go-api-design-with-protocol-buffers-and-grpc-991838e4852b?source=collection_archive---------2-----------------------#2022-05-19</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="bf46" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">基于社交媒体应用的分步指南</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/aad449f87575861397540a47d1e7adb0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*lJu8bnI-h8x1nYJG5SF2Jw.png"/></div></div></figure><p id="62c4" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">当使用gRPC构建API时，API设计通常使用协议缓冲区来定义API端点、请求消息和响应消息。这通常是通过使用proto文件来完成的，稍后可以使用proto文件来生成go代码以进行实际的RPC调用，还可以生成一个反向代理来将gRPC翻译成JSON APIs等。</p><p id="47ed" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">我建议按以下顺序阅读这些文章:</p><ol class=""><li id="d532" class="lq lr it kw b kx ky la lb ld ls lh lt ll lu lp lv lw lx ly bi translated">使用协议缓冲区和gRPC的Go API设计</li><li id="a583" class="lq lr it kw b kx lz la ma ld mb lh mc ll md lp lv lw lx ly bi translated"><a class="ae me" rel="noopener ugc nofollow" target="_blank" href="/building-reverse-proxy-grpc-gateway-621696b29b0">建立反向代理(gRPC-Gateway) </a></li><li id="e0aa" class="lq lr it kw b kx lz la ma ld mb lh mc ll md lp lv lw lx ly bi translated"><a class="ae me" href="https://yairfernando.medium.com/go-api-database-connection-d47e463cea37" rel="noopener"> Go API —数据库连接</a></li></ol><p id="4a33" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">在本文中，我们将重点关注以下内容:</p><ul class=""><li id="d4ce" class="lq lr it kw b kx ky la lb ld ls lh lt ll lu lp mf lw lx ly bi translated">使用协议缓冲区构建API设计</li><li id="f810" class="lq lr it kw b kx lz la ma ld mb lh mc ll md lp mf lw lx ly bi translated">创建端点</li><li id="840b" class="lq lr it kw b kx lz la ma ld mb lh mc ll md lp mf lw lx ly bi translated">定义请求消息</li><li id="7920" class="lq lr it kw b kx lz la ma ld mb lh mc ll md lp mf lw lx ly bi translated">定义响应消息</li><li id="4ce0" class="lq lr it kw b kx lz la ma ld mb lh mc ll md lp mf lw lx ly bi translated">使用可枚举数</li><li id="a39c" class="lq lr it kw b kx lz la ma ld mb lh mc ll md lp mf lw lx ly bi translated">处理时间戳</li><li id="6a41" class="lq lr it kw b kx lz la ma ld mb lh mc ll md lp mf lw lx ly bi translated">返回空响应</li></ul><p id="ed74" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">我不会详细介绍gRPC是什么，或者为什么应该使用协议缓冲区而不是JSON，但是如果您有兴趣了解更多，这里有另一篇<a class="ae me" href="https://levelup.gitconnected.com/grpc-how-to-make-effective-unary-calls-4c9fa68cd9d5" rel="noopener ugc nofollow" target="_blank">文章</a>对此有更多的解释。</p><p id="28e3" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">对于本文，API设计将基于一个社交媒体应用程序。</p><p id="a809" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">在开始之前，重要的是要提到我将使用Go模块。因此，为了继续本系列，有必要让Go模块在您的机器上正常工作，因为我们稍后将在Go应用程序中测试API。</p><p id="bd32" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">首先，让我们使用以下命令导航到$GOPATH:</p><pre class="kj kk kl km gt mg mh mi mj aw mk bi"><span id="2aa3" class="ml mm it mh b gy mn mo l mp mq">cd $GOPATH</span></pre><p id="444d" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">然后创建或导航到以下路径:</p><pre class="kj kk kl km gt mg mh mi mj aw mk bi"><span id="beb9" class="ml mm it mh b gy mn mo l mp mq">cd src/github.com/YourGithubHandle/sma</span></pre><p id="a6ba" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">现在创建这个路径对以后会有帮助，因为我们最终会将这个代码推送到GitHub。</p><p id="149a" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">一旦我们进入代表社交媒体应用的<code class="fe mr ms mt mh b">sma</code>文件夹，让我们初始化一个Go模块。</p><pre class="kj kk kl km gt mg mh mi mj aw mk bi"><span id="e018" class="ml mm it mh b gy mn mo l mp mq">go mod init github.com/YourGithubHandle/sma</span></pre><p id="62ac" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">这个命令将为我们创建<code class="fe mr ms mt mh b">go.mod</code>文件。</p><p id="59d1" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">然后我们将在protos下创建<code class="fe mr ms mt mh b">posts.proto</code>文件。</p><p id="52ad" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">因此，让我们创建该文件夹并将<code class="fe mr ms mt mh b">posts.proto</code>文件放入其中。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi mu"><img src="../Images/fb1a043aa8d58594db15ae1433ae35e0.png" data-original-src="https://miro.medium.com/v2/resize:fit:708/format:webp/1*gynYdq1EnrIWHHlIeNHxrg.png"/></div></div></figure><p id="fa89" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">我们将首先定义创建端点。这个端点将接收一个带有一些参数的请求消息，它将返回一个响应消息，通知我们post对象已经创建。</p><p id="7a3e" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">让我们看看下面的定义:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mv mw l"/></div></figure><p id="8566" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">这个proto文件的第一行定义了我们使用的proto语法。在这种情况下，这就是proto3语法。如果没有指定这一行，protobuf编译器将假设使用了proto2语法。如果你想进一步了解它们的区别，这里有<a class="ae me" href="https://developers.google.com/protocol-buffers/docs/proto3" rel="noopener ugc nofollow" target="_blank"> proto3 </a>和<a class="ae me" href="https://developers.google.com/protocol-buffers/docs/proto" rel="noopener ugc nofollow" target="_blank"> proto2 </a>的文档。</p><p id="eab0" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">在第3行，我们有了包定义。如果您需要在不同的包名下定义相同的消息定义，这可以帮助您避免名称冲突。</p><p id="e63b" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">然后我们还有<code class="fe mr ms mt mh b">option go_package</code>。在Golang的例子中，这将被用作包名，但是在这个例子中，它与原来的包名相同。如果你需要它与众不同，你可以使用这个选项。</p><p id="7bf0" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">然后我们有一个进口。这个导入允许我们正确地序列化<code class="fe mr ms mt mh b">created_at</code>和<code class="fe mr ms mt mh b">updated_at</code>时间戳。这个导入实际上是protobuf将用来处理时间戳的另一个proto文件<code class="fe mr ms mt mh b"><a class="ae me" href="https://github.com/protocolbuffers/protobuf/blob/main/src/google/protobuf/timestamp.proto" rel="noopener ugc nofollow" target="_blank">timestamp.proto</a></code>。就像我们导入这个外部原型文件一样，我们将出于不同的目的使用其他外部原型文件。</p><p id="d38c" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">此外，如果需要，我们可以使用我们拥有的其他原型文件中的定义，包括不是来自Google的定义。我们稍后会谈到这一点。</p><p id="9d97" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">在第9行，我们有帖子的服务定义。通过在proto文件中定义服务，我们可以在协议缓冲编译器使用这个文件时生成Go代码。它将生成包含所有代码的服务器和客户端接口来进行RPC调用。</p><p id="22a6" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">我们定义了我们希望在该服务中支持的端点。在本例中，我们有一个创建post端点，它接受<code class="fe mr ms mt mh b">CreatePostReq</code>并返回创建的<code class="fe mr ms mt mh b">Post</code>对象。</p><p id="2b56" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">我们先来关注一下<code class="fe mr ms mt mh b">CreatePostReq</code>消息。</p><p id="3d07" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">该消息定义了该端点将在请求中接受的参数。</p><p id="7951" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">该结构首先定义字段的类型，然后是字段的名称，最后是字段的编号。</p><p id="3dc4" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">字段的<code class="fe mr ms mt mh b">type</code>指定该参数的数据类型，可以是字符串、整数、布尔、浮点、双精度、字节等。</p><p id="6876" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">字段的<code class="fe mr ms mt mh b">name</code>只是参数本身的名称。</p><p id="c109" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">字段的<code class="fe mr ms mt mh b">number</code>是用于识别二进制格式的每个字段的唯一数字。并且一旦您的消息类型已经被使用，就不应该改变。这里需要注意的一点是，你应该尽量为你的信息中最重要和最频繁的字段保留1到15的数字。</p><p id="da58" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">这是因为从1到15的字段编号需要一个字节来编码，而从16到2047需要两个字节。因此，如果一条消息中有10个从1到10的字段，然后有两个字段的字段编号大于15，这是完全没有问题的，因为您希望为未来的字段保留这五个编号。</p><p id="74e2" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">关于这个<code class="fe mr ms mt mh b">CreatePostReq</code>消息，最后要提到的是最后一个字段在定义的开头有一个额外的单词。这是因为最后一个参数是一个数组，在协议缓冲区中表示它的方式是在字段定义的开头使用<code class="fe mr ms mt mh b">repeated</code>字。重复字段的默认值将是一个空列表或数组，这取决于该消息被翻译成的编程语言。</p><p id="ed8d" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">现在让我们检查一下<code class="fe mr ms mt mh b">Post</code>消息的定义。前四个字段是不言自明的，所以让我们转到status字段。这里我们使用enum(在第50行中定义)作为字段的类型。使用枚举将确保该字段只接受枚举中的一个选项。如果没有传递值，字段编号为0的枚举值将是默认值。</p><p id="5e6d" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">枚举的几个注意事项是它必须有一个零值，因为零值被认为是默认值。另一件事是，为了与proto2语法兼容，零值必须是枚举中的第一个元素。</p><p id="bc1e" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">最后，我们在<code class="fe mr ms mt mh b">Post</code>消息中有创建和更新的字段，这里字段的类型是<code class="fe mr ms mt mh b">google.protobuf.Timestamp</code>，它又有另一个protobuf消息，有两个字段:秒和毫微秒。</p></div><div class="ab cl mx my hx mz" role="separator"><span class="na bw bk nb nc nd"/><span class="na bw bk nb nc nd"/><span class="na bw bk nb nc"/></div><div class="im in io ip iq"><p id="73bd" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">我们将向这个文件添加更多的端点，但是现在，让我们继续为这个原型文件生成go代码。</p><p id="d4cc" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">首先，让我们用这个命令安装protobuf:</p><pre class="kj kk kl km gt mg mh mi mj aw mk bi"><span id="28cc" class="ml mm it mh b gy mn mo l mp mq">brew install protobuf</span></pre><p id="2ac0" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">我们还需要安装protoco-gen-go和protoco-gen-go-grpc，如下所示:</p><pre class="kj kk kl km gt mg mh mi mj aw mk bi"><span id="9855" class="ml mm it mh b gy mn mo l mp mq">go install google.golang.org/protobuf/cmd/protoc-gen-go@latest<br/>go install google.golang.org/grpc/cmd/protoc-gen-go-grpc@latest</span></pre><p id="4015" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">然后确保你更新你的路径</p><pre class="kj kk kl km gt mg mh mi mj aw mk bi"><span id="7dc1" class="ml mm it mh b gy mn mo l mp mq">export PATH="$PATH:$(go env GOPATH)/bin"</span></pre><p id="6c2b" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">之后，确保“启用模块”打开</p><pre class="kj kk kl km gt mg mh mi mj aw mk bi"><span id="7336" class="ml mm it mh b gy mn mo l mp mq">export GO111MODULE=on</span></pre><p id="9e6f" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">如果您键入protocol，您应该会看到以下内容:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi ne"><img src="../Images/f62c73e2737c36cfcec867398bc4ceb4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1216/format:webp/1*MSyayd0ZxWjE_baHhcuB5w.png"/></div></figure><p id="b300" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">现在，让我们导航到<code class="fe mr ms mt mh b">protos</code>文件夹，运行下面的命令来生成Go代码。在这样做之前，确保创建了<code class="fe mr ms mt mh b">src/go/sma</code>文件夹结构。</p><pre class="kj kk kl km gt mg mh mi mj aw mk bi"><span id="27ba" class="ml mm it mh b gy mn mo l mp mq">protoc --go_out=src/go/sma \<br/>       --go_opt=paths=source_relative \<br/>       --go-grpc_out=src/go/sma \<br/>       --go-grpc_opt=paths=source_relative \<br/>       posts.proto</span></pre><p id="edb5" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">这将生成带有<code class="fe mr ms mt mh b">Posts</code>服务和端点定义的Go代码。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi nf"><img src="../Images/f1fcd675fa32611db608d0341a4f783d.png" data-original-src="https://miro.medium.com/v2/resize:fit:698/format:webp/1*Mg2N5qHDoM80-bOq07vU1A.png"/></div></figure><p id="95f1" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">太好了！我们已经为包含创建端点的Posts服务生成了代码。</p><p id="70c8" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">为了继续构建Posts服务，我们需要添加<code class="fe mr ms mt mh b">UPDATE</code>、<code class="fe mr ms mt mh b">SHOW</code>、<code class="fe mr ms mt mh b">LIST</code>和<code class="fe mr ms mt mh b">DELETE </code>端点。</p><p id="5900" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">下面是更新端点的定义:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mv mw l"/></div></figure><p id="076a" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">像往常一样，我们用请求消息和响应消息定义RPC端点。在这一点上，这并不新鲜。让我们检查一下<code class="fe mr ms mt mh b"><strong class="kw iu">UpdatePostReq</strong></code>消息的定义。</p><p id="f270" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">该报文的第一个字段为<code class="fe mr ms mt mh b">update_mask</code>，类型为<code class="fe mr ms mt mh b">google.protobuf.FieldMask</code>。</p><p id="b475" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">字段掩码有两个用途，一个是显式定义get操作应该返回的字段集，另一个是在update操作中要更新的字段。它过滤掉修补请求中发送的字段，只留下或允许掩码中指定的字段。</p><p id="2dbb" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">对于get操作，它将接受响应，并且只返回掩码中存在的字段。其余字段将默认为它们所保存的数据类型的默认值。对于返回对象集合的终结点，字段掩码将应用于集合中的每个对象。在这种情况下，掩码对象是该消息中的最后一个字段。</p><p id="8237" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">稍后，当我们为这个原型文件编写注释时，我们将看到如何使用这个字段。这里需要注意的一点是，这个端点的REST动词将是PATCH，因为我们使用的是字段掩码。PUT仅用于完全更新。</p><p id="de1b" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">在第8行，我们导入了这个原型文件来使用<code class="fe mr ms mt mh b">FieldMask</code>。</p><p id="2720" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated"><code class="fe mr ms mt mh b">UpdatePost </code>保存允许更新的属性。这意味着端点将允许更新<code class="fe mr ms mt mh b">title</code>、<code class="fe mr ms mt mh b">description</code>、<code class="fe mr ms mt mh b">media_ids</code>和<code class="fe mr ms mt mh b">schedule_at</code>属性。</p><p id="2182" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated"><code class="fe mr ms mt mh b">PostId</code>是要更新的帖子的id。</p><p id="6a77" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">好了，让我们继续到显示端点，如下所示:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mv mw l"/></div></figure><p id="7875" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">这是一个非常简单的问题。在<code class="fe mr ms mt mh b">PostIdReq</code>消息中，我们只有一个字段，就是我们要显示的帖子的<code class="fe mr ms mt mh b">post_id</code>。作为响应，我们返回之前声明的<code class="fe mr ms mt mh b">Post</code>消息。</p><p id="ee09" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">下面是<code class="fe mr ms mt mh b">ListPosts</code>端点定义的代码:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mv mw l"/></div></figure><p id="b2c7" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">对于这个端点，我们将返回与给定用户相关联的帖子集合，以便在请求消息中需要用户id。</p><p id="fb66" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">如果我们看一下<code class="fe mr ms mt mh b">ListPostsReq</code>消息，第一个字段是实际的<code class="fe mr ms mt mh b">user_id</code>，下一个字段是搜索查询字符串，以防我们想要搜索整个集合。它还有<code class="fe mr ms mt mh b">page </code>和<code class="fe mr ms mt mh b">per_page</code>字段来指定返回哪个页面以及每个页面应该有多少个元素。</p><p id="8e11" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">最后一个元素是<code class="fe mr ms mt mh b">filter</code>，这里我们有一个enum来表示这个字段的类型，这意味着我们只能通过<code class="fe mr ms mt mh b">Filters</code> enum中指定的元素进行过滤，它映射了文章的状态。</p><p id="6b05" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">在<code class="fe mr ms mt mh b">ListPostsResp</code>中，我们只有两个字段。第一个表示将返回的文章集合，第二个关注分页数据对象。</p><p id="db11" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">最后，让我们看看删除端点的定义:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mv mw l"/></div></figure><p id="a06f" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">这个端点非常简单；它使用我们之前定义的<code class="fe mr ms mt mh b">PostIdReq</code>并返回一个空的响应消息。</p><p id="e21e" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">让我们也更新一下<code class="fe mr ms mt mh b">CreatePostResp</code>消息，添加<code class="fe mr ms mt mh b">scheduled_at</code>字段，因为我已经将它添加到了<code class="fe mr ms mt mh b">UpdatePost </code>端点中。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi ng"><img src="../Images/9af9ee02b20d3bd38f84b5859f77a4d2.png" data-original-src="https://miro.medium.com/v2/resize:fit:796/format:webp/1*DIENNtqtrbFTGZqh98GpJA.png"/></div><p class="nh ni gj gh gi nj nk bd b be z dk translated">CreatePostResp已更新。代码如下。</p></figure><p id="7c88" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">我们已经完成了Posts服务的API。</p><p id="5aed" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">以下是完整的原型文件:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mv mw l"/></div></figure><p id="823e" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">现在，让我们为这个服务生成Go代码。</p><p id="1ab3" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">为了避免记住我们为生成Go代码而运行的最后一个协议命令，让我们在<code class="fe mr ms mt mh b">protos</code>文件夹下创建一个Makefile，代码如下:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi nl"><img src="../Images/e14ad4f73909a32d27807f90de1d24a1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1070/format:webp/1*CikSI3P8DhUbmCPggSQqWQ.png"/></div><p class="nh ni gj gh gi nj nk bd b be z dk translated">生成文件</p></figure><p id="bf54" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">现在，让我们打开<code class="fe mr ms mt mh b">protos</code>文件夹下的终端并运行make命令:</p><pre class="kj kk kl km gt mg mh mi mj aw mk bi"><span id="ca5c" class="ml mm it mh b gy mn mo l mp mq">make proto proto_file=posts.proto</span></pre><p id="a3e2" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">这将生成Go代码！太好了，我们已经使用协议缓冲区和gRPC为Posts资源定义了API端点！</p><p id="8eef" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">文件夹结构如下所示:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi nm"><img src="../Images/7b87a589475c63d7c10042c0a68a1962.png" data-original-src="https://miro.medium.com/v2/resize:fit:714/format:webp/1*OBADzWjpGTjHerymMMJgEw.png"/></div><p class="nh ni gj gh gi nj nk bd b be z dk translated">文件夹结构</p></figure><p id="43e5" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">现在让我们看看如何为Posts API生成swagger和openapi文档。</p><p id="5696" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">首先，让我们为<code class="fe mr ms mt mh b">posts.proto</code>文件定义服务配置文件。这个文件包含了从gRPC到REST API的HTTP配置和映射。</p><p id="ad7b" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">在<code class="fe mr ms mt mh b">protos</code>文件夹中创建一个新文件，并将其命名为<code class="fe mr ms mt mh b">posts_annotations.yml</code>。代码如下:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mv mw l"/></div></figure><p id="8b6d" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">这里我们有来自<code class="fe mr ms mt mh b">posts.proto</code>文件的每个端点的HTTP规则。</p><p id="f85c" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">选择器指定RPC端点，然后我们指定HTTP谓词，后跟我们希望将该端点映射到的rest路径。这里我们指定了路径中必须包含的参数。在这种情况下，<code class="fe mr ms mt mh b">user_id</code>和<code class="fe mr ms mt mh b">post_id</code>取决于每个端点。</p><p id="1c37" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">在<code class="fe mr ms mt mh b">UpdatePost</code>端点中，我们使用了一个字段掩码，并将可更新的对象称为<code class="fe mr ms mt mh b">Post</code>。这就是为什么主体有一个字符串表示“post”这是指我们在<code class="fe mr ms mt mh b">UpdatePostReq</code>消息中的<code class="fe mr ms mt mh b">Post</code>消息。</p><p id="6d86" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">运行以下命令安装swagger和protoco-gen-open API v2:</p><pre class="kj kk kl km gt mg mh mi mj aw mk bi"><span id="7c3b" class="ml mm it mh b gy mn mo l mp mq">go install github.com/grpc-ecosystem/grpc-gateway/protoc-gen-swagger@latest<br/>go install github.com/grpc-ecosystem/grpc-gateway/v2/protoc-gen-openapiv2@latest</span></pre><p id="8cd7" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">让我们创建两个新文件夹。在<code class="fe mr ms mt mh b">src</code>下，创建swagger文件夹和openapi文件夹。</p><p id="b0cb" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">现在，我们需要扩展Makefile中的命令，用swagger和openapi生成API文档。我们还将包含生成gateway Go代码的命令，以便我们的API可以实现反向代理。</p><p id="11ab" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">新命令如下所示:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mv mw l"/></div></figure><p id="5b27" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">让我们生成代码。</p><pre class="kj kk kl km gt mg mh mi mj aw mk bi"><span id="a848" class="ml mm it mh b gy mn mo l mp mq">make proto annotation_file=posts_annotations.yml proto_file=posts.proto</span></pre><p id="8657" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">这将创建swagger JSON文件和一个新文件<code class="fe mr ms mt mh b">posts.pb.gw.go</code>，其中包含实现反向代理的代码。</p><p id="5a09" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">这是运行make命令后的新文件夹结构:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi nn"><img src="../Images/a68e5349d0a04f9bb00cfd5972a990fe.png" data-original-src="https://miro.medium.com/v2/resize:fit:680/format:webp/1*P0WpdjKKctwQgPyklPFIAA.png"/></div><p class="nh ni gj gh gi nj nk bd b be z dk translated">文件夹结构</p></figure><p id="648f" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">太好了。我们已经覆盖了很多，我们的API设计已经可以在gRPC项目中使用了。如果你想看看如何实现反向代理和消费这个API，请留下评论！</p><p id="8901" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">感谢您的阅读。敬请关注。</p></div></div>    
</body>
</html>