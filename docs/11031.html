<html>
<head>
<title>Inside Docker: One Nginx But Different PHP Versions Based on Your Hostname</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Docker内部:一个Nginx，但是根据你的主机名有不同的PHP版本</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/inside-docker-one-nginx-but-different-php-versions-based-on-your-hostname-2d4aca6654bd?source=collection_archive---------6-----------------------#2022-02-11">https://betterprogramming.pub/inside-docker-one-nginx-but-different-php-versions-based-on-your-hostname-2d4aca6654bd?source=collection_archive---------6-----------------------#2022-02-11</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="8e27" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">nginx http map模块的实际用例</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/a40658235f23a95451d52cebd4823a12.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*vZQA8YalwVMlso6U"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">乔恩·泰森在<a class="ae kv" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的照片</p></figure><p id="684c" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">好吧，这里有一个每个人都应该知道的日常场景:</p><p id="fbd6" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">您有一个典型的docker-compose.yml设置</p><ul class=""><li id="9302" class="ls lt iq ky b kz la lc ld lf lu lj lv ln lw lr lx ly lz ma bi translated">nginx</li><li id="221f" class="ls lt iq ky b kz mb lc mc lf md lj me ln mf lr lx ly lz ma bi translated">php-fpm (PHP 7)</li><li id="73a3" class="ls lt iq ky b kz mb lc mc lf md lj me ln mf lr lx ly lz ma bi translated">数据库(这里对我们不重要)</li></ul><p id="9036" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">假设您当前的PHP版本是7.4，您想将您的应用程序升级到PHP 8.1，只需扩展docker-compose.yml，而不是只进行“复制粘贴”和复制所有内容。目标是保持两个版本同时运行，而不是替换现有的配置。</p><p id="11f2" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">有很多方法可以做到这一点，而且都可能没问题。在这篇文章中，我只是想向你展示一条我多年后都不知道的路。</p><p id="f67f" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">所以你的默认设置可能完全不同，所以我想向你展示一下我的PHP设置:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mg mh l"/></div></figure><p id="7add" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">没什么特别的，就是简单的<code class="fe mi mj mk ml b">nginx</code> / <code class="fe mi mj mk ml b">php-fpm</code>连击。<br/><code class="fe mi mj mk ml b">host.conf</code>:</p><pre class="kg kh ki kj gt mm ml mn mo aw mp bi"><span id="2cbc" class="mq mr iq ml b gy ms mt l mu mv">server {<br/>    listen 80;<br/>    server_name myapp.com;<br/>    root /app/public;<br/>    include /etc/nginx/php.conf;<br/>}</span></pre><p id="ffd9" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><code class="fe mi mj mk ml b">php.conf </code>(只是重要的部分):</p><pre class="kg kh ki kj gt mm ml mn mo aw mp bi"><span id="1b47" class="mq mr iq ml b gy ms mt l mu mv">location ~ \.php$ {<br/>    try_files $uri =404;<br/>    fastcgi_split_path_info ^(.+\.php)(/.+)$;<br/>    fastcgi_pass php-fpm7:9000;<br/>    fastcgi_index index.php;<br/>    include fastcgi_params;<br/>    fastcgi_param SCRIPT_FILENAME $document_root$fastcgi_script_name;<br/>    fastcgi_param PATH_INFO $fastcgi_path_info;<br/>}</span></pre><p id="481d" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">到目前为止，一切顺利，没什么特别的。假设我们想要添加新的应用程序，保留所有配置文件并减少重复。我无意中发现了<code class="fe mi mj mk ml b">nginx</code>的一个很好的特征:<code class="fe mi mj mk ml b"><a class="ae kv" href="http://nginx.org/en/docs/http/ngx_http_map_module.html" rel="noopener ugc nofollow" target="_blank">ngx_http_map_module</a></code><a class="ae kv" href="http://nginx.org/en/docs/http/ngx_http_map_module.html" rel="noopener ugc nofollow" target="_blank"/>——这么多年过去了，我一直不知道它的存在——直到现在:)</p><p id="8600" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">让我向您展示一下在这种特殊情况下我是如何使用该模块的:</p><p id="a226" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在“http”部分的<code class="fe mi mj mk ml b">nginx.conf</code>中，我添加了以下内容:</p><pre class="kg kh ki kj gt mm ml mn mo aw mp bi"><span id="93da" class="mq mr iq ml b gy ms mt l mu mv">map $http_host $phpfpm {<br/> 'myapp.com'         'php-fpm7'; &lt;--- /app<br/> 'new.myapp.com'     'php-fpm8'; &lt;--- /app-new<br/>}</span></pre><p id="5a1d" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我用新的虚拟主机扩展了我的“host.conf ”:</p><pre class="kg kh ki kj gt mm ml mn mo aw mp bi"><span id="eb0e" class="mq mr iq ml b gy ms mt l mu mv">server {<br/>    listen 80;<br/>    server_name new.myapp.com<br/>    root /app-new/public; &lt;----- different folder !<br/>    include /etc/nginx/php.conf; &lt;--- same config<br/>}</span></pre><p id="385f" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们记得，在我们的<code class="fe mi mj mk ml b">php.conf</code>中，我们有一个固定的“fastcgi_pass”:</p><pre class="kg kh ki kj gt mm ml mn mo aw mp bi"><span id="b2df" class="mq mr iq ml b gy ms mt l mu mv">php-fpm7:9000</span></pre><p id="ba55" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">因为有了新的映射，我们现在可以用新的$变量替换它，所以这一行改为:</p><pre class="kg kh ki kj gt mm ml mn mo aw mp bi"><span id="47a2" class="mq mr iq ml b gy ms mt l mu mv">$phpfpm:9000</span></pre><p id="8868" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">但是——这也是我必须学习的东西——因为nginx运行在Docker中，我们必须告诉nginx，nginx应该使用哪个解析器才能从我们的映射主机名中获得正确的IP:<code class="fe mi mj mk ml b">php-fpm7</code>和<code class="fe mi mj mk ml b">php-fpm8</code>，这就是为什么我们必须添加这个:</p><pre class="kg kh ki kj gt mm ml mn mo aw mp bi"><span id="0909" class="mq mr iq ml b gy ms mt l mu mv">resolver 127.0.0.11 ipv6=off;</span></pre><p id="3014" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这是我们<code class="fe mi mj mk ml b">php.conf</code>的最终结果:</p><pre class="kg kh ki kj gt mm ml mn mo aw mp bi"><span id="ccc9" class="mq mr iq ml b gy ms mt l mu mv">location ~ \.php$ {<br/>    resolver 127.0.0.11 ipv6=off;<br/>    try_files $uri =404;<br/>    fastcgi_split_path_info ^(.+\.php)(/.+)$;<br/>    fastcgi_pass $phpfpm:9000;<br/>    fastcgi_index index.php;<br/>    include fastcgi_params;<br/>    fastcgi_param SCRIPT_FILENAME $document_root$fastcgi_script_name;<br/>    fastcgi_param PATH_INFO $fastcgi_path_info;<br/>}</span></pre><p id="ee85" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">有了这个设置，nginx就可以根据我们的域名知道我们想要使用哪个PHP-Container，cool)</p><p id="05c9" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">当然，我们必须扩展我们的docker-compose.yml:</p><p id="2f8c" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在“nginx”服务中，我们必须安装您的“app-new”目录:</p><pre class="kg kh ki kj gt mm ml mn mo aw mp bi"><span id="6605" class="mq mr iq ml b gy ms mt l mu mv">- /home/app-new:/app-new</span></pre><p id="b041" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们添加另一个具有相同映射的PHP服务，并将其命名为<code class="fe mi mj mk ml b">php-fpm8</code>。</p><p id="8d2f" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">最终结果如下所示:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mg mh l"/></div></figure><p id="88b9" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">同样，许多解决方案会得出相同的结果，但我个人想看看这种“映射”是如何工作的，以及如何使用它，我对这种解决方案很满意，因为:</p><ul class=""><li id="b15d" class="ls lt iq ky b kz la lc ld lf lu lj lv ln lw lr lx ly lz ma bi translated">我可以重用我现有的主配置:<code class="fe mi mj mk ml b">php.conf</code></li><li id="3190" class="ls lt iq ky b kz mb lc mc lf md lj me ln mf lr lx ly lz ma bi translated">我可以并行使用不同的PHP版本，同一个应用程序或我的应用程序的另一个版本</li><li id="7b09" class="ls lt iq ky b kz mb lc mc lf md lj me ln mf lr lx ly lz ma bi translated">我“可以”在每个项目中使用我的<code class="fe mi mj mk ml b">php.conf</code>,这不是最好的主意，但是可能的，因为现在“映射”告诉nginx使用哪个容器</li></ul><p id="e366" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">当然，如果你想同时用不同的PHP版本测试你的应用程序，你的映射应该是这样的:</p><pre class="kg kh ki kj gt mm ml mn mo aw mp bi"><span id="6e65" class="mq mr iq ml b gy ms mt l mu mv">map $http_host $phpfpm {<br/> 'myapp.com'         'php-fpm5';<br/> 'php7.myapp.com'    'php-fpm7';<br/> 'php80.myapp.com'   'php-fpm80';<br/> 'php81.myapp.com'   'php-fpm81';<br/>}</span></pre><p id="2564" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这只是一个例子，你得到的想法；)</p><p id="a311" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">对我来说，这是一种在同一个应用程序中处理不同PHP版本的好方法。</p><p id="aa42" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><strong class="ky ir">提示:</strong>将映射放入一个单独的配置中，在我们的示例中，让我们创建一个<br/> a <code class="fe mi mj mk ml b">php_mapping.conf</code>并将映射放入其中(不要忘记在您的nginx服务中挂载它)并将我们的<code class="fe mi mj mk ml b">nginx.conf</code>的“http”部分中的映射替换为:</p><pre class="kg kh ki kj gt mm ml mn mo aw mp bi"><span id="03d1" class="mq mr iq ml b gy ms mt l mu mv">include /etc/nginx/php_mapping.conf;</span></pre><p id="fdfe" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这样，甚至我们的<code class="fe mi mj mk ml b">nginx.conf</code>也可以在其他项目中重用！</p></div><div class="ab cl mw mx hu my" role="separator"><span class="mz bw bk na nb nc"/><span class="mz bw bk na nb nc"/><span class="mz bw bk na nb"/></div><div class="ij ik il im in"><p id="f10f" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">一如既往，我希望你能找到任何有用的信息</p></div></div>    
</body>
</html>