<html>
<head>
<title>Handling iOS 14 Diffable Data Sources</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">处理iOS 14不同的数据源</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/handling-ios-14-diffable-data-sources-29ebb6c53af4?source=collection_archive---------2-----------------------#2020-11-13">https://betterprogramming.pub/handling-ios-14-diffable-data-sources-29ebb6c53af4?source=collection_archive---------2-----------------------#2020-11-13</a></blockquote><div><div class="fc ii ij ik il im"/><div class="in io ip iq ir"><div class=""/><div class=""><h2 id="4e88" class="pw-subtitle-paragraph jr it iu bd b js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki dk translated">可区分的数据源获得节快照和一流的重新排序支持</h2></div><figure class="kk kl km kn gu ko gi gj paragraph-image"><div role="button" tabindex="0" class="kp kq di kr bf ks"><div class="gi gj kj"><img src="../Images/37a106f4997e534032fc5b7249162699.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*FGyorjyftTuidAuv"/></div></div><p class="kv kw gk gi gj kx ky bd b be z dk translated">Jess Bailey 在<a class="ae kz" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片。</p></figure><p id="943f" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">尽管在iOS 13中引入了SwiftUI(一种声明式UI框架)，但苹果仍然对UIKit框架进行了大量新的更改。突出的特性包括对<code class="fe lw lx ly lz b">UICollectionView</code>的增强。</p><p id="0b7a" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">具体来说，<a class="ae kz" href="https://medium.com/better-programming/ios-13-compositional-layouts-in-collectionview-90a574b410b8" rel="noopener">组合布局</a>和不同的数据源API允许更容易地构建高级<code class="fe lw lx ly lz b">CollectionView</code>布局和集中式数据源。</p><p id="893a" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">iOS 14更进一步，带来了新的细胞注册API，并在<code class="fe lw lx ly lz b">UICollectionView</code>内为<code class="fe lw lx ly lz b">UITableView</code>提供开箱即用的支持。</p><p id="6e41" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">但更重要的是，iOS 14中可区分的数据源现在包括了节快照。这意味着你现在可以在每个部分的基础上更新数据，这在构建概述风格的列表中非常有用，这是iOS 14引入的新的分层设计。</p><p id="61d6" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">一流的重新排序能力是今年不同数据源的另一个特点。</p></div><div class="ab cl ma mb hy mc" role="separator"><span class="md bw bk me mf mg"/><span class="md bw bk me mf mg"/><span class="md bw bk me mf"/></div><div class="in io ip iq ir"><h1 id="f948" class="mh mi iu bd mj mk ml mm mn mo mp mq mr ka ms kb mt kd mu ke mv kg mw kh mx my bi translated">我们的目标</h1><ul class=""><li id="6fa2" class="mz na iu lc b ld nb lg nc lj nd ln ne lr nf lv ng nh ni nj bi translated">不同数据源的快速回顾。</li><li id="2548" class="mz na iu lc b ld nk lg nl lj nm ln nn lr no lv ng nh ni nj bi translated">了解如何实现节快照。</li><li id="9b5c" class="mz na iu lc b ld nk lg nl lj nm ln nn lr no lv ng nh ni nj bi translated">深入研究新的重新排序API。</li></ul></div><div class="ab cl ma mb hy mc" role="separator"><span class="md bw bk me mf mg"/><span class="md bw bk me mf mg"/><span class="md bw bk me mf"/></div><div class="in io ip iq ir"><h1 id="9c37" class="mh mi iu bd mj mk ml mm mn mo mp mq mr ka ms kb mt kd mu ke mv kg mw kh mx my bi translated">不同数据源概述</h1><p id="ae44" class="pw-post-body-paragraph la lb iu lc b ld nb jv lf lg nc jy li lj np ll lm ln nq lp lq lr nr lt lu lv in bi translated">在这个新的声明式API之前，开发人员不得不依靠<code class="fe lw lx ly lz b">numberOfItemsInSection</code>、<code class="fe lw lx ly lz b">numberOfSections</code>、<code class="fe lw lx ly lz b">cellForItemAt</code>方法来创建数据源。为了更新数据，<code class="fe lw lx ly lz b">performBatchUpdates()</code>和<code class="fe lw lx ly lz b">reloadData()</code>是常用的方法。</p><p id="b098" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">这种方法工作得很好，但是导致了分散的数据源。更糟糕的是，<code class="fe lw lx ly lz b">reloadData()</code>方法毁了我们展示好动画的机会，而<code class="fe lw lx ly lz b">performBatchUpdates</code>会无意中导致常见的错误，比如<code class="fe lw lx ly lz b">NSInternalInconsistencyException</code>。</p><p id="d7e0" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">有了新的可区分数据源，我们就有了一个集中的专用数据源，其中的数据是通过快照提供的。</p><p id="1306" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">快照代表数据的单一状态，不依赖于索引路径来更新项目。相反，它依赖类型安全的唯一标识符来标识唯一的节和项。</p><p id="9b19" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">更好的是，您可以使用<code class="fe lw lx ly lz b">apply</code>方法将<code class="fe lw lx ly lz b">NSDiffableDataSourceSnapshot</code>实例设置为<code class="fe lw lx ly lz b">UITableView</code>或<code class="fe lw lx ly lz b">UICollectionView</code>的数据源，并让它处理动画。有趣的是，<code class="fe lw lx ly lz b">apply</code>方法也可以从后台线程执行。</p><p id="a233" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">总而言之，不同的数据源计算差异，并允许在我们的<code class="fe lw lx ly lz b">UICollectionView</code>和<code class="fe lw lx ly lz b">UITableView</code>布局中更容易地管理数据源。您可以访问<code class="fe lw lx ly lz b">dataSource.snapshot()</code>来访问UI元素的当前状态，并相应地添加/删除项目。</p></div><div class="ab cl ma mb hy mc" role="separator"><span class="md bw bk me mf mg"/><span class="md bw bk me mf mg"/><span class="md bw bk me mf"/></div><div class="in io ip iq ir"><h1 id="d973" class="mh mi iu bd mj mk ml mm mn mo mp mq mr ka ms kb mt kd mu ke mv kg mw kh mx my bi translated">iOS 14引入SectionSnapshots</h1><p id="4306" class="pw-post-body-paragraph la lb iu lc b ld nb jv lf lg nc jy li lj np ll lm ln nq lp lq lr nr lt lu lv in bi translated">在iOS 14之前，要在iOS 13中填充项目和部分，我们必须在<code class="fe lw lx ly lz b">NSDiffableDataSourceSnapshot</code>上使用以下方法:</p><pre class="kk kl km kn gu ns lz nt nu aw nv bi"><span id="ee57" class="nw mi iu lz b gz nx ny l nz oa">var snapshot = NSDiffableDataSourceSnapshot&lt;String, String&gt;()        snapshot.appendSections(["1", "2"])                </span></pre><p id="cfb4" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">为了在一个部分中添加项目，我们使用下面的方法:</p><pre class="kk kl km kn gu ns lz nt nu aw nv bi"><span id="3f19" class="nw mi iu lz b gz nx ny l nz oa">snapshot.appendItems(["1.1"], toSection: "1")<br/>snapshot.appendItems(["2.1"], toSection: "2")</span></pre><p id="1fb9" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">那么，考虑到我们已经可以在每个部分的基础上添加项目，新的<code class="fe lw lx ly lz b">NSDiffableDataSourceSectionSnapshot</code> API会带来什么呢？</p><p id="1fa6" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">简而言之:定制概要/可扩展列表。</p><p id="b79c" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">通过使用<code class="fe lw lx ly lz b">NSDiffableDataSourceSectionSnapshot</code> API，您可以轻松地创建和更新可扩展的集合视图，并且能够扩展和折叠某些部分。这在构建分层数据时非常方便。</p><p id="8818" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">以下是iOS 14中新的部分快照所公开的方法:</p><figure class="kk kl km kn gu ko gi gj paragraph-image"><div role="button" tabindex="0" class="kp kq di kr bf ks"><div class="gi gj ob"><img src="../Images/b7f6484775e86cd0e92726e136dfbe5e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*kei3dKe8oFCklFqBWjSTbQ.png"/></div></div></figure><p id="bcc3" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">现在，让我们通过为我们的数据源使用全新的部分快照来创建一个iOS 14 <code class="fe lw lx ly lz b">CollectionView</code>。</p><h2 id="2be5" class="nw mi iu bd mj oc od dn mn oe of dp mr lj og oh mt ln oi oj mv lr ok ol mx om bi translated">创建您的数据模型</h2><p id="ef6f" class="pw-post-body-paragraph la lb iu lc b ld nb jv lf lg nc jy li lj np ll lm ln nq lp lq lr nr lt lu lv in bi translated">我们的数据源将保存字符串的分层数据。因此，让我们用一个<code class="fe lw lx ly lz b">childItems</code>数组创建两个条目结构:</p><figure class="kk kl km kn gu ko"><div class="bz fq l di"><div class="on oo l"/></div></figure><p id="9634" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">由于父项(标题)和<code class="fe lw lx ly lz b">childItems</code>都是字符串，我们需要一种方法来区分它们的类型，以区别它们要放入的<code class="fe lw lx ly lz b">UICollectionViewCell</code>。可以理解的是，我们将为这两种情况创建一个案例枚举:</p><pre class="kk kl km kn gu ns lz nt nu aw nv bi"><span id="266f" class="nw mi iu lz b gz nx ny l nz oa"><strong class="lz iv">enum</strong> OutlineItem: Hashable {<br/><strong class="lz iv">case</strong> parent(Parent)<br/><strong class="lz iv">case</strong> child(Child)<br/>}</span></pre><p id="56f8" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">既然我们的数据模型已经准备好了，下面先来看一下将用于填充<code class="fe lw lx ly lz b">UICollectionView</code>的虚拟数据:</p><figure class="kk kl km kn gu ko gi gj paragraph-image"><div role="button" tabindex="0" class="kp kq di kr bf ks"><div class="gi gj op"><img src="../Images/2a5eacac71ceef88b328b1cc759f6c3b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*LjFef6MmcvFeNBqj-PfJ-g.png"/></div></div><p class="kv kw gk gi gj kx ky bd b be z dk translated">图片作者。</p></figure><h2 id="16f9" class="nw mi iu bd mj oc od dn mn oe of dp mr lj og oh mt ln oi oj mv lr ok ol mx om bi translated">创建我们不同的数据源</h2><p id="6e57" class="pw-post-body-paragraph la lb iu lc b ld nb jv lf lg nc jy li lj np ll lm ln nq lp lq lr nr lt lu lv in bi translated">通过使用新的iOS 14小区注册技术，我们不需要使用传统的小区标识符初始化方式<code class="fe lw lx ly lz b">UICollectionViewCell</code>。</p><p id="bb8a" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">下面看看如何在iOS 14 <code class="fe lw lx ly lz b">UICollectionView.CellRegistration</code>中创建和显示内容，并将它们传递给<code class="fe lw lx ly lz b">UICollectionViewDiffableDataSource</code>:</p><figure class="kk kl km kn gu ko"><div class="bz fq l di"><div class="on oo l"/></div></figure><p id="0477" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">请注意，我们已经注册了两个单元格。一个作为每个部分的根，包含公开指示符。另一个用于显示每个子项的内容。</p><p id="0d53" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">既然我们的数据源已经准备好了，是时候将它设置在<code class="fe lw lx ly lz b">CollectionView</code>上了:</p><pre class="kk kl km kn gu ns lz nt nu aw nv bi"><span id="d469" class="nw mi iu lz b gz nx ny l nz oa">private lazy var dataSource = makeDataSource()</span></pre><p id="dd2b" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">最后，我们将对上面的数据源应用快照。</p><h2 id="b83a" class="nw mi iu bd mj oc od dn mn oe of dp mr lj og oh mt ln oi oj mv lr ok ol mx om bi translated">构建截面快照</h2><p id="dafd" class="pw-post-body-paragraph la lb iu lc b ld nb jv lf lg nc jy li lj np ll lm ln nq lp lq lr nr lt lu lv in bi translated">截面快照按以下方式构建:</p><figure class="kk kl km kn gu ko"><div class="bz fq l di"><div class="on oo l"/></div></figure><p id="ba85" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">我们已经遍历了<code class="fe lw lx ly lz b">hierarchical</code>数据，并将父实例设置为每个部分的标题，其中设置了<code class="fe lw lx ly lz b">childItems</code>。此外，我们还扩展了每个标题部分以显示所有项目(您也可以将其配置为仅隐藏/扩展特定部分)。</p><p id="3dcf" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">最后，截面快照应用于<code class="fe lw lx ly lz b">UICollectionView</code>的根截面，当在模拟器上运行时，应用程序看起来如下:</p><figure class="kk kl km kn gu ko gi gj paragraph-image"><div class="gi gj oq"><img src="../Images/672f18fc231d9790b7ebb2e1647983d4.png" data-original-src="https://miro.medium.com/v2/resize:fit:612/format:webp/1*kcVgghNni4x878Zfg_zqow.png"/></div><p class="kv kw gk gi gj kx ky bd b be z dk translated">作者截图。</p></figure><p id="8b3a" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated"><code class="fe lw lx ly lz b">UICollectionView</code> +不同数据源和截面快照的完整源代码<a class="ae kz" href="https://gist.github.com/anupamchugh/9a6555c7f3384623aa3236649d25c623" rel="noopener ugc nofollow" target="_blank">可在GitHub </a>上获得。</p><p id="87a4" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">您还可以通过设置<code class="fe lw lx ly lz b">dataSource</code>上的<code class="fe lw lx ly lz b">sectionSnapshotHandlers</code>来定制各部分项目的展开状态。<code class="fe lw lx ly lz b">SectionSnapshotHandler&lt;Item&gt;</code>提供不同的闭包，如<code class="fe lw lx ly lz b">shouldCollapseItem</code>、<code class="fe lw lx ly lz b">willCollapseItem</code>、<code class="fe lw lx ly lz b">willExpandItem</code>和<code class="fe lw lx ly lz b">shouldExpandItem</code>。</p></div><div class="ab cl ma mb hy mc" role="separator"><span class="md bw bk me mf mg"/><span class="md bw bk me mf mg"/><span class="md bw bk me mf"/></div><div class="in io ip iq ir"><h1 id="f0df" class="mh mi iu bd mj mk ml mm mn mo mp mq mr ka ms kb mt kd mu ke mv kg mw kh mx my bi translated">使用新的重新排序API</h1><p id="0447" class="pw-post-body-paragraph la lb iu lc b ld nb jv lf lg nc jy li lj np ll lm ln nq lp lq lr nr lt lu lv in bi translated">虽然节快照有助于生成可扩展的列表并确定项目的嵌套级别(列表的根)，但还有一个重新排序API，可以快速插入到我们不同的数据源中。</p><p id="a320" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">具体来说，要启用重新排序，您需要定义以下两个闭包:</p><figure class="kk kl km kn gu ko gi gj paragraph-image"><div role="button" tabindex="0" class="kp kq di kr bf ks"><div class="gi gj or"><img src="../Images/cd05ab3a5b0ebcab919915a07ca787e3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*pRMTRkAlL8beOFJIfTAmhg.png"/></div></div></figure><p id="9700" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">可以理解的是，对于单元注册，您需要按照以下方式设置附件:</p><pre class="kk kl km kn gu ns lz nt nu aw nv bi"><span id="f3d6" class="nw mi iu lz b gz nx ny l nz oa">cell.accessories = [.reorder(displayed:.always)]</span></pre><p id="32c1" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">注意:为了简洁起见，我们将重新排序图标设置为总是显示。但建议设置一个在<code class="fe lw lx ly lz b">whenEditing</code>和<code class="fe lw lx ly lz b">whenNotEditing</code>状态之间切换的<code class="fe lw lx ly lz b">Edit</code>按钮，用于启用/禁用重新排序。</p><figure class="kk kl km kn gu ko gi gj paragraph-image"><div class="gi gj os"><img src="../Images/b72c3b44e563c90f7a92ada97420f5f8.png" data-original-src="https://miro.medium.com/v2/resize:fit:566/1*LsNQNAy-Lx49MgJxHfEBLw.gif"/></div></figure><p id="c022" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated"><code class="fe lw lx ly lz b">didReorder</code>和<code class="fe lw lx ly lz b">willReorder</code>闭包通过了一种称为<code class="fe lw lx ly lz b">NSDiffableDataSourceTranscation</code>的新类型。</p><p id="7e0a" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">该事务包含更新不同数据源所需的所有相关信息:</p><figure class="kk kl km kn gu ko gi gj paragraph-image"><div role="button" tabindex="0" class="kp kq di kr bf ks"><div class="gi gj ot"><img src="../Images/15ed48e7920a208689f635f582e2fc53.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*EWT5Nnu49B7o0WNQQ6wRuA.png"/></div></div></figure><p id="549d" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated"><code class="fe lw lx ly lz b">CollectionDifference</code>是Swift 5.1中引入的新类型。它描述跨两种集合状态插入和移除项。</p><p id="54ea" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">因此，您可以简单地用以下方式用<code class="fe lw lx ly lz b">didReorder</code>闭包内重新排序的事务更新原始数据源:</p><pre class="kk kl km kn gu ns lz nt nu aw nv bi"><span id="31ec" class="nw mi iu lz b gz nx ny l nz oa">originalDataSource.applying(transaction.difference)</span></pre></div><div class="ab cl ma mb hy mc" role="separator"><span class="md bw bk me mf mg"/><span class="md bw bk me mf mg"/><span class="md bw bk me mf"/></div><div class="in io ip iq ir"><h1 id="efad" class="mh mi iu bd mj mk ml mm mn mo mp mq mr ka ms kb mt kd mu ke mv kg mw kh mx my bi translated">结论</h1><p id="8353" class="pw-post-body-paragraph la lb iu lc b ld nb jv lf lg nc jy li lj np ll lm ln nq lp lq lr nr lt lu lv in bi translated">这篇关于iOS 14不同数据源变化的文章到此结束。通过使用节快照和新的重新排序API，您可以轻松地在您的<code class="fe lw lx ly lz b">CollectionViews</code>中编写和更新数据块。</p><p id="051f" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">感谢阅读。</p></div></div>    
</body>
</html>