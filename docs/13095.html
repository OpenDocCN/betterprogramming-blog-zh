<html>
<head>
<title>Drawing With SwiftUI’s Path</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">用SwiftUI的路径绘图</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/drawing-with-swiftuis-path-1cb3e57b9ee5?source=collection_archive---------1-----------------------#2022-07-28">https://betterprogramming.pub/drawing-with-swiftuis-path-1cb3e57b9ee5?source=collection_archive---------1-----------------------#2022-07-28</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="5f58" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">如何使用SwiftUI的路径视图绘制直线、曲线和更复杂的图形</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/deb8613181a87b6351fff538837f8e9b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*rAzvINVu0zRbtzXeMGp9EA.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">第4/5部分</p></figure><p id="09f7" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">这是我目前的贝塞尔路径系列的第四篇文章。这篇文章主要教你如何使用路径视图，特别是曲线。</p><h1 id="9cb4" class="lr ls iq bd lt lu lv lw lx ly lz ma mb jw mc jx md jz me ka mf kc mg kd mh mi bi translated">介绍</h1><p id="9fc0" class="pw-post-body-paragraph kv kw iq kx b ky mj jr la lb mk ju ld le ml lg lh li mm lk ll lm mn lo lp lq ij bi translated">在这里，我将教你如何在使用这个对象绘制方法绘制形状时使用路径视图。在您阅读了本系列的第一篇文章之后，这可能会更容易些:<a class="ae mo" href="https://luizpedrofg.medium.com/b%C3%A9zier-fundaments-for-swift-e8be3eec22fd" rel="noopener">Swift的贝塞尔基础</a>。</p><p id="a248" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">本文将分为五个部分:</p><ol class=""><li id="a9d4" class="mp mq iq kx b ky kz lb lc le mr li ms lm mt lq mu mv mw mx bi translated">工作场所(设置项目)</li><li id="053f" class="mp mq iq kx b ky my lb mz le na li nb lm nc lq mu mv mw mx bi translated">画一个简单的形状(理解除了画画我们还需要做什么)</li><li id="021d" class="mp mq iq kx b ky my lb mz le na li nb lm nc lq mu mv mw mx bi translated">画出我们的第一个曲线形状</li><li id="63cb" class="mp mq iq kx b ky my lb mz le na li nb lm nc lq mu mv mw mx bi translated">画这篇文章横幅！</li></ol><p id="8451" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">所以做好准备。用swift绘图不会再是外星技术了！</p><h1 id="ecf3" class="lr ls iq bd lt lu lv lw lx ly lz ma mb jw mc jx md jz me ka mf kc mg kd mh mi bi translated">工作场所</h1><p id="c082" class="pw-post-body-paragraph kv kw iq kx b ky mj jr la lb mk ju ld le ml lg lh li mm lk ll lm mn lo lp lq ij bi translated">创建一个空的SwiftUI项目后，我所做的就是:</p><ul class=""><li id="f210" class="mp mq iq kx b ky kz lb lc le mr li ms lm mt lq nd mv mw mx bi translated">将<code class="fe ne nf ng nh b">AccentColor</code>更改为自定义蓝色(<code class="fe ne nf ng nh b">#006A98</code>)；</li><li id="9200" class="mp mq iq kx b ky my lb mz le na li nb lm nc lq nd mv mw mx bi translated">创建了三个Swift文件和三个空视图(<code class="fe ne nf ng nh b">SquareView</code>、<code class="fe ne nf ng nh b">DShapeView</code>、<code class="fe ne nf ng nh b">BannerView</code>)</li><li id="c5a1" class="mp mq iq kx b ky my lb mz le na li nb lm nc lq nd mv mw mx bi translated">在<code class="fe ne nf ng nh b">ContentView.swift</code>中创建了一个标签栏</li></ul><pre class="kg kh ki kj gt ni nh nj nk aw nl bi"><span id="812c" class="nm ls iq nh b gy nn no l np nq">var body: some View {<br/>    TabView {<br/>        SquareView()<br/>            .tabItem {<br/>                Label("Square", systemImage: "1.square.fill")<br/>            }<br/>        DShapeView()<br/>            .tabItem {<br/>                Label("D Shape", systemImage: "2.circle.fill")<br/>            }<br/>        BannerView()<br/>            .tabItem {<br/>                Label("Banner", systemImage: "pencil.circle.fill")<br/>            }<br/>    }<br/>}</span></pre><p id="f432" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">这样，我们可以很容易地看到我们的三个不同的实现，而无需删除代码。</p><h1 id="e782" class="lr ls iq bd lt lu lv lw lx ly lz ma mb jw mc jx md jz me ka mf kc mg kd mh mi bi translated">画一个简单的形状</h1><p id="3267" class="pw-post-body-paragraph kv kw iq kx b ky mj jr la lb mk ju ld le ml lg lh li mm lk ll lm mn lo lp lq ij bi translated">我们在这一部分的目标是使用<code class="fe ne nf ng nh b">drawLine</code>方法绘制一个简单的蓝色正方形(见下图)。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi nr"><img src="../Images/e3a765abb334c4a7aba530e5c681c941.png" data-original-src="https://miro.medium.com/v2/resize:fit:368/format:webp/1*3vWloPJCdTCFoIqfhStdoA.png"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">简单的蓝色正方形</p></figure><p id="f5c9" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">在第一个屏幕中(<code class="fe ne nf ng nh b">SquareView</code>)，我们将从一个空类开始(我们不会使用<code class="fe ne nf ng nh b">viewDidLoad</code>方法)。</p><p id="0f09" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">首先，让我们改变我们的身体内容。我们将添加一个<code class="fe ne nf ng nh b">NavigationView</code>(只是为了给页面添加一个标题)，调用我们的Path视图，并添加一些修饰符:路径将被填充的颜色、填充和导航标题。</p><pre class="kg kh ki kj gt ni nh nj nk aw nl bi"><span id="6214" class="nm ls iq nh b gy nn no l np nq">var body: some View {<br/>    NavigationView {<br/>        Path { path in<br/>            <br/>        }<br/>        .fill(Color.accentColor)<br/>        .padding(20)<br/>        .navigationTitle(Text("Square View"))<br/>    }<br/>}</span></pre><p id="205e" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">现在我们有了开始画画所需的一切！我们可以准确地看到我们需要做的下一个图像。在这种情况下，我们将使用正值，每次我们增加X或Y值时，屏幕就会向右或向下移动。因此，我们的四个点将具有以下值:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/3cbb6920b03dcfda570cb61a876f92e9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*rOi6qIngQT9UZzyy5QEHHA.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">形状点</p></figure><p id="6a15" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">现在，我们发现了四个点的位置，我们可以将它们转换成代码。在我们的路径视图中，让我们移动到第一个点并添加线条，直到我们再次到达第一个点。</p><pre class="kg kh ki kj gt ni nh nj nk aw nl bi"><span id="cfcf" class="nm ls iq nh b gy nn no l np nq">path.move(to: .zero)<br/>path.addLine(to: CGPoint(x: 100, y: 0))<br/>path.addLine(to: CGPoint(x: 100, y: 100))<br/>path.addLine(to: CGPoint(x: 0, y: 100))<br/>path.addLine(to: .zero)<br/>path.closeSubpath()</span></pre><p id="8e25" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">另外，不要忘记调用<code class="fe ne nf ng nh b">closeSubpath</code>方法。这对于避免奇怪的伪像很重要，但当您想要绘制多个与同一个对象不相关的形状/笔画时也很重要。</p><p id="f926" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">嘿，这很简单！让我们看看它是如何运行的:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi ns"><img src="../Images/b3593dfda313ed9667bbfb40a56a4004.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*qdAerpuNwiaTs3bHZiE0DQ.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">方形模拟器</p></figure><p id="b036" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">如果你需要我的完整代码，你可以在这里得到它，在我的GitHub repo中。</p><p id="6696" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">酷！让我们进入下一个视图，用曲线画些东西！</p><h1 id="078b" class="lr ls iq bd lt lu lv lw lx ly lz ma mb jw mc jx md jz me ka mf kc mg kd mh mi bi translated">画出我们的第一个曲线形状</h1><p id="48de" class="pw-post-body-paragraph kv kw iq kx b ky mj jr la lb mk ju ld le ml lg lh li mm lk ll lm mn lo lp lq ij bi translated">我们的第一个曲线形状将是一个简单的“D”形，如下图所示:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi nt"><img src="../Images/1c89ac688cc72f7985ce0c017471fad1.png" data-original-src="https://miro.medium.com/v2/resize:fit:280/format:webp/1*s7N1f0oJg12CvXOn0M6aEQ.png"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">带有蓝色描边的简单“D”形</p></figure><p id="0d6b" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">这样，我们可以展示一个简单的曲线路径，以了解它是如何准确工作的。在这里，我们将最终使用贝塞尔曲线方法！不是仅仅画一条线到一个给定点，我们需要通过这个点我们需要通过目的地点和两个控制点。但是…什么是控制点呢？</p><div class="kg kh ki kj gt ab cb"><figure class="nu kk nv nw nx ny nz paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><img src="../Images/33c0a2769d00d63d3359fb02e57170c8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1000/format:webp/1*wRseM8H5FQpxPACGximO-g.png"/></div></figure><figure class="nu kk nv nw nx ny nz paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><img src="../Images/e26401fd00dd85b968ec14b2021c24a8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1000/format:webp/1*w2MNAZiV66eVv-lTE5wBMg.png"/></div><p class="kr ks gj gh gi kt ku bd b be z dk oa di ob oc translated">曲线示例及其控制点</p></figure></div><p id="e826" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">我在<a class="ae mo" href="https://luizpedrofg.medium.com/b%C3%A9zier-fundaments-for-swift-e8be3eec22fd" rel="noopener">这篇文章</a> <strong class="kx ir"> </strong>里解释的比较好(如果你没看过，去读吧。这样事情就好办了！)，但这是一种计算曲线中每个点应该在哪里的方法，使用这两个额外的点作为指导！我们可以在上面的图像中看到原点和终点(红色大圆圈)及其控制点(红色小圆圈)。在下图中，我们可以看到在改变控制点的位置时，我们可以用相同的曲线实现什么:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi od"><img src="../Images/d66d174fe78a249fad2535972f2ff631.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*fi2PMKY8p0gGlQo5E0UyyA.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">不同控制点位置的示例</p></figure><p id="703e" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">好了，现在你已经知道它是如何工作的了，让我们来编码吧！在我们的<code class="fe ne nf ng nh b">DShapeView</code>中，让我们将我们的<code class="fe ne nf ng nh b">Path</code>视图移到一个<code class="fe ne nf ng nh b">Shape</code>中！所以代码看起来会像这样:</p><pre class="kg kh ki kj gt ni nh nj nk aw nl bi"><span id="001c" class="nm ls iq nh b gy nn no l np nq">struct DShapeView: View {<br/>    var body: some View {<br/>        NavigationView {<br/>            DShape()<br/>                .stroke(Color.accentColor, lineWidth: 5)<br/>                .navigationTitle(Text("Banner Shape View"))<br/>                .frame(width: 100, height: 100)<br/>                .offset(x: 25, y: -50)<br/>        }<br/>    }<br/>}</span><span id="3772" class="nm ls iq nh b gy oe no l np nq">struct DShape: Shape {<br/>    func path(in rect: CGRect) -&gt; Path {<br/>        // <br/>    }<br/>}</span></pre><p id="a2e9" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">现在我们已经创建了一个<code class="fe ne nf ng nh b">Shape</code>，并在视图主体中设置了所有内容，让我们找出我们的点需要哪些值。假设我们设想一个100x100(宽和高)的框架，我们最终会得到类似下图的结果:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/55bd518b193b70c9d38c817519bf382c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*SWDN1sbMbgxW_9qO0pSkcQ.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">曲线点位置</p></figure><p id="3ce9" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">为了实现我们的“D”形，我们需要:</p><ul class=""><li id="d3c6" class="mp mq iq kx b ky kz lb lc le mr li ms lm mt lq nd mv mw mx bi translated">移动到第一点</li><li id="311d" class="mp mq iq kx b ky my lb mz le na li nb lm nc lq nd mv mw mx bi translated">向第二个点添加曲线</li><li id="151f" class="mp mq iq kx b ky my lb mz le na li nb lm nc lq nd mv mw mx bi translated">定义我们的曲线控制点(右上角和右下角)</li><li id="4d86" class="mp mq iq kx b ky my lb mz le na li nb lm nc lq nd mv mw mx bi translated">向第一个点添加一条线</li></ul><p id="89ef" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">让我们在我们的<code class="fe ne nf ng nh b">path</code>函数中实现这个逻辑:</p><pre class="kg kh ki kj gt ni nh nj nk aw nl bi"><span id="2a33" class="nm ls iq nh b gy nn no l np nq">Path { path in<br/>    path.move(to: .zero)<br/>    path.addCurve(<br/>        to: CGPoint(x: 0, y: 100),<br/>        control1: CGPoint(x: 75, y: 0),<br/>        control2: CGPoint(x: 75, y: 100))<br/>    path.addLine(to: .zero)<br/>    path.closeSubpath()<br/>}</span></pre><p id="6daa" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">注意，我们可以使用<code class="fe ne nf ng nh b">rect</code>参数来确保我们的形状在不同的尺寸下保持一致。但是现在，我将使用绝对值。</p><p id="5018" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">让我们在模拟器中运行它:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi ns"><img src="../Images/0aca1b9b56f27f4d3655de9fa1d9cfee.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*srlxZwHfbf2IV4K9JScY3A.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">“D”形模拟器</p></figure><p id="1749" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">如果你需要我的完整代码，你可以在我的GitHub repo 中得到它<a class="ae mo" href="https://github.com/LuizGuerra/Medium-Article-Codes/blob/main/BezierPath/SwiftUI%20Path/SwiftUI%20Path/Views/DShapeView.swift" rel="noopener ugc nofollow" target="_blank">。</a></p><p id="d3a4" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">不错！让我们做一些更有挑战性的事情吧！</p><h1 id="8575" class="lr ls iq bd lt lu lv lw lx ly lz ma mb jw mc jx md jz me ka mf kc mg kd mh mi bi translated">绘制这篇文章的横幅</h1><p id="66a6" class="pw-post-body-paragraph kv kw iq kx b ky mj jr la lb mk ju ld le ml lg lh li mm lk ll lm mn lo lp lq ij bi translated">好了，现在我们有了基础，让我们把这篇文章横幅编码为我们新的应用程序背景！但是…从哪里开始呢？像往常一样，让我们把问题分成更小的部分。</p><p id="d725" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">正如我们所看到的，现在我们有两个形状要跟踪——顶部和底部。在<code class="fe ne nf ng nh b">BannerView</code>中，我们将创建代码:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi of"><img src="../Images/7312748147fdb980a915d899f12d4419.png" data-original-src="https://miro.medium.com/v2/resize:fit:800/format:webp/1*jPmqeZ2Enx9UhdKK26frAQ.png"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">这篇文章横幅</p></figure><pre class="kg kh ki kj gt ni nh nj nk aw nl bi"><span id="d297" class="nm ls iq nh b gy nn no l np nq">struct BannerView: View {<br/>    var body: some View {<br/>        ZStack {<br/>            BannerShape()<br/>                .fill(Color.accentColor)<br/>                .ignoresSafeArea()<br/>            Text("Banner Shape")<br/>                .font(.largeTitle).bold()<br/>                .foregroundColor(Color.accentColor)<br/>        }<br/>    }<br/>}</span><span id="bc6d" class="nm ls iq nh b gy oe no l np nq">struct BannerShape: Shape {<br/>    func path(in rect: CGRect) -&gt; Path {<br/>        let width = rect.width<br/>        let height = rect.height<br/>        <br/>        return Path { path in<br/>    }<br/>}</span></pre><p id="d693" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">通过这段代码，我们在屏幕中间设置了一个文本，我们的新结构<code class="fe ne nf ng nh b">Shape</code>，以及它在<code class="fe ne nf ng nh b">View</code>主体中的颜色。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi og"><img src="../Images/f79e0516964a2ecbb98c158498f2699d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Ang_nxCLmWzvHK54QVnbTw.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">横幅及其线条、曲线、点和控制点</p></figure><p id="9aaa" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">现在，开始编码形状。正如我们在第一个顶部图像中看到的，横幅是由相同的形状制成的，其中一个是镜像的。该形状可以分成三条直线和两条简单的贝塞尔曲线。</p><p id="aa9d" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">我们可以看到，为了达到最佳状态，我们需要:</p><ol class=""><li id="a349" class="mp mq iq kx b ky kz lb lc le mr li ms lm mt lq mu mv mw mx bi translated">移动到第一个(我将使用左上角)</li><li id="c2be" class="mp mq iq kx b ky my lb mz le na li nb lm nc lq mu mv mw mx bi translated">在第二行(右上角)添加一行</li><li id="7951" class="mp mq iq kx b ky my lb mz le na li nb lm nc lq mu mv mw mx bi translated">在第三个位置添加一条线(中间偏右)</li><li id="acb0" class="mp mq iq kx b ky my lb mz le na li nb lm nc lq mu mv mw mx bi translated">向第四点(左上角)添加一条大曲线</li><li id="eabb" class="mp mq iq kx b ky my lb mz le na li nb lm nc lq mu mv mw mx bi translated">向第五点添加一条小曲线(也在左上角)</li><li id="e870" class="mp mq iq kx b ky my lb mz le na li nb lm nc lq mu mv mw mx bi translated">添加一条线回到第一点。</li></ol><p id="0815" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">这一次，对于点位置，我们将使用相对值。<a class="ae mo" href="https://luizpedrofg.medium.com/calculating-relative-points-from-different-frame-sizes-6d6560615de5" rel="noopener">点击此处了解它们是什么以及如何计算</a>。综上所述，我们可以将视图的最小和最大位置分别视为0和1，并将我们获得的值乘以宽度或高度，以获得应用程序屏幕上的正确位置。这样，计算将适用于任何屏幕尺寸。</p><p id="5b4c" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">因此，让我们从在我们的<code class="fe ne nf ng nh b">path</code>方法中添加一些有助于我们的变量开始:</p><pre class="kg kh ki kj gt ni nh nj nk aw nl bi"><span id="4a8d" class="nm ls iq nh b gy nn no l np nq">func path(in rect: CGRect) -&gt; Path {<br/>    let width = rect.width<br/>    let height = rect.height<br/>}</span></pre><p id="3332" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">之后，我将添加顶部形状的代码:</p><pre class="kg kh ki kj gt ni nh nj nk aw nl bi"><span id="7e24" class="nm ls iq nh b gy nn no l np nq">func path(in rect: CGRect) -&gt; Path {<br/>    // ...<br/>    path.move(to: .zero)<br/>    path.addLine(to: CGPoint(x: rect.width, y: 0))<br/>    path.addLine(to: CGPoint(x: rect.width, y: rect.height*0.3125))</span><span id="d1d6" class="nm ls iq nh b gy oe no l np nq">    path.addCurve(to: CGPoint(x: 40, y: 75),<br/>                  control1: CGPoint(<br/>                    x: rect.width-40,<br/>                    y: rect.height*0.15625),<br/>                  control2: CGPoint(<br/>                    x: rect.width*3/5,<br/>                    y: rect.height*0.09375))<br/>    path.addCurve(to: CGPoint(x: 0, y: 50),<br/>                  control1: CGPoint(x: 10, y: 75),<br/>                  control2: CGPoint(x: 0, y: 65))</span><span id="3631" class="nm ls iq nh b gy oe no l np nq">    path.addLine(to: .zero)<br/>    path.closeSubpath()<br/>}</span></pre><p id="d77d" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">请注意，乘法运算中使用的所有预编码值都是我之前提到的相对值。底部形状也将使用它们。代码如下:</p><pre class="kg kh ki kj gt ni nh nj nk aw nl bi"><span id="607f" class="nm ls iq nh b gy nn no l np nq">func path(in rect: CGRect) -&gt; Path {<br/>    // ...<br/>    path.move(to: CGPoint(x: 0, y: rect.height*0.6875))</span><span id="4513" class="nm ls iq nh b gy oe no l np nq">    path.addCurve(to: CGPoint(x: width-40, y: height-75),<br/>                  control1: CGPoint(<br/>                    x: 40,<br/>                    y: height*0.84375),<br/>                  control2: CGPoint(<br/>                    x: width*2/5,<br/>                    y: height*0.90625))<br/>    path.addCurve(to: CGPoint(x: width, y: height-50),<br/>                  control1: CGPoint(<br/>                    x: width-10,<br/>                    y: height-75),<br/>                  control2: CGPoint(<br/>                    x: width,<br/>                    y: height-65))</span><span id="1c12" class="nm ls iq nh b gy oe no l np nq">    path.addLine(to: CGPoint(x: width, y: height))<br/>    path.addLine(to: CGPoint(x: 0, y: height))<br/>    path.addLine(to: CGPoint(x: 0, y: rect.height*0.6875))<br/>    path.closeSubpath()<br/>}</span></pre><p id="5ca4" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">现在，如果我们运行代码，我们将得到以下结果:</p><div class="kg kh ki kj gt ab cb"><figure class="nu kk oh nw nx ny nz paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><img src="../Images/615352086f91056139036eb29f7fca1a.png" data-original-src="https://miro.medium.com/v2/resize:fit:404/format:webp/1*x5sYGiit4rgpqg3aG6YyZw.png"/></div></figure><figure class="nu kk oi nw nx ny nz paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><img src="../Images/98b98539842acd9e0050974796584e8e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1598/format:webp/1*E7lyt_yXMXvlc_uEFWu38A.png"/></div></figure></div><p id="2267" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">不错！</p><p id="921d" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">如果你需要我的完整代码，可以从<a class="ae mo" href="https://github.com/LuizGuerra/Medium-Article-Codes/blob/main/BezierPath/SwiftUI%20Path/SwiftUI%20Path/Views/BannerView.swift" rel="noopener ugc nofollow" target="_blank">我的GitHub repo </a>中获取。</p><h1 id="bf96" class="lr ls iq bd lt lu lv lw lx ly lz ma mb jw mc jx md jz me ka mf kc mg kd mh mi bi translated">结论</h1><p id="2326" class="pw-post-body-paragraph kv kw iq kx b ky mj jr la lb mk ju ld le ml lg lh li mm lk ll lm mn lo lp lq ij bi translated">SwiftUI的路径代码是迄今为止最容易使用的，因为你不必等待上下文，在正确的时间添加填充，并且它的样式也非常干净。虽然我没有写过任何关于动画的东西，但是很容易看出，不需要从其他工具导入路径，不需要使用第三方包，就可以拥有移动路径。当然，它们仍然是有用的，但这将完美地适用于较小的东西。</p><p id="5037" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">此外，我想链接到<a class="ae mo" href="https://developer.apple.com/tutorials/swiftui/drawing-paths-and-shapes" rel="noopener ugc nofollow" target="_blank">苹果的路径教程</a>，它展示了编写更复杂的几何图形是多么容易。</p><pre class="kg kh ki kj gt ni nh nj nk aw nl bi"><span id="7911" class="nm ls iq nh b gy nn no l np nq"><strong class="nh ir">Want to Connect?</strong></span><span id="93f6" class="nm ls iq nh b gy oe no l np nq">Feel free to comment here or send me a message on <a class="ae mo" href="https://twitter.com/LuizPedroGuerra" rel="noopener ugc nofollow" target="_blank">Twitter</a>. The article code repository can be found <a class="ae mo" href="https://github.com/LuizGuerra/Medium-Article-Codes/tree/main/BezierPath/SwiftUI%20Path" rel="noopener ugc nofollow" target="_blank">here</a>.</span></pre></div></div>    
</body>
</html>