# 石墨烯-Django 输入验证

> 原文：<https://betterprogramming.pub/validate-graphene-django-inputs-like-a-pro-e362cfc74372>

## 防止恶意攻击

![](img/f3c8329b8a1662fc37b611cf6a7303ce.png)

照片由[西格蒙德](https://unsplash.com/@sigmund?utm_source=medium&utm_medium=referral)在 [Unsplash](https://unsplash.com?utm_source=medium&utm_medium=referral) 上拍摄

API 的输入验证是必须的，怎么强调都不为过。在本文中，我将向您展示如何使用协作式多重继承来验证您的石墨烯输入。

# 到底什么是输入验证？

输入验证是对用户提供的任何输入进行测试，以防止恶意数据进入 API。

# 如果不验证用户输入会发生什么？

这可能导致 SQL 注入攻击、内存泄漏和系统受损。在本文中，我们将使用白名单来通知我们的 API 什么样的数据是可接受的，其他任何数据都将被拒绝。这是一个非常有效的激进策略。

## **我的第一次尝试**

当我第一次编写正则表达式验证 ***装饰*** 时，它完成了工作，但我不是很满意，它看起来很粗糙，而且每当我遇到新的边缘情况时，我的白名单就会越来越长。

石墨烯实际上提供了验证输入的完美框架。Django models 接受任意嵌套对象(JSONField ),但是在 graphene 中，无论对象的嵌套程度如何，每个键值对都是一个标量或枚举实例。

很自然，我认为如果`graphene`包定义了一个`Descriptor`作为标量的基类，我的工作就完成了一半。所以我在我的环境里钓鱼。根本没有！

> 给 graphene devs 的消息——为标量定义一个描述符，或者更好，添加一个正则表达式验证参数，就像我在这里做的那样。我们用户会为此感谢你的。

要么单独子类化标量(String、Float、Int、ID、Boolean ),要么直接子类化基本标量类，并与具体标量处于同一级别，这就是我们将在下面看到的。

下面是自定义标量的外观

在使用自定义标量字符串之前，应该了解它的一些行为。

1.  连续为每个实例调用 Dunder init。实例一次流入一个，并对它们调用 init。
2.  在调用静态方法之前，所有的实例都将被初始化。所以，这不像一个实例被初始化，静态方法同步调用它的值，不。如果这个类是自上而下同步的，这实际上很容易，但它不是，所以我们必须弄脏我们的手。
3.  如果值是 Python 数据类型，将调用`parse_value`方法
4.  如果值是 GraphQL 文字，将调用`parse_literal`方法。
5.  当类返回值时，将调用`serialize`方法。这对我们的用例来说无关紧要，但是我们的类必须实现它才能与基类(标量)合作。
6.  重要的是，由于类中的方法是静态方法，为了捕获我们的参数(您将在下面看到),我们需要将它们存储在类的外部。这样，当用一个值调用一个静态方法时，我们可以验证它。

我们将如何使用这个类？

方法如下:

石墨烯标量只有两个参数

*   `required`孰真孰假
*   `description`该字段的描述。

我添加了第三个参数，`*validate*`。这是一个正则表达式模式，它将为每个字段定义，以通知我们的 Stringy 类什么类型的数据对于该特定字段是可接受的

注意:第 30 行的 name 和 email 都是 Stringy 的一个实例，它们将被一个接一个地初始化。在它们都被初始化之后，静态方法将用值来调用。这对一些人来说可能是显而易见的，但不是所有人。

# **哪个是价值，哪个是论点？**

*   值是从浏览器发送的输入，并且
*   参数是在实例化过程中传递给标量的内容。分别是`required`、`description`和`validate`。

那么我们如何验证输入呢？

很高兴你问了！

以下是方法。

让我们检查一下文件:

*   顶部的 pattern_list 用于捕获我们的验证正则表达式模式。
*   在 init 方法中，我们从`kwargs`中移除了 validate 键，并将其添加到 pattern_list 中以备后用。
*   在 parse_ value 和 parse_literal 方法中，我们遍历 pattern_list，看看是否有任何模式与值匹配。
*   我们将迭代的范围增加了 pattern_list 的长度加 1。因此，如果迭代命中`IndexError`，我们将知道没有模式匹配我们的值，因此它是无效的。

请注意，验证密钥不能传递给石墨烯，这就是为什么我们使用 pop 来删除它。这被称为关键字参数剥离，是[合作多重继承范例](https://rhettinger.wordpress.com/2011/05/26/super-considered-super/)中的一个巧妙技巧。

## 白名单

我们本质上所做的是将我们的 API 将接受的所有可接受的模式列入白名单，因此如果 pattern_list 中没有模式匹配，我们将拒绝输入。

这是输入验证的本质，但是我们定义的只是一个标量，字符串标量。我们需要对 Float、Int、Boolean 和 ID 标量做同样的事情。

为了简单起见，让我们将验证迭代移到类之外。

像这样。

干净多了！

但是如果我们必须为所有自定义标量(Stringy、Inty 等)定义`serialize`、`parse_value`和`parse_literal`方法，这就不会枯燥了。

解决方案？

让我们创建一个中间初始化器类来保存标量的方法，就像这样:

那更好。

以下是完整的标量用法:

# 这种方法的好处？

*   Pattern_list 是动态构建的，它非常小，因为它一次只用于一个变异类。
*   这种方法让您可以对允许进入 API 的数据进行细粒度的控制。
*   当添加新字段时，您不必担心测试，因为我们验证的是字段，而不是类或函数。所以只要使用像[regextester.com](http://regextester.com)这样的工具来测试这个新领域的正则表达式。
*   您可以验证自定义类型和自定义输入，方式非常类似:

# **结论**

不要将标量命名为“字符串”、“浮点”、“整数”、“布尔”或“ID”。如果您这样做，实例调用将绕过您的自定义类，直接进入同名的 graphene 标量，并且您将得到一个传递 validate regex 模式的错误。我不确定为什么会有这种行为。给它们起一个独特的名字，如 Stringy，Floaty 等。

> 请注意，我的用例只是突变，因此，如果出于某种原因，您想将它用于查询，您将需要确保您的初始化器类是可序列化的。

你有它！

不要错过下一个重要的操作方法。

感谢阅读。