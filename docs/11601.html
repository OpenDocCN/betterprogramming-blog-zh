<html>
<head>
<title>Bulk Test APIs Before Production — Azure DevOps Release Gate With Azure Durable Functions</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">生产前批量测试APIs具有Azure持久功能的Azure DevOps发布门户</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/bulk-test-apis-before-production-azure-devops-release-gate-with-azure-durable-functions-f0a02ee04e34?source=collection_archive---------5-----------------------#2022-04-02">https://betterprogramming.pub/bulk-test-apis-before-production-azure-devops-release-gate-with-azure-durable-functions-f0a02ee04e34?source=collection_archive---------5-----------------------#2022-04-02</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="abc6" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">批量验证API，仅在自动验证后将应用程序发布到生产环境中</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/2f0dd417ebdb47b7fd13daa8cc1e6fa4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*93XvyO7TNBxHftEV"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">米哈伊尔·费申科在<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</p></figure><p id="5748" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">Azure DevOps中的发布管道允许开发人员跨多个阶段部署应用程序。发布管道类似于DevOps工程师定义自动化任务和工作的方式，如构建过程、单元测试、集成测试等。</p><p id="45fd" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">除了任务之外，我们还可以在包进入后续阶段之前定义部署前条件检查和部署后条件检查。下图直观地说明了流程。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi lv"><img src="../Images/9a5476858a3fde104bb3a046b8eefe63.png" data-original-src="https://miro.medium.com/v2/resize:fit:1212/format:webp/1*qynK6F1bxng4OF4by2LvIQ.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">来源:<a class="ae ky" href="https://docs.microsoft.com/en-us/azure/devops/pipelines/release/approvals/?view=azure-devops" rel="noopener ugc nofollow" target="_blank">https://docs . Microsoft . com/en-us/azure/devo PS/pipelines/release/approvals/？view=azure-devops </a></p></figure><p id="d129" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在这些条件下，我们可以定义人工干预，这需要选定成员的批准，或者定义关口，这有几个自动化任务，我们可以在发布部署之前执行这些任务来检查条件。</p><p id="0de6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">本文将重点讨论释放门。无论是检查合规性，还是验证应用程序功能或就绪性，发布关口都可以确保额外的检查层，这有助于减少部署后的问题。</p></div><div class="ab cl lw lx hx ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="im in io ip iq"><h2 id="8514" class="md me it bd mf mg mh dn mi mj mk dp ml li mm mn mo lm mp mq mr lq ms mt mu mv bi translated">情节</h2><p id="22fa" class="pw-post-body-paragraph kz la it lb b lc mw ju le lf mx jx lh li my lk ll lm mz lo lp lq na ls lt lu im bi translated">作为自动化测试阶段的一部分，开发人员通常会在管道中包含自动化单元测试和集成测试。就功能测试而言，有自动化方法和让测试人员执行测试的混合。一个相当常见的功能测试是执行REST API调用，以确保服务按预期工作。</p><p id="1dd3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">除了为系统调用API之外，它还可能涉及调用外部API，例如，检查外部端点的状态、符合性检查等。</p><p id="406d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在释放门下面有几个选项，如下图所示。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nb"><img src="../Images/be11aa49dda8fe56e2155f588632c6a2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*bP3GML_QXlpQK7OfuOwJUg.png"/></div></div></figure><p id="ebd6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">检查Azure策略合规性是常用的，因为这允许客户在符合组织标准的环境中部署工作负载。我们还可以通过通用连接或Azure函数调用API。最后，查询Azure Monitor警报和工作项对于确保新环境的发布遵循某些标准也是至关重要的。你可以在这里获得更多关于发布门的细节:<a class="ae ky" href="https://docs.microsoft.com/en-us/azure/devops/pipelines/release/approvals/gates?view=azure-devops" rel="noopener ugc nofollow" target="_blank">https://docs . Microsoft . com/en-us/azure/devo PS/pipelines/release/approvals/gates？view=azure-devops </a></p><p id="527c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">为REST API定义一个通用连接很简单。我们可以在项目设置中创建一个服务连接，并定义服务器URL和认证细节。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nc"><img src="../Images/59259e7cf079d5bd351f8381033df6cf.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*aPTw5RAn-AqD7EdU6NQ_BQ.png"/></div></div></figure><blockquote class="nd ne nf"><p id="d984" class="kz la ng lb b lc ld ju le lf lg jx lh nh lj lk ll ni ln lo lp nj lr ls lt lu im bi translated"><strong class="lb iu">这适用于几个API。我们可以逐一定义。20个、30个或更多API怎么样？</strong></p></blockquote><p id="112a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">你可能想知道为什么我们不在管道内做呢？是的，我们可以将此活动包括在管道中。这里的一个主要区别是，通过定义结果的条件，再加上人工干预，可以确定部署是否可以进行到下一个阶段或环境。</p><p id="15b4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">回到服务连接。如图所示，实际上我们需要一个接一个地定义端点，如果我们调用10个以上的端点，这是不可行的。接下来的问题将是，有没有一种方法来编排所有的API调用并聚集响应，作为一个发布门？</p></div><div class="ab cl lw lx hx ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="im in io ip iq"><h2 id="49af" class="md me it bd mf mg mh dn mi mj mk dp ml li mm mn mo lm mp mq mr lq ms mt mu mv bi translated">解决方法</h2><p id="6bc5" class="pw-post-body-paragraph kz la it lb b lc mw ju le lf mx jx lh li my lk ll lm mz lo lp lq na ls lt lu im bi translated">Azure Functions是众所周知的“功能即服务”的无服务器计算，通常用于微服务工作负载。通常是无国籍的，短命的。另一方面，除了Azure功能的好处之外，Azure持久功能旨在处理有状态作业。最值得一提的是，Azure Durable Functions擅长充当协调器，以并行或按定义的顺序执行任务。针对不同的用例，Azure持久功能有很多应用模式，这里记录:<a class="ae ky" href="https://docs.microsoft.com/en-us/azure/azure-functions/durable/durable-functions-overview?tabs=csharp" rel="noopener ugc nofollow" target="_blank">https://docs . Microsoft . com/en-us/Azure/Azure-Functions/Durable/Durable-Functions-overview？tabs=csharp </a></p><p id="bba3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在这种情况下，我们可以对这个用例使用扇出/扇入模式。这个想法很简单。我们调用orchestrator，然后orchestrator将调用REST APIs列表，最后聚合结果并作为输出返回。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi nk"><img src="../Images/2ac1d9f1ed5e52853f309ab008336cba.png" data-original-src="https://miro.medium.com/v2/resize:fit:1194/format:webp/1*FLBBtKMHliWQ6o2vkUuMSQ.png"/></div></figure><p id="26bc" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们详细看看这是如何工作的。</p><h2 id="9ec8" class="md me it bd mf mg mh dn mi mj mk dp ml li mm mn mo lm mp mq mr lq ms mt mu mv bi translated">Azure持久功能Orchestrator</h2><p id="47f4" class="pw-post-body-paragraph kz la it lb b lc mw ju le lf mx jx lh li my lk ll lm mz lo lp lq na ls lt lu im bi translated">我将从模板开始。使用VS代码或Visual Studio，我可以选择Azure Functions模板，在这种情况下，我选择了<strong class="lb iu">持久功能编排</strong>作为起点。将生成以下模板。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nl nm l"/></div></figure><p id="d94c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">它将生成3个函数，分别是“<code class="fe nn no np nq b">DurableFunctionsOrchestration</code>”、“<code class="fe nn no np nq b">DurableFunctionsOrchestration_Hello</code>”和“<code class="fe nn no np nq b">DurableFunctionsOrchestration_HttpStart</code>”。让我们从底层去了解他们。</p><p id="69ee" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">“<code class="fe nn no np nq b">DurableFunctionsOrchestration_HttpStart</code>”被定义为工作流的入口点，充当持久客户端。如第27行所示，它使用了HTTP触发器。它的意思是，它将接受HTTP GET或HTTP Post，并启动编排流。当然，根据不同的用例，我们还定义了其他触发器，比如定时器触发器、Azure服务总线触发器等等。下面是可用绑定的列表，您可以为触发器使用受支持的绑定。</p><div class="nr ns gp gr nt nu"><a href="https://docs.microsoft.com/en-us/azure/azure-functions/functions-triggers-bindings?tabs=csharp" rel="noopener  ugc nofollow" target="_blank"><div class="nv ab fo"><div class="nw ab nx cl cj ny"><h2 class="bd iu gy z fp nz fr fs oa fu fw is bi translated">Azure函数中的触发器和绑定</h2><div class="ob l"><h3 class="bd b gy z fp nz fr fs oa fu fw dk translated">学习使用触发器和绑定将Azure功能连接到在线事件和基于云的服务。</h3></div><div class="oc l"><p class="bd b dl z fp nz fr fs oa fu fw dk translated">docs.microsoft.com</p></div></div><div class="od l"><div class="oe l of og oh od oi ks nu"/></div></div></a></div><p id="6b4e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在这个例子中，我将坚持使用HTTP触发器。它很容易调用，这个HTTP触发器将以HTTP响应的形式返回编排细节，比如编排状态、输出等，这在本例中是需要的。</p><p id="1916" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们转到“T4”。顾名思义，这个函数编排活动。我可以定义活动是如何编排的，比如以异步模式运行，或者根据前一个活动的输出以串行方式运行。在上面的例子中，从第10行到第12行，它简单地触发了串行活动，这是一个函数链接。这是我们设计上述六种模式之一的地方。</p><p id="e743" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">从"<code class="fe nn no np nq b">DurableFunctionsOrchestration</code>"开始的目标活动被称为"<code class="fe nn no np nq b">DurableFunctionsOrchestration_Hello</code> <em class="ng">"，</em>以一个字符串作为输入。这是所有重物搬运的地方。</p></div><div class="ab cl lw lx hx ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="im in io ip iq"><p id="ea34" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">回到我们的场景。想法是创建一个函数，其目的是发出多个API调用来验证状态和输出，并将结果返回给Azure Pipeline release gate。</p><p id="dc1c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在我们有了Azure持久功能的概念，让我们看看如何在这个场景中实现它。我将从活动开始，执行所有繁重任务的功能。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nl nm l"/></div></figure><p id="78ef" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我把它命名为<code class="fe nn no np nq b">HealthCheck_Executor</code>。出于演示的目的，我简单地对我的后端API做了一个回显，验证了返回的消息与我的输入相同。我做的唯一附加动作是构造一个名为<code class="fe nn no np nq b">APICheckObject</code>的对象，来捕获API名称及其状态。请记住，我希望在稍后汇总所有结果，因此做1或0是一个简单的方法，同时，我可以识别哪个API没有按预期运行。</p><p id="5910" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">接下来，让我们来看看管弦乐队。要解决的第一个问题是，我应该使用什么样的模式？函数链和扇出/扇入似乎是一个可行的选择。</p><p id="60a0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果API是按顺序测试的，我会选择函数链接，例如，第二个API依赖于第一个API的输出。在我的例子中，所有的API都是相互独立的，因此我选择扇出/扇入，以并行化所有的执行，从而缩短执行时间。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nl nm l"/></div></figure><p id="4984" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">然后，我将返回一个对象列表，作为整个过程的输出。</p><p id="29c2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">拼图的最后一块是调用这个持久函数的方法。我将坚持使用HTTP触发器，但是我还需要一样东西。如果我直接调用这个持久函数，它会返回几个URL，主要是让我们查看状态或者终止任务。Azure Pipeline release gate将无法使用输出。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi oj"><img src="../Images/05de2fe7920a2412d50ec71c5f8c9701.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*tCnoiYy9GG_-rCMb7f9jmw.png"/></div></div></figure><p id="5bea" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">为了解决这个问题，我可以简单地使用HTTP trigger创建另一个Azure函数来调用这个持久的函数，同时在Azure DevOps中聚合验证的输出。</p><p id="6043" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">完整的源代码可以在GitHub上找到。</p><div class="nr ns gp gr nt nu"><a href="https://github.com/guangying94/Azure_Durable_Functions_API_Checker" rel="noopener  ugc nofollow" target="_blank"><div class="nv ab fo"><div class="nw ab nx cl cj ny"><h2 class="bd iu gy z fp nz fr fs oa fu fw is bi translated">GitHub-guangying 94/Azure _ Durable _ Functions _ API _ Checker:使用Azure持久函数的示例…</h2><div class="ob l"><h3 class="bd b gy z fp nz fr fs oa fu fw dk translated">这个样本库是Azure持久功能的一个实现，用于批量检查API，并返回状态…</h3></div><div class="oc l"><p class="bd b dl z fp nz fr fs oa fu fw dk translated">github.com</p></div></div><div class="od l"><div class="ok l of og oh od oi ks nu"/></div></div></a></div><h2 id="f7e3" class="md me it bd mf mg mh dn mi mj mk dp ml li mm mn mo lm mp mq mr lq ms mt mu mv bi translated">Azure管道发布门验证</h2><p id="1bf3" class="pw-post-body-paragraph kz la it lb b lc mw ju le lf mx jx lh li my lk ll lm mz lo lp lq na ls lt lu im bi translated">让我们看看上面Azure函数的输出。我有总成功调用，以及相应的API名称及其状态。</p><pre class="kj kk kl km gt ol nq om on aw oo bi"><span id="16dd" class="md me it nq b gy op oq l or os">{<br/>   "totalSuccess":3,<br/>   "details":[<br/>                {"apiName":"test1","apiStatus":1},<br/>                {"apiName":"test2","apiStatus":1},  <br/>                {"apiName":"test3","apiStatus":1}<br/>             ]<br/>}</span></pre><p id="97e9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在Azure Pipeline中，让我们转到发布管道并修改我们的发布门。为了将Azure功能添加到release gate中，我们可以选择预部署或后部署。就我而言，我会选择后期部署。添加Azure功能很简单。只需点击左上角“Gates”下的“+ Add”，放入Azure Functions URL和Azure Functions Key。如果你不知道在哪里检索密钥，它在Azure Portal内部。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ot"><img src="../Images/f32328a79fafce5c24a408e384bec325.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*acBD9GPeQWrUsSN1o6w8bA.png"/></div></div></figure><p id="1666" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我刚才展示了API响应，现在我可以定义这个部署后检查的成功标准了。我将检查成功调用的总数，如果成功调用在我的参数范围内，则检查通过。您可以在文档中获得关于定义条件的其他方式的更多详细信息。</p><div class="nr ns gp gr nt nu"><a href="https://docs.microsoft.com/en-us/azure/devops/pipelines/process/conditions?view=azure-devops&amp;tabs=yaml" rel="noopener  ugc nofollow" target="_blank"><div class="nv ab fo"><div class="nw ab nx cl cj ny"><h2 class="bd iu gy z fp nz fr fs oa fu fw is bi translated">条件-天蓝色管道</h2><div class="ob l"><h3 class="bd b gy z fp nz fr fs oa fu fw dk translated">您可以指定每个阶段、作业或步骤运行的条件。默认情况下，作业或阶段会运行，如果它…</h3></div><div class="oc l"><p class="bd b dl z fp nz fr fs oa fu fw dk translated">docs.microsoft.com</p></div></div><div class="od l"><div class="ou l of og oh od oi ks nu"/></div></div></a></div><p id="6cdd" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这是我的释放门的样子。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi ov"><img src="../Images/88b7a46988427aafe0a738c5b5016907.png" data-original-src="https://miro.medium.com/v2/resize:fit:1100/format:webp/1*BAy5c7KZZ8IeFCqw7muD7Q.png"/></div></figure><p id="829a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">要验证它，只需创建一个发布并检查日志。您会注意到，该条件以5分钟为间隔被检查了两次。您可以在上面的部署门页面中定义参数。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ow"><img src="../Images/8093144c57e063cb667a3f3439e241f3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*eHvOZqCmSYLpSqRAfuPYnQ.png"/></div></div></figure><p id="f2bd" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">下图显示了整个流程。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi ox"><img src="../Images/04a3639e52527391fa4f6bc68ef83376.png" data-original-src="https://miro.medium.com/v2/resize:fit:1392/format:webp/1*UhZUKm7JOrGHaay7CNl-vw.png"/></div></figure><p id="0693" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这样，现在您可以批量验证API，并且只在自动验证之后将应用程序发布到生产环境中！</p></div></div>    
</body>
</html>