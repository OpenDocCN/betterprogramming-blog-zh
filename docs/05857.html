<html>
<head>
<title>Migrate From Flask to FastAPI Smoothly</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">顺利地从Flask迁移到FastAPI</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/migrate-from-flask-to-fastapi-smoothly-cc4c6c255397?source=collection_archive---------1-----------------------#2020-08-12">https://betterprogramming.pub/migrate-from-flask-to-fastapi-smoothly-cc4c6c255397?source=collection_archive---------1-----------------------#2020-08-12</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="8165" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">转换您的Flask服务器以获得更好的性能和可维护性</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi ki"><img src="../Images/6d62e96c43207a606dcf1e4f2be06ef9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1288/format:webp/1*g2a3VIIlkaTzdUkyMm98sA.png"/></div><p class="kq kr gj gh gi ks kt bd b be z dk translated">图片由作者提供。</p></figure><p id="e01f" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">通过阅读这篇文章，你将了解到<code class="fe lq lr ls lt b">FastAPI</code>背后的基本概念，以及从<code class="fe lq lr ls lt b">Flask</code>过渡到<code class="fe lq lr ls lt b">FastAPI</code>的步骤。并列比较将提供给你的参考。在本教程结束时，您应该能够将您的<code class="fe lq lr ls lt b">Flask</code>服务器完全迁移到<code class="fe lq lr ls lt b">FastAPI</code>服务器中。基于<a class="ae lu" href="https://fastapi.tiangolo.com/" rel="noopener ugc nofollow" target="_blank">官方文档</a>，<code class="fe lq lr ls lt b">FastAPI</code>框架为:</p><blockquote class="lv lw lx"><p id="9dd5" class="ku kv ly kw b kx ky ju kz la lb jx lc lz le lf lg ma li lj lk mb lm ln lo lp im bi translated">“…一个现代、快速(高性能)的web框架，用于基于标准Python类型提示使用Python 3.6+构建API。”</p></blockquote><p id="2632" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">众所周知，<code class="fe lq lr ls lt b">Flask</code>是一个微web框架，是100% <code class="fe lq lr ls lt b">WSGI </code> (Web服务器网关接口)。向前看，<strong class="kw iu"> </strong> <code class="fe lq lr ls lt b">ASGI </code>(异步服务器网关接口)是<code class="fe lq lr ls lt b">WSGI</code>的精神继承者，因为<code class="fe lq lr ls lt b">ASGI</code>能够通过支持<code class="fe lq lr ls lt b">HTTP/2</code>和<code class="fe lq lr ls lt b">WebSockets</code>在IO绑定的上下文中实现高吞吐量，而这是<code class="fe lq lr ls lt b">WSGI</code>无法处理的。</p><p id="b221" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">随着技术的进步，一款名为<code class="fe lq lr ls lt b">Uvicorn</code>的快如闪电的<code class="fe lq lr ls lt b">ASGI</code>服务器诞生了。但是，<code class="fe lq lr ls lt b">Uvicorn</code>只是一个web服务器，没有任何路由能力。然后，<code class="fe lq lr ls lt b">Starlette</code>出现了，它在<code class="fe lq lr ls lt b">Uvicorn</code>、<code class="fe lq lr ls lt b">Daphne</code>或<code class="fe lq lr ls lt b">Hypercorn</code>等<code class="fe lq lr ls lt b">ASGI</code>服务器上提供了一个完整的<code class="fe lq lr ls lt b">ASGI</code>工具包。如果你要找一个直接的比较，<code class="fe lq lr ls lt b">Starlette</code>是一个<code class="fe lq lr ls lt b">ASGI</code> web框架，而<code class="fe lq lr ls lt b">Flask</code>是一个<code class="fe lq lr ls lt b">WSGI</code> web框架。</p><p id="151c" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated"><code class="fe lq lr ls lt b">FastAPI</code>框架充分利用了<code class="fe lq lr ls lt b">Starlette</code>背后的功能和<code class="fe lq lr ls lt b">Flask</code>的编程风格，使其成为一个类似烧瓶的<code class="fe lq lr ls lt b">ASGI</code> web框架。此外，它还包含以下特性，这些特性使它成为创建RESTful API的理想web框架:</p><ul class=""><li id="0cf7" class="mc md it kw b kx ky la lb ld me lh mf ll mg lp mh mi mj mk bi translated">数据验证:使用在运行时强制类型提示的<code class="fe lq lr ls lt b">Pydantic</code>。当数据无效时，它还提供用户友好的错误。</li><li id="2c23" class="mc md it kw b kx ml la mm ld mn lh mo ll mp lp mh mi mj mk bi translated">文档:支持带有JSON模式的自动数据模型文档。带有<code class="fe lq lr ls lt b">Swagger UI</code>或<code class="fe lq lr ls lt b">ReDoc</code>。</li></ul><p id="884e" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">通过使用<code class="fe lq lr ls lt b">FastAPI</code>而不是<code class="fe lq lr ls lt b">Flask</code>，您的web服务器将拥有随时可用的数据验证和数据模型文档，即使您在任一框架中花费的编码时间大致相同。因此，它有助于改进您团队中的开发过程。</p><p id="2f43" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">让我们继续下一部分，开始安装必要的模块。</p></div><div class="ab cl mq mr hx ms" role="separator"><span class="mt bw bk mu mv mw"/><span class="mt bw bk mu mv mw"/><span class="mt bw bk mu mv"/></div><div class="im in io ip iq"><h1 id="f450" class="mx my it bd mz na nb nc nd ne nf ng nh jz ni ka nj kc nk kd nl kf nm kg nn no bi translated">1.设置</h1><p id="bf70" class="pw-post-body-paragraph ku kv it kw b kx np ju kz la nq jx lc ld nr lf lg lh ns lj lk ll nt ln lo lp im bi translated">强烈建议您在继续安装之前创建一个虚拟环境。如果你打算测试FastAPI，你只需要安装<code class="fe lq lr ls lt b">FastAPI</code>和<code class="fe lq lr ls lt b">Uvicorn</code>。其余的包是可选的，只有在您打算按照本教程学习时才是必需的。</p><h2 id="907d" class="nu my it bd mz nv nw dn nd nx ny dp nh ld nz oa nj lh ob oc nl ll od oe nn of bi translated">FastAPI</h2><p id="7938" class="pw-post-body-paragraph ku kv it kw b kx np ju kz la nq jx lc ld nr lf lg lh ns lj lk ll nt ln lo lp im bi translated">通过<code class="fe lq lr ls lt b">pip install</code>，安装非常简单。</p><pre class="kj kk kl km gt og lt oh oi aw oj bi"><span id="a64f" class="nu my it lt b gy ok ol l om on">pip install fastapi</span></pre><h2 id="7358" class="nu my it bd mz nv nw dn nd nx ny dp nh ld nz oa nj lh ob oc nl ll od oe nn of bi translated">紫玉米</h2><p id="79aa" class="pw-post-body-paragraph ku kv it kw b kx np ju kz la nq jx lc ld nr lf lg lh ns lj lk ll nt ln lo lp im bi translated">为<code class="fe lq lr ls lt b">FastAPI</code>推荐的<code class="fe lq lr ls lt b">ASGI</code>服务器是<code class="fe lq lr ls lt b">Uvicorn</code>。运行以下命令进行安装:</p><pre class="kj kk kl km gt og lt oh oi aw oj bi"><span id="e828" class="nu my it lt b gy ok ol l om on">pip install uvicorn</span></pre><h2 id="3825" class="nu my it bd mz nv nw dn nd nx ny dp nh ld nz oa nj lh ob oc nl ll od oe nn of bi translated">Jinja2(可选)</h2><p id="0300" class="pw-post-body-paragraph ku kv it kw b kx np ju kz la nq jx lc ld nr lf lg lh ns lj lk ll nt ln lo lp im bi translated">如果您打算通过模板提供网页，您可以使用任何带有<code class="fe lq lr ls lt b">FastAPI</code>的模板引擎。为了简单起见，让我们安装<code class="fe lq lr ls lt b">Jinja2</code>，它与Flask使用的模板引擎相同。</p><pre class="kj kk kl km gt og lt oh oi aw oj bi"><span id="fac6" class="nu my it lt b gy ok ol l om on">pip install jinja2</span></pre><h2 id="e713" class="nu my it bd mz nv nw dn nd nx ny dp nh ld nz oa nj lh ob oc nl ll od oe nn of bi translated">Aiofiles(可选)</h2><p id="ea0b" class="pw-post-body-paragraph ku kv it kw b kx np ju kz la nq jx lc ld nr lf lg lh ns lj lk ll nt ln lo lp im bi translated">如果你需要为用户提供静态文件，你也需要安装<code class="fe lq lr ls lt b">aiofiles</code>。</p><pre class="kj kk kl km gt og lt oh oi aw oj bi"><span id="4e62" class="nu my it lt b gy ok ol l om on">pip install aiofiles</span></pre><h2 id="a440" class="nu my it bd mz nv nw dn nd nx ny dp nh ld nz oa nj lh ob oc nl ll od oe nn of bi translated">Python-multipart(可选)</h2><p id="0c55" class="pw-post-body-paragraph ku kv it kw b kx np ju kz la nq jx lc ld nr lf lg lh ns lj lk ll nt ln lo lp im bi translated">默认情况下，<code class="fe lq lr ls lt b">FastAPI</code>将输入请求标准化为JSON。如果你需要接收表单域，你必须安装<code class="fe lq lr ls lt b">python-multipart</code>。</p><pre class="kj kk kl km gt og lt oh oi aw oj bi"><span id="f18f" class="nu my it lt b gy ok ol l om on">pip install python-multipart</span></pre><h2 id="ebf4" class="nu my it bd mz nv nw dn nd nx ny dp nh ld nz oa nj lh ob oc nl ll od oe nn of bi translated">烧瓶(可选)</h2><p id="a506" class="pw-post-body-paragraph ku kv it kw b kx np ju kz la nq jx lc ld nr lf lg lh ns lj lk ll nt ln lo lp im bi translated">本教程将展示一个<code class="fe lq lr ls lt b">Flask</code>服务器及其使用<code class="fe lq lr ls lt b">FastAPI</code>的等效功能。安装Flask，当且仅当您打算进行并排比较以供参考时。否则，您可以安全地忽略这个模块，转而运行<code class="fe lq lr ls lt b">FastAPI</code>服务器。</p><pre class="kj kk kl km gt og lt oh oi aw oj bi"><span id="bca4" class="nu my it lt b gy ok ol l om on">pip install flask</span></pre><p id="79fc" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">让我们进入下一部分，并开始实施</p></div><div class="ab cl mq mr hx ms" role="separator"><span class="mt bw bk mu mv mw"/><span class="mt bw bk mu mv mw"/><span class="mt bw bk mu mv"/></div><div class="im in io ip iq"><h1 id="e3b5" class="mx my it bd mz na nb nc nd ne nf ng nh jz ni ka nj kc nk kd nl kf nm kg nn no bi translated">2.比较</h1><p id="4445" class="pw-post-body-paragraph ku kv it kw b kx np ju kz la nq jx lc ld nr lf lg lh ns lj lk ll nt ln lo lp im bi translated">在本节中，将提供代码以及对<code class="fe lq lr ls lt b">Flask</code>服务器和<code class="fe lq lr ls lt b">FastAPI</code>服务器的解释。两台服务器将具有相同的API和功能。</p><h2 id="3e9b" class="nu my it bd mz nv nw dn nd nx ny dp nh ld nz oa nj lh ob oc nl ll od oe nn of bi translated">进口(烧瓶)</h2><p id="121a" class="pw-post-body-paragraph ku kv it kw b kx np ju kz la nq jx lc ld nr lf lg lh ns lj lk ll nt ln lo lp im bi translated">进口申报对<code class="fe lq lr ls lt b">Flask</code>来说非常简单，因为所有东西都打包在烧瓶包装下。<code class="fe lq lr ls lt b">random</code>模块将在稍后的一个API中用于生成随机数。</p><pre class="kj kk kl km gt og lt oh oi aw oj bi"><span id="8d93" class="nu my it lt b gy ok ol l om on">from flask import Flask, request, jsonify, render_template, send_from_directory</span><span id="0ef7" class="nu my it lt b gy oo ol l om on">import random</span></pre><h2 id="ec1a" class="nu my it bd mz nv nw dn nd nx ny dp nh ld nz oa nj lh ob oc nl ll od oe nn of bi translated">导入(FastAPI)</h2><p id="1a48" class="pw-post-body-paragraph ku kv it kw b kx np ju kz la nq jx lc ld nr lf lg lh ns lj lk ll nt ln lo lp im bi translated">另一方面，对于<code class="fe lq lr ls lt b">FastAPI</code>，进口报表被分类到不同的包中。下面的代码片段包括对表单域输入的支持，以及对返回不同类型响应的支持。此外，它还可以通过模板引擎提供静态文件和HTML文件。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="op oq l"/></div></figure><p id="4bd4" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">如果您正在寻找一个最简单的导入语句，它应该是这样的</p><pre class="kj kk kl km gt og lt oh oi aw oj bi"><span id="f684" class="nu my it lt b gy ok ol l om on">from fastapi import FastAPI</span><span id="9c85" class="nu my it lt b gy oo ol l om on">from pydantic import BaseModel<br/>import random   # needed for generating a random number for an API<br/>import uvicorn  # optional if you run it directly from terminal</span></pre><h2 id="8bee" class="nu my it bd mz nv nw dn nd nx ny dp nh ld nz oa nj lh ob oc nl ll od oe nn of bi translated">初始化(烧瓶)</h2><p id="5d89" class="pw-post-body-paragraph ku kv it kw b kx np ju kz la nq jx lc ld nr lf lg lh ns lj lk ll nt ln lo lp im bi translated"><code class="fe lq lr ls lt b">Flask</code>中的初始化代码简单如下。<code class="fe lq lr ls lt b">Flask</code>将为您处理静态文件和模板引擎。</p><pre class="kj kk kl km gt og lt oh oi aw oj bi"><span id="8f2b" class="nu my it lt b gy ok ol l om on">app = Flask(__name__)</span></pre><h2 id="fdbf" class="nu my it bd mz nv nw dn nd nx ny dp nh ld nz oa nj lh ob oc nl ll od oe nn of bi translated">初始化(FastAPI)</h2><p id="8d1c" class="pw-post-body-paragraph ku kv it kw b kx np ju kz la nq jx lc ld nr lf lg lh ns lj lk ll nt ln lo lp im bi translated">除了标准的初始化之外，您还需要挂载用于服务静态文件的路径。同样，您必须通过模板引擎声明一个用于呈现的变量。大多数初始化代码围绕着基于<code class="fe lq lr ls lt b">Pydantic</code>语法创建数据模型类。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="op oq l"/></div></figure><h2 id="0acd" class="nu my it bd mz nv nw dn nd nx ny dp nh ld nz oa nj lh ob oc nl ll od oe nn of bi translated">你好世界(烧瓶)</h2><p id="0292" class="pw-post-body-paragraph ku kv it kw b kx np ju kz la nq jx lc ld nr lf lg lh ns lj lk ll nt ln lo lp im bi translated">让我们看看下面的代码片段，它创建了一个向用户返回字符串的路由。</p><pre class="kj kk kl km gt og lt oh oi aw oj bi"><span id="9d58" class="nu my it lt b gy ok ol l om on">@app.route('/')<br/>def hello():<br/>    return "Hello World!"</span></pre><h2 id="3540" class="nu my it bd mz nv nw dn nd nx ny dp nh ld nz oa nj lh ob oc nl ll od oe nn of bi translated">你好世界(FastAPI)</h2><p id="b951" class="pw-post-body-paragraph ku kv it kw b kx np ju kz la nq jx lc ld nr lf lg lh ns lj lk ll nt ln lo lp im bi translated"><code class="fe lq lr ls lt b">FastAPI</code>的“Hello World”功能等效如下。默认情况下，它将返回JSON作为响应。因此，您需要将<code class="fe lq lr ls lt b">response_class</code>改为<code class="fe lq lr ls lt b">PlainTextResponse</code>来返回一个字符串。</p><p id="6551" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated"><code class="fe lq lr ls lt b">async</code>不是必需的，但是它使得处理异步代码更加容易。建议定义它，除非您正在处理不支持异步的代码。</p><pre class="kj kk kl km gt og lt oh oi aw oj bi"><span id="a2e8" class="nu my it lt b gy ok ol l om on">@app.get("/", response_class=PlainTextResponse)<br/>async def hello():<br/>    return "Hello World!"</span></pre><h2 id="d723" class="nu my it bd mz nv nw dn nd nx ny dp nh ld nz oa nj lh ob oc nl ll od oe nn of bi translated">随机数(烧瓶)</h2><p id="ab39" class="pw-post-body-paragraph ku kv it kw b kx np ju kz la nq jx lc ld nr lf lg lh ns lj lk ll nt ln lo lp im bi translated">假设您有一个API，它返回一个随机生成的数字。在<code class="fe lq lr ls lt b">Flask</code>服务器中，您的代码应该如下所示。</p><pre class="kj kk kl km gt og lt oh oi aw oj bi"><span id="b927" class="nu my it lt b gy ok ol l om on">@app.route('/random-number')<br/>def random_number():<br/>    return str(random.randrange(100))</span></pre><h2 id="2955" class="nu my it bd mz nv nw dn nd nx ny dp nh ld nz oa nj lh ob oc nl ll od oe nn of bi translated">随机数(FastAPI)</h2><p id="c451" class="pw-post-body-paragraph ku kv it kw b kx np ju kz la nq jx lc ld nr lf lg lh ns lj lk ll nt ln lo lp im bi translated">对于<code class="fe lq lr ls lt b">FastAPI</code>服务器，您可以轻松修改如下:</p><pre class="kj kk kl km gt og lt oh oi aw oj bi"><span id="bc59" class="nu my it lt b gy ok ol l om on">@app.get('/random-number', response_class=PlainTextResponse)<br/>async def random_number():<br/>    return str(random.randrange(100))</span></pre><h2 id="7bfc" class="nu my it bd mz nv nw dn nd nx ny dp nh ld nz oa nj lh ob oc nl ll od oe nn of bi translated">检查伊萨法(烧瓶)</h2><p id="93ff" class="pw-post-body-paragraph ku kv it kw b kx np ju kz la nq jx lc ld nr lf lg lh ns lj lk ll nt ln lo lp im bi translated">接下来，我们将测试一个API，它接受一个名为<code class="fe lq lr ls lt b">text</code>的查询参数并返回JSON作为结果。在Flask中，该方法是通过route decorator设置的。在这种情况下，我们将其设置为仅接受<code class="fe lq lr ls lt b">GET</code>请求。</p><pre class="kj kk kl km gt og lt oh oi aw oj bi"><span id="2ebf" class="nu my it lt b gy ok ol l om on">@app.route('/alpha', methods=['GET'])<br/>def alpha():<br/>    text = request.args.get('text', '')</span><span id="06a4" class="nu my it lt b gy oo ol l om on">    result = {'text': text, 'is_alpha' : text.isalpha()}</span><span id="159e" class="nu my it lt b gy oo ol l om on">    return jsonify(result)</span></pre><h2 id="1888" class="nu my it bd mz nv nw dn nd nx ny dp nh ld nz oa nj lh ob oc nl ll od oe nn of bi translated">检查<code class="fe lq lr ls lt b">isAlpha</code> (FastAPI)</h2><p id="a535" class="pw-post-body-paragraph ku kv it kw b kx np ju kz la nq jx lc ld nr lf lg lh ns lj lk ll nt ln lo lp im bi translated">HTTP方法从一开始就和装饰器一起定义。用<code class="fe lq lr ls lt b">FastAPI</code>术语来说，这叫做操作。对于<code class="fe lq lr ls lt b">GET</code>操作，你需要称之为<code class="fe lq lr ls lt b">app.get</code>。对于具有相同功能的多个HTTP方法，您必须将逻辑封装在一个函数中，并在每个操作中独立调用它。</p><p id="839d" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">查询参数需要与类型提示一起指定。<code class="fe lq lr ls lt b">text: str</code>表示需要的字符串查询参数，称为<code class="fe lq lr ls lt b">text</code>。您可以为其分配默认值<code class="fe lq lr ls lt b">text = ‘text’</code>，使其成为可选参数。</p><pre class="kj kk kl km gt og lt oh oi aw oj bi"><span id="3e49" class="nu my it lt b gy ok ol l om on">@app.get('/alpha')<br/>async def alpha(text: str):<br/>    result = {'text': text, 'is_alpha' : text.isalpha()}</span><span id="f435" class="nu my it lt b gy oo ol l om on">return result</span></pre><h2 id="69cc" class="nu my it bd mz nv nw dn nd nx ny dp nh ld nz oa nj lh ob oc nl ll od oe nn of bi translated">创建新用户(烧瓶)</h2><p id="1b1a" class="pw-post-body-paragraph ku kv it kw b kx np ju kz la nq jx lc ld nr lf lg lh ns lj lk ll nt ln lo lp im bi translated">大多数情况下，您会收到一个向数据库添加新数据的<code class="fe lq lr ls lt b">POST</code>请求。让我们看看下面的例子，它接受两个表单字段并返回一个JSON结果。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="op oq l"/></div></figure><h2 id="adb6" class="nu my it bd mz nv nw dn nd nx ny dp nh ld nz oa nj lh ob oc nl ll od oe nn of bi translated">创建新用户(FastAPI)</h2><p id="0761" class="pw-post-body-paragraph ku kv it kw b kx np ju kz la nq jx lc ld nr lf lg lh ns lj lk ll nt ln lo lp im bi translated"><code class="fe lq lr ls lt b">POST</code>操作通过<code class="fe lq lr ls lt b">app.post</code>装饰器处理。当您声明输入参数时，您需要指定<code class="fe lq lr ls lt b">Form(…)</code>，因为默认实现是基于JSON或查询参数的。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="op oq l"/></div></figure><h2 id="ec45" class="nu my it bd mz nv nw dn nd nx ny dp nh ld nz oa nj lh ob oc nl ll od oe nn of bi translated">更新语言(烧瓶)</h2><p id="ab08" class="pw-post-body-paragraph ku kv it kw b kx np ju kz la nq jx lc ld nr lf lg lh ns lj lk ll nt ln lo lp im bi translated">到目前为止，我们已经讨论了查询参数和表单字段。让我们看看另一个例子，它将基于JSON输入更新一个名为<code class="fe lq lr ls lt b">language</code>的变量。对于更新现有数据，建议使用<code class="fe lq lr ls lt b">PUT</code>方法。下面的代码片段将展示如何通过条件语句来实现，而不是直接指定<code class="fe lq lr ls lt b">PUT</code>方法。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="op oq l"/></div></figure><h2 id="4237" class="nu my it bd mz nv nw dn nd nx ny dp nh ld nz oa nj lh ob oc nl ll od oe nn of bi translated">更新语言(FastAPI)</h2><p id="f9ba" class="pw-post-body-paragraph ku kv it kw b kx np ju kz la nq jx lc ld nr lf lg lh ns lj lk ll nt ln lo lp im bi translated">同样，<code class="fe lq lr ls lt b">PUT</code>操作通过<code class="fe lq lr ls lt b">app.put</code>装饰器调用。在初始化过程中，我们声明了下面的类</p><pre class="kj kk kl km gt og lt oh oi aw oj bi"><span id="6acd" class="nu my it lt b gy ok ol l om on">class Item(BaseModel):<br/>    language = 'english'</span></pre><p id="f636" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">我们将把它作为类型提示传递给<code class="fe lq lr ls lt b">item</code>输入参数。它将在后台被正确解析。您可以简单地使用<code class="fe lq lr ls lt b">variable_name.attribute_name</code>语法进行调用。这种情况下是<code class="fe lq lr ls lt b">item.language</code>。</p><pre class="kj kk kl km gt og lt oh oi aw oj bi"><span id="11ad" class="nu my it lt b gy ok ol l om on">@app.put('/update-language', response_class=PlainTextResponse)<br/>async def update_language(item: Item):<br/>    language = item.language</span><span id="caa1" class="nu my it lt b gy oo ol l om on">return "Successfully updated language to %s" % (language)</span></pre><h2 id="3cb8" class="nu my it bd mz nv nw dn nd nx ny dp nh ld nz oa nj lh ob oc nl ll od oe nn of bi translated">HTML网页(烧瓶)</h2><p id="e74b" class="pw-post-body-paragraph ku kv it kw b kx np ju kz la nq jx lc ld nr lf lg lh ns lj lk ll nt ln lo lp im bi translated">在Flask中提供HTML网页相对简单，因为它使用了<code class="fe lq lr ls lt b">Jinja2</code>模板引擎。你需要做的就是在一个名为templates的文件夹中声明HTML文件。如果您提供静态文件，您需要将它包含在一个名为static的文件夹中。</p><p id="7b97" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">下面的例子将使用<code class="fe lq lr ls lt b">index.html</code>渲染一个网页。变量可以作为输入参数传递，如下所示:</p><pre class="kj kk kl km gt og lt oh oi aw oj bi"><span id="e1f5" class="nu my it lt b gy ok ol l om on">@app.route('/get-webpage', methods=['GET'])<br/>def get_webpage():<br/>    return render_template('index.html', message="Contact Us")</span></pre><h2 id="ee44" class="nu my it bd mz nv nw dn nd nx ny dp nh ld nz oa nj lh ob oc nl ll od oe nn of bi translated">HTML网页(FastAPI)</h2><p id="4084" class="pw-post-body-paragraph ku kv it kw b kx np ju kz la nq jx lc ld nr lf lg lh ns lj lk ll nt ln lo lp im bi translated">在初始化过程中，我们安装了一个名为<code class="fe lq lr ls lt b">static</code>的文件夹，用于存放静态文件</p><pre class="kj kk kl km gt og lt oh oi aw oj bi"><span id="cb1f" class="nu my it lt b gy ok ol l om on">app.mount("/static", StaticFiles(directory="static"), name="static")</span></pre><p id="c977" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">此外，我们还为<code class="fe lq lr ls lt b">Jinja2Templates</code>创建了一个变量。它将用于呈现HTML模板。</p><pre class="kj kk kl km gt og lt oh oi aw oj bi"><span id="3423" class="nu my it lt b gy ok ol l om on">templates = Jinja2Templates(directory="templates")</span></pre><p id="214b" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">您需要将<code class="fe lq lr ls lt b">response_class</code>改为<code class="fe lq lr ls lt b">HTMLResponse</code>，以便提供HTML网页。如果不使用模板引擎，可以将结果作为字符串返回。</p><p id="b957" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">需要返回一个模板和你自定义参数。</p><pre class="kj kk kl km gt og lt oh oi aw oj bi"><span id="4c67" class="nu my it lt b gy ok ol l om on">@app.get('/get-webpage', response_class=HTMLResponse)<br/>async def get_webpage(request: Request):<br/>    return templates.TemplateResponse("index.html", {"request": request, "message": "Contact Us"})</span></pre><h2 id="990d" class="nu my it bd mz nv nw dn nd nx ny dp nh ld nz oa nj lh ob oc nl ll od oe nn of bi translated">文件响应(烧瓶)</h2><p id="c69c" class="pw-post-body-paragraph ku kv it kw b kx np ju kz la nq jx lc ld nr lf lg lh ns lj lk ll nt ln lo lp im bi translated">向用户返回文件的推荐方式是通过内置的<code class="fe lq lr ls lt b">send_from_directory()</code>函数，尤其是路径或文件来自用户的输入。它接受两个主要输入:</p><ul class=""><li id="cfae" class="mc md it kw b kx ky la lb ld me lh mf ll mg lp mh mi mj mk bi translated">文件所在的路径</li><li id="7c8e" class="mc md it kw b kx ml la mm ld mn lh mo ll mp lp mh mi mj mk bi translated">文件的名称</li></ul><p id="d265" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">此外，您可以指定额外的参数，如<code class="fe lq lr ls lt b">as_attachment</code>，它将修改<code class="fe lq lr ls lt b">Content-Disposition</code>头，将其指定为附件。</p><p id="ba5a" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">您可以使用下面的语法<code class="fe lq lr ls lt b">&lt;type:variable_name&gt;</code>指定path参数。这种情况下就是<code class="fe lq lr ls lt b">&lt;string:language&gt;</code>。</p><pre class="kj kk kl km gt og lt oh oi aw oj bi"><span id="e737" class="nu my it lt b gy ok ol l om on">@app.route('/get-language-file/&lt;string:language&gt;', methods=['GET'])<br/>def get_language_file(language):<br/>    return send_from_directory('./static/language', language + '.json', as_attachment=True)</span></pre><h2 id="3770" class="nu my it bd mz nv nw dn nd nx ny dp nh ld nz oa nj lh ob oc nl ll od oe nn of bi translated">文件响应(FastAPI)</h2><p id="ec5c" class="pw-post-body-paragraph ku kv it kw b kx np ju kz la nq jx lc ld nr lf lg lh ns lj lk ll nt ln lo lp im bi translated">根据您的要求和需要,<code class="fe lq lr ls lt b">FastAPI</code>带有相当多的<code class="fe lq lr ls lt b">Response</code>类型。要返回文件，您可以选择使用<code class="fe lq lr ls lt b">FileResponse</code>或<code class="fe lq lr ls lt b">StreamingResponse</code>。在本教程中，我将展示<code class="fe lq lr ls lt b">FileResponse</code>。它接受以下输入。</p><ul class=""><li id="6796" class="mc md it kw b kx ky la lb ld me lh mf ll mg lp mh mi mj mk bi translated"><code class="fe lq lr ls lt b">path</code>:要流式传输的文件的文件路径。</li><li id="f009" class="mc md it kw b kx ml la mm ld mn lh mo ll mp lp mh mi mj mk bi translated"><code class="fe lq lr ls lt b">headers</code>:要包含的任何自定义标题，作为字典。</li><li id="ab34" class="mc md it kw b kx ml la mm ld mn lh mo ll mp lp mh mi mj mk bi translated"><code class="fe lq lr ls lt b">media_type</code>:给出媒体类型的字符串。如果未设置，文件名或路径将用于推断媒体类型。</li><li id="e767" class="mc md it kw b kx ml la mm ld mn lh mo ll mp lp mh mi mj mk bi translated"><code class="fe lq lr ls lt b">filename</code>:如果设置，这将包括在响应<code class="fe lq lr ls lt b">Content-Disposition</code>中。</li></ul><p id="ff8c" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">让我们看看下面的代码片段，以便更好地了解它是如何工作的。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="op oq l"/></div></figure><h2 id="6db7" class="nu my it bd mz nv nw dn nd nx ny dp nh ld nz oa nj lh ob oc nl ll od oe nn of bi translated">主要(烧瓶)</h2><p id="e180" class="pw-post-body-paragraph ku kv it kw b kx np ju kz la nq jx lc ld nr lf lg lh ns lj lk ll nt ln lo lp im bi translated">在Flask中，您可以按如下方式指定主函数:</p><pre class="kj kk kl km gt og lt oh oi aw oj bi"><span id="976a" class="nu my it lt b gy ok ol l om on">if __name__ == '__main__':<br/>    app.run('0.0.0.0',port=8000)</span></pre><p id="fee3" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">然后，在终端中通过以下命令运行该文件:</p><pre class="kj kk kl km gt og lt oh oi aw oj bi"><span id="0bf0" class="nu my it lt b gy ok ol l om on">python myapp.py</span></pre><h2 id="20f5" class="nu my it bd mz nv nw dn nd nx ny dp nh ld nz oa nj lh ob oc nl ll od oe nn of bi translated">Main (FastAPI)</h2><p id="b993" class="pw-post-body-paragraph ku kv it kw b kx np ju kz la nq jx lc ld nr lf lg lh ns lj lk ll nt ln lo lp im bi translated">对于<code class="fe lq lr ls lt b">FastAPI</code>，需要导入<code class="fe lq lr ls lt b">uvicorn</code></p><pre class="kj kk kl km gt og lt oh oi aw oj bi"><span id="fa01" class="nu my it lt b gy ok ol l om on">import uvicorn</span></pre><p id="044a" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">并指定主函数如下(<code class="fe lq lr ls lt b">myapp</code>指文件名，<code class="fe lq lr ls lt b">app</code>指为<code class="fe lq lr ls lt b">FastAPI</code>实例声明的变量名):</p><pre class="kj kk kl km gt og lt oh oi aw oj bi"><span id="974c" class="nu my it lt b gy ok ol l om on">if __name__ == '__main__':<br/>    uvicorn.run('myapp:app', host='0.0.0.0', port=8000)</span></pre><p id="4074" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">然后，您可以从终端正常运行它:</p><pre class="kj kk kl km gt og lt oh oi aw oj bi"><span id="4294" class="nu my it lt b gy ok ol l om on">python myapp.py</span></pre><p id="9410" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">但是，推荐的方法是从终端直接通过<code class="fe lq lr ls lt b">uvicorn</code>运行它，而不需要调用main函数。</p><pre class="kj kk kl km gt og lt oh oi aw oj bi"><span id="363f" class="nu my it lt b gy ok ol l om on">uvicorn myapp:app</span></pre><p id="fb86" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">您可以指定其他参数，例如:</p><ul class=""><li id="59cc" class="mc md it kw b kx ky la lb ld me lh mf ll mg lp mh mi mj mk bi translated"><code class="fe lq lr ls lt b">reload</code>:启用自动重装，当你对文件进行修改时，自动重装会刷新服务器。对地方发展极其有用。</li><li id="68e7" class="mc md it kw b kx ml la mm ld mn lh mo ll mp lp mh mi mj mk bi translated"><code class="fe lq lr ls lt b">port</code>:服务器的端口号。默认是<code class="fe lq lr ls lt b">8000</code>。</li></ul><p id="fee9" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">下面的例子将使用<code class="fe lq lr ls lt b">5000</code>作为端口号。</p><pre class="kj kk kl km gt og lt oh oi aw oj bi"><span id="e3f4" class="nu my it lt b gy ok ol l om on">uvicorn myapp:app <!-- -->--reload --port 5000</span></pre><h2 id="6a73" class="nu my it bd mz nv nw dn nd nx ny dp nh ld nz oa nj lh ob oc nl ll od oe nn of bi translated">Flask服务器</h2><p id="4b82" class="pw-post-body-paragraph ku kv it kw b kx np ju kz la nq jx lc ld nr lf lg lh ns lj lk ll nt ln lo lp im bi translated">查看下面的<a class="ae lu" href="https://gist.github.com/wfng92/42269866a47298e7409b04f4b200bfac" rel="noopener ugc nofollow" target="_blank">要点</a>以获得<code class="fe lq lr ls lt b">Flask</code>服务器的完整代码。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="op oq l"/></div></figure><h2 id="3f51" class="nu my it bd mz nv nw dn nd nx ny dp nh ld nz oa nj lh ob oc nl ll od oe nn of bi translated">FastAPI服务器</h2><p id="0cda" class="pw-post-body-paragraph ku kv it kw b kx np ju kz la nq jx lc ld nr lf lg lh ns lj lk ll nt ln lo lp im bi translated">以下<a class="ae lu" href="https://gist.github.com/wfng92/d278a3df8e9dd5f5c32c32386dd09b57" rel="noopener ugc nofollow" target="_blank">要点</a>包含使用<code class="fe lq lr ls lt b">FastAPI</code>的相同功能的完整代码。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="op oq l"/></div></figure></div><div class="ab cl mq mr hx ms" role="separator"><span class="mt bw bk mu mv mw"/><span class="mt bw bk mu mv mw"/><span class="mt bw bk mu mv"/></div><div class="im in io ip iq"><h1 id="3ceb" class="mx my it bd mz na nb nc nd ne nf ng nh jz ni ka nj kc nk kd nl kf nm kg nn no bi translated">3.证明文件</h1><p id="b74d" class="pw-post-body-paragraph ku kv it kw b kx np ju kz la nq jx lc ld nr lf lg lh ns lj lk ll nt ln lo lp im bi translated">一旦你运行了<code class="fe lq lr ls lt b">FastAPI</code>服务器，你将可以访问另外两条记录文件的路径。</p><h2 id="c274" class="nu my it bd mz nv nw dn nd nx ny dp nh ld nz oa nj lh ob oc nl ll od oe nn of bi translated">交互文档(Swagger UI)</h2><p id="4862" class="pw-post-body-paragraph ku kv it kw b kx np ju kz la nq jx lc ld nr lf lg lh ns lj lk ll nt ln lo lp im bi translated">第一个是<code class="fe lq lr ls lt b">Swagger UI</code>提供的交互文档。如果您在端口<code class="fe lq lr ls lt b">8000</code>上运行服务器，您可以通过以下URL访问它</p><pre class="kj kk kl km gt og lt oh oi aw oj bi"><span id="0388" class="nu my it lt b gy ok ol l om on"><a class="ae lu" href="http://localhost:8000/docs" rel="noopener ugc nofollow" target="_blank">http://localhost:8000/docs</a></span></pre><p id="abf0" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">您应该会看到以下网页:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="os ot di ou bf ov"><div class="gh gi or"><img src="../Images/fd1c49e2c51ce4367fec2c522f78773a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*QJSf6GAnN6HA0Fnfuz_Q_w.png"/></div></div><p class="kq kr gj gh gi ks kt bd b be z dk translated">作者提供的截图。</p></figure><p id="67a2" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">它是一个交互式文档，您可以在其中单独测试API。当你点击<code class="fe lq lr ls lt b">/alpha</code>路线时，你应该会看到下面的界面。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="os ot di ou bf ov"><div class="gh gi ow"><img src="../Images/64057067b04ad9aa2b9b23e235fc15b5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*WOgnbbhM7c8OaIHY6wQWcw.png"/></div></div><p class="kq kr gj gh gi ks kt bd b be z dk translated">作者提供的截图。</p></figure><p id="5662" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">单击“试用”按钮，并在文本字段中输入一个字符串。接下来，单击“执行”按钮，您应该会得到以下结果:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="os ot di ou bf ov"><div class="gh gi ox"><img src="../Images/12042e23e00c2132dcc4597537fbb096.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Xq71Ln6oUhB0P8C_iDL7Yw.png"/></div></div><p class="kq kr gj gh gi ks kt bd b be z dk translated">作者提供的截图。</p></figure><h2 id="df7b" class="nu my it bd mz nv nw dn nd nx ny dp nh ld nz oa nj lh ob oc nl ll od oe nn of bi translated">雷多克</h2><p id="c0d9" class="pw-post-body-paragraph ku kv it kw b kx np ju kz la nq jx lc ld nr lf lg lh ns lj lk ll nt ln lo lp im bi translated">此外，<code class="fe lq lr ls lt b">FastAPI</code>还附带了由<code class="fe lq lr ls lt b">ReDoc</code>提供的替代文档。您可以通过以下URL访问它:</p><pre class="kj kk kl km gt og lt oh oi aw oj bi"><span id="3010" class="nu my it lt b gy ok ol l om on"><a class="ae lu" href="http://localhost:8000/redoc" rel="noopener ugc nofollow" target="_blank">http://localhost:8000/redoc</a></span></pre><p id="48cf" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">您应该会看到以下文档。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="os ot di ou bf ov"><div class="gh gi oy"><img src="../Images/6d34488e2bd5b764c08f08c9807ad48e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*3JaLqZQbeRopir72cdZ2VA.png"/></div></div><p class="kq kr gj gh gi ks kt bd b be z dk translated">作者提供的截图。</p></figure></div><div class="ab cl mq mr hx ms" role="separator"><span class="mt bw bk mu mv mw"/><span class="mt bw bk mu mv mw"/><span class="mt bw bk mu mv"/></div><div class="im in io ip iq"><h1 id="6da1" class="mx my it bd mz na nb nc nd ne nf ng nh jz ni ka nj kc nk kd nl kf nm kg nn no bi translated">4.结论</h1><p id="cf7e" class="pw-post-body-paragraph ku kv it kw b kx np ju kz la nq jx lc ld nr lf lg lh ns lj lk ll nt ln lo lp im bi translated">让我们回顾一下今天所学的内容。</p><p id="70a7" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">我们首先简要介绍了背景，并解释了<code class="fe lq lr ls lt b">FastAPI</code>背后的核心概念。然后，我们继续安装运行<code class="fe lq lr ls lt b">Flask</code>和<code class="fe lq lr ls lt b">FastAPI</code>所需的模块。</p><p id="2139" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">安装完成后，我们测试了用不同的HTTP方法、输入请求和输出响应实现几个API。结果，我们看到了不同之处，并学会了做出必要的修改，将我们的代码从Flask转移到<code class="fe lq lr ls lt b">FastAPI</code>的等效功能中。</p><p id="a1c3" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">到目前为止，您应该对基于您的用例将您的<code class="fe lq lr ls lt b">Flask</code>服务器迁移到<code class="fe lq lr ls lt b">FastAPI</code>服务器有了基本的了解。</p></div><div class="ab cl mq mr hx ms" role="separator"><span class="mt bw bk mu mv mw"/><span class="mt bw bk mu mv mw"/><span class="mt bw bk mu mv"/></div><div class="im in io ip iq"><h1 id="019b" class="mx my it bd mz na nb nc nd ne nf ng nh jz ni ka nj kc nk kd nl kf nm kg nn no bi translated">参考</h1><ol class=""><li id="f25e" class="mc md it kw b kx np la nq ld oz lh pa ll pb lp pc mi mj mk bi translated"><a class="ae lu" href="https://github.com/encode/uvicorn" rel="noopener ugc nofollow" target="_blank">uvicon Github页面</a></li><li id="4483" class="mc md it kw b kx ml la mm ld mn lh mo ll mp lp pc mi mj mk bi translated"><a class="ae lu" href="https://www.uvicorn.org/" rel="noopener ugc nofollow" target="_blank">uv icon文档</a></li><li id="7bd6" class="mc md it kw b kx ml la mm ld mn lh mo ll mp lp pc mi mj mk bi translated"><a class="ae lu" href="https://github.com/tiangolo/fastapi" rel="noopener ugc nofollow" target="_blank"> FastAPI Github页面</a></li><li id="62b7" class="mc md it kw b kx ml la mm ld mn lh mo ll mp lp pc mi mj mk bi translated"><a class="ae lu" href="https://fastapi.tiangolo.com/" rel="noopener ugc nofollow" target="_blank"> FastAPI文档</a></li></ol></div></div>    
</body>
</html>