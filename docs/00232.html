<html>
<head>
<title>How to read version and other information from Android and iOS apps using Java</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何使用Java从Android和iOS应用程序中读取版本和其他信息</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/how-to-read-version-and-other-information-from-android-and-ios-apps-using-java-3be7cf067f79?source=collection_archive---------1-----------------------#2018-11-19">https://betterprogramming.pub/how-to-read-version-and-other-information-from-android-and-ios-apps-using-java-3be7cf067f79?source=collection_archive---------1-----------------------#2018-11-19</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="9398" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">从APK、IPA和应用程序包中轻松检索版本信息</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/537216ecbfdf22f1956d01c45b81f88f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*71_jrGctRTWB8rKOXiFpkg.jpeg"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated"><a class="ae ky" href="https://www.flickr.com/photos/pestoverde/16324871102/" rel="noopener ugc nofollow" target="_blank">图片来源:Maurizio Pesce/flickr </a></p></figure><p id="5478" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">很多时候，尤其是在对移动应用程序运行自动化测试时，验证应用程序的正确版本是非常重要的。本文描述了使用命令行工具或Java库从Android和iOS应用程序包中查询版本信息的简单方法。这两种方法都可以很容易地集成到构建管道中。</p><h2 id="f332" class="lv lw it bd lx ly lz dn ma mb mc dp md li me mf mg lm mh mi mj lq mk ml mm mn bi translated">命令行方式</h2><p id="3ce3" class="pw-post-body-paragraph kz la it lb b lc mo ju le lf mp jx lh li mq lk ll lm mr lo lp lq ms ls lt lu im bi translated">对于Android，从APK文件中解析元信息的一种方法是像这样使用<code class="fe mt mu mv mw b">aapt </code>:</p><pre class="kj kk kl km gt mx mw my mz aw na bi"><span id="72a5" class="lv lw it mw b gy nb nc l nd ne">aapt dump badging /path/test.apk</span></pre><p id="8e34" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这将打印大量信息，因此我们需要将输出调整为我们感兴趣的内容:</p><pre class="kj kk kl km gt mx mw my mz aw na bi"><span id="db64" class="lv lw it mw b gy nb nc l nd ne">aapt dump badging test.apk | grep -o 'versionName=[^,]*' | cut -d'=' -f 2 | cut -d ' ' -f 1 | tr -d "'"</span></pre><p id="7c29" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">类似地，我们也可以查询版本代码(或任何其他相关信息):</p><pre class="kj kk kl km gt mx mw my mz aw na bi"><span id="4669" class="lv lw it mw b gy nb nc l nd ne">aapt dump badging /path/test.apk | grep -o ‘versionCode=[^,]*’ | cut -d’=’ -f 2 | cut -d ‘ ‘ -f 1 | tr -d "'"</span></pre><p id="01c7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果我们将应用程序安装在通过<code class="fe mt mu mv mw b">adb</code>连接的设备(物理或模拟器)上，我们也可以像这样查询版本:</p><pre class="kj kk kl km gt mx mw my mz aw na bi"><span id="ef33" class="lv lw it mw b gy nb nc l nd ne">adb shell dumpsys package package.of.the.app | grep versionName | cut -d'=' -f 2 | cut -d ' ' -f 1</span><span id="c916" class="lv lw it mw b gy nf nc l nd ne">adb shell dumpsys package package.of.the.app | grep versionCode | cut -d'=' -f 2 | cut -d ' ' -f 1</span></pre><p id="f839" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">对于iOS应用，我们先考虑应用包(用于模拟器)。如果我们在Mac OSX上，我们可以使用<code class="fe mt mu mv mw b">defaults</code>。请注意，路径必须是绝对的:</p><pre class="kj kk kl km gt mx mw my mz aw na bi"><span id="d640" class="lv lw it mw b gy nb nc l nd ne">defaults read /path/test.app/Info CFBundleShortVersionString<br/>defaults read /path/test.app/Info CFBundleVersion</span></pre><p id="0e32" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在Linux上，我们需要<code class="fe mt mu mv mw b">plistutil</code>和像<code class="fe mt mu mv mw b">xmllint</code>这样的XML解析器:</p><pre class="kj kk kl km gt mx mw my mz aw na bi"><span id="d66f" class="lv lw it mw b gy nb nc l nd ne">plistutil -i /path/test.app/Info | xmllint --xpath "//key[text()='CFBundleShortVersionString']/following-sibling::string[1]/text()" -<br/>plistutil -i /path/test.app/Info | xmllint --xpath "//key[text()='CFBundleVersion']/following-sibling::string[1]/text()"</span></pre><p id="b9c8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果我们想从一个IPA文件(用于物理设备)中检索版本信息，我们必须首先解包它。然后，我们可以运行与上面相同的命令:</p><pre class="kj kk kl km gt mx mw my mz aw na bi"><span id="b30a" class="lv lw it mw b gy nb nc l nd ne"># Unpack IPA file<br/>unzip -q /path/test.ipa -d /tmp/ipa</span><span id="ee88" class="lv lw it mw b gy nf nc l nd ne"># Mac OS<br/>defaults read /tmp/ipa/Payload/test.app/Info CFBundleShortVersionString<br/>defaults read /tmp/ipa/Payload/test.app/Info CFBundleVersion</span><span id="9c2b" class="lv lw it mw b gy nf nc l nd ne"># Linux<br/>plistutil -i /tmp/ipa/Payload/test.app/Info | xmllint --xpath "//key[text()='CFBundleShortVersionString']/following-sibling::string[1]/text()" -<br/>plistutil -i /tmp/ipa/Payload/test.app/Info | xmllint --xpath "//key[text()='CFBundleVersion']/following-sibling::string[1]/text()"</span><span id="0f06" class="lv lw it mw b gy nf nc l nd ne"># Clean-up<br/>rm -rf /tmp/ipa</span></pre><h2 id="52f7" class="lv lw it bd lx ly lz dn ma mb mc dp md li me mf mg lm mh mi mj lq mk ml mm mn bi translated">Java之路</h2><p id="5946" class="pw-post-body-paragraph kz la it lb b lc mo ju le lf mp jx lh li mq lk ll lm mr lo lp lq ms ls lt lu im bi translated">从Java程序中检索版本信息的一种方法是使用<code class="fe mt mu mv mw b">Runtime</code>或<code class="fe mt mu mv mw b">ProcessBuilder</code>来执行上面的shell命令。然而，这是依赖于平台的，有点脆弱。它要求使用的工具(<code class="fe mt mu mv mw b">aapt</code>、<code class="fe mt mu mv mw b">plistutil</code>、<code class="fe mt mu mv mw b">xmllint</code>等)。)可在运行Java代码的机器上获得。</p><p id="5818" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">因此，本地Java解决方案是更可取的。幸运的是，有满足我们所有需求的开源库:</p><ul class=""><li id="1fcc" class="ng nh it lb b lc ld lf lg li ni lm nj lq nk lu nl nm nn no bi translated">apk解析器:这个库允许我们从APK文件中读取信息。</li><li id="8456" class="ng nh it lb b lc np lf nq li nr lm ns lq nt lu nl nm nn no bi translated"><a class="ae ky" href="https://github.com/3breadt/dd-plist" rel="noopener ugc nofollow" target="_blank"> dd-plist </a>:这个库可以处理用于存储iOS应用元信息的<code class="fe mt mu mv mw b">plist </code>文件。</li><li id="922a" class="ng nh it lb b lc np lf nq li nr lm ns lq nt lu nl nm nn no bi translated"><a class="ae ky" href="http://www.lingala.net/zip4j/" rel="noopener ugc nofollow" target="_blank"> zip4j </a>:这个库是Java中处理zip文件的众多选项之一。</li></ul><p id="3714" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">使用Maven，我们可以将它们包含在我们的项目中:</p><pre class="kj kk kl km gt mx mw my mz aw na bi"><span id="9a7f" class="lv lw it mw b gy nb nc l nd ne">&lt;properties&gt;<br/>  &lt;dd.plist.version&gt;1.21&lt;/dd.plist.version&gt;<br/>  &lt;apk.parser.version&gt;2.6.4&lt;/apk.parser.version&gt;<br/>  &lt;zip4j.version&gt;1.3.2&lt;/zip4j.version&gt;<br/>&lt;/properties&gt;</span><span id="e369" class="lv lw it mw b gy nf nc l nd ne">&lt;dependencies&gt;<br/>  &lt;dependency&gt;<br/>    &lt;groupId&gt;com.googlecode.plist&lt;/groupId&gt;<br/>    &lt;artifactId&gt;dd-plist&lt;/artifactId&gt;<br/>    &lt;version&gt;${dd.plist.version}&lt;/version&gt;<br/>  &lt;/dependency&gt;<br/>  &lt;dependency&gt;<br/>    &lt;groupId&gt;net.dongliu&lt;/groupId&gt;<br/>    &lt;artifactId&gt;apk-parser&lt;/artifactId&gt;<br/>    &lt;version&gt;${apk.parser.version}&lt;/version&gt;<br/>  &lt;/dependency&gt;<br/>  &lt;dependency&gt;<br/>    &lt;groupId&gt;net.lingala.zip4j&lt;/groupId&gt;<br/>    &lt;artifactId&gt;zip4j&lt;/artifactId&gt;<br/>    &lt;version&gt;${zip4j.version}&lt;/version&gt;<br/>  &lt;/dependency&gt;<br/>&lt;/depdencies&gt;</span></pre><p id="0841" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">对于Android，我们可以像这样简单地获取版本信息:</p><pre class="kj kk kl km gt mx mw my mz aw na bi"><span id="dd79" class="lv lw it mw b gy nb nc l nd ne">String appPath = "/path/test.apk";<br/>ApkFile apkFile = <strong class="mw iu">new</strong> ApkFile(<strong class="mw iu">new</strong> File(appPath));<br/>ApkMeta apkMeta = apkFile.getApkMeta();<br/>String versionName = apkMeta.getVersionName();<br/>String versionCode = apkMeta.getVersionCode().toString();</span></pre><p id="e4a3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">对于iOS，应用程序包的代码如下所示:</p><pre class="kj kk kl km gt mx mw my mz aw na bi"><span id="13ca" class="lv lw it mw b gy nb nc l nd ne">String appPath = "/path/test.app";<br/>NSDictionary dictionary = (NSDictionary) PropertyListParser.<em class="nu">parse</em>(path);<br/>String versionName = dictionary.objectForKey(“CFBundleShortVersionString”).toString();<br/>String versionCode = dictionary.objectForKey(“CFBundleVersion”).toString();</span></pre><p id="fa6d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果我们处理的是IPA文件:</p><pre class="kj kk kl km gt mx mw my mz aw na bi"><span id="f972" class="lv lw it mw b gy nb nc l nd ne">String appPath = "/path/test.ipa";</span><span id="567e" class="lv lw it mw b gy nf nc l nd ne"># Unpack IPA file<br/>String tmpFolder = File.<strong class="mw iu"><em class="nu">separator</em></strong> + "tmp" + File.<strong class="mw iu"><em class="nu">separator</em></strong> + UUID.<em class="nu">randomUUID</em>().toString();<br/>ZipFile zipFile = <strong class="mw iu">new</strong> ZipFile(appPath);<br/>zipFile.extractAll(tmpFolder);</span><span id="6bd8" class="lv lw it mw b gy nf nc l nd ne"># Fetch version information<br/>NSDictionary dictionary = (NSDictionary) PropertyListParser.<em class="nu">parse</em>(<strong class="mw iu">new</strong> File(<strong class="mw iu">new</strong> File(tmpFolder + File.<strong class="mw iu"><em class="nu">separator</em></strong> + "Payload").listFiles()[0].getAbsolutePath() + File.<strong class="mw iu"><em class="nu">separator </em></strong>+ "Info.plist"));</span><span id="d708" class="lv lw it mw b gy nf nc l nd ne">String versionName = dictionary.objectForKey(“CFBundleShortVersionString”).toString();<br/>String versionCode = dictionary.objectForKey(“CFBundleVersion”).toString();</span><span id="2cfa" class="lv lw it mw b gy nf nc l nd ne"># Clean-up<br/>Files.<em class="nu">walk</em>(Paths.<em class="nu">get</em>(tmpFolder)).sorted(Comparator.<em class="nu">reverseOrder</em>()).map(Path::toFile).forEach(File::delete);</span></pre><p id="c087" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">为了简单起见，上面的例子中已经去掉了异常处理。</p><p id="3e66" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">完整的代码可以在这里<a class="ae ky" href="https://github.com/martinschneider/justtestlah/blob/master/justtestlah-mobile-tools/src/main/java/io/github/martinschneider/justtestlah/mobile/tools/ApplicationInfoService.java" rel="noopener ugc nofollow" target="_blank">找到。</a></p><h2 id="69b0" class="lv lw it bd lx ly lz dn ma mb mc dp md li me mf mg lm mh mi mj lq mk ml mm mn bi translated">多功能图书馆</h2><p id="8664" class="pw-post-body-paragraph kz la it lb b lc mo ju le lf mp jx lh li mq lk ll lm mr lo lp lq ms ls lt lu im bi translated">上面的演示是测试框架的一部分。您可以使用<code class="fe mt mu mv mw b">mobile-tools</code> JAR(附带了最少的附加依赖)来查询Android和iOS应用程序的版本和其他元信息。按如下方式导入它:</p><pre class="kj kk kl km gt mx mw my mz aw na bi"><span id="20fa" class="lv lw it mw b gy nb nc l nd ne">&lt;properties&gt;<br/>  &lt;justtestlah.version&gt;1.3.2&lt;/justtestlah.version&gt;<br/>&lt;/properties&gt;</span><span id="5677" class="lv lw it mw b gy nf nc l nd ne">&lt;dependencies&gt;<br/>  &lt;dependency&gt;<br/>    &lt;groupId&gt;io.github.martinschneider&lt;/groupId&gt;<br/>    &lt;artifactId&gt;justtestlah-mobile-tools&lt;/artifactId&gt;<br/>    &lt;version&gt;${justtestlah.version}&lt;/version&gt;<br/>  &lt;/dependency&gt;<br/>&lt;/depdencies&gt;</span></pre><p id="0a92" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">然后，简单地像这样使用它:</p><pre class="kj kk kl km gt mx mw my mz aw na bi"><span id="3d67" class="lv lw it mw b gy nb nc l nd ne">ApplicationInfo appInfo = <strong class="mw iu">new</strong> ApplicationInfoService().getAppInfo(appPath);</span><span id="055d" class="lv lw it mw b gy nf nc l nd ne">String versionName = appInfo.getVersionName();<br/>String versionCode = appInfo.getVersionCode();<br/>String applicationName = appInfo.getApplicationName();</span></pre><p id="d253" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe mt mu mv mw b">appPath</code>可以指向任何APK、IPA或APP文件。</p></div></div>    
</body>
</html>