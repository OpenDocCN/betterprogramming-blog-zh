<html>
<head>
<title>An Introduction to Parallel Programming</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">并行编程导论</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/an-introduction-to-parallel-programming-972eb16921ce?source=collection_archive---------15-----------------------#2022-01-05">https://betterprogramming.pub/an-introduction-to-parallel-programming-972eb16921ce?source=collection_archive---------15-----------------------#2022-01-05</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="ec59" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">解决计算问题的另一种方法</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/65a474e5ab8fb5af89386c2aa82fdf44.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*3aH5eARH1AHsUAJV"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">乔希·米尔斯在<a class="ae kv" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的照片</p></figure><h1 id="0089" class="kw kx iq bd ky kz la lb lc ld le lf lg jw lh jx li jz lj ka lk kc ll kd lm ln bi translated">顺序程序设计</h1><p id="f389" class="pw-post-body-paragraph lo lp iq lq b lr ls jr lt lu lv ju lw lx ly lz ma mb mc md me mf mg mh mi mj ij bi translated">当你正在学习计算机科学，并且正在编写你的第一个程序时，最常见的方式是<em class="mk">顺序或结构化编程</em>。它是一个指令或动作按顺序跟随另一个指令或动作的过程。在这种类型的编程中，操作从开始到结束，变量初始化，赋值操作，计算，总结，等等。它还可以调用函数，并且可以在循环中停留一定的时间。一种算法将问题分成更小的指令。然后，这些指令在计算机的中央处理器(CPU)上逐一执行。一条指令完成后，下一条指令才开始。</p><h2 id="7ffa" class="ml kx iq bd ky mm mn dn lc mo mp dp lg lx mq mr li mb ms mt lk mf mu mv lm mw bi translated">冯·诺依曼模型</h2><p id="3aeb" class="pw-post-body-paragraph lo lp iq lq b lr ls jr lt lu lv ju lw lx ly lz ma mb mc md me mf mg mh mi mj ij bi translated">它是基于数学家和物理学家约翰·冯·诺依曼在1945年描述的计算机体系结构。它描述了一种顺序计算机的设计体系结构，其部件包括包含逻辑运算单元和处理器寄存器的处理单元、包含指令寄存器和程序计数器的控制单元、用于存储数据和指令的存储器、外部大容量存储器以及进入和退出机制。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi mx"><img src="../Images/80dc788457298b532443e5fddf6c9fe9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1178/format:webp/1*5CquW1d2KqM2od5JRmoRdg.png"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">冯·诺依曼建筑</p></figure><h1 id="5578" class="kw kx iq bd ky kz la lb lc ld le lf lg jw lh jx li jz lj ka lk kc ll kd lm ln bi translated">并行和计算</h1><p id="e457" class="pw-post-body-paragraph lo lp iq lq b lr ls jr lt lu lv ju lw lx ly lz ma mb mc md me mf mg mh mi mj ij bi translated">并行计算是使用并行计算机来减少解决计算问题的时间。并行计算机是指具有多个支持<em class="mk">并行计算</em>的处理器的计算机。</p><blockquote class="my mz na"><p id="f4de" class="lo lp mk lq b lr nb jr lt lu nc ju lw nd ne lz ma nf ng md me nh ni mh mi mj ij bi translated">并行性有时被视为计算的一个罕见而奇特的子领域，很有趣，但对普通程序员来说没什么意义。并行正变得无处不在，并行编程正成为编程企业的核心。—伊恩·福斯特</p></blockquote><p id="b1b2" class="pw-post-body-paragraph lo lp iq lq b lr nb jr lt lu nc ju lw lx ne lz ma mb ng md me mf ni mh mi mj ij bi translated">串行计算“浪费”了潜在的计算能力，因此并行计算使硬件更好地工作。并行编程是用一种编程语言进行编程，这种编程语言允许您显式地指示不同处理器如何执行进程的不同部分。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi nj"><img src="../Images/374c7242905ab50710c98e0ca2c67a23.png" data-original-src="https://miro.medium.com/v2/resize:fit:878/format:webp/1*6TjhCRsOA5jJywRKsjLNdA.png"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">并行计算机的一个例子。各种处理器被连接到共享存储块</p></figure><h2 id="37d6" class="ml kx iq bd ky mm mn dn lc mo mp dp lg lx mq mr li mb ms mt lk mf mu mv lm mw bi translated">并行计算的目标</h2><ul class=""><li id="8f7f" class="nk nl iq lq b lr ls lu lv lx nm mb nn mf no mj np nq nr ns bi translated">负载平衡</li><li id="4fc3" class="nk nl iq lq b lr nt lu nu lx nv mb nw mf nx mj np nq nr ns bi translated">当我们在分配任务时，处理器之间的通信很少</li></ul><h2 id="b57c" class="ml kx iq bd ky mm mn dn lc mo mp dp lg lx mq mr li mb ms mt lk mf mu mv lm mw bi translated">弗林分类法</h2><p id="73d6" class="pw-post-body-paragraph lo lp iq lq b lr ls jr lt lu lv ju lw lx ly lz ma mb mc md me mf mg mh mi mj ij bi translated">Flynn分类法是对计算机体系结构的分类，由Michael J. Flynn于1966年提出。上面说电脑分为4类:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi mx"><img src="../Images/5af249c2a29a555b471fdad3dacd04b7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1178/format:webp/1*tRiSxmENOvNaMabm6jTLhw.png"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">弗林分类法</p></figure><ol class=""><li id="e25d" class="nk nl iq lq b lr nb lu nc lx ny mb nz mf oa mj ob nq nr ns bi translated"><strong class="lq ir"> SISD </strong>:一条指令会在同一时间对一条数据执行。指遵循冯·诺依曼体系结构的顺序计算机。</li><li id="dd1b" class="nk nl iq lq b lr nt lu nu lx nv mb nw mf nx mj ob nq nr ns bi translated"><strong class="lq ir"> SIMD </strong>:我们有一个单一的指令，将应用于多个数据。这个想法是，所有的处理器(假设我们有多个处理器)都在工作和执行相同的指令，并且将对不同的数据执行。</li><li id="0ca7" class="nk nl iq lq b lr nt lu nu lx nv mb nw mf nx mj ob nq nr ns bi translated"><strong class="lq ir"> MISD </strong>:一台多处理器计算机，能够在不同的处理器上执行不同的指令，但它们都在同一数据集上工作。</li><li id="4893" class="nk nl iq lq b lr nt lu nu lx nv mb nw mf nx mj ob nq nr ns bi translated">MIMD:能够在多个数据集上执行多条指令。它就像今天的大多数电脑一样，像笔记本电脑和一些电话。</li></ol><h2 id="d8ca" class="ml kx iq bd ky mm mn dn lc mo mp dp lg lx mq mr li mb ms mt lk mf mu mv lm mw bi translated">MPI和并行计算软件</h2><p id="bdca" class="pw-post-body-paragraph lo lp iq lq b lr ls jr lt lu lv ju lw lx ly lz ma mb mc md me mf mg mh mi mj ij bi translated">最常见的并行计算是MPI和OpenMP。MPI实现存在于C/C++、Fortran甚至Python中。</p><p id="43bc" class="pw-post-body-paragraph lo lp iq lq b lr nb jr lt lu nc ju lw lx ne lz ma mb ng md me mf ni mh mi mj ij bi translated">MPI(消息传递接口)是一个消息传递库接口规范。这个定义的所有部分都很重要。MPI主要解决消息传递并行编程模型，在该模型中，数据通过每个进程中的协作操作从一个进程的地址空间移动到另一个进程的地址空间。</p><p id="2ba1" class="pw-post-body-paragraph lo lp iq lq b lr nb jr lt lu nc ju lw lx ne lz ma mb ng md me mf ni mh mi mj ij bi translated">MPI程序由自治进程组成，它们以MIMD方式执行自己的代码。每个进程执行的代码并不相同。这些进程通过调用MPI通信函数进行通信。</p><p id="43a3" class="pw-post-body-paragraph lo lp iq lq b lr nb jr lt lu nc ju lw lx ne lz ma mb ng md me mf ni mh mi mj ij bi translated">尽管支持共享内存，但每个进程都在自己的地址空间中运行。MPI的思想是使用分布式计算(在进程间传递消息)。</p><h2 id="72bb" class="ml kx iq bd ky mm mn dn lc mo mp dp lg lx mq mr li mb ms mt lk mf mu mv lm mw bi translated">MPI库示例</h2><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="oc od l"/></div></figure><p id="f81a" class="pw-post-body-paragraph lo lp iq lq b lr nb jr lt lu nc ju lw lx ne lz ma mb ng md me mf ni mh mi mj ij bi translated">在初始化MPI环境之后，几乎所有的MPI函数都必须通过调用<code class="fe oe of og oh b">MPI_Init ()</code>函数来调用，在使用<code class="fe oe of og oh b">MPI_Finalize ()</code>结束该环境之后，几乎没有函数可以被调用。</p><p id="7a80" class="pw-post-body-paragraph lo lp iq lq b lr nb jr lt lu nc ju lw lx ne lz ma mb ng md me mf ni mh mi mj ij bi translated">当你创建一个MPI程序时，你需要定义一个通信器。<code class="fe oe of og oh b">MPI_COMM_WORLD</code>是一个默认的通信器，它连接程序中的所有进程。要查看更多标准，请访问此<a class="ae kv" href="https://www.mpi-forum.org/docs/" rel="noopener ugc nofollow" target="_blank">链接</a>。</p><p id="a366" class="pw-post-body-paragraph lo lp iq lq b lr nb jr lt lu nc ju lw lx ne lz ma mb ng md me mf ni mh mi mj ij bi translated">通常，变量rank代表进程标识符，而size代表将执行程序的进程的数量。</p><p id="1996" class="pw-post-body-paragraph lo lp iq lq b lr nb jr lt lu nc ju lw lx ne lz ma mb ng md me mf ni mh mi mj ij bi translated">为了在C中运行MPI程序，编译<em class="mk">的指令是:</em></p><pre class="kg kh ki kj gt oi oh oj ok aw ol bi"><span id="a9f5" class="ml kx iq oh b gy om on l oo op"><strong class="oh ir">$ mpicc program_name.c -o object-program</strong></span></pre><p id="6726" class="pw-post-body-paragraph lo lp iq lq b lr nb jr lt lu nc ju lw lx ne lz ma mb ng md me mf ni mh mi mj ij bi translated">并且对<em class="mk">执行</em>是用指令:</p><pre class="kg kh ki kj gt oi oh oj ok aw ol bi"><span id="faa0" class="ml kx iq oh b gy om on l oo op"><strong class="oh ir">$ mpiexec -np {number-of-processes} ./object_program</strong></span></pre><p id="20b1" class="pw-post-body-paragraph lo lp iq lq b lr nb jr lt lu nc ju lw lx ne lz ma mb ng md me mf ni mh mi mj ij bi translated">有5个进程的<em class="mk"> hello-mpi.c </em>程序的输出如下:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi oq"><img src="../Images/341d40d48a7609c3db293ec4cf404207.png" data-original-src="https://miro.medium.com/v2/resize:fit:442/format:webp/1*5Z9gtBOXcp-uKnq2o9Erdg.png"/></div></figure><p id="e67b" class="pw-post-body-paragraph lo lp iq lq b lr nb jr lt lu nc ju lw lx ne lz ma mb ng md me mf ni mh mi mj ij bi translated">如上图所示，所有进程都在争用CPU资源。所以每一个的到达时间有(很小的)差别。每次程序运行时，进程的顺序很可能会改变。</p><p id="0605" class="pw-post-body-paragraph lo lp iq lq b lr nb jr lt lu nc ju lw lx ne lz ma mb ng md me mf ni mh mi mj ij bi translated">下一个例子是关于本地通信:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="oc od l"/></div></figure><p id="6c2f" class="pw-post-body-paragraph lo lp iq lq b lr nb jr lt lu nc ju lw lx ne lz ma mb ng md me mf ni mh mi mj ij bi translated">它使用<code class="fe oe of og oh b">MPI_Send()</code>和<code class="fe oe of og oh b">MPI_Recv()</code>功能。在这种情况下，进程0向进程1发送变量= 10。</p><h1 id="0de4" class="kw kx iq bd ky kz la lb lc ld le lf lg jw lh jx li jz lj ka lk kc ll kd lm ln bi translated">结论</h1><p id="f5ac" class="pw-post-body-paragraph lo lp iq lq b lr ls jr lt lu lv ju lw lx ly lz ma mb mc md me mf mg mh mi mj ij bi translated">这只是您可以用并行计算做的事情的一点点尝试。有很多事情，比如发送和接收操作，将消息和数据从一个进程传递到另一个进程，等等。</p><p id="e47b" class="pw-post-body-paragraph lo lp iq lq b lr nb jr lt lu nc ju lw lx ne lz ma mb ng md me mf ni mh mi mj ij bi translated">想象一下数据排序。如果数据量增加，使用顺序算法可能需要很长时间。做数据并行，我们可以把数据集分成几个进程，在这些进程中执行同一个指令。如果有一个矩阵相乘的程序就更好了，结果，我们将节省执行时间。</p><p id="3036" class="pw-post-body-paragraph lo lp iq lq b lr nb jr lt lu nc ju lw lx ne lz ma mb ng md me mf ni mh mi mj ij bi translated">有一些著名的问题，像<em class="mk">康威的生命游戏</em>，可以用顺序和并行编程来实现。在图论中，寻找两个节点间最短路径的<em class="mk">弗洛伊德算法</em>也可以实现为并行。</p><h2 id="ebfc" class="ml kx iq bd ky mm mn dn lc mo mp dp lg lx mq mr li mb ms mt lk mf mu mv lm mw bi translated">资源</h2><p id="8bc9" class="pw-post-body-paragraph lo lp iq lq b lr ls jr lt lu lv ju lw lx ly lz ma mb mc md me mf mg mh mi mj ij bi translated">有关更多信息，您可以查看以下资源:</p><ul class=""><li id="d25f" class="nk nl iq lq b lr nb lu nc lx ny mb nz mf oa mj np nq nr ns bi translated"><a class="ae kv" href="https://www.open-mpi.org/doc/v3.1/" rel="noopener ugc nofollow" target="_blank"> Open-MPI </a></li><li id="5a68" class="nk nl iq lq b lr nt lu nu lx nv mb nw mf nx mj np nq nr ns bi translated"><a class="ae kv" href="https://www.rookiehpc.com/mpi/docs/index.php" rel="noopener ugc nofollow" target="_blank"> Rookiehpc </a></li><li id="b748" class="nk nl iq lq b lr nt lu nu lx nv mb nw mf nx mj np nq nr ns bi translated"><a class="ae kv" href="https://nyu-cds.github.io/python-mpi/" rel="noopener ugc nofollow" target="_blank"> Python MPI </a></li></ul></div></div>    
</body>
</html>