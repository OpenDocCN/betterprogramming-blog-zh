<html>
<head>
<title>Using Kong Ingress Controller With Spring Boot Services</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">通过Spring Boot服务使用Kong入口控制器</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/using-kong-ingress-controller-with-spring-boot-services-b779b40ac7ff?source=collection_archive---------8-----------------------#2022-03-25">https://betterprogramming.pub/using-kong-ingress-controller-with-spring-boot-services-b779b40ac7ff?source=collection_archive---------8-----------------------#2022-03-25</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="9d5f" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">Kong Ingress Controller允许用户在现有的Kubernetes实现中包含Kong Gateway的功能，而无需太多的努力。</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/e1f17ccf51a765a715548bd85f4da9c5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*xfyx12ZCBW2RNj5e4sl_Uw.jpeg"/></div></div></figure><p id="bf21" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">自2003年以来，我一直使用IntelliJ作为我开发应用程序和服务的主要工具。十九年前，我对使用IDE所需的少量内存和1.x版本中包含的重构能力印象深刻。</p><p id="c3db" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">用Java开发不需要我使用IntelliJ IDEA产品。我当前项目中的其他开发人员使用Eclipse或VS代码，但是这些工具不是必需的。当您可以用一个简单的文本编辑器和终端会话编写组件、服务和应用程序时，您最终会得到相同的编译后的Java代码。</p><p id="fdcb" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">那么，为什么我每年都要把钱花在IntelliJ上呢？因为IntelliJ IDEA旨在让开发人员的工作变得更容易——这相当于我的工作效率更高。例如，右键单击一个类，我可以在几秒钟内选择重新定位这个类。当IntelliJ找到机会删除重复代码时，它会创建新的共享代码，并正确更新依赖于集中式方法的位置。IntelliJ也是代码审查期间验证的一个极好的来源。</p><p id="1900" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">虽然这个例子看起来有点简单，但我想知道为什么更多的软件工程师在构建他们的服务时不采用类似的方法。</p><h1 id="c410" class="lo lp iq bd lq lr ls lt lu lv lw lx ly jw lz jx ma jz mb ka mc kc md kd me mf bi translated">Spring Boot服务和Kubernetes</h1><p id="3805" class="pw-post-body-paragraph kr ks iq kt b ku mg jr kw kx mh ju kz la mi lc ld le mj lg lh li mk lk ll lm ij bi translated">让我们假设你的特性团队已经标准化了对API服务的<a class="ae ln" href="https://en.wikipedia.org/wiki/Spring_Framework#Spring_Boot" rel="noopener ugc nofollow" target="_blank"> Spring Boot </a>的使用。由于您团队的辛勤工作和详细设计，您的API被公众消费者认为是成功的。您的组织决定使用<a class="ae ln" href="https://konghq.com/learning-center/kubernetes/what-is-kubernetes/?utm_source=guest&amp;utm_medium=devspotlight&amp;utm_campaign=community" rel="noopener ugc nofollow" target="_blank"> Kubernetes </a>提供这些服务。</p><p id="f631" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">对于您的团队开发的每个Spring Boot服务，这是高级生命周期的样子:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi ml"><img src="../Images/c2287d760dc980b506c3ae481c062ca8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*p0i6zqUpXFXURMYsbsU5EQ.png"/></div></div></figure><p id="2fbb" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">初始化Spring Boot服务，并添加自定义代码。该服务被封装成一个Docker映像，最终部署到Kubernetes中。</p><p id="2a63" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">通过使用Kubernetes，我们获得了以下优势:</p><ul class=""><li id="d03f" class="mm mn iq kt b ku kv kx ky la mo le mp li mq lm mr ms mt mu bi translated">一组Spring Boot码头集装箱被放入一个“容器”中作为一个单独的应用程序。这使得每个Spring Boot服务都能够专注于最终API的给定方面。</li><li id="6539" class="mm mn iq kt b ku mv kx mw la mx le my li mz lm mr ms mt mu bi translated">可以对一个或多个pod进行分组，以形成最终的API服务，该服务可以针对可发现性、可观察性、水平伸缩和负载平衡进行配置。</li><li id="fd89" class="mm mn iq kt b ku mv kx mw la mx le my li mz lm mr ms mt mu bi translated">利用滚动更新和金丝雀部署来实现稳定的消费者体验。</li></ul><p id="3f87" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">如果您有兴趣将Kubernetes与Spring Boot结合使用，请查看以下URL:</p><p id="af88" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">Spring Boot·库伯内特</p><p id="b5c4" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">基于这些流行API的成功，让我们想象一下，行政领导想要将服务货币化，以从最活跃的消费者那里获得收入。免费层仍然可用，但是将引入对API使用的限制。</p><p id="6d48" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">虽然团队可以在Spring Boot级别实现一些定制逻辑，但这没有意义。我们需要的是一种集中的方式来处理这种新的需求。</p><h1 id="95e1" class="lo lp iq bd lq lr ls lt lu lv lw lx ly jw lz jx ma jz mb ka mc kc md kd me mf bi translated">孔入口控制员来救援了</h1><p id="e209" class="pw-post-body-paragraph kr ks iq kt b ku mg jr kw kx mh ju kz la mi lc ld le mj lg lh li mk lk ll lm ij bi translated">去年，作为我的一个客户的长期解决方案的一部分，我开始熟悉<a class="ae ln" href="https://konghq.com/?utm_source=guest&amp;utm_medium=devspotlight&amp;utm_campaign=community" rel="noopener ugc nofollow" target="_blank">孔</a>产品套件。我上面描述的场景反映了我在过去五年中遇到的情况:集中公共组件是成功实现微服务的关键。</p><p id="ae1a" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">如果你想更多地了解孔，可以看看我去年五月发表的文章:</p><p id="8ed7" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated"><a class="ae ln" href="https://medium.com/nerd-for-tech/how-i-stopped-coding-repetitive-service-components-with-kong-1308be4000e3" rel="noopener">我是如何和孔一起停止编写重复的服务组件的</a></p><p id="908b" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">对于上面提到的用例，我们可以在API网关级别处理以下组件:</p><ul class=""><li id="43df" class="mm mn iq kt b ku kv kx ky la mo le mp li mq lm mr ms mt mu bi translated">应用程序注册(密钥授权)</li><li id="bb8a" class="mm mn iq kt b ku mv kx mw la mx le my li mz lm mr ms mt mu bi translated">限速</li><li id="7c38" class="mm mn iq kt b ku mv kx mw la mx le my li mz lm mr ms mt mu bi translated">集中记录</li></ul><p id="53bb" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">由于Kong Gateway是开源的，并且是2021年Gartner全生命周期API管理幻方图中的“领导者”,因此Kong Gateway是处理这些常见组件的安全方式。了解到Kong还提供了一个用于Kubernetes的入口控制器，进一步验证了产品决策。</p><p id="62f3" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">在这个GitHub页面上，您可以找到开始使用Kong Ingress Controller (KIC)所需的一切:</p><p id="8a2d" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">【Kubernetes的孔入口控制器</p><p id="f75a" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">下图显示了这两种服务所需的设计:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi ml"><img src="../Images/0cf4a9275f4aa78939425f71165da3d5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Y1HrArgIB750R_0carrG-g.png"/></div></div></figure><p id="c339" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">针对API服务#1或#2的请求到达Kubernetes。Kong入口控制器拦截请求并验证所提供的API密钥。基于该信息，控制器确定做出请求的消费者是否已经超过其请求限制。</p><p id="e1f0" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">如果没有超过速率限制，则请求被转发到适当的服务。但是，如果超过了速率限制，那么将返回429(太多请求)HTTP响应。在所有情况下，可以轻松地配置日志模块来跟踪所有传入的请求，包括API消费者提供的所有元数据。</p><h1 id="03a5" class="lo lp iq bd lq lr ls lt lu lv lw lx ly jw lz jx ma jz mb ka mc kc md kd me mf bi translated">这个设计的价值</h1><p id="0bfb" class="pw-post-body-paragraph kr ks iq kt b ku mg jr kw kx mh ju kz la mi lc ld le mj lg lh li mk lk ll lm ij bi translated">当我们后退一步，看看由此产生的架构和设计时，我们很快就会看到好处:</p><ul class=""><li id="e753" class="mm mn iq kt b ku kv kx ky la mo le mp li mq lm mr ms mt mu bi translated">Spring Boot服务是真正的微服务，每个服务都专注于API的一个方面。</li><li id="ebc4" class="mm mn iq kt b ku mv kx mw la mx le my li mz lm mr ms mt mu bi translated">Docker允许Spring Boot服务是独立的，并且可以在开发生命周期的任何时候分发。</li><li id="f4c7" class="mm mn iq kt b ku mv kx mw la mx le my li mz lm mr ms mt mu bi translated">Kubernetes提供了将这些目的驱动的Docker图像分组到Pods中的能力，这些Pods充当单个应用程序。在我们的示例中，这些pod然后被分组为API服务。</li><li id="60da" class="mm mn iq kt b ku mv kx mw la mx le my li mz lm mr ms mt mu bi translated">共享组件—如应用程序注册、速率限制和日志记录—存在于Kong Gateway的一个集中位置。</li><li id="8049" class="mm mn iq kt b ku mv kx mw la mx le my li mz lm mr ms mt mu bi translated">Kong Ingress控制器成为Kong Gateway和Kubernetes之间的中间件层，以利用所有共享组件。</li></ul><p id="2949" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">作为这种模型的结果，从事Spring Boot服务的特性团队开发人员只需要关注他们的产品所有者所提供的工作来改进或扩展服务。这些开发人员不需要担心API键、速率限制或其他地方管理的任何其他共享组件。</p><p id="8836" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">支持Kubernetes实现的DevOps工程师也不必设计任何定制的设计方面来处理那些共享组件。这是因为Kong Gateway是为满足这些需求而构建的，并且通过Kong Ingress控制器工作良好。</p><h1 id="6958" class="lo lp iq bd lq lr ls lt lu lv lw lx ly jw lz jx ma jz mb ka mc kc md kd me mf bi translated">结论</h1><p id="49a7" class="pw-post-body-paragraph kr ks iq kt b ku mg jr kw kx mh ju kz la mi lc ld le mj lg lh li mk lk ll lm ij bi translated">自2021年以来，我一直试图按照以下使命宣言生活，我觉得这可以适用于任何IT专业人士:</p><blockquote class="na nb nc"><p id="3553" class="kr ks nd kt b ku kv jr kw kx ky ju kz ne lb lc ld nf lf lg lh ng lj lk ll lm ij bi translated"><em class="iq">“将您的时间集中在提供扩展您知识产权价值的特性/功能上。将框架、产品和服务用于其他一切。”</em></p><p id="bc10" class="kr ks nd kt b ku kv jr kw kx ky ju kz ne lb lc ld nf lf lg lh ng lj lk ll lm ij bi translated"><em class="iq">——j·维斯特</em></p></blockquote><p id="93b1" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">在这篇文章的开始，我谈到了与文本编辑器和终端会话相比，我更喜欢IntelliJ IDEA。事实上，核心原因与我的个人使命直接相关。创意产品让我专注于正确的事情；同时，它处理与编写原始源代码相关的重复性任务。</p><p id="4971" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">类似地，Spring、Docker、Kubernetes和Kong都提供了解决方案和框架来实现相同的使命。上面提到的每一个方面都可以追溯到给定项目的单一真相来源。因此，整个应用环境中没有重复的服务或功能。</p><blockquote class="na nb nc"><p id="9591" class="kr ks nd kt b ku kv jr kw kx ky ju kz ne lb lc ld nf lf lg lh ng lj lk ll lm ij bi translated"><em class="iq">如果你发现自己第二次执行同样的过程，那肯定是时候考虑重构你的设计了。</em></p></blockquote><p id="8b78" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">如果您的服务层属于我在这里讨论的类似模式，并且您没有使用Kong Gateway或Kong Ingress Controller，那么当您准备完善您的服务设计时，它们当然应该在您的产品清单上。</p><p id="424f" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">祝你今天过得愉快！</p></div></div>    
</body>
</html>