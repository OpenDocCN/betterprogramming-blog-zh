<html>
<head>
<title>How To Perform User Authentication With React Using Firebase</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何使用Firebase通过React执行用户身份验证</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/how-to-perform-user-authentication-with-react-using-firebase-5cfbf17e0993?source=collection_archive---------7-----------------------#2021-07-21">https://betterprogramming.pub/how-to-perform-user-authentication-with-react-using-firebase-5cfbf17e0993?source=collection_archive---------7-----------------------#2021-07-21</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="e8fd" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">使用Firebase SDKs轻松验证React应用程序中的用户</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/b421b195d7f1a777edefe1b3ee543f42.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*kpEA7nDc0-MLY8koON_wTQ.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">我们今天将创造什么！图片由作者提供。</p></figure><p id="f38a" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">在您的应用程序中对用户进行身份验证曾经非常具有挑战性。这是一个很大的安全隐患，只有专家才敢实施和维护解决方案。但是现在，我们不再需要了。有无数的外部身份提供者使用OAuth 2.0和OpenID Connect等安全认证协议，我们可以利用这些协议，而无需自己编写代码，更重要的是，无需自己存储用户凭据。</p><p id="778e" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">Firebase是谷歌开发的一个用于创建移动和网络应用的平台，它拥有大量的功能，在这方面令人印象深刻。今天，我们将通过使用他们的用于JavaScript的<a class="ae lu" href="https://firebase.google.com/docs/web/setup?authuser=0" rel="noopener ugc nofollow" target="_blank">认证SDK </a>来关注Firebase的用户认证。</p><p id="95c4" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">如果你知道该做什么，这是相当简单的。让我们开始吧！我会一路解释某些概念。</p><p id="d472" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated"><em class="lv">注:演示应用的所有代码都可以在我的</em> <a class="ae lu" href="https://gitlab.com/gvanderput/gerard-firebase" rel="noopener ugc nofollow" target="_blank"> <em class="lv"> GitLab资源库</em> </a> <em class="lv">中找到。</em></p></div><div class="ab cl lw lx hx ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="im in io ip iq"><h1 id="08ba" class="md me it bd mf mg mh mi mj mk ml mm mn jz mo ka mp kc mq kd mr kf ms kg mt mu bi translated">Firebase设置</h1><p id="656c" class="pw-post-body-paragraph ky kz it la b lb mv ju ld le mw jx lg lh mx lj lk ll my ln lo lp mz lr ls lt im bi translated">首先，我们需要为我们的项目设置Firebase。在<a class="ae lu" href="https://console.firebase.google.com/" rel="noopener ugc nofollow" target="_blank"> Firebase控制台</a>中，创建一个新项目。给它起一个有意义的名字(在我的例子中是“GerardFirebase”)。</p><p id="f680" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">接下来，在左侧的“身份验证”部分，启用登录提供者。如你所见，有很多:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi na"><img src="../Images/2ca71381bc34b4760df10b7bdad3ce0c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1204/format:webp/1*OdLrhZsjn1VpXZZxBEBzyg.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">许多登录提供者是可用的(Firebase控制台的屏幕截图)。</p></figure><p id="a1ee" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">在本文中，我们将重点关注如何让用户使用他们的Google帐户登录我们的网站。因此，我们将启用“Google”条目。</p><p id="9627" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">在这样做的时候，我们必须为我们的应用程序提供一个名称，用户在登录时可以看到这个名称，同时提供一个他们可以看到的电子邮件地址(虽然是间接的——在显示之前，他们必须单击身份验证页面上的一个链接)。</p><p id="702c" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">另外，请注意“授权域”部分:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nb"><img src="../Images/73186b10aab5bfde87d406c3c7490c7f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Or0ViU0Dj7-mAPCzgh6gHg.png"/></div></div></figure><p id="2dcf" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">这些是在运行应用程序时可以使用的域。例如，当您使用CRA (Create React App)或Next.js开发新的应用程序时，您最有可能使用本地主机域。在这种情况下，默认值就足够了。一旦您开始使用您的应用程序并使用一个真正的域，您就必须将它添加到这个列表中。或者更好的是，您可以创建一个专用的、独立的生产数据库！</p><p id="efa7" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">一旦完成，你就可以走了。让我们写一些代码。</p><p id="8018" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated"><em class="lv">注意:可以启用多个登录提供者，但这超出了本文的范围，因为我们必须在前端实现更多的代码。通过只关注Google登录提供商，我们可以更容易地解释概念和解决方案。</em></p></div><div class="ab cl lw lx hx ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="im in io ip iq"><h1 id="3b89" class="md me it bd mf mg mh mi mj mk ml mm mn jz mo ka mp kc mq kd mr kf ms kg mt mu bi translated">在您的前端配置SDK的使用</h1><p id="9dbf" class="pw-post-body-paragraph ky kz it la b lb mv ju ld le mw jx lg lh mx lj lk ll my ln lo lp mz lr ls lt im bi translated">将Firebase SDKs添加到React项目中:</p><pre class="kj kk kl km gt nc nd ne nf aw ng bi"><span id="9db5" class="nh me it nd b gy ni nj l nk nl">$ yarn add <strong class="nd iu">firebase</strong></span></pre><p id="4e3c" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">之后，我们必须在代码中配置和初始化Firebase SDK。创建Firebase引导文件:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nm nn l"/></div></figure><p id="0f93" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">当然，我们必须为我们的配置对象提供值。您可以将它们直接写在这个文件中，但这被认为是一种不好的做法。如果您将文件提交并推送到远程存储库，这些值也会被发送到那里，这很可能不是我们想要的。</p><p id="79b2" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">我们可以将这些值存储在环境变量中。我使用的是Next.js，所以我将在根目录下创建一个名为<code class="fe no np nq nd b">.env.local</code>的文件，内容如下:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nm nn l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">注:在本文中，实际值被替换为***值。</p></figure><p id="aa7d" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">创建该文件后，我可以重新启动开发服务器，并使用引导文件中的值，如下所示:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nm nn l"/></div></figure><p id="9950" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">如果你正在使用CRA (Create React App)，你可以做一些类似的事情。具体细节在<a class="ae lu" href="https://create-react-app.dev/docs/adding-custom-environment-variables/" rel="noopener ugc nofollow" target="_blank">这一页</a>的文档中有描述。</p></div><div class="ab cl lw lx hx ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="im in io ip iq"><h1 id="fe66" class="md me it bd mf mg mh mi mj mk ml mm mn jz mo ka mp kc mq kd mr kf ms kg mt mu bi translated">SDK配置值</h1><p id="0ca1" class="pw-post-body-paragraph ky kz it la b lb mv ju ld le mw jx lg lh mx lj lk ll my ln lo lp mz lr ls lt im bi translated">您可以在Firebase控制台的“项目设置”下找到实际值在显示它们之前，你必须进入项目设置&gt;通用&gt;你的应用&gt;添加应用，然后添加一个<em class="lv"> Web应用</em>。这样，您指示Firebase您将在web应用程序中使用Firebase SDK，配置将显示如下:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi nr"><img src="../Images/c0867f148c3cbddd25f78cdbf058ffe8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1246/format:webp/1*QqF5oXqRNUwnb5h9g9ak5Q.png"/></div></figure></div><div class="ab cl lw lx hx ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="im in io ip iq"><h1 id="7318" class="md me it bd mf mg mh mi mj mk ml mm mn jz mo ka mp kc mq kd mr kf ms kg mt mu bi translated">包括引导文件</h1><p id="34f3" class="pw-post-body-paragraph ky kz it la b lb mv ju ld le mw jx lg lh mx lj lk ll my ln lo lp mz lr ls lt im bi translated">最后，我们必须通过将引导文件添加到索引文件来确保它包含在源代码中:</p><pre class="kj kk kl km gt nc nd ne nf aw ng bi"><span id="7dcf" class="nh me it nd b gy ni nj l nk nl">import "../path/to/bootstrap.js";</span></pre><p id="0e1c" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">对于Next.js应用程序，将这一行添加到您的<code class="fe no np nq nd b">pages/_app.js</code>文件中。如果您使用的是CRA，请将其添加到<code class="fe no np nq nd b">src/index.js</code>。</p><p id="e098" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">现在，一旦您运行应用程序，到Firebase项目的连接将被初始化，我们可以开始使用SDK功能。</p></div><div class="ab cl lw lx hx ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="im in io ip iq"><h1 id="a5d4" class="md me it bd mf mg mh mi mj mk ml mm mn jz mo ka mp kc mq kd mr kf ms kg mt mu bi translated">认证上下文</h1><p id="2022" class="pw-post-body-paragraph ky kz it la b lb mv ju ld le mw jx lg lh mx lj lk ll my ln lo lp mz lr ls lt im bi translated">在我们实际使用Firebase SDK之前，我们必须做一些准备工作。</p><p id="b49c" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">我们希望能够在整个应用程序中访问有关登录用户的信息，因此我们将创建一个能够保存这些信息的<a class="ae lu" href="https://reactjs.org/docs/context.html" rel="noopener ugc nofollow" target="_blank"> React上下文</a>。如果您不熟悉上下文，我建议在继续之前阅读我的其他文章:</p><div class="ns nt gp gr nu nv"><a rel="noopener  ugc nofollow" target="_blank" href="/exploring-caching-techniques-in-react-d30bbb78d54d"><div class="nw ab fo"><div class="nx ab ny cl cj nz"><h2 class="bd iu gy z fp oa fr fs ob fu fw is bi translated">探索React中的缓存技术</h2><div class="oc l"><h3 class="bd b gy z fp oa fr fs ob fu fw dk translated">如何使用记忆、上下文、使用记忆、使用状态和使用效果</h3></div><div class="od l"><p class="bd b dl z fp oa fr fs ob fu fw dk translated">better编程. pub</p></div></div><div class="oe l"><div class="of l og oh oi oe oj ks nv"/></div></div></a></div><p id="c44f" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">创建一个新文件，该文件创建一个新的上下文并将其导出:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nm nn l"/></div></figure><p id="ebb2" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">如您所见，该值可以是<code class="fe no np nq nd b">null</code>(用户未登录—默认)或<code class="fe no np nq nd b">User object</code>(我们有一个经过身份验证的用户)。</p><p id="6efe" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">接下来，我们创建一个<a class="ae lu" href="https://reactjs.org/docs/higher-order-components.html" rel="noopener ugc nofollow" target="_blank">高阶组件</a>，它利用了我们新上下文中的提供者:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nm nn l"/></div></figure><p id="ffef" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">我们将用这个HOC来包装我们的整个应用程序(根组件),稍后会有更多内容。那么这个文件中发生了什么呢？</p><p id="0498" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">在第6-7行，我们看到我们有一些本地状态。它跟踪身份验证过程是否已经初始化，并且可以存储一个用户对象。很快会有更多。</p><p id="5969" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">最后，我们决定我们的HOC要渲染什么(第11-21行)。如果初始化还没有完成，我们返回我们很忙(“loading…”)。如果我们没有用户(第15行)，我们显示一个登录按钮:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi ok"><img src="../Images/9acd34306c63b4d1bc455b9d86703d50.png" data-original-src="https://miro.medium.com/v2/resize:fit:1110/format:webp/1*mUgHLvcbbFEeSwQFW_YkWQ.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">当用户没有被认证时，我们的HOC返回一个登录按钮。</p></figure><p id="e898" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">如果我们有一个授权用户，我们返回传递给这个<code class="fe no np nq nd b">AuthContextProvider</code>组件的子组件。</p><p id="9e43" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">但最重要的部分还是不见了。我们必须使用Firebase SDK，这样当认证用户发生变化时，我们的HOC就会得到通知。导入相关的SDK代码:</p><pre class="kj kk kl km gt nc nd ne nf aw ng bi"><span id="054d" class="nh me it nd b gy ni nj l nk nl">import <strong class="nd iu">firebase</strong> from "firebase/app";<br/>import "firebase/auth";</span></pre><p id="a238" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">并添加下面的<code class="fe no np nq nd b">useEffect</code>钩子(在上面的代码片段中，第9行没有这个钩子):</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nm nn l"/></div></figure><p id="544d" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">因为我们提供了一个空数组作为<code class="fe no np nq nd b">useEffect</code>调用的第二个参数，所以这段代码将被执行一次(当这个HOC被挂载到DOM时)。</p><p id="c3b9" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">我们使用Firebase认证SDK中的<code class="fe no np nq nd b">onAuthStateChange</code>函数。每当用户身份验证发生变化时(例如，用户登录或退出)，所提供的回调将使用一个参数(“im”——一个<code class="fe no np nq nd b">Firebase.User</code>实例——或<code class="fe no np nq nd b">null</code>)来执行，我们会相应地更新本地状态。</p></div><div class="ab cl lw lx hx ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="im in io ip iq"><h1 id="36a2" class="md me it bd mf mg mh mi mj mk ml mm mn jz mo ka mp kc mq kd mr kf ms kg mt mu bi translated">使用AuthContextProvider专用</h1><p id="6016" class="pw-post-body-paragraph ky kz it la b lb mv ju ld le mw jx lg lh mx lj lk ll my ln lo lp mz lr ls lt im bi translated">确保在您的索引文件中用我们的HOC来包装您的根组件:</p><pre class="kj kk kl km gt nc nd ne nf aw ng bi"><span id="4955" class="nh me it nd b gy ni nj l nk nl">&lt;AuthContextProvider&gt;<br/>  &lt;MyApp /&gt;<br/>&lt;/AuthContextProvider&gt;</span></pre></div><div class="ab cl lw lx hx ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="im in io ip iq"><h1 id="3ae5" class="md me it bd mf mg mh mi mj mk ml mm mn jz mo ka mp kc mq kd mr kf ms kg mt mu bi translated">登录按钮</h1><p id="ac3c" class="pw-post-body-paragraph ky kz it la b lb mv ju ld le mw jx lg lh mx lj lk ll my ln lo lp mz lr ls lt im bi translated">不久前我们看到，如果用户没有经过身份验证，我们就会呈现一个登录按钮。组件如下所示(特别注意第9行的<code class="fe no np nq nd b">onClick</code>处理程序):</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nm nn l"/></div></figure><p id="4a52" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">单击该按钮时，会发生两件事。首先，我们创建一个提供者。还记得Firebase项目配置中的登录提供者列表吗？在这里，我们可以选择一个已启用的提供者。我们只启用了谷歌的，所以这是我们创建的。</p><p id="2b64" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated"><em class="lv">注意:在这里你可以看到为多个提供商(如脸书、Twitter等)创建多个登录按钮是多么简单。</em></p><p id="7fed" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">其次，我们通过调用<code class="fe no np nq nd b">signInWithRedirect</code>方法，指示Firebase SDK启动一个带有重定向的<em class="lv">认证流。因此，当我们的用户点击按钮时，他们将被重定向到谷歌，以表明自己的身份:</em></p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi ol"><img src="../Images/202c2d426fffff33b45f39860452557a.png" data-original-src="https://miro.medium.com/v2/resize:fit:916/format:webp/1*7USFH2EGJAFimsbdFAGthA.png"/></div></figure><p id="8d83" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">这样做之后，它们将被重定向回我们的应用程序。</p><p id="b084" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">如果你不希望你的用户通过重定向暂时离开你的应用程序，你可以使用<code class="fe no np nq nd b">signInWithPopup</code>来代替。请注意，如果您正在创建一个移动应用程序，这将不起作用。</p><p id="23ea" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">当它们被重定向回我们的应用程序时，我们对HOC中的<code class="fe no np nq nd b">useEffect</code>钩子内的<code class="fe no np nq nd b">firebase.auth().onAuthStateChanged</code>的调用的处理程序将被执行，我们将拥有一个经过认证的用户！</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi om"><img src="../Images/b6a24a8f6aac34dc074449d30aa1d786.png" data-original-src="https://miro.medium.com/v2/resize:fit:1108/format:webp/1*TJpP_0yxLZd2O5z0qs0tmQ.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">我们的应用程序中有一个经过身份验证的用户！</p></figure></div><div class="ab cl lw lx hx ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="im in io ip iq"><h1 id="9f8b" class="md me it bd mf mg mh mi mj mk ml mm mn jz mo ka mp kc mq kd mr kf ms kg mt mu bi translated">显示用户信息</h1><p id="5559" class="pw-post-body-paragraph ky kz it la b lb mv ju ld le mw jx lg lh mx lj lk ll my ln lo lp mz lr ls lt im bi translated">由于我们已经在一个上下文中存储了关于用户的信息(请参阅:本文前面的),并且我们已经通过我们的HOC(提供者)提供了该上下文的值，所以我们可以读取该信息并在屏幕上呈现它，如果需要的话，可以在任何组件中呈现。我的演示存储库中的<code class="fe no np nq nd b">UserInfo</code>组件如下所示:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nm nn l"/></div></figure><p id="1b04" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">注意我们如何通过使用<code class="fe no np nq nd b">useContext</code>钩子在第9行获得对用户对象的引用。</p></div><div class="ab cl lw lx hx ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="im in io ip iq"><h1 id="b36a" class="md me it bd mf mg mh mi mj mk ml mm mn jz mo ka mp kc mq kd mr kf ms kg mt mu bi translated">签名登记离开</h1><p id="0de4" class="pw-post-body-paragraph ky kz it la b lb mv ju ld le mw jx lg lh mx lj lk ll my ln lo lp mz lr ls lt im bi translated">最后，必须有一种方法让用户退出我们的应用程序。幸运的是，SDK也使这一点非常容易实现:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nm nn l"/></div></figure></div><div class="ab cl lw lx hx ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="im in io ip iq"><h1 id="d9db" class="md me it bd mf mg mh mi mj mk ml mm mn jz mo ka mp kc mq kd mr kf ms kg mt mu bi translated">结论</h1><p id="ea05" class="pw-post-body-paragraph ky kz it la b lb mv ju ld le mw jx lg lh mx lj lk ll my ln lo lp mz lr ls lt im bi translated">正如简介中提到的，用户认证过去很难，而且容易出现安全漏洞。通过利用Firebase等平台的功能，我们不会冒任何安全风险。</p><p id="23ae" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">您可以在本文中看到，我们在应用程序中只以临时状态存储用户信息(当用户关闭应用程序时，该状态已经消失)。它存储在内存中。不要自己持久存储用户信息(例如，在数据库或本地存储中)！最有可能的是，你不必这样做。相反，请依赖登录/身份提供商，如Google或任何其他可信任的第三方，或者它们的组合:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi on"><img src="../Images/fe7661c177c03cf71d27d9ee541a05b7.png" data-original-src="https://miro.medium.com/v2/resize:fit:766/format:webp/1*C5w_Z2H833wy88emtezUcA.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">Gitlab.com在其登录页面上提供多个提供商。</p></figure><p id="3c88" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">使用Firebase身份验证SDK对您的用户进行身份验证为使用Firebase的更多功能打开了大门，例如他们的Firestore数据库。</p><p id="9529" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">我们很快就会看到。</p><p id="64e7" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">感谢您的宝贵时间！</p></div></div>    
</body>
</html>