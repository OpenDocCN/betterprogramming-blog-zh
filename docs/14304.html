<html>
<head>
<title>Resilient and Performant Data Fetching in Next.js</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Next.js中的弹性和高性能数据提取</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/resilient-and-performant-data-fetching-in-nextjs-363c40a40502?source=collection_archive---------1-----------------------#2022-11-27">https://betterprogramming.pub/resilient-and-performant-data-fetching-in-nextjs-363c40a40502?source=collection_archive---------1-----------------------#2022-11-27</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="8f90" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated"><em class="kf">关于如何使用React Query和Next.js优化API调用和向视图呈现数据的教程</em></h2></div><figure class="kh ki kj kk gt kl gh gi paragraph-image"><div role="button" tabindex="0" class="km kn di ko bf kp"><div class="gh gi kg"><img src="../Images/19a1c712b464fea607f9fc8c5a025e5f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*skj8u9dKxVXZ4zt-8qIs4g.jpeg"/></div></div></figure><p id="fc60" class="pw-post-body-paragraph ks kt iq ku b kv kw jr kx ky kz ju la lb lc ld le lf lg lh li lj lk ll lm ln ij bi translated">API通常是我们驱动网站浏览量的主要数据源。它们是我们的应用程序呈现信息的核心部分，比如天气、用户数据、交易列表等等。考虑到获取和呈现数据的重要性，我们必须确保以高性能和弹性的方式完成这项工作。服务器错误、网络问题、请求超时和其他因素可能会阻止您的数据填充视图。幸运的是，我们可以使用一些工具来优化我们的初始请求，并在数据过时时不断更新数据。</p><h1 id="7455" class="lo lp iq bd lq lr ls lt lu lv lw lx ly jw lz jx ma jz mb ka mc kc md kd me mf bi translated">js服务器端抓取</h1><p id="d711" class="pw-post-body-paragraph ks kt iq ku b kv mg jr kx ky mh ju la lb mi ld le lf mj lh li lj mk ll lm ln ij bi translated">当您获取数据时，有什么比显示一个设计良好的加载微调器更好的呢？根本不需要！</p><p id="5505" class="pw-post-body-paragraph ks kt iq ku b kv kw jr kx ky kz ju la lb lc ld le lf lg lh li lj lk ll lm ln ij bi translated"><a class="ae ml" href="https://nextjs.org/" rel="noopener ugc nofollow" target="_blank"> Next.js </a>提供了一个名为<a class="ae ml" href="https://nextjs.org/docs/basic-features/data-fetching/get-server-side-props" rel="noopener ugc nofollow" target="_blank"> getServerSideProps </a>的页面级函数，它允许我们执行NodeJS获取请求，并将其作为Props传递给页面。这给了我们在客户端准备好数据的好处。</p><p id="f1e2" class="pw-post-body-paragraph ks kt iq ku b kv kw jr kx ky kz ju la lb lc ld le lf lg lh li lj lk ll lm ln ij bi translated">从<a class="ae ml" href="https://fakerapi.it/en" rel="noopener ugc nofollow" target="_blank"> Faker API </a>获取并呈现公司列表可能如下所示:</p><pre class="kh ki kj kk gt mm mn mo bn mp mq bi"><span id="c314" class="mr lp iq mn b be ms mt l mu mv">const fetchCompanies = async () =&gt; {<br/>  const res = await fetch("https://fakerapi.it/api/v1/companies");<br/><br/>  if (!res.ok) {<br/>    throw new Error("Something went wrong");<br/>  }<br/><br/>  const { data = [] } = await res.json();<br/><br/>  return data;<br/>};<br/><br/>export default function Home({ data }) {<br/>  return (<br/>    &lt;div&gt;<br/>      &lt;h1&gt;Companies&lt;/h1&gt;<br/>      &lt;ol&gt;<br/>        {data &amp;&amp; data.map(({ id, name, email, vat, phone, website }) =&gt; (<br/>          &lt;li key={id}&gt;<br/>            &lt;h2&gt;{name}&lt;/h2&gt;<br/>            &lt;p&gt;{email}&lt;/p&gt;<br/>            &lt;p&gt;{vat}&lt;/p&gt;<br/>            &lt;p&gt;{phone}&lt;/p&gt;<br/>            &lt;p&gt;{website}&lt;/p&gt;<br/>          &lt;/li&gt;<br/>        ))}<br/>      &lt;/ol&gt;<br/>    &lt;/div&gt;<br/>  );<br/>};<br/><br/>export const getServerSideProps = async () =&gt; {<br/>  const data = await fetchCompanies()<br/>  return {<br/>    props: {<br/>      data<br/>    },<br/>  };<br/>};</span></pre><h1 id="712e" class="lo lp iq bd lq lr ls lt lu lv lw lx ly jw lz jx ma jz mb ka mc kc md kd me mf bi translated">页面视图</h1><figure class="kh ki kj kk gt kl gh gi paragraph-image"><div role="button" tabindex="0" class="km kn di ko bf kp"><div class="gh gi mw"><img src="../Images/6843344fd76f0cf567d976a24ba150be.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*Ig9AtS_NFk0SN1Zb.png"/></div></div></figure><p id="6f15" class="pw-post-body-paragraph ks kt iq ku b kv kw jr kx ky kz ju la lb lc ld le lf lg lh li lj lk ll lm ln ij bi translated">看起来很棒，对吧？列表几乎立即呈现，我们甚至不需要显示加载状态(目前)。</p><p id="0881" class="pw-post-body-paragraph ks kt iq ku b kv kw jr kx ky kz ju la lb lc ld le lf lg lh li lj lk ll lm ln ij bi translated">如果我们生活在一个完美的世界中，这可能足以进行生产。然而，在现实场景中，我们必须考虑初始请求失败、需要重试、缓存以提高性能以及避免达到API限制。</p><h1 id="4438" class="lo lp iq bd lq lr ls lt lu lv lw lx ly jw lz jx ma jz mb ka mc kc md kd me mf bi translated">对救援的质疑作出反应</h1><p id="86d2" class="pw-post-body-paragraph ks kt iq ku b kv mg jr kx ky mh ju la lb mi ld le lf mj lh li lj mk ll lm ln ij bi translated"><a class="ae ml" href="https://tanstack.com/query/v4/" rel="noopener ugc nofollow" target="_blank"> React Query </a>是一个优秀的数据获取库，允许我们使用初始服务器端获取、重试、缓存、请求超时等等！</p><p id="2aec" class="pw-post-body-paragraph ks kt iq ku b kv kw jr kx ky kz ju la lb lc ld le lf lg lh li lj lk ll lm ln ij bi translated">我们可以对上面的代码做的第一个改进是引入查询水合和重试机制。水合是使用客户端JavaScript向服务器呈现的HTML添加应用程序状态和交互性的过程。</p><p id="94a9" class="pw-post-body-paragraph ks kt iq ku b kv kw jr kx ky kz ju la lb lc ld le lf lg lh li lj lk ll lm ln ij bi translated">首先，我们需要在<code class="fe mx my mz mn b">_app.js</code>中用React Query的提供者包装我们的页面。</p><pre class="kh ki kj kk gt mm mn mo bn mp mq bi"><span id="345f" class="mr lp iq mn b be ms mt l mu mv">import { QueryClient, QueryClientProvider, Hydrate } from "@tanstack/react-query";<br/>// Create a client<br/>const queryClient = new QueryClient();<br/>export default function MyApp({ Component, pageProps }) {<br/>  return (<br/>    &lt;QueryClientProvider client={queryClient}&gt;<br/>      &lt;Hydrate state={pageProps.dehydratedState}&gt;<br/>        &lt;Component {...pageProps} /&gt;<br/>      &lt;/Hydrate&gt;<br/>    &lt;/QueryClientProvider&gt;<br/>  );<br/>}</span></pre><p id="9b3d" class="pw-post-body-paragraph ks kt iq ku b kv kw jr kx ky kz ju la lb lc ld le lf lg lh li lj lk ll lm ln ij bi translated">这里发生了两件事。首先，我们用一个<code class="fe mx my mz mn b">QueryClientProvider</code>包装我们的应用程序，它让React Query的钩子通过上下文访问一个<code class="fe mx my mz mn b">QueryClient</code>的实例。其次，我们正在向<code class="fe mx my mz mn b">Hydrate</code>传递脱水状态。脱水状态将来自我们的服务器端获取，是缓存的冻结表示，稍后可以在客户端进行水合。</p><h1 id="68eb" class="lo lp iq bd lq lr ls lt lu lv lw lx ly jw lz jx ma jz mb ka mc kc md kd me mf bi translated">修改我们最初的方法</h1><pre class="kh ki kj kk gt mm mn mo bn mp mq bi"><span id="0d1b" class="mr lp iq mn b be ms mt l mu mv">import { QueryClient, dehydrate } from "@tanstack/react-query";<br/><br/>const fetchCompanies = async () =&gt; {<br/>  const res = await fetch("https://fakerapi.it/api/v1/companies");<br/><br/>  if (!res.ok) {<br/>    throw new Error("Something went wrong");<br/>  }<br/><br/>  const { data = [] } = await res.json();<br/><br/>  return data;<br/>};<br/><br/>export default function Home() {<br/>  const { data, error, isLoading } = useQuery({ queryKey: 'companies', queryFn: fetchCompanies, staleTime: 60_000 }); // stale after 1 min<br/>  if (isLoading){<br/>   return &lt;h1&gt;Loading...&lt;/h1&gt;<br/>  }<br/>  if (error){<br/>   return &lt;h1&gt;{error.message}&lt;/h1&gt;<br/>  }<br/>  return (<br/>    &lt;div&gt;<br/>      &lt;h1&gt;Companies&lt;/h1&gt;<br/>      &lt;ol&gt;<br/>        {data &amp;&amp; data.map(({ id, name, email, vat, phone, website }) =&gt; (<br/>          &lt;li key={id}&gt;<br/>            &lt;h2&gt;{name}&lt;/h2&gt;<br/>            &lt;p&gt;{email}&lt;/p&gt;<br/>            &lt;p&gt;{vat}&lt;/p&gt;<br/>            &lt;p&gt;{phone}&lt;/p&gt;<br/>            &lt;p&gt;{website}&lt;/p&gt;<br/>          &lt;/li&gt;<br/>        ))}<br/>      &lt;/ol&gt;<br/>    &lt;/div&gt;<br/>  );<br/>};<br/><br/>export const getServerSideProps = async () =&gt; {<br/>  const queryClient = new QueryClient()<br/>  await queryClient.prefetchQuery(["companies"], fetchCompanies);<br/><br/>  return {<br/>    props: {<br/>      dehydratedState: dehydrate(queryClient),<br/>    },<br/>  };<br/>};</span></pre><h1 id="51e8" class="lo lp iq bd lq lr ls lt lu lv lw lx ly jw lz jx ma jz mb ka mc kc md kd me mf bi translated">有什么变化？</h1><figure class="kh ki kj kk gt kl gh gi paragraph-image"><div role="button" tabindex="0" class="km kn di ko bf kp"><div class="gh gi na"><img src="../Images/7cba826e7cb95f7ab58bff0e75336102.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*bNKZd62XETnthBp6.png"/></div></div></figure><p id="cd10" class="pw-post-body-paragraph ks kt iq ku b kv kw jr kx ky kz ju la lb lc ld le lf lg lh li lj lk ll lm ln ij bi translated">如果我们查看我们的初步页面负载，我们仍然得到了公司的渲染列表，没有任何客户端获取请求的迹象。这意味着我们最初仍在获取服务器端。</p><p id="7345" class="pw-post-body-paragraph ks kt iq ku b kv kw jr kx ky kz ju la lb lc ld le lf lg lh li lj lk ll lm ln ij bi translated">我们的好处是，当数据过时时，它会刷新客户端。由于缓存过期、us指示新数据超时或执行另一个请求(例如，使用<code class="fe mx my mz mn b">POST</code>请求创建新的数据条目),数据可能进入状态，从而触发当前数据的无效。</p><figure class="kh ki kj kk gt kl gh gi paragraph-image"><div role="button" tabindex="0" class="km kn di ko bf kp"><div class="gh gi na"><img src="../Images/d2affed857b543e4292b6986af4a2bf1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*rGsLI3mK1L4WZpYJ.png"/></div></div></figure><p id="b3d2" class="pw-post-body-paragraph ks kt iq ku b kv kw jr kx ky kz ju la lb lc ld le lf lg lh li lj lk ll lm ln ij bi translated">重新检查network选项卡，我们可以看到，一旦数据被认为过时，就会触发客户端获取。因此，如果初始请求失败，React Query将多次尝试恢复数据。</p><h1 id="5a38" class="lo lp iq bd lq lr ls lt lu lv lw lx ly jw lz jx ma jz mb ka mc kc md kd me mf bi translated">结论(差不多)</h1><p id="1c8e" class="pw-post-body-paragraph ks kt iq ku b kv mg jr kx ky mh ju la lb mi ld le lf mj lh li lj mk ll lm ln ij bi translated">就是这样！我们已经使我们的应用程序对请求失败具有高性能和反应能力。此外，React Query可以配置为进一步优化应用程序状态和请求，这取决于您正在开发的应用程序的类型。</p><p id="a4fc" class="pw-post-body-paragraph ks kt iq ku b kv kw jr kx ky kz ju la lb lc ld le lf lg lh li lj lk ll lm ln ij bi translated">说到这里，我们还可以做一件事…</p><h1 id="386a" class="lo lp iq bd lq lr ls lt lu lv lw lx ly jw lz jx ma jz mb ka mc kc md kd me mf bi translated">重构</h1><p id="0416" class="pw-post-body-paragraph ks kt iq ku b kv mg jr kx ky mh ju la lb mi ld le lf mj lh li lj mk ll lm ln ij bi translated">让我们清理这段代码，把它变成更好的东西。</p><p id="f767" class="pw-post-body-paragraph ks kt iq ku b kv kw jr kx ky kz ju la lb lc ld le lf lg lh li lj lk ll lm ln ij bi translated">我们可以从为键定义一个enum和为fetchers定义一个函数映射开始。</p><pre class="kh ki kj kk gt mm mn mo bn mp mq bi"><span id="6e9b" class="mr lp iq mn b be ms mt l mu mv">const QUERY_KEYS = {<br/>  COMPANIES: "companies",<br/>}<br/>const queryFunctions = {<br/>  [QUERY_KEYS.COMPANIES]: fetchCompanies,<br/>};</span></pre><p id="6071" class="pw-post-body-paragraph ks kt iq ku b kv kw jr kx ky kz ju la lb lc ld le lf lg lh li lj lk ll lm ln ij bi translated">之后，我们可以用我们的<code class="fe mx my mz mn b">useQuery</code>钩子创建一个HOC ( <a class="ae ml" href="https://reactjs.org/docs/higher-order-components.html" rel="noopener ugc nofollow" target="_blank">高阶组件</a>)。</p><pre class="kh ki kj kk gt mm mn mo bn mp mq bi"><span id="70d5" class="mr lp iq mn b be ms mt l mu mv">export const withQuery = (Component, key) =&gt; {<br/>  return (props) =&gt; {<br/>    const queryResponse = useQuery({ queryKey: [key], queryFn: queryFunctions[key], staleTime: 50_000 });<br/>    return &lt;Component {...{...props, ...queryResponse}} /&gt;;<br/>  };<br/>};jsx</span></pre><p id="e22a" class="pw-post-body-paragraph ks kt iq ku b kv kw jr kx ky kz ju la lb lc ld le lf lg lh li lj lk ll lm ln ij bi translated">这个HOC将包装我们的页面组件，并为我们传播查询响应属性(以及页面属性)，类似于我们在第一次迭代中使用直接从<code class="fe mx my mz mn b">getServerSideProps </code>接收的数据。这给了我们一个简单的接口和抽象实现细节的好处。</p><p id="051a" class="pw-post-body-paragraph ks kt iq ku b kv kw jr kx ky kz ju la lb lc ld le lf lg lh li lj lk ll lm ln ij bi translated">我们最终的页面组件将如下所示:</p><pre class="kh ki kj kk gt mm mn mo bn mp mq bi"><span id="43c3" class="mr lp iq mn b be ms mt l mu mv">const Home = ({ data, error, isLoading }) =&gt; {<br/><br/>  if (isLoading) {<br/>    return &lt;h1&gt;Loading...&lt;/h1&gt;;<br/>  }<br/><br/>  if (error) {<br/>    return &lt;h1&gt;{error.message}&lt;/h1&gt;;<br/>  }<br/><br/>  return (<br/>    &lt;div&gt;<br/>      &lt;ReactQueryDevtools initialIsOpen={false} /&gt;<br/>      &lt;h1&gt;Companies&lt;/h1&gt;<br/>      &lt;ol&gt;<br/>        {data &amp;&amp; data.map(({ id, name, email, vat, phone, website }) =&gt; (<br/>          &lt;li key={id}&gt;<br/>            &lt;h2&gt;{name}&lt;/h2&gt;<br/>            &lt;p&gt;{email}&lt;/p&gt;<br/>            &lt;p&gt;{vat}&lt;/p&gt;<br/>            &lt;p&gt;{phone}&lt;/p&gt;<br/>            &lt;p&gt;{website}&lt;/p&gt;<br/>          &lt;/li&gt;<br/>        ))}<br/>      &lt;/ol&gt;<br/>    &lt;/div&gt;<br/>  );<br/>};<br/><br/>export default withQuery(Home, QUERY_KEYS.COMPANIES);</span></pre><p id="8c11" class="pw-post-body-paragraph ks kt iq ku b kv kw jr kx ky kz ju la lb lc ld le lf lg lh li lj lk ll lm ln ij bi translated">当然，我们也可以扩展它来使用多个查询，将额外的配置传递给<code class="fe mx my mz mn b">useQuery</code>，等等。，但就目前而言，这就足够了。</p><p id="8808" class="pw-post-body-paragraph ks kt iq ku b kv kw jr kx ky kz ju la lb lc ld le lf lg lh li lj lk ll lm ln ij bi translated">我希望这能让您对如何提高Next.js中API请求的弹性和性能有所了解。</p><p id="bfbe" class="pw-post-body-paragraph ks kt iq ku b kv kw jr kx ky kz ju la lb lc ld le lf lg lh li lj lk ll lm ln ij bi translated">快乐迷人！</p></div></div>    
</body>
</html>