<html>
<head>
<title>Developing a Flutter Native Plugin —A Real-world Scenario</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">开发一个Flutter原生插件——一个真实的场景</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/developing-flutter-native-plugin-a-real-world-scenario-f062bcdcda9f?source=collection_archive---------5-----------------------#2022-05-23">https://betterprogramming.pub/developing-flutter-native-plugin-a-real-world-scenario-f062bcdcda9f?source=collection_archive---------5-----------------------#2022-05-23</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="810d" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">在Xcode和Android Studio中编写原生代码与Flutter通信</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/e67cbd28c0ac09705672c73983bd8e67.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*Casl7bLiaEWSj3_a"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">Artur Shamsutdinov 在<a class="ae kv" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</p></figure><p id="f54c" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">你有没有想过和iOS / Android OS对话，做一些Flutter没有的特定动作？也许你的团队为iOS和Android平台准备了单独的<em class="ls">内部</em>包，你现在需要在Flutter中使用它。但是怎么做呢？</p></div><div class="ab cl lt lu hu lv" role="separator"><span class="lw bw bk lx ly lz"/><span class="lw bw bk lx ly lz"/><span class="lw bw bk lx ly"/></div><div class="ij ik il im in"><p id="0617" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我遇到了一个来自Naurt团队的请求，为他们的iOS和Android SDK创建一个Flutter插件。他们的产品是位置优化SDK所以他们希望他们的SDK也能用于Flutter应用。</p><h1 id="7664" class="ma mb iq bd mc md me mf mg mh mi mj mk jw ml jx mm jz mn ka mo kc mp kd mq mr bi translated"><strong class="ak">你将学到什么</strong></h1><ol class=""><li id="fb94" class="ms mt iq ky b kz mu lc mv lf mw lj mx ln my lr mz na nb nc bi translated">创建颤振插件</li><li id="ff2a" class="ms mt iq ky b kz nd lc ne lf nf lj ng ln nh lr mz na nb nc bi translated">从平台实现中分离插件行为(<a class="ae kv" href="https://docs.flutter.dev/development/packages-and-plugins/developing-packages" rel="noopener ugc nofollow" target="_blank">联合包</a>)</li><li id="92a6" class="ms mt iq ky b kz nd lc ne lf nf lj ng ln nh lr mz na nb nc bi translated">向本机平台发送消息。</li><li id="8368" class="ms mt iq ky b kz nd lc ne lf nf lj ng ln nh lr mz na nb nc bi translated">接收来自本机平台的响应。</li><li id="2181" class="ms mt iq ky b kz nd lc ne lf nf lj ng ln nh lr mz na nb nc bi translated">从本地到Flutter的流事件</li><li id="87c9" class="ms mt iq ky b kz nd lc ne lf nf lj ng ln nh lr mz na nb nc bi translated">从本机调用dart方法</li><li id="076a" class="ms mt iq ky b kz nd lc ne lf nf lj ng ln nh lr mz na nb nc bi translated">为SDK演示一个可运行的示例应用程序</li><li id="477e" class="ms mt iq ky b kz nd lc ne lf nf lj ng ln nh lr mz na nb nc bi translated">用Xcode编写与dart代码通信的iOS本地代码</li><li id="0247" class="ms mt iq ky b kz nd lc ne lf nf lj ng ln nh lr mz na nb nc bi translated">在Android Studio中编写与dart代码通信的Android本机代码</li></ol><h1 id="31d7" class="ma mb iq bd mc md me mf mg mh mi mj mk jw ml jx mm jz mn ka mo kc mp kd mq mr bi translated">解决办法</h1><p id="88a6" class="pw-post-body-paragraph kw kx iq ky b kz mu jr lb lc mv ju le lf ni lh li lj nj ll lm ln nk lp lq lr ij bi translated">Flutter使用<strong class="ky ir">方法通道</strong>来调用特定于平台的API。</p><p id="1aff" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">方法通道是一个灵活的消息传递系统，允许在应用程序的Flutter部分和非Dart部分之间进行双向通信。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nl"><img src="../Images/a9af25c2f5c0e9da2f432fc6617de4d9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*5NjKaEY8LGSbzfpTS_kUkw.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">方法通道架构概述</p></figure><ol class=""><li id="3d3d" class="ms mt iq ky b kz la lc ld lf nm lj nn ln no lr mz na nb nc bi translated">Flutter app可以向主机发送消息，主机接收消息并调用特定于平台的API——用本地语言。</li><li id="7b72" class="ms mt iq ky b kz nd lc ne lf nf lj ng ln nh lr mz na nb nc bi translated">主机可以将响应发送回Flutter应用程序</li></ol><p id="1b2f" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">您可以将方法通道视为HTTP方法。<em class="ls">我们不使用它们来调用服务器上的函数</em>，而是捆绑信息，以服务器可以理解的格式发送，并回复一个响应。</p><p id="6182" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">因此，当Flutter应用程序为Android开发时，它将Android SDK嵌入到Android应用程序捆绑包中，而当它为iOS开发时，它将iOS SDK嵌入到iOS应用程序捆绑包中。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi np"><img src="../Images/444f66fcea889601becdca7873ec008f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*0fW6FFLKgfYGWP4yiG_x5A.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">嵌入平台二进制文件的SDK</p></figure><h1 id="432c" class="ma mb iq bd mc md me mf mg mh mi mj mk jw ml jx mm jz mn ka mo kc mp kd mq mr bi translated">步骤1 —创建一个新的插件项目</h1><p id="ccfb" class="pw-post-body-paragraph kw kx iq ky b kz mu jr lb lc mv ju le lf ni lh li lj nj ll lm ln nk lp lq lr ij bi translated">为了创建一个Flutter插件，打开VSCode，然后<code class="fe nq nr ns nt b">View &gt; Command Palette &gt; Flutter: New Project</code>选择<code class="fe nq nr ns nt b">Plugin Template </code>并命名为<em class="ls"> naurt </em>。项目创建后，将文件夹重命名为<code class="fe nq nr ns nt b">naurt_platform_interface.</code>，注意<code class="fe nq nr ns nt b">package</code>和<code class="fe nq nr ns nt b">plugin</code>的区别。包只包含dart代码。而是用来与底层平台通信的插件。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nu"><img src="../Images/80e67aae6d832c59831da2aa53e6d734.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*PCiXR7pT2qIVV8jbp3Vc5Q.png"/></div></div></figure><p id="5549" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><code class="fe nq nr ns nt b">naurt_platform_interface</code>只包含抽象类，这些抽象类定义了插件包对特定于平台的实现的要求。所以方法没有实现。</p><p id="aaa1" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><code class="fe nq nr ns nt b">PlatformInterface</code>是一个帮助类，确保<code class="fe nq nr ns nt b">NaurtPlatform</code>的子类扩展这个类，而不是实现它。这有助于您以后向接口添加任何方法，它不会破坏所有平台特定的实现。</p><p id="6cd5" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">删除<code class="fe nq nr ns nt b">naurt</code>文件、<code class="fe nq nr ns nt b">example</code>文件夹和<code class="fe nq nr ns nt b">getPlatfromVersion()</code>。</p><p id="39f6" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">目标文件夹结构:</p><ul class=""><li id="37aa" class="ms mt iq ky b kz la lc ld lf nm lj nn ln no lr nv na nb nc bi translated"><code class="fe nq nr ns nt b">Naurt</code><br/>–<code class="fe nq nr ns nt b">naurt_platform_interface</code><br/>–<code class="fe nq nr ns nt b">naurt_ios</code><br/>–<code class="fe nq nr ns nt b">naurt_android</code><br/>–<code class="fe nq nr ns nt b">naurt_plugin</code></li></ul><p id="020f" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><code class="fe nq nr ns nt b">naurt_ios</code>和<code class="fe nq nr ns nt b">naurt_android</code>是<code class="fe nq nr ns nt b">naurt_platform_interface</code>的平台特定实现。<code class="fe nq nr ns nt b">naurt_plugin</code>引用了所有这些包，在Flutter应用程序中，我们将<code class="fe nq nr ns nt b">naurt_plugin</code>设置为依赖。所以以后如果需要一个windows插件，它需要创建另一个专门为windows实现接口的包。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nw"><img src="../Images/8112ba342813b915f9375181c74f3cfd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*bkpJHqv5LU7iD4NQyI7Sow.png"/></div></div></figure><h1 id="f838" class="ma mb iq bd mc md me mf mg mh mi mj mk jw ml jx mm jz mn ka mo kc mp kd mq mr bi translated"><strong class="ak">定义平台接口方法和属性</strong></h1><p id="e314" class="pw-post-body-paragraph kw kx iq ky b kz mu jr lb lc mv ju le lf ni lh li lj nj ll lm ln nk lp lq lr ij bi translated">看两个<a class="ae kv" href="https://gist.github.com/AnBowell/8a44250b1f2490df4230ba20c7b28295#file-naurt_object_properties-swift" rel="noopener ugc nofollow" target="_blank">iOS</a>/<a class="ae kv" href="https://gist.github.com/AnBowell/3e62482ee813fcfa734ea71d5a746ecf#file-naurt_object_properties-kt" rel="noopener ugc nofollow" target="_blank">Android</a>SDK方法。它们几乎完全相同，只是有一点不同。第一步是创建一个所有平台都应该使用的公共接口。此外，该团队提到，特定于平台的SDK中的属性是可见的，用户可以听到它们的变化。这意味着，例如在iOS / Android中，如果客户端想要监控位置更新，他们需要监听<code class="fe nq nr ns nt b">lastNaurtPoint</code>属性。</p><p id="7c38" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">让我们转换一个方法和一个属性。其余的都一样。</p><p id="d3e1" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><strong class="ky ir"> iOS </strong> : <code class="fe nq nr ns nt b"> Naurt.shared.initialise( apiKey: String, precision: Int)</code></p><p id="6c98" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><strong class="ky ir">安卓</strong> : <code class="fe nq nr ns nt b">Naurt.initialise( apiKey: String, context: Context, precision: Int): CompletableFuture&lt;NaurtTrackingStatus&gt;</code></p><p id="b258" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">并检查SDK是否正确初始化，有可观察的<code class="fe nq nr ns nt b">isInitialised </code>属性。</p><p id="037d" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><strong class="ky ir">iOS:</strong>T3】</p><p id="c91c" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><strong class="ky ir">安卓:</strong>T4】</p><p id="858c" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">通过观察特定于平台的语言(Swift、Kotlin)中的<code class="fe nq nr ns nt b">isInitialised</code>，片刻之后，SDK会通知您它是否被正确初始化。我们并不寻求判断它们的实现。我们需要在Dart中定义一个简单的接口，以适应我们在Flutter应用程序中的用例。</p><p id="8f2c" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><strong class="ky ir">建议镖法:</strong> <code class="fe nq nr ns nt b">Future&lt;bool&gt; initialize({required String apiKey, required int precision})</code></p><p id="807b" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">正如你所看到的，我们已经将上述两个方法和属性结合在一个统一的Dart方法中，并使用bool返回值来简化我们在Flutter应用程序中的插件使用。</p><p id="a010" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">目标是:</p><ol class=""><li id="1c18" class="ms mt iq ky b kz la lc ld lf nm lj nn ln no lr mz na nb nc bi translated">正确地与团队沟通，理解他们的意思</li><li id="5182" class="ms mt iq ky b kz nd lc ne lf nf lj ng ln nh lr mz na nb nc bi translated">提出一个好的解决方案。</li></ol><p id="e6e9" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在我们如何映射到dart时，有两个有趣的属性:</p><pre class="kg kh ki kj gt nx nt ny nz aw oa bi"><span id="7472" class="ob mb iq nt b gy oc od l oe of">/** Is Naurt's Locomotion running at the moment? */<br/>@Published isRunning: Bool</span><span id="3e4a" class="ob mb iq nt b gy og od l oe of">/** Most recent naurt point for the current journey* nil if no data is available */<br/>@Published naurtPoint: NaurtLocation?</span></pre><h2 id="5e86" class="ob mb iq bd mc oh oi dn mg oj ok dp mk lf ol om mm lj on oo mo ln op oq mq or bi translated"><strong class="ak">飞镖方法</strong></h2><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="os ot l"/></div></figure><p id="de17" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在Dart中，我们可以使用<code class="fe nq nr ns nt b">Stream</code>或<code class="fe nq nr ns nt b">callBacks</code>来观察变化。我更喜欢用流来改变位置，因为我可以用、<code class="fe nq nr ns nt b">map</code>、<code class="fe nq nr ns nt b">reduce</code>来操作流数据，但不能用回调。Boolean的回调比<code class="fe nq nr ns nt b">Stream</code> s要方便得多。</p><p id="fb17" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">您可以在此查看平台接口方法:</p><div class="ou ov gp gr ow ox"><a href="https://github.com/haashem/flutter-native-plugin-tutorial/blob/35188521c5e55407a562302da8ab1ff577f42b9e/naurt_platfrom_interface/lib/naurt_platform_interface.dart" rel="noopener  ugc nofollow" target="_blank"><div class="oy ab fo"><div class="oz ab pa cl cj pb"><h2 class="bd ir gy z fp pc fr fs pd fu fw ip bi translated">flutter-native-plugin-tutorial/naurt _ platform _ interface . dart at…</h2><div class="pe l"><h3 class="bd b gy z fp pc fr fs pd fu fw dk translated">此时您不能执行该操作。您已使用另一个标签页或窗口登录。您已在另一个选项卡中注销，或者…</h3></div><div class="pf l"><p class="bd b dl z fp pc fr fs pd fu fw dk translated">github.com</p></div></div><div class="pg l"><div class="ph l pi pj pk pg pl kp ox"/></div></div></a></div><h1 id="b7e0" class="ma mb iq bd mc md me mf mg mh mi mj mk jw ml jx mm jz mn ka mo kc mp kd mq mr bi translated">步骤2:创建iOS实现</h1><p id="76de" class="pw-post-body-paragraph kw kx iq ky b kz mu jr lb lc mv ju le lf ni lh li lj nj ll lm ln nk lp lq lr ij bi translated">创建另一个插件项目，命名为<code class="fe nq nr ns nt b">naurt_ios</code>，并保存在<code class="fe nq nr ns nt b">naurt</code>目录中。打开<code class="fe nq nr ns nt b">pubspec.yaml</code>并添加<code class="fe nq nr ns nt b">naurt_platfrom_interface</code>作为依赖:</p><pre class="kg kh ki kj gt nx nt ny nz aw oa bi"><span id="53f1" class="ob mb iq nt b gy oc od l oe of">naurt_platfrom_interface:<br/>  path: ../naurt_platfrom_interface/</span></pre><p id="fd71" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">此外，在文件顶部添加<code class="fe nq nr ns nt b">publish_to: 'none'</code>——对于本教程，我们不会发布到pub . dev——否则所有的依赖项都必须上传到<code class="fe nq nr ns nt b">pub.dev</code>。</p><p id="fbdc" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">将<code class="fe nq nr ns nt b">naurt_ios_method_channel</code>重命名为<code class="fe nq nr ns nt b">naurt_ios</code>，将其类重命名为<code class="fe nq nr ns nt b">NaurtIOS</code>，删除<code class="fe nq nr ns nt b">lib</code>文件夹中的其他文件。也删除<code class="fe nq nr ns nt b">example</code>和<code class="fe nq nr ns nt b">test</code>文件夹。</p><h2 id="2b52" class="ob mb iq bd mc oh oi dn mg oj ok dp mk lf ol om mm lj on oo mo ln op oq mq or bi translated"><strong class="ak">创建一个丢失的iOS文件夹</strong></h2><p id="ea09" class="pw-post-body-paragraph kw kx iq ky b kz mu jr lb lc mv ju le lf ni lh li lj nj ll lm ln nk lp lq lr ij bi translated">在终端中运行下面的命令，用<code class="fe nq nr ns nt b">iOS</code>文件夹重新创建插件项目。我们将在iOS文件夹中编写Swift代码，以处理来自Flutter应用程序的消息:</p><pre class="kg kh ki kj gt nx nt ny nz aw oa bi"><span id="9240" class="ob mb iq nt b gy oc od l oe of">flutter create --template=plugin --org=com.naurt --platforms=ios .</span></pre><p id="86d7" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">打开<code class="fe nq nr ns nt b">pubspec.yaml</code>文件，在flutter部分设置iOS的插件类:</p><pre class="kg kh ki kj gt nx nt ny nz aw oa bi"><span id="f798" class="ob mb iq nt b gy oc od l oe of">plugin:<br/>  platforms:<br/>    ios:<br/>      dartPluginClass: NaurtIOS<br/>      pluginClass: NaurtIosPlugin</span></pre><p id="38e0" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><code class="fe nq nr ns nt b">NaurtIOS</code>是实现该接口的Dart类的名称，</p><p id="f3b0" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><code class="fe nq nr ns nt b">NaurtIosPlugin</code>是方法通道将消息传输到的iOS类的名称。你可以在<code class="fe nq nr ns nt b">ios/classes</code>路径上找到这个类。Flutter自动生成Swift版本，名称为<code class="fe nq nr ns nt b">SwiftNaurtIosPlugin</code>:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi pm"><img src="../Images/17c1b4b7e3af2077c06feda9528371c9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1132/format:webp/1*ULvS-K14pYjBIYMtL0aJaA.png"/></div></figure><p id="2a67" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">打开<code class="fe nq nr ns nt b">NaurtIOS</code>文件，从<code class="fe nq nr ns nt b">NaurtPlatform</code>扩展它并覆盖方法:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="os ot l"/></div></figure><p id="a6a8" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们定义了一个名为<code class="fe nq nr ns nt b">com.naurt.ios</code>的方法通道来向iOS发送消息。</p><p id="6159" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><code class="fe nq nr ns nt b">registerWith</code>将在启动时被<code class="fe nq nr ns nt b">naurt_plugin </code>包调用，注册已经实现平台接口的dart类，并与原生平台通信。我们稍后将讨论这一点。</p><p id="8b86" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在最初的Naurt SDK自述文件中，也提到了SDK应该是单例的。所以dart中的singleton就是用<code class="fe nq nr ns nt b">_</code>添加命名构造函数那么简单。</p><p id="21ca" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在<code class="fe nq nr ns nt b">initialize</code>方法中，方法通道调用用<code class="fe nq nr ns nt b">apiKey</code>和<code class="fe nq nr ns nt b">precision</code>参数向项目的iOS端发送一个要初始化的消息名。我们用“发送消息”这个词，因为iOS端可以忽略这个消息，什么都不会发生。</p><h2 id="166c" class="ob mb iq bd mc oh oi dn mg oj ok dp mk lf ol om mm lj on oo mo ln op oq mq or bi translated"><strong class="ak">添加Naurt iOS SDK依赖关系</strong></h2><p id="02d6" class="pw-post-body-paragraph kw kx iq ky b kz mu jr lb lc mv ju le lf ni lh li lj nj ll lm ln nk lp lq lr ij bi translated">打开<code class="fe nq nr ns nt b">iOS/naurt_ios.podspec</code>，添加Naurt iOS SDK依赖:</p><pre class="kg kh ki kj gt nx nt ny nz aw oa bi"><span id="90cf" class="ob mb iq nt b gy oc od l oe of">s.dependency 'naurt_cocoapod', '0.6.0'<br/>s.xcconfig = { 'ENABLE_BITCODE' =&gt; 'NO', }<br/>s.platform = :ios, '13.4'</span></pre><p id="4c20" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们还禁用了依赖项的位代码，因为SDK文档中提到应该禁用它。</p><p id="7cdd" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">如果在您的情况下，依赖项在<code class="fe nq nr ns nt b">cocoapods</code>上不可用，并且您将它作为框架，导航到平台实现路径，如:<code class="fe nq nr ns nt b">naurt_ios/ios/Frameworks</code>将框架移动到文件夹中，并更新podspec，如下所示:</p><pre class="kg kh ki kj gt nx nt ny nz aw oa bi"><span id="8d58" class="ob mb iq nt b gy oc od l oe of">s.vendored_frameworks = 'Frameworks/FaceTecSDK.framework'</span></pre><p id="3102" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">然后在termnial中导航到<code class="fe nq nr ns nt b">naurt_ios/example/iOS</code>并键入<code class="fe nq nr ns nt b">pod install</code>以将依赖关系与项目集成。</p><p id="c235" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">那我们如何处理iOS中的方法通道消息呢？我们应该在哪里写Swift代码？</p><p id="46f8" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们将在<code class="fe nq nr ns nt b">SwiftNaurtIosPlugin.swift</code>编写所有Swift代码。</p><h1 id="7f16" class="ma mb iq bd mc md me mf mg mh mi mj mk jw ml jx mm jz mn ka mo kc mp kd mq mr bi translated">Xcode中的iOS插件实现</h1><p id="a632" class="pw-post-body-paragraph kw kx iq ky b kz mu jr lb lc mv ju le lf ni lh li lj nj ll lm ln nk lp lq lr ij bi translated">右键点击<code class="fe nq nr ns nt b">example/iOS</code>，在Xcode中打开。是时候编写Swift代码并处理来自Flutter端的消息了。</p><p id="c0cb" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">导航到<code class="fe nq nr ns nt b">SwiftNaurtIosPlugin.swift</code>。该文件的路径是深层嵌套的，但您可以通过查看下图来找到它:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi pn"><img src="../Images/c4e5af5d2bfbd1dc322b41245f2e02bb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ZEkCi_lUg0DChjUD9d0x0g.png"/></div></div></figure><p id="b889" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">导入<code class="fe nq nr ns nt b">naurt_framework</code>并构建项目以验证一切工作正常。</p><p id="7567" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">那么<code class="fe nq nr ns nt b">SwiftNaurtIosPlugin</code>如何从方法通道接收消息呢？</p><p id="4c0a" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">如果你记得我们在<code class="fe nq nr ns nt b">naurt_ios</code> <code class="fe nq nr ns nt b">pubspec.yaml</code>中设置<code class="fe nq nr ns nt b">NaurtIosPlugin</code>为iOS插件类。</p><p id="8fac" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在<code class="fe nq nr ns nt b">register</code>方法中，创建了一个名为<code class="fe nq nr ns nt b">com.naurt.ios</code>的方法通道。你可以认为<code class="fe nq nr ns nt b">binaryMessenger</code>是一个编码和解码消息的工具。为了处理通道中的消息，我们需要覆盖:</p><pre class="kg kh ki kj gt nx nt ny nz aw oa bi"><span id="a06f" class="ob mb iq nt b gy oc od l oe of">func handle(_ call: FlutterMethodCall, result: @escaping FlutterResult)</span></pre><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="os ot l"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">处理方法调用</p></figure><h2 id="2125" class="ob mb iq bd mc oh oi dn mg oj ok dp mk lf ol om mm lj on oo mo ln op oq mq or bi translated"><strong class="ak">从Dart中调用本机方法</strong></h2><p id="4695" class="pw-post-body-paragraph kw kx iq ky b kz mu jr lb lc mv ju le lf ni lh li lj nj ll lm ln nk lp lq lr ij bi translated">在方法内部，我们检查是否调用了<code class="fe nq nr ns nt b">initialize</code>方法——然后我们从调用中提取方法参数，并将其传递给iOS SDK initialize方法。</p><p id="190e" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">如果我们看一下<code class="fe nq nr ns nt b">NaurtPlatform</code> <code class="fe nq nr ns nt b">initialize</code>方法，它期望一个bool返回值。</p><p id="63e4" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">为了找出初始化结果，我们需要观察<code class="fe nq nr ns nt b">isInitialized</code> Naurt iOS SDK属性并将该值传递给<code class="fe nq nr ns nt b">handle(_ :FlutterMethodCall, result: @escaping FlutterResult)</code> <code class="fe nq nr ns nt b">result</code>参数。</p><p id="26dd" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><code class="fe nq nr ns nt b">result</code>用于将返回值传递给调用者。现在您已经了解了如何在本机中调用方法并向dart返回值。因为Naurt iOS SDK内部使用了Combine框架，所以我们需要保留订阅列表，否则我们无法观察到变化。</p><h2 id="f3c5" class="ob mb iq bd mc oh oi dn mg oj ok dp mk lf ol om mm lj on oo mo ln op oq mq or bi translated"><strong class="ak">从本机调用Dart方法</strong></h2><p id="0161" class="pw-post-body-paragraph kw kx iq ky b kz mu jr lb lc mv ju le lf ni lh li lj nj ll lm ln nk lp lq lr ij bi translated">如果您还记得，我们在名为:</p><pre class="kg kh ki kj gt nx nt ny nz aw oa bi"><span id="c8c9" class="ob mb iq nt b gy oc od l oe of">ValueChanged&lt;bool&gt;? onRunning;</span></pre><p id="5d5c" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们使用这个回调来观察SDK的运行状态。你在原生版中看到了我们如何在channel上使用<code class="fe nq nr ns nt b">invokeMethod</code>用status值调用Dart中的<code class="fe nq nr ns nt b">onRunning</code>。</p><p id="1cc3" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在Dart中，我们以同样的方式处理方法调用。下面是我在<code class="fe nq nr ns nt b">NaurtIOS</code>初始化器中的Dart方法调用处理:</p><pre class="kg kh ki kj gt nx nt ny nz aw oa bi"><span id="869c" class="ob mb iq nt b gy oc od l oe of">NaurtIOS() {<br/>  methodChannel.setMethodCallHandler((call) async {<br/>    if (call.method == 'onRunning') {<br/>      onRunning?.call(call.arguments);<br/>    }<br/>  });<br/>}</span></pre><h2 id="f62e" class="ob mb iq bd mc oh oi dn mg oj ok dp mk lf ol om mm lj on oo mo ln op oq mq or bi translated"><strong class="ak">将事件从本机流式传输到Dart </strong></h2><p id="46c4" class="pw-post-body-paragraph kw kx iq ky b kz mu jr lb lc mv ju le lf ni lh li lj nj ll lm ln nk lp lq lr ij bi translated">与方法通道相同，您需要一个事件通道来打开，并使用事件接收器将事件流放入通道中。对于每个特定的事件，您需要一个特定的事件接收器。在Flutter中，我们需要监听位置变化。</p><p id="51d0" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">首先，我们需要创建一个事件通道:</p><pre class="kg kh ki kj gt nx nt ny nz aw oa bi"><span id="a320" class="ob mb iq nt b gy oc od l oe of">static const EventChannel _eventChannel = EventChannel('com.naurt.ios');</span></pre><p id="e96b" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">然后我们以这种方式监听位置变化，并将其映射到<code class="fe nq nr ns nt b">NaurtLocation</code>:</p><pre class="kg kh ki kj gt nx nt ny nz aw oa bi"><span id="dd3c" class="ob mb iq nt b gy oc od l oe of">@override<br/>Stream&lt;NaurtLocation&gt; get onLocationChanged {<br/>  return eventChannel<br/>  .receiveBroadcastStream()<br/>  .where((location) =&gt; location != null)<br/>  .map((dynamic location) =&gt;<br/>     NaurtLocation.fromMap(Map&lt;String, dynamic&gt;.from(location)));<br/>}</span></pre><p id="2777" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">并且在iOS中我们用<code class="fe nq nr ns nt b">register</code>方法创建了一个具有相同标识符的事件通道:</p><pre class="kg kh ki kj gt nx nt ny nz aw oa bi"><span id="3c96" class="ob mb iq nt b gy oc od l oe of">let eventChannel = FlutterEventChannel(name: "com.naurt.ios", binaryMessenger: registrar.messenger())<br/>eventChannel.setStreamHandler(instance)</span></pre><p id="f00d" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们创建一个名为<code class="fe nq nr ns nt b">locationUpdateEventSink</code>的属性，专门用于sinking位置更新。</p><pre class="kg kh ki kj gt nx nt ny nz aw oa bi"><span id="1da7" class="ob mb iq nt b gy oc od l oe of">private var locationUpdateEventSink: FlutterEventSink?</span></pre><p id="0600" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">然后，我们在事件通道打开时设置事件接收器，并在它关闭时清除它:</p><pre class="kg kh ki kj gt nx nt ny nz aw oa bi"><span id="d6ab" class="ob mb iq nt b gy oc od l oe of">public func onListen(withArguments arguments: Any?, eventSink events: @escaping FlutterEventSink) -&gt; FlutterError? {<br/>  locationUpdateEventSink = events<br/>  return nil<br/>}</span><span id="72cf" class="ob mb iq nt b gy og od l oe of">public func onCancel(withArguments arguments: Any?) -&gt; FlutterError? {<br/>  locationUpdateEventSink = nil<br/>  return nil<br/>}</span></pre><p id="e0b7" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">通过观察<code class="fe nq nr ns nt b">naurtPoint</code>的更新，我们将更新传递给事件接收器:</p><pre class="kg kh ki kj gt nx nt ny nz aw oa bi"><span id="72f7" class="ob mb iq nt b gy oc od l oe of">subscriptions.append(Naurt.shared.$naurtPoint.sink { [weak self ]   value in<br/>  self?.locationUpdateEventSink?(value?.encode())<br/>})</span></pre><p id="f2af" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><code class="fe nq nr ns nt b">encode</code>是对<code class="fe nq nr ns nt b">NaurtLocation</code>对象的扩展，将它转换成地图。</p><p id="e46a" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们只能在方法和事件通道中传递原始数据类型。</p><pre class="kg kh ki kj gt nx nt ny nz aw oa bi"><span id="cb97" class="ob mb iq nt b gy oc od l oe of">private extension NaurtLocation {<br/>  func encode() -&gt; [String: Any]{<br/>    return ["latitude": latitude, "longitude":longitude, "timestamp": timestamp]<br/>  }<br/>}</span></pre><p id="5730" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">为了验证插件的正确性，我在<code class="fe nq nr ns nt b">naurt-ios</code>插件文件夹中添加了一个例子，它只是测试SDK的基本行为:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi po"><img src="../Images/dfaf4b2c3f4ad6c406ae718f6b05dc97.png" data-original-src="https://miro.medium.com/v2/resize:fit:900/format:webp/1*KBBBCn0fXqarV9EEUqnEcQ.jpeg"/></div></figure><p id="ea1d" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><a class="ae kv" href="https://github.com/haashem/flutter-native-plugin-tutorial/tree/7bd60c8455fdf65a09de777b1cc11a560ee133bc" rel="noopener ugc nofollow" target="_blank">在Github查看完整的iOS插件源代码</a></p><h1 id="5f84" class="ma mb iq bd mc md me mf mg mh mi mj mk jw ml jx mm jz mn ka mo kc mp kd mq mr bi translated">步骤3:创建Naurt Android插件项目</h1><p id="110c" class="pw-post-body-paragraph kw kx iq ky b kz mu jr lb lc mv ju le lf ni lh li lj nj ll lm ln nk lp lq lr ij bi translated">创建一个新的插件项目，命名为<code class="fe nq nr ns nt b">naurt_android</code>。</p><p id="8b0a" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">删除<code class="fe nq nr ns nt b">pubspec.yaml</code>文件。我们现在将重新创建它。</p><p id="fe56" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">运行以下命令在<code class="fe nq nr ns nt b">naurt_android</code>目录下创建<code class="fe nq nr ns nt b">android</code>和<code class="fe nq nr ns nt b">example</code>文件夹。</p><pre class="kg kh ki kj gt nx nt ny nz aw oa bi"><span id="211e" class="ob mb iq nt b gy oc od l oe of">flutter create --template=plugin --org=com.naurt --platforms=android .</span></pre><p id="39cb" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><code class="fe nq nr ns nt b">pubspec.yaml</code>用正确的类和包名重新创建。</p><pre class="kg kh ki kj gt nx nt ny nz aw oa bi"><span id="326a" class="ob mb iq nt b gy oc od l oe of">flutter:<br/>  plugin:<br/>    platforms:<br/>      android:<br/>        package: com.naurt.naurt_android<br/>        pluginClass: NaurtAndroidPlugin<br/>        dartPluginClass: NaurtAndroid</span></pre><p id="a402" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><code class="fe nq nr ns nt b">NaurtAndroidPlugin</code>是我们编写android原生代码的Kotlin文件。另外，在依赖关系部分添加<code class="fe nq nr ns nt b">naurt_platfrom_interface</code>:</p><pre class="kg kh ki kj gt nx nt ny nz aw oa bi"><span id="5280" class="ob mb iq nt b gy oc od l oe of">naurt_platfrom_interface:<br/>  path: ../naurt_platfrom_interface/</span></pre><p id="4095" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">删除我们不需要的<code class="fe nq nr ns nt b">naurt_android_platform_interface.dart</code>和<code class="fe nq nr ns nt b">naurt_android_method_channel.dart</code>文件。</p><p id="0112" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">接口的Dart实现与iOS相同。</p><p id="0784" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">但是它可以基于需求而不同。灵活性是实现分离的好处。</p><p id="f6f0" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这意味着两个不同的团队可以以他们喜欢的任何方式实现相同的接口。</p><h1 id="40f1" class="ma mb iq bd mc md me mf mg mh mi mj mk jw ml jx mm jz mn ka mo kc mp kd mq mr bi translated">Android Studio中的Android插件实现</h1><p id="79a5" class="pw-post-body-paragraph kw kx iq ky b kz mu jr lb lc mv ju le lf ni lh li lj nj ll lm ln nk lp lq lr ij bi translated">在Android Studio中打开整个<code class="fe nq nr ns nt b">naurt_android</code>文件夹—通过打开Android Studio: <code class="fe nq nr ns nt b">File &gt; Open &gt; “path to naurt_android project"</code></p><p id="5764" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">然后安装Android Studio的Flutter插件:<code class="fe nq nr ns nt b">Android Studio &gt; Preferences &gt; Plugins &gt; Flutter</code>并安装。然后重启Android Studio。它加载了原生Android项目所需的所有Flutter包。通过这样做，我们能够编辑本机插件的Kotlin文件。</p><p id="1e89" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">要为Flutter启用代码完成，您需要再次打开首选项，在<code class="fe nq nr ns nt b">preferences</code>中搜索Flutter并启用代码完成:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi pp"><img src="../Images/7f560db9601ec769596f7c4919658e53.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*CyIuYjnvE1lpU1Wocah5fg.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">在Android Studio中为Flutter启用代码完成</p></figure><p id="a01c" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">然后从左侧栏选择<code class="fe nq nr ns nt b">Packages</code>模式，选择<code class="fe nq nr ns nt b">NaurtAndroidPlugin</code>，然后在右侧选择<code class="fe nq nr ns nt b">Open for Editing in Android Studio</code></p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi pq"><img src="../Images/45ba22b18957404cd6e33c23e24b4fe0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*dDTMujSo0CTldyKP7pLQGw.png"/></div></div></figure><p id="8aa2" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">最后，我们可以使用代码完成功能编辑Android插件Kotlin文件。</p><h2 id="63ea" class="ob mb iq bd mc oh oi dn mg oj ok dp mk lf ol om mm lj on oo mo ln op oq mq or bi translated"><strong class="ak">配置Android依赖关系</strong></h2><p id="9645" class="pw-post-body-paragraph kw kx iq ky b kz mu jr lb lc mv ju le lf ni lh li lj nj ll lm ln nk lp lq lr ij bi translated">为<code class="fe nq nr ns nt b">naurt_android</code>打开<code class="fe nq nr ns nt b">build.gradle</code>并添加<a class="ae kv" href="https://docs.naurt.net/android_sdk" rel="noopener ugc nofollow" target="_blank"> Naurt Android SDK依赖项</a>，并将JitPack添加到存储库列表列表中:</p><pre class="kg kh ki kj gt nx nt ny nz aw oa bi"><span id="2db1" class="ob mb iq nt b gy oc od l oe of">rootProject.allprojects <strong class="nt ir">{<br/>    </strong>repositories <strong class="nt ir">{<br/>        </strong>google()<br/>        mavenCentral()<br/>        maven <strong class="nt ir">{ </strong>url 'https://jitpack.io' <strong class="nt ir">}<br/>    }<br/>}</strong></span></pre><p id="c7f7" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">然后点击IDE右上角的<code class="fe nq nr ns nt b">Sync Now</code>来安装依赖项。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi pr"><img src="../Images/65cab80234b49b10c1de63ab8c0ee003.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*fYMddM5UQo-DKEBiphnVag.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">添加Android依赖项</p></figure><p id="f7b4" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">将<a class="ae kv" href="https://docs.naurt.net/android_sdk" rel="noopener ugc nofollow" target="_blank">所需权限</a>添加到AndroidManifest.xml中，现在可以在<code class="fe nq nr ns nt b">NaurtAndroidPlugin.kt</code>中导入以下内容，并开始在Android Studio中编写插件的Android实现。</p><pre class="kg kh ki kj gt nx nt ny nz aw oa bi"><span id="e29c" class="ob mb iq nt b gy oc od l oe of">import  com.naurt_kotlin_sdk.Naurt.<em class="ls">INSTANCE </em>as Naurt</span></pre><p id="0bc7" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我已经写了完整的android实现。大部分和iOS一样。你可以在这里浏览一下<a class="ae kv" href="https://github.com/haashem/flutter-native-plugin-tutorial/tree/5137a0b8c8e2ed6379dfcbae6e9e78d32b30bd89" rel="noopener ugc nofollow" target="_blank">的Android实现</a>。</p><h1 id="c9e2" class="ma mb iq bd mc md me mf mg mh mi mj mk jw ml jx mm jz mn ka mo kc mp kd mq mr bi translated">步骤4:创建Naurt插件项目</h1><p id="fde6" class="pw-post-body-paragraph kw kx iq ky b kz mu jr lb lc mv ju le lf ni lh li lj nj ll lm ln nk lp lq lr ij bi translated">在这里，我们引用了所有iOS、Android和其他平台的<code class="fe nq nr ns nt b">NaurtPlatform</code>接口实现，并创建了一个示例项目，可以使用适当的实现插件运行所有平台。</p><p id="7e7c" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">创建一个新的插件项目，命名为<code class="fe nq nr ns nt b">naurt_plugin</code>。</p><p id="6731" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">运行以下命令，在<code class="fe nq nr ns nt b">naurt_plugin</code>目录下创建一个<code class="fe nq nr ns nt b">example</code>文件夹。</p><pre class="kg kh ki kj gt nx nt ny nz aw oa bi"><span id="d794" class="ob mb iq nt b gy oc od l oe of">flutter create --template=plugin --org=com.naurt --platforms=iOS, android .</span></pre><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi ps"><img src="../Images/13d47e3cab5bb3380fc05a63fac1c731.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*XnmpuRKeh8Pik4TPX3jTcw.png"/></div></div></figure><p id="a365" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">打开<code class="fe nq nr ns nt b">pubspec.yaml</code>文件，在依赖项部分添加<code class="fe nq nr ns nt b">naurt_platform_interface</code>、<code class="fe nq nr ns nt b">naurt_ios</code>和<code class="fe nq nr ns nt b">naurt_android</code>:</p><pre class="kg kh ki kj gt nx nt ny nz aw oa bi"><span id="ddfe" class="ob mb iq nt b gy oc od l oe of">dependencies:<br/>  naurt_platfrom_interface:<br/>    path: ../naurt_platfrom_interface/<br/>  naurt_android:<br/>    path: ../naurt_android/<br/>  naurt_ios:<br/>    path: ../naurt_ios/</span></pre><p id="73c8" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">然后添加<code class="fe nq nr ns nt b">naurt_ios</code>为iOS平台实现，分别为android:</p><pre class="kg kh ki kj gt nx nt ny nz aw oa bi"><span id="dadb" class="ob mb iq nt b gy oc od l oe of">flutter:<br/>  plugin:<br/>    platforms:<br/>      ios:<br/>        default_package: naurt_ios<br/>      android:<br/>        default_package: naurt_android</span></pre><p id="363f" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">将<code class="fe nq nr ns nt b">main.dart</code>复制到<code class="fe nq nr ns nt b">naurt_ios</code>或<code class="fe nq nr ns nt b">naurt_android</code>示例文件夹中，并在<code class="fe nq nr ns nt b">naurt_plugin</code>示例app中重复使用。</p><p id="3406" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">运行<code class="fe nq nr ns nt b">naurt_plugin</code>应用中的示例应用，查看在Android和iOS设备上的运行情况。</p><p id="8756" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">从现在开始，如果你想在任何Flutter应用程序中使用该插件，只需在<code class="fe nq nr ns nt b">pubspec.yaml</code>中引用<code class="fe nq nr ns nt b">naurt_plugin</code>。</p><p id="7649" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">因为基于上面的配置，插件可以理解要查找哪个平台实例。</p><h1 id="b719" class="ma mb iq bd mc md me mf mg mh mi mj mk jw ml jx mm jz mn ka mo kc mp kd mq mr bi translated">结论</h1><p id="0703" class="pw-post-body-paragraph kw kx iq ky b kz mu jr lb lc mv ju le lf ni lh li lj nj ll lm ln nk lp lq lr ij bi translated">这是一个很沉重的话题，但是我们可以提起它🏋️‍♀️.</p><p id="22cc" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">您学习了如何从Flutter端与底层平台通信，反之亦然——用Xcode和Android Studio编写本机代码来与Flutter通信。此外，您还练习了联邦插件包，这是Flutter团队推荐的方法。</p><p id="6b23" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">你可以在Github 上查看完整的源代码。</p></div></div>    
</body>
</html>