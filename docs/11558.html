<html>
<head>
<title>Implementing the Adapter Design Pattern in Swift</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">在Swift中实施适配器设计模式</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/the-adapter-design-pattern-in-swift-59ae3f2289a1?source=collection_archive---------7-----------------------#2022-03-30">https://betterprogramming.pub/the-adapter-design-pattern-in-swift-59ae3f2289a1?source=collection_archive---------7-----------------------#2022-03-30</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="fa46" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">让我们使用Swift中的一个真实例子来讨论适配器设计模式</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/1a21e2212dca777150403960ed739ae4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*hGdCXI-3c1DIOrV5ylTY7w.jpeg"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">马库斯·温克勒在<a class="ae kv" href="https://unsplash.com/s/photos/adapter?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的照片</p></figure><p id="a5a4" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">适配器是一种结构设计模式，允许不兼容的类或结构一起工作。</p><p id="fc56" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">通常在我们希望将外部类/结构或第三方库集成到我们的代码中，并且它们的接口与我们当前在应用程序中使用的接口不匹配时使用。</p><p id="c233" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">让我们看看适配器实现的通用结构:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ls lt l"/></div></figure><p id="877d" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">适配器实现由三个主要参与者组成:</p><p id="3493" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><strong class="ky ir">目标接口(协议):</strong>定义客户端代码在我们的应用程序中使用的接口。我们使用适配器模式使现有的类/结构与我们的目标接口兼容。</p><p id="c777" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><strong class="ky ir"> Adaptee: </strong>定义需要适配以兼容目标接口的类型。</p><p id="4ba8" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><strong class="ky ir">适配器:</strong>负责将被适配器类型适配到目标接口。这可以使用适配器类型(如上面的代码所示实现的类或结构)或利用Swift扩展来实现(我们将在最后一节研究这种方法)。</p><h2 id="cfd0" class="lu lv iq bd lw lx ly dn lz ma mb dp mc lf md me mf lj mg mh mi ln mj mk ml mm bi translated">真实世界的例子</h2><p id="4819" class="pw-post-body-paragraph kw kx iq ky b kz mn jr lb lc mo ju le lf mp lh li lj mq ll lm ln mr lp lq lr ij bi translated">假设我们的应用程序中目前有以下界面，其主要目的是呈现一个进度HUD:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ls lt l"/></div></figure><p id="a6c2" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">它在我们的应用中被广泛使用，就像这样:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ls lt l"/></div></figure><p id="c63d" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">然后，我们被分配了一项任务，我们需要开始使用<a class="ae kv" href="https://github.com/pkluz/PKHUD" rel="noopener ugc nofollow" target="_blank"> PKHUD </a>进行我们所有的HUD演示。鉴于我们的大多数屏幕目前都将HUDPresenter作为一种依赖来使用，我们希望继续使用它。因此，这是使用适配器模式使PKHUD适应我们的HUDPresenter协议的好时机:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ls lt l"/></div></figure><p id="4ec6" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这里的目标是<code class="fe ms mt mu mv b">HUDPresenter</code>协议。被适配者应该是<code class="fe ms mt mu mv b">PKHUD</code>。而<code class="fe ms mt mu mv b">PKHUDPresenter</code>类将是适配器。</p><p id="ab63" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">你可能会问:为什么我们不直接用PKHUD的实例替换HUDPresenter呢？有几个原因:</p><ol class=""><li id="615e" class="mw mx iq ky b kz la lc ld lf my lj mz ln na lr nb nc nd ne bi translated">如果将来我们想用另一个HUD第三方库替换PKHUD，我们需要用新库更新每个使用PKHUD的视图控制器。这太容易出错，我们的代码会变得不太容易维护(UI依赖关系的改变会触发我们代码库中的大量更新)。</li><li id="427a" class="mw mx iq ky b kz nf lc ng lf nh lj ni ln nj lr nb nc nd ne bi translated">我们将违反<a class="ae kv" href="http://blog.cleancoder.com/uncle-bob/2014/05/12/TheOpenClosedPrinciple.html" rel="noopener ugc nofollow" target="_blank">开闭原则</a>，该原则规定类应该对扩展开放，但对修改关闭。我们应该能够扩展视图控制器的行为，而不需要修改它们的源代码。</li><li id="08ff" class="mw mx iq ky b kz nf lc ng lf nh lj ni ln nj lr nb nc nd ne bi translated">我们将违反<a class="ae kv" href="https://stackify.com/dependency-inversion-principle/" rel="noopener ugc nofollow" target="_blank">依赖倒置原则</a>，该原则声明我们应该依赖抽象(Swift中的协议)而不是具体类型(Swift中的值或引用类型)。</li></ol><h2 id="582a" class="lu lv iq bd lw lx ly dn lz ma mb dp mc lf md me mf lj mg mh mi ln mj mk ml mm bi translated">快速扩展方法</h2><p id="47d1" class="pw-post-body-paragraph kw kx iq ky b kz mn jr lb lc mo ju le lf mp lh li lj mq ll lm ln mr lp lq lr ij bi translated">让专用的结构/类作为适配器工作的另一种方法是扩展Adaptee以符合我们的目标接口协议。</p><p id="398c" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">回到上面的实际例子，我们采用这种方法的解决方案应该是这样的:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ls lt l"/></div></figure><p id="c0de" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">使用扩展方法，我们不需要为适配器创建额外的结构/类。</p><p id="efa9" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这种方法的一个缺点是，在将PKHUD依赖项注入视图控制器时，您需要导入它。如果您的依赖项是以集中的方式创建和注入的，那么这个缺点可以被最小化。</p></div><div class="ab cl nk nl hu nm" role="separator"><span class="nn bw bk no np nq"/><span class="nn bw bk no np nq"/><span class="nn bw bk no np"/></div><div class="ij ik il im in"><p id="d1e2" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">就是这样！我希望这个适配器模式的真实用例对您和您未来的项目有用。</p></div></div>    
</body>
</html>