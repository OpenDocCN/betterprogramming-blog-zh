<html>
<head>
<title>10 Lessons I Learned From Architecting an Enterprise Application</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">我从设计企业应用程序中学到的10个教训</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/frontend-architecture-376e6323ef9b?source=collection_archive---------4-----------------------#2021-03-18">https://betterprogramming.pub/frontend-architecture-376e6323ef9b?source=collection_archive---------4-----------------------#2021-03-18</a></blockquote><div><div class="fc ii ij ik il im"/><div class="in io ip iq ir"><h2 id="262a" class="is it iu bd b dl iv iw ix iy iz ja dk jb translated" aria-label="kicker paragraph"><a class="ae ep" href="https://rakiabensassi.medium.com/list/software-engineering-7a179a23ebfd" rel="noopener">软件工程</a></h2><div class=""/><div class=""><h2 id="a7bc" class="pw-subtitle-paragraph ka jd iu bd b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr dk translated">前端架构从来都不是“一劳永逸”的命题，没有任何设计或计划是完美或完整的</h2></div><figure class="kt ku kv kw gu kx gi gj paragraph-image"><div role="button" tabindex="0" class="ky kz di la bf lb"><div class="gi gj ks"><img src="../Images/f214706a7753a5a7a7fb5cf3e7e8b3bf.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*nRh026pl1mW2iwMU"/></div></div><p class="le lf gk gi gj lg lh bd b be z dk translated">照片由<a class="ae li" href="https://unsplash.com/@thisisengineering?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">在</a><a class="ae li" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</p></figure><blockquote class="lj lk ll"><p id="9866" class="lm ln lo lp b lq lr ke ls lt lu kh lv lw lx ly lz ma mb mc md me mf mg mh mi in bi translated">“我们有一个大型ERP项目，我们在后端使用DotNet核心微服务。在这个ERP项目中，我们希望使用Angular在遗留系统中完成与windows窗体相同的事务和功能。最重要的是，我们希望在键盘上使用可编辑的角度网格。”</p></blockquote><p id="8aea" class="pw-post-body-paragraph lm ln iu lp b lq lr ke ls lt lu kh lv mj lx ly lz mk mb mc md ml mf mg mh mi in bi translated">从一个新的业务联系人那里收到这条消息几天后，在与他讨论了这个项目后，我开始构建一个内嵌的可编辑网格，它满足了<a class="ae li" rel="noopener ugc nofollow" target="_blank" href="/angular-keyboard-listeners-good-practices-b208edc6bf89"> web accessibility (A11y) </a>的需求。</p><p id="4cef" class="pw-post-body-paragraph lm ln iu lp b lq lr ke ls lt lu kh lv mj lx ly lz mk mb mc md ml mf mg mh mi in bi translated">它为最终用户提供了使用鼠标和键盘或仅使用键盘来执行以下(及更多)功能的可能性:</p><ul class=""><li id="979e" class="mm mn iu lp b lq lr lt lu mj mo mk mp ml mq mi mr ms mt mu bi translated">编辑、删除、添加和保存行。</li><li id="490f" class="mm mn iu lp b lq mv lt mw mj mx mk my ml mz mi mr ms mt mu bi translated">在行、列和单元格之间导航。</li><li id="66d5" class="mm mn iu lp b lq mv lt mw mj mx mk my ml mz mi mr ms mt mu bi translated">将不可编辑的行转换为可编辑的模式(使用键盘箭头和ENTER键)。</li><li id="b151" class="mm mn iu lp b lq mv lt mw mj mx mk my ml mz mi mr ms mt mu bi translated">在某些特定列中使用自动完成功能，让用户可以搜索值。</li><li id="fcca" class="mm mn iu lp b lq mv lt mw mj mx mk my ml mz mi mr ms mt mu bi translated">当焦点在显示自动完成的单元格中时，按F2键后打开一个显示更详细结果的对话框。</li><li id="d76b" class="mm mn iu lp b lq mv lt mw mj mx mk my ml mz mi mr ms mt mu bi translated">在对话框中的数据列表中导航并在其中执行搜索(或从中打开其他对话框)，然后使用键盘箭头和ENTER键选择一个值。</li><li id="5d0e" class="mm mn iu lp b lq mv lt mw mj mx mk my ml mz mi mr ms mt mu bi translated">用键盘关闭对话框，并将焦点设置回网格或先前打开的对话框。</li></ul><figure class="kt ku kv kw gu kx gi gj paragraph-image"><div role="button" tabindex="0" class="ky kz di la bf lb"><div class="gi gj na"><img src="../Images/a1c47a1350686985e057e47d981f028b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*iDmgmlF_1ssAFb9Y4dQ-Aw.png"/></div></div><p class="le lf gk gi gj lg lh bd b be z dk translated">带有动态表格的角度材料自定义自动完成</p></figure><figure class="kt ku kv kw gu kx gi gj paragraph-image"><div role="button" tabindex="0" class="ky kz di la bf lb"><div class="gi gj nb"><img src="../Images/bca45eff166d920fa511f4c70c4ed413.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*A2umVgLkQvmkCVEQbwVjFg.png"/></div></div><p class="le lf gk gi gj lg lh bd b be z dk translated">在内嵌可编辑网格中使用的角度材料自定义自动完成(带有动态表格)</p></figure><p id="6334" class="pw-post-body-paragraph lm ln iu lp b lq lr ke ls lt lu kh lv mj lx ly lz mk mb mc md ml mf mg mh mi in bi translated">有了这个关键特性——带键盘监听器的内联可编辑网格——的控制，项目中团队成员的数量增加了，应用程序开始形成大规模应用程序(ERP)的形状。然后我被委以前端架构师的角色。我实现了许多动态组件，在多个模块中使用，并在需要时调整代码设计，以降低复杂性并促进新队友的集成。</p><p id="6734" class="pw-post-body-paragraph lm ln iu lp b lq lr ke ls lt lu kh lv mj lx ly lz mk mb mc md ml mf mg mh mi in bi translated">在这篇文章中，我将分享我从这次旅程中学到的十个教训。他们的目的不是教你如何设计一个企业web应用程序，而是帮助你熟悉前端架构和软件工程的许多问题。我将分解要考虑的问题，并给出一些技巧，您可以利用这些技巧来提高工作效率并构建更好的web应用程序。</p><p id="2e4e" class="pw-post-body-paragraph lm ln iu lp b lq lr ke ls lt lu kh lv mj lx ly lz mk mb mc md ml mf mg mh mi in bi translated">下面我要告诉你的一切都来自我的个人经历和感受，以及我在IT领域十多年来所学到的东西。</p><p id="b906" class="pw-post-body-paragraph lm ln iu lp b lq lr ke ls lt lu kh lv mj lx ly lz mk mb mc md ml mf mg mh mi in bi translated">事不宜迟，我们开始吧。</p></div><div class="ab cl nc nd hy ne" role="separator"><span class="nf bw bk ng nh ni"/><span class="nf bw bk ng nh ni"/><span class="nf bw bk ng nh"/></div><div class="in io ip iq ir"><h1 id="f398" class="nj nk iu bd nl nm nn no np nq nr ns nt kj nu kk nv km nw kn nx kp ny kq nz oa bi translated">1.集装箱-呈递人模式</h1><p id="1f65" class="pw-post-body-paragraph lm ln iu lp b lq ob ke ls lt oc kh lv mj od ly lz mk oe mc md ml of mg mh mi in bi translated">随着项目的发展，您应该会发现越来越多的机会来增加特性和模块之间的代码重用。为了实现这个目标，您需要避免混合关注点，这不仅违反了软件开发的许多原则，而且使理解和维护您的源代码变得乏味。</p><p id="4763" class="pw-post-body-paragraph lm ln iu lp b lq lr ke ls lt lu kh lv mj lx ly lz mk mb mc md ml mf mg mh mi in bi translated">为了在现代基于组件的前端架构中应用这种方法，我们通过将组件组织成类别来阐明它们的职责。为此，我们使用容器-呈现者模式，将组件分为:</p><ul class=""><li id="a9e4" class="mm mn iu lp b lq lr lt lu mj mo mk mp ml mq mi mr ms mt mu bi translated"><strong class="lp je">容器组件:</strong>这些是智能组件。他们知道如何从服务中获取数据。它们使用输入和输出与其子组件(表示组件)进行通信。</li><li id="cf9f" class="mm mn iu lp b lq mv lt mw mj mx mk my ml mz mi mr ms mt mu bi translated"><strong class="lp je">表示组件:</strong>这些组件呈现用户界面并管理与用户的交互。您需要记住，表示组件不一定要被转储——也就是说，它们不能被注入任何服务。如果让它们总是转储，为了在容器和叶组件之间传递数据，组件树中会有大量重复的输入。</li></ul><p id="86ba" class="pw-post-body-paragraph lm ln iu lp b lq lr ke ls lt lu kh lv mj lx ly lz mk mb mc md ml mf mg mh mi in bi translated">在我们的ERP中，在每个模块中，我们都有一个主展示者在容器和叶组件之间扮演桥梁的角色。它将许多输入/输出传递给它的子节点，而不在自己的逻辑中使用它们。随着时间的推移，输入和输出的数量以一种难以理解的方式增加；这就是所谓的<em class="lo">冒泡事件。</em></p><p id="5357" class="pw-post-body-paragraph lm ln iu lp b lq lr ke ls lt lu kh lv mj lx ly lz mk mb mc md ml mf mg mh mi in bi translated">在将服务深入注入组件树并使一些表示性的叶子组件变得智能之后，我缓解了冒泡事件的问题，并使代码设计更易于维护。冒泡事件问题在你的应用程序中有多痛苦取决于你的组件树有多大和多深。</p></div><div class="ab cl nc nd hy ne" role="separator"><span class="nf bw bk ng nh ni"/><span class="nf bw bk ng nh ni"/><span class="nf bw bk ng nh"/></div><div class="in io ip iq ir"><h1 id="ec51" class="nj nk iu bd nl nm nn no np nq nr ns nt kj nu kk nv km nw kn nx kp ny kq nz oa bi translated">2.亲子设计</h1><p id="ce6e" class="pw-post-body-paragraph lm ln iu lp b lq ob ke ls lt oc kh lv mj od ly lz mk oe mc md ml of mg mh mi in bi translated">如果您有许多遵循类似代码设计的组件，您会注意到重复的输入、输出和方法。为了摆脱这种样板代码，我利用组件继承来外部化父类中的共享逻辑。遵循这种方法后，大量的代码重复被删除。</p><p id="7ae9" class="pw-post-body-paragraph lm ln iu lp b lq lr ke ls lt lu kh lv mj lx ly lz mk mb mc md ml mf mg mh mi in bi translated">通过使用父子设计，您可以减少在执行重复性任务时出现的许多人为错误。</p><p id="7561" class="pw-post-body-paragraph lm ln iu lp b lq lr ke ls lt lu kh lv mj lx ly lz mk mb mc md ml mf mg mh mi in bi translated">但是在应用这个技巧之前，您可能需要使用通用名称，如下一点所述。</p></div><div class="ab cl nc nd hy ne" role="separator"><span class="nf bw bk ng nh ni"/><span class="nf bw bk ng nh ni"/><span class="nf bw bk ng nh"/></div><div class="in io ip iq ir"><h1 id="60ca" class="nj nk iu bd nl nm nn no np nq nr ns nt kj nu kk nv km nw kn nx kp ny kq nz oa bi translated">3.通用命名</h1><p id="0f64" class="pw-post-body-paragraph lm ln iu lp b lq ob ke ls lt oc kh lv mj od ly lz mk oe mc md ml of mg mh mi in bi translated">在不同的组件中使用<code class="fe og oh oi oj b">dataList</code>作为变量名，而不是使用<code class="fe og oh oi oj b">invoiceList</code>和<code class="fe og oh oi oj b">stockList</code>，这有助于您看到代码设计中的模式，并使您能够将样板代码提取到父类或助手类中。</p></div><div class="ab cl nc nd hy ne" role="separator"><span class="nf bw bk ng nh ni"/><span class="nf bw bk ng nh ni"/><span class="nf bw bk ng nh"/></div><div class="in io ip iq ir"><h1 id="5981" class="nj nk iu bd nl nm nn no np nq nr ns nt kj nu kk nv km nw kn nx kp ny kq nz oa bi translated">4.共享包装组件</h1><p id="e235" class="pw-post-body-paragraph lm ln iu lp b lq ob ke ls lt oc kh lv mj od ly lz mk oe mc md ml of mg mh mi in bi translated">共享包装组件是一个表示性组件，用于多个模块(或组件)。它有助于维护、未来的重构，或者可能迁移到不同的库——比如从Kendo迁移到AG Grid。</p><p id="30ae" class="pw-post-body-paragraph lm ln iu lp b lq lr ke ls lt lu kh lv mj lx ly lz mk mb mc md ml mf mg mh mi in bi translated">共享包装器组件(例如，呈现搜索框的组件)的主要好处是，您可以在一个地方(在包装器中)更改搜索行为，结果将在使用它的每个模块中复制。假设您想要<code class="fe og oh oi oj b">debounce</code>搜索查询并消除连续的重复条目。在一个可重用的演示者中，这个变更请求很容易完成，如下面的清单所示:</p><figure class="kt ku kv kw gu kx"><div class="bz fq l di"><div class="ok ol l"/></div><p class="le lf gk gi gj lg lh bd b be z dk translated">使用去抖动、不同搜索查询的搜索演示者(<a class="ae li" href="https://indepth.dev/posts/1201/presenters-with-angular" rel="noopener ugc nofollow" target="_blank">源</a></p></figure><p id="4c8c" class="pw-post-body-paragraph lm ln iu lp b lq lr ke ls lt lu kh lv mj lx ly lz mk mb mc md ml mf mg mh mi in bi translated">共享包装器的另一个例子是由多个组件组成的复杂数据表UI。每个行或单元格组件可以拥有一个或多个表示器来处理UI行为、本地UI状态、验证和格式化。</p><p id="d054" class="pw-post-body-paragraph lm ln iu lp b lq lr ke ls lt lu kh lv mj lx ly lz mk mb mc md ml mf mg mh mi in bi translated">在我们的ERP中，我们使用了<code class="fe og oh oi oj b">Kendo</code>来实现不同类型的网格:</p><ul class=""><li id="79c9" class="mm mn iu lp b lq lr lt lu mj mo mk mp ml mq mi mr ms mt mu bi translated">每行保存一个内嵌编辑网格，</li><li id="314f" class="mm mn iu lp b lq mv lt mw mj mx mk my ml mz mi mr ms mt mu bi translated">一批网格，</li><li id="07f1" class="mm mn iu lp b lq mv lt mw mj mx mk my ml mz mi mr ms mt mu bi translated">不可编辑的网格，</li><li id="beab" class="mm mn iu lp b lq mv lt mw mj mx mk my ml mz mi mr ms mt mu bi translated">等等。</li></ul><p id="3b1a" class="pw-post-body-paragraph lm ln iu lp b lq lr ke ls lt lu kh lv mj lx ly lz mk mb mc md ml mf mg mh mi in bi translated">这些网格中的每一种都在许多模块中使用。通过在包装器组件— <code class="fe og oh oi oj b">batch-grid</code>和<code class="fe og oh oi oj b">edit-grid</code>中实现共享逻辑，我去除了大量的样板代码。我注意到，每当我们需要添加一个新特性时，比如说添加到<code class="fe og oh oi oj b">edit-grid</code>中，只在一个地方(共享包装器)添加比在n个组件中添加n次要容易得多。</p><p id="ecd8" class="pw-post-body-paragraph lm ln iu lp b lq lr ke ls lt lu kh lv mj lx ly lz mk mb mc md ml mf mg mh mi in bi translated">如果我们计划将来从<code class="fe og oh oi oj b">Kendo</code>切换到<code class="fe og oh oi oj b">PrimeNG</code>或另一个库，我们需要做的只是改变包装器组件中的实现，而不是使用该库中的网格来改变每个模块中的实现。</p><p id="bbf5" class="pw-post-body-paragraph lm ln iu lp b lq lr ke ls lt lu kh lv mj lx ly lz mk mb mc md ml mf mg mh mi in bi translated">下面是我们的一个组件<code class="fe og oh oi oj b">account-receipt</code>使用一个共享包装器<code class="fe og oh oi oj b">edit-grid</code>来呈现一个<a class="ae li" href="https://javascript.plainenglish.io/angular-material-table-with-edit-function-like-excel-7c2c53332553" rel="noopener ugc nofollow" target="_blank">内联可编辑网格</a>:</p><figure class="kt ku kv kw gu kx"><div class="bz fq l di"><div class="ok ol l"/></div><p class="le lf gk gi gj lg lh bd b be z dk translated">帐户接收模块中使用的剑道网格包装组件</p></figure><p id="7d04" class="pw-post-body-paragraph lm ln iu lp b lq lr ke ls lt lu kh lv mj lx ly lz mk mb mc md ml mf mg mh mi in bi translated">这是包装组件的模板。如您所见，它调用剑道网格<code class="fe og oh oi oj b">kendo-edit-grid</code>，但是<code class="fe og oh oi oj b">account-receipt</code>组件看不到这种依赖性:</p><figure class="kt ku kv kw gu kx"><div class="bz fq l di"><div class="ok ol l"/></div><p class="le lf gk gi gj lg lh bd b be z dk translated">剑道网格的角包装组件:kendo-edit-grid.component.html</p></figure></div><div class="ab cl nc nd hy ne" role="separator"><span class="nf bw bk ng nh ni"/><span class="nf bw bk ng nh ni"/><span class="nf bw bk ng nh"/></div><div class="in io ip iq ir"><h1 id="2e84" class="nj nk iu bd nl nm nn no np nq nr ns nt kj nu kk nv km nw kn nx kp ny kq nz oa bi translated">5.可观察的数据服务(商店服务)</h1><p id="a47e" class="pw-post-body-paragraph lm ln iu lp b lq ob ke ls lt oc kh lv mj od ly lz mk oe mc md ml of mg mh mi in bi translated">为了保持组件的责任集中并保持关注点的分离，我们创建了<code class="fe og oh oi oj b">Services</code>来处理数据请求。但是服务可以做的不仅仅是与API通信；他们可以在现代网络应用中扮演商店的角色。</p><p id="81e6" class="pw-post-body-paragraph lm ln iu lp b lq lr ke ls lt lu kh lv mj lx ly lz mk mb mc md ml mf mg mh mi in bi translated">在许多情况下，通过避免引入Redux、NgRx或NgXs来管理应用程序状态，可以降低代码的复杂性。相反，你实现基于<code class="fe og oh oi oj b">BehaviorSubject</code>的服务——也称为<a class="ae li" href="https://levelup.gitconnected.com/promise-vs-observable-vs-stream-165a310e886f" rel="noopener ugc nofollow" target="_blank">可观察的</a>数据服务或存储服务——来做同样的工作。</p><p id="8c8e" class="pw-post-body-paragraph lm ln iu lp b lq lr ke ls lt lu kh lv mj lx ly lz mk mb mc md ml mf mg mh mi in bi translated">在ERP的每个模块中，我们都有两种基本服务:</p><ul class=""><li id="6a60" class="mm mn iu lp b lq lr lt lu mj mo mk mp ml mq mi mr ms mt mu bi translated">一个扩展<code class="fe og oh oi oj b">BaseHttpService&lt;T&gt;</code>的HTTP服务，包含调用REST API的方法。</li><li id="68d2" class="mm mn iu lp b lq mv lt mw mj mx mk my ml mz mi mr ms mt mu bi translated">Store服务扩展了<code class="fe og oh oi oj b">BaseStoreService&lt;T&gt;</code>，它有<code class="fe og oh oi oj b">BehaviorSubject</code>变量和方法调用HTTP服务(注入其中)。</li></ul><figure class="kt ku kv kw gu kx"><div class="bz fq l di"><div class="ok ol l"/></div><p class="le lf gk gi gj lg lh bd b be z dk translated">RxJs行为主体</p></figure><p id="0fec" class="pw-post-body-paragraph lm ln iu lp b lq lr ke ls lt lu kh lv mj lx ly lz mk mb mc md ml mf mg mh mi in bi translated">您可以将存储服务视为提供RxJs功能操作符的传统事件总线。您可以用<code class="fe og oh oi oj b">subscribe()</code>方法订阅它，它通过<code class="fe og oh oi oj b">next()</code>方法向订阅者发出新值。</p><figure class="kt ku kv kw gu kx"><div class="bz fq l di"><div class="ok ol l"/></div><p class="le lf gk gi gj lg lh bd b be z dk translated">订阅并释放新的价值</p></figure></div><div class="ab cl nc nd hy ne" role="separator"><span class="nf bw bk ng nh ni"/><span class="nf bw bk ng nh ni"/><span class="nf bw bk ng nh"/></div><div class="in io ip iq ir"><h1 id="c2b4" class="nj nk iu bd nl nm nn no np nq nr ns nt kj nu kk nv km nw kn nx kp ny kq nz oa bi translated">6.复试</h1><p id="2a4e" class="pw-post-body-paragraph lm ln iu lp b lq ob ke ls lt oc kh lv mj od ly lz mk oe mc md ml of mg mh mi in bi translated">JavaScript 中的回调是作为参数传递给另一个函数的函数。在我们的ERP中，我使用这种技术在用户与UI交互之后执行一些验证或一些逻辑。示例:</p><ul class=""><li id="ba20" class="mm mn iu lp b lq lr lt lu mj mo mk mp ml mq mi mr ms mt mu bi translated">如果库存代码发生变化，则应更新在不同栏中用作下拉选项的单位列表。</li><li id="ca22" class="mm mn iu lp b lq mv lt mw mj mx mk my ml mz mi mr ms mt mu bi translated">如果货币类型发生变化，则必须调整“汇率”列中的值。</li></ul><p id="b98b" class="pw-post-body-paragraph lm ln iu lp b lq lr ke ls lt lu kh lv mj lx ly lz mk mb mc md ml mf mg mh mi in bi translated">项目中有动态表单，网格的实现独立于列列表。这就是为什么我在配置对象中传递回调函数——使用动态表单或动态网格为每个组件定义特定列或表单字段的数组。</p><p id="5fc8" class="pw-post-body-paragraph lm ln iu lp b lq lr ke ls lt lu kh lv mj lx ly lz mk mb mc md ml mf mg mh mi in bi translated">下面是两个使用回调的例子。第一次监听显示了两个回调函数，<code class="fe og oh oi oj b">onApCodeChanged</code>和<code class="fe og oh oi oj b">onCreditChanged</code>，它们在定义列列表的数组中传递:</p><figure class="kt ku kv kw gu kx"><div class="bz fq l di"><div class="ok ol l"/></div><p class="le lf gk gi gj lg lh bd b be z dk translated">动态可编辑网格的列定义</p></figure><p id="254b" class="pw-post-body-paragraph lm ln iu lp b lq lr ke ls lt lu kh lv mj lx ly lz mk mb mc md ml mf mg mh mi in bi translated">该列表<code class="fe og oh oi oj b">displayColumnsDefs</code>作为输入传送到可编辑网格<code class="fe og oh oi oj b">edit-grid</code>:</p><figure class="kt ku kv kw gu kx"><div class="bz fq l di"><div class="ok ol l"/></div><p class="le lf gk gi gj lg lh bd b be z dk translated">角度内嵌可编辑网格</p></figure><p id="9c3a" class="pw-post-body-paragraph lm ln iu lp b lq lr ke ls lt lu kh lv mj lx ly lz mk mb mc md ml mf mg mh mi in bi translated">第二个例子展示了回调，比如<code class="fe og oh oi oj b">descrContainsChange</code>，它出现在动态表单的字段定义中:</p><figure class="kt ku kv kw gu kx"><div class="bz fq l di"><div class="ok ol l"/></div><p class="le lf gk gi gj lg lh bd b be z dk translated"><a class="ae li" href="https://gist.github.com/rakia/27b6c7ac8523da1ab60cfec8a1ca0378#file-form-field-value-change-callback-component-ts" rel="noopener ugc nofollow" target="_blank">表单-字段-值-变更-回调. component.ts </a>:</p></figure><p id="0f8d" class="pw-post-body-paragraph lm ln iu lp b lq lr ke ls lt lu kh lv mj lx ly lz mk mb mc md ml mf mg mh mi in bi translated">这些回调函数已经工作了一段时间，但是我们在通过添加像<code class="fe og oh oi oj b">this.stockService.getUnits(currencyType)</code>这样的指令来更新它们的实现之后，面临了一个挑战。你能猜出是什么问题吗？</p><p id="c847" class="pw-post-body-paragraph lm ln iu lp b lq lr ke ls lt lu kh lv mj lx ly lz mk mb mc md ml mf mg mh mi in bi translated">没错，回调函数被绑定到了错误的范围，导致了一个错误，说在定义列或表单字段的数组或JSON对象中没有名为<code class="fe og oh oi oj b">stockService</code>的变量。</p><p id="19e0" class="pw-post-body-paragraph lm ln iu lp b lq lr ke ls lt lu kh lv mj lx ly lz mk mb mc md ml mf mg mh mi in bi translated">解决方案是在将回调添加到我们的配置对象之前，使用<code class="fe og oh oi oj b">bind(this)</code>将它们绑定到正确的作用域<code class="fe og oh oi oj b">this</code>，如下面的清单所示:</p><figure class="kt ku kv kw gu kx"><div class="bz fq l di"><div class="ok ol l"/></div><p class="le lf gk gi gj lg lh bd b be z dk translated"><a class="ae li" href="https://gist.github.com/rakia/126f4633c55ae9223dd4eeeba619d751#file-column-value-change-callback-component-ts" rel="noopener ugc nofollow" target="_blank">column-value-change-callback . component . ts</a></p></figure></div><div class="ab cl nc nd hy ne" role="separator"><span class="nf bw bk ng nh ni"/><span class="nf bw bk ng nh ni"/><span class="nf bw bk ng nh"/></div><div class="in io ip iq ir"><h1 id="3e23" class="nj nk iu bd nl nm nn no np nq nr ns nt kj nu kk nv km nw kn nx kp ny kq nz oa bi translated">7.性能监控</h1><p id="fbbe" class="pw-post-body-paragraph lm ln iu lp b lq ob ke ls lt oc kh lv mj od ly lz mk oe mc md ml of mg mh mi in bi translated">当您向项目中添加新功能时，它的工作方式可能会改变，您可能会面临倒退，或者用户意识到在某个时候，UI会变得更慢、迟缓，并且可能会非常频繁地暂停。</p><p id="58f9" class="pw-post-body-paragraph lm ln iu lp b lq lr ke ls lt lu kh lv mj lx ly lz mk mb mc md ml mf mg mh mi in bi translated">这就是为什么你必须关注<a class="ae li" rel="noopener ugc nofollow" target="_blank" href="/angular-onpush-change-detection-f629cbce0bfa">性能</a>，它可能会杀死你的应用程序！</p><h2 id="9dbb" class="om nk iu bd nl on oo dn np op oq dp nt mj or os nv mk ot ou nx ml ov ow nz ja bi translated">Webpack捆绑包分析器</h2><p id="39c3" class="pw-post-body-paragraph lm ln iu lp b lq ob ke ls lt oc kh lv mj od ly lz mk oe mc md ml of mg mh mi in bi translated">您可以通过将它添加到您的<code class="fe og oh oi oj b">package.json</code>中来利用像<code class="fe og oh oi oj b">webpack-bundle-analyzer</code>这样的工具。它允许您分析您的应用程序包和依赖项的大小:</p><figure class="kt ku kv kw gu kx"><div class="bz fq l di"><div class="ok ol l"/></div><p class="le lf gk gi gj lg lh bd b be z dk translated">package.json中的webpack-bundle-analyzer</p></figure><figure class="kt ku kv kw gu kx gi gj paragraph-image"><div role="button" tabindex="0" class="ky kz di la bf lb"><div class="gi gj ox"><img src="../Images/7b433763b272ae87805e0b05577cbcac.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ykm5CqYwTr1ivTOkET68_Q.png"/></div></div><p class="le lf gk gi gj lg lh bd b be z dk translated">Angular企业应用程序的Webpack捆绑包分析器</p></figure><h2 id="f36e" class="om nk iu bd nl on oo dn np op oq dp nt mj or os nv mk ot ou nx ml ov ow nz ja bi translated">Chrome开发工具</h2><p id="0caf" class="pw-post-body-paragraph lm ln iu lp b lq ob ke ls lt oc kh lv mj od ly lz mk oe mc md ml of mg mh mi in bi translated">别忘了用Chrome DevTools监控你的表现:</p><ul class=""><li id="5428" class="mm mn iu lp b lq lr lt lu mj mo mk mp ml mq mi mr ms mt mu bi translated">您可以拍摄堆快照，向您展示内存是如何在我们的应用程序的<a class="ae li" rel="noopener ugc nofollow" target="_blank" href="/typescript-new-release-19f1238c6a68"> JavaScript </a>对象、原语、字符串、函数、DOM节点等之间分配的。</li><li id="67ac" class="mm mn iu lp b lq mv lt mw mj mx mk my ml mz mi mr ms mt mu bi translated">您可以使用“内存”面板来识别JavaScript堆内存泄漏。</li><li id="782c" class="mm mn iu lp b lq mv lt mw mj mx mk my ml mz mi mr ms mt mu bi translated">性能时间线记录向您展示了在用户交互之后，JS堆大小、节点大小和侦听器大小将如何随时间变化。当您的应用程序无法清除未使用的资源时，就会发生内存泄漏。频繁上升和下降的JS堆或节点计数图是潜在垃圾收集问题的征兆。</li></ul><figure class="kt ku kv kw gu kx gi gj paragraph-image"><div role="button" tabindex="0" class="ky kz di la bf lb"><div class="gi gj oy"><img src="../Images/eb4ddbdde5de9296a7030c2fb32b543d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*by0Ek3CiQoFDeSM5z3K5Wg.gif"/></div></div><p class="le lf gk gi gj lg lh bd b be z dk translated"><a class="ae li" rel="noopener ugc nofollow" target="_blank" href="/build-me-an-angular-app-with-memory-leaks-please-36302184e658">性能时间线记录</a>:内存泄漏修复前后(动画由<a class="ae li" href="https://rakia-bensassi.medium.com/" rel="noopener">作者</a>制作)</p></figure><p id="a7da" class="pw-post-body-paragraph lm ln iu lp b lq lr ke ls lt lu kh lv mj lx ly lz mk mb mc md ml mf mg mh mi in bi translated">在“<a class="ae li" rel="noopener ugc nofollow" target="_blank" href="/build-me-an-angular-app-with-memory-leaks-please-36302184e658">如何使用Chrome DevTools </a>创建并修复内存泄漏”一文中，有更多的细节和指南，关于如何使用DevTools并理解它生成的图表、统计数据和指标。</p></div><div class="ab cl nc nd hy ne" role="separator"><span class="nf bw bk ng nh ni"/><span class="nf bw bk ng nh ni"/><span class="nf bw bk ng nh"/></div><div class="in io ip iq ir"><h1 id="d4e4" class="nj nk iu bd nl nm nn no np nq nr ns nt kj nu kk nv km nw kn nx kp ny kq nz oa bi translated">8.重构</h1><p id="d388" class="pw-post-body-paragraph lm ln iu lp b lq ob ke ls lt oc kh lv mj od ly lz mk oe mc md ml of mg mh mi in bi translated">管理动态业务需求之间的平衡和保持技术部门最小化可能是我们作为开发人员面临的最大挑战。</p><p id="50a2" class="pw-post-body-paragraph lm ln iu lp b lq lr ke ls lt lu kh lv mj lx ly lz mk mb mc md ml mf mg mh mi in bi translated">为了实现这个目标，我们需要让重构成为一个持续的基本活动，这属于我们的编程文化，以保持干净的代码和干净的设计。</p><p id="af93" class="pw-post-body-paragraph lm ln iu lp b lq lr ke ls lt lu kh lv mj lx ly lz mk mb mc md ml mf mg mh mi in bi translated">我完全同意Steven A. Lowe的观点，他将重构描述为从编码经验中学习的机会。我喜欢他的文章“你犯敏捷错误的15个迹象”中的以下摘录:</p><blockquote class="lj lk ll"><p id="e4ed" class="lm ln lo lp b lq lr ke ls lt lu kh lv lw lx ly lz ma mb mc md me mf mg mh mi in bi translated">“重构不仅有助于提高代码的机械质量；它也帮助你从你的代码中学习。当重构时，你会收敛于更好的模型。现在，你的代码可以工作，但是可能感觉紧张，甚至有点脆弱。重构揭示了隐含的模型，它通知你对领域的理解。在红绿重构的测试驱动开发周期中，“重构”不是可有可无的，以免你积累技术债务，无法从编码经验中吸取教训。”</p></blockquote></div><div class="ab cl nc nd hy ne" role="separator"><span class="nf bw bk ng nh ni"/><span class="nf bw bk ng nh ni"/><span class="nf bw bk ng nh"/></div><div class="in io ip iq ir"><h1 id="f417" class="nj nk iu bd nl nm nn no np nq nr ns nt kj nu kk nv km nw kn nx kp ny kq nz oa bi translated">9.进化建筑</h1><blockquote class="lj lk ll"><p id="4e18" class="lm ln lo lp b lq lr ke ls lt lu kh lv lw lx ly lz ma mb mc md me mf mg mh mi in bi translated">“前端架构从来都不是一个“设置好就一劳永逸”的命题。没有任何设计或计划是完美或完整的。客户的需求(以及开发人员的需求)将随着时间的推移而改变和发展，在项目的某个阶段工作良好的过程可能需要在以后重新访问，以提高效率或减少错误。</p><p id="62a2" class="lm ln lo lp b lq lr ke ls lt lu kh lv lw lx ly lz ma mb mc md me mf mg mh mi in bi translated">前端架构师的一个关键才能是不断进行调整的能力。"</p><p id="f6ba" class="lm ln lo lp b lq lr ke ls lt lu kh lv lw lx ly lz ma mb mc md me mf mg mh mi in bi translated">— <a class="ae li" href="https://www.oreilly.com/library/view/frontend-architecture-for/9781491926772/ch01.html" rel="noopener ugc nofollow" target="_blank">设计系统的前端架构</a></p></blockquote><p id="c65d" class="pw-post-body-paragraph lm ln iu lp b lq lr ke ls lt lu kh lv mj lx ly lz mk mb mc md ml mf mg mh mi in bi translated">作为软件架构师，我们需要意识到这样一个事实，即最好的结果来自于<a class="ae li" href="https://medium.com/swlh/characteristics-of-successful-team-60272e59a2c6" rel="noopener">与团队</a>的合作，并且设计必须与开发过程同步调整。</p><p id="2fe2" class="pw-post-body-paragraph lm ln iu lp b lq lr ke ls lt lu kh lv mj lx ly lz mk mb mc md ml mf mg mh mi in bi translated">在开发人员开始使用您建立的代码结构后，从他们那里收集反馈可以让您从不同的角度来看您的设计，并注意到您可以优化哪些内容来支持不断的变化。</p></div><div class="ab cl nc nd hy ne" role="separator"><span class="nf bw bk ng nh ni"/><span class="nf bw bk ng nh ni"/><span class="nf bw bk ng nh"/></div><div class="in io ip iq ir"><h1 id="b0b4" class="nj nk iu bd nl nm nn no np nq nr ns nt kj nu kk nv km nw kn nx kp ny kq nz oa bi translated">10.团队反馈</h1><blockquote class="oz"><p id="031c" class="pa pb iu bd pc pd pe pf pg ph pi mi dk translated">“前端开发人员的受众是最终用户，而前端架构师的受众是开发人员本身。”</p><p id="a9d4" class="pa pb iu bd pc pd pe pf pg ph pi mi dk translated">— <a class="ae li" href="https://www.oreilly.com/library/view/frontend-architecture-for/9781491926772/ch01.html" rel="noopener ugc nofollow" target="_blank">设计系统的前端架构</a></p></blockquote><p id="f4af" class="pw-post-body-paragraph lm ln iu lp b lq pj ke ls lt pk kh lv mj pl ly lz mk pm mc md ml pn mg mh mi in bi translated">在我们的项目中成为一名前端架构师并不意味着我会成为一名经理，再也不用写一行代码。作为一名架构师，我编写了更多的代码，不仅是为了实现所要求的业务特性，也是为了响应我的新受众——我的开发团队——的需求。</p><p id="464a" class="pw-post-body-paragraph lm ln iu lp b lq lr ke ls lt lu kh lv mj lx ly lz mk mb mc md ml mf mg mh mi in bi translated">实现一个企业应用程序通常意味着大量具有不同技术技能的人将参与开发过程。了解团队成员的背景有助于选择适当的技术、架构模式和代码设计的复杂性。</p><p id="8f2d" class="pw-post-body-paragraph lm ln iu lp b lq lr ke ls lt lu kh lv mj lx ly lz mk mb mc md ml mf mg mh mi in bi translated">在我们ERP的开发周期中，我们开发了<a class="ae li" rel="noopener ugc nofollow" target="_blank" href="/angular-library-dynamic-stepper-2ba05ab40228">新的需求</a>和一个具有不同技术背景的成长团队——从初级和高级开发人员开始他们的Angular之旅，到<a class="ae li" rel="noopener ugc nofollow" target="_blank" href="/angular-10-new-features-dbc779061dc8"> Angular </a>专家。我们的主要目标之一是提供最低的代码复杂度，并支持我们的团队成员沿着他们的学习曲线前进。出于这个原因，我避免使用<code class="fe og oh oi oj b">monorepo</code>，而是使用<code class="fe og oh oi oj b">BehaviorSubject</code>商店服务，而不是<code class="fe og oh oi oj b">Ngxs</code>或<code class="fe og oh oi oj b">Ngrx</code>。</p><p id="6ea4" class="pw-post-body-paragraph lm ln iu lp b lq lr ke ls lt lu kh lv mj lx ly lz mk mb mc md ml mf mg mh mi in bi translated">我还记得很多年前我在一家有很多scrum团队的公司的另一次经历。当时，我被要求实现一个ETL应用程序，该应用程序应该与吉拉REST API通信以从中提取数据。该应用程序的最终用户是公司的会计人员，但现有团队中的开发人员是在我完成工作后负责维护的人。因为我有很好的spring框架知识，所以我很高兴在实现中使用它。但是我们的技术领导让我用Java Jwt来做，因为他的所有团队都在用Java和EJB工作，他们没有spring框架背景。</p><p id="da75" class="pw-post-body-paragraph lm ln iu lp b lq lr ke ls lt lu kh lv mj lx ly lz mk mb mc md ml mf mg mh mi in bi translated">因此，了解你的团队，听取他们的意见，并对他们的反馈做出反应！</p></div><div class="ab cl nc nd hy ne" role="separator"><span class="nf bw bk ng nh ni"/><span class="nf bw bk ng nh ni"/><span class="nf bw bk ng nh"/></div><div class="in io ip iq ir"><h1 id="cb88" class="nj nk iu bd nl nm nn no np nq nr ns nt kj nu kk nv km nw kn nx kp ny kq nz oa bi translated">外卖食品</h1><p id="b91c" class="pw-post-body-paragraph lm ln iu lp b lq ob ke ls lt oc kh lv mj od ly lz mk oe mc md ml of mg mh mi in bi translated">作为前端架构师，你做前端开发和前端工程工作。您通过选择最佳设计模式来设计技术解决方案，以解决业务和客户的挑战。</p><p id="c12f" class="pw-post-body-paragraph lm ln iu lp b lq lr ke ls lt lu kh lv mj lx ly lz mk mb mc md ml mf mg mh mi in bi translated">作为架构师，您的角色还包括评估您的沟通和协作能力，以及您在人员、软件性能和开发时间方面最大化资源的技能。</p><p id="dbe0" class="pw-post-body-paragraph lm ln iu lp b lq lr ke ls lt lu kh lv mj lx ly lz mk mb mc md ml mf mg mh mi in bi translated">感谢你阅读这篇文章。希望你能得到一些见解，对你自己的旅程有所帮助。</p></div><div class="ab cl nc nd hy ne" role="separator"><span class="nf bw bk ng nh ni"/><span class="nf bw bk ng nh ni"/><span class="nf bw bk ng nh"/></div><div class="in io ip iq ir"><p id="c562" class="pw-post-body-paragraph lm ln iu lp b lq lr ke ls lt lu kh lv mj lx ly lz mk mb mc md ml mf mg mh mi in bi translated">🧠💡我为一群聪明、好奇的人写关于工程、技术和领导力的文章。<a class="ae li" href="https://rakiabensassi.substack.com/" rel="noopener ugc nofollow" target="_blank"> <strong class="lp je">加入我的免费电子邮件简讯独家访问</strong> </a> <strong class="lp je"> </strong>或在此注册媒体<a class="ae li" href="https://rakiabensassi.medium.com/membership" rel="noopener"/>。</p><p id="a62b" class="pw-post-body-paragraph lm ln iu lp b lq lr ke ls lt lu kh lv mj lx ly lz mk mb mc md ml mf mg mh mi in bi translated"><em class="lo">你可以在Udemy上查看我的</em> <strong class="lp je"> <em class="lo">视频课程</em></strong><em class="lo">:</em><a class="ae li" href="https://www.udemy.com/course/identify-and-fix-javascript-memory-leaks/" rel="noopener ugc nofollow" target="_blank"><em class="lo">如何识别、诊断、修复Web Apps中的内存泄漏</em> </a> <em class="lo">。</em></p></div></div>    
</body>
</html>