<html>
<head>
<title>Sticky HTML Elements Done the Right Way</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">用正确的方法制作粘性HTML元素</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/sticky-done-the-right-way-880af0122a71?source=collection_archive---------5-----------------------#2020-12-22">https://betterprogramming.pub/sticky-done-the-right-way-880af0122a71?source=collection_archive---------5-----------------------#2020-12-22</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="73c1" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">创建滚动时保持不变的元素的最佳实践</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/b98710d036353f7d3200298b48b5ee01.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*u0xG8Fj66PhnSC0J"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">由<a class="ae ky" href="https://unsplash.com/@kellysikkema?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Kelly Sikkema </a>在<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</p></figure><p id="cad1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如今，当滚动经过一个重要元素时，有一个非常常见的模式，我们希望用户一直留在那里:<strong class="lb iu">使它保持不变</strong>。CSS中内置了一个现成的解决方案，即<code class="fe lv lw lx ly b">position: sticky</code>和<code class="fe lv lw lx ly b">position: -webkit-sticky</code>。为了让这个属性工作，它需要更多关于如何行为的信息，这就是<code class="fe lv lw lx ly b">bottom</code>、<code class="fe lv lw lx ly b">top</code>、<code class="fe lv lw lx ly b">left</code>和<code class="fe lv lw lx ly b">right</code>发挥作用的地方。没有这些额外的信息，<code class="fe lv lw lx ly b">position: sticky</code>不会做任何事情，因为它缺少关键的信息；会像<code class="fe lv lw lx ly b">position: relative</code>一样对待。如果你曾经尝试过，但它对你不起作用，那可能就是原因。</p><p id="775c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">假设这是一条快乐的路径，你可以用几行CSS代码实现粘性效果，如下例所示:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="lz ma l"/></div></figure><p id="dd5c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">作为回报，您将得到如下内容。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi mb"><img src="../Images/c3b8167f917db98ca111a522e9528b8c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*ehBFxoloM-5XNHTy1rZDRg.gif"/></div></div></figure><p id="7d8e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这是非常甜蜜的，文章可能会在这里结束。但是不支持这个的浏览器会怎么样呢？你可以看到这个特性得到了很大的支持，但是仍然有一些浏览器落后了。对于浏览器支持，<a class="ae ky" href="https://caniuse.com" rel="noopener ugc nofollow" target="_blank">caniuse.com</a>永远是我们最好的朋友:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi mc"><img src="../Images/06facbaefacbdc69cd059a114b39d469.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*zinGZQgVAF2sNac2ypJMyQ.png"/></div></div></figure><p id="f853" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">幸运的是，我们有一个工具可以随时检查浏览器是否支持一些CSS属性。<code class="fe lv lw lx ly b">Css.supports</code>方法返回一个<code class="fe lv lw lx ly b">Boolean</code>值，指示浏览器是否支持给定的CSS特性。这是一个非常有趣的API，你可以<a class="ae ky" href="https://developer.mozilla.org/en-US/docs/Web/CSS/@supports" rel="noopener ugc nofollow" target="_blank">查看</a>的更多细节。</p><p id="8495" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">对于我们的用例，我们想要检查的是:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="lz ma l"/></div></figure><p id="c48d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">因此，下一个问题是，将这一功能添加到这些旧式浏览器中的最有效方式是什么。事情从这里开始变得非常有趣。让我们深入探讨一下最佳解决方案。</p></div><div class="ab cl md me hx mf" role="separator"><span class="mg bw bk mh mi mj"/><span class="mg bw bk mh mi mj"/><span class="mg bw bk mh mi"/></div><div class="im in io ip iq"><h1 id="f645" class="mk ml it bd mm mn mo mp mq mr ms mt mu jz mv ka mw kc mx kd my kf mz kg na nb bi translated">最常见的方法</h1><p id="41de" class="pw-post-body-paragraph kz la it lb b lc nc ju le lf nd jx lh li ne lk ll lm nf lo lp lq ng ls lt lu im bi translated">没有我们的CSS超能力，我们只能在JavaScript领域想出一个解决方案。需要做的是:</p><ol class=""><li id="c3b9" class="nh ni it lb b lc ld lf lg li nj lm nk lq nl lu nm nn no np bi translated">检查滚动是否经过那个div。</li><li id="940b" class="nh ni it lb b lc nq lf nr li ns lm nt lq nu lu nm nn no np bi translated">如果是，将位置从<code class="fe lv lw lx ly b">static</code>更改为<code class="fe lv lw lx ly b">fixed</code>。</li><li id="3d52" class="nh ni it lb b lc nq lf nr li ns lm nt lq nu lu nm nn no np bi translated">如果用户确实从该div向上滚动，只需再次将位置从<code class="fe lv lw lx ly b">absolute</code>更改为<code class="fe lv lw lx ly b">static</code>。</li></ol><p id="de16" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">你可以看到方法非常简单。然而，有一个问题:你需要不断地监视浏览器上发生了什么，并对其做出反应。监控浏览器活动最常见的方法是<code class="fe lv lw lx ly b">onScroll</code>或<code class="fe lv lw lx ly b">requestAnimationFrame</code>。我们将检查两者，包括它们的缺点。</p><p id="f531" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们将从<code class="fe lv lw lx ly b">onScroll</code>方法开始。您可以在这里看到一个实现示例:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="lz ma l"/></div></figure><p id="655a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">请注意，当用户滚动并根据窗口滚动偏移量检查位置时，我们会不断触发事件。大概99%的事件对我们没有任何用处。</p><p id="08a0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如前所述，另一种方法是使用<code class="fe lv lw lx ly b">requestAnimationFrame</code>。我们要做的不是检查每个事件滚动，而是检查每一帧的元素是否应该是粘性的。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="lz ma l"/></div></figure><p id="65dd" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">您可以看到，这种方法使用了与以前几乎相同的代码，但是依赖于不同的触发器。<code class="fe lv lw lx ly b">requestAnimationFrame</code>触发器仅适用于非常特殊的用例及动画。您可以看到，现在触发的事件数量比以前更多了。这将保证您不会在同一个帧中触发两个事件，但这需要付出很高的代价。</p><p id="9b80" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">总结一下，我们已经知道这两个事件是非常愚蠢和昂贵的，它们导致了一个非常必要的实现:由我们来决定这个项目是否在屏幕上。应该有更好的方法来解决这个问题。</p></div><div class="ab cl md me hx mf" role="separator"><span class="mg bw bk mh mi mj"/><span class="mg bw bk mh mi mj"/><span class="mg bw bk mh mi"/></div><div class="im in io ip iq"><h1 id="7ae0" class="mk ml it bd mm mn mo mp mq mr ms mt mu jz mv ka mw kc mx kd my kf mz kg na nb bi translated">十字路口观察员前来救援</h1><p id="d7d0" class="pw-post-body-paragraph kz la it lb b lc nc ju le lf nd jx lh li ne lk ll lm nf lo lp lq ng ls lt lu im bi translated">不久前，<a class="ae ky" href="https://developer.mozilla.org/en-US/docs/Web/API/Intersection_Observer_API" rel="noopener ugc nofollow" target="_blank">路口观察者</a>功能发布。这个API使我们能够被动地观察元素并获取事件，或者查看这些元素何时在视口中可见或隐藏。</p><p id="9e82" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这对我们来说意味着我们可以放置一个元素，通过检查它是可见的还是隐藏的，我们将知道我们是否需要使我们的div具有粘性。这听起来更具宣示性，而不那么粗鲁。此外，我们将避免听到大量的事件和计算。完成所有繁重的工作后，我们可以专注于我们想要实现的功能，而将所有的计算留给浏览器。这听起来像一个可怕的交易。</p><p id="bb46" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们看看如何重写之前低效的代码，使之更具可读性。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="lz ma l"/></div></figure><p id="4a82" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">您可以看到我们的代码变得更加简单和高效。这是双赢的局面。代码越少，错误越少。</p></div><div class="ab cl md me hx mf" role="separator"><span class="mg bw bk mh mi mj"/><span class="mg bw bk mh mi mj"/><span class="mg bw bk mh mi"/></div><div class="im in io ip iq"><h1 id="27aa" class="mk ml it bd mm mn mo mp mq mr ms mt mu jz mv ka mw kc mx kd my kf mz kg na nb bi translated">支持交叉点观察器</h1><p id="7600" class="pw-post-body-paragraph kz la it lb b lc nc ju le lf nd jx lh li ne lk ll lm nf lo lp lq ng ls lt lu im bi translated">对这个特性的支持是相当大的:<strong class="lb iu"> <em class="nv"> </em> </strong> 92.3%。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi nw"><img src="../Images/0bcb778582fa7c1cfd8422d8169d47b9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*_qKLSyPdGH7LCmfxaDaiDA.png"/></div></figure><p id="eee6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果你担心的是那另外7.7%的用户，不要慌。你可以只使用:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="lz ma l"/></div></figure><p id="07fe" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">只有在浏览器确实需要时，此聚合填充工具才会加载回退实现。</p></div><div class="ab cl md me hx mf" role="separator"><span class="mg bw bk mh mi mj"/><span class="mg bw bk mh mi mj"/><span class="mg bw bk mh mi"/></div><div class="im in io ip iq"><h1 id="ce48" class="mk ml it bd mm mn mo mp mq mr ms mt mu jz mv ka mw kc mx kd my kf mz kg na nb bi translated">包裹</h1><p id="91fc" class="pw-post-body-paragraph kz la it lb b lc nc ju le lf nd jx lh li ne lk ll lm nf lo lp lq ng ls lt lu im bi translated">总结一下，让我们看看解决方案最终会是什么样子:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="lz ma l"/></div></figure><p id="0e08" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">当然，通过在真正需要的时候发布代码，这种方法可以变得更好。因此，我们可以延迟加载我们所有的交叉点观察器代码，只在用户需要时才发布。我认为这需要另一篇文章来深入探讨如何在不影响全功能浏览器性能的情况下优化多填充特性。我认为现在明智的做法是一次只专注于一件事，一步一步地尽我们所能做到最好。</p><p id="f22d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我希望你玩得开心并学到了新的东西。随着浏览器生态系统越来越成熟，看到曾经非常困难或低效的事情如何变得非常琐碎是非常有趣的。</p><p id="2bfd" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">干杯！</p></div></div>    
</body>
</html>