<html>
<head>
<title>Dynamic Import, Code Splitting, Lazy Loading, and Error Boundaries</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">动态导入、代码分割、延迟加载和错误边界</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/dynamic-import-code-splitting-lazy-loading-and-error-boundaries-fff57e63f6c4?source=collection_archive---------2-----------------------#2020-06-11">https://betterprogramming.pub/dynamic-import-code-splitting-lazy-loading-and-error-boundaries-fff57e63f6c4?source=collection_archive---------2-----------------------#2020-06-11</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="7d17" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">详细的指南</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/58becead0be2fd35a0e3f1d32d738dd1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ihsDzsPnDMbEyLq4mtRR9g.jpeg"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">照片由<a class="ae ky" href="https://unsplash.com/@m47h4r" rel="noopener ugc nofollow" target="_blank"> Mazhar Zandsalim </a> i在<a class="ae ky" href="https://unsplash.com/" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</p></figure><p id="1bda" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">本文是关于如何使用动态导入的详细指南，动态导入支持代码分割和延迟加载。它还描述了如何使用错误边界来捕捉错误。</p><p id="a97f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe lv lw lx ly b"><a class="ae ky" href="https://github.com/tc39/proposal-dynamic-import" rel="noopener ugc nofollow" target="_blank">import()</a></code>是函数吗？</p><p id="c9f9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">有，但是没有。</p><p id="4169" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe lv lw lx ly b"><a class="ae ky" href="https://github.com/tc39/proposal-dynamic-import" rel="noopener ugc nofollow" target="_blank">import()</a></code>目前处于TC39流程的第4阶段。它是一个类似函数的模块，在JavaScript中加载语法形式。</p><p id="439d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">它在许多方面都像一个函数:</p><ul class=""><li id="b51d" class="lz ma it lb b lc ld lf lg li mb lm mc lq md lu me mf mg mh bi translated">它由<code class="fe lv lw lx ly b">()</code>操作符调用。</li><li id="c8ad" class="lz ma it lb b lc mi lf mj li mk lm ml lq mm lu me mf mg mh bi translated">它返回所请求模块的模块名称空间对象的承诺，该对象是在获取、实例化和评估模块的所有依赖项以及模块本身之后创建的。</li></ul><p id="5e6d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">但它不是一个函数:</p><ul class=""><li id="5aed" class="lz ma it lb b lc ld lf lg li mb lm mc lq md lu me mf mg mh bi translated">是一种刚好使用括号的句法形式，类似于<code class="fe lv lw lx ly b"><a class="ae ky" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/super" rel="noopener ugc nofollow" target="_blank">super(</a>)</code>。</li><li id="32eb" class="lz ma it lb b lc mi lf mj li mk lm ml lq mm lu me mf mg mh bi translated">它不是从<code class="fe lv lw lx ly b">Function.prototype</code>继承来的。因此不能用<code class="fe lv lw lx ly b">apply</code>或<code class="fe lv lw lx ly b">call</code>调用。</li><li id="8511" class="lz ma it lb b lc mi lf mj li mk lm ml lq mm lu me mf mg mh bi translated">它不从<code class="fe lv lw lx ly b">Object.prototype</code>继承。因此，它不能用作变量。<code class="fe lv lw lx ly b">const a = import</code>违法。</li></ul><p id="f19d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">另一个有趣的地方:<code class="fe lv lw lx ly b">import.meta</code>，一个第4阶段的TC39提案，将特定于上下文的元数据暴露给一个JavaScript模块。它包含关于模块的信息，比如模块的URL。<code class="fe lv lw lx ly b">import.meta</code>是一个带有<code class="fe lv lw lx ly b">null</code>原型的对象。但是，它是可扩展的，其属性是可写的、可配置的和可枚举的。</p><p id="895b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">动态导入、代码分割、延迟加载和错误边界都是有趣的技术。你想知道更多吗？</p></div><div class="ab cl mn mo hx mp" role="separator"><span class="mq bw bk mr ms mt"/><span class="mq bw bk mr ms mt"/><span class="mq bw bk mr ms"/></div><div class="im in io ip iq"><h1 id="0bb2" class="mu mv it bd mw mx my mz na nb nc nd ne jz nf ka ng kc nh kd ni kf nj kg nk nl bi translated"><strong class="ak">什么是动态导入？</strong></h1><p id="67e2" class="pw-post-body-paragraph kz la it lb b lc nm ju le lf nn jx lh li no lk ll lm np lo lp lq nq ls lt lu im bi translated">与<a class="ae ky" href="https://medium.com/better-programming/a-handy-guide-to-export-and-import-modules-for-javascript-and-typescript-6cff8e47d554" rel="noopener">静态导入模块</a>相反，动态导入是一种设计模式，将对象的初始化推迟到需要它的时候。动态导入支持代码拆分和延迟加载。这可以显著提高应用程序的性能。</p><p id="8c56" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">由<code class="fe lv lw lx ly b">import()</code>完成:</p><pre class="kj kk kl km gt nr ly ns nt aw nu bi"><span id="2bf1" class="nv mv it ly b gy nw nx l ny nz">import("/path/to/import-module.js") // .js can be skipped<br/>  .then((module) =&gt; {<br/>    // do something with the module<br/>  });</span></pre><p id="dfe7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><a class="ae ky" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/import" rel="noopener ugc nofollow" target="_blank"> MDN web文档</a>中描述了五种动态导入用例:</p><ul class=""><li id="9f88" class="lz ma it lb b lc ld lf lg li mb lm mc lq md lu me mf mg mh bi translated">当静态导入显著降低了加载速度，并且您不太可能需要该代码，或者您以后会需要它时</li><li id="ae34" class="lz ma it lb b lc mi lf mj li mk lm ml lq mm lu me mf mg mh bi translated">当静态导入显著增加了内存使用量，并且不太可能需要该代码时</li><li id="7315" class="lz ma it lb b lc mi lf mj li mk lm ml lq mm lu me mf mg mh bi translated">当模块在加载时不存在时</li><li id="afed" class="lz ma it lb b lc mi lf mj li mk lm ml lq mm lu me mf mg mh bi translated">当需要动态构造导入说明符字符串时</li><li id="9532" class="lz ma it lb b lc mi lf mj li mk lm ml lq mm lu me mf mg mh bi translated">当被导入的模块有副作用时，这些副作用是可以避免的，除非某些情况发生</li></ul></div><div class="ab cl mn mo hx mp" role="separator"><span class="mq bw bk mr ms mt"/><span class="mq bw bk mr ms mt"/><span class="mq bw bk mr ms"/></div><div class="im in io ip iq"><h1 id="5572" class="mu mv it bd mw mx my mz na nb nc nd ne jz nf ka ng kc nh kd ni kf nj kg nk nl bi translated">静态导入的示例</h1><p id="8a13" class="pw-post-body-paragraph kz la it lb b lc nm ju le lf nn jx lh li no lk ll lm np lo lp lq nq ls lt lu im bi translated">这是一个网页的用户界面。一切都是静态导入的，不管用户是否要选择任何东西。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi oa"><img src="../Images/bab34215377a2158dbde306a6ecbe33d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*TN-0wbjQBMPuO5yFjzn14g.png"/></div></div></figure><p id="a95c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">选择菜单有两个选项:</p><ul class=""><li id="4c3c" class="lz ma it lb b lc ld lf lg li mb lm mc lq md lu me mf mg mh bi translated"><code class="fe lv lw lx ly b">Micro Frontends</code>话题</li><li id="e897" class="lz ma it lb b lc mi lf mj li mk lm ml lq mm lu me mf mg mh bi translated"><code class="fe lv lw lx ly b">React Utilities</code>话题</li></ul><p id="9bf5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">选择<code class="fe lv lw lx ly b">Micro Frontends</code>主题后，显示两个文章链接。当您单击任一链接时，将显示相关介绍:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi oa"><img src="../Images/b0d872a6efd5de73352d9fdb2217a063.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*n-iQt0L9l2pS2wzSLJIKTw.png"/></div></div></figure><p id="d0a2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">选择<code class="fe lv lw lx ly b">React Utilities</code>主题后，显示另外两篇文章链接。当您单击任一链接时，将显示相关介绍:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi oa"><img src="../Images/34d562cb5d4df6f1bd5cedf7d666f4dc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*9Uh8JAlKZdDnJ-rb52q1SQ.png"/></div></div></figure><p id="0875" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们创建这个例子。<a class="ae ky" href="https://medium.com/better-programming/10-fun-facts-about-create-react-app-eb7124aa3785" rel="noopener">创建React应用</a>是启动React编码环境的一种便捷方式:</p><pre class="kj kk kl km gt nr ly ns nt aw nu bi"><span id="f4fb" class="nv mv it ly b gy nw nx l ny nz">npx create-react-app my-app<br/>cd my-app<br/>npm start</span></pre><p id="305e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们在<code class="fe lv lw lx ly b">package.json:</code>中增加两个<code class="fe lv lw lx ly b"><a class="ae ky" href="https://medium.com/better-programming/package-jsons-dependencies-in-depth-a1f0637a3129" rel="noopener">dependencies</a></code></p><pre class="kj kk kl km gt nr ly ns nt aw nu bi"><span id="d86c" class="nv mv it ly b gy nw nx l ny nz">"dependencies": {<br/>  "react-router-dom": "^5.2.0",<br/>  "react-select": "^3.1.0"<br/>}</span></pre><ul class=""><li id="6737" class="lz ma it lb b lc ld lf lg li mb lm mc lq md lu me mf mg mh bi translated"><code class="fe lv lw lx ly b">react-router-dom</code>用于构建路线。</li><li id="337e" class="lz ma it lb b lc mi lf mj li mk lm ml lq mm lu me mf mg mh bi translated"><code class="fe lv lw lx ly b"><a class="ae ky" href="https://medium.com/better-programming/react-select-makes-creating-selectable-menus-easy-5d9dffc7e0d9" rel="noopener">react-select</a></code>是实现下拉列表的一种优雅方式。</li></ul><p id="3145" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">将<code class="fe lv lw lx ly b">src/App.css</code>改为最小样式:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ob oc l"/></div></figure><p id="3cfc" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在下面的<code class="fe lv lw lx ly b">src/index.js</code>中，在第10行和第12行增加<code class="fe lv lw lx ly b">BrowserRouter</code>:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ob oc l"/></div></figure><p id="e3c8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">创建组件生成器:<code class="fe lv lw lx ly b">src/buildComponent.js</code>。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ob oc l"/></div></figure><p id="5d94" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在<code class="fe lv lw lx ly b">src/microFrontendRoutes.js</code>中为<code class="fe lv lw lx ly b">Micro Frontends</code>主题创建路线信息。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ob oc l"/></div></figure><p id="0462" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">为<code class="fe lv lw lx ly b">src/reactUtilitiesRoutes.js</code>中的<code class="fe lv lw lx ly b">React Utilities</code>主题创建路线信息。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ob oc l"/></div></figure><p id="d5c4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在我们来看看<code class="fe lv lw lx ly b">src/App.js</code>的主要变化:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ob oc l"/></div></figure><p id="627f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在第4行和第5行，<code class="fe lv lw lx ly b">mfaRoutes</code>和<code class="fe lv lw lx ly b">utilRoutes</code>被静态导入。它们被映射到第26 - 32行。</p><p id="a6c6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">第9行定义了由选择组件设置的<code class="fe lv lw lx ly b">topic</code>状态。第12 - 24行定义了选择选项。选择组件由第49 - 54行定义。当选择一个<code class="fe lv lw lx ly b">topic</code>时，第53行的<code class="fe lv lw lx ly b">onChange</code>将调用<code class="fe lv lw lx ly b">handleTopicChange</code>(第36 - 43行)。</p><p id="d969" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">第10行定义了<code class="fe lv lw lx ly b">routes</code>状态。当<code class="fe lv lw lx ly b">handleTopicChange</code>被调用时，它在第38行设置选择的<code class="fe lv lw lx ly b">topic</code>并在第39行设置选择的<code class="fe lv lw lx ly b">routes</code>。<code class="fe lv lw lx ly b">routes</code>更改将导致第55 - 61行的链接重新呈现以及第63 - 67行的路线更改。</p><p id="2a76" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">本例中的所有内容都是静态导入的。</p></div><div class="ab cl mn mo hx mp" role="separator"><span class="mq bw bk mr ms mt"/><span class="mq bw bk mr ms mt"/><span class="mq bw bk mr ms"/></div><div class="im in io ip iq"><h1 id="bec2" class="mu mv it bd mw mx my mz na nb nc nd ne jz nf ka ng kc nh kd ni kf nj kg nk nl bi translated">转换为动态导入</h1><p id="c73e" class="pw-post-body-paragraph kz la it lb b lc nm ju le lf nn jx lh li no lk ll lm np lo lp lq nq ls lt lu im bi translated">这是一个网页的相同用户界面。选择组件下面的内容将被动态导入。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi od"><img src="../Images/5c620896a893bd2c4e7ae895b4a0ebfa.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*SJkr-8Ehvxm04NPNvzzBtw.png"/></div></div></figure><p id="282e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">选择<code class="fe lv lw lx ly b">Micro Frontends</code>主题后，加载链接和相关介绍。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi od"><img src="../Images/2bdc9abb958cde63ce5db8206c317c0f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*yagRIsWC6VSvbXHYXNBRhA.png"/></div></div></figure><p id="a271" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">选择<code class="fe lv lw lx ly b">React Utilities</code>主题后，加载链接和相关介绍。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi od"><img src="../Images/e556f485fe59a88f702dad1f7bcc6973.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*2W4OLeNWooSlX3eS2KicWA.png"/></div></div></figure><p id="f317" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这个例子使用与静态导入例子相同的代码库，在<code class="fe lv lw lx ly b">src/App.js</code>中有一些变化。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ob oc l"/></div></figure><p id="ac53" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe lv lw lx ly b">mfaRoutes</code>和<code class="fe lv lw lx ly b">utilRoute</code>的静态导入被移除。<code class="fe lv lw lx ly b">routeMapping</code>第24 - 30行指向文件名，而不是静态导入。可以跳过文件扩展名。</p><p id="0a72" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">关键的区别在<code class="fe lv lw lx ly b">handleTopicChange</code>(第34 - 43行)。它动态导入相关模块来设置<code class="fe lv lw lx ly b">currentRoutes</code>。</p><p id="5b84" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这就是所有的变化。这看起来简单明了。</p></div><div class="ab cl mn mo hx mp" role="separator"><span class="mq bw bk mr ms mt"/><span class="mq bw bk mr ms mt"/><span class="mq bw bk mr ms"/></div><div class="im in io ip iq"><h1 id="3b6d" class="mu mv it bd mw mx my mz na nb nc nd ne jz nf ka ng kc nh kd ni kf nj kg nk nl bi translated">代码分割</h1><p id="aff3" class="pw-post-body-paragraph kz la it lb b lc nm ju le lf nn jx lh li no lk ll lm np lo lp lq nq ls lt lu im bi translated">如果你仔细阅读上面的<code class="fe lv lw lx ly b">src/App.js</code>，你可能会奇怪为什么我们要在第37行构建文件路径，而不是在<code class="fe lv lw lx ly b">routeMapping</code>中构建完整的路径。</p><p id="126f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">试试看。</p><p id="a49e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">您将遇到错误:“<a class="ae ky" href="https://github.com/webpack/webpack/issues/6680" rel="noopener ugc nofollow" target="_blank">找不到具有动态导入</a>的模块。”这个错误来自于<a class="ae ky" href="https://webpack.js.org/" rel="noopener ugc nofollow" target="_blank"> Webpack </a>，由Create React App使用。Webpack在构建时执行静态分析。它可以很好地处理静态路径，但是它很难从变量中推断出哪些文件需要放在单独的块中。</p><p id="d35a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果我们硬编码类似于<code class="fe lv lw lx ly b">import(“./microFrontendRoutes.js”)</code>的东西，它将使这个文件成为一个单独的块。</p><p id="375f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果我们编写类似于<code class="fe lv lw lx ly b">import(“./” + routeMapping[selected.value])</code>的代码，它将使<code class="fe lv lw lx ly b">./</code>目录中的每个文件成为一个独立的块。</p><p id="6341" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果我们编写类似<code class="fe lv lw lx ly b">import(someVariable)</code>的代码，Webpack会抛出一个错误。</p><p id="92e9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">什么是代码拆分？</p><p id="e399" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">将代码分成不同的包(块)是一个特性，这些包可以按需或并行加载。它可以用来实现更小的包并控制资源负载优先级。如果使用正确，它可以减少加载时间。</p><p id="4146" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">Webpack提供了三种执行代码拆分的通用方法:</p><ul class=""><li id="c6e7" class="lz ma it lb b lc ld lf lg li mb lm mc lq md lu me mf mg mh bi translated">入口点:使用入口配置手动分割代码</li><li id="44ca" class="lz ma it lb b lc mi lf mj li mk lm ml lq mm lu me mf mg mh bi translated">防止重复:使用<code class="fe lv lw lx ly b">SplitChunksPlugin</code>来删除重复数据和分割数据块</li><li id="c797" class="lz ma it lb b lc mi lf mj li mk lm ml lq mm lu me mf mg mh bi translated">动态导入:通过内联<code class="fe lv lw lx ly b">import()</code>拆分代码</li></ul><p id="a9a5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">对于我们的静态示例，<code class="fe lv lw lx ly b">npm run build</code>显示了以下生成的包:</p><pre class="kj kk kl km gt nr ly ns nt aw nu bi"><span id="a7a5" class="nv mv it ly b gy nw nx l ny nz">File sizes after gzip:</span><span id="3476" class="nv mv it ly b gy oe nx l ny nz">71.85 KB (+32.46 KB)  build/static/js/2.489c17a1.chunk.js<br/>2.24 KB (+1.6 KB)     build/static/js/main.7c91b243.chunk.js<br/>776 B                 build/static/js/runtime-main.8894ea17.js<br/>312 B (-235 B)        build/static/css/main.83b9e03d.chunk.css</span></pre><p id="343c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在上面的包中:</p><ul class=""><li id="e279" class="lz ma it lb b lc ld lf lg li mb lm mc lq md lu me mf mg mh bi translated"><code class="fe lv lw lx ly b">main.[hash].chunk.js</code>:是应用代码，包括App.js等。</li><li id="4841" class="lz ma it lb b lc mi lf mj li mk lm ml lq mm lu me mf mg mh bi translated"><code class="fe lv lw lx ly b">[number].[hash].chunk.js</code>:要么是厂商代码，要么是分割块。</li><li id="8ef8" class="lz ma it lb b lc mi lf mj li mk lm ml lq mm lu me mf mg mh bi translated"><code class="fe lv lw lx ly b">runtime-main.[hash].js</code>:它是Webpack运行时逻辑的一小部分，用于加载和运行应用程序。</li><li id="06ba" class="lz ma it lb b lc mi lf mj li mk lm ml lq mm lu me mf mg mh bi translated"><code class="fe lv lw lx ly b">main.[hash].chunk.css</code>:是CSS代码。</li></ul><p id="4543" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">使用硬编码的<code class="fe lv lw lx ly b">import(“./microFrontendRoutes.js”)</code>，我们可以看到生成了一个额外的块:</p><pre class="kj kk kl km gt nr ly ns nt aw nu bi"><span id="faaf" class="nv mv it ly b gy nw nx l ny nz">File sizes after gzip:</span><span id="6f8a" class="nv mv it ly b gy oe nx l ny nz">71.85 KB (+70.95 KB)  build/static/js/2.489c17a1.chunk.js<br/>  1.17 KB (-74 B)       build/static/js/runtime-main.c08b891b.js<br/>  902 B (-912 B)        build/static/js/main.a5e0768c.chunk.js<br/>  885 B (-290 B)        build/static/js/3.b3637929.chunk.js<br/>  312 B                 build/static/css/main.83b9e03d.chunk.css</span></pre><p id="51d0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">编码为<code class="fe lv lw lx ly b">import(“./” + routeMapping[selected.value])</code>，我们可以看到<code class="fe lv lw lx ly b">./</code>目录中的每个文件都变成了一个单独的块。</p><pre class="kj kk kl km gt nr ly ns nt aw nu bi"><span id="27d3" class="nv mv it ly b gy nw nx l ny nz">File sizes after gzip:</span><span id="8b0f" class="nv mv it ly b gy oe nx l ny nz">71.86 KB           build/static/js/9.e1addb36.chunk.js<br/>50.68 KB           build/static/js/1.ee2fd9a6.chunk.js<br/>49.51 KB           build/static/js/0.ee6ff7e2.chunk.js<br/>1.77 KB (-477 B)   build/static/js/main.21dcc146.chunk.js<br/>1.24 KB (+496 B)   build/static/js/runtime-main.834cfecb.js<br/>1.15 KB            build/static/js/3.5ca48094.chunk.js<br/>919 B (-70.95 KB)  build/static/js/2.4da83169.chunk.js<br/>312 B              build/static/css/main.83b9e03d.chunk.css<br/>283 B              build/static/js/5.0753ed26.chunk.js<br/>283 B              build/static/js/4.7720f7a0.chunk.js<br/>177 B              build/static/js/10.880ba423.chunk.js<br/>160 B              build/static/js/6.f3a8c74d.chunk.js</span></pre></div><div class="ab cl mn mo hx mp" role="separator"><span class="mq bw bk mr ms mt"/><span class="mq bw bk mr ms mt"/><span class="mq bw bk mr ms"/></div><div class="im in io ip iq"><h1 id="447c" class="mu mv it bd mw mx my mz na nb nc nd ne jz nf ka ng kc nh kd ni kf nj kg nk nl bi translated">惰性装载</h1><p id="5674" class="pw-post-body-paragraph kz la it lb b lc nm ju le lf nn jx lh li no lk ll lm np lo lp lq nq ls lt lu im bi translated">延迟加载是代码分割的后续。由于代码已经在逻辑断点处被分割，我们在需要的时候加载代码。通过这种方式，我们可以显著提高性能。尽管加载时间总量可能相同，但初始加载时间得到了改善。通过这样做，我们避免了加载用户可能根本无法访问的内容。</p><p id="198f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">动态导入延迟加载任何JavaScript模块。<code class="fe lv lw lx ly b">React.lazy</code>使它变得更容易，限制将动态导入渲染为常规组件。</p><p id="f8eb" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">下面是一个类似的用户界面。<code class="fe lv lw lx ly b">Other Articles</code>链接以下的东西都是懒加载的。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi of"><img src="../Images/750b9c674b97f0e4b26920e11f97d422.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*H6q7t_kWaExdkbCjggsJlg.png"/></div></div></figure><p id="02f5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">点击<code class="fe lv lw lx ly b">Other Articles</code>链接后，它会加载剩余的内容:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi of"><img src="../Images/778c26d89c969f576ca6c93531f2431b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Ap0fa-EvpV1iSUrgMWj70g.png"/></div></div></figure><p id="5ced" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在<code class="fe lv lw lx ly b">src/OtherRouteComp.js</code>中创建要延迟加载的组件。</p><p id="dc71" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">目前，这个React组件必须默认导出。命名导出不支持延迟加载。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ob oc l"/></div></figure><p id="4570" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">上述组件可以在<code class="fe lv lw lx ly b">src/App.js</code>中被延迟加载:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ob oc l"/></div></figure><p id="bf11" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">第6行延迟加载<code class="fe lv lw lx ly b">OtherRouteComp</code>，它返回一个解析为由<code class="fe lv lw lx ly b">src/OtherRouteComp.js</code>导出的组件的承诺。这个组件被包装在<code class="fe lv lw lx ly b">&lt;Suspense&gt;</code>中，它在第10行有一个回退用户界面来显示加载期间的转换。</p><p id="8954" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">类似地，由于延迟加载，会产生额外的块。</p><pre class="kj kk kl km gt nr ly ns nt aw nu bi"><span id="af01" class="nv mv it ly b gy nw nx l ny nz">File sizes after gzip:</span><span id="5500" class="nv mv it ly b gy oe nx l ny nz">47.91 KB (+480 B)  build/static/js/2.27608de7.chunk.js<br/>1.17 KB (-1 B)     build/static/js/runtime-main.fce20771.js<br/>911 B (+232 B)     build/static/js/main.6680ea99.chunk.js<br/>372 B (-10 B)      build/static/js/3.df091b29.chunk.js<br/>312 B              build/static/css/main.83b9e03d.chunk.css</span></pre><p id="7a0a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在Network选项卡上，它显示在点击<code class="fe lv lw lx ly b">Other Articles</code>链接后加载了一个新块。这种延迟加载行为适用于所有动态导入情况。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi og"><img src="../Images/5dcf6efe4f75a7701ef2764c4a675656.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*GcIl6aoLENvCrm8uumt3hA.png"/></div></div></figure></div><div class="ab cl mn mo hx mp" role="separator"><span class="mq bw bk mr ms mt"/><span class="mq bw bk mr ms mt"/><span class="mq bw bk mr ms"/></div><div class="im in io ip iq"><h1 id="cdef" class="mu mv it bd mw mx my mz na nb nc nd ne jz nf ka ng kc nh kd ni kf nj kg nk nl bi translated">误差边界</h1><p id="5d31" class="pw-post-body-paragraph kz la it lb b lc nm ju le lf nn jx lh li no lk ll lm np lo lp lq nq ls lt lu im bi translated">懒加载返回一个承诺。如果这个过渡失败了呢？</p><p id="eca4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">设计良好的用户体验可以很好地处理这种情况。误差边界用于此目的。这是一个经典的组件，可以捕捉子组件树中任何地方的JavaScript错误。它记录这些错误，并显示一个回退用户界面，而不是崩溃的组件树。</p><p id="2b90" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这里是在第11行和第25行设置了<code class="fe lv lw lx ly b">MyErrorBoundary</code>的<code class="fe lv lw lx ly b">src/App.js</code>。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ob oc l"/></div></figure><p id="c924" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe lv lw lx ly b">src/MyErrorBoundary.js</code>是典型的误差边界元件:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ob oc l"/></div></figure><p id="a4ce" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">错误边界有一种或两种生命周期方法:</p><ul class=""><li id="04f7" class="lz ma it lb b lc ld lf lg li mb lm mc lq md lu me mf mg mh bi translated"><code class="fe lv lw lx ly b"><a class="ae ky" href="https://reactjs.org/docs/react-component.html#static-getderivedstatefromerror" rel="noopener ugc nofollow" target="_blank">static getDerivedStateFromError()</a></code>(第9 - 11行):它设置错误状态以呈现回退用户界面。</li><li id="e1c6" class="lz ma it lb b lc mi lf mj li mk lm ml lq mm lu me mf mg mh bi translated"><code class="fe lv lw lx ly b"><a class="ae ky" href="https://reactjs.org/docs/react-component.html#componentdidcatch" rel="noopener ugc nofollow" target="_blank">componentDidCatch()</a></code>(第13 - 16行):用于记录错误信息。</li></ul><p id="40cc" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们可以通过在第6行将<code class="fe lv lw lx ly b">hasError</code>初始化为<code class="fe lv lw lx ly b">true</code>来模拟一个错误。然后，我们将遇到由第20行定义的以下回退用户界面:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi oh"><img src="../Images/1eb034c207f31df70f9ce0154e71c2ff.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*N9tLL6hzOP3Drn0CCNy1XA.png"/></div></div></figure><p id="eb0d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">错误边界的粒度取决于开发人员。可以有多级误差边界。</p></div><div class="ab cl mn mo hx mp" role="separator"><span class="mq bw bk mr ms mt"/><span class="mq bw bk mr ms mt"/><span class="mq bw bk mr ms"/></div><div class="im in io ip iq"><h1 id="654c" class="mu mv it bd mw mx my mz na nb nc nd ne jz nf ka ng kc nh kd ni kf nj kg nk nl bi translated">结论</h1><p id="fdeb" class="pw-post-body-paragraph kz la it lb b lc nm ju le lf nn jx lh li no lk ll lm np lo lp lq nq ls lt lu im bi translated">我们已经讨论了好处，并提供了动态导入、代码分割、延迟加载和错误边界的例子。</p><p id="5aa7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">最后，我们想强调不要过度使用任何技术。静态导入更适合于加载初始依赖项，并且可以更容易地从静态分析工具和树抖动中受益。仅在必要时使用动态导入。</p><p id="e82d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">感谢阅读。我希望这有所帮助。你可以在这里看到我的其他媒体出版物<a class="ae ky" href="https://medium.com/@jenniferfubook/jennifer-fus-web-development-publications-1a887e4454af" rel="noopener"/>。</p><p id="fb1a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><em class="oi">注:Jonathan Ma对本文部分内容有贡献。</em></p></div></div>    
</body>
</html>