<html>
<head>
<title>Write Better Python Scripts</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">编写更好的Python脚本</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/write-better-python-scripts-ce58c1ebf690?source=collection_archive---------0-----------------------#2020-05-26">https://betterprogramming.pub/write-better-python-scripts-ce58c1ebf690?source=collection_archive---------0-----------------------#2020-05-26</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="11f9" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">使用这三个内置模块以Pythonic的方式格式化您的脚本。</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi ki"><img src="../Images/e043d8426c24f10a27723327a9e58acd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1392/format:webp/1*hmvn5XYLGXrF4ACspVqgPw.png"/></div><p class="kq kr gj gh gi ks kt bd b be z dk translated">作者照片。</p></figure><p id="ea53" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">在本文中，我将向您展示三种脚本约定和相应的内置模块，以帮助您更好地格式化Python脚本。这些模块旨在坚持DRY(不要重复自己)原则，并提高代码和脚本的质量！</p><p id="3df2" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">简而言之，我们将讨论以下三个部分:</p><ol class=""><li id="142f" class="lq lr it kw b kx ky la lb ld ls lh lt ll lu lp lv lw lx ly bi translated">使用<code class="fe lz ma mb mc b">ifmain</code>和相应的<code class="fe lz ma mb mc b">main()</code>功能。</li><li id="d024" class="lq lr it kw b kx md la me ld mf lh mg ll mh lp lv lw lx ly bi translated">如何用<code class="fe lz ma mb mc b">argparse</code>解析命令行参数？</li><li id="a7a4" class="lq lr it kw b kx md la me ld mf lh mg ll mh lp lv lw lx ly bi translated">如何用<code class="fe lz ma mb mc b">logging()</code>模块代替<code class="fe lz ma mb mc b">print()</code>进行调试？</li></ol></div><div class="ab cl mi mj hx mk" role="separator"><span class="ml bw bk mm mn mo"/><span class="ml bw bk mm mn mo"/><span class="ml bw bk mm mn"/></div><div class="im in io ip iq"><h1 id="7a58" class="mp mq it bd mr ms mt mu mv mw mx my mz jz na ka nb kc nc kd nd kf ne kg nf ng bi translated">始终使用ifmain</h1><p id="f7c4" class="pw-post-body-paragraph ku kv it kw b kx nh ju kz la ni jx lc ld nj lf lg lh nk lj lk ll nl ln lo lp im bi translated"><code class="fe lz ma mb mc b">ifmain</code>是指你经常看到的一个Python脚本中的最后几行代码:<code class="fe lz ma mb mc b">if __name__ == "__main__":</code>。当Python解释器解析Python脚本时，会设置一些顶级变量，包括<code class="fe lz ma mb mc b">__name__</code>变量。</p><p id="8027" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">通常，您正在编写一个Python脚本，您正在从这样的交互式提示中阅读该脚本:<code class="fe lz ma mb mc b">$ python3 file.py</code>。当你这样做时，<code class="fe lz ma mb mc b">__name__</code>变量被设置为<code class="fe lz ma mb mc b">__main__</code>。</p><p id="3693" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">根据DRY原则，您应该希望编写可以在其他Python脚本中重用的函数。您可以通过使用<code class="fe lz ma mb mc b">import modular_function from file.py</code>从Python脚本导入模块(类或函数)来实现这一点:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nm nn l"/></div></figure><p id="10f2" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">这里有一个问题:如果您导入一个函数，变量<code class="fe lz ma mb mc b">__name__</code>将被设置为函数的名称(在本例中为<code class="fe lz ma mb mc b">modular_function</code>)。因此，<code class="fe lz ma mb mc b">ifmain</code>下的代码只有在主程序被执行时才会被执行——例如，从Python解释器<code class="fe lz ma mb mc b">$python3 file.py</code>执行。</p><p id="a2fb" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">这使我们能够编写既可以被其他脚本使用又可以作为主程序运行的<code class="fe lz ma mb mc b">.py</code>文件。我经常在创建具有不同模块化步骤的机器学习管道时使用这种方法，例如预处理或训练。在测试框架中编写单元测试时，它也很有用，该框架导入模块并在测试数据库上运行特殊的测试功能。无论如何，您仍然可以导入整个文件并运行主要功能:</p><pre class="kj kk kl km gt no mc np nq aw nr bi"><span id="4335" class="ns mq it mc b gy nt nu l nv nw">import ifmain<br/>ifmain.main()</span></pre></div><div class="ab cl mi mj hx mk" role="separator"><span class="ml bw bk mm mn mo"/><span class="ml bw bk mm mn mo"/><span class="ml bw bk mm mn"/></div><div class="im in io ip iq"><h1 id="1813" class="mp mq it bd mr ms mt mu mv mw mx my mz jz na ka nb kc nc kd nd kf ne kg nf ng bi translated">用argparse解析命令行参数</h1><p id="52ce" class="pw-post-body-paragraph ku kv it kw b kx nh ju kz la ni jx lc ld nj lf lg lh nk lj lk ll nl ln lo lp im bi translated">位置命令行参数，比如<code class="fe lz ma mb mc b">$ python3 file.py arg1 arg2</code>，可以用<code class="fe lz ma mb mc b">sys.argv[0]</code>和<code class="fe lz ma mb mc b">sys.argv[1]</code>来解析。Python还附带了内置的<code class="fe lz ma mb mc b"><a class="ae nx" href="https://docs.python.org/3/library/argparse.html" rel="noopener ugc nofollow" target="_blank">argparse</a></code>模块，当用户给程序无效的参数时，该模块会自动生成帮助和使用消息并发出错误。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nm nn l"/></div></figure><p id="d490" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">然后，您可以在您的<code class="fe lz ma mb mc b">main</code>函数中使用这些参数，方法是通过参数的值调用参数(例如<code class="fe lz ma mb mc b">args.i</code>):</p><pre class="kj kk kl km gt no mc np nq aw nr bi"><span id="cb2e" class="ns mq it mc b gy nt nu l nv nw">def main():</span><span id="70d2" class="ns mq it mc b gy ny nu l nv nw">with open(args.i, "r") as inp_file:<br/>        # do something meaningful</span></pre></div><div class="ab cl mi mj hx mk" role="separator"><span class="ml bw bk mm mn mo"/><span class="ml bw bk mm mn mo"/><span class="ml bw bk mm mn"/></div><div class="im in io ip iq"><h1 id="a4e1" class="mp mq it bd mr ms mt mu mv mw mx my mz jz na ka nb kc nc kd nd kf ne kg nf ng bi translated">记录错误而不是打印</h1><p id="909b" class="pw-post-body-paragraph ku kv it kw b kx nh ju kz la ni jx lc ld nj lf lg lh nk lj lk ll nl ln lo lp im bi translated">打印错误可能对调试有用，但是使用Python的内置<code class="fe lz ma mb mc b"><a class="ae nx" href="https://docs.python.org/3/library/logging.html" rel="noopener ugc nofollow" target="_blank">logging</a></code>模块使所有Python模块都能够参与日志记录，因此您的应用程序日志可以包含您的消息和来自第三方模块的消息。</p><p id="354d" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated"><code class="fe lz ma mb mc b">logging</code>模块提供了从最不严重到最严重的几个<code class="fe lz ma mb mc b">LEVELS</code>:</p><ul class=""><li id="c50e" class="lq lr it kw b kx ky la lb ld ls lh lt ll lu lp nz lw lx ly bi translated"><code class="fe lz ma mb mc b">DEBUG</code> —详细信息，通常仅在诊断问题时感兴趣。</li><li id="0bc8" class="lq lr it kw b kx md la me ld mf lh mg ll mh lp nz lw lx ly bi translated"><code class="fe lz ma mb mc b">INFO</code> —确认事情按预期运行。</li><li id="e15a" class="lq lr it kw b kx md la me ld mf lh mg ll mh lp nz lw lx ly bi translated"><code class="fe lz ma mb mc b">WARNING</code> —表示发生了或即将发生意想不到的事情(如“磁盘空间不足”)。该软件仍按预期工作。</li><li id="80d7" class="lq lr it kw b kx md la me ld mf lh mg ll mh lp nz lw lx ly bi translated"><code class="fe lz ma mb mc b">ERROR</code> —由于更严重的问题，软件无法执行某些功能。</li><li id="41b2" class="lq lr it kw b kx md la me ld mf lh mg ll mh lp nz lw lx ly bi translated"><code class="fe lz ma mb mc b">CRITICAL</code> —严重错误，表示程序本身可能无法继续运行。</li></ul><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nm nn l"/></div></figure><p id="5dfc" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated"><code class="fe lz ma mb mc b">basicConfig</code>的级别表示包括哪些日志。例如，如果您使用<code class="fe lz ma mb mc b">info()</code>，但是日志级别设置为<code class="fe lz ma mb mc b">WARNING</code>，这些日志将不会显示。您也可以使用配置将日志输出到一个<code class="fe lz ma mb mc b">example.log</code>文件，而不是将我们的日志流式传输到标准输出(相当于打印它们):</p><pre class="kj kk kl km gt no mc np nq aw nr bi"><span id="e950" class="ns mq it mc b gy nt nu l nv nw">logging.basicConfig(filename='example.log',level=logging.DEBUG)</span></pre></div><div class="ab cl mi mj hx mk" role="separator"><span class="ml bw bk mm mn mo"/><span class="ml bw bk mm mn mo"/><span class="ml bw bk mm mn"/></div><div class="im in io ip iq"><h1 id="6f24" class="mp mq it bd mr ms mt mu mv mw mx my mz jz na ka nb kc nc kd nd kf ne kg nf ng bi translated">把所有的放在一起</h1><p id="9d32" class="pw-post-body-paragraph ku kv it kw b kx nh ju kz la ni jx lc ld nj lf lg lh nk lj lk ll nl ln lo lp im bi translated">根据我们对<code class="fe lz ma mb mc b">argparse</code>和<code class="fe lz ma mb mc b">logging</code>模块的了解，我们现在可以创建一个标准的脚本格式，其中我们可以将脚本的日志记录<code class="fe lz ma mb mc b">LEVEL</code>设置为命令行参数之一。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nm nn l"/></div></figure><p id="8412" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">这样，您可以从命令行使用<code class="fe lz ma mb mc b">$ python3 format.py -v 2</code>调用脚本，并使用参数<code class="fe lz ma mb mc b">-v</code>设置日志记录级别。如果你想或者只是保持输出干净，你现在可以看到调试的错误！</p><p id="4e24" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">* <code class="fe lz ma mb mc b">add_pargument</code>带有一个<code class="fe lz ma mb mc b">default</code>参数，所以即使你调用没有参数<code class="fe lz ma mb mc b">-v</code>的脚本，它仍然会默认为<code class="fe lz ma mb mc b">2</code> / <code class="fe lz ma mb mc b">logging.WARNING</code>(第16行)。</p></div></div>    
</body>
</html>