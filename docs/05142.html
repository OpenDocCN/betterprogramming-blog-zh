<html>
<head>
<title>Encrypting Kubernetes Secrets With Sealed Secrets</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">用密封的秘密加密Kubernetes的秘密</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/encrypting-kubernetes-secrets-with-sealed-secrets-fe363149a211?source=collection_archive---------0-----------------------#2020-06-15">https://betterprogramming.pub/encrypting-kubernetes-secrets-with-sealed-secrets-fe363149a211?source=collection_archive---------0-----------------------#2020-06-15</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="f24d" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">如何在git中存储您的Kubernetes秘密</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/e1f4e6e24cf55452109832e24c4c6cbe.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*l9La4SoBS2-yDkLtW1ZlIw.jpeg"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">照片由Kristina Flour在Unsplash上拍摄</p></figure><p id="e948" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">GitOps是一种通过Git管理所有配置的方式。它允许团队通过声明性代码来管理环境配置和基础设施。</p><p id="2edd" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">虽然Kubernetes允许团队使用资源清单管理他们的容器工作负载，但是在Git存储库中存储Kubernetes <code class="fe lu lv lw lx b">Secrets</code>一直是一个挑战。</p><p id="c955" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">Kubernetes <code class="fe lu lv lw lx b">Secrets</code>是帮助您存储敏感信息的资源，比如密码、密钥、证书、OAuth令牌和SSH密钥。</p><p id="c92b" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">它分离了秘密管理和利用。虽然管理员可以创建密码，但是开发人员可以简单地引用清单中的<code class="fe lu lv lw lx b">Secret</code>资源，而不是在pod定义中硬编码密码。</p><p id="34af" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">这听起来不错，但是Kubernetes secrets的问题是它们将敏感信息存储为base64字符串。任何人都可以解码base64字符串，从<code class="fe lu lv lw lx b">Secret</code>清单中获取原始令牌。</p><p id="429f" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">因此，<code class="fe lu lv lw lx b">Secret</code>清单文件不能存储在源代码库中。在集群上创建秘密总是需要手动操作，这使得100%的GitOps变得困难。</p><p id="64e2" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">Bitnami Labs试图通过创建一个名为<a class="ae ly" href="https://github.com/bitnami-labs/sealed-secrets" rel="noopener ugc nofollow" target="_blank"> Sealed Secrets </a>的开源工具来解决这个问题。</p></div><div class="ab cl lz ma hx mb" role="separator"><span class="mc bw bk md me mf"/><span class="mc bw bk md me mf"/><span class="mc bw bk md me"/></div><div class="im in io ip iq"><h1 id="503d" class="mg mh it bd mi mj mk ml mm mn mo mp mq jz mr ka ms kc mt kd mu kf mv kg mw mx bi translated">密封的秘密</h1><p id="d064" class="pw-post-body-paragraph ky kz it la b lb my ju ld le mz jx lg lh na lj lk ll nb ln lo lp nc lr ls lt im bi translated">《密封的秘密》由两部分组成:</p><ul class=""><li id="b608" class="nd ne it la b lb lc le lf lh nf ll ng lp nh lt ni nj nk nl bi translated">集群端Kubernetes控制器/操作员</li><li id="cc89" class="nd ne it la b lb nm le nn lh no ll np lp nq lt ni nj nk nl bi translated">名为<code class="fe lu lv lw lx b">kubeseal</code>的客户端实用程序</li></ul><p id="f572" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated"><code class="fe lu lv lw lx b">kubeseal</code>实用程序允许您使用非对称加密算法来密封Kubernetes <code class="fe lu lv lw lx b">Secrets</code>。<code class="fe lu lv lw lx b">SealedSecrets</code>是Kubernetes资源，包含只有控制器才能解密的加密<code class="fe lu lv lw lx b">Secrets</code>。因此，<code class="fe lu lv lw lx b">SealedSecret</code>即使存储在公共存储库中也是安全的。</p><p id="f6eb" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated"><code class="fe lu lv lw lx b">SealedSecret</code>资源只是创建Kubernetes <code class="fe lu lv lw lx b">Secret</code>资源的一种方法。当您在Kubernetes集群上应用它时，集群端操作符读取<code class="fe lu lv lw lx b">SealedSecret</code>，生成Kubernetes <code class="fe lu lv lw lx b">Secret</code>，并将生成的<code class="fe lu lv lw lx b">Secret</code>应用到集群上。Kubernetes <code class="fe lu lv lw lx b">Pod</code>然后可以按照惯例使用<code class="fe lu lv lw lx b">Secret</code>。</p><p id="2b8a" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">下面是一个<code class="fe lu lv lw lx b">SealedSecret</code>的例子:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nr ns l"/></div></figure><p id="964f" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">当控制器打开<code class="fe lu lv lw lx b">SealedSecret</code>时，它生成一个Kubernetes <code class="fe lu lv lw lx b">Secret</code>，如下所示:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nr ns l"/></div></figure><p id="d62f" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">施加<code class="fe lu lv lw lx b">SealedSecret</code>几秒钟后，控制器产生Kubernetes <code class="fe lu lv lw lx b">Secret</code>。</p></div><div class="ab cl lz ma hx mb" role="separator"><span class="mc bw bk md me mf"/><span class="mc bw bk md me mf"/><span class="mc bw bk md me"/></div><div class="im in io ip iq"><h1 id="cd5e" class="mg mh it bd mi mj mk ml mm mn mo mp mq jz mr ka ms kc mt kd mu kf mv kg mw mx bi translated">密封保密范围</h1><p id="a7c1" class="pw-post-body-paragraph ky kz it la b lb my ju ld le mz jx lg lh na lj lk ll nb ln lo lp nc lr ls lt im bi translated">从最终用户的角度来看，<code class="fe lu lv lw lx b">SealedSecret</code>是一个只写设备。</p><p id="1fd7" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">除了运行的控制器没有人能解密<code class="fe lu lv lw lx b">SealedSecret</code>，甚至连<code class="fe lu lv lw lx b">Secret</code>的作者也不能。</p><p id="89fc" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">一般来说，最佳实践是禁止用户直接读取机密。您可以创建RBAC规则来禁止低权限用户阅读<code class="fe lu lv lw lx b">Secrets</code>。您还可以限制用户只能从他们的名称空间读取<code class="fe lu lv lw lx b">Secrets</code>。</p><p id="0543" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">虽然<code class="fe lu lv lw lx b">SealedSecrets</code>的设计方式是不可能直接读取它们，但用户可以绕过这个过程，获得他们不被允许查看的秘密。</p><p id="d70b" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated"><code class="fe lu lv lw lx b">SealedSecret</code>资源提供了多种方式来防止这种误用。默认情况下，它们是名称空间感知的。一旦使用<code class="fe lu lv lw lx b">kubeseal</code>为特定的名称空间生成了<code class="fe lu lv lw lx b">SealedSecret</code>，就不能在另一个名称空间中使用<code class="fe lu lv lw lx b">SealedSecret</code>。</p><p id="e24c" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">例如，如果您为名称空间<code class="fe lu lv lw lx b">web</code>创建一个名为<code class="fe lu lv lw lx b">foo</code>的<code class="fe lu lv lw lx b">Secret</code>并带有一个值<code class="fe lu lv lw lx b">bar</code>，您就不能在<code class="fe lu lv lw lx b">database</code>名称空间上应用<code class="fe lu lv lw lx b">Secret</code>——即使它需要相同的<code class="fe lu lv lw lx b">Secret</code>。</p><p id="c284" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">这是故意的，因为我们不允许访问<code class="fe lu lv lw lx b">database</code>名称空间的用户通过在<code class="fe lu lv lw lx b">database</code>名称空间上应用<code class="fe lu lv lw lx b">web</code>名称空间的<code class="fe lu lv lw lx b">SealedSecrets</code>来从<code class="fe lu lv lw lx b">web</code>名称空间查看<code class="fe lu lv lw lx b">Secrets</code>。表现得好像每个名称空间都有自己的解密密钥。</p><p id="4359" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">虽然Sealed Secret的控制器没有为每个名称空间使用独立的私钥，但它在加密过程中考虑了名称空间和名称，这达到了相同的结果。</p><p id="bf70" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">另一个场景是，我们可能有一个用户在<code class="fe lu lv lw lx b">web</code>名称空间上，他只能查看某些秘密，而不是全部。也允许这样。</p><p id="5cc1" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">当您为名称空间<code class="fe lu lv lw lx b">web</code>中名为<code class="fe lu lv lw lx b">foo</code>的<code class="fe lu lv lw lx b">Secret</code>生成一个<code class="fe lu lv lw lx b">SealedSecret</code>时，对名称空间<code class="fe lu lv lw lx b">web</code>中名为<code class="fe lu lv lw lx b">bar</code>的<code class="fe lu lv lw lx b">Secret</code>具有读取权限的用户不能将<code class="fe lu lv lw lx b">SealedSecret</code>清单中的<code class="fe lu lv lw lx b">Secret</code>的名称更改为<code class="fe lu lv lw lx b">bar</code>并应用它来查看<code class="fe lu lv lw lx b">Secret</code>。</p><p id="2ab9" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">虽然这些方法有助于你防止人们滥用<code class="fe lu lv lw lx b">Secrets</code>，但它们可能会让你在管理上头疼。在默认配置中，您将无法定义在多个名称空间中使用的泛型<code class="fe lu lv lw lx b">Secrets</code>。</p><p id="5609" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">您可能没有一个大型团队，并且您的Kubernetes集群可能只由管理员访问和管理。因此，您可能不需要那种级别的基于角色的访问控制。</p><p id="4ad0" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">您可能还想定义可以跨名称空间移动的<code class="fe lu lv lw lx b">SealedSecrets</code>。您不希望为同一个<code class="fe lu lv lw lx b">Secret</code>管理多个<code class="fe lu lv lw lx b">SealedSecrets</code>副本。</p><p id="3877" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated"><code class="fe lu lv lw lx b">SealedSecrets</code>使用示波器允许这些可能性。</p><p id="e5f9" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">您可以使用三个范围创建您的<code class="fe lu lv lw lx b">SealedSecrets</code>:</p><ul class=""><li id="47c1" class="nd ne it la b lb lc le lf lh nf ll ng lp nh lt ni nj nk nl bi translated"><code class="fe lu lv lw lx b">strict</code>(默认):在这种情况下，考虑到名称和命名空间，你需要密封你的<code class="fe lu lv lw lx b">Secret</code>。一旦创建了<code class="fe lu lv lw lx b">SealedSecret</code>，就不能更改它的名称和命名空间。如果你试图这样做，你会得到一个解密错误。</li><li id="27d2" class="nd ne it la b lb nm le nn lh no ll np lp nq lt ni nj nk nl bi translated"><code class="fe lu lv lw lx b">namespace-wide</code>:这个作用域允许您在已经密封了<code class="fe lu lv lw lx b">Secret</code>的名称空间内自由地重命名<code class="fe lu lv lw lx b">SealedSecret</code>。</li><li id="7ee0" class="nd ne it la b lb nm le nn lh no ll np lp nq lt ni nj nk nl bi translated"><code class="fe lu lv lw lx b">cluster-wide</code>:这个作用域允许你自由地将<code class="fe lu lv lw lx b">Secret</code>移动到任何名称空间，并给它起任何你想要的名字。</li></ul><p id="2fa1" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">除了名称和命名空间之外，您还可以重命名密钥，而不会失去任何解密功能。</p><p id="7fc0" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">使用<code class="fe lu lv lw lx b">kubeseal</code>时，可以选择带有<code class="fe lu lv lw lx b">--scope</code>标志的范围:</p><pre class="kj kk kl km gt nt lx nu nv aw nw bi"><span id="cc1e" class="nx mh it lx b gy ny nz l oa ob">$ kubeseal --scope cluster-wide --format yaml &lt;secret.yaml &gt;sealed-secret.yaml</span></pre><p id="1eeb" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">在将配置传递给<code class="fe lu lv lw lx b">kubeseal</code>之前，您还可以在<code class="fe lu lv lw lx b">Secret</code>中使用注释来应用作用域:</p><ul class=""><li id="a447" class="nd ne it la b lb lc le lf lh nf ll ng lp nh lt ni nj nk nl bi translated"><code class="fe lu lv lw lx b">sealedsecrets.bitnami.com/namespace-wide: "true"</code>为<code class="fe lu lv lw lx b">namespace-wide</code></li><li id="63e1" class="nd ne it la b lb nm le nn lh no ll np lp nq lt ni nj nk nl bi translated"><code class="fe lu lv lw lx b">sealedsecrets.bitnami.com/cluster-wide: "true"</code>为<code class="fe lu lv lw lx b">cluster-wide</code></li></ul><p id="c3f7" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">如果您没有指定任何注释，那么<code class="fe lu lv lw lx b">kubeseal</code>将采用<code class="fe lu lv lw lx b">strict</code>范围。如果您设置了两种注释，<code class="fe lu lv lw lx b">cluster-wide</code>优先。</p></div><div class="ab cl lz ma hx mb" role="separator"><span class="mc bw bk md me mf"/><span class="mc bw bk md me mf"/><span class="mc bw bk md me"/></div><div class="im in io ip iq"><h1 id="3676" class="mg mh it bd mi mj mk ml mm mn mo mp mq jz mr ka ms kc mt kd mu kf mv kg mw mx bi translated">安装“共享机密”</h1><p id="183f" class="pw-post-body-paragraph ky kz it la b lb my ju ld le mz jx lg lh na lj lk ll nb ln lo lp nc lr ls lt im bi translated">如前一节所述，<code class="fe lu lv lw lx b">SharedSecrets</code>包含一个客户端<code class="fe lu lv lw lx b">kubeseal</code>二进制文件和一个集群端Kubernetes操作符。</p><p id="b252" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">让我们从安装<code class="fe lu lv lw lx b">kubeseal</code>二进制文件开始。</p><p id="851a" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">从<a class="ae ly" href="https://github.com/bitnami-labs/sealed-secrets/releases" rel="noopener ugc nofollow" target="_blank">这里</a>选择最新的发布版本，下载最新的二进制文件，然后运行以下程序:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nr ns l"/></div></figure><p id="943a" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">现在安装集群端控制器资源。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nr ns l"/></div></figure></div><div class="ab cl lz ma hx mb" role="separator"><span class="mc bw bk md me mf"/><span class="mc bw bk md me mf"/><span class="mc bw bk md me"/></div><div class="im in io ip iq"><h1 id="058e" class="mg mh it bd mi mj mk ml mm mn mo mp mq jz mr ka ms kc mt kd mu kf mv kg mw mx bi translated">创建一个“密封的秘密”</h1><p id="89ab" class="pw-post-body-paragraph ky kz it la b lb my ju ld le mz jx lg lh na lj lk ll nb ln lo lp nc lr ls lt im bi translated">要创建一个<code class="fe lu lv lw lx b">SealedSecret</code>，我们首先需要创建一个<code class="fe lu lv lw lx b">Secret</code>文件。</p><pre class="kj kk kl km gt nt lx nu nv aw nw bi"><span id="d592" class="nx mh it lx b gy ny nz l oa ob">echo -n "This is a secret!" | kubectl create secret generic mysecret -n web --dry-run --from-file=secret=/dev/stdin -o yaml &gt; secret.yaml</span></pre><p id="59e4" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">上面的命令产生了下面的<code class="fe lu lv lw lx b">secret.yaml</code>文件:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nr ns l"/></div></figure><p id="6f4e" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated"><code class="fe lu lv lw lx b">Secret</code>只是<code class="fe lu lv lw lx b">This is a secret!</code>的base64编码表示，因此，不适合存储在您的源代码回购中。</p><p id="9626" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">时间到了<code class="fe lu lv lw lx b">kubeseal</code>该<code class="fe lu lv lw lx b">Secret</code>了。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nr ns l"/></div></figure><p id="4344" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">现在<code class="fe lu lv lw lx b">Secret</code>被加密了。您可以将它安全地存储在Git存储库中。</p></div><div class="ab cl lz ma hx mb" role="separator"><span class="mc bw bk md me mf"/><span class="mc bw bk md me mf"/><span class="mc bw bk md me"/></div><div class="im in io ip iq"><h1 id="df89" class="mg mh it bd mi mj mk ml mm mn mo mp mq jz mr ka ms kc mt kd mu kf mv kg mw mx bi translated">应用“密封秘笈”</h1><p id="43f1" class="pw-post-body-paragraph ky kz it la b lb my ju ld le mz jx lg lh na lj lk ll nb ln lo lp nc lr ls lt im bi translated">现在让我们在<code class="fe lu lv lw lx b">busybox</code> pod中使用<code class="fe lu lv lw lx b">Secret</code>,看看我们能否在集群中检索它。</p><p id="3f83" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">让我们从创建一个<code class="fe lu lv lw lx b">web</code>名称空间开始。</p><pre class="kj kk kl km gt nt lx nu nv aw nw bi"><span id="4aba" class="nx mh it lx b gy ny nz l oa ob">$ kubectl create ns web<br/>namespace/web created</span></pre><p id="1783" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">使用<code class="fe lu lv lw lx b">SealedSecret</code>。</p><pre class="kj kk kl km gt nt lx nu nv aw nw bi"><span id="ce1b" class="nx mh it lx b gy ny nz l oa ob">$ kubectl apply -f sealedsecret.yaml<br/>sealedsecret.bitnami.com/mysecret created</span></pre><p id="61a5" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">这应该会产生一个名为<code class="fe lu lv lw lx b">mysecret</code>的对等<code class="fe lu lv lw lx b">Secret</code>。</p><pre class="kj kk kl km gt nt lx nu nv aw nw bi"><span id="d840" class="nx mh it lx b gy ny nz l oa ob">$ kubectl get secret mysecret -n web<br/>NAME       TYPE     DATA   AGE<br/>mysecret   Opaque   1      119s</span></pre><p id="c2d6" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">使用下面使用<code class="fe lu lv lw lx b">Secret</code>的<code class="fe lu lv lw lx b">busybox</code> pod YAML。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nr ns l"/></div></figure><p id="ed47" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">让我们打印出<code class="fe lu lv lw lx b">Secret</code>值。我们得到<code class="fe lu lv lw lx b">This is a secret!</code>作为输出。</p><pre class="kj kk kl km gt nt lx nu nv aw nw bi"><span id="e5d4" class="nx mh it lx b gy ny nz l oa ob">$ kubectl exec -it busybox -n web -- cat /tmp/mysecret/secret<br/>This is a secret!</span></pre></div><div class="ab cl lz ma hx mb" role="separator"><span class="mc bw bk md me mf"/><span class="mc bw bk md me mf"/><span class="mc bw bk md me"/></div><div class="im in io ip iq"><h1 id="b16c" class="mg mh it bd mi mj mk ml mm mn mo mp mq jz mr ka ms kc mt kd mu kf mv kg mw mx bi translated">修改名称空间</h1><p id="c762" class="pw-post-body-paragraph ky kz it la b lb my ju ld le mz jx lg lh na lj lk ll nb ln lo lp nc lr ls lt im bi translated">由于我们在上面的<code class="fe lu lv lw lx b">Secret</code>中没有指定任何范围，这个<code class="fe lu lv lw lx b">Secret</code>不应该在<code class="fe lu lv lw lx b">web</code>名称空间之外的任何地方工作。让我们创建一个<code class="fe lu lv lw lx b">database</code>名称空间，在那里应用<code class="fe lu lv lw lx b">Secret</code>，然后自己看看。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nr ns l"/></div></figure><p id="3f8d" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">从<code class="fe lu lv lw lx b">database</code>名称空间获取<code class="fe lu lv lw lx b">Secret</code>。</p><pre class="kj kk kl km gt nt lx nu nv aw nw bi"><span id="678b" class="nx mh it lx b gy ny nz l oa ob">$ kubectl get secret -n database<br/>NAME                  TYPE                                  DATA   AGE<br/>default-token-cjj68   kubernetes.io/service-account-token   3      76s</span></pre><p id="0a91" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">我们看不到<code class="fe lu lv lw lx b">Secret</code>——为什么？让我们在<code class="fe lu lv lw lx b">database</code>名称空间中列出<code class="fe lu lv lw lx b">SealedSecret</code>。</p><pre class="kj kk kl km gt nt lx nu nv aw nw bi"><span id="589c" class="nx mh it lx b gy ny nz l oa ob">$ kubectl get sealedsecret -n database<br/>NAME       AGE<br/>mysecret   109s</span></pre><p id="66a2" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated"><code class="fe lu lv lw lx b">SealedSecret</code>存在，但无法产生<code class="fe lu lv lw lx b">Secret</code>。让我们看看控制器日志。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nr ns l"/></div></figure><p id="afc2" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">我们发现有一个错误。这表明默认情况下无法更改<code class="fe lu lv lw lx b">SealedSecret</code>的名称空间。</p></div><div class="ab cl lz ma hx mb" role="separator"><span class="mc bw bk md me mf"/><span class="mc bw bk md me mf"/><span class="mc bw bk md me"/></div><div class="im in io ip iq"><h1 id="c828" class="mg mh it bd mi mj mk ml mm mn mo mp mq jz mr ka ms kc mt kd mu kf mv kg mw mx bi translated">修改机密名称</h1><p id="25c0" class="pw-post-body-paragraph ky kz it la b lb my ju ld le mz jx lg lh na lj lk ll nb ln lo lp nc lr ls lt im bi translated">现在让我们尝试修改<code class="fe lu lv lw lx b">Secret</code>名称，并将其应用到<code class="fe lu lv lw lx b">web</code>名称空间。</p><pre class="kj kk kl km gt nt lx nu nv aw nw bi"><span id="9512" class="nx mh it lx b gy ny nz l oa ob">$ cp -a sealedsecret.yaml sealedsecret-anothersecret.yaml<br/>$ sed -i 's/mysecret/anothersecret/g' sealedsecret-anothersecret.yaml<br/>$ kubectl apply -f sealedsecret-anothersecret.yaml<br/>sealedsecret.bitnami.com/anothersecret created</span></pre><p id="f321" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">在<code class="fe lu lv lw lx b">web</code>名称空间上列出<code class="fe lu lv lw lx b">Secrets</code>。</p><pre class="kj kk kl km gt nt lx nu nv aw nw bi"><span id="97ff" class="nx mh it lx b gy ny nz l oa ob">$ kubectl get secret -n web<br/>NAME                  TYPE                                  DATA   AGE<br/>default-token-6ngbx   kubernetes.io/service-account-token   3      12m<br/>mysecret              Opaque                                1      11m</span></pre><p id="123b" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">而我们没有看到<code class="fe lu lv lw lx b">anothersecret</code>。</p><p id="909d" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">让我们看看控制器日志，看看发生了什么。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nr ns l"/></div></figure><p id="f9b7" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">我们也看到了这个错误。</p><p id="7bd0" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">我们预料到了这一点，因为我们已经在<code class="fe lu lv lw lx b">strict</code>模式中创建了<code class="fe lu lv lw lx b">Secret</code>。现在让我们试着在<code class="fe lu lv lw lx b">cluster-wide</code>范围内创建<code class="fe lu lv lw lx b">Secret</code>，看看我们会得到什么。</p></div><div class="ab cl lz ma hx mb" role="separator"><span class="mc bw bk md me mf"/><span class="mc bw bk md me mf"/><span class="mc bw bk md me"/></div><div class="im in io ip iq"><h1 id="aecc" class="mg mh it bd mi mj mk ml mm mn mo mp mq jz mr ka ms kc mt kd mu kf mv kg mw mx bi translated">正在创建群集范围的“密封机密”</h1><p id="888b" class="pw-post-body-paragraph ky kz it la b lb my ju ld le mz jx lg lh na lj lk ll nb ln lo lp nc lr ls lt im bi translated">让我们创建一个<code class="fe lu lv lw lx b">Secret</code>而不指定名称空间。</p><pre class="kj kk kl km gt nt lx nu nv aw nw bi"><span id="9050" class="nx mh it lx b gy ny nz l oa ob">echo -n "This is a secret!" | kubectl create secret generic mycwsecret --dry-run --from-file=secret=/dev/stdin -o yaml &gt; secret-cw.yaml</span></pre><p id="f26f" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">使用<code class="fe lu lv lw lx b">cluster-wide</code>作用域密封<code class="fe lu lv lw lx b">Secret</code>，并将其应用于<code class="fe lu lv lw lx b">web</code>名称空间。</p><pre class="kj kk kl km gt nt lx nu nv aw nw bi"><span id="f7ca" class="nx mh it lx b gy ny nz l oa ob">$ kubeseal --format yaml --scope cluster-wide &lt;secret-cw.yaml &gt;sealedsecret-cw.yaml<br/>$ kubectl apply -n web -f sealedsecret-cw.yaml<br/>sealedsecret.bitnami.com/mycwsecret created</span></pre><p id="cee5" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">让我们看看<code class="fe lu lv lw lx b">Secret</code>是否被创建。</p><pre class="kj kk kl km gt nt lx nu nv aw nw bi"><span id="e5c6" class="nx mh it lx b gy ny nz l oa ob">$ kubectl get secret mycwsecret -n web<br/>NAME         TYPE     DATA   AGE<br/>mycwsecret   Opaque   1      19s</span></pre><p id="0e56" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">现在让我们重命名<code class="fe lu lv lw lx b">Secret</code>，并将其应用到<code class="fe lu lv lw lx b">web</code>名称空间。</p><pre class="kj kk kl km gt nt lx nu nv aw nw bi"><span id="58b3" class="nx mh it lx b gy ny nz l oa ob">$ cp -a sealedsecret-cw.yaml sealedsecret-anothercwsecret.yaml<br/>$ sed -i 's/mycwsecret/anothercwsecret/g' sealedsecret-anothercwsecret.yaml<br/>$ kubectl apply -n web -f sealedsecret-anothercwsecret.yaml<br/>sealedsecret.bitnami.com/anothercwsecret created</span></pre><p id="a40d" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">当我们得到<code class="fe lu lv lw lx b">Secret</code>时，我们看到它是可用的。</p><pre class="kj kk kl km gt nt lx nu nv aw nw bi"><span id="1312" class="nx mh it lx b gy ny nz l oa ob">$ kubectl get secret anothercwsecret -n web<br/>NAME              TYPE     DATA   AGE<br/>anothercwsecret   Opaque   1      14s</span></pre><p id="88f5" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">修改名称空间怎么样？让我们将密封的<code class="fe lu lv lw lx b">Secret</code>应用到<code class="fe lu lv lw lx b">database</code>名称空间上。</p><pre class="kj kk kl km gt nt lx nu nv aw nw bi"><span id="e4fb" class="nx mh it lx b gy ny nz l oa ob">$ kubectl apply -n database -f sealedsecret-cw.yaml<br/>sealedsecret.bitnami.com/mycwsecret created</span></pre><p id="37b3" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">当我们得到<code class="fe lu lv lw lx b">Secret</code>时，我们看到它也存在。</p><pre class="kj kk kl km gt nt lx nu nv aw nw bi"><span id="98c9" class="nx mh it lx b gy ny nz l oa ob">$ kubectl get secret mycwsecret -n database<br/>NAME         TYPE     DATA   AGE<br/>mycwsecret   Opaque   1      25s</span></pre></div><div class="ab cl lz ma hx mb" role="separator"><span class="mc bw bk md me mf"/><span class="mc bw bk md me mf"/><span class="mc bw bk md me"/></div><div class="im in io ip iq"><h1 id="57af" class="mg mh it bd mi mj mk ml mm mn mo mp mq jz mr ka ms kc mt kd mu kf mv kg mw mx bi translated">结论</h1><p id="d0c9" class="pw-post-body-paragraph ky kz it la b lb my ju ld le mz jx lg lh na lj lk ll nb ln lo lp nc lr ls lt im bi translated">感谢阅读！我希望你喜欢这篇文章。</p><p id="9ef1" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">在Git中存储和管理Kubernetes的秘密总是一个挑战，而共享秘密可以帮助您解决这个问题。</p></div></div>    
</body>
</html>