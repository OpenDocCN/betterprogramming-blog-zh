<html>
<head>
<title>Adding Regular Expression Support to an Existing Golang Tool</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">向现有Golang工具添加正则表达式支持</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/adding-regular-expression-support-to-an-existing-golang-tool-2dcbdcd3b4ed?source=collection_archive---------20-----------------------#2022-08-15">https://betterprogramming.pub/adding-regular-expression-support-to-an-existing-golang-tool-2dcbdcd3b4ed?source=collection_archive---------20-----------------------#2022-08-15</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="60bb" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">文本过滤第2部分:电子正则表达式布加洛</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/8b52e1786c07301f877f589cd5234c6f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*xMBHtDR6vTDegrxzwPwX0Q.jpeg"/></div></div></figure><p id="784a" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">这是四部分系列的第二部分(有些仍在进行中)。你可以在这里找到其他人:</p><ul class=""><li id="df7b" class="ln lo iq kt b ku kv kx ky la lp le lq li lr lm ls lt lu lv bi translated"><a class="ae lw" rel="noopener ugc nofollow" target="_blank" href="/how-to-build-a-text-filtering-log-simplifying-tool-in-go-b29d3067e092">第1部分:在Go中构建一个文本过滤工具</a></li><li id="dab1" class="ln lo iq kt b ku lx kx ly la lz le ma li mb lm ls lt lu lv bi translated"><a class="ae lw" rel="noopener ugc nofollow" target="_blank" href="/benchmarking-in-go-substrings-vs-regular-expressions-a84de7f0eb02">第3部分:在Go中对程序进行基准测试</a></li><li id="0e3d" class="ln lo iq kt b ku lx kx ly la lz le ma li mb lm ls lt lu lv bi translated"><a class="ae lw" rel="noopener ugc nofollow" target="_blank" href="/benchmarking-command-line-tools-7d00ed4813cc">第4部分:针对grep的命令行基准测试</a></li></ul><p id="a19d" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">之前，我们在Go 中构建了一个<a class="ae lw" rel="noopener ugc nofollow" target="_blank" href="/how-to-build-a-text-filtering-log-simplifying-tool-in-go-b29d3067e092">反向字符串匹配工具，目标是在调试的同时去除有噪声的日志。第一次迭代接受一个或多个关键短语来匹配源文件。这对于有些静态的、重复的行来说是很好的，但是如果我们想要删除匹配特定模式的行呢？</a></p><p id="1584" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">输入正则表达式。</p><p id="68cd" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">今天，我们将介绍Go中正则表达式的一些基础知识，以及如何扩展现有程序以向后兼容的方式添加功能。</p><h1 id="f36e" class="mc md iq bd me mf mg mh mi mj mk ml mm jw mn jx mo jz mp ka mq kc mr kd ms mt bi translated">什么是正则表达式？</h1><p id="f651" class="pw-post-body-paragraph kr ks iq kt b ku mu jr kw kx mv ju kz la mw lc ld le mx lg lh li my lk ll lm ij bi translated">正则表达式(简称regex)是一系列指定搜索模式<em class="mz">的字符。字符串搜索算法使用它们来识别文本的相关部分。</em></p><p id="61d7" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">您可能已经熟悉了通配符——使用<code class="fe na nb nc nd b">*</code>来表示任意数量的字符(包括空字符串)。Regex更进了一步。</p><p id="6260" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">它们允许您更具体地进行模式匹配。您可以使用<code class="fe na nb nc nd b">[^&lt;characters to avoid&gt;]</code>搜索除之外的任何字符<em class="mz">。你可以用<code class="fe na nb nc nd b">^&lt;phrase&gt;</code>搜索以</em>开头的短语。同样，您可以使用<code class="fe na nb nc nd b">&lt;phrase&gt;$</code>搜索以结尾的内容。你可以做的还有很多，你可以在这里了解<a class="ae lw" href="https://www.computerhope.com/jargon/r/regex.htm" rel="noopener ugc nofollow" target="_blank">，在这里</a>测试<a class="ae lw" href="https://regex101.com" rel="noopener ugc nofollow" target="_blank">。</a></p><h1 id="2899" class="mc md iq bd me mf mg mh mi mj mk ml mm jw mn jx mo jz mp ka mq kc mr kd ms mt bi translated">我们为什么关心？</h1><p id="9fcd" class="pw-post-body-paragraph kr ks iq kt b ku mu jr kw kx mv ju kz la mw lc ld le mx lg lh li my lk ll lm ij bi translated">日志消息通常非常适合子串匹配，但并不总是如此。如果我们想要删除两个特定时间戳之间的日志行，比如2022年8月1日至4日，会怎么样？我们可以使用现有的子串匹配工具，通过重复我们自己:</p><pre class="kg kh ki kj gt ne nd nf ng aw nh bi"><span id="1e7f" class="ni md iq nd b gy nj nk l nl nm">-keys="logcreated-20220801:|logcreated-20220802:|logcreated-20220803:|logcreated-20220804:</span></pre><p id="7b7f" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">或者我们可以搜索匹配以下正则表达式的模式:</p><pre class="kg kh ki kj gt ne nd nf ng aw nh bi"><span id="4b32" class="ni md iq nd b gy nj nk l nl nm">^logcreated-2022080([1-4]):</span></pre><p id="295d" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">随着查询复杂性的增加，正则表达式成为定制、可重复搜索的强大工具。</p><h1 id="5681" class="mc md iq bd me mf mg mh mi mj mk ml mm jw mn jx mo jz mp ka mq kc mr kd ms mt bi translated">添加新功能</h1><p id="7a4e" class="pw-post-body-paragraph kr ks iq kt b ku mu jr kw kx mv ju kz la mw lc ld le mx lg lh li my lk ll lm ij bi translated">正如在<a class="ae lw" rel="noopener ugc nofollow" target="_blank" href="/how-to-build-a-text-filtering-log-simplifying-tool-in-go-b29d3067e092">上一篇文章</a>中，我们应该考虑用户将如何与新功能交互。为了简单起见，我们可以假设用户将提供一组匹配的子字符串(<code class="fe na nb nc nd b">-keys</code>)或一个模式(<code class="fe na nb nc nd b">-pattern</code>)，或者两者都提供。这将使指令和错误处理逻辑变得容易——如果既没有给出<code class="fe na nb nc nd b">keys</code>也没有给出<code class="fe na nb nc nd b">pattern</code>就抱怨吧。</p><p id="789c" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">要添加反向模式匹配，我们需要执行以下操作:</p><ul class=""><li id="4ce4" class="ln lo iq kt b ku kv kx ky la lp le lq li lr lm ls lt lu lv bi translated">更新自述文件和帮助说明</li><li id="dcdf" class="ln lo iq kt b ku lx kx ly la lz le ma li mb lm ls lt lu lv bi translated">添加新标志和错误处理</li><li id="eea9" class="ln lo iq kt b ku lx kx ly la lz le ma li mb lm ls lt lu lv bi translated">编写正则表达式匹配代码</li><li id="a4cd" class="ln lo iq kt b ku lx kx ly la lz le ma li mb lm ls lt lu lv bi translated">更新处理循环以在正则表达式和子字符串匹配之间进行选择</li></ul><p id="5e95" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">为简洁起见，可在<a class="ae lw" href="https://github.com/swayne275/lineremover" rel="noopener ugc nofollow" target="_blank">工具报告</a>中查看更新的帮助和自述文件指南。</p><h2 id="33d7" class="ni md iq bd me nn no dn mi np nq dp mm la nr ns mo le nt nu mq li nv nw ms nx bi translated">添加新标志和错误处理:</h2><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ny nz l"/></div></figure><p id="4cfd" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">因为我们通过<code class="fe na nb nc nd b">getUserInput()</code>获取用户输入，并将配置存储在<code class="fe na nb nc nd b">config</code>中，所以我们只需要更新这些实体来添加一个新的标志。这里，我们只是在第11行定义新的标志，并验证它或<code class="fe na nb nc nd b">keys</code>是否已经在第19行被传入。</p><p id="7716" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">对于这段代码，我们使用另一个标准库包<a class="ae lw" href="https://pkg.go.dev/regexp" rel="noopener ugc nofollow" target="_blank"> regexp </a>来处理正则表达式匹配。我们还验证了所提供的模式实际上可以用作正则表达式。通过在这里这样做，我们可以在一个地方对用户输入相关的事情进行早期的失败。</p><p id="326e" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">注意，Go的regexpr不支持某些功能，比如<a class="ae lw" href="https://stackoverflow.com/questions/26771592/negative-look-ahead-in-go-regular-expressions" rel="noopener ugc nofollow" target="_blank">否定前瞻</a>。做一些快速的谷歌搜索，似乎有各种各样的RE2实现应该提供额外的功能，但这是另一个时间的探索。</p><h2 id="569a" class="ni md iq bd me nn no dn mi np nq dp mm la nr ns mo le nt nu mq li nv nw ms nx bi translated">编写正则表达式匹配代码:</h2><p id="0872" class="pw-post-body-paragraph kr ks iq kt b ku mu jr kw kx mv ju kz la mw lc ld le mx lg lh li my lk ll lm ij bi translated">因为我们已经编译了正则表达式并将其包含在配置中，所以我们只需要对正则表达式调用<code class="fe na nb nc nd b">MatchString()</code>，传入要检查的字符串。这将产生一个关于是否匹配的布尔值。类似于子串检查，我们可以遍历输入文件中的所有行，对它们调用<code class="fe na nb nc nd b">MatchString()</code>，并保存不匹配的行。</p><p id="cd87" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">为了简化处理逻辑，让我们给<code class="fe na nb nc nd b">config</code>添加一个接收器:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ny nz l"/></div></figure><p id="870a" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">可以在一个<code class="fe na nb nc nd b">config</code>实例上调用<code class="fe na nb nc nd b">lineMatches()</code>来确定给定的字符串是否匹配模式中提供的内容，或者关键短语中提供的内容。</p><h2 id="9710" class="ni md iq bd me nn no dn mi np nq dp mm la nr ns mo le nt nu mq li nv nw ms nx bi translated">更新处理循环</h2><p id="e423" class="pw-post-body-paragraph kr ks iq kt b ku mu jr kw kx mv ju kz la mw lc ld le mx lg lh li my lk ll lm ij bi translated"><code class="fe na nb nc nd b">transformInputImpl()</code>没有太大变化。我们将接受一个<code class="fe na nb nc nd b">*config</code>作为输入(而不是几个变量)，我们将交换:</p><pre class="kg kh ki kj gt ne nd nf ng aw nh bi"><span id="a111" class="ni md iq nd b gy nj nk l nl nm">if !substrInLine(line, keys) {</span></pre><p id="39b1" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">用于:</p><pre class="kg kh ki kj gt ne nd nf ng aw nh bi"><span id="6176" class="ni md iq nd b gy nj nk l nl nm">if !cfg.lineMatches(line) {</span></pre><p id="194b" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">这样做的一个好的副作用是，所有的行匹配逻辑都被捆绑在<code class="fe na nb nc nd b">lineMatches()</code>中，这使得对处理的进一步调整变得清晰和集中。</p><h1 id="563a" class="mc md iq bd me mf mg mh mi mj mk ml mm jw mn jx mo jz mp ka mq kc mr kd ms mt bi translated">使用工具</h1><p id="e2af" class="pw-post-body-paragraph kr ks iq kt b ku mu jr kw kx mv ju kz la mw lc ld le mx lg lh li my lk ll lm ij bi translated">基于我们之前的示例，我们现在可以替换:</p><pre class="kg kh ki kj gt ne nd nf ng aw nh bi"><span id="69f6" class="ni md iq nd b gy nj nk l nl nm">go run main.go -file="example/input.txt" -keys="hello"</span></pre><p id="c0f4" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">使用:</p><pre class="kg kh ki kj gt ne nd nf ng aw nh bi"><span id="f25f" class="ni md iq nd b gy nj nk l nl nm">go run main.go -file="example/input.txt" -pattern="hello"</span></pre><p id="6a81" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">这将完成同样的事情，但不是很令人兴奋或新的。不如我们这样做:</p><pre class="kg kh ki kj gt ne nd nf ng aw nh bi"><span id="a19b" class="ni md iq nd b gy nj nk l nl nm">go run main.go -file="example/input.txt" -pattern=".*b([r]?)ig([ht]?).*"</span></pre><p id="d8bf" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">使用<a class="ae lw" href="https://regex101.com" rel="noopener ugc nofollow" target="_blank"> regex101 </a>可以进一步解释这种模式，但本质上它匹配任何包含“big”、“brig”、“bight”或“bright”的输入行。在<code class="fe na nb nc nd b">examples/input.txt</code>中，这将只剩下<code class="fe na nb nc nd b">hello world</code>了！</p><p id="3b80" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">如果我们愿意，我们甚至可以提供一组关键短语和一个模式！</p><pre class="kg kh ki kj gt ne nd nf ng aw nh bi"><span id="8ac5" class="ni md iq nd b gy nj nk l nl nm">go run main.go -file="example/input.txt" -keys="hello" -pattern=".*b([r]?)ig([ht]?).*"</span></pre><p id="845d" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">将不会在我们的输入文件中留下任何内容。</p><h1 id="2a19" class="mc md iq bd me mf mg mh mi mj mk ml mm jw mn jx mo jz mp ka mq kc mr kd ms mt bi translated">包扎</h1><p id="1588" class="pw-post-body-paragraph kr ks iq kt b ku mu jr kw kx mv ju kz la mw lc ld le mx lg lh li my lk ll lm ij bi translated">今天，我们扩展了一个已有的工具，在不需要对核心结构做太多改变的情况下添加了额外的功能。当构建软件时，我们必须考虑当前的用例，但是考虑未来的用例是谨慎的。在设计和构建阶段考虑这一点可以允许软件在对现有代码进行最小改动的情况下进行扩展，因此减少了出现错误、麻烦和问题的空间。</p><p id="30fa" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">进一步扩展<code class="fe na nb nc nd b">lineremover</code>以接受目标文件的路径留给读者作为练习。</p><p id="8713" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">如果你克隆了<a class="ae lw" href="https://github.com/swayne275/lineremover" rel="noopener ugc nofollow" target="_blank"> repo </a>并遵循上面的过程，你就可以进行一个快速而无痛的支线任务，让你的手变得有点脏！</p></div></div>    
</body>
</html>