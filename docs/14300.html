<html>
<head>
<title>How to Use Waiters With AWS SDK</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何在AWS SDK中使用等待程序</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/using-waiters-with-aws-sdk-8ec539ac974?source=collection_archive---------4-----------------------#2022-11-26">https://betterprogramming.pub/using-waiters-with-aws-sdk-8ec539ac974?source=collection_archive---------4-----------------------#2022-11-26</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="f9f5" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">让你的代码更具可读性，减少样板逻辑</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/e204b05674761908cadf33e6fc71c627.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*eKTAszNo-jqCMigu"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">由<a class="ae kv" href="https://unsplash.com/@sevcovic23?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Petr Sevcovic </a>在<a class="ae kv" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</p></figure><p id="2b8f" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">创建、更新或删除AWS资源可能需要一些时间，并且在脚本中执行这些操作时，如果后续代码试图访问所述资源，可能会导致错误。在这篇博文中，我们将介绍什么是等待者，何时以及如何使用它们，以及在改变资源状态时如何避免任何错误。</p><p id="1ab8" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><strong class="ky ir">注意</strong>:下面的代码将使用Python和Boto3库编写，但是等待程序也可以与任何其他AWS SDKs一起使用。</p><h1 id="548b" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">先决条件</h1><ul class=""><li id="446f" class="mk ml iq ky b kz mm lc mn lf mo lj mp ln mq lr mr ms mt mu bi translated">AWS帐户</li><li id="4025" class="mk ml iq ky b kz mv lc mw lf mx lj my ln mz lr mr ms mt mu bi translated">Python3/Pip</li><li id="5f2e" class="mk ml iq ky b kz mv lc mw lf mx lj my ln mz lr mr ms mt mu bi translated">Boto3</li></ul><h1 id="c2ce" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">代码走查</h1><p id="22ec" class="pw-post-body-paragraph kw kx iq ky b kz mm jr lb lc mn ju le lf na lh li lj nb ll lm ln nc lp lq lr ij bi translated">在本演练中，我们将看到一个python脚本，它从csv文件中提取数据，并将其写入AWS上新创建的DynamoDB实例中。</p><p id="542e" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我将尝试构建一个面向服务员的用例，但是如果您已经习惯了在您的本地环境中使用Python SDK，那么可以直接滚动到服务员部分。</p><p id="f99a" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">首先，我们来看看数据集。</p><pre class="kg kh ki kj gt nd ne nf bn ng nh bi"><span id="b2bd" class="ni lt iq ne b be nj nk l nl nm">MMM,127.83,1669231715.438569<br/>AOS,61.8,1669231717.501728<br/>ABT,106.14,1669231718.50959<br/>ABBV,159.42,1669231719.519121<br/>ABMD,377.81,1669231720.609117<br/>ACN,295.34,1669231721.636138<br/>ATVI,76.44,1669231722.648533<br/>ADP,262.38,1669231725.858109<br/>A,157.01,1669231730.847122<br/>GOOGL,98.21,1669231741.430469<br/>MO,44.81,1669231743.767232<br/>AMZN,94.11,1669231744.166251<br/>AIG,61.12,1669231750.5217159<br/>ABC,165.99,1669231756.527267<br/>AAPL,150.95,1669231765.310137</span></pre><p id="54ca" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">数据文件名是<code class="fe nn no np ne b">stock_prices.csv</code>，与我们的<code class="fe nn no np ne b">example_waiters.py</code>脚本位于同一个目录中。第一列表示股票代码，第二列是其对应的价格，最后一列是unix时间戳，表示提取股票价格的时间。</p><pre class="kg kh ki kj gt nd ne nf bn ng nh bi"><span id="8d93" class="ni lt iq ne b be nj nk l nq nm">## Helper Functions<br/>def get_file_contents(file_path):<br/> f = open(file_path, "r")<br/> contents = f.readlines()<br/> f.close()<br/><br/> return [ line.strip() for line in contents ]<br/><br/>def create_item_obj_for_dynamo(line_data):<br/><br/> symbol, price, extracted_time = line_data.split(",")<br/><br/> Item = {<br/>  "symbol": { "S": symbol },<br/>  "price": { "S": price },<br/>  "extracted_time": { "S": extracted_time }<br/> }<br/><br/> return Item</span></pre><p id="c05e" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><code class="fe nn no np ne b">get_file_contents</code>函数读取我们的文件并返回其内容列表，其中列表的索引对应于csv文件中的数据行。</p><p id="6126" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><code class="fe nn no np ne b">create_item_obj_for_dynamo</code>函数将列表中的每一行转换成一个对象，该对象可以传递给dynamodb <em class="nr"> </em> <code class="fe nn no np ne b">put_item()</code> API调用的<em class="nr"> Item </em>参数。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi ns"><img src="../Images/e2626a853d32395854c8bf7d70f7cab4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*OGZhY58RqMh6lvEjQAA9Aw.jpeg"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">Boto3文档— DynamoDb客户端— Put_Item API</p></figure><p id="4569" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在<code class="fe nn no np ne b">put_item</code> api中只有两个必需的参数，即<code class="fe nn no np ne b">TableName</code>和<code class="fe nn no np ne b">Item</code>。</p><p id="080a" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">对于<code class="fe nn no np ne b">Item</code>，我们看到它需要一个对象(或python字典)，其键对应于表中的列名，其值是一个字典(字典的键对应于我们希望该列的值具有的数据类型，值是我们希望插入到该列中的内容)。</p><p id="1823" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">由于DynamoDB是一个NoSQL数据库，所以只需要为<code class="fe nn no np ne b">put_item</code>的<code class="fe nn no np ne b">Item</code>参数的每个item对象传递<code class="fe nn no np ne b">Primary Key</code>。在我们的例子中，股票代码的主键/分区键是一个<code class="fe nn no np ne b">symbol</code>。</p><pre class="kg kh ki kj gt nd ne nf bn ng nh bi"><span id="41fb" class="ni lt iq ne b be nj nk l nq nm"> Item = {<br/>  "stock": { "S": symbol },<br/>  "price": { "S": price },<br/>  "extracted_time": { "S": extracted_time }<br/> }</span></pre><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nt"><img src="../Images/abb66a5bf66be430956e757484e6f7ce.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*E8w_SWJHpmQc7VlP4NOmBQ.jpeg"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">Boto3 PutItem验证异常—密钥丢失</p></figure><p id="cd59" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">因此，如果我们用<code class="fe nn no np ne b">stock</code> <strong class="ky ir"> <em class="nr"> </em> </strong>替换<code class="fe nn no np ne b">symbol</code>，那么我们将遇到一个<code class="fe nn no np ne b">ValidationException</code>，因为没有对应于我们的表的<code class="fe nn no np ne b">Primary Key</code>的键，即<code class="fe nn no np ne b">symbol</code></p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nu"><img src="../Images/e40de81f31619f7651351a8b7f564056.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ajW33is9RlBHTQrSoq51Aw.jpeg"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">成功的放置项目API调用</p></figure><p id="3bb7" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">只要我们在对象中提供主键，我们就可以添加任何其他的键值对。</p><pre class="kg kh ki kj gt nd ne nf bn ng nh bi"><span id="5bb4" class="ni lt iq ne b be nj nk l nq nm"><br/>import boto3<br/><br/># initialize client<br/>dynamo = boto3.client("dynamodb")<br/><br/>def create_dynamo_table(table_name):<br/> try:<br/>  dynamo.create_table(<br/>   TableName=table_name,<br/>   AttributeDefinitions=[{<br/>    "AttributeName": "symbol",<br/>    "AttributeType": "S"<br/>   }],<br/>   KeySchema=[{<br/>    "AttributeName": "symbol",<br/>    "KeyType": "HASH"<br/>   }],<br/>   ProvisionedThroughput={<br/>    "ReadCapacityUnits": 1,<br/>    "WriteCapacityUnits": 1<br/>   }<br/>  )<br/><br/> except Exception as err:<br/>  print(err)<br/>  exit(1)<br/><br/>def add_item_to_table(table_name, item_obj):<br/> try:<br/>  dynamo.put_item(<br/>   TableName=table_name,<br/>   Item=item_obj<br/>  )<br/>  print(f"Successfully added {item_obj['symbol']['S']} to {table_name} table")<br/> except Exception as err:<br/>  print(f"Failed to add {item_obj['symbol']['S']} to {table_name} table")<br/>  print(err)<br/>  print("")<br/>  exit(1)</span></pre><p id="b1a0" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><code class="fe nn no np ne b">create_dynamo_table</code>函数调用<code class="fe nn no np ne b">create_table</code> api，所有显示的参数都是必需的。</p><p id="4c86" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><code class="fe nn no np ne b">KeySchema</code> <em class="nr"> </em>参数<em class="nr"> </em>是我们明确声明<code class="fe nn no np ne b">symbol</code>将是我们的分区键(通过<em class="nr">散列</em> <strong class="ky ir"> </strong>关键字)的地方，而<code class="fe nn no np ne b">AttributeDefinitions</code>是我们定义其数据类型的地方。</p><p id="48e5" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们任意将读/写容量单位设置为1，因为我们只处理非常小的数据集。<code class="fe nn no np ne b">add_item_to_table</code>函数是我们调用<code class="fe nn no np ne b">put_item</code> API的地方。</p><p id="1224" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这是我们整个脚本目前应该看起来的样子:</p><pre class="kg kh ki kj gt nd ne nf bn ng nh bi"><span id="29cb" class="ni lt iq ne b be nj nk l nq nm">## example_waiters.py<br/>import boto3<br/><br/><br/># initialize client<br/>dynamo = boto3.client("dynamodb")<br/><br/><br/>""" --- Helper Functions --- """<br/>def get_file_contents(file_path):<br/> f = open(file_path, "r")<br/> contents = f.readlines()<br/> f.close()<br/><br/> return [ line.strip() for line in contents ]<br/><br/>def create_item_obj_for_dynamo(line_data):<br/><br/> symbol, price, extracted_time = line_data.split(",")<br/><br/> Item = {<br/>  "symbol": { "S": symbol },<br/>  "price": { "S": price },<br/>  "extracted_time": { "S": extracted_time }<br/> }<br/><br/> return Item<br/><br/>""" --- API CALLS --- """<br/>def create_dynamo_table(table_name):<br/> try:<br/>  dynamo.create_table(<br/>   TableName=table_name,<br/>   AttributeDefinitions=[{<br/>    "AttributeName": "symbol",<br/>    "AttributeType": "S"<br/>   }],<br/>   KeySchema=[{<br/>    "AttributeName": "symbol",<br/>    "KeyType": "HASH"<br/>   }],<br/>   ProvisionedThroughput={<br/>    "ReadCapacityUnits": 1,<br/>    "WriteCapacityUnits": 1<br/>   }<br/>  )<br/><br/> except Exception as err:<br/>  print(err)<br/>  exit(1)<br/><br/>def add_item_to_table(table_name, item_obj):<br/> try:<br/>  dynamo.put_item(<br/>   TableName=table_name,<br/>   Item=item_obj<br/>  )<br/>  print(f"Successfully added {item_obj['symbol']['S']} to {table_name} table")<br/> except Exception as err:<br/>  print(f"Failed to add {item_obj['symbol']['S']} to {table_name} table")<br/>  print(err)<br/>  print("")<br/>  exit(1)<br/><br/><br/>def main():<br/> #initialize variables<br/> table_name = "stock-prices"<br/> file_path = "./stock_prices.csv"<br/><br/> #execute tasks<br/> create_dynamo_table(table_name)<br/><br/> stock_data_objs = get_file_contents(file_path)<br/><br/> for stock_data in stock_data_objs:<br/>  item_obj = create_item_obj_for_dynamo(stock_data)<br/>  add_item_to_table(table_name, item_obj)<br/><br/>if __name__ == "__main__":<br/> main()</span></pre><p id="4477" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在<code class="fe nn no np ne b">main</code>中，我们首先定义了<code class="fe nn no np ne b">table_name</code>和<code class="fe nn no np ne b">file_path</code>，在下一行，我们创建了dynamodb表。</p><p id="465c" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><code class="fe nn no np ne b">stock_data_objs</code>变量是一个数组，对应于<code class="fe nn no np ne b">stock_symbols.csv</code>中的每一行数据。</p><p id="df8c" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们遍历数组中的每一行数据，将其解析成一个python字典，然后将该字典传递给要添加到我们的<code class="fe nn no np ne b">stock-prices</code>表中的<code class="fe nn no np ne b">put_item</code>方法。</p><p id="12e1" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在我们继续之前，我们需要解决一个可能的问题。</p></div><div class="ab cl nv nw hu nx" role="separator"><span class="ny bw bk nz oa ob"/><span class="ny bw bk nz oa ob"/><span class="ny bw bk nz oa"/></div><div class="ij ik il im in"><h1 id="8b7d" class="ls lt iq bd lu lv oc lx ly lz od mb mc jw oe jx me jz of ka mg kc og kd mi mj bi translated">AccessDeniedException &amp; IAM权限</h1><p id="15a8" class="pw-post-body-paragraph kw kx iq ky b kz mm jr lb lc mn ju le lf na lh li lj nb ll lm ln nc lp lq lr ij bi translated">尽管代码在本地运行，但我们仍然需要确保我们拥有与IAM用户相关联的正确IAM权限。</p><p id="02f0" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">检查和查看是否缺少权限的一种快速方法是运行上面的脚本。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi oh"><img src="../Images/68a028b397f5ef713ce2dd54fe9c84aa.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*6B_f4PSyXkR1pRgX7gvt_A.jpeg"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">AccessDeniedException缺少执行操作的IAM权限</p></figure><p id="704b" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">如果在运行代码时有一个<code class="fe nn no np ne b">AccessDeniedException</code>,那么这意味着我们没有为IAM用户附加正确的权限来运行代码。本节将介绍如何添加这些权限来修复此错误。如果没有错误，可以跳过这一部分。</p><p id="b4b7" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">AWS安全令牌服务(AWS STS)是一种用于获取访问AWS资源所需的安全凭据的服务，但也可用于获取有关这些凭据的信息。为了知道在哪里添加权限，我们需要知道我们用来进行API调用的IAM用户。我们将使用STS中的<code class="fe nn no np ne b">get_caller_identity</code>方法来帮助完成这项工作。</p><pre class="kg kh ki kj gt nd ne nf bn ng nh bi"><span id="09ec" class="ni lt iq ne b be nj nk l nq nm">## get_user_arn.py<br/>import boto3<br/><br/># initialize client<br/>sts = boto3.client("sts")<br/><br/># get ARN for user<br/>response = sts.get_caller_identity()["Arn"]<br/>print(response)</span></pre><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi oi"><img src="../Images/44a1138a3f40f9490f6163cc238fb2c9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*gTgekLSUO8Ujq7nlMDPfew.jpeg"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">boto3客户端的用户ARN</p></figure><p id="f5ee" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">运行上面的脚本输出IAM用户的ARN，该用户的凭证用于对AWS进行<code class="fe nn no np ne b">boto3</code> API调用，在我的例子中，我们看到这个用户是George。现在，让我们为用户添加权限。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi oj"><img src="../Images/f370e925abd97137439260ceb0362b2f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*HnOe8gr0UvpQgdoFVxyWDw.jpeg"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">IAM用户的权限选项卡</p></figure><p id="0373" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">导航到IAM服务控制台，在侧边菜单上，单击<em class="nr">用户</em>。从那里，我们选择感兴趣的用户(在我的例子中是George)。突出显示<em class="nr">权限</em>选项卡后，现在选择<em class="nr">添加内嵌策略</em>为您的用户创建新的权限策略。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi ok"><img src="../Images/8158717d3146f83f1434cf925e1b538b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*6E2a8ertkWlEmJHlb6SwpA.jpeg"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">DynamoDB的内联权限策略</p></figure><p id="cc31" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">对于维修，选择<code class="fe nn no np ne b">DynamoDB</code>，所需的操作对应于</p><ul class=""><li id="9910" class="mk ml iq ky b kz la lc ld lf ol lj om ln on lr mr ms mt mu bi translated"><code class="fe nn no np ne b">dynamodb:CreateTable</code></li><li id="d4c3" class="mk ml iq ky b kz mv lc mw lf mx lj my ln mz lr mr ms mt mu bi translated"><code class="fe nn no np ne b">dynamodb:DescribeTable</code></li><li id="00fd" class="mk ml iq ky b kz mv lc mw lf mx lj my ln mz lr mr ms mt mu bi translated"><code class="fe nn no np ne b">dynamodb:PutItem</code></li></ul><p id="aafc" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">如果我们想在许可上更加严格，我们可以设置<em class="nr"> Resources </em>单独指向这个特定的DynamoDB表。因为我们将要创建的表名叫做<code class="fe nn no np ne b">stock-prices</code>，所以ARN将采用以下形式</p><p id="2f1c" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><code class="fe nn no np ne b">arn:aws:dynamodb:{your-region}:{your-account-id}:table/stock-prices</code></p><p id="6736" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">现在点击<em class="nr">审查政策</em></p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi oo"><img src="../Images/66a08b96d6567a8c3b305061d617326f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*DWDHOGZhV9oHwjvFjka7WA.jpeg"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">查看IAM权限策略</p></figure><p id="67ec" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">为策略命名，然后单击<em class="nr">创建策略。</em>这将附加在本地运行代码所需的权限。</p></div><div class="ab cl nv nw hu nx" role="separator"><span class="ny bw bk nz oa ob"/><span class="ny bw bk nz oa ob"/><span class="ny bw bk nz oa"/></div><div class="ij ik il im in"><h1 id="1cd4" class="ls lt iq bd lu lv oc lx ly lz od mb mc jw oe jx me jz of ka mg kc og kd mi mj bi translated">ResourceNotFoundException &amp;变通办法</h1><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi op"><img src="../Images/0292eee564374c3b89defdeaa98dd5b5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*gA_u4P_FbJaY5AQcnDtv_A.jpeg"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">Put-Item失败— ResourceNotFoundException</p></figure><p id="1f31" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">现在我们已经确保了我们有正确的权限，在运行脚本之后，我们看到我们得到了一个<code class="fe nn no np ne b">ResourceNotFoundException</code>。这里给出的声明是我们的<strong class="ky ir">股票价格</strong>表没有找到，因此没有创建。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi oq"><img src="../Images/787fee9c8d37bed93411b3f8d22f86e6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*7-cRBpeFNNTha6T6xXiadA.jpeg"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">Boto3文档—DynamoDB客户端—创建_表格注释</p></figure><p id="17b7" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">Boto3文档提到<code class="fe nn no np ne b">CreateTable</code>是异步的，这可以解释我们收到<code class="fe nn no np ne b">ResourceNotFoundException</code>的原因。</p><p id="63dc" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">由于表最初处于<em class="nr">创建</em>状态，我们需要找到一种方法，在调用<code class="fe nn no np ne b">put_api</code>之前，等待它的状态变为<em class="nr">活动</em>。</p><p id="aa7c" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><strong class="ky ir">注意</strong>:如果我们注释掉创建表格的代码，并在第一次执行几秒钟后再次运行脚本，那么我们将能够向表格中添加数据，这将解决问题。但是我们希望能够同步进行，因此只运行一次脚本。解决这个问题的一个非常常见的方法是使用<code class="fe nn no np ne b">describe_table</code> API。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi or"><img src="../Images/cba66b80d7afa501d57a03f6eb8aa6b9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*z-Uodfjuss5bI9cIcnwkIA.jpeg"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">Boto3 — DynamoDB客户端—描述_表方法</p></figure><p id="9e93" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">从<strong class="ky ir">响应语法</strong>中，我们感兴趣的是<code class="fe nn no np ne b">TableStatus</code>值</p><pre class="kg kh ki kj gt nd ne nf bn ng nh bi"><span id="7aa5" class="ni lt iq ne b be nj nk l nq nm">def get_table_status(table_name):<br/> try:<br/>  response = dynamo.describe_table(<br/>   TableName=table_name<br/>  )["Table"]<br/><br/>  print(f"The status of the table is currently: {response['TableStatus']}")<br/>  return response["TableStatus"]<br/><br/> except Exception as err:<br/>  print(err)</span></pre><p id="c3ea" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">因此，我们在脚本中添加了一个新函数来获取和记录表状态</p><pre class="kg kh ki kj gt nd ne nf bn ng nh bi"><span id="64d7" class="ni lt iq ne b be nj nk l nq nm">def main():<br/> #initialize variables<br/> table_name = "stock-prices"<br/> file_path = "./stock_prices.csv"<br/><br/> #execute tasks<br/> create_dynamo_table(table_name)<br/><br/> count = 0<br/> status_of_table = get_table_status(table_name)<br/> while status_of_table != "ACTIVE":<br/>  status_of_table = get_table_status(table_name)<br/>  count += 1<br/><br/> print(count)<br/> stock_data_objs = get_file_contents(file_path)<br/> for stock_data in stock_data_objs:<br/>  item_obj = create_item_obj_for_dynamo(stock_data)<br/>  add_item_to_table(table_name, item_obj)</span></pre><p id="3ede" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在<code class="fe nn no np ne b">create_dynamo_table</code>之后，我们有一个<code class="fe nn no np ne b">while</code>循环，它将一直循环，直到桌子的状态等于<em class="nr">活动</em>，然后它将中断循环并继续脚本的其余部分。</p><p id="ac01" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我添加了一个count变量来查看这个函数会循环多少次。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi os"><img src="../Images/22629c1ecd0f4660213b058263296c5a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*YQPDJnnOKVNsZvkuG2YbbQ.jpeg"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">while循环迭代计数</p></figure><p id="9ce4" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在这种情况下，<code class="fe nn no np ne b">describe_table</code>操作被执行了145次！这需要大量的API调用，累积起来成本会很高。</p><p id="c673" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">一个解决方法是导入<code class="fe nn no np ne b">time</code>模块并使用<code class="fe nn no np ne b">time.sleep</code></p><pre class="kg kh ki kj gt nd ne nf bn ng nh bi"><span id="ab33" class="ni lt iq ne b be nj nk l nq nm"> count = 0<br/> status_of_table = get_table_status(table_name)<br/> while status_of_table != "ACTIVE":<br/>  status_of_table = get_table_status(table_name)<br/>  time.sleep(1)<br/>  count += 1<br/> print(count)</span></pre><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi ot"><img src="../Images/6b4820244852b67e8af98d8618e350fd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*v9oJ_rk6tEL8NL3dKbqjIQ.jpeg"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">使用time.sleep(1)减少describe_table调用</p></figure><p id="f76f" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">将我们的<code class="fe nn no np ne b">while</code>循环更新为睡眠一秒钟，我们看到我们已经将<code class="fe nn no np ne b">describe_table</code>调用从145次减少到7次。有趣的是，这也告诉我们创建表大约需要7秒钟，所以我们可以使用<code class="fe nn no np ne b">time.sleep(7)</code>将调用次数减少到1次。</p><p id="4ad0" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">但是如果我们试图创建和添加的其他DynamoDB表需要更长的时间才能到达活动状态呢？为<code class="fe nn no np ne b">time.sleep</code>选择秒数似乎很随意…</p><p id="914f" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">此时，您可能会想，一定有更好的方法来做到这一点？</p><p id="23a7" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">嗯，你说得对！</p><p id="e4d3" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">所以我们终于谈到了这个博客的主题。</p><h1 id="2288" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">用等待者实现</h1><p id="a87e" class="pw-post-body-paragraph kw kx iq ky b kz mm jr lb lc mn ju le lf na lh li lj nb ll lm ln nc lp lq lr ij bi translated">等待程序轮询AWS资源的指定状态，并暂停执行，直到资源达到该状态，从而使脚本能够以同步方式运行。</p><p id="b683" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">为了初始化一个服务员，我们首先需要访问资源的<code class="fe nn no np ne b">boto3 client</code>,然后向服务员提供我们想要等待的状态。</p><p id="25c2" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">对象上的属性告诉我们给定资源等待的状态</p><pre class="kg kh ki kj gt nd ne nf bn ng nh bi"><span id="f3b2" class="ni lt iq ne b be nj nk l nq nm">import boto3<br/><br/><br/>dynamo = boto3.client("dynamodb")<br/>ec2 = boto3.client("ec2")<br/>sqs = boto3.client("sqs")<br/><br/>print("dynamo waiters:", dynamo.waiter_names)<br/>print("")<br/>print("ec2 waiters:", ec2.waiter_names)<br/>print("")<br/>print("sqs waiters:", sqs.waiter_names)</span></pre><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi ou"><img src="../Images/354c39a30f748fb28652333d86f66de5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*E4YYPGubqjLvL9NCvXuJ1Q.jpeg"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">DynamoDB、EC2和SQS客户端的可用等待状态</p></figure><p id="3d57" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们看到DynamoDB只有两种状态，在这两种状态下，我们可以使用<code class="fe nn no np ne b">waiter</code>来轮询和停止我们的执行。EC2要多得多，而SQS一个都没有。并不总是保证一个客户会有服务员。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi ov"><img src="../Images/dc937ff7af717a2a3262f14030f1b3f0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*dRz9AjRchTfW5TkLI7Vz0Q.jpeg"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">通过资源对象访问客户端对象</p></figure><p id="3494" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">当使用资源对象时，我们可以使用<code class="fe nn no np ne b">.meta.client</code>来访问我们的低级客户端对象，因此可以通过这种方式获得<code class="fe nn no np ne b">waiter_names</code>。</p><pre class="kg kh ki kj gt nd ne nf bn ng nh bi"><span id="3b1b" class="ni lt iq ne b be nj nk l nq nm">def main():<br/> #initialize variables<br/> table_name = "stock-prices"<br/> file_path = "./stock_prices.csv"<br/><br/> #execute tasks<br/> create_dynamo_table(table_name)<br/><br/> #waiter for table to become ACTIVE<br/> waiter = dynamo.get_waiter("table_exists")<br/> waiter.wait(TableName=table_name)<br/><br/> stock_data_objs = get_file_contents(file_path)<br/> for stock_data in stock_data_objs:<br/>  item_obj = create_item_obj_for_dynamo(stock_data)<br/>  add_item_to_table(table_name, item_obj)</span></pre><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi ow"><img src="../Images/fc8f734380912ce3b52ec2102d8781ca.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*RsnJtjW2gXZPlNA7-z7Zow.jpeg"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">实现服务员后的输出</p></figure><p id="d17c" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在更新我们的主函数以使用客户端的<code class="fe nn no np ne b">get_waiter</code>方法和提供的<code class="fe nn no np ne b">waiter_name</code>(在本例中是<code class="fe nn no np ne b">table_exists</code>)之后，我们能够获得我们的<code class="fe nn no np ne b">Waiter</code>对象。为了执行指定的服务员，我们在该对象上使用了<code class="fe nn no np ne b">wait</code>，我们看到我们的程序成功地创建了表并添加了所有的项目。所有这些都是在没有之前的<code class="fe nn no np ne b">while</code>循环逻辑和明确使用<code class="fe nn no np ne b">describe_table()</code> API的情况下完成的。这使得我们的代码可读性更强，也更容易管理。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi ox"><img src="../Images/f686ee6d302ec9449b44e61d7353fd64.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*v0CjbcCyYulaIwah9LzmKQ.jpeg"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">DynamoDB客户端表_exists等待程序</p></figure><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi oy"><img src="../Images/cf86af862fa63eed315fea59e1470faf.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*mKaBuPbp7QGbNWDsXOb-aA.jpeg"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">EC2客户端实例_exists等待程序</p></figure><p id="f672" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">需要注意的是，默认情况下，每个等待对象轮询资源的延迟时间不同，重试次数也不同。上面，我们看到<code class="fe nn no np ne b">DynamoDB.Waiter.TableExists</code>等待轮询资源的时间是<code class="fe nn no np ne b">EC2.Waiter.InstanceExists</code>的4倍，这会降低我们程序的速度。</p><p id="731e" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">此外，考虑到我们之前注意到的情况，我们的实例大约花了7秒钟才变成活动的<em class="nr"/>，因此在这里等待20秒钟可能太长了。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi oz"><img src="../Images/00c6b1d3dfb190b1edc4ece02e6f1a0d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Z_Hx5pZ7PJFBhN2PygzohQ.jpeg"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">DynamoDB。服务员. TableExists参数</p></figure><p id="c60e" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">幸运的是，我们可以使用<code class="fe nn no np ne b">WaiterConfig</code>参数定制<code class="fe nn no np ne b">Delay</code>和<code class="fe nn no np ne b">MaxAttempts</code>，因此<em class="nr"> </em>可以对我们的轮询尝试进行更多的控制。</p><p id="dc07" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们最终的脚本，使用服务员</p><pre class="kg kh ki kj gt nd ne nf bn ng nh bi"><span id="821c" class="ni lt iq ne b be nj nk l nq nm">## example_waiters.py<br/>import boto3<br/>from typing import List<br/><br/># initialize client<br/>dynamo = boto3.client("dynamodb")<br/><br/><br/>""" --- Helper Functions --- """<br/>def get_file_contents(file_path: str) -&gt; List[str]:<br/> f = open(file_path, "r")<br/> contents = f.readlines()<br/> f.close()<br/><br/> return [ line.strip() for line in contents ]<br/><br/>def create_item_obj_for_dynamo(line_data: str) -&gt; dict:<br/><br/> symbol, price, extracted_time = line_data.split(",")<br/><br/> Item = {<br/>  "symbol": { "S": symbol },<br/>  "price": { "S": price },<br/>  "extracted_time": { "S": extracted_time }<br/> }<br/><br/> return Item<br/><br/>""" --- API CALLS --- """<br/>def create_dynamo_table(table_name: str) -&gt; None:<br/> try:<br/>  dynamo.create_table(<br/>   TableName=table_name,<br/>   AttributeDefinitions=[{<br/>    "AttributeName": "symbol",<br/>    "AttributeType": "S"<br/>   }],<br/>   KeySchema=[{<br/>    "AttributeName": "symbol",<br/>    "KeyType": "HASH"<br/>   }],<br/>   ProvisionedThroughput={<br/>    "ReadCapacityUnits": 1,<br/>    "WriteCapacityUnits": 1<br/>   }<br/>  )<br/><br/>  print(f"Successfully created the {table_name} table")<br/><br/> except Exception as err:<br/>  print(err)<br/>  exit(1)<br/><br/>def add_item_to_table(table_name: str, item_obj: dict) -&gt; None:<br/> try:<br/>  dynamo.put_item(<br/>   TableName=table_name,<br/>   Item=item_obj<br/>  )<br/>  print(f"Successfully added {item_obj['symbol']['S']} to {table_name} table")<br/> except Exception as err:<br/>  print(f"Failed to add {item_obj['symbol']['S']} to {table_name} table")<br/>  print(err)<br/>  print("")<br/>  exit(1)<br/><br/>def main() -&gt; None:<br/> #initialize variables<br/> table_name = "stock-prices"<br/> file_path = "./stock_prices.csv"<br/><br/> create_dynamo_table(table_name)<br/><br/> #wait for table to be in ACTIVE state<br/> waiter = dynamo.get_waiter("table_exists")<br/> waiter_config = {"Delay": 2, "MaxAttempts": 10}<br/> waiter.wait(TableName=table_name, WaiterConfig=waiter_config)<br/><br/> #parse data and add to dynamo table<br/> stock_data_objs = get_file_contents(file_path)<br/> for stock_data in stock_data_objs:<br/>  item_obj = create_item_obj_for_dynamo(stock_data)<br/>  add_item_to_table(table_name, item_obj)<br/><br/>if __name__ == "__main__":<br/> main()</span></pre><h1 id="edce" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">结论</h1><p id="ac97" class="pw-post-body-paragraph kw kx iq ky b kz mm jr lb lc mn ju le lf na lh li lj nb ll lm ln nc lp lq lr ij bi translated">等待程序是暂时停止执行和轮询资源直到达到特定状态的好方法。这有助于避免在访问该资源时遇到错误。使用等待程序通过删除样板逻辑使代码更具可读性，并且可以配置为以不同的速率轮询和重试，这有助于优化您的代码。</p><p id="b247" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">感谢您的阅读！</p><p id="7a27" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">也可以随时在LinkedIn 上与我联系！</p><h1 id="f2d3" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">资源</h1><ul class=""><li id="503a" class="mk ml iq ky b kz mm lc mn lf mo lj mp ln mq lr mr ms mt mu bi translated"><a class="ae kv" href="https://boto3.amazonaws.com/v1/documentation/api/latest/reference/services/dynamodb.html#dynamodb" rel="noopener ugc nofollow" target="_blank">https://boto 3 . Amazon AWS . com/v1/documentation/API/latest/reference/services/dynamo db . html # dynamo db</a></li></ul></div></div>    
</body>
</html>