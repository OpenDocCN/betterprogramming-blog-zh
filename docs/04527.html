<html>
<head>
<title>Using Firestore With Android and Architecture Components</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">通过Android和架构组件使用Firestore</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/using-firestore-with-android-and-architecture-components-cb3b5364027e?source=collection_archive---------5-----------------------#2020-04-20">https://betterprogramming.pub/using-firestore-with-android-and-architecture-components-cb3b5364027e?source=collection_archive---------5-----------------------#2020-04-20</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="bd57" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">将组件与我们的Firestore数据集成</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/fe164e48748656169eaf94a80e476e98.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*wvgTmo8z5sqtOjfnZfPnpQ.jpeg"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">Pathum Danthanarayana 在<a class="ae ky" href="https://unsplash.com/s/photos/android?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</p></figure><p id="4731" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">Firebase Firestore和Android架构组件似乎完美契合。然而，几乎没有关于如何将这些工具结合在一起的信息。</p><p id="c0c9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这引起了<a class="ae ky" href="https://medium.com/@TJgrapes" rel="noopener">阿什顿·琼斯</a>的注意，作为回应，我写了一些文章解释如何整合它们。在本文中，我将解释如何将使用Android架构组件开发的Android应用程序与Firebase Firestore数据库集成。</p><p id="a6be" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如前所述，这是一个后续教程，但它可以遵循没有必要阅读以前的。但是如果你好奇的话，这里有:</p><div class="lv lw gp gr lx ly"><a href="https://medium.com/better-programming/create-an-app-that-uses-livedata-and-viewmodel-in-java-f8086ca94229" rel="noopener follow" target="_blank"><div class="lz ab fo"><div class="ma ab mb cl cj mc"><h2 class="bd iu gy z fp md fr fs me fu fw is bi translated">在Java中创建一个使用LiveData和ViewModel的应用程序</h2><div class="mf l"><h3 class="bd b gy z fp md fr fs me fu fw dk translated">使用Android架构组件</h3></div><div class="mg l"><p class="bd b dl z fp md fr fs me fu fw dk translated">medium.com</p></div></div><div class="mh l"><div class="mi l mj mk ml mh mm ks ly"/></div></div></a></div><div class="lv lw gp gr lx ly"><a href="https://medium.com/better-programming/how-to-set-up-a-database-with-firebase-firestore-to-use-with-android-architecture-components-992ab5df8223" rel="noopener follow" target="_blank"><div class="lz ab fo"><div class="ma ab mb cl cj mc"><h2 class="bd iu gy z fp md fr fs me fu fw is bi translated">如何使用Firebase Firestore设置数据库，以便与Android架构组件一起使用</h2><div class="mf l"><h3 class="bd b gy z fp md fr fs me fu fw dk translated">为您的Android应用添加数据库功能</h3></div><div class="mg l"><p class="bd b dl z fp md fr fs me fu fw dk translated">medium.com</p></div></div><div class="mh l"><div class="mn l mj mk ml mh mm ks ly"/></div></div></a></div></div><div class="ab cl mo mp hx mq" role="separator"><span class="mr bw bk ms mt mu"/><span class="mr bw bk ms mt mu"/><span class="mr bw bk ms mt"/></div><div class="im in io ip iq"><h1 id="f197" class="mv mw it bd mx my mz na nb nc nd ne nf jz ng ka nh kc ni kd nj kf nk kg nl nm bi translated">我们开始吧</h1><p id="1cca" class="pw-post-body-paragraph kz la it lb b lc nn ju le lf no jx lh li np lk ll lm nq lo lp lq nr ls lt lu im bi translated">如果你想从这一点继续下去，请在我的网站上下载Android项目。</p><p id="37af" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这个项目写在:</p><ul class=""><li id="2380" class="ns nt it lb b lc ld lf lg li nu lm nv lq nw lu nx ny nz oa bi translated">Android Studio 3.6.2</li><li id="7fce" class="ns nt it lb b lc ob lf oc li od lm oe lq of lu nx ny nz oa bi translated">Java 语言(一种计算机语言，尤用于创建网站)</li><li id="682f" class="ns nt it lb b lc ob lf oc li od lm oe lq of lu nx ny nz oa bi translated">精简库:AndroidX</li></ul><p id="1b12" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">您将需要自己配置Firebase Firestore数据库，因为遗憾的是它不能作为附件提供— <a class="ae ky" href="http://www.evanamargain.com/blog/android/firebase-firestore-for-android-architecture-components/" rel="noopener ugc nofollow" target="_blank">如果您需要知道如何做，这里是</a>。一旦你满足了这些先决条件，你就可以开始本教程。</p><p id="48b9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">运行应用程序，您将看到一个简单的购物清单，这是一个非常常见的示例应用程序，具有基本的架构:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi og"><img src="../Images/1be25393e5238076fa174edf562759d9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1172/format:webp/0*UXHlxLmOBkx9vNdL.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">图一。应用程序的初始视图</p></figure><h1 id="61db" class="mv mw it bd mx my oh na nb nc oi ne nf jz oj ka nh kc ok kd nj kf ol kg nl nm bi translated">从视图模型中分离实时数据</h1><p id="39f4" class="pw-post-body-paragraph kz la it lb b lc nn ju le lf no jx lh li np lk ll lm nq lo lp lq nr ls lt lu im bi translated">开发Android项目时，不断重构总是很重要的。正如鲍伯·马丁叔叔曾经提到的:</p><blockquote class="om on oo"><p id="0816" class="kz la op lb b lc ld ju le lf lg jx lh oq lj lk ll or ln lo lp os lr ls lt lu im bi translated"><em class="it">离开露营地时，一定要比你发现时干净。</em></p><p id="583e" class="kz la op lb b lc ld ju le lf lg jx lh oq lj lk ll or ln lo lp os lr ls lt lu im bi translated"><a class="ae ky" href="https://amzn.to/3amidAR" rel="noopener ugc nofollow" target="_blank"> <em class="it">清理代码。罗伯特·马丁</em> </a></p></blockquote><p id="fb09" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">您将从重构开始这个项目，以便它更好地适应MVVM架构。目前，starter项目的结构如下所示:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ot"><img src="../Images/4d47b818f2fd2951222e1c87eac008dd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*p_fQw3uIYRkH0jRm.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">图二。开始应用程序结构</p></figure><p id="9f9c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在这次重构中，您将向应用程序添加三个新包:</p><ul class=""><li id="a176" class="ns nt it lb b lc ld lf lg li nu lm nv lq nw lu nx ny nz oa bi translated"><code class="fe ou ov ow ox b">LiveData</code></li><li id="647d" class="ns nt it lb b lc ob lf oc li od lm oe lq of lu nx ny nz oa bi translated"><code class="fe ou ov ow ox b">Model</code></li><li id="068e" class="ns nt it lb b lc ob lf oc li od lm oe lq of lu nx ny nz oa bi translated"><code class="fe ou ov ow ox b">Repository</code></li></ul></div><div class="ab cl mo mp hx mq" role="separator"><span class="mr bw bk ms mt mu"/><span class="mr bw bk ms mt mu"/><span class="mr bw bk ms mt"/></div><div class="im in io ip iq"><h1 id="218d" class="mv mw it bd mx my mz na nb nc nd ne nf jz ng ka nh kc ni kd nj kf nk kg nl nm bi translated">将LiveData与视图模型分离</h1><p id="c12f" class="pw-post-body-paragraph kz la it lb b lc nn ju le lf no jx lh li np lk ll lm nq lo lp lq nr ls lt lu im bi translated">理想情况下，架构中的每个组件都应该有自己的包，以便其他开发人员知道在哪里可以找到您的项目信息。</p><p id="2bdc" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">包命名的选择因项目和结构而异。在这种情况下，我们将为每个架构部分准备一个包。首先创建一个LiveData包，右键单击项目的主文件夹，如图3所示:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi oy"><img src="../Images/b3c0437fe0010997a75d5a4ca4b4d921.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*bbIVpEUbE3oBubJi"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">图3。创建新的包菜单</p></figure><p id="e46b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">将包命名为LiveData，如下图所示。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi oz"><img src="../Images/2e05354ba38463d968a62f62cc5685e7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*hzVSzdPUUCvv60Sw.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">图4。LiveData包的名称</p></figure><p id="4bcf" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在这个新包中，创建一个名为<code class="fe ou ov ow ox b">ShoppingListLiveData</code>的Java类。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi oy"><img src="../Images/3edc2b8b22a755455fd7e666fa837541.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*cw1-FmAWg7A9ZFeH"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">图5。创建新的课程菜单</p></figure><p id="bea7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">只需添加名称，保留所有默认选项。更改后，文件夹结构应该如图6所示。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi pa"><img src="../Images/5d0ad3a887df4d8d34c5a81f594ec20b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*MiATEl36kEI0VPrp.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">图6。添加LiveData包和类后的项目结构</p></figure></div><div class="ab cl mo mp hx mq" role="separator"><span class="mr bw bk ms mt mu"/><span class="mr bw bk ms mt mu"/><span class="mr bw bk ms mt"/></div><div class="im in io ip iq"><h1 id="dd41" class="mv mw it bd mx my mz na nb nc nd ne nf jz ng ka nh kc ni kd nj kf nk kg nl nm bi translated">重命名主活动和视图模型</h1><p id="cab0" class="pw-post-body-paragraph kz la it lb b lc nn ju le lf no jx lh li np lk ll lm nq lo lp lq nr ls lt lu im bi translated">重构的另一个重要部分是给类起一个描述性的名字。通常，Android为我们提供了一个默认的活动，它总是被命名为<code class="fe ou ov ow ox b">MainActivity</code>。让我们重构一下<code class="fe ou ov ow ox b">MainActivity</code>和<code class="fe ou ov ow ox b">ViewModel</code>的名称，从这个通用的名称到一个更清晰的名称。右击文件，你会看到一个重构选项，然后点击第一个“重命名……”<strong class="lb iu"><em class="op"/></strong>(图7)，注意不要点击那个叫“重命名文件……”，因为它会改变文件，但不会改变对它的所有引用。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi oy"><img src="../Images/2cb8da85cfba81557d2d2ea436801777.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*2HCaSBEWZ1wnLSXc"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">图7。重构菜单</p></figure><p id="6018" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">单击此选项后，会出现一个对话框，要求您输入新名称，并为您提供各种选项(图8)。保留所有默认选项，只需更改名称。</p><p id="13bd" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">将<code class="fe ou ov ow ox b">ViewModel</code>的名称改为<code class="fe ou ov ow ox b">ShoppingListViewModel</code>，将<code class="fe ou ov ow ox b">MainActivity</code>改为<code class="fe ou ov ow ox b">ShoppingListMainActivity</code>。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi oy"><img src="../Images/c1156737653f0ce2e9cbff60139f77d1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*7h7Ya38aXPaXw2Yw"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">图8。重命名视图模型</p></figure><p id="d67a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">经过这些更改后，项目将如下所示:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi pb"><img src="../Images/62de0a961136653c05e21798ea4033bb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*7cp4fcSOb93ZWdzb.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">图9。重构视图模型名称后的项目结构结果</p></figure><p id="65d8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">太好了！项目现在看起来更干净，如果另一个开发者想修改你的应用程序，他们会知道每个文件的用途。</p></div><div class="ab cl mo mp hx mq" role="separator"><span class="mr bw bk ms mt mu"/><span class="mr bw bk ms mt mu"/><span class="mr bw bk ms mt"/></div><div class="im in io ip iq"><h1 id="df04" class="mv mw it bd mx my mz na nb nc nd ne nf jz ng ka nh kc ni kd nj kf nk kg nl nm bi translated">为购物清单添加模型</h1><p id="5b03" class="pw-post-body-paragraph kz la it lb b lc nn ju le lf no jx lh li np lk ll lm nq lo lp lq nr ls lt lu im bi translated">使用MVVM和几乎任何其他架构时，另一个重要的部分是为你的对象创建模型类。创建一个模型包和一个<code class="fe ou ov ow ox b">ShoppingItem</code>模型，遵循与<code class="fe ou ov ow ox b">LiveData</code>相同的步骤。结果应该如图10所示:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi pc"><img src="../Images/51a07d3f01faeee0397bc4579c2930eb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*42IESTyrZQu15jot.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">图10。购物项目模型及其包装</p></figure><p id="08b6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这个模型只有一个属性——购物清单项目的名称。在类中添加下面的代码:<code class="fe ou ov ow ox b"><em class="op">private String name;</em></code> <em class="op">。</em></p></div><div class="ab cl mo mp hx mq" role="separator"><span class="mr bw bk ms mt mu"/><span class="mr bw bk ms mt mu"/><span class="mr bw bk ms mt"/></div><div class="im in io ip iq"><p id="d984" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们将利用Android Studio代码生成器为这个类创建getter和setter。选择新添加的代码行，并右键单击它。点击菜单选项“生成”(图11)，然后选择选项“Getter和Setter”<strong class="lb iu"><em class="op"/></strong>(图12)。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi oy"><img src="../Images/4017184a0e8c06a07f89ec4f04a70f2a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*Kzg6jW5mBM69h0Wa"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">图11。生成代码的菜单</p></figure><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi oy"><img src="../Images/3c16ae2e5010e6e6d8939b8f502b448a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*HGOqe8Y4D07TqBhE"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">图12。生成getter和setter的选项</p></figure><p id="9dd7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">将出现一个对话框提示您选择字段。如果你有不止一个变量，你可能不想为每个变量都生成getters和setters。在这种情况下，您只有一个项目，因此请确保它被高亮显示，如图13所示，然后单击“确定”</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi pd"><img src="../Images/45c431a3db47344cf9723c12b559e9c5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1242/0*UHyV_W3afiPpz-S1"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">图13。选择需要getter和setter的变量</p></figure><p id="6bc5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">更改后你应该有两个新方法，和<code class="fe ou ov ow ox b">setName(String name)</code>。在这种情况下，方法是在属性之上生成的(图14)。就我个人而言，为了让代码更整洁，我更喜欢将方法放在底部，所以如果你愿意，可以重新排列它们。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi pe"><img src="../Images/58e76a3857fa010eab4a3b15d52bb79b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*9VsU_t8UE9_dbt2F.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">图14。getter和setter生成的结果</p></figure></div><div class="ab cl mo mp hx mq" role="separator"><span class="mr bw bk ms mt mu"/><span class="mr bw bk ms mt mu"/><span class="mr bw bk ms mt"/></div><div class="im in io ip iq"><h1 id="7916" class="mv mw it bd mx my mz na nb nc nd ne nf jz ng ka nh kc ni kd nj kf nk kg nl nm bi translated">创建存储库包和类</h1><p id="760d" class="pw-post-body-paragraph kz la it lb b lc nn ju le lf no jx lh li np lk ll lm nq lo lp lq nr ls lt lu im bi translated">最后，我们创建一个存储库。这在MVVM建筑中并不常见。您将看到这部分代码有不同的命名——有些是指Dao和dto，有些是指网络层。在这种情况下，我们将使用存储库来处理与后端的连接，即Firebase Firestore。</p><p id="d0a1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">使用与LiveData和Model相同的步骤，创建一个存储库包和类。您的结果将类似于图15:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi pf"><img src="../Images/d39610ba9fffad940475a08967280c2c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*aTJhiY9-lPWOmHO2.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">图15。创建存储库包和类后的项目结构</p></figure><p id="a96e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果你在这一点上运行应用程序，它应该工作，并仍然显示你在图1中看到的相同的屏幕。如果您有问题，请返回并确保您正确遵循了每一步。</p></div><div class="ab cl mo mp hx mq" role="separator"><span class="mr bw bk ms mt mu"/><span class="mr bw bk ms mt mu"/><span class="mr bw bk ms mt"/></div><div class="im in io ip iq"><h1 id="19c4" class="mv mw it bd mx my mz na nb nc nd ne nf jz ng ka nh kc ni kd nj kf nk kg nl nm bi translated">将Firestore与Android架构组件连接起来</h1><p id="100e" class="pw-post-body-paragraph kz la it lb b lc nn ju le lf no jx lh li np lk ll lm nq lo lp lq nr ls lt lu im bi translated">最后，我们得到了本教程的要点。使用我们刚刚创建的结构，我们将能够连接到Firestore，并在项目中拥有一个真正干净的架构。</p><h2 id="5fef" class="pg mw it bd mx ph pi dn nb pj pk dp nf li pl pm nh lm pn po nj lq pp pq nl pr bi translated">将存储库与Firestore连接</h2><p id="1d17" class="pw-post-body-paragraph kz la it lb b lc nn ju le lf no jx lh li np lk ll lm nq lo lp lq nr ls lt lu im bi translated">在您刚刚创建的<code class="fe ou ov ow ox b">ShoppingListRepository</code>中，添加以下代码:</p><pre class="kj kk kl km gt ps ox pt pu aw pv bi"><span id="5586" class="pg mw it ox b gy pw px l py pz">// 1 <br/>private FirebaseFirestore firebaseFirestore = FirebaseFirestore.getInstance(); </span><span id="8742" class="pg mw it ox b gy qa px l py pz">// 2 <br/>public ShoppingListLiveData getFirestoreLiveData() { <br/>  // 3 <br/>  DocumentReference documentReference = firebaseFirestore            <br/>                                          .collection("MyGroceries") <br/>                                          .document("March26-2020"); <br/>  // 4 <br/>  return new ShoppingListLiveData(); <br/>}</span></pre><p id="6856" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们来分解一下:</p><p id="56eb" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们将创建一个Firebase Firestore的新实例，如果你将这个库正确地集成到项目中，它应该是可用的。如果你有困难，回顾一下<a class="ae ky" href="http://www.evanamargain.com/blog/android/firebase-firestore-for-android-architecture-components/" rel="noopener ugc nofollow" target="_blank">这篇</a>文章中的步骤。</p><p id="e388" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe ou ov ow ox b">// 2</code>:您将创建一个<code class="fe ou ov ow ox b">getFirestoreLiveData()</code>方法，正如它的名字所说，它将返回来自Firestore的LiveData。这个方法将替代我们目前在<code class="fe ou ov ow ox b">ViewModel</code>中硬编码的<code class="fe ou ov ow ox b">loadShoppingList()</code>方法。</p><p id="f2e0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe ou ov ow ox b">// 3</code> : Firestore和LiveData的神奇就发生在这里。您只需要提供您的收藏和文档名称，这将跟踪文档中的任何更改。</p><p id="27a5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe ou ov ow ox b">// 4</code>:最后，我们创建一个新的<code class="fe ou ov ow ox b">ShoppingListLiveData</code>实例，它稍后将接收这个文档引用。然而，我还没有添加这个，因为这会导致一个错误。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi qb"><img src="../Images/5ac01ae496b6cd6b4dc3c476699774c9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*lEVEMWQXN_INuCGO.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">图16。Firestore数据库，包含代码中使用的集合和文档名称。</p></figure><p id="bd11" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">大多数情况下，当你添加新代码时，Android Studio会在你复制和粘贴时提示你导入(图17)。如果你明白了，就接受这些建议吧。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi oy"><img src="../Images/48f0f048c9a6bcc538e9a0a3ea172d87.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*Us6K3yKGgPKe8DU5"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">图17。从Android Studio导入提示。</p></figure><p id="dd4e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果您正在键入代码，您可能得不到建议，因此以下是您可能需要的输入:</p><pre class="kj kk kl km gt ps ox pt pu aw pv bi"><span id="d774" class="pg mw it ox b gy pw px l py pz">import com.evanamargain.android.myshoppinglist.LiveData.ShoppingListLiveData; <br/>import com.google.firebase.firestore.DocumentReference; <br/>import com.google.firebase.firestore.FirebaseFirestore;</span></pre><p id="d846" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果您再次运行该应用程序，它应该仍然可以工作。确保它没有损坏，看起来仍然像图1。</p><h2 id="5546" class="pg mw it bd mx ph pi dn nb pj pk dp nf li pl pm nh lm pn po nj lq pp pq nl pr bi translated">将LiveData与包含Firestore参考的存储库连接起来</h2><p id="a0ba" class="pw-post-body-paragraph kz la it lb b lc nn ju le lf no jx lh li np lk ll lm nq lo lp lq nr ls lt lu im bi translated">LiveData允许我们扩展类，以便配置接收到的数据。这个例子非常简单，所以您只需添加为购物清单提供信息的逻辑。尽管如此，仔细看看代码结构，因为它在更大、更复杂的项目中可能是有用的。</p><p id="f78d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">你要做的第一件事就是扩展和实现<code class="fe ou ov ow ox b">EventListener&lt;DocumentSnapshot&gt;</code>。您的类声明应该如下所示:</p><pre class="kj kk kl km gt ps ox pt pu aw pv bi"><span id="2ab8" class="pg mw it ox b gy pw px l py pz">public class ShoppingListLiveData extends LiveData&lt;List&lt;ShoppingItem&gt;&gt; implements EventListener&lt;DocumentSnapshot&gt; { <br/>  ... <br/>}</span></pre><p id="e6f7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">你可能想知道为什么我们需要这两个类，所以让我们看看答案:</p><ul class=""><li id="73c6" class="ns nt it lb b lc ld lf lg li nu lm nv lq nw lu nx ny nz oa bi translated"><code class="fe ou ov ow ox b">LiveData&lt;List&lt;ShoppingItem&gt;&gt;</code>，指的是将在应用程序中观察到的项目类型，我们有一个购物项目列表，但我们希望该列表来自FireStore，因此通过扩展它，您可以将默认实现修改为您自己的实现。</li><li id="701f" class="ns nt it lb b lc ob lf oc li od lm oe lq of lu nx ny nz oa bi translated"><code class="fe ou ov ow ox b">EventListener&lt;DocumentSnapshot&gt;</code>允许应用程序观察firebase并查看特定文档是否发生变化。快照是数据的固定映像—当快照发生变化时，将触发<code class="fe ou ov ow ox b">onEvent</code> <strong class="lb iu"> <em class="op"> </em> </strong>。</li></ul><p id="b1d9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">说到上面的<code class="fe ou ov ow ox b">onEvent</code>方法——因为它是<code class="fe ou ov ow ox b">EventListener&lt;DocumentSnapshot&gt;</code>的必需方法，Android Studio会给你一个错误，要求你添加它。</p><p id="0a7e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">首先，添加两个实例变量:</p><pre class="kj kk kl km gt ps ox pt pu aw pv bi"><span id="7add" class="pg mw it ox b gy pw px l py pz">private List&lt;ShoppingItem&gt; shoppingListTemp = new ArrayList&lt;&gt;(); <br/>public MutableLiveData&lt;List&lt;ShoppingItem&gt;&gt; shoppingList = new MutableLiveData&lt;&gt;();</span></pre><p id="641e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">第一行是一个临时列表，您将使用它来添加项目。在你得到这个临时列表中的所有条目后，你将把它们都添加到<code class="fe ou ov ow ox b">MutableLiveData</code>变量中，以通知视图并进行必要的更新。</p></div><div class="ab cl mo mp hx mq" role="separator"><span class="mr bw bk ms mt mu"/><span class="mr bw bk ms mt mu"/><span class="mr bw bk ms mt"/></div><div class="im in io ip iq"><h1 id="d360" class="mv mw it bd mx my mz na nb nc nd ne nf jz ng ka nh kc ni kd nj kf nk kg nl nm bi translated">onEvent方法</h1><p id="a48e" class="pw-post-body-paragraph kz la it lb b lc nn ju le lf no jx lh li np lk ll lm nq lo lp lq nr ls lt lu im bi translated">添加这两个变量后，您现在可以创建错误所需的onEvent方法，使用以下代码添加它:</p><pre class="kj kk kl km gt ps ox pt pu aw pv bi"><span id="1d46" class="pg mw it ox b gy pw px l py pz">// 1 <br/>@Override public void onEvent(@Nullable DocumentSnapshot documentSnapshot, @Nullable FirebaseFirestoreException e) { <br/>  // 2 <br/>  if(documentSnapshot != null &amp;&amp; documentSnapshot.exists()) { </span><span id="92ef" class="pg mw it ox b gy qa px l py pz">    // 3 <br/>    Map&lt;String, Object&gt; shoppingListItems = documentSnapshot.getData(); </span><span id="1bbe" class="pg mw it ox b gy qa px l py pz">    // 4 <br/>    shoppingListTemp.clear(); </span><span id="2134" class="pg mw it ox b gy qa px l py pz">    // 5 <br/>    for (Map.Entry&lt;String, Object&gt; entry : shoppingListItems.entrySet()) { <br/>      ShoppingItem itemToAdd = new ShoppingItem();   <br/>      itemToAdd.setName(entry.getValue().toString()); <br/>      shoppingListTemp.add(itemToAdd); <br/>    } </span><span id="fea8" class="pg mw it ox b gy qa px l py pz">    // 6 <br/>    shoppingList.setValue(shoppingListTemp); </span><span id="731b" class="pg mw it ox b gy qa px l py pz">  } else {<br/>    // 7 <br/>    Log.d("TAG", "error"); <br/>  } <br/>}</span></pre><p id="d57f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这是一个很长的方法，所以让我们分解一下。</p><p id="d0ff" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe ou ov ow ox b">// 1</code>:您正在覆盖所请求的方法，该方法将包含一个错误或者您指定的文档的快照(顺便说一下，是存储库中的那个)。</p><p id="a8a1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe ou ov ow ox b">// 2</code>:你正在检查你是否真的得到了快照。</p><p id="4ae9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe ou ov ow ox b">// 3</code>:文档快照一个映射，其中键是字段名称，在您的数据库中是<code class="fe ou ov ow ox b">Item1</code>、<code class="fe ou ov ow ox b">Item2</code>等。为了清楚起见，请看图19。该值是一个对象，因为您的代码不知道它将接收哪种类型的值，尽管在这种情况下，所有值都应该是字符串。</p><p id="b8b0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe ou ov ow ox b">// 4</code>:清空临时列表以避免重复。有一些方法可以将FireStore数据库中的新数据添加到LiveData中，但这不在本教程中讨论。</p><p id="1419" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe ou ov ow ox b">// 5</code>:遍历项目映射中的所有项目，并为每个项目创建一个<code class="fe ou ov ow ox b">ShoppingItem</code>实例。您为对象设置名称，并将其添加到<code class="fe ou ov ow ox b">TemporaryList</code>。</p><p id="1f51" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe ou ov ow ox b">// 6</code>:这一步是触发LiveData的关键。为了让应用程序知道LiveData发生了变化，您需要使用方法<code class="fe ou ov ow ox b">setValue()</code>——您在那里设置了临时列表。如果你选择<code class="fe ou ov ow ox b">setValue</code>每次你添加一个项目，你会刷新屏幕很多，这是没有必要的。这就是这个方法在循环外被调用的原因。</p><p id="ff44" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe ou ov ow ox b">// 7</code>:当然，在生产应用程序中，你会管理错误，也许会重试或者让用户知道。但是这是一个单独的主题——这里我们只记录错误。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi oy"><img src="../Images/29e7aae535a4f6fc6737e672138b429b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*S-dAEPFDYPU6l_bI"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">图18。文档键值对</p></figure><p id="4a86" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">完成这些更改后，您的导入应该如下所示:</p><pre class="kj kk kl km gt ps ox pt pu aw pv bi"><span id="fecc" class="pg mw it ox b gy pw px l py pz">import android.util.Log; </span><span id="9515" class="pg mw it ox b gy qa px l py pz">import com.evanamargain.android.myshoppinglist.Model.ShoppingItem; <br/>import com.google.firebase.firestore.DocumentSnapshot; <br/>import com.google.firebase.firestore.EventListener; <br/>import com.google.firebase.firestore.FirebaseFirestoreException; </span><span id="2df7" class="pg mw it ox b gy qa px l py pz">import java.util.ArrayList; <br/>import java.util.List; <br/>import java.util.Map; </span><span id="5cd2" class="pg mw it ox b gy qa px l py pz">import androidx.annotation.Nullable; <br/>import androidx.lifecycle.LiveData; <br/>import androidx.lifecycle.MutableLiveData;</span></pre><p id="57fd" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果您在此时运行应用程序，它应该仍然像开始时一样工作(图1)，因为您当前的代码仍然没有连接到<code class="fe ou ov ow ox b">View</code>或<code class="fe ou ov ow ox b">ViewModel</code>。验证它是否仍在工作。</p></div><div class="ab cl mo mp hx mq" role="separator"><span class="mr bw bk ms mt mu"/><span class="mr bw bk ms mt mu"/><span class="mr bw bk ms mt"/></div><div class="im in io ip iq"><h1 id="92fa" class="mv mw it bd mx my mz na nb nc nd ne nf jz ng ka nh kc ni kd nj kf nk kg nl nm bi translated">连接LiveData和存储库</h1><p id="90bd" class="pw-post-body-paragraph kz la it lb b lc nn ju le lf no jx lh li np lk ll lm nq lo lp lq nr ls lt lu im bi translated">现在我们有了两个部分，<code class="fe ou ov ow ox b">ShoppingListLiveData</code>和<code class="fe ou ov ow ox b">ShoppingListRepository</code>，我们必须将它们连接起来。请记住，您需要将存储库中的文档引用发送到LiveData。</p><p id="5517" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在<code class="fe ou ov ow ox b">LiveData</code>类的顶部添加一个变量来存储文档引用:</p><pre class="kj kk kl km gt ps ox pt pu aw pv bi"><span id="1825" class="pg mw it ox b gy pw px l py pz">private DocumentReference documentReference;</span></pre><p id="4f5e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这将需要以下导入:</p><pre class="kj kk kl km gt ps ox pt pu aw pv bi"><span id="2523" class="pg mw it ox b gy pw px l py pz">import com.google.firebase.firestore.DocumentReference;</span></pre><p id="cdbc" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">然后向这个类中添加一个构造函数，您将在其中初始化它。</p><pre class="kj kk kl km gt ps ox pt pu aw pv bi"><span id="59d5" class="pg mw it ox b gy pw px l py pz">public ShoppingListLiveData(DocumentReference documentReference) { <br/>  this.documentReference = documentReference; <br/>}</span></pre><p id="c41e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在您已经有了这个变量，并且它在<code class="fe ou ov ow ox b">ShoppingListLiveData</code>的构造函数中，存储库中的最后一行代码将会报怨。只需通过将返回行更改为以下内容来添加您的文档引用:</p><pre class="kj kk kl km gt ps ox pt pu aw pv bi"><span id="5d59" class="pg mw it ox b gy pw px l py pz">return new ShoppingListLiveData(documentReference);</span></pre><p id="86f3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe ou ov ow ox b">ViewModel</code>也会为此请求一个参数，只需给它赋值null，因为我们不会在那里初始化它。按如下方式更改该行:</p><pre class="kj kk kl km gt ps ox pt pu aw pv bi"><span id="909f" class="pg mw it ox b gy pw px l py pz">ShoppingListLiveData liveData = null;</span></pre><h1 id="691b" class="mv mw it bd mx my oh na nb nc oi ne nf jz oj ka nh kc ok kd nj kf ol kg nl nm bi translated">测试</h1><p id="7be9" class="pw-post-body-paragraph kz la it lb b lc nn ju le lf no jx lh li np lk ll lm nq lo lp lq nr ls lt lu im bi translated">现在运行应用程序，它终于开始工作了！你会在手机上的应用程序中看到与你在Firestore数据库中看到的完全相同的信息。现在用Firestore中的数据玩一玩:</p><ol class=""><li id="d51e" class="ns nt it lb b lc ld lf lg li nu lm nv lq nw lu qc ny nz oa bi translated">添加新项目</li><li id="c00d" class="ns nt it lb b lc ob lf oc li od lm oe lq of lu qc ny nz oa bi translated">更改值</li><li id="2763" class="ns nt it lb b lc ob lf oc li od lm oe lq of lu qc ny nz oa bi translated">删除项目</li></ol><p id="e8d9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">注意当你做所有这些改变时，应用程序是如何更新的，下面你可以看到一张图片，它是如何为我工作的。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi qd"><img src="../Images/9b5ab27a802bef4183e08d639ad7abf6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1000/0*7H3aMzxI0mcd6e0f.gif"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">图19。决赛成绩</p></figure><p id="cff9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">搞定了。我们现在有一个应用程序，使用Firestore和Android架构组件。如果你想看看这个项目最终应该如何运作，你可以在我的网站上下载完成的项目。</p><p id="1c17" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">下次见！</p></div></div>    
</body>
</html>