<html>
<head>
<title>How to Delete an Item in a Nested Object in Redux State</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何在Redux状态下删除嵌套对象中的项目</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/deleting-an-item-in-a-nested-redux-state-3de0cb3943da?source=collection_archive---------0-----------------------#2017-12-26">https://betterprogramming.pub/deleting-an-item-in-a-nested-redux-state-3de0cb3943da?source=collection_archive---------0-----------------------#2017-12-26</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="5558" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">你的Redux状态可能会变得复杂，以下是如何移除嵌套数据</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/baa126667f6e97e2ba16aaeef4b9559f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*v_shUfxgcMhfVlwM1zBFJQ.jpeg"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">照片由<a class="ae ky" href="https://unsplash.com/@lysanderyuen?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">吕山德·袁</a>在<a class="ae ky" href="https://unsplash.com/s/photos/complex?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</p></figure><p id="014a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><a class="ae ky" href="https://redux.js.org/" rel="noopener ugc nofollow" target="_blank"> Redux </a>的一个关键特点就是它的<a class="ae ky" href="https://redux.js.org/api/store/" rel="noopener ugc nofollow" target="_blank">商店</a>；它将应用程序的逻辑保存为一个状态对象。</p><p id="0c23" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">本质上，您可以在商店中触发有限数量的方法。例如，使用<code class="fe lv lw lx ly b"><a class="ae ky" href="https://redux.js.org/api/store/#getstate" rel="noopener ugc nofollow" target="_blank">getState</a></code>作为读取当前状态树的机制。</p><p id="ee9f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">你可能会问:“给国务院写信怎么样？”</p><p id="3c9e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">嗯，这就是<code class="fe lv lw lx ly b"><a class="ae ky" href="https://redux.js.org/api/store/#dispatchaction" rel="noopener ugc nofollow" target="_blank">dispatch(action)</a></code>的用武之地。这是Redux中触发状态改变的唯一方式。调度行为与<code class="fe lv lw lx ly b">reducer</code>概念紧密相关。减速器接收<code class="fe lv lw lx ly b">action</code>和<code class="fe lv lw lx ly b">state</code>，并返回新的应用状态。</p><p id="cab7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">黄金法则是，我们不会回到一个突变的状态，而是一个新的状态。根据您的动作类型，当它遇到reducer时，您可能需要以各种形式更新您的状态树。</p><ul class=""><li id="ab19" class="lz ma it lb b lc ld lf lg li mb lm mc lq md lu me mf mg mh bi translated">您可能需要向其中一个状态属性添加一个新项目。</li><li id="7c01" class="lz ma it lb b lc mi lf mj li mk lm ml lq mm lu me mf mg mh bi translated">可能需要更新或重新分配状态属性。</li><li id="9983" class="lz ma it lb b lc mi lf mj li mk lm ml lq mm lu me mf mg mh bi translated">或者，您可能需要从状态属性中删除一个项目。</li></ul><p id="b380" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这让我们想到了<a class="ae ky" href="https://redux.js.org/recipes/structuring-reducers/immutable-update-patterns/" rel="noopener ugc nofollow" target="_blank"> Redux的不可变更新(或数据修改)模式</a>的概念。不变性是关键，因为我们从来不想直接改变状态树中的值，而是总是进行复制并基于旧值返回新值。</p><p id="6c0f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">状态属性可以有许多不同的类型。但是当我们谈论数据修改模式的挑战时，<code class="fe lv lw lx ly b">Array</code>和<code class="fe lv lw lx ly b">Object</code>可以被认为是具有更多边缘情况的。</p><p id="53f9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在本文中，我们将关注一个特定的Redux数据修改模式，该模式涉及删除状态树上嵌套对象中的一个项目。</p></div><div class="ab cl mn mo hx mp" role="separator"><span class="mq bw bk mr ms mt"/><span class="mq bw bk mr ms mt"/><span class="mq bw bk mr ms"/></div><div class="im in io ip iq"><h1 id="fe3a" class="mu mv it bd mw mx my mz na nb nc nd ne jz nf ka ng kc nh kd ni kf nj kg nk nl bi translated">用例:在Redux状态下删除嵌套对象中的项目</h1><p id="ea92" class="pw-post-body-paragraph kz la it lb b lc nm ju le lf nn jx lh li no lk ll lm np lo lp lq nq ls lt lu im bi translated">假设我们有一个时尚电子商务应用程序，初始状态如下。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nr ns l"/></div></figure><p id="534a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">状态树很简单，包括几个对象键，如<code class="fe lv lw lx ly b">outfits</code>或<code class="fe lv lw lx ly b">filters</code>。</p><p id="6363" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在我们的应用程序中，我们有一个过滤机制，它根据像<code class="fe lv lw lx ly b">brand</code> <strong class="lb iu"> </strong>或<code class="fe lv lw lx ly b">colour</code>这样的属性过滤服装。例如，如果用户对具有<code class="fe lv lw lx ly b">Black</code>颜色的<code class="fe lv lw lx ly b">Bally</code>品牌的服装感兴趣并进行过滤；这将导致下面的状态树。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nr ns l"/></div></figure><p id="8db3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果我们想要一个更加用户友好的应用程序，我们可能会对显示用户选择的过滤器感兴趣；就在过滤系统下面。</p><p id="c671" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这样，用户可以选择查看他们选择的所有过滤器，并可以删除他们不再感兴趣的过滤器。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nt"><img src="../Images/7e452168e652aa911baccc435e4718c0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*366_aUREBWuC5dgUcAHF8w.png"/></div></div></figure><p id="8672" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">为了实现这个目标，我们需要一个<code class="fe lv lw lx ly b">removeFilter</code> <strong class="lb iu"> </strong> <code class="fe lv lw lx ly b">actionCreator</code> <strong class="lb iu"> </strong>，它接受显示的过滤器中的字段类型(例如，<code class="fe lv lw lx ly b">brand</code>)和索引(例如，第一个元素),并从状态树中相应的元素中删除特定的过滤器值。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nr ns l"/></div></figure><p id="4fe2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">下面的代码显示了渲染部分。通过迭代过滤列表来呈现按钮，过滤列表呈现<code class="fe lv lw lx ly b">Button</code>并向它们提供<code class="fe lv lw lx ly b">index</code>和<code class="fe lv lw lx ly b">field</code>。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nr ns l"/></div></figure></div><div class="ab cl mn mo hx mp" role="separator"><span class="mq bw bk mr ms mt"/><span class="mq bw bk mr ms mt"/><span class="mq bw bk mr ms"/></div><div class="im in io ip iq"><h1 id="36de" class="mu mv it bd mw mx my mz na nb nc nd ne jz nf ka ng kc nh kd ni kf nj kg nk nl bi translated"><strong class="ak">回购</strong></h1><p id="d67a" class="pw-post-body-paragraph kz la it lb b lc nm ju le lf nn jx lh li no lk ll lm np lo lp lq nq ls lt lu im bi translated">如果你有兴趣，<a class="ae ky" href="https://github.com/kasrakhosravi/redux-update-patterns" rel="noopener ugc nofollow" target="_blank">这里有一个回购</a> <strong class="lb iu"> </strong>更好地展示了我们在本文中涉及的用例。</p></div></div>    
</body>
</html>