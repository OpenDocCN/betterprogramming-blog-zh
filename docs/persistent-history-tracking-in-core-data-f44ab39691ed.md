# 核心数据中的持久历史跟踪

> 原文：<https://betterprogramming.pub/persistent-history-tracking-in-core-data-f44ab39691ed>

## 了解持续历史跟踪的工作原理

![](img/d5b0de35f681fac9f3d64e76cb1d9826.png)

[安德鲁·尼尔](https://unsplash.com/@andrewtneel?utm_source=medium&utm_medium=referral)在 [Unsplash](https://unsplash.com?utm_source=medium&utm_medium=referral) 上拍照。

WWDC 2017 引入了 iOS 11 的新概念:持续历史跟踪。这是苹果对合并来自应用程序扩展等几个目标的变化的回答。每当您从 Share Extension 更改核心数据数据库中的内容时，都会编写一个事务，该事务可以合并到任何其他目标中。

你可能已经读过我的文章[核心数据和应用扩展:共享一个数据库](https://medium.com/better-programming/core-data-and-app-extensions-sharing-a-single-database-24f8cac35faa)建议达尔文通知在应用扩展之间共享一个数据库。这是一个很好的解决方案，现在仍然有效，但是苹果公司并不推荐这种解决方案，它使用了未记录的达尔文通知。因此，如果你一直使用达尔文通知，我强烈建议你切换到持久历史跟踪。

# 持续历史跟踪是如何工作的？

启用持久历史跟踪后，您的应用程序将开始为核心数据存储中发生的任何更改编写事务。无论它们发生在应用程序扩展、后台环境还是你的主应用程序中，它们都被写入事务中。

应用程序的每个目标都可以获取自给定日期以来发生的交易，并将这些交易合并到本地存储中。这样，您就可以根据其他协调员的更改来更新您的商店。合并所有事务后，您可以更新合并日期，以便在下次合并时只获取新事务。

# 远程更改通知

虽然它是在 iOS 11 中引入的，但最好使用远程更改通知来实现这一功能，这是在 iOS 13 中引入的。这允许您仅在发生远程更改时获取新事务。在引入这个新功能之前，我们必须在任何合适的时候(例如在`didBecomeActive`事件期间)进行投票。获取事务的开销很大，所以最好在有新事务要获取的时候进行。

在本文中，您将看到几项性能改进，以减少需要完成的工作量。只有相关的交易被提取，而且只有在有意义的时候。

如果你想了解更多关于持久历史跟踪的信息，我还推荐你观看 WWDC 2017 [核心数据新功能](https://developer.apple.com/videos/play/wwdc2017/210/)会议，苹果在会上宣布了持久历史跟踪。

# 如何启用持续历史跟踪

如前所述，我们将启用持久历史跟踪和远程通知。我们可以通过在我们的`NSPersistentStoreDescription`中设置持久存储选项来做到这一点，我们将它用作我们的`NSPersistentContainer`的输入:

注意，我们必须在指示持久性容器加载其持久性存储之前设置这些选项。否则，这两个选项都不会有任何效果。

# 监听远程更改通知

一旦为写数据事务配置了持久性容器，就可以开始观察远程更改通知了。最好为此创建一个专用实例，这样我们就可以将代码分开。

在深入研究这些代码之前，我们首先定义一个枚举，它定义了我们所有的目标。在本例中，我们有一个应用程序和一个共享扩展:

```
public enum AppTarget: String, CaseIterable {
    case app
    case shareExtension
}
```

有了这个应用目标 enum，我们可以启动一个负责观察远程变化的`PersistentHistoryObserver`:

`processPersistentHistory`方法还没有实现，它将负责我们关于合并和清除持久历史事务的业务逻辑。

我们使用后台上下文来避免视图上下文阻塞主队列。我们还利用了一个串行操作队列，这样我们就不会因为竞争情况而处理两次事务。您可以在我的文章[Swift 中的操作和操作队列入门](https://medium.com/better-programming/getting-started-with-operations-and-operationqueues-in-swift-893c4406eabf)中了解更多关于操作队列的信息。

# 将持久历史事务合并到您的应用目标中

交易的处理分两步完成:

*   获取事务并将其合并到本地存储中。
*   合并到每个目标中的事务被清理。

我们首先实现一个实例，该实例负责获取事务并将它们合并到本地存储中。

在实现了以下扩展方法之后，这个实例将利用几个在`UserDefaults`上可用的便利方法:

这些方法允许我们获取目标之间的公共事务时间戳，以及读取和写入每个给定目标的时间戳。

# 创建持久的历史合并

以下实例负责获取当前目标的事务，将它们合并到本地存储中，并更新当前活动应用程序目标的时间戳:

这一合并遵循以下几个步骤:

*   它通过使用当前的“开始”日期获取与当前目标相关的所有事务。
*   事务被合并到后台上下文中，然后直接合并到视图上下文中，这样两个上下文都是最新的。
*   更新最后合并的历史事务时间戳，以便我们不会再次合并相同的事务。

合并利用一种方便的方法将事务合并到给定的上下文中:

# 创建事务提取器

大多数优化的逻辑都位于获取事务的专用实例中。该获取器试图通过过滤视图上下文名称和事务作者来优化用于获取给定“from”日期之后的所有事务的`fetch`请求:

为了确保此代码按预期工作，用名称和事务作者更新您的托管对象上下文是很重要的:

```
persistentContainer.viewContext.name = "view_context"
persistentContainer.viewContext.transactionAuthor = "main_app"
```

这允许您识别创建某个事务的上下文和目标，也允许优化工作。只有不是由给定上下文创建的事务才会被获取和合并，这样我们就不会合并已经存在于我们上下文中的事务。

这完成了我们的合并逻辑，并允许我们跟上远程变化。下一步是确保一旦一个事务被合并到每个现有的目标中，我们就能很好地清理。

# 清除持久历史事务

所有事务都缓存在磁盘上，会占用空间。作为平台的良民，我们需要清理旧的交易，释放空间。

我们可以通过获取合并到每个活动目标中的所有事务来做到这一点。一旦一个事务被合并到每个目标中，保留它就不再有价值，如果我们删除它也没关系。

同样，我们将为此创建一个专用实例:

这个 cleaner 实例执行几个步骤:

*   确定公共时间戳。如果公共时间戳不存在，我们仍然有需要合并到我们的目标之一的事务。因此，我们需要取消删除过程。
*   常用日期用于删除历史记录。
*   每个目标的事务时间戳都被重置，这样我们就不会在无限循环中删除历史。

这就完成了我们通过调用先前定义的`PersistentHistoryObserver`中的那些实例来实现持久历史跟踪的逻辑:

仅此而已。您的应用程序现在将保持最新，并将来自远程应用程序目标的任何传入事务合并到您的本地数据库中。

# 结论

持续历史跟踪是苹果公司建立的一个伟大的解决方案。它通过一个数据库来保持你的主应用和它的扩展都是最新的。它需要一个事务合并器和清除器来确保事务被正确处理。

谢谢！