<html>
<head>
<title>Faster Python in Docker</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Docker中更快的Python</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/faster-python-in-docker-d1a71a9b9917?source=collection_archive---------3-----------------------#2020-01-27">https://betterprogramming.pub/faster-python-in-docker-d1a71a9b9917?source=collection_archive---------3-----------------------#2020-01-27</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="5e6f" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">从您的容器中获得最佳性能</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/40de9a4db90f87f07727227477045cda.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*1oNFSb3P71Fw5mYAu1YKaQ.png"/></div></div></figure><p id="b663" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">TL；DR:通过对您的配置进行一些简单的调整，您可以将Docker容器中Python代码的执行速度提高到接近本地速度:</p><ul class=""><li id="4262" class="lq lr it kw b kx ky la lb ld ls lh lt ll lu lp lv lw lx ly bi translated">在Ubuntu主机上，Docker中的基准执行时间大约是本地时间的两倍；这种差异可以通过修改容器的安全设置来消除</li><li id="2c2c" class="lq lr it kw b kx lz la ma ld mb lh mc ll md lp lv lw lx ly bi translated">当运行优化良好的代码时，差异要小得多——而不是带有(不必要的)for循环的代码</li><li id="b197" class="lq lr it kw b kx lz la ma ld mb lh mc ll md lp lv lw lx ly bi translated">在Windows主机上，Python代码在Docker中实际上运行得更快，并且容器安全设置似乎不会对执行速度产生太大影响</li></ul><p id="6cfe" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">我测试了一堆配置。最大的好处(就执行速度而言)来自于禁用容器内活动的安全计算配置文件。当然，这涉及到必须考虑的安全问题。当运行不受信任的代码来:</p><p id="4cf4" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">启动容器时，禁用<code class="fe mf mg mh mi b">seccomp</code>并将其配置文件设置为<code class="fe mf mg mh mi b">unconfined</code>:</p><pre class="kj kk kl km gt mj mi mk ml aw mm bi"><span id="df2c" class="mn mo it mi b gy mp mq l mr ms">--security-opt seccomp=unconfined</span></pre><p id="344c" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">例如，从这段代码中运行演示容器如下所示:</p><pre class="kj kk kl km gt mj mi mk ml aw mm bi"><span id="d3ae" class="mn mo it mi b gy mp mq l mr ms">docker run -it <!-- -->--security-opt seccomp=unconfined<!-- --> 4oh4/pi</span></pre></div><div class="ab cl mt mu hx mv" role="separator"><span class="mw bw bk mx my mz"/><span class="mw bw bk mx my mz"/><span class="mw bw bk mx my"/></div><div class="im in io ip iq"><h1 id="71c5" class="na mo it bd nb nc nd ne nf ng nh ni nj jz nk ka nl kc nm kd nn kf no kg np nq bi translated">介绍</h1><p id="4374" class="pw-post-body-paragraph ku kv it kw b kx nr ju kz la ns jx lc ld nt lf lg lh nu lj lk ll nv ln lo lp im bi translated">我们最近注意到Docker容器中一些计算密集型处理的运行速度低于预期。当然，运行容器的一些开销是可以预期的，但是当它导致明显的速度下降时，我们可能会开始质疑这种便利是否值得。</p><p id="6e38" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">这在很大程度上归结于安全性。当运行可信工作负载时，我们可以选择通过禁用其中一些保护来获得更好的性能。</p><h2 id="5751" class="mn mo it bd nb nw nx dn nf ny nz dp nj ld oa ob nl lh oc od nn ll oe of np og bi translated">本文概述</h2><p id="98cc" class="pw-post-body-paragraph ku kv it kw b kx nr ju kz la ns jx lc ld nt lf lg lh nu lj lk ll nv ln lo lp im bi translated">这篇文章写得很好，所以你可以快速浏览。关键要点和方法在顶部，而结果和解释越往下越详细:</p><ol class=""><li id="30c6" class="lq lr it kw b kx ky la lb ld ls lh lt ll lu lp oh lw lx ly bi translated">使用Phoronix测试套件进行性能基准测试</li><li id="6c50" class="lq lr it kw b kx lz la ma ld mb lh mc ll md lp oh lw lx ly bi translated">自定义Python基准</li><li id="9657" class="lq lr it kw b kx lz la ma ld mb lh mc ll md lp oh lw lx ly bi translated">修改安全计算(<code class="fe mf mg mh mi b">seccomp</code>)配置文件</li><li id="de24" class="lq lr it kw b kx lz la ma ld mb lh mc ll md lp oh lw lx ly bi translated">其他设置</li><li id="bd9b" class="lq lr it kw b kx lz la ma ld mb lh mc ll md lp oh lw lx ly bi translated">结论</li></ol><p id="c27e" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">注意:这篇文章中讨论的一些变化包括关闭功能。但是功能倾向于做一些有用的事情——否则，它们就不会存在。在这种情况下，它们通常与安全相关。在做出大的改变之前，理解其中的含义和权衡，尤其是在处理共享计算资源时。</p></div><div class="ab cl mt mu hx mv" role="separator"><span class="mw bw bk mx my mz"/><span class="mw bw bk mx my mz"/><span class="mw bw bk mx my"/></div><div class="im in io ip iq"><h1 id="0774" class="na mo it bd nb nc nd ne nf ng nh ni nj jz nk ka nl kc nm kd nn kf no kg np nq bi translated">基准绩效</h1><p id="5f72" class="pw-post-body-paragraph ku kv it kw b kx nr ju kz la ns jx lc ld nt lf lg lh nu lj lk ll nv ln lo lp im bi translated">在本文中，我们使用<code class="fe mf mg mh mi b">PyBench</code>和<code class="fe mf mg mh mi b">Phoronix Test Suite</code>来测试Docker容器内部的性能。<code class="fe mf mg mh mi b">PyBench</code>混合使用内置函数调用和嵌套for循环来模拟典型的计算密集型Python应用程序。</p><p id="65d4" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">有一个现成的Docker映像，所以运行基准很简单:</p><pre class="kj kk kl km gt mj mi mk ml aw mm bi"><span id="68f2" class="mn mo it mi b gy mp mq l mr ms">$ docker run -it phoronix/pts<br/>Unable to find image ‘phoronix/pts:latest’ locally<br/>latest: Pulling from phoronix/pts<br/>be71862069d7: Downloading 86.1MB/2.3GB</span></pre><p id="2158" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">一旦容器被实例化，您应该会看到Phoronix控制台。要安装并运行基准测试，请键入:</p><pre class="kj kk kl km gt mj mi mk ml aw mm bi"><span id="526f" class="mn mo it mi b gy mp mq l mr ms">benchmark pybench</span></pre><p id="1702" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">在一些下载和安装之后，测试应该运行，结果应该显示在控制台中:</p><pre class="kj kk kl km gt mj mi mk ml aw mm bi"><span id="ff4e" class="mn mo it mi b gy mp mq l mr ms">PyBench 2018-02-16:<br/>    pts/pybench-1.1.3<br/>    Test 1 of 1<br/>    Estimated Trial Run Count:    3<br/>    Estimated Time To Completion: 8 Minutes [21:52 UTC]<br/>        Started Run 1 @ 21:45:12<br/>        Started Run 2 @ 21:46:30<br/>        Started Run 3 @ 21:47:49</span><span id="3dfe" class="mn mo it mi b gy oi mq l mr ms">Total For Average Test Times:<br/>        2973<br/>        2972<br/>        2970</span><span id="efd2" class="mn mo it mi b gy oi mq l mr ms">Average: 2972 Milliseconds<br/>    Deviation: 0.05%</span></pre><p id="faff" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">结果是完成基准测试的平均时间是2972 ms——记住，时间越短越好。本文中的基准测试结果是在4.10GHz (10核)的英特尔酷睿i9–9820 x Ubuntu计算机和1.6GHz (4核)的i5–8265 u Windows计算机上运行的。</p></div><div class="ab cl mt mu hx mv" role="separator"><span class="mw bw bk mx my mz"/><span class="mw bw bk mx my mz"/><span class="mw bw bk mx my"/></div><div class="im in io ip iq"><h1 id="4f05" class="na mo it bd nb nc nd ne nf ng nh ni nj jz nk ka nl kc nm kd nn kf no kg np nq bi translated">本地基准测试</h1><p id="096c" class="pw-post-body-paragraph ku kv it kw b kx nr ju kz la ns jx lc ld nt lf lg lh nu lj lk ll nv ln lo lp im bi translated">您还可以运行本机基准(在Docker容器之外)。在主机上安装相对容易——大多数常见系统都有二进制文件。在Ubuntu上，在<a class="ae oj" href="https://linuxconfig.org/how-to-install-the-latest-phoronix-test-suite-on-ubuntu-18-04-bionic-beaver" rel="noopener ugc nofollow" target="_blank">安装</a>之后，从控制台运行命令:</p><pre class="kj kk kl km gt mj mi mk ml aw mm bi"><span id="3cd2" class="mn mo it mi b gy mp mq l mr ms">$ phoronix-test-suite benchmark pybench</span></pre></div><div class="ab cl mt mu hx mv" role="separator"><span class="mw bw bk mx my mz"/><span class="mw bw bk mx my mz"/><span class="mw bw bk mx my"/></div><div class="im in io ip iq"><h1 id="fd24" class="na mo it bd nb nc nd ne nf ng nh ni nj jz nk ka nl kc nm kd nn kf no kg np nq bi translated">自定义Python基准</h1><p id="d616" class="pw-post-body-paragraph ku kv it kw b kx nr ju kz la ns jx lc ld nt lf lg lh nu lj lk ll nv ln lo lp im bi translated">为了确认结果，我还编写了一个定制的基准，使用随机抽样来估计pi的值。该基准包含两个实现:</p><ol class=""><li id="7b35" class="lq lr it kw b kx ky la lb ld ls lh lt ll lu lp oh lw lx ly bi translated">使用<code class="fe mf mg mh mi b">numpy</code>和矩阵的优化示例</li><li id="1020" class="lq lr it kw b kx lz la ma ld mb lh mc ll md lp oh lw lx ly bi translated">使用for循环的懒惰示例(慢得多)</li></ol><p id="9d94" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">我们将在下面看到，当运行优化良好的代码(比如使用<code class="fe mf mg mh mi b">numpy</code>)时，一些性能改进带来的好处要小得多。运行基准测试最简单的方法是从Docker Hub中提取映像:</p><pre class="kj kk kl km gt mj mi mk ml aw mm bi"><span id="2551" class="mn mo it mi b gy mp mq l mr ms">$ docker run -it 4oh4/pi</span></pre><p id="38ef" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">源代码可以在GitHub上找到:</p><div class="ok ol gp gr om on"><a href="https://github.com/4OH4/pi" rel="noopener  ugc nofollow" target="_blank"><div class="oo ab fo"><div class="op ab oq cl cj or"><h2 class="bd iu gy z fp os fr fs ot fu fw is bi translated">4OH4/pi</h2><div class="ou l"><h3 class="bd b gy z fp os fr fs ot fu fw dk translated">使用随机抽样的Python估算—基准测试的长期运行流程运行基准测试(矢量化…</h3></div><div class="ov l"><p class="bd b dl z fp os fr fs ot fu fw dk translated">github.com</p></div></div><div class="ow l"><div class="ox l oy oz pa ow pb ks on"/></div></div></a></div><p id="ef54" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">自定义基准测试的结果是10轮的平均时间，每轮是10次重复的总执行时间。</p><p id="c4ce" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">该脚本在运行优化的和未优化的代码之间交替，并在最后整理结果。</p></div><div class="ab cl mt mu hx mv" role="separator"><span class="mw bw bk mx my mz"/><span class="mw bw bk mx my mz"/><span class="mw bw bk mx my"/></div><div class="im in io ip iq"><h1 id="3a0a" class="na mo it bd nb nc nd ne nf ng nh ni nj jz nk ka nl kc nm kd nn kf no kg np nq bi translated">安全计算(seccomp)配置文件</h1><p id="c8f4" class="pw-post-body-paragraph ku kv it kw b kx nr ju kz la ns jx lc ld nt lf lg lh nu lj lk ll nv ln lo lp im bi translated">这是我发现影响速度的主要配置选项。</p><p id="1f10" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated"><code class="fe mf mg mh mi b">seccomp</code>(或安全计算模式)是Linux内核中的一个安全设施。它允许将进程限制为运行有限的系统调用子集，从而使运行不受信任的代码更加安全。默认Docker配置文件禁用了总共300多个系统调用中的大约44个。运行容器时，可以使用参数启用/禁用特定调用或删除所有限制:</p><pre class="kj kk kl km gt mj mi mk ml aw mm bi"><span id="ae62" class="mn mo it mi b gy mp mq l mr ms">--security-opt seccomp=unconfined</span></pre><p id="c2ff" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">对性能的影响非常明显，PyBench的执行时间恢复到了本机速度:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi pc"><img src="../Images/edeb33bc50d606e9476d3f326f03b870.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*TmrMZiLOU6g4fGa6NBvnSw.png"/></div></div><p class="pd pe gj gh gi pf pg bd b be z dk translated">PyBench是在Ubuntu主机上运行的结果:本机，在Docker容器内，具有标准配置，并且安全计算模式不受限制。结果是六次测试的平均值——两轮三次重复——误差线显示了获得的全部结果。</p></figure><p id="8da0" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">用<code class="fe mf mg mh mi b">seccomp=unconfined</code>在Docker中运行实际上比本地运行稍快，尽管差别很小，并且在误差范围内。</p><p id="3140" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">在运行定制基准测试时可以看到类似的结果:使用随机抽样来估计pi的值。定制基准包含两个版本的代码:一个使用<code class="fe mf mg mh mi b">numpy</code>进行优化，另一个使用基本Python中的for循环。运行优化算法时，使用<code class="fe mf mg mh mi b">seccomp=unconfined</code>获得的性能收益要小得多:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ph"><img src="../Images/c78df4ccb1ebf7948a81c14128af0ec9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*suitPfeU-N-PtXcgikj_dA.png"/></div></div><p class="pd pe gj gh gi pf pg bd b be z dk translated">在Ubuntu主机上运行自定义基准(使用随机抽样估计pi)的结果:10轮的平均值，每轮是运行10次重复的总时间。</p></figure><p id="4911" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">然而，当在Windows主机上运行时，这种方法没有产生同样的增益。自定义基准在Docker容器中实际上运行得更快，并且在运行未优化的代码时，设置<code class="fe mf mg mh mi b">seccomp=unconfined</code>对执行时间只有很小的影响:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ph"><img src="../Images/62c7a0b6bb2492156915f733a0bfa1bf.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*rHQ0Trq7raj2kSK4hhQ2vw.png"/></div></div><p class="pd pe gj gh gi pf pg bd b be z dk translated">在Windows主机上运行自定义基准测试(使用随机抽样估计pi)的结果:10轮测试的平均值，每轮测试是运行10次重复测试的总时间。</p></figure><p id="ec11" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">这让我有点吃惊，但这是一种已知的<a class="ae oj" href="https://stackoverflow.com/questions/27335744/docker-speeds-up-python-why" rel="noopener ugc nofollow" target="_blank">效应。当在Windows主机上运行时，Docker位于虚拟机之上——这与在Linux主机上运行时的架构有很大不同。</a></p><p id="fe82" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">你可以在这里找到更多关于T4和码头工人的信息。</p><p id="1433" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">以下两节详细介绍了一些其他配置选项，我尝试了这些选项，但没有发现<strong class="kw iu"> <em class="me"> </em> </strong>能够产生任何额外的好处。</p></div><div class="ab cl mt mu hx mv" role="separator"><span class="mw bw bk mx my mz"/><span class="mw bw bk mx my mz"/><span class="mw bw bk mx my"/></div><div class="im in io ip iq"><h1 id="d1f8" class="na mo it bd nb nc nd ne nf ng nh ni nj jz nk ka nl kc nm kd nn kf no kg np nq bi translated">其他设置</h1><h2 id="08e4" class="mn mo it bd nb nw nx dn nf ny nz dp nj ld oa ob nl lh oc od nn ll oe of np og bi translated">表观摩尔</h2><p id="2d23" class="pw-post-body-paragraph ku kv it kw b kx nr ju kz la ns jx lc ld nt lf lg lh nu lj lk ll nv ln lo lp im bi translated"><code class="fe mf mg mh mi b">AppArmor</code>是一个内核级的安全模块，允许在每个应用程序的基础上设置权限。<a class="ae oj" href="https://docs.docker.com/engine/security/apparmor/" rel="noopener ugc nofollow" target="_blank">默认Docker配置文件</a>提供了适度的安全设置和广泛的兼容性。</p><p id="7d17" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">我看不出修改这个设置有任何性能上的好处，但是，如果需要，您可以在启动容器时使用<code class="fe mf mg mh mi b">— -security-opt</code>参数将其配置文件设置为<code class="fe mf mg mh mi b">unconfined</code>:</p><pre class="kj kk kl km gt mj mi mk ml aw mm bi"><span id="0b34" class="mn mo it mi b gy mp mq l mr ms">--security-opt apparmor=unconfined</span></pre><h2 id="245e" class="mn mo it bd nb nw nx dn nf ny nz dp nj ld oa ob nl lh oc od nn ll oe of np og bi translated">特权模式和Linux功能</h2><p id="f740" class="pw-post-body-paragraph ku kv it kw b kx nr ju kz la ns jx lc ld nt lf lg lh nu lj lk ll nv ln lo lp im bi translated"><a class="ae oj" href="https://docs.docker.com/engine/reference/run/#runtime-privilege-and-linux-capabilities" rel="noopener ugc nofollow" target="_blank">默认</a>，Docker容器无特权运行。这限制了他们对主机的访问，是一个有用的安全网。赋予容器<code class="fe mf mg mh mi b">privileged</code>状态就赋予了它一系列的权限。<code class="fe mf mg mh mi b">seccomp</code>(见上)也被有效禁用，所以它给出了类似的加速。要授予<code class="fe mf mg mh mi b">privileged</code>状态，请在运行容器时设置参数:</p><pre class="kj kk kl km gt mj mi mk ml aw mm bi"><span id="e7b6" class="mn mo it mi b gy mp mq l mr ms">docker run -it <!-- -->--privileged=true<!-- --> 4oh4/pi</span></pre><p id="7b24" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">然而，我没有看到运行<code class="fe mf mg mh mi b">privileged</code>比运行<code class="fe mf mg mh mi b">seccomp=unconfined</code>有任何进一步的<em class="me"> </em>性能提升。所以避开它——除非你有其他用途。</p><p id="230d" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">还有向容器添加/移除Linux功能的选项。有些是默认启用的。有些是禁用的，可以添加(全部添加:<code class="fe mf mg mh mi b">--cap-add All</code>)。然而，我没有看到这样做有任何性能上的好处。</p></div><div class="ab cl mt mu hx mv" role="separator"><span class="mw bw bk mx my mz"/><span class="mw bw bk mx my mz"/><span class="mw bw bk mx my"/></div><div class="im in io ip iq"><h1 id="e6fe" class="na mo it bd nb nc nd ne nf ng nh ni nj jz nk ka nl kc nm kd nn kf no kg np nq bi translated">结束语</h1><p id="4f64" class="pw-post-body-paragraph ku kv it kw b kx nr ju kz la ns jx lc ld nt lf lg lh nu lj lk ll nv ln lo lp im bi translated">在Linux主机上运行时，修改Docker容器的安全计算配置会对性能产生显著影响。与许多事情一样，这实际上是速度和安全性之间的权衡。</p><p id="66bb" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">PyBench结果反映了典型的应用程序性能，其中有许多程序分支和循环。</p><p id="88e1" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">这里的性能提升相当大。经过优化的计算密集型工作负载(例如，使用专用库，如<code class="fe mf mg mh mi b">numpy</code>)已经比未经优化的同类产品运行得更快。修改后的<code class="fe mf mg mh mi b">seccomp</code>概要文件的性能增益要低得多。对您的工作负载的影响可能介于两者之间，这取决于操作的类型及其实现方式。</p><p id="dadb" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">在Windows主机上运行没有提供同样的性能改进。这可能与架构的不同有关，容器位于Docker虚拟机之上。在Linux主机上，容器和主机之间可以有更多的交互。</p><div class="ok ol gp gr om on"><a href="https://medium.com/@rupertt/docker-desktop-2-2-for-windows-whats-new-317ec27f6c9d" rel="noopener follow" target="_blank"><div class="oo ab fo"><div class="op ab oq cl cj or"><h2 class="bd iu gy z fp os fr fs ot fu fw is bi translated">Docker桌面2.2 Windows版—有什么新功能？</h2><div class="ou l"><h3 class="bd b gy z fp os fr fs ot fu fw dk translated">WSL 2后端选项和GUI仪表板优先考虑可用性</h3></div><div class="ov l"><p class="bd b dl z fp os fr fs ot fu fw dk translated">medium.com</p></div></div><div class="ow l"><div class="pi l oy oz pa ow pb ks on"/></div></div></a></div></div><div class="ab cl mt mu hx mv" role="separator"><span class="mw bw bk mx my mz"/><span class="mw bw bk mx my mz"/><span class="mw bw bk mx my"/></div><div class="im in io ip iq"><h1 id="a043" class="na mo it bd nb nc nd ne nf ng nh ni nj jz nk ka nl kc nm kd nn kf no kg np nq bi translated">进一步阅读</h1><p id="2d29" class="pw-post-body-paragraph ku kv it kw b kx nr ju kz la ns jx lc ld nt lf lg lh nu lj lk ll nv ln lo lp im bi translated"><a class="ae oj" href="https://medium.com/lucjuggery/docker-apparmor-30-000-foot-view-60c5a5deb7b" rel="noopener">Luc jug gery:" Docker&amp;AppArmor 30.000英尺视图"</a></p><p id="a177" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated"><a class="ae oj" href="https://docs.docker.com/engine/security/apparmor/" rel="noopener ugc nofollow" target="_blank">“码头工人的外观安全配置文件</a></p><p id="ec90" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated"><a class="ae oj" href="https://training.play-with-docker.com/security-seccomp/" rel="noopener ugc nofollow" target="_blank">玩转Docker课堂:“安全实验室:sec comp”</a></p><p id="ca53" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated"><a class="ae oj" href="https://openbenchmarking.org/test/pts/pybench" rel="noopener ugc nofollow" target="_blank">open benchmark . org:" py bench[pts/py bench]"</a></p><p id="d393" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated"><a class="ae oj" href="https://medium.com/appian-engineering/yet-another-reason-your-docker-containers-may-be-slow-on-ec2-clock-gettime-gettimeofday-and-9d92f6892048" rel="noopener">凯文·佩奇:“EC2上Docker容器可能变慢的另一个原因:clock_gettime、gettimeofday和seccomp”</a></p><p id="3ece" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated"><a class="ae oj" href="https://hackernoon.com/why-is-python-so-slow-e5074b6fe55b" rel="noopener ugc nofollow" target="_blank">“为什么Python这么慢？</a></p><p id="a5dd" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated"><a class="ae oj" href="https://stackify.com/docker-performance-improvement-tips-and-tricks/" rel="noopener ugc nofollow" target="_blank">“Docker性能改进:提示和技巧</a>”</p></div></div>    
</body>
</html>