<html>
<head>
<title>How to Use DALL-E API in Swift — Image Generation in SwiftUI</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何在Swift中使用DALL-E API——Swift ui中的图像生成</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/dall-e-api-in-swift-generate-faces-e39a2625a5a2?source=collection_archive---------2-----------------------#2022-11-22">https://betterprogramming.pub/dall-e-api-in-swift-generate-faces-e39a2625a5a2?source=collection_archive---------2-----------------------#2022-11-22</a></blockquote><div><div class="fc ii ij ik il im"/><div class="in io ip iq ir"><div class=""/><div class=""><h2 id="cb1c" class="pw-subtitle-paragraph jr it iu bd b js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki dk translated">构建一个SwiftUI应用程序，使用OpenAI的API编辑现有图像中的人脸。我们将使用视觉人脸检测请求来屏蔽人脸</h2></div><figure class="kk kl km kn gu ko gi gj paragraph-image"><div role="button" tabindex="0" class="kp kq di kr bf ks"><div class="gi gj kj"><img src="../Images/044234a5b79555ba7e8aa193fd7fb865.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*db6ZWYgKSNZMZjuhnblxAA.png"/></div></div></figure><p id="d8d1" class="pw-post-body-paragraph kv kw iu kx b ky kz jv la lb lc jy ld le lf lg lh li lj lk ll lm ln lo lp lq in bi translated">我记得我试图找出如何快速将DALL-E API集成到我的SwiftUI项目中。OpenAI没有为Swift提供文档，使用<code class="fe lr ls lt lu b">URLSession</code>的多部分数据请求是一个痛点。</p><p id="baa1" class="pw-post-body-paragraph kv kw iu kx b ky kz jv la lb lc jy ld le lf lg lh li lj lk ll lm ln lo lp lq in bi translated">我决定接受这个挑战，使用基于<code class="fe lr ls lt lu b">async/await</code>的URLSession APIs来上传图片。同时，我利用SwiftUI的<code class="fe lr ls lt lu b">AsyncImage</code>下载图片。</p><p id="3a2f" class="pw-post-body-paragraph kv kw iu kx b ky kz jv la lb lc jy ld le lf lg lh li lj lk ll lm ln lo lp lq in bi translated">但这还不是全部。我还想使用视觉框架的人脸检测请求，使用<code class="fe lr ls lt lu b">CoreGraphics</code>裁剪出人脸矩形，并最终使用OpenAI的编辑图像API生成新的矩形，就像人脸交换应用程序一样。</p><p id="3f26" class="pw-post-body-paragraph kv kw iu kx b ky kz jv la lb lc jy ld le lf lg lh li lj lk ll lm ln lo lp lq in bi translated">尽管还不能投入生产，但通过优化和设计改进，这种概念验证的潜力是无限的。</p></div><div class="ab cl lv lw hy lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="in io ip iq ir"><h1 id="c8fa" class="mc md iu bd me mf mg mh mi mj mk ml mm ka mn kb mo kd mp ke mq kg mr kh ms mt bi translated">入门指南</h1><p id="a039" class="pw-post-body-paragraph kv kw iu kx b ky mu jv la lb mv jy ld le mw lg lh li mx lk ll lm my lo lp lq in bi translated">OpenAI团队最近在公开测试版中推出了DALL-E API。在撰写本文时，以下三个API端点是可用的:</p><ul class=""><li id="6a0d" class="mz na iu kx b ky kz lb lc le nb li nc lm nd lq ne nf ng nh bi translated"><code class="fe lr ls lt lu b">/generations </code> —从文本提示生成图像</li><li id="132b" class="mz na iu kx b ky ni lb nj le nk li nl lm nm lq ne nf ng nh bi translated"><code class="fe lr ls lt lu b">/edits </code> —根据文本提示，通过遮蔽区域来编辑原始图像</li><li id="0c6c" class="mz na iu kx b ky ni lb nj le nk li nl lm nm lq ne nf ng nh bi translated"><code class="fe lr ls lt lu b">/variations </code> —生成图像的变体</li></ul><p id="25f1" class="pw-post-body-paragraph kv kw iu kx b ky kz jv la lb lc jy ld le lf lg lh li lj lk ll lm ln lo lp lq in bi translated">通过在参数<code class="fe lr ls lt lu b">n</code>(默认为1)中传递所需的数字，我们可以在单个API响应中生成1-10个图像。除此之外，它们的<code class="fe lr ls lt lu b">size</code>可以设置为<code class="fe lr ls lt lu b">256x256</code>、<code class="fe lr ls lt lu b">512x512</code>或<code class="fe lr ls lt lu b">1024x1024</code>(默认)。</p><p id="74d7" class="pw-post-body-paragraph kv kw iu kx b ky kz jv la lb lc jy ld le lf lg lh li lj lk ll lm ln lo lp lq in bi translated">要更深入地研究API并了解它们的Python和Node.js实现，请阅读OpenAI的参考指南<a class="ae nn" href="https://beta.openai.com/docs/api-reference/images" rel="noopener ugc nofollow" target="_blank">这里</a>。我们将使用CURL实现在Swift中构建我们的<code class="fe lr ls lt lu b">URLRequest</code>。当你这么做的时候，一定要从他们的<a class="ae nn" href="https://beta.openai.com/account/api-keys" rel="noopener ugc nofollow" target="_blank">控制台</a>生成你的OpenAI API密匙。我们将需要它来使用Swift运行我们的应用程序。</p><h1 id="858a" class="mc md iu bd me mf no mh mi mj np ml mm ka nq kb mo kd nr ke mq kg ns kh ms mt bi translated">我的过程</h1><p id="2c53" class="pw-post-body-paragraph kv kw iu kx b ky mu jv la lb mv jy ld le mw lg lh li mx lk ll lm my lo lp lq in bi translated">下面是构建基于OpenAI的SwiftUI应用程序的过程:</p><ul class=""><li id="777a" class="mz na iu kx b ky kz lb lc le nb li nc lm nd lq ne nf ng nh bi translated">创建一个SwiftUI TabView，其内容跨越两个选项卡来运行不同的API，即<code class="fe lr ls lt lu b">generation</code>和<code class="fe lr ls lt lu b">edits</code>。</li><li id="ae67" class="mz na iu kx b ky ni lb nj le nk li nl lm nm lq ne nf ng nh bi translated">利用视觉框架的<code class="fe lr ls lt lu b">VNDetectFaceRectanglesRequest</code>来检测人脸并将其裁剪掉，从而为<code class="fe lr ls lt lu b">/edits</code>端点生成一个遮罩图像。</li><li id="3afe" class="mz na iu kx b ky ni lb nj le nk li nl lm nm lq ne nf ng nh bi translated">使用Swift的<code class="fe lr ls lt lu b">URLSession</code>和async/await来运行我们的API请求。我们将准备一个<code class="fe lr ls lt lu b">MultipartFormDataRequest</code>来通过多部分/表单数据请求上传图像数据。</li></ul><p id="032e" class="pw-post-body-paragraph kv kw iu kx b ky kz jv la lb lc jy ld le lf lg lh li lj lk ll lm ln lo lp lq in bi translated">让我们从为URL端点构建一个Swift enum开始。代码如下:</p><pre class="kk kl km kn gu nt lu nu bn nv nw bi"><span id="d388" class="nx md iu lu b be ny nz l oa ob">enum OpenAIEndpoint: String{<br/>    <br/>    private var baseURL: String { return "https://api.openai.com/v1/images/" }<br/>    <br/>    case generations<br/>    case edits<br/>    <br/>    var url: URL {<br/>            guard let url = URL(string: baseURL) else {<br/>                preconditionFailure("The url is not valid")<br/>            }<br/>            return url.appendingPathComponent(self.rawValue)<br/>    }<br/>}</span></pre><p id="3b1f" class="pw-post-body-paragraph kv kw iu kx b ky kz jv la lb lc jy ld le lf lg lh li lj lk ll lm ln lo lp lq in bi translated">在下一节中，我们将遍历代码，通过文本提示生成图像。</p><h1 id="8954" class="mc md iu bd me mf no mh mi mj np ml mm ka nq kb mo kd nr ke mq kg ns kh ms mt bi translated">在Swift中调用OpenAI Generations API</h1><p id="5169" class="pw-post-body-paragraph kv kw iu kx b ky mu jv la lb mv jy ld le mw lg lh li mx lk ll lm my lo lp lq in bi translated">让我们设置一个<code class="fe lr ls lt lu b">ObservableObject</code>类来从API获取故事，并将它们传递给SwiftUI接口:</p><pre class="kk kl km kn gu nt lu nu bn nv nw bi"><span id="cb3e" class="nx md iu lu b be ny nz l oa ob">class OpenAIService: ObservableObject{<br/>    <br/>    let api_key_free = "&lt;INSERT_API_KEY_HERE&gt;"<br/>    <br/>    func generateImage(from prompt: String) async throws -&gt; [Photo]{<br/>        var request = URLRequest(url: OpenAIEndpoint.generations.url)<br/>        request.setValue("Bearer \(api_key_free)", forHTTPHeaderField: "Authorization")<br/>        request.setValue("application/json", forHTTPHeaderField: "Content-Type")<br/>        request.httpMethod = "POST"<br/>        <br/>        let parameters: [String: Any] = [<br/>            "prompt": prompt,<br/>            "n": 1,<br/>            "size": "256x256"<br/>        ]<br/>        <br/>        let jsonData = try? JSONSerialization.data(withJSONObject: parameters)<br/>        <br/>        request.httpBody = jsonData<br/><br/>        let (data, response) = try await URLSession.shared.data(for: request)<br/>        let dalleResponse = try? JSONDecoder().decode(DALLEResponse.self, from: data)<br/>        <br/>        return dalleResponse?.data ?? []<br/><br/>    }<br/>}</span></pre><p id="0fe5" class="pw-post-body-paragraph kv kw iu kx b ky kz jv la lb lc jy ld le lf lg lh li lj lk ll lm ln lo lp lq in bi translated">上面的代码片段中发生了大量的事情，所以让我们来分解一下:</p><ul class=""><li id="f91f" class="mz na iu kx b ky kz lb lc le nb li nc lm nd lq ne nf ng nh bi translated">我们用<code class="fe lr ls lt lu b">async throws</code>标记了<code class="fe lr ls lt lu b">generateImage</code>函数，以便在URLSession中使用新的async/await语法(并跳过完成处理程序)。</li><li id="4efe" class="mz na iu kx b ky ni lb nj le nk li nl lm nm lq ne nf ng nh bi translated">我们的<code class="fe lr ls lt lu b">URLRequest</code>由两个头字段和一个JSON主体组成。</li><li id="6b8b" class="mz na iu kx b ky ni lb nj le nk li nl lm nm lq ne nf ng nh bi translated">我们获取数据，并使用<code class="fe lr ls lt lu b">JSONDecoder()</code>将其解码为<code class="fe lr ls lt lu b">DALLEResponse</code>结构。<code class="fe lr ls lt lu b">DALLEResponse</code>的数据字段保存一个URL字符串数组。我们最终将这个数组作为<code class="fe lr ls lt lu b">[Photo]</code>返回，以填充SwiftUI中一个或多个<code class="fe lr ls lt lu b">AsyncImage</code>的列表。</li></ul><p id="58c6" class="pw-post-body-paragraph kv kw iu kx b ky kz jv la lb lc jy ld le lf lg lh li lj lk ll lm ln lo lp lq in bi translated">这里看一下我们的<code class="fe lr ls lt lu b">DALLEResponse</code>结构:</p><pre class="kk kl km kn gu nt lu nu bn nv nw bi"><span id="5d93" class="nx md iu lu b be ny nz l oa ob">struct DALLEResponse: Decodable {<br/>    let created: Int<br/>    let data: [Photo]<br/>}<br/><br/>struct Photo: Decodable {<br/>    let url: String<br/>}</span></pre><p id="6f67" class="pw-post-body-paragraph kv kw iu kx b ky kz jv la lb lc jy ld le lf lg lh li lj lk ll lm ln lo lp lq in bi translated">最后，我们将构建我们的SwiftUI视图，它由一个<code class="fe lr ls lt lu b">AsyncImage</code>、一个<code class="fe lr ls lt lu b">TextField</code>和一个<code class="fe lr ls lt lu b">Button</code>组成:</p><pre class="kk kl km kn gu nt lu nu bn nv nw bi"><span id="d382" class="nx md iu lu b be ny nz l oa ob">struct ContentView: View {<br/>    <br/>    @ObservedObject var fetcher = OpenAIService()<br/>    @State var photos : [Photo] = []<br/>    @State private var textPrompt: String = ""<br/><br/>    var body: some View {<br/>        VStack {<br/><br/>            List {<br/>               ForEach(photos, id: \.url) { photo in<br/><br/>                   AsyncImage(url: URL(string: photo.url)) { image in<br/>                               image<br/>                                   .resizable()<br/>                                   .aspectRatio(contentMode: .fit)<br/>                           } placeholder: {<br/>                               Image(systemName: "photo.fill")<br/>                           }.frame(maxWidth: .infinity, maxHeight: 500)<br/>                       .listRowInsets(.init(.zero))<br/>               }<br/>            }<br/><br/>            TextField("Enter the prompt", text: $textPrompt)<br/>                        .textFieldStyle(RoundedTextFieldStyle())<br/>                        .padding()<br/>            <br/>            Button(action: runOpenAIGeneration, label: {Text("Generate Text From Prompt")})<br/>        }<br/>        .padding()<br/>    }<br/>    <br/>    func runOpenAIGeneration(){<br/>        Task{<br/>            do{<br/>                self.photos = try await fetcher.generateImage(from: textPrompt)<br/>            }catch(let error){<br/>                print(error)<br/>            }<br/>        }<br/>    }<br/>}</span></pre><p id="e07b" class="pw-post-body-paragraph kv kw iu kx b ky kz jv la lb lc jy ld le lf lg lh li lj lk ll lm ln lo lp lq in bi translated">在上面的代码中，<code class="fe lr ls lt lu b">runOpenAIGeneration</code>动作执行<code class="fe lr ls lt lu b">URLSession</code>任务，并在<code class="fe lr ls lt lu b">AsyncImage</code>中显示图像列表。</p><h1 id="b7d6" class="mc md iu bd me mf no mh mi mj np ml mm ka nq kb mo kd nr ke mq kg ns kh ms mt bi translated">使用OpenAI编辑图像API和视觉框架生成人脸</h1><p id="b980" class="pw-post-body-paragraph kv kw iu kx b ky mu jv la lb mv jy ld le mw lg lh li mx lk ll lm my lo lp lq in bi translated">编辑原始图像和创建输出的能力是更有趣的API(我认为！).从交换面孔到生成不同的时尚服装，我们可以通过屏蔽图像中的区域并使用提示来描述新图像来做很多事情。</p><p id="ede1" class="pw-post-body-paragraph kv kw iu kx b ky kz jv la lb lc jy ld le lf lg lh li lj lk ll lm ln lo lp lq in bi translated">在这一节中，我们将使用<code class="fe lr ls lt lu b">Vision</code>框架来运行一个人脸检测请求，在检测到的人脸上绘制边界框，擦除该区域以使用核心图形创建一个蒙版图像，并运行多部分请求来生成一个新图像。</p><p id="151a" class="pw-post-body-paragraph kv kw iu kx b ky kz jv la lb lc jy ld le lf lg lh li lj lk ll lm ln lo lp lq in bi translated">让我们从设置我们的愿景请求开始。</p><h2 id="e449" class="oc md iu bd me od oe dn mi of og dp mm le oh oi mo li oj ok mq lm ol om ms on bi translated">设置视觉人脸检测器请求</h2><p id="aadd" class="pw-post-body-paragraph kv kw iu kx b ky mu jv la lb mv jy ld le mw lg lh li mx lk ll lm my lo lp lq in bi translated">下面是启动和执行一个<code class="fe lr ls lt lu b">VNDetectFaceRectanglesRequest</code>的代码:</p><pre class="kk kl km kn gu nt lu nu bn nv nw bi"><span id="230d" class="nx md iu lu b be ny nz l oa ob">class VisionRequester: ObservableObject{<br/>    <br/>    @Published var maskedImage: UIImage?<br/>    //1 - @Published<br/>    var faceRect: VNFaceObservation?<br/>    <br/>    func maskFaceUsingVisionRequest(inputImage: UIImage){<br/>        <br/>        let request = VNDetectFaceRectanglesRequest()<br/>        let handler = VNImageRequestHandler(cgImage: inputImage.cgImage!, options: [:])<br/>        Task{<br/>          do{<br/>              try handler.perform([request])<br/>              <br/>              guard let results = request.results else {return}<br/>              faceRect = results.first //2<br/>              guard let faceRect else {return}<br/><br/>              //3 - convert bounding boxes to UIKit coordinate system and erase face.<br/>  <br/>          }catch{<br/>              print(error)<br/>          }<br/>        }<br/>    }<br/>}</span></pre><p id="cdfc" class="pw-post-body-paragraph kv kw iu kx b ky kz jv la lb lc jy ld le lf lg lh li lj lk ll lm ln lo lp lq in bi translated">上述代码中发生了相当多的事情！为了确保<code class="fe lr ls lt lu b">handler.perform</code>函数不会阻塞主线程，我将它包装在一个<code class="fe lr ls lt lu b">Task</code>中。</p><p id="6281" class="pw-post-body-paragraph kv kw iu kx b ky kz jv la lb lc jy ld le lf lg lh li lj lk ll lm ln lo lp lq in bi translated">我已经注释掉了<code class="fe lr ls lt lu b">faceRect</code>上的<code class="fe lr ls lt lu b">@Published</code>属性包装器。但是理想情况下，您可以使用它来观察SwiftUI视图中的变化，并绘制具有<code class="fe lr ls lt lu b">overlay</code>和<code class="fe lr ls lt lu b">Rectangle</code>形状的边界框(在将视觉坐标转换到SwiftUI系统之后)，如下所示:</p><pre class="kk kl km kn gu nt lu nu bn nv nw bi"><span id="735e" class="nx md iu lu b be ny nz l oa ob">.overlay{<br/>     Rectangle()<br/>     .stroke(Color.green,lineWidth: 3.0)<br/>     .frame(width: rect.width, height: rect.height)<br/>     .position(x: rect.midX, y: rect.midY)                                          <br/> }</span></pre><figure class="kk kl km kn gu ko gi gj paragraph-image"><div role="button" tabindex="0" class="kp kq di kr bf ks"><div class="gi gj oo"><img src="../Images/e454e73377ece2ba9bc395714598af4e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*f3ErnnPgzX8rcwC5ANy-Hg.png"/></div></div></figure><p id="e866" class="pw-post-body-paragraph kv kw iu kx b ky kz jv la lb lc jy ld le lf lg lh li lj lk ll lm ln lo lp lq in bi translated">这既快速又简单，虽然您需要一个<code class="fe lr ls lt lu b">CGSizePreferenceKey</code>来监听图像大小变化(方向变化)并重新绘制边界框，但解决方案与问题无关。我们的问题陈述要求将屏蔽的图像上传到<code class="fe lr ls lt lu b">/edits</code>端点。是的，可以使用反向<code class="fe lr ls lt lu b">mask</code>修改器，裁剪出矩形，并将SwiftUI视图转换成UIImage。然而，我们将坚持使用ObservableObject并生成一个屏蔽的<code class="fe lr ls lt lu b">UIImage</code>，而不是在SwiftUI视图界面中执行繁重的任务</p></div><div class="ab cl lv lw hy lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="in io ip iq ir"><p id="6893" class="pw-post-body-paragraph kv kw iu kx b ky kz jv la lb lc jy ld le lf lg lh li lj lk ll lm ln lo lp lq in bi translated">因此，我们有了输入图像，并从视觉请求中检索到了<code class="fe lr ls lt lu b">VNFaceObservation</code>结果。在我们开始裁剪和创建蒙版图像之前，让我们将视觉坐标转换到UIKit系统。</p><p id="977e" class="pw-post-body-paragraph kv kw iu kx b ky kz jv la lb lc jy ld le lf lg lh li lj lk ll lm ln lo lp lq in bi translated">由于视觉坐标是标准化的(这意味着左下角是原点)并且独立于屏幕分辨率，我们将使用以下代码转换和缩放该框:</p><pre class="kk kl km kn gu nt lu nu bn nv nw bi"><span id="2f5d" class="nx md iu lu b be ny nz l oa ob">func getBoundingBoxes(rect : VNFaceObservation, on imageSize: CGSize) -&gt; CGRect {<br/>        <br/>        let transform = CGAffineTransform(scaleX: 1, y: -1).translatedBy(x: 0, y: -imageSize.height)<br/>        let scale = CGAffineTransform.identity.scaledBy(x: imageSize.width, y: imageSize.height)<br/><br/>        let bounds = rect.boundingBox.applying(scale).applying(transform)<br/>        <br/>        return bounds<br/>        <br/>}</span></pre><h1 id="0532" class="mc md iu bd me mf no mh mi mj np ml mm ka nq kb mo kd nr ke mq kg ns kh ms mt bi translated">使用CoreGraphics从UIImage中擦除零件</h1><p id="cd64" class="pw-post-body-paragraph kv kw iu kx b ky mu jv la lb mv jy ld le mw lg lh li mx lk ll lm my lo lp lq in bi translated">下面是从图像中剪切出边界框并用透明区域替换它的代码:</p><pre class="kk kl km kn gu nt lu nu bn nv nw bi"><span id="aa09" class="nx md iu lu b be ny nz l oa ob">func erase(region: CGRect, from image: UIImage) -&gt; UIImage? {<br/>        UIGraphicsBeginImageContext(image.size)<br/>        image.draw(at: CGPoint.zero)<br/>        let context = UIGraphicsGetCurrentContext()!<br/>        let bez = UIBezierPath(rect: region)<br/>        context.addPath(bez.cgPath)<br/>        context.clip()<br/>        context.clear(CGRect(x:0,y:0,width: image.size.width,height: image.size.height))<br/>        let newImage = UIGraphicsGetImageFromCurrentImageContext()<br/>        UIGraphicsEndImageContext()<br/>        <br/>        return newImage<br/>}</span></pre><p id="6347" class="pw-post-body-paragraph kv kw iu kx b ky kz jv la lb lc jy ld le lf lg lh li lj lk ll lm ln lo lp lq in bi translated"><code class="fe lr ls lt lu b">context.clip()</code>将绘图限制在所提供的<code class="fe lr ls lt lu b">UIBezierPath</code>内的区域。因此，通过在下一行设置<code class="fe lr ls lt lu b">context.clear</code>，我们要求CoreGraphics将边界框内的部分标记为透明。</p></div><div class="ab cl lv lw hy lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="in io ip iq ir"><p id="eefe" class="pw-post-body-paragraph kv kw iu kx b ky kz jv la lb lc jy ld le lf lg lh li lj lk ll lm ln lo lp lq in bi translated">我们更新后的<code class="fe lr ls lt lu b">maskFaceUsingVisionRequest</code>函数如下所示:</p><pre class="kk kl km kn gu nt lu nu bn nv nw bi"><span id="8d43" class="nx md iu lu b be ny nz l oa ob">func maskFaceUsingVisionRequest(inputImage: UIImage){<br/>        <br/>        let request = VNDetectFaceRectanglesRequest()<br/>        let handler = VNImageRequestHandler(cgImage: inputImage.cgImage!, options: [:])<br/>        <br/>        Task{<br/>            <br/>            do{<br/>                try handler.perform([request])<br/>                <br/>                guard let results = request.results else {return}<br/>                faceRect = results.first<br/>                guard let faceRect else {return}<br/>                <br/>                let box = getBoundingBoxes(rect: faceRect, on: inputImage.size)<br/>                <br/>                await MainActor.run{<br/>                    self.maskedImage = erase(region: box, from: inputImage)<br/>                }<br/>                <br/>            }catch{<br/>                print(error)<br/>            }<br/>        }<br/>}</span></pre><p id="e913" class="pw-post-body-paragraph kv kw iu kx b ky kz jv la lb lc jy ld le lf lg lh li lj lk ll lm ln lo lp lq in bi translated">由于<code class="fe lr ls lt lu b">maskedImage</code>是一个<code class="fe lr ls lt lu b">Published</code>属性，它需要从主线程更新。遵循最新的Swift 5.5并发实践，我们将其包装在<code class="fe lr ls lt lu b">MainActor.run</code>中。由于<code class="fe lr ls lt lu b">MainActor.run</code>是一个异步函数，我们将其标记为<code class="fe lr ls lt lu b">await</code>。</p><p id="fd24" class="pw-post-body-paragraph kv kw iu kx b ky kz jv la lb lc jy ld le lf lg lh li lj lk ll lm ln lo lp lq in bi translated">一切就绪！我们已经成功生成了一个屏蔽图像。是时候运行我们的DALL-E API了！</p><h1 id="f6a2" class="mc md iu bd me mf no mh mi mj np ml mm ka nq kb mo kd nr ke mq kg ns kh ms mt bi translated">使用URLSession将图像上传到OpenAI DALL-E API</h1><p id="d885" class="pw-post-body-paragraph kv kw iu kx b ky mu jv la lb mv jy ld le mw lg lh li mx lk ll lm my lo lp lq in bi translated">API要求图像为方形，小于&lt;4MB, with the masked image having an alpha channel.</p><p id="816e" class="pw-post-body-paragraph kv kw iu kx b ky kz jv la lb lc jy ld le lf lg lh li lj lk ll lm ln lo lp lq in bi translated">Here’s the code to execute our network request using async/await:</p><pre class="kk kl km kn gu nt lu nu bn nv nw bi"><span id="1a31" class="nx md iu lu b be ny nz l oa ob">func generateEditedImage(from image: UIImage, with mask: UIImage) async throws -&gt; [Photo]  {<br/>    <br/>        guard let imageData = image.pngData() else{return []}<br/>        guard let maskData = mask.pngData() else{return []}<br/>        <br/>        let formFields: [String: String] = [<br/>            "prompt": "A woman wearing a red dress with an angry face",<br/>            "size": "256x256"<br/>        ]<br/>        <br/>        let multipart = MultipartFormDataRequest(url: OpenAIEndpoint.edits.url)<br/>        multipart.addDataField(fieldName:  "image", fileName: "image.png", data: imageData, mimeType: "image/png")<br/>        multipart.addDataField(fieldName:  "mask", fileName: "mask.png", data: maskData, mimeType: "image/png")<br/>        <br/>        for (key, value) in formFields {<br/>            multipart.addTextField(named: key, value: value)<br/>        }<br/><br/>        var request = multipart.asURLRequest()<br/>        request.setValue("Bearer \(api_key_free)", forHTTPHeaderField: "Authorization")<br/>        <br/>        let (data, response) = try await URLSession.shared.data(for: request)<br/>        <br/>        <br/>        let dalleResponse = try? JSONDecoder().decode(DALLEResponse.self, from: data)<br/>        <br/>        return dalleResponse?.data ?? []<br/>        <br/>}</span></pre><p id="51c5" class="pw-post-body-paragraph kv kw iu kx b ky kz jv la lb lc jy ld le lf lg lh li lj lk ll lm ln lo lp lq in bi translated"><strong class="kx iv">注</strong>:相关字段<code class="fe lr ls lt lu b">mask</code>和<code class="fe lr ls lt lu b">image</code>只能上传PNG数据。</p><p id="204b" class="pw-post-body-paragraph kv kw iu kx b ky kz jv la lb lc jy ld le lf lg lh li lj lk ll lm ln lo lp lq in bi translated"><code class="fe lr ls lt lu b"><a class="ae nn" href="https://github.com/anupamchugh/SwiftUIDallEAPI/blob/main/SwiftUIDallEAPI/MultipartFormDataRequest.swift" rel="noopener ugc nofollow" target="_blank">MultiPartFormDataRequest</a></code>结构用于准备一个包含<code class="fe lr ls lt lu b">boundary</code>、<code class="fe lr ls lt lu b">Content-Disposation</code>和其他有趣内容的多部分请求。查看<a class="ae nn" href="https://www.donnywals.com/uploading-images-and-forms-to-a-server-using-urlsession/" rel="noopener ugc nofollow" target="_blank"> Donny Wals使用</a> <code class="fe lr ls lt lu b"><a class="ae nn" href="https://www.donnywals.com/uploading-images-and-forms-to-a-server-using-urlsession/" rel="noopener ugc nofollow" target="_blank">URLSession</a></code> <a class="ae nn" href="https://www.donnywals.com/uploading-images-and-forms-to-a-server-using-urlsession/" rel="noopener ugc nofollow" target="_blank">指南</a>将图像和表单上传到服务器，了解构建多部分表单数据请求的复杂性。</p></div><div class="ab cl lv lw hy lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="in io ip iq ir"><p id="bbb7" class="pw-post-body-paragraph kv kw iu kx b ky kz jv la lb lc jy ld le lf lg lh li lj lk ll lm ln lo lp lq in bi translated">上传图像和表单数据的<code class="fe lr ls lt lu b">URLRequest</code>准备就绪后，我们将通过以下方式从SwiftUI视图中调用<code class="fe lr ls lt lu b">generateEditedImage</code>函数:</p><pre class="kk kl km kn gu nt lu nu bn nv nw bi"><span id="ce3e" class="nx md iu lu b be ny nz l oa ob"><br/>struct EditImageView: View {<br/>    <br/>    @StateObject var visionProcessing  = VisionRequester()<br/>    @StateObject var fetcher = OpenAIService()<br/>    @State var inputImage : UIImage = UIImage(named: "sample")!<br/><br/>    var body: some View {<br/> <br/>      //....<br/>     <br/>      if let outputImage = self.visionProcessing.maskedImage{<br/>        Image(uiImage: outputImage)<br/>            .resizable()<br/>            .aspectRatio(contentMode:.fit)<br/>            .onReceive(self.visionProcessing.$maskedImage,<br/>                       perform: { updated in<br/>                if let _ = updated?.size{<br/>                    Task{<br/>                        do{<br/>                            self.photos = try await fetcher.generateEditedImage(from: inputImage, with: outputImage)<br/>                        }catch(let error){<br/>                            print(error)<br/>                        }<br/>                    }<br/>                }<br/>            })<br/>      }<br/>      <br/>      //....<br/><br/>    }<br/><br/>}</span></pre><p id="9d2d" class="pw-post-body-paragraph kv kw iu kx b ky kz jv la lb lc jy ld le lf lg lh li lj lk ll lm ln lo lp lq in bi translated">运行项目时，您应该会看到生成的面:</p><figure class="kk kl km kn gu ko gi gj paragraph-image"><div role="button" tabindex="0" class="kp kq di kr bf ks"><div class="gi gj kj"><img src="../Images/73e2afe2ae7f09ecd185330507b3648b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*qyATTnucm5byYjFlUroDNg.png"/></div></div></figure><figure class="kk kl km kn gu ko gi gj paragraph-image"><div role="button" tabindex="0" class="kp kq di kr bf ks"><div class="gi gj kj"><img src="../Images/d50dfbdd7640e1a7ea0673bdb871fb31.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*nP14-WpaJrxMSp7NsaDsmw.png"/></div></div><p class="op oq gk gi gj or os bd b be z dk translated">提示:一个长胡子的家伙</p></figure><figure class="kk kl km kn gu ko gi gj paragraph-image"><div role="button" tabindex="0" class="kp kq di kr bf ks"><div class="gi gj kj"><img src="../Images/9569e688194efa6c4cbf38094faf0e93.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*v_MmurNKSSYR__AOCRVkIA.png"/></div></div><p class="op oq gk gi gj or os bd b be z dk translated">一个留着胡子戴着蓝色眼镜的男孩</p></figure><p id="eb49" class="pw-post-body-paragraph kv kw iu kx b ky kz jv la lb lc jy ld le lf lg lh li lj lk ll lm ln lo lp lq in bi translated">本教程到此结束。该项目在我的<a class="ae nn" href="https://github.com/anupamchugh/SwiftUIDallEAPI" rel="noopener ugc nofollow" target="_blank"> GitHub资源库</a>中可用。尝试在一张集体照中反复遮罩多张脸。</p><p id="a47a" class="pw-post-body-paragraph kv kw iu kx b ky kz jv la lb lc jy ld le lf lg lh li lj lk ll lm ln lo lp lq in bi translated">或者，您可以测试我们的<code class="fe lr ls lt lu b">variations</code>端点来生成输入图像的变体。相当不错的结果，没有传递一个屏蔽的图像或提示生成脸:</p><figure class="kk kl km kn gu ko gi gj paragraph-image"><div role="button" tabindex="0" class="kp kq di kr bf ks"><div class="gi gj kj"><img src="../Images/60afb2271a32bf6642e3a63fbb28eddf.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*R8rukNU6LHeIzvJx5TG7ag.png"/></div></div></figure><p id="64ce" class="pw-post-body-paragraph kv kw iu kx b ky kz jv la lb lc jy ld le lf lg lh li lj lk ll lm ln lo lp lq in bi translated">感谢阅读。</p></div></div>    
</body>
</html>