<html>
<head>
<title>URLSession in Swift — From Completion Handler to Combine to Async/Await</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Swift中的URLSession从完成处理器到组合到异步/等待</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/urlsession-combine-and-asyncawait-96981923a7ec?source=collection_archive---------4-----------------------#2021-12-22">https://betterprogramming.pub/urlsession-combine-and-asyncawait-96981923a7ec?source=collection_archive---------4-----------------------#2021-12-22</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="851b" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">URLSession的发展历程——了解如何在SwiftUI应用中使用3种技术使用Swift执行网络请求</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/9740b2ab1b31139e1823b542612d9697.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*q-3wS0fHAaLR_iZ3"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">照片由<a class="ae ky" href="https://unsplash.com/@ryanquintal?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">瑞安·昆塔尔</a>在<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</p></figure><p id="4c45" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">URLSession第一次出现在iOS 7的框架中，是在2009年。其结构背后的基本动态，使用回调，直到2019年保持不变。一个被称为联合的新框架所挑战的结构。虽然有些人可能会说，真正的变化是在2021年iOS 15中引入async/await之后。</p><p id="7b48" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">和我一起看看URLSession这些年来是如何发展的。我们看2009，2014，现在看2021的版本。尽管在我开始之前，让我们稍微绕一下路，看看如何定制OS X的内置web服务器，这样您也可以为您的网络代码设置一个独立的测试平台。</p><h1 id="913a" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">OS X阿帕奇网络服务器</h1><p id="fa63" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">URLSession与web服务器交互，web服务器是通常位于互联网某处的资源。这是测试这里给出的代码所需的资源。幸运的是，OS X预装了Apache服务器。让测试变得轻而易举的装置。</p><p id="b928" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">为此，您需要将资产保存在本地apache web服务器的documents目录中。打开一个终端窗口，成为root用户，然后切换到web服务器的]文档目录。</p><pre class="kj kk kl km gt mw mv mx my aw mz bi"><span id="417b" class="na lw it mv b gy nb nc l nd ne">sudo su - <br/>cd /Library/WebServer/Documents</span></pre><p id="1f76" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在那里，您可以使用一个简单的编辑器(如vi)来创建和保存一些您想要测试的原始JSON文件的简单示例。</p><p id="2cd3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">设置好您想要使用的文档后，您可以使用显示的命令启动/停止web服务器——尽管如果您使用模拟器进行测试，您不需要运行守护进程。</p><pre class="kj kk kl km gt mw mv mx my aw mz bi"><span id="8176" class="na lw it mv b gy nb nc l nd ne">apachectl start or stop</span></pre><p id="614e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">只有在真实设备上运行时，您才需要它。显然，在这种情况下，显示的本地主机地址将是您的工作站/笔记本电脑的IP地址。</p><pre class="kj kk kl km gt mw mv mx my aw mz bi"><span id="73ef" class="na lw it mv b gy nb nc l nd ne"><a class="ae ky" href="http://127.0.0.1/filename.extension" rel="noopener ugc nofollow" target="_blank">http://127.0.0.1/filename.extension</a></span></pre><p id="d364" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我应该在这里提一下，这是一个HTTP服务器，所以您还需要在您的项目的<code class="fe ms mt mu mv b">info.plist</code>中启用任意负载。在Xcode的最新版本中，这个过程略有不同，请注意。</p><pre class="kj kk kl km gt mw mv mx my aw mz bi"><span id="4471" class="na lw it mv b gy nb nc l nd ne">&lt;<strong class="mv iu">dict</strong>&gt;<br/>  &lt;<strong class="mv iu">key</strong>&gt;NSAppTransportSecurity&lt;/<strong class="mv iu">key</strong>&gt;<br/>  &lt;<strong class="mv iu">dict</strong>&gt;<br/>    &lt;<strong class="mv iu">key</strong>&gt;NSAllowsArbitraryLoads&lt;/<strong class="mv iu">key</strong>&gt;<br/>    &lt;<strong class="mv iu">true</strong>/&gt;<br/>  &lt;/<strong class="mv iu">dict</strong>&gt;<br/>&lt;/<strong class="mv iu">dict</strong>&gt;</span></pre><h1 id="feae" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">URLSession开始</h1><p id="d1e0" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">嘿，我们现在是在2009年的WWDC，苹果刚刚发布了带有召回的<code class="fe ms mt mu mv b">URLSession</code>。它看起来不错，运行良好——这里是一些示例代码。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nf ng l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">URLSession alla 2009</p></figure><p id="eece" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我设置了URL [localhost],然后使用完成处理程序运行fetch方法。假设我创建了如图所示的<code class="fe ms mt mu mv b">user.json</code>文件，它应该使用演示代码将盖尔·加朵这个名字放在屏幕中央:</p><pre class="kj kk kl km gt mw mv mx my aw mz bi"><span id="5b76" class="na lw it mv b gy nb nc l nd ne">cat user.json<br/>{<br/> "id": "A0DA1512-391D-40F0-89F8-E22A42B39047",<br/> "name": "Gal Gadot",<br/> "age": 36<br/>}</span></pre><p id="7028" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">但是现在回想起来(现在是2021年)，我们从第12行跳到第24行——然后在第14、19或21行退出。当前围绕结构化编码的思想流派并不支持这种执行路径。</p><ul class=""><li id="b158" class="nh ni it lb b lc ld lf lg li nj lm nk lq nl lu nm nn no np bi translated">有人说到处乱跳使得代码更难理解/维护；我们差不多回到戈托斯了。</li><li id="a44f" class="nh ni it lb b lc nq lf nr li ns lm nt lq nu lu nm nn no np bi translated">仅在这个简单的例子中就有三个出口，您忘记调用完成子句的可能性是一个正在形成的错误[可以用async/await避免]。</li></ul><h1 id="edae" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">合并URLSession</h1><p id="1ea3" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">现在是WWDC2019，苹果现在肯定在新的领域——推出SwiftUI和Combine框架。这里是一个使用新的声明性框架的<code class="fe ms mt mu mv b">URLSession</code>的例子:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nf ng l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">使用组合alla 2019的URLSession</p></figure><p id="5fc8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">从表面上看，这个框架在这个例子中看起来更容易，尽管我承认我们在这里比较苹果和橘子，因为虽然这是可行的，但它是以忽略错误为代价的。</p><ul class=""><li id="3bab" class="nh ni it lb b lc ld lf lg li nj lm nk lq nl lu nm nn no np bi translated">与同类产品相比，它的主要优势在于能够通过可取消属性管理流程，并且在本例中，它从顶部开始，一直延伸到底部。</li></ul><h1 id="7749" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">带异步/等待的URLSession</h1><p id="b959" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">Bon，这是WWDC 2021无疑也是WWDC今年新增并发语言功能的主要目标之一。这里又是<code class="fe ms mt mu mv b">URLSession</code>的代码。类似这样的代码。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nf ng l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">使用异步/等待alla 2021的URLSession</p></figure><p id="a305" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这更好，因为它从第6行运行到第20行——当然，如果有故障，它会跳出来了，但总体来说感觉/看起来更干净。当然，我觉得有必要指出这里仍然有多个出口。</p><ul class=""><li id="b00f" class="nh ni it lb b lc ld lf lg li nj lm nk lq nl lu nm nn no np bi translated">与最初版本相比，最大的优势是执行顺序，现在是从上到下，这使得它更容易理解，也更容易调试。</li><li id="598f" class="nh ni it lb b lc nq lf nr li ns lm nt lq nu lu nm nn no np bi translated">然而，更重要的是，有了新的语法，至少在理论上，省去应该返回某些内容的分支要困难得多，即使这只是一个错误。</li></ul><h1 id="a405" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">具有合并和异步/等待的URLSession</h1><p id="44d6" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">这一切都很好，或者是——我听到你问，声明式解决方案发生了什么，苹果放弃了吗？</p><p id="740e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">不，他们没有，但老实说，我仍然试图让我的头周围联合起来，就像我觉得很多其他人一样。这是可行的——我觉得比较苹果和苹果可能不是完美的解决方案，因为它确实能处理错误。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nf ng l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">使用组合alla 2021的URLSession</p></figure><p id="ee15" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我试着把数据下载和解码分开；并且让它工作起来——但是说实话，它甚至比这个更复杂。在其中混合声明性和命令性编码——我不会张贴它。试试看，然后告诉我。</p></div><div class="ab cl nv nw hx nx" role="separator"><span class="ny bw bk nz oa ob"/><span class="ny bw bk nz oa ob"/><span class="ny bw bk nz oa"/></div><div class="im in io ip iq"><p id="320f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">但是等等——因为我在这里的旅程还没有完全结束——我想谈谈如何配置你的<code class="fe ms mt mu mv b">URLSession</code>,因为默认设置有时有点烦人。即会话超时和会话缓存——前者太长，后者太好。</p><p id="292a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">要更改默认值，我们只需创建一个自定义会话，而不要使用代码中所示的共享会话。我已经更改了作为示例显示的上一个版本。所做的更改可以很容易地应用到任何其他介绍。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nf ng l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">自定义URLSession alla 2021</p></figure><p id="6edb" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">最后要注意的是我在其中运行所有这些的SwiftUI代码；除了在屏幕中央显示上传的JSON之外，它几乎没有做什么。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nf ng l"/></div></figure><p id="c8b4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">所有这些让我想到了这篇文章的结尾——我希望你能像我写这篇文章一样喜欢阅读它，并且确实像我一样，同时也学到了一两件事。</p></div></div>    
</body>
</html>