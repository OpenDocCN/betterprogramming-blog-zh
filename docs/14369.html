<html>
<head>
<title>Synthwave Scene — My Coolest Three.js Project</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Synthwave场景——我最酷的Three.js项目</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/synthwave-scene-my-coolest-three-js-project-yet-6359c38dfd08?source=collection_archive---------5-----------------------#2022-12-05">https://betterprogramming.pub/synthwave-scene-my-coolest-three-js-project-yet-6359c38dfd08?source=collection_archive---------5-----------------------#2022-12-05</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="958c" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">我的代码的详细演练</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/b54205eab561a3878b99f4bb7aa182c0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*B4-rouDnpRMKDzvSzCXgKQ.png"/></div></div></figure><p id="f4f3" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">大约两年前，我完全迷上了YouTube上的Retrowave/Synthwave音乐。我真的很喜欢音乐和视觉的复古未来主义美学——一个向前移动的视角，展示了一个超级酷的永不结束的霓虹网格，夕阳就在地平线上。从那以后，我一直想用Three.js重新创建一个“Synthwave场景”</p><p id="8bed" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">我记得去年我第一次尝试，但我在某个时候卡住了，很快就感到沮丧，最后放弃了。老实说，重现场景不是一件简单的工作，对初学者来说更是如此。我为自己最终创造了一个像样的Synthwave场景感到非常自豪。现在，我将带你一步一步地完成创建相同场景的过程。</p><p id="70d2" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">先说细分。</p><h1 id="56f3" class="ln lo iq bd lp lq lr ls lt lu lv lw lx jw ly jx lz jz ma ka mb kc mc kd md me bi translated">教程分解</h1><ol class=""><li id="815e" class="mf mg iq kt b ku mh kx mi la mj le mk li ml lm mm mn mo mp bi translated">现场演示</li><li id="2237" class="mf mg iq kt b ku mq kx mr la ms le mt li mu lm mm mn mo mp bi translated">构建地形的方法</li><li id="3b87" class="mf mg iq kt b ku mq kx mr la ms le mt li mu lm mm mn mo mp bi translated">项目的代码结构</li><li id="1ab5" class="mf mg iq kt b ku mq kx mr la ms le mt li mu lm mm mn mo mp bi translated">设置场景环境</li><li id="c84e" class="mf mg iq kt b ku mq kx mr la ms le mt li mu lm mm mn mo mp bi translated">为地形⛰设置平面几何体</li><li id="37db" class="mf mg iq kt b ku mq kx mr la ms le mt li mu lm mm mn mo mp bi translated">在地形上创建亮/霓虹网格线</li><li id="1a95" class="mf mg iq kt b ku mq kx mr la ms le mt li mu lm mm mn mo mp bi translated">创造一个没有尽头的地形的幻觉</li><li id="27e7" class="mf mg iq kt b ku mq kx mr la ms le mt li mu lm mm mn mo mp bi translated">添加落日☀并制作动画</li><li id="208d" class="mf mg iq kt b ku mq kx mr la ms le mt li mu lm mm mn mo mp bi translated">添加GUI控件以在运行时调整参数</li><li id="5305" class="mf mg iq kt b ku mq kx mr la ms le mt li mu lm mm mn mo mp bi translated">用Bloom效果对场景进行后期处理，让它看起来更酷！</li></ol><h1 id="20e8" class="ln lo iq bd lp lq lr ls lt lu lv lw lx jw ly jx lz jz ma ka mb kc mc kd md me bi translated">1.现场演示</h1><p id="91cd" class="pw-post-body-paragraph kr ks iq kt b ku mh jr kw kx mi ju kz la mv lc ld le mw lg lh li mx lk ll lm ij bi translated">像往常一样，先看看你要建立什么！这个演示是托管在我的代码沙盒帐户。在更大的窗口里看起来更好，不那么笨重。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="my mz l"/></div></figure><p id="52d1" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">很酷的场景吧？</p><p id="db9d" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">如果你想看完整的代码，请查看https://github.com/franky-adl/threejs-synthwave-scene的。</p><h1 id="addc" class="ln lo iq bd lp lq lr ls lt lu lv lw lx jw ly jx lz jz ma ka mb kc mc kd md me bi translated">2.构建地形的方法</h1><p id="bcba" class="pw-post-body-paragraph kr ks iq kt b ku mh jr kw kx mi ju kz la mv lc ld le mw lg lh li mx lk ll lm ij bi translated">这一节解释了如何处理在制作地形几何图形时遇到的问题，这真的有助于你理解我在幕后的思考过程。这会变得有点长，所以如果你想马上进入代码，跳到下一节。</p><p id="c612" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">制作synthwave场景要克服的第一个障碍是生成地形。我们将制作一个中间平坦的地形作为道路，两边崎岖不平的地形作为山脉。有不同的方法生成地形；有些在你脑海中看起来很容易，但当你尝试编码时却很难。为了更深入地了解地形问题，实际上有三个主要问题:</p><p id="f7ca" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">A.我们应该使用什么样的几何图形？<br/> B .如何使地形中间平坦而两边凹凸不平？<br/> C .如何制作地形动画来伪造一个无尽的道路效果？</p><p id="fd08" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">让我们一个一个来。</p><h2 id="6edf" class="nb lo iq bd lp nc nd dn lt ne nf dp lx la ng nh lz le ni nj mb li nk nl md nm bi translated"><strong class="ak"> A .我们应该使用什么样的几何图形？</strong></h2><p id="5825" class="pw-post-body-paragraph kr ks iq kt b ku mh jr kw kx mi ju kz la mv lc ld le mw lg lh li mx lk ll lm ij bi translated">乍一看，你可能认为<code class="fe nn no np nq b">PlaneGeometry</code>是显而易见的选择；是的，但也有一些曲折。有很重要的一点要记住:霓虹灯线必须匹配这个平面几何的线框；比方说，如果霓虹灯线不沿着你的<code class="fe nn no np nq b">PlaneGeometry</code>网格中的对角线，你会看到相邻的三角形面的阴影在对角线上变化，但是如果没有一条线来切断阴影的变化，视觉效果会看起来很奇怪。因此，如果你使用香草<code class="fe nn no np nq b">PlaneGeometry</code>作为地形的基础几何图形，你的霓虹线也需要追踪除垂直和水平网格线之外的所有对角线，缺点是使中央通道看起来不对称。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nr"><img src="../Images/d8862c59040317819b831e4a31c2b159.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*T5LvNvjvfAdrQ9Q8gkS5hw.png"/></div></div><p class="ns nt gj gh gi nu nv bd b be z dk translated">普通平面几何的线框</p></figure><p id="d448" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">如果我们想避免对角线问题，有3个选择。</p><ol class=""><li id="22e1" class="mf mg iq kt b ku kv kx ky la nw le nx li ny lm mm mn mo mp bi translated">将整个<code class="fe nn no np nq b">PlaneGeometry</code>旋转45度！</li><li id="d5e8" class="mf mg iq kt b ku mq kx mr la ms le mt li mu lm mm mn mo mp bi translated">制作一个自定义的<code class="fe nn no np nq b">BufferGeometry</code>，它是旋转方块的镶嵌。</li><li id="a7e7" class="mf mg iq kt b ku mq kx mr la ms le mt li mu lm mm mn mo mp bi translated">在y方向剪切<code class="fe nn no np nq b">PlaneGeometry</code>，直到你有一个对称三角形的镶嵌！</li></ol><div class="kg kh ki kj gt ab cb"><figure class="nz kk oa ob oc od oe paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><img src="../Images/ee849bd01970fcd022eb6a1b3f926676.png" data-original-src="https://miro.medium.com/v2/resize:fit:1002/format:webp/1*ggCmTmsg0xFnH_qGijwpXA.png"/></div></figure><figure class="nz kk of ob oc od oe paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><img src="../Images/3fc0c3b13481cec208b7e73c03e8a9df.png" data-original-src="https://miro.medium.com/v2/resize:fit:1000/format:webp/1*MWnTmVkF6W1qS0qRHp-poQ.png"/></div><p class="ns nt gj gh gi nu nv bd b be z dk og di oh oi translated">左:选项1将平面旋转45度，右:选项2进行自定义缓冲测量</p></figure></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi oj"><img src="../Images/2c124c2636fffef5521c29aff46b8bfe.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*DThEze54-h2aS4yK7-qaRA.png"/></div></div><p class="ns nt gj gh gi nu nv bd b be z dk translated">选项3:使用<code class="fe nn no np nq b">matrix.makeShear()</code>剪切平面，xy设置为-0.5</p></figure><p id="7ce0" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">你可能会说，嘿，有选项4，这是简单地使用一个正方形网格！遗憾的是，这不是一个可行的选择，因为三角形最终是Three.js的基本构建块；据我所知，不可能用纯正方形来堆叠网格。</p><p id="ba54" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">因此，让我们考虑3个选项。请记住，我们需要在地形中铺设一条很长的道路，因此我们可能需要复制和连接飞机，以便使它更长。</p><ul class=""><li id="cad6" class="mf mg iq kt b ku kv kx ky la nw le nx li ny lm ok mn mo mp bi translated">对于选项1，从头到脚连接多个旋转的平面会产生一个明显的问题:它们之间会有很大的空白空间。将一个指向前方的菱形镶嵌成一条道路是非常痛苦和低效的。</li><li id="b9b2" class="mf mg iq kt b ku mq kx mr la ms le mt li mu lm ok mn mo mp bi translated">对于选项2，自定义几何图形看起来不错，但是开销太高；你将不得不自己计算和设置顶点的位置，并且精确地连接平面更加复杂。</li><li id="1209" class="mf mg iq kt b ku mq kx mr la ms le mt li mu lm ok mn mo mp bi translated">对于选项3，只需要2-3行代码就可以剪切它，直到三角形对对称。开销很小。虽然整个平面被对角拉伸，但仍然很容易将平面相乘并连接起来，如果我们正确设置相机和动画循环，观众不会注意到剪切。</li></ul><p id="7c76" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">选项3是赢家👑！</p><h2 id="73f8" class="nb lo iq bd lp nc nd dn lt ne nf dp lx la ng nh lz le ni nj mb li nk nl md nm bi translated"><strong class="ak"> B .如何让地形中间平坦而两边凹凸不平？</strong></h2><p id="7f1e" class="pw-post-body-paragraph kr ks iq kt b ku mh jr kw kx mi ju kz la mv lc ld le mw lg lh li mx lk ll lm ij bi translated">我们首先需要一张高度图。不管你是用手工还是用一些生成代码来做，都应该是黑白图像，白色代表最高，黑色代表最低。我在Affinity Designer中使用径向渐变和纹理笔刷生成了我的。显然，我们需要保持中央垂直矩形区域为黑色，以便将其作为道路铺设。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi ol"><img src="../Images/dc96731e45bc8eafe0ba498c798ee09a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*aLMP1Bo6uJfFM5ZN52o4fg.png"/></div></div><p class="ns nt gj gh gi nu nv bd b be z dk translated">我在合成波场景中使用的高度图</p></figure><p id="5315" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">下一个问题是用这个高度图中的高度数据来渲染我们的平面几何。我尝试的第一件事是使用<code class="fe nn no np nq b">TextureLoader</code>加载高度图图像，然后将纹理分配给<code class="fe nn no np nq b">MeshStandardMaterial</code>的<code class="fe nn no np nq b">displacementMap</code>属性。但是这种方法不适用于以后创建的霓虹线(我将在霓虹线部分解释原因),因为<code class="fe nn no np nq b">displacementMap</code>属性只在运行时更新<code class="fe nn no np nq b">vertexShader</code>程序中的顶点位置，我们的主js程序中的平面几何对象的positions数组不受影响。</p><p id="0d9c" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">因此，我不得不手动从位移贴图中提取灰度值，缩放它，并将其值直接分配给我们的几何对象的每个顶点的z位置值。我发现我们甚至不需要手动计算法线，灯光只是以某种方式工作！</p><h2 id="9eee" class="nb lo iq bd lp nc nd dn lt ne nf dp lx la ng nh lz le ni nj mb li nk nl md nm bi translated">如何制作地形动画来模拟一个无尽的道路效果？</h2><p id="3853" class="pw-post-body-paragraph kr ks iq kt b ku mh jr kw kx mi ju kz la mv lc ld le mw lg lh li mx lk ll lm ij bi translated">这个问题存在于很多需要某种无尽之路的游戏/动画中。我敢肯定，这是解决了很多次，反反复复。是的，这个问题本身很容易解决，但在我们的情况下，有一个额外的复杂性(将在下一段解释)。大局依旧；假设我们有多个平面实例连接在一起形成我们的道路，我们让它们像火车一样向相机加速，这样从相机的角度看，我们就像是在前进。一旦火车的车头在我们的相机后面，我们就把它的位置调回到火车的尾部，这就是如何让我们的路看起来没有尽头。</p><p id="5c9d" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">额外的问题是，我们如何确保平面实例在它们的连接处完美地结合在一起，没有间隙。想象一下，对所有平面实例使用相同的<code class="fe nn no np nq b">heightmap</code>，高度图的顶行像素很可能与底行像素不匹配，自然，您会看到这样的间隙:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi om"><img src="../Images/5143cb4f158503eaed1cd269dcb68468.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ZELaA1E2OAs2xF19wjR-2A.png"/></div></div><p class="ns nt gj gh gi nu nv bd b be z dk translated">平面实例之间的间隙，如果它们没有完全从上到下缝合</p></figure><p id="bf99" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">解决方案其实很简单。您可以编辑您的高度图图像，复制顶行像素并将其粘贴在底行像素的顶部。那行得通。</p><p id="3efd" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">但我更喜欢编程的方式，因为如果你想在高度图图像之间切换，程序会自动为你做完美的缝合，这样你就不必每次想尝试新的<code class="fe nn no np nq b">heightmap</code>时都亲自做缝合工作。</p><h1 id="e940" class="ln lo iq bd lp lq lr ls lt lu lv lw lx jw ly jx lz jz ma ka mb kc mc kd md me bi translated">3.项目的代码结构</h1><p id="e2f6" class="pw-post-body-paragraph kr ks iq kt b ku mh jr kw kx mi ju kz la mv lc ld le mw lg lh li mx lk ll lm ij bi translated">我从我的自定义模板开始这个项目，在https://github.com/franky-adl/threejs-starter-template公开托管。编写本教程时，假设您使用此初学者模板开始项目。</p><p id="3bff" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">当然，您可以使用任何您喜欢的样板文件或设置，然后您必须做一些小的代码翻译，使我的代码为您的设置工作。关于这个初学者模板如何工作的更多细节，你可以在这里阅读我以前的文章。</p><p id="bf77" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">现在，让我简单介绍一下代码的结构。</p><p id="ada7" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">项目文件层次结构:</p><pre class="kg kh ki kj gt on nq oo bn op oq bi"><span id="096d" class="or lo iq nq b be os ot l ou ov">.<br/>├── src<br/>│   └── assets<br/>│       ├── heightmap.png<br/>│       └── Starfield.png<br/>│   ├── common-utils.js<br/>│   ├── core-utils.js<br/>│   ├── functions.js<br/>│   ├── index.html<br/>│   └── index.js<br/>├── .gitignore<br/>├── package-lock.json<br/>└── package.json</span></pre><p id="cf9e" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">我们所有的代码和图片基本上都在<code class="fe nn no np nq b">src</code>文件夹里。在<code class="fe nn no np nq b">package.json</code>中，我们只有3个依赖项:</p><ul class=""><li id="0b23" class="mf mg iq kt b ku kv kx ky la nw le nx li ny lm ok mn mo mp bi translated"><code class="fe nn no np nq b">three@0.145.0</code>:three . js库</li><li id="2fcb" class="mf mg iq kt b ku mq kx mr la ms le mt li mu lm ok mn mo mp bi translated"><code class="fe nn no np nq b">dat.gui@0.7.9</code>:GUI控件库</li><li id="48dd" class="mf mg iq kt b ku mq kx mr la ms le mt li mu lm ok mn mo mp bi translated"><code class="fe nn no np nq b">parcel@2.7.0</code>:捆扎机工具</li></ul><p id="8b2d" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">在<code class="fe nn no np nq b">src</code>中，将所有的纹理/图像保存在<code class="fe nn no np nq b">assets</code>子文件夹下。</p><p id="bd5f" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">包含大部分场景构建代码的文件是<code class="fe nn no np nq b">index.js</code>文件。</p><p id="2252" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated"><code class="fe nn no np nq b">core-utils.js</code>包含一些方便的方法，用于设置大多数Three.js项目中需要的公共对象(即相机、渲染器、合成器、窗口大小调整监听器、鼠标<code class="fe nn no np nq b">onmove</code>监听器、动画循环)。</p><p id="f7f4" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated"><code class="fe nn no np nq b">common-utils.js</code>有一些更方便的方法，我自己发现这些方法在Three.js项目中很有用(例如，支持async/await的图像加载函数，十六进制到rgb的转换器等等)。</p><p id="3958" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated"><code class="fe nn no np nq b">functions.js</code>包含了在这个项目中使用的函数，这些函数有助于从主js文件中取出部分代码，使其可读性更好，体积更小。</p><p id="08ba" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated"><code class="fe nn no np nq b">index.html</code>是package bundler的入口点，它有一个请求<code class="fe nn no np nq b">index.js</code>文件的脚本标签。</p><h1 id="16d1" class="ln lo iq bd lp lq lr ls lt lu lv lw lx jw ly jx lz jz ma ka mb kc mc kd md me bi translated">4.设置场景环境</h1><p id="0b50" class="pw-post-body-paragraph kr ks iq kt b ku mh jr kw kx mi ju kz la mv lc ld le mw lg lh li mx lk ll lm ij bi translated">让我们假设我们使用我的<code class="fe nn no np nq b"><a class="ae na" href="https://github.com/franky-adl/threejs-starter-template" rel="noopener ugc nofollow" target="_blank">threejs-starter-template</a></code>开始这个项目。运行以下命令将打开一个选项卡，显示一些灯箱后面的旋转圆环。</p><pre class="kg kh ki kj gt on nq oo bn op oq bi"><span id="6ae9" class="or lo iq nq b be os ot l ow ov">git clone https://github.com/franky-adl/threejs-starter-template<br/>cd threejs-starter-template<br/>npm i<br/>npm run start</span></pre><p id="5b14" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">根据自己的喜好，在不同的地方重命名项目名称<code class="fe nn no np nq b">threejs-starter-template</code>。场景中的物体只是为了演示，我们需要移除它们，这样我们就可以重新开始。</p><p id="c72d" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">进行清理，并用以下代码替换<code class="fe nn no np nq b">index.js</code>的内容:</p><pre class="kg kh ki kj gt on nq oo bn op oq bi"><span id="23f5" class="or lo iq nq b be os ot l ow ov">// ThreeJS and Third-party deps<br/>import * as THREE from "three"<br/>import * as dat from 'dat.gui'<br/>import Stats from "three/examples/jsm/libs/stats.module"<br/>import { OrbitControls } from "three/examples/jsm/controls/OrbitControls"<br/><br/>// Core boilerplate code deps<br/>import { createCamera, createComposer, createRenderer, runApp } from "./core-utils"<br/><br/>global.THREE = THREE<br/><br/>/**************************************************<br/> * 0. Tweakable parameters for the scene<br/> *************************************************/<br/>const params = {<br/>  // general scene params<br/>}<br/><br/><br/>/**************************************************<br/> * 1. Initialize core threejs components<br/> *************************************************/<br/>// Create the scene<br/>let scene = new THREE.Scene()<br/><br/>// Create the renderer via 'createRenderer',<br/>// 1st param receives additional WebGLRenderer properties<br/>// 2nd param receives a custom callback to further configure the renderer<br/>let renderer = createRenderer({ antialias: true })<br/><br/>// Create the camera<br/>// Pass in fov, near, far and camera position respectively<br/>let camera = createCamera(45, 1, 1000, { x: 0, y: 5, z: -15 })<br/><br/>// The RenderPass is already created in 'createComposer'<br/>let composer = createComposer(renderer, scene, camera, (comp) =&gt; {<br/>})<br/><br/>/**************************************************<br/> * 2. Build your scene in this threejs app<br/> * This app object needs to consist of at least the async initScene() function (it is async so the animate function can wait for initScene() to finish before being called)<br/> * initScene() is called after a basic threejs environment has been set up, you can add objects/lighting to you scene in initScene()<br/> * if your app needs to animate things(i.e. not static), include a updateScene(interval, elapsed) function in the app as well<br/> *************************************************/<br/>let app = {<br/>  async initScene() {<br/>    // OrbitControls<br/>    this.controls = new OrbitControls(camera, renderer.domElement)<br/>    this.controls.enableDamping = true<br/><br/>    // GUI controls<br/>    const gui = new dat.GUI()<br/><br/>    // Stats - show fps<br/>    this.stats1 = new Stats()<br/>    this.stats1.showPanel(0) // Panel 0 = fps<br/>    this.stats1.domElement.style.cssText = "position:absolute;top:0px;left:0px;"<br/>    // this.container is the parent DOM element of the threejs canvas element<br/>    this.container.appendChild(this.stats1.domElement)<br/>  },<br/>  // @param {number} interval - time elapsed between 2 frames<br/>  // @param {number} elapsed - total time elapsed since app start<br/>  updateScene(interval, elapsed) {<br/>    this.controls.update()<br/>    this.stats1.update()<br/>  }<br/>}<br/><br/>/**************************************************<br/> * 3. Run the app<br/> * 'runApp' will do most of the boilerplate setup code for you:<br/> * e.g. HTML container, window resize listener, mouse move/touch listener for shader uniforms, THREE.Clock() for animation<br/> * Executing this line puts everything together and runs the app<br/> * ps. if you don't use custom shaders, pass undefined to the 'uniforms'(2nd-last) param<br/> * ps. if you don't use post-processing, pass undefined to the 'composer'(last) param<br/> *************************************************/<br/>runApp(app, scene, renderer, camera, true, undefined, composer)</span></pre><p id="a306" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">然后，从资产文件夹中移除<code class="fe nn no np nq b">checker_tile.png</code>。</p><p id="0f9c" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">现在运行<code class="fe nn no np nq b">npm run start</code>应该会给你一个黑屏，在左上角只有fps计数器。从现在开始保存对文件的代码更改将触发packet bundler自动重新构建，并且您的Three.js浏览器选项卡将自动刷新。</p><pre class="kg kh ki kj gt on nq oo bn op oq bi"><span id="996a" class="or lo iq nq b be os ot l ow ov">% npm run start<br/><br/>&gt; threejs-synthwave-scene@1.0.0 start<br/>&gt; parcel src/index.html --open<br/><br/>Server running at http://localhost:1234<br/>✨ Built in 1.21s</span></pre><p id="c7bf" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">让我们先放一张背景图片吧！</p><p id="58cb" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">将<a class="ae na" href="https://github.com/franky-adl/threejs-synthwave-scene" rel="noopener ugc nofollow" target="_blank"> my synthwave repo </a>中的<code class="fe nn no np nq b">Starfield.png</code>复制到assets文件夹中。</p><p id="9d57" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">用以下内容创建一个新文件<code class="fe nn no np nq b">functions.js</code>:</p><pre class="kg kh ki kj gt on nq oo bn op oq bi"><span id="32e3" class="or lo iq nq b be os ot l ow ov">import { maintainBgAspect } from "./common-utils"<br/><br/>/**<br/> * @param {object} scene the Three.js scene object<br/> * @param {object} image the path to the background image<br/> * @returns a Promise that resolves after the texture is loaded as the scene's background<br/> */<br/>export const loadSceneBackground = (scene, image) =&gt; {<br/>  return new Promise((resolve, reject) =&gt; {<br/>    var loader = new THREE.TextureLoader();<br/>    loader.load(image, function (texture) {<br/>      scene.background = texture<br/>      // position scene background such that image aspect ratio is preserved<br/>      maintainBgAspect(scene, texture.image.width, texture.image.height)<br/>      // need to maintain background aspect ratio across window resizes<br/>      window.addEventListener("resize", () =&gt; {<br/>        maintainBgAspect(scene, texture.image.width, texture.image.height)<br/>      })<br/>      resolve()<br/>    }, undefined, function (error) {<br/>      console.log(error)<br/>      reject(error)<br/>    });<br/>  })<br/>}</span></pre><p id="417b" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">我们用一个<code class="fe nn no np nq b">Promise</code>包装<code class="fe nn no np nq b">TextureLoader.load()</code>函数的回调，这样我们就可以在<code class="fe nn no np nq b">async initScene()</code>函数中使用<code class="fe nn no np nq b">loadSceneBackground</code>上的<code class="fe nn no np nq b">await</code>表达式。</p><p id="ed56" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">我们希望这个<code class="fe nn no np nq b">Promise</code>只有在纹理被加载时才能被解析，这就是为什么我们在传递给<code class="fe nn no np nq b">loader.load()</code>的<code class="fe nn no np nq b">onLoad</code>回调中调用<code class="fe nn no np nq b">resolve()</code>。这确保了我们的场景只有在背景完全加载后才被揭开。由于<code class="fe nn no np nq b">core-utils.js</code>中的<code class="fe nn no np nq b">runApp()</code>函数中的代码，该揭示机制起作用:</p><pre class="kg kh ki kj gt on nq oo bn op oq bi"><span id="b8f9" class="or lo iq nq b be os ot l ow ov">app.initScene().then(() =&gt; {<br/>  const veil = document.getElementById("veil")<br/>  veil.style.opacity = 0<br/>  return true<br/>})</span></pre><p id="fe0c" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">后台加载函数就绪后，我们需要在主程序中执行它。</p><p id="7df4" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">对<code class="fe nn no np nq b">index.js</code>进行以下代码更改:</p><pre class="kg kh ki kj gt on nq oo bn op oq bi"><span id="a222" class="or lo iq nq b be os ot l ow ov">+ import { loadSceneBackground } from "./functions"<br/>+ import Background from "./assets/Starfield.png"<br/><br/>...<br/><br/>let app = {<br/>  async initScene() {<br/>    // OrbitControls<br/>    this.controls = new OrbitControls(camera, renderer.domElement)<br/>    this.controls.enableDamping = true<br/><br/>+   // Environment<br/>+   await loadSceneBackground(scene, Background)</span></pre><p id="5724" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">现在我们有了繁星满天的夜空！很好很容易。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi ox"><img src="../Images/398825e054b78564fe2918d17a32daf1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*LswiFO2OTD010O6AQmwh_Q.png"/></div></div></figure><h1 id="3616" class="ln lo iq bd lp lq lr ls lt lu lv lw lx jw ly jx lz jz ma ka mb kc mc kd md me bi translated">5.为地形⛰设置平面几何体</h1><p id="f51b" class="pw-post-body-paragraph kr ks iq kt b ku mh jr kw kx mi ju kz la mv lc ld le mw lg lh li mx lk ll lm ij bi translated">首先，将我的<code class="fe nn no np nq b">synthwave</code>回购中的<code class="fe nn no np nq b">heightmap.png</code>复制到assets文件夹中。</p><p id="7af3" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">接下来，将下面的代码添加到<code class="fe nn no np nq b">common-utils.js</code>中:</p><pre class="kg kh ki kj gt on nq oo bn op oq bi"><span id="09bf" class="or lo iq nq b be os ot l ow ov">/**<br/> * This loadImage function returns a Promise that is resolved when the image finishes loading<br/> * if you use it with await, it returns the loaded image object<br/> * @param {string} path image file path<br/> * @returns a Promise that resolves with the value assigned as the loaded image<br/> */<br/>export const loadImage = (path) =&gt; {<br/>    return new Promise((resolve, reject) =&gt; {<br/>        const img = new Image()<br/>        img.crossOrigin = "Anonymous" // to avoid CORS if used with Canvas<br/>        img.src = path<br/>        img.onload = () =&gt; {<br/>            resolve(img)<br/>        }<br/>        img.onerror = (e) =&gt; {<br/>            reject(e)<br/>        }<br/>    })<br/>}</span></pre><p id="c71d" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">我们将使用这个函数来同步加载我们的<code class="fe nn no np nq b">heightmap</code>。</p><p id="8fc3" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">然后，将以下代码追加到<code class="fe nn no np nq b">functions.js</code>中:</p><pre class="kg kh ki kj gt on nq oo bn op oq bi"><span id="11b1" class="or lo iq nq b be os ot l ow ov">/**<br/> * original reference: https://gist.github.com/jawdatls/465d82f2158e1c4ce161<br/> * This function lets you get the greyscale color value from a specific point in an image<br/> * In this scenario, we pass in a displacement map as imageData,<br/> * and u/v values which gets translated to a certain point on the image<br/> * getting either one of r/g/b value as the displacement value is the same<br/> * since the image is supposed to be black and white<br/> * note that the direction of v axis in texture data is the inverse of the y axis in image data<br/> *<br/> * @param {object} imageData the color data of the displacement map image to be passed in<br/> * @param {number} u the x position [0,1] of the target pixel<br/> * @param {number} v the y position [0,1] of the target pixel<br/> * @param {number} cvWidth the width of the heightmap image in canvas<br/> * @param {number} cvHeight the height of the heightmap image in canvas<br/> * @returns {number} height value of the requested point within [0,5]<br/> */<br/>export function getZFromImageDataPoint(imageData, u, v, cvWidth, cvHeight) {<br/>  const mapWidth = cvWidth<br/>  const mapHeight = cvHeight<br/>  const displacementScale = 5<br/>  var x = Math.round(u * (mapWidth - 1))<br/>  var y = Math.round((1 - v) * (mapHeight - 1))<br/>  var index = (y * imageData.width + x) * 4<br/>  var red = imageData.data[index]<br/>  return red / 255 * displacementScale<br/>}</span></pre><p id="2a04" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">我们将使用该函数从<code class="fe nn no np nq b">heightmap.png</code>中提取每个平面顶点对应像素的高度值。</p><p id="a8ef" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">该函数的<code class="fe nn no np nq b">u</code>和<code class="fe nn no np nq b">v</code>输入正好是平面顶点的uv值。该函数将uv坐标转换为图像坐标。</p><p id="3c02" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">对于这一行代码<code class="fe nn no np nq b">var index = (y * imageData.width + x) * 4</code>，<code class="fe nn no np nq b">y</code>和<code class="fe nn no np nq b">x</code>是图像数据中映射的行号和列号，乘以4是因为<code class="fe nn no np nq b">imageData.data </code>顺序存储所有像素的颜色值(即【r，g，b，a，r，g，b，a，…】)。</p><p id="eec1" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">因此，产生的<code class="fe nn no np nq b">index</code>是每个像素的第一个颜色通道，为红色。我们得到哪个颜色通道并不重要，因为高度图是黑白的。</p><p id="8283" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">最后，我们将该值放大5倍。因此，该函数的返回值在[0，5]的范围内。</p><p id="5677" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">让我们在<code class="fe nn no np nq b">index.js</code>中进行以下代码更改:</p><pre class="kg kh ki kj gt on nq oo bn op oq bi"><span id="39c1" class="or lo iq nq b be os ot l ow ov">+ import { loadImage } from "./common-utils"<br/>- import { loadSceneBackground } from "./functions"<br/>+ import { loadSceneBackground, getZFromImageDataPoint } from "./functions"<br/>import Background from "./assets/Starfield.png"<br/>+ import HeightMap from "./assets/heightmap.png"<br/><br/>global.THREE = THREE<br/><br/>/**************************************************<br/> * 0. Tweakable parameters for the scene<br/> *************************************************/<br/>const params = {<br/>  // general scene params<br/>+ dirLightColor1: 0x2dd7ff,<br/>+ dirLightColor2: 0x2dd7ff,<br/>+ // plane params<br/>+ metalness: 0.2,<br/>+ roughness: 0.7,<br/>+ meshColor: 0xffffff,<br/>+ meshEmissive: 0x000098,<br/>}<br/>+ const terrainWidth = 30<br/>+ const terrainHeight = 30<br/>+ const lightPos1 = {<br/>+   x: 15,<br/>+   y: 1,<br/>+   z: 5<br/>+ }<br/>+ const lightIntensity1 = 0.85<br/>+ const lightPos2 = {<br/>+   x: -15,<br/>+   y: 1,<br/>+   z: 5<br/>+ }<br/>+ const lightIntensity2 = 0.85<br/><br/>...<br/><br/>- let camera = createCamera(45, 1, 1000, { x: 0, y: 5, z: -15 })<br/>+ let camera = createCamera(70, 1, 120, { x: 0, y: 0, z: 2.4 })<br/><br/>...<br/><br/>let app = {<br/>  async initScene() {<br/>    // OrbitControls<br/>    this.controls = new OrbitControls(camera, renderer.domElement)<br/>    this.controls.enableDamping = true<br/><br/>    // Environment<br/>    await loadSceneBackground(scene, Background)<br/><br/>+   // Lighting<br/>+   this.dirLight1 = new THREE.DirectionalLight(params.dirLightColor1, lightIntensity1)<br/>+   this.dirLight1.position.set(lightPos1.x, lightPos1.y, lightPos1.z)<br/>+   scene.add(this.dirLight1)<br/>+   this.dirLight2 = new THREE.DirectionalLight(params.dirLightColor2, lightIntensity2)<br/>+   this.dirLight2.position.set(lightPos2.x, lightPos2.y, lightPos2.z)<br/>+   scene.add(this.dirLight2)<br/><br/>+   // load heightmap to a new image first, then read its color data to set the heights of our plane vertices<br/>+   // see: https://gist.github.com/jawdatls/465d82f2158e1c4ce161<br/>+   let hm_image = await loadImage(HeightMap)<br/>+   var canvas = document.createElement("canvas")<br/>+   canvas.width = hm_image.width<br/>+   canvas.height = hm_image.height<br/>+   var context = canvas.getContext("2d")<br/>+   context.drawImage(hm_image, 0, 0)<br/>+   var hm_imageData = context.getImageData(0, 0, canvas.width, canvas.height)<br/><br/>+   // Create a PlaneGeom<br/>+   let planeGeometry = new THREE.PlaneGeometry(terrainWidth, terrainHeight, terrainWidth, terrainHeight)<br/>+   let geometryPositions = planeGeometry.getAttribute("position").array<br/>+   let geometryUVs = planeGeometry.getAttribute("uv").array<br/><br/>+   // update each vertex position's z value according to the value we extracted from the heightmap image<br/>+   for (let index = 0; index &lt; geometryUVs.length / 2; index++) {<br/>+     let vertexU = geometryUVs[index * 2]<br/>+     let vertexV = geometryUVs[index * 2 + 1]<br/>+     // Update the z positions according to height map<br/>+     let terrainHeight = getZFromImageDataPoint(hm_imageData, vertexU, vertexV, canvas.width, canvas.height)<br/>+     geometryPositions[index * 3 + 2] = terrainHeight<br/>+   }<br/>+   // skew the plane geometry<br/>+   const shearMtx = new THREE.Matrix4()<br/>+   shearMtx.makeShear(-0.5, 0, 0, 0, 0, 0)<br/>+   planeGeometry.applyMatrix4(shearMtx)<br/><br/>+   // material for the plane geometry<br/>+   let meshMaterial = new THREE.MeshStandardMaterial({<br/>+     color: new THREE.Color(params.meshColor),<br/>+     emissive: new THREE.Color(params.meshEmissive),<br/>+     metalness: params.metalness,<br/>+     roughness: params.roughness,<br/>+     flatShading: true<br/>+   })<br/><br/>+   // create plane mesh and add to scene<br/>+   let mesh = new THREE.Mesh(planeGeometry, meshMaterial)<br/>+   mesh.position.set(0, -1.5, 0)<br/>+   mesh.rotation.x -= Math.PI / 2<br/>+   scene.add(mesh)<br/><br/>    // GUI controls<br/>    const gui = new dat.GUI()</span></pre><p id="ea5e" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">这是怎么回事？首先，我们添加依赖关系和必要的变量，用于设置照明和平面几何体+材质。我们还更新了摄像机，以便更好地观察我们的场景；我喜欢使用更大的<code class="fe nn no np nq b">fov</code>，这样场景看起来更宽。</p><p id="5c4e" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">然后在<code class="fe nn no np nq b">initScene()</code>中，我们添加了两个<code class="fe nn no np nq b">DirectionalLight</code>来照射左右两边的山体。如果没有光线，整个地形会有相同的颜色，没有明暗变化。</p><p id="d69d" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">之后，我们创建一个<code class="fe nn no np nq b">canvas</code>对象来存储加载的高度图图像，并通过<code class="fe nn no np nq b">context.getImageData()</code>将图像数据保存到<code class="fe nn no np nq b">hm_imageData</code>中。不要担心，这个画布没有添加到文档中，因此在屏幕上是不可见的。</p><p id="e433" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">然后我们创建一个具有相同宽度和高度(设置为30)的正方形<code class="fe nn no np nq b">planeGeometry</code>，为简单起见，宽度/高度段也具有相同的值。我们从普通的<code class="fe nn no np nq b">PlaneGeometry</code>中提取出<code class="fe nn no np nq b">BufferAttribute</code>中的<code class="fe nn no np nq b">position</code>和<code class="fe nn no np nq b">uv</code>数组以备后用。</p><p id="e043" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">然后我们遍历所有的顶点来设置每个顶点的高度值。我们使用<code class="fe nn no np nq b">getZFromImageDataPoint()</code>来获得高度图上每个顶点对应的高度值。看看for循环，<code class="fe nn no np nq b">geometryUVs.length / 2</code>表示顶点的总数，因为<code class="fe nn no np nq b">BufferAttribute</code>数组在一个层中顺序存储值，而不是嵌套每个顶点的x，y，z或u，v值；见下图。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi oy"><img src="../Images/37f4e1ef68b7862b12685cef3b45bbfe.png" data-original-src="https://miro.medium.com/v2/resize:fit:820/format:webp/1*xRZcvLRl8p4ZjkmC7O4jtA.png"/></div><p class="ns nt gj gh gi nu nv bd b be z dk translated">每个BufferAttribute的数组结构，图片来自<a class="ae na" href="https://threejs.org/manual/#en/custom-buffergeometry" rel="noopener ugc nofollow" target="_blank">https://threejs.org/manual/#en/custom-buffergeometry</a></p></figure><p id="9b60" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">这就是为什么在<code class="fe nn no np nq b">geometryPositions[index * 3 + 2]</code>中，we乘以3因为每个顶点有3个位置值x，y，z，加2就是得到z值。</p><p id="fdbe" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">现在我们已经为每个顶点设置了正确的高度，我们仍然需要沿着y方向剪切平面。我没有真正深入到<code class="fe nn no np nq b">makeShear</code>函数的源代码中，但是如果我没有弄错的话，用<code class="fe nn no np nq b">0.5</code>剪切它应该是正确的幅度。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi oz"><img src="../Images/42bf7eb434ab18a8a86eed95ca1c576f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*dQuUxzk7rytJAuojP29MiQ.png"/></div></div><p class="ns nt gj gh gi nu nv bd b be z dk translated">我们想沿着y轴剪切它，直到图案看起来像一对对称三角形的组合</p></figure><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi oz"><img src="../Images/05048d0a396b7d99ce3a33fa23503f0a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*4Q4NeyC5z2ec2TQN36t8kA.png"/></div></div><p class="ns nt gj gh gi nu nv bd b be z dk translated">虚线表示普通平面几何形状的一个单元，实线表示剪切状态</p></figure><p id="7a92" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">我们创建的普通平面几何体由正方形组成，因为宽度和高度值与宽度和高度部分相同。我们想在y方向剪切它一半的正方形长度<code class="fe nn no np nq b">l/2</code>。查看上面简化的2d剪切方程，如果我们将剪切因子<code class="fe nn no np nq b">s</code>设置为0.5，那么我们得到的坐标将是<code class="fe nn no np nq b">(x, y + 0.5x)</code>。代入<code class="fe nn no np nq b">x = l</code>，剪切的量就是<code class="fe nn no np nq b">l/2</code>，这就是我们想要的量。</p><p id="8dcd" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated"><a class="ae na" href="https://www.youtube.com/watch?v=cxbTV5Jjm6s" rel="noopener ugc nofollow" target="_blank">这个视频</a>很好地解释了剪切概念。</p><p id="9337" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">对于平面材质，我们使用<code class="fe nn no np nq b">MeshStandardMaterial</code>，因此我们可以使用<code class="fe nn no np nq b">metalness</code>和<code class="fe nn no np nq b">roughness</code>进行调整。打开<code class="fe nn no np nq b">flatShading</code>很重要，因为视觉样式更适合低多边形的对象。</p><p id="2e9e" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">应用所有更改后，您的场景现在应该如下所示:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi ox"><img src="../Images/cec0aae3ea400429ae737baf069bffea.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*p0KTJpMyuOpH4K9A6pRP4w.png"/></div></div></figure><h1 id="59f1" class="ln lo iq bd lp lq lr ls lt lu lv lw lx jw ly jx lz jz ma ka mb kc mc kd md me bi translated">6.在地形上创建亮/霓虹网格线</h1><p id="6899" class="pw-post-body-paragraph kr ks iq kt b ku mh jr kw kx mi ju kz la mv lc ld le mw lg lh li mx lk ll lm ij bi translated">最初，我尝试使用<code class="fe nn no np nq b">WireframeGeometry</code>和<code class="fe nn no np nq b">LineSegments</code>来创建网格线，但是有一个严重的限制。遗憾的是，使用的<code class="fe nn no np nq b">LineBasicMaterial</code>被限制为<code class="fe nn no np nq b">linewidth</code>总是为1，而不管设置了什么值。</p><p id="0cd7" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">幸运的是，还有另一种方法来实现可配置粗细的线条。按照<a class="ae na" href="https://threejs.org/examples/?q=fat#webgl_lines_fat" rel="noopener ugc nofollow" target="_blank">这个例子</a>演示的方法，我们能够控制线条的粗细。但是如果我们要实现这个方法，我们将需要注入了高度图数据的平面几何的顶点位置。</p><p id="3519" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">这就是为什么需要手动计算每个顶点的z值，而不是简单地将<code class="fe nn no np nq b">heightmap</code>分配给材质的<code class="fe nn no np nq b">displacementMap</code>属性(如第2节所述)。</p><p id="afac" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">在<code class="fe nn no np nq b">index.js</code>中进行以下更改:</p><pre class="kg kh ki kj gt on nq oo bn op oq bi"><span id="1c85" class="or lo iq nq b be os ot l ow ov">import Stats from "three/examples/jsm/libs/stats.module"<br/>import { OrbitControls } from "three/examples/jsm/controls/OrbitControls"<br/>+ import { LineGeometry } from "three/examples/jsm/lines/LineGeometry"<br/>+ import { LineMaterial } from "three/examples/jsm/lines/LineMaterial"<br/>+ import { Line2 } from "three/examples/jsm/lines/Line2"<br/><br/>...<br/><br/>const params = {<br/>  // general scene params<br/>  dirLightColor1: 0x2dd7ff,<br/>  dirLightColor2: 0x2dd7ff,<br/>  // plane params<br/>  metalness: 0.2,<br/>  roughness: 0.7,<br/>  meshColor: 0xffffff,<br/>  meshEmissive: 0x000098,<br/>+ lineWidth: 0.04,<br/>+ lineColor: 0xcee4ff,<br/>}<br/><br/>...<br/><br/>- let renderer = createRenderer({ antialias: true }, (_renderer) =&gt; {<br/>+ let renderer = createRenderer({ antialias: true, logarithmicDepthBuffer: true }, (_renderer) =&gt; {<br/><br/>...<br/><br/>let app = {<br/>  async initScene() {<br/>    ...<br/><br/>+   // the grid lines, reference: https://threejs.org/examples/?q=line#webgl_lines_fat<br/>+   let lineGeometry = new LineGeometry()<br/>+   let linePositions = []<br/>+   // This is a specific way to map line points to cooresponding vertices of the planeGeometry<br/>+   for (let row = 0; row &lt; terrainHeight; row++) {<br/>+     let isEvenRow = row % 2 == 0<br/>+     for (let col = (isEvenRow ? 0 : (terrainWidth - 1)); isEvenRow ? (col &lt; terrainWidth) : (col &gt;= 0); isEvenRow ? col++ : col--) {<br/>+       for (let point = (isEvenRow ? 0 : 3); isEvenRow ? (point &lt; 4) : (point &gt;= 0); isEvenRow ? point++ : point--) {<br/>+         let mappedIndex<br/>+         let rowOffset = row * (terrainWidth + 1)<br/>+         if (point &lt; 2) {<br/>+           mappedIndex = rowOffset + col + point<br/>+         } else {<br/>+           mappedIndex = rowOffset + col + point + terrainWidth - 1<br/>+         }<br/><br/>+         linePositions.push(geometryPositions[mappedIndex * 3])<br/>+         linePositions.push(geometryPositions[mappedIndex * 3 + 1])<br/>+         linePositions.push(geometryPositions[mappedIndex * 3 + 2])<br/>+       }<br/>+     }<br/>+   }<br/>+   lineGeometry.setPositions(linePositions)<br/><br/>+   // the material for the grid lines<br/>+   let lineMaterial = new LineMaterial({<br/>+     color: params.lineColor,<br/>+     linewidth: params.lineWidth, // in world units with size attenuation, pixels otherwise<br/>+     alphaToCoverage: false,<br/>+     worldUnits: true // such that line width depends on world distance<br/>+   })<br/><br/>    // create plane mesh and add to scene<br/>    let mesh = new THREE.Mesh(planeGeometry, meshMaterial)<br/>    mesh.position.set(0, -1.5, 0)<br/>    mesh.rotation.x -= Math.PI / 2<br/>    scene.add(mesh)<br/><br/>+   // create the lines mesh and add to scene<br/>+   let line = new Line2(lineGeometry, lineMaterial)<br/>+   line.computeLineDistances()<br/>+   line.position.set(0, -1.5, 0)<br/>+   line.rotation.x -= Math.PI / 2<br/>+   scene.add(line)<br/><br/>    // GUI controls<br/>    const gui = new dat.GUI()</span></pre><p id="2984" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">注意，我们打开了渲染器的<code class="fe nn no np nq b">logarithmicDepthBuffer</code>。此配置修复了网格线和平面几何体之间的z战斗问题。在<a class="ae na" href="https://threejs.org/manual/#en/cameras" rel="noopener ugc nofollow" target="_blank">https://threejs.org/manual/#en/cameras</a>的下半部分阅读更多关于这个问题的内容。</p><p id="3594" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">另外，请注意，<code class="fe nn no np nq b">LineGeometry</code>、<code class="fe nn no np nq b">LineMaterial</code>和<code class="fe nn no np nq b">Line2</code>类不是来自核心的Three.js库。它们是从<code class="fe nn no np nq b">jsm</code>文件夹导入的。</p><p id="ebea" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated"><code class="fe nn no np nq b">LineGeometry</code>的工作方式是它需要一个顶点位置的顺序数组，然后它会画一条线，以相同的顺序连接位置数组中指定的点。所以基本上只画了一条线，从头到尾。</p><p id="b8d1" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">三重嵌套的for循环代码块所做的是正确设置顶点的顺序数组。我用一个简单的例子来解释。</p><p id="7864" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">比方说如果我们根本不计算<code class="fe nn no np nq b">linePositions</code>直接用平面几何的<code class="fe nn no np nq b">geometryPositions</code>:</p><pre class="kg kh ki kj gt on nq oo bn op oq bi"><span id="b62f" class="or lo iq nq b be os ot l ow ov">lineGeometry.setPositions(geometryPositions)</span></pre><p id="ccbe" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">你看到的会是混乱的:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi ox"><img src="../Images/8109c55e66ad3c851cd47f068d164dbc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*LErCZt-42V_GclZSR_1wSw.png"/></div></div></figure><p id="a99d" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">原因是顶点位置的默认顺序是从左到右逐行排列的。查看带有数字辅助对象的平面几何体，这些辅助对象标记了下面的每个顶点:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi pa"><img src="../Images/31b3c94a3b209f80456c07a7ad8496ea.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*xZyjtxIdb-REHKNVWWtmxQ.png"/></div></div><p class="ns nt gj gh gi nu nv bd b be z dk translated">位于<a class="ae na" href="https://hofk.de/main/discourse.threejs/2022/THREEn/NumberingHelperExamples.html" rel="noopener ugc nofollow" target="_blank">https://hofk . de/main/discourse . three js/2022/three n/numberinghelperexamples . html</a>的示例截图</p></figure><p id="c669" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">因此，正在绘制的线只是遵循顶点顺序，结果是这样的(蓝线):</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi oz"><img src="../Images/e9f4ce483366345216fb01522e1fea64.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*7yfYYH2FrYhvzZ7cc_9cTA.png"/></div></div><p class="ns nt gj gh gi nu nv bd b be z dk translated">每一行都是从最右边到最左边，难怪我们会看到一片混乱</p></figure><p id="89e6" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">为了防止行从右边缘跳到左边缘，我们必须以特定的方式排列行的位置。</p><p id="eeed" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">对于第一行，我们应该按照顶点顺序绘制直线:</p><p id="5bc6" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">v0 — v1 — v5 — v6，接着是v1 — v2 — v6 — v7，依此类推。</p><p id="1529" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">然而，对于第二行，我们必须从右侧开始，而不是从左侧开始，因为否则，我们会遇到同样的问题，即直线从右边缘跳到左边缘。所以基本上，对于偶数行，我们必须按照奇数行的相反顺序排列顶点。</p><p id="4618" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">因此，对于第二行，我们应该遵循以下顶点顺序:</p><p id="3c74" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">v14 — v13 — v9 — v8，接着是v13 — v12 — v8 — v7，依此类推。</p><p id="f17d" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">通过实施这种特殊的排序，我们可以在我们的地形上获得一个完美的线网格:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi ox"><img src="../Images/ade7fb9cf055f944ed1f57533234d789.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*N2S-QoygFgqaRebPYCChVg.png"/></div></div><p class="ns nt gj gh gi nu nv bd b be z dk translated">走近我们的最终产品！</p></figure><h1 id="fb8d" class="ln lo iq bd lp lq lr ls lt lu lv lw lx jw ly jx lz jz ma ka mb kc mc kd md me bi translated">7.创造一个没有尽头的地形的幻觉</h1><p id="f3dd" class="pw-post-body-paragraph kr ks iq kt b ku mh jr kw kx mi ju kz la mv lc ld le mw lg lh li mx lk ll lm ij bi translated">这个项目令人兴奋的部分来了:伪造一个永无止境的地形！</p><p id="31a4" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">如果您跳过了上面第2部分的解释，我将快速回顾一下这个概念:</p><ol class=""><li id="1385" class="mf mg iq kt b ku kv kx ky la nw le nx li ny lm mm mn mo mp bi translated">制作几组地形图</li><li id="f054" class="mf mg iq kt b ku mq kx mr la ms le mt li mu lm mm mn mo mp bi translated">像火车一样把他们连接起来</li><li id="5450" class="mf mg iq kt b ku mq kx mr la ms le mt li mu lm mm mn mo mp bi translated">让火车朝着摄像机移动</li><li id="3a21" class="mf mg iq kt b ku mq kx mr la ms le mt li mu lm mm mn mo mp bi translated">弹出火车头部，如果它在摄像机后面，就把它放回尾部。</li><li id="141a" class="mf mg iq kt b ku mq kx mr la ms le mt li mu lm mm mn mo mp bi translated">瞧啊。这就是你如何伪造一个无尽的地形。</li></ol><p id="3256" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">在我的开发过程中，我发现为所有连续的地形克隆只重复一个高度图在视觉上太重复了，所以我做了一个快速修复，使地形看起来不那么重复；通过水平翻转高度图来“创建”第二个高度图。也就是说，对于“奇数”地形使用高度图，而对于“偶数”地形反转高度图。</p><p id="c0ad" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">让我们在<code class="fe nn no np nq b">index.js</code>中进行以下代码更改:</p><pre class="kg kh ki kj gt on nq oo bn op oq bi"><span id="e9c1" class="or lo iq nq b be os ot l ow ov">/**************************************************<br/> * 0. Tweakable parameters for the scene<br/> *************************************************/<br/>const params = {<br/>  // general scene params<br/>+ speed: 2.5,<br/><br/>...<br/><br/>const lightIntensity2 = 0.85<br/>+ // need to be even number since the consecutive terrains are stitched in pairs<br/>+ const numOfMeshSets = 6<br/><br/>...<br/><br/>let app = {<br/>  async initScene() {<br/>    ...<br/>    scene.add(this.dirLight2)<br/><br/>+   // create sets of objects, for the capability to use different heightmaps for each set of plane and lines<br/>+   let planeGeometries = []<br/>+   let lineGeometries = []<br/>+   let geometryPositionsArray = []<br/><br/>+   // we only loop twice here, although we load a single HeightMap, the trick is:<br/>+   // first loop we load the HeightMap the normal way<br/>+   // second loop we load the HeightMap data horizontally inversed<br/>+   for (let i = 0; i &lt; 2; i++) {<br/>      // load heightmap to a new image first, then read its color data to set the heights of our plane vertices<br/>      // see: https://gist.github.com/jawdatls/465d82f2158e1c4ce161<br/>      let hm_image = await loadImage(HeightMap)<br/>      var canvas = document.createElement("canvas")<br/>      canvas.width = hm_image.width<br/>      canvas.height = hm_image.height<br/>      var context = canvas.getContext("2d")<br/>      context.drawImage(hm_image, 0, 0)<br/>      var hm_imageData = context.getImageData(0, 0, canvas.width, canvas.height)<br/><br/>      // Create a PlaneGeom<br/>      let planeGeometry = new THREE.PlaneGeometry(terrainWidth, terrainHeight, terrainWidth, terrainHeight)<br/>      let geometryPositions = planeGeometry.getAttribute("position").array<br/>      let geometryUVs = planeGeometry.getAttribute("uv").array<br/><br/>      // update each vertex position's z value according to the value we extracted from the heightmap image<br/>      for (let index = 0; index &lt; geometryUVs.length / 2; index++) {<br/>        let vertexU = geometryUVs[index * 2]<br/>        let vertexV = geometryUVs[index * 2 + 1]<br/>-       // Update the z positions according to height map,<br/>-       let terrainHeight = getZFromImageDataPoint(hm_imageData, vertexU, vertexV, canvas.width, canvas.height)<br/>+       // Update the z positions according to height map, inverse heightmap horizontally for the second loop<br/>+       let terrainHeight = getZFromImageDataPoint(hm_imageData, (i == 0 ? vertexU : 1 - vertexU), vertexV, canvas.width, canvas.height)<br/>        geometryPositions[index * 3 + 2] = terrainHeight<br/>      }<br/>      // skew the plane geometry<br/>      const shearMtx = new THREE.Matrix4()<br/>      shearMtx.makeShear(-0.5, 0, 0, 0, 0, 0)<br/>      planeGeometry.applyMatrix4(shearMtx)<br/><br/>+     planeGeometries.push(planeGeometry)<br/>+     geometryPositionsArray.push(geometryPositions)<br/>+   }<br/><br/>+   // zip up the gaps between the 1st and 2nd plane geometries<br/>+   for (let index = 0; index &lt;= terrainWidth; index++) {<br/>+     let bottomOffset = (terrainWidth + 1) * terrainHeight<br/>+     // 2nd geom's bottom row height should be synced with 1st geom's top<br/>+     geometryPositionsArray[1][(bottomOffset + index) * 3 + 2] = geometryPositionsArray[0][index * 3 + 2]<br/>+     // 1st geom's bottom row height should be synced with 2nd geom's top<br/>+     geometryPositionsArray[0][(bottomOffset + index) * 3 + 2] = geometryPositionsArray[1][index * 3 + 2]<br/>+   }<br/><br/>    // material for the plane geometry<br/>    let meshMaterial = new THREE.MeshStandardMaterial({<br/>      color: new THREE.Color(params.meshColor),<br/>      emissive: new THREE.Color(params.meshEmissive),<br/>      metalness: params.metalness,<br/>      roughness: params.roughness,<br/>      flatShading: true<br/>    })<br/><br/>    // the grid lines, reference: https://threejs.org/examples/?q=line#webgl_lines_fat<br/>+   for (let i = 0; i &lt; 2; i++) {<br/>      let lineGeometry = new LineGeometry()<br/>      let linePositions = []<br/>      // This is a specific way to map line points to corresponding vertices of the planeGeometry<br/>      for (let row = 0; row &lt; terrainHeight; row++) {<br/>        let isEvenRow = row % 2 == 0<br/>        for (let col = (isEvenRow ? 0 : (terrainWidth - 1)); isEvenRow ? (col &lt; terrainWidth) : (col &gt;= 0); isEvenRow ? col++ : col--) {<br/>          for (let point = (isEvenRow ? 0 : 3); isEvenRow ? (point &lt; 4) : (point &gt;= 0); isEvenRow ? point++ : point--) {<br/>            let mappedIndex<br/>            let rowOffset = row * (terrainWidth + 1)<br/>            if (point &lt; 2) {<br/>              mappedIndex = rowOffset + col + point<br/>            } else {<br/>              mappedIndex = rowOffset + col + point + terrainWidth - 1<br/>            }<br/><br/>-           linePositions.push(geometryPositions[mappedIndex * 3])<br/>-           linePositions.push(geometryPositions[mappedIndex * 3 + 1])<br/>-           linePositions.push(geometryPositions[mappedIndex * 3 + 2])<br/>+           linePositions.push(geometryPositionsArray[i][mappedIndex * 3])<br/>+           linePositions.push(geometryPositionsArray[i][mappedIndex * 3 + 1])<br/>+           linePositions.push(geometryPositionsArray[i][mappedIndex * 3 + 2])<br/>          }<br/>        }<br/>      }<br/>      lineGeometry.setPositions(linePositions)<br/><br/>+     lineGeometries.push(lineGeometry)<br/>+   }<br/><br/>-   // create plane mesh and add to scene<br/>-   let mesh = new THREE.Mesh(planeGeometry, meshMaterial)<br/>-   mesh.position.set(0, -1.5, 0)<br/>-   mesh.rotation.x -= Math.PI / 2<br/>-   scene.add(mesh)<br/>-   // create the lines mesh and add to scene<br/>-   let line = new Line2(lineGeometry, lineMaterial)<br/>-   line.computeLineDistances()<br/>-   line.position.set(0, -1.5, 0)<br/>-   line.rotation.x -= Math.PI / 2<br/>-   scene.add(line)<br/><br/>+   this.meshGroup = []<br/>+   this.lineGroup = []<br/>+   // create multiple sets of plane and line meshes determined by numOfMeshSets<br/>+   for (let i = 0; i &lt; numOfMeshSets; i++) {<br/>+     // create the meshes<br/>+     let mesh = new THREE.Mesh(planeGeometries[i % 2], meshMaterial)<br/>+     let line = new Line2(lineGeometries[i % 2], lineMaterial)<br/>+     line.computeLineDistances()<br/>+     // set the correct pos and rot for both the terrain and its wireframe<br/>+     mesh.position.set(0, -1.5, -terrainHeight * i)<br/>+     mesh.rotation.x -= Math.PI / 2<br/>+     line.position.set(0, -1.5, -terrainHeight * i)<br/>+     line.rotation.x -= Math.PI / 2<br/>+     // add the meshes to the scene<br/>+     scene.add(mesh)<br/>+     scene.add(line)<br/>+     this.meshGroup.push(mesh)<br/>+     this.lineGroup.push(line)<br/>+   }<br/><br/>...<br/><br/>  // @param {number} interval - time elapsed between 2 frames<br/>  // @param {number} elapsed - total time elapsed since app start<br/>  updateScene(interval, elapsed) {<br/>    this.controls.update()<br/>    this.stats1.update()<br/><br/>+   for (let i = 0; i &lt; numOfMeshSets; i++) {<br/>+     this.meshGroup[i].position.z += interval * params.speed<br/>+     this.lineGroup[i].position.z += interval * params.speed<br/>+     if (this.meshGroup[i].position.z &gt;= terrainHeight) {<br/>+       this.meshGroup[i].position.z -= numOfMeshSets * terrainHeight<br/>+       this.lineGroup[i].position.z -= numOfMeshSets * terrainHeight<br/>+     }<br/>+   }<br/>  }</span></pre><p id="a074" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">我们定义了一个新的<code class="fe nn no np nq b">speed</code>参数来控制地形移动的速度。我们还定义了一个新的<code class="fe nn no np nq b">numOfMeshSets</code>变量来控制我们想要创建多少地形副本。</p><p id="1991" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">现在，我们定义变量<code class="fe nn no np nq b">planeGeometries</code>、<code class="fe nn no np nq b">lineGeometries</code>和<code class="fe nn no np nq b">geometryPositionsArray</code>来存储两组几何图形，每组都是由于使用的<code class="fe nn no np nq b">heightmaps</code>不同而产生的。</p><p id="751d" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">然后，我们将平面和线几何设置代码包装在一个2圈的for循环中。在平面几何设置的第二个循环中，我们将<code class="fe nn no np nq b">1 — vertexU</code>传递给<code class="fe nn no np nq b">u</code>参数来实现水平反转高度图的效果。</p><p id="76d4" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">在<code class="fe nn no np nq b">runApp()</code>中设置的动画循环每一帧都会调用<code class="fe nn no np nq b">updateScene()</code>功能。这里添加的代码是无休止地激活地形的东西。相机设置也是一个因素。由于其<code class="fe nn no np nq b">far</code>值设置为120，而“地形列车”的可见长度约为150至180，我们将永远不会看到弹出的地形抖动被添加回列车尾部。</p><p id="04cf" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">变化之后，你会看到地形不断向你移动。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi ox"><img src="../Images/ac9c91a9066266f7e300114ebf69c563.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*FnJhhcMh-HQx0oyjJF97EA.png"/></div></div><p class="ns nt gj gh gi nu nv bd b be z dk translated">在永无止境的地形中前进的错觉</p></figure><h1 id="376e" class="ln lo iq bd lp lq lr ls lt lu lv lw lx jw ly jx lz jz ma ka mb kc mc kd md me bi translated">8.添加落日☀并制作动画</h1><p id="7b61" class="pw-post-body-paragraph kr ks iq kt b ku mh jr kw kx mi ju kz la mv lc ld le mw lg lh li mx lk ll lm ij bi translated">这也是一个有趣的部分，但涉及到这个项目中最复杂的数学。我花了一些时间来找出正确的公式来制作太阳上这些条纹的动画。我使用自定义着色器，以动画太阳的颜色。如果你不熟悉这个主题，请阅读关于<a class="ae na" href="https://thebookofshaders.com/" rel="noopener ugc nofollow" target="_blank">https://thebookofshaders.com/</a>的着色器。</p><p id="3760" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">将以下代码附加到<code class="fe nn no np nq b">functions.js</code>:</p><pre class="kg kh ki kj gt on nq oo bn op oq bi"><span id="933e" class="or lo iq nq b be os ot l ow ov">// vertexShader for the Sun<br/>export function vertexShader() {<br/>  return `<br/>      varying vec2 vUv;<br/>      varying vec3 vPos;<br/>      void main() {<br/>        vUv = uv;<br/>        vPos = position;<br/>        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0); <br/>      }<br/>  `<br/>}<br/><br/>// fragmentShader for the Sun<br/>export function fragmentShader() {<br/>  return `<br/>      #ifdef GL_ES<br/>      precision mediump float;<br/>      #endif<br/>      #define PI 3.14159265359<br/>      #define TWO_PI 6.28318530718<br/>      <br/>      uniform vec2 u_resolution;<br/>      uniform vec2 u_mouse;<br/>      uniform float u_time;<br/>      uniform vec3 color_main;<br/>      uniform vec3 color_accent;<br/>      varying vec2 vUv;<br/>      varying vec3 vPos;<br/>      void main() {<br/>        vec2 st = gl_FragCoord.xy/u_resolution.xy;<br/>        float x = vPos.y;<br/>        float osc = ceil(sin((3. - (x - u_time) / 1.5) * 5.) / 2. + 0.4 - floor((3. - x / 1.5) * 5. / TWO_PI) / 10.);<br/>        vec3 color = mix(color_accent, color_main, smoothstep(0.2, 1., vUv.y));<br/>        gl_FragColor = vec4(color, osc);<br/>      }<br/>  `<br/>}</span></pre><p id="e312" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">我很乐意花更多的时间来解释<code class="fe nn no np nq b">fragmentShader</code>中的代码，但是我担心这篇文章会变得太长。</p><p id="8ee8" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">接下来，对<code class="fe nn no np nq b">index.js</code>进行如下更改:</p><pre class="kg kh ki kj gt on nq oo bn op oq bi"><span id="1749" class="or lo iq nq b be os ot l ow ov">- import { createCamera, createComposer, createRenderer, runApp } from "./core-utils"<br/>+ import { createCamera, createComposer, createRenderer, runApp, getDefaultUniforms } from "./core-utils"<br/><br/>- import { loadImage} from "./common-utils"<br/>- import { loadSceneBackground, getZFromImageDataPoint } from "./functions"<br/>+ import { loadImage, hexToRgb } from "./common-utils"<br/>+ import { loadSceneBackground, getZFromImageDataPoint, vertexShader, fragmentShader } from "./functions"<br/><br/>...<br/><br/>/**************************************************<br/> * 0. Tweakable parameters for the scene<br/> *************************************************/<br/>const params = {<br/>  // general scene params<br/>  ...<br/>+ // sun params<br/>+ topColor: 0xffab00,<br/>+ bottomColor: 0xff51c8<br/>}<br/>...<br/>const lightIntensity2 = 0.85<br/>// need to be even number since the consecutive terrains are stitched in pairs<br/>const numOfMeshSets = 6<br/>+ const sunPos = {<br/>+   x: 0,<br/>+   y: 16,<br/>+   z: -100<br/>+ }<br/>+ const uniforms = {<br/>+   ...getDefaultUniforms(),<br/>+   color_main: { // sun's top color<br/>+     value: hexToRgb("#ffab00", true)<br/>+   },<br/>+   color_accent: { // sun's bottom color<br/>+     value: hexToRgb("#ff51c8", true)<br/>+   }<br/>+ }<br/><br/>...<br/><br/>let app = {<br/>  async initScene() {<br/>    ...<br/><br/>+   // the sun<br/>+   const sunGeom = new THREE.SphereGeometry(30, 64, 64)<br/>+   const sunMat = new THREE.ShaderMaterial({<br/>+     uniforms: uniforms,<br/>+     vertexShader: vertexShader(),<br/>+     fragmentShader: fragmentShader(),<br/>+     transparent: true<br/>+   })<br/>+   let sun = new THREE.Mesh(sunGeom, sunMat)<br/>+   sun.position.set(sunPos.x, sunPos.y, sunPos.z)<br/>+   scene.add(sun)<br/><br/>    // GUI controls<br/>    const gui = new dat.GUI()</span></pre><p id="f9bc" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated"><code class="fe nn no np nq b">uniforms</code>变量包含要传递给着色器程序的参数。<code class="fe nn no np nq b">fragmentShader()</code>中的动画代码也利用了<code class="fe nn no np nq b">getDefaultUniforms.</code>定义的<code class="fe nn no np nq b">u_time</code><code class="fe nn no np nq b">u_time</code>由<code class="fe nn no np nq b">runApp</code>中的动画循环更新。对于任何动画代码来说，时间都是必不可少的元素。</p><p id="7c15" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">应用代码更改会给你一个动画太阳:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi ox"><img src="../Images/bc7f6c859e29893b8713c3f6695d7d9d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*9HHsTYiCFvvx4rjEgxLp9Q.png"/></div></div></figure><h1 id="ce44" class="ln lo iq bd lp lq lr ls lt lu lv lw lx jw ly jx lz jz ma ka mb kc mc kd md me bi translated">9.添加GUI控件以在运行时调整参数</h1><p id="84d4" class="pw-post-body-paragraph kr ks iq kt b ku mh jr kw kx mi ju kz la mv lc ld le mw lg lh li mx lk ll lm ij bi translated">GUI控件有助于开发人员在运行时快速测试各种参数值。通常，GUI控件是在开发的早期阶段添加的，但是为了本文的流程，我宁愿先解释所有重要的代码。</p><p id="40f5" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">在<code class="fe nn no np nq b">index.js</code>中进行以下更改:</p><pre class="kg kh ki kj gt on nq oo bn op oq bi"><span id="b145" class="or lo iq nq b be os ot l ow ov">  async initScene() {<br/>    ...<br/><br/>    // GUI<br/>    const gui = new dat.GUI()<br/><br/>+   gui.add(guiOptions, "speed", 1, 10, 0.5).name('Plane speed')<br/>+   gui.addColor(guiOptions, 'dirLightColor1').name('Dir light 1').onChange((val) =&gt; {<br/>+     this.dirLight1.color.set(val)<br/>+   })<br/>+   gui.addColor(guiOptions, 'dirLightColor2').name('Dir light 2').onChange((val) =&gt; {<br/>+     this.dirLight2.color.set(val)<br/>+   })<br/><br/>+   let planeFolder = gui.addFolder(`Plane`)<br/>+   planeFolder.add(guiOptions, "metalness", 0, 1, 0.05).onChange((val) =&gt; {<br/>+     meshMaterial.metalness = val<br/>+   })<br/>+   planeFolder.add(guiOptions, "roughness", 0, 1, 0.05).onChange((val) =&gt; {<br/>+     meshMaterial.roughness = val<br/>+   })<br/>+   planeFolder.addColor(guiOptions, 'meshColor').name('color').onChange((val) =&gt; {<br/>+     meshMaterial.color.set(val)<br/>+   })<br/>+   planeFolder.addColor(guiOptions, 'meshEmissive').name('emissive').onChange((val) =&gt; {<br/>+     meshMaterial.emissive.set(val)<br/>+   })<br/>+   planeFolder.addColor(guiOptions, 'lineColor').name('line color').onChange((val) =&gt; {<br/>+     lineMaterial.color.set(val)<br/>+   })<br/>+   planeFolder.add(guiOptions, "lineWidth", 0, 0.1, 0.01).name('line width').onChange((val) =&gt; {<br/>+     lineMaterial.linewidth = val<br/>+   })<br/><br/>+   let sunFolder = gui.addFolder(`Sun`)<br/>+   sunFolder.addColor(guiOptions, 'topColor').name('top color').onChange((val) =&gt; {<br/>+     let clr = new THREE.Color(val)<br/>+     uniforms.color_main.value = hexToRgb(clr.getHexString(), true)<br/>+   })<br/>+   sunFolder.addColor(guiOptions, 'bottomColor').name('bottom color').onChange((val) =&gt; {<br/>+     let clr = new THREE.Color(val)<br/>+     uniforms.color_accent.value = hexToRgb(clr.getHexString(), true)<br/>+   })<br/><br/>    // Stats - show fps<br/>    this.stats1 = new Stats()<br/>    this.stats1.showPanel(0) // Panel 0 = fps<br/>    this.stats1.domElement.style.cssText = "position:absolute;top:0px;left:0px;"<br/>    this.container.appendChild(this.stats1.domElement)<br/>  },</span></pre><p id="d42e" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">现在你可以任意调整参数和颜色了！</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi ox"><img src="../Images/a905f23ff76152812edb7f7016331001.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*vQqczRBZrsfvqfsMlXHWkQ.png"/></div></div></figure><h1 id="e674" class="ln lo iq bd lp lq lr ls lt lu lv lw lx jw ly jx lz jz ma ka mb kc mc kd md me bi translated">10.用布鲁姆效果✨✨对场景进行后期处理，让它看起来更酷！</h1><p id="100a" class="pw-post-body-paragraph kr ks iq kt b ku mh jr kw kx mi ju kz la mv lc ld le mw lg lh li mx lk ll lm ij bi translated">下面是本文的最后一部分。我们将添加Bloom效果来照亮场景！这最后的润色对于让场景看起来很酷和散发出一种合成波的氛围是很重要的！</p><p id="1d0b" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">对<code class="fe nn no np nq b">index.js</code>进行以下更改:</p><pre class="kg kh ki kj gt on nq oo bn op oq bi"><span id="70c7" class="or lo iq nq b be os ot l ow ov">+ import { UnrealBloomPass } from "three/examples/jsm/postprocessing/UnrealBloomPass"<br/><br/>...<br/><br/>const params = {<br/>  // general scene params<br/>  speed: 2.5,<br/>  dirLightColor1: 0x2dd7ff,<br/>  dirLightColor2: 0x2dd7ff,<br/>+ // bloom params<br/>+ bloomStrength: 0.5,<br/>+ bloomRadius: 0.2,<br/>+ bloomThreshold: 0.5,<br/>  // plane params<br/>  metalness: 0.2,<br/>  ...<br/>}<br/><br/>...<br/><br/>// The RenderPass is already created in 'createComposer'<br/>+ // Post-processing with Bloom effect<br/>+ let bloomPass = new UnrealBloomPass(<br/>+   new THREE.Vector2(window.innerWidth, window.innerHeight),<br/>+   params.bloomStrength,<br/>+   params.bloomRadius,<br/>+   params.bloomThreshold<br/>+ );<br/>let composer = createComposer(renderer, scene, camera, (comp) =&gt; {<br/>+   comp.addPass(bloomPass)<br/>})<br/><br/>...<br/><br/>let app = {<br/>  async initScene() {<br/>  ...<br/><br/>    // GUI controls<br/>    const gui = new dat.GUI()<br/><br/>+   let bloomFolder = gui.addFolder(`Bloom`)<br/>+   bloomFolder.add(params, "bloomStrength", 0, 3, 0.05).onChange((val) =&gt; {<br/>+     bloomPass.strength = Number(val)<br/>+   })<br/>+   bloomFolder.add(params, "bloomRadius", 0, 1, 0.05).onChange((val) =&gt; {<br/>+     bloomPass.radius = Number(val)<br/>+   })<br/>+   bloomFolder.add(params, "bloomThreshold", 0, 1, 0.05).onChange((val) =&gt; {<br/>+     bloomPass.threshold = Number(val)<br/>+   })</span></pre><p id="343a" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">这需要一些实验来获得适合场景的高光参数。随着这最后的润色到位，整个场景现在照亮了✨:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi ox"><img src="../Images/ea9ede7e6c89eaf532b54f0581d39253.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*or1Gfq5My0GRs2O_56KiIQ.png"/></div></div><p class="ns nt gj gh gi nu nv bd b be z dk translated">一旦你开花了，就再也不会回来了。</p></figure></div><div class="ab cl pb pc hu pd" role="separator"><span class="pe bw bk pf pg ph"/><span class="pe bw bk pf pg ph"/><span class="pe bw bk pf pg"/></div><div class="ij ik il im in"><p id="c6ae" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">这就是了。您已经完成了教程！</p><p id="23e9" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">说实话，在动笔之前，我已经搭建了一个我认为足够好的版本。然而，当我开始写这篇文章时，我发现它并不好！</p><p id="32cf" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">我正在使用一个复杂的自定义<code class="fe nn no np nq b">BufferGeometry</code>构建地形几何图形。视觉效果和性能比我现在得到的结果更差。感谢阅读。</p></div></div>    
</body>
</html>