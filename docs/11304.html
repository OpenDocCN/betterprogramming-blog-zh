<html>
<head>
<title>Comparing 3 Code Analysis Frameworks for C</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">比较C语言的3种代码分析框架</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/no-pain-no-gain-comparing-3-program-analysis-frameworks-for-c-b1ef8bdd6219?source=collection_archive---------18-----------------------#2022-03-07">https://betterprogramming.pub/no-pain-no-gain-comparing-3-program-analysis-frameworks-for-c-b1ef8bdd6219?source=collection_archive---------18-----------------------#2022-03-07</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="968c" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">没有痛苦就没有收获。</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/2ecec53aaebfe76a19ae092fa3a633df.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*EK3QMGjNcuo0GvArZ_fJgw.jpeg"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">吉恩·杰特在<a class="ae kv" href="https://unsplash.com/@genejeter?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的照片</p></figure><p id="0518" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">程序分析方法通常用图来表示程序。这些图表应该从源代码中自动生成。已经实现了许多工具来实现这一点，但是它们的设置通常很痛苦。在这篇文章中，我将比较我用来生成C程序的图形表示的3个程序分析框架。</p><p id="4c10" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><strong class="ky ir">TL；DR: </strong>更强大的框架更难建立，因为它们需要编译器信息或者公开复杂的API。</p><ul class=""><li id="e825" class="ls lt iq ky b kz la lc ld lf lu lj lv ln lw lr lx ly lz ma bi translated">如果您需要的只是AST，并且不需要100%的精度，那么SrcML非常好。</li><li id="be68" class="ls lt iq ky b kz mb lc mc lf md lj me ln mf lr lx ly lz ma bi translated">如果你需要CFG或PDG来运行一大堆程序，Joern是很棒的，并且可以处理一些潜在的解析错误。</li><li id="0010" class="ls lt iq ky b kz mb lc mc lf md lj me ln mf lr lx ly lz ma bi translated">如果您想要进行坚如磐石的分析，并且想要利用Clang编译器中使用的复杂程序分析过程，LLVM是很好的选择，并且您可以提供编译器信息。</li></ul><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi mg"><img src="../Images/38588fa26101d99e9e351e98f4e0f895.png" data-original-src="https://miro.medium.com/v2/resize:fit:1024/format:webp/1*XBdohYJSgvvMsfiBh2Q7YQ.jpeg"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">不劳无获。更多的痛苦更多的收获？？？(来源:<a class="ae kv" href="https://www.dreamstime.com/stock-illustration-gradual-development-muscle-building-weakling-to-steep-pitching-funny-cartoon-character-vector-illustration-isolated-image48375937" rel="noopener ugc nofollow" target="_blank"> kharlamova </a>)</p></figure><h1 id="daad" class="mh mi iq bd mj mk ml mm mn mo mp mq mr jw ms jx mt jz mu ka mv kc mw kd mx my bi translated">控制流程什么-现在？</h1><p id="04db" class="pw-post-body-paragraph kw kx iq ky b kz mz jr lb lc na ju le lf nb lh li lj nc ll lm ln nd lp lq lr ij bi translated">不同类型的图表用于不同的分析，这取决于需要什么信息[0]:</p><ul class=""><li id="e244" class="ls lt iq ky b kz la lc ld lf lu lj lv ln lw lr lx ly lz ma bi translated">抽象语法树(AST):程序中标记的树型表示，它抽象出诸如括号、空格和分隔符等细节。</li><li id="288d" class="ls lt iq ky b kz mb lc mc lf md lj me ln mf lr lx ly lz ma bi translated">控制流图(CFG):一种图形表示，其中每个节点是一个语句，每个边是控制流中的一个转换。</li><li id="4a35" class="ls lt iq ky b kz mb lc mc lf md lj me ln mf lr lx ly lz ma bi translated">程序依赖图(PDG):一种图形表示，其中每个节点是一个语句，每个边是一个控制或数据依赖。如果语句影响变量的值，则变量依赖于该语句。</li></ul><p id="b98a" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我选择研究我在自己的研究中使用的3种流行的程序分析框架的相对优势:</p><p id="872f" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我根据我们对任何程序分析任务都关心的3个标准来评估框架。</p><ul class=""><li id="0f79" class="ls lt iq ky b kz la lc ld lf lu lj lv ln lw lr lx ly lz ma bi translated">速度:框架有多快？</li><li id="41c9" class="ls lt iq ky b kz mb lc mc lf md lj me ln mf lr lx ly lz ma bi translated">精度:得到的CFG有多精确？</li><li id="21d0" class="ls lt iq ky b kz mb lc mc lf md lj me ln mf lr lx ly lz ma bi translated">易用性:使用框架需要多少努力，特别是。在一大套程序上？</li></ul><p id="2e6c" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">所有这些图形表示都可以从C源代码中自动生成，尽管这项任务有时很有挑战性。</p><h1 id="a539" class="mh mi iq bd mj mk ml mm mn mo mp mq mr jw ms jx mt jz mu ka mv kc mw kd mx my bi translated">解析C代码的挑战</h1><p id="1a74" class="pw-post-body-paragraph kw kx iq ky b kz mz jr lb lc na ju le lf nb lh li lj nc ll lm ln nd lp lq lr ij bi translated">c程序很难解析，因为预处理程序允许任意的文本替换[1]。如果没有定义预处理器宏，解析器可能会误解某段代码的上下文，并完全错误地解析它。在我对3个框架的评估中，我称之为<em class="ne">不精确</em>。</p><p id="fa29" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">c程序还需要编译器信息，比如头文件中定义的类型和函数，以便正确解析[2]。这些头文件可以分散在整个机器上，标准库头文件位于不同操作系统或发行版的不同位置。编译器信息通常通过编译器标志(如<code class="fe nf ng nh ni b">-I</code>或<code class="fe nf ng nh ni b">-D</code>)传递给解析器。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi mg"><img src="../Images/6e072aa65d6dec0ba646653fe85fd8a2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1024/format:webp/1*cB8esPRAR5yx3yCxgDZl-Q.png"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">SrcML、Joern和LLVM的相对优势。(来源:<a class="ae kv" href="https://benjijang.com/" rel="noopener ugc nofollow" target="_blank">本杰明·斯廷霍克</a>)</p></figure><h1 id="2a73" class="mh mi iq bd mj mk ml mm mn mo mp mq mr jw ms jx mt jz mu ka mv kc mw kd mx my bi translated">SrcML</h1><p id="9464" class="pw-post-body-paragraph kw kx iq ky b kz mz jr lb lc na ju le lf nb lh li lj nc ll lm ln nd lp lq lr ij bi translated">SrcML 是源代码的XML格式。它以独立于语言的格式提供AST。它还保留所有字符，包括空格、注释和预处理程序宏。</p><p id="4ae4" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">SrcML可以解析缺少包含和库的代码，这使得它非常适合大规模程序分析(大约几百万个程序)。然而，这也意味着AST有时可能不正确。如果有预处理宏，这个问题会变得更加严重。SrcML解析器使用一组试探法来处理这些挑战，但是它有时会导致不正确的AST。</p><p id="948f" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">SrcML作者声称它比编译器更快(超过25k loc/秒)[3]。我观察到它确实运行得非常快，而且由于它将XML输出为文本，所以可以在内存中完成所有处理。</p><p id="1f88" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">SrcML提供AST，但不提供CFG或PDG。为了获得CFG，我们必须实现一个算法来基于AST生成CFG。一些项目已经将此作为其实现的一部分(特别是<a class="ae kv" href="https://github.com/srcML/srcSlice" rel="noopener ugc nofollow" target="_blank"> srcSlice </a>和<a class="ae kv" href="https://github.com/srcML/srcPtr" rel="noopener ugc nofollow" target="_blank"> srcPtr </a>)，但是我发现很难将这些实现用于其他用途。</p><p id="c823" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">SrcML格式是独立于语言的，所以从理论上讲，您可以编写基于XML格式的分析，并将其应用于所有支持的语言(目前是C、C++、C#和Java)。</p><p id="9969" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">有趣的是，SrcML是<em class="ne">可逆的</em>，这意味着用户可以将代码解析为XML，编辑XML，然后将XML解解析回代码，同时保留编辑内容。这允许一些很酷的编辑功能，我发现在某些情况下这比编辑原始源代码更容易，因为我可以通过遍历XML树来定位我想要编辑的符号。</p><p id="0687" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">SrcML团队对我关于他们的框架的询问反应非常积极。</p><h1 id="1890" class="mh mi iq bd mj mk ml mm mn mo mp mq mr jw ms jx mt jz mu ka mv kc mw kd mx my bi translated">约恩</h1><p id="8eae" class="pw-post-body-paragraph kw kx iq ky b kz mz jr lb lc na ju le lf nb lh li lj nc ll lm ln nd lp lq lr ij bi translated"><a class="ae kv" href="https://joern.io/" rel="noopener ugc nofollow" target="_blank"> Joern </a>是一个解析C/C++代码并生成代码属性图(CPG)的工作台。CPG是AST、CFG和PDG在一个大图中的组合，它公开了足以进行广泛分析的信息。该工具的主界面是一个命令行解释器，允许用户在基于Scala的DSL中编写自定义查询。</p><p id="8efe" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">Joern不需要编译器信息，而是使用一种被称为<em class="ne">岛语法</em>的模糊解析方法来尽可能好地解析代码。</p><p id="2908" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我发现Joern实现运行起来比SrcML和LLVM都慢。这可能是因为运行时平台的选择:SrcML和LLVM是用C++构建的，功能比较窄，而Joern是用Scala构建的，具有很强的可定制性/可脚本化。</p><p id="33e8" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">支持多种语言:C/C++、x86/64汇编、JVM、LLVM位代码和Javascript。我只尝试过C/C++，这是唯一在他们的<a class="ae kv" href="https://docs.joern.io/home#supported-languages" rel="noopener ugc nofollow" target="_blank">文档页面</a>上标记为<em class="ne">高</em>成熟度的语言。</p><p id="347b" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">Joern包含了很棒的分析工具，但是对代码的任何修改都必须手工粘贴在一起。不支持重写或转换。</p><p id="1d28" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">ShiftLeft团队在开发Joern方面非常活跃，他们对他们框架的用户很有帮助。</p><h1 id="999d" class="mh mi iq bd mj mk ml mm mn mo mp mq mr jw ms jx mt jz mu ka mv kc mw kd mx my bi translated">LLVM</h1><p id="f3f1" class="pw-post-body-paragraph kw kx iq ky b kz mz jr lb lc na ju le lf nb lh li lj nc ll lm ln nd lp lq lr ij bi translated">LLVM是所有程序分析框架的鼻祖。它是一个为编译器开发设计的成熟工具集。</p><p id="4380" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">LLVM是Clang编译器、Clang静态分析器(CSA)、klee和许多其他知名工具的基础。因为它在如此多的流行工具中被使用，所以它被优化得非常快。LLVM公开了用于AST、CFG和PDG信息的API，以及一大堆其他分析。基本上，任何对编译器可用的信息对LLVM工具的开发者都是可用的。同样，信息是100%精确的，因为编译器不能容忍不正确的信息。</p><p id="6877" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这种能力是有代价的——LLVM要求定义所有类型，以便正确解析代码。由于C的模糊语法，如果没有定义类型，那么编译器就无法区分函数定义和变量定义，从而导致解析错误(cite)。如果缺少一些定义，LLVM可能会产生一个缺失了大部分的不完整AST。</p><p id="9110" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">通常，这些信息是通过给LLVM一组用于编译程序的编译器标志来提供的。如果您想要分析大量的程序，可能很难获得这些标志，因为这些标志依赖于平台和配置。这可能会引入大量的手动工作来获取这些标志，从而使LLVM不适合分析大规模的程序数据集。</p><p id="4ed3" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">LLVM的分析功能只在源代码级别处理C/C++。LLVM IR提供了额外的实用程序，这是一种低级SSA汇编语言，许多其他语言都以它为目标。</p><p id="d52f" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">LLVM提供了用于重写源代码的<a class="ae kv" href="https://clang.llvm.org/doxygen/classclang_1_1Rewriter.html" rel="noopener ugc nofollow" target="_blank">重写器API </a>。我发现这些实用程序在大多数情况下非常方便，尽管在某些情况下，当我想要重写的位置没有被AST暴露时，很难绕过rewriter API。</p><p id="376b" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">最后，我发现LLVM C++ API <a class="ae kv" href="https://clang.llvm.org/docs/LibTooling.html" rel="noopener ugc nofollow" target="_blank"> LibTooling </a>有时候可以很直观很舒服，但是往往细节非常复杂，有很多footguns。根据经验，我越来越擅长使用它，但我仍然需要一段时间来弄清楚我应该使用哪个ASTMatcher。</p><h1 id="464d" class="mh mi iq bd mj mk ml mm mn mo mp mq mr jw ms jx mt jz mu ka mv kc mw kd mx my bi translated">基准分析</h1><p id="519b" class="pw-post-body-paragraph kw kx iq ky b kz mz jr lb lc na ju le lf nb lh li lj nc ll lm ln nd lp lq lr ij bi translated">为了评估每个工具的速度，我为每个框架实现了一个简单的重构工具。重构工具用一个<code class="fe nf ng nh ni b">while</code>语句交换一个<code class="fe nf ng nh ni b">for</code>语句。虽然控制流信息对于早期处理<code class="fe nf ng nh ni b">break</code>、<code class="fe nf ng nh ni b">cont inue</code>或<code class="fe nf ng nh ni b">return</code>是必要的，但是这只能用AST来完成。你可以在这里获得原型的源代码:<a class="ae kv" href="https://github.com/bstee615/pa_framework_examples" rel="noopener ugc nofollow" target="_blank">https://github.com/bstee615/pa_framework_examples</a>。</p><p id="a2e3" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这是一个工具工作的例子。当输入该程序时:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nj nk l"/></div></figure><p id="4169" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">那么这个程序应该是输出。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nj nk l"/></div></figure><p id="0130" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我在示例程序上以秒为单位测量了原型工具的运行时间，平均运行了5次。结果如下所示。格式:平均标准。偏差。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nj nk l"/></div></figure><p id="9d13" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">该评估显示了两种框架之间启动时间的差异。在我的研究中，我发现启动时间是一个相当大的考虑因素，而程序的大小对框架性能的影响相对较小。</p><p id="b93f" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">对于所有实际问题，LLVM和SrcML的性能非常相似。值得注意的是，我使用Python调用SrcML并解析输出XML。如果我用C++写，用SrcML库链接，可能会稍微快一点。</p><p id="93ec" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">乔恩是迄今为止最慢的。这可能是由于启动Scala VM和Joern的解释器的开销。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nl"><img src="../Images/a0e78b28f0b01c6912b515de01f7b292.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*R7do8Cp36iXuKVuQmfdj3Q.jpeg"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">框架是多维的，不仅仅是轻量级/重量级的。(来源:<a class="ae kv" href="https://www.self.com/story/guide-to-navigating-free-weights-at-the-gym" rel="noopener ugc nofollow" target="_blank">摩根·约翰逊</a>)</p></figure><p id="2ec6" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这些框架中的每一个在程序分析中都有其最佳点。在现实中，分析真实世界的程序是困难的。有很多痛苦/快乐不同维度的选择。我在一个小例子中比较了速度，以突出框架之间的差异。我建议您对这3个框架进行自己的研究，找出哪一个最适合您的应用程序。最重要的是，不要武断地使用一种方法而不使用另一种方法——例如，假设您习惯于LLVM在分析中为您提供编译器级别的精度，那么您可能会从切换到Joern中受益，以便加快您的开发周期。</p><h1 id="b57f" class="mh mi iq bd mj mk ml mm mn mo mp mq mr jw ms jx mt jz mu ka mv kc mw kd mx my bi translated">资源</h1><p id="3f4b" class="pw-post-body-paragraph kw kx iq ky b kz mz jr lb lc na ju le lf nb lh li lj nc ll lm ln nd lp lq lr ij bi translated">[0] F. Yamaguchi，N. Golde，D. Arp和K. Rieck，“用代码属性图建模和发现漏洞”，2014年IEEE安全和隐私研讨会，2014年，第590-604页，DOI:【https://doi.org/10.1109/SP.2014.44.】T2</p><p id="e9fb" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">[1]阿莱杭德娜·加里多和拉尔夫·约翰逊。2002.重构C程序的挑战。《软件进化原理国际研讨会论文集》(IWPSE '02)。计算机械协会，纽约，纽约州，美国，6-14。DOI:https://DOI . org/10.1145/512035.512039</p><p id="9ac2" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">[2]e . bender sky(2007年11月)。C语言语法的上下文敏感性。伊莱本德斯基的网站原子。2022年3月3日检索，来自<a class="ae kv" href="https://web.archive.org/web/20210713114717/https://eli.thegreenplace.net/2007/11/24/the-context-sensitivity-of-cs-grammar" rel="noopener ugc nofollow" target="_blank">https://web . archive . org/web/20210713114717/https://Eli . the green place . net/2007/11/24/the-context-sensitivity-of-cs-grammar</a></p><p id="2567" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">[3] M. L. Collard、M. J. Decker和J. I. Maletic，“srcML:探索、分析和操作源代码的基础设施:工具演示”，2013年IEEE软件维护国际会议，2013年，第516–519页，DOI:<a class="ae kv" href="https://doi.org/10.1109/ICSM.2013.85" rel="noopener ugc nofollow" target="_blank">https://doi.org/10.1109/ICSM.2013.85</a></p></div><div class="ab cl nm nn hu no" role="separator"><span class="np bw bk nq nr ns"/><span class="np bw bk nq nr ns"/><span class="np bw bk nq nr"/></div><div class="ij ik il im in"><p id="ce24" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><em class="ne">最初发表于</em><a class="ae kv" href="https://benjijang.com/posts/2022/03/no-pain-no-gain/" rel="noopener ugc nofollow" target="_blank"><em class="ne">https://benjijang.com</em></a></p></div></div>    
</body>
</html>