<html>
<head>
<title>Lazy-Loading React Components</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">延迟加载React组件</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/lazy-loading-react-components-8ac7dbd4a854?source=collection_archive---------9-----------------------#2020-11-05">https://betterprogramming.pub/lazy-loading-react-components-8ac7dbd4a854?source=collection_archive---------9-----------------------#2020-11-05</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="81f8" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">通过代码拆分优化生产版本</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/ee618f599e53f591f27ce6b9bd6e5dbe.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*5JcqtcEllJ8YHG8K"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">照片由<a class="ae ky" href="https://unsplash.com/@drew_beamer?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">在<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上绘制的光束器</a></p></figure><p id="5a71" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">当涉及到减少构建规模时，代码分割是一个非常有用的工具。它允许您将代码解析(或拆分)成不同的包，这些包可以根据当前的需要有条件地加载。</p><p id="ab65" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">假设您有一套适用于不同班级和不同教育水平的电子学习应用程序。您可以将每个应用程序的所有代码编译成一个构建文件，当您点击登录页面(包含所有应用程序的链接)时，该文件将提供给浏览器。</p><p id="9c16" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">只要您的构建文件不太大，这种编译方法并不是一个坏主意。但是，如果您向项目中添加新的特性、应用程序或包，那么这个包文件可能会变得非常大。</p><p id="5c86" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果您的构建文件太大，它会降低React应用程序的加载时间。这可能会对用户体验产生负面影响。你不讨厌缓慢的加载时间吗？</p><p id="fb3c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">想象一下:你有一个非常小的用于登陆页面的捆绑包文件(它只需要呈现无数电子学习应用的链接),然后是每个应用的其他小捆绑包，如果你进入一个特定的应用，它们只需要<em class="lv">加载</em>。</p><p id="8776" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">当你只想使用英语I时，为什么需要英语II(或套件中的其他应用程序)的包文件？代码分割可以通过根据您的入口点分离出相关的代码来补救这种情况，从而从主包中取出代码并减小其大小。</p><p id="ba44" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在本文中，我将介绍如何使用内置的React函数和组件实现代码拆分，而不需要库或额外的配置。</p><p id="60a9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">首先，这里是我们应用程序的所有路线:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="lw lx l"/></div></figure><p id="4f1e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">通过添加一个内置的React函数和组件，我们只需两步就可以将上面代码的捆绑包拆分成单独的捆绑包。下面是我们将要使用的函数，名为<code class="fe ly lz ma mb b">React.lazy</code>。</p></div><div class="ab cl mc md hx me" role="separator"><span class="mf bw bk mg mh mi"/><span class="mf bw bk mg mh mi"/><span class="mf bw bk mg mh"/></div><div class="im in io ip iq"><h1 id="41ca" class="mj mk it bd ml mm mn mo mp mq mr ms mt jz mu ka mv kc mw kd mx kf my kg mz na bi translated">懒惰的</h1><p id="a7a1" class="pw-post-body-paragraph kz la it lb b lc nb ju le lf nc jx lh li nd lk ll lm ne lo lp lq nf ls lt lu im bi translated"><code class="fe ly lz ma mb b">React.lazy</code>函数允许您将动态导入作为常规组件呈现。典型的导入可能如下所示:</p><pre class="kj kk kl km gt ng mb nh ni aw nj bi"><span id="bded" class="nk mk it mb b gy nl nm l nn no">import <!-- -->Home <!-- -->from './<!-- -->Home<!-- -->';</span></pre><p id="be44" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果使用<code class="fe ly lz ma mb b">React.lazy</code>，您的导入看起来会是这样:</p><pre class="kj kk kl km gt ng mb nh ni aw nj bi"><span id="1273" class="nk mk it mb b gy nl nm l nn no">const <!-- -->Home <!-- -->= React.lazy(() =&gt; import('./<!-- -->Home<!-- -->'));</span></pre><p id="b502" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们的第二步涉及到<code class="fe ly lz ma mb b">Suspense</code>组件。</p></div><div class="ab cl mc md hx me" role="separator"><span class="mf bw bk mg mh mi"/><span class="mf bw bk mg mh mi"/><span class="mf bw bk mg mh"/></div><div class="im in io ip iq"><h1 id="0f3f" class="mj mk it bd ml mm mn mo mp mq mr ms mt jz mu ka mv kc mw kd mx kf my kg mz na bi translated">焦虑</h1><p id="4fec" class="pw-post-body-paragraph kz la it lb b lc nb ju le lf nc jx lh li nd lk ll lm ne lo lp lq nf ls lt lu im bi translated">通过在<code class="fe ly lz ma mb b">Suspense</code>中包装惰性加载的组件，我们可以在等待惰性组件加载时显示一些后备内容(比如加载指示器)。见下文:</p><pre class="kj kk kl km gt ng mb nh ni aw nj bi"><span id="cfb0" class="nk mk it mb b gy nl nm l nn no">&lt;Suspense fallback={&lt;div&gt;LOADING&lt;/div&gt;}&gt;<br/>  {ROUTES}<br/>&lt;/Suspense&gt;</span></pre><p id="7224" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们看看更新后的<code class="fe ly lz ma mb b">App.js</code>组件，包括我们对<code class="fe ly lz ma mb b">lazy</code>和<code class="fe ly lz ma mb b">Suspense</code>的使用:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="lw lx l"/></div></figure><p id="076c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">就是这样！现在，您已经将主包分成了多个更小的包，只有当路由与延迟加载组件的路由相匹配时，这些包才会被加载。当单独的包被提供给浏览器时，<code class="fe ly lz ma mb b">Suspense</code>组件充当占位符，向用户保证应用程序将随时可用。</p><p id="9fda" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">您的新构建文件可能类似于<code class="fe ly lz ma mb b">1.js</code>、<code class="fe ly lz ma mb b">2.js</code>、<code class="fe ly lz ma mb b">3.js</code>等。除了原始/主构建文件之外。</p><p id="7dff" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">用<code class="fe ly lz ma mb b">lazy</code>和<code class="fe ly lz ma mb b">Suspense</code>进行代码分割可能是在不重新配置的情况下减少包大小的最简单的方法。不过，我建议你也重新配置你的捆扎机，以减少更多的建设规模。但是还有其他方法可以减少构建规模，包括更多的重新配置。</p><p id="5f5b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">阅读<a class="ae ky" href="https://medium.com/@rajaraodv/two-quick-ways-to-reduce-react-apps-size-in-production-82226605771a#:~:text=js%20(the%20dev%20version)%20for,is%20just%20libraries%20in%20node_modules!" rel="noopener">这篇文章</a>了解更多关于如何使用webpack和gzip减小包大小的信息。</p><p id="b415" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">本文的源代码可以在<a class="ae ky" href="https://github.com/macro6461/medium-react-lazy-load" rel="noopener ugc nofollow" target="_blank"> GitHub </a>上找到。</p></div><div class="ab cl mc md hx me" role="separator"><span class="mf bw bk mg mh mi"/><span class="mf bw bk mg mh mi"/><span class="mf bw bk mg mh"/></div><div class="im in io ip iq"><p id="1852" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><a class="ae ky" href="https://matt-croak.medium.com/membership" rel="noopener"> <em class="lv">点击此处，将您的免费媒体会员升级为付费会员</em> </a> <em class="lv">，每月只需5美元，您就可以获得数千名作家的无限量无广告故事。这是一个附属链接，你的会员资格的一部分帮助我为我创造的内容获得奖励。谢谢大家！</em></p><h1 id="60a6" class="mj mk it bd ml mm np mo mp mq nq ms mt jz nr ka mv kc ns kd mx kf nt kg mz na bi translated">参考</h1><div class="nu nv gp gr nw nx"><a href="https://reactjs.org/docs/code-splitting.html" rel="noopener  ugc nofollow" target="_blank"><div class="ny ab fo"><div class="nz ab oa cl cj ob"><h2 class="bd iu gy z fp oc fr fs od fu fw is bi translated">代码分解-反应</h2><div class="oe l"><h3 class="bd b gy z fp oc fr fs od fu fw dk translated">大多数React应用程序会使用Webpack、Rollup或Browserify等工具“捆绑”文件。捆绑是一个过程…</h3></div><div class="of l"><p class="bd b dl z fp oc fr fs od fu fw dk translated">reactjs.org</p></div></div><div class="og l"><div class="oh l oi oj ok og ol ks nx"/></div></div></a></div><div class="nu nv gp gr nw nx"><a href="https://medium.com/@rajaraodv/two-quick-ways-to-reduce-react-apps-size-in-production-82226605771a" rel="noopener follow" target="_blank"><div class="ny ab fo"><div class="nz ab oa cl cj ob"><h2 class="bd iu gy z fp oc fr fs od fu fw is bi translated">减少React应用程序生产规模的两种快速方法</h2><div class="oe l"><h3 class="bd b gy z fp oc fr fs od fu fw dk translated">如果您正在构建一个包含Webpack的React + Redux应用程序，那么您可能已经注意到final的大小…</h3></div><div class="of l"><p class="bd b dl z fp oc fr fs od fu fw dk translated">medium.com</p></div></div><div class="og l"><div class="om l oi oj ok og ol ks nx"/></div></div></a></div><div class="nu nv gp gr nw nx"><a href="https://github.com/macro6461/medium-react-lazy-load" rel="noopener  ugc nofollow" target="_blank"><div class="ny ab fo"><div class="nz ab oa cl cj ob"><h2 class="bd iu gy z fp oc fr fs od fu fw is bi translated">macro 6461/中等反应惰性负载</h2><div class="oe l"><h3 class="bd b gy z fp oc fr fs od fu fw dk translated">这是我的帖子“Lazy AF(Lazy Loading React Components)”的源代码，GitHub拥有超过5000万个</h3></div><div class="of l"><p class="bd b dl z fp oc fr fs od fu fw dk translated">github.com</p></div></div><div class="og l"><div class="on l oi oj ok og ol ks nx"/></div></div></a></div></div></div>    
</body>
</html>