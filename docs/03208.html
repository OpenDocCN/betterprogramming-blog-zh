<html>
<head>
<title>An Introduction to TypeScript Interfaces</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">类型脚本接口介绍</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/introduction-to-typescript-interfaces-extending-interfaces-and-classes-af10fcfc1238?source=collection_archive---------9-----------------------#2020-01-28">https://betterprogramming.pub/introduction-to-typescript-interfaces-extending-interfaces-and-classes-af10fcfc1238?source=collection_archive---------9-----------------------#2020-01-28</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="e59c" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">如何扩展接口和编写扩展类的接口</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/cff9cd78a4fabc4c6f94d0903190040b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*fyn0dM6K2Oq9BUEDVfJ3Yw.jpeg"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">照片由<a class="ae ky" href="https://unsplash.com/@foxfox?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Natalia Y </a>在<a class="ae ky" href="https://unsplash.com/s/photos/letters?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</p></figure><p id="aa63" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">与普通JavaScript相比，TypeScript的最大优势在于，它通过添加确保程序对象类型安全的特性来扩展JavaScript的特性。</p><p id="08f0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">它通过检查对象所呈现的值的形状来做到这一点。检查形状称为<em class="lv">鸭式分型</em>或<em class="lv">结构分型</em>。接口是在TypeScript中扮演命名数据类型角色的一种方式。</p><p id="f62b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">它们对于在TypeScript程序的代码中定义契约非常有用。</p><p id="8b08" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在最后一部分，我们将看看如何定义一个TypeScript接口，以及如何向它添加属性。我们还研究了对象文字的额外属性检查和接口的定义类型。</p><p id="053f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在本文中，我们将研究如何扩展接口和编写扩展类的接口。</p></div><div class="ab cl lw lx hx ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="im in io ip iq"><h1 id="b111" class="md me it bd mf mg mh mi mj mk ml mm mn jz mo ka mp kc mq kd mr kf ms kg mt mu bi translated">扩展接口</h1><p id="7b4f" class="pw-post-body-paragraph kz la it lb b lc mv ju le lf mw jx lh li mx lk ll lm my lo lp lq mz ls lt lu im bi translated">在TypeScript中，接口可以像类一样相互扩展。这让我们可以将一个接口的成员复制到另一个接口，并在如何使用接口方面给予我们更多的灵活性。</p><p id="567e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们可以在不同的地方重用常见的实现，我们可以以不同的方式扩展它们，而无需为接口重复代码。</p><p id="8191" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们可以用关键字<code class="fe na nb nc nd b">extends</code>扩展接口。我们可以使用关键字来扩展一个或多个用逗号分隔的接口。例如，我们可以在下面的代码中使用<code class="fe na nb nc nd b">extends</code>关键字:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ne nf l"/></div></figure><p id="a9be" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">然后，为了实现<code class="fe na nb nc nd b">Dog</code>和<code class="fe na nb nc nd b">Cat</code>接口，我们还必须实现在<code class="fe na nb nc nd b">Animal</code>接口中列出的成员。例如，我们将在下面的代码中实现它们:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ne nf l"/></div></figure><p id="4bcb" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">正如我们所看到的，我们已经在类实现中添加了父接口和子接口的所有内容。我们还可以扩展多个接口，如下面的代码所示:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ne nf l"/></div></figure><p id="a51f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">从上面的代码中我们可以看到，如果我们像对待<code class="fe na nb nc nd b">Clock</code>类一样实现<code class="fe na nb nc nd b">ClockInterface</code>，我们就拥有了<code class="fe na nb nc nd b">Machineinterface</code>、<code class="fe na nb nc nd b">ProductInterface</code>和<code class="fe na nb nc nd b">ClockInterface</code>的所有成员。</p><p id="2d65" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">注意，如果我们在多个接口中有相同的成员名，那么它们也必须有相同的数据类型。例如，如果我们有以下代码:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ne nf l"/></div></figure><p id="2881" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">Typescript编译器会拒绝它，因为我们在<code class="fe na nb nc nd b">MachineInterface</code>中有一个字符串<code class="fe na nb nc nd b">name</code>，在<code class="fe na nb nc nd b">ProductInterface</code>中有一个数字<code class="fe na nb nc nd b">name</code>。</p><p id="6e36" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果我们尝试用TypeScript编译器编译上面的代码，我们会得到错误:</p><pre class="kj kk kl km gt ng nd nh ni aw nj bi"><span id="6c99" class="nk me it nd b gy nl nm l nn no">Interface ‘ClockInterface’ cannot simultaneously extend types ‘MachineInterface’ and ‘ProductInterface’. Named property ‘name’ of types ‘MachineInterface’ and ‘ProductInterface’ are not identical.(2320)</span></pre></div><div class="ab cl lw lx hx ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="im in io ip iq"><h1 id="60a9" class="md me it bd mf mg mh mi mj mk ml mm mn jz mo ka mp kc mq kd mr kf ms kg mt mu bi translated">混合类型</h1><p id="9513" class="pw-post-body-paragraph kz la it lb b lc mv ju le lf mw jx lh li mx lk ll lm my lo lp lq mz ls lt lu im bi translated">我们可以用类型断言操作符重写由对象推断的类型，这在TypeScript中用<code class="fe na nb nc nd b">as</code>关键字表示。</p><p id="3a24" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这样，我们可以在继续使用接口的同时使用具有动态类型的代码。例如，我们可以编写以下代码:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ne nf l"/></div></figure><p id="b80a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在上面的代码中，我们在<code class="fe na nb nc nd b">getPerson</code>函数中有<code class="fe na nb nc nd b">person</code>变量，我们用<code class="fe na nb nc nd b">Person</code>类型显式设置它，这样我们就可以将<code class="fe na nb nc nd b">Person</code>接口中列出的属性分配给<code class="fe na nb nc nd b">person</code>变量。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi np"><img src="../Images/e6132d1f77174683fe3e2deeaedadc51.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*MXpwQV9HfTYnddsG"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">照片由<a class="ae ky" href="https://unsplash.com/@neonbrand?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> NeONBRAND </a>在<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</p></figure></div><div class="ab cl lw lx hx ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="im in io ip iq"><h1 id="19e9" class="md me it bd mf mg mh mi mj mk ml mm mn jz mo ka mp kc mq kd mr kf ms kg mt mu bi translated">接口扩展类</h1><p id="52c5" class="pw-post-body-paragraph kz la it lb b lc mv ju le lf mw jx lh li mx lk ll lm my lo lp lq mz ls lt lu im bi translated">TypeScript接口可以扩展类。这意味着接口可以继承类的成员，但不能继承它们的实现。在这种情况下，类充当所有声明的成员的接口，而不提供实现。</p><p id="1413" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这意味着当我们用私有或受保护的成员扩展一个类时，接口只能由那个类或它的子类实现。例如，我们可以编写一个扩展类的接口，如下面的代码所示:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ne nf l"/></div></figure><p id="bfbf" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在上面的代码中，我们首先创建了类<code class="fe na nb nc nd b">Animal</code>，它有一个公共成员<code class="fe na nb nc nd b">name</code>和一个私有成员<code class="fe na nb nc nd b">age</code>。然后，我们添加了一个<code class="fe na nb nc nd b">BirdInterface</code>，它通过添加公共成员<code class="fe na nb nc nd b">breed</code>和<code class="fe na nb nc nd b">color</code>来扩展<code class="fe na nb nc nd b">Animal</code>类。</p><p id="7fc1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">然后，在扩展了<code class="fe na nb nc nd b">Animal</code>类并实现了<code class="fe na nb nc nd b">BirdInterface</code>的<code class="fe na nb nc nd b">Bird</code>类中，我们拥有了<code class="fe na nb nc nd b">BirdInterface</code>的所有成员以及<code class="fe na nb nc nd b">Animal</code>类的公共成员。</p><p id="63f6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">因为私有成员不能在类外访问，所以我们不能访问<code class="fe na nb nc nd b">Bird</code>类中的成员<code class="fe na nb nc nd b">age</code>。我们也不能在<code class="fe na nb nc nd b">Bird</code>班再增加一个<code class="fe na nb nc nd b">age</code>成员。</p><p id="57f0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">否则，我们会得到错误:</p><pre class="kj kk kl km gt ng nd nh ni aw nj bi"><span id="10d3" class="nk me it nd b gy nl nm l nn no">Class ‘Bird’ incorrectly extends base class ‘Animal’. Property ‘age’ is private in type ‘Animal’ but not in type ‘Bird’.(2415)” and “Class ‘Bird’ incorrectly implements interface ‘BirdInterface’. Property ‘age’ is private in type ‘BirdInterface’ but not in type ‘Bird’.(2420)</span></pre><p id="55ae" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">然而，如果我们将<code class="fe na nb nc nd b">Animal</code>类中的<code class="fe na nb nc nd b">age</code>成员更改为受保护成员，它可以被扩展<code class="fe na nb nc nd b">Animal</code>的所有子类访问，那么我们可以在<code class="fe na nb nc nd b">Bird</code>类中引用它，如下面的代码所示:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ne nf l"/></div></figure><p id="5c2b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">方法也是如此。私有方法不能被定义它的类之外的任何东西访问，也不能被任何子类或接口覆盖。例如，如果我们有以下代码:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ne nf l"/></div></figure><p id="b0a9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">然后我们会得到错误:</p><pre class="kj kk kl km gt ng nd nh ni aw nj bi"><span id="87a0" class="nk me it nd b gy nl nm l nn no">Class ‘Bird’ incorrectly extends base class ‘Animal’. Property ‘age’ is private in type ‘Animal’ but not in type ‘Bird’.(2415)” and “Class ‘Bird’ incorrectly implements interface ‘BirdInterface’. Property ‘age’ is private in type ‘BirdInterface’ but not in type ‘Bird’.(2420)</span></pre><p id="a981" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">但是，我们可以在子类中重写受保护的方法，如下面的代码所示:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ne nf l"/></div></figure><p id="25d7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在TypeScript中，接口可以像类一样相互扩展。这让我们可以将一个接口的成员复制到另一个接口，并在如何使用接口方面给予我们更多的灵活性。</p><p id="fee3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们可以在不同的地方重用常见的实现，我们可以以不同的方式扩展它们，而无需为接口重复代码。</p><p id="fc4f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">此外，TypeScript接口可以扩展类。这意味着接口可以继承类的成员，但不能继承它们的实现。在这种情况下，类充当所有声明的成员的接口，而不提供实现。</p><p id="92c3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这意味着当我们用私有或受保护的成员扩展一个类时，接口只能由那个类或它的子类实现。</p></div></div>    
</body>
</html>