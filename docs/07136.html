<html>
<head>
<title>iOS 14 and Big Sur Navigation</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">iOS 14和大苏尔导航</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/ios-14-and-big-sur-navigation-ae11a7efdf29?source=collection_archive---------16-----------------------#2020-12-09">https://betterprogramming.pub/ios-14-and-big-sur-navigation-ae11a7efdf29?source=collection_archive---------16-----------------------#2020-12-09</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="7991" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">在现代苹果生态系统中使用侧边栏和标签栏进行主导航</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/bb3f9d55860b3204a25c17c486ec7b02.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*pPqtznA6nzzi8xh3zU4ZDg.jpeg"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">奥利尔在<a class="ae ky" href="https://unsplash.com/s/photos/iphone-and-ipad?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</p></figure><p id="48c1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">WWDC20的突出趋势之一是在iPad OS中添加了侧边栏，这让人想起了Mac上的侧边栏。这些提供了一种更好的使用iPad空间的方式，感觉比标签栏好得多。凭借根据上下文显示和隐藏侧边栏的能力，您可以创建出色的导航并最大限度地利用屏幕空间，而不会失去iPhone的任何便利性。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="be06" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">最终产品</h1><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi mu"><img src="../Images/e8563adb5ef7f4eba79e4591711844c1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*6ZzuNIeNNh2nVjSHKQ8csA.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">在iPhone、iPad和Mac上运行的应用程序</p></figure><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi mv"><img src="../Images/54e551a6e898ad7d01067eb2dad3256a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*wX6LZwxnoRGWjOv1iXt8vQ.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">这款应用在紧凑的多任务处理中的外观</p></figure><p id="4d0f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在这里，我们可以看到我们要创建的实际最终产品。如果不想看文章，直接跳到最后，从GitHub抓取代码。<br/> <br/>我们在Mac和iPad上有侧边栏，在iPhone和紧凑型iPad上有标签栏多任务大小。当在侧边栏中选择一个项目时，导航会像您预期的那样工作，并且标签栏在iPhone上的行为与往常一样。当您调整应用程序大小时，它会自动重新绘制到正确的导航状态。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="d635" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">开始</h1><p id="5df8" class="pw-post-body-paragraph kz la it lb b lc mw ju le lf mx jx lh li my lk ll lm mz lo lp lq na ls lt lu im bi translated">我们不会直接跳到UI，因为首先我们需要对侧边栏建模。为此，我们需要几个对象。</p><p id="c44f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">首先，我们的标识符。这些是最简单的，只是一个枚举。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nb nc l"/></div></figure><p id="9198" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">接下来，我们需要一种区分项目类型的方法。我们将拥有标题、可扩展/可折叠标题和标准行。枚举也非常适合这种情况。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nb nc l"/></div></figure><p id="616f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">最后，我们需要实际定义一个项目的模型。这将需要与所有三种类型的项目类型兼容，这意味着它可能有也可能没有图像和项目标识符，但它将始终有一个标题。我们还将保留一个对类型的引用，以备后用。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nb nc l"/></div></figure><p id="f5e1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这允许我们使用一个section对象来建模我们的侧边栏，这可以使以后的事情更加整洁。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nb nc l"/></div></figure></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="3331" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">设置侧栏</h1><p id="dbeb" class="pw-post-body-paragraph kz la it lb b lc mw ju le lf mx jx lh li my lk ll lm mz lo lp lq na ls lt lu im bi translated">侧边栏本身非常简单，只是一个带有特殊数据源和列表布局的集合视图。这几乎是今年的所有新功能，因此我们将逐一介绍每个步骤并解释其工作原理。</p><p id="3cf5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">首先创建一个带有私有扩展的空白视图控制器，如下所示。我们将把我们所有的集合视图设置放在那个私有扩展中，这样它就不会暴露在任何其他地方。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nb nc l"/></div></figure><p id="32c8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们需要几个变量来开始我们的布局和显示项目，它们是集合视图、数据源本身和对我们的部分的引用。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nb nc l"/></div></figure><p id="b1f7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这里的部分只是我们之前的<code class="fe nd ne nf ng b">FancyListSection</code>中的静态变量，配置成看起来像Apple Music的侧边栏。现在，您可能需要更改这些内容以匹配您的应用程序。存储对这些的引用，让我们可以做一些非常简单的事情。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nb nc l"/></div></figure><p id="269a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">视图控制器的其余部分只是样板文件，但是值得一看，以显示侧栏的重要部分。不要担心实际上还不存在的功能——我们将在下一节中填充它们。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nb nc l"/></div></figure><p id="4199" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这里只需要指出两件事，其余的都是标准的:</p><ul class=""><li id="cfe0" class="nh ni it lb b lc ld lf lg li nj lm nk lq nl lu nm nn no np bi translated">在<code class="fe nd ne nf ng b">setupCollectionView</code>中，我们使用一个外观设置为<code class="fe nd ne nf ng b">sidebar</code>的<code class="fe nd ne nf ng b">UICollectionLayoutListConfiguration</code>，我们将标题模式设置为<code class="fe nd ne nf ng b">firstItemInSection</code>。这为我们处理了列表的布局，并将每一部分中的第一项视为标题——所以要小心确保每一部分都有标题，否则可能会出现一些奇怪的行为。</li><li id="a45b" class="nh ni it lb b lc nq lf nr li ns lm nt lq nu lu nm nn no np bi translated">此外，还做了一些改动，让它在Mac上看起来更自然。大多数macOS侧边栏没有导航标题，所以我们应该隐藏它们。我们还将背景颜色设置为<code class="fe nd ne nf ng b">clear</code>。这意味着我们可以在split view控制器中使用侧边栏背景样式来获得侧边栏适当的本机外观。</li></ul></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="7482" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">数据源</h1><p id="7cfb" class="pw-post-body-paragraph kz la it lb b lc mw ju le lf mx jx lh li my lk ll lm mz lo lp lq na ls lt lu im bi translated">接下来，我们将构建数据源。我们将自下而上构建它，从每种细胞类型开始，然后向上移动到更大的来源本身。</p><p id="1c39" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">选择的数据源是<code class="fe nd ne nf ng b">UICollectionViewDiffableDataSource</code>和几个<code class="fe nd ne nf ng b">UICollectionView.CellRegistration</code>，让我们从一些细胞注册开始。</p><p id="dcb4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">单元注册为我们提供了一种通过闭包配置单元的简单方法，闭包提供了条目、索引路径和单元本身。我们只是配置我们需要的。</p><p id="1416" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们将结合一个单元注册和一个<code class="fe nd ne nf ng b">UIContentConfiguration</code>以最小配置构建不同类型的单元。我们需要一个标题和行的配置，这两个都已经可用了。</p><p id="2043" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们的第一个注册是标准行。将以下功能添加到您的私人分机中。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nb nc l"/></div></figure><p id="489f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们正在返回一个<code class="fe nd ne nf ng b">UICollectionView.CellRegistration&lt;UICollectionViewListCell,FancyListITem&gt;</code>。这意味着当我们调用它时，单元注册将期待一个<code class="fe nd ne nf ng b">FancyListItem</code>，在闭包中，我们将得到它。</p><p id="f9ff" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们使用预制的<code class="fe nd ne nf ng b">UIListContentConfiguration.sidebarCell()</code>创建一个内容配置。这为侧边栏行设置了完美的一切。当我们使用这个配置的文本和图像属性时，它们将完全按照您在侧边栏中所期望的方式显示。</p><p id="b246" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这就是我们设置侧边栏单元格所需要做的一切！</p><p id="a59b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们只需对我们的标题单元格重复这个过程，只需做很少的更改。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nb nc l"/></div></figure><p id="7839" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这里我们使用了非常相似的东西，但是内容配置不同。字体被覆盖以更好地匹配Apple music示例，但是如果您愿意，可以保留这个标准。</p><p id="cd2d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在我们的可扩展注册中，我们可以看到内容配置的附件功能，这允许我们显示类似于公开指示器的内容，或者在本例中，显示大纲公开。大纲显示是一个特殊的附件，允许用户点击它并展开标题所在的部分。</p><p id="ab57" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在我们有了这些，我们实际上可以制作我们的数据源。有了我们刚刚完成的新注册，代码就变得很简单了。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nb nc l"/></div></figure><p id="2e9d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们完全按照您的期望创建数据源，并使用新的<code class="fe nd ne nf ng b">dequeueConfiguredReusableCell</code>选项。我们在数据源中所要做的就是切换条目类型，这是我们之前在模型中配置的，并调用新的<code class="fe nd ne nf ng b">dequeue</code>函数。我们使用开关，这样我们可以通过正确的注册，但我们不必做任何其他事情，因为我们的<code class="fe nd ne nf ng b">FancyListItem</code>类型足够智能，可以为所有三行类型工作。</p><p id="ab10" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">接下来，让我们实际添加数据。</p><p id="126f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">还记得之前那部分的属性吗？它将允许我们只需几行代码就可以向列表中添加数据。我们这样做的方式也是面向未来的，允许我们在以后添加更多的节和更多的行，只需将它们放在节的属性中。</p><p id="1a1a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">下面是实现这一点的代码。你可能以前没见过这些快照，但它们非常有用。我们不使用普通的数据源快照，而是使用节快照。我们添加标题，然后在标题下添加我们想要的项目，最后调用<code class="fe nd ne nf ng b">expand</code>来确保该部分可见。</p><p id="5c87" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果您不展开没有大纲显示的部分，用户将无法看到它的内容。对于带有大纲显示的部分，用户可以随意打开和关闭它。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nb nc l"/></div></figure></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="9a5f" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">代表</h1><p id="3a9e" class="pw-post-body-paragraph kz la it lb b lc mw ju le lf mx jx lh li my lk ll lm mz lo lp lq na ls lt lu im bi translated">由于我们刚刚使用了相同的section属性，我们的委托变得轻而易举。我们为代理定义了一个协议，该协议将传递一个项目标识符，并在视图控制器中调用该代理。</p><p id="92c0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">确保向视图控制器添加一个变量，我们可以在以后填充它。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nb nc l"/></div></figure><p id="3994" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在我们需要遵守<code class="fe nd ne nf ng b">UICollectionViewDelegate</code>并确保我们安全地调用我们的代表。在这里，我们可以获取相关的部分，并安全地检查标识符。请注意，我们使用的是<code class="fe nd ne nf ng b">indexPath.row-1</code>，而不仅仅是<code class="fe nd ne nf ng b">indexPath.row</code>。这是为了说明第一项总是标题这一事实。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nb nc l"/></div></figure></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="fa53" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">构建导航堆栈</h1><p id="b85c" class="pw-post-body-paragraph kz la it lb b lc mw ju le lf mx jx lh li my lk ll lm mz lo lp lq na ls lt lu im bi translated">我们有一个填充了数据的侧边栏。现在我们只需要创建一个拆分视图来托管它并响应它的回调。</p><p id="9677" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这不完全是最佳实践，但是我们将在<code class="fe nd ne nf ng b">SceneDelegate</code>中直接实现侧边栏委托。一旦你掌握了这一点，你可以很容易地把它迁移到其他地方，比如一个<code class="fe nd ne nf ng b">SidebarCoordinator</code>。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nb nc l"/></div></figure><p id="222b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们再次没有做任何不寻常的事情，但是我们已经为Mac做了一点小小的改变。</p><ul class=""><li id="7977" class="nh ni it lb b lc ld lf lg li nj lm nk lq nl lu nm nn no np bi translated">我们设置了一个双栏风格的拆分视图，这将使侧边栏能够根据用户手势或点击自动生成的侧边栏按钮来打开和关闭。</li><li id="7b97" class="nh ni it lb b lc nq lf nr li ns lm nt lq nu lu nm nn no np bi translated">我们已经为主视图和次视图设置了视图控制器，次视图是从<code class="fe nd ne nf ng b">FancyListItemIdentifier</code>构建的一个简单的占位符。</li></ul><p id="2d91" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">不要担心占位符，它只是一个非常简单的视图控制器，用来证明导航是有效的。所有代码如下。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nb nc l"/></div></figure><p id="30dd" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们现在要做的就是遵守我们的列表委托，我们就可以使用iPad和Mac了。</p><p id="1a23" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在场景委托的底部添加一个符合<code class="fe nd ne nf ng b">FancyListViewControllerDelegate</code>的扩展。这里我们有一个基本的实现，它调用上面的函数来创建一个占位符，然后将其设置为辅助视图控制器。在您的应用程序中，这是您获取正确视图控制器的地方。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nb nc l"/></div></figure><p id="2b62" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在iPad和Mac上运行该应用程序，你会看到以下内容——万岁！</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nv"><img src="../Images/243903b4c66aa56e34dfc3ef42c4cc4f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ZrQ-K_o7nK-i5FuaSVjEJQ.png"/></div></div></figure><p id="c946" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">它看起来很棒，你甚至可以看到键盘快捷键在iPad上可用。但是我们还有另一种情况要处理:多任务处理。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi mv"><img src="../Images/02f23ffc9e9e3406d2a55909a1bae31e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*IMIdY02xnngP2pWW_kJ_Aw.png"/></div></div></figure><p id="5354" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">当我们进入紧凑的多任务处理时，我们最终得到的是一个每次触摸都不起作用的列表。我们必须对此采取措施，幸运的是，解决方案非常简单。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="8883" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">处理小型设备</h1><p id="c592" class="pw-post-body-paragraph kz la it lb b lc mw ju le lf mx jx lh li my lk ll lm mz lo lp lq na ls lt lu im bi translated">当你使用紧凑型设备时，你通常会期望一个标签栏，这正是我们现在要添加的。添加标签栏的功能非常简单——我们实际上已经使用过了！</p><pre class="kj kk kl km gt nw ng nx ny aw nz bi"><span id="c33b" class="oa md it ng b gy ob oc l od oe">splitViewController.setViewController(FancyTabBarController(), for: .compact)</span></pre><p id="1675" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">不幸的是，我们不得不独立地实现标签栏和它的导航堆栈，但这对于在所有设备上获得良好的用户体验来说是很小的代价。我已经创建了一个基本的<code class="fe nd ne nf ng b">FancyTabBarController</code>，但是你应该以你认为最好的方式实现它。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nb nc l"/></div></figure><p id="14be" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">当我们实现这个的时候，一旦我们的size类变成了horizontal，我们就会得到一个tab栏。修正了上面的例子，给出了下面的例子。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi mv"><img src="../Images/045c9095d51241209695807b6af52e9e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*r4cjLvnFGbyDIYW7qkrdcQ.png"/></div></div></figure></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><p id="a853" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">就是这样！</p><p id="11cf" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们现在在所有平台上都有一个最佳的导航系统，只需要最少的工作。接下来的步骤是用一组真正的视图控制器替换掉<code class="fe nd ne nf ng b">viewController(for itemIdentifier:)</code>函数的内容，但这完全取决于您！</p><p id="c8dd" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">当然，这里是<a class="ae ky" href="https://github.com/SwiftyAlex/sidebar-sample" rel="noopener ugc nofollow" target="_blank">示例代码。</a></p></div></div>    
</body>
</html>