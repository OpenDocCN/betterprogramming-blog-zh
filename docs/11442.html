<html>
<head>
<title>How SOLID Remains Solid — Software Principles vs. Patterns</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何保持稳固——软件原则与模式</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/how-solid-remains-solid-software-principles-vs-patterns-c77c623a628b?source=collection_archive---------4-----------------------#2022-03-21">https://betterprogramming.pub/how-solid-remains-solid-software-principles-vs-patterns-c77c623a628b?source=collection_archive---------4-----------------------#2022-03-21</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="7201" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">简单明了</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/5ae3d7313ad2e79b7f1e9d16ade8c032.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*UtIhx7901QZzH8hLTkRDhQ.jpeg"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">Artem Kniaz 在<a class="ae kv" href="https://unsplash.com/?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</p></figure><p id="813b" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">上次，我们讨论了依赖倒置&amp;和依赖注入之间的<a class="ae kv" rel="noopener ugc nofollow" target="_blank" href="/straightforward-simple-dependency-inversion-vs-dependency-injection-7d8c0d0ed28e">差异。两者都是重要的概念，可以帮助我们构建更好的软件。然而，一个关键的区别是依赖注入是一种模式，而依赖倒置是一种原则。</a></p><p id="3410" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">今天我们将讨论为什么这是一个重要的区别。</p><h1 id="e172" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">什么是原则？</h1><p id="f4e4" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">原则是根本真理。它们是人们建立更复杂的系统和理论的基础。说到创造新事物，原则是至关重要的。它们让我们能够<a class="ae kv" href="https://fs.blog/first-principles/" rel="noopener ugc nofollow" target="_blank">实现指数级的结果</a>，通过新的和以前没有想到的方式连接这些点。原则是世界不断变化的解药，这种变化似乎正在加速。<br/>原则的例子可以在生活的各个领域找到:</p><ul class=""><li id="7c9c" class="mp mq iq ky b kz la lc ld lf mr lj ms ln mt lr mu mv mw mx bi translated">在软件工程中，我们有<a class="ae kv" href="https://en.wikipedia.org/wiki/SOLID" rel="noopener ugc nofollow" target="_blank">坚实的设计原则</a>。</li><li id="a412" class="mp mq iq ky b kz my lc mz lf na lj nb ln nc lr mu mv mw mx bi translated">在心理学中，我们有<a class="ae kv" href="https://en.wikipedia.org/wiki/Pleasure_principle_(psychology)" rel="noopener ugc nofollow" target="_blank">快乐原则</a>。</li><li id="8c52" class="mp mq iq ky b kz my lc mz lf na lj nb ln nc lr mu mv mw mx bi translated">在物理学中，我们有<a class="ae kv" href="https://en.wikipedia.org/wiki/Newton%27s_laws_of_motion" rel="noopener ugc nofollow" target="_blank">运动原理</a>。</li></ul><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nd"><img src="../Images/7485dc60554754ab6a0533042b011101.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*nTxmu7dwo-LdFsZL56DAvg.jpeg"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">照片由<a class="ae kv" href="https://unsplash.com/@danclear?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">丹清除</a>上的<a class="ae kv" href="https://unsplash.com/s/photos/principle?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a></p></figure><h1 id="5801" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">什么是模式？</h1><p id="79c0" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">简单地说，模式是以可预测的方式重复自身的东西。<br/>我们的大脑非常善于识别模式。不仅如此，通过使用归纳思维，他们善于预测这些模式意味着什么。<br/>模式的例子也可以在生活的各个领域找到:</p><ul class=""><li id="5c47" class="mp mq iq ky b kz la lc ld lf mr lj ms ln mt lr mu mv mw mx bi translated">在软件工程中，我们有<a class="ae kv" href="https://en.wikipedia.org/wiki/Software_design_pattern" rel="noopener ugc nofollow" target="_blank">设计模式</a>。</li><li id="92d4" class="mp mq iq ky b kz my lc mz lf na lj nb ln nc lr mu mv mw mx bi translated">在时装业，我们有<a class="ae kv" href="https://en.wikipedia.org/wiki/Pattern_(sewing)" rel="noopener ugc nofollow" target="_blank">图案作为模板</a>。</li><li id="6114" class="mp mq iq ky b kz my lc mz lf na lj nb ln nc lr mu mv mw mx bi translated">在自然界中，我们有对称、分形等<a class="ae kv" href="https://en.wikipedia.org/wiki/Patterns_in_nature" rel="noopener ugc nofollow" target="_blank">视觉模式</a>。</li></ul><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi ne"><img src="../Images/39ae3dca62abb8afd05d1690afe3ed57.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*VEOJDhkYomUXbz5LpFaLtg.jpeg"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">照片由<a class="ae kv" href="https://unsplash.com/@jjying?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> JJ英</a>在<a class="ae kv" href="https://unsplash.com/s/photos/pattern?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</p></figure><h1 id="60e6" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">为什么你应该依靠原则</h1><p id="41aa" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">我们都在寻找可以依赖的稳定的东西，一些超越背景和不断变化的技术的潜在真理。好了，别再看了，原则正是我们所需要的。</p><p id="6e5a" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">人类对食物的需求是一个原则。(除了<a class="ae kv" href="https://en.wikipedia.org/wiki/Inedia" rel="noopener ugc nofollow" target="_blank">呼吸者</a>，他们声称靠空气和阳光生存)。你可以相信这是一条公理，只要人类还是人类，它就不会改变。</p><p id="507e" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">相比之下，人类对披萨的需求是一种模式。如果你走在年轻人中间，尤其是年轻的软件工程师，这几乎就像是一个原则——披萨很棒，它肯定是人类的基本需求。然而，就像其他模式一样，我们对比萨饼的普遍喜爱也是受环境影响的。如果你在节食，比萨饼很快就会变成一种反模式——无论如何都要避免。</p><h1 id="848d" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">软件工程原理</h1><p id="e990" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">在软件工程的世界里，当设计软件时，我们也有原则作为我们的路标。</p><p id="002f" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">以依赖倒置为例。这是<a class="ae kv" href="https://en.wikipedia.org/wiki/SOLID" rel="noopener ugc nofollow" target="_blank">坚实</a>的5个核心原则的一部分。简而言之——这意味着我们应该依赖抽象，而不是具体的实现。这个原则帮助我们设计健壮的可维护软件。没有上下文会迫使我们更喜欢具体的实现而不是抽象，因为使用抽象的成本可以忽略不计，而具体实现的成本可能是无限的。</p><h1 id="7a33" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">软件工程中的模式</h1><p id="9dd2" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">软件工程的世界也充满了模式，其中一些被认为是“不好的”，我们倾向于称之为“反模式”，其中最令人难忘的是可怕的“意大利面条代码”。而有些被认为是“好的”，我们简单地称它们为“设计模式”。</p><p id="1652" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">反模式被认为是糟糕的实践，是通向无尽麻烦和错误的道路，是没有经验的工程师的标志。无论如何都要避免它们。它们仍然被认为是模式，因为它们的发生是可以预测的，特别是对于没有经验的工程师。在“意大利面条式代码”的例子中，它只是思维混乱的一种表现，当试图在没有事先计划或经验的情况下解决问题时，这种情况往往会自然发生。</p><p id="eb70" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">设计模式被认为是很好的实践——使用我们作为软件工程师的集体经验来寻找常见问题的优雅解决方案。问题是，有时甚至“好”模式也可能被误用，潜在地将它们变成反模式。</p><h1 id="f150" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">设计模式——好的、坏的和可能的</h1><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nf"><img src="../Images/14f21ec2a834698586c432a6da958460.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*s-ADXa4ZVY3sU6WIiFgV-g.jpeg"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">卡罗琳·霍尔在<a class="ae kv" href="https://unsplash.com/s/photos/maybe?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的照片</p></figure><p id="1b78" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">有很多设计模式的例子，但是根据经验，一个好的设计模式根植于设计原则。<br/>例如，依赖注入是一个伟大的设计模式，它允许我们将创建和使用分开。它减少了耦合，改进了测试，并且植根于设计原则——它是依赖倒置原则的实现。</p><p id="6f04" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">然而，有些模式并没有被普遍接受，主要是因为它们没有深深植根于设计原则中。例如，让我们来看看单例模式。大多数人认为它是一种有用的设计模式。它用于只需要一个类实例的情况，拥有多个实例是有害的。当我们想要为一个缓存、一个配置文件或一个记录器创建一个单独的实例时，这种模式非常方便。</p><p id="c9c5" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">然而，有些人认为它是一种反模式。一个常见的说法是，模式违反了单一责任原则(实线中的S ),因为它控制了它的生命周期，并在自身上强制执行单一实例行为。在我看来，这并不准确，因为实例控制与功能是正交的，而SRP指的是功能。更合理的说法是，单例违反了依赖倒置原则，因为您依赖于具体的实现——通过具体的静态方法访问单例，而不是依赖抽象。这导致了紧密耦合，这使得我们的代码更难维护，如果发生变化，更容易出现错误。这并不是说单例模式本质上是不好的，但是如果它看起来违反了原则，那么在实现它之前你应该小心。</p><h1 id="dd25" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">我们今天学到了什么</h1><p id="ceda" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">在软件工程中，就像在生活中一样，我们有模式和原则。发现模式并使用它们来解决常见的问题是非常有益的。然而，没有深深扎根于原则的模式可能会变成反模式——导致比它们解决的问题更多的问题。</p><p id="5b37" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">下次你发现自己在学习一个新的设计模式，或者甚至想要实现一个现有的模式时，问问自己——这个模式植根于可靠的(双关语)设计原则吗？或者，它可能会导致不可预见的问题吗？</p><p id="3c55" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我希望这篇文章对你有用，在下一次之前，保持它简单明了！</p></div></div>    
</body>
</html>