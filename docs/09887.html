<html>
<head>
<title>Understand Keys, Virtual DOM, Reconciliation, and Diffing in React</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">理解键、虚拟DOM、协调和差异</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/understand-keys-virtual-dom-reconciliation-and-diffing-in-react-e65a9bee316f?source=collection_archive---------2-----------------------#2021-10-26">https://betterprogramming.pub/understand-keys-virtual-dom-reconciliation-and-diffing-in-react-e65a9bee316f?source=collection_archive---------2-----------------------#2021-10-26</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="6561" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">React开发人员的基本概念</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/b4f87bf99dfb89307a4e140137e7c1c5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*GJiR7jC07hARQ1WogY1Ffg.jpeg"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">图片来源:<a class="ae ky" href="https://wallpaperaccess.com/react-js" rel="noopener ugc nofollow" target="_blank">壁纸访问</a></p></figure><p id="631b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">许多开发人员知道如何用React构建复杂的ui，但很少有人了解React的内部。为了充分发挥React的潜力，学习这些概念非常重要。</p><p id="346f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们从虚拟DOM开始。</p><h1 id="ba47" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">虚拟DOM</h1><p id="796d" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">它是UI(DOM的副本)的虚拟表示，保存在内存中，并通过像<a class="ae ky" href="https://reactjs.org/docs/react-dom.html" rel="noopener ugc nofollow" target="_blank"> ReactDOM </a>这样的库与真实的DOM同步。</p><h2 id="8860" class="ms lw it bd lx mt mu dn mb mv mw dp mf li mx my mh lm mz na mj lq nb nc ml nd bi translated">既然有实际的DOM，为什么我们还需要一个虚拟的DOM呢？</h2><p id="d109" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">嗯，DOM操作是昂贵的，并且在每次属性/状态改变时更新整个DOM是非常低效的。下面是虚拟DOM如何处理这种低效率:</p><ul class=""><li id="d7e0" class="ne nf it lb b lc ld lf lg li ng lm nh lq ni lu nj nk nl nm bi translated">组件道具/状态改变</li><li id="dd65" class="ne nf it lb b lc nn lf no li np lm nq lq nr lu nj nk nl nm bi translated">React触发重新渲染</li><li id="bb5d" class="ne nf it lb b lc nn lf no li np lm nq lq nr lu nj nk nl nm bi translated">React将虚拟DOM(更新前的虚拟DOM)与更新后的虚拟DOM(更新后的虚拟DOM)进行比较</li><li id="e0d4" class="ne nf it lb b lc nn lf no li np lm nq lq nr lu nj nk nl nm bi translated">React通过对真实DOM进行最少的操作来确定反映UI变化的最佳方式。</li></ul><p id="f3c2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">所以它的虚拟DOM帮助React更新UI以匹配最新的树。</p><h1 id="3946" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">和解</h1><p id="fe44" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">保持虚拟DOM与真实DOM同步的过程称为协调。</p><p id="0398" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">所以我们上面讨论的整个过程被称为和解。</p><h1 id="abbc" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">差异</h1><p id="a0cb" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">虚拟DOM之间的比较(找出UI中需要更新的内容)被称为diffing，进行这种比较的算法被称为diffing算法。</p><h2 id="4f33" class="ms lw it bd lx mt mu dn mb mv mw dp mf li mx my mh lm mz na mj lq nb nc ml nd bi translated">差分算法是如何工作的？</h2><p id="f9ff" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">diffing算法通过首先比较它们的根节点来比较这两棵树。</p><h2 id="07bc" class="ms lw it bd lx mt mu dn mb mv mw dp mf li mx my mh lm mz na mj lq nb nc ml nd bi translated">不同的根节点</h2><p id="8f21" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">考虑下面的片段:</p><pre class="kj kk kl km gt ns nt nu nv aw nw bi"><span id="d298" class="ms lw it nt b gy nx ny l nz oa">&lt;div&gt;<br/>  &lt;p&gt;Hello&lt;/p&gt;<br/>&lt;/div&gt;</span><span id="2674" class="ms lw it nt b gy ob ny l nz oa">&lt;section&gt;<br/>  &lt;p&gt;Hello&lt;/p&gt;<br/>&lt;/section&gt;</span></pre><p id="8618" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">比较上面的两棵树将导致完全的重建，因为根元素<code class="fe oc od oe nt b">&lt;div&gt;</code>和<code class="fe oc od oe nt b">&lt;section&gt;</code>是不同的。根目录下的任何组件也将被重建。</p><h2 id="a289" class="ms lw it bd lx mt mu dn mb mv mw dp mf li mx my mh lm mz na mj lq nb nc ml nd bi translated">相同的根节点</h2><p id="c070" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">当比较相同类型的DOM元素时，React会比较两者的属性，保持相同的底层DOM节点，并更新更改后的属性。</p><pre class="kj kk kl km gt ns nt nu nv aw nw bi"><span id="bfd7" class="ms lw it nt b gy nx ny l nz oa">&lt;div className="foo" /&gt;</span><span id="4b46" class="ms lw it nt b gy ob ny l nz oa">&lt;div className="foo bar" /&gt;</span></pre><p id="18e1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">React修改底层DOM节点上的类名。</p><h2 id="1c8a" class="ms lw it bd lx mt mu dn mb mv mw dp mf li mx my mh lm mz na mj lq nb nc ml nd bi translated">不同列表</h2><p id="bb81" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">当区分DOM节点的子节点时，React会比较两个列表的子节点，并在有差异时生成一个变异。</p><p id="6686" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">考虑下面的待办事项列表:</p><pre class="kj kk kl km gt ns nt nu nv aw nw bi"><span id="af5b" class="ms lw it nt b gy nx ny l nz oa">&lt;ul&gt;<br/>  &lt;li&gt;Breakfast&lt;/li&gt;<br/>  &lt;li&gt;Lunch&lt;/li&gt;<br/>&lt;/ul&gt;</span></pre><p id="2c3d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在，让我们在列表的开头添加一个新项目:</p><pre class="kj kk kl km gt ns nt nu nv aw nw bi"><span id="0933" class="ms lw it nt b gy nx ny l nz oa">&lt;ul&gt;<br/>  &lt;li&gt;Exercise&lt;/li&gt;<br/>  &lt;li&gt;Breakfast&lt;/li&gt;<br/>  &lt;li&gt;Lunch&lt;/li&gt;<br/>&lt;/ul&gt;</span></pre><p id="c48d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">当新项目添加到列表中时，会发生以下情况:</p><ul class=""><li id="db73" class="ne nf it lb b lc ld lf lg li ng lm nh lq ni lu nj nk nl nm bi translated">React将虚拟DOM中的<code class="fe oc od oe nt b">&lt;li&gt;Breakfast&lt;/li&gt;</code>与更新后的虚拟DOM中的<code class="fe oc od oe nt b">&lt;li&gt;Exercise&lt;/li&gt;</code>进行比较</li><li id="b204" class="ne nf it lb b lc nn lf no li np lm nq lq nr lu nj nk nl nm bi translated">这个比较告诉React列表项被改变了</li><li id="5730" class="ne nf it lb b lc nn lf no li np lm nq lq nr lu nj nk nl nm bi translated">React将重新绘制DOM中的所有列表项</li></ul><p id="4bb5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这是非常低效的，因为React必须重新绘制所有的列表项。为了解决这个问题，我们可以给一个<code class="fe oc od oe nt b">key</code>属性一个值，在它的兄弟列表中唯一地标识一个列表项。</p><h1 id="5085" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">键</h1><p id="a09e" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">属性让React识别列表中的每个元素。它用于跟踪被更改、添加或删除的项目。键在其同级中应该是唯一的，而不是全局唯一的。</p><p id="2995" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在让我们在上面的例子中添加一个关键道具:</p><pre class="kj kk kl km gt ns nt nu nv aw nw bi"><span id="ea1f" class="ms lw it nt b gy nx ny l nz oa">&lt;ul&gt;<br/>  &lt;li key="br"&gt;Breakfast&lt;/li&gt;<br/>  &lt;li key="lu"&gt;Lunch&lt;/li&gt;<br/>&lt;/ul&gt;</span><span id="e4af" class="ms lw it nt b gy ob ny l nz oa">&lt;ul&gt;<br/>  &lt;li key="ex"&gt;Exercise&lt;/li&gt;<br/>  &lt;li key="br"&gt;Breakfast&lt;/li&gt;<br/>  &lt;li key="lu"&gt;Lunch&lt;/li&gt;<br/>&lt;/ul&gt;</span></pre><p id="d5cf" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在React知道带有关键字<code class="fe oc od oe nt b">'ex'</code>的元素是新的元素，React将只是把新元素添加到DOM中，而不是再次操作DOM中的所有项目。</p><h1 id="5470" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">选择什么作为键？</h1><p id="c408" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">通常，你正在迭代的数据集已经有一个ID或者可以用作ID的东西。所以你可以用这个。</p><pre class="kj kk kl km gt ns nt nu nv aw nw bi"><span id="7733" class="ms lw it nt b gy nx ny l nz oa">&lt;li key={item.id}&gt;{item.name}&lt;/li&gt;</span></pre><p id="61e1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">当您的数据集中没有稳定的id时，您可以使用像<a class="ae ky" href="https://www.npmjs.com/package/nanoid" rel="noopener ugc nofollow" target="_blank"> nanoid </a>这样的库，它可以为您生成唯一的ID。</p><pre class="kj kk kl km gt ns nt nu nv aw nw bi"><span id="6d58" class="ms lw it nt b gy nx ny l nz oa">import { nanoid } from 'nanoid';</span><span id="bec1" class="ms lw it nt b gy ob ny l nz oa">{items.map(item =&gt; (<br/>  &lt;div key={nanoid()}&gt;{item.name}&lt;/div&gt;<br/>))}</span></pre><p id="2576" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">但是，索引并不总是最佳选择，可能会导致性能下降和意外的呈现问题。<a class="ae ky" href="https://robinpokorny.medium.com/index-as-a-key-is-an-anti-pattern-e0349aece318" rel="noopener">这里有一篇文章解释了使用索引作为关键字的负面影响</a>。</p></div><div class="ab cl of og hx oh" role="separator"><span class="oi bw bk oj ok ol"/><span class="oi bw bk oj ok ol"/><span class="oi bw bk oj ok"/></div><div class="im in io ip iq"><p id="183b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">感谢阅读。如果你喜欢你读到的东西，也可以看看相关的故事。</p><h1 id="10b8" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">有关系的</h1><div class="om on gp gr oo op"><a href="https://haseeb-anwar.medium.com/react-router-6-features-upgradation-guide-886b9bc2fb71" rel="noopener follow" target="_blank"><div class="oq ab fo"><div class="or ab os cl cj ot"><h2 class="bd iu gy z fp ou fr fs ov fu fw is bi translated">React路由器6功能和升级指南</h2><div class="ow l"><h3 class="bd b gy z fp ou fr fs ov fu fw dk translated">迄今为止最强大的React客户端路由器</h3></div><div class="ox l"><p class="bd b dl z fp ou fr fs ov fu fw dk translated">haseeb-anwar.medium.com</p></div></div><div class="oy l"><div class="oz l pa pb pc oy pd ks op"/></div></div></a></div><div class="om on gp gr oo op"><a rel="noopener  ugc nofollow" target="_blank" href="/8-best-practices-every-react-developer-should-follow-44177670c646"><div class="oq ab fo"><div class="or ab os cl cj ot"><h2 class="bd iu gy z fp ou fr fs ov fu fw is bi translated">每个React开发人员应该遵循的8个最佳实践</h2><div class="ow l"><h3 class="bd b gy z fp ou fr fs ov fu fw dk translated">编写更好的React代码的技巧</h3></div><div class="ox l"><p class="bd b dl z fp ou fr fs ov fu fw dk translated">better编程. pub</p></div></div><div class="oy l"><div class="pe l pa pb pc oy pd ks op"/></div></div></a></div></div></div>    
</body>
</html>