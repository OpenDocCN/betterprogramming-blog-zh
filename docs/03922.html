<html>
<head>
<title>Android and iOS View/Logic Decoupling With Examples</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Android和iOS视图/逻辑解耦示例</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/android-ios-view-logic-decoupling-examples-8be1bc287114?source=collection_archive---------10-----------------------#2020-03-12">https://betterprogramming.pub/android-ios-view-logic-decoupling-examples-8be1bc287114?source=collection_archive---------10-----------------------#2020-03-12</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="821b" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">通过简化代码来改进我们的应用程序</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/45027de41be5490c161ca926a9c7aae3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*QUGq0jT_wnidZpZy"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">照片<a class="ae ky" href="https://unsplash.com/@killerfvith" rel="noopener ugc nofollow" target="_blank">来自<a class="ae ky" href="https://unsplash.com/photos/l5Tzv1alcps" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>的黄福生</a></p></figure><p id="325b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">为了使我们的应用程序代码更好地结构化，可以将逻辑与视图分离开来——例如<code class="fe lv lw lx ly b">Activity</code>(在Android中)和<code class="fe lv lw lx ly b">ViewController</code>(在iOS中)。因此，知道如何做是很重要的。</p><p id="bc51" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在这里，我分享了从视图中分离逻辑的各种方法，并在Android (Kotlin)和iOS (Swift)中给出了例子。这使得学习这两个平台更加容易。</p><p id="0ac8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这也将像MVP这样的架构暴露给MVVM。可以评估一下个别app哪个更好。</p></div><div class="ab cl lz ma hx mb" role="separator"><span class="mc bw bk md me mf"/><span class="mc bw bk md me mf"/><span class="mc bw bk md me"/></div><div class="im in io ip iq"><h1 id="a1eb" class="mg mh it bd mi mj mk ml mm mn mo mp mq jz mr ka ms kc mt kd mu kf mv kg mw mx bi translated">代码示例</h1><p id="92de" class="pw-post-body-paragraph kz la it lb b lc my ju le lf mz jx lh li na lk ll lm nb lo lp lq nc ls lt lu im bi translated">为了帮助学习，我在两个平台上都创建了代码示例，其中六个示例(六个按钮)做完全相同的事情(从用户的角度来看)，但是具有不同的架构方法，我将在下面的每一节中详细介绍。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nd"><img src="../Images/f98370fc1d96f9feb8e1109307b15d1a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*czzOH0kDRcAtmDQVkd8zWA.png"/></div></div></figure><div class="ne nf gp gr ng nh"><a href="https://github.com/elye/demo_android_view_model_view_decouple" rel="noopener  ugc nofollow" target="_blank"><div class="ni ab fo"><div class="nj ab nk cl cj nl"><h2 class="bd iu gy z fp nm fr fs nn fu fw is bi translated">elye/demo _ Android _ view _ model _ view _ decouple</h2><div class="no l"><h3 class="bd b gy z fp nm fr fs nn fu fw dk translated">在Android-elye/demo _ Android _ View _ model _ View _ decouple中演示解耦视图模型及其视图的各种架构</h3></div><div class="np l"><p class="bd b dl z fp nm fr fs nn fu fw dk translated">github.com</p></div></div><div class="nq l"><div class="nr l ns nt nu nq nv ks nh"/></div></div></a></div><div class="ne nf gp gr ng nh"><a href="https://github.com/elye/demo_ios_view_model_view_decouple" rel="noopener  ugc nofollow" target="_blank"><div class="ni ab fo"><div class="nj ab nk cl cj nl"><h2 class="bd iu gy z fp nm fr fs nn fu fw is bi translated">elye/demo _ IOs _ view _ model _ view _ decouple</h2><div class="no l"><h3 class="bd b gy z fp nm fr fs nn fu fw dk translated">演示在iOS-elye/demo _ iOS _ View _ model _ View _ decouple中解耦视图模型及其视图的各种架构</h3></div><div class="np l"><p class="bd b dl z fp nm fr fs nn fu fw dk translated">github.com</p></div></div><div class="nq l"><div class="nw l ns nt nu nq nv ks nh"/></div></div></a></div></div><div class="ab cl lz ma hx mb" role="separator"><span class="mc bw bk md me mf"/><span class="mc bw bk md me mf"/><span class="mc bw bk md me"/></div><div class="im in io ip iq"><h1 id="ec64" class="mg mh it bd mi mj mk ml mm mn mo mp mq jz mr ka ms kc mt kd mu kf mv kg mw mx bi translated">基本:无架构</h1><p id="ae6f" class="pw-post-body-paragraph kz la it lb b lc my ju le lf mz jx lh li na lk ll lm nb lo lp lq nc ls lt lu im bi translated">首先，让我们看一个没有任何架构的。这有助于说明整体功能是什么。它是由青色按钮触发的。代码易于追踪，因为所有代码(包括逻辑)都在<code class="fe lv lw lx ly b">Activity</code>和<code class="fe lv lw lx ly b">ViewController</code>中。</p><p id="db7f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">功能很简单:我们将显示一个可编辑的文本字段和一个保存按钮。我们称之为<em class="nx">编辑模式。</em>一旦用户输入内容并点击保存按钮，它就会变成一个标签，里面显示文本。它还会显示一个清除按钮。我们称之为<em class="nx">视图模式。</em></p><p id="a8af" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">相反，当用户点击清除按钮时，它将返回到编辑模式并清除文本。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ny"><img src="../Images/727d7b70ddac4e7a1a6e982d086c83e5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*feuRwm06mRn3-QVTnSRKaw.png"/></div></div></figure><p id="a580" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">除了在编辑模式和查看模式之间来回切换之外，它还将类型数据保存到内存中。因此，如果用户在查看模式下退出视图并返回页面，它将显示编辑模式。</p><p id="6e74" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">从功能上讲，它的工作原理如下面的流程图所示。流程中有几个逻辑的例子。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi nz"><img src="../Images/67f126b3864508052e98333174872a13.png" data-original-src="https://miro.medium.com/v2/resize:fit:1322/format:webp/1*rvRPC8YOHp264SlRkE4s7w.png"/></div></figure><p id="bb18" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">从架构图来看，没有逻辑分离。一切都在一个类内处理(<code class="fe lv lw lx ly b">Activity</code> / <code class="fe lv lw lx ly b">ViewController</code>)。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi oa"><img src="../Images/62f09fb2c5a63437a6a9c70b3e09c3a7.png" data-original-src="https://miro.medium.com/v2/resize:fit:942/format:webp/1*fzVC2eE8lpGxssO-bdWoXw.png"/></div></figure><p id="3c89" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这对于一个小的逻辑视图页面来说是可以的，如本例所示。但是如果我们进一步扩展它的功能，它将无法扩展，并且变得难以维护。此外，这会使测试变得困难，因为我们需要在测试代码中包含<code class="fe lv lw lx ly b">View</code>类。</p><p id="415d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">从长远来看，为了使它变得更好并具有可伸缩性，让我们将逻辑解耦到另一个名为<code class="fe lv lw lx ly b">ViewModel</code>的类中。至于如何做，下面是五种不同的方法。</p></div><div class="ab cl lz ma hx mb" role="separator"><span class="mc bw bk md me mf"/><span class="mc bw bk md me mf"/><span class="mc bw bk md me"/></div><div class="im in io ip iq"><h1 id="16c1" class="mg mh it bd mi mj mk ml mm mn mo mp mq jz mr ka ms kc mt kd mu kf mv kg mw mx bi translated">代表架构</h1><p id="20a2" class="pw-post-body-paragraph kz la it lb b lc my ju le lf mz jx lh li na lk ll lm nb lo lp lq nc ls lt lu im bi translated">在Android世界中，这通常被称为<em class="nx">模型-视图-展示者(MVP) </em>架构模式。在iOS中，它通常被称为<em class="nx">委托方法，</em>主类将其逻辑委托给另一个类。这里，我们指的是逻辑处理类<code class="fe lv lw lx ly b">ViewModel</code>。</p><p id="27a2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这个<code class="fe lv lw lx ly b">ViewModel</code>类将负责所有的逻辑部分(例如，决定保存按钮是否可以保存)以及与持久文本的交互，让<code class="fe lv lw lx ly b">View</code>类不用担心所有这些细节。</p><p id="7521" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe lv lw lx ly b">ViewModel</code>虽然负责逻辑，但需要与视图通信以进入视图或编辑模式。为此，我们需要如下图所示的接口/协议的帮助。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ob"><img src="../Images/376826677e5a794990217d143ce2b6ec.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*zibJXzjBO8t4VuHSwBLykw.png"/></div></div></figure><p id="c2c4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">接口/协议定义了视图需要实现什么，这样<code class="fe lv lw lx ly b">ViewModel</code>就可以进行交互。</p><pre class="kj kk kl km gt oc ly od oe aw of bi"><span id="93aa" class="og mh it ly b gy oh oi l oj ok"><strong class="ly iu">// Android</strong><br/><strong class="ly iu">interface</strong> DelegateView {<br/>    fun enterViewMode(text: String)<br/>    fun enterEditMode()<br/>}</span><span id="3d41" class="og mh it ly b gy ol oi l oj ok"><strong class="ly iu">// iOS<br/>protocol</strong> DelegateView : class {<br/>    func enterViewMode(text: String)<br/>    func enterEditMode()<br/>}</span></pre><p id="52b2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">视图本身会相应地实现这个接口/协议。它拥有一个<code class="fe lv lw lx ly b">ViewModel</code>，在那里它将自己传递给。</p><pre class="kj kk kl km gt oc ly od oe aw of bi"><span id="9b9d" class="og mh it ly b gy oh oi l oj ok"><strong class="ly iu">// Android</strong><br/>class DelegateActivity : AppCompatActivity(), <strong class="ly iu">DelegateView</strong> {<br/>    private var <strong class="ly iu">viewModel: DelegateViewModel</strong>? = null<br/>    //... <br/>    viewModel = <strong class="ly iu">DelegateViewModel(this)</strong><br/>}</span><span id="02dd" class="og mh it ly b gy ol oi l oj ok"><strong class="ly iu">// iOS<br/></strong>class DelegateViewController: UIViewController, <strong class="ly iu">DelegateView</strong> {<br/>    private var <strong class="ly iu">viewModel: DelegateViewModel</strong>?<br/>    //...<br/>    self.viewModel = <strong class="ly iu">DelegateViewModel(delegate: self)</strong><br/>}</span></pre><p id="c991" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">为了进行反馈，<code class="fe lv lw lx ly b">ViewModel</code>也有一个视图的引用，它是接口/协议的实现。</p><pre class="kj kk kl km gt oc ly od oe aw of bi"><span id="a7a7" class="og mh it ly b gy oh oi l oj ok"><strong class="ly iu">// Android</strong><br/>class DelegateViewModel(private val delegate: DelegateView)</span><span id="5359" class="og mh it ly b gy ol oi l oj ok"><strong class="ly iu">// iOS</strong><br/>class DelegateViewModel {<br/>    private <strong class="ly iu">unowned</strong> let delegate: DelegateView!<br/>    init(delegate: DelegateView) { self.delegate = delegate }</span><span id="ed14" class="og mh it ly b gy ol oi l oj ok">    // ...<br/>}</span></pre><p id="b724" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这里需要注意的是，在iOS中，我们将<code class="fe lv lw lx ly b">unowned</code>类型设置为<code class="fe lv lw lx ly b">delegate</code>来打破保持循环。</p><p id="c5fe" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">就是这样。现在，您可以将逻辑从视图中分离出来。有关详细信息，请查看示例代码。</p><h2 id="2872" class="og mh it bd mi om on dn mm oo op dp mq li oq or ms lm os ot mu lq ou ov mw ow bi translated">讨论</h2><p id="bb1b" class="pw-post-body-paragraph kz la it lb b lc my ju le lf mz jx lh li na lk ll lm nb lo lp lq nc ls lt lu im bi translated">这种方法很容易跟踪，并且在视图和<code class="fe lv lw lx ly b">ViewModel </code>之间有很强的契约——如接口/协议所定义的。这使得跟踪变得容易，当缺少某些东西时，编译时错误很容易显示出来。</p><p id="e259" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这种方法的缺点是:</p><ol class=""><li id="7ec4" class="ox oy it lb b lc ld lf lg li oz lm pa lq pb lu pc pd pe pf bi translated">需要额外的接口/协议。</li><li id="5d2d" class="ox oy it lb b lc pg lf ph li pi lm pj lq pk lu pc pd pe pf bi translated">即使我们已经解耦了逻辑，它们仍然以某种方式强耦合，其中一方需要了解另一方的期望。</li><li id="9a0d" class="ox oy it lb b lc pg lf ph li pi lm pj lq pk lu pc pd pe pf bi translated">即使不是所有定义的接口/协议都是必需的，视图仍然需要实现它们(我们可以使用Kotlin中的默认接口来减轻这一点——但不是针对协议)。</li></ol><p id="007c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">为了解决这个限制，让我们看看下一种方法</p></div><div class="ab cl lz ma hx mb" role="separator"><span class="mc bw bk md me mf"/><span class="mc bw bk md me mf"/><span class="mc bw bk md me"/></div><div class="im in io ip iq"><h1 id="5b61" class="mg mh it bd mi mj mk ml mm mn mo mp mq jz mr ka ms kc mt kd mu kf mv kg mw mx bi translated">功能建筑</h1><p id="b170" class="pw-post-body-paragraph kz la it lb b lc my ju le lf mz jx lh li na lk ll lm nb lo lp lq nc ls lt lu im bi translated">我们可以传递函数，而不是用现代编程方法定义接口/协议。这可以使用Kotlin中的lambdas和Swift中的closures来完成。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ob"><img src="../Images/ef2ddeaa3ddefee1590bc558bbd2f13e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*nxwIeNcJoXFxuM3CGbLwPg.png"/></div></div></figure><p id="171a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在<code class="fe lv lw lx ly b">ViewModel</code>中，所需的lambda/闭包定义可以声明如下:</p><pre class="kj kk kl km gt oc ly od oe aw of bi"><span id="a897" class="og mh it ly b gy oh oi l oj ok"><strong class="ly iu">// Android</strong><br/>fun initialSetup(enterEditMode: () -&gt; Unit,<br/>                 enterViewMode: (text: String) -&gt; Unit) </span><span id="7af5" class="og mh it ly b gy ol oi l oj ok"><strong class="ly iu">// iOS</strong><br/>fun initialSetup(enterEditMode: () -&gt; Unit,<br/>                 enterViewMode: (text: String) -&gt; Unit) </span></pre><p id="7b54" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在视图中，用户可以轻松地发送函数:</p><pre class="kj kk kl km gt oc ly od oe aw of bi"><span id="6ffa" class="og mh it ly b gy oh oi l oj ok"><strong class="ly iu">// Android</strong><br/>viewModel?.initialSetup(::enterEditMode, ::enterViewMode)</span><span id="e586" class="og mh it ly b gy ol oi l oj ok"><strong class="ly iu">// iOS</strong><br/>viewModel?.initialSetup(enterEditMode: enterEditMode, <br/>                        enterViewMode: enterViewMode)</span></pre><h2 id="cd63" class="og mh it bd mi om on dn mm oo op dp mq li oq or ms lm os ot mu lq ou ov mw ow bi translated">讨论</h2><p id="256c" class="pw-post-body-paragraph kz la it lb b lc my ju le lf mz jx lh li na lk ll lm nb lo lp lq nc ls lt lu im bi translated">在这种方法中，我们消除了对接口/协议的需求，如上图所示。强契约和耦合不再存在。这使得视图对它所需要的和不需要在<code class="fe lv lw lx ly b">ViewModel</code>中定义的有更多的控制。</p><p id="cb5c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">然而，这种方法的缺点是:</p><ol class=""><li id="101a" class="ox oy it lb b lc ld lf lg li oz lm pa lq pb lu pc pd pe pf bi translated">视图决定了<code class="fe lv lw lx ly b">ViewModel</code>应该调用什么功能。因此，如果一个错误的函数(相同的签名)被发送，这可能会导致一个<code class="fe lv lw lx ly b">ViewModel</code>无法控制的错误。</li><li id="3ef6" class="ox oy it lb b lc pg lf ph li pi lm pj lq pk lu pc pd pe pf bi translated">如果一遍又一遍地需要同一个函数，同样的函数需要一遍又一遍地发送给<code class="fe lv lw lx ly b">ViewModel</code>。例如，下面的代码显示<code class="fe lv lw lx ly b">enterViewMode</code>被发送了两次，而<code class="fe lv lw lx ly b">enterEditMode</code>也被发送了两次。</li></ol><pre class="kj kk kl km gt oc ly od oe aw of bi"><span id="a919" class="og mh it ly b gy oh oi l oj ok"><strong class="ly iu">// Android example</strong><br/>private fun save() {<br/>    viewModel?.save(edit_text.<em class="nx">text</em>.toString(), ::<strong class="ly iu">enterViewMode</strong>)<br/>}<br/><br/>private fun clear() {<br/>    viewModel?.clear(::<strong class="ly iu">enterEditMode</strong>)<br/>}<br/><br/>private fun setupInitialView() {<br/>    viewModel?.initialSetup(::<strong class="ly iu">enterEditMode</strong>, ::<strong class="ly iu">enterViewMode</strong>)<br/>}</span></pre></div><div class="ab cl lz ma hx mb" role="separator"><span class="mc bw bk md me mf"/><span class="mc bw bk md me mf"/><span class="mc bw bk md me"/></div><div class="im in io ip iq"><h1 id="f7cc" class="mg mh it bd mi mj mk ml mm mn mo mp mq jz mr ka ms kc mt kd mu kf mv kg mw mx bi translated">通知架构</h1><p id="b37c" class="pw-post-body-paragraph kz la it lb b lc my ju le lf mz jx lh li na lk ll lm nb lo lp lq nc ls lt lu im bi translated">对于一个简单的应用程序来说，这不是一个很常见的模式，但是在我们研究反应式方法之前，这是值得一游的。</p><p id="33c6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在这种方法中，我们进一步分离了视图和<code class="fe lv lw lx ly b">ViewModel </code>——其中视图与<code class="fe lv lw lx ly b">ViewModel</code>交互，但是<code class="fe lv lw lx ly b">ViewModel</code>不直接与视图通信。</p><p id="3c4e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">相反，<code class="fe lv lw lx ly b">ViewModel</code>只是更新模型(数据)。更新后，数据将向监听其通知的人发送通知。观众将注册收听该事件，因此将被通知这些变化。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi pl"><img src="../Images/ba19f72398b4a2ffa7d9ab7f18b970dc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1262/format:webp/1*UxEE2ZCaUlIGaKsjx0lNmg.png"/></div></figure><p id="0a3d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在我的代码示例中，我使用了Android和iOS自带的通知机制。</p><ul class=""><li id="84bb" class="ox oy it lb b lc ld lf lg li oz lm pa lq pb lu pm pd pe pf bi translated">在Android中，我使用<a class="ae ky" href="https://developer.android.com/reference/androidx/localbroadcastmanager/content/LocalBroadcastManager" rel="noopener ugc nofollow" target="_blank"> LocalBroadcastManager </a></li><li id="c17f" class="ox oy it lb b lc pg lf ph li pi lm pj lq pk lu pm pd pe pf bi translated">在iOS中，我使用<a class="ae ky" href="https://developer.apple.com/documentation/foundation/notificationcenter" rel="noopener ugc nofollow" target="_blank"> NotificationCenter </a></li></ul><p id="d728" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu">注意:</strong>Android中不再推荐LocalBroadcastManager。我使用它——因为它相对类似于iOS中的NotificationCenter。Google推荐使用另一种观察者模式(例如，<a class="ae ky" href="https://github.com/greenrobot/EventBus" rel="noopener ugc nofollow" target="_blank"> EventBus </a> ) —或者甚至是LiveData —作为一种更现代的方式。查看这篇博客文章，了解更多关于LiveData的信息。</p><p id="9a7d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在这种方法中，视图将首先注册为接收者。</p><pre class="kj kk kl km gt oc ly od oe aw of bi"><span id="5a06" class="og mh it ly b gy oh oi l oj ok"><strong class="ly iu">// Android<br/></strong>class NotificationArchitectureActivity : AppCompatActivity() {</span><span id="7c29" class="og mh it ly b gy ol oi l oj ok">  private val messageReceiver: BroadcastReceiver <br/>    = object : BroadcastReceiver() {<br/>    override fun onReceive(context: Context?, intent: Intent) {<br/>        //... <br/>    }<br/>  }</span><span id="fd29" class="og mh it ly b gy ol oi l oj ok">  // ...<br/>  <strong class="ly iu">LocalBroadcastManager.getInstance(this).registerReceiver</strong>(<br/>        messageReceiver,<br/>        IntentFilter(NotificationModel.textSetNotification)<br/>    )</span><span id="0128" class="og mh it ly b gy ol oi l oj ok">}</span><span id="d79f" class="og mh it ly b gy ol oi l oj ok"><strong class="ly iu">// iOS<br/></strong>class NotificationViewController: UIViewController {<br/>    override init(nibName nibNameOrNil: String?, <br/>        bundle nibBundleOrNil: Bundle?) {<br/>        super.init(nibName: nibNameOrNil, bundle: nibBundleOrNil)</span><span id="4cdb" class="og mh it ly b gy ol oi l oj ok">       <strong class="ly iu"> NotificationCenter.default.addObserver</strong>(<br/>            self, selector: #selector(gotNotified(_:)),<br/>            name: NSNotification.Name(rawValue:   <br/>            NotificationModel.textSetNotification),<br/>            object: nil)<br/>    }<br/>}</span></pre><p id="6734" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">此外，在退出视图时，需要记住取消注册。</p><pre class="kj kk kl km gt oc ly od oe aw of bi"><span id="45de" class="og mh it ly b gy oh oi l oj ok"><strong class="ly iu">// Android</strong><br/>override fun onDestroy() {<br/>    <strong class="ly iu">LocalBroadcastManager.getInstance(this).unregisterReceiver</strong>(<br/>        messageReceiver)<br/>    super.onDestroy()<br/>}</span><span id="8e61" class="og mh it ly b gy ol oi l oj ok"><strong class="ly iu">// iOS<br/></strong>deinit {<br/>    <strong class="ly iu">NotificationCenter.default.removeObserver</strong>(<br/>        self, name: NSNotification.Name(rawValue:   <br/>        NotificationModel.textSetNotification),<br/>       object: self)<br/>}</span></pre><p id="47e6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe lv lw lx ly b">ViewModel</code>将有一些逻辑来决定什么时候它应该发送一个对模型文本的更新。当模型文本更新时，它会广播它的文本。</p><pre class="kj kk kl km gt oc ly od oe aw of bi"><span id="8c6d" class="og mh it ly b gy oh oi l oj ok"><strong class="ly iu">// Android<br/></strong>var text: String? = MainActivity.persistedText<br/>    set(value) {<br/>        field = value<br/>        MainActivity.persistedText = value ?: String()<br/>        val intent = Intent(textSetNotification).<em class="nx">apply </em>{ <br/>             putExtra(textKey, value) <br/>        }<strong class="ly iu"><br/>        LocalBroadcastManager.getInstance</strong>(<br/>             MainActivity.globalContext).<strong class="ly iu">sendBroadcast</strong>(intent)<br/>    }</span><span id="41f8" class="og mh it ly b gy ol oi l oj ok"><strong class="ly iu">// iOS<br/></strong>var text: String? {<br/>   didSet {<br/>       ViewController.persistedText = text ?? String()<br/>       let data:[String: String?] <br/>            = [NotificationModel.textKey: text]</span><span id="b567" class="og mh it ly b gy ol oi l oj ok">        <strong class="ly iu">NotificationCenter.default.post</strong>(<br/>            name: NSNotification.Name(<br/>                rawValue: NotificationModel.textSetNotification),<br/>            object: nil, userInfo: data as [AnyHashable : Any]<br/>        )<br/>    }<br/>}</span></pre><p id="af16" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这里，由于广播者只广播模型文本的变化，这种变化可以从有文本变为没有文本，视图仍然需要一些逻辑来决定什么进入编辑模式或视图模式。</p><h2 id="6d3b" class="og mh it bd mi om on dn mm oo op dp mq li oq or ms lm os ot mu lq ou ov mw ow bi translated">讨论</h2><p id="d219" class="pw-post-body-paragraph kz la it lb b lc my ju le lf mz jx lh li na lk ll lm nb lo lp lq nc ls lt lu im bi translated">这种模式看起来不错，因为它使得<code class="fe lv lw lx ly b">ViewModel</code>根本不需要知道视图。它的职责只是更新模型文本(数据)。模型文本(数据)的责任是广播它已经改变了。</p><p id="6482" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这种模式曾因其简洁的解耦而备受青睐。然而，它给人们对心流的理解带来了复杂性。有时，这似乎很神奇——也许视图会知道自己的数据已经更新了。追溯到发送数据的起点并不容易。</p><p id="3b2c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu">注:</strong>Android中曾经流行的<a class="ae ky" href="https://developer.android.com/guide/components/loaders" rel="noopener ugc nofollow" target="_blank"> loader架构</a>也采用了这种模式。该模式将让视图获取<code class="fe lv lw lx ly b">ViewModel</code>来获取数据并更新数据库。在更新数据库时，它会通知视图它已经更改，并将更改后的数据发送过来。这种方法也被Google now认为是不可取的，LiveData被视为首选方法。</p></div><div class="ab cl lz ma hx mb" role="separator"><span class="mc bw bk md me mf"/><span class="mc bw bk md me mf"/><span class="mc bw bk md me"/></div><div class="im in io ip iq"><h1 id="3cae" class="mg mh it bd mi mj mk ml mm mn mo mp mq jz mr ka ms kc mt kd mu kf mv kg mw mx bi translated">反应式建筑</h1><p id="85ed" class="pw-post-body-paragraph kz la it lb b lc my ju le lf mz jx lh li na lk ll lm nb lo lp lq nc ls lt lu im bi translated">通知架构非常简洁，因为它具有很好的解耦性。然而，追踪流程的困难导致了它的衰落。因此，反应式方法开始发挥作用。它具有很好的解耦性，并以更简单的方式来跟踪它们是如何交互的。</p><p id="7658" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我称之为<em class="nx">反应式方法，</em>因为我们使用的是反应式编程机制。然而，在开发社区中，这也被称为<em class="nx">模型-视图-视图-模型(MVVM) </em>架构模式。</p><p id="ad53" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在这种反应式架构中，视图将分配<code class="fe lv lw lx ly b">ViewModel</code>来执行其所需的流程逻辑。<code class="fe lv lw lx ly b">ViewModel</code>有反应对象(如<code class="fe lv lw lx ly b">Subject</code>、<code class="fe lv lw lx ly b">Signal</code>、<code class="fe lv lw lx ly b">Observable</code>等)，<code class="fe lv lw lx ly b">ViewModel</code>可以相应更新。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ob"><img src="../Images/80e0f5085ef8a7f2e3ea1554e4d6a633.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*hVqDHFUPKLRsCLISpHa5pg.png"/></div></div></figure><p id="12bd" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">视图将订阅/绑定/观察反应对象。因此，当反应对象发生任何变化时，视图会立即得到通知。虽然它看起来类似于通知方法，但就其转换数据的能力而言，它要轻得多，也更有效。</p><p id="ad3a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">为了使用反应式方法，我们需要使用外部库。</p><ul class=""><li id="b44c" class="ox oy it lb b lc ld lf lg li oz lm pa lq pb lu pm pd pe pf bi translated">在Android中，我使用<a class="ae ky" href="https://github.com/ReactiveX/RxJava" rel="noopener ugc nofollow" target="_blank"> RxJava </a></li><li id="f457" class="ox oy it lb b lc pg lf ph li pi lm pj lq pk lu pm pd pe pf bi translated">在iOS中，我使用<a class="ae ky" href="https://github.com/DeclarativeHub/ReactiveKit" rel="noopener ugc nofollow" target="_blank"> ReactiveKit </a></li></ul><p id="840e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">要了解更多关于RxJava的信息，你可以参考<a class="ae ky" href="https://medium.com/@elye.project/learning-rxjava-in-android-made-simple-in-kotlin-observable-range-filter-ec605bb273a1" rel="noopener">这篇博文</a>。</p><p id="9dc7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在这种方法中，在<code class="fe lv lw lx ly b">ViewModel</code>中，它有反应对象。需要时，它会用适当的数据更新反应对象。</p><pre class="kj kk kl km gt oc ly od oe aw of bi"><span id="f741" class="og mh it ly b gy oh oi l oj ok"><strong class="ly iu">// Android</strong><br/>val textSubject: <strong class="ly iu">ReplaySubject</strong>&lt;String&gt; = ReplaySubject.create()<br/>// ...<br/>textSubject.onNext(text)</span><span id="1584" class="og mh it ly b gy ol oi l oj ok">// iOS<br/>let<strong class="ly iu"> </strong>textSubject = <strong class="ly iu">ReplayOneSubject</strong>&lt;String, Never&gt;()<br/>//...<br/>textSubject.send(text)</span></pre><p id="46c3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在视图中，我们将订阅/绑定/观察<code class="fe lv lw lx ly b">ViewModel</code>中各自的反应对象。</p><pre class="kj kk kl km gt oc ly od oe aw of bi"><span id="711d" class="og mh it ly b gy oh oi l oj ok"><strong class="ly iu">// Android</strong><br/>disposable = <strong class="ly iu">viewModel?.textSubject?.subscribe </strong>{ text -&gt;<br/>    if (text.<em class="nx">isEmpty</em>()) {<br/>        enterEditMode()<br/>    } else {<br/>        enterViewMode(text)<br/>    }<br/>}</span><span id="4e81" class="og mh it ly b gy ol oi l oj ok"><strong class="ly iu">// iOS</strong><br/><strong class="ly iu">viewModel?.textSubject.observeNext</strong> { [unowned self] text in<br/>    if text.isEmpty {<br/>        self.enterEditMode()<br/>    } else {<br/>        self.enterViewMode(text: text)<br/>    }<br/>}.dispose(in: bag)</span></pre><p id="03e4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">收到信号后，它提取数据并决定如何处理。如你所见，这个观点还是有一些逻辑的。好像不太理想。</p><p id="f505" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">然而，这是因为我使用了一个反应性对象来进行通信，该对象将用于决定视图中的各种视图更改。</p><p id="7fdf" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">为了做得更好并减少视图中所需的逻辑，我们可以考虑使用更多的反应性对象——如下一种方法所示。</p></div><div class="ab cl lz ma hx mb" role="separator"><span class="mc bw bk md me mf"/><span class="mc bw bk md me mf"/><span class="mc bw bk md me"/></div><div class="im in io ip iq"><h1 id="0e8d" class="mg mh it bd mi mj mk ml mm mn mo mp mq jz mr ka ms kc mt kd mu kf mv kg mw mx bi translated">全反应式架构</h1><p id="8a07" class="pw-post-body-paragraph kz la it lb b lc my ju le lf mz jx lh li na lk ll lm nb lo lp lq nc ls lt lu im bi translated">这种方法和上面的完全一样，除了我们使用了更多的反应物体。我们可以将特定视图行为的对象联系在一起。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ob"><img src="../Images/57b71621303c0de19f5adf0162642449.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*dVd-iMEZLY-TWrLB3mrg0Q.png"/></div></div></figure><p id="620f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们进一步放大，看看反应对象和视图组件之间的关系。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi pn"><img src="../Images/b80ce8c032987655818edbf81e7a8396.png" data-original-src="https://miro.medium.com/v2/resize:fit:1142/format:webp/1*YnJCcuK7keS9jAe2ouB8PA.png"/></div></div></figure><p id="383d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这种1:1的关系能够实现<code class="fe lv lw lx ly b">ViewModel</code>中的完全逻辑控制。因此，这从视图中移走了所有可能的逻辑，使得视图依赖于<code class="fe lv lw lx ly b">ViewModel</code>。</p><p id="12c5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">下面，我们展示了视图组件和反应对象之间的绑定关系。</p><pre class="kj kk kl km gt oc ly od oe aw of bi"><span id="0c2b" class="og mh it ly b gy oh oi l oj ok"><strong class="ly iu">// Android</strong><br/>viewModel?.textSubject?.subscribe <strong class="ly iu">{ </strong>text <strong class="ly iu">-&gt;<br/>    </strong>edit_text.setText(text)<br/>    text_view.<em class="nx">text </em>= text <strong class="ly iu">}</strong>?.<em class="nx">addToBag</em>()<br/><br/>viewModel?.modeTextSignal?.subscribe <strong class="ly iu">{ </strong>text_status.<em class="nx">text </em>= <strong class="ly iu">it }<br/>    </strong>?.<em class="nx">addToBag</em>()<br/><br/>viewModel?.hideKeyboardSignal?.subscribe <strong class="ly iu">{ </strong><em class="nx">hideKeyboard</em>() <strong class="ly iu">}<br/>    </strong>?.<em class="nx">addToBag</em>()<br/><br/>viewModel?.hideClearButton?.subscribe <strong class="ly iu">{ </strong>btn_clear.<em class="nx">hideIt</em>(<strong class="ly iu">it</strong>) <strong class="ly iu">}<br/>    </strong>?.<em class="nx">addToBag</em>()<br/><br/>viewModel?.hideTextField?.subscribe <strong class="ly iu">{ </strong>edit_text.<em class="nx">hideIt</em>(<strong class="ly iu">it</strong>)<strong class="ly iu">}<br/>    </strong>?.<em class="nx">addToBag</em>()<br/><br/>viewModel?.hideSaveButton?.subscribe <strong class="ly iu">{ </strong>btn_save.<em class="nx">hideIt</em>(<strong class="ly iu">it</strong>) <strong class="ly iu">}<br/>    </strong>?.<em class="nx">addToBag</em>()<br/><br/>viewModel?.hideTextLabel?.subscribe <strong class="ly iu">{ </strong>text_view.<em class="nx">hideIt</em>(<strong class="ly iu">it</strong>) <strong class="ly iu">}<br/>    </strong>?.<em class="nx">addToBag</em>()</span><span id="9011" class="og mh it ly b gy ol oi l oj ok"><strong class="ly iu">// iOS</strong><br/>viewModel?.textSubject.observeNext { [unowned self] text in<br/>    self.textField.text = text<br/>    self.textLabel.text = text }.dispose(in: bag)</span><span id="df59" class="og mh it ly b gy ol oi l oj ok">viewModel?.modeTextSignal.observeNext {<br/>    self.statusLabel.text = $0 }.dispose(in: bag)</span><span id="11b3" class="og mh it ly b gy ol oi l oj ok">viewModel?.hideKeyboardSignal.observeNext{<br/>    self.textField.resignFirstResponder() }.dispose(in: bag)</span><span id="2da2" class="og mh it ly b gy ol oi l oj ok">viewModel?.hideTextLabel<br/>    .bind(to: textLabel.reactive.isHidden).dispose(in: bag)</span><span id="d0f0" class="og mh it ly b gy ol oi l oj ok">viewModel?.hideClearButton<br/>    .bind(to: clearButton.reactive.isHidden).dispose(in: bag)</span><span id="b409" class="og mh it ly b gy ol oi l oj ok">viewModel?.hideTextField<br/>    .bind(to: textField.reactive.isHidden).dispose(in: bag)</span><span id="65ab" class="og mh it ly b gy ol oi l oj ok">viewModel?.hideSaveButton<br/>    .bind(to: saveButton.reactive.isHidden).dispose(in: bag)</span></pre><p id="cbf8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">反应式方法是目前比较流行的方法之一，原因在于:</p><ul class=""><li id="c37c" class="ox oy it lb b lc ld lf lg li oz lm pa lq pb lu pm pd pe pf bi translated">将<code class="fe lv lw lx ly b">ViewModel</code>从视图中分离出来的能力，其中<code class="fe lv lw lx ly b">ViewModel</code>根本不需要了解视图</li><li id="a58a" class="ox oy it lb b lc pg lf ph li pi lm pj lq pk lu pm pd pe pf bi translated">响应式对象比通知框架要轻量级得多，因此，我们可以为每个组件单独拥有它们</li><li id="57f7" class="ox oy it lb b lc pg lf ph li pi lm pj lq pk lu pm pd pe pf bi translated">追踪逻辑——尽管不像委托方法那样简单——通常仍然是可行的</li></ul></div><div class="ab cl lz ma hx mb" role="separator"><span class="mc bw bk md me mf"/><span class="mc bw bk md me mf"/><span class="mc bw bk md me"/></div><div class="im in io ip iq"><h1 id="7975" class="mg mh it bd mi mj mk ml mm mn mo mp mq jz mr ka ms kc mt kd mu kf mv kg mw mx bi translated">结论</h1><p id="846f" class="pw-post-body-paragraph kz la it lb b lc my ju le lf mz jx lh li na lk ll lm nb lo lp lq nc ls lt lu im bi translated">鉴于反应式MVVM方法具有很大的优势，它也被Google made Architecture for Android所采用——例如，<a class="ae ky" href="https://developer.android.com/topic/libraries/architecture" rel="noopener ugc nofollow" target="_blank">Android Architecture Components</a>with LiveData等。</p><p id="b863" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">感谢阅读。</p></div></div>    
</body>
</html>