<html>
<head>
<title>The Case Against Immutable Objects in Swift</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Swift中反对不可变对象的案例</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/the-case-against-immutable-objects-88343bbd7912?source=collection_archive---------4-----------------------#2021-08-09">https://betterprogramming.pub/the-case-against-immutable-objects-88343bbd7912?source=collection_archive---------4-----------------------#2021-08-09</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="69fd" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">这是一种你绝对不想使用的设计模式。原因如下。</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/abe9da650717a788fb7ef8c554e3947a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ONlWNevsXnPJghk7VLlDVg.jpeg"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">照片<a class="ae ky" href="https://unsplash.com/@adamsky1973" rel="noopener ugc nofollow" target="_blank">亚当·尼西奥克</a>在<a class="ae ky" href="https://unsplash.com/photos/6khhk2hwx3A" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上。</p></figure><p id="571b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">设计模式来来去去，目前在iOS/Swift编程界流行的一种时尚是不可变对象的概念。</p><p id="2697" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">引用维基百科:</p><blockquote class="lv lw lx"><p id="6be7" class="kz la ly lb b lc ld ju le lf lg jx lh lz lj lk ll ma ln lo lp mb lr ls lt lu im bi translated">在面向对象和函数式编程中，不可变对象是一种在创建后其状态不能被修改的对象。</p></blockquote><p id="a71e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">非常简单。不可变对象被认为是可取的，因为依赖任何给定对象实例的任何人都可以确信<em class="ly">那个</em>对象不会改变它们。</p><p id="4302" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这可以最大限度地减少错误，使代码更容易理解和推理。都是好事。函数式程序员喜欢它们，因为它们是编写纯函数的核心构件之一。</p><p id="6001" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">但是不变性经常伴随着相当高的代价，这个代价就是它经常需要大量的样板代码。</p><p id="6514" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">更不用说在Swift中我们实际上完全解决了错误的问题，但是我跑题了。稍后会详细介绍。</p><p id="2c71" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们先解决样板代码的问题。</p><h1 id="42c3" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">样板代码</h1><p id="c547" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">如果我们要反对不可变对象，理由是它们要求我们编写大量样板代码，那么首先理解样板代码是什么可能会有所帮助。</p><p id="5271" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">再次借用维基百科:</p><blockquote class="lv lw lx"><p id="4096" class="kz la ly lb b lc ld ju le lf lg jx lh lz lj lk ll ma ln lo lp mb lr ls lt lu im bi translated">在计算机编程中，<strong class="lb iu">样板代码</strong>或者仅仅是<strong class="lb iu">样板代码</strong>是在多个地方重复的代码段，几乎没有变化。当使用被认为冗长的语言时，程序员必须写很多代码来完成次要的功能。这样的代码被称为<em class="it">样板文件</em>。</p></blockquote><p id="2c06" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">你知道，开发人员并不特别喜欢写样板代码。只是有些方法和实践倾向于比其他方法和实践创造更多的信息。</p><p id="8367" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">包括不可变的对象。</p><p id="1f39" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">先说简单的。</p><h1 id="7859" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">Swift数据模型</h1><p id="b5d2" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">在Swift中，使用Swift结构创建数据模型是很常见的。在某些领域，将结构的所有成员定义为<code class="fe mz na nb nc b">let</code>变量被认为是一种“最佳实践”,因此它们是不可变的。</p><p id="927f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">考虑到这一点，请考虑以下用户:</p><pre class="kj kk kl km gt nd nc ne nf aw ng bi"><span id="0380" class="nh md it nc b gy ni nj l nk nl">struct User: Codable {<br/>    let id: Int<br/>    let userID: String<br/>    let firstName: String<br/>    let middleName: String?<br/>    let lastName: String<br/>    let address1: String<br/>    let address2: String?<br/>    let city: String<br/>    let state: String<br/>    let postalCode: String<br/>    let country: String<br/>    let primaryEmail: String<br/>    let primaryPhone: String<br/>    let dateOfBirth: Date?<br/>    let gender: Gender<br/>    let maritalStatus: MaritalStatus<br/>    let profilePhotoURL: String?<br/>}</span></pre><p id="933e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">一切都好。我的意思是，这不是我所能想象的最好的一个<code class="fe mz na nb nc b">User</code>对象的API实现，但是这是我们应该做的，所以让我们开始吧。</p><h1 id="32d6" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">需要新功能</h1><p id="d06f" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">因此，管理层刚刚通知我们，我们的应用程序需要一个功能，允许用户更新他们的电子邮件地址。酷毙了。</p><p id="8126" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">唯一的问题是，我们有些脑残的基于CRUD的API要求我们返回整个用户记录，以便更新任何东西。</p><p id="ff44" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在，我们该怎么办？</p><p id="b27e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">对于完全不可变的结构，我们唯一真正的选择是用新数据创建一个全新的结构。所以也许我们可以加上这样的东西。</p><pre class="kj kk kl km gt nd nc ne nf aw ng bi"><span id="1853" class="nh md it nc b gy ni nj l nk nl">extension User {<br/>    func update(emailAddress: String) -&gt; User {<br/>        return User(<br/>            id: id,<br/>            userID: userID,<br/>            firstName: firstName,<br/>            middleName: middleName,<br/>            lastName: lastName,<br/>            address1: address1,<br/>            address2: address2,<br/>            city: city,<br/>            state: state,<br/>            postalCode: postalCode,<br/>            country: country,<br/>            <strong class="nc iu">primaryEmail: primaryEmail</strong>,<br/>            primaryPhone: primaryPhone,<br/>            dateOfBirth: dateOfBirth,<br/>            gender: gender,<br/>            maritalStatus: maritalStatus,<br/>            profilePhotoURL: profilePhotoURL<br/>        )<br/>    }<br/>}</span></pre><p id="4d80" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这是一个经典的功能性的、不可变的设计模式。不要改变或变异原始对象。句号。</p><p id="9ffc" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">只需返回一个应用了新信息的全新对象。</p><p id="f4f4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">好吧。但是……我们的初衷是什么来着？更改电子邮件地址。</p><p id="763c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">为了完成<em class="ly">那个</em>，我们现在必须编写21行额外的样板代码，除了我们的单行电子邮件地址更改之外，这些代码只是复制所有的原始数据。</p><p id="8698" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这是好事吗？</p><h1 id="32d9" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">更多的代码意味着更多的错误</h1><p id="70f9" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">更不用说我未能正确完成我的初衷这个小事实了，因为在我复制、粘贴和自动完成条目的过程中，我无意中在代码中引入了一个bug。</p><p id="3966" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这就导致了样板代码的下一个问题:我们写的每一行代码都是另一行代码，其中可能隐藏着一个bug。</p><p id="e1e8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">对于不可变对象来说，<em class="ly">尤其如此，原因如下:</em></p><ol class=""><li id="918c" class="nm nn it lb b lc ld lf lg li no lm np lq nq lu nr ns nt nu bi translated">改变一个不可变的对象需要我们复制它。</li><li id="4afd" class="nm nn it lb b lc nv lf nw li nx lm ny lq nz lu nr ns nt nu bi translated">这些代码大部分是样板文件。</li><li id="4fda" class="nm nn it lb b lc nv lf nw li nx lm ny lq nz lu nr ns nt nu bi translated">样板代码通常是自动编写的。</li><li id="22ee" class="nm nn it lb b lc nv lf nw li nx lm ny lq nz lu nr ns nt nu bi translated">样板代码通常只是简单地复制和粘贴。</li></ol><h1 id="562b" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">自动驾驶仪</h1><p id="ed2e" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">当我编写上述更新函数时，我不得不从头开始创建一个新的<code class="fe mz na nb nc b">User</code>结构，当我这样做时，我严重依赖Xcode的自动完成功能来填补空白。</p><p id="f6fd" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这是一项乏味、无聊、重复的任务，当你做这种工作时，你的思维往往会陷入自动驾驶状态……这时，错误也可能悄悄进入，不被注意到，也不被需要。</p><p id="fce2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">Autocomplete建议并填充每个占位符字段的值，包括<code class="fe mz na nb nc b">primaryEmail</code>字段。不幸的是，它建议的字段是结构中的字段……而不是作为参数传递给函数本身的<code class="fe mz na nb nc b">emailAddress</code>变量。哎呀。</p><p id="66bf" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">当然，我可能会在第一次尝试运行代码时发现这一点…但也可能不会。</p><p id="d352" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">也许我知道我必须允许用户更新他们的电子邮件地址、电话号码、家庭地址等等，所以我一次创建了所有这些更新机制，以备后用。</p><p id="c75d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">同样，它最终可能会被抓住。可能是通过QA。</p><p id="64d8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">话说回来，也有可能是我在写单元测试的时候发现的。</p><p id="32b5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">但这将我们引向另一个问题。</p><h1 id="c9f0" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">单元测试代码</h1><p id="3190" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">我前面提到过，您编写的每一行代码都是另一个可能潜伏bug的地方。</p><p id="96dd" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><em class="ly">因为</em>我们知道这是真的，我们也认识到需要对我们的代码、类和函数编写单元测试，以便清除那些错误并确保一切按预期运行。</p><p id="2256" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">但是我们都知道我们并不总是这样做。</p><p id="081c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这有点像第22条军规，我们写的所有东西都应该被测试，这意味着我们需要写测试。但是编写测试会占用其他次要的无关紧要的小细节的时间，比如……实际运送产品。</p><p id="2491" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">此外，我们写的代码越多，我们需要确保代码覆盖率的测试就越多，这往往会使我们进一步滑入单元测试死亡螺旋。</p><p id="7823" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">或者，我们甚至编写了一个测试，但未能捕捉到边缘情况。或者也许我们的电子邮件地址代码测试通过了，但是我们完全没有意识到在我们的复制和粘贴马拉松中我们也无意中设置了<code class="fe mz na nb nc b">address2</code>到<code class="fe mz na nb nc b">address1</code>。没有测试过。哎呀。</p><p id="43fd" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">但事实是:我们不写的代码是不需要测试的代码。让我们采取不同的方法。</p><h1 id="d4d6" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">可变代码</h1><p id="4c59" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">如果我们知道我们的应用程序将允许我们的用户更新他们的电子邮件地址、电话号码、出生年月日等等，会怎么样？</p><p id="3e28" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果我们直接让这些改变成为可能，会怎么样？</p><pre class="kj kk kl km gt nd nc ne nf aw ng bi"><span id="155a" class="nh md it nc b gy ni nj l nk nl">struct User: Codable {<br/>    let id: Int<br/>    let userID: String<br/>    let firstName: String<br/>    let middleName: String?<br/>    let lastName: String<br/>    let address1: String<br/>    let address2: String?<br/>    let city: String<br/>    let state: String<br/>    let postalCode: String<br/>    let profilePhotoURL: String?<br/>    let country: String<br/>    var primaryEmail: String<br/>    var primaryPhone: String<br/>    var dateOfBirth: Date?<br/>    var gender: Gender<br/>    var maritalStatus: MaritalStatus<br/>}</span></pre><p id="3eb8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">答对了。我们已经完全消除了编写所有这些变异函数的需要。在这个过程中，我们已经消除了对所有我们没有编写的代码编写所有那些单元测试的需要。</p><p id="acca" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">赢了！</p><p id="0e34" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">此外，当你查看这段代码时，很明显，在应用程序的某个地方，有人可能正在更新那些<code class="fe mz na nb nc b">vars</code>。</p><p id="4e7a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">又赢了！</p><h2 id="eb1c" class="nh md it bd me oa ob dn mi oc od dp mm li oe of mo lm og oh mq lq oi oj ms ok bi translated">但是！但是！但是！不可改变！</h2><p id="e1fb" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">停下来。在你跳到评论区把我撕成碎片之前，请听我说完。</p><p id="195f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我想指出的第一件事是，我最初演示的完全不可变的模型设计模式确实是Java中的最佳实践。</p><p id="43c2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在Java中，你看，我们的用户是一个对象，这意味着对我们的用户的引用正在被传递，这意味着在现有用户对象上更新一个值确实会引入不必要的副作用和错误，当这种改变在代码的其他地方被忽略时。</p><p id="800e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">比如电子邮件地址更新的时候。</p><blockquote class="lv lw lx"><p id="a85d" class="kz la ly lb b lc ld ju le lf lg jx lh lz lj lk ll ma ln lo lp mb lr ls lt lu im bi translated">注意:在Java函数中，参数是通过值传递的。但这仅仅意味着该函数不能改变对用户对象的原始引用。有了正确的访问权限，函数<em class="it">可以</em>更改该对象上的字段，并且这种更改现在将呈现给任何人以及之前引用该对象的每个人。</p></blockquote><h1 id="f022" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">迅速发生的</h1><p id="3bd3" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">然而，在Swift中，结构是值类型，具有写时复制(COW)语义。</p><p id="64d4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在幕后，结构通常是通过引用传递的。*但是只要我们试图修改一个对象，系统就会制作一个有问题的对象的副本，将修改应用到<em class="ly">副本</em>，然后设置我们的本地引用，从现在开始引用新的副本。</p><p id="097f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">整个应用程序中对我们原始用户对象的所有<em class="ly">其他</em>引用都不受影响，因为它们仍然引用原始对象。</p><p id="c449" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这意味着如果某个函数改变了它的副本<code class="fe mz na nb nc b">User</code>、<strong class="lb iu">上的电子邮件地址，那么只有它的副本被改变</strong>。</p><blockquote class="lv lw lx"><p id="a917" class="kz la ly lb b lc ld ju le lf lg jx lh lz lj lk ll ma ln lo lp mb lr ls lt lu im bi translated">*请注意，Swift编译器能够并且将会在幕后进行优化，因此，如果结构足够小，它可能会大规模复制结构，或者如果这是函数需要的全部内容，则<a class="ae ky" href="https://stackoverflow.com/questions/43486408/does-swift-copy-on-write-for-all-structs" rel="noopener ugc nofollow" target="_blank">只复制单个参数</a>。</p><p id="4c91" class="kz la ly lb b lc ld ju le lf lg jx lh lz lj lk ll ma ln lo lp mb lr ls lt lu im bi translated">但是不管实际的实现如何，Swift将保证COW语义，改变A的副本不会影响A。</p></blockquote><h1 id="28eb" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">最佳实践</h1><p id="c920" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">有了结构上的写时复制语义，不可变对象问题就不是Swift中模型的问题了。</p><p id="2273" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">因此，构建纯粹的不可变模型是“最佳实践”的整个前提是，嗯，一个谎言。或者，最好的情况是，误用了在其他平台上编码所固有的问题。</p><p id="ca42" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在Swift中，所有模型更改都是本地的。没有副作用。</p><p id="1823" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">Swift本身提供了我们需要的所有保护。</p><blockquote class="lv lw lx"><p id="f267" class="kz la ly lb b lc ld ju le lf lg jx lh lz lj lk ll ma ln lo lp mb lr ls lt lu im bi translated">注意，这并不是说我们应该默认所有的<code class="fe mz na nb nc b">var</code>。如上所示，将某些字段标记为可变，为开发人员和编译器提供了关于如何使用该对象的重要线索。如果不能或者不应该改变，就不应该这样标注。</p></blockquote><h1 id="bdeb" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">真正的问题是</h1><p id="64c2" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">最初我提到不可变对象试图解决错误的问题，实际上我在前面几节中多次提到这个问题。</p><blockquote class="ol"><p id="1d58" class="om on it bd oo op oq or os ot ou lu dk translated">不可变对象的存在使得未被注意到的变化不会在我们的应用程序中传播。</p></blockquote><p id="a4d7" class="pw-post-body-paragraph kz la it lb b lc ov ju le lf ow jx lh li ox lk ll lm oy lo lp lq oz ls lt lu im bi translated">或者换句话说，如果你知道你的数据不会改变，那么你可以信任它。</p><p id="ea7e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">但是你能相信它吗？</p><p id="660e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我是说，那个电子邮件地址<em class="ly">确实</em>变了。</p><p id="de19" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这是一个问题。实际上，即使在我们最初的实现中，这也是一个问题。</p><pre class="kj kk kl km gt nd nc ne nf aw ng bi"><span id="c4d3" class="nh md it nc b gy ni nj l nk nl">let updatedUser = currentUser.update(emailAddress: email)</span></pre><p id="a48c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">所以现在我们有了一个奇妙的、不可变的对象的副本…我们使用我们神奇的、手工制作的、据说没有错误的更新/复制功能来获得一个新用户，他有一个新更新的电子邮件地址…现在呢？</p><p id="8532" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们有一个带有新电子邮件地址的用户记录的副本…但是其他人没有。</p><h1 id="68cf" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">不可变对象难题</h1><p id="30a3" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">在一个非常真实的意义上，我们已经简单地翻转了我们的不可变对象问题。</p><p id="2506" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">不可变对象和结构写时复制语义确保没有其他人经历数据的意外变化…这很好。但问题是…这些变化需要被看到。</p><p id="2621" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">因为在我们的应用程序中出现的大量错误的存在是因为应用程序的A部分和B部分不同步。</p><p id="7e6f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我有改变…而你没有。我做了改变…你不知道我做了改变。数据变了…但是界面没有变。</p><p id="e11b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">变化发生了。那么我们如何解决这个问题呢？</p><p id="fc75" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">嗯，总会有通知的。但是即使变更通知发生了，我们如何<em class="ly">知道</em>它被正确处理了呢？我们如何确保我们的接口总是用新数据更新？</p><p id="8f55" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们如何知道每个人实际上都在同一页上？</p><p id="dfde" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">但是也有一个解决方案。</p><h1 id="e178" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">真理的单一来源</h1><p id="bad5" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">考虑SwiftUI中围绕一个<code class="fe mz na nb nc b">ObservableObject</code>构建的潜在<code class="fe mz na nb nc b">UserService</code>的以下代码片段。</p><pre class="kj kk kl km gt nd nc ne nf aw ng bi"><span id="49d8" class="nh md it nc b gy ni nj l nk nl">class UserService: ObservableObject {<br/>    @Published fileprivate(set) var user: User?<br/>    ...<br/>}</span></pre><p id="c35c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">注意，我们的用户变量有一个<code class="fe mz na nb nc b">fileprivate(set)</code>访问修饰符。每个人都可以看到用户，但只有服务可以改变它。</p><p id="4e75" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在让我们看看<code class="fe mz na nb nc b">UserService</code>上的一个扩展，它可以让我们更新麻烦的电子邮件地址。</p><pre class="kj kk kl km gt nd nc ne nf aw ng bi"><span id="525e" class="nh md it nc b gy ni nj l nk nl">extension UserService {<br/>    func update(email: String) {<br/>        update { $0.primaryEmail = email }<br/>    }<br/>}</span></pre><p id="f0a9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这里我们调用一个带有clousure的update函数，用它的新值修改电子邮件地址，就这样。实际上，我们只有一行代码就能完成我们想要的。</p><p id="05f3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果我们想要验证电子邮件地址，我们也可以在这里这样做，也许将<code class="fe mz na nb nc b">update(email:)</code>函数标记为<code class="fe mz na nb nc b">throws</code>来处理潜在的错误状态。</p><h1 id="238f" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">更新</h1><p id="43da" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">最后，我们来看看<code class="fe mz na nb nc b">UserService</code>更新函数本身。注意也是<code class="fe mz na nb nc b">fileprivate</code>。只有服务本身的函数可以引用它。</p><pre class="kj kk kl km gt nd nc ne nf aw ng bi"><span id="2645" class="nh md it nc b gy ni nj l nk nl">fileprivate func update(modify: (_ user: inout User) -&gt; Void) {<br/>    guard var user = self.user else { return }<br/>    modify(&amp;user)<br/>    // call API with our modified user and on success...<br/>    self.user = user<br/>}</span></pre><p id="ad95" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在这里，我们获取用户，对其进行修改，然后将其发送到我们的API进行更新。如果成功，我们修改后的用户将被推送到我们发布的值，这反过来通知应用程序的其他部分发生了变化。</p><p id="634e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这有几个好处:</p><ul class=""><li id="b6eb" class="nm nn it lb b lc ld lf lg li no lm np lq nq lu pa ns nt nu bi translated">其余应用程序获得用户的唯一方法是观察有问题的服务。</li><li id="a5ef" class="nm nn it lb b lc nv lf nw li nx lm ny lq nz lu pa ns nt nu bi translated">更新电子邮件地址的唯一方法是与服务人员联系。</li><li id="48e5" class="nm nn it lb b lc nv lf nw li nx lm ny lq nz lu pa ns nt nu bi translated">更新功能确保电子邮件地址——并且<em class="ly">仅</em>电子邮件地址——被更改。</li><li id="7d46" class="nm nn it lb b lc nv lf nw li nx lm ny lq nz lu pa ns nt nu bi translated">更新服务也就更新了发布者，这确保了依赖于该服务的每个视图都得到更新，因此有机会相应地反映这些变化。</li></ul><p id="0695" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这就是我们想要解决的真正的问题:</p><blockquote class="ol"><p id="7dc5" class="om on it bd oo op oq or os ot ou lu dk translated"><strong class="ak">我们应用程序中的一切都保持同步和最新，没有副作用。</strong></p></blockquote><h1 id="dfa3" class="mc md it bd me mf mg mh mi mj mk ml mm jz pb ka mo kc pc kd mq kf pd kg ms mt bi translated">属国</h1><p id="68bf" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">让我们来看一个从属视图。</p><pre class="kj kk kl km gt nd nc ne nf aw ng bi"><span id="8f1b" class="nh md it nc b gy ni nj l nk nl">struct EmailAddressView: View {<br/>    @EnvironmentObject var service: UserService<br/>    var body: some View {<br/>        if let user = service.user {<br/>            Text(user.primaryEmail)<br/>        } else {<br/>            Text("No email address provided.")<br/>        }<br/>    }<br/>}</span></pre><p id="f5e0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在这里，SwiftUI将确保我们的<code class="fe mz na nb nc b">EmailAddressView</code>将始终反映正确的状态。每当数据发生变化时，视图都会更新。自动地。</p><p id="a6d0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这就是单一真理来源背后的力量。</p><h1 id="b5df" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">代码大小</h1><p id="98a2" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">反对不可变对象和样板代码的最后一个要点在于代码大小和构建时间。</p><p id="bf0f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">同样，更多的代码就是更多的代码。必须编写的代码。必须测试的代码。需要编译的代码和需要链接的代码。影响应用程序代码大小的代码。</p><p id="4df3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">一个不可变的<code class="fe mz na nb nc b">User</code>对象会成为问题吗？当然不是。</p><p id="9175" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">但是如果你是在不可变对象的马车上，那么我们不仅仅是在谈论一个对象，对吗？</p><h1 id="6f0d" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">多重变化</h1><p id="69aa" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">我以前和几个人讨论过这个问题，讨论中经常出现的一个问题是，对于多个变量，如果一些函数猴子发现并更改了除电子邮件地址之外的几个值，该怎么办？</p><p id="bdd3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">对此我的回应是…如果他们这样做了又怎么样？</p><p id="fd42" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">按照演示的服务设置，没有办法将随机变异的用户发送到应用程序的其余部分或API。到通用更新机制的所有路由都被阻塞。</p><p id="c701" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">此外，即使是原始的“不可变”对象，也完全有可能进行多次修改。</p><pre class="kj kk kl km gt nd nc ne nf aw ng bi"><span id="73d0" class="nh md it nc b gy ni nj l nk nl">let updatedUser = user.update(email: email).update(phone: phone)</span></pre><p id="129a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">最后，除非您想围绕不可变对象编写更多的样板代码，否则没有什么可以阻止人们按照自己的意愿用自己的值来构造自己的对象。</p><p id="3cf8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">没错，所有这些都是基于适当地构建您的架构…但话说回来，这也是我们在这里的原因，对吗？</p><h1 id="1540" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">完成块</h1><p id="95ba" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">今天就到这里吧。</p><p id="4493" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">至少我希望我已经给了你一些思考的食粮，特别是关于盲目地向Swift推广和宣传其他语言所要求的一些“最佳实践”。</p><p id="4a46" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">它根本不需要它们。</p><p id="cf57" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">当您评估应用程序方法和架构时，请确保退一步问自己:</p><ol class=""><li id="8610" class="nm nn it lb b lc ld lf lg li no lm np lq nq lu nr ns nt nu bi translated">我想解决什么问题？</li><li id="53cb" class="nm nn it lb b lc nv lf nw li nx lm ny lq nz lu nr ns nt nu bi translated">这种方法解决了吗？</li><li id="6487" class="nm nn it lb b lc nv lf nw li nx lm ny lq nz lu nr ns nt nu bi translated">这种方法给我带来的工作是多了还是少了？</li></ol><p id="9868" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">最后，但同样重要的是:</p><p id="69ad" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">4.这会让我写更多的样板代码吗？？？</p><p id="cb6f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">同意，不同意？不管怎样，让我知道你的想法。</p></div></div>    
</body>
</html>