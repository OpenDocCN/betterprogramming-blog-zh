<html>
<head>
<title>8 Miraculous Ways to Bolster Your React Apps</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">增强React应用的8种神奇方法</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/8-miraculous-ways-to-bolster-your-react-apps-80a5040143a3?source=collection_archive---------3-----------------------#2019-08-25">https://betterprogramming.pub/8-miraculous-ways-to-bolster-your-react-apps-80a5040143a3?source=collection_archive---------3-----------------------#2019-08-25</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="7d7f" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">如果可以的话，让React做更少的工作</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/b1e04c83767629b9c6bc5acb0f263aad.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*1dYMnUjzavoZXEpO.jpg"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated"><em class="ky">照片由Tarn Nguyen在Unsplash上拍摄</em></p></figure><p id="d3ec" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">有时，当我们在React中构建应用程序时，我们可能会错过改进应用程序的机会，这可能是因为，当我们的应用程序刚刚<em class="lv">工作</em>并且<em class="lv">感觉</em>快时，我们容忍它是完美的。</p><p id="9e92" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">作为开发人员，我们可能会假设，如果我们的项目的结果对我们来说是正常的，那么对用户来说也是正常的。当我们这样思考时，这可能会导致我们忽略代码中可以优化以获得更好结果的区域。</p><p id="b108" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这篇文章将从八个方面来支持你的React应用。</p></div><div class="ab cl lw lx hx ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="im in io ip iq"><h1 id="d2cb" class="md me it bd mf mg mh mi mj mk ml mm mn jz mo ka mp kc mq kd mr kf ms kg mt mu bi translated">1.热爱你们的身份</h1><p id="d3a0" class="pw-post-body-paragraph kz la it lb b lc mv ju le lf mw jx lh li mx lk ll lm my lo lp lq mz ls lt lu im bi translated">支持React应用的第一个方法是热爱你的身份。</p><p id="10c6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">重要的是要记住，你可以用<code class="fe na nb nc nd b">React.useMemo</code>包装变量和函数，因为你可以授予它们记忆自己的能力，以便React知道它们在未来的渲染中保持不变。</p><p id="57b1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">否则，如果不记住它们，它们的引用将从未来的渲染中消失。这可能会伤害他们的感情，所以你可以向他们表示你爱他们，并希望通过纪念他们来留住他们。</p><p id="7846" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果你爱他们，他们会回报你，确保他们照顾你和你的应用，帮助避免他们所处情况下的浪费操作。</p><p id="0569" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">例如，让我们假设我们正在制作一个定制的钩子，它接受一系列的<code class="fe na nb nc nd b">urls</code>作为参数，这样它就可以把它们累积成一个承诺数组，用<code class="fe na nb nc nd b">Promise.all</code>来解析。</p><p id="2b0a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">一旦完成，结果将被插入到状态中并传递给<code class="fe na nb nc nd b">App</code>组件。我们的承诺列表将映射到包含四个要获取的不同URL的<code class="fe na nb nc nd b">urls</code>数组:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ne nf l"/></div></figure><p id="d63f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们的任务是从这四个链接中获取数据，所以，理想情况下，应该只发出四个请求。</p><p id="cf61" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">但是，如果我们看一看<em class="lv"> Chrome </em>内部的<em class="lv">网络标签</em>，事实是它发出了八个请求。</p><p id="44a6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这是因为<code class="fe na nb nc nd b">urls</code>参数没有<em class="lv">而不是</em>保持与之前相同的身份，因为当<code class="fe na nb nc nd b">App</code>重新呈现时，它每次都实例化一个新的数组，所以React将其视为一个已更改的值。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi ng"><img src="../Images/4e68da7037fd0e29aa3427dc4457f960.png" data-original-src="https://miro.medium.com/v2/resize:fit:1330/format:webp/0*n6CNI2xwY7Z15RiZ.jpg"/></div></figure><p id="449e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">计算机程序有时认为他们可以智胜我们，并摆脱这种糟糕的行为。</p><p id="0981" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">为了解决这个问题，我们可以使用<code class="fe na nb nc nd b">React.useMemo</code>，这样只要包含URL的数组不改变，promises数组就不会在每次渲染<em class="lv">时重新计算自己。</em></p><p id="22e3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们重构代码来应用这个概念:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ne nf l"/></div></figure><p id="8ffc" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果我们现在运行它，它仍然会发送八个请求。这是因为，尽管我们记忆了<code class="fe na nb nc nd b">urls</code>数组，但我们也需要记忆钩子内部的<code class="fe na nb nc nd b">promises</code>变量，因为每当钩子运行时，它也会实例化自己:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ne nf l"/></div></figure><p id="e344" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们的代码现在在运行时应该只发送四个请求。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nh"><img src="../Images/763080142de8eafb91d4954cdea0b041.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*3aU686ay90XYKUrq.jpg"/></div></div></figure></div><div class="ab cl lw lx hx ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="im in io ip iq"><h1 id="7768" class="md me it bd mf mg mh mi mj mk ml mm mn jz mo ka mp kc mq kd mr kf ms kg mt mu bi translated">2.将道具合并到孩子</h1><p id="c553" class="pw-post-body-paragraph kz la it lb b lc mv ju le lf mw jx lh li mx lk ll lm my lo lp lq mz ls lt lu im bi translated">有时我们会遇到这样的情况，我们想在渲染之前偷偷放入一个道具与孩子融合在一起。React允许你查看任何React元素的属性，以及其他属性，比如暴露它的<code class="fe na nb nc nd b">key</code>。</p><p id="ef61" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们可以用一个新的组件包装子元素，并从那里注入新的道具，或者我们可以使用这种方法合并新的道具。</p><p id="2423" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">例如，假设我们有一个使用<code class="fe na nb nc nd b">useModal</code>钩子的<code class="fe na nb nc nd b">App</code>组件，它通过提供<code class="fe na nb nc nd b">open</code>、<code class="fe na nb nc nd b">close</code>和<code class="fe na nb nc nd b">opened</code>这样的控件来提供一些方便的工具来管理模态。</p><p id="194b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们希望将这些道具传递给一个<code class="fe na nb nc nd b">VisibilityControl</code>组件，因为它将在将模态数据传递给子组件之前提供额外的功能:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ne nf l"/></div></figure><p id="d3dc" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe na nb nc nd b">VisibilityControl</code>确保<code class="fe na nb nc nd b">activated</code>为<code class="fe na nb nc nd b">true</code>后，才允许<code class="fe na nb nc nd b">opened</code>被其子节点正常使用。</p><p id="da83" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果在秘密路线中使用，则<code class="fe na nb nc nd b">VisibilityControl</code>提供防止未激活用户看到秘密内容的功能。</p></div><div class="ab cl lw lx hx ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="im in io ip iq"><h1 id="6b90" class="md me it bd mf mg mh mi mj mk ml mm mn jz mo ka mp kc mq kd mr kf ms kg mt mu bi translated">3.巨型减速器组合减速器</h1><p id="0ec8" class="pw-post-body-paragraph kz la it lb b lc mv ju le lf mw jx lh li mx lk ll lm my lo lp lq mz ls lt lu im bi translated">可能会有一段时间，你需要在应用程序中组合两个或更多的减速器，使一个更大的。这种方法类似于<a class="ae ni" href="https://react-redux.js.org/" rel="noopener ugc nofollow" target="_blank">中<code class="fe na nb nc nd b">combineReducers</code>的工作方式。</a></p><p id="d8a2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们假设我们计划制作一个巨大的微服务应用程序，我们最初计划指定应用程序中的每个部分负责它们自己的上下文/状态。</p><p id="9eb9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">但是，后来，我们想到了一个价值百万美元的应用程序，它要求各州联合成一个大州，这样我们就可以在同一个环境中管理它们。</p><p id="35f8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们有一个<code class="fe na nb nc nd b">authReducer.js</code>、<code class="fe na nb nc nd b">ownersReducer.js</code>和<code class="fe na nb nc nd b">frogsReducer.js</code>，我们希望将它们结合起来:</p><p id="ce6e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe na nb nc nd b">authReducer.js</code></p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ne nf l"/></div></figure><p id="7df6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe na nb nc nd b">ownersReducer.js</code></p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ne nf l"/></div></figure><p id="10e9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe na nb nc nd b">frogsReducer.js</code></p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ne nf l"/></div></figure><p id="b249" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们将它们导入到主文件中，并在那里定义状态结构:</p><p id="5783" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe na nb nc nd b">App.js</code></p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ne nf l"/></div></figure><p id="6bf7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">然后您可以像平常一样使用钩子，调用<code class="fe na nb nc nd b">dispatch</code>，传入匹配的<code class="fe na nb nc nd b">type</code>，以及指定的reducer的参数。</p><p id="18d7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">最重要的部分要看的是<code class="fe na nb nc nd b">rootReducer</code>:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ne nf l"/></div></figure></div><div class="ab cl lw lx hx ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="im in io ip iq"><h1 id="e712" class="md me it bd mf mg mh mi mj mk ml mm mn jz mo ka mp kc mq kd mr kf ms kg mt mu bi translated">4.错误报告的哨兵</h1><p id="5557" class="pw-post-body-paragraph kz la it lb b lc mv ju le lf mw jx lh li mx lk ll lm my lo lp lq mz ls lt lu im bi translated">当与React集成时，项目从<a class="ae ni" href="https://docs.sentry.io/platforms/javascript/react/" rel="noopener ugc nofollow" target="_blank"> Sentry </a>中受益匪浅。将详细的错误报告发送到一个中心位置进行分析是一个非常重要的工具！</p><p id="33cb" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">一旦你<code class="fe na nb nc nd b">npm install @sentry/browser</code>并为你的React应用程序设置好，你就可以在创建你的帐户并在你项目的仪表板中分析你的错误报告后登录<a class="ae ni" href="https://sentry.io/" rel="noopener ugc nofollow" target="_blank"> sentry.io </a>。</p><p id="071c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这些报告非常详细，因此您将从大量信息中受益，这些信息有助于您解决错误，例如了解用户的设备、浏览器、发生错误的URL、用户的IP地址、错误的堆栈跟踪、错误是否得到处理、函数名称、源代码、显示导致错误的网络操作跟踪的有用的面包屑列表、标题等等。</p><p id="2d0c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">下面是这可能看起来像什么的截图:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nj"><img src="../Images/12b6e372cbcfd4b310b59a571b3f57f1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*vS8yS0vVUJMiRUPp.jpg"/></div></div></figure><p id="d1e5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">你也可以让几个团队成员对不同的事情发表意见，这样就可以形成一个协作的环境。</p></div><div class="ab cl lw lx hx ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="im in io ip iq"><h1 id="5b4d" class="md me it bd mf mg mh mi mj mk ml mm mn jz mo ka mp kc mq kd mr kf ms kg mt mu bi translated">5.在window.fetch上使用axios</h1><p id="d58e" class="pw-post-body-paragraph kz la it lb b lc mv ju le lf mw jx lh li mx lk ll lm my lo lp lq mz ls lt lu im bi translated">除非你不关心Internet Explorer用户，否则你应该<em class="lv">不要</em>为你的React应用程序使用<code class="fe na nb nc nd b">window.fetch</code>，因为没有一个IE浏览器支持<code class="fe na nb nc nd b">window.fetch</code>，除非你提供一个polyfill。</p><p id="8985" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">Axios 很好地支持了IE，同时也带来了额外的功能，比如中途取消请求。这个<code class="fe na nb nc nd b">window.fetch</code>其实适用于任何web app，并不是专门针对React的。</p><p id="dfca" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">它出现在这个列表中的原因是今天在React应用程序中使用<code class="fe na nb nc nd b">window.fetch</code>并不罕见。随着React应用程序经历传输/编译阶段，根据所配置的工具，很容易意外地认为它是传输的<code class="fe na nb nc nd b">window.fetch</code>。</p></div><div class="ab cl lw lx hx ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="im in io ip iq"><h1 id="4d79" class="md me it bd mf mg mh mi mj mk ml mm mn jz mo ka mp kc mq kd mr kf ms kg mt mu bi translated">6.监视DOM节点时，使用回调引用而不是对象引用</h1><p id="1c46" class="pw-post-body-paragraph kz la it lb b lc mv ju le lf mw jx lh li mx lk ll lm my lo lp lq mz ls lt lu im bi translated">尽管<code class="fe na nb nc nd b">React.useRef</code>是附加和控制对DOM节点的引用的新手，但它并不总是最好的选择。</p><p id="c259" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">有时，您可能需要对DOM节点进行更多的控制，以便提供额外的功能。</p><p id="e7fc" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">例如，<a class="ae ni" href="https://reactjs.org/docs/hooks-faq.html#how-can-i-measure-a-dom-node" rel="noopener ugc nofollow" target="_blank"> React docs </a>展示了这样一种情况，您需要使用回调ref来确保，即使当前ref值发生了变化，外部的组件仍然可以得到更新通知。这就是回调引用相对于<code class="fe na nb nc nd b">useRef</code>的优势。</p><p id="2806" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">Material-ui利用这个强大的概念在组件模块中附加额外的功能。最棒的是，这种行为中自然会出现清理。精彩！</p></div><div class="ab cl lw lx hx ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="im in io ip iq"><h1 id="4963" class="md me it bd mf mg mh mi mj mk ml mm mn jz mo ka mp kc mq kd mr kf ms kg mt mu bi translated">7.<code class="fe na nb nc nd b">useWhyDidYouUpdate</code></h1><p id="139b" class="pw-post-body-paragraph kz la it lb b lc mv ju le lf mw jx lh li mx lk ll lm my lo lp lq mz ls lt lu im bi translated">这是一个自定义的钩子，用来暴露使我们的组件重新呈现的变化。</p><p id="c331" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">有时，当像高阶组件<code class="fe na nb nc nd b">React.memo</code>这样的记忆器不够用时，你可以使用这个方便的钩子来找到你需要考虑记忆的道具:(归功于布鲁诺·莱默斯。)</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ne nf l"/></div></figure><p id="8fde" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">你可以这样使用它:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ne nf l"/></div></figure></div><div class="ab cl lw lx hx ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="im in io ip iq"><h1 id="207d" class="md me it bd mf mg mh mi mj mk ml mm mn jz mo ka mp kc mq kd mr kf ms kg mt mu bi translated">8.让你的功能找到你</h1><p id="6a02" class="pw-post-body-paragraph kz la it lb b lc mv ju le lf mw jx lh li mx lk ll lm my lo lp lq mz ls lt lu im bi translated">这将引用以前的一篇文章，因为它有点长，非常适合这篇文章。以下是内容:</p><p id="1ee3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我举一个现实生活中的例子，因为我想多强调一下这个例子。</p><p id="bd7c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">高阶函数最大的好处之一是，如果使用正确，它会为你和你周围的人节省很多时间。</p><p id="54f3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在我的工作中，我们使用<a class="ae ni" href="https://github.com/fkhadra/react-toastify" rel="noopener ugc nofollow" target="_blank">React-to-stify</a>来显示通知。我们到处都用它。此外，他们还为UX最后一分钟的快速决策提供了绝佳的逃生通道。</p><p id="9bb7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们应该如何处理这个错误？只显示一个祝酒通知！完成了。</p><p id="2f72" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">然而，我们开始注意到，当应用程序变得越来越大，复杂程度越来越高时，我们的Toast通知变得过于频繁。</p><p id="6166" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这很好，但是，我们没有办法防止重复。这意味着一些Toast通知会在屏幕上显示多次，即使它们与上面的Toast完全相同。</p><p id="2dbe" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">因此，我们最终利用该库提供的API，通过使用<code class="fe na nb nc nd b">toast.dismiss()</code>的<code class="fe na nb nc nd b">id</code>来帮助删除活动的Toast通知。</p><p id="b146" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">为了解释前面的部分，在继续之前，显示我们从中导入祝酒词的文件可能是个好主意:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ne nf l"/></div></figure><p id="d899" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">听我说，我知道这看起来不太吸引人。但我保证两分钟后会好的。</p><p id="75ba" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这是我们在一个单独的组件中用来检查之前的Toast是否已经在屏幕上。如果是，它将尝试移除该Toast并重新显示新Toast。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ne nf l"/></div></figure><p id="6bdb" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这工作得很好，但是，我们在整个应用程序中有其他祝酒词需要以同样的方式修改。我们不得不仔细检查每一个显示Toast通知的文件来删除重复的文件。</p><p id="fafb" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">当我们想到在2019年检查每一个文件时，我们立即知道这不是解决方案。因此，我们查看了<code class="fe na nb nc nd b">util/toast.js</code>文件并重构它来解决我们的问题。</p><p id="5227" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这是后来的样子:</p><p id="7700" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe na nb nc nd b">src/util/toast.js</code></p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ne nf l"/></div></figure><p id="4f48" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">最简单的解决方案是创建一个高阶函数，而不是遍历每个文件。这样做可以让我们“颠倒”角色，这样，我们就不用搜索文件，而是将祝酒词指向我们的高阶函数。</p><p id="abcd" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这样，文件中的代码就不会被修改或改动。它们仍然正常工作，我们获得了删除重复祝酒词的能力，最终不用去任何地方写不必要的代码。这节省了时间。</p><p id="c7b2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">而这就是本文的结尾！我希望你觉得它有用，并期待在未来更多。</p></div></div>    
</body>
</html>