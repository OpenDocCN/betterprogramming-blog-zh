<html>
<head>
<title>Test Controllers in NestJS + Mongo With Jest</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">用Jest测试NestJS + Mongo中的控制器</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/testing-controllers-in-nestjs-and-mongo-with-jest-63e1b208503c?source=collection_archive---------1-----------------------#2022-05-02">https://betterprogramming.pub/testing-controllers-in-nestjs-and-mongo-with-jest-63e1b208503c?source=collection_archive---------1-----------------------#2022-05-02</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="e847" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">在使用MongoDB和Mongoose时，如何使用Jest为您的NestJS控制器规划和编写可靠的单元测试</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/287709cca155e20a46cec929fad0d0a0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*CE-ZJqYSjZfYsUUk67P3GQ.png"/></div></div></figure><p id="65ef" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">在本文中，通过示例，您将了解到在使用MongoDB和Mongoose时，如何使用Jest为您的NestJS控制器规划和编写可靠的单元测试。这里使用的大多数测试技术都可以在没有NestJS的情况下应用，使用其他DBMS(数据库管理系统)甚至使用Jest以外的测试库！这里使用它们是因为它们的相关性以及它们简化了多少工作。</p><p id="b74e" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">在开始编写代码之前，让我们先快速浏览一下所使用的主要库(用NPM安装它们)。</p></div><div class="ab cl ln lo hu lp" role="separator"><span class="lq bw bk lr ls lt"/><span class="lq bw bk lr ls lt"/><span class="lq bw bk lr ls"/></div><div class="ij ik il im in"><h1 id="e20d" class="lu lv iq bd lw lx ly lz ma mb mc md me jw mf jx mg jz mh ka mi kc mj kd mk ml bi translated">NestJS</h1><p id="1200" class="pw-post-body-paragraph kr ks iq kt b ku mm jr kw kx mn ju kz la mo lc ld le mp lg lh li mq lk ll lm ij bi translated">Node.js框架，用于使用JavaScript或更好的TypeScript编写服务器端应用程序。<a class="ae mr" href="https://nestjs.com/" rel="noopener ugc nofollow" target="_blank"> NestJS </a>通过提供自己的开箱即用的应用架构模式，简化了开发的架构部分，旨在提供可伸缩性、解耦性、易维护性，当然，还有可测试性。NPM的NestJS核心每周下载量持续增长，上周下载量超过130万次。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi ms"><img src="../Images/67d021e019b4fb977e7393fd893eba64.png" data-original-src="https://miro.medium.com/v2/resize:fit:738/format:webp/1*FmTClitLyiIiDqB-JcOYbA.png"/></div></figure><h1 id="478c" class="lu lv iq bd lw lx mt lz ma mb mu md me jw mv jx mg jz mw ka mi kc mx kd mk ml bi translated">蒙戈</h1><p id="aff0" class="pw-post-body-paragraph kr ks iq kt b ku mm jr kw kx mn ju kz la mo lc ld le mp lg lh li mq lk ll lm ij bi translated">我用“mongo”指代<a class="ae mr" href="https://www.mongodb.com/" rel="noopener ugc nofollow" target="_blank">MongoDB</a>+<a class="ae mr" href="https://mongoosejs.com/" rel="noopener ugc nofollow" target="_blank">mongose</a>+<a class="ae mr" href="https://github.com/nodkz/mongodb-memory-server" rel="noopener ugc nofollow" target="_blank">MongoDB内存服务器</a>。MongoDB是一个高性能的NoSQL DBMS，它将数据存储为类似JSON格式的文档。Mongoose是一个JavaScript对象建模库，它使得与MongoDB的交互更加容易和安全。MongoDB内存服务器是一个库，它从Node.js中以编程方式启动一个真实的MongoDB服务器。</p><h1 id="0fbf" class="lu lv iq bd lw lx mt lz ma mb mu md me jw mv jx mg jz mw ka mi kc mx kd mk ml bi translated">玩笑</h1><p id="f5d7" class="pw-post-body-paragraph kr ks iq kt b ku mm jr kw kx mn ju kz la mo lc ld le mp lg lh li mq lk ll lm ij bi translated">Jest 是一个完整的JavaScript测试框架，由Meta(以前的脸书)开发，关注简单性和性能(例如，测试并行运行)。NPM的Jest weekly下载量持续增长，上周下载量超过1730万次。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi my"><img src="../Images/79674701084eba74613d8d03af6d2dd9.png" data-original-src="https://miro.medium.com/v2/resize:fit:728/format:webp/1*K4jjNhQKyPQ8SJNTfFQG6Q.png"/></div></figure></div><div class="ab cl ln lo hu lp" role="separator"><span class="lq bw bk lr ls lt"/><span class="lq bw bk lr ls lt"/><span class="lq bw bk lr ls"/></div><div class="ij ik il im in"><h1 id="ed47" class="lu lv iq bd lw lx ly lz ma mb mc md me jw mf jx mg jz mh ka mi kc mj kd mk ml bi translated">实施目标</h1><p id="21e7" class="pw-post-body-paragraph kr ks iq kt b ku mm jr kw kx mn ju kz la mo lc ld le mp lg lh li mq lk ll lm ij bi translated">我们希望在本指南中实现和测试什么？我们将在NestJS控制器中实现并测试两个端点。一个GET端点映射到一个名为<code class="fe mz na nb nc b"><em class="nd">getArticle</em></code>的方法，一个POST端点映射到一个名为<code class="fe mz na nb nc b"><em class="nd">postArticle</em></code>的方法。</p><p id="d56c" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">这里使用的代码和项目结构被简化，以集中于测试方面。如果您想在更完整的项目环境中看到更多的测试和代码，请参考下面的GitHub资源库:</p><div class="ne nf gp gr ng nh"><a href="https://github.com/vsdepontes/space-flight-news-backend-node" rel="noopener  ugc nofollow" target="_blank"><div class="ni ab fo"><div class="nj ab nk cl cj nl"><h2 class="bd ir gy z fp nm fr fs nn fu fw ip bi translated">GitHub-vsdepontes/太空飞行-新闻-后端-节点:后端挑战2021🏅-太空飞行新闻</h2><div class="no l"><h3 class="bd b gy z fp nm fr fs nn fu fw dk translated">这是由Coodesh后端服务为Coodesh“后端挑战2021”发起的挑战🏅——太空飞行新闻”。的…</h3></div><div class="np l"><p class="bd b dl z fp nm fr fs nn fu fw dk translated">github.com</p></div></div><div class="nq l"><div class="nr l ns nt nu nq nv kp nh"/></div></div></a></div><p id="2ad4" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">这是来自库德什的挑战。简单来说，目的是使一个API能够接口对航天新闻文章数据库的CRUD(创建、读取、更新和删除)操作。</p><h1 id="ca33" class="lu lv iq bd lw lx mt lz ma mb mu md me jw mv jx mg jz mw ka mi kc mx kd mk ml bi translated">从哪里开始？</h1><p id="fcc4" class="pw-post-body-paragraph kr ks iq kt b ku mm jr kw kx mn ju kz la mo lc ld le mp lg lh li mq lk ll lm ij bi translated">你将如何开始编写代码和测试？如果你已经完成了你的代码，很好！你可以写你的测试。但是我想快速地谈谈一个被称为测试驱动开发(TDD)的良好实践。</p><p id="eed8" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">在TDD中，我们遵循以下三条规则:</p><p id="3be3" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">1-在编写确保正确行为的单元测试之前，您不应该编写任何生产代码。</p><p id="90b7" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">2-你不应该写太多的测试，以免失败。</p><p id="f8cc" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">3-你不应该写多于足够通过测试的产品代码。</p><p id="2b02" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">这些规则引导我们进入以下工作流程:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nw"><img src="../Images/6b0c2c86de2003edfee8c125c85f29bd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*1x6xhw3hM_0CImcd7kzU9Q.png"/></div></div><p class="nx ny gj gh gi nz oa bd b be z dk translated">TDD工作流程</p></figure><p id="5b7a" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">首先，我们编写测试来确保我们想要实现的算法的正确行为(“使用<em class="nd"> X </em>输入，异常、错误或预期结果是<em class="nd"> Y </em>”)。然后，我们编写足够通过测试的代码。最后，当我们改进代码时，我们回到第一步，一个循环就产生了。</p><p id="d03e" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">直接回答题目中的问题，我们就从测试开始。</p><h1 id="6363" class="lu lv iq bd lw lx mt lz ma mb mu md me jw mv jx mg jz mw ka mi kc mx kd mk ml bi translated">计划测试</h1><p id="887f" class="pw-post-body-paragraph kr ks iq kt b ku mm jr kw kx mn ju kz la mo lc ld le mp lg lh li mq lk ll lm ij bi translated">这一部分的重要性怎么强调都不为过。如果我们错误地计划我们的测试，我们的代码也会出错，从而使我们浪费时间和精力。</p><p id="a0a6" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">测试应该反映您正在尝试实现的特性/功能的需求。另一个人必须能够知道你的代码接受什么作为输入，它给出什么作为输出，以及它何时以及如何失败。测试是对你的代码最好的文档。</p><p id="2fc8" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">我们的<code class="fe mz na nb nc b"><em class="nd">postArticle</em></code> <em class="nd"> </em>方法必须接收一篇文章作为参数，并返回该文章的已保存版本或一个异常，以防已经保存了另一篇同名文章。<code class="fe mz na nb nc b"><em class="nd">getArticle</em></code> <em class="nd"> </em>方法必须接收一个标题作为参数，并返回带有相应标题或<code class="fe mz na nb nc b"><em class="nd">null</em></code>的文章。这些是我们将要测试的行为。</p><p id="ff6e" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated"><em class="nd">注意:这里我们将使用文章的标题(字符串)作为标识符，但是更好的方法是使用自己的数据库id(通常是正整数)。</em></p><h1 id="eee7" class="lu lv iq bd lw lx mt lz ma mb mu md me jw mv jx mg jz mw ka mi kc mx kd mk ml bi translated">准备基础</h1><h2 id="c486" class="ob lv iq bd lw oc od dn ma oe of dp me la og oh mg le oi oj mi li ok ol mk om bi translated">控制器、模块和服务</h2><p id="08e0" class="pw-post-body-paragraph kr ks iq kt b ku mm jr kw kx mn ju kz la mo lc ld le mp lg lh li mq lk ll lm ij bi translated">要从头开始，您的控制器、模块和服务文件应该如下所示:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="on oo l"/></div></figure><p id="43c4" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">当您使用Nest CLI创建它们时，NestJS可能已经在您的控制器和服务文件中放入了一些简单的方法，但是如果是这样的话，请删除它们和它们的依赖项。</p><h2 id="6a76" class="ob lv iq bd lw oc od dn ma oe of dp me la og oh mg le oi oj mi li ok ol mk om bi translated">这篇文章</h2><p id="5b78" class="pw-post-body-paragraph kr ks iq kt b ku mm jr kw kx mn ju kz la mo lc ld le mp lg lh li mq lk ll lm ij bi translated">我们希望将文章保存到数据库中，但是文章到底是什么？我们必须确定文章的结构。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="on oo l"/></div></figure><p id="8e99" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">因为我们还想在MongoDB数据库中持久化(保存)文章，所以我们必须创建相应的MongoDB模式。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="on oo l"/></div></figure><h2 id="ae8b" class="ob lv iq bd lw oc od dn ma oe of dp me la og oh mg le oi oj mi li ok ol mk om bi translated">存根</h2><p id="b717" class="pw-post-body-paragraph kr ks iq kt b ku mm jr kw kx mn ju kz la mo lc ld le mp lg lh li mq lk ll lm ij bi translated">测试时，我们使用“存根”。这些是我们在测试时将要使用的对象的实例，具有预定义的值。在项目的根目录下创建一个名为“test”的文件夹，并在其中保存一个名为“stubs”的子文件夹，这是一个很好的做法。</p><p id="6d33" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">因为我们需要一个文章的实例来测试我们的代码，所以让我们创建一个文章存根。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="on oo l"/></div></figure><p id="8ab8" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">注意，我们正在导出一个名为<code class="fe mz na nb nc b"><em class="nd">ArticleSTOStub</em></code>的<code class="fe mz na nb nc b"><em class="nd">ArticleDTO</em></code> <em class="nd"> </em>的实例，它具有预定义的值。</p><h2 id="0b89" class="ob lv iq bd lw oc od dn ma oe of dp me la og oh mg le oi oj mi li ok ol mk om bi translated">例外</h2><p id="565c" class="pw-post-body-paragraph kr ks iq kt b ku mm jr kw kx mn ju kz la mo lc ld le mp lg lh li mq lk ll lm ij bi translated">当有人试图保存一篇标题重复的文章时，我们想要返回一个异常，所以我们写这个异常。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="on oo l"/></div></figure><p id="ccbb" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">我们将其命名为<code class="fe mz na nb nc b"><em class="nd">ArticleAlreadyExists</em></code> <em class="nd">，</em>定义了一个自定义错误消息(“文章已经存在！”)并将HTTP响应代码设置为400(错误请求)<em class="nd">。</em></p><h2 id="05de" class="ob lv iq bd lw oc od dn ma oe of dp me la og oh mg le oi oj mi li ok ol mk om bi translated">数据库连接</h2><p id="301c" class="pw-post-body-paragraph kr ks iq kt b ku mm jr kw kx mn ju kz la mo lc ld le mp lg lh li mq lk ll lm ij bi translated">为了建立与数据库的连接，我们可以在控制器中做这样的事情:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="on oo l"/></div></figure><p id="37c5" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">基本上，我们用<code class="fe mz na nb nc b"><em class="nd">MongooseModule</em></code>通过<code class="fe mz na nb nc b"><em class="nd">forFeature</em></code> <em class="nd"> </em>方法传递我们的模式，用<code class="fe mz na nb nc b"><em class="nd">forRoot</em> </code>方法传递MongoDB连接URI。注意，这里我们通过一个环境变量来传递我们的连接URI，以避免在我们的代码中将其作为字符串公开。</p><h1 id="d86d" class="lu lv iq bd lw lx mt lz ma mb mu md me jw mv jx mg jz mw ka mi kc mx kd mk ml bi translated">编写测试</h1><h2 id="ffca" class="ob lv iq bd lw oc od dn ma oe of dp me la og oh mg le oi oj mi li ok ol mk om bi translated">测试文件的基础</h2><p id="65f6" class="pw-post-body-paragraph kr ks iq kt b ku mm jr kw kx mn ju kz la mo lc ld le mp lg lh li mq lk ll lm ij bi translated">首先，让我们创建测试文件。如果NestJS已经为您创建了一个，请删除它并跟随我们。在单元测试的情况下，在与要测试的代码相同的文件夹中创建测试文件，并通过附加<em class="nd">来命名它。spec </em>带有要测试代码的文件名的后缀。Jest在默认情况下也需要这些约定。所以，如果控制器被称为<code class="fe mz na nb nc b"><em class="nd">app.controller.ts</em></code>，测试文件将被称为<code class="fe mz na nb nc b"><em class="nd">app.controller.spec.ts</em></code>，并且应该在同一个文件夹中。</p><p id="f198" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">创建好文件后，让我们开始编写一些代码。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="on oo l"/></div></figure><blockquote class="op oq or"><p id="393c" class="kr ks nd kt b ku kv jr kw kx ky ju kz os lb lc ld ot lf lg lh ou lj lk ll lm ij bi translated"><em class="iq">第1行:我们从</em> <code class="fe mz na nb nc b">@nestjs/testing</code> <em class="iq">中导入了一个名为</em> <code class="fe mz na nb nc b">Test</code> <em class="iq">的类和一个名为</em> <code class="fe mz na nb nc b">TestingModule</code> <em class="iq">的类型。</em></p><p id="a52c" class="kr ks nd kt b ku kv jr kw kx ky ju kz os lb lc ld ot lf lg lh ou lj lk ll lm ij bi translated">第2行:我们导入了想要测试的控制器。</p><p id="cdac" class="kr ks nd kt b ku kv jr kw kx ky ju kz os lb lc ld ot lf lg lh ou lj lk ll lm ij bi translated"><em class="iq">第3行:我们导入了控制器使用/依赖的服务。</em></p><p id="161d" class="kr ks nd kt b ku kv jr kw kx ky ju kz os lb lc ld ot lf lg lh ou lj lk ll lm ij bi translated"><em class="iq">第6行:Jest中的</em> <code class="fe mz na nb nc b">describe</code> <em class="iq">创建了一个测试块，并让您传递一个字符串作为参数，以表明它们的一般用途。既然我们想测试我们的</em> <code class="fe mz na nb nc b">AppController</code> <em class="iq">，我们就写它吧。</em></p><p id="cfd1" class="kr ks nd kt b ku kv jr kw kx ky ju kz os lb lc ld ot lf lg lh ou lj lk ll lm ij bi translated"><em class="iq">第7行:很快，我们将实例化我们的控制器，以便访问它的方法(</em> <code class="fe mz na nb nc b">postArticle</code> <em class="iq">和</em> <code class="fe mz na nb nc b">getArticle</code> <em class="iq">)，但是让我们在这个块的全局作用域中声明它，以便我们可以在任何测试中引用我们的控制器(因为每个测试都是块中有自己作用域的函数)。</em></p><p id="69ff" class="kr ks nd kt b ku kv jr kw kx ky ju kz os lb lc ld ot lf lg lh ou lj lk ll lm ij bi translated"><em class="iq">第9行:Jest中的</em> <code class="fe mz na nb nc b"><em class="iq">beforeAll</em></code> <em class="iq">创建了一个代码块，它将在任何测试之前运行。</em></p><p id="fc91" class="kr ks nd kt b ku kv jr kw kx ky ju kz os lb lc ld ot lf lg lh ou lj lk ll lm ij bi translated"><em class="iq">第10–15行:我们编译我们的应用程序(</em> <code class="fe mz na nb nc b">app</code> <em class="iq">)，传递我们想要测试的控制器和它需要的提供者。</em></p><p id="2db5" class="kr ks nd kt b ku kv jr kw kx ky ju kz os lb lc ld ot lf lg lh ou lj lk ll lm ij bi translated"><em class="iq">第16行:从我们编译的</em> <code class="fe mz na nb nc b">app</code> <em class="iq">中得到我们需要的控制器的实例(</em> <code class="fe mz na nb nc b">appController</code> <em class="iq">)。</em></p></blockquote><p id="46d5" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">如果您在您的终端中编写<code class="fe mz na nb nc b"><em class="nd">jest</em></code>并按回车键运行，您会看到一个错误，但是如果您仔细阅读(总是注意错误消息)，您会发现问题是什么:<em class="nd">您的测试套件必须包含至少一个测试。</em></p><p id="63d6" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">我们确实打下了一些基础，但是我们仍然没有编写任何测试。</p><h2 id="cbcc" class="ob lv iq bd lw oc od dn ma oe of dp me la og oh mg le oi oj mi li ok ol mk om bi translated">数据库连接问题</h2><p id="aee1" class="pw-post-body-paragraph kr ks iq kt b ku mm jr kw kx mn ju kz la mo lc ld le mp lg lh li mq lk ll lm ij bi translated">我们不想在测试时搞乱我们的生产数据库。您可以考虑建立一个远程测试数据库，但是这也有几个问题，比如模式结构不匹配、无法离线测试以及在多人使用数据库时缺乏对数据库状态的控制。</p><p id="daec" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">最常用的方法是“模仿”与数据库的交互，也就是说，对检索或更改数据所涉及的方法设置预定义的响应，而不真正依赖任何类型的数据库实例。</p><p id="a143" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">然而，这种方法通常会很快变得令人困惑，并在测试中增加一层人为因素。更好的方法是在您的RAM中运行一个随需应变的专用数据库实例进行测试。这就是我们将要对<code class="fe mz na nb nc b"><em class="nd">MongoDBMemoryServer</em></code>做的事情。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="on oo l"/></div></figure><blockquote class="op oq or"><p id="80f0" class="kr ks nd kt b ku kv jr kw kx ky ju kz os lb lc ld ot lf lg lh ou lj lk ll lm ij bi translated"><em class="iq">第17行:我们创建一个新的MongoDB服务器并获得守护进程(</em> <code class="fe mz na nb nc b">mongod</code> <em class="iq"> ) </em></p><p id="f38a" class="kr ks nd kt b ku kv jr kw kx ky ju kz os lb lc ld ot lf lg lh ou lj lk ll lm ij bi translated"><em class="iq">第18行:我们获得了刚刚启动的MongoDB服务器的连接URI</em></p><p id="d105" class="kr ks nd kt b ku kv jr kw kx ky ju kz os lb lc ld ot lf lg lh ou lj lk ll lm ij bi translated"><em class="iq">第19行:我们使用URI连接并获得到MongoDB服务器的连接</em></p><p id="0767" class="kr ks nd kt b ku kv jr kw kx ky ju kz os lb lc ld ot lf lg lh ou lj lk ll lm ij bi translated"><em class="iq">第20行:通过连接，得到我们想要操作的模式的模型(</em> <code class="fe mz na nb nc b">Article</code> <em class="iq"> ) </em></p><p id="5d2e" class="kr ks nd kt b ku kv jr kw kx ky ju kz os lb lc ld ot lf lg lh ou lj lk ll lm ij bi translated"><em class="iq">第25行:我们提供了我们的</em> <code class="fe mz na nb nc b">Article</code> <em class="iq">模式模型，类似于我们之前在</em> <code class="fe mz na nb nc b"><em class="iq">app.module.ts</em></code> <em class="iq">中所做的。这里的区别只是这个模型来自我们的临时RAM数据库，而不是来自由</em> <code class="fe mz na nb nc b"><em class="iq">MONGODB_CONNECTION_URI</em></code> <em class="iq">环境变量指定的真实数据库。</em></p></blockquote><p id="d510" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">现在，让我们从Jest添加两个更多的块，<code class="fe mz na nb nc b"><em class="nd">afterAll</em></code>和<code class="fe mz na nb nc b"><em class="nd">afterEach</em></code>。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="on oo l"/></div></figure><blockquote class="op oq or"><p id="d486" class="kr ks nd kt b ku kv jr kw kx ky ju kz os lb lc ld ot lf lg lh ou lj lk ll lm ij bi translated"><em class="iq">第31–35行:在这里，我们说在我们所有的测试都运行之后，我们必须删除数据库，关闭连接并停止守护进程。</em></p><p id="c58f" class="kr ks nd kt b ku kv jr kw kx ky ju kz os lb lc ld ot lf lg lh ou lj lk ll lm ij bi translated"><em class="iq">第37–43行:现在，我们说在每个单独的测试之后，我们将从我们的集合中删除所有条目(文档/数据)。在这种情况下，我们只有一个集合(用于文章)，但是将它变得更加通用是一个很好的实践。想法是总是从一个干净的数据库开始测试。</em></p></blockquote><h2 id="7d53" class="ob lv iq bd lw oc od dn ma oe of dp me la og oh mg le oi oj mi li ok ol mk om bi translated">测试文章后</h2><p id="83d3" class="pw-post-body-paragraph kr ks iq kt b ku mm jr kw kx mn ju kz la mo lc ld le mp lg lh li mq lk ll lm ij bi translated">现在，我们终于能够为<code class="fe mz na nb nc b"><em class="nd">postArticle</em></code>方法编写一批测试了。记住，这个方法必须接收一篇文章作为参数，并返回文章的保存版本或一个异常，以防已经保存了另一篇同名的文章。</p><p id="beb4" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">为了创建一批测试，我们使用Jest中的一个<code class="fe mz na nb nc b">describe</code>块和一个或多个<code class="fe mz na nb nc b">it</code>块。一个<code class="fe mz na nb nc b">it</code>块对应于一个特定的测试场景，并且应该在其末尾调用<code class="fe mz na nb nc b">expect</code>函数来检查验证测试的条件。</p><p id="0646" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">基于我们的需求，我们可以考虑两个简单的测试场景。</p><p id="9e4a" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">1-文章是有效的，应该没有任何问题地保存。</p><p id="3f2a" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">2 —文章标题重复，应抛出异常。</p><p id="5740" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">我们将用两个<code class="fe mz na nb nc b">it</code>块为<code class="fe mz na nb nc b">postArticle</code>方法编写一个<code class="fe mz na nb nc b">describe</code>块，每个测试一个。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="on oo l"/></div></figure><blockquote class="op oq or"><p id="242f" class="kr ks nd kt b ku kv jr kw kx ky ju kz os lb lc ld ot lf lg lh ou lj lk ll lm ij bi translated"><em class="iq">第49行:我们将文章存根传递给</em> <code class="fe mz na nb nc b">postArticle</code> <em class="iq">方法，并获取返回的已创建文章。</em></p><p id="38c5" class="kr ks nd kt b ku kv jr kw kx ky ju kz os lb lc ld ot lf lg lh ou lj lk ll lm ij bi translated"><em class="iq">第50行:我们使用</em> <code class="fe mz na nb nc b">expect</code> <em class="iq">函数来检查创建的文章的标题是否等于我们传递来保存的文章的标题。</em> <code class="fe mz na nb nc b">toBe</code> <em class="iq">方法指定了我们想要执行的逻辑比较。有很多不同的方法进行各种检查。如果该表达式返回除</em> <code class="fe mz na nb nc b">true</code> <em class="iq">之外的任何内容，则测试被视为失败。</em></p><p id="7908" class="kr ks nd kt b ku kv jr kw kx ky ju kz os lb lc ld ot lf lg lh ou lj lk ll lm ij bi translated"><em class="iq">第53行:这里，我们使用mongoose将文章存根保存在数据库中(注意，我们使用的是</em> <code class="fe mz na nb nc b">articleModel</code> <em class="iq">)。我们可以使用我们的</em> <code class="fe mz na nb nc b">postArticle</code> <em class="iq">方法来保存文章存根，但是该方法可能包含比简单保存更多的逻辑，因此当我们只是想在数据库中放些东西时，会引入更多的不确定性。</em></p><p id="7a7a" class="kr ks nd kt b ku kv jr kw kx ky ju kz os lb lc ld ot lf lg lh ou lj lk ll lm ij bi translated"><em class="iq">第54–56行:这里，我们使用</em> <code class="fe mz na nb nc b">postArticle</code> <em class="iq">方法，尝试保存数据库中已经存在的一篇文章，因为我们在上面的行中保存了它，并检查是否会抛出预期的异常。</em> <code class="fe mz na nb nc b">rejects</code> <em class="iq">方法用于处理被拒绝的承诺，而</em> <code class="fe mz na nb nc b">toThrow</code> <em class="iq">方法检查错误是否是</em> <code class="fe mz na nb nc b">ArticleAlreadyExists</code> <em class="iq">的实例。</em></p></blockquote><p id="870a" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">记住<code class="fe mz na nb nc b"><em class="nd">postArticle</em></code> <em class="nd"> </em>仍然不存在，所以你的IDE可能会警告你，如果你试图运行测试文件，你也会得到相关的错误。然而，要意识到现在我们已经知道了方法必须如何运行，并且我们有一个简单的方法来检查它并展示给其他人。</p><h2 id="434e" class="ob lv iq bd lw oc od dn ma oe of dp me la og oh mg le oi oj mi li ok ol mk om bi translated">测试物品</h2><p id="b965" class="pw-post-body-paragraph kr ks iq kt b ku mm jr kw kx mn ju kz la mo lc ld le mp lg lh li mq lk ll lm ij bi translated"><code class="fe mz na nb nc b"><em class="nd">getArticle</em></code>方法必须接收一个标题作为参数，并返回具有相应标题的文章或返回<code class="fe mz na nb nc b"><em class="nd">null</em></code>。</p><p id="893c" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">基于我们的需求，我们可以考虑两个简单的测试场景。</p><p id="d6d3" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">1 —找到并返回具有相应标题的文章。</p><p id="2764" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">2 —没有相应标题的文章，应返回<code class="fe mz na nb nc b"><em class="nd">null</em></code>。</p><p id="fdb1" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">让我们编写测试。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="on oo l"/></div></figure><blockquote class="op oq or"><p id="3b11" class="kr ks nd kt b ku kv jr kw kx ky ju kz os lb lc ld ot lf lg lh ou lj lk ll lm ij bi translated"><em class="iq">第62行:再次强调，这里不要使用</em> <code class="fe mz na nb nc b">postArticle</code> <em class="iq">方法来保存文章，这一点很重要。如果您在这里使用了它，并且在</em> <code class="fe mz na nb nc b">postArticle</code> <em class="iq">方法中发生了错误，测试将会说在测试</em> <code class="fe mz na nb nc b">getArticle</code> <em class="iq">时发生了错误，这使得事情更加混乱。总是试图隔离你正在测试的东西。</em></p><p id="ac0d" class="kr ks nd kt b ku kv jr kw kx ky ju kz os lb lc ld ot lf lg lh ou lj lk ll lm ij bi translated"><em class="iq">第63行:这里我们使用</em> <code class="fe mz na nb nc b">getArticle</code> <em class="iq">来搜索我们之前保存的文章的标题并存储返回。</em></p><p id="ff54" class="kr ks nd kt b ku kv jr kw kx ky ju kz os lb lc ld ot lf lg lh ou lj lk ll lm ij bi translated">第64行:现在，我们检查找到并返回的文章标题是否与我们保存的文章标题相同。</p><p id="f0cd" class="kr ks nd kt b ku kv jr kw kx ky ju kz os lb lc ld ot lf lg lh ou lj lk ll lm ij bi translated"><em class="iq">第67行:在没有事先将任何内容保存到数据库的情况下(记住，</em> <code class="fe mz na nb nc b">afterEach</code> <em class="iq">方法会在每次测试后清空数据库)，我们尝试通过文章的标题来查找文章。</em></p><p id="830b" class="kr ks nd kt b ku kv jr kw kx ky ju kz os lb lc ld ot lf lg lh ou lj lk ll lm ij bi translated"><em class="iq">第68行:我们使用</em> <code class="fe mz na nb nc b">toBeNull</code> <em class="iq">检查对象文章是否如预期的那样是</em> <code class="fe mz na nb nc b">null</code> <em class="iq">。</em></p></blockquote><h1 id="0309" class="lu lv iq bd lw lx mt lz ma mb mu md me jw mv jx mg jz mw ka mi kc mx kd mk ml bi translated">实现这些方法</h1><p id="797b" class="pw-post-body-paragraph kr ks iq kt b ku mm jr kw kx mn ju kz la mo lc ld le mp lg lh li mq lk ll lm ij bi translated">既然测试已经完成，我们应该编写足够的代码来通过测试，因为通过测试意味着功能是完整和准确的。</p><p id="c146" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">本文的重点是测试，所以不会有太多关于方法本身实现的解释。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="on oo l"/></div></figure><h1 id="8f72" class="lu lv iq bd lw lx mt lz ma mb mu md me jw mv jx mg jz mw ka mi kc mx kd mk ml bi translated">运行测试</h1><p id="2122" class="pw-post-body-paragraph kr ks iq kt b ku mm jr kw kx mn ju kz la mo lc ld le mp lg lh li mq lk ll lm ij bi translated">现在，当您在终端中执行<code class="fe mz na nb nc b"><em class="nd">npm test</em></code>时，所有的测试都应该运行并顺利通过。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi ov"><img src="../Images/c0351d080123f8143cc36801f109ad06.png" data-original-src="https://miro.medium.com/v2/resize:fit:1302/format:webp/1*Mff7afpojzBt_AJagfm8hw.png"/></div></figure><p id="9eb8" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">要查看测试覆盖率，使用<code class="fe mz na nb nc b"><em class="nd">npm run test:cov</em></code> <em class="nd">。测试覆盖结果显示了你的所有测试测试了多少代码，并且是代码质量的一个很好的度量。</em></p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi ow"><img src="../Images/893072cb7769e3c0e2ccd5ff35b18fba.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*OaXxFDF67DLNA1-YMipwXA.png"/></div></div></figure><p id="7248" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">为了让您的测试在您修改代码时自动运行，请使用<code class="fe mz na nb nc b"><em class="nd">npm run test:watch</em></code>。还有一些有用的VS代码扩展来帮助你跟踪你的测试执行，比如来自“Orta”的“Jest”扩展。</p></div><div class="ab cl ln lo hu lp" role="separator"><span class="lq bw bk lr ls lt"/><span class="lq bw bk lr ls lt"/><span class="lq bw bk lr ls"/></div><div class="ij ik il im in"><h1 id="6434" class="lu lv iq bd lw lx ly lz ma mb mc md me jw mf jx mg jz mh ka mi kc mj kd mk ml bi translated">最终考虑</h1><p id="8041" class="pw-post-body-paragraph kr ks iq kt b ku mm jr kw kx mn ju kz la mo lc ld le mp lg lh li mq lk ll lm ij bi translated">这绝不是对Jest或TDD的详尽回顾，但我真的希望您能在这里找到有用的东西。读完这篇文章后，我建议看一下<a class="ae mr" href="https://jestjs.io/docs/getting-started" rel="noopener ugc nofollow" target="_blank"> Jest文档</a>以获取更多信息。</p><p id="18ae" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">感谢阅读。</p></div></div>    
</body>
</html>