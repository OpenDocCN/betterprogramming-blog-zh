<html>
<head>
<title>Docker Tips: Using Docker Config</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Docker提示:使用Docker配置</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/about-using-docker-config-e967d4a74b83?source=collection_archive---------6-----------------------#2017-11-21">https://betterprogramming.pub/about-using-docker-config-e967d4a74b83?source=collection_archive---------6-----------------------#2017-11-21</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><figure class="gl gn jr js jt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi jq"><img src="../Images/3a74e02d95981e6482495b2f685c8840.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*LjbUt0WAU_Sl6wXjlLXXyA.jpeg"/></div></div><p class="kb kc gj gh gi kd ke bd b be z dk translated">Alejandro Escamilla 在<a class="ae kf" href="https://unsplash.com/search/photos/computer?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</p></figure><h1 id="b179" class="kg kh it bd ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld bi translated">TL；速度三角形定位法(dead reckoning)</h1><p id="63e4" class="pw-post-body-paragraph le lf it lg b lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb im bi translated">使用一个<a class="ae kf" href="http://docker.com" rel="noopener ugc nofollow" target="_blank"> Docker </a>配置而不是创建一个具有嵌入式配置的映像怎么样？</p></div><div class="ab cl mc md hx me" role="separator"><span class="mf bw bk mg mh mi"/><span class="mf bw bk mg mh mi"/><span class="mf bw bk mg mh"/></div><div class="im in io ip iq"><h1 id="8a27" class="kg kh it bd ki kj mj kl km kn mk kp kq kr ml kt ku kv mm kx ky kz mn lb lc ld bi translated">在图像中嵌入配置？</h1><p id="d668" class="pw-post-body-paragraph le lf it lg b lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb im bi translated">我们经常看到如下所示的docker文件，其中创建一个新映像只是为了向基本映像添加一个配置。</p><pre class="mo mp mq mr gt ms mt mu mv aw mw bi"><span id="4d33" class="mx kh it mt b gy my mz l na nb">$ cat Dockerfile<br/>FROM nginx:1.13.6<br/>COPY nginx.conf /etc/nginx/nginx.conf</span></pre><p id="25f6" class="pw-post-body-paragraph le lf it lg b lh nc lj lk ll nd ln lo lp ne lr ls lt nf lv lw lx ng lz ma mb im bi translated">在这个例子中，本地<code class="fe nh ni nj mt b">nginx.conf</code>配置文件被复制到<a class="ae kf" href="https://www.nginx.com/" rel="noopener ugc nofollow" target="_blank"> NGINX </a>映像的文件系统中，以覆盖默认配置文件，即<code class="fe nh ni nj mt b">/etc/nginx/nginx.conf</code>中提供的文件。</p><p id="1f65" class="pw-post-body-paragraph le lf it lg b lh nc lj lk ll nd ln lo lp ne lr ls lt nf lv lw lx ng lz ma mb im bi translated">这种方法的一个主要缺点是，如果配置发生变化，就需要重新构建映像。</p></div><div class="ab cl mc md hx me" role="separator"><span class="mf bw bk mg mh mi"/><span class="mf bw bk mg mh mi"/><span class="mf bw bk mg mh"/></div><div class="im in io ip iq"><h1 id="2014" class="kg kh it bd ki kj mj kl km kn mk kp kq kr ml kt ku kv mm kx ky kz mn lb lc ld bi translated">Docker配置进入画面</h1><p id="b640" class="pw-post-body-paragraph le lf it lg b lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb im bi translated"><code class="fe nh ni nj mt b">Configs</code>从17.06号码头开始提供服务。在<code class="fe nh ni nj mt b">secrets</code>存储敏感信息的地方，<code class="fe nh ni nj mt b">config</code>允许在服务映像之外存储非敏感信息，比如配置文件。</p><p id="7fc3" class="pw-post-body-paragraph le lf it lg b lh nc lj lk ll nd ln lo lp ne lr ls lt nf lv lw lx ng lz ma mb im bi translated">至于其他Docker原语(容器、图像、卷)，<code class="fe nh ni nj mt b">config</code>在CLI中有自己的命令集。</p><pre class="mo mp mq mr gt ms mt mu mv aw mw bi"><span id="a416" class="mx kh it mt b gy my mz l na nb">$ docker config --help</span><span id="0fef" class="mx kh it mt b gy nk mz l na nb">Usage: docker config COMMAND</span><span id="ea8a" class="mx kh it mt b gy nk mz l na nb">Manage Docker configs</span><span id="8142" class="mx kh it mt b gy nk mz l na nb">Options:</span><span id="65f0" class="mx kh it mt b gy nk mz l na nb">Commands:<br/> create Create a configuration file from a file or STDIN as content<br/> inspect Display detailed information on one or more config files<br/> ls List configs<br/> rm Remove one or more configuration files</span><span id="0380" class="mx kh it mt b gy nk mz l na nb">Run ‘docker config COMMAND — help’ for more information on a command.</span></pre></div><div class="ab cl mc md hx me" role="separator"><span class="mf bw bk mg mh mi"/><span class="mf bw bk mg mh mi"/><span class="mf bw bk mg mh"/></div><div class="im in io ip iq"><h1 id="1c67" class="kg kh it bd ki kj mj kl km kn mk kp kq kr ml kt ku kv mm kx ky kz mn lb lc ld bi translated"><strong class="ak">创建配置</strong></h1><p id="af5d" class="pw-post-body-paragraph le lf it lg b lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb im bi translated">回到前面的例子，我们将创建一个Docker配置文件，而不是在映像中复制NGINX配置文件。</p><p id="859b" class="pw-post-body-paragraph le lf it lg b lh nc lj lk ll nd ln lo lp ne lr ls lt nf lv lw lx ng lz ma mb im bi translated">在本例中，<code class="fe nh ni nj mt b">nginx.conf</code>文件包含以下内容。</p><figure class="mo mp mq mr gt ju"><div class="bz fp l di"><div class="nl nm l"/></div></figure><p id="ca4d" class="pw-post-body-paragraph le lf it lg b lh nc lj lk ll nd ln lo lp ne lr ls lt nf lv lw lx ng lz ma mb im bi translated">它基本上定义了一个web服务器，该服务器监听端口8000，并将到达<code class="fe nh ni nj mt b">/api</code>端点的所有HTTP请求转发给上游API服务器。</p><p id="1834" class="pw-post-body-paragraph le lf it lg b lh nc lj lk ll nd ln lo lp ne lr ls lt nf lv lw lx ng lz ma mb im bi translated">使用Docker CLI，我们可以从这个配置文件中创建一个<code class="fe nh ni nj mt b">config</code>，我们将这个配置命名为<code class="fe nh ni nj mt b">proxy</code>。</p><pre class="mo mp mq mr gt ms mt mu mv aw mw bi"><span id="d333" class="mx kh it mt b gy my mz l na nb">$ docker config create proxy nginx.conf<br/>mdcfnxud53ve6jgcgjkhflg0s</span></pre><p id="7098" class="pw-post-body-paragraph le lf it lg b lh nc lj lk ll nd ln lo lp ne lr ls lt nf lv lw lx ng lz ma mb im bi translated">然后，我们可以像检查任何其他Docker原语一样检查配置:</p><pre class="mo mp mq mr gt ms mt mu mv aw mw bi"><span id="bea0" class="mx kh it mt b gy my mz l na nb">$ docker config inspect proxy<br/>[<br/>  {<br/>    "ID": "x06uaozphg9kbnf8g4az4mucn",<br/>    "Version": {<br/>      "Index": 2723<br/>    },<br/>    "CreatedAt": "2017–11–21T07:49:09.553666064Z",<br/>    "UpdatedAt": "2017–11–21T07:49:09.553666064Z",<br/>    "Spec": {<br/>      "Name": "proxy,<br/>      "Labels": {},<br/>      "Data": "dXNlciB3d3ctZGF0YTsKd29y...ogIgICAgIH0KICAgIH0KfQo="<br/>    }<br/>  }<br/>]</span></pre><p id="2e88" class="pw-post-body-paragraph le lf it lg b lh nc lj lk ll nd ln lo lp ne lr ls lt nf lv lw lx ng lz ma mb im bi translated">这些数据仅采用Base64编码，很容易解码。</p><figure class="mo mp mq mr gt ju"><div class="bz fp l di"><div class="nl nm l"/></div></figure><p id="3381" class="pw-post-body-paragraph le lf it lg b lh nc lj lk ll nd ln lo lp ne lr ls lt nf lv lw lx ng lz ma mb im bi translated">根据定义，配置中的数据不是机密的，因此不会加密。</p></div><div class="ab cl mc md hx me" role="separator"><span class="mf bw bk mg mh mi"/><span class="mf bw bk mg mh mi"/><span class="mf bw bk mg mh"/></div><div class="im in io ip iq"><h1 id="2a35" class="kg kh it bd ki kj mj kl km kn mk kp kq kr ml kt ku kv mm kx ky kz mn lb lc ld bi translated">使用配置</h1><p id="f7d7" class="pw-post-body-paragraph le lf it lg b lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb im bi translated">既然我们已经创建了<code class="fe nh ni nj mt b">proxy</code>配置，我们将看看如何在服务中使用它。为此，我们将考虑两种方法——使用命令行和使用Docker堆栈。</p><p id="17f3" class="pw-post-body-paragraph le lf it lg b lh nc lj lk ll nd ln lo lp ne lr ls lt nf lv lw lx ng lz ma mb im bi translated">在这两种情况下，我们定义了两种服务:</p><ul class=""><li id="e63b" class="nn no it lg b lh nc ll nd lp np lt nq lx nr mb ns nt nu nv bi translated"><strong class="lg iu"> API </strong>:一个简单的HTTP服务器监听端口80，并在每次收到Get请求时发回一个城市访问建议。</li><li id="5f06" class="nn no it lg b lh nw ll nx lp ny lt nz lx oa mb ns nt nu nv bi translated">一个<strong class="lg iu">代理</strong>使用上面创建的配置，将所有以<code class="fe nh ni nj mt b">/api</code>端点为目标的流量发送到上游API服务。</li></ul><p id="595b" class="pw-post-body-paragraph le lf it lg b lh nc lj lk ll nd ln lo lp ne lr ls lt nf lv lw lx ng lz ma mb im bi translated">我们将通过在代理的端口8000上的<code class="fe nh ni nj mt b">/api </code>端点上发送一个HTTP Get请求来测试这个设置，并确保我们得到一个来自API的响应。</p><h2 id="f294" class="mx kh it bd ki ob oc dn km od oe dp kq lp of og ku lt oh oi ky lx oj ok lc ol bi translated"><strong class="ak">使用命令行</strong></h2><p id="71b4" class="pw-post-body-paragraph le lf it lg b lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb im bi translated">我们首先创建一个覆盖网络。我们将使用它，这样API和代理这两个服务就可以一起通信。</p><pre class="mo mp mq mr gt ms mt mu mv aw mw bi"><span id="043e" class="mx kh it mt b gy my mz l na nb">$ docker network create --driver overlay front</span></pre><p id="66ff" class="pw-post-body-paragraph le lf it lg b lh nc lj lk ll nd ln lo lp ne lr ls lt nf lv lw lx ng lz ma mb im bi translated">然后我们创建了<code class="fe nh ni nj mt b">api</code>服务。</p><pre class="mo mp mq mr gt ms mt mu mv aw mw bi"><span id="e940" class="mx kh it mt b gy my mz l na nb">$ docker service create --name api --network front lucj/api</span></pre><p id="7cfb" class="pw-post-body-paragraph le lf it lg b lh nc lj lk ll nd ln lo lp ne lr ls lt nf lv lw lx ng lz ma mb im bi translated">最后一步是创建<code class="fe nh ni nj mt b">proxy</code>服务。</p><pre class="mo mp mq mr gt ms mt mu mv aw mw bi"><span id="3fcb" class="mx kh it mt b gy my mz l na nb">$ docker service create --name proxy \<br/>  --name proxy \<br/>  --network front \<br/>  --config src=proxy,target=/etc/nginx/nginx.conf \<br/>  --port 8000:8000 \<br/>  nginx:1.13.6</span></pre><p id="d8ba" class="pw-post-body-paragraph le lf it lg b lh nc lj lk ll nd ln lo lp ne lr ls lt nf lv lw lx ng lz ma mb im bi translated">一切就绪后，让我们在本地主机的端口8000(代理服务在主机上发布的端口)上发送一个HTTP请求</p><pre class="mo mp mq mr gt ms mt mu mv aw mw bi"><span id="db39" class="mx kh it mt b gy my mz l na nb">$ curl localhost:8000/api<br/>{“msg”:”c249837f1f58 suggests to visit Emosiba”}</span></pre><p id="d90c" class="pw-post-body-paragraph le lf it lg b lh nc lj lk ll nd ln lo lp ne lr ls lt nf lv lw lx ng lz ma mb im bi translated">请求到达代理服务，代理服务将请求转发给API。换句话说，作为Docker配置提供的NGINX配置文件被正确地考虑在内。</p><h2 id="36d5" class="mx kh it bd ki ob oc dn km od oe dp kq lp of og ku lt oh oi ky lx oj ok lc ol bi translated"><strong class="ak">使用Docker编写文件</strong></h2><p id="bba7" class="pw-post-body-paragraph le lf it lg b lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb im bi translated">当然，使用Compose文件来定义应用程序并将其部署为Docker堆栈更加方便。然后我们用以下内容创建一个<code class="fe nh ni nj mt b">stack.yml</code>文件。</p><figure class="mo mp mq mr gt ju"><div class="bz fp l di"><div class="nl nm l"/></div></figure><p id="6d6b" class="pw-post-body-paragraph le lf it lg b lh nc lj lk ll nd ln lo lp ne lr ls lt nf lv lw lx ng lz ma mb im bi translated">注意:因为配置是在运行应用程序之前创建的，所以在这个文件中它被定义为<code class="fe nh ni nj mt b">external</code>。</p><p id="8561" class="pw-post-body-paragraph le lf it lg b lh nc lj lk ll nd ln lo lp ne lr ls lt nf lv lw lx ng lz ma mb im bi translated">然后可以使用以下命令运行该应用程序:</p><pre class="mo mp mq mr gt ms mt mu mv aw mw bi"><span id="3e6f" class="mx kh it mt b gy my mz l na nb">$ docker stack deploy -c stack.yml test<br/>Creating service test_proxy<br/>Creating service test_api</span></pre><p id="47ff" class="pw-post-body-paragraph le lf it lg b lh nc lj lk ll nd ln lo lp ne lr ls lt nf lv lw lx ng lz ma mb im bi translated">让我们向代理服务的<code class="fe nh ni nj mt b">/api</code>端点发送一个HTTP Get请求。</p><pre class="mo mp mq mr gt ms mt mu mv aw mw bi"><span id="cc4c" class="mx kh it mt b gy my mz l na nb">$ curl localhost:8000/api<br/>{“msg”:”f462d568c0b0 suggests to visit Onitufdu”}</span></pre><p id="a9e5" class="pw-post-body-paragraph le lf it lg b lh nc lj lk ll nd ln lo lp ne lr ls lt nf lv lw lx ng lz ma mb im bi translated">和以前一样，请求被转发给API服务。</p></div><div class="ab cl mc md hx me" role="separator"><span class="mf bw bk mg mh mi"/><span class="mf bw bk mg mh mi"/><span class="mf bw bk mg mh"/></div><div class="im in io ip iq"><h1 id="9b06" class="kg kh it bd ki kj mj kl km kn mk kp kq kr ml kt ku kv mm kx ky kz mn lb lc ld bi translated">服务更新</h1><p id="c5b5" class="pw-post-body-paragraph le lf it lg b lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb im bi translated">当需要修改配置的内容时，常见的模式是创建一个新的配置(使用<code class="fe nh ni nj mt b">docker config create</code>)，然后更新服务订单以删除对以前配置的访问，并添加对新配置的访问。服务命令是<code class="fe nh ni nj mt b">--config-rm</code>和<code class="fe nh ni nj mt b">-- config-add.</code></p><p id="1f8a" class="pw-post-body-paragraph le lf it lg b lh nc lj lk ll nd ln lo lp ne lr ls lt nf lv lw lx ng lz ma mb im bi translated">让我们从<code class="fe nh ni nj mt b">nginx-v2.conf</code>文件创建一个新的配置。</p><pre class="mo mp mq mr gt ms mt mu mv aw mw bi"><span id="c861" class="mx kh it mt b gy my mz l na nb">$ docker config create proxy-v2 nginx-v2.conf<br/>xtd1s1g6b5zukjhvup5vi4jzd</span></pre><p id="2ada" class="pw-post-body-paragraph le lf it lg b lh nc lj lk ll nd ln lo lp ne lr ls lt nf lv lw lx ng lz ma mb im bi translated">然后，我们可以用下面的命令更新服务。这样，我们删除名为<code class="fe nh ni nj mt b">proxy</code>的<strong class="lg iu"> </strong>配置，并添加名为<code class="fe nh ni nj mt b">proxy-v2</code> <strong class="lg iu">的配置。</strong></p><pre class="mo mp mq mr gt ms mt mu mv aw mw bi"><span id="12bc" class="mx kh it mt b gy my mz l na nb">$ docker service update --config-rm proxy --config-add src=proxy-v2,target=/etc/nginx/nginx.conf proxy</span></pre><p id="66c0" class="pw-post-body-paragraph le lf it lg b lh nc lj lk ll nd ln lo lp ne lr ls lt nf lv lw lx ng lz ma mb im bi translated">注意:默认情况下，当配置附加到服务时，它在/config_name文件中可用。然后我们需要使用<code class="fe nh ni nj mt b">target</code>选项明确定义位置。</p></div><div class="ab cl mc md hx me" role="separator"><span class="mf bw bk mg mh mi"/><span class="mf bw bk mg mh mi"/><span class="mf bw bk mg mh"/></div><div class="im in io ip iq"><h1 id="31ab" class="kg kh it bd ki kj mj kl km kn mk kp kq kr ml kt ku kv mm kx ky kz mn lb lc ld bi translated">摘要</h1><p id="6762" class="pw-post-body-paragraph le lf it lg b lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb im bi translated">Config是一个非常简洁的东西，它有助于将应用程序从配置中分离出来。你在应用程序中使用配置吗？</p></div></div>    
</body>
</html>