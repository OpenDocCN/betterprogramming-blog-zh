<html>
<head>
<title>Should You Work on Your Own Types in Rust? Yes, and Here’s How</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">你应该在Rust中开发你自己的类型吗？是的，下面是方法</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/rust-should-you-work-on-your-own-types-yes-and-heres-how-5214c61300b0?source=collection_archive---------15-----------------------#2022-08-24">https://betterprogramming.pub/rust-should-you-work-on-your-own-types-yes-and-heres-how-5214c61300b0?source=collection_archive---------15-----------------------#2022-08-24</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="7ae1" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">让你的Rust代码更安全、更干净</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/e1a1ae85a51ab20855320950a94a850c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*O_e4LMq4wp3JGfFU"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated"><a class="ae ky" href="https://unsplash.com/@florianklauer?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Florian Klauer </a>在<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</p></figure><p id="3868" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">首先，我想说的是，如果您希望您的代码是生产就绪的或者尽可能干净，那么您应该使用本文中描述的方法。说完了，我们开始吧！</p><p id="9f63" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">有无数的理由说明类型在你的代码中是必不可少的:速度、编译器效率、可维护性、可读性、安全性等等，这就是为什么大多数语言依赖于类型。</p><p id="cac4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">像Rust这样的语言有一些内置的类型，也称为“原始”类型。这些原语意味着直接在您的代码中使用，但也可以让您在它们的基础上构建自己的类型。</p><p id="3d25" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">例如，Rust的标准库提供了许多有用的类型和实现供您在代码中使用，但是当您决定不在机箱中包含标准库时，真正的挑战才开始。</p><p id="abab" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">例如，当使用微控制器或其他嵌入式系统时，您可能不想使用标准库，就像您在编写智能合同时不想使用它一样，在智能合同中，关心编译代码的大小是很重要的。</p><p id="75a0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在没有标准库的情况下编写非基本代码的唯一方法是创建自己的类型，即使有了标准库，大多数时候也需要创建新的类型。</p></div><div class="ab cl lz ma hx mb" role="separator"><span class="mc bw bk md me mf"/><span class="mc bw bk md me mf"/><span class="mc bw bk md me"/></div><div class="im in io ip iq"><p id="ec0e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">但是数字呢？在Rust中，你有各种各样的本原数类型:<code class="fe lv lw lx ly b">i8</code>、<code class="fe lv lw lx ly b">i16</code>、<code class="fe lv lw lx ly b">i32</code>、<code class="fe lv lw lx ly b">i64</code>、<code class="fe lv lw lx ly b">i128</code>、<code class="fe lv lw lx ly b">isize</code>、<code class="fe lv lw lx ly b">u8</code>、<code class="fe lv lw lx ly b">u16</code>、<code class="fe lv lw lx ly b">u32</code>、<code class="fe lv lw lx ly b">u64</code>、<code class="fe lv lw lx ly b">u128</code>、<code class="fe lv lw lx ly b">usize</code>、<code class="fe lv lw lx ly b">f32</code>、<code class="fe lv lw lx ly b">f64</code>。</p><p id="4546" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">本文旨在向您展示为什么您会发现大多数时候，使用您自己的类型更好，并且它将通过数字来实现。</p><blockquote class="mg mh mi"><p id="10f3" class="kz la mj lb b lc ld ju le lf lg jx lh mk lj lk ll ml ln lo lp mm lr ls lt lu im bi translated">为什么通过数字？</p></blockquote><p id="c923" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">因为即使在处理像有符号和无符号整数这样简单的东西时，这也是显示对新类型的需求的一种强有力的方式。</p><h1 id="2c92" class="mn mo it bd mp mq mr ms mt mu mv mw mx jz my ka mz kc na kd nb kf nc kg nd ne bi translated">用例</h1><p id="d9fa" class="pw-post-body-paragraph kz la it lb b lc nf ju le lf ng jx lh li nh lk ll lm ni lo lp lq nj ls lt lu im bi translated">假设我们正在制作一个苹果汁赠品，我们想赠送180个苹果汁，让最多180个加入赠品的用户能够以他们认为正确/有利可图的价格转售他们的苹果汁。</p><p id="4d51" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">由于我们使用键值存储来实现并行性(假设我们的目标平台支持它)，我们将为每个180分配一个数字id。</p><p id="570c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们还可以说，我们的应用程序必须知道密钥，而不需要获取它们，因此使用一个从0到180的数字作为id是一个很好的方法。</p><p id="b281" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们可以做的是创建一个这样的枚举来包含一个<code class="fe lv lw lx ly b">u8</code>数(因为u8的最大值可以是255):</p><pre class="kj kk kl km gt nk ly nl nm aw nn bi"><span id="52aa" class="no mo it ly b gy np nq l nr ns">enum Key {<br/>    Giveaway(u8),<br/>}</span></pre><p id="bf5f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这样，当我们在键值存储中读取或写入我们的第120个苹果汁时，我们可以使用键:<code class="fe lv lw lx ly b">Key::Giveaway(120)</code>。</p><h1 id="4bc0" class="mn mo it bd mp mq mr ms mt mu mv mw mx jz my ka mz kc na kd nb kf nc kg nd ne bi translated">问题是</h1><blockquote class="mg mh mi"><p id="7c35" class="kz la mj lb b lc ld ju le lf lg jx lh mk lj lk ll ml ln lo lp mm lr ls lt lu im bi translated">这个实现有什么问题？</p></blockquote><p id="120f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">那么<code class="fe lv lw lx ly b">Key::Giveaway(190)</code>呢？</p><p id="881e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们的ID应该有一个最大值180，所以可以肯定地说，如果我们想让我们的应用程序受益于Rust提供的安全性，就不应该有上面这样的东西。我们可以这样做:</p><pre class="kj kk kl km gt nk ly nl nm aw nn bi"><span id="d6c8" class="no mo it ly b gy np nq l nr ns">fn put_store(key: Key, value: &amp;[u8]) {<br/>    let Key::Giveaway(repr) = key;<br/>    assert!(repr &lt;= 180);<br/>    // put in the kv<br/>}</span></pre><p id="0045" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">但这绝对不是一个干净的过程，更难维护，而且远不如我们将要做的清晰可辨。</p><h1 id="bb7f" class="mn mo it bd mp mq mr ms mt mu mv mw mx jz my ka mz kc na kd nb kf nc kg nd ne bi translated">解决方案</h1><p id="8512" class="pw-post-body-paragraph kz la it lb b lc nf ju le lf ng jx lh li nh lk ll lm ni lo lp lq nj ls lt lu im bi translated">我们要做的是创建我们自己的类型，并设置界限以受益于强类型。我们将做一些事情，不允许用一个无效的<code class="fe lv lw lx ly b">u8</code>内部值创建一个<code class="fe lv lw lx ly b">Key::Giveaway</code>。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nt nu l"/></div></figure><p id="decb" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们创建了<code class="fe lv lw lx ly b">Id</code>结构，并实现了<code class="fe lv lw lx ly b">Id::new</code>方法来检查ID的整数表示是否有效(<code class="fe lv lw lx ly b">assert!(int ≤ 180)</code>)。</p><p id="5d24" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们现在可以调用一个<code class="fe lv lw lx ly b">put_store</code>、<code class="fe lv lw lx ly b">get_store</code>或任何其他涉及<code class="fe lv lw lx ly b">Id</code>的函数，而不用担心安全检查，因为我们拥有的任何<code class="fe lv lw lx ly b">Id</code>都是为了进行这些检查而创建的。</p><h1 id="d30b" class="mn mo it bd mp mq mr ms mt mu mv mw mx jz my ka mz kc na kd nb kf nc kg nd ne bi translated">为什么？</h1><blockquote class="mg mh mi"><p id="1e02" class="kz la mj lb b lc ld ju le lf lg jx lh mk lj lk ll ml ln lo lp mm lr ls lt lu im bi translated">这难道不会使代码的性能稍有下降吗？</p><p id="8c5b" class="kz la mj lb b lc ld ju le lf lg jx lh mk lj lk ll ml ln lo lp mm lr ls lt lu im bi translated">在我们的类型中有很强的界限是唯一的优势吗？</p><p id="32f9" class="kz la mj lb b lc ld ju le lf lg jx lh mk lj lk ll ml ln lo lp mm lr ls lt lu im bi translated">我应该什么时候实施这种语法？</p></blockquote><p id="ed9b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我的经验是，如果您正在处理其他开发人员不得不审查和维护的代码，或者您计划自己维护一段时间的代码，则应该始终加强正确性、可读性和可维护性。</p><p id="32e9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">强制这样的强类型不仅在检查填充它们的值、可维护性和可读性方面是有益的，而且还可以防止您自己或其他开发人员执行无效的操作。</p><p id="a541" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">例如，如果我们使用<code class="fe lv lw lx ly b">u8</code>原语作为我们的id，而不是<code class="fe lv lw lx ly b">Id</code>类型，那么另一个开发人员可以执行像<code class="fe lv lw lx ly b">my_id * 100</code>这样的操作，为与特定苹果汁相关的另一个值创建一个id，这是不应该发生的，因为将<code class="fe lv lw lx ly b">my_id</code>乘以100会产生另一种id。</p><h1 id="6429" class="mn mo it bd mp mq mr ms mt mu mv mw mx jz my ka mz kc na kd nb kf nc kg nd ne bi translated">权衡取舍</h1><p id="8cbe" class="pw-post-body-paragraph kz la it lb b lc nf ju le lf ng jx lh li nh lk ll lm ni lo lp lq nj ls lt lu im bi translated">当采用这种方法时，您会注意到最大的缺点是代码大小，以及您必须根据需要为您的类型编写大量实现的事实。例如，如果你需要用id(<code class="fe lv lw lx ly b">id1 + id2</code>)做加法，你将不得不这样做:</p><pre class="kj kk kl km gt nk ly nl nm aw nn bi"><span id="788b" class="no mo it ly b gy np nq l nr ns">impl Id {<br/>    ...</span><span id="da24" class="no mo it ly b gy nv nq l nr ns">    pub fn add(&amp;self, rhs: Id) -&gt; Id {<br/>        Id::new(self.0 + rhs.0)<br/>    }<br/>}</span></pre><p id="0998" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">不得不手动实现这些可能很烦人，但是当处理生产代码时，这是值得做的努力。</p></div><div class="ab cl lz ma hx mb" role="separator"><span class="mc bw bk md me mf"/><span class="mc bw bk md me mf"/><span class="mc bw bk md me"/></div><div class="im in io ip iq"><p id="9be5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">最后，我并不总是强制强类型。您必须考虑到许多因开发人员而异的变量:</p><ul class=""><li id="532f" class="nw nx it lb b lc ld lf lg li ny lm nz lq oa lu ob oc od oe bi translated">代码是要直接投入生产吗？</li><li id="2634" class="nw nx it lb b lc of lf og li oh lm oi lq oj lu ob oc od oe bi translated">该类型在代码中的重现性如何？</li><li id="03f1" class="nw nx it lb b lc of lf og li oh lm oi lq oj lu ob oc od oe bi translated">现有的法规是如何实施的？</li></ul><p id="9515" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">不管怎样，知道如何和为什么使用你自己的类型是很好的，即使是在处理，例如，数字。</p><p id="e508" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><em class="mj">感谢阅读！如果你对Rust感兴趣，你可能也会觉得我最近写的两篇文章很有趣:</em></p><div class="ok ol gp gr om on"><a rel="noopener  ugc nofollow" target="_blank" href="/build-a-cryptominer-in-rust-and-run-it-on-your-browser-300662204131"><div class="oo ab fo"><div class="op ab oq cl cj or"><h2 class="bd iu gy z fp os fr fs ot fu fw is bi translated">在Rust中构建一个加密货币挖掘器，并在您的浏览器上运行它</h2><div class="ou l"><h3 class="bd b gy z fp os fr fs ot fu fw dk translated">了解黑客如何利用WASM进行区块链采矿</h3></div><div class="ov l"><p class="bd b dl z fp os fr fs ot fu fw dk translated">better编程. pub</p></div></div><div class="ow l"><div class="ox l oy oz pa ow pb ks on"/></div></div></a></div><div class="ok ol gp gr om on"><a rel="noopener  ugc nofollow" target="_blank" href="/rust-for-the-fastest-serverless-experience-80530acdd4d4"><div class="oo ab fo"><div class="op ab oq cl cj or"><h2 class="bd iu gy z fp os fr fs ot fu fw is bi translated">创建无服务器的Rust功能以获得快速体验</h2><div class="ou l"><h3 class="bd b gy z fp os fr fs ot fu fw dk translated">WASM再次施展魔法</h3></div><div class="ov l"><p class="bd b dl z fp os fr fs ot fu fw dk translated">better编程. pub</p></div></div><div class="ow l"><div class="pc l oy oz pa ow pb ks on"/></div></div></a></div></div></div>    
</body>
</html>