<html>
<head>
<title>Zen Naming Convention</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">禅宗命名惯例</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/zen-naming-convention-5314aa0ab67a?source=collection_archive---------9-----------------------#2019-08-21">https://betterprogramming.pub/zen-naming-convention-5314aa0ab67a?source=collection_archive---------9-----------------------#2019-08-21</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="b7bd" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">一组灵活的命名建议，您可以根据需要进行修改</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/6b05826f1263596e1460e8d9bfddb03d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*XXBBYx4a9S_MC7Mr28zVbA.jpeg"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">照片由<a class="ae ky" href="https://unsplash.com/@wildspot?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">aurélien——Unsplash</a><a class="ae ky" href="https://unsplash.com/search/photos/zen?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">上的野生斑点</a></p></figure><p id="72a6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">关于正确的命名约定还没有定论，但是如果你想从一组灵活的建议开始，并根据你的需要进行修改，我也许可以帮助你。</p><p id="e55c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">本指南中的代码是用JavaScript编写的，但这些原则可以普遍适用。</p><h1 id="4b30" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">1.别担心，开心点</h1><pre class="kj kk kl km gt mn mo mp mq aw mr bi"><span id="bb67" class="ms lw it mo b gy mt mu l mv mw">const doSomething = stuff =&gt; {}</span></pre><p id="8f1e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">上面的功能是我的一种仪式。这些年来，我逐渐意识到在我真正需要命名一个函数之前，我需要一个函数，所以我经常从这里开始。</p><p id="d60f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">郑重声明，这是准确的。我得做点什么来填充。这个函数的名字告诉我这个函数是做什么的，同时也告诉我要尽快重命名它。</p><p id="977d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">大多数情况下，我会在调用这个函数之前对它进行重命名，但有时，我发现自己在最后一刻解决了一个棘手的问题，我需要尽我所能保留所有的脑力。</p><p id="700b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我要说明的要点是，我从来不会因为我必须为一个变量选择正确的名称而失去思考的节奏，你也不应该这样。</p><p id="5ee6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">当今大多数现代的ide都是为了在整个项目中安全地重命名变量而构建的，如果您想提高自己在命名约定方面的天赋，您应该尽早并经常使用该工具。</p></div><div class="ab cl mx my hx mz" role="separator"><span class="na bw bk nb nc nd"/><span class="na bw bk nb nc nd"/><span class="na bw bk nb nc"/></div><div class="im in io ip iq"><h1 id="714a" class="lv lw it bd lx ly ne ma mb mc nf me mf jz ng ka mh kc nh kd mj kf ni kg ml mm bi translated">2.越平越好</h1><pre class="kj kk kl km gt mn mo mp mq aw mr bi"><span id="60bb" class="ms lw it mo b gy mt mu l mv mw"><em class="nj">const </em>THEME_BORDER_COLOR = '#999'<br/><em class="nj">const </em>THEME_BORDER_STYLE = 'solid'<br/><em class="nj">const </em>THEME_BORDER_WIDTH = 1<br/><em class="nj">const </em>THEME_MARGIN_BOTTOM = 20<br/><em class="nj">const </em>THEME_MARGIN_TOP = 20<br/><em class="nj">const </em>THEME_PADDING = 40<br/><br/><em class="nj">const </em>theme = {<br/>  border: {<br/>    color: '#999',<br/>    style: 'solid',<br/>    width: 1,<br/>  },<br/>  margin: {<br/>    top: 20,<br/>    bottom: 20,<br/>  },<br/>  padding: 20,<br/>}</span></pre><p id="070c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">平面变量可以由您的IDE索引，这使得它们更容易在整个项目中使用。</p><p id="3ec8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">另外，看一下上面的例子。如果我想从一个单独的<code class="fe nk nl nm mo b">PADDING</code>变量变成<code class="fe nk nl nm mo b">PADDING_TOP</code>、<code class="fe nk nl nm mo b">PADDING_BOTTOM</code>等等，我可以通过简单地创建新的变量，用扁平结构很容易地做到这一点。</p><p id="eed1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">然而，在嵌套结构中，我需要将<code class="fe nk nl nm mo b">theme.padding</code>从一个值改为一个嵌套更深的对象。随着项目的增长，以这种方式不断地重塑你的变量树肯定会给你带来麻烦，而扁平结构喜欢伸缩。</p></div><div class="ab cl mx my hx mz" role="separator"><span class="na bw bk nb nc nd"/><span class="na bw bk nb nc nd"/><span class="na bw bk nb nc"/></div><div class="im in io ip iq"><h1 id="3cd2" class="lv lw it bd lx ly ne ma mb mc nf me mf jz ng ka mh kc nh kd mj kf ni kg ml mm bi translated">3.避免缩写</h1><pre class="kj kk kl km gt mn mo mp mq aw mr bi"><span id="fa08" class="ms lw it mo b gy mt mu l mv mw">let i = 0  -&gt;  <strong class="mo iu">let index = 0<br/></strong>let j = 0  -&gt;  <strong class="mo iu">let index2 = 0</strong></span></pre><p id="ee3e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">上面例子的第一部分看起来足够无辜了吧？用<code class="fe nk nl nm mo b">i</code>做索引变量有什么问题？</p><p id="ebae" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">问题是，当您需要范围内的另一个索引变量时，您会倾向于使用<code class="fe nk nl nm mo b">j</code>。</p><p id="cc79" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这是因为，尽管<code class="fe nk nl nm mo b">j</code>是一个自然进程，但你现在错误地暗示这些变量是一个序列的一部分，而<code class="fe nk nl nm mo b">i</code>实际上是<code class="fe nk nl nm mo b">index</code>的简称，<code class="fe nk nl nm mo b">j</code>代表<code class="fe nk nl nm mo b">index2</code>。</p><p id="9297" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">选择稍微宽一点的代码，给自己起一个更具描述性的名字。如果您正确地命名了变量和函数，那么您需要的内联文档就会少得多，因为在某种程度上，代码会自己编写文档。</p><pre class="kj kk kl km gt mn mo mp mq aw mr bi"><span id="9f8c" class="ms lw it mo b gy mt mu l mv mw">initAuth  -&gt;  <strong class="mo iu">initializeAuthentication</strong> or <strong class="mo iu">initiateAuthorization</strong></span></pre><p id="3d09" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我真的很不喜欢前缀<code class="fe nk nl nm mo b">init</code>，因为很难判断函数是启动了什么还是初始化了什么。我也避免使用缩写<code class="fe nk nl nm mo b">auth</code>,因为它可能适用于认证或授权。</p><p id="79fd" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">看上面的例子，如果您选择一个粗体名称，您不需要额外的文档来清楚地说明这些区别。</p></div><div class="ab cl mx my hx mz" role="separator"><span class="na bw bk nb nc nd"/><span class="na bw bk nb nc nd"/><span class="na bw bk nb nc"/></div><div class="im in io ip iq"><h1 id="9c92" class="lv lw it bd lx ly ne ma mb mc nf me mf jz ng ka mh kc nh kd mj kf ni kg ml mm bi translated">4.语法一致</h1><p id="7988" class="pw-post-body-paragraph kz la it lb b lc nn ju le lf no jx lh li np lk ll lm nq lo lp lq nr ls lt lu im bi translated">在英语语法中，有四种句子结构:</p><ul class=""><li id="ad4b" class="ns nt it lb b lc ld lf lg li nu lm nv lq nw lu nx ny nz oa bi translated">声明性:“项目延期。”</li><li id="c1a6" class="ns nt it lb b lc ob lf oc li od lm oe lq of lu nx ny nz oa bi translated">命令式:“告诉我为什么。”</li><li id="2d49" class="ns nt it lb b lc ob lf oc li od lm oe lq of lu nx ny nz oa bi translated">疑问:“你确定你想知道？”</li><li id="ec80" class="ns nt it lb b lc ob lf oc li od lm oe lq of lu nx ny nz oa bi translated">感叹:“是啊！”</li></ul><p id="c1ac" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">以下是代码中的这些结构:</p><ul class=""><li id="6675" class="ns nt it lb b lc ld lf lg li nu lm nv lq nw lu nx ny nz oa bi translated">声明性:<code class="fe nk nl nm mo b">userIsAuthenticated</code>(变量)</li><li id="6fb3" class="ns nt it lb b lc ob lf oc li od lm oe lq of lu nx ny nz oa bi translated">命令式:<code class="fe nk nl nm mo b">authenticateUser</code>(功能)</li><li id="6234" class="ns nt it lb b lc ob lf oc li od lm oe lq of lu nx ny nz oa bi translated">疑问:<code class="fe nk nl nm mo b">isUserAuthenticated</code>(不要用)</li><li id="e743" class="ns nt it lb b lc ob lf oc li od lm oe lq of lu nx ny nz oa bi translated">感叹号:<code class="fe nk nl nm mo b">AUTHENTICATION_ERROR</code>(常量)</li></ul><p id="683b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">陈述句陈述信息，所以对变量使用陈述句。</p><p id="2e0d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">因为祈使句能促使行动，所以把它们用作功能。</p><p id="e972" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">感叹句实际上并不存在于代码中，但认为常量属于这一类。</p><p id="6dc2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">最后，代码中的疑问结构可能会令人困惑，所以要避免使用它们。</p></div><div class="ab cl mx my hx mz" role="separator"><span class="na bw bk nb nc nd"/><span class="na bw bk nb nc nd"/><span class="na bw bk nb nc"/></div><div class="im in io ip iq"><h1 id="dd92" class="lv lw it bd lx ly ne ma mb mc nf me mf jz ng ka mh kc nh kd mj kf ni kg ml mm bi translated">5.名字的前缀/后缀</h1><h2 id="e905" class="ms lw it bd lx og oh dn mb oi oj dp mf li ok ol mh lm om on mj lq oo op ml oq bi translated"><strong class="ak">布尔型</strong></h2><p id="c8b6" class="pw-post-body-paragraph kz la it lb b lc nn ju le lf no jx lh li np lk ll lm nq lo lp lq nr ls lt lu im bi translated">帮助您清理命名约定的最有效的技巧之一是为特定的变量组保留某些前缀和后缀。</p><p id="53a9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">例如，我喜欢给我所有的布尔值加一个前缀:<code class="fe nk nl nm mo b">is</code>、<code class="fe nk nl nm mo b">can</code>或<code class="fe nk nl nm mo b">should</code>。</p><pre class="kj kk kl km gt mn mo mp mq aw mr bi"><span id="aaa8" class="ms lw it mo b gy mt mu l mv mw">let active = false  -&gt;  <strong class="mo iu">let isActive = false<br/></strong>let load = false    -&gt;  <strong class="mo iu">let canLoad = false<br/></strong>let render = false  -&gt;  <strong class="mo iu">let shouldRender = false</strong></span></pre><p id="06c3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">通过确保所有布尔变量都是前缀中表示的子组的一部分，我在调试时有了更多的信息来指导我。</p><h2 id="014b" class="ms lw it bd lx og oh dn mb oi oj dp mf li ok ol mh lm om on mj lq oo op ml oq bi translated">数组</h2><p id="78a5" class="pw-post-body-paragraph kz la it lb b lc nn ju le lf no jx lh li np lk ll lm nq lo lp lq nr ls lt lu im bi translated">有一个关于命名数组的共同协议；我们似乎都同意数组应该是多元的。我发现这种方法有一个弱点。</p><p id="6975" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">看看这个例子:</p><pre class="kj kk kl km gt mn mo mp mq aw mr bi"><span id="e4a9" class="ms lw it mo b gy mt mu l mv mw"><em class="nj">const </em>exchangeRates1 = {<br/>  EUR: {<br/>    CNY: 7.84,<br/>    GBP: 0.91,<br/>    INR: 79.42,<br/>    USD: 1.11,<br/>  },<br/>  USD: {<br/>    CNY: 7.06,<br/>    EUR: 0.90,<br/>    GBP: 0.82,<br/>    INR: 71.51,<br/>  },<br/>}<br/><br/><em class="nj">const </em>exchangeRates2 = {...}<br/><em class="nj">const </em>exchangeRates3 = {...}<br/><br/><em class="nj">const </em>exchangeRates = [<br/>  exchangeRates1,<br/>  exchangeRates2,<br/>  exchangeRates3,<br/>]</span></pre><p id="61b9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">数据表明名为<code class="fe nk nl nm mo b">exchangeRates{n}</code>的对象是值的集合，这很好。但是，我们的集合数组被命名为<code class="fe nk nl nm mo b">exchangeRates</code>，没有<code class="fe nk nl nm mo b">n</code>值，当你只看名字的时候，这可能会令人困惑。</p><p id="9502" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这个变量是否只代表一个汇率对象，也许是一个活动对象？它是object类型还是其他类型？我们应该如何暗示这是一个数组？</p><p id="9982" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">试试这个:</p><pre class="kj kk kl km gt mn mo mp mq aw mr bi"><span id="b3ef" class="ms lw it mo b gy mt mu l mv mw">exchangeRates  -&gt;  <strong class="mo iu">exchangeRatesSet</strong></span></pre><p id="974f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我使用后缀<code class="fe nk nl nm mo b">Set</code>来标识数组，而不是复数。这使得代码稍微宽一点，但是你可以在上面看到它是如何解决收集复数对象的问题的。</p><h2 id="c873" class="ms lw it bd lx og oh dn mb oi oj dp mf li ok ol mh lm om on mj lq oo op ml oq bi translated">功能</h2><p id="2ade" class="pw-post-body-paragraph kz la it lb b lc nn ju le lf no jx lh li np lk ll lm nq lo lp lq nr ls lt lu im bi translated">我用React和Redux做了很多我的专业工作，这个堆栈中我最喜欢的概念之一是<a class="ae ky" href="https://medium.com/@matthew.holman/what-is-a-redux-selector-a517acee1fe8" rel="noopener">选择器</a>。</p><p id="41ed" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">许多Redux程序员同意选择器应该以前缀<code class="fe nk nl nm mo b">get</code>开头，就像在<code class="fe nk nl nm mo b">getUserInfo</code>中一样，但没有深入研究。因此，不言而喻，非选择器函数名不应该以相同的前缀开头。</p><p id="5358" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我想进一步阐述那个原则。</p><p id="e055" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">几乎在我的每个React/Redux项目中，都有一个包含五到十五个函数的文件夹，我称之为<em class="nj">助手</em>，它们不是选择器、thunks、动作创建者或缩减者……它们没有真正的家。</p><p id="5015" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这些通常是纯函数，每个函数都执行一项任务。</p><p id="dc1f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">功能包括:</p><pre class="kj kk kl km gt mn mo mp mq aw mr bi"><span id="2e9f" class="ms lw it mo b gy mt mu l mv mw">isUserActive = user =&gt; {...}<br/>canLoadItem = item =&gt; {...}<em class="nj"><br/></em>makeFormattedDate = (date, format) =&gt; {...}<br/>sortActiveUsers = users =&gt; {...}<br/>validateEmailAddress = (address, validations) =&gt; {...}</span></pre><p id="01b6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我对这些辅助函数的存在没有意见，只要它们保持纯粹和简单。</p><p id="f784" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">然而，令我困扰的是，我不能一眼就识别出一个助手函数。</p><p id="aac4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">因此，我开始在我的所有助手函数前加上前缀<code class="fe nk nl nm mo b">determine</code>或<code class="fe nk nl nm mo b">prepare</code>，这取决于该函数返回的是布尔值还是数据。</p><pre class="kj kk kl km gt mn mo mp mq aw mr bi"><span id="fb8b" class="ms lw it mo b gy mt mu l mv mw">isUserActive          -&gt;  <strong class="mo iu">determineIsUserActive</strong><em class="nj"><br/></em>canLoadItem           -&gt;  <strong class="mo iu">determineCanLoadItem</strong><em class="nj"><br/></em>makeFormattedDate     -&gt;  <strong class="mo iu">prepareFormattedDate</strong><br/>sortActiveUsers       -&gt;  <strong class="mo iu">prepareSortedActiveUsers</strong><br/>validateEmailAddress  -&gt;  <strong class="mo iu">prepareValidEmailAddress</strong></span></pre><p id="175d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">通过确保我的所有助手函数都被命名为带有特定前缀的动词短语，我消除了语法一致性的挑战，同时也为我的助手函数开发了一种品牌，将它们与我的选择器和thunks分开。</p><p id="e2bb" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">另外，请注意我们是如何开始混合命令式、声明式和疑问式函数名称，并以所有命令式名称结束的。</p><p id="c7d2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">下面，我有两个<a class="ae ky" href="https://medium.com/@stowball/a-dummys-guide-to-redux-and-thunk-in-react-d8904a7005d3" rel="noopener"> Redux thunk </a>函数，一个调用另一个:</p><pre class="kj kk kl km gt mn mo mp mq aw mr bi"><span id="4426" class="ms lw it mo b gy mt mu l mv mw"><em class="nj">const </em><strong class="mo iu">fetchUserDataIfNeeded</strong> = userID =&gt; dispatch =&gt; {<br/>  <em class="nj">const </em>fetchIsNeeded = {...}</span><span id="3150" class="ms lw it mo b gy or mu l mv mw"><em class="nj">  if </em>(fetchIsNeeded) {<br/>    dispatch(<strong class="mo iu">fetchUserData</strong>(userID))<br/>  }<br/>}<br/><br/><em class="nj">const </em><strong class="mo iu">fetchUserData</strong> = userID =&gt; dispatch =&gt; {...}</span></pre><p id="dabb" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">通常，当使用异步获取时，您需要调用一个函数来确定是否需要获取或重新获取数据，如果是，那么条件函数将调用获取函数。</p><p id="7f20" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在我的Redux项目中，我对这些情况使用后缀<code class="fe nk nl nm mo b">IfNeeded</code>。现在，当我看到这个函数时，我知道我看到的是一个条件异步fetch thunk，这是一个函数名中要传递的大量元数据。</p></div><div class="ab cl mx my hx mz" role="separator"><span class="na bw bk nb nc nd"/><span class="na bw bk nb nc nd"/><span class="na bw bk nb nc"/></div><div class="im in io ip iq"><h1 id="cdd5" class="lv lw it bd lx ly ne ma mb mc nf me mf jz ng ka mh kc nh kd mj kf ni kg ml mm bi translated">结论</h1><p id="b09b" class="pw-post-body-paragraph kz la it lb b lc nn ju le lf no jx lh li np lk ll lm nq lo lp lq nr ls lt lu im bi translated">显然，我遗漏了太多东西，比如类应该如何成为名词，以及带有<code class="fe nk nl nm mo b">children</code>的<code class="fe nk nl nm mo b">parent</code>如何优于带有<code class="fe nk nl nm mo b">items</code>的<code class="fe nk nl nm mo b">list</code>等等……但我在六到八分钟的文章统计中茁壮成长。</p><p id="980e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">所以，请，我鼓励你们所有人挑战你们在这里看到的一切。找到自己的公式，只要找到一致性。</p></div></div>    
</body>
</html>