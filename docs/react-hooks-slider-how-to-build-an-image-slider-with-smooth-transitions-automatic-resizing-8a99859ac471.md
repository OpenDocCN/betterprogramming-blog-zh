# React Hooks Slider:如何构建一个具有平滑过渡和自动调整大小的图像滑块

> 原文：<https://betterprogramming.pub/react-hooks-slider-how-to-build-an-image-slider-with-smooth-transitions-automatic-resizing-8a99859ac471>

## 第三部分

![](img/95ae4d94d1c82987ced1cb2437cb792b.png)

图片来源:作者

在 React Hooks 滑块系列的第三部分中，我们将解决它的最后两个缺点:

*   当从最后一张幻灯片转到第一张幻灯片时，以及当从第一张幻灯片转到最后一张幻灯片时，消除了在中间幻灯片之间循环的必要性
*   不适应浏览器大小调整

我在本文末尾提供了本系列第一部分和第二部分的链接、包含代码和工作示例的资源库以及视频教程。

# 快速回顾

在第 2 部分的结尾，这是我们在`Slider`组件中结束的代码。

利用`useRef`和`useEffect`钩子创建自动播放功能非常简单。为了解决我上面列出的问题，我们将使用完全相同的方法。

在我们进入任何代码之前，我们需要先从概念上解决问题。让我们从如何渲染幻灯片开始吧。

顺便告诉你，我决定把我们的`activeIndex` 变量的名字改成`activeSlide`。我觉得更有道理。如果你是从零开始编写代码，确保重命名`Dots`组件上的 prop。从现在开始，任何代码片段都将使用新的变量名。

# 一次只能呈现三张幻灯片

现在，我们的滑块不是很有效，并把每张幻灯片都呈现到 DOM 中。我认为这违背了 React 方式，而且在此基础上，需要在我们的`nextSlide`和`prevSlide` 函数中编写一些令人困惑的逻辑。

为了方便起见，我们将一次呈现三张幻灯片。

# 创建一个数组来存储三张幻灯片

为了做到这一点，我们将从 props 中取出整个幻灯片数组，并设置一个名为`_slides`的内部状态变量，以包含初始渲染时的第一张幻灯片、第二张幻灯片和最后一张幻灯片。

但是，我们不会按这个顺序存储它们。相反，我们将按照以下顺序存储它们:

`[Last Slide, First Slide, Second Slide]`

接下来，浏览器中当前显示的幻灯片将始终是我们在阵列中间看到的幻灯片。如果这让你感到困惑，请允许我解释。

为了获得良好的来回切换效果，我们需要在浏览器中当前活动幻灯片的左侧和右侧各有一张幻灯片。因此，由三张幻灯片组成的数组(幻灯片存储在中间，作为显示的幻灯片)是有意义的。

然而，我们还没有完成。我们需要将初始翻译值设置为浏览器的当前宽度，而不是像现在这样设置为 0。这确保了我们在阵列的中间显示幻灯片。

# 更新阵列以包含正确的幻灯片

当我们向右或向左移动时，幻灯片的排列需要改变。我们可以创建一个函数来处理这个问题，但是在此之前，让我们思考一下这个函数到底需要做什么。

我想出了三种可能的情况，一旦滑块被使用，我们不再处于原始的初始渲染状态，我们需要考虑这三种情况。

1.  正在播放第一张幻灯片吗？
2.  正在播放最后一张幻灯片吗？
3.  上面的幻灯片都没有显示吗？

**如果第一张幻灯片正在显示**，更新数组以反映我们在初始渲染时设置的内容:

`[Last Slide, First Slide, Second Slide]`

**如果正在显示最后一张幻灯片**，将数组设置为:

`[Second To Last Slide, Last Slide, First Slide]`

**如果正在显示的幻灯片既不是第一张也不是最后一张**，则将数组设置为:

`[Previous Active Slide, Active Slide, Active Slide + 1]`

处理所有这三种情况应该会涵盖我们。但是，我也想清楚地表明，每当我们更新这个数组时，我们并不引用当前在`_slides`中的任何值来更新它:我们总是使用 props 中的数组来这样做。

既然我们已经对如何完成这一部分有了一个很好的想法，让我们在下一节实现这个函数

# 处理和禁用过渡

为了在幻灯片之间有一个很好的平滑过渡，我们需要确保在每张幻灯片过渡到视图之前，我们不会更新`_slides`数组。幸运的是，我们可以设置一个侦听器，每当它检测到转换完全完成时，就会触发我们的函数。

我们将使用`[transitionend](https://developer.mozilla.org/en-US/docs/Web/API/HTMLElement/transitionend_event)`事件。要做到这一点，我们可以创建一个 ref，就像我们对 autoplay 特性所做的那样。让我们创建这个 ref 并添加事件监听器。

您将看到我们将转换引用设置为一个名为`smoothTransition`函数。因为我们已经触及了我们的函数所涵盖的所有场景，这应该是有意义的。

其中一个棘手的部分是，当我们更新数组时，我们需要暂时消除过渡效果。如果我们不这样做，我们会得到一个奇怪的效果，当前幻灯片过渡到当前幻灯片。

因为我们正在更新数组，并在每次单击鼠标左键或右键时重置平移，所以我们不想得到我上面描述的效果。因此，我们可以通过在更新阶段将其值设置为 0 来禁用转换，然后立即重置。

我们可以在更新后通过创建一个简单的`useEffect`调用来重置 translate，该调用可以观察转换变量是否在重新渲染时发生变化。如果转换是 0，在我们更新了`smoothTransition`中的`_slides`数组之后，它将是 0，只需将它设置回它的初始值。

```
useEffect(() => { 
  if (transition === 0) setState({ …state, transition: 0.45 }) 
}, [transition])
```

让我们来看看更新后的`Slider` 组件的代码。

有了这些，我们就完成了过渡功能，可以进入最后一部分，处理浏览器的大小调整。

# 处理浏览器大小调整

这比你想象的要简单得多。我们只需要为`[resize](https://developer.mozilla.org/en-US/docs/Web/API/Window/resize_event)`事件设置一个监听器，并编写一个小函数，在 resize 事件结束时设置适当的 translate 值。为此，我们将创建另一个引用，并添加到一些现有的代码中。

请注意，我们在这里也将过渡设置为 0。这是必要的，因为每次调整浏览器大小时，当前显示的幻灯片将需要适应并转换到适当的位置。如果有一个过渡集…你现在应该知道了。

# 啊哦…我们的滑块里有一个 Bug

我们的调整大小功能非常棒！但是等等——当我们悬停在箭头上时，我们不是使用了过渡效果吗？这将导致一个非常有趣的副作用，如果我们悬停在箭头上(我们甚至不需要点击箭头)，我们将触发更新我们的`_slides`数组的函数。恐怖啊！

别担心，我的朋友们。我们可以在我们的`useEffect` 调用中用一些简单的条件逻辑和对我们的`SliderContent`组件的一些快速重构来解决这个问题。每当`transitionend`事件触发我们的`smoothTransition`函数时，我们将检查触发它的元素是否是`SliderContent` 组件。

下面我包含了对我们的`SliderContent`组件的重构。请注意它与我们之前的版本有什么不同。我这样做是因为情绪是如何在引擎盖下运作的。如果您不使用库的 styled 部分，而是自己创建一个 div，它会自动将一个带有您的组件名称的类添加到幕后的 div*。*这使得检查触发`transitionend`事件的元素是否是`SliderContent` *变得容易。*

如果你自己编码，不使用情感，只要确保给你的`SliderContent`组件添加一个`SliderContent`的`className`即可。

准备好之后，让我们检查滑块的最终代码。检查一下我们谈到的条件语句的`useEffect`调用中的`smooth`函数。

# React Hooks 图像滑块摘要

我们走吧，伙计们。我们已经到达了图像滑块旅程的终点，并将在不久的将来开始一些同样有趣的事情。

我很想听听你对下一步想看什么的建议。

非常感谢。

# 链接

第一部分。 [React 挂钩滑块:如何用 React 挂钩构建图像滑块](https://medium.com/better-programming/build-an-image-slider-with-react-es6-264368de68e4)

第二部分。 [React Hooks Slider:如何用 Autoplay 构建图像滑块](https://medium.com/p/c94deaf763c4/edit)

[GitHub 库](https://github.com/DZuz14/react-hooks-image-slider)