<html>
<head>
<title>Docker for Front-End Developers</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">面向前端开发人员的Docker</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/docker-for-front-end-developers-c758a44e622f?source=collection_archive---------2-----------------------#2019-08-13">https://betterprogramming.pub/docker-for-front-end-developers-c758a44e622f?source=collection_archive---------2-----------------------#2019-08-13</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/eff87723c2499160a3f29510e6ed1b18.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*Fm8aEndU5SU9pN2G"/></div></div><p class="jy jz gj gh gi ka kb bd b be z dk translated">照片由<a class="ae kc" href="https://unsplash.com/@cmventi20?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">卡梅隆通风</a>在<a class="ae kc" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</p></figure><p id="d363" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">作为一名前端web开发人员有时很困难，但我们通常喜欢它。今天的前端开发几乎提供了太多的东西——有时它会让人不知所措地思考下一步该学什么。Docker对我来说就是这样一种技术。虽然它已经存在了相当长一段时间，但我不愿意使用它。想知道我怎么想的吗？剧透:我喜欢。</p><h1 id="921f" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">介绍</h1><figure class="ma mb mc md gt jr gh gi paragraph-image"><div class="gh gi lz"><img src="../Images/c6e2b05f458b26fd8a957e9beac6e222.png" data-original-src="https://miro.medium.com/v2/resize:fit:672/format:webp/1*glD7bNJG3SlO0_xNmSGPcQ.png"/></div><p class="jy jz gj gh gi ka kb bd b be z dk translated"><a class="ae kc" href="https://www.docker.com/" rel="noopener ugc nofollow" target="_blank"> Docker </a>标志</p></figure><blockquote class="me mf mg"><p id="e400" class="kd ke mh kf b kg kh ki kj kk kl km kn mi kp kq kr mj kt ku kv mk kx ky kz la ij bi translated">“Docker是唯一一个独立的容器平台，支持组织在任何地方无缝地构建、共享和运行任何应用。”—通过Docker的<a class="ae kc" href="https://www.docker.com/why-docker" rel="noopener ugc nofollow" target="_blank">网站</a></p></blockquote><p id="a5cb" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">Docker的口头禅是:建造，运输，运行。简单来说，它是一个跨平台工具，旨在减轻构建、共享和部署应用程序的痛苦。</p><h1 id="2fd4" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">为什么是Docker？</h1><p id="6438" class="pw-post-body-paragraph kd ke iq kf b kg ml ki kj kk mm km kn ko mn kq kr ks mo ku kv kw mp ky kz la ij bi translated">在将时间投入到另一个工具之前，有必要先问一下为什么我们需要Docker？它解决什么问题？</p><p id="f66c" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">作为开发人员，如果我们在加入一家公司的第一天就可以专注于开发应用程序，而不是在安装/运行应用程序时花费数小时来解决一个愚蠢的版本问题，这不是很好吗？</p><p id="90d6" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如果只需要一个命令来构建和运行我们的整个项目，那不是很好吗？</p><p id="8852" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">Docker解决了以下痛点:</p><ul class=""><li id="0b37" class="mq mr iq kf b kg kh kk kl ko ms ks mt kw mu la mv mw mx my bi translated">开发/生产平价</li><li id="3281" class="mq mr iq kf b kg mz kk na ko nb ks nc kw nd la mv mw mx my bi translated">跨不同操作系统运行应用程序的不同环境</li><li id="421c" class="mq mr iq kf b kg mz kk na ko nb ks nc kw nd la mv mw mx my bi translated">从应用程序开发中分离基础设施</li><li id="5a09" class="mq mr iq kf b kg mz kk na ko nb ks nc kw nd la mv mw mx my bi translated">新开发人员的入职变得非常容易</li><li id="e506" class="mq mr iq kf b kg mz kk na ko nb ks nc kw nd la mv mw mx my bi translated">应用隔离—将DDoS攻击限制在一个容器内，负载平衡</li><li id="e7af" class="mq mr iq kf b kg mz kk na ko nb ks nc kw nd la mv mw mx my bi translated">调试功能</li></ul><h1 id="fee5" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">码头建筑</h1><figure class="ma mb mc md gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi ne"><img src="../Images/6b25deac96152c8dfeb2a7a50a2fd050.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*m8X00uwTA-WNja9Prbt2Ug.png"/></div></div><p class="jy jz gj gh gi ka kb bd b be z dk translated">Docker高级体系结构</p></figure><ul class=""><li id="7781" class="mq mr iq kf b kg kh kk kl ko ms ks mt kw mu la mv mw mx my bi translated">客户机-服务器体系结构</li><li id="ec4a" class="mq mr iq kf b kg mz kk na ko nb ks nc kw nd la mv mw mx my bi translated">客户端命令行界面(CLI)与Docker守护程序(服务器)对话</li><li id="6146" class="mq mr iq kf b kg mz kk na ko nb ks nc kw nd la mv mw mx my bi translated">守护进程构建、运行和管理Docker对象</li><li id="d73a" class="mq mr iq kf b kg mz kk na ko nb ks nc kw nd la mv mw mx my bi translated">守护进程和Docker客户端通过Unix套接字或网络接口使用Rest API进行通信</li><li id="b925" class="mq mr iq kf b kg mz kk na ko nb ks nc kw nd la mv mw mx my bi translated">Docker注册表存储Docker图像</li></ul><h2 id="743f" class="nf lc iq bd ld ng nh dn lh ni nj dp ll ko nk nl lp ks nm nn lt kw no np lx nq bi translated">码头引擎</h2><figure class="ma mb mc md gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi nr"><img src="../Images/d851f4b5c80f30f228f22eb93f84ceb4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*uEtAhWOHVMFo5kRUnhKNBg.png"/></div></div><p class="jy jz gj gh gi ka kb bd b be z dk translated">Docker引擎架构</p></figure><ul class=""><li id="447f" class="mq mr iq kf b kg kh kk kl ko ms ks mt kw mu la mv mw mx my bi translated">Docker CLI客户机对Docker守护进程服务器进行REST API调用</li><li id="5271" class="mq mr iq kf b kg mz kk na ko nb ks nc kw nd la mv mw mx my bi translated">Docker对请求做出响应，并通过gRPC协议将消息传递给<code class="fe ns nt nu nv b">containerd</code>流程，从而启动一个容器</li><li id="862d" class="mq mr iq kf b kg mz kk na ko nb ks nc kw nd la mv mw mx my bi translated"><code class="fe ns nt nu nv b">containerd</code> <strong class="kf ir"> </strong>管理图像和容器的生命周期:停止、暂停、开始、删除</li><li id="7c6e" class="mq mr iq kf b kg mz kk na ko nb ks nc kw nd la mv mw mx my bi translated"><code class="fe ns nt nu nv b">containerd</code>为新容器分叉<code class="fe ns nt nu nv b">runc</code>的实例</li><li id="302a" class="mq mr iq kf b kg mz kk na ko nb ks nc kw nd la mv mw mx my bi translated"><code class="fe ns nt nu nv b">runc</code> <strong class="kf ir"> </strong>流程创建容器后退出</li><li id="20fe" class="mq mr iq kf b kg mz kk na ko nb ks nc kw nd la mv mw mx my bi translated"><code class="fe ns nt nu nv b">shim</code>成为正在运行的容器的父容器</li></ul><h2 id="d245" class="nf lc iq bd ld ng nh dn lh ni nj dp ll ko nk nl lp ks nm nn lt kw no np lx nq bi translated">Docker与完全虚拟化</h2><figure class="ma mb mc md gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi nw"><img src="../Images/4a4c82645d11be12927ce6107c6f44c0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*1YwHX2o8HHR90tdbU8eglA.png"/></div></div><p class="jy jz gj gh gi ka kb bd b be z dk translated">Docker与完全虚拟化</p></figure><p id="bb54" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">Docker使用的虚拟化技术是一种称为操作系统级虚拟化或基于容器的虚拟化，这与使用VirtualBox或VMware完成的模拟或完全虚拟化<strong class="kf ir"> </strong>形成对比。</p><p id="f66e" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">完全虚拟化完全在主机操作系统之上运行来宾操作系统。存在系统资源开销，因此，您将体验到缓慢的性能。</p><p id="83c2" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在基于容器的虚拟化中，现有主机操作系统的一部分用于隔离运行您的应用程序。这些部分被称为容器，非常轻量级，这意味着我们可以运行多个容器。他们中的每一个都将运行一个操作系统，包含基本的裸原语，没有内核代码或用户界面。</p><p id="afde" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，在Docker中运行一个Ubuntu容器大约需要188 MB(相比之下，全盛时期需要800 MB)。尺寸的减小可以部分归因于删除了Ubuntu内核和Ubuntu UI的代码。Docker将在主机操作系统上转发该容器中运行的所有命令。这使得docker变得非常轻便和高效。</p><figure class="ma mb mc md gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi nx"><img src="../Images/91ea32a9b0061e0185c92cf8607746f3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*T4FexlHjGZcZ5FMPqTdqPw.png"/></div></div><p class="jy jz gj gh gi ka kb bd b be z dk translated">缩小尺寸的图像</p></figure></div><div class="ab cl ny nz hu oa" role="separator"><span class="ob bw bk oc od oe"/><span class="ob bw bk oc od oe"/><span class="ob bw bk oc od"/></div><div class="ij ik il im in"><h1 id="6185" class="lb lc iq bd ld le of lg lh li og lk ll lm oh lo lp lq oi ls lt lu oj lw lx ly bi translated">Docker图像</h1><ul class=""><li id="f155" class="mq mr iq kf b kg ml kk mm ko ok ks ol kw om la mv mw mx my bi translated">用于创建容器的只读模板</li><li id="aadb" class="mq mr iq kf b kg mz kk na ko nb ks nc kw nd la mv mw mx my bi translated">一堆文件和一份清单</li><li id="6dcb" class="mq mr iq kf b kg mz kk na ko nb ks nc kw nd la mv mw mx my bi translated">构建时构造</li><li id="5180" class="mq mr iq kf b kg mz kk na ko nb ks nc kw nd la mv mw mx my bi translated">在删除图像的所有容器之前，无法删除图像</li><li id="682d" class="mq mr iq kf b kg mz kk na ko nb ks nc kw nd la mv mw mx my bi translated">使用Dockerfile构建</li><li id="ca21" class="mq mr iq kf b kg mz kk na ko nb ks nc kw nd la mv mw mx my bi translated">多层:每一层都是前一层的延伸</li><li id="f320" class="mq mr iq kf b kg mz kk na ko nb ks nc kw nd la mv mw mx my bi translated">每一层都有应用程序二进制文件、文件系统和库</li></ul><figure class="ma mb mc md gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi on"><img src="../Images/b49de881f0e6f99e4ceb206b80fbfe50.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*IzXW9q4OEBeli1rxKR4vkQ.png"/></div></div></figure><p id="3578" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">清单文件如下所示:</p><figure class="ma mb mc md gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi oo"><img src="../Images/6702f481c468add187aa19fbf06dd08f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*jOhRcMyUi0hxVycP7I_GGQ.png"/></div></div></figure><h1 id="27aa" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">码头集装箱</h1><figure class="ma mb mc md gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi op"><img src="../Images/350df9c6ec28d0afc62f791ff06479b8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*bvnHtNKBLONsSdvF4pTMtw.png"/></div></div></figure><ul class=""><li id="c598" class="mq mr iq kf b kg kh kk kl ko ms ks mt kw mu la mv mw mx my bi translated">它们是我们的应用程序运行的运行时构造</li><li id="442a" class="mq mr iq kf b kg mz kk na ko nb ks nc kw nd la mv mw mx my bi translated">容器在映像文件系统之上添加了一个运行时读写层</li><li id="cc9c" class="mq mr iq kf b kg mz kk na ko nb ks nc kw nd la mv mw mx my bi translated">运行时所做的所有更改都是在顶部可写层中进行的</li><li id="4da7" class="mq mr iq kf b kg mz kk na ko nb ks nc kw nd la mv mw mx my bi translated">可以保存这些更改并提交以创建新的映像。</li></ul><h1 id="f99f" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">将应用程序容器化— Dockerfile</h1><figure class="ma mb mc md gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi oq"><img src="../Images/be2ab965f39c0ad817d2aff764517368.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*DdgfO4jcSVDlqQwL8U2REQ.png"/></div></div></figure><ul class=""><li id="373a" class="mq mr iq kf b kg kh kk kl ko ms ks mt kw mu la mv mw mx my bi translated">为应用程序创建Dockerfile</li><li id="293e" class="mq mr iq kf b kg mz kk na ko nb ks nc kw nd la mv mw mx my bi translated">使用它建立一个Docker映像</li><li id="fdb7" class="mq mr iq kf b kg mz kk na ko nb ks nc kw nd la mv mw mx my bi translated">运行Docker映像来运行应用程序的容器</li></ul><figure class="ma mb mc md gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi or"><img src="../Images/8c619ce14fd53553568e67365e56b865.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*9uQB01maFeiqC8EybMZ4TA.png"/></div></div><p class="jy jz gj gh gi ka kb bd b be z dk translated">Dockerfile文件</p></figure><p id="facc" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><strong class="kf ir">解释</strong></p><ul class=""><li id="ecb2" class="mq mr iq kf b kg kh kk kl ko ms ks mt kw mu la mv mw mx my bi translated"><code class="fe ns nt nu nv b">FROM</code>指令通常是Dockerfile文件中的第一条指令。它告诉Docker您想要在哪个基础图像上构建您的自定义图像。我们使用的是<a class="ae kc" href="https://alpinelinux.org/" rel="noopener ugc nofollow" target="_blank"> Alpine </a>，一个非常轻量级的Linux发行版，上面安装了一个节点。</li><li id="05c7" class="mq mr iq kf b kg mz kk na ko nb ks nc kw nd la mv mw mx my bi translated"><code class="fe ns nt nu nv b">WORKDIR</code>是一种非常方便的定义工作目录的方式。它将与后续的<code class="fe ns nt nu nv b">RUN</code>、<code class="fe ns nt nu nv b">CMD</code>、<code class="fe ns nt nu nv b">ENTRYPOINT</code>、<code class="fe ns nt nu nv b">COPY</code>和<code class="fe ns nt nu nv b">ADD</code>指令一起使用。</li><li id="2b1d" class="mq mr iq kf b kg mz kk na ko nb ks nc kw nd la mv mw mx my bi translated"><code class="fe ns nt nu nv b">COPY</code> <strong class="kf ir"> </strong>命令只是将文件或目录从主机系统复制到正在构建的Docker映像。</li><li id="5b8e" class="mq mr iq kf b kg mz kk na ko nb ks nc kw nd la mv mw mx my bi translated"><code class="fe ns nt nu nv b">RUN</code>命令在构建映像时运行任何shell命令，并将结果(文件)作为一个层提交或添加到映像中。</li><li id="92fb" class="mq mr iq kf b kg mz kk na ko nb ks nc kw nd la mv mw mx my bi translated"><code class="fe ns nt nu nv b">EXPOSE</code> <strong class="kf ir"> </strong>告诉用户当我们从这个映像运行一个容器时，我们的应用程序将在哪个端口上运行。我们可以在运行时映射到主机端口。</li><li id="8441" class="mq mr iq kf b kg mz kk na ko nb ks nc kw nd la mv mw mx my bi translated"><code class="fe ns nt nu nv b">CMD</code> <strong class="kf ir"> </strong>指令告诉从这个图像启动容器时运行哪个命令。与<code class="fe ns nt nu nv b"><strong class="kf ir">RUN</strong></code> <strong class="kf ir"> </strong>指令不同，它不会在映像构建步骤中执行。因此，像启动服务器或服务这样的事情将驻留在其中。</li></ul><p id="25c7" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">要从Dockerfile文件构建映像，请运行build命令，如下所示:</p><figure class="ma mb mc md gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi os"><img src="../Images/221f761c408bef8eb0124efd540cd395.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*7oBU-JYPztAUm7ilqgJyoA.png"/></div></div><p class="jy jz gj gh gi ka kb bd b be z dk translated">Docker构建命令</p></figure><ul class=""><li id="4e93" class="mq mr iq kf b kg kh kk kl ko ms ks mt kw mu la mv mw mx my bi translated"><code class="fe ns nt nu nv b">--rm</code>标志意味着删除由于docker文件中的任何<code class="fe ns nt nu nv b">RUN</code>指令而运行的任何中间容器。在成功构建之后，他们致力于构建的形象。这个标志确保它们最终被删除。</li><li id="e689" class="mq mr iq kf b kg mz kk na ko nb ks nc kw nd la mv mw mx my bi translated"><code class="fe ns nt nu nv b">-t</code>标志用于指定正在构建的图像的名称和标签。默认情况下，如果<code class="fe ns nt nu nv b">tagname</code>没有通过，则分配最新的</li><li id="99f8" class="mq mr iq kf b kg mz kk na ko nb ks nc kw nd la mv mw mx my bi translated"><code class="fe ns nt nu nv b">-f</code>标志用于指定Dockerfile的路径。如果图像的名称不同于Dockerfile，或者它存在于当前目录之外的某个目录中，这很有帮助。</li><li id="e4ae" class="mq mr iq kf b kg mz kk na ko nb ks nc kw nd la mv mw mx my bi translated">最后，我们需要提供上下文目录的路径。这很重要，因为上下文目录中的所有内容都被复制或发送到Docker守护进程。</li></ul><blockquote class="me mf mg"><p id="f427" class="kd ke mh kf b kg kh ki kj kk kl km kn mi kp kq kr mj kt ku kv mk kx ky kz la ij bi translated"><strong class="kf ir"> <em class="iq">提示:</em> </strong> <em class="iq">在嵌套项目的情况下(比如Lerna)，不要选择项目的根作为Docker上下文。它会不必要地复制整个项目，这会花费大量的时间和空间。明确你想从事的工作。</em></p></blockquote><p id="f844" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">另外，通过使用<code class="fe ns nt nu nv b"><strong class="kf ir">.dockerignore</strong></code> <strong class="kf ir"> </strong>文件，您可以选择哪些文件不要从Docker上下文复制到守护进程。这有助于加快构建时间，从而创建更小的图像。</p><figure class="ma mb mc md gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi or"><img src="../Images/719a6df908605ce1c2a44a9be056fb2c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*CiLkXMLmq7Q2NapdwaORTQ.png"/></div></div><p class="jy jz gj gh gi ka kb bd b be z dk translated">。dockerignore</p></figure><h2 id="ca01" class="nf lc iq bd ld ng nh dn lh ni nj dp ll ko nk nl lp ks nm nn lt kw no np lx nq bi translated">运行容器</h2><figure class="ma mb mc md gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi ot"><img src="../Images/51396342e69e345a5dad4b48f4522598.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*KOvBhQkeVTcsUfDfwlzNmw.png"/></div></div></figure><p id="387b" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">Docker <code class="fe ns nt nu nv b">run</code>命令使用起来非常简单。<code class="fe ns nt nu nv b"><strong class="kf ir">-p</strong></code> <strong class="kf ir"> </strong>标志用于指定端口映射。这里，容器的3000端口将被映射到主机系统的8080端口。这意味着你可以在mac上访问<code class="fe ns nt nu nv b">localhost:8080</code>上的应用程序。</p><p id="7f47" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">要查看正在运行的容器列表，请运行<code class="fe ns nt nu nv b">docker ps</code>。</p><figure class="ma mb mc md gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi ou"><img src="../Images/6d688c6b86d53c0299e96ec4b63971b1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*92dW554sqYWqqM5EUwQ7Aw.png"/></div></div></figure><p id="7a1e" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">顺便说一下，如果您想登录到正在运行的容器的shell中，您可以使用带有<code class="fe ns nt nu nv b">-it</code> <strong class="kf ir"> </strong>标志的Docker execute命令来实现。并且可以通过<code class="fe ns nt nu nv b">sh</code>传递最后一个ARG作为想要使用的shell。</p><figure class="ma mb mc md gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi ov"><img src="../Images/4bdc6c046d358f5e7eaab3e055bac115.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*KnmiP4L9GB7KJ8fHx7ToHg.png"/></div></div></figure><h1 id="ccea" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">Docker撰写</h1><ul class=""><li id="5f25" class="mq mr iq kf b kg ml kk mm ko ok ks ol kw om la mv mw mx my bi translated">用于定义和运行多容器Docker应用程序</li><li id="84dc" class="mq mr iq kf b kg mz kk na ko nb ks nc kw nd la mv mw mx my bi translated">用于启动、停止、暂停等的命令。一次所有容器</li></ul><figure class="ma mb mc md gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi ow"><img src="../Images/18652a6f3a12989bd9eb8768ac744e76.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*KxfWWAnRQWDWMXNUaIQ_Aw.png"/></div></div></figure><h1 id="3992" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">Docker卷</h1><ul class=""><li id="3319" class="mq mr iq kf b kg ml kk mm ko ok ks ol kw om la mv mw mx my bi translated">持久存储Docker容器生成和使用的数据的首选机制</li><li id="920d" class="mq mr iq kf b kg mz kk na ko nb ks nc kw nd la mv mw mx my bi translated">将目录或文件从主机装载/映射到容器</li><li id="e60f" class="mq mr iq kf b kg mz kk na ko nb ks nc kw nd la mv mw mx my bi translated">为容器创建共享空间或目录</li></ul><figure class="ma mb mc md gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi or"><img src="../Images/6d3dea4c358b0402b7996d480f30679a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*TVsu1jiR2L-H5EfSuOO7og.png"/></div></div><p class="jy jz gj gh gi ka kb bd b be z dk translated">运行Docker <code class="fe ns nt nu nv b">run</code>命令时，将主机目录作为卷挂载到容器中</p></figure><figure class="ma mb mc md gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi ox"><img src="../Images/08fa5ccd15b016e09ca51da88b3d0e6d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*-b8XTQGesgRJzpl9GJbBGg.png"/></div></div><p class="jy jz gj gh gi ka kb bd b be z dk translated">在docker-compose.yml文件中挂载src文件夹</p></figure><p id="61f0" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">当您在开发环境中运行您的应用程序以使用启用了热重载的webpack-dev-server时，这非常有用。您可以将应用程序的src目录映射到运行webpack-dev-server的容器。这样，您在主机中对src目录所做的任何更改都将覆盖该目录的内容，这将触发热模块更换(HMR)过程以进行热重装。</p><h1 id="9062" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">演示</h1><p id="bfca" class="pw-post-body-paragraph kd ke iq kf b kg ml ki kj kk mm km kn ko mn kq kr ks mo ku kv kw mp ky kz la ij bi translated">工作演示可以在GitHub上找到:<a class="ae kc" href="https://github.com/paramsinghvc/react-express-docker" rel="noopener ugc nofollow" target="_blank">https://github.com/paramsinghvc/react-express-docker</a></p><h1 id="84a4" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">摘要</h1><p id="00bc" class="pw-post-body-paragraph kd ke iq kf b kg ml ki kj kk mm km kn ko mn kq kr ks mo ku kv kw mp ky kz la ij bi translated">我们学到的还不止这些。有大量的选项和标志来运行/配置您的构建和容器。通过本指南，我们已经学会了如何在日常项目中使用Docker。这就像添加一个Dockerfile文件、构建一个映像并在其中运行一个容器一样简单。请务必查看我在上面添加的演示链接，看看如何在开发环境中使用它。</p></div></div>    
</body>
</html>