<html>
<head>
<title>Just Enough Swift for React Native Developers</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">对于React本地开发人员来说足够快</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/just-enough-swift-for-react-native-developers-aeef8bc79010?source=collection_archive---------20-----------------------#2019-09-30">https://betterprogramming.pub/just-enough-swift-for-react-native-developers-aeef8bc79010?source=collection_archive---------20-----------------------#2019-09-30</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="7e0c" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">Xcode和Swift的核心概念</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/c4260466d8a326b33193fdc57d58b269.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*pWpybiYgA_z9Zlg150ljQg.jpeg"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">由<a class="ae ky" href="https://unsplash.com/@goshua13?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">约书亚·阿拉贡</a>在<a class="ae ky" href="https://unsplash.com/s/photos/reactjs?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</p></figure><p id="435a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">那么，你是一个React本地开发人员。这意味着你生活在JavaScript中。这意味着你不太喜欢Objective-C。这意味着你爱斯威夫特。</p><p id="e350" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">你在这里是因为你想用Swift在React Native里写原生代码。</p><p id="a7ca" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">但是你对这个新世界没有信心。“var”和“let”关键字看起来很熟悉，但工作方式并不熟悉。感叹号是什么？什么是问号？哇，双问号？参数前加下划线？什么是弱关键词？什么是懒？</p><p id="41c8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我很懒，所以我不想学那些。我就是想学够Swift给React Native写点原生代码。那么，让我们开始…</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><p id="4584" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">首先，Swift中的“var”是“let”，“let”是“const”。所以你不能这么做。</p><pre class="kj kk kl km gt mc md me mf aw mg bi"><span id="01e0" class="mh mi it md b gy mj mk l ml mm">let k = 1<br/>k = 2   // Cannot assign to value: 'k' is a 'let' constant</span></pre><p id="2e7b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">你需要用“var”代替“let”，基本上。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="893d" class="mn mi it bd mo mp mq mr ms mt mu mv mw jz mx ka my kc mz kd na kf nb kg nc nd bi translated"><strong class="ak">类别和功能</strong></h1><p id="296a" class="pw-post-body-paragraph kz la it lb b lc ne ju le lf nf jx lh li ng lk ll lm nh lo lp lq ni ls lt lu im bi translated">有人说Swift是功能性的，有人说是面向对象的，有人说是多范式的。可能最后一个是真的，但是作为一个JavaScript开发人员，它看起来像面向对象，因为你将为iOS创建本地组件，感觉就像你在编写类并从中创建实例。您创建类似于其他OO语言的类，但是创建没有“new”关键字的实例。构造函数方法不是类名，而是所有类的“init”。我们也可以重载构造函数，如果类有一个超类就覆盖它。</p><pre class="kj kk kl km gt mc md me mf aw mg bi"><span id="dd14" class="mh mi it md b gy mj mk l ml mm"><strong class="md iu">class</strong> MyAwesomeClass {<br/>  var k: Int = 0<br/>  init(){<br/>    self.k = 1<br/>  }<br/>  init(newK: Int){<br/>    self.k = newK<br/>  }<br/>}<br/>let a = MyAwesomeClass()<br/>print(a.k) // prints 1<br/>let b= MyAwesomeClass(newK: 12)<br/>print(b.k) // prints 12</span></pre><p id="cc00" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这是很明显的。不明显的是，为什么我需要将标签“newK”放在参数本身之前。那就是Swift 3+。您必须将参数名与值一起使用。所以看看下面的代码:</p><pre class="kj kk kl km gt mc md me mf aw mg bi"><span id="53e6" class="mh mi it md b gy mj mk l ml mm"><strong class="md iu">func</strong> sum(a: Int, b: Int) -&gt; Int {<br/>  <strong class="md iu">return</strong> a+b<br/>}</span><span id="5bc8" class="mh mi it md b gy nj mk l ml mm"><strong class="md iu">let</strong> c = sum(3,5)      // Missing argument labels 'a:b:' in call</span><span id="17bd" class="mh mi it md b gy nj mk l ml mm">let d = sum(a:3, b:5) // This will work<br/>print(c)              // prints 8</span></pre><p id="e164" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我确信在某个地方，一旦我使用了类似<code class="fe nk nl nm md b">sum(3,4)</code>的功能，它就工作了。是的，它有时会起作用——但是什么时候呢？</p><pre class="kj kk kl km gt mc md me mf aw mg bi"><span id="9e8f" class="mh mi it md b gy mj mk l ml mm"><strong class="md iu">func</strong> sum(_ a: Int, _ b: Int) -&gt; Int {<br/>  <strong class="md iu">return</strong> a+b<br/>}</span></pre><p id="04f3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><em class="nn">仅当参数名前使用下划线时，</em>同上。现在使用<code class="fe nk nl nm md b">sum(3,5)</code>的函数调用可以工作了。所以我们也揭示了Swift的一个奥秘:下划线。以下划线开头的参数名将被忽略，因此可以在没有参数名的情况下调用它们。</p><p id="3c9c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">顺便说一下“→ Int”在某些语言中不是箭头函数或lambda。这是函数的返回类型。对于void不要使用任何东西。</p><p id="ef11" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">Swift还支持可变数量的参数。例如，要编写一个像“sum(3，5，6，8)”这样的函数，你不需要重载很多函数。查看下面的示例:</p><pre class="kj kk kl km gt mc md me mf aw mg bi"><span id="d328" class="mh mi it md b gy mj mk l ml mm">func sum(_ nums: Int...) -&gt; Int {<br/>    var total = 0<br/>    nums.forEach { (val) in<br/>        total += val<br/>    }<br/>    return total<br/>}<br/><br/>let t = sum(1,2,3,4,5,6,7)<br/>print(t)</span></pre><p id="ae3d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">有时在参数名之前，你会看到另一个参数名。起初你可能会认为这是一个有特殊用途的保留词。然后你看到它很多不同的词，所以你认为它不是一个保留词。你会意识到这叫做参数标签。以下示例中的“to”是一个参数标签:</p><pre class="kj kk kl km gt mc md me mf aw mg bi"><span id="63f0" class="mh mi it md b gy mj mk l ml mm"><strong class="md iu">class</strong> Building {<br/>  <strong class="md iu">var</strong> color: String = "red"<br/>  <strong class="md iu">func</strong> changeColor(to newColor:String){<br/>    <strong class="md iu">self</strong>.color = newColor<br/>  }<br/>}</span><span id="5251" class="mh mi it md b gy nj mk l ml mm"><strong class="md iu">var</strong> building = Building()<br/>print(building.color)              // prints red<br/>building.changeColor(to: "yellow")<br/>print(building.color)              // prints yellow</span></pre><p id="d67a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">当你调用函数时，你使用“to”作为变量名，但是在函数内部，“to”变成了“newColor”。说实话，我觉得这个没啥用。这看起来像是从Objective-C中采用的一个不必要的特性。它应该使函数调用更容易被人理解。我不得不说这听起来确实像“把颜色改成黄色”。相当可读…但那是给人类看的，我是个开发者！我为什么需要这样的东西？这让我很困惑。但这只是我的看法。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="14b9" class="mn mi it bd mo mp mq mr ms mt mu mv mw jz mx ka my kc mz kd na kf nb kg nc nd bi translated"><strong class="ak">选项</strong></h1><p id="8354" class="pw-post-body-paragraph kz la it lb b lc ne ju le lf nf jx lh li ng lk ll lm nh lo lp lq ni ls lt lu im bi translated">Swift中最引人注目的可能是选件。有两种类型的选项。感叹号和问号。</p><p id="26ae" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">为了让变量中的值为零，您需要将它们定义为可选变量。问号选项更安全，但需要在访问它们之前解开。感叹号选项可以赋值为nil，但是当你访问它们的时候，你需要确保它们不为nil，否则你的应用会崩溃。</p><p id="8c59" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">下面的代码片段可以编译，但是在运行时会崩溃。因为选项已经被展开了，所以只有当你知道它们有值的时候才可以安全的使用它们。</p><pre class="kj kk kl km gt mc md me mf aw mg bi"><span id="589d" class="mh mi it md b gy mj mk l ml mm"><strong class="md iu">var</strong> number: Int! = <strong class="md iu">nil</strong></span><span id="90e1" class="mh mi it md b gy nj mk l ml mm">var result = number * 2</span><span id="f9ea" class="mh mi it md b gy nj mk l ml mm">// error: Execution was interrupted, reason: EXC_BAD_INSTRUCTION (code=EXC_I386_INVOP, subcode=0x0).<br/></span></pre><p id="51c1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">但是这段代码甚至无法编译:</p><pre class="kj kk kl km gt mc md me mf aw mg bi"><span id="bc5d" class="mh mi it md b gy mj mk l ml mm"><strong class="md iu">var</strong> number: Int? = <strong class="md iu">nil</strong></span><span id="e2e5" class="mh mi it md b gy nj mk l ml mm">print(number*2)</span><span id="d1db" class="mh mi it md b gy nj mk l ml mm">// Value of optional type 'Int?' must be unwrapped to a value of type 'Int'</span></pre><p id="8d31" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">Xcode会给你提示。使用“？”强制展开或合并。?"</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi no"><img src="../Images/42afa973db36ce0382683f471f2b9942.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*qqgD1wuKwXvjy1XXckBIQg.png"/></div></div></figure><p id="1dce" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果您强制unwrap，它将编译，但在运行时崩溃，因为它没有一个值。首先确保它有一个值，然后打开它。像这样:</p><pre class="kj kk kl km gt mc md me mf aw mg bi"><span id="63e9" class="mh mi it md b gy mj mk l ml mm"><strong class="md iu">var</strong> number: Int? = <strong class="md iu">nil<br/></strong>number<strong class="md iu"> </strong>= 2</span><span id="cdba" class="mh mi it md b gy nj mk l ml mm">print(number*2) // 4</span></pre><p id="a2fa" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">另一种选择是使用“？?"。这是JavaScript开发人员非常熟悉的。它与“||”非常相似。以下片段几乎完全相同:</p><pre class="kj kk kl km gt mc md me mf aw mg bi"><span id="364c" class="mh mi it md b gy mj mk l ml mm">// JavaScript code below<br/>let number = undefined<br/>const newNum = number || 0</span><span id="5142" class="mh mi it md b gy nj mk l ml mm">// Swift Code below<br/>let number: Int? = nil<br/>let newNum = number ?? 0</span></pre><h2 id="f064" class="mh mi it bd mo np nq dn ms nr ns dp mw li nt nu my lm nv nw na lq nx ny nc nz bi translated"><strong class="ak">可选链接</strong></h2><p id="9dab" class="pw-post-body-paragraph kz la it lb b lc ne ju le lf nf jx lh li ng lk ll lm nh lo lp lq ni ls lt lu im bi translated">如果你在JavaScript中使用过babel，那么你很有可能使用了“tc39/proposal-optional-chaining ”,它很有可能在未来成为JavaScript的标准。Swift已经内置了这一功能。</p><p id="ec51" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">看看下面的例子。这可能会导致Xcode给出一些(可忽略的)警告，但完全没问题。它会编译，不会抛出任何运行时错误。</p><pre class="kj kk kl km gt mc md me mf aw mg bi"><span id="1198" class="mh mi it md b gy mj mk l ml mm">class City {<br/>    var name = "BigCity"       <br/>}</span><span id="516d" class="mh mi it md b gy nj mk l ml mm">class Town{<br/>    var name = "BigTown"<br/>    var city: City?   <br/>}</span><span id="71b0" class="mh mi it md b gy nj mk l ml mm">let town = Town()</span><span id="eb21" class="mh mi it md b gy nj mk l ml mm">print(town.city?.name) // Ignored<br/>town.city = City()<br/>print(town.city?.name) // Prints BigCity</span></pre></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="7cd9" class="mn mi it bd mo mp mq mr ms mt mu mv mw jz mx ka my kc mz kd na kf nb kg nc nd bi translated"><strong class="ak">目标-C </strong></h1><p id="d3b7" class="pw-post-body-paragraph kz la it lb b lc ne ju le lf nf jx lh li ng lk ll lm nh lo lp lq ni ls lt lu im bi translated">我知道你不喜欢Objective-C，但是在React Native中这是无法避免的。然而，你<em class="nn">可以</em>最小化它。我说的不是AppDelegate.m文件—在大多数情况下，您甚至不需要接触它。我说的是你自己的原生代码。</p><p id="7494" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">你不需要用Objective-C写完整的类或函数，你可以用Swift全部写出来。但是，您需要用Objective-C将它们导出到JavaScript。因此，您可以将它们视为接口。在Swift中，你只需要将它们标记为可导出到Objective-C，并从那里导出到JavaScript。您可以通过使用“@objc”属性来标记可导出的函数或类——这不是React本机特定的属性:任何同时使用Swift和Objective-C的Xcode项目都可以使用它。</p><p id="3392" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">有两种不同的本机模块。其中之一是UI组件，我们在其中实现了从UIView派生的可视化组件。另一种是我们所说的无头组件，它没有UI，但可以执行播放音频、管理通知、处理GPS等任务。</p><h2 id="45fe" class="mh mi it bd mo np nq dn ms nr ns dp mw li nt nu my lm nv nw na lq nx ny nc nz bi translated"><strong class="ak"> UI原生模块</strong></h2><p id="a423" class="pw-post-body-paragraph kz la it lb b lc ne ju le lf nf jx lh li ng lk ll lm nh lo lp lq ni ls lt lu im bi translated">假设我们想要实现一个地图(Google maps，MapBox，TomTom等)SDK。我们想在地图上添加标记，当它准备好时，我们在本机端调用一个直接/命令函数。大概是这样的:</p><pre class="kj kk kl km gt mc md me mf aw mg bi"><span id="d9e8" class="mh mi it md b gy mj mk l ml mm">/// JavaScript<br/>import { NativeModules} from 'react-native'<br/>const locateUser = () =&gt; {<br/>  NativeModules.MapViewController.locateUser([0,0])</span><span id="7f8b" class="mh mi it md b gy nj mk l ml mm">}</span><span id="2444" class="mh mi it md b gy nj mk l ml mm">&lt;Map<br/>    markers={[{lat: 100, lng:100}, {lat: -50, lng:50}]}<br/>    onMapReady={ this.locateUser }<br/>/&gt;</span></pre><p id="be2d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">通常我们需要这些组件:</p><p id="fd85" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu">视图控制器:</strong>(或视图管理器)从RCTViewManager派生的类，标记为“@objc”。使用RCT外部模块导出视图控制器。</p><p id="cac4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu">视图:</strong>由UIView派生的类，由视图控制器中的View()函数返回。视图未被导出，因为它们已经随控制器一起提供。</p><p id="de21" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu">查看属性:</strong>变量或函数(用objc标记)。这些是从JavaScript发出的React道具。函数意味着它是一个回调函数，并且它们的类型总是RCTDirectEventBlock。如果它是一个变量，它可以是一个简单的对象(如字符串或整数)，数组(NSArray)或JSON对象(NSDictionary)。</p><p id="e0e2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu">直接方法:</strong>以声明方式对道具工作做出反应。这意味着您不能直接调用它们。你改变道具，它就会触发反应采取行动。有时您可能希望直接调用本机函数。您使用RCT外部方法来导出这些方法。看看下面的locateUser函数:</p><pre class="kj kk kl km gt mc md me mf aw mg bi"><span id="3ddd" class="mh mi it md b gy mj mk l ml mm"><strong class="md iu">// Objective-C<br/></strong>@interface RCT_EXTERN_MODULE(MapViewController, RCTViewManager)</span><span id="889d" class="mh mi it md b gy nj mk l ml mm">  RCT_EXPORT_VIEW_PROPERTY(mapMarkers, NSArray)<br/>  RCT_EXPORT_VIEW_PROPERTY(onMapReady, RCTDirectEventBlock)<br/>  RCT_EXTERN_METHOD(locateUser:(nonnull NSArray *)location resolve:(RCTPromiseResolveBlock)resolve reject:(RCTPromiseRejectBlock)reject)</span><span id="26a5" class="mh mi it md b gy nj mk l ml mm">@end</span><span id="8d4c" class="mh mi it md b gy nj mk l ml mm"><strong class="md iu">// Swift</strong></span><span id="45c8" class="mh mi it md b gy nj mk l ml mm">// View Controller<br/><a class="ae ky" href="http://twitter.com/objc" rel="noopener ugc nofollow" target="_blank">@objc</a>(MyViewController)<br/>class MapViewController: RCTViewManager {</span><span id="f6d6" class="mh mi it md b gy nj mk l ml mm"><br/>    <a class="ae ky" href="http://twitter.com/objc" rel="noopener ugc nofollow" target="_blank">@objc</a> func locateUser(_ location:NSArray, resolve:RCTPromiseResolveBlock, reject:RCTPromiseRejectBlock){<br/>        <br/>    }</span><span id="e374" class="mh mi it md b gy nj mk l ml mm">    override func view() -&gt; UIView? {<br/>      let mapView = MapView()<br/>      return mapView</span><span id="a919" class="mh mi it md b gy nj mk l ml mm">    }</span><span id="728f" class="mh mi it md b gy nj mk l ml mm">}</span><span id="13bb" class="mh mi it md b gy nj mk l ml mm">//View</span><span id="073f" class="mh mi it md b gy nj mk l ml mm">class GenericMap: UIView{<br/>    @objc var mapMarkers: NSArray = []<br/></span><span id="78c2" class="mh mi it md b gy nj mk l ml mm">}</span></pre><h2 id="fe16" class="mh mi it bd mo np nq dn ms nr ns dp mw li nt nu my lm nv nw na lq nx ny nc nz bi translated"><strong class="ak">无头本机模块</strong></h2><p id="aeac" class="pw-post-body-paragraph kz la it lb b lc ne ju le lf nf jx lh li ng lk ll lm nh lo lp lq ni ls lt lu im bi translated">我不确定它们是否被称为无头本机模块，我指的是非UI本机模块。它们通常不是JSX模块。它们是你可以直接调用的。所以它们的使用和定义与UI模块中的“locateUser”方法完全一样。他们使用RCT外部模块导出模块，使用RCT外部方法导出方法。无头本机模块的一个例子是音频管理器或通知管理器。它们是使用“react-native”库的NativeModules对象调用的。</p><p id="9168" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">因为您直接调用函数，并且它们在本机执行，所以您希望这是异步完成的。所以我们需要使用回调或承诺。如果你看看“locateUser”函数有2个React(如果你没注意到的话，RCT是React的前缀)对象RCTPromiseResolveBlock和RCTPromiseRejectBlock。它们必须是这些函数的最后两个参数，按照这个顺序。因此，当您完成本机执行时，您将调用这些函数中的一个来触发它的JavaScript对应物。</p><p id="c47b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这只是React本地开发者进入Swift世界的一小步。在我对原生模块感到相对自信之前，这里介绍的概念是我必须学习的主要概念。我仍在学习Swift，并使用Android和IOS的原生模块实现React原生库。但是当我使用Xcode和Swift时，我不觉得我不知道我在做什么，因为我已经学会了一些核心概念。我们开发人员可以在途中解决剩下的问题！</p><p id="3605" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">快乐学习。</p></div></div>    
</body>
</html>