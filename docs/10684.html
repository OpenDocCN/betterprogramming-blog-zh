<html>
<head>
<title>How to Execute Plain SQL Queries With SQLAlchemy in Python</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何用Python中的SQLAlchemy执行普通SQL查询</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/how-to-execute-plain-sql-queries-with-sqlalchemy-627a3741fdb1?source=collection_archive---------1-----------------------#2022-01-22">https://betterprogramming.pub/how-to-execute-plain-sql-queries-with-sqlalchemy-627a3741fdb1?source=collection_archive---------1-----------------------#2022-01-22</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="83e1" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">了解用Python运行SQL查询的标准方法</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/2253365dbb2a96d9d6eaadb4bd9b23cb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*evKiZC18AJdbNAs0.jpg"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">图片来自<a class="ae ky" href="https://pixabay.com/illustrations/server-servers-data-computer-5451985/" rel="noopener ugc nofollow" target="_blank"> Pixabay </a>。</p></figure><p id="9211" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在很多情况下，您不想使用<a class="ae ky" href="https://www.sqlalchemy.org/" rel="noopener ugc nofollow" target="_blank"> SQLAlchemy </a>的高级<a class="ae ky" href="https://docs.sqlalchemy.org/en/13/orm/" rel="noopener ugc nofollow" target="_blank">对象关系映射器(ORM) </a>特性，而只想执行普通的SQL查询。这对于到处都使用普通查询的遗留系统来说很常见。此外，对于面向数据分析的项目，使用普通SQL查询也更常见、更方便。对于包含大量JOIN子句和子查询的SQL查询，直接执行它们比将它们翻译成复杂的基于ORM模型的代码要简单得多。此外，我们可以将SQL查询存储在一个文件中，然后用<a class="ae ky" href="https://pypi.org/project/sqlparse/" rel="noopener ugc nofollow" target="_blank"> <em class="lv"> sqlparse </em> </a>和SQLAlchemy执行它们。</p><p id="03b4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">Python中可以用来执行普通SQL查询的工具有很多，比如<a class="ae ky" href="https://pypi.org/project/PyMySQL/" rel="noopener ugc nofollow" target="_blank"> PyMySQL </a>、<a class="ae ky" href="https://pypi.org/project/mysql-connector-python/" rel="noopener ugc nofollow" target="_blank"> mysql-connector-python </a>、<a class="ae ky" href="https://pypi.org/project/MySQL-python/" rel="noopener ugc nofollow" target="_blank"> MySQL-python </a>等。但是，建议使用SQLAlchemy来执行普通的SQL查询。这是因为SQLAlchemy非常通用，可以用于各种数据库。此外，即使你现在不愿意在你的应用程序中学习和使用ORM模型，你很可能有一天会有机会去读或写ORM代码。一旦您学会了如何使用SQLAlchemy来执行普通的SQL查询，那么探索SQLAlchemy的其他特性，包括ORM模型，将会变得更加简单。</p></div><div class="ab cl lw lx hx ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="im in io ip iq"><p id="7fa6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">对于本教程，我们需要有一个本地运行的MySQL服务器。建议使用Docker在本地启动一个MySQL容器。这样，您可以使用任何版本的MySQL，并且可以避免潜在的端口冲突。</p><pre class="kj kk kl km gt md me mf mg aw mh bi"><span id="49c3" class="mi mj it me b gy mk ml l mm mn"># Create a volume to persist the data.<br/>$ <strong class="me iu">docker volume create mysql8-data</strong></span><span id="1fa1" class="mi mj it me b gy mo ml l mm mn"># Create the container for MySQL.<br/>$ <strong class="me iu">docker run --name mysql8 -d -e MYSQL_ROOT_PASSWORD=root -p 13306:3306 -v mysql8-data:/var/lib/mysql mysql:8</strong></span><span id="a3a1" class="mi mj it me b gy mo ml l mm mn"># Connect to the local MySQL server in Docker.<br/>$ <strong class="me iu">docker exec -it mysql8 mysql -u root -proot</strong><br/>mysql&gt; SELECT VERSION();<br/>+-----------+<br/>| VERSION() |<br/>+-----------+<br/>| 8.0.27    |<br/>+-----------+<br/>1 row in set (0.00 sec)</span></pre><p id="74f7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">注意事项:</p><ul class=""><li id="6170" class="mp mq it lb b lc ld lf lg li mr lm ms lq mt lu mu mv mw mx bi translated">为MySQL容器创建并装载了一个卷，这样，即使容器重新启动，我们稍后创建的数据库和表也可以持久化。</li><li id="f0c4" class="mp mq it lb b lc my lf mz li na lm nb lq nc lu mu mv mw mx bi translated">高端口13306用于容器，以避免与系统的潜在端口冲突。如果也使用13306，请选择一个不同的。</li><li id="f9ab" class="mp mq it lb b lc my lf mz li na lm nb lq nc lu mu mv mw mx bi translated">在命令行上为<em class="lv">根</em>指定了密码。实际上，您不应该在命令行上暴露<em class="lv"> root </em>密码。并且您应该避免直接为您的应用程序使用<em class="lv"> root </em>，而是使用一个具有有限权限的帐户。</li><li id="bf8c" class="mp mq it lb b lc my lf mz li na lm nb lq nc lu mu mv mw mx bi translated"><code class="fe nd ne nf me b">docker exec</code>用于直接启动Docker容器内的MySQL控制台。这样我们就不需要在本地安装MySQL客户端了。您可以在这个控制台中执行下面介绍的SQL查询，以检查我们稍后将对表进行的更新。</li></ul></div><div class="ab cl lw lx hx ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="im in io ip iq"><p id="fbe4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果我们只想执行普通的SQL查询，通常已经创建了数据库和表，您只需要对表记录执行<code class="fe nd ne nf me b">SELECT/UPDATE/INSERT/DELETE</code> ( <a class="ae ky" href="https://en.wikipedia.org/wiki/Create,_read,_update_and_delete" rel="noopener ugc nofollow" target="_blank"> CRUD </a>)操作。请在上面打开的MySQL控制台中运行以下查询，为本教程准备数据库和表:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ng nh l"/></div></figure></div><div class="ab cl lw lx hx ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="im in io ip iq"><p id="4386" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在我们使用SQLAlchemy连接到我们的数据库并执行SQL查询之前，我们需要安装这个包及其依赖项。建议在虚拟环境<a class="ae ky" href="https://medium.com/codex/how-to-create-virtual-environments-with-venv-and-conda-in-python-31814c0a8ec2" rel="noopener">中安装软件包</a>，这样就不会弄乱你的系统库。你可以使用<code class="fe nd ne nf me b">venv</code>或<code class="fe nd ne nf me b">conda</code>在Python中创建一个虚拟环境。建议使用<code class="fe nd ne nf me b"><a class="ae ky" href="https://medium.com/codex/how-to-create-virtual-environments-with-venv-and-conda-in-python-31814c0a8ec2" rel="noopener">conda</a></code>创建虚拟环境，因为可以在虚拟环境中安装特定版本的Python:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ng nh l"/></div></figure><p id="3b73" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">为本教程安装的软件包:</p><ul class=""><li id="8e34" class="mp mq it lb b lc ld lf lg li mr lm ms lq mt lu mu mv mw mx bi translated">SQLAlchemy —将用于执行普通SQL查询的主包。</li><li id="7dd0" class="mp mq it lb b lc my lf mz li na lm nb lq nc lu mu mv mw mx bi translated"><a class="ae ky" href="https://pypi.org/project/PyMySQL/" rel="noopener ugc nofollow" target="_blank">PyMySQL</a>—SQLAlchemy使用它来连接MySQL数据库并与之交互，稍后将对此进行更详细的介绍。</li><li id="209b" class="mp mq it lb b lc my lf mz li na lm nb lq nc lu mu mv mw mx bi translated"><a class="ae ky" href="https://pypi.org/project/cryptography/" rel="noopener ugc nofollow" target="_blank"> <em class="lv">密码术</em> </a> —由SQLAlchemy用于认证。</li><li id="772e" class="mp mq it lb b lc my lf mz li na lm nb lq nc lu mu mv mw mx bi translated"><a class="ae ky" href="https://pypi.org/project/sqlparse/" rel="noopener ugc nofollow" target="_blank"> <em class="lv"> sqlparse </em> </a> —用于将原始字符串解析成SQL查询。</li><li id="f4a0" class="mp mq it lb b lc my lf mz li na lm nb lq nc lu mu mv mw mx bi translated"><a class="ae ky" href="https://pypi.org/project/codetiming/" rel="noopener ugc nofollow" target="_blank"> <em class="lv">代码计时</em> </a> —用于检查某段代码的执行时间。</li><li id="af76" class="mp mq it lb b lc my lf mz li na lm nb lq nc lu mu mv mw mx bi translated"><a class="ae ky" href="https://pypi.org/project/ipython/" rel="noopener ugc nofollow" target="_blank"> <em class="lv"> ipython </em> </a> —用于更方便地执行交互式python代码。</li></ul></div><div class="ab cl lw lx hx ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="im in io ip iq"><h2 id="f69b" class="mi mj it bd ni nj nk dn nl nm nn dp no li np nq nr lm ns nt nu lq nv nw nx ny bi translated"><strong class="ak">创建一个SQLAlchemy引擎和连接</strong></h2><p id="cdee" class="pw-post-body-paragraph kz la it lb b lc nz ju le lf oa jx lh li ob lk ll lm oc lo lp lq od ls lt lu im bi translated">要使用SQLAlchemy执行普通的SQL查询，我们需要首先创建一个引擎和一个连接实例。</p><p id="d226" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><a class="ae ky" href="https://docs.sqlalchemy.org/en/14/core/engines.html" rel="noopener ugc nofollow" target="_blank">引擎</a>是任何SQLAlchemy应用程序的起点。该引擎结合了一个<a class="ae ky" href="https://docs.sqlalchemy.org/en/14/core/pooling.html" rel="noopener ugc nofollow" target="_blank">池</a>和一个<a class="ae ky" href="https://docs.sqlalchemy.org/en/14/core/internals.html#sqlalchemy.engine.Dialect" rel="noopener ugc nofollow" target="_blank">方言</a>，并提供了一种连接到数据库并与之交互的方式。</p><p id="94ea" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">连接池是一组可以有效重用的活动的长期运行的数据库连接。这是必要且重要的，因为创建新连接是有开销的。通过重用池中的连接，应用程序可以工作得更快。正常情况下，可以同时创建和使用的连接数量有一个上限，我们将在后面看到。</p><p id="aa23" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">由于SQLAlchemy可以处理多种类型的数据库，因此每种类型的数据库都被视为一种方言。从技术上讲，方言定义了特定数据库的名称和底层Python<strong class="lb iu">D</strong>ATA<strong class="lb iu">b</strong>ase<strong class="lb iu">API</strong>规范(DBAPI)。比如方言可以是<code class="fe nd ne nf me b">mysql</code>、<code class="fe nd ne nf me b">postgresql</code>、<code class="fe nd ne nf me b">oracle</code>、<code class="fe nd ne nf me b">sqlite</code>等。</p><p id="4359" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">要创建引擎实例，我们需要首先定义一个数据库URL，其格式如下:</p><pre class="kj kk kl km gt md me mf mg aw mh bi"><span id="30c1" class="mi mj it me b gy mk ml l mm mn">dialect[+driver]://user:password@host:port/dbname</span></pre><ul class=""><li id="4dc5" class="mp mq it lb b lc ld lf lg li mr lm ms lq mt lu mu mv mw mx bi translated">方言——上面介绍的方言，可以是<code class="fe nd ne nf me b">mysql</code>、<code class="fe nd ne nf me b">postgresql</code>等。</li><li id="0386" class="mp mq it lb b lc my lf mz li na lm nb lq nc lu mu mv mw mx bi translated">驱动程序—用于连接数据库并与之交互的DBAPI的名称。如果未指定驱动程序，将使用默认驱动程序。对于MySQL，默认驱动是<a class="ae ky" href="https://pypi.org/project/MySQL-python/" rel="noopener ugc nofollow" target="_blank"> MySQL-Python </a>。然而，MySQL-Python不能正确支持Python3，现在应该被视为已弃用。因此，我们应该始终提供最佳实践的驱动因素。对于MySQL，常用的驱动有<a class="ae ky" href="https://docs.sqlalchemy.org/en/14/dialects/mysql.html#module-sqlalchemy.dialects.mysql.mysqldb" rel="noopener ugc nofollow" target="_blank"> mysqlclient </a>、<a class="ae ky" href="https://docs.sqlalchemy.org/en/14/dialects/mysql.html#module-sqlalchemy.dialects.mysql.pymysql" rel="noopener ugc nofollow" target="_blank"> PyMySQL </a>、<a class="ae ky" href="https://docs.sqlalchemy.org/en/14/dialects/mysql.html#module-sqlalchemy.dialects.mysql.mysqlconnector" rel="noopener ugc nofollow" target="_blank"> MySQL-Connector </a>等。一般来说，如果没有批量插入/更新，使用哪个驱动程序并不重要，只要它被积极地维护。但是，不同的驱动程序有不同的系统依赖性，有些可能无法安装在您的计算机上。如果一个驱动程序无法安装，您可以尝试安装另一个。在本教程中，我们将使用<a class="ae ky" href="https://pypi.org/project/PyMySQL/" rel="noopener ugc nofollow" target="_blank"> PyMySQL </a>，这是一个积极维护和使用的MySQL驱动程序。它可以很容易地安装在大多数系统上。如果您想了解更多关于不同驱动程序的性能，请查看<a class="ae ky" href="https://stackoverflow.com/questions/43102442/whats-the-difference-between-mysqldb-mysqlclient-and-mysql-connector-python" rel="noopener ugc nofollow" target="_blank">这个堆栈溢出讨论</a>。</li><li id="6a1a" class="mp mq it lb b lc my lf mz li na lm nb lq nc lu mu mv mw mx bi translated">用户、口令、主机、端口、数据库名-目标数据库的用户名、口令、主机名、端口和默认数据库/模式。请在实践中针对自己的案例使用相应的。</li></ul><p id="f983" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在让我们为MySQL数据库创建一个引擎，从上面的Docker容器开始:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ng nh l"/></div></figure><p id="f092" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">注意，我们可以将一组定义特殊配置的键/值对传递给<code class="fe nd ne nf me b">create_engine()</code>函数。最常用的键是<code class="fe nd ne nf me b">echo</code>，它记录引擎执行的SQL查询。它有助于调试，但是不要在生产环境中使用它。此外，对于MySQL，我们通常需要指定<code class="fe nd ne nf me b">pool_size</code>和<code class="fe nd ne nf me b">pool_recycle</code>，它们分别定义了多少个连接将在池中保持打开，以及多长时间后一个连接将被回收到池中。这样，我们可以控制活动连接的数量，并且不会有已经关闭的过时连接。这是必要的，因为如果在<a class="ae ky" href="https://docs.sqlalchemy.org/en/14/core/engines.html#sqlalchemy.create_engine.params.pool_recycle" rel="noopener ugc nofollow" target="_blank">八小时</a>内没有检测到连接活动，MySQL会自动断开连接。</p><p id="1046" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">创建了引擎实例后，我们可以从它创建一个<a class="ae ky" href="https://docs.sqlalchemy.org/en/14/core/connections.html#sqlalchemy.engine.Connection" rel="noopener ugc nofollow" target="_blank">连接</a>实例。我们不应该直接使用引擎执行SQL查询，而应该通过连接实例来执行，该实例为包装的DBAPI连接提供高级功能。</p><p id="9483" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">用<code class="fe nd ne nf me b">Engine.connect()</code>方法创建一个连接对象。创建的连接对象是从前面介绍的连接池中签出的单个DBAPI连接。当连接关闭时，它将被回收到池中，以便重新使用。通过重用池中已经创建的连接，我们节省了每次创建新连接的开销，这是相当繁重的。您可以尝试先建立一个连接，然后关闭它，然后再次创建一个新的连接。第二次应该比第一次快得多，因为连接是直接从池中签出的。</p><p id="8a78" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们用代码测试一下。您可以复制以下代码并在iPython中运行它:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ng nh l"/></div></figure><p id="adbf" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们可以看到，第二个连接的创建速度比第一个快得多。这是因为第二个是直接从池中获取的，它存储在内存中以便有效地重用。如果您的数据库是远程数据库，时差会更明显。要了解Python中的<a class="ae ky" href="https://lynn-kwong.medium.com/stop-using-print-in-your-python-code-for-logging-use-the-logging-module-like-a-pro-66fb0427d636" rel="noopener">日志</a>和<a class="ae ky" href="https://medium.com/codex/learn-more-than-the-basics-about-the-date-time-and-timezone-in-python-b88e6a1071fc" rel="noopener">定时器</a>的更多信息，请查看链接中的相应文章。</p></div><div class="ab cl lw lx hx ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="im in io ip iq"><p id="6aef" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">既然我们已经学习了如何创建引擎和连接，现在我们可以开始执行普通的SQL查询了。</p><p id="9d56" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">虽然在遗留系统中经常使用，但是直接向<code class="fe nd ne nf me b">Connection.execute()</code>传递一个普通字符串是<a class="ae ky" href="https://docs.sqlalchemy.org/en/14/core/connections.html#sqlalchemy.engine.Connection.execute" rel="noopener ugc nofollow" target="_blank">不赞成的</a>，我们应该使用<code class="fe nd ne nf me b"><a class="ae ky" href="https://docs.sqlalchemy.org/en/14/core/sqlelement.html#sqlalchemy.sql.expression.text" rel="noopener ugc nofollow" target="_blank">text()</a></code>来指定一个普通的SQL查询字符串。让我们试着从上面创建的<code class="fe nd ne nf me b">product_stocks</code>表中选择:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ng nh l"/></div></figure><p id="f6b6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">请注意，如果模式与在<code class="fe nd ne nf me b">db_url</code>中指定的模式相同，您可以在普通SQL查询中省略数据库名称，在MySQL中称为<a class="ae ky" href="https://dev.mysql.com/doc/refman/8.0/en/system-schema.html#:~:text=The%20mysql%20schema%20is%20the,used%20for%20other%20operational%20purposes." rel="noopener ugc nofollow" target="_blank">模式</a>。然而，通常我们在一个MySQL数据库中会有不止一个模式。因此，为了清晰起见，建议总是在普通SQL查询中指定模式。</p><p id="7117" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">此外，我们需要在使用后关闭连接，以便它可以被回收<br/>回池中。通过这种方式，其他进程可以更有效地重用该连接，正如上面所证明的那样。作为替代，我们可以把它放在一个<code class="fe nd ne nf me b">with()</code>上下文块中，这样在里面的代码被执行后，连接可以自动关闭。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ng nh l"/></div></figure><p id="c24e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">建议使用<code class="fe nd ne nf me b">with()</code>上下文管理器创建一个连接，这样您就不会忘记最后关闭连接。</p><p id="b5a8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">通常，我们需要向普通的SQL查询传递一些参数，以便根据指定的条件只选择一些行。这可以通过<code class="fe nd ne nf me b"><a class="ae ky" href="https://docs.sqlalchemy.org/en/14/core/sqlelement.html#sqlalchemy.sql.expression.TextClause.bindparams" rel="noopener ugc nofollow" target="_blank">TextClause.bindparams()</a></code>方法完成。顺便提一下，<code class="fe nd ne nf me b">text()</code>构造返回一个<code class="fe nd ne nf me b"><a class="ae ky" href="https://docs.sqlalchemy.org/en/14/core/sqlelement.html#sqlalchemy.sql.expression.TextClause" rel="noopener ugc nofollow" target="_blank">TextClause</a></code>对象，它代表SQlAlchemy中的一个文本SQL文本片段。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ng nh l"/></div></figure><p id="b618" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">用<code class="fe nd ne nf me b">text()</code>指定参数的语法是<code class="fe nd ne nf me b">= :VAR_NAME</code>。注意冒号放在等号后面，冒号后面没有空格！<code class="fe nd ne nf me b">VAR_NAME</code>可以是Python中任何有效的变量名。变量名用于在使用<code class="fe nd ne nf me b">Connection.execute()</code>方法执行查询时指定一个值。</p><p id="0305" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">正如我们看到的，用这种语法指定多个参数并不方便。事实上，我们不应该在这些场合使用<code class="fe nd ne nf me b">text()</code>和<code class="fe nd ne nf me b">Connection.execute()</code>，因为这里可以找到<a class="ae ky" href="https://docs.sqlalchemy.org/en/14/core/connections.html#sqlalchemy.engine.Connection.execute.params.*multiparams/**params" rel="noopener ugc nofollow" target="_blank"/>。相反，对于这些情况，我们应该使用<code class="fe nd ne nf me b"><a class="ae ky" href="https://docs.sqlalchemy.org/en/14/core/connections.html#sqlalchemy.engine.Connection.exec_driver_sql" rel="noopener ugc nofollow" target="_blank">Connection.exec_driver_sql()</a></code>。</p></div><div class="ab cl lw lx hx ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="im in io ip iq"><p id="595a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">对于<code class="fe nd ne nf me b">Connection.exec_driver_sql()</code>，我们不传递一个由<code class="fe nd ne nf me b">text()</code>构造的<code class="fe nd ne nf me b">TextClause</code>对象，而是直接传递一个普通的SQL查询。此外，我们可以使用字典来指定参数，并使用字典列表来支持多执行。</p><p id="a0ea" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe nd ne nf me b">Connection.exec_driver_sql()</code>对于有多个参数的<code class="fe nd ne nf me b">SELECT</code>查询非常有用，对于通常有多个参数的<code class="fe nd ne nf me b">INSERT/UPDATE</code>查询也非常有用。让我们在实践中看到它。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ng nh l"/></div></figure><p id="487a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">干杯，成功了！如果你不熟悉Python中的百分号(%)字符串格式，可以看看<a class="ae ky" href="https://medium.com/codex/special-python-string-formatting-in-logging-and-pint-unit-conversion-fddb51f3d03a" rel="noopener">这篇文章</a>。特别是，请注意无论值的类型是什么，在普通SQL查询中总是使用<code class="fe nd ne nf me b">%()s</code>。SQLAlchemy自动处理这些类型。</p><p id="06e4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们可以在普通SQL查询中使用其他运算符，而不仅仅是等号(=)运算符:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ng nh l"/></div></figure><p id="5064" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">对于要检查的值列表，就像使用<code class="fe nd ne nf me b">IN</code>操作符一样，我们可以传递一个列表或一组元素。</p></div><div class="ab cl lw lx hx ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="im in io ip iq"><p id="ba7c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们现在已经介绍了如何在不同的场合执行普通SELECT查询，这也是使用SQLAlchemy执行普通SQL查询的最常见用例。然而，在实际情况中，您可能还想执行普通的<code class="fe nd ne nf me b">INSERT/UPDATE/DELETE</code>查询。现在就让我们来探索一下。</p><p id="1c34" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">执行普通<code class="fe nd ne nf me b">INSERT/UPDATE/DELETE</code>查询的语法与上面介绍的使用<code class="fe nd ne nf me b">Connection.exec_driver_sql()</code>的语法非常相似。例如，让我们在表中插入一条新记录:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ng nh l"/></div></figure><p id="70bb" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">使用上面的代码，我们在<code class="fe nd ne nf me b">product_stocks</code>表中插入了一个新行。特别是<code class="fe nd ne nf me b">lastrowid</code>返回最后插入行的主键的值。</p><p id="9926" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们可以通过传入字典列表来插入多行:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ng nh l"/></div></figure><p id="d526" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在让我们尝试更新一行:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ng nh l"/></div></figure><p id="194a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这是删除一行的方法:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ng nh l"/></div></figure><p id="138f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在我们进入关于如何执行存储在文件中的SQL查询的下一节之前，让我们检查一个MySQL特有的特性。如果要插入的记录已经存在于数据库中，您将得到重复条目错误:</p><pre class="kj kk kl km gt md me mf mg aw mh bi"><span id="1631" class="mi mj it me b gy mk ml l mm mn">IntegrityError: (pymysql.err.IntegrityError) (1062, "<strong class="me iu">Duplicate entry </strong>'Cellphone-2022-01-10 08:00:00' for key 'product_stocks.uq_category_check_time'")</span></pre><p id="57fc" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">您可以通过在数据库中插入一条带有现有<code class="fe nd ne nf me b">category</code>和<code class="fe nd ne nf me b">check_time</code>的记录来重现此错误。这将触发该错误，因为<code class="fe nd ne nf me b">category</code>和<code class="fe nd ne nf me b">check_time</code>是表<code class="fe nd ne nf me b">data.product_stocks</code>中的唯一键。</p><p id="b31d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">为了解决这个问题，我们可以使用<code class="fe nd ne nf me b"><a class="ae ky" href="https://dev.mysql.com/doc/refman/8.0/en/insert-on-duplicate.html" rel="noopener ugc nofollow" target="_blank">ON DUPLICATE KEY UPDATE</a></code>语法:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ng nh l"/></div></figure><p id="c508" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">您现在可以多次执行这个查询，不会出现“重复输入”错误。</p></div><div class="ab cl lw lx hx ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="im in io ip iq"><p id="c8b5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">最后，让我们看看如何执行存储在文本文件中的多个SQL查询。如果您希望使用CRON作业或Airflow重复执行一些SQL查询，这非常有用。作为数据工程师或数据科学家，您可能会发现它在您的工作中非常方便。</p><p id="1aed" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">要从一个文本文件执行多个SQL查询，我们需要使用本教程开始时安装在我们的虚拟环境中的<a class="ae ky" href="https://pypi.org/project/sqlparse/" rel="noopener ugc nofollow" target="_blank"> <em class="lv"> sqlparse </em> </a>模块。<em class="lv"> sqlparse </em>可以从字符串中剥离注释，并将其拆分成多个可以单独执行的SQL查询:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ng nh l"/></div></figure><p id="c963" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如前所述，我们可以使用<code class="fe nd ne nf me b">sqlparse.format()</code>从原始字符串中提取注释，然后使用<code class="fe nd ne nf me b">sqlparse.split()</code>将其分割成多个可执行的普通SQL查询。</p><p id="a23d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们将用于演示的<a class="ae ky" href="https://gist.github.com/lynnkwong/3e2c7c48d3152897fbca6d91885c3aea" rel="noopener ugc nofollow" target="_blank">虚拟SQL文件</a>的内容如下:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ng nh l"/></div></figure><p id="8462" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在让我们使用<em class="lv"> sqlparse </em>来解析文件，然后使用SQLAlchemy来执行查询。注意，由于我们通常不需要为存储在文件中的SQL查询传递参数，我们可以使用本教程前面介绍的<code class="fe nd ne nf me b">text()</code>构造。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ng nh l"/></div></figure><p id="13d1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">请注意，我们在创建引擎时添加了<code class="fe nd ne nf me b">echo=True</code>,因此执行的查询可以在控制台中打印出来:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ng nh l"/></div></figure><p id="1008" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">干杯！我们现在已经成功地执行了文本文件中存储的所有SQL查询。</p></div><div class="ab cl lw lx hx ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="im in io ip iq"><p id="a4ba" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在本文中，我们介绍了SQLAlchemy的基本概念，以及如何使用<code class="fe nd ne nf me b">Connection.execute()</code>和<code class="fe nd ne nf me b">Connection.exec_driver_sql()</code>方法执行普通的<a class="ae ky" href="https://en.wikipedia.org/wiki/Create,_read,_update_and_delete" rel="noopener ugc nofollow" target="_blank"> CRUD </a> SQL查询。重要的是，您还学习了如何使用<code class="fe nd ne nf me b">sqlparse</code>来解析文件中的原始数据，并生成可执行的普通SQL查询。这种技术对于数据管道和分析非常方便，尤其是对于遗留系统。</p><p id="7393" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">掌握了本教程的知识，你应该有足够的信心在Python中使用数据库，并且为学习更高级的对象相关映射器(ORM)做好了充分的准备，这些将在后面的教程中介绍。稍后您会发现，我们可以使用ORM以更方便、更Pythonic化的方式与数据库交互。</p></div><div class="ab cl lw lx hx ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="im in io ip iq"><p id="4215" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">相关文章:</p><ul class=""><li id="7248" class="mp mq it lb b lc ld lf lg li mr lm ms lq mt lu mu mv mw mx bi translated"><a class="ae ky" href="https://lynn-kwong.medium.com/learn-the-basics-and-get-started-with-sqlalchemy-orm-from-scratch-66c8624b069?source=your_stories_page----------------------------------------" rel="noopener">学习基础知识并开始使用SQLAlchemy ORM </a></li></ul></div></div>    
</body>
</html>