<html>
<head>
<title>GraphQL, and the end of shared client-side model objects</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">GraphQL和共享客户端模型对象的结束</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/graphql-and-the-end-of-shared-client-side-model-objects-fefc73f1b508?source=collection_archive---------1-----------------------#2019-05-07">https://betterprogramming.pub/graphql-and-the-end-of-shared-client-side-model-objects-fefc73f1b508?source=collection_archive---------1-----------------------#2019-05-07</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="03a2" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">如何使用GraphQL、React和Swift来准确获取您的应用程序所需的内容</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/00568b713f9164c9d41244c4a7cc32ec.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*niUzqPxCttyKet0gsKZSdg.jpeg"/></div></div></figure><p id="b626" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">在传统的客户机-服务器开发中，客户机端模型通常与服务器端模型没有太大的不同。</p><p id="bdb7" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">他们应该吗？</p><p id="febf" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">标准的RESTful API可能会序列化服务器端用户模型，如下所示:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="lq lr l"/></div></figure><p id="d717" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">同一用户模型类型的实例可以通过多种途径出售，例如:</p><ol class=""><li id="46a2" class="ls lt it kw b kx ky la lb ld lu lh lv ll lw lp lx ly lz ma bi translated"><code class="fe mb mc md me b">/me</code> —返回当前认证用户的路由</li><li id="647e" class="ls lt it kw b kx mf la mg ld mh lh mi ll mj lp lx ly lz ma bi translated"><code class="fe mb mc md me b">/friends</code> —返回当前用户好友的路线</li></ol><p id="9225" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">RESTful APIs本质上不是类型安全的，所以前端开发人员通常会通过查看API文档(并希望它是准确的)，或者通过观察HTTP流量本身来了解这些路由都返回相同的<code class="fe mb mc md me b">User</code>类型的对象。</p><p id="93d1" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">认识到这一点后，可以将类似下面的类型定义手动添加到客户端应用程序中，当解析来自这两种途径之一的响应体时，可以填充它的实例:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="lq lr l"/></div></figure><p id="1b2c" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">这个共享的、规范的<code class="fe mb mc md me b">User</code>模型可以被前端应用程序中需要用户属性子集的任何部分使用。您可以很容易地在客户端键值存储或关系数据库中缓存这些<code class="fe mb mc md me b">User</code>实例。</p><p id="ffd3" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">假设您的应用程序包括以下功能(并且复杂性在不断增加):</p><ol class=""><li id="9dd9" class="ls lt it kw b kx ky la lb ld lu lh lv ll lw lp lx ly lz ma bi translated">呈现用户配置文件(需要所有用户属性)</li><li id="8a16" class="ls lt it kw b kx mf la mg ld mh lh mi ll mj lp lx ly lz ma bi translated">查看朋友列表(仅需要用户名和头像)</li><li id="4886" class="ls lt it kw b kx mf la mg ld mh lh mi ll mj lp lx ly lz ma bi translated">在导航中显示当前用户的头像(只需要头像)</li></ol><p id="99dc" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">您的服务器最初将从所有这些要素的路径返回相同的用户有效负载，但这不会扩展得特别好。具有大量属性的模型对于渲染完整的简档是必要的，但是在渲染一长串用户的名字和头像时会有问题。当用户的大部分属性被忽略时，序列化一个完整的用户是不必要的，甚至是一个性能瓶颈。</p><p id="c25d" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">也许您的API开发人员改变了您的服务器，只从<code class="fe mb mc md me b">/friends</code>路径返回用户属性的子集。接下来是对API文档的更改，希望您的前端工程师会注意到，这时他们会向客户端代码库添加一个新的类型。也许这种新类型看起来像:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="lq lr l"/></div></figure><p id="caba" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">此时，您的前端需要:</p><p id="48ba" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">1.在处理HTTP响应<br/> 2时，跟踪哪些路由出售<code class="fe mb mc md me b">User</code>实例与<code class="fe mb mc md me b">SimpleUser</code>实例。更新其缓存逻辑以支持这两种不同的类型</p><p id="9d5f" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated"><code class="fe mb mc md me b">User</code> vs. <code class="fe mb mc md me b">SimpleUser</code>无可否认是一个粗糙而肤浅的区别。如果我们在混合物中加入第三种口味，我们会合理地给它起什么名字？</p><p id="1c74" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">不叫<code class="fe mb mc md me b">SimpleUser</code>，我们可以把这种新型号叫做<code class="fe mb mc md me b">FriendListUser</code>，以它所提供的功能命名。为每个用例建立单独的用户模型是一种更具可扩展性的方法——我们可能会有很多不同的版本，它们的名字都比“简单”更准确地传达了意图:</p><ul class=""><li id="8ee9" class="ls lt it kw b kx ky la lb ld lu lh lv ll lw lp ml ly lz ma bi translated"><code class="fe mb mc md me b">FriendListUser</code></li><li id="917d" class="ls lt it kw b kx mf la mg ld mh lh mi ll mj lp ml ly lz ma bi translated"><code class="fe mb mc md me b">EditAccountUser</code></li><li id="97dc" class="ls lt it kw b kx mf la mg ld mh lh mi ll mj lp ml ly lz ma bi translated"><code class="fe mb mc md me b">ProfileUser</code></li><li id="169e" class="ls lt it kw b kx mf la mg ld mh lh mi ll mj lp ml ly lz ma bi translated"><code class="fe mb mc md me b">LoggedOutProfileUser</code></li></ul><p id="b45d" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">这里的风险是，在跟踪哪些路线出售哪些模型，以及在建模前端持久层时如何理解所有这些不同的变量方面，我们可能会产生大量的开销。</p><p id="c5d0" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">通过将我们的客户端类型定义更紧密地耦合到我们的API规范来减少这种开销将是朝着正确方向迈出的一大步。<a class="ae mm" href="https://graphql.org" rel="noopener ugc nofollow" target="_blank"> GraphQL </a>就是一个帮助实现这一点的工具。</p><h2 id="55ee" class="mn mo it bd mp mq mr dn ms mt mu dp mv ld mw mx my lh mz na nb ll nc nd ne nf bi translated">GraphQL</h2><p id="fb87" class="pw-post-body-paragraph ku kv it kw b kx ng ju kz la nh jx lc ld ni lf lg lh nj lj lk ll nk ln lo lp im bi translated">GraphQL有很多令人喜欢的地方——如果你想要一个全面的概述，我建议你查看一下官方文档。</p><p id="6ddd" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">相对于传统RESTful接口的一个优势是GraphQL服务器提供强类型模式。这些模式可以通过编程方式进行自省，使您的API通过default⁴.实现自文档化但是这是一篇关于客户端模型的文章，而不是避免陈旧的文档。</p><p id="63fb" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">更高的模型特异性带来了更高的清晰度和效率，主要的缺点是维护大量模型所涉及的额外工作。让我们更深入地探讨代码生成如何减轻这种负面影响。</p><p id="ddba" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">通过内省两者:</p><ol class=""><li id="da2e" class="ls lt it kw b kx ky la lb ld lu lh lv ll lw lp lx ly lz ma bi translated">我们后端API的强类型模式</li><li id="53dc" class="ls lt it kw b kx mf la mg ld mh lh mi ll mj lp lx ly lz ma bi translated">我们前端应用的数据需求</li></ol><p id="0762" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">我们可以轻松地为每个单独的用例生成定制的客户端模型。</p><p id="e793" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">首先，我们必须了解GraphQL查询是如何工作的。在传统的RESTful API服务器中，相同的路由总是出售相同的模型。假设我们的GraphQL服务器公开了以下两个查询:</p><ol class=""><li id="81df" class="ls lt it kw b kx ky la lb ld lu lh lv ll lw lp lx ly lz ma bi translated"><code class="fe mb mc md me b">me: User</code></li><li id="4141" class="ls lt it kw b kx mf la mg ld mh lh mi ll mj lp lx ly lz ma bi translated"><code class="fe mb mc md me b">friends: [User]</code></li></ol><p id="5330" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">虽然两个查询公开了相同的服务器端<code class="fe mb mc md me b">User</code>模型，但是客户机指定了它感兴趣的属性子集，并且只返回这些属性。我们的前端可能会进行以下查询:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="lq lr l"/></div></figure><p id="be38" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">服务器将只返回上面指定的属性，即使服务器端用户模型包含的属性比实际请求的多得多。</p><p id="f841" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">类似地，该查询将返回不同的子集:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="lq lr l"/></div></figure><p id="ec77" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">代码生成工具可以自省这些客户端查询以及API模式定义，以便:</p><ol class=""><li id="8e96" class="ls lt it kw b kx ky la lb ld lu lh lv ll lw lp lx ly lz ma bi translated">确保只查询有效的属性(甚至直接在IDE中，在编译时验证API调用)</li><li id="6824" class="ls lt it kw b kx mf la mg ld mh lh mi ll mj lp lx ly lz ma bi translated">生成特定于每个不同查询的客户端模型</li></ol><p id="3834" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">在这种情况下，生成的模型将如下所示:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="lq lr l"/></div></figure><p id="92f5" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">我们的应用程序的每个组件现在都可以提供一个完全适合他们需求的模型，而不需要我们自己维护所有这些类型变化的开销。</p><h2 id="0ef3" class="mn mo it bd mp mq mr dn ms mt mu dp mv ld mw mx my lh mz na nb ll nc nd ne nf bi translated">组件树、查询树</h2><p id="6755" class="pw-post-body-paragraph ku kv it kw b kx ng ju kz la nh jx lc ld ni lf lg lh nj lj lk ll nk ln lo lp im bi translated">像<a class="ae mm" href="https://reactjs.org" rel="noopener ugc nofollow" target="_blank"> React </a>和<a class="ae mm" href="https://developer.apple.com/documentation/uikit" rel="noopener ugc nofollow" target="_blank"> UIKit </a>这样的用户界面库允许将封装的组件组合成一个复杂的层次结构。每个组件都有自己的状态需求，其他组件在理想情况下不需要关心这些需求。</p><p id="f394" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">这与传统的RESTful API开发不一致，在传统的RESTful API开发中，单个路由通常会返回大量数据，用于填充组件树的整个分支，而不仅仅是单个节点。</p><p id="d730" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">GraphQL查询片段更好地促进了组件<em class="mk">和</em>的协同定位，它们的数据需求:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="lq lr l"/></div></figure><p id="d6c2" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">这就产生了一个“查询层次结构”,它与我们的组件层次结构更加一致。</p><p id="e38f" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">正如UI渲染层将遍历组件树以布局我们的完整接口层次结构一样，GraphQL网络层将把查询和片段聚合到一个单一的、合并的有效负载中，以便从我们的服务器请求。</p><h2 id="1f70" class="mn mo it bd mp mq mr dn ms mt mu dp mv ld mw mx my lh mz na nb ll nc nd ne nf bi translated">异构缓存变得简单</h2><p id="db9e" class="pw-post-body-paragraph ku kv it kw b kx ng ju kz la nh jx lc ld ni lf lg lh nj lj lk ll nk ln lo lp im bi translated">GraphQL是一种高级查询语言；虽然您可以使用它来查询GraphQL <em class="mk">服务器</em>，但是客户端库，如<a class="ae mm" href="https://www.apollographql.com" rel="noopener ugc nofollow" target="_blank"> Apollo </a>和<a class="ae mm" href="https://facebook.github.io/relay/" rel="noopener ugc nofollow" target="_blank"> Relay </a>可以充当网络和可选本地cache⁵.之上的抽象层</p><p id="26f7" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">(此外，Apollo和Relay还处理代码生成和前面章节中概述的查询片段统一💫)</p><p id="9b41" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">传统的客户端-服务器应用程序通常以如下所示的逻辑结束:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="lq lr l"/></div></figure><p id="9354" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">在本例中，我们通过两种不同的机制查询同一个用户:针对本地数据库的SQL和针对远程服务器的URL编码的查询字符串。</p><p id="efda" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">Apollo和类似的库允许我们以一种统一的方式更明确地指定我们需要的数据。这一级别的抽象让我们可以委派繁重的工作——检查我们的请求是否可以完全从缓存中完成，如果不能，就增加额外的远程数据。</p><p id="bbb1" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">继续我们的例子:如果您首先进行一个<code class="fe mb mc md me b">friends</code>查询，那么您的缓存用户将只包含<code class="fe mb mc md me b">firstName</code>、<code class="fe mb mc md me b">lastName</code>和<code class="fe mb mc md me b">avatar.thumbnail</code>属性。对这些相同用户之一的后续<code class="fe mb mc md me b">me</code>查询将访问服务器，以便“填充”附加属性— <code class="fe mb mc md me b">location</code>和<code class="fe mb mc md me b">avatar.large</code>。从这一点开始，后续的<code class="fe mb mc md me b">friends</code>或<code class="fe mb mc md me b">me</code>查询可以避免网络往返altogether⁵.</p><p id="e31b" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">只要两个用户模型具有相同的惟一标识符，那么它们的属性的哪个子集以什么顺序被获取并不重要。阿波罗会帮我们把它们正常化。</p><p id="fc96" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">听起来很神奇？不管是好是坏，当然可以。像所有高层次的抽象一样，当它工作时令人惊奇，当它不工作时令人恼火。</p><p id="697d" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">但这就是GraphQL的承诺；<strong class="kw iu">当一个类型化的模式定义是建立在其上的基础的时候，天空就是工具的极限</strong>。这种性质的工具可以建立一个前提，否则这个前提看起来会非常笨拙——为每一个微小的用例变化建立一个不同的客户端模型类型——不仅可以实现，而且是理想的。</p></div><div class="ab cl nl nm hx nn" role="separator"><span class="no bw bk np nq nr"/><span class="no bw bk np nq nr"/><span class="no bw bk np nq"/></div><div class="im in io ip iq"><p id="ce24" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">[1]:如果它是使用类似于<a class="ae mm" href="https://swagger.io" rel="noopener ugc nofollow" target="_blank"> Swagger </a>的东西生成的，可能性更大；如果您的API工程师手动尽最大努力使它保持最新，可能性更小。</p><p id="74ee" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">[2]:例如，想象一下一个脸书用户包含多少属性。</p><p id="2092" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">[3]:更不用说，不尊重你的用户的时间<em class="mk">和</em>蜂窝数据计划。</p><p id="4001" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">[4]:像<a class="ae mm" href="https://github.com/graphql/graphiql" rel="noopener ugc nofollow" target="_blank"> GraphiQL </a>这样的工具可以让你准确地看到每个GraphiQL查询所提供的服务器端模型。</p><p id="b40e" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">[5]:当然，这取决于您的缓存策略。</p></div></div>    
</body>
</html>