<html>
<head>
<title>How to Test If Your Swift Classes Are Thread-safe: Before and After Actors</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何测试您的Swift类是否是线程安全的:Actors之前和之后</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/how-to-test-if-your-swift-classes-are-thread-safe-before-and-after-actors-efc743f27da4?source=collection_archive---------1-----------------------#2021-12-10">https://betterprogramming.pub/how-to-test-if-your-swift-classes-are-thread-safe-before-and-after-actors-efc743f27da4?source=collection_archive---------1-----------------------#2021-12-10</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="8a9a" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">线程安全资源测试和参与者</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/173576e2b21ec0430ff436469b2a28c0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*Mag9DDZUncv-mgY4"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">泰勒·希瑞在<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的照片</p></figure><p id="8e7d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在开发大型应用程序时，我们经常需要在不同的组件之间共享数据。无论是模块还是屏幕，它们都需要从同一个数据源读取和写入数据。</p><p id="59af" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这就引入了一个问题:如果在不同的<a class="ae ky" href="https://en.wikipedia.org/wiki/Thread_(computing)" rel="noopener ugc nofollow" target="_blank">线程</a>中使用相同的日期结构，我们需要确保它们不会同时访问数据。否则，我们可能会引发不同的问题:</p><ol class=""><li id="057b" class="lv lw it lb b lc ld lf lg li lx lm ly lq lz lu ma mb mc md bi translated">更新可能以不同的顺序到达(只有当我们重视排序时才是一个问题)。</li><li id="7f1f" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated">我们可能会错过一些更新。</li><li id="1230" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated">应用程序可能会崩溃。</li></ol><p id="c94a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">当一个数据结构以防止这些问题的方式实现时，我们称之为<a class="ae ky" href="https://en.wikipedia.org/wiki/Thread_safety" rel="noopener ugc nofollow" target="_blank">线程安全</a>数据结构。</p><p id="8ea4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在所有iOS版本中，都有各种方法来保证线程安全。从Swift 5.5开始，<code class="fe mj mk ml mm b">actors</code>把这个权力直接交给编译器。然而，<a class="ae ky" href="https://www.swiftbysundell.com/special/swift-concurrency-backward-compatibility/" rel="noopener ugc nofollow" target="_blank"> actors也将只在iOS 13中可用，在Xcode 13.2发布之后</a>。</p><p id="9ee0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在今天的文章中，我将展示如何测试兼容所有iOS版本的线程安全存储。之后，我们将看到如何通过使用actors来简化测试和代码。</p><h1 id="931b" class="mn mo it bd mp mq mr ms mt mu mv mw mx jz my ka mz kc na kd nb kf nc kg nd ne bi translated">基本存储行为</h1><p id="f75c" class="pw-post-body-paragraph kz la it lb b lc nf ju le lf ng jx lh li nh lk ll lm ni lo lp lq nj ls lt lu im bi translated">让我们从定义基本的<code class="fe mj mk ml mm b">Storage</code>接口开始。我们需要为一个键设置一个值，并检索与该键相关联的值。</p><p id="e08a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们想要应用<a class="ae ky" href="https://en.wikipedia.org/wiki/Test-driven_development" rel="noopener ugc nofollow" target="_blank">测试驱动开发</a> (TDD)方法，所以让我们开始编写我们的第一个测试:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nk nl l"/></div></figure><p id="5b9b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这是我们可以为<code class="fe mj mk ml mm b">get</code>操作编写的最简单的测试。</p><p id="649e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">测试不会构建，因为<code class="fe mj mk ml mm b">Storage</code>类还不存在。所以，还是写出来让测试通过吧。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nk nl l"/></div></figure><p id="75d4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这是通过测试所需的最少代码。记住，在TDD中，我们遵循三个步骤:</p><ol class=""><li id="5099" class="lv lw it lb b lc ld lf lg li lx lm ly lq lz lu ma mb mc md bi translated">我们创建了一个失败的测试。</li><li id="e4ec" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated">我们编写最少的代码来使它通过。</li><li id="52e8" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated">最后，我们重构代码，使其更具可读性和可维护性。</li></ol><p id="45af" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">对<code class="fe mj mk ml mm b">get</code>方法的测试现在通过了。让我们为<code class="fe mj mk ml mm b">set</code>方法添加一个新的测试。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nk nl l"/></div></figure><p id="49cd" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这个测试不会编译，因为<code class="fe mj mk ml mm b">Storage</code>没有<code class="fe mj mk ml mm b">set</code>方法。让我们用运行这个类所需的最少代码来更新它。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nk nl l"/></div></figure><p id="1ba7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们正在保存一个从<code class="fe mj mk ml mm b">nil</code>开始的<code class="fe mj mk ml mm b">String</code>。如果我们进行测试，他们都会通过。这是一个重要的观察:使用TDD，我们增加了功能，确保我们以前实现的功能继续工作。</p><p id="daae" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在第三个测试中，我们测试我们可以添加多对<key value="">，并且我们可以为正确的键检索正确的值。</key></p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nk nl l"/></div></figure><p id="e100" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在这个测试中，我们使用随机值来防止我们自己使用硬编码值。如果我们现在运行测试，它会失败，因为我们一次只记忆一个值，而第二个<code class="fe mj mk ml mm b">set</code>会改变存储的值。</p><p id="1693" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们可以更新我们的类型，使用字典将值与键关联起来。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nk nl l"/></div></figure><p id="e744" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">有了这个改变，所有的测试都通过了。</p><p id="7b70" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们对这个班的基本表现感到满意。现在让我们检查线程安全。</p><h1 id="e692" class="mn mo it bd mp mq mr ms mt mu mv mw mx jz my ka mz kc na kd nb kf nc kg nd ne bi translated">添加线程安全</h1><p id="fd9d" class="pw-post-body-paragraph kz la it lb b lc nf ju le lf ng jx lh li nh lk ll lm ni lo lp lq nj ls lt lu im bi translated">为了在测试中模拟多线程环境，我们可以在一个<code class="fe mj mk ml mm b"><a class="ae ky" href="https://developer.apple.com/documentation/dispatch/dispatchqueue" rel="noopener ugc nofollow" target="_blank">DispatchQueue</a></code>上异步调度多个作业，并使用一个<code class="fe mj mk ml mm b"><a class="ae ky" href="https://developer.apple.com/documentation/dispatch/dispatchgroup" rel="noopener ugc nofollow" target="_blank">DispatchGroup</a></code>来等待它们完成。这些API是名为<a class="ae ky" href="https://developer.apple.com/documentation/dispatch" rel="noopener ugc nofollow" target="_blank">大中央调度</a> (GCD)的框架的一部分。</p><p id="a0f4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">测试看起来像这样:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nk nl l"/></div></figure><p id="0702" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">该测试由以下模块组成:</p><ol class=""><li id="df68" class="lv lw it lb b lc ld lf lg li lx lm ly lq lz lu ma mb mc md bi translated">我们声明了<code class="fe mj mk ml mm b">sut</code>、<code class="fe mj mk ml mm b">dispatchGroup</code>和<code class="fe mj mk ml mm b">expectation</code>。需要<code class="fe mj mk ml mm b">expectation</code>等待，直到所有线程都完成。</li><li id="1bc9" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated">我们通过在一个循环中使用<code class="fe mj mk ml mm b">DispatchQueue.global().async</code>函数来创建100个线程。在分派工作单元之前，我们使用<code class="fe mj mk ml mm b">dispatchGroup.enter()</code>函数登记到组中。</li><li id="14b2" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated">线程工作是<code class="fe mj mk ml mm b">set</code>存储中的一个键值对。设置好之后，我们就<code class="fe mj mk ml mm b">exit</code>离组了。</li><li id="d798" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated">最后，我们要求该组等待，直到其中的所有线程都终止它们的工作。这是使用<code class="fe mj mk ml mm b">dispatchGroup.notify()</code>功能完成的。一旦发生这种情况，我们就实现了期望。</li><li id="3ecb" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated">在最后一步中，我们断言所有的键都已经插入到<code class="fe mj mk ml mm b">Storage</code>中。</li></ol><p id="c2bd" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果我们现在运行测试，它们将崩溃并显示以下错误</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nm"><img src="../Images/06ac3f6fb5fe2f929e5b7d20c107cc27.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*q-ims4jHTTLfwm5ePD-DpQ.png"/></div></div></figure><p id="2e90" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">多个线程同时试图<code class="fe mj mk ml mm b">set</code>字典<strong class="lb iu">中的一个值</strong>而Swift不知道怎么做。</p><p id="5fe5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">为了解决这个问题，我们需要更新我们的存储代码。有多种方法可以实现线程安全。最简单、可读性更好的方法是通过使用私有的<code class="fe mj mk ml mm b">DispatchQueue</code>来同步对资源的访问:默认情况下，调度队列一次执行一个操作，直到前一个操作结束，才会执行其他操作。采用的策略是<em class="nn">“先进先出”</em> (FIFO):首先到达的请求被服务。</p><p id="6ffb" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">代码现在看起来像这样:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nk nl l"/></div></figure><p id="734a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在第4行中，我们声明了一个私有的<code class="fe mj mk ml mm b">DispatchQueue</code>，并将其命名为<code class="fe mj mk ml mm b">storage.synchronization</code>。我们在第7行使用它，将<code class="fe mj mk ml mm b">set</code>主体包装到<code class="fe mj mk ml mm b">sync</code>方法中。</p><p id="d1e1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果我们现在运行测试，它们不会崩溃。</p><h2 id="c09b" class="no mo it bd mp np nq dn mt nr ns dp mx li nt nu mz lm nv nw nb lq nx ny nd nz bi translated">确保一致性</h2><p id="0f9b" class="pw-post-body-paragraph kz la it lb b lc nf ju le lf ng jx lh li nh lk ll lm ni lo lp lq nj ls lt lu im bi translated">虽然代码现在看起来很好，很稳定，没有崩溃，但我们仍然有一个一致性问题。想象一下，我们想要:</p><ol class=""><li id="e3a4" class="lv lw it lb b lc ld lf lg li lx lm ly lq lz lu ma mb mc md bi translated">读取一个值。</li><li id="dca0" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated">修改一下。</li><li id="a058" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated">再储存一次。</li></ol><p id="c148" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果另一个线程在步骤1和步骤2之间更改了与同一个键相关联的值，会发生什么情况？第一个线程将更新旧值，而第二个线程的更新将丢失。</p><p id="583d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们可以用下面的测试来测试这个用例:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nk nl l"/></div></figure><p id="f4ac" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">测试有点复杂，所以我们一步一步来分析。</p><ol class=""><li id="ad5c" class="lv lw it lb b lc ld lf lg li lx lm ly lq lz lu ma mb mc md bi translated">代码的第一部分用一百个键值对准备测试变量和<code class="fe mj mk ml mm b">Storage</code>。</li><li id="f58f" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated">然后我们创建一个组，通过添加<code class="fe mj mk ml mm b">_read</code>后缀来更新这些值。为了实现这一点，我们输入一个<code class="fe mj mk ml mm b">dispatchGroup</code>，我们执行工作，然后离开。</li><li id="b692" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated">我们创建第二组线程，将后缀<code class="fe mj mk ml mm b">_disturb</code>附加到同一个键值对，同时模拟一系列并发更新。</li><li id="f447" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated">我们创建一个<code class="fe mj mk ml mm b">expectation</code>，然后等待<code class="fe mj mk ml mm b">dispatchGroup</code>结束。</li><li id="f5f7" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated">最后，我们写出我们的断言。这两组线程同时运行，所以我们不知道它们将以何种顺序执行。无论我们先执行“追加<code class="fe mj mk ml mm b">_read</code>”还是先执行“追加<code class="fe mj mk ml mm b">disturb</code>”，断言都会通过。我们不能接受两个操作中有一个丢失。</li></ol><p id="e980" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果我们现在运行测试，它们可能会崩溃，并出现我们在设置值时遇到的相同错误。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi oa"><img src="../Images/cb20b9153ae56afe39566c26758be4af.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*7yQvryG2pcoNMz_ZQXkHNA.png"/></div></div></figure><p id="772e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">多个线程试图从字典中读取，而其他线程试图写入字典。斯威夫特又一次不知道如何应对。我们可以将读取操作包装在对<code class="fe mj mk ml mm b">dispatchQueue</code>的<code class="fe mj mk ml mm b">sync</code>调用中。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nk nl l"/></div></figure><p id="4382" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">唯一的变化发生在第13行:我们将读取操作包装在了<code class="fe mj mk ml mm b">sync</code>方法中(<code class="fe mj mk ml mm b">sync</code>方法可以返回其闭包返回的相同值)。</p><p id="a6fc" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果我们现在运行测试，它们不会崩溃，但也不会通过。断言失败:我们正在丢失一些操作，因为来自不同组的线程读取相同的变量，然后它们试图更新它们。为了解决这个问题，我们需要引入一个不同的操作:<code class="fe mj mk ml mm b">update</code>。</p><p id="3c66" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">该操作需要一个闭包，其中<code class="fe mj mk ml mm b">Storage</code>将值传递给闭包。然后，调用者可以在锁定的上下文中操作，这可以防止其他线程访问它。</p><p id="c72f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们首先更新测试，遵循TDD方法:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nk nl l"/></div></figure><p id="bd1b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">测试完全相同，但是我们用<code class="fe mj mk ml mm b">update</code>操作替换了<code class="fe mj mk ml mm b">get</code>和<code class="fe mj mk ml mm b">set</code>操作。</p><p id="a941" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">代码不会构建，因为我们在类中缺少方法。补充一下吧。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nk nl l"/></div></figure><p id="e892" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如上所述，update函数接受我们想要更新的<code class="fe mj mk ml mm b">key</code>和一个闭包，该闭包为那个键提供一个新值，传递旧值(如果存在的话)。然后，闭包的结果被设置为新值。一切都包裹在<code class="fe mj mk ml mm b">dispatchQueue.sync</code>方法中，以确保线程安全。</p><p id="8c88" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果我们最终现在运行测试，测试套件就通过了。</p><h1 id="23b2" class="mn mo it bd mp mq mr ms mt mu mv mw mx jz my ka mz kc na kd nb kf nc kg nd ne bi translated">使用演员</h1><p id="1b9d" class="pw-post-body-paragraph kz la it lb b lc nf ju le lf ng jx lh li nh lk ll lm ni lo lp lq nj ls lt lu im bi translated">从iOS 15开始，我们可以使用<code class="fe mj mk ml mm b">actor</code> s. Actors确保操作在其中以受控和序列化的方式运行。</p><p id="8b11" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们将<code class="fe mj mk ml mm b">Storage</code>的类型从<code class="fe mj mk ml mm b">class</code>改为<code class="fe mj mk ml mm b">actor</code>:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nk nl l"/></div></figure><p id="9651" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">编译器开始在<code class="fe mj mk ml mm b">actor</code>和测试代码中抛出不同种类的错误。让我们从分析<code class="fe mj mk ml mm b">actor</code>的错误开始:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ob"><img src="../Images/313366c11b0877a667030f8327bc4a98.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*05g6zI3nx-xhgZcc0nwGbg.png"/></div></div></figure><p id="8dac" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">一个<code class="fe mj mk ml mm b">actor</code>已经在内部调度队列中运行，它不允许我们将它的操作调度给另一个。编译器建议我们移除私有的<code class="fe mj mk ml mm b">dispatchQueue</code>:我们不再需要它了。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nk nl l"/></div></figure><p id="f004" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">然后，我们在测试中有一堆错误。可以在<a class="ae ky" href="https://www.avanderlee.com/swift/nonisolated-isolated/" rel="noopener ugc nofollow" target="_blank">隔离上下文</a>中使用:这些是由运行时控制的异步上下文。要修复这些错误，我们必须执行以下步骤:</p><ol class=""><li id="f9db" class="lv lw it lb b lc ld lf lg li lx lm ly lq lz lu ma mb mc md bi translated">所有的测试方法必须变成<code class="fe mj mk ml mm b">async</code>。</li><li id="d1ce" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated">所有的<code class="fe mj mk ml mm b">get</code>和<code class="fe mj mk ml mm b">set</code>调用都必须以<code class="fe mj mk ml mm b">await</code>为前缀。</li><li id="affc" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated">如果测试使用了一个<code class="fe mj mk ml mm b">DispatchGroup</code>，那么必须使用<code class="fe mj mk ml mm b"><a class="ae ky" href="https://developer.apple.com/documentation/swift/3814991-withtaskgroup" rel="noopener ugc nofollow" target="_blank">withTaskGroup</a></code> API将它转换成一个<code class="fe mj mk ml mm b"><a class="ae ky" href="https://developer.apple.com/documentation/swift/taskgroup" rel="noopener ugc nofollow" target="_blank">TaskGroup</a></code>。</li></ol><p id="5ca5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们单独看看每个测试。</p><h2 id="e5c3" class="no mo it bd mp np nq dn mt nr ns dp mx li nt nu mz lm nv nw nb lq nx ny nd nz bi translated">测试获取</h2><p id="dbcc" class="pw-post-body-paragraph kz la it lb b lc nf ju le lf ng jx lh li nh lk ll lm ni lo lp lq nj ls lt lu im bi translated">新的测试代码如下:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nk nl l"/></div></figure><p id="834b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们应用了转换列表的第1步和第2步:我们将方法标记为<code class="fe mj mk ml mm b">async</code>，我们将<code class="fe mj mk ml mm b">get</code>提取到单独的一行中，我们在<code class="fe mj mk ml mm b">get</code>调用前添加了<code class="fe mj mk ml mm b">await</code>关键字。</p><h2 id="6ef5" class="no mo it bd mp np nq dn mt nr ns dp mx li nt nu mz lm nv nw nb lq nx ny nd nz bi translated">测试设置和获取</h2><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nk nl l"/></div></figure><p id="9a02" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">该测试更新为上一个测试。我们将测试标记为<code class="fe mj mk ml mm b">async</code>，并添加了<code class="fe mj mk ml mm b">set</code>调用。<code class="fe mj mk ml mm b">set</code>和<code class="fe mj mk ml mm b">get</code>都标有<code class="fe mj mk ml mm b">await</code>关键字，以使它们能够与新的并发范例一起工作。</p><h2 id="0b29" class="no mo it bd mp np nq dn mt nr ns dp mx li nt nu mz lm nv nw nb lq nx ny nd nz bi translated">测试SetMultipleValues</h2><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nk nl l"/></div></figure><p id="0db2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这个测试和它的孪生测试非常相似:我们<code class="fe mj mk ml mm b">set</code>两个不同的变量，然后我们<code class="fe mj mk ml mm b">get</code>它们。正如我们之前所做的，我们将该方法标记为<code class="fe mj mk ml mm b">async</code>，并将<code class="fe mj mk ml mm b">await</code>关键字用于所有的<code class="fe mj mk ml mm b">get</code>和<code class="fe mj mk ml mm b">set</code>操作。</p><h2 id="43df" class="no mo it bd mp np nq dn mt nr ns dp mx li nt nu mz lm nv nw nb lq nx ny nd nz bi translated">测试并发集</h2><p id="aa04" class="pw-post-body-paragraph kz la it lb b lc nf ju le lf ng jx lh li nh lk ll lm ni lo lp lq nj ls lt lu im bi translated">这个测试要求我们使用第三个转换步骤。在这个测试中，我们需要将一个<code class="fe mj mk ml mm b">DispatchGroup</code>转换成一个<code class="fe mj mk ml mm b">TaskGroup</code>。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nk nl l"/></div></figure><p id="b2da" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">新测试比原来的测试更短:只有15行，而原来是22行。我们能够丢弃<code class="fe mj mk ml mm b">expectation</code>，因为我们能够<code class="fe mj mk ml mm b">TaskGroup</code>完成<code class="fe mj mk ml mm b">await</code>。</p><p id="b7df" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe mj mk ml mm b">withTaskGroup</code> API提供了一个组来添加异步操作。这些是并发执行的，在<code class="fe mj mk ml mm b">withTaskGroup</code>函数之前的<code class="fe mj mk ml mm b">await</code>关键字允许我们等待它们全部执行。</p><h2 id="5276" class="no mo it bd mp np nq dn mt nr ns dp mx li nt nu mz lm nv nw nb lq nx ny nd nz bi translated">测试并发更新</h2><p id="8e73" class="pw-post-body-paragraph kz la it lb b lc nf ju le lf ng jx lh li nh lk ll lm ni lo lp lq nj ls lt lu im bi translated">在最后一个测试中，我们并行运行了两个任务组。我们使用<code class="fe mj mk ml mm b">async let</code>语法来声明我们可以并发执行的两个变量:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nk nl l"/></div></figure><p id="df21" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">新的测试比原来的短:36行对44行。我们既不需要<code class="fe mj mk ml mm b">DispatchGroup</code>也不需要<code class="fe mj mk ml mm b">expectation</code>，相反，我们使用<code class="fe mj mk ml mm b">withTaskGroup</code> API创建<code class="fe mj mk ml mm b">TaskGroups</code>，并将这些组存储在一些特定的变量中。<code class="fe mj mk ml mm b">group1</code>和<code class="fe mj mk ml mm b">group2</code>变量是<code class="fe mj mk ml mm b">async let</code>:我们将它们的评估和计算延迟到我们需要它们的时候。</p><p id="8bcb" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在第28行我们<code class="fe mj mk ml mm b">await</code>了由两个组组成的数组，要求系统实际执行它们。</p><p id="6590" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在所有这些转变之后，所有的考验都将通过。</p><h1 id="fc3f" class="mn mo it bd mp mq mr ms mt mu mv mw mx jz my ka mz kc na kd nb kf nc kg nd ne bi translated">结论</h1><p id="9105" class="pw-post-body-paragraph kz la it lb b lc nf ju le lf ng jx lh li nh lk ll lm ni lo lp lq nj ls lt lu im bi translated">在今天的文章中，我们评估了如何创建线程安全的数据结构，实现基本的读、写和更新操作。我们应用了测试驱动开发，并且我们探索了在使用线程安全数据结构时所面临的典型问题。</p><p id="30b8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">然后，我们探索了如何创建复杂的测试来检查多线程环境中最常见的问题:崩溃和更新丢失。一旦我们写下了这些测试，我们也有了一些防止回归的安全网。由于这些测试，类似的问题在未来不会发生。</p><p id="4712" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">最后，我们探索了新的<code class="fe mj mk ml mm b">actor</code>类型，并分析了如何将一个测试套件从Grand Central Dispatch (GCD)模型转换为新的async-await模型。更新后，代码看起来更简单、更优雅。</p></div></div>    
</body>
</html>